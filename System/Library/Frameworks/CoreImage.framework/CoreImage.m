uint64_t get_int(const char *a1, uint64_t a2)
{
  char *v4;
  void *v6;

  v4 = getenv(a1);
  if (v4)
    return atoi(v4);
  if (userDefaults(void)::didCheck != -1)
    dispatch_once(&userDefaults(void)::didCheck, &__block_literal_global_171);
  v6 = (void *)objc_msgSend((id)userDefaults(void)::defaults, "objectForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return objc_msgSend(v6, "intValue");
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return objc_msgSend(v6, "intValue");
  else
    return a2;
}

uint64_t register_more_builtins(uint64_t a1)
{
  void *v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  _BYTE v11[128];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (register_more_builtins(void({block_pointer})(NSString *))::onceToken != -1)
    dispatch_once(&register_more_builtins(void({block_pointer})(NSString *))::onceToken, &__block_literal_global_723);
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  v2 = (void *)register_more_builtins(void({block_pointer})(NSString *))::moreList;
  result = objc_msgSend((id)register_more_builtins(void({block_pointer})(NSString *))::moreList, "countByEnumeratingWithState:objects:count:", &v7, v11, 16);
  if (result)
  {
    v4 = result;
    v5 = *(_QWORD *)v8;
    do
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v8 != v5)
          objc_enumerationMutation(v2);
        (*(void (**)(uint64_t, _QWORD))(a1 + 16))(a1, *(_QWORD *)(*((_QWORD *)&v7 + 1) + 8 * v6++));
      }
      while (v4 != v6);
      result = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v7, v11, 16);
      v4 = result;
    }
    while (result);
  }
  return result;
}

uint64_t ___ZL23classNameIsSystemFilterP8NSString_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = objc_msgSend(*(id *)(a1 + 32), "isEqualToString:", a2);
  if ((_DWORD)result)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
  return result;
}

void ___ZL22register_more_builtinsU13block_pointerFvP8NSStringE_block_invoke()
{
  NSObject *v0;
  void *v1;
  int has_internal_content;
  char *v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t j;
  NSString *v25;
  NSObject *v26;
  NSObject *v27;
  uint64_t v28;
  const char *v29;
  const char *v30;
  char *v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t k;
  NSString *v36;
  Class v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  id obj;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  _QWORD v50[2];
  void (*v51)(uint64_t);
  void *v52;
  void *v53;
  void *v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  _QWORD v59[2];
  void (*v60)(uint64_t);
  void *v61;
  void *v62;
  void *v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  _BYTE v72[128];
  uint8_t v73[128];
  uint8_t buf[4];
  uint64_t v75;
  _BYTE v76[128];
  _BYTE v77[128];
  _QWORD v78[6];

  v78[3] = *MEMORY[0x1E0C80C00];
  v0 = ci_signpost_log_filter();
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_1921E4000, v0, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LoadMoreFilters", (const char *)&unk_192520C83, buf, 2u);
  }
  v1 = (void *)objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
  has_internal_content = os_variant_has_internal_content();
  v3 = getenv("CI_FILTERS_DIR");
  v4 = v3;
  if (!v3 || *v3 != 48 || v3[1])
  {
    obj = (id)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v5 = *MEMORY[0x1E0C99A00];
    v78[0] = *MEMORY[0x1E0C99A90];
    v78[1] = v5;
    v78[2] = *MEMORY[0x1E0C99A28];
    v6 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v78, 3);
    if (v4)
      v7 = has_internal_content;
    else
      v7 = 0;
    if (v7 == 1)
    {
      v70 = 0u;
      v71 = 0u;
      v68 = 0u;
      v69 = 0u;
      v8 = (void *)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v4), "componentsSeparatedByString:", CFSTR(","));
      v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v68, v77, 16);
      if (v9)
      {
        v10 = *(_QWORD *)v69;
        do
        {
          for (i = 0; i != v9; ++i)
          {
            if (*(_QWORD *)v69 != v10)
              objc_enumerationMutation(v8);
            objc_msgSend(obj, "addObjectsFromArray:", objc_msgSend(v1, "contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:", objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:isDirectory:", *(_QWORD *)(*((_QWORD *)&v68 + 1) + 8 * i), 1), v6, 7, 0));
          }
          v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v68, v77, 16);
        }
        while (v9);
      }
    }
    objc_msgSend(obj, "addObjectsFromArray:", objc_msgSend(v1, "contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:", objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:isDirectory:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "/System/Library/CoreImage"), 1), v6, 7, 0));
    if (has_internal_content)
    {
      v12 = objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:isDirectory:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "/AppleInternal/Library/CoreImage"), 1);
      if (v12)
        objc_msgSend(obj, "addObjectsFromArray:", objc_msgSend(v1, "contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:", v12, v6, 7, 0));
    }
    register_more_builtins(void({block_pointer})(NSString *))::moreList = (uint64_t)objc_alloc_init(MEMORY[0x1E0C99DE8]);
    v13 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v66 = 0u;
    v67 = 0u;
    v64 = 0u;
    v65 = 0u;
    v14 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v64, v76, 16);
    if (v14)
    {
      v15 = *(_QWORD *)v65;
      v41 = *(_QWORD *)v65;
      v42 = v13;
      do
      {
        v16 = 0;
        v43 = v14;
        do
        {
          if (*(_QWORD *)v65 != v15)
            objc_enumerationMutation(obj);
          v17 = *(void **)(*((_QWORD *)&v64 + 1) + 8 * v16);
          if (objc_msgSend((id)objc_msgSend(v17, "pathExtension"), "isEqualToString:", CFSTR("cifilter")))
          {
            v18 = objc_msgSend(v17, "lastPathComponent");
            if (objc_msgSend(v13, "containsObject:", v18))
            {
              NSLog(CFSTR("A filter bundle with the same name has already been registered so %@ will be ignored."), objc_msgSend(v17, "path"));
            }
            else
            {
              objc_msgSend(v13, "addObject:", v18);
              v19 = ci_signpost_log_filter();
              if ((unint64_t)v17 + 1 >= 2)
              {
                v38 = v19;
                if (os_signpost_enabled(v19))
                {
                  v39 = objc_msgSend((id)objc_msgSend(v17, "lastPathComponent"), "UTF8String");
                  *(_DWORD *)buf = 136446210;
                  v75 = v39;
                  _os_signpost_emit_with_name_impl(&dword_1921E4000, v38, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v17, "LoadFilter", "%{public}s", buf, 0xCu);
                }
              }
              v44 = v16;
              v59[0] = MEMORY[0x1E0C809B0];
              v59[1] = 3221225472;
              v60 = ___ZL22register_more_builtinsU13block_pointerFvP8NSStringE_block_invoke_737;
              v61 = &unk_1E2EC3DE0;
              v62 = v17;
              v63 = v17;
              v20 = (void *)objc_msgSend(MEMORY[0x1E0CB34D0], "bundleWithURL:", v17);
              v21 = (void *)objc_msgSend(v20, "objectForInfoDictionaryKey:", CFSTR("CIFilterList"));
              if (objc_msgSend(v21, "count"))
              {
                v57 = 0u;
                v58 = 0u;
                v55 = 0u;
                v56 = 0u;
                v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v55, v73, 16);
                if (v22)
                {
                  v23 = *(_QWORD *)v56;
                  do
                  {
                    for (j = 0; j != v22; ++j)
                    {
                      if (*(_QWORD *)v56 != v23)
                        objc_enumerationMutation(v21);
                      v25 = *(NSString **)(*((_QWORD *)&v55 + 1) + 8 * j);
                      if ((objc_msgSend((id)register_more_builtins(void({block_pointer})(NSString *))::moreList, "containsObject:", v25) & 1) != 0|| NSClassFromString(v25))
                      {
                        NSLog(CFSTR("The filter '%@' in %@ has already been registered so this bundle will be ignored."), v25, objc_msgSend(v17, "path"));
                      }
                    }
                    v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v55, v73, 16);
                  }
                  while (v22);
                }
                v26 = ci_signpost_log_filter();
                if ((unint64_t)v17 + 1 >= 2)
                {
                  v27 = v26;
                  if (os_signpost_enabled(v26))
                  {
                    v28 = objc_msgSend((id)objc_msgSend(v17, "lastPathComponent"), "UTF8String");
                    *(_DWORD *)buf = 136446210;
                    v75 = v28;
                    _os_signpost_emit_with_name_impl(&dword_1921E4000, v27, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v17, "BundleLoad", "%{public}s", buf, 0xCu);
                  }
                }
                v50[0] = MEMORY[0x1E0C809B0];
                v50[1] = 3221225472;
                v51 = ___ZL22register_more_builtinsU13block_pointerFvP8NSStringE_block_invoke_742;
                v52 = &unk_1E2EC3DE0;
                v53 = v17;
                v54 = v17;
                v29 = (const char *)objc_msgSend((id)objc_msgSend(v20, "executablePath"), "UTF8String");
                v30 = v29;
                if (v29 && !dlopen(v29, 1))
                {
                  v31 = dlerror();
                  v32 = "";
                  if (v31)
                    v32 = v31;
                  NSLog(CFSTR("The executable for the bundle at %s failed to load: %s"), v30, v32);
                }
                v51((uint64_t)v50);
                v48 = 0u;
                v49 = 0u;
                v46 = 0u;
                v47 = 0u;
                v33 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v46, v72, 16);
                if (v33)
                {
                  v34 = *(_QWORD *)v47;
                  do
                  {
                    for (k = 0; k != v33; ++k)
                    {
                      if (*(_QWORD *)v47 != v34)
                        objc_enumerationMutation(v21);
                      v36 = *(NSString **)(*((_QWORD *)&v46 + 1) + 8 * k);
                      v37 = NSClassFromString(v36);
                      if (objc_msgSend((id)register_more_builtins(void({block_pointer})(NSString *))::moreList, "containsObject:", v36))
                      {
                        NSLog(CFSTR("The filter '%@' in the bundle at %@ has already been registered."), v36, objc_msgSend(v17, "path"));
                      }
                      else if (v37)
                      {
                        if ((-[objc_class isSubclassOfClass:](v37, "isSubclassOfClass:", objc_opt_class()) & 1) != 0)
                          objc_msgSend((id)register_more_builtins(void({block_pointer})(NSString *))::moreList, "addObject:", v36);
                        else
                          NSLog(CFSTR("The filter '%@' in the bundle at %@ is not a subclass of CIFilter so it will not be registered."), v36, objc_msgSend(v17, "path"));
                      }
                      else
                      {
                        NSLog(CFSTR("The filter '%@' is not implemented in the bundle at %@."), v36, objc_msgSend(v17, "path"));
                      }
                    }
                    v33 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v46, v72, 16);
                  }
                  while (v33);
                }
              }
              v60((uint64_t)v59);
              v13 = v42;
              v14 = v43;
              v15 = v41;
              v16 = v44;
            }
          }
          ++v16;
        }
        while (v16 != v14);
        v40 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v64, v76, 16);
        v14 = v40;
      }
      while (v40);
    }
  }
  ___ZL22register_more_builtinsU13block_pointerFvP8NSStringE_block_invoke_724();
}

void sub_1921E71B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43)
{
  _Unwind_Resume(exception_object);
}

uint64_t ci_signpost_log_filter()
{
  if (ci_signpost_log_filter_onceToken != -1)
    dispatch_once(&ci_signpost_log_filter_onceToken, &__block_literal_global_13_0);
  return ci_signpost_log_filter_log;
}

NSUInteger getCustomAttributes(objc_class *a1)
{
  NSObject *v2;
  SEL v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSDictionary *v8;
  NSUInteger v9;
  NSString *v10;
  _QWORD block[6];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  void (*v16)(uint64_t, uint64_t);
  void (*v17)(uint64_t);
  uint64_t v18;

  if (!-[objc_class isSubclassOfClass:](a1, "isSubclassOfClass:", objc_opt_class()))
    return 0;
  v13 = 0;
  v14 = &v13;
  v15 = 0x3052000000;
  v16 = __Block_byref_object_copy__8;
  v17 = __Block_byref_object_dispose__8;
  v18 = 0;
  v2 = filterRegistryIsolationQueue();
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZL19getCustomAttributesP10objc_class_block_invoke;
  block[3] = &unk_1E2EC3D38;
  block[4] = a1;
  block[5] = &v13;
  dispatch_sync(v2, block);
  v3 = NSSelectorFromString(CFSTR("customAttributes"));
  v4 = -[objc_class methodForSelector:](a1, "methodForSelector:", v3);
  v5 = +[CIFilter methodForSelector:](CIFilter, "methodForSelector:", v3);
  v6 = -[objc_class instanceMethodForSelector:](a1, "instanceMethodForSelector:", v3);
  v7 = +[CIFilter instanceMethodForSelector:](CIFilter, "instanceMethodForSelector:", v3);
  if (v4 == v5)
  {
    if (v6 != v7)
    {
      v10 = NSStringFromClass(a1);
      NSLog(CFSTR("%@ -customAttributes is not supported on iOS. Implement +customAttributes instead."), v10);
    }
    v8 = 0;
  }
  else
  {
    v8 = (NSDictionary *)-[objc_class customAttributes](a1, "customAttributes");
  }
  v9 = objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  mergeDictionaries(v9, v8);
  mergeDictionaries(v9, (NSDictionary *)v14[5]);

  _Block_object_dispose(&v13, 8);
  return v9;
}

void sub_1921E79CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1921E7B84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t filterRegistryIsolationQueue(void)
{
  unsigned __int8 v0;
  _QWORD *v1;
  int v3;
  NSObject *v4;

  if ((v0 & 1) == 0)
  {
    if (v3)
    {
      v4 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
      filterRegistryIsolationQueue(void)::isolationQueue = (uint64_t)dispatch_queue_create("com.apple.coreimage.CIFilterRegistryIsolation", v4);
    }
  }
  return v1[62];
}

__CFString *classNameFromTypeEncoding(__CFString *result)
{
  __CFString *v1;
  __CFString *v2;
  int v3;

  if (result)
  {
    v1 = result;
    result = (__CFString *)-[__CFString length](result, "length");
    if (result)
    {
      v2 = result;
      v3 = -[__CFString characterAtIndex:](v1, "characterAtIndex:", 0);
      if ((unint64_t)v2 >= 4 && v3 == 64)
      {
        return (__CFString *)-[__CFString substringWithRange:](v1, "substringWithRange:", 2, (char *)&v2[-1].length + 5);
      }
      else if (v2 == (__CFString *)1 && (objc_msgSend(CFSTR("iIsSlLqQBfdcC"), "containsString:", v1) & 1) != 0)
      {
        return CFSTR("__WrappedNSNumber");
      }
      else if (-[__CFString isEqualToString:](v1, "isEqualToString:", CFSTR("@")))
      {
        return CFSTR("NSObject");
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t getStdAttrsForKey(NSString *a1)
{
  void *v2;
  const __CFString **v3;
  const __CFString **v4;
  uint64_t v5;
  _QWORD v7[2];
  _QWORD v8[2];
  _QWORD v9[2];
  _QWORD v10[2];
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFString *v14;
  _QWORD v15[5];
  _QWORD v16[5];
  _QWORD v17[7];
  _QWORD v18[7];
  _QWORD v19[6];
  _QWORD v20[7];

  v20[6] = *MEMORY[0x1E0C80C00];
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("inputIntensity")))
  {
    v19[0] = CFSTR("CIAttributeMin");
    v19[1] = CFSTR("CIAttributeSliderMin");
    v20[0] = &unk_1E2F19B50;
    v20[1] = &unk_1E2F19B50;
    v19[2] = CFSTR("CIAttributeSliderMax");
    v19[3] = CFSTR("CIAttributeDefault");
    v20[2] = &unk_1E2F19B60;
    v20[3] = &unk_1E2F19B60;
    v19[4] = CFSTR("CIAttributeIdentity");
    v19[5] = CFSTR("CIAttributeType");
    v20[4] = &unk_1E2F19B50;
    v20[5] = CFSTR("CIAttributeTypeScalar");
    v2 = (void *)MEMORY[0x1E0C99D80];
    v3 = (const __CFString **)v20;
    v4 = (const __CFString **)v19;
    v5 = 6;
    return objc_msgSend(v2, "dictionaryWithObjects:forKeys:count:", v3, v4, v5);
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("inputTime")))
  {
    v17[0] = CFSTR("CIAttributeMin");
    v17[1] = CFSTR("CIAttributeMax");
    v18[0] = &unk_1E2F19B50;
    v18[1] = &unk_1E2F19B60;
    v17[2] = CFSTR("CIAttributeSliderMin");
    v17[3] = CFSTR("CIAttributeSliderMax");
    v18[2] = &unk_1E2F19B50;
    v18[3] = &unk_1E2F19B60;
    v17[4] = CFSTR("CIAttributeDefault");
    v17[5] = CFSTR("CIAttributeIdentity");
    v18[4] = &unk_1E2F19B50;
    v18[5] = &unk_1E2F19B50;
    v17[6] = CFSTR("CIAttributeType");
    v18[6] = CFSTR("CIAttributeTypeTime");
    v2 = (void *)MEMORY[0x1E0C99D80];
    v3 = (const __CFString **)v18;
    v4 = (const __CFString **)v17;
    v5 = 7;
    return objc_msgSend(v2, "dictionaryWithObjects:forKeys:count:", v3, v4, v5);
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("inputAngle")))
  {
    v15[0] = CFSTR("CIAttributeSliderMin");
    v15[1] = CFSTR("CIAttributeSliderMax");
    v16[0] = &unk_1E2F19B70;
    v16[1] = &unk_1E2F19B80;
    v15[2] = CFSTR("CIAttributeDefault");
    v15[3] = CFSTR("CIAttributeIdentity");
    v16[2] = &unk_1E2F19B50;
    v16[3] = &unk_1E2F19B50;
    v15[4] = CFSTR("CIAttributeType");
    v16[4] = CFSTR("CIAttributeTypeAngle");
    v2 = (void *)MEMORY[0x1E0C99D80];
    v3 = (const __CFString **)v16;
    v4 = (const __CFString **)v15;
    v5 = 5;
    return objc_msgSend(v2, "dictionaryWithObjects:forKeys:count:", v3, v4, v5);
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("inputImage"))
    || -[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("inputMaskImage"))
    || -[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("inputBackgroundImage"))
    || -[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("inputShadingImage"))
    || -[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("inputTargetImage")))
  {
    v13 = CFSTR("CIAttributeType");
    v14 = CFSTR("CIAttributeTypeImage");
    v2 = (void *)MEMORY[0x1E0C99D80];
    v3 = &v14;
    v4 = &v13;
LABEL_13:
    v5 = 1;
    return objc_msgSend(v2, "dictionaryWithObjects:forKeys:count:", v3, v4, v5);
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("inputGradientImage")))
  {
    v11 = CFSTR("CIAttributeType");
    v12 = CFSTR("CIAttributeTypeGradient");
    v2 = (void *)MEMORY[0x1E0C99D80];
    v3 = &v12;
    v4 = &v11;
    goto LABEL_13;
  }
  if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("inputCenter")))
  {
    v9[0] = CFSTR("CIAttributeDefault");
    v9[1] = CFSTR("CIAttributeType");
    v10[0] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", 150.0, 150.0);
    v10[1] = CFSTR("CIAttributeTypePosition");
    v2 = (void *)MEMORY[0x1E0C99D80];
    v3 = (const __CFString **)v10;
    v4 = (const __CFString **)v9;
  }
  else
  {
    if (!-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("inputExtent")))
      return 0;
    v7[0] = CFSTR("CIAttributeDefault");
    v7[1] = CFSTR("CIAttributeType");
    v8[0] = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", 0.0, 0.0, 640.0, 80.0);
    v8[1] = CFSTR("CIAttributeTypeRectangle");
    v2 = (void *)MEMORY[0x1E0C99D80];
    v3 = (const __CFString **)v8;
    v4 = (const __CFString **)v7;
  }
  v5 = 2;
  return objc_msgSend(v2, "dictionaryWithObjects:forKeys:count:", v3, v4, v5);
}

NSUInteger mergeDictionaries(NSUInteger result, NSDictionary *a2)
{
  void *v3;
  NSUInteger v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  id v9;
  void *v10;
  uint64_t v11;
  void *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _BYTE v17[128];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    if (a2)
    {
      v3 = (void *)result;
      v15 = 0u;
      v16 = 0u;
      v13 = 0u;
      v14 = 0u;
      result = -[NSDictionary countByEnumeratingWithState:objects:count:](a2, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
      if (result)
      {
        v4 = result;
        v5 = *(_QWORD *)v14;
        do
        {
          v6 = 0;
          do
          {
            if (*(_QWORD *)v14 != v5)
              objc_enumerationMutation(a2);
            v7 = *(void **)(*((_QWORD *)&v13 + 1) + 8 * v6);
            if ((objc_msgSend(v7, "isEqualToString:", kCIConstructorKey) & 1) == 0)
            {
              v8 = objc_msgSend(v3, "objectForKey:", v7);
              v9 = -[NSDictionary objectForKey:](a2, "objectForKey:", v7);
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
              {
                v10 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionaryWithDictionary:", v8);
                objc_msgSend(v10, "addEntriesFromDictionary:", v9);
                v11 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithDictionary:", v10);
                v12 = v3;
              }
              else
              {
                if (!v9)
                  goto LABEL_15;
                v12 = v3;
                v11 = (uint64_t)v9;
              }
              objc_msgSend(v12, "setObject:forKey:", v11, v7);
            }
LABEL_15:
            ++v6;
          }
          while (v4 != v6);
          result = -[NSDictionary countByEnumeratingWithState:objects:count:](a2, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
          v4 = result;
        }
        while (result);
      }
    }
  }
  return result;
}

uint64_t classNameIsSystemFilter(NSString *a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZL23classNameIsSystemFilterP8NSString_block_invoke;
  v3[3] = &unk_1E2EC3E08;
  v3[4] = a1;
  v3[5] = &v4;
  register_more_builtins((uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1921E9E38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t get_BOOL(const char *a1, uint64_t a2)
{
  char *v4;
  unsigned int v5;
  void *v6;

  v4 = getenv(a1);
  if (v4)
  {
    v5 = atoi(v4);
    if (v5 <= 1)
      return v5 != 0;
  }
  else
  {
    if (userDefaults(void)::didCheck != -1)
      dispatch_once(&userDefaults(void)::didCheck, &__block_literal_global_171);
    v6 = (void *)objc_msgSend((id)userDefaults(void)::defaults, "objectForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
      return objc_msgSend(v6, "BOOLValue");
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
      return objc_msgSend(v6, "BOOLValue");
  }
  return a2;
}

CGColorSpaceRef ___ZN2CI7Context19defaultWorkingSpaceEv_block_invoke()
{
  int v0;
  CFStringRef *v1;
  CGColorSpaceRef result;

  v0 = dyld_program_sdk_at_least();
  v1 = (CFStringRef *)MEMORY[0x1E0C9D958];
  if (!v0)
    v1 = (CFStringRef *)MEMORY[0x1E0C9DA00];
  result = CGColorSpaceCreateWithName(*v1);
  CI::Context::defaultWorkingSpace(void)::space = (uint64_t)result;
  return result;
}

CGColorSpaceRef ___ZL20GetDefaultColorSpacev_block_invoke()
{
  CGColorSpaceRef result;

  if (dyld_program_sdk_at_least())
    result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  else
    result = CGColorSpaceCreateDeviceRGB();
  GetDefaultColorSpace(void)::cs = (uint64_t)result;
  return result;
}

uint64_t CI::Kernel::num_apply_arguments(CI::Kernel *this)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int type;

  if (*((_BYTE *)this + 12))
    v2 = CI::KernelArguments::count((CI::Kernel *)((char *)this + 144));
  else
    v2 = *((_DWORD *)this + 5);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = 0;
    v5 = v2;
    while (1)
    {
      if (*((_BYTE *)this + 12))
      {
        type = CI::KernelArguments::get_type((CI::Kernel *)((char *)this + 144), v3);
      }
      else
      {
        if (v3 >= *((int *)this + 5))
          goto LABEL_11;
        type = *(_DWORD *)(*((_QWORD *)this + 9) + 4 * v3);
      }
      if (type <= 29)
LABEL_11:
        v4 = (v4 + 1);
      if (v5 == ++v3)
        return v4;
    }
  }
  return 0;
}

void sub_1921EADAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CI::Object::unref(CI::Object *this)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;
  void (*v4[5])(_QWORD);

  v1 = (unsigned int *)((char *)this + 8);
  atomic_load((unsigned int *)this + 2);
  do
  {
    v2 = __ldaxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    v4[0] = (void (*)(_QWORD))MEMORY[0x1E0C809B0];
    v4[1] = (void (*)(_QWORD))0x40000000;
    v4[2] = (void (*)(_QWORD))___ZNK2CI6Object5unrefEv_block_invoke;
    v4[3] = (void (*)(_QWORD))&__block_descriptor_tmp_4_3;
    v4[4] = (void (*)(_QWORD))this;
    CI::Object::performDeferred(v4);
  }
}

uint64_t ___ZNK2CI6Object5unrefEv_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void CI::Object::performDeferred(void (**a1)(_QWORD))
{
  NSObject *specific;
  NSObject *v3;
  BOOL v4;

  specific = dispatch_get_specific(&CI::Object::_queueKey);
  v3 = dispatch_get_specific(&CI::Object::_groupKey);
  if (specific)
    v4 = v3 == 0;
  else
    v4 = 1;
  if (v4)
    a1[2](a1);
  else
    dispatch_group_async(v3, specific, a1);
}

uint64_t CI::Kernel::num_image_arguments(CI::Kernel *this)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int type;
  int v7;

  if (*((_BYTE *)this + 12))
    v2 = CI::KernelArguments::count((CI::Kernel *)((char *)this + 144));
  else
    v2 = *((_DWORD *)this + 5);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = 0;
    v5 = v2;
    while (1)
    {
      if (*((_BYTE *)this + 12))
      {
        type = CI::KernelArguments::get_type((CI::Kernel *)((char *)this + 144), v3);
      }
      else
      {
        if (v3 >= *((int *)this + 5))
          goto LABEL_13;
        type = *(_DWORD *)(*((_QWORD *)this + 9) + 4 * v3);
      }
      if (type == 1)
        goto LABEL_16;
      if (*((_BYTE *)this + 12))
      {
        v7 = CI::KernelArguments::get_type((CI::Kernel *)((char *)this + 144), v3);
        goto LABEL_15;
      }
LABEL_13:
      if (v3 >= *((int *)this + 5))
        goto LABEL_17;
      v7 = *(_DWORD *)(*((_QWORD *)this + 9) + 4 * v3);
LABEL_15:
      if (v7 == 2)
LABEL_16:
        v4 = (v4 + 1);
LABEL_17:
      if (v5 == ++v3)
        return v4;
    }
  }
  return 0;
}

uint64_t CI::KernelArguments::get_type(CI::KernelArguments *this, unsigned int a2)
{
  uint64_t result;
  uint64_t v4;
  unsigned int *v5;

  result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    v4 = *(_QWORD *)this;
    if (v4)
    {
      if (*(_DWORD *)v4 <= (signed int)a2)
      {
        return 0;
      }
      else
      {
        if (a2 > 9)
          v5 = (unsigned int *)(*(_QWORD *)(v4 + 16) + 4 * (a2 - 10));
        else
          v5 = (unsigned int *)(v4 + 4 * a2 + 24);
        return *v5;
      }
    }
  }
  return result;
}

id CIMetalCopyDefaultDevice()
{
  if (CI_ENABLE_METAL_GPU())
    return MTLCreateSystemDefaultDevice();
  else
    return 0;
}

uint64_t can_use_metal()
{
  if (can_use_metal_once != -1)
    dispatch_once(&can_use_metal_once, &__block_literal_global_14_0);
  return can_use_metal_canUse;
}

void __can_use_metal_block_invoke()
{
  id v0;
  NSObject *v1;
  NSObject *v2;

  if (CI_ENABLE_METAL_GPU())
  {
    if (CI_ENABLE_METAL_GPU())
    {
      v0 = MTLCreateSystemDefaultDevice();
      if (v0)
        can_use_metal_canUse = 1;
    }
    else
    {
      v0 = 0;
    }

    if ((can_use_metal_canUse & 1) == 0)
    {
      v2 = ci_logger_api();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        __can_use_metal_block_invoke_cold_2();
    }
  }
  else
  {
    v1 = ci_logger_api();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      __can_use_metal_block_invoke_cold_1();
  }
}

uint64_t CI_ENABLE_METAL_GPU()
{
  if (CI_ENABLE_METAL_GPU::didCheck != -1)
    dispatch_once(&CI_ENABLE_METAL_GPU::didCheck, &__block_literal_global_86);
  return CI_ENABLE_METAL_GPU::v;
}

uint64_t CIMetalDeviceIsSupported(void *a1, const char *a2)
{
  return objc_msgSend(a1, "supportsFamily:", 1002);
}

void *CIMetalCommandQueueCreate(uint64_t a1, void *a2)
{
  void *v3;
  __CFString *v4;
  void *v5;
  uint64_t v6;
  _QWORD v8[5];
  _QWORD v9[3];

  v9[2] = *MEMORY[0x1E0C80C00];
  v3 = (void *)objc_msgSend(a2, "newCommandQueue");
  if (!dyld_program_sdk_at_least())
    goto LABEL_5;
  if (isWidget_once != -1)
    dispatch_once(&isWidget_once, &__block_literal_global_47);
  if (!isWidget_bWidget)
LABEL_5:
    objc_msgSend(v3, "setBackgroundGPUPriority:", 2);
  if (CI_ENABLE_METAL_DEBUG())
  {
    if ((objc_msgSend((id)objc_msgSend((id)objc_msgSend(v3, "device"), "name"), "containsString:", CFSTR("AMD")) & 1) != 0)
    {
      v4 = CFSTR("AMDStat_GPU_Engine_Ticks");
    }
    else if ((objc_msgSend((id)objc_msgSend((id)objc_msgSend(v3, "device"), "name"), "containsString:", CFSTR("Intel")) & 1) != 0)
    {
      v4 = CFSTR("GPU_CoreClocks");
    }
    else if ((objc_msgSend((id)objc_msgSend((id)objc_msgSend(v3, "device"), "name"), "containsString:", CFSTR("NVIDIA")) & 1) != 0)
    {
      v4 = CFSTR("MTLStatHostElapsedCycles");
    }
    else
    {
      v4 = (__CFString *)objc_msgSend(CFSTR("MTLStatTotalGPUCycles"), "copy");
    }
    v9[0] = CFSTR("MTLStat_nSec");
    v9[1] = v4;
    v5 = (void *)objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v9, 2);
    v6 = objc_msgSend(v5, "count");
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = __configureQueue_block_invoke;
    v8[3] = &__block_descriptor_40_e42_v32__0___MTLCommandBuffer__8__NSData_16Q24l;
    v8[4] = v6;
    objc_msgSend(v3, "addPerfSampleHandler:", v8);
    objc_msgSend(v3, "setStatEnabled:", 1);
    objc_msgSend(v3, "setStatLocations:", 63);
    objc_msgSend(v3, "setStatOptions:", 1);
    if (objc_msgSend(v3, "requestCounters:withIndex:", v5, 0))
      NSLog(CFSTR("Error requesting counters"));

  }
  if (CI_ENABLE_METAL_LABEL())
    objc_msgSend(v3, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  return v3;
}

uint64_t CI_ENABLE_METAL_DEBUG()
{
  unsigned __int8 v0;

  {
    CI_ENABLE_METAL_DEBUG::v = get_BOOL("CI_ENABLE_METAL_DEBUG", 0);
  }
  return CI_ENABLE_METAL_DEBUG::v;
}

void sub_1921EB84C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN2CI17StitchableKernelsC2EPKNS_12MetalContextE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  id v4;
  void *v5;
  uint64_t v6;
  id v7;
  void *v8;
  id v9;
  void *v10;
  uint64_t v11;
  char v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  id *v16;
  void *v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BYTE v27[128];
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v28 = 0;
  v29 = 0;
  v2 = *(_QWORD *)(a1 + 40);
  v3 = CI::MetalContext::device(*(id **)(a1 + 48));
  v4 = +[CIKernelLibrary internalLibraryWithName:device:](CIKernelLibrary, "internalLibraryWithName:device:", CFSTR("ci_stdlib_stitchable"), v3);
  if (v4)
  {
    v5 = v4;
    v6 = objc_msgSend((id)objc_msgSend(v4, "functionNames"), "count");
    v28 = v6;
    objc_msgSend(*(id *)(v2 + 24), "addObject:", v5);

  }
  else
  {
    NSLog(CFSTR("Failed to load 'ci_stdlib_stitchable' Metal library."));
    v6 = 0;
  }
  v7 = +[CIKernelLibrary internalLibraryWithName:device:](CIKernelLibrary, "internalLibraryWithName:device:", CFSTR("ci_filters_stitchable"), v3);
  if (v7)
  {
    v8 = v7;
    v28 = v6 + objc_msgSend((id)objc_msgSend(v7, "functionNames"), "count");
    objc_msgSend(*(id *)(v2 + 24), "addObject:", v8);

  }
  else
  {
    NSLog(CFSTR("Failed to load 'ci_filters_stitchable' Metal library."));
  }
  if (CI_ENABLE_HALF_KERNELS() && *(_BYTE *)(*(_QWORD *)(a1 + 48) + 43))
  {
    *(_QWORD *)(v2 + 32) = (id)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v9 = +[CIKernelLibrary internalLibraryWithName:device:](CIKernelLibrary, "internalLibraryWithName:device:", CFSTR("ci_stdlib_stitchable_h"), v3);
    if (v9)
    {
      v10 = v9;
      v29 = objc_msgSend((id)objc_msgSend(v9, "functionNames"), "count");
      objc_msgSend(*(id *)(v2 + 32), "addObject:", v10);

    }
    else
    {
      NSLog(CFSTR("Failed to load 'ci_stdlib_stitchable_h' Metal library."));
    }
  }
  else
  {
    *(_QWORD *)(v2 + 32) = 0;
  }
  v11 = 0;
  v12 = 1;
  do
  {
    v13 = v12;
    v14 = v2;
    v15 = v2 + 8 * v11;
    *(_QWORD *)(v15 + 40) = (id)objc_msgSend(MEMORY[0x1E0C99E20], "setWithCapacity:", *(&v28 + v11));
    v16 = (id *)(v15 + 40);
    v23 = 0u;
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v17 = *(v16 - 2);
    result = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
    if (result)
    {
      v19 = result;
      v20 = *(_QWORD *)v24;
      do
      {
        v21 = 0;
        do
        {
          if (*(_QWORD *)v24 != v20)
            objc_enumerationMutation(v17);
          v22 = *(void **)(*((_QWORD *)&v23 + 1) + 8 * v21);
          objc_msgSend(v22, "setLabel:", *(_QWORD *)(a1 + 32));
          objc_msgSend(*v16, "addObjectsFromArray:", objc_msgSend(v22, "functionNames"));
          ++v21;
        }
        while (v19 != v21);
        result = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
        v19 = result;
      }
      while (result);
    }
    v12 = 0;
    v11 = 1;
    v2 = v14;
  }
  while ((v13 & 1) != 0);
  return result;
}

CI::PrecompiledKernels *CI::DAGPrecompiledKernels::DAGPrecompiledKernels(CI::DAGPrecompiledKernels *this, id *a2)
{
  uint64_t v3;
  uint64_t v4;
  id v5;
  void *v6;
  uint64_t v7;
  id v8;
  void *v9;
  id v10;
  void *v11;
  uint64_t v12;
  char v13;
  char v14;
  char *v15;
  id *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t i;
  void *v21;
  CI::PrecompiledKernels *v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[128];
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v23 = CI::PrecompiledKernels::PrecompiledKernels(this);
  *(_QWORD *)v23 = &off_1E2EBE280;
  v3 = CI::MetalContext::device(a2);
  v4 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a2[240]);
  *((_QWORD *)v23 + 3) = (id)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v29 = 0;
  v30 = 0;
  v5 = +[CIKernelLibrary internalLibraryWithName:device:](CIKernelLibrary, "internalLibraryWithName:device:", CFSTR("ci_stdlib"), v3);
  v6 = v5;
  if (v5)
  {
    v7 = objc_msgSend((id)objc_msgSend(v5, "externFunctionNames"), "count");
    v29 = v7;
    objc_msgSend(*((id *)v23 + 3), "addObject:", v6);

  }
  else
  {
    NSLog(CFSTR("Failed to load 'ci_stdlib' Metal library."));
    v7 = 0;
  }
  v8 = +[CIKernelLibrary internalLibraryWithName:device:](CIKernelLibrary, "internalLibraryWithName:device:", CFSTR("ci_filters"), v3);
  v9 = v8;
  if (v8)
  {
    v29 = v7 + objc_msgSend((id)objc_msgSend(v8, "externFunctionNames"), "count");
    objc_msgSend(*((id *)v23 + 3), "addObject:", v9);

  }
  else
  {
    NSLog(CFSTR("Failed to load 'ci_filters' Metal library."));
  }
  if (CI_ENABLE_HALF_KERNELS() && *((_BYTE *)a2 + 43))
  {
    *((_QWORD *)v23 + 4) = (id)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v10 = +[CIKernelLibrary internalLibraryWithName:device:](CIKernelLibrary, "internalLibraryWithName:device:", CFSTR("ci_stdlib_h"), v3);
    v11 = v10;
    if (v10)
    {
      v30 = objc_msgSend((id)objc_msgSend(v10, "externFunctionNames"), "count");
      objc_msgSend(*((id *)v23 + 4), "addObject:", v11);

    }
    else
    {
      NSLog(CFSTR("Failed to load 'ci_stdlib_h' Metal library."));
    }
  }
  else
  {
    *((_QWORD *)v23 + 4) = 0;
  }
  v12 = 0;
  v13 = 1;
  do
  {
    v14 = v13;
    v15 = (char *)v23 + 8 * v12;
    *((_QWORD *)v15 + 5) = (id)objc_msgSend(MEMORY[0x1E0C99E20], "setWithCapacity:", *(&v29 + v12));
    v16 = (id *)(v15 + 40);
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v27 = 0u;
    v17 = *(v16 - 2);
    v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
    if (v18)
    {
      v19 = *(_QWORD *)v25;
      do
      {
        for (i = 0; i != v18; ++i)
        {
          if (*(_QWORD *)v25 != v19)
            objc_enumerationMutation(v17);
          v21 = *(void **)(*((_QWORD *)&v24 + 1) + 8 * i);
          objc_msgSend(v21, "setLabel:", v4);
          objc_msgSend(*v16, "addObjectsFromArray:", objc_msgSend(v21, "externFunctionNames"));
        }
        v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v24, v28, 16);
      }
      while (v18);
    }
    v13 = 0;
    v12 = 1;
  }
  while ((v14 & 1) != 0);
  return v23;
}

void sub_1921EBE44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CI::PrecompiledKernels *a10)
{
  CI::PrecompiledKernels::~PrecompiledKernels(a10);
  _Unwind_Resume(a1);
}

uint64_t CI::MetalContext::device(id *this)
{
  return objc_msgSend(this[49], "device");
}

CI::PrecompiledKernels *CI::PrecompiledKernels::PrecompiledKernels(CI::PrecompiledKernels *this)
{
  NSObject *v2;

  *(_QWORD *)this = &off_1E2EBDCD0;
  *((_BYTE *)this + 8) = 1;
  *((_QWORD *)this + 2) = 0;
  v2 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *((_QWORD *)this + 7) = dispatch_queue_create("CI::LoadLibrariesQueue", v2);
  *((_QWORD *)this + 8) = dispatch_group_create();
  *((_QWORD *)this + 2) = objc_opt_new();
  return this;
}

void sub_1921EC174(_Unwind_Exception *a1)
{
  NSObject **v1;

  Queue::~Queue(v1);
  _Unwind_Resume(a1);
}

uint64_t CI_ENABLE_HALF_KERNELS()
{
  unsigned __int8 v0;

  {
    CI_ENABLE_HALF_KERNELS::v = get_BOOL("CI_ENABLE_HALF_KERNELS", 1);
  }
  return CI_ENABLE_HALF_KERNELS::v;
}

void sub_1921EC1EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CI::MetalContext::init(CI::MetalContext *this, CFTypeRef cf, const char *a3)
{
  CFTypeRef v5;
  char v6;
  uint64_t v7;
  char v8;
  char v9;
  int v10;
  char *v11;
  uint64_t v12;
  CI::MetalTextureManager *v13;
  const CI::MetalContext *v14;
  const CI::MetalContext *v15;
  const CI::MetalContext *v16;
  CI::SWContext *v17;
  CI::Object *v18;

  if (cf)
    v5 = CFRetain(cf);
  else
    v5 = 0;
  *((_QWORD *)this + 49) = v5;
  *((_QWORD *)this + 240) = a3;
  bzero((char *)this + 1232, 0x208uLL);
  v6 = 0;
  v7 = 0;
  v8 = 1;
  do
  {
    v9 = v8;
    v10 = v6 & 1;
    v6 = 1;
    v11 = (char *)this + 16 * v7;
    *((_QWORD *)v11 + 219) = CIMetalSamplerCreate(*((_QWORD *)this + 240), (void *)objc_msgSend(*((id *)this + 49), "device"), v10, 1);
    v12 = CIMetalSamplerCreate(*((_QWORD *)this + 240), (void *)objc_msgSend(*((id *)this + 49), "device"), v10, 0);
    v8 = 0;
    *((_QWORD *)v11 + 220) = v12;
    v7 = 1;
  }
  while ((v9 & 1) != 0);
  v13 = (CI::MetalTextureManager *)operator new();
  CI::MetalTextureManager::MetalTextureManager(v13, this);
  *((_QWORD *)this + 227) = v13;
  *((_QWORD *)this + 224) = 0;
  *((_QWORD *)this + 226) = 0;
  *((_QWORD *)this + 225) = 0;
  *(_OWORD *)((char *)this + 1832) = 0u;
  *(_OWORD *)((char *)this + 1848) = 0u;
  *(_OWORD *)((char *)this + 1864) = 0u;
  *(_OWORD *)((char *)this + 1880) = 0u;
  *(_OWORD *)((char *)this + 1889) = 0u;
  CIMetalDeviceGetLimits((void *)objc_msgSend(*((id *)this + 49), "device"), (unint64_t *)this + 50);
  CIMetalDeviceGetFeatures((void *)objc_msgSend(*((id *)this + 49), "device"), (_BYTE *)this + 456);
  *((_QWORD *)this + 241) = CI::new_precompiled_kernels((id *)this, v14);
  *((_QWORD *)this + 242) = CI::new_stitchable_kernels(this, v15);
  *((_QWORD *)this + 243) = CI::new_ci_dylib((id *)this, v16);
  CI::MetalContext::load_archives(this);
  v17 = (CI::SWContext *)operator new();
  CI::SWContext::SWContext(v17, this);
  v18 = (CI::Object *)*((_QWORD *)this + 228);
  *((_QWORD *)this + 228) = v17;
  if (v18)
    CI::Object::unref(v18);
}

void sub_1921EC3A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40CDAF8E61);
  _Unwind_Resume(a1);
}

uint64_t CIMetalSamplerCreate(uint64_t a1, void *a2, int a3, int a4)
{
  void *v8;
  void *v9;
  uint64_t v10;

  v8 = (void *)objc_opt_new();
  v9 = v8;
  if (a3)
  {
    objc_msgSend(v8, "setMinFilter:", 1);
    objc_msgSend(v9, "setMagFilter:", 1);
  }
  if (a4)
  {
    objc_msgSend(v9, "setSAddressMode:", 4);
    objc_msgSend(v9, "setTAddressMode:", 4);
  }
  objc_msgSend(v9, "setNormalizedCoordinates:", 1);
  if (CI_ENABLE_METAL_LABEL())
    objc_msgSend(v9, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  v10 = objc_msgSend(a2, "newSamplerStateWithDescriptor:", v9);

  return v10;
}

uint64_t CI_ENABLE_METAL_LABEL()
{
  unsigned __int8 v0;

  {
    CI_ENABLE_METAL_LABEL::v = get_BOOL("CI_ENABLE_METAL_LABEL", 1);
  }
  return CI_ENABLE_METAL_LABEL::v;
}

void sub_1921EC508(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CI::DAGPrecompiledKernels *CI::new_precompiled_kernels(id *this, const CI::MetalContext *a2)
{
  CI::DAGPrecompiledKernels *v3;

  v3 = (CI::DAGPrecompiledKernels *)operator new();
  CI::DAGPrecompiledKernels::DAGPrecompiledKernels(v3, this);
  return v3;
}

void sub_1921EC564(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10C1C40108F59C3);
  _Unwind_Resume(a1);
}

CI::MetalTextureManager *CI::MetalTextureManager::MetalTextureManager(CI::MetalTextureManager *this, CI::MetalContext *a2)
{
  int v4;
  int v5;
  uint64_t v6;
  _QWORD v8[5];
  int v9;

  v4 = (*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)a2 + 272))(a2);
  CI::TextureManager::TextureManager(this, v4);
  *(_QWORD *)this = &off_1E2EBDFC8;
  *((_QWORD *)this + 21) = a2;
  if (CI_RECYCLE_METAL_TEXTURES() && CI_IOSURFACE_INTERMEDIATES())
  {
    v5 = (*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)a2 + 272))(a2);
    v6 = *((_QWORD *)this + 13);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = ___ZN2CI19MetalTextureManagerC2EPNS_12MetalContextE_block_invoke;
    v8[3] = &__block_descriptor_44_e23_v16__0r____IOSurface__8l;
    v8[4] = this;
    v9 = v5;
    AddReleaseSurfaceBlock(v6, (uint64_t)v8);
  }
  return this;
}

void sub_1921EC644(_Unwind_Exception *a1)
{
  dispatch_queue_t *v1;

  CI::TextureManager::~TextureManager(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::Context::index(CI::Context *this)
{
  return *((unsigned int *)this + 36);
}

CI::TextureManager *CI::TextureManager::TextureManager(CI::TextureManager *this, int a2)
{
  NSObject *v3;
  dispatch_queue_t v4;
  _QWORD *v5;

  *(_QWORD *)this = &unk_1E2EBB028;
  *((_DWORD *)this + 2) = a2;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = (char *)this + 32;
  *((_QWORD *)this + 5) = (char *)this + 32;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = (char *)this + 64;
  *((_QWORD *)this + 9) = (char *)this + 64;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = dispatch_group_create();
  *((_QWORD *)this + 12) = dispatch_queue_create("CI::complete_intermediate", 0);
  v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v4 = dispatch_queue_create("CI::TextureManager", v3);
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 13) = v4;
  *((_QWORD *)this + 14) = (char *)this + 120;
  v5 = (_QWORD *)operator new();
  *v5 = v5;
  v5[1] = v5;
  v5[2] = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 17) = v5;
  *((_QWORD *)this + 18) = (char *)this + 152;
  return this;
}

uint64_t CI_RECYCLE_METAL_TEXTURES()
{
  unsigned __int8 v0;

  {
    CI_RECYCLE_METAL_TEXTURES::v = get_BOOL("CI_RECYCLE_METAL_TEXTURES", 0);
  }
  return CI_RECYCLE_METAL_TEXTURES::v;
}

void sub_1921EC78C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *CIMetalDeviceGetLimits(void *result, unint64_t *a2)
{
  void *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;

  if (a2)
  {
    v3 = result;
    v4 = objc_msgSend(result, "maxTextureWidth2D");
    if (v4 >= objc_msgSend(v3, "maxTextureHeight2D"))
      v5 = objc_msgSend(v3, "maxTextureHeight2D");
    else
      v5 = objc_msgSend(v3, "maxTextureWidth2D");
    *a2 = v5;
    if (v5 >= (int)CI_MAX_TEXTURE_SIZE())
      v6 = (int)CI_MAX_TEXTURE_SIZE();
    else
      v6 = *a2;
    *a2 = v6;
    v7 = objc_msgSend(v3, "maxComputeTextures");
    if (v7 >= objc_msgSend(v3, "maxComputeSamplers"))
      v8 = objc_msgSend(v3, "maxComputeSamplers");
    else
      v8 = objc_msgSend(v3, "maxComputeTextures");
    a2[1] = v8;
    a2[2] = objc_msgSend(v3, "maxBufferLength");
    a2[3] = objc_msgSend(v3, "iosurfaceReadOnlyTextureAlignmentBytes");
    a2[4] = objc_msgSend(v3, "iosurfaceTextureAlignmentBytes");
    a2[5] = objc_msgSend(v3, "sharedMemorySize");
    result = (void *)objc_msgSend(v3, "dedicatedMemorySize");
    a2[6] = (unint64_t)result;
  }
  return result;
}

uint64_t CI_MAX_TEXTURE_SIZE()
{
  unsigned __int8 v0;

  {
    CI_MAX_TEXTURE_SIZE::v = get_int("CI_MAX_TEXTURE_SIZE", 0x7FFFFFFFLL);
  }
  return CI_MAX_TEXTURE_SIZE::v;
}

void sub_1921EC8F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *CIMetalDeviceGetFeatures(void *result, _BYTE *a2)
{
  void *v3;

  if (a2)
  {
    v3 = result;
    *a2 = objc_msgSend(result, "supportsFamily:", 1003);
    a2[1] = objc_msgSend(v3, "supportsFamily:", 1004);
    a2[2] = objc_msgSend(v3, "supportsFamily:", 1006);
    result = (void *)objc_msgSend(v3, "supportsFamily:", 1004);
    a2[3] = (_BYTE)result;
  }
  return result;
}

dispatch_queue_t *CI::new_stitchable_kernels(CI *this, const CI::MetalContext *a2)
{
  dispatch_queue_t *v3;

  v3 = (dispatch_queue_t *)operator new();
  CI::StitchableKernels::StitchableKernels(v3, this);
  return v3;
}

void sub_1921EC9B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10C1C40108F59C3);
  _Unwind_Resume(a1);
}

dispatch_queue_t *CI::StitchableKernels::StitchableKernels(dispatch_queue_t *this, const CI::MetalContext *a2)
{
  uint64_t v4;
  _QWORD v6[7];

  *(_QWORD *)CI::PrecompiledKernels::PrecompiledKernels((CI::PrecompiledKernels *)this) = &off_1E2EBDAD8;
  v4 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", *((_QWORD *)a2 + 240));
  this[3] = (dispatch_queue_t)(id)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN2CI17StitchableKernelsC2EPKNS_12MetalContextE_block_invoke;
  v6[3] = &unk_1E2EC78E8;
  v6[5] = this;
  v6[6] = a2;
  v6[4] = v4;
  Queue::execute_async(this + 7, v6);
  return this;
}

void sub_1921ECA84(_Unwind_Exception *a1)
{
  CI::PrecompiledKernels *v1;

  CI::PrecompiledKernels::~PrecompiledKernels(v1);
  _Unwind_Resume(a1);
}

void Queue::execute_async(dispatch_queue_t *a1, void *a2)
{
  qos_class_t v4;
  dispatch_block_t v5;

  v4 = qos_class_self();
  v5 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, v4, 0, a2);
  dispatch_async(*a1, v5);
  _Block_release(v5);
}

uint64_t CI::new_ci_dylib(id *this, const CI::MetalContext *a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;

  v3 = operator new();
  v4 = CI::MetalContext::device(this);
  *(_QWORD *)v3 = 0;
  *(_BYTE *)(v3 + 8) = 1;
  *(_QWORD *)(v3 + 16) = v4;
  v5 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *(_QWORD *)(v3 + 24) = dispatch_queue_create("CI::CoreImageDyLibCompilation", v5);
  return v3;
}

void sub_1921ECB58(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10C0C4009D5372FLL);
  _Unwind_Resume(a1);
}

void sub_1921ECBD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40DBE5A1EELL);
  _Unwind_Resume(a1);
}

uint64_t CI::Object::ref(uint64_t this)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(this + 8);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  return this;
}

void sub_1921ECFC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_PRINT_TREE()
{
  if (CI_PRINT_TREE::didCheck != -1)
    dispatch_once(&CI_PRINT_TREE::didCheck, &__block_literal_global_26);
  return CI_PRINT_TREE::v;
}

uint64_t CI_PRINT_TIME()
{
  if (CI_PRINT_TIME::didCheck != -1)
    dispatch_once(&CI_PRINT_TIME::didCheck, &__block_literal_global_14);
  return CI_PRINT_TIME::v;
}

CI::FillImage *CI::FillImage::FillImage(CI::FillImage *this)
{
  unsigned int v2;
  unint64_t v3;
  int64x2_t v5[5];
  int __src;

  *(_QWORD *)(CI::Image::Image((uint64_t)this) + 104) = off_1E2EBC0C8;
  do
    v2 = __ldaxr(&dword_1ECF872F0[7]);
  while (__stlxr(v2 + 1, &dword_1ECF872F0[7]));
  *(_QWORD *)this = &off_1E2EBFF78;
  *((_QWORD *)this + 13) = &unk_1E2EC00C8;
  *((_QWORD *)this + 14) = 0;
  XXH64_reset(v5, 0);
  __src = (*(uint64_t (**)(CI::FillImage *))(*(_QWORD *)this + 16))(this);
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  v3 = XXH64_digest((uint64_t)v5);
  *((_QWORD *)this + 10) = v3;
  *((_QWORD *)this + 11) = v3;
  *((_WORD *)this + 48) = 1;
  return this;
}

uint64_t XXH64_reset(int64x2_t *a1, unint64_t a2)
{
  a1[1] = vaddq_s64(vdupq_n_s64(a2), (int64x2_t)xmmword_19249CE10);
  a1[2].i64[0] = a2;
  a1[2].i64[1] = a2 + 0x61C8864E7A143579;
  a1->i64[0] = 0;
  a1->i64[1] = a2;
  a1[5].i32[0] = 0;
  return 0;
}

unint64_t XXH64_digest(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unsigned int *v6;
  BOOL v7;
  uint64_t v8;
  unsigned int v9;
  unint64_t v10;

  v1 = (_QWORD *)(a1 + 48);
  v2 = *(unsigned int *)(a1 + 80);
  v3 = a1 + 48 + v2;
  if (*(_QWORD *)a1 < 0x20uLL)
    v4 = *(_QWORD *)(a1 + 8) + 0x27D4EB2F165667C5;
  else
    v4 = 0x85EBCA77C2B2AE63
       - 0x61C8864E7A143579
       * ((0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579
         * ((0x85EBCA77C2B2AE63
           - 0x61C8864E7A143579
           * ((0x85EBCA77C2B2AE63
             - 0x61C8864E7A143579
             * ((__ROR8__(*(_QWORD *)(a1 + 24), 57)
               + __ROR8__(*(_QWORD *)(a1 + 16), 63)
               + __ROR8__(*(_QWORD *)(a1 + 32), 52)
               + __ROR8__(*(_QWORD *)(a1 + 40), 46)) ^ (0x9E3779B185EBCA87
                                                      * ((0x93EA75A780000000 * *(_QWORD *)(a1 + 16)) | ((0xC2B2AE3D27D4EB4FLL * *(_QWORD *)(a1 + 16)) >> 33))))) ^ (0x9E3779B185EBCA87 * ((0x93EA75A780000000 * *(_QWORD *)(a1 + 24)) | ((0xC2B2AE3D27D4EB4FLL * *(_QWORD *)(a1 + 24)) >> 33))))) ^ (0x9E3779B185EBCA87 * ((0x93EA75A780000000 * *(_QWORD *)(a1 + 32)) | ((0xC2B2AE3D27D4EB4FLL * *(_QWORD *)(a1 + 32)) >> 33))))) ^ (0x9E3779B185EBCA87 * ((0x93EA75A780000000 * *(_QWORD *)(a1 + 40)) | ((0xC2B2AE3D27D4EB4FLL * *(_QWORD *)(a1 + 40)) >> 33))));
  v5 = v4 + *(_QWORD *)a1;
  if (a1 + 56 <= v3)
  {
    do
    {
      v6 = (unsigned int *)(v1 + 1);
      v5 = 0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579
         * __ROR8__((0x9E3779B185EBCA87 * ((0x93EA75A780000000 * *v1) | ((0xC2B2AE3D27D4EB4FLL * *v1) >> 33))) ^ v5, 37);
      v7 = (unint64_t)(v1 + 2) > v3;
      ++v1;
    }
    while (!v7);
  }
  else
  {
    v6 = (unsigned int *)(a1 + 48);
  }
  if ((unint64_t)(v6 + 1) <= v3)
    v5 = 0x165667B19E3779F9 - 0x3D4D51C2D82B14B1 * __ROR8__((0x9E3779B185EBCA87 * *v6++) ^ v5, 41);
  if ((unint64_t)v6 < v3)
  {
    v8 = a1 + v2 - (_QWORD)v6 + 48;
    do
    {
      v9 = *(unsigned __int8 *)v6;
      v6 = (unsigned int *)((char *)v6 + 1);
      v5 = 0x9E3779B185EBCA87 * __ROR8__((0x27D4EB2F165667C5 * v9) ^ v5, 53);
      --v8;
    }
    while (v8);
  }
  v10 = 0x165667B19E3779F9
      * ((0xC2B2AE3D27D4EB4FLL * (v5 ^ (v5 >> 33))) ^ ((0xC2B2AE3D27D4EB4FLL * (v5 ^ (v5 >> 33))) >> 29));
  return v10 ^ HIDWORD(v10);
}

uint64_t CI::Image::Image(uint64_t this)
{
  __int128 v1;
  unsigned int v2;
  unsigned int v3;

  *(_DWORD *)(this + 8) = 1;
  *(_QWORD *)this = off_1E2EBE8A8;
  v1 = *(_OWORD *)(MEMORY[0x1E0C9D628] + 16);
  *(_OWORD *)(this + 16) = *MEMORY[0x1E0C9D628];
  *(_OWORD *)(this + 32) = v1;
  *(_QWORD *)(this + 56) = 0;
  *(_QWORD *)(this + 64) = 0;
  *(_QWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(_QWORD *)(this + 80) = 0;
  *(_QWORD *)(this + 88) = 0;
  *(_WORD *)(this + 96) = 0;
  do
  {
    v2 = __ldaxr(&CI::gImageCounter);
    v3 = v2 + 1;
  }
  while (__stlxr(v3, &CI::gImageCounter));
  *(_DWORD *)(this + 100) = v3;
  return this;
}

uint64_t CI::FillImage::type(CI::FillImage *this)
{
  return 9;
}

uint64_t CI::SurfaceImage::type(CI::SurfaceImage *this)
{
  return 19;
}

uint64_t CI::format_is_ycc_or_ycca(int a1)
{
  uint64_t result;

  LODWORD(result) = CI::format_is_ycc(a1);
  if (a1 == 535)
    return 1;
  else
    return result;
}

uint64_t CI::GeneralKernelImage::GeneralKernelImage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, int a6, int a7, double a8, double a9, double a10, double a11)
{
  unsigned int v18;
  uint64_t v19;
  __int128 v20;
  _BYTE *v21;
  int v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  int *v26;
  unint64_t v27;
  uint64_t v28;
  CI::XXHashHelper **v29;
  int *v30;
  unint64_t v31;
  uint64_t v32;
  CI::XXHashHelper **v33;
  uint64_t v34;
  BOOL v35;
  char v36;
  int64x2_t v38[5];
  __int128 v39;
  __int128 v40;
  int __src;

  *(double *)&v39 = a8;
  *((double *)&v39 + 1) = a9;
  *(double *)&v40 = a10;
  *((double *)&v40 + 1) = a11;
  *(_QWORD *)(CI::Image::Image(a1) + 104) = off_1E2EBB858;
  do
    v18 = __ldaxr(&dword_1ECF872F0[11]);
  while (__stlxr(v18 + 1, &dword_1ECF872F0[11]));
  *(_QWORD *)a1 = &off_1E2EBDB58;
  *(_QWORD *)(a1 + 104) = &unk_1E2EBDCA8;
  std::vector<CGRect>::vector((_QWORD *)(a1 + 128), a4);
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  if (a2)
  {
    v19 = a2;
    if (*(_BYTE *)(a2 + 12))
      v19 = CI::Object::ref(a2);
  }
  else
  {
    v19 = 0;
  }
  *(_QWORD *)(a1 + 112) = v19;
  *(_QWORD *)(a1 + 120) = a3;
  v20 = v40;
  *(_OWORD *)(a1 + 152) = v39;
  *(_OWORD *)(a1 + 168) = v20;
  *(_QWORD *)(a1 + 184) = _Block_copy(a5);
  if (a6)
  {
    *(_BYTE *)(a1 + 192) = a7;
    v21 = (_BYTE *)(a1 + 192);
    *(_DWORD *)(a1 + 196) = a6;
    v22 = a6;
  }
  else
  {
    *(_BYTE *)(a1 + 192) = a7;
    v21 = (_BYTE *)(a1 + 192);
    v22 = *(_DWORD *)(*(_QWORD *)(a1 + 112) + 120);
    *(_DWORD *)(a1 + 196) = v22;
    if (!v22)
      goto LABEL_12;
  }
  if ((CI::format_has_alpha(v22) & 1) == 0)
    *v21 = 1;
LABEL_12:
  *(_DWORD *)(a1 + 72) = 0;
  v23 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (v23 >= 1)
  {
    v24 = 0;
    v25 = *(_DWORD *)(a1 + 72);
    do
    {
      if (v25 <= *(_DWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, v24) + 72) + 1)
        v25 = *(_DWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, v24) + 72) + 1;
      else
        v25 = *(_DWORD *)(a1 + 72);
      *(_DWORD *)(a1 + 72) = v25;
      v24 = (v24 + 1);
    }
    while (v23 != (_DWORD)v24);
  }
  XXH64_reset(v38, 0);
  __src = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  XXH64_update((uint64_t)v38, (char *)&__src, 4uLL);
  (*(void (**)(uint64_t, int64x2_t *))(*(_QWORD *)a2 + 64))(a2, v38);
  v26 = *(int **)(a1 + 120);
  if (*v26 >= 1)
  {
    v27 = 0;
    v28 = 6;
    do
    {
      if (v27 > 9)
        v29 = (CI::XXHashHelper **)(*((_QWORD *)v26 + 2) + 8 * (v27 - 10));
      else
        v29 = (CI::XXHashHelper **)&v26[v28];
      CI::Kernel::add_argument_to_digest((CI::Kernel *)v38, *v29, 0);
      ++v27;
      v26 = *(int **)(a1 + 120);
      v28 += 2;
    }
    while ((uint64_t)v27 < *v26);
  }
  XXH64_update((uint64_t)v38, (char *)&v39, 0x20uLL);
  __src = a6;
  XXH64_update((uint64_t)v38, (char *)&__src, 4uLL);
  __src = a7;
  XXH64_update((uint64_t)v38, (char *)&__src, 4uLL);
  *(_QWORD *)(a1 + 80) = XXH64_digest((uint64_t)v38);
  XXH64_reset(v38, 0);
  __src = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  XXH64_update((uint64_t)v38, (char *)&__src, 4uLL);
  (*(void (**)(uint64_t, int64x2_t *))(*(_QWORD *)a2 + 64))(a2, v38);
  v30 = *(int **)(a1 + 120);
  if (*v30 >= 1)
  {
    v31 = 0;
    v32 = 6;
    do
    {
      if (v31 > 9)
        v33 = (CI::XXHashHelper **)(*((_QWORD *)v30 + 2) + 8 * (v31 - 10));
      else
        v33 = (CI::XXHashHelper **)&v30[v32];
      CI::Kernel::add_argument_to_digest((CI::Kernel *)v38, *v33, (const CI::Object *)1);
      ++v31;
      v30 = *(int **)(a1 + 120);
      v32 += 2;
    }
    while ((uint64_t)v31 < *v30);
  }
  XXH64_update((uint64_t)v38, (char *)&v39, 0x20uLL);
  __src = a6;
  XXH64_update((uint64_t)v38, (char *)&__src, 4uLL);
  __src = a7;
  XXH64_update((uint64_t)v38, (char *)&__src, 4uLL);
  *(_QWORD *)(a1 + 88) = XXH64_digest((uint64_t)v38);
  *(_BYTE *)(a1 + 96) = *(_QWORD *)(a2 + 48) != 0;
  if (v23 >= 1)
  {
    v34 = 0;
    do
    {
      if (*(_BYTE *)((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, v34) + 96))
        v35 = *(_BYTE *)(a1 + 96) == 0;
      else
        v35 = 1;
      v36 = !v35;
      *(_BYTE *)(a1 + 96) = v36;
      v34 = (v34 + 1);
    }
    while (v23 != (_DWORD)v34);
  }
  *(_BYTE *)(a1 + 97) = 0;
  return a1;
}

uint64_t XXH64_update(uint64_t a1, char *__src, size_t __n)
{
  int v3;
  char *v4;
  uint64_t v6;
  size_t v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;

  v3 = __n;
  v4 = __src;
  *(_QWORD *)a1 += __n;
  v6 = *(unsigned int *)(a1 + 80);
  if (v6 + __n <= 0x1F)
  {
    memcpy((void *)(a1 + v6 + 48), __src, __n);
    LODWORD(v7) = *(_DWORD *)(a1 + 80) + v3;
LABEL_11:
    *(_DWORD *)(a1 + 80) = v7;
    return 0;
  }
  v8 = &__src[__n];
  if ((_DWORD)v6)
  {
    memcpy((void *)(a1 + 48 + v6), __src, (32 - v6));
    v9 = __ROR8__(*(_QWORD *)(a1 + 24) - 0x3D4D51C2D82B14B1 * *(_QWORD *)(a1 + 56), 33);
    *(_QWORD *)(a1 + 16) = 0x9E3779B185EBCA87
                         * __ROR8__(*(_QWORD *)(a1 + 16) - 0x3D4D51C2D82B14B1 * *(_QWORD *)(a1 + 48), 33);
    *(_QWORD *)(a1 + 24) = 0x9E3779B185EBCA87 * v9;
    v10 = 0x9E3779B185EBCA87 * __ROR8__(*(_QWORD *)(a1 + 40) - 0x3D4D51C2D82B14B1 * *(_QWORD *)(a1 + 72), 33);
    *(_QWORD *)(a1 + 32) = 0x9E3779B185EBCA87
                         * __ROR8__(*(_QWORD *)(a1 + 32) - 0x3D4D51C2D82B14B1 * *(_QWORD *)(a1 + 64), 33);
    *(_QWORD *)(a1 + 40) = v10;
    v4 += (32 - *(_DWORD *)(a1 + 80));
    *(_DWORD *)(a1 + 80) = 0;
  }
  if (v4 + 32 <= v8)
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_QWORD *)(a1 + 24);
    v14 = *(_QWORD *)(a1 + 32);
    v13 = *(_QWORD *)(a1 + 40);
    do
    {
      v11 = 0x9E3779B185EBCA87 * __ROR8__(v11 - 0x3D4D51C2D82B14B1 * *(_QWORD *)v4, 33);
      v12 = 0x9E3779B185EBCA87 * __ROR8__(v12 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 1), 33);
      v14 = 0x9E3779B185EBCA87 * __ROR8__(v14 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 2), 33);
      v13 = 0x9E3779B185EBCA87 * __ROR8__(v13 - 0x3D4D51C2D82B14B1 * *((_QWORD *)v4 + 3), 33);
      v4 += 32;
    }
    while (v4 <= v8 - 32);
    *(_QWORD *)(a1 + 16) = v11;
    *(_QWORD *)(a1 + 24) = v12;
    *(_QWORD *)(a1 + 32) = v14;
    *(_QWORD *)(a1 + 40) = v13;
  }
  if (v4 < v8)
  {
    v7 = v8 - v4;
    memcpy((void *)(a1 + 48), v4, v7);
    goto LABEL_11;
  }
  return 0;
}

void CI::Kernel::add_argument_to_digest(CI::Kernel *this, CI::XXHashHelper *a2, const CI::Object *a3)
{
  int v3;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t __src;

  v3 = (int)a3;
  v6 = (*(uint64_t (**)(CI::XXHashHelper *))(*(_QWORD *)a2 + 16))(a2);
  switch(v6)
  {
    case ';':
      XXH64_update((uint64_t)this, (char *)a2 + 24, 0x10uLL);
      CI::XXHashHelper::add(this, *((CGColorSpaceRef *)a2 + 5));
      break;
    case ':':
      v7 = *((int *)a2 + 6);
      if ((_DWORD)v7)
        XXH64_update((uint64_t)this, (char *)a2 + 28, 4 * v7);
      break;
    case '9':
      CI::XXHashHelper::add(this, *((CFDataRef *)a2 + 3));
      break;
    default:
      v8 = (*(uint64_t (**)(CI::XXHashHelper *))(*(_QWORD *)a2 + 16))(a2);
      if (CI::is_any_TypeImage(v8))
      {
        if (v3)
          v9 = *((_QWORD *)a2 + 11);
        else
          v9 = *((_QWORD *)a2 + 10);
        __src = v9;
        XXH64_update((uint64_t)this, (char *)&__src, 8uLL);
      }
      break;
  }
}

void sub_1921EDCA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL12userDefaultsv_block_invoke()
{
  uint64_t result;

  result = objc_msgSend(objc_alloc(MEMORY[0x1E0C99EA0]), "initWithSuiteName:", CFSTR("com.apple.coreimage"));
  userDefaults(void)::defaults = result;
  return result;
}

uint64_t ___ZN2CI12MetalContext18binaryArchiveCacheEv_block_invoke()
{
  uint64_t result;

  result = objc_opt_new();
  CI::MetalContext::binaryArchiveCache(void)::cache = result;
  return result;
}

os_log_t __ci_signpost_log_filter_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "signpost_filter");
  ci_signpost_log_filter_log = (uint64_t)result;
  return result;
}

void sub_1921EE4E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10F1C4010D716A0);
  _Unwind_Resume(a1);
}

void OptionIsTrueOrFalse(void *a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  void (*v7)(uint64_t, uint64_t);
  uint64_t v8;
  uint64_t v9;
  NSObject *v11;

  v5 = 0;
  if (a1 && a2)
    v5 = (void *)objc_msgSend(a1, "objectForKey:", a2);
  if (v5 == (void *)MEMORY[0x1E0C9AAB0] || v5 == &unk_1E2F1B5D8)
  {
    v7 = *(void (**)(uint64_t, uint64_t))(a3 + 16);
    v8 = a3;
    v9 = 1;
LABEL_16:
    v7(v8, v9);
    return;
  }
  if (v5 == (void *)MEMORY[0x1E0C9AAA0] || v5 == &unk_1E2F1B5C0)
  {
    v7 = *(void (**)(uint64_t, uint64_t))(a3 + 16);
    v8 = a3;
    v9 = 0;
    goto LABEL_16;
  }
  if (v5)
  {
    v11 = ci_logger_api();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      OptionIsTrueOrFalse((uint64_t)v5, a2, v11);
  }
}

uint64_t CI::format_modernize(uint64_t a1, CI *this, const char *a3)
{
  uint64_t v3;
  int v4;

  v3 = a1;
  v4 = a1 - 1;
  if ((a1 - 1) <= 0x3E && ((0x7C77FFFFF807FFFFuLL >> v4) & 1) != 0)
  {
    v3 = dword_19249B594[v4];
    CI::log_old_format(this, off_1E2EC6D70[v4], a3);
  }
  return v3;
}

uint64_t CI::MetalContext::MetalContext(uint64_t a1, const void *a2, const char *a3, CGColorSpace *a4, CGColorSpace *a5, int a6, char a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, char a12)
{
  int v18;
  int v19;
  unsigned int v20;

  if (dyld_program_sdk_at_least())
    v18 = 2056;
  else
    v18 = 264;
  if (a6)
    v19 = a6;
  else
    v19 = v18;
  CI::Context::Context(a1, a4, a5, v19, a7, a8, a9, a10, a11, a12);
  *(_QWORD *)(a1 + 384) = off_1E2EB7B30;
  do
    v20 = __ldaxr(&dword_1ECF873D0[19]);
  while (__stlxr(v20 + 1, &dword_1ECF873D0[19]));
  *(_QWORD *)a1 = &off_1E2EB9400;
  *(_QWORD *)(a1 + 384) = &unk_1E2EB9680;
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 1784) = 0;
  *(_QWORD *)(a1 + 1824) = 0;
  *(_DWORD *)(a1 + 1848) = 0;
  *(_BYTE *)(a1 + 1852) = 0;
  bzero((void *)(a1 + 460), 0x301uLL);
  *(_OWORD *)(a1 + 1928) = 0u;
  *(_OWORD *)(a1 + 1944) = 0u;
  *(_OWORD *)(a1 + 1912) = 0u;
  CI::MetalContext::init((CI::MetalContext *)a1, a2, a3);
  return a1;
}

{
  return CI::MetalContext::MetalContext(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
}

void sub_1921EE768(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  CI::Object *v5;
  unsigned int *v6;
  unsigned int v7;

  v5 = *(CI::Object **)(v1 + 1824);
  *(_QWORD *)(v1 + 1824) = 0;
  if (v5)
    CI::Object::unref(v5);
  *(_QWORD *)(v1 + 384) = v2;
  v6 = (unsigned int *)(v3 + 308);
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  CI::Context::~Context((CGColorSpaceRef *)v1);
  _Unwind_Resume(a1);
}

uint64_t CI::Context::Context(uint64_t a1, CGColorSpace *a2, CGColorSpace *a3, int a4, char a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, char a10)
{
  unsigned int v14;
  unsigned int v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  CGColorSpaceRef DeviceRGB;
  CGColorSpace *v26;
  CGColorSpaceRef v27;

  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = off_1E2EBEF40;
  *(_DWORD *)(a1 + 32) = a4;
  *(_DWORD *)(a1 + 36) = 0;
  *(_BYTE *)(a1 + 41) = 1;
  do
  {
    v14 = __ldaxr(&CI::gContextCounter);
    v15 = v14 + 1;
  }
  while (__stlxr(v15, &CI::gContextCounter));
  v17 = *MEMORY[0x1E0C9D628];
  v16 = *(_OWORD *)(MEMORY[0x1E0C9D628] + 16);
  *(_OWORD *)(a1 + 236) = 0u;
  *(_DWORD *)(a1 + 144) = v15;
  *(_QWORD *)(a1 + 152) = 0;
  *(_OWORD *)(a1 + 160) = v17;
  *(_OWORD *)(a1 + 176) = v16;
  *(_QWORD *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 200) = v17;
  *(_OWORD *)(a1 + 216) = v16;
  *(_DWORD *)(a1 + 232) = 1;
  *(_OWORD *)(a1 + 252) = 0u;
  *(_OWORD *)(a1 + 268) = 0u;
  *(_OWORD *)(a1 + 284) = 0u;
  *(_BYTE *)(a1 + 300) = 1;
  *(_DWORD *)(a1 + 344) = 0;
  *(_QWORD *)(a1 + 352) = 0;
  *(_QWORD *)(a1 + 360) = a7;
  *(_QWORD *)(a1 + 368) = a6;
  *(_QWORD *)(a1 + 376) = a8;
  v18 = operator new();
  *(_QWORD *)(a1 + 304) = CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::ObjectCache(v18, 0x400uLL);
  v19 = operator new();
  *(_QWORD *)(a1 + 312) = CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::ObjectCache(v19, 0x20uLL);
  v20 = operator new();
  *(_QWORD *)(a1 + 320) = CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::ObjectCache(v20, 0x20uLL);
  v21 = CI_WORKING_FORMAT();
  if (v21)
    *(_DWORD *)(a1 + 32) = v21;
  v22 = MEMORY[0x1E0C9BAA8];
  v23 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
  *(_OWORD *)(a1 + 96) = *MEMORY[0x1E0C9BAA8];
  *(_OWORD *)(a1 + 112) = v23;
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(v22 + 32);
  v24 = *(_OWORD *)(MEMORY[0x1E0C9D5E0] + 16);
  *(_OWORD *)(a1 + 64) = *MEMORY[0x1E0C9D5E0];
  *(_OWORD *)(a1 + 80) = v24;
  *(_DWORD *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 60) = 0;
  *(_BYTE *)(a1 + 40) = a5;
  *(_BYTE *)(a1 + 42) = a9;
  *(_BYTE *)(a1 + 43) = a10;
  if (a2)
    DeviceRGB = CGColorSpaceRetain(a2);
  else
    DeviceRGB = CGColorSpaceCreateDeviceRGB();
  *(_QWORD *)(a1 + 16) = DeviceRGB;
  if (a3)
  {
    if ((CGColorSpace *)*MEMORY[0x1E0C9B0D0] == a3)
    {
      v27 = 0;
      goto LABEL_16;
    }
    v26 = a3;
  }
  else
  {
    if (CI::Context::defaultWorkingSpace(void)::didCreate != -1)
      dispatch_once(&CI::Context::defaultWorkingSpace(void)::didCreate, &__block_literal_global_21);
    v26 = (CGColorSpace *)CI::Context::defaultWorkingSpace(void)::space;
  }
  v27 = CGColorSpaceRetain(v26);
LABEL_16:
  *(_QWORD *)(a1 + 24) = v27;
  *(_QWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 44) = 0;
  *(_QWORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 336) = 0;
  return a1;
}

CGColorSpaceRef GetWorkingColorSpaceFromOptions(NSDictionary *a1, BOOL *a2)
{
  CGColorSpace *v3;
  CGColorSpaceRef DeviceRGB;
  CGColorSpace *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a2)
    *a2 = 1;
  v3 = -[NSDictionary valueForKey:](a1, "valueForKey:", CFSTR("working_color_space"));
  DeviceRGB = v3;
  if (v3 && v3 != (CGColorSpace *)*MEMORY[0x1E0C9B0D0])
  {
    if (!CGColorSpaceGetType())
    {
      DeviceRGB = CGColorSpaceCreateDeviceRGB();
      CFAutorelease(DeviceRGB);
    }
    if (!CI::ColorSpace_is_RGB_and_supports_output((_BOOL8)DeviceRGB, v5))
    {
      v6 = ci_logger_api();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        GetWorkingColorSpaceFromOptions(v6, v7, v8, v9, v10, v11, v12, v13);
      DeviceRGB = 0;
      if (a2)
        *a2 = 0;
    }
  }
  return DeviceRGB;
}

id GetOutputColorSpaceFromOptions(NSDictionary *a1, BOOL *a2)
{
  CGColorSpace *v3;
  id v4;
  id result;
  BOOL is_RGB_or_Gray_and_supports_output;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (a2)
    *a2 = 1;
  v4 = -[NSDictionary valueForKey:](a1, "valueForKey:", CFSTR("output_color_space"));
  result = 0;
  if (v4)
  {
    if (v4 != (id)*MEMORY[0x1E0C9B0D0])
    {
      is_RGB_or_Gray_and_supports_output = CI::ColorSpace_is_RGB_or_Gray_and_supports_output((_BOOL8)v4, v3);
      result = v4;
      if (!is_RGB_or_Gray_and_supports_output)
      {
        v7 = ci_logger_api();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          GetOutputColorSpaceFromOptions(v7, v8, v9, v10, v11, v12, v13, v14);
        result = 0;
        if (a2)
          *a2 = 0;
      }
    }
  }
  return result;
}

uint64_t CI_WORKING_FORMAT()
{
  if (CI_WORKING_FORMAT::didCheck != -1)
    dispatch_once(&CI_WORKING_FORMAT::didCheck, &__block_literal_global_80);
  return CI_WORKING_FORMAT::v;
}

void ___ZL31defaultIntermediateMemoryTargetv_block_invoke()
{
  id v0;
  const char *v1;
  void *v2;
  void *v3;
  void *v4;

  v0 = CIMetalCopyDefaultDevice();
  if (CIMetalDeviceIsA9OrHigher(v0, v1))
  {
    if (objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle"), "bundleIdentifier"))
    {
      v2 = (void *)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle"), "infoDictionary");
      if (v2)
      {
        v3 = v2;
        if (!objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("NSExtension")))
        {
          v4 = (void *)objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("CFBundlePackageType"));
          if (v4)
          {
            if (objc_msgSend(v4, "containsString:", CFSTR("APPL")))
              defaultIntermediateMemoryTarget(void)::targetMB = 1;
          }
        }
      }
    }
  }
  if (v0)
    CFRelease(v0);
}

void CI::MetalContext::load_archives(CI::MetalContext *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  void *v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  __int128 *v14;
  int64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  __int128 *v20;
  __int128 *v21;
  __int128 *v22;
  __int128 *v23;
  void *__p;
  void *v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  void *v31;
  char *v32;
  unint64_t v33;
  uint8_t buf[4];
  int v35;
  __int16 v36;
  uint64_t v37;
  _BYTE v38[128];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (CI_USE_ARCHIVED_KERNELS())
  {
    if (CI::MetalContext::binaryArchiveCache(void)::onceToken != -1)
      dispatch_once(&CI::MetalContext::binaryArchiveCache(void)::onceToken, &__block_literal_global_11_0);
    v2 = (void *)CI::MetalContext::binaryArchiveCache(void)::cache;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    objc_sync_enter((id)CI::MetalContext::binaryArchiveCache(void)::cache);
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v27, v38, 16);
    if (v3)
    {
      v4 = *(_QWORD *)v28;
      do
      {
        for (i = 0; i != v3; ++i)
        {
          if (*(_QWORD *)v28 != v4)
            objc_enumerationMutation(v2);
          v6 = *(_QWORD *)(*((_QWORD *)&v27 + 1) + 8 * i);
          v7 = (void *)objc_msgSend(v2, "objectForKey:", v6);
          if (v7)
          {
            v8 = ci_logger_render();
            if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
            {
              v9 = (*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)this + 272))(this);
              *(_DWORD *)buf = 67109378;
              v35 = v9;
              v36 = 2114;
              v37 = v6;
              _os_log_impl(&dword_1921E4000, v8, OS_LOG_TYPE_INFO, "Context[%d] uses %{public}@ archive", buf, 0x12u);
            }
            v10 = objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("air"));
            v11 = objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("bin"));
            v12 = v11;
            v13 = v32;
            if ((unint64_t)v32 >= v33)
            {
              v15 = (v32 - (_BYTE *)v31) >> 4;
              v16 = v15 + 1;
              if ((unint64_t)(v15 + 1) >> 60)
                abort();
              v17 = v33 - (_QWORD)v31;
              if ((uint64_t)(v33 - (_QWORD)v31) >> 3 > v16)
                v16 = v17 >> 3;
              if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0)
                v18 = 0xFFFFFFFFFFFFFFFLL;
              else
                v18 = v16;
              if (v18)
                v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)&v33, v18);
              else
                v19 = 0;
              v20 = (__int128 *)&v19[16 * v15];
              *(_QWORD *)v20 = v10;
              *((_QWORD *)v20 + 1) = v12;
              v22 = (__int128 *)v31;
              v21 = (__int128 *)v32;
              v23 = v20;
              if (v32 != v31)
              {
                do
                  *--v23 = *--v21;
                while (v21 != v22);
                v21 = (__int128 *)v31;
              }
              v14 = v20 + 1;
              v31 = v23;
              v32 = (char *)(v20 + 1);
              v33 = (unint64_t)&v19[16 * v18];
              if (v21)
                operator delete(v21);
            }
            else
            {
              *(_QWORD *)v32 = v10;
              *((_QWORD *)v13 + 1) = v11;
              v14 = (__int128 *)(v13 + 16);
            }
            v32 = (char *)v14;
          }
        }
        v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v27, v38, 16);
      }
      while (v3);
    }
    objc_sync_exit(v2);
    v25 = 0;
    v26 = 0;
    __p = 0;
    std::vector<std::pair<void const*,void const*>>::__init_with_size[abi:nn180100]<std::pair<void const*,void const*>*,std::pair<void const*,void const*>*>((char *)&__p, (__int128 *)v31, (__int128 *)v32, (v32 - (_BYTE *)v31) >> 4);
    *((_QWORD *)this + 244) = CI::new_kernel_archive((__int128 **)&__p);
    if (__p)
    {
      v25 = __p;
      operator delete(__p);
    }
    if (v31)
    {
      v32 = (char *)v31;
      operator delete(v31);
    }
  }
}

void sub_1921EEF0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27)
{
  if (__p)
    operator delete(__p);
  if (a26)
    operator delete(a26);
  _Unwind_Resume(exception_object);
}

uint64_t CI::new_kernel_archive(__int128 **a1)
{
  uint64_t v2;
  void *__p;
  void *v5;
  uint64_t v6;

  v2 = operator new();
  v5 = 0;
  v6 = 0;
  __p = 0;
  std::vector<std::pair<void const*,void const*>>::__init_with_size[abi:nn180100]<std::pair<void const*,void const*>*,std::pair<void const*,void const*>*>((char *)&__p, *a1, a1[1], a1[1] - *a1);
  CI::KernelArchive::KernelArchive(v2, (__int128 **)&__p);
  if (__p)
  {
    v5 = __p;
    operator delete(__p);
  }
  return v2;
}

void sub_1921EEFEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  uint64_t v11;

  if (__p)
    operator delete(__p);
  MEMORY[0x194025AAC](v11, 0x80C40512DBC69);
  _Unwind_Resume(a1);
}

uint64_t CI::KernelArchive::KernelArchive(uint64_t a1, __int128 **a2)
{
  NSObject *v4;
  __int128 *v5;
  __int128 *v6;
  uint64_t v7;
  NSObject *v8;
  __int128 v9;
  _QWORD block[5];
  __int128 v12;

  v4 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E0C80D50], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *(_QWORD *)a1 = dispatch_queue_create("CI::KernelArchiveLockQueue", v4);
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = objc_opt_new();
  v6 = *a2;
  v5 = a2[1];
  if (v6 != v5)
  {
    v7 = MEMORY[0x1E0C809B0];
    do
    {
      v8 = *(NSObject **)a1;
      block[0] = v7;
      block[1] = 3221225472;
      block[2] = ___ZN2CI13KernelArchive10addArchiveENSt3__14pairIPKvS4_EE_block_invoke;
      block[3] = &__block_descriptor_56_e5_v8__0l;
      block[4] = a1;
      v9 = *v6++;
      v12 = v9;
      dispatch_barrier_sync(v8, block);
    }
    while (v6 != v5);
  }
  return a1;
}

void sub_1921EF118(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v5 = *(void **)(v1 + 56);
  if (v5)
  {
    *(_QWORD *)(v1 + 64) = v5;
    operator delete(v5);
  }
  CI::KernelArchive::KernelArchive(v3, v2, v1);
  _Unwind_Resume(a1);
}

uint64_t CI_USE_ARCHIVED_KERNELS()
{
  unsigned __int8 v0;

  {
    CI_USE_ARCHIVED_KERNELS::v = get_int("CI_USE_ARCHIVED_KERNELS", 2);
  }
  return CI_USE_ARCHIVED_KERNELS::v;
}

void sub_1921EF1A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_ENABLE_METAL_CAPTURE()
{
  unsigned __int8 v0;

  {
    CI_ENABLE_METAL_CAPTURE::v = get_BOOL("CI_ENABLE_METAL_CAPTURE", 0);
  }
  return CI_ENABLE_METAL_CAPTURE::v;
}

void sub_1921EF224(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *CIMetalDeviceIsA9OrHigher(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "supportsFamily:", 1003);
  return a1;
}

uint64_t __iosurface_limits_block_invoke()
{
  uint64_t result;

  *(_QWORD *)&iosurface_limits_limits = MEMORY[0x194025788](*MEMORY[0x1E0CBC1E0]);
  *((_QWORD *)&iosurface_limits_limits + 1) = MEMORY[0x194025788](*MEMORY[0x1E0CBC008]);
  result = MEMORY[0x194025788](*MEMORY[0x1E0CBBF08]);
  qword_1ECF87180 = result;
  return result;
}

char *get_string(const char *a1)
{
  char *result;
  char *v3;

  result = getenv(a1);
  if (!result)
  {
    if (userDefaults(void)::didCheck != -1)
      dispatch_once(&userDefaults(void)::didCheck, &__block_literal_global_171);
    result = (char *)objc_msgSend((id)userDefaults(void)::defaults, "objectForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
    if (result)
    {
      v3 = result;
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
        return (char *)objc_msgSend(v3, "UTF8String");
      else
        return 0;
    }
  }
  return result;
}

void sub_1921F030C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C4084945667);
  _Unwind_Resume(a1);
}

uint64_t CI::format_bits_per_pixel(int a1)
{
  uint64_t result;

  result = 0;
  if (a1 <= 1792)
  {
    if (a1 > 770)
    {
      if (a1 > 1042)
      {
        if (a1 > 1298)
        {
          if (a1 <= 1553)
          {
            if (a1 == 1299)
              return 32;
            if (a1 != 1302)
              return result;
          }
          else
          {
            if (a1 == 1554)
              return 16;
            if (a1 == 1555)
              return 32;
            if (a1 != 1558)
              return result;
          }
          return 22;
        }
        if (a1 <= 1284)
        {
          if (a1 != 1043)
          {
            if (a1 != 1046)
              return result;
            return 32;
          }
          return 48;
        }
        switch(a1)
        {
          case 1285:
            return 10;
          case 1286:
            return 20;
          case 1298:
            return 16;
        }
      }
      else
      {
        switch(a1)
        {
          case 771:
          case 773:
            return 16;
          case 772:
          case 776:
          case 777:
          case 778:
          case 779:
          case 780:
          case 781:
          case 782:
          case 783:
          case 788:
          case 789:
            return result;
          case 774:
          case 775:
          case 784:
          case 785:
          case 790:
            return 32;
          case 786:
            return 24;
          case 787:
            return 48;
          default:
            if (a1 == 1042)
              return 24;
            break;
        }
      }
    }
    else
    {
      switch(a1)
      {
        case 257:
        case 258:
        case 259:
        case 261:
          result = 8;
          break;
        case 260:
        case 262:
        case 276:
        case 277:
        case 278:
          return 16;
        case 263:
        case 275:
          return 24;
        case 264:
        case 265:
        case 266:
        case 267:
        case 268:
        case 269:
        case 270:
        case 271:
          return 32;
        case 272:
        case 273:
          return result;
        case 274:
LABEL_28:
          result = 12;
          break;
        default:
          switch(a1)
          {
            case 530:
              goto LABEL_28;
            case 531:
              return 24;
            case 532:
            case 533:
            case 534:
              return 16;
            case 535:
              return 32;
            default:
              return result;
          }
      }
    }
  }
  else
  {
    if (a1 > 2304)
    {
      if (a1 <= 3080)
      {
        if (a1 <= 2566)
        {
          switch(a1)
          {
            case 2305:
            case 2306:
            case 2307:
            case 2309:
              return 32;
            case 2308:
            case 2310:
              return 64;
            case 2311:
              result = 96;
              break;
            case 2312:
            case 2313:
            case 2316:
              result = 128;
              break;
            default:
              return result;
          }
          return result;
        }
        if (a1 > 2823)
        {
          if (a1 == 2824)
            return 64;
          if (a1 != 3079)
            return result;
        }
        else if (a1 != 2567)
        {
          if (a1 != 2569)
            return result;
          return 64;
        }
        return 32;
      }
      if (a1 > 3349)
      {
        if (a1 <= 3605)
        {
          if (a1 == 3350)
            return 32;
          if (a1 == 3602)
            return 24;
          if (a1 != 3603)
            return result;
        }
        else
        {
          if (a1 <= 3858)
          {
            if (a1 == 3606)
              return 32;
            if (a1 != 3858)
              return result;
            return 24;
          }
          if (a1 != 3859)
          {
            if (a1 != 3862)
              return result;
            return 32;
          }
        }
        return 48;
      }
      if (a1 > 3333)
      {
        if (a1 == 3334)
          return 32;
        if (a1 == 3346)
          return 24;
        if (a1 != 3347)
          return result;
        return 48;
      }
      if (a1 == 3081)
        return 64;
      if (a1 != 3331 && a1 != 3333)
        return result;
      return 16;
    }
    switch(a1)
    {
      case 1793:
      case 1794:
      case 1795:
      case 1797:
        return 16;
      case 1796:
      case 1798:
      case 1814:
        return 32;
      case 1799:
      case 1811:
        return 48;
      case 1800:
      case 1801:
      case 1804:
        return 64;
      case 1802:
      case 1803:
      case 1805:
      case 1806:
      case 1807:
      case 1808:
      case 1809:
      case 1812:
      case 1813:
        return result;
      case 1810:
        return 24;
      default:
        switch(a1)
        {
          case 2049:
          case 2050:
          case 2051:
          case 2053:
            return 16;
          case 2052:
          case 2054:
          case 2070:
            return 32;
          case 2055:
          case 2067:
            return 48;
          case 2056:
          case 2060:
            return 64;
          case 2066:
            return 24;
          default:
            return result;
        }
    }
  }
  return result;
}

uint64_t CI::format_is_ycc(int a1)
{
  unsigned int v2;
  unint64_t v3;
  char is_ycc_422;
  unint64_t v5;
  unsigned int v6;

  HIDWORD(v3) = a1 - 274;
  LODWORD(v3) = a1 - 274;
  v2 = v3 >> 8;
  if (v2 < 0xF && ((0x70FFu >> v2) & 1) != 0)
    return 1;
  is_ycc_422 = CI::format_is_ycc_422(a1);
  HIDWORD(v5) = a1 - 275;
  LODWORD(v5) = a1 - 275;
  v6 = (0x70FFu >> ((unsigned __int16)(a1 - 275) >> 8)) & 1;
  if ((v5 >> 8) >= 0xF)
    v6 = 0;
  if ((is_ycc_422 & 1) != 0)
    return 1;
  else
    return v6;
}

uint64_t CI::format_is_ycc_422(int a1)
{
  uint64_t result;

  result = 1;
  if (a1 <= 1045)
  {
    if ((a1 - 276) >= 3 && (a1 - 532) >= 3 && a1 != 790)
      return 0;
  }
  else if (a1 > 2069)
  {
    if (a1 > 3605)
    {
      if (a1 != 3606 && a1 != 3862)
        return 0;
    }
    else if (a1 != 2070 && a1 != 3350)
    {
      return 0;
    }
  }
  else
  {
    if (a1 <= 1557)
    {
      if (a1 == 1046 || a1 == 1302)
        return result;
      return 0;
    }
    if (a1 != 1558 && a1 != 1814)
      return 0;
  }
  return result;
}

uint64_t CI::PixelFormatType_is_source_supported(CI *this)
{
  int v1;
  uint64_t result;
  unsigned __int16 v3;
  int v4;
  int v5;
  unsigned int v6;

  v1 = equivalent_uncompressed_format((uint64_t)this);
  result = 1;
  if (v1 <= 1667844405)
  {
    if (v1 <= 1093677111)
    {
      if (v1 > 843264303)
      {
        if (v1 <= 875704421)
        {
          if (((v1 - 843264304) > 6 || ((1 << (v1 - 48)) & 0x45) == 0) && v1 != 846624102)
          {
            v4 = 846624121;
            goto LABEL_115;
          }
        }
        else if (v1 > 875704949)
        {
          if (v1 != 875704950 && v1 != 875836518)
          {
            v4 = 875836534;
            goto LABEL_115;
          }
        }
        else if (v1 != 875704422 && v1 != 875704438)
        {
          v4 = 875704934;
          goto LABEL_115;
        }
        return result;
      }
      if (v1 <= 826487087)
      {
        if (((v1 - 826486840) > 0x30 || ((1 << (v1 - 56)) & 0x1400000000001) == 0)
          && v1 != 24
          && v1 != 32)
        {
          return 0;
        }
        return result;
      }
      if ((v1 - 826487088) <= 6 && ((1 << (v1 - 48)) & 0x45) != 0)
        return result;
      v5 = -843264056;
    }
    else
    {
      if (v1 <= 1279340599)
      {
        if (v1 > 1111970368)
        {
          if (((v1 - 1278226488) > 0x30 || ((1 << (v1 - 56)) & 0x1400000000001) == 0)
            && ((v1 - 1278226736) > 6 || ((1 << (v1 - 48)) & 0x45) == 0))
          {
            v4 = 1111970369;
            goto LABEL_115;
          }
        }
        else if (((v1 - 1093677112) > 0x30
                || ((1 << (v1 - 56)) & 0x1400000000001) == 0)
               && v1 != 1093677366)
        {
          v4 = 1094862674;
          goto LABEL_115;
        }
        return result;
      }
      if (v1 > 1380410944)
      {
        if (v1 > 1667838255)
        {
          if (v1 > 1667838823)
          {
            if (v1 == 1667838824)
              return result;
            v3 = 13360;
          }
          else
          {
            if (v1 == 1667838256)
              return result;
            v3 = 13158;
          }
          v4 = v3 | 0x63690000;
LABEL_115:
          if (v1 == v4)
            return result;
          return 0;
        }
        if (v1 != 1380410945 && v1 != 1380411457)
        {
          v4 = 1650943796;
          goto LABEL_115;
        }
        return result;
      }
      if (v1 > 1279340853)
      {
        if (v1 != 1279340854 && v1 != 1279342648)
        {
          v4 = 1380401729;
          goto LABEL_115;
        }
        return result;
      }
      v5 = -1279340600;
    }
    v6 = v1 + v5;
    if (v6 > 0x30 || ((1 << v6) & 0x1400000000001) == 0)
      return 0;
    return result;
  }
  if (v1 > 1936077359)
  {
    if (v1 <= 1953903667)
    {
      if (v1 <= 1937126451)
      {
        if (v1 <= 1936077875)
        {
          if (v1 == 1936077360)
            return result;
          v4 = 1936077362;
          goto LABEL_115;
        }
        if (v1 != 1936077876 && v1 != 1937125936)
        {
          v4 = 1937125938;
          goto LABEL_115;
        }
      }
      else if (v1 > 1952855091)
      {
        if (v1 != 1952855092 && v1 != 1953903152)
        {
          v4 = 1953903154;
          goto LABEL_115;
        }
      }
      else if (v1 != 1937126452 && v1 != 1952854576)
      {
        v4 = 1952854578;
        goto LABEL_115;
      }
    }
    else if (v1 > 2019963439)
    {
      if (v1 > 2033463351)
      {
        if (v1 != 2033463352 && v1 != 2037741158)
        {
          v4 = 2037741171;
          goto LABEL_115;
        }
      }
      else if (v1 != 2019963440 && v1 != 2019963442)
      {
        v4 = 2019963956;
        goto LABEL_115;
      }
    }
    else if (v1 > 2016686639)
    {
      if (v1 != 2016686640 && v1 != 2016686642)
      {
        v4 = 2016687156;
        goto LABEL_115;
      }
    }
    else if (v1 != 1953903668 && v1 != 1999843442)
    {
      v4 = 1999908961;
      goto LABEL_115;
    }
  }
  else if (v1 > 1751528499)
  {
    if (v1 <= 1882468913)
    {
      if (v1 <= 1815361649)
      {
        if (v1 == 1751528500)
          return result;
        v4 = 1815162994;
        goto LABEL_115;
      }
      if (v1 != 1815361650 && v1 != 1815491698)
      {
        v4 = 1882468912;
        goto LABEL_115;
      }
    }
    else if (v1 > 1885745713)
    {
      if (v1 != 1885745714 && v1 != 1885746228)
      {
        v4 = 1919379252;
        goto LABEL_115;
      }
    }
    else if (v1 != 1882468914 && v1 != 1882469428)
    {
      v4 = 1885745712;
      goto LABEL_115;
    }
  }
  else if (v1 > 1734505011)
  {
    if (v1 > 1751411058)
    {
      if (v1 != 1751411059 && v1 != 1751527984)
      {
        v4 = 1751527986;
        goto LABEL_115;
      }
    }
    else if (v1 != 1734505012 && v1 != 1735549492)
    {
      v4 = 1751410032;
      goto LABEL_115;
    }
  }
  else if (((v1 - 1667844406) > 0x32 || ((1 << (v1 - 54)) & 0x5000000000005) == 0)
         && v1 != 1717855600)
  {
    v4 = 1717856627;
    goto LABEL_115;
  }
  return result;
}

uint64_t equivalent_uncompressed_format(uint64_t result)
{
  int v1;
  int v2;
  int v3;
  int v4;

  if ((result & 0xFD000000) == 0x2D000000 || (int)result >> 24 == 124 || (int)result >> 24 == 38)
  {
    v1 = result & 0xFFFFFF | 0x20000000;
    if (v1 <= 542271552)
    {
      if (v1 <= 540571185)
      {
        if (v1 > 540567087)
        {
          if (v1 > 540567091)
          {
            if (v1 == 540567092)
              return 875836518;
            if (v1 == 540571184)
            {
              v2 = 875704422;
              return v2 | 0x10u;
            }
          }
          else
          {
            if (v1 == 540567088)
              return 875704422;
            if (v1 == 540567090)
              return 875704934;
          }
          return 0;
        }
        if (v1 == 540160056)
          return 843264056;
        if (v1 != 540160104)
        {
          if (v1 == 540292208)
            return 2016687216;
          return 0;
        }
        v4 = 843264056;
      }
      else
      {
        if (v1 <= 541864039)
        {
          if (v1 > 541214528)
          {
            if (v1 == 541214529)
              return 1111970369;
            if (v1 == 541863992)
              return 1278226488;
          }
          else
          {
            if (v1 == 540571186)
              return 875704950;
            if (v1 == 540571188)
            {
              v2 = 875836518;
              return v2 | 0x10u;
            }
          }
          return 0;
        }
        if (v1 > 541864241)
        {
          if (v1 == 541864242)
            return 1278226738;
          if (v1 == 541864246)
            return 1278226742;
          return 0;
        }
        if (v1 != 541864040)
        {
          if (v1 == 541864240)
            return 1278226736;
          return 0;
        }
        v4 = 1278226488;
      }
      return (v4 + 48);
    }
    if (v1 <= 544761391)
    {
      if (v1 > 543712815)
      {
        if (v1 > 544682865)
        {
          if (v1 == 544682866)
            return 1999843442;
          if (v1 == 544683105)
            return 1999908961;
        }
        else
        {
          if (v1 == 543712816)
            return 1751527984;
          if (v1 == 543961458)
            return 1815162994;
        }
        return 0;
      }
      if (v1 == 542271553)
        return 1380411457;
      if (v1 == 543306552)
        return 1647534392;
      if (v1 != 543569008)
        return 0;
      v3 = 2016687216;
    }
    else
    {
      if (v1 > 544765489)
      {
        if (v1 > 544830821)
        {
          if (v1 == 544830822)
            return 2037741158;
          if (v1 == 544830835)
            return 2037741171;
        }
        else
        {
          if (v1 == 544765490)
            return 1882468914;
          if (v1 == 544765492)
            return 1882469428;
        }
        return 0;
      }
      if (v1 > 544761395)
      {
        if (v1 == 544761396)
          return 1885746228;
        if (v1 == 544765488)
          return 1882468912;
        return 0;
      }
      if (v1 != 544761392)
      {
        if (v1 == 544761394)
          return 1885745714;
        return 0;
      }
      v3 = 1882468912;
    }
    return (v3 + 3276800);
  }
  return result;
}

uint64_t CI::format_from_PixelFormatType(CI *this)
{
  int v1;
  uint64_t result;
  int v3;
  unsigned int v4;
  unsigned int v5;

  v1 = equivalent_uncompressed_format((uint64_t)this);
  result = 0;
  if (v1 > 1667839023)
  {
    if (v1 <= 1919379251)
    {
      if (v1 <= 1751527983)
      {
        if (v1 > 1717855599)
        {
          if (v1 > 1735549491)
          {
            if (v1 == 1735549492)
              return 771;
            if (v1 != 1751410032 && v1 != 1751411059)
              return result;
            return 2051;
          }
          if (v1 != 1717855600 && v1 != 1717856627)
          {
            v3 = 1734505012;
            goto LABEL_59;
          }
          return 2307;
        }
        if (v1 <= 1667844407)
        {
          if (v1 == 1667844406)
            v5 = 1794;
          else
            v5 = 0;
          if (v1 == 1667839024)
            return 3081;
          else
            return v5;
        }
        else
        {
          switch(v1)
          {
            case 1667844408:
              return 258;
            case 1667844454:
              return 2306;
            case 1667844456:
              return 2050;
          }
        }
      }
      else if (v1 > 1882468911)
      {
        if (v1 > 1885745711)
        {
          switch(v1)
          {
            case 1885745712:
              return 1298;
            case 1885745714:
              return 1302;
            case 1885746228:
              return 1299;
          }
        }
        else
        {
          switch(v1)
          {
            case 1882468912:
              return 1554;
            case 1882468914:
              return 1558;
            case 1882469428:
              return 1555;
          }
        }
      }
      else if (v1 > 1815162993)
      {
        switch(v1)
        {
          case 1815162994:
            return 784;
          case 1815361650:
            return 1799;
          case 1815491698:
            return 1800;
        }
      }
      else
      {
        switch(v1)
        {
          case 1751527984:
            return 2066;
          case 1751527986:
            return 2070;
          case 1751528500:
            return 2067;
        }
      }
    }
    else if (v1 > 1953903667)
    {
      if (v1 > 2019963439)
      {
        if (v1 > 2033463351)
        {
          switch(v1)
          {
            case 2033463352:
              return 535;
            case 2037741158:
              return 277;
            case 2037741171:
              return 533;
          }
        }
        else
        {
          switch(v1)
          {
            case 2019963440:
              return 786;
            case 2019963442:
              return 790;
            case 2019963956:
              return 787;
          }
        }
      }
      else if (v1 > 2016686639)
      {
        switch(v1)
        {
          case 2016686640:
            return 1042;
          case 2016686642:
            return 1046;
          case 2016687156:
            return 1043;
        }
      }
      else
      {
        switch(v1)
        {
          case 1953903668:
            return 3603;
          case 1999843442:
            return 2567;
          case 1999908961:
            return 2569;
        }
      }
    }
    else if (v1 > 1937126451)
    {
      if (v1 > 1952855091)
      {
        switch(v1)
        {
          case 1952855092:
            return 3347;
          case 1953903152:
            return 3602;
          case 1953903154:
            return 3606;
        }
      }
      else
      {
        switch(v1)
        {
          case 1937126452:
            return 3859;
          case 1952854576:
            return 3346;
          case 1952854578:
            return 3350;
        }
      }
    }
    else if (v1 > 1936077875)
    {
      switch(v1)
      {
        case 1936077876:
          return 1811;
        case 1937125936:
          return 3858;
        case 1937125938:
          return 3862;
      }
    }
    else
    {
      switch(v1)
      {
        case 1919379252:
          return 771;
        case 1936077360:
          return 1810;
        case 1936077362:
          return 1814;
      }
    }
  }
  else if (v1 <= 1093677157)
  {
    if (v1 <= 843264303)
    {
      if (v1 <= 826487087)
      {
        if (v1 <= 826486839)
        {
          if (v1 == 32)
            v4 = 265;
          else
            v4 = 0;
          if (v1 == 24)
            return 263;
          else
            return v4;
        }
        else
        {
          switch(v1)
          {
            case 826486840:
              return 261;
            case 826486886:
              return 2309;
            case 826486888:
              return 2053;
          }
        }
      }
      else if (v1 > 843264055)
      {
        switch(v1)
        {
          case 843264056:
            return 262;
          case 843264102:
            return 2310;
          case 843264104:
            return 2054;
        }
      }
      else
      {
        switch(v1)
        {
          case 826487088:
            return 773;
          case 826487090:
            return 3333;
          case 826487094:
            return 1797;
        }
      }
    }
    else if (v1 > 875704437)
    {
      if (v1 > 875836517)
      {
        switch(v1)
        {
          case 875836518:
            return 275;
          case 875836534:
            return 531;
          case 1093677112:
            return 257;
        }
      }
      else
      {
        switch(v1)
        {
          case 875704438:
            return 530;
          case 875704934:
            return 278;
          case 875704950:
            return 534;
        }
      }
    }
    else if (v1 > 846624101)
    {
      switch(v1)
      {
        case 846624102:
          return 276;
        case 846624121:
          return 532;
        case 875704422:
          return 274;
      }
    }
    else
    {
      switch(v1)
      {
        case 843264304:
          return 774;
        case 843264306:
          return 3334;
        case 843264310:
          return 1798;
      }
    }
  }
  else
  {
    if (v1 <= 1279340645)
    {
      if (v1 <= 1278226533)
      {
        if (v1 > 1094862673)
        {
          switch(v1)
          {
            case 1094862674:
              return 267;
            case 1111970369:
              return 266;
            case 1278226488:
              return 259;
          }
        }
        else
        {
          switch(v1)
          {
            case 1093677158:
              return 2305;
            case 1093677160:
              return 2049;
            case 1093677366:
              return 1793;
          }
        }
        return result;
      }
      if (v1 <= 1278226737)
      {
        if (v1 != 1278226534)
        {
          if (v1 != 1278226536)
          {
            v3 = 1278226736;
LABEL_59:
            if (v1 != v3)
              return result;
            return 771;
          }
          return 2051;
        }
        return 2307;
      }
      if (v1 == 1278226738)
        return 3331;
      if (v1 == 1278226742)
        return 1795;
      if (v1 != 1279340600)
        return result;
      return 260;
    }
    if (v1 > 1380411456)
    {
      if (v1 > 1667838767)
      {
        switch(v1)
        {
          case 1667838768:
            return 3079;
          case 1667838822:
            return 2311;
          case 1667838824:
            return 2055;
        }
      }
      else
      {
        switch(v1)
        {
          case 1380411457:
            return 2056;
          case 1650943796:
            return 771;
          case 1667838256:
            return 785;
        }
      }
    }
    else if (v1 > 1279342647)
    {
      switch(v1)
      {
        case 1279342648:
          return 260;
        case 1380401729:
          return 264;
        case 1380410945:
          return 2312;
      }
    }
    else
    {
      switch(v1)
      {
        case 1279340646:
          return 2308;
        case 1279340648:
          return 2052;
        case 1279340854:
          return 1796;
      }
    }
  }
  return result;
}

BOOL CI::format_has_unpremul_alpha(int a1)
{
  return a1 == 535 || (a1 & 0xFFFFFFFE) == 784;
}

uint64_t CI::format_from_IOSurface(CI *this, __IOSurface *a2)
{
  CI *PixelFormat;
  uint64_t v4;
  CFTypeRef v5;
  const void *v6;

  PixelFormat = (CI *)IOSurfaceGetPixelFormat(this);
  v4 = CI::format_from_PixelFormatType(PixelFormat);
  v5 = IOSurfaceCopyValue(this, CFSTR("IOSurfaceAlphaIsOpaque"));
  v6 = v5;
  if (v5 == (CFTypeRef)*MEMORY[0x1E0C9AE50])
  {
    v4 = CI::format_with_x_for_format(v4);
    if (!v6)
      return v4;
    goto LABEL_3;
  }
  if (v5)
LABEL_3:
    CFRelease(v6);
  return v4;
}

uint64_t CI::format_has_alpha(int a1)
{
  uint64_t result;
  unsigned int v3;

  result = 1;
  if (a1 > 2048)
  {
    if (a1 <= 2568)
    {
      if ((a1 - 2305) > 8 || ((1 << (a1 - 1)) & 0x18B) == 0)
      {
        v3 = a1 - 2049;
        if (v3 > 7 || ((1 << v3) & 0x8B) == 0)
          return 0;
      }
    }
    else if (a1 != 2569 && a1 != 2824 && a1 != 3081)
    {
      return 0;
    }
  }
  else if (a1 > 783)
  {
    if (((a1 - 1793) > 8 || ((1 << (a1 - 1)) & 0x18B) == 0) && (a1 - 784) >= 2)
      return 0;
  }
  else if (((a1 - 257) > 0xA || ((1 << (a1 - 1)) & 0x78B) == 0) && a1 != 535)
  {
    return 0;
  }
  return result;
}

CI::ColorMatchImage *CI::ColorMatchImage::ColorMatchImage(CI::ColorMatchImage *this, CI::Image *a2, CGColorSpace *a3, int a4)
{
  unsigned int v8;
  CGColorSpaceRef v9;
  BOOL IsHDR;
  float v11;

  *((_QWORD *)CI::ImageWithChild::ImageWithChild(this, a2) + 14) = off_1E2EBBDD0;
  do
    v8 = __ldaxr(&dword_1ECF872F0[2]);
  while (__stlxr(v8 + 1, &dword_1ECF872F0[2]));
  *(_QWORD *)this = &off_1E2EBB490;
  *((_QWORD *)this + 14) = &unk_1E2EBB5E8;
  *((_BYTE *)this + 138) = 0;
  *((_DWORD *)this + 35) = 0;
  v9 = CGColorSpaceRetain(a3);
  *((_WORD *)this + 68) = 256;
  *((_QWORD *)this + 15) = v9;
  *((_QWORD *)this + 16) = 0;
  if (a4)
  {
    IsHDR = CGColorSpaceIsHDR(a3);
    v11 = 1.0;
  }
  else
  {
    IsHDR = 0;
    v11 = 0.0;
  }
  *((_BYTE *)this + 138) = IsHDR;
  *((float *)this + 35) = v11;
  *((_QWORD *)this + 10) = CI::ColorMatchImage::makeDigest(*((_QWORD *)a2 + 10), a3, 0, v11);
  *((_QWORD *)this + 11) = CI::ColorMatchImage::makeDigest(*((_QWORD *)a2 + 11), a3, 0, *((float *)this + 35));
  return this;
}

uint64_t CI::ColorMatchImage::type(CI::ColorMatchImage *this)
{
  return 4;
}

uint64_t CI::XXHashHelper::add(CI::XXHashHelper *this, CFStringRef theString)
{
  char *CStringPtr;
  char buffer[1024];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (theString)
  {
    CStringPtr = (char *)CFStringGetCStringPtr(theString, 0x8000100u);
    if (!CStringPtr)
    {
      if (CFStringGetCString(theString, buffer, 1024, 0x8000100u))
        CStringPtr = buffer;
      else
        CStringPtr = 0;
    }
    return CI::XXHashHelper::addstr((uint64_t)this, CStringPtr);
  }
  else
  {
    *(_DWORD *)buffer = 0;
    return XXH64_update((uint64_t)this, buffer, 4uLL);
  }
}

uint64_t CI::XXHashHelper::addstr(uint64_t this, char *__s)
{
  uint64_t v3;

  if (__s)
  {
    v3 = this;
    this = strlen(__s);
    if (this)
      return XXH64_update(v3, __s, this);
  }
  return this;
}

void CI::XXHashHelper::add(CI::XXHashHelper *this, CGColorSpaceRef space)
{
  const __CFString *Name;
  const __CFData *v5;
  const __CFData *v6;
  const char *__src;

  if (space)
  {
    if (CGColorSpaceGetName(space))
    {
      Name = CGColorSpaceGetName(space);
      CI::XXHashHelper::add(this, Name);
      return;
    }
    v5 = CGColorSpaceCopyICCData(space);
    if (v5)
    {
      v6 = v5;
      CI::XXHashHelper::add(this, v5);
      CFRelease(v6);
      return;
    }
    __src = (const char *)space;
  }
  else
  {
    __src = "nilCGColorSpaceRef";
  }
  XXH64_update((uint64_t)this, (char *)&__src, 8uLL);
}

CI::ImageWithChild *CI::ImageWithChild::ImageWithChild(CI::ImageWithChild *this, CI::Image *a2)
{
  __int128 v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  CI::FillImage *v9;

  *((_DWORD *)this + 2) = 1;
  *(_QWORD *)this = off_1E2EBE8A8;
  v4 = *(_OWORD *)(MEMORY[0x1E0C9D628] + 16);
  *((_OWORD *)this + 1) = *MEMORY[0x1E0C9D628];
  *((_OWORD *)this + 2) = v4;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_WORD *)this + 48) = 0;
  do
  {
    v5 = __ldaxr(&CI::gImageCounter);
    v6 = v5 + 1;
  }
  while (__stlxr(v6, &CI::gImageCounter));
  *((_DWORD *)this + 25) = v6;
  *(_QWORD *)this = &off_1E2EBA8B8;
  if (a2)
  {
    v7 = CI::Object::ref((uint64_t)a2);
    v8 = *((_DWORD *)a2 + 18) + 1;
  }
  else
  {
    v9 = (CI::FillImage *)operator new();
    v7 = CI::FillImage::FillImage(v9);
    v8 = 0;
  }
  *((_QWORD *)this + 13) = v7;
  *((_DWORD *)this + 18) = v8;
  *((_WORD *)this + 48) = *((_WORD *)a2 + 48);
  return this;
}

CI::AffineImage *CI::AffineImage::AffineImage(CI::AffineImage *this, CI::Image *a2, const CI::Affine *a3, int a4)
{
  unsigned int v8;
  __int128 v9;
  __int128 v10;

  *((_QWORD *)CI::ImageWithChild::ImageWithChild(this, a2) + 14) = off_1E2EBBAB0;
  do
    v8 = __ldaxr(dword_1ECF872F0);
  while (__stlxr(v8 + 1, dword_1ECF872F0));
  *(_QWORD *)this = &unk_1E2EB8650;
  *((_QWORD *)this + 14) = &unk_1E2EB87A8;
  v9 = *(_OWORD *)a3;
  v10 = *((_OWORD *)a3 + 1);
  *(_OWORD *)((char *)this + 152) = *((_OWORD *)a3 + 2);
  *(_OWORD *)((char *)this + 136) = v10;
  *(_OWORD *)((char *)this + 120) = v9;
  *((_BYTE *)this + 168) = a4;
  *((_QWORD *)this + 10) = CI::AffineImage::makeDigest(*((_QWORD *)a2 + 10), (char *)a3, a4);
  *((_QWORD *)this + 11) = CI::AffineImage::makeDigest(*((_QWORD *)a2 + 11), (char *)a3, a4);
  if (!CI::Affine::isOrientationWithIntegralTranslation(a3))
    *((_BYTE *)this + 97) = 0;
  return this;
}

void sub_1921F2288(_Unwind_Exception *a1)
{
  CI::ImageWithChild *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v5;
  unsigned int v6;

  *((_QWORD *)v1 + 14) = v2;
  v5 = (unsigned int *)(v3 + 8);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 - 1, v5));
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

uint64_t CI_NO_CM()
{
  unsigned __int8 v0;

  {
    CI_NO_CM::v = get_BOOL("CI_NO_CM", 0);
  }
  return CI_NO_CM::v;
}

void sub_1921F2318(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double iosurface_limits@<D0>(uint64_t a1@<X8>)
{
  double result;

  if (iosurface_limits_once != -1)
    dispatch_once(&iosurface_limits_once, &__block_literal_global_82);
  result = *(double *)&iosurface_limits_limits;
  *(_OWORD *)a1 = iosurface_limits_limits;
  *(_QWORD *)(a1 + 16) = qword_1ECF87180;
  return result;
}

uint64_t CI::format_from_CGImageProvider(uint64_t result)
{
  unsigned int v1;
  uint64_t PixelSize;
  uint64_t v3;
  CGColorSpace *ColorSpace;
  CGColorSpaceModel Model;
  int AlphaInfo;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  char v13;
  char v14;
  char v15;
  char v16;
  BOOL v17;
  unsigned int v18;
  char v19;
  char v20;
  char v21;
  int v22;
  int v23;
  int v24;
  int v25;
  char v26;
  int v27;
  char v28;
  char v29;
  char v30;

  if (result)
  {
    v1 = CGImageProviderGetComponentType() - 1;
    if (v1 > 5)
      return 0;
    PixelSize = CGImageProviderGetPixelSize();
    v3 = 8 * PixelSize;
    if (8 * PixelSize != 128
      && (PixelSize & 0x1FFFFFFFFFFFFFFBLL) != 8
      && (PixelSize & 0x1FFFFFFFFFFFFFFDLL) != 4
      && (PixelSize & 0x1FFFFFFFFFFFFFFDLL) != 1
      && v3 != 16)
    {
      return 0;
    }
    ColorSpace = (CGColorSpace *)CGImageProviderGetColorSpace();
    Model = CGColorSpaceGetModel(ColorSpace);
    AlphaInfo = CGImageProviderGetAlphaInfo();
    if (Model == kCGColorSpaceModelRGB)
    {
      v8 = 0;
      v7 = 1;
    }
    else
    {
      result = 0;
      if (Model)
        return result;
      v7 = 0;
      v8 = 1;
    }
    result = 0;
    switch(v1)
    {
      case 0u:
        if (v3 == 8)
          v9 = v8;
        else
          v9 = 0;
        if (v9 == 1 && !AlphaInfo)
          return 259;
        v16 = v8 ^ 1;
        if (v3 != 16)
          v16 = 1;
        if ((v16 & 1) == 0)
        {
          v17 = ((AlphaInfo - 1) & 0xFFFFFFFD) == 0;
          v18 = 260;
          goto LABEL_69;
        }
        if (v3 == 24)
          v22 = v7;
        else
          v22 = 0;
        if (v22 == 1 && !AlphaInfo)
          return 263;
        v26 = v7 ^ 1;
        if (v3 != 32)
          v26 = 1;
        if ((v26 & 1) != 0)
          return 0;
        v27 = CGImageProviderGetBitmapInfo() - 1;
        result = 264;
        switch(v27)
        {
          case 0:
          case 2:
            return result;
          case 1:
          case 3:
            return 265;
          case 4:
            goto LABEL_131;
          case 5:
            return 269;
          default:
            if ((AlphaInfo | 2) == 3)
              return 264;
            if (AlphaInfo != 5)
              return 0;
LABEL_131:
            result = 268;
            break;
        }
        return result;
      case 1u:
        if (v3 == 16)
          v10 = v8;
        else
          v10 = 0;
        if (v10 == 1 && !AlphaInfo)
          return 1795;
        v19 = v8 ^ 1;
        if (v3 != 32)
          v19 = 1;
        if ((v19 & 1) == 0)
        {
          v17 = ((AlphaInfo - 1) & 0xFFFFFFFD) == 0;
          v18 = 1796;
          goto LABEL_69;
        }
        if (v3 == 48)
          v23 = v7;
        else
          v23 = 0;
        if (v23 == 1 && !AlphaInfo)
          return 1799;
        v28 = v7 ^ 1;
        if (v3 != 64)
          v28 = 1;
        if ((v28 & 1) != 0)
          return 0;
        if ((AlphaInfo | 2) == 3)
          return 1800;
        if (AlphaInfo != 5)
          return 0;
        return 1804;
      case 3u:
        if (v3 == 32)
          v11 = v8;
        else
          v11 = 0;
        if (v11 == 1 && !AlphaInfo)
          return 2307;
        v20 = v8 ^ 1;
        if (v3 != 64)
          v20 = 1;
        if ((v20 & 1) == 0)
        {
          v17 = ((AlphaInfo - 1) & 0xFFFFFFFD) == 0;
          v18 = 2308;
          goto LABEL_69;
        }
        if (v3 == 96)
          v24 = v7;
        else
          v24 = 0;
        if (v24 == 1 && !AlphaInfo)
          return 2311;
        v29 = v7 ^ 1;
        if (v3 != 128)
          v29 = 1;
        if ((v29 & 1) != 0)
          return 0;
        if ((AlphaInfo | 2) == 3)
          return 2312;
        if (AlphaInfo != 5)
          return 0;
        return 2316;
      case 4u:
        if (v3 == 16)
          v12 = v8;
        else
          v12 = 0;
        if (v12 == 1 && !AlphaInfo)
          return 2051;
        v21 = v8 ^ 1;
        if (v3 != 32)
          v21 = 1;
        if ((v21 & 1) != 0)
        {
          if (v3 == 48)
            v25 = v7;
          else
            v25 = 0;
          if (v25 != 1 || AlphaInfo)
          {
            v30 = v7 ^ 1;
            if (v3 != 64)
              v30 = 1;
            if ((v30 & 1) != 0)
              return 0;
            if ((AlphaInfo | 2) == 3)
            {
              return 2056;
            }
            else
            {
              if (AlphaInfo != 5)
                return 0;
              return 2060;
            }
          }
          else
          {
            return 2055;
          }
        }
        else
        {
          v17 = ((AlphaInfo - 1) & 0xFFFFFFFD) == 0;
          v18 = 2052;
LABEL_69:
          if (v17)
            return v18;
          else
            return 0;
        }
      case 5u:
        if (v3 != 32)
          return 0;
        if (AlphaInfo == 3)
          v13 = v7;
        else
          v13 = 0;
        if ((v13 & 1) != 0)
          return 784;
        if (AlphaInfo == 5)
          v14 = v7;
        else
          v14 = 0;
        if ((v14 & 1) == 0)
        {
          if (AlphaInfo == 4)
            v15 = v7;
          else
            v15 = 0;
          if ((v15 & 1) != 0)
            return 784;
          if (AlphaInfo != 6)
            LOBYTE(v7) = 0;
          if ((v7 & 1) == 0)
            return 0;
        }
        result = 775;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t CI::alpha_mode_from_CGImageProvider(uint64_t result)
{
  unsigned int AlphaInfo;

  if (result)
  {
    AlphaInfo = CGImageProviderGetAlphaInfo();
    if (AlphaInfo > 5)
      return 0xFFFFFFFFLL;
    else
      return dword_19249B850[AlphaInfo];
  }
  return result;
}

uint64_t getContentDigestFromOptions(NSDictionary *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  size_t v4;
  char *p_src;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int64x2_t v23[5];
  uint64_t __src;

  v1 = -[NSDictionary objectForKey:](a1, "objectForKey:", CFSTR("kCIImageContentDigest"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    if ((unint64_t)objc_msgSend(v1, "length") >= 0x10)
    {
      XXH64_reset(v23, 0);
      v2 = objc_msgSend(v1, "bytes");
      v3 = objc_msgSend(v1, "length");
      if (!v2)
        return XXH64_digest((uint64_t)v23);
      v4 = v3;
      if (!v3)
        return XXH64_digest((uint64_t)v23);
      p_src = (char *)v2;
LABEL_13:
      XXH64_update((uint64_t)v23, p_src, v4);
      return XXH64_digest((uint64_t)v23);
    }
    v7 = ci_logger_api();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      getContentDigestFromOptions(v7, v8, v9, v10, v11, v12, v13, v14);
  }
  else
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
      return objc_msgSend(v1, "unsignedLongLongValue");
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      if ((unint64_t)objc_msgSend(v1, "length") >= 0x10)
      {
        XXH64_reset(v23, 0);
        __src = objc_msgSend(v1, "UTF8String");
        p_src = (char *)&__src;
        v4 = 8;
        goto LABEL_13;
      }
      v15 = ci_logger_api();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        getContentDigestFromOptions(v15, v16, v17, v18, v19, v20, v21, v22);
    }
  }
  return 0;
}

uint64_t CI::PixelFormatType_approx_from_format(int a1)
{
  uint64_t result;
  unsigned __int16 v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  BOOL v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  unsigned __int16 v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;

  result = 0;
  if (a1 <= 1792)
  {
    if (a1 <= 770)
    {
      switch(a1)
      {
        case 257:
          result = 1093677112;
          break;
        case 258:
          v30 = 1667844406;
LABEL_154:
          result = (v30 + 2);
          break;
        case 259:
          result = 1278226488;
          break;
        case 260:
          result = 1279340600;
          break;
        case 261:
          result = 826486840;
          break;
        case 262:
          result = 843264056;
          break;
        case 263:
          result = 24;
          break;
        case 264:
        case 268:
          v3 = 16961;
LABEL_15:
          result = v3 | 0x52470000u;
          break;
        case 265:
        case 269:
          result = 32;
          break;
        case 266:
        case 270:
          result = 1111970369;
          break;
        case 267:
        case 271:
          result = 1094862674;
          break;
        case 272:
        case 273:
          return result;
        case 274:
          result = 875704422;
          break;
        case 275:
          result = 875836518;
          break;
        case 276:
          result = 846624102;
          break;
        case 277:
          result = 2037741158;
          break;
        case 278:
          result = 875704934;
          break;
        default:
          switch(a1)
          {
            case 530:
              v20 = 875704422;
              goto LABEL_166;
            case 531:
              v20 = 875836518;
LABEL_166:
              result = v20 | 0x10u;
              break;
            case 532:
              result = 846624121;
              break;
            case 533:
              result = 2037741171;
              break;
            case 534:
              result = 875704950;
              break;
            case 535:
              result = 2033463352;
              break;
            default:
              return result;
          }
          break;
      }
    }
    else if (a1 > 1041)
    {
      if (a1 == 1558)
        v9 = 1882468914;
      else
        v9 = 0;
      if (a1 == 1555)
        v10 = 1882469428;
      else
        v10 = v9;
      if (a1 == 1554)
        v10 = 1882468912;
      if (a1 == 1302)
        v11 = 1885745714;
      else
        v11 = 0;
      if (a1 == 1299)
        v12 = 1885746228;
      else
        v12 = v11;
      if (a1 <= 1553)
        v10 = v12;
      v13 = 1885745712;
      if (a1 != 1298)
        v13 = 0;
      if (a1 == 1046)
        v13 = 2016686642;
      if (a1 == 1043)
        v14 = 2016687156;
      else
        v14 = 0;
      if (a1 == 1042)
        v15 = 2016686640;
      else
        v15 = v14;
      if (a1 <= 1045)
        v13 = v15;
      if (a1 <= 1298)
        return v13;
      else
        return v10;
    }
    else
    {
      switch(a1)
      {
        case 771:
          v23 = 1278226488;
          goto LABEL_113;
        case 773:
          v23 = 826486840;
          goto LABEL_113;
        case 774:
          v23 = 843264056;
LABEL_113:
          result = (v23 + 248);
          break;
        case 775:
        case 784:
          result = 1815162994;
          break;
        case 785:
          v24 = 12592;
LABEL_128:
          result = v24 | 0x63690000u;
          break;
        case 786:
          result = 2019963440;
          break;
        case 787:
          result = 2019963956;
          break;
        case 790:
          result = 2019963442;
          break;
        default:
          return result;
      }
    }
  }
  else
  {
    if (a1 > 2304)
    {
      if (a1 > 3080)
      {
        if (a1 <= 3349)
        {
          if (a1 == 3347)
            v16 = 1952855092;
          else
            v16 = 0;
          if (a1 == 3346)
            v17 = 1952854576;
          else
            v17 = v16;
          if (a1 == 3334)
            v5 = 843264306;
          else
            v5 = v17;
          if (a1 == 3333)
            v18 = 826487090;
          else
            v18 = 0;
          if (a1 == 3331)
            v19 = 1278226738;
          else
            v19 = v18;
          if (a1 == 3081)
            v7 = 1667839024;
          else
            v7 = v19;
          v8 = a1 <= 3333;
        }
        else
        {
          if (a1 == 3862)
            v4 = 1937125938;
          else
            v4 = 0;
          if (a1 == 3859)
            v5 = 1937126452;
          else
            v5 = v4;
          if (a1 == 3858)
            v6 = 1937125936;
          else
            v6 = 0;
          if (a1 == 3606)
            v6 = 1953903154;
          if (a1 <= 3858)
            v5 = v6;
          v7 = 1953903668;
          if (a1 != 3603)
            v7 = 0;
          if (a1 == 3602)
            v7 = 1953903152;
          if (a1 == 3350)
            v7 = 1952854578;
          v8 = a1 <= 3605;
        }
      }
      else
      {
        if (a1 <= 2566)
        {
          switch(a1)
          {
            case 2305:
              v25 = 1093677112;
              goto LABEL_124;
            case 2306:
              v26 = 1667844406;
              goto LABEL_145;
            case 2307:
              v25 = 1278226488;
              goto LABEL_124;
            case 2308:
              return 1279340646;
            case 2309:
              v25 = 826486840;
              goto LABEL_124;
            case 2310:
              v25 = 843264056;
LABEL_124:
              result = (v25 + 46);
              break;
            case 2311:
              result = 1667838822;
              break;
            case 2312:
            case 2313:
            case 2316:
              v3 = 26177;
              goto LABEL_15;
            default:
              return result;
          }
          return result;
        }
        if (a1 == 3079)
          v21 = 1667838768;
        else
          v21 = 0;
        if (a1 == 2824)
          v5 = 1815491698;
        else
          v5 = v21;
        if (a1 == 2569)
          v22 = 1999908961;
        else
          v22 = 0;
        if (a1 == 2567)
          v7 = 1999843442;
        else
          v7 = v22;
        v8 = a1 <= 2823;
      }
      if (v8)
        return v7;
      else
        return v5;
    }
    switch(a1)
    {
      case 1793:
        v27 = 1093677112;
        goto LABEL_133;
      case 1794:
        v24 = 18742;
        goto LABEL_128;
      case 1795:
        v27 = 1278226488;
        goto LABEL_133;
      case 1796:
        return 1279340854;
      case 1797:
        v27 = 826486840;
        goto LABEL_133;
      case 1798:
        v27 = 843264056;
LABEL_133:
        result = (v27 + 254);
        break;
      case 1799:
        result = 1815361650;
        break;
      case 1800:
      case 1804:
        result = 1815491698;
        break;
      case 1801:
        result = 1664496754;
        break;
      case 1802:
      case 1803:
      case 1805:
      case 1806:
      case 1807:
      case 1808:
      case 1809:
      case 1812:
      case 1813:
        return result;
      case 1810:
        result = 1936077360;
        break;
      case 1811:
        v28 = 1936077360;
LABEL_149:
        result = (v28 + 516);
        break;
      case 1814:
        v29 = 1936077360;
LABEL_151:
        result = v29 | 2u;
        break;
      default:
        switch(a1)
        {
          case 2049:
            v26 = 1093677112;
            goto LABEL_145;
          case 2050:
            return 1667844456;
          case 2051:
            v26 = 1278226488;
            goto LABEL_145;
          case 2052:
            v30 = 1279340646;
            goto LABEL_154;
          case 2053:
            v26 = 826486840;
            goto LABEL_145;
          case 2054:
            v26 = 843264056;
LABEL_145:
            result = (v26 + 48);
            break;
          case 2055:
            result = 1667838824;
            break;
          case 2056:
          case 2060:
            result = 1380411457;
            break;
          case 2066:
            result = 1751527984;
            break;
          case 2067:
            v28 = 1751527984;
            goto LABEL_149;
          case 2070:
            v29 = 1751527984;
            goto LABEL_151;
          default:
            return result;
        }
        break;
    }
  }
  return result;
}

uint64_t CI::format_is_supported_source_bitmap(int a1)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a1 != 2824)
      return CI::format_is_ycc_biplanar(a1) ^ 1;
  }
  return result;
}

uint64_t CI::PixelFormatType_from_format(int a1)
{
  uint64_t result;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  unsigned int v11;
  BOOL v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  unsigned __int16 v22;
  int v23;
  unsigned __int16 v24;
  int v25;
  int v26;

  result = 0;
  if (a1 <= 1792)
  {
    if (a1 > 770)
    {
      if (a1 > 1042)
      {
        if (a1 == 1558)
          v8 = 1882468914;
        else
          v8 = 0;
        if (a1 == 1555)
          v8 = 1882469428;
        if (a1 == 1554)
          v14 = 1882468912;
        else
          v14 = 0;
        if (a1 == 1302)
          v14 = 1885745714;
        if (a1 <= 1554)
          v8 = v14;
        v11 = 1885746228;
        if (a1 != 1299)
          v11 = 0;
        if (a1 == 1298)
          v11 = 1885745712;
        if (a1 == 1046)
          v15 = 2016686642;
        else
          v15 = 0;
        if (a1 == 1043)
          v15 = 2016687156;
        if (a1 <= 1297)
          v11 = v15;
        v12 = a1 <= 1301;
        goto LABEL_94;
      }
      switch(a1)
      {
        case 771:
          v5 = 1278226488;
          goto LABEL_138;
        case 772:
        case 775:
        case 776:
        case 777:
        case 778:
        case 779:
        case 780:
        case 781:
        case 782:
        case 783:
        case 788:
        case 789:
          return result;
        case 773:
          v5 = 826486840;
          goto LABEL_138;
        case 774:
          v5 = 843264056;
LABEL_138:
          result = (v5 + 248);
          break;
        case 784:
          result = 1815162994;
          break;
        case 785:
          v24 = 12592;
LABEL_141:
          result = v24 | 0x63690000u;
          break;
        case 786:
          result = 2019963440;
          break;
        case 787:
          result = 2019963956;
          break;
        case 790:
          result = 2019963442;
          break;
        default:
          if (a1 == 1042)
            result = 2016686640;
          else
            result = 0;
          break;
      }
    }
    else
    {
      switch(a1)
      {
        case 257:
          result = 1093677112;
          break;
        case 258:
          v23 = 1667844406;
LABEL_148:
          result = (v23 + 2);
          break;
        case 259:
          result = 1278226488;
          break;
        case 260:
          result = 1279340600;
          break;
        case 261:
          result = 826486840;
          break;
        case 262:
          result = 843264056;
          break;
        case 263:
          result = 24;
          break;
        case 264:
          v22 = 16961;
LABEL_112:
          result = v22 | 0x52470000u;
          break;
        case 265:
          result = 32;
          break;
        case 266:
          result = 1111970369;
          break;
        case 267:
          result = 1094862674;
          break;
        case 268:
        case 269:
        case 270:
        case 271:
        case 272:
        case 273:
          return result;
        case 274:
          result = 875704422;
          break;
        case 275:
          result = 875836518;
          break;
        case 276:
          result = 846624102;
          break;
        case 277:
          result = 2037741158;
          break;
        case 278:
          result = 875704934;
          break;
        default:
          switch(a1)
          {
            case 530:
              v16 = 875704422;
              goto LABEL_160;
            case 531:
              v16 = 875836518;
LABEL_160:
              result = v16 | 0x10u;
              break;
            case 532:
              result = 846624121;
              break;
            case 533:
              result = 2037741171;
              break;
            case 534:
              result = 875704950;
              break;
            case 535:
              result = 2033463352;
              break;
            default:
              return result;
          }
          break;
      }
    }
  }
  else
  {
    if (a1 > 2304)
    {
      if (a1 > 3330)
      {
        if (a1 > 3601)
        {
          if (a1 == 3862)
            v17 = 1937125938;
          else
            v17 = 0;
          if (a1 == 3859)
            v18 = 1937126452;
          else
            v18 = v17;
          if (a1 == 3858)
            v8 = 1937125936;
          else
            v8 = v18;
          if (a1 == 3606)
            v19 = 1953903154;
          else
            v19 = 0;
          if (a1 == 3603)
            v20 = 1953903668;
          else
            v20 = v19;
          if (a1 == 3602)
            v11 = 1953903152;
          else
            v11 = v20;
          v12 = a1 <= 3857;
        }
        else
        {
          if (a1 == 3350)
            v6 = 1952854578;
          else
            v6 = 0;
          if (a1 == 3347)
            v7 = 1952855092;
          else
            v7 = v6;
          if (a1 == 3346)
            v8 = 1952854576;
          else
            v8 = v7;
          if (a1 == 3334)
            v9 = 843264306;
          else
            v9 = 0;
          if (a1 == 3333)
            v10 = 826487090;
          else
            v10 = v9;
          if (a1 == 3331)
            v11 = 1278226738;
          else
            v11 = v10;
          v12 = a1 <= 3345;
        }
      }
      else
      {
        if (a1 <= 2566)
        {
          switch(a1)
          {
            case 2305:
              v3 = 1093677112;
              goto LABEL_102;
            case 2306:
              v13 = 1667844406;
              goto LABEL_151;
            case 2307:
              v3 = 1278226488;
              goto LABEL_102;
            case 2308:
              return 1279340646;
            case 2309:
              v3 = 826486840;
              goto LABEL_102;
            case 2310:
              v3 = 843264056;
LABEL_102:
              result = (v3 + 46);
              break;
            case 2311:
              result = 1667838822;
              break;
            case 2312:
              v22 = 26177;
              goto LABEL_112;
            default:
              return result;
          }
          return result;
        }
        if (a1 == 3081)
          v8 = 1667839024;
        else
          v8 = 0;
        if (a1 == 3079)
          v8 = 1667838768;
        if (a1 == 2569)
          v21 = 1999908961;
        else
          v21 = 0;
        if (a1 == 2567)
          v11 = 1999843442;
        else
          v11 = v21;
        v12 = a1 <= 3078;
      }
LABEL_94:
      if (v12)
        return v11;
      else
        return v8;
    }
    switch(a1)
    {
      case 1793:
        v4 = 1093677112;
        goto LABEL_126;
      case 1794:
        v24 = 18742;
        goto LABEL_141;
      case 1795:
        v4 = 1278226488;
        goto LABEL_126;
      case 1796:
        return 1279340854;
      case 1797:
        v4 = 826486840;
        goto LABEL_126;
      case 1798:
        v4 = 843264056;
LABEL_126:
        result = (v4 + 254);
        break;
      case 1799:
        result = 1815361650;
        break;
      case 1800:
        result = 1815491698;
        break;
      case 1801:
        result = 1664496754;
        break;
      case 1802:
      case 1803:
      case 1804:
      case 1805:
      case 1806:
      case 1807:
      case 1808:
      case 1809:
      case 1812:
      case 1813:
        return result;
      case 1810:
        result = 1936077360;
        break;
      case 1811:
        v25 = 1936077360;
LABEL_156:
        result = (v25 + 516);
        break;
      case 1814:
        v26 = 1936077360;
LABEL_158:
        result = v26 | 2u;
        break;
      default:
        switch(a1)
        {
          case 2049:
            v13 = 1093677112;
            goto LABEL_151;
          case 2050:
            return 1667844456;
          case 2051:
            v13 = 1278226488;
            goto LABEL_151;
          case 2052:
            v23 = 1279340646;
            goto LABEL_148;
          case 2053:
            v13 = 826486840;
            goto LABEL_151;
          case 2054:
            v13 = 843264056;
LABEL_151:
            result = (v13 + 48);
            break;
          case 2055:
            result = 1667838824;
            break;
          case 2056:
            result = 1380411457;
            break;
          case 2066:
            result = 1751527984;
            break;
          case 2067:
            v25 = 1751527984;
            goto LABEL_156;
          case 2070:
            v26 = 1751527984;
            goto LABEL_158;
          default:
            return result;
        }
        break;
    }
  }
  return result;
}

uint64_t CI::alpha_mode_from_CGImage(uint64_t this, CGImage *a2)
{
  CGImage *v2;
  uint64_t ImageProvider;
  uint64_t v4;
  CGImageAlphaInfo AlphaInfo;

  if (this)
  {
    v2 = (CGImage *)this;
    ImageProvider = CGImageGetImageProvider();
    if (ImageProvider && (v4 = ImageProvider, CI::format_from_CGImageProvider(ImageProvider)))
    {
      return CI::alpha_mode_from_CGImageProvider(v4);
    }
    else
    {
      AlphaInfo = CGImageGetAlphaInfo(v2);
      if (AlphaInfo > kCGImageAlphaOnly)
        return 0xFFFFFFFFLL;
      else
        return dword_19249B830[AlphaInfo];
    }
  }
  return this;
}

uint64_t CI::format_is_ycc_biplanar(int a1)
{
  uint64_t result;
  unsigned int v3;

  result = 1;
  if (a1 <= 1553)
  {
    if (a1 <= 785)
    {
      if ((a1 - 274) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0)
        return result;
      v3 = a1 - 530;
      goto LABEL_15;
    }
    if (((a1 - 786) > 4 || ((1 << (a1 - 18)) & 0x13) == 0)
      && ((a1 - 1042) > 4 || ((1 << (a1 - 18)) & 0x13) == 0))
    {
      v3 = a1 - 1298;
      goto LABEL_15;
    }
  }
  else if (a1 > 3345)
  {
    if (((a1 - 3346) > 4 || ((1 << (a1 - 18)) & 0x13) == 0)
      && ((a1 - 3602) > 4 || ((1 << (a1 - 18)) & 0x13) == 0))
    {
      v3 = a1 - 3858;
      goto LABEL_15;
    }
  }
  else if (((a1 - 1554) > 4 || ((1 << (a1 - 18)) & 0x13) == 0)
         && ((a1 - 1810) > 4 || ((1 << (a1 - 18)) & 0x13) == 0))
  {
    v3 = a1 - 2066;
LABEL_15:
    if (v3 > 4 || ((1 << v3) & 0x13) == 0)
      return 0;
  }
  return result;
}

uint64_t CI::format_from_CGImage(uint64_t this, CGImage *a2)
{
  CGImage *v2;
  uint64_t ImageProvider;
  size_t BitsPerComponent;
  size_t BitsPerPixel;
  unint64_t v6;
  __int128 v7;
  CGColorSpace *ColorSpace;
  CGColorSpaceModel Model;
  CGBitmapInfo BitmapInfo;
  CGImageAlphaInfo AlphaInfo;
  CGImagePixelFormatInfo PixelFormatInfo;
  int v13;
  BOOL v14;
  int v15;
  char v17;
  _BOOL4 v18;
  BOOL v19;
  char v20;
  int v21;
  _BOOL4 v22;
  int v23;
  int v24;
  char v25;
  char v26;
  char v27;
  unsigned int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;

  if (this)
  {
    v2 = (CGImage *)this;
    ImageProvider = CGImageGetImageProvider();
    if (!ImageProvider || (this = CI::format_from_CGImageProvider(ImageProvider), !(_DWORD)this))
    {
      BitsPerComponent = CGImageGetBitsPerComponent(v2);
      this = 0;
      if (BitsPerComponent <= 0x20 && ((1 << BitsPerComponent) & 0x100010500) != 0)
      {
        BitsPerPixel = CGImageGetBitsPerPixel(v2);
        this = 0;
        *((_QWORD *)&v7 + 1) = BitsPerPixel;
        *(_QWORD *)&v7 = BitsPerPixel - 8;
        v6 = v7 >> 3;
        if (v6 <= 0xF && ((1 << v6) & 0x88AF) != 0)
        {
          ColorSpace = CGImageGetColorSpace(v2);
          Model = CGColorSpaceGetModel(ColorSpace);
          BitmapInfo = CGImageGetBitmapInfo(v2);
          AlphaInfo = CGImageGetAlphaInfo(v2);
          PixelFormatInfo = CGImageGetPixelFormatInfo(v2);
          v13 = BitmapInfo & 0x7000;
          v14 = (PixelFormatInfo & 0x30000) != 0 && BitsPerComponent == 10;
          v15 = BitmapInfo & 0x7100;
          v17 = v14 && v15 == 0x2000;
          v18 = (BitmapInfo & 0x100) == 0 && BitsPerComponent == 8;
          v19 = (BitmapInfo & 0x100) == 0 || BitsPerComponent != 32;
          v20 = v13 != 0x2000 || v19;
          if (v13 == 4096)
            v21 = (BitsPerComponent == 16) & ((unsigned __int16)(BitmapInfo & 0x100) >> 8);
          else
            v21 = 0;
          v22 = v15 == 4096 && BitsPerComponent == 16;
          if (Model == kCGColorSpaceModelRGB)
          {
            v24 = 0;
            v23 = 1;
          }
          else
          {
            this = 0;
            if (Model)
              return this;
            v23 = 0;
            v24 = 1;
          }
          v25 = v17 ^ 1;
          if (BitsPerPixel != 32)
            v25 = 1;
          if ((v25 & 1) == 0)
          {
            if (AlphaInfo == kCGImageAlphaFirst)
              v26 = v23;
            else
              v26 = 0;
            if ((v26 & 1) != 0)
              return 784;
            v27 = AlphaInfo == kCGImageAlphaNoneSkipFirst ? v23 : 0;
            if ((v27 & 1) != 0)
              return 775;
          }
          v28 = AlphaInfo & 0xFFFFFFFD;
          if (v22)
          {
            if (BitsPerPixel == 16)
              v29 = v24;
            else
              v29 = 0;
            if (v29 == 1 && AlphaInfo == kCGImageAlphaNone)
              return 1795;
            if (BitsPerPixel != 32)
              v24 = 0;
            if (v24 == 1 && v28 == 1)
              return 1796;
            if (BitsPerPixel == 48)
              v32 = v23;
            else
              v32 = 0;
            if (v32 == 1 && AlphaInfo == kCGImageAlphaNone)
              return 1799;
            if (BitsPerPixel != 64)
              return 0;
            if (v23 && v28 == 1)
              return 1800;
            if (!v23)
              return 0;
            this = 1801;
            if (AlphaInfo != kCGImageAlphaPremultipliedFirst && AlphaInfo != kCGImageAlphaFirst)
            {
              if (AlphaInfo == kCGImageAlphaNoneSkipLast)
                return 1804;
              return 0;
            }
          }
          else
          {
            if (v21)
            {
              if (BitsPerPixel == 16)
                v30 = v24;
              else
                v30 = 0;
              if (v30 == 1 && AlphaInfo == kCGImageAlphaNone)
                return 2051;
              if (BitsPerPixel != 32)
                v24 = 0;
              if (v24 == 1 && v28 == 1)
                return 2052;
              if (BitsPerPixel == 48)
                v34 = v23;
              else
                v34 = 0;
              if (v34 == 1 && AlphaInfo == kCGImageAlphaNone)
                return 2055;
              if (BitsPerPixel == 64)
              {
                if (v23 && v28 == 1)
                  return 2056;
                if (AlphaInfo != kCGImageAlphaNoneSkipLast)
                  LOBYTE(v23) = 0;
                if ((v23 & 1) != 0)
                  return 2060;
              }
              return 0;
            }
            if ((v20 & 1) != 0)
            {
              if (!v18)
                return 0;
              if (BitsPerPixel == 8)
                v31 = v24;
              else
                v31 = 0;
              if (v31 == 1 && AlphaInfo == kCGImageAlphaNone)
                return 259;
              if (BitsPerPixel != 16)
                v24 = 0;
              if (v24 == 1 && v28 == 1)
                return 260;
              if (BitsPerPixel != 24)
                v23 = 0;
              if (v23 == 1 && AlphaInfo == kCGImageAlphaNone)
                return 263;
              if (BitsPerPixel != 32 || Model != kCGColorSpaceModelRGB)
                return 0;
              this = 264;
              switch(BitmapInfo)
              {
                case 1u:
                case 3u:
                  return this;
                case 2u:
                case 4u:
                  this = 265;
                  break;
                case 5u:
                  this = 268;
                  break;
                case 6u:
                  this = 269;
                  break;
                default:
                  switch(BitmapInfo)
                  {
                    case 0x2001u:
                    case 0x2003u:
                      this = 267;
                      break;
                    case 0x2002u:
                    case 0x2004u:
                      this = 266;
                      break;
                    case 0x2005u:
                      this = 271;
                      break;
                    case 0x2006u:
                      this = 270;
                      break;
                    default:
                      return 0;
                  }
                  break;
              }
            }
            else
            {
              if (BitsPerPixel == 32)
                v33 = v24;
              else
                v33 = 0;
              if (v33 == 1 && AlphaInfo == kCGImageAlphaNone)
                return 2307;
              if (BitsPerPixel != 64)
                v24 = 0;
              if (v24 == 1 && v28 == 1)
                return 2308;
              if (BitsPerPixel == 96)
                v35 = v23;
              else
                v35 = 0;
              if (v35 == 1 && AlphaInfo == kCGImageAlphaNone)
                return 2311;
              if (BitsPerPixel != 128)
                return 0;
              if (v23 && v28 == 1)
                return 2312;
              if (!v23)
                return 0;
              this = 2313;
              if (AlphaInfo != kCGImageAlphaPremultipliedFirst && AlphaInfo != kCGImageAlphaFirst)
              {
                if (AlphaInfo == kCGImageAlphaNoneSkipLast)
                  return 2316;
                return 0;
              }
            }
          }
        }
      }
    }
  }
  return this;
}

BOOL iosurface_creatable_from_cgblock(_BOOL8 result)
{
  double v1;
  double v2;
  double v3;
  unint64_t v4;
  unint64_t BytesPerRow;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;

  if (result)
  {
    CGImageBlockGetRect();
    v2 = v1;
    v4 = llround(v3);
    BytesPerRow = CGImageBlockGetBytesPerRow();
    v7 = 0;
    v8 = 0;
    v9 = 0;
    iosurface_limits((uint64_t)&v7);
    return v4 <= v7 && llround(v2) <= v8 && BytesPerRow <= v9;
  }
  return result;
}

const void *IOSurfaceWrapPointerOk(const void *result)
{
  unint64_t v1;
  size_t v2;
  int v3;

  if (result)
  {
    v1 = (unint64_t)result;
    v2 = malloc_size(result);
    v3 = getpagesize();
    if (v2 <= 32 * v3)
      return 0;
    else
      return (const void *)(v1 % v3 == 0);
  }
  return result;
}

uint64_t SurfaceApplyPlaneBlock(__IOSurface *a1, uint64_t a2)
{
  uint64_t result;
  size_t PlaneCount;
  void *BaseAddress;
  size_t BytesPerRow;
  size_t Width;
  size_t Height;
  size_t v10;
  size_t i;
  void *BaseAddressOfPlane;
  size_t BytesPerRowOfPlane;
  size_t WidthOfPlane;
  size_t HeightOfPlane;

  result = 3758097090;
  if (a1 && a2)
  {
    if (IOSurfaceGetCompressionTypeOfPlane())
    {
      x_log("Error: a compressed surface cannot be accessed via its base address.\n");
      return 3758097084;
    }
    PlaneCount = IOSurfaceGetPlaneCount(a1);
    if (PlaneCount <= 1)
    {
      result = IOSurfaceLock(a1, 0, 0);
      if ((_DWORD)result)
        return result;
      BaseAddress = IOSurfaceGetBaseAddress(a1);
      BytesPerRow = IOSurfaceGetBytesPerRow(a1);
      Width = IOSurfaceGetWidth(a1);
      Height = IOSurfaceGetHeight(a1);
      if (BaseAddress && BytesPerRow && Width)
      {
        if (Height)
          (*(void (**)(uint64_t, void *, _QWORD, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddress, 0, Width, Height, BytesPerRow);
      }
      IOSurfaceUnlock(a1, 0, 0);
      return 0;
    }
    v10 = PlaneCount;
    if ((PlaneCount & 0xFFFFFFFFFFFFFFFELL) != 2)
      return 0;
    for (i = 0; i != v10; ++i)
    {
      result = IOSurfaceLockPlane();
      if ((_DWORD)result)
        break;
      BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(a1, i);
      BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(a1, i);
      WidthOfPlane = IOSurfaceGetWidthOfPlane(a1, i);
      HeightOfPlane = IOSurfaceGetHeightOfPlane(a1, i);
      if (BaseAddressOfPlane && BytesPerRowOfPlane && WidthOfPlane && HeightOfPlane)
        (*(void (**)(uint64_t, void *, size_t, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddressOfPlane, i, WidthOfPlane, HeightOfPlane, BytesPerRowOfPlane);
      IOSurfaceUnlockPlane();
      result = 0;
    }
  }
  return result;
}

__IOSurface *CreateSurface(__CVBuffer *a1, __CVBuffer *a2, void *a3, uint64_t a4, int a5)
{
  _QWORD v6[3];

  memset(v6, 0, sizeof(v6));
  return CreateCachedSurface(a1, a2, a3, a4, (uint64_t)v6, a5);
}

uint64_t CI_IOSURFACE_WRAPPING(unsigned int a1)
{
  unsigned __int8 v2;

  {
    CI_IOSURFACE_WRAPPING::v = get_int("CI_IOSURFACE_WRAPPING", 3);
  }
  return CI_IOSURFACE_WRAPPING::v & a1;
}

void sub_1921F4A18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CI::Image::set_base_obj(CI::Image *this, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = (CFTypeRef)*((_QWORD *)this + 8);
  if (v3 != cf)
  {
    if (cf)
    {
      CFRetain(cf);
      v3 = (CFTypeRef)*((_QWORD *)this + 8);
    }
    if (v3)
      CFRelease(v3);
    *((_QWORD *)this + 8) = cf;
  }
}

__IOSurface *CreateCachedSurface(__CVBuffer *a1, __CVBuffer *a2, void *a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v12;
  __IOSurface *IOSurface;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  const CFDictionaryKeyCallBacks *v18;
  const CFDictionaryValueCallBacks *v19;
  __CFDictionary *v20;
  __CFDictionary *v21;
  const void *v22;
  CFNumberRef v23;
  const void *v24;
  uint64_t v25;
  CFNumberRef v26;
  CVPixelBufferRef v27;
  uint64_t v28;
  __CFDictionary *Mutable;
  const void *v30;
  CFNumberRef v31;
  const void *v32;
  CFNumberRef v33;
  const void *v34;
  CFNumberRef v35;
  const void *v36;
  CFNumberRef v37;
  CFNumberRef v38;
  CFNumberRef v39;
  uint64_t v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  int v44;
  int v45;
  unint64_t v46;
  const void *v47;
  CFNumberRef v48;
  const __CFDictionary *v49;
  int v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  __CVBuffer *v55;
  int v56;
  int v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  __CVBuffer *v66;
  __CVBuffer *v67;
  const void *v68;
  CFNumberRef v69;
  const void *v70;
  CFNumberRef v71;
  __CFDictionary *v72;
  const void *v73;
  CFNumberRef v74;
  const void *v75;
  CFNumberRef v76;
  const void *v77;
  CFNumberRef v78;
  const void *v79;
  CFNumberRef v80;
  const void *v81;
  CFNumberRef v82;
  const void *v83;
  CFNumberRef v84;
  const void *v85;
  CFNumberRef v86;
  __CFDictionary *v87;
  CFNumberRef v88;
  CFNumberRef v89;
  CFNumberRef v90;
  CFNumberRef v91;
  CFNumberRef v92;
  CFNumberRef v93;
  CFNumberRef v94;
  CFArrayRef v95;
  int v96;
  int v97;
  int v98;
  __CFDictionary *v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  __CVBuffer *v105;
  unint64_t v106;
  unint64_t v107;
  const void *v108;
  CFNumberRef v109;
  const void *v110;
  CFNumberRef v111;
  __CFDictionary *v112;
  const void *v113;
  CFNumberRef v114;
  const void *v115;
  CFNumberRef v116;
  const void *v117;
  CFNumberRef v118;
  const void *v119;
  CFNumberRef v120;
  const void *v121;
  CFNumberRef v122;
  const void *v123;
  CFNumberRef v124;
  const void *v125;
  CFNumberRef v126;
  __CFDictionary *v127;
  CFNumberRef v128;
  CFNumberRef v129;
  CFNumberRef v130;
  CFNumberRef v131;
  CFNumberRef v132;
  CFNumberRef v133;
  CFNumberRef v134;
  CFMutableDictionaryRef v135;
  CFNumberRef v136;
  CFNumberRef v137;
  CFNumberRef v138;
  CFNumberRef v139;
  CFNumberRef v140;
  CFNumberRef v141;
  CFNumberRef v142;
  CFArrayRef v143;
  int v144;
  int v145;
  int v146;
  int v147;
  const void *v148;
  CFNumberRef v149;
  int v150;
  int v151;
  char v152;
  int v153;
  CFTypeRef *v154;
  CFTypeRef *v155;
  int v157;
  int v158;
  unsigned __int16 v159;
  int v160;
  unsigned __int16 v161;
  void *v162;
  void *v163;
  void *key;
  int v165;
  void *v166;
  __CVBuffer *v167;
  __CVBuffer *v168;
  int v169;
  int v170;
  __CVBuffer *v171;
  __CVBuffer *v172;
  __CVBuffer *v173;
  __CVBuffer *v174;
  int v175;
  unsigned int v176;
  int v177;
  int v178;
  int v179;
  int v180;
  int v181;
  int v182;
  int v183;
  uint64_t v184;
  __CFDictionary *theDict;
  void *v186;
  __CVBuffer *v187;
  void *v188;
  int v189;
  __CVBuffer *height;
  CVPixelBufferRef pixelBufferOut;
  __int128 valuePtr;
  CFTypeRef cf[2];
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  int v199;
  uint64_t v200;

  v200 = *MEMORY[0x1E0C80C00];
  v12 = equivalent_uncompressed_format(a4);
  IOSurface = 0;
  if (a1 && a2 && (_DWORD)a4)
  {
    v14 = v12;
    v15 = min_bytes_per_row(v12, (uint64_t)a1);
    if ((((_DWORD)v14 - 1919365990) & 0xFFFFFFFD) == 0 || (v16 = is_biplanar(a4), v15) || v16)
    {
      v186 = a3;
      height = a2;
      v17 = v14;
      v189 = a6;
      if ((a4 & 0xFD000000) != 0x2D000000 && (int)a4 >> 24 != 38 && (int)a4 >> 24 != 124)
      {
        v25 = a5;
        v22 = (const void *)*MEMORY[0x1E0CBC1A0];
        v28 = a4;
        v24 = (const void *)*MEMORY[0x1E0CBBEE8];
LABEL_18:
        Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v30 = (const void *)*MEMORY[0x1E0CBC1E0];
        *(_QWORD *)&valuePtr = a1;
        v31 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
        CFDictionarySetValue(Mutable, v30, v31);
        CFRelease(v31);
        v32 = (const void *)*MEMORY[0x1E0CBC008];
        *(_QWORD *)&valuePtr = height;
        v33 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
        CFDictionarySetValue(Mutable, v32, v33);
        CFRelease(v33);
        v34 = (const void *)*MEMORY[0x1E0CBC070];
        LODWORD(valuePtr) = v28;
        v35 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
        CFDictionarySetValue(Mutable, v34, v35);
        CFRelease(v35);
        v36 = (const void *)*MEMORY[0x1E0CBBF10];
        LODWORD(valuePtr) = *(_DWORD *)v25;
        v37 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
        CFDictionarySetValue(Mutable, v36, v37);
        CFRelease(v37);
        *(_QWORD *)&valuePtr = *(_QWORD *)(v25 + 8);
        v38 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
        CFDictionarySetValue(Mutable, v22, v38);
        CFRelease(v38);
        v184 = v25;
        *(_QWORD *)&valuePtr = *(_QWORD *)(v25 + 16);
        v39 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
        theDict = Mutable;
        CFDictionarySetValue(Mutable, v24, v39);
        CFRelease(v39);
        v40 = v17;
        if (is_biplanar(v17))
        {
          v183 = v28;
          v41 = equivalent_uncompressed_format(v17);
          if (v41 <= 1936077875)
          {
            v42 = (unint64_t)height;
            if (v41 <= 1751528499)
            {
              v43 = (unint64_t)a1;
              if (v41 == 875836518)
                goto LABEL_51;
              v44 = 875836534;
            }
            else
            {
              v43 = (unint64_t)a1;
              if (v41 == 1751528500)
                goto LABEL_51;
              v43 = (unint64_t)a1;
              if (v41 == 1882469428)
                goto LABEL_51;
              v44 = 1885746228;
            }
          }
          else
          {
            v42 = (unint64_t)height;
            if (v41 > 1953903667)
            {
              v43 = (unint64_t)a1;
              if (v41 == 1953903668)
                goto LABEL_51;
              v43 = (unint64_t)a1;
              if (v41 == 2016687156)
                goto LABEL_51;
              v44 = 2019963956;
            }
            else
            {
              v43 = (unint64_t)a1;
              if (v41 == 1936077876)
                goto LABEL_51;
              v43 = (unint64_t)a1;
              if (v41 == 1937126452)
                goto LABEL_51;
              v44 = 1952855092;
            }
          }
          v43 = (unint64_t)a1;
          if (v41 != v44)
            v43 = ((unint64_t)a1 + 1) >> 1;
LABEL_51:
          if (v41 <= 1936077359)
          {
            if (v41 <= 1751527983)
            {
              if (v41 == 875704422)
                goto LABEL_66;
              v57 = 875704438;
            }
            else
            {
              if (v41 == 1751527984 || v41 == 1882468912)
                goto LABEL_66;
              v57 = 1885745712;
            }
          }
          else if (v41 > 1953903151)
          {
            if (v41 == 1953903152 || v41 == 2019963440)
              goto LABEL_66;
            v57 = 2016686640;
          }
          else
          {
            if (v41 == 1936077360 || v41 == 1937125936)
              goto LABEL_66;
            v57 = 1952854576;
          }
          v58 = v42;
          if (v41 != v57)
          {
LABEL_67:
            v59 = format_for_plane(v40, 0);
            v60 = format_for_plane(v40, 1);
            if (((equivalent_uncompressed_format(v59) - 1919365990) & 0xFFFFFFFD) == 0
              || (is_biplanar(v59) & 1) != 0)
            {
              v61 = 0;
              goto LABEL_70;
            }
            v61 = 2;
            if ((int)v59 > 846624120)
            {
              if ((_DWORD)v59 == 846624121 || (_DWORD)v59 == 2037741158)
                goto LABEL_70;
              v96 = 2037741171;
            }
            else
            {
              if ((_DWORD)v59 == 828584240 || (_DWORD)v59 == 845361456)
              {
                v61 = 3;
                goto LABEL_70;
              }
              v96 = 846624102;
            }
            if ((_DWORD)v59 != v96)
              v61 = 1;
LABEL_70:
            v179 = v61;
            v176 = v40;
            if (((equivalent_uncompressed_format(v60) - 1919365990) & 0xFFFFFFFD) == 0
              || (is_biplanar(v60) & 1) != 0)
            {
              v62 = 0;
LABEL_73:
              v181 = v62;
              v177 = bytes_per_element(v60);
              v169 = bytes_per_element(v59);
              v63 = min_bytes_per_row(v59, (uint64_t)a1);
              v64 = min_bytes_per_row(v60, v43);
              v65 = 32;
              if (v186)
                v65 = (unint64_t)v186;
              v171 = (__CVBuffer *)v43;
              v172 = (__CVBuffer *)v58;
              v66 = (__CVBuffer *)((v63 + v65 - 1) / v65 * v65);
              v187 = (__CVBuffer *)((v64 + v65 - 1) / v65 * v65);
              v67 = (__CVBuffer *)((_QWORD)v66 * v42);
              v174 = (__CVBuffer *)((_QWORD)v187 * v58);
              v68 = (const void *)*MEMORY[0x1E0CBBF08];
              *(_QWORD *)&valuePtr = ((_QWORD)v187 * v58 + (_QWORD)v66 * v42) / v42;
              v69 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
              CFDictionarySetValue(theDict, v68, v69);
              CFRelease(v69);
              v70 = (const void *)*MEMORY[0x1E0CBBEE0];
              *(_QWORD *)&valuePtr = (_QWORD)v187 * v58 + (_QWORD)v66 * v42;
              v71 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
              CFDictionarySetValue(theDict, v70, v71);
              CFRelease(v71);
              v72 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              *(_QWORD *)&valuePtr = v72;
              v73 = (const void *)*MEMORY[0x1E0CBC178];
              pixelBufferOut = a1;
              v74 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v72, v73, v74);
              CFRelease(v74);
              v75 = (const void *)*MEMORY[0x1E0CBC140];
              pixelBufferOut = (CVPixelBufferRef)v42;
              v76 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v72, v75, v76);
              CFRelease(v76);
              v77 = (const void *)*MEMORY[0x1E0CBC160];
              pixelBufferOut = 0;
              v78 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v72, v77, v78);
              CFRelease(v78);
              v79 = (const void *)*MEMORY[0x1E0CBC168];
              pixelBufferOut = v67;
              v80 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v72, v79, v80);
              CFRelease(v80);
              v81 = (const void *)*MEMORY[0x1E0CBC098];
              pixelBufferOut = v66;
              v82 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v72, v81, v82);
              CFRelease(v82);
              v83 = (const void *)*MEMORY[0x1E0CBC090];
              LODWORD(pixelBufferOut) = v169;
              v84 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
              CFDictionarySetValue(v72, v83, v84);
              CFRelease(v84);
              v85 = (const void *)*MEMORY[0x1E0CBC110];
              LODWORD(pixelBufferOut) = v179;
              v86 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
              CFDictionarySetValue(v72, v85, v86);
              CFRelease(v86);
              v87 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              *((_QWORD *)&valuePtr + 1) = v87;
              pixelBufferOut = v171;
              v88 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v87, v73, v88);
              CFRelease(v88);
              pixelBufferOut = v172;
              v89 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v87, v75, v89);
              CFRelease(v89);
              pixelBufferOut = v67;
              v90 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v87, v77, v90);
              CFRelease(v90);
              pixelBufferOut = v174;
              v91 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v87, v79, v91);
              CFRelease(v91);
              pixelBufferOut = v187;
              v92 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
              CFDictionarySetValue(v87, v81, v92);
              CFRelease(v92);
              LODWORD(pixelBufferOut) = v177;
              v93 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
              CFDictionarySetValue(v87, v83, v93);
              CFRelease(v93);
              LODWORD(pixelBufferOut) = v181;
              v94 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
              v49 = theDict;
              CFDictionarySetValue(v87, v85, v94);
              CFRelease(v94);
              v95 = CFArrayCreate(0, (const void **)&valuePtr, 2, MEMORY[0x1E0C9B378]);
              CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E0CBC158], v95);
              CFRelease(v95);
              CFRelease((CFTypeRef)valuePtr);
              CFRelease(*((CFTypeRef *)&valuePtr + 1));
              v45 = v183;
              v40 = v176;
              goto LABEL_119;
            }
            v62 = 2;
            if ((int)v60 > 846624120)
            {
              if ((_DWORD)v60 == 846624121 || (_DWORD)v60 == 2037741158)
                goto LABEL_73;
              v97 = 2037741171;
            }
            else
            {
              if ((_DWORD)v60 == 828584240 || (_DWORD)v60 == 845361456)
              {
                v62 = 3;
                goto LABEL_73;
              }
              v97 = 846624102;
            }
            if ((_DWORD)v60 != v97)
              v62 = 1;
            goto LABEL_73;
          }
LABEL_66:
          v58 = (v42 + 1) >> 1;
          goto LABEL_67;
        }
        v45 = v28;
        if (((equivalent_uncompressed_format(v28) - 1919365990) & 0xFFFFFFFD) != 0)
        {
          v46 = 32;
          if (v186)
            v46 = (unint64_t)v186;
          v47 = (const void *)*MEMORY[0x1E0CBBF08];
          *(_QWORD *)&valuePtr = (v46 + v15 - 1) / v46 * v46;
          v48 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
          v49 = theDict;
          CFDictionarySetValue(theDict, v47, v48);
          CFRelease(v48);
          if (((equivalent_uncompressed_format(v17) - 1919365990) & 0xFFFFFFFD) == 0)
            goto LABEL_118;
          v50 = 2;
          if ((int)v17 > 846624120)
          {
            if ((_DWORD)v17 != 846624121 && (_DWORD)v17 != 2037741158)
            {
              v51 = 2037741171;
LABEL_45:
              if ((_DWORD)v17 != v51)
                goto LABEL_118;
            }
          }
          else
          {
            if ((_DWORD)v17 != 828584240 && (_DWORD)v17 != 845361456)
            {
              v51 = 846624102;
              goto LABEL_45;
            }
            v50 = 3;
          }
          setIntValue(theDict, (const void *)*MEMORY[0x1E0CBBFC0], v50);
LABEL_118:
          v147 = bytes_per_element(v17);
          v148 = (const void *)*MEMORY[0x1E0CBBF00];
          LODWORD(valuePtr) = v147;
          v149 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
          CFDictionarySetValue(theDict, v148, v149);
          CFRelease(v149);
          goto LABEL_119;
        }
        v52 = format_for_plane(v17, 0);
        v53 = format_for_plane(v17, 1);
        v54 = format_for_plane(v17, 2);
        if (((equivalent_uncompressed_format(v52) - 1919365990) & 0xFFFFFFFD) == 0)
        {
          v56 = 0;
          v55 = height;
          goto LABEL_95;
        }
        v55 = height;
        if ((is_biplanar(v52) & 1) != 0)
        {
          v56 = 0;
          goto LABEL_95;
        }
        v56 = 2;
        if ((int)v52 > 846624120)
        {
          if ((_DWORD)v52 == 846624121 || (_DWORD)v52 == 2037741158)
            goto LABEL_95;
          v144 = 2037741171;
        }
        else
        {
          if ((_DWORD)v52 == 828584240 || (_DWORD)v52 == 845361456)
          {
            v56 = 3;
            goto LABEL_95;
          }
          v144 = 846624102;
        }
        if ((_DWORD)v52 != v144)
          v56 = 1;
LABEL_95:
        if (((equivalent_uncompressed_format(v53) - 1919365990) & 0xFFFFFFFD) == 0
          || (is_biplanar(v53) & 1) != 0)
        {
          v98 = 0;
          goto LABEL_98;
        }
        v98 = 2;
        if ((int)v53 > 846624120)
        {
          if ((_DWORD)v53 == 846624121 || (_DWORD)v53 == 2037741158)
            goto LABEL_98;
          v145 = 2037741171;
        }
        else
        {
          if ((_DWORD)v53 == 828584240 || (_DWORD)v53 == 845361456)
          {
            v98 = 3;
            goto LABEL_98;
          }
          v145 = 846624102;
        }
        if ((_DWORD)v53 != v145)
          v98 = 1;
LABEL_98:
        v182 = v98;
        v175 = v56;
        if (((equivalent_uncompressed_format(v54) - 1919365990) & 0xFFFFFFFD) == 0
          || (is_biplanar(v54) & 1) != 0)
        {
          v99 = theDict;
          v100 = 0;
          goto LABEL_101;
        }
        v100 = 2;
        if ((int)v54 > 846624120)
        {
          if ((_DWORD)v54 == 846624121)
          {
            v99 = theDict;
            goto LABEL_101;
          }
          v99 = theDict;
          if ((_DWORD)v54 == 2037741158)
          {
LABEL_101:
            v178 = v100;
            v180 = bytes_per_element(v54);
            v170 = bytes_per_element(v53);
            v165 = bytes_per_element(v52);
            v101 = min_bytes_per_row(v52, (uint64_t)a1);
            v102 = min_bytes_per_row(v53, (uint64_t)a1);
            v103 = min_bytes_per_row(v54, (uint64_t)a1);
            v104 = 32;
            if (v186)
              v104 = (unint64_t)v186;
            v105 = (__CVBuffer *)((v101 + v104 - 1) / v104 * v104);
            v106 = (v102 + v104 - 1) / v104 * v104;
            v173 = (__CVBuffer *)((v103 + v104 - 1) / v104 * v104);
            v167 = (__CVBuffer *)(v106 * (_QWORD)v55);
            v168 = (__CVBuffer *)v106;
            v107 = (_QWORD)v173 * (_QWORD)v55 + 2 * v106 * (_QWORD)v55;
            v108 = (const void *)*MEMORY[0x1E0CBBF08];
            *(_QWORD *)&valuePtr = v107 / (unint64_t)v55;
            v109 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
            CFDictionarySetValue(v99, v108, v109);
            CFRelease(v109);
            v110 = (const void *)*MEMORY[0x1E0CBBEE0];
            *(_QWORD *)&valuePtr = v107;
            v111 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
            CFDictionarySetValue(v99, v110, v111);
            CFRelease(v111);
            cf[0] = 0;
            v112 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            *(_QWORD *)&valuePtr = v112;
            v113 = (const void *)*MEMORY[0x1E0CBC178];
            pixelBufferOut = a1;
            v114 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v112, v113, v114);
            CFRelease(v114);
            v115 = (const void *)*MEMORY[0x1E0CBC140];
            key = (void *)*MEMORY[0x1E0CBC140];
            pixelBufferOut = v55;
            v116 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v112, v115, v116);
            CFRelease(v116);
            v117 = (const void *)*MEMORY[0x1E0CBC160];
            v163 = (void *)*MEMORY[0x1E0CBC160];
            pixelBufferOut = 0;
            v118 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v112, v117, v118);
            CFRelease(v118);
            v119 = (const void *)*MEMORY[0x1E0CBC168];
            v188 = (void *)*MEMORY[0x1E0CBC168];
            pixelBufferOut = (CVPixelBufferRef)((_QWORD)v105 * (_QWORD)v55);
            v120 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v112, v119, v120);
            CFRelease(v120);
            v121 = (const void *)*MEMORY[0x1E0CBC098];
            v162 = (void *)*MEMORY[0x1E0CBC098];
            pixelBufferOut = v105;
            v122 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v112, v121, v122);
            CFRelease(v122);
            v123 = (const void *)*MEMORY[0x1E0CBC090];
            LODWORD(pixelBufferOut) = v165;
            v124 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
            CFDictionarySetValue(v112, v123, v124);
            CFRelease(v124);
            v125 = (const void *)*MEMORY[0x1E0CBC110];
            v166 = (void *)*MEMORY[0x1E0CBC110];
            LODWORD(pixelBufferOut) = v175;
            v126 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
            CFDictionarySetValue(v112, v125, v126);
            CFRelease(v126);
            v127 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            *((_QWORD *)&valuePtr + 1) = v127;
            pixelBufferOut = a1;
            v128 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v127, v113, v128);
            CFRelease(v128);
            pixelBufferOut = v55;
            v129 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v127, key, v129);
            CFRelease(v129);
            pixelBufferOut = (CVPixelBufferRef)((_QWORD)v105 * (_QWORD)v55);
            v130 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v127, v163, v130);
            CFRelease(v130);
            pixelBufferOut = v167;
            v131 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v127, v188, v131);
            CFRelease(v131);
            pixelBufferOut = v168;
            v132 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v127, v162, v132);
            CFRelease(v132);
            LODWORD(pixelBufferOut) = v170;
            v133 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
            CFDictionarySetValue(v127, v123, v133);
            CFRelease(v133);
            LODWORD(pixelBufferOut) = v182;
            v134 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
            CFDictionarySetValue(v127, v166, v134);
            CFRelease(v134);
            v135 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            cf[0] = v135;
            pixelBufferOut = a1;
            v136 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v135, v113, v136);
            CFRelease(v136);
            pixelBufferOut = height;
            v137 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v135, key, v137);
            CFRelease(v137);
            pixelBufferOut = (__CVBuffer *)((char *)v167 + (_QWORD)v105 * (_QWORD)v55);
            v138 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v135, v163, v138);
            CFRelease(v138);
            pixelBufferOut = (CVPixelBufferRef)((_QWORD)v173 * (_QWORD)v55);
            v139 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v135, v188, v139);
            CFRelease(v139);
            pixelBufferOut = v173;
            v140 = CFNumberCreate(0, kCFNumberLongType, &pixelBufferOut);
            CFDictionarySetValue(v135, v162, v140);
            CFRelease(v140);
            LODWORD(pixelBufferOut) = v180;
            v141 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
            CFDictionarySetValue(v135, v123, v141);
            CFRelease(v141);
            LODWORD(pixelBufferOut) = v178;
            v142 = CFNumberCreate(0, kCFNumberIntType, &pixelBufferOut);
            v49 = theDict;
            CFDictionarySetValue(v135, v166, v142);
            CFRelease(v142);
            v143 = CFArrayCreate(0, (const void **)&valuePtr, 3, MEMORY[0x1E0C9B378]);
            CFDictionarySetValue(theDict, (const void *)*MEMORY[0x1E0CBC158], v143);
            CFRelease(v143);
            CFRelease((CFTypeRef)valuePtr);
            CFRelease(*((CFTypeRef *)&valuePtr + 1));
            CFRelease(cf[0]);
LABEL_119:
            IOSurface = IOSurfaceCreate(v49);
            nameSurface(*(_QWORD *)(v184 + 16), IOSurface);
            if (v189)
            {
              if ((v45 & 0xFD000000) == 0x2D000000 || v45 >> 24 == 124 || v45 >> 24 == 38)
                x_log("Error: a compressed surface cannot be cleared using ClearSurface().\n");
              else
                ClearSurface(IOSurface);
            }
            if ((int)v40 > 2037741157)
            {
              if ((_DWORD)v40 != 2037741158)
              {
                v150 = 2037741171;
LABEL_129:
                if ((_DWORD)v40 == v150)
                  goto LABEL_130;
                v157 = equivalent_uncompressed_format(v40);
                if (v157 > 1937126451)
                {
                  if (v157 <= 2016686639)
                  {
                    if (v157 > 1953903153)
                    {
                      if (v157 == 1953903154)
                        goto LABEL_184;
                      v159 = 13364;
                    }
                    else
                    {
                      if (v157 == 1937126452)
                        goto LABEL_184;
                      v159 = 12848;
                    }
                    v158 = v159 | 0x74760000;
                  }
                  else if (v157 <= 2016687155)
                  {
                    if (v157 == 2016686640)
                      goto LABEL_184;
                    v158 = 2016686642;
                  }
                  else
                  {
                    if (v157 == 2016687156 || v157 == 2037741171)
                      goto LABEL_184;
                    v158 = 2033463352;
                  }
                }
                else if (v157 <= 1882468911)
                {
                  if (v157 > 875704949)
                  {
                    if (v157 == 875704950)
                      goto LABEL_184;
                    v158 = 875836534;
                  }
                  else
                  {
                    if (v157 == 846624121)
                      goto LABEL_184;
                    v158 = 875704438;
                  }
                }
                else if (v157 <= 1882469427)
                {
                  if (v157 == 1882468912)
                    goto LABEL_184;
                  v158 = 1882468914;
                }
                else
                {
                  if (v157 == 1882469428 || v157 == 1937125936)
                    goto LABEL_184;
                  v158 = 1937125938;
                }
                if (v157 != v158)
                  goto LABEL_130;
LABEL_184:
                if (v157 > 1937126451)
                {
                  if (v157 <= 2016686639)
                  {
                    if (v157 > 1953903153)
                    {
                      if (v157 == 1953903154)
                        goto LABEL_211;
                      v161 = 13364;
                    }
                    else
                    {
                      if (v157 == 1937126452)
                        goto LABEL_211;
                      v161 = 12848;
                    }
                    v160 = v161 | 0x74760000;
                  }
                  else if (v157 <= 2016687155)
                  {
                    if (v157 == 2016686640)
                      goto LABEL_211;
                    v160 = 2016686642;
                  }
                  else
                  {
                    if (v157 == 2016687156 || v157 == 2037741171)
                      goto LABEL_211;
                    v160 = 2033463352;
                  }
                }
                else if (v157 <= 1882468911)
                {
                  if (v157 > 875704949)
                  {
                    if (v157 == 875704950)
                      goto LABEL_211;
                    v160 = 875836534;
                  }
                  else
                  {
                    if (v157 == 846624121)
                      goto LABEL_211;
                    v160 = 875704438;
                  }
                }
                else
                {
                  if (v157 > 1882469427)
                  {
                    if (v157 != 1882469428 && v157 != 1937125936)
                    {
                      v160 = 1937125938;
                      goto LABEL_210;
                    }
LABEL_211:
                    v153 = 0;
                    v151 = 1;
                    v152 = 1;
                    goto LABEL_131;
                  }
                  if (v157 == 1882468912)
                    goto LABEL_211;
                  v160 = 1882468914;
                }
LABEL_210:
                if (v157 != v160)
                {
LABEL_136:
                  v27 = v49;
LABEL_137:
                  CFRelease(v27);
                  return IOSurface;
                }
                goto LABEL_211;
              }
            }
            else if ((_DWORD)v40 != 846624102)
            {
              v150 = 846624121;
              goto LABEL_129;
            }
LABEL_130:
            v151 = 0;
            v152 = 6;
            v153 = 1;
LABEL_131:
            v199 = 0;
            v197 = 0u;
            v198 = 0u;
            v195 = 0u;
            v196 = 0u;
            *(_OWORD *)cf = 0u;
            v194 = 0u;
            valuePtr = 0u;
            BYTE10(v195) = v152;
            IOSurfaceSetBulkAttachments2();
            v154 = (CFTypeRef *)MEMORY[0x1E0CBC1F8];
            v155 = (CFTypeRef *)MEMORY[0x1E0CBC200];
            if (!v151)
              v155 = (CFTypeRef *)MEMORY[0x1E0CBC1F0];
            if (!v153)
              v154 = v155;
            IOSurfaceSetValue(IOSurface, (CFStringRef)*MEMORY[0x1E0CBC1E8], *v154);
            goto LABEL_136;
          }
          v146 = 2037741171;
        }
        else
        {
          v99 = theDict;
          if ((_DWORD)v54 == 828584240 || (_DWORD)v54 == 845361456)
          {
            v100 = 3;
            goto LABEL_101;
          }
          v146 = 846624102;
        }
        if ((_DWORD)v54 != v146)
          v100 = 1;
        goto LABEL_101;
      }
      pixelBufferOut = 0;
      v18 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
      v19 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
      v20 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v21 = CFDictionaryCreateMutable(0, 0, v18, v19);
      v22 = (const void *)*MEMORY[0x1E0CBC1A0];
      *(_QWORD *)&valuePtr = *(_QWORD *)(a5 + 8);
      v23 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
      CFDictionarySetValue(v21, v22, v23);
      CFRelease(v23);
      v24 = (const void *)*MEMORY[0x1E0CBBEE8];
      v25 = a5;
      *(_QWORD *)&valuePtr = *(_QWORD *)(a5 + 16);
      v26 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
      CFDictionarySetValue(v21, v24, v26);
      CFRelease(v26);
      CFDictionarySetValue(v20, (const void *)*MEMORY[0x1E0CA8FF0], v21);
      CFDictionarySetValue(v20, CFSTR("IOSurfacePurgeable"), (const void *)*MEMORY[0x1E0C9AE50]);
      CVPixelBufferCreate(0, (size_t)a1, (size_t)height, a4, v20, &pixelBufferOut);
      CFRelease(v21);
      CFRelease(v20);
      if (pixelBufferOut)
      {
        IOSurface = CVPixelBufferGetIOSurface(pixelBufferOut);
        if (IOSurface)
        {
          nameSurface(*(_QWORD *)(v25 + 16), IOSurface);
          CFRetain(IOSurface);
        }
        v27 = pixelBufferOut;
        goto LABEL_137;
      }
      if ((_DWORD)v17)
      {
        v28 = v17;
        goto LABEL_18;
      }
    }
    return 0;
  }
  return IOSurface;
}

uint64_t is_biplanar(uint64_t a1)
{
  uint64_t v1;
  int v2;
  uint64_t result;
  int v4;
  unsigned __int16 v5;
  unsigned __int16 v6;
  unsigned __int16 v7;
  unsigned __int16 v8;
  unsigned __int16 v9;

  v1 = equivalent_uncompressed_format(a1);
  v2 = equivalent_uncompressed_format(v1);
  result = 1;
  if (v2 <= 1936077361)
  {
    if (v2 <= 1751528499)
    {
      if (v2 > 875836517)
      {
        if (v2 > 1751527983)
        {
          if (v2 == 1751527984)
            return result;
          v4 = 1751527986;
        }
        else
        {
          if (v2 == 875836518)
            return result;
          v4 = 875836534;
        }
      }
      else
      {
        if (v2 > 875704933)
        {
          if (v2 == 875704934)
            return result;
          v5 = 12918;
        }
        else
        {
          if (v2 == 875704422)
            return result;
          v5 = 12406;
        }
        v4 = v5 | 0x34320000;
      }
      goto LABEL_54;
    }
    if (v2 <= 1885745711)
    {
      if (v2 > 1882468913)
      {
        if (v2 == 1882468914)
          return result;
        v6 = 13364;
      }
      else
      {
        if (v2 == 1751528500)
          return result;
        v6 = 12848;
      }
      v4 = v6 | 0x70340000;
      goto LABEL_54;
    }
    if (v2 <= 1885746227)
    {
      if (v2 == 1885745712)
        return result;
      v4 = 1885745714;
      goto LABEL_54;
    }
    if (v2 == 1885746228)
      return result;
    v7 = 12848;
    goto LABEL_50;
  }
  if (v2 <= 1953903151)
  {
    if (v2 > 1937126451)
    {
      if (v2 > 1952854577)
      {
        if (v2 == 1952854578)
          return result;
        v8 = 13364;
      }
      else
      {
        if (v2 == 1937126452)
          return result;
        v8 = 12848;
      }
      v4 = v8 | 0x74660000;
      goto LABEL_54;
    }
    if (v2 > 1937125935)
    {
      if (v2 == 1937125936)
        return result;
      v4 = 1937125938;
      goto LABEL_54;
    }
    if (v2 == 1936077362)
      return result;
    v7 = 13364;
LABEL_50:
    v4 = v7 | 0x73660000;
LABEL_54:
    if (v2 != v4)
      return 0;
    return result;
  }
  if (v2 <= 2016686641)
  {
    if (v2 <= 1953903667)
    {
      if (v2 == 1953903152)
        return result;
      v4 = 1953903154;
      goto LABEL_54;
    }
    if (v2 == 1953903668)
      return result;
    v9 = 12848;
    goto LABEL_37;
  }
  if (v2 <= 2019963439)
  {
    if (v2 == 2016686642)
      return result;
    v9 = 13364;
LABEL_37:
    v4 = v9 | 0x78340000;
    goto LABEL_54;
  }
  if (v2 != 2019963440 && v2 != 2019963442)
  {
    v4 = 2019963956;
    goto LABEL_54;
  }
  return result;
}

__IOSurface *nameSurface(uint64_t a1, __IOSurface *a2)
{
  const __CFString *v4;

  if (CI_NAME_SURFACES())
  {
    if (a1)
      v4 = CFSTR("CoreImagePool");
    else
      v4 = CFSTR("CoreImage");
    IOSurfaceSetValue(a2, (CFStringRef)*MEMORY[0x1E0CBC048], v4);
  }
  return a2;
}

uint64_t min_bytes_per_row(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned __int16 v12;

  if (((equivalent_uncompressed_format(a1) - 1919365990) & 0xFFFFFFFD) == 0 || (is_biplanar(a1) & 1) != 0)
    return 0;
  v5 = 0;
  v6 = 1;
  if ((int)a1 > 1279340599)
  {
    if ((int)a1 > 1667844407)
    {
      if ((int)a1 > 1815162993)
      {
        if ((int)a1 > 1999908960)
        {
          if ((int)a1 > 2037741157)
          {
            if ((_DWORD)a1 == 2037741158)
              goto LABEL_92;
            v10 = 2037741171;
            goto LABEL_91;
          }
          if ((_DWORD)a1 != 1999908961)
          {
            v9 = 2033463352;
            goto LABEL_75;
          }
        }
        else
        {
          if ((int)a1 <= 1815491697)
          {
            if ((_DWORD)a1 == 1815162994)
              goto LABEL_76;
            v8 = 1815361650;
            goto LABEL_45;
          }
          if ((_DWORD)a1 != 1815491698)
          {
            v9 = 1999843442;
LABEL_75:
            if ((_DWORD)a1 != v9)
              return v5 * a2;
            goto LABEL_76;
          }
        }
        goto LABEL_88;
      }
      if ((int)a1 > 1717855599)
      {
        if ((int)a1 <= 1751410031)
        {
          if ((_DWORD)a1 == 1717855600)
            goto LABEL_76;
          v9 = 1717856627;
          goto LABEL_75;
        }
        if ((_DWORD)a1 == 1751410032)
          goto LABEL_92;
        v10 = 1751411059;
        goto LABEL_91;
      }
      if ((_DWORD)a1 == 1667844408)
        goto LABEL_93;
      if ((_DWORD)a1 == 1667844454)
        goto LABEL_76;
      v12 = 18792;
LABEL_87:
      v10 = v12 | 0x63690000;
      goto LABEL_91;
    }
    if ((int)a1 > 1664496753)
    {
      if ((int)a1 <= 1667838821)
      {
        if ((_DWORD)a1 != 1664496754)
        {
          if ((_DWORD)a1 == 1667838256)
            goto LABEL_76;
          v9 = 1667838768;
          goto LABEL_75;
        }
        goto LABEL_88;
      }
      if ((int)a1 <= 1667839023)
      {
        if ((_DWORD)a1 == 1667838822)
        {
          v6 = 12;
          goto LABEL_93;
        }
        v8 = 1667838824;
LABEL_45:
        if ((_DWORD)a1 != v8)
          return v5 * a2;
        v6 = 6;
        goto LABEL_93;
      }
      if ((_DWORD)a1 != 1667839024)
      {
        v12 = 18742;
        goto LABEL_87;
      }
    }
    else
    {
      if ((int)a1 > 1279340853)
      {
        if ((int)a1 <= 1380410944)
        {
          if ((_DWORD)a1 == 1279340854)
            goto LABEL_76;
          v9 = 1380401729;
          goto LABEL_75;
        }
        if ((_DWORD)a1 == 1380410945)
        {
          v6 = 16;
          goto LABEL_93;
        }
        v11 = 1380411457;
        goto LABEL_79;
      }
      if ((_DWORD)a1 == 1279340600)
        goto LABEL_92;
      if ((_DWORD)a1 != 1279340646)
      {
        v9 = 1279340648;
        goto LABEL_75;
      }
    }
LABEL_88:
    v6 = 8;
    goto LABEL_93;
  }
  if ((int)a1 > 845361455)
  {
    if ((int)a1 > 1094862673)
    {
      if ((int)a1 <= 1278226533)
      {
        if ((_DWORD)a1 != 1094862674 && (_DWORD)a1 != 1111970369)
        {
          v7 = 1278226488;
LABEL_22:
          if ((_DWORD)a1 != v7)
            return v5 * a2;
          goto LABEL_93;
        }
        goto LABEL_76;
      }
      if ((a1 - 1278226736) <= 6 && ((1 << (a1 - 48)) & 0x45) != 0)
        goto LABEL_92;
      if ((_DWORD)a1 == 1278226534)
      {
LABEL_76:
        v6 = 4;
        goto LABEL_93;
      }
      v10 = 1278226536;
      goto LABEL_91;
    }
    if ((int)a1 <= 1093677111)
    {
      if ((_DWORD)a1 == 845361456)
      {
        a2 *= 2;
        return (2 * (((unint64_t)(a2 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
      }
      if ((_DWORD)a1 == 846624102)
        goto LABEL_92;
      v10 = 846624121;
    }
    else
    {
      if ((int)a1 <= 1093677159)
      {
        if ((_DWORD)a1 != 1093677112)
        {
          v9 = 1093677158;
          goto LABEL_75;
        }
LABEL_93:
        v5 = v6;
        return v5 * a2;
      }
      if ((_DWORD)a1 == 1093677160)
        goto LABEL_92;
      v10 = 1093677366;
    }
LABEL_91:
    if ((_DWORD)a1 == v10)
      goto LABEL_92;
    return v5 * a2;
  }
  if ((int)a1 <= 828584239)
  {
    if ((int)a1 <= 826486885)
    {
      if ((_DWORD)a1 == 24)
      {
        v6 = 3;
        goto LABEL_93;
      }
      if ((_DWORD)a1 != 32)
      {
        v7 = 826486840;
        goto LABEL_22;
      }
      goto LABEL_76;
    }
    if ((a1 - 826487088) > 6 || ((1 << (a1 - 48)) & 0x45) == 0)
    {
      if ((_DWORD)a1 != 826486886)
      {
        v10 = 826486888;
        goto LABEL_91;
      }
      goto LABEL_76;
    }
LABEL_92:
    v6 = 2;
    goto LABEL_93;
  }
  if ((int)a1 > 843264103)
  {
    if ((a1 - 843264304) <= 6 && ((1 << (a1 - 48)) & 0x45) != 0)
      goto LABEL_76;
    v9 = 843264104;
    goto LABEL_75;
  }
  if ((_DWORD)a1 != 828584240)
  {
    if ((_DWORD)a1 == 843264056)
      goto LABEL_92;
    v11 = 843264102;
LABEL_79:
    if ((_DWORD)a1 != v11)
      return v5 * a2;
    goto LABEL_88;
  }
  return (2 * (((unint64_t)(a2 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
}

uint64_t bytes_per_element(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned __int16 v9;

  if (((equivalent_uncompressed_format(a1) - 1919365990) & 0xFFFFFFFD) == 0 || (is_biplanar(a1) & 1) != 0)
    return 0;
  result = 0;
  v3 = 1;
  if ((int)a1 > 1279340599)
  {
    if ((int)a1 > 1667844407)
    {
      if ((int)a1 > 1815162993)
      {
        if ((int)a1 > 1999908960)
        {
          if ((int)a1 > 2037741157)
          {
            if ((_DWORD)a1 == 2037741158)
              return 4;
            v7 = 2037741171;
            goto LABEL_94;
          }
          if ((_DWORD)a1 != 1999908961)
          {
            v7 = 2033463352;
            goto LABEL_94;
          }
          return 8;
        }
        if ((int)a1 > 1815491697)
        {
          if ((_DWORD)a1 != 1815491698)
          {
            v7 = 1999843442;
            goto LABEL_94;
          }
          return 8;
        }
        if ((_DWORD)a1 == 1815162994)
          return 4;
        v6 = 1815361650;
LABEL_52:
        if ((_DWORD)a1 != v6)
          return result;
        return 6;
      }
      if ((int)a1 > 1717855599)
      {
        if ((int)a1 > 1751410031)
        {
          if ((_DWORD)a1 == 1751410032)
            return 2;
          v8 = 1751411059;
          goto LABEL_89;
        }
        if ((_DWORD)a1 == 1717855600)
          return 4;
        v7 = 1717856627;
LABEL_94:
        if ((_DWORD)a1 != v7)
          return result;
        return 4;
      }
      if ((_DWORD)a1 == 1667844408)
        return v3;
      if ((_DWORD)a1 == 1667844454)
        return 4;
      v9 = 18792;
    }
    else
    {
      if ((int)a1 <= 1380411456)
      {
        if ((int)a1 > 1279340853)
        {
          if ((int)a1 > 1380401728)
          {
            if ((_DWORD)a1 != 1380401729)
            {
              if ((_DWORD)a1 != 1380410945)
                return result;
              return 16;
            }
          }
          else if ((_DWORD)a1 != 1279340854)
          {
            v8 = 1279342648;
            goto LABEL_89;
          }
          return 4;
        }
        if ((_DWORD)a1 == 1279340600)
          return 2;
        if ((_DWORD)a1 != 1279340646)
        {
          v7 = 1279340648;
          goto LABEL_94;
        }
        return 8;
      }
      if ((int)a1 <= 1667838821)
      {
        if ((int)a1 > 1667838255)
        {
          if ((_DWORD)a1 == 1667838256)
            return 4;
          v7 = 1667838768;
          goto LABEL_94;
        }
        if ((_DWORD)a1 != 1380411457)
        {
          v5 = 1664496754;
          goto LABEL_64;
        }
        return 8;
      }
      if ((int)a1 <= 1667839023)
      {
        if ((_DWORD)a1 == 1667838822)
          return 12;
        v6 = 1667838824;
        goto LABEL_52;
      }
      if ((_DWORD)a1 == 1667839024)
        return 8;
      v9 = 18742;
    }
    v8 = v9 | 0x63690000;
    goto LABEL_89;
  }
  if ((int)a1 <= 845361455)
  {
    if ((int)a1 <= 828584239)
    {
      if ((int)a1 <= 826486885)
      {
        if ((_DWORD)a1 == 24)
          return 3;
        if ((_DWORD)a1 != 32)
        {
          v4 = 826486840;
          goto LABEL_22;
        }
        return 4;
      }
      if ((a1 - 826487088) <= 6 && ((1 << (a1 - 48)) & 0x45) != 0)
        return 2;
      if ((_DWORD)a1 != 826486886)
      {
        v8 = 826486888;
        goto LABEL_89;
      }
      return 4;
    }
    if ((int)a1 > 843264103)
    {
      if ((a1 - 843264304) <= 6 && ((1 << (a1 - 48)) & 0x45) != 0)
        return 4;
      v7 = 843264104;
      goto LABEL_94;
    }
    if ((_DWORD)a1 == 828584240)
      return 4;
    if ((_DWORD)a1 != 843264056)
    {
      v5 = 843264102;
LABEL_64:
      if ((_DWORD)a1 != v5)
        return result;
      return 8;
    }
    return 2;
  }
  if ((int)a1 > 1094862673)
  {
    if ((int)a1 <= 1278226533)
    {
      if ((_DWORD)a1 != 1094862674 && (_DWORD)a1 != 1111970369)
      {
        v4 = 1278226488;
LABEL_22:
        if ((_DWORD)a1 != v4)
          return result;
        return v3;
      }
      return 4;
    }
    if ((a1 - 1278226736) <= 6 && ((1 << (a1 - 48)) & 0x45) != 0)
      return 2;
    if ((_DWORD)a1 == 1278226534)
      return 4;
    v8 = 1278226536;
LABEL_89:
    if ((_DWORD)a1 != v8)
      return result;
    return 2;
  }
  if ((int)a1 <= 1093677111)
  {
    if ((_DWORD)a1 != 845361456)
    {
      if ((_DWORD)a1 == 846624102)
        return 4;
      v7 = 846624121;
      goto LABEL_94;
    }
    return 8;
  }
  if ((int)a1 > 1093677159)
  {
    if ((_DWORD)a1 == 1093677160)
      return 2;
    v8 = 1093677366;
    goto LABEL_89;
  }
  if ((_DWORD)a1 != 1093677112)
  {
    v7 = 1093677158;
    goto LABEL_94;
  }
  return v3;
}

uint64_t CI_NAME_SURFACES()
{
  unsigned __int8 v0;

  {
    CI_NAME_SURFACES::v = get_BOOL("CI_NAME_SURFACES", 1);
  }
  return CI_NAME_SURFACES::v;
}

void sub_1921F7458(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t fosl_filter_kernelpool_preservesAlpha(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t))(foslFuncs + 136))(a1);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_isPositionInvariant(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t))(foslFuncs + 128))(a1);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_getPrintedKernel(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t))(foslFuncs + 112))(a1);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_getParamType(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t, uint64_t))(foslFuncs + 160))(a1, a2);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_getParamName(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t, uint64_t))(foslFuncs + 152))(a1, a2);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_getNumKernels(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t))(foslFuncs + 48))(a1);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_getNumKernelParameters(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t))(foslFuncs + 144))(a1);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_getNumKernelAttributes(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t))(foslFuncs + 168))(a1);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_getNumDiagnostics(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t))(foslFuncs + 72))(a1);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_getKernelReturnType(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t))(foslFuncs + 96))(a1);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_getKernelName(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t))(foslFuncs + 104))(a1);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_getKernelKind(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t))(foslFuncs + 88))(a1);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_getKernelByIdx(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t, uint64_t))(foslFuncs + 64))(a1, a2);
  else
    return 0;
}

void fosl_filter_kernelpool_destroyPool(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t))(foslFuncs + 40))(a1);
}

uint64_t fosl_filter_kernelpool_createPool()
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(void))(foslFuncs + 8))();
  else
    return 0;
}

void fosl_filter_kernelpool_addString(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t, uint64_t))(foslFuncs + 32))(a1, a2);
}

void fosl_filter_kernelpool_addLibrary(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t, uint64_t))(foslFuncs + 24))(a1, a2);
}

uint64_t ci_signpost_log_render()
{
  if (ci_signpost_log_render_onceToken != -1)
    dispatch_once(&ci_signpost_log_render_onceToken, &__block_literal_global_72);
  return ci_signpost_log_render_log;
}

uint64_t ci_signpost_log_kernel()
{
  if (ci_signpost_log_kernel_onceToken != -1)
    dispatch_once(&ci_signpost_log_kernel_onceToken, &__block_literal_global_16_0);
  return ci_signpost_log_kernel_log;
}

os_log_t __ci_signpost_log_render_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "signpost_render");
  ci_signpost_log_render_log = (uint64_t)result;
  return result;
}

os_log_t __ci_signpost_log_kernel_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "signpost_kernel");
  ci_signpost_log_kernel_log = (uint64_t)result;
  return result;
}

uint64_t ___ZN2CI7Context23render_completion_queueEv_block_invoke()
{
  NSObject *v0;
  uint64_t result;

  v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  CI::Context::render_completion_queue(void)::sRenderCompletionQueue = (uint64_t)dispatch_queue_create("CI::RenderCompletionQueue", v0);
  if ((CI_PRINT_TREE_dump_intermediates() & 1) != 0)
    return atexit_b(&__block_literal_global_4_3);
  result = CI_PRINT_TREE_dump_outputs();
  if ((_DWORD)result)
    return atexit_b(&__block_literal_global_4_3);
  return result;
}

void ___ZN2CI19MetalTextureManager19purge_intermediatesEm_block_invoke(uint64_t a1)
{
  CI::TextureManager *v2;
  NSObject *v3;
  uint64_t v4;
  _QWORD v5[6];

  v2 = *(CI::TextureManager **)(a1 + 32);
  if (CI_RECYCLE_METAL_TEXTURES() && CI_IOSURFACE_INTERMEDIATES())
  {
    v3 = *((_QWORD *)v2 + 13);
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = ___ZN2CI19MetalTextureManager19purge_intermediatesEm_block_invoke_2;
    v5[3] = &__block_descriptor_48_e5_v8__0l;
    v4 = *(_QWORD *)(a1 + 40);
    v5[4] = v2;
    v5[5] = v4;
    dispatch_sync(v3, v5);
  }
  CI::TextureManager::purge_intermediates(v2);
}

uint64_t ___ZN2CI14TextureManager19purge_intermediatesEm_block_invoke(uint64_t result)
{
  uint64_t v1;
  uint64_t i;

  v1 = *(_QWORD *)(*(_QWORD *)(result + 32) + 136);
  for (i = *(_QWORD *)(v1 + 8); i != v1; i = *(_QWORD *)(i + 8))
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(i + 16) + 16))(*(_QWORD *)(i + 16));
  return result;
}

void ___ZN2CI14TextureManager10remove_allEv_block_invoke(uint64_t a1)
{
  CI::TextureManager *i;

  for (i = *(CI::TextureManager **)(a1 + 32);
        *((_QWORD *)i + 6);
}

void ___ZN2CI13KernelArchiveD2Ev_block_invoke(uint64_t a1)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v4;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(void ***)(v1 + 56);
  v3 = *(void ***)(v1 + 64);
  while (v2 != v3)
  {
    v4 = *v2++;

  }
  *(_QWORD *)(v1 + 16) = *(_QWORD *)(v1 + 8);
  *(_QWORD *)(v1 + 40) = *(_QWORD *)(v1 + 32);

}

void ___ZN13foslFunctions24initializeWrapperLibraryEv_block_invoke()
{
  foslFunctions *v0;
  uint64_t v1;

  v0 = (foslFunctions *)operator new();
  foslFunctions::foslFunctions(v0);
  foslFuncs = v1;
}

void ___ZL8GetQueuev_block_invoke()
{
  NSObject *v0;
  NSObject *global_queue;

  v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  gSurfaceCacheQueue = (uint64_t)dispatch_queue_create("CI::SurfaceCacheQueue", v0);
  global_queue = dispatch_get_global_queue(2, 0);
  gMemoryPressure = (uint64_t)dispatch_source_create(MEMORY[0x1E0C80DA8], 0, 6uLL, global_queue);
  dispatch_source_set_event_handler((dispatch_source_t)gMemoryPressure, &__block_literal_global_70_2);
  dispatch_resume((dispatch_object_t)gMemoryPressure);
}

void foslFunctions::foslFunctions(void)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  v2 = ci_signpost_log_render();
  v3 = *((_QWORD *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "foslFunctions", (const char *)&unk_192520C83, v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void std::vector<std::string>::reserve(std::vector<std::string> *this, std::vector<std::string>::size_type __n)
{
  std::__compressed_pair<std::string *> *p_end_cap;
  std::string *value;
  int64_t v5;
  char *v6;
  uint64_t v7;
  std::string *end;
  std::vector<std::string>::pointer begin;
  std::string *v10;
  __int128 v11;
  int64x2_t v12;
  std::string *v13;
  std::__split_buffer<std::string> v14;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)this->__begin_) >> 3) < __n)
  {
    if (__n >= 0xAAAAAAAAAAAAAABLL)
      abort();
    v5 = this->__end_ - this->__begin_;
    v14.__end_cap_.__value_ = (std::allocator<std::string> *)p_end_cap;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>((uint64_t)p_end_cap, __n);
    begin = this->__begin_;
    end = this->__end_;
    if (end == this->__begin_)
    {
      v12 = vdupq_n_s64((unint64_t)end);
      v10 = (std::string *)&v6[24 * v5];
    }
    else
    {
      v10 = (std::string *)&v6[24 * v5];
      do
      {
        v11 = *(_OWORD *)&end[-1].__r_.__value_.__l.__data_;
        v10[-1].__r_.__value_.__r.__words[2] = end[-1].__r_.__value_.__r.__words[2];
        *(_OWORD *)&v10[-1].__r_.__value_.__l.__data_ = v11;
        --v10;
        end[-1].__r_.__value_.__l.__size_ = 0;
        end[-1].__r_.__value_.__r.__words[2] = 0;
        end[-1].__r_.__value_.__r.__words[0] = 0;
        --end;
      }
      while (end != begin);
      v12 = *(int64x2_t *)&this->__begin_;
    }
    this->__begin_ = v10;
    this->__end_ = (std::vector<std::string>::pointer)&v6[24 * v5];
    *(int64x2_t *)&v14.__begin_ = v12;
    v13 = this->__end_cap_.__value_;
    this->__end_cap_.__value_ = (std::string *)&v6[24 * v7];
    v14.__end_cap_.__value_ = v13;
    v14.__first_ = (std::__split_buffer<std::string>::pointer)v12.i64[0];
    std::__split_buffer<std::string>::~__split_buffer(&v14);
  }
}

void std::vector<std::string>::__vdeallocate(std::vector<std::string> *this)
{
  if (this->__begin_)
  {
    std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)this);
    operator delete(this->__begin_);
    this->__begin_ = 0;
    this->__end_ = 0;
    this->__end_cap_.__value_ = 0;
  }
}

_QWORD *std::vector<CI::KernelArgumentType>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  int64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    std::vector<CI::KernelArgumentType>::__vallocate[abi:nn180100](a1, v5 >> 2);
    v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

void std::vector<CI::KernelArgumentType>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  int v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 2)
  {
    if (a2 >> 62)
      abort();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = &v6[4 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v12 - 1) = v13;
        v12 -= 4;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

_QWORD *std::vector<CGRect>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  int64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    std::vector<CGRect>::__vallocate[abi:nn180100](a1, v5 >> 5);
    v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

void std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::__map_value_compare<CI::Node const*,std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::less<CI::Node const*>,true>,std::allocator<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::__map_value_compare<CI::Node const*,std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::less<CI::Node const*>,true>,std::allocator<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::__map_value_compare<CI::Node const*,std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::less<CI::Node const*>,true>,std::allocator<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>>>::destroy(a1, a2[1]);
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(a2 + 5), (_QWORD *)a2[6]);
    operator delete(a2);
  }
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::__destruct_at_end[abi:nn180100]((uint64_t)this, (void **)&this->__begin_->__r_.__value_.__l.__data_);
  if (this->__first_)
    operator delete(this->__first_);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      abort();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

_QWORD *std::__list_imp<CI::attached_surface_t *>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;

  if (result[2])
  {
    v1 = result;
    result = (_QWORD *)result[1];
    v2 = *v1;
    v3 = *result;
    *(_QWORD *)(v3 + 8) = *(_QWORD *)(*v1 + 8);
    **(_QWORD **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        v4 = (_QWORD *)result[1];
        operator delete(result);
        result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

int64x2_t Rectangle::inset@<Q0>(Rectangle *this@<X0>, double a2@<D0>, double a3@<D1>, uint64_t a4@<X8>)
{
  double var0;
  double var1;
  BOOL v6;
  int64x2_t result;
  double var2;
  double v9;
  double var3;
  double v11;

  var0 = this->var0;
  if (fabs(this->var0) == INFINITY)
    goto LABEL_14;
  var1 = this->var1;
  if (fabs(var1) == INFINITY)
    goto LABEL_14;
  v6 = var0 == -8.98846567e307 && var1 == -8.98846567e307;
  if (v6 && this->var2 == 1.79769313e308 && this->var3 == 1.79769313e308)
  {
    result = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)a4 = result;
    *(int64x2_t *)(a4 + 16) = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    return result;
  }
  var2 = this->var2;
  v9 = fabs(var2) + a2 * -2.0;
  if (v9 < 0.0 || (var3 = this->var3, v11 = fabs(var3) + a3 * -2.0, v11 < 0.0))
  {
LABEL_14:
    result = vdupq_n_s64(0x7FF0000000000000uLL);
    *(int64x2_t *)a4 = result;
    *(_QWORD *)(a4 + 16) = 0;
    *(_QWORD *)(a4 + 24) = 0;
  }
  else
  {
    *(double *)result.i64 = fmin(var0, var0 + var2) + a2;
    *(_QWORD *)a4 = result.i64[0];
    *(double *)(a4 + 8) = fmin(var1, var3 + var1) + a3;
    *(double *)(a4 + 16) = v9;
    *(double *)(a4 + 24) = v11;
  }
  return result;
}

float64x2_t Rectangle::integralize@<Q0>(Rectangle *this@<X0>, double a2@<D0>, uint64_t a3@<X8>)
{
  double var1;
  float64x2_t result;
  BOOL v6;
  float64x2_t v7;
  float64x2_t v8[2];

  if (fabs(this->var0) == INFINITY || (var1 = this->var1, fabs(var1) == INFINITY))
  {
    result = (float64x2_t)vdupq_n_s64(0x7FF0000000000000uLL);
    *(float64x2_t *)a3 = result;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)(a3 + 24) = 0;
  }
  else
  {
    v6 = this->var0 == -8.98846567e307 && var1 == -8.98846567e307;
    if (v6 && this->var2 == 1.79769313e308 && this->var3 == 1.79769313e308)
    {
      result = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
      *(float64x2_t *)a3 = result;
      *(int64x2_t *)(a3 + 16) = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    }
    else
    {
      Rectangle::inset(this, a2, a2, (uint64_t)v8);
      v7 = vrndmq_f64(v8[0]);
      result = vsubq_f64(vrndpq_f64(vaddq_f64(v8[0], v8[1])), v7);
      *(float64x2_t *)a3 = v7;
      *(float64x2_t *)(a3 + 16) = result;
    }
  }
  return result;
}

double CI::CropImage::extent(CI::CropImage *this)
{
  double result;
  CGRect v3;

  v3.origin.x = (*(double (**)(_QWORD))(**((_QWORD **)this + 13) + 88))(*((_QWORD *)this + 13));
  *(_QWORD *)&result = (unint64_t)CGRectIntersection(v3, *(CGRect *)((char *)this + 120));
  return result;
}

uint64_t CI::Vector::type(CI::Vector *this)
{
  return 58;
}

uint64_t CI::Kernel::add_to_digest(CI::Kernel *this, CI::XXHashHelper *a2)
{
  char *v3;

  v3 = (char *)*((_QWORD *)this + 4);
  if (!v3)
  {
    v3 = (char *)*((_QWORD *)this + 5);
    if (!v3)
      v3 = (char *)*((_QWORD *)this + 3);
  }
  return CI::XXHashHelper::addstr((uint64_t)a2, v3);
}

double CI::Affine::applyToRect(CI::Affine *this, CGRect a2)
{
  double height;
  double width;
  double y;
  double x;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  uint64_t v14;
  double v15;
  float v16;
  double v17;
  double v18;
  float v19;
  BOOL v20;
  BOOL v21;
  double v22;
  float v23;
  unint64_t v24;
  float v25;
  float v26;
  unint64_t v27;
  float v28;
  float v29;
  unint64_t v30;
  uint64_t v32;
  uint64_t v33;
  CGRect v34;

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  if (!CGRectIsNull(a2))
  {
    v34.origin.x = x;
    v34.origin.y = y;
    v34.size.width = width;
    v34.size.height = height;
    if (!CGRectIsInfinite(v34) && !CI::Affine::isIdentity(this))
    {
      v7 = *((double *)this + 2);
      v8 = *((double *)this + 3);
      v9 = y * v7;
      v11 = *(double *)this;
      v10 = *((double *)this + 1);
      v13 = *((double *)this + 4);
      v12 = *((double *)this + 5);
      *(float *)&v14 = v13 + y * v7 + *(double *)this * x;
      v15 = y * v8;
      v16 = v12 + y * v8 + v10 * x;
      v17 = x + width;
      v18 = (y + height) * v7;
      v19 = v13 + v18 + *(double *)this * (x + width);
      v20 = v19 < *(float *)&v14;
      v21 = v19 <= *(float *)&v14;
      *((float *)&v14 + 1) = v16;
      v32 = v14;
      v33 = v14;
      v22 = (y + height) * v8;
      v23 = v12 + v22 + v10 * (x + width);
      if (v20)
      {
        *(float *)&v33 = v19;
      }
      else if (!v21)
      {
        *(float *)&v32 = v19;
      }
      if (v16 <= v23)
      {
        if (v16 >= v23)
          goto LABEL_14;
        v24 = (unint64_t)&v32;
      }
      else
      {
        v24 = (unint64_t)&v33;
      }
      *(float *)(v24 | 4) = v23;
LABEL_14:
      v25 = v13 + v9 + v11 * v17;
      v26 = v12 + v15 + v10 * v17;
      if (*(float *)&v33 <= v25)
      {
        if (*(float *)&v32 < v25)
          *(float *)&v32 = v25;
      }
      else
      {
        *(float *)&v33 = v25;
      }
      if (*((float *)&v33 + 1) <= v26)
      {
        if (*((float *)&v32 + 1) >= v26)
          goto LABEL_23;
        v27 = (unint64_t)&v32;
      }
      else
      {
        v27 = (unint64_t)&v33;
      }
      *(float *)(v27 | 4) = v26;
LABEL_23:
      v28 = v13 + v18 + v11 * x;
      v29 = v12 + v22 + v10 * x;
      if (*(float *)&v33 <= v28)
      {
        if (*(float *)&v32 < v28)
          *(float *)&v32 = v28;
      }
      else
      {
        *(float *)&v33 = v28;
      }
      if (*((float *)&v33 + 1) <= v29)
      {
        if (*((float *)&v32 + 1) >= v29)
          return *(float *)&v33;
        v30 = (unint64_t)&v32;
      }
      else
      {
        v30 = (unint64_t)&v33;
      }
      *(float *)(v30 | 4) = v29;
      return *(float *)&v33;
    }
  }
  return x;
}

BOOL CI::Affine::isIdentity(CI::Affine *this)
{
  return *(double *)this == 1.0
      && *((double *)this + 1) == 0.0
      && *((double *)this + 2) == 0.0
      && *((double *)this + 3) == 1.0
      && *((double *)this + 4) == 0.0
      && *((double *)this + 5) == 0.0;
}

double CI::GeneralKernelImage::extent(CI::GeneralKernelImage *this)
{
  return *((double *)this + 19);
}

uint64_t CI::GeneralKernelImage::child(CI::GeneralKernelImage *this, int a2)
{
  uint64_t v2;
  uint64_t v5;
  int v6;
  uint64_t i;
  uint64_t v8;
  unsigned int type;
  uint64_t v12;
  uint64_t v13;

  v2 = **((unsigned int **)this + 15);
  if ((int)v2 < 1)
    return 0;
  v5 = 0;
  v6 = 0;
  for (i = 24; ; i += 8)
  {
    v8 = *((_QWORD *)this + 14);
    if (*(_BYTE *)(v8 + 12))
    {
      type = CI::KernelArguments::get_type((CI::KernelArguments *)(v8 + 144), v5);
      goto LABEL_7;
    }
    if (v5 < *(int *)(v8 + 20))
      break;
LABEL_13:
    if (v2 == ++v5)
      return 0;
  }
  type = *(_DWORD *)(*(_QWORD *)(v8 + 72) + 4 * v5);
LABEL_7:
  if (type > 4 || ((1 << type) & 0x16) == 0)
    goto LABEL_13;
  if (v6 != a2)
  {
    ++v6;
    goto LABEL_13;
  }
  v12 = *((_QWORD *)this + 15);
  if (v5 > 9)
    v13 = *(_QWORD *)(v12 + 16) + 8 * (v5 - 10);
  else
    v13 = v12 + i;
  return *(_QWORD *)v13;
}

uint64_t CI::GeneralKernelImage::type(CI::GeneralKernelImage *this)
{
  return 13;
}

uint64_t CI::GeneralKernelImage::child_count(CI::GeneralKernelImage *this)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int type;

  v1 = **((unsigned int **)this + 15);
  if ((int)v1 >= 1)
  {
    v3 = 0;
    v4 = 0;
    while (1)
    {
      v5 = *((_QWORD *)this + 14);
      if (*(_BYTE *)(v5 + 12))
        break;
      if (v3 < *(int *)(v5 + 20))
      {
        type = *(_DWORD *)(*(_QWORD *)(v5 + 72) + 4 * v3);
        goto LABEL_7;
      }
LABEL_13:
      if (v1 == ++v3)
        return v4;
    }
    type = CI::KernelArguments::get_type((CI::KernelArguments *)(v5 + 144), v3);
LABEL_7:
    if (type > 4 || ((1 << type) & 0x16) == 0)
      v4 = v4;
    else
      v4 = (v4 + 1);
    goto LABEL_13;
  }
  return 0;
}

uint64_t CI::KernelArguments::count(CI::KernelArguments *this)
{
  if (*(_QWORD *)this)
    return **(unsigned int **)this;
  else
    return 0;
}

uint64_t CI::ImageWithChild::extent(CI::ImageWithChild *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 88))(*((_QWORD *)this + 13));
}

_DWORD *CI::SurfaceImage::extent(_DWORD *this)
{
  if (!this[46])
    return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)this + 96))(this);
  return this;
}

double CI::SurfaceImage::extent_unclamped(IOSurfaceRef *this)
{
  IOSurfaceGetWidth(this[14]);
  IOSurfaceGetHeight(this[14]);
  return 0.0;
}

double CI::AffineImage::extent(CI::AffineImage *this)
{
  CI::Affine *v1;
  CGRect v3;

  v1 = (CI::AffineImage *)((char *)this + 120);
  v3.origin.x = (*(double (**)(_QWORD))(**((_QWORD **)this + 13) + 88))(*((_QWORD *)this + 13));
  return CI::Affine::applyToRect(v1, v3);
}

uint64_t CI::AffineImage::type(CI::AffineImage *this)
{
  return 2;
}

void TimerBase::~TimerBase(TimerBase *this)
{
  int v2;
  double v3;
  int v4;
  NSObject *v5;
  const char *label;
  const char *v7;
  uint64_t v8;
  int v9;
  FILE **v10;
  double v11;
  double v12;
  float v13;
  double v15;
  const char *v16;
  double v17;
  double v18;
  FILE *v19;
  const char *v20;
  double v21;
  double v22;
  FILE *v23;
  int v24;
  FILE *v25;
  CFAbsoluteTime Current;
  NSObject *v27;
  int v28;

  v2 = *((_DWORD *)this + 6);
  if ((v2 - 29) < 2 || v2 == 6 || (v2 - 25) <= 3 || v2)
    kdebug_trace();
  if (CI_PRINT_TIME())
  {
    v3 = CFAbsoluteTimeGetCurrent() - *((double *)this + 5);
    if (v3 >= 0.000005)
    {
      v4 = *((_DWORD *)this + 7);
      if (v4)
      {
        if (v4 < (int)CI_PRINT_TIME())
        {
          v5 = *((_QWORD *)this + 4);
          if (v5)
            label = dispatch_queue_get_label(*((dispatch_queue_t *)this + 4));
          else
            label = "";
          if (!strncmp(label, "CI::", 4uLL))
            v7 = label;
          else
            v7 = "";
          v8 = *((int *)this + 7);
          if (*v7)
            v9 = 2 * v8 + 16;
          else
            v9 = 2 * v8;
          v10 = (FILE **)MEMORY[0x1E0C80C10];
          if (v5)
          {
            v11 = (double)(unint64_t)dispatch_queue_get_specific(v5, (const void *)(v8 + 0x6369746C1))
                / 10000000.0;
            if (v11 > 0.0)
            {
              v12 = v3 - v11;
              if (v12 >= 0.000001)
              {
                v13 = v12 * 100.0 / v3;
                if (v13 >= 10.0 && v13 <= 90.0)
                {
                  v15 = v13;
                  if (v12 <= 1.5)
                    v16 = "ms";
                  else
                    v16 = "s ";
                  v17 = 1000.0;
                  if (v12 > 1.5)
                    v17 = 1.0;
                  v18 = v12 * v17;
                  v19 = *v10;
                  v20 = _indent_str();
                  fprintf(v19, "CI_PRINT_TIME %9.3f%s %.*s unaccounted(%.1f%%) %s\n", v18, v16, v9 + 2, v20, v15, v7);
                }
              }
            }
          }
          v21 = 1000.0;
          if (v3 > 1.5)
            v21 = 1.0;
          v22 = v3 * v21;
          if (*((_DWORD *)this + 1))
          {
            v23 = *v10;
            _indent_str();
            fprintf(v23, "CI_PRINT_TIME %9.3f%s %.*s %s(c:%u, n:%u)  %s\n", *(_QWORD *)&v22);
          }
          else
          {
            v24 = *(_DWORD *)this;
            v25 = *v10;
            _indent_str();
            if (v24)
              fprintf(v25, "CI_PRINT_TIME %9.3f%s %.*s %s(c:%u)  %s\n");
            else
              fprintf(v25, "CI_PRINT_TIME %9.3f%s %.*s %s  %s\n");
          }
          fflush(*v10);
        }
      }
    }
    Current = CFAbsoluteTimeGetCurrent();
    TimerBase::add_time_at_level(this, *((_DWORD *)this + 7), Current - *((double *)this + 6));
    v27 = *((_QWORD *)this + 4);
    if (v27)
    {
      v28 = *((_DWORD *)this + 7);
      if (v28 <= 1)
        v28 = 1;
      dispatch_queue_set_specific(v27, "com.apple.coreimage.TimerBase.dispatchQueueKey", (void *)(v28 - 1), 0);
    }
  }
}

void Queue::~Queue(NSObject **this)
{
  NSObject *v2;
  NSObject *v3;

  v2 = *this;
  if (v2)
    dispatch_release(v2);
  v3 = this[1];
  if (v3)
    dispatch_release(v3);
}

void CI::CropImage::~CropImage(CI::CropImage *this)
{
  unsigned int v1;

  *((_QWORD *)this + 14) = off_1E2EBBF88;
  do
    v1 = __ldaxr(&dword_1ECF872F0[4]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[4]));
  CI::ImageWithChild::~ImageWithChild(this);
  JUMPOUT(0x194025AACLL);
}

{
  unsigned int v1;

  *((_QWORD *)this + 14) = off_1E2EBBF88;
  do
    v1 = __ldaxr(&dword_1ECF872F0[4]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[4]));
  CI::ImageWithChild::~ImageWithChild(this);
}

CI::CropImage *CI::CropImage::CropImage(CI::CropImage *this, CI::Image *a2, CGRect a3)
{
  double height;
  double width;
  double y;
  double x;
  unsigned int v9;

  height = a3.size.height;
  width = a3.size.width;
  y = a3.origin.y;
  x = a3.origin.x;
  *((_QWORD *)CI::ImageWithChild::ImageWithChild(this, a2) + 14) = off_1E2EBBF88;
  do
    v9 = __ldaxr(&dword_1ECF872F0[4]);
  while (__stlxr(v9 + 1, &dword_1ECF872F0[4]));
  *(_QWORD *)this = &unk_1E2EBFC18;
  *((_QWORD *)this + 14) = &unk_1E2EBFD70;
  *((double *)this + 15) = x;
  *((double *)this + 16) = y;
  *((double *)this + 17) = width;
  *((double *)this + 18) = height;
  *((_QWORD *)this + 10) = CI::CropImage::makeDigest(*((_QWORD *)a2 + 10), x, y, width, height);
  *((_QWORD *)this + 11) = CI::CropImage::makeDigest(*((_QWORD *)a2 + 11), x, y, width, height);
  return this;
}

void sub_1921F918C(_Unwind_Exception *a1)
{
  CI::ImageWithChild *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v5;
  unsigned int v6;

  *((_QWORD *)v1 + 14) = v2;
  v5 = (unsigned int *)(v3 + 24);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 - 1, v5));
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

void CI::Context::~Context(CGColorSpaceRef *this)
{
  CI::Object *v2;
  CGColorSpaceRef v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[5];

  *this = (CGColorSpaceRef)off_1E2EBEF40;
  CGColorSpaceRelease(this[2]);
  this[2] = 0;
  CGColorSpaceRelease(this[3]);
  this[3] = 0;
  CGContextRelease(this[6]);
  this[6] = 0;
  *((_BYTE *)this + 236) = 0;
  v2 = this[44];
  if (v2)
    CI::Object::unref(v2);
  this[44] = 0;
  v3 = this[38];
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 0x40000000;
  v11[2] = ___ZN2CI11ObjectCacheINS_11MainProgramENS_13ProgramDigestELb0EE5clearEv_block_invoke;
  v11[3] = &__block_descriptor_tmp_63_0;
  v11[4] = v3;
  Queue::execute_async((dispatch_queue_t *)v3 + 7, v11);
  v4 = (*((uint64_t (**)(CGColorSpaceRef *))*this + 34))(this);
  RemoveCacheEntriesForContext(v4);
  v5 = (uint64_t)this[38];
  if (v5)
  {
    v6 = CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::~ObjectCache(v5);
    MEMORY[0x194025AAC](v6, 0x10E0C40C1366CD6);
  }
  v7 = (uint64_t)this[39];
  if (v7)
  {
    v8 = CI::ObjectCache<CI::Node,unsigned long long,false>::~ObjectCache(v7);
    MEMORY[0x194025AAC](v8, 0x10E0C40C1366CD6);
  }
  v9 = (uint64_t)this[40];
  if (v9)
  {
    v10 = CI::ObjectCache<CI::Node,unsigned long long,false>::~ObjectCache(v9);
    MEMORY[0x194025AAC](v10, 0x10E0C40C1366CD6);
  }
}

uint64_t CI::Context::render_completion_queue(CI::Context *this)
{
  if (CI::Context::render_completion_queue(void)::onceToken != -1)
    dispatch_once(&CI::Context::render_completion_queue(void)::onceToken, &__block_literal_global_86);
  return CI::Context::render_completion_queue(void)::sRenderCompletionQueue;
}

uint64_t CI::Context::setDownsampleQuality(uint64_t this, char a2)
{
  *(_BYTE *)(this + 60) = a2;
  return this;
}

uint64_t CI::Context::setCacheVolatility(uint64_t this, int a2)
{
  int v2;

  if (a2 < 0)
    v2 = -1;
  else
    v2 = a2;
  if (v2 >= 8)
    v2 = 8;
  *(_DWORD *)(this + 232) = v2;
  return this;
}

uint64_t CI::Context::set_client_name(uint64_t this, CFStringRef theString)
{
  char *v3;

  v3 = (char *)(this + 236);
  if (theString)
    return CFStringGetCString(theString, v3, 64, 0x8000100u);
  *v3 = 0;
  return this;
}

void CI::Vector::~Vector(CI::Vector *this)
{
  unsigned int v1;

  *((_QWORD *)this + 2) = off_1E2EBBEE8;
  do
    v1 = __ldaxr(dword_1ECF873D0);
  while (__stlxr(v1 - 1, dword_1ECF873D0));
  JUMPOUT(0x194025AACLL);
}

{
  unsigned int v1;

  *((_QWORD *)this + 2) = off_1E2EBBEE8;
  do
    v1 = __ldaxr(dword_1ECF873D0);
  while (__stlxr(v1 - 1, dword_1ECF873D0));
}

uint64_t CI::Vector::Vector(uint64_t this, float a2)
{
  unsigned int v2;

  *(_QWORD *)this = &unk_1E2EBED30;
  *(_DWORD *)(this + 8) = 1;
  *(_QWORD *)(this + 16) = off_1E2EBBEE8;
  do
    v2 = __ldaxr(dword_1ECF873D0);
  while (__stlxr(v2 + 1, dword_1ECF873D0));
  *(_QWORD *)this = &off_1E2EBED68;
  *(_QWORD *)(this + 16) = &unk_1E2EBEDA0;
  *(_QWORD *)(this + 96) = 0;
  *(_OWORD *)(this + 32) = 0u;
  *(_OWORD *)(this + 48) = 0u;
  *(_OWORD *)(this + 64) = 0u;
  *(_OWORD *)(this + 76) = 0u;
  *(_DWORD *)(this + 24) = 1;
  *(float *)(this + 28) = a2;
  return this;
}

uint64_t CI::Kernel::set_can_reduce_output_channels(uint64_t this, char a2)
{
  *(_BYTE *)(this + 160) = a2;
  return this;
}

void CI::Image::~Image(CI::Image *this)
{
  void (**v2)(CI::Image *__hidden);
  const void *v3;

  v2 = off_1E2EBE8A8;
  *(_QWORD *)this = off_1E2EBE8A8;
  v3 = (const void *)*((_QWORD *)this + 6);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)this + 6) = 0;
    v2 = *(void (***)(CI::Image *__hidden))this;
  }
  ((void (*)(CI::Image *, _QWORD))v2[37])(this, 0);
  (*(void (**)(CI::Image *, _QWORD))(*(_QWORD *)this + 312))(this, 0);
}

void CI::Image::set_user_info(CI::Image *this, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = (CFTypeRef)*((_QWORD *)this + 7);
  if (v3 != cf)
  {
    if (cf)
    {
      CFRetain(cf);
      v3 = (CFTypeRef)*((_QWORD *)this + 7);
    }
    if (v3)
      CFRelease(v3);
    *((_QWORD *)this + 7) = cf;
  }
}

uint64_t CI::delete_precompiled_kernels(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

dispatch_object_t *CI::release_kernel_archive(dispatch_object_t *this, CI::KernelArchive *a2)
{
  if (this)
  {
    CI::KernelArchive::~KernelArchive(this);
    JUMPOUT(0x194025AACLL);
  }
  return this;
}

void CI::DAGPrecompiledKernels::~DAGPrecompiledKernels(CI::DAGPrecompiledKernels *this)
{
  CI::PrecompiledKernels::~PrecompiledKernels(this);
  JUMPOUT(0x194025AACLL);
}

void CI::SerialObjectPtrArray::~SerialObjectPtrArray(CI::SerialObjectPtrArray *this)
{
  int v2;
  unint64_t v3;
  CI::Object **v4;
  CI::Object **v5;
  void *v6;

  v2 = *(_DWORD *)this;
  if (*(int *)this >= 1)
  {
    v3 = 0;
    v4 = (CI::Object **)((char *)this + 24);
    do
    {
      v5 = v4;
      if (v3 >= 0xA)
        v5 = (CI::Object **)(*((_QWORD *)this + 2) + 8 * (v3 - 10));
      if (*v5)
      {
        CI::Object::unref(*v5);
        v2 = *(_DWORD *)this;
      }
      ++v3;
      ++v4;
    }
    while ((uint64_t)v3 < v2);
  }
  v6 = (void *)*((_QWORD *)this + 2);
  if (v6)
    free(v6);
}

void CI::MetalTextureManager::~MetalTextureManager(CI::MetalTextureManager *this)
{
  NSObject *v2;
  _QWORD v3[6];

  *(_QWORD *)this = &off_1E2EBDFC8;
  v2 = *((_QWORD *)this + 12);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN2CI19MetalTextureManager19purge_intermediatesEm_block_invoke;
  v3[3] = &__block_descriptor_48_e5_v8__0l;
  v3[4] = this;
  v3[5] = 0;
  dispatch_async(v2, v3);
  dispatch_sync(*((dispatch_queue_t *)this + 12), &__block_literal_global_85);
  CI::TextureManager::remove_all(this);
  if (CI_RECYCLE_METAL_TEXTURES() && CI_IOSURFACE_INTERMEDIATES())
    RemoveReleaseSurfaceBlock(*((_QWORD *)this + 13));
  CI::TextureManager::~TextureManager((dispatch_queue_t *)this);
}

{
  CI::MetalTextureManager::~MetalTextureManager(this);
  JUMPOUT(0x194025AACLL);
}

void sub_1921F9654(_Unwind_Exception *a1)
{
  dispatch_queue_t *v1;

  CI::TextureManager::~TextureManager(v1);
  _Unwind_Resume(a1);
}

void CI::MetalTextureManager::purge_intermediates(CI::MetalTextureManager *this, uint64_t a2)
{
  NSObject *v2;
  _QWORD v3[6];

  v2 = *((_QWORD *)this + 12);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN2CI19MetalTextureManager19purge_intermediatesEm_block_invoke;
  v3[3] = &__block_descriptor_48_e5_v8__0l;
  v3[4] = this;
  v3[5] = a2;
  dispatch_async(v2, v3);
}

void CI::PrecompiledKernels::~PrecompiledKernels(CI::PrecompiledKernels *this)
{
  NSObject **v2;
  uint64_t v3;
  char v4;
  char v5;
  id *v6;

  *(_QWORD *)this = &off_1E2EBDCD0;
  v2 = (NSObject **)((char *)this + 56);
  dispatch_sync(*((dispatch_queue_t *)this + 7), &__block_literal_global_183);
  v3 = 0;
  v4 = 1;
  do
  {
    v5 = v4;
    v6 = (id *)((char *)this + 8 * v3);

    v4 = 0;
    v3 = 1;
  }
  while ((v5 & 1) != 0);

  Queue::~Queue(v2);
}

{
  CI::PrecompiledKernels::~PrecompiledKernels(this);
  JUMPOUT(0x194025AACLL);
}

void sub_1921F9768(_Unwind_Exception *a1)
{
  NSObject **v1;

  Queue::~Queue(v1);
  _Unwind_Resume(a1);
}

void CI::GeneralKernelImage::~GeneralKernelImage(CI::GeneralKernelImage *this)
{
  CI::Object *v2;
  CI::SerialObjectPtrArray *v3;
  void *v4;
  unsigned int v5;

  *(_QWORD *)this = &off_1E2EBDB58;
  *((_QWORD *)this + 13) = &unk_1E2EBDCA8;
  v2 = (CI::Object *)*((_QWORD *)this + 14);
  if (v2 && *((_BYTE *)v2 + 12))
    CI::Object::unref(v2);
  v3 = (CI::SerialObjectPtrArray *)*((_QWORD *)this + 15);
  if (v3)
  {
    CI::SerialObjectPtrArray::~SerialObjectPtrArray(v3);
    MEMORY[0x194025AAC]();
  }
  _Block_release(*((const void **)this + 23));
  v4 = (void *)*((_QWORD *)this + 16);
  if (v4)
  {
    *((_QWORD *)this + 17) = v4;
    operator delete(v4);
  }
  *((_QWORD *)this + 13) = off_1E2EBB858;
  do
    v5 = __ldaxr(&dword_1ECF872F0[11]);
  while (__stlxr(v5 - 1, &dword_1ECF872F0[11]));
  CI::Image::~Image(this);
}

{
  CI::GeneralKernelImage::~GeneralKernelImage(this);
  JUMPOUT(0x194025AACLL);
}

void CI::StitchableKernels::~StitchableKernels(CI::StitchableKernels *this)
{
  CI::PrecompiledKernels::~PrecompiledKernels(this);
  JUMPOUT(0x194025AACLL);
}

CI::SerialStringArray *CI::SerialStringArray::SerialStringArray(CI::SerialStringArray *this, unsigned int a2, int a3)
{
  signed int v6;
  void *v7;
  int v8;
  uint64_t v9;

  *(_DWORD *)this = 0;
  v6 = a2 + a2 * a3;
  *((_DWORD *)this + 4) = v6;
  *((_QWORD *)this + 3) = malloc_type_malloc(v6, 0x5AFFD461uLL);
  v7 = malloc_type_malloc(8 * (int)a2, 0x10040436913F5uLL);
  if (a2 <= 1)
    v8 = 1;
  else
    v8 = a2;
  *((_DWORD *)this + 1) = a2;
  *((_DWORD *)this + 2) = v8;
  v9 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 4) = v7;
  *((_QWORD *)this + 5) = v9;
  *((_DWORD *)this + 3) = a3;
  return this;
}

id *CI::release_ci_dylib(id *this, CI::CoreImageDylib *a2)
{
  if (this)
  {
    CI::CoreImageDylib::~CoreImageDylib(this);
    JUMPOUT(0x194025AACLL);
  }
  return this;
}

BOOL CI::is_any_TypeImage(int a1)
{
  return (a1 - 2) < 0x18;
}

void CI::ColorMatchImage::~ColorMatchImage(CI::ColorMatchImage *this)
{
  unsigned int v2;

  *(_QWORD *)this = &off_1E2EBB490;
  *((_QWORD *)this + 14) = &unk_1E2EBB5E8;
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 15));
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 16));
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 14) = off_1E2EBBDD0;
  do
    v2 = __ldaxr(&dword_1ECF872F0[2]);
  while (__stlxr(v2 - 1, &dword_1ECF872F0[2]));
  CI::ImageWithChild::~ImageWithChild(this);
}

{
  CI::ColorMatchImage::~ColorMatchImage(this);
  JUMPOUT(0x194025AACLL);
}

void CI::TextureManager::~TextureManager(dispatch_queue_t *this)
{
  dispatch_queue_t v2;
  dispatch_queue_t v3;

  *this = (dispatch_queue_t)&unk_1E2EBB028;
  dispatch_sync(this[13], &__block_literal_global_98);
  v2 = this[7];
  if (v2)
    CFRelease(v2);
  this[7] = 0;
  v3 = this[17];
  if (v3)
  {
    std::__list_imp<CI::attached_surface_t *>::clear(this[17]);
    MEMORY[0x194025AAC](v3, 0x1020C4062D53EE8);
  }
  this[17] = 0;
  dispatch_release(this[13]);
  dispatch_release(this[11]);
  dispatch_release(this[12]);
  std::__tree<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::__map_value_compare<CI::Node const*,std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>,std::less<CI::Node const*>,true>,std::allocator<std::__value_type<CI::Node const*,std::multimap<int const,CI::TextureManager::tmIntermediate_t *>>>>::destroy((uint64_t)(this + 18), this[19]);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(this + 14), this[15]);
  std::__list_imp<CI::attached_surface_t *>::clear(this + 8);
  std::__list_imp<CI::attached_surface_t *>::clear(this + 4);
}

void CI::TextureManager::purge_intermediates(CI::TextureManager *this)
{
  NSObject *v1;
  _QWORD block[5];

  v1 = *((_QWORD *)this + 13);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI14TextureManager19purge_intermediatesEm_block_invoke;
  block[3] = &__block_descriptor_tmp_10_7;
  block[4] = this;
  dispatch_sync(v1, block);
}

void CI::TextureManager::remove_all(CI::TextureManager *this)
{
  NSObject *v1;
  _QWORD block[5];

  v1 = *((_QWORD *)this + 13);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI14TextureManager10remove_allEv_block_invoke;
  block[3] = &__block_descriptor_tmp_6_5;
  block[4] = this;
  dispatch_sync(v1, block);
}

void CI::ImageWithChild::~ImageWithChild(CI::ImageWithChild *this)
{
  CI::Object *v2;

  *(_QWORD *)this = &off_1E2EBA8B8;
  v2 = (CI::Object *)*((_QWORD *)this + 13);
  if (v2)
    CI::Object::unref(v2);
  *((_QWORD *)this + 13) = 0;
  CI::Image::~Image(this);
}

{
  CI::ImageWithChild::~ImageWithChild(this);
  JUMPOUT(0x194025AACLL);
}

void sub_1921F9B6C(_Unwind_Exception *a1)
{
  CI::Image *v1;

  CI::Image::~Image(v1);
  _Unwind_Resume(a1);
}

void CI::CoreImageDylib::~CoreImageDylib(id *this)
{
  id v2;

  if (*this)

  v2 = this[3];
  if (v2)

}

void CI::KernelArchive::~KernelArchive(dispatch_object_t *this)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  _QWORD block[5];

  v2 = *this;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN2CI13KernelArchiveD2Ev_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_sync(v2, block);
  dispatch_release(*this);
  v3 = this[7];
  if (v3)
  {
    this[8] = v3;
    operator delete(v3);
  }
  v4 = this[4];
  if (v4)
  {
    this[5] = v4;
    operator delete(v4);
  }
  v5 = this[1];
  if (v5)
  {
    this[2] = v5;
    operator delete(v5);
  }
}

void CI::SurfaceImage::~SurfaceImage(CI::SurfaceImage *this)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  unsigned int v8;

  *(_QWORD *)this = &off_1E2EB98D0;
  *((_QWORD *)this + 13) = &unk_1E2EB9A38;
  v2 = (const void *)*((_QWORD *)this + 14);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 14) = 0;
    v3 = (const void *)*((_QWORD *)this + 17);
    if (v3)
      CFRelease(v3);
    *((_QWORD *)this + 17) = 0;
    v4 = (const void *)*((_QWORD *)this + 16);
    if (v4)
    {
      CFRelease(v4);
      *((_QWORD *)this + 16) = 0;
    }
  }
  v5 = (const void *)*((_QWORD *)this + 18);
  if (v5)
    CFRelease(v5);
  *((_QWORD *)this + 18) = 0;
  v6 = (const void *)*((_QWORD *)this + 19);
  if (v6)
    CFRelease(v6);
  *((_QWORD *)this + 19) = 0;
  v7 = (const void *)*((_QWORD *)this + 20);
  if (v7)
    CFRelease(v7);
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 13) = off_1E2EBB948;
  do
    v8 = __ldaxr(&dword_1ECF872F0[17]);
  while (__stlxr(v8 - 1, &dword_1ECF872F0[17]));
  CI::Image::~Image(this);
}

{
  CI::SurfaceImage::~SurfaceImage(this);
  JUMPOUT(0x194025AACLL);
}

void CI::MetalContext::~MetalContext(CI::MetalContext *this)
{
  CI::CoreImageDylib *v2;
  CI::KernelArchive *v3;
  const void *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  char v8;
  char v9;
  char v10;
  char *v11;
  const void *v12;
  const void *v13;
  uint64_t v14;
  CI::Object *v15;
  unsigned int v16;

  *(_QWORD *)this = &off_1E2EB9400;
  *((_QWORD *)this + 48) = &unk_1E2EB9680;
  CI::delete_precompiled_kernels(*((_QWORD *)this + 241));
  CI::delete_precompiled_kernels(*((_QWORD *)this + 242));
  CI::release_ci_dylib(*((id **)this + 243), v2);
  CI::release_kernel_archive(*((dispatch_object_t **)this + 244), v3);
  *((_QWORD *)this + 244) = 0;
  *((_QWORD *)this + 241) = 0;
  *((_QWORD *)this + 242) = 0;
  v4 = (const void *)*((_QWORD *)this + 239);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 239) = 0;
  }
  v5 = 0;
  v6 = 1;
  do
  {
    v7 = 0;
    v8 = v6;
    v9 = 1;
    do
    {
      v10 = v9;
      v11 = (char *)this + 16 * v5 + 8 * v7;
      v12 = (const void *)*((_QWORD *)v11 + 219);
      if (v12)
      {
        CFRelease(v12);
        *((_QWORD *)v11 + 219) = 0;
      }
      v9 = 0;
      v7 = 1;
    }
    while ((v10 & 1) != 0);
    v6 = 0;
    v5 = 1;
  }
  while ((v8 & 1) != 0);
  v13 = (const void *)*((_QWORD *)this + 49);
  if (v13)
  {
    CFRelease(v13);
    *((_QWORD *)this + 49) = 0;
  }
  v14 = *((_QWORD *)this + 227);
  if (v14)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 32))(v14);
  v15 = (CI::Object *)*((_QWORD *)this + 228);
  *((_QWORD *)this + 227) = 0;
  *((_QWORD *)this + 228) = 0;
  if (v15)
    CI::Object::unref(v15);
  *((_QWORD *)this + 48) = off_1E2EB7B30;
  do
    v16 = __ldaxr(&dword_1ECF873D0[19]);
  while (__stlxr(v16 - 1, &dword_1ECF873D0[19]));
  CI::Context::~Context((CGColorSpaceRef *)this);
}

{
  CI::MetalContext::~MetalContext(this);
  JUMPOUT(0x194025AACLL);
}

void sub_1921F9E60(_Unwind_Exception *a1)
{
  uint64_t v1;
  CI::Object *v3;
  unsigned int v4;

  v3 = *(CI::Object **)(v1 + 1824);
  *(_QWORD *)(v1 + 1824) = 0;
  if (v3)
    CI::Object::unref(v3);
  *(_QWORD *)(v1 + 384) = off_1E2EB7B30;
  do
    v4 = __ldaxr(&dword_1ECF873D0[19]);
  while (__stlxr(v4 - 1, &dword_1ECF873D0[19]));
  CI::Context::~Context((CGColorSpaceRef *)v1);
  _Unwind_Resume(a1);
}

void CI::AffineImage::~AffineImage(CI::AffineImage *this)
{
  unsigned int v1;

  *((_QWORD *)this + 14) = off_1E2EBBAB0;
  do
    v1 = __ldaxr(dword_1ECF872F0);
  while (__stlxr(v1 - 1, dword_1ECF872F0));
  CI::ImageWithChild::~ImageWithChild(this);
  JUMPOUT(0x194025AACLL);
}

{
  unsigned int v1;

  *((_QWORD *)this + 14) = off_1E2EBBAB0;
  do
    v1 = __ldaxr(dword_1ECF872F0);
  while (__stlxr(v1 - 1, dword_1ECF872F0));
  CI::ImageWithChild::~ImageWithChild(this);
}

BOOL CIKernelReflection::reflect(CIKernelReflection *this, uint64_t a2, uint64_t a3, NSError **a4)
{
  uint64_t KernelByIdx;
  uint64_t v7;
  char *PrintedKernel;
  BOOL v9;
  NSObject *v10;
  _BOOL8 result;
  NSObject *v12;
  unsigned int KernelKind;
  int KernelReturnType;
  int v16;
  unsigned int NumKernelParameters;
  vector<CI::KernelArgumentType, std::allocator<CI::KernelArgumentType>> *p_var5;
  vector<std::string, std::allocator<std::string>> *p_var6;
  uint64_t v20;
  char *ParamName;
  char *var0;
  char *var1;
  __int128 v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char *v29;
  char *v30;
  __int128 v31;
  char *v32;
  char *v33;
  char *v34;
  __int128 v35;
  int64x2_t v36;
  void *v37;
  std::string *v38;
  int v39;
  int *v40;
  int *v41;
  int v42;
  int *v43;
  int *v44;
  int *v45;
  int *v46;
  int v47;
  int *v48;
  int *v49;
  int *v50;
  int *v51;
  int *v52;
  int *v53;
  int *v54;
  int *v55;
  int *v56;
  int *v57;
  int *v58;
  int *v59;
  int *v60;
  int *v61;
  int *v62;
  int *v63;
  int *v64;
  int v65;
  int *v66;
  int *v67;
  int *v68;
  int *v69;
  int *v70;
  int *v71;
  int *v72;
  int *v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  char *v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  int *v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  char *v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  int *v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  char *v129;
  int *v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  unint64_t v134;
  char *v135;
  uint64_t v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  uint64_t v142;
  unint64_t v143;
  uint64_t v144;
  uint64_t v145;
  unint64_t v146;
  uint64_t v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  int *v151;
  int v152;
  int v153;
  int *v154;
  int v155;
  int v156;
  int v157;
  int v158;
  int v159;
  int v160;
  int v161;
  int v162;
  int v163;
  int v164;
  int v165;
  int v166;
  int v167;
  int *v168;
  int v169;
  int *v170;
  int v171;
  int v172;
  int v173;
  int v174;
  int v175;
  int v176;
  uint64_t v177;
  const char *AttributeKeyword;
  char *v179;
  std::__split_buffer<std::string>::pointer begin;
  char *first;
  char *v182;
  char *v183;
  char *v184;
  std::string::size_type size;
  uint64_t v187;
  int v188;
  const char *v189;
  NSObject *v190;
  NSObject *v191;
  NSError **v192;
  char v193;
  __compressed_pair<CI::KernelArgumentType *, std::allocator<CI::KernelArgumentType>> *p_var2;
  std::__split_buffer<std::string> __s;
  char v196;
  std::string __p;
  uint64_t v198;

  v198 = *MEMORY[0x1E0C80C00];
  KernelByIdx = fosl_filter_kernelpool_getKernelByIdx(a2, a3);
  if (!KernelByIdx)
  {
    CIKernelError(a4, 4u, CFSTR("No valid kernels were in the string"));
    v12 = ci_logger_compile();
    result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    goto LABEL_10;
  }
  v7 = KernelByIdx;
  this->var2 = (char *)fosl_filter_kernelpool_getKernelName(KernelByIdx);
  PrintedKernel = (char *)fosl_filter_kernelpool_getPrintedKernel(v7);
  this->var3 = PrintedKernel;
  if (this->var2)
    v9 = PrintedKernel == 0;
  else
    v9 = 1;
  if (v9)
  {
    CIKernelError(a4, 4u, CFSTR("No valid kernels were in the string"));
    v10 = ci_logger_compile();
    result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
LABEL_10:
    CIKernelReflection::reflect();
    return 0;
  }
  if (FOSL_PRINT_KERNEL_AST())
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "Printed AST of kernel %s:\n%s\n", this->var2, this->var3);
  KernelKind = fosl_filter_kernelpool_getKernelKind(v7);
  if (KernelKind <= 2)
    this->var0 = dword_192495CC8[KernelKind];
  KernelReturnType = fosl_filter_kernelpool_getKernelReturnType(v7);
  switch(KernelReturnType)
  {
    case 1:
      v16 = 1;
      goto LABEL_22;
    case 3:
      v16 = 2;
      goto LABEL_22;
    case 19:
      v16 = 3;
LABEL_22:
      this->var1 = v16;
      break;
  }
  NumKernelParameters = fosl_filter_kernelpool_getNumKernelParameters(v7);
  p_var5 = &this->var5;
  std::vector<CI::KernelArgumentType>::reserve((void **)&this->var5.var0, NumKernelParameters);
  p_var6 = &this->var6;
  std::vector<std::string>::reserve((std::vector<std::string> *)&this->var6, NumKernelParameters);
  if (NumKernelParameters)
  {
    v192 = a4;
    v20 = 0;
    v193 = 0;
    p_var2 = &this->var5.var2;
    while (2)
    {
      ParamName = (char *)fosl_filter_kernelpool_getParamName(v7, v20);
      std::string::basic_string[abi:nn180100]<0>(&__p, ParamName);
      var1 = (char *)this->var6.var1;
      var0 = (char *)this->var6.var2.var0;
      if (var1 >= var0)
      {
        v25 = 0xAAAAAAAAAAAAAAABLL * ((var1 - (char *)p_var6->var0) >> 3);
        v26 = v25 + 1;
        if (v25 + 1 > 0xAAAAAAAAAAAAAAALL)
          abort();
        v27 = 0xAAAAAAAAAAAAAAABLL * ((var0 - (char *)p_var6->var0) >> 3);
        if (2 * v27 > v26)
          v26 = 2 * v27;
        if (v27 >= 0x555555555555555)
          v28 = 0xAAAAAAAAAAAAAAALL;
        else
          v28 = v26;
        __s.__end_cap_.__value_ = (std::allocator<std::string> *)&this->var6.var2;
        if (v28)
          v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>((uint64_t)&this->var6.var2, v28);
        else
          v29 = 0;
        v30 = &v29[24 * v25];
        v31 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *((_QWORD *)v30 + 2) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
        *(_OWORD *)v30 = v31;
        memset(&__p, 0, sizeof(__p));
        v33 = (char *)this->var6.var0;
        v32 = (char *)this->var6.var1;
        if (v32 == v33)
        {
          v36 = vdupq_n_s64((unint64_t)v32);
          v34 = &v29[24 * v25];
        }
        else
        {
          v34 = &v29[24 * v25];
          do
          {
            v35 = *(_OWORD *)(v32 - 24);
            *((_QWORD *)v34 - 1) = *((_QWORD *)v32 - 1);
            *(_OWORD *)(v34 - 24) = v35;
            v34 -= 24;
            *((_QWORD *)v32 - 2) = 0;
            *((_QWORD *)v32 - 1) = 0;
            *((_QWORD *)v32 - 3) = 0;
            v32 -= 24;
          }
          while (v32 != v33);
          v36 = *(int64x2_t *)&p_var6->var0;
        }
        v37 = v30 + 24;
        this->var6.var0 = v34;
        this->var6.var1 = v30 + 24;
        *(int64x2_t *)&__s.__begin_ = v36;
        v38 = (std::string *)this->var6.var2.var0;
        this->var6.var2.var0 = &v29[24 * v28];
        __s.__end_cap_.__value_ = v38;
        __s.__first_ = (std::__split_buffer<std::string>::pointer)v36.i64[0];
        std::__split_buffer<std::string>::~__split_buffer(&__s);
        v39 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
        this->var6.var1 = v37;
        if (v39 < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }
      else
      {
        v24 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *((_QWORD *)var1 + 2) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
        *(_OWORD *)var1 = v24;
        this->var6.var1 = var1 + 24;
      }
      switch(fosl_filter_kernelpool_getParamType(v7, v20))
      {
        case 0u:
          v41 = this->var5.var1;
          v40 = this->var5.var2.var0;
          if (v41 < v40)
          {
            v42 = 5;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v97 = v41 - p_var5->var0;
          v98 = v97 + 1;
          if ((unint64_t)(v97 + 1) >> 62)
            abort();
          v99 = (char *)v40 - (char *)v73;
          if (v99 >> 1 > v98)
            v98 = v99 >> 1;
          if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v98;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v97];
          *v151 = 5;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v159 = *--v41;
            *--v151 = v159;
          }
          goto LABEL_365;
        case 1u:
          v41 = this->var5.var1;
          v51 = this->var5.var2.var0;
          if (v41 < v51)
          {
            v42 = 6;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v94 = v41 - p_var5->var0;
          v95 = v94 + 1;
          if ((unint64_t)(v94 + 1) >> 62)
            abort();
          v96 = (char *)v51 - (char *)v73;
          if (v96 >> 1 > v95)
            v95 = v96 >> 1;
          if ((unint64_t)v96 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v95;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v94];
          *v151 = 6;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v158 = *--v41;
            *--v151 = v158;
          }
          goto LABEL_365;
        case 2u:
          v41 = this->var5.var1;
          v54 = this->var5.var2.var0;
          if (v41 < v54)
          {
            v42 = 7;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v106 = v41 - p_var5->var0;
          v107 = v106 + 1;
          if ((unint64_t)(v106 + 1) >> 62)
            abort();
          v108 = (char *)v54 - (char *)v73;
          if (v108 >> 1 > v107)
            v107 = v108 >> 1;
          if ((unint64_t)v108 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v107;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v106];
          *v151 = 7;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v162 = *--v41;
            *--v151 = v162;
          }
          goto LABEL_365;
        case 3u:
          v41 = this->var5.var1;
          v52 = this->var5.var2.var0;
          if (v41 < v52)
          {
            v42 = 8;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v100 = v41 - p_var5->var0;
          v101 = v100 + 1;
          if ((unint64_t)(v100 + 1) >> 62)
            abort();
          v102 = (char *)v52 - (char *)v73;
          if (v102 >> 1 > v101)
            v101 = v102 >> 1;
          if ((unint64_t)v102 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v101;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v100];
          *v151 = 8;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v160 = *--v41;
            *--v151 = v160;
          }
          goto LABEL_365;
        case 4u:
          v41 = this->var5.var1;
          v58 = this->var5.var2.var0;
          if (v41 < v58)
          {
            v42 = 27;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v118 = v41 - p_var5->var0;
          v119 = v118 + 1;
          if ((unint64_t)(v118 + 1) >> 62)
            abort();
          v120 = (char *)v58 - (char *)v73;
          if (v120 >> 1 > v119)
            v119 = v120 >> 1;
          if ((unint64_t)v120 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v119;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v118];
          *v151 = 27;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v166 = *--v41;
            *--v151 = v166;
          }
          goto LABEL_365;
        case 5u:
          v41 = this->var5.var1;
          v50 = this->var5.var2.var0;
          if (v41 < v50)
          {
            v42 = 10;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v91 = v41 - p_var5->var0;
          v92 = v91 + 1;
          if ((unint64_t)(v91 + 1) >> 62)
            abort();
          v93 = (char *)v50 - (char *)v73;
          if (v93 >> 1 > v92)
            v92 = v93 >> 1;
          if ((unint64_t)v93 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v92;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v91];
          *v151 = 10;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v157 = *--v41;
            *--v151 = v157;
          }
          goto LABEL_365;
        case 6u:
          v41 = this->var5.var1;
          v57 = this->var5.var2.var0;
          if (v41 < v57)
          {
            v42 = 11;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v115 = v41 - p_var5->var0;
          v116 = v115 + 1;
          if ((unint64_t)(v115 + 1) >> 62)
            abort();
          v117 = (char *)v57 - (char *)v73;
          if (v117 >> 1 > v116)
            v116 = v117 >> 1;
          if ((unint64_t)v117 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v116;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v115];
          *v151 = 11;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v165 = *--v41;
            *--v151 = v165;
          }
          goto LABEL_365;
        case 7u:
          v41 = this->var5.var1;
          v67 = this->var5.var2.var0;
          if (v41 < v67)
          {
            v42 = 19;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v139 = v41 - p_var5->var0;
          v140 = v139 + 1;
          if ((unint64_t)(v139 + 1) >> 62)
            abort();
          v141 = (char *)v67 - (char *)v73;
          if (v141 >> 1 > v140)
            v140 = v141 >> 1;
          if ((unint64_t)v141 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v140;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v139];
          *v151 = 19;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v173 = *--v41;
            *--v151 = v173;
          }
          goto LABEL_365;
        case 8u:
          v41 = this->var5.var1;
          v53 = this->var5.var2.var0;
          if (v41 < v53)
          {
            v42 = 4;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v103 = v41 - p_var5->var0;
          v104 = v103 + 1;
          if ((unint64_t)(v103 + 1) >> 62)
            abort();
          v105 = (char *)v53 - (char *)v73;
          if (v105 >> 1 > v104)
            v104 = v105 >> 1;
          if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v104;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v103];
          *v151 = 4;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v161 = *--v41;
            *--v151 = v161;
          }
          goto LABEL_365;
        case 9u:
          v64 = this->var5.var1;
          v63 = this->var5.var2.var0;
          if (v64 < v63)
          {
            v65 = 1;
            goto LABEL_87;
          }
          v130 = p_var5->var0;
          v131 = v64 - p_var5->var0;
          v132 = v131 + 1;
          if ((unint64_t)(v131 + 1) >> 62)
            abort();
          v133 = (char *)v63 - (char *)v130;
          if (v133 >> 1 > v132)
            v132 = v133 >> 1;
          if ((unint64_t)v133 >= 0x7FFFFFFFFFFFFFFCLL)
            v134 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v134 = v132;
          if (v134)
          {
            v135 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v134);
            v130 = this->var5.var0;
            v64 = this->var5.var1;
          }
          else
          {
            v135 = 0;
          }
          v170 = (int *)&v135[4 * v131];
          *v170 = 1;
          v70 = v170 + 1;
          while (v64 != v130)
          {
            v171 = *--v64;
            *--v170 = v171;
          }
          goto LABEL_357;
        case 0xAu:
          this->var13 = 1;
          v64 = this->var5.var1;
          v69 = this->var5.var2.var0;
          if (v64 >= v69)
          {
            v130 = p_var5->var0;
            v145 = v64 - p_var5->var0;
            v146 = v145 + 1;
            if ((unint64_t)(v145 + 1) >> 62)
              abort();
            v147 = (char *)v69 - (char *)v130;
            if (v147 >> 1 > v146)
              v146 = v147 >> 1;
            if ((unint64_t)v147 >= 0x7FFFFFFFFFFFFFFCLL)
              v134 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v134 = v146;
            if (v134)
            {
              v135 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v134);
              v130 = this->var5.var0;
              v64 = this->var5.var1;
            }
            else
            {
              v135 = 0;
            }
            v170 = (int *)&v135[4 * v145];
            *v170 = 2;
            v70 = v170 + 1;
            while (v64 != v130)
            {
              v175 = *--v64;
              *--v170 = v175;
            }
LABEL_357:
            this->var5.var0 = v170;
            this->var5.var1 = v70;
            this->var5.var2.var0 = (int *)&v135[4 * v134];
            if (v130)
              operator delete(v130);
          }
          else
          {
            v65 = 2;
LABEL_87:
            *v64 = v65;
            v70 = v64 + 1;
          }
          this->var5.var1 = v70;
          goto LABEL_360;
        case 0xCu:
          v41 = this->var5.var1;
          v55 = this->var5.var2.var0;
          if (v41 < v55)
          {
            v42 = 9;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v109 = v41 - p_var5->var0;
          v110 = v109 + 1;
          if ((unint64_t)(v109 + 1) >> 62)
            abort();
          v111 = (char *)v55 - (char *)v73;
          if (v111 >> 1 > v110)
            v110 = v111 >> 1;
          if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v110;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v109];
          *v151 = 9;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v163 = *--v41;
            *--v151 = v163;
          }
          goto LABEL_365;
        case 0x10u:
          v41 = this->var5.var1;
          v66 = this->var5.var2.var0;
          if (v41 < v66)
          {
            v42 = 12;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v136 = v41 - p_var5->var0;
          v137 = v136 + 1;
          if ((unint64_t)(v136 + 1) >> 62)
            abort();
          v138 = (char *)v66 - (char *)v73;
          if (v138 >> 1 > v137)
            v137 = v138 >> 1;
          if ((unint64_t)v138 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v137;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v136];
          *v151 = 12;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v172 = *--v41;
            *--v151 = v172;
          }
          goto LABEL_365;
        case 0x11u:
          v41 = this->var5.var1;
          v56 = this->var5.var2.var0;
          if (v41 < v56)
          {
            v42 = 13;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v112 = v41 - p_var5->var0;
          v113 = v112 + 1;
          if ((unint64_t)(v112 + 1) >> 62)
            abort();
          v114 = (char *)v56 - (char *)v73;
          if (v114 >> 1 > v113)
            v113 = v114 >> 1;
          if ((unint64_t)v114 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v113;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v112];
          *v151 = 13;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v164 = *--v41;
            *--v151 = v164;
          }
          goto LABEL_365;
        case 0x12u:
          v41 = this->var5.var1;
          v71 = this->var5.var2.var0;
          if (v41 < v71)
          {
            v42 = 14;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v148 = v41 - p_var5->var0;
          v149 = v148 + 1;
          if ((unint64_t)(v148 + 1) >> 62)
            abort();
          v150 = (char *)v71 - (char *)v73;
          if (v150 >> 1 > v149)
            v149 = v150 >> 1;
          if ((unint64_t)v150 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v149;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v148];
          *v151 = 14;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v176 = *--v41;
            *--v151 = v176;
          }
          goto LABEL_365;
        case 0x13u:
          v41 = this->var5.var1;
          v68 = this->var5.var2.var0;
          if (v41 < v68)
          {
            v42 = 15;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v142 = v41 - p_var5->var0;
          v143 = v142 + 1;
          if ((unint64_t)(v142 + 1) >> 62)
            abort();
          v144 = (char *)v68 - (char *)v73;
          if (v144 >> 1 > v143)
            v143 = v144 >> 1;
          if ((unint64_t)v144 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v143;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v142];
          *v151 = 15;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v174 = *--v41;
            *--v151 = v174;
          }
          goto LABEL_365;
        case 0x14u:
          v41 = this->var5.var1;
          v43 = this->var5.var2.var0;
          if (v41 < v43)
          {
            v42 = 16;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v74 = v41 - p_var5->var0;
          v75 = v74 + 1;
          if ((unint64_t)(v74 + 1) >> 62)
            abort();
          v76 = (char *)v43 - (char *)v73;
          if (v76 >> 1 > v75)
            v75 = v76 >> 1;
          if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v75;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v74];
          *v151 = 16;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v152 = *--v41;
            *--v151 = v152;
          }
          goto LABEL_365;
        case 0x15u:
          v41 = this->var5.var1;
          v59 = this->var5.var2.var0;
          if (v41 < v59)
          {
            v42 = 17;
            goto LABEL_90;
          }
          v73 = p_var5->var0;
          v121 = v41 - p_var5->var0;
          v122 = v121 + 1;
          if ((unint64_t)(v121 + 1) >> 62)
            abort();
          v123 = (char *)v59 - (char *)v73;
          if (v123 >> 1 > v122)
            v122 = v123 >> 1;
          if ((unint64_t)v123 >= 0x7FFFFFFFFFFFFFFCLL)
            v77 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v77 = v122;
          if (v77)
          {
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
            v73 = this->var5.var0;
            v41 = this->var5.var1;
          }
          else
          {
            v78 = 0;
          }
          v151 = (int *)&v78[4 * v121];
          *v151 = 17;
          v72 = v151 + 1;
          while (v41 != v73)
          {
            v167 = *--v41;
            *--v151 = v167;
          }
          goto LABEL_365;
        case 0x16u:
          v41 = this->var5.var1;
          v44 = this->var5.var2.var0;
          if (v41 >= v44)
          {
            v73 = p_var5->var0;
            v79 = v41 - p_var5->var0;
            v80 = v79 + 1;
            if ((unint64_t)(v79 + 1) >> 62)
              abort();
            v81 = (char *)v44 - (char *)v73;
            if (v81 >> 1 > v80)
              v80 = v81 >> 1;
            if ((unint64_t)v81 >= 0x7FFFFFFFFFFFFFFCLL)
              v77 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v77 = v80;
            if (v77)
            {
              v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v77);
              v73 = this->var5.var0;
              v41 = this->var5.var1;
            }
            else
            {
              v78 = 0;
            }
            v151 = (int *)&v78[4 * v79];
            *v151 = 18;
            v72 = v151 + 1;
            while (v41 != v73)
            {
              v153 = *--v41;
              *--v151 = v153;
            }
LABEL_365:
            this->var5.var0 = v151;
            this->var5.var1 = v72;
            this->var5.var2.var0 = (int *)&v78[4 * v77];
            if (v73)
              operator delete(v73);
          }
          else
          {
            v42 = 18;
LABEL_90:
            *v41 = v42;
            v72 = v41 + 1;
          }
          this->var5.var1 = v72;
          goto LABEL_368;
        case 0x18u:
          v61 = this->var5.var1;
          v60 = this->var5.var2.var0;
          if (v61 >= v60)
          {
            v124 = p_var5->var0;
            v125 = v61 - p_var5->var0;
            v126 = v125 + 1;
            if ((unint64_t)(v125 + 1) >> 62)
              abort();
            v127 = (char *)v60 - (char *)v124;
            if (v127 >> 1 > v126)
              v126 = v127 >> 1;
            if ((unint64_t)v127 >= 0x7FFFFFFFFFFFFFFCLL)
              v128 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v128 = v126;
            if (v128)
            {
              v129 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v128);
              v124 = this->var5.var0;
              v61 = this->var5.var1;
            }
            else
            {
              v129 = 0;
            }
            v168 = (int *)&v129[4 * v125];
            *v168 = 4;
            v62 = v168 + 1;
            while (v61 != v124)
            {
              v169 = *--v61;
              *--v168 = v169;
            }
            this->var5.var0 = v168;
            this->var5.var1 = v62;
            this->var5.var2.var0 = (int *)&v129[4 * v128];
            if (v124)
              operator delete(v124);
          }
          else
          {
            *v61 = 4;
            v62 = v61 + 1;
          }
          this->var5.var1 = v62;
          this->var8 |= 0x10u;
          goto LABEL_368;
        case 0x19u:
          v46 = this->var5.var1;
          v48 = this->var5.var2.var0;
          if (v46 < v48)
          {
            v47 = 1;
            goto LABEL_54;
          }
          v82 = p_var5->var0;
          v88 = v46 - p_var5->var0;
          v89 = v88 + 1;
          if ((unint64_t)(v88 + 1) >> 62)
            abort();
          v90 = (char *)v48 - (char *)v82;
          if (v90 >> 1 > v89)
            v89 = v90 >> 1;
          if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFFCLL)
            v86 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v86 = v89;
          if (v86)
          {
            v87 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v86);
            v82 = this->var5.var0;
            v46 = this->var5.var1;
          }
          else
          {
            v87 = 0;
          }
          v154 = (int *)&v87[4 * v88];
          *v154 = 1;
          v49 = v154 + 1;
          while (v46 != v82)
          {
            v156 = *--v46;
            *--v154 = v156;
          }
          goto LABEL_283;
        case 0x1Au:
          this->var13 = 1;
          v46 = this->var5.var1;
          v45 = this->var5.var2.var0;
          if (v46 >= v45)
          {
            v82 = p_var5->var0;
            v83 = v46 - p_var5->var0;
            v84 = v83 + 1;
            if ((unint64_t)(v83 + 1) >> 62)
              abort();
            v85 = (char *)v45 - (char *)v82;
            if (v85 >> 1 > v84)
              v84 = v85 >> 1;
            if ((unint64_t)v85 >= 0x7FFFFFFFFFFFFFFCLL)
              v86 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v86 = v84;
            if (v86)
            {
              v87 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)p_var2, v86);
              v82 = this->var5.var0;
              v46 = this->var5.var1;
            }
            else
            {
              v87 = 0;
            }
            v154 = (int *)&v87[4 * v83];
            *v154 = 2;
            v49 = v154 + 1;
            while (v46 != v82)
            {
              v155 = *--v46;
              *--v154 = v155;
            }
LABEL_283:
            this->var5.var0 = v154;
            this->var5.var1 = v49;
            this->var5.var2.var0 = (int *)&v87[4 * v86];
            if (v82)
              operator delete(v82);
          }
          else
          {
            v47 = 2;
LABEL_54:
            *v46 = v47;
            v49 = v46 + 1;
          }
          this->var5.var1 = v49;
          this->var8 |= 0x10u;
LABEL_360:
          v193 = 1;
LABEL_368:
          v20 = (v20 + 1);
          if ((_DWORD)v20 == NumKernelParameters)
            goto LABEL_371;
          continue;
        default:
          CIKernelError(v192, 4u, CFSTR("Kernel %s has an unsupported type for the parameter %s"), this->var2, ParamName);
          v191 = ci_logger_compile();
          result = os_log_type_enabled(v191, OS_LOG_TYPE_ERROR);
          if (!result)
            return result;
          CIKernelReflection::reflect();
          return 0;
      }
    }
  }
  v193 = 0;
LABEL_371:
  if (fosl_filter_kernelpool_isPositionInvariant(v7))
    this->var8 |= 1u;
  if ((v193 & 1) != 0 && fosl_filter_kernelpool_preservesAlpha(v7))
    this->var8 |= 2u;
  if (fosl_filter_kernelpool_getNumKernelAttributes(v7))
  {
    v177 = 0;
    while (1)
    {
      AttributeKeyword = (const char *)fosl_filter_kernelpool_getAttributeKeyword(v7, v177);
      v179 = fosl_filter_kernelpool_hasAttributeParameters(v7, v177)
           ? (char *)fosl_filter_kernelpool_getAttributeParameters(v7, v177)
           : 0;
      if (!strcmp(AttributeKeyword, "outputFormat") && v179)
        break;
LABEL_414:
      v177 = (v177 + 1);
      if (v177 >= fosl_filter_kernelpool_getNumKernelAttributes(v7))
        return 1;
    }
    std::string::basic_string[abi:nn180100]<0>(&__s, v179);
    if (SHIBYTE(__s.__end_) < 0)
    {
      begin = __s.__begin_;
      if ((uint64_t)__s.__begin_ >= 11)
      {
        first = (char *)__s.__first_;
LABEL_388:
        v182 = (char *)begin + (_QWORD)first;
        v183 = first;
        do
        {
          v184 = (char *)memchr(v183, 107, (size_t)&begin[-1].__r_.__value_.__r.__words[2]);
          if (!v184)
            break;
          if (*(_QWORD *)v184 == 0x616D726F4649436BLL && v184[8] == 116)
          {
            if (v184 != v182 && v184 == first)
            {
              std::string::basic_string(&__p, (const std::string *)&__s, 9uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v196);
              size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                size = __p.__r_.__value_.__l.__size_;
              if (size)
              {
                v187 = 0;
                while (1)
                {
                  v188 = dword_192495C80[v187];
                  v189 = CI::name_for_format(v188);
                  if (v189)
                  {
                    if (!std::string::compare(&__p, v189))
                      break;
                  }
                  if (++v187 == 6)
                    goto LABEL_407;
                }
                this->var9 = v188;
              }
LABEL_407:
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                operator delete(__p.__r_.__value_.__l.__data_);
            }
            break;
          }
          v183 = v184 + 1;
          begin = (std::__split_buffer<std::string>::pointer)(v182 - v183);
        }
        while (v182 - v183 >= 9);
      }
    }
    else
    {
      begin = (std::__split_buffer<std::string>::pointer)HIBYTE(__s.__end_);
      if (HIBYTE(__s.__end_) >= 0xBu)
      {
        first = (char *)&__s;
        goto LABEL_388;
      }
    }
    if (!this->var9)
    {
      v190 = ci_logger_api();
      if (os_log_type_enabled(v190, OS_LOG_TYPE_INFO))
      {
        LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v179;
        _os_log_impl(&dword_1921E4000, v190, OS_LOG_TYPE_INFO, "%{public}s is not an known pixel format name. Will use working format instead.", (uint8_t *)&__p, 0xCu);
      }
    }
    if (SHIBYTE(__s.__end_) < 0)
      operator delete(__s.__first_);
    goto LABEL_414;
  }
  return 1;
}

void sub_1921FB2A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a22 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void foslFunctions::foslFunctions(foslFunctions *this)
{
  _BYTE v2[56];

  ci_signpost_log_render();
  TimerBase::TimerBase((uint64_t)v2, 0, 0, (uint64_t)"foslFunctions", 31);
  foslFunctions::initializeFunctions(this);
  foslFunctions::foslFunctions(void)::SignpostTimer::~SignpostTimer((TimerBase *)v2);
}

void *foslFunctions::initializeFunctions(foslFunctions *this)
{
  void *v2;
  void *v3;
  void *result;

  v2 = dlopen("/usr/lib/libFosl_dynamic.dylib", 2);
  if (!v2)
    return (void *)fprintf((FILE *)*MEMORY[0x1E0C80C10], "Unable to open Fosl library at path %s\n", "/usr/lib/libFosl_dynamic.dylib");
  v3 = v2;
  *(_QWORD *)this = dlsym(v2, "fosl_filter_interface_version");
  *((_QWORD *)this + 1) = dlsym(v3, "fosl_filter_kernelpool_createPool");
  *((_QWORD *)this + 2) = dlsym(v3, "fosl_filter_kernelpool_hasError");
  *((_QWORD *)this + 3) = dlsym(v3, "fosl_filter_kernelpool_addLibrary");
  *((_QWORD *)this + 4) = dlsym(v3, "fosl_filter_kernelpool_addString");
  *((_QWORD *)this + 5) = dlsym(v3, "fosl_filter_kernelpool_destroyPool");
  *((_QWORD *)this + 6) = dlsym(v3, "fosl_filter_kernelpool_getNumKernels");
  *((_QWORD *)this + 7) = dlsym(v3, "fosl_filter_kernelpool_lookupKernel");
  *((_QWORD *)this + 8) = dlsym(v3, "fosl_filter_kernelpool_getKernelByIdx");
  *((_QWORD *)this + 9) = dlsym(v3, "fosl_filter_kernelpool_getNumDiagnostics");
  *((_QWORD *)this + 10) = dlsym(v3, "fosl_filter_kernelpool_getDiagnosticByIdx");
  *((_QWORD *)this + 11) = dlsym(v3, "fosl_filter_kernelpool_getKernelKind");
  *((_QWORD *)this + 12) = dlsym(v3, "fosl_filter_kernelpool_getKernelReturnType");
  *((_QWORD *)this + 13) = dlsym(v3, "fosl_filter_kernelpool_getKernelName");
  *((_QWORD *)this + 14) = dlsym(v3, "fosl_filter_kernelpool_getPrintedKernel");
  *((_QWORD *)this + 15) = dlsym(v3, "fosl_filter_kernelpool_getKernelDimensionality");
  *((_QWORD *)this + 16) = dlsym(v3, "fosl_filter_kernelpool_isPositionInvariant");
  *((_QWORD *)this + 17) = dlsym(v3, "fosl_filter_kernelpool_preservesAlpha");
  *((_QWORD *)this + 18) = dlsym(v3, "fosl_filter_kernelpool_getNumKernelParameters");
  *((_QWORD *)this + 19) = dlsym(v3, "fosl_filter_kernelpool_getParamName");
  *((_QWORD *)this + 20) = dlsym(v3, "fosl_filter_kernelpool_getParamType");
  *((_QWORD *)this + 21) = dlsym(v3, "fosl_filter_kernelpool_getNumKernelAttributes");
  *((_QWORD *)this + 22) = dlsym(v3, "fosl_filter_kernelpool_getAttributeKeyword");
  *((_QWORD *)this + 23) = dlsym(v3, "fosl_filter_kernelpool_getAttributeParameters");
  *((_QWORD *)this + 24) = dlsym(v3, "fosl_filter_kernelpool_hasAttributeParameters");
  *((_QWORD *)this + 25) = dlsym(v3, "fosl_filter_createGraph");
  *((_QWORD *)this + 26) = dlsym(v3, "fosl_filter_assignRoot");
  *((_QWORD *)this + 27) = dlsym(v3, "fosl_filter_destroyGraph");
  *((_QWORD *)this + 28) = dlsym(v3, "fosl_filter_createKernel");
  *((_QWORD *)this + 29) = dlsym(v3, "fosl_filter_addLibraryFunction");
  *((_QWORD *)this + 30) = dlsym(v3, "fosl_filter_addChild");
  *((_QWORD *)this + 31) = dlsym(v3, "fosl_filter_createSampler");
  *((_QWORD *)this + 32) = dlsym(v3, "fosl_filter_createImage");
  *((_QWORD *)this + 33) = dlsym(v3, "fosl_filter_createUniform");
  *((_QWORD *)this + 34) = dlsym(v3, "fosl_filter_createConstant");
  *((_QWORD *)this + 35) = dlsym(v3, "fosl_filter_createTransformMatrix");
  *((_QWORD *)this + 36) = dlsym(v3, "fosl_filter_createSampleTransform");
  *((_QWORD *)this + 37) = dlsym(v3, "fosl_filter_createUsePosition");
  *((_QWORD *)this + 38) = dlsym(v3, "fosl_filter_createPositionUpdate");
  *((_QWORD *)this + 39) = dlsym(v3, "fosl_filter_createCoordinateTransform");
  *((_QWORD *)this + 40) = dlsym(v3, "fosl_filter_setPositionUpdatePosition");
  *((_QWORD *)this + 41) = dlsym(v3, "fosl_filter_setPositionUpdateContinuation");
  *((_QWORD *)this + 42) = dlsym(v3, "fosl_filter_setSamplerNeedsSRGBToLinear");
  *((_QWORD *)this + 43) = dlsym(v3, "fosl_filter_setSamplerSwizzleMask");
  *((_QWORD *)this + 44) = dlsym(v3, "fosl_filter_setSamplerSwizzleMacro");
  *((_QWORD *)this + 45) = dlsym(v3, "fosl_filter_setMainEntryPointName");
  *((_QWORD *)this + 46) = dlsym(v3, "fosl_filter_parseNodesInGraph");
  *((_QWORD *)this + 47) = dlsym(v3, "fosl_filter_synthesizeMainInGraph");
  *((_QWORD *)this + 48) = dlsym(v3, "fosl_filter_synthesizeMainInGraphOfType");
  *((_QWORD *)this + 49) = dlsym(v3, "fosl_filter_synthesizeMainInGraphOfTypeWithOptions");
  *((_QWORD *)this + 50) = dlsym(v3, "fosl_filter_dumpGraph");
  *((_QWORD *)this + 51) = dlsym(v3, "fosl_filter_printGraph");
  *((_QWORD *)this + 52) = dlsym(v3, "fosl_filter_getStringForGraph");
  result = dlsym(v3, "fosl_filter_getStringForGraphWithOptions");
  *((_QWORD *)this + 53) = result;
  return result;
}

uint64_t check_and_emit_compile_errors(NSString *a1, uint64_t a2, NSMutableArray *a3)
{
  uint64_t result;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  std::locale::id *v9;
  const char **DiagnosticByIdx;
  _QWORD *v11;
  _QWORD *v12;
  size_t v13;
  _QWORD *v14;
  const std::locale::facet *v15;
  _QWORD *v16;
  const std::locale::facet *v17;
  int v18;
  const __CFString *v19;
  _QWORD *v20;
  const char *v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  const std::locale::facet *v25;
  uint64_t v26;
  _QWORD v28[6];
  std::locale v29;
  std::locale *v30;
  uint64_t v31;
  uint64_t v32;
  std::locale v33;
  _QWORD v34[4];
  _QWORD v35[6];

  v35[4] = *MEMORY[0x1E0C80C00];
  result = fosl_filter_kernelpool_getNumDiagnostics(a2);
  if ((_DWORD)result)
  {
    v6 = result;
    v7 = 0;
    v26 = 0;
    v8 = (_QWORD *)MEMORY[0x1E0DE4A50];
    v9 = (std::locale::id *)MEMORY[0x1E0DE4A90];
    do
    {
      DiagnosticByIdx = (const char **)fosl_filter_kernelpool_getDiagnosticByIdx(a2, v7);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"[CIKernelPool] ", 15);
      v11 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)":", 1);
      v12 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)": ", 2);
      switch(*(_DWORD *)DiagnosticByIdx)
      {
        case 0:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"note: ", 6);
          break;
        case 1:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"remark: ", 8);
          break;
        case 2:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"WARNING: ", 9);
          break;
        case 4:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"ERROR: ", 7);
          goto LABEL_9;
        case 8:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"FATAL ERROR: ", 13);
LABEL_9:
          ++v26;
          break;
        default:
          break;
      }
      v13 = strlen(DiagnosticByIdx[2]);
      v14 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)DiagnosticByIdx[2], v13);
      std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(_QWORD *)(*v14 - 24)));
      v15 = std::locale::use_facet(&v29, v9);
      ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
      std::locale::~locale(&v29);
      std::ostream::put();
      std::ostream::flush();
      v29.__locale_ = 0;
      v30 = &v29;
      v31 = 0x2020000000;
      v32 = 1;
      v28[0] = MEMORY[0x1E0C809B0];
      v28[1] = 3221225472;
      v28[2] = ___ZL29check_and_emit_compile_errorsP8NSStringPvP14NSMutableArray_block_invoke;
      v28[3] = &unk_1E2EC46E8;
      v28[4] = &v29;
      v28[5] = DiagnosticByIdx;
      -[NSString enumerateLinesUsingBlock:](a1, "enumerateLinesUsingBlock:", v28);
      *(_QWORD *)((char *)v8 + *(_QWORD *)(*v8 - 24) + 24) = *((int *)DiagnosticByIdx + 2);
      v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"^", 1);
      std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(_QWORD *)(*v16 - 24)));
      v17 = std::locale::use_facet(&v33, v9);
      ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
      std::locale::~locale(&v33);
      std::ostream::put();
      std::ostream::flush();
      if (a3)
      {
        v34[0] = CFSTR("CIKernelMessageType");
        v18 = *(_DWORD *)DiagnosticByIdx - 1;
        v19 = CFSTR("CIKernelMessageTypeNote");
        if (v18 <= 7)
          v19 = (const __CFString *)*((_QWORD *)&off_1E2EC47E0 + v18);
        v35[0] = v19;
        v34[1] = CFSTR("CIKernelMessageLineNumber");
        v35[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *((unsigned int *)DiagnosticByIdx + 1));
        v34[2] = CFSTR("kCIKernelMessageOffset");
        v35[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", *((unsigned int *)DiagnosticByIdx + 3));
        v34[3] = CFSTR("kCIKernelMessageDescription");
        v35[3] = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", DiagnosticByIdx[2]);
        -[NSMutableArray addObject:](a3, "addObject:", objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v35, v34, 4));
      }
      free(DiagnosticByIdx);
      _Block_object_dispose(&v29, 8);
      v7 = (v7 + 1);
    }
    while (v6 != (_DWORD)v7);
    if (v26)
    {
      v20 = (_QWORD *)std::ostream::operator<<();
      if (v26 == 1)
        v21 = " error ";
      else
        v21 = " errors ";
      if (v26 == 1)
        v22 = 7;
      else
        v22 = 8;
      v23 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)v21, v22);
      v24 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v23, (uint64_t)"generated.", 10);
      std::ios_base::getloc((const std::ios_base *)((char *)v24 + *(_QWORD *)(*v24 - 24)));
      v25 = std::locale::use_facet(&v29, MEMORY[0x1E0DE4A90]);
      ((void (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 10);
      std::locale::~locale(&v29);
      std::ostream::put();
      std::ostream::flush();
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_1921FBC5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::locale a18, uint64_t a19, uint64_t a20,uint64_t a21,std::locale a22)
{
  std::locale::~locale(&a18);
  _Unwind_Resume(a1);
}

char *CI_PRINT_TREE_has_string(char *a1)
{
  char *string;
  char *result;
  const char *v4;

  string = get_string("CI_PRINT_TREE");
  result = 0;
  if (a1)
  {
    if (string)
    {
      result = strstr(string, a1);
      if (result)
      {
        v4 = result;
        result = a1;
        if (v4 != a1)
        {
          if (*(v4 - 1) == 32)
            return (char *)v4;
          else
            return 0;
        }
      }
    }
  }
  return result;
}

uint64_t verify_argument_type(void *a1, int a2, int a3)
{
  unint64_t v6;
  uint64_t v7;
  char isKindOfClass;
  BOOL v9;
  double v10;
  double v11;
  BOOL v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v6 = objc_msgSend(a1, "count");
  else
    v6 = 0;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v7 = objc_msgSend(a1, "count");
  else
    v7 = 0;
  isKindOfClass = 0;
  switch(a2)
  {
    case 1:
    case 2:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
        goto LABEL_50;
      goto LABEL_45;
    case 4:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_48;
      v15 = objc_msgSend(a1, "_internalRepresentation");
      v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 16))(v15);
      if ((CI::is_raster_TypeImage(v16) & 1) == 0)
        goto LABEL_48;
      goto LABEL_50;
    case 5:
    case 12:
      objc_opt_class();
      isKindOfClass = objc_opt_isKindOfClass() | (v6 == 1);
      return isKindOfClass & 1;
    case 6:
    case 13:
      v9 = v6 > 1;
      goto LABEL_42;
    case 7:
    case 14:
      v9 = v6 > 2;
LABEL_42:
      isKindOfClass = v9;
      return isKindOfClass & 1;
    case 8:
    case 15:
      if (v6 - 3 < 2)
        goto LABEL_50;
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
        goto LABEL_50;
      if (a3)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          objc_msgSend(a1, "extent");
          if (fabs(v10 * v11 + -1.0) < 1.0e-10)
            goto LABEL_50;
        }
      }
      goto LABEL_48;
    case 9:
    case 16:
      v12 = v6 == 4;
      goto LABEL_23;
    case 10:
    case 17:
      v12 = v6 == 9 || v6 == 6;
      goto LABEL_23;
    case 11:
    case 18:
      v12 = v6 == 16;
LABEL_23:
      isKindOfClass = v12;
      return isKindOfClass & 1;
    case 19:
    case 23:
    case 28:
    case 29:
      goto LABEL_45;
    case 20:
    case 24:
      if (v7 == 2)
      {
        objc_msgSend(a1, "objectAtIndex:", 0);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          isKindOfClass = 1;
          objc_msgSend(a1, "objectAtIndex:", 1);
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
            return isKindOfClass & 1;
        }
      }
      goto LABEL_48;
    case 21:
    case 25:
      if (v7 != 3)
        goto LABEL_48;
      objc_msgSend(a1, "objectAtIndex:", 0);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_48;
      objc_msgSend(a1, "objectAtIndex:", 1);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_48;
      v13 = a1;
      v14 = 2;
      goto LABEL_39;
    case 22:
    case 26:
      if (v7 != 4)
        goto LABEL_48;
      objc_msgSend(a1, "objectAtIndex:", 0);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_48;
      objc_msgSend(a1, "objectAtIndex:", 1);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_48;
      objc_msgSend(a1, "objectAtIndex:", 2);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_48;
      v13 = a1;
      v14 = 3;
LABEL_39:
      objc_msgSend(v13, "objectAtIndex:", v14);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
LABEL_50:
        isKindOfClass = 1;
      else
LABEL_48:
        isKindOfClass = 0;
      break;
    case 27:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
        goto LABEL_50;
LABEL_45:
      objc_opt_class();
      isKindOfClass = objc_opt_isKindOfClass();
      break;
    default:
      return isKindOfClass & 1;
  }
  return isKindOfClass & 1;
}

CI::Vector *object_for_argument(void *a1, int a2)
{
  CI::Vector *v2;
  uint64_t v4;
  float v5;
  double v6;
  double v7;
  float v8;
  double v9;
  float v10;
  double v11;
  double v12;
  double v13;
  double v14;
  float v15;
  float v16;
  double v17;
  float v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  float v25;
  float v26;
  float v27;
  __n128 v28;
  float v29;
  unsigned __int32 v30;
  unsigned __int32 v31;
  float v32;
  float v33;
  __n64 v34;
  unsigned __int32 v35;
  unsigned __int32 v36;
  float v37;
  float v38;
  float v39;
  float v40;
  __n64 v41;
  unsigned __int32 v42;
  unsigned __int32 v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  __n128 v50;
  double v51;
  float v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  float v58;
  float v59;
  double v60;
  float v61;
  CGAffineTransform v63;

  v2 = 0;
  switch(a2)
  {
    case 1:
    case 2:
    case 4:
      v2 = (CI::Vector *)objc_msgSend(a1, "_internalRepresentation");
      CI::Object::ref((uint64_t)v2);
      return v2;
    case 5:
    case 12:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
        goto LABEL_8;
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_40;
      v2 = (CI::Vector *)operator new();
      objc_msgSend(a1, "X");
      *(float *)&v51 = v51;
      CI::Vector::Vector((uint64_t)v2, *(float *)&v51);
      return v2;
    case 6:
    case 13:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_40;
      v2 = (CI::Vector *)operator new();
      objc_msgSend(a1, "X");
      v7 = v6;
      objc_msgSend(a1, "Y");
      v8 = v7;
      v10 = v9;
      *(float *)&v9 = v8;
      CI::Vector::Vector(v2, *(__n64 *)&v9, v10);
      return v2;
    case 7:
    case 14:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_40;
      v2 = (CI::Vector *)operator new();
      objc_msgSend(a1, "X");
      v12 = v11;
      objc_msgSend(a1, "Y");
      v14 = v13;
      objc_msgSend(a1, "Z");
      v15 = v12;
      v16 = v14;
      v18 = v17;
      *(float *)&v17 = v15;
      CI::Vector::Vector(v2, *(__n64 *)&v17, v16, v18);
      return v2;
    case 8:
    case 15:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
        goto LABEL_14;
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_40;
      goto LABEL_34;
    case 9:
    case 16:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_40;
LABEL_14:
      v2 = (CI::Vector *)operator new();
      objc_msgSend(a1, "X");
      v20 = v19;
      objc_msgSend(a1, "Y");
      v22 = v21;
      objc_msgSend(a1, "Z");
      v24 = v23;
      objc_msgSend(a1, "W");
      v25 = v20;
      v26 = v22;
      v27 = v24;
      v29 = v28.n128_f64[0];
      v28.n128_f32[0] = v25;
      CI::Vector::Vector(v2, v28, v26, v27, v29);
      break;
    case 10:
    case 11:
    case 17:
    case 18:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_40;
      v4 = objc_msgSend(a1, "count");
      v2 = (CI::Vector *)operator new();
      if (v4 == 6)
      {
        if (a1)
          objc_msgSend(a1, "CGAffineTransformValue");
        else
          memset(&v63, 0, sizeof(v63));
        CI::Vector::Vector(v2, &v63);
      }
      else
      {
        CI::Vector::Vector(v2, (const double *)objc_msgSend(a1, "_values"), objc_msgSend(a1, "count"));
      }
      break;
    case 19:
    case 23:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_40;
LABEL_8:
      v2 = (CI::Vector *)operator new();
      objc_msgSend(a1, "floatValue");
      CI::Vector::Vector((uint64_t)v2, v5);
      break;
    case 20:
    case 24:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0 || objc_msgSend(a1, "count") != 2)
        goto LABEL_40;
      v2 = (CI::Vector *)operator new();
      objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", 0), "floatValue");
      v31 = v30;
      objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", 1), "floatValue");
      v33 = v32;
      v34.n64_u32[0] = v31;
      CI::Vector::Vector(v2, v34, v33);
      break;
    case 21:
    case 25:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0 || objc_msgSend(a1, "count") != 3)
        goto LABEL_40;
      v2 = (CI::Vector *)operator new();
      objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", 0), "floatValue");
      v36 = v35;
      objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", 1), "floatValue");
      v38 = v37;
      objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", 2), "floatValue");
      v40 = v39;
      v41.n64_u32[0] = v36;
      CI::Vector::Vector(v2, v41, v38, v40);
      break;
    case 22:
    case 26:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0 || objc_msgSend(a1, "count") != 4)
        goto LABEL_40;
      v2 = (CI::Vector *)operator new();
      objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", 0), "floatValue");
      v43 = v42;
      objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", 1), "floatValue");
      v45 = v44;
      objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", 2), "floatValue");
      v47 = v46;
      objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", 3), "floatValue");
      v49 = v48;
      v50.n128_u32[0] = v43;
      CI::Vector::Vector(v2, v50, v45, v47, v49);
      break;
    case 27:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v52 = 1.0;
        if ((unint64_t)objc_msgSend(a1, "count") >= 4)
        {
          objc_msgSend(a1, "W");
          v52 = v53;
        }
        v2 = (CI::Vector *)operator new();
        objc_msgSend(a1, "X");
        v55 = v54;
        objc_msgSend(a1, "Y");
        v57 = v56;
        objc_msgSend(a1, "Z");
        v58 = v55;
        v59 = v57;
        v61 = v60;
        CI::Color::Color((uint64_t)v2, v58, v59, v61, v52);
      }
      else
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
LABEL_34:
          v2 = (CI::Vector *)operator new();
          CI::Color::Color(v2, (CGColor *)objc_msgSend(a1, "cgColor"));
        }
        else
        {
LABEL_40:
          v2 = 0;
        }
      }
      break;
    case 28:
    case 29:
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_40;
      v2 = (CI::Vector *)operator new();
      CI::Buffer::Buffer(v2, a1);
      break;
    default:
      return v2;
  }
  return v2;
}

void sub_1921FC7FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10A1C405FB94D4BLL);
  _Unwind_Resume(a1);
}

BOOL check_cikl_string(NSString *a1, const char *a2)
{
  NSUInteger v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = -[NSString length](a1, "length");
  if (!v3)
  {
    v4 = ci_logger_compile();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      check_cikl_string((uint64_t)a2, v4, v5, v6, v7, v8, v9, v10);
  }
  return v3 != 0;
}

void RemoveCacheEntriesForContext(int a1)
{
  _QWORD block[4];
  int v3;

  if (GetQueue(void)::onceToken != -1)
    dispatch_once(&GetQueue(void)::onceToken, &__block_literal_global_67_0);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __RemoveCacheEntriesForContext_block_invoke;
  block[3] = &__block_descriptor_tmp_48_1;
  v3 = a1;
  dispatch_sync((dispatch_queue_t)gSurfaceCacheQueue, block);
}

uint64_t FOSL_PRINT_KERNEL_AST()
{
  unsigned __int8 v0;

  {
    FOSL_PRINT_KERNEL_AST::v = get_BOOL("FOSL_PRINT_KERNEL_AST", 0);
  }
  return FOSL_PRINT_KERNEL_AST::v;
}

void sub_1921FC9D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_PRINT_TREE_dump_outputs()
{
  unsigned __int8 v0;

  {
    CI_PRINT_TREE_dump_outputs::v = CI_PRINT_TREE_has_string("dump-outputs") != 0;
  }
  return CI_PRINT_TREE_dump_outputs::v;
}

void sub_1921FCA58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_PRINT_TREE_dump_intermediates()
{
  unsigned __int8 v0;

  {
    CI_PRINT_TREE_dump_intermediates::v = CI_PRINT_TREE_has_string("dump-intermediates") != 0;
  }
  return CI_PRINT_TREE_dump_intermediates::v;
}

void sub_1921FCAD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_LOG_SURFACE_CACHE()
{
  unsigned __int8 v0;

  {
    CI_LOG_SURFACE_CACHE::v = get_int("CI_LOG_SURFACE_CACHE", 0);
  }
  return CI_LOG_SURFACE_CACHE::v;
}

void sub_1921FCB54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_KDEBUG()
{
  unsigned __int8 v0;

  {
    CI_KDEBUG::v = get_int("CI_KDEBUG", 1);
  }
  return CI_KDEBUG::v;
}

void sub_1921FCBD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1921FE2A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *__p, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__pa, uint64_t a14, uint64_t a15, uint64_t a16, CIKernelReflection *a17, uint64_t a18, CIKernelReflection *a19, CIKernelReflection *a20,CIKernelReflection *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t a71;

  CIKernelReflection::~CIKernelReflection((CIKernelReflection *)&a41);
  CIKernelReflection::~CIKernelReflection((CIKernelReflection *)&a56);
  CIKernelReflection::~CIKernelReflection((CIKernelReflection *)&a71);
  _Unwind_Resume(a1);
}

void sub_1921FE5A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  uint64_t v22;

  MEMORY[0x194025AAC](v22, 0x10F1C409D028DB2);
  _Unwind_Resume(a1);
}

void sub_1921FE6E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  CIKernelReflection::~CIKernelReflection((CIKernelReflection *)&a9);
  _Unwind_Resume(a1);
}

void sub_1921FE950(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C407DA4F8A2);
  _Unwind_Resume(a1);
}

void sub_1921FEC5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(exception_object);
}

uint64_t CI::SoftwareDAGDescriptor::print(CI::SoftwareDAGDescriptor *this, __sFILE *__stream)
{
  uint64_t v4;
  char *v5;
  void **v6;
  CI::SoftwareDAGDescriptor *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  unint64_t i;
  uint64_t v14;
  int v15;
  void **v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  unint64_t v22;
  int *v23;
  char v24;
  int v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unsigned int v32;
  void **v33;
  uint64_t v34;
  void (**v35)(void **__return_ptr);
  CI::SoftwareDAGDescriptor *v37;
  void *__p[2];
  char v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int128 v43;
  char *v44;
  void (***v45)(void **__return_ptr);
  unint64_t v46;
  char v47;

  fwrite("// Software DAG Functions\n", 0x1AuLL, 1uLL, __stream);
  v37 = this;
  v4 = *((_QWORD *)this + 2);
  v41 = 0;
  v42 = 0;
  v40 = 0;
  std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>((char *)&v40, *(_QWORD *)v4, *(_QWORD *)(v4 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(v4 + 8) - *(_QWORD *)v4) >> 3));
  v5 = *(char **)(v4 + 40);
  v43 = *(_OWORD *)(v4 + 24);
  v44 = v5;
  v45 = (void (***)(void **__return_ptr))v40;
  v46 = *(_QWORD *)(v4 + 56);
  v47 = *(_BYTE *)(v4 + 64);
  fprintf(__stream, "#%zu = ", 0);
  fprintf(__stream, "%s(", v44);
  (**v45)(__p);
  if (v39 >= 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  fputs((const char *)v6, __stream);
  if (v39 < 0)
    operator delete(__p[0]);
  fwrite(")\n", 2uLL, 1uLL, __stream);
  __p[0] = &v40;
  std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
  v7 = this;
  if (*((_QWORD *)this + 6) == *((_QWORD *)this + 5))
  {
    v18 = 0;
  }
  else
  {
    v8 = 0;
    do
    {
      v9 = v8 + 1;
      fprintf(__stream, "#%zu = ", v8 + 1);
      v10 = *((_QWORD *)v7 + 5) + 72 * v8;
      v41 = 0;
      v42 = 0;
      v40 = 0;
      std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>((char *)&v40, *(_QWORD *)v10, *(_QWORD *)(v10 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(v10 + 8) - *(_QWORD *)v10) >> 3));
      v11 = *(_OWORD *)(v10 + 24);
      v44 = *(char **)(v10 + 40);
      v43 = v11;
      v45 = (void (***)(void **__return_ptr))v40;
      v46 = *(_QWORD *)(v10 + 56);
      v47 = *(_BYTE *)(v10 + 64);
      fputs(v44, __stream);
      if (v46)
      {
        v12 = 0;
        for (i = 0; i < v46; ++i)
        {
          if (i)
            v14 = 44;
          else
            v14 = 40;
          fprintf(__stream, "%c ", v14);
          v15 = (int)v45[v12 + 2];
          if ((v15 - 3) < 2 || v15 == 0)
          {
            (*v45[v12])(__p);
            if (v39 >= 0)
              v17 = __p;
            else
              v17 = (void **)__p[0];
            fputs((const char *)v17, __stream);
            if (v39 < 0)
              operator delete(__p[0]);
          }
          else if (v15 == 5)
          {
            fprintf(__stream, "#%zu", (size_t)v45[v12 + 1]);
          }
          else
          {
            fputs("<Unknown>", __stream);
          }
          v12 += 3;
        }
      }
      fwrite(")\n", 2uLL, 1uLL, __stream);
      __p[0] = &v40;
      std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
      v7 = v37;
      v18 = 0x8E38E38E38E38E39 * ((uint64_t)(*((_QWORD *)v37 + 6) - *((_QWORD *)v37 + 5)) >> 3);
      ++v8;
    }
    while (v9 < v18);
  }
  if (0x8E38E38E38E38E39 * ((uint64_t)(*((_QWORD *)v7 + 3) - *((_QWORD *)v7 + 2)) >> 3) >= 2)
  {
    v19 = 1;
    while (1)
    {
      fprintf(__stream, "#%zu = ", v19 + v18);
      v20 = *((_QWORD *)v7 + 2) + 72 * v19;
      v41 = 0;
      v42 = 0;
      v40 = 0;
      std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>((char *)&v40, *(_QWORD *)v20, *(_QWORD *)(v20 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(v20 + 8) - *(_QWORD *)v20) >> 3));
      v21 = *(_OWORD *)(v20 + 24);
      v44 = *(char **)(v20 + 40);
      v43 = v21;
      v45 = (void (***)(void **__return_ptr))v40;
      v22 = *(_QWORD *)(v20 + 56);
      v46 = v22;
      v47 = *(_BYTE *)(v20 + 64);
      if (v22)
      {
        v23 = (int *)(v40 + 16);
        v24 = 1;
        do
        {
          v25 = *v23;
          v23 += 6;
          v24 &= v25 == 5;
          --v22;
        }
        while (v22);
      }
      else
      {
        v24 = 1;
      }
      fputs(v44, __stream);
      if (v46)
        break;
      fwrite("()\n", 3uLL, 1uLL, __stream);
LABEL_67:
      __p[0] = &v40;
      std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
      if (++v19 >= 0x8E38E38E38E38E39 * ((uint64_t)(*((_QWORD *)v7 + 3) - *((_QWORD *)v7 + 2)) >> 3))
        return fputc(10, __stream);
    }
    if ((v24 & 1) != 0)
    {
      v26 = 0;
      v27 = 1;
      do
      {
        if (v26)
          v28 = 44;
        else
          v28 = 40;
        fprintf(__stream, "%c #%zu", v28, (size_t)v45[v27] + v18);
        ++v26;
        v27 += 3;
      }
      while (v26 < v46);
LABEL_66:
      fwrite(")\n", 2uLL, 1uLL, __stream);
      v7 = v37;
      goto LABEL_67;
    }
    v29 = 0;
    v30 = 0;
    while (1)
    {
      v31 = v30 ? 44 : 40;
      fprintf(__stream, "%c ", v31);
      v32 = v45[v29 + 2];
      if (v32 > 7)
        break;
      if (((1 << v32) & 0x99) != 0)
      {
        (*v45[v29])(__p);
        if (v39 >= 0)
          v33 = __p;
        else
          v33 = (void **)__p[0];
        fputs((const char *)v33, __stream);
        if (v39 < 0)
          operator delete(__p[0]);
        goto LABEL_65;
      }
      if (v32 == 5)
      {
        v35 = v45[v29 + 1];
        if (v35)
          v34 = (uint64_t)v35 + v18;
        else
          v34 = 0;
      }
      else
      {
        if (v32 != 6)
          break;
        v34 = (uint64_t)v45[v29 + 1] + 1;
      }
      fprintf(__stream, "#%zu", v34);
LABEL_65:
      ++v30;
      v29 += 3;
      if (v30 >= v46)
        goto LABEL_66;
    }
    fputs("<Unknown>", __stream);
    goto LABEL_65;
  }
  return fputc(10, __stream);
}

void sub_1921FF324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100]((void ***)va);
  _Unwind_Resume(a1);
}

void CI::SoftwareDAG::~SoftwareDAG(CI::SoftwareDAG *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E2EB7AA0;
  v2 = *((_QWORD *)this + 12);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  CI::MainProgram::~MainProgram(this);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_1E2EB7AA0;
  v2 = *((_QWORD *)this + 12);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  CI::MainProgram::~MainProgram(this);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::SoftwareDAG::print_program(CI::SoftwareDAGDescriptor **this, __sFILE *a2)
{
  return CI::SoftwareDAGDescriptor::print(this[12], a2);
}

const char *CI::SoftwareDAG::get_type_name(CI::SoftwareDAG *this)
{
  return "SWDAG";
}

void CI::SoftwareDAG::execute(uint64_t a1, uint64_t a2, dispatch_queue_t *a3, CI::Object *this, int a5, double a6, double a7, double a8, double a9)
{
  _QWORD block[11];

  if (this)
    CI::Object::ref((uint64_t)this);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZNK2CI11SoftwareDAG7executeERKNS_20SerialObjectPtrArrayEP5Queue6CGRectPKNS_13BitmapSamplerEb_block_invoke;
  block[3] = &__block_descriptor_88_e5_v8__0l;
  block[4] = a1;
  block[5] = a2;
  *(double *)&block[6] = a6;
  *(double *)&block[7] = a7;
  *(double *)&block[8] = a8;
  *(double *)&block[9] = a9;
  block[10] = this;
  if (a5)
    dispatch_sync(*a3, block);
  else
    Queue::execute_async(a3, block);
}

void ___ZNK2CI11SoftwareDAG7executeERKNS_20SerialObjectPtrArrayEP5Queue6CGRectPKNS_13BitmapSamplerEb_block_invoke(uint64_t a1)
{
  CI::MainProgram *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  unint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  CI::Object *v26;
  _BYTE v27[32];
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v2 = *(CI::MainProgram **)(a1 + 32);
  v3 = CI::MainProgram::num_arguments(v2);
  v4 = v3;
  if (MEMORY[0x1E0C80A78](v3, v5, v6, v7, v8, v9))
  {
    v13 = &v27[-64 * v4];
    do
    {
      *(_OWORD *)v13 = 0uLL;
      *((_OWORD *)v13 + 1) = 0uLL;
      *((_QWORD *)v13 + 4) = 0x100000000;
      *((_QWORD *)v13 + 6) = 0;
      *((_QWORD *)v13 + 7) = 0;
      v13 += 64;
    }
    while (v13 != v27);
    if ((int)v4 >= 1)
    {
      v14 = 0;
      v15 = 24;
      v16 = &v27[-64 * v4];
      do
      {
        v17 = (*(uint64_t (**)(CI::MainProgram *, unint64_t))(*(_QWORD *)v2 + 40))(v2, v14);
        v18 = *(_QWORD *)(a1 + 40);
        if (v14 > 9)
          v19 = (uint64_t *)(*(_QWORD *)(v18 + 16) + 8 * (v14 - 10));
        else
          v19 = (uint64_t *)(v18 + v15);
        v20 = *v19;
        switch(v17)
        {
          case 1:
          case 2:
          case 3:
          case 4:
            *(_QWORD *)v16 = v20;
            break;
          case 5:
          case 12:
          case 19:
          case 23:
            if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v20 + 16))(v20) != 58)
              return;
            *(_DWORD *)v16 = *(_DWORD *)(v20 + 28);
            break;
          case 6:
          case 13:
          case 20:
          case 24:
            if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v20 + 16))(v20) != 58)
              return;
            *(_QWORD *)v16 = *(_QWORD *)(v20 + 96);
            break;
          case 7:
          case 14:
          case 21:
          case 25:
            if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v20 + 16))(v20) != 58)
              return;
            v22 = *(_OWORD *)(v20 + 96);
            *((_DWORD *)v16 + 2) = DWORD2(v22);
            *(_QWORD *)v16 = v22;
            break;
          case 8:
          case 15:
          case 22:
          case 26:
          case 27:
            if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v20 + 16))(v20) != 58)
              return;
            v21 = *(_OWORD *)(v20 + 96);
LABEL_20:
            *(_OWORD *)v16 = v21;
            break;
          case 40:
          case 44:
          case 45:
            v21 = *(_OWORD *)(v20 + 96);
            v23 = *(_OWORD *)(v20 + 112);
            *((_QWORD *)v16 + 4) = *(_QWORD *)(v20 + 128);
            *((_OWORD *)v16 + 1) = v23;
            goto LABEL_20;
          case 41:
            v24 = *(_OWORD *)(v20 + 64);
            *(_QWORD *)&v28 = *(_QWORD *)(v20 + 128);
            v25 = *(_OWORD *)(v20 + 112);
            *(_OWORD *)v16 = *(_OWORD *)(v20 + 96);
            *((_OWORD *)v16 + 1) = v25;
            *((_OWORD *)v16 + 2) = v28;
            *((_OWORD *)v16 + 3) = v24;
            break;
          default:
            break;
        }
        ++v14;
        v16 += 64;
        v15 += 8;
      }
      while (v4 != v14);
    }
  }
  CI::SoftwareDAGDescriptor::execute(*((_QWORD **)v2 + 12), (uint64_t)&v27[-64 * v4], *(_QWORD *)(a1 + 80), v10, v11, v12, *(CGFloat *)(a1 + 48), *(CGFloat *)(a1 + 56), *(CGFloat *)(a1 + 64), *(CGFloat *)(a1 + 72));
  v26 = *(CI::Object **)(a1 + 80);
  if (v26)
    CI::Object::unref(v26);
}

void CI::SoftwareDAGDescriptor::execute(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, CGFloat a7, CGFloat a8, CGFloat a9, CGFloat a10)
{
  uint64_t v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t *v31;
  uint64_t v32;
  unint64_t width;
  unint64_t height;
  unint64_t x;
  unint64_t y;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  CI::Object *v40;
  unint64_t v41;
  unint64_t v42;
  int v43[2];
  uint64_t v44;
  CGRect v45;
  CGRect v46;
  CGRect v47;
  CGRect v48;
  CGRect v49;

  v44 = *MEMORY[0x1E0C80C00];
  v17 = MEMORY[0x1E0C80A78](a1, 16 * ((a1[3] - a1[2]) / 72), a3, a4, a5, a6);
  v24 = &v41 - 2 * v23;
  if (v25 != v26)
    bzero(&v41 - 2 * v23, v18);
  v27 = a1[6] - a1[5];
  if (v27)
  {
    v28 = 0x8E38E38E38E38E39 * (v27 >> 3);
    MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22);
    v30 = (unint64_t *)((char *)&v41 - v29);
  }
  else
  {
    MEMORY[0x1E0C80A78](v17, v18, v19, v20, v21, v22);
    v30 = &v41 - 10;
    v28 = 1;
  }
  v31 = v30;
  do
  {
    *v31 = (unint64_t)&off_1E2EB7668;
    v31[8] = 0;
    v31[9] = 0;
    *(_OWORD *)(v31 + 1) = 0uLL;
    *(_OWORD *)(v31 + 3) = 0uLL;
    *(_OWORD *)(v31 + 5) = 0uLL;
    v31 += 10;
  }
  while (v31 != &v30[10 * v28]);
  v32 = a1[1];
  v41 = v28;
  CI::SWRendererPipeline::initSamplers(v32, a2, (uint64_t)v30);
  v45.origin.x = a7;
  v45.origin.y = a8;
  v45.size.width = a9;
  v45.size.height = a10;
  if (CGRectIsNull(v45))
  {
    width = 0;
    height = 0;
    x = 0x7FFFFFFFLL;
    y = 0x7FFFFFFFLL;
  }
  else
  {
    v46.origin.x = a7;
    v46.origin.y = a8;
    v46.size.width = a9;
    v46.size.height = a10;
    if (CGRectIsInfinite(v46))
    {
      x = -2147483647;
      width = 0xFFFFFFFFLL;
      y = -2147483647;
      height = 0xFFFFFFFFLL;
    }
    else
    {
      v47.origin.x = a7;
      v47.origin.y = a8;
      v47.size.width = a9;
      v47.size.height = a10;
      v48 = CGRectInset(v47, 0.000001, 0.000001);
      v49 = CGRectIntegral(v48);
      width = (unint64_t)v49.size.width;
      height = (unint64_t)v49.size.height;
      y = (int)v49.origin.y;
      x = (int)v49.origin.x;
    }
  }
  v42 = height + y;
  if (height + y > y)
  {
    v37 = width + x;
    do
    {
      if (v37 > x)
      {
        v38 = x;
        do
        {
          v43[0] = v38;
          v43[1] = y;
          CI::SWRendererPipeline::execute((_QWORD *)a1[1], a2, v24, (uint64_t)v30, a3, v43);
          ++v38;
        }
        while (v37 > v38);
      }
      ++y;
    }
    while (v42 > y);
  }
  v39 = 10 * v41;
  do
  {
    v30[v39 - 10] = (unint64_t)&off_1E2EB7668;
    v40 = (CI::Object *)v30[v39 - 9];
    if (v40)
      CI::Object::unref(v40);
    v39 -= 10;
  }
  while (v39 * 8);
}

void sub_1921FF9CC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  CI::Object *v6;

  v5 = 80 * *(_QWORD *)(v3 - 144);
  while (1)
  {
    *(_QWORD *)(v1 + v5 - 80) = v2;
    v6 = *(CI::Object **)(v1 + v5 - 72);
    if (v6)
      CI::Object::unref(v6);
    v5 -= 80;
    if (!v5)
      _Unwind_Resume(exception_object);
  }
}

uint64_t CI::DAGHelper::add_function_with_name(uint64_t this, char *a2)
{
  uint64_t v2;
  uint64_t v3;
  void **v4;
  uint64_t (***v5)(_QWORD, __int128 *);
  __int128 v6;
  void *v7;
  void *__p[2];
  char v9;

  if (*(_QWORD *)(this + 40))
  {
    v2 = this;
    v3 = this + 160;
    std::string::basic_string[abi:nn180100]<0>(__p, a2);
    v4 = std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::find<std::string>(v3, __p);
    if (v9 < 0)
      operator delete(__p[0]);
    v5 = *(uint64_t (****)(_QWORD, __int128 *))(v2 + 8);
    v6 = *(_OWORD *)(v4 + 7);
    v7 = v4[9];
    return (**v5)(v5, &v6);
  }
  return this;
}

void sub_1921FFA84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void **CI::SerialValArray<int>::append(void **result, int a2)
{
  void **v3;
  int v4;
  int v5;
  int v6;
  _DWORD *v7;

  v3 = result;
  v4 = *(_DWORD *)result;
  v5 = *((_DWORD *)result + 1);
  if (*(_DWORD *)result >= v5)
  {
    v6 = *((_DWORD *)result + 2) + v5;
    *((_DWORD *)result + 1) = v6;
    result = (void **)malloc_type_realloc(result[2], 4 * (v6 - 10), 0x100004052888210uLL);
    v3[2] = result;
    v4 = *(_DWORD *)v3;
  }
  if (v4 > 9)
    v7 = (char *)v3[2] + 4 * (v4 - 10);
  else
    v7 = (_DWORD *)v3 + v4 + 6;
  *v7 = a2;
  ++*(_DWORD *)v3;
  return result;
}

uint64_t CI::SerialObjectPtrArray::append(uint64_t this, CI::Object *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  _QWORD *v7;

  v3 = this;
  v4 = *(_DWORD *)this;
  v5 = *(_DWORD *)(this + 4);
  if (*(_DWORD *)this >= v5)
  {
    v6 = *(_DWORD *)(this + 8) + v5;
    *(_DWORD *)(this + 4) = v6;
    this = (uint64_t)malloc_type_realloc(*(void **)(this + 16), 8 * (v6 - 10), 0x2004093837F09uLL);
    *(_QWORD *)(v3 + 16) = this;
    v4 = *(_DWORD *)v3;
  }
  if (v4 > 9)
    v7 = (_QWORD *)(*(_QWORD *)(v3 + 16) + 8 * (v4 - 10));
  else
    v7 = (_QWORD *)(v3 + 8 * v4 + 24);
  *v7 = a2;
  if (a2)
  {
    this = CI::Object::ref((uint64_t)a2);
    v4 = *(_DWORD *)v3;
  }
  *(_DWORD *)v3 = v4 + 1;
  return this;
}

uint64_t CI::DAGHelper::add_arguments_for_image_node@<X0>(_QWORD *a1@<X0>, CI::Node *a2@<X1>, int a3@<W2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  CI::TextureSampler *v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void **v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  unint64_t v21;
  void **v22;
  uint64_t v23;
  void **v24;
  uint64_t v25;
  uint64_t v26;
  CI::Vector *v27;
  uint64_t result;
  char v29;
  __n64 v30;

  ++a1[6];
  v12 = (CI::TextureSampler *)operator new();
  CI::TextureSampler::TextureSampler(v12, a2, a3);
  v13 = (void **)a1[5];
  if (v13)
  {
    v14 = *(int *)v13;
    CI::SerialValArray<int>::append(v13, a4);
  }
  else
  {
    v14 = 0;
  }
  *(_QWORD *)a6 = v14;
  CI::SerialObjectPtrArray::append(a5, v12);
  if (a4 != 2)
    goto LABEL_20;
  v15 = a1[7];
  a1[7] = v15 + 1;
  *(_QWORD *)(a6 + 8) = v15;
  v16 = (void **)a1[5];
  if (v16)
  {
    v17 = *(int *)v16;
    CI::SerialValArray<int>::append(v16, 40);
  }
  else
  {
    v17 = 0;
  }
  *(_QWORD *)(a6 + 16) = v17;
  CI::SerialObjectPtrArray::append(a5, v12);
  v18 = (*(uint64_t (**)(CI::Node *))(*(_QWORD *)a2 + 16))(a2);
  v19 = *(_QWORD *)a2;
  if (v18 == 46)
  {
    v20 = (*(uint64_t (**)(CI::Node *))(v19 + 208))(a2);
    CI::SurfaceNode::chroma_scale_fix((IOSurfaceRef *)a2);
  }
  else
  {
    if ((*(unsigned int (**)(CI::Node *))(v19 + 16))(a2) != 44)
      goto LABEL_20;
    v20 = (*(uint64_t (**)(CI::Node *))(*(_QWORD *)a2 + 208))(a2);
    CI::ProviderNode::chroma_scale_fix(a2);
  }
  if (v20 >= 2)
  {
    v30.n64_u64[0] = v21;
    v22 = (void **)a1[5];
    if (v22)
    {
      v23 = *(int *)v22;
      CI::SerialValArray<int>::append(v22, 3);
    }
    else
    {
      v23 = 0;
    }
    *(_QWORD *)(a6 + 24) = v23;
    CI::SerialObjectPtrArray::append(a5, v12);
    v24 = (void **)a1[5];
    v25 = a1[7];
    ++a1[6];
    a1[7] = v25 + 1;
    *(_QWORD *)(a6 + 32) = v25;
    if (v24)
    {
      v26 = *(int *)v24;
      CI::SerialValArray<int>::append(v24, 6);
    }
    else
    {
      v26 = 0;
    }
    *(_QWORD *)(a6 + 40) = v26;
    v27 = (CI::Vector *)operator new();
    CI::Vector::Vector(v27, v30, v30.n64_f32[1]);
    CI::SerialObjectPtrArray::append(a5, v27);
    CI::Object::unref(v27);
  }
LABEL_20:
  CI::Object::unref(v12);
  result = (*(uint64_t (**)(CI::Node *))(*(_QWORD *)a2 + 16))(a2);
  if ((_DWORD)result == 52)
    v29 = *((_BYTE *)a2 + 144) & 1;
  else
    v29 = 0;
  *(_BYTE *)(a6 + 48) = v29;
  return result;
}

void sub_1921FFE04(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x1081C40C4ADF1D2);
  _Unwind_Resume(a1);
}

uint64_t *CI::DAGHelper::add_init_destcoord_function_info(uint64_t *this)
{
  uint64_t v1;
  uint64_t argument_info;
  unsigned int v3;

  if (this[5])
  {
    v1 = (uint64_t)this;
    argument_info = CI::SoftwareDAGDescriptor::create_argument_info((CI::SoftwareDAGDescriptor *)this[1], 1);
    v3 = argument_info;
    CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 8) + 64) + 32 * argument_info), 4, 0);
    return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(v1 + 8), v3);
  }
  return this;
}

uint64_t CI::SoftwareDAGDescriptor::create_argument_info(CI::SoftwareDAGDescriptor *this, uint64_t a2)
{
  char *v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  void *v18[5];

  v6 = *((_QWORD *)this + 10);
  v4 = (char *)this + 80;
  v5 = v6;
  v7 = (_QWORD *)*((_QWORD *)v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    v9 = (uint64_t *)(v4 - 16);
    v10 = *((_QWORD *)v4 - 2);
    v11 = ((uint64_t)v7 - v10) >> 5;
    v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 59)
      abort();
    v13 = v5 - v10;
    if (v13 >> 4 > v12)
      v12 = v13 >> 4;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFE0)
      v14 = 0x7FFFFFFFFFFFFFFLL;
    else
      v14 = v12;
    v18[4] = v4;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>((uint64_t)v4, v14);
    else
      v15 = 0;
    v16 = &v15[32 * v11];
    v18[0] = v15;
    v18[1] = v16;
    v18[3] = &v15[32 * v14];
    *(_QWORD *)v16 = a2;
    *((_QWORD *)v16 + 1) = 0;
    *((_QWORD *)v16 + 2) = 0;
    *((_QWORD *)v16 + 3) = 0;
    v18[2] = v16 + 32;
    std::vector<CI::SoftwareDAGDescriptor::ArgumentInfo>::__swap_out_circular_buffer(v9, v18);
    v8 = (_QWORD *)*((_QWORD *)this + 9);
    std::__split_buffer<CI::SoftwareDAGDescriptor::ArgumentInfo>::~__split_buffer(v18);
  }
  else
  {
    *v7 = a2;
    v7[1] = 0;
    v7[2] = 0;
    v7[3] = 0;
    v8 = v7 + 4;
    *((_QWORD *)this + 9) = v7 + 4;
  }
  *((_QWORD *)this + 9) = v8;
  return (((uint64_t)v8 - *((_QWORD *)this + 8)) >> 5) - 1;
}

void sub_1921FFF98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CI::SoftwareDAGDescriptor::ArgumentInfo>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t CI::SoftwareDAGDescriptor::ArgumentInfo::add(_QWORD *a1, int a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int64x2_t v54;
  uint64_t v55;
  uint64_t v56;
  int64x2_t v57;
  uint64_t v58;
  _QWORD *v59;

  switch(a2)
  {
    case 0:
    case 1:
    case 2:
      result = (uint64_t)(a1 + 3);
      v6 = a1[3];
      v7 = a1[2];
      if (v7 >= v6)
      {
        v8 = a1[1];
        v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - v8) >> 3);
        v10 = v9 + 1;
        if (v9 + 1 <= 0xAAAAAAAAAAAAAAALL)
        {
          v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - v8) >> 3);
          if (2 * v11 > v10)
            v10 = 2 * v11;
          if (v11 >= 0x555555555555555)
            v12 = 0xAAAAAAAAAAAAAAALL;
          else
            v12 = v10;
          v59 = a1 + 3;
          v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(result, v12);
          v15 = &v13[24 * v9];
          *(_QWORD *)v15 = &off_1E2EB7C38;
          *((_QWORD *)v15 + 1) = a3;
          *((_DWORD *)v15 + 4) = 0;
          v16 = a1[1];
          v17 = a1[2];
          if (v17 != v16)
          {
            v18 = &v13[24 * v9];
            do
            {
              *((_QWORD *)v18 - 3) = &off_1E2EB7C38;
              v18 -= 24;
              v19 = *(_QWORD *)(v17 - 16);
              *((_DWORD *)v18 + 4) = *(_DWORD *)(v17 - 8);
              *((_QWORD *)v18 + 1) = v19;
              v17 -= 24;
            }
            while (v17 != v16);
LABEL_63:
            v54 = *(int64x2_t *)(a1 + 1);
LABEL_65:
            v25 = v15 + 24;
            a1[1] = v18;
            a1[2] = v15 + 24;
            v57 = v54;
            v55 = a1[3];
            a1[3] = &v13[24 * v14];
            v58 = v55;
            v56 = v54.i64[0];
            result = std::__split_buffer<CI::SWRendererFunctionInputNode>::~__split_buffer((uint64_t)&v56);
            goto LABEL_66;
          }
          goto LABEL_64;
        }
LABEL_67:
        abort();
      }
      *(_QWORD *)v7 = &off_1E2EB7C38;
      *(_QWORD *)(v7 + 8) = a3;
      *(_DWORD *)(v7 + 16) = 0;
LABEL_23:
      v25 = (char *)(v7 + 24);
LABEL_66:
      a1[2] = v25;
      return result;
    case 3:
      result = (uint64_t)(a1 + 3);
      v20 = a1[3];
      v7 = a1[2];
      if (v7 < v20)
      {
        *(_QWORD *)v7 = &off_1E2EB7C38;
        *(_QWORD *)(v7 + 8) = a3;
        v21 = 3;
LABEL_22:
        *(_DWORD *)(v7 + 16) = v21;
        goto LABEL_23;
      }
      v26 = a1[1];
      v27 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - v26) >> 3);
      v28 = v27 + 1;
      if (v27 + 1 <= 0xAAAAAAAAAAAAAAALL)
      {
        v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - v26) >> 3);
        if (2 * v29 > v28)
          v28 = 2 * v29;
        if (v29 >= 0x555555555555555)
          v30 = 0xAAAAAAAAAAAAAAALL;
        else
          v30 = v28;
        v59 = a1 + 3;
        v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(result, v30);
        v15 = &v13[24 * v27];
        *(_QWORD *)v15 = &off_1E2EB7C38;
        *((_QWORD *)v15 + 1) = a3;
        *((_DWORD *)v15 + 4) = 3;
        v31 = a1[1];
        v17 = a1[2];
        if (v17 != v31)
        {
          v18 = &v13[24 * v27];
          do
          {
            *((_QWORD *)v18 - 3) = &off_1E2EB7C38;
            v18 -= 24;
            v32 = *(_QWORD *)(v17 - 16);
            *((_DWORD *)v18 + 4) = *(_DWORD *)(v17 - 8);
            *((_QWORD *)v18 + 1) = v32;
            v17 -= 24;
          }
          while (v17 != v31);
          goto LABEL_63;
        }
LABEL_64:
        v54 = vdupq_n_s64(v17);
        v18 = v15;
        goto LABEL_65;
      }
      goto LABEL_67;
    case 4:
      result = (uint64_t)(a1 + 3);
      v22 = a1[3];
      v7 = a1[2];
      if (v7 >= v22)
      {
        v33 = a1[1];
        v34 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - v33) >> 3);
        v35 = v34 + 1;
        if (v34 + 1 <= 0xAAAAAAAAAAAAAAALL)
        {
          v36 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - v33) >> 3);
          if (2 * v36 > v35)
            v35 = 2 * v36;
          if (v36 >= 0x555555555555555)
            v37 = 0xAAAAAAAAAAAAAAALL;
          else
            v37 = v35;
          v59 = a1 + 3;
          v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(result, v37);
          v15 = &v13[24 * v34];
          *(_QWORD *)v15 = &off_1E2EB7C38;
          *((_QWORD *)v15 + 1) = a3;
          *((_DWORD *)v15 + 4) = 4;
          v38 = a1[1];
          v17 = a1[2];
          if (v17 != v38)
          {
            v18 = &v13[24 * v34];
            do
            {
              *((_QWORD *)v18 - 3) = &off_1E2EB7C38;
              v18 -= 24;
              v39 = *(_QWORD *)(v17 - 16);
              *((_DWORD *)v18 + 4) = *(_DWORD *)(v17 - 8);
              *((_QWORD *)v18 + 1) = v39;
              v17 -= 24;
            }
            while (v17 != v38);
            goto LABEL_63;
          }
          goto LABEL_64;
        }
        goto LABEL_67;
      }
      *(_QWORD *)v7 = &off_1E2EB7C38;
      *(_QWORD *)(v7 + 8) = a3;
      v21 = 4;
      goto LABEL_22;
    case 5:
      result = (uint64_t)(a1 + 3);
      v23 = a1[3];
      v7 = a1[2];
      if (v7 >= v23)
      {
        v40 = a1[1];
        v41 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - v40) >> 3);
        v42 = v41 + 1;
        if (v41 + 1 <= 0xAAAAAAAAAAAAAAALL)
        {
          v43 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - v40) >> 3);
          if (2 * v43 > v42)
            v42 = 2 * v43;
          if (v43 >= 0x555555555555555)
            v44 = 0xAAAAAAAAAAAAAAALL;
          else
            v44 = v42;
          v59 = a1 + 3;
          v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(result, v44);
          v15 = &v13[24 * v41];
          *(_QWORD *)v15 = &off_1E2EB7C38;
          *((_QWORD *)v15 + 1) = a3;
          *((_DWORD *)v15 + 4) = 5;
          v45 = a1[1];
          v17 = a1[2];
          if (v17 != v45)
          {
            v18 = &v13[24 * v41];
            do
            {
              *((_QWORD *)v18 - 3) = &off_1E2EB7C38;
              v18 -= 24;
              v46 = *(_QWORD *)(v17 - 16);
              *((_DWORD *)v18 + 4) = *(_DWORD *)(v17 - 8);
              *((_QWORD *)v18 + 1) = v46;
              v17 -= 24;
            }
            while (v17 != v45);
            goto LABEL_63;
          }
          goto LABEL_64;
        }
        goto LABEL_67;
      }
      *(_QWORD *)v7 = &off_1E2EB7C38;
      *(_QWORD *)(v7 + 8) = a3;
      v21 = 5;
      goto LABEL_22;
    case 7:
      result = (uint64_t)(a1 + 3);
      v24 = a1[3];
      v7 = a1[2];
      if (v7 >= v24)
      {
        v47 = a1[1];
        v48 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - v47) >> 3);
        v49 = v48 + 1;
        if (v48 + 1 <= 0xAAAAAAAAAAAAAAALL)
        {
          v50 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - v47) >> 3);
          if (2 * v50 > v49)
            v49 = 2 * v50;
          if (v50 >= 0x555555555555555)
            v51 = 0xAAAAAAAAAAAAAAALL;
          else
            v51 = v49;
          v59 = a1 + 3;
          v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(result, v51);
          v15 = &v13[24 * v48];
          *(_QWORD *)v15 = &off_1E2EB7C38;
          *((_QWORD *)v15 + 1) = 0;
          *((_DWORD *)v15 + 4) = 7;
          v52 = a1[1];
          v17 = a1[2];
          if (v17 != v52)
          {
            v18 = &v13[24 * v48];
            do
            {
              *((_QWORD *)v18 - 3) = &off_1E2EB7C38;
              v18 -= 24;
              v53 = *(_QWORD *)(v17 - 16);
              *((_DWORD *)v18 + 4) = *(_DWORD *)(v17 - 8);
              *((_QWORD *)v18 + 1) = v53;
              v17 -= 24;
            }
            while (v17 != v52);
            goto LABEL_63;
          }
          goto LABEL_64;
        }
        goto LABEL_67;
      }
      *(_QWORD *)v7 = &off_1E2EB7C38;
      *(_QWORD *)(v7 + 8) = 0;
      v21 = 7;
      goto LABEL_22;
    default:
      goto LABEL_67;
  }
}

uint64_t *CI::SoftwareDAGDescriptor::create_function_info(uint64_t *this, unsigned int a2)
{
  uint64_t *v2;
  uint64_t *v3;
  __int128 *v4;
  uint64_t *v5;
  uint64_t *v6;
  __int128 v7;
  uint64_t v8;

  if ((a2 & 0x80000000) == 0)
  {
    v2 = this;
    v3 = (uint64_t *)(this[8] + 32 * a2 + 8);
    v6 = v3;
    v4 = (__int128 *)(this + 11);
    v5 = (uint64_t *)this[3];
    if ((unint64_t)v5 >= this[4])
    {
      this = (uint64_t *)std::vector<CI::SWRendererFunctionNode>::__emplace_back_slow_path<CI::SWFunction &,std::vector<CI::SWRendererFunctionInputNode> *&>(this + 2, v4, &v6);
    }
    else
    {
      v7 = *v4;
      v8 = this[13];
      CI::SWRendererFunctionNode::SWRendererFunctionNode(v5, (uint64_t)&v7, v3);
      this = v5 + 9;
      v2[3] = (uint64_t)(v5 + 9);
    }
    v2[3] = (uint64_t)this;
  }
  return this;
}

void sub_192200500(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 24) = v2;
  _Unwind_Resume(a1);
}

uint64_t *CI::DAGHelper::add_read_pixel_function_info(uint64_t *this, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t argument_info;

  if (this[5])
  {
    v8 = (uint64_t)this;
    argument_info = CI::SoftwareDAGDescriptor::create_argument_info((CI::SoftwareDAGDescriptor *)this[1], 3);
    CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 64) + 32 * argument_info), 0, a2);
    CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 64) + 32 * argument_info), 4, a5);
    CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 8) + 64) + 32 * argument_info), 5, a4);
    return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(v8 + 8), argument_info);
  }
  return this;
}

uint64_t *CI::DAGHelper::add_read_pixel_420_function_info(uint64_t *this, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8)
{
  uint64_t v13;
  uint64_t argument_info;

  if (this[5])
  {
    v13 = (uint64_t)this;
    argument_info = CI::SoftwareDAGDescriptor::create_argument_info((CI::SoftwareDAGDescriptor *)this[1], 5);
    CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v13 + 8) + 64) + 32 * argument_info), 0, a2);
    CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v13 + 8) + 64) + 32 * argument_info), 4, a5);
    CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v13 + 8) + 64) + 32 * argument_info), 0, a6);
    CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v13 + 8) + 64) + 32 * argument_info), 4, a8);
    CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v13 + 8) + 64) + 32 * argument_info), 5, a4);
    return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(v13 + 8), argument_info);
  }
  return this;
}

uint64_t *CI::DAGHelper::add_colour_inout_function_info(uint64_t *this, uint64_t a2)
{
  uint64_t v3;
  uint64_t argument_info;
  unsigned int v5;

  if (this[5])
  {
    v3 = (uint64_t)this;
    argument_info = CI::SoftwareDAGDescriptor::create_argument_info((CI::SoftwareDAGDescriptor *)this[1], 1);
    v5 = argument_info;
    CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 64) + 32 * argument_info), 5, a2);
    return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(v3 + 8), v5);
  }
  return this;
}

uint64_t *CI::DAGHelper::add_write_pixel_function_info(uint64_t *this, uint64_t a2)
{
  uint64_t v3;
  uint64_t argument_info;

  if (this[5])
  {
    v3 = (uint64_t)this;
    argument_info = CI::SoftwareDAGDescriptor::create_argument_info((CI::SoftwareDAGDescriptor *)this[1], 3);
    CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 64) + 32 * argument_info), 2, 0);
    CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 64) + 32 * argument_info), 5, a2);
    CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 8) + 64) + 32 * argument_info), 7, 0);
    return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(v3 + 8), argument_info);
  }
  return this;
}

uint64_t *CI::DAGHelper::add_function_info(uint64_t a1, uint64_t a2, CI::ColorKernelNode *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  int v9;
  int argument_info;
  signed int v11;
  uint64_t v12;
  signed int v13;
  int v14;
  int v15;
  _QWORD *v16;
  int v17;
  uint64_t v18;
  CI::Object *argument;
  void **v20;
  uint64_t v21;
  void **v22;
  uint64_t v23;

  v8 = *((_QWORD *)a3 + 6);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8) != 62)
    (*(void (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
  if (*(_BYTE *)(v8 + 12))
    v9 = CI::KernelArguments::count((CI::KernelArguments *)(v8 + 144));
  else
    v9 = *(_DWORD *)(v8 + 20);
  if (*(_QWORD *)(a1 + 40))
    argument_info = CI::SoftwareDAGDescriptor::create_argument_info(*(CI::SoftwareDAGDescriptor **)(a1 + 8), v9);
  else
    argument_info = -1;
  v11 = 0;
  v12 = argument_info;
  while (1)
  {
    v13 = *(_BYTE *)(v8 + 12) ? CI::KernelArguments::count((CI::KernelArguments *)(v8 + 144)) : *(_DWORD *)(v8 + 20);
    if (v11 >= v13)
      return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(a1 + 8), v12);
    v14 = CI::ColorKernelNode::kernel_argument_type(a3, v11);
    v15 = v14;
    switch(v14)
    {
      case 30:
        if (*(_QWORD *)(a1 + 40))
        {
          v16 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * v12);
          v17 = 5;
          v18 = a5;
          goto LABEL_36;
        }
        goto LABEL_37;
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
        goto LABEL_19;
      case 36:
        if (!*(_QWORD *)(a1 + 40))
          goto LABEL_37;
        v16 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * v12);
        v17 = 4;
LABEL_30:
        v18 = 0;
        goto LABEL_36;
      case 37:
        v22 = *(void ***)(a1 + 40);
        if (v22)
        {
          v23 = *(int *)v22;
          CI::SerialValArray<int>::append(v22, 37);
          if (*(_QWORD *)(a1 + 40))
            CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * v12), 4, v23);
        }
        if (a4)
          CI::SerialObjectPtrArray::append(a4, *(CI::Object **)(a4 + 24));
        goto LABEL_37;
      case 38:
        v16 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * v12);
        v17 = 2;
        goto LABEL_30;
      case 39:
        if (*(_BYTE *)(v8 + 166))
        {
          v18 = *(_QWORD *)(a1 + 48);
          *(_QWORD *)(a1 + 48) = v18 + 1;
        }
        else
        {
          v18 = 0;
        }
        if (!*(_QWORD *)(a1 + 40))
          goto LABEL_37;
        v16 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * v12);
        v17 = 2;
        goto LABEL_36;
      default:
        if ((v14 - 1) < 2 || v14 == 4)
          goto LABEL_37;
LABEL_19:
        CI::KernelArguments::is_uniform(v14);
        argument = (CI::Object *)CI::ColorKernelNode::get_argument(a3, v11);
        CI::SerialObjectPtrArray::append(a4, argument);
        v20 = *(void ***)(a1 + 40);
        if (!v20)
          goto LABEL_37;
        v21 = *(int *)v20;
        CI::SerialValArray<int>::append(v20, v15);
        if (!*(_QWORD *)(a1 + 40))
          goto LABEL_37;
        v16 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * v12);
        v17 = 4;
        v18 = v21;
LABEL_36:
        CI::SoftwareDAGDescriptor::ArgumentInfo::add(v16, v17, v18);
LABEL_37:
        ++v11;
        break;
    }
  }
}

uint64_t *CI::DAGHelper::add_function_info(uint64_t a1, CI::SerialStringArray **a2, CI::ColorKernelNode *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9, _QWORD *a10)
{
  uint64_t v15;
  int v16;
  int argument_info;
  signed int v18;
  int v19;
  signed int v20;
  int v21;
  int v22;
  _QWORD *v23;
  int v24;
  uint64_t v25;
  uint64_t argument;
  CI::Node *v27;
  uint64_t **v28;
  void **v29;
  uint64_t v30;
  uint64_t IndexOfString;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  unint64_t v37;
  BOOL v38;
  _QWORD *v39;
  uint64_t *v40;
  uint64_t *v41;
  CI::Object *v42;
  void **v43;
  uint64_t v44;
  std::string *v45;
  unint64_t v46;
  unint64_t v47;
  std::string::size_type size;
  std::string *v49;
  std::string::size_type v50;
  uint64_t v51;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t *v56;
  void (***v57)(_QWORD, std::string *);
  uint64_t v59;
  uint64_t v61;
  uint64_t v63;
  uint64_t v65;
  _QWORD *v66;
  int v67;
  uint64_t **v68;
  int v69[2];
  uint64_t *v70;
  std::string v71;
  void *__p[3];
  char v73;
  uint64_t *v74[2];

  v15 = *((_QWORD *)a3 + 6);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v15 + 16))(v15) != 62)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 16))(v15);
  if (*(_BYTE *)(v15 + 12))
    v16 = CI::KernelArguments::count((CI::KernelArguments *)(v15 + 144));
  else
    v16 = *(_DWORD *)(v15 + 20);
  if (*(_QWORD *)(a1 + 40))
    argument_info = CI::SoftwareDAGDescriptor::create_argument_info(*(CI::SoftwareDAGDescriptor **)(a1 + 8), v16);
  else
    argument_info = -1;
  v18 = 0;
  v19 = 0;
  v68 = (uint64_t **)(a1 + 88);
  v65 = a6 + 1;
  v66 = (_QWORD *)(a1 + 96);
  v63 = a1 + 112;
  *(_QWORD *)v69 = argument_info;
  v61 = a6 + 2;
  v59 = a6 + a8 + 3;
  while (1)
  {
    v20 = *(_BYTE *)(v15 + 12) ? CI::KernelArguments::count((CI::KernelArguments *)(v15 + 144)) : *(_DWORD *)(v15 + 20);
    if (v18 >= v20)
      break;
    v21 = CI::ColorKernelNode::kernel_argument_type(a3, v18);
    v22 = v21;
    if (v21 > 29)
    {
      switch(v21)
      {
        case 30:
          if (!*(_QWORD *)(a1 + 40))
            goto LABEL_82;
          v23 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v69);
          v24 = 5;
          v25 = a5;
          goto LABEL_57;
        case 36:
          if (!*(_QWORD *)(a1 + 40))
            goto LABEL_82;
          v23 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v69);
          v24 = 4;
          goto LABEL_33;
        case 37:
          v29 = *(void ***)(a1 + 40);
          if (v29)
          {
            v30 = *(int *)v29;
            CI::SerialValArray<int>::append(v29, 37);
            if (*(_QWORD *)(a1 + 40))
              CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v69), 4, v30);
          }
          if (a4)
            CI::SerialObjectPtrArray::append(a4, *(CI::Object **)(a4 + 24));
          goto LABEL_82;
        case 38:
          if (!*(_QWORD *)(a1 + 40))
            goto LABEL_82;
          v23 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v69);
          v24 = 2;
LABEL_33:
          v25 = 0;
          break;
        case 39:
          goto LABEL_82;
        default:
          goto LABEL_54;
      }
      goto LABEL_57;
    }
    switch(v21)
    {
      case 1:
        goto LABEL_21;
      case 2:
        break;
      case 4:
LABEL_21:
        argument = CI::ColorKernelNode::get_argument(a3, v18);
        v27 = (CI::Node *)argument;
        if (v22 == 4)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)argument + 232))(argument);
          CI::Node::rois_count(v27);
          v74[0] = 0;
          v74[0] = (uint64_t *)CI::hash_image_node_id((uint64_t)v27, 0);
          v71.__r_.__value_.__r.__words[0] = (std::string::size_type)v74;
          v28 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)(a1 + 136), (unint64_t *)v74, (uint64_t)&std::piecewise_construct, &v71);
          if (*(_QWORD *)(a1 + 40))
            CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v69), 0, (uint64_t)v28[5]);
        }
        else
        {
          *(_BYTE *)(a8 + v65) = v19 + 48;
          *(_BYTE *)(a8 + v61) = 0;
          IndexOfString = CI::SerialStringArray::firstIndexOfString(a2[7], (const char *)(a8 + 1));
          if ((_DWORD)IndexOfString != -1)
            v27 = (CI::Node *)(*((uint64_t (**)(CI::SerialStringArray **, uint64_t))*a2 + 6))(a2, IndexOfString);
          v67 = v19;
          v32 = (uint64_t *)CI::hash_dag_node_id((unint64_t)v27, a7, (char *)a8);
          if ((*(unsigned int (**)(CI::Node *))(*(_QWORD *)v27 + 232))(v27))
          {
            v33 = v59;
            do
            {
              v27 = (CI::Node *)(*(uint64_t (**)(CI::Node *, _QWORD))(*(_QWORD *)v27 + 48))(v27, 0);
              *(_WORD *)(v33 - 1) = 48;
              v34 = CI::SerialStringArray::firstIndexOfString(a2[7], (const char *)(a8 + 1));
              if ((_DWORD)v34 != -1)
                v27 = (CI::Node *)(*((uint64_t (**)(CI::SerialStringArray **, uint64_t))*a2 + 6))(a2, v34);
              v32 = (uint64_t *)CI::hash_dag_node_id((unint64_t)v27, (uint64_t)v32, (char *)a8);
              ++v33;
            }
            while (((*(uint64_t (**)(CI::Node *))(*(_QWORD *)v27 + 232))(v27) & 1) != 0);
          }
          v35 = (_QWORD *)*v66;
          v19 = v67;
          if (!*v66)
            goto LABEL_52;
          v36 = (_QWORD *)(a1 + 96);
          do
          {
            v37 = v35[4];
            v38 = v37 >= (unint64_t)v32;
            if (v37 >= (unint64_t)v32)
              v39 = v35;
            else
              v39 = v35 + 1;
            if (v38)
              v36 = v35;
            v35 = (_QWORD *)*v39;
          }
          while (*v39);
          if (v36 == v66 || (unint64_t)v32 < v36[4])
          {
LABEL_52:
            v70 = v32;
            v74[0] = (uint64_t *)&v70;
            v40 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v63, (unint64_t *)&v70, (uint64_t)&std::piecewise_construct, v74);
            v41 = v40;
            if (*((char *)v40 + 63) < 0)
              std::string::__init_copy_ctor_external(&v71, (const std::string::value_type *)v40[5], v40[6]);
            else
              v71 = *(std::string *)(v40 + 5);
            std::vector<unsigned long>::vector(__p, (uint64_t)(v41 + 8));
            v73 = *((_BYTE *)v41 + 88);
            if ((v71.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v45 = &v71;
            else
              v45 = (std::string *)v71.__r_.__value_.__r.__words[0];
            CI::DAGHelper::add_function_with_name(a1, (char *)v45);
            size = HIBYTE(v71.__r_.__value_.__r.__words[2]);
            if ((v71.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              size = v71.__r_.__value_.__l.__size_;
            if (size != 14)
              goto LABEL_71;
            v49 = &v71;
            if ((v71.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v49 = (std::string *)v71.__r_.__value_.__r.__words[0];
            v50 = v49->__r_.__value_.__r.__words[0];
            v51 = *(std::string::size_type *)((char *)v49->__r_.__value_.__r.__words + 6);
            if (v50 == 0x646165725F69635FLL && v51 == 0x6C657869705F6461)
              CI::DAGHelper::add_read_pixel_function_info((uint64_t *)a1, *(_QWORD *)__p[0], v46, *((_QWORD *)__p[0] + 2), *((_QWORD *)__p[0] + 3));
            else
LABEL_71:
              CI::DAGHelper::add_read_pixel_420_function_info((uint64_t *)a1, *(_QWORD *)__p[0], v46, *((_QWORD *)__p[0] + 2), *((_QWORD *)__p[0] + 3), *((_QWORD *)__p[0] + 4), v47, *((_QWORD *)__p[0] + 6));
            v53 = (*a10)++;
            v70 = v32;
            v74[0] = (uint64_t *)&v70;
            *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v68, (unint64_t *)&v70, (uint64_t)&std::piecewise_construct, v74)+ 20) = v53;
            if (v73)
            {
              CI::DAGHelper::add_function_with_name(a1, "_ci_srgb_to_linear");
              v70 = v32;
              v74[0] = (uint64_t *)&v70;
              v54 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v68, (unint64_t *)&v70, (uint64_t)&std::piecewise_construct, v74);
              CI::DAGHelper::add_colour_inout_function_info((uint64_t *)a1, *((unsigned __int16 *)v54 + 20));
              v55 = (*a10)++;
              v70 = v32;
              v74[0] = (uint64_t *)&v70;
              *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v68, (unint64_t *)&v70, (uint64_t)&std::piecewise_construct, v74)+ 20) = v55;
            }
            v74[0] = v32;
            std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__erase_unique<unsigned long long>(v63, (unint64_t *)v74);
            v19 = v67;
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
            if (SHIBYTE(v71.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v71.__r_.__value_.__l.__data_);
          }
          v74[0] = v32;
          v71.__r_.__value_.__r.__words[0] = (std::string::size_type)v74;
          v56 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v68, (unint64_t *)v74, (uint64_t)&std::piecewise_construct, (uint64_t **)&v71);
          if (*(_QWORD *)(a1 + 40))
            CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v69), 5, *((unsigned __int16 *)v56 + a9 + 20));
          *(_BYTE *)(a8 + v65) = 0;
        }
        ++v19;
        break;
      default:
LABEL_54:
        CI::KernelArguments::is_uniform(v21);
        v42 = (CI::Object *)CI::ColorKernelNode::get_argument(a3, v18);
        CI::SerialObjectPtrArray::append(a4, v42);
        v43 = *(void ***)(a1 + 40);
        if (v43)
        {
          v44 = *(int *)v43;
          CI::SerialValArray<int>::append(v43, v22);
          if (*(_QWORD *)(a1 + 40))
          {
            v23 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v69);
            v24 = 4;
            v25 = v44;
LABEL_57:
            CI::SoftwareDAGDescriptor::ArgumentInfo::add(v23, v24, v25);
          }
        }
        break;
    }
LABEL_82:
    ++v18;
  }
  if (*(_QWORD *)(a1 + 40))
  {
    v57 = *(void (****)(_QWORD, std::string *))(a1 + 8);
    v71 = *(std::string *)(v15 + 48);
    (**v57)(v57, &v71);
  }
  return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(a1 + 8), v69[0]);
}

void sub_192201140(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  CI::DAGHelper::TextureReadFunction::~TextureReadFunction((CI::DAGHelper::TextureReadFunction *)&__p);
  _Unwind_Resume(a1);
}

void CI::DAGHelper::TextureReadFunction::~TextureReadFunction(CI::DAGHelper::TextureReadFunction *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
  if (*((char *)this + 23) < 0)
    operator delete(*(void **)this);
}

uint64_t *CI::DAGHelper::add_function_info(CI::SoftwareDAGDescriptor **this, const CI::ProgramNode *a2, const CI::GeneralKernelNode *a3, CI::Object **a4, uint64_t a5, unint64_t a6)
{
  uint64_t v8;
  int v9;
  int argument_info;
  unint64_t v11;
  int v12;
  uint64_t v13;
  int type;
  uint64_t v15;
  CI::Object **v16;
  void **v17;
  uint64_t v18;
  void **v19;
  uint64_t v20;
  uint64_t v21;
  double **v22;
  double *v23;
  size_t v24;
  unint64_t v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  const char *v43;
  CI::Object *v44;
  double v45;
  signed int v46;
  void **v47;
  uint64_t v48;
  CI::SoftwareDAGDescriptor *v49;
  uint64_t v50;
  void **v51;
  uint64_t v52;
  unint64_t sampler_builder_function_info;
  int v58[2];
  int v59[2];
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67[8];

  v67[6] = *(double *)MEMORY[0x1E0C80C00];
  v8 = *((_QWORD *)a3 + 6);
  (*(void (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
  if (*(_BYTE *)(v8 + 12))
    v9 = CI::KernelArguments::count((CI::KernelArguments *)(v8 + 144));
  else
    v9 = *(_DWORD *)(v8 + 20);
  if (this[5])
    argument_info = CI::SoftwareDAGDescriptor::create_argument_info(this[1], v9);
  else
    argument_info = -1;
  v11 = 0;
  *(_QWORD *)v58 = argument_info;
  *(_QWORD *)v59 = 0;
  while (1)
  {
    v12 = *(_BYTE *)(v8 + 12) ? CI::KernelArguments::count((CI::KernelArguments *)(v8 + 144)) : *(_DWORD *)(v8 + 20);
    if ((uint64_t)v11 >= v12)
      return CI::SoftwareDAGDescriptor::create_function_info((uint64_t *)this[1], v58[0]);
    v13 = *((_QWORD *)a3 + 6);
    if (*(_BYTE *)(v13 + 12))
    {
      type = CI::KernelArguments::get_type((CI::KernelArguments *)(v13 + 144), v11);
    }
    else
    {
      if ((uint64_t)v11 >= *(int *)(v13 + 20))
      {
        type = 0;
LABEL_25:
        CI::KernelArguments::is_uniform(type);
        v15 = *((_QWORD *)a3 + 7);
        if (v11 > 9)
          v16 = (CI::Object **)(*(_QWORD *)(v15 + 16) + 8 * (v11 - 10));
        else
          v16 = (CI::Object **)(v15 + 8 * v11 + 24);
        CI::SerialObjectPtrArray::append((uint64_t)a4, *v16);
        v17 = (void **)this[5];
        if (v17)
        {
          v18 = *(int *)v17;
          CI::SerialValArray<int>::append(v17, type);
          if (this[5])
            CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*((_QWORD *)this[1] + 8) + 32 * *(_QWORD *)v58), 4, v18);
        }
        goto LABEL_70;
      }
      type = *(_DWORD *)(*(_QWORD *)(v13 + 72) + 4 * v11);
    }
    if (type > 29)
    {
      switch(type)
      {
        case 30:
          if (this[5])
            CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*((_QWORD *)this[1] + 8) + 32 * *(_QWORD *)v58), 5, a5);
          break;
        case 36:
          if (this[5])
            CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*((_QWORD *)this[1] + 8) + 32 * *(_QWORD *)v58), 4, 0);
          break;
        case 37:
          v19 = (void **)this[5];
          if (v19)
          {
            v20 = *(int *)v19;
            CI::SerialValArray<int>::append(v19, 37);
            if (this[5])
              CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*((_QWORD *)this[1] + 8) + 32 * *(_QWORD *)v58), 4, v20);
          }
          if (a4)
            CI::SerialObjectPtrArray::append((uint64_t)a4, a4[3]);
          break;
        case 38:
          if (this[5])
            CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*((_QWORD *)this[1] + 8) + 32 * *(_QWORD *)v58), 2, 0);
          break;
        case 39:
          goto LABEL_70;
        default:
          goto LABEL_25;
      }
      goto LABEL_70;
    }
    if (type == 1)
      goto LABEL_70;
    if (type != 2)
    {
      if (type == 4)
        goto LABEL_70;
      goto LABEL_25;
    }
    v21 = *((_QWORD *)a3 + 7);
    if (v11 > 9)
      v22 = (double **)(*(_QWORD *)(v21 + 16) + 8 * (v11 - 10));
    else
      v22 = (double **)(v21 + 8 * v11 + 24);
    v23 = *v22;
    v62 = 0.0;
    v63 = 0.0;
    v61 = 1.0;
    v64 = 1.0;
    v65 = 0.0;
    v66 = 0.0;
    v24 = CI::ProgramNode::child_depth(a2, v59[0]);
    if (v24 - 1 > a6)
    {
      v25 = ~a6 + v24;
      do
      {
        if ((*(unsigned int (**)(double *))(*(_QWORD *)v23 + 16))(v23) == 28)
        {
          v26 = v23[7];
          v27 = v23[8];
          v28 = v27 * v63 + v26 * v61;
          v29 = v27 * v64 + v26 * v62;
          v30 = v23[9];
          v31 = v23[10];
          v32 = v63 * v31 + v30 * v61;
          v33 = v64 * v31 + v30 * v62;
          v34 = v23[11];
          v35 = v23[12];
          v36 = v65 + v63 * v35 + v34 * v61;
          v37 = v64 * v35 + v34 * v62 + v66;
          v61 = v28;
          v62 = v29;
          v63 = v32;
          v64 = v33;
          v65 = v36;
          v66 = v37;
        }
        else
        {
          v38 = (*(uint64_t (**)(double *))(*(_QWORD *)v23 + 16))(v23);
          v39 = *(_QWORD *)v23;
          if (v38 == 45)
          {
            (*(void (**)(double *))(v39 + 408))(v23);
          }
          else if ((*(unsigned int (**)(double *))(v39 + 16))(v23) != 30)
          {
            (*(void (**)(double *))(*(_QWORD *)v23 + 16))(v23);
          }
        }
        v23 = (double *)(*(uint64_t (**)(double *, _QWORD))(*(_QWORD *)v23 + 48))(v23, 0);
        --v25;
      }
      while (v25);
    }
    v40 = (*(uint64_t (**)(const CI::ProgramNode *, int *))(*(_QWORD *)a2 + 48))(a2, *(int **)v59);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v40 + 16))(v40) == 52)
    {
      v41 = *(unsigned int *)(v40 + 140);
      v42 = *(_BYTE *)(v40 + 144);
      v67[0] = *(double *)(v40 + 145);
      *(_DWORD *)((char *)v67 + 7) = *(_DWORD *)(v40 + 152);
      if ((v42 & 1) != 0)
      {
        if (CI_INTERMEDIATE_SRGB_TEXTURES()
          && (*(unsigned int (**)(CI::SoftwareDAGDescriptor *, uint64_t, uint64_t))(*(_QWORD *)this[2] + 584))(this[2], v41, 1))
        {
          *(_DWORD *)(v40 + 140) = v41;
          *(_BYTE *)(v40 + 144) = v42 | 4;
          *(double *)(v40 + 145) = v67[0];
          *(_DWORD *)(v40 + 152) = *(_DWORD *)((char *)v67 + 7);
        }
        else
        {
          v43 = CI::name_for_format(v41);
          x_log("Cannot use sRGB texture binding with format %s for sampler %d in kernel '%s'.\n", v43, v11, *(const char **)(v8 + 24));
        }
      }
    }
    v44 = (CI::Object *)operator new();
    v45 = CI::Affine::inverse((CI::Affine *)&v61, v67);
    CI::TextureSampler::TextureSampler(v44, v40, v45);
    if (this[5])
    {
      v46 = CI::SoftwareDAGDescriptor::create_argument_info(this[1], 2);
      v47 = (void **)this[5];
      if (v47)
      {
        v48 = *(int *)v47;
        CI::SerialValArray<int>::append(v47, 2);
        v49 = this[5];
        this[6] = (CI::SoftwareDAGDescriptor *)((char *)this[6] + 1);
        v50 = v46;
        if (v49)
          CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*((_QWORD *)this[1] + 8) + 32 * v46), 1, v48);
        goto LABEL_64;
      }
    }
    else
    {
      v46 = -1;
    }
    this[6] = (CI::SoftwareDAGDescriptor *)((char *)this[6] + 1);
    v50 = v46;
LABEL_64:
    this[7] = (CI::SoftwareDAGDescriptor *)((char *)this[7] + 1);
    CI::SerialObjectPtrArray::append((uint64_t)a4, v44);
    v51 = (void **)this[5];
    if (v51)
    {
      v52 = *(int *)v51;
      CI::SerialValArray<int>::append(v51, 41);
      if (this[5])
        CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*((_QWORD *)this[1] + 8) + 32 * v50), 4, v52);
    }
    CI::SerialObjectPtrArray::append((uint64_t)a4, v44);
    sampler_builder_function_info = CI::SoftwareDAGDescriptor::create_sampler_builder_function_info(this[1], v46);
    if (this[5])
      CI::SoftwareDAGDescriptor::ArgumentInfo::add_sampler_builder_output((CI::SoftwareDAGDescriptor::ArgumentInfo *)(*((_QWORD *)this[1] + 8) + 32 * *(_QWORD *)v58), sampler_builder_function_info);
    CI::Object::unref(v44);
    *(_QWORD *)v59 = (v59[0] + 1);
LABEL_70:
    ++v11;
  }
}

void sub_192201824(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10A1C40000A9EE4);
  _Unwind_Resume(a1);
}

uint64_t x_log(const char *a1, ...)
{
  va_list va;

  va_start(va, a1);
  return vfprintf((FILE *)*MEMORY[0x1E0C80C10], a1, va);
}

double CI::Affine::inverse@<D0>(CI::Affine *this@<X0>, double *a2@<X8>)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double result;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;

  v3 = *((double *)this + 1);
  v4 = *((double *)this + 2);
  v5 = *((double *)this + 3);
  v6 = *(double *)this * v5 - v3 * v4;
  if (fabs(v6) >= 1.0e-10)
  {
    v8 = 1.0 / v6;
    v9 = v5 * v8;
    v10 = *(double *)this * v8;
    v12 = *((double *)this + 4);
    v11 = *((double *)this + 5);
    *a2 = v9;
    a2[1] = v8 * -v3;
    a2[2] = -(v4 * v8);
    a2[3] = v10;
    result = v3 * v8 * v12 - v10 * v11;
    a2[4] = v4 * v8 * v11 - v9 * v12;
    a2[5] = result;
  }
  else
  {
    x_log("Singular matrix cannot be inverted!\n");
    result = 0.0;
    *((_OWORD *)a2 + 1) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)a2 = 0u;
  }
  return result;
}

unint64_t CI::SoftwareDAGDescriptor::create_sampler_builder_function_info(CI::SoftwareDAGDescriptor *this, unsigned int a2)
{
  uint64_t *v3;
  __int128 *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v8;
  __int128 v9;
  uint64_t v10;

  if ((a2 & 0x80000000) != 0)
    return 0;
  v3 = (uint64_t *)(*((_QWORD *)this + 8) + 32 * a2 + 8);
  v8 = v3;
  v4 = (__int128 *)((char *)this + 112);
  v5 = (uint64_t *)*((_QWORD *)this + 6);
  if ((unint64_t)v5 >= *((_QWORD *)this + 7))
  {
    v6 = std::vector<CI::SWRendererFunctionNode>::__emplace_back_slow_path<CI::SWFunction const&,std::vector<CI::SWRendererFunctionInputNode> *&>((uint64_t *)this + 5, v4, &v8);
  }
  else
  {
    v9 = *v4;
    v10 = *((_QWORD *)this + 16);
    CI::SWRendererFunctionNode::SWRendererFunctionNode(v5, (uint64_t)&v9, v3);
    v6 = (uint64_t)(v5 + 9);
    *((_QWORD *)this + 6) = v5 + 9;
  }
  *((_QWORD *)this + 6) = v6;
  return 0x8E38E38E38E38E39 * ((v6 - *((_QWORD *)this + 5)) >> 3) - 1;
}

void sub_1922019DC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 48) = v2;
  _Unwind_Resume(a1);
}

uint64_t *CI::DAGHelper::add_function_info(uint64_t a1, CI::SerialStringArray **a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, char *a8, unsigned __int8 a9, _QWORD *a10)
{
  uint64_t v15;
  int v16;
  int argument_info;
  unint64_t v18;
  int v19;
  uint64_t v20;
  int type;
  uint64_t v22;
  CI::Node **v23;
  uint64_t v24;
  CI::Object **v25;
  void **v26;
  uint64_t v27;
  void **v28;
  uint64_t v29;
  uint64_t v30;
  double **v31;
  CI::Node *v32;
  uint64_t **v33;
  unint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  BOOL v39;
  _QWORD *v40;
  uint64_t *v41;
  uint64_t *v42;
  double *v43;
  size_t v44;
  unint64_t v45;
  double v46;
  double v47;
  double v48;
  std::string::size_type v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char v62;
  std::string *v63;
  unint64_t v64;
  unint64_t v65;
  std::string::size_type size;
  std::string *v67;
  std::string::size_type v68;
  uint64_t v69;
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t *v74;
  const char *v75;
  CI::Object *v76;
  double v77;
  signed int v78;
  void **v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  void **v83;
  uint64_t v84;
  unint64_t sampler_builder_function_info;
  void (***v86)(_QWORD, std::string *);
  uint64_t v88;
  uint64_t v90;
  uint64_t v92;
  unint64_t v93;
  _QWORD *v94;
  uint64_t **v95;
  CI::SerialObjectPtrArray *v96;
  int v97[2];
  CI::KernelArguments *v98;
  int v99[2];
  char *__s2;
  unint64_t v102;
  std::string v103;
  void *v104;
  double v105;
  double v106;
  char v107;
  _BYTE v108[44];
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  v15 = *(_QWORD *)(a3 + 48);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v15 + 16))(v15) != 64)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 16))(v15);
  if (*(_BYTE *)(v15 + 12))
    v16 = CI::KernelArguments::count((CI::KernelArguments *)(v15 + 144));
  else
    v16 = *(_DWORD *)(v15 + 20);
  if (*(_QWORD *)(a1 + 40))
    argument_info = CI::SoftwareDAGDescriptor::create_argument_info(*(CI::SoftwareDAGDescriptor **)(a1 + 8), v16);
  else
    argument_info = -1;
  v18 = 0;
  v98 = (CI::KernelArguments *)(v15 + 144);
  *(_QWORD *)v99 = 0;
  *(_QWORD *)v97 = argument_info;
  __s2 = a8 + 1;
  v95 = (uint64_t **)(a1 + 88);
  v96 = (CI::SerialObjectPtrArray *)a4;
  v93 = a6 + 1;
  v94 = (_QWORD *)(a1 + 96);
  v92 = a1 + 112;
  v88 = a7;
  v90 = v15;
  while (1)
  {
    v19 = *(_BYTE *)(v15 + 12) ? CI::KernelArguments::count(v98) : *(_DWORD *)(v15 + 20);
    if ((uint64_t)v18 >= v19)
      break;
    v20 = *(_QWORD *)(a3 + 48);
    if (*(_BYTE *)(v20 + 12))
    {
      type = CI::KernelArguments::get_type((CI::KernelArguments *)(v20 + 144), v18);
    }
    else
    {
      if ((uint64_t)v18 >= *(int *)(v20 + 20))
      {
        type = 0;
LABEL_28:
        CI::KernelArguments::is_uniform(type);
        v24 = *(_QWORD *)(a3 + 56);
        if (v18 > 9)
          v25 = (CI::Object **)(*(_QWORD *)(v24 + 16) + 8 * (v18 - 10));
        else
          v25 = (CI::Object **)(v24 + 8 * v18 + 24);
        CI::SerialObjectPtrArray::append(a4, *v25);
        v26 = *(void ***)(a1 + 40);
        if (v26)
        {
          v27 = *(int *)v26;
          CI::SerialValArray<int>::append(v26, type);
          if (*(_QWORD *)(a1 + 40))
            CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v97), 4, v27);
        }
        goto LABEL_122;
      }
      type = *(_DWORD *)(*(_QWORD *)(v20 + 72) + 4 * v18);
    }
    if (type > 29)
    {
      switch(type)
      {
        case 30:
          if (*(_QWORD *)(a1 + 40))
            CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v97), 5, a5);
          break;
        case 36:
          if (*(_QWORD *)(a1 + 40))
            CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v97), 4, 0);
          break;
        case 37:
          v28 = *(void ***)(a1 + 40);
          if (v28)
          {
            v29 = *(int *)v28;
            CI::SerialValArray<int>::append(v28, 37);
            if (*(_QWORD *)(a1 + 40))
              CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v97), 4, v29);
          }
          if (a4)
            CI::SerialObjectPtrArray::append(a4, *(CI::Object **)(a4 + 24));
          break;
        case 38:
          if (*(_QWORD *)(a1 + 40))
            CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v97), 2, 0);
          break;
        case 39:
          goto LABEL_122;
        default:
          goto LABEL_28;
      }
      goto LABEL_122;
    }
    if (type == 1)
      goto LABEL_25;
    if (type != 2)
    {
      if (type != 4)
        goto LABEL_28;
LABEL_25:
      v22 = *(_QWORD *)(a3 + 56);
      if (v18 > 9)
        v23 = (CI::Node **)(*(_QWORD *)(v22 + 16) + 8 * (v18 - 10));
      else
        v23 = (CI::Node **)(v22 + 8 * v18 + 24);
      v32 = *v23;
      if (type == 4)
      {
        (*(void (**)(CI::Node *))(*(_QWORD *)v32 + 232))(v32);
        CI::Node::rois_count(v32);
        *(_QWORD *)v108 = 0;
        *(_QWORD *)v108 = CI::hash_image_node_id((uint64_t)v32, 0);
        v103.__r_.__value_.__r.__words[0] = (std::string::size_type)v108;
        v33 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)(a1 + 136), (unint64_t *)v108, (uint64_t)&std::piecewise_construct, &v103);
        if (*(_QWORD *)(a1 + 40))
          CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v97), 0, (uint64_t)v33[5]);
      }
      else
      {
        a8[v93] = LOBYTE(v99[0]) + 48;
        a8[a6 + 2] = 0;
        if (CI::SerialStringArray::firstIndexOfString(a2[7], __s2) != -1)
          v32 = (CI::Node *)(*((uint64_t (**)(CI::SerialStringArray **))*a2 + 6))(a2);
        v34 = CI::hash_dag_node_id((unint64_t)v32, a7, a8);
        if ((*(unsigned int (**)(CI::Node *))(*(_QWORD *)v32 + 232))(v32))
        {
          v35 = (uint64_t)&a8[a6 + 3];
          do
          {
            v32 = (CI::Node *)(*(uint64_t (**)(CI::Node *, _QWORD))(*(_QWORD *)v32 + 48))(v32, 0);
            *(_WORD *)(v35 - 1) = 48;
            if (CI::SerialStringArray::firstIndexOfString(a2[7], __s2) != -1)
              v32 = (CI::Node *)(*((uint64_t (**)(CI::SerialStringArray **))*a2 + 6))(a2);
            v34 = CI::hash_dag_node_id((unint64_t)v32, v34, a8);
            ++v35;
          }
          while (((*(uint64_t (**)(CI::Node *))(*(_QWORD *)v32 + 232))(v32) & 1) != 0);
        }
        v36 = (_QWORD *)*v94;
        if (!*v94)
          goto LABEL_67;
        v37 = (_QWORD *)(a1 + 96);
        do
        {
          v38 = v36[4];
          v39 = v38 >= v34;
          if (v38 >= v34)
            v40 = v36;
          else
            v40 = v36 + 1;
          if (v39)
            v37 = v36;
          v36 = (_QWORD *)*v40;
        }
        while (*v40);
        if (v37 == v94 || v34 < v37[4])
        {
LABEL_67:
          v102 = v34;
          *(_QWORD *)v108 = &v102;
          v41 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v92, &v102, (uint64_t)&std::piecewise_construct, (_QWORD **)v108);
          v42 = v41;
          if (*((char *)v41 + 63) < 0)
            std::string::__init_copy_ctor_external(&v103, (const std::string::value_type *)v41[5], v41[6]);
          else
            v103 = *(std::string *)(v41 + 5);
          std::vector<unsigned long>::vector(&v104, (uint64_t)(v42 + 8));
          v107 = *((_BYTE *)v42 + 88);
          if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v63 = &v103;
          else
            v63 = (std::string *)v103.__r_.__value_.__r.__words[0];
          CI::DAGHelper::add_function_with_name(a1, (char *)v63);
          size = HIBYTE(v103.__r_.__value_.__r.__words[2]);
          if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            size = v103.__r_.__value_.__l.__size_;
          if (size != 14)
            goto LABEL_97;
          v67 = &v103;
          if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v67 = (std::string *)v103.__r_.__value_.__r.__words[0];
          v68 = v67->__r_.__value_.__r.__words[0];
          v69 = *(std::string::size_type *)((char *)v67->__r_.__value_.__r.__words + 6);
          if (v68 == 0x646165725F69635FLL && v69 == 0x6C657869705F6461)
            CI::DAGHelper::add_read_pixel_function_info((uint64_t *)a1, *(_QWORD *)v104, v64, *((_QWORD *)v104 + 2), *((_QWORD *)v104 + 3));
          else
LABEL_97:
            CI::DAGHelper::add_read_pixel_420_function_info((uint64_t *)a1, *(_QWORD *)v104, v64, *((_QWORD *)v104 + 2), *((_QWORD *)v104 + 3), *((_QWORD *)v104 + 4), v65, *((_QWORD *)v104 + 6));
          v71 = (*a10)++;
          v102 = v34;
          *(_QWORD *)v108 = &v102;
          *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v95, &v102, (uint64_t)&std::piecewise_construct, (uint64_t **)v108)+ 20) = v71;
          if (v107)
          {
            CI::DAGHelper::add_function_with_name(a1, "_ci_srgb_to_linear");
            v102 = v34;
            *(_QWORD *)v108 = &v102;
            v72 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v95, &v102, (uint64_t)&std::piecewise_construct, (uint64_t **)v108);
            CI::DAGHelper::add_colour_inout_function_info((uint64_t *)a1, *((unsigned __int16 *)v72 + 20));
            v73 = (*a10)++;
            v102 = v34;
            *(_QWORD *)v108 = &v102;
            *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v95, &v102, (uint64_t)&std::piecewise_construct, (uint64_t **)v108)+ 20) = v73;
          }
          *(_QWORD *)v108 = v34;
          std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__erase_unique<unsigned long long>(v92, (unint64_t *)v108);
          if (*(double *)&v104 != 0.0)
          {
            v105 = *(double *)&v104;
            operator delete(v104);
          }
          if (SHIBYTE(v103.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v103.__r_.__value_.__l.__data_);
        }
        *(_QWORD *)v108 = v34;
        v103.__r_.__value_.__r.__words[0] = (std::string::size_type)v108;
        v74 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v95, (unint64_t *)v108, (uint64_t)&std::piecewise_construct, (uint64_t **)&v103);
        if (*(_QWORD *)(a1 + 40))
          CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v97), 5, *((unsigned __int16 *)v74 + a9 + 20));
        a8[v93] = 0;
      }
      *(_QWORD *)v99 = (v99[0] + 1);
      goto LABEL_122;
    }
    v30 = *(_QWORD *)(a3 + 56);
    if (v18 > 9)
      v31 = (double **)(*(_QWORD *)(v30 + 16) + 8 * (v18 - 10));
    else
      v31 = (double **)(v30 + 8 * v18 + 24);
    v43 = *v31;
    v103.__r_.__value_.__r.__words[2] = 0;
    *(_OWORD *)&v103.__r_.__value_.__l.__data_ = 0x3FF0000000000000uLL;
    *(double *)&v104 = 1.0;
    v105 = 0.0;
    v106 = 0.0;
    v44 = CI::ProgramNode::child_depth((CI::ProgramNode *)a2, v99[0]);
    if (v44 - 1 > a6)
    {
      v45 = ~a6 + v44;
      do
      {
        if ((*(unsigned int (**)(double *))(*(_QWORD *)v43 + 16))(v43) == 28)
        {
          v46 = v43[7];
          v47 = v43[8];
          v48 = v47 * *(double *)&v103.__r_.__value_.__r.__words[2] + v46 * *(double *)&v103.__r_.__value_.__l.__data_;
          *(double *)&v49 = v47 * *(double *)&v104 + v46 * *(double *)&v103.__r_.__value_.__l.__size_;
          v50 = v43[9];
          v51 = v43[10];
          v52 = *(double *)&v103.__r_.__value_.__r.__words[2] * v51 + v50 * *(double *)&v103.__r_.__value_.__l.__data_;
          v53 = *(double *)&v104 * v51 + v50 * *(double *)&v103.__r_.__value_.__l.__size_;
          v54 = v43[11];
          v55 = v43[12];
          v56 = v105
              + *(double *)&v103.__r_.__value_.__r.__words[2] * v55
              + v54 * *(double *)&v103.__r_.__value_.__l.__data_;
          v57 = *(double *)&v104 * v55 + v54 * *(double *)&v103.__r_.__value_.__l.__size_ + v106;
          *(double *)&v103.__r_.__value_.__l.__data_ = v48;
          v103.__r_.__value_.__l.__size_ = v49;
          *(double *)&v103.__r_.__value_.__r.__words[2] = v52;
          *(double *)&v104 = v53;
          v105 = v56;
          v106 = v57;
        }
        else
        {
          v58 = (*(uint64_t (**)(double *))(*(_QWORD *)v43 + 16))(v43);
          v59 = *(_QWORD *)v43;
          if (v58 == 45)
          {
            (*(void (**)(double *))(v59 + 408))(v43);
          }
          else if ((*(unsigned int (**)(double *))(v59 + 16))(v43) != 30)
          {
            (*(void (**)(double *))(*(_QWORD *)v43 + 16))(v43);
          }
        }
        v43 = (double *)(*(uint64_t (**)(double *, _QWORD))(*(_QWORD *)v43 + 48))(v43, 0);
        --v45;
      }
      while (v45);
    }
    v60 = (*((uint64_t (**)(CI::SerialStringArray **, int *))*a2 + 6))(a2, *(int **)v99);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v60 + 16))(v60) == 52)
    {
      v61 = *(unsigned int *)(v60 + 140);
      v62 = *(_BYTE *)(v60 + 144);
      *(_QWORD *)v108 = *(_QWORD *)(v60 + 145);
      *(_DWORD *)&v108[7] = *(_DWORD *)(v60 + 152);
      if ((v62 & 1) != 0)
      {
        if (CI_INTERMEDIATE_SRGB_TEXTURES()
          && (*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 16) + 584))(*(_QWORD *)(a1 + 16), v61, 1))
        {
          *(_DWORD *)(v60 + 140) = v61;
          *(_BYTE *)(v60 + 144) = v62 | 4;
          *(_QWORD *)(v60 + 145) = *(_QWORD *)v108;
          *(_DWORD *)(v60 + 152) = *(_DWORD *)&v108[7];
        }
        else
        {
          v75 = CI::name_for_format(v61);
          x_log("Cannot use sRGB texture binding with format %s for sampler %d in kernel '%s'.\n", v75, v18, *(const char **)(v90 + 24));
        }
      }
      a7 = v88;
    }
    v76 = (CI::Object *)operator new();
    v77 = CI::Affine::inverse((CI::Affine *)&v103, (double *)v108);
    CI::TextureSampler::TextureSampler(v76, v60, v77);
    if (*(_QWORD *)(a1 + 40))
    {
      v78 = CI::SoftwareDAGDescriptor::create_argument_info(*(CI::SoftwareDAGDescriptor **)(a1 + 8), 2);
      v79 = *(void ***)(a1 + 40);
      if (v79)
      {
        v80 = *(int *)v79;
        CI::SerialValArray<int>::append(v79, 2);
        v81 = *(_QWORD *)(a1 + 40);
        ++*(_QWORD *)(a1 + 48);
        v82 = v78;
        if (v81)
          CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * v78), 1, v80);
        goto LABEL_116;
      }
    }
    else
    {
      v78 = -1;
    }
    ++*(_QWORD *)(a1 + 48);
    v82 = v78;
LABEL_116:
    ++*(_QWORD *)(a1 + 56);
    CI::SerialObjectPtrArray::append((uint64_t)v96, v76);
    v83 = *(void ***)(a1 + 40);
    if (v83)
    {
      v84 = *(int *)v83;
      CI::SerialValArray<int>::append(v83, 41);
      if (*(_QWORD *)(a1 + 40))
        CI::SoftwareDAGDescriptor::ArgumentInfo::add((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * v82), 4, v84);
    }
    CI::SerialObjectPtrArray::append((uint64_t)v96, v76);
    sampler_builder_function_info = CI::SoftwareDAGDescriptor::create_sampler_builder_function_info(*(CI::SoftwareDAGDescriptor **)(a1 + 8), v78);
    if (*(_QWORD *)(a1 + 40))
      CI::SoftwareDAGDescriptor::ArgumentInfo::add_sampler_builder_output((CI::SoftwareDAGDescriptor::ArgumentInfo *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) + 32 * *(_QWORD *)v97), sampler_builder_function_info);
    CI::Object::unref(v76);
    *(_QWORD *)v99 = (v99[0] + 1);
    v15 = v90;
    a4 = (uint64_t)v96;
LABEL_122:
    ++v18;
  }
  if (*(_QWORD *)(a1 + 40))
  {
    v86 = *(void (****)(_QWORD, std::string *))(a1 + 8);
    v103 = *(std::string *)(v15 + 48);
    (**v86)(v86, &v103);
  }
  return CI::SoftwareDAGDescriptor::create_function_info(*(uint64_t **)(a1 + 8), v97[0]);
}

void sub_192202564(_Unwind_Exception *a1)
{
  uint64_t v1;

  CI::DAGHelper::TextureReadFunction::~TextureReadFunction((CI::DAGHelper::TextureReadFunction *)(v1 - 208));
  _Unwind_Resume(a1);
}

uint64_t CI::DAGHelper::color_output_for_kernel(CI::DAGHelper *this, const CI::Kernel *a2, unint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  unint64_t v10;
  uint64_t v12;

  v12 = 0;
  if (*((_DWORD *)a2 + 4))
  {
    v4 = *((_QWORD *)a2 + 16);
    v5 = *((_QWORD *)a2 + 17);
    v6 = (*a3)++;
    if (v4 == 2 && v5 == 2)
    {
      for (i = 0; i != 4; ++i)
      {
        CI::DAGHelper::add_function_with_name((uint64_t)this, CI::DAGHelper::color_output_for_kernel(CI::Kernel const*,unsigned long &)::sGroupOutputFunctions[i]);
        CI::DAGHelper::add_colour_inout_function_info((uint64_t *)this, v6);
        v10 = (*a3)++;
        *((_WORD *)&v12 + i) = v10;
      }
    }
    else
    {
      LOWORD(v12) = v6;
    }
  }
  return v12;
}

uint64_t CI::DAGHelper::build_dag(CI::DAGHelper *this, const CI::Node *a2, const CI::ProgramNode *a3, CI::SerialObjectPtrArray *a4, uint64_t a5)
{
  NSObject *v10;
  os_signpost_id_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  char *v15;
  uint64_t v16;
  std::string *v17;
  unint64_t v18;
  unint64_t v19;
  std::string::size_type size;
  std::string *v21;
  std::string::size_type v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t **v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  std::string v32;
  void *__p[3];
  char v34;
  unint64_t v35;
  _QWORD v36[10];
  _QWORD v37[6];
  _QWORD v38[7];
  _QWORD v39[10];
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t (*v43)(uint64_t, uint64_t);
  uint64_t (*v44)();
  const char *v45;
  uint64_t v46;
  _QWORD v47[9];
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  uint8_t buf[71];
  unint64_t *v53;

  if (CI_VERBOSE_SIGNPOSTS())
  {
    v10 = ci_signpost_log_render();
    v11 = *((int *)a3 + 9) | (unint64_t)((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 272))(*((_QWORD *)this + 2)) << 32);
    if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v10))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v10, OS_SIGNPOST_INTERVAL_BEGIN, v11, "build_dag", (const char *)&unk_192520C83, buf, 2u);
    }
  }
  v12 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 272))(*((_QWORD *)this + 2));
  TimerBase::TimerBase((uint64_t)buf, v12, *((_DWORD *)a3 + 9), (uint64_t)"build_dag", 5);
  v48 = 0;
  v49 = &v48;
  v50 = 0x2020000000;
  v51 = a5 + 1;
  v13 = MEMORY[0x1E0C809B0];
  v47[0] = MEMORY[0x1E0C809B0];
  v47[1] = 3221225472;
  v47[2] = ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke;
  v47[3] = &unk_1E2EC2A78;
  v47[6] = a5;
  v47[7] = a3;
  v47[8] = a4;
  v47[4] = &v48;
  v47[5] = this;
  CI::ProgramNode::traverse_dag_preorder((uint64_t)a3, (unint64_t)a2, (uint64_t)v47, (uint64_t)&__block_literal_global);
  v40 = 0;
  v41 = &v40;
  v42 = 0x3812000000;
  v43 = __Block_byref_object_copy_;
  v44 = __Block_byref_object_dispose_;
  v45 = "";
  v46 = 0;
  if (*((_BYTE *)a3 + 136))
  {
    v39[0] = v13;
    v39[1] = 3221225472;
    v39[2] = ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_21;
    v39[3] = &unk_1E2EC2AC0;
    v39[6] = this;
    v39[7] = a5;
    v39[8] = a3;
    v39[9] = a4;
    v39[4] = &v48;
    v39[5] = &v40;
    CI::ProgramNode::traverse_dag_preorder((uint64_t)a3, (unint64_t)a2, (uint64_t)v39, 0);
  }
  else
  {
    v38[0] = v13;
    v38[1] = 3221225472;
    v38[2] = ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_2_22;
    v38[3] = &__block_descriptor_56_e33_v60__0_v8r_v16i24i28_v32Q40_48i56l;
    v38[4] = this;
    v38[5] = a3;
    v38[6] = a4;
    CI::ProgramNode::traverse_dag_preorder((uint64_t)a3, (unint64_t)a2, (uint64_t)v38, (uint64_t)&__block_literal_global_24);
    v37[0] = v13;
    v37[1] = 3221225472;
    v37[2] = ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_4;
    v37[3] = &__block_descriptor_48_e33_v60__0_v8r_v16i24i28_v32Q40_48i56l;
    v37[4] = this;
    v37[5] = a5;
    CI::ProgramNode::traverse_dag_preorder((uint64_t)a3, (unint64_t)a2, (uint64_t)v37, (uint64_t)&__block_literal_global_28);
  }
  v36[0] = v13;
  v36[1] = 3221225472;
  v36[2] = ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_6;
  v36[3] = &unk_1E2EC2AC0;
  v36[6] = this;
  v36[7] = a5;
  v36[8] = a3;
  v36[9] = a4;
  v36[4] = &v48;
  v36[5] = &v40;
  CI::ProgramNode::traverse_dag((uint64_t)a3, (unint64_t)a2, (uint64_t)v36, (uint64_t)&__block_literal_global_29);
  v14 = v41;
  if (!*((_WORD *)v41 + 24) && *((_QWORD *)this + 16))
  {
    v15 = (char *)this + 112;
    v16 = *((_QWORD *)this + 14);
    v35 = *(_QWORD *)(v16 + 32);
    if (*(char *)(v16 + 63) < 0)
      std::string::__init_copy_ctor_external(&v32, *(const std::string::value_type **)(v16 + 40), *(_QWORD *)(v16 + 48));
    else
      v32 = *(std::string *)(v16 + 40);
    std::vector<unsigned long>::vector(__p, v16 + 64);
    v34 = *(_BYTE *)(v16 + 88);
    if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v17 = &v32;
    else
      v17 = (std::string *)v32.__r_.__value_.__r.__words[0];
    CI::DAGHelper::add_function_with_name((uint64_t)this, (char *)v17);
    size = HIBYTE(v32.__r_.__value_.__r.__words[2]);
    if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = v32.__r_.__value_.__l.__size_;
    if (size != 14)
      goto LABEL_25;
    v21 = &v32;
    if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v21 = (std::string *)v32.__r_.__value_.__r.__words[0];
    v22 = v21->__r_.__value_.__r.__words[0];
    v23 = *(std::string::size_type *)((char *)v21->__r_.__value_.__r.__words + 6);
    if (v22 == 0x646165725F69635FLL && v23 == 0x6C657869705F6461)
      CI::DAGHelper::add_read_pixel_function_info((uint64_t *)this, *(_QWORD *)__p[0], v18, *((_QWORD *)__p[0] + 2), *((_QWORD *)__p[0] + 3));
    else
LABEL_25:
      CI::DAGHelper::add_read_pixel_420_function_info((uint64_t *)this, *(_QWORD *)__p[0], v18, *((_QWORD *)__p[0] + 2), *((_QWORD *)__p[0] + 3), *((_QWORD *)__p[0] + 4), v19, *((_QWORD *)__p[0] + 6));
    v25 = v49[3];
    v49[3] = v25 + 1;
    v26 = (uint64_t **)((char *)this + 88);
    v53 = &v35;
    *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)this + 11, &v35, (uint64_t)&std::piecewise_construct, (uint64_t **)&v53)+ 20) = v25;
    if (v34)
    {
      CI::DAGHelper::add_function_with_name((uint64_t)this, "_ci_srgb_to_linear");
      v53 = &v35;
      v27 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)this + 11, &v35, (uint64_t)&std::piecewise_construct, (uint64_t **)&v53);
      CI::DAGHelper::add_colour_inout_function_info((uint64_t *)this, *((unsigned __int16 *)v27 + 20));
      v28 = v49[3];
      v49[3] = v28 + 1;
      v53 = &v35;
      *((_WORD *)std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v26, &v35, (uint64_t)&std::piecewise_construct, (uint64_t **)&v53)+ 20) = v28;
    }
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__erase_unique<unsigned long long>((uint64_t)v15, &v35);
    v53 = &v35;
    v29 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v26, &v35, (uint64_t)&std::piecewise_construct, (uint64_t **)&v53);
    v41[6] = v29[5];
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v32.__r_.__value_.__l.__data_);
    v14 = v41;
  }
  v30 = v14[6];
  _Block_object_dispose(&v40, 8);
  _Block_object_dispose(&v48, 8);
  CI::DAGHelper::build_dag(CI::Node const*,CI::ProgramNode const*,CI::SerialObjectPtrArray *,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)buf);
  return v30;
}

void sub_192202B8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54)
{
  uint64_t v54;

  _Block_object_dispose(&a54, 8);
  _Block_object_dispose((const void *)(v54 - 192), 8);
  CI::DAGHelper::build_dag(CI::Node const*,CI::ProgramNode const*,CI::SerialObjectPtrArray *,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)(v54 - 160));
  _Unwind_Resume(a1);
}

void ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke(_QWORD *a1, CI::Object *this, int a3, int a4, int a5, unint64_t a6, uint64_t a7, char *a8, int a9)
{
  uint64_t v14;
  uint64_t v15;
  CI::ColorKernelNode *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  void (***v21)(_QWORD, __int128 *);
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  CI::Object *v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;

  if (a9 == -1)
  {
    v14 = a1[5];
    v27 = this;
    v28 = 0;
    if (this)
      CI::Object::ref((uint64_t)this);
    v15 = (*(uint64_t (**)(CI::Object *, _QWORD))(*(_QWORD *)this + 320))(this, *(_QWORD *)(v14 + 16));
    v28 = v15;
    if (v15)
      v16 = (CI::ColorKernelNode *)v15;
    else
      v16 = v27;
    if ((*(unsigned int (**)(CI::ColorKernelNode *))(*(_QWORD *)v16 + 16))(v16) == 50)
    {
      v18 = *((_QWORD *)v16 + 6);
      if (a6)
      {
        v26 = CI::hash_dag_node_id(a6, a7, 0);
        *(_QWORD *)&v29 = &v26;
        v19 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v14 + 64), &v26, (uint64_t)&std::piecewise_construct, (uint64_t **)&v29)+ 5;
      }
      else
      {
        v19 = a1 + 6;
      }
      v20 = *v19;
      if (*(_QWORD *)(v14 + 40))
      {
        v21 = *(void (****)(_QWORD, __int128 *))(v14 + 8);
        v29 = *(_OWORD *)(v18 + 48);
        v30 = *(_QWORD *)(v18 + 64);
        (**v21)(v21, &v29);
      }
      CI::DAGHelper::add_function_info(v14, v17, v16, a1[8], v20);
      v22 = CI::hash_dag_node_id((unint64_t)this, a7, a8);
      v23 = CI::hash_dag_node_id((unint64_t)this, v22, 0);
      v24 = *(_QWORD *)(a1[4] + 8);
      v25 = *(_QWORD *)(v24 + 24);
      *(_QWORD *)(v24 + 24) = v25 + 1;
      v26 = v23;
      *(_QWORD *)&v29 = &v26;
      std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v14 + 64), &v26, (uint64_t)&std::piecewise_construct, (uint64_t **)&v29)[5] = v25;
    }
    CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)&v27);
  }
}

void sub_192202D94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 232))(a2) ^ 1;
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  return result;
}

uint64_t ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_21(uint64_t result, const CI::GeneralKernelNode *a2, uint64_t a3, int a4, uint64_t a5, unint64_t a6, uint64_t a7, char *a8, int a9)
{
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  void (***v20)(_QWORD, __int128 *);
  uint64_t v21;
  uint64_t **v22;
  unint64_t v23;
  __int128 v24;
  uint64_t v25;

  if (a9 == -1)
  {
    v14 = result;
    v15 = *(_QWORD *)(result + 48);
    result = (*(uint64_t (**)(const CI::GeneralKernelNode *))(*(_QWORD *)a2 + 16))(a2);
    if ((_DWORD)result == 51)
    {
      result = (*(uint64_t (**)(const CI::GeneralKernelNode *))(*(_QWORD *)a2 + 296))(a2);
      if ((result & 1) == 0)
      {
        v16 = CI::hash_dag_node_id((unint64_t)a2, a7, a8);
        v17 = *((_QWORD *)a2 + 6);
        if (a6)
        {
          v23 = CI::hash_dag_node_id(a6, a7, 0);
          *(_QWORD *)&v24 = &v23;
          v18 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v15 + 64), &v23, (uint64_t)&std::piecewise_construct, (uint64_t **)&v24)+ 5;
        }
        else
        {
          v18 = (uint64_t *)(v14 + 56);
        }
        v19 = *v18;
        if (*(_QWORD *)(v15 + 40))
        {
          v20 = *(void (****)(_QWORD, __int128 *))(v15 + 8);
          v24 = *(_OWORD *)(v17 + 48);
          v25 = *(_QWORD *)(v17 + 64);
          (**v20)(v20, &v24);
        }
        CI::DAGHelper::add_function_info((CI::SoftwareDAGDescriptor **)v15, *(const CI::ProgramNode **)(v14 + 64), a2, *(CI::Object ***)(v14 + 72), v19, a4);
        v21 = CI::DAGHelper::color_output_for_kernel((CI::DAGHelper *)v15, (const CI::Kernel *)v17, (unint64_t *)(*(_QWORD *)(*(_QWORD *)(v14 + 32) + 8) + 24));
        v22 = (uint64_t **)(v15 + 88);
        v23 = v16;
        *(_QWORD *)&v24 = &v23;
        std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v22, &v23, (uint64_t)&std::piecewise_construct, (uint64_t **)&v24)[5] = v21;
        v23 = v16;
        *(_QWORD *)&v24 = &v23;
        result = (uint64_t)std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v22, &v23, (uint64_t)&std::piecewise_construct, (uint64_t **)&v24);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v14 + 40) + 8) + 48) = *(_QWORD *)(result + 40);
      }
    }
  }
  return result;
}

double ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_2_22(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v13;
  CI::Node *v14;
  const CI::Node *v15;
  int v16;
  unint64_t v17;
  double result;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  BOOL v22;
  _QWORD *v23;
  uint64_t **v24;
  __int128 v25;
  _OWORD v26[2];
  __int128 v27;
  uint64_t *v28;
  unint64_t v29;
  unint64_t *v30;

  if (a9 != -1)
  {
    v13 = *(_QWORD *)(a1 + 32);
    v14 = (CI::Node *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 48))(*(_QWORD *)(a1 + 40), a9);
    if (a3 && !(*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 192))(a3, a5))
    {
      v15 = 0;
      v16 = 4;
    }
    else
    {
      v15 = (const CI::Node *)a9;
      v16 = 2;
    }
    v17 = CI::hash_image_node_id(a2, v15);
    v29 = v17;
    v19 = *(_QWORD **)(v13 + 144);
    if (!v19)
      goto LABEL_17;
    v20 = (_QWORD *)(v13 + 144);
    do
    {
      v21 = v19[4];
      v22 = v21 >= v17;
      if (v21 >= v17)
        v23 = v19;
      else
        v23 = v19 + 1;
      if (v22)
        v20 = v19;
      v19 = (_QWORD *)*v23;
    }
    while (*v23);
    if (v20 == (_QWORD *)(v13 + 144) || v17 < v20[4])
    {
LABEL_17:
      CI::DAGHelper::add_arguments_for_image_node((_QWORD *)v13, v14, a9, v16, *(_QWORD *)(a1 + 48), (uint64_t)v26);
      v30 = &v29;
      v24 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)(v13 + 136), &v29, (uint64_t)&std::piecewise_construct, &v30);
      v25 = v26[1];
      *(_OWORD *)(v24 + 5) = v26[0];
      *(_OWORD *)(v24 + 7) = v25;
      result = *(double *)&v27;
      *(_OWORD *)(v24 + 9) = v27;
      v24[11] = v28;
    }
  }
  return result;
}

uint64_t ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_3(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 232))(a2) ^ 1;
}

unint64_t ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_4(unint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, char *a8, int a9)
{
  unint64_t v13;
  uint64_t v14;
  void *v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  BOOL v19;
  _QWORD *v20;
  int v21;
  uint64_t v22;
  uint64_t **v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t *v28;
  void *v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t *v35;
  _QWORD *v36;
  uint64_t *v37;
  uint64_t *v38;
  int v39;
  _BOOL4 v40;
  char v41;
  unint64_t v42;
  void *v43;
  void *v44[2];
  char v45;
  std::string v46;
  void *__p;
  void *v48;
  void *v49;
  void *v50;
  _QWORD *v51;
  unint64_t v52;
  _QWORD *v53[2];

  if (a9 != -1)
  {
    v13 = result;
    v14 = *(_QWORD *)(result + 32);
    if (!a3 || (result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 192))(a3, a5), (_DWORD)result))
    {
      result = CI::hash_dag_node_id(a2, a7, a8);
      v15 = (void *)result;
      v16 = *(_QWORD **)(v14 + 96);
      if (!v16)
        goto LABEL_15;
      v17 = (_QWORD *)(v14 + 96);
      do
      {
        v18 = v16[4];
        v19 = v18 >= result;
        if (v18 >= result)
          v20 = v16;
        else
          v20 = v16 + 1;
        if (v19)
          v17 = v16;
        v16 = (_QWORD *)*v20;
      }
      while (*v20);
      if (v17 == (_QWORD *)(v14 + 96) || result < v17[4])
      {
LABEL_15:
        v21 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)a2 + 16))(a2);
        v22 = *(_QWORD *)a2;
        if (v21 != 46)
        {
          if ((*(unsigned int (**)(unint64_t))(v22 + 16))(a2) != 44)
          {
            v39 = 0;
            v40 = 0;
            v42 = 0;
            goto LABEL_20;
          }
          v22 = *(_QWORD *)a2;
        }
        v42 = (*(int (**)(unint64_t))(v22 + 208))(a2);
        v40 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)a2 + 304))(a2) == 1;
        v39 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)a2 + 408))(a2);
LABEL_20:
        v52 = CI::hash_image_node_id(a2, (const CI::Node *)a9);
        v46.__r_.__value_.__r.__words[0] = (std::string::size_type)&v52;
        v23 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t **)(v14 + 136), &v52, (uint64_t)&std::piecewise_construct, &v46);
        v25 = v23[5];
        v24 = v23[6];
        v27 = v23[7];
        v26 = v23[8];
        v28 = v23[10];
        v38 = v23[9];
        v41 = *((_BYTE *)v23 + 88);
        if (a6)
        {
          v29 = (void *)CI::hash_dag_node_id(a6, a7, 0);
          v30 = v14;
          v49 = v29;
          v46.__r_.__value_.__r.__words[0] = (std::string::size_type)&v49;
          v31 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v14 + 64), (unint64_t *)&v49, (uint64_t)&std::piecewise_construct, (uint64_t **)&v46)+ 5;
        }
        else
        {
          v30 = v14;
          v31 = (uint64_t *)(v13 + 40);
        }
        v32 = *v31;
        if (v42 < 2)
        {
          v36 = operator new(0x20uLL);
          v50 = v36 + 4;
          v51 = v36 + 4;
          *v36 = v25;
          v36[1] = v24;
          v36[2] = v32;
          v36[3] = v27;
          v49 = v36;
          std::string::basic_string[abi:nn180100]<0>(v44, "_ci_read_pixel");
          CI::DAGHelper::TextureReadFunction::TextureReadFunction(&v46, (__int128 *)v44, (uint64_t)&v49);
          v34 = v30;
          v43 = v15;
          v53[0] = &v43;
          v37 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v30 + 112, (unint64_t *)&v43, (uint64_t)&std::piecewise_construct, v53);
          CI::DAGHelper::TextureReadFunction::operator=((std::string *)(v37 + 5), &v46);
        }
        else
        {
          v33 = operator new(0x38uLL);
          v50 = v33 + 7;
          v51 = v33 + 7;
          *v33 = v25;
          v33[1] = v24;
          v33[2] = v32;
          v33[3] = v27;
          v33[4] = v26;
          v33[5] = v38;
          v33[6] = v28;
          v49 = v33;
          if ((v40 & v39) == 1)
            std::string::basic_string[abi:nn180100]<0>(v44, "_ci_read_pixel_420_packed");
          else
            std::string::basic_string[abi:nn180100]<0>(v44, "_ci_read_pixel_420");
          v34 = v30;
          CI::DAGHelper::TextureReadFunction::TextureReadFunction(&v46, (__int128 *)v44, (uint64_t)&v49);
          v43 = v15;
          v53[0] = &v43;
          v35 = std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v30 + 112, (unint64_t *)&v43, (uint64_t)&std::piecewise_construct, v53);
          CI::DAGHelper::TextureReadFunction::operator=((std::string *)(v35 + 5), &v46);
        }
        if (__p)
        {
          v48 = __p;
          operator delete(__p);
        }
        if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v46.__r_.__value_.__l.__data_);
        if (v45 < 0)
          operator delete(v44[0]);
        if (v49)
        {
          v50 = v49;
          operator delete(v49);
        }
        v49 = v15;
        v46.__r_.__value_.__r.__words[0] = (std::string::size_type)&v49;
        result = (unint64_t)std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v34 + 112, (unint64_t *)&v49, (uint64_t)&std::piecewise_construct, &v46);
        *(_BYTE *)(result + 88) = v41 & 1;
      }
    }
  }
  return result;
}

void sub_1922034EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28)
{
  if (a19 < 0)
    operator delete(__p);
  if (a27)
    operator delete(a27);
  _Unwind_Resume(exception_object);
}

std::string *CI::DAGHelper::TextureReadFunction::operator=(std::string *a1, const std::string *a2)
{
  std::string::operator=(a1, a2);
  if (a1 != a2)
    std::vector<unsigned long>::__assign_with_size[abi:nn180100]<unsigned long *,unsigned long *>((char *)&a1[1], a2[1].__r_.__value_.__l.__data_, a2[1].__r_.__value_.__l.__size_, (uint64_t)(a2[1].__r_.__value_.__l.__size_ - a2[1].__r_.__value_.__r.__words[0]) >> 3);
  return a1;
}

uint64_t ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_5(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 232))(a2) ^ 1;
}

void ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_6(uint64_t a1, CI::Object *this, int a3, int a4, int a5, unint64_t a6, uint64_t a7, char *a8, int a9)
{
  uint64_t v15;
  uint64_t v16;
  const CI::Kernel *v17;
  uint64_t *v18;
  const CI::Kernel *v19;
  uint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t **v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  CI::ColorKernelNode *v44;
  unint64_t v45;
  CI::Object *v46;
  uint64_t v47;
  unint64_t *v48;

  if (a9 == -1)
  {
    v15 = *(_QWORD *)(a1 + 48);
    v46 = this;
    v47 = 0;
    if (this)
      CI::Object::ref((uint64_t)this);
    v16 = (*(uint64_t (**)(CI::Object *, _QWORD))(*(_QWORD *)this + 320))(this, *(_QWORD *)(v15 + 16));
    v47 = v16;
    if (!v16)
      v16 = (uint64_t)v46;
    v44 = (CI::ColorKernelNode *)v16;
    if ((*(unsigned int (**)(void))(*(_QWORD *)v16 + 16))() == 49)
    {
      v17 = (const CI::Kernel *)*((_QWORD *)v44 + 6);
      if (a6)
      {
        v45 = CI::hash_dag_node_id(a6, a7, 0);
        v48 = &v45;
        v18 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v15 + 64), &v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v48)+ 5;
      }
      else
      {
        v18 = (uint64_t *)(a1 + 56);
      }
      v21 = *v18;
      v22 = CI::hash_dag_node_id((unint64_t)this, a7, a8);
      CI::DAGHelper::add_function_info(v15, *(CI::SerialStringArray ***)(a1 + 64), v44, *(_QWORD *)(a1 + 72), v21, a4, a7, (uint64_t)a8, 0, (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
      v23 = a8;
      v24 = a7;
      v25 = CI::DAGHelper::color_output_for_kernel((CI::DAGHelper *)v15, v17, (unint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
      v26 = (uint64_t)v23;
      v27 = v15;
      v28 = (uint64_t **)(v15 + 88);
      v45 = v22;
      v48 = &v45;
      v29 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v15 + 88), &v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v48);
      v30 = 0;
      v29[5] = v25;
      do
      {
        v31 = v30 + 1;
        if (*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 2 * v30 + 50))
        {
          CI::DAGHelper::add_function_info(v27, *(CI::SerialStringArray ***)(a1 + 64), v44, *(_QWORD *)(a1 + 72), v21, a4, v24, v26, v31, (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
          v45 = v22;
          v48 = &v45;
          v32 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v28, &v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v48);
          v33 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          v34 = *(_QWORD *)(v33 + 24);
          *(_QWORD *)(v33 + 24) = v34 + 1;
          *((_WORD *)v32 + v30 + 21) = v34;
        }
        ++v30;
      }
      while (v31 != 3);
    }
    else
    {
      if ((*(unsigned int (**)(CI::ColorKernelNode *))(*(_QWORD *)v44 + 16))(v44) != 51
        || !(*(unsigned int (**)(CI::ColorKernelNode *))(*(_QWORD *)v44 + 296))(v44))
      {
        goto LABEL_19;
      }
      v19 = (const CI::Kernel *)*((_QWORD *)v44 + 6);
      if (a6)
      {
        v45 = CI::hash_dag_node_id(a6, a7, 0);
        v48 = &v45;
        v20 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v15 + 64), &v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v48)+ 5;
      }
      else
      {
        v20 = (uint64_t *)(a1 + 56);
      }
      v35 = *v20;
      v22 = CI::hash_dag_node_id((unint64_t)this, a7, a8);
      CI::DAGHelper::add_function_info(v15, *(CI::SerialStringArray ***)(a1 + 64), (uint64_t)v44, *(_QWORD *)(a1 + 72), v35, a4, a7, a8, 0, (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
      v43 = a8;
      v36 = CI::DAGHelper::color_output_for_kernel((CI::DAGHelper *)v15, v19, (unint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
      v37 = v15;
      v28 = (uint64_t **)(v15 + 88);
      v45 = v22;
      v48 = &v45;
      v38 = 0;
      std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)(v15 + 88), &v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v48)[5] = v36;
      do
      {
        v39 = v38 + 1;
        if (*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 2 * v38 + 50))
        {
          CI::DAGHelper::add_function_info(v37, *(CI::SerialStringArray ***)(a1 + 64), (uint64_t)v44, *(_QWORD *)(a1 + 72), v35, a4, a7, v43, v39, (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
          v45 = v22;
          v48 = &v45;
          v40 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v28, &v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v48);
          v41 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          v42 = *(_QWORD *)(v41 + 24);
          *(_QWORD *)(v41 + 24) = v42 + 1;
          *((_WORD *)v40 + v38 + 21) = v42;
        }
        ++v38;
      }
      while (v39 != 3);
    }
    v45 = v22;
    v48 = &v45;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48) = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v28, &v45, (uint64_t)&std::piecewise_construct, (uint64_t **)&v48)[5];
LABEL_19:
    CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)&v46);
  }
}

void sub_192203A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2CI9DAGHelper9build_dagEPKNS_4NodeEPKNS_11ProgramNodeEPNS_20SerialObjectPtrArrayEm_block_invoke_7(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 232))(a2) ^ 1;
}

void CI::DAGHelper::build_dag(CI::Node const*,CI::ProgramNode const*,CI::SerialObjectPtrArray *,unsigned long)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  if (CI_VERBOSE_SIGNPOSTS())
  {
    v2 = ci_signpost_log_render();
    v3 = *((_QWORD *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "build_dag", (const char *)&unk_192520C83, v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_192203B40(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::DAGHelper::analyze_kernels(CI::DAGHelper *this, const CI::ProgramNode *a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD v6[10];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  __n128 (*v10)(__n128 *, __n128 *);
  uint64_t (*v11)();
  const char *v12;
  __int128 v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;
  _QWORD v18[3];
  char v19;
  _QWORD v20[3];
  char v21;

  v20[0] = 0;
  v20[1] = v20;
  v20[2] = 0x2020000000;
  v21 = 0;
  v18[0] = 0;
  v18[1] = v18;
  v18[2] = 0x2020000000;
  v19 = 0;
  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = 1;
  v7 = 0;
  v8 = &v7;
  v9 = 0x4012000000;
  v10 = __Block_byref_object_copy__30;
  v11 = __Block_byref_object_dispose__31;
  v12 = "";
  v13 = xmmword_19248E080;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZN2CI9DAGHelper15analyze_kernelsEPKNS_11ProgramNodeE_block_invoke;
  v6[3] = &unk_1E2EC2B48;
  v6[8] = this;
  v6[9] = a2;
  v6[4] = v18;
  v6[5] = v20;
  v6[6] = &v14;
  v6[7] = &v7;
  CI::ProgramNode::traverse_graph_preorder_stoppable((uint64_t)a2, (uint64_t)v6);
  *(_OWORD *)((char *)this + 24) = *((_OWORD *)v8 + 3);
  if (*((_BYTE *)v15 + 24))
  {
    v3 = operator new();
    v4 = 0;
    *(_QWORD *)v3 = &off_1E2EB7C10;
    *(_QWORD *)(v3 + 104) = 0;
    *(_QWORD *)(v3 + 112) = _ci_sampler_builder;
    *(_QWORD *)(v3 + 120) = 0;
    *(_QWORD *)(v3 + 128) = "_ci_sampler_builder";
    *(_OWORD *)(v3 + 8) = 0u;
    *(_OWORD *)(v3 + 24) = 0u;
    *(_OWORD *)(v3 + 40) = 0u;
    *(_OWORD *)(v3 + 56) = 0u;
    *(_OWORD *)(v3 + 72) = 0u;
    *(_OWORD *)(v3 + 88) = 0u;
    *((_QWORD *)this + 1) = v3;
  }
  else
  {
    v4 = 0xFFFFFFFFLL;
  }
  _Block_object_dispose(&v7, 8);
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(v18, 8);
  _Block_object_dispose(v20, 8);
  return v4;
}

void sub_192203D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 128), 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Block_object_dispose((const void *)(v11 - 64), 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__30(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

BOOL ___ZN2CI9DAGHelper15analyze_kernelsEPKNS_11ProgramNodeE_block_invoke(uint64_t a1, CI::Object *this, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _BYTE *v7;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  CI::Object *v18;
  uint64_t v19;

  if ((_DWORD)a6 == -1)
  {
    v9 = *(_QWORD *)(a1 + 64);
    v18 = this;
    v19 = 0;
    if (this)
      CI::Object::ref((uint64_t)this);
    v10 = (*(uint64_t (**)(CI::Object *, _QWORD))(*(_QWORD *)this + 320))(this, *(_QWORD *)(v9 + 16));
    v19 = v10;
    if (v10)
      v11 = (_QWORD *)v10;
    else
      v11 = v18;
    if ((*(unsigned int (**)(_QWORD *))(*v11 + 16))(v11) == 49
      || (*(unsigned int (**)(_QWORD *))(*v11 + 16))(v11) == 50
      || (*(unsigned int (**)(_QWORD *))(*v11 + 16))(v11) == 51)
    {
      v12 = v11[6];
      if (v12)
      {
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12) == 62 && *(_BYTE *)(v12 + 176))
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
        if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 72))(v12))
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 0;
        v13 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
        v14 = *(_QWORD *)(v13 + 48);
        if (v14 <= *(_QWORD *)(v12 + 128))
          v14 = *(_QWORD *)(v12 + 128);
        *(_QWORD *)(v13 + 48) = v14;
        v15 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
        v16 = *(_QWORD *)(v15 + 56);
        if (v16 <= *(_QWORD *)(v12 + 136))
          v16 = *(_QWORD *)(v12 + 136);
        *(_QWORD *)(v15 + 56) = v16;
      }
    }
    CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)&v18);
  }
  else
  {
    v7 = (_BYTE *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 72) + 48))(*(_QWORD *)(a1 + 72), a6);
    if ((*(unsigned int (**)(_BYTE *))(*(_QWORD *)v7 + 16))(v7) == 52 && (v7[144] & 1) != 0)
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
  return *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) == 0;
}

void sub_192203EF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)&a9);
  _Unwind_Resume(a1);
}

uint64_t CI::DAGHelper::process_kernels(CI::DAGHelper *this, const char *a2, const CI::Node *a3, const CI::ProgramNode *a4, CI::SerialObjectPtrArray *a5)
{
  uint64_t v10;
  unsigned __int16 v11;
  uint64_t v12;
  unsigned __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v10 = operator new();
  *(_QWORD *)v10 = 0;
  *(_OWORD *)(v10 + 16) = 0u;
  *(_OWORD *)(v10 + 32) = 0u;
  *(_OWORD *)(v10 + 48) = 0u;
  *(_QWORD *)(v10 + 4) = 32;
  *(_QWORD *)(v10 + 16) = malloc_type_calloc(0x16uLL, 4uLL, 0x100004052888210uLL);
  *(_DWORD *)(v10 + 8) = 32;
  *((_QWORD *)this + 5) = v10;
  CI::SerialValArray<int>::append((void **)v10, 44);
  CI::DAGHelper::add_function_with_name((uint64_t)this, "_ci_init_destcoord");
  CI::DAGHelper::add_init_destcoord_function_info((uint64_t *)this);
  v11 = CI::DAGHelper::build_dag(this, a3, a4, a5, 0);
  v12 = v11;
  if (v11)
  {
    if ((*((_BYTE *)a4 + 144) & 1) != 0)
    {
      v13 = v11;
      CI::DAGHelper::add_function_with_name((uint64_t)this, "_ci_linear_to_srgb");
      CI::DAGHelper::add_colour_inout_function_info((uint64_t *)this, v12);
      v12 = (unsigned __int16)(v13 + 1);
    }
    CI::DAGHelper::add_function_with_name((uint64_t)this, "_ci_write_pixel");
    CI::DAGHelper::add_write_pixel_function_info((uint64_t *)this, v12);
  }
  CI::SoftwareDAGDescriptor::analyze_set_destcoord(*((CI::SoftwareDAGDescriptor **)this + 1));
  CI::SoftwareDAGDescriptor::create_pipeline(*((_QWORD **)this + 1));
  v14 = operator new();
  v15 = *((_QWORD *)this + 1);
  CI::MainProgram::MainProgram((int64x2_t *)v14, a2, 0, *((_QWORD *)this + 5), 0);
  *(_QWORD *)v14 = &off_1E2EB7AA0;
  *(_QWORD *)(v14 + 96) = v15;
  *(_OWORD *)(v14 + 80) = *(_OWORD *)((char *)this + 24);
  return v14;
}

void sub_1922040A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10F1C40A348548ELL);
  _Unwind_Resume(a1);
}

void CI::SoftwareDAGDescriptor::analyze_set_destcoord(CI::SoftwareDAGDescriptor *this)
{
  uint64_t v1;
  uint64_t v3;
  int v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void **v10;

  v1 = *((_QWORD *)this + 2);
  if (0x8E38E38E38E38E39 * ((*((_QWORD *)this + 3) - v1) >> 3) - 3 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v3 = 0;
    v4 = -1;
    v5 = 1;
    do
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>((char *)&v7, *(_QWORD *)(v1 + v3 + 72), *(_QWORD *)(v1 + v3 + 80), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(v1 + v3 + 80) - *(_QWORD *)(v1 + v3 + 72)) >> 3));
      v6 = *(_QWORD *)(v8 - 16);
      if (v6 != v4)
      {
        *(_BYTE *)(*((_QWORD *)this + 2) + v3 + 136) = 1;
        v4 = v6;
      }
      v10 = (void **)&v7;
      std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100](&v10);
      ++v5;
      v1 = *((_QWORD *)this + 2);
      v3 += 72;
    }
    while (-1 - 0x71C71C71C71C71C7 * ((*((_QWORD *)this + 3) - v1) >> 3) > v5);
  }
}

_QWORD *CI::SoftwareDAGDescriptor::create_pipeline(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!this[1])
  {
    v1 = this;
    this = (_QWORD *)operator new();
    v2 = v1[2];
    v3 = v1[3] - v2;
    v4 = v1[5];
    v5 = v1[6];
    *this = v2;
    this[1] = v4;
    this[2] = 0x8E38E38E38E38E39 * (v3 >> 3);
    this[3] = 0x8E38E38E38E38E39 * ((v5 - v4) >> 3);
    v1[1] = this;
  }
  return this;
}

uint64_t CI::create_sw_dag(CI *this, const CI::SWContext *a2, const CI::SWContext *a3, const CI::Node *a4, const CI::ProgramNode *a5, CI::SerialObjectPtrArray *a6)
{
  uint64_t v10;
  char *v12[23];

  CI::DAGHelper::DAGHelper((CI::DAGHelper *)v12, a2);
  if (CI::DAGHelper::analyze_kernels((CI::DAGHelper *)v12, a4))
    v10 = 0;
  else
    v10 = CI::DAGHelper::process_kernels((CI::DAGHelper *)v12, (const char *)this, a3, a4, a5);
  CI::DAGHelper::~DAGHelper(v12);
  return v10;
}

void sub_1922042DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CI::DAGHelper::~DAGHelper((char **)va);
  _Unwind_Resume(a1);
}

void CI::create_sw_args(CI *this, const CI::SWContext *a2, const CI::Node *a3, const CI::ProgramNode *a4, CI::SerialObjectPtrArray *a5)
{
  char *v8;
  uint64_t v9;

  CI::DAGHelper::DAGHelper((CI::DAGHelper *)&v8, this);
  if (!CI::DAGHelper::analyze_kernels((CI::DAGHelper *)&v8, a3))
  {
    CI::DAGHelper::build_dag((CI::DAGHelper *)&v8, a2, a3, a4, 1);
    if (v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 16))(v9);
  }
  CI::DAGHelper::~DAGHelper(&v8);
}

void sub_19220437C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CI::DAGHelper::~DAGHelper((char **)va);
  _Unwind_Resume(a1);
}

uint64_t CI::SoftwareDAG::type(CI::SoftwareDAG *this)
{
  return 69;
}

char *std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char *v6;
  uint64_t i;
  uint64_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CI::SWRendererFunctionInputNode>::__vallocate[abi:nn180100](result, a4);
    for (i = *((_QWORD *)v6 + 1); a2 != a3; i += 24)
    {
      *(_QWORD *)i = &off_1E2EB7C38;
      v8 = *(_QWORD *)(a2 + 8);
      *(_DWORD *)(i + 16) = *(_DWORD *)(a2 + 16);
      *(_QWORD *)(i + 8) = v8;
      a2 += 24;
    }
    *((_QWORD *)v6 + 1) = i;
  }
  return result;
}

char *std::vector<CI::SWRendererFunctionInputNode>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(24 * a2);
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
  abort();
}

void std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  BOOL v9;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 24;
      v7 = v4 - 24;
      do
      {
        v8 = *(_QWORD *)v7;
        v7 -= 24;
        (*(void (**)(char *))(v8 + 8))(v6);
        v9 = v6 == v2;
        v6 = v7;
      }
      while (!v9);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void CI::SWRendererFunctionInputNode::description(CI::SWRendererFunctionInputNode *this@<X0>, _QWORD *a2@<X8>)
{
  char *v3;
  std::string *v4;
  __int128 v5;
  std::string *v6;
  std::string *v7;
  __int128 v8;
  __int128 v9;
  void *v10;
  std::string *v11;
  __int128 v12;
  std::string v13;
  std::string v14;

  switch(*((_DWORD *)this + 4))
  {
    case 0:
      std::to_string(&v13, *((_QWORD *)this + 1));
      v4 = std::string::insert(&v13, 0, "Texture[", 8uLL);
      v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
      v14.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v5;
      v4->__r_.__value_.__l.__size_ = 0;
      v4->__r_.__value_.__r.__words[2] = 0;
      v4->__r_.__value_.__r.__words[0] = 0;
      v6 = std::string::append(&v14, "]", 1uLL);
      goto LABEL_6;
    case 3:
      std::to_string(&v14, *((_QWORD *)this + 1));
      v11 = std::string::insert(&v14, 0, "Sampler#", 8uLL);
      v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      a2[2] = *((_QWORD *)&v11->__r_.__value_.__l + 2);
      *(_OWORD *)a2 = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      if ((SHIBYTE(v14.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        return;
      v10 = (void *)v14.__r_.__value_.__r.__words[0];
      goto LABEL_14;
    case 4:
      std::to_string(&v13, *((_QWORD *)this + 1));
      v7 = std::string::insert(&v13, 0, "Buffer[", 7uLL);
      v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      v14.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      v6 = std::string::append(&v14, "]", 1uLL);
LABEL_6:
      v9 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      a2[2] = *((_QWORD *)&v6->__r_.__value_.__l + 2);
      *(_OWORD *)a2 = v9;
      v6->__r_.__value_.__l.__size_ = 0;
      v6->__r_.__value_.__r.__words[2] = 0;
      v6->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v14.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v13.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        return;
      v10 = (void *)v13.__r_.__value_.__r.__words[0];
LABEL_14:
      operator delete(v10);
      break;
    case 5:
    case 6:
      v3 = "";
      goto LABEL_11;
    case 7:
      v3 = "ThreadPosition";
      goto LABEL_11;
    default:
      v3 = "Unknown";
LABEL_11:
      std::string::basic_string[abi:nn180100]<0>(a2, v3);
      break;
  }
}

void sub_1922046E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CI::SWRendererFunctionInputNode::~SWRendererFunctionInputNode(CI::SWRendererFunctionInputNode *this)
{
  JUMPOUT(0x194025AACLL);
}

void SamplerObj::~SamplerObj(SamplerObj *this)
{
  CI::Object *v1;

  *(_QWORD *)this = &off_1E2EB7668;
  v1 = (CI::Object *)*((_QWORD *)this + 1);
  if (v1)
    CI::Object::unref(v1);
}

{
  CI::Object *v1;

  *(_QWORD *)this = &off_1E2EB7668;
  v1 = (CI::Object *)*((_QWORD *)this + 1);
  if (v1)
    CI::Object::unref(v1);
  JUMPOUT(0x194025AACLL);
}

_QWORD *std::string::basic_string[abi:nn180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

uint64_t std::vector<CI::SoftwareDAGDescriptor::ArgumentInfo>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>,std::reverse_iterator<CI::SoftwareDAGDescriptor::ArgumentInfo*>,std::reverse_iterator<CI::SoftwareDAGDescriptor::ArgumentInfo*>,std::reverse_iterator<CI::SoftwareDAGDescriptor::ArgumentInfo*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(32 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>,std::reverse_iterator<CI::SoftwareDAGDescriptor::ArgumentInfo*>,std::reverse_iterator<CI::SoftwareDAGDescriptor::ArgumentInfo*>,std::reverse_iterator<CI::SoftwareDAGDescriptor::ArgumentInfo*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a3 != a5)
  {
    v11 = 0;
    do
    {
      v12 = *(_QWORD *)(a3 + v11 - 32);
      *(_QWORD *)(a7 + v11 - 24) = 0;
      v13 = a7 + v11 - 24;
      *(_QWORD *)(v13 - 8) = v12;
      *(_QWORD *)(v13 + 8) = 0;
      *(_QWORD *)(v13 + 16) = 0;
      std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>((char *)v13, *(_QWORD *)(a3 + v11 - 24), *(_QWORD *)(a3 + v11 - 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a3 + v11 - 16) - *(_QWORD *)(a3 + v11 - 24)) >> 3));
      v11 -= 32;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

void **std::__split_buffer<CI::SoftwareDAGDescriptor::ArgumentInfo>::~__split_buffer(void **a1)
{
  std::__split_buffer<CI::SoftwareDAGDescriptor::ArgumentInfo>::clear[abi:nn180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<CI::SoftwareDAGDescriptor::ArgumentInfo>::clear[abi:nn180100](uint64_t a1)
{
  uint64_t i;
  uint64_t v2;
  void **v4;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 32;
    v4 = (void **)(i - 24);
    std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100](&v4);
  }
}

uint64_t std::__split_buffer<CI::SWRendererFunctionInputNode>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(_QWORD *)(i - 24);
    *(_QWORD *)(a1 + 16) = i - 24;
    (*(void (**)(void))(v4 + 8))();
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::vector<CI::SWRendererFunctionNode>::__emplace_back_slow_path<CI::SWFunction &,std::vector<CI::SWRendererFunctionInputNode> *&>(uint64_t *a1, __int128 *a2, uint64_t **a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  void *v16;
  uint64_t *v17;
  uint64_t *v18;
  char *v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;

  v3 = *a1;
  v4 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0x38E38E38E38E38ELL)
    abort();
  v10 = a1[2];
  v9 = (uint64_t)(a1 + 2);
  v11 = 0x8E38E38E38E38E39 * ((v10 - v3) >> 3);
  if (2 * v11 > v5)
    v5 = 2 * v11;
  if (v11 >= 0x1C71C71C71C71C7)
    v12 = 0x38E38E38E38E38ELL;
  else
    v12 = v5;
  v20 = v9;
  if (v12)
    v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionNode>>(v9, v12);
  else
    v13 = 0;
  v16 = v13;
  v17 = (uint64_t *)&v13[72 * v4];
  v18 = v17;
  v19 = &v13[72 * v12];
  v21 = *a2;
  v22 = *((_QWORD *)a2 + 2);
  CI::SWRendererFunctionNode::SWRendererFunctionNode(v17, (uint64_t)&v21, *a3);
  v18 = v17 + 9;
  std::vector<CI::SWRendererFunctionNode>::__swap_out_circular_buffer(a1, &v16);
  v14 = a1[1];
  std::__split_buffer<CI::SWRendererFunctionNode>::~__split_buffer(&v16);
  return v14;
}

void sub_192204B9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CI::SWRendererFunctionNode>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t *CI::SWRendererFunctionNode::SWRendererFunctionNode(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>((char *)a1, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3));
  v6 = *(_QWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 3) = *(_OWORD *)a2;
  v7 = *a1;
  a1[5] = v6;
  a1[6] = v7;
  a1[7] = 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3);
  *((_BYTE *)a1 + 64) = 0;
  return a1;
}

uint64_t std::vector<CI::SWRendererFunctionNode>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<CI::SWRendererFunctionNode>,std::reverse_iterator<CI::SWRendererFunctionNode*>,std::reverse_iterator<CI::SWRendererFunctionNode*>,std::reverse_iterator<CI::SWRendererFunctionNode*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionNode>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(72 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:nn180100]<std::allocator<CI::SWRendererFunctionNode>,std::reverse_iterator<CI::SWRendererFunctionNode*>,std::reverse_iterator<CI::SWRendererFunctionNode*>,std::reverse_iterator<CI::SWRendererFunctionNode*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (a3 != a5)
  {
    v11 = 0;
    do
    {
      v12 = a7 + v11;
      *(_QWORD *)(v12 - 72) = 0;
      *(_QWORD *)(v12 - 64) = 0;
      *(_QWORD *)(a7 + v11 - 56) = 0;
      std::vector<CI::SWRendererFunctionInputNode>::__init_with_size[abi:nn180100]<CI::SWRendererFunctionInputNode*,CI::SWRendererFunctionInputNode*>((char *)(a7 + v11 - 72), *(_QWORD *)(a3 + v11 - 72), *(_QWORD *)(a3 + v11 - 64), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a3 + v11 - 64) - *(_QWORD *)(a3 + v11 - 72)) >> 3));
      v13 = *(_QWORD *)(a3 + v11 - 32);
      *(_OWORD *)(a7 + v11 - 48) = *(_OWORD *)(a3 + v11 - 48);
      v14 = *(_QWORD *)(a7 + v11 - 72);
      *(_QWORD *)(a7 + v11 - 32) = v13;
      *(_QWORD *)(a7 + v11 - 24) = v14;
      *(_QWORD *)(a7 + v11 - 16) = *(_QWORD *)(a3 + v11 - 16);
      *(_BYTE *)(a7 + v11 - 8) = *(_BYTE *)(a3 + v11 - 8);
      v11 -= 72;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

void **std::__split_buffer<CI::SWRendererFunctionNode>::~__split_buffer(void **a1)
{
  std::__split_buffer<CI::SWRendererFunctionNode>::clear[abi:nn180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<CI::SWRendererFunctionNode>::clear[abi:nn180100](uint64_t a1)
{
  uint64_t i;
  uint64_t v2;
  void **v4;
  void **v5;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    v4 = (void **)(i - 72);
    *(_QWORD *)(a1 + 16) = v4;
    v5 = v4;
    std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100](&v5);
  }
}

uint64_t CI::SerialStringArray::firstIndexOfString(CI::SerialStringArray *this, const char *__s2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v2 = *(unsigned int *)this;
  if ((int)v2 < 1)
    return 0xFFFFFFFFLL;
  v4 = 0;
  v5 = *((_QWORD *)this + 4);
  while (strcmp(*(const char **)(v5 + 8 * v4), __s2))
  {
    if (v2 == ++v4)
      return 0xFFFFFFFFLL;
  }
  return v4;
}

_QWORD *std::vector<unsigned long>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  int64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    std::vector<unsigned long>::__vallocate[abi:nn180100](a1, v5 >> 3);
    v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

char *std::vector<unsigned long>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(8 * a2);
}

uint64_t std::vector<CI::SWRendererFunctionNode>::__emplace_back_slow_path<CI::SWFunction const&,std::vector<CI::SWRendererFunctionInputNode> *&>(uint64_t *a1, __int128 *a2, uint64_t **a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  void *v16;
  uint64_t *v17;
  uint64_t *v18;
  char *v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;

  v3 = *a1;
  v4 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0x38E38E38E38E38ELL)
    abort();
  v10 = a1[2];
  v9 = (uint64_t)(a1 + 2);
  v11 = 0x8E38E38E38E38E39 * ((v10 - v3) >> 3);
  if (2 * v11 > v5)
    v5 = 2 * v11;
  if (v11 >= 0x1C71C71C71C71C7)
    v12 = 0x38E38E38E38E38ELL;
  else
    v12 = v5;
  v20 = v9;
  if (v12)
    v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionNode>>(v9, v12);
  else
    v13 = 0;
  v16 = v13;
  v17 = (uint64_t *)&v13[72 * v4];
  v18 = v17;
  v19 = &v13[72 * v12];
  v21 = *a2;
  v22 = *((_QWORD *)a2 + 2);
  CI::SWRendererFunctionNode::SWRendererFunctionNode(v17, (uint64_t)&v21, *a3);
  v18 = v17 + 9;
  std::vector<CI::SWRendererFunctionNode>::__swap_out_circular_buffer(a1, &v16);
  v14 = a1[1];
  std::__split_buffer<CI::SWRendererFunctionNode>::~__split_buffer(&v16);
  return v14;
}

void sub_192205070(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CI::SWRendererFunctionNode>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t CI::SoftwareDAGDescriptor::ArgumentInfo::add_sampler_builder_output(CI::SoftwareDAGDescriptor::ArgumentInfo *this, uint64_t a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  int64x2_t v21;
  uint64_t v22;
  uint64_t v23;
  int64x2_t v24;
  uint64_t v25;
  uint64_t v26;

  v6 = *((_QWORD *)this + 3);
  result = (uint64_t)this + 24;
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (v7 >= v6)
  {
    v9 = *((_QWORD *)this + 1);
    v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - v9) >> 3);
    v11 = v10 + 1;
    if (v10 + 1 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - v9) >> 3);
    if (2 * v12 > v11)
      v11 = 2 * v12;
    if (v12 >= 0x555555555555555)
      v13 = 0xAAAAAAAAAAAAAAALL;
    else
      v13 = v11;
    v26 = result;
    v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(result, v13);
    v16 = &v14[24 * v10];
    *(_QWORD *)v16 = &off_1E2EB7C38;
    *((_QWORD *)v16 + 1) = a2;
    *((_DWORD *)v16 + 4) = 6;
    v17 = *((_QWORD *)this + 1);
    v18 = *((_QWORD *)this + 2);
    if (v18 == v17)
    {
      v21 = vdupq_n_s64(v18);
      v19 = &v14[24 * v10];
    }
    else
    {
      v19 = &v14[24 * v10];
      do
      {
        *((_QWORD *)v19 - 3) = &off_1E2EB7C38;
        v19 -= 24;
        v20 = *(_QWORD *)(v18 - 16);
        *((_DWORD *)v19 + 4) = *(_DWORD *)(v18 - 8);
        *((_QWORD *)v19 + 1) = v20;
        v18 -= 24;
      }
      while (v18 != v17);
      v21 = *(int64x2_t *)((char *)this + 8);
    }
    v8 = v16 + 24;
    *((_QWORD *)this + 1) = v19;
    *((_QWORD *)this + 2) = v16 + 24;
    v24 = v21;
    v22 = *((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = &v14[24 * v15];
    v25 = v22;
    v23 = v21.i64[0];
    result = std::__split_buffer<CI::SWRendererFunctionInputNode>::~__split_buffer((uint64_t)&v23);
  }
  else
  {
    *(_QWORD *)v7 = &off_1E2EB7C38;
    *(_QWORD *)(v7 + 8) = a2;
    *(_DWORD *)(v7 + 16) = 6;
    v8 = (char *)(v7 + 24);
  }
  *((_QWORD *)this + 2) = v8;
  return result;
}

uint64_t TimerBase::TimerBase(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  int v7;
  signed int v8;
  NSObject *v9;

  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  *(_QWORD *)(a1 + 8) = a3 | (unint64_t)(a2 << 32);
  *(_QWORD *)(a1 + 16) = a4;
  if (CI_KDEBUG())
    v7 = a5;
  else
    v7 = 0;
  *(_DWORD *)(a1 + 24) = v7;
  *(_QWORD *)(a1 + 28) = 0;
  *(_QWORD *)(a1 + 44) = 0;
  *(_QWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  if ((v7 - 29) < 2 || v7 == 6 || (v7 - 25) <= 3 || v7)
    kdebug_trace();
  if (CI_PRINT_TIME())
  {
    *(CFAbsoluteTime *)(a1 + 48) = CFAbsoluteTimeGetCurrent();
    *(_QWORD *)(a1 + 32) = dispatch_get_current_queue();
    v8 = TimerBase::get_and_increment_queue_level((TimerBase *)a1);
    *(_DWORD *)(a1 + 28) = v8;
    v9 = *(NSObject **)(a1 + 32);
    if (v9)
      dispatch_queue_set_specific(v9, (const void *)(v8 + 0x6369746C1), 0, 0);
    *(CFAbsoluteTime *)(a1 + 40) = CFAbsoluteTimeGetCurrent();
  }
  return a1;
}

char *TimerBase::get_and_increment_queue_level(TimerBase *this)
{
  NSObject *v1;
  char *v2;

  v1 = *((_QWORD *)this + 4);
  if (!v1)
    return 0;
  v2 = (char *)dispatch_queue_get_specific(*((dispatch_queue_t *)this + 4), "com.apple.coreimage.TimerBase.dispatchQueueKey")+ 1;
  dispatch_queue_set_specific(v1, "com.apple.coreimage.TimerBase.dispatchQueueKey", v2, 0);
  return v2;
}

void CI::ConvertedNodeRAII::~ConvertedNodeRAII(CI::ConvertedNodeRAII *this)
{
  CI::Object *v2;

  v2 = (CI::Object *)*((_QWORD *)this + 1);
  if (v2)
    CI::Object::unref(v2);
  if (*(_QWORD *)this)
    CI::Object::unref(*(CI::Object **)this);
}

std::string *CI::DAGHelper::TextureReadFunction::TextureReadFunction(std::string *this, __int128 *a2, uint64_t a3)
{
  __int128 v5;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  std::vector<unsigned long>::vector(this[1].__r_.__value_.__r.__words, a3);
  this[2].__r_.__value_.__s.__data_[0] = 0;
  return this;
}

void sub_1922053EC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned long>::__assign_with_size[abi:nn180100]<unsigned long *,unsigned long *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 3)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61)
      abort();
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<unsigned long>::__vallocate[abi:nn180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 3;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

void TimerBase::add_time_at_level(TimerBase *this, int a2, double a3)
{
  NSObject *v3;
  const void *v4;
  void *v5;

  v3 = *((_QWORD *)this + 4);
  if (v3)
  {
    v4 = (const void *)(a2 + 0x6369746C0);
    v5 = (void *)(((double)(unint64_t)dispatch_queue_get_specific(*((dispatch_queue_t *)this + 4), v4)
                 / 10000000.0
                 + a3)
                * 10000000.0
                + 0.5);
    dispatch_queue_set_specific(v3, v4, v5, 0);
  }
}

__n128 _ci_sampler_builder(uint64_t a1, CI::Object *this, __int128 *a3, __n128 *a4)
{
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __n128 result;

  *(_QWORD *)a1 = &off_1E2EB7668;
  if (this)
    v7 = CI::Object::ref((uint64_t)this);
  else
    v7 = 0;
  *(_QWORD *)(a1 + 8) = v7;
  v8 = *a3;
  v9 = a3[1];
  *(_QWORD *)(a1 + 48) = *((_QWORD *)a3 + 4);
  *(_OWORD *)(a1 + 16) = v8;
  *(_OWORD *)(a1 + 32) = v9;
  result = *a4;
  *(__n128 *)(a1 + 64) = *a4;
  return result;
}

__n128 CI::SoftwareDAGDescriptor::add_function(uint64_t a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *(_QWORD *)(a1 + 104) = a2[1].n128_u64[0];
  *(__n128 *)(a1 + 88) = result;
  return result;
}

void CI::SoftwareDAGDescriptor::~SoftwareDAGDescriptor(CI::SoftwareDAGDescriptor *this)
{
  CI::SoftwareDAGDescriptor::~SoftwareDAGDescriptor(this);
  JUMPOUT(0x194025AACLL);
}

{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = &off_1E2EB7C10;
  v2 = *((_QWORD *)this + 1);
  if (v2)
    MEMORY[0x194025AAC](v2, 0x1060C4030F2A1FBLL);
  v3 = (void **)((char *)this + 64);
  std::vector<CI::SoftwareDAGDescriptor::ArgumentInfo>::__destroy_vector::operator()[abi:nn180100](&v3);
  v3 = (void **)((char *)this + 40);
  std::vector<CI::SWRendererFunctionNode>::__destroy_vector::operator()[abi:nn180100](&v3);
  v3 = (void **)((char *)this + 16);
  std::vector<CI::SWRendererFunctionNode>::__destroy_vector::operator()[abi:nn180100](&v3);
}

void std::vector<CI::SoftwareDAGDescriptor::ArgumentInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  void **v7;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 32;
        v7 = (void **)(v4 - 24);
        std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100](&v7);
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<CI::SWRendererFunctionNode>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;
  void **v6;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 9;
        v6 = v4;
        std::vector<CI::SWRendererFunctionInputNode>::__destroy_vector::operator()[abi:nn180100](&v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

CI::DAGHelper *CI::DAGHelper::DAGHelper(CI::DAGHelper *this, const CI::SWContext *a2)
{
  uint64_t v3;
  void *v5[6];
  _QWORD v6[6];
  _QWORD v7[6];
  _QWORD v8[6];
  _QWORD v9[6];
  _QWORD v10[8];

  v10[6] = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E2EB7C60;
  *((_QWORD *)this + 2) = a2;
  *((_QWORD *)this + 5) = 0;
  *((_OWORD *)this + 3) = xmmword_19248E020;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 8) = (char *)this + 72;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 11) = (char *)this + 96;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = (char *)this + 120;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 17) = (char *)this + 144;
  *((_QWORD *)this + 19) = 0;
  std::string::basic_string[abi:nn180100]<0>(v5, "_ci_read_pixel");
  v5[3] = _ci_read_pixel;
  v5[4] = CI::f4_sr2d_f3x3_f2;
  v5[5] = "_ci_read_pixel";
  std::string::basic_string[abi:nn180100]<0>(v6, "_ci_read_pixel_420");
  v6[3] = _ci_read_pixel_420;
  v6[4] = CI::f4_sr2d_f3x3_sr2d_f2_f2;
  v6[5] = "_ci_read_pixel_420";
  std::string::basic_string[abi:nn180100]<0>(v7, "_ci_srgb_to_linear");
  v7[3] = _ci_srgb_to_linear;
  v7[4] = CI::f4;
  v7[5] = "_ci_srgb_to_linear";
  std::string::basic_string[abi:nn180100]<0>(v8, "_ci_init_destcoord");
  v8[3] = _ci_init_destcoord;
  v8[4] = 0;
  v8[5] = "_ci_init_destcoord";
  std::string::basic_string[abi:nn180100]<0>(v9, "_ci_write_pixel");
  v9[3] = _ci_write_pixel;
  v9[4] = CI::f4_sr2d_f4_gid;
  v9[5] = "_ci_write_pixel";
  std::string::basic_string[abi:nn180100]<0>(v10, "_ci_linear_to_srgb");
  v10[3] = _ci_linear_to_srgb;
  v10[4] = CI::f4;
  v10[5] = "_ci_linear_to_srgb";
  std::map<std::string,CI::SWFunction>::map[abi:nn180100]((uint64_t)this + 160, v5, 6);
  v3 = 36;
  do
  {
    if (*((char *)&v5[v3 - 3] - 1) < 0)
      operator delete(v5[v3 - 6]);
    v3 -= 6;
  }
  while (v3 * 8);
  return this;
}

void sub_1922059E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  _QWORD **v13;
  uint64_t v14;
  _QWORD **v15;
  _QWORD **v16;
  _QWORD **v17;
  uint64_t v19;

  v19 = 288;
  while (1)
  {
    if (*(char *)(v14 + v19 - 25) < 0)
      operator delete(*(void **)(v14 + v19 - 48));
    v19 -= 48;
    if (!v19)
    {
      std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(a10, *v13);
      std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::destroy(a11, *v17);
      std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(a12, *v16);
      std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(a13, *v15);
      _Unwind_Resume(a1);
    }
  }
}

void sub_192205A78()
{
  JUMPOUT(0x192205A40);
}

double _ci_read_pixel(uint64x2_t *a1, float32x2_t *a2, double a3, float64x2_t a4, double a5, double a6, int8x16_t a7, double a8, double a9, int8x16_t a10)
{
  __int32 v10;
  float32x2_t v11;

  v10 = a2[4].i32[1];
  if (v10 != 2)
  {
    if (v10 == 1)
    {
      a4.f64[0] = *(float64_t *)a2;
      v11 = a2[1];
      HIDWORD(a4.f64[0]) = a2[2].i32[0];
      v11.i32[1] = a2[2].i32[1];
      a5 = COERCE_DOUBLE(vmla_f32(v11, *(float32x2_t *)&a4.f64[0], *(float32x2_t *)&a3));
      a3 = a5;
    }
    else
    {
      *(float *)&a5 = vmlas_n_f32(vmuls_lane_f32(a2->f32[1], *(float32x2_t *)&a3, 1), a2->f32[0], *(float *)&a3);
      LODWORD(a6) = a2[1].i32[1];
      LODWORD(a8) = a2[2].i32[1];
      *(float *)a7.i32 = vmlas_n_f32(vmuls_lane_f32(a2[2].f32[0], *(float32x2_t *)&a3, 1), *(float *)&a6, *(float *)&a3);
      *(float *)&a3 = a2[1].f32[0] + *(float *)&a5;
      *(float *)a4.f64 = *(float *)&a8 + *(float *)a7.i32;
      *((float *)&a3 + 1) = *(float *)&a8 + *(float *)a7.i32;
    }
  }
  return CI::BitmapSampler::read(a1, a3, a4, a5, a6, a7, *(uint8x8_t *)&a8, a9, a10);
}

void CI::f4_sr2d_f3x3_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v10;
  double (*v11)(uint64_t, char *, double);
  uint64_t v12;
  uint64_t v13;
  CI *v14;
  __int128 v15;

  v10 = *(_QWORD **)(a1 + 48);
  v11 = *(double (**)(uint64_t, char *, double))(a1 + 24);
  v12 = *((_QWORD *)a2 + 8 * v10[1]);
  v13 = v10[4];
  v14 = (CI *)(a3 + 16 * v10[7]);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC(v14, a2);
  *(double *)&v15 = v11(v12, (char *)a2 + 64 * v13, *(double *)v14);
  *(_OWORD *)(a3 + 16 * a7) = v15;
}

double _ci_read_pixel_420(uint64x2_t *a1, float32x2_t *a2, uint64x2_t *a3, float32x2_t a4, float64x2_t a5, double a6, double a7, int8x16_t a8, double a9, double a10, int8x16_t a11)
{
  float32x2_t v11;
  __int32 v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  double v18;
  float64x2_t v19;
  double v20;
  double v21;
  int8x16_t v22;
  uint8x8_t v23;
  double v24;
  int8x16_t v25;
  double v26;
  float32x2_t v28;
  unsigned int v29;

  v11 = *(float32x2_t *)&a5.f64[0];
  v14 = a2[4].i32[1];
  if (v14 != 2)
  {
    if (v14 == 1)
    {
      v15 = *a2;
      v16 = a2[1];
      v15.i32[1] = a2[2].i32[0];
      v16.i32[1] = a2[2].i32[1];
      *(float32x2_t *)&a5.f64[0] = vmla_f32(v16, v15, v11);
      v11 = *(float32x2_t *)&a5.f64[0];
    }
    else
    {
      LODWORD(a6) = a2[1].i32[1];
      a8.i32[0] = a2[2].i32[1];
      *(float *)&a7 = vmlas_n_f32(vmuls_lane_f32(a2[2].f32[0], *(float32x2_t *)&a5.f64[0], 1), *(float *)&a6, *(float *)a5.f64);
      v17.f32[0] = a2[1].f32[0]
                 + vmlas_n_f32(vmuls_lane_f32(a2->f32[1], *(float32x2_t *)&a5.f64[0], 1), a2->f32[0], *(float *)a5.f64);
      *(float *)a5.f64 = *(float *)a8.i32 + *(float *)&a7;
      v17.f32[1] = *(float *)a8.i32 + *(float *)&a7;
      v11 = v17;
    }
  }
  v28 = v11;
  v18 = CI::BitmapSampler::read(a1, *(double *)&v11, a5, a6, a7, a8, (uint8x8_t)v11, a10, a11);
  v29 = LODWORD(v18);
  v26 = CI::BitmapSampler::read(a3, COERCE_DOUBLE(vmul_f32(a4, v28)), v19, v20, v21, v22, v23, v24, v25);
  return COERCE_DOUBLE(__PAIR64__(LODWORD(v26), v29));
}

void CI::f4_sr2d_f3x3_sr2d_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v10;
  double (*v11)(uint64_t, char *, uint64_t, double, double);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CI *v16;
  __int128 v17;

  v10 = *(_QWORD **)(a1 + 48);
  v11 = *(double (**)(uint64_t, char *, uint64_t, double, double))(a1 + 24);
  v12 = *((_QWORD *)a2 + 8 * v10[1]);
  v13 = v10[4];
  v14 = *((_QWORD *)a2 + 8 * v10[7]);
  v15 = v10[10];
  v16 = (CI *)(a3 + 16 * v10[13]);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC(v16, a2);
  *(double *)&v17 = v11(v12, (char *)a2 + 64 * v13, v14, *((double *)a2 + 8 * v15), *(double *)v16);
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

float32x4_t _ci_srgb_to_linear(float32x4_t a1)
{
  float32x4_t v1;
  int8x16_t v2;
  simd_float4 v8;
  float32x4_t v9;
  float32x4_t result;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;

  v1 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i64[0] = 0x8000000080000000;
  v2.i64[1] = 0x8000000080000000;
  __asm { FMOV            V0.4S, #1.0 }
  v12 = (float32x4_t)_Q0;
  v13 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v1), (int8x16_t)vcgtzq_f32(v1)), vorrq_s8(vandq_s8((int8x16_t)v1, v2), _Q0), (int8x16_t)0);
  v11 = vabsq_f32(v1);
  v8 = (simd_float4)vaddq_f32(vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x3F72A76Eu)), (float32x4_t)vdupq_n_s32(0x3D558919u));
  v8.i32[3] = 0;
  result = (float32x4_t)_simd_pow_f4(v8, (simd_float4)xmmword_19248E030);
  v9 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_n_s32(0x3D25AEE6u), v11), (int8x16_t)0, (int8x16_t)v12);
  result.i64[0] = vmulq_laneq_f32(vmulq_f32(v13, vmlaq_f32(vmulq_f32(vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x3D9E8391u)), vsubq_f32(v12, v9)), v9, result)), a1, 3).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

void CI::f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  double (*v9)(_QWORD *);
  __int128 v10;

  v9 = (double (*)(_QWORD *))a1[3];
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(a1[6] + 8)), a2);
  *(double *)&v10 = v9(a1);
  *(_OWORD *)(a3 + 16 * a7) = v10;
}

__n64 _ci_init_destcoord(float *a1, uint64_t a2)
{
  float v2;
  float v3;
  __n64 result;

  v2 = (float)(int)a2 + 0.5;
  v3 = (float)SHIDWORD(a2) + 0.5;
  result.n64_f32[0] = a1[2] + (float)((float)(v3 * a1[1]) + (float)(v2 * *a1));
  result.n64_f32[1] = a1[5] + (float)((float)(v3 * a1[4]) + (float)(v2 * a1[3]));
  return result;
}

double _ci_write_pixel(uint64_t a1, IPoint a2, __n128 a3)
{
  __n128 v4;

  v4 = a3;
  CI::BitmapSampler::write(a1, a2, (const vec4 *)&v4);
  return v4.n128_f64[0];
}

void CI::f4_sr2d_f4_gid(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, uint64_t a7)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  __n128 *v12;
  __n128 *v13;
  __int128 v14;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(_DWORD *)(v9 + 40);
  v11 = *(_QWORD *)(v9 + 32);
  v12 = (__n128 *)(a3 + 16 * v11);
  v13 = (__n128 *)(a2 + (v11 << 6));
  if (v10 == 5)
    v13 = v12;
  *(double *)&v14 = (*(double (**)(uint64_t, _QWORD, __n128))(a1 + 24))(a5, *a6, *v13);
  *(_OWORD *)(a3 + 16 * a7) = v14;
}

float32x4_t _ci_linear_to_srgb(float32x4_t a1)
{
  float32x4_t v1;
  int8x16_t v2;
  simd_float4 v8;
  float32x4_t v9;
  float32x4_t result;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;

  v1 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i64[0] = 0x8000000080000000;
  v2.i64[1] = 0x8000000080000000;
  __asm { FMOV            V0.4S, #1.0 }
  v12 = (float32x4_t)_Q0;
  v13 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v1), (int8x16_t)vcgtzq_f32(v1)), vorrq_s8(vandq_s8((int8x16_t)v1, v2), _Q0), (int8x16_t)0);
  v11 = vabsq_f32(v1);
  v8 = (simd_float4)v11;
  v8.i32[3] = 0;
  result = (float32x4_t)_simd_pow_f4(v8, (simd_float4)xmmword_19248E040);
  v9 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_n_s32(0x3B4D2E1Cu), v11), (int8x16_t)0, (int8x16_t)v12);
  result.i64[0] = vmulq_laneq_f32(vmulq_f32(v13, vmlaq_f32(vmulq_f32(vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x414EB852u)), vsubq_f32(v12, v9)), v9, vaddq_f32(vmulq_f32(result, (float32x4_t)vdupq_n_s32(0x3F870A3Du)), (float32x4_t)vdupq_n_s32(0xBD6147AE)))), a1, 3).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

void CI::DAGHelper::~DAGHelper(char **this)
{
  CI::DAGHelper::~DAGHelper(this);
  JUMPOUT(0x194025AACLL);
}

{
  *this = (char *)&off_1E2EB7C60;
  std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::destroy((uint64_t)(this + 20), this[21]);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(this + 17), this[18]);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::destroy((uint64_t)(this + 14), this[15]);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(this + 11), this[12]);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(this + 8), this[9]);
}

double CI::BitmapSampler::read(uint64x2_t *a1, double a2, float64x2_t a3, double a4, double a5, int8x16_t a6, uint8x8_t a7, double a8, int8x16_t a9)
{
  uint64_t v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float32x4_t v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  float32x4_t v32;
  uint64_t v33;
  float32x4_t v34;
  uint64_t v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  float32x4_t v44;
  float32x4_t v45;
  float64x2_t v46;
  unsigned __int32 v47;

  if (a1[8].i8[11])
  {
    a3 = vcvtq_f64_u64(a1[5]);
    *(float32x2_t *)&a3.f64[0] = vcvt_f32_f64(a3);
    a2 = COERCE_DOUBLE(vmul_f32(*(float32x2_t *)&a2, *(float32x2_t *)&a3.f64[0]));
  }
  if (a1[8].i8[10])
  {
    v10 = a1[5].i64[0];
    v11 = 0.0;
    if (v10)
    {
      v12 = a1[5].i64[1];
      if (v12)
      {
        v13 = a1[4].i64[1];
        if (v13)
        {
          if (a1[7].i64[0])
          {
            v14 = a1[7].i64[1];
            if (v14)
            {
              v15 = (int)*(float *)&a2;
              LODWORD(a2) = HIDWORD(a2);
              v16 = v15 & ~(v15 >> 31);
              v17 = v10 - 1;
              if (v16 < v17)
                v17 = v16;
              v18 = v12 - 1;
              if (((int)*((float *)&a2 + 1) & ~((int)*((float *)&a2 + 1) >> 31)) < v18)
                v18 = (int)*((float *)&a2 + 1) & ~((int)*((float *)&a2 + 1) >> 31);
              return CI::BitmapSampler::read((CI::BitmapSampler *)a1, (unsigned __int8 *)(v13 + a1[6].i64[0] * v18 + v14 * v17), a2, (int8x16_t)a3);
            }
          }
        }
      }
    }
    return v11;
  }
  HIDWORD(a3.f64[0]) = -1090519040;
  *(float32x2_t *)v19.f32 = vadd_f32(*(float32x2_t *)&a2, (float32x2_t)0xBF000000BF000000);
  v20 = (int)v19.f32[0];
  v21 = (int)v19.f32[1];
  *(float *)a3.f64 = v19.f32[1] - (float)(int)v19.f32[1];
  v22 = v21 & ~(v21 >> 31);
  v23 = a1[5].i64[0];
  v24 = a1[5].i64[1];
  v25 = v23 - 1;
  if ((v20 & ~(v20 >> 31)) >= (int)v23 - 1)
    v26 = v23 - 1;
  else
    v26 = v20 & ~(v20 >> 31);
  v27 = v24 - 1;
  if (v22 >= (int)v24 - 1)
    v22 = v24 - 1;
  if (v20 < 0)
    v28 = -1;
  else
    v28 = (int)v19.f32[0];
  if (v21 < 0)
    v21 = -1;
  if (v28 + 1 < v25)
    v29 = v28 + 1;
  else
    v29 = v23 - 1;
  if (v21 + 1 < v27)
    v30 = v21 + 1;
  else
    v30 = v24 - 1;
  if (v26 + 1 == v29)
  {
    *(float *)&a4 = (float)v20;
    v19.f32[0] = v19.f32[0] - (float)v20;
    return CI::BitmapSampler::bilinear_read((CI::BitmapSampler *)a1, (float32x4_t *)(a1[4].i64[1] + a1[6].i64[0] * v22 + a1[7].i64[1] * v26), (float32x4_t *)(a1[4].i64[1] + a1[6].i64[0] * v30 + a1[7].i64[1] * v26), *(double *)v19.i64, a3.f64[0], a4, a5, a6, a7, a8, a9);
  }
  v32 = 0uLL;
  if (v23 && v24)
  {
    v33 = a1[4].i64[1];
    v34 = 0uLL;
    if (!v33 || !a1[7].i64[0] || (v35 = a1[7].i64[1]) == 0)
    {
LABEL_45:
      v39 = a1[5].i64[1];
      if (v39)
      {
        v40 = a1[4].i64[1];
        if (v40)
        {
          if (a1[7].i64[0])
          {
            v41 = a1[7].i64[1];
            if (v41)
            {
              v42 = v23 - 1;
              if ((v26 & ~(v26 >> 31)) < v42)
                v42 = v26 & ~(v26 >> 31);
              v43 = v39 - 1;
              if ((v30 & ~(v30 >> 31)) < v43)
                v43 = v30 & ~(v30 >> 31);
              v45 = v34;
              v47 = LODWORD(a3.f64[0]);
              *(double *)v44.i64 = CI::BitmapSampler::read((CI::BitmapSampler *)a1, (unsigned __int8 *)(v40 + a1[6].i64[0] * v43 + v41 * v42), *(double *)v19.i64, (int8x16_t)a3);
              v34 = v45;
              LODWORD(a3.f64[0]) = v47;
              v32 = v44;
            }
          }
        }
      }
      goto LABEL_54;
    }
    v36 = v26 & ~(v26 >> 31);
    v37 = v22 & ~(v22 >> 31);
    if (v36 >= v25)
      v36 = v25;
    if (v37 >= v27)
      v38 = v27;
    else
      v38 = v37;
    v46 = a3;
    *(double *)v19.i64 = CI::BitmapSampler::read((CI::BitmapSampler *)a1, (unsigned __int8 *)(v33 + a1[6].i64[0] * v38 + v35 * v36), *(double *)v19.i64, (int8x16_t)a3);
    v32 = 0uLL;
    a3 = v46;
    v34 = v19;
    v23 = a1[5].i64[0];
  }
  else
  {
    v34 = 0uLL;
  }
  if (v23)
    goto LABEL_45;
LABEL_54:
  *(_QWORD *)&v11 = vmlaq_n_f32(vmulq_n_f32(v34, 1.0 - *(float *)a3.f64), v32, *(float *)a3.f64).u64[0];
  return v11;
}

double CI::BitmapSampler::bilinear_read(CI::BitmapSampler *this, float32x4_t *a2, float32x4_t *a3, double a4, double a5, double a6, double a7, int8x16_t a8, uint8x8_t a9, double a10, int8x16_t a11)
{
  int8x16_t v11;
  float16x4_t v12;
  int v13;
  float32x2_t v14;
  float32x2_t v15;
  int8x8_t v16;
  int8x8_t v17;
  int8x8_t v18;
  float32x2_t v19;
  float32x2_t v20;
  unsigned int v21;
  float32x2_t v22;
  float32x2_t v23;
  float v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x2_t v32;
  int32x2_t v33;
  int32x2_t v34;
  unsigned int v35;
  float v36;
  int8x16_t v37;
  uint32x4_t v38;
  int8x16_t v39;
  uint32x4_t v40;
  uint32x4_t v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  int8x16_t v47;
  uint32x4_t v48;
  uint32x4_t v49;
  uint32x4_t v50;
  float v51;
  float v52;
  uint16x8_t v53;
  int8x16_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float v60;
  float32x4_t v61;
  float32x4_t v62;
  float v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float v69;
  float32x4_t v70;
  float32x4_t v71;
  int8x16_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int8x8_t v75;
  float32x2_t v76;
  float32x2_t v77;
  int8x16_t v78;
  float32x4_t v79;
  float32x4_t v80;
  int8x16_t v81;
  int8x16_t v82;
  uint16x8_t v83;
  int8x16_t v84;
  float32x4_t v85;
  float32x4_t v86;
  uint16x8_t v87;
  int8x16_t v88;
  float32x4_t v89;
  float32x4_t v90;
  uint16x8_t v91;
  int8x16_t v92;
  uint16x8_t v93;
  int8x16_t v94;
  float32x4_t v95;
  float32x4_t v96;
  uint16x8_t v97;
  int8x16_t v98;
  uint16x8_t v99;
  int8x16_t v100;
  float32x4_t v101;
  float32x4_t v102;
  uint16x8_t v103;
  int8x16_t v104;
  uint16x8_t v105;
  uint8x8_t v106;
  uint16x8_t v107;
  uint16x8_t v108;
  int8x16_t v109;
  float32x4_t v110;
  float32x4_t v111;
  uint16x8_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float v120;

  v12 = 0;
  v13 = *((_DWORD *)this + 26);
  if (v13 <= 2048)
  {
    if (v13 > 770)
    {
      switch(v13)
      {
        case 1793:
        case 1794:
        case 1795:
        case 1797:
          goto LABEL_35;
        case 1796:
        case 1798:
          goto LABEL_34;
        case 1799:
          v24 = 1.0 - *(float *)&a5;
          v25 = (int8x16_t)vdupq_n_s32(0x4B400000u);
          v26 = (float32x4_t)vdupq_n_s32(0xCB400000);
          v27 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
          v28 = vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)a2->f32), v25), v26), v27), 1.0 - *(float *)&a4);
          v29 = vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s32(*(int32x2_t *)a2->f32, 0)), v25), v26), v27), *(float *)&a4);
          v30 = vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)a3->f32), v25), v26), v27), 1.0 - *(float *)&a4);
          v31 = vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)vzip2_s32(*(int32x2_t *)a3->f32, 0)), v25), v26), v27), *(float *)&a4);
          goto LABEL_51;
        case 1800:
        case 1801:
        case 1804:
          goto LABEL_27;
        case 1802:
        case 1803:
          return *(double *)&v12;
        default:
          v35 = v13 - 771;
          if (v35 > 0xE)
            return *(double *)&v12;
          if (((1 << v35) & 0x6010) != 0)
            goto LABEL_26;
          if (((1 << v35) & 5) != 0)
            goto LABEL_35;
          if (v35 != 3)
            return *(double *)&v12;
          goto LABEL_34;
      }
    }
    switch(v13)
    {
      case 257:
        v12 = 0;
        return *(double *)&v12;
      case 258:
      case 259:
      case 261:
        v14.f32[0] = 1.0 - *(float *)&a4;
        v14.i32[1] = LODWORD(a4);
        v15.f32[0] = 1.0 - *(float *)&a5;
        v15.i32[1] = LODWORD(a5);
        v16.i32[0] = a2->u8[0];
        v16.i32[1] = a2->u8[1];
        v17.i32[0] = a3->u8[0];
        v17.i32[1] = a3->u8[1];
        v18 = (int8x8_t)vdup_n_s32(0x4B400000u);
        v19 = (float32x2_t)vdup_n_s32(0xCB400000);
        v20 = vadd_f32((float32x2_t)vorr_s8(v16, v18), v19);
        v21 = 1132396544;
        goto LABEL_36;
      case 260:
      case 262:
        *(float *)&a7 = 1.0 - *(float *)&a4;
        *(int32x2_t *)v59.f32 = vdup_lane_s32(*(int32x2_t *)&a7, 0);
        *(int32x2_t *)&v59.u32[2] = vdup_lane_s32(*(int32x2_t *)&a4, 0);
        v60 = 1.0 - *(float *)&a5;
        v12.i32[0] = a2->i32[0];
        v78 = (int8x16_t)vdupq_n_s32(0x4B400000u);
        v79 = (float32x4_t)vdupq_n_s32(0xCB400000);
        v80 = (float32x4_t)vdupq_n_s32(0x437F0000u);
        v61 = vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8((uint8x8_t)v12)), v78), v79), v80);
        a11.i32[0] = a3->i32[0];
        v62 = vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)a11.i8)), v78), v79), v80);
        goto LABEL_40;
      case 263:
        a9.i32[0] = a2->i32[0];
        v105 = vmovl_u8(a9);
        v106.i8[7] = 0;
        v106.i8[0] = v105.i8[0];
        v106.i8[1] = v105.i8[2];
        v106.i8[2] = v105.i8[4];
        v106.i8[3] = v105.i8[6];
        v106.i8[4] = a2->i8[4];
        *(__int16 *)((char *)&v106.i16[2] + 1) = a2->u8[5];
        v11.i32[0] = a3->i32[0];
        v107 = vmovl_u8(*(uint8x8_t *)v11.i8);
        v105.i8[0] = v107.i8[0];
        v105.i8[1] = v107.i8[2];
        v105.i8[2] = v107.i8[4];
        v105.i8[3] = v107.i8[6];
        v105.i32[1] = a3->u16[2];
        v108 = vmovl_u8(v106);
        v109 = (int8x16_t)vdupq_n_s32(0x4B400000u);
        v110 = (float32x4_t)vdupq_n_s32(0xCB400000);
        v111 = (float32x4_t)vdupq_n_s32(0x437F0000u);
        v112 = vmovl_u8(*(uint8x8_t *)v105.i8);
        v113 = vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_high_u16(v108), v109), v110), v111), *(float *)&a4);
        v114 = vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v108.i8), v109), v110), v111), 1.0 - *(float *)&a4);
        v115 = vmulq_n_f32(vaddq_f32(vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v112.i8), v109), v110), v111), 1.0 - *(float *)&a4), vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_high_u16(v112), v109), v110), v111), *(float *)&a4)), *(float *)&a5);
        v116 = vmulq_n_f32(vaddq_f32(v114, v113), 1.0 - *(float *)&a5);
        goto LABEL_53;
      case 264:
      case 268:
        v51 = 1.0 - *(float *)&a4;
        v52 = 1.0 - *(float *)&a5;
        v83 = vmovl_u8(*(uint8x8_t *)a2->f32);
        v84 = (int8x16_t)vmovl_high_u16(v83);
        v54 = (int8x16_t)vdupq_n_s32(0x4B400000u);
        v55 = (float32x4_t)vdupq_n_s32(0xCB400000);
        v56 = (float32x4_t)vdupq_n_s32(0x437F0000u);
        v57 = vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v83.i8), v54), v55), v56);
        v58 = vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8(v84, v54), v55), v56);
        v53 = vmovl_u8(*(uint8x8_t *)a3->f32);
        goto LABEL_42;
      case 265:
      case 269:
        goto LABEL_47;
      case 266:
      case 270:
        v87 = vmovl_u8(*(uint8x8_t *)a2->f32);
        v88 = (int8x16_t)vdupq_n_s32(0x4B400000u);
        v89 = (float32x4_t)vdupq_n_s32(0xCB400000);
        v90 = (float32x4_t)vdupq_n_s32(0x437F0000u);
        v91 = vmovl_u8(*(uint8x8_t *)a3->f32);
        v92 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_n_f32(vaddq_f32(vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v87.i8), v88), v89), v90), 1.0 - *(float *)&a4), vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_high_u16(v87), v88), v89), v90), *(float *)&a4)), 1.0 - *(float *)&a5),
                                                  vmulq_n_f32(vaddq_f32(vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v91.i8), v88), v89), v90), 1.0 - *(float *)&a4), vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_high_u16(v91), v88), v89), v90), *(float *)&a4)), *(float *)&a5)));
        v12 = (float16x4_t)vextq_s8(v92, v92, 0xCuLL).u64[0];
        return *(double *)&v12;
      case 267:
      case 271:
        v93 = vmovl_u8(*(uint8x8_t *)a2->f32);
        v94 = (int8x16_t)vdupq_n_s32(0x4B400000u);
        v95 = (float32x4_t)vdupq_n_s32(0xCB400000);
        v96 = (float32x4_t)vdupq_n_s32(0x437F0000u);
        v97 = vmovl_u8(*(uint8x8_t *)a3->f32);
        v98 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_n_f32(vaddq_f32(vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v93.i8), v94), v95), v96), 1.0 - *(float *)&a4), vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_high_u16(v93), v94), v95), v96), *(float *)&a4)), 1.0 - *(float *)&a5),
                                                  vmulq_n_f32(vaddq_f32(vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v97.i8), v94), v95), v96), 1.0 - *(float *)&a4), vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_high_u16(v97), v94), v95), v96), *(float *)&a4)), *(float *)&a5)));
        v12 = (float16x4_t)vextq_s8(v98, v98, 8uLL).u64[0];
        return *(double *)&v12;
      default:
        if (v13 == 535)
        {
LABEL_47:
          v99 = vmovl_u8(*(uint8x8_t *)a2->f32);
          v100 = (int8x16_t)vdupq_n_s32(0x4B400000u);
          v101 = (float32x4_t)vdupq_n_s32(0xCB400000);
          v102 = (float32x4_t)vdupq_n_s32(0x437F0000u);
          v103 = vmovl_u8(*(uint8x8_t *)a3->f32);
          v104 = (int8x16_t)vaddq_f32(vmulq_n_f32(vaddq_f32(vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v99.i8), v100), v101), v102), 1.0 - *(float *)&a4), vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_high_u16(v99), v100), v101), v102), *(float *)&a4)), 1.0 - *(float *)&a5), vmulq_n_f32(vaddq_f32(vmulq_n_f32(vdivq_f32(
                                      vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v103.i8), v100), v101), v102), 1.0 - *(float *)&a4), vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_high_u16(v103), v100), v101), v102), *(float *)&a4)), *(float *)&a5));
          v12 = (float16x4_t)vextq_s8(v104, v104, 4uLL).u64[0];
        }
        break;
    }
    return *(double *)&v12;
  }
  if (v13 <= 2304)
  {
    switch(v13)
    {
      case 2049:
      case 2050:
      case 2051:
      case 2053:
        v32.f32[0] = 1.0 - *(float *)&a4;
        v32.i32[1] = LODWORD(a4);
        v15.f32[0] = 1.0 - *(float *)&a5;
        v15.i32[1] = LODWORD(a5);
        LODWORD(a5) = a2->i32[0];
        v12.i32[0] = a3->i32[0];
        v33 = (int32x2_t)vmul_f32(v32, (float32x2_t)*(_OWORD *)&vcvtq_f32_f16(*(float16x4_t *)&a5));
        v34 = (int32x2_t)vmul_f32(v32, (float32x2_t)*(_OWORD *)&vcvtq_f32_f16(v12));
        goto LABEL_38;
      case 2052:
      case 2054:
        *(float *)&a7 = 1.0 - *(float *)&a4;
        *(int32x2_t *)v59.f32 = vdup_lane_s32(*(int32x2_t *)&a7, 0);
        *(int32x2_t *)&v59.u32[2] = vdup_lane_s32(*(int32x2_t *)&a4, 0);
        v60 = 1.0 - *(float *)&a5;
        v61 = vcvtq_f32_f16(*(float16x4_t *)a2->f32);
        v62 = vcvtq_f32_f16(*(float16x4_t *)a3->f32);
        goto LABEL_40;
      case 2055:
        v120 = 1.0 - *(float *)&a4;
        v24 = 1.0 - *(float *)&a5;
        v29 = vmulq_n_f32(vcvtq_f32_f16((float16x4_t)vzip2_s32(*(int32x2_t *)a2->f32, 0)), *(float *)&a4);
        v28 = vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)a2->f32), 1.0 - *(float *)&a4);
        v31 = vmulq_n_f32(vcvtq_f32_f16((float16x4_t)vzip2_s32(*(int32x2_t *)a3->f32, 0)), *(float *)&a4);
        v30 = vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)a3->f32), v120);
LABEL_51:
        v119 = vaddq_f32(v28, v29);
LABEL_52:
        v115 = vmulq_n_f32(vaddq_f32(v30, v31), *(float *)&a5);
        v116 = vmulq_n_f32(v119, v24);
LABEL_53:
        v12 = (float16x4_t)vaddq_f32(v116, v115).u64[0];
        break;
      case 2056:
      case 2060:
        v69 = 1.0 - *(float *)&a4;
        v52 = 1.0 - *(float *)&a5;
        v70 = vmulq_n_f32(vcvt_hight_f32_f16(*(float16x8_t *)a2), *(float *)&a4);
        v71 = vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)a2->f32), 1.0 - *(float *)&a4);
        v66 = vmulq_n_f32(vcvt_hight_f32_f16(*(float16x8_t *)a3), *(float *)&a4);
        v67 = vmulq_n_f32(vcvtq_f32_f16(*(float16x4_t *)a3->f32), v69);
        v68 = vaddq_f32(v71, v70);
        goto LABEL_43;
      default:
        return *(double *)&v12;
    }
  }
  else
  {
    if (v13 <= 2566)
    {
      switch(v13)
      {
        case 2305:
        case 2306:
        case 2307:
        case 2309:
          v14.f32[0] = 1.0 - *(float *)&a4;
          v14.i32[1] = LODWORD(a4);
          v15.f32[0] = 1.0 - *(float *)&a5;
          v15.i32[1] = LODWORD(a5);
          v22 = *(float32x2_t *)a2->f32;
          v23 = *(float32x2_t *)a3->f32;
          goto LABEL_37;
        case 2308:
        case 2310:
          *(float *)&a7 = 1.0 - *(float *)&a4;
          *(int32x2_t *)v59.f32 = vdup_lane_s32(*(int32x2_t *)&a7, 0);
          *(int32x2_t *)&v59.u32[2] = vdup_lane_s32(*(int32x2_t *)&a4, 0);
          v60 = 1.0 - *(float *)&a5;
          v61 = *a2;
          v62 = *a3;
          goto LABEL_40;
        case 2311:
          v117 = vmulq_n_f32(*a2, 1.0 - *(float *)&a4);
          v24 = 1.0 - *(float *)&a5;
          v30 = vmulq_n_f32(*a3, 1.0 - *(float *)&a4);
          v118 = vmulq_n_f32((float32x4_t)(unint64_t)(*(__int128 *)a2 >> 32), *(float *)&a4);
          v31 = vmulq_n_f32((float32x4_t)(unint64_t)(*(__int128 *)a3 >> 32), *(float *)&a4);
          v119 = vaddq_f32(v117, v118);
          goto LABEL_52;
        case 2312:
        case 2316:
          v63 = 1.0 - *(float *)&a4;
          v52 = 1.0 - *(float *)&a5;
          v64 = vmulq_n_f32(a2[1], *(float *)&a4);
          v65 = vmulq_n_f32(*a2, 1.0 - *(float *)&a4);
          v66 = vmulq_n_f32(a3[1], *(float *)&a4);
          v67 = vmulq_n_f32(*a3, v63);
          v68 = vaddq_f32(v65, v64);
          goto LABEL_43;
        default:
          return *(double *)&v12;
      }
      return *(double *)&v12;
    }
    if (v13 <= 3080)
    {
      if (v13 != 2567)
      {
        if (v13 == 2569)
        {
LABEL_27:
          v51 = 1.0 - *(float *)&a4;
          v52 = 1.0 - *(float *)&a5;
          v53 = *(uint16x8_t *)a3;
          v54 = (int8x16_t)vdupq_n_s32(0x4B400000u);
          v55 = (float32x4_t)vdupq_n_s32(0xCB400000);
          v56 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
          v57 = vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)a2->f32), v54), v55), v56);
          v58 = vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_high_u16(*(uint16x8_t *)a2), v54), v55), v56);
LABEL_42:
          v85 = vmulq_n_f32(v58, *(float *)&a4);
          v86 = vmulq_n_f32(v57, v51);
          v66 = vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_high_u16(v53), v54), v55), v56), *(float *)&a4);
          v67 = vmulq_n_f32(vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v53.i8), v54), v55), v56), v51);
          v68 = vaddq_f32(v86, v85);
LABEL_43:
          v12 = (float16x4_t)vaddq_f32(vmulq_n_f32(v68, v52), vmulq_n_f32(vaddq_f32(v67, v66), *(float *)&a5)).u64[0];
          return *(double *)&v12;
        }
        if (v13 != 3079)
          return *(double *)&v12;
      }
LABEL_26:
      v36 = 1.0 - *(float *)&a4;
      *(uint32x2_t *)a8.i8 = vshl_u32((uint32x2_t)vdup_n_s32(a2->u32[1]), (uint32x2_t)0xFFFFFFECFFFFFFF6);
      a11.i32[0] = a2->i32[0];
      a11.i32[1] = (unsigned __int32)a2->i32[0] >> 10;
      a11.i32[2] = (unsigned __int32)a2->i32[0] >> 20;
      v11.i32[0] = a2->i32[1];
      v37 = vextq_s8(vextq_s8(v11, v11, 4uLL), a8, 0xCuLL);
      v38 = (uint32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.i8, 0);
      v39.i64[0] = 0x300000003;
      v39.i64[1] = 0x300000003;
      v40 = (uint32x4_t)vandq_s8(v37, v39);
      v41 = (uint32x4_t)vandq_s8(a11, v39);
      v42 = (int8x16_t)vshlq_u32(v38, (uint32x4_t)xmmword_19248E060);
      v40.i32[3] = v42.i32[3];
      v41.i32[3] = vshlq_u32((uint32x4_t)vdupq_n_s32(*(_DWORD *)a2), (uint32x4_t)xmmword_19248E060).i32[3];
      v43 = vcvtq_f32_u32(vcvtq_u32_f32(vdivq_f32(vcvtq_f32_u32(v40), (float32x4_t)xmmword_19248E070)));
      v44 = vcvtq_f32_u32(vcvtq_u32_f32(vdivq_f32(vcvtq_f32_u32(v41), (float32x4_t)xmmword_19248E070)));
      v45 = vmulq_n_f32(v43, *(float *)&a4);
      v46 = vmulq_n_f32(v44, v36);
      *(uint32x2_t *)v43.f32 = vshl_u32((uint32x2_t)vdup_n_s32(a3->u32[1]), (uint32x2_t)0xFFFFFFECFFFFFFF6);
      v44.i32[0] = a3->i32[0];
      v44.i32[1] = (unsigned __int32)a3->i32[0] >> 10;
      v44.i32[2] = (unsigned __int32)a3->i32[0] >> 20;
      v42.i32[0] = a3->i32[1];
      v47 = vextq_s8(vextq_s8(v42, v42, 4uLL), (int8x16_t)v43, 0xCuLL);
      v48 = (uint32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.i8, 0);
      v49 = (uint32x4_t)vandq_s8(v47, v39);
      v50 = (uint32x4_t)vandq_s8((int8x16_t)v44, v39);
      v49.i32[3] = vshlq_u32(v48, (uint32x4_t)xmmword_19248E060).i32[3];
      v50.i32[3] = vshlq_u32((uint32x4_t)vdupq_n_s32(*(_DWORD *)a3), (uint32x4_t)xmmword_19248E060).i32[3];
      v12 = (float16x4_t)vaddq_f32(vaddq_f32(v46, v45), vaddq_f32(vmulq_n_f32(vcvtq_f32_u32(vcvtq_u32_f32(vdivq_f32(vcvtq_f32_u32(v50), (float32x4_t)xmmword_19248E070))), 1.0 - *(float *)&a5), vmulq_n_f32(vcvtq_f32_u32(vcvtq_u32_f32(vdivq_f32(vcvtq_f32_u32(v49), (float32x4_t)xmmword_19248E070))), *(float *)&a5))).u64[0];
      return *(double *)&v12;
    }
    if (v13 <= 3332)
    {
      if (v13 != 3081)
      {
        if (v13 != 3331)
          return *(double *)&v12;
        goto LABEL_35;
      }
      goto LABEL_27;
    }
    if (v13 == 3333)
    {
LABEL_35:
      v14.f32[0] = 1.0 - *(float *)&a4;
      v14.i32[1] = LODWORD(a4);
      v15.f32[0] = 1.0 - *(float *)&a5;
      v15.i32[1] = LODWORD(a5);
      v75.i32[0] = a2->u16[0];
      v75.i32[1] = a2->u16[1];
      v17.i32[0] = a3->u16[0];
      v17.i32[1] = a3->u16[1];
      v18 = (int8x8_t)vdup_n_s32(0x4B400000u);
      v19 = (float32x2_t)vdup_n_s32(0xCB400000);
      v20 = vadd_f32((float32x2_t)vorr_s8(v75, v18), v19);
      v21 = 1199570688;
LABEL_36:
      v76 = (float32x2_t)vdup_n_s32(v21);
      v22 = vdiv_f32(v20, v76);
      v23 = vdiv_f32(vadd_f32((float32x2_t)vorr_s8(v17, v18), v19), v76);
LABEL_37:
      v33 = (int32x2_t)vmul_f32(v14, v22);
      v34 = (int32x2_t)vmul_f32(v14, v23);
LABEL_38:
      v77 = vmul_f32(v15, vadd_f32((float32x2_t)vzip1_s32(v33, v34), (float32x2_t)vzip2_s32(v33, v34)));
      v12 = (float16x4_t)vadd_f32(v77, (float32x2_t)vdup_lane_s32((int32x2_t)v77, 1)).u32[0];
      return *(double *)&v12;
    }
    if (v13 == 3334)
    {
LABEL_34:
      *(float *)&a7 = 1.0 - *(float *)&a4;
      *(int32x2_t *)v59.f32 = vdup_lane_s32(*(int32x2_t *)&a7, 0);
      *(int32x2_t *)&v59.u32[2] = vdup_lane_s32(*(int32x2_t *)&a4, 0);
      v60 = 1.0 - *(float *)&a5;
      v72 = (int8x16_t)vdupq_n_s32(0x4B400000u);
      v73 = (float32x4_t)vdupq_n_s32(0xCB400000);
      v74 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
      v61 = vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)a2->f32), v72), v73), v74);
      v62 = vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)a3->f32), v72), v73), v74);
LABEL_40:
      v81 = (int8x16_t)vmulq_f32(v59, v61);
      v82 = (int8x16_t)vmulq_f32(v59, v62);
      v12 = (float16x4_t)vadd_f32(vmul_n_f32(vadd_f32(*(float32x2_t *)v81.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v81, v81, 8uLL)), v60), vmul_n_f32(vadd_f32(*(float32x2_t *)v82.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v82, v82, 8uLL)), *(float *)&a5));
    }
  }
  return *(double *)&v12;
}

double CI::BitmapSampler::read(CI::BitmapSampler *this, unsigned __int8 *a2, double a3, int8x16_t a4)
{
  int v5;
  float v6;
  int8x8_t v7;
  float32x2_t v8;
  unsigned int v14;
  int8x16_t v15;
  uint32x4_t v16;
  float32x4_t v17;
  unsigned int v18;
  int8x8_t v19;
  float32x2_t v20;
  float32x2_t v21;
  unsigned int v22;
  int8x8_t v23;
  int8x8_t v24;

  _Q0.i64[0] = 0;
  v5 = *((_DWORD *)this + 26);
  if (v5 <= 2048)
  {
    if (v5 > 770)
    {
      switch(v5)
      {
        case 1793:
        case 1794:
        case 1795:
        case 1797:
          goto LABEL_36;
        case 1796:
        case 1798:
          goto LABEL_35;
        case 1799:
          v7.i32[0] = *(unsigned __int16 *)a2;
          v7.i32[1] = *((unsigned __int16 *)a2 + 1);
          v8 = vdiv_f32(vadd_f32((float32x2_t)vorr_s8(v7, (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), (float32x2_t)vdup_n_s32(0x477FFF00u));
          goto LABEL_54;
        case 1800:
        case 1801:
        case 1804:
          goto LABEL_27;
        case 1802:
        case 1803:
          return *(double *)_Q0.i64;
        default:
          v14 = v5 - 771;
          if (v14 > 0xE)
            return *(double *)_Q0.i64;
          if (((1 << v14) & 0x6010) != 0)
            goto LABEL_26;
          if (((1 << v14) & 5) != 0)
            goto LABEL_36;
          if (v14 != 3)
            return *(double *)_Q0.i64;
          goto LABEL_35;
      }
    }
    switch(v5)
    {
      case 257:
        _Q0.i64[0] = 0;
        return *(double *)_Q0.i64;
      case 258:
      case 259:
      case 261:
        _Q0.i8[0] = *a2;
        _Q0.f32[0] = (float)_Q0.u32[0];
        v6 = 255.0;
        goto LABEL_37;
      case 260:
      case 262:
        v23.i32[0] = *a2;
        v23.i32[1] = a2[1];
        v20 = (float32x2_t)vorr_s8(v23, (int8x8_t)vdup_n_s32(0x4B400000u));
        v21 = (float32x2_t)vdup_n_s32(0xCB400000);
        v22 = 1132396544;
        goto LABEL_41;
      case 263:
        v24.i32[0] = *a2;
        v24.i32[1] = a2[1];
        v8 = vdiv_f32(vadd_f32((float32x2_t)vorr_s8(v24, (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), (float32x2_t)vdup_n_s32(0x437F0000u));
        goto LABEL_54;
      case 264:
      case 268:
        _Q0.i32[0] = *(_DWORD *)a2;
        _Q0 = vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)_Q0.f32)), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000));
        v18 = 1132396544;
        goto LABEL_44;
      case 265:
      case 269:
        goto LABEL_49;
      case 266:
      case 270:
        _Q0.i32[0] = *(_DWORD *)a2;
        _Q0 = (float32x4_t)vrev64q_s32((int32x4_t)vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)_Q0.f32)), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000)), (float32x4_t)vdupq_n_s32(0x437F0000u)));
        _Q0.i64[0] = vextq_s8((int8x16_t)_Q0, (int8x16_t)_Q0, 0xCuLL).u64[0];
        return *(double *)_Q0.i64;
      case 267:
      case 271:
        _Q0.i32[0] = *(_DWORD *)a2;
        _Q0 = (float32x4_t)vrev64q_s32((int32x4_t)vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)_Q0.f32)), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000)), (float32x4_t)vdupq_n_s32(0x437F0000u)));
        _Q0.i64[0] = vextq_s8((int8x16_t)_Q0, (int8x16_t)_Q0, 8uLL).u64[0];
        return *(double *)_Q0.i64;
      default:
        if (v5 == 535)
        {
LABEL_49:
          _Q0.i32[0] = *(_DWORD *)a2;
          _Q0 = vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)_Q0.f32)), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000)), (float32x4_t)vdupq_n_s32(0x437F0000u));
          _Q0.i64[0] = vextq_s8((int8x16_t)_Q0, (int8x16_t)_Q0, 4uLL).u64[0];
        }
        break;
    }
    return *(double *)_Q0.i64;
  }
  if (v5 > 2304)
  {
    if (v5 <= 2566)
    {
      switch(v5)
      {
        case 2305:
        case 2306:
        case 2307:
        case 2309:
          _Q0.i32[0] = *(_DWORD *)a2;
          goto LABEL_38;
        case 2308:
        case 2310:
          _Q0.i64[0] = *(_QWORD *)a2;
          break;
        case 2311:
          __asm { FMOV            V0.4S, #1.0 }
          _Q0.i64[0] = *(_QWORD *)a2;
          break;
        case 2312:
        case 2316:
          _Q0 = *(float32x4_t *)a2;
          break;
        default:
          return *(double *)_Q0.i64;
      }
      return *(double *)_Q0.i64;
    }
    if (v5 > 3080)
    {
      if (v5 > 3332)
      {
        if (v5 != 3333)
        {
          if (v5 == 3334)
          {
LABEL_35:
            v19.i32[0] = *(unsigned __int16 *)a2;
            v19.i32[1] = *((unsigned __int16 *)a2 + 1);
            v20 = (float32x2_t)vorr_s8(v19, (int8x8_t)vdup_n_s32(0x4B400000u));
            v21 = (float32x2_t)vdup_n_s32(0xCB400000);
            v22 = 1199570688;
LABEL_41:
            *(float32x2_t *)_Q0.f32 = vdiv_f32(vadd_f32(v20, v21), (float32x2_t)vdup_n_s32(v22));
          }
          return *(double *)_Q0.i64;
        }
        goto LABEL_36;
      }
      if (v5 != 3081)
      {
        if (v5 != 3331)
          return *(double *)_Q0.i64;
LABEL_36:
        _Q0.i16[0] = *(_WORD *)a2;
        _Q0.f32[0] = (float)_Q0.u32[0];
        v6 = 65535.0;
LABEL_37:
        _Q0.f32[0] = _Q0.f32[0] / v6;
LABEL_38:
        _Q0.i32[1] = 0;
        return *(double *)_Q0.i64;
      }
      goto LABEL_27;
    }
    if (v5 != 2567)
    {
      if (v5 == 2569)
      {
LABEL_27:
        _Q0 = vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)a2), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000));
        v18 = 1199570688;
LABEL_44:
        v17 = (float32x4_t)vdupq_n_s32(v18);
        goto LABEL_45;
      }
      if (v5 != 3079)
        return *(double *)_Q0.i64;
    }
LABEL_26:
    a4.i32[0] = *(_DWORD *)a2;
    a4.i32[1] = *(_DWORD *)a2 >> 10;
    a4.i32[2] = *(_DWORD *)a2 >> 20;
    v15.i64[0] = 0x300000003;
    v15.i64[1] = 0x300000003;
    v16 = (uint32x4_t)vandq_s8(a4, v15);
    v16.i32[3] = vshrq_n_u32((uint32x4_t)vdupq_n_s32(*(_DWORD *)a2), 0x1EuLL).i32[3];
    _Q0 = vcvtq_f32_u32(v16);
    v17 = (float32x4_t)xmmword_19248E070;
LABEL_45:
    _Q0.i64[0] = vdivq_f32(_Q0, v17).u64[0];
    return *(double *)_Q0.i64;
  }
  switch(v5)
  {
    case 2049:
    case 2050:
    case 2051:
    case 2053:
      _H0 = *(_WORD *)a2;
      __asm { FCVT            S0, H0 }
      goto LABEL_38;
    case 2052:
    case 2054:
      _Q0.i32[0] = *(_DWORD *)a2;
      _Q0.i64[0] = vcvtq_f32_f16(*(float16x4_t *)_Q0.f32).u64[0];
      break;
    case 2055:
      _Q0.i32[0] = *(_DWORD *)a2;
      v8 = (float32x2_t)vcvtq_f32_f16(*(float16x4_t *)_Q0.f32).u64[0];
      _H0 = *((_WORD *)a2 + 2);
      __asm { FCVT            S2, H0 }
LABEL_54:
      __asm { FMOV            V0.4S, #1.0 }
      *(float32x2_t *)_Q0.f32 = v8;
      break;
    case 2056:
    case 2060:
      _Q0.i64[0] = vcvtq_f32_f16(*(float16x4_t *)a2).u64[0];
      break;
    default:
      return *(double *)_Q0.i64;
  }
  return *(double *)_Q0.i64;
}

uint64_t CI::BitmapSampler::write(uint64_t this, IPoint a2, const vec4 *a3)
{
  unint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  int var1;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int16x8_t v15;
  unsigned __int32 v16;
  uint64_t v17;
  float v18;
  float v19;
  float v21;
  int v22;
  float v23;
  float v24;
  float v25;
  int v26;
  __int128 v30;
  float32x2_t v31;
  int32x2_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int16x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  int8x16_t v40;
  int8x16_t v41;
  __int32 v42;
  float32x2_t v43;
  int32x2_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float16x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float16x4_t v50;
  NSObject *v51;
  uint64_t v52;
  NSObject *v53;
  uint64_t v54;
  uint64_t v55;
  NSObject *v56;
  uint64_t v57;
  NSObject *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int var0;
  int v63;
  uint8_t buf[4];
  int v65;
  __int16 v66;
  int v67;
  __int16 v68;
  uint64_t v69;
  __int16 v70;
  uint64_t v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v4 = (uint64_t *)(this + 80);
  v3 = *(_QWORD *)(this + 80);
  if (!v3 || (v5 = *(_QWORD *)(this + 88)) == 0)
  {
    v61 = this;
    v51 = ci_logger_render();
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      CI::BitmapSampler::write(v4, v61, v51);
    goto LABEL_62;
  }
  var1 = a2.var1;
  _CF = a2.var1 >= v5 || a2.var0 >= v3;
  if (_CF || (*(_QWORD *)&a2 & 0x8000000000000000) != 0 || a2.var0 < 0)
  {
    var0 = a2.var0;
    v52 = this;
    v53 = ci_logger_render();
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      v54 = *(_QWORD *)(v52 + 80);
      v55 = *(_QWORD *)(v52 + 88);
      *(_DWORD *)buf = 67240960;
      v65 = var0;
      v66 = 1026;
      v67 = var1;
      v68 = 2050;
      v69 = v54;
      v70 = 2050;
      v71 = v55;
      v56 = v53;
      goto LABEL_67;
    }
LABEL_62:
    abort();
  }
  v8 = *(_QWORD *)(this + 120);
  v9 = *(_QWORD *)(this + 96);
  v10 = v9 * v5;
  v11 = v8 * a2.var0 + v9 * a2.var1;
  if (v11 >= v10)
  {
    v63 = a2.var0;
    v57 = this;
    v58 = ci_logger_render();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
    {
      v59 = *(_QWORD *)(v57 + 80);
      v60 = *(_QWORD *)(v57 + 88);
      *(_DWORD *)buf = 67240960;
      v65 = v63;
      v66 = 1026;
      v67 = var1;
      v68 = 2050;
      v69 = v59;
      v70 = 2050;
      v71 = v60;
      v56 = v58;
LABEL_67:
      _os_log_error_impl(&dword_1921E4000, v56, OS_LOG_TYPE_ERROR, "Bitmap write error: Accessing out of bound p:(%{public}d , %{public}d) size:(%{public}zu , %{public}zu)", buf, 0x22u);
      abort();
    }
    goto LABEL_62;
  }
  v12 = *(_QWORD *)(this + 72) + v11;
  if ((*(_DWORD *)(this + 104) | 4) == 0x10E)
  {
    v13 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    v14.i64[0] = 0x3F0000003F000000;
    v14.i64[1] = 0x3F0000003F000000;
    v15 = (int16x8_t)vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v14, v13, *(float32x4_t *)a3), (float32x4_t)0), v13));
    *(int16x4_t *)v15.i8 = vrev32_s16(vmovn_s32((int32x4_t)v15));
    *(int8x8_t *)v15.i8 = vext_s8(*(int8x8_t *)v15.i8, *(int8x8_t *)v15.i8, 6uLL);
LABEL_12:
    v16 = vmovn_s16(v15).u32[0];
LABEL_13:
    *(_DWORD *)v12 = v16;
  }
  else
  {
    v17 = *(_QWORD *)(this + 128);
    if (*(_BYTE *)(this + 136) || v17 != 8)
    {
      if (*(_BYTE *)(this + 136) || v17 != 16)
      {
        if (*(_BYTE *)(this + 136) && v17 == 16)
        {
          switch(v8)
          {
            case 2:
              _S0 = *(_DWORD *)a3;
              __asm { FCVT            H0, S0 }
              *(_WORD *)v12 = _S0;
              break;
            case 4:
              v16 = vcvt_f16_f32(*(float32x4_t *)a3).u32[0];
              goto LABEL_13;
            case 6:
              v47 = vcvt_f16_f32(*(float32x4_t *)a3);
LABEL_54:
              *(_DWORD *)v12 = v47.i32[0];
              *(_WORD *)(v12 + 4) = v47.i16[2];
              break;
            case 8:
              v50 = vcvt_f16_f32(*(float32x4_t *)a3);
              goto LABEL_56;
            default:
              return this;
          }
        }
        else if (*(_BYTE *)(this + 136) && v17 == 32)
        {
          *((_QWORD *)&v30 + 1) = *(_QWORD *)(this + 120);
          *(_QWORD *)&v30 = v8 - 4;
          switch((unint64_t)(v30 >> 2))
          {
            case 0uLL:
              *(_DWORD *)v12 = *(_DWORD *)a3;
              break;
            case 1uLL:
              *(_QWORD *)v12 = *(_QWORD *)a3;
              break;
            case 2uLL:
              *(_DWORD *)v12 = *(_DWORD *)a3;
              *(_DWORD *)(v12 + 4) = *((_DWORD *)a3 + 1);
              *(_DWORD *)(v12 + 8) = *((_DWORD *)a3 + 2);
              break;
            case 3uLL:
              *(_OWORD *)v12 = *(_OWORD *)a3;
              break;
            default:
              return this;
          }
        }
        else if (v8 == 4 && v17 == 10)
        {
          v38 = (float32x4_t)vdupq_n_s32(0x447FC000u);
          v39.i64[0] = 0x3F0000003F000000;
          v39.i64[1] = 0x3F0000003F000000;
          v40 = (int8x16_t)vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v39, v38, *(float32x4_t *)a3), (float32x4_t)0), v38));
          v38.i64[0] = 0xFFFF0000FFFFLL;
          v38.i64[1] = 0xFFFF0000FFFFLL;
          v41 = vandq_s8(v40, (int8x16_t)v38);
          v42 = v41.i32[0];
          v41.i32[0] = vextq_s8(v41, v41, 8uLL).i32[1];
          *(uint32x2_t *)v40.i8 = vshl_u32(*(uint32x2_t *)v41.i8, (uint32x2_t)0xA0000001ELL);
          *(_DWORD *)v12 = v42 | (v40.i32[2] << 20) | v40.i32[0] | v40.i32[1];
        }
        else if (v8 == 8 && v17 == 10)
        {
LABEL_51:
          v48 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
          v49.i64[0] = 0x3F0000003F000000;
          v49.i64[1] = 0x3F0000003F000000;
          v50 = (float16x4_t)vmovn_s32(vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v49, v48, *(float32x4_t *)a3), (float32x4_t)0), v48)));
LABEL_56:
          *(float16x4_t *)v12 = v50;
        }
      }
      else
      {
        switch(v8)
        {
          case 2:
            v23 = 65535.0;
            v24 = (float)(*(float *)a3 * 65535.0) + 0.5;
            if (v24 <= 65535.0)
              v23 = (float)(*(float *)a3 * 65535.0) + 0.5;
            _NF = v24 < 0.0;
            v25 = 0.0;
            if (!_NF)
              v25 = v23;
            v26 = (int)v25;
            goto LABEL_47;
          case 4:
            v43 = (float32x2_t)vdup_n_s32(0x477FFF00u);
            v44 = vcvt_s32_f32(vminnm_f32(vmaxnm_f32(vmla_f32((float32x2_t)0x3F0000003F000000, v43, *(float32x2_t *)a3), 0), v43));
            *(_WORD *)(v12 + 2) = v44.i16[2];
            LOWORD(v26) = v44.i16[0];
LABEL_47:
            *(_WORD *)v12 = v26;
            break;
          case 6:
            v45 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
            v46.i64[0] = 0x3F0000003F000000;
            v46.i64[1] = 0x3F0000003F000000;
            v47 = (float16x4_t)vmovn_s32(vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v46, v45, *(float32x4_t *)a3), (float32x4_t)0), v45)));
            goto LABEL_54;
          case 8:
            goto LABEL_51;
          default:
            return this;
        }
      }
    }
    else
    {
      switch(v8)
      {
        case 1:
          v18 = 255.0;
          v19 = (float)(*(float *)a3 * 255.0) + 0.5;
          if (v19 <= 255.0)
            v18 = (float)(*(float *)a3 * 255.0) + 0.5;
          _NF = v19 < 0.0;
          v21 = 0.0;
          if (!_NF)
            v21 = v18;
          v22 = (int)v21;
          goto LABEL_40;
        case 2:
          v31 = (float32x2_t)vdup_n_s32(0x437F0000u);
          v32 = vcvt_s32_f32(vminnm_f32(vmaxnm_f32(vmla_f32((float32x2_t)0x3F0000003F000000, v31, *(float32x2_t *)a3), 0), v31));
          *(_BYTE *)(v12 + 1) = v32.i8[4];
          LOBYTE(v22) = v32.i8[0];
LABEL_40:
          *(_BYTE *)v12 = v22;
          break;
        case 3:
          v33 = (float32x4_t)vdupq_n_s32(0x437F0000u);
          v34.i64[0] = 0x3F0000003F000000;
          v34.i64[1] = 0x3F0000003F000000;
          v35 = vmovn_s32(vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v34, v33, *(float32x4_t *)a3), (float32x4_t)0), v33)));
          *(_BYTE *)v12 = v35.i8[0];
          *(_BYTE *)(v12 + 1) = v35.i8[2];
          *(_BYTE *)(v12 + 2) = v35.i8[4];
          break;
        case 4:
          v36 = (float32x4_t)vdupq_n_s32(0x437F0000u);
          v37.i64[0] = 0x3F0000003F000000;
          v37.i64[1] = 0x3F0000003F000000;
          v15 = (int16x8_t)vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v37, v36, *(float32x4_t *)a3), (float32x4_t)0), v36));
          *(int16x4_t *)v15.i8 = vmovn_s32((int32x4_t)v15);
          goto LABEL_12;
        default:
          return this;
      }
    }
  }
  return this;
}

uint64_t std::map<std::string,CI::SWFunction>::map[abi:nn180100](uint64_t a1, void **a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v6;

  *(_QWORD *)(a1 + 8) = 0;
  v4 = a1 + 8;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  if (a3)
  {
    v6 = 48 * a3;
    do
    {
      std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,CI::SWFunction> const&>((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 6;
      v6 -= 48;
    }
    while (v6);
  }
  return a1;
}

void sub_1922077F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::destroy(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,CI::SWFunction> const&>(uint64_t **a1, uint64_t a2, void **a3, uint64_t a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;
  void **v10;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__find_equal<std::string>(a1, a2, &v10, &v9, a3);
  result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__construct_node<std::pair<std::string const,CI::SWFunction> const&>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v10, v6, v8);
    return v8;
  }
  return result;
}

void **std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__find_equal<std::string>(_QWORD *a1, uint64_t a2, void ***a3, uint64_t *a4, void **a5)
{
  void **v9;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  void **v14;
  void **v15;
  _QWORD *v16;
  BOOL v17;
  void **v19;

  v9 = (void **)(a1 + 1);
  if (a1 + 1 == (_QWORD *)a2
    || (std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a5, (void **)(a2 + 32)) & 0x80) != 0)
  {
    if (*a1 == a2)
    {
      v12 = (_QWORD *)a2;
    }
    else
    {
      v11 = *(_QWORD **)a2;
      if (*(_QWORD *)a2)
      {
        do
        {
          v12 = v11;
          v11 = (_QWORD *)v11[1];
        }
        while (v11);
      }
      else
      {
        v16 = (_QWORD *)a2;
        do
        {
          v12 = (_QWORD *)v16[2];
          v17 = *v12 == (_QWORD)v16;
          v16 = v12;
        }
        while (v17);
      }
      if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v12 + 4, a5) & 0x80) == 0)
        return (void **)std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__find_equal<std::string>((uint64_t)a1, a3, a5);
    }
    if (*(_QWORD *)a2)
    {
      *a3 = (void **)v12;
      return (void **)(v12 + 1);
    }
    else
    {
      *a3 = (void **)a2;
      return (void **)a2;
    }
  }
  if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)(a2 + 32), a5) & 0x80) != 0)
  {
    a4 = (uint64_t *)(a2 + 8);
    v13 = *(_QWORD *)(a2 + 8);
    if (v13)
    {
      v14 = *(void ***)(a2 + 8);
      do
      {
        v15 = v14;
        v14 = (void **)*v14;
      }
      while (v14);
    }
    else
    {
      v19 = (void **)a2;
      do
      {
        v15 = (void **)v19[2];
        v17 = *v15 == v19;
        v19 = v15;
      }
      while (!v17);
    }
    if (v15 == v9)
      goto LABEL_27;
    if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a5, v15 + 4) & 0x80) != 0)
    {
      v13 = *a4;
LABEL_27:
      if (v13)
      {
        *a3 = v15;
        return v15;
      }
      else
      {
        *a3 = (void **)a2;
      }
      return (void **)a4;
    }
    return (void **)std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__find_equal<std::string>((uint64_t)a1, a3, a5);
  }
  *a3 = (void **)a2;
  *a4 = a2;
  return (void **)a4;
}

__n128 std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__construct_node<std::pair<std::string const,CI::SWFunction> const&>@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;
  __n128 result;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x50uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    *((_QWORD *)v6 + 6) = *(_QWORD *)(a2 + 16);
  }
  result = *(__n128 *)(a2 + 24);
  *(__n128 *)(v6 + 56) = result;
  *((_QWORD *)v6 + 9) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_192207A9C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,CI::SWFunction>,void *>>>::operator()[abi:nn180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

_QWORD *std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, void **a3)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = v4;
        v8 = v4 + 4;
        if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a3, (void **)v4 + 4) & 0x80) == 0)
          break;
        v4 = (_QWORD *)*v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v8, a3) & 0x80) == 0)
        break;
      v5 = v7 + 1;
      v4 = (_QWORD *)v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(_QWORD *a1, void **a2)
{
  size_t v2;
  size_t v3;
  int v4;
  void *v5;
  size_t v6;

  v2 = *((unsigned __int8 *)a1 + 23);
  v3 = a1[1];
  if ((v2 & 0x80u) != 0)
  {
    a1 = (_QWORD *)*a1;
    v2 = v3;
  }
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = a2;
  else
    v5 = *a2;
  if (v4 >= 0)
    v6 = *((unsigned __int8 *)a2 + 23);
  else
    v6 = (size_t)a2[1];
  return std::operator<=>[abi:nn180100]<char,std::char_traits<char>>(a1, v2, v5, v6);
}

uint64_t std::operator<=>[abi:nn180100]<char,std::char_traits<char>>(const void *a1, size_t a2, void *__s2, size_t a4)
{
  size_t v7;
  int v8;

  if (a4 >= a2)
    v7 = a2;
  else
    v7 = a4;
  v8 = memcmp(a1, __s2, v7);
  if (v8)
  {
    if ((v8 & 0x80000000) == 0)
      return 1;
  }
  else
  {
    if (a2 == a4)
      return 0;
    if (a2 >= a4)
      return 1;
  }
  return 255;
}

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,CI::SWFunction>,void *>>>::operator()[abi:nn180100](uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0)
      operator delete(__p[4]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::destroy(a1, *(_QWORD *)a2);
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::destroy(a1, *((_QWORD *)a2 + 1));
    if (a2[55] < 0)
      operator delete(*((void **)a2 + 4));
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:nn180100]<std::pair<unsigned long long const,CI::DAGHelper::TextureReadFunction>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<unsigned long long const,CI::DAGHelper::TextureReadFunction>,0>(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(_QWORD *)(a1 + 40) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
}

void **std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::find<std::string>(uint64_t a1, void **a2)
{
  void **v2;
  _QWORD *v3;
  void **v5;
  char v6;
  _QWORD *v7;

  v2 = (void **)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = (void **)(a1 + 8);
  do
  {
    v6 = std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v3 + 4, a2);
    if (v6 >= 0)
      v7 = v3;
    else
      v7 = v3 + 1;
    if (v6 >= 0)
      v5 = (void **)v3;
    v3 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v5 == v2
    || (std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a2, v5 + 4) & 0x80) != 0)
  {
    return v2;
  }
  return v5;
}

uint64_t **std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, _QWORD **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t **v9;
  unint64_t v10;
  char *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = v6[4];
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = (char *)operator new(0x60uLL);
    *((_QWORD *)v11 + 4) = **a4;
    *((_QWORD *)v11 + 11) = 0;
    *(_OWORD *)(v11 + 72) = 0u;
    *(_OWORD *)(v11 + 56) = 0u;
    *(_OWORD *)(v11 + 40) = 0u;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t *std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, _QWORD **a4)
{
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t *v8;
  unint64_t v9;
  uint64_t *v11[3];

  v6 = (uint64_t **)(a1 + 8);
  v5 = *(uint64_t **)(a1 + 8);
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = v5;
        v9 = v5[4];
        if (v7 >= v9)
          break;
        v5 = (uint64_t *)*v8;
        v6 = (uint64_t **)v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = (uint64_t *)v8[1];
      if (!v5)
      {
        v6 = (uint64_t **)(v8 + 1);
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = (uint64_t *)(a1 + 8);
LABEL_10:
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(a1, a4, (uint64_t)v11);
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v8, v6, v11[0]);
    v8 = v11[0];
    v11[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>>>>::reset[abi:nn180100]((uint64_t)v11, 0);
  }
  return v8;
}

_QWORD *std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, _QWORD **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *result;

  v5 = a1 + 8;
  v6 = operator new(0x60uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v6[4] = **a2;
  result = std::string::basic_string[abi:nn180100]<0>(v6 + 5, "");
  v6[8] = 0;
  v6[9] = 0;
  *((_BYTE *)v6 + 88) = 0;
  v6[10] = 0;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1922081D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>>>>::reset[abi:nn180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,void *>>>>::reset[abi:nn180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:nn180100]<std::pair<unsigned long long const,CI::DAGHelper::TextureReadFunction>,0>((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

uint64_t *std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t **v9;
  unint64_t v10;
  uint64_t *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = v6[4];
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    v11[5] = 0;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__erase_unique<unsigned long long>(uint64_t a1, unint64_t *a2)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  BOOL v6;
  _QWORD *v7;

  v2 = *(_QWORD **)(a1 + 8);
  if (!v2)
    return 0;
  v3 = *a2;
  v4 = (uint64_t *)(a1 + 8);
  do
  {
    v5 = v2[4];
    v6 = v5 >= v3;
    if (v5 >= v3)
      v7 = v2;
    else
      v7 = v2 + 1;
    if (v6)
      v4 = v2;
    v2 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t *)(a1 + 8) || v3 < v4[4])
    return 0;
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__remove_node_pointer((uint64_t **)a1, v4);
  std::__destroy_at[abi:nn180100]<std::pair<unsigned long long const,CI::DAGHelper::TextureReadFunction>,0>((uint64_t)(v4 + 4));
  operator delete(v4);
  return 1;
}

uint64_t *std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::TextureReadFunction>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 == v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v13 = *(uint64_t **)(v12 + 8);
      v14 = *v13;
      *(_QWORD *)(v12 + 8) = *v13;
      if (v14)
        *(_QWORD *)(v14 + 16) = v12;
      v13[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
      *v13 = v12;
      *(_QWORD *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7)
        result = v7;
      v7 = *(uint64_t **)(*v7 + 8);
    }
    v15 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      v16 = (uint64_t *)v7[1];
      if (!v16)
        goto LABEL_56;
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v22 = v15[1];
        *v7 = v22;
        if (v22)
          *(_QWORD *)(v22 + 16) = v7;
        v15[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        v16 = v7;
      }
      else
      {
        v15 = v7;
      }
      v23 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v16 + 24) = 1;
      v24 = *(uint64_t **)(v23 + 8);
      v25 = *v24;
      *(_QWORD *)(v23 + 8) = *v24;
      if (v25)
        *(_QWORD *)(v25 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      *v24 = v23;
      goto LABEL_72;
    }
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_55;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v18 = v7[1];
    *(_QWORD *)v12 = v18;
    if (v18)
      *(_QWORD *)(v18 + 16) = v12;
    v7[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(_QWORD *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12)
      result = v7;
    v7 = *(uint64_t **)v12;
  }
  v19 = (_QWORD *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24))
    goto LABEL_68;
  v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
    goto LABEL_49;
  }
  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    v20 = v7;
  }
  else
  {
    *((_BYTE *)v20 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v26 = *v20;
    v7[1] = *v20;
    if (v26)
      *(_QWORD *)(v26 + 16) = v7;
    v20[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
    *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    v19 = v7;
  }
  v23 = v20[2];
  *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v19 + 24) = 1;
  v24 = *(uint64_t **)v23;
  v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
  *(_QWORD *)v23 = v27;
  if (v27)
    *(_QWORD *)(v27 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

uint64_t CI::getDC(CI *this)
{
  return CI::_thread_dc();
}

_QWORD *CI::setDC(CI *this, const vec2 *a2)
{
  _QWORD *result;
  _QWORD *v3;

  result = (_QWORD *)CI::_thread_dc();
  *result = *v3;
  return result;
}

double CI::SWRendererPipeline::initSamplers(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 *v10;
  double result;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;

  if (*(_QWORD *)(a1 + 24))
  {
    v6 = 0;
    v7 = 48;
    do
    {
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + v7);
      v9 = *(_QWORD *)(a2 + (*(_QWORD *)(v8 + 8) << 6));
      v10 = (__int128 *)(a2 + (*(_QWORD *)(v8 + 32) << 6));
      v12 = *v10;
      v13 = v10[1];
      v14 = v10[2];
      v15 = v10[3];
      *(_QWORD *)a3 = &off_1E2EB7668;
      if (v9)
        v9 = CI::Object::ref(v9);
      *(_QWORD *)(a3 + 8) = v9;
      *(_OWORD *)(a3 + 16) = v12;
      *(_OWORD *)(a3 + 32) = v13;
      *(_QWORD *)(a3 + 48) = v14;
      result = *(double *)&v15;
      *(_OWORD *)(a3 + 64) = v15;
      ++v6;
      a3 += 80;
      v7 += 72;
    }
    while (*(_QWORD *)(a1 + 24) > v6);
  }
  return result;
}

uint64_t CI::SWRendererPipeline::execute(_QWORD *a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, int *a6)
{
  float *v6;
  float v7;
  float v8;
  uint64_t v9;
  unint64_t v16;
  uint64_t v17;

  v6 = (float *)(a2 + (*(_QWORD *)(*(_QWORD *)(*a1 + 48) + 8) << 6));
  v7 = (float)*a6 + 0.5;
  v8 = (float)a6[1] + 0.5;
  *(float *)&v9 = v6[2] + (float)((float)(v6[1] * v8) + (float)(v7 * *v6));
  *((float *)&v9 + 1) = v6[5] + (float)((float)(v8 * v6[4]) + (float)(v7 * v6[3]));
  *a3 = v9;
  if (a1[2] >= 2uLL)
  {
    v16 = 1;
    v17 = 104;
    do
    {
      (*(void (**)(uint64_t, uint64_t, _QWORD *, uint64_t, uint64_t, int *, unint64_t))(*a1 + v17))(*a1 + v17 - 32, a2, a3, a4, a5, a6, v16++);
      v17 += 72;
    }
    while (a1[2] > v16);
  }
  return 1;
}

const __CFString *CoreAnayticsAppIndentifier(const __CFString *result)
{
  const __CFString *v1;
  CFIndex Length;
  CFRange v3;
  CFRange v4;
  CFRange v5;
  CFRange v6;
  CFRange v7;
  CFRange v8;
  CFRange v9;
  CFRange v10;
  CFRange v11;
  CFRange v12;
  CFRange v13;
  CFRange v14;
  CFRange v15;
  CFRange v16;
  CFRange v17;
  CFRange v18;

  if (result)
  {
    v1 = result;
    Length = CFStringGetLength(result);
    v3.location = 0;
    v3.length = Length;
    if (CFStringFindWithOptions(v1, CFSTR("com.microsoft"), v3, 1uLL, 0))
    {
      return CFSTR("Microsoft");
    }
    else
    {
      v4.location = 0;
      v4.length = Length;
      if (CFStringFindWithOptions(v1, CFSTR("com.adobe"), v4, 1uLL, 0))
      {
        return CFSTR("Adobe");
      }
      else
      {
        v5.location = 0;
        v5.length = Length;
        if (CFStringFindWithOptions(v1, CFSTR("com.google"), v5, 1uLL, 0))
        {
          return CFSTR("Google");
        }
        else
        {
          v6.location = 0;
          v6.length = Length;
          if (CFStringFindWithOptions(v1, CFSTR("com.facebook"), v6, 1uLL, 0))
          {
            return CFSTR("Facebook");
          }
          else
          {
            v7.location = 0;
            v7.length = Length;
            if (CFStringFindWithOptions(v1, CFSTR("com.burbn.instagram"), v7, 1uLL, 0))
            {
              return CFSTR("Instagram");
            }
            else
            {
              v8.location = 0;
              v8.length = Length;
              if (CFStringFindWithOptions(v1, CFSTR("com.gentlemencoders"), v8, 1uLL, 0))
              {
                return CFSTR("GentlemenCoders");
              }
              else
              {
                v9.location = 0;
                v9.length = Length;
                if (CFStringFindWithOptions(v1, CFSTR("com.fxfactory"), v9, 1uLL, 0))
                {
                  return CFSTR("FxFactory");
                }
                else
                {
                  v10.location = 0;
                  v10.length = Length;
                  if (CFStringFindWithOptions(v1, CFSTR("com.ubercab"), v10, 1uLL, 0))
                  {
                    return CFSTR("Uber");
                  }
                  else
                  {
                    v11.location = 0;
                    v11.length = Length;
                    if (CFStringFindWithOptions(v1, CFSTR("com.postmates"), v11, 1uLL, 0))
                    {
                      return CFSTR("Postmates");
                    }
                    else
                    {
                      v12.location = 0;
                      v12.length = Length;
                      if (CFStringFindWithOptions(v1, CFSTR("com.dynamicappdesign.rawplus"), v12, 1uLL, 0))
                      {
                        return CFSTR("RawPlus");
                      }
                      else
                      {
                        v13.location = 0;
                        v13.length = Length;
                        if (CFStringFindWithOptions(v1, CFSTR("com.pixelmatorteam"), v13, 1uLL, 0))
                        {
                          return CFSTR("Pixelmator");
                        }
                        else
                        {
                          v14.location = 0;
                          v14.length = Length;
                          if (CFStringFindWithOptions(v1, CFSTR("com.vidvox"), v14, 1uLL, 0))
                          {
                            return CFSTR("Vidvox");
                          }
                          else
                          {
                            v15.location = 0;
                            v15.length = Length;
                            if (CFStringFindWithOptions(v1, CFSTR("com.boinx"), v15, 1uLL, 0))
                            {
                              return CFSTR("Boinx");
                            }
                            else
                            {
                              v16.location = 0;
                              v16.length = Length;
                              if (CFStringFindWithOptions(v1, CFSTR("com.ecamm"), v16, 1uLL, 0))
                              {
                                return CFSTR("Ecamm");
                              }
                              else
                              {
                                v17.location = 0;
                                v17.length = Length;
                                if (CFStringFindWithOptions(v1, CFSTR("com.crossforward"), v17, 1uLL, 0))
                                {
                                  return CFSTR("CrossForward");
                                }
                                else
                                {
                                  v18.location = 0;
                                  v18.length = Length;
                                  if (CFStringFindWithOptions(v1, CFSTR("com.apple"), v18, 1uLL, 0))
                                    return v1;
                                  else
                                    return CFSTR("Other");
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

const char *acLog(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const char *result;

  result = getenv("CI_DEBUG_AUTOCROP");
  if (result)
  {
    result = (const char *)atoi(result);
    if ((_DWORD)result)
      return (const char *)vfprintf((FILE *)*MEMORY[0x1E0C80C10], a1, &a9);
  }
  return result;
}

char *BGHashMapCreate(unsigned int a1)
{
  char *v2;
  _BYTE *v3;
  uint64_t v4;
  _QWORD *v5;

  v2 = (char *)malloc_type_malloc(16 * a1 + 24, 0x344C54A3uLL);
  v3 = v2 + 24;
  *(_QWORD *)v2 = v2 + 24;
  *((_DWORD *)v2 + 2) = a1;
  *((_QWORD *)v2 + 2) = 0;
  if (a1)
  {
    v4 = a1;
    do
    {
      *v3 = 0;
      v3 += 16;
      --v4;
    }
    while (v4);
  }
  v5 = malloc_type_malloc(0x1D4D8uLL, 0x61CF12B5uLL);
  *v5 = v5 + 3;
  v5[1] = 5000;
  v5[2] = 0;
  *((_QWORD *)v2 + 2) = v5;
  return v2;
}

void BGHashMapRelease(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a1)
  {
    v2 = (_QWORD *)a1[2];
    if (v2)
    {
      do
      {
        v3 = (_QWORD *)v2[2];
        free(v2);
        v2 = v3;
      }
      while (v3);
    }
    free(a1);
  }
}

void BGHashClear(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(_QWORD **)(v2 + 16);
  if (v3)
  {
    do
    {
      v4 = (_QWORD *)v3[2];
      free(v3);
      v3 = v4;
    }
    while (v4);
  }
  *(_DWORD *)(v2 + 12) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  bzero(*(void **)a1, 16 * *(unsigned int *)(a1 + 8));
}

uint64_t BGHashFindKey(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int v3;
  uint64_t v4;

  v3 = BYTE2(a2) | (BYTE2(a2) << 8);
  if (!*(_BYTE *)(*(_QWORD *)a1
                 + 16
                 * ((257 * (16974593 * a2 + BYTE3(a2) + 66049 * BYTE1(a2) + v3) + BYTE4(a2) + 842144005)
                  % *(_DWORD *)(a1 + 8))))
    return 0;
  v4 = *(_QWORD *)(*(_QWORD *)a1
                 + 16
                 * ((257 * (16974593 * a2 + BYTE3(a2) + 66049 * BYTE1(a2) + v3) + BYTE4(a2) + 842144005)
                  % *(_DWORD *)(a1 + 8))
                 + 8);
  if (!v4)
    return 0;
  while (*(_QWORD *)v4 != a2)
  {
    v4 = *(_QWORD *)(v4 + 16);
    if (!v4)
      return 0;
  }
  *a3 = *(_DWORD *)(v4 + 8);
  return 1;
}

char *BGHashSetValue(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  int v8;
  char *result;

  v5 = (257 * (16974593 * a2 + BYTE3(a2) + 66049 * BYTE1(a2) + (BYTE2(a2) | (BYTE2(a2) << 8)))
      + BYTE4(a2)
      + 842144005)
     % *(_DWORD *)(a1 + 8);
  v6 = *(_QWORD *)a1;
  v7 = (_BYTE *)(*(_QWORD *)a1 + 16 * v5);
  v8 = *v7;
  result = bgNewLinkedListEntry(a1);
  if (v8)
  {
    *((_QWORD *)result + 2) = *(_QWORD *)(v6 + 16 * v5 + 8);
  }
  else
  {
    *((_QWORD *)result + 2) = 0;
    *v7 = 1;
  }
  *(_QWORD *)result = a2;
  *((_DWORD *)result + 2) = a3;
  *(_QWORD *)(v6 + 16 * v5 + 8) = result;
  return result;
}

char *bgNewLinkedListEntry(uint64_t a1)
{
  _DWORD *v2;
  unsigned int v3;
  char *v4;

  v2 = *(_DWORD **)(a1 + 16);
  v3 = v2[3];
  if (v3 == v2[2])
  {
    v2 = malloc_type_malloc(24 * v3 + 24, 0x61CF12B5uLL);
    v4 = (char *)(v2 + 6);
    *(_QWORD *)v2 = v2 + 6;
    v2[2] = v3;
    v2[3] = 0;
    *((_QWORD *)v2 + 2) = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v2;
    v3 = 0;
  }
  else
  {
    v4 = *(char **)v2;
  }
  v2[3] = v3 + 1;
  return &v4[24 * v3];
}

unint64_t hash3(unsigned __int8 *a1)
{
  return ((unint64_t)a1[2] << 16) | ((unint64_t)a1[1] << 8) | *a1;
}

unint64_t hash5(unsigned __int8 *a1)
{
  return *a1 | ((unint64_t)*(unsigned int *)(a1 + 1) << 8);
}

uint64_t hash_shift(uint64_t a1, int a2, int a3)
{
  unsigned int v3;
  _QWORD v5[3];

  v5[1] = 0;
  v5[2] = 0;
  v5[0] = a1;
  v3 = *((unsigned __int8 *)v5 + a2) + a3;
  if (v3 > 0xFF)
    return -1;
  *((_BYTE *)v5 + a2) = v3;
  return v5[0];
}

unint64_t hash_pad(int a1)
{
  return ((unint64_t)(a1 & 0x80) << 49) | ((((unint64_t)(a1 & 0x40) >> 6) & 1) << 48) | ((((unint64_t)(a1 & 0x20) >> 5) & 1) << 40) | ((((unint64_t)(a1 & 0x10) >> 4) & 1) << 32) | (a1 << 21) & 0x1000000 | (unint64_t)((a1 << 14) & 0x10000) | (a1 << 7) & 0x100 | (unint64_t)(a1 & 1);
}

void sub_19220C3F4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19220C4E8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19220C910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *zmalloc(size_t a1)
{
  return malloc_type_malloc(a1, 0x4A7C05C1uLL);
}

void *zcalloc(size_t a1, size_t a2)
{
  return malloc_type_calloc(a1, a2, 0x293D63F1uLL);
}

void *initBitmap(uint64_t a1, int a2, int a3, int a4, int a5, float a6)
{
  int v7;
  void *result;

  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = a3;
  *(_DWORD *)(a1 + 28) = a4;
  *(_DWORD *)(a1 + 32) = a5;
  *(float *)(a1 + 36) = a6;
  v7 = a4 * a2 * a5;
  *(_DWORD *)(a1 + 16) = a4 * a2;
  *(_DWORD *)(a1 + 20) = v7;
  *(_DWORD *)(a1 + 24) = v7 * a3;
  result = malloc_type_malloc(v7 * a3, 0x4A7C05C1uLL);
  *(_QWORD *)a1 = result;
  return result;
}

void termBitmap(void **a1)
{
  void *v2;

  v2 = *a1;
  if (v2)
    free(v2);
  *a1 = 0;
}

uint64_t constructBitmap(uint64_t result, uint64_t a2, int a3, int a4, int a5, int a6, int a7, float a8)
{
  *(_QWORD *)result = a2;
  *(_DWORD *)(result + 8) = a3;
  *(_DWORD *)(result + 12) = a4;
  *(_DWORD *)(result + 28) = a5;
  *(_DWORD *)(result + 32) = a6;
  *(float *)(result + 36) = a8;
  *(_DWORD *)(result + 16) = a7 / a6;
  *(_DWORD *)(result + 20) = a7;
  *(_DWORD *)(result + 24) = a7 * a4;
  return result;
}

float constructSliceBitmap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  float result;

  v5 = *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 20);
  v6 = *(_DWORD *)(a1 + 28);
  v7 = *(_DWORD *)(a1 + 32);
  *(_QWORD *)a2 = *(_QWORD *)a1 + v4 * (int)a3 + v6 * (int)a4 * v7;
  *(_DWORD *)(a2 + 8) = HIDWORD(a4) - a4;
  *(_DWORD *)(a2 + 12) = HIDWORD(a3) - a3;
  *(_DWORD *)(a2 + 16) = v5;
  *(_DWORD *)(a2 + 20) = v4;
  *(_DWORD *)(a2 + 24) = v4 * (HIDWORD(a3) - a3);
  *(_DWORD *)(a2 + 28) = v6;
  *(_DWORD *)(a2 + 32) = v7;
  result = *(float *)(a1 + 36);
  *(float *)(a2 + 36) = result;
  return result;
}

BOOL bilinearLookupTest(uint64_t a1, float a2, float a3)
{
  _BOOL8 result;

  result = 0;
  if (a2 >= 0.0 && a3 >= 0.0)
    return (float)(*(_DWORD *)(a1 + 8) - 1) >= a2 && (float)(*(_DWORD *)(a1 + 12) - 1) >= a3;
  return result;
}

uint64_t bilinearLookup(uint64_t a1, float a2, float a3)
{
  float v3;
  float v4;
  int v5;
  int v6;
  signed int v7;
  int v8;
  float v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  float v14;

  v3 = 0.0;
  v4 = 0.0;
  if (a2 >= 0.0)
  {
    v4 = a2;
    if ((float)(*(_DWORD *)(a1 + 8) - 1) < a2)
      v4 = (float)(*(_DWORD *)(a1 + 8) - 1);
  }
  v5 = *(_DWORD *)(a1 + 12);
  if (a3 >= 0.0)
  {
    v3 = a3;
    if ((float)(v5 - 1) < a3)
      v3 = (float)(v5 - 1);
  }
  v6 = vcvtms_s32_f32(v4);
  v7 = vcvtms_s32_f32(v3);
  if (*(_DWORD *)(a1 + 8) - 2 < v6)
    v6 = *(_DWORD *)(a1 + 8) - 2;
  v8 = v5 - 2;
  if (v8 >= v7)
    v8 = v7;
  v9 = v4 - (float)v6;
  v10 = v3 - (float)v8;
  v11 = *(int *)(a1 + 16);
  v12 = *(int *)(a1 + 28);
  v13 = (unsigned __int8 *)(*(_QWORD *)a1 + v8 * (int)v11 + (int)v12 * v6);
  v14 = (float)*v13 + (float)((float)(v13[v12] - *v13) * v9);
  return (int)rintf(v14+ (float)((float)((float)((float)v13[v11]+ (float)((float)(v13[(int)v12 + (int)v11] - v13[v11]) * v9))- v14)* v10));
}

uint64_t bilinearLookupAccurate(uint64_t a1, float a2, float a3)
{
  float v3;
  float v4;
  int v5;
  int v6;
  signed int v7;
  int v8;
  int v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  int v14;

  v3 = 0.0;
  v4 = 0.0;
  if (a2 >= 0.0)
  {
    v4 = a2;
    if ((float)(*(_DWORD *)(a1 + 8) - 1) < a2)
      v4 = (float)(*(_DWORD *)(a1 + 8) - 1);
  }
  v5 = *(_DWORD *)(a1 + 12);
  if (a3 >= 0.0)
  {
    v3 = a3;
    if ((float)(v5 - 1) < a3)
      v3 = (float)(v5 - 1);
  }
  v6 = vcvtms_s32_f32(v4);
  v7 = vcvtms_s32_f32(v3);
  if (*(_DWORD *)(a1 + 8) - 2 < v6)
    v6 = *(_DWORD *)(a1 + 8) - 2;
  v8 = v5 - 2;
  if (v8 >= v7)
    v8 = v7;
  v9 = (int)rintf((float)(v4 - (float)v6) * 64.0);
  v10 = rintf((float)(v3 - (float)v8) * 64.0);
  v11 = *(int *)(a1 + 16);
  v12 = *(int *)(a1 + 28);
  v13 = (unsigned __int8 *)(*(_QWORD *)a1 + v8 * (int)v11 + (int)v12 * v6);
  v14 = v13[v11];
  LODWORD(v11) = v13[(int)v12 + (int)v11];
  LODWORD(v13) = *v13 + (((v13[v12] - *v13) * v9 + 32) >> 6);
  return ((v14 - (_DWORD)v13 + ((((int)v11 - v14) * v9 + 32) >> 6)) * (int)v10 + ((_DWORD)v13 << 6));
}

double bilinearCbCrLookup(uint64_t a1, float a2, float a3)
{
  float v3;
  float v4;
  int v5;
  int v6;
  signed int v7;
  int v8;
  float v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  float v14;

  v3 = 0.0;
  v4 = 0.0;
  if (a2 >= 0.0)
  {
    v4 = a2;
    if ((float)(*(_DWORD *)(a1 + 8) - 1) < a2)
      v4 = (float)(*(_DWORD *)(a1 + 8) - 1);
  }
  v5 = *(_DWORD *)(a1 + 12);
  if (a3 >= 0.0)
  {
    v3 = a3;
    if ((float)(v5 - 1) < a3)
      v3 = (float)(v5 - 1);
  }
  v6 = vcvtms_s32_f32(v4);
  v7 = vcvtms_s32_f32(v3);
  if (*(_DWORD *)(a1 + 8) - 2 < v6)
    v6 = *(_DWORD *)(a1 + 8) - 2;
  v8 = v5 - 2;
  if (v8 >= v7)
    v8 = v7;
  v9 = v4 - (float)v6;
  v10 = v3 - (float)v8;
  v11 = *(int *)(a1 + 16);
  v12 = *(int *)(a1 + 28);
  v13 = (unsigned __int8 *)(*(_QWORD *)a1 + v8 * (int)v11 + (int)v12 * v6);
  v14 = (float)*v13 + (float)((float)(v13[v12] - *v13) * v9);
  return (double)(uint64_t)rintf(v14+ (float)((float)((float)((float)v13[v11]+ (float)((float)(v13[(int)v12 + (int)v11] - v13[v11]) * v9))- v14)* v10));
}

float bilinearARGB8LookupComponents(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, float a6, float a7)
{
  float v7;
  float v8;
  int v9;
  int v10;
  signed int v11;
  int v12;
  float v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned __int8 *v30;
  int v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float result;

  v7 = 0.0;
  v8 = 0.0;
  if (a6 >= 0.0)
  {
    v8 = a6;
    if ((float)(*(_DWORD *)(a1 + 8) - 1) < a6)
      v8 = (float)(*(_DWORD *)(a1 + 8) - 1);
  }
  v9 = *(_DWORD *)(a1 + 12);
  if (a7 >= 0.0)
  {
    v7 = a7;
    if ((float)(v9 - 1) < a7)
      v7 = (float)(v9 - 1);
  }
  v10 = vcvtms_s32_f32(v8);
  v11 = vcvtms_s32_f32(v7);
  if (*(_DWORD *)(a1 + 8) - 2 < v10)
    v10 = *(_DWORD *)(a1 + 8) - 2;
  v12 = v9 - 2;
  if (v12 >= v11)
    v12 = v11;
  v13 = v8 - (float)v10;
  v14 = v7 - (float)v12;
  v15 = *(int *)(a1 + 16);
  v16 = *(int *)(a1 + 28);
  v17 = (unsigned __int8 *)(*(_QWORD *)a1 + v12 * (int)v15 + (int)v16 * v10);
  v18 = *v17;
  v19 = v17[1];
  v20 = v17[2];
  v21 = v17[3];
  v22 = v17[v16];
  v23 = v17[v16 + 1];
  v24 = v17[v16 + 2];
  v25 = v17[v16 + 3];
  v26 = v17[v15];
  v27 = v17[v15 + 1];
  v28 = v17[v15 + 2];
  v29 = v17[v15 + 3];
  v30 = &v17[(int)v16 + (int)v15];
  LODWORD(v15) = *v30;
  LODWORD(v16) = v30[1];
  v31 = v30[2];
  LODWORD(v30) = v30[3];
  v32 = (float)v18 + (float)((float)(int)(v22 - v18) * v13);
  *a2 = (int)rintf(v32 + (float)((float)((float)((float)v26 + (float)((float)(int)(v15 - v26) * v13)) - v32) * v14));
  v33 = (float)v19 + (float)((float)(int)(v23 - v19) * v13);
  *a3 = (int)rintf(v33 + (float)((float)((float)((float)v27 + (float)((float)(int)(v16 - v27) * v13)) - v33) * v14));
  v34 = (float)v20 + (float)((float)(int)(v24 - v20) * v13);
  *a4 = (int)rintf(v34 + (float)((float)((float)((float)v28 + (float)((float)(int)(v31 - v28) * v13)) - v34) * v14));
  v35 = (float)v21 + (float)((float)(int)(v25 - v21) * v13);
  result = rintf(v35 + (float)((float)((float)((float)v29 + (float)((float)(int)((_DWORD)v30 - v29) * v13)) - v35) * v14));
  *a5 = (int)result;
  return result;
}

int *copySliceOfBitmapToBitmap(int *result, char **a2, uint64_t a3, uint64_t a4)
{
  int *v4;
  int v5;
  int v6;
  int v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;

  if (result[8] != *((_DWORD *)a2 + 8))
    return (int *)puts("copySliceOfBitmapToBitmap: bytes per sample or samples per pixel differs!");
  v4 = result;
  if (result[7] != *((_DWORD *)a2 + 7))
    return (int *)puts("copySliceOfBitmapToBitmap: bytes per sample or samples per pixel differs!");
  v5 = HIDWORD(a3) - a3;
  if (SHIDWORD(a3) > (int)a3)
  {
    v6 = a4;
    v7 = HIDWORD(a4) - a4;
    v8 = *a2;
    v9 = result[5];
    v10 = *(_QWORD *)result + (int)v9 * (uint64_t)(int)a3;
    v11 = *((int *)a2 + 5);
    do
    {
      v12 = v4[8] * v4[7];
      result = (int *)memmove(v8, (const void *)(v10 + v12 * v6), v12 * v7);
      v10 += v9;
      v8 += v11;
      --v5;
    }
    while (v5);
  }
  return result;
}

int *copyBitmapToSliceOfBitmap(int *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int *v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;

  if (result[8] != *(_DWORD *)(a2 + 32))
    return (int *)puts("copyBitmapToSliceOfBitmap: bytes per sample or samples per pixel differs!");
  v5 = result;
  if (result[7] != *(_DWORD *)(a2 + 28))
    return (int *)puts("copyBitmapToSliceOfBitmap: bytes per sample or samples per pixel differs!");
  v6 = HIDWORD(a3) - a3;
  if (SHIDWORD(a3) > (int)a3)
  {
    v7 = a4;
    v8 = HIDWORD(a4) - a4;
    v9 = *(int *)(a2 + 20);
    v10 = *(_QWORD *)a2 + (int)v9 * (uint64_t)(int)a3;
    v11 = *(char **)result;
    v12 = result[5];
    do
    {
      result = (int *)memmove((void *)(v10 + *(int *)(a2 + 28) * (uint64_t)v7 * *(int *)(a2 + 32)), v11, v5[7] * (uint64_t)v8 * v5[8]);
      v11 += v12;
      v10 += v9;
      --v6;
    }
    while (v6);
  }
  return result;
}

unint64_t bitmapToBitmapDifferenceBitmapRect(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, int8x8_t a7)
{
  int v7;
  char v8;
  unsigned int v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  uint64_t v13;
  int v14;
  int v15;
  int32x2_t v16;
  int32x2_t v17;
  unsigned int v18;
  unsigned __int8 *v19;
  unsigned __int8 *v20;
  int32x2_t v21;
  BOOL v22;
  BOOL v23;
  int8x16_t v25;

  v7 = *(_DWORD *)(a1 + 12);
  if (v7 < 1)
    return 0;
  v8 = 0;
  v9 = 0;
  v10 = (*(_DWORD *)(a1 + 32) * *(_DWORD *)(a1 + 28));
  v11 = *(unsigned __int8 **)a2;
  v12 = *(unsigned __int8 **)a1;
  v13 = *(int *)(a1 + 20);
  v14 = *(_DWORD *)(a1 + 8);
  if (v14 <= 1)
    v15 = 1;
  else
    v15 = *(_DWORD *)(a1 + 8);
  v16 = 0;
  v17 = 0;
  do
  {
    if (v14 >= 1)
    {
      if (v10 > 8 || ((1 << v10) & 0x116) == 0)
      {
        puts("bitmapToBitmapDifferenceBitmapRect: source pixel configuration illegal");
        return 0;
      }
      v18 = 0;
      v19 = v11;
      v20 = v12;
      v21 = v16;
      do
      {
        switch((_DWORD)v10)
        {
          case 4:
            if (*v20 != *v19
              || (v20[1] == v19[1] ? (v22 = v20[2] == v19[2]) : (v22 = 0),
                  v22 ? (v23 = v20[3] == v19[3]) : (v23 = 0),
                  !v23))
            {
LABEL_35:
              v16 = (int32x2_t)__PAIR64__(v18, v9);
              if ((v8 & 1) != 0)
              {
                a7 = (int8x8_t)vcgt_s32(v17, (int32x2_t)__PAIR64__(v18, v9));
                v17 = vmin_s32((int32x2_t)__PAIR64__(v18, v9), v17);
                v16 = (int32x2_t)vbsl_s8(a7, (int8x8_t)v21, (int8x8_t)vmax_s32((int32x2_t)__PAIR64__(v18, v9), v21));
                v8 = 1;
              }
              else
              {
                v8 = 1;
                v17 = (int32x2_t)__PAIR64__(v18, v9);
              }
              goto LABEL_38;
            }
            break;
          case 2:
            if (*v20 != *v19 || v20[1] != v19[1])
              goto LABEL_35;
            break;
          case 1:
            if (*v20 != *v19)
              goto LABEL_35;
            break;
          default:
            if (*v20 != *v19)
              goto LABEL_35;
            v16.i32[0] = *(_DWORD *)(v19 + 1);
            a7.i32[0] = *(_DWORD *)(v20 + 1);
            a7 = (int8x8_t)vmovl_u8((uint8x8_t)a7).u64[0];
            if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16((int16x4_t)vmvn_s8((int8x8_t)vceq_s16((int16x4_t)a7, (int16x4_t)*(_OWORD *)&vmovl_u8((uint8x8_t)v16))), 0xFuLL))) & 1) != 0|| v20[5] != v19[5]|| v20[6] != v19[6]|| v20[7] != v19[7])
            {
              goto LABEL_35;
            }
            break;
        }
        v16 = v21;
LABEL_38:
        ++v18;
        v20 += v10;
        v19 += *(int *)(a2 + 32) * (uint64_t)*(int *)(a2 + 28);
        v21 = v16;
      }
      while (v15 != v18);
    }
    ++v9;
    v12 += v13;
    v11 += *(int *)(a2 + 20);
  }
  while (v9 != v7);
  if ((v8 & 1) != 0)
  {
    v25.i64[0] = v17.u32[0];
    v25.i64[1] = v17.u32[1];
    return vorrq_s8((int8x16_t)vshll_n_s32(vadd_s32(v16, (int32x2_t)0x100000001), 0x20uLL), v25).u64[0];
  }
  return 0;
}

unint64_t makeBitmapRect(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  return a2 | (unint64_t)(a4 << 32);
}

unint64_t insetBitmapRect(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return (a1 + a4) | ((unint64_t)(HIDWORD(a1) - a4) << 32);
}

unint64_t offsetBitmapRect(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return (a1 + a4) | ((unint64_t)(HIDWORD(a1) + a4) << 32);
}

uint64_t intersectBitmapRects(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;

  if ((int)a1 <= (int)a3)
    v3 = a3;
  else
    v3 = a1;
  if (SHIDWORD(a1) >= SHIDWORD(a3))
    v4 = HIDWORD(a3);
  else
    v4 = HIDWORD(a1);
  return v3 | (v4 << 32);
}

uint64_t unionBitmapRects(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;

  if ((int)a1 >= (int)a3)
    v3 = a3;
  else
    v3 = a1;
  if (SHIDWORD(a1) <= SHIDWORD(a3))
    v4 = HIDWORD(a3);
  else
    v4 = HIDWORD(a1);
  return v3 | (v4 << 32);
}

unint64_t halfBitmapRect(uint64_t a1)
{
  int v1;

  if ((int)a1 >= 0)
    v1 = a1;
  else
    v1 = a1 + 1;
  return (v1 >> 1) | ((unint64_t)(SHIDWORD(a1) / 2) << 32);
}

unint64_t twiceBitmapRect(uint64_t a1)
{
  return (2 * a1) & 0xFFFFFFFEFFFFFFFELL;
}

unint64_t evenBitmapRect(uint64_t a1)
{
  return (a1 + 0x100000000) & 0xFFFFFFFE00000000 | a1 & 0xFFFFFFFE;
}

double alignedBitmapRectAroundPoint(unsigned int a1, unsigned int a2, unsigned int a3)
{
  int32x2_t v3;
  int32x2_t v4;
  int8x8_t v5;
  unint64_t v6;
  int8x16_t v7;
  double result;

  v3 = vdup_n_s32(a3);
  v4 = vadd_s32(v3, (int32x2_t)__PAIR64__(a1, a2));
  v5 = (int8x8_t)vadd_s32(v4, (int32x2_t)0x100000001);
  v6 = *(_QWORD *)&vsub_s32((int32x2_t)__PAIR64__(a1, a2), v3) & 0xFFFFFFFEFFFFFFFELL;
  v7.i64[0] = v6;
  v7.i64[1] = HIDWORD(v6);
  *(_QWORD *)&result = vorrq_s8((int8x16_t)vshll_n_s32((int32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)vand_s8(v5, (int8x8_t)0x100000001)), v5, (int8x8_t)vadd_s32((int32x2_t)(*(_QWORD *)&v4 & 0xFFFFFFFEFFFFFFFELL), (int32x2_t)0x200000002)), 0x20uLL), v7).u64[0];
  return result;
}

unint64_t clipBitmapRectToBitmapBounds(unint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;

  v3 = HIDWORD(a1);
  if ((int)(*(_DWORD *)(a3 + 12) & 0xFFFFFFFE) < SHIDWORD(a1))
    LODWORD(v3) = *(_DWORD *)(a3 + 12) & 0xFFFFFFFE;
  return a1 & ~((int)a1 >> 31) | ((unint64_t)(v3
                                                                 - (((_BYTE)v3
                                                                   - (a1 & ~((int)a1 >> 31))) & 1)) << 32);
}

uint64_t clipBitmapRectToWidthAndHeight(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;

  v4 = a1;
  if ((int)(a4 & 0xFFFFFFFE) >= SHIDWORD(a1))
    v5 = HIDWORD(a1);
  else
    v5 = a4 & 0xFFFFFFFE;
  if ((int)a1 < 0)
    v4 = 0;
  return v4 | (v5 << 32);
}

uint64_t applyMaxFilter8(uint64_t a1, int a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t result;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  char *v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  char *v20;
  uint64_t v21;
  char *v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  int v34;
  int v35;
  uint64_t v36;
  int v37;
  int v38;
  char *v39;
  int v40;
  int v41;
  uint64_t v42;
  char *v43;
  int v44;
  int v45;
  char *v46;
  uint64_t v47;
  int v48;
  int v49;
  int v50;
  uint64_t v51;
  int v52;
  int v53;
  unsigned __int8 *v54;
  unsigned __int8 *v55;
  unsigned __int8 *v56;
  int v57;
  int v58;
  int v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  char *v66;
  int v67;

  if (*(_DWORD *)(a1 + 8) < a2)
    return 1;
  v3 = *(_DWORD *)(a1 + 12);
  if (v3 < a2)
    return 1;
  v4 = *(int *)(a1 + 16);
  v5 = *(int *)(a1 + 28);
  if (a2 >= 0)
    v6 = a2;
  else
    v6 = a2 + 1;
  if (v3 <= (int)v4)
    v3 = *(_DWORD *)(a1 + 16);
  result = (uint64_t)malloc_type_calloc(v3, 1uLL, 0x293D63F1uLL);
  if (result)
  {
    v9 = -(v6 >> 1);
    v10 = a2 - (v6 >> 1);
    v11 = *(_DWORD *)(a1 + 12);
    v12 = a2;
    if (v11 >= 1)
    {
      v13 = 0;
      v14 = 0;
      v15 = *(char **)a1;
      v16 = v6 >> 1;
      if ((v6 >> 1) + 1 <= 1)
        v17 = 1;
      else
        v17 = (v6 >> 1) + 1;
      v64 = result;
      v65 = v12;
      v63 = (int)v5 * (uint64_t)v12;
      do
      {
        v67 = v14;
        v66 = v15;
        memmove((void *)result, v15, *(int *)(a1 + 8));
        if ((int)v5 < 1)
        {
          result = v64;
          v12 = v65;
          v19 = v67;
          v20 = v66;
        }
        else
        {
          v18 = 0;
          result = v64;
          v12 = v65;
          v19 = v67;
          v20 = v66;
          v62 = v5 * (v9 - 1);
          do
          {
            v21 = v64 + v18;
            v22 = &v66[v18];
            if (v65 < -1)
            {
              v28 = 0;
            }
            else
            {
              v23 = 0;
              v24 = -(v6 >> 1);
              do
              {
                if (v23 <= v16)
                  v25 = v6 >> 1;
                else
                  v25 = v23;
                if (v23 < v16)
                  v26 = -v23;
                else
                  v26 = -(v6 >> 1);
                if (v26 >= v10)
                {
                  v13 = 0;
                }
                else
                {
                  v13 = 0;
                  v27 = (int)v5 * (v25 + v24);
                  do
                  {
                    if (v13 <= *(unsigned __int8 *)(v21 + v27))
                      v13 = *(unsigned __int8 *)(v21 + v27);
                    ++v26;
                    v27 += v5;
                  }
                  while (v26 < v10);
                }
                ++v23;
                *v22 = v13;
                v21 += v5;
                v22 += v5;
                --v24;
              }
              while (v23 != v17);
              v28 = v17;
            }
            v29 = *(_DWORD *)(a1 + 8);
            v30 = v29 - v10;
            if (v28 < v29 - v10)
            {
              v31 = (unsigned __int8 *)(v21 + v62);
              v32 = (unsigned __int8 *)(v21 + v62 + v63);
              do
              {
                if (v13 <= *v31 || v13 <= *v32)
                {
                  v33 = &v31[v5];
                  if (&v31[v5] <= v32)
                  {
                    v13 = 0;
                    do
                    {
                      if (v13 <= *v33)
                        v13 = *v33;
                      v33 += v5;
                    }
                    while (v33 <= v32);
                  }
                  else
                  {
                    v13 = 0;
                  }
                }
                ++v28;
                v21 += v5;
                *v22 = v13;
                v31 += v5;
                v32 += v5;
                v22 += v5;
              }
              while (v28 < v30);
              goto LABEL_47;
            }
            v30 = v28;
            while (v30 < v29)
            {
              if (v30 + v10 <= v29)
                v34 = v10;
              else
                v34 = v29 - v30;
              if (v9 >= v34)
              {
                LOBYTE(v35) = 0;
              }
              else
              {
                v35 = 0;
                v36 = (int)v5 * v9;
                v37 = -(v6 >> 1);
                do
                {
                  if (v35 <= *(unsigned __int8 *)(v21 + v36))
                    v35 = *(unsigned __int8 *)(v21 + v36);
                  ++v37;
                  v36 += v5;
                }
                while (v37 < v34);
              }
              *v22 = v35;
              ++v30;
              v21 += v5;
              v22 += v5;
LABEL_47:
              v29 = *(_DWORD *)(a1 + 8);
            }
            ++v18;
          }
          while (v18 != v5);
        }
        v14 = v19 + 1;
        v15 = &v20[v4];
        v11 = *(_DWORD *)(a1 + 12);
      }
      while (v14 < v11);
    }
    if (*(_DWORD *)(a1 + 8) * (int)v5 >= 1)
    {
      v38 = 0;
      v39 = *(char **)a1;
      v40 = (v6 >> 1) + 1;
      v41 = v6 >> 1;
      if (v40 <= 1)
        v40 = 1;
      do
      {
        if (v11 >= 1)
        {
          v42 = 0;
          v43 = v39;
          do
          {
            *(_BYTE *)(result + v42) = *v43;
            v43 += v4;
            v11 = *(_DWORD *)(a1 + 12);
            ++v42;
          }
          while ((int)v42 < v11);
        }
        if (v12 < -1)
        {
          v52 = 0;
          v50 = 0;
          v47 = result;
          v46 = v39;
        }
        else
        {
          v44 = 0;
          v45 = -(v6 >> 1);
          v46 = v39;
          v47 = result;
          do
          {
            if (v44 <= v41)
              v48 = v6 >> 1;
            else
              v48 = v44;
            if (v44 < v41)
              v49 = -v44;
            else
              v49 = -(v6 >> 1);
            if (v49 >= v10)
            {
              v50 = 0;
            }
            else
            {
              v50 = 0;
              v51 = v48 + v45;
              do
              {
                if (v50 <= *(unsigned __int8 *)(v47 + v51))
                  v50 = *(unsigned __int8 *)(v47 + v51);
                ++v51;
              }
              while ((int)v51 < v10);
            }
            ++v44;
            *v46 = v50;
            ++v47;
            v46 += v4;
            --v45;
          }
          while (v44 != v40);
          v11 = *(_DWORD *)(a1 + 12);
          v52 = v40;
        }
        v53 = v11 - v10;
        if (v52 < v11 - v10)
        {
          v54 = (unsigned __int8 *)(v47 + v9 - 1);
          v55 = &v54[v12];
          do
          {
            if (v50 <= *v54 || v50 <= *v55)
            {
              v56 = v54 + 1;
              if (v54 + 1 <= v55)
              {
                v50 = 0;
                do
                {
                  v58 = *v56++;
                  v57 = v58;
                  if (v50 <= v58)
                    v50 = v57;
                }
                while (v56 <= v55);
              }
              else
              {
                v50 = 0;
              }
            }
            ++v52;
            ++v47;
            *v46 = v50;
            ++v54;
            ++v55;
            v46 += v4;
          }
          while (v52 < v53);
          goto LABEL_101;
        }
        v53 = v52;
        while (v53 < v11)
        {
          if (v53 + v10 <= v11)
            v59 = v10;
          else
            v59 = v11 - v53;
          if (v9 >= v59)
          {
            LOBYTE(v60) = 0;
          }
          else
          {
            v60 = 0;
            v61 = v9;
            do
            {
              if (v60 <= *(unsigned __int8 *)(v47 + v61))
                v60 = *(unsigned __int8 *)(v47 + v61);
              ++v61;
            }
            while ((int)v61 < v59);
          }
          *v46 = v60;
          ++v53;
          ++v47;
          v46 += v4;
LABEL_101:
          v11 = *(_DWORD *)(a1 + 12);
        }
        ++v38;
        ++v39;
      }
      while (v38 < *(_DWORD *)(a1 + 8) * (int)v5);
    }
    free((void *)result);
    return 1;
  }
  return result;
}

_QWORD *initBitmask(int a1, int a2)
{
  _DWORD *v4;
  _QWORD *v5;
  int v6;
  void *v7;
  const char *v8;

  v4 = zmalloc(0x18uLL);
  if (!v4)
  {
    v8 = "initBitmask: bitmap record can not be allocated";
    goto LABEL_7;
  }
  v5 = v4;
  v6 = a1 + 7;
  if (a1 < -7)
    v6 = a1 + 14;
  v4[2] = a1;
  v4[3] = a2;
  v4[4] = v6 >> 3;
  v7 = zcalloc(a2, (uint64_t)v6 >> 3);
  *v5 = v7;
  if (!v7)
  {
    zfree(v5);
    v8 = "initBitmask: bitmap body can not be allocated";
LABEL_7:
    puts(v8);
    return 0;
  }
  return v5;
}

void termBitmask(void **a1)
{
  void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      zfree(v2);
    zfree(a1);
  }
  else
  {
    puts("termBitmask: bitmap was null");
  }
}

uint64_t bitValueFromBitmask(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result;

  if ((a2 & 0x80000000) != 0)
    return 0;
  result = 0;
  if ((a3 & 0x80000000) == 0 && *(_DWORD *)(a1 + 8) > (signed int)a2)
  {
    if (*(_DWORD *)(a1 + 12) > a3)
      return (*(unsigned __int8 *)(*(_QWORD *)a1 + *(int *)(a1 + 16) * (uint64_t)a3 + ((unint64_t)a2 >> 3)) >> (a2 & 7)) & 1;
    return 0;
  }
  return result;
}

uint64_t setBitInBitmask(uint64_t result, unsigned int a2, int a3, int a4)
{
  uint64_t v4;
  unint64_t v5;
  int v6;
  char v7;
  char v8;
  char v9;

  if ((a2 & 0x80000000) == 0
    && (a3 & 0x80000000) == 0
    && *(_DWORD *)(result + 8) > (signed int)a2
    && *(_DWORD *)(result + 12) > a3)
  {
    v4 = *(_QWORD *)result + *(int *)(result + 16) * (uint64_t)a3;
    v5 = (unint64_t)a2 >> 3;
    v6 = 1 << (a2 & 7);
    v7 = *(_BYTE *)(v4 + v5);
    v8 = v7 | v6;
    v9 = v7 & ~(_BYTE)v6;
    if (a4)
      v9 = v8;
    *(_BYTE *)(v4 + v5) = v9;
  }
  return result;
}

uint64_t bitmaskMinus(uint64_t result, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  char *v5;
  _BYTE *v6;
  char v7;

  if (*(_DWORD *)(result + 8) != *(_DWORD *)(a2 + 8))
    return puts("bitmaskMinus: bitmasks have different shapes");
  v2 = *(_DWORD *)(result + 12);
  if (v2 != *(_DWORD *)(a2 + 12))
    return puts("bitmaskMinus: bitmasks have different shapes");
  v3 = *(_DWORD *)(result + 16);
  if (v3 != *(_DWORD *)(a2 + 16))
    return puts("bitmaskMinus: bitmasks have different shapes");
  v4 = v3 * v2;
  if (v4 >= 1)
  {
    v5 = *(char **)a2;
    v6 = *(_BYTE **)result;
    do
    {
      v7 = *v5++;
      *v6++ &= ~v7;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t spreadBitmask(uint64_t result, uint64_t a2, int a3)
{
  int v3;
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  unint64_t v18;
  char v19;
  int v20;
  int v21;

  v3 = *(_DWORD *)(result + 12);
  if (v3 >= 1)
  {
    v6 = result;
    v7 = 0;
    v8 = *(_DWORD *)(result + 8);
    do
    {
      if (v8 <= 0)
      {
        LODWORD(v10) = v7 + 1;
      }
      else
      {
        v9 = 0;
        v10 = v7 + 1;
        do
        {
          v11 = *(_QWORD *)v6;
          v12 = *(_DWORD *)(v6 + 12);
          v13 = *(int *)(v6 + 16);
          v14 = *(_QWORD *)v6 + (int)v13 * (uint64_t)v7;
          v15 = a3;
          if (v9)
          {
            v15 = a3;
            if (v12 > v7)
              v15 = (*(unsigned __int8 *)(v14 + ((unint64_t)(v9 - 1) >> 3)) >> ((v9 - 1) & 7)) & 1;
          }
          v16 = v9 + 1;
          v17 = a3;
          if (v8 > (int)(v9 + 1))
          {
            v17 = a3;
            if (v12 > v7)
              v17 = (*(unsigned __int8 *)(v14 + ((unint64_t)(v9 + 1) >> 3)) >> ((v9 + 1) & 7)) & 1;
          }
          v18 = (unint64_t)v9 >> 3;
          v19 = v9 & 7;
          v20 = a3;
          if (v7)
          {
            v20 = a3;
            if (v12 >= v7)
              v20 = (*(unsigned __int8 *)(v11 + v13 * (v7 - 1) + v18) >> v19) & 1;
          }
          v21 = a3;
          if (v12 > (int)v10)
            v21 = (*(unsigned __int8 *)(v11 + v13 * v10 + v18) >> v19) & 1;
          result = setBitInBitmask(a2, v16 - 1, v7, v15 | (*(unsigned __int8 *)(v14 + v18) >> v19) & 1 | v17 | v20 | v21);
          v8 = *(_DWORD *)(v6 + 8);
          v9 = v16;
        }
        while (v16 < v8);
        v3 = *(_DWORD *)(v6 + 12);
      }
      v7 = v10;
    }
    while ((int)v10 < v3);
  }
  return result;
}

void spreadBitmask3(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  BOOL v11;
  int v12;
  uint64_t v13;
  signed int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  signed int v23;
  int v24;
  int v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  unint64_t v41;
  char v42;
  int v43;
  signed int v44;
  int v45;
  uint64_t v46;
  unsigned int v47;
  int v48;
  int v49;
  int v50;
  int v51;

  v6 = bitmaskBoundingBitmapRect(a1);
  v8 = v7;
  bzero(*(void **)a2, *(int *)(a2 + 12) * (uint64_t)*(int *)(a2 + 16));
  v9 = *(_DWORD *)(a1 + 12);
  if ((int)v6 < 1
    || ((v10 = HIDWORD(v6), v9 > SHIDWORD(v6)) ? (v11 = (int)v8 < 1) : (v11 = 1),
        v11 || *(_DWORD *)(a1 + 8) <= SHIDWORD(v8)))
  {
    if (v9 < 1)
      return;
    v26 = 0;
    v27 = *(_DWORD *)(a1 + 8);
    while (v27 <= 0)
    {
      LODWORD(v30) = v26 + 1;
LABEL_63:
      v26 = v30;
      if ((int)v30 >= v9)
        return;
    }
    v28 = 0;
    v29 = v26 - 1;
    v30 = v26 + 1;
    while (1)
    {
      v31 = 2 * a3;
      v32 = a3;
      if (!v28)
        goto LABEL_37;
      v33 = *(_DWORD *)(a1 + 12);
      v34 = a3;
      if (v26)
      {
        v34 = a3;
        if (v33 >= v26)
          v34 = (*(unsigned __int8 *)(*(_QWORD *)a1 + *(int *)(a1 + 16) * v29 + ((unint64_t)(v28 - 1) >> 3)) >> ((v28 - 1) & 7)) & 1;
      }
      v35 = a3;
      if (v33 > v26)
        v35 = (*(unsigned __int8 *)(*(_QWORD *)a1 + *(int *)(a1 + 16) * (uint64_t)v26 + ((unint64_t)(v28 - 1) >> 3)) >> ((v28 - 1) & 7)) & 1;
      v31 = v35 + v34;
      if (v33 > (int)v30)
        break;
      v32 = a3;
      if (v26)
      {
LABEL_38:
        v36 = *(_QWORD *)a1;
        v37 = *(_DWORD *)(a1 + 12);
        v38 = *(_DWORD *)(a1 + 16);
        if (v37 >= v26)
          v39 = (*(unsigned __int8 *)(v36 + v38 * (uint64_t)(int)v29 + ((unint64_t)v28 >> 3)) >> (v28 & 7)) & 1;
        else
          v39 = a3;
        goto LABEL_43;
      }
LABEL_41:
      v36 = *(_QWORD *)a1;
      v39 = a3;
      v37 = *(_DWORD *)(a1 + 12);
      v38 = *(_DWORD *)(a1 + 16);
LABEL_43:
      v40 = v38;
      v41 = (unint64_t)v28 >> 3;
      v42 = v28 & 7;
      v43 = a3;
      if (v37 > (int)v30)
        v43 = (*(unsigned __int8 *)(v36 + v38 * (uint64_t)(int)v30 + v41) >> v42) & 1;
      v44 = v28 + 1;
      v45 = a3;
      if (v27 > (int)(v28 + 1))
      {
        v45 = a3;
        if (v37 >= v26)
        {
          v45 = a3;
          if (v26)
            v45 = (*(unsigned __int8 *)(v36 + v38 * (uint64_t)(int)v29 + ((unint64_t)(v28 + 1) >> 3)) >> ((v28 + 1) & 7)) & 1;
        }
      }
      v46 = v36 + v38 * (uint64_t)v26;
      v47 = *(unsigned __int8 *)(v46 + v41);
      v48 = a3;
      v49 = a3;
      if (v27 > v44)
      {
        v48 = a3;
        if (v37 > v26)
          v48 = (*(unsigned __int8 *)(v46 + ((unint64_t)(v28 + 1) >> 3)) >> ((v28 + 1) & 7)) & 1;
        if (v37 <= (int)v30)
          v49 = a3;
        else
          v49 = (*(unsigned __int8 *)(v36 + v40 * (uint64_t)(int)v30 + ((unint64_t)(v28 + 1) >> 3)) >> ((v28 + 1) & 7)) & 1;
      }
      v50 = v32 + v31 + v39;
      v51 = (v47 >> v42) & 1;
      if (v50 + v51 + v43 + v45 + v48 + v49 > 1 || v51 != 0)
      {
        setBitInBitmask(a2, v28, v26, 1);
        v27 = *(_DWORD *)(a1 + 8);
      }
      v28 = v44;
      if (v44 >= v27)
      {
        v9 = *(_DWORD *)(a1 + 12);
        goto LABEL_63;
      }
    }
    v32 = (*(unsigned __int8 *)(*(_QWORD *)a1 + *(int *)(a1 + 16) * v30 + ((unint64_t)(v28 - 1) >> 3)) >> ((v28 - 1) & 7)) & 1;
LABEL_37:
    if (v26)
      goto LABEL_38;
    goto LABEL_41;
  }
  if ((int)v6 < SHIDWORD(v6))
  {
    v12 = v6;
    do
    {
      if ((int)v8 >= SHIDWORD(v8))
      {
        LODWORD(v13) = v12 + 1;
      }
      else
      {
        v13 = v12 + 1;
        v14 = v8;
        do
        {
          v15 = *(_QWORD *)a1;
          v16 = *(int *)(a1 + 16);
          v17 = *(_QWORD *)a1 + v16 * (v12 - 1);
          v18 = v14 + 6;
          if (v14 - 1 >= 0)
            v18 = v14 - 1;
          v19 = v15 + (int)v16 * (uint64_t)v12;
          v20 = v15 + v16 * v13;
          v21 = ((*(unsigned __int8 *)(v19 + (v18 >> 3)) >> ((v14 - 1) & 7)) & 1)
              + ((*(unsigned __int8 *)(v17 + (v18 >> 3)) >> ((v14 - 1) & 7)) & 1)
              + ((*(unsigned __int8 *)(v20 + (v18 >> 3)) >> ((v14 - 1) & 7)) & 1)
              + ((*(unsigned __int8 *)(v17 + v14 / 8) >> (v14 & 7)) & 1);
          v22 = (*(unsigned __int8 *)(v19 + v14 / 8) >> (v14 & 7)) & 1;
          v23 = v14 + 1;
          v24 = v14 + 8;
          if (v14 + 1 >= 0)
            v24 = v14 + 1;
          if (v21
             + v22
             + ((*(unsigned __int8 *)(v20 + v14 / 8) >> (v14 & 7)) & 1)
             + ((*(unsigned __int8 *)(v17 + (v24 >> 3)) >> (v23 & 7)) & 1)
             + ((*(unsigned __int8 *)(v19 + (v24 >> 3)) >> (v23 & 7)) & 1)
             + ((*(unsigned __int8 *)(v20 + (v24 >> 3)) >> (v23 & 7)) & 1u) > 1
            || v22 != 0)
          {
            setBitInBitmask(a2, v14, v12, 1);
          }
          v14 = v23;
        }
        while (HIDWORD(v8) != v23);
      }
      v12 = v13;
    }
    while ((_DWORD)v13 != (_DWORD)v10);
  }
}

unint64_t bitmaskBoundingBitmapRect(uint64_t a1)
{
  int16x8_t v1;
  signed int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  __int8 *v6;
  int v7;
  uint32x4_t v8;
  unsigned int v9;
  int8x16_t v10;
  uint32x4_t v11;
  int32x4_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int32x4_t v18;
  int32x4_t v19;
  unsigned int v20;
  __int8 *v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int32x4_t v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int32x4_t v34;
  int8x16_t v35;
  int32x4_t v36;
  int32x4_t v37;
  uint8x8_t v38;
  int16x4_t v39;
  int16x4_t v40;
  int16x4_t v41;
  int16x4_t v42;
  uint16x8_t v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t v46;

  v3 = *(_DWORD *)(a1 + 8);
  v2 = *(_DWORD *)(a1 + 12);
  if (v2 < 1)
  {
    v14 = -1;
    v13 = *(unsigned int *)(a1 + 8);
    v9 = -1;
  }
  else
  {
    v4 = 0;
    v5 = *(unsigned int *)(a1 + 12);
    v6 = *(__int8 **)a1;
    v7 = *(_DWORD *)(a1 + 16);
    v8 = (uint32x4_t)vdupq_n_s32(v3 - 1);
    v9 = -1;
    v10.i64[0] = 0x700000007;
    v10.i64[1] = 0x700000007;
    v11.i64[0] = 0x100000001;
    v11.i64[1] = 0x100000001;
    v12.i64[0] = 0x800000008;
    v12.i64[1] = 0x800000008;
    v13 = *(unsigned int *)(a1 + 8);
    v14 = -1;
    do
    {
      if (v7 >= 1)
      {
        v15 = 0;
        while (!v6[v15])
        {
          if (v7 == (_DWORD)++v15)
            goto LABEL_28;
        }
        if (v3 >= 1)
        {
          v16 = (int8x16_t)vdupq_n_s32(v9);
          v17 = (int8x16_t)vdupq_n_s32(v13);
          v18 = vdupq_n_s32(v14);
          v19 = vdupq_n_s32(v2);
          v20 = (v3 + 7) & 0xFFFFFFF8;
          v21 = v6;
          v22 = (int32x4_t)v16;
          v23 = (int32x4_t)v17;
          v24 = vdupq_n_s32(v4);
          v25 = v18;
          v26 = v19;
          v27 = (int32x4_t)xmmword_19248E120;
          v28 = (int32x4_t)xmmword_19248E110;
          do
          {
            v29 = (int8x16_t)v26;
            v30 = (int8x16_t)v19;
            v31 = (int8x16_t)v25;
            v32 = (int8x16_t)v18;
            v33 = (int8x16_t)v23;
            v34 = (int32x4_t)v17;
            v35 = (int8x16_t)v22;
            v36 = (int32x4_t)v16;
            v37 = (int32x4_t)vcgeq_u32(v8, (uint32x4_t)v27);
            *(int16x4_t *)v1.i8 = vmovn_s32(v37);
            v38 = (uint8x8_t)vmovn_s16(v1);
            if ((v38.i8[0] & 1) != 0)
              v38.i8[0] = *v21;
            if ((vmovn_s16(v1).i8[1] & 1) != 0)
              v38.i8[1] = *v21;
            v39 = (int16x4_t)vmovn_s16(v1);
            if ((v39.i8[2] & 1) != 0)
              v38.i8[2] = *v21;
            if ((vmovn_s16(v1).i8[3] & 1) != 0)
              v38.i8[3] = *v21;
            v1 = (int16x8_t)vcgeq_u32(v8, (uint32x4_t)v28);
            v40 = (int16x4_t)vmovn_s16(vmovn_hight_s32(v39, (int32x4_t)v1));
            if ((v40.i8[4] & 1) != 0)
              v38.i8[4] = *v21;
            v41 = (int16x4_t)vmovn_s16(vmovn_hight_s32(v40, (int32x4_t)v1));
            if ((v41.i8[5] & 1) != 0)
              v38.i8[5] = *v21;
            v42 = (int16x4_t)vmovn_s16(vmovn_hight_s32(v41, (int32x4_t)v1));
            if ((v42.i8[6] & 1) != 0)
              v38.i8[6] = *v21;
            if ((vmovn_s16(vmovn_hight_s32(v42, *(int32x4_t *)&v1)).i8[7] & 1) != 0)
              v38.i8[7] = *v21;
            v43 = vmovl_u8(v38);
            v44 = (int8x16_t)vmovl_high_u16(v43);
            v45 = vbicq_s8((int8x16_t)v37, (int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v11, (uint32x4_t)vandq_s8((int8x16_t)v27, v10)), (int8x16_t)vmovl_u16(*(uint16x4_t *)v43.i8))));
            v46 = vbicq_s8((int8x16_t)v1, (int8x16_t)vceqzq_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32(v11, (uint32x4_t)vandq_s8((int8x16_t)v28, v10)), v44)));
            v26 = (int32x4_t)vbslq_s8(v46, (int8x16_t)vminq_s32(v24, v26), (int8x16_t)v26);
            v19 = (int32x4_t)vbslq_s8(v45, (int8x16_t)vminq_s32(v24, v19), (int8x16_t)v19);
            v25 = (int32x4_t)vbslq_s8(v46, (int8x16_t)vmaxq_s32(v24, v25), (int8x16_t)v25);
            v18 = (int32x4_t)vbslq_s8(v45, (int8x16_t)vmaxq_s32(v24, v18), (int8x16_t)v18);
            v23 = (int32x4_t)vbslq_s8(v46, (int8x16_t)vminq_s32(v28, v23), (int8x16_t)v23);
            v17 = vbslq_s8(v45, (int8x16_t)vminq_s32(v27, v34), (int8x16_t)v34);
            v22 = (int32x4_t)vbslq_s8(v46, (int8x16_t)vmaxq_s32(v28, v22), (int8x16_t)v22);
            v16 = vbslq_s8(v45, (int8x16_t)vmaxq_s32(v27, v36), (int8x16_t)v36);
            v27 = vaddq_s32(v27, v12);
            v28 = vaddq_s32(v28, v12);
            ++v21;
            v20 -= 8;
          }
          while (v20);
          v2 = vminvq_s32(vminq_s32((int32x4_t)vbslq_s8((int8x16_t)v37, (int8x16_t)v19, v30), (int32x4_t)vbslq_s8((int8x16_t)v1, (int8x16_t)v26, v29)));
          v14 = vmaxvq_s32(vmaxq_s32((int32x4_t)vbslq_s8((int8x16_t)v37, (int8x16_t)v18, v32), (int32x4_t)vbslq_s8((int8x16_t)v1, (int8x16_t)v25, v31)));
          v13 = vminvq_s32(vminq_s32((int32x4_t)vbslq_s8((int8x16_t)v37, v17, (int8x16_t)v34), (int32x4_t)vbslq_s8((int8x16_t)v1, (int8x16_t)v23, v33)));
          v9 = vmaxvq_s32(vmaxq_s32((int32x4_t)vbslq_s8((int8x16_t)v37, v16, (int8x16_t)v36), (int32x4_t)vbslq_s8((int8x16_t)v1, (int8x16_t)v22, v35)));
        }
      }
LABEL_28:
      ++v4;
      v6 += v7;
    }
    while (v4 != v5);
  }
  return makeBitmapRect(v13, v2, v9 + 1, v14 + 1);
}

uint64_t chokeBitmask(uint64_t result, uint64_t a2, char a3)
{
  int v3;
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  unint64_t v18;
  char v19;
  int v20;
  int v21;

  v3 = *(_DWORD *)(result + 12);
  if (v3 >= 1)
  {
    v6 = result;
    v7 = 0;
    v8 = *(_DWORD *)(result + 8);
    do
    {
      if (v8 <= 0)
      {
        LODWORD(v10) = v7 + 1;
      }
      else
      {
        v9 = 0;
        v10 = v7 + 1;
        do
        {
          v11 = *(_QWORD *)v6;
          v12 = *(_DWORD *)(v6 + 12);
          v13 = *(int *)(v6 + 16);
          v14 = *(_QWORD *)v6 + (int)v13 * (uint64_t)v7;
          LOBYTE(v15) = a3;
          if (v9)
          {
            LOBYTE(v15) = a3;
            if (v12 > v7)
              v15 = (*(unsigned __int8 *)(v14 + ((unint64_t)(v9 - 1) >> 3)) >> ((v9 - 1) & 7)) & 1;
          }
          v16 = v9 + 1;
          LOBYTE(v17) = a3;
          if (v8 > (int)(v9 + 1))
          {
            LOBYTE(v17) = a3;
            if (v12 > v7)
              v17 = (*(unsigned __int8 *)(v14 + ((unint64_t)(v9 + 1) >> 3)) >> ((v9 + 1) & 7)) & 1;
          }
          v18 = (unint64_t)v9 >> 3;
          v19 = v9 & 7;
          LOBYTE(v20) = a3;
          if (v7)
          {
            LOBYTE(v20) = a3;
            if (v12 >= v7)
              v20 = (*(unsigned __int8 *)(v11 + v13 * (v7 - 1) + v18) >> v19) & 1;
          }
          LOBYTE(v21) = a3;
          if (v12 > (int)v10)
            v21 = (*(unsigned __int8 *)(v11 + v13 * v10 + v18) >> v19) & 1;
          result = setBitInBitmask(a2, v16 - 1, v7, (*(unsigned __int8 *)(v14 + v18) >> v19) & 1 & v15 & v17 & v20 & v21);
          v8 = *(_DWORD *)(v6 + 8);
          v9 = v16;
        }
        while (v16 < v8);
        v3 = *(_DWORD *)(v6 + 12);
      }
      v7 = v10;
    }
    while ((int)v10 < v3);
  }
  return result;
}

unsigned __int8 *computeThresholdedBitmask(unsigned __int8 *result, uint64_t *a2, int a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  unsigned __int8 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;

  v3 = *((_DWORD *)result + 3);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_DWORD *)result + 2);
    v6 = *a2;
    v7 = *(unsigned __int8 **)result;
    v8 = *((int *)a2 + 4);
    v9 = *((int *)result + 7);
    v10 = *((int *)result + 4);
    do
    {
      if (v5 >= 1)
      {
        v11 = 0;
        result = v7;
        do
        {
          if (*result > a3)
            *(_BYTE *)(v6 + ((unint64_t)v11 >> 3)) |= 1 << (v11 & 7);
          ++v11;
          result += v9;
        }
        while (v5 != v11);
      }
      ++v4;
      v7 += v10;
      v6 += v8;
    }
    while (v4 != v3);
  }
  return result;
}

unint64_t bitmaskBoundingBitmapRectWithSeedPoint(uint64_t *a1, int a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  unsigned __int8 *v22;
  uint64_t v23;
  BOOL v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  unsigned __int8 *v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  unsigned __int8 *v34;
  int v35;
  int v36;
  uint64_t v37;
  unsigned __int8 *v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;

  if (a2 < 0
    || a3 < 0
    || (v4 = *((unsigned int *)a1 + 2), (int)v4 <= a2)
    || (v5 = *((unsigned int *)a1 + 3), (int)v5 <= a3)
    || (v6 = *a1,
        v7 = *((int *)a1 + 4),
        v8 = *a1 + (int)v7 * (uint64_t)a3,
        v9 = (unint64_t)a2 >> 3,
        v10 = 1 << (a2 & 7),
        (v10 & *(_BYTE *)(v8 + v9)) == 0))
  {
    v13 = 0;
    LODWORD(v14) = 0;
    v15 = 0;
    v16 = 0;
  }
  else
  {
    LODWORD(v11) = a2;
    while (1)
    {
      v12 = __OFSUB__((_DWORD)v11, 1);
      v11 = (v11 - 1);
      if (((v11 & 0x80000000) != 0) != v12)
        break;
      if (((*(unsigned __int8 *)(v8 + (v11 >> 3)) >> (v11 & 7)) & 1) == 0)
      {
        v13 = (v11 + 1);
        goto LABEL_13;
      }
    }
    v13 = 0;
LABEL_13:
    v18 = v4 - 1;
    if (a2 > (int)v4 - 1)
      v18 = a2;
    while (v18 != a2)
    {
      v15 = (a2 + 1);
      if ((int)v15 >= 0)
        v19 = a2 + 1;
      else
        v19 = a2 + 8;
      v20 = *(unsigned __int8 *)(v8 + (v19 >> 3)) >> (v15 & 7);
      a2 = v15;
      if ((v20 & 1) == 0)
        goto LABEL_22;
    }
    v15 = (v18 + 1);
LABEL_22:
    v21 = a3;
    LODWORD(v14) = a3 + 1;
    v22 = (unsigned __int8 *)(v6 + v9 + (a3 - 1) * v7);
    v23 = a3;
    while (1)
    {
      v24 = v23-- < 1;
      if (v24)
        break;
      v25 = *v22;
      LODWORD(v14) = v14 - 1;
      v22 -= v7;
      if ((v10 & v25) == 0)
        goto LABEL_27;
    }
    LODWORD(v14) = a3 & (a3 >> 31);
LABEL_27:
    v26 = v5 - 1;
    if (a3 > (int)v5 - 1)
      v26 = a3;
    v27 = a3 - 1;
    v28 = v26 - v21;
    v29 = (unsigned __int8 *)(v6 + v9 + v7 + (int)v7 * (uint64_t)(int)v21);
    while (v28)
    {
      v30 = *v29;
      ++v27;
      --v28;
      v29 += v7;
      if ((v10 & v30) == 0)
        goto LABEL_34;
    }
    v27 = v26;
LABEL_34:
    v16 = (v27 + 1);
    while (1)
    {
LABEL_35:
      if ((int)v13 >= 1)
      {
        v31 = 0;
        v32 = v13;
        while ((int)v16 > (int)v14)
        {
          v33 = v32 + 6;
          if ((int)v32 >= 1)
            v33 = v32 - 1;
          v34 = (unsigned __int8 *)(v6 + (int)v7 * (uint64_t)(int)v14 + (v33 >> 3));
          v35 = v16 - v14;
          while (((1 << ((v32 - 1) & 7)) & *v34) == 0)
          {
            v34 += v7;
            if (!--v35)
            {
              v13 = v32;
              goto LABEL_48;
            }
          }
          v31 = 1;
          v24 = (int)v32 < 2;
          v32 = (v32 - 1);
          if (v24)
          {
            v13 = 0;
            goto LABEL_48;
          }
        }
      }
      v31 = 0;
LABEL_48:
      if ((int)v15 < (int)v4)
      {
        v36 = v31;
        v37 = v15;
        while ((int)v16 > (int)v14)
        {
          v38 = (unsigned __int8 *)(v6 + (int)v7 * (uint64_t)(int)v14 + (int)v37 / 8);
          v39 = v16 - v14;
          while (((1 << (v37 & 7)) & *v38) == 0)
          {
            v38 += v7;
            if (!--v39)
            {
              v15 = v37;
              v31 = v36;
              goto LABEL_57;
            }
          }
          v37 = (v37 + 1);
          v36 = 1;
          if ((_DWORD)v37 == (_DWORD)v4)
          {
            v15 = v4;
            v31 = 1;
            break;
          }
        }
      }
LABEL_57:
      if ((int)v14 >= 1)
      {
        v14 = v14;
        v40 = v31;
        while ((int)v13 < (int)v15)
        {
          v41 = v13;
          while (((*(unsigned __int8 *)(v6 + (v14 - 1) * v7 + v41 / 8) >> (v41 & 7)) & 1) == 0)
          {
            if ((_DWORD)v15 == ++v41)
              goto LABEL_68;
          }
          v40 = 1;
          v24 = v14-- < 2;
          if (v24)
          {
            LODWORD(v14) = 0;
            goto LABEL_68;
          }
        }
      }
      v40 = v31;
LABEL_68:
      if ((int)v16 < (int)v5)
      {
        v16 = (int)v16;
        v42 = v40;
LABEL_70:
        if ((int)v13 < (int)v15)
          break;
      }
      if (!v40)
        return makeBitmapRect(v13, v14, v15, v16);
    }
    v43 = v13;
    do
    {
      if (((*(unsigned __int8 *)(v6 + v16 * v7 + v43 / 8) >> (v43 & 7)) & 1) != 0)
      {
        ++v16;
        v42 = 1;
        if (v16 != (int)v5)
          goto LABEL_70;
        v16 = v5;
        goto LABEL_35;
      }
      ++v43;
    }
    while ((_DWORD)v15 != v43);
    if (v42)
      goto LABEL_35;
  }
  return makeBitmapRect(v13, v14, v15, v16);
}

uint64_t bitmaskCentroidUsingBoundingRect(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  BOOL v10;
  int v11;
  int v12;

  if ((int)a2 < SHIDWORD(a2))
  {
    v3 = 0;
    v4 = 0;
    v5 = 0;
    v6 = a2;
    do
    {
      if ((int)a3 < SHIDWORD(a3))
      {
        v7 = a3;
        do
        {
          v8 = *(unsigned __int8 *)(*(_QWORD *)result + *(int *)(result + 16) * (uint64_t)v6 + v7 / 8);
          v9 = 1 << (v7 & 7);
          v10 = (v9 & v8) == 0;
          if ((v9 & v8) != 0)
            v11 = v7;
          else
            v11 = 0;
          v5 += v11;
          if (v10)
            v12 = 0;
          else
            v12 = v6;
          v4 += v12;
          if (!v10)
            ++v3;
          ++v7;
        }
        while (HIDWORD(a3) != v7);
      }
      ++v6;
    }
    while (v6 != HIDWORD(a2));
  }
  return result;
}

uint64_t bitmaskCentroid(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;

  v2 = bitmaskBoundingBitmapRect(a1);
  return bitmaskCentroidUsingBoundingRect(a1, v2, v3);
}

float bitmaskOvalnessUsingBoundingRect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v3;
  int v4;
  float v5;
  int v6;
  int v7;
  uint64_t v8;
  float v9;
  int v10;
  int v11;

  v3 = 1.0 / (float)(HIDWORD(a3) - a3);
  v4 = HIDWORD(a2) - a2;
  v5 = 1.0 / (float)(HIDWORD(a2) - a2);
  if (SHIDWORD(a2) <= (int)a2)
  {
    v7 = 0;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = (uint64_t)rintf(v5 * 16777000.0);
    v9 = rintf(v3 * 16777000.0);
    do
    {
      if (SHIDWORD(a3) > (int)a3)
      {
        v10 = ((int)(uint64_t)v9 >> 1) + 2048;
        v11 = a3;
        do
        {
          v7 += (*(unsigned __int8 *)(*(_QWORD *)a1 + *(int *)(a1 + 16) * (uint64_t)(int)a2 + v11 / 8) >> (v11 & 7)) & 1 ^ (((((((int)v8 >> 1) + 2048 + v6 * (int)v8) >> 12) - 2048) * (((((int)v8 >> 1) + 2048 + v6 * (int)v8) >> 12) - 2048) + ((v10 >> 12) - 2048) * ((v10 >> 12) - 2048)) < 0x400000);
          ++v11;
          v10 += (uint64_t)v9;
        }
        while (HIDWORD(a3) != v11);
      }
      LODWORD(a2) = a2 + 1;
      ++v6;
    }
    while (v6 != v4);
  }
  return (float)v7 * -2.0 * v5 * v3 + 1.0;
}

uint64_t bitmaskAreaUsingBoundingRect(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  int v5;

  v3 = HIDWORD(a2);
  if ((int)a2 >= SHIDWORD(a2))
    return 0;
  v4 = 0;
  do
  {
    if ((int)a3 < SHIDWORD(a3))
    {
      v5 = a3;
      do
      {
        v4 = ((*(unsigned __int8 *)(*(_QWORD *)a1 + *(int *)(a1 + 16) * (uint64_t)(int)a2 + v5 / 8) >> (v5 & 7)) & 1)
           + v4;
        ++v5;
      }
      while (HIDWORD(a3) != v5);
    }
    LODWORD(a2) = a2 + 1;
  }
  while ((_DWORD)a2 != (_DWORD)v3);
  return v4;
}

uint64_t bitmaskArea(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;

  v2 = bitmaskBoundingBitmapRect(a1);
  return bitmaskAreaUsingBoundingRect(a1, v2, v3);
}

uint64_t closestSetBitInBitmaskUsingBoundingRect(uint64_t result, unint64_t a2, uint64_t a3, int *a4, int *a5, double a6, double a7)
{
  unint64_t v7;
  float v8;
  int v9;
  int v10;
  float v11;
  float v12;
  int v13;
  float v14;
  float v15;

  v7 = HIDWORD(a2);
  if ((int)a2 >= SHIDWORD(a2))
  {
    v10 = -1;
    v9 = -1;
  }
  else
  {
    v8 = (float)(*(_DWORD *)(result + 8) * *(_DWORD *)(result + 8) + *(_DWORD *)(result + 12) * *(_DWORD *)(result + 12));
    v9 = -1;
    v10 = -1;
    do
    {
      if ((int)a3 < SHIDWORD(a3))
      {
        v11 = (float)(int)a2 - a7;
        v12 = v11 * v11;
        v13 = a3;
        do
        {
          if (((*(unsigned __int8 *)(*(_QWORD *)result + *(int *)(result + 16) * (uint64_t)(int)a2 + v13 / 8) >> (v13 & 7)) & 1) != 0)
          {
            v14 = (float)v13 - a6;
            v15 = v12 + (float)(v14 * v14);
            if (v15 < v8)
            {
              v10 = v13;
              v9 = a2;
              v8 = v15;
            }
          }
          ++v13;
        }
        while (HIDWORD(a3) != v13);
      }
      LODWORD(a2) = a2 + 1;
    }
    while ((_DWORD)a2 != (_DWORD)v7);
  }
  *a4 = v10;
  *a5 = v9;
  return result;
}

float bitmaskContrastUsingBoundingRect(uint64_t a1, uint64_t *a2, uint64_t a3, unint64_t a4, float *a5, int *a6)
{
  unint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  unint64_t v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v46;
  int v47;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;

  v6 = HIDWORD(a4);
  v8 = *((_DWORD *)a2 + 2);
  v7 = *((_DWORD *)a2 + 3);
  if ((int)a4 <= 1)
    LODWORD(a4) = 1;
  if (v8 <= (int)v6)
    LODWORD(v6) = v8 - 1;
  if ((int)a3 <= 1)
    v9 = 1;
  else
    v9 = a3;
  if (v7 <= SHIDWORD(a3))
    v10 = v7 - 1;
  else
    v10 = HIDWORD(a3);
  if (v9 >= v10)
  {
    *a5 = 0.0;
    *a6 = 0;
  }
  else
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = *a2;
    v15 = *((int *)a2 + 4);
    v16 = (int)v15 * v9;
    v17 = *((int *)a2 + 7);
    v18 = *a2 + v16 + -(int)v15 - v17;
    v19 = *a2 + v16 + (int)v17 - (int)v15;
    v20 = *a2 + v16 - v17;
    v21 = *a2 + v17 + v16;
    v22 = *a2 + v16 - v15;
    v23 = v14 + v15 + v16 - v17;
    v24 = v14 + v15 + v16;
    v25 = v14 + v16 + (int)v17 + (int)v15;
    v26 = (int)v17 * (int)a4;
    v46 = v10;
    v47 = a4;
    do
    {
      if ((int)a4 >= (int)v6)
      {
        ++v9;
      }
      else
      {
        v27 = v19;
        v28 = *(int *)(a1 + 16);
        v29 = *(_QWORD *)a1 + (int)v28 * (uint64_t)v9;
        v30 = *(_QWORD *)a1 + v28 * (v9 + 1);
        v31 = *(_QWORD *)a1 + v28 * (v9 - 1);
        v32 = v25;
        v33 = v24;
        v49 = v23;
        v50 = v21;
        v51 = v20;
        v52 = v19;
        v53 = v22;
        v34 = v18;
        v35 = a4;
        do
        {
          v36 = (unint64_t)v35 >> 3;
          v37 = v35 + 1;
          if (((*(unsigned __int8 *)(v29 + v36) >> (v35 & 7)) & 1) != 0
            && ((*(unsigned __int8 *)(v29 + ((unint64_t)(v35 + 1) >> 3)) >> ((v35 + 1) & 7)) & 1)
             + ((*(unsigned __int8 *)(v30 + v36) >> (v35 & 7)) & 1)
             + ((*(unsigned __int8 *)(v29 + ((unint64_t)(v35 - 1) >> 3)) >> ((v35 - 1) & 7)) & 1)
             + ((*(unsigned __int8 *)(v31 + v36) >> (v35 & 7)) & 1u) <= 3)
          {
            v38 = *(unsigned __int8 *)(v34 + v26) - *(unsigned __int8 *)(v32 + v26);
            if (v38 < 0)
              v38 = *(unsigned __int8 *)(v32 + v26) - *(unsigned __int8 *)(v34 + v26);
            v39 = *(unsigned __int8 *)(v22 + v26) - *(unsigned __int8 *)(v33 + v26);
            if (v39 < 0)
              v39 = *(unsigned __int8 *)(v33 + v26) - *(unsigned __int8 *)(v22 + v26);
            v40 = *(unsigned __int8 *)(v27 + v26) - *(unsigned __int8 *)(v23 + v26);
            if (v40 < 0)
              v40 = *(unsigned __int8 *)(v23 + v26) - *(unsigned __int8 *)(v27 + v26);
            v41 = *(unsigned __int8 *)(v20 + v26) - *(unsigned __int8 *)(v21 + v26);
            if (v41 < 0)
              v41 = *(unsigned __int8 *)(v21 + v26) - *(unsigned __int8 *)(v20 + v26);
            v42 = v40 + v41 + v39 + v38;
            if (v42 >= v11)
              v43 = v11;
            else
              v43 = v42;
            if (v12)
              v11 = v43;
            else
              v11 = v42;
            v13 += v42;
            ++v12;
          }
          v34 += v17;
          v22 += v17;
          v27 += v17;
          v20 += v17;
          v21 += v17;
          v23 += v17;
          v33 += v17;
          v32 += v17;
          v35 = v37;
        }
        while ((_DWORD)v6 != v37);
        v10 = v46;
        LODWORD(a4) = v47;
        ++v9;
        v19 = v52;
        v22 = v53;
        v21 = v50;
        v20 = v51;
        v23 = v49;
      }
      v18 += v15;
      v22 += v15;
      v19 += v15;
      v20 += v15;
      v21 += v15;
      v23 += v15;
      v24 += v15;
      v25 += v15;
    }
    while (v9 != v10);
    *a5 = (float)v11;
    *a6 = v12;
    if (v12)
      return (float)v13 / (float)v12;
  }
  return 0.0;
}

void getBitmaskInfo(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;

  v6 = bitmaskBoundingBitmapRect(a1);
  v8 = v7;
  *(_QWORD *)(a3 + 36) = v6;
  *(_QWORD *)(a3 + 44) = v7;
  bitmaskCentroidUsingBoundingRect(a1, v6, v7);
  *(_QWORD *)a3 = v9;
  *(_QWORD *)(a3 + 8) = v10;
  *(_DWORD *)(a3 + 16) = bitmaskAreaUsingBoundingRect(a1, v6, v8);
  *(float *)(a3 + 20) = bitmaskOvalnessUsingBoundingRect(a1, v6, v8);
  *(float *)(a3 + 24) = bitmaskContrastUsingBoundingRect(a1, a2, v6, v8, (float *)(a3 + 28), (int *)(a3 + 32));
  v11 = *(int *)(a3 + 36) < 1
     || *(_DWORD *)(a3 + 40) >= *(_DWORD *)(a1 + 12)
     || *(int *)(a3 + 44) < 1
     || *(_DWORD *)(a3 + 48) >= *(_DWORD *)(a1 + 8);
  *(_BYTE *)(a3 + 56) = v11;
}

void getBitmaskInfoWithSeedPoint(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;

  v8 = bitmaskBoundingBitmapRectWithSeedPoint((uint64_t *)a1, a4, a5);
  v10 = v9;
  *(_QWORD *)(a3 + 36) = v8;
  *(_QWORD *)(a3 + 44) = v9;
  bitmaskCentroidUsingBoundingRect(a1, v8, v9);
  *(_QWORD *)a3 = v11;
  *(_QWORD *)(a3 + 8) = v12;
  *(_DWORD *)(a3 + 16) = bitmaskAreaUsingBoundingRect(a1, v8, v10);
  *(float *)(a3 + 20) = bitmaskOvalnessUsingBoundingRect(a1, v8, v10);
  *(float *)(a3 + 24) = bitmaskContrastUsingBoundingRect(a1, a2, v8, v10, (float *)(a3 + 28), (int *)(a3 + 32));
  v13 = *(int *)(a3 + 36) < 1
     || *(_DWORD *)(a3 + 40) >= *(_DWORD *)(a1 + 12)
     || *(int *)(a3 + 44) < 1
     || *(_DWORD *)(a3 + 48) >= *(_DWORD *)(a1 + 8);
  *(_BYTE *)(a3 + 56) = v13;
}

__n64 cikernel::_accordianWarpS(CI *a1, double a2, double a3)
{
  float v3;
  __n64 result;
  float v5;
  float v6;
  BOOL v7;
  float v8;
  float v9;
  float v11;

  v11 = *(float *)&a3;
  v3 = *((float *)&a3 + 1);
  result.n64_u64[0] = *(unint64_t *)CI::getDC(a1);
  v5 = (float)(result.n64_f32[1] - v11) / v3;
  if (v5 <= 1.0)
    v6 = (float)(result.n64_f32[1] - v11) / v3;
  else
    v6 = 1.0;
  v7 = v5 < 0.0;
  v8 = 0.0;
  if (!v7)
    v8 = v6;
  v9 = 1.0
     - fabs((float)((float)(v8 * *(float *)&a2) + (float)(floorf((float)(v8 * *(float *)&a2) * 0.5) * -2.0)) + -1.0);
  result.n64_f32[0] = (float)(vmuls_lane_f32(v9, *(float32x2_t *)&a2, 1) + 1.0) * result.n64_f32[0];
  result.n64_u32[1] = fminf(result.n64_f32[1], fmaxf(result.n64_f32[1] - v3, v11));
  return result;
}

void CI::f2_f3_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128);
  uint64_t v12;
  int v13;
  uint64_t v14;
  __n128 *v15;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128))a1[3];
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(_QWORD *)(v10 + 32);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 56)), a2);
  v15 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v15 = (__n128 *)((char *)a2 + 64 * v14);
  *(double *)(a3 + 16 * a7) = v11(a1, *((__n128 *)a2 + 4 * v12), *v15);
}

void CI::WarpKernel::~WarpKernel(CI::WarpKernel *this)
{
  CI::Kernel::~Kernel(this);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::WarpKernel::type(CI::WarpKernel *this)
{
  return 63;
}

uint64_t CI::Kernel::metalConstants(CI::Kernel *this)
{
  return 0;
}

uint64_t CI::Kernel::metalConstantTypes(CI::Kernel *this)
{
  return 0;
}

uint64_t CI::Kernel::metalConstantsDigest(CI::Kernel *this)
{
  return 0;
}

uint64_t CI::Kernel::metal_kernel(CI::Kernel *this)
{
  return 0;
}

void CI::Kernel::~Kernel(CI::Kernel *this)
{
  void *v2;
  void *v3;
  void *v4;
  const void *v5;

  *(_QWORD *)this = &off_1E2EBECD0;
  if (*((_BYTE *)this + 12))
  {
    v2 = (void *)*((_QWORD *)this + 3);
    if (v2)
      free(v2);
    v3 = (void *)*((_QWORD *)this + 4);
    if (v3 && !*((_BYTE *)this + 104))
      free(v3);
    v4 = (void *)*((_QWORD *)this + 5);
    if (v4)
      free(v4);
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 5) = 0;
    v5 = (const void *)*((_QWORD *)this + 14);
    if (v5)
    {
      CFRelease(v5);
      *((_QWORD *)this + 14) = 0;
    }
  }
  CI::KernelArguments::~KernelArguments((CI::Kernel *)((char *)this + 144));
}

{
  CI::Kernel::~Kernel(this);
  JUMPOUT(0x194025AACLL);
}

void sub_19221107C(_Unwind_Exception *a1)
{
  uint64_t v1;

  CI::KernelArguments::~KernelArguments((CI::KernelArguments *)(v1 + 144));
  _Unwind_Resume(a1);
}

uint64_t CI::Kernel::type(CI::Kernel *this)
{
  return 61;
}

void CI::KernelArguments::~KernelArguments(CI::KernelArguments *this)
{
  uint64_t v2;
  void *v3;
  CI::SerialStringArray *v4;

  v2 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v3 = *(void **)(v2 + 16);
    if (v3)
      free(v3);
    MEMORY[0x194025AAC](v2, 0x1010C40C0D7B093);
  }
  *(_QWORD *)this = 0;
  v4 = (CI::SerialStringArray *)*((_QWORD *)this + 1);
  if (v4)
  {
    CI::SerialStringArray::~SerialStringArray(v4);
    MEMORY[0x194025AAC]();
  }
  *((_QWORD *)this + 1) = 0;
}

void CI::SerialStringArray::~SerialStringArray(CI::SerialStringArray *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 4);
  if (v3)
    free(v3);
}

__n64 cikernel::_accordianWarpT(CI *a1, double a2, __n128 a3)
{
  float v3;
  __n64 result;
  float v7;
  float v8;
  float v10;
  float v11;

  v3 = a3.n128_f32[1];
  result.n64_u64[0] = *(unint64_t *)CI::getDC(a1);
  _V16.S[2] = a3.n128_u32[2];
  _S2 = result.n64_f32[1] - a3.n128_f32[0];
  v7 = (float)(result.n64_f32[1] - a3.n128_f32[0]) / v3;
  if (v7 <= 1.0)
    v8 = (float)(result.n64_f32[1] - a3.n128_f32[0]) / v3;
  else
    v8 = 1.0;
  _NF = v7 < 0.0;
  v10 = 0.0;
  if (!_NF)
    v10 = v8;
  v11 = 1.0
      - fabs((float)((float)(v10 * *(float *)&a2) + (float)(floorf((float)(v10 * *(float *)&a2) * 0.5) * -2.0)) + -1.0);
  __asm { FMLA            S4, S2, V16.S[2] }
  result.n64_f32[0] = (float)(vmuls_lane_f32(v11, *(float32x2_t *)&a2, 1) + 1.0) * result.n64_f32[0];
  result.n64_u32[1] = fmaxf(result.n64_f32[1], fminf(_S4, a3.n128_f32[3] + result.n64_f32[1]));
  return result;
}

double cikernel::_accordionMix(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float a5, double a6)
{
  float v6;
  uint64_t DC;
  float v8;
  float v9;
  BOOL v10;
  float v11;
  double result;
  float v13;

  v13 = *(float *)&a6;
  v6 = *((float *)&a6 + 1);
  DC = CI::getDC(a1);
  v8 = (float)(*(float *)(DC + 4) - v13) / v6;
  if (v8 <= 1.0)
    v9 = (float)(*(float *)(DC + 4) - v13) / v6;
  else
    v9 = 1.0;
  v10 = v8 < 0.0;
  v11 = 0.0;
  if (!v10)
    v11 = v9;
  *(_QWORD *)&result = vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - a5), a3, a5), 1.0 - vmuls_lane_f32((float)(v11 * a4.f32[0]) - floorf(v11 * a4.f32[0]), a4, 2)).u64[0];
  return result;
}

void CI::f4_s_s_f3_f_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, float, __n128);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __n128 *v19;
  __n128 *v20;
  __n128 *v21;
  __int128 v22;
  int v23;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, float, __n128))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_QWORD *)(v9 + 80);
  v17 = *(_DWORD *)(v9 + 112);
  v18 = *(_QWORD *)(v9 + 104);
  if (*(_BYTE *)(a1 + 64))
  {
    v23 = *(_DWORD *)(v9 + 40);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
    v13 = v23;
  }
  v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v18);
  v20 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v14);
  v21 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v21 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v22 = v10(*v21, *v20, *((__n128 *)a2 + 4 * v15), *((float *)a2 + 16 * v16), *v19);
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

void CI::ColorKernel::~ColorKernel(CI::ColorKernel *this)
{
  CI::Kernel::~Kernel(this);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::ColorKernel::type(CI::ColorKernel *this)
{
  return 62;
}

uint64_t CI::ColorKernel::set_extentType(uint64_t result, int a2)
{
  if (*(_BYTE *)(result + 12))
    *(_DWORD *)(result + 168) = a2;
  return result;
}

uint64_t CI::ColorKernel::set_blendBehavior(uint64_t result, int a2, int a3)
{
  int v3;

  if (*(_BYTE *)(result + 12))
  {
    if (a3)
      v3 = *(_DWORD *)(result + 172) | a2;
    else
      v3 = *(_DWORD *)(result + 172) & ~a2;
    *(_DWORD *)(result + 172) = v3;
  }
  return result;
}

double cikernel::_accordionFoldTransition(uint64_t a1, uint64_t a2, float32x4_t a3, float a4, float64x2_t a5)
{
  float v7;
  uint64_t v8;
  double v9;
  int8x16_t v10;
  float v11;
  int8x16_t v12;
  float64x2_t v14;
  float v15;
  uint8x8_t v17;
  double v18;
  double v19;
  float v20;
  double v21;
  double v27;
  double v28;
  int8x16_t v29;
  uint8x8_t v30;
  double v31;
  int8x16_t v32;
  float32x4_t v33;
  double result;
  float32x4_t v35;
  float v37;

  v7 = *((float *)a5.f64 + 1);
  v8 = *(_QWORD *)CI::getDC((CI *)a1);
  v11 = *((float *)&v8 + 1);
  v12 = (int8x16_t)a5;
  _S11 = *((float *)&v8 + 1) - *(float *)a5.f64;
  *(float *)v14.f64 = (float)(*((float *)&v8 + 1) - *(float *)a5.f64) / v7;
  if (*(float *)v14.f64 <= 1.0)
    v15 = (float)(*((float *)&v8 + 1) - *(float *)a5.f64) / v7;
  else
    v15 = 1.0;
  _NF = *(float *)v14.f64 < 0.0;
  LODWORD(v14.f64[0]) = 0;
  if (!_NF)
    *(float *)v14.f64 = v15;
  v17.i32[1] = a3.i32[1];
  *(float *)v14.f64 = *(float *)v14.f64 * a3.f32[0];
  v18 = 1.0;
  v19 = 1.0 - fabs((float)(*(float *)v14.f64 + (float)(floorf(*(float *)v14.f64 * 0.5) * -2.0)) + -1.0);
  *(float *)&v19 = v19;
  *(float *)&v18 = fminf(*((float *)&v8 + 1), fmaxf(*((float *)&v8 + 1) - v7, *(float *)a5.f64));
  v20 = (float)(vmuls_lane_f32(*(float *)&v19, *(float32x2_t *)a3.f32, 1) + 1.0) * *(float *)&v8;
  v12.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)&v21 = *(float *)(a1 + 24)
                 + (float)((float)(*(float *)(a1 + 20) * *(float *)&v18) + (float)(v20 * *(float *)(a1 + 16)));
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&v19 = *(float *)&v18 * *(float *)(a1 + 32);
  v37 = 1.0 - vmuls_lane_f32(*(float *)v14.f64 - floorf(*(float *)v14.f64), a3, 2);
  *(float *)v14.f64 = *(float *)v17.i32 + (float)(*(float *)&v19 + (float)(v20 * *(float *)v12.i32));
  *((float *)&v21 + 1) = *(float *)v14.f64;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v21, v14, v19, v18, v12, v17, v9, v10);
  v35 = _Q0;
  _Q1 = a5;
  __asm { FMLA            S0, S11, V1.S[2] }
  *(float *)_Q1.f64 = fmaxf(v11, fminf(_Q0.f32[0], *((float *)&a5.f64[1] + 1) + v11));
  LODWORD(v27) = *(_DWORD *)(a2 + 28);
  _Q0.f32[0] = *(float *)(a2 + 24)
             + (float)((float)(*(float *)_Q1.f64 * *(float *)(a2 + 20)) + (float)(v20 * *(float *)(a2 + 16)));
  LODWORD(v28) = *(_DWORD *)(a2 + 32);
  v29.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)_Q1.f64 = *(float *)v29.i32
                    + (float)((float)(*(float *)_Q1.f64 * *(float *)&v28) + (float)(v20 * *(float *)&v27));
  _Q0.i32[1] = LODWORD(_Q1.f64[0]);
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)_Q0.i64, _Q1, v28, v27, v29, v30, v31, v32);
  *(_QWORD *)&result = vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(v35, 1.0 - a4), v33, a4), v37).u64[0];
  return result;
}

void CI::f4_sr_sr_f3_f_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, uint64_t, __n128, float, __n128);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __int128 v19;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t, __n128, float, __n128))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_QWORD *)(v10 + 32);
  v14 = *(_QWORD *)(v10 + 56);
  v15 = *(_QWORD *)(v10 + 80);
  v16 = *(_DWORD *)(v10 + 112);
  v17 = *(_QWORD *)(v10 + 104);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 128)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  *(double *)&v19 = v11(a4 + 80 * v12, a4 + 80 * v13, *((__n128 *)a2 + 4 * v14), *((float *)a2 + 16 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

void CI::GeneralKernel::~GeneralKernel(CI::GeneralKernel *this)
{
  CI::Kernel::~Kernel(this);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::GeneralKernel::type(CI::GeneralKernel *this)
{
  return 64;
}

float32x2_t cikernel::_tile(CI *a1, float32x2_t a2, int8x16_t a3)
{
  float32x2_t v4;

  v4 = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), vsub_f32(*(float32x2_t *)CI::getDC(a1), a2));
  return vadd_f32(a2, vmul_f32(*(float32x2_t *)a3.i8, vminnm_f32(vsub_f32(v4, vrndm_f32(v4)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu))));
}

void CI::f2_f2_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, double, __n128);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __n128 *v16;
  double *v17;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, double, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 56)), a2);
  v16 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v16 = (__n128 *)((char *)a2 + 64 * v15);
  v17 = (double *)(a3 + 16 * v13);
  if (v12 != 5)
    v17 = (double *)((char *)a2 + 64 * v13);
  *(double *)(a3 + 16 * a7) = v11(a1, *v17, *v16);
}

float32x2_t cikernel::_lowq_affine(CI *a1, float32x2_t a2, float32x2_t a3, float32x2_t a4)
{
  float32x2_t *DC;
  int32x2_t v8;
  int32x2_t v9;

  DC = (float32x2_t *)CI::getDC(a1);
  v8 = (int32x2_t)vmul_f32(a3, *DC);
  v9 = (int32x2_t)vmul_f32(a4, *DC);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v8, v9), (float32x2_t)vzip2_s32(v8, v9)));
}

void CI::f2_f2_f2_f2(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, double, double, double);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  double *v18;
  double *v19;
  double *v20;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, double, double, double))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_DWORD *)(v10 + 64);
  v17 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (double *)((char *)a2 + 64 * v17);
  v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (double *)((char *)a2 + 64 * v15);
  v20 = (double *)(a3 + 16 * v13);
  if (v12 != 5)
    v20 = (double *)((char *)a2 + 64 * v13);
  *(double *)(a3 + 16 * a7) = v11(a1, *v20, *v19, *v18);
}

uint64_t CGAffineTransformFromObject(objc_object *a1, CGAffineTransform *a2)
{
  const char *v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  CGFloat v8;
  CGFloat v9;
  CGFloat v10;
  CGFloat v11;
  CGFloat v12;
  CGFloat v13;

  if (!a1)
  {
    v5 = *MEMORY[0x1E0C9BAA8];
    v6 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 32);
    *(_OWORD *)&a2->c = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
    *(_OWORD *)&a2->tx = v6;
    *(_OWORD *)&a2->a = v5;
    return 1;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      -[objc_object transformStruct](a1, "transformStruct");
      *(_OWORD *)&a2->a = 0u;
      *(_OWORD *)&a2->c = 0u;
      *(_OWORD *)&a2->tx = 0u;
      return 1;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0 && -[objc_object count](a1, "count") == 6)
    {
      objc_msgSend((id)-[objc_object objectAtIndex:](a1, "objectAtIndex:", 0), "doubleValue");
      a2->a = v8;
      v7 = 1;
      objc_msgSend((id)-[objc_object objectAtIndex:](a1, "objectAtIndex:", 1), "doubleValue");
      a2->b = v9;
      objc_msgSend((id)-[objc_object objectAtIndex:](a1, "objectAtIndex:", 2), "doubleValue");
      a2->c = v10;
      objc_msgSend((id)-[objc_object objectAtIndex:](a1, "objectAtIndex:", 3), "doubleValue");
      a2->d = v11;
      objc_msgSend((id)-[objc_object objectAtIndex:](a1, "objectAtIndex:", 4), "doubleValue");
      a2->tx = v12;
      objc_msgSend((id)-[objc_object objectAtIndex:](a1, "objectAtIndex:", 5), "doubleValue");
      a2->ty = v13;
      return v7;
    }
    return 0;
  }
  v4 = (const char *)-[objc_object objCType](a1, "objCType");
  if (strcmp(v4, "{CGAffineTransform=dddddd}") && strcmp(v4, "{?=dddddd}"))
    return 0;
  -[objc_object getValue:size:](a1, "getValue:size:", a2, 48);
  return 1;
}

double cikernel::_ASGh50(uint64x2_t **this, SamplerObj *a2)
{
  float32x2_t *DC;
  double v4;
  double v5;
  float64x2_t v6;
  int8x16_t v7;
  float v8;
  double v9;
  float v10;
  float v11;
  float32x2_t v12;
  int8x16_t v13;
  float32x2_t v14;
  double v15;
  float32x4_t v16;
  float32x4_t v17;
  double v18;
  double v19;
  int8x16_t v20;
  uint8x8_t v21;
  double v22;
  int8x16_t v23;
  float32x4_t v24;
  float64x2_t v25;
  double v26;
  double v27;
  int8x16_t v28;
  uint8x8_t v29;
  double v30;
  int8x16_t v31;
  float64x2_t v33;
  float32x2_t v38;
  double v39;
  double v40;
  int8x16_t v41;
  uint8x8_t v42;
  double v43;
  int8x16_t v44;
  float32x4_t v45;
  float64x2_t v46;
  double v47;
  double v48;
  int8x16_t v49;
  uint8x8_t v50;
  double v51;
  int8x16_t v52;
  float64x2_t v54;
  float32x2_t v55;
  double v56;
  double v57;
  int8x16_t v58;
  uint8x8_t v59;
  double v60;
  int8x16_t v61;
  float32x4_t v62;
  float64x2_t v63;
  double v64;
  double v65;
  int8x16_t v66;
  uint8x8_t v67;
  double v68;
  int8x16_t v69;
  float32x4_t v70;
  double result;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x2_t v78;

  DC = (float32x2_t *)CI::getDC((CI *)this);
  v4 = 2.0;
  v5 = 0.5;
  v6.f64[0] = floor(floorf(COERCE_FLOAT(*DC)) * 2.0 + 0.499) + 0.5;
  *(float *)v6.f64 = v6.f64[0];
  LODWORD(v5) = *((_DWORD *)this + 4);
  LODWORD(v4) = *((_DWORD *)this + 5);
  v7.i32[0] = *((_DWORD *)this + 6);
  v8 = *((float *)this + 7);
  *(float *)&v9 = *(float *)v7.i32 + (float)(*(float *)&v5 + (float)(*(float *)&v4 * 0.0));
  v10 = *((float *)this + 8);
  v11 = *((float *)this + 9);
  *((float *)&v9 + 1) = v11 + (float)(v8 + (float)(v10 * 0.0));
  v12.f32[0] = *(float *)v7.i32 + (float)((float)(*(float *)&v4 * 0.0) + (float)(*(float *)&v5 * 0.0));
  *(float *)v13.i32 = v11 + (float)((float)(v10 * 0.0) + (float)(v8 * 0.0));
  v12.f32[1] = *(float *)v13.i32;
  v14 = vsub_f32(*(float32x2_t *)&v9, v12);
  *(float *)&v4 = vmuls_lane_f32(*(float *)&v4, *DC, 1);
  *(float *)&v15 = *(float *)v7.i32 + (float)(*(float *)&v4 + (float)(*(float *)v6.f64 * *(float *)&v5));
  *(float *)&v5 = vmuls_lane_f32(v10, *DC, 1);
  *(float *)v6.f64 = v11 + (float)(*(float *)&v5 + (float)(*(float *)v6.f64 * v8));
  HIDWORD(v15) = LODWORD(v6.f64[0]);
  v78 = *(float32x2_t *)&v15;
  *(double *)v16.i64 = CI::BitmapSampler::read(this[1], v15, v6, v5, v4, v13, (uint8x8_t)v12, v9, v7);
  v17 = (float32x4_t)vdupq_n_s32(0x3F0006F2u);
  v75 = vmulq_f32(v16, v17);
  *(double *)v24.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v14, v78)), (float64x2_t)v17, v18, v19, v20, v21, v22, v23);
  v72 = v24;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v78, v14)), v25, v26, v27, v28, v29, v30, v31);
  v33 = (float64x2_t)v75;
  v76 = vaddq_f32(v75, vmulq_f32(vaddq_f32(v72, _Q0), (float32x4_t)vdupq_n_s32(0x3E96D656u)));
  __asm { FMOV            V0.2S, #3.0 }
  v38 = vmul_f32(v14, *(float32x2_t *)_Q0.f32);
  *(double *)v45.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v38, v78)), v33, v39, v40, v41, v42, v43, v44);
  v73 = v45;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v78, v38)), v46, v47, v48, v49, v50, v51, v52);
  v54 = (float64x2_t)v76;
  v77 = vaddq_f32(v76, vmulq_f32(vaddq_f32(v73, _Q0), (float32x4_t)vdupq_n_s32(0xBD4FC321)));
  __asm { FMOV            V0.2S, #5.0 }
  v55 = vmul_f32(v14, *(float32x2_t *)_Q0.f32);
  *(double *)v62.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v55, v78)), v54, v56, v57, v58, v59, v60, v61);
  v74 = v62;
  *(double *)v70.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v78, v55)), v63, v64, v65, v66, v67, v68, v69);
  *(_QWORD *)&result = vaddq_f32(v77, vmulq_f32(vaddq_f32(v74, v70), (float32x4_t)vdupq_n_s32(0x3BC6C851u))).u64[0];
  return result;
}

void CI::f4_sr(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t);
  uint64_t v12;
  __int128 v13;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 32)), a2);
  *(double *)&v13 = v11(a4 + 80 * v12);
  *(_OWORD *)(a3 + 16 * a7) = v13;
}

double cikernel::_ASGv50(uint64x2_t **this, SamplerObj *a2)
{
  _QWORD *DC;
  double v4;
  double v5;
  float64x2_t v6;
  double v7;
  int8x16_t v8;
  float32x2_t v9;
  float v10;
  float v11;
  float32x2_t v12;
  int8x16_t v13;
  float32x2_t v14;
  double v15;
  float32x4_t v16;
  float32x4_t v17;
  double v18;
  double v19;
  int8x16_t v20;
  uint8x8_t v21;
  double v22;
  int8x16_t v23;
  float32x4_t v24;
  float64x2_t v25;
  double v26;
  double v27;
  int8x16_t v28;
  uint8x8_t v29;
  double v30;
  int8x16_t v31;
  float64x2_t v33;
  float32x2_t v38;
  double v39;
  double v40;
  int8x16_t v41;
  uint8x8_t v42;
  double v43;
  int8x16_t v44;
  float32x4_t v45;
  float64x2_t v46;
  double v47;
  double v48;
  int8x16_t v49;
  uint8x8_t v50;
  double v51;
  int8x16_t v52;
  float64x2_t v54;
  float32x2_t v55;
  double v56;
  double v57;
  int8x16_t v58;
  uint8x8_t v59;
  double v60;
  int8x16_t v61;
  float32x4_t v62;
  float64x2_t v63;
  double v64;
  double v65;
  int8x16_t v66;
  uint8x8_t v67;
  double v68;
  int8x16_t v69;
  float32x4_t v70;
  double result;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float32x2_t v78;

  DC = (_QWORD *)CI::getDC((CI *)this);
  v4 = 2.0;
  v5 = 0.5;
  v6.f64[0] = floor(floorf(COERCE_FLOAT(HIDWORD(*DC))) * 2.0 + 0.499) + 0.5;
  *(float *)v6.f64 = v6.f64[0];
  LODWORD(v5) = *((_DWORD *)this + 4);
  LODWORD(v4) = *((_DWORD *)this + 5);
  LODWORD(v7) = *((_DWORD *)this + 6);
  v8.i32[0] = *((_DWORD *)this + 7);
  v9.f32[0] = *(float *)&v7 + (float)(*(float *)&v4 + (float)(*(float *)&v5 * 0.0));
  v10 = *((float *)this + 8);
  v11 = *((float *)this + 9);
  v9.f32[1] = v11 + (float)(v10 + (float)(*(float *)v8.i32 * 0.0));
  v12.f32[0] = *(float *)&v7 + (float)((float)(*(float *)&v4 * 0.0) + (float)(*(float *)&v5 * 0.0));
  *(float *)v13.i32 = v11 + (float)((float)(v10 * 0.0) + (float)(*(float *)v8.i32 * 0.0));
  v12.f32[1] = *(float *)v13.i32;
  v14 = vsub_f32(v9, v12);
  *(float *)&v4 = vmlas_n_f32(*(float *)&v4 * *(float *)v6.f64, *(float *)&v5, COERCE_FLOAT(*DC));
  *(float *)&v5 = *(float *)&v7 + *(float *)&v4;
  *(float *)v6.f64 = v11 + vmlas_n_f32(v10 * *(float *)v6.f64, *(float *)v8.i32, COERCE_FLOAT(*DC));
  *(float *)&v15 = *(float *)&v7 + *(float *)&v4;
  HIDWORD(v15) = LODWORD(v6.f64[0]);
  v78 = *(float32x2_t *)&v15;
  *(double *)v16.i64 = CI::BitmapSampler::read(this[1], v15, v6, v5, v4, v13, (uint8x8_t)v9, v7, v8);
  v17 = (float32x4_t)vdupq_n_s32(0x3F0006F2u);
  v75 = vmulq_f32(v16, v17);
  *(double *)v24.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v14, v78)), (float64x2_t)v17, v18, v19, v20, v21, v22, v23);
  v72 = v24;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v78, v14)), v25, v26, v27, v28, v29, v30, v31);
  v33 = (float64x2_t)v75;
  v76 = vaddq_f32(v75, vmulq_f32(vaddq_f32(v72, _Q0), (float32x4_t)vdupq_n_s32(0x3E96D656u)));
  __asm { FMOV            V0.2S, #3.0 }
  v38 = vmul_f32(v14, *(float32x2_t *)_Q0.f32);
  *(double *)v45.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v38, v78)), v33, v39, v40, v41, v42, v43, v44);
  v73 = v45;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v78, v38)), v46, v47, v48, v49, v50, v51, v52);
  v54 = (float64x2_t)v76;
  v77 = vaddq_f32(v76, vmulq_f32(vaddq_f32(v73, _Q0), (float32x4_t)vdupq_n_s32(0xBD4FC321)));
  __asm { FMOV            V0.2S, #5.0 }
  v55 = vmul_f32(v14, *(float32x2_t *)_Q0.f32);
  *(double *)v62.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v55, v78)), v54, v56, v57, v58, v59, v60, v61);
  v74 = v62;
  *(double *)v70.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v78, v55)), v63, v64, v65, v66, v67, v68, v69);
  *(_QWORD *)&result = vaddq_f32(v77, vmulq_f32(vaddq_f32(v74, v70), (float32x4_t)vdupq_n_s32(0x3BC6C851u))).u64[0];
  return result;
}

double cikernel::_ASGh66(uint64x2_t **this, SamplerObj *a2)
{
  float32x2_t *DC;
  float v4;
  float v5;
  float v6;
  double v7;
  float64x2_t v8;
  float v9;
  int8x16_t v10;
  float v11;
  double v12;
  float v13;
  float v14;
  float32x2_t v15;
  int8x16_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  double v21;
  float32x4_t v22;
  float64x2_t v23;
  double v24;
  double v25;
  int8x16_t v26;
  uint8x8_t v27;
  double v28;
  int8x16_t v29;
  float32x4_t v30;
  float64x2_t v31;
  double v32;
  double v33;
  int8x16_t v34;
  uint8x8_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  float64x2_t v39;
  double v40;
  double v41;
  int8x16_t v42;
  uint8x8_t v43;
  double v44;
  int8x16_t v45;
  float32x4_t v46;
  float64x2_t v47;
  double v48;
  double v49;
  int8x16_t v50;
  uint8x8_t v51;
  double v52;
  int8x16_t v53;
  float32x4_t v54;
  float64x2_t v55;
  double v56;
  double v57;
  int8x16_t v58;
  uint8x8_t v59;
  double v60;
  int8x16_t v61;
  float32x4_t v62;
  float64x2_t v63;
  double v64;
  double v65;
  int8x16_t v66;
  uint8x8_t v67;
  double v68;
  int8x16_t v69;
  float32x4_t v70;
  float64x2_t v71;
  double v72;
  double v73;
  int8x16_t v74;
  uint8x8_t v75;
  double v76;
  int8x16_t v77;
  float32x4_t v78;
  float64x2_t v79;
  double v80;
  double v81;
  int8x16_t v82;
  uint8x8_t v83;
  double v84;
  int8x16_t v85;
  float32x4_t v86;
  double result;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float v96;
  double v97;

  DC = (float32x2_t *)CI::getDC((CI *)this);
  v4 = 0.5 * COERCE_FLOAT(*DC);
  v5 = floorf(v4);
  v6 = floor((float)(v4 - v5) + (float)(v4 - v5));
  v96 = v6;
  v7 = 1.5;
  v8.f64[0] = floor(floorf(COERCE_FLOAT(*DC)) * 1.5 + 0.499) + 0.5;
  *(float *)v8.f64 = v8.f64[0];
  v9 = *((float *)this + 4);
  LODWORD(v7) = *((_DWORD *)this + 5);
  v10.i32[0] = *((_DWORD *)this + 6);
  v11 = *((float *)this + 7);
  *(float *)&v12 = *(float *)v10.i32 + (float)(v9 + (float)(*(float *)&v7 * 0.0));
  v13 = *((float *)this + 8);
  v14 = *((float *)this + 9);
  *((float *)&v12 + 1) = v14 + (float)(v11 + (float)(v13 * 0.0));
  v15.f32[0] = *(float *)v10.i32 + (float)((float)(*(float *)&v7 * 0.0) + (float)(v9 * 0.0));
  *(float *)v16.i32 = v14 + (float)((float)(v13 * 0.0) + (float)(v11 * 0.0));
  v15.f32[1] = *(float *)v16.i32;
  v17 = vsub_f32(*(float32x2_t *)&v12, v15);
  v18 = vadd_f32(v17, v17);
  v19 = vadd_f32(v17, v18);
  v20 = vadd_f32(v18, v18);
  *(float *)&v7 = vmuls_lane_f32(*(float *)&v7, *DC, 1);
  *(float *)&v21 = *(float *)v10.i32 + (float)(*(float *)&v7 + (float)(*(float *)v8.f64 * v9));
  *((float *)&v21 + 1) = v14 + (float)(vmuls_lane_f32(v13, *DC, 1) + (float)(*(float *)v8.f64 * v11));
  v97 = v21;
  *(double *)v22.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v21, v20)), v8, v21, v7, v16, (uint8x8_t)v15, v12, v10);
  v94 = v22;
  *(double *)v30.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v97, v19)), v23, v24, v25, v26, v27, v28, v29);
  v95 = v30;
  *(double *)v38.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v97, v18)), v31, v32, v33, v34, v35, v36, v37);
  v93 = v38;
  *(double *)v46.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v97, v17)), v39, v40, v41, v42, v43, v44, v45);
  v92 = v46;
  *(double *)v54.i64 = CI::BitmapSampler::read(this[1], v97, v47, v48, v49, v50, v51, v52, v53);
  v91 = v54;
  *(double *)v62.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v17, *(float32x2_t *)&v97)), v55, v56, v57, v58, v59, v60, v61);
  v89 = v62;
  *(double *)v70.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v18, *(float32x2_t *)&v97)), v63, v64, v65, v66, v67, v68, v69);
  v88 = v70;
  *(double *)v78.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v97, v19)), v71, v72, v73, v74, v75, v76, v77);
  v90 = v78;
  *(double *)v86.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v97, v20)), v79, v80, v81, v82, v83, v84, v85);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v91, (float32x4_t)vdupq_n_s32(0x3F2AA3BCu)), vmulq_f32(vaddq_f32(v92, v89), (float32x4_t)vdupq_n_s32(0x3E75B08Du))), vmulq_f32(vaddq_f32(v93, v88), (float32x4_t)vdupq_n_s32(0xBD9EC1EA))), vmulq_f32(vaddq_f32(v94, v86), (float32x4_t)vdupq_n_s32(0x3B8D1E61u))), 1.0 - v96), vaddq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v91, v89), (float32x4_t)vdupq_n_s32(0x3F086A95u)), vmulq_f32(vaddq_f32(v93, v90), (float32x4_t)vdupq_n_s32(0xBD32FB50))), vmulq_f32(vaddq_f32(v95, v86), (float32x4_t)vdupq_n_s32(0x3C31480Cu))), v96).u64[0];
  return result;
}

double cikernel::_ASGv66(uint64x2_t **this, SamplerObj *a2)
{
  float32x2_t *DC;
  float v4;
  float v5;
  float v6;
  double v7;
  float64x2_t v8;
  float v9;
  double v10;
  int8x16_t v11;
  float32x2_t v12;
  float v13;
  float v14;
  float32x2_t v15;
  int8x16_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  double v21;
  float32x4_t v22;
  float64x2_t v23;
  double v24;
  double v25;
  int8x16_t v26;
  uint8x8_t v27;
  double v28;
  int8x16_t v29;
  float32x4_t v30;
  float64x2_t v31;
  double v32;
  double v33;
  int8x16_t v34;
  uint8x8_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  float64x2_t v39;
  double v40;
  double v41;
  int8x16_t v42;
  uint8x8_t v43;
  double v44;
  int8x16_t v45;
  float32x4_t v46;
  float64x2_t v47;
  double v48;
  double v49;
  int8x16_t v50;
  uint8x8_t v51;
  double v52;
  int8x16_t v53;
  float32x4_t v54;
  float64x2_t v55;
  double v56;
  double v57;
  int8x16_t v58;
  uint8x8_t v59;
  double v60;
  int8x16_t v61;
  float32x4_t v62;
  float64x2_t v63;
  double v64;
  double v65;
  int8x16_t v66;
  uint8x8_t v67;
  double v68;
  int8x16_t v69;
  float32x4_t v70;
  float64x2_t v71;
  double v72;
  double v73;
  int8x16_t v74;
  uint8x8_t v75;
  double v76;
  int8x16_t v77;
  float32x4_t v78;
  float64x2_t v79;
  double v80;
  double v81;
  int8x16_t v82;
  uint8x8_t v83;
  double v84;
  int8x16_t v85;
  float32x4_t v86;
  double result;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float v96;
  double v97;

  DC = (float32x2_t *)CI::getDC((CI *)this);
  v4 = vmuls_lane_f32(0.5, *DC, 1);
  v5 = floorf(v4);
  v6 = floor((float)(v4 - v5) + (float)(v4 - v5));
  v96 = v6;
  v7 = 1.5;
  v8.f64[0] = floor(floorf(COERCE_FLOAT(HIDWORD(*(unint64_t *)DC))) * 1.5 + 0.499) + 0.5;
  *(float *)v8.f64 = v8.f64[0];
  v9 = *((float *)this + 4);
  LODWORD(v7) = *((_DWORD *)this + 5);
  LODWORD(v10) = *((_DWORD *)this + 6);
  v11.i32[0] = *((_DWORD *)this + 7);
  v12.f32[0] = *(float *)&v10 + (float)(*(float *)&v7 + (float)(v9 * 0.0));
  v13 = *((float *)this + 8);
  v14 = *((float *)this + 9);
  v12.f32[1] = v14 + (float)(v13 + (float)(*(float *)v11.i32 * 0.0));
  v15.f32[0] = *(float *)&v10 + (float)((float)(*(float *)&v7 * 0.0) + (float)(v9 * 0.0));
  *(float *)v16.i32 = v14 + (float)((float)(v13 * 0.0) + (float)(*(float *)v11.i32 * 0.0));
  v15.f32[1] = *(float *)v16.i32;
  v17 = vsub_f32(v12, v15);
  v18 = vadd_f32(v17, v17);
  v19 = vadd_f32(v17, v18);
  v20 = vadd_f32(v18, v18);
  *(float *)&v7 = vmlas_n_f32(*(float *)&v7 * *(float *)v8.f64, v9, COERCE_FLOAT(*DC));
  *(float *)&v21 = *(float *)&v10 + *(float *)&v7;
  *(float *)v8.f64 = vmlas_n_f32(v13 * *(float *)v8.f64, *(float *)v11.i32, COERCE_FLOAT(*DC));
  *((float *)&v21 + 1) = v14 + *(float *)v8.f64;
  v97 = v21;
  *(double *)v22.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v21, v20)), v8, v21, v7, v16, (uint8x8_t)v12, v10, v11);
  v94 = v22;
  *(double *)v30.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v97, v19)), v23, v24, v25, v26, v27, v28, v29);
  v95 = v30;
  *(double *)v38.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v97, v18)), v31, v32, v33, v34, v35, v36, v37);
  v93 = v38;
  *(double *)v46.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v97, v17)), v39, v40, v41, v42, v43, v44, v45);
  v92 = v46;
  *(double *)v54.i64 = CI::BitmapSampler::read(this[1], v97, v47, v48, v49, v50, v51, v52, v53);
  v91 = v54;
  *(double *)v62.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v17, *(float32x2_t *)&v97)), v55, v56, v57, v58, v59, v60, v61);
  v89 = v62;
  *(double *)v70.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v18, *(float32x2_t *)&v97)), v63, v64, v65, v66, v67, v68, v69);
  v88 = v70;
  *(double *)v78.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v19, *(float32x2_t *)&v97)), v71, v72, v73, v74, v75, v76, v77);
  v90 = v78;
  *(double *)v86.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v20, *(float32x2_t *)&v97)), v79, v80, v81, v82, v83, v84, v85);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v91, (float32x4_t)vdupq_n_s32(0x3F2AA3BCu)), vmulq_f32(vaddq_f32(v92, v89), (float32x4_t)vdupq_n_s32(0x3E75B08Du))), vmulq_f32(vaddq_f32(v93, v88), (float32x4_t)vdupq_n_s32(0xBD9EC1EA))), vmulq_f32(vaddq_f32(v94, v86), (float32x4_t)vdupq_n_s32(0x3B8D1E61u))), 1.0 - v96), vaddq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v91, v89), (float32x4_t)vdupq_n_s32(0x3F086A95u)), vmulq_f32(vaddq_f32(v93, v90), (float32x4_t)vdupq_n_s32(0xBD32FB50))), vmulq_f32(vaddq_f32(v95, v86), (float32x4_t)vdupq_n_s32(0x3C31480Cu))), v96).u64[0];
  return result;
}

double cikernel::_ASGv75(uint64x2_t **this, SamplerObj *a2)
{
  _QWORD *DC;
  float v4;
  float v5;
  double v6;
  float64x2_t v7;
  float v8;
  uint8x8_t v9;
  double v10;
  int8x16_t v11;
  int8x16_t v12;
  float v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  double v19;
  float32x4_t v20;
  float64x2_t v21;
  double v22;
  double v23;
  int8x16_t v24;
  uint8x8_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  float64x2_t v29;
  double v30;
  double v31;
  int8x16_t v32;
  uint8x8_t v33;
  double v34;
  int8x16_t v35;
  float32x4_t v36;
  float64x2_t v37;
  double v38;
  double v39;
  int8x16_t v40;
  uint8x8_t v41;
  double v42;
  int8x16_t v43;
  float32x4_t v44;
  float64x2_t v45;
  double v46;
  double v47;
  int8x16_t v48;
  uint8x8_t v49;
  double v50;
  int8x16_t v51;
  float32x4_t v52;
  float64x2_t v53;
  double v54;
  double v55;
  int8x16_t v56;
  uint8x8_t v57;
  double v58;
  int8x16_t v59;
  float32x4_t v60;
  float64x2_t v61;
  double v62;
  double v63;
  int8x16_t v64;
  uint8x8_t v65;
  double v66;
  int8x16_t v67;
  float32x4_t v68;
  float64x2_t v69;
  double v70;
  double v71;
  int8x16_t v72;
  uint8x8_t v73;
  double v74;
  int8x16_t v75;
  float32x4_t v76;
  float64x2_t v77;
  double v78;
  double v79;
  int8x16_t v80;
  uint8x8_t v81;
  double v82;
  int8x16_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  double result;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  double v104;

  DC = (_QWORD *)CI::getDC((CI *)this);
  LODWORD(v4) = HIDWORD(*DC);
  v5 = floor((float)((float)(v4 / 3.0) - floorf(v4 / 3.0)) * 3.0);
  v6 = 0.5;
  v7.f64[0] = floor(floorf(v4) * 1.33333333 + 0.5) + 0.5;
  *(float *)v7.f64 = v7.f64[0];
  v8 = *((float *)this + 4);
  LODWORD(v6) = *((_DWORD *)this + 5);
  v9.i32[0] = *((_DWORD *)this + 6);
  LODWORD(v10) = *((_DWORD *)this + 7);
  *(float *)v11.i32 = *(float *)v9.i32 + (float)(*(float *)&v6 + (float)(v8 * 0.0));
  v12.i32[0] = *((_DWORD *)this + 8);
  v13 = *((float *)this + 9);
  *(float *)&v11.i32[1] = v13 + (float)(*(float *)v12.i32 + (float)(*(float *)&v10 * 0.0));
  v14.f32[0] = *(float *)v9.i32 + (float)((float)(*(float *)&v6 * 0.0) + (float)(v8 * 0.0));
  v14.f32[1] = v13 + (float)((float)(*(float *)v12.i32 * 0.0) + (float)(*(float *)&v10 * 0.0));
  v15 = vsub_f32(*(float32x2_t *)v11.i8, v14);
  v16 = vadd_f32(v15, v15);
  v17 = vadd_f32(v15, v16);
  v18 = vadd_f32(v16, v16);
  *(float *)&v6 = vmlas_n_f32(*(float *)&v6 * *(float *)v7.f64, v8, COERCE_FLOAT(*DC));
  *(float *)&v19 = *(float *)v9.i32 + *(float *)&v6;
  *(float *)v7.f64 = vmlas_n_f32(*(float *)v12.i32 * *(float *)v7.f64, *(float *)&v10, COERCE_FLOAT(*DC));
  *((float *)&v19 + 1) = v13 + *(float *)v7.f64;
  v104 = v19;
  *(double *)v20.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v19, v18)), v7, v19, v6, v11, v9, v10, v12);
  v103 = v20;
  *(double *)v28.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v104, v17)), v21, v22, v23, v24, v25, v26, v27);
  v102 = v28;
  *(double *)v36.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v104, v16)), v29, v30, v31, v32, v33, v34, v35);
  v101 = v36;
  *(double *)v44.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v104, v15)), v37, v38, v39, v40, v41, v42, v43);
  v100 = v44;
  *(double *)v52.i64 = CI::BitmapSampler::read(this[1], v104, v45, v46, v47, v48, v49, v50, v51);
  v99 = v52;
  *(double *)v60.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v15, *(float32x2_t *)&v104)), v53, v54, v55, v56, v57, v58, v59);
  v98 = v60;
  *(double *)v68.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v16, *(float32x2_t *)&v104)), v61, v62, v63, v64, v65, v66, v67);
  v97 = v68;
  *(double *)v76.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v17, *(float32x2_t *)&v104)), v69, v70, v71, v72, v73, v74, v75);
  v96 = v76;
  *(double *)v84.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v18, *(float32x2_t *)&v104)), v77, v78, v79, v80, v81, v82, v83);
  v85 = (float32x4_t)vdupq_n_s32(0x39C168EBu);
  v86 = (float32x4_t)vdupq_n_s32(0x3C151754u);
  v87 = (float32x4_t)vdupq_n_s32(0x3D0D1CCEu);
  v88 = vmulq_f32(v99, (float32x4_t)vdupq_n_s32(0x3F2998B2u));
  v89 = (float32x4_t)vdupq_n_s32(0x3EE24338u);
  v90 = (float32x4_t)vdupq_n_s32(0x3DA75B23u);
  v91 = (float32x4_t)vdupq_n_s32(0x3B46B2D7u);
  v92 = vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vmulq_f32(v102, v86), vmulq_f32(v103, v85)), vmulq_f32(v101, v87)), v88), vmulq_f32(v98, v89)), vmulq_f32(v97, v90)), vmulq_f32(v84, v91));
  v93 = vsubq_f32(vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vmulq_f32(v103, v91), vmulq_f32(v101, v90)), vmulq_f32(v100, v89)), v88), vmulq_f32(v97, v87)), vmulq_f32(v96, v86)), vmulq_f32(v84, v85));
  v86.f32[0] = fminf(v5, 1.0);
  v94 = vmlaq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v99, (float32x4_t)vdupq_n_s32(0x3F4010EAu)), vmulq_f32(vaddq_f32(v100, v98), (float32x4_t)vdupq_n_s32(0x3E41574Eu))), vmulq_f32(vaddq_f32(v101, v97), (float32x4_t)vdupq_n_s32(0xBD9BD797))), vmulq_f32(vaddq_f32(v102, v96), (float32x4_t)vdupq_n_s32(0x3C472ACCu))), 1.0 - v86.f32[0]), v92, v86.f32[0]);
  v92.f32[0] = fmaxf(v5 + -1.0, 0.0);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v94, 1.0 - v92.f32[0]), v93, v92.f32[0]).u64[0];
  return result;
}

double cikernel::_ASGh80(uint64x2_t **this, SamplerObj *a2)
{
  float32x2_t *DC;
  float v4;
  double v5;
  float64x2_t v6;
  float v7;
  double v8;
  int8x16_t v9;
  float32x2_t v10;
  float v11;
  float v12;
  int8x16_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  double v18;
  float32x4_t v19;
  float64x2_t v20;
  double v21;
  double v22;
  int8x16_t v23;
  uint8x8_t v24;
  double v25;
  int8x16_t v26;
  float32x4_t v27;
  float64x2_t v28;
  double v29;
  double v30;
  int8x16_t v31;
  uint8x8_t v32;
  double v33;
  int8x16_t v34;
  float32x4_t v35;
  float64x2_t v36;
  double v37;
  double v38;
  int8x16_t v39;
  uint8x8_t v40;
  double v41;
  int8x16_t v42;
  float32x4_t v43;
  float64x2_t v44;
  double v45;
  double v46;
  int8x16_t v47;
  uint8x8_t v48;
  double v49;
  int8x16_t v50;
  float32x4_t v51;
  float64x2_t v52;
  double v53;
  double v54;
  int8x16_t v55;
  uint8x8_t v56;
  double v57;
  int8x16_t v58;
  float32x4_t v59;
  float64x2_t v60;
  double v61;
  double v62;
  int8x16_t v63;
  uint8x8_t v64;
  double v65;
  int8x16_t v66;
  float32x4_t v67;
  float64x2_t v68;
  double v69;
  double v70;
  int8x16_t v71;
  uint8x8_t v72;
  double v73;
  int8x16_t v74;
  float32x4_t v75;
  float64x2_t v76;
  double v77;
  double v78;
  int8x16_t v79;
  uint8x8_t v80;
  double v81;
  int8x16_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  double result;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  double v104;

  DC = (float32x2_t *)CI::getDC((CI *)this);
  v4 = floor((float)((float)(0.25 * COERCE_FLOAT(*DC)) - floorf(0.25 * COERCE_FLOAT(*DC))) * 4.0);
  v5 = 1.25;
  v6.f64[0] = floor(floorf(COERCE_FLOAT(*DC)) * 1.25 + 0.499) + 0.5;
  *(float *)v6.f64 = v6.f64[0];
  v7 = *((float *)this + 4);
  LODWORD(v5) = *((_DWORD *)this + 5);
  LODWORD(v8) = *((_DWORD *)this + 6);
  v9.i32[0] = *((_DWORD *)this + 7);
  v10.f32[0] = *(float *)&v8 + (float)(v7 + (float)(*(float *)&v5 * 0.0));
  v11 = *((float *)this + 8);
  v12 = *((float *)this + 9);
  v10.f32[1] = v12 + (float)(*(float *)v9.i32 + (float)(v11 * 0.0));
  *(float *)v13.i32 = *(float *)&v8 + (float)((float)(*(float *)&v5 * 0.0) + (float)(v7 * 0.0));
  *(float *)&v13.i32[1] = v12 + (float)((float)(v11 * 0.0) + (float)(*(float *)v9.i32 * 0.0));
  v14 = vsub_f32(v10, *(float32x2_t *)v13.i8);
  v15 = vadd_f32(v14, v14);
  v16 = vadd_f32(v14, v15);
  v17 = vadd_f32(v15, v15);
  *(float *)&v5 = vmuls_lane_f32(*(float *)&v5, *DC, 1);
  *(float *)&v18 = *(float *)&v8 + (float)(*(float *)&v5 + (float)(*(float *)v6.f64 * v7));
  *((float *)&v18 + 1) = v12 + (float)(vmuls_lane_f32(v11, *DC, 1) + (float)(*(float *)v6.f64 * *(float *)v9.i32));
  v104 = v18;
  *(double *)v19.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v18, v17)), v6, v18, v5, v13, (uint8x8_t)v10, v8, v9);
  v103 = v19;
  *(double *)v27.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v104, v16)), v20, v21, v22, v23, v24, v25, v26);
  v102 = v27;
  *(double *)v35.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v104, v15)), v28, v29, v30, v31, v32, v33, v34);
  v101 = v35;
  *(double *)v43.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v104, v14)), v36, v37, v38, v39, v40, v41, v42);
  v100 = v43;
  *(double *)v51.i64 = CI::BitmapSampler::read(this[1], v104, v44, v45, v46, v47, v48, v49, v50);
  v99 = v51;
  *(double *)v59.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v14, *(float32x2_t *)&v104)), v52, v53, v54, v55, v56, v57, v58);
  v98 = v59;
  *(double *)v67.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v15, *(float32x2_t *)&v104)), v60, v61, v62, v63, v64, v65, v66);
  v97 = v67;
  *(double *)v75.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v104, v16)), v68, v69, v70, v71, v72, v73, v74);
  v96 = v75;
  *(double *)v83.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v104, v17)), v76, v77, v78, v79, v80, v81, v82);
  v84 = (float32x4_t)vdupq_n_s32(0x395DE0F1u);
  v85 = (float32x4_t)vdupq_n_s32(0x3BE3920Bu);
  v86 = (float32x4_t)vdupq_n_s32(0x3CE3D41Bu);
  v87 = vmulq_f32(v99, (float32x4_t)vdupq_n_s32(0x3F3D4D47u));
  v88 = (float32x4_t)vdupq_n_s32(0x3EB8D105u);
  v89 = (float32x4_t)vdupq_n_s32(0x3DBB4F61u);
  v90 = (float32x4_t)vdupq_n_s32(0x3C465F60u);
  v91 = vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vmulq_f32(v102, v85), vmulq_f32(v103, v84)), vmulq_f32(v101, v86)), v87), vmulq_f32(v98, v88)), vmulq_f32(v97, v89)), vmulq_f32(v96, v90));
  v92 = vsubq_f32(vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vmulq_f32(v102, v90), vmulq_f32(v101, v89)), vmulq_f32(v100, v88)), v87), vmulq_f32(v97, v86)), vmulq_f32(v96, v85)), vmulq_f32(v83, v84));
  v85.f32[0] = fminf(v4, 1.0);
  v93 = vmlaq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v99, (float32x4_t)vdupq_n_s32(0x3F4CDCC0u)), vmulq_f32(vaddq_f32(v100, v98), (float32x4_t)vdupq_n_s32(0x3E1CCAF7u))), vmulq_f32(vaddq_f32(v101, v97), (float32x4_t)vdupq_n_s32(0xBD84D643))), vmulq_f32(vaddq_f32(v102, v96), (float32x4_t)vdupq_n_s32(0x3C456854u))), vmulq_f32(vaddq_f32(v103, v83), (float32x4_t)vdupq_n_s32(0xB9DFA948))), 1.0 - v85.f32[0]), v91, v85.f32[0]);
  v91.f32[0] = fmaxf(v4 + -1.0, 0.0);
  v94 = vmlaq_n_f32(vmulq_n_f32(v93, 1.0 - v91.f32[0]), vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v99, v98), (float32x4_t)vdupq_n_s32(0x3F138E4Au)), vmulq_f32(vaddq_f32(v100, v97), (float32x4_t)vdupq_n_s32(0xBDA10EBE))), vmulq_f32(vaddq_f32(v102, v83), (float32x4_t)vdupq_n_s32(0x3B14DF20u))), vmulq_f32(v103, (float32x4_t)vdupq_n_s32(0xB82907CC))), v91.f32[0]);
  v91.f32[0] = fmaxf(v4 + -2.0, 0.0);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v94, 1.0 - v91.f32[0]), v92, v91.f32[0]).u64[0];
  return result;
}

double cikernel::_ASGv80(uint64x2_t **this, SamplerObj *a2)
{
  float32x2_t *DC;
  float v4;
  float v5;
  double v6;
  float64x2_t v7;
  float v8;
  uint8x8_t v9;
  double v10;
  int8x16_t v11;
  int8x16_t v12;
  float v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  double v19;
  float32x4_t v20;
  float64x2_t v21;
  double v22;
  double v23;
  int8x16_t v24;
  uint8x8_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  float64x2_t v29;
  double v30;
  double v31;
  int8x16_t v32;
  uint8x8_t v33;
  double v34;
  int8x16_t v35;
  float32x4_t v36;
  float64x2_t v37;
  double v38;
  double v39;
  int8x16_t v40;
  uint8x8_t v41;
  double v42;
  int8x16_t v43;
  float32x4_t v44;
  float64x2_t v45;
  double v46;
  double v47;
  int8x16_t v48;
  uint8x8_t v49;
  double v50;
  int8x16_t v51;
  float32x4_t v52;
  float64x2_t v53;
  double v54;
  double v55;
  int8x16_t v56;
  uint8x8_t v57;
  double v58;
  int8x16_t v59;
  float32x4_t v60;
  float64x2_t v61;
  double v62;
  double v63;
  int8x16_t v64;
  uint8x8_t v65;
  double v66;
  int8x16_t v67;
  float32x4_t v68;
  float64x2_t v69;
  double v70;
  double v71;
  int8x16_t v72;
  uint8x8_t v73;
  double v74;
  int8x16_t v75;
  float32x4_t v76;
  float64x2_t v77;
  double v78;
  double v79;
  int8x16_t v80;
  uint8x8_t v81;
  double v82;
  int8x16_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  double result;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  double v105;

  DC = (float32x2_t *)CI::getDC((CI *)this);
  v4 = vmuls_lane_f32(0.25, *DC, 1);
  v5 = floor((float)(v4 - floorf(v4)) * 4.0);
  v6 = 1.25;
  v7.f64[0] = floor(floorf(COERCE_FLOAT(HIDWORD(*(unint64_t *)DC))) * 1.25 + 0.499) + 0.5;
  *(float *)v7.f64 = v7.f64[0];
  v8 = *((float *)this + 4);
  LODWORD(v6) = *((_DWORD *)this + 5);
  v9.i32[0] = *((_DWORD *)this + 6);
  LODWORD(v10) = *((_DWORD *)this + 7);
  *(float *)v11.i32 = *(float *)v9.i32 + (float)(*(float *)&v6 + (float)(v8 * 0.0));
  v12.i32[0] = *((_DWORD *)this + 8);
  v13 = *((float *)this + 9);
  *(float *)&v11.i32[1] = v13 + (float)(*(float *)v12.i32 + (float)(*(float *)&v10 * 0.0));
  v14.f32[0] = *(float *)v9.i32 + (float)((float)(*(float *)&v6 * 0.0) + (float)(v8 * 0.0));
  v14.f32[1] = v13 + (float)((float)(*(float *)v12.i32 * 0.0) + (float)(*(float *)&v10 * 0.0));
  v15 = vsub_f32(*(float32x2_t *)v11.i8, v14);
  v16 = vadd_f32(v15, v15);
  v17 = vadd_f32(v15, v16);
  v18 = vadd_f32(v16, v16);
  *(float *)&v6 = vmlas_n_f32(*(float *)&v6 * *(float *)v7.f64, v8, COERCE_FLOAT(*DC));
  *(float *)&v19 = *(float *)v9.i32 + *(float *)&v6;
  *(float *)v7.f64 = vmlas_n_f32(*(float *)v12.i32 * *(float *)v7.f64, *(float *)&v10, COERCE_FLOAT(*DC));
  *((float *)&v19 + 1) = v13 + *(float *)v7.f64;
  v105 = v19;
  *(double *)v20.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v19, v18)), v7, v19, v6, v11, v9, v10, v12);
  v104 = v20;
  *(double *)v28.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v105, v17)), v21, v22, v23, v24, v25, v26, v27);
  v103 = v28;
  *(double *)v36.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v105, v16)), v29, v30, v31, v32, v33, v34, v35);
  v102 = v36;
  *(double *)v44.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v105, v15)), v37, v38, v39, v40, v41, v42, v43);
  v101 = v44;
  *(double *)v52.i64 = CI::BitmapSampler::read(this[1], v105, v45, v46, v47, v48, v49, v50, v51);
  v100 = v52;
  *(double *)v60.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v15, *(float32x2_t *)&v105)), v53, v54, v55, v56, v57, v58, v59);
  v99 = v60;
  *(double *)v68.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v16, *(float32x2_t *)&v105)), v61, v62, v63, v64, v65, v66, v67);
  v98 = v68;
  *(double *)v76.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v17, *(float32x2_t *)&v105)), v69, v70, v71, v72, v73, v74, v75);
  v97 = v76;
  *(double *)v84.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v18, *(float32x2_t *)&v105)), v77, v78, v79, v80, v81, v82, v83);
  v85 = (float32x4_t)vdupq_n_s32(0x395DE0F1u);
  v86 = (float32x4_t)vdupq_n_s32(0x3BE3920Bu);
  v87 = (float32x4_t)vdupq_n_s32(0x3CE3D41Bu);
  v88 = vmulq_f32(v100, (float32x4_t)vdupq_n_s32(0x3F3D4D47u));
  v89 = (float32x4_t)vdupq_n_s32(0x3EB8D105u);
  v90 = (float32x4_t)vdupq_n_s32(0x3DBB4F61u);
  v91 = (float32x4_t)vdupq_n_s32(0x3C465F60u);
  v92 = vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vmulq_f32(v103, v86), vmulq_f32(v104, v85)), vmulq_f32(v102, v87)), v88), vmulq_f32(v99, v89)), vmulq_f32(v98, v90)), vmulq_f32(v97, v91));
  v93 = vsubq_f32(vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vmulq_f32(v103, v91), vmulq_f32(v102, v90)), vmulq_f32(v101, v89)), v88), vmulq_f32(v98, v87)), vmulq_f32(v97, v86)), vmulq_f32(v84, v85));
  v86.f32[0] = fminf(v5, 1.0);
  v94 = vmlaq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v100, (float32x4_t)vdupq_n_s32(0x3F4CDCC0u)), vmulq_f32(vaddq_f32(v101, v99), (float32x4_t)vdupq_n_s32(0x3E1CCAF7u))), vmulq_f32(vaddq_f32(v102, v98), (float32x4_t)vdupq_n_s32(0xBD84D643))), vmulq_f32(vaddq_f32(v103, v97), (float32x4_t)vdupq_n_s32(0x3C456854u))), vmulq_f32(vaddq_f32(v104, v84), (float32x4_t)vdupq_n_s32(0xB9DFA948))), 1.0 - v86.f32[0]), v92, v86.f32[0]);
  v92.f32[0] = fmaxf(v5 + -1.0, 0.0);
  v95 = vmlaq_n_f32(vmulq_n_f32(v94, 1.0 - v92.f32[0]), vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v100, v99), (float32x4_t)vdupq_n_s32(0x3F138E4Au)), vmulq_f32(vaddq_f32(v101, v98), (float32x4_t)vdupq_n_s32(0xBDA10EBE))), vmulq_f32(vaddq_f32(v103, v84), (float32x4_t)vdupq_n_s32(0x3B14DF20u))), vmulq_f32(v104, (float32x4_t)vdupq_n_s32(0xB82907CC))), v92.f32[0]);
  v92.f32[0] = fmaxf(v5 + -2.0, 0.0);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v95, 1.0 - v92.f32[0]), v93, v92.f32[0]).u64[0];
  return result;
}

double cikernel::_ASGh60(uint64x2_t **this, SamplerObj *a2)
{
  float32x2_t *DC;
  float v4;
  float64x2_t v5;
  float v6;
  float v7;
  double v8;
  int8x16_t v9;
  float32x2_t v10;
  float v11;
  float v12;
  int8x16_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  double v18;
  double v19;
  float32x4_t v20;
  float64x2_t v21;
  double v22;
  double v23;
  int8x16_t v24;
  uint8x8_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  float64x2_t v29;
  double v30;
  double v31;
  int8x16_t v32;
  uint8x8_t v33;
  double v34;
  int8x16_t v35;
  float32x4_t v36;
  float64x2_t v37;
  double v38;
  double v39;
  int8x16_t v40;
  uint8x8_t v41;
  double v42;
  int8x16_t v43;
  float32x4_t v44;
  float64x2_t v45;
  double v46;
  double v47;
  int8x16_t v48;
  uint8x8_t v49;
  double v50;
  int8x16_t v51;
  float32x4_t v52;
  float64x2_t v53;
  double v54;
  double v55;
  int8x16_t v56;
  uint8x8_t v57;
  double v58;
  int8x16_t v59;
  float32x4_t v60;
  float64x2_t v61;
  double v62;
  double v63;
  int8x16_t v64;
  uint8x8_t v65;
  double v66;
  int8x16_t v67;
  float32x4_t v68;
  float64x2_t v69;
  double v70;
  double v71;
  int8x16_t v72;
  uint8x8_t v73;
  double v74;
  int8x16_t v75;
  float32x4_t v76;
  float64x2_t v77;
  double v78;
  double v79;
  int8x16_t v80;
  uint8x8_t v81;
  double v82;
  int8x16_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  double result;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  double v104;

  DC = (float32x2_t *)CI::getDC((CI *)this);
  v4 = floor((float)((float)(COERCE_FLOAT(*DC) / 3.0) - floorf(COERCE_FLOAT(*DC) / 3.0)) * 3.0);
  v5.f64[0] = floor(floorf(COERCE_FLOAT(*DC)) / 0.6 + 0.499) + 0.5;
  *(float *)v5.f64 = v5.f64[0];
  v6 = *((float *)this + 4);
  v7 = *((float *)this + 5);
  LODWORD(v8) = *((_DWORD *)this + 6);
  v9.i32[0] = *((_DWORD *)this + 7);
  v10.f32[0] = *(float *)&v8 + (float)(v6 + (float)(v7 * 0.0));
  v11 = *((float *)this + 8);
  v12 = *((float *)this + 9);
  v10.f32[1] = v12 + (float)(*(float *)v9.i32 + (float)(v11 * 0.0));
  *(float *)v13.i32 = *(float *)&v8 + (float)((float)(v7 * 0.0) + (float)(v6 * 0.0));
  *(float *)&v13.i32[1] = v12 + (float)((float)(v11 * 0.0) + (float)(*(float *)v9.i32 * 0.0));
  v14 = vsub_f32(v10, *(float32x2_t *)v13.i8);
  v15 = vadd_f32(v14, v14);
  v16 = vadd_f32(v14, v15);
  v17 = vadd_f32(v15, v15);
  *(float *)&v18 = vmuls_lane_f32(v7, *DC, 1);
  *(float *)&v19 = *(float *)&v8 + (float)(*(float *)&v18 + (float)(*(float *)v5.f64 * v6));
  *((float *)&v19 + 1) = v12 + (float)(vmuls_lane_f32(v11, *DC, 1) + (float)(*(float *)v5.f64 * *(float *)v9.i32));
  v104 = v19;
  *(double *)v20.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v19, v17)), v5, v19, v18, v13, (uint8x8_t)v10, v8, v9);
  v103 = v20;
  *(double *)v28.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v104, v16)), v21, v22, v23, v24, v25, v26, v27);
  v102 = v28;
  *(double *)v36.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v104, v15)), v29, v30, v31, v32, v33, v34, v35);
  v101 = v36;
  *(double *)v44.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v104, v14)), v37, v38, v39, v40, v41, v42, v43);
  v100 = v44;
  *(double *)v52.i64 = CI::BitmapSampler::read(this[1], v104, v45, v46, v47, v48, v49, v50, v51);
  v99 = v52;
  *(double *)v60.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v14, *(float32x2_t *)&v104)), v53, v54, v55, v56, v57, v58, v59);
  v98 = v60;
  *(double *)v68.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v15, *(float32x2_t *)&v104)), v61, v62, v63, v64, v65, v66, v67);
  v97 = v68;
  *(double *)v76.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v16, *(float32x2_t *)&v104)), v69, v70, v71, v72, v73, v74, v75);
  v96 = v76;
  *(double *)v84.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v17, *(float32x2_t *)&v104)), v77, v78, v79, v80, v81, v82, v83);
  v85 = (float32x4_t)vdupq_n_s32(0x3C14C7A3u);
  v86 = (float32x4_t)vdupq_n_s32(0x3D474371u);
  v87 = (float32x4_t)vdupq_n_s32(0x3EDD553Fu);
  v88 = vmulq_f32(v99, (float32x4_t)vdupq_n_s32(0x3F0DF9F0u));
  v89 = (float32x4_t)vdupq_n_s32(0x3DEB32CFu);
  v90 = (float32x4_t)vdupq_n_s32(0x3D8C7B7Cu);
  v91 = (float32x4_t)vdupq_n_s32(0x3BAAAD28u);
  v92 = vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vmulq_f32(v103, v85), vmulq_f32(v102, v86)), vmulq_f32(v100, v87)), v88), vmulq_f32(v98, v89)), vmulq_f32(v97, v90)), vmulq_f32(v84, v91));
  v93 = vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vmulq_f32(v103, v91), vmulq_f32(v101, v90)), vmulq_f32(v100, v89)), v88), vmulq_f32(v98, v87)), vmulq_f32(v96, v86)), vmulq_f32(v84, v85));
  v86.f32[0] = fminf(v4, 1.0);
  v94 = vmlaq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v99, (float32x4_t)vdupq_n_s32(0x3F19A4F0u)), vmulq_f32(vaddq_f32(v100, v98), (float32x4_t)vdupq_n_s32(0x3E8A9AC3u))), vmulq_f32(vaddq_f32(v101, v97), (float32x4_t)vdupq_n_s32(0xBD71927F))), vmulq_f32(vaddq_f32(v102, v96), (float32x4_t)vdupq_n_s32(0xBCAADC82))), vmulq_f32(vaddq_f32(v103, v84), (float32x4_t)vdupq_n_s32(0x3C140D7Eu))), 1.0 - v86.f32[0]), v92, v86.f32[0]);
  v92.f32[0] = fmaxf(v4 + -1.0, 0.0);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v94, 1.0 - v92.f32[0]), v93, v92.f32[0]).u64[0];
  return result;
}

double cikernel::_ASGv60(uint64x2_t **this, SamplerObj *a2)
{
  _QWORD *DC;
  float v4;
  double v5;
  float v6;
  float64x2_t v7;
  float v8;
  uint8x8_t v9;
  double v10;
  int8x16_t v11;
  int8x16_t v12;
  float v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  double v19;
  float32x4_t v20;
  float64x2_t v21;
  double v22;
  double v23;
  int8x16_t v24;
  uint8x8_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  float64x2_t v29;
  double v30;
  double v31;
  int8x16_t v32;
  uint8x8_t v33;
  double v34;
  int8x16_t v35;
  float32x4_t v36;
  float64x2_t v37;
  double v38;
  double v39;
  int8x16_t v40;
  uint8x8_t v41;
  double v42;
  int8x16_t v43;
  float32x4_t v44;
  float64x2_t v45;
  double v46;
  double v47;
  int8x16_t v48;
  uint8x8_t v49;
  double v50;
  int8x16_t v51;
  float32x4_t v52;
  float64x2_t v53;
  double v54;
  double v55;
  int8x16_t v56;
  uint8x8_t v57;
  double v58;
  int8x16_t v59;
  float32x4_t v60;
  float64x2_t v61;
  double v62;
  double v63;
  int8x16_t v64;
  uint8x8_t v65;
  double v66;
  int8x16_t v67;
  float32x4_t v68;
  float64x2_t v69;
  double v70;
  double v71;
  int8x16_t v72;
  uint8x8_t v73;
  double v74;
  int8x16_t v75;
  float32x4_t v76;
  float64x2_t v77;
  double v78;
  double v79;
  int8x16_t v80;
  uint8x8_t v81;
  double v82;
  int8x16_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  double result;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  double v104;

  DC = (_QWORD *)CI::getDC((CI *)this);
  LODWORD(v4) = HIDWORD(*DC);
  v5 = 3.0;
  v6 = floor((float)((float)(v4 / 3.0) - floorf(v4 / 3.0)) * 3.0);
  v7.f64[0] = floor(floorf(v4) / 0.6 + 0.499) + 0.5;
  *(float *)v7.f64 = v7.f64[0];
  v8 = *((float *)this + 4);
  LODWORD(v5) = *((_DWORD *)this + 5);
  v9.i32[0] = *((_DWORD *)this + 6);
  LODWORD(v10) = *((_DWORD *)this + 7);
  *(float *)v11.i32 = *(float *)v9.i32 + (float)(*(float *)&v5 + (float)(v8 * 0.0));
  v12.i32[0] = *((_DWORD *)this + 8);
  v13 = *((float *)this + 9);
  *(float *)&v11.i32[1] = v13 + (float)(*(float *)v12.i32 + (float)(*(float *)&v10 * 0.0));
  v14.f32[0] = *(float *)v9.i32 + (float)((float)(*(float *)&v5 * 0.0) + (float)(v8 * 0.0));
  v14.f32[1] = v13 + (float)((float)(*(float *)v12.i32 * 0.0) + (float)(*(float *)&v10 * 0.0));
  v15 = vsub_f32(*(float32x2_t *)v11.i8, v14);
  v16 = vadd_f32(v15, v15);
  v17 = vadd_f32(v15, v16);
  v18 = vadd_f32(v16, v16);
  *(float *)&v5 = vmlas_n_f32(*(float *)&v5 * *(float *)v7.f64, v8, COERCE_FLOAT(*DC));
  *(float *)&v19 = *(float *)v9.i32 + *(float *)&v5;
  *(float *)v7.f64 = vmlas_n_f32(*(float *)v12.i32 * *(float *)v7.f64, *(float *)&v10, COERCE_FLOAT(*DC));
  *((float *)&v19 + 1) = v13 + *(float *)v7.f64;
  v104 = v19;
  *(double *)v20.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v19, v18)), v7, v19, v5, v11, v9, v10, v12);
  v103 = v20;
  *(double *)v28.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v104, v17)), v21, v22, v23, v24, v25, v26, v27);
  v102 = v28;
  *(double *)v36.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v104, v16)), v29, v30, v31, v32, v33, v34, v35);
  v101 = v36;
  *(double *)v44.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v104, v15)), v37, v38, v39, v40, v41, v42, v43);
  v100 = v44;
  *(double *)v52.i64 = CI::BitmapSampler::read(this[1], v104, v45, v46, v47, v48, v49, v50, v51);
  v99 = v52;
  *(double *)v60.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v15, *(float32x2_t *)&v104)), v53, v54, v55, v56, v57, v58, v59);
  v98 = v60;
  *(double *)v68.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v16, *(float32x2_t *)&v104)), v61, v62, v63, v64, v65, v66, v67);
  v97 = v68;
  *(double *)v76.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v17, *(float32x2_t *)&v104)), v69, v70, v71, v72, v73, v74, v75);
  v96 = v76;
  *(double *)v84.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v18, *(float32x2_t *)&v104)), v77, v78, v79, v80, v81, v82, v83);
  v85 = (float32x4_t)vdupq_n_s32(0x3C14C7A3u);
  v86 = (float32x4_t)vdupq_n_s32(0x3D474371u);
  v87 = (float32x4_t)vdupq_n_s32(0x3EDD553Fu);
  v88 = vmulq_f32(v99, (float32x4_t)vdupq_n_s32(0x3F0DF9F0u));
  v89 = (float32x4_t)vdupq_n_s32(0x3DEB32CFu);
  v90 = (float32x4_t)vdupq_n_s32(0x3D8C7B7Cu);
  v91 = (float32x4_t)vdupq_n_s32(0x3BAAAD28u);
  v92 = vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vmulq_f32(v103, v85), vmulq_f32(v102, v86)), vmulq_f32(v100, v87)), v88), vmulq_f32(v98, v89)), vmulq_f32(v97, v90)), vmulq_f32(v84, v91));
  v93 = vaddq_f32(vsubq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vsubq_f32(vmulq_f32(v103, v91), vmulq_f32(v101, v90)), vmulq_f32(v100, v89)), v88), vmulq_f32(v98, v87)), vmulq_f32(v96, v86)), vmulq_f32(v84, v85));
  v86.f32[0] = fminf(v6, 1.0);
  v94 = vmlaq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(v99, (float32x4_t)vdupq_n_s32(0x3F19A4F0u)), vmulq_f32(vaddq_f32(v100, v98), (float32x4_t)vdupq_n_s32(0x3E8A9AC3u))), vmulq_f32(vaddq_f32(v101, v97), (float32x4_t)vdupq_n_s32(0xBD71927F))), vmulq_f32(vaddq_f32(v102, v96), (float32x4_t)vdupq_n_s32(0xBCAADC82))), vmulq_f32(vaddq_f32(v103, v84), (float32x4_t)vdupq_n_s32(0x3C140D7Eu))), 1.0 - v86.f32[0]), v92, v86.f32[0]);
  v92.f32[0] = fmaxf(v6 + -1.0, 0.0);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v94, 1.0 - v92.f32[0]), v93, v92.f32[0]).u64[0];
  return result;
}

void ___ZL5downHP7CIImagedd_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5;
  float v6;

  v5 = *(double *)(a1 + 32);
  v6 = *(double *)(a1 + 40);
  roiDownK(*(CGRect *)&a2, v5, v6, 1);
}

void roiDownK(CGRect a1, float a2, float a3, int a4)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  double v8;
  double v9;
  double v10;
  double v11;
  CGAffineTransform v12;
  CGRect v13;
  CGRect v14;

  height = a1.size.height;
  width = a1.size.width;
  y = a1.origin.y;
  x = a1.origin.x;
  v8 = 1.0;
  if (a4)
    v9 = 1.0 / a3;
  else
    v9 = 1.0;
  if (a4)
  {
    v10 = (float)-a2;
  }
  else
  {
    v8 = 1.0 / a3;
    v10 = 0.0;
  }
  if (a4)
    v11 = 0.0;
  else
    v11 = (float)-a2;
  CGAffineTransformMakeScale(&v12, v9, v8);
  v13.origin.x = x;
  v13.origin.y = y;
  v13.size.width = width;
  v13.size.height = height;
  v14 = CGRectApplyAffineTransform(v13, &v12);
  CGRectInset(v14, v10, v11);
}

double cikernel::_asgDownH(uint64_t a1, int8x16_t a2, float a3)
{
  float32x2_t *DC;
  double v8;
  int8x16_t v9;
  float64x2_t v10;
  float32x2_t v15;
  int8x16_t v17;
  int8x16_t v18;
  float32x4_t v19;
  double v20;
  double v21;
  float64x2_t v22;
  uint8x8_t v23;
  double v24;
  int8x16_t v25;
  float32x4_t v26;
  double v27;
  double v28;
  float64x2_t v29;
  uint8x8_t v30;
  double v31;
  int8x16_t v32;
  float32x4_t v33;
  double v34;
  double v35;
  float64x2_t v36;
  uint8x8_t v37;
  double v38;
  int8x16_t v39;
  float32x4_t v40;
  double v41;
  double v42;
  float64x2_t v43;
  uint8x8_t v44;
  double v45;
  int8x16_t v46;
  float32x4_t v47;
  double v48;
  double v49;
  float64x2_t v50;
  double v51;
  int8x16_t v52;
  float32x4_t v53;
  double v54;
  double v55;
  float64x2_t v56;
  uint8x8_t v57;
  double v58;
  int8x16_t v59;
  float32x4_t v60;
  double v61;
  double v62;
  float64x2_t v63;
  uint8x8_t v64;
  double v65;
  int8x16_t v66;
  float32x4_t v67;
  double v68;
  double v69;
  float64x2_t v70;
  uint8x8_t v71;
  double v72;
  int8x16_t v73;
  float32x4_t v74;
  double v75;
  double v76;
  float64x2_t v77;
  uint8x8_t v78;
  double v79;
  int8x16_t v80;
  float32x4_t v81;
  double v82;
  double v83;
  float64x2_t v84;
  uint8x8_t v85;
  double v86;
  int8x16_t v87;
  float32x4_t v88;
  double v89;
  double v90;
  float64x2_t v91;
  uint8x8_t v92;
  double v93;
  int8x16_t v94;
  float32x4_t v95;
  float v96;
  float32x2_t v97;
  float v98;
  double v99;
  float v100;
  float v101;
  long double v102;
  float v103;
  long double v104;
  float v105;
  double v106;
  float v107;
  float v108;
  long double v109;
  float v110;
  long double v111;
  float v112;
  double v113;
  float v114;
  float v115;
  long double v116;
  float v117;
  long double v118;
  float v119;
  double v120;
  float v121;
  float v122;
  long double v123;
  float v124;
  long double v125;
  float v126;
  double v127;
  float v128;
  float v129;
  long double v130;
  float v131;
  long double v132;
  float v133;
  double v134;
  float v135;
  float v136;
  long double v137;
  float v138;
  long double v139;
  float v140;
  float v141;
  float v142;
  double v143;
  float v144;
  float v145;
  long double v146;
  float v147;
  long double v148;
  float v149;
  double v150;
  float v151;
  float v152;
  long double v153;
  float v154;
  long double v155;
  float v156;
  float v157;
  float v158;
  double v159;
  float v160;
  float v161;
  long double v162;
  float v163;
  long double v164;
  float v165;
  double v166;
  float v167;
  float v168;
  long double v169;
  float v170;
  long double v171;
  float v172;
  float v173;
  float v174;
  double v175;
  float v176;
  float v177;
  long double v178;
  float v179;
  long double v180;
  long double v181;
  float v182;
  float v183;
  long double v184;
  float v185;
  double result;
  float32x4_t v187;
  float32x4_t v188;
  float32x4_t v189;
  float32x4_t v190;
  float32x4_t v191;
  float32x4_t v192;
  float32x4_t v193;
  float32x4_t v194;
  float32x4_t v195;
  float32x4_t v196;
  float32x4_t v197;
  float32x4_t v198;
  float v199;
  float32x2_t v200;
  float v201;
  int8x16_t v202;
  float v203;
  int8x16_t v204;
  float v205;
  int8x16_t v206;
  float v207;
  int8x16_t v208;
  float v209;
  uint8x8_t v210;
  int8x16_t v211;
  float v212;
  int8x16_t v213;
  float v214;
  int8x16_t v215;
  int8x16_t v216;
  float v217;
  float v218;
  float v219;
  int8x16_t v220;
  float v221;
  float v222;
  int8x16_t v223;
  int8x16_t v224;
  float v226;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  _Q2 = a2;
  *(float32x2_t *)_Q3.i8 = vmul_f32(*(float32x2_t *)a2.i8, *DC);
  v224 = _Q3;
  v8 = 0.5;
  *(float *)&v8 = floor(*(float *)_Q3.i32 + -0.5) + 0.5;
  v210 = *(uint8x8_t *)&v8;
  v9 = _Q3;
  v9.i32[0] = LODWORD(v8);
  v10 = (float64x2_t)vextq_s8(_Q2, _Q2, 8uLL);
  __asm { FMOV            V2.2S, #5.0 }
  *(float32x2_t *)_Q2.i8 = vmul_f32(*(float32x2_t *)&v10.f64[0], *(float32x2_t *)_Q2.i8);
  v15 = vsub_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)_Q2.i8);
  __asm { FMOV            V3.2S, #4.0 }
  *(float32x2_t *)_Q3.i8 = vmul_f32(*(float32x2_t *)&v10.f64[0], *(float32x2_t *)_Q3.i8);
  *(float32x2_t *)_Q4.i8 = vsub_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)_Q3.i8);
  v202 = _Q4;
  __asm { FMOV            V4.2S, #3.0 }
  *(float32x2_t *)_Q4.i8 = vmul_f32(*(float32x2_t *)&v10.f64[0], *(float32x2_t *)_Q4.i8);
  *(float32x2_t *)v17.i8 = vsub_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)_Q4.i8);
  v204 = v17;
  *(float32x2_t *)v17.i8 = vadd_f32(*(float32x2_t *)&v10.f64[0], *(float32x2_t *)&v10.f64[0]);
  *(float32x2_t *)v18.i8 = vsub_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)v17.i8);
  v206 = v18;
  *(float32x2_t *)v18.i8 = vsub_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)&v10.f64[0]);
  v208 = v18;
  *(float32x2_t *)v18.i8 = vadd_f32(*(float32x2_t *)&v10.f64[0], *(float32x2_t *)v9.i8);
  *(float32x2_t *)v17.i8 = vadd_f32(*(float32x2_t *)v17.i8, *(float32x2_t *)v9.i8);
  v211 = v18;
  v213 = v17;
  *(float32x2_t *)_Q4.i8 = vadd_f32(*(float32x2_t *)_Q4.i8, *(float32x2_t *)v9.i8);
  *(float32x2_t *)_Q3.i8 = vadd_f32(*(float32x2_t *)_Q3.i8, *(float32x2_t *)v9.i8);
  v215 = _Q4;
  v216 = _Q3;
  *(float32x2_t *)_Q2.i8 = vadd_f32(*(float32x2_t *)_Q2.i8, *(float32x2_t *)v9.i8);
  v220 = _Q2;
  __asm { FMOV            V2.2S, #6.0 }
  *(float32x2_t *)&v10.f64[0] = vmul_f32(*(float32x2_t *)&v10.f64[0], *(float32x2_t *)_Q2.i8);
  *(float32x2_t *)v9.i8 = vadd_f32(*(float32x2_t *)&v10.f64[0], *(float32x2_t *)v9.i8);
  v223 = v9;
  v200 = v15;
  _Q2.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v9.i32 = *(float *)(a1 + 24)
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v15, 1), *(float *)(a1 + 16), v15.f32[0]);
  _Q3.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.f64 = *(float *)_Q3.i32
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v15, 1), *(float *)_Q2.i32, v15.f32[0]);
  v9.i32[1] = LODWORD(v10.f64[0]);
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v9.i64, v10, *(double *)_Q2.i64, *(double *)_Q3.i64, _Q4, *(uint8x8_t *)v17.i8, *(double *)&v15, v18);
  v198 = v19;
  LODWORD(v20) = *(_DWORD *)(a1 + 28);
  v19.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v202.i8, 1), *(float *)(a1 + 16), *(float *)v202.i32);
  LODWORD(v21) = *(_DWORD *)(a1 + 36);
  *(float *)v22.f64 = *(float *)&v21
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v202.i8, 1), *(float *)&v20, *(float *)v202.i32);
  v19.i32[1] = LODWORD(v22.f64[0]);
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v22, v20, v21, v202, v23, v24, v25);
  v197 = v26;
  LODWORD(v27) = *(_DWORD *)(a1 + 28);
  v26.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v204.i8, 1), *(float *)(a1 + 16), *(float *)v204.i32);
  LODWORD(v28) = *(_DWORD *)(a1 + 36);
  *(float *)v29.f64 = *(float *)&v28
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v204.i8, 1), *(float *)&v27, *(float *)v204.i32);
  v26.i32[1] = LODWORD(v29.f64[0]);
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, v29, v27, v28, v204, v30, v31, v32);
  v196 = v33;
  LODWORD(v34) = *(_DWORD *)(a1 + 28);
  v33.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v206.i8, 1), *(float *)(a1 + 16), *(float *)v206.i32);
  LODWORD(v35) = *(_DWORD *)(a1 + 36);
  *(float *)v36.f64 = *(float *)&v35
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v206.i8, 1), *(float *)&v34, *(float *)v206.i32);
  v33.i32[1] = LODWORD(v36.f64[0]);
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v33.i64, v36, v34, v35, v206, v37, v38, v39);
  v195 = v40;
  LODWORD(v41) = *(_DWORD *)(a1 + 28);
  v40.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v208.i8, 1), *(float *)(a1 + 16), *(float *)v208.i32);
  LODWORD(v42) = *(_DWORD *)(a1 + 36);
  *(float *)v43.f64 = *(float *)&v42
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v208.i8, 1), *(float *)&v41, *(float *)v208.i32);
  v40.i32[1] = LODWORD(v43.f64[0]);
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v40.i64, v43, v41, v42, v208, v44, v45, v46);
  v194 = v47;
  LODWORD(v48) = *(_DWORD *)(a1 + 28);
  v47.f32[0] = *(float *)(a1 + 24)
             + (float)(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v224.i8, 1)
                     + (float)(*(float *)v210.i32 * *(float *)(a1 + 16)));
  LODWORD(v49) = *(_DWORD *)(a1 + 36);
  *(float *)v50.f64 = *(float *)&v49
                    + (float)(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v224.i8, 1)
                            + (float)(*(float *)v210.i32 * *(float *)&v48));
  v47.i32[1] = LODWORD(v50.f64[0]);
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v47.i64, v50, v48, v49, v224, v210, v51, v52);
  v193 = v53;
  LODWORD(v54) = *(_DWORD *)(a1 + 28);
  v53.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v211.i8, 1), *(float *)(a1 + 16), *(float *)v211.i32);
  LODWORD(v55) = *(_DWORD *)(a1 + 36);
  *(float *)v56.f64 = *(float *)&v55
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v211.i8, 1), *(float *)&v54, *(float *)v211.i32);
  v53.i32[1] = LODWORD(v56.f64[0]);
  *(double *)v60.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v53.i64, v56, v54, v55, v211, v57, v58, v59);
  v192 = v60;
  LODWORD(v61) = *(_DWORD *)(a1 + 28);
  v60.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v213.i8, 1), *(float *)(a1 + 16), *(float *)v213.i32);
  LODWORD(v62) = *(_DWORD *)(a1 + 36);
  *(float *)v63.f64 = *(float *)&v62
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v213.i8, 1), *(float *)&v61, *(float *)v213.i32);
  v60.i32[1] = LODWORD(v63.f64[0]);
  *(double *)v67.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v60.i64, v63, v61, v62, v213, v64, v65, v66);
  v191 = v67;
  LODWORD(v68) = *(_DWORD *)(a1 + 28);
  v67.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v215.i8, 1), *(float *)(a1 + 16), *(float *)v215.i32);
  LODWORD(v69) = *(_DWORD *)(a1 + 36);
  *(float *)v70.f64 = *(float *)&v69
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v215.i8, 1), *(float *)&v68, *(float *)v215.i32);
  v67.i32[1] = LODWORD(v70.f64[0]);
  *(double *)v74.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v67.i64, v70, v68, v69, v215, v71, v72, v73);
  v190 = v74;
  LODWORD(v75) = *(_DWORD *)(a1 + 28);
  v74.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v216.i8, 1), *(float *)(a1 + 16), *(float *)v216.i32);
  LODWORD(v76) = *(_DWORD *)(a1 + 36);
  *(float *)v77.f64 = *(float *)&v76
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v216.i8, 1), *(float *)&v75, *(float *)v216.i32);
  v74.i32[1] = LODWORD(v77.f64[0]);
  *(double *)v81.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v74.i64, v77, v75, v76, v216, v78, v79, v80);
  v189 = v81;
  LODWORD(v82) = *(_DWORD *)(a1 + 28);
  v81.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v220.i8, 1), *(float *)(a1 + 16), *(float *)v220.i32);
  LODWORD(v83) = *(_DWORD *)(a1 + 36);
  *(float *)v84.f64 = *(float *)&v83
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v220.i8, 1), *(float *)&v82, *(float *)v220.i32);
  v81.i32[1] = LODWORD(v84.f64[0]);
  *(double *)v88.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v81.i64, v84, v82, v83, v220, v85, v86, v87);
  v188 = v88;
  LODWORD(v89) = *(_DWORD *)(a1 + 28);
  v88.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v223.i8, 1), *(float *)(a1 + 16), *(float *)v223.i32);
  LODWORD(v90) = *(_DWORD *)(a1 + 36);
  *(float *)v91.f64 = *(float *)&v90
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v223.i8, 1), *(float *)&v89, *(float *)v223.i32);
  v88.i32[1] = LODWORD(v91.f64[0]);
  *(double *)v95.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v88.i64, v91, v89, v90, v223, v92, v93, v94);
  v97 = *(float32x2_t *)v224.i8;
  v96 = *(float *)a2.i32;
  v187 = v95;
  v98 = fabsf((float)(vsub_f32(v200, *(float32x2_t *)v224.i8).f32[0] / *(float *)a2.i32) + a3);
  v201 = 0.0;
  v199 = 0.0;
  if (v98 < 3.0)
  {
    v99 = v98;
    v199 = 1.0;
    if (v99 >= 0.000001)
    {
      v100 = v99 * 3.14159265;
      v101 = sinf(v100);
      v102 = v100 * 0.125;
      v103 = v101 / v100;
      v104 = cos(v102);
      v97 = *(float32x2_t *)v224.i8;
      v96 = *(float *)a2.i32;
      *(float *)&v104 = v104;
      v199 = (float)((float)((float)(v103 * *(float *)&v104) * *(float *)&v104) * *(float *)&v104) * *(float *)&v104;
    }
  }
  v105 = fabsf((float)(vsub_f32(*(float32x2_t *)v202.i8, v97).f32[0] / v96) + a3);
  if (v105 < 3.0)
  {
    v106 = v105;
    v201 = 1.0;
    if (v106 >= 0.000001)
    {
      v107 = v106 * 3.14159265;
      v108 = sinf(v107);
      v109 = v107 * 0.125;
      v110 = v108 / v107;
      v111 = cos(v109);
      v97 = *(float32x2_t *)v224.i8;
      v96 = *(float *)a2.i32;
      *(float *)&v111 = v111;
      v201 = (float)((float)((float)(v110 * *(float *)&v111) * *(float *)&v111) * *(float *)&v111) * *(float *)&v111;
    }
  }
  v112 = fabsf((float)(vsub_f32(*(float32x2_t *)v204.i8, v97).f32[0] / v96) + a3);
  v205 = 0.0;
  v203 = 0.0;
  if (v112 < 3.0)
  {
    v113 = v112;
    v203 = 1.0;
    if (v113 >= 0.000001)
    {
      v114 = v113 * 3.14159265;
      v115 = sinf(v114);
      v116 = v114 * 0.125;
      v117 = v115 / v114;
      v118 = cos(v116);
      v97 = *(float32x2_t *)v224.i8;
      v96 = *(float *)a2.i32;
      *(float *)&v118 = v118;
      v203 = (float)((float)((float)(v117 * *(float *)&v118) * *(float *)&v118) * *(float *)&v118) * *(float *)&v118;
    }
  }
  v119 = fabsf((float)(vsub_f32(*(float32x2_t *)v206.i8, v97).f32[0] / v96) + a3);
  if (v119 < 3.0)
  {
    v120 = v119;
    v205 = 1.0;
    if (v120 >= 0.000001)
    {
      v121 = v120 * 3.14159265;
      v122 = sinf(v121);
      v123 = v121 * 0.125;
      v124 = v122 / v121;
      v125 = cos(v123);
      v97 = *(float32x2_t *)v224.i8;
      v96 = *(float *)a2.i32;
      *(float *)&v125 = v125;
      v205 = (float)((float)((float)(v124 * *(float *)&v125) * *(float *)&v125) * *(float *)&v125) * *(float *)&v125;
    }
  }
  v126 = fabsf((float)(vsub_f32(*(float32x2_t *)v208.i8, v97).f32[0] / v96) + a3);
  v209 = 0.0;
  v207 = 0.0;
  if (v126 < 3.0)
  {
    v127 = v126;
    v207 = 1.0;
    if (v127 >= 0.000001)
    {
      v128 = v127 * 3.14159265;
      v129 = sinf(v128);
      v130 = v128 * 0.125;
      v131 = v129 / v128;
      v132 = cos(v130);
      v97 = *(float32x2_t *)v224.i8;
      v96 = *(float *)a2.i32;
      *(float *)&v132 = v132;
      v207 = (float)((float)((float)(v131 * *(float *)&v132) * *(float *)&v132) * *(float *)&v132) * *(float *)&v132;
    }
  }
  v133 = fabsf((float)((float)(*(float *)v210.i32 - v97.f32[0]) / v96) + a3);
  if (v133 < 3.0)
  {
    v134 = v133;
    v209 = 1.0;
    if (v134 >= 0.000001)
    {
      v135 = v134 * 3.14159265;
      v136 = sinf(v135);
      v137 = v135 * 0.125;
      v138 = v136 / v135;
      v139 = cos(v137);
      v97 = *(float32x2_t *)v224.i8;
      v96 = *(float *)a2.i32;
      *(float *)&v139 = v139;
      v209 = (float)((float)((float)(v138 * *(float *)&v139) * *(float *)&v139) * *(float *)&v139) * *(float *)&v139;
    }
  }
  v140 = fabsf((float)(vsub_f32(*(float32x2_t *)v211.i8, v97).f32[0] / v96) + a3);
  v141 = 0.0;
  v142 = 0.0;
  if (v140 < 3.0)
  {
    v143 = v140;
    v142 = 1.0;
    if (v143 >= 0.000001)
    {
      v144 = v143 * 3.14159265;
      v145 = sinf(v144);
      v146 = v144 * 0.125;
      v147 = v145 / v144;
      v148 = cos(v146);
      v141 = 0.0;
      v97 = *(float32x2_t *)v224.i8;
      v96 = *(float *)a2.i32;
      *(float *)&v148 = v148;
      v142 = (float)((float)((float)(v147 * *(float *)&v148) * *(float *)&v148) * *(float *)&v148) * *(float *)&v148;
    }
  }
  v149 = fabsf((float)(vsub_f32(*(float32x2_t *)v213.i8, v97).f32[0] / v96) + a3);
  v214 = v142;
  if (v149 < 3.0)
  {
    v150 = v149;
    v141 = 1.0;
    if (v150 >= 0.000001)
    {
      v151 = v150 * 3.14159265;
      v152 = sinf(v151);
      v153 = v151 * 0.125;
      v154 = v152 / v151;
      v155 = cos(v153);
      v142 = v214;
      v97 = *(float32x2_t *)v224.i8;
      v96 = *(float *)a2.i32;
      *(float *)&v155 = v155;
      v141 = (float)((float)((float)(v154 * *(float *)&v155) * *(float *)&v155) * *(float *)&v155) * *(float *)&v155;
    }
  }
  v156 = fabsf((float)(vsub_f32(*(float32x2_t *)v215.i8, v97).f32[0] / v96) + a3);
  v157 = 0.0;
  v158 = 0.0;
  v212 = v141;
  if (v156 < 3.0)
  {
    v159 = v156;
    v158 = 1.0;
    if (v159 >= 0.000001)
    {
      v160 = v159 * 3.14159265;
      v161 = sinf(v160);
      v162 = v160 * 0.125;
      v163 = v161 / v160;
      v164 = cos(v162);
      v157 = 0.0;
      v141 = v212;
      v142 = v214;
      v97 = *(float32x2_t *)v224.i8;
      v96 = *(float *)a2.i32;
      *(float *)&v164 = v164;
      v158 = (float)((float)((float)(v163 * *(float *)&v164) * *(float *)&v164) * *(float *)&v164) * *(float *)&v164;
    }
  }
  v165 = fabsf((float)(vsub_f32(*(float32x2_t *)v216.i8, v97).f32[0] / v96) + a3);
  if (v165 < 3.0)
  {
    v166 = v165;
    v157 = 1.0;
    if (v166 >= 0.000001)
    {
      v167 = v166 * 3.14159265;
      v217 = v158;
      v168 = sinf(v167);
      v169 = v167 * 0.125;
      v170 = v168 / v167;
      v171 = cos(v169);
      v158 = v217;
      v141 = v212;
      v142 = v214;
      v97 = *(float32x2_t *)v224.i8;
      v96 = *(float *)a2.i32;
      *(float *)&v171 = v171;
      v157 = (float)((float)((float)(v170 * *(float *)&v171) * *(float *)&v171) * *(float *)&v171) * *(float *)&v171;
    }
  }
  v172 = fabsf((float)(vsub_f32(*(float32x2_t *)v220.i8, v97).f32[0] / v96) + a3);
  v173 = 0.0;
  v174 = 0.0;
  if (v172 < 3.0)
  {
    v175 = v172;
    v174 = 1.0;
    if (v175 >= 0.000001)
    {
      v176 = v175 * 3.14159265;
      v218 = v158;
      v221 = v157;
      v177 = sinf(v176);
      v178 = v176 * 0.125;
      v179 = v177 / v176;
      v180 = cos(v178);
      v173 = 0.0;
      v158 = v218;
      v157 = v221;
      v141 = v212;
      v142 = v214;
      v97 = *(float32x2_t *)v224.i8;
      v96 = *(float *)a2.i32;
      *(float *)&v180 = v180;
      v174 = (float)((float)((float)(v179 * *(float *)&v180) * *(float *)&v180) * *(float *)&v180) * *(float *)&v180;
    }
  }
  v181 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)v223.i8, v97));
  *(float *)&v181 = fabsf((float)(*(float *)&v181 / v96) + a3);
  if (*(float *)&v181 < 3.0)
  {
    v181 = *(float *)&v181;
    v173 = 1.0;
    if (v181 >= 0.000001)
    {
      v182 = v181 * 3.14159265;
      v219 = v158;
      v222 = v157;
      v226 = v174;
      v183 = sinf(v182);
      v184 = v182 * 0.125;
      v185 = v183 / v182;
      v181 = cos(v184);
      v174 = v226;
      v158 = v219;
      v157 = v222;
      v141 = v212;
      v142 = v214;
      *(float *)&v181 = v181;
      v173 = (float)((float)((float)(v185 * *(float *)&v181) * *(float *)&v181) * *(float *)&v181) * *(float *)&v181;
    }
  }
  *(float *)&v181 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v199 + v201) + v203)
                                                                                  + v205)
                                                                          + v207)
                                                                  + v209)
                                                          + v142)
                                                  + v141)
                                          + v158)
                                  + v157)
                          + v174)
                  + v173;
  *(_QWORD *)&result = vdivq_f32(vaddq_f32(vmulq_n_f32(v192, v142), vaddq_f32(vmulq_n_f32(v191, v141), vaddq_f32(vmulq_n_f32(v190, v158), vaddq_f32(vmulq_n_f32(v189, v157), vaddq_f32(vmulq_n_f32(v188, v174), vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(v198, v199), vmulq_n_f32(v197, v201)), vmulq_n_f32(v196, v203)), vmulq_n_f32(v195, v205)), vmulq_n_f32(v194, v207)),
                                       vmulq_n_f32(v193, v209)),
                                     vmulq_n_f32(v187, v173))))))),
                         (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v181, 0)).u64[0];
  return result;
}

void CI::f4_sr_f4_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, __n128, float);
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  __n128 *v17;
  __int128 v18;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, __n128, float))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_DWORD *)(v11 + 40);
  v15 = *(_QWORD *)(v11 + 32);
  v16 = *(_QWORD *)(v11 + 56);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 80)), a2);
  v17 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v15);
  *(double *)&v18 = v12(a4 + 80 * v13, *v17, *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

float ___ZL5downVP7CIImagedd_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5;
  float v6;
  float result;

  v5 = *(double *)(a1 + 32);
  v6 = *(double *)(a1 + 40);
  roiDownK(*(CGRect *)&a2, v5, v6, 0);
  return result;
}

double cikernel::_asgDownV(uint64_t a1, int8x16_t a2, float a3)
{
  float32x2_t *DC;
  int8x16_t v7;
  float v8;
  double v9;
  int8x16_t v10;
  float64x2_t v11;
  float32x2_t v17;
  float32x2_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  float v24;
  float32x4_t v25;
  double v26;
  int8x16_t v27;
  double v28;
  float v29;
  float64x2_t v30;
  double v31;
  int8x16_t v32;
  float32x4_t v33;
  double v34;
  double v35;
  float64x2_t v36;
  uint8x8_t v37;
  double v38;
  int8x16_t v39;
  float32x4_t v40;
  double v41;
  double v42;
  float64x2_t v43;
  uint8x8_t v44;
  double v45;
  int8x16_t v46;
  float32x4_t v47;
  double v48;
  double v49;
  float64x2_t v50;
  uint8x8_t v51;
  double v52;
  int8x16_t v53;
  float32x4_t v54;
  double v55;
  int8x16_t v56;
  double v57;
  float64x2_t v58;
  int8x16_t v59;
  float32x4_t v60;
  double v61;
  double v62;
  float64x2_t v63;
  uint8x8_t v64;
  double v65;
  int8x16_t v66;
  float32x4_t v67;
  double v68;
  double v69;
  float64x2_t v70;
  uint8x8_t v71;
  double v72;
  int8x16_t v73;
  float32x4_t v74;
  double v75;
  double v76;
  float64x2_t v77;
  uint8x8_t v78;
  double v79;
  int8x16_t v80;
  float32x4_t v81;
  double v82;
  double v83;
  float64x2_t v84;
  uint8x8_t v85;
  double v86;
  int8x16_t v87;
  float32x4_t v88;
  double v89;
  double v90;
  float64x2_t v91;
  uint8x8_t v92;
  double v93;
  int8x16_t v94;
  float32x4_t v95;
  double v96;
  double v97;
  float64x2_t v98;
  uint8x8_t v99;
  double v100;
  int8x16_t v101;
  float32x4_t v102;
  float v103;
  float v104;
  double v105;
  float v106;
  float v107;
  long double v108;
  float v109;
  float v110;
  float v111;
  double v112;
  float v113;
  float v114;
  long double v115;
  float v116;
  float v117;
  float v118;
  float v119;
  double v120;
  float v121;
  float v122;
  long double v123;
  float v124;
  float v125;
  float v126;
  double v127;
  float v128;
  float v129;
  long double v130;
  float v131;
  float v132;
  float v133;
  float v134;
  float v135;
  double v136;
  float v137;
  float v138;
  long double v139;
  float v140;
  long double v141;
  float v142;
  double v143;
  float v144;
  float v145;
  long double v146;
  float v147;
  float v148;
  float v149;
  float v150;
  float v151;
  double v152;
  float v153;
  float v154;
  long double v155;
  float v156;
  long double v157;
  float v158;
  double v159;
  float v160;
  float v161;
  long double v162;
  float v163;
  float v164;
  float v165;
  float v166;
  float v167;
  double v168;
  float v169;
  float v170;
  long double v171;
  float v172;
  long double v173;
  float v174;
  double v175;
  float v176;
  float v177;
  long double v178;
  float v179;
  long double v180;
  long double v181;
  float v182;
  float v183;
  float v184;
  float v185;
  long double v186;
  float v187;
  float v188;
  float v189;
  float v190;
  long double v191;
  float v192;
  double result;
  float v194;
  float32x4_t v195;
  float32x4_t v196;
  float32x4_t v197;
  float32x4_t v198;
  float32x4_t v199;
  float32x4_t v200;
  double v201;
  float32x4_t v202;
  float32x4_t v203;
  float32x4_t v204;
  float32x4_t v205;
  float32x2_t v206;
  float32x4_t v207;
  float32x4_t v208;
  int8x16_t v210;
  float v211;
  int8x16_t v212;
  float v213;
  int8x16_t v214;
  float v215;
  int8x16_t v216;
  uint8x8_t v217;
  float v218;
  int8x16_t v219;
  int8x16_t v220;
  float v221;
  int8x16_t v222;
  float v223;
  int8x16_t v224;
  float v225;
  float v226;
  float v227;
  int8x16_t v228;
  float v229;
  float v230;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  _Q2 = a2;
  *(float32x2_t *)v7.i8 = vmul_f32(*(float32x2_t *)a2.i8, *DC);
  v201 = *(double *)v7.i64;
  v8 = *(float *)&v7.i32[1];
  v9 = 0.5;
  *(float *)&v9 = floor(*(float *)&v7.i32[1] + -0.5) + 0.5;
  v217 = *(uint8x8_t *)&v9;
  v10 = v7;
  v10.i32[1] = LODWORD(v9);
  v11 = (float64x2_t)vextq_s8(_Q2, _Q2, 8uLL);
  __asm { FMOV            V2.2S, #5.0 }
  *(float32x2_t *)_Q2.i8 = vmul_f32(*(float32x2_t *)&v11.f64[0], *(float32x2_t *)_Q2.i8);
  *(float32x2_t *)v7.i8 = vsub_f32(*(float32x2_t *)v10.i8, *(float32x2_t *)_Q2.i8);
  __asm { FMOV            V4.2S, #4.0 }
  v17 = vmul_f32(*(float32x2_t *)&v11.f64[0], _D4);
  v206 = vsub_f32(*(float32x2_t *)v10.i8, v17);
  __asm { FMOV            V5.2S, #3.0 }
  v19 = vmul_f32(*(float32x2_t *)&v11.f64[0], _D5);
  *(float32x2_t *)v20.i8 = vsub_f32(*(float32x2_t *)v10.i8, v19);
  v210 = v20;
  *(float32x2_t *)v20.i8 = vadd_f32(*(float32x2_t *)&v11.f64[0], *(float32x2_t *)&v11.f64[0]);
  *(float32x2_t *)v21.i8 = vsub_f32(*(float32x2_t *)v10.i8, *(float32x2_t *)v20.i8);
  v212 = v21;
  *(float32x2_t *)v21.i8 = vsub_f32(*(float32x2_t *)v10.i8, *(float32x2_t *)&v11.f64[0]);
  v214 = v21;
  *(float32x2_t *)v21.i8 = vadd_f32(*(float32x2_t *)&v11.f64[0], *(float32x2_t *)v10.i8);
  v216 = v21;
  *(float32x2_t *)v20.i8 = vadd_f32(*(float32x2_t *)v20.i8, *(float32x2_t *)v10.i8);
  *(float32x2_t *)v22.i8 = vadd_f32(v19, *(float32x2_t *)v10.i8);
  v219 = v20;
  v220 = v22;
  *(float32x2_t *)v23.i8 = vadd_f32(v17, *(float32x2_t *)v10.i8);
  *(float32x2_t *)_Q2.i8 = vadd_f32(*(float32x2_t *)_Q2.i8, *(float32x2_t *)v10.i8);
  v222 = v23;
  v224 = _Q2;
  __asm { FMOV            V2.2S, #6.0 }
  *(float32x2_t *)&v11.f64[0] = vmul_f32(*(float32x2_t *)&v11.f64[0], *(float32x2_t *)_Q2.i8);
  *(float32x2_t *)v10.i8 = vadd_f32(*(float32x2_t *)&v11.f64[0], *(float32x2_t *)v10.i8);
  v228 = v10;
  _Q2.i32[0] = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v7.i8, 1), *(float *)_Q2.i32, *(float *)v7.i32);
  v24 = *(float *)&v7.i32[1];
  *(float *)v10.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v7.i8, 1), *(float *)(a1 + 16), *(float *)v7.i32);
  *(float *)v11.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  *(float *)&v10.i32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v10.i64, v11, *(double *)_Q2.i64, *(double *)v7.i64, v23, *(uint8x8_t *)v22.i8, *(double *)v20.i64, v21);
  v208 = v25;
  LODWORD(v26) = *(_DWORD *)(a1 + 28);
  v27.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&v28 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v206, 1), *(float *)&v26, v206.f32[0]);
  v29 = v206.f32[1];
  v25.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v206, 1), *(float *)(a1 + 16), v206.f32[0]);
  *(float *)v30.f64 = *(float *)v27.i32 + *(float *)&v28;
  v25.f32[1] = *(float *)v27.i32 + *(float *)&v28;
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v30, v26, v28, v27, (uint8x8_t)v206, v31, v32);
  v207 = v33;
  LODWORD(v34) = *(_DWORD *)(a1 + 28);
  v33.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v210.i8, 1), *(float *)(a1 + 16), *(float *)v210.i32);
  LODWORD(v35) = *(_DWORD *)(a1 + 36);
  *(float *)v36.f64 = *(float *)&v35
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v210.i8, 1), *(float *)&v34, *(float *)v210.i32);
  v33.i32[1] = LODWORD(v36.f64[0]);
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v33.i64, v36, v34, v35, v210, v37, v38, v39);
  v205 = v40;
  LODWORD(v41) = *(_DWORD *)(a1 + 28);
  v40.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v212.i8, 1), *(float *)(a1 + 16), *(float *)v212.i32);
  LODWORD(v42) = *(_DWORD *)(a1 + 36);
  *(float *)v43.f64 = *(float *)&v42
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v212.i8, 1), *(float *)&v41, *(float *)v212.i32);
  v40.i32[1] = LODWORD(v43.f64[0]);
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v40.i64, v43, v41, v42, v212, v44, v45, v46);
  v204 = v47;
  LODWORD(v48) = *(_DWORD *)(a1 + 28);
  v47.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v214.i8, 1), *(float *)(a1 + 16), *(float *)v214.i32);
  LODWORD(v49) = *(_DWORD *)(a1 + 36);
  *(float *)v50.f64 = *(float *)&v49
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v214.i8, 1), *(float *)&v48, *(float *)v214.i32);
  v47.i32[1] = LODWORD(v50.f64[0]);
  *(double *)v54.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v47.i64, v50, v48, v49, v214, v51, v52, v53);
  v203 = v54;
  LODWORD(v55) = *(_DWORD *)(a1 + 28);
  v56.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&v57 = vmlas_n_f32(*(float *)(a1 + 32) * *(float *)v217.i32, *(float *)&v55, *(float *)&v201);
  v54.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(*(float *)(a1 + 20) * *(float *)v217.i32, *(float *)(a1 + 16), *(float *)&v201);
  *(float *)v58.f64 = *(float *)v56.i32 + *(float *)&v57;
  v54.f32[1] = *(float *)v56.i32 + *(float *)&v57;
  *(double *)v60.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v54.i64, v58, v55, v57, v56, v217, v201, v59);
  v202 = v60;
  LODWORD(v61) = *(_DWORD *)(a1 + 28);
  v60.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v216.i8, 1), *(float *)(a1 + 16), *(float *)v216.i32);
  LODWORD(v62) = *(_DWORD *)(a1 + 36);
  *(float *)v63.f64 = *(float *)&v62
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v216.i8, 1), *(float *)&v61, *(float *)v216.i32);
  v60.i32[1] = LODWORD(v63.f64[0]);
  *(double *)v67.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v60.i64, v63, v61, v62, v216, v64, v65, v66);
  v200 = v67;
  LODWORD(v68) = *(_DWORD *)(a1 + 28);
  v67.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v219.i8, 1), *(float *)(a1 + 16), *(float *)v219.i32);
  LODWORD(v69) = *(_DWORD *)(a1 + 36);
  *(float *)v70.f64 = *(float *)&v69
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v219.i8, 1), *(float *)&v68, *(float *)v219.i32);
  v67.i32[1] = LODWORD(v70.f64[0]);
  *(double *)v74.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v67.i64, v70, v68, v69, v219, v71, v72, v73);
  v199 = v74;
  LODWORD(v75) = *(_DWORD *)(a1 + 28);
  v74.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v220.i8, 1), *(float *)(a1 + 16), *(float *)v220.i32);
  LODWORD(v76) = *(_DWORD *)(a1 + 36);
  *(float *)v77.f64 = *(float *)&v76
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v220.i8, 1), *(float *)&v75, *(float *)v220.i32);
  v74.i32[1] = LODWORD(v77.f64[0]);
  *(double *)v81.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v74.i64, v77, v75, v76, v220, v78, v79, v80);
  v198 = v81;
  LODWORD(v82) = *(_DWORD *)(a1 + 28);
  v81.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v222.i8, 1), *(float *)(a1 + 16), *(float *)v222.i32);
  LODWORD(v83) = *(_DWORD *)(a1 + 36);
  *(float *)v84.f64 = *(float *)&v83
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v222.i8, 1), *(float *)&v82, *(float *)v222.i32);
  v81.i32[1] = LODWORD(v84.f64[0]);
  *(double *)v88.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v81.i64, v84, v82, v83, v222, v85, v86, v87);
  v197 = v88;
  LODWORD(v89) = *(_DWORD *)(a1 + 28);
  v88.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v224.i8, 1), *(float *)(a1 + 16), *(float *)v224.i32);
  LODWORD(v90) = *(_DWORD *)(a1 + 36);
  *(float *)v91.f64 = *(float *)&v90
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v224.i8, 1), *(float *)&v89, *(float *)v224.i32);
  v88.i32[1] = LODWORD(v91.f64[0]);
  *(double *)v95.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v88.i64, v91, v89, v90, v224, v92, v93, v94);
  v196 = v95;
  LODWORD(v96) = *(_DWORD *)(a1 + 28);
  v95.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v228.i8, 1), *(float *)(a1 + 16), *(float *)v228.i32);
  LODWORD(v97) = *(_DWORD *)(a1 + 36);
  *(float *)v98.f64 = *(float *)&v97
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v228.i8, 1), *(float *)&v96, *(float *)v228.i32);
  v95.i32[1] = LODWORD(v98.f64[0]);
  *(double *)v102.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v95.i64, v98, v96, v97, v228, v99, v100, v101);
  v195 = v102;
  v103 = fabsf((float)((float)(v24 - v8) / *(float *)&a2.i32[1]) + a3);
  a2.i32[0] = 0;
  v104 = 0.0;
  if (v103 < 3.0)
  {
    v105 = v103;
    v104 = 1.0;
    if (v105 >= 0.000001)
    {
      v106 = v105 * 3.14159265;
      v107 = sinf(v106);
      v108 = v106 * 0.125;
      v109 = v107 / v106;
      v110 = cos(v108);
      v104 = (float)((float)((float)(v109 * v110) * v110) * v110) * v110;
    }
  }
  v194 = v104;
  v111 = fabsf((float)((float)(v29 - v8) / *(float *)&a2.i32[1]) + a3);
  if (v111 < 3.0)
  {
    v112 = v111;
    a2.i32[0] = 1.0;
    if (v112 >= 0.000001)
    {
      v113 = v112 * 3.14159265;
      v114 = sinf(v113);
      v115 = v113 * 0.125;
      v116 = v114 / v113;
      v117 = cos(v115);
      *(float *)a2.i32 = (float)((float)((float)(v116 * v117) * v117) * v117) * v117;
    }
  }
  v118 = fabsf((float)((float)(*(float *)&v210.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  v213 = 0.0;
  v119 = 0.0;
  if (v118 < 3.0)
  {
    v120 = v118;
    v119 = 1.0;
    if (v120 >= 0.000001)
    {
      v121 = v120 * 3.14159265;
      v122 = sinf(v121);
      v123 = v121 * 0.125;
      v124 = v122 / v121;
      v125 = cos(v123);
      v119 = (float)((float)((float)(v124 * v125) * v125) * v125) * v125;
    }
  }
  v211 = v119;
  v126 = fabsf((float)((float)(*(float *)&v212.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  if (v126 < 3.0)
  {
    v127 = v126;
    v213 = 1.0;
    if (v127 >= 0.000001)
    {
      v128 = v127 * 3.14159265;
      v129 = sinf(v128);
      v130 = v128 * 0.125;
      v131 = v129 / v128;
      v132 = cos(v130);
      v213 = (float)((float)((float)(v131 * v132) * v132) * v132) * v132;
    }
  }
  v133 = fabsf((float)((float)(*(float *)&v214.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  v134 = 0.0;
  v135 = 0.0;
  if (v133 < 3.0)
  {
    v136 = v133;
    v135 = 1.0;
    if (v136 >= 0.000001)
    {
      v137 = v136 * 3.14159265;
      v138 = sinf(v137);
      v139 = v137 * 0.125;
      v140 = v138 / v137;
      v141 = cos(v139);
      v134 = 0.0;
      *(float *)&v141 = v141;
      v135 = (float)((float)((float)(v140 * *(float *)&v141) * *(float *)&v141) * *(float *)&v141) * *(float *)&v141;
    }
  }
  v215 = v135;
  v142 = fabsf((float)((float)(*(float *)v217.i32 - v8) / *(float *)&a2.i32[1]) + a3);
  if (v142 < 3.0)
  {
    v143 = v142;
    v134 = 1.0;
    if (v143 >= 0.000001)
    {
      v144 = v143 * 3.14159265;
      v145 = sinf(v144);
      v146 = v144 * 0.125;
      v147 = v145 / v144;
      v148 = cos(v146);
      v134 = (float)((float)((float)(v147 * v148) * v148) * v148) * v148;
    }
  }
  v218 = v134;
  v149 = fabsf((float)((float)(*(float *)&v216.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  v150 = 0.0;
  v151 = 0.0;
  if (v149 < 3.0)
  {
    v152 = v149;
    v151 = 1.0;
    if (v152 >= 0.000001)
    {
      v153 = v152 * 3.14159265;
      v154 = sinf(v153);
      v155 = v153 * 0.125;
      v156 = v154 / v153;
      v157 = cos(v155);
      v150 = 0.0;
      *(float *)&v157 = v157;
      v151 = (float)((float)((float)(v156 * *(float *)&v157) * *(float *)&v157) * *(float *)&v157) * *(float *)&v157;
    }
  }
  *(float *)v219.i32 = v151;
  v158 = fabsf((float)((float)(*(float *)&v219.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  if (v158 < 3.0)
  {
    v159 = v158;
    v150 = 1.0;
    if (v159 >= 0.000001)
    {
      v160 = v159 * 3.14159265;
      v161 = sinf(v160);
      v162 = v160 * 0.125;
      v163 = v161 / v160;
      v164 = cos(v162);
      v150 = (float)((float)((float)(v163 * v164) * v164) * v164) * v164;
    }
  }
  v165 = fabsf((float)((float)(*(float *)&v220.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  v166 = 0.0;
  v167 = 0.0;
  v221 = v150;
  if (v165 < 3.0)
  {
    v168 = v165;
    v167 = 1.0;
    if (v168 >= 0.000001)
    {
      v169 = v168 * 3.14159265;
      v170 = sinf(v169);
      v171 = v169 * 0.125;
      v172 = v170 / v169;
      v173 = cos(v171);
      v166 = 0.0;
      v150 = v221;
      *(float *)&v173 = v173;
      v167 = (float)((float)((float)(v172 * *(float *)&v173) * *(float *)&v173) * *(float *)&v173) * *(float *)&v173;
    }
  }
  v174 = fabsf((float)((float)(*(float *)&v222.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  if (v174 < 3.0)
  {
    v175 = v174;
    v166 = 1.0;
    if (v175 >= 0.000001)
    {
      v176 = v175 * 3.14159265;
      v225 = v167;
      v177 = sinf(v176);
      v178 = v176 * 0.125;
      v179 = v177 / v176;
      v180 = cos(v178);
      v167 = v225;
      v150 = v221;
      *(float *)&v180 = v180;
      v166 = (float)((float)((float)(v179 * *(float *)&v180) * *(float *)&v180) * *(float *)&v180) * *(float *)&v180;
    }
  }
  HIDWORD(v181) = v228.i32[1];
  *(float *)&v181 = fabsf((float)((float)(*(float *)&v224.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  v182 = 0.0;
  v183 = 0.0;
  if (*(float *)&v181 < 3.0)
  {
    v181 = *(float *)&v181;
    v183 = 1.0;
    if (v181 >= 0.000001)
    {
      v184 = v181 * 3.14159265;
      v226 = v167;
      v229 = v166;
      v185 = sinf(v184);
      v186 = v184 * 0.125;
      v187 = v185 / v184;
      v181 = cos(v186);
      v182 = 0.0;
      v167 = v226;
      v166 = v229;
      v150 = v221;
      *(float *)&v181 = v181;
      v183 = (float)((float)((float)(v187 * *(float *)&v181) * *(float *)&v181) * *(float *)&v181) * *(float *)&v181;
    }
  }
  v188 = fabsf((float)((float)(*(float *)&v228.i32[1] - v8) / *(float *)&a2.i32[1]) + a3);
  if (v188 < 3.0)
  {
    v181 = v188;
    v182 = 1.0;
    if (v181 >= 0.000001)
    {
      v189 = v181 * 3.14159265;
      v227 = v167;
      v230 = v166;
      v223 = v183;
      v190 = sinf(v189);
      v191 = v189 * 0.125;
      v192 = v190 / v189;
      v181 = cos(v191);
      v183 = v223;
      v167 = v227;
      v166 = v230;
      v150 = v221;
      *(float *)&v181 = v181;
      v182 = (float)((float)((float)(v192 * *(float *)&v181) * *(float *)&v181) * *(float *)&v181) * *(float *)&v181;
    }
  }
  *(float *)&v181 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v194
                                                                                                  + *(float *)a2.i32)
                                                                                          + v211)
                                                                                  + v213)
                                                                          + v215)
                                                                  + v218)
                                                          + *(float *)v219.i32)
                                                  + v150)
                                          + v167)
                                  + v166)
                          + v183)
                  + v182;
  *(_QWORD *)&result = vdivq_f32(vaddq_f32(vmulq_n_f32(v200, *(float *)v219.i32), vaddq_f32(vmulq_n_f32(v199, v150), vaddq_f32(vmulq_n_f32(v198, v167), vaddq_f32(vmulq_n_f32(v197, v166), vaddq_f32(vmulq_n_f32(v196, v183), vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(v208, v194), vmulq_n_f32(v207, *(float *)a2.i32)), vmulq_n_f32(v205, v211)), vmulq_n_f32(v204, v213)), vmulq_n_f32(v203, v215)),
                                       vmulq_n_f32(v202, v218)),
                                     vmulq_n_f32(v195, v182))))))),
                         (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v181, 0)).u64[0];
  return result;
}

double cikernel::_CIAreaHistogramScaleAndClamp(float32x4_t a1, double a2, double a3)
{
  double result;

  *(_QWORD *)&result = vminnmq_f32(vmaxnmq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0), (float32x4_t)0), vdivq_f32(vrndmq_f32(vmulq_n_f32(vmulq_n_f32(a1, *(float *)&a2), *(float *)&a3)), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0))).u64[0];
  return result;
}

void CI::f4_s_f_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, float, float);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __n128 *v16;
  __int128 v17;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, float, float))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v16 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v16 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v17 = v11(a1, *v16, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15));
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

void ___ZL16mpsAreaHistogramPU32objcproto21CIImageProcessorInput11objc_objectPU33objcproto22CIImageProcessorOutput11objc_object5IRectjjf_block_invoke(uint64_t a1)
{

}

double ___ZN2CI13AreaHistogramL17loadConvertKernelEPU19objcproto9MTLDevice11objc_object_block_invoke()
{
  uint64_t v0;
  double result;

  v0 = operator new();
  result = 0.0;
  *(_OWORD *)v0 = 0u;
  *(_OWORD *)(v0 + 16) = 0u;
  *(_DWORD *)(v0 + 32) = 1065353216;
  CI::AreaHistogram::kernelCache = v0;
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::find<unsigned long long>(_QWORD *a1, unint64_t *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (v3 >= *(_QWORD *)&v2)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (*(_QWORD *)&v2 - 1) & v3;
  }
  v6 = *(_QWORD **)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  result = (_QWORD *)*v6;
  if (*v6)
  {
    do
    {
      v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == v3)
          return result;
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(_QWORD *)&v2)
            v8 %= *(_QWORD *)&v2;
        }
        else
        {
          v8 &= *(_QWORD *)&v2 - 1;
        }
        if (v8 != v5)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__emplace_unique_key_args<unsigned long long,unsigned long long,objc_object  {objcproto23MTLComputePipelineState}&>(uint64_t a1, unint64_t *a2, _QWORD *a3, uint64_t *a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  uint64_t v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v8 = *a2;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v8 >= v9)
        v4 = v8 % v9;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == v8)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v8;
  v14 = *a4;
  i[2] = *a3;
  i[3] = v14;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    v17 = 1;
    if (v9 >= 3)
      v17 = (v9 & (v9 - 1)) != 0;
    v18 = v17 | (2 * v9);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>(a1, v20);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v4 = v8 % v9;
      else
        v4 = v8;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *i = *v22;
LABEL_38:
    *v22 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v21 + 8 * v4) = a1 + 16;
  if (*i)
  {
    v23 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v23 >= v9)
        v23 %= v9;
    }
    else
    {
      v23 &= v9 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_192219E54(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__do_rehash<true>(a1, prime);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  unint64_t v12;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_24:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

double cikernel::_CIAreaHistogramScale(float32x4_t a1, float a2)
{
  float32x4_t v2;
  float32x4_t v3;
  double result;

  v2 = vmulq_n_f32(a1, a2);
  v3 = (float32x4_t)vdupq_n_s32(0x437F0000u);
  *(_QWORD *)&result = vdivq_f32(vrndmq_f32(vmulq_f32(v2, v3)), v3).u64[0];
  return result;
}

void CI::f4_s_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, float);
  int v12;
  uint64_t v13;
  uint64_t v14;
  __n128 *v15;
  __int128 v16;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, float))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 56)), a2);
  v15 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v15 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v16 = v11(a1, *v15, *((float *)a2 + 16 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v16;
}

double cikernel::_prepHistogram(float32x4_t a1, float a2)
{
  float32x4_t v3;
  double result;

  a1.i32[3] = 0;
  v3 = vmaxnmq_f32(a1, (float32x4_t)0);
  v3.i32[3] = 0;
  *(_QWORD *)&result = vmulq_n_f32(vminnmq_f32(v3, (float32x4_t)xmmword_19248E2D0), a2).u64[0];
  return result;
}

float32x4_t cikernel::_logHistogram(simd_float4 a1, double a2, float a3)
{
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t result;
  unsigned __int32 v8;

  v8 = a1.u32[3];
  a1.i32[3] = 0;
  v4 = (float32x4_t)_simd_log2_f4(a1);
  v5 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0);
  result = vsubq_f32(v4, v5);
  v5.f32[0] = a3 - *(float *)&a2;
  result.i64[0] = vdivq_f32(result, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 0)).u64[0];
  result.i32[3] = v8;
  return result;
}

float cikernel::_perc_norm_red(float32x4_t a1, float32x4_t a2)
{
  return fmaxf(vsubq_f32(a1, a2).f32[0]/ fmaxf(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 1), a2).f32[0], 0.00001), 0.0);
}

void CI::f4_s_s(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __n128 *v16;
  __n128 *v17;
  __int128 v18;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 56)), a2);
  v16 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v16 = (__n128 *)((char *)a2 + 64 * v15);
  v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v18 = v11(a1, *v17, *v16);
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_perc_accum_red(cikernel *this, SamplerObj *a2, double a3, float64x2_t a4, double a5, double a6, int8x16_t a7, double a8, double a9, int8x16_t a10)
{
  float v10;
  float v11;
  int v12;
  float v13;
  int v15;
  float v16;
  float v17;
  float v18;
  double v19;
  double result;

  v10 = *(float *)a4.f64;
  v11 = *(float *)&a3;
  v12 = (int)*(float *)a4.f64;
  v13 = 0.0;
  if ((int)*(float *)a4.f64 < 1)
  {
    v15 = 0;
    v16 = 0.0;
    v17 = 0.0;
  }
  else
  {
    v15 = 0;
    v16 = 0.0;
    v17 = 0.0;
    while (1)
    {
      v18 = (float)v15 + 0.5;
      LODWORD(a5) = *((_DWORD *)this + 6);
      LODWORD(a8) = *((_DWORD *)this + 9);
      *(float *)a7.i32 = *((float *)this + 8) * 0.5;
      *(float *)&a6 = *(float *)a7.i32 + (float)(v18 * *((float *)this + 7));
      *(float *)&v19 = *(float *)&a5
                     + (float)((float)(*((float *)this + 5) * 0.5) + (float)(v18 * *((float *)this + 4)));
      *(float *)a4.f64 = *(float *)&a8 + *(float *)&a6;
      *((float *)&v19 + 1) = *(float *)&a8 + *(float *)&a6;
      a3 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v19, a4, a5, a6, a7, *(uint8x8_t *)&a8, a9, a10);
      v17 = v17 + *(float *)&a3;
      if (v17 >= v11)
        break;
      v16 = v16 + *(float *)&a3;
      if (v12 == ++v15)
      {
        v15 = v12;
        break;
      }
    }
  }
  if (v11 > 0.0 && (float)(v17 - v16) > 0.0)
    v13 = (float)(v11 - v16) / (float)(v17 - v16);
  *(float *)&a3 = (float)(v13 + (float)v15) / v10;
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)&a3, 0).u64[0];
  return result;
}

void CI::f4_sr_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v11;
  double (*v12)(uint64_t, float, float);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;

  v11 = *(_QWORD **)(a1 + 48);
  v12 = *(double (**)(uint64_t, float, float))(a1 + 24);
  v13 = v11[1];
  v14 = v11[4];
  v15 = v11[7];
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * v11[10]), a2);
  *(double *)&v16 = v12(a4 + 80 * v13, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15));
  *(_OWORD *)(a3 + 16 * a7) = v16;
}

float cikernel::_perc_denorm_red(float a1, float32x4_t a2)
{
  return vmlas_n_f32(a2.f32[0], vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 1), a2).f32[0], a1);
}

float cikernel::_perc_clip_hard(float32x4_t a1, float32x4_t a2)
{
  BOOL v2;
  float v3;

  v2 = (vmovn_s32(vcgtq_f32(a2, a1)).u8[0] & 1) == 0;
  v3 = 1.0;
  if (!v2)
    return 0.0;
  return v3;
}

float cikernel::_perc_clip_soft(float32x4_t a1, float32x4_t a2)
{
  BOOL v2;
  float v3;

  v2 = (vmovn_s32(vcgtq_f32(a2, a1)).u8[0] & 1) == 0;
  v3 = 0.0;
  if (v2)
    return a1.f32[0];
  return v3;
}

void OUTLINED_FUNCTION_1(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

uint64_t OUTLINED_FUNCTION_3()
{
  return objc_opt_class();
}

void OUTLINED_FUNCTION_4(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x16u);
}

void sub_19221C080(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(v1 - 208))(v1 - 224);
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

double maximum_time(double a1, double a2, float a3, float a4)
{
  int v4;
  float v5;
  float32x2_t v6;
  double v7;
  float32x2_t v9;
  float32x2_t v10;
  float v11;
  _BOOL4 v12;
  int i;
  float v14;
  float v15;
  double v16;
  double v17;
  float v18;
  double v19;
  float32_t v20;
  float32x2_t v21;
  float32x2_t v22;

  v4 = vcvtps_s32_f32(vmlas_n_f32(vmuls_lane_f32(*(float *)&a2, *(float32x2_t *)&a1, 1), *((float *)&a2 + 1), *(float *)&a1) / a3);
  if (*(float *)&a2 < 0.00001)
  {
    v5 = sqrtf(*((float *)&a1 + 1) / a4) + (float)(v4 - 1);
LABEL_7:
    v7 = v5;
    return v7 + 0.00001;
  }
  if (*((float *)&a2 + 1) < 0.00001)
  {
    v5 = sqrtf(*(float *)&a1 / a4) + (float)(v4 - 1);
    goto LABEL_7;
  }
  if (v4 == 1)
  {
    v6 = vsqrt_f32(vdiv_f32(*(float32x2_t *)&a1, vmul_n_f32(*(float32x2_t *)&a2, a4)));
    v5 = fminf(v6.f32[0], v6.f32[1]);
    goto LABEL_7;
  }
  v7 = 0.0;
  if (v4 >= 2)
  {
    v9 = vmul_n_f32(*(float32x2_t *)&a2, a4);
    v10 = vsqrt_f32(vdiv_f32(*(float32x2_t *)&a1, v9));
    v11 = fminf(v10.f32[0], v10.f32[1]);
    v7 = 0.0;
    v12 = 1;
    for (i = 1; i != v4; ++i)
    {
      v14 = (float)i;
      v15 = (float)i * a3;
      v16 = (float)((float)-(float)(v15 * *((float *)&a2 + 1)) / *(float *)&a2);
      v17 = (float)((float)((float)(*(float *)&a2 * v15) / *((float *)&a2 + 1))
                  - (float)(*((float *)&a1 + 1) / *((float *)&a2 + 1)));
      if ((float)-*((float *)&a2 + 1) * v16 < (float)-*((float *)&a2 + 1) * v17)
        v17 = v16;
      v18 = (float)((float)(*((float *)&a2 + 1) * a3) * v14) + v17 * *(float *)&a2;
      if (v12)
      {
        v19 = fmax(v7, (float)(v11 + (float)(i - 1)));
        v12 = v18 <= 0.00001;
        if (v18 > 0.00001)
          v7 = v19;
      }
      v20 = (float)((float)(*(float *)&a2 * a3) * v14) - v17 * *((float *)&a2 + 1);
      v21.f32[0] = *(float *)&a1 - v18;
      v21.f32[1] = v20;
      v22 = vsqrt_f32(vdiv_f32(v21, v9));
      v7 = fmax(v7, (float)(fminf(v22.f32[0], v22.f32[1]) + v14));
    }
  }
  return v7 + 0.00001;
}

float32x2_t cikernel::_barsSwipe(CI *a1, __n128 a2, float32x2_t a3, float a4)
{
  float32x2_t *DC;
  float v7;

  DC = (float32x2_t *)CI::getDC(a1);
  v7 = fmaxf(a4 - fabsf(floorf(a2.n128_f32[2] + vaddv_f32(vmul_f32((float32x2_t)a2.n128_u64[0], *DC)))), 0.0);
  return vadd_f32(*(float32x2_t *)CI::getDC((CI *)DC), vmul_n_f32(a3, v7 * v7));
}

void CI::f2_f3_f2_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, double, float);
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  double *v16;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, double, float))a1[3];
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v16 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v16 = (double *)((char *)a2 + 64 * v14);
  *(double *)(a3 + 16 * a7) = v11(a1, *((__n128 *)a2 + 4 * v12), *v16, *((float *)a2 + 16 * v15));
}

void cikernel::_CBHorzGuided(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4, float a5, float a6)
{
  float32x2_t *DC;
  int8x16_t v12;
  double v13;
  double v14;
  double v15;
  float64x2_t v16;
  uint8x8_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  double v21;
  double v22;
  float64x2_t v23;
  uint8x8_t v24;
  double v25;
  int8x16_t v26;
  __int128 v27;
  int v28;
  int v29;
  int v30;
  float32x4_t v31;
  float v32;
  float64x2_t v33;
  int8x16_t v34;
  double v35;
  double v36;
  double v37;
  uint8x8_t v38;
  double v39;
  int8x16_t v40;
  float32x4_t v41;
  double v42;
  int8x16_t v43;
  double v44;
  float64x2_t v45;
  double v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float v52;
  float v53;
  float32x4_t v54;
  int8x16_t v55;
  float32x2_t v56;
  float32x4_t v57;
  __int32 v58;
  __int32 v59;
  __int128 v60;
  float32x4_t v61;
  float32x4_t v62;

  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v12.i8 = *DC;
  v55 = v12;
  LODWORD(v13) = *((_DWORD *)this + 7);
  *(float *)&v14 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v15) = *((_DWORD *)this + 9);
  *(float *)v16.f64 = *(float *)&v15
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v13, COERCE_FLOAT(*DC));
  HIDWORD(v14) = LODWORD(v16.f64[0]);
  *(double *)v20.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v14, v16, v13, v15, v12, v17, v18, v19);
  v54 = v20;
  LODWORD(v21) = *((_DWORD *)a2 + 7);
  v20.f32[0] = *((float *)a2 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), *(float32x2_t *)v55.i8, 1), *((float *)a2 + 4), *(float *)v55.i32);
  LODWORD(v22) = *((_DWORD *)a2 + 9);
  *(float *)v23.f64 = *(float *)&v22
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), *(float32x2_t *)v55.i8, 1), *(float *)&v21, *(float *)v55.i32);
  v20.i32[1] = LODWORD(v23.f64[0]);
  CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v20.i64, v23, v21, v22, v55, v24, v25, v26);
  v28 = (int)a4;
  if (((int)a4 & 0x80000000) == 0)
  {
    v29 = -v28;
    v30 = (2 * v28) | 1;
    v31 = 0uLL;
    LODWORD(v27) = 0;
    do
    {
      v60 = v27;
      v61 = v31;
      v32 = expf(-(float)((float)(v29 * v29) * a6));
      HIDWORD(v33.f64[0]) = 0;
      *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v55.i8, (float32x2_t)COERCE_UNSIGNED_INT((float)v29));
      v56 = *(float32x2_t *)v34.i8;
      LODWORD(v35) = *((_DWORD *)this + 7);
      *(float *)&v36 = *((float *)this + 6)
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v34.i8, 1), *((float *)this + 4), *(float *)v34.i32);
      LODWORD(v37) = *((_DWORD *)this + 9);
      *(float *)v33.f64 = *(float *)&v37
                        + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v34.i8, 1), *(float *)&v35, *(float *)v34.i32);
      HIDWORD(v36) = LODWORD(v33.f64[0]);
      *(double *)v41.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v36, v33, v35, v37, v34, v38, v39, v40);
      v62 = v41;
      HIDWORD(v42) = v56.i32[1];
      LODWORD(v42) = *((_DWORD *)a2 + 7);
      v43.i32[0] = *((_DWORD *)a2 + 9);
      *(float *)&v44 = vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), v56, 1), *(float *)&v42, v56.f32[0]);
      v41.f32[0] = *((float *)a2 + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), v56, 1), *((float *)a2 + 4), v56.f32[0]);
      *(float *)v45.f64 = *(float *)v43.i32 + *(float *)&v44;
      v41.f32[1] = *(float *)v43.i32 + *(float *)&v44;
      *(double *)v48.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v41.i64, v45, v42, v44, v43, (uint8x8_t)v56, v46, v47);
      v57 = v48;
      v49 = vsubq_f32(v62, v54);
      v50 = v49;
      v50.i32[3] = v58;
      v49.i32[3] = v59;
      v51 = vmulq_f32(v50, v49);
      v52 = expf(-(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 2), vaddq_f32(v51, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 1))).f32[0]* a5));
      v27 = v60;
      v53 = vmuls_lane_f32(v32 * v52, v62, 3);
      *(float *)&v27 = *(float *)&v60 + v53;
      ++v29;
      v31 = vaddq_f32(v61, vmulq_n_f32(v57, v53));
      --v30;
    }
    while (v30);
  }
}

void CI::f4_sr_sr_f_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v11;
  double (*v12)(uint64_t, uint64_t, float, float, float);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;

  v11 = *(_QWORD **)(a1 + 48);
  v12 = *(double (**)(uint64_t, uint64_t, float, float, float))(a1 + 24);
  v13 = v11[1];
  v14 = v11[4];
  v15 = v11[7];
  v16 = v11[10];
  v17 = v11[13];
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * v11[16]), a2);
  *(double *)&v18 = v12(a4 + 80 * v13, a4 + 80 * v14, *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16), *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

void cikernel::_CBVertGuided(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4, float a5, float a6)
{
  float32x2_t *DC;
  int8x16_t v12;
  double v13;
  double v14;
  double v15;
  float64x2_t v16;
  uint8x8_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  double v21;
  double v22;
  float64x2_t v23;
  uint8x8_t v24;
  double v25;
  int8x16_t v26;
  __int128 v27;
  int v28;
  int v29;
  int v30;
  float32x4_t v31;
  float v32;
  float64x2_t v33;
  int8x16_t v34;
  double v35;
  double v36;
  double v37;
  uint8x8_t v38;
  double v39;
  int8x16_t v40;
  float32x4_t v41;
  double v42;
  int8x16_t v43;
  double v44;
  float64x2_t v45;
  double v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float v52;
  float v53;
  float32x4_t v54;
  int8x16_t v55;
  float32x2_t v56;
  float32x4_t v57;
  __int32 v58;
  __int32 v59;
  __int128 v60;
  float32x4_t v61;
  float32x4_t v62;

  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v12.i8 = *DC;
  v55 = v12;
  LODWORD(v13) = *((_DWORD *)this + 7);
  *(float *)&v14 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v15) = *((_DWORD *)this + 9);
  *(float *)v16.f64 = *(float *)&v15
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v13, COERCE_FLOAT(*DC));
  HIDWORD(v14) = LODWORD(v16.f64[0]);
  *(double *)v20.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v14, v16, v13, v15, v12, v17, v18, v19);
  v54 = v20;
  LODWORD(v21) = *((_DWORD *)a2 + 7);
  v20.f32[0] = *((float *)a2 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), *(float32x2_t *)v55.i8, 1), *((float *)a2 + 4), *(float *)v55.i32);
  LODWORD(v22) = *((_DWORD *)a2 + 9);
  *(float *)v23.f64 = *(float *)&v22
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), *(float32x2_t *)v55.i8, 1), *(float *)&v21, *(float *)v55.i32);
  v20.i32[1] = LODWORD(v23.f64[0]);
  CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v20.i64, v23, v21, v22, v55, v24, v25, v26);
  v28 = (int)a4;
  if (((int)a4 & 0x80000000) == 0)
  {
    v29 = -v28;
    v30 = (2 * v28) | 1;
    v31 = 0uLL;
    LODWORD(v27) = 0;
    do
    {
      v60 = v27;
      v61 = v31;
      v32 = expf(-(float)((float)(v29 * v29) * a6));
      LODWORD(v33.f64[0]) = 0;
      *((float *)v33.f64 + 1) = (float)v29;
      *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v55.i8, *(float32x2_t *)&v33.f64[0]);
      v56 = *(float32x2_t *)v34.i8;
      LODWORD(v35) = *((_DWORD *)this + 7);
      *(float *)&v36 = *((float *)this + 6)
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v34.i8, 1), *((float *)this + 4), *(float *)v34.i32);
      LODWORD(v37) = *((_DWORD *)this + 9);
      *(float *)v33.f64 = *(float *)&v37
                        + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v34.i8, 1), *(float *)&v35, *(float *)v34.i32);
      HIDWORD(v36) = LODWORD(v33.f64[0]);
      *(double *)v41.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v36, v33, v35, v37, v34, v38, v39, v40);
      v62 = v41;
      HIDWORD(v42) = v56.i32[1];
      LODWORD(v42) = *((_DWORD *)a2 + 7);
      v43.i32[0] = *((_DWORD *)a2 + 9);
      *(float *)&v44 = vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), v56, 1), *(float *)&v42, v56.f32[0]);
      v41.f32[0] = *((float *)a2 + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), v56, 1), *((float *)a2 + 4), v56.f32[0]);
      *(float *)v45.f64 = *(float *)v43.i32 + *(float *)&v44;
      v41.f32[1] = *(float *)v43.i32 + *(float *)&v44;
      *(double *)v48.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v41.i64, v45, v42, v44, v43, (uint8x8_t)v56, v46, v47);
      v57 = v48;
      v49 = vsubq_f32(v62, v54);
      v50 = v49;
      v50.i32[3] = v58;
      v49.i32[3] = v59;
      v51 = vmulq_f32(v50, v49);
      v52 = expf(-(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 2), vaddq_f32(v51, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 1))).f32[0]* a5));
      v27 = v60;
      v53 = vmuls_lane_f32(v32 * v52, v62, 3);
      *(float *)&v27 = *(float *)&v60 + v53;
      ++v29;
      v31 = vaddq_f32(v61, vmulq_n_f32(v57, v53));
      --v30;
    }
    while (v30);
  }
}

void cikernel::_CBHorz(cikernel *this, SamplerObj *a2, float a3, float a4, float a5)
{
  float32x2_t *DC;
  int8x16_t v10;
  double v11;
  double v12;
  double v13;
  float64x2_t v14;
  uint8x8_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  __int128 v19;
  int v20;
  int v21;
  int v22;
  float32x4_t v23;
  float v24;
  float64x2_t v25;
  float32x2_t v26;
  double v27;
  double v28;
  uint8x8_t v29;
  int8x16_t v30;
  double v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float v37;
  float v38;
  float32x2_t v39;
  float32x4_t v40;
  float32x4_t v41;
  __int32 v42;
  __int32 v43;
  __int128 v44;
  float32x4_t v45;

  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v10.i8 = *DC;
  LODWORD(v11) = *((_DWORD *)this + 7);
  *(float *)&v12 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v13) = *((_DWORD *)this + 9);
  v39 = *DC;
  *(float *)v14.f64 = *(float *)&v13
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v11, COERCE_FLOAT(*DC));
  HIDWORD(v12) = LODWORD(v14.f64[0]);
  *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v12, v14, v11, v13, v10, v15, v16, v17);
  v40 = v18;
  v20 = (int)a3;
  if (((int)a3 & 0x80000000) == 0)
  {
    v21 = -v20;
    v22 = (2 * v20) | 1;
    v23 = 0uLL;
    LODWORD(v19) = 0;
    do
    {
      v44 = v19;
      v45 = v23;
      v24 = expf(-(float)((float)(v21 * v21) * a5));
      HIDWORD(v25.f64[0]) = 0;
      v26 = vadd_f32(v39, (float32x2_t)COERCE_UNSIGNED_INT((float)v21));
      *(float *)&v27 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v26, 1), *((float *)this + 4), v26.f32[0]);
      LODWORD(v28) = *((_DWORD *)this + 7);
      v29.i32[0] = *((_DWORD *)this + 9);
      *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v26, 1), *(float *)&v28, v26.f32[0]);
      v26.f32[0] = *((float *)this + 6) + *(float *)&v27;
      *(float *)v25.f64 = *(float *)v29.i32 + *(float *)v30.i32;
      v26.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
      *(double *)v33.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v26, v25, v27, v28, v30, v29, v31, v32);
      v41 = v33;
      v34 = vsubq_f32(v33, v40);
      v35 = v34;
      v35.i32[3] = v42;
      v34.i32[3] = v43;
      v36 = vmulq_f32(v35, v34);
      v37 = expf(-(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0]* a4));
      v19 = v44;
      v38 = vmuls_lane_f32(v24 * v37, v41, 3);
      *(float *)&v19 = *(float *)&v44 + v38;
      ++v21;
      v23 = vaddq_f32(v45, vmulq_n_f32(v41, v38));
      --v22;
    }
    while (v22);
  }
}

void CI::f4_sr_f_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v11;
  double (*v12)(uint64_t, float, float, float);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;

  v11 = *(_QWORD **)(a1 + 48);
  v12 = *(double (**)(uint64_t, float, float, float))(a1 + 24);
  v13 = v11[1];
  v14 = v11[4];
  v15 = v11[7];
  v16 = v11[10];
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * v11[13]), a2);
  *(double *)&v17 = v12(a4 + 80 * v13, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

void cikernel::_CBVert(cikernel *this, SamplerObj *a2, float a3, float a4, float a5)
{
  float32x2_t *DC;
  int8x16_t v10;
  double v11;
  double v12;
  double v13;
  float64x2_t v14;
  uint8x8_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  __int128 v19;
  int v20;
  int v21;
  int v22;
  float32x4_t v23;
  float v24;
  float64x2_t v25;
  float32x2_t v26;
  double v27;
  double v28;
  uint8x8_t v29;
  int8x16_t v30;
  double v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float v37;
  float v38;
  float32x2_t v39;
  float32x4_t v40;
  float32x4_t v41;
  __int32 v42;
  __int32 v43;
  __int128 v44;
  float32x4_t v45;

  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v10.i8 = *DC;
  LODWORD(v11) = *((_DWORD *)this + 7);
  *(float *)&v12 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v13) = *((_DWORD *)this + 9);
  v39 = *DC;
  *(float *)v14.f64 = *(float *)&v13
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v11, COERCE_FLOAT(*DC));
  HIDWORD(v12) = LODWORD(v14.f64[0]);
  *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v12, v14, v11, v13, v10, v15, v16, v17);
  v40 = v18;
  v20 = (int)a3;
  if (((int)a3 & 0x80000000) == 0)
  {
    v21 = -v20;
    v22 = (2 * v20) | 1;
    v23 = 0uLL;
    LODWORD(v19) = 0;
    do
    {
      v44 = v19;
      v45 = v23;
      v24 = expf(-(float)((float)(v21 * v21) * a5));
      LODWORD(v25.f64[0]) = 0;
      *((float *)v25.f64 + 1) = (float)v21;
      v26 = vadd_f32(v39, *(float32x2_t *)&v25.f64[0]);
      *(float *)&v27 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v26, 1), *((float *)this + 4), v26.f32[0]);
      LODWORD(v28) = *((_DWORD *)this + 7);
      v29.i32[0] = *((_DWORD *)this + 9);
      *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v26, 1), *(float *)&v28, v26.f32[0]);
      v26.f32[0] = *((float *)this + 6) + *(float *)&v27;
      *(float *)v25.f64 = *(float *)v29.i32 + *(float *)v30.i32;
      v26.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
      *(double *)v33.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v26, v25, v27, v28, v30, v29, v31, v32);
      v41 = v33;
      v34 = vsubq_f32(v33, v40);
      v35 = v34;
      v35.i32[3] = v42;
      v34.i32[3] = v43;
      v36 = vmulq_f32(v35, v34);
      v37 = expf(-(float)(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0]* a4));
      v19 = v44;
      v38 = vmuls_lane_f32(v24 * v37, v41, 3);
      *(float *)&v19 = *(float *)&v44 + v38;
      ++v21;
      v23 = vaddq_f32(v45, vmulq_n_f32(v41, v38));
      --v22;
    }
    while (v22);
  }
}

void OUTLINED_FUNCTION_3_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

const char *OUTLINED_FUNCTION_5(int a1)
{
  return CI::name_for_format(a1);
}

double cikernel::_add(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vaddq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_multiply(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vmulq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_min(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vminnmq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_max(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vmaxnmq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_clear()
{
  return 0.0;
}

double cikernel::_dst(double a1, double a2)
{
  return a2;
}

double cikernel::_srcOver(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vaddq_f32(a1, vmulq_n_f32(a2, 1.0 - a1.f32[3])).u64[0];
  return result;
}

double cikernel::_dstOver(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vaddq_f32(a2, vmulq_n_f32(a1, 1.0 - a2.f32[3])).u64[0];
  return result;
}

double cikernel::_srcIn(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vmulq_laneq_f32(a1, a2, 3).u64[0];
  return result;
}

double cikernel::_dstIn(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vmulq_laneq_f32(a2, a1, 3).u64[0];
  return result;
}

double cikernel::_srcOut(float32x4_t a1, __n128 a2)
{
  double result;

  *(_QWORD *)&result = vmulq_n_f32(a1, 1.0 - a2.n128_f32[3]).u64[0];
  return result;
}

double cikernel::_dstOut(__n128 a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vmulq_n_f32(a2, 1.0 - a1.n128_f32[3]).u64[0];
  return result;
}

double cikernel::_srcAtop(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vaddq_f32(vmulq_laneq_f32(a1, a2, 3), vmulq_n_f32(a2, 1.0 - a1.f32[3])).u64[0];
  return result;
}

double cikernel::_dstAtop(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vaddq_f32(vmulq_laneq_f32(a2, a1, 3), vmulq_n_f32(a1, 1.0 - a2.f32[3])).u64[0];
  return result;
}

double cikernel::_exclusiveOr(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])).u64[0];
  return result;
}

double cikernel::_multiplyBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  double result;

  v2 = vmulq_f32(vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001)), vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001)));
  v2.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v2, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_screenBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  v4 = vsubq_f32(vaddq_f32(v2, v3), vmulq_f32(v2, v3));
  v4.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v4, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_overlayBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v11;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  v5 = vsubq_f32(vaddq_f32(v2, v3), vmulq_f32(v2, v3));
  __asm { FMOV            V17.4S, #-1.0 }
  v11 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(v4, v3)), (int8x16_t)vaddq_f32(vaddq_f32(v5, v5), _Q17), (int8x16_t)vmulq_f32(v2, vaddq_f32(v3, v3)));
  v11.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v11, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_darkenBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  v4 = vminnmq_f32(v3, v2);
  v4.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v4, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_lightenBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  v4 = vmaxnmq_f32(v3, v2);
  v4.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v4, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_colorDodgeBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v8;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  __asm { FMOV            V7.4S, #1.0 }
  v8 = vdivq_f32(vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001)), vmaxnmq_f32(vsubq_f32(_Q7, v2), (float32x4_t)vdupq_n_s32(0x33D6BF95u)));
  v8.i32[3] = 1.0;
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v8, (float32x4_t)0), _Q7), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_colorBurnBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v8;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  __asm { FMOV            V7.4S, #1.0 }
  v8 = vsubq_f32(_Q7, vdivq_f32(vsubq_f32(_Q7, vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001))), vmaxnmq_f32(v2, (float32x4_t)vdupq_n_s32(0x33D6BF95u))));
  v8.i32[3] = 1.0;
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v8, (float32x4_t)0), _Q7), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_hardLightBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v11;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  v5 = vsubq_f32(vaddq_f32(v2, v3), vmulq_f32(v2, v3));
  __asm { FMOV            V17.4S, #-1.0 }
  v11 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(v4, v2)), (int8x16_t)vaddq_f32(vaddq_f32(v5, v5), _Q17), (int8x16_t)vmulq_f32(v3, vaddq_f32(v2, v2)));
  v11.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v11, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_softLightBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v11;
  float32x4_t v13;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v18;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  __asm
  {
    FMOV            V7.4S, #0.25
    FMOV            V17.4S, #16.0
    FMOV            V18.4S, #-12.0
  }
  v11 = vmulq_f32(v3, vaddq_f32(vmulq_f32(v3, _Q17), _Q18));
  __asm { FMOV            V18.4S, #4.0 }
  v13 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(_Q7, v3)), (int8x16_t)vsqrtq_f32(v3), (int8x16_t)vmulq_f32(v3, vaddq_f32(v11, _Q18)));
  __asm { FMOV            V17.4S, #-1.0 }
  v15 = vaddq_f32(vaddq_f32(v2, v2), _Q17);
  _Q17.i64[0] = 0x3F0000003F000000;
  _Q17.i64[1] = 0x3F0000003F000000;
  v16 = vsubq_f32(_Q17, v2);
  __asm { FMOV            V17.4S, #1.0 }
  v18 = vaddq_f32(v3, vmulq_f32(v15, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(v16), (int8x16_t)vsubq_f32(v13, v3), (int8x16_t)vmulq_f32(v3, vsubq_f32(_Q17, v3)))));
  v18.i32[3] = 1.0;
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v18, (float32x4_t)0), _Q17), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_differenceBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  double result;

  v2 = vabdq_f32(vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001)), vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001)));
  v2.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v2, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_exclusionBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  v4.i64[0] = 0xC0000000C0000000;
  v4.i64[1] = 0xC0000000C0000000;
  v5 = vaddq_f32(vaddq_f32(v2, v3), vmulq_f32(v2, vmulq_f32(v3, v4)));
  v5.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v5, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_hueBlendMode(float32x4_t a1, float32x4_t a2, double a3, double a4, double a5, float32x4_t a6)
{
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  int8x16_t v9;
  float32x4_t v10;
  float32x4_t v11;
  int8x16_t v12;
  int32x4_t v13;
  float32x4_t v14;
  int32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  double v22;
  float v23;
  float32x4_t v24;
  double v25;
  int32x2_t v26;
  float v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  double result;

  v6 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v7 = v6;
  v7.i32[3] = a1.i32[3];
  v8 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  a6.i32[0] = v8.i32[1];
  v9.i64[0] = vrev64q_s32((int32x4_t)v7).u64[0];
  v9.i64[1] = v7.i64[1];
  v10 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v7, v9);
  v11 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v10, (float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2))), 1)), (int8x16_t)v10, (int8x16_t)vuzp1q_s32((int32x4_t)v10, vrev64q_s32((int32x4_t)v10)));
  v12 = (int8x16_t)v11;
  v12.i32[0] = v11.i32[1];
  v13 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v11, v12);
  v14 = 0uLL;
  if (*(float *)v13.i32 > *(float *)&v13.i32[2])
  {
    v15 = (int32x4_t)v8;
    v15.i32[3] = a2.i32[3];
    v16.i64[0] = vrev64q_s32(v15).u64[0];
    v16.i64[1] = v15.i64[1];
    v17 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v8, a6), 0), (int8x16_t)v15, v16);
    v18 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v17, (float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2))), 1)), (int8x16_t)v17, (int8x16_t)vuzp1q_s32((int32x4_t)v17, vrev64q_s32((int32x4_t)v17)));
    v19 = (int8x16_t)v18;
    v19.i32[0] = v18.i32[1];
    v20 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))), 0)), (int8x16_t)v18, v19);
    v21 = vmulq_n_f32(vsubq_f32(v7, (float32x4_t)vdupq_laneq_s32(v13, 2)), vsubq_f32(v20, (float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2)).f32[0]);
    *(float *)v13.i32 = *(float *)v13.i32 - *(float *)&v13.i32[2];
    v14 = vdivq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.i8, 0));
  }
  v26.i32[1] = 1069295861;
  v22 = v8.f32[1] * 0.59 + v8.f32[0] * 0.3 + v8.f32[2] * 0.11;
  *(float *)&v22 = v22;
  v23 = v14.f32[1] * 0.59 + v14.f32[0] * 0.3 + v14.f32[2] * 0.11;
  *(float *)&v22 = *(float *)&v22 - v23;
  v24 = vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v22, 0));
  v25 = v24.f32[1] * 0.59 + v24.f32[0] * 0.3 + v24.f32[2] * 0.11;
  *(float *)&v25 = v25;
  *(float *)v26.i32 = fminf(fminf(v24.f32[0], v24.f32[1]), v24.f32[2]);
  v27 = fmaxf(fmaxf(v24.f32[0], v24.f32[1]), v24.f32[2]);
  if (*(float *)v26.i32 < 0.0)
  {
    v28 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v25, 0);
    *(float *)v26.i32 = *(float *)&v25 - *(float *)v26.i32;
    v24 = vaddq_f32(v28, vdivq_f32(vmulq_n_f32(vsubq_f32(v24, v28), *(float *)&v25), (float32x4_t)vdupq_lane_s32(v26, 0)));
  }
  if (v27 > 1.0)
  {
    v29 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v25, 0);
    v30 = vmulq_n_f32(vsubq_f32(v24, v29), 1.0 - *(float *)&v25);
    *(float *)&v25 = v27 - *(float *)&v25;
    v24 = vaddq_f32(v29, vdivq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v25, 0)));
  }
  v24.i32[3] = 1.0;
  __asm { FMOV            V5.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v24, (float32x4_t)0), _Q5), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_saturationBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  int8x16_t v4;
  float32x4_t v5;
  float32x4_t v6;
  int8x16_t v7;
  int8x16_t v8;
  float32x4_t v9;
  float32x4_t v10;
  int16x4_t v11;
  int8x16_t v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  double v18;
  float v19;
  float32x4_t v20;
  double v21;
  int32x2_t v22;
  float v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  double result;

  v2 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3 = v2;
  v3.i32[3] = a2.i32[3];
  v4.i64[0] = vrev64q_s32((int32x4_t)v3).u64[0];
  v4.i64[1] = v3.i64[1];
  v5 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1)), 0), (int8x16_t)v3, v4);
  v6 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v5, (float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2))), 1)), (int8x16_t)v5, (int8x16_t)vuzp1q_s32((int32x4_t)v5, vrev64q_s32((int32x4_t)v5)));
  v7 = (int8x16_t)v6;
  v7.i32[0] = v6.i32[1];
  v8 = vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v6, v7);
  v9 = 0uLL;
  if (*(float *)v8.i32 > *(float *)&v8.i32[2])
  {
    v10 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
    v11 = vmovn_s32(vcgtq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1)));
    v10.i32[3] = a1.i32[3];
    v12.i64[0] = vrev64q_s32((int32x4_t)v10).u64[0];
    v12.i64[1] = v10.i64[1];
    v13 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(v11, 0)), 0x1FuLL)), (int8x16_t)v10, v12);
    v14 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v13, (float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2))), 1)), (int8x16_t)v13, (int8x16_t)vuzp1q_s32((int32x4_t)v13, vrev64q_s32((int32x4_t)v13)));
    v15 = (int8x16_t)v14;
    v15.i32[0] = v14.i32[1];
    v16 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))), 0)), (int8x16_t)v14, v15);
    v17 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2);
    *(float *)v8.i32 = *(float *)v8.i32 - *(float *)&v8.i32[2];
    v9 = vdivq_f32(vmulq_n_f32(vsubq_f32(v3, v17), vsubq_f32(v16, v17).f32[0]), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.i8, 0));
  }
  v22.i32[1] = 1069295861;
  v18 = v2.f32[1] * 0.59 + v2.f32[0] * 0.3 + v2.f32[2] * 0.11;
  *(float *)&v18 = v18;
  v19 = v9.f32[1] * 0.59 + v9.f32[0] * 0.3 + v9.f32[2] * 0.11;
  *(float *)&v18 = *(float *)&v18 - v19;
  v20 = vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v18, 0));
  v21 = v20.f32[1] * 0.59 + v20.f32[0] * 0.3 + v20.f32[2] * 0.11;
  *(float *)&v21 = v21;
  *(float *)v22.i32 = fminf(fminf(v20.f32[0], v20.f32[1]), v20.f32[2]);
  v23 = fmaxf(fmaxf(v20.f32[0], v20.f32[1]), v20.f32[2]);
  if (*(float *)v22.i32 < 0.0)
  {
    v24 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v21, 0);
    *(float *)v22.i32 = *(float *)&v21 - *(float *)v22.i32;
    v20 = vaddq_f32(v24, vdivq_f32(vmulq_n_f32(vsubq_f32(v20, v24), *(float *)&v21), (float32x4_t)vdupq_lane_s32(v22, 0)));
  }
  if (v23 > 1.0)
  {
    v25 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v21, 0);
    v26 = vmulq_n_f32(vsubq_f32(v20, v25), 1.0 - *(float *)&v21);
    *(float *)&v21 = v23 - *(float *)&v21;
    v20 = vaddq_f32(v25, vdivq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v21, 0)));
  }
  v20.i32[3] = 1.0;
  __asm { FMOV            V5.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v20, (float32x4_t)0), _Q5), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_colorBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  int32x4_t v3;
  float32x2_t v4;
  float32x2_t v5;
  float32x4_t v6;
  double v7;
  double v8;
  float v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v3 = (int32x4_t)vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v4 = (float32x2_t)vzip1_s32(*(int32x2_t *)v3.i8, *(int32x2_t *)v2.f32);
  v5 = (float32x2_t)vzip2_s32(*(int32x2_t *)v3.i8, *(int32x2_t *)v2.f32);
  v3.i64[0] = vzip2q_s32(v3, (int32x4_t)v2).u64[0];
  v2.i32[3] = a1.i32[3];
  *(float32x2_t *)v3.i8 = vcvt_f32_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v5), (float64x2_t)vdupq_n_s64(0x3FE2E147AE147AE1uLL)), (float64x2_t)vdupq_n_s64(0x3FD3333333333333uLL), vcvtq_f64_f32(v4)), (float64x2_t)vdupq_n_s64(0x3FBC28F5C28F5C29uLL), vcvtq_f64_f32(*(float32x2_t *)v3.i8)));
  v6 = vaddq_f32(v2, (float32x4_t)vdupq_lane_s32((int32x2_t)vsub_f32(*(float32x2_t *)v3.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v3.i8, 1)), 0));
  v8 = v6.f32[2];
  v7 = v6.f32[1] * 0.59 + v6.f32[0] * 0.3 + v6.f32[2] * 0.11;
  *(float *)&v7 = v7;
  *(float *)&v8 = fminf(fminf(v6.f32[0], v6.f32[1]), v6.f32[2]);
  v9 = fmaxf(fmaxf(v6.f32[0], v6.f32[1]), v6.f32[2]);
  if (*(float *)&v8 < 0.0)
  {
    v10 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0);
    *(float *)&v8 = *(float *)&v7 - *(float *)&v8;
    v6 = vaddq_f32(v10, vdivq_f32(vmulq_n_f32(vsubq_f32(v6, v10), *(float *)&v7), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v8, 0)));
  }
  if (v9 > 1.0)
  {
    v11 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0);
    v12 = vmulq_n_f32(vsubq_f32(v6, v11), 1.0 - *(float *)&v7);
    *(float *)&v7 = v9 - *(float *)&v7;
    v6 = vaddq_f32(v11, vdivq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0)));
  }
  v6.i32[3] = 1.0;
  __asm { FMOV            V6.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v6, (float32x4_t)0), _Q6), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_luminosityBlendMode(float32x4_t a1, float32x4_t a2)
{
  int32x4_t v2;
  float32x4_t v3;
  float32x2_t v4;
  float32x2_t v5;
  float32x4_t v6;
  double v7;
  double v8;
  float v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;

  v2 = (int32x4_t)vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v4 = (float32x2_t)vzip1_s32(*(int32x2_t *)v2.i8, *(int32x2_t *)v3.f32);
  v5 = (float32x2_t)vzip2_s32(*(int32x2_t *)v2.i8, *(int32x2_t *)v3.f32);
  v2.i64[0] = vzip2q_s32(v2, (int32x4_t)v3).u64[0];
  v3.i32[3] = a2.i32[3];
  *(float32x2_t *)v2.i8 = vcvt_f32_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32(v5), (float64x2_t)vdupq_n_s64(0x3FE2E147AE147AE1uLL)), (float64x2_t)vdupq_n_s64(0x3FD3333333333333uLL), vcvtq_f64_f32(v4)), (float64x2_t)vdupq_n_s64(0x3FBC28F5C28F5C29uLL), vcvtq_f64_f32(*(float32x2_t *)v2.i8)));
  v6 = vaddq_f32(v3, (float32x4_t)vdupq_lane_s32((int32x2_t)vsub_f32(*(float32x2_t *)v2.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v2.i8, 1)), 0));
  v8 = v6.f32[2];
  v7 = v6.f32[1] * 0.59 + v6.f32[0] * 0.3 + v6.f32[2] * 0.11;
  *(float *)&v7 = v7;
  *(float *)&v8 = fminf(fminf(v6.f32[0], v6.f32[1]), v6.f32[2]);
  v9 = fmaxf(fmaxf(v6.f32[0], v6.f32[1]), v6.f32[2]);
  if (*(float *)&v8 < 0.0)
  {
    v10 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0);
    *(float *)&v8 = *(float *)&v7 - *(float *)&v8;
    v6 = vaddq_f32(v10, vdivq_f32(vmulq_n_f32(vsubq_f32(v6, v10), *(float *)&v7), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v8, 0)));
  }
  if (v9 > 1.0)
  {
    v11 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0);
    v12 = vmulq_n_f32(vsubq_f32(v6, v11), 1.0 - *(float *)&v7);
    *(float *)&v7 = v9 - *(float *)&v7;
    v6 = vaddq_f32(v11, vdivq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v7, 0)));
  }
  if (a1.f32[3] >= 0.000001)
  {
    v6.i32[3] = 1.0;
    __asm { FMOV            V6.4S, #1.0 }
    a2.i64[0] = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v6, (float32x4_t)0), _Q6), a1, 3), a2, 3)).u64[0];
  }
  return *(double *)a2.i64;
}

double cikernel::_subtractBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  double result;

  v2 = vsubq_f32(vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001)), vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001)));
  v2.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v2, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_divideBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  v3 = vdivq_f32(vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001)), vmaxnmq_f32(v2, (float32x4_t)vdupq_n_s32(0x33D6BF95u)));
  v3.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v3, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_linearBurnBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v7;
  double result;

  __asm { FMOV            V4.4S, #-1.0 }
  v7 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001)), vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001))), _Q4);
  v7.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v7, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_linearDodgeBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  double result;

  v2 = vaddq_f32(vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001)), vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001)));
  v2.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v2, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_vividLightBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v9;
  int8x16_t v10;
  float32x4_t v11;
  int8x16_t v12;
  float32x4_t v13;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  __asm { FMOV            V7.4S, #1.0 }
  v9 = (float32x4_t)vdupq_n_s32(0x33D6BF95u);
  v10 = (int8x16_t)vsubq_f32(_Q7, vdivq_f32(vsubq_f32(_Q7, v3), vmaxnmq_f32(vaddq_f32(v2, v2), v9)));
  v11 = vsubq_f32(_Q7, v2);
  v12 = (int8x16_t)vdivq_f32(v3, vmaxnmq_f32(vaddq_f32(v11, v11), v9));
  v11.i64[0] = 0x3F0000003F000000;
  v11.i64[1] = 0x3F0000003F000000;
  v13 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(v11, v2)), v12, v10);
  v13.i32[3] = 1.0;
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v13, (float32x4_t)0), _Q7), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_linearLightBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v9;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v3 = vaddq_f32(vaddq_f32(v2, v2), vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001)));
  __asm { FMOV            V4.4S, #-1.0 }
  v9 = vaddq_f32(v3, _Q4);
  v9.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v9, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_pinLightBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v10;
  float32x4_t v11;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  v4 = vaddq_f32(v2, v2);
  __asm { FMOV            V7.4S, #-1.0 }
  v10 = vaddq_f32(v4, _Q7);
  v11 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(v3, v10)), (int8x16_t)v10, vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(v3, v4)), (int8x16_t)v3, (int8x16_t)v4));
  v11.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v11, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_hardMixBlendMode(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v9;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v3.i32[3] = a2.i32[3];
  __asm { FMOV            V7.4S, #1.0 }
  v9 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(vsubq_f32(_Q7, v3), v2)), (int8x16_t)_Q7, (int8x16_t)0);
  v9.i32[3] = 1.0;
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v9, (float32x4_t)0), _Q7), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_darkerColorBlendMode(float32x4_t a1, float32x4_t a2)
{
  int32x4_t v2;
  int32x4_t v3;
  float32x2_t v4;
  float32x4_t v5;
  double result;

  v2 = (int32x4_t)vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v3 = (int32x4_t)vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v4 = vcvt_f32_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32((float32x2_t)vzip2_s32(*(int32x2_t *)v2.i8, *(int32x2_t *)v3.i8)), (float64x2_t)vdupq_n_s64(0x3FE2E147AE147AE1uLL)), (float64x2_t)vdupq_n_s64(0x3FD3333333333333uLL), vcvtq_f64_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v2.i8, *(int32x2_t *)v3.i8))), (float64x2_t)vdupq_n_s64(0x3FBC28F5C28F5C29uLL), vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vzip2q_s32(v2, v3))));
  v5 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16((int16x4_t)vcgt_f32(v4, (float32x2_t)vdup_lane_s32((int32x2_t)v4, 1)), 0)), 0x1FuLL)), (int8x16_t)v3, (int8x16_t)v2);
  v5.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v5, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_lighterColorBlendMode(float32x4_t a1, float32x4_t a2)
{
  int32x4_t v2;
  int32x4_t v3;
  float32x2_t v4;
  float32x4_t v5;
  double result;

  v2 = (int32x4_t)vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v3 = (int32x4_t)vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v4 = vcvt_f32_f64(vmlaq_f64(vmlaq_f64(vmulq_f64(vcvtq_f64_f32((float32x2_t)vzip2_s32(*(int32x2_t *)v2.i8, *(int32x2_t *)v3.i8)), (float64x2_t)vdupq_n_s64(0x3FE2E147AE147AE1uLL)), (float64x2_t)vdupq_n_s64(0x3FD3333333333333uLL), vcvtq_f64_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v2.i8, *(int32x2_t *)v3.i8))), (float64x2_t)vdupq_n_s64(0x3FBC28F5C28F5C29uLL), vcvtq_f64_f32((float32x2_t)*(_OWORD *)&vzip2q_s32(v2, v3))));
  v5 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16((int16x4_t)vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v4, 1), v4), 0)), 0x1FuLL)), (int8x16_t)v3, (int8x16_t)v2);
  v5.i32[3] = 1.0;
  __asm { FMOV            V4.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(a2, 1.0 - a1.f32[3]), vmulq_n_f32(a1, 1.0 - a2.f32[3])), vmulq_laneq_f32(vmulq_laneq_f32(vminnmq_f32(vmaxnmq_f32(v5, (float32x4_t)0), _Q4), a1, 3), a2, 3)).u64[0];
  return result;
}

double cikernel::_plusDarker(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v10;
  double result;

  v2 = vaddq_f32(a1, a2);
  v3 = vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 3), v2);
  v3.i32[3] = v2.i32[3];
  v4 = vmaxnmq_f32(v3, (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  v10 = vminnmq_f32(v4, _Q1);
  *(_QWORD *)&result = vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 3), v10).u64[0];
  return result;
}

double cikernel::_plusLighter(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vaddq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_hueBlendMode_v0(float32x4_t a1, float32x4_t a2)
{
  int32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  int32x4_t v5;
  int16x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  int8x16_t v9;
  int32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  int8x16_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  double result;

  v3 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2 = vcgtq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1));
  v3.i32[3] = a1.i32[3];
  v4 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v5 = (int32x4_t)v4;
  v5.i32[3] = a2.i32[3];
  v6 = vmovn_s32(v2);
  v2.i64[0] = vrev64q_s32((int32x4_t)v3).u64[0];
  v2.i64[1] = v3.i64[1];
  v7 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(v6, 0)), 0x1FuLL)), (int8x16_t)v3, (int8x16_t)v2);
  v8 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v7, (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2))), 1)), (int8x16_t)v7, (int8x16_t)vuzp1q_s32((int32x4_t)v7, vrev64q_s32((int32x4_t)v7)));
  v9 = (int8x16_t)v8;
  v9.i32[0] = v8.i32[1];
  v10 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v8, v9);
  v9.i64[0] = vrev64q_s32(v5).u64[0];
  v9.i64[1] = v5.i64[1];
  v11 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v5, v9);
  v12 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v11, (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2))), 1)), (int8x16_t)v11, (int8x16_t)vuzp1q_s32((int32x4_t)v11, vrev64q_s32((int32x4_t)v11)));
  v13 = (int8x16_t)v12;
  v13.i32[0] = v12.i32[1];
  v14 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))), 0)), (int8x16_t)v12, v13);
  if (*(float *)&v10.i32[2] + 0.00001 <= *(float *)v10.i32)
  {
    v15 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2);
    v16 = vmulq_n_f32(vsubq_f32(v3, (float32x4_t)vdupq_laneq_s32(v10, 2)), vsubq_f32(v14, v15).f32[0]);
    *(float *)v10.i32 = *(float *)v10.i32 - *(float *)&v10.i32[2];
    v14 = vaddq_f32(v15, vdivq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.i8, 0)));
  }
  else
  {
    v14.i32[1] = v14.i32[2];
  }
  v14.i32[3] = a2.i32[3];
  v17 = vmulq_laneq_f32(v4, a2, 3);
  v17.i32[3] = a2.i32[3];
  v18 = vmlaq_laneq_f32(vmulq_n_f32(v3, 1.0 - a2.f32[3]), v14, a2, 3);
  v18.i32[3] = 1.0;
  *(_QWORD *)&result = vmlaq_laneq_f32(vmulq_n_f32(v17, 1.0 - a1.f32[3]), v18, a1, 3).u64[0];
  return result;
}

double cikernel::_saturationBlendMode_v0(float32x4_t a1, float32x4_t a2)
{
  int32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  int8x16_t v6;
  float32x4_t v7;
  float32x4_t v8;
  int8x16_t v9;
  int8x16_t v10;
  float v11;
  float32x4_t v12;
  float32x4_t v13;
  float v14;
  int8x16_t v15;
  int32x4_t v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  double v23;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  double result;

  v3 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2 = vcgtq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1));
  v3.i32[3] = a1.i32[3];
  v4 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v5 = v4;
  v5.i32[3] = a2.i32[3];
  v6.i64[0] = vrev64q_s32((int32x4_t)v3).u64[0];
  v6.i64[1] = v3.i64[1];
  v7 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(v2), 0)), 0x1FuLL)), (int8x16_t)v3, v6);
  v8 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v7, (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2))), 1)), (int8x16_t)v7, (int8x16_t)vuzp1q_s32((int32x4_t)v7, vrev64q_s32((int32x4_t)v7)));
  v9 = (int8x16_t)v8;
  v9.i32[0] = v8.i32[1];
  v10 = vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v8, v9);
  v11 = *(float *)v10.i32 + *(float *)&v10.i32[2];
  v6.i64[0] = vrev64q_s32((int32x4_t)v5).u64[0];
  v6.i64[1] = v5.i64[1];
  v12 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v5, v6);
  v13 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v12, (float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2))), 1)), (int8x16_t)v12, (int8x16_t)vuzp1q_s32((int32x4_t)v12, vrev64q_s32((int32x4_t)v12)));
  v14 = (float)(*(float *)v10.i32 + *(float *)&v10.i32[2]) * 0.5;
  v15 = (int8x16_t)v13;
  v15.i32[0] = v13.i32[1];
  v16 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v13, v15);
  v17 = (float)(*(float *)v16.i32 + *(float *)&v16.i32[2]) * 0.5;
  v18 = *(float *)v10.i32 - *(float *)&v10.i32[2];
  v19 = 2.0 - v11;
  if (v14 < 0.5)
    v19 = v11;
  v20 = v18 / fmaxf(v19, 0.000001);
  v21 = v17 + (float)(v17 * v20);
  v22 = (float)(v17 + v20) - (float)(v17 * v20);
  if (v17 > 0.5)
    v21 = v22;
  v23 = -(v21 - v17 * 2.0);
  *(float *)&v23 = v23;
  if (*(float *)&v16.i32[2] + 0.00001 <= *(float *)v16.i32)
  {
    v29 = vmulq_n_f32(vsubq_f32(v5, (float32x4_t)vdupq_laneq_s32(v16, 2)), v21 - *(float *)&v23);
    *(float *)v16.i32 = *(float *)v16.i32 - *(float *)&v16.i32[2];
    _Q6 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v23, 0), vdivq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.i8, 0)));
  }
  else
  {
    __asm { FMOV            V6.4S, #1.0 }
    _Q6.i64[0] = __PAIR64__(LODWORD(v23), LODWORD(v21));
    _Q6.i32[2] = LODWORD(v23);
  }
  _Q6.i32[3] = a2.i32[3];
  v30 = vmulq_laneq_f32(v4, a2, 3);
  v30.i32[3] = a2.i32[3];
  v31 = vmlaq_laneq_f32(vmulq_n_f32(v3, 1.0 - a2.f32[3]), _Q6, a2, 3);
  v31.i32[3] = 1.0;
  *(_QWORD *)&result = vmlaq_laneq_f32(vmulq_n_f32(v30, 1.0 - a1.f32[3]), v31, a1, 3).u64[0];
  return result;
}

double cikernel::_colorBlendMode_v0(float32x4_t a1, float32x4_t a2)
{
  int32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  int32x4_t v5;
  int8x16_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float64x2_t v9;
  int32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float64x2_t v14;
  float v15;
  int8x16_t v16;
  float v17;
  double v18;
  float v19;
  float v20;
  float v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  double result;

  v3 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2 = vcgtq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1));
  v3.i32[3] = a1.i32[3];
  v4 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v5 = (int32x4_t)v4;
  v5.i32[3] = a2.i32[3];
  v6.i64[0] = vrev64q_s32((int32x4_t)v3).u64[0];
  v6.i64[1] = v3.i64[1];
  v7 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(v2), 0)), 0x1FuLL)), (int8x16_t)v3, v6);
  v8 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v7, (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2))), 1)), (int8x16_t)v7, (int8x16_t)vuzp1q_s32((int32x4_t)v7, vrev64q_s32((int32x4_t)v7)));
  v9 = (float64x2_t)v8;
  LODWORD(v9.f64[0]) = v8.i32[1];
  v10 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v8, (int8x16_t)v9);
  v6.i64[0] = vrev64q_s32(v5).u64[0];
  v6.i64[1] = v5.i64[1];
  v11 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v5, v6);
  v12 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v11, (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2))), 1)), (int8x16_t)v11, (int8x16_t)vuzp1q_s32((int32x4_t)v11, vrev64q_s32((int32x4_t)v11)));
  v16 = (int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))), 0));
  v14 = (float64x2_t)v12;
  LODWORD(v14.f64[0]) = v12.i32[1];
  v13 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v12, (int8x16_t)v14);
  *(float *)v14.f64 = *(float *)v10.i32 + *(float *)&v10.i32[2];
  v15 = 0.5 * vaddq_f32(v13, (float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2)).f32[0];
  *(float *)v16.i32 = *(float *)v10.i32 - *(float *)&v10.i32[2];
  if ((float)((float)(*(float *)v10.i32 + *(float *)&v10.i32[2]) * 0.5) >= 0.5)
    *(float *)v14.f64 = 2.0 - (float)(*(float *)v10.i32 + *(float *)&v10.i32[2]);
  v17 = *(float *)v16.i32 / fmaxf(*(float *)v14.f64, 0.000001);
  v18 = v15;
  v19 = v15 + (float)(v15 * v17);
  v20 = (float)(v15 + v17) - (float)(v15 * v17);
  if (v15 <= 0.5)
    v21 = v19;
  else
    v21 = v20;
  v14.f64[0] = v21;
  v9.f64[0] = -(v21 - v18 * 2.0);
  *(float *)v9.f64 = v9.f64[0];
  v22 = vmulq_n_f32(vsubq_f32(v3, (float32x4_t)vdupq_laneq_s32(v10, 2)), v21 - *(float *)v9.f64);
  v23 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.i8, 0);
  v24 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v9.f64[0], 0);
  v9.f64[0] = *(float *)v9.f64 + 0.00001;
  v25 = (int8x16_t)vdivq_f32(v22, v23);
  v23.i64[0] = 0x8000000080000000;
  v23.i64[1] = 0x8000000080000000;
  v26 = vaddq_f32(v24, (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s64(vcgtq_f64(v9, v14).i64[0], 0), (int8x16_t)v23, v25));
  v26.i32[3] = a2.i32[3];
  v27 = vmulq_laneq_f32(v4, a2, 3);
  v27.i32[3] = a2.i32[3];
  v28 = vmlaq_laneq_f32(vmulq_n_f32(v3, 1.0 - a2.f32[3]), v26, a2, 3);
  v28.i32[3] = 1.0;
  *(_QWORD *)&result = vmlaq_laneq_f32(vmulq_n_f32(v27, 1.0 - a1.f32[3]), v28, a1, 3).u64[0];
  return result;
}

double cikernel::_luminosityBlendMode_v0(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  int32x4_t v3;
  int32x4_t v4;
  float32x4_t v5;
  int8x16_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float64x2_t v9;
  int32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float64x2_t v14;
  float v15;
  int8x16_t v16;
  float v17;
  double v18;
  float v19;
  float v20;
  float v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v3 = (int32x4_t)v2;
  v3.i32[3] = a1.i32[3];
  v5 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v4 = vcgtq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1));
  v5.i32[3] = a2.i32[3];
  v6.i64[0] = vrev64q_s32((int32x4_t)v5).u64[0];
  v6.i64[1] = v5.i64[1];
  v7 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(v4), 0)), 0x1FuLL)), (int8x16_t)v5, v6);
  v8 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v7, (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2))), 1)), (int8x16_t)v7, (int8x16_t)vuzp1q_s32((int32x4_t)v7, vrev64q_s32((int32x4_t)v7)));
  v9 = (float64x2_t)v8;
  LODWORD(v9.f64[0]) = v8.i32[1];
  v10 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v8, (int8x16_t)v9);
  v6.i64[0] = vrev64q_s32(v3).u64[0];
  v6.i64[1] = v3.i64[1];
  v11 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(vmovn_s32(vcgtq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))), 0)), 0x1FuLL)), (int8x16_t)v3, v6);
  v12 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v11, (float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2))), 1)), (int8x16_t)v11, (int8x16_t)vuzp1q_s32((int32x4_t)v11, vrev64q_s32((int32x4_t)v11)));
  v16 = (int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))), 0));
  v14 = (float64x2_t)v12;
  LODWORD(v14.f64[0]) = v12.i32[1];
  v13 = (float32x4_t)vbslq_s8(v16, (int8x16_t)v12, (int8x16_t)v14);
  *(float *)v14.f64 = *(float *)v10.i32 + *(float *)&v10.i32[2];
  v15 = 0.5 * vaddq_f32(v13, (float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2)).f32[0];
  *(float *)v16.i32 = *(float *)v10.i32 - *(float *)&v10.i32[2];
  if ((float)((float)(*(float *)v10.i32 + *(float *)&v10.i32[2]) * 0.5) >= 0.5)
    *(float *)v14.f64 = 2.0 - (float)(*(float *)v10.i32 + *(float *)&v10.i32[2]);
  v17 = *(float *)v16.i32 / fmaxf(*(float *)v14.f64, 0.000001);
  v18 = v15;
  v19 = v15 + (float)(v15 * v17);
  v20 = (float)(v15 + v17) - (float)(v15 * v17);
  if (v15 <= 0.5)
    v21 = v19;
  else
    v21 = v20;
  v14.f64[0] = v21;
  v9.f64[0] = -(v21 - v18 * 2.0);
  *(float *)v9.f64 = v9.f64[0];
  v22 = vmulq_n_f32(vsubq_f32(v5, (float32x4_t)vdupq_laneq_s32(v10, 2)), v21 - *(float *)v9.f64);
  v23 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v9.f64[0], 0);
  v9.f64[0] = *(float *)v9.f64 + 0.00001;
  v24 = (int8x16_t)vdivq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.i8, 0));
  v25.i64[0] = 0x8000000080000000;
  v25.i64[1] = 0x8000000080000000;
  v26 = vaddq_f32(v23, (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s64(vcgtq_f64(v9, v14).i64[0], 0), v25, v24));
  v26.i32[3] = a1.i32[3];
  v27 = vmulq_laneq_f32(v2, a1, 3);
  v27.i32[3] = a1.i32[3];
  v28 = vmlaq_laneq_f32(vmulq_n_f32(v5, 1.0 - a1.f32[3]), v26, a1, 3);
  v28.i32[3] = 1.0;
  *(_QWORD *)&result = vmlaq_laneq_f32(vmulq_n_f32(v27, 1.0 - a2.f32[3]), v28, a2, 3).u64[0];
  return result;
}

double cikernel::_linearBurnBlendMode_v0(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v10;
  double result;

  v2 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v2.i32[3] = a1.i32[3];
  v3 = vmulq_n_f32(a2, 1.0 / fmaxf(a2.f32[3], 0.00001));
  v4 = vmulq_laneq_f32(v3, a2, 3);
  v3.i32[3] = a2.i32[3];
  __asm { FMOV            V17.4S, #1.0 }
  v4.i32[3] = a2.i32[3];
  v10 = vmlaq_laneq_f32(vmulq_n_f32(v2, 1.0 - a2.f32[3]), vminnmq_f32(vmaxnmq_f32(vsubq_f32(v3, vsubq_f32(_Q17, vmulq_laneq_f32(v2, a1, 3))), (float32x4_t)0), _Q17), a2, 3);
  v10.i32[3] = 1.0;
  *(_QWORD *)&result = vmlaq_laneq_f32(vmulq_n_f32(v4, 1.0 - a1.f32[3]), v10, a1, 3).u64[0];
  return result;
}

__n64 _fillColor(CIImage *a1)
{
  __n64 result;
  _QWORD *v2;
  float *v3;
  float v4;

  result.n64_u64[0] = 0;
  if (a1)
  {
    v2 = -[CIImage _internalRepresentation](a1, "_internalRepresentation", 0.0);
    if ((*(unsigned int (**)(_QWORD *))(*v2 + 16))(v2) == 9)
    {
      v3 = (float *)v2[14];
      result.n64_u64[0] = 0;
      if (v3)
      {
        v4 = v3[9];
        result.n64_f32[0] = v3[6] * v4;
        result.n64_f32[1] = v4 * v3[7];
      }
    }
    else
    {
      return (__n64)vdupq_n_s32(0x7FC00000u).u64[0];
    }
  }
  return result;
}

double cikernel::_mix(float32x4_t a1, float32x4_t a2, float a3)
{
  double result;

  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - a3), a1, a3).u64[0];
  return result;
}

void CI::f4_s_s_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, float);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  __n128 *v17;
  __n128 *v18;
  __int128 v19;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, float))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v17 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v15);
  v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v19 = v11(a1, *v18, *v17, *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_blendWithMask(float32x4_t a1, float32x4_t a2, float32x2_t a3)
{
  double result;

  *(_QWORD *)&result = vmlaq_lane_f32(vmulq_n_f32(a2, 1.0 - a3.f32[1]), a1, a3, 1).u64[0];
  return result;
}

void CI::f4_s_s_s(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, __n128);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __n128 *v20;
  __int128 v21;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_DWORD *)(v10 + 64);
  v17 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v15);
  v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v21 = v11(a1, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

double cikernel::_blendWithMaskB0(float32x4_t a1, float32x2_t a2)
{
  double result;

  *(_QWORD *)&result = vmulq_lane_f32(a1, a2, 1).u64[0];
  return result;
}

double cikernel::_blendWithRedMask(float32x4_t a1, float32x4_t a2, float a3)
{
  double result;

  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - a3), a1, a3).u64[0];
  return result;
}

double cikernel::_blendWithRedMaskB0(float32x4_t a1, float a2)
{
  double result;

  *(_QWORD *)&result = vmulq_n_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_blendWithBlueMask(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  double result;

  *(_QWORD *)&result = vmlaq_laneq_f32(vmulq_n_f32(a2, 1.0 - a3.f32[2]), a1, a3, 2).u64[0];
  return result;
}

double cikernel::_blendWithBlueMaskB0(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vmulq_laneq_f32(a1, a2, 2).u64[0];
  return result;
}

double cikernel::_blendWithAlphaMask(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  double result;

  *(_QWORD *)&result = vmlaq_laneq_f32(vmulq_n_f32(a2, 1.0 - a3.f32[3]), a1, a3, 3).u64[0];
  return result;
}

double cikernel::_blendWithAlphaMaskB0(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vmulq_laneq_f32(a1, a2, 3).u64[0];
  return result;
}

double cikernel::_bloom(float32x4_t a1, float32x4_t a2, float a3)
{
  double result;

  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a3), vmaxnmq_f32(a1, a2), a3).u64[0];
  return result;
}

double cikernel::_gloom(float32x4_t a1, float32x4_t a2, float a3)
{
  double result;

  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a3), vminnmq_f32(a1, a2), a3).u64[0];
  return result;
}

double addPoints(void *a1, void *a2, double x, double y, double width, double height)
{
  uint64_t i;
  double v13;
  double v14;
  double v15;
  double v16;
  CGRect v18;
  CGRect v19;
  CGRect v20;
  CGRect v21;

  for (i = 0; i != 4; ++i)
  {
    objc_msgSend(a1, "valueAtIndex:", i);
    v14 = v13;
    objc_msgSend(a2, "valueAtIndex:", i);
    v16 = v15;
    if (fabs(v14 + 1.0) > 0.001 && fabs(v15 + 1.0) > 0.001)
    {
      v18.origin.x = x;
      v18.origin.y = y;
      v18.size.width = width;
      v18.size.height = height;
      if (CGRectIsNull(v18))
      {
        x = v14 + -0.5;
        y = v16 + -0.5;
        width = 1.0;
        height = 1.0;
      }
      else
      {
        v21.size.width = 1.0;
        v21.size.height = 1.0;
        v19.origin.x = x;
        v19.origin.y = y;
        v19.size.width = width;
        v19.size.height = height;
        v21.origin.x = v14 + -0.5;
        v21.origin.y = v16 + -0.5;
        v20 = CGRectUnion(v19, v21);
        x = v20.origin.x;
        y = v20.origin.y;
        width = v20.size.width;
        height = v20.size.height;
      }
    }
  }
  return x;
}

CIImage *boxBlurImage(CIImage *a1, unsigned int a2, int a3, int a4)
{
  CIKernel *v9;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  uint64_t v14;
  uint64_t *v15;
  unsigned int v16;
  void *v17;
  double v18;
  double v19;
  CIVector *v20;
  CIKernel *v21;
  CGFloat v22;
  CGFloat v23;
  CGFloat v24;
  CGFloat v25;
  CIKernel *v26;
  double v27;
  double v28;
  double v29;
  double v30;
  unsigned int v31;
  void *v32;
  double v33;
  double v34;
  CIVector *v35;
  unsigned int v36;
  int v37;
  void *v38;
  float v39;
  double v40;
  double v41;
  CIVector *v42;
  void *v43;
  double v44;
  double v45;
  CIVector *v46;
  uint64_t v47;
  _QWORD v48[6];
  _QWORD v49[6];
  _QWORD v50[6];
  _QWORD v51[4];
  int v52;
  int v53;
  _QWORD v54[4];
  int v55;
  int v56;
  _QWORD v57[4];
  int v58;
  int v59;
  _QWORD v60[4];
  int v61;
  int v62;
  _QWORD v63[4];
  int v64;
  int v65;
  _QWORD v66[4];
  int v67;
  int v68;
  _QWORD v69[3];
  _QWORD v70[2];
  _QWORD v71[2];
  _QWORD v72[2];
  _QWORD v73[2];
  _QWORD v74[2];
  _QWORD v75[2];
  _QWORD v76[2];
  _QWORD v77[2];
  _QWORD v78[3];
  CGRect v79;
  CGRect v80;
  CGRect v81;
  CGRect v82;
  CGRect v83;
  CGRect v84;
  CGRect v85;
  CGRect v86;
  CGRect v87;
  CGRect v88;
  CGRect v89;
  CGRect v90;
  CGRect v91;
  CGRect v92;
  CGRect v93;
  CGRect v94;
  CGRect v95;
  CGRect v96;
  CGRect v97;
  CGRect v98;

  v78[2] = *MEMORY[0x1E0C80C00];
  if ((int)a2 <= 1)
    return a1;
  switch(a2)
  {
    case 3u:
      v9 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_boxBlur3);
      -[CIImage extent](a1, "extent");
      v80 = CGRectInset(v79, (double)-a3, (double)-a4);
      x = v80.origin.x;
      y = v80.origin.y;
      width = v80.size.width;
      height = v80.size.height;
      v66[0] = MEMORY[0x1E0C809B0];
      v66[1] = 3221225472;
      v66[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke;
      v66[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
      v67 = a3;
      v68 = a4;
      v78[0] = a1;
      v78[1] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", (double)a3, (double)a4);
      v14 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v78, 2);
      v15 = v66;
      goto LABEL_13;
    case 5u:
      v9 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_boxBlur5);
      -[CIImage extent](a1, "extent");
      v84 = CGRectInset(v83, (double)(-2 * a3), (double)(-2 * a4));
      x = v84.origin.x;
      y = v84.origin.y;
      width = v84.size.width;
      height = v84.size.height;
      v63[0] = MEMORY[0x1E0C809B0];
      v63[1] = 3221225472;
      v63[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_2;
      v63[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
      v64 = a3;
      v65 = a4;
      v77[0] = a1;
      v77[1] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", (double)a3, (double)a4);
      v14 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v77, 2);
      v15 = v63;
      goto LABEL_13;
    case 7u:
      v9 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_boxBlur7);
      -[CIImage extent](a1, "extent");
      v86 = CGRectInset(v85, (double)(-3 * a3), (double)(-3 * a4));
      x = v86.origin.x;
      y = v86.origin.y;
      width = v86.size.width;
      height = v86.size.height;
      v60[0] = MEMORY[0x1E0C809B0];
      v60[1] = 3221225472;
      v60[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_3;
      v60[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
      v61 = a3;
      v62 = a4;
      v76[0] = a1;
      v76[1] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", (double)a3, (double)a4);
      v14 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v76, 2);
      v15 = v60;
      goto LABEL_13;
    case 9u:
      v9 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_boxBlur9);
      -[CIImage extent](a1, "extent");
      v88 = CGRectInset(v87, (double)(-4 * a3), (double)(-4 * a4));
      x = v88.origin.x;
      y = v88.origin.y;
      width = v88.size.width;
      height = v88.size.height;
      v57[0] = MEMORY[0x1E0C809B0];
      v57[1] = 3221225472;
      v57[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_4;
      v57[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
      v58 = a3;
      v59 = a4;
      v75[0] = a1;
      v75[1] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", (double)a3, (double)a4);
      v14 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v75, 2);
      v15 = v57;
      goto LABEL_13;
    case 0xBu:
      v9 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_boxBlur11);
      -[CIImage extent](a1, "extent");
      v90 = CGRectInset(v89, (double)(-5 * a3), (double)(-5 * a4));
      x = v90.origin.x;
      y = v90.origin.y;
      width = v90.size.width;
      height = v90.size.height;
      v54[0] = MEMORY[0x1E0C809B0];
      v54[1] = 3221225472;
      v54[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_5;
      v54[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
      v55 = a3;
      v56 = a4;
      v74[0] = a1;
      v74[1] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", (double)a3, (double)a4);
      v14 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v74, 2);
      v15 = v54;
      goto LABEL_13;
    case 0xDu:
      v9 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_boxBlur13);
      -[CIImage extent](a1, "extent");
      v92 = CGRectInset(v91, (double)(-6 * a3), (double)(-6 * a4));
      x = v92.origin.x;
      y = v92.origin.y;
      width = v92.size.width;
      height = v92.size.height;
      v51[0] = MEMORY[0x1E0C809B0];
      v51[1] = 3221225472;
      v51[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_6;
      v51[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
      v52 = a3;
      v53 = a4;
      v73[0] = a1;
      v73[1] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", (double)a3, (double)a4);
      v14 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v73, 2);
      v15 = v51;
LABEL_13:
      v26 = v9;
      v27 = x;
      v28 = y;
      v29 = width;
      v30 = height;
      break;
    default:
      if (a2 < 0x31 || (v16 = a2 / 7, a2 % 7))
      {
        if (a2 < 0x19 || (v31 = a2 / 5, a2 % 5))
        {
          v36 = a2 / 3;
          if (a2 == 3 * (a2 / 3))
          {
            v43 = (void *)boxBlurImage(a1, a2 / 3, a3, a4);
            v44 = (double)(int)(v36 * a3);
            v45 = (double)(int)(v36 * a4);
            v46 = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v44, v45);
            v21 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_boxCombine3);
            objc_msgSend(v43, "extent");
            v98 = CGRectInset(v97, -v44, -v45);
            v22 = v98.origin.x;
            v23 = v98.origin.y;
            v24 = v98.size.width;
            v25 = v98.size.height;
            v48[0] = MEMORY[0x1E0C809B0];
            v48[1] = 3221225472;
            v48[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_9;
            v48[3] = &__block_descriptor_48_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
            *(double *)&v48[4] = v44;
            *(double *)&v48[5] = v45;
            v70[0] = v43;
            v70[1] = v46;
            v14 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v70, 2);
            v15 = v48;
          }
          else
          {
            v37 = (a2 >> 1) | 1;
            v38 = (void *)boxBlurImage(a1, v37, a3, a4);
            v39 = floor((double)(int)a2 * 0.25 + 0.5);
            v40 = (float)((float)a3 * v39);
            v41 = (float)((float)a4 * v39);
            v42 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v40, v41, (double)v37 / (double)(int)a2, (double)v37 / (double)(int)a2 * -2.0 + 1.0);
            v21 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_boxCombine2);
            objc_msgSend(v38, "extent");
            v96 = CGRectInset(v95, -v40, -v41);
            v22 = v96.origin.x;
            v23 = v96.origin.y;
            v24 = v96.size.width;
            v25 = v96.size.height;
            v69[0] = a1;
            v69[1] = v38;
            v69[2] = v42;
            v14 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v69, 3, MEMORY[0x1E0C809B0], 3221225472, ___ZL12boxBlurImageP7CIImageiii_block_invoke_10, &__block_descriptor_48_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l, *(_QWORD *)&v40, *(_QWORD *)&v41);
            v15 = &v47;
          }
        }
        else
        {
          v32 = (void *)boxBlurImage(a1, a2 / 5, a3, a4);
          v33 = (double)(int)(v31 * a3);
          v34 = (double)(int)(v31 * a4);
          v35 = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v33, v34);
          v21 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_boxCombine5);
          objc_msgSend(v32, "extent");
          v94 = CGRectInset(v93, v33 * -2.0, v34 * -2.0);
          v22 = v94.origin.x;
          v23 = v94.origin.y;
          v24 = v94.size.width;
          v25 = v94.size.height;
          v49[0] = MEMORY[0x1E0C809B0];
          v49[1] = 3221225472;
          v49[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_8;
          v49[3] = &__block_descriptor_48_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
          *(double *)&v49[4] = v33;
          *(double *)&v49[5] = v34;
          v71[0] = v32;
          v71[1] = v35;
          v14 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v71, 2);
          v15 = v49;
        }
      }
      else
      {
        v17 = (void *)boxBlurImage(a1, v16, a3, a4);
        v18 = (double)(int)(v16 * a3);
        v19 = (double)(int)(v16 * a4);
        v20 = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v18, v19);
        v21 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_boxCombine7);
        objc_msgSend(v17, "extent");
        v82 = CGRectInset(v81, v18 * -3.0, v19 * -3.0);
        v22 = v82.origin.x;
        v23 = v82.origin.y;
        v24 = v82.size.width;
        v25 = v82.size.height;
        v50[0] = MEMORY[0x1E0C809B0];
        v50[1] = 3221225472;
        v50[2] = ___ZL12boxBlurImageP7CIImageiii_block_invoke_7;
        v50[3] = &__block_descriptor_48_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
        *(double *)&v50[4] = v18;
        *(double *)&v50[5] = v19;
        v72[0] = v17;
        v72[1] = v20;
        v14 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v72, 2);
        v15 = v50;
      }
      v26 = v21;
      v27 = v22;
      v28 = v23;
      v29 = v24;
      v30 = v25;
      break;
  }
  return -[CIKernel applyWithExtent:roiCallback:arguments:](v26, "applyWithExtent:roiCallback:arguments:", v15, v14, v27, v28, v29, v30);
}

double cikernel::_boxBlur3x3(cikernel *this, SamplerObj *a2)
{
  float32x2_t v3;
  float32x2_t v9;
  double v10;
  double v11;
  uint8x8_t v12;
  int8x16_t v13;
  float64x2_t v14;
  double v15;
  int8x16_t v16;
  float32x4_t v17;
  double v18;
  double v19;
  uint8x8_t v20;
  int8x16_t v21;
  float64x2_t v22;
  double v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x2_t v26;
  double v27;
  double v28;
  int8x16_t v29;
  double v30;
  uint8x8_t v31;
  float64x2_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x2_t v35;
  double v36;
  double v37;
  int8x16_t v38;
  double v39;
  uint8x8_t v40;
  float64x2_t v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x4_t v45;
  double result;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;

  v3 = *(float32x2_t *)CI::getDC(this);
  __asm { FMOV            V0.2S, #1.0 }
  v9 = vadd_f32(v3, _D0);
  *(float *)&v10 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v9, 1), *((float *)this + 4), v9.f32[0]);
  LODWORD(v11) = *((_DWORD *)this + 7);
  v12.i32[0] = *((_DWORD *)this + 9);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v9, 1), *(float *)&v11, v9.f32[0]);
  v9.f32[0] = *((float *)this + 6) + *(float *)&v10;
  *(float *)v14.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  v9.f32[1] = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v9, v14, v10, v11, v13, v12, v15, v16);
  v48 = v17;
  *(float32x2_t *)v17.f32 = vadd_f32(v3, (float32x2_t)0xBF0000003F800000);
  *(float *)&v18 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v17.f32, 1), *((float *)this + 4), v17.f32[0]);
  LODWORD(v19) = *((_DWORD *)this + 7);
  v20.i32[0] = *((_DWORD *)this + 9);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v17.f32, 1), *(float *)&v19, v17.f32[0]);
  v17.f32[0] = *((float *)this + 6) + *(float *)&v18;
  *(float *)v22.f64 = *(float *)v20.i32 + *(float *)v21.i32;
  v17.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v17.i64, v22, v18, v19, v21, v20, v23, v24);
  v26 = vadd_f32(v3, (float32x2_t)0x3F800000BF000000);
  *(float *)&v27 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v26, 1), *((float *)this + 4), v26.f32[0]);
  LODWORD(v28) = *((_DWORD *)this + 6);
  v29.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v30) = *((_DWORD *)this + 9);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v26, 1), *(float *)v29.i32, v26.f32[0]);
  v32 = (float64x2_t)v48;
  v49 = vaddq_f32(v48, vaddq_f32(v25, v25));
  v25.f32[0] = *(float *)&v28 + *(float *)&v27;
  *(float *)v32.f64 = *(float *)&v30 + *(float *)v31.i32;
  v25.f32[1] = *(float *)&v30 + *(float *)v31.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v25.i64, v32, v28, v27, v29, v31, v30, v33);
  v35 = vadd_f32(v3, (float32x2_t)0xBF000000BF000000);
  *(float *)&v36 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v35, 1), *((float *)this + 4), v35.f32[0]);
  LODWORD(v37) = *((_DWORD *)this + 6);
  v38.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v39) = *((_DWORD *)this + 9);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v35, 1), *(float *)v38.i32, v35.f32[0]);
  v41 = (float64x2_t)v49;
  v50 = vaddq_f32(v49, vaddq_f32(v34, v34));
  v34.f32[0] = *(float *)&v37 + *(float *)&v36;
  *(float *)v41.f64 = *(float *)&v39 + *(float *)v40.i32;
  v34.f32[1] = *(float *)&v39 + *(float *)v40.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v34.i64, v41, v37, v36, v38, v40, v39, v42);
  __asm { FMOV            V1.4S, #4.0 }
  v45 = vaddq_f32(v50, vmulq_f32(v43, _Q1));
  __asm { FMOV            V1.4S, #9.0 }
  *(_QWORD *)&result = vdivq_f32(v45, _Q1).u64[0];
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double result;

  *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)-*(_DWORD *)(a1 + 32), (double)-*(_DWORD *)(a1 + 36));
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_2(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double result;

  *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)(-2 * *(_DWORD *)(a1 + 32)), (double)(-2 * *(_DWORD *)(a1 + 36)));
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_3(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double result;

  *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)(-3 * *(_DWORD *)(a1 + 32)), (double)(-3 * *(_DWORD *)(a1 + 36)));
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_4(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double result;

  *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)(-4 * *(_DWORD *)(a1 + 32)), (double)(-4 * *(_DWORD *)(a1 + 36)));
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_5(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double result;

  *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)(-5 * *(_DWORD *)(a1 + 32)), (double)(-5 * *(_DWORD *)(a1 + 36)));
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_6(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double result;

  *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)(-6 * *(_DWORD *)(a1 + 32)), (double)(-6 * *(_DWORD *)(a1 + 36)));
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_7(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double result;

  *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&a2, *(double *)(a1 + 32) * -3.0, *(double *)(a1 + 40) * -3.0);
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_8(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double result;

  *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&a2, *(double *)(a1 + 32) * -2.0, *(double *)(a1 + 40) * -2.0);
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_9(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double result;

  *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&a2, -*(double *)(a1 + 32), -*(double *)(a1 + 40));
  return result;
}

double ___ZL12boxBlurImageP7CIImageiii_block_invoke_10(uint64_t a1, int a2, double result, double a4, double a5, double a6)
{
  if (a2)
    *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&result, -*(double *)(a1 + 32), -*(double *)(a1 + 40));
  return result;
}

double cikernel::_boxBlur3(uint64_t a1, float32x2_t a2)
{
  float32x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  float64x2_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  double result;
  float32x4_t v28;

  v4 = *(float32x2_t *)CI::getDC((CI *)a1);
  v5 = vsub_f32(v4, a2);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v10, v6, v7, v9, v8, v11, v12);
  v28 = v13;
  *(float32x2_t *)v13.f32 = vadd_f32(vmul_f32(a2, (float32x2_t)0x3F0000003F000000), v4);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v13.f32, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  __asm { FMOV            V1.4S, #3.0 }
  *(_QWORD *)&result = vdivq_f32(vaddq_f32(v28, vaddq_f32(v21, v21)), _Q1).u64[0];
  return result;
}

void CI::f4_sr_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, double);
  uint64_t v13;
  int v14;
  uint64_t v15;
  double *v16;
  __int128 v17;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, double))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_DWORD *)(v11 + 40);
  v15 = *(_QWORD *)(v11 + 32);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 56)), a2);
  v16 = (double *)(a3 + 16 * v15);
  if (v14 != 5)
    v16 = (double *)((char *)a2 + 64 * v15);
  *(double *)&v17 = v12(a4 + 80 * v13, *v16);
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

double cikernel::_boxBlur5(uint64_t a1, float32x2_t a2)
{
  float64x2_t v4;
  float32x2_t v10;
  float32x2_t v11;
  double v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  double v20;
  float64x2_t v21;
  int8x16_t v22;
  double v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x2_t v26;
  double v27;
  double v28;
  int8x16_t v29;
  double v30;
  uint8x8_t v31;
  float64x2_t v32;
  int8x16_t v33;
  float32x4_t v34;
  double result;
  float32x4_t v36;
  float32x4_t v37;
  float32x2_t v38;
  float32x4_t v39;

  v4.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  v38 = *(float32x2_t *)&v4.f64[0];
  __asm { FMOV            V0.2S, #1.5 }
  v10 = vmul_f32(a2, _D0);
  v11 = vsub_f32(*(float32x2_t *)&v4.f64[0], v10);
  *(float *)&v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v11, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v4.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v11, v4, v12, v13, v15, v14, v16, v17);
  v19 = (float32x4_t)vdupq_n_s32(0x3ECCCCCDu);
  LODWORD(v20) = *(_DWORD *)(a1 + 28);
  *(float *)v21.f64 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v38, 1), *(float *)(a1 + 16), v38.f32[0]);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v38, 1), *(float *)&v20, v38.f32[0]);
  v36 = vmulq_f32(v18, v19);
  v37 = v19;
  *((float *)v21.f64 + 1) = *(float *)v22.i32 + *(float *)&v23;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v21.f64[0], v21, v23, v20, v22, (uint8x8_t)v38, *(double *)v19.i64, v24);
  v26 = vadd_f32(v10, v38);
  *(float *)&v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v26, 1), *(float *)(a1 + 16), v26.f32[0]);
  LODWORD(v28) = *(_DWORD *)(a1 + 24);
  v29.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v30) = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v26, 1), *(float *)v29.i32, v26.f32[0]);
  v32 = (float64x2_t)v36;
  v39 = vaddq_f32(v36, vmulq_f32(v25, (float32x4_t)vdupq_n_s32(0x3E4CCCCDu)));
  v25.f32[0] = *(float *)&v28 + *(float *)&v27;
  *(float *)v32.f64 = *(float *)&v30 + *(float *)v31.i32;
  v25.f32[1] = *(float *)&v30 + *(float *)v31.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v32, v28, v27, v29, v31, v30, v33);
  *(_QWORD *)&result = vaddq_f32(v39, vmulq_f32(v34, v37)).u64[0];
  return result;
}

double cikernel::_boxBlur7(uint64_t a1, float32x2_t a2)
{
  float32x2_t v4;
  float32x2_t v10;
  float32x2_t v11;
  double v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  float64x2_t v16;
  double v17;
  int8x16_t v18;
  float32x4_t v19;
  double v20;
  double v21;
  uint8x8_t v22;
  int8x16_t v23;
  float64x2_t v24;
  double v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x2_t v28;
  double v29;
  double v30;
  int8x16_t v31;
  double v32;
  uint8x8_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float64x2_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x2_t v39;
  double v40;
  double v41;
  int8x16_t v42;
  double v43;
  uint8x8_t v44;
  float64x2_t v45;
  int8x16_t v46;
  float32x4_t v47;
  double result;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;

  v4 = *(float32x2_t *)CI::getDC((CI *)a1);
  __asm { FMOV            V0.2S, #2.5 }
  v10 = vmul_f32(a2, _D0);
  v11 = vsub_f32(v4, v10);
  *(float *)&v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v11, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v16.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v11, v16, v12, v13, v15, v14, v17, v18);
  v50 = v19;
  *(float32x2_t *)v19.f32 = vsub_f32(v4, a2);
  *(float *)&v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v19.f32, 1), *(float *)(a1 + 16), v19.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v19.f32, 1), *(float *)&v21, v19.f32[0]);
  v19.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v24.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v19.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v24, v20, v21, v23, v22, v25, v26);
  v28 = vadd_f32(vmul_f32(a2, (float32x2_t)0x3F0000003F000000), v4);
  *(float *)&v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 24);
  v31.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v32) = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)v31.i32, v28.f32[0]);
  v34.i64[0] = 0x3F0000003F000000;
  v34.i64[1] = 0x3F0000003F000000;
  v35 = vmulq_f32(v27, v34);
  v36 = (float64x2_t)v50;
  v51 = vaddq_f32(v50, v35);
  v35.f32[0] = *(float *)&v30 + *(float *)&v29;
  *(float *)v36.f64 = *(float *)&v32 + *(float *)v33.i32;
  v35.f32[1] = *(float *)&v32 + *(float *)v33.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v36, v30, v29, v31, v33, v32, v37);
  v39 = vadd_f32(v10, v4);
  *(float *)&v40 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v39, 1), *(float *)(a1 + 16), v39.f32[0]);
  LODWORD(v41) = *(_DWORD *)(a1 + 24);
  v42.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v43) = *(_DWORD *)(a1 + 36);
  *(float *)v44.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v39, 1), *(float *)v42.i32, v39.f32[0]);
  v45 = (float64x2_t)v51;
  v52 = vaddq_f32(v51, v38);
  v38.f32[0] = *(float *)&v41 + *(float *)&v40;
  *(float *)v45.f64 = *(float *)&v43 + *(float *)v44.i32;
  v38.f32[1] = *(float *)&v43 + *(float *)v44.i32;
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v45, v41, v40, v42, v44, v43, v46);
  __asm { FMOV            V1.4S, #3.5 }
  *(_QWORD *)&result = vdivq_f32(vaddq_f32(v52, v47), _Q1).u64[0];
  return result;
}

double cikernel::_boxBlur9(uint64_t a1, float32x2_t a2)
{
  float64x2_t v4;
  float32x2_t v10;
  float32x2_t v11;
  double v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  double v16;
  int8x16_t v17;
  float32x2_t v19;
  double v20;
  double v21;
  uint8x8_t v22;
  int8x16_t v23;
  float64x2_t v24;
  double v25;
  int8x16_t v26;
  float32x4_t v27;
  float64x2_t v28;
  double v29;
  double v30;
  uint8x8_t v31;
  double v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x2_t v35;
  double v36;
  double v37;
  int8x16_t v38;
  double v39;
  uint8x8_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float64x2_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x2_t v46;
  double v47;
  double v48;
  int8x16_t v49;
  double v50;
  uint8x8_t v51;
  float64x2_t v52;
  int8x16_t v53;
  float32x4_t v54;
  double result;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  int8x16_t v60;
  float32x4_t v61;

  v4.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  v60 = (int8x16_t)v4;
  __asm { FMOV            V0.2S, #3.5 }
  v10 = vmul_f32(a2, _D0);
  v11 = vsub_f32(*(float32x2_t *)&v4.f64[0], v10);
  *(float *)&v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v11, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v4.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v11, v4, v12, v13, v15, v14, v16, v17);
  v57 = _Q0;
  __asm { FMOV            V0.2S, #1.5 }
  v19 = vmul_f32(a2, *(float32x2_t *)_Q0.f32);
  *(float32x2_t *)_Q0.f32 = vsub_f32(*(float32x2_t *)v60.i8, v19);
  *(float *)&v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q0.f32, 1), *(float *)(a1 + 16), _Q0.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q0.f32, 1), *(float *)&v21, _Q0.f32[0]);
  _Q0.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v24.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  _Q0.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)_Q0.i64, v24, v20, v21, v23, v22, v25, v26);
  v28 = (float64x2_t)v57;
  v58 = vaddq_f32(v57, v27);
  LODWORD(v29) = *(_DWORD *)(a1 + 28);
  v27.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v60.i8, 1), *(float *)(a1 + 16), *(float *)v60.i32);
  LODWORD(v30) = *(_DWORD *)(a1 + 36);
  *(float *)v28.f64 = *(float *)&v30
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v60.i8, 1), *(float *)&v29, *(float *)v60.i32);
  v27.i32[1] = LODWORD(v28.f64[0]);
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v28, v29, v30, v60, v31, v32, v33);
  v35 = vadd_f32(v19, *(float32x2_t *)v60.i8);
  *(float *)&v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v35, 1), *(float *)(a1 + 16), v35.f32[0]);
  LODWORD(v37) = *(_DWORD *)(a1 + 24);
  v38.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v39) = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v35, 1), *(float *)v38.i32, v35.f32[0]);
  v41.i64[0] = 0x3F0000003F000000;
  v41.i64[1] = 0x3F0000003F000000;
  v42 = vmulq_f32(v34, v41);
  v43 = (float64x2_t)v58;
  v59 = vaddq_f32(v58, v42);
  v42.f32[0] = *(float *)&v37 + *(float *)&v36;
  *(float *)v43.f64 = *(float *)&v39 + *(float *)v40.i32;
  v42.f32[1] = *(float *)&v39 + *(float *)v40.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v42.i64, v43, v37, v36, v38, v40, v39, v44);
  v46 = vadd_f32(v10, *(float32x2_t *)v60.i8);
  *(float *)&v47 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v46, 1), *(float *)(a1 + 16), v46.f32[0]);
  LODWORD(v48) = *(_DWORD *)(a1 + 24);
  v49.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v50) = *(_DWORD *)(a1 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v46, 1), *(float *)v49.i32, v46.f32[0]);
  v52 = (float64x2_t)v59;
  v61 = vaddq_f32(v59, v45);
  v45.f32[0] = *(float *)&v48 + *(float *)&v47;
  *(float *)v52.f64 = *(float *)&v50 + *(float *)v51.i32;
  v45.f32[1] = *(float *)&v50 + *(float *)v51.i32;
  *(double *)v54.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v52, v48, v47, v49, v51, v50, v53);
  __asm { FMOV            V1.4S, #4.5 }
  *(_QWORD *)&result = vdivq_f32(vaddq_f32(v61, v54), _Q1).u64[0];
  return result;
}

double cikernel::_boxBlur11(uint64_t a1, float32x2_t a2)
{
  float32x2_t v4;
  float32x2_t v10;
  float32x2_t v11;
  double v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  float64x2_t v16;
  double v17;
  int8x16_t v18;
  float32x2_t v20;
  double v21;
  double v22;
  uint8x8_t v23;
  int8x16_t v24;
  float64x2_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x2_t v29;
  double v30;
  double v31;
  int8x16_t v32;
  double v33;
  uint8x8_t v34;
  float64x2_t v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x2_t v38;
  double v39;
  double v40;
  int8x16_t v41;
  double v42;
  uint8x8_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float64x2_t v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x2_t v49;
  double v50;
  double v51;
  int8x16_t v52;
  double v53;
  uint8x8_t v54;
  float64x2_t v55;
  int8x16_t v56;
  float32x4_t v57;
  float32x2_t v58;
  double v59;
  double v60;
  int8x16_t v61;
  double v62;
  uint8x8_t v63;
  float64x2_t v64;
  int8x16_t v65;
  float32x4_t v66;
  double result;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;

  v4 = *(float32x2_t *)CI::getDC((CI *)a1);
  __asm { FMOV            V0.2S, #4.5 }
  v10 = vmul_f32(a2, _D0);
  v11 = vsub_f32(v4, v10);
  *(float *)&v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v11, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v16.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v11, v16, v12, v13, v15, v14, v17, v18);
  v69 = _Q0;
  __asm { FMOV            V0.2S, #2.5 }
  v20 = vmul_f32(a2, *(float32x2_t *)_Q0.f32);
  *(float32x2_t *)_Q0.f32 = vsub_f32(v4, v20);
  *(float *)&v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q0.f32, 1), *(float *)(a1 + 16), _Q0.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q0.f32, 1), *(float *)&v22, _Q0.f32[0]);
  _Q0.f32[0] = *(float *)(a1 + 24) + *(float *)&v21;
  *(float *)v25.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  _Q0.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)_Q0.i64, v25, v21, v22, v24, v23, v26, v27);
  v29 = vsub_f32(v4, a2);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v29, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 24);
  v32.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v33) = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v29, 1), *(float *)v32.i32, v29.f32[0]);
  v35 = (float64x2_t)v69;
  v70 = vaddq_f32(v69, v28);
  v28.f32[0] = *(float *)&v31 + *(float *)&v30;
  *(float *)v35.f64 = *(float *)&v33 + *(float *)v34.i32;
  v28.f32[1] = *(float *)&v33 + *(float *)v34.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v35, v31, v30, v32, v34, v33, v36);
  v38 = vadd_f32(vmul_f32(a2, (float32x2_t)0x3F0000003F000000), v4);
  *(float *)&v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v38, 1), *(float *)(a1 + 16), v38.f32[0]);
  LODWORD(v40) = *(_DWORD *)(a1 + 24);
  v41.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v42) = *(_DWORD *)(a1 + 36);
  *(float *)v43.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v38, 1), *(float *)v41.i32, v38.f32[0]);
  v44.i64[0] = 0x3F0000003F000000;
  v44.i64[1] = 0x3F0000003F000000;
  v45 = vmulq_f32(v37, v44);
  v46 = (float64x2_t)v70;
  v71 = vaddq_f32(v70, v45);
  v45.f32[0] = *(float *)&v40 + *(float *)&v39;
  *(float *)v46.f64 = *(float *)&v42 + *(float *)v43.i32;
  v45.f32[1] = *(float *)&v42 + *(float *)v43.i32;
  *(double *)v48.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v46, v40, v39, v41, v43, v42, v47);
  v49 = vadd_f32(v20, v4);
  *(float *)&v50 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v49, 1), *(float *)(a1 + 16), v49.f32[0]);
  LODWORD(v51) = *(_DWORD *)(a1 + 24);
  v52.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v53) = *(_DWORD *)(a1 + 36);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v49, 1), *(float *)v52.i32, v49.f32[0]);
  v55 = (float64x2_t)v71;
  v72 = vaddq_f32(v71, v48);
  v48.f32[0] = *(float *)&v51 + *(float *)&v50;
  *(float *)v55.f64 = *(float *)&v53 + *(float *)v54.i32;
  v48.f32[1] = *(float *)&v53 + *(float *)v54.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v48.i64, v55, v51, v50, v52, v54, v53, v56);
  v58 = vadd_f32(v10, v4);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v58, 1), *(float *)(a1 + 16), v58.f32[0]);
  LODWORD(v60) = *(_DWORD *)(a1 + 24);
  v61.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v62) = *(_DWORD *)(a1 + 36);
  *(float *)v63.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v58, 1), *(float *)v61.i32, v58.f32[0]);
  v64 = (float64x2_t)v72;
  v73 = vaddq_f32(v72, v57);
  v57.f32[0] = *(float *)&v60 + *(float *)&v59;
  *(float *)v64.f64 = *(float *)&v62 + *(float *)v63.i32;
  v57.f32[1] = *(float *)&v62 + *(float *)v63.i32;
  *(double *)v66.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v57.i64, v64, v60, v59, v61, v63, v62, v65);
  __asm { FMOV            V1.4S, #5.5 }
  *(_QWORD *)&result = vdivq_f32(vaddq_f32(v73, v66), _Q1).u64[0];
  return result;
}

double cikernel::_boxBlur13(uint64_t a1, float32x2_t a2)
{
  float64x2_t v4;
  float32x2_t v10;
  float32x2_t v11;
  double v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  double v16;
  int8x16_t v17;
  float32x2_t v19;
  double v20;
  double v21;
  uint8x8_t v22;
  int8x16_t v23;
  float64x2_t v24;
  double v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x2_t v29;
  float32x2_t v30;
  double v31;
  double v32;
  int8x16_t v33;
  double v34;
  uint8x8_t v35;
  float64x2_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float64x2_t v39;
  double v40;
  double v41;
  uint8x8_t v42;
  double v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x2_t v46;
  double v47;
  double v48;
  int8x16_t v49;
  double v50;
  uint8x8_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float64x2_t v54;
  int8x16_t v55;
  float32x4_t v56;
  float32x2_t v57;
  double v58;
  double v59;
  int8x16_t v60;
  double v61;
  uint8x8_t v62;
  float64x2_t v63;
  int8x16_t v64;
  float32x4_t v65;
  float32x2_t v66;
  double v67;
  double v68;
  int8x16_t v69;
  double v70;
  uint8x8_t v71;
  float64x2_t v72;
  int8x16_t v73;
  float32x4_t v74;
  double result;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  int8x16_t v82;
  float32x4_t v83;

  v4.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  v82 = (int8x16_t)v4;
  __asm { FMOV            V0.2S, #5.5 }
  v10 = vmul_f32(a2, _D0);
  v11 = vsub_f32(*(float32x2_t *)&v4.f64[0], v10);
  *(float *)&v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v11, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v4.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v11, v4, v12, v13, v15, v14, v16, v17);
  v77 = _Q0;
  __asm { FMOV            V0.2S, #3.5 }
  v19 = vmul_f32(a2, *(float32x2_t *)_Q0.f32);
  *(float32x2_t *)_Q0.f32 = vsub_f32(*(float32x2_t *)v82.i8, v19);
  *(float *)&v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q0.f32, 1), *(float *)(a1 + 16), _Q0.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q0.f32, 1), *(float *)&v21, _Q0.f32[0]);
  _Q0.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v24.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  _Q0.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)_Q0.i64, v24, v20, v21, v23, v22, v25, v26);
  __asm { FMOV            V1.2S, #1.5 }
  v29 = vmul_f32(a2, _D1);
  v30 = vsub_f32(*(float32x2_t *)v82.i8, v29);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v30, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 24);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v34) = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v30, 1), *(float *)v33.i32, v30.f32[0]);
  v36 = (float64x2_t)v77;
  v78 = vaddq_f32(v77, v27);
  v27.f32[0] = *(float *)&v32 + *(float *)&v31;
  *(float *)v36.f64 = *(float *)&v34 + *(float *)v35.i32;
  v27.f32[1] = *(float *)&v34 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v36, v32, v31, v33, v35, v34, v37);
  v39 = (float64x2_t)v78;
  v79 = vaddq_f32(v78, v38);
  LODWORD(v40) = *(_DWORD *)(a1 + 28);
  v38.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v82.i8, 1), *(float *)(a1 + 16), *(float *)v82.i32);
  LODWORD(v41) = *(_DWORD *)(a1 + 36);
  *(float *)v39.f64 = *(float *)&v41
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v82.i8, 1), *(float *)&v40, *(float *)v82.i32);
  v38.i32[1] = LODWORD(v39.f64[0]);
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v39, v40, v41, v82, v42, v43, v44);
  v46 = vadd_f32(v29, *(float32x2_t *)v82.i8);
  *(float *)&v47 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v46, 1), *(float *)(a1 + 16), v46.f32[0]);
  LODWORD(v48) = *(_DWORD *)(a1 + 24);
  v49.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v50) = *(_DWORD *)(a1 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v46, 1), *(float *)v49.i32, v46.f32[0]);
  v52.i64[0] = 0x3F0000003F000000;
  v52.i64[1] = 0x3F0000003F000000;
  v53 = vmulq_f32(v45, v52);
  v54 = (float64x2_t)v79;
  v80 = vaddq_f32(v79, v53);
  v53.f32[0] = *(float *)&v48 + *(float *)&v47;
  *(float *)v54.f64 = *(float *)&v50 + *(float *)v51.i32;
  v53.f32[1] = *(float *)&v50 + *(float *)v51.i32;
  *(double *)v56.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v53.i64, v54, v48, v47, v49, v51, v50, v55);
  v57 = vadd_f32(v19, *(float32x2_t *)v82.i8);
  *(float *)&v58 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v57, 1), *(float *)(a1 + 16), v57.f32[0]);
  LODWORD(v59) = *(_DWORD *)(a1 + 24);
  v60.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v61) = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v57, 1), *(float *)v60.i32, v57.f32[0]);
  v63 = (float64x2_t)v80;
  v81 = vaddq_f32(v80, v56);
  v56.f32[0] = *(float *)&v59 + *(float *)&v58;
  *(float *)v63.f64 = *(float *)&v61 + *(float *)v62.i32;
  v56.f32[1] = *(float *)&v61 + *(float *)v62.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v56.i64, v63, v59, v58, v60, v62, v61, v64);
  v66 = vadd_f32(v10, *(float32x2_t *)v82.i8);
  *(float *)&v67 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v66, 1), *(float *)(a1 + 16), v66.f32[0]);
  LODWORD(v68) = *(_DWORD *)(a1 + 24);
  v69.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v70) = *(_DWORD *)(a1 + 36);
  *(float *)v71.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v66, 1), *(float *)v69.i32, v66.f32[0]);
  v72 = (float64x2_t)v81;
  v83 = vaddq_f32(v81, v65);
  v65.f32[0] = *(float *)&v68 + *(float *)&v67;
  *(float *)v72.f64 = *(float *)&v70 + *(float *)v71.i32;
  v65.f32[1] = *(float *)&v70 + *(float *)v71.i32;
  *(double *)v74.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v72, v68, v67, v69, v71, v70, v73);
  __asm { FMOV            V1.4S, #6.5 }
  *(_QWORD *)&result = vdivq_f32(vaddq_f32(v83, v74), _Q1).u64[0];
  return result;
}

double cikernel::_boxCombine7(uint64_t a1, float32x2_t a2)
{
  float64x2_t v4;
  float32x2_t v10;
  float32x2_t v11;
  double v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x2_t v19;
  double v20;
  double v21;
  uint8x8_t v22;
  int8x16_t v23;
  float64x2_t v24;
  double v25;
  int8x16_t v26;
  float32x4_t v27;
  float32x2_t v28;
  double v29;
  double v30;
  int8x16_t v31;
  double v32;
  uint8x8_t v33;
  float64x2_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float64x2_t v37;
  double v38;
  double v39;
  uint8x8_t v40;
  double v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x2_t v44;
  double v45;
  double v46;
  int8x16_t v47;
  double v48;
  uint8x8_t v49;
  float64x2_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float32x2_t v53;
  double v54;
  double v55;
  int8x16_t v56;
  double v57;
  uint8x8_t v58;
  float64x2_t v59;
  int8x16_t v60;
  float32x4_t v61;
  float32x2_t v62;
  double v63;
  double v64;
  int8x16_t v65;
  double v66;
  uint8x8_t v67;
  float64x2_t v68;
  int8x16_t v69;
  float32x4_t v70;
  double result;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int8x16_t v78;
  float32x4_t v79;

  v4.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  v78 = (int8x16_t)v4;
  __asm { FMOV            V0.2S, #3.0 }
  v10 = vmul_f32(a2, _D0);
  v11 = vsub_f32(*(float32x2_t *)&v4.f64[0], v10);
  *(float *)&v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v11, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v4.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v11, v4, v12, v13, v15, v14, v16, v17);
  v73 = v18;
  v19 = vadd_f32(a2, a2);
  *(float32x2_t *)v18.f32 = vsub_f32(*(float32x2_t *)v78.i8, v19);
  *(float *)&v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v18.f32, 1), *(float *)(a1 + 16), v18.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v18.f32, 1), *(float *)&v21, v18.f32[0]);
  v18.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v24.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v18.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v24, v20, v21, v23, v22, v25, v26);
  v28 = vsub_f32(*(float32x2_t *)v78.i8, a2);
  *(float *)&v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 24);
  v31.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v32) = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)v31.i32, v28.f32[0]);
  v34 = (float64x2_t)v73;
  v74 = vaddq_f32(v73, v27);
  v27.f32[0] = *(float *)&v30 + *(float *)&v29;
  *(float *)v34.f64 = *(float *)&v32 + *(float *)v33.i32;
  v27.f32[1] = *(float *)&v32 + *(float *)v33.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v34, v30, v29, v31, v33, v32, v35);
  v37 = (float64x2_t)v74;
  v75 = vaddq_f32(v74, v36);
  LODWORD(v38) = *(_DWORD *)(a1 + 28);
  v36.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v78.i8, 1), *(float *)(a1 + 16), *(float *)v78.i32);
  LODWORD(v39) = *(_DWORD *)(a1 + 36);
  *(float *)v37.f64 = *(float *)&v39
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v78.i8, 1), *(float *)&v38, *(float *)v78.i32);
  v36.i32[1] = LODWORD(v37.f64[0]);
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v36.i64, v37, v38, v39, v78, v40, v41, v42);
  v44 = vadd_f32(a2, *(float32x2_t *)v78.i8);
  *(float *)&v45 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v44, 1), *(float *)(a1 + 16), v44.f32[0]);
  LODWORD(v46) = *(_DWORD *)(a1 + 24);
  v47.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v48) = *(_DWORD *)(a1 + 36);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v44, 1), *(float *)v47.i32, v44.f32[0]);
  v50 = (float64x2_t)v75;
  v76 = vaddq_f32(v75, v43);
  v43.f32[0] = *(float *)&v46 + *(float *)&v45;
  *(float *)v50.f64 = *(float *)&v48 + *(float *)v49.i32;
  v43.f32[1] = *(float *)&v48 + *(float *)v49.i32;
  *(double *)v52.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v43.i64, v50, v46, v45, v47, v49, v48, v51);
  v53 = vadd_f32(v19, *(float32x2_t *)v78.i8);
  *(float *)&v54 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v53, 1), *(float *)(a1 + 16), v53.f32[0]);
  LODWORD(v55) = *(_DWORD *)(a1 + 24);
  v56.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v57) = *(_DWORD *)(a1 + 36);
  *(float *)v58.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v53, 1), *(float *)v56.i32, v53.f32[0]);
  v59 = (float64x2_t)v76;
  v77 = vaddq_f32(v76, v52);
  v52.f32[0] = *(float *)&v55 + *(float *)&v54;
  *(float *)v59.f64 = *(float *)&v57 + *(float *)v58.i32;
  v52.f32[1] = *(float *)&v57 + *(float *)v58.i32;
  *(double *)v61.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v52.i64, v59, v55, v54, v56, v58, v57, v60);
  v62 = vadd_f32(v10, *(float32x2_t *)v78.i8);
  *(float *)&v63 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v62, 1), *(float *)(a1 + 16), v62.f32[0]);
  LODWORD(v64) = *(_DWORD *)(a1 + 24);
  v65.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v66) = *(_DWORD *)(a1 + 36);
  *(float *)v67.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v62, 1), *(float *)v65.i32, v62.f32[0]);
  v68 = (float64x2_t)v77;
  v79 = vaddq_f32(v77, v61);
  v61.f32[0] = *(float *)&v64 + *(float *)&v63;
  *(float *)v68.f64 = *(float *)&v66 + *(float *)v67.i32;
  v61.f32[1] = *(float *)&v66 + *(float *)v67.i32;
  *(double *)v70.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v61.i64, v68, v64, v63, v65, v67, v66, v69);
  __asm { FMOV            V1.4S, #7.0 }
  *(_QWORD *)&result = vdivq_f32(vaddq_f32(v79, v70), _Q1).u64[0];
  return result;
}

double cikernel::_boxCombine5(uint64_t a1, float32x2_t a2)
{
  int8x16_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  float64x2_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float64x2_t v22;
  double v23;
  double v24;
  uint8x8_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x2_t v29;
  double v30;
  double v31;
  int8x16_t v32;
  double v33;
  uint8x8_t v34;
  float64x2_t v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x2_t v38;
  double v39;
  double v40;
  int8x16_t v41;
  double v42;
  uint8x8_t v43;
  float64x2_t v44;
  int8x16_t v45;
  float32x4_t v46;
  double result;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  int8x16_t v51;
  float32x4_t v52;

  v4.i64[0] = *(_QWORD *)CI::getDC((CI *)a1);
  v51 = v4;
  v5 = vadd_f32(a2, a2);
  *(float32x2_t *)v4.i8 = vsub_f32(*(float32x2_t *)v4.i8, v5);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v4.i8, 1), *(float *)(a1 + 16), *(float *)v4.i32);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v4.i8, 1), *(float *)&v7, *(float *)v4.i32);
  *(float *)v4.i32 = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  *(float *)&v4.i32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v4.i64, v10, v6, v7, v9, v8, v11, v12);
  v48 = v13;
  *(float32x2_t *)v13.f32 = vsub_f32(*(float32x2_t *)v51.i8, a2);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v13.f32, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  v22 = (float64x2_t)v48;
  v49 = vaddq_f32(v48, v21);
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v21.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v51.i8, 1), *(float *)(a1 + 16), *(float *)v51.i32);
  LODWORD(v24) = *(_DWORD *)(a1 + 36);
  *(float *)v22.f64 = *(float *)&v24
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v51.i8, 1), *(float *)&v23, *(float *)v51.i32);
  v21.i32[1] = LODWORD(v22.f64[0]);
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v22, v23, v24, v51, v25, v26, v27);
  v29 = vadd_f32(a2, *(float32x2_t *)v51.i8);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v29, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 24);
  v32.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v33) = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v29, 1), *(float *)v32.i32, v29.f32[0]);
  v35 = (float64x2_t)v49;
  v50 = vaddq_f32(v49, v28);
  v28.f32[0] = *(float *)&v31 + *(float *)&v30;
  *(float *)v35.f64 = *(float *)&v33 + *(float *)v34.i32;
  v28.f32[1] = *(float *)&v33 + *(float *)v34.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v35, v31, v30, v32, v34, v33, v36);
  v38 = vadd_f32(v5, *(float32x2_t *)v51.i8);
  *(float *)&v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v38, 1), *(float *)(a1 + 16), v38.f32[0]);
  LODWORD(v40) = *(_DWORD *)(a1 + 24);
  v41.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v42) = *(_DWORD *)(a1 + 36);
  *(float *)v43.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v38, 1), *(float *)v41.i32, v38.f32[0]);
  v44 = (float64x2_t)v50;
  v52 = vaddq_f32(v50, v37);
  v37.f32[0] = *(float *)&v40 + *(float *)&v39;
  *(float *)v44.f64 = *(float *)&v42 + *(float *)v43.i32;
  v37.f32[1] = *(float *)&v42 + *(float *)v43.i32;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v37.i64, v44, v40, v39, v41, v43, v42, v45);
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v52, v46), (float32x4_t)vdupq_n_s32(0x3E4CCCCDu)).u64[0];
  return result;
}

double cikernel::_boxCombine3(uint64_t a1, float32x2_t a2)
{
  float32x2_t *DC;
  int8x16_t v5;
  double v6;
  double v7;
  double v8;
  float64x2_t v9;
  uint8x8_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  double v26;
  uint8x8_t v27;
  float64x2_t v28;
  int8x16_t v29;
  float32x4_t v30;
  double result;
  float32x4_t v37;
  float32x2_t v38;
  float32x4_t v39;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v5.i8 = *DC;
  v38 = *DC;
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  *(float *)&v7 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v8) = *(_DWORD *)(a1 + 36);
  *(float *)v9.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v6, COERCE_FLOAT(*DC));
  HIDWORD(v7) = LODWORD(v9.f64[0]);
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v7, v9, v6, v8, v5, v10, v11, v12);
  v37 = v13;
  *(float32x2_t *)v13.f32 = vsub_f32(v38, a2);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v13.f32, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  v22 = vadd_f32(a2, v38);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 24);
  v25.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v26) = *(_DWORD *)(a1 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)v25.i32, v22.f32[0]);
  v28 = (float64x2_t)v37;
  v39 = vaddq_f32(v37, v21);
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  *(float *)v28.f64 = *(float *)&v26 + *(float *)v27.i32;
  v21.f32[1] = *(float *)&v26 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v28, v24, v23, v25, v27, v26, v29);
  __asm { FMOV            V1.4S, #3.0 }
  *(_QWORD *)&result = vdivq_f32(vaddq_f32(v39, v30), _Q1).u64[0];
  return result;
}

double cikernel::_boxCombine2(uint64_t a1, uint64_t a2, float32x4_t a3)
{
  float32x2_t *DC;
  int8x16_t v6;
  double v7;
  double v8;
  double v9;
  float64x2_t v10;
  uint8x8_t v11;
  double v12;
  int8x16_t v13;
  float32x4_t v14;
  float64x2_t v15;
  double v16;
  double v17;
  int8x16_t v18;
  double v19;
  uint8x8_t v20;
  float32x4_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  double v26;
  uint8x8_t v27;
  float64x2_t v28;
  float32x4_t v29;
  double result;
  float32x4_t v31;
  int8x16_t v32;
  float32x4_t v33;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v6.i8 = *DC;
  v32 = v6;
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  *(float *)&v8 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v9) = *(_DWORD *)(a1 + 36);
  *(float *)v10.f64 = *(float *)&v9
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v7, COERCE_FLOAT(*DC));
  HIDWORD(v8) = LODWORD(v10.f64[0]);
  *(double *)v14.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v8, v10, v7, v9, v6, v11, v12, v13);
  *(_QWORD *)&v15.f64[1] = v32.i64[1];
  *(float32x2_t *)&v15.f64[0] = vsub_f32(*(float32x2_t *)v32.i8, *(float32x2_t *)a3.f32);
  *(float *)&v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)&v15.f64[0], 1), *(float *)(a2 + 16), *(float *)v15.f64);
  LODWORD(v17) = *(_DWORD *)(a2 + 24);
  v18.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v19) = *(_DWORD *)(a2 + 36);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)&v15.f64[0], 1), *(float *)v18.i32, *(float *)v15.f64);
  v31 = vmulq_laneq_f32(v14, a3, 3);
  v14.f32[0] = *(float *)&v17 + *(float *)&v16;
  *(float *)v15.f64 = *(float *)&v19 + *(float *)v20.i32;
  v14.f32[1] = *(float *)&v19 + *(float *)v20.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v14.i64, v15, v17, v16, v18, v20, v19, (int8x16_t)a3);
  v22 = vadd_f32(*(float32x2_t *)a3.f32, *(float32x2_t *)v32.i8);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v22, 1), *(float *)(a2 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a2 + 24);
  v25.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v26) = *(_DWORD *)(a2 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v22, 1), *(float *)v25.i32, v22.f32[0]);
  v28 = (float64x2_t)v31;
  v33 = vaddq_f32(v31, vmulq_laneq_f32(v21, a3, 2));
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  *(float *)v28.f64 = *(float *)&v26 + *(float *)v27.i32;
  v21.f32[1] = *(float *)&v26 + *(float *)v27.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v21.i64, v28, v24, v23, v25, v27, v26, (int8x16_t)a3);
  *(_QWORD *)&result = vaddq_f32(v33, vmulq_laneq_f32(v29, a3, 2)).u64[0];
  return result;
}

void CI::f4_sr_sr_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, uint64_t, __n128);
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  __n128 *v17;
  __int128 v18;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, uint64_t, __n128))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_QWORD *)(v11 + 32);
  v15 = *(_DWORD *)(v11 + 64);
  v16 = *(_QWORD *)(v11 + 56);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 80)), a2);
  v17 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v16);
  *(double *)&v18 = v12(a4 + 80 * v13, a4 + 80 * v14, *v17);
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

float32x2_t cikernel::_bumpDistortion(CI *a1, int8x16_t a2)
{
  float32x2_t *DC;
  float32x2_t v3;
  float v4;
  float v5;
  BOOL v6;
  float v7;
  float v8;
  float32x2_t v11;

  DC = (float32x2_t *)CI::getDC(a1);
  v11 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  v3 = vsub_f32(v11, *DC);
  v4 = 1.0;
  v5 = 1.0 - (float)(sqrtf(vaddv_f32(vmul_f32(v3, v3))) * *(float *)a2.i32);
  if (v5 <= 1.0)
    v4 = v5;
  v6 = v5 < 0.0;
  v7 = 0.0;
  if (!v6)
    v7 = v4;
  v8 = (v7 * -2.0 + 3.0) * v7 * v7 * *(float *)&a2.i32[1] + 1.0;
  return vadd_f32(v11, vmul_n_f32(vsub_f32(*(float32x2_t *)CI::getDC((CI *)DC), v11), v8));
}

void CI::f2_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128);
  int v12;
  uint64_t v13;
  __n128 *v14;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 32)), a2);
  v14 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v14 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)(a3 + 16 * a7) = v11(a1, *v14);
}

float32x2_t cikernel::_bumpDistortionLinear(CI *a1, float32x4_t a2, __n128 a3)
{
  CI *DC;
  float32x4_t v4;
  int8x16_t v5;
  float v6;
  float v7;
  float v8;
  BOOL v9;
  float v10;
  float v11;
  float32x2_t *v12;
  float v13;

  DC = (CI *)CI::getDC(a1);
  v4.i64[0] = *(_QWORD *)DC;
  v4.i64[1] = 1065353216;
  v5 = (int8x16_t)vmulq_f32(a2, v4);
  v6 = vaddv_f32(vadd_f32(*(float32x2_t *)v5.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL)));
  v7 = 1.0;
  v8 = 1.0 - fabsf(v6);
  if (v8 <= 1.0)
    v7 = v8;
  v9 = v8 < 0.0;
  v10 = 0.0;
  if (!v9)
    v10 = v7;
  v11 = (v10 * -2.0 + 3.0) * v10 * v10 * a3.n128_f32[2] + 1.0;
  v12 = (float32x2_t *)CI::getDC(DC);
  v13 = (v11 + -1.0) * v6;
  return vadd_f32(*v12, vmul_n_f32((float32x2_t)a3.n128_u64[0], v13));
}

void CI::f2_f4_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __n128 *v16;
  __n128 *v17;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 56)), a2);
  v16 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v16 = (__n128 *)((char *)a2 + 64 * v15);
  v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)(a3 + 16 * a7) = v11(a1, *v17, *v16);
}

void sub_19222910C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19222B2C8(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x3B0], 8);
  _Unwind_Resume(a1);
}

uint64_t getFCRFaceExpressionLeftEyeClosed()
{
  void *v0;
  void *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = (void *)getFCRFaceExpressionLeftEyeClosedSymbolLoc_ptr;
  v6 = getFCRFaceExpressionLeftEyeClosedSymbolLoc_ptr;
  if (!getFCRFaceExpressionLeftEyeClosedSymbolLoc_ptr)
  {
    v1 = (void *)FaceCoreLibrary();
    v0 = dlsym(v1, "FCRFaceExpressionLeftEyeClosed");
    v4[3] = (uint64_t)v0;
    getFCRFaceExpressionLeftEyeClosedSymbolLoc_ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v3, 8);
  if (!v0)
    getFCRFaceExpressionLeftEyeClosed_cold_1();
  return *(_QWORD *)v0;
}

void sub_19222B398(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t getFCRFaceExpressionRightEyeClosed()
{
  void *v0;
  void *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = (void *)getFCRFaceExpressionRightEyeClosedSymbolLoc_ptr;
  v6 = getFCRFaceExpressionRightEyeClosedSymbolLoc_ptr;
  if (!getFCRFaceExpressionRightEyeClosedSymbolLoc_ptr)
  {
    v1 = (void *)FaceCoreLibrary();
    v0 = dlsym(v1, "FCRFaceExpressionRightEyeClosed");
    v4[3] = (uint64_t)v0;
    getFCRFaceExpressionRightEyeClosedSymbolLoc_ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v3, 8);
  if (!v0)
    getFCRFaceExpressionRightEyeClosed_cold_1();
  return *(_QWORD *)v0;
}

void sub_19222B430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t getFCRFaceExpressionSmile()
{
  void *v0;
  void *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = (void *)getFCRFaceExpressionSmileSymbolLoc_ptr;
  v6 = getFCRFaceExpressionSmileSymbolLoc_ptr;
  if (!getFCRFaceExpressionSmileSymbolLoc_ptr)
  {
    v1 = (void *)FaceCoreLibrary();
    v0 = dlsym(v1, "FCRFaceExpressionSmile");
    v4[3] = (uint64_t)v0;
    getFCRFaceExpressionSmileSymbolLoc_ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v3, 8);
  if (!v0)
    getFCRFaceExpressionSmile_cold_1();
  return *(_QWORD *)v0;
}

void sub_19222B4C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t FaceCoreLibraryCore()
{
  uint64_t v0;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = 0;
  v3 = &v2;
  v4 = 0x2020000000;
  v0 = FaceCoreLibraryCore_frameworkLibrary;
  v5 = FaceCoreLibraryCore_frameworkLibrary;
  if (!FaceCoreLibraryCore_frameworkLibrary)
  {
    v6 = xmmword_1E2EC2EA0;
    v0 = _sl_dlopen();
    v3[3] = v0;
    FaceCoreLibraryCore_frameworkLibrary = v0;
  }
  _Block_object_dispose(&v2, 8);
  return v0;
}

void sub_19222E3B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t FaceCoreLibrary()
{
  uint64_t result;
  void *v1;

  v1 = 0;
  result = FaceCoreLibraryCore();
  if (!result)
    FaceCoreLibrary_cold_1(&v1);
  return result;
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

Class __getFaceCoreDetectorClass_block_invoke(uint64_t a1)
{
  Class result;

  FaceCoreLibrary();
  result = objc_getClass("FaceCoreDetector");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getFaceCoreDetectorClass_block_invoke_cold_1();
  getFaceCoreDetectorClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getFaceCoreImageClass_block_invoke(uint64_t a1)
{
  Class result;

  FaceCoreLibrary();
  result = objc_getClass("FaceCoreImage");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getFaceCoreImageClass_block_invoke_cold_1();
  getFaceCoreImageClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getFaceCoreFaceClass_block_invoke(uint64_t a1)
{
  Class result;

  FaceCoreLibrary();
  result = objc_getClass("FaceCoreFace");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getFaceCoreFaceClass_block_invoke_cold_1();
  getFaceCoreFaceClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

char *OUTLINED_FUNCTION_0_0()
{
  return dlerror();
}

double vec2::get_xxy(vec2 *this, int32x4_t a2)
{
  a2.i64[0] = *(_QWORD *)this;
  a2.i64[0] = vzip1q_s32(a2, a2).u64[0];
  return *(double *)a2.i64;
}

double vec2::get_xyxy(vec2 *this)
{
  return *(double *)this;
}

void findBestThreeWayDivision(uint64_t a1@<X0>, uint64_t a2@<X1>, int *a3@<X2>, int *a4@<X3>, int a5@<W4>, int a6@<W5>, int a7@<W6>, uint64_t a8@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int *v34;
  float v35;
  float v36;
  uint64_t v37;
  int *v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  float v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  float v46;
  uint64_t v47;
  int *v48;
  uint64_t v49;
  float v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  int *v55;
  uint64_t v56;
  float v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int *v63;
  uint64_t v64;
  float v65;
  int v66;
  float v67;
  int *v68;
  uint64_t v69;
  int *v70;
  uint64_t v71;
  int *v72;
  int *v73;
  uint64_t v74;
  int *v75;
  uint64_t i;
  int *v77;
  uint64_t v78;
  int *v79;
  int *v80;
  uint64_t v81;
  float v82;
  BOOL v83;
  int v84;
  uint64_t v85;
  int v86;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  uint64_t v99;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  int *v104;
  uint64_t v105;
  uint64_t v106;
  int *v107;
  int *v108;
  uint64_t v109;
  __int128 v110;
  uint64_t v111;

  *(_QWORD *)(a8 + 8) = 0;
  *(_QWORD *)(a8 + 16) = 0;
  v10 = *a3;
  v11 = *a4;
  if (a7 <= 0)
    v12 = v11 - v10 + 1;
  else
    v12 = a7;
  if (a6 <= 1)
    v13 = 1;
  else
    v13 = a6;
  *(int32x2_t *)a8 = vdup_n_s32(0x7F7FFFFFu);
  BurstLoggingMessage("\n***Finding three way division:\nfirstValidImage = %d, lastValidImage = %d\n", v10, v11);
  v14 = v13 + v10 - 1;
  v15 = v11 - 2 * v13;
  if (v14 <= v15)
  {
    v16 = 0;
    v17 = 0;
    v19 = (int)(float)v12;
    v20 = a2 / 0x32 + 1;
    v21 = v10 + 1;
    v22 = (int)(v10 + 2 * v13 - 1);
    v23 = v19;
    v24 = (int)(v11 - v13);
    v25 = v14;
    v95 = v15;
    v94 = v24 - v13;
    v26 = (int)v10 * (uint64_t)(int)a2;
    v27 = (int)v20 * (uint64_t)(int)a2;
    v28 = (a2 * (unsigned __int128)0x51EB851EB851EB9uLL) >> 64;
    v29 = 4 * v28 + 4;
    v30 = (int)a2 + (int)a2 * (uint64_t)v14;
    v31 = (int)a2 + (int)a2 * v22;
    v106 = a1 + 4 * (v14 + v26) + 4;
    v32 = 4 * v27;
    v107 = (int *)(a1 + 4 * v30 + 4 * v10);
    v33 = 4 * v30 + 4 * v22 + a1 + 4;
    v92 = 4 * (v28 + v27) + 4;
    v93 = v26;
    v34 = (int *)(a1 + 4 * v31 + 4 * v10);
    v35 = 3.4028e38;
    v36 = 3.4028e38;
    v18 = a2;
    v98 = v19;
    v99 = a2;
    v96 = v24;
    v97 = v19;
    do
    {
      v104 = v34;
      v105 = v33;
      if (v25 <= v94)
      {
        v37 = v25 + 1;
        v38 = v34;
        v39 = v31;
        v40 = v22;
        v102 = v30;
        v103 = v22;
        v101 = v31;
        do
        {
          if (v25 < v23 && v40 - v25 <= v23 && ~(_DWORD)v40 + (int)v18 <= v19)
          {
            v109 = v39;
            if (v25 <= v10)
            {
              v41 = 0;
              v46 = 0.0;
              v42 = 0.0;
            }
            else
            {
              v41 = 0;
              v42 = 0.0;
              v43 = v26;
              v44 = v10;
              v45 = v21;
              v46 = 0.0;
              do
              {
                v47 = v45;
                v48 = (int *)(a1 + 4 * (v43 + v45));
                v49 = v47;
                do
                {
                  v50 = (float)*v48;
                  if (v46 < v50)
                    v46 = (float)*v48;
                  v42 = v42 + v50;
                  ++v41;
                  v49 += v20;
                  v48 = (int *)((char *)v48 + v29);
                }
                while (v49 <= v25);
                v44 += v20;
                v45 = v47 + v20;
                v43 += v27;
              }
              while (v44 < v25);
            }
            if (v37 < v40)
            {
              v51 = v30;
              v52 = v37;
              v53 = v25 + 2;
              do
              {
                v54 = v53;
                v55 = (int *)(a1 + 4 * (v51 + v53));
                v56 = v54;
                do
                {
                  v57 = (float)*v55;
                  if (v46 < v57)
                    v46 = (float)*v55;
                  v42 = v42 + v57;
                  ++v41;
                  v56 += v20;
                  v55 = (int *)((char *)v55 + v29);
                }
                while (v56 <= v40);
                v52 += v20;
                v53 = v54 + v20;
                v51 += v27;
              }
              while (v52 < v40);
            }
            v108 = v38;
            v58 = v40 + 1;
            if (v40 + 1 < v11)
            {
              v59 = v40 + 2;
              v60 = v109;
              v61 = v40 + 1;
              do
              {
                v62 = v59;
                v63 = (int *)(a1 + 4 * (v60 + v59));
                v64 = v62;
                do
                {
                  v65 = (float)*v63;
                  if (v46 < v65)
                    v46 = (float)*v63;
                  v42 = v42 + v65;
                  ++v41;
                  v64 += v20;
                  v63 = (int *)((char *)v63 + v29);
                }
                while (v64 <= v11);
                v61 += v20;
                v59 = v62 + v20;
                v60 += v27;
              }
              while (v61 < v11);
            }
            if (v25 >= v10)
            {
              v66 = 0;
              v67 = 0.0;
              v68 = (int *)v106;
              v69 = v10;
              do
              {
                v70 = v68;
                v71 = v37;
                if (v25 < v11)
                {
                  do
                  {
                    v67 = v67 + (float)*v70;
                    ++v66;
                    v71 += v20;
                    v70 = (int *)((char *)v70 + v29);
                  }
                  while (v71 <= v11);
                }
                v69 += v20;
                v68 = (int *)((char *)v68 + v32);
              }
              while (v69 <= v25);
            }
            else
            {
              v66 = 0;
              v67 = 0.0;
            }
            v72 = (int *)v33;
            v73 = v107;
            v74 = v37;
            if (v40 > v25)
            {
              do
              {
                v75 = v73;
                for (i = v10; i <= v25; v75 = (int *)((char *)v75 + v29))
                {
                  v67 = v67 + (float)*v75;
                  ++v66;
                  i += v20;
                }
                v77 = v72;
                v78 = v40 + 1;
                if (v40 < v11)
                {
                  do
                  {
                    v67 = v67 + (float)*v77;
                    ++v66;
                    v78 += v20;
                    v77 = (int *)((char *)v77 + v29);
                  }
                  while (v78 <= v11);
                }
                v74 += v20;
                v73 = (int *)((char *)v73 + v32);
                v72 = (int *)((char *)v72 + v32);
              }
              while (v74 <= v40);
            }
            v38 = v108;
            v79 = v108;
            v37 = v25 + 1;
            if (v40 < v11)
            {
              do
              {
                if (v40 >= v10)
                {
                  v80 = v79;
                  v81 = v10;
                  do
                  {
                    v67 = v67 + (float)*v80;
                    ++v66;
                    v81 += v20;
                    v80 = (int *)((char *)v80 + v29);
                  }
                  while (v81 <= v40);
                }
                v58 += v20;
                v79 = (int *)((char *)v79 + v32);
              }
              while (v58 <= v11);
            }
            v82 = (float)(v42 / (float)v41) / (float)(v67 / (float)v66);
            v83 = v82 >= v35 || v36 * 1.25 <= v46;
            v39 = v109;
            if (!v83)
            {
              BurstLoggingMessage("NEW BEST: largestInnerDistance = %f, bestRatio = %f\n", v46, v82);
              BurstLoggingMessage("Divider1 = %d, Divider2 = %d\n", v25, v40);
              v38 = v108;
              v39 = v109;
              v37 = v25 + 1;
              v31 = v101;
              v30 = v102;
              v26 = v93;
              v24 = v96;
              v23 = v97;
              v22 = v103;
              v21 = v10 + 1;
              v19 = v98;
              v18 = v99;
              *(float *)a8 = v46;
              *(float *)(a8 + 4) = v82;
              *(_DWORD *)(a8 + 8) = v10;
              *(_DWORD *)(a8 + 12) = v11;
              v16 = v40;
              v17 = v25;
              v35 = v82;
              v36 = v46;
              *(_DWORD *)(a8 + 16) = v25;
              *(_DWORD *)(a8 + 20) = v40;
            }
          }
          v40 += v20;
          v39 += v27;
          v33 += v29;
          v38 = (int *)((char *)v38 + v32);
        }
        while (v40 <= v24);
      }
      v25 += v20;
      v22 += v20;
      v30 += v27;
      v31 += v27;
      v106 += v29;
      v107 = (int *)((char *)v107 + v32);
      v33 = v105 + v92;
      v34 = &v104[(unint64_t)v32 / 4];
    }
    while (v25 <= v95);
  }
  else
  {
    v16 = 0;
    v17 = 0;
    v18 = a2;
  }
  if (a5 <= 2 && (int)v11 - (int)v10 >= 6)
  {
    if (v17 == (_DWORD)v10)
    {
      ++*a3;
      v84 = v11 - 1;
    }
    else
    {
      v84 = v11 - 1;
      if (v16 != (_DWORD)v11 - 1)
        return;
    }
    v85 = v18;
    v86 = *a4;
    if (v16 == v84)
      *a4 = --v86;
    BurstLoggingMessage("RECURSING: (%d->%d) becomes (%d->%d)\n", v10, v11, *a3, v86);
    findBestThreeWayDivision(&v110, a1, v85, a3, a4, (a5 + 1), a6, a7);
    *(_OWORD *)a8 = v110;
    *(_QWORD *)(a8 + 16) = v111;
  }
}

uint64_t updateBlurStatsOne16x16(uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4)
{
  int v6;
  int v7;
  uint64_t result;
  _BOOL4 v11;

  v6 = computeEdge1Squared16x16_NEON(a1, (uint64_t)a2, a3, a4);
  v7 = computeEdgeVal(a1, 2);
  result = computeEdgeVal(a1, 1);
  v11 = v6 > 1225 || v7 > 1225 || (int)result > 1225;
  if (a2)
  {
    if (v11 && v6 < v7 && v7 != (_DWORD)result)
    {
      ++*a2;
      if (v6 < 1225 || v7 < 1225 || (int)result <= 1224)
        ++a2[1];
    }
  }
  return result;
}

float computeRegistrationErrorStats(float *a1, float *a2, int a3, float result)
{
  float v4;
  int v5;
  float *v6;
  float v7;
  float v8;
  float v9;
  uint64_t i;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;

  if (a1)
  {
    v4 = 0.0;
    if (a3 >= 1)
    {
      v5 = a3;
      v6 = a2;
      do
      {
        v7 = *v6++;
        v4 = v4 + v7;
        --v5;
      }
      while (v5);
    }
    v8 = (float)a3;
    v9 = (float)(v4 / (float)a3) * 0.5;
    for (i = 16; i != -1; --i)
      a2[i] = v9;
    v11 = a3 - 17;
    do
      a2[v11++] = v9;
    while (v11 < a3);
    if (a3 < 1)
    {
      v15 = 0.0;
      v14 = 0.0;
      v13 = 0.0;
      v12 = 0.0;
    }
    else
    {
      v12 = 0.0;
      v13 = 0.0;
      v14 = 0.0;
      v15 = 0.0;
      do
      {
        v16 = *a2++;
        v17 = v16;
        if (v16 > v13)
          v13 = v17;
        v12 = v12 + v17;
        v15 = v15 + (float)(v17 * v17);
        v14 = v14 + (float)(v17 * (float)(v17 * v17));
        --a3;
      }
      while (a3);
    }
    v18 = v12 / v8;
    v19 = (float)(v15 / v8) - (float)(v18 * v18);
    v20 = sqrtf(v19);
    v21 = (float)((float)(v14 / v8) - (float)((float)((float)(v18 * v18) + (float)(v19 * 3.0)) * v18))
        / (float)(v19 * v20);
    *a1 = v21;
    a1[1] = v18;
    a1[2] = v20;
    a1[3] = v13;
    BurstLoggingMessage("Registration error stats: mean=%f, stdDev=%f, skewness=%f, maxValue=%f\n", v18, v20, v21, v13);
  }
  return result;
}

void computeForegroundInterval(uint64_t a1, uint64_t a2, int a3, int *a4, int *a5)
{
  int v10;
  float *v11;
  int32x2_t v12;
  float *v13;
  int v14;
  uint64_t v15;
  float v16;
  uint64_t v17;
  int32x4_t v18;
  float v19;
  uint64_t v20;
  float32x4_t v21;
  int32x4_t v22;
  float *v23;
  float v24;
  float v25;
  float v26;
  int v27;
  int v28;
  float v29;
  float *v30;
  uint64_t v31;
  int *v32;
  int v33;
  int v34;
  int v35;
  float v36;
  float *v37;
  float v38;
  int v39;
  int v40;
  uint64_t v41;
  int v42;

  if (!a1 || !a4 || !a5)
    return;
  v10 = a3 - 1;
  v11 = (float *)malloc_type_malloc(8 * a3, 0x100004000313F17uLL);
  if (v11)
  {
    v13 = v11;
    if (a3 < 37)
    {
      v14 = 0;
    }
    else
    {
      v14 = 0;
      v15 = a2 + 8;
      v16 = 0.0;
      v17 = 18;
      v18.i64[0] = 0x100000001;
      v18.i64[1] = 0x100000001;
      v19 = 0.0;
      do
      {
        v20 = 0;
        v12.i32[0] = *(_DWORD *)(a2 + 4 * v17);
        v21 = (float32x4_t)vdupq_lane_s32(v12, 0);
        v22.i64[0] = 0x100000001;
        v22.i64[1] = 0x100000001;
        do
        {
          v22 = (int32x4_t)vbicq_s8((int8x16_t)v22, (int8x16_t)vcgtq_f32(*(float32x4_t *)(v15 + v20), v21));
          v20 += 16;
        }
        while (v20 != 128);
        if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(v22, v18)))) & 1) == 0)
        {
          v23 = &v11[2 * v14];
          *v23 = *(float *)v12.i32;
          *((_DWORD *)v23 + 1) = v17;
          ++v14;
          v24 = *(float *)(a2 + 4 * v17);
          v19 = v19 + v24;
          v16 = v16 + (float)(v24 * v24);
        }
        ++v17;
        v15 += 4;
      }
      while (v17 != a3 - 18);
      if (v14)
      {
        v25 = v19 / (float)v14;
        v26 = sqrtf((float)(v16 / (float)v14) - (float)(v25 * v25));
LABEL_17:
        qsort(v11, v14, 8uLL, (int (__cdecl *)(const void *, const void *))comparePeaks);
        if (*v13 >= 5000.0)
        {
          if ((float)(v25 + (float)(v26 * 0.22)) >= 3000.0)
            v29 = v25 + (float)(v26 * 0.22);
          else
            v29 = 3000.0;
          BurstLoggingMessage("Peak rejection threshold = %f (mean = %f, std = %f)\n", v29, v25, v26);
          if (v14 < 2)
          {
            LODWORD(v31) = 1;
          }
          else
          {
            v30 = v13 + 2;
            v31 = 1;
            while (*v30 >= v29)
            {
              ++v31;
              v30 += 2;
              if (v14 == v31)
              {
                LODWORD(v31) = v14;
                break;
              }
            }
          }
          v27 = 0;
          if (v31 <= 1)
            v31 = 1;
          else
            v31 = v31;
          v32 = (int *)(v13 + 1);
          v28 = a3;
          do
          {
            v34 = *v32;
            v32 += 2;
            v33 = v34;
            if (v34 < v28)
              v28 = v33;
            if (v33 > v27)
              v27 = v33;
            --v31;
          }
          while (v31);
          BurstLoggingMessage("Starting ROI construction at %d->%d\n", v28, v27);
        }
        else
        {
          v27 = a3 - 17;
          BurstLoggingMessage("Insufficient peak error for ROI computation %f (threshold %f)\n", *v13, 5000.0);
          v28 = 17;
        }
        free(v13);
        goto LABEL_39;
      }
    }
    v26 = 0.0;
    v25 = 3.4028e38;
    goto LABEL_17;
  }
  v27 = 0;
  v28 = a3;
LABEL_39:
  v35 = 0;
  v36 = *(float *)(a1 + 4) + (float)(*(float *)(a1 + 8) * 0.5);
  if (v36 < 3000.0)
    v36 = 3000.0;
  v37 = (float *)(a2 + 4 * (v28 - 1));
  while (v28 >= 18)
  {
    v38 = *v37--;
    if (v38 < v36)
      ++v35;
    else
      v35 = 0;
    --v28;
    if (v35 >= 4)
    {
      v39 = v28 - 10;
      goto LABEL_49;
    }
  }
  v39 = 0;
LABEL_49:
  v40 = 0;
  *a4 = v39;
  v41 = v27 + 1;
  while (v41 < a3 - 17)
  {
    if (*(float *)(a2 + 4 * v41) < v36)
      ++v40;
    else
      v40 = 0;
    ++v27;
    ++v41;
    if (v40 >= 4)
      goto LABEL_57;
  }
  v27 = v10;
LABEL_57:
  v42 = v27 + 10;
  if (v27 + 10 >= a3)
    v42 = v10;
  *a5 = v42;
}

uint64_t compareFloats(float *a1, float *a2)
{
  if (*a1 > *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 < *a2;
}

uint64_t compareGridElements(uint64_t a1, uint64_t a2)
{
  float v2;
  float v3;

  v2 = *(float *)(a1 + 4);
  v3 = *(float *)(a2 + 4);
  if (v2 > v3)
    return 0xFFFFFFFFLL;
  else
    return v2 < v3;
}

uint64_t computeEdgeVal(uint64_t a1, int a2)
{
  int v4;
  int v5;
  int v6;
  uint64_t result;

  v4 = computeEdgeValOne8x8(a1, a2);
  v5 = computeEdgeValOne8x8(a1 + 16, a2);
  if (v5 > v4)
    v4 = v5;
  v6 = computeEdgeValOne8x8(a1 + 512, a2);
  if (v6 > v4)
    v4 = v6;
  LODWORD(result) = computeEdgeValOne8x8(a1 + 528, a2);
  if ((int)result <= v4)
    return v4;
  else
    return result;
}

uint64_t computeEdgeValOne8x8(uint64_t a1, int a2)
{
  int v2;
  uint64_t v3;
  float v4;
  __int16 *v5;
  int v6;
  uint64_t v7;
  __int16 *v8;
  int v9;

  if (a2 < 1)
    return 0;
  v2 = 0;
  v4 = 0.0;
  v5 = (__int16 *)(a1 + 2 * a2);
  do
  {
    v6 = a2;
    v7 = a1;
    v8 = v5;
    do
    {
      v3 = (32 * a2);
      v9 = *(__int16 *)(v7 + 2 * v3) * *(__int16 *)(v7 + 2 * v3) + v8[v3] * v8[v3] + *v8 * *v8;
      if (v4 < (float)v9)
        v4 = (float)v9;
      ++v8;
      v7 += 2;
      --v6;
    }
    while (v6);
    ++v2;
    v5 += 32;
    a1 += 64;
  }
  while (v2 != a2);
  return (int)v4;
}

uint64_t comparePeaks(float *a1, float *a2)
{
  if (*a1 > *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 < *a2;
}

void *BurstLoggingSetCallback(void *result, uint64_t a2)
{
  gBurstLoggingCallback = result;
  gBurstLoggingUserData = a2;
  return result;
}

uint64_t BurstLoggingSetFileHandle(uint64_t result)
{
  gBurstLoggingFileHandle = result;
  return result;
}

void BurstLoggingMessage(char *__format, ...)
{
  int v2;
  size_t v3;
  char *v4;
  char __str;
  va_list v6;
  va_list va;

  va_start(va, __format);
  if (__format)
  {
    va_copy(v6, va);
    v2 = vsnprintf(&__str, 1uLL, __format, va);
    if (v2 > 0)
    {
      v3 = (v2 + 1);
      v4 = (char *)malloc_type_malloc(v3, 0xB8EEE3FBuLL);
      vsnprintf(v4, v3, __format, va);
      if (v4)
      {
        if (gBurstLoggingCallback)
          gBurstLoggingCallback(gBurstLoggingUserData, v4);
        if (gBurstLoggingFileHandle)
          fputs(v4, (FILE *)gBurstLoggingFileHandle);
        free(v4);
      }
    }
  }
}

double cikernel::_white(int32x4_t a1)
{
  double result;

  *(_QWORD *)&result = vdupq_laneq_s32(a1, 3).u64[0];
  return result;
}

void CI::f4_s(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128);
  int v12;
  uint64_t v13;
  __n128 *v14;
  __int128 v15;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 32)), a2);
  v14 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v14 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v15 = v11(a1, *v14);
  *(_OWORD *)(a3 + 16 * a7) = v15;
}

double cikernel::_cmyk_convert(int32x4_t a1, double a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v10;
  double result;

  v2 = (float32x4_t)vdupq_laneq_s32(a1, 3);
  a1.i32[3] = 0;
  v3 = vmaxnmq_f32((float32x4_t)a1, (float32x4_t)0);
  v3.i32[3] = 0;
  v2.i32[3] = 0;
  v4 = vminnmq_f32(v3, v2);
  __asm { FMOV            V2.4S, #1.0 }
  v10 = vsubq_f32(_Q2, v4);
  _Q2.f32[0] = vmuls_lane_f32(fminf(fminf(v10.f32[0], v10.f32[1]), v10.f32[2]), *(float32x2_t *)&a2, 1);
  *(float *)&a2 = (float)(_Q2.f32[0] * _Q2.f32[0]) * *(float *)&a2;
  *(_QWORD *)&result = vsubq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0)).u64[0];
  return result;
}

void CI::f4_s_f2(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, double);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  double *v16;
  __n128 *v17;
  __int128 v18;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, double))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 56)), a2);
  v16 = (double *)(a3 + 16 * v15);
  if (v14 != 5)
    v16 = (double *)((char *)a2 + 64 * v15);
  v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v18 = v11(a1, *v17, *v16);
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_cmyk_cyan(CI *a1, float32x4_t a2, double a3, float32x2_t a4, int8x16_t a5, float a6)
{
  float32x2_t v7;
  float32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float v13;
  int32x2_t v14;
  float v15;
  float v16;
  float v18;
  float32x4_t v19;
  double result;

  v7 = a4;
  v8 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a4);
  v9 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, v8);
  v10 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v8);
  v11 = vadd_f32(v7, vadd_f32((float32x2_t)vzip1_s32(v9, v10), (float32x2_t)vzip2_s32(v9, v10)));
  v12 = vmul_f32(vminnm_f32(vsub_f32(v11, vrndm_f32(v11)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)), (float32x2_t)vdup_n_s32(0x40C90FDBu));
  a5.i32[1] = v12.i32[1];
  v7.i32[0] = sinf(v12.f32[0]);
  v13 = (float)(v7.f32[0] + sinf(*(float *)&a5.i32[1])) * 0.25 * (-1.0 / a6 + 0.995) + 0.5;
  v14.i32[1] = HIDWORD(a3);
  v15 = (float)((float)(*(float *)&a3 - v13) * a6) + 0.5;
  if (v15 <= 1.0)
    v16 = v15;
  else
    v16 = 1.0;
  _NF = v15 < 0.0;
  v18 = 0.0;
  if (!_NF)
    v18 = v16;
  *(float *)v14.i32 = 1.0 - v18;
  v19 = vmaxnmq_f32(vmulq_f32(a2, vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v14, 0), (float32x4_t)xmmword_192491BE0, v18)), (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  *(_QWORD *)&result = vminnmq_f32(v19, _Q1).u64[0];
  return result;
}

void CI::f4_s_s_f2_f4_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, double, __n128, float);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  __n128 *v20;
  double *v21;
  __n128 *v22;
  __n128 *v23;
  __int128 v24;
  int v25;
  int v26;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, double, __n128, float))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  v19 = *(_QWORD *)(v9 + 104);
  if (*(_BYTE *)(a1 + 64))
  {
    v25 = *(_DWORD *)(v9 + 88);
    v26 = *(_DWORD *)(v9 + 64);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
    v17 = v25;
    v15 = v26;
  }
  v20 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v18);
  v21 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v21 = (double *)((char *)a2 + 64 * v16);
  v22 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v22 = (__n128 *)((char *)a2 + 64 * v14);
  v23 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v23 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v24 = v10(*v23, *v22, *v21, *v20, *((float *)a2 + 16 * v19));
  *(_OWORD *)(a3 + 16 * a7) = v24;
}

double cikernel::_cmyk_magenta(CI *a1, float32x4_t a2, double a3, float32x2_t a4, int8x16_t a5, float a6)
{
  float32x2_t v7;
  float32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float v13;
  int32x2_t v14;
  float v15;
  float v16;
  float v18;
  float32x4_t v19;
  double result;
  float v26;

  v26 = *((float *)&a3 + 1);
  v7 = a4;
  v8 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a4);
  v9 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, v8);
  v10 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v8);
  v11 = vadd_f32(v7, vadd_f32((float32x2_t)vzip1_s32(v9, v10), (float32x2_t)vzip2_s32(v9, v10)));
  v12 = vmul_f32(vminnm_f32(vsub_f32(v11, vrndm_f32(v11)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)), (float32x2_t)vdup_n_s32(0x40C90FDBu));
  a5.i32[1] = v12.i32[1];
  v7.i32[0] = sinf(v12.f32[0]);
  v13 = (float)(v7.f32[0] + sinf(*(float *)&a5.i32[1])) * 0.25 * (-1.0 / a6 + 0.995) + 0.5;
  *(float *)&v14.i32[1] = v26;
  v15 = (float)((float)(v26 - v13) * a6) + 0.5;
  if (v15 <= 1.0)
    v16 = v15;
  else
    v16 = 1.0;
  _NF = v15 < 0.0;
  v18 = 0.0;
  if (!_NF)
    v18 = v16;
  *(float *)v14.i32 = 1.0 - v18;
  v19 = vmaxnmq_f32(vmulq_f32(a2, vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v14, 0), (float32x4_t)xmmword_192491BF0, v18)), (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  *(_QWORD *)&result = vminnmq_f32(v19, _Q1).u64[0];
  return result;
}

double cikernel::_cmyk_yellow(CI *a1, float32x4_t a2, __n128 a3, float32x2_t a4, int8x16_t a5, float a6)
{
  float32x2_t v7;
  float32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float v13;
  int32x2_t v14;
  float v15;
  float v16;
  float v18;
  float32x4_t v19;
  double result;

  v7 = a4;
  v8 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a4);
  v9 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, v8);
  v10 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v8);
  v11 = vadd_f32(v7, vadd_f32((float32x2_t)vzip1_s32(v9, v10), (float32x2_t)vzip2_s32(v9, v10)));
  v12 = vmul_f32(vminnm_f32(vsub_f32(v11, vrndm_f32(v11)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)), (float32x2_t)vdup_n_s32(0x40C90FDBu));
  a5.i32[1] = v12.i32[1];
  v7.i32[0] = sinf(v12.f32[0]);
  v13 = (float)(v7.f32[0] + sinf(*(float *)&a5.i32[1])) * 0.25 * (-1.0 / a6 + 0.995) + 0.5;
  v14.i32[1] = a3.n128_i32[1];
  v15 = (float)((float)(a3.n128_f32[2] - v13) * a6) + 0.5;
  if (v15 <= 1.0)
    v16 = v15;
  else
    v16 = 1.0;
  _NF = v15 < 0.0;
  v18 = 0.0;
  if (!_NF)
    v18 = v16;
  *(float *)v14.i32 = 1.0 - v18;
  v19 = vmaxnmq_f32(vmulq_f32(a2, vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v14, 0), (float32x4_t)xmmword_192491C00, v18)), (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  *(_QWORD *)&result = vminnmq_f32(v19, _Q1).u64[0];
  return result;
}

double cikernel::_cmyk_black(CI *a1, float32x4_t a2, __n128 a3, float32x2_t a4, int8x16_t a5, float a6)
{
  float32x2_t v7;
  float32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float v13;
  int32x2_t v14;
  float v15;
  float v16;
  float v18;
  float32x4_t v19;
  double result;

  v7 = a4;
  v8 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a4);
  v9 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, v8);
  v10 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v8);
  v11 = vadd_f32(v7, vadd_f32((float32x2_t)vzip1_s32(v9, v10), (float32x2_t)vzip2_s32(v9, v10)));
  v12 = vmul_f32(vminnm_f32(vsub_f32(v11, vrndm_f32(v11)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)), (float32x2_t)vdup_n_s32(0x40C90FDBu));
  a5.i32[1] = v12.i32[1];
  v7.i32[0] = sinf(v12.f32[0]);
  v13 = (float)(v7.f32[0] + sinf(*(float *)&a5.i32[1])) * 0.25 * (-1.0 / a6 + 0.995) + 0.5;
  v14.i32[1] = a3.n128_i32[1];
  v15 = (float)((float)(a3.n128_f32[3] - v13) * a6) + 0.5;
  if (v15 <= 1.0)
    v16 = v15;
  else
    v16 = 1.0;
  _NF = v15 < 0.0;
  v18 = 0.0;
  if (!_NF)
    v18 = v16;
  *(float *)v14.i32 = 1.0 - v18;
  v19 = vmaxnmq_f32(vmulq_f32(a2, vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v14, 0), (float32x4_t)xmmword_19248E050, v18)), (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  *(_QWORD *)&result = vminnmq_f32(v19, _Q1).u64[0];
  return result;
}

double cikernel::_radialLensDistortion(uint64_t a1, uint64_t a2, float64x2_t a3)
{
  float v5;
  float v6;
  float32x2_t *DC;
  float64x2_t v8;
  float32x2_t v9;
  double v10;
  int8x16_t v11;
  double v12;
  uint8x8_t v13;
  double v14;
  int8x16_t v15;
  __int128 v16;
  CI *v17;
  float32x2_t *v18;
  float64x2_t v19;
  double v20;
  float32x2_t v21;
  float32x2_t v22;
  double v23;
  uint8x8_t v24;
  int8x16_t v25;
  double v26;
  int8x16_t v27;
  __int128 v29;

  v5 = *(float *)&a3.f64[1];
  v6 = *((float *)&a3.f64[1] + 1) + -1.0;
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v8 = a3;
  v9 = vsub_f32(*(float32x2_t *)&a3.f64[0], *DC);
  *(float *)&v10 = (float)((float)(v6 * sqrtf(vaddv_f32(vmul_f32(v9, v9)))) / v5) + 0.5;
  v11.i32[0] = *(_DWORD *)(a2 + 28);
  v9.f32[0] = *(float *)(a2 + 24)
            + (float)((float)(*(float *)(a2 + 20) * 0.5) + (float)(*(float *)&v10 * *(float *)(a2 + 16)));
  LODWORD(v12) = *(_DWORD *)(a2 + 32);
  v13.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v8.f64 = *(float *)v13.i32
                   + (float)((float)(*(float *)&v12 * 0.5) + (float)(*(float *)&v10 * *(float *)v11.i32));
  v9.f32[1] = *(float *)v8.f64;
  *(double *)&v16 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v9, v8, v10, v12, v11, v13, v14, v15);
  v29 = v16;
  v18 = (float32x2_t *)CI::getDC(v17);
  v19.f64[1] = *((float64_t *)&v29 + 1);
  HIDWORD(v20) = HIDWORD(a3.f64[0]);
  v21 = vsub_f32(*v18, *(float32x2_t *)&a3.f64[0]);
  *(float32x2_t *)&v19.f64[0] = vmul_n_f32(v21, *(float *)&v29);
  v22 = vadd_f32(*(float32x2_t *)&a3.f64[0], vadd_f32(v21, *(float32x2_t *)&v19.f64[0]));
  *(float *)&v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)&v23, v22.f32[0]);
  v22.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v19.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v22.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  return CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v22, v19, v20, v23, v25, v24, v26, v27);
}

double cikernel::_cheapBlur(uint64_t a1, float32x2_t a2)
{
  float32x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  float32x2_t v11;
  float64x2_t v12;
  double v13;
  int8x16_t v14;
  float32x4_t v15;
  double v16;
  double v17;
  uint8x8_t v18;
  int8x16_t v19;
  float64x2_t v20;
  double v21;
  int8x16_t v22;
  float32x4_t v23;
  double v24;
  double v25;
  uint8x8_t v26;
  int8x16_t v27;
  float64x2_t v28;
  double v29;
  int8x16_t v30;
  float32x4_t v31;
  double v32;
  double v33;
  uint8x8_t v34;
  int8x16_t v35;
  float64x2_t v36;
  double v37;
  int8x16_t v38;
  float32x4_t v39;
  CI *v40;
  float32x2_t *DC;
  double v42;
  double v43;
  uint8x8_t v44;
  int8x16_t v45;
  double v46;
  float64x2_t v47;
  double v48;
  int8x16_t v49;
  float32x4_t v50;
  double result;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;

  v4 = *(float32x2_t *)CI::getDC((CI *)a1);
  v5 = vmul_f32(a2, (float32x2_t)0x40800000BF800000);
  v6 = vadd_f32(v5, v4);
  *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v6, 1), *(float *)(a1 + 16), v6.f32[0]);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v6, 1), *(float *)&v8, v6.f32[0]);
  v11 = vmul_f32(a2, (float32x2_t)0x3F80000040800000);
  v6.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v12.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v12, v7, v8, v10, v9, v13, v14);
  v55 = v15;
  *(float32x2_t *)v15.f32 = vadd_f32(v11, v4);
  *(float *)&v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v15.f32, 1), *(float *)(a1 + 16), v15.f32[0]);
  LODWORD(v17) = *(_DWORD *)(a1 + 28);
  v18.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v15.f32, 1), *(float *)&v17, v15.f32[0]);
  v15.f32[0] = *(float *)(a1 + 24) + *(float *)&v16;
  *(float *)v20.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v15.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v15.i64, v20, v16, v17, v19, v18, v21, v22);
  v54 = v23;
  *(float32x2_t *)v23.f32 = vsub_f32(v4, v11);
  *(float *)&v24 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v23.f32, 1), *(float *)(a1 + 16), v23.f32[0]);
  LODWORD(v25) = *(_DWORD *)(a1 + 28);
  v26.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v23.f32, 1), *(float *)&v25, v23.f32[0]);
  v23.f32[0] = *(float *)(a1 + 24) + *(float *)&v24;
  *(float *)v28.f64 = *(float *)v26.i32 + *(float *)v27.i32;
  v23.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v23.i64, v28, v24, v25, v27, v26, v29, v30);
  v53 = v31;
  *(float32x2_t *)v31.f32 = vsub_f32(v4, v5);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v31.f32, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v33) = *(_DWORD *)(a1 + 28);
  v34.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v31.f32, 1), *(float *)&v33, v31.f32[0]);
  v31.f32[0] = *(float *)(a1 + 24) + *(float *)&v32;
  *(float *)v36.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v31.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v31.i64, v36, v32, v33, v35, v34, v37, v38);
  v52 = v39;
  DC = (float32x2_t *)CI::getDC(v40);
  *(float *)&v42 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v43) = *(_DWORD *)(a1 + 28);
  v44.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v43, COERCE_FLOAT(*DC));
  *(float *)&v46 = *(float *)(a1 + 24) + *(float *)&v42;
  *(float *)v47.f64 = *(float *)v44.i32 + *(float *)v45.i32;
  *((float *)&v46 + 1) = *(float *)v44.i32 + *(float *)v45.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v46, v47, v42, v43, v45, v44, v48, v49);
  *(_QWORD *)&result = vaddq_f32(vmulq_f32(vaddq_f32(v53, vaddq_f32(vaddq_f32(v55, v54), v52)), (float32x4_t)vdupq_n_s32(0x3E51745Du)), vmulq_f32(v50, (float32x4_t)vdupq_n_s32(0x3E3A2E8Cu))).u64[0];
  return result;
}

double cikernel::_lerp(float32x4_t a1, float32x4_t a2, float a3)
{
  double result;

  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - a3), a1, a3).u64[0];
  return result;
}

double cikernel::_box4(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float32x2_t v9;
  float32x2_t v11;
  double v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  double v19;
  double v20;
  uint8x8_t v21;
  int8x16_t v22;
  float64x2_t v23;
  double v24;
  int8x16_t v25;
  float32x4_t v26;
  double v27;
  double v28;
  uint8x8_t v29;
  int8x16_t v30;
  float64x2_t v31;
  double v32;
  int8x16_t v33;
  double v35;
  double v36;
  uint8x8_t v37;
  int8x16_t v38;
  float64x2_t v39;
  double v40;
  int8x16_t v41;
  float32x4_t v42;
  double result;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;

  DC = (float32x2_t *)CI::getDC(this);
  __asm { FMOV            V1.2S, #4.0 }
  v9 = vmul_f32(*DC, *(float32x2_t *)&_Q1.f64[0]);
  __asm { FMOV            V0.2S, #-1.0 }
  v11 = vadd_f32(v9, _D0);
  *(float *)&v12 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v11, 1), *((float *)this + 4), v11.f32[0]);
  LODWORD(v13) = *((_DWORD *)this + 7);
  v14.i32[0] = *((_DWORD *)this + 9);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *((float *)this + 6) + *(float *)&v12;
  *(float *)_Q1.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v11, _Q1, v12, v13, v15, v14, v16, v17);
  v47 = v18;
  *(float32x2_t *)v18.f32 = vadd_f32(v9, (float32x2_t)0x3F800000BF800000);
  *(float *)&v19 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v18.f32, 1), *((float *)this + 4), v18.f32[0]);
  LODWORD(v20) = *((_DWORD *)this + 7);
  v21.i32[0] = *((_DWORD *)this + 9);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v18.f32, 1), *(float *)&v20, v18.f32[0]);
  v18.f32[0] = *((float *)this + 6) + *(float *)&v19;
  *(float *)v23.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  v18.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v18.i64, v23, v19, v20, v22, v21, v24, v25);
  v46 = v26;
  *(float32x2_t *)v26.f32 = vadd_f32(v9, (float32x2_t)0xBF8000003F800000);
  *(float *)&v27 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v26.f32, 1), *((float *)this + 4), v26.f32[0]);
  LODWORD(v28) = *((_DWORD *)this + 7);
  v29.i32[0] = *((_DWORD *)this + 9);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v26.f32, 1), *(float *)&v28, v26.f32[0]);
  v26.f32[0] = *((float *)this + 6) + *(float *)&v27;
  *(float *)v31.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v26.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v26.i64, v31, v27, v28, v30, v29, v32, v33);
  v45 = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  *(float32x2_t *)_Q0.f32 = vadd_f32(v9, *(float32x2_t *)_Q0.f32);
  *(float *)&v35 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v36) = *((_DWORD *)this + 7);
  v37.i32[0] = *((_DWORD *)this + 9);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v36, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v35;
  *(float *)v39.f64 = *(float *)v37.i32 + *(float *)v38.i32;
  _Q0.f32[1] = *(float *)v37.i32 + *(float *)v38.i32;
  *(double *)v42.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v39, v35, v36, v38, v37, v40, v41);
  __asm { FMOV            V1.4S, #0.25 }
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v47, v46), v45), v42), _Q1).u64[0];
  return result;
}

double cikernel::_box6(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float32x2_t v9;
  float32x2_t v10;
  double v11;
  double v12;
  uint8x8_t v13;
  int8x16_t v14;
  double v15;
  int8x16_t v16;
  float32x4_t v17;
  double v18;
  double v19;
  uint8x8_t v20;
  int8x16_t v21;
  float64x2_t v22;
  double v23;
  int8x16_t v24;
  float32x4_t v25;
  double v26;
  double v27;
  uint8x8_t v28;
  int8x16_t v29;
  float64x2_t v30;
  double v31;
  int8x16_t v32;
  float32x4_t v33;
  double v34;
  double v35;
  uint8x8_t v36;
  int8x16_t v37;
  float64x2_t v38;
  double v39;
  int8x16_t v40;
  float32x4_t v41;
  double v42;
  double v43;
  uint8x8_t v44;
  int8x16_t v45;
  float64x2_t v46;
  double v47;
  int8x16_t v48;
  float32x4_t v49;
  double v50;
  double v51;
  uint8x8_t v52;
  int8x16_t v53;
  float64x2_t v54;
  double v55;
  int8x16_t v56;
  float32x4_t v57;
  double v58;
  double v59;
  uint8x8_t v60;
  int8x16_t v61;
  float64x2_t v62;
  double v63;
  int8x16_t v64;
  float32x4_t v65;
  double v66;
  double v67;
  uint8x8_t v68;
  int8x16_t v69;
  float64x2_t v70;
  double v71;
  int8x16_t v72;
  float32x4_t v73;
  double v74;
  double v75;
  uint8x8_t v76;
  int8x16_t v77;
  float64x2_t v78;
  double v79;
  int8x16_t v80;
  float32x4_t v81;
  double result;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;

  DC = (float32x2_t *)CI::getDC(this);
  __asm { FMOV            V1.2S, #6.0 }
  v9 = vmul_f32(*DC, *(float32x2_t *)&_Q1.f64[0]);
  v10 = vadd_f32(v9, (float32x2_t)0xC0000000C0000000);
  *(float *)&v11 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v10, 1), *((float *)this + 4), v10.f32[0]);
  LODWORD(v12) = *((_DWORD *)this + 7);
  v13.i32[0] = *((_DWORD *)this + 9);
  *(float *)v14.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v10, 1), *(float *)&v12, v10.f32[0]);
  v10.f32[0] = *((float *)this + 6) + *(float *)&v11;
  *(float *)_Q1.f64 = *(float *)v13.i32 + *(float *)v14.i32;
  v10.f32[1] = *(float *)v13.i32 + *(float *)v14.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v10, _Q1, v11, v12, v14, v13, v15, v16);
  v90 = v17;
  *(float32x2_t *)v17.f32 = vadd_f32(v9, (float32x2_t)0xC000000000000000);
  *(float *)&v18 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v17.f32, 1), *((float *)this + 4), v17.f32[0]);
  LODWORD(v19) = *((_DWORD *)this + 7);
  v20.i32[0] = *((_DWORD *)this + 9);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v17.f32, 1), *(float *)&v19, v17.f32[0]);
  v17.f32[0] = *((float *)this + 6) + *(float *)&v18;
  *(float *)v22.f64 = *(float *)v20.i32 + *(float *)v21.i32;
  v17.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v17.i64, v22, v18, v19, v21, v20, v23, v24);
  v89 = v25;
  *(float32x2_t *)v25.f32 = vadd_f32(v9, (float32x2_t)0xC000000040000000);
  *(float *)&v26 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v25.f32, 1), *((float *)this + 4), v25.f32[0]);
  LODWORD(v27) = *((_DWORD *)this + 7);
  v28.i32[0] = *((_DWORD *)this + 9);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v25.f32, 1), *(float *)&v27, v25.f32[0]);
  v25.f32[0] = *((float *)this + 6) + *(float *)&v26;
  *(float *)v30.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  v25.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v25.i64, v30, v26, v27, v29, v28, v31, v32);
  v88 = v33;
  *(float32x2_t *)v33.f32 = vadd_f32(v9, (float32x2_t)3221225472);
  *(float *)&v34 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v33.f32, 1), *((float *)this + 4), v33.f32[0]);
  LODWORD(v35) = *((_DWORD *)this + 7);
  v36.i32[0] = *((_DWORD *)this + 9);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v33.f32, 1), *(float *)&v35, v33.f32[0]);
  v33.f32[0] = *((float *)this + 6) + *(float *)&v34;
  *(float *)v38.f64 = *(float *)v36.i32 + *(float *)v37.i32;
  v33.f32[1] = *(float *)v36.i32 + *(float *)v37.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v33.i64, v38, v34, v35, v37, v36, v39, v40);
  v87 = v41;
  *(float32x2_t *)v41.f32 = vadd_f32(v9, 0);
  *(float *)&v42 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v41.f32, 1), *((float *)this + 4), v41.f32[0]);
  LODWORD(v43) = *((_DWORD *)this + 7);
  v44.i32[0] = *((_DWORD *)this + 9);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v41.f32, 1), *(float *)&v43, v41.f32[0]);
  v41.f32[0] = *((float *)this + 6) + *(float *)&v42;
  *(float *)v46.f64 = *(float *)v44.i32 + *(float *)v45.i32;
  v41.f32[1] = *(float *)v44.i32 + *(float *)v45.i32;
  *(double *)v49.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v41.i64, v46, v42, v43, v45, v44, v47, v48);
  v86 = v49;
  *(float32x2_t *)v49.f32 = vadd_f32(v9, (float32x2_t)0x40000000);
  *(float *)&v50 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v49.f32, 1), *((float *)this + 4), v49.f32[0]);
  LODWORD(v51) = *((_DWORD *)this + 7);
  v52.i32[0] = *((_DWORD *)this + 9);
  *(float *)v53.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v49.f32, 1), *(float *)&v51, v49.f32[0]);
  v49.f32[0] = *((float *)this + 6) + *(float *)&v50;
  *(float *)v54.f64 = *(float *)v52.i32 + *(float *)v53.i32;
  v49.f32[1] = *(float *)v52.i32 + *(float *)v53.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v49.i64, v54, v50, v51, v53, v52, v55, v56);
  v85 = v57;
  *(float32x2_t *)v57.f32 = vadd_f32(v9, (float32x2_t)0x40000000C0000000);
  *(float *)&v58 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v57.f32, 1), *((float *)this + 4), v57.f32[0]);
  LODWORD(v59) = *((_DWORD *)this + 7);
  v60.i32[0] = *((_DWORD *)this + 9);
  *(float *)v61.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v57.f32, 1), *(float *)&v59, v57.f32[0]);
  v57.f32[0] = *((float *)this + 6) + *(float *)&v58;
  *(float *)v62.f64 = *(float *)v60.i32 + *(float *)v61.i32;
  v57.f32[1] = *(float *)v60.i32 + *(float *)v61.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v57.i64, v62, v58, v59, v61, v60, v63, v64);
  v84 = v65;
  *(float32x2_t *)v65.f32 = vadd_f32(v9, (float32x2_t)0x4000000000000000);
  *(float *)&v66 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v65.f32, 1), *((float *)this + 4), v65.f32[0]);
  LODWORD(v67) = *((_DWORD *)this + 7);
  v68.i32[0] = *((_DWORD *)this + 9);
  *(float *)v69.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v65.f32, 1), *(float *)&v67, v65.f32[0]);
  v65.f32[0] = *((float *)this + 6) + *(float *)&v66;
  *(float *)v70.f64 = *(float *)v68.i32 + *(float *)v69.i32;
  v65.f32[1] = *(float *)v68.i32 + *(float *)v69.i32;
  *(double *)v73.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v65.i64, v70, v66, v67, v69, v68, v71, v72);
  v83 = v73;
  *(float32x2_t *)v73.f32 = vadd_f32(v9, (float32x2_t)0x4000000040000000);
  *(float *)&v74 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v73.f32, 1), *((float *)this + 4), v73.f32[0]);
  LODWORD(v75) = *((_DWORD *)this + 7);
  v76.i32[0] = *((_DWORD *)this + 9);
  *(float *)v77.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v73.f32, 1), *(float *)&v75, v73.f32[0]);
  v73.f32[0] = *((float *)this + 6) + *(float *)&v74;
  *(float *)v78.f64 = *(float *)v76.i32 + *(float *)v77.i32;
  v73.f32[1] = *(float *)v76.i32 + *(float *)v77.i32;
  *(double *)v81.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v73.i64, v78, v74, v75, v77, v76, v79, v80);
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v90, v89), v88), v87), v86), v85), v84), v83), v81), (float32x4_t)vdupq_n_s32(0x3DE38E39u)).u64[0];
  return result;
}

double cikernel::_cross4(cikernel *this, SamplerObj *a2, float a3)
{
  float32x2_t *DC;
  int8x16_t v5;
  double v6;
  double v7;
  double v8;
  float64x2_t v9;
  uint8x8_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  float64x2_t v14;
  double v15;
  double v16;
  uint8x8_t v17;
  int8x16_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float64x2_t v22;
  double v23;
  double v24;
  uint8x8_t v25;
  int8x16_t v26;
  double v27;
  int8x16_t v28;
  float32x4_t v29;
  float64x2_t v30;
  double v31;
  double v32;
  uint8x8_t v33;
  int8x16_t v34;
  double v35;
  int8x16_t v36;
  float32x4_t v37;
  float64x2_t v38;
  double v39;
  double v40;
  uint8x8_t v41;
  int8x16_t v42;
  double v43;
  int8x16_t v44;
  float32x4_t v45;
  double result;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float64x2_t v52;

  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v5.i8 = *DC;
  v52 = (float64x2_t)v5;
  LODWORD(v6) = *((_DWORD *)this + 7);
  *(float *)&v7 = *((float *)this + 6)
                + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v8) = *((_DWORD *)this + 9);
  *(float *)v9.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v6, COERCE_FLOAT(*DC));
  HIDWORD(v7) = LODWORD(v9.f64[0]);
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v7, v9, v6, v8, v5, v10, v11, v12);
  v50 = v13;
  v14 = v52;
  *(float32x2_t *)v13.f32 = vadd_f32(*(float32x2_t *)&v52.f64[0], (float32x2_t)0xBFC00000BF000000);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v16) = *((_DWORD *)this + 7);
  v17.i32[0] = *((_DWORD *)this + 9);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v16, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v15;
  *(float *)v14.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v13.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v14, v15, v16, v18, v17, v19, v20);
  v49 = v21;
  v22 = v52;
  *(float32x2_t *)v21.f32 = vadd_f32(*(float32x2_t *)&v52.f64[0], (float32x2_t)0x3FC000003F000000);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v21.f32, 1), *((float *)this + 4), v21.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 7);
  v25.i32[0] = *((_DWORD *)this + 9);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v21.f32, 1), *(float *)&v24, v21.f32[0]);
  v21.f32[0] = *((float *)this + 6) + *(float *)&v23;
  *(float *)v22.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v21.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v21.i64, v22, v23, v24, v26, v25, v27, v28);
  v48 = v29;
  v30 = v52;
  *(float32x2_t *)v29.f32 = vadd_f32(*(float32x2_t *)&v52.f64[0], (float32x2_t)0x3F000000BFC00000);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v29.f32, 1), *((float *)this + 4), v29.f32[0]);
  LODWORD(v32) = *((_DWORD *)this + 7);
  v33.i32[0] = *((_DWORD *)this + 9);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v29.f32, 1), *(float *)&v32, v29.f32[0]);
  v29.f32[0] = *((float *)this + 6) + *(float *)&v31;
  *(float *)v30.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v29.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v29.i64, v30, v31, v32, v34, v33, v35, v36);
  v47 = v37;
  v38 = v52;
  *(float32x2_t *)v37.f32 = vadd_f32(*(float32x2_t *)&v52.f64[0], (float32x2_t)0xBF0000003FC00000);
  *(float *)&v39 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v37.f32, 1), *((float *)this + 4), v37.f32[0]);
  LODWORD(v40) = *((_DWORD *)this + 7);
  v41.i32[0] = *((_DWORD *)this + 9);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v37.f32, 1), *(float *)&v40, v37.f32[0]);
  v37.f32[0] = *((float *)this + 6) + *(float *)&v39;
  *(float *)v38.f64 = *(float *)v41.i32 + *(float *)v42.i32;
  v37.f32[1] = *(float *)v41.i32 + *(float *)v42.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v37.i64, v38, v39, v40, v42, v41, v43, v44);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v50, 1.0 - a3), vaddq_f32(vmulq_f32(v50, (float32x4_t)vdupq_n_s32(0x3DA3D70Au)), vmulq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v49, v48), v47), v45), (float32x4_t)vdupq_n_s32(0x3E6B851Fu))), a3).u64[0];
  return result;
}

void CI::f4_sr_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v11;
  double (*v12)(uint64_t, float);
  uint64_t v13;
  uint64_t v14;
  __int128 v15;

  v11 = *(_QWORD **)(a1 + 48);
  v12 = *(double (**)(uint64_t, float))(a1 + 24);
  v13 = v11[1];
  v14 = v11[4];
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * v11[7]), a2);
  *(double *)&v15 = v12(a4 + 80 * v13, *((float *)a2 + 16 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v15;
}

double cikernel::_checker(CI *a1, float32x2_t a2, float32x4_t a3, float32x4_t a4, int32x4_t a5)
{
  float32x2_t v5;
  float32x2_t v6;
  float32x2_t v12;
  float32x2_t v14;
  double result;

  v5 = vmul_n_f32(vsub_f32(*(float32x2_t *)CI::getDC(a1), a2), *(float *)a5.i32);
  v6 = vminnm_f32(vsub_f32(v5, vrndm_f32(v5)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  __asm { FMOV            V1.2S, #1.0 }
  v12 = vminnm_f32(vmaxnm_f32(vadd_f32((float32x2_t)vdup_laneq_s32(a5, 2), vmul_lane_f32(vminnm_f32(vsub_f32(_D1, v6), v6), *(float32x2_t *)a5.i8, 1)), 0), _D1);
  __asm { FMOV            V2.2S, #3.0 }
  v14 = vmul_f32(v12, vmul_f32(v12, vsub_f32(_D2, vadd_f32(v12, v12))));
  _D1.f32[0] = fminf(v14.f32[0], v14.f32[1]) * 2.0 + 1.0 - vaddv_f32(v14);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a4, 1.0 - _D1.f32[0]), a3, _D1.f32[0]).u64[0];
  return result;
}

void CI::f4_f2_clr_clr_f3(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, double, __n128, __n128, __n128);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double *v17;
  __int128 v18;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, double, __n128, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_QWORD *)(v10 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
  v17 = (double *)(a3 + 16 * v13);
  if (v12 != 5)
    v17 = (double *)((char *)a2 + 64 * v13);
  *(double *)&v18 = v11(a1, *v17, *((__n128 *)a2 + 4 * v14), *((__n128 *)a2 + 4 * v15), *((__n128 *)a2 + 4 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_circle(CI *a1, float32x4_t a2, float32x4_t a3)
{
  float v3;
  float32x2_t v4;
  float v5;
  float v6;
  BOOL v7;
  float v8;
  double result;

  v3 = a2.f32[2];
  v4 = vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a2.f32);
  v5 = vmuls_lane_f32(v3 - sqrtf(vaddv_f32(vmul_f32(v4, v4))), a2, 3) + 0.5;
  v6 = 1.0;
  if (v5 <= 1.0)
    v6 = v5;
  v7 = v5 < 0.0;
  v8 = 0.0;
  if (!v7)
    v8 = v6;
  *(_QWORD *)&result = vmulq_n_f32(a3, v8).u64[0];
  return result;
}

void CI::f4_f4_clr(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128);
  int v12;
  uint64_t v13;
  uint64_t v14;
  __n128 *v15;
  __int128 v16;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 56)), a2);
  v15 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v15 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v16 = v11(a1, *v15, *((__n128 *)a2 + 4 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v16;
}

float32x2_t cikernel::_circleSplash(CI *a1, float32x2_t a2, float a3)
{
  float32x2_t v5;
  float32x2_t v6;
  float32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;

  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v6 = vmul_f32(v5, v5);
  v7 = vadd_f32(v6, (float32x2_t)vdup_lane_s32((int32x2_t)v6, 1));
  v8 = vrsqrte_f32((float32x2_t)v7.u32[0]);
  v9 = vmul_f32(v8, vrsqrts_f32((float32x2_t)v7.u32[0], vmul_f32(v8, v8)));
  return vadd_f32(a2, vmul_n_f32(vmul_n_f32(v5, v9.f32[0]), fminf(vmul_f32(v7, v9).f32[0], a3)));
}

void CI::f2_f2_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, double, float);
  int v12;
  uint64_t v13;
  uint64_t v14;
  double *v15;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, double, float))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 56)), a2);
  v15 = (double *)(a3 + 16 * v13);
  if (v12 != 5)
    v15 = (double *)((char *)a2 + 64 * v13);
  *(double *)(a3 + 16 * a7) = v11(a1, *v15, *((float *)a2 + 16 * v14));
}

__n64 cikernel::_circularWrap(CI *a1, float32x2_t a2, float a3, float a4, float a5, float a6)
{
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  int8x8_t v18;
  float v19;
  float v20;
  double v21;
  double v22;
  double v23;
  double v24;
  float v25;
  float v26;
  float v27;
  __n64 result;

  v10 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v11 = vmul_f32(v10, v10);
  v12 = vadd_f32(v11, (float32x2_t)vdup_lane_s32((int32x2_t)v11, 1));
  v13 = vrsqrte_f32((float32x2_t)v12.u32[0]);
  v14 = vmul_f32(v13, vrsqrts_f32((float32x2_t)v12.u32[0], vmul_f32(v13, v13)));
  v15 = vmul_n_f32(v10, v14.f32[0]);
  v16 = vabs_f32(v15);
  v17 = vadd_f32(vmul_f32(vadd_f32(vmul_f32(vadd_f32(vmul_f32(v16, (float32x2_t)vdup_n_s32(0x3F667469u)), (float32x2_t)vdup_n_s32(0xBF32DEF3)), v16), (float32x2_t)vdup_n_s32(0x3F932752u)), v16), (float32x2_t)vdup_n_s32(0x3A9C2CD7u));
  v18 = vbsl_s8((int8x8_t)vcltz_f32(v15), (int8x8_t)vneg_f32(v17), (int8x8_t)v17);
  v19 = *(float *)&v18.i32[1];
  if (v15.f32[0] < 0.0)
  {
    v20 = 3.1415927 - *(float *)&v18.i32[1];
    v19 = v20;
  }
  v21 = *(float *)v18.i32;
  v22 = v21 + -1.5707963;
  v23 = 1.5707963 - v21;
  if (v15.f32[1] >= 0.0)
    v24 = v23;
  else
    v24 = v22;
  v25 = v24;
  if ((vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v16, 1), v16).u8[0] & 1) == 0)
    v25 = v19;
  v26 = (float)(v25 - a6) * 0.15915494;
  v27 = (float)(v26 - floorf(v26)) * 6.2831853;
  result.n64_f32[0] = a5 + (float)(v27 * a4);
  result.n64_f32[1] = vmul_f32(v12, v14).f32[0] + a3;
  return result;
}

void CI::f2_f2_f_f_f_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, double, float, float, float, float);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double *v18;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, double, float, float, float, float))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_QWORD *)(v10 + 80);
  v17 = *(_QWORD *)(v10 + 104);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 128)), a2);
  v18 = (double *)(a3 + 16 * v13);
  if (v12 != 5)
    v18 = (double *)((char *)a2 + 64 * v13);
  *(double *)(a3 + 16 * a7) = v11(a1, *v18, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16), *((float *)a2 + 16 * v17));
}

double cikernel::_colorAbsDiff(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  double result;

  v2 = vabdq_f32(a1, a2);
  v2.i32[3] = a1.i32[3];
  *(_QWORD *)&result = vmulq_laneq_f32(v2, a2, 3).u64[0];
  return result;
}

__n128 cikernel::_colorbalance(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  float32x4_t v3;
  float32x4_t v4;
  simd_float4 v5;
  float32x4_t v6;
  int8x16_t v7;
  __n128 result;
  unsigned __int32 v10;
  int8x16_t v11;

  v10 = a1.u32[3];
  v3 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_192491EB0, a1, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_192491EA0, *(float32x2_t *)a1.f32, 1), vmulq_n_f32((float32x4_t)xmmword_192491E90, a1.f32[0])));
  v11 = (int8x16_t)v3;
  v3.f32[0] = fmaxf(a2.f32[3], 0.00001);
  v4 = vdivq_f32(a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 0));
  v4.i32[3] = 0;
  v5 = (simd_float4)vmaxnmq_f32(v4, (float32x4_t)0);
  v5.i32[3] = 0;
  v6 = (float32x4_t)_simd_pow_f4(v5, (simd_float4)xmmword_192491EC0);
  v7 = (int8x16_t)vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_192491EF0, v6, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_192491EE0, *(float32x2_t *)v6.f32, 1), vmulq_n_f32((float32x4_t)xmmword_192491ED0, v6.f32[0])));
  result.n128_u64[0] = (unint64_t)vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 4uLL), vmul_n_f32(vmul_laneq_f32(vsub_f32(*(float32x2_t *)a3.f32, (float32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 4uLL)), a3, 2), powf(*(float *)v11.i32, a3.f32[3])));
  result.n128_u64[0] = vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_192491F10, (float32x2_t)result.n128_u64[0], 1), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.i8, 0), vmulq_n_f32((float32x4_t)xmmword_192491F00, result.n128_f32[0]))).u64[0];
  result.n128_u32[3] = v10;
  return result;
}

void CI::f4_s_clr_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, __n128);
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  __n128 *v17;
  __n128 *v18;
  __int128 v19;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v17 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v16);
  v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v19 = v11(a1, *v18, *((__n128 *)a2 + 4 * v14), *v17);
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_colorClamp(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  double result;

  *(_QWORD *)&result = vminnmq_f32(vmaxnmq_f32(a1, a2), a3).u64[0];
  return result;
}

void CI::f4_s_f4_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, __n128);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __n128 *v20;
  __int128 v21;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_DWORD *)(v10 + 64);
  v17 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v15);
  v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v21 = v11(a1, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

double cikernel::_colorClampAP(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  double result;

  *(_QWORD *)&result = vminnmq_f32(vmaxnmq_f32(a1, a2), a3).u64[0];
  return result;
}

CIImage *_imageByApplyingColorMatrix(void *a1, float a2, float a3, float a4, float a5, float a6, float a7, double a8, double a9, float a10, float a11, float a12, float a13, float a14, float a15)
{
  const double (*v26)[4];
  CIImage *v28;
  CI::Image *v29;
  CI::ColorMatrixImage *v30;
  double v32[12];
  __int128 v33;
  __int128 v34;
  double v35;
  double v36;
  double v37;
  uint64_t v38;
  uint64_t v39;
  CGRect v40;

  v39 = *MEMORY[0x1E0C80C00];
  objc_msgSend(a1, "extent");
  if (CGRectIsEmpty(v40))
    return +[CIImage emptyImage](CIImage, "emptyImage");
  v32[0] = a2;
  v32[1] = a3;
  v32[2] = a4;
  v32[3] = 0.0;
  v32[4] = a5;
  v32[5] = a6;
  v32[6] = a7;
  v32[7] = 0.0;
  v32[8] = a10;
  v32[9] = a11;
  v32[10] = a12;
  v32[11] = 0.0;
  v33 = xmmword_192491FA0;
  v34 = unk_192491FB0;
  v35 = a13;
  v36 = a14;
  v37 = a15;
  v38 = 0;
  if (CI::ColorMatrixImage::is_identity((CI::ColorMatrixImage *)v32, v26))
    return (CIImage *)a1;
  v29 = (CI::Image *)objc_msgSend(a1, "_internalRepresentation");
  v30 = (CI::ColorMatrixImage *)operator new();
  CI::ColorMatrixImage::ColorMatrixImage(v30, v29, (const double (*)[4])v32);
  v28 = +[CIImage imageWithInternalRepresentation:](CIImage, "imageWithInternalRepresentation:", v30);
  CI::Object::unref(v30);
  return v28;
}

void sub_192240C64(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40112EC1AALL);
  _Unwind_Resume(a1);
}

id ___ZL11defaultCubev_block_invoke()
{
  id result;
  _OWORD v1[8];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1[4] = xmmword_192492020;
  v1[5] = unk_192492030;
  v1[6] = xmmword_192492040;
  v1[7] = unk_192492050;
  v1[0] = xmmword_192491FE0;
  v1[1] = unk_192491FF0;
  v1[2] = xmmword_192492000;
  v1[3] = unk_192492010;
  result = (id)objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v1, 128);
  defaultCube(void)::data = (uint64_t)result;
  return result;
}

double cikernel::_colorcube(uint64x2_t *a1, float32x4_t a2, int8x16_t a3, double a4, double a5, int8x16_t a6, double a7, double a8, int8x16_t a9)
{
  float32x4_t v11;
  float32x4_t v12;
  float v13;
  float v14;
  float32_t v15;
  float32x2_t v16;
  double v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x4_t v20;
  float64x2_t v21;
  double v22;
  double v23;
  int8x16_t v24;
  uint8x8_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  double result;
  float32x2_t v30;
  float32x4_t v31;

  a2.i32[3] = 0;
  v11 = vmaxnmq_f32(a2, (float32x4_t)xmmword_192491FC0);
  v11.i32[3] = 0;
  v12 = vmulq_n_f32(vminnmq_f32(v11, (float32x4_t)xmmword_19248E2D0), *(float *)a3.i32);
  v13 = v12.f32[2];
  v14 = floorf(v12.f32[2]);
  *(float32x2_t *)v12.f32 = vadd_f32(*(float32x2_t *)v12.f32, (float32x2_t)0x3F0000003F000000);
  *(double *)a6.i64 = *(float *)a3.i32 + 1.0;
  v15 = *(double *)a6.i64 * v14;
  v16.i32[0] = 0;
  LODWORD(v17) = 0;
  *((float32_t *)&v17 + 1) = v15;
  v18 = vadd_f32(*(float32x2_t *)v12.f32, *(float32x2_t *)&v17);
  *(double *)a2.i64 = *(double *)a6.i64 * fminf(v14 + 1.0, *(float *)a3.i32);
  a2.f32[0] = *(double *)a2.i64;
  v16.i32[1] = a2.i32[0];
  v19 = vadd_f32(*(float32x2_t *)v12.f32, v16);
  v30 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  *(double *)v20.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v30, v18)), (float64x2_t)a3, *(double *)&v18, *(double *)a2.i64, a6, (uint8x8_t)v16, v17, a9);
  v31 = v20;
  *(double *)v28.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v30, v19)), v21, v22, v23, v24, v25, v26, v27);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v31, 1.0 - (float)(v13 - v14)), v28, v13 - v14).u64[0];
  return result;
}

void CI::f4_s_sr2d_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, __n128, __n128);
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  __n128 *v17;
  __n128 *v18;
  __int128 v19;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, __n128, __n128))(a1 + 24);
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *((_QWORD *)a2 + 8 * *(_QWORD *)(v10 + 32));
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v17 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v16);
  v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v19 = v11(v14, *v18, *v17);
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_colorcubeopaque(uint64x2_t *a1, float32x4_t a2, int8x16_t a3, double a4, double a5, int8x16_t a6, double a7, double a8, int8x16_t a9)
{
  float32x4_t v11;
  float32x4_t v12;
  float v13;
  float v14;
  float32_t v15;
  float32x2_t v16;
  double v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x4_t v20;
  float64x2_t v21;
  double v22;
  double v23;
  int8x16_t v24;
  uint8x8_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  double result;
  float32x2_t v30;
  float32x4_t v31;

  a2.i32[3] = 0;
  v11 = vmaxnmq_f32(a2, (float32x4_t)xmmword_192491FC0);
  v11.i32[3] = 0;
  v12 = vmulq_n_f32(vminnmq_f32(v11, (float32x4_t)xmmword_19248E2D0), *(float *)a3.i32);
  v13 = v12.f32[2];
  v14 = floorf(v12.f32[2]);
  *(float32x2_t *)v12.f32 = vadd_f32(*(float32x2_t *)v12.f32, (float32x2_t)0x3F0000003F000000);
  *(double *)a6.i64 = *(float *)a3.i32 + 1.0;
  v15 = *(double *)a6.i64 * v14;
  v16.i32[0] = 0;
  LODWORD(v17) = 0;
  *((float32_t *)&v17 + 1) = v15;
  v18 = vadd_f32(*(float32x2_t *)v12.f32, *(float32x2_t *)&v17);
  *(double *)a2.i64 = *(double *)a6.i64 * fminf(v14 + 1.0, *(float *)a3.i32);
  a2.f32[0] = *(double *)a2.i64;
  v16.i32[1] = a2.i32[0];
  v19 = vadd_f32(*(float32x2_t *)v12.f32, v16);
  v30 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  *(double *)v20.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v30, v18)), (float64x2_t)a3, *(double *)&v18, *(double *)a2.i64, a6, (uint8x8_t)v16, v17, a9);
  v31 = v20;
  *(double *)v28.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v30, v19)), v21, v22, v23, v24, v25, v26, v27);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v31, 1.0 - (float)(v13 - v14)), v28, v13 - v14).u64[0];
  return result;
}

double cikernel::_colorcubeopaque_extend(uint64x2_t *a1, float32x4_t a2, int8x16_t a3, double a4, double a5, double a6, double a7, double a8, int8x16_t a9)
{
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float v22;
  float v23;
  double v24;
  float32x2_t v25;
  float32x4_t v26;
  float64x2_t v27;
  double v28;
  double v29;
  int8x16_t v30;
  uint8x8_t v31;
  double v32;
  int8x16_t v33;
  float32x4_t v34;
  int8x16_t v35;
  uint8x8_t v36;
  double v37;
  int8x16_t v38;
  float32x4_t v39;
  float64x2_t v40;
  float32x4_t v41;
  float v42;
  float v43;
  double v44;
  double v45;
  float32x2_t v46;
  float32x4_t v47;
  float64x2_t v48;
  double v49;
  double v50;
  int8x16_t v51;
  uint8x8_t v52;
  double v53;
  int8x16_t v54;
  float32x4_t v55;
  float v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float v62;
  float32x2_t v63;

  v12 = (float32x4_t)vdupq_n_s32(0xBE99999A);
  v13 = vaddq_f32(a2, v12);
  v14 = vmulq_f32(v13, v13);
  a2.i32[3] = 0;
  v15 = vmaxnmq_f32(a2, (float32x4_t)0);
  v15.i32[3] = 0;
  v16.i64[1] = 1065353216;
  v17 = vaddq_f32(vminnmq_f32(v15, (float32x4_t)xmmword_192491FD0), v12);
  v18 = vmulq_f32(v17, v17);
  v62 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0]);
  v19 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1)));
  v19.f32[0] = sqrtf(v19.f32[0]);
  v61 = v19;
  v20 = vmaxnmq_f32(a2, (float32x4_t)xmmword_192491FC0);
  v20.i32[3] = 0;
  v14.i64[1] = 1065353048;
  v21 = vmulq_n_f32(vminnmq_f32(v20, (float32x4_t)xmmword_19248E2D0), *(float *)a3.i32);
  v22 = v21.f32[2];
  v23 = floorf(v21.f32[2]);
  *(float32x2_t *)v21.f32 = vadd_f32(*(float32x2_t *)v21.f32, (float32x2_t)0x3F0000003F000000);
  v16.i64[0] = 1.0;
  v24 = *(float *)a3.i32 + 1.0;
  v14.f32[0] = v24 * v23;
  a2.i32[0] = 0;
  a2.i32[1] = v14.i32[0];
  *(float32x2_t *)v14.f32 = vadd_f32(*(float32x2_t *)v21.f32, *(float32x2_t *)a2.f32);
  *(double *)v15.i64 = v24 * fminf(v23 + 1.0, *(float *)a3.i32);
  v15.f32[0] = *(double *)v15.i64;
  a2.i32[0] = 0;
  a2.i32[1] = v15.i32[0];
  v25 = vadd_f32(*(float32x2_t *)v21.f32, *(float32x2_t *)a2.f32);
  v57 = *(float *)a3.i32;
  v63 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  *(double *)v26.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v63, *(float32x2_t *)v14.f32)), (float64x2_t)v14, *(double *)v15.i64, *(double *)a2.i64, v16, *(uint8x8_t *)a3.i8, a8, a9);
  v59 = v26;
  *(double *)v34.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v63, v25)), v27, v28, v29, v30, v31, v32, v33);
  v39 = vmlaq_n_f32(vmulq_n_f32(v59, 1.0 - (float)(v22 - v23)), v34, v22 - v23);
  *(_QWORD *)&v40.f64[1] = v61.i64[1];
  if (v62 > v61.f32[0])
  {
    v41 = vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3E99999Au), v57);
    v42 = v41.f32[2];
    v43 = floorf(v41.f32[2]);
    v60 = v39;
    *(float32x2_t *)v41.f32 = vadd_f32(*(float32x2_t *)v41.f32, (float32x2_t)0x3F0000003F000000);
    *(float *)v40.f64 = v24 * v43;
    LODWORD(v44) = 0;
    HIDWORD(v44) = LODWORD(v40.f64[0]);
    *(float32x2_t *)&v40.f64[0] = vadd_f32(*(float32x2_t *)v41.f32, *(float32x2_t *)&v44);
    v45 = v24 * fminf(v43 + 1.0, v57);
    *(float *)&v45 = v45;
    LODWORD(v44) = 0;
    HIDWORD(v44) = LODWORD(v45);
    v46 = vadd_f32(*(float32x2_t *)v41.f32, *(float32x2_t *)&v44);
    *(double *)v47.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v63, *(float32x2_t *)&v40.f64[0])), v40, v45, v44, v35, v36, v37, v38);
    v58 = v47;
    *(double *)v55.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v63, v46)), v48, v49, v50, v51, v52, v53, v54);
    v39 = vmlaq_n_f32(vmulq_n_f32(v58, 1.0 - (float)(v42 - v43)), v55, v42 - v43);
    v39.i64[0] = vaddq_f32(v39, vdivq_f32(vmulq_n_f32(vsubq_f32(v60, v39), v62), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v61.f32, 0))).u64[0];
  }
  return *(double *)v39.i64;
}

double cikernel::_headroomToneMap(float32x4_t a1, float a2, float a3, float a4, float32x4_t a5)
{
  float v5;
  float v6;
  float v7;
  float v8;
  double result;

  v5 = fmaxf(fmaxf(a1.f32[0], a1.f32[1]), a1.f32[2]);
  if (v5 > 1.0)
  {
    v6 = (float)(a5.f32[2] + sqrtf(fmaxf(vmlas_n_f32(a5.f32[1], v5, a5.f32[0]), 0.0))) / a5.f32[0];
    v7 = a4 + vmuls_lane_f32(v6, a5, 3) * (v6 + -2.0);
    if (v5 >= a2)
      v8 = a3;
    else
      v8 = v7;
    a4 = fminf(v8 / v5, 1.0);
  }
  *(_QWORD *)&result = vmulq_n_f32(a1, a4).u64[0];
  return result;
}

id ___ZL12defaultTablev_block_invoke()
{
  id result;
  uint64_t v6;
  int v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v7 = 0;
  v6 = 0;
  v8 = xmmword_1924920D0;
  __asm { FMOV            V0.2S, #1.0 }
  v9 = _D0;
  result = (id)objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v6, 36);
  defaultTable(void)::data = (uint64_t)result;
  return result;
}

double cikernel::_colorcurves(uint64x2_t *a1, float32x4_t a2, int32x2_t a3, double a4, double a5, int8x16_t a6, uint8x8_t a7, double a8, int8x16_t a9)
{
  float32x4_t v10;
  float32x4_t v11;
  double v12;
  float64x2_t v13;
  double v14;
  int8x16_t v15;
  uint8x8_t v16;
  double v17;
  int8x16_t v18;
  double v19;
  float64x2_t v20;
  double v21;
  int8x16_t v22;
  uint8x8_t v23;
  double v24;
  int8x16_t v25;
  unsigned int v27;
  unsigned int v28;
  float32x4_t v29;
  float32x4_t v31;

  *(int32x2_t *)a6.i8 = vdup_lane_s32(a3, 1);
  v10 = vsubq_f32(a2, (float32x4_t)vdupq_lane_s32(a3, 0));
  v11 = (float32x4_t)vdupq_lane_s32((int32x2_t)vsub_f32(*(float32x2_t *)a6.i8, (float32x2_t)a3), 0);
  v29 = vdivq_f32(v10, v11);
  v11.i32[0] = HIDWORD(a4);
  v31 = v11;
  v11.f32[0] = vmlas_n_f32(*((float *)&a4 + 1), v29.f32[0], *(float *)&a4);
  v12 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(v11.u32[0] | 0x3F00000000000000), (float64x2_t)v11, a4, *(double *)v10.i64, a6, a7, a8, a9);
  v28 = LODWORD(v12);
  v13 = (float64x2_t)v31;
  *(float *)v13.f64 = vmlas_n_f32(v31.f32[0], v29.f32[1], *(float *)&a4);
  v19 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(LODWORD(v13.f64[0]) | 0x3F00000000000000), v13, a4, v14, v15, v16, v17, v18);
  v27 = HIDWORD(v19);
  v20 = (float64x2_t)v31;
  *(float *)v20.f64 = vmlas_n_f32(v31.f32[0], v29.f32[2], *(float *)&a4);
  CI::BitmapSampler::read(a1, COERCE_DOUBLE(LODWORD(v20.f64[0]) | 0x3F00000000000000), v20, a4, v21, v22, v23, v24, v25);
  return COERCE_DOUBLE(__PAIR64__(v27, v28));
}

void CI::f4_s_sr2d_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(uint64_t, __n128, double, double);
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  double *v18;
  double *v19;
  __n128 *v20;
  __int128 v21;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(uint64_t, __n128, double, double))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *((_QWORD *)a2 + 8 * *(_QWORD *)(v9 + 32));
  v13 = *(_QWORD *)(v9 + 8);
  v14 = *(_DWORD *)(v9 + 64);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_DWORD *)(v9 + 88);
  v17 = *(_QWORD *)(v9 + 80);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 104)), a2);
  v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (double *)((char *)a2 + 64 * v17);
  v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (double *)((char *)a2 + 64 * v15);
  v20 = (__n128 *)(a3 + 16 * v13);
  if (v11 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v21 = v10(v12, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

void CI::f4_s_f_f_f_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(_QWORD *, __n128, float, float, float, __n128);
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __int128 v20;

  v9 = a1[6];
  v10 = (double (*)(_QWORD *, __n128, float, float, float, __n128))a1[3];
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_QWORD *)(v9 + 32);
  v14 = *(_QWORD *)(v9 + 56);
  v15 = *(_QWORD *)(v9 + 80);
  v16 = *(_DWORD *)(v9 + 112);
  v17 = *(_QWORD *)(v9 + 104);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v20 = v10(a1, *v19, *((float *)a2 + 16 * v13), *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

float32x4_t cikernel::_linearToAppleLog(float32x4_t a1)
{
  float32x4_t v1;
  float32x4_t result;

  result = (float32x4_t)_simd_log2_f4((simd_float4)vaddq_f32(a1, (float32x4_t)vdupq_n_s32(0x3C1DF346u)));
  v1 = vaddq_f32(a1, (float32x4_t)vdupq_n_s32(0x3D670F18u));
  result.i64[0] = vbslq_s8((int8x16_t)vcltzq_f32(vaddq_f32(a1, (float32x4_t)vdupq_n_s32(0xBC23D70A))), vbslq_s8((int8x16_t)vcltzq_f32(v1), (int8x16_t)0, (int8x16_t)vmulq_f32(v1, vmulq_f32(v1, (float32x4_t)vdupq_n_s32(0x423D2601u)))), (int8x16_t)vaddq_f32(vmulq_f32(result, (float32x4_t)vdupq_n_s32(0x3DAF1D23u)), (float32x4_t)vdupq_n_s32(0x3F3180A9u))).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

float32x4_t cikernel::_appleLogToLinear(float32x4_t a1)
{
  simd_float4 v1;
  simd_float4 v2;
  float32x4_t result;
  unsigned __int32 v4;

  v4 = a1.u32[3];
  v1 = (simd_float4)vdivq_f32(vaddq_f32(a1, (float32x4_t)vdupq_n_s32(0xBF3180A9)), (float32x4_t)vdupq_n_s32(0x3DAF1D23u));
  v2.i64[0] = 0x4000000040000000;
  v2.i64[1] = 0x4000000040000000;
  result = (float32x4_t)_simd_pow_f4(v2, v1);
  result.i64[0] = vaddq_f32(result, (float32x4_t)vdupq_n_s32(0xBC1DF346)).u64[0];
  result.i32[3] = v4;
  return result;
}

double cikernel::_colorMonochrome(float32x4_t a1, float32x4_t a2, float a3)
{
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v9;
  float32x4_t v10;
  unint64_t v12;
  int64x2_t v13;
  int v14;
  int8x8_t v15;
  __int8 v16;
  float32x4_t v17;
  double result;

  v3 = vmulq_f32(a1, (float32x4_t)xmmword_192492180);
  v3.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0];
  v4 = vmulq_n_f32(a2, v3.f32[0] + v3.f32[0]);
  __asm { FMOV            V7.4S, #1.0 }
  v9 = vmulq_n_f32(vsubq_f32(_Q7, a2), 1.0 - v3.f32[0]);
  v10 = vaddq_f32(v9, v9);
  v3.f32[0] = v3.f32[0] + -0.5;
  _NF = v3.f32[0] < 0.0;
  v12 = 16843008;
  if (v3.f32[0] >= 0.0)
    v12 = 0;
  v13 = vdupq_n_s64(v12);
  v14 = _NF;
  v15 = (int8x8_t)vmovn_s64(vtstq_s64(v13, (int64x2_t)xmmword_192492190));
  v16 = v15.i8[0];
  v15.i32[0] = v14;
  *(float32x2_t *)v17.f32 = vcvt_f32_u32((uint32x2_t)vand_s8(v15, (int8x8_t)0x100000001));
  v17.f32[2] = (float)(v16 & 1);
  v17.i32[3] = v17.i32[0];
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a3), vmlaq_f32(vmulq_f32(vsubq_f32(_Q7, v10), vsubq_f32(_Q7, v17)), v17, v4), a3).u64[0];
  return result;
}

void CI::f4_s_clr_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, float);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __n128 *v16;
  __int128 v17;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, float))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v16 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v16 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v17 = v11(a1, *v16, *((__n128 *)a2 + 4 * v14), *((float *)a2 + 16 * v15));
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

void cikernel::_palettize(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4)
{
  float32x2_t *DC;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  float64x2_t v13;
  double v14;
  int8x16_t v15;
  float32x4_t v16;
  double v17;
  double v18;
  float64x2_t v19;
  int8x16_t v20;
  uint8x8_t v21;
  double v22;
  int8x16_t v23;
  float32x4_t v24;
  int8x16_t v25;
  float32x4_t v26;
  double v27;
  int8x16_t v28;
  double v29;
  float32x4_t v30;
  int8x16_t v31;
  float32x4_t v32;
  float v33;
  double v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  int8x16_t v39;

  DC = (float32x2_t *)CI::getDC(this);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v9, COERCE_FLOAT(*DC));
  *(float *)&v12 = *((float *)this + 6) + *(float *)&v8;
  *(float *)v13.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  *((float *)&v12 + 1) = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v12, v13, v8, v9, v11, v10, v14, v15);
  v37 = v16;
  LODWORD(v17) = *((_DWORD *)a2 + 7);
  v16.f32[0] = *((float *)a2 + 6) + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)(*((float *)a2 + 4) * 0.5));
  LODWORD(v18) = *((_DWORD *)a2 + 9);
  *(float *)v19.f64 = *(float *)&v18 + (float)((float)(*((float *)a2 + 8) * 0.5) + (float)(*(float *)&v17 * 0.5));
  v16.f32[1] = *(float *)v19.f64;
  *(double *)v24.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v16.i64, v19, v17, v18, v20, v21, v22, v23);
  if (a4 > 1.0)
  {
    HIDWORD(v29) = v37.i32[1];
    v30 = vsubq_f32(v37, v24);
    v31 = (int8x16_t)vmulq_f32(v30, v30);
    v32 = (float32x4_t)vextq_s8(v31, v31, 8uLL);
    *(float32x2_t *)v32.f32 = vadd_f32(*(float32x2_t *)v31.i8, *(float32x2_t *)v32.f32);
    v26.f32[0] = vaddv_f32(*(float32x2_t *)v32.f32);
    v33 = 1.0;
    do
    {
      v38 = v26;
      v39 = (int8x16_t)v24;
      v31.i32[0] = *((_DWORD *)a2 + 6);
      v26.i32[0] = *((_DWORD *)a2 + 9);
      *(float *)v25.i32 = *((float *)a2 + 8) * 0.5;
      *(float *)&v29 = *(float *)v25.i32 + (float)((float)(v33 + 0.5) * *((float *)a2 + 7));
      *(float *)&v34 = *(float *)v31.i32
                     + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)((float)(v33 + 0.5) * *((float *)a2 + 4)));
      v32.f32[0] = v26.f32[0] + *(float *)&v29;
      *((float *)&v34 + 1) = v26.f32[0] + *(float *)&v29;
      *(double *)v35.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), v34, (float64x2_t)v32, *(double *)v31.i64, v29, v25, *(uint8x8_t *)v26.f32, v27, v28);
      HIDWORD(v29) = v37.i32[1];
      v26 = v38;
      v36 = vsubq_f32(v37, v35);
      v32 = vmulq_f32(v36, v36);
      *(float32x2_t *)v32.f32 = vadd_f32(*(float32x2_t *)v32.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v32, (int8x16_t)v32, 8uLL));
      v32.f32[0] = vaddv_f32(*(float32x2_t *)v32.f32);
      v31 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v38, v32), 0);
      v25 = vbslq_s8(v31, (int8x16_t)v35, v39);
      v24 = (float32x4_t)v25;
      if (v32.f32[0] < v38.f32[0])
        v26.f32[0] = v32.f32[0];
      v33 = v33 + 1.0;
    }
    while (v33 < a4);
  }
}

void CI::f4_sr_sr_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v11;
  double (*v12)(uint64_t, uint64_t, float);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;

  v11 = *(_QWORD **)(a1 + 48);
  v12 = *(double (**)(uint64_t, uint64_t, float))(a1 + 24);
  v13 = v11[1];
  v14 = v11[4];
  v15 = v11[7];
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * v11[10]), a2);
  *(double *)&v16 = v12(a4 + 80 * v13, a4 + 80 * v14, *((float *)a2 + 16 * v15));
  *(_OWORD *)(a3 + 16 * a7) = v16;
}

double cikernel::_ddither(float32x4_t a1, int32x4_t a2, float a3)
{
  double v3;
  double result;

  v3 = vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 2), vaddq_f32((float32x4_t)a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 1)))).f32[0]* 0.25+ -0.5;
  *(float *)&v3 = v3;
  *(float *)&v3 = *(float *)&v3 * a3;
  *(_QWORD *)&result = vaddq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v3, 0)).u64[0];
  return result;
}

double cikernel::_shadowdesat(float32x4_t a1, float a2, double a3, float a4)
{
  float32x4_t v4;
  float v5;
  float v6;
  float v7;
  BOOL v8;
  float v9;
  double result;

  v4 = vmulq_f32(a1, (float32x4_t)xmmword_1924921A0);
  v5 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0];
  v6 = (float)(v5 - (float)(a2 * a4)) / (float)(a2 - (float)(a2 * a4));
  if (v6 <= 1.0)
    v7 = v6;
  else
    v7 = 1.0;
  v8 = v6 < 0.0;
  v9 = 0.0;
  if (!v8)
    v9 = v7;
  *(float *)&a3 = (float)(1.0 - (float)((float)(v9 * v9) * (float)((float)(v9 * -2.0) + 3.0))) * *(float *)&a3;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - *(float *)&a3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), v5).u64[0];
  return result;
}

void CI::f4_s_f_f_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, float, float, float);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 *v17;
  __int128 v18;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, float, float, float))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_QWORD *)(v10 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
  v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v18 = v11(a1, *v17, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_colorMap(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4)
{
  float32x2_t *DC;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  float64x2_t v13;
  double v14;
  int8x16_t v15;
  float32x4_t v16;
  int8x16_t v17;
  uint8x8_t v18;
  double v19;
  int8x16_t v20;
  float64x2_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float v25;
  BOOL v26;
  float v27;
  double v28;
  float32x4_t v29;
  double result;
  float32x4_t v31;

  DC = (float32x2_t *)CI::getDC(this);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v9, COERCE_FLOAT(*DC));
  *(float *)&v12 = *((float *)this + 6) + *(float *)&v8;
  *(float *)v13.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  *((float *)&v12 + 1) = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v12, v13, v8, v9, v11, v10, v14, v15);
  v31 = v16;
  LODWORD(v21.f64[0]) = 1.0;
  v22 = vmulq_n_f32(v16, 1.0 / fmaxf(v16.f32[3], 0.00001));
  v23 = vmulq_f32(v22, (float32x4_t)xmmword_192492180);
  v24 = vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1));
  v25 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), v24).f32[0];
  if (v25 <= 1.0)
    *(float *)v21.f64 = v25;
  v26 = v25 < 0.0;
  v27 = 0.0;
  if (!v26)
    v27 = *(float *)v21.f64;
  v24.f32[0] = (float)(v27 * a4) + 0.5;
  v17.i32[0] = *((_DWORD *)a2 + 7);
  *(float *)&v28 = *((float *)a2 + 6)
                 + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)(v24.f32[0] * *((float *)a2 + 4)));
  v22.i32[0] = *((_DWORD *)a2 + 8);
  v18.i32[0] = *((_DWORD *)a2 + 9);
  *(float *)v21.f64 = *(float *)v18.i32 + (float)((float)(v22.f32[0] * 0.5) + (float)(v24.f32[0] * *(float *)v17.i32));
  *((float *)&v28 + 1) = *(float *)v21.f64;
  *(double *)v29.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), v28, v21, *(double *)v24.i64, *(double *)v22.i64, v17, v18, v19, v20);
  *(_QWORD *)&result = vmulq_laneq_f32(v29, v31, 3).u64[0];
  return result;
}

double cikernel::_ciSingleChannelColorMap(cikernel *this, SamplerObj *a2, SamplerObj *a3)
{
  float32x2_t *DC;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  float64x2_t v11;
  double v12;
  int8x16_t v13;
  double v14;
  double v15;
  double v16;
  int8x16_t v17;
  uint8x8_t v18;
  double v19;
  int8x16_t v20;
  float64x2_t v21;
  double v22;

  DC = (float32x2_t *)CI::getDC(this);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v7, COERCE_FLOAT(*DC));
  *(float *)&v10 = *((float *)this + 6) + *(float *)&v6;
  *(float *)v11.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  *((float *)&v10 + 1) = *(float *)v8.i32 + *(float *)v9.i32;
  v14 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v10, v11, v6, v7, v9, v8, v12, v13);
  LODWORD(v21.f64[0]) = 1132396544;
  if (*(float *)&v14 <= 1.0)
    *(float *)v21.f64 = 255.0 * *(float *)&v14;
  if (*(float *)&v14 < 0.0)
    *(float *)v21.f64 = 0.0;
  LODWORD(v16) = 0.5;
  v17.i32[0] = *((_DWORD *)a2 + 7);
  *(float *)&v22 = *((float *)a2 + 6)
                 + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)(*(float *)v21.f64 * *((float *)a2 + 4)));
  v18.i32[0] = *((_DWORD *)a2 + 9);
  *(float *)&v15 = *((float *)a2 + 8) * 0.5;
  *(float *)v21.f64 = *(float *)v18.i32 + (float)(*(float *)&v15 + (float)(*(float *)v21.f64 * *(float *)v17.i32));
  HIDWORD(v22) = LODWORD(v21.f64[0]);
  return CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), v22, v21, v15, v16, v17, v18, v19, v20);
}

void CI::f4_sr_sr(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v10;
  double (*v11)(uint64_t, uint64_t);
  uint64_t v12;
  uint64_t v13;
  __int128 v14;

  v10 = *(_QWORD **)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t))(a1 + 24);
  v12 = v10[1];
  v13 = v10[4];
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * v10[7]), a2);
  *(double *)&v14 = v11(a4 + 80 * v12, a4 + 80 * v13);
  *(_OWORD *)(a3 + 16 * a7) = v14;
}

double cikernel::_ciExtractChannel(__n128 a1, float a2)
{
  int v2;
  double result;
  __n128 v4;

  v2 = (int)a2;
  if ((int)a2 >= 3)
    LOBYTE(v2) = 3;
  v4 = a1;
  *(_QWORD *)&result = *(unsigned int *)((unint64_t)&v4 & 0xFFFFFFFFFFFFFFF3 | (4 * (v2 & 3)));
  return result;
}

void sub_192246848(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40112EC1AALL);
  _Unwind_Resume(a1);
}

double cikernel::_colorPolynomial(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  double result;

  *(_QWORD *)&result = vaddq_f32(a2, vmulq_f32(a1, vaddq_f32(a3, vmulq_f32(a1, vaddq_f32(a4, vmulq_f32(a1, a5)))))).u64[0];
  return result;
}

void CI::f4_s_f4_f4_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, __n128);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  __n128 *v21;
  __n128 *v22;
  __n128 *v23;
  __n128 *v24;
  __n128 *v25;
  __int128 v26;
  int v27;
  int v28;
  int v29;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  v19 = *(_DWORD *)(v9 + 112);
  v20 = *(_QWORD *)(v9 + 104);
  if (*(_BYTE *)(a1 + 64))
  {
    v28 = *(_DWORD *)(v9 + 88);
    v29 = *(_DWORD *)(v9 + 40);
    v27 = *(_DWORD *)(v9 + 64);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
    v15 = v27;
    v17 = v28;
    v13 = v29;
  }
  v21 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5)
    v21 = (__n128 *)((char *)a2 + 64 * v20);
  v22 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v22 = (__n128 *)((char *)a2 + 64 * v18);
  v23 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v23 = (__n128 *)((char *)a2 + 64 * v16);
  v24 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v24 = (__n128 *)((char *)a2 + 64 * v14);
  v25 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v25 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v26 = v10(*v25, *v24, *v23, *v22, *v21);
  *(_OWORD *)(a3 + 16 * a7) = v26;
}

double cikernel::_colorPolynomialRGB(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  double result;

  *(_QWORD *)&result = vaddq_f32(a2, vmulq_f32(a1, vaddq_f32(a3, vmulq_f32(a1, vaddq_f32(a4, vmulq_f32(a1, a5)))))).u64[0];
  return result;
}

__n64 cikernel::_colorPolynomialInverse(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v14;
  float32x4_t v16;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  float32x4_t v25;
  __n64 result;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v32;
  float32x4_t v35;

  v5 = vmulq_f32(a4, a4);
  v6 = vmulq_f32(a4, v5);
  v7 = v5;
  v28 = v5;
  __asm { FMOV            V5.4S, #27.0 }
  v35 = vsubq_f32(a1, a2);
  __asm { FMOV            V0.4S, #9.0 }
  v14 = vsubq_f32(vaddq_f32(vmulq_f32(a5, vmulq_f32(a4, vmulq_f32(a3, _Q0))), vmulq_f32(v35, vmulq_f32(a5, vmulq_f32(a5, _Q5)))), vaddq_f32(v6, v6));
  __asm { FMOV            V1.4S, #3.0 }
  v29 = _Q1;
  v16 = vsubq_f32(vmulq_f32(vmulq_f32(a3, _Q1), a5), v7);
  __asm { FMOV            V3.4S, #4.0 }
  v32 = _Q3;
  v18 = vaddq_f32(v14, vsqrtq_f32(vaddq_f32(vmulq_f32(v16, vmulq_f32(v16, vmulq_f32(v16, _Q3))), vmulq_f32(v14, v14))));
  v16.i64[0] = 0x3F0000003F000000;
  v16.i64[1] = 0x3F0000003F000000;
  v19 = (float32x4_t)_simd_pow_f4((simd_float4)vmulq_f32(v18, v16), (simd_float4)vdupq_n_s64(0x3EAAAAAB3EAAAAABuLL));
  v21 = vmulq_f32(a5, v29);
  v22 = (int8x16_t)vsubq_f32(vsubq_f32(vdivq_f32(v19, v21), vdivq_f32(vsubq_f32(a3, vdivq_f32(v28, v21)), v19)), vdivq_f32(a4, v21));
  v23 = (int8x16_t)vdivq_f32(vsubq_f32(vsqrtq_f32(vsubq_f32(vmulq_f32(a3, a3), vmulq_f32(vsubq_f32(a2, a1), vmulq_f32(a4, v32)))), a3), vaddq_f32(a4, a4));
  v24 = (int8x16_t)vdivq_f32(v35, a3);
  v25 = (float32x4_t)v22;
  if (a5.f32[1] == 0.0)
  {
    v25.i32[0] = 0;
    v25 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.f32, 1), v25), 0), v24, v23);
  }
  if (a5.f32[3] == 0.0)
    v20 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a4, 3);
  v20.i32[0] = 0;
  result.n64_u32[0] = vbslq_s8((int8x16_t)vceqq_f32(a5, v20), vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(a4, v20), 0), v24, v23), v22).u32[0];
  result.n64_u32[1] = v25.u32[1];
  return result;
}

__n64 cikernel::_colorPolynomialInverseRGB(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v13;
  float32x4_t v15;
  float32x4_t v17;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  __n64 result;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v32;
  float32x4_t v36;

  v5 = vmulq_f32(a4, a4);
  v6 = vmulq_f32(a4, v5);
  v7 = v5;
  v29 = v5;
  __asm { FMOV            V5.4S, #27.0 }
  v36 = vsubq_f32(a1, a2);
  v13 = vmulq_f32(v36, vmulq_f32(a5, vmulq_f32(a5, _Q5)));
  __asm { FMOV            V5.4S, #9.0 }
  v15 = vsubq_f32(vaddq_f32(vmulq_f32(a5, vmulq_f32(a4, vmulq_f32(a3, _Q5))), v13), vaddq_f32(v6, v6));
  __asm { FMOV            V1.4S, #3.0 }
  v30 = _Q1;
  v17 = vsubq_f32(vmulq_f32(vmulq_f32(a3, _Q1), a5), v7);
  __asm { FMOV            V3.4S, #4.0 }
  v32 = _Q3;
  v19 = vaddq_f32(v15, vsqrtq_f32(vaddq_f32(vmulq_f32(v17, vmulq_f32(v17, vmulq_f32(v17, _Q3))), vmulq_f32(v15, v15))));
  v17.i64[0] = 0x3F0000003F000000;
  v17.i64[1] = 0x3F0000003F000000;
  v20 = (float32x4_t)_simd_pow_f4((simd_float4)vmulq_f32(v19, v17), (simd_float4)vdupq_n_s64(0x3EAAAAAB3EAAAAABuLL));
  v22 = vmulq_f32(a5, v30);
  v23 = (int8x16_t)vsubq_f32(vsubq_f32(vdivq_f32(v20, v22), vdivq_f32(vsubq_f32(a3, vdivq_f32(v29, v22)), v20)), vdivq_f32(a4, v22));
  v24 = (int8x16_t)vdivq_f32(vsubq_f32(vsqrtq_f32(vsubq_f32(vmulq_f32(a3, a3), vmulq_f32(vsubq_f32(a2, a1), vmulq_f32(a4, v32)))), a3), vaddq_f32(a4, a4));
  v25 = (int8x16_t)vdivq_f32(v36, a3);
  v26 = (float32x4_t)v23;
  if (a5.f32[1] == 0.0)
  {
    v26.i32[0] = 0;
    v26 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.f32, 1), v26), 0), v25, v24);
  }
  if (a5.f32[2] == 0.0)
    v21 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a4, 2);
  v21.i32[0] = 0;
  result.n64_u32[0] = vbslq_s8((int8x16_t)vceqq_f32(a5, v21), vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(a4, v21), 0), v25, v24), v23).u32[0];
  result.n64_u32[1] = v26.u32[1];
  return result;
}

double cikernel::_colorCrossPolynomial(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, float32x4_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float32x4_t a17, float32x4_t a18, float32x4_t a19)
{
  double result;

  *(_QWORD *)&result = vaddq_f32(a19, vaddq_f32(vmulq_n_f32(a18, vmuls_lane_f32(a1.f32[0], a1, 2)), vaddq_f32(vmulq_n_f32(a17, vmuls_lane_f32(a1.f32[1], a1, 2)), vaddq_f32(vmulq_n_f32(a8, vmuls_lane_f32(a1.f32[0], *(float32x2_t *)a1.f32, 1)), vaddq_f32(vmulq_n_f32(a7, vmuls_lane_f32(a1.f32[2], a1, 2)), vaddq_f32(vmulq_n_f32(a6, vmuls_lane_f32(a1.f32[1], *(float32x2_t *)a1.f32, 1)), vaddq_f32(vmulq_n_f32(a5, vmulq_f32(a1, a1).f32[0]), vaddq_f32(vmulq_laneq_f32(a4, a1, 2), vaddq_f32(vmulq_n_f32(a2, a1.f32[0]), vmulq_lane_f32(a3, *(float32x2_t *)a1.f32, 1)))))))))).u64[0];
  return result;
}

void CI::f4_s_f3_f3_f3_f3_f3_f3_f3_f3_f3_f3(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double);
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  CI *v23;
  uint64_t v24;
  __n128 *v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_QWORD *)(v9 + 32);
  v14 = *(_QWORD *)(v9 + 56);
  v15 = *(_QWORD *)(v9 + 80);
  v16 = *(_QWORD *)(v9 + 104);
  v17 = *(_QWORD *)(v9 + 128);
  v18 = *(_QWORD *)(v9 + 152);
  v19 = *(_QWORD *)(v9 + 176);
  v20 = *(_QWORD *)(v9 + 200);
  v21 = *(_QWORD *)(v9 + 224);
  v22 = *(_QWORD *)(v9 + 248);
  if (*(_BYTE *)(a1 + 64))
  {
    v23 = (CI *)(a3 + 16 * *(_QWORD *)(v9 + 272));
    v30 = *(_QWORD *)(v9 + 80);
    v31 = a3;
    v24 = *(_QWORD *)(v9 + 32);
    v28 = *(_QWORD *)(v9 + 128);
    v29 = *(_QWORD *)(v9 + 200);
    v27 = *(_QWORD *)(v9 + 248);
    CI::setDC(v23, a2);
    v22 = v27;
    v17 = v28;
    v20 = v29;
    v15 = v30;
    v13 = v24;
    a3 = v31;
  }
  v25 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v25 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v26 = v10(*v25, *((__n128 *)a2 + 4 * v13), *((__n128 *)a2 + 4 * v14), *((__n128 *)a2 + 4 * v15), *((__n128 *)a2 + 4 * v16), *((__n128 *)a2 + 4 * v17), *((__n128 *)a2 + 4 * v18), *((__n128 *)a2 + 4 * v19), *((double *)a2 + 8 * v20), *((double *)a2 + 8 * v20 + 1), *((double *)a2 + 8 * v21), *((double *)a2 + 8 * v21 + 1), *((double *)a2 + 8 * v22), *((double *)a2 + 8 * v22 + 1));
  *(_OWORD *)(a3 + 16 * a7) = v26;
}

double cikernel::_colorPosterize(float32x4_t a1, double a2)
{
  float32x4_t v2;
  float32x4_t v3;
  double result;

  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  v3 = vaddq_f32(vmulq_n_f32(a1, *(float *)&a2), v2);
  v3.i32[3] = 0;
  *(_QWORD *)&result = vmulq_lane_f32(vrndmq_f32(v3), *(float32x2_t *)&a2, 1).u64[0];
  return result;
}

double cikernel::_colorThreshold(float32x4_t a1, int32x2_t a2)
{
  double result;

  __asm { FMOV            V2.4S, #1.0 }
  *(_QWORD *)&result = vbicq_s8(_Q2, (int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(a2, 0)))).u64[0];
  return result;
}

double cikernel::_otsu(cikernel *this, SamplerObj *a2, float32x4_t a3, int8x16_t a4, double a5, int8x16_t a6, int8x16_t a7, int8x16_t a8, int8x16_t a9)
{
  float v9;
  int v10;
  int v12;
  int8x16_t v13;
  double v14;
  float32x4_t v15;
  float v16;
  double v17;
  float32x4_t v18;
  int v19;
  float32x4_t v20;
  double v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float v25;
  double v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  int8x16_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int8x16_t v38;
  int8x16_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;

  v9 = a3.f32[0];
  v10 = (int)a3.f32[0];
  if ((int)a3.f32[0] < 1)
  {
    v20 = 0uLL;
  }
  else
  {
    v12 = 0;
    v13 = 0uLL;
    v14 = 0.0;
    v15 = 0uLL;
    do
    {
      v44 = v15;
      v46 = (float32x4_t)v13;
      v16 = v14 + 0.5;
      LODWORD(a5) = *((_DWORD *)this + 6);
      a8.i32[0] = *((_DWORD *)this + 9);
      *(float *)a7.i32 = *((float *)this + 8) * 0.5;
      *(float *)a6.i32 = *(float *)a7.i32 + (float)(v16 * *((float *)this + 7));
      *(float *)&v17 = *(float *)&a5
                     + (float)((float)(*((float *)this + 5) * 0.5) + (float)(v16 * *((float *)this + 4)));
      *(float *)a4.i32 = *(float *)a8.i32 + *(float *)a6.i32;
      *((float *)&v17 + 1) = *(float *)a8.i32 + *(float *)a6.i32;
      *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v17, (float64x2_t)a4, a5, *(double *)a6.i64, a7, *(uint8x8_t *)a8.i8, *(double *)a9.i64, v13);
      v13 = (int8x16_t)vaddq_f32(v46, v18);
      v15 = vaddq_f32(v44, vmulq_n_f32(v18, (float)v12));
      v14 = v14 + 1.0;
      ++v12;
    }
    while (v10 != v12);
    v19 = 0;
    v20 = 0uLL;
    v21 = 0.0;
    v22 = 0uLL;
    v23 = 0uLL;
    v24 = 0uLL;
    v45 = v15;
    v47 = (float32x4_t)v13;
    do
    {
      v40 = (int8x16_t)v20;
      v41 = v24;
      v42 = v23;
      v43 = v22;
      v25 = v21 + 0.5;
      v20.i32[0] = *((_DWORD *)this + 6);
      a8.i32[0] = *((_DWORD *)this + 9);
      *(float *)a7.i32 = *((float *)this + 8) * 0.5;
      *(float *)a6.i32 = *(float *)a7.i32 + (float)(v25 * *((float *)this + 7));
      *(float *)&v26 = v20.f32[0] + (float)((float)(*((float *)this + 5) * 0.5) + (float)(v25 * *((float *)this + 4)));
      *(float *)a4.i32 = *(float *)a8.i32 + *(float *)a6.i32;
      *((float *)&v26 + 1) = *(float *)a8.i32 + *(float *)a6.i32;
      *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v26, (float64x2_t)a4, *(double *)v20.i64, *(double *)a6.i64, a7, *(uint8x8_t *)a8.i8, *(double *)a9.i64, v13);
      v13 = (int8x16_t)v47;
      v28 = vmulq_f32(v42, vsubq_f32(v47, v42));
      v29 = vmulq_f32(v45, v42);
      v30 = vsubq_f32(vmulq_f32(v47, v43), v29);
      v31 = (int8x16_t)vdivq_f32(vmulq_f32(v30, v30), v28);
      v29.i32[0] = 0;
      v32 = v31;
      v32.i32[0] = -1.0;
      v33 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v29, v28)), 0), v31, v32);
      v34 = v33;
      v34.i32[1] = -1.0;
      v28.i32[0] = vextq_s8((int8x16_t)v28, (int8x16_t)v28, 8uLL).u32[0];
      *(int8x8_t *)v28.f32 = vmvn_s8((int8x8_t)vclez_f32(*(float32x2_t *)v28.f32));
      v35 = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(*(int16x4_t *)v28.f32, 2)), v33, v34);
      a6 = v35;
      a6.i32[2] = -1.0;
      a4 = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(*(int16x4_t *)v28.f32, 0)), v35, a6);
      *(int16x4_t *)v35.i8 = vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32((float32x4_t)a4, v41)));
      v36 = v40;
      *(float *)v36.i32 = (float)v19;
      v37 = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(*(int16x4_t *)v35.i8, 0)), v40, v36);
      v38 = v37;
      *(float *)&v38.i32[1] = (float)v19;
      a9 = (int8x16_t)vmovl_s16(vdup_lane_s16(*(int16x4_t *)v35.i8, 1));
      a7 = vbslq_s8(a9, v37, v38);
      a8 = a7;
      *(float *)&a8.i32[2] = (float)v19;
      v20 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(*(int16x4_t *)v35.i8, 2)), a7, a8);
      v24 = vmaxnmq_f32(v41, (float32x4_t)a4);
      v23 = vaddq_f32(v42, v27);
      a3 = vmulq_n_f32(v27, (float)v19);
      v22 = vaddq_f32(v43, a3);
      v21 = v21 + 1.0;
      ++v19;
    }
    while (v10 != v19);
  }
  a3.f32[0] = v9 + -1.0;
  a3.i64[0] = vdivq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a3.f32, 0)).u64[0];
  return *(double *)a3.i64;
}

double cikernel::_otsuThresh(float32x4_t a1, float32x4_t a2)
{
  double result;

  __asm { FMOV            V2.4S, #1.0 }
  *(_QWORD *)&result = vbicq_s8(_Q2, (int8x16_t)vcltzq_f32(vsubq_f32(a1, a2))).u64[0];
  return result;
}

double cikernel::_sobelEdges(uint64x2_t **this, SamplerObj *a2, float a3)
{
  float32x2_t *DC;
  float v5;
  float v6;
  int8x16_t v7;
  uint8x8_t v8;
  float32x2_t v9;
  double v10;
  double v11;
  float32x2_t v12;
  float32x2_t v13;
  float32x2_t v14;
  int8x16_t v15;
  float32x2_t v16;
  float64x2_t v17;
  double v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x4_t v21;
  float64x2_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  uint8x8_t v26;
  double v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x2_t v30;
  float64x2_t v31;
  double v32;
  double v33;
  int8x16_t v34;
  uint8x8_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  float64x2_t v39;
  double v40;
  double v41;
  int8x16_t v42;
  uint8x8_t v43;
  double v44;
  int8x16_t v45;
  float32x4_t v46;
  float64x2_t v47;
  double v48;
  double v49;
  int8x16_t v50;
  uint8x8_t v51;
  double v52;
  int8x16_t v53;
  float32x4_t v54;
  float64x2_t v55;
  double v56;
  double v57;
  int8x16_t v58;
  uint8x8_t v59;
  double v60;
  int8x16_t v61;
  float32x4_t v62;
  float64x2_t v63;
  double v64;
  double v65;
  int8x16_t v66;
  uint8x8_t v67;
  double v68;
  int8x16_t v69;
  float32x4_t v70;
  float64x2_t v71;
  double v72;
  double v73;
  int8x16_t v74;
  uint8x8_t v75;
  double v76;
  int8x16_t v77;
  float32x4_t v78;
  float64x2_t v79;
  double v80;
  double v81;
  int8x16_t v82;
  uint8x8_t v83;
  double v84;
  int8x16_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  double result;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x2_t v99;

  DC = (float32x2_t *)CI::getDC((CI *)this);
  v5 = *((float *)this + 4);
  v6 = *((float *)this + 5);
  v7.i32[0] = *((_DWORD *)this + 6);
  v8.i32[0] = *((_DWORD *)this + 7);
  v9.f32[0] = *(float *)v7.i32 + vmlas_n_f32(vmuls_lane_f32(v6, *DC, 1), v5, COERCE_FLOAT(*DC));
  LODWORD(v10) = *((_DWORD *)this + 8);
  LODWORD(v11) = *((_DWORD *)this + 9);
  v9.f32[1] = *(float *)&v11 + vmlas_n_f32(vmuls_lane_f32(*(float *)&v10, *DC, 1), *(float *)v8.i32, COERCE_FLOAT(*DC));
  v12 = vadd_f32(*DC, (float32x2_t)1065353216);
  v13.f32[0] = *(float *)v7.i32 + vmlas_n_f32(vmuls_lane_f32(v6, v12, 1), v5, v12.f32[0]);
  v13.f32[1] = *(float *)&v11 + vmlas_n_f32(vmuls_lane_f32(*(float *)&v10, v12, 1), *(float *)v8.i32, v12.f32[0]);
  v14 = vsub_f32(v13, v9);
  v15.i64[0] = 0x3F80000000000000;
  v16 = vadd_f32(*DC, (float32x2_t)0x3F80000000000000);
  *(float *)v17.f64 = *(float *)v7.i32 + vmlas_n_f32(vmuls_lane_f32(v6, v16, 1), v5, v16.f32[0]);
  *(float *)&v18 = vmlas_n_f32(vmuls_lane_f32(*(float *)&v10, v16, 1), *(float *)v8.i32, v16.f32[0]);
  *((float *)v17.f64 + 1) = *(float *)&v11 + *(float *)&v18;
  v99 = v9;
  v19 = vsub_f32(*(float32x2_t *)&v17.f64[0], v9);
  v20 = vadd_f32(v19, v14);
  *(double *)v21.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v9, v20)), v17, v18, v10, v7, v8, v11, v15);
  v97 = v21;
  *(double *)v29.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v99, v20)), v22, v23, v24, v25, v26, v27, v28);
  v96 = v29;
  v30 = vsub_f32(v14, v19);
  *(double *)v38.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v99, v30)), v31, v32, v33, v34, v35, v36, v37);
  v95 = v38;
  *(double *)v46.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v99, v30)), v39, v40, v41, v42, v43, v44, v45);
  v94 = v46;
  *(double *)v54.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v99, v19)), v47, v48, v49, v50, v51, v52, v53);
  v93 = v54;
  *(double *)v62.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v99, v19)), v55, v56, v57, v58, v59, v60, v61);
  v92 = v62;
  *(double *)v70.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vadd_f32(v99, v14)), v63, v64, v65, v66, v67, v68, v69);
  v91 = v70;
  *(double *)v78.i64 = CI::BitmapSampler::read(this[1], COERCE_DOUBLE(vsub_f32(v99, v14)), v71, v72, v73, v74, v75, v76, v77);
  v90 = v78;
  *(double *)v86.i64 = CI::BitmapSampler::read(this[1], *(double *)&v99, v79, v80, v81, v82, v83, v84, v85);
  v87 = vsubq_f32(vaddq_f32(v95, vaddq_f32(v97, vaddq_f32(v91, v91))), vaddq_f32(v96, vaddq_f32(v94, vaddq_f32(v90, v90))));
  v88 = vsubq_f32(vaddq_f32(v97, vaddq_f32(v94, vaddq_f32(v93, v93))), vaddq_f32(v95, vaddq_f32(v96, vaddq_f32(v92, v92))));
  *(_QWORD *)&result = vmulq_laneq_f32(vmulq_n_f32(vsqrtq_f32(vaddq_f32(vmulq_f32(v88, v88), vmulq_f32(v87, v87))), a3), v86, 3).u64[0];
  return result;
}

double cikernel::_noiseComicReduction(uint64_t a1, double a2, float32x4_t a3, __n128 a4)
{
  int8x16_t v5;
  double v6;
  double v7;
  double v8;
  float64x2_t v9;
  uint8x8_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  float64x2_t v14;
  double v15;
  double v16;
  uint8x8_t v17;
  int8x16_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float64x2_t v22;
  double v23;
  double v24;
  uint8x8_t v25;
  int8x16_t v26;
  double v27;
  int8x16_t v28;
  float32x4_t v29;
  float64x2_t v30;
  double v31;
  double v32;
  uint8x8_t v33;
  int8x16_t v34;
  double v35;
  int8x16_t v36;
  float32x4_t v37;
  float64x2_t v38;
  double v39;
  double v40;
  uint8x8_t v41;
  int8x16_t v42;
  double v43;
  int8x16_t v44;
  float32x4_t v45;
  float64x2_t v46;
  double v47;
  double v48;
  uint8x8_t v49;
  int8x16_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float64x2_t v53;
  double v54;
  double v55;
  uint8x8_t v56;
  int8x16_t v57;
  double v58;
  int8x16_t v59;
  float32x4_t v60;
  float64x2_t v61;
  double v62;
  double v63;
  uint8x8_t v64;
  int8x16_t v65;
  double v66;
  int8x16_t v67;
  float32x4_t v68;
  float64x2_t v69;
  double v70;
  double v71;
  uint8x8_t v72;
  int8x16_t v73;
  double v74;
  int8x16_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float v85;
  float v86;
  double result;
  float32x4_t v88;
  float64x2_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  int32x2_t v99;
  float64x2_t v101;

  v5.i64[0] = *(_QWORD *)CI::getDC((CI *)a1);
  v101 = (float64x2_t)v5;
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  *(float *)&v7 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v5.i8, 1), *(float *)(a1 + 16), *(float *)v5.i32);
  LODWORD(v8) = *(_DWORD *)(a1 + 36);
  *(float *)v9.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v5.i8, 1), *(float *)&v6, *(float *)v5.i32);
  HIDWORD(v7) = LODWORD(v9.f64[0]);
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v7, v9, v6, v8, v5, v10, v11, v12);
  v96 = v13;
  v13.i32[0] = 0;
  v13.f32[1] = -*(float *)&a2;
  v14 = v101;
  *(float32x2_t *)v13.f32 = vadd_f32(*(float32x2_t *)v13.f32, *(float32x2_t *)&v101.f64[0]);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v13.f32, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v13.f32, 1), *(float *)&v16, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v15;
  *(float *)v14.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v13.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, v14, v15, v16, v18, v17, v19, v20);
  v95 = v21;
  v22 = v101;
  *(float32x2_t *)v21.f32 = vadd_f32((float32x2_t)vzip1_s32(0, *(int32x2_t *)&a2), *(float32x2_t *)&v101.f64[0]);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v21.f32, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v21.f32, 1), *(float *)&v24, v21.f32[0]);
  v21.f32[0] = *(float *)(a1 + 24) + *(float *)&v23;
  *(float *)v22.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v21.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v22, v23, v24, v26, v25, v27, v28);
  v94 = v29;
  *(_QWORD *)&v30.f64[0] = COERCE_UNSIGNED_INT(-*(float *)&a2);
  *(float32x2_t *)v29.f32 = vadd_f32(*(float32x2_t *)&v30.f64[0], *(float32x2_t *)&v101.f64[0]);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v29.f32, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 28);
  v33.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v29.f32, 1), *(float *)&v32, v29.f32[0]);
  v29.f32[0] = *(float *)(a1 + 24) + *(float *)&v31;
  *(float *)v30.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v29.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v30, v31, v32, v34, v33, v35, v36);
  v93 = v37;
  v38 = v101;
  *(float32x2_t *)v37.f32 = vadd_f32((float32x2_t)LODWORD(a2), *(float32x2_t *)&v101.f64[0]);
  *(float *)&v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v37.f32, 1), *(float *)(a1 + 16), v37.f32[0]);
  LODWORD(v40) = *(_DWORD *)(a1 + 28);
  v41.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v37.f32, 1), *(float *)&v40, v37.f32[0]);
  v37.f32[0] = *(float *)(a1 + 24) + *(float *)&v39;
  *(float *)v38.f64 = *(float *)v41.i32 + *(float *)v42.i32;
  v37.f32[1] = *(float *)v41.i32 + *(float *)v42.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v37.i64, v38, v39, v40, v42, v41, v43, v44);
  v92 = v45;
  *(int32x2_t *)&v46.f64[0] = vdup_lane_s32(*(int32x2_t *)&a2, 1);
  v89 = v46;
  *(float32x2_t *)v45.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], *(float32x2_t *)&v101.f64[0]);
  *(float *)&v47 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v45.f32, 1), *(float *)(a1 + 16), v45.f32[0]);
  LODWORD(v48) = *(_DWORD *)(a1 + 28);
  v49.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v45.f32, 1), *(float *)&v48, v45.f32[0]);
  v45.f32[0] = *(float *)(a1 + 24) + *(float *)&v47;
  *(float *)v46.f64 = *(float *)v49.i32 + *(float *)v50.i32;
  v45.f32[1] = *(float *)v49.i32 + *(float *)v50.i32;
  *(double *)v52.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v46, v47, v48, v50, v49, a2, v51);
  v91 = v52;
  v52.f32[0] = -*((float *)&a2 + 1);
  v99 = *(int32x2_t *)v52.f32;
  v53 = v89;
  *((float *)v53.f64 + 1) = -*((float *)&a2 + 1);
  *(float32x2_t *)v52.f32 = vadd_f32(*(float32x2_t *)&v53.f64[0], *(float32x2_t *)&v101.f64[0]);
  *(float *)&v54 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v52.f32, 1), *(float *)(a1 + 16), v52.f32[0]);
  LODWORD(v55) = *(_DWORD *)(a1 + 28);
  v56.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v52.f32, 1), *(float *)&v55, v52.f32[0]);
  v52.f32[0] = *(float *)(a1 + 24) + *(float *)&v54;
  *(float *)v53.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v52.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v60.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v52.i64, v53, v54, v55, v57, v56, v58, v59);
  v90 = v60;
  v61 = v101;
  *(float32x2_t *)v60.f32 = vadd_f32((float32x2_t)vdup_lane_s32(v99, 0), *(float32x2_t *)&v101.f64[0]);
  *(float *)&v62 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v60.f32, 1), *(float *)(a1 + 16), v60.f32[0]);
  LODWORD(v63) = *(_DWORD *)(a1 + 28);
  v64.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v60.f32, 1), *(float *)&v63, v60.f32[0]);
  v60.f32[0] = *(float *)(a1 + 24) + *(float *)&v62;
  *(float *)v61.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v60.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v68.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v60.i64, v61, v62, v63, v65, v64, v66, v67);
  v88 = v68;
  v69 = v101;
  *(float32x2_t *)v68.f32 = vadd_f32(*(float32x2_t *)&a2, *(float32x2_t *)&v101.f64[0]);
  *(float *)&v70 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v68.f32, 1), *(float *)(a1 + 16), v68.f32[0]);
  LODWORD(v71) = *(_DWORD *)(a1 + 28);
  v72.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v73.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v68.f32, 1), *(float *)&v71, v68.f32[0]);
  v68.f32[0] = *(float *)(a1 + 24) + *(float *)&v70;
  *(float *)v69.f64 = *(float *)v72.i32 + *(float *)v73.i32;
  v68.f32[1] = *(float *)v72.i32 + *(float *)v73.i32;
  *(double *)v76.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v68.i64, v69, v70, v71, v73, v72, v74, v75);
  v77 = vaddq_f32(vmulq_laneq_f32(v96, a3, 2), vaddq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(v95, v94), v93), v92), a3.f32[0]), vmulq_lane_f32(vaddq_f32(vaddq_f32(vaddq_f32(v91, v90), v88), v76), *(float32x2_t *)a3.f32, 1)));
  _Q0 = vabdq_f32(v77, v96);
  _Q0.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)_Q0, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q0.f32, 1), _Q0)).u32[0];
  _V3.S[1] = a4.n128_u32[1];
  __asm { FMLA            S2, S0, V3.S[1] }
  if (_S2 <= 1.0)
    v85 = _S2;
  else
    v85 = 1.0;
  if (_S2 >= a4.n128_f32[2])
    v86 = v85;
  else
    v86 = a4.n128_f32[2];
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v96, 1.0 - v86), v77, v86).u64[0];
  return result;
}

void CI::f4_sr_f2_f3_f3(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, double, __n128, __n128);
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double *v18;
  __int128 v19;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, double, __n128, __n128))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_DWORD *)(v11 + 40);
  v15 = *(_QWORD *)(v11 + 32);
  v16 = *(_QWORD *)(v11 + 56);
  v17 = *(_QWORD *)(v11 + 80);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 104)), a2);
  v18 = (double *)(a3 + 16 * v15);
  if (v14 != 5)
    v18 = (double *)((char *)a2 + 64 * v15);
  *(double *)&v19 = v12(a4 + 80 * v13, *v18, *((__n128 *)a2 + 4 * v16), *((__n128 *)a2 + 4 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_colorControls()
{
  return 0.0;
}

double cikernel::_spotColor(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int8x16_t a17)
{
  int32x2_t v17;
  float32x2_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float v22;
  float v23;
  BOOL v24;
  float v25;
  float32x4_t v26;
  float32x4_t v27;
  int8x16_t v28;
  float32x4_t v29;
  int8x16_t v30;
  float32x2_t v31;
  float v32;
  int32x2_t v33;
  float32x4_t v34;
  float32x4_t v35;
  double result;

  v18.i32[1] = a17.i32[1];
  *(float *)v17.i32 = fmaxf(a1.f32[3], 0.00001);
  v19 = vdivq_f32(a1, (float32x4_t)vdupq_lane_s32(v17, 0));
  v20 = vsubq_f32(v19, a2);
  v21 = vmulq_f32(v20, v20);
  v22 = (float)((float)(*(float *)a8.i32
                      - sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).f32[0]))* *(float *)a17.i32)+ 0.5;
  if (v22 <= 1.0)
    v23 = v22;
  else
    v23 = 1.0;
  v24 = v22 < 0.0;
  v25 = 0.0;
  if (v24)
    v23 = 0.0;
  v26 = vmulq_n_f32(a3, v23);
  v27 = vsubq_f32(v19, a4);
  v28 = (int8x16_t)vmulq_f32(v27, v27);
  v29 = vsubq_f32(v19, a6);
  v30 = (int8x16_t)vmulq_f32(v29, v29);
  a8.i32[0] = vextq_s8(a8, a8, 8uLL).u32[0];
  v18.i32[0] = vextq_s8(a17, a17, 8uLL).u32[0];
  v31 = vadd_f32(vmul_f32(v18, vsub_f32(*(float32x2_t *)a8.i8, vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL)), vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v30.i8, *(int32x2_t *)v28.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v30.i8, *(int32x2_t *)v28.i8)))))), (float32x2_t)0x3F0000003F000000);
  v32 = v31.f32[1];
  v33 = vcltz_f32(v31);
  if (v31.f32[1] > 1.0)
    v32 = 1.0;
  if ((v33.i8[4] & 1) != 0)
    v32 = 0.0;
  v34 = vmulq_n_f32(a5, v32);
  if (v31.f32[0] > 1.0)
    v31.f32[0] = 1.0;
  if ((v33.i8[0] & 1) == 0)
    v25 = v31.f32[0];
  v35 = vmulq_n_f32(a7, v25);
  v31.f32[0] = 1.0 - v26.f32[3];
  *(_QWORD *)&result = vaddq_f32(v35, vmulq_n_f32(vaddq_f32(v34, vmulq_n_f32(vaddq_f32(v26, (float32x4_t)vdupq_lane_s32((int32x2_t)v31, 0)), 1.0 - v34.f32[3])), 1.0 - v35.f32[3])).u64[0];
  return result;
}

void CI::f4_s_clr_clr_clr_clr_clr_clr_f4_f4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double);
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const vec2 *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  double *v23;
  __n128 *v24;
  __n128 *v25;
  __int128 v26;
  double (*v27)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double);
  int v28;
  uint64_t v29;
  const vec2 *v30;
  uint64_t v31;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_QWORD *)(v9 + 32);
  v14 = *(_QWORD *)(v9 + 56);
  v15 = *(_QWORD *)(v9 + 80);
  v16 = *(const vec2 **)(v9 + 104);
  v17 = *(_QWORD *)(v9 + 128);
  v18 = *(_QWORD *)(v9 + 152);
  v19 = *(_DWORD *)(v9 + 184);
  v20 = *(_QWORD *)(v9 + 176);
  v21 = *(_DWORD *)(v9 + 208);
  v22 = *(_QWORD *)(v9 + 200);
  if (*(_BYTE *)(a1 + 64))
  {
    v27 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double))(a1 + 24);
    v30 = *(const vec2 **)(v9 + 104);
    v31 = *(_QWORD *)(v9 + 80);
    v29 = *(_QWORD *)(v9 + 56);
    v28 = *(_DWORD *)(v9 + 184);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 224)), v16);
    v19 = v28;
    v14 = v29;
    v16 = v30;
    v15 = v31;
    v10 = v27;
  }
  v23 = (double *)(a3 + 16 * v22);
  if (v21 != 5)
    v23 = (double *)(a2 + (v22 << 6));
  v24 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5)
    v24 = (__n128 *)(a2 + (v20 << 6));
  v25 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v25 = (__n128 *)(a2 + (v12 << 6));
  *(double *)&v26 = v10(*v25, *(__n128 *)(a2 + (v13 << 6)), *(__n128 *)(a2 + (v14 << 6)), *(__n128 *)(a2 + (v15 << 6)), *(__n128 *)(a2 + ((_QWORD)v16 << 6)), *(__n128 *)(a2 + (v17 << 6)), *(__n128 *)(a2 + (v18 << 6)), *v24, *v23, v23[1]);
  *(_OWORD *)(a3 + 16 * a7) = v26;
}

void sub_19224BC7C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19224C148(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19224C1A4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19224C1F0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_19224C2E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CoreAnalytics(NSString *a1, CIContext *a2)
{
  unsigned __int8 v2;
  void *v3;
  NSObject *v4;
  int v5;
  int v6;
  CIContext *v7;
  NSString *v8;
  _QWORD block[6];

  if (a1)
  {
    if ((v2 & 1) == 0)
    {
      v7 = a2;
      v8 = a1;
      v6 = v5;
      a2 = v7;
      a1 = v8;
      if (v6)
      {
        CoreAnalytics(NSString *,CIContext *)::queue = (uint64_t)dispatch_queue_create("CoreImageAnalytics", 0);
        a2 = v7;
        a1 = v8;
      }
    }
    v4 = *((_QWORD *)v3 + 53);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___ZL13CoreAnalyticsP8NSStringP9CIContext_block_invoke;
    block[3] = &unk_1E2EC2EE0;
    block[4] = a2;
    block[5] = a1;
    dispatch_async(v4, block);
  }
}

void sub_19224E6C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_19224E738(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_19224F70C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10F1C4003C5734DLL);
  _Unwind_Resume(a1);
}

void sub_19224FCF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40CDAF8E61);
  _Unwind_Resume(a1);
}

void sub_19224FEC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10F1C4003C5734DLL);
  _Unwind_Resume(a1);
}

uint64_t ___ZL13CoreAnalyticsP8NSStringP9CIContext_block_invoke()
{
  return AnalyticsSendEventLazy();
}

uint64_t ___ZL13CoreAnalyticsP8NSStringP9CIContext_block_invoke_2(uint64_t a1)
{
  const __CFString *v2;
  uint64_t v3;
  const __CFString *v4;
  void *v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  _QWORD v15[8];
  _QWORD v16[9];

  v16[8] = *MEMORY[0x1E0C80C00];
  v2 = (const __CFString *)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle"), "bundleIdentifier");
  v3 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle"), "bundlePath"), "pathExtension");
  v4 = CoreAnayticsAppIndentifier(v2);
  v5 = (void *)objc_msgSend(MEMORY[0x1E0CA58E0], "extensionPointRecordForCurrentProcess");
  if (v5)
    v6 = objc_msgSend(v5, "identifier");
  else
    v6 = 0;
  result = objc_msgSend(*(id *)(a1 + 32), "_internalContext");
  if (result)
  {
    v8 = result;
    v15[0] = CFSTR("identifier");
    v15[1] = CFSTR("extension");
    v9 = &stru_1E2ECD1B0;
    if (v2)
      v10 = v2;
    else
      v10 = &stru_1E2ECD1B0;
    if (v3)
      v11 = (const __CFString *)v3;
    else
      v11 = &stru_1E2ECD1B0;
    if (v6)
      v11 = (const __CFString *)v6;
    v16[0] = v10;
    v16[1] = v11;
    if (v4)
      v9 = v4;
    v15[2] = CFSTR("client");
    v15[3] = CFSTR("contextMethod");
    v12 = *(_QWORD *)(a1 + 40);
    v16[2] = v9;
    v16[3] = v12;
    v15[4] = CFSTR("cacheIntermediates");
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)result + 232))(result) == -1)
      v13 = &unk_1E2F1B5C0;
    else
      v13 = &unk_1E2F1B5D8;
    v16[4] = v13;
    v15[5] = CFSTR("workingFormat");
    v16[5] = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", CI::name_for_format(*(_DWORD *)(v8 + 32)));
    v15[6] = CFSTR("backing");
    v16[6] = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 304))(v8));
    v15[7] = CFSTR("coreui");
    if (!strcmp((const char *)(v8 + 236), "CoreUI"))
      v14 = &unk_1E2F1B5D8;
    else
      v14 = &unk_1E2F1B5C0;
    v16[7] = v14;
    return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v16, v15, 8);
  }
  return result;
}

uint64_t ___ZL19set_context_optionsPN2CI9GLContextEP12NSDictionary_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 208))(*(_QWORD *)(a1 + 32));
}

uint64_t ___ZL19set_context_optionsPN2CI9GLContextEP12NSDictionary_block_invoke_2(uint64_t result, char a2)
{
  *(_BYTE *)(*(_QWORD *)(result + 32) + 41) = a2;
  return result;
}

uint64_t ___ZL19set_context_optionsPN2CI9GLContextEP12NSDictionary_block_invoke_340(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 160))(*(_QWORD *)(a1 + 32));
}

void OUTLINED_FUNCTION_2_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

void OUTLINED_FUNCTION_3_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x16u);
}

void OUTLINED_FUNCTION_4_1(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x20u);
}

void OUTLINED_FUNCTION_9(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void sub_1922516AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  CI::create_cgimage(CIContext *,CIImage *,CGRect,CGColorSpace *,int,BOOL,CI::Trilean,void({block_pointer})(CGRect,NSError *))::SignpostTimer::~SignpostTimer((TimerBase *)(v1 - 224));
  _Block_object_dispose((const void *)(v1 - 256), 8);
  _Unwind_Resume(a1);
}

const __CFString *_block_invoke_2(uint64_t a1, void *a2)
{
  const __CFString *v2;
  const __CFString *v3;

  v2 = (const __CFString *)objc_msgSend(a2, "description");
  return CI::Context::AbortIfUnhandledError(v2, v3);
}

void ___ZN2CIL14create_cgimageEP9CIContextP7CIImage6CGRectP12CGColorSpaceibNS_7TrileanEU13block_pointerFvS4_P7NSErrorE_block_invoke(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  unsigned int v12;
  NSObject *v13;
  os_signpost_id_t v14;
  uint64_t v15;
  void **v16;
  int v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v11 = *(unsigned int *)(a1 + 64);
  if (((*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 264))(*(_QWORD *)(a1 + 40)) & 1) != 0
    || (CI::format_has_alpha(*(_DWORD *)(a1 + 68)) & 1) == 0)
  {
    if ((_DWORD)v11 == 264)
      v12 = 268;
    else
      v12 = v11;
    if (v12 == 266)
      v12 = 270;
    if (v12 == 265)
      v12 = 269;
    if (v12 == 267)
      v12 = 271;
    if (v12 == 784)
      v12 = 775;
    if (v12 == 1800)
      v12 = 1804;
    if (v12 == 2056)
      v12 = 2060;
    if (v12 == 2312)
      v12 = 2316;
    if (v12 == 260)
      v12 = 259;
    if (v12 == 1796)
      v12 = 1795;
    if (v12 == 2052)
      v12 = 2051;
    if (v12 == 2308)
      v11 = 2307;
    else
      v11 = v12;
  }
  v13 = ci_signpost_log_render();
  v14 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 272))(*(_QWORD *)(a1 + 48)) << 32;
  if (v14 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v13))
  {
    v17 = 134218240;
    v18 = a4;
    v19 = 2048;
    v20 = a5;
    _os_signpost_emit_with_name_impl(&dword_1921E4000, v13, OS_SIGNPOST_INTERVAL_BEGIN, v14, "new_bitmap", "[%zu %zu]", (uint8_t *)&v17, 0x16u);
  }
  v15 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 272))(*(_QWORD *)(a1 + 48));
  TimerBase::TimerBase((uint64_t)&v17, v15, 0, (uint64_t)"new_bitmap", 0);
  v16 = (void **)operator new();
  CI::Bitmap::Bitmap(v16, a4, a5, v11, *(unsigned __int8 *)(a1 + 72), *(_QWORD *)(a1 + 56), a6);
  _ZZZN2CIL14create_cgimageEP9CIContextP7CIImage6CGRectP12CGColorSpaceibNS_7TrileanEU13block_pointerFvS4_P7NSErrorEEUb_EN13SignpostTimerD1Ev((TimerBase *)&v17);
  memcpy(v16[9], a2, a6 * a5);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CI::Bitmap::create_CGImage((CI::Bitmap *)v16);
  CI::Object::unref((CI::Object *)v16);
}

void sub_192251DFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  MEMORY[0x194025AAC](v9, 0x10E1C40ABAAFD7FLL);
  _ZZZN2CIL14create_cgimageEP9CIContextP7CIImage6CGRectP12CGColorSpaceibNS_7TrileanEU13block_pointerFvS4_P7NSErrorEEUb_EN13SignpostTimerD1Ev((TimerBase *)&a9);
  _Unwind_Resume(a1);
}

void _ZZZN2CIL14create_cgimageEP9CIContextP7CIImage6CGRectP12CGColorSpaceibNS_7TrileanEU13block_pointerFvS4_P7NSErrorEEUb_EN13SignpostTimerD1Ev(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  v2 = ci_signpost_log_render();
  v3 = *((_QWORD *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "new_bitmap", (const char *)&unk_192520C83, v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_192251EC0(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void CI::create_cgimage(CIContext *,CIImage *,CGRect,CGColorSpace *,int,BOOL,CI::Trilean,void({block_pointer})(CGRect,NSError *))::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  v2 = ci_signpost_log_render();
  v3 = *((_QWORD *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "create_cgimage_check", (const char *)&unk_192520C83, v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_192251F5C(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void __CFDictionary::setValue(__CFDictionary *this, __CFDictionary *a2, const __CFString *a3, const void *a4)
{
  const void **v4;
  const void *v5;

  v4 = (const void **)MEMORY[0x1E0C9AE50];
  if (!(_DWORD)a3)
    v4 = (const void **)MEMORY[0x1E0C9AE40];
  v5 = *v4;
  __CFDictionary::setValue(this, a2, *v4, a4);
  if (v5)
    CFRelease(v5);
}

uint64_t CI::copyImageBlockSetOptsCallback(uint64_t a1, uint64_t a2, const __CFDictionary *a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  double v14;
  CGFloat v15;
  double v16;
  CGFloat v17;
  CGFloat x;
  CGFloat y;
  double width;
  double height;
  int v22;
  int v23;
  uint64_t v24;
  const __CFNumber *Value;
  _BOOL4 v26;
  const __CFNumber *v27;
  const __CFNumber *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  size_t v33;
  void *v34;
  __int128 v35;
  CGFloat v36;
  double v37;
  double v38;
  CGFloat v39;
  CGFloat v40;
  CGFloat v41;
  CGFloat v42;
  NSObject *v43;
  _QWORD *v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD block[14];
  CGRect v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t v59;
  char v60;
  CGAffineTransform v61;
  CGAffineTransform v62;
  __int128 v63;
  unsigned int v64;
  int v65;
  int valuePtr;
  uint64_t v67;
  uint64_t v68;
  CGRect v69;
  CGRect v70;
  CGRect v71;
  CGRect v72;
  CGRect v73;
  CGRect v74;
  CGRect v75;

  v68 = *MEMORY[0x1E0C80C00];
  CGImageProviderGetSize();
  v15 = v14;
  v17 = v16;
  v69.origin.x = a4;
  v69.origin.y = a5;
  v69.size.width = a6;
  v69.size.height = a7;
  v75 = CGRectIntegral(v69);
  v70.origin.x = 0.0;
  v70.origin.y = 0.0;
  v70.size.width = v15;
  v70.size.height = v17;
  v71 = CGRectIntersection(v70, v75);
  x = v71.origin.x;
  y = v71.origin.y;
  width = v71.size.width;
  height = v71.size.height;
  v22 = getpagesize();
  v23 = CI::format_bytes_per_pixel(*(_DWORD *)(a1 + 16));
  v24 = objc_msgSend(*(id *)a1, "_internalContext");
  if (a3)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E0C9DAC8]);
    valuePtr = 0;
    if (Value)
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    if (CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E0C9DAB0]))
      return 0;
    v26 = CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E0C9DAB8]) == (const void *)*MEMORY[0x1E0C9AE50];
    v27 = (const __CFNumber *)CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E0C9DA90]);
    v65 = 0;
    if (v27)
    {
      CFNumberGetValue(v27, kCFNumberIntType, &v65);
      if (v65)
      {
        if (v22 % v65)
          return 0;
      }
    }
    v28 = (const __CFNumber *)CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E0C9DA98]);
  }
  else
  {
    v28 = 0;
    valuePtr = 0;
    v26 = *MEMORY[0x1E0C9AE50] == 0;
    v65 = 0;
  }
  v64 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v24 + 544))(v24, *(unsigned int *)(a1 + 16));
  if (v28)
    CFNumberGetValue(v28, kCFNumberIntType, &v64);
  if (a3 && CFDictionaryContainsKey(a3, (const void *)*MEMORY[0x1E0C9DAA0]))
    return 0;
  v29 = (unint64_t)(width * (double)(unint64_t)v23);
  if ((int)v64 >= 1 && v29 % v64)
    v29 = (v64 + v29 - 1) / v64 * v64;
  v30 = (v29 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  v31 = (v29 + 7) & 0xFFFFFFFFFFFFFFF8;
  v32 = *(_DWORD *)(a1 + 16) == 259 ? v30 : v31;
  v33 = ((unint64_t)((height + 1.0) * (double)v32) + v22 - 1) / v22 * v22;
  v34 = mmap(0, v33, 3, 4098, 1140850688, 0);
  if (v34 == (void *)-1)
    return 0;
  v63 = xmmword_1E2EC3238;
  v35 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
  *(_OWORD *)&v62.a = *MEMORY[0x1E0C9BAA8];
  *(_OWORD *)&v62.c = v35;
  *(_OWORD *)&v62.tx = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 32);
  v36 = x;
  *(CGFloat *)&v35 = y;
  v37 = width;
  v38 = height;
  v72 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v35 - 8), &v62);
  v39 = v72.origin.x;
  v40 = v72.origin.y;
  v41 = v72.size.width;
  v42 = v72.size.height;
  CGAffineTransformMakeTranslation(&v61, *(CGFloat *)(a1 + 32), *(CGFloat *)(a1 + 40));
  v73.origin.x = v39;
  v73.origin.y = v40;
  v73.size.width = v41;
  v73.size.height = v42;
  v74 = CGRectApplyAffineTransform(v73, &v61);
  v57 = 0;
  v58 = &v57;
  v59 = 0x2020000000;
  v60 = 0;
  v43 = *(NSObject **)(a1 + 64);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN2CIL29copyImageBlockSetOptsCallbackEPvP15CGImageProvider6CGRect6CGSizePK14__CFDictionary_block_invoke;
  block[3] = &unk_1E2EC3250;
  *(CGFloat *)&block[6] = x;
  *(CGFloat *)&block[7] = y;
  *(double *)&block[8] = width;
  *(double *)&block[9] = height;
  block[10] = v32;
  block[11] = a1;
  block[12] = a2;
  block[13] = v24;
  v56 = v74;
  block[4] = &v57;
  block[5] = v34;
  dispatch_sync(v43, block);
  if (*((_BYTE *)v58 + 24))
  {
    v44 = malloc_type_calloc(1uLL, 0x10uLL, 0x1080040FC6463CFuLL);
    *v44 = v34;
    v44[1] = v33;
    v67 = CGImageBlockCreate();
    if (v26 && mprotect(v34, v33, 1) == -1)
    {
      v45 = ci_logger_render();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        CI::copyImageBlockSetOptsCallback(v45, v46, v47, v48, v49, v50, v51, v52);
    }
    v53 = CGImageBlockSetCreate();
  }
  else
  {
    munmap(v34, v33);
    v53 = 0;
  }
  _Block_object_dispose(&v57, 8);
  return v53;
}

void sub_19225248C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

__IOSurface *CI::copyIOSurfaceCallback(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  double v5;
  double v6;
  double v7;
  double v8;
  uint64_t v9;
  double v10;
  __IOSurface *Surface;
  const __CFNumber *Value;
  const __CFNumber *v14;
  uint64_t v15;
  int v16;
  int v17;
  int default_ycc_color_matrix;
  __int128 v19;
  uint64_t v20;
  double v21;
  double v22;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CGFloat v27;
  CGFloat v28;
  CGFloat v29;
  CGFloat v30;
  CGColorSpace *ColorSpace;
  CGColorSpace *v32;
  CFPropertyListRef v33;
  const void *v34;
  NSObject *v35;
  _QWORD v36[12];
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  char v40;
  CGAffineTransform v41;
  CGAffineTransform v42;
  uint64_t v43;
  CGRect v44;
  CGRect v45;
  CGRect v46;

  CGImageProviderGetSize();
  v6 = v5;
  v8 = v7;
  v9 = objc_msgSend(*(id *)a1, "_internalContext");
  if (v6 <= v8)
    v10 = v8;
  else
    v10 = v6;
  if (v10 > (double)(unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 440))(v9))
    return 0;
  v43 = 16;
  if (!a3)
    goto LABEL_15;
  Value = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("kCGImageSurfaceFormatRequest"));
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberSInt32Type, (char *)&v43 + 4);
    Value = (const __CFNumber *)HIDWORD(v43);
  }
  if (!CI::format_from_PixelFormatType(Value))
    HIDWORD(v43) = 0;
  v14 = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("kCGImageSurfaceBytesPerRowAlignmentRequest"));
  if (v14)
    CFNumberGetValue(v14, kCFNumberSInt32Type, &v43);
  v15 = HIDWORD(v43);
  if (!HIDWORD(v43))
  {
LABEL_15:
    v15 = CI::PixelFormatType_from_format(*(_DWORD *)(a1 + 16));
    if (!(_DWORD)v15)
      v15 = CI::PixelFormatType_approx_from_format(*(_DWORD *)(a1 + 16));
  }
  Surface = 0;
  if ((_DWORD)v15 && (v15 & 0xFF000000) != 0x63000000)
  {
    v16 = CI::format_from_PixelFormatType((CI *)v15);
    if (!v16)
      return 0;
    v17 = v16;
    Surface = CreateSurface((__CVBuffer *)v6, (__CVBuffer *)v8, (void *)(int)v43, v15, 1);
    if (Surface)
    {
      default_ycc_color_matrix = CI::format_get_default_ycc_color_matrix(v17);
      if (default_ycc_color_matrix)
        SurfaceSetYCCMatrix(Surface, default_ycc_color_matrix);
      v19 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
      *(_OWORD *)&v42.a = *MEMORY[0x1E0C9BAA8];
      *(_OWORD *)&v42.c = v19;
      *(_OWORD *)&v42.tx = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 32);
      v20 = 0;
      *(_QWORD *)&v19 = 0;
      v21 = v6;
      v22 = v8;
      v44 = CGRectApplyAffineTransform(*(CGRect *)((char *)&v19 - 8), &v42);
      x = v44.origin.x;
      y = v44.origin.y;
      width = v44.size.width;
      height = v44.size.height;
      CGAffineTransformMakeTranslation(&v41, *(CGFloat *)(a1 + 32), *(CGFloat *)(a1 + 40));
      v45.origin.x = x;
      v45.origin.y = y;
      v45.size.width = width;
      v45.size.height = height;
      v46 = CGRectApplyAffineTransform(v45, &v41);
      v27 = v46.origin.x;
      v28 = v46.origin.y;
      v29 = v46.size.width;
      v30 = v46.size.height;
      ColorSpace = (CGColorSpace *)CGImageProviderGetColorSpace();
      v32 = ColorSpace;
      if (ColorSpace)
      {
        v33 = CGColorSpaceCopyPropertyList(ColorSpace);
        if (v33)
        {
          v34 = v33;
          IOSurfaceSetValue(Surface, (CFStringRef)*MEMORY[0x1E0CBBF90], v33);
          CFRelease(v34);
        }
      }
      if (objc_msgSend(*(id *)(a1 + 8), "isOpaque") && (CI::format_has_alpha(v17) & 1) != 0
        || CI::format_has_x(*(_DWORD *)(a1 + 16)))
      {
        IOSurfaceSetValue(Surface, CFSTR("IOSurfaceAlphaIsOpaque"), (CFTypeRef)*MEMORY[0x1E0C9AE50]);
      }
      v37 = 0;
      v38 = &v37;
      v39 = 0x2020000000;
      v40 = 0;
      v35 = *(NSObject **)(a1 + 64);
      v36[0] = MEMORY[0x1E0C809B0];
      v36[1] = 3221225472;
      v36[2] = ___ZN2CIL21copyIOSurfaceCallbackEPvP15CGImageProviderPK14__CFDictionary_block_invoke;
      v36[3] = &unk_1E2EC3288;
      v36[6] = v32;
      v36[7] = a1;
      *(CGFloat *)&v36[8] = v27;
      *(CGFloat *)&v36[9] = v28;
      *(CGFloat *)&v36[10] = v29;
      *(CGFloat *)&v36[11] = v30;
      v36[4] = &v37;
      v36[5] = Surface;
      dispatch_sync(v35, v36);
      if (!*((_BYTE *)v38 + 24))
      {
        CFRelease(Surface);
        Surface = 0;
      }
      _Block_object_dispose(&v37, 8);
    }
  }
  return Surface;
}

void sub_1922527A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void CI::_providerInfoReleaseCallback(CI *this, void *a2)
{
  const void *v3;

  dispatch_release(*((dispatch_object_t *)this + 8));
  v3 = (const void *)*((_QWORD *)this + 9);
  if (v3)
    _Block_release(v3);
  free(this);
}

void __CFDictionary::setValue(CFMutableDictionaryRef this, const void *key, const void *value, const void *a4)
{
  BOOL v4;
  int v5;

  if (this)
    v4 = key == 0;
  else
    v4 = 1;
  v5 = !v4;
  if (value)
  {
    if (v5)
      CFDictionarySetValue(this, key, value);
  }
  else if (v5)
  {
    CFDictionaryRemoveValue(this, key);
  }
}

void CI::_imageBlockReleaseCallback(uint64_t a1)
{
  munmap(*(void **)a1, *(_QWORD *)(a1 + 8));
  free((void *)a1);
}

void ___ZN2CIL29copyImageBlockSetOptsCallbackEPvP15CGImageProvider6CGRect6CGSizePK14__CFDictionary_block_invoke(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t ColorSpace;
  uint64_t v8;
  double v9;
  double v10;
  double v11;
  unint64_t v12;
  double v13;
  __IOSurface *WrappedSurface;
  CIRenderDestination *v15;
  CIRenderDestination *v16;
  uint64_t v17;
  void *v18;
  _QWORD v19[3];
  _BYTE v20[72];
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;

  v26 = 0;
  v2 = *(_QWORD *)(a1 + 40);
  v3 = (unint64_t)*(double *)(a1 + 64);
  v4 = (unint64_t)*(double *)(a1 + 72);
  v5 = *(_QWORD *)(a1 + 80);
  v6 = *(unsigned int *)(*(_QWORD *)(a1 + 88) + 16);
  ColorSpace = CGImageProviderGetColorSpace();
  CI::Bitmap::Bitmap(v20, v2, v3, v4, v5, v6, ColorSpace);
  v8 = CI::PixelFormatType_approx_from_format(*(_DWORD *)(*(_QWORD *)(a1 + 88) + 16));
  if (!CI_IOSURFACE_WRAPPING(2u))
    goto LABEL_11;
  if (!(_DWORD)v8)
    goto LABEL_11;
  if ((*(_BYTE *)(a1 + 80) & 3) != 0)
    goto LABEL_11;
  v9 = iosurface_limits((uint64_t)v19);
  if (v19[2] < *(_QWORD *)(a1 + 80))
    goto LABEL_11;
  v10 = *(double *)(a1 + 64);
  v11 = *(double *)(a1 + 72);
  v12 = (*(uint64_t (**)(_QWORD, double))(**(_QWORD **)(a1 + 104) + 440))(*(_QWORD *)(a1 + 104), v9);
  v13 = v10 <= v11 ? v11 : v10;
  if (v13 > (double)v12
    || (WrappedSurface = CreateWrappedSurface(v22, v23, v8, v24, v25, v21)) == 0
    || (v15 = -[CIRenderDestination initWithIOSurface:]([CIRenderDestination alloc], "initWithIOSurface:", WrappedSurface), CFRelease(WrappedSurface), !v15))
  {
LABEL_11:
    v16 = [CIRenderDestination alloc];
    v15 = -[CIRenderDestination initWithBitmapData:width:height:bytesPerRow:format:](v16, "initWithBitmapData:width:height:bytesPerRow:format:", v21, v22, v23, v24, *(unsigned int *)(*(_QWORD *)(a1 + 88) + 16));
  }
  -[CIRenderDestination setFlipped:](v15, "setFlipped:", 0);
  -[CIRenderDestination setColorSpace:](v15, "setColorSpace:", CGImageProviderGetColorSpace());
  -[CIRenderDestination setAlphaMode:](v15, "setAlphaMode:", *(_QWORD *)(*(_QWORD *)(a1 + 88) + 24));
  v17 = *(_QWORD *)(a1 + 88);
  if (*(_QWORD *)(v17 + 24) == 2)
  {
    -[CIRenderDestination setClamped:](v15, "setClamped:", 0);
    v17 = *(_QWORD *)(a1 + 88);
  }
  v18 = (void *)objc_msgSend(*(id *)v17, "startTaskToRender:fromRect:toDestination:atPoint:error:", *(_QWORD *)(v17 + 8), v15, &v26, *(double *)(a1 + 112), *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *MEMORY[0x1E0C9D538], *(double *)(MEMORY[0x1E0C9D538] + 8));
  objc_msgSend(v18, "waitUntilCompletedAndReturnError:", &v26);

  (*(void (**)(double, double, double, double))(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 72) + 16))(*(double *)(a1 + 112), *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136));
  if (v18 && !v26)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  CI::Bitmap::~Bitmap((CI::Bitmap *)v20);
}

void sub_192252A74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  CI::Bitmap::~Bitmap((CI::Bitmap *)va);
  _Unwind_Resume(a1);
}

void ___ZN2CIL21copyIOSurfaceCallbackEPvP15CGImageProviderPK14__CFDictionary_block_invoke(uint64_t a1)
{
  CIRenderDestination *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;

  v2 = -[CIRenderDestination initWithIOSurface:]([CIRenderDestination alloc], "initWithIOSurface:", *(_QWORD *)(a1 + 40));
  -[CIRenderDestination setFlipped:](v2, "setFlipped:", 0);
  -[CIRenderDestination setColorSpace:](v2, "setColorSpace:", *(_QWORD *)(a1 + 48));
  -[CIRenderDestination setAlphaMode:](v2, "setAlphaMode:", *(_QWORD *)(*(_QWORD *)(a1 + 56) + 24));
  v3 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(v3 + 24) == 2)
  {
    -[CIRenderDestination setClamped:](v2, "setClamped:", 0);
    v3 = *(_QWORD *)(a1 + 56);
  }
  v5 = 0;
  v4 = (void *)objc_msgSend(*(id *)v3, "startTaskToRender:fromRect:toDestination:atPoint:error:", *(_QWORD *)(v3 + 8), v2, &v5, *(double *)(a1 + 64), *(double *)(a1 + 72), *(double *)(a1 + 80), *(double *)(a1 + 88), *MEMORY[0x1E0C9D538], *(double *)(MEMORY[0x1E0C9D538] + 8));
  objc_msgSend(v4, "waitUntilCompletedAndReturnError:", &v5);
  (*(void (**)(double, double, double, double))(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 72) + 16))(*(double *)(a1 + 64), *(double *)(a1 + 72), *(double *)(a1 + 80), *(double *)(a1 + 88));

  if (v4)
  {
    if (!v5)
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
}

void CI::create_cgimage_immediate(CIContext *,CIImage *,CGRect,CGColorSpace *,int,CIRenderDestinationAlphaMode,NSError **)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  v2 = ci_signpost_log_render();
  v3 = *((_QWORD *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "new_bitmap", (const char *)&unk_192520C83, v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_192252C14(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_1_2(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

CIImage *downScale(CIImage *a1, float a2, float a3)
{
  float v4;
  float v5;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  CIImage *v15;
  CGAffineTransform v17;
  CGAffineTransform v18;
  CGAffineTransform v19;

  v4 = fmin(a2, 1.0);
  v5 = fmin(a3, 1.0);
  if (v4 != 1.0 || v5 != 1.0)
  {
    memset(&v19, 0, sizeof(v19));
    CGAffineTransformMakeScale(&v19, v4, v5);
    v18 = v19;
    -[CIImage extent](-[CIImage imageByApplyingTransform:](a1, "imageByApplyingTransform:", &v18), "extent");
    v8 = v7;
    v10 = v9;
    v12 = v11;
    v14 = v13;
    v15 = -[CIImage imageByClampingToExtent](a1, "imageByClampingToExtent");
    v17 = v19;
    return -[CIImage imageByCroppingToRect:](-[CIImage imageByApplyingTransform:highQualityDownsample:](v15, "imageByApplyingTransform:highQualityDownsample:", &v17, 1), "imageByCroppingToRect:", v8, v10, v12, v14);
  }
  return a1;
}

void sub_192254A34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
  _Block_object_dispose(&a46, 8);
  _Block_object_dispose(&a52, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

void __Block_byref_object_copy__40(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__41(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t imageRepError(uint64_t a1, const NSString *a2)
{
  uint64_t v3;
  const __CFString *v5;
  _QWORD v6[2];

  v6[1] = *MEMORY[0x1E0C80C00];
  v5 = CFSTR("CINonLocalizedDescriptionKey");
  v6[0] = a2;
  v3 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v6, &v5, 1);
  return objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", CFSTR("CINonLocalizedDescriptionKey"), a1, v3);
}

uint64_t imageRepError(uint64_t a1, const NSString *a2, const NSError *a3)
{
  void *v4;
  _QWORD *v5;
  const __CFString **v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[2];
  _QWORD v11[2];
  const __CFString *v12;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v10[0] = *MEMORY[0x1E0CB3388];
    v10[1] = CFSTR("CINonLocalizedDescriptionKey");
    v11[0] = a3;
    v11[1] = a2;
    v4 = (void *)MEMORY[0x1E0C99D80];
    v5 = v11;
    v6 = (const __CFString **)v10;
    v7 = 2;
  }
  else
  {
    v12 = CFSTR("CINonLocalizedDescriptionKey");
    v13[0] = a2;
    v4 = (void *)MEMORY[0x1E0C99D80];
    v5 = v13;
    v6 = &v12;
    v7 = 1;
  }
  v8 = objc_msgSend(v4, "dictionaryWithObjects:forKeys:count:", v5, v6, v7);
  return objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", CFSTR("CINonLocalizedDescriptionKey"), a1, v8);
}

BOOL canCreateDataRepresentation(CIImage *a1, CGColorSpace *a2, int a3, NSError **a4)
{
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  uint64_t v11;
  NSObject *v12;
  _BOOL8 result;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CFTypeID TypeID;
  int v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const __CFString *v32;
  _QWORD v33[2];
  CGRect v34;
  CGRect v35;
  CGRect v36;
  CGRect v37;

  v33[1] = *MEMORY[0x1E0C80C00];
  -[CIImage extent](a1, "extent");
  v35 = CGRectInset(v34, 0.00100000005, 0.00100000005);
  v36 = CGRectIntegral(v35);
  x = v36.origin.x;
  y = v36.origin.y;
  width = v36.size.width;
  height = v36.size.height;
  if (CGRectIsEmpty(v36)
    || (v37.origin.x = x, v37.origin.y = y, v37.size.width = width, v37.size.height = height, CGRectIsInfinite(v37)))
  {
    if (a4)
    {
      v32 = CFSTR("CINonLocalizedDescriptionKey");
      v33[0] = CFSTR("image extent must be finite and non-empty.");
      v11 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v33, &v32, 1);
      *a4 = (NSError *)objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", CFSTR("CINonLocalizedDescriptionKey"), 1, v11);
    }
    v12 = ci_logger_api();
    result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if (result)
    {
      canCreateDataRepresentation(v12, v14, v15, v16, v17, v18, v19, v20);
      return 0;
    }
    return result;
  }
  if (a2)
  {
    TypeID = CGColorSpaceGetTypeID();
    if (TypeID == CFGetTypeID(a2) && CGColorSpaceSupportsOutput(a2))
    {
      if ((CI::format_is_luminance(a3) & 1) != 0)
      {
        v22 = 0;
      }
      else
      {
        if (!CI::format_is_rgb(a3))
          goto LABEL_16;
        v22 = 1;
      }
      if (CGColorSpaceGetModel(a2) == v22)
        return 1;
    }
  }
LABEL_16:
  if (a4)
  {
    v32 = CFSTR("CINonLocalizedDescriptionKey");
    v33[0] = CFSTR("unsupported colorspace.");
    v23 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v33, &v32, 1);
    *a4 = (NSError *)objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", CFSTR("CINonLocalizedDescriptionKey"), 2, v23);
  }
  v24 = ci_logger_api();
  result = os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
  if (result)
  {
    canCreateDataRepresentation(v24, v25, v26, v27, v28, v29, v30, v31);
    return 0;
  }
  return result;
}

uint64_t canCreateDataRepresentation(CIImage *a1, CGColorSpace *a2, NSError **a3)
{
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  uint64_t v9;
  NSObject *v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFTypeID TypeID;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFString *v29;
  _QWORD v30[2];
  CGRect v31;
  CGRect v32;
  CGRect v33;
  CGRect v34;

  v30[1] = *MEMORY[0x1E0C80C00];
  -[CIImage extent](a1, "extent");
  v32 = CGRectInset(v31, 0.00100000005, 0.00100000005);
  v33 = CGRectIntegral(v32);
  x = v33.origin.x;
  y = v33.origin.y;
  width = v33.size.width;
  height = v33.size.height;
  if (CGRectIsEmpty(v33)
    || (v34.origin.x = x, v34.origin.y = y, v34.size.width = width, v34.size.height = height, CGRectIsInfinite(v34)))
  {
    if (a3)
    {
      v29 = CFSTR("CINonLocalizedDescriptionKey");
      v30[0] = CFSTR("image extent must be finite and non-empty.");
      v9 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v30, &v29, 1);
      *a3 = (NSError *)objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", CFSTR("CINonLocalizedDescriptionKey"), 1, v9);
    }
    v10 = ci_logger_api();
    result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      canCreateDataRepresentation(v10, v12, v13, v14, v15, v16, v17, v18);
      return 0;
    }
  }
  else
  {
    if (a2)
    {
      TypeID = CGColorSpaceGetTypeID();
      if (TypeID == CFGetTypeID(a2) && CGColorSpaceSupportsOutput(a2))
      {
        if (CGColorSpaceGetModel(a2) == kCGColorSpaceModelMonochrome)
          return 1;
        result = CGColorSpaceGetModel(a2);
        if ((_DWORD)result == 1)
          return result;
      }
    }
    if (a3)
    {
      v29 = CFSTR("CINonLocalizedDescriptionKey");
      v30[0] = CFSTR("unsupported colorspace.");
      v20 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v30, &v29, 1);
      *a3 = (NSError *)objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", CFSTR("CINonLocalizedDescriptionKey"), 2, v20);
    }
    v21 = ci_logger_api();
    result = os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      canCreateDataRepresentation(v21, v22, v23, v24, v25, v26, v27, v28);
      return 0;
    }
  }
  return result;
}

BOOL canCreateDataRepresentation(CIImage *a1, NSError **a2)
{
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  uint64_t v7;
  NSObject *v8;
  _BOOL8 result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFString *v17;
  _QWORD v18[2];
  CGRect v19;
  CGRect v20;
  CGRect v21;
  CGRect v22;

  v18[1] = *MEMORY[0x1E0C80C00];
  -[CIImage extent](a1, "extent");
  v20 = CGRectInset(v19, 0.00100000005, 0.00100000005);
  v21 = CGRectIntegral(v20);
  x = v21.origin.x;
  y = v21.origin.y;
  width = v21.size.width;
  height = v21.size.height;
  if (!CGRectIsEmpty(v21))
  {
    v22.origin.x = x;
    v22.origin.y = y;
    v22.size.width = width;
    v22.size.height = height;
    if (!CGRectIsInfinite(v22))
      return 1;
  }
  if (a2)
  {
    v17 = CFSTR("CINonLocalizedDescriptionKey");
    v18[0] = CFSTR("image extent must be finite and non-empty.");
    v7 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v18, &v17, 1);
    *a2 = (NSError *)objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", CFSTR("CINonLocalizedDescriptionKey"), 1, v7);
  }
  v8 = ci_logger_api();
  result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  if (result)
  {
    canCreateDataRepresentation(v8, v10, v11, v12, v13, v14, v15, v16);
    return 0;
  }
  return result;
}

void sub_192255DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

uint64_t getkCMPhotoCompressionContainerOption_Format(void)
{
  void *v0;
  void *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = (void *)getkCMPhotoCompressionContainerOption_FormatSymbolLoc(void)::ptr;
  v6 = getkCMPhotoCompressionContainerOption_FormatSymbolLoc(void)::ptr;
  if (!getkCMPhotoCompressionContainerOption_FormatSymbolLoc(void)::ptr)
  {
    v1 = (void *)CMPhotoLibrary();
    v0 = dlsym(v1, "kCMPhotoCompressionContainerOption_Format");
    v4[3] = (uint64_t)v0;
    getkCMPhotoCompressionContainerOption_FormatSymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v3, 8);
  if (!v0)
    getkCMPhotoCompressionContainerOption_Format();
  return *(_QWORD *)v0;
}

void sub_192255E94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t getkCMPhotoCompressionContainerOption_ImageCountHint(void)
{
  void *v0;
  void *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = (void *)getkCMPhotoCompressionContainerOption_ImageCountHintSymbolLoc(void)::ptr;
  v6 = getkCMPhotoCompressionContainerOption_ImageCountHintSymbolLoc(void)::ptr;
  if (!getkCMPhotoCompressionContainerOption_ImageCountHintSymbolLoc(void)::ptr)
  {
    v1 = (void *)CMPhotoLibrary();
    v0 = dlsym(v1, "kCMPhotoCompressionContainerOption_ImageCountHint");
    v4[3] = (uint64_t)v0;
    getkCMPhotoCompressionContainerOption_ImageCountHintSymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v3, 8);
  if (!v0)
    getkCMPhotoCompressionContainerOption_ImageCountHint();
  return *(_QWORD *)v0;
}

void sub_192255F2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t getkCMPhotoCompressionContainerOption_BackingType(void)
{
  void *v0;
  void *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = (void *)getkCMPhotoCompressionContainerOption_BackingTypeSymbolLoc(void)::ptr;
  v6 = getkCMPhotoCompressionContainerOption_BackingTypeSymbolLoc(void)::ptr;
  if (!getkCMPhotoCompressionContainerOption_BackingTypeSymbolLoc(void)::ptr)
  {
    v1 = (void *)CMPhotoLibrary();
    v0 = dlsym(v1, "kCMPhotoCompressionContainerOption_BackingType");
    v4[3] = (uint64_t)v0;
    getkCMPhotoCompressionContainerOption_BackingTypeSymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v3, 8);
  if (!v0)
    getkCMPhotoCompressionContainerOption_BackingType();
  return *(_QWORD *)v0;
}

void sub_192255FC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_CMPhotoCompressionSessionOpenEmptyContainer(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  void *v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v4 = getCMPhotoCompressionSessionOpenEmptyContainerSymbolLoc(void)::ptr;
  v10 = getCMPhotoCompressionSessionOpenEmptyContainerSymbolLoc(void)::ptr;
  if (!getCMPhotoCompressionSessionOpenEmptyContainerSymbolLoc(void)::ptr)
  {
    v5 = (void *)CMPhotoLibrary();
    v4 = dlsym(v5, "CMPhotoCompressionSessionOpenEmptyContainer");
    v8[3] = (uint64_t)v4;
    getCMPhotoCompressionSessionOpenEmptyContainerSymbolLoc(void)::ptr = v4;
  }
  _Block_object_dispose(&v7, 8);
  if (!v4)
    soft_CMPhotoCompressionSessionOpenEmptyContainer();
  return ((uint64_t (*)(uint64_t, uint64_t))v4)(a1, a2);
}

void sub_192256074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t getkCMPhotoCompressionOption_ImageOrientation(void)
{
  void *v0;
  void *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = (void *)getkCMPhotoCompressionOption_ImageOrientationSymbolLoc(void)::ptr;
  v6 = getkCMPhotoCompressionOption_ImageOrientationSymbolLoc(void)::ptr;
  if (!getkCMPhotoCompressionOption_ImageOrientationSymbolLoc(void)::ptr)
  {
    v1 = (void *)CMPhotoLibrary();
    v0 = dlsym(v1, "kCMPhotoCompressionOption_ImageOrientation");
    v4[3] = (uint64_t)v0;
    getkCMPhotoCompressionOption_ImageOrientationSymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v3, 8);
  if (!v0)
    getkCMPhotoCompressionOption_ImageOrientation();
  return *(_QWORD *)v0;
}

void sub_19225610C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t getkCMPhotoCompressionOption_QualityControllerType(void)
{
  void *v0;
  void *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = (void *)getkCMPhotoCompressionOption_QualityControllerTypeSymbolLoc(void)::ptr;
  v6 = getkCMPhotoCompressionOption_QualityControllerTypeSymbolLoc(void)::ptr;
  if (!getkCMPhotoCompressionOption_QualityControllerTypeSymbolLoc(void)::ptr)
  {
    v1 = (void *)CMPhotoLibrary();
    v0 = dlsym(v1, "kCMPhotoCompressionOption_QualityControllerType");
    v4[3] = (uint64_t)v0;
    getkCMPhotoCompressionOption_QualityControllerTypeSymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v3, 8);
  if (!v0)
    getkCMPhotoCompressionOption_QualityControllerType();
  return *(_QWORD *)v0;
}

void sub_1922561A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t getkCMPhotoQualityControllerParameter_QualityValue(void)
{
  void *v0;
  void *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = (void *)getkCMPhotoQualityControllerParameter_QualityValueSymbolLoc(void)::ptr;
  v6 = getkCMPhotoQualityControllerParameter_QualityValueSymbolLoc(void)::ptr;
  if (!getkCMPhotoQualityControllerParameter_QualityValueSymbolLoc(void)::ptr)
  {
    v1 = (void *)CMPhotoLibrary();
    v0 = dlsym(v1, "kCMPhotoQualityControllerParameter_QualityValue");
    v4[3] = (uint64_t)v0;
    getkCMPhotoQualityControllerParameter_QualityValueSymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v3, 8);
  if (!v0)
    getkCMPhotoQualityControllerParameter_QualityValue();
  return *(_QWORD *)v0;
}

void sub_19225623C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t getkCMPhotoCompressionOption_QualityControllerParameters(void)
{
  void *v0;
  void *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = (void *)getkCMPhotoCompressionOption_QualityControllerParametersSymbolLoc(void)::ptr;
  v6 = getkCMPhotoCompressionOption_QualityControllerParametersSymbolLoc(void)::ptr;
  if (!getkCMPhotoCompressionOption_QualityControllerParametersSymbolLoc(void)::ptr)
  {
    v1 = (void *)CMPhotoLibrary();
    v0 = dlsym(v1, "kCMPhotoCompressionOption_QualityControllerParameters");
    v4[3] = (uint64_t)v0;
    getkCMPhotoCompressionOption_QualityControllerParametersSymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v3, 8);
  if (!v0)
    getkCMPhotoCompressionOption_QualityControllerParameters();
  return *(_QWORD *)v0;
}

void sub_1922562D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_CMPhotoCompressionSessionAddImage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  void *v9;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  void *v14;

  v11 = 0;
  v12 = &v11;
  v13 = 0x2020000000;
  v8 = getCMPhotoCompressionSessionAddImageSymbolLoc(void)::ptr;
  v14 = getCMPhotoCompressionSessionAddImageSymbolLoc(void)::ptr;
  if (!getCMPhotoCompressionSessionAddImageSymbolLoc(void)::ptr)
  {
    v9 = (void *)CMPhotoLibrary();
    v8 = dlsym(v9, "CMPhotoCompressionSessionAddImage");
    v12[3] = (uint64_t)v8;
    getCMPhotoCompressionSessionAddImageSymbolLoc(void)::ptr = v8;
  }
  _Block_object_dispose(&v11, 8);
  if (!v8)
    soft_CMPhotoCompressionSessionAddImage();
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))v8)(a1, a2, a3, a4);
}

void sub_19225639C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_CMPhotoCompressionSessionAddMetadataFromImageProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  void *v7;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  void *v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2020000000;
  v6 = getCMPhotoCompressionSessionAddMetadataFromImagePropertiesSymbolLoc(void)::ptr;
  v12 = getCMPhotoCompressionSessionAddMetadataFromImagePropertiesSymbolLoc(void)::ptr;
  if (!getCMPhotoCompressionSessionAddMetadataFromImagePropertiesSymbolLoc(void)::ptr)
  {
    v7 = (void *)CMPhotoLibrary();
    v6 = dlsym(v7, "CMPhotoCompressionSessionAddMetadataFromImageProperties");
    v10[3] = (uint64_t)v6;
    getCMPhotoCompressionSessionAddMetadataFromImagePropertiesSymbolLoc(void)::ptr = v6;
  }
  _Block_object_dispose(&v9, 8);
  if (!v6)
    soft_CMPhotoCompressionSessionAddMetadataFromImageProperties();
  return ((uint64_t (*)(uint64_t, uint64_t, _QWORD, uint64_t))v6)(a1, a2, 0, a3);
}

void sub_192256460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_CMPhotoCompressionSessionCloseContainerAndCopyBacking(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  void *v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v4 = getCMPhotoCompressionSessionCloseContainerAndCopyBackingSymbolLoc(void)::ptr;
  v10 = getCMPhotoCompressionSessionCloseContainerAndCopyBackingSymbolLoc(void)::ptr;
  if (!getCMPhotoCompressionSessionCloseContainerAndCopyBackingSymbolLoc(void)::ptr)
  {
    v5 = (void *)CMPhotoLibrary();
    v4 = dlsym(v5, "CMPhotoCompressionSessionCloseContainerAndCopyBacking");
    v8[3] = (uint64_t)v4;
    getCMPhotoCompressionSessionCloseContainerAndCopyBackingSymbolLoc(void)::ptr = v4;
  }
  _Block_object_dispose(&v7, 8);
  if (!v4)
    soft_CMPhotoCompressionSessionCloseContainerAndCopyBacking();
  return ((uint64_t (*)(uint64_t, _QWORD, _QWORD, uint64_t))v4)(a1, 0, 0, a2);
}

void sub_192256518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

__n64 cikernel::_flexMapLinGain(__n128 a1, __n128 a2, float a3, float a4)
{
  __n64 result;

  result.n64_f32[0] = (float)(fmaxf(a1.n128_f32[0], fmaxf(a1.n128_f32[1], fmaxf(a1.n128_f32[2], 0.0))) + a4)
                    / (float)(fmaxf(a2.n128_f32[0], fmaxf(a2.n128_f32[1], fmaxf(a2.n128_f32[2], 0.0))) + a3);
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_s_s_f_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, float, float);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __int128 v20;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, float, float))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_QWORD *)(v10 + 56);
  v17 = *(_QWORD *)(v10 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
  v18 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v15);
  v19 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v20 = v11(a1, *v19, *v18, *((float *)a2 + 16 * v16), *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_flexMapLinGainRGB(float32x4_t a1, float32x4_t a2, int32x2_t a3, int32x2_t a4)
{
  a1.i32[3] = 0;
  a2.i32[3] = 0;
  a1.i64[0] = vdivq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(a4, 0), vmaxnmq_f32(a1, (float32x4_t)0)), vaddq_f32((float32x4_t)vdupq_lane_s32(a3, 0), vmaxnmq_f32(a2, (float32x4_t)0))).u64[0];
  return *(double *)a1.i64;
}

double cikernel::_flexMapImageRGB(simd_float4 a1, double a2, float a3)
{
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  double result;

  a1.i32[3] = 0;
  v4 = (float32x4_t)_simd_log2_f4(a1);
  v5 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0);
  v6 = vsubq_f32(v4, v5);
  v5.f32[0] = a3 - *(float *)&a2;
  v7 = vdivq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 0));
  v7.i32[3] = 0;
  v8 = vmaxnmq_f32(v7, (float32x4_t)0);
  v8.i32[3] = 0;
  *(_QWORD *)&result = vminnmq_f32(v8, (float32x4_t)xmmword_192491FD0).u64[0];
  return result;
}

double cikernel::_flexMapImage(float a1, float a2, float a3)
{
  int32x2_t v3;
  float v4;
  BOOL v5;
  double result;

  *(float *)v3.i32 = (float)(log2f(a1) - a2) / (float)(a3 - a2);
  if (*(float *)v3.i32 <= 1.0)
    v4 = *(float *)v3.i32;
  else
    v4 = 1.0;
  v5 = *(float *)v3.i32 < 0.0;
  v3.i32[0] = 0;
  if (!v5)
    *(float *)v3.i32 = v4;
  *(_QWORD *)&result = vdupq_lane_s32(v3, 0).u64[0];
  return result;
}

uint64_t CMPhotoLibrary(void)
{
  void *v1;
  __int128 v2;
  uint64_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v1 = 0;
  if (!CMPhotoLibraryCore(char **)::frameworkLibrary)
  {
    v2 = xmmword_1E2EC3378;
    v3 = 0;
    CMPhotoLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  if (!CMPhotoLibraryCore(char **)::frameworkLibrary)
    CMPhotoLibrary(&v1);
  return CMPhotoLibraryCore(char **)::frameworkLibrary;
}

uint64_t convert_weights(const double *a1, float *a2, unsigned int a3, unsigned int a4)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  float v10;
  float *v11;
  float *v12;

  if (a4)
  {
    v4 = 0;
    v5 = 0;
    v6 = a3 * (a4 - 1);
    do
    {
      v7 = a3;
      v8 = v6;
      v9 = v4;
      if (a3)
      {
        do
        {
          v10 = a1[v8];
          a2[v9++] = v10;
          ++v8;
          --v7;
        }
        while (v7);
      }
      ++v5;
      v4 += a3;
      v6 -= a3;
    }
    while (v5 != a4);
    if (a3 >= 4 && a4 == 1)
    {
      v11 = &a2[a3 - 1];
      while (fabsf(*a2) < 1.0e-10 && fabsf(*v11) < 1.0e-10)
      {
        ++a2;
        a3 -= 2;
        --v11;
        if (a3 <= 3)
          goto LABEL_12;
      }
      a4 = 1;
    }
    else
    {
LABEL_12:
      if (a4 >= 4 && a3 == 1)
      {
        v12 = &a2[a4 - 1];
        do
        {
          if (fabsf(*a2) >= 1.0e-10)
            break;
          if (fabsf(*v12) >= 1.0e-10)
            break;
          ++a2;
          a4 -= 2;
          --v12;
        }
        while (a4 > 3);
        a3 = 1;
      }
    }
  }
  return a4 * a3;
}

CIImage *apply1DConvolution(CIImage *a1, CIVector *a2, double a3, unsigned int a4, int a5)
{
  double *v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  double x;
  double y;
  double width;
  double height;
  unsigned int v22;
  CIKernel *v23;
  void (***v24)(CI::GeneralKernel *__hidden);
  CIKernel *v25;
  void (***v26)(CI::GeneralKernel *__hidden);
  CIKernel *v27;
  CIVector *v28;
  CIVector *v29;
  CIVector *v30;
  uint64_t v31;
  _QWORD *v32;
  CIVector *v33;
  CIVector *v34;
  _QWORD v36[4];
  int v37;
  int v38;
  _QWORD v39[4];
  int v40;
  int v41;
  float v42[2];
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  _QWORD v50[3];
  _QWORD v51[5];
  CGRect v52;
  CGRect v53;

  v51[4] = *MEMORY[0x1E0C80C00];
  v9 = -[CIVector _values](a2, "_values");
  if (a4)
    v10 = 9;
  else
    v10 = 1;
  if (a4)
    v11 = 1;
  else
    v11 = 9;
  v12 = convert_weights(v9, v42, v10, v11);
  v13 = v12;
  if (v12 >= 0)
    v14 = v12;
  else
    v14 = v12 + 1;
  v15 = v14 >> 1;
  if (a4)
    v16 = v15;
  else
    v16 = 0;
  if (a4)
    v17 = 0;
  else
    v17 = v15;
  if (fabs(a3) >= 1.0e-10)
  {
    x = *MEMORY[0x1E0C9D5E0];
    y = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
    width = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
    height = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
  }
  else
  {
    -[CIImage extent](a1, "extent");
    v53 = CGRectInset(v52, (double)-v16, (double)-v17);
    x = v53.origin.x;
    y = v53.origin.y;
    width = v53.size.width;
    height = v53.size.height;
  }
  v22 = a4 ^ 1;
  if (v13 == 5)
  {
    v25 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_convolution5);
    if ((a5 & 1) != 0)
    {
      v26 = &CI::_convolutionrgb5;
LABEL_32:
      v25 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", v26);
    }
LABEL_33:
    v27 = v25;
    v33 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v43, v44, v45, v46);
    v34 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v47, a3, (double)a4, (double)v22);
    v36[0] = MEMORY[0x1E0C809B0];
    v36[1] = 3221225472;
    v36[2] = ___ZL18apply1DConvolutionP7CIImageP8CIVectordbb_block_invoke_2;
    v36[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
    v37 = v16;
    v38 = v17;
    v50[0] = a1;
    v50[1] = v33;
    v50[2] = v34;
    v31 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v50, 3);
    v32 = v36;
    return -[CIKernel applyWithExtent:roiCallback:arguments:](v27, "applyWithExtent:roiCallback:arguments:", v32, v31, x, y, width, height);
  }
  if (v13 != 7)
  {
    if (v13 == 9)
    {
      v23 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_convolution9);
      if ((a5 & 1) != 0)
      {
        v24 = &CI::_convolutionrgb9;
LABEL_28:
        v23 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", v24);
        goto LABEL_29;
      }
      goto LABEL_29;
    }
    v25 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_convolution3);
    if (a5)
    {
      v26 = &CI::_convolutionrgb3;
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  v23 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_convolution7);
  if (a5)
  {
    v24 = &CI::_convolutionrgb7;
    goto LABEL_28;
  }
LABEL_29:
  v27 = v23;
  v28 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v42[0], v42[1], v43, v44);
  v29 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v45, v46, v47, v48);
  v30 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v49, a3, (double)a4, (double)v22);
  v39[0] = MEMORY[0x1E0C809B0];
  v39[1] = 3221225472;
  v39[2] = ___ZL18apply1DConvolutionP7CIImageP8CIVectordbb_block_invoke;
  v39[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
  v40 = v16;
  v41 = v17;
  v51[0] = a1;
  v51[1] = v28;
  v51[2] = v29;
  v51[3] = v30;
  v31 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v51, 4);
  v32 = v39;
  return -[CIKernel applyWithExtent:roiCallback:arguments:](v27, "applyWithExtent:roiCallback:arguments:", v32, v31, x, y, width, height);
}

float32x4_t cikernel::_convrgb3x3sym(uint64_t a1, int8x16_t a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  double v5;
  double v6;
  float64x2_t v7;
  float64x2_t v8;
  uint8x8_t v9;
  double v10;
  int8x16_t v11;
  unsigned __int32 v12;
  float64x2_t v13;
  float32x2_t v14;
  double v15;
  double v16;
  uint8x8_t v17;
  int8x16_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float64x2_t v22;
  double v23;
  double v24;
  uint8x8_t v25;
  int8x16_t v26;
  double v27;
  int8x16_t v28;
  float32x4_t v29;
  double v30;
  float32x2_t v31;
  double v32;
  int8x16_t v33;
  double v34;
  uint8x8_t v35;
  float64x2_t v36;
  int8x16_t v37;
  float32x4_t v38;
  double v39;
  float32x2_t v40;
  double v41;
  int8x16_t v42;
  double v43;
  uint8x8_t v44;
  float64x2_t v45;
  int8x16_t v46;
  float32x4_t result;
  float32x4_t v48;
  float32x4_t v49;
  unsigned __int32 v50;
  float64x2_t v51;
  float64x2_t v52;
  float32x4_t v53;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v4.f64[0] = *(float64_t *)DC;
  v52 = v4;
  *(float *)&v5 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v6) = *(_DWORD *)(a1 + 36);
  *(float *)v7.f64 = -*(float *)&a2.i32[1];
  HIDWORD(v7.f64[0]) = a2.i32[0];
  v51 = v7;
  *(float *)v8.f64 = *(float *)&v6
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  HIDWORD(v5) = LODWORD(v8.f64[0]);
  CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v5, v8, v7.f64[0], v6, a2, v9, v10, v11);
  v50 = v12;
  v13 = v51;
  v14 = vadd_f32(*(float32x2_t *)&v51.f64[0], *(float32x2_t *)&v52.f64[0]);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v14, 1), *(float *)(a1 + 16), v14.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v14, 1), *(float *)&v16, v14.f32[0]);
  v14.f32[0] = *(float *)(a1 + 24) + *(float *)&v15;
  *(float *)v13.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v14.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v14, v13, v15, v16, v18, v17, v19, v20);
  v48 = v21;
  v22 = v52;
  *(float32x2_t *)v21.f32 = vadd_f32(*(float32x2_t *)a2.i8, *(float32x2_t *)&v52.f64[0]);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v21.f32, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v21.f32, 1), *(float *)&v24, v21.f32[0]);
  v21.f32[0] = *(float *)(a1 + 24) + *(float *)&v23;
  *(float *)v22.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v21.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v22, v23, v24, v26, v25, v27, v28);
  HIDWORD(v30) = HIDWORD(v52.f64[0]);
  v31 = vsub_f32(*(float32x2_t *)&v52.f64[0], *(float32x2_t *)a2.i8);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v31, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 24);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v34) = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v31, 1), *(float *)v33.i32, v31.f32[0]);
  v36 = (float64x2_t)v48;
  v49 = vaddq_f32(v48, v29);
  v29.f32[0] = *(float *)&v30 + *(float *)&v32;
  *(float *)v36.f64 = *(float *)&v34 + *(float *)v35.i32;
  v29.f32[1] = *(float *)&v34 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v36, v30, v32, v33, v35, v34, v37);
  HIDWORD(v39) = HIDWORD(v51.f64[0]);
  v40 = vsub_f32(*(float32x2_t *)&v52.f64[0], *(float32x2_t *)&v51.f64[0]);
  *(float *)&v41 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v40, 1), *(float *)(a1 + 16), v40.f32[0]);
  LODWORD(v39) = *(_DWORD *)(a1 + 24);
  v42.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v43) = *(_DWORD *)(a1 + 36);
  *(float *)v44.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v40, 1), *(float *)v42.i32, v40.f32[0]);
  v45 = (float64x2_t)v49;
  v53 = vaddq_f32(v49, v38);
  v38.f32[0] = *(float *)&v39 + *(float *)&v41;
  *(float *)v45.f64 = *(float *)&v43 + *(float *)v44.i32;
  v38.f32[1] = *(float *)&v43 + *(float *)v44.i32;
  *(double *)result.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v45, v39, v41, v42, v44, v43, v46);
  result.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)a2, 3), vmulq_laneq_f32(vaddq_f32(v53, result), (float32x4_t)a2, 2)).u64[0];
  result.i32[3] = v50;
  return result;
}

void CI::f4_sr_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, __n128);
  uint64_t v13;
  int v14;
  uint64_t v15;
  __n128 *v16;
  __int128 v17;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, __n128))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_DWORD *)(v11 + 40);
  v15 = *(_QWORD *)(v11 + 32);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 56)), a2);
  v16 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v16 = (__n128 *)((char *)a2 + 64 * v15);
  *(double *)&v17 = v12(a4 + 80 * v13, *v16);
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

double cikernel::_conv3x3sym(uint64_t a1, int32x4_t a2)
{
  float32x2_t v3;
  float64x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  double v26;
  uint8x8_t v27;
  float64x2_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x2_t v31;
  double v32;
  double v33;
  int8x16_t v34;
  double v35;
  uint8x8_t v36;
  float64x2_t v37;
  int8x16_t v38;
  float32x4_t v39;
  double result;
  float32x4_t v41;
  float32x4_t v42;
  float32x2_t v43;
  float32x4_t v44;

  v3 = *(float32x2_t *)CI::getDC((CI *)a1);
  v4 = (float64x2_t)a2;
  v5.f32[0] = -*(float *)&a2.i32[1];
  v5.i32[1] = a2.i32[0];
  v43 = v5;
  v6 = vadd_f32(v5, v3);
  *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v6, 1), *(float *)(a1 + 16), v6.f32[0]);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v4, v7, v8, v10, v9, v11, v12);
  v41 = v13;
  *(float32x2_t *)v13.f32 = vadd_f32(*(float32x2_t *)a2.i8, v3);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v13.f32, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  v22 = vsub_f32(v3, *(float32x2_t *)a2.i8);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 24);
  v25.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v26) = *(_DWORD *)(a1 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)v25.i32, v22.f32[0]);
  v28 = (float64x2_t)v41;
  v42 = vaddq_f32(v41, v21);
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  *(float *)v28.f64 = *(float *)&v26 + *(float *)v27.i32;
  v21.f32[1] = *(float *)&v26 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v28, v24, v23, v25, v27, v26, v29);
  v31 = vsub_f32(v3, v43);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v31, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v33) = *(_DWORD *)(a1 + 24);
  v34.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v35) = *(_DWORD *)(a1 + 36);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v31, 1), *(float *)v34.i32, v31.f32[0]);
  v37 = (float64x2_t)v42;
  v44 = vaddq_f32(v42, v30);
  v30.f32[0] = *(float *)&v33 + *(float *)&v32;
  *(float *)v37.f64 = *(float *)&v35 + *(float *)v36.i32;
  v30.f32[1] = *(float *)&v35 + *(float *)v36.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v30.i64, v37, v33, v32, v34, v36, v35, v38);
  *(_QWORD *)&result = vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 3), vmulq_laneq_f32(vaddq_f32(v44, v39), (float32x4_t)a2, 2)).u64[0];
  return result;
}

float32x4_t cikernel::_convrgb3x3(uint64_t a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  float32x2_t *DC;
  int8x16_t v6;
  double v7;
  double v8;
  float64x2_t v9;
  uint8x8_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  float64x2_t v14;
  double v15;
  double v16;
  uint8x8_t v17;
  int8x16_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x2_t v22;
  double v23;
  float32x2_t v24;
  double v25;
  int8x16_t v26;
  double v27;
  uint8x8_t v28;
  float64x2_t v29;
  int8x16_t v30;
  float32x4_t v31;
  float32x2_t v32;
  double v33;
  float32x2_t v34;
  double v35;
  int8x16_t v36;
  double v37;
  uint8x8_t v38;
  float64x2_t v39;
  int8x16_t v40;
  float32x4_t v41;
  double v42;
  float32x2_t v43;
  double v44;
  int8x16_t v45;
  double v46;
  uint8x8_t v47;
  float64x2_t v48;
  int8x16_t v49;
  float32x4_t v50;
  double v51;
  float32x2_t v52;
  double v53;
  double v54;
  uint8x8_t v55;
  float32x4_t v56;
  int8x16_t v57;
  float32x4_t v58;
  double v59;
  float32x2_t v60;
  double v61;
  int8x16_t v62;
  double v63;
  uint8x8_t v64;
  float64x2_t v65;
  int8x16_t v66;
  float32x4_t v67;
  float32x2_t v68;
  double v69;
  float32x2_t v70;
  double v71;
  int8x16_t v72;
  double v73;
  uint8x8_t v74;
  float64x2_t v75;
  int8x16_t v76;
  float32x4_t v77;
  double v78;
  float32x2_t v79;
  double v80;
  int8x16_t v81;
  double v82;
  uint8x8_t v83;
  float64x2_t v84;
  int8x16_t v85;
  float32x4_t result;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float64x2_t v98;
  float32x4_t v99;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v6.i8 = *DC;
  v98 = (float64x2_t)v6;
  *(float *)&v7 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v8) = *(_DWORD *)(a1 + 36);
  v91 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.i8, 1);
  *(float *)v9.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  HIDWORD(v7) = LODWORD(v9.f64[0]);
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v7, v9, *(double *)v91.i64, v8, v6, v10, v11, v12);
  v90 = v13;
  v13.f32[0] = -*(float *)&a4.i32[2];
  v13.f32[1] = -*(float *)&a4.i32[3];
  v14 = v98;
  *(float32x2_t *)v13.f32 = vadd_f32(*(float32x2_t *)v13.f32, *(float32x2_t *)&v98.f64[0]);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v13.f32, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v13.f32, 1), *(float *)&v16, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v15;
  *(float *)v14.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v13.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, v14, v15, v16, v18, v17, v19, v20);
  v22.i32[0] = 0;
  v22.f32[1] = -*(float *)&a4.i32[3];
  HIDWORD(v23) = HIDWORD(v98.f64[0]);
  v24 = vadd_f32(v22, *(float32x2_t *)&v98.f64[0]);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v24, 1), *(float *)(a1 + 16), v24.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 24);
  v26.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v27) = *(_DWORD *)(a1 + 36);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v24, 1), *(float *)v26.i32, v24.f32[0]);
  v29 = (float64x2_t)v91;
  v87 = vaddq_f32(v91, vmulq_n_f32(v21, a2.f32[0]));
  v21.f32[0] = *(float *)&v23 + *(float *)&v25;
  *(float *)v29.f64 = *(float *)&v27 + *(float *)v28.i32;
  v21.f32[1] = *(float *)&v27 + *(float *)v28.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v29, v23, v25, v26, v28, v27, v30);
  v32 = (float32x2_t)vextq_s8(a4, a4, 8uLL).u64[0];
  *(float32x2_t *)v91.f32 = v32;
  v32.f32[1] = -*(float *)&a4.i32[3];
  HIDWORD(v33) = HIDWORD(v98.f64[0]);
  v34 = vadd_f32(v32, *(float32x2_t *)&v98.f64[0]);
  *(float *)&v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v34, 1), *(float *)(a1 + 16), v34.f32[0]);
  LODWORD(v33) = *(_DWORD *)(a1 + 24);
  v36.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v37) = *(_DWORD *)(a1 + 36);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v34, 1), *(float *)v36.i32, v34.f32[0]);
  v39 = (float64x2_t)v87;
  v88 = vaddq_f32(v87, vmulq_lane_f32(v31, *(float32x2_t *)a2.f32, 1));
  v31.f32[0] = *(float *)&v33 + *(float *)&v35;
  *(float *)v39.f64 = *(float *)&v37 + *(float *)v38.i32;
  v31.f32[1] = *(float *)&v37 + *(float *)v38.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v31.i64, v39, v33, v35, v36, v38, v37, v40);
  HIDWORD(v42) = HIDWORD(v98.f64[0]);
  v43 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&a4.i32[2]), *(float32x2_t *)&v98.f64[0]);
  *(float *)&v44 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v43, 1), *(float *)(a1 + 16), v43.f32[0]);
  LODWORD(v42) = *(_DWORD *)(a1 + 24);
  v45.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v46) = *(_DWORD *)(a1 + 36);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v43, 1), *(float *)v45.i32, v43.f32[0]);
  v48 = (float64x2_t)v88;
  v89 = vaddq_f32(v88, vmulq_laneq_f32(v41, a2, 2));
  v41.f32[0] = *(float *)&v42 + *(float *)&v44;
  *(float *)v48.f64 = *(float *)&v46 + *(float *)v47.i32;
  v41.f32[1] = *(float *)&v46 + *(float *)v47.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v41.i64, v48, v42, v44, v45, v47, v46, v49);
  HIDWORD(v51) = HIDWORD(v98.f64[0]);
  v52 = vadd_f32((float32x2_t)v91.u32[0], *(float32x2_t *)&v98.f64[0]);
  *(float *)&v53 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v52, 1), *(float *)(a1 + 16), v52.f32[0]);
  LODWORD(v51) = *(_DWORD *)(a1 + 24);
  LODWORD(v54) = *(_DWORD *)(a1 + 36);
  *(float *)v55.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v52, 1), *(float *)(a1 + 28), v52.f32[0]);
  v56 = vmulq_n_f32(v90, a3.f32[0]);
  v93 = vaddq_f32(v56, vaddq_f32(v89, vmulq_laneq_f32(v50, a2, 3)));
  v50.f32[0] = *(float *)&v51 + *(float *)&v53;
  v56.f32[0] = *(float *)&v54 + *(float *)v55.i32;
  v50.f32[1] = *(float *)&v54 + *(float *)v55.i32;
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v50.i64, (float64x2_t)v56, v51, v53, (int8x16_t)v90, v55, v54, v57);
  v59 = COERCE_DOUBLE(__PAIR64__(a4.u32[3], -*(float *)&a4.i32[2]));
  v60 = vadd_f32((float32x2_t)__PAIR64__(a4.u32[3], -*(float *)&a4.i32[2]), *(float32x2_t *)&v98.f64[0]);
  *(float *)&v61 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v60, 1), *(float *)(a1 + 16), v60.f32[0]);
  LODWORD(v59) = *(_DWORD *)(a1 + 24);
  v62.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v63) = *(_DWORD *)(a1 + 36);
  *(float *)v64.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v60, 1), *(float *)v62.i32, v60.f32[0]);
  v65 = (float64x2_t)v93;
  v94 = vaddq_f32(v93, vmulq_lane_f32(v58, *(float32x2_t *)a3.f32, 1));
  v58.f32[0] = *(float *)&v59 + *(float *)&v61;
  *(float *)v65.f64 = *(float *)&v63 + *(float *)v64.i32;
  v58.f32[1] = *(float *)&v63 + *(float *)v64.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v58.i64, v65, v59, v61, v62, v64, v63, v66);
  v68.i32[1] = v91.i32[1];
  v68.i32[0] = 0;
  HIDWORD(v69) = HIDWORD(v98.f64[0]);
  v70 = vadd_f32(v68, *(float32x2_t *)&v98.f64[0]);
  *(float *)&v71 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v70, 1), *(float *)(a1 + 16), v70.f32[0]);
  LODWORD(v69) = *(_DWORD *)(a1 + 24);
  v72.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v73) = *(_DWORD *)(a1 + 36);
  *(float *)v74.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v70, 1), *(float *)v72.i32, v70.f32[0]);
  v75 = (float64x2_t)v94;
  v95 = vaddq_f32(v94, vmulq_laneq_f32(v67, a3, 2));
  v67.f32[0] = *(float *)&v69 + *(float *)&v71;
  *(float *)v75.f64 = *(float *)&v73 + *(float *)v74.i32;
  v67.f32[1] = *(float *)&v73 + *(float *)v74.i32;
  *(double *)v77.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v67.i64, v75, v69, v71, v72, v74, v73, v76);
  v78 = COERCE_DOUBLE(__PAIR64__(a4.u32[3], v91.u32[0]));
  v79 = vadd_f32((float32x2_t)__PAIR64__(a4.u32[3], v91.u32[0]), *(float32x2_t *)&v98.f64[0]);
  *(float *)&v80 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v79, 1), *(float *)(a1 + 16), v79.f32[0]);
  LODWORD(v78) = *(_DWORD *)(a1 + 24);
  v81.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v82) = *(_DWORD *)(a1 + 36);
  *(float *)v83.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v79, 1), *(float *)v81.i32, v79.f32[0]);
  v84 = (float64x2_t)v95;
  v99 = vaddq_f32(v95, vmulq_laneq_f32(v77, a3, 3));
  v77.f32[0] = *(float *)&v78 + *(float *)&v80;
  *(float *)v84.f64 = *(float *)&v82 + *(float *)v83.i32;
  v77.f32[1] = *(float *)&v82 + *(float *)v83.i32;
  *(double *)result.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v77.i64, v84, v78, v80, v81, v83, v82, v85);
  result.i64[0] = vaddq_f32(v99, vmulq_n_f32(result, *(float *)a4.i32)).u64[0];
  result.i32[3] = v90.i32[3];
  return result;
}

void CI::f4_sr_f4_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, __n128, __n128, __n128);
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __n128 *v19;
  __n128 *v20;
  __n128 *v21;
  __int128 v22;
  int v23;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, __n128, __n128, __n128))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  v17 = *(_DWORD *)(v10 + 88);
  v18 = *(_QWORD *)(v10 + 80);
  if (*(_BYTE *)(a1 + 64))
  {
    v23 = *(_DWORD *)(v10 + 64);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
    v15 = v23;
  }
  v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v18);
  v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v16);
  v21 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v21 = (__n128 *)((char *)a2 + 64 * v14);
  *(double *)&v22 = v11(a4 + 80 * v12, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

double cikernel::_conv3x3(uint64_t a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  float32x2_t *DC;
  float64x2_t v6;
  int8x16_t v7;
  float32x2_t v8;
  float32x2_t v9;
  double v10;
  uint8x8_t v11;
  int8x16_t v12;
  double v13;
  int8x16_t v14;
  float32x4_t v15;
  float32x2_t v16;
  double v17;
  float32x2_t v18;
  double v19;
  int8x16_t v20;
  double v21;
  uint8x8_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x2_t v26;
  double v27;
  float32x2_t v28;
  double v29;
  int8x16_t v30;
  double v31;
  uint8x8_t v32;
  float64x2_t v33;
  int8x16_t v34;
  float32x4_t v35;
  double v36;
  float32x2_t v37;
  double v38;
  int8x16_t v39;
  double v40;
  uint8x8_t v41;
  float64x2_t v42;
  int8x16_t v43;
  float32x4_t v44;
  float64x2_t v45;
  double v46;
  double v47;
  uint8x8_t v48;
  double v49;
  int8x16_t v50;
  float32x4_t v51;
  double v52;
  float32x2_t v53;
  double v54;
  int8x16_t v55;
  double v56;
  uint8x8_t v57;
  float64x2_t v58;
  int8x16_t v59;
  float32x4_t v60;
  double v61;
  float32x2_t v62;
  double v63;
  int8x16_t v64;
  double v65;
  uint8x8_t v66;
  float64x2_t v67;
  int8x16_t v68;
  float32x4_t v69;
  float32x2_t v70;
  double v71;
  float32x2_t v72;
  double v73;
  int8x16_t v74;
  double v75;
  uint8x8_t v76;
  float64x2_t v77;
  int8x16_t v78;
  float32x4_t v79;
  double v80;
  float32x2_t v81;
  double v82;
  int8x16_t v83;
  double v84;
  uint8x8_t v85;
  float64x2_t v86;
  int8x16_t v87;
  float32x4_t v88;
  double result;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x2_t v93;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  int8x16_t v101;
  float32x4_t v102;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v6 = (float64x2_t)a4;
  *(float32x2_t *)v7.i8 = *DC;
  v101 = v7;
  v8.f32[0] = -*(float *)&a4.i32[2];
  v8.f32[1] = -*(float *)&a4.i32[3];
  v9 = vadd_f32(v8, *DC);
  *(float *)&v10 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v9, 1), *(float *)(a1 + 16), v9.f32[0]);
  v7.i32[0] = *(_DWORD *)(a1 + 28);
  v11.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v9, 1), *(float *)v7.i32, v9.f32[0]);
  v9.f32[0] = *(float *)(a1 + 24) + *(float *)&v10;
  *(float *)v6.f64 = *(float *)v11.i32 + *(float *)v12.i32;
  v9.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v9, v6, v10, *(double *)v7.i64, v12, v11, v13, v14);
  v16.i32[0] = 0;
  v16.f32[1] = -*(float *)&a4.i32[3];
  HIDWORD(v17) = v101.i32[1];
  v18 = vadd_f32(v16, *(float32x2_t *)v101.i8);
  *(float *)&v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v18, 1), *(float *)(a1 + 16), v18.f32[0]);
  LODWORD(v17) = *(_DWORD *)(a1 + 24);
  v20.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v21) = *(_DWORD *)(a1 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v18, 1), *(float *)v20.i32, v18.f32[0]);
  v23 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.i8, 1);
  v90 = vaddq_f32(v23, vmulq_n_f32(v15, a2.f32[0]));
  v15.f32[0] = *(float *)&v17 + *(float *)&v19;
  v23.f32[0] = *(float *)&v21 + *(float *)v22.i32;
  v15.f32[1] = *(float *)&v21 + *(float *)v22.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v15.i64, (float64x2_t)v23, v17, v19, v20, v22, v21, v24);
  v26 = (float32x2_t)vextq_s8(a4, a4, 8uLL).u64[0];
  v93 = v26;
  v26.f32[1] = -*(float *)&a4.i32[3];
  HIDWORD(v27) = v101.i32[1];
  v28 = vadd_f32(v26, *(float32x2_t *)v101.i8);
  *(float *)&v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v27) = *(_DWORD *)(a1 + 24);
  v30.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v31) = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)v30.i32, v28.f32[0]);
  v33 = (float64x2_t)v90;
  v91 = vaddq_f32(v90, vmulq_lane_f32(v25, *(float32x2_t *)a2.f32, 1));
  v25.f32[0] = *(float *)&v27 + *(float *)&v29;
  *(float *)v33.f64 = *(float *)&v31 + *(float *)v32.i32;
  v25.f32[1] = *(float *)&v31 + *(float *)v32.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v33, v27, v29, v30, v32, v31, v34);
  HIDWORD(v36) = v101.i32[1];
  v37 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&a4.i32[2]), *(float32x2_t *)v101.i8);
  *(float *)&v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v37, 1), *(float *)(a1 + 16), v37.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a1 + 24);
  v39.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v40) = *(_DWORD *)(a1 + 36);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v37, 1), *(float *)v39.i32, v37.f32[0]);
  v42 = (float64x2_t)v91;
  v92 = vaddq_f32(v91, vmulq_laneq_f32(v35, a2, 2));
  v35.f32[0] = *(float *)&v36 + *(float *)&v38;
  *(float *)v42.f64 = *(float *)&v40 + *(float *)v41.i32;
  v35.f32[1] = *(float *)&v40 + *(float *)v41.i32;
  *(double *)v44.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v42, v36, v38, v39, v41, v40, v43);
  v45 = (float64x2_t)v92;
  v95 = vaddq_f32(v92, vmulq_laneq_f32(v44, a2, 3));
  LODWORD(v46) = *(_DWORD *)(a1 + 28);
  v44.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v101.i8, 1), *(float *)(a1 + 16), *(float *)v101.i32);
  LODWORD(v47) = *(_DWORD *)(a1 + 36);
  *(float *)v45.f64 = *(float *)&v47
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v101.i8, 1), *(float *)&v46, *(float *)v101.i32);
  v44.i32[1] = LODWORD(v45.f64[0]);
  *(double *)v51.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v44.i64, v45, v46, v47, v101, v48, v49, v50);
  HIDWORD(v52) = v101.i32[1];
  v53 = vadd_f32((float32x2_t)v93.u32[0], *(float32x2_t *)v101.i8);
  *(float *)&v54 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v53, 1), *(float *)(a1 + 16), v53.f32[0]);
  LODWORD(v52) = *(_DWORD *)(a1 + 24);
  v55.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v56) = *(_DWORD *)(a1 + 36);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v53, 1), *(float *)v55.i32, v53.f32[0]);
  v58 = (float64x2_t)v95;
  v96 = vaddq_f32(v95, vmulq_n_f32(v51, a3.f32[0]));
  v51.f32[0] = *(float *)&v52 + *(float *)&v54;
  *(float *)v58.f64 = *(float *)&v56 + *(float *)v57.i32;
  v51.f32[1] = *(float *)&v56 + *(float *)v57.i32;
  *(double *)v60.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v51.i64, v58, v52, v54, v55, v57, v56, v59);
  v61 = COERCE_DOUBLE(__PAIR64__(a4.u32[3], -*(float *)&a4.i32[2]));
  v62 = vadd_f32((float32x2_t)__PAIR64__(a4.u32[3], -*(float *)&a4.i32[2]), *(float32x2_t *)v101.i8);
  *(float *)&v63 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v62, 1), *(float *)(a1 + 16), v62.f32[0]);
  LODWORD(v61) = *(_DWORD *)(a1 + 24);
  v64.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v65) = *(_DWORD *)(a1 + 36);
  *(float *)v66.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v62, 1), *(float *)v64.i32, v62.f32[0]);
  v67 = (float64x2_t)v96;
  v97 = vaddq_f32(v96, vmulq_lane_f32(v60, *(float32x2_t *)a3.f32, 1));
  v60.f32[0] = *(float *)&v61 + *(float *)&v63;
  *(float *)v67.f64 = *(float *)&v65 + *(float *)v66.i32;
  v60.f32[1] = *(float *)&v65 + *(float *)v66.i32;
  *(double *)v69.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v60.i64, v67, v61, v63, v64, v66, v65, v68);
  v70.i32[1] = v93.i32[1];
  v70.i32[0] = 0;
  HIDWORD(v71) = v101.i32[1];
  v72 = vadd_f32(v70, *(float32x2_t *)v101.i8);
  *(float *)&v73 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v72, 1), *(float *)(a1 + 16), v72.f32[0]);
  LODWORD(v71) = *(_DWORD *)(a1 + 24);
  v74.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v75) = *(_DWORD *)(a1 + 36);
  *(float *)v76.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v72, 1), *(float *)v74.i32, v72.f32[0]);
  v77 = (float64x2_t)v97;
  v98 = vaddq_f32(v97, vmulq_laneq_f32(v69, a3, 2));
  v69.f32[0] = *(float *)&v71 + *(float *)&v73;
  *(float *)v77.f64 = *(float *)&v75 + *(float *)v76.i32;
  v69.f32[1] = *(float *)&v75 + *(float *)v76.i32;
  *(double *)v79.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v69.i64, v77, v71, v73, v74, v76, v75, v78);
  v80 = COERCE_DOUBLE(__PAIR64__(a4.u32[3], v93.u32[0]));
  v81 = vadd_f32((float32x2_t)__PAIR64__(a4.u32[3], v93.u32[0]), *(float32x2_t *)v101.i8);
  *(float *)&v82 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v81, 1), *(float *)(a1 + 16), v81.f32[0]);
  LODWORD(v80) = *(_DWORD *)(a1 + 24);
  v83.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v84) = *(_DWORD *)(a1 + 36);
  *(float *)v85.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v81, 1), *(float *)v83.i32, v81.f32[0]);
  v86 = (float64x2_t)v98;
  v102 = vaddq_f32(v98, vmulq_laneq_f32(v79, a3, 3));
  v79.f32[0] = *(float *)&v80 + *(float *)&v82;
  *(float *)v86.f64 = *(float *)&v84 + *(float *)v85.i32;
  v79.f32[1] = *(float *)&v84 + *(float *)v85.i32;
  *(double *)v88.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v79.i64, v86, v80, v82, v83, v85, v84, v87);
  *(_QWORD *)&result = vaddq_f32(v102, vmulq_n_f32(v88, *(float *)a4.i32)).u64[0];
  return result;
}

double ___ZL18apply1DConvolutionP7CIImageP8CIVectordbb_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double result;

  *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)-*(_DWORD *)(a1 + 32), (double)-*(_DWORD *)(a1 + 36));
  return result;
}

double ___ZL18apply1DConvolutionP7CIImageP8CIVectordbb_block_invoke_2(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double result;

  *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)-*(_DWORD *)(a1 + 32), (double)-*(_DWORD *)(a1 + 36));
  return result;
}

double cikernel::_convolution9(uint64_t a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  int8x16_t v5;
  float64x2_t v6;
  float32x2_t v12;
  float32x2_t v13;
  double v14;
  uint8x8_t v15;
  int8x16_t v16;
  double v17;
  int8x16_t v18;
  float32x4_t v19;
  double v21;
  float32x2_t v22;
  float32x2_t v23;
  double v24;
  int8x16_t v25;
  double v26;
  uint8x8_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x2_t v31;
  float32x2_t v32;
  double v33;
  double v34;
  int8x16_t v35;
  double v36;
  uint8x8_t v37;
  float64x2_t v38;
  int8x16_t v39;
  float32x4_t v40;
  double v41;
  float32x2_t v42;
  double v43;
  int8x16_t v44;
  double v45;
  uint8x8_t v46;
  float64x2_t v47;
  int8x16_t v48;
  float32x4_t v49;
  float64x2_t v50;
  double v51;
  double v52;
  uint8x8_t v53;
  double v54;
  int8x16_t v55;
  float32x4_t v56;
  double v57;
  float32x2_t v58;
  double v59;
  int8x16_t v60;
  double v61;
  uint8x8_t v62;
  float64x2_t v63;
  int8x16_t v64;
  float32x4_t v65;
  float32x2_t v66;
  double v67;
  double v68;
  int8x16_t v69;
  double v70;
  uint8x8_t v71;
  float64x2_t v72;
  int8x16_t v73;
  float32x4_t v74;
  float32x2_t v75;
  double v76;
  double v77;
  int8x16_t v78;
  double v79;
  uint8x8_t v80;
  float64x2_t v81;
  int8x16_t v82;
  float32x4_t v83;
  float32x2_t v84;
  double v85;
  double v86;
  int8x16_t v87;
  double v88;
  uint8x8_t v89;
  float64x2_t v90;
  int8x16_t v91;
  float32x4_t v92;
  double result;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v99;
  float32x2_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  int8x16_t v105;
  float32x4_t v106;

  v5.i64[0] = *(_QWORD *)CI::getDC((CI *)a1);
  v105 = v5;
  v6 = (float64x2_t)vextq_s8(a4, a4, 8uLL);
  v100 = *(float32x2_t *)&v6.f64[0];
  __asm { FMOV            V0.2S, #4.0 }
  v12 = vmul_f32(*(float32x2_t *)&v6.f64[0], _D0);
  v13 = vsub_f32(*(float32x2_t *)v5.i8, v12);
  *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v13, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v13, 1), *(float *)&v14, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)v5.i32;
  *(float *)v6.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v13.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v13, v6, *(double *)v5.i64, v14, v16, v15, v17, v18);
  __asm { FMOV            V1.2S, #3.0 }
  HIDWORD(v21) = v100.i32[1];
  v22 = vmul_f32(v100, _D1);
  v23 = vsub_f32(*(float32x2_t *)v105.i8, v22);
  *(float *)&v24 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v23, 1), *(float *)(a1 + 16), v23.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 24);
  v25.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v26) = *(_DWORD *)(a1 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v23, 1), *(float *)v25.i32, v23.f32[0]);
  v28 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.i8, 1);
  v94 = vaddq_f32(v28, vmulq_n_f32(v19, a2.f32[0]));
  v19.f32[0] = *(float *)&v21 + *(float *)&v24;
  v28.f32[0] = *(float *)&v26 + *(float *)v27.i32;
  v19.f32[1] = *(float *)&v26 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, (float64x2_t)v28, v21, v24, v25, v27, v26, v29);
  v31 = vadd_f32(v100, v100);
  v32 = vsub_f32(*(float32x2_t *)v105.i8, v31);
  *(float *)&v33 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v32, 1), *(float *)(a1 + 16), v32.f32[0]);
  LODWORD(v34) = *(_DWORD *)(a1 + 24);
  v35.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v36) = *(_DWORD *)(a1 + 36);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v32, 1), *(float *)v35.i32, v32.f32[0]);
  v38 = (float64x2_t)v94;
  v95 = vaddq_f32(v94, vmulq_lane_f32(v30, *(float32x2_t *)a2.f32, 1));
  v30.f32[0] = *(float *)&v34 + *(float *)&v33;
  *(float *)v38.f64 = *(float *)&v36 + *(float *)v37.i32;
  v30.f32[1] = *(float *)&v36 + *(float *)v37.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v30.i64, v38, v34, v33, v35, v37, v36, v39);
  HIDWORD(v41) = v105.i32[1];
  v42 = vsub_f32(*(float32x2_t *)v105.i8, v100);
  *(float *)&v43 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v42, 1), *(float *)(a1 + 16), v42.f32[0]);
  LODWORD(v41) = *(_DWORD *)(a1 + 24);
  v44.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v45) = *(_DWORD *)(a1 + 36);
  *(float *)v46.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v42, 1), *(float *)v44.i32, v42.f32[0]);
  v47 = (float64x2_t)v95;
  v96 = vaddq_f32(v95, vmulq_laneq_f32(v40, a2, 2));
  v40.f32[0] = *(float *)&v41 + *(float *)&v43;
  *(float *)v47.f64 = *(float *)&v45 + *(float *)v46.i32;
  v40.f32[1] = *(float *)&v45 + *(float *)v46.i32;
  *(double *)v49.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v40.i64, v47, v41, v43, v44, v46, v45, v48);
  v50 = (float64x2_t)v96;
  v99 = vaddq_f32(v96, vmulq_laneq_f32(v49, a2, 3));
  LODWORD(v51) = *(_DWORD *)(a1 + 28);
  v49.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v105.i8, 1), *(float *)(a1 + 16), *(float *)v105.i32);
  LODWORD(v52) = *(_DWORD *)(a1 + 36);
  *(float *)v50.f64 = *(float *)&v52
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v105.i8, 1), *(float *)&v51, *(float *)v105.i32);
  v49.i32[1] = LODWORD(v50.f64[0]);
  *(double *)v56.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v49.i64, v50, v51, v52, v105, v53, v54, v55);
  HIDWORD(v57) = v105.i32[1];
  v58 = vadd_f32(v100, *(float32x2_t *)v105.i8);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v58, 1), *(float *)(a1 + 16), v58.f32[0]);
  LODWORD(v57) = *(_DWORD *)(a1 + 24);
  v60.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v61) = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v58, 1), *(float *)v60.i32, v58.f32[0]);
  v63 = (float64x2_t)v99;
  v101 = vaddq_f32(v99, vmulq_n_f32(v56, a3.f32[0]));
  v56.f32[0] = *(float *)&v57 + *(float *)&v59;
  *(float *)v63.f64 = *(float *)&v61 + *(float *)v62.i32;
  v56.f32[1] = *(float *)&v61 + *(float *)v62.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v56.i64, v63, v57, v59, v60, v62, v61, v64);
  v66 = vadd_f32(v31, *(float32x2_t *)v105.i8);
  *(float *)&v67 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v66, 1), *(float *)(a1 + 16), v66.f32[0]);
  LODWORD(v68) = *(_DWORD *)(a1 + 24);
  v69.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v70) = *(_DWORD *)(a1 + 36);
  *(float *)v71.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v66, 1), *(float *)v69.i32, v66.f32[0]);
  v72 = (float64x2_t)v101;
  v102 = vaddq_f32(v101, vmulq_lane_f32(v65, *(float32x2_t *)a3.f32, 1));
  v65.f32[0] = *(float *)&v68 + *(float *)&v67;
  *(float *)v72.f64 = *(float *)&v70 + *(float *)v71.i32;
  v65.f32[1] = *(float *)&v70 + *(float *)v71.i32;
  *(double *)v74.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v72, v68, v67, v69, v71, v70, v73);
  v75 = vadd_f32(v22, *(float32x2_t *)v105.i8);
  *(float *)&v76 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v75, 1), *(float *)(a1 + 16), v75.f32[0]);
  LODWORD(v77) = *(_DWORD *)(a1 + 24);
  v78.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v79) = *(_DWORD *)(a1 + 36);
  *(float *)v80.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v75, 1), *(float *)v78.i32, v75.f32[0]);
  v81 = (float64x2_t)v102;
  v103 = vaddq_f32(v102, vmulq_laneq_f32(v74, a3, 2));
  v74.f32[0] = *(float *)&v77 + *(float *)&v76;
  *(float *)v81.f64 = *(float *)&v79 + *(float *)v80.i32;
  v74.f32[1] = *(float *)&v79 + *(float *)v80.i32;
  *(double *)v83.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v74.i64, v81, v77, v76, v78, v80, v79, v82);
  v84 = vadd_f32(v12, *(float32x2_t *)v105.i8);
  *(float *)&v85 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v84, 1), *(float *)(a1 + 16), v84.f32[0]);
  LODWORD(v86) = *(_DWORD *)(a1 + 24);
  v87.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v88) = *(_DWORD *)(a1 + 36);
  *(float *)v89.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v84, 1), *(float *)v87.i32, v84.f32[0]);
  v90 = (float64x2_t)v103;
  v106 = vaddq_f32(v103, vmulq_laneq_f32(v83, a3, 3));
  v83.f32[0] = *(float *)&v86 + *(float *)&v85;
  *(float *)v90.f64 = *(float *)&v88 + *(float *)v89.i32;
  v83.f32[1] = *(float *)&v88 + *(float *)v89.i32;
  *(double *)v92.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v83.i64, v90, v86, v85, v87, v89, v88, v91);
  *(_QWORD *)&result = vaddq_f32(v106, vmulq_n_f32(v92, *(float *)a4.i32)).u64[0];
  return result;
}

double cikernel::_convolution7(uint64_t a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  int8x16_t v5;
  float64x2_t v6;
  float32x2_t v12;
  float32x2_t v13;
  double v14;
  uint8x8_t v15;
  int8x16_t v16;
  double v17;
  int8x16_t v18;
  float32x4_t v19;
  float32x2_t v20;
  float32x2_t v21;
  double v22;
  double v23;
  int8x16_t v24;
  double v25;
  uint8x8_t v26;
  float64x2_t v27;
  int8x16_t v28;
  float32x4_t v29;
  double v30;
  float32x2_t v31;
  double v32;
  int8x16_t v33;
  double v34;
  uint8x8_t v35;
  float64x2_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float64x2_t v39;
  double v40;
  double v41;
  uint8x8_t v42;
  double v43;
  int8x16_t v44;
  float32x4_t v45;
  double v46;
  float32x2_t v47;
  double v48;
  int8x16_t v49;
  double v50;
  uint8x8_t v51;
  float64x2_t v52;
  int8x16_t v53;
  float32x4_t v54;
  float32x2_t v55;
  double v56;
  double v57;
  int8x16_t v58;
  double v59;
  uint8x8_t v60;
  float64x2_t v61;
  int8x16_t v62;
  float32x4_t v63;
  float32x2_t v64;
  double v65;
  double v66;
  int8x16_t v67;
  double v68;
  uint8x8_t v69;
  float64x2_t v70;
  int8x16_t v71;
  float32x4_t v72;
  double result;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x4_t v78;
  float32x4_t v80;
  float32x4_t v81;
  int8x16_t v83;
  float32x4_t v84;

  v5.i64[0] = *(_QWORD *)CI::getDC((CI *)a1);
  v83 = v5;
  v74 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.i8, 1);
  v6 = (float64x2_t)vextq_s8(a4, a4, 8uLL);
  a4.i64[0] = *(_QWORD *)&v6.f64[0];
  __asm { FMOV            V0.2S, #3.0 }
  v12 = vmul_f32(*(float32x2_t *)&v6.f64[0], _D0);
  v13 = vsub_f32(*(float32x2_t *)v5.i8, v12);
  *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v13, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v13, 1), *(float *)&v14, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)v5.i32;
  *(float *)v6.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v13.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v13, v6, *(double *)v5.i64, v14, v16, v15, v17, v18);
  v20 = vadd_f32(*(float32x2_t *)a4.i8, *(float32x2_t *)a4.i8);
  v21 = vsub_f32(*(float32x2_t *)v83.i8, v20);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v21, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 24);
  v24.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v25) = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v21, 1), *(float *)v24.i32, v21.f32[0]);
  v27 = (float64x2_t)v74;
  v75 = vaddq_f32(v74, vmulq_lane_f32(v19, *(float32x2_t *)a2.f32, 1));
  v19.f32[0] = *(float *)&v23 + *(float *)&v22;
  *(float *)v27.f64 = *(float *)&v25 + *(float *)v26.i32;
  v19.f32[1] = *(float *)&v25 + *(float *)v26.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v27, v23, v22, v24, v26, v25, v28);
  HIDWORD(v30) = v83.i32[1];
  v31 = vsub_f32(*(float32x2_t *)v83.i8, *(float32x2_t *)a4.i8);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v31, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 24);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v34) = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v31, 1), *(float *)v33.i32, v31.f32[0]);
  v36 = (float64x2_t)v75;
  v76 = vaddq_f32(v75, vmulq_laneq_f32(v29, a2, 2));
  v29.f32[0] = *(float *)&v30 + *(float *)&v32;
  *(float *)v36.f64 = *(float *)&v34 + *(float *)v35.i32;
  v29.f32[1] = *(float *)&v34 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v36, v30, v32, v33, v35, v34, v37);
  v39 = (float64x2_t)v76;
  v78 = vaddq_f32(v76, vmulq_laneq_f32(v38, a2, 3));
  LODWORD(v40) = *(_DWORD *)(a1 + 28);
  v38.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v83.i8, 1), *(float *)(a1 + 16), *(float *)v83.i32);
  LODWORD(v41) = *(_DWORD *)(a1 + 36);
  *(float *)v39.f64 = *(float *)&v41
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v83.i8, 1), *(float *)&v40, *(float *)v83.i32);
  v38.i32[1] = LODWORD(v39.f64[0]);
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v39, v40, v41, v83, v42, v43, v44);
  HIDWORD(v46) = v83.i32[1];
  v47 = vadd_f32(*(float32x2_t *)a4.i8, *(float32x2_t *)v83.i8);
  *(float *)&v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v47, 1), *(float *)(a1 + 16), v47.f32[0]);
  LODWORD(v46) = *(_DWORD *)(a1 + 24);
  v49.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v50) = *(_DWORD *)(a1 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v47, 1), *(float *)v49.i32, v47.f32[0]);
  v52 = (float64x2_t)v78;
  v80 = vaddq_f32(v78, vmulq_n_f32(v45, a3.f32[0]));
  v45.f32[0] = *(float *)&v46 + *(float *)&v48;
  *(float *)v52.f64 = *(float *)&v50 + *(float *)v51.i32;
  v45.f32[1] = *(float *)&v50 + *(float *)v51.i32;
  *(double *)v54.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v52, v46, v48, v49, v51, v50, v53);
  v55 = vadd_f32(v20, *(float32x2_t *)v83.i8);
  *(float *)&v56 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v55, 1), *(float *)(a1 + 16), v55.f32[0]);
  LODWORD(v57) = *(_DWORD *)(a1 + 24);
  v58.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v59) = *(_DWORD *)(a1 + 36);
  *(float *)v60.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v55, 1), *(float *)v58.i32, v55.f32[0]);
  v61 = (float64x2_t)v80;
  v81 = vaddq_f32(v80, vmulq_lane_f32(v54, *(float32x2_t *)a3.f32, 1));
  v54.f32[0] = *(float *)&v57 + *(float *)&v56;
  *(float *)v61.f64 = *(float *)&v59 + *(float *)v60.i32;
  v54.f32[1] = *(float *)&v59 + *(float *)v60.i32;
  *(double *)v63.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v54.i64, v61, v57, v56, v58, v60, v59, v62);
  v64 = vadd_f32(v12, *(float32x2_t *)v83.i8);
  *(float *)&v65 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v64, 1), *(float *)(a1 + 16), v64.f32[0]);
  LODWORD(v66) = *(_DWORD *)(a1 + 24);
  v67.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v68) = *(_DWORD *)(a1 + 36);
  *(float *)v69.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v64, 1), *(float *)v67.i32, v64.f32[0]);
  v70 = (float64x2_t)v81;
  v84 = vaddq_f32(v81, vmulq_laneq_f32(v63, a3, 2));
  v63.f32[0] = *(float *)&v66 + *(float *)&v65;
  *(float *)v70.f64 = *(float *)&v68 + *(float *)v69.i32;
  v63.f32[1] = *(float *)&v68 + *(float *)v69.i32;
  *(double *)v72.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v63.i64, v70, v66, v65, v67, v69, v68, v71);
  *(_QWORD *)&result = vaddq_f32(v84, vmulq_laneq_f32(v72, a3, 3)).u64[0];
  return result;
}

float32x4_t cikernel::_convolutionrgb9(uint64_t a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  float32x2_t *DC;
  double v6;
  double v7;
  float64x2_t v8;
  double v9;
  int8x16_t v10;
  float64x2_t v16;
  float32x2_t v17;
  double v18;
  double v19;
  uint8x8_t v20;
  int8x16_t v21;
  double v22;
  int8x16_t v23;
  float32x4_t v24;
  double v26;
  float32x2_t v27;
  float32x2_t v28;
  double v29;
  int8x16_t v30;
  double v31;
  uint8x8_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x2_t v36;
  float32x2_t v37;
  double v38;
  double v39;
  int8x16_t v40;
  double v41;
  uint8x8_t v42;
  float64x2_t v43;
  int8x16_t v44;
  float32x4_t v45;
  double v46;
  float32x2_t v47;
  double v48;
  int8x16_t v49;
  double v50;
  uint8x8_t v51;
  float64x2_t v52;
  int8x16_t v53;
  float32x4_t v54;
  double v55;
  float32x2_t v56;
  double v57;
  double v58;
  uint8x8_t v59;
  float32x4_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x2_t v63;
  double v64;
  double v65;
  int8x16_t v66;
  double v67;
  uint8x8_t v68;
  float64x2_t v69;
  int8x16_t v70;
  float32x4_t v71;
  float32x2_t v72;
  double v73;
  double v74;
  int8x16_t v75;
  double v76;
  uint8x8_t v77;
  float64x2_t v78;
  int8x16_t v79;
  float32x4_t v80;
  float32x2_t v81;
  double v82;
  double v83;
  int8x16_t v84;
  double v85;
  uint8x8_t v86;
  float64x2_t v87;
  int8x16_t v88;
  float32x4_t result;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  int8x16_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x2_t v101;
  float32x4_t v102;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v101 = *DC;
  *(float *)&v6 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v7) = *(_DWORD *)(a1 + 36);
  v97 = vextq_s8(a4, a4, 8uLL);
  *(float *)v8.f64 = *(float *)&v7
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  HIDWORD(v6) = LODWORD(v8.f64[0]);
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v6, v8, *(double *)v97.i64, v7, a4, (uint8x8_t)*DC, v9, v10);
  v93 = _Q0;
  __asm { FMOV            V0.2S, #4.0 }
  v16 = (float64x2_t)v97;
  v17 = vmul_f32(*(float32x2_t *)v97.i8, *(float32x2_t *)_Q0.f32);
  *(float32x2_t *)_Q0.f32 = vsub_f32(v101, v17);
  *(float *)&v18 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q0.f32, 1), *(float *)(a1 + 16), _Q0.f32[0]);
  LODWORD(v19) = *(_DWORD *)(a1 + 28);
  v20.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q0.f32, 1), *(float *)&v19, _Q0.f32[0]);
  _Q0.f32[0] = *(float *)(a1 + 24) + *(float *)&v18;
  *(float *)v16.f64 = *(float *)v20.i32 + *(float *)v21.i32;
  _Q0.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)_Q0.i64, v16, v18, v19, v21, v20, v22, v23);
  __asm { FMOV            V1.2S, #3.0 }
  HIDWORD(v26) = v97.i32[1];
  v27 = vmul_f32(*(float32x2_t *)v97.i8, _D1);
  v28 = vsub_f32(v101, v27);
  *(float *)&v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v26) = *(_DWORD *)(a1 + 24);
  v30.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v31) = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)v30.i32, v28.f32[0]);
  v33 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.i8, 1);
  v90 = vaddq_f32(v33, vmulq_n_f32(v24, a2.f32[0]));
  v24.f32[0] = *(float *)&v26 + *(float *)&v29;
  v33.f32[0] = *(float *)&v31 + *(float *)v32.i32;
  v24.f32[1] = *(float *)&v31 + *(float *)v32.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v24.i64, (float64x2_t)v33, v26, v29, v30, v32, v31, v34);
  v36 = vadd_f32(*(float32x2_t *)v97.i8, *(float32x2_t *)v97.i8);
  v37 = vsub_f32(v101, v36);
  *(float *)&v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v37, 1), *(float *)(a1 + 16), v37.f32[0]);
  LODWORD(v39) = *(_DWORD *)(a1 + 24);
  v40.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v41) = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v37, 1), *(float *)v40.i32, v37.f32[0]);
  v43 = (float64x2_t)v90;
  v91 = vaddq_f32(v90, vmulq_lane_f32(v35, *(float32x2_t *)a2.f32, 1));
  v35.f32[0] = *(float *)&v39 + *(float *)&v38;
  *(float *)v43.f64 = *(float *)&v41 + *(float *)v42.i32;
  v35.f32[1] = *(float *)&v41 + *(float *)v42.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v43, v39, v38, v40, v42, v41, v44);
  HIDWORD(v46) = v97.i32[1];
  v47 = vsub_f32(v101, *(float32x2_t *)v97.i8);
  *(float *)&v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v47, 1), *(float *)(a1 + 16), v47.f32[0]);
  LODWORD(v46) = *(_DWORD *)(a1 + 24);
  v49.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v50) = *(_DWORD *)(a1 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v47, 1), *(float *)v49.i32, v47.f32[0]);
  v52 = (float64x2_t)v91;
  v92 = vaddq_f32(v91, vmulq_laneq_f32(v45, a2, 2));
  v45.f32[0] = *(float *)&v46 + *(float *)&v48;
  *(float *)v52.f64 = *(float *)&v50 + *(float *)v51.i32;
  v45.f32[1] = *(float *)&v50 + *(float *)v51.i32;
  *(double *)v54.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v52, v46, v48, v49, v51, v50, v53);
  HIDWORD(v55) = v97.i32[1];
  v56 = vadd_f32(*(float32x2_t *)v97.i8, v101);
  *(float *)&v57 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v56, 1), *(float *)(a1 + 16), v56.f32[0]);
  LODWORD(v55) = *(_DWORD *)(a1 + 24);
  LODWORD(v58) = *(_DWORD *)(a1 + 36);
  *(float *)v59.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v56, 1), *(float *)(a1 + 28), v56.f32[0]);
  v60 = vmulq_n_f32(v93, a3.f32[0]);
  v98 = vaddq_f32(v60, vaddq_f32(v92, vmulq_laneq_f32(v54, a2, 3)));
  v54.f32[0] = *(float *)&v55 + *(float *)&v57;
  v60.f32[0] = *(float *)&v58 + *(float *)v59.i32;
  v54.f32[1] = *(float *)&v58 + *(float *)v59.i32;
  *(double *)v62.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v54.i64, (float64x2_t)v60, v55, v57, (int8x16_t)v93, v59, v58, v61);
  v63 = vadd_f32(v36, v101);
  *(float *)&v64 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v63, 1), *(float *)(a1 + 16), v63.f32[0]);
  LODWORD(v65) = *(_DWORD *)(a1 + 24);
  v66.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v67) = *(_DWORD *)(a1 + 36);
  *(float *)v68.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v63, 1), *(float *)v66.i32, v63.f32[0]);
  v69 = (float64x2_t)v98;
  v99 = vaddq_f32(v98, vmulq_lane_f32(v62, *(float32x2_t *)a3.f32, 1));
  v62.f32[0] = *(float *)&v65 + *(float *)&v64;
  *(float *)v69.f64 = *(float *)&v67 + *(float *)v68.i32;
  v62.f32[1] = *(float *)&v67 + *(float *)v68.i32;
  *(double *)v71.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v62.i64, v69, v65, v64, v66, v68, v67, v70);
  v72 = vadd_f32(v27, v101);
  *(float *)&v73 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v72, 1), *(float *)(a1 + 16), v72.f32[0]);
  LODWORD(v74) = *(_DWORD *)(a1 + 24);
  v75.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v76) = *(_DWORD *)(a1 + 36);
  *(float *)v77.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v72, 1), *(float *)v75.i32, v72.f32[0]);
  v78 = (float64x2_t)v99;
  v100 = vaddq_f32(v99, vmulq_laneq_f32(v71, a3, 2));
  v71.f32[0] = *(float *)&v74 + *(float *)&v73;
  *(float *)v78.f64 = *(float *)&v76 + *(float *)v77.i32;
  v71.f32[1] = *(float *)&v76 + *(float *)v77.i32;
  *(double *)v80.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v71.i64, v78, v74, v73, v75, v77, v76, v79);
  v81 = vadd_f32(v17, v101);
  *(float *)&v82 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v81, 1), *(float *)(a1 + 16), v81.f32[0]);
  LODWORD(v83) = *(_DWORD *)(a1 + 24);
  v84.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v85) = *(_DWORD *)(a1 + 36);
  *(float *)v86.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v81, 1), *(float *)v84.i32, v81.f32[0]);
  v87 = (float64x2_t)v100;
  v102 = vaddq_f32(v100, vmulq_laneq_f32(v80, a3, 3));
  v80.f32[0] = *(float *)&v83 + *(float *)&v82;
  *(float *)v87.f64 = *(float *)&v85 + *(float *)v86.i32;
  v80.f32[1] = *(float *)&v85 + *(float *)v86.i32;
  *(double *)result.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v80.i64, v87, v83, v82, v84, v86, v85, v88);
  result.i64[0] = vaddq_f32(v102, vmulq_n_f32(result, *(float *)a4.i32)).u64[0];
  result.i32[3] = v93.i32[3];
  return result;
}

double cikernel::_convolutionrgb7(uint64_t a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  float32x2_t *DC;
  int8x16_t v6;
  int8x16_t v7;
  double v8;
  double v9;
  float64x2_t v10;
  double v11;
  int8x16_t v12;
  float64x2_t v18;
  float32x2_t v19;
  double v20;
  double v21;
  uint8x8_t v22;
  int8x16_t v23;
  double v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x2_t v27;
  float32x2_t v28;
  double v29;
  double v30;
  int8x16_t v31;
  double v32;
  uint8x8_t v33;
  float64x2_t v34;
  int8x16_t v35;
  float32x4_t v36;
  double v37;
  float32x2_t v38;
  double v39;
  int8x16_t v40;
  double v41;
  uint8x8_t v42;
  float64x2_t v43;
  int8x16_t v44;
  float32x4_t v45;
  double v46;
  float32x2_t v47;
  double v48;
  double v49;
  uint8x8_t v50;
  float32x4_t v51;
  int8x16_t v52;
  float32x4_t v53;
  float32x2_t v54;
  double v55;
  double v56;
  int8x16_t v57;
  double v58;
  uint8x8_t v59;
  float64x2_t v60;
  int8x16_t v61;
  float32x4_t v62;
  float32x2_t v63;
  double v64;
  double v65;
  int8x16_t v66;
  double v67;
  uint8x8_t v68;
  float64x2_t v69;
  int8x16_t v70;
  float32x4_t v71;
  double result;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  int8x16_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x2_t v83;
  float32x4_t v84;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v6.i8 = *DC;
  v83 = *DC;
  v7 = a4;
  v73 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.i8, 1);
  *(float *)&v8 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v9) = *(_DWORD *)(a1 + 36);
  v79 = vextq_s8(v7, v7, 8uLL);
  *(float *)v10.f64 = *(float *)&v9
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  HIDWORD(v8) = LODWORD(v10.f64[0]);
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v8, v10, *(double *)v79.i64, v9, v6, *(uint8x8_t *)v7.i8, v11, v12);
  v76 = _Q0;
  __asm { FMOV            V0.2S, #3.0 }
  v18 = (float64x2_t)v79;
  v19 = vmul_f32(*(float32x2_t *)v79.i8, *(float32x2_t *)_Q0.f32);
  *(float32x2_t *)_Q0.f32 = vsub_f32(v83, v19);
  *(float *)&v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q0.f32, 1), *(float *)(a1 + 16), _Q0.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q0.f32, 1), *(float *)&v21, _Q0.f32[0]);
  _Q0.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v18.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  _Q0.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)_Q0.i64, v18, v20, v21, v23, v22, v24, v25);
  v27 = vadd_f32(*(float32x2_t *)v79.i8, *(float32x2_t *)v79.i8);
  v28 = vsub_f32(v83, v27);
  *(float *)&v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 24);
  v31.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v32) = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)v31.i32, v28.f32[0]);
  v34 = (float64x2_t)v73;
  v74 = vaddq_f32(v73, vmulq_lane_f32(v26, *(float32x2_t *)a2.f32, 1));
  v26.f32[0] = *(float *)&v30 + *(float *)&v29;
  *(float *)v34.f64 = *(float *)&v32 + *(float *)v33.i32;
  v26.f32[1] = *(float *)&v32 + *(float *)v33.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, v34, v30, v29, v31, v33, v32, v35);
  HIDWORD(v37) = v79.i32[1];
  v38 = vsub_f32(v83, *(float32x2_t *)v79.i8);
  *(float *)&v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v38, 1), *(float *)(a1 + 16), v38.f32[0]);
  LODWORD(v37) = *(_DWORD *)(a1 + 24);
  v40.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v41) = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v38, 1), *(float *)v40.i32, v38.f32[0]);
  v43 = (float64x2_t)v74;
  v75 = vaddq_f32(v74, vmulq_laneq_f32(v36, a2, 2));
  v36.f32[0] = *(float *)&v37 + *(float *)&v39;
  *(float *)v43.f64 = *(float *)&v41 + *(float *)v42.i32;
  v36.f32[1] = *(float *)&v41 + *(float *)v42.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v36.i64, v43, v37, v39, v40, v42, v41, v44);
  HIDWORD(v46) = v79.i32[1];
  v47 = vadd_f32(*(float32x2_t *)v79.i8, v83);
  *(float *)&v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v47, 1), *(float *)(a1 + 16), v47.f32[0]);
  LODWORD(v46) = *(_DWORD *)(a1 + 24);
  LODWORD(v49) = *(_DWORD *)(a1 + 36);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v47, 1), *(float *)(a1 + 28), v47.f32[0]);
  v51 = vmulq_n_f32(v76, a3.f32[0]);
  v80 = vaddq_f32(v51, vaddq_f32(v75, vmulq_laneq_f32(v45, a2, 3)));
  v45.f32[0] = *(float *)&v46 + *(float *)&v48;
  v51.f32[0] = *(float *)&v49 + *(float *)v50.i32;
  v45.f32[1] = *(float *)&v49 + *(float *)v50.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, (float64x2_t)v51, v46, v48, (int8x16_t)v76, v50, v49, v52);
  v54 = vadd_f32(v27, v83);
  *(float *)&v55 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v54, 1), *(float *)(a1 + 16), v54.f32[0]);
  LODWORD(v56) = *(_DWORD *)(a1 + 24);
  v57.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v58) = *(_DWORD *)(a1 + 36);
  *(float *)v59.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v54, 1), *(float *)v57.i32, v54.f32[0]);
  v60 = (float64x2_t)v80;
  v81 = vaddq_f32(v80, vmulq_lane_f32(v53, *(float32x2_t *)a3.f32, 1));
  v53.f32[0] = *(float *)&v56 + *(float *)&v55;
  *(float *)v60.f64 = *(float *)&v58 + *(float *)v59.i32;
  v53.f32[1] = *(float *)&v58 + *(float *)v59.i32;
  *(double *)v62.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v53.i64, v60, v56, v55, v57, v59, v58, v61);
  v63 = vadd_f32(v19, v83);
  *(float *)&v64 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v63, 1), *(float *)(a1 + 16), v63.f32[0]);
  LODWORD(v65) = *(_DWORD *)(a1 + 24);
  v66.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v67) = *(_DWORD *)(a1 + 36);
  *(float *)v68.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v63, 1), *(float *)v66.i32, v63.f32[0]);
  v69 = (float64x2_t)v81;
  v84 = vaddq_f32(v81, vmulq_laneq_f32(v62, a3, 2));
  v62.f32[0] = *(float *)&v65 + *(float *)&v64;
  *(float *)v69.f64 = *(float *)&v67 + *(float *)v68.i32;
  v62.f32[1] = *(float *)&v67 + *(float *)v68.i32;
  *(double *)v71.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v62.i64, v69, v65, v64, v66, v68, v67, v70);
  *(_QWORD *)&result = vaddq_f32(v84, vmulq_laneq_f32(v71, a3, 3)).u64[0];
  return result;
}

double cikernel::_convolution5(uint64_t a1, float32x4_t a2, int8x16_t a3)
{
  float64x2_t v4;
  int32x4_t v5;
  float32x2_t v6;
  float32x2_t v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  float32x2_t v15;
  double v16;
  int8x16_t v17;
  double v18;
  uint8x8_t v19;
  float64x2_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float64x2_t v23;
  double v24;
  double v25;
  uint8x8_t v26;
  double v27;
  int8x16_t v28;
  float32x4_t v29;
  double v30;
  float32x2_t v31;
  double v32;
  int8x16_t v33;
  double v34;
  uint8x8_t v35;
  float64x2_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x2_t v39;
  double v40;
  double v41;
  int8x16_t v42;
  double v43;
  uint8x8_t v44;
  float64x2_t v45;
  int8x16_t v46;
  float32x4_t v47;
  double result;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x2_t v52;
  float32x4_t v53;
  int8x16_t v55;
  float32x4_t v57;

  v4.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  v55 = (int8x16_t)v4;
  v5 = vdupq_lane_s32(*(int32x2_t *)a3.i8, 1);
  v49 = (float32x4_t)v5;
  v52 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  v6 = vadd_f32(v52, v52);
  v7 = vsub_f32(*(float32x2_t *)&v4.f64[0], v6);
  *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v7, 1), *(float *)(a1 + 16), v7.f32[0]);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v7, 1), *(float *)&v8, v7.f32[0]);
  v7.f32[0] = *(float *)(a1 + 24) + *(float *)v5.i32;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v7.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v7, v4, *(double *)v5.i64, v8, v10, v9, v11, v12);
  HIDWORD(v14) = v55.i32[1];
  v15 = vsub_f32(*(float32x2_t *)v55.i8, v52);
  *(float *)&v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v15, 1), *(float *)(a1 + 16), v15.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 24);
  v17.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v18) = *(_DWORD *)(a1 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v15, 1), *(float *)v17.i32, v15.f32[0]);
  v20 = (float64x2_t)v49;
  v50 = vaddq_f32(v49, vmulq_n_f32(v13, a2.f32[0]));
  v13.f32[0] = *(float *)&v14 + *(float *)&v16;
  *(float *)v20.f64 = *(float *)&v18 + *(float *)v19.i32;
  v13.f32[1] = *(float *)&v18 + *(float *)v19.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, v20, v14, v16, v17, v19, v18, v21);
  v23 = (float64x2_t)v50;
  v51 = vaddq_f32(v50, vmulq_lane_f32(v22, *(float32x2_t *)a2.f32, 1));
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v22.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v55.i8, 1), *(float *)(a1 + 16), *(float *)v55.i32);
  LODWORD(v25) = *(_DWORD *)(a1 + 36);
  *(float *)v23.f64 = *(float *)&v25
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v55.i8, 1), *(float *)&v24, *(float *)v55.i32);
  v22.i32[1] = LODWORD(v23.f64[0]);
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v22.i64, v23, v24, v25, v55, v26, v27, v28);
  HIDWORD(v30) = v55.i32[1];
  v31 = vadd_f32(v52, *(float32x2_t *)v55.i8);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v31, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 24);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v34) = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v31, 1), *(float *)v33.i32, v31.f32[0]);
  v36 = (float64x2_t)v51;
  v53 = vaddq_f32(v51, vmulq_laneq_f32(v29, a2, 2));
  v29.f32[0] = *(float *)&v30 + *(float *)&v32;
  *(float *)v36.f64 = *(float *)&v34 + *(float *)v35.i32;
  v29.f32[1] = *(float *)&v34 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v36, v30, v32, v33, v35, v34, v37);
  v39 = vadd_f32(v6, *(float32x2_t *)v55.i8);
  *(float *)&v40 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v39, 1), *(float *)(a1 + 16), v39.f32[0]);
  LODWORD(v41) = *(_DWORD *)(a1 + 24);
  v42.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v43) = *(_DWORD *)(a1 + 36);
  *(float *)v44.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v39, 1), *(float *)v42.i32, v39.f32[0]);
  v45 = (float64x2_t)v53;
  v57 = vaddq_f32(v53, vmulq_laneq_f32(v38, a2, 3));
  v38.f32[0] = *(float *)&v41 + *(float *)&v40;
  *(float *)v45.f64 = *(float *)&v43 + *(float *)v44.i32;
  v38.f32[1] = *(float *)&v43 + *(float *)v44.i32;
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v45, v41, v40, v42, v44, v43, v46);
  *(_QWORD *)&result = vaddq_f32(v57, vmulq_n_f32(v47, *(float *)a3.i32)).u64[0];
  return result;
}

void CI::f4_sr_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, __n128, __n128);
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __int128 v20;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, __n128, __n128))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_DWORD *)(v11 + 40);
  v15 = *(_QWORD *)(v11 + 32);
  v16 = *(_DWORD *)(v11 + 64);
  v17 = *(_QWORD *)(v11 + 56);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 80)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v15);
  *(double *)&v20 = v12(a4 + 80 * v13, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_convolution3(uint64_t a1, float32x4_t a2, int8x16_t a3)
{
  float32x2_t *DC;
  int8x16_t v5;
  int32x4_t v6;
  float64x2_t v7;
  float32x2_t v8;
  uint8x8_t v9;
  int8x16_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  float64x2_t v14;
  double v15;
  double v16;
  uint8x8_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  double v21;
  float32x2_t v22;
  double v23;
  int8x16_t v24;
  double v25;
  uint8x8_t v26;
  float64x2_t v27;
  int8x16_t v28;
  float32x4_t v29;
  double result;
  float32x4_t v31;
  float32x4_t v32;
  int8x16_t v34;
  float32x4_t v35;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v5 = a3;
  v6 = vdupq_lane_s32(*(int32x2_t *)a3.i8, 1);
  v7.f64[0] = *(float64_t *)DC;
  v34 = (int8x16_t)v7;
  v31 = (float32x4_t)v6;
  a3.i64[0] = vextq_s8(v5, v5, 8uLL).u64[0];
  v8 = vsub_f32(*DC, *(float32x2_t *)a3.i8);
  *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v8, 1), *(float *)(a1 + 16), v8.f32[0]);
  v6.i32[0] = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v8, 1), *(float *)v6.i32, v8.f32[0]);
  v8.f32[0] = *(float *)(a1 + 24) + *(float *)v5.i32;
  *(float *)v7.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v8.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v8, v7, *(double *)v5.i64, *(double *)v6.i64, v10, v9, v11, v12);
  v14 = (float64x2_t)v31;
  v32 = vaddq_f32(v31, vmulq_lane_f32(v13, *(float32x2_t *)a2.f32, 1));
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v13.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v34.i8, 1), *(float *)(a1 + 16), *(float *)v34.i32);
  LODWORD(v16) = *(_DWORD *)(a1 + 36);
  *(float *)v14.f64 = *(float *)&v16
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v34.i8, 1), *(float *)&v15, *(float *)v34.i32);
  v13.i32[1] = LODWORD(v14.f64[0]);
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, v14, v15, v16, v34, v17, v18, v19);
  HIDWORD(v21) = v34.i32[1];
  v22 = vadd_f32(*(float32x2_t *)a3.i8, *(float32x2_t *)v34.i8);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 24);
  v24.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v25) = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)v24.i32, v22.f32[0]);
  v27 = (float64x2_t)v32;
  v35 = vaddq_f32(v32, vmulq_laneq_f32(v20, a2, 2));
  v20.f32[0] = *(float *)&v21 + *(float *)&v23;
  *(float *)v27.f64 = *(float *)&v25 + *(float *)v26.i32;
  v20.f32[1] = *(float *)&v25 + *(float *)v26.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v27, v21, v23, v24, v26, v25, v28);
  *(_QWORD *)&result = vaddq_f32(v35, vmulq_laneq_f32(v29, a2, 3)).u64[0];
  return result;
}

float32x4_t cikernel::_convolutionrgb5(uint64_t a1, float32x4_t a2, int8x16_t a3)
{
  float32x2_t *DC;
  double v5;
  double v6;
  float64x2_t v7;
  double v8;
  int8x16_t v9;
  float32x4_t v10;
  float32x2_t v11;
  double v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  float64x2_t v16;
  double v17;
  int8x16_t v18;
  float32x4_t v19;
  double v20;
  float32x2_t v21;
  double v22;
  int8x16_t v23;
  double v24;
  uint8x8_t v25;
  float32x4_t v26;
  int8x16_t v27;
  float32x4_t v28;
  double v29;
  float32x2_t v30;
  double v31;
  double v32;
  uint8x8_t v33;
  float32x4_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x2_t v37;
  double v38;
  double v39;
  int8x16_t v40;
  double v41;
  uint8x8_t v42;
  float64x2_t v43;
  int8x16_t v44;
  float32x4_t result;
  float32x4_t v46;
  float32x4_t v47;
  float32x2_t v49;
  float32x4_t v50;
  float32x2_t v52;
  float32x4_t v53;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v52 = *DC;
  *(float *)&v5 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v6) = *(_DWORD *)(a1 + 36);
  v49 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  *(float *)v7.f64 = *(float *)&v6
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  HIDWORD(v5) = LODWORD(v7.f64[0]);
  *(double *)v10.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v5, v7, *(double *)&v49, v6, a3, (uint8x8_t)*DC, v8, v9);
  v47 = v10;
  v11 = vadd_f32(v49, v49);
  *(float32x2_t *)v10.f32 = vsub_f32(v52, v11);
  *(float *)&v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v10.f32, 1), *(float *)(a1 + 16), v10.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v10.f32, 1), *(float *)&v13, v10.f32[0]);
  v10.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v16.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v10.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v10.i64, v16, v12, v13, v15, v14, v17, v18);
  HIDWORD(v20) = v49.i32[1];
  v21 = vsub_f32(v52, v49);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v21, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v20) = *(_DWORD *)(a1 + 24);
  v23.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v24) = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v21, 1), *(float *)v23.i32, v21.f32[0]);
  v26 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a3.i8, 1);
  v46 = vaddq_f32(v26, vmulq_n_f32(v19, a2.f32[0]));
  v19.f32[0] = *(float *)&v20 + *(float *)&v22;
  v26.f32[0] = *(float *)&v24 + *(float *)v25.i32;
  v19.f32[1] = *(float *)&v24 + *(float *)v25.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, (float64x2_t)v26, v20, v22, v23, v25, v24, v27);
  HIDWORD(v29) = v49.i32[1];
  v30 = vadd_f32(v49, v52);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v30, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v29) = *(_DWORD *)(a1 + 24);
  LODWORD(v32) = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v30, 1), *(float *)(a1 + 28), v30.f32[0]);
  v34 = vmulq_laneq_f32(v47, a2, 2);
  v50 = vaddq_f32(v34, vaddq_f32(v46, vmulq_lane_f32(v28, *(float32x2_t *)a2.f32, 1)));
  v28.f32[0] = *(float *)&v29 + *(float *)&v31;
  v34.f32[0] = *(float *)&v32 + *(float *)v33.i32;
  v28.f32[1] = *(float *)&v32 + *(float *)v33.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, (float64x2_t)v34, v29, v31, (int8x16_t)a2, v33, v32, v35);
  v37 = vadd_f32(v11, v52);
  *(float *)&v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v37, 1), *(float *)(a1 + 16), v37.f32[0]);
  LODWORD(v39) = *(_DWORD *)(a1 + 24);
  v40.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v41) = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v37, 1), *(float *)v40.i32, v37.f32[0]);
  v43 = (float64x2_t)v50;
  v53 = vaddq_f32(v50, vmulq_laneq_f32(v36, a2, 3));
  v36.f32[0] = *(float *)&v39 + *(float *)&v38;
  *(float *)v43.f64 = *(float *)&v41 + *(float *)v42.i32;
  v36.f32[1] = *(float *)&v41 + *(float *)v42.i32;
  *(double *)result.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v36.i64, v43, v39, v38, v40, v42, v41, v44);
  result.i64[0] = vaddq_f32(v53, vmulq_n_f32(result, *(float *)a3.i32)).u64[0];
  result.i32[3] = v47.i32[3];
  return result;
}

float32x4_t cikernel::_convolutionrgb3(uint64_t a1, float32x4_t a2, int8x16_t a3)
{
  float32x2_t *DC;
  int8x16_t v5;
  double v6;
  double v7;
  float64x2_t v8;
  double v9;
  int8x16_t v10;
  float32x4_t v11;
  float64x2_t v12;
  double v13;
  double v14;
  uint8x8_t v15;
  int8x16_t v16;
  double v17;
  int8x16_t v18;
  float32x4_t v19;
  double v20;
  float32x2_t v21;
  double v22;
  double v23;
  uint8x8_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t result;
  float32x4_t v28;
  int8x16_t v29;
  float32x2_t v30;
  float32x4_t v31;
  float32x4_t v33;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v5.i8 = *DC;
  v28 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a3.i8, 1);
  *(float *)&v6 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v7) = *(_DWORD *)(a1 + 36);
  v29 = vextq_s8(a3, a3, 8uLL);
  v30 = *DC;
  *(float *)v8.f64 = *(float *)&v7
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  HIDWORD(v6) = LODWORD(v8.f64[0]);
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v6, v8, *(double *)v29.i64, v7, v5, *(uint8x8_t *)a3.i8, v9, v10);
  v33 = v11;
  v12 = (float64x2_t)v29;
  *(float32x2_t *)v11.f32 = vsub_f32(v30, *(float32x2_t *)v29.i8);
  *(float *)&v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v11.f32, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v11.f32, 1), *(float *)&v14, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v13;
  *(float *)v12.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v11.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, v12, v13, v14, v16, v15, v17, v18);
  HIDWORD(v20) = v29.i32[1];
  v21 = vadd_f32(*(float32x2_t *)v29.i8, v30);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v21, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v20) = *(_DWORD *)(a1 + 24);
  LODWORD(v23) = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v21, 1), *(float *)(a1 + 28), v21.f32[0]);
  v25 = vmulq_laneq_f32(v33, a2, 2);
  v31 = vaddq_f32(v25, vaddq_f32(v28, vmulq_lane_f32(v19, *(float32x2_t *)a2.f32, 1)));
  v19.f32[0] = *(float *)&v20 + *(float *)&v22;
  v25.f32[0] = *(float *)&v23 + *(float *)v24.i32;
  v19.f32[1] = *(float *)&v23 + *(float *)v24.i32;
  *(double *)result.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, (float64x2_t)v25, v20, v22, (int8x16_t)a2, v24, v23, v26);
  result.i64[0] = vaddq_f32(v31, vmulq_laneq_f32(result, a2, 3)).u64[0];
  result.i32[3] = v33.i32[3];
  return result;
}

float32x4_t cikernel::_convolutionrgb5x5(uint64_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, int8x16_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8)
{
  float32x2_t *DC;
  float64x2_t v10;
  int8x16_t v11;
  double v12;
  double v13;
  double v14;
  int8x16_t v15;
  float32x4_t v16;
  float64x2_t v17;
  double v18;
  double v19;
  uint8x8_t v20;
  int8x16_t v21;
  double v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x2_t v25;
  double v26;
  float32x2_t v27;
  double v28;
  int8x16_t v29;
  double v30;
  uint8x8_t v31;
  float64x2_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x2_t v35;
  double v36;
  float32x2_t v37;
  double v38;
  int8x16_t v39;
  double v40;
  uint8x8_t v41;
  float64x2_t v42;
  int8x16_t v43;
  float32x4_t v44;
  double v45;
  float32x2_t v46;
  double v47;
  int8x16_t v48;
  double v49;
  uint8x8_t v50;
  float64x2_t v51;
  int8x16_t v52;
  float32x4_t v53;
  double v54;
  float32x2_t v55;
  double v56;
  int8x16_t v57;
  double v58;
  uint8x8_t v59;
  float64x2_t v60;
  int8x16_t v61;
  float32x4_t v62;
  double v63;
  float32x2_t v64;
  double v65;
  int8x16_t v66;
  double v67;
  uint8x8_t v68;
  float64x2_t v69;
  int8x16_t v70;
  float32x4_t v71;
  double v72;
  float32x2_t v73;
  double v74;
  int8x16_t v75;
  double v76;
  uint8x8_t v77;
  float64x2_t v78;
  int8x16_t v79;
  float32x4_t v80;
  double v81;
  float32x2_t v82;
  double v83;
  int8x16_t v84;
  double v85;
  uint8x8_t v86;
  float64x2_t v87;
  int8x16_t v88;
  float32x4_t v89;
  double v90;
  float32x2_t v91;
  double v92;
  int8x16_t v93;
  double v94;
  uint8x8_t v95;
  float64x2_t v96;
  int8x16_t v97;
  float32x4_t v98;
  double v99;
  float32x2_t v100;
  double v101;
  int8x16_t v102;
  double v103;
  uint8x8_t v104;
  float64x2_t v105;
  int8x16_t v106;
  float32x4_t v107;
  double v108;
  float32x2_t v109;
  double v110;
  int8x16_t v111;
  double v112;
  uint8x8_t v113;
  float64x2_t v114;
  int8x16_t v115;
  float32x4_t v116;
  double v117;
  float32x2_t v118;
  double v119;
  int8x16_t v120;
  double v121;
  uint8x8_t v122;
  float64x2_t v123;
  int8x16_t v124;
  float32x4_t v125;
  double v126;
  float32x2_t v127;
  double v128;
  double v129;
  uint8x8_t v130;
  float32x4_t v131;
  int8x16_t v132;
  float32x4_t v133;
  double v134;
  float32x2_t v135;
  double v136;
  int8x16_t v137;
  double v138;
  uint8x8_t v139;
  float64x2_t v140;
  int8x16_t v141;
  float32x4_t v142;
  double v143;
  float32x2_t v144;
  double v145;
  int8x16_t v146;
  double v147;
  uint8x8_t v148;
  float64x2_t v149;
  int8x16_t v150;
  float32x4_t v151;
  double v152;
  float32x2_t v153;
  double v154;
  int8x16_t v155;
  double v156;
  uint8x8_t v157;
  float64x2_t v158;
  int8x16_t v159;
  float32x4_t v160;
  float32x2_t v161;
  double v162;
  float32x2_t v163;
  double v164;
  int8x16_t v165;
  double v166;
  uint8x8_t v167;
  float64x2_t v168;
  int8x16_t v169;
  float32x4_t v170;
  double v171;
  float32x2_t v172;
  double v173;
  int8x16_t v174;
  double v175;
  uint8x8_t v176;
  float64x2_t v177;
  int8x16_t v178;
  float32x4_t v179;
  double v180;
  float32x2_t v181;
  double v182;
  int8x16_t v183;
  double v184;
  uint8x8_t v185;
  float64x2_t v186;
  int8x16_t v187;
  float32x4_t v188;
  double v189;
  float32x2_t v190;
  double v191;
  int8x16_t v192;
  double v193;
  uint8x8_t v194;
  float64x2_t v195;
  int8x16_t v196;
  float32x4_t v197;
  double v198;
  float32x2_t v199;
  double v200;
  int8x16_t v201;
  double v202;
  uint8x8_t v203;
  float64x2_t v204;
  int8x16_t v205;
  float32x4_t v206;
  float32x2_t v207;
  double v208;
  float32x2_t v209;
  double v210;
  int8x16_t v211;
  double v212;
  uint8x8_t v213;
  float64x2_t v214;
  int8x16_t v215;
  float32x4_t v216;
  double v217;
  float32x2_t v218;
  double v219;
  int8x16_t v220;
  double v221;
  uint8x8_t v222;
  float64x2_t v223;
  int8x16_t v224;
  float32x4_t v225;
  double v226;
  float32x2_t v227;
  double v228;
  int8x16_t v229;
  double v230;
  uint8x8_t v231;
  float64x2_t v232;
  int8x16_t v233;
  float32x4_t result;
  float32x4_t v235;
  float32x4_t v236;
  float32x4_t v237;
  float32x4_t v238;
  float32x4_t v239;
  float32x4_t v240;
  float32x4_t v241;
  float32x4_t v242;
  float32x4_t v243;
  float32x4_t v246;
  float32x4_t v247;
  float32x4_t v248;
  float32x4_t v249;
  float32x4_t v251;
  float32x4_t v252;
  float32x4_t v253;
  float32x4_t v255;
  float32x4_t v256;
  float32x4_t v257;
  float32x4_t v258;
  float32x4_t v260;
  float32x4_t v261;
  float32x4_t v262;
  float32x2_t v264;
  float32x4_t v265;
  double v267;
  float64x2_t v268;
  float32x4_t v269;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v10 = (float64x2_t)vdupq_lane_s32(*(int32x2_t *)a8.i8, 1);
  v235 = (float32x4_t)v10;
  *(float32x2_t *)v11.i8 = *DC;
  v264 = (float32x2_t)vextq_s8(a8, a8, 8uLL).u64[0];
  *(float *)&v12 = *(float *)(a1 + 24)
                 + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v13) = *(_DWORD *)(a1 + 36);
  *(float32x2_t *)&v267 = vadd_f32(v264, v264);
  v268 = (float64x2_t)v11;
  *(float *)v10.f64 = *(float *)&v13
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  HIDWORD(v12) = LODWORD(v10.f64[0]);
  *(double *)v16.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v12, v10, v267, v13, v11, (uint8x8_t)v264, v14, v15);
  v239 = v16;
  v16.f32[0] = -*(float *)&v267;
  v16.f32[1] = -*((float *)&v267 + 1);
  v17 = v268;
  *(float32x2_t *)v16.f32 = vadd_f32(*(float32x2_t *)v16.f32, *(float32x2_t *)&v268.f64[0]);
  *(float *)&v18 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v16.f32, 1), *(float *)(a1 + 16), v16.f32[0]);
  LODWORD(v19) = *(_DWORD *)(a1 + 28);
  v20.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v16.f32, 1), *(float *)&v19, v16.f32[0]);
  v16.f32[0] = *(float *)(a1 + 24) + *(float *)&v18;
  *(float *)v17.f64 = *(float *)v20.i32 + *(float *)v21.i32;
  v16.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v16.i64, v17, v18, v19, v21, v20, v22, v23);
  v25.f32[0] = -*(float *)&a8.i32[2];
  v25.f32[1] = -*((float *)&v267 + 1);
  HIDWORD(v26) = HIDWORD(v268.f64[0]);
  v27 = vadd_f32(v25, *(float32x2_t *)&v268.f64[0]);
  *(float *)&v28 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v27, 1), *(float *)(a1 + 16), v27.f32[0]);
  LODWORD(v26) = *(_DWORD *)(a1 + 24);
  v29.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v30) = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v27, 1), *(float *)v29.i32, v27.f32[0]);
  v32 = (float64x2_t)v235;
  v236 = vaddq_f32(v235, vmulq_n_f32(v24, a2.f32[0]));
  v24.f32[0] = *(float *)&v26 + *(float *)&v28;
  *(float *)v32.f64 = *(float *)&v30 + *(float *)v31.i32;
  v24.f32[1] = *(float *)&v30 + *(float *)v31.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v24.i64, v32, v26, v28, v29, v31, v30, v33);
  v35.i32[0] = 0;
  v35.f32[1] = -*((float *)&v267 + 1);
  HIDWORD(v36) = HIDWORD(v268.f64[0]);
  v37 = vadd_f32(v35, *(float32x2_t *)&v268.f64[0]);
  *(float *)&v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v37, 1), *(float *)(a1 + 16), v37.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a1 + 24);
  v39.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v40) = *(_DWORD *)(a1 + 36);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v37, 1), *(float *)v39.i32, v37.f32[0]);
  v42 = (float64x2_t)v236;
  v237 = vaddq_f32(v236, vmulq_lane_f32(v34, *(float32x2_t *)a2.f32, 1));
  v34.f32[0] = *(float *)&v36 + *(float *)&v38;
  *(float *)v42.f64 = *(float *)&v40 + *(float *)v41.i32;
  v34.f32[1] = *(float *)&v40 + *(float *)v41.i32;
  *(double *)v44.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v34.i64, v42, v36, v38, v39, v41, v40, v43);
  HIDWORD(v45) = HIDWORD(v268.f64[0]);
  v46 = vadd_f32((float32x2_t)__PAIR64__(-*((float *)&v267 + 1), v264.u32[0]), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v47 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v46, 1), *(float *)(a1 + 16), v46.f32[0]);
  LODWORD(v45) = *(_DWORD *)(a1 + 24);
  v48.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v49) = *(_DWORD *)(a1 + 36);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v46, 1), *(float *)v48.i32, v46.f32[0]);
  v51 = (float64x2_t)v237;
  v238 = vaddq_f32(v237, vmulq_laneq_f32(v44, a2, 2));
  v44.f32[0] = *(float *)&v45 + *(float *)&v47;
  *(float *)v51.f64 = *(float *)&v49 + *(float *)v50.i32;
  v44.f32[1] = *(float *)&v49 + *(float *)v50.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v44.i64, v51, v45, v47, v48, v50, v49, v52);
  HIDWORD(v54) = HIDWORD(v268.f64[0]);
  v55 = vadd_f32((float32x2_t)__PAIR64__(-*((float *)&v267 + 1), LODWORD(v267)), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v56 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v55, 1), *(float *)(a1 + 16), v55.f32[0]);
  LODWORD(v54) = *(_DWORD *)(a1 + 24);
  v57.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v58) = *(_DWORD *)(a1 + 36);
  *(float *)v59.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v55, 1), *(float *)v57.i32, v55.f32[0]);
  v60 = (float64x2_t)v238;
  v240 = vaddq_f32(v238, vmulq_laneq_f32(v53, a2, 3));
  v53.f32[0] = *(float *)&v54 + *(float *)&v56;
  *(float *)v60.f64 = *(float *)&v58 + *(float *)v59.i32;
  v53.f32[1] = *(float *)&v58 + *(float *)v59.i32;
  *(double *)v62.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v53.i64, v60, v54, v56, v57, v59, v58, v61);
  HIDWORD(v63) = HIDWORD(v268.f64[0]);
  v64 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], -*(float *)&v267), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v65 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v64, 1), *(float *)(a1 + 16), v64.f32[0]);
  LODWORD(v63) = *(_DWORD *)(a1 + 24);
  v66.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v67) = *(_DWORD *)(a1 + 36);
  *(float *)v68.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v64, 1), *(float *)v66.i32, v64.f32[0]);
  v69 = (float64x2_t)v240;
  v241 = vaddq_f32(v240, vmulq_n_f32(v62, a3.f32[0]));
  v62.f32[0] = *(float *)&v63 + *(float *)&v65;
  *(float *)v69.f64 = *(float *)&v67 + *(float *)v68.i32;
  v62.f32[1] = *(float *)&v67 + *(float *)v68.i32;
  *(double *)v71.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v62.i64, v69, v63, v65, v66, v68, v67, v70);
  HIDWORD(v72) = HIDWORD(v268.f64[0]);
  v73 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], -*(float *)&a8.i32[2]), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v74 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v73, 1), *(float *)(a1 + 16), v73.f32[0]);
  LODWORD(v72) = *(_DWORD *)(a1 + 24);
  v75.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v76) = *(_DWORD *)(a1 + 36);
  *(float *)v77.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v73, 1), *(float *)v75.i32, v73.f32[0]);
  v78 = (float64x2_t)v241;
  v242 = vaddq_f32(v241, vmulq_lane_f32(v71, *(float32x2_t *)a3.f32, 1));
  v71.f32[0] = *(float *)&v72 + *(float *)&v74;
  *(float *)v78.f64 = *(float *)&v76 + *(float *)v77.i32;
  v71.f32[1] = *(float *)&v76 + *(float *)v77.i32;
  *(double *)v80.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v71.i64, v78, v72, v74, v75, v77, v76, v79);
  LODWORD(v81) = 0;
  *((float *)&v81 + 1) = -*(float *)&a8.i32[3];
  v82 = vadd_f32(*(float32x2_t *)&v81, *(float32x2_t *)&v268.f64[0]);
  *(float *)&v83 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v82, 1), *(float *)(a1 + 16), v82.f32[0]);
  LODWORD(v81) = *(_DWORD *)(a1 + 24);
  v84.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v85) = *(_DWORD *)(a1 + 36);
  *(float *)v86.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v82, 1), *(float *)v84.i32, v82.f32[0]);
  v87 = (float64x2_t)v242;
  v243 = vaddq_f32(v242, vmulq_laneq_f32(v80, a3, 2));
  v80.f32[0] = *(float *)&v81 + *(float *)&v83;
  *(float *)v87.f64 = *(float *)&v85 + *(float *)v86.i32;
  v80.f32[1] = *(float *)&v85 + *(float *)v86.i32;
  *(double *)v89.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v80.i64, v87, v81, v83, v84, v86, v85, v88);
  HIDWORD(v90) = HIDWORD(v268.f64[0]);
  v91 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], v264.u32[0]), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v92 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v91, 1), *(float *)(a1 + 16), v91.f32[0]);
  LODWORD(v90) = *(_DWORD *)(a1 + 24);
  v93.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v94) = *(_DWORD *)(a1 + 36);
  *(float *)v95.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v91, 1), *(float *)v93.i32, v91.f32[0]);
  v96 = (float64x2_t)v243;
  v246 = vaddq_f32(v243, vmulq_laneq_f32(v89, a3, 3));
  v89.f32[0] = *(float *)&v90 + *(float *)&v92;
  *(float *)v96.f64 = *(float *)&v94 + *(float *)v95.i32;
  v89.f32[1] = *(float *)&v94 + *(float *)v95.i32;
  *(double *)v98.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v89.i64, v96, v90, v92, v93, v95, v94, v97);
  HIDWORD(v99) = HIDWORD(v268.f64[0]);
  v100 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], LODWORD(v267)), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v101 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v100, 1), *(float *)(a1 + 16), v100.f32[0]);
  LODWORD(v99) = *(_DWORD *)(a1 + 24);
  v102.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v103) = *(_DWORD *)(a1 + 36);
  *(float *)v104.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v100, 1), *(float *)v102.i32, v100.f32[0]);
  v105 = (float64x2_t)v246;
  v247 = vaddq_f32(v246, vmulq_n_f32(v98, a4.f32[0]));
  v98.f32[0] = *(float *)&v99 + *(float *)&v101;
  *(float *)v105.f64 = *(float *)&v103 + *(float *)v104.i32;
  v98.f32[1] = *(float *)&v103 + *(float *)v104.i32;
  *(double *)v107.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v98.i64, v105, v99, v101, v102, v104, v103, v106);
  HIDWORD(v108) = HIDWORD(v268.f64[0]);
  v109 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&v267), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v110 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v109, 1), *(float *)(a1 + 16), v109.f32[0]);
  LODWORD(v108) = *(_DWORD *)(a1 + 24);
  v111.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v112) = *(_DWORD *)(a1 + 36);
  *(float *)v113.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v109, 1), *(float *)v111.i32, v109.f32[0]);
  v114 = (float64x2_t)v247;
  v248 = vaddq_f32(v247, vmulq_lane_f32(v107, *(float32x2_t *)a4.f32, 1));
  v107.f32[0] = *(float *)&v108 + *(float *)&v110;
  *(float *)v114.f64 = *(float *)&v112 + *(float *)v113.i32;
  v107.f32[1] = *(float *)&v112 + *(float *)v113.i32;
  *(double *)v116.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v107.i64, v114, v108, v110, v111, v113, v112, v115);
  HIDWORD(v117) = HIDWORD(v268.f64[0]);
  v118 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&a8.i32[2]), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v119 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v118, 1), *(float *)(a1 + 16), v118.f32[0]);
  LODWORD(v117) = *(_DWORD *)(a1 + 24);
  v120.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v121) = *(_DWORD *)(a1 + 36);
  *(float *)v122.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v118, 1), *(float *)v120.i32, v118.f32[0]);
  v123 = (float64x2_t)v248;
  v249 = vaddq_f32(v248, vmulq_laneq_f32(v116, a4, 2));
  v116.f32[0] = *(float *)&v117 + *(float *)&v119;
  *(float *)v123.f64 = *(float *)&v121 + *(float *)v122.i32;
  v116.f32[1] = *(float *)&v121 + *(float *)v122.i32;
  *(double *)v125.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v116.i64, v123, v117, v119, v120, v122, v121, v124);
  HIDWORD(v126) = HIDWORD(v268.f64[0]);
  v127 = vadd_f32((float32x2_t)v264.u32[0], *(float32x2_t *)&v268.f64[0]);
  *(float *)&v128 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v127, 1), *(float *)(a1 + 16), v127.f32[0]);
  LODWORD(v126) = *(_DWORD *)(a1 + 24);
  LODWORD(v129) = *(_DWORD *)(a1 + 36);
  *(float *)v130.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v127, 1), *(float *)(a1 + 28), v127.f32[0]);
  v131 = vmulq_n_f32(v239, *(float *)a5.i32);
  v251 = vaddq_f32(v131, vaddq_f32(v249, vmulq_laneq_f32(v125, a4, 3)));
  v125.f32[0] = *(float *)&v126 + *(float *)&v128;
  v131.f32[0] = *(float *)&v129 + *(float *)v130.i32;
  v125.f32[1] = *(float *)&v129 + *(float *)v130.i32;
  *(double *)v133.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v125.i64, (float64x2_t)v131, v126, v128, a5, v130, v129, v132);
  HIDWORD(v134) = HIDWORD(v268.f64[0]);
  v135 = vadd_f32((float32x2_t)LODWORD(v267), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v136 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v135, 1), *(float *)(a1 + 16), v135.f32[0]);
  LODWORD(v134) = *(_DWORD *)(a1 + 24);
  v137.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v138) = *(_DWORD *)(a1 + 36);
  *(float *)v139.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v135, 1), *(float *)v137.i32, v135.f32[0]);
  v140 = (float64x2_t)v251;
  v252 = vaddq_f32(v251, vmulq_lane_f32(v133, *(float32x2_t *)a5.i8, 1));
  v133.f32[0] = *(float *)&v134 + *(float *)&v136;
  *(float *)v140.f64 = *(float *)&v138 + *(float *)v139.i32;
  v133.f32[1] = *(float *)&v138 + *(float *)v139.i32;
  *(double *)v142.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v133.i64, v140, v134, v136, v137, v139, v138, v141);
  HIDWORD(v143) = HIDWORD(v268.f64[0]);
  v144 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], -*(float *)&v267), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v145 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v144, 1), *(float *)(a1 + 16), v144.f32[0]);
  LODWORD(v143) = *(_DWORD *)(a1 + 24);
  v146.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v147) = *(_DWORD *)(a1 + 36);
  *(float *)v148.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v144, 1), *(float *)v146.i32, v144.f32[0]);
  v149 = (float64x2_t)v252;
  v253 = vaddq_f32(v252, vmulq_laneq_f32(v142, (float32x4_t)a5, 2));
  v142.f32[0] = *(float *)&v143 + *(float *)&v145;
  *(float *)v149.f64 = *(float *)&v147 + *(float *)v148.i32;
  v142.f32[1] = *(float *)&v147 + *(float *)v148.i32;
  *(double *)v151.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v142.i64, v149, v143, v145, v146, v148, v147, v150);
  HIDWORD(v152) = HIDWORD(v268.f64[0]);
  v153 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], -*(float *)&a8.i32[2]), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v154 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v153, 1), *(float *)(a1 + 16), v153.f32[0]);
  LODWORD(v152) = *(_DWORD *)(a1 + 24);
  v155.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v156) = *(_DWORD *)(a1 + 36);
  *(float *)v157.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v153, 1), *(float *)v155.i32, v153.f32[0]);
  v158 = (float64x2_t)v253;
  v255 = vaddq_f32(v253, vmulq_laneq_f32(v151, (float32x4_t)a5, 3));
  v151.f32[0] = *(float *)&v152 + *(float *)&v154;
  *(float *)v158.f64 = *(float *)&v156 + *(float *)v157.i32;
  v151.f32[1] = *(float *)&v156 + *(float *)v157.i32;
  *(double *)v160.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v151.i64, v158, v152, v154, v155, v157, v156, v159);
  v161.i32[1] = v264.i32[1];
  v161.i32[0] = 0;
  HIDWORD(v162) = HIDWORD(v268.f64[0]);
  v163 = vadd_f32(v161, *(float32x2_t *)&v268.f64[0]);
  *(float *)&v164 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v163, 1), *(float *)(a1 + 16), v163.f32[0]);
  LODWORD(v162) = *(_DWORD *)(a1 + 24);
  v165.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v166) = *(_DWORD *)(a1 + 36);
  *(float *)v167.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v163, 1), *(float *)v165.i32, v163.f32[0]);
  v168 = (float64x2_t)v255;
  v256 = vaddq_f32(v255, vmulq_n_f32(v160, a6.f32[0]));
  v160.f32[0] = *(float *)&v162 + *(float *)&v164;
  *(float *)v168.f64 = *(float *)&v166 + *(float *)v167.i32;
  v160.f32[1] = *(float *)&v166 + *(float *)v167.i32;
  *(double *)v170.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v160.i64, v168, v162, v164, v165, v167, v166, v169);
  HIDWORD(v171) = HIDWORD(v268.f64[0]);
  v172 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], v264.u32[0]), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v173 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v172, 1), *(float *)(a1 + 16), v172.f32[0]);
  LODWORD(v171) = *(_DWORD *)(a1 + 24);
  v174.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v175) = *(_DWORD *)(a1 + 36);
  *(float *)v176.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v172, 1), *(float *)v174.i32, v172.f32[0]);
  v177 = (float64x2_t)v256;
  v257 = vaddq_f32(v256, vmulq_lane_f32(v170, *(float32x2_t *)a6.f32, 1));
  v170.f32[0] = *(float *)&v171 + *(float *)&v173;
  *(float *)v177.f64 = *(float *)&v175 + *(float *)v176.i32;
  v170.f32[1] = *(float *)&v175 + *(float *)v176.i32;
  *(double *)v179.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v170.i64, v177, v171, v173, v174, v176, v175, v178);
  HIDWORD(v180) = HIDWORD(v268.f64[0]);
  v181 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], LODWORD(v267)), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v182 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v181, 1), *(float *)(a1 + 16), v181.f32[0]);
  LODWORD(v180) = *(_DWORD *)(a1 + 24);
  v183.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v184) = *(_DWORD *)(a1 + 36);
  *(float *)v185.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v181, 1), *(float *)v183.i32, v181.f32[0]);
  v186 = (float64x2_t)v257;
  v258 = vaddq_f32(v257, vmulq_laneq_f32(v179, a6, 2));
  v179.f32[0] = *(float *)&v180 + *(float *)&v182;
  *(float *)v186.f64 = *(float *)&v184 + *(float *)v185.i32;
  v179.f32[1] = *(float *)&v184 + *(float *)v185.i32;
  *(double *)v188.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v179.i64, v186, v180, v182, v183, v185, v184, v187);
  HIDWORD(v189) = HIDWORD(v268.f64[0]);
  v190 = vadd_f32((float32x2_t)__PAIR64__(HIDWORD(v267), -*(float *)&v267), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v191 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v190, 1), *(float *)(a1 + 16), v190.f32[0]);
  LODWORD(v189) = *(_DWORD *)(a1 + 24);
  v192.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v193) = *(_DWORD *)(a1 + 36);
  *(float *)v194.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v190, 1), *(float *)v192.i32, v190.f32[0]);
  v195 = (float64x2_t)v258;
  v260 = vaddq_f32(v258, vmulq_laneq_f32(v188, a6, 3));
  v188.f32[0] = *(float *)&v189 + *(float *)&v191;
  *(float *)v195.f64 = *(float *)&v193 + *(float *)v194.i32;
  v188.f32[1] = *(float *)&v193 + *(float *)v194.i32;
  *(double *)v197.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v188.i64, v195, v189, v191, v192, v194, v193, v196);
  HIDWORD(v198) = HIDWORD(v268.f64[0]);
  v199 = vadd_f32((float32x2_t)__PAIR64__(HIDWORD(v267), -*(float *)&a8.i32[2]), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v200 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v199, 1), *(float *)(a1 + 16), v199.f32[0]);
  LODWORD(v198) = *(_DWORD *)(a1 + 24);
  v201.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v202) = *(_DWORD *)(a1 + 36);
  *(float *)v203.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v199, 1), *(float *)v201.i32, v199.f32[0]);
  v204 = (float64x2_t)v260;
  v261 = vaddq_f32(v260, vmulq_n_f32(v197, a7.f32[0]));
  v197.f32[0] = *(float *)&v198 + *(float *)&v200;
  *(float *)v204.f64 = *(float *)&v202 + *(float *)v203.i32;
  v197.f32[1] = *(float *)&v202 + *(float *)v203.i32;
  *(double *)v206.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v197.i64, v204, v198, v200, v201, v203, v202, v205);
  v207.i32[1] = HIDWORD(v267);
  HIDWORD(v208) = HIDWORD(v268.f64[0]);
  v207.i32[0] = 0;
  v209 = vadd_f32(v207, *(float32x2_t *)&v268.f64[0]);
  *(float *)&v210 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v209, 1), *(float *)(a1 + 16), v209.f32[0]);
  LODWORD(v208) = *(_DWORD *)(a1 + 24);
  v211.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v212) = *(_DWORD *)(a1 + 36);
  *(float *)v213.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v209, 1), *(float *)v211.i32, v209.f32[0]);
  v214 = (float64x2_t)v261;
  v262 = vaddq_f32(v261, vmulq_lane_f32(v206, *(float32x2_t *)a7.f32, 1));
  v206.f32[0] = *(float *)&v208 + *(float *)&v210;
  *(float *)v214.f64 = *(float *)&v212 + *(float *)v213.i32;
  v206.f32[1] = *(float *)&v212 + *(float *)v213.i32;
  *(double *)v216.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v206.i64, v214, v208, v210, v211, v213, v212, v215);
  v217 = COERCE_DOUBLE(__PAIR64__(HIDWORD(v267), v264.u32[0]));
  v218 = vadd_f32((float32x2_t)__PAIR64__(HIDWORD(v267), v264.u32[0]), *(float32x2_t *)&v268.f64[0]);
  *(float *)&v219 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v218, 1), *(float *)(a1 + 16), v218.f32[0]);
  LODWORD(v217) = *(_DWORD *)(a1 + 24);
  v220.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v221) = *(_DWORD *)(a1 + 36);
  *(float *)v222.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v218, 1), *(float *)v220.i32, v218.f32[0]);
  v223 = (float64x2_t)v262;
  v265 = vaddq_f32(v262, vmulq_laneq_f32(v216, a7, 2));
  v216.f32[0] = *(float *)&v217 + *(float *)&v219;
  *(float *)v223.f64 = *(float *)&v221 + *(float *)v222.i32;
  v216.f32[1] = *(float *)&v221 + *(float *)v222.i32;
  *(double *)v225.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v216.i64, v223, v217, v219, v220, v222, v221, v224);
  HIDWORD(v226) = HIDWORD(v267);
  v227 = vadd_f32(*(float32x2_t *)&v267, *(float32x2_t *)&v268.f64[0]);
  *(float *)&v228 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v227, 1), *(float *)(a1 + 16), v227.f32[0]);
  LODWORD(v226) = *(_DWORD *)(a1 + 24);
  v229.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v230) = *(_DWORD *)(a1 + 36);
  *(float *)v231.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v227, 1), *(float *)v229.i32, v227.f32[0]);
  v232 = (float64x2_t)v265;
  v269 = vaddq_f32(v265, vmulq_laneq_f32(v225, a7, 3));
  v225.f32[0] = *(float *)&v226 + *(float *)&v228;
  *(float *)v232.f64 = *(float *)&v230 + *(float *)v231.i32;
  v225.f32[1] = *(float *)&v230 + *(float *)v231.i32;
  *(double *)result.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v225.i64, v232, v226, v228, v229, v231, v230, v233);
  result.i64[0] = vaddq_f32(v269, vmulq_n_f32(result, *(float *)a8.i32)).u64[0];
  result.i32[3] = v239.i32[3];
  return result;
}

void CI::f4_sr_f4_f4_f4_f4_f4_f4_f4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128);
  uint64_t v12;
  int v13;
  const vec2 *v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  __n128 *v27;
  __n128 *v28;
  __n128 *v29;
  __n128 *v30;
  __n128 *v31;
  __n128 *v32;
  __n128 *v33;
  __n128 *v34;
  __n128 *v35;
  __int128 v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  double (*v44)(uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128);
  const vec2 *v45;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(const vec2 **)(v10 + 32);
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  v17 = *(_DWORD *)(v10 + 88);
  v18 = *(_QWORD *)(v10 + 80);
  v19 = *(_DWORD *)(v10 + 112);
  v20 = *(_QWORD *)(v10 + 104);
  v21 = *(_DWORD *)(v10 + 136);
  v22 = *(_QWORD *)(v10 + 128);
  v23 = *(_DWORD *)(v10 + 160);
  v24 = *(_QWORD *)(v10 + 152);
  v25 = *(_DWORD *)(v10 + 184);
  v26 = *(_QWORD *)(v10 + 176);
  if (*(_BYTE *)(a1 + 64))
  {
    v44 = *(double (**)(uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128))(a1 + 24);
    v45 = *(const vec2 **)(v10 + 32);
    v42 = *(_QWORD *)(v10 + 8);
    v43 = *(_QWORD *)(v10 + 56);
    v40 = *(_QWORD *)(v10 + 104);
    v41 = *(_QWORD *)(v10 + 80);
    v38 = *(_DWORD *)(v10 + 160);
    v39 = *(_DWORD *)(v10 + 136);
    v37 = *(_DWORD *)(v10 + 184);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 200)), v14);
    v25 = v37;
    v23 = v38;
    v21 = v39;
    v20 = v40;
    v18 = v41;
    v12 = v42;
    v16 = v43;
    v11 = v44;
    v14 = v45;
  }
  v27 = (__n128 *)(a3 + 16 * v26);
  if (v25 != 5)
    v27 = (__n128 *)(a2 + (v26 << 6));
  v28 = (__n128 *)(a3 + 16 * v24);
  if (v23 != 5)
    v28 = (__n128 *)(a2 + (v24 << 6));
  v29 = (__n128 *)(a3 + 16 * v22);
  if (v21 != 5)
    v29 = (__n128 *)(a2 + (v22 << 6));
  v30 = (__n128 *)(a3 + 16 * v20);
  v31 = (__n128 *)(a2 + (v20 << 6));
  if (v19 != 5)
    v30 = v31;
  v32 = (__n128 *)(a3 + 16 * v18);
  v33 = (__n128 *)(a2 + (v18 << 6));
  if (v17 != 5)
    v32 = v33;
  v34 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v34 = (__n128 *)(a2 + (v16 << 6));
  v35 = (__n128 *)(a3 + 16 * (_QWORD)v14);
  if (v13 != 5)
    v35 = (__n128 *)(a2 + ((_QWORD)v14 << 6));
  *(double *)&v36 = v11(a4 + 80 * v12, *v35, *v34, *v32, *v30, *v29, *v28, *v27);
  *(_OWORD *)(a3 + 16 * a7) = v36;
}

double cikernel::_convolution5x5(uint64_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8)
{
  int8x16_t v9;
  float64x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x2_t v19;
  double v20;
  float32x2_t v21;
  double v22;
  int8x16_t v23;
  double v24;
  uint8x8_t v25;
  float64x2_t v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x2_t v29;
  double v30;
  float32x2_t v31;
  double v32;
  int8x16_t v33;
  double v34;
  uint8x8_t v35;
  float64x2_t v36;
  int8x16_t v37;
  float32x4_t v38;
  double v39;
  float32x2_t v40;
  double v41;
  int8x16_t v42;
  double v43;
  uint8x8_t v44;
  float64x2_t v45;
  int8x16_t v46;
  float32x4_t v47;
  double v48;
  float32x2_t v49;
  double v50;
  int8x16_t v51;
  double v52;
  uint8x8_t v53;
  float64x2_t v54;
  int8x16_t v55;
  float32x4_t v56;
  double v57;
  float32x2_t v58;
  double v59;
  int8x16_t v60;
  double v61;
  uint8x8_t v62;
  float64x2_t v63;
  int8x16_t v64;
  float32x4_t v65;
  double v66;
  float32x2_t v67;
  double v68;
  int8x16_t v69;
  double v70;
  uint8x8_t v71;
  float64x2_t v72;
  int8x16_t v73;
  float32x4_t v74;
  double v75;
  float32x2_t v76;
  double v77;
  int8x16_t v78;
  double v79;
  uint8x8_t v80;
  float64x2_t v81;
  int8x16_t v82;
  float32x4_t v83;
  double v84;
  float32x2_t v85;
  double v86;
  int8x16_t v87;
  double v88;
  uint8x8_t v89;
  float64x2_t v90;
  int8x16_t v91;
  float32x4_t v92;
  double v93;
  float32x2_t v94;
  double v95;
  int8x16_t v96;
  double v97;
  uint8x8_t v98;
  float64x2_t v99;
  int8x16_t v100;
  float32x4_t v101;
  double v102;
  float32x2_t v103;
  double v104;
  int8x16_t v105;
  double v106;
  uint8x8_t v107;
  float64x2_t v108;
  int8x16_t v109;
  float32x4_t v110;
  double v111;
  float32x2_t v112;
  double v113;
  int8x16_t v114;
  double v115;
  uint8x8_t v116;
  float64x2_t v117;
  int8x16_t v118;
  float32x4_t v119;
  float64x2_t v120;
  double v121;
  double v122;
  uint8x8_t v123;
  double v124;
  int8x16_t v125;
  float32x4_t v126;
  double v127;
  float32x2_t v128;
  double v129;
  int8x16_t v130;
  double v131;
  uint8x8_t v132;
  float64x2_t v133;
  int8x16_t v134;
  float32x4_t v135;
  double v136;
  float32x2_t v137;
  double v138;
  int8x16_t v139;
  double v140;
  uint8x8_t v141;
  float64x2_t v142;
  int8x16_t v143;
  float32x4_t v144;
  double v145;
  float32x2_t v146;
  double v147;
  int8x16_t v148;
  double v149;
  uint8x8_t v150;
  float64x2_t v151;
  int8x16_t v152;
  float32x4_t v153;
  double v154;
  float32x2_t v155;
  double v156;
  int8x16_t v157;
  double v158;
  uint8x8_t v159;
  float64x2_t v160;
  int8x16_t v161;
  float32x4_t v162;
  float32x2_t v163;
  double v164;
  float32x2_t v165;
  double v166;
  int8x16_t v167;
  double v168;
  uint8x8_t v169;
  float64x2_t v170;
  int8x16_t v171;
  float32x4_t v172;
  double v173;
  float32x2_t v174;
  double v175;
  int8x16_t v176;
  double v177;
  uint8x8_t v178;
  float64x2_t v179;
  int8x16_t v180;
  float32x4_t v181;
  double v182;
  float32x2_t v183;
  double v184;
  int8x16_t v185;
  double v186;
  uint8x8_t v187;
  float64x2_t v188;
  int8x16_t v189;
  float32x4_t v190;
  double v191;
  float32x2_t v192;
  double v193;
  int8x16_t v194;
  double v195;
  uint8x8_t v196;
  float64x2_t v197;
  int8x16_t v198;
  float32x4_t v199;
  double v200;
  float32x2_t v201;
  double v202;
  int8x16_t v203;
  double v204;
  uint8x8_t v205;
  float64x2_t v206;
  int8x16_t v207;
  float32x4_t v208;
  float32x2_t v209;
  double v210;
  float32x2_t v211;
  double v212;
  int8x16_t v213;
  double v214;
  uint8x8_t v215;
  float64x2_t v216;
  int8x16_t v217;
  float32x4_t v218;
  double v219;
  float32x2_t v220;
  double v221;
  int8x16_t v222;
  double v223;
  uint8x8_t v224;
  float64x2_t v225;
  int8x16_t v226;
  float32x4_t v227;
  double v228;
  float32x2_t v229;
  double v230;
  int8x16_t v231;
  double v232;
  uint8x8_t v233;
  float64x2_t v234;
  int8x16_t v235;
  float32x4_t v236;
  double result;
  float32x4_t v238;
  float32x4_t v239;
  float32x4_t v240;
  float32x4_t v241;
  float32_t v242;
  float32x4_t v243;
  float32x4_t v244;
  float32x4_t v245;
  float32x4_t v246;
  float32x4_t v249;
  float32x4_t v250;
  float32x4_t v251;
  float32x4_t v252;
  float32x4_t v254;
  float32x4_t v255;
  float32x4_t v256;
  float32x4_t v257;
  float32x4_t v259;
  float32x4_t v260;
  float32x4_t v261;
  float32x4_t v262;
  unsigned int v263;
  float32x4_t v265;
  float32x4_t v266;
  float32x4_t v267;
  float32x2_t v269;
  float32x4_t v270;
  float32x2_t v272;
  int8x16_t v273;
  float32x4_t v274;

  v9.i64[0] = *(_QWORD *)CI::getDC((CI *)a1);
  v273 = v9;
  v10 = (float64x2_t)vdupq_lane_s32(*(int32x2_t *)a8.i8, 1);
  v238 = (float32x4_t)v10;
  v269 = (float32x2_t)vextq_s8(a8, a8, 8uLL).u64[0];
  v11 = vadd_f32(v269, v269);
  v272 = v11;
  v11.f32[0] = -v11.f32[0];
  v263 = v11.u32[0];
  v11.f32[1] = -v11.f32[1];
  v242 = v11.f32[1];
  v12 = vadd_f32(v11, *(float32x2_t *)v9.i8);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v12, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v12, 1), *(float *)&v13, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)v9.i32;
  *(float *)v10.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v12.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v12, v10, *(double *)v9.i64, v13, v15, v14, v16, v17);
  v19.f32[0] = -*(float *)&a8.i32[2];
  v19.f32[1] = v242;
  HIDWORD(v20) = v273.i32[1];
  v21 = vadd_f32(v19, *(float32x2_t *)v273.i8);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v21, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v20) = *(_DWORD *)(a1 + 24);
  v23.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v24) = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v21, 1), *(float *)v23.i32, v21.f32[0]);
  v26 = (float64x2_t)v238;
  v239 = vaddq_f32(v238, vmulq_n_f32(v18, a2.f32[0]));
  v18.f32[0] = *(float *)&v20 + *(float *)&v22;
  *(float *)v26.f64 = *(float *)&v24 + *(float *)v25.i32;
  v18.f32[1] = *(float *)&v24 + *(float *)v25.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v26, v20, v22, v23, v25, v24, v27);
  v29.i32[0] = 0;
  v29.f32[1] = v242;
  HIDWORD(v30) = v273.i32[1];
  v31 = vadd_f32(v29, *(float32x2_t *)v273.i8);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v31, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 24);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v34) = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v31, 1), *(float *)v33.i32, v31.f32[0]);
  v36 = (float64x2_t)v239;
  v240 = vaddq_f32(v239, vmulq_lane_f32(v28, *(float32x2_t *)a2.f32, 1));
  v28.f32[0] = *(float *)&v30 + *(float *)&v32;
  *(float *)v36.f64 = *(float *)&v34 + *(float *)v35.i32;
  v28.f32[1] = *(float *)&v34 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v36, v30, v32, v33, v35, v34, v37);
  HIDWORD(v39) = v273.i32[1];
  v40 = vadd_f32((float32x2_t)__PAIR64__(LODWORD(v242), v269.u32[0]), *(float32x2_t *)v273.i8);
  *(float *)&v41 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v40, 1), *(float *)(a1 + 16), v40.f32[0]);
  LODWORD(v39) = *(_DWORD *)(a1 + 24);
  v42.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v43) = *(_DWORD *)(a1 + 36);
  *(float *)v44.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v40, 1), *(float *)v42.i32, v40.f32[0]);
  v45 = (float64x2_t)v240;
  v241 = vaddq_f32(v240, vmulq_laneq_f32(v38, a2, 2));
  v38.f32[0] = *(float *)&v39 + *(float *)&v41;
  *(float *)v45.f64 = *(float *)&v43 + *(float *)v44.i32;
  v38.f32[1] = *(float *)&v43 + *(float *)v44.i32;
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v45, v39, v41, v42, v44, v43, v46);
  HIDWORD(v48) = v273.i32[1];
  v49 = vadd_f32((float32x2_t)__PAIR64__(LODWORD(v242), v272.u32[0]), *(float32x2_t *)v273.i8);
  *(float *)&v50 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v49, 1), *(float *)(a1 + 16), v49.f32[0]);
  LODWORD(v48) = *(_DWORD *)(a1 + 24);
  v51.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v52) = *(_DWORD *)(a1 + 36);
  *(float *)v53.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v49, 1), *(float *)v51.i32, v49.f32[0]);
  v54 = (float64x2_t)v241;
  v243 = vaddq_f32(v241, vmulq_laneq_f32(v47, a2, 3));
  v47.f32[0] = *(float *)&v48 + *(float *)&v50;
  *(float *)v54.f64 = *(float *)&v52 + *(float *)v53.i32;
  v47.f32[1] = *(float *)&v52 + *(float *)v53.i32;
  *(double *)v56.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v47.i64, v54, v48, v50, v51, v53, v52, v55);
  HIDWORD(v57) = v273.i32[1];
  v58 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], v263), *(float32x2_t *)v273.i8);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v58, 1), *(float *)(a1 + 16), v58.f32[0]);
  LODWORD(v57) = *(_DWORD *)(a1 + 24);
  v60.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v61) = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v58, 1), *(float *)v60.i32, v58.f32[0]);
  v63 = (float64x2_t)v243;
  v244 = vaddq_f32(v243, vmulq_n_f32(v56, a3.f32[0]));
  v56.f32[0] = *(float *)&v57 + *(float *)&v59;
  *(float *)v63.f64 = *(float *)&v61 + *(float *)v62.i32;
  v56.f32[1] = *(float *)&v61 + *(float *)v62.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v56.i64, v63, v57, v59, v60, v62, v61, v64);
  HIDWORD(v66) = v273.i32[1];
  v67 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], -*(float *)&a8.i32[2]), *(float32x2_t *)v273.i8);
  *(float *)&v68 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v67, 1), *(float *)(a1 + 16), v67.f32[0]);
  LODWORD(v66) = *(_DWORD *)(a1 + 24);
  v69.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v70) = *(_DWORD *)(a1 + 36);
  *(float *)v71.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v67, 1), *(float *)v69.i32, v67.f32[0]);
  v72 = (float64x2_t)v244;
  v245 = vaddq_f32(v244, vmulq_lane_f32(v65, *(float32x2_t *)a3.f32, 1));
  v65.f32[0] = *(float *)&v66 + *(float *)&v68;
  *(float *)v72.f64 = *(float *)&v70 + *(float *)v71.i32;
  v65.f32[1] = *(float *)&v70 + *(float *)v71.i32;
  *(double *)v74.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v72, v66, v68, v69, v71, v70, v73);
  LODWORD(v75) = 0;
  *((float *)&v75 + 1) = -*(float *)&a8.i32[3];
  v76 = vadd_f32(*(float32x2_t *)&v75, *(float32x2_t *)v273.i8);
  *(float *)&v77 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v76, 1), *(float *)(a1 + 16), v76.f32[0]);
  LODWORD(v75) = *(_DWORD *)(a1 + 24);
  v78.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v79) = *(_DWORD *)(a1 + 36);
  *(float *)v80.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v76, 1), *(float *)v78.i32, v76.f32[0]);
  v81 = (float64x2_t)v245;
  v246 = vaddq_f32(v245, vmulq_laneq_f32(v74, a3, 2));
  v74.f32[0] = *(float *)&v75 + *(float *)&v77;
  *(float *)v81.f64 = *(float *)&v79 + *(float *)v80.i32;
  v74.f32[1] = *(float *)&v79 + *(float *)v80.i32;
  *(double *)v83.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v74.i64, v81, v75, v77, v78, v80, v79, v82);
  HIDWORD(v84) = v273.i32[1];
  v85 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], v269.u32[0]), *(float32x2_t *)v273.i8);
  *(float *)&v86 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v85, 1), *(float *)(a1 + 16), v85.f32[0]);
  LODWORD(v84) = *(_DWORD *)(a1 + 24);
  v87.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v88) = *(_DWORD *)(a1 + 36);
  *(float *)v89.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v85, 1), *(float *)v87.i32, v85.f32[0]);
  v90 = (float64x2_t)v246;
  v249 = vaddq_f32(v246, vmulq_laneq_f32(v83, a3, 3));
  v83.f32[0] = *(float *)&v84 + *(float *)&v86;
  *(float *)v90.f64 = *(float *)&v88 + *(float *)v89.i32;
  v83.f32[1] = *(float *)&v88 + *(float *)v89.i32;
  *(double *)v92.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v83.i64, v90, v84, v86, v87, v89, v88, v91);
  HIDWORD(v93) = v273.i32[1];
  v94 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a8.i32[3], v272.u32[0]), *(float32x2_t *)v273.i8);
  *(float *)&v95 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v94, 1), *(float *)(a1 + 16), v94.f32[0]);
  LODWORD(v93) = *(_DWORD *)(a1 + 24);
  v96.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v97) = *(_DWORD *)(a1 + 36);
  *(float *)v98.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v94, 1), *(float *)v96.i32, v94.f32[0]);
  v99 = (float64x2_t)v249;
  v250 = vaddq_f32(v249, vmulq_n_f32(v92, a4.f32[0]));
  v92.f32[0] = *(float *)&v93 + *(float *)&v95;
  *(float *)v99.f64 = *(float *)&v97 + *(float *)v98.i32;
  v92.f32[1] = *(float *)&v97 + *(float *)v98.i32;
  *(double *)v101.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v92.i64, v99, v93, v95, v96, v98, v97, v100);
  HIDWORD(v102) = v273.i32[1];
  v103 = vadd_f32((float32x2_t)v263, *(float32x2_t *)v273.i8);
  *(float *)&v104 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v103, 1), *(float *)(a1 + 16), v103.f32[0]);
  LODWORD(v102) = *(_DWORD *)(a1 + 24);
  v105.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v106) = *(_DWORD *)(a1 + 36);
  *(float *)v107.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v103, 1), *(float *)v105.i32, v103.f32[0]);
  v108 = (float64x2_t)v250;
  v251 = vaddq_f32(v250, vmulq_lane_f32(v101, *(float32x2_t *)a4.f32, 1));
  v101.f32[0] = *(float *)&v102 + *(float *)&v104;
  *(float *)v108.f64 = *(float *)&v106 + *(float *)v107.i32;
  v101.f32[1] = *(float *)&v106 + *(float *)v107.i32;
  *(double *)v110.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v101.i64, v108, v102, v104, v105, v107, v106, v109);
  HIDWORD(v111) = v273.i32[1];
  v112 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&a8.i32[2]), *(float32x2_t *)v273.i8);
  *(float *)&v113 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v112, 1), *(float *)(a1 + 16), v112.f32[0]);
  LODWORD(v111) = *(_DWORD *)(a1 + 24);
  v114.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v115) = *(_DWORD *)(a1 + 36);
  *(float *)v116.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v112, 1), *(float *)v114.i32, v112.f32[0]);
  v117 = (float64x2_t)v251;
  v252 = vaddq_f32(v251, vmulq_laneq_f32(v110, a4, 2));
  v110.f32[0] = *(float *)&v111 + *(float *)&v113;
  *(float *)v117.f64 = *(float *)&v115 + *(float *)v116.i32;
  v110.f32[1] = *(float *)&v115 + *(float *)v116.i32;
  *(double *)v119.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v110.i64, v117, v111, v113, v114, v116, v115, v118);
  v120 = (float64x2_t)v252;
  v254 = vaddq_f32(v252, vmulq_laneq_f32(v119, a4, 3));
  LODWORD(v121) = *(_DWORD *)(a1 + 28);
  v119.f32[0] = *(float *)(a1 + 24)
              + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v273.i8, 1), *(float *)(a1 + 16), *(float *)v273.i32);
  LODWORD(v122) = *(_DWORD *)(a1 + 36);
  *(float *)v120.f64 = *(float *)&v122
                     + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v273.i8, 1), *(float *)&v121, *(float *)v273.i32);
  v119.i32[1] = LODWORD(v120.f64[0]);
  *(double *)v126.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v119.i64, v120, v121, v122, v273, v123, v124, v125);
  HIDWORD(v127) = v273.i32[1];
  v128 = vadd_f32((float32x2_t)v269.u32[0], *(float32x2_t *)v273.i8);
  *(float *)&v129 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v128, 1), *(float *)(a1 + 16), v128.f32[0]);
  LODWORD(v127) = *(_DWORD *)(a1 + 24);
  v130.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v131) = *(_DWORD *)(a1 + 36);
  *(float *)v132.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v128, 1), *(float *)v130.i32, v128.f32[0]);
  v133 = (float64x2_t)v254;
  v255 = vaddq_f32(v254, vmulq_n_f32(v126, a5.f32[0]));
  v126.f32[0] = *(float *)&v127 + *(float *)&v129;
  *(float *)v133.f64 = *(float *)&v131 + *(float *)v132.i32;
  v126.f32[1] = *(float *)&v131 + *(float *)v132.i32;
  *(double *)v135.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v126.i64, v133, v127, v129, v130, v132, v131, v134);
  HIDWORD(v136) = v273.i32[1];
  v137 = vadd_f32((float32x2_t)v272.u32[0], *(float32x2_t *)v273.i8);
  *(float *)&v138 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v137, 1), *(float *)(a1 + 16), v137.f32[0]);
  LODWORD(v136) = *(_DWORD *)(a1 + 24);
  v139.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v140) = *(_DWORD *)(a1 + 36);
  *(float *)v141.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v137, 1), *(float *)v139.i32, v137.f32[0]);
  v142 = (float64x2_t)v255;
  v256 = vaddq_f32(v255, vmulq_lane_f32(v135, *(float32x2_t *)a5.f32, 1));
  v135.f32[0] = *(float *)&v136 + *(float *)&v138;
  *(float *)v142.f64 = *(float *)&v140 + *(float *)v141.i32;
  v135.f32[1] = *(float *)&v140 + *(float *)v141.i32;
  *(double *)v144.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v135.i64, v142, v136, v138, v139, v141, v140, v143);
  HIDWORD(v145) = v273.i32[1];
  v146 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], v263), *(float32x2_t *)v273.i8);
  *(float *)&v147 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v146, 1), *(float *)(a1 + 16), v146.f32[0]);
  LODWORD(v145) = *(_DWORD *)(a1 + 24);
  v148.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v149) = *(_DWORD *)(a1 + 36);
  *(float *)v150.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v146, 1), *(float *)v148.i32, v146.f32[0]);
  v151 = (float64x2_t)v256;
  v257 = vaddq_f32(v256, vmulq_laneq_f32(v144, a5, 2));
  v144.f32[0] = *(float *)&v145 + *(float *)&v147;
  *(float *)v151.f64 = *(float *)&v149 + *(float *)v150.i32;
  v144.f32[1] = *(float *)&v149 + *(float *)v150.i32;
  *(double *)v153.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v144.i64, v151, v145, v147, v148, v150, v149, v152);
  HIDWORD(v154) = v273.i32[1];
  v155 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], -*(float *)&a8.i32[2]), *(float32x2_t *)v273.i8);
  *(float *)&v156 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v155, 1), *(float *)(a1 + 16), v155.f32[0]);
  LODWORD(v154) = *(_DWORD *)(a1 + 24);
  v157.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v158) = *(_DWORD *)(a1 + 36);
  *(float *)v159.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v155, 1), *(float *)v157.i32, v155.f32[0]);
  v160 = (float64x2_t)v257;
  v259 = vaddq_f32(v257, vmulq_laneq_f32(v153, a5, 3));
  v153.f32[0] = *(float *)&v154 + *(float *)&v156;
  *(float *)v160.f64 = *(float *)&v158 + *(float *)v159.i32;
  v153.f32[1] = *(float *)&v158 + *(float *)v159.i32;
  *(double *)v162.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v153.i64, v160, v154, v156, v157, v159, v158, v161);
  v163.i32[1] = v269.i32[1];
  v163.i32[0] = 0;
  HIDWORD(v164) = v273.i32[1];
  v165 = vadd_f32(v163, *(float32x2_t *)v273.i8);
  *(float *)&v166 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v165, 1), *(float *)(a1 + 16), v165.f32[0]);
  LODWORD(v164) = *(_DWORD *)(a1 + 24);
  v167.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v168) = *(_DWORD *)(a1 + 36);
  *(float *)v169.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v165, 1), *(float *)v167.i32, v165.f32[0]);
  v170 = (float64x2_t)v259;
  v260 = vaddq_f32(v259, vmulq_n_f32(v162, a6.f32[0]));
  v162.f32[0] = *(float *)&v164 + *(float *)&v166;
  *(float *)v170.f64 = *(float *)&v168 + *(float *)v169.i32;
  v162.f32[1] = *(float *)&v168 + *(float *)v169.i32;
  *(double *)v172.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v162.i64, v170, v164, v166, v167, v169, v168, v171);
  HIDWORD(v173) = v273.i32[1];
  v174 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], v269.u32[0]), *(float32x2_t *)v273.i8);
  *(float *)&v175 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v174, 1), *(float *)(a1 + 16), v174.f32[0]);
  LODWORD(v173) = *(_DWORD *)(a1 + 24);
  v176.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v177) = *(_DWORD *)(a1 + 36);
  *(float *)v178.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v174, 1), *(float *)v176.i32, v174.f32[0]);
  v179 = (float64x2_t)v260;
  v261 = vaddq_f32(v260, vmulq_lane_f32(v172, *(float32x2_t *)a6.f32, 1));
  v172.f32[0] = *(float *)&v173 + *(float *)&v175;
  *(float *)v179.f64 = *(float *)&v177 + *(float *)v178.i32;
  v172.f32[1] = *(float *)&v177 + *(float *)v178.i32;
  *(double *)v181.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v172.i64, v179, v173, v175, v176, v178, v177, v180);
  HIDWORD(v182) = v273.i32[1];
  v183 = vadd_f32((float32x2_t)__PAIR64__(a8.u32[3], v272.u32[0]), *(float32x2_t *)v273.i8);
  *(float *)&v184 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v183, 1), *(float *)(a1 + 16), v183.f32[0]);
  LODWORD(v182) = *(_DWORD *)(a1 + 24);
  v185.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v186) = *(_DWORD *)(a1 + 36);
  *(float *)v187.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v183, 1), *(float *)v185.i32, v183.f32[0]);
  v188 = (float64x2_t)v261;
  v262 = vaddq_f32(v261, vmulq_laneq_f32(v181, a6, 2));
  v181.f32[0] = *(float *)&v182 + *(float *)&v184;
  *(float *)v188.f64 = *(float *)&v186 + *(float *)v187.i32;
  v181.f32[1] = *(float *)&v186 + *(float *)v187.i32;
  *(double *)v190.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v181.i64, v188, v182, v184, v185, v187, v186, v189);
  HIDWORD(v191) = v273.i32[1];
  v192 = vadd_f32((float32x2_t)__PAIR64__(v272.u32[1], v263), *(float32x2_t *)v273.i8);
  *(float *)&v193 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v192, 1), *(float *)(a1 + 16), v192.f32[0]);
  LODWORD(v191) = *(_DWORD *)(a1 + 24);
  v194.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v195) = *(_DWORD *)(a1 + 36);
  *(float *)v196.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v192, 1), *(float *)v194.i32, v192.f32[0]);
  v197 = (float64x2_t)v262;
  v265 = vaddq_f32(v262, vmulq_laneq_f32(v190, a6, 3));
  v190.f32[0] = *(float *)&v191 + *(float *)&v193;
  *(float *)v197.f64 = *(float *)&v195 + *(float *)v196.i32;
  v190.f32[1] = *(float *)&v195 + *(float *)v196.i32;
  *(double *)v199.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v190.i64, v197, v191, v193, v194, v196, v195, v198);
  HIDWORD(v200) = v273.i32[1];
  v201 = vadd_f32((float32x2_t)__PAIR64__(v272.u32[1], -*(float *)&a8.i32[2]), *(float32x2_t *)v273.i8);
  *(float *)&v202 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v201, 1), *(float *)(a1 + 16), v201.f32[0]);
  LODWORD(v200) = *(_DWORD *)(a1 + 24);
  v203.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v204) = *(_DWORD *)(a1 + 36);
  *(float *)v205.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v201, 1), *(float *)v203.i32, v201.f32[0]);
  v206 = (float64x2_t)v265;
  v266 = vaddq_f32(v265, vmulq_n_f32(v199, a7.f32[0]));
  v199.f32[0] = *(float *)&v200 + *(float *)&v202;
  *(float *)v206.f64 = *(float *)&v204 + *(float *)v205.i32;
  v199.f32[1] = *(float *)&v204 + *(float *)v205.i32;
  *(double *)v208.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v199.i64, v206, v200, v202, v203, v205, v204, v207);
  v209.i32[1] = v272.i32[1];
  HIDWORD(v210) = v273.i32[1];
  v209.i32[0] = 0;
  v211 = vadd_f32(v209, *(float32x2_t *)v273.i8);
  *(float *)&v212 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v211, 1), *(float *)(a1 + 16), v211.f32[0]);
  LODWORD(v210) = *(_DWORD *)(a1 + 24);
  v213.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v214) = *(_DWORD *)(a1 + 36);
  *(float *)v215.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v211, 1), *(float *)v213.i32, v211.f32[0]);
  v216 = (float64x2_t)v266;
  v267 = vaddq_f32(v266, vmulq_lane_f32(v208, *(float32x2_t *)a7.f32, 1));
  v208.f32[0] = *(float *)&v210 + *(float *)&v212;
  *(float *)v216.f64 = *(float *)&v214 + *(float *)v215.i32;
  v208.f32[1] = *(float *)&v214 + *(float *)v215.i32;
  *(double *)v218.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v208.i64, v216, v210, v212, v213, v215, v214, v217);
  v219 = COERCE_DOUBLE(__PAIR64__(v272.u32[1], v269.u32[0]));
  v220 = vadd_f32((float32x2_t)__PAIR64__(v272.u32[1], v269.u32[0]), *(float32x2_t *)v273.i8);
  *(float *)&v221 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v220, 1), *(float *)(a1 + 16), v220.f32[0]);
  LODWORD(v219) = *(_DWORD *)(a1 + 24);
  v222.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v223) = *(_DWORD *)(a1 + 36);
  *(float *)v224.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v220, 1), *(float *)v222.i32, v220.f32[0]);
  v225 = (float64x2_t)v267;
  v270 = vaddq_f32(v267, vmulq_laneq_f32(v218, a7, 2));
  v218.f32[0] = *(float *)&v219 + *(float *)&v221;
  *(float *)v225.f64 = *(float *)&v223 + *(float *)v224.i32;
  v218.f32[1] = *(float *)&v223 + *(float *)v224.i32;
  *(double *)v227.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v218.i64, v225, v219, v221, v222, v224, v223, v226);
  HIDWORD(v228) = v273.i32[1];
  v229 = vadd_f32(v272, *(float32x2_t *)v273.i8);
  *(float *)&v230 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v229, 1), *(float *)(a1 + 16), v229.f32[0]);
  LODWORD(v228) = *(_DWORD *)(a1 + 24);
  v231.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v232) = *(_DWORD *)(a1 + 36);
  *(float *)v233.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v229, 1), *(float *)v231.i32, v229.f32[0]);
  v234 = (float64x2_t)v270;
  v274 = vaddq_f32(v270, vmulq_laneq_f32(v227, a7, 3));
  v227.f32[0] = *(float *)&v228 + *(float *)&v230;
  *(float *)v234.f64 = *(float *)&v232 + *(float *)v233.i32;
  v227.f32[1] = *(float *)&v232 + *(float *)v233.i32;
  *(double *)v236.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v227.i64, v234, v228, v230, v231, v233, v232, v235);
  *(_QWORD *)&result = vaddq_f32(v274, vmulq_n_f32(v236, *(float *)a8.i32)).u64[0];
  return result;
}

float32x4_t cikernel::_convolutionrgb7x7(uint64_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, int8x16_t a8, float32x4_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float32x4_t a17, float32x4_t a18, float32x4_t a19, float32x4_t a20,int8x16_t a21)
{
  float32x2_t *DC;
  int8x16_t v23;
  float64x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  double v27;
  double v33;
  int8x16_t v34;
  float32x4_t v35;
  float64x2_t v36;
  double v37;
  double v38;
  uint8x8_t v39;
  int8x16_t v40;
  double v41;
  int8x16_t v42;
  float32x4_t v43;
  float32x2_t v44;
  double v45;
  float32x2_t v46;
  double v47;
  int8x16_t v48;
  double v49;
  uint8x8_t v50;
  float64x2_t v51;
  int8x16_t v52;
  float32x4_t v53;
  float32x2_t v54;
  double v55;
  float32x2_t v56;
  double v57;
  int8x16_t v58;
  double v59;
  uint8x8_t v60;
  float64x2_t v61;
  int8x16_t v62;
  float32x4_t v63;
  float32x2_t v64;
  double v65;
  float32x2_t v66;
  double v67;
  int8x16_t v68;
  double v69;
  uint8x8_t v70;
  float64x2_t v71;
  int8x16_t v72;
  float32x4_t v73;
  double v74;
  float32x2_t v75;
  double v76;
  int8x16_t v77;
  double v78;
  uint8x8_t v79;
  float64x2_t v80;
  int8x16_t v81;
  float32x4_t v82;
  double v83;
  float32x2_t v84;
  double v85;
  int8x16_t v86;
  double v87;
  uint8x8_t v88;
  float64x2_t v89;
  int8x16_t v90;
  float32x4_t v91;
  double v92;
  float32x2_t v93;
  double v94;
  int8x16_t v95;
  double v96;
  uint8x8_t v97;
  float64x2_t v98;
  int8x16_t v99;
  float32x4_t v100;
  float32x2_t v101;
  double v102;
  float32x2_t v103;
  double v104;
  int8x16_t v105;
  double v106;
  uint8x8_t v107;
  float64x2_t v108;
  int8x16_t v109;
  float32x4_t v110;
  double v111;
  float32x2_t v112;
  double v113;
  int8x16_t v114;
  double v115;
  uint8x8_t v116;
  float64x2_t v117;
  int8x16_t v118;
  float32x4_t v119;
  double v120;
  float32x2_t v121;
  double v122;
  int8x16_t v123;
  double v124;
  uint8x8_t v125;
  float64x2_t v126;
  int8x16_t v127;
  float32x4_t v128;
  float32x2_t v129;
  double v130;
  float32x2_t v131;
  double v132;
  int8x16_t v133;
  double v134;
  uint8x8_t v135;
  float64x2_t v136;
  int8x16_t v137;
  float32x4_t v138;
  double v139;
  float32x2_t v140;
  double v141;
  int8x16_t v142;
  double v143;
  uint8x8_t v144;
  float64x2_t v145;
  int8x16_t v146;
  float32x4_t v147;
  double v148;
  float32x2_t v149;
  double v150;
  int8x16_t v151;
  double v152;
  uint8x8_t v153;
  float64x2_t v154;
  int8x16_t v155;
  float32x4_t v156;
  double v157;
  float32x2_t v158;
  double v159;
  int8x16_t v160;
  double v161;
  uint8x8_t v162;
  float64x2_t v163;
  int8x16_t v164;
  float32x4_t v165;
  float32x2_t v166;
  double v167;
  float32x2_t v168;
  double v169;
  int8x16_t v170;
  double v171;
  uint8x8_t v172;
  float64x2_t v173;
  int8x16_t v174;
  float32x4_t v175;
  double v176;
  float32x2_t v177;
  double v178;
  int8x16_t v179;
  double v180;
  uint8x8_t v181;
  float64x2_t v182;
  int8x16_t v183;
  float32x4_t v184;
  double v185;
  float32x2_t v186;
  double v187;
  int8x16_t v188;
  double v189;
  uint8x8_t v190;
  float64x2_t v191;
  int8x16_t v192;
  float32x4_t v193;
  double v194;
  float32x2_t v195;
  double v196;
  int8x16_t v197;
  double v198;
  uint8x8_t v199;
  float64x2_t v200;
  int8x16_t v201;
  float32x4_t v202;
  double v203;
  float32x2_t v204;
  double v205;
  int8x16_t v206;
  double v207;
  uint8x8_t v208;
  float64x2_t v209;
  int8x16_t v210;
  float32x4_t v211;
  double v212;
  float32x2_t v213;
  double v214;
  int8x16_t v215;
  double v216;
  uint8x8_t v217;
  float64x2_t v218;
  int8x16_t v219;
  float32x4_t v220;
  double v221;
  float32x2_t v222;
  double v223;
  int8x16_t v224;
  double v225;
  uint8x8_t v226;
  float64x2_t v227;
  int8x16_t v228;
  float32x4_t v229;
  double v230;
  float32x2_t v231;
  double v232;
  int8x16_t v233;
  double v234;
  uint8x8_t v235;
  float64x2_t v236;
  int8x16_t v237;
  float32x4_t v238;
  double v239;
  float32x2_t v240;
  double v241;
  int8x16_t v242;
  double v243;
  uint8x8_t v244;
  float64x2_t v245;
  int8x16_t v246;
  float32x4_t v247;
  double v248;
  float32x2_t v249;
  double v250;
  int8x16_t v251;
  double v252;
  uint8x8_t v253;
  float64x2_t v254;
  int8x16_t v255;
  float32x4_t v256;
  double v257;
  float32x2_t v258;
  double v259;
  double v260;
  uint8x8_t v261;
  float32x4_t v262;
  int8x16_t v263;
  float32x4_t v264;
  double v265;
  float32x2_t v266;
  double v267;
  int8x16_t v268;
  double v269;
  uint8x8_t v270;
  float64x2_t v271;
  int8x16_t v272;
  float32x4_t v273;
  double v274;
  float32x2_t v275;
  double v276;
  int8x16_t v277;
  double v278;
  uint8x8_t v279;
  float64x2_t v280;
  int8x16_t v281;
  float32x4_t v282;
  double v283;
  float32x2_t v284;
  double v285;
  int8x16_t v286;
  double v287;
  uint8x8_t v288;
  float64x2_t v289;
  int8x16_t v290;
  float32x4_t v291;
  double v292;
  float32x2_t v293;
  double v294;
  int8x16_t v295;
  double v296;
  uint8x8_t v297;
  float64x2_t v298;
  int8x16_t v299;
  float32x4_t v300;
  double v301;
  float32x2_t v302;
  double v303;
  int8x16_t v304;
  double v305;
  uint8x8_t v306;
  float64x2_t v307;
  int8x16_t v308;
  float32x4_t v309;
  float32x2_t v310;
  double v311;
  float32x2_t v312;
  double v313;
  int8x16_t v314;
  double v315;
  uint8x8_t v316;
  float64x2_t v317;
  int8x16_t v318;
  float32x4_t v319;
  double v320;
  float32x2_t v321;
  double v322;
  int8x16_t v323;
  double v324;
  uint8x8_t v325;
  float64x2_t v326;
  int8x16_t v327;
  float32x4_t v328;
  double v329;
  float32x2_t v330;
  double v331;
  int8x16_t v332;
  double v333;
  uint8x8_t v334;
  float64x2_t v335;
  int8x16_t v336;
  float32x4_t v337;
  double v338;
  float32x2_t v339;
  double v340;
  int8x16_t v341;
  double v342;
  uint8x8_t v343;
  float64x2_t v344;
  int8x16_t v345;
  float32x4_t v346;
  double v347;
  float32x2_t v348;
  double v349;
  int8x16_t v350;
  double v351;
  uint8x8_t v352;
  float64x2_t v353;
  int8x16_t v354;
  float32x4_t v355;
  double v356;
  float32x2_t v357;
  double v358;
  int8x16_t v359;
  double v360;
  uint8x8_t v361;
  float64x2_t v362;
  int8x16_t v363;
  float32x4_t v364;
  double v365;
  float32x2_t v366;
  double v367;
  int8x16_t v368;
  double v369;
  uint8x8_t v370;
  float64x2_t v371;
  int8x16_t v372;
  float32x4_t v373;
  float32x2_t v374;
  double v375;
  float32x2_t v376;
  double v377;
  int8x16_t v378;
  double v379;
  uint8x8_t v380;
  float64x2_t v381;
  int8x16_t v382;
  float32x4_t v383;
  double v384;
  float32x2_t v385;
  double v386;
  int8x16_t v387;
  double v388;
  uint8x8_t v389;
  float64x2_t v390;
  int8x16_t v391;
  float32x4_t v392;
  double v393;
  float32x2_t v394;
  double v395;
  int8x16_t v396;
  double v397;
  uint8x8_t v398;
  float64x2_t v399;
  int8x16_t v400;
  float32x4_t v401;
  double v402;
  float32x2_t v403;
  double v404;
  int8x16_t v405;
  double v406;
  uint8x8_t v407;
  float64x2_t v408;
  int8x16_t v409;
  float32x4_t v410;
  double v411;
  float32x2_t v412;
  double v413;
  int8x16_t v414;
  double v415;
  uint8x8_t v416;
  float64x2_t v417;
  int8x16_t v418;
  float32x4_t v419;
  double v420;
  float32x2_t v421;
  double v422;
  int8x16_t v423;
  double v424;
  uint8x8_t v425;
  float64x2_t v426;
  int8x16_t v427;
  float32x4_t v428;
  double v429;
  float32x2_t v430;
  double v431;
  int8x16_t v432;
  double v433;
  uint8x8_t v434;
  float64x2_t v435;
  int8x16_t v436;
  float32x4_t v437;
  float32x2_t v438;
  double v439;
  float32x2_t v440;
  double v441;
  int8x16_t v442;
  double v443;
  uint8x8_t v444;
  float64x2_t v445;
  int8x16_t v446;
  float32x4_t v447;
  double v448;
  float32x2_t v449;
  double v450;
  int8x16_t v451;
  double v452;
  uint8x8_t v453;
  float64x2_t v454;
  int8x16_t v455;
  float32x4_t v456;
  double v457;
  float32x2_t v458;
  double v459;
  int8x16_t v460;
  double v461;
  uint8x8_t v462;
  float64x2_t v463;
  int8x16_t v464;
  float32x4_t v465;
  double v466;
  float32x2_t v467;
  double v468;
  int8x16_t v469;
  double v470;
  uint8x8_t v471;
  float64x2_t v472;
  int8x16_t v473;
  float32x4_t result;
  float32x4_t v475;
  float32x4_t v476;
  float32x4_t v477;
  float32x4_t v478;
  float32x4_t v480;
  float32x4_t v481;
  float32x4_t v482;
  float32x4_t v483;
  float32x4_t v485;
  float32x4_t v486;
  float32x4_t v487;
  float32x4_t v488;
  float32x4_t v490;
  float32x4_t v491;
  float32x4_t v492;
  float32x4_t v493;
  float32x4_t v495;
  float32x4_t v496;
  float32x4_t v497;
  float32x4_t v498;
  float32x4_t v503;
  float32x4_t v504;
  float32x4_t v505;
  float32x4_t v506;
  float32x4_t v507;
  float32x4_t v508;
  float32x4_t v509;
  float32x4_t v510;
  float32x4_t v511;
  float32x4_t v512;
  float32x4_t v513;
  float32x4_t v514;
  float32x4_t v515;
  float32x4_t v516;
  float32x4_t v517;
  float32x4_t v518;
  float32x4_t v519;
  float32x4_t v520;
  float32x4_t v521;
  float32x4_t v522;
  unsigned int v523;
  float32x2_t v524;
  double v525;
  float32x2_t v526;
  float32x4_t v527;
  float32x4_t v528;
  float32x4_t v529;
  float32x4_t v530;
  float32x4_t v531;
  float32x4_t v532;
  float32x4_t v533;
  float32x4_t v534;
  float64x2_t v535;
  float32x4_t v536;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v23.i8 = *DC;
  v24 = (float64x2_t)vdupq_lane_s32(*(int32x2_t *)a21.i8, 1);
  v522 = (float32x4_t)v24;
  v25 = (float32x2_t)vextq_s8(a21, a21, 8uLL).u64[0];
  *(float32x2_t *)&v24.f64[0] = vadd_f32(v25, v25);
  v526 = *(float32x2_t *)&v24.f64[0];
  v535 = (float64x2_t)v23;
  v26 = v25;
  v524 = v25;
  v25.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v27) = *(_DWORD *)(a1 + 36);
  __asm { FMOV            V2.2S, #3.0 }
  *(float32x2_t *)&v525 = vmul_f32(v26, _D2);
  *(float *)v24.f64 = *(float *)&v27
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  v25.i32[1] = LODWORD(v24.f64[0]);
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v25, v24, v525, v27, v23, (uint8x8_t)v26, v33, v34);
  v478 = v35;
  v35.f32[0] = -*(float *)&v525;
  v35.f32[1] = -*((float *)&v525 + 1);
  v36 = v535;
  *(float32x2_t *)v35.f32 = vadd_f32(*(float32x2_t *)v35.f32, *(float32x2_t *)&v535.f64[0]);
  *(float *)&v37 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v35.f32, 1), *(float *)(a1 + 16), v35.f32[0]);
  LODWORD(v38) = *(_DWORD *)(a1 + 28);
  v39.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v35.f32, 1), *(float *)&v38, v35.f32[0]);
  v35.f32[0] = *(float *)(a1 + 24) + *(float *)&v37;
  *(float *)v36.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v35.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v36, v37, v38, v40, v39, v41, v42);
  v44.f32[0] = -v526.f32[0];
  *(float *)&v523 = -v526.f32[0];
  v44.f32[1] = -*((float *)&v525 + 1);
  HIDWORD(v45) = HIDWORD(v535.f64[0]);
  v46 = vadd_f32(v44, *(float32x2_t *)&v535.f64[0]);
  *(float *)&v47 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v46, 1), *(float *)(a1 + 16), v46.f32[0]);
  LODWORD(v45) = *(_DWORD *)(a1 + 24);
  v48.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v49) = *(_DWORD *)(a1 + 36);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v46, 1), *(float *)v48.i32, v46.f32[0]);
  v51 = (float64x2_t)v522;
  v475 = vaddq_f32(v522, vmulq_n_f32(v43, a2.f32[0]));
  v43.f32[0] = *(float *)&v45 + *(float *)&v47;
  *(float *)v51.f64 = *(float *)&v49 + *(float *)v50.i32;
  v43.f32[1] = *(float *)&v49 + *(float *)v50.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v43.i64, v51, v45, v47, v48, v50, v49, v52);
  v54.f32[0] = -*(float *)&a21.i32[2];
  v54.f32[1] = -*((float *)&v525 + 1);
  HIDWORD(v55) = HIDWORD(v535.f64[0]);
  v56 = vadd_f32(v54, *(float32x2_t *)&v535.f64[0]);
  *(float *)&v57 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v56, 1), *(float *)(a1 + 16), v56.f32[0]);
  LODWORD(v55) = *(_DWORD *)(a1 + 24);
  v58.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v59) = *(_DWORD *)(a1 + 36);
  *(float *)v60.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v56, 1), *(float *)v58.i32, v56.f32[0]);
  v61 = (float64x2_t)v475;
  v476 = vaddq_f32(v475, vmulq_lane_f32(v53, *(float32x2_t *)a2.f32, 1));
  v53.f32[0] = *(float *)&v55 + *(float *)&v57;
  *(float *)v61.f64 = *(float *)&v59 + *(float *)v60.i32;
  v53.f32[1] = *(float *)&v59 + *(float *)v60.i32;
  *(double *)v63.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v53.i64, v61, v55, v57, v58, v60, v59, v62);
  v64.i32[0] = 0;
  v64.f32[1] = -*((float *)&v525 + 1);
  HIDWORD(v65) = HIDWORD(v535.f64[0]);
  v66 = vadd_f32(v64, *(float32x2_t *)&v535.f64[0]);
  *(float *)&v67 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v66, 1), *(float *)(a1 + 16), v66.f32[0]);
  LODWORD(v65) = *(_DWORD *)(a1 + 24);
  v68.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v69) = *(_DWORD *)(a1 + 36);
  *(float *)v70.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v66, 1), *(float *)v68.i32, v66.f32[0]);
  v71 = (float64x2_t)v476;
  v477 = vaddq_f32(v476, vmulq_laneq_f32(v63, a2, 2));
  v63.f32[0] = *(float *)&v65 + *(float *)&v67;
  *(float *)v71.f64 = *(float *)&v69 + *(float *)v70.i32;
  v63.f32[1] = *(float *)&v69 + *(float *)v70.i32;
  *(double *)v73.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v63.i64, v71, v65, v67, v68, v70, v69, v72);
  HIDWORD(v74) = HIDWORD(v535.f64[0]);
  v75 = vadd_f32((float32x2_t)__PAIR64__(-*((float *)&v525 + 1), v524.u32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v76 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v75, 1), *(float *)(a1 + 16), v75.f32[0]);
  LODWORD(v74) = *(_DWORD *)(a1 + 24);
  v77.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v78) = *(_DWORD *)(a1 + 36);
  *(float *)v79.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v75, 1), *(float *)v77.i32, v75.f32[0]);
  v80 = (float64x2_t)v477;
  v480 = vaddq_f32(v477, vmulq_laneq_f32(v73, a2, 3));
  v73.f32[0] = *(float *)&v74 + *(float *)&v76;
  *(float *)v80.f64 = *(float *)&v78 + *(float *)v79.i32;
  v73.f32[1] = *(float *)&v78 + *(float *)v79.i32;
  *(double *)v82.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v73.i64, v80, v74, v76, v77, v79, v78, v81);
  HIDWORD(v83) = HIDWORD(v535.f64[0]);
  v84 = vadd_f32((float32x2_t)__PAIR64__(-*((float *)&v525 + 1), v526.u32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v85 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v84, 1), *(float *)(a1 + 16), v84.f32[0]);
  LODWORD(v83) = *(_DWORD *)(a1 + 24);
  v86.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v87) = *(_DWORD *)(a1 + 36);
  *(float *)v88.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v84, 1), *(float *)v86.i32, v84.f32[0]);
  v89 = (float64x2_t)v480;
  v481 = vaddq_f32(v480, vmulq_n_f32(v82, a3.f32[0]));
  v82.f32[0] = *(float *)&v83 + *(float *)&v85;
  *(float *)v89.f64 = *(float *)&v87 + *(float *)v88.i32;
  v82.f32[1] = *(float *)&v87 + *(float *)v88.i32;
  *(double *)v91.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v82.i64, v89, v83, v85, v86, v88, v87, v90);
  HIDWORD(v92) = HIDWORD(v535.f64[0]);
  v93 = vadd_f32((float32x2_t)__PAIR64__(-*((float *)&v525 + 1), LODWORD(v525)), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v94 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v93, 1), *(float *)(a1 + 16), v93.f32[0]);
  LODWORD(v92) = *(_DWORD *)(a1 + 24);
  v95.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v96) = *(_DWORD *)(a1 + 36);
  *(float *)v97.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v93, 1), *(float *)v95.i32, v93.f32[0]);
  v98 = (float64x2_t)v481;
  v482 = vaddq_f32(v481, vmulq_lane_f32(v91, *(float32x2_t *)a3.f32, 1));
  v91.f32[0] = *(float *)&v92 + *(float *)&v94;
  *(float *)v98.f64 = *(float *)&v96 + *(float *)v97.i32;
  v91.f32[1] = *(float *)&v96 + *(float *)v97.i32;
  *(double *)v100.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v91.i64, v98, v92, v94, v95, v97, v96, v99);
  v101.f32[0] = -*(float *)&v525;
  v101.f32[1] = -v526.f32[1];
  HIDWORD(v102) = HIDWORD(v535.f64[0]);
  v103 = vadd_f32(v101, *(float32x2_t *)&v535.f64[0]);
  *(float *)&v104 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v103, 1), *(float *)(a1 + 16), v103.f32[0]);
  LODWORD(v102) = *(_DWORD *)(a1 + 24);
  v105.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v106) = *(_DWORD *)(a1 + 36);
  *(float *)v107.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v103, 1), *(float *)v105.i32, v103.f32[0]);
  v108 = (float64x2_t)v482;
  v483 = vaddq_f32(v482, vmulq_laneq_f32(v100, a3, 2));
  v100.f32[0] = *(float *)&v102 + *(float *)&v104;
  *(float *)v108.f64 = *(float *)&v106 + *(float *)v107.i32;
  v100.f32[1] = *(float *)&v106 + *(float *)v107.i32;
  *(double *)v110.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v100.i64, v108, v102, v104, v105, v107, v106, v109);
  HIDWORD(v111) = HIDWORD(v535.f64[0]);
  v112 = vadd_f32((float32x2_t)__PAIR64__(-v526.f32[1], -v526.f32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v113 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v112, 1), *(float *)(a1 + 16), v112.f32[0]);
  LODWORD(v111) = *(_DWORD *)(a1 + 24);
  v114.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v115) = *(_DWORD *)(a1 + 36);
  *(float *)v116.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v112, 1), *(float *)v114.i32, v112.f32[0]);
  v117 = (float64x2_t)v483;
  v485 = vaddq_f32(v483, vmulq_laneq_f32(v110, a3, 3));
  v110.f32[0] = *(float *)&v111 + *(float *)&v113;
  *(float *)v117.f64 = *(float *)&v115 + *(float *)v116.i32;
  v110.f32[1] = *(float *)&v115 + *(float *)v116.i32;
  *(double *)v119.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v110.i64, v117, v111, v113, v114, v116, v115, v118);
  HIDWORD(v120) = HIDWORD(v535.f64[0]);
  v121 = vadd_f32((float32x2_t)__PAIR64__(-v526.f32[1], -*(float *)&a21.i32[2]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v122 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v121, 1), *(float *)(a1 + 16), v121.f32[0]);
  LODWORD(v120) = *(_DWORD *)(a1 + 24);
  v123.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v124) = *(_DWORD *)(a1 + 36);
  *(float *)v125.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v121, 1), *(float *)v123.i32, v121.f32[0]);
  v126 = (float64x2_t)v485;
  v486 = vaddq_f32(v485, vmulq_n_f32(v119, a4.f32[0]));
  v119.f32[0] = *(float *)&v120 + *(float *)&v122;
  *(float *)v126.f64 = *(float *)&v124 + *(float *)v125.i32;
  v119.f32[1] = *(float *)&v124 + *(float *)v125.i32;
  *(double *)v128.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v119.i64, v126, v120, v122, v123, v125, v124, v127);
  v129.i32[0] = 0;
  v129.f32[1] = -v526.f32[1];
  HIDWORD(v130) = HIDWORD(v535.f64[0]);
  v131 = vadd_f32(v129, *(float32x2_t *)&v535.f64[0]);
  *(float *)&v132 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v131, 1), *(float *)(a1 + 16), v131.f32[0]);
  LODWORD(v130) = *(_DWORD *)(a1 + 24);
  v133.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v134) = *(_DWORD *)(a1 + 36);
  *(float *)v135.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v131, 1), *(float *)v133.i32, v131.f32[0]);
  v136 = (float64x2_t)v486;
  v487 = vaddq_f32(v486, vmulq_lane_f32(v128, *(float32x2_t *)a4.f32, 1));
  v128.f32[0] = *(float *)&v130 + *(float *)&v132;
  *(float *)v136.f64 = *(float *)&v134 + *(float *)v135.i32;
  v128.f32[1] = *(float *)&v134 + *(float *)v135.i32;
  *(double *)v138.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v128.i64, v136, v130, v132, v133, v135, v134, v137);
  HIDWORD(v139) = HIDWORD(v535.f64[0]);
  v140 = vadd_f32((float32x2_t)__PAIR64__(-v526.f32[1], v524.u32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v141 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v140, 1), *(float *)(a1 + 16), v140.f32[0]);
  LODWORD(v139) = *(_DWORD *)(a1 + 24);
  v142.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v143) = *(_DWORD *)(a1 + 36);
  *(float *)v144.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v140, 1), *(float *)v142.i32, v140.f32[0]);
  v145 = (float64x2_t)v487;
  v488 = vaddq_f32(v487, vmulq_laneq_f32(v138, a4, 2));
  v138.f32[0] = *(float *)&v139 + *(float *)&v141;
  *(float *)v145.f64 = *(float *)&v143 + *(float *)v144.i32;
  v138.f32[1] = *(float *)&v143 + *(float *)v144.i32;
  *(double *)v147.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v138.i64, v145, v139, v141, v142, v144, v143, v146);
  HIDWORD(v148) = HIDWORD(v535.f64[0]);
  v149 = vadd_f32((float32x2_t)__PAIR64__(-v526.f32[1], v526.u32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v150 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v149, 1), *(float *)(a1 + 16), v149.f32[0]);
  LODWORD(v148) = *(_DWORD *)(a1 + 24);
  v151.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v152) = *(_DWORD *)(a1 + 36);
  *(float *)v153.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v149, 1), *(float *)v151.i32, v149.f32[0]);
  v154 = (float64x2_t)v488;
  v490 = vaddq_f32(v488, vmulq_laneq_f32(v147, a4, 3));
  v147.f32[0] = *(float *)&v148 + *(float *)&v150;
  *(float *)v154.f64 = *(float *)&v152 + *(float *)v153.i32;
  v147.f32[1] = *(float *)&v152 + *(float *)v153.i32;
  *(double *)v156.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v147.i64, v154, v148, v150, v151, v153, v152, v155);
  HIDWORD(v157) = HIDWORD(v535.f64[0]);
  v158 = vadd_f32((float32x2_t)__PAIR64__(-v526.f32[1], LODWORD(v525)), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v159 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v158, 1), *(float *)(a1 + 16), v158.f32[0]);
  LODWORD(v157) = *(_DWORD *)(a1 + 24);
  v160.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v161) = *(_DWORD *)(a1 + 36);
  *(float *)v162.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v158, 1), *(float *)v160.i32, v158.f32[0]);
  v163 = (float64x2_t)v490;
  v491 = vaddq_f32(v490, vmulq_n_f32(v156, a5.f32[0]));
  v156.f32[0] = *(float *)&v157 + *(float *)&v159;
  *(float *)v163.f64 = *(float *)&v161 + *(float *)v162.i32;
  v156.f32[1] = *(float *)&v161 + *(float *)v162.i32;
  *(double *)v165.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v156.i64, v163, v157, v159, v160, v162, v161, v164);
  v166.f32[0] = -*(float *)&v525;
  v166.f32[1] = -*(float *)&a21.i32[3];
  HIDWORD(v167) = HIDWORD(v535.f64[0]);
  v168 = vadd_f32(v166, *(float32x2_t *)&v535.f64[0]);
  *(float *)&v169 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v168, 1), *(float *)(a1 + 16), v168.f32[0]);
  LODWORD(v167) = *(_DWORD *)(a1 + 24);
  v170.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v171) = *(_DWORD *)(a1 + 36);
  *(float *)v172.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v168, 1), *(float *)v170.i32, v168.f32[0]);
  v173 = (float64x2_t)v491;
  v492 = vaddq_f32(v491, vmulq_lane_f32(v165, *(float32x2_t *)a5.f32, 1));
  v165.f32[0] = *(float *)&v167 + *(float *)&v169;
  *(float *)v173.f64 = *(float *)&v171 + *(float *)v172.i32;
  v165.f32[1] = *(float *)&v171 + *(float *)v172.i32;
  *(double *)v175.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v165.i64, v173, v167, v169, v170, v172, v171, v174);
  HIDWORD(v176) = HIDWORD(v535.f64[0]);
  v177 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], -v526.f32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v178 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v177, 1), *(float *)(a1 + 16), v177.f32[0]);
  LODWORD(v176) = *(_DWORD *)(a1 + 24);
  v179.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v180) = *(_DWORD *)(a1 + 36);
  *(float *)v181.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v177, 1), *(float *)v179.i32, v177.f32[0]);
  v182 = (float64x2_t)v492;
  v493 = vaddq_f32(v492, vmulq_laneq_f32(v175, a5, 2));
  v175.f32[0] = *(float *)&v176 + *(float *)&v178;
  *(float *)v182.f64 = *(float *)&v180 + *(float *)v181.i32;
  v175.f32[1] = *(float *)&v180 + *(float *)v181.i32;
  *(double *)v184.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v175.i64, v182, v176, v178, v179, v181, v180, v183);
  HIDWORD(v185) = HIDWORD(v535.f64[0]);
  v186 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], -*(float *)&a21.i32[2]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v187 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v186, 1), *(float *)(a1 + 16), v186.f32[0]);
  LODWORD(v185) = *(_DWORD *)(a1 + 24);
  v188.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v189) = *(_DWORD *)(a1 + 36);
  *(float *)v190.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v186, 1), *(float *)v188.i32, v186.f32[0]);
  v191 = (float64x2_t)v493;
  v495 = vaddq_f32(v493, vmulq_laneq_f32(v184, a5, 3));
  v184.f32[0] = *(float *)&v185 + *(float *)&v187;
  *(float *)v191.f64 = *(float *)&v189 + *(float *)v190.i32;
  v184.f32[1] = *(float *)&v189 + *(float *)v190.i32;
  *(double *)v193.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v184.i64, v191, v185, v187, v188, v190, v189, v192);
  LODWORD(v194) = 0;
  *((float *)&v194 + 1) = -*(float *)&a21.i32[3];
  v195 = vadd_f32(*(float32x2_t *)&v194, *(float32x2_t *)&v535.f64[0]);
  *(float *)&v196 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v195, 1), *(float *)(a1 + 16), v195.f32[0]);
  LODWORD(v194) = *(_DWORD *)(a1 + 24);
  v197.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v198) = *(_DWORD *)(a1 + 36);
  *(float *)v199.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v195, 1), *(float *)v197.i32, v195.f32[0]);
  v200 = (float64x2_t)v495;
  v496 = vaddq_f32(v495, vmulq_n_f32(v193, a6.f32[0]));
  v193.f32[0] = *(float *)&v194 + *(float *)&v196;
  *(float *)v200.f64 = *(float *)&v198 + *(float *)v199.i32;
  v193.f32[1] = *(float *)&v198 + *(float *)v199.i32;
  *(double *)v202.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v193.i64, v200, v194, v196, v197, v199, v198, v201);
  HIDWORD(v203) = HIDWORD(v535.f64[0]);
  v204 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], v524.u32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v205 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v204, 1), *(float *)(a1 + 16), v204.f32[0]);
  LODWORD(v203) = *(_DWORD *)(a1 + 24);
  v206.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v207) = *(_DWORD *)(a1 + 36);
  *(float *)v208.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v204, 1), *(float *)v206.i32, v204.f32[0]);
  v209 = (float64x2_t)v496;
  v497 = vaddq_f32(v496, vmulq_lane_f32(v202, *(float32x2_t *)a6.f32, 1));
  v202.f32[0] = *(float *)&v203 + *(float *)&v205;
  *(float *)v209.f64 = *(float *)&v207 + *(float *)v208.i32;
  v202.f32[1] = *(float *)&v207 + *(float *)v208.i32;
  *(double *)v211.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v202.i64, v209, v203, v205, v206, v208, v207, v210);
  HIDWORD(v212) = HIDWORD(v535.f64[0]);
  v213 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], v526.u32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v214 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v213, 1), *(float *)(a1 + 16), v213.f32[0]);
  LODWORD(v212) = *(_DWORD *)(a1 + 24);
  v215.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v216) = *(_DWORD *)(a1 + 36);
  *(float *)v217.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v213, 1), *(float *)v215.i32, v213.f32[0]);
  v218 = (float64x2_t)v497;
  v498 = vaddq_f32(v497, vmulq_laneq_f32(v211, a6, 2));
  v211.f32[0] = *(float *)&v212 + *(float *)&v214;
  *(float *)v218.f64 = *(float *)&v216 + *(float *)v217.i32;
  v211.f32[1] = *(float *)&v216 + *(float *)v217.i32;
  *(double *)v220.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v211.i64, v218, v212, v214, v215, v217, v216, v219);
  HIDWORD(v221) = HIDWORD(v535.f64[0]);
  v222 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], LODWORD(v525)), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v223 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v222, 1), *(float *)(a1 + 16), v222.f32[0]);
  LODWORD(v221) = *(_DWORD *)(a1 + 24);
  v224.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v225) = *(_DWORD *)(a1 + 36);
  *(float *)v226.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v222, 1), *(float *)v224.i32, v222.f32[0]);
  v227 = (float64x2_t)v498;
  v503 = vaddq_f32(v498, vmulq_laneq_f32(v220, a6, 3));
  v220.f32[0] = *(float *)&v221 + *(float *)&v223;
  *(float *)v227.f64 = *(float *)&v225 + *(float *)v226.i32;
  v220.f32[1] = *(float *)&v225 + *(float *)v226.i32;
  *(double *)v229.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v220.i64, v227, v221, v223, v224, v226, v225, v228);
  HIDWORD(v230) = HIDWORD(v535.f64[0]);
  v231 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&v525), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v232 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v231, 1), *(float *)(a1 + 16), v231.f32[0]);
  LODWORD(v230) = *(_DWORD *)(a1 + 24);
  v233.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v234) = *(_DWORD *)(a1 + 36);
  *(float *)v235.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v231, 1), *(float *)v233.i32, v231.f32[0]);
  v236 = (float64x2_t)v503;
  v504 = vaddq_f32(v503, vmulq_n_f32(v229, a7.f32[0]));
  v229.f32[0] = *(float *)&v230 + *(float *)&v232;
  *(float *)v236.f64 = *(float *)&v234 + *(float *)v235.i32;
  v229.f32[1] = *(float *)&v234 + *(float *)v235.i32;
  *(double *)v238.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v229.i64, v236, v230, v232, v233, v235, v234, v237);
  HIDWORD(v239) = HIDWORD(v535.f64[0]);
  v240 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-v526.f32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v241 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v240, 1), *(float *)(a1 + 16), v240.f32[0]);
  LODWORD(v239) = *(_DWORD *)(a1 + 24);
  v242.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v243) = *(_DWORD *)(a1 + 36);
  *(float *)v244.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v240, 1), *(float *)v242.i32, v240.f32[0]);
  v245 = (float64x2_t)v504;
  v505 = vaddq_f32(v504, vmulq_lane_f32(v238, *(float32x2_t *)a7.f32, 1));
  v238.f32[0] = *(float *)&v239 + *(float *)&v241;
  *(float *)v245.f64 = *(float *)&v243 + *(float *)v244.i32;
  v238.f32[1] = *(float *)&v243 + *(float *)v244.i32;
  *(double *)v247.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v238.i64, v245, v239, v241, v242, v244, v243, v246);
  HIDWORD(v248) = HIDWORD(v535.f64[0]);
  v249 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&a21.i32[2]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v250 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v249, 1), *(float *)(a1 + 16), v249.f32[0]);
  LODWORD(v248) = *(_DWORD *)(a1 + 24);
  v251.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v252) = *(_DWORD *)(a1 + 36);
  *(float *)v253.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v249, 1), *(float *)v251.i32, v249.f32[0]);
  v254 = (float64x2_t)v505;
  v506 = vaddq_f32(v505, vmulq_laneq_f32(v247, a7, 2));
  v247.f32[0] = *(float *)&v248 + *(float *)&v250;
  *(float *)v254.f64 = *(float *)&v252 + *(float *)v253.i32;
  v247.f32[1] = *(float *)&v252 + *(float *)v253.i32;
  *(double *)v256.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v247.i64, v254, v248, v250, v251, v253, v252, v255);
  HIDWORD(v257) = HIDWORD(v535.f64[0]);
  v258 = vadd_f32((float32x2_t)v524.u32[0], *(float32x2_t *)&v535.f64[0]);
  *(float *)&v259 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v258, 1), *(float *)(a1 + 16), v258.f32[0]);
  LODWORD(v257) = *(_DWORD *)(a1 + 24);
  LODWORD(v260) = *(_DWORD *)(a1 + 36);
  *(float *)v261.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v258, 1), *(float *)(a1 + 28), v258.f32[0]);
  v262 = vmulq_n_f32(v478, *(float *)a8.i32);
  v507 = vaddq_f32(v262, vaddq_f32(v506, vmulq_laneq_f32(v256, a7, 3)));
  v256.f32[0] = *(float *)&v257 + *(float *)&v259;
  v262.f32[0] = *(float *)&v260 + *(float *)v261.i32;
  v256.f32[1] = *(float *)&v260 + *(float *)v261.i32;
  *(double *)v264.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v256.i64, (float64x2_t)v262, v257, v259, a8, v261, v260, v263);
  HIDWORD(v265) = HIDWORD(v535.f64[0]);
  v266 = vadd_f32((float32x2_t)v526.u32[0], *(float32x2_t *)&v535.f64[0]);
  *(float *)&v267 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v266, 1), *(float *)(a1 + 16), v266.f32[0]);
  LODWORD(v265) = *(_DWORD *)(a1 + 24);
  v268.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v269) = *(_DWORD *)(a1 + 36);
  *(float *)v270.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v266, 1), *(float *)v268.i32, v266.f32[0]);
  v271 = (float64x2_t)v507;
  v508 = vaddq_f32(v507, vmulq_lane_f32(v264, *(float32x2_t *)a8.i8, 1));
  v264.f32[0] = *(float *)&v265 + *(float *)&v267;
  *(float *)v271.f64 = *(float *)&v269 + *(float *)v270.i32;
  v264.f32[1] = *(float *)&v269 + *(float *)v270.i32;
  *(double *)v273.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v264.i64, v271, v265, v267, v268, v270, v269, v272);
  HIDWORD(v274) = HIDWORD(v535.f64[0]);
  v275 = vadd_f32((float32x2_t)LODWORD(v525), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v276 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v275, 1), *(float *)(a1 + 16), v275.f32[0]);
  LODWORD(v274) = *(_DWORD *)(a1 + 24);
  v277.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v278) = *(_DWORD *)(a1 + 36);
  *(float *)v279.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v275, 1), *(float *)v277.i32, v275.f32[0]);
  v280 = (float64x2_t)v508;
  v509 = vaddq_f32(v508, vmulq_laneq_f32(v273, (float32x4_t)a8, 2));
  v273.f32[0] = *(float *)&v274 + *(float *)&v276;
  *(float *)v280.f64 = *(float *)&v278 + *(float *)v279.i32;
  v273.f32[1] = *(float *)&v278 + *(float *)v279.i32;
  *(double *)v282.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v273.i64, v280, v274, v276, v277, v279, v278, v281);
  HIDWORD(v283) = HIDWORD(v535.f64[0]);
  v284 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], -*(float *)&v525), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v285 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v284, 1), *(float *)(a1 + 16), v284.f32[0]);
  LODWORD(v283) = *(_DWORD *)(a1 + 24);
  v286.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v287) = *(_DWORD *)(a1 + 36);
  *(float *)v288.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v284, 1), *(float *)v286.i32, v284.f32[0]);
  v289 = (float64x2_t)v509;
  v510 = vaddq_f32(v509, vmulq_laneq_f32(v282, (float32x4_t)a8, 3));
  v282.f32[0] = *(float *)&v283 + *(float *)&v285;
  *(float *)v289.f64 = *(float *)&v287 + *(float *)v288.i32;
  v282.f32[1] = *(float *)&v287 + *(float *)v288.i32;
  *(double *)v291.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v282.i64, v289, v283, v285, v286, v288, v287, v290);
  HIDWORD(v292) = HIDWORD(v535.f64[0]);
  v293 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], -v526.f32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v294 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v293, 1), *(float *)(a1 + 16), v293.f32[0]);
  LODWORD(v292) = *(_DWORD *)(a1 + 24);
  v295.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v296) = *(_DWORD *)(a1 + 36);
  *(float *)v297.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v293, 1), *(float *)v295.i32, v293.f32[0]);
  v298 = (float64x2_t)v510;
  v511 = vaddq_f32(v510, vmulq_n_f32(v291, a9.f32[0]));
  v291.f32[0] = *(float *)&v292 + *(float *)&v294;
  *(float *)v298.f64 = *(float *)&v296 + *(float *)v297.i32;
  v291.f32[1] = *(float *)&v296 + *(float *)v297.i32;
  *(double *)v300.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v291.i64, v298, v292, v294, v295, v297, v296, v299);
  HIDWORD(v301) = HIDWORD(v535.f64[0]);
  v302 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], -*(float *)&a21.i32[2]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v303 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v302, 1), *(float *)(a1 + 16), v302.f32[0]);
  LODWORD(v301) = *(_DWORD *)(a1 + 24);
  v304.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v305) = *(_DWORD *)(a1 + 36);
  *(float *)v306.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v302, 1), *(float *)v304.i32, v302.f32[0]);
  v307 = (float64x2_t)v511;
  v512 = vaddq_f32(v511, vmulq_lane_f32(v300, *(float32x2_t *)a9.f32, 1));
  v300.f32[0] = *(float *)&v301 + *(float *)&v303;
  *(float *)v307.f64 = *(float *)&v305 + *(float *)v306.i32;
  v300.f32[1] = *(float *)&v305 + *(float *)v306.i32;
  *(double *)v309.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v300.i64, v307, v301, v303, v304, v306, v305, v308);
  v310.i32[1] = v524.i32[1];
  v310.i32[0] = 0;
  HIDWORD(v311) = HIDWORD(v535.f64[0]);
  v312 = vadd_f32(v310, *(float32x2_t *)&v535.f64[0]);
  *(float *)&v313 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v312, 1), *(float *)(a1 + 16), v312.f32[0]);
  LODWORD(v311) = *(_DWORD *)(a1 + 24);
  v314.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v315) = *(_DWORD *)(a1 + 36);
  *(float *)v316.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v312, 1), *(float *)v314.i32, v312.f32[0]);
  v317 = (float64x2_t)v512;
  v513 = vaddq_f32(v512, vmulq_laneq_f32(v309, a9, 2));
  v309.f32[0] = *(float *)&v311 + *(float *)&v313;
  *(float *)v317.f64 = *(float *)&v315 + *(float *)v316.i32;
  v309.f32[1] = *(float *)&v315 + *(float *)v316.i32;
  *(double *)v319.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v309.i64, v317, v311, v313, v314, v316, v315, v318);
  HIDWORD(v320) = HIDWORD(v535.f64[0]);
  v321 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], v524.u32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v322 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v321, 1), *(float *)(a1 + 16), v321.f32[0]);
  LODWORD(v320) = *(_DWORD *)(a1 + 24);
  v323.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v324) = *(_DWORD *)(a1 + 36);
  *(float *)v325.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v321, 1), *(float *)v323.i32, v321.f32[0]);
  v326 = (float64x2_t)v513;
  v514 = vaddq_f32(v513, vmulq_laneq_f32(v319, a9, 3));
  v319.f32[0] = *(float *)&v320 + *(float *)&v322;
  *(float *)v326.f64 = *(float *)&v324 + *(float *)v325.i32;
  v319.f32[1] = *(float *)&v324 + *(float *)v325.i32;
  *(double *)v328.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v319.i64, v326, v320, v322, v323, v325, v324, v327);
  HIDWORD(v329) = HIDWORD(v535.f64[0]);
  v330 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], v526.u32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v331 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v330, 1), *(float *)(a1 + 16), v330.f32[0]);
  LODWORD(v329) = *(_DWORD *)(a1 + 24);
  v332.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v333) = *(_DWORD *)(a1 + 36);
  *(float *)v334.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v330, 1), *(float *)v332.i32, v330.f32[0]);
  v335 = (float64x2_t)v514;
  v515 = vaddq_f32(v514, vmulq_n_f32(v328, a17.f32[0]));
  v328.f32[0] = *(float *)&v329 + *(float *)&v331;
  *(float *)v335.f64 = *(float *)&v333 + *(float *)v334.i32;
  v328.f32[1] = *(float *)&v333 + *(float *)v334.i32;
  *(double *)v337.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v328.i64, v335, v329, v331, v332, v334, v333, v336);
  HIDWORD(v338) = HIDWORD(v535.f64[0]);
  v339 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], LODWORD(v525)), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v340 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v339, 1), *(float *)(a1 + 16), v339.f32[0]);
  LODWORD(v338) = *(_DWORD *)(a1 + 24);
  v341.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v342) = *(_DWORD *)(a1 + 36);
  *(float *)v343.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v339, 1), *(float *)v341.i32, v339.f32[0]);
  v344 = (float64x2_t)v515;
  v516 = vaddq_f32(v515, vmulq_lane_f32(v337, *(float32x2_t *)a17.f32, 1));
  v337.f32[0] = *(float *)&v338 + *(float *)&v340;
  *(float *)v344.f64 = *(float *)&v342 + *(float *)v343.i32;
  v337.f32[1] = *(float *)&v342 + *(float *)v343.i32;
  *(double *)v346.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v337.i64, v344, v338, v340, v341, v343, v342, v345);
  HIDWORD(v347) = HIDWORD(v535.f64[0]);
  v348 = vadd_f32((float32x2_t)__PAIR64__(v526.u32[1], -*(float *)&v525), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v349 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v348, 1), *(float *)(a1 + 16), v348.f32[0]);
  LODWORD(v347) = *(_DWORD *)(a1 + 24);
  v350.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v351) = *(_DWORD *)(a1 + 36);
  *(float *)v352.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v348, 1), *(float *)v350.i32, v348.f32[0]);
  v353 = (float64x2_t)v516;
  v517 = vaddq_f32(v516, vmulq_laneq_f32(v346, a17, 2));
  v346.f32[0] = *(float *)&v347 + *(float *)&v349;
  *(float *)v353.f64 = *(float *)&v351 + *(float *)v352.i32;
  v346.f32[1] = *(float *)&v351 + *(float *)v352.i32;
  *(double *)v355.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v346.i64, v353, v347, v349, v350, v352, v351, v354);
  HIDWORD(v356) = HIDWORD(v535.f64[0]);
  v357 = vadd_f32((float32x2_t)__PAIR64__(v526.u32[1], -v526.f32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v358 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v357, 1), *(float *)(a1 + 16), v357.f32[0]);
  LODWORD(v356) = *(_DWORD *)(a1 + 24);
  v359.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v360) = *(_DWORD *)(a1 + 36);
  *(float *)v361.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v357, 1), *(float *)v359.i32, v357.f32[0]);
  v362 = (float64x2_t)v517;
  v518 = vaddq_f32(v517, vmulq_laneq_f32(v355, a17, 3));
  v355.f32[0] = *(float *)&v356 + *(float *)&v358;
  *(float *)v362.f64 = *(float *)&v360 + *(float *)v361.i32;
  v355.f32[1] = *(float *)&v360 + *(float *)v361.i32;
  *(double *)v364.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v355.i64, v362, v356, v358, v359, v361, v360, v363);
  HIDWORD(v365) = HIDWORD(v535.f64[0]);
  v366 = vadd_f32((float32x2_t)__PAIR64__(v526.u32[1], -*(float *)&a21.i32[2]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v367 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v366, 1), *(float *)(a1 + 16), v366.f32[0]);
  LODWORD(v365) = *(_DWORD *)(a1 + 24);
  v368.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v369) = *(_DWORD *)(a1 + 36);
  *(float *)v370.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v366, 1), *(float *)v368.i32, v366.f32[0]);
  v371 = (float64x2_t)v518;
  v519 = vaddq_f32(v518, vmulq_n_f32(v364, a18.f32[0]));
  v364.f32[0] = *(float *)&v365 + *(float *)&v367;
  *(float *)v371.f64 = *(float *)&v369 + *(float *)v370.i32;
  v364.f32[1] = *(float *)&v369 + *(float *)v370.i32;
  *(double *)v373.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v364.i64, v371, v365, v367, v368, v370, v369, v372);
  v374.i32[1] = v526.i32[1];
  HIDWORD(v375) = HIDWORD(v535.f64[0]);
  v374.i32[0] = 0;
  v376 = vadd_f32(v374, *(float32x2_t *)&v535.f64[0]);
  *(float *)&v377 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v376, 1), *(float *)(a1 + 16), v376.f32[0]);
  LODWORD(v375) = *(_DWORD *)(a1 + 24);
  v378.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v379) = *(_DWORD *)(a1 + 36);
  *(float *)v380.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v376, 1), *(float *)v378.i32, v376.f32[0]);
  v381 = (float64x2_t)v519;
  v520 = vaddq_f32(v519, vmulq_lane_f32(v373, *(float32x2_t *)a18.f32, 1));
  v373.f32[0] = *(float *)&v375 + *(float *)&v377;
  *(float *)v381.f64 = *(float *)&v379 + *(float *)v380.i32;
  v373.f32[1] = *(float *)&v379 + *(float *)v380.i32;
  *(double *)v383.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v373.i64, v381, v375, v377, v378, v380, v379, v382);
  HIDWORD(v384) = HIDWORD(v535.f64[0]);
  v385 = vadd_f32((float32x2_t)__PAIR64__(v526.u32[1], v524.u32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v386 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v385, 1), *(float *)(a1 + 16), v385.f32[0]);
  LODWORD(v384) = *(_DWORD *)(a1 + 24);
  v387.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v388) = *(_DWORD *)(a1 + 36);
  *(float *)v389.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v385, 1), *(float *)v387.i32, v385.f32[0]);
  v390 = (float64x2_t)v520;
  v521 = vaddq_f32(v520, vmulq_laneq_f32(v383, a18, 2));
  v383.f32[0] = *(float *)&v384 + *(float *)&v386;
  *(float *)v390.f64 = *(float *)&v388 + *(float *)v389.i32;
  v383.f32[1] = *(float *)&v388 + *(float *)v389.i32;
  *(double *)v392.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v383.i64, v390, v384, v386, v387, v389, v388, v391);
  HIDWORD(v393) = v526.i32[1];
  v394 = vadd_f32(v526, *(float32x2_t *)&v535.f64[0]);
  *(float *)&v395 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v394, 1), *(float *)(a1 + 16), v394.f32[0]);
  LODWORD(v393) = *(_DWORD *)(a1 + 24);
  v396.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v397) = *(_DWORD *)(a1 + 36);
  *(float *)v398.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v394, 1), *(float *)v396.i32, v394.f32[0]);
  v399 = (float64x2_t)v521;
  v527 = vaddq_f32(v521, vmulq_laneq_f32(v392, a18, 3));
  v392.f32[0] = *(float *)&v393 + *(float *)&v395;
  *(float *)v399.f64 = *(float *)&v397 + *(float *)v398.i32;
  v392.f32[1] = *(float *)&v397 + *(float *)v398.i32;
  *(double *)v401.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v392.i64, v399, v393, v395, v396, v398, v397, v400);
  HIDWORD(v402) = HIDWORD(v535.f64[0]);
  v403 = vadd_f32(vmul_f32(v524, (float32x2_t)0x4000000040400000), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v404 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v403, 1), *(float *)(a1 + 16), v403.f32[0]);
  LODWORD(v402) = *(_DWORD *)(a1 + 24);
  v405.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v406) = *(_DWORD *)(a1 + 36);
  *(float *)v407.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v403, 1), *(float *)v405.i32, v403.f32[0]);
  v408 = (float64x2_t)v527;
  v528 = vaddq_f32(v527, vmulq_n_f32(v401, a19.f32[0]));
  v401.f32[0] = *(float *)&v402 + *(float *)&v404;
  *(float *)v408.f64 = *(float *)&v406 + *(float *)v407.i32;
  v401.f32[1] = *(float *)&v406 + *(float *)v407.i32;
  *(double *)v410.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v401.i64, v408, v402, v404, v405, v407, v406, v409);
  HIDWORD(v411) = HIDWORD(v535.f64[0]);
  v412 = vadd_f32((float32x2_t)__PAIR64__(HIDWORD(v525), -*(float *)&v525), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v413 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v412, 1), *(float *)(a1 + 16), v412.f32[0]);
  LODWORD(v411) = *(_DWORD *)(a1 + 24);
  v414.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v415) = *(_DWORD *)(a1 + 36);
  *(float *)v416.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v412, 1), *(float *)v414.i32, v412.f32[0]);
  v417 = (float64x2_t)v528;
  v529 = vaddq_f32(v528, vmulq_lane_f32(v410, *(float32x2_t *)a19.f32, 1));
  v410.f32[0] = *(float *)&v411 + *(float *)&v413;
  *(float *)v417.f64 = *(float *)&v415 + *(float *)v416.i32;
  v410.f32[1] = *(float *)&v415 + *(float *)v416.i32;
  *(double *)v419.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v410.i64, v417, v411, v413, v414, v416, v415, v418);
  HIDWORD(v420) = HIDWORD(v535.f64[0]);
  v421 = vadd_f32((float32x2_t)__PAIR64__(HIDWORD(v525), v523), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v422 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v421, 1), *(float *)(a1 + 16), v421.f32[0]);
  LODWORD(v420) = *(_DWORD *)(a1 + 24);
  v423.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v424) = *(_DWORD *)(a1 + 36);
  *(float *)v425.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v421, 1), *(float *)v423.i32, v421.f32[0]);
  v426 = (float64x2_t)v529;
  v530 = vaddq_f32(v529, vmulq_laneq_f32(v419, a19, 2));
  v419.f32[0] = *(float *)&v420 + *(float *)&v422;
  *(float *)v426.f64 = *(float *)&v424 + *(float *)v425.i32;
  v419.f32[1] = *(float *)&v424 + *(float *)v425.i32;
  *(double *)v428.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v419.i64, v426, v420, v422, v423, v425, v424, v427);
  HIDWORD(v429) = HIDWORD(v535.f64[0]);
  v430 = vadd_f32((float32x2_t)__PAIR64__(HIDWORD(v525), -*(float *)&a21.i32[2]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v431 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v430, 1), *(float *)(a1 + 16), v430.f32[0]);
  LODWORD(v429) = *(_DWORD *)(a1 + 24);
  v432.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v433) = *(_DWORD *)(a1 + 36);
  *(float *)v434.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v430, 1), *(float *)v432.i32, v430.f32[0]);
  v435 = (float64x2_t)v530;
  v531 = vaddq_f32(v530, vmulq_laneq_f32(v428, a19, 3));
  v428.f32[0] = *(float *)&v429 + *(float *)&v431;
  *(float *)v435.f64 = *(float *)&v433 + *(float *)v434.i32;
  v428.f32[1] = *(float *)&v433 + *(float *)v434.i32;
  *(double *)v437.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v428.i64, v435, v429, v431, v432, v434, v433, v436);
  v438.i32[1] = HIDWORD(v525);
  v438.i32[0] = 0;
  HIDWORD(v439) = HIDWORD(v535.f64[0]);
  v440 = vadd_f32(v438, *(float32x2_t *)&v535.f64[0]);
  *(float *)&v441 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v440, 1), *(float *)(a1 + 16), v440.f32[0]);
  LODWORD(v439) = *(_DWORD *)(a1 + 24);
  v442.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v443) = *(_DWORD *)(a1 + 36);
  *(float *)v444.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v440, 1), *(float *)v442.i32, v440.f32[0]);
  v445 = (float64x2_t)v531;
  v532 = vaddq_f32(v531, vmulq_n_f32(v437, a20.f32[0]));
  v437.f32[0] = *(float *)&v439 + *(float *)&v441;
  *(float *)v445.f64 = *(float *)&v443 + *(float *)v444.i32;
  v437.f32[1] = *(float *)&v443 + *(float *)v444.i32;
  *(double *)v447.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v437.i64, v445, v439, v441, v442, v444, v443, v446);
  HIDWORD(v448) = HIDWORD(v535.f64[0]);
  v449 = vadd_f32((float32x2_t)__PAIR64__(HIDWORD(v525), v524.u32[0]), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v450 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v449, 1), *(float *)(a1 + 16), v449.f32[0]);
  LODWORD(v448) = *(_DWORD *)(a1 + 24);
  v451.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v452) = *(_DWORD *)(a1 + 36);
  *(float *)v453.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v449, 1), *(float *)v451.i32, v449.f32[0]);
  v454 = (float64x2_t)v532;
  v533 = vaddq_f32(v532, vmulq_lane_f32(v447, *(float32x2_t *)a20.f32, 1));
  v447.f32[0] = *(float *)&v448 + *(float *)&v450;
  *(float *)v454.f64 = *(float *)&v452 + *(float *)v453.i32;
  v447.f32[1] = *(float *)&v452 + *(float *)v453.i32;
  *(double *)v456.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v447.i64, v454, v448, v450, v451, v453, v452, v455);
  HIDWORD(v457) = HIDWORD(v535.f64[0]);
  v458 = vadd_f32(vmul_f32(v524, (float32x2_t)0x4040000040000000), *(float32x2_t *)&v535.f64[0]);
  *(float *)&v459 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v458, 1), *(float *)(a1 + 16), v458.f32[0]);
  LODWORD(v457) = *(_DWORD *)(a1 + 24);
  v460.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v461) = *(_DWORD *)(a1 + 36);
  *(float *)v462.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v458, 1), *(float *)v460.i32, v458.f32[0]);
  v463 = (float64x2_t)v533;
  v534 = vaddq_f32(v533, vmulq_laneq_f32(v456, a20, 2));
  v456.f32[0] = *(float *)&v457 + *(float *)&v459;
  *(float *)v463.f64 = *(float *)&v461 + *(float *)v462.i32;
  v456.f32[1] = *(float *)&v461 + *(float *)v462.i32;
  *(double *)v465.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v456.i64, v463, v457, v459, v460, v462, v461, v464);
  HIDWORD(v466) = HIDWORD(v525);
  v467 = vadd_f32(*(float32x2_t *)&v525, *(float32x2_t *)&v535.f64[0]);
  *(float *)&v468 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v467, 1), *(float *)(a1 + 16), v467.f32[0]);
  LODWORD(v466) = *(_DWORD *)(a1 + 24);
  v469.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v470) = *(_DWORD *)(a1 + 36);
  *(float *)v471.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v467, 1), *(float *)v469.i32, v467.f32[0]);
  v472 = (float64x2_t)v534;
  v536 = vaddq_f32(v534, vmulq_laneq_f32(v465, a20, 3));
  v465.f32[0] = *(float *)&v466 + *(float *)&v468;
  *(float *)v472.f64 = *(float *)&v470 + *(float *)v471.i32;
  v465.f32[1] = *(float *)&v470 + *(float *)v471.i32;
  *(double *)result.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v465.i64, v472, v466, v468, v469, v471, v470, v473);
  result.i64[0] = vaddq_f32(v536, vmulq_n_f32(result, *(float *)a21.i32)).u64[0];
  result.i32[3] = v478.i32[3];
  return result;
}

void CI::f4_sr_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double, double, double, double, double);
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  const vec2 *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  double *v37;
  double *v38;
  double *v39;
  double *v40;
  double *v41;
  double *v42;
  double *v43;
  __n128 *v44;
  __n128 *v45;
  __n128 *v46;
  __n128 *v47;
  __n128 *v48;
  __n128 *v49;
  __n128 *v50;
  __n128 *v51;
  __n128 *v52;
  __n128 *v53;
  __n128 *v54;
  __n128 *v55;
  __int128 v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  double (*v71)(uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double, double, double, double, double);
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double, double, double, double, double))(a1 + 24);
  v11 = *(_QWORD *)(v9 + 8);
  v12 = *(_DWORD *)(v9 + 40);
  v13 = *(_QWORD *)(v9 + 32);
  v14 = *(_DWORD *)(v9 + 64);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = (const vec2 *)*(unsigned int *)(v9 + 88);
  v17 = *(_QWORD *)(v9 + 80);
  v18 = *(_DWORD *)(v9 + 112);
  v19 = *(_QWORD *)(v9 + 104);
  v20 = *(_DWORD *)(v9 + 136);
  v21 = *(_QWORD *)(v9 + 128);
  v22 = *(_DWORD *)(v9 + 160);
  v23 = *(_QWORD *)(v9 + 152);
  v24 = *(_QWORD *)(v9 + 176);
  v75 = *(_DWORD *)(v9 + 208);
  v76 = *(_DWORD *)(v9 + 184);
  v25 = *(_QWORD *)(v9 + 200);
  v26 = *(_QWORD *)(v9 + 224);
  v73 = *(_DWORD *)(v9 + 256);
  v74 = *(_DWORD *)(v9 + 232);
  v27 = *(_QWORD *)(v9 + 248);
  v72 = *(_DWORD *)(v9 + 280);
  v28 = *(_QWORD *)(v9 + 272);
  v29 = *(_DWORD *)(v9 + 304);
  v30 = *(_QWORD *)(v9 + 296);
  v31 = *(_DWORD *)(v9 + 328);
  v32 = *(_QWORD *)(v9 + 320);
  if (*(_BYTE *)(a1 + 64))
  {
    v71 = *(double (**)(uint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double, double, double, double, double))(a1 + 24);
    v68 = *(_QWORD *)(v9 + 56);
    v69 = *(_QWORD *)(v9 + 8);
    v33 = a4;
    v66 = *(_DWORD *)(v9 + 112);
    v34 = *(_DWORD *)(v9 + 40);
    v70 = *(_QWORD *)(v9 + 32);
    v64 = *(_QWORD *)(v9 + 128);
    v65 = *(_QWORD *)(v9 + 104);
    v35 = *(_DWORD *)(v9 + 64);
    v67 = *(_QWORD *)(v9 + 80);
    v36 = *(_DWORD *)(v9 + 88);
    v62 = *(_QWORD *)(v9 + 176);
    v63 = *(_QWORD *)(v9 + 152);
    v60 = *(_QWORD *)(v9 + 224);
    v61 = *(_QWORD *)(v9 + 200);
    v59 = *(_QWORD *)(v9 + 248);
    v57 = *(_DWORD *)(v9 + 328);
    v58 = *(_DWORD *)(v9 + 304);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 344)), v16);
    v31 = v57;
    v29 = v58;
    v27 = v59;
    v26 = v60;
    v25 = v61;
    v24 = v62;
    v23 = v63;
    LODWORD(v16) = v36;
    v17 = v67;
    v14 = v35;
    v21 = v64;
    v19 = v65;
    v11 = v69;
    v13 = v70;
    v12 = v34;
    v18 = v66;
    a4 = v33;
    v15 = v68;
    v10 = v71;
  }
  v37 = (double *)(a3 + 16 * v32);
  if (v31 != 5)
    v37 = (double *)(a2 + (v32 << 6));
  v38 = (double *)(a3 + 16 * v30);
  if (v29 != 5)
    v38 = (double *)(a2 + (v30 << 6));
  v39 = (double *)(a3 + 16 * v28);
  if (v72 != 5)
    v39 = (double *)(a2 + (v28 << 6));
  v40 = (double *)(a3 + 16 * v27);
  v41 = (double *)(a2 + (v27 << 6));
  if (v73 != 5)
    v40 = v41;
  v42 = (double *)(a3 + 16 * v26);
  v43 = (double *)(a2 + (v26 << 6));
  if (v74 != 5)
    v42 = v43;
  v44 = (__n128 *)(a3 + 16 * v25);
  v45 = (__n128 *)(a2 + (v25 << 6));
  if (v75 != 5)
    v44 = v45;
  v46 = (__n128 *)(a3 + 16 * v24);
  v47 = (__n128 *)(a2 + (v24 << 6));
  if (v76 != 5)
    v46 = v47;
  v48 = (__n128 *)(a3 + 16 * v23);
  v49 = (__n128 *)(a2 + (v23 << 6));
  if (v22 != 5)
    v48 = v49;
  v50 = (__n128 *)(a3 + 16 * v21);
  v51 = (__n128 *)(a2 + (v21 << 6));
  if (v20 != 5)
    v50 = v51;
  v52 = (__n128 *)(a3 + 16 * v19);
  if (v18 != 5)
    v52 = (__n128 *)(a2 + (v19 << 6));
  v53 = (__n128 *)(a3 + 16 * v17);
  if ((_DWORD)v16 != 5)
    v53 = (__n128 *)(a2 + (v17 << 6));
  v54 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v54 = (__n128 *)(a2 + (v15 << 6));
  v55 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v55 = (__n128 *)(a2 + (v13 << 6));
  *(double *)&v56 = v10(a4 + 80 * v11, *v55, *v54, *v53, *v52, *v50, *v48, *v46, *v44, *v42, v42[1], *v40, v40[1], *v39, v39[1], *v38, v38[1], *v37, v37[1]);
  *(_OWORD *)(a3 + 16 * a7) = v56;
}

double cikernel::_convolution7x7(uint64_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, float32x4_t a8, float32x4_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float32x4_t a17, float32x4_t a18, float32x4_t a19, float32x4_t a20,int8x16_t a21)
{
  int8x16_t v22;
  float64x2_t v23;
  float32x2_t v29;
  int8x16_t v30;
  float32x2_t v31;
  double v32;
  uint8x8_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x2_t v36;
  double v37;
  float32x2_t v38;
  double v39;
  int8x16_t v40;
  double v41;
  uint8x8_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  float32x2_t v46;
  double v47;
  float32x2_t v48;
  double v49;
  int8x16_t v50;
  double v51;
  uint8x8_t v52;
  float64x2_t v53;
  int8x16_t v54;
  float32x4_t v55;
  float32x2_t v56;
  double v57;
  float32x2_t v58;
  double v59;
  int8x16_t v60;
  double v61;
  uint8x8_t v62;
  float64x2_t v63;
  int8x16_t v64;
  float32x4_t v65;
  double v66;
  float32x2_t v67;
  double v68;
  int8x16_t v69;
  double v70;
  uint8x8_t v71;
  float64x2_t v72;
  int8x16_t v73;
  float32x4_t v74;
  double v75;
  float32x2_t v76;
  double v77;
  int8x16_t v78;
  double v79;
  uint8x8_t v80;
  float64x2_t v81;
  int8x16_t v82;
  float32x4_t v83;
  double v84;
  float32x2_t v85;
  double v86;
  int8x16_t v87;
  double v88;
  uint8x8_t v89;
  float64x2_t v90;
  int8x16_t v91;
  float32x4_t v92;
  float32x2_t v93;
  double v94;
  float32x2_t v95;
  double v96;
  int8x16_t v97;
  double v98;
  uint8x8_t v99;
  float64x2_t v100;
  int8x16_t v101;
  float32x4_t v102;
  double v103;
  float32x2_t v104;
  double v105;
  int8x16_t v106;
  double v107;
  uint8x8_t v108;
  float64x2_t v109;
  int8x16_t v110;
  float32x4_t v111;
  double v112;
  float32x2_t v113;
  double v114;
  int8x16_t v115;
  double v116;
  uint8x8_t v117;
  float64x2_t v118;
  int8x16_t v119;
  float32x4_t v120;
  float32x2_t v121;
  double v122;
  float32x2_t v123;
  double v124;
  int8x16_t v125;
  double v126;
  uint8x8_t v127;
  float64x2_t v128;
  int8x16_t v129;
  float32x4_t v130;
  double v131;
  float32x2_t v132;
  double v133;
  int8x16_t v134;
  double v135;
  uint8x8_t v136;
  float64x2_t v137;
  int8x16_t v138;
  float32x4_t v139;
  double v140;
  float32x2_t v141;
  double v142;
  int8x16_t v143;
  double v144;
  uint8x8_t v145;
  float64x2_t v146;
  int8x16_t v147;
  float32x4_t v148;
  double v149;
  float32x2_t v150;
  double v151;
  int8x16_t v152;
  double v153;
  uint8x8_t v154;
  float64x2_t v155;
  int8x16_t v156;
  float32x4_t v157;
  float32x2_t v158;
  double v159;
  float32x2_t v160;
  double v161;
  int8x16_t v162;
  double v163;
  uint8x8_t v164;
  float64x2_t v165;
  int8x16_t v166;
  float32x4_t v167;
  double v168;
  float32x2_t v169;
  double v170;
  int8x16_t v171;
  double v172;
  uint8x8_t v173;
  float64x2_t v174;
  int8x16_t v175;
  float32x4_t v176;
  double v177;
  float32x2_t v178;
  double v179;
  int8x16_t v180;
  double v181;
  uint8x8_t v182;
  float64x2_t v183;
  int8x16_t v184;
  float32x4_t v185;
  double v186;
  float32x2_t v187;
  double v188;
  int8x16_t v189;
  double v190;
  uint8x8_t v191;
  float64x2_t v192;
  int8x16_t v193;
  float32x4_t v194;
  double v195;
  float32x2_t v196;
  double v197;
  int8x16_t v198;
  double v199;
  uint8x8_t v200;
  float64x2_t v201;
  int8x16_t v202;
  float32x4_t v203;
  double v204;
  float32x2_t v205;
  double v206;
  int8x16_t v207;
  double v208;
  uint8x8_t v209;
  float64x2_t v210;
  int8x16_t v211;
  float32x4_t v212;
  double v213;
  float32x2_t v214;
  double v215;
  int8x16_t v216;
  double v217;
  uint8x8_t v218;
  float64x2_t v219;
  int8x16_t v220;
  float32x4_t v221;
  double v222;
  float32x2_t v223;
  double v224;
  int8x16_t v225;
  double v226;
  uint8x8_t v227;
  float64x2_t v228;
  int8x16_t v229;
  float32x4_t v230;
  double v231;
  float32x2_t v232;
  double v233;
  int8x16_t v234;
  double v235;
  uint8x8_t v236;
  float64x2_t v237;
  int8x16_t v238;
  float32x4_t v239;
  double v240;
  float32x2_t v241;
  double v242;
  int8x16_t v243;
  double v244;
  uint8x8_t v245;
  float64x2_t v246;
  int8x16_t v247;
  float32x4_t v248;
  float64x2_t v249;
  double v250;
  double v251;
  uint8x8_t v252;
  double v253;
  int8x16_t v254;
  float32x4_t v255;
  double v256;
  float32x2_t v257;
  double v258;
  int8x16_t v259;
  double v260;
  uint8x8_t v261;
  float64x2_t v262;
  int8x16_t v263;
  float32x4_t v264;
  double v265;
  float32x2_t v266;
  double v267;
  int8x16_t v268;
  double v269;
  uint8x8_t v270;
  float64x2_t v271;
  int8x16_t v272;
  float32x4_t v273;
  double v274;
  float32x2_t v275;
  double v276;
  int8x16_t v277;
  double v278;
  uint8x8_t v279;
  float64x2_t v280;
  int8x16_t v281;
  float32x4_t v282;
  double v283;
  float32x2_t v284;
  double v285;
  int8x16_t v286;
  double v287;
  uint8x8_t v288;
  float64x2_t v289;
  int8x16_t v290;
  float32x4_t v291;
  double v292;
  float32x2_t v293;
  double v294;
  int8x16_t v295;
  double v296;
  uint8x8_t v297;
  float64x2_t v298;
  int8x16_t v299;
  float32x4_t v300;
  double v301;
  float32x2_t v302;
  double v303;
  int8x16_t v304;
  double v305;
  uint8x8_t v306;
  float64x2_t v307;
  int8x16_t v308;
  float32x4_t v309;
  float32x2_t v310;
  double v311;
  float32x2_t v312;
  double v313;
  int8x16_t v314;
  double v315;
  uint8x8_t v316;
  float64x2_t v317;
  int8x16_t v318;
  float32x4_t v319;
  double v320;
  float32x2_t v321;
  double v322;
  int8x16_t v323;
  double v324;
  uint8x8_t v325;
  float64x2_t v326;
  int8x16_t v327;
  float32x4_t v328;
  double v329;
  float32x2_t v330;
  double v331;
  int8x16_t v332;
  double v333;
  uint8x8_t v334;
  float64x2_t v335;
  int8x16_t v336;
  float32x4_t v337;
  double v338;
  float32x2_t v339;
  double v340;
  int8x16_t v341;
  double v342;
  uint8x8_t v343;
  float64x2_t v344;
  int8x16_t v345;
  float32x4_t v346;
  double v347;
  float32x2_t v348;
  double v349;
  int8x16_t v350;
  double v351;
  uint8x8_t v352;
  float64x2_t v353;
  int8x16_t v354;
  float32x4_t v355;
  double v356;
  float32x2_t v357;
  double v358;
  int8x16_t v359;
  double v360;
  uint8x8_t v361;
  float64x2_t v362;
  int8x16_t v363;
  float32x4_t v364;
  double v365;
  float32x2_t v366;
  double v367;
  int8x16_t v368;
  double v369;
  uint8x8_t v370;
  float64x2_t v371;
  int8x16_t v372;
  float32x4_t v373;
  float32x2_t v374;
  double v375;
  float32x2_t v376;
  double v377;
  int8x16_t v378;
  double v379;
  uint8x8_t v380;
  float64x2_t v381;
  int8x16_t v382;
  float32x4_t v383;
  double v384;
  float32x2_t v385;
  double v386;
  int8x16_t v387;
  double v388;
  uint8x8_t v389;
  float64x2_t v390;
  int8x16_t v391;
  float32x4_t v392;
  double v393;
  float32x2_t v394;
  double v395;
  int8x16_t v396;
  double v397;
  uint8x8_t v398;
  float64x2_t v399;
  int8x16_t v400;
  float32x4_t v401;
  double v402;
  float32x2_t v403;
  double v404;
  int8x16_t v405;
  double v406;
  uint8x8_t v407;
  float64x2_t v408;
  int8x16_t v409;
  float32x4_t v410;
  double v411;
  float32x2_t v412;
  double v413;
  int8x16_t v414;
  double v415;
  uint8x8_t v416;
  float64x2_t v417;
  int8x16_t v418;
  float32x4_t v419;
  double v420;
  float32x2_t v421;
  double v422;
  int8x16_t v423;
  double v424;
  uint8x8_t v425;
  float64x2_t v426;
  int8x16_t v427;
  float32x4_t v428;
  double v429;
  float32x2_t v430;
  double v431;
  int8x16_t v432;
  double v433;
  uint8x8_t v434;
  float64x2_t v435;
  int8x16_t v436;
  float32x4_t v437;
  float32x2_t v438;
  double v439;
  float32x2_t v440;
  double v441;
  int8x16_t v442;
  double v443;
  uint8x8_t v444;
  float64x2_t v445;
  int8x16_t v446;
  float32x4_t v447;
  double v448;
  float32x2_t v449;
  double v450;
  int8x16_t v451;
  double v452;
  uint8x8_t v453;
  float64x2_t v454;
  int8x16_t v455;
  float32x4_t v456;
  double v457;
  float32x2_t v458;
  double v459;
  int8x16_t v460;
  double v461;
  uint8x8_t v462;
  float64x2_t v463;
  int8x16_t v464;
  float32x4_t v465;
  double v466;
  float32x2_t v467;
  double v468;
  int8x16_t v469;
  double v470;
  uint8x8_t v471;
  float64x2_t v472;
  int8x16_t v473;
  float32x4_t v474;
  double result;
  float32x4_t v476;
  float32x4_t v477;
  float32x4_t v478;
  float32x4_t v480;
  float32x4_t v481;
  float32x4_t v482;
  float32x4_t v483;
  float32x4_t v485;
  float32x4_t v486;
  float32x4_t v487;
  float32x4_t v488;
  float32x4_t v490;
  float32x4_t v491;
  float32x4_t v492;
  float32x4_t v493;
  float32x4_t v495;
  float32x4_t v496;
  float32x4_t v497;
  float32x4_t v498;
  float32_t v503;
  float32x4_t v504;
  float32x4_t v505;
  float32x4_t v506;
  float32x4_t v507;
  float32x4_t v508;
  float32x4_t v509;
  float32x4_t v510;
  float32x4_t v511;
  float32x4_t v512;
  float32x4_t v513;
  float32x4_t v514;
  float32x4_t v515;
  float32x4_t v516;
  float32x4_t v517;
  float32x4_t v518;
  float32x4_t v519;
  float32x4_t v520;
  float32x4_t v521;
  float32x4_t v522;
  float32x4_t v523;
  unsigned int v524;
  float32_t v525;
  float32x2_t v526;
  float32x2_t v527;
  float32x2_t v528;
  float32x4_t v529;
  float32x4_t v530;
  float32x4_t v531;
  float32x4_t v532;
  float32x4_t v533;
  float32x4_t v534;
  float32x4_t v535;
  float32x4_t v536;
  int8x16_t v537;
  float32x4_t v538;

  v22.i64[0] = *(_QWORD *)CI::getDC((CI *)a1);
  v537 = v22;
  v23 = (float64x2_t)vextq_s8(a21, a21, 8uLL);
  __asm { FMOV            V0.2S, #3.0 }
  v29 = vmul_f32(*(float32x2_t *)&v23.f64[0], _D0);
  v30 = (int8x16_t)v23;
  v526 = *(float32x2_t *)&v23.f64[0];
  v527 = v29;
  v29.f32[0] = -v29.f32[0];
  v525 = v29.f32[0];
  v29.f32[1] = -v29.f32[1];
  v503 = v29.f32[1];
  v31 = vadd_f32(v29, *(float32x2_t *)v22.i8);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v31, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 28);
  v33.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v31, 1), *(float *)&v32, v31.f32[0]);
  v528 = vadd_f32(*(float32x2_t *)v30.i8, *(float32x2_t *)v30.i8);
  v31.f32[0] = *(float *)(a1 + 24) + *(float *)v22.i32;
  *(float *)v23.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v31.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v31, v23, *(double *)v22.i64, v32, v34, v33, *(double *)a21.i64, v30);
  v36.f32[0] = -v528.f32[0];
  *(float *)&v524 = -v528.f32[0];
  v36.f32[1] = v503;
  HIDWORD(v37) = v537.i32[1];
  v38 = vadd_f32(v36, *(float32x2_t *)v537.i8);
  *(float *)&v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v38, 1), *(float *)(a1 + 16), v38.f32[0]);
  LODWORD(v37) = *(_DWORD *)(a1 + 24);
  v40.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v41) = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v38, 1), *(float *)v40.i32, v38.f32[0]);
  v43 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a21.i8, 1);
  v476 = vaddq_f32(v43, vmulq_n_f32(v35, a2.f32[0]));
  v35.f32[0] = *(float *)&v37 + *(float *)&v39;
  v43.f32[0] = *(float *)&v41 + *(float *)v42.i32;
  v35.f32[1] = *(float *)&v41 + *(float *)v42.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, (float64x2_t)v43, v37, v39, v40, v42, v41, v44);
  v46.f32[0] = -*(float *)&a21.i32[2];
  v46.f32[1] = v503;
  HIDWORD(v47) = v537.i32[1];
  v48 = vadd_f32(v46, *(float32x2_t *)v537.i8);
  *(float *)&v49 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v48, 1), *(float *)(a1 + 16), v48.f32[0]);
  LODWORD(v47) = *(_DWORD *)(a1 + 24);
  v50.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v51) = *(_DWORD *)(a1 + 36);
  *(float *)v52.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v48, 1), *(float *)v50.i32, v48.f32[0]);
  v53 = (float64x2_t)v476;
  v477 = vaddq_f32(v476, vmulq_lane_f32(v45, *(float32x2_t *)a2.f32, 1));
  v45.f32[0] = *(float *)&v47 + *(float *)&v49;
  *(float *)v53.f64 = *(float *)&v51 + *(float *)v52.i32;
  v45.f32[1] = *(float *)&v51 + *(float *)v52.i32;
  *(double *)v55.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v53, v47, v49, v50, v52, v51, v54);
  v56.i32[0] = 0;
  v56.f32[1] = v503;
  HIDWORD(v57) = v537.i32[1];
  v58 = vadd_f32(v56, *(float32x2_t *)v537.i8);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v58, 1), *(float *)(a1 + 16), v58.f32[0]);
  LODWORD(v57) = *(_DWORD *)(a1 + 24);
  v60.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v61) = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v58, 1), *(float *)v60.i32, v58.f32[0]);
  v63 = (float64x2_t)v477;
  v478 = vaddq_f32(v477, vmulq_laneq_f32(v55, a2, 2));
  v55.f32[0] = *(float *)&v57 + *(float *)&v59;
  *(float *)v63.f64 = *(float *)&v61 + *(float *)v62.i32;
  v55.f32[1] = *(float *)&v61 + *(float *)v62.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v55.i64, v63, v57, v59, v60, v62, v61, v64);
  HIDWORD(v66) = v537.i32[1];
  v67 = vadd_f32((float32x2_t)__PAIR64__(LODWORD(v503), v526.u32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v68 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v67, 1), *(float *)(a1 + 16), v67.f32[0]);
  LODWORD(v66) = *(_DWORD *)(a1 + 24);
  v69.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v70) = *(_DWORD *)(a1 + 36);
  *(float *)v71.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v67, 1), *(float *)v69.i32, v67.f32[0]);
  v72 = (float64x2_t)v478;
  v480 = vaddq_f32(v478, vmulq_laneq_f32(v65, a2, 3));
  v65.f32[0] = *(float *)&v66 + *(float *)&v68;
  *(float *)v72.f64 = *(float *)&v70 + *(float *)v71.i32;
  v65.f32[1] = *(float *)&v70 + *(float *)v71.i32;
  *(double *)v74.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v72, v66, v68, v69, v71, v70, v73);
  HIDWORD(v75) = v537.i32[1];
  v76 = vadd_f32((float32x2_t)__PAIR64__(LODWORD(v503), v528.u32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v77 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v76, 1), *(float *)(a1 + 16), v76.f32[0]);
  LODWORD(v75) = *(_DWORD *)(a1 + 24);
  v78.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v79) = *(_DWORD *)(a1 + 36);
  *(float *)v80.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v76, 1), *(float *)v78.i32, v76.f32[0]);
  v81 = (float64x2_t)v480;
  v481 = vaddq_f32(v480, vmulq_n_f32(v74, a3.f32[0]));
  v74.f32[0] = *(float *)&v75 + *(float *)&v77;
  *(float *)v81.f64 = *(float *)&v79 + *(float *)v80.i32;
  v74.f32[1] = *(float *)&v79 + *(float *)v80.i32;
  *(double *)v83.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v74.i64, v81, v75, v77, v78, v80, v79, v82);
  HIDWORD(v84) = v537.i32[1];
  v85 = vadd_f32((float32x2_t)__PAIR64__(LODWORD(v503), v527.u32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v86 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v85, 1), *(float *)(a1 + 16), v85.f32[0]);
  LODWORD(v84) = *(_DWORD *)(a1 + 24);
  v87.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v88) = *(_DWORD *)(a1 + 36);
  *(float *)v89.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v85, 1), *(float *)v87.i32, v85.f32[0]);
  v90 = (float64x2_t)v481;
  v482 = vaddq_f32(v481, vmulq_lane_f32(v83, *(float32x2_t *)a3.f32, 1));
  v83.f32[0] = *(float *)&v84 + *(float *)&v86;
  *(float *)v90.f64 = *(float *)&v88 + *(float *)v89.i32;
  v83.f32[1] = *(float *)&v88 + *(float *)v89.i32;
  *(double *)v92.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v83.i64, v90, v84, v86, v87, v89, v88, v91);
  v93.f32[0] = v525;
  v93.f32[1] = -v528.f32[1];
  HIDWORD(v94) = v537.i32[1];
  v95 = vadd_f32(v93, *(float32x2_t *)v537.i8);
  *(float *)&v96 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v95, 1), *(float *)(a1 + 16), v95.f32[0]);
  LODWORD(v94) = *(_DWORD *)(a1 + 24);
  v97.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v98) = *(_DWORD *)(a1 + 36);
  *(float *)v99.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v95, 1), *(float *)v97.i32, v95.f32[0]);
  v100 = (float64x2_t)v482;
  v483 = vaddq_f32(v482, vmulq_laneq_f32(v92, a3, 2));
  v92.f32[0] = *(float *)&v94 + *(float *)&v96;
  *(float *)v100.f64 = *(float *)&v98 + *(float *)v99.i32;
  v92.f32[1] = *(float *)&v98 + *(float *)v99.i32;
  *(double *)v102.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v92.i64, v100, v94, v96, v97, v99, v98, v101);
  HIDWORD(v103) = v537.i32[1];
  v104 = vadd_f32((float32x2_t)__PAIR64__(-v528.f32[1], -v528.f32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v105 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v104, 1), *(float *)(a1 + 16), v104.f32[0]);
  LODWORD(v103) = *(_DWORD *)(a1 + 24);
  v106.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v107) = *(_DWORD *)(a1 + 36);
  *(float *)v108.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v104, 1), *(float *)v106.i32, v104.f32[0]);
  v109 = (float64x2_t)v483;
  v485 = vaddq_f32(v483, vmulq_laneq_f32(v102, a3, 3));
  v102.f32[0] = *(float *)&v103 + *(float *)&v105;
  *(float *)v109.f64 = *(float *)&v107 + *(float *)v108.i32;
  v102.f32[1] = *(float *)&v107 + *(float *)v108.i32;
  *(double *)v111.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v102.i64, v109, v103, v105, v106, v108, v107, v110);
  HIDWORD(v112) = v537.i32[1];
  v113 = vadd_f32((float32x2_t)__PAIR64__(-v528.f32[1], -*(float *)&a21.i32[2]), *(float32x2_t *)v537.i8);
  *(float *)&v114 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v113, 1), *(float *)(a1 + 16), v113.f32[0]);
  LODWORD(v112) = *(_DWORD *)(a1 + 24);
  v115.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v116) = *(_DWORD *)(a1 + 36);
  *(float *)v117.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v113, 1), *(float *)v115.i32, v113.f32[0]);
  v118 = (float64x2_t)v485;
  v486 = vaddq_f32(v485, vmulq_n_f32(v111, a4.f32[0]));
  v111.f32[0] = *(float *)&v112 + *(float *)&v114;
  *(float *)v118.f64 = *(float *)&v116 + *(float *)v117.i32;
  v111.f32[1] = *(float *)&v116 + *(float *)v117.i32;
  *(double *)v120.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v111.i64, v118, v112, v114, v115, v117, v116, v119);
  v121.i32[0] = 0;
  v121.f32[1] = -v528.f32[1];
  HIDWORD(v122) = v537.i32[1];
  v123 = vadd_f32(v121, *(float32x2_t *)v537.i8);
  *(float *)&v124 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v123, 1), *(float *)(a1 + 16), v123.f32[0]);
  LODWORD(v122) = *(_DWORD *)(a1 + 24);
  v125.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v126) = *(_DWORD *)(a1 + 36);
  *(float *)v127.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v123, 1), *(float *)v125.i32, v123.f32[0]);
  v128 = (float64x2_t)v486;
  v487 = vaddq_f32(v486, vmulq_lane_f32(v120, *(float32x2_t *)a4.f32, 1));
  v120.f32[0] = *(float *)&v122 + *(float *)&v124;
  *(float *)v128.f64 = *(float *)&v126 + *(float *)v127.i32;
  v120.f32[1] = *(float *)&v126 + *(float *)v127.i32;
  *(double *)v130.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v120.i64, v128, v122, v124, v125, v127, v126, v129);
  HIDWORD(v131) = v537.i32[1];
  v132 = vadd_f32((float32x2_t)__PAIR64__(-v528.f32[1], v526.u32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v133 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v132, 1), *(float *)(a1 + 16), v132.f32[0]);
  LODWORD(v131) = *(_DWORD *)(a1 + 24);
  v134.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v135) = *(_DWORD *)(a1 + 36);
  *(float *)v136.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v132, 1), *(float *)v134.i32, v132.f32[0]);
  v137 = (float64x2_t)v487;
  v488 = vaddq_f32(v487, vmulq_laneq_f32(v130, a4, 2));
  v130.f32[0] = *(float *)&v131 + *(float *)&v133;
  *(float *)v137.f64 = *(float *)&v135 + *(float *)v136.i32;
  v130.f32[1] = *(float *)&v135 + *(float *)v136.i32;
  *(double *)v139.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v130.i64, v137, v131, v133, v134, v136, v135, v138);
  HIDWORD(v140) = v537.i32[1];
  v141 = vadd_f32((float32x2_t)__PAIR64__(-v528.f32[1], v528.u32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v142 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v141, 1), *(float *)(a1 + 16), v141.f32[0]);
  LODWORD(v140) = *(_DWORD *)(a1 + 24);
  v143.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v144) = *(_DWORD *)(a1 + 36);
  *(float *)v145.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v141, 1), *(float *)v143.i32, v141.f32[0]);
  v146 = (float64x2_t)v488;
  v490 = vaddq_f32(v488, vmulq_laneq_f32(v139, a4, 3));
  v139.f32[0] = *(float *)&v140 + *(float *)&v142;
  *(float *)v146.f64 = *(float *)&v144 + *(float *)v145.i32;
  v139.f32[1] = *(float *)&v144 + *(float *)v145.i32;
  *(double *)v148.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v139.i64, v146, v140, v142, v143, v145, v144, v147);
  HIDWORD(v149) = v537.i32[1];
  v150 = vadd_f32((float32x2_t)__PAIR64__(-v528.f32[1], v527.u32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v151 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v150, 1), *(float *)(a1 + 16), v150.f32[0]);
  LODWORD(v149) = *(_DWORD *)(a1 + 24);
  v152.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v153) = *(_DWORD *)(a1 + 36);
  *(float *)v154.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v150, 1), *(float *)v152.i32, v150.f32[0]);
  v155 = (float64x2_t)v490;
  v491 = vaddq_f32(v490, vmulq_n_f32(v148, a5.f32[0]));
  v148.f32[0] = *(float *)&v149 + *(float *)&v151;
  *(float *)v155.f64 = *(float *)&v153 + *(float *)v154.i32;
  v148.f32[1] = *(float *)&v153 + *(float *)v154.i32;
  *(double *)v157.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v148.i64, v155, v149, v151, v152, v154, v153, v156);
  v158.f32[0] = v525;
  v158.f32[1] = -*(float *)&a21.i32[3];
  HIDWORD(v159) = v537.i32[1];
  v160 = vadd_f32(v158, *(float32x2_t *)v537.i8);
  *(float *)&v161 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v160, 1), *(float *)(a1 + 16), v160.f32[0]);
  LODWORD(v159) = *(_DWORD *)(a1 + 24);
  v162.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v163) = *(_DWORD *)(a1 + 36);
  *(float *)v164.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v160, 1), *(float *)v162.i32, v160.f32[0]);
  v165 = (float64x2_t)v491;
  v492 = vaddq_f32(v491, vmulq_lane_f32(v157, *(float32x2_t *)a5.f32, 1));
  v157.f32[0] = *(float *)&v159 + *(float *)&v161;
  *(float *)v165.f64 = *(float *)&v163 + *(float *)v164.i32;
  v157.f32[1] = *(float *)&v163 + *(float *)v164.i32;
  *(double *)v167.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v157.i64, v165, v159, v161, v162, v164, v163, v166);
  HIDWORD(v168) = v537.i32[1];
  v169 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], -v528.f32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v170 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v169, 1), *(float *)(a1 + 16), v169.f32[0]);
  LODWORD(v168) = *(_DWORD *)(a1 + 24);
  v171.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v172) = *(_DWORD *)(a1 + 36);
  *(float *)v173.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v169, 1), *(float *)v171.i32, v169.f32[0]);
  v174 = (float64x2_t)v492;
  v493 = vaddq_f32(v492, vmulq_laneq_f32(v167, a5, 2));
  v167.f32[0] = *(float *)&v168 + *(float *)&v170;
  *(float *)v174.f64 = *(float *)&v172 + *(float *)v173.i32;
  v167.f32[1] = *(float *)&v172 + *(float *)v173.i32;
  *(double *)v176.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v167.i64, v174, v168, v170, v171, v173, v172, v175);
  HIDWORD(v177) = v537.i32[1];
  v178 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], -*(float *)&a21.i32[2]), *(float32x2_t *)v537.i8);
  *(float *)&v179 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v178, 1), *(float *)(a1 + 16), v178.f32[0]);
  LODWORD(v177) = *(_DWORD *)(a1 + 24);
  v180.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v181) = *(_DWORD *)(a1 + 36);
  *(float *)v182.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v178, 1), *(float *)v180.i32, v178.f32[0]);
  v183 = (float64x2_t)v493;
  v495 = vaddq_f32(v493, vmulq_laneq_f32(v176, a5, 3));
  v176.f32[0] = *(float *)&v177 + *(float *)&v179;
  *(float *)v183.f64 = *(float *)&v181 + *(float *)v182.i32;
  v176.f32[1] = *(float *)&v181 + *(float *)v182.i32;
  *(double *)v185.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v176.i64, v183, v177, v179, v180, v182, v181, v184);
  LODWORD(v186) = 0;
  *((float *)&v186 + 1) = -*(float *)&a21.i32[3];
  v187 = vadd_f32(*(float32x2_t *)&v186, *(float32x2_t *)v537.i8);
  *(float *)&v188 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v187, 1), *(float *)(a1 + 16), v187.f32[0]);
  LODWORD(v186) = *(_DWORD *)(a1 + 24);
  v189.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v190) = *(_DWORD *)(a1 + 36);
  *(float *)v191.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v187, 1), *(float *)v189.i32, v187.f32[0]);
  v192 = (float64x2_t)v495;
  v496 = vaddq_f32(v495, vmulq_n_f32(v185, a6.f32[0]));
  v185.f32[0] = *(float *)&v186 + *(float *)&v188;
  *(float *)v192.f64 = *(float *)&v190 + *(float *)v191.i32;
  v185.f32[1] = *(float *)&v190 + *(float *)v191.i32;
  *(double *)v194.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v185.i64, v192, v186, v188, v189, v191, v190, v193);
  HIDWORD(v195) = v537.i32[1];
  v196 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], v526.u32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v197 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v196, 1), *(float *)(a1 + 16), v196.f32[0]);
  LODWORD(v195) = *(_DWORD *)(a1 + 24);
  v198.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v199) = *(_DWORD *)(a1 + 36);
  *(float *)v200.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v196, 1), *(float *)v198.i32, v196.f32[0]);
  v201 = (float64x2_t)v496;
  v497 = vaddq_f32(v496, vmulq_lane_f32(v194, *(float32x2_t *)a6.f32, 1));
  v194.f32[0] = *(float *)&v195 + *(float *)&v197;
  *(float *)v201.f64 = *(float *)&v199 + *(float *)v200.i32;
  v194.f32[1] = *(float *)&v199 + *(float *)v200.i32;
  *(double *)v203.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v194.i64, v201, v195, v197, v198, v200, v199, v202);
  HIDWORD(v204) = v537.i32[1];
  v205 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], v528.u32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v206 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v205, 1), *(float *)(a1 + 16), v205.f32[0]);
  LODWORD(v204) = *(_DWORD *)(a1 + 24);
  v207.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v208) = *(_DWORD *)(a1 + 36);
  *(float *)v209.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v205, 1), *(float *)v207.i32, v205.f32[0]);
  v210 = (float64x2_t)v497;
  v498 = vaddq_f32(v497, vmulq_laneq_f32(v203, a6, 2));
  v203.f32[0] = *(float *)&v204 + *(float *)&v206;
  *(float *)v210.f64 = *(float *)&v208 + *(float *)v209.i32;
  v203.f32[1] = *(float *)&v208 + *(float *)v209.i32;
  *(double *)v212.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v203.i64, v210, v204, v206, v207, v209, v208, v211);
  HIDWORD(v213) = v537.i32[1];
  v214 = vadd_f32((float32x2_t)__PAIR64__(-*(float *)&a21.i32[3], v527.u32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v215 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v214, 1), *(float *)(a1 + 16), v214.f32[0]);
  LODWORD(v213) = *(_DWORD *)(a1 + 24);
  v216.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v217) = *(_DWORD *)(a1 + 36);
  *(float *)v218.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v214, 1), *(float *)v216.i32, v214.f32[0]);
  v219 = (float64x2_t)v498;
  v504 = vaddq_f32(v498, vmulq_laneq_f32(v212, a6, 3));
  v212.f32[0] = *(float *)&v213 + *(float *)&v215;
  *(float *)v219.f64 = *(float *)&v217 + *(float *)v218.i32;
  v212.f32[1] = *(float *)&v217 + *(float *)v218.i32;
  *(double *)v221.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v212.i64, v219, v213, v215, v216, v218, v217, v220);
  HIDWORD(v222) = v537.i32[1];
  v223 = vadd_f32((float32x2_t)LODWORD(v525), *(float32x2_t *)v537.i8);
  *(float *)&v224 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v223, 1), *(float *)(a1 + 16), v223.f32[0]);
  LODWORD(v222) = *(_DWORD *)(a1 + 24);
  v225.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v226) = *(_DWORD *)(a1 + 36);
  *(float *)v227.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v223, 1), *(float *)v225.i32, v223.f32[0]);
  v228 = (float64x2_t)v504;
  v505 = vaddq_f32(v504, vmulq_n_f32(v221, a7.f32[0]));
  v221.f32[0] = *(float *)&v222 + *(float *)&v224;
  *(float *)v228.f64 = *(float *)&v226 + *(float *)v227.i32;
  v221.f32[1] = *(float *)&v226 + *(float *)v227.i32;
  *(double *)v230.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v221.i64, v228, v222, v224, v225, v227, v226, v229);
  HIDWORD(v231) = v537.i32[1];
  v232 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-v528.f32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v233 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v232, 1), *(float *)(a1 + 16), v232.f32[0]);
  LODWORD(v231) = *(_DWORD *)(a1 + 24);
  v234.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v235) = *(_DWORD *)(a1 + 36);
  *(float *)v236.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v232, 1), *(float *)v234.i32, v232.f32[0]);
  v237 = (float64x2_t)v505;
  v506 = vaddq_f32(v505, vmulq_lane_f32(v230, *(float32x2_t *)a7.f32, 1));
  v230.f32[0] = *(float *)&v231 + *(float *)&v233;
  *(float *)v237.f64 = *(float *)&v235 + *(float *)v236.i32;
  v230.f32[1] = *(float *)&v235 + *(float *)v236.i32;
  *(double *)v239.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v230.i64, v237, v231, v233, v234, v236, v235, v238);
  HIDWORD(v240) = v537.i32[1];
  v241 = vadd_f32((float32x2_t)COERCE_UNSIGNED_INT(-*(float *)&a21.i32[2]), *(float32x2_t *)v537.i8);
  *(float *)&v242 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v241, 1), *(float *)(a1 + 16), v241.f32[0]);
  LODWORD(v240) = *(_DWORD *)(a1 + 24);
  v243.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v244) = *(_DWORD *)(a1 + 36);
  *(float *)v245.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v241, 1), *(float *)v243.i32, v241.f32[0]);
  v246 = (float64x2_t)v506;
  v507 = vaddq_f32(v506, vmulq_laneq_f32(v239, a7, 2));
  v239.f32[0] = *(float *)&v240 + *(float *)&v242;
  *(float *)v246.f64 = *(float *)&v244 + *(float *)v245.i32;
  v239.f32[1] = *(float *)&v244 + *(float *)v245.i32;
  *(double *)v248.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v239.i64, v246, v240, v242, v243, v245, v244, v247);
  v249 = (float64x2_t)v507;
  v508 = vaddq_f32(v507, vmulq_laneq_f32(v248, a7, 3));
  LODWORD(v250) = *(_DWORD *)(a1 + 28);
  v248.f32[0] = *(float *)(a1 + 24)
              + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v537.i8, 1), *(float *)(a1 + 16), *(float *)v537.i32);
  LODWORD(v251) = *(_DWORD *)(a1 + 36);
  *(float *)v249.f64 = *(float *)&v251
                     + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v537.i8, 1), *(float *)&v250, *(float *)v537.i32);
  v248.i32[1] = LODWORD(v249.f64[0]);
  *(double *)v255.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v248.i64, v249, v250, v251, v537, v252, v253, v254);
  HIDWORD(v256) = v537.i32[1];
  v257 = vadd_f32((float32x2_t)v526.u32[0], *(float32x2_t *)v537.i8);
  *(float *)&v258 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v257, 1), *(float *)(a1 + 16), v257.f32[0]);
  LODWORD(v256) = *(_DWORD *)(a1 + 24);
  v259.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v260) = *(_DWORD *)(a1 + 36);
  *(float *)v261.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v257, 1), *(float *)v259.i32, v257.f32[0]);
  v262 = (float64x2_t)v508;
  v509 = vaddq_f32(v508, vmulq_n_f32(v255, a8.f32[0]));
  v255.f32[0] = *(float *)&v256 + *(float *)&v258;
  *(float *)v262.f64 = *(float *)&v260 + *(float *)v261.i32;
  v255.f32[1] = *(float *)&v260 + *(float *)v261.i32;
  *(double *)v264.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v255.i64, v262, v256, v258, v259, v261, v260, v263);
  HIDWORD(v265) = v537.i32[1];
  v266 = vadd_f32((float32x2_t)v528.u32[0], *(float32x2_t *)v537.i8);
  *(float *)&v267 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v266, 1), *(float *)(a1 + 16), v266.f32[0]);
  LODWORD(v265) = *(_DWORD *)(a1 + 24);
  v268.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v269) = *(_DWORD *)(a1 + 36);
  *(float *)v270.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v266, 1), *(float *)v268.i32, v266.f32[0]);
  v271 = (float64x2_t)v509;
  v510 = vaddq_f32(v509, vmulq_lane_f32(v264, *(float32x2_t *)a8.f32, 1));
  v264.f32[0] = *(float *)&v265 + *(float *)&v267;
  *(float *)v271.f64 = *(float *)&v269 + *(float *)v270.i32;
  v264.f32[1] = *(float *)&v269 + *(float *)v270.i32;
  *(double *)v273.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v264.i64, v271, v265, v267, v268, v270, v269, v272);
  HIDWORD(v274) = v537.i32[1];
  v275 = vadd_f32((float32x2_t)v527.u32[0], *(float32x2_t *)v537.i8);
  *(float *)&v276 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v275, 1), *(float *)(a1 + 16), v275.f32[0]);
  LODWORD(v274) = *(_DWORD *)(a1 + 24);
  v277.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v278) = *(_DWORD *)(a1 + 36);
  *(float *)v279.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v275, 1), *(float *)v277.i32, v275.f32[0]);
  v280 = (float64x2_t)v510;
  v511 = vaddq_f32(v510, vmulq_laneq_f32(v273, a8, 2));
  v273.f32[0] = *(float *)&v274 + *(float *)&v276;
  *(float *)v280.f64 = *(float *)&v278 + *(float *)v279.i32;
  v273.f32[1] = *(float *)&v278 + *(float *)v279.i32;
  *(double *)v282.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v273.i64, v280, v274, v276, v277, v279, v278, v281);
  HIDWORD(v283) = v537.i32[1];
  v284 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], LODWORD(v525)), *(float32x2_t *)v537.i8);
  *(float *)&v285 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v284, 1), *(float *)(a1 + 16), v284.f32[0]);
  LODWORD(v283) = *(_DWORD *)(a1 + 24);
  v286.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v287) = *(_DWORD *)(a1 + 36);
  *(float *)v288.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v284, 1), *(float *)v286.i32, v284.f32[0]);
  v289 = (float64x2_t)v511;
  v512 = vaddq_f32(v511, vmulq_laneq_f32(v282, a8, 3));
  v282.f32[0] = *(float *)&v283 + *(float *)&v285;
  *(float *)v289.f64 = *(float *)&v287 + *(float *)v288.i32;
  v282.f32[1] = *(float *)&v287 + *(float *)v288.i32;
  *(double *)v291.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v282.i64, v289, v283, v285, v286, v288, v287, v290);
  HIDWORD(v292) = v537.i32[1];
  v293 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], -v528.f32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v294 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v293, 1), *(float *)(a1 + 16), v293.f32[0]);
  LODWORD(v292) = *(_DWORD *)(a1 + 24);
  v295.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v296) = *(_DWORD *)(a1 + 36);
  *(float *)v297.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v293, 1), *(float *)v295.i32, v293.f32[0]);
  v298 = (float64x2_t)v512;
  v513 = vaddq_f32(v512, vmulq_n_f32(v291, a9.f32[0]));
  v291.f32[0] = *(float *)&v292 + *(float *)&v294;
  *(float *)v298.f64 = *(float *)&v296 + *(float *)v297.i32;
  v291.f32[1] = *(float *)&v296 + *(float *)v297.i32;
  *(double *)v300.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v291.i64, v298, v292, v294, v295, v297, v296, v299);
  HIDWORD(v301) = v537.i32[1];
  v302 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], -*(float *)&a21.i32[2]), *(float32x2_t *)v537.i8);
  *(float *)&v303 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v302, 1), *(float *)(a1 + 16), v302.f32[0]);
  LODWORD(v301) = *(_DWORD *)(a1 + 24);
  v304.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v305) = *(_DWORD *)(a1 + 36);
  *(float *)v306.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v302, 1), *(float *)v304.i32, v302.f32[0]);
  v307 = (float64x2_t)v513;
  v514 = vaddq_f32(v513, vmulq_lane_f32(v300, *(float32x2_t *)a9.f32, 1));
  v300.f32[0] = *(float *)&v301 + *(float *)&v303;
  *(float *)v307.f64 = *(float *)&v305 + *(float *)v306.i32;
  v300.f32[1] = *(float *)&v305 + *(float *)v306.i32;
  *(double *)v309.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v300.i64, v307, v301, v303, v304, v306, v305, v308);
  v310.i32[1] = v526.i32[1];
  v310.i32[0] = 0;
  HIDWORD(v311) = v537.i32[1];
  v312 = vadd_f32(v310, *(float32x2_t *)v537.i8);
  *(float *)&v313 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v312, 1), *(float *)(a1 + 16), v312.f32[0]);
  LODWORD(v311) = *(_DWORD *)(a1 + 24);
  v314.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v315) = *(_DWORD *)(a1 + 36);
  *(float *)v316.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v312, 1), *(float *)v314.i32, v312.f32[0]);
  v317 = (float64x2_t)v514;
  v515 = vaddq_f32(v514, vmulq_laneq_f32(v309, a9, 2));
  v309.f32[0] = *(float *)&v311 + *(float *)&v313;
  *(float *)v317.f64 = *(float *)&v315 + *(float *)v316.i32;
  v309.f32[1] = *(float *)&v315 + *(float *)v316.i32;
  *(double *)v319.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v309.i64, v317, v311, v313, v314, v316, v315, v318);
  HIDWORD(v320) = v537.i32[1];
  v321 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], v526.u32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v322 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v321, 1), *(float *)(a1 + 16), v321.f32[0]);
  LODWORD(v320) = *(_DWORD *)(a1 + 24);
  v323.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v324) = *(_DWORD *)(a1 + 36);
  *(float *)v325.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v321, 1), *(float *)v323.i32, v321.f32[0]);
  v326 = (float64x2_t)v515;
  v516 = vaddq_f32(v515, vmulq_laneq_f32(v319, a9, 3));
  v319.f32[0] = *(float *)&v320 + *(float *)&v322;
  *(float *)v326.f64 = *(float *)&v324 + *(float *)v325.i32;
  v319.f32[1] = *(float *)&v324 + *(float *)v325.i32;
  *(double *)v328.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v319.i64, v326, v320, v322, v323, v325, v324, v327);
  HIDWORD(v329) = v537.i32[1];
  v330 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], v528.u32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v331 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v330, 1), *(float *)(a1 + 16), v330.f32[0]);
  LODWORD(v329) = *(_DWORD *)(a1 + 24);
  v332.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v333) = *(_DWORD *)(a1 + 36);
  *(float *)v334.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v330, 1), *(float *)v332.i32, v330.f32[0]);
  v335 = (float64x2_t)v516;
  v517 = vaddq_f32(v516, vmulq_n_f32(v328, a17.f32[0]));
  v328.f32[0] = *(float *)&v329 + *(float *)&v331;
  *(float *)v335.f64 = *(float *)&v333 + *(float *)v334.i32;
  v328.f32[1] = *(float *)&v333 + *(float *)v334.i32;
  *(double *)v337.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v328.i64, v335, v329, v331, v332, v334, v333, v336);
  HIDWORD(v338) = v537.i32[1];
  v339 = vadd_f32((float32x2_t)__PAIR64__(a21.u32[3], v527.u32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v340 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v339, 1), *(float *)(a1 + 16), v339.f32[0]);
  LODWORD(v338) = *(_DWORD *)(a1 + 24);
  v341.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v342) = *(_DWORD *)(a1 + 36);
  *(float *)v343.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v339, 1), *(float *)v341.i32, v339.f32[0]);
  v344 = (float64x2_t)v517;
  v518 = vaddq_f32(v517, vmulq_lane_f32(v337, *(float32x2_t *)a17.f32, 1));
  v337.f32[0] = *(float *)&v338 + *(float *)&v340;
  *(float *)v344.f64 = *(float *)&v342 + *(float *)v343.i32;
  v337.f32[1] = *(float *)&v342 + *(float *)v343.i32;
  *(double *)v346.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v337.i64, v344, v338, v340, v341, v343, v342, v345);
  HIDWORD(v347) = v537.i32[1];
  v348 = vadd_f32((float32x2_t)__PAIR64__(v528.u32[1], LODWORD(v525)), *(float32x2_t *)v537.i8);
  *(float *)&v349 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v348, 1), *(float *)(a1 + 16), v348.f32[0]);
  LODWORD(v347) = *(_DWORD *)(a1 + 24);
  v350.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v351) = *(_DWORD *)(a1 + 36);
  *(float *)v352.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v348, 1), *(float *)v350.i32, v348.f32[0]);
  v353 = (float64x2_t)v518;
  v519 = vaddq_f32(v518, vmulq_laneq_f32(v346, a17, 2));
  v346.f32[0] = *(float *)&v347 + *(float *)&v349;
  *(float *)v353.f64 = *(float *)&v351 + *(float *)v352.i32;
  v346.f32[1] = *(float *)&v351 + *(float *)v352.i32;
  *(double *)v355.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v346.i64, v353, v347, v349, v350, v352, v351, v354);
  HIDWORD(v356) = v537.i32[1];
  v357 = vadd_f32((float32x2_t)__PAIR64__(v528.u32[1], -v528.f32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v358 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v357, 1), *(float *)(a1 + 16), v357.f32[0]);
  LODWORD(v356) = *(_DWORD *)(a1 + 24);
  v359.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v360) = *(_DWORD *)(a1 + 36);
  *(float *)v361.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v357, 1), *(float *)v359.i32, v357.f32[0]);
  v362 = (float64x2_t)v519;
  v520 = vaddq_f32(v519, vmulq_laneq_f32(v355, a17, 3));
  v355.f32[0] = *(float *)&v356 + *(float *)&v358;
  *(float *)v362.f64 = *(float *)&v360 + *(float *)v361.i32;
  v355.f32[1] = *(float *)&v360 + *(float *)v361.i32;
  *(double *)v364.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v355.i64, v362, v356, v358, v359, v361, v360, v363);
  HIDWORD(v365) = v537.i32[1];
  v366 = vadd_f32((float32x2_t)__PAIR64__(v528.u32[1], -*(float *)&a21.i32[2]), *(float32x2_t *)v537.i8);
  *(float *)&v367 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v366, 1), *(float *)(a1 + 16), v366.f32[0]);
  LODWORD(v365) = *(_DWORD *)(a1 + 24);
  v368.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v369) = *(_DWORD *)(a1 + 36);
  *(float *)v370.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v366, 1), *(float *)v368.i32, v366.f32[0]);
  v371 = (float64x2_t)v520;
  v521 = vaddq_f32(v520, vmulq_n_f32(v364, a18.f32[0]));
  v364.f32[0] = *(float *)&v365 + *(float *)&v367;
  *(float *)v371.f64 = *(float *)&v369 + *(float *)v370.i32;
  v364.f32[1] = *(float *)&v369 + *(float *)v370.i32;
  *(double *)v373.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v364.i64, v371, v365, v367, v368, v370, v369, v372);
  v374.i32[1] = v528.i32[1];
  HIDWORD(v375) = v537.i32[1];
  v374.i32[0] = 0;
  v376 = vadd_f32(v374, *(float32x2_t *)v537.i8);
  *(float *)&v377 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v376, 1), *(float *)(a1 + 16), v376.f32[0]);
  LODWORD(v375) = *(_DWORD *)(a1 + 24);
  v378.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v379) = *(_DWORD *)(a1 + 36);
  *(float *)v380.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v376, 1), *(float *)v378.i32, v376.f32[0]);
  v381 = (float64x2_t)v521;
  v522 = vaddq_f32(v521, vmulq_lane_f32(v373, *(float32x2_t *)a18.f32, 1));
  v373.f32[0] = *(float *)&v375 + *(float *)&v377;
  *(float *)v381.f64 = *(float *)&v379 + *(float *)v380.i32;
  v373.f32[1] = *(float *)&v379 + *(float *)v380.i32;
  *(double *)v383.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v373.i64, v381, v375, v377, v378, v380, v379, v382);
  HIDWORD(v384) = v537.i32[1];
  v385 = vadd_f32((float32x2_t)__PAIR64__(v528.u32[1], v526.u32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v386 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v385, 1), *(float *)(a1 + 16), v385.f32[0]);
  LODWORD(v384) = *(_DWORD *)(a1 + 24);
  v387.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v388) = *(_DWORD *)(a1 + 36);
  *(float *)v389.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v385, 1), *(float *)v387.i32, v385.f32[0]);
  v390 = (float64x2_t)v522;
  v523 = vaddq_f32(v522, vmulq_laneq_f32(v383, a18, 2));
  v383.f32[0] = *(float *)&v384 + *(float *)&v386;
  *(float *)v390.f64 = *(float *)&v388 + *(float *)v389.i32;
  v383.f32[1] = *(float *)&v388 + *(float *)v389.i32;
  *(double *)v392.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v383.i64, v390, v384, v386, v387, v389, v388, v391);
  HIDWORD(v393) = v537.i32[1];
  v394 = vadd_f32(v528, *(float32x2_t *)v537.i8);
  *(float *)&v395 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v394, 1), *(float *)(a1 + 16), v394.f32[0]);
  LODWORD(v393) = *(_DWORD *)(a1 + 24);
  v396.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v397) = *(_DWORD *)(a1 + 36);
  *(float *)v398.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v394, 1), *(float *)v396.i32, v394.f32[0]);
  v399 = (float64x2_t)v523;
  v529 = vaddq_f32(v523, vmulq_laneq_f32(v392, a18, 3));
  v392.f32[0] = *(float *)&v393 + *(float *)&v395;
  *(float *)v399.f64 = *(float *)&v397 + *(float *)v398.i32;
  v392.f32[1] = *(float *)&v397 + *(float *)v398.i32;
  *(double *)v401.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v392.i64, v399, v393, v395, v396, v398, v397, v400);
  HIDWORD(v402) = v537.i32[1];
  v403 = vadd_f32(vmul_f32(v526, (float32x2_t)0x4000000040400000), *(float32x2_t *)v537.i8);
  *(float *)&v404 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v403, 1), *(float *)(a1 + 16), v403.f32[0]);
  LODWORD(v402) = *(_DWORD *)(a1 + 24);
  v405.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v406) = *(_DWORD *)(a1 + 36);
  *(float *)v407.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v403, 1), *(float *)v405.i32, v403.f32[0]);
  v408 = (float64x2_t)v529;
  v530 = vaddq_f32(v529, vmulq_n_f32(v401, a19.f32[0]));
  v401.f32[0] = *(float *)&v402 + *(float *)&v404;
  *(float *)v408.f64 = *(float *)&v406 + *(float *)v407.i32;
  v401.f32[1] = *(float *)&v406 + *(float *)v407.i32;
  *(double *)v410.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v401.i64, v408, v402, v404, v405, v407, v406, v409);
  HIDWORD(v411) = v537.i32[1];
  v412 = vadd_f32((float32x2_t)__PAIR64__(v527.u32[1], LODWORD(v525)), *(float32x2_t *)v537.i8);
  *(float *)&v413 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v412, 1), *(float *)(a1 + 16), v412.f32[0]);
  LODWORD(v411) = *(_DWORD *)(a1 + 24);
  v414.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v415) = *(_DWORD *)(a1 + 36);
  *(float *)v416.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v412, 1), *(float *)v414.i32, v412.f32[0]);
  v417 = (float64x2_t)v530;
  v531 = vaddq_f32(v530, vmulq_lane_f32(v410, *(float32x2_t *)a19.f32, 1));
  v410.f32[0] = *(float *)&v411 + *(float *)&v413;
  *(float *)v417.f64 = *(float *)&v415 + *(float *)v416.i32;
  v410.f32[1] = *(float *)&v415 + *(float *)v416.i32;
  *(double *)v419.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v410.i64, v417, v411, v413, v414, v416, v415, v418);
  HIDWORD(v420) = v537.i32[1];
  v421 = vadd_f32((float32x2_t)__PAIR64__(v527.u32[1], v524), *(float32x2_t *)v537.i8);
  *(float *)&v422 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v421, 1), *(float *)(a1 + 16), v421.f32[0]);
  LODWORD(v420) = *(_DWORD *)(a1 + 24);
  v423.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v424) = *(_DWORD *)(a1 + 36);
  *(float *)v425.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v421, 1), *(float *)v423.i32, v421.f32[0]);
  v426 = (float64x2_t)v531;
  v532 = vaddq_f32(v531, vmulq_laneq_f32(v419, a19, 2));
  v419.f32[0] = *(float *)&v420 + *(float *)&v422;
  *(float *)v426.f64 = *(float *)&v424 + *(float *)v425.i32;
  v419.f32[1] = *(float *)&v424 + *(float *)v425.i32;
  *(double *)v428.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v419.i64, v426, v420, v422, v423, v425, v424, v427);
  HIDWORD(v429) = v537.i32[1];
  v430 = vadd_f32((float32x2_t)__PAIR64__(v527.u32[1], -*(float *)&a21.i32[2]), *(float32x2_t *)v537.i8);
  *(float *)&v431 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v430, 1), *(float *)(a1 + 16), v430.f32[0]);
  LODWORD(v429) = *(_DWORD *)(a1 + 24);
  v432.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v433) = *(_DWORD *)(a1 + 36);
  *(float *)v434.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v430, 1), *(float *)v432.i32, v430.f32[0]);
  v435 = (float64x2_t)v532;
  v533 = vaddq_f32(v532, vmulq_laneq_f32(v428, a19, 3));
  v428.f32[0] = *(float *)&v429 + *(float *)&v431;
  *(float *)v435.f64 = *(float *)&v433 + *(float *)v434.i32;
  v428.f32[1] = *(float *)&v433 + *(float *)v434.i32;
  *(double *)v437.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v428.i64, v435, v429, v431, v432, v434, v433, v436);
  v438.i32[1] = v527.i32[1];
  v438.i32[0] = 0;
  HIDWORD(v439) = v537.i32[1];
  v440 = vadd_f32(v438, *(float32x2_t *)v537.i8);
  *(float *)&v441 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v440, 1), *(float *)(a1 + 16), v440.f32[0]);
  LODWORD(v439) = *(_DWORD *)(a1 + 24);
  v442.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v443) = *(_DWORD *)(a1 + 36);
  *(float *)v444.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v440, 1), *(float *)v442.i32, v440.f32[0]);
  v445 = (float64x2_t)v533;
  v534 = vaddq_f32(v533, vmulq_n_f32(v437, a20.f32[0]));
  v437.f32[0] = *(float *)&v439 + *(float *)&v441;
  *(float *)v445.f64 = *(float *)&v443 + *(float *)v444.i32;
  v437.f32[1] = *(float *)&v443 + *(float *)v444.i32;
  *(double *)v447.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v437.i64, v445, v439, v441, v442, v444, v443, v446);
  HIDWORD(v448) = v537.i32[1];
  v449 = vadd_f32((float32x2_t)__PAIR64__(v527.u32[1], v526.u32[0]), *(float32x2_t *)v537.i8);
  *(float *)&v450 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v449, 1), *(float *)(a1 + 16), v449.f32[0]);
  LODWORD(v448) = *(_DWORD *)(a1 + 24);
  v451.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v452) = *(_DWORD *)(a1 + 36);
  *(float *)v453.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v449, 1), *(float *)v451.i32, v449.f32[0]);
  v454 = (float64x2_t)v534;
  v535 = vaddq_f32(v534, vmulq_lane_f32(v447, *(float32x2_t *)a20.f32, 1));
  v447.f32[0] = *(float *)&v448 + *(float *)&v450;
  *(float *)v454.f64 = *(float *)&v452 + *(float *)v453.i32;
  v447.f32[1] = *(float *)&v452 + *(float *)v453.i32;
  *(double *)v456.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v447.i64, v454, v448, v450, v451, v453, v452, v455);
  HIDWORD(v457) = v537.i32[1];
  v458 = vadd_f32(vmul_f32(v526, (float32x2_t)0x4040000040000000), *(float32x2_t *)v537.i8);
  *(float *)&v459 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v458, 1), *(float *)(a1 + 16), v458.f32[0]);
  LODWORD(v457) = *(_DWORD *)(a1 + 24);
  v460.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v461) = *(_DWORD *)(a1 + 36);
  *(float *)v462.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v458, 1), *(float *)v460.i32, v458.f32[0]);
  v463 = (float64x2_t)v535;
  v536 = vaddq_f32(v535, vmulq_laneq_f32(v456, a20, 2));
  v456.f32[0] = *(float *)&v457 + *(float *)&v459;
  *(float *)v463.f64 = *(float *)&v461 + *(float *)v462.i32;
  v456.f32[1] = *(float *)&v461 + *(float *)v462.i32;
  *(double *)v465.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v456.i64, v463, v457, v459, v460, v462, v461, v464);
  HIDWORD(v466) = v537.i32[1];
  v467 = vadd_f32(v527, *(float32x2_t *)v537.i8);
  *(float *)&v468 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v467, 1), *(float *)(a1 + 16), v467.f32[0]);
  LODWORD(v466) = *(_DWORD *)(a1 + 24);
  v469.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v470) = *(_DWORD *)(a1 + 36);
  *(float *)v471.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v467, 1), *(float *)v469.i32, v467.f32[0]);
  v472 = (float64x2_t)v536;
  v538 = vaddq_f32(v536, vmulq_laneq_f32(v465, a20, 3));
  v465.f32[0] = *(float *)&v466 + *(float *)&v468;
  *(float *)v472.f64 = *(float *)&v470 + *(float *)v471.i32;
  v465.f32[1] = *(float *)&v470 + *(float *)v471.i32;
  *(double *)v474.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v465.i64, v472, v466, v468, v469, v471, v470, v473);
  *(_QWORD *)&result = vaddq_f32(v538, vmulq_n_f32(v474, *(float *)a21.i32)).u64[0];
  return result;
}

double cikernel::_copyMachineTransition(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, __n128 a7)
{
  float32x4_t v7;
  int8x16_t v8;
  float v9;
  float v10;
  BOOL v11;
  float v12;
  float v13;
  float v14;
  float v15;
  double result;

  v7.i64[0] = *(_QWORD *)CI::getDC(a1);
  v7.i64[1] = __PAIR64__(1.0, a7.n128_u32[0]);
  v8 = (int8x16_t)vmulq_f32(a5, v7);
  v9 = vaddv_f32(vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL)));
  if (v9 <= 1.0)
    v10 = v9;
  else
    v10 = 1.0;
  v11 = v9 < 0.0;
  v12 = 0.0;
  if (v11)
    v10 = 0.0;
  v13 = fminf(vmlas_n_f32(a4.f32[1], v10, a4.f32[0]), vmuls_lane_f32(v10, a4, 2));
  if (v13 <= 1.0)
    v14 = v13;
  else
    v14 = 1.0;
  if (v13 >= 0.0)
    v12 = v14;
  v15 = fmaxf(v10, a7.n128_f32[2]);
  *(_QWORD *)&result = vaddq_f32(vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - v15), a3, v15), vmulq_n_f32(a6, vmuls_lane_f32(v12, (float32x2_t)a7.n128_u64[0], 1))).u64[0];
  return result;
}

void CI::f4_s_s_f3_f4_f4_f3(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, __n128, __n128);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  __n128 *v21;
  __n128 *v22;
  __n128 *v23;
  __n128 *v24;
  __int128 v25;
  int v26;
  int v27;
  int v28;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_DWORD *)(v9 + 88);
  v17 = *(_QWORD *)(v9 + 80);
  v18 = *(_DWORD *)(v9 + 112);
  v19 = *(_QWORD *)(v9 + 104);
  v20 = *(_QWORD *)(v9 + 128);
  if (*(_BYTE *)(a1 + 64))
  {
    v27 = *(_DWORD *)(v9 + 88);
    v28 = *(_DWORD *)(v9 + 16);
    v26 = *(_DWORD *)(v9 + 40);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 152)), a2);
    v13 = v26;
    v16 = v27;
    v11 = v28;
  }
  v21 = (__n128 *)(a3 + 16 * v19);
  if (v18 != 5)
    v21 = (__n128 *)((char *)a2 + 64 * v19);
  v22 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v22 = (__n128 *)((char *)a2 + 64 * v17);
  v23 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v23 = (__n128 *)((char *)a2 + 64 * v14);
  v24 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v24 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v25 = v10(*v24, *v23, *((__n128 *)a2 + 4 * v15), *v22, *v21, *((__n128 *)a2 + 4 * v20));
  *(_OWORD *)(a3 + 16 * a7) = v25;
}

uint64_t getMLMultiArrayClass(void)
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  void (*v7)(uint64_t);
  uint64_t v8;

  v3 = 0;
  v4 = &v3;
  v5 = 0x3052000000;
  v6 = __Block_byref_object_copy__2;
  v7 = __Block_byref_object_dispose__2;
  v0 = getMLMultiArrayClass(void)::softClass;
  v8 = getMLMultiArrayClass(void)::softClass;
  if (!getMLMultiArrayClass(void)::softClass)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = ___ZL20getMLMultiArrayClassv_block_invoke;
    v2[3] = &unk_1E2EC2EB8;
    v2[4] = &v3;
    ___ZL20getMLMultiArrayClassv_block_invoke((uint64_t)v2);
    v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_192261328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getMLFeatureValueClass(void)
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  void (*v7)(uint64_t);
  uint64_t v8;

  v3 = 0;
  v4 = &v3;
  v5 = 0x3052000000;
  v6 = __Block_byref_object_copy__2;
  v7 = __Block_byref_object_dispose__2;
  v0 = getMLFeatureValueClass(void)::softClass;
  v8 = getMLFeatureValueClass(void)::softClass;
  if (!getMLFeatureValueClass(void)::softClass)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = ___ZL22getMLFeatureValueClassv_block_invoke;
    v2[3] = &unk_1E2EC2EB8;
    v2[4] = &v3;
    ___ZL22getMLFeatureValueClassv_block_invoke((uint64_t)v2);
    v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1922613EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1922623D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 192), 8);
  _Unwind_Resume(a1);
}

uint64_t featureTypeOfName(void *a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  void *v6;

  v5 = (void *)objc_msgSend(a1, "modelDescription");
  if (a3 == 1)
  {
    v6 = (void *)objc_msgSend(v5, "outputDescriptionsByName");
  }
  else if (a3)
  {
    v6 = 0;
  }
  else
  {
    v6 = (void *)objc_msgSend(v5, "inputDescriptionsByName");
  }
  return objc_msgSend((id)objc_msgSend(v6, "objectForKey:", a2), "type");
}

uint64_t shapeForLayer(void *a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t result;
  uint64_t v10;

  v5 = (void *)objc_msgSend(a1, "modelDescription");
  if (a3 == 1)
  {
    v6 = (void *)objc_msgSend(v5, "outputDescriptionsByName");
  }
  else if (a3)
  {
    v6 = 0;
  }
  else
  {
    v6 = (void *)objc_msgSend(v5, "inputDescriptionsByName");
  }
  v7 = (void *)objc_msgSend(v6, "objectForKey:", a2);
  if (objc_msgSend(v7, "type") == 5)
  {
    v8 = (void *)objc_msgSend((id)objc_msgSend(v7, "multiArrayConstraint"), "shapeConstraint");
    result = objc_msgSend((id)objc_msgSend((id)objc_msgSend(v8, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "count");
    if ((unint64_t)(result - 2) <= 2)
    {
      v10 = result - 1;
      objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v8, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "objectAtIndexedSubscript:", result - 2), "integerValue");
      return objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v8, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "objectAtIndexedSubscript:", v10), "integerValue");
    }
  }
  else
  {
    result = objc_msgSend(v7, "type");
    if (result == 4)
    {
      objc_msgSend((id)objc_msgSend(v7, "imageConstraint"), "pixelsHigh");
      return objc_msgSend((id)objc_msgSend(v7, "imageConstraint"), "pixelsWide");
    }
  }
  return result;
}

void fillMultiArrayFloatToRh<float>(void *a1, void *a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double v21;
  uint64_t v22;
  double v23;
  int v24;
  uint64_t v25;
  int *v26;

  v4 = objc_msgSend(a2, "dataPointer");
  v5 = (void *)objc_msgSend(a2, "shape");
  v6 = objc_msgSend(v5, "count");
  v7 = objc_msgSend((id)objc_msgSend(v5, "objectAtIndexedSubscript:", v6 - 2), "intValue");
  v8 = objc_msgSend(a1, "baseAddress");
  v9 = objc_msgSend(a1, "bytesPerRow");
  objc_msgSend(a1, "region");
  v11 = v10;
  v13 = v12;
  v15 = v14;
  v17 = v16;
  v18 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "strides"), "objectAtIndexedSubscript:", v6 - 3), "unsignedLongValue");
  v19 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "strides"), "objectAtIndexedSubscript:", v6 - 2), "unsignedLongValue");
  v20 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "strides"), "objectAtIndexedSubscript:", v6 - 1), "unsignedLongValue");
  objc_msgSend(a1, "region");
  v22 = objc_msgSend(a1, "bytesPerRow") * ((int)v21 - 1);
  objc_msgSend(a1, "region");
  bzero((void *)objc_msgSend(a1, "baseAddress"), v22 + 2 * (int)v23);
  if (v17 > 0.0)
  {
    v24 = 0;
    do
    {
      if (v15 > 0.0)
      {
        v25 = 0;
        v26 = (int *)(v4 + 4 * (v20 * (int)v11 + v18 * ((v24 + (int)v13) / v7) + v19 * ((v24 + (int)v13) % v7)));
        do
        {
          _S0 = *v26;
          __asm { FCVT            H0, S0 }
          *(_WORD *)(v8 + 2 * v25++) = _S0;
          v26 += v20;
        }
        while (v15 > (double)(int)v25);
      }
      ++v24;
      v8 += 2 * (v9 >> 1);
    }
    while (v17 > (double)v24);
  }
}

void _ZL23fillMultiArrayFloatToRhIDF16_EvPU33objcproto22CIImageProcessorOutput11objc_objectP12MLMultiArray(void *a1, void *a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double v21;
  uint64_t v22;
  double v23;
  int v24;
  uint64_t v25;
  _WORD *v26;

  v4 = objc_msgSend(a2, "dataPointer");
  v5 = (void *)objc_msgSend(a2, "shape");
  v6 = objc_msgSend(v5, "count");
  v7 = objc_msgSend((id)objc_msgSend(v5, "objectAtIndexedSubscript:", v6 - 2), "intValue");
  v8 = objc_msgSend(a1, "baseAddress");
  v9 = objc_msgSend(a1, "bytesPerRow");
  objc_msgSend(a1, "region");
  v11 = v10;
  v13 = v12;
  v15 = v14;
  v17 = v16;
  v18 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "strides"), "objectAtIndexedSubscript:", v6 - 3), "unsignedLongValue");
  v19 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "strides"), "objectAtIndexedSubscript:", v6 - 2), "unsignedLongValue");
  v20 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "strides"), "objectAtIndexedSubscript:", v6 - 1), "unsignedLongValue");
  objc_msgSend(a1, "region");
  v22 = objc_msgSend(a1, "bytesPerRow") * ((int)v21 - 1);
  objc_msgSend(a1, "region");
  bzero((void *)objc_msgSend(a1, "baseAddress"), v22 + 2 * (int)v23);
  if (v17 > 0.0)
  {
    v24 = 0;
    do
    {
      if (v15 > 0.0)
      {
        v25 = 0;
        v26 = (_WORD *)(v4 + 2 * (v20 * (int)v11 + v18 * ((v24 + (int)v13) / v7) + v19 * ((v24 + (int)v13) % v7)));
        do
        {
          *(_WORD *)(v8 + 2 * v25++) = *v26;
          v26 += v20;
        }
        while (v15 > (double)(int)v25);
      }
      ++v24;
      v8 += 2 * (v9 >> 1);
    }
    while (v17 > (double)v24);
  }
}

uint64_t channelCountOfName(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  void *v7;
  void *v8;
  void *v10;
  uint64_t v11;

  v6 = featureTypeOfName(a1, a2, a3);
  if (v6 == 4)
    return 1;
  if (v6 != 5)
    return 0xFFFFFFFFLL;
  v7 = (void *)objc_msgSend(a1, "modelDescription");
  if (a3 == 1)
    v8 = (void *)objc_msgSend(v7, "outputDescriptionsByName");
  else
    v8 = a3 ? 0 : (void *)objc_msgSend(v7, "inputDescriptionsByName");
  v10 = (void *)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v8, "objectForKey:", a2), "multiArrayConstraint"), "shapeConstraint");
  if (objc_msgSend(v10, "type") != 2)
    return 0xFFFFFFFFLL;
  v11 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(v10, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "count");
  if (v11 != 4)
  {
    if (v11 == 3)
      return objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v10, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "objectAtIndexedSubscript:", 0), "integerValue");
    return 0xFFFFFFFFLL;
  }
  return objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v10, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "objectAtIndexedSubscript:", 1), "integerValue");
}

CIImage *process(void *a1, void *a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  void *v8;
  uint64_t v9;
  double *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  double v16;
  double v17;
  double v18;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  CIImage *v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  BOOL v38;
  BOOL v39;
  double v40;
  CGFloat v41;
  double v42;
  double v43;
  CGFloat v44;
  double v45;
  CIImage *v46;
  CIImage *v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  const __CFString *v51;
  double v52;
  double v53;
  double v54;
  double v55;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  double v62;
  void *v63;
  uint64_t v64;
  CIImage *result;
  const __CFString *v66;
  int v68;
  id obj;
  uint64_t v70;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  CGAffineTransform v81;
  CGAffineTransform v82;
  CGAffineTransform v83;
  CGAffineTransform v84;
  _QWORD v85[11];
  _QWORD v86[11];
  _BYTE v87[128];
  uint64_t v88;

  v88 = *MEMORY[0x1E0C80C00];
  v8 = (void *)objc_msgSend((id)objc_msgSend(a1, "allKeys"), "sortedArrayUsingSelector:", sel_caseInsensitiveCompare_);
  v68 = channelCountOfName(a2, a3, 1);
  v75 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v74 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v73 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v72 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v76 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v77 = 0u;
  v78 = 0u;
  v79 = 0u;
  v80 = 0u;
  obj = v8;
  v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v77, v87, 16);
  v10 = (double *)MEMORY[0x1E0C9D820];
  if (v9)
  {
    v11 = v9;
    v12 = *(_QWORD *)v78;
    v70 = a5;
LABEL_3:
    v13 = 0;
    while (1)
    {
      if (*(_QWORD *)v78 != v12)
        objc_enumerationMutation(obj);
      v14 = *(_QWORD *)(*((_QWORD *)&v77 + 1) + 8 * v13);
      shapeForLayer(a2, v14, 0);
      v17 = v16;
      v18 = v15;
      if (v16 == *v10 && v15 == v10[1])
        return 0;
      v20 = channelCountOfName(a2, v14, 0);
      if (v20 > 4 || ((1 << v20) & 0x1A) == 0)
        return 0;
      v22 = v20;
      v23 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "modelDescription"), "inputDescriptionsByName"), "objectForKey:", v14), "type");
      if (v23 != 4)
      {
        if (v23 != 5)
          return 0;
        v24 = (void *)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "modelDescription"), "inputDescriptionsByName"), "objectForKey:", v14), "multiArrayConstraint"), "shapeConstraint");
        if (objc_msgSend(v24, "type") != 2
          || objc_msgSend((id)objc_msgSend((id)objc_msgSend(v24, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "count") == 4&& objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(v24, "enumeratedShapes"), "objectAtIndexedSubscript:", 0), "objectAtIndexedSubscript:", 0), "integerValue") != 1)
        {
          return 0;
        }
      }
      v25 = (CIImage *)objc_msgSend(a1, "objectForKeyedSubscript:", v14);
      -[CIImage extent](v25, "extent");
      v27 = v26;
      v29 = v28;
      v31 = v30;
      v33 = v32;
      shapeForLayer(a2, v14, 0);
      v36 = v34;
      v37 = v35;
      if (v27 != 0.0 || (v29 == 0.0 ? (v38 = v31 == v34) : (v38 = 0), v38 ? (v39 = v33 == v35) : (v39 = 0), !v39))
      {
        memset(&v84, 0, sizeof(v84));
        -[CIImage extent](v25, "extent");
        v41 = -v40;
        -[CIImage extent](v25, "extent");
        CGAffineTransformMakeTranslation(&v84, v41, -v42);
        memset(&v83, 0, sizeof(v83));
        -[CIImage extent](v25, "extent");
        v44 = v36 / v43;
        -[CIImage extent](v25, "extent");
        CGAffineTransformMakeScale(&v83, v44, v37 / v45);
        v46 = -[CIImage imageByClampingToExtent](v25, "imageByClampingToExtent");
        v82 = v84;
        v47 = -[CIImage imageByApplyingTransform:](v46, "imageByApplyingTransform:", &v82);
        v81 = v83;
        v25 = -[CIImage imageByCroppingToRect:](-[CIImage imageByApplyingTransform:highQualityDownsample:](v47, "imageByApplyingTransform:highQualityDownsample:", &v81, 1), "imageByCroppingToRect:", 0.0, 0.0, v36, v37);
      }
      if (a5)
        v25 = -[CIImage imageByColorMatchingWorkingSpaceToColorSpace:](v25, "imageByColorMatchingWorkingSpaceToColorSpace:", a5);
      v48 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "modelDescription"), "inputDescriptionsByName"), "objectForKey:", v14), "type");
      v49 = (void *)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "modelDescription"), "inputDescriptionsByName"), "objectForKey:", v14);
      if (v49)
        v50 = objc_msgSend((id)objc_msgSend(v49, "imageConstraint"), "pixelFormatType");
      else
        v50 = 0;
      if (v48 == 5)
      {
        a5 = v70;
        if ((_DWORD)v22 == 3)
        {
          v51 = CFSTR("CIInterleavedToPlanar3");
          goto LABEL_39;
        }
        if ((_DWORD)v22 == 4)
        {
          v51 = CFSTR("CIInterleavedToPlanar4");
LABEL_39:
          v25 = -[CIImage imageByApplyingFilter:](v25, "imageByApplyingFilter:", v51);
        }
      }
      else
      {
        a5 = v70;
      }
      objc_msgSend(v75, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v17));
      objc_msgSend(v74, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v18));
      objc_msgSend(v73, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v22));
      objc_msgSend(v72, "addObject:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v50));
      if (!v25)
        v25 = +[CIImage emptyImage](CIImage, "emptyImage");
      objc_msgSend(v76, "addObject:", v25);
      if (v11 == ++v13)
      {
        v11 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v77, v87, 16);
        if (v11)
          goto LABEL_3;
        break;
      }
    }
  }
  shapeForLayer(a2, a3, 1);
  v54 = v53;
  v55 = v52;
  if (v53 == *v10 && v52 == v10[1])
    return 0;
  v57 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "modelDescription"), "inputDescriptionsByName"), "objectForKey:", objc_msgSend(obj, "objectAtIndexedSubscript:", 0)), "type");
  v58 = objc_msgSend((id)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "modelDescription"), "outputDescriptionsByName"), "objectForKey:", a3), "type");
  v59 = v58;
  if (v57 == 4)
    v60 = 266;
  else
    v60 = 2053;
  if (v58 == 4)
    v61 = 266;
  else
    v61 = 2053;
  v62 = v55 * (double)v68;
  v63 = (void *)objc_msgSend((id)objc_msgSend((id)objc_msgSend(a2, "modelDescription"), "outputDescriptionsByName"), "objectForKey:", a3);
  if (v63)
    v64 = objc_msgSend((id)objc_msgSend(v63, "imageConstraint"), "pixelFormatType");
  else
    v64 = 0;
  v84.a = 0.0;
  v85[0] = CFSTR("model");
  v85[1] = CFSTR("headName");
  v86[0] = a2;
  v86[1] = a3;
  v85[2] = CFSTR("inputNames");
  v85[3] = CFSTR("inputFormats");
  v86[2] = obj;
  v86[3] = v72;
  v85[4] = CFSTR("inputCIFormat");
  v86[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v60);
  v86[5] = v75;
  v85[5] = CFSTR("inputWidths");
  v85[6] = CFSTR("inputHeights");
  v86[6] = v74;
  v86[7] = v73;
  v85[7] = CFSTR("inputChans");
  v85[8] = CFSTR("outputFormat");
  v86[8] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", v64);
  v85[9] = CFSTR("outputCIFormat");
  v86[9] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v61);
  v85[10] = CFSTR("softmax");
  v86[10] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", a4);
  result = +[CIImageProcessorKernel applyWithExtent:inputs:arguments:error:](CICoreMLProcessor, "applyWithExtent:inputs:arguments:error:", v76, objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v86, v85, 11), &v84, 0.0, 0.0, v54, v62);
  if (v59 == 5)
  {
    if (v68 == 3)
    {
      v66 = CFSTR("CIPlanarToInterleaved3");
    }
    else
    {
      if (v68 != 4)
        goto LABEL_65;
      v66 = CFSTR("CIPlanarToInterleaved4");
    }
    result = -[CIImage imageByApplyingFilter:](result, "imageByApplyingFilter:", v66);
  }
LABEL_65:
  if (a5)
    return -[CIImage imageByColorMatchingColorSpaceToWorkingSpace:](result, "imageByColorMatchingColorSpaceToWorkingSpace:", a5);
  return result;
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

Class ___ZL20getMLMultiArrayClassv_block_invoke(uint64_t a1)
{
  Class result;

  CoreMLLibrary();
  result = objc_getClass("MLMultiArray");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL20getMLMultiArrayClassv_block_invoke_cold_1();
  getMLMultiArrayClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

void CoreMLLibrary(void)
{
  void *v0;
  __int128 v1;
  uint64_t v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v0 = 0;
  if (!CoreMLLibraryCore(char **)::frameworkLibrary)
  {
    v1 = xmmword_1E2EC33B0;
    v2 = 0;
    CoreMLLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  if (!CoreMLLibraryCore(char **)::frameworkLibrary)
    CoreMLLibrary(&v0);
}

Class ___ZL22getMLFeatureValueClassv_block_invoke(uint64_t a1)
{
  Class result;

  CoreMLLibrary();
  result = objc_getClass("MLFeatureValue");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL22getMLFeatureValueClassv_block_invoke_cold_1();
  getMLFeatureValueClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

void ___ZL24multiArrayForPlanarInputPU32objcproto21CIImageProcessorInput11objc_objectimmmPP7NSError_block_invoke(int a1, void *a2)
{
  free(a2);
}

Class ___ZL27getMLPredictionOptionsClassv_block_invoke(uint64_t a1)
{
  Class result;

  CoreMLLibrary();
  result = objc_getClass("MLPredictionOptions");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL27getMLPredictionOptionsClassv_block_invoke_cold_1();
  getMLPredictionOptionsClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

double cikernel::_crystallize(uint64_t a1, uint64_t a2, double a3, float32x2_t a4)
{
  float32x2_t v7;
  double v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v16;
  float64x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  double v20;
  uint8x8_t v21;
  int8x16_t v22;
  double v23;
  int8x16_t v24;
  float32x2_t v25;
  float v26;
  float32x2_t v27;
  int8x16_t v28;
  double v29;
  double v30;
  float64x2_t v31;
  double v32;
  int8x16_t v33;
  float32x2_t v34;
  float v35;
  float32x2_t v36;
  int8x16_t v37;
  double v38;
  double v39;
  float64x2_t v40;
  double v41;
  int8x16_t v42;
  __int128 v43;
  float32x2_t v44;
  float v45;
  float32x2_t v46;
  int8x16_t v47;
  double v48;
  float64x2_t v49;
  double v50;
  int8x16_t v51;
  double v52;
  float v53;
  int8x16_t v54;
  int8x16_t v55;
  float32x2_t v56;
  int32x2_t v57;
  float32x2_t v58;
  int32x2_t v59;
  int32x2_t v60;
  int8x16_t v61;
  int8x16_t v62;
  float32x2_t v63;
  int32x2_t v64;
  float32x2_t v65;
  int32x2_t v66;
  int32x2_t v67;
  int8x16_t v68;
  float32x4_t v69;
  int8x16_t v70;
  float32x4_t v71;
  int8x16_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int8x16_t v75;
  int8x16_t v76;
  float32x4_t v77;
  int8x16_t v78;
  float32x4_t v79;
  int8x16_t v80;
  float64x2_t v81;
  float v82;
  float v83;
  float v84;
  double v85;
  float32x4_t v86;
  double v87;
  int8x16_t v88;
  double v89;
  float64x2_t v90;
  double v91;
  int8x16_t v92;
  float32x4_t v93;
  double result;
  float32x2_t v95;
  __int128 v96;
  float32x2_t v97;
  double v98;
  float32x2_t v99;
  float32x4_t v100;
  double v101;
  float32x2_t v102;
  float v104;

  v7 = *(float32x2_t *)CI::getDC((CI *)a1);
  HIDWORD(v8) = HIDWORD(a3);
  v9 = vadd_f32(vmul_n_f32(vadd_f32(vrndm_f32(vadd_f32(vmul_lane_f32(v7, *(float32x2_t *)&a3, 1), (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000), *(float *)&a3), (float32x2_t)0x3F0000003F000000);
  v10 = vadd_f32(vadd_f32(a4, vmul_lane_f32(v9, *(float32x2_t *)&a3, 1)), (float32x2_t)0xBF000000BF000000);
  v97 = vadd_f32(v10, (float32x2_t)1065353216);
  v95 = vadd_f32(v10, (float32x2_t)0x3F80000000000000);
  __asm { FMOV            V1.2S, #1.0 }
  v99 = vadd_f32(v10, _D1);
  v16 = (float32x2_t)vdup_n_s32(0x3B800000u);
  *(float32x2_t *)&v17.f64[0] = vrndm_f32(vmul_f32(v10, v16));
  v18 = (float32x2_t)vdup_n_s32(0xC3800000);
  v19 = vmla_f32(v10, v18, *(float32x2_t *)&v17.f64[0]);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v19, 1), *(float *)(a2 + 16), v19.f32[0]);
  LODWORD(v20) = *(_DWORD *)(a2 + 28);
  v21.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v19, 1), *(float *)&v20, v19.f32[0]);
  v19.f32[0] = *(float *)(a2 + 24) + *(float *)&v8;
  *(float *)v17.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  v19.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  v101 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v19, v17, v8, v20, v22, v21, v23, v24);
  v25 = vmla_f32(v97, v18, vrndm_f32(vmul_f32(v97, v16)));
  v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v25, 1), *(float *)(a2 + 16), v25.f32[0]);
  v27 = v25;
  v25.i32[0] = *(_DWORD *)(a2 + 28);
  v28.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v27, 1), v25.f32[0], v27.f32[0]);
  *(float *)&v30 = *(float *)(a2 + 24) + v26;
  *(float *)v31.f64 = *(float *)v28.i32 + *(float *)&v29;
  *((float *)&v30 + 1) = *(float *)v28.i32 + *(float *)&v29;
  v98 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v30, v31, *(double *)&v25, v29, v28, (uint8x8_t)v27, v32, v33);
  v34 = vmla_f32(v95, v18, vrndm_f32(vmul_f32(v95, v16)));
  v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v34, 1), *(float *)(a2 + 16), v34.f32[0]);
  v36 = v34;
  v34.i32[0] = *(_DWORD *)(a2 + 28);
  v37.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v36, 1), v34.f32[0], v36.f32[0]);
  *(float *)&v39 = *(float *)(a2 + 24) + v35;
  *(float *)v40.f64 = *(float *)v37.i32 + *(float *)&v38;
  *((float *)&v39 + 1) = *(float *)v37.i32 + *(float *)&v38;
  *(double *)&v43 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v39, v40, *(double *)&v34, v38, v37, (uint8x8_t)v36, v41, v42);
  v96 = v43;
  v44 = vmla_f32(v99, v18, vrndm_f32(vmul_f32(v99, v16)));
  v45 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v44, 1), *(float *)(a2 + 16), v44.f32[0]);
  v46 = v44;
  v44.i32[0] = *(_DWORD *)(a2 + 28);
  v47.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v46, 1), v44.f32[0], v46.f32[0]);
  *(float *)&v43 = *(float *)(a2 + 24) + v45;
  *(float *)v49.f64 = *(float *)v47.i32 + *(float *)&v48;
  *((float *)&v43 + 1) = *(float *)v47.i32 + *(float *)&v48;
  v52 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v43, v49, *(double *)&v44, v48, v47, (uint8x8_t)v46, v50, v51);
  v53 = *(float *)&a3 * 0.65;
  *(float32x2_t *)v54.i8 = vadd_f32(v9, vmul_n_f32(vadd_f32(*(float32x2_t *)&v101, (float32x2_t)0xBF000000BF000000), v53));
  *(float32x2_t *)v55.i8 = vadd_f32(vadd_f32((float32x2_t)LODWORD(a3), v9), vmul_n_f32(vadd_f32(*(float32x2_t *)&v98, (float32x2_t)0xBF000000BF000000), v53));
  v56 = vsub_f32(v7, *(float32x2_t *)v54.i8);
  v57 = (int32x2_t)vmul_f32(v56, v56);
  v58 = vsub_f32(v7, *(float32x2_t *)v55.i8);
  v59 = (int32x2_t)vmul_f32(v58, v58);
  v60 = (int32x2_t)vadd_f32((float32x2_t)vzip1_s32(v57, v59), (float32x2_t)vzip2_s32(v57, v59));
  v54.i64[1] = v60.u32[0];
  v55.i64[1] = v60.u32[1];
  v70.i64[1] = *((_QWORD *)&v96 + 1);
  *(float32x2_t *)v61.i8 = vadd_f32(vadd_f32((float32x2_t)vzip1_s32(0, *(int32x2_t *)&a3), v9), vmul_n_f32(vadd_f32(*(float32x2_t *)&v96, (float32x2_t)0xBF000000BF000000), v53));
  *(float32x2_t *)v62.i8 = vadd_f32(vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0), v9), vmul_n_f32(vadd_f32(*(float32x2_t *)&v52, (float32x2_t)0xBF000000BF000000), v53));
  v63 = vsub_f32(v7, *(float32x2_t *)v61.i8);
  v64 = (int32x2_t)vmul_f32(v63, v63);
  v65 = vsub_f32(v7, *(float32x2_t *)v62.i8);
  v66 = (int32x2_t)vmul_f32(v65, v65);
  v67 = (int32x2_t)vadd_f32((float32x2_t)vzip1_s32(v64, v66), (float32x2_t)vzip2_s32(v64, v66));
  v61.i64[1] = v67.u32[0];
  v62.i64[1] = v67.u32[1];
  v68 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(vsub_f32((float32x2_t)v60, (float32x2_t)vdup_lane_s32(v60, 1)).f32[0] < 0.0)), 0x1FuLL));
  v69 = (float32x4_t)vbslq_s8(v68, v54, v55);
  *(int32x2_t *)v70.i8 = vdup_lane_s32(v67, 1);
  v71 = (float32x4_t)vbslq_s8(v68, v55, v54);
  v72 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(vsub_f32((float32x2_t)v67, *(float32x2_t *)v70.i8).f32[0] < 0.0)), 0x1FuLL));
  v73 = (float32x4_t)vbslq_s8(v72, v61, v62);
  v74 = (float32x4_t)vbslq_s8(v72, v62, v61);
  v75 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(COERCE_FLOAT(vsubq_f32(v69, v73).i32[2]) < 0.0)), 0x1FuLL));
  v76 = vbslq_s8(v75, (int8x16_t)v69, (int8x16_t)v73);
  v77 = (float32x4_t)vbslq_s8(v75, (int8x16_t)v73, (int8x16_t)v69);
  v78 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(COERCE_FLOAT(vsubq_f32(v71, v74).i32[2]) < 0.0)), 0x1FuLL));
  v79 = (float32x4_t)vbslq_s8(v78, (int8x16_t)v71, (int8x16_t)v74);
  v81 = (float64x2_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(COERCE_FLOAT(vsubq_f32(v77, v79).i32[2]) < 0.0)), 0x1FuLL));
  v80 = vbslq_s8((int8x16_t)v81, (int8x16_t)v77, (int8x16_t)v79);
  v102 = *(float32x2_t *)v80.i8;
  v81.f64[0] = 0.5;
  v82 = (float)(sqrtf(*(float *)&v80.i32[2]) - sqrtf(*(float *)&v76.i32[2])) * 0.5 + 0.5;
  if (v82 <= 1.0)
    v83 = v82;
  else
    v83 = 1.0;
  _NF = v82 < 0.0;
  v84 = 0.0;
  if (!_NF)
    v84 = v83;
  v104 = v84;
  v77.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)&v85 = *(float *)(a1 + 24)
                 + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v76.i8, 1), *(float *)(a1 + 16), *(float *)v76.i32);
  v78.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v81.f64 = *(float *)v78.i32
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v76.i8, 1), v77.f32[0], *(float *)v76.i32);
  HIDWORD(v85) = LODWORD(v81.f64[0]);
  *(double *)v86.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v85, v81, *(double *)v77.i64, *(double *)v76.i64, v78, *(uint8x8_t *)v68.i8, *(double *)v69.i64, v70);
  v100 = v86;
  HIDWORD(v87) = v102.i32[1];
  LODWORD(v87) = *(_DWORD *)(a1 + 28);
  v88.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&v89 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v102, 1), *(float *)&v87, v102.f32[0]);
  v86.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v102, 1), *(float *)(a1 + 16), v102.f32[0]);
  *(float *)v90.f64 = *(float *)v88.i32 + *(float *)&v89;
  v86.f32[1] = *(float *)v88.i32 + *(float *)&v89;
  *(double *)v93.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v86.i64, v90, v87, v89, v88, (uint8x8_t)v102, v91, v92);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v93, 1.0 - v104), v100, v104).u64[0];
  return result;
}

void CI::f4_sr_sr_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, uint64_t, double, double);
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  double *v18;
  double *v19;
  __int128 v20;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t, double, double))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_QWORD *)(v10 + 32);
  v14 = *(_DWORD *)(v10 + 64);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_DWORD *)(v10 + 88);
  v17 = *(_QWORD *)(v10 + 80);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
  v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (double *)((char *)a2 + 64 * v17);
  v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (double *)((char *)a2 + 64 * v15);
  *(double *)&v20 = v11(a4 + 80 * v12, a4 + 80 * v13, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_tiltShift(uint64_t a1, uint64_t a2, uint64_t a3, double a4, float32x2_t a5, double a6)
{
  float32x2_t *DC;
  double v11;
  double v12;
  uint8x8_t v13;
  int8x16_t v14;
  double v15;
  float64x2_t v16;
  double v17;
  int8x16_t v18;
  float32x4_t v19;
  CI *v20;
  float32x2_t *v21;
  double v22;
  double v23;
  uint8x8_t v24;
  int8x16_t v25;
  double v26;
  float64x2_t v27;
  double v28;
  int8x16_t v29;
  float32x4_t v30;
  CI *v31;
  float32x2_t *v32;
  double v33;
  double v34;
  uint8x8_t v35;
  int8x16_t v36;
  double v37;
  float64x2_t v38;
  double v39;
  int8x16_t v40;
  float32x4_t v41;
  float32x2_t v42;
  float v43;
  float32x2_t v44;
  float32x2_t v50;
  float32x2_t v52;
  double result;
  float32x4_t v54;
  float v55;
  float v56;
  float32x4_t v58;
  float v59;

  v59 = *((float *)&a6 + 1);
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v11 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v12) = *(_DWORD *)(a1 + 28);
  v13.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v14.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v12, COERCE_FLOAT(*DC));
  *(float *)&v15 = *(float *)(a1 + 24) + *(float *)&v11;
  *(float *)v16.f64 = *(float *)v13.i32 + *(float *)v14.i32;
  v55 = *(float *)v13.i32 + *(float *)v14.i32;
  v56 = *(float *)&v15;
  *((float *)&v15 + 1) = *(float *)v13.i32 + *(float *)v14.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v15, v16, v11, v12, v14, v13, v17, v18);
  v58 = v19;
  v21 = (float32x2_t *)CI::getDC(v20);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *v21, 1), *(float *)(a2 + 16), COERCE_FLOAT(*v21));
  LODWORD(v23) = *(_DWORD *)(a2 + 28);
  v24.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *v21, 1), *(float *)&v23, COERCE_FLOAT(*v21));
  *(float *)&v26 = *(float *)(a2 + 24) + *(float *)&v22;
  *(float *)v27.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  *((float *)&v26 + 1) = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v26, v27, v22, v23, v25, v24, v28, v29);
  v54 = v30;
  v32 = (float32x2_t *)CI::getDC(v31);
  *(float *)&v33 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 20), *v32, 1), *(float *)(a3 + 16), COERCE_FLOAT(*v32));
  LODWORD(v34) = *(_DWORD *)(a3 + 28);
  v35.i32[0] = *(_DWORD *)(a3 + 36);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 32), *v32, 1), *(float *)&v34, COERCE_FLOAT(*v32));
  *(float *)&v37 = *(float *)(a3 + 24) + *(float *)&v33;
  *(float *)v38.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  *((float *)&v37 + 1) = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a3 + 8), v37, v38, v33, v34, v36, v35, v39, v40);
  v42 = vsub_f32(a5, *(float32x2_t *)&a4);
  v43 = vmlas_n_f32(vmuls_lane_f32(v42.f32[1], v42, 1), v42.f32[0], v42.f32[0]);
  v42.f32[0] = (float)(sqrtf(v43)
                     * fabsf(vmlas_n_f32(vmuls_lane_f32(-(float)(*(float *)&a4 - v56), v42, 1), *((float *)&a4 + 1) - v55, v42.f32[0])/ v43))/ v59;
  v44 = vcvt_f32_f64(vmlaq_n_f64((float64x2_t)xmmword_192493BA0, (float64x2_t)xmmword_192493B90, (float)(v42.f32[0] + v42.f32[0])));
  __asm { FMOV            V3.2S, #1.0 }
  v50 = (float32x2_t)vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v44, _D3), (int8x8_t)_D3, (int8x8_t)v44), (int8x8_t)vcltz_f32(v44));
  __asm { FMOV            V4.2S, #3.0 }
  v52 = vmul_f32(vmul_f32(v50, v50), vmla_f32(_D4, (float32x2_t)0xC0000000C0000000, v50));
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(v58, v52.f32[0]), vmulq_n_f32(v54, 1.0 - vaddv_f32(v52))), vmulq_lane_f32(v41, v52, 1)).u64[0];
  return result;
}

void CI::f4_sr_sr_sr_f2_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, uint64_t, uint64_t, double, double, double);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  double *v21;
  double *v22;
  double *v23;
  __int128 v24;
  int v25;
  uint64_t v26;
  int v27;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t, uint64_t, double, double, double))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_QWORD *)(v10 + 32);
  v14 = *(_QWORD *)(v10 + 56);
  v15 = *(_DWORD *)(v10 + 88);
  v16 = *(_QWORD *)(v10 + 80);
  v17 = *(_DWORD *)(v10 + 112);
  v18 = *(_QWORD *)(v10 + 104);
  v19 = *(_DWORD *)(v10 + 136);
  v20 = *(_QWORD *)(v10 + 128);
  if (*(_BYTE *)(a1 + 64))
  {
    v26 = *(_QWORD *)(v10 + 32);
    v27 = *(_DWORD *)(v10 + 88);
    v25 = *(_DWORD *)(v10 + 136);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 152)), a2);
    v19 = v25;
    v15 = v27;
    v13 = v26;
  }
  v21 = (double *)(a3 + 16 * v20);
  if (v19 != 5)
    v21 = (double *)((char *)a2 + 64 * v20);
  v22 = (double *)(a3 + 16 * v18);
  if (v17 != 5)
    v22 = (double *)((char *)a2 + 64 * v18);
  v23 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v23 = (double *)((char *)a2 + 64 * v16);
  *(double *)&v24 = v11(a4 + 80 * v12, a4 + 80 * v13, a4 + 80 * v14, *v23, *v22, *v21);
  *(_OWORD *)(a3 + 16 * a7) = v24;
}

double cikernel::_distanceColored(float *a1, double a2, float32x2_t a3)
{
  float32x2_t *DC;
  int32x2_t v6;
  float32x2_t v7;
  float v8;
  float v9;
  double result;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v6 = (int32x2_t)*DC;
  v7 = vsub_f32(a3, *(float32x2_t *)&a2);
  v8 = vmlas_n_f32(vmuls_lane_f32(v7.f32[1], v7, 1), v7.f32[0], v7.f32[0]);
  *(float *)v6.i32 = fabsf(vmlas_n_f32(vmuls_lane_f32(-(float)(*(float *)&a2- (float)(a1[6] + vmlas_n_f32(vmuls_lane_f32(a1[5], *DC, 1), a1[4], COERCE_FLOAT(*DC)))), v7, 1), *((float *)&a2 + 1)- (float)(a1[9] + vmlas_n_f32(vmuls_lane_f32(a1[8], *DC, 1), a1[7], COERCE_FLOAT(*DC))), v7.f32[0])/ v8);
  v9 = sqrtf(v8);
  *(float *)v6.i32 = (float)((float)(v9 * *(float *)v6.i32) / a1[19]) + (float)((float)(v9 * *(float *)v6.i32) / a1[19]);
  *(_QWORD *)&result = vdupq_lane_s32(v6, 0).u64[0];
  return result;
}

void CI::f4_sr_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, double, double);
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  double *v18;
  double *v19;
  __int128 v20;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, double, double))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_DWORD *)(v11 + 40);
  v15 = *(_QWORD *)(v11 + 32);
  v16 = *(_DWORD *)(v11 + 64);
  v17 = *(_QWORD *)(v11 + 56);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 80)), a2);
  v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (double *)((char *)a2 + 64 * v17);
  v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (double *)((char *)a2 + 64 * v15);
  *(double *)&v20 = v12(a4 + 80 * v13, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_alphaNormalize(float32x4_t a1)
{
  double result;

  *(_QWORD *)&result = vdivq_f32(a1, (float32x4_t)vdupq_laneq_s32((int32x4_t)a1, 3)).u64[0];
  return result;
}

uint64_t getAVDepthDataClass()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  void (*v7)(uint64_t);
  uint64_t v8;

  v3 = 0;
  v4 = &v3;
  v5 = 0x3052000000;
  v6 = __Block_byref_object_copy__3;
  v7 = __Block_byref_object_dispose__3;
  v0 = getAVDepthDataClass_softClass;
  v8 = getAVDepthDataClass_softClass;
  if (!getAVDepthDataClass_softClass)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = __getAVDepthDataClass_block_invoke;
    v2[3] = &unk_1E2EC2EB8;
    v2[4] = &v3;
    __getAVDepthDataClass_block_invoke((uint64_t)v2);
    v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_192265558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getAVCameraCalibrationDataClass()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  void (*v7)(uint64_t);
  uint64_t v8;

  v3 = 0;
  v4 = &v3;
  v5 = 0x3052000000;
  v6 = __Block_byref_object_copy__3;
  v7 = __Block_byref_object_dispose__3;
  v0 = getAVCameraCalibrationDataClass_softClass;
  v8 = getAVCameraCalibrationDataClass_softClass;
  if (!getAVCameraCalibrationDataClass_softClass)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = __getAVCameraCalibrationDataClass_block_invoke;
    v2[3] = &unk_1E2EC2EB8;
    v2[4] = &v3;
    __getAVCameraCalibrationDataClass_block_invoke((uint64_t)v2);
    v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_192265620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t AVFDepthDataFromDictionary(const __CFDictionary *a1)
{
  if (a1 && CFDictionaryGetCount(a1))
    return objc_msgSend((id)getAVDepthDataClass(), "depthDataFromDictionaryRepresentation:error:", a1, 0);
  else
    return 0;
}

void *AVFDepthDataType(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "depthDataType");
  return a1;
}

void *AVFDepthDataByConvertingToDepthDataType(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "depthDataByConvertingToDepthDataType:", a2);
  return a1;
}

void *AVFDepthDataByReplacingDepthDataMapWithPixelBuffer(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "depthDataByReplacingDepthDataMapWithPixelBuffer:error:", a2, 0);
  return a1;
}

void *AVFDepthDataMap(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "depthDataMap");
  return a1;
}

void *AVFDepthDataDictionaryRepresentation(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "dictionaryRepresentationForAuxiliaryDataType:", a2);
  return a1;
}

void *AVFDepthCameraCalibrationData(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "cameraCalibrationData");
  return a1;
}

uint64_t AVFDepthCameraCalibrationDataInitWithDictionary(uint64_t a1)
{
  SEL v2;
  id v3;

  if (a1
    && (v2 = NSSelectorFromString(CFSTR("initWithCameraCalibrationDataDictionary:error:")),
        (v3 = objc_alloc((Class)getAVCameraCalibrationDataClass())) != 0))
  {
    return objc_msgSend(v3, "performSelector:withObject:withObject:", v2, a1, 0);
  }
  else
  {
    return 0;
  }
}

double AVCameraCalibrationDataIntrinsicMatrix(void *a1)
{
  double result;

  if (!a1)
    return 0.0;
  objc_msgSend(a1, "intrinsicMatrix");
  return result;
}

double AVCameraCalibrationDataExtrinsicMatrix(void *a1)
{
  double result;

  if (!a1)
    return 0.0;
  objc_msgSend(a1, "extrinsicMatrix");
  return result;
}

float AVCameraCalibrationDataPixelSize(void *a1, const char *a2)
{
  float result;

  if (!a1)
    return 0.0;
  objc_msgSend(a1, "pixelSize");
  return result;
}

double AVCameraCalibrationDataIntrinsicMatrixReferenceDimensions(void *a1)
{
  double result;

  if (!a1)
    return 0.0;
  objc_msgSend(a1, "intrinsicMatrixReferenceDimensions");
  return result;
}

void *AVCameraCalibrationDataLensDistortionLookupTable(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "lensDistortionLookupTable");
  return a1;
}

void *AVCameraCalibrationDataInverseLensDistortionLookupTable(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "inverseLensDistortionLookupTable");
  return a1;
}

double AVCameraCalibrationDataIntrinsicLensDistortionCenter(void *a1)
{
  double result;

  if (!a1)
    return *MEMORY[0x1E0C9D538];
  objc_msgSend(a1, "lensDistortionCenter");
  return result;
}

uint64_t AVCameraCalibrationDataDictionary(void *a1)
{
  if (a1)
    return objc_msgSend(a1, "cameraCalibrationDataDictionary");
  else
    return MEMORY[0x1E0C9AA70];
}

uint64_t getAVPortraitEffectsMatteClass()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  void (*v7)(uint64_t);
  uint64_t v8;

  v3 = 0;
  v4 = &v3;
  v5 = 0x3052000000;
  v6 = __Block_byref_object_copy__3;
  v7 = __Block_byref_object_dispose__3;
  v0 = getAVPortraitEffectsMatteClass_softClass;
  v8 = getAVPortraitEffectsMatteClass_softClass;
  if (!getAVPortraitEffectsMatteClass_softClass)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = __getAVPortraitEffectsMatteClass_block_invoke;
    v2[3] = &unk_1E2EC2EB8;
    v2[4] = &v3;
    __getAVPortraitEffectsMatteClass_block_invoke((uint64_t)v2);
    v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1922658B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *AVFPortraitEffectsMatteImage(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "mattingImage");
  return a1;
}

uint64_t AVPortraitEffectsMatteFromDictionary(const __CFDictionary *a1)
{
  if (a1 && CFDictionaryGetCount(a1))
    return objc_msgSend((id)getAVPortraitEffectsMatteClass(), "portraitEffectsMatteFromDictionaryRepresentation:error:", a1, 0);
  else
    return 0;
}

void *AVPortraitEffectsMatteDictionaryRepresentation(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "dictionaryRepresentationForAuxiliaryDataType:", a2);
  return a1;
}

uint64_t getAVSemanticSegmentationMatteClass()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  void (*v7)(uint64_t);
  uint64_t v8;

  v3 = 0;
  v4 = &v3;
  v5 = 0x3052000000;
  v6 = __Block_byref_object_copy__3;
  v7 = __Block_byref_object_dispose__3;
  v0 = getAVSemanticSegmentationMatteClass_softClass;
  v8 = getAVSemanticSegmentationMatteClass_softClass;
  if (!getAVSemanticSegmentationMatteClass_softClass)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = __getAVSemanticSegmentationMatteClass_block_invoke;
    v2[3] = &unk_1E2EC2EB8;
    v2[4] = &v3;
    __getAVSemanticSegmentationMatteClass_block_invoke((uint64_t)v2);
    v0 = v4[5];
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1922659E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *AVSemanticSegmentationMatteImage(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "mattingImage");
  return a1;
}

uint64_t AVSemanticSegmentationMatteFromDictionary(const __CFDictionary *a1, uint64_t a2)
{
  if (a1 && CFDictionaryGetCount(a1))
    return objc_msgSend((id)getAVSemanticSegmentationMatteClass(), "semanticSegmentationMatteFromImageSourceAuxiliaryDataType:dictionaryRepresentation:error:", a2, a1, 0);
  else
    return 0;
}

void *AVSemanticSegmentationMatteDictionaryRepresentationForAuxiliaryType(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "dictionaryRepresentationForAuxiliaryDataType:", a2);
  return a1;
}

void *AVSemanticSegmentationMatteType(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "matteType");
  return a1;
}

void *AVSemanticSegmentationMatteDataType(void *a1, const char *a2)
{
  if (a1)
    return (void *)objc_msgSend(a1, "pixelFormatType");
  return a1;
}

void __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

Class __getAVDepthDataClass_block_invoke(uint64_t a1)
{
  Class result;

  AVFoundationLibrary();
  result = objc_getClass("AVDepthData");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getAVDepthDataClass_block_invoke_cold_1();
  getAVDepthDataClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

void AVFoundationLibrary()
{
  void *v0;
  __int128 v1;
  uint64_t v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v0 = 0;
  if (!AVFoundationLibraryCore_frameworkLibrary)
  {
    v1 = xmmword_1E2EC33E8;
    v2 = 0;
    AVFoundationLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  if (!AVFoundationLibraryCore_frameworkLibrary)
    AVFoundationLibrary_cold_1(&v0);
}

Class __getAVCameraCalibrationDataClass_block_invoke(uint64_t a1)
{
  Class result;

  AVFoundationLibrary();
  result = objc_getClass("AVCameraCalibrationData");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getAVCameraCalibrationDataClass_block_invoke_cold_1();
  getAVCameraCalibrationDataClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getAVPortraitEffectsMatteClass_block_invoke(uint64_t a1)
{
  Class result;

  AVFoundationLibrary();
  result = objc_getClass("AVPortraitEffectsMatte");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getAVPortraitEffectsMatteClass_block_invoke_cold_1();
  getAVPortraitEffectsMatteClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getAVSemanticSegmentationMatteClass_block_invoke(uint64_t a1)
{
  Class result;

  AVFoundationLibrary();
  result = objc_getClass("AVSemanticSegmentationMatte");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getAVSemanticSegmentationMatteClass_block_invoke_cold_1();
  getAVSemanticSegmentationMatteClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t *loadACBS()
{
  if (loadACBS::onceToken != -1)
    dispatch_once(&loadACBS::onceToken, &__block_literal_global_16);
  if (loadACBS::ACBSLoaded)
    return &loadACBS::ACBSFuncs;
  else
    return 0;
}

void __loadACBS_block_invoke()
{
  if (!QuaggaLibraryCore(char **)::frameworkLibrary)
    QuaggaLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  if (QuaggaLibraryCore(char **)::frameworkLibrary)
  {
    loadACBS::ACBSFuncs = (uint64_t)soft_ACBSConfigCreate;
    *(_QWORD *)algn_1EE281918 = soft_ACBSConfigFree;
    qword_1EE281920 = (uint64_t)soft_ACBSConfigSetMaxQRModuleSamples;
    unk_1EE281928 = soft_ACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBuffer;
    qword_1EE281930 = (uint64_t)soft_ACBSConfigSetSymbologiesEnabled;
    unk_1EE281938 = soft_ACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncoding;
    loadACBS::ACBSLoaded = 1;
  }
  else
  {
    fwrite("Unable to load Quagga.framework\n", 0x20uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
  }
}

uint64_t soft_ACBSConfigCreate(void)
{
  void *v0;
  void *v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  void *v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = getACBSConfigCreateSymbolLoc(void)::ptr;
  v7 = getACBSConfigCreateSymbolLoc(void)::ptr;
  if (!getACBSConfigCreateSymbolLoc(void)::ptr)
  {
    v1 = (void *)QuaggaLibrary();
    v0 = dlsym(v1, "ACBSConfigCreate");
    v5[3] = (uint64_t)v0;
    getACBSConfigCreateSymbolLoc(void)::ptr = v0;
  }
  _Block_object_dispose(&v4, 8);
  if (!v0)
    soft_ACBSConfigCreate();
  return ((uint64_t (*)(uint64_t))v0)(v2);
}

void sub_192266090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_ACBSConfigFree(uint64_t a1)
{
  void *v2;
  void *v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  void *v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v2 = getACBSConfigFreeSymbolLoc(void)::ptr;
  v8 = getACBSConfigFreeSymbolLoc(void)::ptr;
  if (!getACBSConfigFreeSymbolLoc(void)::ptr)
  {
    v3 = (void *)QuaggaLibrary();
    v2 = dlsym(v3, "ACBSConfigFree");
    v6[3] = (uint64_t)v2;
    getACBSConfigFreeSymbolLoc(void)::ptr = v2;
  }
  _Block_object_dispose(&v5, 8);
  if (!v2)
    soft_ACBSConfigFree();
  return ((uint64_t (*)(uint64_t))v2)(a1);
}

void sub_192266138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_ACBSConfigSetMaxQRModuleSamples(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  void *v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v4 = getACBSConfigSetMaxQRModuleSamplesSymbolLoc(void)::ptr;
  v10 = getACBSConfigSetMaxQRModuleSamplesSymbolLoc(void)::ptr;
  if (!getACBSConfigSetMaxQRModuleSamplesSymbolLoc(void)::ptr)
  {
    v5 = (void *)QuaggaLibrary();
    v4 = dlsym(v5, "ACBSConfigSetMaxQRModuleSamples");
    v8[3] = (uint64_t)v4;
    getACBSConfigSetMaxQRModuleSamplesSymbolLoc(void)::ptr = v4;
  }
  _Block_object_dispose(&v7, 8);
  if (!v4)
    soft_ACBSConfigSetMaxQRModuleSamples();
  return ((uint64_t (*)(uint64_t, uint64_t))v4)(a1, a2);
}

void sub_1922661E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_ACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBuffer(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  void *v14;
  void *v15;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  void *v20;

  v17 = 0;
  v18 = &v17;
  v19 = 0x2020000000;
  v14 = getACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBufferSymbolLoc(void)::ptr;
  v20 = getACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBufferSymbolLoc(void)::ptr;
  if (!getACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBufferSymbolLoc(void)::ptr)
  {
    v15 = (void *)QuaggaLibrary();
    v14 = dlsym(v15, "ACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBuffer");
    v18[3] = (uint64_t)v14;
    getACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBufferSymbolLoc(void)::ptr = v14;
  }
  _Block_object_dispose(&v17, 8);
  if (!v14)
    soft_ACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBuffer();
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, double, double, double, double))v14)(a1, a2, a3, a4, a5, a6, a7);
}

void sub_1922662D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_ACBSConfigSetSymbologiesEnabled(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  void *v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v4 = getACBSConfigSetSymbologiesEnabledSymbolLoc(void)::ptr;
  v10 = getACBSConfigSetSymbologiesEnabledSymbolLoc(void)::ptr;
  if (!getACBSConfigSetSymbologiesEnabledSymbolLoc(void)::ptr)
  {
    v5 = (void *)QuaggaLibrary();
    v4 = dlsym(v5, "ACBSConfigSetSymbologiesEnabled");
    v8[3] = (uint64_t)v4;
    getACBSConfigSetSymbologiesEnabledSymbolLoc(void)::ptr = v4;
  }
  _Block_object_dispose(&v7, 8);
  if (!v4)
    soft_ACBSConfigSetSymbologiesEnabled();
  return ((uint64_t (*)(uint64_t, uint64_t))v4)(a1, a2);
}

void sub_192266388(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t soft_ACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncoding(const __CFDictionary *a1, const __CFString *a2)
{
  void *v4;
  void *v5;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  void *v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v4 = getACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncodingSymbolLoc(void)::ptr;
  v10 = getACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncodingSymbolLoc(void)::ptr;
  if (!getACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncodingSymbolLoc(void)::ptr)
  {
    v5 = (void *)QuaggaLibrary();
    v4 = dlsym(v5, "ACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncoding");
    v8[3] = (uint64_t)v4;
    getACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncodingSymbolLoc(void)::ptr = v4;
  }
  _Block_object_dispose(&v7, 8);
  if (!v4)
    soft_ACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncoding();
  return ((uint64_t (*)(const __CFDictionary *, const __CFString *))v4)(a1, a2);
}

void sub_192266438(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t QuaggaLibrary(void)
{
  void *v1;
  __int128 v2;
  uint64_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v1 = 0;
  if (!QuaggaLibraryCore(char **)::frameworkLibrary)
  {
    v2 = xmmword_1E2EC3568;
    v3 = 0;
    QuaggaLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  if (!QuaggaLibraryCore(char **)::frameworkLibrary)
    QuaggaLibrary(&v1);
  return QuaggaLibraryCore(char **)::frameworkLibrary;
}

double convolutionAddROI(int a1, CGRect a2, NSArray *a3)
{
  double height;
  double width;
  double y;
  double x;
  double v7;
  double v8;
  double v9;
  CGRect v11;

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  if (!a1)
  {
    v11.origin.x = a2.origin.x + boundsForPointArray(a3);
    v11.origin.y = y + v7;
    v11.size.width = width + v8;
    v11.size.height = height + v9;
    *(_QWORD *)&x = (unint64_t)CGRectIntegral(v11);
  }
  return x;
}

id makeRecipe(float a1, float a2, float a3, float a4, float a5)
{
  uint64_t v5;
  id v10;
  uint64_t v11;
  double v12;
  double v13;
  float v14;
  unsigned int v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  CIVector *v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  CIVector *v42;
  float v43;
  int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v48;
  double v49;
  double v50;
  double v51;
  int v52;
  int v53;
  int v54;
  BOOL v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  double v63;
  int v64;
  int v65;
  uint64_t v66;
  int v67;
  double v68;
  double v69;
  double v70;
  double v71;
  uint64_t v72;
  int v73;
  int v74;
  double v75;
  double v76;
  uint64_t v77;
  double v78;
  double v79;
  double v80;
  double v81;
  int v82;
  double v83;
  double v84;
  double v85;
  uint64_t v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  BOOL v92;
  int v93;
  int v94;
  int v95;
  int v96;
  double v97;
  int v98;
  double v99;
  double v100;
  double v101;
  double v102;
  double v103;
  char v104;
  char v105;
  double v106;
  double v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  int v113;
  double v114;
  double v115;
  double v117;
  double v118;
  double v119;
  double v120;
  _BOOL4 v121;
  unsigned int v122;
  int v123;
  int v124;
  int v125;
  unsigned int v126;
  double v127;
  double v128;
  double v129;
  double v130;
  int v131;
  double v132;
  int v133;
  double v134;
  int v135;
  double v136;
  double v137;
  int v138;
  int v139;
  _QWORD v140[2];
  _QWORD v141[6];
  _QWORD v142[9];
  _QWORD v143[9];
  _QWORD v144[6];
  _QWORD v145[6];
  _QWORD v146[9];
  _QWORD v147[9];
  _QWORD v148[6];
  _QWORD v149[6];
  _QWORD v150[9];
  _QWORD v151[9];
  _QWORD v152[6];
  _QWORD v153[2];
  _BYTE v154[28];
  _QWORD v155[2];
  _BYTE v156[32];
  double v157;
  double v158;
  double v159;
  double v160;
  double v161;
  double v162;
  double v163;
  double v164;
  double v165;
  double v166;
  double v167;
  double v168;
  double v169;
  double v170;
  double v171;
  double v172;
  double v173;
  double v174;
  double v175;
  double v176;
  double v177;
  double v178;
  double v179;
  double v180;
  double v181;
  double v182;
  double v183;
  double v184;
  double v185;
  double v186;
  double v187;
  double v188;
  double v189;
  double v190;
  double v191;
  double v192;
  double v193;
  double v194;
  double v195;
  double v196;
  double v197;
  double v198;
  double v199;
  double v200;
  double v201;
  _QWORD v202[2];
  _QWORD v203[2];
  _QWORD v204[5];

  v204[2] = *MEMORY[0x1E0C80C00];
  v10 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  if (a1 <= 20.0)
  {
    v13 = a4;
    v117 = 1.0;
  }
  else
  {
    LODWORD(v11) = 0;
    v12 = 1.0;
    do
    {
      v12 = v12 + v12;
      a1 = a1 * 0.5;
      v11 = (v11 + 1);
    }
    while (a1 > 20.0);
    v117 = v12;
    v204[0] = CFSTR("down");
    v204[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v11);
    objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v204, 2));
    v13 = 0.0;
  }
  v14 = fabsf(a1);
  v15 = vcvtps_s32_f32(v14);
  switch(v15)
  {
    case 3u:
      v24 = a1;
      v25 = a2;
      v26 = a3;
      v136 = disc_multi(0.0, 0.0, v24, a2, a3, v13);
      v134 = disc_multi(1.0, 0.0, v24, a2, a3, v13);
      v132 = disc_multi(1.0, 1.0, v24, a2, a3, v13);
      v130 = disc_multi(2.0, 0.0, v24, a2, a3, v13);
      v27 = disc_multi(2.0, 1.0, v24, a2, a3, v13);
      v128 = disc_multi(2.0, 2.0, v24, a2, a3, v13);
      v28 = disc_multi(3.0, 0.0, v24, a2, a3, v13);
      v29 = disc_multi(3.0, 1.0, v24, v25, a3, v13);
      v30 = disc_multi(3.0, 2.0, v24, v25, a3, v13);
      v31 = disc_multi(3.0, 3.0, v24, v25, v26, v13);
      v32 = v136 + (v31 + v30 + v29 + v28 + v30 + v128 + v27 + v130 + v134 + v132 + v27 + v29) * 4.0;
      *(double *)v156 = v31;
      *(double *)&v156[8] = v30 / v32;
      *(double *)&v156[16] = v29 / v32;
      *(double *)&v156[24] = v28 / v32;
      v157 = v29 / v32;
      v158 = v30 / v32;
      v159 = v31;
      v160 = v30 / v32;
      v161 = v128 / v32;
      v162 = v27 / v32;
      v163 = v130 / v32;
      v164 = v27 / v32;
      v165 = v128 / v32;
      v166 = v30 / v32;
      v167 = v29 / v32;
      v168 = v27 / v32;
      v169 = v132 / v32;
      v170 = v134 / v32;
      v171 = v132 / v32;
      v172 = v27 / v32;
      v173 = v29 / v32;
      v174 = v28 / v32;
      v175 = v130 / v32;
      v176 = v134 / v32;
      v177 = v136 / v32;
      v178 = v134 / v32;
      v179 = v130 / v32;
      v180 = v28 / v32;
      v181 = v29 / v32;
      v182 = v27 / v32;
      v183 = v132 / v32;
      v184 = v134 / v32;
      v185 = v132 / v32;
      v186 = v27 / v32;
      v187 = v29 / v32;
      v188 = v30 / v32;
      v189 = v128 / v32;
      v190 = v27 / v32;
      v191 = v130 / v32;
      v192 = v27 / v32;
      v193 = v128 / v32;
      v194 = v30 / v32;
      v195 = v31;
      v196 = v30 / v32;
      v197 = v29 / v32;
      v198 = v28 / v32;
      v199 = v29 / v32;
      v200 = v30 / v32;
      v201 = v31;
      v155[0] = CFSTR("conv7");
      v155[1] = +[CIVector vectorWithValues:count:](CIVector, "vectorWithValues:count:", v156, 49);
      objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v155, 2));
      return v10;
    case 2u:
      v33 = a1;
      v34 = a2;
      v35 = a3;
      v137 = disc_multi(0.0, 0.0, v33, v34, v35, v13);
      v36 = disc_multi(1.0, 0.0, v33, v34, v35, v13);
      v37 = disc_multi(1.0, 1.0, v33, v34, v35, v13);
      v38 = disc_multi(2.0, 0.0, v33, v34, v35, v13);
      v39 = disc_multi(2.0, 1.0, v33, v34, v35, v13);
      v40 = disc_multi(2.0, 2.0, v33, v34, v35, v13);
      v41 = v137 + (v40 + v39 + v38 + v36 + v37 + v39) * 4.0;
      *(double *)v156 = v40 / v41;
      *(double *)&v156[8] = v39 / v41;
      *(double *)&v156[16] = v38 / v41;
      *(double *)&v156[24] = v39 / v41;
      v157 = v40 / v41;
      v158 = v39 / v41;
      v159 = v37 / v41;
      v160 = v36 / v41;
      v161 = v37 / v41;
      v162 = v39 / v41;
      v163 = v38 / v41;
      v164 = v36 / v41;
      v165 = v137 / v41;
      v166 = v36 / v41;
      v167 = v38 / v41;
      v168 = v39 / v41;
      v169 = v37 / v41;
      v170 = v36 / v41;
      v171 = v37 / v41;
      v172 = v39 / v41;
      v173 = v40 / v41;
      v174 = v39 / v41;
      v175 = v38 / v41;
      v176 = v39 / v41;
      v177 = v40 / v41;
      v42 = +[CIVector vectorWithValues:count:](CIVector, "vectorWithValues:count:", v156, 25);
      v202[0] = CFSTR("conv5");
      v202[1] = v42;
      objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v202, 2));
      return v10;
    case 1u:
      v16 = a1;
      v17 = a2;
      v18 = a3;
      v19 = disc_multi(0.0, 0.0, a1, v17, v18, v13);
      v20 = disc_multi(1.0, 0.0, v16, v17, v18, v13);
      v21 = disc_multi(1.0, 1.0, v16, v17, v18, v13);
      v22 = v19 + (v20 + v21) * 4.0;
      *(double *)v156 = v21 / v22;
      *(double *)&v156[8] = v20 / v22;
      *(double *)&v156[16] = v21 / v22;
      *(double *)&v156[24] = v20 / v22;
      v157 = v19 / v22;
      v158 = v20 / v22;
      v159 = v21 / v22;
      v160 = v20 / v22;
      v161 = v21 / v22;
      v23 = +[CIVector vectorWithValues:count:](CIVector, "vectorWithValues:count:", v156, 9);
      v203[0] = CFSTR("conv3");
      v203[1] = v23;
      objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v203, 2));
      return v10;
  }
  v43 = ceilf(v14);
  *(_OWORD *)v156 = xmmword_192493E68;
  *(_OWORD *)&v156[12] = *(__int128 *)((char *)&xmmword_192493E68 + 12);
  v44 = 1;
  *(_OWORD *)v154 = xmmword_192493E68;
  *(_OWORD *)&v154[12] = *(__int128 *)((char *)&xmmword_192493E68 + 12);
  v45 = 4;
  v46 = 1;
  do
  {
    v46 *= 9;
    *(_DWORD *)&v156[v45] = v46;
    v44 *= 3;
    *(_DWORD *)&v154[v45] = v44;
    v45 += 4;
  }
  while (v45 != 28);
  v47 = operator new();
  v48 = (int)(float)(v43 + 2.0);
  *(_DWORD *)(v47 + 16) = v48;
  *(_QWORD *)(v47 + 8) = malloc_type_calloc(v48 + v48 * v48, 4uLL, 0x100004052888210uLL);
  v49 = a1;
  v50 = a2;
  v51 = a3;
  v52 = disc25(0.0, 0.0, v49, v50, v51, v13);
  *(_DWORD *)v47 = v52;
  if (v48 < 1)
  {
    v56 = v52;
  }
  else
  {
    LODWORD(v5) = 1;
    do
    {
      v53 = 0;
      do
      {
        v54 = disc25((double)v53, (double)(int)v5, v49, v50, v51, v13);
        ConvMap::setValue(v47, v54, v53++, v5);
      }
      while (v48 + 1 != v53);
      v55 = (_DWORD)v5 == v48;
      v5 = (v5 + 1);
    }
    while (!v55);
    v56 = *(_DWORD *)v47;
  }
  v57 = 0;
  v58 = v48 & ~(v48 >> 31);
  v135 = (int)(float)(v43 + 2.0);
  while (v58 != v57)
  {
    v59 = 0;
    v60 = *(_DWORD *)(v47 + 16);
    if ((v60 & 0x80000000) == 0 && v57 < v60)
      v59 = *(_DWORD *)(*(_QWORD *)(v47 + 8) + 4 * (v57 + v57 * v60));
    ++v57;
    if (v56 > v59)
    {
      v58 = v57 - 1;
      break;
    }
  }
  LODWORD(v5) = vcvtmd_s64_f64(log2((double)((2 * v58) | 1)) / 1.5849625);
  v61 = *(_DWORD *)&v154[4 * (int)v5];
  v153[0] = CFSTR("box");
  v153[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v5);
  objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v153, 2));
  v62 = *(_DWORD *)&v156[4 * (int)v5];
  ConvMap::subtract((_DWORD *)v47, v56, v61);
  v63 = (double)v62;
  if ((int)v5 >= 1)
  {
    while (1)
    {
      v64 = *(_DWORD *)&v154[4 * v5];
      v65 = v64 >= 0 ? *(_DWORD *)&v154[4 * v5] : v64 + 1;
      v138 = v135 - (v65 >> 1);
      if (v138 >= 0)
        break;
      v76 = v63;
LABEL_56:
      v63 = v76;
      v92 = v5-- <= 1;
      if (v92)
        goto LABEL_60;
    }
    v66 = 0;
    v67 = 0;
    v68 = 0.0;
    v69 = 0.0;
    v70 = 0.0;
    v71 = 0.0;
    while ((v66 & 0x80000000) != 0)
    {
      v76 = v63;
      v75 = v68;
LABEL_53:
      v66 = (v66 + v64);
      v68 = v75;
      v63 = v76;
      if ((int)v66 > v138)
        goto LABEL_56;
    }
    v72 = 0;
    while (1)
    {
      v73 = ConvMap::bestValue((ConvMap *)v47, v72, v66, v64);
      if (!v73)
        break;
      v74 = v73;
      v75 = (double)v73 / 25.0 * (double)*(int *)&v156[4 * v5];
      if ((_DWORD)v72 && (_DWORD)v66 != (_DWORD)v72)
      {
        v76 = v63 + v75 * 8.0;
        if (v67 == 4)
        {
          objc_msgSend(v10, "removeLastObject");
          v150[0] = CFSTR("add4and8");
          v150[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v5);
          v150[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v71);
          v150[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v70);
          v150[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v72);
          v150[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v66);
          v150[6] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v69 / v76);
          v150[7] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v68 / v76);
          v150[8] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v75 / v76);
          objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v150, 9));
LABEL_46:
          v67 = 0;
        }
        else
        {
          if (v67 == 8)
          {
            objc_msgSend(v10, "removeLastObject");
            v151[0] = CFSTR("add8and8");
            v151[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v5);
            v151[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v71);
            v151[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v70);
            v151[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v72);
            v151[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v66);
            v151[6] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v69 / v76);
            v151[7] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v68 / v76);
            v151[8] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v75 / v76);
            objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v151, 9));
            goto LABEL_46;
          }
          v149[0] = CFSTR("add8");
          v149[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v5);
          v149[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v72);
          v149[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v66);
          v149[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v63 / v76);
          v149[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v75 / v76);
          objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v149, 6));
          v71 = (double)(int)v72;
          v67 = 8;
          v70 = (double)(int)v66;
          v69 = v63;
          v68 = v75;
        }
        ConvMap::subtract(v47, v74, v72, v66, v64);
        ConvMap::subtract(v47, v74, v66, v72, v64);
LABEL_49:
        v63 = v69;
        v75 = v68;
        goto LABEL_50;
      }
      v152[0] = CFSTR("add4");
      v152[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v5);
      v152[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v72);
      v76 = v63 + v75 * 4.0;
      v152[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v66);
      v152[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v63 / v76);
      v152[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v75 / v76);
      objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v152, 6));
      ConvMap::subtract(v47, v74, v72, v66, v64);
      v71 = (double)(int)v72;
      v67 = 4;
      v70 = (double)(int)v66;
LABEL_50:
      v72 = (v72 + v64);
      v69 = v63;
      v68 = v75;
      v63 = v76;
      if ((int)v72 > (int)v66)
        goto LABEL_53;
    }
    v76 = v63;
    goto LABEL_49;
  }
  v76 = (double)v62;
LABEL_60:
  if (v135 < 0)
    goto LABEL_134;
  v77 = 0;
  v131 = 0;
  v133 = -1;
  v78 = 0.0;
  v79 = 0.0;
  v80 = 0.0;
  v81 = 0.0;
  v129 = 0.0;
  do
  {
    v127 = v78;
    v82 = 0;
    v118 = v78 + 1.0;
    v121 = v77 != 0;
    v122 = v77 + 1;
    if ((_DWORD)v77)
      v83 = 2.0;
    else
      v83 = 1.5;
    v84 = 0.666666667;
    if ((_DWORD)v77)
      v84 = 0.5;
    v119 = v83;
    v120 = v84;
    v126 = v77;
    do
    {
      v85 = v76;
      v86 = (v77 + v82);
      v87 = ConvMap::value((ConvMap *)v47, v77, (int)v77 + v82);
      if (!v87)
        goto LABEL_117;
      v88 = v87;
      if (!v82)
        goto LABEL_115;
      v89 = ConvMap::value((ConvMap *)v47, v77, (int)v77 + v82 + 1);
      v90 = ConvMap::value((ConvMap *)v47, v122, v86);
      v123 = v77 + v82 + 1;
      v91 = ConvMap::value((ConvMap *)v47, v122, v123);
      if ((_DWORD)v86)
        v92 = v89 * v88 <= 0;
      else
        v92 = 1;
      v93 = !v92;
      if (v90 == v88)
        v94 = v93;
      else
        v94 = 0;
      v139 = v89;
      if (v91 == v89)
        v95 = v94;
      else
        v95 = 0;
      if ((v95 & 1) != 0)
      {
        v96 = 1;
        v97 = v119;
LABEL_88:
        v98 = 1;
        v77 = v126;
        goto LABEL_89;
      }
      v97 = 1.0;
      if ((v93 & 1) != 0)
      {
        v96 = 0;
        goto LABEL_88;
      }
      v77 = v126;
      if (!v126 || v90 * v88 < 1)
        goto LABEL_124;
      v98 = 0;
      v96 = 1;
      v139 = v90;
LABEL_89:
      v99 = (double)v139 / 25.0;
      v100 = (double)v88 / 25.0 + v99;
      v101 = v99 / v100;
      if (v96)
        v102 = v101;
      else
        v102 = 0.0;
      if (v98)
        v103 = v101;
      else
        v103 = 0.0;
      v124 = v98;
      v125 = v96;
      v104 = v96 | v98;
      if ((_DWORD)v77)
        v105 = 0;
      else
        v105 = v95;
      v106 = v97 * v100;
      if (v95)
        v107 = v120;
      else
        v107 = v102;
      if (((v95 | v121) & 1) == 0)
      {
        v148[0] = CFSTR("add4");
        v148[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", 0);
        v129 = v107 + 0.0;
        v148[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:");
        v81 = v103 + (double)(int)v86;
        v76 = v76 + v106 * 4.0;
        v148[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v81);
        v148[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v85 / v76);
        v148[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v106 / v76);
        objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v148, 6));
        ConvMap::subtract(v47, v88, 0, v86);
        ConvMap::subtract(v47, v139, v125, v77 + v124 + v82);
        if ((v104 & 1) != 0)
        {
          v131 = 4;
          v80 = v85;
          v79 = v106;
          goto LABEL_117;
        }
        goto LABEL_115;
      }
      v76 = v76 + v106 * 8.0;
      if (v131 == 4)
      {
        objc_msgSend(v10, "removeLastObject");
        v146[0] = CFSTR("add4and8");
        v146[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", 0);
        v146[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v129);
        v146[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v81);
        v146[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v107 + v127);
        v146[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v103 + (double)(int)v86);
        v146[6] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v80 / v76);
        v146[7] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v79 / v76);
        v146[8] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v106 / v76);
        v108 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v146, 9);
        goto LABEL_111;
      }
      if (v131 == 8)
      {
        objc_msgSend(v10, "removeLastObject");
        v147[0] = CFSTR("add8and8");
        v147[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", 0);
        v147[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v129);
        v147[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v81);
        v147[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v107 + v127);
        v147[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v103 + (double)(int)v86);
        v147[6] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v80 / v76);
        v147[7] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v79 / v76);
        v147[8] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v106 / v76);
        v108 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v147, 9);
LABEL_111:
        v109 = v108;
        v131 = 0;
        goto LABEL_113;
      }
      v145[0] = CFSTR("add8");
      v145[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", 0);
      v129 = v107 + v127;
      v145[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:");
      v81 = v103 + (double)(int)v86;
      v145[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v81);
      v145[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v85 / v76);
      v145[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v106 / v76);
      v109 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v145, 6);
      v131 = 8;
      v80 = v85;
      v79 = v106;
LABEL_113:
      objc_msgSend(v10, "addObject:", v109);
      if ((v105 & 1) != 0)
      {
        ConvMap::subtract(v47, v88, -1, v86);
        ConvMap::subtract(v47, v88, 0, v86);
        ConvMap::subtract(v47, v88, 1, v86);
        ConvMap::subtract(v47, v139, -1, v123);
        ConvMap::subtract(v47, v139, 0, v123);
        v77 = v126;
        ConvMap::subtract(v47, v139, 1, v123);
        if ((v104 & 1) != 0)
          goto LABEL_117;
LABEL_115:
        v79 = (double)v88 / 25.0;
LABEL_116:
        v80 = v76;
        v144[0] = CFSTR("add4");
        v144[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", 0);
        v144[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v77);
        v76 = v76 + v79 * 4.0;
        v144[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v86);
        v144[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v80 / v76);
        v144[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v79 / v76);
        objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v144, 6));
        ConvMap::subtract(v47, v88, v77, v86, 1);
        v81 = (double)(int)v86;
        v131 = 4;
        v129 = v127;
        goto LABEL_117;
      }
      ConvMap::subtract(v47, v88, v77, v86);
      ConvMap::subtract(v47, v88, v86, v77);
      if (v95)
      {
        ConvMap::subtract(v47, v88, v122, v86);
        ConvMap::subtract(v47, v88, v86, v122);
        ConvMap::subtract(v47, v139, v77, v123);
        ConvMap::subtract(v47, v139, v123, v126);
        ConvMap::subtract(v47, v139, v122, v123);
        v110 = v47;
        v111 = v139;
        v112 = v123;
        v77 = v126;
        v113 = v122;
      }
      else
      {
        ConvMap::subtract(v47, v139, v125 + v77, v77 + v124 + v82);
        v110 = v47;
        v111 = v139;
        v112 = v77 + v124 + v82;
        v113 = v125 + v77;
      }
      ConvMap::subtract(v110, v111, v112, v113);
      if ((v104 & 1) == 0)
      {
LABEL_124:
        v114 = (double)v88 / 25.0;
        if (!(_DWORD)v77)
        {
          v79 = (double)v88 / 25.0;
          goto LABEL_116;
        }
        v115 = v76 + v114 * 8.0;
        if (v131 == 4)
        {
          objc_msgSend(v10, "removeLastObject");
          v142[0] = CFSTR("add4and8");
          v142[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", 0);
          v142[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v129);
          v142[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v81);
          v142[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v77);
          v142[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v86);
          v142[6] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v80 / v115);
          v142[7] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v79 / v115);
          v142[8] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v114 / v115);
          objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v142, 9));
LABEL_130:
          v131 = 0;
        }
        else
        {
          if (v131 == 8)
          {
            objc_msgSend(v10, "removeLastObject");
            v143[0] = CFSTR("add8and8");
            v143[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", 0);
            v143[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v129);
            v143[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v81);
            v143[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v77);
            v143[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v86);
            v143[6] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v80 / v115);
            v143[7] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v79 / v115);
            v143[8] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v114 / v115);
            objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v143, 9));
            goto LABEL_130;
          }
          v141[0] = CFSTR("add8");
          v141[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", 0);
          v141[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v77);
          v141[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v86);
          v141[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v76 / v115);
          v141[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v114 / v115);
          objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v141, 6));
          v81 = (double)(int)v86;
          v131 = 8;
          v129 = v127;
          v80 = v76;
          v79 = (double)v88 / 25.0;
        }
        ConvMap::subtract(v47, v88, v77, v86, 1);
        ConvMap::subtract(v47, v88, v86, v77, 1);
        v76 = v76 + v114 * 8.0;
      }
LABEL_117:
      ++v82;
    }
    while (v133 + v82 < v135);
    ++v133;
    v78 = v118;
    v92 = (int)v77 < v135;
    v77 = v122;
  }
  while (v92);
LABEL_134:
  if (v117 > 1.0)
  {
    v140[0] = CFSTR("up");
    v140[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v117);
    objc_msgSend(v10, "addObject:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v140, 2));
  }
  free(*(void **)(v47 + 8));
  *(_QWORD *)(v47 + 8) = 0;
  *(_DWORD *)v47 = 0;
  *(_DWORD *)(v47 + 16) = 0;
  MEMORY[0x194025AAC](v47, 0x1010C400FFEF802);
  return v10;
}

void sub_192269408(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x1010C400FFEF802);
  _Unwind_Resume(a1);
}

CIImage *applyRecipe(NSArray *a1, CIImage *a2)
{
  void (***v3)(CI::GeneralKernel *__hidden);
  uint64_t v4;
  uint64_t v5;
  void (***v6)(CI::GeneralKernel *__hidden);
  void *v7;
  void *v8;
  int v9;
  CIKernel *v10;
  double x;
  double y;
  double width;
  double height;
  uint64_t v15;
  CIKernel *v16;
  uint64_t v17;
  CIImage *v18;
  const __CFString *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  CIImage *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  CIKernel *v28;
  double v29;
  double v30;
  double v31;
  double v32;
  int v33;
  float v34;
  float v35;
  float v36;
  float v37;
  double v38;
  double v39;
  float v40;
  void *v41;
  CIKernel *v42;
  double v43;
  CGFloat v44;
  double v45;
  CGFloat v46;
  double v47;
  CGFloat v48;
  double v49;
  CGFloat v50;
  CGFloat v51;
  CGFloat v52;
  CGFloat v53;
  double v54;
  uint64_t v55;
  _QWORD *v56;
  CIKernel *v57;
  double v58;
  double v59;
  int v60;
  float v61;
  float v62;
  float v63;
  float v64;
  double v65;
  double v66;
  float v67;
  void *v68;
  CIKernel *v69;
  double v70;
  CGFloat v71;
  double v72;
  CGFloat v73;
  double v74;
  CGFloat v75;
  double v76;
  CGFloat v77;
  CGFloat v78;
  CGFloat v79;
  double v80;
  int v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  double v88;
  double v89;
  double v90;
  float v91;
  void *v92;
  CIKernel *v93;
  double v94;
  CGFloat v95;
  double v96;
  CGFloat v97;
  double v98;
  CGFloat v99;
  double v100;
  CGFloat v101;
  CGFloat v102;
  CGFloat v103;
  CGFloat v104;
  int v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  double v112;
  double v113;
  double v114;
  float v115;
  void *v116;
  double v117;
  CGFloat v118;
  double v119;
  CGFloat v120;
  double v121;
  CGFloat v122;
  double v123;
  CGFloat v124;
  int v125;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  double v132;
  double v133;
  double v134;
  float v135;
  void *v136;
  CIKernel *v137;
  double v138;
  CGFloat v139;
  double v140;
  CGFloat v141;
  double v142;
  CGFloat v143;
  double v144;
  CGFloat v145;
  double v146;
  double v147;
  double v148;
  double v149;
  double v151;
  double v152;
  double v153;
  double v154;
  double v155;
  double v156;
  float v157;
  float v158;
  float v159;
  double v160;
  double v161;
  double v162;
  double v163;
  double v164;
  int v165;
  double v166;
  double v167;
  float v168;
  float v169;
  float v170;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  _QWORD v175[4];
  float v176;
  _QWORD v177[4];
  float v178;
  _QWORD v179[4];
  float v180;
  _QWORD v181[4];
  float v182;
  _QWORD v183[4];
  float v184;
  _QWORD v185[4];
  int v186;
  _QWORD v187[4];
  CGAffineTransform v188;
  CGAffineTransform v189;
  CGAffineTransform v190;
  CGAffineTransform v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  _QWORD v196[4];
  _QWORD v197[4];
  _QWORD v198[4];
  _QWORD v199[4];
  _QWORD v200[4];
  _QWORD v201[2];
  const __CFString *v202;
  uint64_t v203;
  const __CFString *v204;
  uint64_t v205;
  const __CFString *v206;
  uint64_t v207;
  const __CFString *v208;
  uint64_t v209;
  CIImage *v210;
  _BYTE v211[128];
  _OWORD v212[3];
  uint64_t v213;
  uint64_t v214;
  CGRect v215;
  CGRect v216;
  CGRect v217;
  CGRect v218;
  CGRect v219;
  CGRect v220;
  CGRect v221;
  CGRect v222;
  CGRect v223;
  CGRect v224;
  CGRect v225;
  CGRect v226;
  CGRect v227;
  CGRect v228;
  CGRect v229;
  CGRect v230;
  CGRect v231;
  CGRect v232;
  CGRect v233;
  CGRect v234;
  CGRect v235;
  CGRect v236;
  CGRect v237;
  CGRect v238;
  CGRect v239;

  v214 = *MEMORY[0x1E0C80C00];
  v213 = 0;
  memset(v212, 0, sizeof(v212));
  v192 = 0u;
  v193 = 0u;
  v194 = 0u;
  v195 = 0u;
  v173 = -[NSArray countByEnumeratingWithState:objects:count:](a1, "countByEnumeratingWithState:objects:count:", &v192, v211, 16);
  if (v173)
  {
    v172 = *(_QWORD *)v193;
    v3 = &CI::_downhalf;
    v4 = MEMORY[0x1E0C809B0];
    do
    {
      v5 = 0;
      do
      {
        v6 = v3;
        if (*(_QWORD *)v193 != v172)
          objc_enumerationMutation(a1);
        v174 = v5;
        v7 = *(void **)(*((_QWORD *)&v192 + 1) + 8 * v5);
        v8 = (void *)objc_msgSend(v7, "objectAtIndex:", 0);
        if (objc_msgSend(v8, "isEqualToString:", CFSTR("down")))
        {
          v9 = objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 1), "intValue");
          a2 = -[CIImage imageBySamplingLinear](a2, "imageBySamplingLinear");
          if (v9 < 1)
            goto LABEL_39;
          v3 = v6;
          do
          {
            memset(&v191, 0, sizeof(v191));
            CGAffineTransformMakeScale(&v191, 0.5, 0.5);
            memset(&v190, 0, sizeof(v190));
            CGAffineTransformMakeScale(&v190, 2.0, 2.0);
            v10 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", v3);
            -[CIImage extent](a2, "extent");
            v189 = v191;
            v216 = CGRectApplyAffineTransform(v215, &v189);
            v217 = CGRectInset(v216, -1.0, -1.0);
            x = v217.origin.x;
            y = v217.origin.y;
            width = v217.size.width;
            height = v217.size.height;
            v187[0] = v4;
            v187[1] = 3221225472;
            v187[2] = ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke;
            v187[3] = &__block_descriptor_80_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
            v188 = v190;
            v210 = a2;
            v15 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v210, 1);
            v16 = v10;
            v3 = v6;
            a2 = -[CIKernel applyWithExtent:roiCallback:arguments:](v16, "applyWithExtent:roiCallback:arguments:", v187, v15, x, y, width, height);
            --v9;
          }
          while (v9);
        }
        else
        {
          if (objc_msgSend(v8, "isEqualToString:", CFSTR("up")))
          {
            objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 1), "floatValue");
            v208 = CFSTR("inputScale");
            v209 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:");
            v17 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v209, &v208, 1);
            v18 = a2;
            v19 = CFSTR("CISoftCubicUpsample");
LABEL_19:
            v23 = -[CIImage imageByApplyingFilter:withInputParameters:](v18, "imageByApplyingFilter:withInputParameters:", v19, v17);
            goto LABEL_20;
          }
          if (objc_msgSend(v8, "isEqualToString:", CFSTR("conv3")))
          {
            v20 = objc_msgSend(v7, "objectAtIndex:", 1);
            v206 = CFSTR("inputWeights");
            v207 = v20;
            v17 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v207, &v206, 1);
            v18 = a2;
            v19 = CFSTR("CIConvolution3X3");
            goto LABEL_19;
          }
          if (objc_msgSend(v8, "isEqualToString:", CFSTR("conv5")))
          {
            v21 = objc_msgSend(v7, "objectAtIndex:", 1);
            v204 = CFSTR("inputWeights");
            v205 = v21;
            v17 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v205, &v204, 1);
            v18 = a2;
            v19 = CFSTR("CIConvolution5X5");
            goto LABEL_19;
          }
          if (objc_msgSend(v8, "isEqualToString:", CFSTR("conv7")))
          {
            v22 = objc_msgSend(v7, "objectAtIndex:", 1);
            v202 = CFSTR("inputWeights");
            v203 = v22;
            v17 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v203, &v202, 1);
            v18 = a2;
            v19 = CFSTR("CIConvolution7X7");
            goto LABEL_19;
          }
          if (!objc_msgSend(v8, "isEqualToString:", CFSTR("box")))
          {
            if (objc_msgSend(v8, "isEqualToString:", CFSTR("add4")))
            {
              v33 = objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 1), "intValue");
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 2), "floatValue");
              v35 = v34;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 3), "floatValue");
              v37 = v36;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 4), "doubleValue");
              v166 = v38;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 5), "doubleValue");
              v160 = v39;
              v40 = ceilf(fmaxf(v35, v37));
              v41 = (void *)*((_QWORD *)v212 + v33);
              v42 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_add4);
              -[CIImage extent](a2, "extent");
              v44 = v43;
              v46 = v45;
              v48 = v47;
              v50 = v49;
              objc_msgSend(v41, "extent");
              v235 = CGRectInset(v220, (float)-v40, (float)-v40);
              v221.origin.x = v44;
              v221.origin.y = v46;
              v221.size.width = v48;
              v221.size.height = v50;
              v222 = CGRectUnion(v221, v235);
              v51 = v222.origin.x;
              v52 = v222.origin.y;
              v53 = v222.size.width;
              v54 = v222.size.height;
              v183[0] = v4;
              v183[1] = 3221225472;
              v183[2] = ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_3;
              v183[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
              v184 = v40;
              v200[0] = a2;
              v200[1] = v41;
              v200[2] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v35, v37);
              v200[3] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v166, v160);
              v55 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v200, 4);
              v56 = v183;
              v57 = v42;
              v58 = v51;
              v59 = v52;
LABEL_30:
              v80 = v53;
              goto LABEL_31;
            }
            if (objc_msgSend(v8, "isEqualToString:", CFSTR("add8")))
            {
              v60 = objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 1), "intValue");
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 2), "floatValue");
              v62 = v61;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 3), "floatValue");
              v64 = v63;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 4), "doubleValue");
              v167 = v65;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 5), "doubleValue");
              v161 = v66;
              v67 = ceilf(fmaxf(v62, v64));
              v68 = (void *)*((_QWORD *)v212 + v60);
              v69 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_add8);
              -[CIImage extent](a2, "extent");
              v71 = v70;
              v73 = v72;
              v75 = v74;
              v77 = v76;
              objc_msgSend(v68, "extent");
              v236 = CGRectInset(v223, (float)-v67, (float)-v67);
              v224.origin.x = v71;
              v224.origin.y = v73;
              v224.size.width = v75;
              v224.size.height = v77;
              v225 = CGRectUnion(v224, v236);
              v78 = v225.origin.x;
              v79 = v225.origin.y;
              v53 = v225.size.width;
              v54 = v225.size.height;
              v181[0] = v4;
              v181[1] = 3221225472;
              v181[2] = ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_4;
              v181[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
              v182 = v67;
              v199[0] = a2;
              v199[1] = v68;
              v199[2] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v62, v64);
              v199[3] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v167, v161);
              v55 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v199, 4);
              v56 = v181;
              v57 = v69;
              v58 = v78;
              v59 = v79;
              goto LABEL_30;
            }
            if (objc_msgSend(v8, "isEqualToString:", CFSTR("add4and4")))
            {
              v81 = objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 1), "intValue");
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 2), "floatValue");
              v83 = v82;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 3), "floatValue");
              v85 = v84;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 4), "floatValue");
              v168 = v86;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 5), "floatValue");
              v157 = v87;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 6), "doubleValue");
              v162 = v88;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 7), "doubleValue");
              v154 = v89;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 8), "doubleValue");
              v151 = v90;
              v91 = ceilf(fmaxf(v83, v85));
              v92 = (void *)*((_QWORD *)v212 + v81);
              v93 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_add4and4);
              -[CIImage extent](a2, "extent");
              v95 = v94;
              v97 = v96;
              v99 = v98;
              v101 = v100;
              objc_msgSend(v92, "extent");
              v237 = CGRectInset(v226, (float)-v91, (float)-v91);
              v227.origin.x = v95;
              v227.origin.y = v97;
              v227.size.width = v99;
              v227.size.height = v101;
              v228 = CGRectUnion(v227, v237);
              v102 = v228.origin.x;
              v103 = v228.origin.y;
              v104 = v228.size.width;
              v54 = v228.size.height;
              v179[0] = v4;
              v179[1] = 3221225472;
              v179[2] = ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_5;
              v179[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
              v180 = v91;
              v198[0] = a2;
              v198[1] = v92;
              v198[2] = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v83, v85, v168, v157);
              v198[3] = +[CIVector vectorWithX:Y:Z:](CIVector, "vectorWithX:Y:Z:", v162, v154, v151);
              v55 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v198, 4);
              v56 = v179;
              goto LABEL_36;
            }
            if (objc_msgSend(v8, "isEqualToString:", CFSTR("add4and8")))
            {
              v105 = objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 1), "intValue");
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 2), "floatValue");
              v107 = v106;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 3), "floatValue");
              v109 = v108;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 4), "floatValue");
              v169 = v110;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 5), "floatValue");
              v158 = v111;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 6), "doubleValue");
              v163 = v112;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 7), "doubleValue");
              v155 = v113;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 8), "doubleValue");
              v152 = v114;
              v115 = ceilf(fmaxf(v107, v109));
              v116 = (void *)*((_QWORD *)v212 + v105);
              v93 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_add4and8);
              -[CIImage extent](a2, "extent");
              v118 = v117;
              v120 = v119;
              v122 = v121;
              v124 = v123;
              objc_msgSend(v116, "extent");
              v238 = CGRectInset(v229, (float)-v115, (float)-v115);
              v230.origin.x = v118;
              v230.origin.y = v120;
              v230.size.width = v122;
              v230.size.height = v124;
              v231 = CGRectUnion(v230, v238);
              v102 = v231.origin.x;
              v103 = v231.origin.y;
              v104 = v231.size.width;
              v54 = v231.size.height;
              v177[0] = v4;
              v177[1] = 3221225472;
              v177[2] = ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_6;
              v177[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
              v178 = v115;
              v197[0] = a2;
              v197[1] = v116;
              v197[2] = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v107, v109, v169, v158);
              v197[3] = +[CIVector vectorWithX:Y:Z:](CIVector, "vectorWithX:Y:Z:", v163, v155, v152);
              v55 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v197, 4);
              v56 = v177;
LABEL_36:
              v57 = v93;
              v58 = v102;
              v59 = v103;
              v80 = v104;
LABEL_31:
              v23 = -[CIKernel applyWithExtent:roiCallback:arguments:](v57, "applyWithExtent:roiCallback:arguments:", v56, v55, v58, v59, v80, v54);
LABEL_20:
              a2 = v23;
              v3 = v6;
              goto LABEL_40;
            }
            if (objc_msgSend(v8, "isEqualToString:", CFSTR("add8and8")))
            {
              v125 = objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 1), "intValue");
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 2), "floatValue");
              v127 = v126;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 3), "floatValue");
              v129 = v128;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 4), "floatValue");
              v170 = v130;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 5), "floatValue");
              v159 = v131;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 6), "doubleValue");
              v164 = v132;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 7), "doubleValue");
              v156 = v133;
              objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 8), "doubleValue");
              v153 = v134;
              v135 = ceilf(fmaxf(v127, v129));
              v136 = (void *)*((_QWORD *)v212 + v125);
              v137 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_add8and8);
              -[CIImage extent](a2, "extent");
              v139 = v138;
              v141 = v140;
              v143 = v142;
              v145 = v144;
              objc_msgSend(v136, "extent");
              v239 = CGRectInset(v232, (float)-v135, (float)-v135);
              v233.origin.x = v139;
              v233.origin.y = v141;
              v233.size.width = v143;
              v233.size.height = v145;
              v234 = CGRectUnion(v233, v239);
              v146 = v234.origin.x;
              v147 = v234.origin.y;
              v148 = v234.size.width;
              v149 = v234.size.height;
              v175[0] = v4;
              v175[1] = 3221225472;
              v175[2] = ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_7;
              v175[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
              v176 = v135;
              v196[0] = a2;
              v196[1] = v136;
              v196[2] = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v127, v129, v170, v159);
              v196[3] = +[CIVector vectorWithX:Y:Z:](CIVector, "vectorWithX:Y:Z:", v164, v156, v153);
              a2 = -[CIKernel applyWithExtent:roiCallback:arguments:](v137, "applyWithExtent:roiCallback:arguments:", v175, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v196, 4), v146, v147, v148, v149);
            }
LABEL_39:
            v3 = v6;
            goto LABEL_40;
          }
          v24 = objc_msgSend((id)objc_msgSend(v7, "objectAtIndex:", 1), "intValue");
          *(_QWORD *)&v212[0] = a2;
          v165 = v24;
          if (v24 >= 1)
          {
            v25 = (v24 + 1) - 1;
            v26 = 1;
            v27 = (_QWORD *)v212 + 1;
            do
            {
              v28 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_box3);
              -[CIImage extent](a2, "extent");
              v219 = CGRectInset(v218, (double)-(int)v26, (double)-(int)v26);
              v29 = v219.origin.x;
              v30 = v219.origin.y;
              v31 = v219.size.width;
              v32 = v219.size.height;
              v185[0] = MEMORY[0x1E0C809B0];
              v185[1] = 3221225472;
              v185[2] = ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_2;
              v185[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
              v186 = v26;
              v201[0] = a2;
              v201[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v26);
              a2 = -[CIKernel applyWithExtent:roiCallback:arguments:](v28, "applyWithExtent:roiCallback:arguments:", v185, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v201, 2), v29, v30, v31, v32);
              *v27++ = a2;
              v26 = (3 * v26);
              --v25;
            }
            while (v25);
          }
          a2 = (CIImage *)*((_QWORD *)v212 + v165);
          v3 = v6;
          v4 = MEMORY[0x1E0C809B0];
        }
LABEL_40:
        ++v5;
      }
      while (v174 + 1 != v173);
      v173 = -[NSArray countByEnumeratingWithState:objects:count:](a1, "countByEnumeratingWithState:objects:count:", &v192, v211, 16);
    }
    while (v173);
  }
  return a2;
}

double cikernel::_convolutionAdd_1(uint64_t a1, uint64_t a2, float32x2_t a3, float a4)
{
  float32x2_t *DC;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  float64x2_t v13;
  double v14;
  int8x16_t v15;
  float32x4_t v16;
  CI *v17;
  float32x2_t v18;
  double v19;
  double v20;
  uint8x8_t v21;
  int8x16_t v22;
  float64x2_t v23;
  double v24;
  int8x16_t v25;
  float32x4_t v26;
  double result;
  float32x4_t v28;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v9) = *(_DWORD *)(a2 + 28);
  v10.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v9, COERCE_FLOAT(*DC));
  *(float *)&v12 = *(float *)(a2 + 24) + *(float *)&v8;
  *(float *)v13.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  *((float *)&v12 + 1) = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v12, v13, v8, v9, v11, v10, v14, v15);
  v28 = v16;
  v18 = vadd_f32(a3, *(float32x2_t *)CI::getDC(v17));
  *(float *)&v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v18, 1), *(float *)(a1 + 16), v18.f32[0]);
  LODWORD(v20) = *(_DWORD *)(a1 + 28);
  v21.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v18, 1), *(float *)&v20, v18.f32[0]);
  v18.f32[0] = *(float *)(a1 + 24) + *(float *)&v19;
  *(float *)v23.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  v18.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v18, v23, v19, v20, v22, v21, v24, v25);
  *(_QWORD *)&result = vaddq_f32(v28, vmulq_n_f32(v26, a4)).u64[0];
  return result;
}

void CI::f4_sr_sr_f2_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, uint64_t, double, float);
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  double *v18;
  __int128 v19;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, uint64_t, double, float))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_QWORD *)(v11 + 32);
  v15 = *(_DWORD *)(v11 + 64);
  v16 = *(_QWORD *)(v11 + 56);
  v17 = *(_QWORD *)(v11 + 80);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 104)), a2);
  v18 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v18 = (double *)((char *)a2 + 64 * v16);
  *(double *)&v19 = v12(a4 + 80 * v13, a4 + 80 * v14, *v18, *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_convolutionAdd_2(uint64_t a1, uint64_t a2, float32x2_t a3, float32x2_t a4, double a5)
{
  float32x2_t *DC;
  double v10;
  double v11;
  uint8x8_t v12;
  int8x16_t v13;
  double v14;
  float64x2_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  CI *v19;
  float32x2_t v20;
  float32x2_t v21;
  double v22;
  double v23;
  uint8x8_t v24;
  int8x16_t v25;
  float64x2_t v26;
  double v27;
  int8x16_t v28;
  float32x4_t v29;
  double v30;
  double v31;
  uint8x8_t v32;
  int8x16_t v33;
  float64x2_t v34;
  double v35;
  int8x16_t v36;
  float32x4_t v37;
  double result;
  float32x4_t v39;
  float32x4_t v40;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v10 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v11) = *(_DWORD *)(a2 + 28);
  v12.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v11, COERCE_FLOAT(*DC));
  *(float *)&v14 = *(float *)(a2 + 24) + *(float *)&v10;
  *(float *)v15.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  *((float *)&v14 + 1) = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v14, v15, v10, v11, v13, v12, v16, v17);
  v40 = v18;
  v20 = *(float32x2_t *)CI::getDC(v19);
  v21 = vadd_f32(a3, v20);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v21, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v21, 1), *(float *)&v23, v21.f32[0]);
  v21.f32[0] = *(float *)(a1 + 24) + *(float *)&v22;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v21.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v21, v26, v22, v23, v25, v24, v27, v28);
  v39 = v29;
  *(float32x2_t *)v29.f32 = vadd_f32(a4, v20);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v29.f32, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v29.f32, 1), *(float *)&v31, v29.f32[0]);
  v29.f32[0] = *(float *)(a1 + 24) + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v29.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v34, v30, v31, v33, v32, v35, v36);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(v40, vmulq_n_f32(v39, *(float *)&a5)), vmulq_lane_f32(v37, *(float32x2_t *)&a5, 1)).u64[0];
  return result;
}

void CI::f4_sr_sr_f2_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(uint64_t, uint64_t, double, double, double);
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  double *v19;
  double *v20;
  double *v21;
  __int128 v22;
  int v23;
  uint64_t v24;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(uint64_t, uint64_t, double, double, double))(a1 + 24);
  v11 = *(_QWORD *)(v9 + 8);
  v12 = *(_QWORD *)(v9 + 32);
  v13 = *(_DWORD *)(v9 + 64);
  v14 = *(_QWORD *)(v9 + 56);
  v15 = *(_DWORD *)(v9 + 88);
  v16 = *(_QWORD *)(v9 + 80);
  v17 = *(_DWORD *)(v9 + 112);
  v18 = *(_QWORD *)(v9 + 104);
  if (*(_BYTE *)(a1 + 64))
  {
    v24 = a4;
    v23 = *(_DWORD *)(v9 + 112);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
    v17 = v23;
    a4 = v24;
  }
  v19 = (double *)(a3 + 16 * v18);
  if (v17 != 5)
    v19 = (double *)((char *)a2 + 64 * v18);
  v20 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v20 = (double *)((char *)a2 + 64 * v16);
  v21 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v21 = (double *)((char *)a2 + 64 * v14);
  *(double *)&v22 = v10(a4 + 80 * v11, a4 + 80 * v12, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

double cikernel::_convolutionAdd_3(uint64_t a1, uint64_t a2, float32x2_t a3, float32x2_t a4, float32x2_t a5, float32x4_t a6)
{
  float32x2_t *DC;
  double v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  double v16;
  float64x2_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  CI *v21;
  float32x2_t v22;
  float32x2_t v23;
  double v24;
  double v25;
  uint8x8_t v26;
  int8x16_t v27;
  float64x2_t v28;
  double v29;
  int8x16_t v30;
  float32x4_t v31;
  double v32;
  double v33;
  uint8x8_t v34;
  int8x16_t v35;
  float64x2_t v36;
  double v37;
  int8x16_t v38;
  float32x4_t v39;
  double v40;
  double v41;
  uint8x8_t v42;
  int8x16_t v43;
  float64x2_t v44;
  double v45;
  int8x16_t v46;
  float32x4_t v47;
  double result;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v13) = *(_DWORD *)(a2 + 28);
  v14.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v13, COERCE_FLOAT(*DC));
  *(float *)&v16 = *(float *)(a2 + 24) + *(float *)&v12;
  *(float *)v17.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  *((float *)&v16 + 1) = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v16, v17, v12, v13, v15, v14, v18, v19);
  v51 = v20;
  v22 = *(float32x2_t *)CI::getDC(v21);
  v23 = vadd_f32(a3, v22);
  *(float *)&v24 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v23, 1), *(float *)(a1 + 16), v23.f32[0]);
  LODWORD(v25) = *(_DWORD *)(a1 + 28);
  v26.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v23, 1), *(float *)&v25, v23.f32[0]);
  v23.f32[0] = *(float *)(a1 + 24) + *(float *)&v24;
  *(float *)v28.f64 = *(float *)v26.i32 + *(float *)v27.i32;
  v23.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v23, v28, v24, v25, v27, v26, v29, v30);
  v50 = v31;
  *(float32x2_t *)v31.f32 = vadd_f32(a4, v22);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v31.f32, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v33) = *(_DWORD *)(a1 + 28);
  v34.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v31.f32, 1), *(float *)&v33, v31.f32[0]);
  v31.f32[0] = *(float *)(a1 + 24) + *(float *)&v32;
  *(float *)v36.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v31.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v31.i64, v36, v32, v33, v35, v34, v37, v38);
  v49 = v39;
  *(float32x2_t *)v39.f32 = vadd_f32(a5, v22);
  *(float *)&v40 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v39.f32, 1), *(float *)(a1 + 16), v39.f32[0]);
  LODWORD(v41) = *(_DWORD *)(a1 + 28);
  v42.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v43.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v39.f32, 1), *(float *)&v41, v39.f32[0]);
  v39.f32[0] = *(float *)(a1 + 24) + *(float *)&v40;
  *(float *)v44.f64 = *(float *)v42.i32 + *(float *)v43.i32;
  v39.f32[1] = *(float *)v42.i32 + *(float *)v43.i32;
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v39.i64, v44, v40, v41, v43, v42, v45, v46);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vaddq_f32(v51, vmulq_n_f32(v50, a6.f32[0])), vmulq_lane_f32(v49, *(float32x2_t *)a6.f32, 1)), vmulq_laneq_f32(v47, a6, 2)).u64[0];
  return result;
}

void CI::f4_sr_sr_f2_f2_f2_f3(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(uint64_t, uint64_t, double, double, double, __n128);
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  double *v20;
  double *v21;
  double *v22;
  __int128 v23;
  uint64_t v24;
  int v25;
  uint64_t v26;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(uint64_t, uint64_t, double, double, double, __n128))(a1 + 24);
  v11 = *(_QWORD *)(v9 + 8);
  v12 = *(_QWORD *)(v9 + 32);
  v13 = *(_DWORD *)(v9 + 64);
  v14 = *(_QWORD *)(v9 + 56);
  v15 = *(_DWORD *)(v9 + 88);
  v16 = *(_QWORD *)(v9 + 80);
  v17 = *(_DWORD *)(v9 + 112);
  v18 = *(_QWORD *)(v9 + 104);
  v19 = *(_QWORD *)(v9 + 128);
  if (*(_BYTE *)(a1 + 64))
  {
    v26 = *(_QWORD *)(v9 + 32);
    v24 = a4;
    v25 = *(_DWORD *)(v9 + 88);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 152)), a2);
    v15 = v25;
    a4 = v24;
    v12 = v26;
  }
  v20 = (double *)(a3 + 16 * v18);
  if (v17 != 5)
    v20 = (double *)((char *)a2 + 64 * v18);
  v21 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v21 = (double *)((char *)a2 + 64 * v16);
  v22 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v22 = (double *)((char *)a2 + 64 * v14);
  *(double *)&v23 = v10(a4 + 80 * v11, a4 + 80 * v12, *v22, *v21, *v20, *((__n128 *)a2 + 4 * v19));
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

double cikernel::_convolutionAdd_4(uint64_t a1, uint64_t a2, int8x16_t a3, int8x16_t a4, float32x4_t a5)
{
  float32x2_t *DC;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  float64x2_t v13;
  double v14;
  int8x16_t v15;
  float32x4_t v16;
  CI *v17;
  float32x2_t v18;
  float32x2_t v19;
  double v20;
  double v21;
  uint8x8_t v22;
  int8x16_t v23;
  float64x2_t v24;
  double v25;
  int8x16_t v26;
  float32x4_t v27;
  double v28;
  double v29;
  uint8x8_t v30;
  int8x16_t v31;
  float64x2_t v32;
  double v33;
  int8x16_t v34;
  float32x4_t v35;
  double v36;
  double v37;
  uint8x8_t v38;
  int8x16_t v39;
  float64x2_t v40;
  double v41;
  int8x16_t v42;
  float32x4_t v43;
  double v44;
  double v45;
  uint8x8_t v46;
  int8x16_t v47;
  float64x2_t v48;
  double v49;
  int8x16_t v50;
  float32x4_t v51;
  double result;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v58;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v9) = *(_DWORD *)(a2 + 28);
  v10.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v9, COERCE_FLOAT(*DC));
  *(float *)&v12 = *(float *)(a2 + 24) + *(float *)&v8;
  *(float *)v13.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  *((float *)&v12 + 1) = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v12, v13, v8, v9, v11, v10, v14, v15);
  v55 = v16;
  v18 = *(float32x2_t *)CI::getDC(v17);
  v19 = vadd_f32(*(float32x2_t *)a3.i8, v18);
  *(float *)&v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v19, 1), *(float *)(a1 + 16), v19.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v19, 1), *(float *)&v21, v19.f32[0]);
  v19.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v24.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v19.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v19, v24, v20, v21, v23, v22, v25, v26);
  v54 = v27;
  *(float32x2_t *)v27.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v18);
  *(float *)&v28 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v27.f32, 1), *(float *)(a1 + 16), v27.f32[0]);
  LODWORD(v29) = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v27.f32, 1), *(float *)&v29, v27.f32[0]);
  v27.f32[0] = *(float *)(a1 + 24) + *(float *)&v28;
  *(float *)v32.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v27.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v32, v28, v29, v31, v30, v33, v34);
  v58 = v35;
  *(float32x2_t *)v35.f32 = vadd_f32(*(float32x2_t *)a4.i8, v18);
  *(float *)&v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v35.f32, 1), *(float *)(a1 + 16), v35.f32[0]);
  LODWORD(v37) = *(_DWORD *)(a1 + 28);
  v38.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v35.f32, 1), *(float *)&v37, v35.f32[0]);
  v35.f32[0] = *(float *)(a1 + 24) + *(float *)&v36;
  *(float *)v40.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v35.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v40, v36, v37, v39, v38, v41, v42);
  v53 = v43;
  *(float32x2_t *)v43.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v18);
  *(float *)&v44 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v43.f32, 1), *(float *)(a1 + 16), v43.f32[0]);
  LODWORD(v45) = *(_DWORD *)(a1 + 28);
  v46.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v43.f32, 1), *(float *)&v45, v43.f32[0]);
  v43.f32[0] = *(float *)(a1 + 24) + *(float *)&v44;
  *(float *)v48.f64 = *(float *)v46.i32 + *(float *)v47.i32;
  v43.f32[1] = *(float *)v46.i32 + *(float *)v47.i32;
  *(double *)v51.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v43.i64, v48, v44, v45, v47, v46, v49, v50);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v55, vmulq_n_f32(v54, a5.f32[0])), vmulq_lane_f32(v58, *(float32x2_t *)a5.f32, 1)), vmulq_laneq_f32(v53, a5, 2)), vmulq_laneq_f32(v51, a5, 3)).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(uint64_t, uint64_t, __n128, __n128, __n128);
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __n128 *v19;
  __n128 *v20;
  __n128 *v21;
  __int128 v22;
  int v23;
  uint64_t v24;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128))(a1 + 24);
  v11 = *(_QWORD *)(v9 + 8);
  v12 = *(_QWORD *)(v9 + 32);
  v13 = *(_DWORD *)(v9 + 64);
  v14 = *(_QWORD *)(v9 + 56);
  v15 = *(_DWORD *)(v9 + 88);
  v16 = *(_QWORD *)(v9 + 80);
  v17 = *(_DWORD *)(v9 + 112);
  v18 = *(_QWORD *)(v9 + 104);
  if (*(_BYTE *)(a1 + 64))
  {
    v24 = a4;
    v23 = *(_DWORD *)(v9 + 112);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
    v17 = v23;
    a4 = v24;
  }
  v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v18);
  v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v16);
  v21 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v21 = (__n128 *)((char *)a2 + 64 * v14);
  *(double *)&v22 = v10(a4 + 80 * v11, a4 + 80 * v12, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

double cikernel::_convolutionAdd_5(uint64_t a1, uint64_t a2, int8x16_t a3, int8x16_t a4, float32x2_t a5, float32x4_t a6, float a7)
{
  float32x2_t *DC;
  double v11;
  double v12;
  uint8x8_t v13;
  int8x16_t v14;
  double v15;
  float64x2_t v16;
  double v17;
  int8x16_t v18;
  float32x4_t v19;
  CI *v20;
  float32x2_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  uint8x8_t v25;
  int8x16_t v26;
  float64x2_t v27;
  double v28;
  int8x16_t v29;
  float32x4_t v30;
  double v31;
  double v32;
  uint8x8_t v33;
  int8x16_t v34;
  float64x2_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  double v39;
  double v40;
  uint8x8_t v41;
  int8x16_t v42;
  float64x2_t v43;
  double v44;
  int8x16_t v45;
  float32x4_t v46;
  double v47;
  double v48;
  uint8x8_t v49;
  int8x16_t v50;
  float64x2_t v51;
  double v52;
  int8x16_t v53;
  float32x4_t v54;
  double v55;
  double v56;
  uint8x8_t v57;
  int8x16_t v58;
  float64x2_t v59;
  double v60;
  int8x16_t v61;
  float32x4_t v62;
  double result;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v70;
  float32x4_t v72;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v11 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v12) = *(_DWORD *)(a2 + 28);
  v13.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v14.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v12, COERCE_FLOAT(*DC));
  *(float *)&v15 = *(float *)(a2 + 24) + *(float *)&v11;
  *(float *)v16.f64 = *(float *)v13.i32 + *(float *)v14.i32;
  *((float *)&v15 + 1) = *(float *)v13.i32 + *(float *)v14.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v15, v16, v11, v12, v14, v13, v17, v18);
  v66 = v19;
  v21 = *(float32x2_t *)CI::getDC(v20);
  v22 = vadd_f32(*(float32x2_t *)a3.i8, v21);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)&v24, v22.f32[0]);
  v22.f32[0] = *(float *)(a1 + 24) + *(float *)&v23;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v22.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v22, v27, v23, v24, v26, v25, v28, v29);
  v65 = v30;
  *(float32x2_t *)v30.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v21);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v30.f32, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 28);
  v33.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v30.f32, 1), *(float *)&v32, v30.f32[0]);
  v30.f32[0] = *(float *)(a1 + 24) + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v30.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v30.i64, v35, v31, v32, v34, v33, v36, v37);
  v70 = v38;
  *(float32x2_t *)v38.f32 = vadd_f32(*(float32x2_t *)a4.i8, v21);
  *(float *)&v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v38.f32, 1), *(float *)(a1 + 16), v38.f32[0]);
  LODWORD(v40) = *(_DWORD *)(a1 + 28);
  v41.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v38.f32, 1), *(float *)&v40, v38.f32[0]);
  v38.f32[0] = *(float *)(a1 + 24) + *(float *)&v39;
  *(float *)v43.f64 = *(float *)v41.i32 + *(float *)v42.i32;
  v38.f32[1] = *(float *)v41.i32 + *(float *)v42.i32;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v43, v39, v40, v42, v41, v44, v45);
  v64 = v46;
  *(float32x2_t *)v46.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v21);
  *(float *)&v47 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v46.f32, 1), *(float *)(a1 + 16), v46.f32[0]);
  LODWORD(v48) = *(_DWORD *)(a1 + 28);
  v49.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v46.f32, 1), *(float *)&v48, v46.f32[0]);
  v46.f32[0] = *(float *)(a1 + 24) + *(float *)&v47;
  *(float *)v51.f64 = *(float *)v49.i32 + *(float *)v50.i32;
  v46.f32[1] = *(float *)v49.i32 + *(float *)v50.i32;
  *(double *)v54.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v46.i64, v51, v47, v48, v50, v49, v52, v53);
  v72 = v54;
  *(float32x2_t *)v54.f32 = vadd_f32(a5, v21);
  *(float *)&v55 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v54.f32, 1), *(float *)(a1 + 16), v54.f32[0]);
  LODWORD(v56) = *(_DWORD *)(a1 + 28);
  v57.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v58.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v54.f32, 1), *(float *)&v56, v54.f32[0]);
  v54.f32[0] = *(float *)(a1 + 24) + *(float *)&v55;
  *(float *)v59.f64 = *(float *)v57.i32 + *(float *)v58.i32;
  v54.f32[1] = *(float *)v57.i32 + *(float *)v58.i32;
  *(double *)v62.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v54.i64, v59, v55, v56, v58, v57, v60, v61);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v66, vmulq_n_f32(v65, a6.f32[0])), vmulq_lane_f32(v70, *(float32x2_t *)a6.f32, 1)), vmulq_laneq_f32(v64, a6, 2)), vmulq_laneq_f32(v72, a6, 3)), vmulq_n_f32(v62, a7)).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f4_f2_f4_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(uint64_t, uint64_t, __n128, __n128, double, __n128, float);
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  __n128 *v22;
  double *v23;
  __n128 *v24;
  __n128 *v25;
  __int128 v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  double (*v31)(uint64_t, uint64_t, __n128, __n128, double, __n128, float);

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(uint64_t, uint64_t, __n128, __n128, double, __n128, float))(a1 + 24);
  v11 = *(_QWORD *)(v9 + 8);
  v12 = *(_QWORD *)(v9 + 32);
  v13 = *(_DWORD *)(v9 + 64);
  v14 = *(_QWORD *)(v9 + 56);
  v15 = *(_DWORD *)(v9 + 88);
  v16 = *(_QWORD *)(v9 + 80);
  v17 = *(_DWORD *)(v9 + 112);
  v18 = *(_QWORD *)(v9 + 104);
  v19 = *(_DWORD *)(v9 + 136);
  v20 = *(_QWORD *)(v9 + 128);
  v21 = *(_QWORD *)(v9 + 152);
  if (*(_BYTE *)(a1 + 64))
  {
    v30 = *(_QWORD *)(v9 + 56);
    v31 = *(double (**)(uint64_t, uint64_t, __n128, __n128, double, __n128, float))(a1 + 24);
    v29 = a4;
    v27 = *(_QWORD *)(v9 + 152);
    v28 = *(_DWORD *)(v9 + 112);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 176)), a2);
    v17 = v28;
    a4 = v29;
    v14 = v30;
    v21 = v27;
    v10 = v31;
  }
  v22 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5)
    v22 = (__n128 *)((char *)a2 + 64 * v20);
  v23 = (double *)(a3 + 16 * v18);
  if (v17 != 5)
    v23 = (double *)((char *)a2 + 64 * v18);
  v24 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v24 = (__n128 *)((char *)a2 + 64 * v16);
  v25 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v25 = (__n128 *)((char *)a2 + 64 * v14);
  *(double *)&v26 = v10(a4 + 80 * v11, a4 + 80 * v12, *v25, *v24, *v23, *v22, *((float *)a2 + 16 * v21));
  *(_OWORD *)(a3 + 16 * a7) = v26;
}

double cikernel::_convolutionAdd_6(uint64_t a1, uint64_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, float32x4_t a6, double a7)
{
  float32x2_t *DC;
  double v10;
  double v11;
  uint8x8_t v12;
  int8x16_t v13;
  double v14;
  float64x2_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  CI *v19;
  float32x2_t v20;
  float32x2_t v21;
  double v22;
  double v23;
  uint8x8_t v24;
  int8x16_t v25;
  float64x2_t v26;
  double v27;
  int8x16_t v28;
  float32x4_t v29;
  double v30;
  double v31;
  uint8x8_t v32;
  int8x16_t v33;
  float64x2_t v34;
  double v35;
  int8x16_t v36;
  float32x4_t v37;
  double v38;
  double v39;
  uint8x8_t v40;
  int8x16_t v41;
  float64x2_t v42;
  double v43;
  int8x16_t v44;
  float32x4_t v45;
  double v46;
  double v47;
  uint8x8_t v48;
  int8x16_t v49;
  float64x2_t v50;
  double v51;
  int8x16_t v52;
  float32x4_t v53;
  double v54;
  double v55;
  uint8x8_t v56;
  int8x16_t v57;
  float64x2_t v58;
  double v59;
  int8x16_t v60;
  float32x4_t v61;
  double v62;
  double v63;
  uint8x8_t v64;
  int8x16_t v65;
  float64x2_t v66;
  double v67;
  int8x16_t v68;
  float32x4_t v69;
  double result;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v78;
  float32x4_t v80;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v10 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v11) = *(_DWORD *)(a2 + 28);
  v12.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v11, COERCE_FLOAT(*DC));
  *(float *)&v14 = *(float *)(a2 + 24) + *(float *)&v10;
  *(float *)v15.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  *((float *)&v14 + 1) = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v14, v15, v10, v11, v13, v12, v16, v17);
  v74 = v18;
  v20 = *(float32x2_t *)CI::getDC(v19);
  v21 = vadd_f32(*(float32x2_t *)a3.i8, v20);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v21, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v21, 1), *(float *)&v23, v21.f32[0]);
  v21.f32[0] = *(float *)(a1 + 24) + *(float *)&v22;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v21.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v21, v26, v22, v23, v25, v24, v27, v28);
  v73 = v29;
  *(float32x2_t *)v29.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v20);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v29.f32, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v29.f32, 1), *(float *)&v31, v29.f32[0]);
  v29.f32[0] = *(float *)(a1 + 24) + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v29.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v34, v30, v31, v33, v32, v35, v36);
  v78 = v37;
  *(float32x2_t *)v37.f32 = vadd_f32(*(float32x2_t *)a4.i8, v20);
  *(float *)&v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v37.f32, 1), *(float *)(a1 + 16), v37.f32[0]);
  LODWORD(v39) = *(_DWORD *)(a1 + 28);
  v40.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v37.f32, 1), *(float *)&v39, v37.f32[0]);
  v37.f32[0] = *(float *)(a1 + 24) + *(float *)&v38;
  *(float *)v42.f64 = *(float *)v40.i32 + *(float *)v41.i32;
  v37.f32[1] = *(float *)v40.i32 + *(float *)v41.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v37.i64, v42, v38, v39, v41, v40, v43, v44);
  v72 = v45;
  *(float32x2_t *)v45.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v20);
  *(float *)&v46 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v45.f32, 1), *(float *)(a1 + 16), v45.f32[0]);
  LODWORD(v47) = *(_DWORD *)(a1 + 28);
  v48.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v45.f32, 1), *(float *)&v47, v45.f32[0]);
  v45.f32[0] = *(float *)(a1 + 24) + *(float *)&v46;
  *(float *)v50.f64 = *(float *)v48.i32 + *(float *)v49.i32;
  v45.f32[1] = *(float *)v48.i32 + *(float *)v49.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v50, v46, v47, v49, v48, v51, v52);
  v80 = v53;
  *(float32x2_t *)v53.f32 = vadd_f32(*(float32x2_t *)a5.i8, v20);
  *(float *)&v54 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v53.f32, 1), *(float *)(a1 + 16), v53.f32[0]);
  LODWORD(v55) = *(_DWORD *)(a1 + 28);
  v56.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v53.f32, 1), *(float *)&v55, v53.f32[0]);
  v53.f32[0] = *(float *)(a1 + 24) + *(float *)&v54;
  *(float *)v58.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v53.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v61.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v53.i64, v58, v54, v55, v57, v56, v59, v60);
  v71 = v61;
  *(float32x2_t *)v61.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v20);
  *(float *)&v62 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v61.f32, 1), *(float *)(a1 + 16), v61.f32[0]);
  LODWORD(v63) = *(_DWORD *)(a1 + 28);
  v64.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v61.f32, 1), *(float *)&v63, v61.f32[0]);
  v61.f32[0] = *(float *)(a1 + 24) + *(float *)&v62;
  *(float *)v66.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v61.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v69.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v61.i64, v66, v62, v63, v65, v64, v67, v68);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v74, vmulq_n_f32(v73, a6.f32[0])), vmulq_lane_f32(v78, *(float32x2_t *)a6.f32, 1)), vmulq_laneq_f32(v72, a6, 2)), vmulq_laneq_f32(v80, a6, 3)), vmulq_n_f32(v71, *(float *)&a7)), vmulq_lane_f32(v69, *(float32x2_t *)&a7, 1)).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f4_f4_f4_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, double);
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  double *v24;
  __n128 *v25;
  __n128 *v26;
  __n128 *v27;
  __n128 *v28;
  __int128 v29;
  int v30;
  uint64_t v31;
  int v32;
  double (*v33)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, double);
  int v34;
  int v35;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, double))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_QWORD *)(v10 + 32);
  v14 = *(_DWORD *)(v10 + 64);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_DWORD *)(v10 + 88);
  v17 = *(_QWORD *)(v10 + 80);
  v18 = *(_DWORD *)(v10 + 112);
  v19 = *(_QWORD *)(v10 + 104);
  v20 = *(_DWORD *)(v10 + 136);
  v21 = *(_QWORD *)(v10 + 128);
  v22 = *(_DWORD *)(v10 + 160);
  v23 = *(_QWORD *)(v10 + 152);
  if (*(_BYTE *)(a1 + 64))
  {
    v33 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, double))(a1 + 24);
    v31 = *(_QWORD *)(v10 + 8);
    v34 = *(_DWORD *)(v10 + 88);
    v35 = *(_DWORD *)(v10 + 64);
    v32 = *(_DWORD *)(v10 + 112);
    v30 = *(_DWORD *)(v10 + 160);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 176)), a2);
    v22 = v30;
    v18 = v32;
    v16 = v34;
    v14 = v35;
    v12 = v31;
    v11 = v33;
  }
  v24 = (double *)(a3 + 16 * v23);
  if (v22 != 5)
    v24 = (double *)((char *)a2 + 64 * v23);
  v25 = (__n128 *)(a3 + 16 * v21);
  if (v20 != 5)
    v25 = (__n128 *)((char *)a2 + 64 * v21);
  v26 = (__n128 *)(a3 + 16 * v19);
  if (v18 != 5)
    v26 = (__n128 *)((char *)a2 + 64 * v19);
  v27 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v27 = (__n128 *)((char *)a2 + 64 * v17);
  v28 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v28 = (__n128 *)((char *)a2 + 64 * v15);
  *(double *)&v29 = v11(a4 + 80 * v12, a4 + 80 * v13, *v28, *v27, *v26, *v25, *v24);
  *(_OWORD *)(a3 + 16 * a7) = v29;
}

double cikernel::_convolutionAdd_7(uint64_t a1, uint64_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, float32x2_t a6, float32x4_t a7, float32x4_t a8)
{
  float32x2_t *DC;
  double v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  double v16;
  float64x2_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  CI *v21;
  float32x2_t v22;
  float32x2_t v23;
  double v24;
  double v25;
  uint8x8_t v26;
  int8x16_t v27;
  float64x2_t v28;
  double v29;
  int8x16_t v30;
  float32x4_t v31;
  double v32;
  double v33;
  uint8x8_t v34;
  int8x16_t v35;
  float64x2_t v36;
  double v37;
  int8x16_t v38;
  float32x4_t v39;
  double v40;
  double v41;
  uint8x8_t v42;
  int8x16_t v43;
  float64x2_t v44;
  double v45;
  int8x16_t v46;
  float32x4_t v47;
  double v48;
  double v49;
  uint8x8_t v50;
  int8x16_t v51;
  float64x2_t v52;
  double v53;
  int8x16_t v54;
  float32x4_t v55;
  double v56;
  double v57;
  uint8x8_t v58;
  int8x16_t v59;
  float64x2_t v60;
  double v61;
  int8x16_t v62;
  float32x4_t v63;
  double v64;
  double v65;
  uint8x8_t v66;
  int8x16_t v67;
  float64x2_t v68;
  double v69;
  int8x16_t v70;
  float32x4_t v71;
  double v72;
  double v73;
  uint8x8_t v74;
  int8x16_t v75;
  float64x2_t v76;
  double v77;
  int8x16_t v78;
  float32x4_t v79;
  double result;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v88;
  float32x4_t v90;
  float32x4_t v92;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v13) = *(_DWORD *)(a2 + 28);
  v14.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v13, COERCE_FLOAT(*DC));
  *(float *)&v16 = *(float *)(a2 + 24) + *(float *)&v12;
  *(float *)v17.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  *((float *)&v16 + 1) = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v16, v17, v12, v13, v15, v14, v18, v19);
  v84 = v20;
  v22 = *(float32x2_t *)CI::getDC(v21);
  v23 = vadd_f32(*(float32x2_t *)a3.i8, v22);
  *(float *)&v24 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v23, 1), *(float *)(a1 + 16), v23.f32[0]);
  LODWORD(v25) = *(_DWORD *)(a1 + 28);
  v26.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v23, 1), *(float *)&v25, v23.f32[0]);
  v23.f32[0] = *(float *)(a1 + 24) + *(float *)&v24;
  *(float *)v28.f64 = *(float *)v26.i32 + *(float *)v27.i32;
  v23.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v23, v28, v24, v25, v27, v26, v29, v30);
  v83 = v31;
  *(float32x2_t *)v31.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v22);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v31.f32, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v33) = *(_DWORD *)(a1 + 28);
  v34.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v31.f32, 1), *(float *)&v33, v31.f32[0]);
  v31.f32[0] = *(float *)(a1 + 24) + *(float *)&v32;
  *(float *)v36.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v31.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v31.i64, v36, v32, v33, v35, v34, v37, v38);
  v88 = v39;
  *(float32x2_t *)v39.f32 = vadd_f32(*(float32x2_t *)a4.i8, v22);
  *(float *)&v40 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v39.f32, 1), *(float *)(a1 + 16), v39.f32[0]);
  LODWORD(v41) = *(_DWORD *)(a1 + 28);
  v42.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v43.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v39.f32, 1), *(float *)&v41, v39.f32[0]);
  v39.f32[0] = *(float *)(a1 + 24) + *(float *)&v40;
  *(float *)v44.f64 = *(float *)v42.i32 + *(float *)v43.i32;
  v39.f32[1] = *(float *)v42.i32 + *(float *)v43.i32;
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v39.i64, v44, v40, v41, v43, v42, v45, v46);
  v82 = v47;
  *(float32x2_t *)v47.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v22);
  *(float *)&v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v47.f32, 1), *(float *)(a1 + 16), v47.f32[0]);
  LODWORD(v49) = *(_DWORD *)(a1 + 28);
  v50.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v47.f32, 1), *(float *)&v49, v47.f32[0]);
  v47.f32[0] = *(float *)(a1 + 24) + *(float *)&v48;
  *(float *)v52.f64 = *(float *)v50.i32 + *(float *)v51.i32;
  v47.f32[1] = *(float *)v50.i32 + *(float *)v51.i32;
  *(double *)v55.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v47.i64, v52, v48, v49, v51, v50, v53, v54);
  v90 = v55;
  *(float32x2_t *)v55.f32 = vadd_f32(*(float32x2_t *)a5.i8, v22);
  *(float *)&v56 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v55.f32, 1), *(float *)(a1 + 16), v55.f32[0]);
  LODWORD(v57) = *(_DWORD *)(a1 + 28);
  v58.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v59.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v55.f32, 1), *(float *)&v57, v55.f32[0]);
  v55.f32[0] = *(float *)(a1 + 24) + *(float *)&v56;
  *(float *)v60.f64 = *(float *)v58.i32 + *(float *)v59.i32;
  v55.f32[1] = *(float *)v58.i32 + *(float *)v59.i32;
  *(double *)v63.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v55.i64, v60, v56, v57, v59, v58, v61, v62);
  v81 = v63;
  *(float32x2_t *)v63.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v22);
  *(float *)&v64 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v63.f32, 1), *(float *)(a1 + 16), v63.f32[0]);
  LODWORD(v65) = *(_DWORD *)(a1 + 28);
  v66.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v67.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v63.f32, 1), *(float *)&v65, v63.f32[0]);
  v63.f32[0] = *(float *)(a1 + 24) + *(float *)&v64;
  *(float *)v68.f64 = *(float *)v66.i32 + *(float *)v67.i32;
  v63.f32[1] = *(float *)v66.i32 + *(float *)v67.i32;
  *(double *)v71.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v63.i64, v68, v64, v65, v67, v66, v69, v70);
  v92 = v71;
  *(float32x2_t *)v71.f32 = vadd_f32(a6, v22);
  *(float *)&v72 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v71.f32, 1), *(float *)(a1 + 16), v71.f32[0]);
  LODWORD(v73) = *(_DWORD *)(a1 + 28);
  v74.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v75.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v71.f32, 1), *(float *)&v73, v71.f32[0]);
  v71.f32[0] = *(float *)(a1 + 24) + *(float *)&v72;
  *(float *)v76.f64 = *(float *)v74.i32 + *(float *)v75.i32;
  v71.f32[1] = *(float *)v74.i32 + *(float *)v75.i32;
  *(double *)v79.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v71.i64, v76, v72, v73, v75, v74, v77, v78);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v84, vmulq_n_f32(v83, a7.f32[0])), vmulq_lane_f32(v88, *(float32x2_t *)a7.f32, 1)), vmulq_laneq_f32(v82, a7, 2)), vmulq_laneq_f32(v90, a7, 3)), vmulq_n_f32(v81, a8.f32[0])), vmulq_lane_f32(v92, *(float32x2_t *)a8.f32, 1)), vmulq_laneq_f32(v79, a8, 2)).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f4_f4_f2_f4_f3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, uint64_t, __n128, __n128, __n128, double, __n128, __n128);
  uint64_t v12;
  uint64_t v13;
  int v14;
  const vec2 *v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  __n128 *v25;
  double *v26;
  __n128 *v27;
  __n128 *v28;
  __n128 *v29;
  __int128 v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const vec2 *v36;
  double (*v37)(uint64_t, uint64_t, __n128, __n128, __n128, double, __n128, __n128);

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, double, __n128, __n128))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_QWORD *)(v10 + 32);
  v14 = *(_DWORD *)(v10 + 64);
  v15 = *(const vec2 **)(v10 + 56);
  v16 = *(_DWORD *)(v10 + 88);
  v17 = *(_QWORD *)(v10 + 80);
  v18 = *(_DWORD *)(v10 + 112);
  v19 = *(_QWORD *)(v10 + 104);
  v20 = *(_DWORD *)(v10 + 136);
  v21 = *(_QWORD *)(v10 + 128);
  v22 = *(_DWORD *)(v10 + 160);
  v23 = *(_QWORD *)(v10 + 152);
  v24 = *(_QWORD *)(v10 + 176);
  if (*(_BYTE *)(a1 + 64))
  {
    v36 = *(const vec2 **)(v10 + 56);
    v37 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, double, __n128, __n128))(a1 + 24);
    v33 = *(_QWORD *)(v10 + 8);
    v34 = *(_QWORD *)(v10 + 80);
    v35 = *(_QWORD *)(v10 + 176);
    v31 = *(_DWORD *)(v10 + 160);
    v32 = *(_DWORD *)(v10 + 136);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 200)), v15);
    v22 = v31;
    v20 = v32;
    v17 = v34;
    v24 = v35;
    v15 = v36;
    v11 = v37;
    v12 = v33;
  }
  v25 = (__n128 *)(a3 + 16 * v23);
  if (v22 != 5)
    v25 = (__n128 *)(a2 + (v23 << 6));
  v26 = (double *)(a3 + 16 * v21);
  if (v20 != 5)
    v26 = (double *)(a2 + (v21 << 6));
  v27 = (__n128 *)(a3 + 16 * v19);
  if (v18 != 5)
    v27 = (__n128 *)(a2 + (v19 << 6));
  v28 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v28 = (__n128 *)(a2 + (v17 << 6));
  v29 = (__n128 *)(a3 + 16 * (_QWORD)v15);
  if (v14 != 5)
    v29 = (__n128 *)(a2 + ((_QWORD)v15 << 6));
  *(double *)&v30 = v11(a4 + 80 * v12, a4 + 80 * v13, *v29, *v28, *v27, *v26, *v25, *(__n128 *)(a2 + (v24 << 6)));
  *(_OWORD *)(a3 + 16 * a7) = v30;
}

double cikernel::_convolutionAdd_8(uint64_t a1, uint64_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, int8x16_t a6, float32x4_t a7, float32x4_t a8)
{
  float32x2_t *DC;
  double v11;
  double v12;
  uint8x8_t v13;
  int8x16_t v14;
  double v15;
  float64x2_t v16;
  double v17;
  int8x16_t v18;
  float32x4_t v19;
  CI *v20;
  float32x2_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  uint8x8_t v25;
  int8x16_t v26;
  float64x2_t v27;
  double v28;
  int8x16_t v29;
  float32x4_t v30;
  double v31;
  double v32;
  uint8x8_t v33;
  int8x16_t v34;
  float64x2_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  double v39;
  double v40;
  uint8x8_t v41;
  int8x16_t v42;
  float64x2_t v43;
  double v44;
  int8x16_t v45;
  float32x4_t v46;
  double v47;
  double v48;
  uint8x8_t v49;
  int8x16_t v50;
  float64x2_t v51;
  double v52;
  int8x16_t v53;
  float32x4_t v54;
  double v55;
  double v56;
  uint8x8_t v57;
  int8x16_t v58;
  float64x2_t v59;
  double v60;
  int8x16_t v61;
  float32x4_t v62;
  double v63;
  double v64;
  uint8x8_t v65;
  int8x16_t v66;
  float64x2_t v67;
  double v68;
  int8x16_t v69;
  float32x4_t v70;
  double v71;
  double v72;
  uint8x8_t v73;
  int8x16_t v74;
  float64x2_t v75;
  double v76;
  int8x16_t v77;
  float32x4_t v78;
  double v79;
  double v80;
  uint8x8_t v81;
  int8x16_t v82;
  float64x2_t v83;
  double v84;
  int8x16_t v85;
  float32x4_t v86;
  double result;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v96;
  float32x4_t v98;
  float32x4_t v100;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v11 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v12) = *(_DWORD *)(a2 + 28);
  v13.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v14.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v12, COERCE_FLOAT(*DC));
  *(float *)&v15 = *(float *)(a2 + 24) + *(float *)&v11;
  *(float *)v16.f64 = *(float *)v13.i32 + *(float *)v14.i32;
  *((float *)&v15 + 1) = *(float *)v13.i32 + *(float *)v14.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v15, v16, v11, v12, v14, v13, v17, v18);
  v92 = v19;
  v21 = *(float32x2_t *)CI::getDC(v20);
  v22 = vadd_f32(*(float32x2_t *)a3.i8, v21);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)&v24, v22.f32[0]);
  v22.f32[0] = *(float *)(a1 + 24) + *(float *)&v23;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v22.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v22, v27, v23, v24, v26, v25, v28, v29);
  v91 = v30;
  *(float32x2_t *)v30.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v21);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v30.f32, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 28);
  v33.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v30.f32, 1), *(float *)&v32, v30.f32[0]);
  v30.f32[0] = *(float *)(a1 + 24) + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v30.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v30.i64, v35, v31, v32, v34, v33, v36, v37);
  v96 = v38;
  *(float32x2_t *)v38.f32 = vadd_f32(*(float32x2_t *)a4.i8, v21);
  *(float *)&v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v38.f32, 1), *(float *)(a1 + 16), v38.f32[0]);
  LODWORD(v40) = *(_DWORD *)(a1 + 28);
  v41.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v38.f32, 1), *(float *)&v40, v38.f32[0]);
  v38.f32[0] = *(float *)(a1 + 24) + *(float *)&v39;
  *(float *)v43.f64 = *(float *)v41.i32 + *(float *)v42.i32;
  v38.f32[1] = *(float *)v41.i32 + *(float *)v42.i32;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v43, v39, v40, v42, v41, v44, v45);
  v90 = v46;
  *(float32x2_t *)v46.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v21);
  *(float *)&v47 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v46.f32, 1), *(float *)(a1 + 16), v46.f32[0]);
  LODWORD(v48) = *(_DWORD *)(a1 + 28);
  v49.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v46.f32, 1), *(float *)&v48, v46.f32[0]);
  v46.f32[0] = *(float *)(a1 + 24) + *(float *)&v47;
  *(float *)v51.f64 = *(float *)v49.i32 + *(float *)v50.i32;
  v46.f32[1] = *(float *)v49.i32 + *(float *)v50.i32;
  *(double *)v54.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v46.i64, v51, v47, v48, v50, v49, v52, v53);
  v98 = v54;
  *(float32x2_t *)v54.f32 = vadd_f32(*(float32x2_t *)a5.i8, v21);
  *(float *)&v55 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v54.f32, 1), *(float *)(a1 + 16), v54.f32[0]);
  LODWORD(v56) = *(_DWORD *)(a1 + 28);
  v57.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v58.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v54.f32, 1), *(float *)&v56, v54.f32[0]);
  v54.f32[0] = *(float *)(a1 + 24) + *(float *)&v55;
  *(float *)v59.f64 = *(float *)v57.i32 + *(float *)v58.i32;
  v54.f32[1] = *(float *)v57.i32 + *(float *)v58.i32;
  *(double *)v62.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v54.i64, v59, v55, v56, v58, v57, v60, v61);
  v89 = v62;
  *(float32x2_t *)v62.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v21);
  *(float *)&v63 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v62.f32, 1), *(float *)(a1 + 16), v62.f32[0]);
  LODWORD(v64) = *(_DWORD *)(a1 + 28);
  v65.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v66.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v62.f32, 1), *(float *)&v64, v62.f32[0]);
  v62.f32[0] = *(float *)(a1 + 24) + *(float *)&v63;
  *(float *)v67.f64 = *(float *)v65.i32 + *(float *)v66.i32;
  v62.f32[1] = *(float *)v65.i32 + *(float *)v66.i32;
  *(double *)v70.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v62.i64, v67, v63, v64, v66, v65, v68, v69);
  v100 = v70;
  *(float32x2_t *)v70.f32 = vadd_f32(*(float32x2_t *)a6.i8, v21);
  *(float *)&v71 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v70.f32, 1), *(float *)(a1 + 16), v70.f32[0]);
  LODWORD(v72) = *(_DWORD *)(a1 + 28);
  v73.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v74.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v70.f32, 1), *(float *)&v72, v70.f32[0]);
  v70.f32[0] = *(float *)(a1 + 24) + *(float *)&v71;
  *(float *)v75.f64 = *(float *)v73.i32 + *(float *)v74.i32;
  v70.f32[1] = *(float *)v73.i32 + *(float *)v74.i32;
  *(double *)v78.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v70.i64, v75, v71, v72, v74, v73, v76, v77);
  v88 = v78;
  *(float32x2_t *)v78.f32 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a6, a6, 8uLL), v21);
  *(float *)&v79 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v78.f32, 1), *(float *)(a1 + 16), v78.f32[0]);
  LODWORD(v80) = *(_DWORD *)(a1 + 28);
  v81.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v82.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v78.f32, 1), *(float *)&v80, v78.f32[0]);
  v78.f32[0] = *(float *)(a1 + 24) + *(float *)&v79;
  *(float *)v83.f64 = *(float *)v81.i32 + *(float *)v82.i32;
  v78.f32[1] = *(float *)v81.i32 + *(float *)v82.i32;
  *(double *)v86.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v78.i64, v83, v79, v80, v82, v81, v84, v85);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(v92, vmulq_n_f32(v91, a7.f32[0])), vmulq_lane_f32(v96, *(float32x2_t *)a7.f32, 1)), vmulq_laneq_f32(v90, a7, 2)), vmulq_laneq_f32(v98, a7, 3)), vmulq_n_f32(v89, a8.f32[0])), vmulq_lane_f32(v100, *(float32x2_t *)a8.f32, 1)), vmulq_laneq_f32(v88, a8, 2)), vmulq_laneq_f32(v86, a8, 3)).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f4_f4_f4_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, __n128, __n128);
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  __n128 *v26;
  __n128 *v27;
  __n128 *v28;
  __n128 *v29;
  __n128 *v30;
  __n128 *v31;
  __int128 v32;
  int v33;
  int v34;
  uint64_t v35;
  int v36;
  double (*v37)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, __n128, __n128);
  int v38;
  uint64_t v39;
  int v40;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, __n128, __n128))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_QWORD *)(v10 + 32);
  v14 = *(_DWORD *)(v10 + 64);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_DWORD *)(v10 + 88);
  v17 = *(_QWORD *)(v10 + 80);
  v18 = *(_DWORD *)(v10 + 112);
  v19 = *(_QWORD *)(v10 + 104);
  v20 = *(_DWORD *)(v10 + 136);
  v21 = *(_QWORD *)(v10 + 128);
  v22 = *(_DWORD *)(v10 + 160);
  v23 = *(_QWORD *)(v10 + 152);
  v24 = *(_DWORD *)(v10 + 184);
  v25 = *(_QWORD *)(v10 + 176);
  if (*(_BYTE *)(a1 + 64))
  {
    v37 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, __n128, __n128))(a1 + 24);
    v39 = *(_QWORD *)(v10 + 8);
    v40 = *(_DWORD *)(v10 + 64);
    v38 = *(_DWORD *)(v10 + 88);
    v36 = *(_DWORD *)(v10 + 112);
    v35 = *(_QWORD *)(v10 + 104);
    v33 = *(_DWORD *)(v10 + 184);
    v34 = *(_DWORD *)(v10 + 160);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 200)), a2);
    v24 = v33;
    v22 = v34;
    v19 = v35;
    v18 = v36;
    v16 = v38;
    v14 = v40;
    v12 = v39;
    v11 = v37;
  }
  v26 = (__n128 *)(a3 + 16 * v25);
  if (v24 != 5)
    v26 = (__n128 *)((char *)a2 + 64 * v25);
  v27 = (__n128 *)(a3 + 16 * v23);
  if (v22 != 5)
    v27 = (__n128 *)((char *)a2 + 64 * v23);
  v28 = (__n128 *)(a3 + 16 * v21);
  if (v20 != 5)
    v28 = (__n128 *)((char *)a2 + 64 * v21);
  v29 = (__n128 *)(a3 + 16 * v19);
  if (v18 != 5)
    v29 = (__n128 *)((char *)a2 + 64 * v19);
  v30 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v30 = (__n128 *)((char *)a2 + 64 * v17);
  v31 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v31 = (__n128 *)((char *)a2 + 64 * v15);
  *(double *)&v32 = v11(a4 + 80 * v12, a4 + 80 * v13, *v31, *v30, *v29, *v28, *v27, *v26);
  *(_OWORD *)(a3 + 16 * a7) = v32;
}

double boundsForPointArray(NSArray *a1)
{
  int v2;
  id v3;
  double v4;
  float v5;
  double v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  id v12;
  double v13;
  float v14;
  double v15;
  float v16;
  float v17;

  v2 = -[NSArray count](a1, "count");
  v3 = -[NSArray objectAtIndex:](a1, "objectAtIndex:", 0);
  objc_msgSend(v3, "X");
  v5 = v4;
  objc_msgSend(v3, "Y");
  v7 = v6;
  if (v2 >= 2)
  {
    v8 = v2;
    v9 = 1;
    v10 = v6;
    v11 = v5;
    while (1)
    {
      v12 = -[NSArray objectAtIndex:](a1, "objectAtIndex:", v9);
      objc_msgSend(v12, "X");
      v14 = v13;
      objc_msgSend(v12, "Y");
      v16 = v15;
      v17 = v5 < v14 ? v14 : v5;
      if (v11 <= v14)
        v5 = v17;
      else
        v11 = v14;
      if (v10 > v16)
        break;
      if (v7 >= v16)
        goto LABEL_12;
LABEL_13:
      ++v9;
      v7 = v16;
      if (v8 == v9)
        return v11;
    }
    v10 = v16;
LABEL_12:
    v16 = v7;
    goto LABEL_13;
  }
  return v5;
}

double disc_multi(double a1, double a2, double a3, double a4, double a5, double a6)
{
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v18;
  double __y;

  v8 = a1;
  v9 = a3 * a5;
  v10 = 0.0;
  v11 = -0.4;
  v12 = 0.0;
  do
  {
    v13 = -0.4;
    v18 = v11;
    __y = a2 + v11 * a6;
    do
    {
      v14 = hypot(v8 + v13 * a6, __y);
      if (v14 < a3)
        v12 = v12 + 0.04;
      if (v14 < v9)
        v10 = v10 + 0.04;
      v8 = a1;
      v13 = v13 + 0.2;
    }
    while (v13 < 0.5);
    v11 = v18 + 0.2;
  }
  while (v18 + 0.2 < 0.5);
  return v10 + (v12 - v10) * (a4 + 1.0);
}

uint64_t disc25(double a1, double a2, double a3, double a4, double a5, double a6)
{
  int v9;
  int v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v19;

  v9 = 0;
  v10 = 0;
  v11 = a3 * a5;
  v12 = -0.4;
  do
  {
    v13 = -0.4;
    v19 = v12;
    v14 = a2 + v12 * a6;
    do
    {
      v15 = hypot(a1 + v13 * a6, v14);
      if (v15 < a3)
        ++v10;
      if (v15 < v11)
        ++v9;
      v13 = v13 + 0.2;
    }
    while (v13 < 0.5);
    v12 = v19 + 0.2;
  }
  while (v19 + 0.2 < 0.5);
  return (int)((double)v10 + (double)(v10 - v9) * a4);
}

uint64_t ConvMap::setValue(uint64_t this, int a2, int a3, int a4)
{
  int v4;
  int v5;
  int v6;
  int v8;

  if (a4 | a3)
  {
    if (a3 >= 0)
      v4 = a3;
    else
      v4 = -a3;
    if (a4 >= 0)
      v5 = a4;
    else
      v5 = -a4;
    v6 = *(_DWORD *)(this + 16);
    if (v4 <= v6 && v5 <= v6)
    {
      if (a4)
        v8 = v4;
      else
        v8 = 0;
      if (a4)
        v4 = v5;
      *(_DWORD *)(*(_QWORD *)(this + 8) + 4 * (v4 - 1 + (v4 - 1) * v6 + v8)) = a2;
    }
  }
  else
  {
    *(_DWORD *)this = a2;
  }
  return this;
}

uint64_t ConvMap::value(ConvMap *this, int a2, int a3)
{
  int v3;
  int v4;
  int v5;
  int v8;

  if (!(a3 | a2))
    return *(unsigned int *)this;
  if (a2 >= 0)
    v3 = a2;
  else
    v3 = -a2;
  if (a3 >= 0)
    v4 = a3;
  else
    v4 = -a3;
  v5 = *((_DWORD *)this + 4);
  if (v3 > v5 || v4 > v5)
    return 0;
  if (a3)
    v8 = v3;
  else
    v8 = 0;
  if (a3)
    v3 = v4;
  return *(unsigned int *)(*((_QWORD *)this + 1) + 4 * (v3 - 1 + (v3 - 1) * v5 + v8));
}

_DWORD *ConvMap::subtract(_DWORD *this, int a2, int a3)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  int v7;
  int v8;

  if (a2)
  {
    v4 = (uint64_t)this;
    *this -= a2;
    if (a3 >= 2)
    {
      v5 = a3 >> 1;
      v6 = (a3 >> 1) + 1;
      v7 = 1;
      do
      {
        v8 = 0;
        do
          this = (_DWORD *)ConvMap::subtract(v4, a2, v8++, v7);
        while (v6 != v8);
      }
      while (v7++ != v5);
    }
  }
  return this;
}

uint64_t ConvMap::bestValue(ConvMap *this, int a2, int a3, int a4)
{
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v29;

  if (a4 >= 0)
    v8 = a4;
  else
    v8 = a4 + 1;
  v9 = ConvMap::value(this, a2, a3);
  if ((_DWORD)v9 && a4 != 1)
  {
    v10 = v8 >> 1;
    if (a4 == 3)
    {
      v11 = a3 - v10;
      v12 = v10 + a3;
      if (v11 <= v12)
      {
        v16 = 0;
        v17 = a2 - v10;
        v18 = v10 + a2;
        v19 = (2 * v10) | 1;
        do
        {
          v20 = v19;
          v21 = v17;
          if (v17 <= v18)
          {
            do
            {
              if ((_DWORD)v9 == ConvMap::value(this, v21, v11))
                ++v16;
              ++v21;
              --v20;
            }
            while (v20);
          }
          v22 = v11++ == v12;
        }
        while (!v22);
        if (v16 <= 4)
          return 0;
        else
          return v9;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      v29 = 6 * a4 * a4 / 9;
      v13 = a3 - v10;
      v14 = v10 + a3;
      if (a3 - v10 <= v10 + a3)
      {
        v15 = 0;
        v23 = a2 - v10;
        v24 = v10 + a2;
        v25 = (2 * v10) | 1;
        do
        {
          v26 = v25;
          v27 = v23;
          if (v23 <= v24)
          {
            do
            {
              if ((_DWORD)v9 == ConvMap::value(this, v27, v13))
                ++v15;
              ++v27;
              --v26;
            }
            while (v26);
          }
          v22 = v13++ == v14;
        }
        while (!v22);
      }
      else
      {
        v15 = 0;
      }
      if (v15 >= v29)
        return v9;
      else
        return 0;
    }
  }
  return v9;
}

uint64_t ConvMap::subtract(uint64_t this, int a2, int a3, int a4, int a5)
{
  int v5;
  int v6;
  int v7;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;

  if (a2)
  {
    v5 = a5 >= 0 ? a5 : a5 + 1;
    v6 = a4 - (v5 >> 1);
    v7 = a4 + (v5 >> 1);
    if (v6 <= v7)
    {
      v9 = this;
      v10 = v5 >> 1;
      v11 = a3 - v10;
      v12 = v10 + a3;
      v13 = (2 * v10) | 1;
      do
      {
        v14 = v13;
        v15 = v11;
        if (v11 <= v12)
        {
          do
          {
            this = ConvMap::subtract(v9, a2, v15++, v6);
            --v14;
          }
          while (v14);
        }
      }
      while (v6++ != v7);
    }
  }
  return this;
}

uint64_t ConvMap::subtract(uint64_t this, int a2, int a3, int a4)
{
  int v4;
  int v5;
  int v6;
  int v7;

  if (a2)
  {
    if (a4 | a3)
    {
      if (a4 >= 0)
        v4 = a4;
      else
        v4 = a3;
      if (a4 < 0)
        v5 = -a4;
      else
        v5 = a3;
      if (a3 < 0)
      {
        v4 = -a3;
        v5 = a4;
      }
      if ((a4 & a3) < 0)
      {
        v4 = -a4;
        v5 = -a3;
      }
      if (!v4)
      {
        v4 = v5;
        v5 = 0;
      }
      v6 = *(_DWORD *)(this + 16);
      if (v5 <= v6 && v4 <= v6)
      {
        v7 = v4 - 1 + (v4 - 1) * v6 + v5;
        *(_DWORD *)(*(_QWORD *)(this + 8) + 4 * v7) -= a2;
      }
    }
    else
    {
      *(_DWORD *)this -= a2;
    }
  }
  return this;
}

double ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke(_OWORD *a1, double a2, double a3, double a4, double a5)
{
  __int128 v5;
  double result;
  CGAffineTransform v7;
  CGRect v8;

  v5 = a1[3];
  *(_OWORD *)&v7.a = a1[2];
  *(_OWORD *)&v7.c = v5;
  *(_OWORD *)&v7.tx = a1[4];
  v8 = CGRectApplyAffineTransform(*(CGRect *)&a2, &v7);
  *(_QWORD *)&result = (unint64_t)CGRectInset(v8, -1.0, -1.0);
  return result;
}

double ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_2(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double result;

  *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&a2, (double)-*(_DWORD *)(a1 + 32), (double)-*(_DWORD *)(a1 + 32));
  return result;
}

double ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_3(uint64_t a1, int a2, double result, double a4, double a5, double a6)
{
  if (a2)
    *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&result, (float)-*(float *)(a1 + 32), (float)-*(float *)(a1 + 32));
  return result;
}

double ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_4(uint64_t a1, int a2, double result, double a4, double a5, double a6)
{
  if (a2)
    *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&result, (float)-*(float *)(a1 + 32), (float)-*(float *)(a1 + 32));
  return result;
}

double ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_5(uint64_t a1, int a2, double result, double a4, double a5, double a6)
{
  if (a2)
    *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&result, (float)-*(float *)(a1 + 32), (float)-*(float *)(a1 + 32));
  return result;
}

double ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_6(uint64_t a1, int a2, double result, double a4, double a5, double a6)
{
  if (a2)
    *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&result, (float)-*(float *)(a1 + 32), (float)-*(float *)(a1 + 32));
  return result;
}

double ___ZL11applyRecipeP7NSArrayP7CIImage_block_invoke_7(uint64_t a1, int a2, double result, double a4, double a5, double a6)
{
  if (a2)
    *(_QWORD *)&result = (unint64_t)CGRectInset(*(CGRect *)&result, (float)-*(float *)(a1 + 32), (float)-*(float *)(a1 + 32));
  return result;
}

double cikernel::_downhalf(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float32x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  float64x2_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  double v26;
  uint8x8_t v27;
  float64x2_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x2_t v31;
  double v32;
  double v33;
  int8x16_t v34;
  double v35;
  uint8x8_t v36;
  float64x2_t v37;
  int8x16_t v38;
  float32x4_t v39;
  double result;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;

  DC = (float32x2_t *)CI::getDC(this);
  v4 = vadd_f32(*DC, *DC);
  v5 = vadd_f32(v4, (float32x2_t)3212836864);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v10, v6, v7, v9, v8, v11, v12);
  v46 = v13;
  *(float32x2_t *)v13.f32 = vadd_f32(v4, (float32x2_t)1065353216);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v15) = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  v22 = vadd_f32(v4, (float32x2_t)0x3F80000000000000);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v22, 1), *((float *)this + 4), v22.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 6);
  v25.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v26) = *((_DWORD *)this + 9);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v22, 1), *(float *)v25.i32, v22.f32[0]);
  v28 = (float64x2_t)v46;
  v47 = vaddq_f32(v46, v21);
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  *(float *)v28.f64 = *(float *)&v26 + *(float *)v27.i32;
  v21.f32[1] = *(float *)&v26 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v21.i64, v28, v24, v23, v25, v27, v26, v29);
  v31 = vadd_f32(v4, (float32x2_t)0xBF80000000000000);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v31, 1), *((float *)this + 4), v31.f32[0]);
  LODWORD(v33) = *((_DWORD *)this + 6);
  v34.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v35) = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v31, 1), *(float *)v34.i32, v31.f32[0]);
  v37 = (float64x2_t)v47;
  v48 = vaddq_f32(v47, v30);
  v30.f32[0] = *(float *)&v33 + *(float *)&v32;
  *(float *)v37.f64 = *(float *)&v35 + *(float *)v36.i32;
  v30.f32[1] = *(float *)&v35 + *(float *)v36.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v30.i64, v37, v33, v32, v34, v36, v35, v38);
  __asm { FMOV            V1.4S, #0.25 }
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v48, v39), _Q1).u64[0];
  return result;
}

double cikernel::_box3(cikernel *this, SamplerObj *a2, double a3)
{
  float32x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  float64x2_t v10;
  int8x16_t v11;
  float32x4_t v12;
  float32x2_t v13;
  double v14;
  double v15;
  int8x16_t v16;
  double v17;
  uint8x8_t v18;
  int8x16_t v19;
  float32x4_t v20;
  double v21;
  float32x2_t v22;
  double v23;
  int8x16_t v24;
  double v25;
  uint8x8_t v26;
  float64x2_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x2_t v30;
  double v31;
  double v32;
  int8x16_t v33;
  double v34;
  uint8x8_t v35;
  float64x2_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x2_t v39;
  double v40;
  double v41;
  int8x16_t v42;
  double v43;
  uint8x8_t v44;
  float64x2_t v45;
  int8x16_t v46;
  float32x4_t v47;
  float32x2_t v48;
  double v49;
  float32x2_t v50;
  double v51;
  int8x16_t v52;
  double v53;
  uint8x8_t v54;
  float64x2_t v55;
  int8x16_t v56;
  float32x4_t v57;
  double v58;
  float32x2_t v59;
  double v60;
  int8x16_t v61;
  double v62;
  uint8x8_t v63;
  float64x2_t v64;
  int8x16_t v65;
  float32x4_t v66;
  double v67;
  float32x2_t v68;
  double v69;
  int8x16_t v70;
  double v71;
  uint8x8_t v72;
  float64x2_t v73;
  int8x16_t v74;
  float32x4_t v75;
  float32x2_t v76;
  double v77;
  double v78;
  int8x16_t v79;
  double v80;
  uint8x8_t v81;
  float64x2_t v82;
  int8x16_t v83;
  float32x4_t v84;
  double result;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  double v96;
  float32x4_t v97;
  float32x4_t v98;
  int32x2_t v99;
  float32x4_t v100;

  v99 = *(int32x2_t *)&a3;
  *(float *)&a3 = -*(float *)&a3;
  v96 = a3;
  v4 = *(float32x2_t *)CI::getDC(this);
  v5 = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&v96, 0), v4);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v10, v6, v7, v9, v8, v96, v11);
  v13 = vadd_f32((float32x2_t)LODWORD(v96), v4);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v13, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v15) = *((_DWORD *)this + 6);
  v16.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v17) = *((_DWORD *)this + 9);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v13, 1), *(float *)v16.i32, v13.f32[0]);
  v91 = vaddq_f32(v12, (float32x4_t)0);
  v12.f32[0] = *(float *)&v15 + *(float *)&v14;
  v12.f32[1] = *(float *)&v17 + *(float *)v18.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)&v17 + *(float *)v18.i32), v15, v14, v16, v18, v17, v19);
  HIDWORD(v21) = v99.i32[1];
  v22 = vadd_f32((float32x2_t)__PAIR64__(v99.u32[0], LODWORD(v96)), v4);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v22, 1), *((float *)this + 4), v22.f32[0]);
  LODWORD(v21) = *((_DWORD *)this + 6);
  v24.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v25) = *((_DWORD *)this + 9);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v22, 1), *(float *)v24.i32, v22.f32[0]);
  v27 = (float64x2_t)v91;
  v92 = vaddq_f32(v91, v20);
  v20.f32[0] = *(float *)&v21 + *(float *)&v23;
  *(float *)v27.f64 = *(float *)&v25 + *(float *)v26.i32;
  v20.f32[1] = *(float *)&v25 + *(float *)v26.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v20.i64, v27, v21, v23, v24, v26, v25, v28);
  v30 = vadd_f32((float32x2_t)vrev64_s32((int32x2_t)LODWORD(v96)), v4);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v30, 1), *((float *)this + 4), v30.f32[0]);
  LODWORD(v32) = *((_DWORD *)this + 6);
  v33.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v34) = *((_DWORD *)this + 9);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v30, 1), *(float *)v33.i32, v30.f32[0]);
  v36 = (float64x2_t)v92;
  v93 = vaddq_f32(v92, v29);
  v29.f32[0] = *(float *)&v32 + *(float *)&v31;
  *(float *)v36.f64 = *(float *)&v34 + *(float *)v35.i32;
  v29.f32[1] = *(float *)&v34 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v29.i64, v36, v32, v31, v33, v35, v34, v37);
  v39 = vadd_f32(v4, 0);
  *(float *)&v40 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v39, 1), *((float *)this + 4), v39.f32[0]);
  LODWORD(v41) = *((_DWORD *)this + 6);
  v42.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v43) = *((_DWORD *)this + 9);
  *(float *)v44.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v39, 1), *(float *)v42.i32, v39.f32[0]);
  v45 = (float64x2_t)v93;
  v94 = vaddq_f32(v93, v38);
  v38.f32[0] = *(float *)&v41 + *(float *)&v40;
  *(float *)v45.f64 = *(float *)&v43 + *(float *)v44.i32;
  v38.f32[1] = *(float *)&v43 + *(float *)v44.i32;
  *(double *)v47.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v38.i64, v45, v41, v40, v42, v44, v43, v46);
  v48.i32[0] = 0;
  HIDWORD(v49) = v99.i32[1];
  v48.i32[1] = v99.i32[0];
  v50 = vadd_f32(v48, v4);
  *(float *)&v51 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v50, 1), *((float *)this + 4), v50.f32[0]);
  LODWORD(v49) = *((_DWORD *)this + 6);
  v52.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v53) = *((_DWORD *)this + 9);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v50, 1), *(float *)v52.i32, v50.f32[0]);
  v55 = (float64x2_t)v94;
  v95 = vaddq_f32(v94, v47);
  v47.f32[0] = *(float *)&v49 + *(float *)&v51;
  *(float *)v55.f64 = *(float *)&v53 + *(float *)v54.i32;
  v47.f32[1] = *(float *)&v53 + *(float *)v54.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v47.i64, v55, v49, v51, v52, v54, v53, v56);
  HIDWORD(v58) = HIDWORD(v96);
  v59 = vadd_f32((float32x2_t)__PAIR64__(LODWORD(v96), v99.u32[0]), v4);
  *(float *)&v60 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v59, 1), *((float *)this + 4), v59.f32[0]);
  LODWORD(v58) = *((_DWORD *)this + 6);
  v61.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v62) = *((_DWORD *)this + 9);
  *(float *)v63.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v59, 1), *(float *)v61.i32, v59.f32[0]);
  v64 = (float64x2_t)v95;
  v97 = vaddq_f32(v95, v57);
  v57.f32[0] = *(float *)&v58 + *(float *)&v60;
  *(float *)v64.f64 = *(float *)&v62 + *(float *)v63.i32;
  v57.f32[1] = *(float *)&v62 + *(float *)v63.i32;
  *(double *)v66.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v57.i64, v64, v58, v60, v61, v63, v62, v65);
  *(_QWORD *)&v67 = v99.u32[0];
  v68 = vadd_f32((float32x2_t)v99.u32[0], v4);
  *(float *)&v69 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v68, 1), *((float *)this + 4), v68.f32[0]);
  LODWORD(v67) = *((_DWORD *)this + 6);
  v70.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v71) = *((_DWORD *)this + 9);
  *(float *)v72.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v68, 1), *(float *)v70.i32, v68.f32[0]);
  v73 = (float64x2_t)v97;
  v98 = vaddq_f32(v97, v66);
  v66.f32[0] = *(float *)&v67 + *(float *)&v69;
  *(float *)v73.f64 = *(float *)&v71 + *(float *)v72.i32;
  v66.f32[1] = *(float *)&v71 + *(float *)v72.i32;
  *(double *)v75.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v66.i64, v73, v67, v69, v70, v72, v71, v74);
  v76 = vadd_f32((float32x2_t)vdup_lane_s32(v99, 0), v4);
  *(float *)&v77 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v76, 1), *((float *)this + 4), v76.f32[0]);
  LODWORD(v78) = *((_DWORD *)this + 6);
  v79.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v80) = *((_DWORD *)this + 9);
  *(float *)v81.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v76, 1), *(float *)v79.i32, v76.f32[0]);
  v82 = (float64x2_t)v98;
  v100 = vaddq_f32(v98, v75);
  v75.f32[0] = *(float *)&v78 + *(float *)&v77;
  *(float *)v82.f64 = *(float *)&v80 + *(float *)v81.i32;
  v75.f32[1] = *(float *)&v80 + *(float *)v81.i32;
  *(double *)v84.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v75.i64, v82, v78, v77, v79, v81, v80, v83);
  __asm { FMOV            V1.4S, #9.0 }
  *(_QWORD *)&result = vdivq_f32(vaddq_f32(v100, v84), _Q1).u64[0];
  return result;
}

double cikernel::_add4(uint64_t a1, uint64_t a2, float32x2_t a3, double a4)
{
  int8x8_t v7;
  float32x2_t v8;
  float32x2_t v9;
  double v10;
  double v11;
  uint8x8_t v12;
  int8x16_t v13;
  float64x2_t v14;
  double v15;
  int8x16_t v16;
  float32x4_t v17;
  float32x2_t v18;
  double v19;
  double v20;
  int8x16_t v21;
  double v22;
  uint8x8_t v23;
  int8x16_t v24;
  float32x4_t v25;
  float32x2_t v26;
  double v27;
  double v28;
  int8x16_t v29;
  double v30;
  uint8x8_t v31;
  float64x2_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float32x2_t v35;
  double v36;
  double v37;
  int8x16_t v38;
  double v39;
  uint8x8_t v40;
  float64x2_t v41;
  int8x16_t v42;
  float32x4_t v43;
  CI *v44;
  float32x2_t *DC;
  double v46;
  double v47;
  uint8x8_t v48;
  int8x16_t v49;
  double v50;
  float64x2_t v51;
  double v52;
  int8x16_t v53;
  float32x4_t v54;
  double result;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;

  v7 = (int8x8_t)vneg_f32(a3);
  v8 = *(float32x2_t *)CI::getDC((CI *)a1);
  v9 = vadd_f32(a3, v8);
  *(float *)&v10 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v9, 1), *(float *)(a2 + 16), v9.f32[0]);
  LODWORD(v11) = *(_DWORD *)(a2 + 28);
  v12.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v9, 1), *(float *)&v11, v9.f32[0]);
  v9.f32[0] = *(float *)(a2 + 24) + *(float *)&v10;
  *(float *)v14.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  v9.f32[1] = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v9, v14, v10, v11, v13, v12, v15, v16);
  v18 = vadd_f32((float32x2_t)vext_s8((int8x8_t)a3, v7, 4uLL), v8);
  *(float *)&v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v18, 1), *(float *)(a2 + 16), v18.f32[0]);
  LODWORD(v20) = *(_DWORD *)(a2 + 24);
  v21.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v22) = *(_DWORD *)(a2 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v18, 1), *(float *)v21.i32, v18.f32[0]);
  v56 = vaddq_f32(v17, (float32x4_t)0);
  v17.f32[0] = *(float *)&v20 + *(float *)&v19;
  v17.f32[1] = *(float *)&v22 + *(float *)v23.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v17.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)&v22 + *(float *)v23.i32), v20, v19, v21, v23, v22, v24);
  v26 = vsub_f32(v8, a3);
  *(float *)&v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v26, 1), *(float *)(a2 + 16), v26.f32[0]);
  LODWORD(v28) = *(_DWORD *)(a2 + 24);
  v29.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v30) = *(_DWORD *)(a2 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v26, 1), *(float *)v29.i32, v26.f32[0]);
  v32 = (float64x2_t)v56;
  v57 = vaddq_f32(v56, v25);
  v25.f32[0] = *(float *)&v28 + *(float *)&v27;
  *(float *)v32.f64 = *(float *)&v30 + *(float *)v31.i32;
  v25.f32[1] = *(float *)&v30 + *(float *)v31.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v25.i64, v32, v28, v27, v29, v31, v30, v33);
  v35 = vadd_f32((float32x2_t)vext_s8(v7, (int8x8_t)a3, 4uLL), v8);
  *(float *)&v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v35, 1), *(float *)(a2 + 16), v35.f32[0]);
  LODWORD(v37) = *(_DWORD *)(a2 + 24);
  v38.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v39) = *(_DWORD *)(a2 + 36);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v35, 1), *(float *)v38.i32, v35.f32[0]);
  v41 = (float64x2_t)v57;
  v58 = vaddq_f32(v57, v34);
  v34.f32[0] = *(float *)&v37 + *(float *)&v36;
  *(float *)v41.f64 = *(float *)&v39 + *(float *)v40.i32;
  v34.f32[1] = *(float *)&v39 + *(float *)v40.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v34.i64, v41, v37, v36, v38, v40, v39, v42);
  v59 = vmulq_lane_f32(vaddq_f32(v58, v43), *(float32x2_t *)&a4, 1);
  DC = (float32x2_t *)CI::getDC(v44);
  *(float *)&v46 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v47) = *(_DWORD *)(a1 + 28);
  v48.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v47, COERCE_FLOAT(*DC));
  *(float *)&v50 = *(float *)(a1 + 24) + *(float *)&v46;
  *(float *)v51.f64 = *(float *)v48.i32 + *(float *)v49.i32;
  *((float *)&v50 + 1) = *(float *)v48.i32 + *(float *)v49.i32;
  *(double *)v54.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v50, v51, v46, v47, v49, v48, v52, v53);
  *(_QWORD *)&result = vaddq_f32(v59, vmulq_n_f32(v54, *(float *)&a4)).u64[0];
  return result;
}

double cikernel::_add8(uint64_t a1, uint64_t a2, float32x2_t a3, double a4)
{
  float32x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  float64x2_t v12;
  double v13;
  int8x16_t v14;
  float32x4_t v15;
  double v16;
  float32x2_t v17;
  double v18;
  int8x16_t v19;
  double v20;
  uint8x8_t v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x2_t v24;
  double v25;
  double v26;
  int8x16_t v27;
  double v28;
  uint8x8_t v29;
  float64x2_t v30;
  int8x16_t v31;
  float32x4_t v32;
  double v33;
  float32x2_t v34;
  double v35;
  int8x16_t v36;
  double v37;
  uint8x8_t v38;
  float64x2_t v39;
  int8x16_t v40;
  float32x4_t v41;
  float32x2_t v42;
  double v43;
  double v44;
  int8x16_t v45;
  double v46;
  uint8x8_t v47;
  float64x2_t v48;
  int8x16_t v49;
  float32x4_t v50;
  double v51;
  float32x2_t v52;
  double v53;
  int8x16_t v54;
  double v55;
  uint8x8_t v56;
  float64x2_t v57;
  int8x16_t v58;
  float32x4_t v59;
  float32x2_t v60;
  double v61;
  double v62;
  int8x16_t v63;
  double v64;
  uint8x8_t v65;
  float64x2_t v66;
  int8x16_t v67;
  float32x4_t v68;
  double v69;
  float32x2_t v70;
  double v71;
  int8x16_t v72;
  double v73;
  uint8x8_t v74;
  float64x2_t v75;
  int8x16_t v76;
  float32x4_t v77;
  CI *v78;
  float32x2_t *DC;
  double v80;
  double v81;
  uint8x8_t v82;
  int8x16_t v83;
  double v84;
  float64x2_t v85;
  double v86;
  int8x16_t v87;
  float32x4_t v88;
  double result;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  int32x2_t v97;
  float32x4_t v99;
  float32x4_t v100;

  v97 = (int32x2_t)vneg_f32(a3);
  v6 = *(float32x2_t *)CI::getDC((CI *)a1);
  v7 = vadd_f32(a3, v6);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v7, 1), *(float *)(a2 + 16), v7.f32[0]);
  LODWORD(v9) = *(_DWORD *)(a2 + 28);
  v10.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *(float *)(a2 + 24) + *(float *)&v8;
  *(float *)v12.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v7, v12, v8, v9, v11, v10, v13, v14);
  HIDWORD(v16) = a3.i32[1];
  v17 = vadd_f32((float32x2_t)vext_s8((int8x8_t)a3, (int8x8_t)v97, 4uLL), v6);
  *(float *)&v18 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v17, 1), *(float *)(a2 + 16), v17.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a2 + 24);
  v19.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v20) = *(_DWORD *)(a2 + 36);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v17, 1), *(float *)v19.i32, v17.f32[0]);
  v90 = vaddq_f32(v15, (float32x4_t)0);
  v15.f32[0] = *(float *)&v16 + *(float *)&v18;
  v15.f32[1] = *(float *)&v20 + *(float *)v21.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v15.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)&v20 + *(float *)v21.i32), v16, v18, v19, v21, v20, v22);
  v24 = vsub_f32(v6, a3);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v24, 1), *(float *)(a2 + 16), v24.f32[0]);
  LODWORD(v26) = *(_DWORD *)(a2 + 24);
  v27.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v28) = *(_DWORD *)(a2 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v24, 1), *(float *)v27.i32, v24.f32[0]);
  v30 = (float64x2_t)v90;
  v91 = vaddq_f32(v90, v23);
  v23.f32[0] = *(float *)&v26 + *(float *)&v25;
  *(float *)v30.f64 = *(float *)&v28 + *(float *)v29.i32;
  v23.f32[1] = *(float *)&v28 + *(float *)v29.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v23.i64, v30, v26, v25, v27, v29, v28, v31);
  HIDWORD(v33) = a3.i32[1];
  v34 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v97, (int8x8_t)a3, 4uLL), v6);
  *(float *)&v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v34, 1), *(float *)(a2 + 16), v34.f32[0]);
  LODWORD(v33) = *(_DWORD *)(a2 + 24);
  v36.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v37) = *(_DWORD *)(a2 + 36);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v34, 1), *(float *)v36.i32, v34.f32[0]);
  v39 = (float64x2_t)v91;
  v92 = vaddq_f32(v91, v32);
  v32.f32[0] = *(float *)&v33 + *(float *)&v35;
  *(float *)v39.f64 = *(float *)&v37 + *(float *)v38.i32;
  v32.f32[1] = *(float *)&v37 + *(float *)v38.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v32.i64, v39, v33, v35, v36, v38, v37, v40);
  v42 = vadd_f32((float32x2_t)vrev64_s32((int32x2_t)a3), v6);
  *(float *)&v43 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v42, 1), *(float *)(a2 + 16), v42.f32[0]);
  LODWORD(v44) = *(_DWORD *)(a2 + 24);
  v45.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v46) = *(_DWORD *)(a2 + 36);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v42, 1), *(float *)v45.i32, v42.f32[0]);
  v48 = (float64x2_t)v92;
  v93 = vaddq_f32(v92, v41);
  v41.f32[0] = *(float *)&v44 + *(float *)&v43;
  *(float *)v48.f64 = *(float *)&v46 + *(float *)v47.i32;
  v41.f32[1] = *(float *)&v46 + *(float *)v47.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v41.i64, v48, v44, v43, v45, v47, v46, v49);
  HIDWORD(v51) = a3.i32[1];
  v52 = vadd_f32((float32x2_t)__PAIR64__(a3.u32[1], v97.u32[0]), v6);
  *(float *)&v53 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v52, 1), *(float *)(a2 + 16), v52.f32[0]);
  LODWORD(v51) = *(_DWORD *)(a2 + 24);
  v54.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v55) = *(_DWORD *)(a2 + 36);
  *(float *)v56.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v52, 1), *(float *)v54.i32, v52.f32[0]);
  v57 = (float64x2_t)v93;
  v94 = vaddq_f32(v93, v50);
  v50.f32[0] = *(float *)&v51 + *(float *)&v53;
  *(float *)v57.f64 = *(float *)&v55 + *(float *)v56.i32;
  v50.f32[1] = *(float *)&v55 + *(float *)v56.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v50.i64, v57, v51, v53, v54, v56, v55, v58);
  v60 = vadd_f32((float32x2_t)vrev64_s32(v97), v6);
  *(float *)&v61 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v60, 1), *(float *)(a2 + 16), v60.f32[0]);
  LODWORD(v62) = *(_DWORD *)(a2 + 24);
  v63.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v64) = *(_DWORD *)(a2 + 36);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v60, 1), *(float *)v63.i32, v60.f32[0]);
  v66 = (float64x2_t)v94;
  v95 = vaddq_f32(v94, v59);
  v59.f32[0] = *(float *)&v62 + *(float *)&v61;
  *(float *)v66.f64 = *(float *)&v64 + *(float *)v65.i32;
  v59.f32[1] = *(float *)&v64 + *(float *)v65.i32;
  *(double *)v68.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v59.i64, v66, v62, v61, v63, v65, v64, v67);
  HIDWORD(v69) = v97.i32[1];
  v70 = vadd_f32((float32x2_t)__PAIR64__(v97.u32[1], a3.u32[0]), v6);
  *(float *)&v71 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v70, 1), *(float *)(a2 + 16), v70.f32[0]);
  LODWORD(v69) = *(_DWORD *)(a2 + 24);
  v72.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v73) = *(_DWORD *)(a2 + 36);
  *(float *)v74.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v70, 1), *(float *)v72.i32, v70.f32[0]);
  v75 = (float64x2_t)v95;
  v99 = vaddq_f32(v95, v68);
  v68.f32[0] = *(float *)&v69 + *(float *)&v71;
  *(float *)v75.f64 = *(float *)&v73 + *(float *)v74.i32;
  v68.f32[1] = *(float *)&v73 + *(float *)v74.i32;
  *(double *)v77.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v68.i64, v75, v69, v71, v72, v74, v73, v76);
  v100 = vmulq_lane_f32(vaddq_f32(v99, v77), *(float32x2_t *)&a4, 1);
  DC = (float32x2_t *)CI::getDC(v78);
  *(float *)&v80 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v81) = *(_DWORD *)(a1 + 28);
  v82.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v83.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v81, COERCE_FLOAT(*DC));
  *(float *)&v84 = *(float *)(a1 + 24) + *(float *)&v80;
  *(float *)v85.f64 = *(float *)v82.i32 + *(float *)v83.i32;
  *((float *)&v84 + 1) = *(float *)v82.i32 + *(float *)v83.i32;
  *(double *)v88.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v84, v85, v80, v81, v83, v82, v86, v87);
  *(_QWORD *)&result = vaddq_f32(v100, vmulq_n_f32(v88, *(float *)&a4)).u64[0];
  return result;
}

double cikernel::_add4and4(uint64_t a1, uint64_t a2, int8x16_t a3, float32x4_t a4)
{
  int8x8_t v6;
  float32x2_t v7;
  float32x2_t v8;
  double v9;
  double v10;
  uint8x8_t v11;
  int8x16_t v12;
  float64x2_t v13;
  double v14;
  int8x16_t v15;
  float32x4_t v16;
  double v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  float64x2_t v21;
  double v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x2_t v25;
  double v26;
  double v27;
  int8x16_t v28;
  double v29;
  uint8x8_t v30;
  float64x2_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x2_t v34;
  double v35;
  double v36;
  int8x16_t v37;
  double v38;
  uint8x8_t v39;
  float64x2_t v40;
  int8x16_t v41;
  float32x4_t v42;
  int8x16_t v43;
  float32x2_t v44;
  int8x16_t v45;
  double v46;
  int8x16_t v47;
  double v48;
  uint8x8_t v49;
  int8x8_t v50;
  float32x4_t v51;
  double v52;
  double v53;
  uint8x8_t v54;
  int8x16_t v55;
  float64x2_t v56;
  double v57;
  int8x16_t v58;
  float32x4_t v59;
  float32x2_t v60;
  double v61;
  double v62;
  int8x16_t v63;
  double v64;
  uint8x8_t v65;
  float64x2_t v66;
  int8x16_t v67;
  float32x4_t v68;
  float32x2_t v69;
  double v70;
  double v71;
  int8x16_t v72;
  double v73;
  uint8x8_t v74;
  float64x2_t v75;
  int8x16_t v76;
  float32x4_t v77;
  CI *v78;
  float32x2_t *DC;
  double v80;
  double v81;
  uint8x8_t v82;
  int8x16_t v83;
  double v84;
  float64x2_t v85;
  double v86;
  int8x16_t v87;
  float32x4_t v88;
  double result;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  int8x16_t v97;
  float32x4_t v98;
  float32x4_t v99;

  v97 = a3;
  v6 = (int8x8_t)vneg_f32(*(float32x2_t *)a3.i8);
  v7 = *(float32x2_t *)CI::getDC((CI *)a1);
  v8 = vadd_f32(*(float32x2_t *)v97.i8, v7);
  *(float *)&v9 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v8, 1), *(float *)(a2 + 16), v8.f32[0]);
  LODWORD(v10) = *(_DWORD *)(a2 + 28);
  v11.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v8, 1), *(float *)&v10, v8.f32[0]);
  v8.f32[0] = *(float *)(a2 + 24) + *(float *)&v9;
  *(float *)v13.f64 = *(float *)v11.i32 + *(float *)v12.i32;
  v8.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v8, v13, v9, v10, v12, v11, v14, v15);
  v92 = v16;
  *(float32x2_t *)v16.f32 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v97.i8, v6, 4uLL), v7);
  *(float *)&v17 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v16.f32, 1), *(float *)(a2 + 16), v16.f32[0]);
  LODWORD(v18) = *(_DWORD *)(a2 + 28);
  v19.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v16.f32, 1), *(float *)&v18, v16.f32[0]);
  v16.f32[0] = *(float *)(a2 + 24) + *(float *)&v17;
  *(float *)v21.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v16.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v16.i64, v21, v17, v18, v20, v19, v22, v23);
  v25 = vsub_f32(v7, *(float32x2_t *)v97.i8);
  *(float *)&v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v25, 1), *(float *)(a2 + 16), v25.f32[0]);
  LODWORD(v27) = *(_DWORD *)(a2 + 24);
  v28.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v29) = *(_DWORD *)(a2 + 36);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v25, 1), *(float *)v28.i32, v25.f32[0]);
  v31 = (float64x2_t)v92;
  v93 = vaddq_f32(v92, v24);
  v24.f32[0] = *(float *)&v27 + *(float *)&v26;
  *(float *)v31.f64 = *(float *)&v29 + *(float *)v30.i32;
  v24.f32[1] = *(float *)&v29 + *(float *)v30.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v24.i64, v31, v27, v26, v28, v30, v29, v32);
  v34 = vadd_f32((float32x2_t)vext_s8(v6, *(int8x8_t *)v97.i8, 4uLL), v7);
  *(float *)&v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v34, 1), *(float *)(a2 + 16), v34.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a2 + 24);
  v37.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v38) = *(_DWORD *)(a2 + 36);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v34, 1), *(float *)v37.i32, v34.f32[0]);
  v40 = (float64x2_t)v93;
  v94 = vaddq_f32(v93, v33);
  v33.f32[0] = *(float *)&v36 + *(float *)&v35;
  *(float *)v40.f64 = *(float *)&v38 + *(float *)v39.i32;
  v33.f32[1] = *(float *)&v38 + *(float *)v39.i32;
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v33.i64, v40, v36, v35, v37, v39, v38, v41);
  v43 = vextq_s8(v97, v97, 8uLL);
  v44 = vadd_f32(*(float32x2_t *)v43.i8, v7);
  v45 = v43;
  v97.i64[0] = v43.i64[0];
  *(float *)&v46 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v44, 1), *(float *)(a2 + 16), v44.f32[0]);
  v43.i32[0] = *(_DWORD *)(a2 + 24);
  v47.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v48) = *(_DWORD *)(a2 + 36);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v44, 1), *(float *)v47.i32, v44.f32[0]);
  v95 = vaddq_f32(vmulq_lane_f32(vaddq_f32(v94, v42), *(float32x2_t *)a4.f32, 1), (float32x4_t)0);
  v50 = (int8x8_t)vneg_f32(*(float32x2_t *)v45.i8);
  v42.f32[0] = *(float *)v43.i32 + *(float *)&v46;
  v42.f32[1] = *(float *)&v48 + *(float *)v49.i32;
  *(double *)v51.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v42.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)&v48 + *(float *)v49.i32), *(double *)v43.i64, v46, v47, v49, v48, v45);
  v90 = v51;
  *(float32x2_t *)v51.f32 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v97.i8, v50, 4uLL), v7);
  *(float *)&v52 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v51.f32, 1), *(float *)(a2 + 16), v51.f32[0]);
  LODWORD(v53) = *(_DWORD *)(a2 + 28);
  v54.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v55.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v51.f32, 1), *(float *)&v53, v51.f32[0]);
  v51.f32[0] = *(float *)(a2 + 24) + *(float *)&v52;
  *(float *)v56.f64 = *(float *)v54.i32 + *(float *)v55.i32;
  v51.f32[1] = *(float *)v54.i32 + *(float *)v55.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v51.i64, v56, v52, v53, v55, v54, v57, v58);
  v60 = vsub_f32(v7, *(float32x2_t *)v97.i8);
  *(float *)&v61 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v60, 1), *(float *)(a2 + 16), v60.f32[0]);
  LODWORD(v62) = *(_DWORD *)(a2 + 24);
  v63.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v64) = *(_DWORD *)(a2 + 36);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v60, 1), *(float *)v63.i32, v60.f32[0]);
  v66 = (float64x2_t)v90;
  v91 = vaddq_f32(v90, v59);
  v59.f32[0] = *(float *)&v62 + *(float *)&v61;
  *(float *)v66.f64 = *(float *)&v64 + *(float *)v65.i32;
  v59.f32[1] = *(float *)&v64 + *(float *)v65.i32;
  *(double *)v68.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v59.i64, v66, v62, v61, v63, v65, v64, v67);
  v69 = vadd_f32((float32x2_t)vext_s8(v50, *(int8x8_t *)v97.i8, 4uLL), v7);
  *(float *)&v70 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v69, 1), *(float *)(a2 + 16), v69.f32[0]);
  LODWORD(v71) = *(_DWORD *)(a2 + 24);
  v72.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v73) = *(_DWORD *)(a2 + 36);
  *(float *)v74.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v69, 1), *(float *)v72.i32, v69.f32[0]);
  v75 = (float64x2_t)v91;
  v98 = vaddq_f32(v91, v68);
  v68.f32[0] = *(float *)&v71 + *(float *)&v70;
  *(float *)v75.f64 = *(float *)&v73 + *(float *)v74.i32;
  v68.f32[1] = *(float *)&v73 + *(float *)v74.i32;
  *(double *)v77.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v68.i64, v75, v71, v70, v72, v74, v73, v76);
  v99 = vaddq_f32(v95, vmulq_laneq_f32(vaddq_f32(v98, v77), a4, 2));
  DC = (float32x2_t *)CI::getDC(v78);
  *(float *)&v80 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v81) = *(_DWORD *)(a1 + 28);
  v82.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v83.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v81, COERCE_FLOAT(*DC));
  *(float *)&v84 = *(float *)(a1 + 24) + *(float *)&v80;
  *(float *)v85.f64 = *(float *)v82.i32 + *(float *)v83.i32;
  *((float *)&v84 + 1) = *(float *)v82.i32 + *(float *)v83.i32;
  *(double *)v88.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v84, v85, v80, v81, v83, v82, v86, v87);
  *(_QWORD *)&result = vaddq_f32(v99, vmulq_n_f32(v88, a4.f32[0])).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, uint64_t, __n128, __n128);
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __int128 v20;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t, __n128, __n128))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_QWORD *)(v10 + 32);
  v14 = *(_DWORD *)(v10 + 64);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_DWORD *)(v10 + 88);
  v17 = *(_QWORD *)(v10 + 80);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v15);
  *(double *)&v20 = v11(a4 + 80 * v12, a4 + 80 * v13, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_add4and8(uint64_t a1, uint64_t a2, int8x16_t a3, float32x4_t a4)
{
  int8x8_t v6;
  float32x2_t v7;
  float32x2_t v8;
  double v9;
  double v10;
  uint8x8_t v11;
  int8x16_t v12;
  float64x2_t v13;
  double v14;
  int8x16_t v15;
  float32x4_t v16;
  double v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  float64x2_t v21;
  double v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x2_t v25;
  double v26;
  double v27;
  int8x16_t v28;
  double v29;
  uint8x8_t v30;
  float64x2_t v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x2_t v34;
  double v35;
  double v36;
  int8x16_t v37;
  double v38;
  uint8x8_t v39;
  float64x2_t v40;
  int8x16_t v41;
  float32x4_t v42;
  int8x16_t v43;
  float32x2_t v44;
  int8x16_t v45;
  double v46;
  int8x16_t v47;
  double v48;
  uint8x8_t v49;
  float32x4_t v50;
  float64x2_t v51;
  double v52;
  double v53;
  uint8x8_t v54;
  int8x16_t v55;
  double v56;
  int8x16_t v57;
  float32x4_t v58;
  float32x2_t v59;
  double v60;
  double v61;
  int8x16_t v62;
  double v63;
  uint8x8_t v64;
  float64x2_t v65;
  int8x16_t v66;
  float32x4_t v67;
  double v68;
  float32x2_t v69;
  double v70;
  int8x16_t v71;
  double v72;
  uint8x8_t v73;
  float64x2_t v74;
  int8x16_t v75;
  float32x4_t v76;
  float32x2_t v77;
  double v78;
  double v79;
  int8x16_t v80;
  double v81;
  uint8x8_t v82;
  float64x2_t v83;
  int8x16_t v84;
  float32x4_t v85;
  double v86;
  float32x2_t v87;
  double v88;
  int8x16_t v89;
  double v90;
  uint8x8_t v91;
  float64x2_t v92;
  int8x16_t v93;
  float32x4_t v94;
  float32x2_t v95;
  double v96;
  double v97;
  int8x16_t v98;
  double v99;
  uint8x8_t v100;
  float64x2_t v101;
  int8x16_t v102;
  float32x4_t v103;
  double v104;
  float32x2_t v105;
  double v106;
  int8x16_t v107;
  double v108;
  uint8x8_t v109;
  float64x2_t v110;
  int8x16_t v111;
  float32x4_t v112;
  CI *v113;
  float32x2_t *DC;
  double v115;
  double v116;
  uint8x8_t v117;
  int8x16_t v118;
  double v119;
  float64x2_t v120;
  double v121;
  int8x16_t v122;
  float32x4_t v123;
  double result;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  int8x16_t v137;
  float32x4_t v138;
  float32x4_t v139;

  v6 = (int8x8_t)vneg_f32(*(float32x2_t *)a3.i8);
  v7 = *(float32x2_t *)CI::getDC((CI *)a1);
  v8 = vadd_f32(*(float32x2_t *)a3.i8, v7);
  *(float *)&v9 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v8, 1), *(float *)(a2 + 16), v8.f32[0]);
  LODWORD(v10) = *(_DWORD *)(a2 + 28);
  v11.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v8, 1), *(float *)&v10, v8.f32[0]);
  v8.f32[0] = *(float *)(a2 + 24) + *(float *)&v9;
  *(float *)v13.f64 = *(float *)v11.i32 + *(float *)v12.i32;
  v8.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v8, v13, v9, v10, v12, v11, v14, v15);
  v133 = v16;
  *(float32x2_t *)v16.f32 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)a3.i8, v6, 4uLL), v7);
  *(float *)&v17 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v16.f32, 1), *(float *)(a2 + 16), v16.f32[0]);
  LODWORD(v18) = *(_DWORD *)(a2 + 28);
  v19.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v16.f32, 1), *(float *)&v18, v16.f32[0]);
  v16.f32[0] = *(float *)(a2 + 24) + *(float *)&v17;
  *(float *)v21.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v16.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v16.i64, v21, v17, v18, v20, v19, v22, v23);
  v25 = vsub_f32(v7, *(float32x2_t *)a3.i8);
  *(float *)&v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v25, 1), *(float *)(a2 + 16), v25.f32[0]);
  LODWORD(v27) = *(_DWORD *)(a2 + 24);
  v28.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v29) = *(_DWORD *)(a2 + 36);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v25, 1), *(float *)v28.i32, v25.f32[0]);
  v31 = (float64x2_t)v133;
  v134 = vaddq_f32(v133, v24);
  v24.f32[0] = *(float *)&v27 + *(float *)&v26;
  *(float *)v31.f64 = *(float *)&v29 + *(float *)v30.i32;
  v24.f32[1] = *(float *)&v29 + *(float *)v30.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v24.i64, v31, v27, v26, v28, v30, v29, v32);
  v34 = vadd_f32((float32x2_t)vext_s8(v6, *(int8x8_t *)a3.i8, 4uLL), v7);
  *(float *)&v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v34, 1), *(float *)(a2 + 16), v34.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a2 + 24);
  v37.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v38) = *(_DWORD *)(a2 + 36);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v34, 1), *(float *)v37.i32, v34.f32[0]);
  v40 = (float64x2_t)v134;
  v135 = vaddq_f32(v134, v33);
  v33.f32[0] = *(float *)&v36 + *(float *)&v35;
  *(float *)v40.f64 = *(float *)&v38 + *(float *)v39.i32;
  v33.f32[1] = *(float *)&v38 + *(float *)v39.i32;
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v33.i64, v40, v36, v35, v37, v39, v38, v41);
  v43 = vextq_s8(a3, a3, 8uLL);
  v44 = vadd_f32(*(float32x2_t *)v43.i8, v7);
  v45 = v43;
  v137 = v43;
  *(float *)&v46 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v44, 1), *(float *)(a2 + 16), v44.f32[0]);
  v43.i32[0] = *(_DWORD *)(a2 + 24);
  v47.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v48) = *(_DWORD *)(a2 + 36);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v44, 1), *(float *)v47.i32, v44.f32[0]);
  v131 = vaddq_f32(vmulq_lane_f32(vaddq_f32(v135, v42), *(float32x2_t *)a4.f32, 1), (float32x4_t)0);
  *(float32x2_t *)v135.f32 = vneg_f32(*(float32x2_t *)v45.i8);
  v42.f32[0] = *(float *)v43.i32 + *(float *)&v46;
  v42.f32[1] = *(float *)&v48 + *(float *)v49.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v42.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)&v48 + *(float *)v49.i32), *(double *)v43.i64, v46, v47, v49, v48, v45);
  v125 = v50;
  v51 = (float64x2_t)v137;
  *(float32x2_t *)v50.f32 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v137.i8, *(int8x8_t *)v135.f32, 4uLL), v7);
  *(float *)&v52 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v50.f32, 1), *(float *)(a2 + 16), v50.f32[0]);
  LODWORD(v53) = *(_DWORD *)(a2 + 28);
  v54.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v55.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v50.f32, 1), *(float *)&v53, v50.f32[0]);
  v50.f32[0] = *(float *)(a2 + 24) + *(float *)&v52;
  *(float *)v51.f64 = *(float *)v54.i32 + *(float *)v55.i32;
  v50.f32[1] = *(float *)v54.i32 + *(float *)v55.i32;
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v50.i64, v51, v52, v53, v55, v54, v56, v57);
  v59 = vsub_f32(v7, *(float32x2_t *)v137.i8);
  *(float *)&v60 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v59, 1), *(float *)(a2 + 16), v59.f32[0]);
  LODWORD(v61) = *(_DWORD *)(a2 + 24);
  v62.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v63) = *(_DWORD *)(a2 + 36);
  *(float *)v64.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v59, 1), *(float *)v62.i32, v59.f32[0]);
  v65 = (float64x2_t)v125;
  v126 = vaddq_f32(v125, v58);
  v58.f32[0] = *(float *)&v61 + *(float *)&v60;
  *(float *)v65.f64 = *(float *)&v63 + *(float *)v64.i32;
  v58.f32[1] = *(float *)&v63 + *(float *)v64.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v58.i64, v65, v61, v60, v62, v64, v63, v66);
  HIDWORD(v68) = v137.i32[1];
  v69 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v135.f32, *(int8x8_t *)v137.i8, 4uLL), v7);
  *(float *)&v70 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v69, 1), *(float *)(a2 + 16), v69.f32[0]);
  LODWORD(v68) = *(_DWORD *)(a2 + 24);
  v71.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v72) = *(_DWORD *)(a2 + 36);
  *(float *)v73.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v69, 1), *(float *)v71.i32, v69.f32[0]);
  v74 = (float64x2_t)v126;
  v127 = vaddq_f32(v126, v67);
  v67.f32[0] = *(float *)&v68 + *(float *)&v70;
  *(float *)v74.f64 = *(float *)&v72 + *(float *)v73.i32;
  v67.f32[1] = *(float *)&v72 + *(float *)v73.i32;
  *(double *)v76.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v67.i64, v74, v68, v70, v71, v73, v72, v75);
  v77 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v137.i8), v7);
  *(float *)&v78 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v77, 1), *(float *)(a2 + 16), v77.f32[0]);
  LODWORD(v79) = *(_DWORD *)(a2 + 24);
  v80.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v81) = *(_DWORD *)(a2 + 36);
  *(float *)v82.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v77, 1), *(float *)v80.i32, v77.f32[0]);
  v83 = (float64x2_t)v127;
  v128 = vaddq_f32(v127, v76);
  v76.f32[0] = *(float *)&v79 + *(float *)&v78;
  *(float *)v83.f64 = *(float *)&v81 + *(float *)v82.i32;
  v76.f32[1] = *(float *)&v81 + *(float *)v82.i32;
  *(double *)v85.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v76.i64, v83, v79, v78, v80, v82, v81, v84);
  HIDWORD(v86) = v137.i32[1];
  v87 = vadd_f32((float32x2_t)__PAIR64__(v137.u32[1], v135.u32[0]), v7);
  *(float *)&v88 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v87, 1), *(float *)(a2 + 16), v87.f32[0]);
  LODWORD(v86) = *(_DWORD *)(a2 + 24);
  v89.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v90) = *(_DWORD *)(a2 + 36);
  *(float *)v91.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v87, 1), *(float *)v89.i32, v87.f32[0]);
  v92 = (float64x2_t)v128;
  v129 = vaddq_f32(v128, v85);
  v85.f32[0] = *(float *)&v86 + *(float *)&v88;
  *(float *)v92.f64 = *(float *)&v90 + *(float *)v91.i32;
  v85.f32[1] = *(float *)&v90 + *(float *)v91.i32;
  *(double *)v94.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v85.i64, v92, v86, v88, v89, v91, v90, v93);
  v95 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v135.f32), v7);
  *(float *)&v96 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v95, 1), *(float *)(a2 + 16), v95.f32[0]);
  LODWORD(v97) = *(_DWORD *)(a2 + 24);
  v98.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v99) = *(_DWORD *)(a2 + 36);
  *(float *)v100.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v95, 1), *(float *)v98.i32, v95.f32[0]);
  v101 = (float64x2_t)v129;
  v130 = vaddq_f32(v129, v94);
  v94.f32[0] = *(float *)&v97 + *(float *)&v96;
  *(float *)v101.f64 = *(float *)&v99 + *(float *)v100.i32;
  v94.f32[1] = *(float *)&v99 + *(float *)v100.i32;
  *(double *)v103.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v94.i64, v101, v97, v96, v98, v100, v99, v102);
  HIDWORD(v104) = v135.i32[1];
  v105 = vadd_f32((float32x2_t)__PAIR64__(v135.u32[1], v137.u32[0]), v7);
  *(float *)&v106 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v105, 1), *(float *)(a2 + 16), v105.f32[0]);
  LODWORD(v104) = *(_DWORD *)(a2 + 24);
  v107.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v108) = *(_DWORD *)(a2 + 36);
  *(float *)v109.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v105, 1), *(float *)v107.i32, v105.f32[0]);
  v110 = (float64x2_t)v130;
  v138 = vaddq_f32(v130, v103);
  v103.f32[0] = *(float *)&v104 + *(float *)&v106;
  *(float *)v110.f64 = *(float *)&v108 + *(float *)v109.i32;
  v103.f32[1] = *(float *)&v108 + *(float *)v109.i32;
  *(double *)v112.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v103.i64, v110, v104, v106, v107, v109, v108, v111);
  v139 = vaddq_f32(v131, vmulq_laneq_f32(vaddq_f32(v138, v112), a4, 2));
  DC = (float32x2_t *)CI::getDC(v113);
  *(float *)&v115 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v116) = *(_DWORD *)(a1 + 28);
  v117.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v118.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v116, COERCE_FLOAT(*DC));
  *(float *)&v119 = *(float *)(a1 + 24) + *(float *)&v115;
  *(float *)v120.f64 = *(float *)v117.i32 + *(float *)v118.i32;
  *((float *)&v119 + 1) = *(float *)v117.i32 + *(float *)v118.i32;
  *(double *)v123.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v119, v120, v115, v116, v118, v117, v121, v122);
  *(_QWORD *)&result = vaddq_f32(v139, vmulq_n_f32(v123, a4.f32[0])).u64[0];
  return result;
}

double cikernel::_add8and8(uint64_t a1, uint64_t a2, __n128 a3, float32x4_t a4)
{
  float32x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  float64x2_t v12;
  double v13;
  int8x16_t v14;
  float32x4_t v15;
  float64x2_t v16;
  double v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  double v21;
  int8x16_t v22;
  float32x4_t v23;
  float32x2_t v24;
  double v25;
  double v26;
  int8x16_t v27;
  double v28;
  uint8x8_t v29;
  float64x2_t v30;
  int8x16_t v31;
  float32x4_t v32;
  double v33;
  float32x2_t v34;
  double v35;
  int8x16_t v36;
  double v37;
  uint8x8_t v38;
  float64x2_t v39;
  int8x16_t v40;
  float32x4_t v41;
  float32x2_t v42;
  double v43;
  double v44;
  int8x16_t v45;
  double v46;
  uint8x8_t v47;
  float64x2_t v48;
  int8x16_t v49;
  float32x4_t v50;
  double v51;
  float32x2_t v52;
  double v53;
  int8x16_t v54;
  double v55;
  uint8x8_t v56;
  float64x2_t v57;
  int8x16_t v58;
  float32x4_t v59;
  float32x2_t v60;
  double v61;
  double v62;
  int8x16_t v63;
  double v64;
  uint8x8_t v65;
  float64x2_t v66;
  int8x16_t v67;
  float32x4_t v68;
  double v69;
  float32x2_t v70;
  double v71;
  int8x16_t v72;
  double v73;
  uint8x8_t v74;
  float64x2_t v75;
  int8x16_t v76;
  float32x4_t v77;
  int8x16_t v78;
  float32x2_t v79;
  int8x16_t v80;
  double v81;
  int8x16_t v82;
  double v83;
  uint8x8_t v84;
  float32x4_t v85;
  float64x2_t v86;
  double v87;
  double v88;
  uint8x8_t v89;
  int8x16_t v90;
  double v91;
  int8x16_t v92;
  float32x4_t v93;
  float32x2_t v94;
  double v95;
  double v96;
  int8x16_t v97;
  double v98;
  uint8x8_t v99;
  float64x2_t v100;
  int8x16_t v101;
  float32x4_t v102;
  double v103;
  float32x2_t v104;
  double v105;
  int8x16_t v106;
  double v107;
  uint8x8_t v108;
  float64x2_t v109;
  int8x16_t v110;
  float32x4_t v111;
  float32x2_t v112;
  double v113;
  double v114;
  int8x16_t v115;
  double v116;
  uint8x8_t v117;
  float64x2_t v118;
  int8x16_t v119;
  float32x4_t v120;
  double v121;
  float32x2_t v122;
  double v123;
  int8x16_t v124;
  double v125;
  uint8x8_t v126;
  float64x2_t v127;
  int8x16_t v128;
  float32x4_t v129;
  float32x2_t v130;
  double v131;
  double v132;
  int8x16_t v133;
  double v134;
  uint8x8_t v135;
  float64x2_t v136;
  int8x16_t v137;
  float32x4_t v138;
  double v139;
  float32x2_t v140;
  double v141;
  int8x16_t v142;
  double v143;
  uint8x8_t v144;
  float64x2_t v145;
  int8x16_t v146;
  float32x4_t v147;
  CI *v148;
  float32x2_t *DC;
  double v150;
  double v151;
  uint8x8_t v152;
  int8x16_t v153;
  double v154;
  float64x2_t v155;
  double v156;
  int8x16_t v157;
  float32x4_t v158;
  double result;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  __n128 v174;
  float32x4_t v175;
  int8x16_t v176;
  int8x16_t v177;
  float32x4_t v178;
  float32x4_t v179;

  v176 = (int8x16_t)a3;
  a3.n128_u64[0] = (unint64_t)vneg_f32((float32x2_t)a3.n128_u64[0]);
  v174 = a3;
  v6 = *(float32x2_t *)CI::getDC((CI *)a1);
  v7 = vadd_f32(*(float32x2_t *)v176.i8, v6);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v7, 1), *(float *)(a2 + 16), v7.f32[0]);
  LODWORD(v9) = *(_DWORD *)(a2 + 28);
  v10.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *(float *)(a2 + 24) + *(float *)&v8;
  *(float *)v12.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v7, v12, v8, v9, v11, v10, v13, v14);
  v166 = v15;
  v16 = (float64x2_t)v174;
  *(float32x2_t *)v15.f32 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v176.i8, (int8x8_t)v174.n128_u64[0], 4uLL), v6);
  *(float *)&v17 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v15.f32, 1), *(float *)(a2 + 16), v15.f32[0]);
  LODWORD(v18) = *(_DWORD *)(a2 + 28);
  v19.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v15.f32, 1), *(float *)&v18, v15.f32[0]);
  v15.f32[0] = *(float *)(a2 + 24) + *(float *)&v17;
  *(float *)v16.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v15.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v15.i64, v16, v17, v18, v20, v19, v21, v22);
  v24 = vsub_f32(v6, *(float32x2_t *)v176.i8);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v24, 1), *(float *)(a2 + 16), v24.f32[0]);
  LODWORD(v26) = *(_DWORD *)(a2 + 24);
  v27.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v28) = *(_DWORD *)(a2 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v24, 1), *(float *)v27.i32, v24.f32[0]);
  v30 = (float64x2_t)v166;
  v167 = vaddq_f32(v166, v23);
  v23.f32[0] = *(float *)&v26 + *(float *)&v25;
  *(float *)v30.f64 = *(float *)&v28 + *(float *)v29.i32;
  v23.f32[1] = *(float *)&v28 + *(float *)v29.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v23.i64, v30, v26, v25, v27, v29, v28, v31);
  HIDWORD(v33) = v174.n128_u32[1];
  v34 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v174.n128_u64[0], *(int8x8_t *)v176.i8, 4uLL), v6);
  *(float *)&v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v34, 1), *(float *)(a2 + 16), v34.f32[0]);
  LODWORD(v33) = *(_DWORD *)(a2 + 24);
  v36.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v37) = *(_DWORD *)(a2 + 36);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v34, 1), *(float *)v36.i32, v34.f32[0]);
  v39 = (float64x2_t)v167;
  v168 = vaddq_f32(v167, v32);
  v32.f32[0] = *(float *)&v33 + *(float *)&v35;
  *(float *)v39.f64 = *(float *)&v37 + *(float *)v38.i32;
  v32.f32[1] = *(float *)&v37 + *(float *)v38.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v32.i64, v39, v33, v35, v36, v38, v37, v40);
  v42 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v176.i8), v6);
  *(float *)&v43 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v42, 1), *(float *)(a2 + 16), v42.f32[0]);
  LODWORD(v44) = *(_DWORD *)(a2 + 24);
  v45.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v46) = *(_DWORD *)(a2 + 36);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v42, 1), *(float *)v45.i32, v42.f32[0]);
  v48 = (float64x2_t)v168;
  v169 = vaddq_f32(v168, v41);
  v41.f32[0] = *(float *)&v44 + *(float *)&v43;
  *(float *)v48.f64 = *(float *)&v46 + *(float *)v47.i32;
  v41.f32[1] = *(float *)&v46 + *(float *)v47.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v41.i64, v48, v44, v43, v45, v47, v46, v49);
  HIDWORD(v51) = v176.i32[1];
  v52 = vadd_f32((float32x2_t)__PAIR64__(v176.u32[1], v174.n128_u32[0]), v6);
  *(float *)&v53 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v52, 1), *(float *)(a2 + 16), v52.f32[0]);
  LODWORD(v51) = *(_DWORD *)(a2 + 24);
  v54.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v55) = *(_DWORD *)(a2 + 36);
  *(float *)v56.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v52, 1), *(float *)v54.i32, v52.f32[0]);
  v57 = (float64x2_t)v169;
  v170 = vaddq_f32(v169, v50);
  v50.f32[0] = *(float *)&v51 + *(float *)&v53;
  *(float *)v57.f64 = *(float *)&v55 + *(float *)v56.i32;
  v50.f32[1] = *(float *)&v55 + *(float *)v56.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v50.i64, v57, v51, v53, v54, v56, v55, v58);
  v60 = vadd_f32((float32x2_t)vrev64_s32((int32x2_t)v174.n128_u64[0]), v6);
  *(float *)&v61 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v60, 1), *(float *)(a2 + 16), v60.f32[0]);
  LODWORD(v62) = *(_DWORD *)(a2 + 24);
  v63.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v64) = *(_DWORD *)(a2 + 36);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v60, 1), *(float *)v63.i32, v60.f32[0]);
  v66 = (float64x2_t)v170;
  v171 = vaddq_f32(v170, v59);
  v59.f32[0] = *(float *)&v62 + *(float *)&v61;
  *(float *)v66.f64 = *(float *)&v64 + *(float *)v65.i32;
  v59.f32[1] = *(float *)&v64 + *(float *)v65.i32;
  *(double *)v68.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v59.i64, v66, v62, v61, v63, v65, v64, v67);
  HIDWORD(v69) = v174.n128_u32[1];
  v70 = vadd_f32((float32x2_t)__PAIR64__(v174.n128_u32[1], v176.u32[0]), v6);
  *(float *)&v71 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v70, 1), *(float *)(a2 + 16), v70.f32[0]);
  LODWORD(v69) = *(_DWORD *)(a2 + 24);
  v72.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v73) = *(_DWORD *)(a2 + 36);
  *(float *)v74.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v70, 1), *(float *)v72.i32, v70.f32[0]);
  v75 = (float64x2_t)v171;
  v175 = vaddq_f32(v171, v68);
  v68.f32[0] = *(float *)&v69 + *(float *)&v71;
  *(float *)v75.f64 = *(float *)&v73 + *(float *)v74.i32;
  v68.f32[1] = *(float *)&v73 + *(float *)v74.i32;
  *(double *)v77.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v68.i64, v75, v69, v71, v72, v74, v73, v76);
  v78 = vextq_s8(v176, v176, 8uLL);
  v79 = vadd_f32(*(float32x2_t *)v78.i8, v6);
  v80 = v78;
  v177 = v78;
  *(float *)&v81 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v79, 1), *(float *)(a2 + 16), v79.f32[0]);
  v78.i32[0] = *(_DWORD *)(a2 + 24);
  v82.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v83) = *(_DWORD *)(a2 + 36);
  *(float *)v84.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v79, 1), *(float *)v82.i32, v79.f32[0]);
  v172 = vaddq_f32(vmulq_lane_f32(vaddq_f32(v175, v77), *(float32x2_t *)a4.f32, 1), (float32x4_t)0);
  *(float32x2_t *)v175.f32 = vneg_f32(*(float32x2_t *)v80.i8);
  v77.f32[0] = *(float *)v78.i32 + *(float *)&v81;
  v77.f32[1] = *(float *)&v83 + *(float *)v84.i32;
  *(double *)v85.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v77.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)&v83 + *(float *)v84.i32), *(double *)v78.i64, v81, v82, v84, v83, v80);
  v160 = v85;
  v86 = (float64x2_t)v177;
  *(float32x2_t *)v85.f32 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v177.i8, *(int8x8_t *)v175.f32, 4uLL), v6);
  *(float *)&v87 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v85.f32, 1), *(float *)(a2 + 16), v85.f32[0]);
  LODWORD(v88) = *(_DWORD *)(a2 + 28);
  v89.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v90.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v85.f32, 1), *(float *)&v88, v85.f32[0]);
  v85.f32[0] = *(float *)(a2 + 24) + *(float *)&v87;
  *(float *)v86.f64 = *(float *)v89.i32 + *(float *)v90.i32;
  v85.f32[1] = *(float *)v89.i32 + *(float *)v90.i32;
  *(double *)v93.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v85.i64, v86, v87, v88, v90, v89, v91, v92);
  v94 = vsub_f32(v6, *(float32x2_t *)v177.i8);
  *(float *)&v95 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v94, 1), *(float *)(a2 + 16), v94.f32[0]);
  LODWORD(v96) = *(_DWORD *)(a2 + 24);
  v97.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v98) = *(_DWORD *)(a2 + 36);
  *(float *)v99.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v94, 1), *(float *)v97.i32, v94.f32[0]);
  v100 = (float64x2_t)v160;
  v161 = vaddq_f32(v160, v93);
  v93.f32[0] = *(float *)&v96 + *(float *)&v95;
  *(float *)v100.f64 = *(float *)&v98 + *(float *)v99.i32;
  v93.f32[1] = *(float *)&v98 + *(float *)v99.i32;
  *(double *)v102.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v93.i64, v100, v96, v95, v97, v99, v98, v101);
  HIDWORD(v103) = v177.i32[1];
  v104 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v175.f32, *(int8x8_t *)v177.i8, 4uLL), v6);
  *(float *)&v105 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v104, 1), *(float *)(a2 + 16), v104.f32[0]);
  LODWORD(v103) = *(_DWORD *)(a2 + 24);
  v106.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v107) = *(_DWORD *)(a2 + 36);
  *(float *)v108.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v104, 1), *(float *)v106.i32, v104.f32[0]);
  v109 = (float64x2_t)v161;
  v162 = vaddq_f32(v161, v102);
  v102.f32[0] = *(float *)&v103 + *(float *)&v105;
  *(float *)v109.f64 = *(float *)&v107 + *(float *)v108.i32;
  v102.f32[1] = *(float *)&v107 + *(float *)v108.i32;
  *(double *)v111.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v102.i64, v109, v103, v105, v106, v108, v107, v110);
  v112 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v177.i8), v6);
  *(float *)&v113 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v112, 1), *(float *)(a2 + 16), v112.f32[0]);
  LODWORD(v114) = *(_DWORD *)(a2 + 24);
  v115.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v116) = *(_DWORD *)(a2 + 36);
  *(float *)v117.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v112, 1), *(float *)v115.i32, v112.f32[0]);
  v118 = (float64x2_t)v162;
  v163 = vaddq_f32(v162, v111);
  v111.f32[0] = *(float *)&v114 + *(float *)&v113;
  *(float *)v118.f64 = *(float *)&v116 + *(float *)v117.i32;
  v111.f32[1] = *(float *)&v116 + *(float *)v117.i32;
  *(double *)v120.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v111.i64, v118, v114, v113, v115, v117, v116, v119);
  HIDWORD(v121) = v177.i32[1];
  v122 = vadd_f32((float32x2_t)__PAIR64__(v177.u32[1], v175.u32[0]), v6);
  *(float *)&v123 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v122, 1), *(float *)(a2 + 16), v122.f32[0]);
  LODWORD(v121) = *(_DWORD *)(a2 + 24);
  v124.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v125) = *(_DWORD *)(a2 + 36);
  *(float *)v126.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v122, 1), *(float *)v124.i32, v122.f32[0]);
  v127 = (float64x2_t)v163;
  v164 = vaddq_f32(v163, v120);
  v120.f32[0] = *(float *)&v121 + *(float *)&v123;
  *(float *)v127.f64 = *(float *)&v125 + *(float *)v126.i32;
  v120.f32[1] = *(float *)&v125 + *(float *)v126.i32;
  *(double *)v129.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v120.i64, v127, v121, v123, v124, v126, v125, v128);
  v130 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v175.f32), v6);
  *(float *)&v131 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v130, 1), *(float *)(a2 + 16), v130.f32[0]);
  LODWORD(v132) = *(_DWORD *)(a2 + 24);
  v133.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v134) = *(_DWORD *)(a2 + 36);
  *(float *)v135.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v130, 1), *(float *)v133.i32, v130.f32[0]);
  v136 = (float64x2_t)v164;
  v165 = vaddq_f32(v164, v129);
  v129.f32[0] = *(float *)&v132 + *(float *)&v131;
  *(float *)v136.f64 = *(float *)&v134 + *(float *)v135.i32;
  v129.f32[1] = *(float *)&v134 + *(float *)v135.i32;
  *(double *)v138.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v129.i64, v136, v132, v131, v133, v135, v134, v137);
  HIDWORD(v139) = v175.i32[1];
  v140 = vadd_f32((float32x2_t)__PAIR64__(v175.u32[1], v177.u32[0]), v6);
  *(float *)&v141 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v140, 1), *(float *)(a2 + 16), v140.f32[0]);
  LODWORD(v139) = *(_DWORD *)(a2 + 24);
  v142.i32[0] = *(_DWORD *)(a2 + 28);
  LODWORD(v143) = *(_DWORD *)(a2 + 36);
  *(float *)v144.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v140, 1), *(float *)v142.i32, v140.f32[0]);
  v145 = (float64x2_t)v165;
  v178 = vaddq_f32(v165, v138);
  v138.f32[0] = *(float *)&v139 + *(float *)&v141;
  *(float *)v145.f64 = *(float *)&v143 + *(float *)v144.i32;
  v138.f32[1] = *(float *)&v143 + *(float *)v144.i32;
  *(double *)v147.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v138.i64, v145, v139, v141, v142, v144, v143, v146);
  v179 = vaddq_f32(v172, vmulq_laneq_f32(vaddq_f32(v178, v147), a4, 2));
  DC = (float32x2_t *)CI::getDC(v148);
  *(float *)&v150 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v151) = *(_DWORD *)(a1 + 28);
  v152.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v153.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v151, COERCE_FLOAT(*DC));
  *(float *)&v154 = *(float *)(a1 + 24) + *(float *)&v150;
  *(float *)v155.f64 = *(float *)v152.i32 + *(float *)v153.i32;
  *((float *)&v154 + 1) = *(float *)v152.i32 + *(float *)v153.i32;
  *(double *)v158.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v154, v155, v150, v151, v153, v152, v156, v157);
  *(_QWORD *)&result = vaddq_f32(v179, vmulq_n_f32(v158, a4.f32[0])).u64[0];
  return result;
}

double cikernel::_ringAvg8(uint64_t a1, float32x2_t a2)
{
  float32x2_t v3;
  float32x2_t v4;
  double v5;
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  float64x2_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  double v13;
  float32x2_t v14;
  double v15;
  int8x16_t v16;
  double v17;
  uint8x8_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x2_t v21;
  double v22;
  double v23;
  int8x16_t v24;
  double v25;
  uint8x8_t v26;
  float64x2_t v27;
  int8x16_t v28;
  float32x4_t v29;
  double v30;
  float32x2_t v31;
  double v32;
  int8x16_t v33;
  double v34;
  uint8x8_t v35;
  float64x2_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x2_t v39;
  double v40;
  double v41;
  int8x16_t v42;
  double v43;
  uint8x8_t v44;
  float64x2_t v45;
  int8x16_t v46;
  float32x4_t v47;
  double v48;
  float32x2_t v49;
  double v50;
  int8x16_t v51;
  double v52;
  uint8x8_t v53;
  float64x2_t v54;
  int8x16_t v55;
  float32x4_t v56;
  float32x2_t v57;
  double v58;
  double v59;
  int8x16_t v60;
  double v61;
  uint8x8_t v62;
  float64x2_t v63;
  int8x16_t v64;
  float32x4_t v65;
  double v66;
  float32x2_t v67;
  double v68;
  int8x16_t v69;
  double v70;
  uint8x8_t v71;
  float64x2_t v72;
  int8x16_t v73;
  float32x4_t v74;
  float32x4_t v75;
  double result;
  float32x4_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  int32x2_t v83;
  float32x4_t v85;

  v83 = (int32x2_t)vneg_f32(a2);
  v3 = *(float32x2_t *)CI::getDC((CI *)a1);
  v4 = vadd_f32(a2, v3);
  *(float *)&v5 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v4, 1), *(float *)(a1 + 16), v4.f32[0]);
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  v7.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *(float *)(a1 + 24) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v4, v9, v5, v6, v8, v7, v10, v11);
  HIDWORD(v13) = a2.i32[1];
  v14 = vadd_f32((float32x2_t)vext_s8((int8x8_t)a2, (int8x8_t)v83, 4uLL), v3);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v14, 1), *(float *)(a1 + 16), v14.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 24);
  v16.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v17) = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v14, 1), *(float *)v16.i32, v14.f32[0]);
  v77 = vaddq_f32(v12, (float32x4_t)0);
  v12.f32[0] = *(float *)&v13 + *(float *)&v15;
  v12.f32[1] = *(float *)&v17 + *(float *)v18.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)&v17 + *(float *)v18.i32), v13, v15, v16, v18, v17, v19);
  v21 = vsub_f32(v3, a2);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v21, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 24);
  v24.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v25) = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v21, 1), *(float *)v24.i32, v21.f32[0]);
  v27 = (float64x2_t)v77;
  v78 = vaddq_f32(v77, v20);
  v20.f32[0] = *(float *)&v23 + *(float *)&v22;
  *(float *)v27.f64 = *(float *)&v25 + *(float *)v26.i32;
  v20.f32[1] = *(float *)&v25 + *(float *)v26.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v27, v23, v22, v24, v26, v25, v28);
  HIDWORD(v30) = a2.i32[1];
  v31 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v83, (int8x8_t)a2, 4uLL), v3);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v31, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 24);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v34) = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v31, 1), *(float *)v33.i32, v31.f32[0]);
  v36 = (float64x2_t)v78;
  v79 = vaddq_f32(v78, v29);
  v29.f32[0] = *(float *)&v30 + *(float *)&v32;
  *(float *)v36.f64 = *(float *)&v34 + *(float *)v35.i32;
  v29.f32[1] = *(float *)&v34 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v36, v30, v32, v33, v35, v34, v37);
  v39 = vadd_f32((float32x2_t)vrev64_s32((int32x2_t)a2), v3);
  *(float *)&v40 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v39, 1), *(float *)(a1 + 16), v39.f32[0]);
  LODWORD(v41) = *(_DWORD *)(a1 + 24);
  v42.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v43) = *(_DWORD *)(a1 + 36);
  *(float *)v44.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v39, 1), *(float *)v42.i32, v39.f32[0]);
  v45 = (float64x2_t)v79;
  v80 = vaddq_f32(v79, v38);
  v38.f32[0] = *(float *)&v41 + *(float *)&v40;
  *(float *)v45.f64 = *(float *)&v43 + *(float *)v44.i32;
  v38.f32[1] = *(float *)&v43 + *(float *)v44.i32;
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v45, v41, v40, v42, v44, v43, v46);
  HIDWORD(v48) = a2.i32[1];
  v49 = vadd_f32((float32x2_t)__PAIR64__(a2.u32[1], v83.u32[0]), v3);
  *(float *)&v50 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v49, 1), *(float *)(a1 + 16), v49.f32[0]);
  LODWORD(v48) = *(_DWORD *)(a1 + 24);
  v51.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v52) = *(_DWORD *)(a1 + 36);
  *(float *)v53.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v49, 1), *(float *)v51.i32, v49.f32[0]);
  v54 = (float64x2_t)v80;
  v81 = vaddq_f32(v80, v47);
  v47.f32[0] = *(float *)&v48 + *(float *)&v50;
  *(float *)v54.f64 = *(float *)&v52 + *(float *)v53.i32;
  v47.f32[1] = *(float *)&v52 + *(float *)v53.i32;
  *(double *)v56.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v47.i64, v54, v48, v50, v51, v53, v52, v55);
  v57 = vadd_f32((float32x2_t)vrev64_s32(v83), v3);
  *(float *)&v58 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v57, 1), *(float *)(a1 + 16), v57.f32[0]);
  LODWORD(v59) = *(_DWORD *)(a1 + 24);
  v60.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v61) = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v57, 1), *(float *)v60.i32, v57.f32[0]);
  v63 = (float64x2_t)v81;
  v82 = vaddq_f32(v81, v56);
  v56.f32[0] = *(float *)&v59 + *(float *)&v58;
  *(float *)v63.f64 = *(float *)&v61 + *(float *)v62.i32;
  v56.f32[1] = *(float *)&v61 + *(float *)v62.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v56.i64, v63, v59, v58, v60, v62, v61, v64);
  HIDWORD(v66) = v83.i32[1];
  v67 = vadd_f32((float32x2_t)__PAIR64__(v83.u32[1], a2.u32[0]), v3);
  *(float *)&v68 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v67, 1), *(float *)(a1 + 16), v67.f32[0]);
  LODWORD(v66) = *(_DWORD *)(a1 + 24);
  v69.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v70) = *(_DWORD *)(a1 + 36);
  *(float *)v71.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v67, 1), *(float *)v69.i32, v67.f32[0]);
  v72 = (float64x2_t)v82;
  v85 = vaddq_f32(v82, v65);
  v65.f32[0] = *(float *)&v66 + *(float *)&v68;
  *(float *)v72.f64 = *(float *)&v70 + *(float *)v71.i32;
  v65.f32[1] = *(float *)&v70 + *(float *)v71.i32;
  *(double *)v74.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v72, v66, v68, v69, v71, v70, v73);
  v75.i64[0] = 0x3E0000003E000000;
  v75.i64[1] = 0x3E0000003E000000;
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v85, v74), v75).u64[0];
  return result;
}

double cikernel::_ringAvg16(uint64_t a1, int8x16_t a2)
{
  float32x2_t v3;
  float32x2_t v4;
  double v5;
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  float64x2_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  double v13;
  float32x2_t v14;
  double v15;
  int8x16_t v16;
  double v17;
  uint8x8_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x2_t v21;
  double v22;
  double v23;
  int8x16_t v24;
  double v25;
  uint8x8_t v26;
  float64x2_t v27;
  int8x16_t v28;
  float32x4_t v29;
  double v30;
  float32x2_t v31;
  double v32;
  int8x16_t v33;
  double v34;
  uint8x8_t v35;
  float64x2_t v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x2_t v39;
  double v40;
  double v41;
  int8x16_t v42;
  double v43;
  uint8x8_t v44;
  float64x2_t v45;
  int8x16_t v46;
  float32x4_t v47;
  double v48;
  float32x2_t v49;
  double v50;
  int8x16_t v51;
  double v52;
  uint8x8_t v53;
  float64x2_t v54;
  int8x16_t v55;
  float32x4_t v56;
  float32x2_t v57;
  double v58;
  double v59;
  int8x16_t v60;
  double v61;
  uint8x8_t v62;
  float64x2_t v63;
  int8x16_t v64;
  float32x4_t v65;
  double v66;
  float32x2_t v67;
  double v68;
  int8x16_t v69;
  double v70;
  uint8x8_t v71;
  float64x2_t v72;
  int8x16_t v73;
  float32x4_t v74;
  int8x16_t v75;
  float32x2_t v76;
  int8x16_t v77;
  double v78;
  double v79;
  uint8x8_t v80;
  float64x2_t v81;
  float32x4_t v82;
  double v83;
  float32x2_t v84;
  double v85;
  int8x16_t v86;
  double v87;
  uint8x8_t v88;
  float64x2_t v89;
  int8x16_t v90;
  float32x4_t v91;
  float32x2_t v92;
  double v93;
  double v94;
  int8x16_t v95;
  double v96;
  uint8x8_t v97;
  float64x2_t v98;
  int8x16_t v99;
  float32x4_t v100;
  double v101;
  float32x2_t v102;
  double v103;
  int8x16_t v104;
  double v105;
  uint8x8_t v106;
  float64x2_t v107;
  int8x16_t v108;
  float32x4_t v109;
  float32x2_t v110;
  double v111;
  double v112;
  int8x16_t v113;
  double v114;
  uint8x8_t v115;
  float64x2_t v116;
  int8x16_t v117;
  float32x4_t v118;
  double v119;
  float32x2_t v120;
  double v121;
  int8x16_t v122;
  double v123;
  uint8x8_t v124;
  float64x2_t v125;
  int8x16_t v126;
  float32x4_t v127;
  float32x2_t v128;
  double v129;
  double v130;
  int8x16_t v131;
  double v132;
  uint8x8_t v133;
  float64x2_t v134;
  int8x16_t v135;
  float32x4_t v136;
  double v137;
  float32x2_t v138;
  double v139;
  int8x16_t v140;
  double v141;
  uint8x8_t v142;
  float64x2_t v143;
  int8x16_t v144;
  float32x4_t v145;
  double result;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  int32x2_t v160;
  float32x4_t v161;
  int8x16_t v162;
  float32x4_t v163;

  v162 = a2;
  v160 = (int32x2_t)vneg_f32(*(float32x2_t *)a2.i8);
  v3 = *(float32x2_t *)CI::getDC((CI *)a1);
  v4 = vadd_f32(*(float32x2_t *)v162.i8, v3);
  *(float *)&v5 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v4, 1), *(float *)(a1 + 16), v4.f32[0]);
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  v7.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *(float *)(a1 + 24) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v4, v9, v5, v6, v8, v7, v10, v11);
  HIDWORD(v13) = v160.i32[1];
  v14 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v162.i8, (int8x8_t)v160, 4uLL), v3);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v14, 1), *(float *)(a1 + 16), v14.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 24);
  v16.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v17) = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v14, 1), *(float *)v16.i32, v14.f32[0]);
  v147 = vaddq_f32(v12, (float32x4_t)0);
  v12.f32[0] = *(float *)&v13 + *(float *)&v15;
  v12.f32[1] = *(float *)&v17 + *(float *)v18.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)&v17 + *(float *)v18.i32), v13, v15, v16, v18, v17, v19);
  v21 = vsub_f32(v3, *(float32x2_t *)v162.i8);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v21, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 24);
  v24.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v25) = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v21, 1), *(float *)v24.i32, v21.f32[0]);
  v27 = (float64x2_t)v147;
  v148 = vaddq_f32(v147, v20);
  v20.f32[0] = *(float *)&v23 + *(float *)&v22;
  *(float *)v27.f64 = *(float *)&v25 + *(float *)v26.i32;
  v20.f32[1] = *(float *)&v25 + *(float *)v26.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v27, v23, v22, v24, v26, v25, v28);
  HIDWORD(v30) = v160.i32[1];
  v31 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v160, *(int8x8_t *)v162.i8, 4uLL), v3);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v31, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 24);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v34) = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v31, 1), *(float *)v33.i32, v31.f32[0]);
  v36 = (float64x2_t)v148;
  v149 = vaddq_f32(v148, v29);
  v29.f32[0] = *(float *)&v30 + *(float *)&v32;
  *(float *)v36.f64 = *(float *)&v34 + *(float *)v35.i32;
  v29.f32[1] = *(float *)&v34 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v36, v30, v32, v33, v35, v34, v37);
  v39 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v162.i8), v3);
  *(float *)&v40 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v39, 1), *(float *)(a1 + 16), v39.f32[0]);
  LODWORD(v41) = *(_DWORD *)(a1 + 24);
  v42.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v43) = *(_DWORD *)(a1 + 36);
  *(float *)v44.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v39, 1), *(float *)v42.i32, v39.f32[0]);
  v45 = (float64x2_t)v149;
  v150 = vaddq_f32(v149, v38);
  v38.f32[0] = *(float *)&v41 + *(float *)&v40;
  *(float *)v45.f64 = *(float *)&v43 + *(float *)v44.i32;
  v38.f32[1] = *(float *)&v43 + *(float *)v44.i32;
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v45, v41, v40, v42, v44, v43, v46);
  HIDWORD(v48) = v162.i32[1];
  v49 = vadd_f32((float32x2_t)__PAIR64__(v162.u32[1], v160.u32[0]), v3);
  *(float *)&v50 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v49, 1), *(float *)(a1 + 16), v49.f32[0]);
  LODWORD(v48) = *(_DWORD *)(a1 + 24);
  v51.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v52) = *(_DWORD *)(a1 + 36);
  *(float *)v53.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v49, 1), *(float *)v51.i32, v49.f32[0]);
  v54 = (float64x2_t)v150;
  v151 = vaddq_f32(v150, v47);
  v47.f32[0] = *(float *)&v48 + *(float *)&v50;
  *(float *)v54.f64 = *(float *)&v52 + *(float *)v53.i32;
  v47.f32[1] = *(float *)&v52 + *(float *)v53.i32;
  *(double *)v56.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v47.i64, v54, v48, v50, v51, v53, v52, v55);
  v57 = vadd_f32((float32x2_t)vrev64_s32(v160), v3);
  *(float *)&v58 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v57, 1), *(float *)(a1 + 16), v57.f32[0]);
  LODWORD(v59) = *(_DWORD *)(a1 + 24);
  v60.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v61) = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v57, 1), *(float *)v60.i32, v57.f32[0]);
  v63 = (float64x2_t)v151;
  v152 = vaddq_f32(v151, v56);
  v56.f32[0] = *(float *)&v59 + *(float *)&v58;
  *(float *)v63.f64 = *(float *)&v61 + *(float *)v62.i32;
  v56.f32[1] = *(float *)&v61 + *(float *)v62.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v56.i64, v63, v59, v58, v60, v62, v61, v64);
  HIDWORD(v66) = v160.i32[1];
  v67 = vadd_f32((float32x2_t)__PAIR64__(v160.u32[1], v162.u32[0]), v3);
  *(float *)&v68 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v67, 1), *(float *)(a1 + 16), v67.f32[0]);
  LODWORD(v66) = *(_DWORD *)(a1 + 24);
  v69.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v70) = *(_DWORD *)(a1 + 36);
  *(float *)v71.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v67, 1), *(float *)v69.i32, v67.f32[0]);
  v72 = (float64x2_t)v152;
  v161 = vaddq_f32(v152, v65);
  v65.f32[0] = *(float *)&v66 + *(float *)&v68;
  *(float *)v72.f64 = *(float *)&v70 + *(float *)v71.i32;
  v65.f32[1] = *(float *)&v70 + *(float *)v71.i32;
  *(double *)v74.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v72, v66, v68, v69, v71, v70, v73);
  v75 = vextq_s8(v162, v162, 8uLL);
  v76 = vadd_f32(*(float32x2_t *)v75.i8, v3);
  v77 = v75;
  v162.i64[0] = v75.i64[0];
  *(float *)&v78 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v76, 1), *(float *)(a1 + 16), v76.f32[0]);
  v75.i32[0] = *(_DWORD *)(a1 + 24);
  LODWORD(v79) = *(_DWORD *)(a1 + 36);
  *(float *)v80.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v76, 1), *(float *)(a1 + 28), v76.f32[0]);
  v81 = (float64x2_t)v161;
  v153 = vaddq_f32(v161, v74);
  *(float32x2_t *)v161.f32 = vneg_f32(*(float32x2_t *)v77.i8);
  v74.f32[0] = *(float *)v75.i32 + *(float *)&v78;
  *(float *)v81.f64 = *(float *)&v79 + *(float *)v80.i32;
  v74.f32[1] = *(float *)&v79 + *(float *)v80.i32;
  *(double *)v82.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v74.i64, v81, *(double *)v75.i64, v78, (int8x16_t)v153, v80, v79, v77);
  HIDWORD(v83) = v162.i32[1];
  v84 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v162.i8, *(int8x8_t *)v161.f32, 4uLL), v3);
  *(float *)&v85 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v84, 1), *(float *)(a1 + 16), v84.f32[0]);
  LODWORD(v83) = *(_DWORD *)(a1 + 24);
  v86.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v87) = *(_DWORD *)(a1 + 36);
  *(float *)v88.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v84, 1), *(float *)v86.i32, v84.f32[0]);
  v89 = (float64x2_t)v153;
  v154 = vaddq_f32(v153, v82);
  v82.f32[0] = *(float *)&v83 + *(float *)&v85;
  *(float *)v89.f64 = *(float *)&v87 + *(float *)v88.i32;
  v82.f32[1] = *(float *)&v87 + *(float *)v88.i32;
  *(double *)v91.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v82.i64, v89, v83, v85, v86, v88, v87, v90);
  v92 = vsub_f32(v3, *(float32x2_t *)v162.i8);
  *(float *)&v93 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v92, 1), *(float *)(a1 + 16), v92.f32[0]);
  LODWORD(v94) = *(_DWORD *)(a1 + 24);
  v95.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v96) = *(_DWORD *)(a1 + 36);
  *(float *)v97.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v92, 1), *(float *)v95.i32, v92.f32[0]);
  v98 = (float64x2_t)v154;
  v155 = vaddq_f32(v154, v91);
  v91.f32[0] = *(float *)&v94 + *(float *)&v93;
  *(float *)v98.f64 = *(float *)&v96 + *(float *)v97.i32;
  v91.f32[1] = *(float *)&v96 + *(float *)v97.i32;
  *(double *)v100.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v91.i64, v98, v94, v93, v95, v97, v96, v99);
  HIDWORD(v101) = v162.i32[1];
  v102 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v161.f32, *(int8x8_t *)v162.i8, 4uLL), v3);
  *(float *)&v103 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v102, 1), *(float *)(a1 + 16), v102.f32[0]);
  LODWORD(v101) = *(_DWORD *)(a1 + 24);
  v104.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v105) = *(_DWORD *)(a1 + 36);
  *(float *)v106.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v102, 1), *(float *)v104.i32, v102.f32[0]);
  v107 = (float64x2_t)v155;
  v156 = vaddq_f32(v155, v100);
  v100.f32[0] = *(float *)&v101 + *(float *)&v103;
  *(float *)v107.f64 = *(float *)&v105 + *(float *)v106.i32;
  v100.f32[1] = *(float *)&v105 + *(float *)v106.i32;
  *(double *)v109.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v100.i64, v107, v101, v103, v104, v106, v105, v108);
  v110 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v162.i8), v3);
  *(float *)&v111 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v110, 1), *(float *)(a1 + 16), v110.f32[0]);
  LODWORD(v112) = *(_DWORD *)(a1 + 24);
  v113.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v114) = *(_DWORD *)(a1 + 36);
  *(float *)v115.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v110, 1), *(float *)v113.i32, v110.f32[0]);
  v116 = (float64x2_t)v156;
  v157 = vaddq_f32(v156, v109);
  v109.f32[0] = *(float *)&v112 + *(float *)&v111;
  *(float *)v116.f64 = *(float *)&v114 + *(float *)v115.i32;
  v109.f32[1] = *(float *)&v114 + *(float *)v115.i32;
  *(double *)v118.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v109.i64, v116, v112, v111, v113, v115, v114, v117);
  HIDWORD(v119) = v162.i32[1];
  v120 = vadd_f32((float32x2_t)__PAIR64__(v162.u32[1], v161.u32[0]), v3);
  *(float *)&v121 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v120, 1), *(float *)(a1 + 16), v120.f32[0]);
  LODWORD(v119) = *(_DWORD *)(a1 + 24);
  v122.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v123) = *(_DWORD *)(a1 + 36);
  *(float *)v124.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v120, 1), *(float *)v122.i32, v120.f32[0]);
  v125 = (float64x2_t)v157;
  v158 = vaddq_f32(v157, v118);
  v118.f32[0] = *(float *)&v119 + *(float *)&v121;
  *(float *)v125.f64 = *(float *)&v123 + *(float *)v124.i32;
  v118.f32[1] = *(float *)&v123 + *(float *)v124.i32;
  *(double *)v127.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v118.i64, v125, v119, v121, v122, v124, v123, v126);
  v128 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v161.f32), v3);
  *(float *)&v129 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v128, 1), *(float *)(a1 + 16), v128.f32[0]);
  LODWORD(v130) = *(_DWORD *)(a1 + 24);
  v131.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v132) = *(_DWORD *)(a1 + 36);
  *(float *)v133.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v128, 1), *(float *)v131.i32, v128.f32[0]);
  v134 = (float64x2_t)v158;
  v159 = vaddq_f32(v158, v127);
  v127.f32[0] = *(float *)&v130 + *(float *)&v129;
  *(float *)v134.f64 = *(float *)&v132 + *(float *)v133.i32;
  v127.f32[1] = *(float *)&v132 + *(float *)v133.i32;
  *(double *)v136.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v127.i64, v134, v130, v129, v131, v133, v132, v135);
  HIDWORD(v137) = v161.i32[1];
  v138 = vadd_f32((float32x2_t)__PAIR64__(v161.u32[1], v162.u32[0]), v3);
  *(float *)&v139 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v138, 1), *(float *)(a1 + 16), v138.f32[0]);
  LODWORD(v137) = *(_DWORD *)(a1 + 24);
  v140.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v141) = *(_DWORD *)(a1 + 36);
  *(float *)v142.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v138, 1), *(float *)v140.i32, v138.f32[0]);
  v143 = (float64x2_t)v159;
  v163 = vaddq_f32(v159, v136);
  v136.f32[0] = *(float *)&v137 + *(float *)&v139;
  *(float *)v143.f64 = *(float *)&v141 + *(float *)v142.i32;
  v136.f32[1] = *(float *)&v141 + *(float *)v142.i32;
  *(double *)v145.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v136.i64, v143, v137, v139, v140, v142, v141, v144);
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v163, v145), (float32x4_t)vdupq_n_s32(0x3D800000u)).u64[0];
  return result;
}

double cikernel::_ringAvg24(uint64_t a1, int8x16_t a2, int8x16_t a3)
{
  float32x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  float64x2_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  float32x2_t v15;
  double v16;
  int8x16_t v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  double v26;
  uint8x8_t v27;
  float64x2_t v28;
  int8x16_t v29;
  float32x4_t v30;
  double v31;
  float32x2_t v32;
  double v33;
  int8x16_t v34;
  double v35;
  uint8x8_t v36;
  float64x2_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x2_t v40;
  double v41;
  double v42;
  int8x16_t v43;
  double v44;
  uint8x8_t v45;
  float64x2_t v46;
  int8x16_t v47;
  float32x4_t v48;
  double v49;
  float32x2_t v50;
  double v51;
  int8x16_t v52;
  double v53;
  uint8x8_t v54;
  float64x2_t v55;
  int8x16_t v56;
  float32x4_t v57;
  float32x2_t v58;
  double v59;
  double v60;
  int8x16_t v61;
  double v62;
  uint8x8_t v63;
  float64x2_t v64;
  int8x16_t v65;
  float32x4_t v66;
  double v67;
  float32x2_t v68;
  double v69;
  int8x16_t v70;
  double v71;
  uint8x8_t v72;
  float64x2_t v73;
  int8x16_t v74;
  float32x4_t v75;
  int8x16_t v76;
  float32x2_t v77;
  int8x16_t v78;
  double v79;
  double v80;
  uint8x8_t v81;
  float64x2_t v82;
  float32x4_t v83;
  double v84;
  float32x2_t v85;
  double v86;
  int8x16_t v87;
  double v88;
  uint8x8_t v89;
  float64x2_t v90;
  int8x16_t v91;
  float32x4_t v92;
  float32x2_t v93;
  double v94;
  double v95;
  int8x16_t v96;
  double v97;
  uint8x8_t v98;
  float64x2_t v99;
  int8x16_t v100;
  float32x4_t v101;
  double v102;
  float32x2_t v103;
  double v104;
  int8x16_t v105;
  double v106;
  uint8x8_t v107;
  float64x2_t v108;
  int8x16_t v109;
  float32x4_t v110;
  float32x2_t v111;
  double v112;
  double v113;
  int8x16_t v114;
  double v115;
  uint8x8_t v116;
  float64x2_t v117;
  int8x16_t v118;
  float32x4_t v119;
  double v120;
  float32x2_t v121;
  double v122;
  int8x16_t v123;
  double v124;
  uint8x8_t v125;
  float64x2_t v126;
  int8x16_t v127;
  float32x4_t v128;
  float32x2_t v129;
  double v130;
  double v131;
  int8x16_t v132;
  double v133;
  uint8x8_t v134;
  float64x2_t v135;
  int8x16_t v136;
  float32x4_t v137;
  double v138;
  float32x2_t v139;
  double v140;
  int8x16_t v141;
  double v142;
  uint8x8_t v143;
  float64x2_t v144;
  int8x16_t v145;
  float32x4_t v146;
  float32x2_t v147;
  double v148;
  double v149;
  int8x16_t v150;
  double v151;
  uint8x8_t v152;
  float64x2_t v153;
  float32x4_t v154;
  double v155;
  float32x2_t v156;
  double v157;
  int8x16_t v158;
  double v159;
  uint8x8_t v160;
  float64x2_t v161;
  int8x16_t v162;
  float32x4_t v163;
  float32x2_t v164;
  double v165;
  double v166;
  int8x16_t v167;
  double v168;
  uint8x8_t v169;
  float64x2_t v170;
  int8x16_t v171;
  float32x4_t v172;
  double v173;
  float32x2_t v174;
  double v175;
  int8x16_t v176;
  double v177;
  uint8x8_t v178;
  float64x2_t v179;
  int8x16_t v180;
  float32x4_t v181;
  float32x2_t v182;
  double v183;
  double v184;
  int8x16_t v185;
  double v186;
  uint8x8_t v187;
  float64x2_t v188;
  int8x16_t v189;
  float32x4_t v190;
  double v191;
  float32x2_t v192;
  double v193;
  int8x16_t v194;
  double v195;
  uint8x8_t v196;
  float64x2_t v197;
  int8x16_t v198;
  float32x4_t v199;
  float32x2_t v200;
  double v201;
  double v202;
  int8x16_t v203;
  double v204;
  uint8x8_t v205;
  float64x2_t v206;
  int8x16_t v207;
  float32x4_t v208;
  double v209;
  float32x2_t v210;
  double v211;
  int8x16_t v212;
  double v213;
  uint8x8_t v214;
  float64x2_t v215;
  int8x16_t v216;
  float32x4_t v217;
  double result;
  float32x4_t v224;
  float32x4_t v225;
  float32x4_t v226;
  float32x4_t v227;
  float32x4_t v228;
  float32x4_t v229;
  float32x4_t v230;
  float32x4_t v231;
  float32x4_t v232;
  float32x4_t v233;
  float32x4_t v234;
  float32x4_t v235;
  float32x4_t v236;
  int32x2_t v237;
  float32x4_t v238;
  float32x4_t v239;
  float32x4_t v240;
  float32x4_t v241;
  float32x4_t v242;
  float32x4_t v243;
  float32x4_t v244;
  float32x4_t v245;
  int8x16_t v247;
  float32x4_t v248;
  float32x4_t v249;

  v247 = a2;
  v237 = (int32x2_t)vneg_f32(*(float32x2_t *)a2.i8);
  v4 = *(float32x2_t *)CI::getDC((CI *)a1);
  v5 = vadd_f32(*(float32x2_t *)v247.i8, v4);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v10, v6, v7, v9, v8, v11, v12);
  HIDWORD(v14) = v237.i32[1];
  v15 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v247.i8, (int8x8_t)v237, 4uLL), v4);
  *(float *)&v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v15, 1), *(float *)(a1 + 16), v15.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 24);
  v17.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v18) = *(_DWORD *)(a1 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v15, 1), *(float *)v17.i32, v15.f32[0]);
  v224 = vaddq_f32(v13, (float32x4_t)0);
  v13.f32[0] = *(float *)&v14 + *(float *)&v16;
  v13.f32[1] = *(float *)&v18 + *(float *)v19.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)&v18 + *(float *)v19.i32), v14, v16, v17, v19, v18, v20);
  v22 = vsub_f32(v4, *(float32x2_t *)v247.i8);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 24);
  v25.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v26) = *(_DWORD *)(a1 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)v25.i32, v22.f32[0]);
  v28 = (float64x2_t)v224;
  v225 = vaddq_f32(v224, v21);
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  *(float *)v28.f64 = *(float *)&v26 + *(float *)v27.i32;
  v21.f32[1] = *(float *)&v26 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v28, v24, v23, v25, v27, v26, v29);
  HIDWORD(v31) = v237.i32[1];
  v32 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v237, *(int8x8_t *)v247.i8, 4uLL), v4);
  *(float *)&v33 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v32, 1), *(float *)(a1 + 16), v32.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 24);
  v34.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v35) = *(_DWORD *)(a1 + 36);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v32, 1), *(float *)v34.i32, v32.f32[0]);
  v37 = (float64x2_t)v225;
  v226 = vaddq_f32(v225, v30);
  v30.f32[0] = *(float *)&v31 + *(float *)&v33;
  *(float *)v37.f64 = *(float *)&v35 + *(float *)v36.i32;
  v30.f32[1] = *(float *)&v35 + *(float *)v36.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v30.i64, v37, v31, v33, v34, v36, v35, v38);
  v40 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v247.i8), v4);
  *(float *)&v41 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v40, 1), *(float *)(a1 + 16), v40.f32[0]);
  LODWORD(v42) = *(_DWORD *)(a1 + 24);
  v43.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v44) = *(_DWORD *)(a1 + 36);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v40, 1), *(float *)v43.i32, v40.f32[0]);
  v46 = (float64x2_t)v226;
  v227 = vaddq_f32(v226, v39);
  v39.f32[0] = *(float *)&v42 + *(float *)&v41;
  *(float *)v46.f64 = *(float *)&v44 + *(float *)v45.i32;
  v39.f32[1] = *(float *)&v44 + *(float *)v45.i32;
  *(double *)v48.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v39.i64, v46, v42, v41, v43, v45, v44, v47);
  HIDWORD(v49) = v247.i32[1];
  v50 = vadd_f32((float32x2_t)__PAIR64__(v247.u32[1], v237.u32[0]), v4);
  *(float *)&v51 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v50, 1), *(float *)(a1 + 16), v50.f32[0]);
  LODWORD(v49) = *(_DWORD *)(a1 + 24);
  v52.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v53) = *(_DWORD *)(a1 + 36);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v50, 1), *(float *)v52.i32, v50.f32[0]);
  v55 = (float64x2_t)v227;
  v228 = vaddq_f32(v227, v48);
  v48.f32[0] = *(float *)&v49 + *(float *)&v51;
  *(float *)v55.f64 = *(float *)&v53 + *(float *)v54.i32;
  v48.f32[1] = *(float *)&v53 + *(float *)v54.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v48.i64, v55, v49, v51, v52, v54, v53, v56);
  v58 = vadd_f32((float32x2_t)vrev64_s32(v237), v4);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v58, 1), *(float *)(a1 + 16), v58.f32[0]);
  LODWORD(v60) = *(_DWORD *)(a1 + 24);
  v61.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v62) = *(_DWORD *)(a1 + 36);
  *(float *)v63.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v58, 1), *(float *)v61.i32, v58.f32[0]);
  v64 = (float64x2_t)v228;
  v229 = vaddq_f32(v228, v57);
  v57.f32[0] = *(float *)&v60 + *(float *)&v59;
  *(float *)v64.f64 = *(float *)&v62 + *(float *)v63.i32;
  v57.f32[1] = *(float *)&v62 + *(float *)v63.i32;
  *(double *)v66.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v57.i64, v64, v60, v59, v61, v63, v62, v65);
  HIDWORD(v67) = v237.i32[1];
  v68 = vadd_f32((float32x2_t)__PAIR64__(v237.u32[1], v247.u32[0]), v4);
  *(float *)&v69 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v68, 1), *(float *)(a1 + 16), v68.f32[0]);
  LODWORD(v67) = *(_DWORD *)(a1 + 24);
  v70.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v71) = *(_DWORD *)(a1 + 36);
  *(float *)v72.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v68, 1), *(float *)v70.i32, v68.f32[0]);
  v73 = (float64x2_t)v229;
  v238 = vaddq_f32(v229, v66);
  v66.f32[0] = *(float *)&v67 + *(float *)&v69;
  *(float *)v73.f64 = *(float *)&v71 + *(float *)v72.i32;
  v66.f32[1] = *(float *)&v71 + *(float *)v72.i32;
  *(double *)v75.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v66.i64, v73, v67, v69, v70, v72, v71, v74);
  v76 = vextq_s8(v247, v247, 8uLL);
  v77 = vadd_f32(*(float32x2_t *)v76.i8, v4);
  v78 = v76;
  v247.i64[0] = v76.i64[0];
  *(float *)&v79 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v77, 1), *(float *)(a1 + 16), v77.f32[0]);
  v76.i32[0] = *(_DWORD *)(a1 + 24);
  LODWORD(v80) = *(_DWORD *)(a1 + 36);
  *(float *)v81.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v77, 1), *(float *)(a1 + 28), v77.f32[0]);
  v82 = (float64x2_t)v238;
  v230 = vaddq_f32(v238, v75);
  *(float32x2_t *)v238.f32 = vneg_f32(*(float32x2_t *)v78.i8);
  v75.f32[0] = *(float *)v76.i32 + *(float *)&v79;
  *(float *)v82.f64 = *(float *)&v80 + *(float *)v81.i32;
  v75.f32[1] = *(float *)&v80 + *(float *)v81.i32;
  *(double *)v83.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v75.i64, v82, *(double *)v76.i64, v79, (int8x16_t)v230, v81, v80, v78);
  HIDWORD(v84) = v247.i32[1];
  v85 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v247.i8, *(int8x8_t *)v238.f32, 4uLL), v4);
  *(float *)&v86 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v85, 1), *(float *)(a1 + 16), v85.f32[0]);
  LODWORD(v84) = *(_DWORD *)(a1 + 24);
  v87.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v88) = *(_DWORD *)(a1 + 36);
  *(float *)v89.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v85, 1), *(float *)v87.i32, v85.f32[0]);
  v90 = (float64x2_t)v230;
  v231 = vaddq_f32(v230, v83);
  v83.f32[0] = *(float *)&v84 + *(float *)&v86;
  *(float *)v90.f64 = *(float *)&v88 + *(float *)v89.i32;
  v83.f32[1] = *(float *)&v88 + *(float *)v89.i32;
  *(double *)v92.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v83.i64, v90, v84, v86, v87, v89, v88, v91);
  v93 = vsub_f32(v4, *(float32x2_t *)v247.i8);
  *(float *)&v94 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v93, 1), *(float *)(a1 + 16), v93.f32[0]);
  LODWORD(v95) = *(_DWORD *)(a1 + 24);
  v96.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v97) = *(_DWORD *)(a1 + 36);
  *(float *)v98.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v93, 1), *(float *)v96.i32, v93.f32[0]);
  v99 = (float64x2_t)v231;
  v232 = vaddq_f32(v231, v92);
  v92.f32[0] = *(float *)&v95 + *(float *)&v94;
  *(float *)v99.f64 = *(float *)&v97 + *(float *)v98.i32;
  v92.f32[1] = *(float *)&v97 + *(float *)v98.i32;
  *(double *)v101.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v92.i64, v99, v95, v94, v96, v98, v97, v100);
  HIDWORD(v102) = v247.i32[1];
  v103 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v238.f32, *(int8x8_t *)v247.i8, 4uLL), v4);
  *(float *)&v104 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v103, 1), *(float *)(a1 + 16), v103.f32[0]);
  LODWORD(v102) = *(_DWORD *)(a1 + 24);
  v105.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v106) = *(_DWORD *)(a1 + 36);
  *(float *)v107.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v103, 1), *(float *)v105.i32, v103.f32[0]);
  v108 = (float64x2_t)v232;
  v233 = vaddq_f32(v232, v101);
  v101.f32[0] = *(float *)&v102 + *(float *)&v104;
  *(float *)v108.f64 = *(float *)&v106 + *(float *)v107.i32;
  v101.f32[1] = *(float *)&v106 + *(float *)v107.i32;
  *(double *)v110.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v101.i64, v108, v102, v104, v105, v107, v106, v109);
  v111 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v247.i8), v4);
  *(float *)&v112 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v111, 1), *(float *)(a1 + 16), v111.f32[0]);
  LODWORD(v113) = *(_DWORD *)(a1 + 24);
  v114.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v115) = *(_DWORD *)(a1 + 36);
  *(float *)v116.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v111, 1), *(float *)v114.i32, v111.f32[0]);
  v117 = (float64x2_t)v233;
  v234 = vaddq_f32(v233, v110);
  v110.f32[0] = *(float *)&v113 + *(float *)&v112;
  *(float *)v117.f64 = *(float *)&v115 + *(float *)v116.i32;
  v110.f32[1] = *(float *)&v115 + *(float *)v116.i32;
  *(double *)v119.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v110.i64, v117, v113, v112, v114, v116, v115, v118);
  HIDWORD(v120) = v247.i32[1];
  v121 = vadd_f32((float32x2_t)__PAIR64__(v247.u32[1], v238.u32[0]), v4);
  *(float *)&v122 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v121, 1), *(float *)(a1 + 16), v121.f32[0]);
  LODWORD(v120) = *(_DWORD *)(a1 + 24);
  v123.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v124) = *(_DWORD *)(a1 + 36);
  *(float *)v125.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v121, 1), *(float *)v123.i32, v121.f32[0]);
  v126 = (float64x2_t)v234;
  v235 = vaddq_f32(v234, v119);
  v119.f32[0] = *(float *)&v120 + *(float *)&v122;
  *(float *)v126.f64 = *(float *)&v124 + *(float *)v125.i32;
  v119.f32[1] = *(float *)&v124 + *(float *)v125.i32;
  *(double *)v128.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v119.i64, v126, v120, v122, v123, v125, v124, v127);
  v129 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v238.f32), v4);
  *(float *)&v130 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v129, 1), *(float *)(a1 + 16), v129.f32[0]);
  LODWORD(v131) = *(_DWORD *)(a1 + 24);
  v132.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v133) = *(_DWORD *)(a1 + 36);
  *(float *)v134.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v129, 1), *(float *)v132.i32, v129.f32[0]);
  v135 = (float64x2_t)v235;
  v236 = vaddq_f32(v235, v128);
  v128.f32[0] = *(float *)&v131 + *(float *)&v130;
  *(float *)v135.f64 = *(float *)&v133 + *(float *)v134.i32;
  v128.f32[1] = *(float *)&v133 + *(float *)v134.i32;
  *(double *)v137.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v128.i64, v135, v131, v130, v132, v134, v133, v136);
  HIDWORD(v138) = v238.i32[1];
  v139 = vadd_f32((float32x2_t)__PAIR64__(v238.u32[1], v247.u32[0]), v4);
  *(float *)&v140 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v139, 1), *(float *)(a1 + 16), v139.f32[0]);
  LODWORD(v138) = *(_DWORD *)(a1 + 24);
  v141.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v142) = *(_DWORD *)(a1 + 36);
  *(float *)v143.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v139, 1), *(float *)v141.i32, v139.f32[0]);
  v144 = (float64x2_t)v236;
  v248 = vaddq_f32(v236, v137);
  v137.f32[0] = *(float *)&v138 + *(float *)&v140;
  *(float *)v144.f64 = *(float *)&v142 + *(float *)v143.i32;
  v137.f32[1] = *(float *)&v142 + *(float *)v143.i32;
  *(double *)v146.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v137.i64, v144, v138, v140, v141, v143, v142, v145);
  v147 = vadd_f32(*(float32x2_t *)a3.i8, v4);
  *(float *)&v148 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v147, 1), *(float *)(a1 + 16), v147.f32[0]);
  LODWORD(v149) = *(_DWORD *)(a1 + 24);
  v150.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v151) = *(_DWORD *)(a1 + 36);
  *(float *)v152.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v147, 1), *(float *)v150.i32, v147.f32[0]);
  v153 = (float64x2_t)v248;
  v239 = vaddq_f32(v248, v146);
  *(float32x2_t *)v248.f32 = vneg_f32(*(float32x2_t *)a3.i8);
  v146.f32[0] = *(float *)&v149 + *(float *)&v148;
  *(float *)v153.f64 = *(float *)&v151 + *(float *)v152.i32;
  v146.f32[1] = *(float *)&v151 + *(float *)v152.i32;
  *(double *)v154.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v146.i64, v153, v149, v148, v150, v152, v151, a3);
  HIDWORD(v155) = a3.i32[1];
  v156 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)a3.i8, *(int8x8_t *)v248.f32, 4uLL), v4);
  *(float *)&v157 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v156, 1), *(float *)(a1 + 16), v156.f32[0]);
  LODWORD(v155) = *(_DWORD *)(a1 + 24);
  v158.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v159) = *(_DWORD *)(a1 + 36);
  *(float *)v160.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v156, 1), *(float *)v158.i32, v156.f32[0]);
  v161 = (float64x2_t)v239;
  v240 = vaddq_f32(v239, v154);
  v154.f32[0] = *(float *)&v155 + *(float *)&v157;
  *(float *)v161.f64 = *(float *)&v159 + *(float *)v160.i32;
  v154.f32[1] = *(float *)&v159 + *(float *)v160.i32;
  *(double *)v163.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v154.i64, v161, v155, v157, v158, v160, v159, v162);
  v164 = vsub_f32(v4, *(float32x2_t *)a3.i8);
  *(float *)&v165 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v164, 1), *(float *)(a1 + 16), v164.f32[0]);
  LODWORD(v166) = *(_DWORD *)(a1 + 24);
  v167.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v168) = *(_DWORD *)(a1 + 36);
  *(float *)v169.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v164, 1), *(float *)v167.i32, v164.f32[0]);
  v170 = (float64x2_t)v240;
  v241 = vaddq_f32(v240, v163);
  v163.f32[0] = *(float *)&v166 + *(float *)&v165;
  *(float *)v170.f64 = *(float *)&v168 + *(float *)v169.i32;
  v163.f32[1] = *(float *)&v168 + *(float *)v169.i32;
  *(double *)v172.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v163.i64, v170, v166, v165, v167, v169, v168, v171);
  HIDWORD(v173) = a3.i32[1];
  v174 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v248.f32, *(int8x8_t *)a3.i8, 4uLL), v4);
  *(float *)&v175 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v174, 1), *(float *)(a1 + 16), v174.f32[0]);
  LODWORD(v173) = *(_DWORD *)(a1 + 24);
  v176.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v177) = *(_DWORD *)(a1 + 36);
  *(float *)v178.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v174, 1), *(float *)v176.i32, v174.f32[0]);
  v179 = (float64x2_t)v241;
  v242 = vaddq_f32(v241, v172);
  v172.f32[0] = *(float *)&v173 + *(float *)&v175;
  *(float *)v179.f64 = *(float *)&v177 + *(float *)v178.i32;
  v172.f32[1] = *(float *)&v177 + *(float *)v178.i32;
  *(double *)v181.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v172.i64, v179, v173, v175, v176, v178, v177, v180);
  v182 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)a3.i8), v4);
  *(float *)&v183 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v182, 1), *(float *)(a1 + 16), v182.f32[0]);
  LODWORD(v184) = *(_DWORD *)(a1 + 24);
  v185.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v186) = *(_DWORD *)(a1 + 36);
  *(float *)v187.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v182, 1), *(float *)v185.i32, v182.f32[0]);
  v188 = (float64x2_t)v242;
  v243 = vaddq_f32(v242, v181);
  v181.f32[0] = *(float *)&v184 + *(float *)&v183;
  *(float *)v188.f64 = *(float *)&v186 + *(float *)v187.i32;
  v181.f32[1] = *(float *)&v186 + *(float *)v187.i32;
  *(double *)v190.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v181.i64, v188, v184, v183, v185, v187, v186, v189);
  HIDWORD(v191) = a3.i32[1];
  v192 = vadd_f32((float32x2_t)__PAIR64__(a3.u32[1], v248.u32[0]), v4);
  *(float *)&v193 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v192, 1), *(float *)(a1 + 16), v192.f32[0]);
  LODWORD(v191) = *(_DWORD *)(a1 + 24);
  v194.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v195) = *(_DWORD *)(a1 + 36);
  *(float *)v196.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v192, 1), *(float *)v194.i32, v192.f32[0]);
  v197 = (float64x2_t)v243;
  v244 = vaddq_f32(v243, v190);
  v190.f32[0] = *(float *)&v191 + *(float *)&v193;
  *(float *)v197.f64 = *(float *)&v195 + *(float *)v196.i32;
  v190.f32[1] = *(float *)&v195 + *(float *)v196.i32;
  *(double *)v199.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v190.i64, v197, v191, v193, v194, v196, v195, v198);
  v200 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v248.f32), v4);
  *(float *)&v201 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v200, 1), *(float *)(a1 + 16), v200.f32[0]);
  LODWORD(v202) = *(_DWORD *)(a1 + 24);
  v203.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v204) = *(_DWORD *)(a1 + 36);
  *(float *)v205.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v200, 1), *(float *)v203.i32, v200.f32[0]);
  v206 = (float64x2_t)v244;
  v245 = vaddq_f32(v244, v199);
  v199.f32[0] = *(float *)&v202 + *(float *)&v201;
  *(float *)v206.f64 = *(float *)&v204 + *(float *)v205.i32;
  v199.f32[1] = *(float *)&v204 + *(float *)v205.i32;
  *(double *)v208.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v199.i64, v206, v202, v201, v203, v205, v204, v207);
  HIDWORD(v209) = v248.i32[1];
  v210 = vadd_f32((float32x2_t)__PAIR64__(v248.u32[1], a3.u32[0]), v4);
  *(float *)&v211 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v210, 1), *(float *)(a1 + 16), v210.f32[0]);
  LODWORD(v209) = *(_DWORD *)(a1 + 24);
  v212.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v213) = *(_DWORD *)(a1 + 36);
  *(float *)v214.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v210, 1), *(float *)v212.i32, v210.f32[0]);
  v215 = (float64x2_t)v245;
  v249 = vaddq_f32(v245, v208);
  v208.f32[0] = *(float *)&v209 + *(float *)&v211;
  *(float *)v215.f64 = *(float *)&v213 + *(float *)v214.i32;
  v208.f32[1] = *(float *)&v213 + *(float *)v214.i32;
  *(double *)v217.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v208.i64, v215, v209, v211, v212, v214, v213, v216);
  __asm { FMOV            V1.4S, #24.0 }
  *(_QWORD *)&result = vdivq_f32(vaddq_f32(v249, v217), _Q1).u64[0];
  return result;
}

void CI::f4_sr_f4_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, __n128, double);
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  double *v18;
  __n128 *v19;
  __int128 v20;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, __n128, double))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_DWORD *)(v11 + 40);
  v15 = *(_QWORD *)(v11 + 32);
  v16 = *(_DWORD *)(v11 + 64);
  v17 = *(_QWORD *)(v11 + 56);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 80)), a2);
  v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (double *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v15);
  *(double *)&v20 = v12(a4 + 80 * v13, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_ringAvg32(uint64_t a1, int8x16_t a2, int8x16_t a3)
{
  float32x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  float64x2_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  float32x2_t v15;
  double v16;
  int8x16_t v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  double v26;
  uint8x8_t v27;
  float64x2_t v28;
  int8x16_t v29;
  float32x4_t v30;
  double v31;
  float32x2_t v32;
  double v33;
  int8x16_t v34;
  double v35;
  uint8x8_t v36;
  float64x2_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x2_t v40;
  double v41;
  double v42;
  int8x16_t v43;
  double v44;
  uint8x8_t v45;
  float64x2_t v46;
  int8x16_t v47;
  float32x4_t v48;
  double v49;
  float32x2_t v50;
  double v51;
  int8x16_t v52;
  double v53;
  uint8x8_t v54;
  float64x2_t v55;
  int8x16_t v56;
  float32x4_t v57;
  float32x2_t v58;
  double v59;
  double v60;
  int8x16_t v61;
  double v62;
  uint8x8_t v63;
  float64x2_t v64;
  int8x16_t v65;
  float32x4_t v66;
  double v67;
  float32x2_t v68;
  double v69;
  int8x16_t v70;
  double v71;
  uint8x8_t v72;
  float64x2_t v73;
  int8x16_t v74;
  float32x4_t v75;
  int8x16_t v76;
  float32x2_t v77;
  int8x16_t v78;
  double v79;
  double v80;
  uint8x8_t v81;
  float64x2_t v82;
  float32x4_t v83;
  double v84;
  float32x2_t v85;
  double v86;
  int8x16_t v87;
  double v88;
  uint8x8_t v89;
  float64x2_t v90;
  int8x16_t v91;
  float32x4_t v92;
  float32x2_t v93;
  double v94;
  double v95;
  int8x16_t v96;
  double v97;
  uint8x8_t v98;
  float64x2_t v99;
  int8x16_t v100;
  float32x4_t v101;
  double v102;
  float32x2_t v103;
  double v104;
  int8x16_t v105;
  double v106;
  uint8x8_t v107;
  float64x2_t v108;
  int8x16_t v109;
  float32x4_t v110;
  float32x2_t v111;
  double v112;
  double v113;
  int8x16_t v114;
  double v115;
  uint8x8_t v116;
  float64x2_t v117;
  int8x16_t v118;
  float32x4_t v119;
  double v120;
  float32x2_t v121;
  double v122;
  int8x16_t v123;
  double v124;
  uint8x8_t v125;
  float64x2_t v126;
  int8x16_t v127;
  float32x4_t v128;
  float32x2_t v129;
  double v130;
  double v131;
  int8x16_t v132;
  double v133;
  uint8x8_t v134;
  float64x2_t v135;
  int8x16_t v136;
  float32x4_t v137;
  double v138;
  float32x2_t v139;
  double v140;
  int8x16_t v141;
  double v142;
  uint8x8_t v143;
  float64x2_t v144;
  int8x16_t v145;
  float32x4_t v146;
  float32x2_t v147;
  double v148;
  double v149;
  double v150;
  uint8x8_t v151;
  float64x2_t v152;
  float32x4_t v153;
  double v154;
  float32x2_t v155;
  double v156;
  int8x16_t v157;
  double v158;
  uint8x8_t v159;
  float64x2_t v160;
  int8x16_t v161;
  float32x4_t v162;
  float32x2_t v163;
  double v164;
  double v165;
  int8x16_t v166;
  double v167;
  uint8x8_t v168;
  float64x2_t v169;
  int8x16_t v170;
  float32x4_t v171;
  double v172;
  float32x2_t v173;
  double v174;
  int8x16_t v175;
  double v176;
  uint8x8_t v177;
  float64x2_t v178;
  int8x16_t v179;
  float32x4_t v180;
  float32x2_t v181;
  double v182;
  double v183;
  int8x16_t v184;
  double v185;
  uint8x8_t v186;
  float64x2_t v187;
  int8x16_t v188;
  float32x4_t v189;
  double v190;
  float32x2_t v191;
  double v192;
  int8x16_t v193;
  double v194;
  uint8x8_t v195;
  float64x2_t v196;
  int8x16_t v197;
  float32x4_t v198;
  float32x2_t v199;
  double v200;
  double v201;
  int8x16_t v202;
  double v203;
  uint8x8_t v204;
  float64x2_t v205;
  int8x16_t v206;
  float32x4_t v207;
  double v208;
  float32x2_t v209;
  double v210;
  int8x16_t v211;
  double v212;
  uint8x8_t v213;
  float64x2_t v214;
  int8x16_t v215;
  float32x4_t v216;
  int8x16_t v217;
  float32x2_t v218;
  int8x16_t v219;
  double v220;
  double v221;
  uint8x8_t v222;
  float64x2_t v223;
  float32x4_t v224;
  double v225;
  float32x2_t v226;
  double v227;
  int8x16_t v228;
  double v229;
  uint8x8_t v230;
  float64x2_t v231;
  int8x16_t v232;
  float32x4_t v233;
  float32x2_t v234;
  double v235;
  double v236;
  int8x16_t v237;
  double v238;
  uint8x8_t v239;
  float64x2_t v240;
  int8x16_t v241;
  float32x4_t v242;
  double v243;
  float32x2_t v244;
  double v245;
  int8x16_t v246;
  double v247;
  uint8x8_t v248;
  float64x2_t v249;
  int8x16_t v250;
  float32x4_t v251;
  float32x2_t v252;
  double v253;
  double v254;
  int8x16_t v255;
  double v256;
  uint8x8_t v257;
  float64x2_t v258;
  int8x16_t v259;
  float32x4_t v260;
  double v261;
  float32x2_t v262;
  double v263;
  int8x16_t v264;
  double v265;
  uint8x8_t v266;
  float64x2_t v267;
  int8x16_t v268;
  float32x4_t v269;
  float32x2_t v270;
  double v271;
  double v272;
  int8x16_t v273;
  double v274;
  uint8x8_t v275;
  float64x2_t v276;
  int8x16_t v277;
  float32x4_t v278;
  double v279;
  float32x2_t v280;
  double v281;
  int8x16_t v282;
  double v283;
  uint8x8_t v284;
  float64x2_t v285;
  int8x16_t v286;
  float32x4_t v287;
  float32x4_t v288;
  double result;
  float32x4_t v290;
  float32x4_t v291;
  float32x4_t v292;
  float32x4_t v293;
  float32x4_t v294;
  float32x4_t v295;
  float32x4_t v296;
  float32x4_t v297;
  float32x4_t v298;
  float32x4_t v299;
  float32x4_t v300;
  float32x4_t v301;
  float32x4_t v302;
  int32x2_t v303;
  float32x4_t v304;
  float32x4_t v305;
  float32x4_t v306;
  float32x4_t v307;
  float32x4_t v308;
  float32x4_t v309;
  float32x4_t v310;
  float32x4_t v311;
  float32x4_t v312;
  float32x4_t v313;
  float32x4_t v314;
  float32x4_t v315;
  float32x4_t v316;
  float32x4_t v317;
  float32x4_t v318;
  int8x16_t v319;
  float32x4_t v320;
  float32x4_t v321;
  float32x4_t v323;

  v319 = a2;
  v303 = (int32x2_t)vneg_f32(*(float32x2_t *)a2.i8);
  v4 = *(float32x2_t *)CI::getDC((CI *)a1);
  v5 = vadd_f32(*(float32x2_t *)v319.i8, v4);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v10, v6, v7, v9, v8, v11, v12);
  HIDWORD(v14) = v303.i32[1];
  v15 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v319.i8, (int8x8_t)v303, 4uLL), v4);
  *(float *)&v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v15, 1), *(float *)(a1 + 16), v15.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 24);
  v17.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v18) = *(_DWORD *)(a1 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v15, 1), *(float *)v17.i32, v15.f32[0]);
  v290 = vaddq_f32(v13, (float32x4_t)0);
  v13.f32[0] = *(float *)&v14 + *(float *)&v16;
  v13.f32[1] = *(float *)&v18 + *(float *)v19.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)&v18 + *(float *)v19.i32), v14, v16, v17, v19, v18, v20);
  v22 = vsub_f32(v4, *(float32x2_t *)v319.i8);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 24);
  v25.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v26) = *(_DWORD *)(a1 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)v25.i32, v22.f32[0]);
  v28 = (float64x2_t)v290;
  v291 = vaddq_f32(v290, v21);
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  *(float *)v28.f64 = *(float *)&v26 + *(float *)v27.i32;
  v21.f32[1] = *(float *)&v26 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v28, v24, v23, v25, v27, v26, v29);
  HIDWORD(v31) = v303.i32[1];
  v32 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v303, *(int8x8_t *)v319.i8, 4uLL), v4);
  *(float *)&v33 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v32, 1), *(float *)(a1 + 16), v32.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 24);
  v34.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v35) = *(_DWORD *)(a1 + 36);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v32, 1), *(float *)v34.i32, v32.f32[0]);
  v37 = (float64x2_t)v291;
  v292 = vaddq_f32(v291, v30);
  v30.f32[0] = *(float *)&v31 + *(float *)&v33;
  *(float *)v37.f64 = *(float *)&v35 + *(float *)v36.i32;
  v30.f32[1] = *(float *)&v35 + *(float *)v36.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v30.i64, v37, v31, v33, v34, v36, v35, v38);
  v40 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v319.i8), v4);
  *(float *)&v41 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v40, 1), *(float *)(a1 + 16), v40.f32[0]);
  LODWORD(v42) = *(_DWORD *)(a1 + 24);
  v43.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v44) = *(_DWORD *)(a1 + 36);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v40, 1), *(float *)v43.i32, v40.f32[0]);
  v46 = (float64x2_t)v292;
  v293 = vaddq_f32(v292, v39);
  v39.f32[0] = *(float *)&v42 + *(float *)&v41;
  *(float *)v46.f64 = *(float *)&v44 + *(float *)v45.i32;
  v39.f32[1] = *(float *)&v44 + *(float *)v45.i32;
  *(double *)v48.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v39.i64, v46, v42, v41, v43, v45, v44, v47);
  HIDWORD(v49) = v319.i32[1];
  v50 = vadd_f32((float32x2_t)__PAIR64__(v319.u32[1], v303.u32[0]), v4);
  *(float *)&v51 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v50, 1), *(float *)(a1 + 16), v50.f32[0]);
  LODWORD(v49) = *(_DWORD *)(a1 + 24);
  v52.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v53) = *(_DWORD *)(a1 + 36);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v50, 1), *(float *)v52.i32, v50.f32[0]);
  v55 = (float64x2_t)v293;
  v294 = vaddq_f32(v293, v48);
  v48.f32[0] = *(float *)&v49 + *(float *)&v51;
  *(float *)v55.f64 = *(float *)&v53 + *(float *)v54.i32;
  v48.f32[1] = *(float *)&v53 + *(float *)v54.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v48.i64, v55, v49, v51, v52, v54, v53, v56);
  v58 = vadd_f32((float32x2_t)vrev64_s32(v303), v4);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v58, 1), *(float *)(a1 + 16), v58.f32[0]);
  LODWORD(v60) = *(_DWORD *)(a1 + 24);
  v61.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v62) = *(_DWORD *)(a1 + 36);
  *(float *)v63.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v58, 1), *(float *)v61.i32, v58.f32[0]);
  v64 = (float64x2_t)v294;
  v295 = vaddq_f32(v294, v57);
  v57.f32[0] = *(float *)&v60 + *(float *)&v59;
  *(float *)v64.f64 = *(float *)&v62 + *(float *)v63.i32;
  v57.f32[1] = *(float *)&v62 + *(float *)v63.i32;
  *(double *)v66.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v57.i64, v64, v60, v59, v61, v63, v62, v65);
  HIDWORD(v67) = v303.i32[1];
  v68 = vadd_f32((float32x2_t)__PAIR64__(v303.u32[1], v319.u32[0]), v4);
  *(float *)&v69 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v68, 1), *(float *)(a1 + 16), v68.f32[0]);
  LODWORD(v67) = *(_DWORD *)(a1 + 24);
  v70.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v71) = *(_DWORD *)(a1 + 36);
  *(float *)v72.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v68, 1), *(float *)v70.i32, v68.f32[0]);
  v73 = (float64x2_t)v295;
  v304 = vaddq_f32(v295, v66);
  v66.f32[0] = *(float *)&v67 + *(float *)&v69;
  *(float *)v73.f64 = *(float *)&v71 + *(float *)v72.i32;
  v66.f32[1] = *(float *)&v71 + *(float *)v72.i32;
  *(double *)v75.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v66.i64, v73, v67, v69, v70, v72, v71, v74);
  v76 = vextq_s8(v319, v319, 8uLL);
  v77 = vadd_f32(*(float32x2_t *)v76.i8, v4);
  v78 = v76;
  v319.i64[0] = v76.i64[0];
  *(float *)&v79 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v77, 1), *(float *)(a1 + 16), v77.f32[0]);
  v76.i32[0] = *(_DWORD *)(a1 + 24);
  LODWORD(v80) = *(_DWORD *)(a1 + 36);
  *(float *)v81.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v77, 1), *(float *)(a1 + 28), v77.f32[0]);
  v82 = (float64x2_t)v304;
  v296 = vaddq_f32(v304, v75);
  *(float32x2_t *)v304.f32 = vneg_f32(*(float32x2_t *)v78.i8);
  v75.f32[0] = *(float *)v76.i32 + *(float *)&v79;
  *(float *)v82.f64 = *(float *)&v80 + *(float *)v81.i32;
  v75.f32[1] = *(float *)&v80 + *(float *)v81.i32;
  *(double *)v83.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v75.i64, v82, *(double *)v76.i64, v79, (int8x16_t)v296, v81, v80, v78);
  HIDWORD(v84) = v319.i32[1];
  v85 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v319.i8, *(int8x8_t *)v304.f32, 4uLL), v4);
  *(float *)&v86 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v85, 1), *(float *)(a1 + 16), v85.f32[0]);
  LODWORD(v84) = *(_DWORD *)(a1 + 24);
  v87.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v88) = *(_DWORD *)(a1 + 36);
  *(float *)v89.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v85, 1), *(float *)v87.i32, v85.f32[0]);
  v90 = (float64x2_t)v296;
  v297 = vaddq_f32(v296, v83);
  v83.f32[0] = *(float *)&v84 + *(float *)&v86;
  *(float *)v90.f64 = *(float *)&v88 + *(float *)v89.i32;
  v83.f32[1] = *(float *)&v88 + *(float *)v89.i32;
  *(double *)v92.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v83.i64, v90, v84, v86, v87, v89, v88, v91);
  v93 = vsub_f32(v4, *(float32x2_t *)v319.i8);
  *(float *)&v94 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v93, 1), *(float *)(a1 + 16), v93.f32[0]);
  LODWORD(v95) = *(_DWORD *)(a1 + 24);
  v96.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v97) = *(_DWORD *)(a1 + 36);
  *(float *)v98.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v93, 1), *(float *)v96.i32, v93.f32[0]);
  v99 = (float64x2_t)v297;
  v298 = vaddq_f32(v297, v92);
  v92.f32[0] = *(float *)&v95 + *(float *)&v94;
  *(float *)v99.f64 = *(float *)&v97 + *(float *)v98.i32;
  v92.f32[1] = *(float *)&v97 + *(float *)v98.i32;
  *(double *)v101.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v92.i64, v99, v95, v94, v96, v98, v97, v100);
  HIDWORD(v102) = v319.i32[1];
  v103 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v304.f32, *(int8x8_t *)v319.i8, 4uLL), v4);
  *(float *)&v104 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v103, 1), *(float *)(a1 + 16), v103.f32[0]);
  LODWORD(v102) = *(_DWORD *)(a1 + 24);
  v105.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v106) = *(_DWORD *)(a1 + 36);
  *(float *)v107.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v103, 1), *(float *)v105.i32, v103.f32[0]);
  v108 = (float64x2_t)v298;
  v299 = vaddq_f32(v298, v101);
  v101.f32[0] = *(float *)&v102 + *(float *)&v104;
  *(float *)v108.f64 = *(float *)&v106 + *(float *)v107.i32;
  v101.f32[1] = *(float *)&v106 + *(float *)v107.i32;
  *(double *)v110.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v101.i64, v108, v102, v104, v105, v107, v106, v109);
  v111 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v319.i8), v4);
  *(float *)&v112 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v111, 1), *(float *)(a1 + 16), v111.f32[0]);
  LODWORD(v113) = *(_DWORD *)(a1 + 24);
  v114.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v115) = *(_DWORD *)(a1 + 36);
  *(float *)v116.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v111, 1), *(float *)v114.i32, v111.f32[0]);
  v117 = (float64x2_t)v299;
  v300 = vaddq_f32(v299, v110);
  v110.f32[0] = *(float *)&v113 + *(float *)&v112;
  *(float *)v117.f64 = *(float *)&v115 + *(float *)v116.i32;
  v110.f32[1] = *(float *)&v115 + *(float *)v116.i32;
  *(double *)v119.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v110.i64, v117, v113, v112, v114, v116, v115, v118);
  HIDWORD(v120) = v319.i32[1];
  v121 = vadd_f32((float32x2_t)__PAIR64__(v319.u32[1], v304.u32[0]), v4);
  *(float *)&v122 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v121, 1), *(float *)(a1 + 16), v121.f32[0]);
  LODWORD(v120) = *(_DWORD *)(a1 + 24);
  v123.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v124) = *(_DWORD *)(a1 + 36);
  *(float *)v125.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v121, 1), *(float *)v123.i32, v121.f32[0]);
  v126 = (float64x2_t)v300;
  v301 = vaddq_f32(v300, v119);
  v119.f32[0] = *(float *)&v120 + *(float *)&v122;
  *(float *)v126.f64 = *(float *)&v124 + *(float *)v125.i32;
  v119.f32[1] = *(float *)&v124 + *(float *)v125.i32;
  *(double *)v128.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v119.i64, v126, v120, v122, v123, v125, v124, v127);
  v129 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v304.f32), v4);
  *(float *)&v130 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v129, 1), *(float *)(a1 + 16), v129.f32[0]);
  LODWORD(v131) = *(_DWORD *)(a1 + 24);
  v132.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v133) = *(_DWORD *)(a1 + 36);
  *(float *)v134.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v129, 1), *(float *)v132.i32, v129.f32[0]);
  v135 = (float64x2_t)v301;
  v302 = vaddq_f32(v301, v128);
  v128.f32[0] = *(float *)&v131 + *(float *)&v130;
  *(float *)v135.f64 = *(float *)&v133 + *(float *)v134.i32;
  v128.f32[1] = *(float *)&v133 + *(float *)v134.i32;
  *(double *)v137.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v128.i64, v135, v131, v130, v132, v134, v133, v136);
  HIDWORD(v138) = v304.i32[1];
  v139 = vadd_f32((float32x2_t)__PAIR64__(v304.u32[1], v319.u32[0]), v4);
  *(float *)&v140 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v139, 1), *(float *)(a1 + 16), v139.f32[0]);
  LODWORD(v138) = *(_DWORD *)(a1 + 24);
  v141.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v142) = *(_DWORD *)(a1 + 36);
  *(float *)v143.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v139, 1), *(float *)v141.i32, v139.f32[0]);
  v144 = (float64x2_t)v302;
  v320 = vaddq_f32(v302, v137);
  v137.f32[0] = *(float *)&v138 + *(float *)&v140;
  *(float *)v144.f64 = *(float *)&v142 + *(float *)v143.i32;
  v137.f32[1] = *(float *)&v142 + *(float *)v143.i32;
  *(double *)v146.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v137.i64, v144, v138, v140, v141, v143, v142, v145);
  v147 = vadd_f32(*(float32x2_t *)a3.i8, v4);
  *(float *)&v148 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v147, 1), *(float *)(a1 + 16), v147.f32[0]);
  LODWORD(v149) = *(_DWORD *)(a1 + 24);
  LODWORD(v150) = *(_DWORD *)(a1 + 36);
  *(float *)v151.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v147, 1), *(float *)(a1 + 28), v147.f32[0]);
  v152 = (float64x2_t)v320;
  v305 = vaddq_f32(v320, v146);
  *(float32x2_t *)v320.f32 = vneg_f32(*(float32x2_t *)a3.i8);
  v146.f32[0] = *(float *)&v149 + *(float *)&v148;
  *(float *)v152.f64 = *(float *)&v150 + *(float *)v151.i32;
  v146.f32[1] = *(float *)&v150 + *(float *)v151.i32;
  *(double *)v153.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v146.i64, v152, v149, v148, (int8x16_t)v305, v151, v150, a3);
  HIDWORD(v154) = v320.i32[1];
  v155 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)a3.i8, *(int8x8_t *)v320.f32, 4uLL), v4);
  *(float *)&v156 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v155, 1), *(float *)(a1 + 16), v155.f32[0]);
  LODWORD(v154) = *(_DWORD *)(a1 + 24);
  v157.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v158) = *(_DWORD *)(a1 + 36);
  *(float *)v159.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v155, 1), *(float *)v157.i32, v155.f32[0]);
  v160 = (float64x2_t)v305;
  v306 = vaddq_f32(v305, v153);
  v153.f32[0] = *(float *)&v154 + *(float *)&v156;
  *(float *)v160.f64 = *(float *)&v158 + *(float *)v159.i32;
  v153.f32[1] = *(float *)&v158 + *(float *)v159.i32;
  *(double *)v162.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v153.i64, v160, v154, v156, v157, v159, v158, v161);
  v163 = vsub_f32(v4, *(float32x2_t *)a3.i8);
  *(float *)&v164 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v163, 1), *(float *)(a1 + 16), v163.f32[0]);
  LODWORD(v165) = *(_DWORD *)(a1 + 24);
  v166.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v167) = *(_DWORD *)(a1 + 36);
  *(float *)v168.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v163, 1), *(float *)v166.i32, v163.f32[0]);
  v169 = (float64x2_t)v306;
  v307 = vaddq_f32(v306, v162);
  v162.f32[0] = *(float *)&v165 + *(float *)&v164;
  *(float *)v169.f64 = *(float *)&v167 + *(float *)v168.i32;
  v162.f32[1] = *(float *)&v167 + *(float *)v168.i32;
  *(double *)v171.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v162.i64, v169, v165, v164, v166, v168, v167, v170);
  HIDWORD(v172) = v320.i32[1];
  v173 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v320.f32, *(int8x8_t *)a3.i8, 4uLL), v4);
  *(float *)&v174 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v173, 1), *(float *)(a1 + 16), v173.f32[0]);
  LODWORD(v172) = *(_DWORD *)(a1 + 24);
  v175.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v176) = *(_DWORD *)(a1 + 36);
  *(float *)v177.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v173, 1), *(float *)v175.i32, v173.f32[0]);
  v178 = (float64x2_t)v307;
  v308 = vaddq_f32(v307, v171);
  v171.f32[0] = *(float *)&v172 + *(float *)&v174;
  *(float *)v178.f64 = *(float *)&v176 + *(float *)v177.i32;
  v171.f32[1] = *(float *)&v176 + *(float *)v177.i32;
  *(double *)v180.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v171.i64, v178, v172, v174, v175, v177, v176, v179);
  v181 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)a3.i8), v4);
  *(float *)&v182 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v181, 1), *(float *)(a1 + 16), v181.f32[0]);
  LODWORD(v183) = *(_DWORD *)(a1 + 24);
  v184.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v185) = *(_DWORD *)(a1 + 36);
  *(float *)v186.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v181, 1), *(float *)v184.i32, v181.f32[0]);
  v187 = (float64x2_t)v308;
  v309 = vaddq_f32(v308, v180);
  v180.f32[0] = *(float *)&v183 + *(float *)&v182;
  *(float *)v187.f64 = *(float *)&v185 + *(float *)v186.i32;
  v180.f32[1] = *(float *)&v185 + *(float *)v186.i32;
  *(double *)v189.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v180.i64, v187, v183, v182, v184, v186, v185, v188);
  HIDWORD(v190) = a3.i32[1];
  v191 = vadd_f32((float32x2_t)__PAIR64__(a3.u32[1], v320.u32[0]), v4);
  *(float *)&v192 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v191, 1), *(float *)(a1 + 16), v191.f32[0]);
  LODWORD(v190) = *(_DWORD *)(a1 + 24);
  v193.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v194) = *(_DWORD *)(a1 + 36);
  *(float *)v195.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v191, 1), *(float *)v193.i32, v191.f32[0]);
  v196 = (float64x2_t)v309;
  v310 = vaddq_f32(v309, v189);
  v189.f32[0] = *(float *)&v190 + *(float *)&v192;
  *(float *)v196.f64 = *(float *)&v194 + *(float *)v195.i32;
  v189.f32[1] = *(float *)&v194 + *(float *)v195.i32;
  *(double *)v198.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v189.i64, v196, v190, v192, v193, v195, v194, v197);
  v199 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v320.f32), v4);
  *(float *)&v200 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v199, 1), *(float *)(a1 + 16), v199.f32[0]);
  LODWORD(v201) = *(_DWORD *)(a1 + 24);
  v202.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v203) = *(_DWORD *)(a1 + 36);
  *(float *)v204.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v199, 1), *(float *)v202.i32, v199.f32[0]);
  v205 = (float64x2_t)v310;
  v311 = vaddq_f32(v310, v198);
  v198.f32[0] = *(float *)&v201 + *(float *)&v200;
  *(float *)v205.f64 = *(float *)&v203 + *(float *)v204.i32;
  v198.f32[1] = *(float *)&v203 + *(float *)v204.i32;
  *(double *)v207.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v198.i64, v205, v201, v200, v202, v204, v203, v206);
  HIDWORD(v208) = v320.i32[1];
  v209 = vadd_f32((float32x2_t)__PAIR64__(v320.u32[1], a3.u32[0]), v4);
  *(float *)&v210 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v209, 1), *(float *)(a1 + 16), v209.f32[0]);
  LODWORD(v208) = *(_DWORD *)(a1 + 24);
  v211.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v212) = *(_DWORD *)(a1 + 36);
  *(float *)v213.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v209, 1), *(float *)v211.i32, v209.f32[0]);
  v214 = (float64x2_t)v311;
  v321 = vaddq_f32(v311, v207);
  v207.f32[0] = *(float *)&v208 + *(float *)&v210;
  *(float *)v214.f64 = *(float *)&v212 + *(float *)v213.i32;
  v207.f32[1] = *(float *)&v212 + *(float *)v213.i32;
  *(double *)v216.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v207.i64, v214, v208, v210, v211, v213, v212, v215);
  v217 = vextq_s8(a3, a3, 8uLL);
  v218 = vadd_f32(*(float32x2_t *)v217.i8, v4);
  v219 = v217;
  a3.i64[0] = v217.i64[0];
  *(float *)&v220 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v218, 1), *(float *)(a1 + 16), v218.f32[0]);
  v217.i32[0] = *(_DWORD *)(a1 + 24);
  LODWORD(v221) = *(_DWORD *)(a1 + 36);
  *(float *)v222.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v218, 1), *(float *)(a1 + 28), v218.f32[0]);
  v223 = (float64x2_t)v321;
  v312 = vaddq_f32(v321, v216);
  *(float32x2_t *)v321.f32 = vneg_f32(*(float32x2_t *)v219.i8);
  v216.f32[0] = *(float *)v217.i32 + *(float *)&v220;
  *(float *)v223.f64 = *(float *)&v221 + *(float *)v222.i32;
  v216.f32[1] = *(float *)&v221 + *(float *)v222.i32;
  *(double *)v224.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v216.i64, v223, *(double *)v217.i64, v220, (int8x16_t)v312, v222, v221, v219);
  HIDWORD(v225) = a3.i32[1];
  v226 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)a3.i8, *(int8x8_t *)v321.f32, 4uLL), v4);
  *(float *)&v227 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v226, 1), *(float *)(a1 + 16), v226.f32[0]);
  LODWORD(v225) = *(_DWORD *)(a1 + 24);
  v228.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v229) = *(_DWORD *)(a1 + 36);
  *(float *)v230.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v226, 1), *(float *)v228.i32, v226.f32[0]);
  v231 = (float64x2_t)v312;
  v313 = vaddq_f32(v312, v224);
  v224.f32[0] = *(float *)&v225 + *(float *)&v227;
  *(float *)v231.f64 = *(float *)&v229 + *(float *)v230.i32;
  v224.f32[1] = *(float *)&v229 + *(float *)v230.i32;
  *(double *)v233.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v224.i64, v231, v225, v227, v228, v230, v229, v232);
  v234 = vsub_f32(v4, *(float32x2_t *)a3.i8);
  *(float *)&v235 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v234, 1), *(float *)(a1 + 16), v234.f32[0]);
  LODWORD(v236) = *(_DWORD *)(a1 + 24);
  v237.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v238) = *(_DWORD *)(a1 + 36);
  *(float *)v239.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v234, 1), *(float *)v237.i32, v234.f32[0]);
  v240 = (float64x2_t)v313;
  v314 = vaddq_f32(v313, v233);
  v233.f32[0] = *(float *)&v236 + *(float *)&v235;
  *(float *)v240.f64 = *(float *)&v238 + *(float *)v239.i32;
  v233.f32[1] = *(float *)&v238 + *(float *)v239.i32;
  *(double *)v242.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v233.i64, v240, v236, v235, v237, v239, v238, v241);
  HIDWORD(v243) = a3.i32[1];
  v244 = vadd_f32((float32x2_t)vext_s8(*(int8x8_t *)v321.f32, *(int8x8_t *)a3.i8, 4uLL), v4);
  *(float *)&v245 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v244, 1), *(float *)(a1 + 16), v244.f32[0]);
  LODWORD(v243) = *(_DWORD *)(a1 + 24);
  v246.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v247) = *(_DWORD *)(a1 + 36);
  *(float *)v248.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v244, 1), *(float *)v246.i32, v244.f32[0]);
  v249 = (float64x2_t)v314;
  v315 = vaddq_f32(v314, v242);
  v242.f32[0] = *(float *)&v243 + *(float *)&v245;
  *(float *)v249.f64 = *(float *)&v247 + *(float *)v248.i32;
  v242.f32[1] = *(float *)&v247 + *(float *)v248.i32;
  *(double *)v251.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v242.i64, v249, v243, v245, v246, v248, v247, v250);
  v252 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)a3.i8), v4);
  *(float *)&v253 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v252, 1), *(float *)(a1 + 16), v252.f32[0]);
  LODWORD(v254) = *(_DWORD *)(a1 + 24);
  v255.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v256) = *(_DWORD *)(a1 + 36);
  *(float *)v257.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v252, 1), *(float *)v255.i32, v252.f32[0]);
  v258 = (float64x2_t)v315;
  v316 = vaddq_f32(v315, v251);
  v251.f32[0] = *(float *)&v254 + *(float *)&v253;
  *(float *)v258.f64 = *(float *)&v256 + *(float *)v257.i32;
  v251.f32[1] = *(float *)&v256 + *(float *)v257.i32;
  *(double *)v260.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v251.i64, v258, v254, v253, v255, v257, v256, v259);
  HIDWORD(v261) = a3.i32[1];
  v262 = vadd_f32((float32x2_t)__PAIR64__(a3.u32[1], v321.u32[0]), v4);
  *(float *)&v263 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v262, 1), *(float *)(a1 + 16), v262.f32[0]);
  LODWORD(v261) = *(_DWORD *)(a1 + 24);
  v264.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v265) = *(_DWORD *)(a1 + 36);
  *(float *)v266.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v262, 1), *(float *)v264.i32, v262.f32[0]);
  v267 = (float64x2_t)v316;
  v317 = vaddq_f32(v316, v260);
  v260.f32[0] = *(float *)&v261 + *(float *)&v263;
  *(float *)v267.f64 = *(float *)&v265 + *(float *)v266.i32;
  v260.f32[1] = *(float *)&v265 + *(float *)v266.i32;
  *(double *)v269.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v260.i64, v267, v261, v263, v264, v266, v265, v268);
  v270 = vadd_f32((float32x2_t)vrev64_s32(*(int32x2_t *)v321.f32), v4);
  *(float *)&v271 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v270, 1), *(float *)(a1 + 16), v270.f32[0]);
  LODWORD(v272) = *(_DWORD *)(a1 + 24);
  v273.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v274) = *(_DWORD *)(a1 + 36);
  *(float *)v275.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v270, 1), *(float *)v273.i32, v270.f32[0]);
  v276 = (float64x2_t)v317;
  v318 = vaddq_f32(v317, v269);
  v269.f32[0] = *(float *)&v272 + *(float *)&v271;
  *(float *)v276.f64 = *(float *)&v274 + *(float *)v275.i32;
  v269.f32[1] = *(float *)&v274 + *(float *)v275.i32;
  *(double *)v278.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v269.i64, v276, v272, v271, v273, v275, v274, v277);
  HIDWORD(v279) = v321.i32[1];
  v280 = vadd_f32((float32x2_t)__PAIR64__(v321.u32[1], a3.u32[0]), v4);
  *(float *)&v281 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v280, 1), *(float *)(a1 + 16), v280.f32[0]);
  LODWORD(v279) = *(_DWORD *)(a1 + 24);
  v282.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v283) = *(_DWORD *)(a1 + 36);
  *(float *)v284.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v280, 1), *(float *)v282.i32, v280.f32[0]);
  v285 = (float64x2_t)v318;
  v323 = vaddq_f32(v318, v278);
  v278.f32[0] = *(float *)&v279 + *(float *)&v281;
  *(float *)v285.f64 = *(float *)&v283 + *(float *)v284.i32;
  v278.f32[1] = *(float *)&v283 + *(float *)v284.i32;
  *(double *)v287.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v278.i64, v285, v279, v281, v282, v284, v283, v286);
  v288.i64[0] = 0x3D0000003D000000;
  v288.i64[1] = 0x3D0000003D000000;
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v323, v287), v288).u64[0];
  return result;
}

double cikernel::_disintegrateWithMask(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float a6, float32x4_t a7)
{
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float32x4_t v12;
  float v13;
  float32x4_t v14;
  float v15;
  float v16;
  double result;

  v7 = 1.0 / (fmaxf(fabsf(vsubq_f32(a4, a3).f32[0]), fabsf(vsubq_f32(a5, a3).f32[0])) + 0.001);
  v8 = a7.f32[3] + (float)(vmuls_lane_f32(a7.f32[3] - a6, *(float32x2_t *)a7.f32, 1) * v7);
  if (v8 <= 1.0)
    v9 = v8;
  else
    v9 = 1.0;
  if (v8 < 0.0)
    v9 = 0.0;
  v10 = a7.f32[2] * (v9 + -1.0) + 1.0;
  v11 = vmuls_lane_f32(a7.f32[0], a7, 3);
  v12 = vmulq_n_f32(a1, v11 + 1.0);
  v12.i32[3] = a1.i32[3];
  v13 = v11 + 1.0 - a7.f32[0];
  v14 = vmulq_n_f32(vmulq_n_f32(a2, v13), v10);
  v14.i32[3] = a2.i32[3];
  v15 = a7.f32[3] + (float)((float)(a7.f32[3] - a3.f32[0]) * v7);
  if (v15 <= 1.0)
    v16 = a7.f32[3] + (float)((float)(a7.f32[3] - a3.f32[0]) * v7);
  else
    v16 = 1.0;
  if (v15 < 0.0)
    v16 = 0.0;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v12, 1.0 - v16), v14, v16).u64[0];
  return result;
}

void CI::f4_s_s_s_s_s_s_f4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, __n128, __n128, __n128);
  int v11;
  uint64_t v12;
  int v13;
  const vec2 *v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  __n128 *v25;
  __n128 *v26;
  __n128 *v27;
  __n128 *v28;
  __n128 *v29;
  __n128 *v30;
  __n128 *v31;
  __n128 *v32;
  __int128 v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  double (*v39)(__n128, __n128, __n128, __n128, __n128, __n128, __n128);
  const vec2 *v40;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(const vec2 **)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  v19 = *(_DWORD *)(v9 + 112);
  v20 = *(_QWORD *)(v9 + 104);
  v21 = *(_DWORD *)(v9 + 136);
  v22 = *(_QWORD *)(v9 + 128);
  v23 = *(_DWORD *)(v9 + 160);
  v24 = *(_QWORD *)(v9 + 152);
  if (*(_BYTE *)(a1 + 64))
  {
    v39 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128))(a1 + 24);
    v40 = *(const vec2 **)(v9 + 32);
    v37 = *(_QWORD *)(v9 + 8);
    v38 = *(_QWORD *)(v9 + 56);
    v36 = *(_DWORD *)(v9 + 112);
    v35 = *(_QWORD *)(v9 + 80);
    v34 = *(_DWORD *)(v9 + 160);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 176)), v14);
    v23 = v34;
    v18 = v35;
    v19 = v36;
    v12 = v37;
    v16 = v38;
    v10 = v39;
    v14 = v40;
  }
  v25 = (__n128 *)(a3 + 16 * v24);
  if (v23 != 5)
    v25 = (__n128 *)(a2 + (v24 << 6));
  v26 = (__n128 *)(a3 + 16 * v22);
  if (v21 != 5)
    v26 = (__n128 *)(a2 + (v22 << 6));
  v27 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5)
    v27 = (__n128 *)(a2 + (v20 << 6));
  v28 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v28 = (__n128 *)(a2 + (v18 << 6));
  v29 = (__n128 *)(a3 + 16 * v16);
  v30 = (__n128 *)(a2 + (v16 << 6));
  if (v15 != 5)
    v29 = v30;
  v31 = (__n128 *)(a3 + 16 * (_QWORD)v14);
  if (v13 != 5)
    v31 = (__n128 *)(a2 + ((_QWORD)v14 << 6));
  v32 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v32 = (__n128 *)(a2 + (v12 << 6));
  *(double *)&v33 = v10(*v32, *v31, *v29, *v28, *v27, *v26, *v25);
  *(_OWORD *)(a3 + 16 * a7) = v33;
}

double cikernel::_disintegrateWithMaskG(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t a4, float32x4_t a5)
{
  float v9;
  float v10;
  float32x2_t *DC;
  double v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  double v16;
  float64x2_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  CI *v21;
  float32x2_t *v22;
  double v23;
  double v24;
  uint8x8_t v25;
  int8x16_t v26;
  double v27;
  float64x2_t v28;
  double v29;
  int8x16_t v30;
  float32x4_t v31;
  CI *v32;
  float32x2_t *v33;
  int8x16_t v34;
  double v35;
  double v36;
  double v37;
  float64x2_t v38;
  uint8x8_t v39;
  double v40;
  int8x16_t v41;
  float32x4_t v42;
  float64x2_t v43;
  double v44;
  double v45;
  uint8x8_t v46;
  int8x16_t v47;
  double v48;
  int8x16_t v49;
  float32x4_t v50;
  float64x2_t v51;
  double v52;
  double v53;
  uint8x8_t v54;
  int8x16_t v55;
  double v56;
  int8x16_t v57;
  float32x4_t v58;
  double v59;
  double v60;
  uint8x8_t v61;
  int8x16_t v62;
  float64x2_t v63;
  double v64;
  int8x16_t v65;
  double v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float32x4_t v72;
  float v73;
  float32x4_t v74;
  float v75;
  float v76;
  float v77;
  double result;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float64x2_t v85;

  v9 = a5.f32[2];
  v10 = a5.f32[3];
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v13, COERCE_FLOAT(*DC));
  *(float *)&v16 = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v17.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  *((float *)&v16 + 1) = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v16, v17, v12, v13, v15, v14, v18, v19);
  v83 = v20;
  v22 = (float32x2_t *)CI::getDC(v21);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *v22, 1), *(float *)(a2 + 16), COERCE_FLOAT(*v22));
  LODWORD(v24) = *(_DWORD *)(a2 + 28);
  v25.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *v22, 1), *(float *)&v24, COERCE_FLOAT(*v22));
  *(float *)&v27 = *(float *)(a2 + 24) + *(float *)&v23;
  *(float *)v28.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  *((float *)&v27 + 1) = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v27, v28, v23, v24, v26, v25, v29, v30);
  v82 = v31;
  v33 = (float32x2_t *)CI::getDC(v32);
  *(float32x2_t *)v34.i8 = *v33;
  v85 = (float64x2_t)v34;
  LODWORD(v35) = *(_DWORD *)(a3 + 28);
  *(float *)&v36 = *(float *)(a3 + 24)
                 + vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 20), *v33, 1), *(float *)(a3 + 16), COERCE_FLOAT(*v33));
  LODWORD(v37) = *(_DWORD *)(a3 + 36);
  *(float *)v38.f64 = *(float *)&v37
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 32), *v33, 1), *(float *)&v35, COERCE_FLOAT(*v33));
  HIDWORD(v36) = LODWORD(v38.f64[0]);
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a3 + 8), v36, v38, v35, v37, v34, v39, v40, v41);
  v81 = v42;
  v43 = v85;
  *(float32x2_t *)v42.f32 = vadd_f32(*(float32x2_t *)&v85.f64[0], (float32x2_t)1065353216);
  *(float *)&v44 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 20), *(float32x2_t *)v42.f32, 1), *(float *)(a3 + 16), v42.f32[0]);
  LODWORD(v45) = *(_DWORD *)(a3 + 28);
  v46.i32[0] = *(_DWORD *)(a3 + 36);
  *(float *)v47.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 32), *(float32x2_t *)v42.f32, 1), *(float *)&v45, v42.f32[0]);
  v42.f32[0] = *(float *)(a3 + 24) + *(float *)&v44;
  *(float *)v43.f64 = *(float *)v46.i32 + *(float *)v47.i32;
  v42.f32[1] = *(float *)v46.i32 + *(float *)v47.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a3 + 8), *(double *)v42.i64, v43, v44, v45, v47, v46, v48, v49);
  v80 = v50;
  v51 = v85;
  *(float32x2_t *)v50.f32 = vadd_f32(*(float32x2_t *)&v85.f64[0], (float32x2_t)0x3F80000000000000);
  *(float *)&v52 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 20), *(float32x2_t *)v50.f32, 1), *(float *)(a3 + 16), v50.f32[0]);
  LODWORD(v53) = *(_DWORD *)(a3 + 28);
  v54.i32[0] = *(_DWORD *)(a3 + 36);
  *(float *)v55.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 32), *(float32x2_t *)v50.f32, 1), *(float *)&v53, v50.f32[0]);
  v50.f32[0] = *(float *)(a3 + 24) + *(float *)&v52;
  *(float *)v51.f64 = *(float *)v54.i32 + *(float *)v55.i32;
  v50.f32[1] = *(float *)v54.i32 + *(float *)v55.i32;
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a3 + 8), *(double *)v50.i64, v51, v52, v53, v55, v54, v56, v57);
  v79 = v58;
  *(float32x2_t *)v58.f32 = vsub_f32(*(float32x2_t *)&v85.f64[0], a4);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 20), *(float32x2_t *)v58.f32, 1), *(float *)(a3 + 16), v58.f32[0]);
  LODWORD(v60) = *(_DWORD *)(a3 + 28);
  v61.i32[0] = *(_DWORD *)(a3 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 32), *(float32x2_t *)v58.f32, 1), *(float *)&v60, v58.f32[0]);
  v58.f32[0] = *(float *)(a3 + 24) + *(float *)&v59;
  *(float *)v63.f64 = *(float *)v61.i32 + *(float *)v62.i32;
  v58.f32[1] = *(float *)v61.i32 + *(float *)v62.i32;
  v66 = CI::BitmapSampler::read(*(uint64x2_t **)(a3 + 8), *(double *)v58.i64, v63, v59, v60, v62, v61, v64, v65);
  v67 = 1.0 / (fmaxf(fabsf(vsubq_f32(v80, v81).f32[0]), fabsf(vsubq_f32(v79, v81).f32[0])) + 0.001);
  v68 = v10 + (float)(vmuls_lane_f32(v10 - *(float *)&v66, *(float32x2_t *)a5.f32, 1) * v67);
  if (v68 <= 1.0)
    v69 = v68;
  else
    v69 = 1.0;
  if (v68 < 0.0)
    v69 = 0.0;
  v70 = v9 * (v69 + -1.0) + 1.0;
  v71 = vmuls_lane_f32(a5.f32[0], a5, 3);
  v72 = vmulq_n_f32(v83, v71 + 1.0);
  v72.i32[3] = v83.i32[3];
  v73 = v71 + 1.0 - a5.f32[0];
  v74 = vmulq_n_f32(vmulq_n_f32(v82, v73), v70);
  v74.i32[3] = v82.i32[3];
  v75 = v10 + (float)((float)(v10 - v81.f32[0]) * v67);
  if (v75 <= 1.0)
    v76 = v75;
  else
    v76 = 1.0;
  if (v75 >= 0.0)
    v77 = v76;
  else
    v77 = 0.0;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v72, 1.0 - v77), v74, v77).u64[0];
  return result;
}

void CI::f4_sr_sr_sr_f2_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, uint64_t, uint64_t, double, __n128);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __n128 *v19;
  double *v20;
  __int128 v21;
  int v22;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t, uint64_t, double, __n128))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_QWORD *)(v10 + 32);
  v14 = *(_QWORD *)(v10 + 56);
  v15 = *(_DWORD *)(v10 + 88);
  v16 = *(_QWORD *)(v10 + 80);
  v17 = *(_DWORD *)(v10 + 112);
  v18 = *(_QWORD *)(v10 + 104);
  if (*(_BYTE *)(a1 + 64))
  {
    v22 = *(_DWORD *)(v10 + 88);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 128)), a2);
    v15 = v22;
  }
  v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v18);
  v20 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v20 = (double *)((char *)a2 + 64 * v16);
  *(double *)&v21 = v11(a4 + 80 * v12, a4 + 80 * v13, a4 + 80 * v14, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

void saveImage(CIImage *a1, uint64_t a2, int a3)
{
  CGColorSpace *v6;
  CGColorSpace *v7;
  int v8;
  CIColorKernel *v9;
  CIColorKernel *v10;
  double v11;
  double v12;
  double v13;
  double v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  const __CFDictionary *v22;
  void *v23;
  uint64_t v24;
  CGImage *v25;
  CGImageDestination *v26;
  CGImageDestination *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD v38[2];
  CGRect v39;

  v38[1] = *MEMORY[0x1E0C80C00];
  if (saveImageWithKeywords(CIImage *,NSString *,BOOL,NSArray *)::onceToken != -1)
    dispatch_once(&saveImageWithKeywords(CIImage *,NSString *,BOOL,NSArray *)::onceToken, &__block_literal_global_176);
  if (saveImageWithKeywords(CIImage *,NSString *,BOOL,NSArray *)::saveImages)
  {
    if (a1)
    {
      -[CIImage extent](a1, "extent");
      if (CGRectEqualToRect(v39, *MEMORY[0x1E0C9D5E0]))
      {
        NSLog(CFSTR("infinite rect can't save image"));
      }
      else
      {
        v6 = -[CIImage colorSpace](a1, "colorSpace");
        if (!v6
          || (v7 = v6, CGColorSpaceGetModel(v6) == kCGColorSpaceModelRGB) && (a3 & 1) != 0
          || (v8 = 0, CGColorSpaceGetModel(v7) == kCGColorSpaceModelMonochrome) && (a3 & 1) == 0)
        {
          v7 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA00]);
          v9 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_gray);
          if (a3)
          {
            v10 = v9;
            -[CIImage extent](a1, "extent");
            v38[0] = a1;
            v8 = 1;
            a1 = -[CIColorKernel applyWithExtent:arguments:](v10, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v38, 1), v11, v12, v13, v14);
          }
          else
          {
            v8 = 1;
          }
        }
        v15 = (void *)MEMORY[0x1E0C9AA60];
        v16 = objc_msgSend(MEMORY[0x1E0C9AA60], "count");
        v17 = *MEMORY[0x1E0CBC780];
        v35 = &unk_1E2F19500;
        if (v16)
        {
          v18 = *MEMORY[0x1E0CBCED8];
          v32 = v17;
          v33 = v18;
          v30 = *MEMORY[0x1E0CBCF10];
          v31 = v15;
          v36 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v31, &v30, 1);
          v34 = *MEMORY[0x1E0CBD090];
          v28 = *MEMORY[0x1E0CBD078];
          v29 = &unk_1E2F1B6C8;
          v37 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v29, &v28, 1);
          v19 = (void *)MEMORY[0x1E0C99D80];
          v20 = 3;
        }
        else
        {
          v21 = *MEMORY[0x1E0CBD090];
          v32 = v17;
          v33 = v21;
          v30 = *MEMORY[0x1E0CBD078];
          v31 = &unk_1E2F1B6C8;
          v36 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v31, &v30, 1);
          v19 = (void *)MEMORY[0x1E0C99D80];
          v20 = 2;
        }
        v22 = (const __CFDictionary *)objc_msgSend(v19, "dictionaryWithObjects:forKeys:count:", &v35, &v32, v20);
        v23 = (void *)saveImageWithKeywords(CIImage *,NSString *,BOOL,NSArray *)::context;
        -[CIImage extent](a1, "extent");
        v24 = objc_msgSend(v23, "createCGImage:fromRect:format:colorSpace:", a1, 2056, v7);
        if (v24)
        {
          v25 = (CGImage *)v24;
          v26 = CGImageDestinationCreateWithURL((CFURLRef)objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:", a2), CFSTR("public.tiff"), 0, 0);
          if (v26)
          {
            v27 = v26;
            CGImageDestinationAddImage(v26, v25, v22);
            CGImageDestinationFinalize(v27);
            CFRelease(v27);
          }
          CGImageRelease(v25);
        }
        if (v8)
          CGColorSpaceRelease(v7);
      }
    }
    else
    {
      NSLog(CFSTR("Can't save nil image"));
    }
  }
}

void sub_192271268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_192272028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

double cikernel::_gray(float a1)
{
  double v1;

  *(float *)&v1 = a1;
  *((float *)&v1 + 1) = a1;
  return v1;
}

void cikernel::_CIInitialConversionRGB(uint64_t a1, float32x2_t a2)
{
  float64x2_t v3;
  float32x2_t v4;
  double v5;
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  double v9;
  int8x16_t v10;
  float32x4_t v11;
  float64x2_t v12;
  double v13;
  double v14;
  uint8x8_t v15;
  int8x16_t v16;
  double v17;
  int8x16_t v18;
  float32x4_t v19;
  float64x2_t v20;
  double v21;
  double v22;
  uint8x8_t v23;
  int8x16_t v24;
  double v25;
  int8x16_t v26;
  float64x2_t v27;
  float32x2_t v28;
  double v29;
  double v30;
  uint8x8_t v31;
  int8x16_t v32;
  double v33;
  int8x16_t v34;
  double v35;
  uint8x8_t v36;
  int8x16_t v37;
  double v38;
  float64x2_t v39;
  int8x16_t v40;
  double v41;
  float32x4_t v42;
  float32x4_t v43;
  float64x2_t v44;

  *(float32x2_t *)&v3.f64[0] = vmul_f32(a2, *(float32x2_t *)CI::getDC((CI *)a1));
  v44 = v3;
  v4 = vadd_f32(*(float32x2_t *)&v3.f64[0], (float32x2_t)3221225472);
  *(float *)&v5 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v4, 1), *(float *)(a1 + 16), v4.f32[0]);
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  v7.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *(float *)(a1 + 24) + *(float *)&v5;
  *(float *)v3.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v4, v3, v5, v6, v8, v7, v9, v10);
  v43 = v11;
  v12 = v44;
  *(float32x2_t *)v11.f32 = vadd_f32(*(float32x2_t *)&v44.f64[0], (float32x2_t)0x40000000);
  *(float *)&v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v11.f32, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v11.f32, 1), *(float *)&v14, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v13;
  *(float *)v12.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v11.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v11.i64, v12, v13, v14, v16, v15, v17, v18);
  v42 = v19;
  v20 = v44;
  *(float32x2_t *)v19.f32 = vadd_f32(*(float32x2_t *)&v44.f64[0], (float32x2_t)0x4000000000000000);
  *(float *)&v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v19.f32, 1), *(float *)(a1 + 16), v19.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v19.f32, 1), *(float *)&v22, v19.f32[0]);
  v19.f32[0] = *(float *)(a1 + 24) + *(float *)&v21;
  *(float *)v20.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v19.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  v41 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v19.i64, v20, v21, v22, v24, v23, v25, v26);
  v27 = v44;
  v28 = vadd_f32(*(float32x2_t *)&v44.f64[0], (float32x2_t)0xC000000000000000);
  *(float *)&v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v28, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 28);
  v31.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v28, 1), *(float *)&v30, v28.f32[0]);
  v28.f32[0] = *(float *)(a1 + 24) + *(float *)&v29;
  *(float *)v27.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v28.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v28, v27, v29, v30, v32, v31, v33, v34);
  *(float *)&v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v44.f64[0], 1), *(float *)(a1 + 16), *(float *)v44.f64);
  v36.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v44.f64[0], 1), *(float *)(a1 + 28), *(float *)v44.f64);
  *(float *)&v38 = *(float *)(a1 + 24) + *(float *)&v35;
  *(float *)v39.f64 = *(float *)v36.i32 + *(float *)v37.i32;
  *((float *)&v38 + 1) = *(float *)v36.i32 + *(float *)v37.i32;
  CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v38, v39, v35, *(double *)vabdq_f32(v42, v43).i64, v37, v36, v41, v40);
}

double cikernel::_CIPyramidGenerateLevel(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float32x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  float64x2_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  double v22;
  double v23;
  uint8x8_t v24;
  int8x16_t v25;
  float64x2_t v26;
  double v27;
  int8x16_t v28;
  float32x4_t v29;
  double v30;
  double v31;
  uint8x8_t v32;
  int8x16_t v33;
  float64x2_t v34;
  double v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  double result;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;

  DC = (float32x2_t *)CI::getDC(this);
  v4 = vadd_f32(*DC, *DC);
  v5 = vadd_f32(v4, (float32x2_t)0xBF000000BF000000);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v10, v6, v7, v9, v8, v11, v12);
  v43 = v13;
  *(float32x2_t *)v13.f32 = vadd_f32(v4, (float32x2_t)0x3F000000BF000000);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v15) = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  v42 = v21;
  *(float32x2_t *)v21.f32 = vadd_f32(v4, (float32x2_t)0xBF0000003F000000);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v21.f32, 1), *((float *)this + 4), v21.f32[0]);
  LODWORD(v23) = *((_DWORD *)this + 7);
  v24.i32[0] = *((_DWORD *)this + 9);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v21.f32, 1), *(float *)&v23, v21.f32[0]);
  v21.f32[0] = *((float *)this + 6) + *(float *)&v22;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v21.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v21.i64, v26, v22, v23, v25, v24, v27, v28);
  v41 = v29;
  *(float32x2_t *)v29.f32 = vadd_f32(v4, (float32x2_t)0x3F0000003F000000);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v29.f32, 1), *((float *)this + 4), v29.f32[0]);
  LODWORD(v31) = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v29.f32, 1), *(float *)&v31, v29.f32[0]);
  v29.f32[0] = *((float *)this + 6) + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v29.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v29.i64, v34, v30, v31, v33, v32, v35, v36);
  v38 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v42, v43)), 3)), (int8x16_t)v42, (int8x16_t)v43);
  v39 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v41, v38)), 3)), (int8x16_t)v41, (int8x16_t)v38);
  *(_QWORD *)&result = vbslq_s8((int8x16_t)vmovl_s16(vdup_lane_s16(vmovn_s32(vcgtq_f32(v37, v39)), 3)), (int8x16_t)v37, (int8x16_t)v39).u64[0];
  return result;
}

double cikernel::_CISmoothDisparity(uint64_t a1, float32x4_t a2)
{
  float v3;
  float64x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  double v13;
  double v14;
  float64x2_t v15;
  uint8x8_t v16;
  double v17;
  int8x16_t v18;
  double v19;
  float64x2_t v20;
  float32x2_t v21;
  double v22;
  double v23;
  uint8x8_t v24;
  int8x16_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  float64x2_t v29;
  double v30;
  double v31;
  uint8x8_t v32;
  int8x16_t v33;
  double v34;
  int8x16_t v35;
  float32x4_t v36;
  float64x2_t v37;
  double v38;
  double v39;
  uint8x8_t v40;
  int8x16_t v41;
  double v42;
  int8x16_t v43;
  float64x2_t v49;
  double v50;
  double v51;
  uint8x8_t v52;
  int8x16_t v53;
  double v54;
  int8x16_t v55;
  float64x2_t v57;
  double v58;
  double v59;
  uint8x8_t v60;
  int8x16_t v61;
  double v62;
  int8x16_t v63;
  float32x4_t v64;
  float64x2_t v65;
  double v66;
  double v67;
  uint8x8_t v68;
  int8x16_t v69;
  double v70;
  int8x16_t v71;
  float32x4_t v72;
  float64x2_t v73;
  double v74;
  double v75;
  uint8x8_t v76;
  int8x16_t v77;
  double v78;
  int8x16_t v79;
  float32x4_t v80;
  double result;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float v88;
  float32x4_t v89;
  int8x16_t v91;

  v3 = a2.f32[1];
  v4.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  v91 = (int8x16_t)v4;
  v5 = vadd_f32(*(float32x2_t *)&v4.f64[0], (float32x2_t)3212836864);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v4, v6, v7, v9, v8, v10, v11);
  v89 = v12;
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v12.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v91.i8, 1), *(float *)(a1 + 16), *(float *)v91.i32);
  LODWORD(v14) = *(_DWORD *)(a1 + 36);
  *(float *)v15.f64 = *(float *)&v14
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v91.i8, 1), *(float *)&v13, *(float *)v91.i32);
  v12.i32[1] = LODWORD(v15.f64[0]);
  v19 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v15, v13, v14, v91, v16, v17, v18);
  v88 = *(float *)&v19;
  v20 = (float64x2_t)v91;
  v21 = vadd_f32(*(float32x2_t *)v91.i8, (float32x2_t)0x3F80000000000000);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v21, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v21, 1), *(float *)&v23, v21.f32[0]);
  v21.f32[0] = *(float *)(a1 + 24) + *(float *)&v22;
  *(float *)v20.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v21.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v21, v20, v22, v23, v25, v24, v26, v27);
  v87 = v28;
  v29 = (float64x2_t)v91;
  *(float32x2_t *)v28.f32 = vadd_f32(*(float32x2_t *)v91.i8, (float32x2_t)0x3F800000BF800000);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v28.f32, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v28.f32, 1), *(float *)&v31, v28.f32[0]);
  v28.f32[0] = *(float *)(a1 + 24) + *(float *)&v30;
  *(float *)v29.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v28.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v29, v30, v31, v33, v32, v34, v35);
  v86 = v36;
  v37 = (float64x2_t)v91;
  *(float32x2_t *)v36.f32 = vadd_f32(*(float32x2_t *)v91.i8, (float32x2_t)1065353216);
  *(float *)&v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v36.f32, 1), *(float *)(a1 + 16), v36.f32[0]);
  LODWORD(v39) = *(_DWORD *)(a1 + 28);
  v40.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v36.f32, 1), *(float *)&v39, v36.f32[0]);
  v36.f32[0] = *(float *)(a1 + 24) + *(float *)&v38;
  *(float *)v37.f64 = *(float *)v40.i32 + *(float *)v41.i32;
  v36.f32[1] = *(float *)v40.i32 + *(float *)v41.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v36.i64, v37, v38, v39, v41, v40, v42, v43);
  v85 = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  v49 = (float64x2_t)v91;
  *(float32x2_t *)_Q0.f32 = vadd_f32(*(float32x2_t *)v91.i8, *(float32x2_t *)_Q0.f32);
  *(float *)&v50 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q0.f32, 1), *(float *)(a1 + 16), _Q0.f32[0]);
  LODWORD(v51) = *(_DWORD *)(a1 + 28);
  v52.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v53.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q0.f32, 1), *(float *)&v51, _Q0.f32[0]);
  _Q0.f32[0] = *(float *)(a1 + 24) + *(float *)&v50;
  *(float *)v49.f64 = *(float *)v52.i32 + *(float *)v53.i32;
  _Q0.f32[1] = *(float *)v52.i32 + *(float *)v53.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)_Q0.i64, v49, v50, v51, v53, v52, v54, v55);
  v84 = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  v57 = (float64x2_t)v91;
  *(float32x2_t *)_Q0.f32 = vadd_f32(*(float32x2_t *)v91.i8, *(float32x2_t *)_Q0.f32);
  *(float *)&v58 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q0.f32, 1), *(float *)(a1 + 16), _Q0.f32[0]);
  LODWORD(v59) = *(_DWORD *)(a1 + 28);
  v60.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v61.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q0.f32, 1), *(float *)&v59, _Q0.f32[0]);
  _Q0.f32[0] = *(float *)(a1 + 24) + *(float *)&v58;
  *(float *)v57.f64 = *(float *)v60.i32 + *(float *)v61.i32;
  _Q0.f32[1] = *(float *)v60.i32 + *(float *)v61.i32;
  *(double *)v64.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)_Q0.i64, v57, v58, v59, v61, v60, v62, v63);
  v83 = v64;
  v65 = (float64x2_t)v91;
  *(float32x2_t *)v64.f32 = vadd_f32(*(float32x2_t *)v91.i8, (float32x2_t)0xBF80000000000000);
  *(float *)&v66 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v64.f32, 1), *(float *)(a1 + 16), v64.f32[0]);
  LODWORD(v67) = *(_DWORD *)(a1 + 28);
  v68.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v69.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v64.f32, 1), *(float *)&v67, v64.f32[0]);
  v64.f32[0] = *(float *)(a1 + 24) + *(float *)&v66;
  *(float *)v65.f64 = *(float *)v68.i32 + *(float *)v69.i32;
  v64.f32[1] = *(float *)v68.i32 + *(float *)v69.i32;
  *(double *)v72.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v64.i64, v65, v66, v67, v69, v68, v70, v71);
  v82 = v72;
  v73 = (float64x2_t)v91;
  *(float32x2_t *)v72.f32 = vadd_f32(*(float32x2_t *)v91.i8, (float32x2_t)0xBFC000003FC00000);
  *(float *)&v74 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v72.f32, 1), *(float *)(a1 + 16), v72.f32[0]);
  LODWORD(v75) = *(_DWORD *)(a1 + 28);
  v76.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v77.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v72.f32, 1), *(float *)&v75, v72.f32[0]);
  v72.f32[0] = *(float *)(a1 + 24) + *(float *)&v74;
  *(float *)v73.f64 = *(float *)v76.i32 + *(float *)v77.i32;
  v72.f32[1] = *(float *)v76.i32 + *(float *)v77.i32;
  *(double *)v80.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v72.i64, v73, v74, v75, v77, v76, v78, v79);
  v80.i64[0] = vaddq_f32(vaddq_f32(vaddq_f32(v86, v84), v83), v80).u64[0];
  v80.f32[0] = vmuls_lane_f32(vmlas_n_f32(vmlas_n_f32(v88, a2.f32[0], vaddq_f32(vaddq_f32(vaddq_f32(v89, v87), v85), v82).f32[0]), v3, v80.f32[0]), a2, 2);
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)v80.f32, 0).u64[0];
  return result;
}

void CI::f4_sr_f3(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v11;
  double (*v12)(uint64_t, __n128);
  uint64_t v13;
  uint64_t v14;
  __int128 v15;

  v11 = *(_QWORD **)(a1 + 48);
  v12 = *(double (**)(uint64_t, __n128))(a1 + 24);
  v13 = v11[1];
  v14 = v11[4];
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * v11[7]), a2);
  *(double *)&v15 = v12(a4 + 80 * v13, *((__n128 *)a2 + 4 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v15;
}

__n64 cikernel::_CIBoxBlur5Min(cikernel *this, SamplerObj *a2)
{
  CI *DC;
  float32x2_t v4;
  float32x2_t *v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  float64x2_t v11;
  double v12;
  int8x16_t v13;
  __int128 v14;
  double v15;
  double v16;
  uint8x8_t v17;
  int8x16_t v18;
  float64x2_t v19;
  double v20;
  int8x16_t v21;
  double v22;
  float64x2_t v23;
  double v24;
  double v25;
  int8x16_t v26;
  double v27;
  uint8x8_t v28;
  float v29;
  int8x16_t v30;
  double v31;
  float32x2_t v37;
  double v38;
  double v39;
  int8x16_t v40;
  double v41;
  uint8x8_t v42;
  float64x2_t v43;
  float v44;
  int8x16_t v45;
  double v46;
  float32x2_t v47;
  double v48;
  double v49;
  int8x16_t v50;
  double v51;
  uint8x8_t v52;
  float64x2_t v53;
  float v54;
  int8x16_t v55;
  double v56;
  float64x2_t v57;
  double v58;
  double v59;
  int8x16_t v60;
  double v61;
  uint8x8_t v62;
  float v63;
  int8x16_t v64;
  double v65;
  float32x2_t v67;
  double v68;
  double v69;
  int8x16_t v70;
  double v71;
  uint8x8_t v72;
  float64x2_t v73;
  float v74;
  int8x16_t v75;
  double v76;
  float32x2_t v77;
  double v78;
  double v79;
  int8x16_t v80;
  double v81;
  uint8x8_t v82;
  float64x2_t v83;
  float v84;
  int8x16_t v85;
  double v86;
  float64x2_t v87;
  double v88;
  double v89;
  int8x16_t v90;
  double v91;
  uint8x8_t v92;
  int8x16_t v93;
  double v94;
  __n64 result;
  __int128 v96;

  DC = (CI *)CI::getDC(this);
  v4 = *(float32x2_t *)DC;
  v5 = (float32x2_t *)CI::getDC(DC);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *v5, 1), *((float *)this + 4), COERCE_FLOAT(*v5));
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *v5, 1), *(float *)&v7, COERCE_FLOAT(*v5));
  *(float *)&v10 = *((float *)this + 6) + *(float *)&v6;
  *(float *)v11.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  *((float *)&v10 + 1) = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)&v14 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v10, v11, v6, v7, v9, v8, v12, v13);
  v96 = v14;
  *(float32x2_t *)&v14 = vadd_f32(v4, (float32x2_t)0x3FC00000BFC00000);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v14, 1), *((float *)this + 4), *(float *)&v14);
  LODWORD(v16) = *((_DWORD *)this + 7);
  v17.i32[0] = *((_DWORD *)this + 9);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v14, 1), *(float *)&v16, *(float *)&v14);
  *(float *)&v14 = *((float *)this + 6) + *(float *)&v15;
  *(float *)v19.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  *((float *)&v14 + 1) = *(float *)v17.i32 + *(float *)v18.i32;
  v22 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v14, v19, v15, v16, v18, v17, v20, v21);
  *(float32x2_t *)&v23.f64[0] = vadd_f32(v4, (float32x2_t)0x3FC0000000000000);
  *(float *)&v24 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v23.f64[0], 1), *((float *)this + 4), *(float *)v23.f64);
  LODWORD(v25) = *((_DWORD *)this + 6);
  v26.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v27) = *((_DWORD *)this + 9);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v23.f64[0], 1), *(float *)v26.i32, *(float *)v23.f64);
  HIDWORD(v23.f64[0]) = 0;
  v29 = *(float *)&v22 * 0.16 + 0.0;
  *(float *)&v22 = *(float *)&v25 + *(float *)&v24;
  *(float *)v23.f64 = *(float *)&v27 + *(float *)v28.i32;
  *((float *)&v22 + 1) = *(float *)&v27 + *(float *)v28.i32;
  v31 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v22, v23, v25, v24, v26, v28, v27, v30);
  __asm { FMOV            V1.2S, #1.5 }
  v37 = vadd_f32(v4, _D1);
  *(float *)&v38 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v37, 1), *((float *)this + 4), v37.f32[0]);
  LODWORD(v39) = *((_DWORD *)this + 6);
  v40.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v41) = *((_DWORD *)this + 9);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v37, 1), *(float *)v40.i32, v37.f32[0]);
  v43.f64[0] = v29;
  v44 = v29 + *(float *)&v31 * 0.08;
  *(float *)&v31 = *(float *)&v39 + *(float *)&v38;
  *(float *)v43.f64 = *(float *)&v41 + *(float *)v42.i32;
  *((float *)&v31 + 1) = *(float *)&v41 + *(float *)v42.i32;
  v46 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v31, v43, v39, v38, v40, v42, v41, v45);
  v47 = vadd_f32(v4, (float32x2_t)3217031168);
  *(float *)&v48 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v47, 1), *((float *)this + 4), v47.f32[0]);
  LODWORD(v49) = *((_DWORD *)this + 6);
  v50.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v51) = *((_DWORD *)this + 9);
  *(float *)v52.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v47, 1), *(float *)v50.i32, v47.f32[0]);
  v53.f64[0] = v44;
  v54 = v44 + *(float *)&v46 * 0.16;
  *(float *)&v46 = *(float *)&v49 + *(float *)&v48;
  *(float *)v53.f64 = *(float *)&v51 + *(float *)v52.i32;
  *((float *)&v46 + 1) = *(float *)&v51 + *(float *)v52.i32;
  v56 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v46, v53, v49, v48, v50, v52, v51, v55);
  *(float *)&v56 = v54 + *(float *)&v56 * 0.08;
  v57.f64[1] = *((float64_t *)&v96 + 1);
  HIDWORD(v58) = 1067743969;
  *(float32x2_t *)&v57.f64[0] = vadd_f32(v4, (float32x2_t)1069547520);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v57.f64[0], 1), *((float *)this + 4), *(float *)v57.f64);
  LODWORD(v58) = *((_DWORD *)this + 6);
  v60.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v61) = *((_DWORD *)this + 9);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v57.f64[0], 1), *(float *)v60.i32, *(float *)v57.f64);
  v63 = *(float *)&v56 + *(float *)&v96 * 0.04;
  *(float *)&v56 = *(float *)&v58 + *(float *)&v59;
  *(float *)v57.f64 = *(float *)&v61 + *(float *)v62.i32;
  *((float *)&v56 + 1) = *(float *)&v61 + *(float *)v62.i32;
  v65 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v56, v57, v58, v59, v60, v62, v61, v64);
  __asm { FMOV            V1.2S, #-1.5 }
  v67 = vadd_f32(v4, _D1);
  *(float *)&v68 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v67, 1), *((float *)this + 4), v67.f32[0]);
  LODWORD(v69) = *((_DWORD *)this + 6);
  v70.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v71) = *((_DWORD *)this + 9);
  *(float *)v72.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v67, 1), *(float *)v70.i32, v67.f32[0]);
  v73.f64[0] = v63;
  v74 = v63 + *(float *)&v65 * 0.08;
  *(float *)&v65 = *(float *)&v69 + *(float *)&v68;
  *(float *)v73.f64 = *(float *)&v71 + *(float *)v72.i32;
  *((float *)&v65 + 1) = *(float *)&v71 + *(float *)v72.i32;
  v76 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v65, v73, v69, v68, v70, v72, v71, v75);
  v77 = vadd_f32(v4, (float32x2_t)0xBFC0000000000000);
  *(float *)&v78 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v77, 1), *((float *)this + 4), v77.f32[0]);
  LODWORD(v79) = *((_DWORD *)this + 6);
  v80.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v81) = *((_DWORD *)this + 9);
  *(float *)v82.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v77, 1), *(float *)v80.i32, v77.f32[0]);
  v83.f64[0] = v74;
  v84 = v74 + *(float *)&v76 * 0.16;
  *(float *)&v76 = *(float *)&v79 + *(float *)&v78;
  *(float *)v83.f64 = *(float *)&v81 + *(float *)v82.i32;
  *((float *)&v76 + 1) = *(float *)&v81 + *(float *)v82.i32;
  v86 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v76, v83, v79, v78, v80, v82, v81, v85);
  *(float32x2_t *)&v87.f64[0] = vadd_f32(v4, (float32x2_t)0xBFC000003FC00000);
  *(float *)&v88 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v87.f64[0], 1), *((float *)this + 4), *(float *)v87.f64);
  LODWORD(v89) = *((_DWORD *)this + 6);
  v90.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v91) = *((_DWORD *)this + 9);
  *(float *)v92.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v87.f64[0], 1), *(float *)v90.i32, *(float *)v87.f64);
  v4.f32[0] = v84 + *(float *)&v86 * 0.08;
  *(float *)&v86 = *(float *)&v89 + *(float *)&v88;
  *(float *)v87.f64 = *(float *)&v91 + *(float *)v92.i32;
  *((float *)&v86 + 1) = *(float *)&v91 + *(float *)v92.i32;
  v94 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v86, v87, v89, v88, v90, v92, v91, v93);
  *(float *)&v94 = v4.f32[0] + *(float *)&v94 * 0.16;
  result.n64_f32[0] = fminf(*(float *)&v94, *(float *)&v96);
  result.n64_u32[1] = 0;
  return result;
}

double cikernel::_displaceFromImage(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4)
{
  float64x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  int8x16_t v13;
  float64x2_t v14;
  float32x2_t v15;
  double v16;
  double v17;
  uint8x8_t v18;
  int8x16_t v19;
  double v20;
  int8x16_t v21;
  double v22;
  double v23;
  double v24;
  float64x2_t v25;
  uint8x8_t v26;
  double v27;
  int8x16_t v28;
  double v29;
  double v30;
  float64x2_t v31;
  double v32;
  int8x16_t v33;
  uint8x8_t v34;
  double v35;
  int8x16_t v36;
  double v38;
  double v39;
  int8x16_t v41;

  v6.f64[0] = *(float64_t *)CI::getDC(this);
  v41 = (int8x16_t)v6;
  v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)1065353216);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), v7, 1), *((float *)a2 + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)a2 + 7);
  v10.i32[0] = *((_DWORD *)a2 + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)a2 + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  v39 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12, v13);
  v14 = (float64x2_t)v41;
  v15 = vadd_f32(*(float32x2_t *)v41.i8, (float32x2_t)0xBF80000000000000);
  *(float *)&v16 = vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), v15, 1), *((float *)a2 + 4), v15.f32[0]);
  LODWORD(v17) = *((_DWORD *)a2 + 7);
  v18.i32[0] = *((_DWORD *)a2 + 9);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), v15, 1), *(float *)&v17, v15.f32[0]);
  v15.f32[0] = *((float *)a2 + 6) + *(float *)&v16;
  *(float *)v14.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v15.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  v38 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)&v15, v14, v16, v17, v19, v18, v20, v21);
  LODWORD(v22) = *((_DWORD *)a2 + 7);
  *(float *)&v23 = *((float *)a2 + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), *(float32x2_t *)v41.i8, 1), *((float *)a2 + 4), *(float *)v41.i32);
  LODWORD(v24) = *((_DWORD *)a2 + 9);
  *(float *)v25.f64 = *(float *)&v24
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), *(float32x2_t *)v41.i8, 1), *(float *)&v22, *(float *)v41.i32);
  HIDWORD(v23) = LODWORD(v25.f64[0]);
  v29 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), v23, v25, v22, v24, v41, v26, v27, v28);
  HIDWORD(v30) = HIDWORD(v39);
  *(_QWORD *)&v31.f64[1] = v41.i64[1];
  *(float32x2_t *)&v31.f64[0] = vadd_f32(*(float32x2_t *)v41.i8, vmul_n_f32((float32x2_t)vzip1_s32((int32x2_t)vsub_f32(*(float32x2_t *)&v39, *(float32x2_t *)&v29), (int32x2_t)vsub_f32(*(float32x2_t *)&v38, *(float32x2_t *)&v29)), a4));
  LODWORD(v32) = *((_DWORD *)this + 7);
  *(float *)&v29 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v31.f64[0], 1), *((float *)this + 4), *(float *)v31.f64);
  v33.i32[0] = *((_DWORD *)this + 9);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v31.f64[0], 1), *(float *)&v32, *(float *)v31.f64);
  *(float *)v31.f64 = *(float *)v33.i32 + *(float *)&v30;
  *((float *)&v29 + 1) = *(float *)v33.i32 + *(float *)&v30;
  return CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v29, v31, v30, v32, v33, v34, v35, v36);
}

double cikernel::_disolve(float32x4_t a1, float32x4_t a2, float a3)
{
  double result;

  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - a3), a1, a3).u64[0];
  return result;
}

double cikernel::_fadeDissolve(float32x4_t a1, float a2)
{
  double result;

  *(_QWORD *)&result = vmulq_n_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_thresholdRed(double a1, float a2)
{
  BOOL v2;
  double result;

  v2 = *(float *)&a1 < a2;
  LODWORD(a1) = 0;
  if (!v2)
    *(float *)&a1 = 1.0;
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)&a1, 0).u64[0];
  return result;
}

double cikernel::_linearMappingNoSecondaryImage(float a1, float a2)
{
  float v2;
  double v3;
  double result;

  v2 = a1 + -0.5 + a1 + -0.5;
  v3 = sqrt((1.0 - fmaxf(v2, 0.0)) * a2);
  *(float *)&v3 = v3;
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)&v3, 0).u64[0];
  return result;
}

double cikernel::_linearMapping(float a1, float a2, float a3)
{
  float v3;
  double v4;
  double result;

  v3 = a1 + -0.5 + a1 + -0.5;
  v4 = sqrt((1.0 - a2) * (1.0 - fmaxf(v3, 0.0)) * a3);
  *(float *)&v4 = v4;
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)&v4, 0).u64[0];
  return result;
}

CIImage *resample(CIImage *a1, CGRect a2)
{
  double height;
  double width;
  CIImage *v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  CIVector *v12;
  CIImage *v13;
  CIImage *v14;
  double v15;
  CGFloat v16;
  double v17;
  CGAffineTransform v19;
  CGAffineTransform v20;
  const __CFString *v21;
  _QWORD v22[2];

  height = a2.size.height;
  width = a2.size.width;
  v4 = a1;
  v22[1] = *MEMORY[0x1E0C80C00];
  -[CIImage extent](a1, "extent", a2.origin.x, a2.origin.y);
  if (vabdd_f64(v5, width) >= 0.0001 || (-[CIImage extent](v4, "extent"), vabdd_f64(v6, height) >= 0.0001))
  {
    -[CIImage extent](v4, "extent");
    if (v7 >= width || (-[CIImage extent](v4, "extent"), v8 >= height))
    {
      memset(&v20, 0, sizeof(v20));
      -[CIImage extent](v4, "extent");
      v16 = width / v15;
      -[CIImage extent](v4, "extent");
      CGAffineTransformMakeScale(&v20, v16, height / v17);
      v19 = v20;
      v14 = -[CIImage imageByApplyingTransform:](v4, "imageByApplyingTransform:", &v19);
    }
    else
    {
      -[CIImage extent](v4, "extent");
      v10 = width / v9;
      -[CIImage extent](v4, "extent");
      v12 = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v10, height / v11);
      v13 = -[CIImage imageByClampingToExtent](v4, "imageByClampingToExtent");
      v21 = CFSTR("inputScale");
      v22[0] = v12;
      v14 = -[CIImage imageByApplyingFilter:withInputParameters:](v13, "imageByApplyingFilter:withInputParameters:", CFSTR("CISoftCubicUpsample"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v22, &v21, 1));
    }
    return -[CIImage imageByCroppingToRect:](v14, "imageByCroppingToRect:", 0.0, 0.0, width, height);
  }
  return v4;
}

CIImage *conditionallyFilteredMaxThreshold(CIImage *a1, CIImage *a2, CIImage *a3, float a4)
{
  CIColorKernel *v8;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat v12;
  double v13;
  CGFloat v14;
  double v15;
  CGFloat v16;
  CGFloat v17;
  CGFloat v18;
  CGFloat v19;
  CGFloat v20;
  double x;
  double y;
  double width;
  double height;
  _QWORD v26[5];
  CGRect v27;
  CGRect v28;
  CGRect v29;

  v26[4] = *MEMORY[0x1E0C80C00];
  v8 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_DEconditionalFilter);
  -[CIImage extent](a1, "extent");
  v10 = v9;
  v12 = v11;
  v14 = v13;
  v16 = v15;
  -[CIImage extent](a2, "extent");
  v29.origin.x = v17;
  v29.origin.y = v18;
  v29.size.width = v19;
  v29.size.height = v20;
  v27.origin.x = v10;
  v27.origin.y = v12;
  v27.size.width = v14;
  v27.size.height = v16;
  v28 = CGRectUnion(v27, v29);
  x = v28.origin.x;
  y = v28.origin.y;
  width = v28.size.width;
  height = v28.size.height;
  v26[0] = a1;
  v26[1] = a2;
  v26[2] = a3;
  *(float *)&v28.origin.x = a4;
  v26[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v28.origin.x);
  return -[CIColorKernel applyWithExtent:arguments:](v8, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v26, 4), x, y, width, height);
}

float cikernel::_CElumaToR(float32x4_t a1)
{
  float32x4_t v1;
  float result;

  v1 = vmulq_f32(a1, (float32x4_t)xmmword_1924921A0);
  LODWORD(result) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1, 2), vaddq_f32(v1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v1.f32, 1))).u32[0];
  return result;
}

double cikernel::_DEcomputeInversionMask(float32x4_t a1, double a2, float a3, float a4, double a5, float32x4_t a6)
{
  float32x4_t v6;
  BOOL v7;
  double result;

  a6.i32[0] = 1.0;
  if ((float)(fmaxf(fmaxf(a1.f32[0], a1.f32[1]), a1.f32[2]) / fminf(fminf(a1.f32[0], a1.f32[1]), a1.f32[2])) <= a3)
  {
    v6 = vmulq_f32(a1, (float32x4_t)xmmword_1924921A0);
    a6 = vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1));
    v7 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), a6).f32[0] <= (float)((float)(*((float *)&a2 + 1)
                                                                                               + *(float *)&a2)
                                                                                       * 0.5);
    a6.i32[0] = 1.0;
    if (v7)
    {
      if ((float)(*((float *)&a2 + 1) - *(float *)&a2) >= a4)
        a6.f32[0] = 0.0;
      else
        a6.f32[0] = 1.0;
    }
  }
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)a6.f32, 0).u64[0];
  return result;
}

void ___ZL11reduceImageP7CIImageiP8CIKernel_block_invoke(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  CGAffineTransform v8;
  CGAffineTransform v9;
  CGRect v10;
  CGRect v11;

  memset(&v9, 0, sizeof(v9));
  CGAffineTransformMakeScale(&v9, 2.0, 2.0);
  v8 = v9;
  v10.origin.x = a1;
  v10.origin.y = a2;
  v10.size.width = a3;
  v10.size.height = a4;
  v11 = CGRectApplyAffineTransform(v10, &v8);
  CGRectIntegral(v11);
}

double cikernel::_DEmax4(uint64_t a1, double a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  float64x2_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  float64x2_t v21;
  double v22;
  double v23;
  uint8x8_t v24;
  int8x16_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  float64x2_t v29;
  double v30;
  double v31;
  uint8x8_t v32;
  int8x16_t v33;
  double v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float64x2_t v44;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)&v4.f64[0] = vadd_f32(*DC, *DC);
  v44 = v4;
  v5 = vadd_f32(*(float32x2_t *)&v4.f64[0], (float32x2_t)0xBF000000BF000000);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v4, v6, v7, v9, v8, v10, v11);
  v42 = v12;
  v13 = v44;
  *(float32x2_t *)v12.f32 = vadd_f32(*(float32x2_t *)&v44.f64[0], (float32x2_t)0xBF0000003F000000);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v15, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v13.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v12.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v13, v14, v15, v17, v16, v18, v19);
  v40 = v20;
  v21 = v44;
  *(float32x2_t *)v20.f32 = vadd_f32(*(float32x2_t *)&v44.f64[0], (float32x2_t)0x3F000000BF000000);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v20.f32, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v20.f32, 1), *(float *)&v23, v20.f32[0]);
  v20.f32[0] = *(float *)(a1 + 24) + *(float *)&v22;
  *(float *)v21.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v20.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v21, v22, v23, v25, v24, v26, v27);
  v41 = v28;
  v29 = v44;
  *(float32x2_t *)v28.f32 = vadd_f32(*(float32x2_t *)&v44.f64[0], (float32x2_t)0x3F0000003F000000);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v28.f32, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v28.f32, 1), *(float *)&v31, v28.f32[0]);
  v28.f32[0] = *(float *)(a1 + 24) + *(float *)&v30;
  *(float *)v29.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v28.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v29, v30, v31, v33, v32, v34, v35);
  if (*(float *)v44.f64 + 0.5 >= *(float *)&a2)
  {
    v37 = v41;
    v38 = v42;
  }
  else
  {
    v37 = vmaxnmq_f32(v41, v36);
    v38 = vmaxnmq_f32(v42, v40);
  }
  if (*((float *)v44.f64 + 1) + 0.5 < *((float *)&a2 + 1))
    v38.i64[0] = vmaxnmq_f32(v38, v37).u64[0];
  return *(double *)v38.i64;
}

double cikernel::_DEcreateForegroundMask(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float v4;
  float32x4_t v5;
  int32x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  int32x4_t v9;
  float v10;
  BOOL v12;
  int8x16_t v13;
  unsigned int v14;
  double result;

  v4 = fminf(a1.f32[0], fminf(a1.f32[1], a1.f32[2]));
  v5 = vmulq_f32(a2, (float32x4_t)vdupq_n_s32(0x3EAAAAAAu));
  v6 = (int32x4_t)vmulq_f32(a1, (float32x4_t)xmmword_192494230);
  v7 = (int32x4_t)vmulq_f32(a1, (float32x4_t)xmmword_192494240);
  v8 = (int32x4_t)vmulq_f32(a3, (float32x4_t)xmmword_192494230);
  v9 = (int32x4_t)vmulq_f32(a3, (float32x4_t)xmmword_192494240);
  *(float32x2_t *)v9.i8 = vsub_f32((float32x2_t)vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v6, 2), vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v6.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v7, 2), vadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 1)))), (float32x2_t)vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v8, 2), vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v8.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v9, 2),
                                                        vadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v9.i8, 1)))));
  LODWORD(v10) = vmulq_f32(a4, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1)))).u32[0];
  a4.f32[0] = fmaxf(a1.f32[0], fmaxf(a1.f32[1], a1.f32[2])) / v4;
  v12 = sqrtf(vaddv_f32(vmul_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)v9.i8))) > a4.f32[3]
     || a4.f32[0] > a4.f32[1]
     || v4 < v10;
  v13 = (int8x16_t)vmulq_f32(a1, (float32x4_t)0);
  if (v12)
    v14 = -1;
  else
    v14 = 0;
  *(_QWORD *)&result = vbslq_s8((int8x16_t)vdupq_n_s32(v14), v13, (int8x16_t)a1).u64[0];
  return result;
}

void CI::f4_s_s_s_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __n128 *v19;
  __n128 *v20;
  __n128 *v21;
  __n128 *v22;
  __int128 v23;
  double (*v24)(__n128, __n128, __n128, __n128);

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  if (*(_BYTE *)(a1 + 64))
  {
    v24 = *(double (**)(__n128, __n128, __n128, __n128))(a1 + 24);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 104)), a2);
    v10 = v24;
  }
  v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v18);
  v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v16);
  v21 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v21 = (__n128 *)((char *)a2 + 64 * v14);
  v22 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v22 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v23 = v10(*v22, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

CIImage *normalizedBlur(CIImage *a1, float a2)
{
  CIColorKernel *v4;
  CIImage *v5;
  double v6;
  double v7;
  double v8;
  double v9;
  CIImage *v10;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  v4 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_DEnormalizeAlpha);
  v5 = -[CIImage imageByApplyingGaussianBlurWithSigma:](a1, "imageByApplyingGaussianBlurWithSigma:", a2);
  -[CIImage extent](v5, "extent");
  v12[0] = v5;
  v10 = -[CIColorKernel applyWithExtent:arguments:](v4, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v12, 1), v6, v7, v8, v9);
  -[CIImage extent](a1, "extent");
  return -[CIImage imageByCroppingToRect:](v10, "imageByCroppingToRect:");
}

double cikernel::_DEnormalizeAlpha(float32x4_t a1, double a2)
{
  float v2;
  float v3;
  BOOL v4;
  float v5;
  double result;

  v2 = (float)(a1.f32[3] + -0.001) / 0.099;
  v3 = 1.0;
  if (v2 <= 1.0)
    v3 = (float)(a1.f32[3] + -0.001) / 0.099;
  v4 = v2 < 0.0;
  v5 = 0.0;
  if (!v4)
    v5 = v3;
  *(float *)&a2 = fmaxf(a1.f32[3], 0.0001);
  *(_QWORD *)&result = vdivq_f32(vmulq_n_f32(a1, (float)(v5 * v5) * (float)((float)(v5 * -2.0) + 3.0)), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0)).u64[0];
  return result;
}

double cikernel::_DEWash(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vdivq_f32(a1, vaddq_f32(a2, (float32x4_t)vdupq_n_s32(0x358637BDu))).u64[0];
  return result;
}

float cikernel::_DE_compinv(float32x4_t a1)
{
  float32x4_t v6;
  float result;

  __asm { FMOV            V1.4S, #1.0 }
  v6 = vmulq_f32(vsubq_f32(_Q1, a1), (float32x4_t)vdupq_n_s32(0x3EAAAAABu));
  LODWORD(result) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).u32[0];
  return result;
}

double cikernel::_DEconditionalFilter(int8x16_t a1, int8x16_t a2, float32x4_t a3, float32x4_t a4)
{
  double result;

  *(_QWORD *)&result = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a3, a4), 0), a1, a2).u64[0];
  return result;
}

void CI::f4_s_s_s_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(_QWORD *, __n128, __n128, __n128, float);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __n128 *v20;
  __int128 v21;

  v9 = a1[6];
  v10 = (double (*)(_QWORD *, __n128, __n128, __n128, float))a1[3];
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_QWORD *)(v9 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 104)), a2);
  v18 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v16);
  v19 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v14);
  v20 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v21 = v10(a1, *v20, *v19, *v18, *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

float cikernel::_DE_sub(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float result;

  v2 = vmulq_f32(a1, (float32x4_t)xmmword_1924921A0);
  v3 = vmulq_f32(a2, (float32x4_t)xmmword_1924921A0);
  LODWORD(result) = vsubq_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1)))).u32[0];
  return result;
}

double cikernel::_DE_scaleAdd(float32x4_t a1, float _S1, float _S2)
{
  float32x4_t v3;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  double result;

  v3 = vmulq_f32(a1, (float32x4_t)xmmword_1924921A0);
  _Q3 = (int32x4_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1)));
  v5 = vmulq_f32(a1, (float32x4_t)xmmword_192494230);
  v6 = vmulq_f32(a1, (float32x4_t)xmmword_192494240);
  __asm { FMLS            S3, S2, V1.S[0] }
  v11 = (float32x4_t)vzip1q_s32(_Q3, (int32x4_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))));
  v11.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).u32[0];
  v12 = vmulq_f32(v11, (float32x4_t)xmmword_192494250);
  v12.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).u32[0];
  v13 = vmulq_f32(v11, (float32x4_t)xmmword_192494260);
  v14 = vmulq_f32(v11, (float32x4_t)xmmword_192494270);
  v12.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).u32[0];
  v12.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).u32[0];
  v15 = vmaxnmq_f32(v12, (float32x4_t)0);
  v15.i32[3] = 0;
  v16 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a1, 3);
  v16.i32[3] = 0;
  *(_QWORD *)&result = vminnmq_f32(v15, v16).u64[0];
  return result;
}

double cikernel::_CEcomp_minmax(__n128 a1)
{
  double v1;

  *(float *)&v1 = fminf(fminf(a1.n128_f32[0], a1.n128_f32[1]), a1.n128_f32[2]);
  HIDWORD(v1) = fmaxf(fmaxf(a1.n128_f32[0], a1.n128_f32[1]), a1.n128_f32[2]);
  return v1;
}

void ___ZL14reduceImageBy2P7CIImageP8CIKerneli_block_invoke(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  CGAffineTransform v8;
  CGRect v9;
  CGRect v10;

  CGAffineTransformMakeScale(&v8, 2.0, 2.0);
  v9.origin.x = a1;
  v9.origin.y = a2;
  v9.size.width = a3;
  v9.size.height = a4;
  v10 = CGRectApplyAffineTransform(v9, &v8);
  CGRectIntegral(v10);
}

__n64 cikernel::_DEminmax4(uint64_t a1, double a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  int8x16_t v11;
  float64x2_t v12;
  float32x2_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  double v18;
  int8x16_t v19;
  float64x2_t v20;
  float32x2_t v21;
  double v22;
  double v23;
  uint8x8_t v24;
  int8x16_t v25;
  double v26;
  int8x16_t v27;
  float64x2_t v28;
  float32x2_t v29;
  double v30;
  double v31;
  uint8x8_t v32;
  int8x16_t v33;
  double v34;
  int8x16_t v35;
  double v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  double v43;
  float v44;
  BOOL v45;
  __n64 result;
  float v47;
  double v48;
  double v49;
  double v50;
  float64x2_t v52;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)&v4.f64[0] = vadd_f32(*DC, *DC);
  v52 = v4;
  v5 = vadd_f32(*(float32x2_t *)&v4.f64[0], (float32x2_t)0xBF000000BF000000);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  v50 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v4, v6, v7, v9, v8, v10, v11);
  v12 = v52;
  v13 = vadd_f32(*(float32x2_t *)&v52.f64[0], (float32x2_t)0xBF0000003F000000);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v13, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v13, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v12.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  v49 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v13, v12, v14, v15, v17, v16, v18, v19);
  v20 = v52;
  v21 = vadd_f32(*(float32x2_t *)&v52.f64[0], (float32x2_t)0x3F000000BF000000);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v21, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v21, 1), *(float *)&v23, v21.f32[0]);
  v21.f32[0] = *(float *)(a1 + 24) + *(float *)&v22;
  *(float *)v20.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v21.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  v48 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v21, v20, v22, v23, v25, v24, v26, v27);
  v28 = v52;
  v29 = vadd_f32(*(float32x2_t *)&v52.f64[0], (float32x2_t)0x3F0000003F000000);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v29, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v29, 1), *(float *)&v31, v29.f32[0]);
  v29.f32[0] = *(float *)(a1 + 24) + *(float *)&v30;
  *(float *)v28.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v29.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  v36 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v29, v28, v30, v31, v33, v32, v34, v35);
  v37 = *((float *)&v50 + 1);
  v38 = *((float *)&v48 + 1);
  v39 = fminf(*(float *)&v48, *(float *)&v36);
  v40 = fminf(*(float *)&v50, *(float *)&v49);
  v41 = fmaxf(*((float *)&v50 + 1), *((float *)&v49 + 1));
  v42 = fmaxf(*((float *)&v48 + 1), *((float *)&v36 + 1));
  if (*(float *)v52.f64 + 0.5 < *(float *)&a2)
  {
    v37 = v41;
  }
  else
  {
    v39 = *(float *)&v48;
    v40 = *(float *)&v50;
  }
  if (*(float *)v52.f64 + 0.5 < *(float *)&a2)
    v38 = v42;
  v43 = *((float *)v52.f64 + 1) + 0.5;
  v44 = fminf(v40, v39);
  v45 = v43 < *((float *)&a2 + 1);
  if (v43 >= *((float *)&a2 + 1))
    result.n64_f32[0] = v40;
  else
    result.n64_f32[0] = v44;
  v47 = fmaxf(v37, v38);
  if (v45)
    v37 = v47;
  result.n64_f32[1] = v37;
  return result;
}

double cikernel::_CEstretch(float32x4_t a1, float32x4_t a2, float a3)
{
  float32x4_t v3;
  int32x2_t v4;
  float32x4_t v5;
  float32x4_t v6;
  double result;

  v3 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0);
  v4 = (int32x2_t)vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 1), a2).u64[0];
  *(float *)v4.i32 = fmaxf(*(float *)v4.i32, 0.00001);
  v5 = vdivq_f32(vsubq_f32(a1, v3), (float32x4_t)vdupq_lane_s32(v4, 0));
  v5.i32[3] = 0;
  v6 = vmaxnmq_f32(v5, (float32x4_t)0);
  v6.i32[3] = 0;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a3), vminnmq_f32(v6, (float32x4_t)xmmword_192491FD0), a3).u64[0];
  return result;
}

void sub_192277668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__4(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

float32x2_t cikernel::_droste(CI *a1, float32x2_t a2, double a3, float a4, double a5, double a6)
{
  float32x2_t v8;
  float v9;
  __float2 v10;
  float v11;
  float v12;
  float32x2_t v14;
  float32_t v15;
  float32x2_t v19;

  v14 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v15 = *(float *)&a5 + atan2f(v14.f32[1], v14.f32[0]);
  v8.f32[0] = logf(vaddv_f32(vmul_f32(v14, v14))) * 0.5;
  v8.f32[1] = v15;
  v9 = vaddv_f32(vmul_f32((float32x2_t)vrev64_s32(*(int32x2_t *)&a3), v8));
  LODWORD(a3) = expf(vmlas_n_f32(vmuls_lane_f32(-v15, *(float32x2_t *)&a3, 1), v8.f32[0], *(float *)&a3));
  v10 = __sincosf_stret(v9);
  v19 = vmul_lane_f32(vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v10.__sinval), LODWORD(v10.__cosval)), *(float *)&a3), *(float32x2_t *)&a5, 1);
  v11 = fmaxf(fabsf(v19.f32[0]) / *(float *)&a6, fabsf(v19.f32[1]) / *((float *)&a6 + 1));
  v12 = logf(v11);
  return vadd_f32(a2, vmul_n_f32(v19, expf(v12 - (float)(a4 * floorf(v12 / a4))) / v11));
}

void CI::f2_f2_f2_f_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(double, double, float, double, double);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  double *v20;
  double *v21;
  double *v22;
  double *v23;
  int v24;
  double (*v25)(double, double, float, double, double);

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(double, double, float, double, double))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_DWORD *)(v9 + 88);
  v17 = *(_QWORD *)(v9 + 80);
  v18 = *(_DWORD *)(v9 + 112);
  v19 = *(_QWORD *)(v9 + 104);
  if (*(_BYTE *)(a1 + 64))
  {
    v25 = *(double (**)(double, double, float, double, double))(a1 + 24);
    v24 = *(_DWORD *)(v9 + 112);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
    v18 = v24;
    v10 = v25;
  }
  v20 = (double *)(a3 + 16 * v19);
  if (v18 != 5)
    v20 = (double *)((char *)a2 + 64 * v19);
  v21 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v21 = (double *)((char *)a2 + 64 * v17);
  v22 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v22 = (double *)((char *)a2 + 64 * v14);
  v23 = (double *)(a3 + 16 * v12);
  if (v11 != 5)
    v23 = (double *)((char *)a2 + 64 * v12);
  *(double *)(a3 + 16 * a7) = v10(*v23, *v22, *((float *)a2 + 16 * v15), *v21, *v20);
}

__n64 cikernel::_drr_noise(cikernel *this, float a2, float a3)
{
  float32x2_t v4;
  float v5;
  float v6;
  __n64 result;

  v4 = vrndm_f32(*(float32x2_t *)CI::getDC(this));
  v5 = v4.f32[0] * 0.764705882 + 65.3529412;
  v4.f32[0] = v4.f32[1] * 0.578947368 + 409.315789;
  v6 = (float)(v4.f32[0] + (float)(v4.f32[0] * v5)) + floor((float)(v4.f32[0] + (float)(v4.f32[0] * v5)) / 37.0) * -37.0;
  v4.f32[0] = (float)(v5 + (float)(v4.f32[0] * v6)) + floor((float)(v5 + (float)(v4.f32[0] * v6)) / 37.0) * -37.0;
  v4.f32[0] = (float)(v5 * v4.f32[0]) + floor((float)(v5 * v4.f32[0]) / 37.0) * -37.0;
  result.n64_f32[0] = ((float)(v4.f32[0] / 37.0) + -0.5) * a2;
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_f_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v10;
  double (*v11)(_QWORD *, float, float);
  uint64_t v12;
  uint64_t v13;
  __int128 v14;

  v10 = (_QWORD *)a1[6];
  v11 = (double (*)(_QWORD *, float, float))a1[3];
  v12 = v10[1];
  v13 = v10[4];
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * v10[7]), a2);
  *(double *)&v14 = v11(a1, *((float *)a2 + 16 * v12), *((float *)a2 + 16 * v13));
  *(_OWORD *)(a3 + 16 * a7) = v14;
}

double cikernel::_drr_cdintersect(CI *a1, float32x4_t a2, float32x2_t a3, float a4, float a5)
{
  float32x2_t v6;
  BOOL v7;
  float v8;
  double result;

  v6 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a3);
  v7 = vaddv_f32(vmul_f32(v6, v6)) > (float)(a5 * a4);
  v8 = 0.0;
  if (!v7)
    v8 = 1.0;
  *(_QWORD *)&result = vmulq_n_f32(a2, v8).u64[0];
  return result;
}

double cikernel::_drr_cdmeasure(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  double result;

  v2 = vdivq_f32(vabdq_f32(a1, a2), vmaxnmq_f32(vaddq_f32(a1, a2), (float32x4_t)vdupq_n_s32(0x38D1B717u)));
  __asm { FMOV            V1.4S, #1.0 }
  *(_QWORD *)&result = vsubq_f32(_Q1, v2).u64[0];
  return result;
}

double cikernel::_drr_spec(float32x4_t a1, __n128 a2, double a3, float a4, float a5)
{
  float v5;
  float v6;
  BOOL v7;
  float v8;
  unint64_t v9;

  *(float *)&a3 = fminf(1.25 * *(float *)&a3, 1.0);
  if (*(float *)&a3 <= a5)
  {
    v9 = a1.i64[0];
  }
  else
  {
    v5 = fminf((float)((float)((float)(a2.n128_f32[2] + vaddv_f32((float32x2_t)a2.n128_u64[0]))- fminf(fminf(a2.n128_f32[0], a2.n128_f32[1]), a2.n128_f32[2]))* 0.5)* a4, 1.0)/ 0.6;
    if (v5 <= 1.0)
      v6 = v5;
    else
      v6 = 1.0;
    v7 = v5 < 0.0;
    v8 = 0.0;
    if (!v7)
      v8 = v6;
    v9 = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - *(float *)&a3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), (float)(v8 * v8) * (float)((float)(v8 * -2.0) + 3.0)).u64[0];
  }
  return *(double *)&v9;
}

void CI::f4_s_s_s_f_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, float, float, float);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __n128 *v20;
  __n128 *v21;
  __n128 *v22;
  __int128 v23;
  int v24;
  int v25;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, float, float, float))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_QWORD *)(v9 + 80);
  v18 = *(_QWORD *)(v9 + 104);
  v19 = *(_QWORD *)(v9 + 128);
  if (*(_BYTE *)(a1 + 64))
  {
    v24 = *(_DWORD *)(v9 + 64);
    v25 = *(_DWORD *)(v9 + 40);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 152)), a2);
    v15 = v24;
    v13 = v25;
  }
  v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v16);
  v21 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v21 = (__n128 *)((char *)a2 + 64 * v14);
  v22 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v22 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v23 = v10(*v22, *v21, *v20, *((float *)a2 + 16 * v17), *((float *)a2 + 16 * v18), *((float *)a2 + 16 * v19));
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

double cikernel::_drr_spec_debug(float32x4_t a1, __n128 a2, double a3, float a4, float a5, float a6)
{
  float v6;
  float v7;
  BOOL v8;
  float v9;
  int8x16_t v10;
  int32x4_t v11;
  int32x4_t v12;

  *(float *)&a3 = fminf(1.25 * *(float *)&a3, 1.0);
  if (*(float *)&a3 <= a5)
  {
    v10 = (int8x16_t)a1;
  }
  else
  {
    v6 = fminf((float)((float)((float)(a2.n128_f32[2] + vaddv_f32((float32x2_t)a2.n128_u64[0]))- fminf(fminf(a2.n128_f32[0], a2.n128_f32[1]), a2.n128_f32[2]))* 0.5)* a4, 1.0)/ 0.6;
    if (v6 <= 1.0)
      v7 = v6;
    else
      v7 = 1.0;
    v8 = v6 < 0.0;
    v9 = 0.0;
    if (!v8)
      v9 = v7;
    v10 = (int8x16_t)vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - *(float *)&a3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), (float)(v9 * v9) * (float)((float)(v9 * -2.0) + 3.0));
  }
  v11 = (int32x4_t)v10;
  v11.i32[3] = a1.i32[3];
  if (a6 >= 1.0)
  {
    if (a6 >= 2.0)
    {
      if (a6 < 3.0)
      {
        v12 = (int32x4_t)vextq_s8(v10, v10, 8uLL);
        *(float32x2_t *)v12.i8 = vmul_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v10.i8, *(int32x2_t *)v12.i8), 0);
        v11.i64[0] = vtrn2q_s32(vzip1q_s32(v11, v12), v11).u64[0];
      }
    }
    else
    {
      v11.i32[1] = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 4uLL), 0).u32[0];
    }
  }
  return *(double *)v11.i64;
}

double cikernel::_drr_repair(int8x16_t a1, float32x4_t a2, float a3, float32x4_t a4, float a5, float a6, float a7, float a8, float a9)
{
  int32x2_t v17;
  double v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float v25;
  float32x2_t v26;
  float v27;
  BOOL v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float32x4_t v41;
  float v42;
  double result;

  v18 = (a7 + a7) * a5;
  *(float *)&v18 = v18;
  v19 = vaddq_f32(a4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v18, 0));
  a4.f32[0] = a7 * a5;
  v20 = vaddq_f32(a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a4.f32, 0));
  v21 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)a1.i8, 0);
  v22 = (float32x2_t)vext_s8(*(int8x8_t *)a1.i8, (int8x8_t)*(_OWORD *)&vextq_s8(a1, a1, 8uLL), 4uLL);
  v23 = vmaxnm_f32(vsub_f32(v21, v22), 0);
  v24 = vadd_f32(v21, v22);
  v26 = (float32x2_t)vdup_n_s32(0x38D1B717u);
  v25 = fmaxf(vaddv_f32(vdiv_f32(v23, vmaxnm_f32(v24, v26))) * 0.5, 0.25);
  v26.f32[0] = (float)(v25 + -0.1) + (float)(v25 + -0.1);
  if (v26.f32[0] <= 1.0)
    v27 = (float)(v25 + -0.1) + (float)(v25 + -0.1);
  else
    v27 = 1.0;
  v28 = v26.f32[0] < 0.0;
  v26.i32[0] = 0;
  if (v28)
    *(float *)v17.i32 = 0.0;
  else
    *(float *)v17.i32 = v27;
  *(float *)v17.i32 = (float)(*(float *)v17.i32 * *(float *)v17.i32) * (float)((float)(*(float *)v17.i32 * -2.0) + 3.0);
  v29 = vmlaq_n_f32(vmulq_n_f32(vmulq_n_f32(v19, a6 + a6), 1.0 - *(float *)v17.i32), (float32x4_t)vdupq_lane_s32(v17, 0), (float)(a6 * 0.5) * fminf(v20.f32[2], v20.f32[1]));
  v30 = vmulq_f32(v29, (float32x4_t)xmmword_1924921A0);
  v31 = vmulq_f32(v19, (float32x4_t)xmmword_1924921A0);
  v32 = vmulq_n_f32(vmulq_n_f32(v19, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v30, 2), vaddq_f32(v30, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v30.f32, 1))).f32[0]), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2), vaddq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1))).f32[0]);
  v33 = vmulq_f32(v19, (float32x4_t)vdupq_n_s32(0x3D75C28Fu));
  v33.i32[3] = 0;
  v34 = vmlaq_n_f32(vmulq_n_f32(v29, 1.0 - a9), v32, a9);
  v34.i32[3] = 0;
  v35 = vmulq_f32((float32x4_t)a1, (float32x4_t)xmmword_1924921A0);
  v36 = vmaxnmq_f32(v33, v34);
  v37 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), vaddq_f32(v35, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1))).f32[0];
  v38 = a8 + 0.01;
  v39 = (float)(v37 - v38) / (float)(1.01 - v38);
  if (v39 <= 1.0)
    v40 = v39;
  else
    v40 = 1.0;
  if (v39 >= 0.0)
    v26.f32[0] = v40;
  v26.f32[0] = (float)(v26.f32[0] * v26.f32[0]) * (float)((float)(v26.f32[0] * -2.0) + 3.0);
  v41 = vmlaq_n_f32(vmulq_n_f32(v36, 1.0 - v26.f32[0]), (float32x4_t)vdupq_lane_s32((int32x2_t)v26, 0), v37);
  v42 = (1.0 - v26.f32[0]) * a3;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - a3), vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - v42), v41, v42), a3).u64[0];
  return result;
}

void CI::f4_s_s_s_s_s_f_f_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, __n128, float, float, float, double);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __n128 *v25;
  __n128 *v26;
  __n128 *v27;
  __n128 *v28;
  __n128 *v29;
  __n128 *v30;
  __int128 v31;
  double v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  double (*v37)(__n128, __n128, __n128, __n128, __n128, float, float, float, double);
  uint64_t v38;
  uint64_t v39;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, float, float, float, double))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  v19 = *(_DWORD *)(v9 + 112);
  v20 = *(_QWORD *)(v9 + 104);
  v21 = *(_QWORD *)(v9 + 128);
  v22 = *(_QWORD *)(v9 + 152);
  v23 = *(_QWORD *)(v9 + 176);
  v24 = *(_QWORD *)(v9 + 200);
  if (*(_BYTE *)(a1 + 64))
  {
    v37 = *(double (**)(__n128, __n128, __n128, __n128, __n128, float, float, float, double))(a1 + 24);
    v38 = *(_QWORD *)(v9 + 200);
    v35 = *(_QWORD *)(v9 + 128);
    v36 = *(_QWORD *)(v9 + 32);
    v39 = *(_QWORD *)(v9 + 152);
    v33 = *(_DWORD *)(v9 + 112);
    v34 = *(_DWORD *)(v9 + 88);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 224)), a2);
    v19 = v33;
    v17 = v34;
    v21 = v35;
    v14 = v36;
    v24 = v38;
    v22 = v39;
    v10 = v37;
  }
  v25 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5)
    v25 = (__n128 *)((char *)a2 + 64 * v20);
  v26 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v26 = (__n128 *)((char *)a2 + 64 * v18);
  v27 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v27 = (__n128 *)((char *)a2 + 64 * v16);
  v28 = (__n128 *)(a3 + 16 * v14);
  v29 = (__n128 *)((char *)a2 + 64 * v14);
  if (v13 != 5)
    v28 = v29;
  v30 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v30 = (__n128 *)((char *)a2 + 64 * v12);
  LODWORD(v32) = *((_DWORD *)a2 + 16 * v24);
  *(double *)&v31 = v10(*v30, *v28, *v27, *v26, *v25, *((float *)a2 + 16 * v21), *((float *)a2 + 16 * v22), *((float *)a2 + 16 * v23), v32);
  *(_OWORD *)(a3 + 16 * a7) = v31;
}

double cikernel::_drr_recovery(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float a5)
{
  float32x4_t v5;
  float v6;
  float v7;
  float v8;
  BOOL v9;
  float v10;
  float v11;
  float32x4_t v12;
  float32x4_t v13;
  double result;

  v5 = vmulq_f32(a2, (float32x4_t)vdupq_n_s32(0x3EAAAAABu));
  LODWORD(v6) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).u32[0];
  v7 = (float)(fminf(fminf(a1.f32[0], a1.f32[1]), a1.f32[2]) + -0.6) / 0.35;
  if (v7 <= 1.0)
    v8 = v7;
  else
    v8 = 1.0;
  v9 = v7 < 0.0;
  v10 = 0.0;
  if (!v9)
    v10 = v8;
  v11 = (float)((float)(v10 * v10) * (float)((float)(v10 * -2.0) + 3.0)) * a5;
  v12 = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - v11), vdivq_f32(vmulq_f32(a3, vmlaq_n_f32(a2, (float32x4_t)0, v6)), a4), v11);
  v13 = a1;
  v13.i32[3] = 0;
  v12.i32[3] = 0;
  *(_QWORD *)&result = vminnmq_f32(v13, v12).u64[0];
  return result;
}

void CI::f4_s_s_s_s_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, float);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  __n128 *v20;
  __n128 *v21;
  __n128 *v22;
  __n128 *v23;
  __int128 v24;
  int v25;
  int v26;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, float))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  v19 = *(_QWORD *)(v9 + 104);
  if (*(_BYTE *)(a1 + 64))
  {
    v25 = *(_DWORD *)(v9 + 88);
    v26 = *(_DWORD *)(v9 + 64);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
    v17 = v25;
    v15 = v26;
  }
  v20 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v18);
  v21 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v21 = (__n128 *)((char *)a2 + 64 * v16);
  v22 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v22 = (__n128 *)((char *)a2 + 64 * v14);
  v23 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v23 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v24 = v10(*v23, *v22, *v21, *v20, *((float *)a2 + 16 * v19));
  *(_OWORD *)(a3 + 16 * a7) = v24;
}

void OUTLINED_FUNCTION_1_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x20u);
}

double OUTLINED_FUNCTION_6(float a1)
{
  return a1;
}

void OUTLINED_FUNCTION_11(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

void OUTLINED_FUNCTION_12(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x18u);
}

void OUTLINED_FUNCTION_13(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x1Cu);
}

double OUTLINED_FUNCTION_14@<D0>(uint64_t a1@<X8>, float a2@<S0>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 8) = a1;
  return (float)(a2 * 100.0);
}

double OUTLINED_FUNCTION_15@<D0>(uint64_t a1@<X8>, float a2@<S0>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 8) = a1;
  return a2;
}

void sub_19227EB10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  void (*v11)(uint64_t *);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, void (*)(uint64_t *));
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v11((uint64_t *)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_19227F468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,void (*a23)(char *))
{
  a23(&a21);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_1_4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xCu);
}

void OUTLINED_FUNCTION_7_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x20u);
}

uint64_t OUTLINED_FUNCTION_9_1@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_QWORD *)(a2 + 4) = a3;
  *(_WORD *)(a2 + 12) = 2112;
  *(_QWORD *)(a2 + 14) = result;
  return result;
}

void OUTLINED_FUNCTION_13_0(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

uint64_t OUTLINED_FUNCTION_14_0@<X0>(uint64_t result@<X0>, int a2@<W8>)
{
  int v2;
  uint64_t v3;

  *(_QWORD *)(result + 4) = v3;
  *(_WORD *)(result + 12) = 1024;
  *(_DWORD *)(result + 14) = a2;
  *(_WORD *)(result + 18) = 1024;
  *(_DWORD *)(result + 20) = v2;
  return result;
}

void OUTLINED_FUNCTION_15_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x24u);
}

void OUTLINED_FUNCTION_16(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x12u);
}

double OUTLINED_FUNCTION_18()
{
  return CFAbsoluteTimeGetCurrent();
}

void OUTLINED_FUNCTION_19(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x18u);
}

double cikernel::_drr_extract_iris(float a1, double a2, float a3, float a4, float a5, float a6)
{
  BOOL v6;
  float v7;
  float v8;
  double result;

  v6 = *(float *)&a2 < a5;
  LODWORD(a2) = 0;
  if (v6)
    v7 = 1.0;
  else
    v7 = 0.0;
  if (a3 >= a6)
    v8 = 0.0;
  else
    v8 = 1.0;
  if (a1 >= a4)
    *(float *)&a2 = v7;
  *(float *)&a2 = *(float *)&a2 * v8;
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double cikernel::_drr_extract_skin(float a1, double a2)
{
  float v2;
  float v3;
  float v4;
  BOOL v5;
  double result;

  v2 = *(float *)&a2 + 0.05;
  v3 = (float)(a1 - *(float *)&a2) / (float)(v2 - *(float *)&a2);
  if (v3 <= 1.0)
    v4 = v3;
  else
    v4 = 1.0;
  v5 = v3 < 0.0;
  LODWORD(a2) = 0;
  if (!v5)
    *(float *)&a2 = v4;
  *(float *)&a2 = 1.0 - (float)((float)(*(float *)&a2 * *(float *)&a2) * (float)((float)(*(float *)&a2 * -2.0) + 3.0));
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double cikernel::_drr_boost(float32x4_t a1, float a2)
{
  double result;

  *(_QWORD *)&result = vmulq_n_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_rer_glint(float32x4_t a1, float32x4_t a2, float a3)
{
  float v3;
  float v4;
  BOOL v5;
  float v6;
  double result;

  v3 = (float)(fminf(fminf(a1.f32[0], a1.f32[1]), a1.f32[2]) - a3) / (float)(1.0 - a3);
  if (v3 <= 1.0)
    v4 = v3;
  else
    v4 = 1.0;
  v5 = v3 < 0.0;
  v6 = 0.0;
  if (!v5)
    v6 = v4;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - (float)((float)(v6 * v6) * (float)((float)(v6 * -2.0) + 3.0))), a1, (float)(v6 * v6) * (float)((float)(v6 * -2.0) + 3.0)).u64[0];
  return result;
}

double cikernel::_drr_threshold(float32x4_t a1, float a2, float a3)
{
  BOOL v3;
  float v4;
  double result;

  v3 = a2 < a3;
  v4 = 1.0;
  if (v3)
    v4 = 0.0;
  *(_QWORD *)&result = vmulq_n_f32(a1, v4).u64[0];
  return result;
}

void sub_192283C74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_192283CEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id updatedTuningFromSetup(NSDictionary *a1, NSDictionary *a2, NSString *a3, NSString *a4, NSString *a5)
{
  id result;
  void *v9;
  id v10;
  void *v11;
  id v12;
  char v13;
  uint64_t v14;
  void *i;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  void *v28;
  _BYTE v29[128];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  result = -[NSDictionary objectForKey:](a2, "objectForKey:", a3);
  if (result)
  {
    result = (id)objc_msgSend(result, "objectForKey:", a5);
    if (result)
    {
      v9 = result;
      v10 = (id)-[NSDictionary mutableCopy](a1, "mutableCopy");
      v21 = 0u;
      v22 = 0u;
      v23 = 0u;
      v24 = 0u;
      v11 = (void *)objc_msgSend(v9, "allKeys");
      result = (id)objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v21, v29, 16);
      if (result)
      {
        v12 = result;
        v13 = 0;
        v14 = *(_QWORD *)v22;
        do
        {
          for (i = 0; i != v12; i = (char *)i + 1)
          {
            if (*(_QWORD *)v22 != v14)
              objc_enumerationMutation(v11);
            v16 = *(void **)(*((_QWORD *)&v21 + 1) + 8 * (_QWORD)i);
            v17 = (uint64_t)v16;
            if (!objc_msgSend(v10, "objectForKey:", v16))
            {
              v17 = (uint64_t)v16;
              if ((unint64_t)objc_msgSend(v16, "length") >= 3)
              {
                v18 = objc_msgSend((id)objc_msgSend(v16, "substringToIndex:", 1), "uppercaseString");
                v19 = objc_msgSend(v16, "substringFromIndex:", 1);
                v17 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@%@%@"), a4, v18, v19);
              }
            }
            if (objc_msgSend(v10, "objectForKey:", v17))
            {
              objc_msgSend(v10, "setValue:forKey:", objc_msgSend(v9, "objectForKey:", v16), v17);
              v13 = 1;
            }
            else if (CI_LOG_DUALRED())
            {
              v20 = ci_logger_api();
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                v26 = "updatedTuningFromSetup";
                v27 = 2112;
                v28 = v16;
                _os_log_error_impl(&dword_1921E4000, v20, OS_LOG_TYPE_ERROR, "%{public}s Unknown tuning key encountered: %@\n", buf, 0x16u);
              }
            }
          }
          v12 = (id)objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v21, v29, 16);
        }
        while (v12);
        if ((v13 & 1) != 0)
          return v10;
        else
          return 0;
      }
    }
  }
  return result;
}

double expandFromCenter(double a1, double a2, double a3, double a4, double a5, double a6)
{
  float v6;
  float v7;
  double v8;
  CGRect v10;

  v6 = a5 - a3;
  v7 = a6 - a4;
  v10 = CGRectInset(*(CGRect *)&a1, (float)(v6 * -0.5), (float)(v7 * -0.5));
  v8 = floor(COERCE_DOUBLE(CGRectIntegral(v10)) * 0.5);
  return v8 + v8;
}

CIVector *orientedPupilFromLandmarks(void *a1, void *a2, uint64_t a3)
{
  void *v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  double v12;
  uint64_t i;
  void *v14;
  double v15;
  double v16;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  _BYTE v22[128];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (objc_msgSend(a2, "requestRevision") == 3 && objc_msgSend(a2, "leftPupil") && objc_msgSend(a2, "rightPupil"))
  {
    if (a3)
      v6 = (void *)objc_msgSend(a2, "rightPupil");
    else
      v6 = (void *)objc_msgSend(a2, "leftPupil");
  }
  else if (a3)
  {
    v6 = (void *)objc_msgSend(a2, "rightEye");
  }
  else
  {
    v6 = (void *)objc_msgSend(a2, "leftEye");
  }
  v7 = CIVNLandmarkInOrientedImage(v6, a1);
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
  if (v8)
  {
    v9 = v8;
    v10 = *(_QWORD *)v19;
    v11 = 0.0;
    v12 = 0.0;
    do
    {
      for (i = 0; i != v9; ++i)
      {
        if (*(_QWORD *)v19 != v10)
          objc_enumerationMutation(v7);
        v14 = *(void **)(*((_QWORD *)&v18 + 1) + 8 * i);
        objc_msgSend(v14, "X");
        v12 = v12 + v15;
        objc_msgSend(v14, "Y");
        v11 = v11 + v16;
      }
      v9 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
    }
    while (v9);
  }
  else
  {
    v11 = 0.0;
    v12 = 0.0;
  }
  return +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v12 / (double)(unint64_t)objc_msgSend(v7, "count"), v11 / (double)(unint64_t)objc_msgSend(v7, "count"));
}

uint64_t semanticPupils(void *a1, void *a2, uint64_t a3, void *a4, void *a5, uint64_t a6, uint64_t a7)
{
  CIColorKernel *v13;
  double v14;
  double v15;
  double v16;
  double v17;
  CIImage *v18;
  double v19;
  double v20;
  double v21;
  double v22;
  CIImage *v23;
  void *v24;
  double v25;
  double v26;
  double v27;
  _QWORD v29[2];
  _QWORD v30[3];
  _QWORD v31[4];

  v31[3] = *MEMORY[0x1E0C80C00];
  v13 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_resp_previs);
  objc_msgSend(a4, "extent");
  v31[0] = a4;
  v31[1] = a6;
  v31[2] = &unk_1E2F1DA28;
  v18 = -[CIColorKernel applyWithExtent:arguments:](v13, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v31, 3), v14, v15, v16, v17);
  objc_msgSend(a5, "extent");
  v30[0] = a5;
  v30[1] = a7;
  v30[2] = &unk_1E2F1DA28;
  v23 = -[CIColorKernel applyWithExtent:arguments:](v13, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v30, 3), v19, v20, v21, v22);
  v24 = (void *)objc_msgSend(a2, "faceSegments");
  v25 = segmentationCentroidInImage(v24, v18, a1);
  v27 = v26;
  v29[0] = +[CIVector vectorWithCGPoint:](CIVector, "vectorWithCGPoint:", segmentationCentroidInImage(v24, v23, a1));
  v29[1] = +[CIVector vectorWithCGPoint:](CIVector, "vectorWithCGPoint:", v25, v27);
  return objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v29, 2);
}

uint64_t semanticPupilsForFaceObservation(void *a1, void *a2, uint64_t a3)
{
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v5 = probabilitiesForSegment((void *)objc_msgSend(a2, "faceSegments"), 480, a3);
  v6 = (void *)objc_msgSend(v5, "objectAtIndexedSubscript:", 0);
  v7 = (void *)objc_msgSend(v5, "objectAtIndexedSubscript:", 1);
  v8 = objc_msgSend(v5, "objectAtIndexedSubscript:", 2);
  v9 = objc_msgSend(v5, "objectAtIndexedSubscript:", 3);
  return semanticPupils(a1, a2, v10, v6, v7, v8, v9);
}

void *axesForEyePointsV2(void *result)
{
  void *v1;
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  CIVector *v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  _QWORD v17[3];

  v17[2] = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v1 = result;
    if ((unint64_t)objc_msgSend(result, "count") >= 8)
    {
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 4), "X");
      v3 = v2;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 0), "X");
      v5 = (v3 - v4) * 0.5;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 4), "Y");
      v7 = v6;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 0), "Y");
      v9 = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v5, (v7 - v8) * 0.5);
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 2), "X");
      v11 = v10;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 6), "X");
      v13 = (v11 - v12) * 0.5;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 2), "Y");
      v15 = v14;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 6), "Y");
      v17[0] = v9;
      v17[1] = -[CIVector _orthonormalizeTo:](+[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v13, (v15 - v16) * 0.5), "_orthonormalizeTo:", v9);
      return (void *)objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v17, 2);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *axesForEyePointsV3(void *result)
{
  void *v1;
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  CIVector *v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  _QWORD v25[3];

  v25[2] = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v1 = result;
    if ((unint64_t)objc_msgSend(result, "count") >= 6)
    {
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 3), "X");
      v3 = v2;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 0), "X");
      v5 = (v3 - v4) * 0.5;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 3), "Y");
      v7 = v6;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 0), "Y");
      v9 = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v5, (v7 - v8) * 0.5);
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 1), "X");
      v11 = v10;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 2), "X");
      v13 = v11 + v12;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 4), "X");
      v15 = v14;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 5), "X");
      v17 = ((v15 + v16) * -0.5 + v13 * 0.5) * 0.5;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 1), "Y");
      v19 = v18;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 2), "Y");
      v21 = v19 + v20;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 4), "Y");
      v23 = v22;
      objc_msgSend((id)objc_msgSend(v1, "objectAtIndexedSubscript:", 5), "Y");
      v25[0] = v9;
      v25[1] = -[CIVector _orthonormalizeTo:](+[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v17, ((v23 + v24) * -0.5 + v21 * 0.5) * 0.5), "_orthonormalizeTo:", v9);
      return (void *)objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v25, 2);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

float areaForAxes(void *a1, void *a2)
{
  float v3;
  float v4;
  float v5;

  objc_msgSend(a1, "_norm");
  v4 = v3;
  objc_msgSend(a2, "_norm");
  return v4 * 3.14159265 * v5;
}

void repairROIforEyePoints(void *a1, void *a2, float *a3)
{
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  float v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  float v20;
  NSObject *v21;
  CGRect v22;
  CGRect v23;
  CGRect v24;
  CGRect v25;

  v22.origin.x = CIVNBoundingRect(a1);
  v23 = CGRectIntegral(v22);
  x = v23.origin.x;
  y = v23.origin.y;
  width = v23.size.width;
  height = v23.size.height;
  v9 = *a3;
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:", 0), "X");
  v11 = fabs(v10 * v9);
  v12 = a3[1];
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:", 1), "X");
  v14 = v11 + fabs(v13 * v12);
  v15 = *a3;
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:", 0), "Y");
  v17 = fabs(v16 * v15);
  v18 = a3[1];
  objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:", 1), "Y");
  v20 = v17 + fabs(v19 * v18);
  if (CI_LOG_DUALRED())
  {
    v21 = ci_logger_api();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      repairROIforEyePoints_cold_1(v21, v14, v20);
  }
  v24.origin.x = x;
  v24.origin.y = y;
  v24.size.width = width;
  v24.size.height = height;
  v25 = CGRectInset(v24, (float)-v14, (float)-v20);
  v25.origin.x = floor(v25.origin.x * 0.5);
  v25.origin.x = v25.origin.x + v25.origin.x;
  v25.origin.y = floor(v25.origin.y * 0.5);
  v25.origin.y = v25.origin.y + v25.origin.y;
  v25.size.width = floor(v25.size.width * 0.5);
  v25.size.width = v25.size.width + v25.size.width;
  v25.size.height = floor(v25.size.height * 0.5);
  v25.size.height = v25.size.height + v25.size.height;
  CGRectIntegral(v25);
}

uint64_t focusStatsForRegion(double a1, double a2, double a3, double a4, uint64_t a5, void *a6, void *a7)
{
  const __CFDictionary *v13;
  float v14;
  float v15;
  double v16;
  float v17;
  double v18;
  float v19;
  float v20;
  NSObject *v21;
  const __CFDictionary *v22;
  void *v23;
  uint64_t v24;
  size_t Width;
  size_t Height;
  uint64_t v27;
  _QWORD v29[5];
  CGAffineTransform v30;
  CVPixelBufferRef pixelBufferOut;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  __n128 (*v35)(__n128 *, __n128 *);
  uint64_t (*v36)();
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD v41[2];

  v41[1] = *MEMORY[0x1E0C80C00];
  v32 = 0;
  v33 = &v32;
  v34 = 0x4012000000;
  v35 = __Block_byref_object_copy__5;
  v36 = __Block_byref_object_dispose__5;
  v37 = "";
  v40 = *MEMORY[0x1E0CA8FF0];
  v41[0] = MEMORY[0x1E0C9AA70];
  v13 = (const __CFDictionary *)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v41, &v40, 1);
  pixelBufferOut = 0;
  v14 = ceil(a1 / 6.0) * 6.0;
  v15 = floor((a1 + a3) / 6.0) * 6.0;
  v16 = ceil(a2 * 0.5);
  v17 = v16 + v16;
  v18 = floor((a2 + a4) * 0.5);
  *(float *)&v18 = v18 + v18;
  v19 = v15 - v14;
  v20 = *(float *)&v18 - v17;
  if (CVPixelBufferCreate(0, (unint64_t)(float)(v15 - v14), (unint64_t)(float)(*(float *)&v18 - v17), 0x4C303038u, v13, &pixelBufferOut))
  {
    if (CI_LOG_DUALRED())
    {
      v21 = ci_logger_api();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        focusStatsForRegion_cold_1(v21);
    }
  }
  else
  {
    v38 = *MEMORY[0x1E0CA8EE8];
    v39 = *MEMORY[0x1E0CA8F10];
    v22 = (const __CFDictionary *)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v39, &v38, 1);
    CVBufferSetAttachments(pixelBufferOut, v22, kCVAttachmentMode_ShouldPropagate);
    v23 = (void *)objc_msgSend(a7, "imageByCroppingToRect:", v14, v17, v19, v20);
    CGAffineTransformMakeTranslation(&v30, -v14, -v17);
    v24 = objc_msgSend((id)objc_msgSend(v23, "imageByApplyingTransform:", &v30), "imageByApplyingFilter:", CFSTR("CILinearToSRGBToneCurve"));
    Width = CVPixelBufferGetWidth(pixelBufferOut);
    Height = CVPixelBufferGetHeight(pixelBufferOut);
    objc_msgSend(a6, "render:toCVPixelBuffer:bounds:colorSpace:", v24, pixelBufferOut, 0, 0.0, 0.0, (double)Width, (double)Height);
    v29[0] = MEMORY[0x1E0C809B0];
    v29[1] = 3221225472;
    v29[2] = __focusStatsForRegion_block_invoke;
    v29[3] = &unk_1E2EC3778;
    v29[4] = &v32;
    PixelBufferApplyPlaneReadOnlyBlock(pixelBufferOut, (uint64_t)v29);
    if (pixelBufferOut)
      CFRelease(pixelBufferOut);
  }
  v27 = v33[6];
  _Block_object_dispose(&v32, 8);
  return v27;
}

void sub_19228578C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  _Unwind_Resume(exception_object);
}

__n128 __Block_byref_object_copy__5(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  return result;
}

void __focusStatsForRegion_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, int a6)
{
  uint64_t v8;
  float v9;
  uint64_t v13;
  int v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  int v17;
  unsigned __int8 *v18;
  unint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  uint64_t v28;
  int32x4_t v29;
  int32x4_t v30;
  int32x4_t v31;
  int64x2_t v32;
  int64x2_t v33;
  int32x4_t v34;
  uint32x4_t v35;
  uint64_t v36;
  int v37;
  float64x2_t v38;
  int32x4_t v39;
  double v40;
  int32x4_t v41;
  int64x2_t v42;
  float64x2_t v43;
  float64x2_t v44;
  float64x2_t v45;
  __int128 v46;
  float64x2_t v47;
  float64x2_t v48;
  float64x2_t v49;
  uint64_t v50;
  int64x2_t v51;
  int8x16_t v52;
  int64x2_t v53;
  int32x4_t v54;
  int8x16_t v55;
  int64x2_t v56;
  int64x2_t v57;
  double v58;
  double v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t i;
  int v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  int v69;
  float v70;
  double v71;
  uint64_t v72;
  _DWORD v73[256];
  _DWORD v74[512];
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  if (!a3)
  {
    v8 = 0;
    v9 = 0.0;
    if (a4 >= 3 && a5 >= 3)
    {
      bzero(v74, 0x800uLL);
      bzero(v73, 0x400uLL);
      if ((int)a5 > 4)
      {
        v13 = a2 + 2 * a6 + 1;
        v14 = 2;
        do
        {
          a2 += a6;
          if ((int)a4 >= 5)
          {
            v15 = (unsigned __int8 *)(a2 + 1);
            v16 = (unsigned __int8 *)v13;
            v17 = a4 - 4;
            do
            {
              v18 = v15;
              v19 = *v15;
              v20 = *(v15 - 1);
              v22 = *++v15;
              v21 = v22;
              v23 = v18[-a6];
              v25 = *v16++;
              v24 = v25;
              ++v73[v19];
              if (v19 <= 0xF0 && v20 <= 0xF0 && v21 <= 0xF0 && v23 <= 0xF0 && v24 <= 0xF0)
              {
                v26 = ((v20 + v21 + v23 + v24 + 2) >> 2) - v19 + 256;
                ++v74[v26];
              }
              --v17;
            }
            while (v17);
          }
          v13 += a6;
        }
        while (v14++ != (_DWORD)a5 - 3);
      }
      v28 = 0;
      v29 = (int32x4_t)xmmword_19248E120;
      v30 = 0uLL;
      v31.i64[0] = 0x400000004;
      v31.i64[1] = 0x400000004;
      v32 = 0uLL;
      v33 = 0uLL;
      do
      {
        v34 = *(int32x4_t *)&v74[v28];
        v30 = vaddq_s32(v34, v30);
        v35 = (uint32x4_t)vmulq_s32(v34, v29);
        v33 = (int64x2_t)vaddw_high_u32((uint64x2_t)v33, v35);
        v32 = (int64x2_t)vaddw_u32((uint64x2_t)v32, *(uint32x2_t *)v35.i8);
        v29 = vaddq_s32(v29, v31);
        v28 += 4;
      }
      while (v28 != 512);
      v36 = 0;
      v37 = vaddvq_s32(v30);
      v38 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)vaddvq_s64(vaddq_s64(v32, v33)) / (double)v37), 0);
      v39 = (int32x4_t)xmmword_19248E120;
      v40 = 0.0;
      v41.i64[0] = 0x400000004;
      v41.i64[1] = 0x400000004;
      do
      {
        v42.i64[0] = v39.i32[0];
        v42.i64[1] = v39.i32[1];
        v43 = vcvtq_f64_s64(v42);
        v42.i64[0] = v39.i32[2];
        v42.i64[1] = v39.i32[3];
        v44 = vsubq_f64(vcvtq_f64_s64(v42), v38);
        v45 = vsubq_f64(v43, v38);
        v46 = *(_OWORD *)&v74[v36];
        v42.i64[0] = v46;
        v42.i64[1] = DWORD1(v46);
        v47 = vcvtq_f64_u64((uint64x2_t)v42);
        v42.i64[0] = DWORD2(v46);
        v42.i64[1] = HIDWORD(v46);
        v48 = vmulq_f64(vmulq_f64(v44, v44), vcvtq_f64_u64((uint64x2_t)v42));
        v49 = vmulq_f64(vmulq_f64(v45, v45), v47);
        v40 = v40 + v49.f64[0] + v49.f64[1] + v48.f64[0] + v48.f64[1];
        v39 = vaddq_s32(v39, v41);
        v36 += 4;
      }
      while (v36 != 512);
      v50 = 0;
      v51 = 0uLL;
      v52 = (int8x16_t)vdupq_n_s64(1uLL);
      v53 = 0uLL;
      do
      {
        v54 = vtstq_s32(*(int32x4_t *)&v74[v50], *(int32x4_t *)&v74[v50]);
        v55.i64[0] = v54.u32[0];
        v55.i64[1] = v54.u32[1];
        v56 = (int64x2_t)vandq_s8(v55, v52);
        v55.i64[0] = v54.u32[2];
        v55.i64[1] = v54.u32[3];
        v53 = vaddq_s64(v53, (int64x2_t)vandq_s8(v55, v52));
        v51 = vaddq_s64(v51, v56);
        v50 += 4;
      }
      while (v50 != 512);
      v57 = vaddq_s64(v51, v53);
      v58 = v40 / (double)v37;
      if (v37 <= 0)
        v58 = 0.0;
      v59 = (double)((uint64_t)(((a4 << 32) - 0x300000000) * (a5 + 4294967293u)) >> 32);
      v60 = (uint64_t)(v59 * 0.05);
      if (v60 < 1)
      {
        v64 = 2;
      }
      else
      {
        v61 = 0;
        for (i = 0; i < v60; i += v73[v61++])
        {
          v63 = v61 + 1;
          if (v61 > 0xFE)
            break;
        }
        v64 = 2 - v63;
      }
      v65 = vaddvq_s64(v57);
      v66 = (uint64_t)(v59 * 0.05);
      if (v66 < 1)
      {
        v69 = 255;
      }
      else
      {
        v67 = 0;
        v68 = 255;
        do
        {
          v69 = v68 - 1;
          if (!v68)
            break;
          v67 += v73[v68--];
        }
        while (v67 < v66);
      }
      v70 = (double)(v69 + v64) / 255.0;
      v71 = v70;
      v9 = 0.0;
      if (v71 > 0.00001)
        v9 = v58 / v71;
      v8 = v65;
    }
    v72 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    *(_QWORD *)(v72 + 48) = LODWORD(v9);
    *(_QWORD *)(v72 + 56) = v8;
  }
}

uint64_t dumpfilepathWithTag(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6;
  uint64_t v7;

  v6 = objc_alloc_init(MEMORY[0x1E0CB3578]);
  objc_msgSend(v6, "setDateFormat:", CFSTR("YYYY_MM_dd__HH_mm_ss_SSS"));
  v7 = objc_msgSend(v6, "stringFromDate:", a3);
  return objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@__IMG__%@__redeye%@"), CFSTR("/var/mobile/Media/DCIM/"), v7, a1), "stringByAppendingString:", a2);
}

uint64_t dump(void *a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;

  v6 = objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:", dumpfilepathWithTag(a2, (uint64_t)CFSTR(".tiff"), a4));
  v7 = objc_msgSend(a1, "colorSpace");
  return objc_msgSend(a3, "writeTIFFRepresentationOfImage:toURL:format:colorSpace:options:error:", a1, v6, 264, v7, MEMORY[0x1E0C9AA70], 0);
}

uint64_t dump420f(__CVBuffer *a1, uint64_t a2, uint64_t a3)
{
  id v6;
  size_t v7;
  void *BaseAddressOfPlane;
  size_t HeightOfPlane;

  CVPixelBufferLockBaseAddress(a1, 1uLL);
  v6 = objc_alloc_init(MEMORY[0x1E0C99DF0]);
  if (CVPixelBufferGetPlaneCount(a1))
  {
    v7 = 0;
    do
    {
      BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(a1, v7);
      HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, v7);
      objc_msgSend(v6, "appendBytes:length:", BaseAddressOfPlane, CVPixelBufferGetBytesPerRowOfPlane(a1, v7++) * HeightOfPlane);
    }
    while (CVPixelBufferGetPlaneCount(a1) > v7);
  }
  objc_msgSend(v6, "writeToFile:atomically:", dumpfilepathWithTag(a2, (uint64_t)CFSTR(".420f"), a3), 1);
  return CVPixelBufferUnlockBaseAddress(a1, 1uLL);
}

uint64_t dumpLinearPNG(uint64_t a1, uint64_t a2)
{
  id v4;
  unsigned __int8 v5;
  uint64_t v6;
  const __CFString *v8;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x1E0C80C00];
  v8 = CFSTR("working_color_space");
  v9[0] = objc_msgSend(MEMORY[0x1E0C99E38], "null");
  v4 = +[CIContext _cachedContext:options:](CIContext, "_cachedContext:options:", CFSTR("DualReEye_dumpLinearPNG"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v9, &v8, 1));
  {
    dumpLinearPNG::cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA00]);
  }
  v6 = objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:", a2);
  return objc_msgSend(v4, "writePNGRepresentationOfImage:toURL:format:colorSpace:options:error:", a1, v6, 264, dumpLinearPNG::cs, MEMORY[0x1E0C9AA70], 0);
}

void sub_192285EC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double cikernel::_resp_previs(float a1, double a2, float a3)
{
  BOOL v3;
  double result;

  v3 = *(float *)&a2 <= a3;
  LODWORD(a2) = 1.0;
  if (!v3)
    *(float *)&a2 = 0.0;
  *(float *)&a2 = *(float *)&a2 * a1;
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

uint64_t CIGLIsUsable()
{
  if (getGLWrapperSymbols_once != -1)
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_23);
  return wrapGLIsUsable();
}

uint64_t GetMacroContext@<X0>(void *a1@<X0>, _QWORD *a2@<X8>)
{
  if (getGLWrapperSymbols_once != -1)
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_23);
  return wrapGetMacroContext(a1, a2);
}

uint64_t CIEAGLContextGetAPI(void *a1)
{
  if (getGLWrapperSymbols_once != -1)
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_23);
  return wrapGetContextAPI(a1);
}

uint64_t CIGLGetFormatInfo(int a1, int a2)
{
  if (getGLWrapperSymbols_once != -1)
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_23);
  return wrapGetFormatInfo(a1, a2);
}

void *CIEAGLContextCreate(int a1, void *a2)
{
  if (getGLWrapperSymbols_once != -1)
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_23);
  return wrapEAGLContextCreate(a1, a2);
}

void *CIEAGLContextSetParameter(void *a1, uint64_t a2, int a3)
{
  if (getGLWrapperSymbols_once != -1)
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_23);
  return wrapEAGLContextSetParameter(a1, a2, a3);
}

void *CIEAGLContextSetBackgroundEnabled(void *a1, int a2)
{
  if (getGLWrapperSymbols_once != -1)
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_23);
  return wrapEAGLContextSetBackgroundEnabled(a1, a2);
}

void *CIEAGLContextRetain(void *a1)
{
  if (getGLWrapperSymbols_once != -1)
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_23);
  return wrapEAGLContextRetain(a1);
}

void CIEAGLContextRelease(void *a1)
{
  if (getGLWrapperSymbols_once != -1)
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_23);
  wrapEAGLContextRelease(a1);
}

uint64_t CIEAGLContextTexImageIOSurface(void *a1, GLenum a2, uint64_t a3, uint64_t a4, GLint a5, signed int a6, signed int a7, __IOSurface *a8, unsigned int a9)
{
  if (getGLWrapperSymbols_once != -1)
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_23);
  return wrapEAGLContextTexImageIOSurface(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t is_gpu_A9_or_higher()
{
  if (getGLWrapperSymbols_once != -1)
    dispatch_once(&getGLWrapperSymbols_once, &__block_literal_global_23);
  return wrapIsA9_or_higher();
}

void cikernel::_jointBilateral(uint64_t a1, uint64_t a2, int8x16_t a3)
{
  CI *DC;
  float32x2_t v6;
  float32x2_t *v7;
  float64x2_t v8;
  float32x2_t *v9;
  float v10;
  float v11;
  int8x16_t v12;
  uint8x8_t v13;
  float64x2_t v14;
  double v15;
  double v16;
  float32x2_t v22;
  int8x16_t v23;
  float32x2_t v24;
  float64x2_t v25;
  double v26;
  float32x2_t v27;
  float64x2_t v28;
  double v29;
  double v30;
  int8x16_t v31;
  uint8x8_t v32;
  double v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x2_t v36;
  float32x4_t v37;
  int v38;
  __int128 v39;
  int i;
  float32x2_t v41;
  float32x2_t v42;
  float v43;
  double v44;
  double v45;
  int8x16_t v46;
  uint8x8_t v47;
  double v48;
  int8x16_t v49;
  float32x4_t v50;
  double v51;
  double v52;
  int8x16_t v53;
  uint8x8_t v54;
  double v55;
  int8x16_t v56;
  float v57;
  float v58;
  float32x2_t v59;
  float32x4_t v60;
  float64x2_t v61;
  float64x2_t v62;
  float32x4_t v64;
  __int128 v65;
  float32x4_t v66;

  DC = (CI *)CI::getDC((CI *)a1);
  v6 = *(float32x2_t *)DC;
  v7 = (float32x2_t *)CI::getDC(DC);
  *(float *)v8.f64 = *(float *)(a1 + 24)
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *v7, 1), *(float *)(a1 + 16), COERCE_FLOAT(*v7));
  *((float *)v8.f64 + 1) = *(float *)(a1 + 36)
                         + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *v7, 1), *(float *)(a1 + 28), COERCE_FLOAT(*v7));
  v62 = v8;
  v9 = (float32x2_t *)CI::getDC((CI *)v7);
  v10 = *(float *)(a2 + 16);
  v11 = *(float *)(a2 + 20);
  v12.i32[0] = *(_DWORD *)(a2 + 24);
  v13.i32[0] = *(_DWORD *)(a2 + 28);
  *(float *)v14.f64 = *(float *)v12.i32 + vmlas_n_f32(vmuls_lane_f32(v11, *v9, 1), v10, COERCE_FLOAT(*v9));
  LODWORD(v15) = *(_DWORD *)(a2 + 32);
  LODWORD(v16) = *(_DWORD *)(a2 + 36);
  *((float *)v14.f64 + 1) = *(float *)&v16
                          + vmlas_n_f32(vmuls_lane_f32(*(float *)&v15, *v9, 1), *(float *)v13.i32, COERCE_FLOAT(*v9));
  v61 = v14;
  __asm { FMOV            V0.2S, #1.0 }
  v22 = vadd_f32(v6, _D0);
  *(float *)v23.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  *(float *)&v23.i32[1] = *(float *)(a1 + 36)
                        + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)(a1 + 28), v22.f32[0]);
  v24 = vsub_f32(*(float32x2_t *)v23.i8, *(float32x2_t *)&v62.f64[0]);
  *(float *)v25.f64 = *(float *)v12.i32 + vmlas_n_f32(vmuls_lane_f32(v11, v22, 1), v10, v22.f32[0]);
  *(float *)&v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)&v15, v22, 1), *(float *)v13.i32, v22.f32[0]);
  *((float *)v25.f64 + 1) = *(float *)&v16 + *(float *)&v26;
  v27 = vsub_f32(*(float32x2_t *)&v25.f64[0], *(float32x2_t *)&v14.f64[0]);
  CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v62.f64[0], v25, v26, v15, v12, v13, v16, v23);
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v61.f64[0], v28, v29, v30, v31, v32, v33, v34);
  v60 = v35;
  v36 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  v37 = 0uLL;
  v38 = -2;
  LODWORD(v39) = 0;
  v59 = v36;
  do
  {
    for (i = -2; i != 3; ++i)
    {
      v65 = v39;
      v66 = v37;
      v41.f32[0] = (float)v38;
      v41.f32[1] = (float)i;
      v42 = vmul_f32(v36, v41);
      v43 = expf(-(float)((float)((float)(v41.f32[1] * v41.f32[1]) + (float)((float)v38 * (float)v38))
                        * *(float *)&a3.i32[1]));
      *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v62.f64[0], vmul_f32(v24, v42))), v62, v44, v45, v46, v47, v48, v49);
      v64 = v50;
      v57 = vsubq_f32((float32x4_t)vdupq_lane_s32(COERCE_INT32X2_T(CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v61.f64[0], vmul_f32(v27, v42))), v61, v51, v52, v53, v54, v55, v56)), 1), v60).f32[0];
      v58 = expf(*(float *)a3.i32 * (float)((float)-v57 * v57));
      v36 = v59;
      v39 = v65;
      *(float *)&v39 = *(float *)&v65 + (float)(v58 * v43);
      v37 = vaddq_f32(v66, vmulq_n_f32(v64, v43 * v58));
    }
    ++v38;
  }
  while (v38 != 3);
}

void cikernel::_jointBilateralRG(uint64_t a1, int8x16_t a2)
{
  CI *DC;
  float32x2_t v4;
  float32x2_t *v5;
  float v6;
  float v7;
  int8x16_t v8;
  uint8x8_t v9;
  double v10;
  int8x16_t v11;
  float64x2_t v12;
  float32x2_t v18;
  float64x2_t v19;
  double v20;
  float32x2_t v21;
  float32x4_t v22;
  float32x2_t v23;
  float32x2_t v24;
  int v25;
  __int128 v26;
  int i;
  float32x2_t v28;
  float32x2_t v29;
  float v30;
  double v31;
  double v32;
  int8x16_t v33;
  uint8x8_t v34;
  double v35;
  int8x16_t v36;
  int8x16_t v37;
  float v38;
  float32x2_t v39;
  float64x2_t v40;
  float32x4_t v41;
  float32x2_t v43;
  __int128 v44;

  DC = (CI *)CI::getDC((CI *)a1);
  v4 = *(float32x2_t *)DC;
  v5 = (float32x2_t *)CI::getDC(DC);
  v6 = *(float *)(a1 + 16);
  v7 = *(float *)(a1 + 20);
  v8.i32[0] = *(_DWORD *)(a1 + 24);
  v9.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v10) = *(_DWORD *)(a1 + 32);
  v11.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v12.f64 = *(float *)v8.i32 + vmlas_n_f32(vmuls_lane_f32(v7, *v5, 1), v6, COERCE_FLOAT(*v5));
  *((float *)v12.f64 + 1) = *(float *)v11.i32
                          + vmlas_n_f32(vmuls_lane_f32(*(float *)&v10, *v5, 1), *(float *)v9.i32, COERCE_FLOAT(*v5));
  __asm { FMOV            V3.2S, #1.0 }
  v18 = vadd_f32(v4, _D3);
  *(float *)v19.f64 = *(float *)v8.i32 + vmlas_n_f32(vmuls_lane_f32(v7, v18, 1), v6, v18.f32[0]);
  *(float *)&v20 = *(float *)v11.i32 + vmlas_n_f32(vmuls_lane_f32(*(float *)&v10, v18, 1), *(float *)v9.i32, v18.f32[0]);
  HIDWORD(v19.f64[0]) = LODWORD(v20);
  v21 = vsub_f32(*(float32x2_t *)&v19.f64[0], *(float32x2_t *)&v12.f64[0]);
  v40 = v12;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v12.f64[0], v19, v20, *(double *)&v18, v8, v9, v10, v11);
  v41 = v22;
  v23 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  v24 = 0;
  v25 = -2;
  LODWORD(v26) = 0;
  v39 = v23;
  do
  {
    for (i = -2; i != 3; ++i)
    {
      v44 = v26;
      v28.f32[0] = (float)v25;
      v28.f32[1] = (float)i;
      v29 = vmul_f32(v23, v28);
      v30 = expf(-(float)((float)((float)(v28.f32[1] * v28.f32[1]) + (float)((float)v25 * (float)v25))
                        * *(float *)&a2.i32[1]));
      *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v40.f64[0], vmul_f32(v21, v29))), v40, v31, v32, v33, v34, v35, v36);
      v43 = (float32x2_t)vextq_s8(v37, v37, 8uLL).u64[0];
      *(float *)v37.i32 = vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.i8, 1), v41).f32[0];
      v38 = expf(*(float *)a2.i32 * (float)((float)-*(float *)v37.i32 * *(float *)v37.i32));
      v23 = v39;
      v26 = v44;
      *(float *)&v26 = *(float *)&v44 + (float)(v38 * v30);
      v24 = vadd_f32(v24, vmul_n_f32(v43, v30 * v38));
    }
    ++v25;
  }
  while (v25 != 3);
}

double cikernel::_guideCombine(float a1, float a2)
{
  return COERCE_DOUBLE(__PAIR64__(LODWORD(a2), LODWORD(a1)));
}

double cikernel::_guideCombine4(int32x4_t a1, int32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vzip1q_s32(a1, a2).u64[0];
  return result;
}

__n64 cikernel::_guideMono(float32x4_t a1)
{
  float32x4_t v1;
  float v2;
  float v3;
  BOOL v4;
  __n64 result;

  v1 = vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x3EAAA64Cu));
  v2 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1, 2), vaddq_f32(v1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v1.f32, 1))).f32[0];
  if (v2 <= 1.0)
    v3 = v2;
  else
    v3 = 1.0;
  v4 = v2 < 0.0;
  result.n64_u32[0] = 0;
  if (!v4)
    result.n64_f32[0] = v3;
  result.n64_u32[1] = 0;
  return result;
}

double cikernel::_edgeWork(float32x4_t a1, float32x4_t a2)
{
  int32x2_t v2;
  float v3;
  BOOL v4;
  double result;

  v2 = (int32x2_t)vsubq_f32(a1, a2).u64[0];
  *(float *)v2.i32 = 1000.0 * *(float *)v2.i32;
  v3 = 1.0;
  if (*(float *)v2.i32 <= 1.0)
    v3 = *(float *)v2.i32;
  v4 = *(float *)v2.i32 < 0.0;
  v2.i32[0] = 0;
  if (!v4)
    *(float *)v2.i32 = v3;
  *(_QWORD *)&result = vdupq_lane_s32(v2, 0).u64[0];
  return result;
}

double cikernel::_edgeWorkContrast(float32x4_t a1, float a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  double result;

  v2.i64[0] = 0xBF000000BF000000;
  v2.i64[1] = 0xBF000000BF000000;
  v3 = vmulq_n_f32(vaddq_f32(a1, v2), a2);
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  v5 = vaddq_f32(v3, v4);
  v4.i8[3] = 0;
  v4.i8[7] = 0;
  v4.i8[11] = 0;
  v4.i8[15] = 0;
  v6 = vmaxnmq_f32(v5, v4);
  __asm { FMOV            V1.4S, #1.0 }
  *(_QWORD *)&result = vminnmq_f32(v6, _Q1).u64[0];
  return result;
}

double cikernel::_edges(cikernel *this, SamplerObj *a2, float a3)
{
  float32x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  float64x2_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  double v22;
  double v23;
  uint8x8_t v24;
  int8x16_t v25;
  float64x2_t v26;
  double v27;
  int8x16_t v28;
  float32x4_t v29;
  CI *v30;
  float32x2_t *DC;
  double v32;
  double v33;
  uint8x8_t v34;
  int8x16_t v35;
  double v36;
  float64x2_t v37;
  double v38;
  int8x16_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  double result;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;

  v4 = *(float32x2_t *)CI::getDC(this);
  v5 = vadd_f32(v4, (float32x2_t)0xBF80000000000000);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v10, v6, v7, v9, v8, v11, v12);
  v46 = v13;
  *(float32x2_t *)v13.f32 = vadd_f32(v4, (float32x2_t)0xBF8000003F800000);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v15) = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  v45 = v21;
  *(float32x2_t *)v21.f32 = vadd_f32(v4, (float32x2_t)1065353216);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v21.f32, 1), *((float *)this + 4), v21.f32[0]);
  LODWORD(v23) = *((_DWORD *)this + 7);
  v24.i32[0] = *((_DWORD *)this + 9);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v21.f32, 1), *(float *)&v23, v21.f32[0]);
  v21.f32[0] = *((float *)this + 6) + *(float *)&v22;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v21.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v21.i64, v26, v22, v23, v25, v24, v27, v28);
  v44 = v29;
  DC = (float32x2_t *)CI::getDC(v30);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v33) = *((_DWORD *)this + 7);
  v34.i32[0] = *((_DWORD *)this + 9);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v33, COERCE_FLOAT(*DC));
  *(float *)&v36 = *((float *)this + 6) + *(float *)&v32;
  *(float *)v37.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  *((float *)&v36 + 1) = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v36, v37, v32, v33, v35, v34, v38, v39);
  v41 = vsubq_f32(v40, v45);
  v42 = vsubq_f32(v46, v44);
  *(_QWORD *)&result = vmulq_n_f32(vaddq_f32(vmulq_f32(v42, v42), vmulq_f32(v41, v41)), a3).u64[0];
  return result;
}

double cikernel::_gabor(cikernel *this, SamplerObj *a2)
{
  float32x2_t v3;
  float32x2_t v4;
  double v5;
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  float64x2_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  double v13;
  double v14;
  uint8x8_t v15;
  int8x16_t v16;
  float64x2_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  double v21;
  double v22;
  uint8x8_t v23;
  int8x16_t v24;
  float64x2_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  double v29;
  double v30;
  uint8x8_t v31;
  int8x16_t v32;
  float64x2_t v33;
  double v34;
  int8x16_t v35;
  float32x4_t v36;
  double v37;
  double v38;
  uint8x8_t v39;
  int8x16_t v40;
  float64x2_t v41;
  double v42;
  int8x16_t v43;
  float32x4_t v44;
  double v45;
  double v46;
  uint8x8_t v47;
  int8x16_t v48;
  float64x2_t v49;
  double v50;
  int8x16_t v51;
  double v57;
  double v58;
  uint8x8_t v59;
  int8x16_t v60;
  float64x2_t v61;
  double v62;
  int8x16_t v63;
  float32x4_t v64;
  double v65;
  double v66;
  uint8x8_t v67;
  int8x16_t v68;
  float64x2_t v69;
  double v70;
  int8x16_t v71;
  float32x4_t v72;
  double v73;
  double v74;
  uint8x8_t v75;
  int8x16_t v76;
  float64x2_t v77;
  double v78;
  int8x16_t v79;
  float32x4_t v80;
  double v81;
  double v82;
  uint8x8_t v83;
  int8x16_t v84;
  float64x2_t v85;
  double v86;
  int8x16_t v87;
  float32x4_t v88;
  double v89;
  double v90;
  uint8x8_t v91;
  int8x16_t v92;
  float64x2_t v93;
  double v94;
  int8x16_t v95;
  float32x4_t v96;
  double v97;
  double v98;
  uint8x8_t v99;
  int8x16_t v100;
  float64x2_t v101;
  double v102;
  int8x16_t v103;
  float32x4_t v104;
  double v105;
  double v106;
  uint8x8_t v107;
  int8x16_t v108;
  float64x2_t v109;
  double v110;
  int8x16_t v111;
  double v113;
  double v114;
  uint8x8_t v115;
  int8x16_t v116;
  float64x2_t v117;
  double v118;
  int8x16_t v119;
  float32x4_t v120;
  double v121;
  double v122;
  uint8x8_t v123;
  int8x16_t v124;
  float64x2_t v125;
  double v126;
  int8x16_t v127;
  float32x4_t v128;
  double v129;
  double v130;
  uint8x8_t v131;
  int8x16_t v132;
  float64x2_t v133;
  double v134;
  int8x16_t v135;
  float32x4_t v136;
  double v137;
  double v138;
  uint8x8_t v139;
  int8x16_t v140;
  float64x2_t v141;
  double v142;
  int8x16_t v143;
  float32x4_t v144;
  double v145;
  double v146;
  uint8x8_t v147;
  int8x16_t v148;
  float64x2_t v149;
  double v150;
  int8x16_t v151;
  float32x4_t v152;
  double v153;
  double v154;
  uint8x8_t v155;
  int8x16_t v156;
  float64x2_t v157;
  double v158;
  int8x16_t v159;
  float32x4_t v160;
  double v161;
  double v162;
  uint8x8_t v163;
  int8x16_t v164;
  float64x2_t v165;
  double v166;
  int8x16_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  int8x16_t v184;
  int8x16_t v185;
  int8x16_t v186;
  int8x16_t v187;
  int8x16_t v188;
  double result;
  float32x4_t v190;
  float32x4_t v191;
  float32x4_t v192;
  float32x4_t v193;
  float32x4_t v194;
  float32x4_t v195;
  float32x4_t v196;
  float32x4_t v197;
  float32x4_t v198;
  float32x4_t v199;
  float32x4_t v200;
  float32x4_t v201;
  float32x4_t v202;
  float32x4_t v203;
  float32x4_t v204;
  float32x4_t v205;
  float32x4_t v206;
  float32x4_t v207;
  float32x4_t v208;

  v3 = *(float32x2_t *)CI::getDC(this);
  v4 = vadd_f32(v3, (float32x2_t)0x40000000BF800000);
  *(float *)&v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v9, v5, v6, v8, v7, v10, v11);
  v208 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(v3, (float32x2_t)0x40400000BF800000);
  *(float *)&v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v12.f32, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, v17, v13, v14, v16, v15, v18, v19);
  v207 = v20;
  *(float32x2_t *)v20.f32 = vadd_f32(v3, (float32x2_t)0x400000003F800000);
  *(float *)&v21 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v20.f32, 1), *((float *)this + 4), v20.f32[0]);
  LODWORD(v22) = *((_DWORD *)this + 7);
  v23.i32[0] = *((_DWORD *)this + 9);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v20.f32, 1), *(float *)&v22, v20.f32[0]);
  v20.f32[0] = *((float *)this + 6) + *(float *)&v21;
  *(float *)v25.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v20.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v20.i64, v25, v21, v22, v24, v23, v26, v27);
  v206 = v28;
  *(float32x2_t *)v28.f32 = vadd_f32(v3, (float32x2_t)0x3F800000C0000000);
  *(float *)&v29 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v28.f32, 1), *((float *)this + 4), v28.f32[0]);
  LODWORD(v30) = *((_DWORD *)this + 7);
  v31.i32[0] = *((_DWORD *)this + 9);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v28.f32, 1), *(float *)&v30, v28.f32[0]);
  v28.f32[0] = *((float *)this + 6) + *(float *)&v29;
  *(float *)v33.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v28.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v28.i64, v33, v29, v30, v32, v31, v34, v35);
  v205 = v36;
  *(float32x2_t *)v36.f32 = vadd_f32(v3, (float32x2_t)0x3F800000BF800000);
  *(float *)&v37 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v36.f32, 1), *((float *)this + 4), v36.f32[0]);
  LODWORD(v38) = *((_DWORD *)this + 7);
  v39.i32[0] = *((_DWORD *)this + 9);
  *(float *)v40.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v36.f32, 1), *(float *)&v38, v36.f32[0]);
  v36.f32[0] = *((float *)this + 6) + *(float *)&v37;
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)v40.i32;
  v36.f32[1] = *(float *)v39.i32 + *(float *)v40.i32;
  *(double *)v44.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v36.i64, v41, v37, v38, v40, v39, v42, v43);
  v204 = v44;
  *(float32x2_t *)v44.f32 = vadd_f32(v3, (float32x2_t)0x3F80000000000000);
  *(float *)&v45 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v44.f32, 1), *((float *)this + 4), v44.f32[0]);
  LODWORD(v46) = *((_DWORD *)this + 7);
  v47.i32[0] = *((_DWORD *)this + 9);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v44.f32, 1), *(float *)&v46, v44.f32[0]);
  v44.f32[0] = *((float *)this + 6) + *(float *)&v45;
  *(float *)v49.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  v44.f32[1] = *(float *)v47.i32 + *(float *)v48.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v44.i64, v49, v45, v46, v48, v47, v50, v51);
  v203 = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  *(float32x2_t *)_Q0.f32 = vadd_f32(v3, *(float32x2_t *)_Q0.f32);
  *(float *)&v57 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v58) = *((_DWORD *)this + 7);
  v59.i32[0] = *((_DWORD *)this + 9);
  *(float *)v60.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v58, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v57;
  *(float *)v61.f64 = *(float *)v59.i32 + *(float *)v60.i32;
  _Q0.f32[1] = *(float *)v59.i32 + *(float *)v60.i32;
  *(double *)v64.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v61, v57, v58, v60, v59, v62, v63);
  v202 = v64;
  *(float32x2_t *)v64.f32 = vadd_f32(v3, (float32x2_t)0x3F80000040000000);
  *(float *)&v65 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v64.f32, 1), *((float *)this + 4), v64.f32[0]);
  LODWORD(v66) = *((_DWORD *)this + 7);
  v67.i32[0] = *((_DWORD *)this + 9);
  *(float *)v68.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v64.f32, 1), *(float *)&v66, v64.f32[0]);
  v64.f32[0] = *((float *)this + 6) + *(float *)&v65;
  *(float *)v69.f64 = *(float *)v67.i32 + *(float *)v68.i32;
  v64.f32[1] = *(float *)v67.i32 + *(float *)v68.i32;
  *(double *)v72.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v64.i64, v69, v65, v66, v68, v67, v70, v71);
  v201 = v72;
  *(float32x2_t *)v72.f32 = vadd_f32(v3, (float32x2_t)3221225472);
  *(float *)&v73 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v72.f32, 1), *((float *)this + 4), v72.f32[0]);
  LODWORD(v74) = *((_DWORD *)this + 7);
  v75.i32[0] = *((_DWORD *)this + 9);
  *(float *)v76.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v72.f32, 1), *(float *)&v74, v72.f32[0]);
  v72.f32[0] = *((float *)this + 6) + *(float *)&v73;
  *(float *)v77.f64 = *(float *)v75.i32 + *(float *)v76.i32;
  v72.f32[1] = *(float *)v75.i32 + *(float *)v76.i32;
  *(double *)v80.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v72.i64, v77, v73, v74, v76, v75, v78, v79);
  v200 = v80;
  *(float32x2_t *)v80.f32 = vadd_f32(v3, (float32x2_t)3212836864);
  *(float *)&v81 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v80.f32, 1), *((float *)this + 4), v80.f32[0]);
  LODWORD(v82) = *((_DWORD *)this + 7);
  v83.i32[0] = *((_DWORD *)this + 9);
  *(float *)v84.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v80.f32, 1), *(float *)&v82, v80.f32[0]);
  v80.f32[0] = *((float *)this + 6) + *(float *)&v81;
  *(float *)v85.f64 = *(float *)v83.i32 + *(float *)v84.i32;
  v80.f32[1] = *(float *)v83.i32 + *(float *)v84.i32;
  *(double *)v88.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v80.i64, v85, v81, v82, v84, v83, v86, v87);
  v199 = v88;
  *(float32x2_t *)v88.f32 = vadd_f32(v3, (float32x2_t)1065353216);
  *(float *)&v89 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v88.f32, 1), *((float *)this + 4), v88.f32[0]);
  LODWORD(v90) = *((_DWORD *)this + 7);
  v91.i32[0] = *((_DWORD *)this + 9);
  *(float *)v92.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v88.f32, 1), *(float *)&v90, v88.f32[0]);
  v88.f32[0] = *((float *)this + 6) + *(float *)&v89;
  *(float *)v93.f64 = *(float *)v91.i32 + *(float *)v92.i32;
  v88.f32[1] = *(float *)v91.i32 + *(float *)v92.i32;
  *(double *)v96.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v88.i64, v93, v89, v90, v92, v91, v94, v95);
  v198 = v96;
  *(float32x2_t *)v96.f32 = vadd_f32(v3, (float32x2_t)0x40000000);
  *(float *)&v97 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v96.f32, 1), *((float *)this + 4), v96.f32[0]);
  LODWORD(v98) = *((_DWORD *)this + 7);
  v99.i32[0] = *((_DWORD *)this + 9);
  *(float *)v100.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v96.f32, 1), *(float *)&v98, v96.f32[0]);
  v96.f32[0] = *((float *)this + 6) + *(float *)&v97;
  *(float *)v101.f64 = *(float *)v99.i32 + *(float *)v100.i32;
  v96.f32[1] = *(float *)v99.i32 + *(float *)v100.i32;
  *(double *)v104.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v96.i64, v101, v97, v98, v100, v99, v102, v103);
  v197 = v104;
  *(float32x2_t *)v104.f32 = vadd_f32(v3, (float32x2_t)0xBF800000C0000000);
  *(float *)&v105 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v104.f32, 1), *((float *)this + 4), v104.f32[0]);
  LODWORD(v106) = *((_DWORD *)this + 7);
  v107.i32[0] = *((_DWORD *)this + 9);
  *(float *)v108.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v104.f32, 1), *(float *)&v106, v104.f32[0]);
  v104.f32[0] = *((float *)this + 6) + *(float *)&v105;
  *(float *)v109.f64 = *(float *)v107.i32 + *(float *)v108.i32;
  v104.f32[1] = *(float *)v107.i32 + *(float *)v108.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v104.i64, v109, v105, v106, v108, v107, v110, v111);
  v196 = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  *(float32x2_t *)_Q0.f32 = vadd_f32(v3, *(float32x2_t *)_Q0.f32);
  *(float *)&v113 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v114) = *((_DWORD *)this + 7);
  v115.i32[0] = *((_DWORD *)this + 9);
  *(float *)v116.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v114, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v113;
  *(float *)v117.f64 = *(float *)v115.i32 + *(float *)v116.i32;
  _Q0.f32[1] = *(float *)v115.i32 + *(float *)v116.i32;
  *(double *)v120.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v117, v113, v114, v116, v115, v118, v119);
  v195 = v120;
  *(float32x2_t *)v120.f32 = vadd_f32(v3, (float32x2_t)0xBF80000000000000);
  *(float *)&v121 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v120.f32, 1), *((float *)this + 4), v120.f32[0]);
  LODWORD(v122) = *((_DWORD *)this + 7);
  v123.i32[0] = *((_DWORD *)this + 9);
  *(float *)v124.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v120.f32, 1), *(float *)&v122, v120.f32[0]);
  v120.f32[0] = *((float *)this + 6) + *(float *)&v121;
  *(float *)v125.f64 = *(float *)v123.i32 + *(float *)v124.i32;
  v120.f32[1] = *(float *)v123.i32 + *(float *)v124.i32;
  *(double *)v128.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v120.i64, v125, v121, v122, v124, v123, v126, v127);
  v194 = v128;
  *(float32x2_t *)v128.f32 = vadd_f32(v3, (float32x2_t)0xBF8000003F800000);
  *(float *)&v129 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v128.f32, 1), *((float *)this + 4), v128.f32[0]);
  LODWORD(v130) = *((_DWORD *)this + 7);
  v131.i32[0] = *((_DWORD *)this + 9);
  *(float *)v132.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v128.f32, 1), *(float *)&v130, v128.f32[0]);
  v128.f32[0] = *((float *)this + 6) + *(float *)&v129;
  *(float *)v133.f64 = *(float *)v131.i32 + *(float *)v132.i32;
  v128.f32[1] = *(float *)v131.i32 + *(float *)v132.i32;
  *(double *)v136.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v128.i64, v133, v129, v130, v132, v131, v134, v135);
  v193 = v136;
  *(float32x2_t *)v136.f32 = vadd_f32(v3, (float32x2_t)0xBF80000040000000);
  *(float *)&v137 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v136.f32, 1), *((float *)this + 4), v136.f32[0]);
  LODWORD(v138) = *((_DWORD *)this + 7);
  v139.i32[0] = *((_DWORD *)this + 9);
  *(float *)v140.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v136.f32, 1), *(float *)&v138, v136.f32[0]);
  v136.f32[0] = *((float *)this + 6) + *(float *)&v137;
  *(float *)v141.f64 = *(float *)v139.i32 + *(float *)v140.i32;
  v136.f32[1] = *(float *)v139.i32 + *(float *)v140.i32;
  *(double *)v144.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v136.i64, v141, v137, v138, v140, v139, v142, v143);
  v192 = v144;
  *(float32x2_t *)v144.f32 = vadd_f32(v3, (float32x2_t)0xC0000000BF800000);
  *(float *)&v145 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v144.f32, 1), *((float *)this + 4), v144.f32[0]);
  LODWORD(v146) = *((_DWORD *)this + 7);
  v147.i32[0] = *((_DWORD *)this + 9);
  *(float *)v148.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v144.f32, 1), *(float *)&v146, v144.f32[0]);
  v144.f32[0] = *((float *)this + 6) + *(float *)&v145;
  *(float *)v149.f64 = *(float *)v147.i32 + *(float *)v148.i32;
  v144.f32[1] = *(float *)v147.i32 + *(float *)v148.i32;
  *(double *)v152.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v144.i64, v149, v145, v146, v148, v147, v150, v151);
  v191 = v152;
  *(float32x2_t *)v152.f32 = vadd_f32(v3, (float32x2_t)0xC0400000BF800000);
  *(float *)&v153 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v152.f32, 1), *((float *)this + 4), v152.f32[0]);
  LODWORD(v154) = *((_DWORD *)this + 7);
  v155.i32[0] = *((_DWORD *)this + 9);
  *(float *)v156.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v152.f32, 1), *(float *)&v154, v152.f32[0]);
  v152.f32[0] = *((float *)this + 6) + *(float *)&v153;
  *(float *)v157.f64 = *(float *)v155.i32 + *(float *)v156.i32;
  v152.f32[1] = *(float *)v155.i32 + *(float *)v156.i32;
  *(double *)v160.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v152.i64, v157, v153, v154, v156, v155, v158, v159);
  v190 = v160;
  *(float32x2_t *)v160.f32 = vadd_f32(v3, (float32x2_t)0xC00000003F800000);
  *(float *)&v161 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v160.f32, 1), *((float *)this + 4), v160.f32[0]);
  LODWORD(v162) = *((_DWORD *)this + 7);
  v163.i32[0] = *((_DWORD *)this + 9);
  *(float *)v164.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v160.f32, 1), *(float *)&v162, v160.f32[0]);
  v160.f32[0] = *((float *)this + 6) + *(float *)&v161;
  *(float *)v165.f64 = *(float *)v163.i32 + *(float *)v164.i32;
  v160.f32[1] = *(float *)v163.i32 + *(float *)v164.i32;
  *(double *)v168.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v160.i64, v165, v161, v162, v164, v163, v166, v167);
  v169 = vsubq_f32(v208, v168);
  v170 = vsubq_f32(v206, v191);
  v171 = vsubq_f32(v205, v192);
  v172 = vsubq_f32(v204, v193);
  v173 = vsubq_f32(v202, v195);
  v174 = vsubq_f32(v201, v196);
  v175 = (float32x4_t)vdupq_n_s32(0x3F0B7176u);
  v176 = (float32x4_t)vdupq_n_s32(0x3E34A234u);
  v177 = (float32x4_t)vdupq_n_s32(0x3C1374BCu);
  v178 = (float32x4_t)vdupq_n_s32(0x3D3645A2u);
  v179 = (float32x4_t)vdupq_n_s32(0x3C9374BCu);
  v180 = vaddq_f32(vmulq_f32(vsubq_f32(v174, v171), v179), vsubq_f32(vaddq_f32(vsubq_f32(vmulq_f32(vsubq_f32(v173, v172), v176), vmulq_f32(vsubq_f32(v199, v198), v175)), vmulq_f32(vsubq_f32(v170, v169), v177)), vmulq_f32(vsubq_f32(v200, v197), v178)));
  v181 = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_f32(vsubq_f32(v203, v194), v175), vmulq_f32(vaddq_f32(v173, v172), v176)), vmulq_f32(vaddq_f32(v174, v171), v177)), vmulq_f32(vsubq_f32(v207, v190), v178)), vmulq_f32(vaddq_f32(v170, v169), v179));
  v183.i64[1] = 0x3F80000000000000;
  v172.i64[1] = 0x3F80000000000000;
  v172.i64[0] = __PAIR64__(v181.u32[0], v180.u32[0]);
  v182 = vaddq_f32(vmulq_f32(v181, v181), vmulq_f32(v180, v180));
  v183.i64[0] = __PAIR64__(v181.u32[1], v180.u32[1]);
  v184 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v182.f32, 1), v182), 0), (int8x16_t)v183, (int8x16_t)v172);
  if (v182.f32[1] <= v182.f32[0])
    v183.f32[0] = v182.f32[0];
  else
    v183.f32[0] = v182.f32[1];
  v185.i64[1] = v184.i64[1];
  v185.i64[0] = __PAIR64__(v181.u32[2], v180.u32[2]);
  v186 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v182, 2), v183), 0), v185, v184);
  if (v182.f32[2] > v183.f32[0])
    v183.f32[0] = v182.f32[2];
  v187 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v182, 3), v183), 0);
  v188.i64[1] = v186.i64[1];
  v188.i64[0] = __PAIR64__(v181.u32[3], v180.u32[3]);
  *(_QWORD *)&result = vbslq_s8(v187, v188, v186).u64[0];
  return result;
}

double cikernel::_sobel(cikernel *this, SamplerObj *a2)
{
  float32x2_t v3;
  float32x2_t v4;
  double v5;
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  float64x2_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  double v13;
  double v14;
  uint8x8_t v15;
  int8x16_t v16;
  float64x2_t v17;
  double v18;
  int8x16_t v19;
  double v25;
  double v26;
  uint8x8_t v27;
  int8x16_t v28;
  float64x2_t v29;
  double v30;
  int8x16_t v31;
  float32x4_t v32;
  double v33;
  double v34;
  uint8x8_t v35;
  int8x16_t v36;
  float64x2_t v37;
  double v38;
  int8x16_t v39;
  float32x4_t v40;
  double v41;
  double v42;
  uint8x8_t v43;
  int8x16_t v44;
  float64x2_t v45;
  double v46;
  int8x16_t v47;
  double v49;
  double v50;
  uint8x8_t v51;
  int8x16_t v52;
  float64x2_t v53;
  double v54;
  int8x16_t v55;
  float32x4_t v56;
  double v57;
  double v58;
  uint8x8_t v59;
  int8x16_t v60;
  float64x2_t v61;
  double v62;
  int8x16_t v63;
  float32x4_t v64;
  double v65;
  double v66;
  uint8x8_t v67;
  int8x16_t v68;
  float64x2_t v69;
  double v70;
  int8x16_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  int8x16_t v75;
  float32x4_t v76;
  float32x4_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int8x16_t v81;
  int8x16_t v82;
  double result;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;

  v3 = *(float32x2_t *)CI::getDC(this);
  v4 = vadd_f32(v3, (float32x2_t)0x3F800000BF800000);
  *(float *)&v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v9, v5, v6, v8, v7, v10, v11);
  v90 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(v3, (float32x2_t)0x3F80000000000000);
  *(float *)&v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v12.f32, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, v17, v13, v14, v16, v15, v18, v19);
  v89 = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  *(float32x2_t *)_Q0.f32 = vadd_f32(v3, *(float32x2_t *)_Q0.f32);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v26) = *((_DWORD *)this + 7);
  v27.i32[0] = *((_DWORD *)this + 9);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v26, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v25;
  *(float *)v29.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  _Q0.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v29, v25, v26, v28, v27, v30, v31);
  v88 = v32;
  *(float32x2_t *)v32.f32 = vadd_f32(v3, (float32x2_t)3212836864);
  *(float *)&v33 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v32.f32, 1), *((float *)this + 4), v32.f32[0]);
  LODWORD(v34) = *((_DWORD *)this + 7);
  v35.i32[0] = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v32.f32, 1), *(float *)&v34, v32.f32[0]);
  v32.f32[0] = *((float *)this + 6) + *(float *)&v33;
  *(float *)v37.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  v32.f32[1] = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v32.i64, v37, v33, v34, v36, v35, v38, v39);
  v87 = v40;
  *(float32x2_t *)v40.f32 = vadd_f32(v3, (float32x2_t)1065353216);
  *(float *)&v41 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v40.f32, 1), *((float *)this + 4), v40.f32[0]);
  LODWORD(v42) = *((_DWORD *)this + 7);
  v43.i32[0] = *((_DWORD *)this + 9);
  *(float *)v44.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v40.f32, 1), *(float *)&v42, v40.f32[0]);
  v40.f32[0] = *((float *)this + 6) + *(float *)&v41;
  *(float *)v45.f64 = *(float *)v43.i32 + *(float *)v44.i32;
  v40.f32[1] = *(float *)v43.i32 + *(float *)v44.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v40.i64, v45, v41, v42, v44, v43, v46, v47);
  v86 = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  *(float32x2_t *)_Q0.f32 = vadd_f32(v3, *(float32x2_t *)_Q0.f32);
  *(float *)&v49 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v50) = *((_DWORD *)this + 7);
  v51.i32[0] = *((_DWORD *)this + 9);
  *(float *)v52.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v50, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v49;
  *(float *)v53.f64 = *(float *)v51.i32 + *(float *)v52.i32;
  _Q0.f32[1] = *(float *)v51.i32 + *(float *)v52.i32;
  *(double *)v56.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v53, v49, v50, v52, v51, v54, v55);
  v85 = v56;
  *(float32x2_t *)v56.f32 = vadd_f32(v3, (float32x2_t)0xBF80000000000000);
  *(float *)&v57 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v56.f32, 1), *((float *)this + 4), v56.f32[0]);
  LODWORD(v58) = *((_DWORD *)this + 7);
  v59.i32[0] = *((_DWORD *)this + 9);
  *(float *)v60.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v56.f32, 1), *(float *)&v58, v56.f32[0]);
  v56.f32[0] = *((float *)this + 6) + *(float *)&v57;
  *(float *)v61.f64 = *(float *)v59.i32 + *(float *)v60.i32;
  v56.f32[1] = *(float *)v59.i32 + *(float *)v60.i32;
  *(double *)v64.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v56.i64, v61, v57, v58, v60, v59, v62, v63);
  v84 = v64;
  *(float32x2_t *)v64.f32 = vadd_f32(v3, (float32x2_t)0xBF8000003F800000);
  *(float *)&v65 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v64.f32, 1), *((float *)this + 4), v64.f32[0]);
  LODWORD(v66) = *((_DWORD *)this + 7);
  v67.i32[0] = *((_DWORD *)this + 9);
  *(float *)v68.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v64.f32, 1), *(float *)&v66, v64.f32[0]);
  v64.f32[0] = *((float *)this + 6) + *(float *)&v65;
  *(float *)v69.f64 = *(float *)v67.i32 + *(float *)v68.i32;
  v64.f32[1] = *(float *)v67.i32 + *(float *)v68.i32;
  *(double *)v72.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v64.i64, v69, v65, v66, v68, v67, v70, v71);
  v73 = vsubq_f32(vaddq_f32(vaddq_f32(v88, vaddq_f32(v86, v86)), v72), vaddq_f32(vaddq_f32(v90, vaddq_f32(v87, v87)), v85));
  v74 = vsubq_f32(vaddq_f32(vaddq_f32(v90, vaddq_f32(v89, v89)), v88), vaddq_f32(vaddq_f32(v85, vaddq_f32(v84, v84)), v72));
  v77.i64[1] = 0x3F80000000000000;
  v75.i64[1] = 0x3F80000000000000;
  v75.i64[0] = __PAIR64__(v74.u32[0], v73.u32[0]);
  v76 = vaddq_f32(vmulq_f32(v74, v74), vmulq_f32(v73, v73));
  v77.i64[0] = __PAIR64__(v74.u32[1], v73.u32[1]);
  v78 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v76.f32, 1), v76), 0), (int8x16_t)v77, v75);
  if (v76.f32[1] <= v76.f32[0])
    v77.f32[0] = v76.f32[0];
  else
    v77.f32[0] = v76.f32[1];
  v79.i64[1] = v78.i64[1];
  v79.i64[0] = __PAIR64__(v74.u32[2], v73.u32[2]);
  v80 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 2), v77), 0), v79, v78);
  if (v76.f32[2] > v77.f32[0])
    v77.f32[0] = v76.f32[2];
  v81 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v76, 3), v77), 0);
  v82.i64[1] = v80.i64[1];
  v82.i64[0] = __PAIR64__(v74.u32[3], v73.u32[3]);
  *(_QWORD *)&result = vbslq_s8(v81, v82, v80).u64[0];
  return result;
}

void cikernel::_sobel_m(cikernel *this, SamplerObj *a2)
{
  float32x2_t v3;
  float32x2_t v4;
  double v5;
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  float64x2_t v9;
  double v10;
  int8x16_t v11;
  float32x2_t v12;
  double v13;
  double v14;
  uint8x8_t v15;
  int8x16_t v16;
  float64x2_t v17;
  double v18;
  int8x16_t v19;
  float32x2_t v25;
  double v26;
  double v27;
  uint8x8_t v28;
  int8x16_t v29;
  float64x2_t v30;
  double v31;
  int8x16_t v32;
  float32x2_t v33;
  double v34;
  double v35;
  uint8x8_t v36;
  int8x16_t v37;
  float64x2_t v38;
  double v39;
  int8x16_t v40;
  float32x2_t v41;
  double v42;
  double v43;
  uint8x8_t v44;
  int8x16_t v45;
  float64x2_t v46;
  double v47;
  int8x16_t v48;
  float32x2_t v50;
  double v51;
  double v52;
  uint8x8_t v53;
  int8x16_t v54;
  float64x2_t v55;
  double v56;
  int8x16_t v57;
  float32x2_t v58;
  double v59;
  double v60;
  uint8x8_t v61;
  int8x16_t v62;
  float64x2_t v63;
  double v64;
  int8x16_t v65;
  float32x2_t v66;
  double v67;
  double v68;
  uint8x8_t v69;
  int8x16_t v70;
  float64x2_t v71;
  double v72;
  int8x16_t v73;

  v3 = *(float32x2_t *)CI::getDC(this);
  v4 = vadd_f32(v3, (float32x2_t)0x3F800000BF800000);
  *(float *)&v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v9, v5, v6, v8, v7, v10, v11);
  v12 = vadd_f32(v3, (float32x2_t)0x3F80000000000000);
  *(float *)&v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v12, 1), *((float *)this + 4), v12.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v12, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v12, v17, v13, v14, v16, v15, v18, v19);
  __asm { FMOV            V0.2S, #1.0 }
  v25 = vadd_f32(v3, _D0);
  *(float *)&v26 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v25, 1), *((float *)this + 4), v25.f32[0]);
  LODWORD(v27) = *((_DWORD *)this + 7);
  v28.i32[0] = *((_DWORD *)this + 9);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v25, 1), *(float *)&v27, v25.f32[0]);
  v25.f32[0] = *((float *)this + 6) + *(float *)&v26;
  *(float *)v30.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  v25.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v25, v30, v26, v27, v29, v28, v31, v32);
  v33 = vadd_f32(v3, (float32x2_t)3212836864);
  *(float *)&v34 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v33, 1), *((float *)this + 4), v33.f32[0]);
  LODWORD(v35) = *((_DWORD *)this + 7);
  v36.i32[0] = *((_DWORD *)this + 9);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v33, 1), *(float *)&v35, v33.f32[0]);
  v33.f32[0] = *((float *)this + 6) + *(float *)&v34;
  *(float *)v38.f64 = *(float *)v36.i32 + *(float *)v37.i32;
  v33.f32[1] = *(float *)v36.i32 + *(float *)v37.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v33, v38, v34, v35, v37, v36, v39, v40);
  v41 = vadd_f32(v3, (float32x2_t)1065353216);
  *(float *)&v42 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v41, 1), *((float *)this + 4), v41.f32[0]);
  LODWORD(v43) = *((_DWORD *)this + 7);
  v44.i32[0] = *((_DWORD *)this + 9);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v41, 1), *(float *)&v43, v41.f32[0]);
  v41.f32[0] = *((float *)this + 6) + *(float *)&v42;
  *(float *)v46.f64 = *(float *)v44.i32 + *(float *)v45.i32;
  v41.f32[1] = *(float *)v44.i32 + *(float *)v45.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v41, v46, v42, v43, v45, v44, v47, v48);
  __asm { FMOV            V0.2S, #-1.0 }
  v50 = vadd_f32(v3, _D0);
  *(float *)&v51 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v50, 1), *((float *)this + 4), v50.f32[0]);
  LODWORD(v52) = *((_DWORD *)this + 7);
  v53.i32[0] = *((_DWORD *)this + 9);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v50, 1), *(float *)&v52, v50.f32[0]);
  v50.f32[0] = *((float *)this + 6) + *(float *)&v51;
  *(float *)v55.f64 = *(float *)v53.i32 + *(float *)v54.i32;
  v50.f32[1] = *(float *)v53.i32 + *(float *)v54.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v50, v55, v51, v52, v54, v53, v56, v57);
  v58 = vadd_f32(v3, (float32x2_t)0xBF80000000000000);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v58, 1), *((float *)this + 4), v58.f32[0]);
  LODWORD(v60) = *((_DWORD *)this + 7);
  v61.i32[0] = *((_DWORD *)this + 9);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v58, 1), *(float *)&v60, v58.f32[0]);
  v58.f32[0] = *((float *)this + 6) + *(float *)&v59;
  *(float *)v63.f64 = *(float *)v61.i32 + *(float *)v62.i32;
  v58.f32[1] = *(float *)v61.i32 + *(float *)v62.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v58, v63, v59, v60, v62, v61, v64, v65);
  v66 = vadd_f32(v3, (float32x2_t)0xBF8000003F800000);
  *(float *)&v67 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v66, 1), *((float *)this + 4), v66.f32[0]);
  LODWORD(v68) = *((_DWORD *)this + 7);
  v69.i32[0] = *((_DWORD *)this + 9);
  *(float *)v70.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v66, 1), *(float *)&v68, v66.f32[0]);
  v66.f32[0] = *((float *)this + 6) + *(float *)&v67;
  *(float *)v71.f64 = *(float *)v69.i32 + *(float *)v70.i32;
  v66.f32[1] = *(float *)v69.i32 + *(float *)v70.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v66, v71, v67, v68, v70, v69, v72, v73);
}

void cikernel::_maxGradOnly(cikernel *this, SamplerObj *a2)
{
  CI *DC;
  float32x2_t v4;
  float32x2_t *v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  float64x2_t v11;
  double v12;
  int8x16_t v13;
  int8x16_t v14;
  float64x2_t v15;
  uint8x8_t v16;
  double v17;
  int8x16_t v18;
  int32x2_t v19;
  double v20;
  int8x16_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  double v26;
  double v27;
  uint8x8_t v28;
  int8x16_t v29;
  float64x2_t v30;
  double v31;
  int8x16_t v32;

  DC = (CI *)CI::getDC(this);
  v4 = *(float32x2_t *)DC;
  v5 = (float32x2_t *)CI::getDC(DC);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *v5, 1), *((float *)this + 4), COERCE_FLOAT(*v5));
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *v5, 1), *(float *)&v7, COERCE_FLOAT(*v5));
  *(float *)&v10 = *((float *)this + 6) + *(float *)&v6;
  *(float *)v11.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  *((float *)&v10 + 1) = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v10, v11, v6, v7, v9, v8, v12, v13);
  if (*(float *)&v14.i32[2] >= 0.0001)
  {
    v19 = (int32x2_t)vmul_f32(*(float32x2_t *)v14.i8, *(float32x2_t *)v14.i8);
    *(_QWORD *)&v20 = vadd_f32((float32x2_t)v19, (float32x2_t)vdup_lane_s32(v19, 1)).u32[0];
    *(float32x2_t *)&v15.f64[0] = vrsqrte_f32((float32x2_t)LODWORD(v20));
    v21 = v14;
    v22 = vmul_f32(*(float32x2_t *)&v15.f64[0], *(float32x2_t *)&v15.f64[0]);
    v23 = vmul_n_f32(*(float32x2_t *)v14.i8, vmul_f32(*(float32x2_t *)&v15.f64[0], vrsqrts_f32((float32x2_t)LODWORD(v20), v22)).f32[0]);
    v24 = vadd_f32(v4, v23);
    v22.f32[0] = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v24, 1), *((float *)this + 4), v24.f32[0]);
    LODWORD(v20) = *((_DWORD *)this + 7);
    v16.i32[0] = *((_DWORD *)this + 9);
    *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v24, 1), *(float *)&v20, v24.f32[0]);
    v24.f32[0] = *((float *)this + 6) + v22.f32[0];
    *(float *)v15.f64 = *(float *)v16.i32 + *(float *)v21.i32;
    v24.f32[1] = *(float *)v16.i32 + *(float *)v21.i32;
    CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v24, v15, *(double *)&v22, v20, v21, v16, v17, v18);
    v25 = vsub_f32(v4, v23);
    *(float *)&v26 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v25, 1), *((float *)this + 4), v25.f32[0]);
    LODWORD(v27) = *((_DWORD *)this + 7);
    v28.i32[0] = *((_DWORD *)this + 9);
    *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v25, 1), *(float *)&v27, v25.f32[0]);
    v25.f32[0] = *((float *)this + 6) + *(float *)&v26;
    *(float *)v30.f64 = *(float *)v28.i32 + *(float *)v29.i32;
    v25.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
    CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v25, v30, v26, v27, v29, v28, v31, v32);
  }
}

double cikernel::_cannyThreshold(int32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  float32x4_t v3;
  double result;

  a2.f32[0] = a2.f32[0] * a2.f32[0];
  v3 = (float32x4_t)vdupq_laneq_s32(a1, 2);
  a3.f32[0] = a3.f32[0] * a3.f32[0];
  *(_QWORD *)&result = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v3, a2)), 0), vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v3, a3)), 0), (int8x16_t)xmmword_19248E050, (int8x16_t)xmmword_1924947B0), (int8x16_t)xmmword_1924947C0).u64[0];
  return result;
}

void cikernel::_cannyHysteresis(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  double v4;
  double v5;
  uint8x8_t v6;
  int8x16_t v7;
  double v8;
  float64x2_t v9;
  double v10;
  int8x16_t v11;
  CI *v12;
  double v13;
  float64x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  double v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  float64x2_t v21;
  double v22;
  int8x16_t v23;
  double v24;
  double v25;
  double v26;
  int8x16_t v27;
  uint8x8_t v28;
  double v29;
  int8x16_t v30;
  float64x2_t v31;
  float32x2_t v32;
  double v33;
  double v34;
  double v35;
  int8x16_t v36;
  uint8x8_t v37;
  double v38;
  int8x16_t v39;
  float64x2_t v40;
  float32x2_t v41;
  double v42;
  double v43;
  double v44;
  int8x16_t v45;
  uint8x8_t v46;
  double v47;
  int8x16_t v48;
  float64x2_t v49;
  float32x2_t v50;
  double v51;
  double v52;
  double v53;
  int8x16_t v54;
  uint8x8_t v55;
  double v56;
  int8x16_t v57;
  float64x2_t v58;
  double v64;
  double v65;
  double v66;
  int8x16_t v67;
  uint8x8_t v68;
  double v69;
  int8x16_t v70;
  float64x2_t v71;
  double v72;
  double v73;
  double v74;
  double v75;
  int8x16_t v76;
  double v77;
  int8x16_t v78;
  float64x2_t v79;
  double v80;
  double v81;
  float64x2_t v82;
  double v83;
  int8x16_t v84;
  double v85;
  int8x16_t v86;
  double v87;
  double v88;
  uint8x8_t v89;
  uint8x8_t v90;
  float64x2_t v91;

  DC = (float32x2_t *)CI::getDC(this);
  *(float *)&v4 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v5) = *((_DWORD *)this + 7);
  v6.i32[0] = *((_DWORD *)this + 9);
  *(float *)v7.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v5, COERCE_FLOAT(*DC));
  *(float *)&v8 = *((float *)this + 6) + *(float *)&v4;
  *(float *)v9.f64 = *(float *)v6.i32 + *(float *)v7.i32;
  *((float *)&v8 + 1) = *(float *)v6.i32 + *(float *)v7.i32;
  v13 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v8, v9, v4, v5, v7, v6, v10, v11);
  v14.f64[0] = 0.9;
  if (*(float *)&v13 < 0.9 && *(float *)&v13 > 0.4)
  {
    v91 = v14;
    v15 = *(float32x2_t *)CI::getDC(v12);
    v16 = vadd_f32(v15, (float32x2_t)1065353216);
    *(float *)&v17 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v16, 1), *((float *)this + 4), v16.f32[0]);
    LODWORD(v18) = *((_DWORD *)this + 7);
    v19.i32[0] = *((_DWORD *)this + 9);
    *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v16, 1), *(float *)&v18, v16.f32[0]);
    v16.f32[0] = *((float *)this + 6) + *(float *)&v17;
    *(float *)v21.f64 = *(float *)v19.i32 + *(float *)v20.i32;
    v16.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
    v24 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v16, v21, v17, v18, v20, v19, v22, v23);
    v31 = v91;
    if (*(float *)&v24 < v91.f64[0])
    {
      v32 = vadd_f32(v15, (float32x2_t)3212836864);
      *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v32, 1), *((float *)this + 4), v32.f32[0]);
      LODWORD(v26) = *((_DWORD *)this + 7);
      v28.i32[0] = *((_DWORD *)this + 9);
      *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v32, 1), *(float *)&v26, v32.f32[0]);
      v32.f32[0] = *((float *)this + 6) + *(float *)&v25;
      *(float *)v31.f64 = *(float *)v28.i32 + *(float *)v27.i32;
      v32.f32[1] = *(float *)v28.i32 + *(float *)v27.i32;
      v33 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v32, v31, v25, v26, v27, v28, v29, v30);
      v40 = v91;
      if (*(float *)&v33 < v91.f64[0])
      {
        v41 = vadd_f32(v15, (float32x2_t)0x3F80000000000000);
        *(float *)&v34 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v41, 1), *((float *)this + 4), v41.f32[0]);
        LODWORD(v35) = *((_DWORD *)this + 7);
        v37.i32[0] = *((_DWORD *)this + 9);
        *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v41, 1), *(float *)&v35, v41.f32[0]);
        v41.f32[0] = *((float *)this + 6) + *(float *)&v34;
        *(float *)v40.f64 = *(float *)v37.i32 + *(float *)v36.i32;
        v41.f32[1] = *(float *)v37.i32 + *(float *)v36.i32;
        v42 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v41, v40, v34, v35, v36, v37, v38, v39);
        v49 = v91;
        if (*(float *)&v42 < v91.f64[0])
        {
          v50 = vadd_f32(v15, (float32x2_t)0xBF80000000000000);
          *(float *)&v43 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v50, 1), *((float *)this + 4), v50.f32[0]);
          LODWORD(v44) = *((_DWORD *)this + 7);
          v46.i32[0] = *((_DWORD *)this + 9);
          *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v50, 1), *(float *)&v44, v50.f32[0]);
          v50.f32[0] = *((float *)this + 6) + *(float *)&v43;
          *(float *)v49.f64 = *(float *)v46.i32 + *(float *)v45.i32;
          v50.f32[1] = *(float *)v46.i32 + *(float *)v45.i32;
          v51 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v50, v49, v43, v44, v45, v46, v47, v48);
          v58 = v91;
          if (*(float *)&v51 < v91.f64[0])
          {
            __asm { FMOV            V0.2S, #-1.0 }
            *(float32x2_t *)v54.i8 = vadd_f32(v15, *(float32x2_t *)&_D0);
            LODWORD(v52) = *((_DWORD *)this + 7);
            *(float *)&_D0 = *((float *)this + 6)
                           + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v54.i8, 1), *((float *)this + 4), *(float *)v54.i32);
            LODWORD(v53) = *((_DWORD *)this + 9);
            v90 = *(uint8x8_t *)v54.i8;
            *(float *)v58.f64 = *(float *)&v53
                              + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v54.i8, 1), *(float *)&v52, *(float *)v54.i32);
            HIDWORD(_D0) = LODWORD(v58.f64[0]);
            v64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), _D0, v58, v52, v53, v54, v55, v56, v57);
            v71 = v91;
            if (*(float *)&v64 < v91.f64[0])
            {
              *(float32x2_t *)v67.i8 = vadd_f32(v15, (float32x2_t)0xBF8000003F800000);
              LODWORD(v65) = *((_DWORD *)this + 7);
              *(float *)&v72 = *((float *)this + 6)
                             + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v67.i8, 1), *((float *)this + 4), *(float *)v67.i32);
              LODWORD(v66) = *((_DWORD *)this + 9);
              v89 = *(uint8x8_t *)v67.i8;
              *(float *)v71.f64 = *(float *)&v66
                                + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v67.i8, 1), *(float *)&v65, *(float *)v67.i32);
              HIDWORD(v72) = LODWORD(v71.f64[0]);
              v73 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v72, v71, v65, v66, v67, v68, v69, v70);
              v79 = v91;
              if (*(float *)&v73 < v91.f64[0])
              {
                LODWORD(v75) = *((_DWORD *)this + 7);
                *(float *)&v80 = *((float *)this + 6)
                               + (float)((float)(*(float *)&v90.i32[1] * *((float *)this + 5))
                                       + (float)(*(float *)v90.i32 * *((float *)this + 4)));
                LODWORD(v74) = *((_DWORD *)this + 8);
                v76.i32[0] = *((_DWORD *)this + 9);
                *(float *)v79.f64 = *(float *)v76.i32
                                  + (float)((float)(*(float *)&v90.i32[1] * *(float *)&v74)
                                          + (float)(*(float *)v90.i32 * *(float *)&v75));
                *((float *)&v80 + 1) = *(float *)v79.f64;
                v81 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v80, v79, v74, v75, v76, v90, v77, v78);
                HIDWORD(v87) = HIDWORD(v91.f64[0]);
                if (*(float *)&v81 < v91.f64[0])
                {
                  LODWORD(v83) = *((_DWORD *)this + 7);
                  *(float *)&v88 = *((float *)this + 6)
                                 + (float)((float)(*(float *)&v89.i32[1] * *((float *)this + 5))
                                         + (float)(*(float *)v89.i32 * *((float *)this + 4)));
                  LODWORD(v87) = *((_DWORD *)this + 8);
                  v84.i32[0] = *((_DWORD *)this + 9);
                  *(float *)v82.f64 = *(float *)v84.i32
                                    + (float)((float)(*(float *)&v89.i32[1] * *(float *)&v87)
                                            + (float)(*(float *)v89.i32 * *(float *)&v83));
                  *((float *)&v88 + 1) = *(float *)v82.f64;
                  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v88, v82, v87, v83, v84, v89, v85, v86);
                }
              }
            }
          }
        }
      }
    }
  }
}

float64_t cikernel::_cannyFinal(float64x2_t a1, float64x2_t a2)
{
  a1.f64[0] = *(float *)a1.f64;
  a2.f64[0] = 0.9;
  __asm { FMOV            V2.4S, #1.0 }
  *(_QWORD *)&a1.f64[0] = vbslq_s8((int8x16_t)vdupq_lane_s64(vmvnq_s8((int8x16_t)vcgeq_f64(a1, a2)).i64[0], 0), (int8x16_t)xmmword_19248E050, _Q2).u64[0];
  return a1.f64[0];
}

uint64_t CI_ENABLE_SUBDIVIDE_ROI()
{
  unsigned __int8 v0;

  {
    CI_ENABLE_SUBDIVIDE_ROI::v = get_BOOL("CI_ENABLE_SUBDIVIDE_ROI", 1);
  }
  return CI_ENABLE_SUBDIVIDE_ROI::v;
}

void sub_192289790(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_IOSURFACE_INTERMEDIATES()
{
  unsigned __int8 v0;

  {
    CI_IOSURFACE_INTERMEDIATES::v = get_BOOL("CI_IOSURFACE_INTERMEDIATES", 1);
  }
  return CI_IOSURFACE_INTERMEDIATES::v;
}

void sub_19228980C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_LOSSLESS_COMPRESSED_INTERMEDIATES()
{
  unsigned __int8 v0;

  {
    CI_LOSSLESS_COMPRESSED_INTERMEDIATES::v = get_BOOL("CI_LOSSLESS_COMPRESSED_INTERMEDIATES", 1);
  }
  return CI_LOSSLESS_COMPRESSED_INTERMEDIATES::v;
}

void sub_192289888(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_LOSSY_COMPRESSED_INTERMEDIATES()
{
  unsigned __int8 v0;

  {
    CI_LOSSY_COMPRESSED_INTERMEDIATES::v = get_BOOL("CI_LOSSY_COMPRESSED_INTERMEDIATES", 1);
  }
  return CI_LOSSY_COMPRESSED_INTERMEDIATES::v;
}

void sub_192289904(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_LOG_FILE()
{
  if (CI_LOG_FILE::didCheck != -1)
    dispatch_once(&CI_LOG_FILE::didCheck, &__block_literal_global_25);
  return CI_LOG_FILE::fp;
}

uint64_t memstream_write(char *a1, const char *__src, int a3)
{
  uint64_t v5;
  int v7;
  NSObject *v9;
  int v10;
  uint64_t v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  int v16;
  int v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  const char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a3 < 1)
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    while (__src[v5] && __src[v5] != 10)
    {
      if (a3 == ++v5)
      {
        v5 = a3;
        break;
      }
    }
  }
  v7 = __src[v5];
  if (v7 == 10 || v7 == 0)
  {
    if ((_DWORD)v5)
    {
      v9 = ci_logger_general();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v10 = *(_DWORD *)a1;
        v16 = 68158466;
        v17 = v10;
        v18 = 2080;
        v19 = a1 + 4;
        v20 = 1040;
        v21 = v5;
        v22 = 2080;
        v23 = __src;
        _os_log_impl(&dword_1921E4000, v9, OS_LOG_TYPE_DEFAULT, "%.*s%.*s", (uint8_t *)&v16, 0x22u);
      }
    }
    *(_DWORD *)a1 = 0;
    return (v5 + 1);
  }
  else
  {
    v12 = *(int *)a1;
    if ((int)v12 + (int)v5 < 1025)
    {
      memcpy(&a1[v12 + 4], __src, v5);
      *(_DWORD *)a1 += v5;
    }
    else
    {
      if ((_DWORD)v12)
      {
        v13 = ci_logger_general();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          v14 = *(_DWORD *)a1;
          v16 = 68157954;
          v17 = v14;
          v18 = 2080;
          v19 = a1 + 4;
          _os_log_impl(&dword_1921E4000, v13, OS_LOG_TYPE_DEFAULT, "%.*s...", (uint8_t *)&v16, 0x12u);
        }
      }
      if ((_DWORD)v5)
      {
        v15 = ci_logger_general();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          v16 = 68157954;
          v17 = v5;
          v18 = 2080;
          v19 = __src;
          _os_log_impl(&dword_1921E4000, v15, OS_LOG_TYPE_DEFAULT, "...%.*s...", (uint8_t *)&v16, 0x12u);
        }
      }
      *(_DWORD *)a1 = 0;
    }
  }
  return v5;
}

char *CI_TEMP_DIR()
{
  char *result;

  if (CI_DOCS_DIR::onceToken != -1)
    dispatch_once(&CI_DOCS_DIR::onceToken, &__block_literal_global_138);
  result = &CI_DOCS_DIR::directory;
  if (!CI_DOCS_DIR::directory)
  {
    if (CI_TEMP_DIR::onceToken != -1)
      dispatch_once(&CI_TEMP_DIR::onceToken, &__block_literal_global_140);
    return (char *)&CI_TEMP_DIR::temporaryDirectory;
  }
  return result;
}

char *CI_PRINT_TIME_has_string(const char *a1)
{
  char *string;

  string = get_string("CI_PRINT_TIME");
  if (a1 && string)
    return strstr(string, a1);
  else
    return 0;
}

BOOL CI_PRINT_TIME_context(int a1, char *__s2)
{
  BOOL v5;

  if (CI_PRINT_TIME_context::didCheck != -1)
    dispatch_once(&CI_PRINT_TIME_context::didCheck, &__block_literal_global_24_0);
  if (CI_PRINT_TIME_context::equal)
  {
    if (CI_PRINT_TIME_context::name)
      return strcmp(&CI_PRINT_TIME_context::name, __s2) == 0;
    else
      return CI_PRINT_TIME_context::v == a1;
  }
  else if (CI_PRINT_TIME_context::nequal)
  {
    if (CI_PRINT_TIME_context::name)
      v5 = strcmp(&CI_PRINT_TIME_context::name, __s2) == 0;
    else
      v5 = CI_PRINT_TIME_context::v == a1;
    return !v5;
  }
  else
  {
    return 1;
  }
}

uint64_t CI_PRINT_TREE_frame()
{
  if (CI_PRINT_TREE_frame::didCheck != -1)
    dispatch_once(&CI_PRINT_TREE_frame::didCheck, &__block_literal_global_53);
  return CI_PRINT_TREE_frame::v;
}

uint64_t CI_PRINT_TREE_graphviz()
{
  if (CI_PRINT_TREE_graphviz::didCheck != -1)
    dispatch_once(&CI_PRINT_TREE_graphviz::didCheck, &__block_literal_global_55);
  return CI_PRINT_TREE_graphviz::v;
}

uint64_t CI_PRINT_TREE_dump_rois()
{
  unsigned __int8 v0;

  {
    CI_PRINT_TREE_dump_rois::v = CI_PRINT_TREE_has_string("dump-rois") != 0;
  }
  return CI_PRINT_TREE_dump_rois::v;
}

void sub_19228A124(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_PRINT_TREE_dump_inputs()
{
  unsigned __int8 v0;

  {
    CI_PRINT_TREE_dump_inputs::v = CI_PRINT_TREE_has_string("dump-inputs") != 0;
  }
  return CI_PRINT_TREE_dump_inputs::v;
}

void sub_19228A1A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_PRINT_TREE_dump_raw_intermediates()
{
  unsigned __int8 v0;

  {
    CI_PRINT_TREE_dump_raw_intermediates::v = CI_PRINT_TREE_has_string("dump-raw-intermediates") != 0;
  }
  return CI_PRINT_TREE_dump_raw_intermediates::v;
}

void sub_19228A224(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_PRINT_TREE_dump_bmtl_intermediates()
{
  unsigned __int8 v0;

  {
    CI_PRINT_TREE_dump_bmtl_intermediates::v = CI_PRINT_TREE_has_string("dump-bmtl-intermediates") != 0;
  }
  return CI_PRINT_TREE_dump_bmtl_intermediates::v;
}

void sub_19228A2A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_PRINT_TREE_dump_timing()
{
  unsigned __int8 v0;

  {
    CI_PRINT_TREE_dump_timing::v = CI_PRINT_TREE_has_string("dump-timing") != 0;
  }
  return CI_PRINT_TREE_dump_timing::v;
}

void sub_19228A324(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL CI_PRINT_TREE_context(int a1, char *__s2)
{
  BOOL v5;

  if (CI_PRINT_TREE_context::didCheck != -1)
    dispatch_once(&CI_PRINT_TREE_context::didCheck, &__block_literal_global_52);
  if (CI_PRINT_TREE_context::equal)
  {
    if (CI_PRINT_TREE_context::name)
      return strcmp(&CI_PRINT_TREE_context::name, __s2) == 0;
    else
      return CI_PRINT_TREE_context::v == a1;
  }
  else if (CI_PRINT_TREE_context::nequal)
  {
    if (CI_PRINT_TREE_context::name)
      v5 = strcmp(&CI_PRINT_TREE_context::name, __s2) == 0;
    else
      v5 = CI_PRINT_TREE_context::v == a1;
    return !v5;
  }
  else
  {
    return 1;
  }
}

uint64_t CI_PRINT_PROGRAM()
{
  if (CI_PRINT_PROGRAM::didCheck != -1)
    dispatch_once(&CI_PRINT_PROGRAM::didCheck, &__block_literal_global_60_0);
  return CI_PRINT_PROGRAM::v;
}

BOOL CI_PRINT_PROGRAM_context(int a1, char *__s2)
{
  BOOL v5;

  if (CI_PRINT_PROGRAM_context::didCheck != -1)
    dispatch_once(&CI_PRINT_PROGRAM_context::didCheck, &__block_literal_global_62_1);
  if (CI_PRINT_PROGRAM_context::equal)
  {
    if (CI_PRINT_PROGRAM_context::name)
      return strcmp(&CI_PRINT_PROGRAM_context::name, __s2) == 0;
    else
      return CI_PRINT_PROGRAM_context::v == a1;
  }
  else if (CI_PRINT_PROGRAM_context::nequal)
  {
    if (CI_PRINT_PROGRAM_context::name)
      v5 = strcmp(&CI_PRINT_PROGRAM_context::name, __s2) == 0;
    else
      v5 = CI_PRINT_PROGRAM_context::v == a1;
    return !v5;
  }
  else
  {
    return 1;
  }
}

uint64_t CI_MAX_CPU_RENDER_SIZE()
{
  unsigned __int8 v0;

  {
    CI_MAX_CPU_RENDER_SIZE::v = get_int("CI_MAX_CPU_RENDER_SIZE", 512);
  }
  return CI_MAX_CPU_RENDER_SIZE::v;
}

void sub_19228A9D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t get_Y_or_N(const char *a1)
{
  char *v2;
  int v3;
  uint64_t result;
  char v5;
  void *v6;

  v2 = getenv(a1);
  if (!v2)
  {
    if (userDefaults(void)::didCheck != -1)
      dispatch_once(&userDefaults(void)::didCheck, &__block_literal_global_171);
    v6 = (void *)objc_msgSend((id)userDefaults(void)::defaults, "objectForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      if (objc_msgSend(v6, "intValue") == 1)
        return 89;
      if (!objc_msgSend(v6, "intValue"))
        return 78;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      if ((objc_msgSend(v6, "isEqual:", CFSTR("Y")) & 1) != 0 || (objc_msgSend(v6, "isEqual:", CFSTR("y")) & 1) != 0)
        return 89;
      if ((objc_msgSend(v6, "isEqual:", CFSTR("N")) & 1) != 0 || (objc_msgSend(v6, "isEqual:", CFSTR("n")) & 1) != 0)
        return 78;
    }
    return 0;
  }
  v3 = *v2;
  result = 89;
  v5 = v3 - 48;
  if ((v3 - 48) > 0x3E)
    goto LABEL_15;
  if (((1 << v5) & 0x4000000040000001) != 0)
    return 78;
  if (((1 << v5) & 0x20000000002) == 0)
  {
LABEL_15:
    if (v3 != 121)
      return 0;
  }
  return result;
}

uint64_t CI_FORCE_IS_BACKGROUND()
{
  unsigned __int8 v0;

  {
    CI_FORCE_IS_BACKGROUND::v = get_Y_or_N("CI_FORCE_IS_BACKGROUND");
  }
  return CI_FORCE_IS_BACKGROUND::v;
}

void sub_19228ABC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_FORCE_GPU_PRIORITY()
{
  if (CI_FORCE_GPU_PRIORITY::didCheck != -1)
    dispatch_once(&CI_FORCE_GPU_PRIORITY::didCheck, &__block_literal_global_67);
  return CI_FORCE_GPU_PRIORITY::v;
}

uint64_t CI_INPUT_CACHE_SIZE()
{
  unsigned __int8 v0;

  {
    CI_INPUT_CACHE_SIZE::v = get_int("CI_INPUT_CACHE_SIZE", 4);
  }
  return CI_INPUT_CACHE_SIZE::v;
}

void sub_19228AD40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_ENABLE_KERNEL_CACHE()
{
  unsigned __int8 v0;

  {
    CI_ENABLE_KERNEL_CACHE::v = get_BOOL("CI_ENABLE_KERNEL_CACHE", 1);
  }
  return CI_ENABLE_KERNEL_CACHE::v;
}

void sub_19228ADBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_ASYNC_KERNEL_COMPILE()
{
  unsigned __int8 v0;

  {
    CI_ASYNC_KERNEL_COMPILE::v = get_int("CI_ASYNC_KERNEL_COMPILE", 2);
  }
  return CI_ASYNC_KERNEL_COMPILE::v;
}

void sub_19228AE38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_INTERMEDIATE_CACHE_SIZE()
{
  unsigned __int8 v0;

  {
    CI_INTERMEDIATE_CACHE_SIZE::v = get_ulong("CI_INTERMEDIATE_CACHE_SIZE", 256);
  }
  return CI_INTERMEDIATE_CACHE_SIZE::v;
}

void sub_19228AEB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t get_ulong(const char *a1, uint64_t a2)
{
  char *v4;
  void *v6;

  v4 = getenv(a1);
  if (v4)
    return strtoul(v4, 0, 10);
  if (userDefaults(void)::didCheck != -1)
    dispatch_once(&userDefaults(void)::didCheck, &__block_literal_global_171);
  v6 = (void *)objc_msgSend((id)userDefaults(void)::defaults, "objectForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return objc_msgSend(v6, "unsignedLongValue");
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return objc_msgSend(v6, "unsignedLongValue");
  else
    return a2;
}

uint64_t CI_INTERMEDIATE_SRGB_TEXTURES()
{
  unsigned __int8 v0;

  {
    CI_INTERMEDIATE_SRGB_TEXTURES::v = get_BOOL("CI_INTERMEDIATE_SRGB_TEXTURES", 1);
  }
  return CI_INTERMEDIATE_SRGB_TEXTURES::v;
}

void sub_19228B014(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_INPUT_SRGB_TEXTURES()
{
  unsigned __int8 v0;

  {
    CI_INPUT_SRGB_TEXTURES::v = get_int("CI_INPUT_SRGB_TEXTURES", 2);
  }
  return CI_INPUT_SRGB_TEXTURES::v;
}

void sub_19228B090(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_OUTPUT_SRGB_TEXTURES()
{
  unsigned __int8 v0;

  {
    CI_OUTPUT_SRGB_TEXTURES::v = get_BOOL("CI_OUTPUT_SRGB_TEXTURES", 1);
  }
  return CI_OUTPUT_SRGB_TEXTURES::v;
}

void sub_19228B10C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_RECYCLE_OPENGL_TEXTURES()
{
  unsigned __int8 v0;

  {
    CI_RECYCLE_OPENGL_TEXTURES::v = get_BOOL("CI_RECYCLE_OPENGL_TEXTURES", 1);
  }
  return CI_RECYCLE_OPENGL_TEXTURES::v;
}

void sub_19228B188(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_USE_INFLIGHT_INTERMEDIATES()
{
  unsigned __int8 v0;

  {
    CI_USE_INFLIGHT_INTERMEDIATES::v = get_BOOL("CI_USE_INFLIGHT_INTERMEDIATES", 1);
  }
  return CI_USE_INFLIGHT_INTERMEDIATES::v;
}

void sub_19228B204(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_ENABLE_METAL_DAG()
{
  unsigned __int8 v0;

  {
    CI_ENABLE_METAL_DAG::v = get_int("CI_ENABLE_METAL_DAG", 1);
  }
  return CI_ENABLE_METAL_DAG::v;
}

void sub_19228B280(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_ENABLE_FUNCTION_STITCHING()
{
  unsigned __int8 v0;

  {
    CI_ENABLE_FUNCTION_STITCHING::v = get_BOOL("CI_ENABLE_FUNCTION_STITCHING", 1);
  }
  return CI_ENABLE_FUNCTION_STITCHING::v;
}

void sub_19228B2FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_DISABLE_LOADING_ARCHIVES()
{
  return get_BOOL("CI_DISABLE_LOADING_ARCHIVES", 0);
}

void *CI_DISABLE_LOADING_ARCHIVES_BY_NAME()
{
  if (CI_DISABLE_LOADING_ARCHIVES_BY_NAME::didCheck != -1)
    dispatch_once(&CI_DISABLE_LOADING_ARCHIVES_BY_NAME::didCheck, &__block_literal_global_91);
  if (CI_DISABLE_LOADING_ARCHIVES_BY_NAME::is_set)
    return &CI_DISABLE_LOADING_ARCHIVES_BY_NAME::archives_name;
  else
    return 0;
}

uint64_t CI_LOG_AIR_ARCHIVE_MISS()
{
  unsigned __int8 v0;

  {
    CI_LOG_AIR_ARCHIVE_MISS::v = get_BOOL("CI_LOG_AIR_ARCHIVE_MISS", 0);
  }
  return CI_LOG_AIR_ARCHIVE_MISS::v;
}

void sub_19228B418(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_LOG_AIR_ARCHIVE_ACTIVITY()
{
  unsigned __int8 v0;

  {
    CI_LOG_AIR_ARCHIVE_ACTIVITY::v = get_BOOL("CI_LOG_AIR_ARCHIVE_ACTIVITY", 0);
  }
  return CI_LOG_AIR_ARCHIVE_ACTIVITY::v;
}

void sub_19228B494(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_LOG_BIN_ARCHIVE_MISS()
{
  unsigned __int8 v0;

  {
    CI_LOG_BIN_ARCHIVE_MISS::v = get_int("CI_LOG_BIN_ARCHIVE_MISS", 0);
  }
  return CI_LOG_BIN_ARCHIVE_MISS::v;
}

void sub_19228B510(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_LOG_METAL_FUNCTION_HASH()
{
  unsigned __int8 v0;

  {
    CI_LOG_METAL_FUNCTION_HASH::v = get_BOOL("CI_LOG_METAL_FUNCTION_HASH", 0);
  }
  return CI_LOG_METAL_FUNCTION_HASH::v;
}

void sub_19228B58C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_HARVEST_BIN_ARCHIVE_PROGRAM_TYPE()
{
  unsigned __int8 v0;

  {
    CI_HARVEST_BIN_ARCHIVE_PROGRAM_TYPE::v = get_int("CI_HARVEST_BIN_ARCHIVE_PROGRAM_TYPE", 0);
  }
  return CI_HARVEST_BIN_ARCHIVE_PROGRAM_TYPE::v;
}

void sub_19228B608(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_SKIP_PREWARMING_SDOF_RENDERING()
{
  unsigned __int8 v0;

  {
    CI_SKIP_PREWARMING_SDOF_RENDERING::v = get_BOOL("CI_SKIP_PREWARMING_SDOF_RENDERING", 0);
  }
  return CI_SKIP_PREWARMING_SDOF_RENDERING::v;
}

void sub_19228B684(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *CI_HARVESTING_SPECIFIC_LIBRARY_LIST()
{
  if (CI_HARVESTING_SPECIFIC_LIBRARY_LIST::didCheck != -1)
    dispatch_once(&CI_HARVESTING_SPECIFIC_LIBRARY_LIST::didCheck, &__block_literal_global_100);
  if (CI_HARVESTING_SPECIFIC_LIBRARY_LIST::is_set)
    return &CI_HARVESTING_SPECIFIC_LIBRARY_LIST::archives_name;
  else
    return 0;
}

char *CI_HARVEST_PROCESS_NAME_LIST()
{
  if (CI_HARVEST_PROCESS_NAME_LIST::didCheck != -1)
    dispatch_once(&CI_HARVEST_PROCESS_NAME_LIST::didCheck, &__block_literal_global_102);
  if (CI_HARVEST_PROCESS_NAME_LIST::is_set)
    return CI_HARVEST_PROCESS_NAME_LIST::archives_name;
  else
    return 0;
}

uint64_t CI_HARVEST_SPECIALIZED_MTL_FUNCTIONS()
{
  unsigned __int8 v0;

  {
    CI_HARVEST_SPECIALIZED_MTL_FUNCTIONS::v = get_BOOL("CI_HARVEST_SPECIALIZED_MTL_FUNCTIONS", 1);
  }
  return CI_HARVEST_SPECIALIZED_MTL_FUNCTIONS::v;
}

void sub_19228B820(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double CI_BIN_ARCHIVE_SERIALIZATION_DELAY()
{
  unsigned __int8 v0;
  const char *v2;
  double v3;

  if ((v0 & 1) == 0)
  {
    if ((_DWORD)v2)
    {
      CI_BIN_ARCHIVE_SERIALIZATION_DELAY::v = get_double(v2, v3);
    }
  }
  return *(double *)&CI_BIN_ARCHIVE_SERIALIZATION_DELAY::v;
}

void sub_19228B890(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double get_double(const char *a1, double a2)
{
  char *v2;
  double result;
  void *v4;

  v2 = getenv("CI_BIN_ARCHIVE_SERIALIZATION_DELAY");
  if (v2)
    return strtod(v2, 0);
  if (userDefaults(void)::didCheck != -1)
    dispatch_once(&userDefaults(void)::didCheck, &__block_literal_global_171);
  v4 = (void *)objc_msgSend((id)userDefaults(void)::defaults, "objectForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CI_BIN_ARCHIVE_SERIALIZATION_DELAY"));
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
      return 100.0;
  }
  objc_msgSend(v4, "doubleValue");
  return result;
}

uint64_t CI_HARVEST_BIN_ARCHIVE()
{
  unsigned __int8 v0;

  {
    CI_HARVEST_BIN_ARCHIVE::v = get_int("CI_HARVEST_BIN_ARCHIVE", 0);
  }
  return CI_HARVEST_BIN_ARCHIVE::v;
}

void sub_19228B9E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_BIN_ARCHIVE_SERIALIZATION_METHOD()
{
  unsigned __int8 v0;

  {
    CI_BIN_ARCHIVE_SERIALIZATION_METHOD::v = get_int("CI_BIN_ARCHIVE_SERIALIZATION_METHOD", 0);
  }
  return CI_BIN_ARCHIVE_SERIALIZATION_METHOD::v;
}

void sub_19228BA60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *CI_HARVEST_BIN_ARCHIVE_ABSOLUTE_PATH()
{
  if (CI_HARVEST_BIN_ARCHIVE_ABSOLUTE_PATH::didCheck != -1)
    dispatch_once(&CI_HARVEST_BIN_ARCHIVE_ABSOLUTE_PATH::didCheck, &__block_literal_global_108);
  if (CI_HARVEST_BIN_ARCHIVE_ABSOLUTE_PATH::is_set)
    return CI_HARVEST_BIN_ARCHIVE_ABSOLUTE_PATH::harvesting_path;
  else
    return 0;
}

char *CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME()
{
  if (CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME::didCheck != -1)
    dispatch_once(&CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME::didCheck, &__block_literal_global_110);
  if (CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME::is_set)
    return CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME::harvesting_dir;
  else
    return 0;
}

uint64_t CI_ADD_PROCESS_NAME_TO_BIN_ARCHIVE()
{
  unsigned __int8 v0;

  {
    CI_ADD_PROCESS_NAME_TO_BIN_ARCHIVE::v = get_BOOL("CI_ADD_PROCESS_NAME_TO_BIN_ARCHIVE", 0);
  }
  return CI_ADD_PROCESS_NAME_TO_BIN_ARCHIVE::v;
}

void sub_19228BBFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_PREVENT_HARVEST_DUPLICATE_ENTRIES()
{
  unsigned __int8 v0;

  {
    CI_PREVENT_HARVEST_DUPLICATE_ENTRIES::v = get_BOOL("CI_PREVENT_HARVEST_DUPLICATE_ENTRIES", 0);
  }
  return CI_PREVENT_HARVEST_DUPLICATE_ENTRIES::v;
}

void sub_19228BC78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_USE_MTL_DAG_FOR_CIKL_SRC()
{
  unsigned __int8 v0;

  {
    CI_USE_MTL_DAG_FOR_CIKL_SRC::v = get_BOOL("CI_USE_MTL_DAG_FOR_CIKL_SRC", 1);
  }
  return CI_USE_MTL_DAG_FOR_CIKL_SRC::v;
}

void sub_19228BCF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_ENABLE_METAL_CONVERT()
{
  unsigned __int8 v0;

  {
    CI_ENABLE_METAL_CONVERT::v = get_BOOL("CI_ENABLE_METAL_CONVERT", 0);
  }
  return CI_ENABLE_METAL_CONVERT::v;
}

void sub_19228BD70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_ENABLE_METAL_BLIT()
{
  unsigned __int8 v0;

  {
    CI_ENABLE_METAL_BLIT::v = get_BOOL("CI_ENABLE_METAL_BLIT", 1);
  }
  return CI_ENABLE_METAL_BLIT::v;
}

void sub_19228BDEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_ENABLE_METAL_IMAGEBLOCKS()
{
  unsigned __int8 v0;

  {
    CI_ENABLE_METAL_IMAGEBLOCKS::v = get_int("CI_ENABLE_METAL_IMAGEBLOCKS", 0);
  }
  return CI_ENABLE_METAL_IMAGEBLOCKS::v;
}

void sub_19228BE68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_ENABLE_WRITE_420()
{
  unsigned __int8 v0;

  {
    CI_ENABLE_WRITE_420::v = get_BOOL("CI_ENABLE_WRITE_420", 1);
  }
  return CI_ENABLE_WRITE_420::v;
}

void sub_19228BEE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_ENABLE_MPS()
{
  unsigned __int8 v0;

  {
    CI_ENABLE_MPS::v = get_BOOL("CI_ENABLE_MPS", 1);
  }
  return CI_ENABLE_MPS::v;
}

void sub_19228BF60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_AUTOTEST_ROI()
{
  unsigned __int8 v0;

  {
    CI_AUTOTEST_ROI::v = get_BOOL("CI_AUTOTEST_ROI", 0);
  }
  return CI_AUTOTEST_ROI::v;
}

void sub_19228BFDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_EDIT_RED_EYE_VERSION()
{
  unsigned __int8 v0;

  {
    CI_EDIT_RED_EYE_VERSION::v = get_int("CI_EDIT_RED_EYE_VERSION", 3);
  }
  if (CI_EDIT_RED_EYE_VERSION::v <= 1)
    return 1;
  else
    return CI_EDIT_RED_EYE_VERSION::v;
}

void sub_19228C060(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_DISABLE_MERGING()
{
  unsigned __int8 v0;

  {
    CI_DISABLE_MERGING::v = get_BOOL("CI_DISABLE_MERGING", 0);
  }
  return CI_DISABLE_MERGING::v;
}

void sub_19228C0DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_DISABLE_MERGING_PRE_GENERAL()
{
  unsigned __int8 v0;

  {
    CI_DISABLE_MERGING_PRE_GENERAL::v = get_BOOL("CI_DISABLE_MERGING_PRE_GENERAL", 0);
  }
  return CI_DISABLE_MERGING_PRE_GENERAL::v;
}

void sub_19228C158(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_DISABLE_MERGING_POST_GENERAL()
{
  unsigned __int8 v0;

  {
    CI_DISABLE_MERGING_POST_GENERAL::v = get_BOOL("CI_DISABLE_MERGING_POST_GENERAL", 0);
  }
  return CI_DISABLE_MERGING_POST_GENERAL::v;
}

void sub_19228C1D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_LOG_TEXTURE_CACHE()
{
  unsigned __int8 v0;

  {
    CI_LOG_TEXTURE_CACHE::v = get_BOOL("CI_LOG_TEXTURE_CACHE", 0);
  }
  return CI_LOG_TEXTURE_CACHE::v;
}

void sub_19228C250(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_LIMIT_SAMPLERS()
{
  unsigned __int8 v0;

  {
    CI_LIMIT_SAMPLERS::v = get_BOOL("CI_LIMIT_SAMPLERS", 0);
  }
  return CI_LIMIT_SAMPLERS::v;
}

void sub_19228C2CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_LIMIT_RENDER()
{
  unsigned __int8 v0;

  {
    CI_LIMIT_RENDER::v = get_int("CI_LIMIT_RENDER", 0);
  }
  return CI_LIMIT_RENDER::v;
}

void sub_19228C348(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_NO_RENDER()
{
  unsigned __int8 v0;

  {
    CI_NO_RENDER::v = get_BOOL("CI_NO_RENDER", 0);
  }
  return CI_NO_RENDER::v;
}

void sub_19228C3C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_TRACE_PEAK_SURFACE_CACHE()
{
  unsigned __int8 v0;

  {
    CI_TRACE_PEAK_SURFACE_CACHE::v = get_BOOL("CI_TRACE_PEAK_SURFACE_CACHE", 0);
  }
  return CI_TRACE_PEAK_SURFACE_CACHE::v;
}

void sub_19228C440(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_LOG_IMAGE_PROVIDER()
{
  unsigned __int8 v0;

  {
    CI_LOG_IMAGE_PROVIDER::v = get_BOOL("CI_LOG_IMAGE_PROVIDER", 0);
  }
  return CI_LOG_IMAGE_PROVIDER::v;
}

void sub_19228C4BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_RENDER_MB_LIMIT()
{
  unsigned __int8 v0;

  {
    CI_RENDER_MB_LIMIT::v = get_ulong("CI_RENDER_MB_LIMIT", 0);
  }
  return CI_RENDER_MB_LIMIT::v;
}

void sub_19228C538(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_SURFACE_CACHE_CAPACITY()
{
  unsigned __int8 v0;

  {
    CI_SURFACE_CACHE_CAPACITY::v = get_ulong("CI_SURFACE_CACHE_CAPACITY", 0x10000000);
  }
  return CI_SURFACE_CACHE_CAPACITY::v;
}

void sub_19228C5B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_DISABLE_CRUFT_COMPATABILITY()
{
  unsigned __int8 v0;

  {
    CI_DISABLE_CRUFT_COMPATABILITY::v = get_BOOL("CI_DISABLE_CRUFT_COMPATABILITY", 0);
  }
  return CI_DISABLE_CRUFT_COMPATABILITY::v;
}

void sub_19228C724(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_FORCE_INSERT_NOOPS()
{
  unsigned __int8 v0;

  {
    CI_FORCE_INSERT_NOOPS::v = get_Y_or_N("CI_FORCE_INSERT_NOOPS");
  }
  return CI_FORCE_INSERT_NOOPS::v;
}

void sub_19228C79C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_MAX_CL_COMPLEXITY()
{
  unsigned __int8 v0;

  {
    CI_MAX_CL_COMPLEXITY::v = get_int("CI_MAX_CL_COMPLEXITY", 45);
  }
  return CI_MAX_CL_COMPLEXITY::v;
}

void sub_19228C818(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_MAX_PROGRAM_DEPTH()
{
  unsigned __int8 v0;

  {
    CI_MAX_PROGRAM_DEPTH::v = get_int("CI_MAX_PROGRAM_DEPTH", 128);
  }
  return CI_MAX_PROGRAM_DEPTH::v;
}

void sub_19228C894(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_MAX_PROGRAM_INPUT_TEXTURES()
{
  unsigned __int8 v0;

  {
    CI_MAX_PROGRAM_INPUT_TEXTURES::v = get_int("CI_MAX_PROGRAM_INPUT_TEXTURES", 32);
  }
  return CI_MAX_PROGRAM_INPUT_TEXTURES::v;
}

void sub_19228C910(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_DEBUG_CONTEXT_COLOR()
{
  unsigned __int8 v0;

  {
    CI_DEBUG_CONTEXT_COLOR::v = get_int("CI_DEBUG_CONTEXT_COLOR", 0);
  }
  return CI_DEBUG_CONTEXT_COLOR::v;
}

void sub_19228C98C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_DISABLE_WORKAROUND()
{
  unsigned __int8 v0;

  {
    CI_DISABLE_WORKAROUND::v = get_int("CI_DISABLE_WORKAROUND", 0);
  }
  return CI_DISABLE_WORKAROUND::v;
}

void sub_19228CA08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_GRAPH_ALLOW_REORDER()
{
  unsigned __int8 v0;

  {
    CI_GRAPH_ALLOW_REORDER::v = get_BOOL("CI_GRAPH_ALLOW_REORDER", 1);
  }
  return CI_GRAPH_ALLOW_REORDER::v;
}

void sub_19228CA84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_GRAPH_FORCE_CROP()
{
  unsigned __int8 v0;

  {
    CI_GRAPH_FORCE_CROP::v = get_BOOL("CI_GRAPH_FORCE_CROP", 0);
  }
  return CI_GRAPH_FORCE_CROP::v;
}

void sub_19228CB00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_FLIP_IMAGE_PROCESSOR()
{
  unsigned __int8 v0;

  {
    CI_FLIP_IMAGE_PROCESSOR::v = get_BOOL("CI_FLIP_IMAGE_PROCESSOR", 1);
  }
  return CI_FLIP_IMAGE_PROCESSOR::v;
}

void sub_19228CB7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_CACHE_PROGRAM_GRAPH()
{
  if (CI_CACHE_PROGRAM_GRAPH::didCheck != -1)
    dispatch_once(&CI_CACHE_PROGRAM_GRAPH::didCheck, &__block_literal_global_155);
  return CI_CACHE_PROGRAM_GRAPH::v;
}

uint64_t CI_VERBOSE_SIGNPOSTS()
{
  unsigned __int8 v0;

  {
    CI_VERBOSE_SIGNPOSTS::v = get_BOOL("CI_VERBOSE_SIGNPOSTS", 0);
  }
  return CI_VERBOSE_SIGNPOSTS::v;
}

void sub_19228CC9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_GRAPHVIZ_INTERNAL()
{
  unsigned __int8 v0;

  {
    CI_GRAPHVIZ_INTERNAL::v = get_BOOL("CI_GRAPHVIZ_INTERNAL", 0);
  }
  return CI_GRAPHVIZ_INTERNAL::v;
}

void sub_19228CD18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t FOSL_DUMP_GRAPH()
{
  unsigned __int8 v0;

  {
    FOSL_DUMP_GRAPH::v = get_BOOL("FOSL_DUMP_GRAPH", 0);
  }
  return FOSL_DUMP_GRAPH::v;
}

void sub_19228CD94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t FOSL_PRINT_GRAPH()
{
  unsigned __int8 v0;

  {
    FOSL_PRINT_GRAPH::v = get_BOOL("FOSL_PRINT_GRAPH", 0);
  }
  return FOSL_PRINT_GRAPH::v;
}

void sub_19228CE10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_DISABLE_REDEYE_SEARCH()
{
  unsigned __int8 v0;

  {
    CI_DISABLE_REDEYE_SEARCH::v = get_int("CI_DISABLE_REDEYE_SEARCH", 0);
  }
  return CI_DISABLE_REDEYE_SEARCH::v;
}

void sub_19228CE8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CI_LOG_DUALRED()
{
  unsigned __int8 v0;
  const __CFNumber *v1;
  const __CFNumber *v2;
  CFTypeID v3;
  uint64_t result;
  CFTypeID v5;
  unsigned int valuePtr;

  {
    CI_LOG_DUALRED::v = get_int("CI_LOG_DUALRED", 0);
  }
  valuePtr = 0;
  v1 = (const __CFNumber *)CFPreferencesCopyAppValue(CFSTR("CI_LOG_DUALRED"), CFSTR("com.apple.coremedia"));
  if (!v1)
    return CI_LOG_DUALRED::v;
  v2 = v1;
  v3 = CFGetTypeID(v1);
  if (v3 == CFNumberGetTypeID())
  {
    CFNumberGetValue(v2, kCFNumberIntType, &valuePtr);
  }
  else
  {
    v5 = CFGetTypeID(v2);
    if (v5 == CFStringGetTypeID())
      valuePtr = CFStringGetIntValue((CFStringRef)v2);
  }
  CFRelease(v2);
  result = CI_LOG_DUALRED::v;
  if (valuePtr)
  {
    if (!CI_LOG_DUALRED::v)
    {
      CI_LOG_DUALRED::v = valuePtr;
      return valuePtr;
    }
  }
  return result;
}

void sub_19228CFA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 cikernel::_facebalance(float32x4_t a1, float32x2_t a2)
{
  float v9;
  __n128 result;
  int8x16_t v11;
  unsigned __int32 v12;

  v12 = a1.u32[3];
  v11 = (int8x16_t)vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_192491EB0, a1, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_192491EA0, *(float32x2_t *)a1.f32, 1), vmulq_n_f32((float32x4_t)xmmword_192491E90, a1.f32[0])));
  _S0 = v11.i32[1];
  __asm { FMLA            S1, S0, V2.S[1] }
  v9 = fminf(_S1 * 4.0, 1.0);
  result.n128_f32[0] = pow(v9, 0.2);
  result.n128_u64[0] = (unint64_t)vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 4uLL), vmul_n_f32(vmul_n_f32(a2, result.n128_f32[0]), 1.0 - (float)(v9 * v9)));
  result.n128_u64[0] = vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_192491F10, (float32x2_t)result.n128_u64[0], 1), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.i8, 0), vmulq_n_f32((float32x4_t)xmmword_192491F00, result.n128_f32[0]))).u64[0];
  result.n128_u32[3] = v12;
  return result;
}

void sub_19228E458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19228EE14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62,uint64_t a63)
{
  void (*a64)(char *);
  char a68;

  a64(&a62);
  _Block_object_dispose(&a68, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__6(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

Class ___ZL25getVNFaceObservationClassv_block_invoke(uint64_t a1)
{
  Class result;

  VisionLibrary();
  result = objc_getClass("VNFaceObservation");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL25getVNFaceObservationClassv_block_invoke_cold_1();
  getVNFaceObservationClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t VisionLibrary(void)
{
  void *v1;
  __int128 v2;
  uint64_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v1 = 0;
  if (!VisionLibraryCore(char **)::frameworkLibrary)
  {
    v2 = xmmword_1E2EC38B8;
    v3 = 0;
    VisionLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  if (!VisionLibraryCore(char **)::frameworkLibrary)
    VisionLibrary(&v1);
  return VisionLibraryCore(char **)::frameworkLibrary;
}

{
  void *v1;
  __int128 v2;
  uint64_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v1 = 0;
  if (!VisionLibraryCore(char **)::frameworkLibrary)
  {
    v2 = xmmword_1E2EC4F20;
    v3 = 0;
    VisionLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  if (!VisionLibraryCore(char **)::frameworkLibrary)
    VisionLibrary(&v1);
  return VisionLibraryCore(char **)::frameworkLibrary;
}

Class ___ZL42getVNTrackLegacyFaceCoreObjectRequestClassv_block_invoke(uint64_t a1)
{
  Class result;

  VisionLibrary();
  result = objc_getClass("VNTrackLegacyFaceCoreObjectRequest");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL42getVNTrackLegacyFaceCoreObjectRequestClassv_block_invoke_cold_1();
  getVNTrackLegacyFaceCoreObjectRequestClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)
                                                                          + 40);
  return result;
}

Class ___ZL37getVNDetectFaceRectanglesRequestClassv_block_invoke(uint64_t a1)
{
  Class result;

  VisionLibrary();
  result = objc_getClass("VNDetectFaceRectanglesRequest");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL37getVNDetectFaceRectanglesRequestClassv_block_invoke_cold_1();
  getVNDetectFaceRectanglesRequestClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class ___ZL29getVNImageRequestHandlerClassv_block_invoke(uint64_t a1)
{
  Class result;

  VisionLibrary();
  result = objc_getClass("VNImageRequestHandler");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL29getVNImageRequestHandlerClassv_block_invoke_cold_1();
  getVNImageRequestHandlerClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

void sub_1922910A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

double addPoints(CIVector *a1, CIVector *a2, CGRect a3, float a4, float a5)
{
  CGFloat height;
  CGFloat width;
  double y;
  double x;
  uint64_t v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  CGFloat v18;
  CGFloat v19;
  CGFloat v20;
  CGFloat v21;
  double v22;
  double v24;
  CGRect v25;
  CGRect v26;
  CGRect v27;
  CGRect v28;

  height = a3.size.height;
  width = a3.size.width;
  y = a3.origin.y;
  x = a3.origin.x;
  v11 = 0;
  v12 = a4;
  v24 = a5;
  v13 = 1.0;
  do
  {
    -[CIVector valueAtIndex:](a1, "valueAtIndex:", v11);
    v15 = v14;
    -[CIVector valueAtIndex:](a2, "valueAtIndex:", v11);
    v17 = v15 * v12;
    if (fabs(v17 + v13) > 0.001)
    {
      v18 = x;
      v19 = y;
      v20 = width;
      v21 = height;
      v22 = v16 * v24;
      if (fabs(v16 * v24 + 1.0) <= 0.001)
      {
        height = v21;
        width = v20;
        y = v19;
        x = v18;
      }
      else
      {
        v25.origin.x = v18;
        v25.origin.y = v19;
        v25.size.width = v20;
        v25.size.height = v21;
        if (CGRectIsNull(v25))
        {
          x = v17 + -0.5;
          y = v22 + -0.5;
          width = 1.0;
          height = 1.0;
        }
        else
        {
          v28.size.width = 1.0;
          v28.size.height = 1.0;
          v26.origin.x = v18;
          v26.origin.y = v19;
          v26.size.width = v20;
          v26.size.height = v21;
          v28.origin.x = v17 + -0.5;
          v28.origin.y = v22 + -0.5;
          v27 = CGRectUnion(v26, v28);
          x = v27.origin.x;
          y = v27.origin.y;
          width = v27.size.width;
          height = v27.size.height;
        }
      }
      v13 = 1.0;
    }
    ++v11;
  }
  while (v11 != 4);
  return x;
}

void sub_19229185C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n64 cikernel::_CIFaceMaskApply(uint64_t a1, uint64_t a2, float32x4_t a3, float64x2_t a4, float32x4_t a5, float32x4_t a6, int8x16_t a7, uint8x8_t a8, int32x2_t a9, int8x16_t a10)
{
  double v13;
  float32x4_t v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  double v18;
  float64x2_t v19;
  double v20;
  int8x16_t v21;
  float32x4_t v22;
  double v23;
  uint8x8_t v24;
  int8x16_t v25;
  double v26;
  float64x2_t v27;
  double v28;
  int8x16_t v29;
  __int128 v30;
  double v31;
  uint8x8_t v32;
  int8x16_t v33;
  double v34;
  float64x2_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  double v39;
  double v40;
  int8x16_t v41;
  float64x2_t v42;
  uint8x8_t v43;
  double v44;
  int8x16_t v45;
  double v46;
  CI *v47;
  float32x2_t *DC;
  int32x2_t v49;
  float32x2_t *v50;
  double v51;
  double v52;
  uint8x8_t v53;
  int8x16_t v54;
  double v55;
  float64x2_t v56;
  double v57;
  int8x16_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  BOOL v62;
  BOOL v63;
  BOOL v64;
  BOOL v65;
  double v67;
  double v75;
  double v78;
  double v81;
  float32x4_t v82;
  double v83;
  float v84;
  float v85;
  float v86;
  float32x4_t v87;
  double v88;
  double v89;
  double v90;
  double v91;
  float v92;
  float v93;
  double v94;
  float v95;
  double v96;
  float v97;
  double v98;
  float v99;
  float v100;
  float v101;
  float v102;
  __n64 result;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float v109;
  float32x4_t v110;
  __int128 v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float v115;
  float32x4_t v116;

  v109 = *(float *)a7.i32;
  v112 = a5;
  v113 = a6;
  v106 = (float32x4_t)a4;
  a5.i32[0] = *(_DWORD *)(a2 + 28);
  *(float *)&v13 = *(float *)(a2 + 24)
                 + (float)((float)(*(float *)(a2 + 20) * 0.5) + (float)(*(float *)(a2 + 16) * 0.5));
  a6.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)a4.f64 = a6.f32[0] + (float)((float)(*(float *)(a2 + 32) * 0.5) + (float)(a5.f32[0] * 0.5));
  *((float *)&v13 + 1) = *(float *)a4.f64;
  *(double *)v14.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v13, a4, *(double *)a5.i64, *(double *)a6.i64, a7, a8, *(double *)&a9, a10);
  v116 = v14;
  LODWORD(v15) = *(_DWORD *)(a2 + 28);
  v16.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v17.i32 = *(float *)(a2 + 32) * 0.5;
  *(float *)&v18 = *(float *)v17.i32 + (float)(*(float *)&v15 * 1.5);
  v14.f32[0] = *(float *)(a2 + 24) + (float)((float)(*(float *)(a2 + 20) * 0.5) + (float)(*(float *)(a2 + 16) * 1.5));
  *(float *)v19.f64 = *(float *)v16.i32 + *(float *)&v18;
  v14.f32[1] = *(float *)v16.i32 + *(float *)&v18;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v14.i64, v19, v18, v15, v17, v16, v20, v21);
  v114 = v22;
  LODWORD(v23) = *(_DWORD *)(a2 + 28);
  v24.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v25.i32 = *(float *)(a2 + 32) * 0.5;
  *(float *)&v26 = *(float *)v25.i32 + (float)(*(float *)&v23 * 2.5);
  v22.f32[0] = *(float *)(a2 + 24) + (float)((float)(*(float *)(a2 + 20) * 0.5) + (float)(*(float *)(a2 + 16) * 2.5));
  *(float *)v27.f64 = *(float *)v24.i32 + *(float *)&v26;
  v22.f32[1] = *(float *)v24.i32 + *(float *)&v26;
  *(double *)&v30 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v22.i64, v27, v26, v23, v25, v24, v28, v29);
  v111 = v30;
  LODWORD(v31) = *(_DWORD *)(a2 + 28);
  v32.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v33.i32 = *(float *)(a2 + 32) * 0.5;
  *(float *)&v34 = *(float *)v33.i32 + (float)(*(float *)&v31 * 3.5);
  *(float *)&v30 = *(float *)(a2 + 24)
                 + (float)((float)(*(float *)(a2 + 20) * 0.5) + (float)(*(float *)(a2 + 16) * 3.5));
  *(float *)v35.f64 = *(float *)v32.i32 + *(float *)&v34;
  *((float *)&v30 + 1) = *(float *)v32.i32 + *(float *)&v34;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v30, v35, v34, v31, v33, v32, v36, v37);
  v108 = v38;
  LODWORD(v39) = 4.5;
  LODWORD(v40) = *(_DWORD *)(a2 + 28);
  v38.f32[0] = *(float *)(a2 + 24) + (float)((float)(*(float *)(a2 + 20) * 0.5) + (float)(*(float *)(a2 + 16) * 4.5));
  v41.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v42.f64 = *(float *)v41.i32 + (float)((float)(*(float *)(a2 + 32) * 0.5) + (float)(*(float *)&v40 * 4.5));
  v38.f32[1] = *(float *)v42.f64;
  v46 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v38.i64, v42, v39, v40, v41, v43, v44, v45);
  v115 = *(float *)&v46;
  DC = (float32x2_t *)CI::getDC(v47);
  v49 = (int32x2_t)vmul_f32((float32x2_t)a8, *DC);
  v105 = vsubq_f32((float32x4_t)vdupq_lane_s32(v49, 0), a3);
  v107 = vmulq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(v49, 1), v106), v109);
  v110 = vsqrtq_f32(vaddq_f32(vmulq_f32(v105, v105), vmulq_f32(v107, v107)));
  v50 = (float32x2_t *)CI::getDC((CI *)DC);
  *(float *)&v51 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *v50, 1), *(float *)(a1 + 16), COERCE_FLOAT(*v50));
  LODWORD(v52) = *(_DWORD *)(a1 + 28);
  v53.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *v50, 1), *(float *)&v52, COERCE_FLOAT(*v50));
  *(float *)&v55 = *(float *)(a1 + 24) + *(float *)&v51;
  *(float *)v56.f64 = *(float *)v53.i32 + *(float *)v54.i32;
  *((float *)&v55 + 1) = *(float *)v53.i32 + *(float *)v54.i32;
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v55, v56, v51, v52, v54, v53, v57, v58);
  v60 = vaddq_f32(vmulq_f32(v112, v105), vmulq_f32(v113, v107));
  v61 = vdivq_f32(vabdq_f32(vmulq_f32(v112, v107), vmulq_f32(v113, v105)), vaddq_f32(vabsq_f32(v60), (float32x4_t)vdupq_n_s32(0x2EDBE6FFu)));
  v62 = v112.f32[0] != 0.0 || v113.f32[0] != 0.0;
  if (v60.f32[0] < 0.0)
    v62 = 0;
  if (v61.f32[0] >= 1.5574)
    v62 = 0;
  v63 = v112.f32[1] != 0.0 || v113.f32[1] != 0.0;
  if (v60.f32[1] < 0.0)
    v63 = 0;
  if (v61.f32[1] >= 1.5574)
    v63 = 0;
  v64 = v112.f32[2] != 0.0 || v113.f32[2] != 0.0;
  if (v60.f32[2] < 0.0)
    v64 = 0;
  if (v61.f32[2] >= 1.5574)
    v64 = 0;
  v65 = v112.f32[3] != 0.0 || v113.f32[3] != 0.0;
  if (v60.f32[3] < 0.0)
    v65 = 0;
  if (v61.f32[3] >= 1.5574)
    v65 = 0;
  _S2 = v110.i32[1];
  v67 = 0.0;
  _V16.D[1] = *((_QWORD *)&v111 + 1);
  _S5 = DWORD1(v111);
  __asm { FMLA            S3, S2, V16.S[1] }
  v75 = _S3;
  if (_NF != _VF)
    v75 = 0.0;
  _S3 = v110.i32[2];
  __asm { FMLA            S5, S3, V16.S[2] }
  v78 = _S5;
  if (_NF != _VF)
    v78 = 0.0;
  _S5 = v110.i32[3];
  __asm { FMLA            S6, S5, V16.S[3] }
  v81 = _S6;
  if (_NF != _VF)
    v81 = 0.0;
  v82 = vaddq_f32(v114, vmulq_f32(v116, v110));
  v83 = vmlas_n_f32((float)-*(float *)&v111 * v108.f32[0], *(float *)&v111, v110.f32[0]);
  if ((vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgeq_f32(v110, v108))).u8[0] & 1) == 0)
    v67 = v83;
  v84 = v67 + v82.f32[0];
  v85 = v75 + v82.f32[1];
  v86 = v78 + v82.f32[2];
  v87 = vmaxnmq_f32((float32x4_t)vdupq_lane_s32(a9, 0), vaddq_f32(vmulq_f32(v61, (float32x4_t)vdupq_n_s32(0x3F8872B0u)), vmulq_f32(v61, vmulq_f32(v61, (float32x4_t)vdupq_n_s32(0xBE8D4FDF)))));
  v88 = vmuls_lane_f32(*(float *)&a9.i32[1], v87, 3);
  v89 = vmuls_lane_f32(*(float *)&a9.i32[1], v87, 2);
  v90 = vmuls_lane_f32(*(float *)&a9.i32[1], *(float32x2_t *)v87.f32, 1);
  v91 = vmuls_lane_f32(v87.f32[0], (float32x2_t)a9, 1);
  v92 = v81 + v82.f32[3];
  if (v84 <= 0.0 || !v62)
    v91 = 1.0;
  v93 = v91 * v84;
  if (v85 > 0.0 && v63)
    v94 = v90;
  else
    v94 = 1.0;
  v95 = v94 * v85;
  if (v86 > 0.0 && v64)
    v96 = v89;
  else
    v96 = 1.0;
  v97 = v96 * v86;
  if (v92 > 0.0 && v65)
    v98 = v88;
  else
    v98 = 1.0;
  v99 = vmulq_f32(v59, v59).f32[0];
  v100 = v98 * v92;
  v101 = v99 + fminf(fminf(v93, v95), fminf(v97, v100));
  v102 = fmaxf(v115, v99);
  if (v101 <= v102)
    v102 = v101;
  if (v101 < 0.0)
    v102 = 0.0;
  result.n64_f32[0] = sqrtf(v102);
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_sr_f4_f4_f4_f4_f_sr_f2_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, float, double, double);
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  double *v27;
  double *v28;
  __n128 *v29;
  __n128 *v30;
  __n128 *v31;
  __n128 *v32;
  __n128 *v33;
  __int128 v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  double (*v39)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, float, double, double);
  uint64_t v40;
  int v41;
  uint64_t v42;
  uint64_t v43;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, float, double, double))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  v17 = *(_DWORD *)(v10 + 88);
  v18 = *(_QWORD *)(v10 + 80);
  v19 = *(_DWORD *)(v10 + 112);
  v20 = *(_QWORD *)(v10 + 104);
  v21 = *(_QWORD *)(v10 + 128);
  v22 = *(_QWORD *)(v10 + 152);
  v23 = *(_DWORD *)(v10 + 184);
  v24 = *(_QWORD *)(v10 + 176);
  v25 = *(_DWORD *)(v10 + 208);
  v26 = *(_QWORD *)(v10 + 200);
  if (*(_BYTE *)(a1 + 64))
  {
    v39 = *(double (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128, float, double, double))(a1 + 24);
    v40 = *(_QWORD *)(v10 + 56);
    v42 = *(_QWORD *)(v10 + 152);
    v43 = *(_QWORD *)(v10 + 8);
    v41 = *(_DWORD *)(v10 + 40);
    v38 = *(_QWORD *)(v10 + 80);
    v36 = *(_DWORD *)(v10 + 184);
    v37 = *(_DWORD *)(v10 + 112);
    v35 = *(_DWORD *)(v10 + 208);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 224)), a2);
    v25 = v35;
    v23 = v36;
    v19 = v37;
    v18 = v38;
    v11 = v39;
    v16 = v40;
    v22 = v42;
    v12 = v43;
    v13 = v41;
  }
  v27 = (double *)(a3 + 16 * v26);
  if (v25 != 5)
    v27 = (double *)((char *)a2 + 64 * v26);
  v28 = (double *)(a3 + 16 * v24);
  if (v23 != 5)
    v28 = (double *)((char *)a2 + 64 * v24);
  v29 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5)
    v29 = (__n128 *)((char *)a2 + 64 * v20);
  v30 = (__n128 *)(a3 + 16 * v18);
  v31 = (__n128 *)((char *)a2 + 64 * v18);
  if (v17 != 5)
    v30 = v31;
  v32 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v32 = (__n128 *)((char *)a2 + 64 * v16);
  v33 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v33 = (__n128 *)((char *)a2 + 64 * v14);
  *(double *)&v34 = v11(a4 + 80 * v12, a4 + 80 * v22, *v33, *v32, *v30, *v29, *((float *)a2 + 16 * v21), *v28, *v27);
  *(_OWORD *)(a3 + 16 * a7) = v34;
}

void cikernel::_faceMaskCalculator(uint64_t a1, float32x4_t a2, float64x2_t a3, double a4, double a5, int8x16_t a6, int8x16_t a7, double a8, int8x16_t a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, double a17, float a18, float a19, float a20,float a21)
{
  double v29;
  float32x2_t v30;
  double v31;
  float32x2_t v32;
  double v33;
  float32x2_t v34;
  double v35;
  double v36;
  float32x2_t v37;
  double v38;
  float32x2_t v39;
  double v40;
  float32x2_t v41;
  double v42;
  float32x4_t v44;

  v44 = (float32x4_t)a3;
  if (a18 > 0.0)
  {
    LODWORD(a4) = *(_DWORD *)(a1 + 28);
    *(float *)&v29 = *(float *)(a1 + 24)
                   + vmlas_n_f32(*(float *)(a1 + 20) * *(float *)a3.f64, *(float *)(a1 + 16), a2.f32[0]);
    LODWORD(a5) = *(_DWORD *)(a1 + 36);
    *(float *)a3.f64 = *(float *)&a5 + vmlas_n_f32(*(float *)(a1 + 32) * *(float *)a3.f64, *(float *)&a4, a2.f32[0]);
    HIDWORD(v29) = LODWORD(a3.f64[0]);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v29, a3, a4, a5, (int8x16_t)v44, *(uint8x8_t *)a2.f32, a8, a9);
  }
  if (a19 > 0.0)
  {
    v30.i32[0] = *(_DWORD *)(a1 + 16);
    LODWORD(a3.f64[0]) = *(_DWORD *)(a1 + 20);
    LODWORD(v31) = *(_DWORD *)(a1 + 24);
    HIDWORD(a3.f64[0]) = *(_DWORD *)(a1 + 32);
    v30.i32[1] = *(_DWORD *)(a1 + 28);
    *(float32x2_t *)&a3.f64[0] = vmla_lane_f32(vmul_lane_f32(*(float32x2_t *)&a3.f64[0], *(float32x2_t *)v44.f32, 1), v30, *(float32x2_t *)a2.f32, 1);
    HIDWORD(v31) = *(_DWORD *)(a1 + 36);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v31, *(float32x2_t *)&a3.f64[0])), a3, v31, *(double *)a2.i64, a6, *(uint8x8_t *)a7.i8, a8, a9);
  }
  if (a20 > 0.0)
  {
    v32.i32[0] = *(_DWORD *)(a1 + 16);
    LODWORD(a3.f64[0]) = *(_DWORD *)(a1 + 20);
    LODWORD(v33) = *(_DWORD *)(a1 + 24);
    HIDWORD(a3.f64[0]) = *(_DWORD *)(a1 + 32);
    v32.i32[1] = *(_DWORD *)(a1 + 28);
    *(float32x2_t *)&a3.f64[0] = vmla_laneq_f32(vmul_laneq_f32(*(float32x2_t *)&a3.f64[0], v44, 2), v32, a2, 2);
    HIDWORD(v33) = *(_DWORD *)(a1 + 36);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v33, *(float32x2_t *)&a3.f64[0])), a3, v33, *(double *)a2.i64, a6, *(uint8x8_t *)a7.i8, a8, a9);
  }
  if (a21 > 0.0)
  {
    v34.i32[0] = *(_DWORD *)(a1 + 16);
    LODWORD(a3.f64[0]) = *(_DWORD *)(a1 + 20);
    LODWORD(v35) = *(_DWORD *)(a1 + 24);
    HIDWORD(a3.f64[0]) = *(_DWORD *)(a1 + 32);
    v34.i32[1] = *(_DWORD *)(a1 + 28);
    *(float32x2_t *)&a3.f64[0] = vmla_laneq_f32(vmul_laneq_f32(*(float32x2_t *)&a3.f64[0], v44, 3), v34, a2, 3);
    HIDWORD(v35) = *(_DWORD *)(a1 + 36);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v35, *(float32x2_t *)&a3.f64[0])), a3, v35, *(double *)a2.i64, a6, *(uint8x8_t *)a7.i8, a8, a9);
  }
  if (a18 > 0.0)
  {
    LODWORD(a4) = *(_DWORD *)(a1 + 28);
    *(float *)&v36 = *(float *)(a1 + 24)
                   + vmlas_n_f32(*(float *)(a1 + 20) * *(float *)a7.i32, *(float *)(a1 + 16), *(float *)a6.i32);
    LODWORD(a5) = *(_DWORD *)(a1 + 36);
    *(float *)a3.f64 = *(float *)&a5
                     + vmlas_n_f32(*(float *)(a1 + 32) * *(float *)a7.i32, *(float *)&a4, *(float *)a6.i32);
    HIDWORD(v36) = LODWORD(a3.f64[0]);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v36, a3, a4, a5, a7, *(uint8x8_t *)a6.i8, a8, a9);
  }
  if (a19 > 0.0)
  {
    v37.i32[0] = *(_DWORD *)(a1 + 16);
    LODWORD(a3.f64[0]) = *(_DWORD *)(a1 + 20);
    LODWORD(v38) = *(_DWORD *)(a1 + 24);
    HIDWORD(a3.f64[0]) = *(_DWORD *)(a1 + 32);
    v37.i32[1] = *(_DWORD *)(a1 + 28);
    *(float32x2_t *)&a3.f64[0] = vmla_lane_f32(vmul_lane_f32(*(float32x2_t *)&a3.f64[0], *(float32x2_t *)a7.i8, 1), v37, *(float32x2_t *)a6.i8, 1);
    HIDWORD(v38) = *(_DWORD *)(a1 + 36);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v38, *(float32x2_t *)&a3.f64[0])), a3, v38, *(double *)a6.i64, a6, *(uint8x8_t *)a7.i8, a8, a9);
  }
  if (a20 > 0.0)
  {
    v39.i32[0] = *(_DWORD *)(a1 + 16);
    LODWORD(a3.f64[0]) = *(_DWORD *)(a1 + 20);
    LODWORD(v40) = *(_DWORD *)(a1 + 24);
    HIDWORD(a3.f64[0]) = *(_DWORD *)(a1 + 32);
    v39.i32[1] = *(_DWORD *)(a1 + 28);
    *(float32x2_t *)&a3.f64[0] = vmla_laneq_f32(vmul_laneq_f32(*(float32x2_t *)&a3.f64[0], (float32x4_t)a7, 2), v39, (float32x4_t)a6, 2);
    HIDWORD(v40) = *(_DWORD *)(a1 + 36);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v40, *(float32x2_t *)&a3.f64[0])), a3, v40, *(double *)a6.i64, a6, *(uint8x8_t *)a7.i8, a8, a9);
  }
  if (a21 > 0.0)
  {
    v41.i32[0] = *(_DWORD *)(a1 + 16);
    LODWORD(a3.f64[0]) = *(_DWORD *)(a1 + 20);
    LODWORD(v42) = *(_DWORD *)(a1 + 24);
    HIDWORD(a3.f64[0]) = *(_DWORD *)(a1 + 32);
    v41.i32[1] = *(_DWORD *)(a1 + 28);
    *(float32x2_t *)&a3.f64[0] = vmla_laneq_f32(vmul_laneq_f32(*(float32x2_t *)&a3.f64[0], (float32x4_t)a7, 3), v41, (float32x4_t)a6, 3);
    HIDWORD(v42) = *(_DWORD *)(a1 + 36);
    CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v42, *(float32x2_t *)&a3.f64[0])), a3, v42, *(double *)a6.i64, a6, *(uint8x8_t *)a7.i8, a8, a9);
  }
  CI::getDC((CI *)a1);
  cikernel::_computeFaceMaskParams();
}

void cikernel::_computeFaceMaskParams()
{
  __asm { FMOV            V19.4S, #1.0 }
}

uint64_t imageByApplyingOrientationInverse(void *a1, uint64_t a2)
{
  _OWORD v4[3];

  if ((a2 - 5) <= 3)
    a2 = dword_192494A20[(int)a2 - 5];
  if (a1)
    objc_msgSend(a1, "imageTransformForOrientation:", a2);
  else
    memset(v4, 0, sizeof(v4));
  return objc_msgSend(a1, "imageByApplyingTransform:", v4);
}

double segmentationCentroidInImage(void *a1, void *a2, void *a3)
{
  uint64_t v6;
  id v7;
  unsigned __int8 v8;
  double v9;
  CGFloat v10;
  CGFloat v11;
  CGFloat v12;
  CGFloat v13;
  double x;
  double width;
  double v16;
  double v17;
  id v19;
  int v20;
  float v21;
  const __CFString *v22;
  uint64_t v23;
  const __CFString *v24;
  _QWORD v25[2];
  CGRect v26;
  CGRect v27;

  v25[1] = *MEMORY[0x1E0C80C00];
  v24 = CFSTR("inputExtent");
  v25[0] = +[CIVector vectorWithCGRect:](CIVector, "vectorWithCGRect:");
  v6 = objc_msgSend(a2, "imageByApplyingFilter:withInputParameters:", CFSTR("CIAreaRedCentroid"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v25, &v24, 1));
  v22 = CFSTR("working_color_space");
  v23 = objc_msgSend(MEMORY[0x1E0C99E38], "null");
  v7 = +[CIContext _cachedContext:options:](CIContext, "_cachedContext:options:", CFSTR("CIFaceUtils-segmentationCentroid"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v23, &v22, 1));
  if ((v8 & 1) == 0)
  {
    v19 = v7;
    v7 = v19;
    if (v20)
    {
      segmentationCentroidInImage::cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA00]);
      v7 = v19;
    }
  }
  objc_msgSend(v7, "render:toBitmap:rowBytes:bounds:format:colorSpace:", v6, &v21, 32, 2312, segmentationCentroidInImage::cs, 0.0, 0.0, 1.0, 1.0);
  v9 = v21;
  if (a3)
  {
    objc_msgSend(a1, "boundingBox");
    CIVNRectInOrientedImage(a3, v10, v11, v12, v13);
    v27 = CGRectIntegral(v26);
    x = v27.origin.x;
    width = v27.size.width;
    objc_msgSend(a2, "extent");
    v17 = v16;
    objc_msgSend(a2, "extent");
    return x + v9 / v17 * width;
  }
  return v9;
}

void sub_1922934AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double constellationRectInSegmentationRect(void *a1, void *a2, void *a3, unint64_t a4)
{
  CGFloat v7;
  CGFloat v8;
  CGFloat v9;
  CGFloat v10;
  double x;
  double y;
  double width;
  double height;
  id v15;
  double v16;
  double v17;
  double v18;
  double result;
  CGRect v20;
  CGRect v21;
  CGRect v22;
  CGRect v23;

  objc_msgSend(a3, "boundingBox");
  CIVNRectInOrientedImage(a1, v7, v8, v9, v10);
  v21 = CGRectIntegral(v20);
  x = v21.origin.x;
  y = v21.origin.y;
  width = v21.size.width;
  height = v21.size.height;
  v15 = CIVNLandmarkInOrientedImage(a2, a1);
  v22.origin.x = CIVNBoundingRect(v15);
  v23 = CGRectIntegral(v22);
  v16 = (float)a4;
  v17 = v16 / width;
  v18 = v16 / height;
  v23.origin.x = v17 * (v23.origin.x - x);
  v23.origin.y = v18 * (v23.origin.y - y);
  v23.size.width = v17 * v23.size.width;
  v23.size.height = v18 * v23.size.height;
  *(_QWORD *)&result = (unint64_t)CGRectIntegral(v23);
  return result;
}

void *probabilitiesForSegment(void *a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;
  __CVBuffer *v8;
  CIImage *v9;
  void *v10;
  void *result;
  uint64_t v12;
  const __CFString *v13;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  v6 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v7 = 0;
  v12 = 0;
  do
  {
    if (((1 << v7) & a2) != 0)
    {
      objc_msgSend(a1, "boundingBox");
      v8 = (__CVBuffer *)objc_msgSend(a1, "createProbabilityImageOfFaceSegment:region:normalize:error:", 1 << v7, 1, &v12);
      v9 = +[CIImage imageWithCVPixelBuffer:](CIImage, "imageWithCVPixelBuffer:", v8);
      CVPixelBufferRelease(v8);
      if ((_DWORD)a3)
      {
        v10 = (void *)imageByApplyingOrientationInverse(v9, a3);
        v13 = CFSTR("Orientation");
        v14[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a3);
        v9 = (CIImage *)objc_msgSend(v10, "imageBySettingProperties:", objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v14, &v13, 1));
      }
      result = 0;
      if (v12 || !v9)
        return result;
      objc_msgSend(v6, "addObject:", v9);
    }
    ++v7;
  }
  while (v7 != 15);
  return v6;
}

CVPixelBufferRef convertToFullFloatPixelBuffer(void *a1, double a2, double a3, double a4, double a5)
{
  int v8;
  int v9;
  double v10;
  int v11;
  double v12;
  int v13;
  size_t v14;
  uint64_t v16;
  double v17;
  vImagePixelCount v18;
  double v19;
  vImagePixelCount v20;
  size_t v21;
  double v22;
  int v23;
  double v24;
  void *v25;
  void *v26;
  CVPixelBufferRef PixelBuffer;
  vImage_Buffer v28;
  vImage_Buffer src;

  v8 = objc_msgSend(a1, "format");
  v9 = objc_msgSend(a1, "format");
  if (v8 == 2309)
  {
    if (v9 != 2309)
      convertToFullFloatPixelBuffer_cold_1();
    objc_msgSend(a1, "region");
    v11 = (int)-v10;
    objc_msgSend(a1, "region");
    v13 = (int)-v12;
    v14 = objc_msgSend(a1, "bytesPerRow");
    return createPixelBuffer((unint64_t)a4, (unint64_t)a5, v14, (char *)(objc_msgSend(a1, "baseAddress") + v14 * v13 + 4 * v11));
  }
  else
  {
    if (v9 != 2053)
      return 0;
    if (objc_msgSend(a1, "format") != 2053)
      convertToFullFloatPixelBuffer_cold_2();
    v16 = objc_msgSend(a1, "baseAddress");
    objc_msgSend(a1, "region");
    v18 = (unint64_t)v17;
    objc_msgSend(a1, "region");
    v20 = (unint64_t)v19;
    v21 = objc_msgSend(a1, "bytesPerRow");
    objc_msgSend(a1, "region");
    v23 = (int)-v22;
    objc_msgSend(a1, "region");
    v25 = (void *)(v16 + v21 * (int)-v24 + 2 * v23);
    v26 = malloc_type_malloc(4 * (unint64_t)a4 * (unint64_t)a5, 0x100004052888210uLL);
    src.data = v25;
    src.height = v20;
    src.width = v18;
    src.rowBytes = v21;
    v28.data = v26;
    v28.height = (unint64_t)a5;
    v28.width = (unint64_t)a4;
    v28.rowBytes = 4 * (unint64_t)a4;
    vImageConvert_Planar16FtoPlanarF(&src, &v28, 0);
    PixelBuffer = createPixelBuffer((unint64_t)a4, (unint64_t)a5, 4 * (unint64_t)a4, (char *)v26);
    free(v26);
    return PixelBuffer;
  }
}

CVPixelBufferRef createPixelBuffer(size_t a1, size_t a2, size_t a3, char *a4)
{
  uint64_t v8;
  CVReturn v9;
  CVPixelBufferRef result;
  char *BaseAddress;
  size_t BytesPerRow;
  size_t v13;
  size_t v14;
  size_t v15;
  unsigned int v16;
  CVPixelBufferRef pixelBuffer;
  _QWORD v18[2];
  _QWORD v19[3];

  v19[2] = *MEMORY[0x1E0C80C00];
  v19[0] = MEMORY[0x1E0C9AA70];
  v8 = *MEMORY[0x1E0CA9040];
  v18[0] = *MEMORY[0x1E0CA8FF0];
  v18[1] = v8;
  v19[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", 1278226534);
  pixelBuffer = 0;
  v9 = CVPixelBufferCreate(0, a1, a2, 0x4C303066u, (CFDictionaryRef)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v19, v18, 2), &pixelBuffer);
  result = 0;
  if (!v9)
  {
    if (!a4)
      goto LABEL_14;
    if (CVPixelBufferLockBaseAddress(pixelBuffer, 0))
      goto LABEL_17;
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(pixelBuffer);
    BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
    if (BytesPerRow == a3)
    {
      memcpy(BaseAddress, a4, a3 * a2);
    }
    else if (BytesPerRow >= a3)
    {
      NSLog(CFSTR("Can't work with an image where there are more bytes in the source than in the destination."));
      CVPixelBufferRelease(pixelBuffer);
      pixelBuffer = 0;
    }
    else
    {
      v13 = CVPixelBufferGetBytesPerRow(pixelBuffer);
      if (a2)
      {
        v14 = v13;
        v15 = 0;
        v16 = 1;
        do
        {
          memcpy(&BaseAddress[v15 * v14], &a4[v15 * a3], v14);
          v15 = v16++;
        }
        while (v15 < a2);
      }
    }
    if (CVPixelBufferUnlockBaseAddress(pixelBuffer, 0))
    {
LABEL_17:
      CVPixelBufferRelease(pixelBuffer);
      pixelBuffer = 0;
    }
    else
    {
LABEL_14:
      if (pixelBuffer && CVPixelBufferGetPixelFormatType(pixelBuffer) == 1278226534)
        return pixelBuffer;
    }
    createPixelBuffer_cold_1();
  }
  return result;
}

void sub_192297778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  char a69;

  _Block_object_dispose(&a69, 8);
  _Unwind_Resume(a1);
}

void appendAttrStr(NSMutableAttributedString *a1, NSString *a2)
{
  id v4;
  id v5;

  v4 = objc_alloc(MEMORY[0x1E0CB3498]);
  v5 = (id)objc_msgSend(v4, "initWithString:attributes:", a2, MEMORY[0x1E0C9AA70]);
  -[NSMutableAttributedString appendAttributedString:](a1, "appendAttributedString:", v5);

}

void appendAttrStrCode(NSMutableAttributedString *a1, NSString *a2)
{
  uint64_t v3;
  id v4;

  v4 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3498]), "initWithMarkdownString:options:baseURL:error:", v3, 0, 0, 0);
  -[NSMutableAttributedString appendAttributedString:](a1, "appendAttributedString:", v4);

}

double pointGetter(void *a1, SEL aSelector)
{
  NSString *v3;
  const __CFString *v4;
  uint64_t v5;
  double v6;
  void *v7;
  double v8;

  v3 = NSStringFromSelector(aSelector);
  if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("parameterB")))
  {
    v4 = CFSTR("inputB");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("parameterC")))
  {
    v4 = CFSTR("inputC");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("underColorRemoval")))
  {
    v4 = CFSTR("inputUCR");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("grayComponentReplacement")))
  {
    v4 = CFSTR("inputGCR");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("textureImage")))
  {
    v4 = CFSTR("inputTexture");
  }
  else
  {
    v4 = (const __CFString *)objc_msgSend(CFSTR("input"), "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v3, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v3, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  v5 = objc_msgSend(a1, "valueForKey:", v4);
  v6 = 0.0;
  if (v5)
  {
    v7 = (void *)v5;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      objc_msgSend(v7, "CGPointValue");
      return v8;
    }
  }
  return v6;
}

uint64_t pointSetter(void *a1, const char *a2)
{
  return objc_msgSend(a1, "setValue:forKey:", +[CIVector vectorWithCGPoint:](CIVector, "vectorWithCGPoint:"), keyForSetter(a2));
}

const __CFString *keyForSetter(const char *a1)
{
  NSString *v1;
  NSString *v3;

  v1 = NSStringFromSelector(a1);
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("setBackgroundImage:")))
    return CFSTR("inputBackgroundImage");
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("setMaskImage:")))
    return CFSTR("inputMaskImage");
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("setSmallImage:")))
    return CFSTR("inputSmallImage");
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("setTargetImage:")))
    return CFSTR("inputTargetImage");
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("setBacksideImage:")))
    return CFSTR("inputBacksideImage");
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("setShadingImage:")))
    return CFSTR("inputShadingImage");
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("setGradientImage:")))
    return CFSTR("inputGradientImage");
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("setPaletteImage:")))
    return CFSTR("inputPaletteImage");
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("setTextureImage:")))
    return CFSTR("inputTexture");
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("setParameterB:")))
    return CFSTR("inputB");
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("setParameterC:")))
    return CFSTR("inputC");
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("setUnderColorRemoval:")))
    return CFSTR("inputUCR");
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("setGrayComponentReplacement:")))
    return CFSTR("inputGCR");
  v3 = -[NSString stringByReplacingCharactersInRange:withString:](v1, "stringByReplacingCharactersInRange:withString:", 0, 3, CFSTR("input"));
  return (const __CFString *)-[NSString substringWithRange:](v3, "substringWithRange:", 0, -[NSString length](v3, "length") - 1);
}

void *iiGetter(void *a1)
{
  void *outValue;

  outValue = 0;
  object_getInstanceVariable(a1, "inputImage", &outValue);
  return outValue;
}

Ivar iiSetter(void *a1, uint64_t a2, void *a3)
{
  id v5;
  id v6;
  void *outValue;

  outValue = 0;
  object_getInstanceVariable(a1, "inputImage", &outValue);
  v5 = outValue;
  v6 = a3;
  return object_setInstanceVariable(a1, "inputImage", a3);
}

uint64_t objGetter(void *a1, SEL aSelector)
{
  NSString *v3;
  const __CFString *v4;

  v3 = NSStringFromSelector(aSelector);
  if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("parameterB")))
  {
    v4 = CFSTR("inputB");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("parameterC")))
  {
    v4 = CFSTR("inputC");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("underColorRemoval")))
  {
    v4 = CFSTR("inputUCR");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("grayComponentReplacement")))
  {
    v4 = CFSTR("inputGCR");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("textureImage")))
  {
    v4 = CFSTR("inputTexture");
  }
  else
  {
    v4 = (const __CFString *)objc_msgSend(CFSTR("input"), "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v3, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v3, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  return objc_msgSend(a1, "valueForKey:", v4);
}

uint64_t objSetter(void *a1, const char *a2, uint64_t a3)
{
  return objc_msgSend(a1, "setValue:forKey:", a3, keyForSetter(a2));
}

float floatGetter(void *a1, SEL aSelector)
{
  NSString *v3;
  const __CFString *v4;
  uint64_t v5;
  void *v6;
  float result;

  v3 = NSStringFromSelector(aSelector);
  if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("parameterB")))
  {
    v4 = CFSTR("inputB");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("parameterC")))
  {
    v4 = CFSTR("inputC");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("underColorRemoval")))
  {
    v4 = CFSTR("inputUCR");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("grayComponentReplacement")))
  {
    v4 = CFSTR("inputGCR");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("textureImage")))
  {
    v4 = CFSTR("inputTexture");
  }
  else
  {
    v4 = (const __CFString *)objc_msgSend(CFSTR("input"), "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v3, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v3, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  v5 = objc_msgSend(a1, "valueForKey:", v4);
  if (!v5)
    return NAN;
  v6 = (void *)v5;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
    return NAN;
  objc_msgSend(v6, "floatValue");
  return result;
}

uint64_t floatSetter(void *a1, const char *a2)
{
  return objc_msgSend(a1, "setValue:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:"), keyForSetter(a2));
}

uint64_t BOOLGetter(void *a1, SEL aSelector)
{
  NSString *v3;
  const __CFString *v4;
  uint64_t v5;
  void *v6;

  v3 = NSStringFromSelector(aSelector);
  if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("parameterB")))
  {
    v4 = CFSTR("inputB");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("parameterC")))
  {
    v4 = CFSTR("inputC");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("underColorRemoval")))
  {
    v4 = CFSTR("inputUCR");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("grayComponentReplacement")))
  {
    v4 = CFSTR("inputGCR");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("textureImage")))
  {
    v4 = CFSTR("inputTexture");
  }
  else
  {
    v4 = (const __CFString *)objc_msgSend(CFSTR("input"), "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v3, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v3, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  v5 = objc_msgSend(a1, "valueForKey:", v4);
  if (v5 && (v6 = (void *)v5, objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    return objc_msgSend(v6, "BOOLValue");
  else
    return 0;
}

uint64_t BOOLSetter(void *a1, const char *a2)
{
  return objc_msgSend(a1, "setValue:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:"), keyForSetter(a2));
}

double rectGetter(void *a1, SEL aSelector)
{
  NSString *v3;
  const __CFString *v4;
  uint64_t v5;
  void *v6;
  double result;

  v3 = NSStringFromSelector(aSelector);
  if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("parameterB")))
  {
    v4 = CFSTR("inputB");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("parameterC")))
  {
    v4 = CFSTR("inputC");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("underColorRemoval")))
  {
    v4 = CFSTR("inputUCR");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("grayComponentReplacement")))
  {
    v4 = CFSTR("inputGCR");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("textureImage")))
  {
    v4 = CFSTR("inputTexture");
  }
  else
  {
    v4 = (const __CFString *)objc_msgSend(CFSTR("input"), "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v3, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v3, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  v5 = objc_msgSend(a1, "valueForKey:", v4);
  if (!v5)
    return *MEMORY[0x1E0C9D628];
  v6 = (void *)v5;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
    return *MEMORY[0x1E0C9D628];
  objc_msgSend(v6, "CGRectValue");
  return result;
}

uint64_t rectSetter(void *a1, const char *a2)
{
  return objc_msgSend(a1, "setValue:forKey:", +[CIVector vectorWithCGRect:](CIVector, "vectorWithCGRect:"), keyForSetter(a2));
}

uint64_t transformGetter@<X0>(SEL aSelector@<X1>, void *a2@<X0>, uint64_t a3@<X8>)
{
  NSString *v5;
  const __CFString *v6;
  uint64_t result;
  uint64_t v8;
  __int128 v9;
  void *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v5 = NSStringFromSelector(aSelector);
  if (-[NSString isEqualToString:](v5, "isEqualToString:", CFSTR("parameterB")))
  {
    v6 = CFSTR("inputB");
  }
  else if (-[NSString isEqualToString:](v5, "isEqualToString:", CFSTR("parameterC")))
  {
    v6 = CFSTR("inputC");
  }
  else if (-[NSString isEqualToString:](v5, "isEqualToString:", CFSTR("underColorRemoval")))
  {
    v6 = CFSTR("inputUCR");
  }
  else if (-[NSString isEqualToString:](v5, "isEqualToString:", CFSTR("grayComponentReplacement")))
  {
    v6 = CFSTR("inputGCR");
  }
  else if (-[NSString isEqualToString:](v5, "isEqualToString:", CFSTR("textureImage")))
  {
    v6 = CFSTR("inputTexture");
  }
  else
  {
    v6 = (const __CFString *)objc_msgSend(CFSTR("input"), "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v5, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v5, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  result = objc_msgSend(a2, "valueForKey:", v6);
  v8 = MEMORY[0x1E0C9BAA8];
  v9 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
  *(_OWORD *)a3 = *MEMORY[0x1E0C9BAA8];
  *(_OWORD *)(a3 + 16) = v9;
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v8 + 32);
  if (result)
  {
    v10 = (void *)result;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v11 = (const char *)objc_msgSend(v10, "objCType");
      if (!strcmp(v11, "{CGAffineTransform=dddddd}"))
        return objc_msgSend(v10, "getValue:size:", a3, 48);
      result = strcmp(v11, "{?=dddddd}");
      if (!(_DWORD)result)
        return objc_msgSend(v10, "getValue:size:", a3, 48);
    }
    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        result = objc_msgSend(v10, "transformStruct");
        *(_OWORD *)a3 = 0u;
        *(_OWORD *)(a3 + 16) = 0u;
        *(_OWORD *)(a3 + 32) = 0u;
      }
      else
      {
        objc_opt_class();
        result = objc_opt_isKindOfClass();
        if ((result & 1) != 0)
        {
          result = objc_msgSend(v10, "count");
          if (result == 6)
          {
            objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 0), "doubleValue");
            *(_QWORD *)a3 = v12;
            objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 1), "doubleValue");
            *(_QWORD *)(a3 + 8) = v13;
            objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 2), "doubleValue");
            *(_QWORD *)(a3 + 16) = v14;
            objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 3), "doubleValue");
            *(_QWORD *)(a3 + 24) = v15;
            objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 4), "doubleValue");
            *(_QWORD *)(a3 + 32) = v16;
            result = objc_msgSend((id)objc_msgSend(v10, "objectAtIndex:", 5), "doubleValue");
            *(_QWORD *)(a3 + 40) = v17;
          }
        }
      }
    }
  }
  return result;
}

uint64_t transformSetter(void *a1, const char *a2, uint64_t a3)
{
  return objc_msgSend(a1, "setValue:forKey:", objc_msgSend(MEMORY[0x1E0CB3B18], "valueWithBytes:objCType:", a3, "{CGAffineTransform=dddddd}"), keyForSetter(a2));
}

uint64_t intGetter(void *a1, SEL aSelector)
{
  NSString *v3;
  const __CFString *v4;
  uint64_t v5;
  void *v6;

  v3 = NSStringFromSelector(aSelector);
  if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("parameterB")))
  {
    v4 = CFSTR("inputB");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("parameterC")))
  {
    v4 = CFSTR("inputC");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("underColorRemoval")))
  {
    v4 = CFSTR("inputUCR");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("grayComponentReplacement")))
  {
    v4 = CFSTR("inputGCR");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("textureImage")))
  {
    v4 = CFSTR("inputTexture");
  }
  else
  {
    v4 = (const __CFString *)objc_msgSend(CFSTR("input"), "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v3, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v3, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  v5 = objc_msgSend(a1, "valueForKey:", v4);
  if (v5 && (v6 = (void *)v5, objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    return objc_msgSend(v6, "integerValue");
  else
    return 0;
}

uint64_t intSetter(void *a1, const char *a2)
{
  return objc_msgSend(a1, "setValue:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:"), keyForSetter(a2));
}

uint64_t uintGetter(void *a1, SEL aSelector)
{
  NSString *v3;
  const __CFString *v4;
  uint64_t v5;
  void *v6;

  v3 = NSStringFromSelector(aSelector);
  if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("parameterB")))
  {
    v4 = CFSTR("inputB");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("parameterC")))
  {
    v4 = CFSTR("inputC");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("underColorRemoval")))
  {
    v4 = CFSTR("inputUCR");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("grayComponentReplacement")))
  {
    v4 = CFSTR("inputGCR");
  }
  else if (-[NSString isEqualToString:](v3, "isEqualToString:", CFSTR("textureImage")))
  {
    v4 = CFSTR("inputTexture");
  }
  else
  {
    v4 = (const __CFString *)objc_msgSend(CFSTR("input"), "stringByAppendingString:", -[NSString stringByReplacingCharactersInRange:withString:](v3, "stringByReplacingCharactersInRange:withString:", 0, 1, -[NSString uppercaseString](-[NSString substringWithRange:](v3, "substringWithRange:", 0, 1), "uppercaseString")));
  }
  v5 = objc_msgSend(a1, "valueForKey:", v4);
  if (v5 && (v6 = (void *)v5, objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    return objc_msgSend(v6, "unsignedIntegerValue");
  else
    return 0;
}

uint64_t uintSetter(void *a1, const char *a2)
{
  return objc_msgSend(a1, "setValue:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:"), keyForSetter(a2));
}

void sub_1922C0AE0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1922C0BEC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1922C1000(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1922C1250(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1922C1434(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1922C1544(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1922C1658(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1922C19DC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1922C1AD8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

const char *__enableFilterInterposing_block_invoke()
{
  const char *result;

  result = getenv("CI_ENABLE_FILTER_INTERPOSING");
  if (result)
  {
    result = (const char *)atoi(result);
    enableFilterInterposing_enableFilterposing = (_DWORD)result != 0;
  }
  return result;
}

uint64_t bundleForCIFilter(void)
{
  unsigned __int8 v0;

  {
    bundleForCIFilter(void)::b = (uint64_t)(id)objc_msgSend(MEMORY[0x1E0CB34D0], "bundleForClass:", objc_opt_class());
  }
  return bundleForCIFilter(void)::b;
}

void sub_1922C2330(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t classIsBuiltinFilter(objc_class *a1)
{
  uint64_t result;
  uint64_t v3;

  result = -[objc_class isSubclassOfClass:](a1, "isSubclassOfClass:", objc_opt_class());
  if ((_DWORD)result)
  {
    v3 = objc_msgSend(MEMORY[0x1E0CB34D0], "bundleForClass:", a1);
    return v3 == bundleForCIFilter();
  }
  return result;
}

void __Block_byref_object_copy__8(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t classIsSystemFilter(objc_class *a1)
{
  uint64_t result;
  NSString *v3;

  result = -[objc_class isSubclassOfClass:](a1, "isSubclassOfClass:", objc_opt_class());
  if ((_DWORD)result)
  {
    v3 = NSStringFromClass(a1);
    return classNameIsSystemFilter(v3);
  }
  return result;
}

void ___ZL22register_more_builtinsU13block_pointerFvP8NSStringE_block_invoke_724()
{
  NSObject *v0;
  uint8_t v1[16];

  v0 = ci_signpost_log_filter();
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1921E4000, v0, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "LoadMoreFilters", (const char *)&unk_192520C83, v1, 2u);
  }
}

void ___ZL22register_more_builtinsU13block_pointerFvP8NSStringE_block_invoke_737(uint64_t a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v2 = ci_signpost_log_filter();
  v3 = *(_QWORD *)(a1 + 40);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      v5 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 32), "lastPathComponent"), "UTF8String");
      v6 = 136446210;
      v7 = v5;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "LoadFilter", "%{public}s", (uint8_t *)&v6, 0xCu);
    }
  }
}

void ___ZL22register_more_builtinsU13block_pointerFvP8NSStringE_block_invoke_742(uint64_t a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v2 = ci_signpost_log_filter();
  v3 = *(_QWORD *)(a1 + 40);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      v5 = objc_msgSend((id)objc_msgSend(*(id *)(a1 + 32), "lastPathComponent"), "UTF8String");
      v6 = 136446210;
      v7 = v5;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "BundleLoad", "%{public}s", (uint8_t *)&v6, 0xCu);
    }
  }
}

double cikernel::_flashColor(CI *a1, float32x4_t a2, float32x4_t a3, float32x2_t a4, float32x4_t a5, __n128 a6, float32x4_t a7, double a8)
{
  float32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  int32x2_t v11;
  float v12;
  float v13;
  float v15;
  float v16;
  float32x4_t v17;
  double result;

  v8 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a4);
  v10 = (int32x2_t)vmul_f32(v8, v8);
  v11 = (int32x2_t)vadd_f32((float32x2_t)v10, (float32x2_t)vdup_lane_s32(v10, 1));
  v12 = 1.0 - vmuls_lane_f32(sqrtf(vaddv_f32((float32x2_t)v10)), a7, 2);
  if (v12 <= 1.0)
    v13 = v12;
  else
    v13 = 1.0;
  _NF = v12 < 0.0;
  v15 = 0.0;
  if (_NF)
    v13 = 0.0;
  v16 = a6.n128_f32[3];
  if (a6.n128_f32[0] <= a6.n128_f32[3])
    v16 = a6.n128_f32[0];
  if (a6.n128_f32[0] >= 0.0)
    v15 = v16;
  *(float *)v9.i32 = vmlas_n_f32(*((float *)&a8 + 1), v15, *(float *)&a8);
  v17 = vmaxnmq_f32(vmulq_n_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(v9, 0), vdivq_f32(vmulq_lane_f32(a5, *(float32x2_t *)a7.f32, 1), (float32x4_t)vdupq_lane_s32(v11, 0))), v13), (float32x4_t)0);
  __asm { FMOV            V3.4S, #1.0 }
  *(_QWORD *)&result = vmlaq_laneq_f32(vmulq_n_f32(vminnmq_f32(vmaxnmq_f32(vaddq_f32(a2, vminnmq_f32(v17, _Q3)), (float32x4_t)0), _Q3), 1.0 - a7.f32[3]), a3, a7, 3).u64[0];
  return result;
}

void CI::f4_s_s_f2_clr_s_f4_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, double, __n128, __n128, __n128, double);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  double *v24;
  __n128 *v25;
  __n128 *v26;
  double *v27;
  __n128 *v28;
  __n128 *v29;
  __int128 v30;
  int v31;
  int v32;
  int v33;
  double (*v34)(__n128, __n128, double, __n128, __n128, __n128, double);
  int v35;
  int v36;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, double, __n128, __n128, __n128, double))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_QWORD *)(v9 + 80);
  v18 = *(_DWORD *)(v9 + 112);
  v19 = *(_QWORD *)(v9 + 104);
  v20 = *(_DWORD *)(v9 + 136);
  v21 = *(_QWORD *)(v9 + 128);
  v22 = *(_DWORD *)(v9 + 160);
  v23 = *(_QWORD *)(v9 + 152);
  if (*(_BYTE *)(a1 + 64))
  {
    v34 = *(double (**)(__n128, __n128, double, __n128, __n128, __n128, double))(a1 + 24);
    v32 = *(_DWORD *)(v9 + 16);
    v33 = *(_DWORD *)(v9 + 112);
    v35 = *(_DWORD *)(v9 + 64);
    v36 = *(_DWORD *)(v9 + 40);
    v31 = *(_DWORD *)(v9 + 160);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 176)), a2);
    v22 = v31;
    v11 = v32;
    v18 = v33;
    v15 = v35;
    v13 = v36;
    v10 = v34;
  }
  v24 = (double *)(a3 + 16 * v23);
  if (v22 != 5)
    v24 = (double *)((char *)a2 + 64 * v23);
  v25 = (__n128 *)(a3 + 16 * v21);
  if (v20 != 5)
    v25 = (__n128 *)((char *)a2 + 64 * v21);
  v26 = (__n128 *)(a3 + 16 * v19);
  if (v18 != 5)
    v26 = (__n128 *)((char *)a2 + 64 * v19);
  v27 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v27 = (double *)((char *)a2 + 64 * v16);
  v28 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v28 = (__n128 *)((char *)a2 + 64 * v14);
  v29 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v29 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v30 = v10(*v29, *v28, *v27, *((__n128 *)a2 + 4 * v17), *v26, *v25, *v24);
  *(_OWORD *)(a3 + 16 * a7) = v30;
}

float32x2_t cikernel::_flashGeom(CI *a1, float32x2_t a2)
{
  float32x2_t v2;
  int32x2_t v3;

  v2 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v3 = (int32x2_t)vmul_f32(v2, v2);
  *(float *)v3.i32 = sqrtf(vaddv_f32((float32x2_t)v3));
  return vadd_f32(vdiv_f32(vmul_f32(v2, (float32x2_t)vdup_n_s32(0x42C80000u)), (float32x2_t)vdup_lane_s32(v3, 0)), (float32x2_t)0x4300000043000000);
}

void CI::f2_f2(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, double);
  int v12;
  uint64_t v13;
  double *v14;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, double))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 32)), a2);
  v14 = (double *)(a3 + 16 * v13);
  if (v12 != 5)
    v14 = (double *)((char *)a2 + 64 * v13);
  *(double *)(a3 + 16 * a7) = v11(a1, *v14);
}

__n64 cikernel::_disparityRefinementPreprocessing(float32x4_t a1, float32x4_t a2, float32x4_t a3, __n128 a4, double a5)
{
  float v5;
  float v6;
  float v7;
  __n64 result;
  float v17;
  float v18;

  v18 = a1.f32[0];
  LODWORD(v17) = vsubq_f32(a1, a3).u32[0];
  v5 = powf(fmaxf(fabsf(v17), 0.0001), a4.n128_f32[1]);
  v6 = expf((float)-v5 / a4.n128_f32[2]) * a4.n128_f32[0];
  if (v6 <= *(float *)&a5)
    v7 = v6;
  else
    v7 = *(float *)&a5;
  if (v6 >= a4.n128_f32[3])
    _S0 = v7;
  else
    _S0 = a4.n128_f32[3];
  _S3 = v17;
  __asm { FMLS            S1, S0, V3.S[0] }
  if ((vmovn_s32(vcgtq_f32(a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 1))).u8[0] & 1) != 0)
    result.n64_f32[0] = _S1;
  else
    result.n64_f32[0] = v18;
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_s_s_s_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, __n128);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  __n128 *v21;
  __n128 *v22;
  __n128 *v23;
  __n128 *v24;
  __n128 *v25;
  __int128 v26;
  int v27;
  int v28;
  int v29;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  v19 = *(_DWORD *)(v9 + 112);
  v20 = *(_QWORD *)(v9 + 104);
  if (*(_BYTE *)(a1 + 64))
  {
    v28 = *(_DWORD *)(v9 + 88);
    v29 = *(_DWORD *)(v9 + 40);
    v27 = *(_DWORD *)(v9 + 64);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
    v15 = v27;
    v17 = v28;
    v13 = v29;
  }
  v21 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5)
    v21 = (__n128 *)((char *)a2 + 64 * v20);
  v22 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v22 = (__n128 *)((char *)a2 + 64 * v18);
  v23 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v23 = (__n128 *)((char *)a2 + 64 * v16);
  v24 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v24 = (__n128 *)((char *)a2 + 64 * v14);
  v25 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v25 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v26 = v10(*v25, *v24, *v23, *v22, *v21);
  *(_OWORD *)(a3 + 16 * a7) = v26;
}

__n64 cikernel::_disparityRefinementPreprocessingPow2(float32x4_t a1, float32x4_t a2, float32x4_t a3, __n128 a4, double a5)
{
  float v5;
  float v6;
  float v7;
  __n64 result;
  float v16;
  float v18;
  float v19;

  v16 = a4.n128_f32[3];
  v19 = a1.f32[0];
  LODWORD(v18) = vsubq_f32(a1, a3).u32[0];
  v5 = fmaxf(fabsf(v18), 0.0001);
  v6 = expf((float)-(float)(v5 * v5) / a4.n128_f32[2]) * a4.n128_f32[0];
  if (v6 <= *(float *)&a5)
    v7 = v6;
  else
    v7 = *(float *)&a5;
  if (v6 >= v16)
    _S0 = v7;
  else
    _S0 = v16;
  _S3 = v18;
  __asm { FMLS            S1, S0, V3.S[0] }
  if ((vmovn_s32(vcgtq_f32(a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 1))).u8[0] & 1) != 0)
    result.n64_f32[0] = _S1;
  else
    result.n64_f32[0] = v19;
  result.n64_u32[1] = 0;
  return result;
}

double cikernel::_fusionDelta(float32x4_t a1, int8x16_t a2, int8x16_t a3, float a4, float32x4_t a5)
{
  float v5;
  float v6;
  BOOL v7;
  float v8;

  v5 = vmlas_n_f32(*(float *)&a2.i32[1], a1.f32[0], *(float *)a2.i32);
  if (v5 <= 1.0)
    v6 = v5;
  else
    v6 = 1.0;
  v7 = v5 < 0.0;
  a5.i32[0] = 0;
  if (v7)
    v6 = 0.0;
  v8 = vmlas_n_f32(*(float *)&a3.i32[1], a1.f32[0], *(float *)a3.i32);
  if (v8 <= 1.0)
    a1.f32[0] = v8;
  else
    a1.f32[0] = 1.0;
  if (v8 < 0.0)
    a1.f32[0] = 0.0;
  a1.f32[0] = v6 - a1.f32[0];
  a1.f32[0] = a1.f32[0]
            * (float)(fabsf(COERCE_FLOAT(vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)vcgtq_f32(a1, a5), 0), a2, a3).i32[2]))
                    * a4);
  a1.i64[0] = vdupq_lane_s32(*(int32x2_t *)a1.f32, 0).u64[0];
  return *(double *)a1.i64;
}

void CI::f4_s_f3_f3_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, __n128, float);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 *v17;
  __int128 v18;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, __n128, float))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_QWORD *)(v10 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
  v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v18 = v11(a1, *v17, *((__n128 *)a2 + 4 * v14), *((__n128 *)a2 + 4 * v15), *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_fusionTwoImages(float32x4_t a1, float32x4_t a2, int8x16_t a3, int8x16_t a4, float a5, float a6, float32x4_t a7)
{
  float v7;
  float v8;
  BOOL v9;
  float v10;
  float v11;
  float v12;
  float32x4_t v13;
  double result;

  v7 = vmlas_n_f32(*(float *)&a3.i32[1], a2.f32[0], *(float *)a3.i32);
  if (v7 <= 1.0)
    v8 = v7;
  else
    v8 = 1.0;
  v9 = v7 < 0.0;
  a7.i32[0] = 0;
  if (v9)
    v8 = 0.0;
  v10 = vmlas_n_f32(*(float *)&a4.i32[1], a2.f32[0], *(float *)a4.i32);
  if (v10 <= 1.0)
    v11 = v10;
  else
    v11 = 1.0;
  if (v10 >= 0.0)
    v12 = v11;
  else
    v12 = 0.0;
  v13 = vsubq_f32(a1, a2);
  v13.f32[0] = (float)(1.0 - (float)(fmaxf(v13.f32[0], 0.0) * a5)) * (float)(v8 - v12);
  v13.f32[0] = v13.f32[0]
             * (float)(fabsf(COERCE_FLOAT(vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)vcgtq_f32(v13, a7), 0), a3, a4).i32[2]))
                     * a6);
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)v13.f32, 0).u64[0];
  return result;
}

void CI::f4_s_s_f3_f3_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, float, float);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __n128 *v19;
  __n128 *v20;
  __int128 v21;
  int v22;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, float, float))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_QWORD *)(v9 + 80);
  v17 = *(_QWORD *)(v9 + 104);
  v18 = *(_QWORD *)(v9 + 128);
  if (*(_BYTE *)(a1 + 64))
  {
    v22 = *(_DWORD *)(v9 + 40);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 152)), a2);
    v13 = v22;
  }
  v19 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v14);
  v20 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v21 = v10(*v20, *v19, *((__n128 *)a2 + 4 * v15), *((__n128 *)a2 + 4 * v16), *((float *)a2 + 16 * v17), *((float *)a2 + 16 * v18));
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

double sizeForStringWithAttributes(CFStringRef str, CFDictionaryRef attributes)
{
  const __CFAttributedString *v2;
  const __CTFramesetter *v3;
  double v4;
  CFRange v6;
  CGSize v7;

  v2 = CFAttributedStringCreate(0, str, attributes);
  v3 = CTFramesetterCreateWithAttributedString(v2);
  v6.length = CFAttributedStringGetLength(v2);
  v7.width = 1.79769313e308;
  v6.location = 0;
  v7.height = 1.79769313e308;
  *(_QWORD *)&v4 = *(_OWORD *)&CTFramesetterSuggestFrameSizeWithConstraints(v3, v6, 0, v7, 0);
  CFRelease(v3);
  CFRelease(v2);
  return v4;
}

CGColorRef CGColorCreateWithHex(unint64_t a1)
{
  unsigned __int8 v2;
  int8x16_t v3;
  float64x2_t v4;
  int8x16_t v5;
  uint64x2_t v6;
  float64x2_t v7;
  _OWORD v9[2];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  {
    CGColorCreateWithHex(unsigned long)::cs = (uint64_t)CGColorSpaceCreateDeviceRGB();
  }
  v3.i64[0] = 255;
  v3.i64[1] = 255;
  v4 = vcvtq_f64_u64((uint64x2_t)vandq_s8((int8x16_t)vshlq_u64((uint64x2_t)vdupq_n_s64(a1), (uint64x2_t)xmmword_192494BE0), v3));
  v5.i64[0] = a1 >> 8;
  v5.i64[1] = a1;
  v6 = (uint64x2_t)vandq_s8(v5, v3);
  v7 = (float64x2_t)vdupq_n_s64(0x406FE00000000000uLL);
  v9[0] = vdivq_f64(v4, v7);
  v9[1] = vdivq_f64(vcvtq_f64_u64(v6), v7);
  return CGColorCreate((CGColorSpaceRef)CGColorCreateWithHex(unsigned long)::cs, (const CGFloat *)v9);
}

void sub_1922C7ED8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CGContextDrawAttributedString(CGContext *a1, CFAttributedStringRef attrString, CGRect a3)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  const __CTFramesetter *v9;
  CFIndex Length;
  const CGPath *v11;
  const __CTFrame *Frame;
  CFRange v13;
  CGRect v14;

  height = a3.size.height;
  width = a3.size.width;
  y = a3.origin.y;
  x = a3.origin.x;
  v9 = CTFramesetterCreateWithAttributedString(attrString);
  Length = CFAttributedStringGetLength(attrString);
  v14.origin.x = x;
  v14.origin.y = y;
  v14.size.width = width;
  v14.size.height = height;
  v11 = CGPathCreateWithRect(v14, 0);
  v13.location = 0;
  v13.length = Length;
  Frame = CTFramesetterCreateFrame(v9, v13, v11, 0);
  CTFrameDraw(Frame, a1);
  CFRelease(v9);
  CFRelease(Frame);
  CFRelease(v11);
}

void patternCallback(void *a1, CGContextRef c)
{
  CGRect v3;
  CGRect v4;
  CGRect v5;
  CGRect v6;

  CGContextSetGrayFillColor(c, 1.0, 1.0);
  v3.origin.x = 0.0;
  v3.origin.y = 0.0;
  v3.size.width = 8.0;
  v3.size.height = 8.0;
  CGContextFillRect(c, v3);
  v4.origin.x = 8.0;
  v4.origin.y = 8.0;
  v4.size.width = 8.0;
  v4.size.height = 8.0;
  CGContextFillRect(c, v4);
  CGContextSetGrayFillColor(c, 0.8, 1.0);
  v5.origin.x = 8.0;
  v5.origin.y = 0.0;
  v5.size.width = 8.0;
  v5.size.height = 8.0;
  CGContextFillRect(c, v5);
  v6.origin.x = 0.0;
  v6.origin.y = 8.0;
  v6.size.width = 8.0;
  v6.size.height = 8.0;
  CGContextFillRect(c, v6);
}

CGFloat CGCubicSplineGetControlPoints(CGPoint a1, CGPoint a2, CGPoint a3, CGPoint a4, CGPoint *a5, CGPoint *a6)
{
  double x;
  double v9;
  double v10;
  double v11;
  CGFloat v12;
  double v13;
  CGFloat v14;
  long double v15;
  double v16;
  double v17;
  long double v18;
  double v19;
  long double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  long double v26;
  double v27;
  long double v28;
  long double v29;
  double v30;
  long double v31;
  long double v32;
  CGFloat v33;
  CGFloat result;
  double v35;
  double v36;
  double y;
  double v38;
  double v39;
  double v40;

  y = a4.y;
  v38 = a2.y;
  x = a4.x;
  v9 = a3.y;
  v10 = a3.x;
  v11 = a2.y;
  v12 = a2.x - a1.x;
  v13 = a2.x;
  v40 = a2.x;
  v14 = a2.y - a1.y;
  v15 = hypot(a2.x - a1.x, a2.y - a1.y);
  v39 = v10;
  v35 = v12 / v15;
  v36 = v14 / v15;
  v16 = hypot(v10 - v13, v9 - v11);
  v17 = (v10 - v13) / v16;
  v18 = x - v10;
  v19 = (v9 - v11) / v16;
  v20 = hypot(v18, y - v9);
  v21 = v18 / v20;
  v22 = (y - v9) / v20;
  v23 = fabs(v17);
  v24 = fabs(v21);
  if (v23 >= v24)
    v25 = v21;
  else
    v25 = (v10 - v13) / v16;
  if (v23 >= v24)
    v26 = v22;
  else
    v26 = v19;
  v27 = fabs(v35);
  if (v27 >= v23)
    v28 = v17;
  else
    v28 = v35;
  if (v27 >= v23)
    v29 = v19;
  else
    v29 = v36;
  v30 = fmin(v16 / 3.0, vabdd_f64(v38, v9));
  v31 = hypot(v25, v26);
  a6->x = v39 - v30 * (v25 / v31);
  a6->y = v9 - v30 * (v26 / v31);
  v32 = hypot(v28, v29);
  v33 = v40 + v30 * (v28 / v32);
  result = v38 + v30 * (v29 / v32);
  a5->x = v33;
  a5->y = result;
  return result;
}

void sub_1922C9440(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CIImage *blurImage(CIImage *a1, double a2, double a3)
{
  int v6;
  int v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double v20;
  CGFloat v21;
  double v22;
  CGFloat v23;
  double v24;
  CGFloat v25;
  double v26;
  CGFloat v27;
  double v28;
  double v29;
  double v30;
  double v31;
  CIKernel *v32;
  CGFloat v33;
  CGFloat v34;
  CGFloat v35;
  CGFloat v36;
  double v37;
  CGFloat v38;
  double v39;
  CGFloat v40;
  double v41;
  CGFloat v42;
  double v43;
  CGFloat v44;
  double v45;
  double v46;
  double v47;
  double v48;
  CIKernel *v49;
  double v50;
  double v51;
  double v52;
  CGFloat v53;
  CGFloat v54;
  CGFloat v55;
  CGFloat v56;
  double v57;
  CGFloat v58;
  double v59;
  CGFloat v60;
  double v61;
  CGFloat v62;
  double v63;
  CGFloat v64;
  double v65;
  double v66;
  double v67;
  double v68;
  CIKernel *v69;
  CGFloat v70;
  CGFloat v71;
  CGFloat v72;
  CGFloat v73;
  double v74;
  CGFloat v75;
  double v76;
  CGFloat v77;
  double v78;
  CGFloat v79;
  double v80;
  CGFloat v81;
  double v82;
  double v83;
  double v84;
  double v85;
  CIKernel *v86;
  double v87;
  int v88;
  double v89;
  double v90;
  int v91;
  BOOL v92;
  CIVector *v93;
  CIVector *v94;
  CIVector *v95;
  uint64_t v96;
  CIKernel *v97;
  uint64_t v98;
  CIVector *v99;
  uint64_t v100;
  double v101;
  double v102;
  int v103;
  double v104;
  int v105;
  BOOL v106;
  CIVector *v107;
  CIVector *v108;
  CIVector *v109;
  CIKernel *v110;
  uint64_t v111;
  CIVector *v112;
  uint64_t v113;
  CGFloat v114;
  CGFloat v115;
  CGFloat v116;
  CGFloat v117;
  double v118;
  double v119;
  double v120;
  double v122;
  double v123;
  double v124;
  double v125;
  CIImage *v126;
  double v127;
  double v128;
  double v129;
  float64x2_t v130;
  float64x2_t v131;
  float64x2_t v132;
  float64x2_t v133;
  int64x2_t v134;
  double v135;
  _QWORD v136[4];
  int v137;
  _QWORD v138[4];
  int v139;
  CGAffineTransform v140;
  CGAffineTransform v141;
  CGAffineTransform v142;
  CGAffineTransform v143;
  Rectangle v144;
  Rectangle v145;
  Rectangle v146;
  CIVector *v147;
  CIVector *v148;
  const __CFString *v149;
  CIVector *v150;
  _QWORD v151[2];
  _QWORD v152[3];
  _QWORD v153[3];
  _QWORD v154[3];
  _QWORD v155[4];
  _QWORD v156[4];
  _QWORD v157[4];
  _QWORD v158[6];
  _QWORD v159[2];
  _QWORD v160[3];
  _QWORD v161[3];
  _QWORD v162[3];
  _QWORD v163[4];
  _QWORD v164[4];
  _QWORD v165[4];
  _QWORD v166[6];
  __int128 v167;
  __int128 v168;
  double v169;
  _QWORD v170[2];
  _QWORD v171[2];
  _QWORD v172[2];
  _QWORD v173[4];
  CGRect v174;
  CGRect v175;
  CGRect v176;
  CGRect v177;
  CGRect v178;
  CGRect v179;
  CGRect v180;
  CGRect v181;
  CGRect v182;
  CGRect v183;
  CGRect v184;
  CGRect v185;
  CGRect v186;
  CGRect v187;
  CGRect v188;
  CGRect v189;
  CGRect v190;
  CGRect v191;
  CGRect v192;
  CGRect v193;
  CGRect v194;
  CGRect v195;
  CGRect v196;
  CGRect v197;
  CGRect v198;
  CGRect v199;

  v173[2] = *MEMORY[0x1E0C80C00];
  v6 = dyld_program_sdk_at_least();
  if (!a1)
    return a1;
  v7 = v6;
  v8 = fmin(a2, 10000.0);
  v9 = fmin(a3, 10000.0);
  v147 = 0;
  v148 = 0;
  v10 = v9 * v9;
  v11 = v8 * v8;
  v122 = v9;
  v124 = v8;
  v12 = fmax(v8, v9);
  v13 = 1.0;
  v126 = a1;
  if (v12 < 3.0)
  {
    v128 = v10;
    v14 = 1.0;
    goto LABEL_97;
  }
  v127 = 1.0;
  v132 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  v133 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
  v135 = 1.0;
LABEL_5:
  v129 = v10;
  v10 = (v10 + -9.9225) * 0.0625;
  while (1)
  {
    v15 = (v11 + -9.9225) * 0.0625;
    if (v15 >= 0.358099622)
    {
      if (v7)
      {
        -[CIImage extent](a1, "extent");
        x = v174.origin.x;
        y = v174.origin.y;
        width = v174.size.width;
        height = v174.size.height;
        if (CGRectIsInfinite(v174))
        {
          *(float64x2_t *)&v144.var0 = v133;
          *(float64x2_t *)&v144.var2 = v132;
        }
        else
        {
          v178.origin.x = x;
          v178.origin.y = y;
          v178.size.width = width;
          v178.size.height = height;
          if (CGRectIsNull(v178))
          {
            *(int64x2_t *)&v144.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
            v144.var2 = 0.0;
            v144.var3 = 0.0;
          }
          else
          {
            v144.var0 = x;
            v144.var1 = y;
            v144.var2 = width;
            v144.var3 = height;
          }
        }
        Rectangle::inset(&v144, -7.0, -0.0, (uint64_t)&v145);
        if (fabs(v145.var0) == INFINITY || fabs(v145.var1) == INFINITY)
        {
          *(int64x2_t *)&v146.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
          v146.var2 = 0.0;
          v146.var3 = 0.0;
        }
        else if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)&v145.var0, v133), (int32x4_t)vceqq_f64(*(float64x2_t *)&v145.var2, v132))))) & 1) != 0)
        {
          v146.var0 = v145.var0 * 0.25;
          v146.var1 = v145.var1;
          v146.var2 = 0.25 * v145.var2;
          v146.var3 = v145.var3;
        }
        else
        {
          *(float64x2_t *)&v146.var0 = v133;
          *(float64x2_t *)&v146.var2 = v132;
        }
        Rectangle::integralize(&v146, 0.0001, (uint64_t)&v167);
        v29 = *((double *)&v167 + 1);
        v28 = *(double *)&v167;
        v31 = *((double *)&v168 + 1);
        v30 = *(double *)&v168;
        if (*(double *)&v167 == -8.98846567e307
          && *((double *)&v167 + 1) == -8.98846567e307
          && *(double *)&v168 == 1.79769313e308
          && *((double *)&v168 + 1) == 1.79769313e308)
        {
          v28 = *MEMORY[0x1E0C9D5E0];
          v29 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
          v30 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
          v31 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
        }
      }
      else
      {
        -[CIImage extent](a1, "extent");
        v21 = v20;
        v23 = v22;
        v25 = v24;
        v27 = v26;
        CGAffineTransformMakeScale(&v143, 0.25, 1.0);
        v175.origin.x = v21;
        v175.origin.y = v23;
        v175.size.width = v25;
        v175.size.height = v27;
        v176 = CGRectApplyAffineTransform(v175, &v143);
        v177 = CGRectInset(v176, -4.0, 0.0);
        v28 = v177.origin.x;
        v29 = v177.origin.y;
        v30 = v177.size.width;
        v31 = v177.size.height;
      }
      v32 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianReduce4, *(_QWORD *)&v122, *(_QWORD *)&v124);
      v173[0] = a1;
      v173[1] = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", 4.0, 1.0, 1.0, 0.0);
      a1 = -[CIKernel applyWithExtent:roiCallback:arguments:](v32, "applyWithExtent:roiCallback:arguments:", &__block_literal_global_34, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v173, 2), v28, v29, v30, v31);
      v135 = v135 * 4.0;
      v11 = v15;
      goto LABEL_25;
    }
    if (v10 < 0.358099622)
      break;
LABEL_25:
    if (v10 >= 0.358099622)
    {
      if (v7)
      {
        -[CIImage extent](a1, "extent");
        v33 = v179.origin.x;
        v34 = v179.origin.y;
        v35 = v179.size.width;
        v36 = v179.size.height;
        if (CGRectIsInfinite(v179))
        {
          *(float64x2_t *)&v144.var0 = v133;
          *(float64x2_t *)&v144.var2 = v132;
        }
        else
        {
          v183.origin.x = v33;
          v183.origin.y = v34;
          v183.size.width = v35;
          v183.size.height = v36;
          if (CGRectIsNull(v183))
          {
            *(int64x2_t *)&v144.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
            v144.var2 = 0.0;
            v144.var3 = 0.0;
          }
          else
          {
            v144.var0 = v33;
            v144.var1 = v34;
            v144.var2 = v35;
            v144.var3 = v36;
          }
        }
        Rectangle::inset(&v144, -0.0, -7.0, (uint64_t)&v145);
        if (fabs(v145.var0) == INFINITY || fabs(v145.var1) == INFINITY)
        {
          *(int64x2_t *)&v146.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
          v146.var2 = 0.0;
          v146.var3 = 0.0;
        }
        else if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)&v145.var0, v133), (int32x4_t)vceqq_f64(*(float64x2_t *)&v145.var2, v132))))) & 1) != 0)
        {
          v146.var0 = v145.var0;
          v146.var1 = v145.var1 * 0.25;
          v146.var2 = v145.var2;
          v146.var3 = vmuld_lane_f64(0.25, *(float64x2_t *)&v145.var2, 1);
        }
        else
        {
          *(float64x2_t *)&v146.var0 = v133;
          *(float64x2_t *)&v146.var2 = v132;
        }
        Rectangle::integralize(&v146, 0.0001, (uint64_t)&v167);
        v46 = *((double *)&v167 + 1);
        v45 = *(double *)&v167;
        v48 = *((double *)&v168 + 1);
        v47 = *(double *)&v168;
        if (*(double *)&v167 == -8.98846567e307
          && *((double *)&v167 + 1) == -8.98846567e307
          && *(double *)&v168 == 1.79769313e308
          && *((double *)&v168 + 1) == 1.79769313e308)
        {
          v45 = *MEMORY[0x1E0C9D5E0];
          v46 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
          v47 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
          v48 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
        }
      }
      else
      {
        -[CIImage extent](a1, "extent");
        v38 = v37;
        v40 = v39;
        v42 = v41;
        v44 = v43;
        CGAffineTransformMakeScale(&v142, 1.0, 0.25);
        v180.origin.x = v38;
        v180.origin.y = v40;
        v180.size.width = v42;
        v180.size.height = v44;
        v181 = CGRectApplyAffineTransform(v180, &v142);
        v182 = CGRectInset(v181, 0.0, -4.0);
        v45 = v182.origin.x;
        v46 = v182.origin.y;
        v47 = v182.size.width;
        v48 = v182.size.height;
      }
      v49 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianReduce4, *(_QWORD *)&v122, *(_QWORD *)&v124);
      v172[0] = a1;
      v172[1] = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", 1.0, 4.0, 0.0, 1.0);
      a1 = -[CIKernel applyWithExtent:roiCallback:arguments:](v49, "applyWithExtent:roiCallback:arguments:", &__block_literal_global_64, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v172, 2), v45, v46, v47, v48);
      v127 = v127 * 4.0;
      goto LABEL_5;
    }
  }
  v50 = 0.25;
  v130 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  v131 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
  v134 = vdupq_n_s64(0x7FF0000000000000uLL);
  v51 = v129;
  while (2)
  {
    v128 = v51;
    v51 = (v51 + -3.0625) * v50;
LABEL_50:
    v52 = (v11 + -3.0625) * 0.25;
    if (v52 >= 0.358099622)
    {
      if (v7)
      {
        -[CIImage extent](a1, "extent");
        v53 = v184.origin.x;
        v54 = v184.origin.y;
        v55 = v184.size.width;
        v56 = v184.size.height;
        if (CGRectIsInfinite(v184))
        {
          *(float64x2_t *)&v144.var0 = v131;
          *(float64x2_t *)&v144.var2 = v130;
        }
        else
        {
          v188.origin.x = v53;
          v188.origin.y = v54;
          v188.size.width = v55;
          v188.size.height = v56;
          if (CGRectIsNull(v188))
          {
            *(int64x2_t *)&v144.var0 = v134;
            v144.var2 = 0.0;
            v144.var3 = 0.0;
          }
          else
          {
            v144.var0 = v53;
            v144.var1 = v54;
            v144.var2 = v55;
            v144.var3 = v56;
          }
        }
        Rectangle::inset(&v144, -4.0, -0.0, (uint64_t)&v145);
        if (fabs(v145.var0) == INFINITY || fabs(v145.var1) == INFINITY)
        {
          *(int64x2_t *)&v146.var0 = v134;
          v146.var2 = 0.0;
          v146.var3 = 0.0;
        }
        else if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)&v145.var0, v131), (int32x4_t)vceqq_f64(*(float64x2_t *)&v145.var2, v130))))) & 1) != 0)
        {
          v146.var0 = v145.var0 * 0.5;
          v146.var1 = v145.var1;
          v146.var2 = 0.5 * v145.var2;
          v146.var3 = v145.var3;
        }
        else
        {
          *(float64x2_t *)&v146.var0 = v131;
          *(float64x2_t *)&v146.var2 = v130;
        }
        Rectangle::integralize(&v146, 0.0001, (uint64_t)&v167);
        v66 = *((double *)&v167 + 1);
        v65 = *(double *)&v167;
        v68 = *((double *)&v168 + 1);
        v67 = *(double *)&v168;
        if (*(double *)&v167 == -8.98846567e307
          && *((double *)&v167 + 1) == -8.98846567e307
          && *(double *)&v168 == 1.79769313e308
          && *((double *)&v168 + 1) == 1.79769313e308)
        {
          v65 = *MEMORY[0x1E0C9D5E0];
          v66 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
          v67 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
          v68 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
        }
      }
      else
      {
        -[CIImage extent](a1, "extent");
        v58 = v57;
        v60 = v59;
        v62 = v61;
        v64 = v63;
        CGAffineTransformMakeScale(&v141, 0.5, 1.0);
        v185.origin.x = v58;
        v185.origin.y = v60;
        v185.size.width = v62;
        v185.size.height = v64;
        v186 = CGRectApplyAffineTransform(v185, &v141);
        v187 = CGRectInset(v186, -3.0, 0.0);
        v65 = v187.origin.x;
        v66 = v187.origin.y;
        v67 = v187.size.width;
        v68 = v187.size.height;
      }
      v69 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianReduce2, *(_QWORD *)&v122, *(_QWORD *)&v124);
      v171[0] = a1;
      v171[1] = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", 2.0, 1.0, 1.0, 0.0);
      a1 = -[CIKernel applyWithExtent:roiCallback:arguments:](v69, "applyWithExtent:roiCallback:arguments:", &__block_literal_global_65, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v171, 2), v65, v66, v67, v68);
      v135 = v135 + v135;
      v11 = v52;
LABEL_69:
      if (v51 >= 0.358099622)
      {
        if (v7)
        {
          -[CIImage extent](a1, "extent");
          v70 = v189.origin.x;
          v71 = v189.origin.y;
          v72 = v189.size.width;
          v73 = v189.size.height;
          if (CGRectIsInfinite(v189))
          {
            *(float64x2_t *)&v144.var0 = v131;
            *(float64x2_t *)&v144.var2 = v130;
          }
          else
          {
            v193.origin.x = v70;
            v193.origin.y = v71;
            v193.size.width = v72;
            v193.size.height = v73;
            if (CGRectIsNull(v193))
            {
              *(int64x2_t *)&v144.var0 = v134;
              v144.var2 = 0.0;
              v144.var3 = 0.0;
            }
            else
            {
              v144.var0 = v70;
              v144.var1 = v71;
              v144.var2 = v72;
              v144.var3 = v73;
            }
          }
          Rectangle::inset(&v144, -0.0, -4.0, (uint64_t)&v145);
          if (fabs(v145.var0) == INFINITY || fabs(v145.var1) == INFINITY)
          {
            *(int64x2_t *)&v146.var0 = v134;
            v146.var2 = 0.0;
            v146.var3 = 0.0;
          }
          else if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)&v145.var0, v131), (int32x4_t)vceqq_f64(*(float64x2_t *)&v145.var2, v130))))) & 1) != 0)
          {
            v146.var0 = v145.var0;
            v146.var1 = v145.var1 * 0.5;
            v146.var2 = v145.var2;
            v146.var3 = vmuld_lane_f64(0.5, *(float64x2_t *)&v145.var2, 1);
          }
          else
          {
            *(float64x2_t *)&v146.var0 = v131;
            *(float64x2_t *)&v146.var2 = v130;
          }
          Rectangle::integralize(&v146, 0.0001, (uint64_t)&v167);
          v83 = *((double *)&v167 + 1);
          v82 = *(double *)&v167;
          v85 = *((double *)&v168 + 1);
          v84 = *(double *)&v168;
          if (*(double *)&v167 == -8.98846567e307
            && *((double *)&v167 + 1) == -8.98846567e307
            && *(double *)&v168 == 1.79769313e308
            && *((double *)&v168 + 1) == 1.79769313e308)
          {
            v82 = *MEMORY[0x1E0C9D5E0];
            v83 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
            v84 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
            v85 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
          }
        }
        else
        {
          -[CIImage extent](a1, "extent");
          v75 = v74;
          v77 = v76;
          v79 = v78;
          v81 = v80;
          CGAffineTransformMakeScale(&v140, 1.0, 0.5);
          v190.origin.x = v75;
          v190.origin.y = v77;
          v190.size.width = v79;
          v190.size.height = v81;
          v191 = CGRectApplyAffineTransform(v190, &v140);
          v192 = CGRectInset(v191, 0.0, -3.0);
          v82 = v192.origin.x;
          v83 = v192.origin.y;
          v84 = v192.size.width;
          v85 = v192.size.height;
        }
        v86 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianReduce2, *(_QWORD *)&v122, *(_QWORD *)&v124);
        v170[0] = a1;
        v170[1] = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", 1.0, 2.0, 0.0, 1.0);
        a1 = -[CIKernel applyWithExtent:roiCallback:arguments:](v86, "applyWithExtent:roiCallback:arguments:", &__block_literal_global_66, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v170, 2), v82, v83, v84, v85);
        v127 = v127 + v127;
        v50 = 0.25;
        continue;
      }
      goto LABEL_50;
    }
    break;
  }
  if (v51 >= 0.358099622)
    goto LABEL_69;
  v14 = v135;
  if (v135 > 1.0)
    v11 = v11 + -0.358098622;
  v13 = v127;
  if (v127 > 1.0)
    v128 = v128 + -0.358098622;
LABEL_97:
  if (v11 <= 0.000001)
  {
    v96 = 0;
  }
  else
  {
    v87 = v13;
    v88 = vcvtpd_s64_f64(v11 / 11.1111111);
    v169 = 0.0;
    v167 = 0u;
    v168 = 0u;
    v89 = v11 / (double)v88;
    v90 = v14;
    v91 = narrowBlurParameters(v89, (double *)&v167, &v148, &v147, v14 > 1.0);
    if (v91)
      v92 = a1 == 0;
    else
      v92 = 1;
    if (v92)
    {
      v96 = 0;
    }
    else
    {
      v93 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", *(double *)&v167, 0.0, *((double *)&v167 + 1), 0.0);
      v94 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", *(double *)&v168, 0.0, *((double *)&v168 + 1), 0.0);
      v95 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v169, 0.0, 0.0, 0.0);
      v96 = 0;
      v97 = 0;
      switch(v91)
      {
        case 1:
          v97 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur3);
          v159[0] = a1;
          v159[1] = v93;
          v98 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v159, 2);
          goto LABEL_114;
        case 2:
          v97 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur5);
          v160[0] = a1;
          v160[1] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", 1.0, 0.0);
          v160[2] = v148;
          v98 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v160, 3);
          goto LABEL_114;
        case 3:
          v97 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur7);
          v161[0] = a1;
          v161[1] = v93;
          v161[2] = v148;
          v98 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v161, 3);
          goto LABEL_114;
        case 4:
          v97 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur9);
          v162[0] = a1;
          v162[1] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", 1.0, 0.0);
          v162[2] = v148;
          v98 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v162, 3);
          goto LABEL_114;
        case 5:
          v97 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur11);
          v163[0] = a1;
          v163[1] = v93;
          v163[2] = v94;
          v163[3] = v148;
          v98 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v163, 4);
          goto LABEL_114;
        case 6:
          v97 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur13);
          v164[0] = a1;
          v164[1] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", 1.0, 0.0);
          v164[2] = v148;
          v164[3] = v147;
          v98 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v164, 4);
          goto LABEL_114;
        case 7:
          v97 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur15);
          v165[0] = a1;
          v165[1] = v93;
          v165[2] = v94;
          v165[3] = v148;
          v98 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v165, 4);
          goto LABEL_114;
        case 8:
          break;
        case 9:
          v99 = v95;
          v97 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur19);
          v166[0] = a1;
          v166[1] = v93;
          v166[2] = v94;
          v166[3] = v99;
          v166[4] = v148;
          v166[5] = v147;
          v98 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v166, 6);
LABEL_114:
          v96 = v98;
          break;
        default:
          v97 = 0;
          break;
      }
      if (v88 >= 1)
      {
        v100 = MEMORY[0x1E0C809B0];
        do
        {
          -[CIImage extent](a1, "extent", *(_QWORD *)&v122, *(_QWORD *)&v124);
          v195 = CGRectInset(v194, (double)-v91, 0.0);
          v138[0] = v100;
          v138[1] = 3221225472;
          v138[2] = ___ZL9blurImageP7CIImagedd_block_invoke_5;
          v138[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
          v139 = v91;
          a1 = -[CIKernel applyWithExtent:roiCallback:arguments:](v97, "applyWithExtent:roiCallback:arguments:", v138, v96, v195.origin.x, v195.origin.y, v195.size.width, v195.size.height);
          --v88;
        }
        while (v88);
      }
    }
    v13 = v87;
    v14 = v90;
  }
  v101 = v128;
  if (v128 > 0.000001)
  {
    v102 = v14;
    v103 = vcvtpd_s64_f64(v128 / 11.1111111);
    v169 = 0.0;
    v167 = 0u;
    v168 = 0u;
    v104 = v13;
    v105 = narrowBlurParameters(v128 / (double)v103, (double *)&v167, &v148, &v147, v13 > 1.0);
    if (v105)
      v106 = a1 == 0;
    else
      v106 = 1;
    if (!v106)
    {
      v107 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", 0.0, *(double *)&v167, 0.0, *((double *)&v167 + 1));
      v108 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", 0.0, *(double *)&v168, 0.0, *((double *)&v168 + 1));
      v109 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", 0.0, v169, 0.0, 0.0);
      v110 = 0;
      switch(v105)
      {
        case 1:
          v110 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur3);
          v151[0] = a1;
          v151[1] = v107;
          v111 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v151, 2);
          goto LABEL_133;
        case 2:
          v110 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur5);
          v152[0] = a1;
          v152[1] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", 0.0, 1.0);
          v152[2] = v148;
          v111 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v152, 3);
          goto LABEL_133;
        case 3:
          v110 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur7);
          v153[0] = a1;
          v153[1] = v107;
          v153[2] = v148;
          v111 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v153, 3);
          goto LABEL_133;
        case 4:
          v110 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur9);
          v154[0] = a1;
          v154[1] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", 0.0, 1.0);
          v154[2] = v148;
          v111 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v154, 3);
          goto LABEL_133;
        case 5:
          v110 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur11);
          v155[0] = a1;
          v155[1] = v107;
          v155[2] = v108;
          v155[3] = v148;
          v111 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v155, 4);
          goto LABEL_133;
        case 6:
          v110 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur13);
          v156[0] = a1;
          v156[1] = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", 0.0, 1.0);
          v156[2] = v148;
          v156[3] = v147;
          v111 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v156, 4);
          goto LABEL_133;
        case 7:
          v110 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur15);
          v157[0] = a1;
          v157[1] = v107;
          v157[2] = v108;
          v157[3] = v148;
          v111 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v157, 4);
          goto LABEL_133;
        case 9:
          v112 = v109;
          v110 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_gaussianBlur19);
          v158[0] = a1;
          v158[1] = v107;
          v158[2] = v108;
          v158[3] = v112;
          v158[4] = v148;
          v158[5] = v147;
          v111 = objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v158, 6);
LABEL_133:
          v96 = v111;
          break;
        default:
          break;
      }
      if (v103 >= 1)
      {
        v113 = MEMORY[0x1E0C809B0];
        do
        {
          -[CIImage extent](a1, "extent", *(_QWORD *)&v122, *(_QWORD *)&v124);
          v197 = CGRectInset(v196, 0.0, (double)-v105);
          v136[0] = v113;
          v136[1] = 3221225472;
          v136[2] = ___ZL9blurImageP7CIImagedd_block_invoke_6;
          v136[3] = &__block_descriptor_36_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
          v137 = v105;
          a1 = -[CIKernel applyWithExtent:roiCallback:arguments:](v110, "applyWithExtent:roiCallback:arguments:", v136, v96, v197.origin.x, v197.origin.y, v197.size.width, v197.size.height);
          --v103;
        }
        while (v103);
      }
    }
    v13 = v104;
    v14 = v102;
  }
  if (v14 > 1.0 || v13 > 1.0)
  {
    v149 = CFSTR("inputScale");
    v150 = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v14, v13, v101, *(_QWORD *)&v122, *(_QWORD *)&v124);
    a1 = -[CIImage imageByApplyingFilter:withInputParameters:](a1, "imageByApplyingFilter:withInputParameters:", CFSTR("CISoftCubicUpsample"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v150, &v149, 1));
  }
  -[CIImage extent](v126, "extent", *(_QWORD *)&v122, *(_QWORD *)&v124);
  v114 = v198.origin.x;
  v115 = v198.origin.y;
  v116 = v198.size.width;
  v117 = v198.size.height;
  if (CGRectIsInfinite(v198))
  {
    *(int64x2_t *)&v145.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v145.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v199.origin.x = v114;
    v199.origin.y = v115;
    v199.size.width = v116;
    v199.size.height = v117;
    if (CGRectIsNull(v199))
    {
      *(int64x2_t *)&v145.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
      v145.var2 = 0.0;
      v145.var3 = 0.0;
    }
    else
    {
      v145.var0 = v114;
      v145.var1 = v115;
      v145.var2 = v116;
      v145.var3 = v117;
    }
  }
  Rectangle::inset(&v145, v125 * -3.0, v123 * -3.0, (uint64_t)&v146);
  Rectangle::integralize(&v146, 0.0001, (uint64_t)&v167);
  if (v7)
  {
    if (*(double *)&v167 != -8.98846567e307)
    {
      v120 = *((double *)&v168 + 1);
      v118 = *((double *)&v167 + 1);
      v119 = *(double *)&v168;
      return -[CIImage imageByCroppingToRect:](a1, "imageByCroppingToRect:", *(double *)&v167, v118, v119, v120);
    }
    v118 = *((double *)&v167 + 1);
    v120 = *((double *)&v168 + 1);
    v119 = *(double *)&v168;
    if (*((double *)&v167 + 1) != -8.98846567e307
      || *(double *)&v168 != 1.79769313e308
      || *((double *)&v168 + 1) != 1.79769313e308)
    {
      return -[CIImage imageByCroppingToRect:](a1, "imageByCroppingToRect:", *(double *)&v167, v118, v119, v120);
    }
  }
  return a1;
}

double ___ZL9blurImageP7CIImagedd_block_invoke(double a1, CGFloat a2, double a3, CGFloat a4)
{
  double v7;
  CGRect v9;

  v7 = a1;
  if (!CGRectIsEmpty(*(CGRect *)&a1))
  {
    v9.origin.x = v7 * 4.0 + -7.0;
    v9.size.width = a3 * 4.0 + 14.0;
    v9.origin.y = a2;
    v9.size.height = a4;
    *(_QWORD *)&v7 = (unint64_t)CGRectIntegral(v9);
  }
  return v7;
}

double ___ZL9blurImageP7CIImagedd_block_invoke_2(double a1, double a2, CGFloat a3, double a4)
{
  double v7;
  CGRect v9;

  v7 = a1;
  if (!CGRectIsEmpty(*(CGRect *)&a1))
  {
    v9.origin.y = a2 * 4.0 + -7.0;
    v9.size.height = a4 * 4.0 + 14.0;
    v9.origin.x = v7;
    v9.size.width = a3;
    *(_QWORD *)&v7 = (unint64_t)CGRectIntegral(v9);
  }
  return v7;
}

double ___ZL9blurImageP7CIImagedd_block_invoke_3(double a1, CGFloat a2, double a3, CGFloat a4)
{
  double v7;
  CGRect v9;

  v7 = a1;
  if (!CGRectIsEmpty(*(CGRect *)&a1))
  {
    v9.origin.x = v7 * 2.0 + -4.0;
    v9.size.width = a3 * 2.0 + 8.0;
    v9.origin.y = a2;
    v9.size.height = a4;
    *(_QWORD *)&v7 = (unint64_t)CGRectIntegral(v9);
  }
  return v7;
}

double ___ZL9blurImageP7CIImagedd_block_invoke_4(double a1, double a2, CGFloat a3, double a4)
{
  double v7;
  CGRect v9;

  v7 = a1;
  if (!CGRectIsEmpty(*(CGRect *)&a1))
  {
    v9.origin.y = a2 * 2.0 + -4.0;
    v9.size.height = a4 * 2.0 + 8.0;
    v9.origin.x = v7;
    v9.size.width = a3;
    *(_QWORD *)&v7 = (unint64_t)CGRectIntegral(v9);
  }
  return v7;
}

uint64_t narrowBlurParameters(double a1, double *a2, CIVector **a3, CIVector **a4, char a5)
{
  double v8;
  double v9;
  uint64_t v10;
  double v11;
  double v12;
  uint64_t v13;
  int32x2_t v14;
  int32x2_t v15;
  int64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  uint64_t v19;
  double v20;
  double v21;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t __x;
  long double v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  double v43[3];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v42 = 0u;
  *(_OWORD *)v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v39 = 0u;
  *a4 = 0;
  *a3 = 0;
  v8 = sqrt(a1);
  if ((a5 & 1) != 0)
  {
    if (v8 >= 0.570644)
    {
      v13 = 0;
      v35 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v8 * 2.50662827), 0);
      v36 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v8 * (v8 + v8)), 0);
      v14 = (int32x2_t)0x100000000;
      v9 = 0.00300000003;
      do
      {
        v15 = vadd_s32(v14, (int32x2_t)0x800000008);
        v16.i64[0] = v15.i32[0];
        v16.i64[1] = v15.i32[1];
        v17 = vcvtq_f64_s64(v16);
        __x = vdivq_f64(vmulq_f64(vnegq_f64(v17), v17), v36);
        v38 = exp(__x.f64[1]);
        v18.f64[0] = exp(__x.f64[0]);
        v18.f64[1] = v38;
        *(__int128 *)((char *)&v39 + v13) = (__int128)vdivq_f64(v18, v35);
        v14 = vadd_s32(v14, (int32x2_t)0x200000002);
        v13 += 16;
      }
      while (v13 != 80);
    }
    else
    {
      v43[0] = fmax(v8 * 0.14 + a1 * 0.33 + -0.036442, 0.0);
      v43[1] = v43[0] * -2.0 + 1.0;
      v9 = 0.00300000003;
    }
  }
  else
  {
    v10 = 0;
    v9 = 0.00150000001;
    do
    {
      v11 = fabs((double)((int)v10 - 9));
      v12 = erf((0.5 - v11) * 0.707106781 / v8);
      *((long double *)&v39 + v10++) = (v12 - erf((-0.5 - v11) * 0.707106781 / v8)) * 0.5;
    }
    while (v10 != 10);
  }
  v19 = 0;
  v20 = 0.0;
  while (1)
  {
    v21 = v20 + *((double *)&v39 + v19);
    if (v21 >= v9)
      break;
    *((_QWORD *)&v39 + v19++) = 0;
    v20 = v21;
    if (v19 == 10)
    {
      LODWORD(v19) = -1;
      goto LABEL_15;
    }
  }
  *((double *)&v39 + v19) = v20 + *((double *)&v39 + v19);
  if ((_DWORD)v19 == 9)
    return 0;
LABEL_15:
  if (dyld_program_sdk_at_least())
  {
    switch((_DWORD)v19)
    {
      case 3:
        *a3 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v43[1], v43[0], *((double *)&v42 + 1), *(double *)&v42);
        *a4 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", *((double *)&v41 + 1), *(double *)&v41, *((double *)&v40 + 1), 0.0);
        return 6;
      case 5:
        *a3 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v43[1], v43[0], *((double *)&v42 + 1), *(double *)&v42);
        return 4;
      case 7:
        *a3 = +[CIVector vectorWithX:Y:Z:](CIVector, "vectorWithX:Y:Z:", v43[1], v43[0], *((double *)&v42 + 1));
        return 2;
    }
  }
  v23 = v43[1] * 0.5 + v43[0];
  v24 = *((double *)&v41 + 1) + *(double *)&v41;
  v25 = *((double *)&v40 + 1) + *(double *)&v40;
  v26 = *((double *)&v39 + 1) + *(double *)&v39;
  v27 = *(double *)&v42 / (*((double *)&v42 + 1) + *(double *)&v42) + 2.0;
  if (*((double *)&v42 + 1) + *(double *)&v42 >= 0.00001)
  {
    v28 = *((double *)&v42 + 1) + *(double *)&v42;
  }
  else
  {
    v27 = 0.0;
    v28 = 0.0;
  }
  if (v24 >= 0.00001)
    v29 = *(double *)&v41 / (*((double *)&v41 + 1) + *(double *)&v41) + 4.0;
  else
    v29 = 0.0;
  if (v24 >= 0.00001)
    v30 = *((double *)&v41 + 1) + *(double *)&v41;
  else
    v30 = 0.0;
  if (v25 >= 0.00001)
    v31 = *((double *)&v40 + 1) + *(double *)&v40;
  else
    v31 = 0.0;
  if (v25 >= 0.00001)
    v32 = *(double *)&v40 / (*((double *)&v40 + 1) + *(double *)&v40) + 6.0;
  else
    v32 = 0.0;
  if (v26 >= 0.00001)
    v33 = *((double *)&v39 + 1) + *(double *)&v39;
  else
    v33 = 0.0;
  if (v26 >= 0.00001)
    v34 = *(double *)&v39 / (*((double *)&v39 + 1) + *(double *)&v39) + 8.0;
  else
    v34 = 0.0;
  *a2 = v43[0] / v23;
  a2[1] = v27;
  a2[2] = v29;
  a2[3] = v32;
  a2[4] = v34;
  *a3 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v23, v28, v30, v31, *(_OWORD *)&v35);
  *a4 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", v33, 0.0, 0.0, 0.0);
  if (v33 > 0.0)
    return 9;
  if (v31 > 0.0)
    return 7;
  if (v30 > 0.0)
    return 5;
  if (v28 <= 0.0)
    return 1;
  return 3;
}

double ___ZL9blurImageP7CIImagedd_block_invoke_5(uint64_t a1, double a2, CGFloat a3, double a4, CGFloat a5)
{
  double v8;
  int v9;
  CGRect v11;

  v8 = a2;
  v9 = *(_DWORD *)(a1 + 32);
  if (!CGRectIsEmpty(*(CGRect *)&a2))
  {
    v11.origin.x = v8 - (double)v9;
    v11.size.width = a4 + (double)v9 * 2.0;
    v11.origin.y = a3;
    v11.size.height = a5;
    *(_QWORD *)&v8 = (unint64_t)CGRectIntegral(v11);
  }
  return v8;
}

double ___ZL9blurImageP7CIImagedd_block_invoke_6(uint64_t a1, double a2, double a3, CGFloat a4, double a5)
{
  double v8;
  int v9;
  CGRect v11;

  v8 = a2;
  v9 = *(_DWORD *)(a1 + 32);
  if (!CGRectIsEmpty(*(CGRect *)&a2))
  {
    v11.origin.y = a3 - (double)v9;
    v11.size.height = a5 + (double)v9 * 2.0;
    v11.origin.x = v8;
    v11.size.width = a4;
    *(_QWORD *)&v8 = (unint64_t)CGRectIntegral(v11);
  }
  return v8;
}

double cikernel::_gaussianReduce4(uint64_t a1, int8x16_t a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  int8x16_t v5;
  double v6;
  double v7;
  double v8;
  uint8x8_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  double v16;
  int8x16_t v17;
  double v18;
  uint8x8_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  double v23;
  double v24;
  uint8x8_t v25;
  int8x16_t v26;
  float64x2_t v27;
  double v28;
  int8x16_t v29;
  float32x4_t v30;
  double v31;
  float32x2_t v32;
  float32x2_t v33;
  double v34;
  int8x16_t v35;
  double v36;
  uint8x8_t v37;
  float64x2_t v38;
  int8x16_t v39;
  float32x4_t v40;
  double v41;
  double v42;
  uint8x8_t v43;
  int8x16_t v44;
  float64x2_t v45;
  double v46;
  int8x16_t v47;
  float32x4_t v48;
  double v49;
  float32x2_t v50;
  float32x2_t v51;
  double v52;
  int8x16_t v53;
  double v54;
  uint8x8_t v55;
  float64x2_t v56;
  int8x16_t v57;
  float32x4_t v58;
  double v59;
  double v60;
  uint8x8_t v61;
  int8x16_t v62;
  float64x2_t v63;
  double v64;
  int8x16_t v65;
  float32x4_t v66;
  double v67;
  float32x2_t v68;
  float32x2_t v69;
  double v70;
  int8x16_t v71;
  double v72;
  uint8x8_t v73;
  float64x2_t v74;
  int8x16_t v75;
  float32x4_t v76;
  double v77;
  double v78;
  uint8x8_t v79;
  int8x16_t v80;
  float64x2_t v81;
  double v82;
  int8x16_t v83;
  float32x4_t v84;
  double result;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v94;
  float32x2_t v95;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v4 = (float64x2_t)a2;
  *(float32x2_t *)v5.i8 = vmul_f32(*(float32x2_t *)a2.i8, *DC);
  v95 = *(float32x2_t *)v5.i8;
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  *(float *)&v7 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v5.i8, 1), *(float *)(a1 + 16), *(float *)v5.i32);
  LODWORD(v8) = *(_DWORD *)(a1 + 36);
  *(float *)v4.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v5.i8, 1), *(float *)&v6, *(float *)v5.i32);
  HIDWORD(v7) = LODWORD(v4.f64[0]);
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v7, v4, v6, v8, v5, v9, v10, v11);
  v13 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  *(float32x2_t *)a2.i8 = v13;
  v14 = vmul_f32(v13, (float32x2_t)vdup_n_s32(0x3FF9A00Bu));
  v15 = vsub_f32(v95, v14);
  *(float *)&v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v15, 1), *(float *)(a1 + 16), v15.f32[0]);
  v13.i32[0] = *(_DWORD *)(a1 + 24);
  v17.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v18) = *(_DWORD *)(a1 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v15, 1), *(float *)v17.i32, v15.f32[0]);
  v20 = (float32x4_t)vdupq_n_s32(0x3E7F158Eu);
  v89 = vmulq_f32(v12, v20);
  v12.f32[0] = v13.f32[0] + *(float *)&v16;
  v20.f32[0] = *(float *)&v18 + *(float *)v19.i32;
  v12.f32[1] = *(float *)&v18 + *(float *)v19.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, (float64x2_t)v20, *(double *)&v13, v16, v17, v19, v18, v21);
  v86 = v22;
  *(float32x2_t *)v22.f32 = vadd_f32(v14, v95);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v22.f32, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v22.f32, 1), *(float *)&v24, v22.f32[0]);
  v22.f32[0] = *(float *)(a1 + 24) + *(float *)&v23;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v22.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v22.i64, v27, v23, v24, v26, v25, v28, v29);
  HIDWORD(v31) = a2.i32[1];
  v32 = vmul_f32(*(float32x2_t *)a2.i8, (float32x2_t)vdup_n_s32(0x4079B00Du));
  v33 = vsub_f32(v95, v32);
  *(float *)&v34 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v33, 1), *(float *)(a1 + 16), v33.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 24);
  v35.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v36) = *(_DWORD *)(a1 + 36);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v33, 1), *(float *)v35.i32, v33.f32[0]);
  v38 = (float64x2_t)v89;
  v90 = vaddq_f32(v89, vmulq_f32(vaddq_f32(v86, v30), (float32x4_t)vdupq_n_s32(0x3E51EA47u)));
  v30.f32[0] = *(float *)&v31 + *(float *)&v34;
  *(float *)v38.f64 = *(float *)&v36 + *(float *)v37.i32;
  v30.f32[1] = *(float *)&v36 + *(float *)v37.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v30.i64, v38, v31, v34, v35, v37, v36, v39);
  v87 = v40;
  *(float32x2_t *)v40.f32 = vadd_f32(v32, v95);
  *(float *)&v41 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v40.f32, 1), *(float *)(a1 + 16), v40.f32[0]);
  LODWORD(v42) = *(_DWORD *)(a1 + 28);
  v43.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v44.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v40.f32, 1), *(float *)&v42, v40.f32[0]);
  v40.f32[0] = *(float *)(a1 + 24) + *(float *)&v41;
  *(float *)v45.f64 = *(float *)v43.i32 + *(float *)v44.i32;
  v40.f32[1] = *(float *)v43.i32 + *(float *)v44.i32;
  *(double *)v48.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v40.i64, v45, v41, v42, v44, v43, v46, v47);
  HIDWORD(v49) = a2.i32[1];
  v50 = vmul_f32(*(float32x2_t *)a2.i8, (float32x2_t)vdup_n_s32(0x40BB7805u));
  v51 = vsub_f32(v95, v50);
  *(float *)&v52 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v51, 1), *(float *)(a1 + 16), v51.f32[0]);
  LODWORD(v49) = *(_DWORD *)(a1 + 24);
  v53.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v54) = *(_DWORD *)(a1 + 36);
  *(float *)v55.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v51, 1), *(float *)v53.i32, v51.f32[0]);
  v56 = (float64x2_t)v90;
  v91 = vaddq_f32(v90, vmulq_f32(vaddq_f32(v87, v48), (float32x4_t)vdupq_n_s32(0x3DE9F147u)));
  v48.f32[0] = *(float *)&v49 + *(float *)&v52;
  *(float *)v56.f64 = *(float *)&v54 + *(float *)v55.i32;
  v48.f32[1] = *(float *)&v54 + *(float *)v55.i32;
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v48.i64, v56, v49, v52, v53, v55, v54, v57);
  v88 = v58;
  *(float32x2_t *)v58.f32 = vadd_f32(v50, v95);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v58.f32, 1), *(float *)(a1 + 16), v58.f32[0]);
  LODWORD(v60) = *(_DWORD *)(a1 + 28);
  v61.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v58.f32, 1), *(float *)&v60, v58.f32[0]);
  v58.f32[0] = *(float *)(a1 + 24) + *(float *)&v59;
  *(float *)v63.f64 = *(float *)v61.i32 + *(float *)v62.i32;
  v58.f32[1] = *(float *)v61.i32 + *(float *)v62.i32;
  *(double *)v66.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v58.i64, v63, v59, v60, v62, v61, v64, v65);
  HIDWORD(v67) = a2.i32[1];
  v68 = vmul_f32(*(float32x2_t *)a2.i8, (float32x2_t)vdup_n_s32(0x40FBCDB9u));
  v69 = vsub_f32(v95, v68);
  *(float *)&v70 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v69, 1), *(float *)(a1 + 16), v69.f32[0]);
  LODWORD(v67) = *(_DWORD *)(a1 + 24);
  v71.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v72) = *(_DWORD *)(a1 + 36);
  *(float *)v73.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v69, 1), *(float *)v71.i32, v69.f32[0]);
  v74 = (float64x2_t)v91;
  v94 = vaddq_f32(v91, vmulq_f32(vaddq_f32(v88, v66), (float32x4_t)vdupq_n_s32(0x3D31953Au)));
  v66.f32[0] = *(float *)&v67 + *(float *)&v70;
  *(float *)v74.f64 = *(float *)&v72 + *(float *)v73.i32;
  v66.f32[1] = *(float *)&v72 + *(float *)v73.i32;
  *(double *)v76.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v66.i64, v74, v67, v70, v71, v73, v72, v75);
  v92 = v76;
  *(float32x2_t *)v76.f32 = vadd_f32(v68, v95);
  *(float *)&v77 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v76.f32, 1), *(float *)(a1 + 16), v76.f32[0]);
  LODWORD(v78) = *(_DWORD *)(a1 + 28);
  v79.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v80.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v76.f32, 1), *(float *)&v78, v76.f32[0]);
  v76.f32[0] = *(float *)(a1 + 24) + *(float *)&v77;
  *(float *)v81.f64 = *(float *)v79.i32 + *(float *)v80.i32;
  v76.f32[1] = *(float *)v79.i32 + *(float *)v80.i32;
  *(double *)v84.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v76.i64, v81, v77, v78, v80, v79, v82, v83);
  *(_QWORD *)&result = vaddq_f32(v94, vmulq_f32(vaddq_f32(v92, v84), (float32x4_t)vdupq_n_s32(0x3C52D001u))).u64[0];
  return result;
}

double cikernel::_gaussianReduce2(uint64_t a1, float64x2_t a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  int8x16_t v5;
  float32x2_t v6;
  float32x2_t v7;
  double v8;
  int8x16_t v9;
  double v10;
  uint8x8_t v11;
  float32x2_t v12;
  int8x16_t v13;
  float32x4_t v14;
  double v15;
  double v16;
  uint8x8_t v17;
  int8x16_t v18;
  float64x2_t v19;
  double v20;
  int8x16_t v21;
  float32x4_t v22;
  double v23;
  double v24;
  float64x2_t v25;
  uint8x8_t v26;
  double v27;
  int8x16_t v28;
  float32x4_t v29;
  double v30;
  double v31;
  uint8x8_t v32;
  int8x16_t v33;
  float64x2_t v34;
  double v35;
  int8x16_t v36;
  float32x4_t v37;
  float32x2_t v38;
  double v39;
  double v40;
  int8x16_t v41;
  double v42;
  uint8x8_t v43;
  float64x2_t v44;
  int8x16_t v45;
  float32x4_t v46;
  double result;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v51;
  int8x16_t v52;
  float32x4_t v53;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v4 = a2;
  *(float32x2_t *)v5.i8 = vmul_f32(*(float32x2_t *)&a2.f64[0], *DC);
  v52 = v5;
  v6 = (float32x2_t)vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL).u64[0];
  v7 = vmul_f32(v6, (float32x2_t)vdup_n_s32(0x406FB10Au));
  *(float32x2_t *)&v4.f64[0] = vsub_f32(*(float32x2_t *)v5.i8, v7);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v4.f64[0], 1), *(float *)(a1 + 16), *(float *)v4.f64);
  v5.i32[0] = *(_DWORD *)(a1 + 24);
  v9.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v10) = *(_DWORD *)(a1 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v4.f64[0], 1), *(float *)v9.i32, *(float *)v4.f64);
  *(int32x2_t *)&v4.f64[0] = vdup_n_s32(0x3FEC5190u);
  v12 = vmul_f32(v6, *(float32x2_t *)&v4.f64[0]);
  v6.f32[0] = *(float *)v5.i32 + *(float *)&v8;
  *(float *)v4.f64 = *(float *)&v10 + *(float *)v11.i32;
  v6.f32[1] = *(float *)&v10 + *(float *)v11.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v4, *(double *)v5.i64, v8, v9, v11, v10, v13);
  v51 = v14;
  *(float32x2_t *)v14.f32 = vsub_f32(*(float32x2_t *)v52.i8, v12);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v14.f32, 1), *(float *)(a1 + 16), v14.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v14.f32, 1), *(float *)&v16, v14.f32[0]);
  v14.f32[0] = *(float *)(a1 + 24) + *(float *)&v15;
  *(float *)v19.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v14.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v14.i64, v19, v15, v16, v18, v17, v20, v21);
  v49 = v22;
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v22.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v52.i8, 1), *(float *)(a1 + 16), *(float *)v52.i32);
  LODWORD(v24) = *(_DWORD *)(a1 + 36);
  *(float *)v25.f64 = *(float *)&v24
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v52.i8, 1), *(float *)&v23, *(float *)v52.i32);
  v22.i32[1] = LODWORD(v25.f64[0]);
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v22.i64, v25, v23, v24, v52, v26, v27, v28);
  v48 = v29;
  *(float32x2_t *)v29.f32 = vadd_f32(v12, *(float32x2_t *)v52.i8);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v29.f32, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v29.f32, 1), *(float *)&v31, v29.f32[0]);
  v29.f32[0] = *(float *)(a1 + 24) + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v29.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v34, v30, v31, v33, v32, v35, v36);
  v38 = vadd_f32(v7, *(float32x2_t *)v52.i8);
  *(float *)&v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v38, 1), *(float *)(a1 + 16), v38.f32[0]);
  LODWORD(v40) = *(_DWORD *)(a1 + 24);
  v41.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v42) = *(_DWORD *)(a1 + 36);
  *(float *)v43.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v38, 1), *(float *)v41.i32, v38.f32[0]);
  v44 = (float64x2_t)v49;
  v53 = vaddq_f32(v49, v37);
  v37.f32[0] = *(float *)&v40 + *(float *)&v39;
  *(float *)v44.f64 = *(float *)&v42 + *(float *)v43.i32;
  v37.f32[1] = *(float *)&v42 + *(float *)v43.i32;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v37.i64, v44, v40, v39, v41, v43, v42, v45);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_f32(v48, (float32x4_t)vdupq_n_s32(0x3EDD5539u)), vmulq_f32(v53, (float32x4_t)vdupq_n_s32(0x3E766429u))), vmulq_f32(vaddq_f32(v51, v46), (float32x4_t)vdupq_n_s32(0x3D311A78u))).u64[0];
  return result;
}

double cikernel::_gaussianBlur19(uint64_t a1, int8x16_t a2, int8x16_t a3, float32x2_t a4, float32x4_t a5, float a6)
{
  float32x2_t v8;
  float32x2_t v9;
  double v10;
  double v11;
  uint8x8_t v12;
  int8x16_t v13;
  float64x2_t v14;
  double v15;
  int8x16_t v16;
  float32x4_t v17;
  double v18;
  double v19;
  uint8x8_t v20;
  int8x16_t v21;
  float64x2_t v22;
  double v23;
  int8x16_t v24;
  float32x4_t v25;
  double v26;
  double v27;
  uint8x8_t v28;
  int8x16_t v29;
  float64x2_t v30;
  double v31;
  int8x16_t v32;
  float32x4_t v33;
  double v34;
  double v35;
  uint8x8_t v36;
  int8x16_t v37;
  float64x2_t v38;
  double v39;
  int8x16_t v40;
  float32x4_t v41;
  double v42;
  double v43;
  uint8x8_t v44;
  int8x16_t v45;
  float64x2_t v46;
  double v47;
  int8x16_t v48;
  float32x4_t v49;
  double v50;
  double v51;
  uint8x8_t v52;
  int8x16_t v53;
  float64x2_t v54;
  double v55;
  int8x16_t v56;
  float32x4_t v57;
  double v58;
  double v59;
  uint8x8_t v60;
  int8x16_t v61;
  float64x2_t v62;
  double v63;
  int8x16_t v64;
  float32x4_t v65;
  double v66;
  double v67;
  uint8x8_t v68;
  int8x16_t v69;
  float64x2_t v70;
  double v71;
  int8x16_t v72;
  float32x4_t v73;
  double v74;
  double v75;
  uint8x8_t v76;
  int8x16_t v77;
  float64x2_t v78;
  double v79;
  int8x16_t v80;
  float32x4_t v81;
  double v82;
  double v83;
  uint8x8_t v84;
  int8x16_t v85;
  float64x2_t v86;
  double v87;
  int8x16_t v88;
  float32x4_t v89;
  double result;
  float32x2_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x2_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v103;
  float32x4_t v105;

  v8 = *(float32x2_t *)CI::getDC((CI *)a1);
  v9 = vsub_f32(v8, a4);
  *(float *)&v10 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v9, 1), *(float *)(a1 + 16), v9.f32[0]);
  LODWORD(v11) = *(_DWORD *)(a1 + 28);
  v12.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v9, 1), *(float *)&v11, v9.f32[0]);
  v9.f32[0] = *(float *)(a1 + 24) + *(float *)&v10;
  *(float *)v14.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  v9.f32[1] = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v9, v14, v10, v11, v13, v12, v15, v16);
  v99 = v17;
  v95 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  *(float32x2_t *)v17.f32 = vsub_f32(v8, v95);
  *(float *)&v18 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v17.f32, 1), *(float *)(a1 + 16), v17.f32[0]);
  LODWORD(v19) = *(_DWORD *)(a1 + 28);
  v20.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v17.f32, 1), *(float *)&v19, v17.f32[0]);
  v17.f32[0] = *(float *)(a1 + 24) + *(float *)&v18;
  *(float *)v22.f64 = *(float *)v20.i32 + *(float *)v21.i32;
  v17.f32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v17.i64, v22, v18, v19, v21, v20, v23, v24);
  v98 = v25;
  *(float32x2_t *)v25.f32 = vsub_f32(v8, *(float32x2_t *)a3.i8);
  *(float *)&v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v25.f32, 1), *(float *)(a1 + 16), v25.f32[0]);
  LODWORD(v27) = *(_DWORD *)(a1 + 28);
  v28.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v25.f32, 1), *(float *)&v27, v25.f32[0]);
  v25.f32[0] = *(float *)(a1 + 24) + *(float *)&v26;
  *(float *)v30.f64 = *(float *)v28.i32 + *(float *)v29.i32;
  v25.f32[1] = *(float *)v28.i32 + *(float *)v29.i32;
  *(double *)v33.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v25.i64, v30, v26, v27, v29, v28, v31, v32);
  v97 = v33;
  v91 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  *(float32x2_t *)v33.f32 = vsub_f32(v8, v91);
  *(float *)&v34 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v33.f32, 1), *(float *)(a1 + 16), v33.f32[0]);
  LODWORD(v35) = *(_DWORD *)(a1 + 28);
  v36.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v33.f32, 1), *(float *)&v35, v33.f32[0]);
  v33.f32[0] = *(float *)(a1 + 24) + *(float *)&v34;
  *(float *)v38.f64 = *(float *)v36.i32 + *(float *)v37.i32;
  v33.f32[1] = *(float *)v36.i32 + *(float *)v37.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v33.i64, v38, v34, v35, v37, v36, v39, v40);
  v94 = v41;
  *(float32x2_t *)v41.f32 = vsub_f32(v8, *(float32x2_t *)a2.i8);
  *(float *)&v42 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v41.f32, 1), *(float *)(a1 + 16), v41.f32[0]);
  LODWORD(v43) = *(_DWORD *)(a1 + 28);
  v44.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v41.f32, 1), *(float *)&v43, v41.f32[0]);
  v41.f32[0] = *(float *)(a1 + 24) + *(float *)&v42;
  *(float *)v46.f64 = *(float *)v44.i32 + *(float *)v45.i32;
  v41.f32[1] = *(float *)v44.i32 + *(float *)v45.i32;
  *(double *)v49.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v41.i64, v46, v42, v43, v45, v44, v47, v48);
  v93 = v49;
  *(float32x2_t *)v49.f32 = vadd_f32(*(float32x2_t *)a2.i8, v8);
  *(float *)&v50 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v49.f32, 1), *(float *)(a1 + 16), v49.f32[0]);
  LODWORD(v51) = *(_DWORD *)(a1 + 28);
  v52.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v53.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v49.f32, 1), *(float *)&v51, v49.f32[0]);
  v49.f32[0] = *(float *)(a1 + 24) + *(float *)&v50;
  *(float *)v54.f64 = *(float *)v52.i32 + *(float *)v53.i32;
  v49.f32[1] = *(float *)v52.i32 + *(float *)v53.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v49.i64, v54, v50, v51, v53, v52, v55, v56);
  v103 = v57;
  *(float32x2_t *)v57.f32 = vadd_f32(v91, v8);
  *(float *)&v58 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v57.f32, 1), *(float *)(a1 + 16), v57.f32[0]);
  LODWORD(v59) = *(_DWORD *)(a1 + 28);
  v60.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v61.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v57.f32, 1), *(float *)&v59, v57.f32[0]);
  v57.f32[0] = *(float *)(a1 + 24) + *(float *)&v58;
  *(float *)v62.f64 = *(float *)v60.i32 + *(float *)v61.i32;
  v57.f32[1] = *(float *)v60.i32 + *(float *)v61.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v57.i64, v62, v58, v59, v61, v60, v63, v64);
  v92 = v65;
  *(float32x2_t *)v65.f32 = vadd_f32(*(float32x2_t *)a3.i8, v8);
  *(float *)&v66 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v65.f32, 1), *(float *)(a1 + 16), v65.f32[0]);
  LODWORD(v67) = *(_DWORD *)(a1 + 28);
  v68.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v69.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v65.f32, 1), *(float *)&v67, v65.f32[0]);
  v65.f32[0] = *(float *)(a1 + 24) + *(float *)&v66;
  *(float *)v70.f64 = *(float *)v68.i32 + *(float *)v69.i32;
  v65.f32[1] = *(float *)v68.i32 + *(float *)v69.i32;
  *(double *)v73.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v70, v66, v67, v69, v68, v71, v72);
  v105 = v73;
  *(float32x2_t *)v73.f32 = vadd_f32(v95, v8);
  *(float *)&v74 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v73.f32, 1), *(float *)(a1 + 16), v73.f32[0]);
  LODWORD(v75) = *(_DWORD *)(a1 + 28);
  v76.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v77.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v73.f32, 1), *(float *)&v75, v73.f32[0]);
  v73.f32[0] = *(float *)(a1 + 24) + *(float *)&v74;
  *(float *)v78.f64 = *(float *)v76.i32 + *(float *)v77.i32;
  v73.f32[1] = *(float *)v76.i32 + *(float *)v77.i32;
  *(double *)v81.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v73.i64, v78, v74, v75, v77, v76, v79, v80);
  v96 = v81;
  *(float32x2_t *)v81.f32 = vadd_f32(a4, v8);
  *(float *)&v82 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v81.f32, 1), *(float *)(a1 + 16), v81.f32[0]);
  LODWORD(v83) = *(_DWORD *)(a1 + 28);
  v84.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v85.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v81.f32, 1), *(float *)&v83, v81.f32[0]);
  v81.f32[0] = *(float *)(a1 + 24) + *(float *)&v82;
  *(float *)v86.f64 = *(float *)v84.i32 + *(float *)v85.i32;
  v81.f32[1] = *(float *)v84.i32 + *(float *)v85.i32;
  *(double *)v89.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v81.i64, v86, v82, v83, v85, v84, v87, v88);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(vaddq_f32(v93, v103), a5.f32[0]), vmulq_lane_f32(vaddq_f32(v94, v92), *(float32x2_t *)a5.f32, 1)), vmulq_laneq_f32(vaddq_f32(v97, v105), a5, 2)), vmulq_laneq_f32(vaddq_f32(v98, v96), a5, 3)), vmulq_n_f32(vaddq_f32(v99, v89), a6)).u64[0];
  return result;
}

void CI::f4_sr_f4_f4_f2_f4_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, __n128, __n128, double, __n128, double);
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  double *v23;
  __n128 *v24;
  double *v25;
  __n128 *v26;
  __n128 *v27;
  __int128 v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  double (*v33)(uint64_t, __n128, __n128, double, __n128, double);

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, __n128, __n128, double, __n128, double))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  v17 = *(_DWORD *)(v10 + 88);
  v18 = *(_QWORD *)(v10 + 80);
  v19 = *(_DWORD *)(v10 + 112);
  v20 = *(_QWORD *)(v10 + 104);
  v21 = *(_DWORD *)(v10 + 136);
  v22 = *(_QWORD *)(v10 + 128);
  if (*(_BYTE *)(a1 + 64))
  {
    v32 = *(_QWORD *)(v10 + 56);
    v33 = *(double (**)(uint64_t, __n128, __n128, double, __n128, double))(a1 + 24);
    v31 = *(_QWORD *)(v10 + 8);
    v29 = *(_QWORD *)(v10 + 32);
    v30 = *(_DWORD *)(v10 + 112);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 152)), a2);
    v19 = v30;
    v12 = v31;
    v16 = v32;
    v14 = v29;
    v11 = v33;
  }
  v23 = (double *)(a3 + 16 * v22);
  if (v21 != 5)
    v23 = (double *)((char *)a2 + 64 * v22);
  v24 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5)
    v24 = (__n128 *)((char *)a2 + 64 * v20);
  v25 = (double *)(a3 + 16 * v18);
  if (v17 != 5)
    v25 = (double *)((char *)a2 + 64 * v18);
  v26 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v26 = (__n128 *)((char *)a2 + 64 * v16);
  v27 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v27 = (__n128 *)((char *)a2 + 64 * v14);
  *(double *)&v28 = v11(a4 + 80 * v12, *v27, *v26, *v25, *v24, *v23);
  *(_OWORD *)(a3 + 16 * a7) = v28;
}

double cikernel::_gaussianBlur15(uint64_t a1, int8x16_t a2, int8x16_t a3, float32x4_t a4)
{
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  float64x2_t v11;
  double v12;
  int8x16_t v13;
  float32x4_t v14;
  double v15;
  double v16;
  uint8x8_t v17;
  int8x16_t v18;
  float64x2_t v19;
  double v20;
  int8x16_t v21;
  float32x4_t v22;
  double v23;
  double v24;
  uint8x8_t v25;
  int8x16_t v26;
  float64x2_t v27;
  double v28;
  int8x16_t v29;
  float32x4_t v30;
  double v31;
  double v32;
  uint8x8_t v33;
  int8x16_t v34;
  float64x2_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  double v39;
  double v40;
  uint8x8_t v41;
  int8x16_t v42;
  float64x2_t v43;
  double v44;
  int8x16_t v45;
  float32x4_t v46;
  double v47;
  double v48;
  uint8x8_t v49;
  int8x16_t v50;
  float64x2_t v51;
  double v52;
  int8x16_t v53;
  float32x4_t v54;
  double v55;
  double v56;
  uint8x8_t v57;
  int8x16_t v58;
  float64x2_t v59;
  double v60;
  int8x16_t v61;
  float32x4_t v62;
  double v63;
  double v64;
  uint8x8_t v65;
  int8x16_t v66;
  float64x2_t v67;
  double v68;
  int8x16_t v69;
  float32x4_t v70;
  double result;
  float32x2_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float32x2_t v77;
  float32x4_t v78;
  float32x4_t v81;
  float32x4_t v83;

  v5 = *(float32x2_t *)CI::getDC((CI *)a1);
  v77 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  v6 = vsub_f32(v5, v77);
  *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v6, 1), *(float *)(a1 + 16), v6.f32[0]);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v11.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v11, v7, v8, v10, v9, v12, v13);
  v78 = v14;
  *(float32x2_t *)v14.f32 = vsub_f32(v5, *(float32x2_t *)a3.i8);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v14.f32, 1), *(float *)(a1 + 16), v14.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v14.f32, 1), *(float *)&v16, v14.f32[0]);
  v14.f32[0] = *(float *)(a1 + 24) + *(float *)&v15;
  *(float *)v19.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v14.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v14.i64, v19, v15, v16, v18, v17, v20, v21);
  v76 = v22;
  v72 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  *(float32x2_t *)v22.f32 = vsub_f32(v5, v72);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v22.f32, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v22.f32, 1), *(float *)&v24, v22.f32[0]);
  v22.f32[0] = *(float *)(a1 + 24) + *(float *)&v23;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v22.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v22.i64, v27, v23, v24, v26, v25, v28, v29);
  v75 = v30;
  *(float32x2_t *)v30.f32 = vsub_f32(v5, *(float32x2_t *)a2.i8);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v30.f32, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 28);
  v33.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v30.f32, 1), *(float *)&v32, v30.f32[0]);
  v30.f32[0] = *(float *)(a1 + 24) + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v30.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v30.i64, v35, v31, v32, v34, v33, v36, v37);
  v74 = v38;
  *(float32x2_t *)v38.f32 = vadd_f32(*(float32x2_t *)a2.i8, v5);
  *(float *)&v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v38.f32, 1), *(float *)(a1 + 16), v38.f32[0]);
  LODWORD(v40) = *(_DWORD *)(a1 + 28);
  v41.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v38.f32, 1), *(float *)&v40, v38.f32[0]);
  v38.f32[0] = *(float *)(a1 + 24) + *(float *)&v39;
  *(float *)v43.f64 = *(float *)v41.i32 + *(float *)v42.i32;
  v38.f32[1] = *(float *)v41.i32 + *(float *)v42.i32;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v43, v39, v40, v42, v41, v44, v45);
  v81 = v46;
  *(float32x2_t *)v46.f32 = vadd_f32(v72, v5);
  *(float *)&v47 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v46.f32, 1), *(float *)(a1 + 16), v46.f32[0]);
  LODWORD(v48) = *(_DWORD *)(a1 + 28);
  v49.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v46.f32, 1), *(float *)&v48, v46.f32[0]);
  v46.f32[0] = *(float *)(a1 + 24) + *(float *)&v47;
  *(float *)v51.f64 = *(float *)v49.i32 + *(float *)v50.i32;
  v46.f32[1] = *(float *)v49.i32 + *(float *)v50.i32;
  *(double *)v54.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v46.i64, v51, v47, v48, v50, v49, v52, v53);
  v73 = v54;
  *(float32x2_t *)v54.f32 = vadd_f32(*(float32x2_t *)a3.i8, v5);
  *(float *)&v55 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v54.f32, 1), *(float *)(a1 + 16), v54.f32[0]);
  LODWORD(v56) = *(_DWORD *)(a1 + 28);
  v57.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v58.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v54.f32, 1), *(float *)&v56, v54.f32[0]);
  v54.f32[0] = *(float *)(a1 + 24) + *(float *)&v55;
  *(float *)v59.f64 = *(float *)v57.i32 + *(float *)v58.i32;
  v54.f32[1] = *(float *)v57.i32 + *(float *)v58.i32;
  *(double *)v62.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v54.i64, v59, v55, v56, v58, v57, v60, v61);
  v83 = v62;
  *(float32x2_t *)v62.f32 = vadd_f32(v77, v5);
  *(float *)&v63 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v62.f32, 1), *(float *)(a1 + 16), v62.f32[0]);
  LODWORD(v64) = *(_DWORD *)(a1 + 28);
  v65.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v66.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v62.f32, 1), *(float *)&v64, v62.f32[0]);
  v62.f32[0] = *(float *)(a1 + 24) + *(float *)&v63;
  *(float *)v67.f64 = *(float *)v65.i32 + *(float *)v66.i32;
  v62.f32[1] = *(float *)v65.i32 + *(float *)v66.i32;
  *(double *)v70.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v62.i64, v67, v63, v64, v66, v65, v68, v69);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(vaddq_f32(v74, v81), a4.f32[0]), vmulq_lane_f32(vaddq_f32(v75, v73), *(float32x2_t *)a4.f32, 1)), vmulq_laneq_f32(vaddq_f32(v76, v83), a4, 2)), vmulq_laneq_f32(vaddq_f32(v78, v70), a4, 3)).u64[0];
  return result;
}

double cikernel::_gaussianBlur13(uint64_t a1, float32x2_t a2, float32x4_t a3, float32x4_t a4)
{
  float32x2_t *DC;
  float64x2_t v7;
  float32x2_t v8;
  double v9;
  double v10;
  uint8x8_t v11;
  int8x16_t v12;
  float32x2_t v13;
  float32x2_t v19;
  double v20;
  int8x16_t v21;
  float32x4_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  uint8x8_t v26;
  double v27;
  int8x16_t v28;
  float64x2_t v30;
  float32x2_t v31;
  double v32;
  double v33;
  int8x16_t v34;
  uint8x8_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  float64x2_t v39;
  double v40;
  double v41;
  int8x16_t v42;
  uint8x8_t v43;
  double v44;
  int8x16_t v45;
  float64x2_t v47;
  float32x2_t v48;
  double v49;
  double v50;
  int8x16_t v51;
  uint8x8_t v52;
  double v53;
  int8x16_t v54;
  float32x4_t v55;
  float64x2_t v56;
  double v57;
  double v58;
  int8x16_t v59;
  uint8x8_t v60;
  double v61;
  int8x16_t v62;
  float32x2_t v64;
  double v65;
  double v66;
  int8x16_t v67;
  uint8x8_t v68;
  double v69;
  int8x16_t v70;
  float32x4_t v71;
  float64x2_t v72;
  double v73;
  double v74;
  int8x16_t v75;
  uint8x8_t v76;
  double v77;
  int8x16_t v78;
  float32x4_t v79;
  float64x2_t v80;
  float32x2_t v81;
  double v82;
  double v83;
  int8x16_t v84;
  uint8x8_t v85;
  double v86;
  int8x16_t v87;
  float32x4_t v88;
  float64x2_t v89;
  double v90;
  double v91;
  int8x16_t v92;
  uint8x8_t v93;
  double v94;
  int8x16_t v95;
  float32x4_t v96;
  float64x2_t v97;
  double v98;
  double v99;
  int8x16_t v100;
  uint8x8_t v101;
  double v102;
  int8x16_t v103;
  float32x4_t v104;
  float64x2_t v105;
  double v106;
  double v107;
  int8x16_t v108;
  uint8x8_t v109;
  double v110;
  int8x16_t v111;
  float32x4_t v112;
  float64x2_t v113;
  double v114;
  double v115;
  int8x16_t v116;
  uint8x8_t v117;
  double v118;
  int8x16_t v119;
  float32x4_t v120;
  double result;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float64x2_t v136;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)v7.f64 = *(float *)(a1 + 24)
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  *((float *)v7.f64 + 1) = *(float *)(a1 + 36)
                         + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  v136 = v7;
  v8 = vadd_f32(a2, *(float32x2_t *)CI::getDC((CI *)DC));
  *(float *)&v9 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v8, 1), *(float *)(a1 + 16), v8.f32[0]);
  LODWORD(v10) = *(_DWORD *)(a1 + 28);
  v11.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v8, 1), *(float *)&v10, v8.f32[0]);
  v8.f32[0] = *(float *)(a1 + 24) + *(float *)&v9;
  v8.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  v13 = vsub_f32(v8, *(float32x2_t *)&v136.f64[0]);
  __asm { FMOV            V0.2S, #6.0 }
  v19 = vmul_f32(v13, _D0);
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v136.f64[0], v19)), v136, v9, v10, v12, v11, v20, v21);
  v122 = vaddq_f32(vmulq_laneq_f32(v22, a4, 2), (float32x4_t)0);
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v136.f64[0], v19)), (float64x2_t)0, v23, v24, v25, v26, v27, v28);
  v30 = (float64x2_t)v122;
  v123 = vaddq_f32(v122, vmulq_laneq_f32(_Q0, a4, 2));
  __asm { FMOV            V0.2S, #5.0 }
  v31 = vmul_f32(v13, *(float32x2_t *)_Q0.f32);
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v136.f64[0], v31)), v30, v32, v33, v34, v35, v36, v37);
  v39 = (float64x2_t)v123;
  v124 = vaddq_f32(v123, vmulq_lane_f32(v38, *(float32x2_t *)a4.f32, 1));
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v136.f64[0], v31)), v39, v40, v41, v42, v43, v44, v45);
  v47 = (float64x2_t)v124;
  v125 = vaddq_f32(v124, vmulq_lane_f32(_Q0, *(float32x2_t *)a4.f32, 1));
  __asm { FMOV            V0.2S, #4.0 }
  v48 = vmul_f32(v13, *(float32x2_t *)_Q0.f32);
  *(double *)v55.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v136.f64[0], v48)), v47, v49, v50, v51, v52, v53, v54);
  v56 = (float64x2_t)v125;
  v126 = vaddq_f32(v125, vmulq_n_f32(v55, a4.f32[0]));
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v136.f64[0], v48)), v56, v57, v58, v59, v60, v61, v62);
  v128 = vaddq_f32(v126, vmulq_n_f32(_Q0, a4.f32[0]));
  __asm { FMOV            V0.2S, #3.0 }
  v64 = vmul_f32(v13, *(float32x2_t *)_Q0.f32);
  *(double *)v71.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v136.f64[0], v64)), (float64x2_t)v126, v65, v66, v67, v68, v69, v70);
  v72 = (float64x2_t)v128;
  v129 = vaddq_f32(v128, vmulq_laneq_f32(v71, a3, 3));
  *(double *)v79.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v136.f64[0], v64)), v72, v73, v74, v75, v76, v77, v78);
  v80 = (float64x2_t)v129;
  v130 = vaddq_f32(v129, vmulq_laneq_f32(v79, a3, 3));
  v81 = vadd_f32(v13, v13);
  *(double *)v88.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v136.f64[0], v81)), v80, v82, v83, v84, v85, v86, v87);
  v89 = (float64x2_t)v130;
  v131 = vaddq_f32(v130, vmulq_laneq_f32(v88, a3, 2));
  *(double *)v96.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v136.f64[0], v81)), v89, v90, v91, v92, v93, v94, v95);
  v97 = (float64x2_t)v131;
  v132 = vaddq_f32(v131, vmulq_laneq_f32(v96, a3, 2));
  *(double *)v104.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v136.f64[0], v13)), v97, v98, v99, v100, v101, v102, v103);
  v105 = (float64x2_t)v132;
  v133 = vaddq_f32(v132, vmulq_lane_f32(v104, *(float32x2_t *)a3.f32, 1));
  *(double *)v112.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v136.f64[0], v13)), v105, v106, v107, v108, v109, v110, v111);
  v113 = (float64x2_t)v133;
  v134 = vaddq_f32(v133, vmulq_lane_f32(v112, *(float32x2_t *)a3.f32, 1));
  *(double *)v120.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v136.f64[0], v113, v114, v115, v116, v117, v118, v119);
  *(_QWORD *)&result = vaddq_f32(v134, vmulq_n_f32(v120, a3.f32[0])).u64[0];
  return result;
}

void CI::f4_sr_f2_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, double, __n128, __n128);
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __n128 *v19;
  __n128 *v20;
  double *v21;
  __int128 v22;
  int v23;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, double, __n128, __n128))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  v17 = *(_DWORD *)(v10 + 88);
  v18 = *(_QWORD *)(v10 + 80);
  if (*(_BYTE *)(a1 + 64))
  {
    v23 = *(_DWORD *)(v10 + 64);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
    v15 = v23;
  }
  v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v18);
  v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v16);
  v21 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v21 = (double *)((char *)a2 + 64 * v14);
  *(double *)&v22 = v11(a4 + 80 * v12, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

double cikernel::_gaussianBlur11(uint64_t a1, int8x16_t a2, float32x2_t a3, float32x4_t a4)
{
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  float64x2_t v11;
  double v12;
  int8x16_t v13;
  float32x4_t v14;
  double v15;
  double v16;
  uint8x8_t v17;
  int8x16_t v18;
  float64x2_t v19;
  double v20;
  int8x16_t v21;
  float32x4_t v22;
  double v23;
  double v24;
  uint8x8_t v25;
  int8x16_t v26;
  float64x2_t v27;
  double v28;
  int8x16_t v29;
  float32x4_t v30;
  double v31;
  double v32;
  uint8x8_t v33;
  int8x16_t v34;
  float64x2_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  double v39;
  double v40;
  uint8x8_t v41;
  int8x16_t v42;
  float64x2_t v43;
  double v44;
  int8x16_t v45;
  float32x4_t v46;
  double v47;
  double v48;
  uint8x8_t v49;
  int8x16_t v50;
  float64x2_t v51;
  double v52;
  int8x16_t v53;
  float32x4_t v54;
  double result;
  float32x2_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v64;

  v5 = *(float32x2_t *)CI::getDC((CI *)a1);
  v6 = vsub_f32(v5, a3);
  *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v6, 1), *(float *)(a1 + 16), v6.f32[0]);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v11.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v11, v7, v8, v10, v9, v12, v13);
  v60 = v14;
  v56 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  *(float32x2_t *)v14.f32 = vsub_f32(v5, v56);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v14.f32, 1), *(float *)(a1 + 16), v14.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v14.f32, 1), *(float *)&v16, v14.f32[0]);
  v14.f32[0] = *(float *)(a1 + 24) + *(float *)&v15;
  *(float *)v19.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v14.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v14.i64, v19, v15, v16, v18, v17, v20, v21);
  v59 = v22;
  *(float32x2_t *)v22.f32 = vsub_f32(v5, *(float32x2_t *)a2.i8);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v22.f32, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v22.f32, 1), *(float *)&v24, v22.f32[0]);
  v22.f32[0] = *(float *)(a1 + 24) + *(float *)&v23;
  *(float *)v27.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v22.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v22.i64, v27, v23, v24, v26, v25, v28, v29);
  v58 = v30;
  *(float32x2_t *)v30.f32 = vadd_f32(*(float32x2_t *)a2.i8, v5);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v30.f32, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 28);
  v33.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v30.f32, 1), *(float *)&v32, v30.f32[0]);
  v30.f32[0] = *(float *)(a1 + 24) + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v30.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v30.i64, v35, v31, v32, v34, v33, v36, v37);
  v64 = v38;
  *(float32x2_t *)v38.f32 = vadd_f32(v56, v5);
  *(float *)&v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v38.f32, 1), *(float *)(a1 + 16), v38.f32[0]);
  LODWORD(v40) = *(_DWORD *)(a1 + 28);
  v41.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v38.f32, 1), *(float *)&v40, v38.f32[0]);
  v38.f32[0] = *(float *)(a1 + 24) + *(float *)&v39;
  *(float *)v43.f64 = *(float *)v41.i32 + *(float *)v42.i32;
  v38.f32[1] = *(float *)v41.i32 + *(float *)v42.i32;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v43, v39, v40, v42, v41, v44, v45);
  v57 = v46;
  *(float32x2_t *)v46.f32 = vadd_f32(a3, v5);
  *(float *)&v47 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v46.f32, 1), *(float *)(a1 + 16), v46.f32[0]);
  LODWORD(v48) = *(_DWORD *)(a1 + 28);
  v49.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v46.f32, 1), *(float *)&v48, v46.f32[0]);
  v46.f32[0] = *(float *)(a1 + 24) + *(float *)&v47;
  *(float *)v51.f64 = *(float *)v49.i32 + *(float *)v50.i32;
  v46.f32[1] = *(float *)v49.i32 + *(float *)v50.i32;
  *(double *)v54.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v46.i64, v51, v47, v48, v50, v49, v52, v53);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(vaddq_f32(v58, v64), a4.f32[0]), vmulq_lane_f32(vaddq_f32(v59, v57), *(float32x2_t *)a4.f32, 1)), vmulq_laneq_f32(vaddq_f32(v60, v54), a4, 2)).u64[0];
  return result;
}

double cikernel::_gaussianBlur9(uint64_t a1, float32x2_t a2, float32x4_t a3)
{
  float32x2_t *DC;
  int8x16_t v6;
  float32x2_t v7;
  uint8x8_t v8;
  float v9;
  float32x2_t v10;
  float64x2_t v11;
  float32x2_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  double v21;
  double v22;
  int8x16_t v23;
  uint8x8_t v24;
  double v25;
  int8x16_t v26;
  float32x2_t v28;
  double v29;
  double v30;
  int8x16_t v31;
  uint8x8_t v32;
  double v33;
  int8x16_t v34;
  float32x4_t v35;
  float64x2_t v36;
  double v37;
  double v38;
  int8x16_t v39;
  uint8x8_t v40;
  double v41;
  int8x16_t v42;
  float32x4_t v43;
  float64x2_t v44;
  float32x2_t v45;
  double v46;
  double v47;
  int8x16_t v48;
  uint8x8_t v49;
  double v50;
  int8x16_t v51;
  float32x4_t v52;
  float64x2_t v53;
  double v54;
  double v55;
  int8x16_t v56;
  uint8x8_t v57;
  double v58;
  int8x16_t v59;
  float32x4_t v60;
  float64x2_t v61;
  double v62;
  double v63;
  int8x16_t v64;
  uint8x8_t v65;
  double v66;
  int8x16_t v67;
  float32x4_t v68;
  float64x2_t v69;
  double v70;
  double v71;
  int8x16_t v72;
  uint8x8_t v73;
  double v74;
  int8x16_t v75;
  float32x4_t v76;
  float64x2_t v77;
  double v78;
  double v79;
  int8x16_t v80;
  uint8x8_t v81;
  double v82;
  int8x16_t v83;
  float32x4_t v84;
  double result;
  float32x4_t v86;
  float v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  int8x16_t v96;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)v6.i32 = *(float *)(a1 + 24)
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  *(float *)&v6.i32[1] = *(float *)(a1 + 36)
                       + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  v96 = v6;
  v7 = vadd_f32(a2, *(float32x2_t *)CI::getDC((CI *)DC));
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  v9 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v7, 1), *(float *)(a1 + 28), v7.f32[0]);
  v7.f32[0] = *(float *)(a1 + 24)
            + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v7, 1), *(float *)(a1 + 16), v7.f32[0]);
  v7.f32[1] = *(float *)v8.i32 + v9;
  v10 = vsub_f32(v7, *(float32x2_t *)v96.i8);
  v11.f64[0] = a3.f32[3];
  v7.f32[0] = 0.5 - (a3.f32[1] + a3.f32[0] * 0.5 + a3.f32[2] + a3.f32[3]);
  v87 = v7.f32[0];
  __asm { FMOV            V0.2S, #4.0 }
  v17 = vmul_f32(v10, _D0);
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)v96.i8, v17)), v11, 0.5, *(double *)a3.i64, v96, v8, v18, v19);
  v86 = vaddq_f32(vmulq_n_f32(v20, v87), (float32x4_t)0);
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)v96.i8, v17)), (float64x2_t)0, v21, v22, v23, v24, v25, v26);
  v88 = vaddq_f32(v86, vmulq_n_f32(_Q0, v87));
  __asm { FMOV            V0.2S, #3.0 }
  v28 = vmul_f32(v10, *(float32x2_t *)_Q0.f32);
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)v96.i8, v28)), (float64x2_t)v86, v29, v30, v31, v32, v33, v34);
  v36 = (float64x2_t)v88;
  v89 = vaddq_f32(v88, vmulq_laneq_f32(v35, a3, 3));
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)v96.i8, v28)), v36, v37, v38, v39, v40, v41, v42);
  v44 = (float64x2_t)v89;
  v90 = vaddq_f32(v89, vmulq_laneq_f32(v43, a3, 3));
  v45 = vadd_f32(v10, v10);
  *(double *)v52.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)v96.i8, v45)), v44, v46, v47, v48, v49, v50, v51);
  v53 = (float64x2_t)v90;
  v91 = vaddq_f32(v90, vmulq_laneq_f32(v52, a3, 2));
  *(double *)v60.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)v96.i8, v45)), v53, v54, v55, v56, v57, v58, v59);
  v61 = (float64x2_t)v91;
  v92 = vaddq_f32(v91, vmulq_laneq_f32(v60, a3, 2));
  *(double *)v68.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)v96.i8, v10)), v61, v62, v63, v64, v65, v66, v67);
  v69 = (float64x2_t)v92;
  v93 = vaddq_f32(v92, vmulq_lane_f32(v68, *(float32x2_t *)a3.f32, 1));
  *(double *)v76.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)v96.i8, v10)), v69, v70, v71, v72, v73, v74, v75);
  v77 = (float64x2_t)v93;
  v94 = vaddq_f32(v93, vmulq_lane_f32(v76, *(float32x2_t *)a3.f32, 1));
  *(double *)v84.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v96.i64, v77, v78, v79, v80, v81, v82, v83);
  *(_QWORD *)&result = vaddq_f32(v94, vmulq_n_f32(v84, a3.f32[0])).u64[0];
  return result;
}

void CI::f4_sr_f2_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, double, __n128);
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  double *v19;
  __int128 v20;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, double, __n128))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_DWORD *)(v11 + 40);
  v15 = *(_QWORD *)(v11 + 32);
  v16 = *(_DWORD *)(v11 + 64);
  v17 = *(_QWORD *)(v11 + 56);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 80)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (double *)((char *)a2 + 64 * v15);
  *(double *)&v20 = v12(a4 + 80 * v13, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_gaussianBlur7(uint64_t a1, int8x16_t a2, double a3)
{
  float32x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  float64x2_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  double v22;
  double v23;
  uint8x8_t v24;
  int8x16_t v25;
  float64x2_t v26;
  double v27;
  int8x16_t v28;
  float32x4_t v29;
  double v30;
  double v31;
  uint8x8_t v32;
  int8x16_t v33;
  float64x2_t v34;
  double v35;
  int8x16_t v36;
  float32x4_t v37;
  double result;
  float32x4_t v39;
  float32x2_t v40;
  float32x4_t v41;
  float32x4_t v44;

  v4 = *(float32x2_t *)CI::getDC((CI *)a1);
  v40 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  v5 = vsub_f32(v4, v40);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v10, v6, v7, v9, v8, v11, v12);
  v41 = v13;
  *(float32x2_t *)v13.f32 = vsub_f32(v4, *(float32x2_t *)a2.i8);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v13.f32, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  v39 = v21;
  *(float32x2_t *)v21.f32 = vadd_f32(*(float32x2_t *)a2.i8, v4);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v21.f32, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v21.f32, 1), *(float *)&v23, v21.f32[0]);
  v21.f32[0] = *(float *)(a1 + 24) + *(float *)&v22;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v21.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v26, v22, v23, v25, v24, v27, v28);
  v44 = v29;
  *(float32x2_t *)v29.f32 = vadd_f32(v40, v4);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v29.f32, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v29.f32, 1), *(float *)&v31, v29.f32[0]);
  v29.f32[0] = *(float *)(a1 + 24) + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v29.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v34, v30, v31, v33, v32, v35, v36);
  *(_QWORD *)&result = vaddq_f32(vmulq_n_f32(vaddq_f32(v39, v44), *(float *)&a3), vmulq_lane_f32(vaddq_f32(v41, v37), *(float32x2_t *)&a3, 1)).u64[0];
  return result;
}

double cikernel::_gaussianBlur5(uint64_t a1, float32x2_t a2, float32x4_t a3)
{
  float32x2_t *DC;
  float64x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  float32x2_t v12;
  float32x2_t v13;
  double v14;
  int8x16_t v15;
  float32x4_t v16;
  double v17;
  double v18;
  int8x16_t v19;
  uint8x8_t v20;
  double v21;
  int8x16_t v22;
  float32x4_t v23;
  float64x2_t v24;
  double v25;
  double v26;
  int8x16_t v27;
  uint8x8_t v28;
  double v29;
  int8x16_t v30;
  float32x4_t v31;
  float64x2_t v32;
  double v33;
  double v34;
  int8x16_t v35;
  uint8x8_t v36;
  double v37;
  int8x16_t v38;
  float32x4_t v39;
  float64x2_t v40;
  double v41;
  double v42;
  int8x16_t v43;
  uint8x8_t v44;
  double v45;
  int8x16_t v46;
  float32x4_t v47;
  double result;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float64x2_t v53;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)v6.f64 = *(float *)(a1 + 24)
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  *((float *)v6.f64 + 1) = *(float *)(a1 + 36)
                         + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)(a1 + 28), COERCE_FLOAT(*DC));
  v53 = v6;
  v7 = vadd_f32(a2, *(float32x2_t *)CI::getDC((CI *)DC));
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v7, 1), *(float *)(a1 + 16), v7.f32[0]);
  LODWORD(v9) = *(_DWORD *)(a1 + 28);
  v10.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *(float *)(a1 + 24) + *(float *)&v8;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  v12 = vsub_f32(v7, *(float32x2_t *)&v53.f64[0]);
  v13 = vadd_f32(v12, v12);
  *(double *)v16.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v53.f64[0], v13)), v53, v8, v9, v11, v10, v14, v15);
  v49 = vaddq_f32(vmulq_laneq_f32(v16, a3, 2), (float32x4_t)0);
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v53.f64[0], v13)), (float64x2_t)0, v17, v18, v19, v20, v21, v22);
  v24 = (float64x2_t)v49;
  v50 = vaddq_f32(v49, vmulq_laneq_f32(v23, a3, 2));
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&v53.f64[0], v12)), v24, v25, v26, v27, v28, v29, v30);
  v32 = (float64x2_t)v50;
  v51 = vaddq_f32(v50, vmulq_lane_f32(v31, *(float32x2_t *)a3.f32, 1));
  *(double *)v39.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&v53.f64[0], v12)), v32, v33, v34, v35, v36, v37, v38);
  v40 = (float64x2_t)v51;
  v52 = vaddq_f32(v51, vmulq_lane_f32(v39, *(float32x2_t *)a3.f32, 1));
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v53.f64[0], v40, v41, v42, v43, v44, v45, v46);
  *(_QWORD *)&result = vaddq_f32(v52, vmulq_n_f32(v47, a3.f32[0])).u64[0];
  return result;
}

double cikernel::_gaussianBlur3(uint64_t a1, float32x2_t a2)
{
  float32x2_t v3;
  float32x2_t v4;
  double v5;
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  float64x2_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  double v13;
  double v14;
  uint8x8_t v15;
  int8x16_t v16;
  float64x2_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t v21;
  double result;
  float32x4_t v23;

  v3 = *(float32x2_t *)CI::getDC((CI *)a1);
  v4 = vsub_f32(v3, a2);
  *(float *)&v5 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v4, 1), *(float *)(a1 + 16), v4.f32[0]);
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  v7.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *(float *)(a1 + 24) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v4, v9, v5, v6, v8, v7, v10, v11);
  v23 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32(a2, v3);
  *(float *)&v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v17, v13, v14, v16, v15, v18, v19);
  v21.i64[0] = 0x3F0000003F000000;
  v21.i64[1] = 0x3F0000003F000000;
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v23, v20), v21).u64[0];
  return result;
}

void sub_1922CE9DC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

double cikernel::_glassDistort(uint64_t a1, uint64_t a2, float32x2_t a3, float32x2_t a4, float32x2_t a5, float32x2_t a6, float32x2_t a7, float a8)
{
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  double v19;
  float64x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  int8x16_t v24;
  double v25;
  int8x16_t v26;
  double v27;
  int8x16_t v28;
  double v29;
  double v30;
  float64x2_t v31;
  double v32;
  int8x16_t v33;
  double v34;
  int8x16_t v35;
  double v36;
  double v37;
  float64x2_t v38;
  double v39;
  int8x16_t v40;
  double v41;
  double v42;
  float64x2_t v43;
  double v44;
  int8x16_t v45;
  uint8x8_t v46;
  double v47;
  int8x16_t v48;
  float32x2_t v50;
  double v51;
  double v52;
  float32x2_t v53;
  float64_t v55;

  v15 = *(float32x2_t *)CI::getDC((CI *)a1);
  v16 = vmul_f32(a3, v15);
  v17 = vadd_f32(a4, v16);
  v18 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
  HIDWORD(v19) = 1056964608;
  *(float32x2_t *)&v20.f64[0] = vadd_f32(vmul_f32(a7, vminnm_f32(vsub_f32(v17, vrndm_f32(v17)), v18)), (float32x2_t)0x3F0000003F000000);
  v21 = vadd_f32(a5, v16);
  v22 = vrndm_f32(v21);
  v50 = vadd_f32(vmul_f32(a7, vminnm_f32(vsub_f32(v21, v22), v18)), (float32x2_t)0x3F0000003F000000);
  v23 = vadd_f32(a6, v16);
  *(float32x2_t *)v24.i8 = vrndm_f32(v23);
  v53 = vadd_f32(vmul_f32(a7, vminnm_f32(vsub_f32(v23, *(float32x2_t *)v24.i8), v18)), (float32x2_t)0x3F0000003F000000);
  LODWORD(v19) = *(_DWORD *)(a2 + 28);
  v23.f32[0] = *(float *)(a2 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)&v20.f64[0], 1), *(float *)(a2 + 16), *(float *)v20.f64);
  v24.i32[0] = *(_DWORD *)(a2 + 36);
  v18.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)&v20.f64[0], 1), *(float *)&v19, *(float *)v20.f64);
  *(float *)v20.f64 = *(float *)v24.i32 + v18.f32[0];
  v23.f32[1] = *(float *)v24.i32 + v18.f32[0];
  v52 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v23, v20, *(double *)&v18, v19, v24, (uint8x8_t)v22, v25, v26);
  HIDWORD(v27) = v50.i32[1];
  LODWORD(v27) = *(_DWORD *)(a2 + 28);
  v28.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v50, 1), *(float *)&v27, v50.f32[0]);
  *(float *)&v30 = *(float *)(a2 + 24)
                 + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v50, 1), *(float *)(a2 + 16), v50.f32[0]);
  *(float *)v31.f64 = *(float *)v28.i32 + *(float *)&v29;
  *((float *)&v30 + 1) = *(float *)v28.i32 + *(float *)&v29;
  v51 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v30, v31, v27, v29, v28, (uint8x8_t)v50, v32, v33);
  HIDWORD(v34) = v53.i32[1];
  LODWORD(v34) = *(_DWORD *)(a2 + 28);
  v35.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v53, 1), *(float *)&v34, v53.f32[0]);
  *(float *)&v37 = *(float *)(a2 + 24)
                 + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v53, 1), *(float *)(a2 + 16), v53.f32[0]);
  *(float *)v38.f64 = *(float *)v35.i32 + *(float *)&v36;
  *((float *)&v37 + 1) = *(float *)v35.i32 + *(float *)&v36;
  v41 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v37, v38, v34, v36, v35, (uint8x8_t)v53, v39, v40);
  HIDWORD(v42) = HIDWORD(v52);
  v43.f64[1] = v55;
  *(float32x2_t *)&v43.f64[0] = vadd_f32(v15, vmul_n_f32((float32x2_t)vzip1_s32((int32x2_t)vsub_f32(*(float32x2_t *)&v51, *(float32x2_t *)&v52), (int32x2_t)vsub_f32(*(float32x2_t *)&v41, *(float32x2_t *)&v52)), a8));
  LODWORD(v44) = *(_DWORD *)(a1 + 28);
  *(float *)&v41 = *(float *)(a1 + 24)
                 + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v43.f64[0], 1), *(float *)(a1 + 16), *(float *)v43.f64);
  v45.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&v42 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v43.f64[0], 1), *(float *)&v44, *(float *)v43.f64);
  *(float *)v43.f64 = *(float *)v45.i32 + *(float *)&v42;
  *((float *)&v41 + 1) = *(float *)v45.i32 + *(float *)&v42;
  return CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v41, v43, v42, v44, v45, v46, v47, v48);
}

void CI::f4_sr_sr_f2_f2_f2_f2_f2_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, uint64_t, double, double, double, double, double, float);
  uint64_t v12;
  uint64_t v13;
  int v14;
  const vec2 *v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  double *v25;
  double *v26;
  double *v27;
  double *v28;
  double *v29;
  __int128 v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const vec2 *v36;
  double (*v37)(uint64_t, uint64_t, double, double, double, double, double, float);

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t, double, double, double, double, double, float))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_QWORD *)(v10 + 32);
  v14 = *(_DWORD *)(v10 + 64);
  v15 = *(const vec2 **)(v10 + 56);
  v16 = *(_DWORD *)(v10 + 88);
  v17 = *(_QWORD *)(v10 + 80);
  v18 = *(_DWORD *)(v10 + 112);
  v19 = *(_QWORD *)(v10 + 104);
  v20 = *(_DWORD *)(v10 + 136);
  v21 = *(_QWORD *)(v10 + 128);
  v22 = *(_DWORD *)(v10 + 160);
  v23 = *(_QWORD *)(v10 + 152);
  v24 = *(_QWORD *)(v10 + 176);
  if (*(_BYTE *)(a1 + 64))
  {
    v36 = *(const vec2 **)(v10 + 56);
    v37 = *(double (**)(uint64_t, uint64_t, double, double, double, double, double, float))(a1 + 24);
    v33 = *(_QWORD *)(v10 + 8);
    v34 = *(_QWORD *)(v10 + 80);
    v35 = *(_QWORD *)(v10 + 176);
    v31 = *(_DWORD *)(v10 + 160);
    v32 = *(_DWORD *)(v10 + 136);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 200)), v15);
    v22 = v31;
    v20 = v32;
    v17 = v34;
    v24 = v35;
    v15 = v36;
    v11 = v37;
    v12 = v33;
  }
  v25 = (double *)(a3 + 16 * v23);
  if (v22 != 5)
    v25 = (double *)(a2 + (v23 << 6));
  v26 = (double *)(a3 + 16 * v21);
  if (v20 != 5)
    v26 = (double *)(a2 + (v21 << 6));
  v27 = (double *)(a3 + 16 * v19);
  if (v18 != 5)
    v27 = (double *)(a2 + (v19 << 6));
  v28 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v28 = (double *)(a2 + (v17 << 6));
  v29 = (double *)(a3 + 16 * (_QWORD)v15);
  if (v14 != 5)
    v29 = (double *)(a2 + ((_QWORD)v15 << 6));
  *(double *)&v30 = v11(a4 + 80 * v12, a4 + 80 * v13, *v29, *v28, *v27, *v26, *v25, *(float *)(a2 + (v24 << 6)));
  *(_OWORD *)(a3 + 16 * a7) = v30;
}

double cikernel::_radialGradient(CI *a1, __n128 a2, float32x4_t a3, float32x4_t a4)
{
  float32x2_t *DC;
  float v12;
  float v13;
  double result;

  DC = (float32x2_t *)CI::getDC(a1);
  _V2.S[2] = a2.n128_u32[2];
  _D0 = vsub_f32((float32x2_t)a2.n128_u64[0], *DC);
  _D0.f32[0] = sqrtf(vaddv_f32(vmul_f32(_D0, _D0)));
  __asm { FMLA            S1, S0, V2.S[2] }
  if (_S1 <= 1.0)
    v12 = _S1;
  else
    v12 = 1.0;
  _NF = _S1 < 0.0;
  v13 = 0.0;
  if (!_NF)
    v13 = v12;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a3, 1.0 - v13), a4, v13).u64[0];
  return result;
}

void CI::f4_f4_clr_clr(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, __n128);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __n128 *v16;
  __int128 v17;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v16 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v16 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v17 = v11(a1, *v16, *((__n128 *)a2 + 4 * v14), *((__n128 *)a2 + 4 * v15));
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

double cikernel::_linearGradient(CI *a1, float32x2_t a2, float32x2_t a3, float32x4_t a4, float32x4_t a5, float a6)
{
  float v6;
  float v7;
  double result;

  v6 = vaddv_f32(vmul_f32(vsub_f32(a3, a2), vsub_f32(*(float32x2_t *)CI::getDC(a1), a2))) * a6;
  if (v6 <= 1.0)
    v7 = v6;
  else
    v7 = 1.0;
  if (v6 < 0.0)
    v7 = 0.0;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a4, 1.0 - v7), a5, v7).u64[0];
  return result;
}

void CI::f4_f2_f2_clr_clr_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(_QWORD *, double, double, __n128, __n128, float);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double *v18;
  double *v19;
  __int128 v20;

  v9 = a1[6];
  v10 = (double (*)(_QWORD *, double, double, __n128, __n128, float))a1[3];
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_QWORD *)(v9 + 80);
  v17 = *(_QWORD *)(v9 + 104);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
  v18 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v18 = (double *)((char *)a2 + 64 * v14);
  v19 = (double *)(a3 + 16 * v12);
  if (v11 != 5)
    v19 = (double *)((char *)a2 + 64 * v12);
  *(double *)&v20 = v10(a1, *v19, *v18, *((__n128 *)a2 + 4 * v15), *((__n128 *)a2 + 4 * v16), *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_smoothLinearGradient(CI *a1, float32x2_t a2, float32x2_t a3, float32x4_t a4, float32x4_t a5, float a6)
{
  float v6;
  float v7;
  BOOL v8;
  float v9;
  double result;

  v6 = vaddv_f32(vmul_f32(vsub_f32(a3, a2), vsub_f32(*(float32x2_t *)CI::getDC(a1), a2))) * a6;
  if (v6 <= 1.0)
    v7 = v6;
  else
    v7 = 1.0;
  v8 = v6 < 0.0;
  v9 = 0.0;
  if (!v8)
    v9 = v7;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a4, 1.0 - (float)((float)(v9 * v9) * (float)((float)(v9 * -2.0) + 3.0))), a5, (float)(v9 * v9) * (float)((float)(v9 * -2.0) + 3.0)).u64[0];
  return result;
}

double cikernel::_gaussianGradient(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float32x2_t v4;
  double v5;
  float v6;
  double result;

  v4 = vsub_f32(*(float32x2_t *)a2.f32, *(float32x2_t *)CI::getDC(a1));
  v5 = fminf(vmuls_lane_f32(sqrtf(vaddv_f32(vmul_f32(v4, v4))), a2, 2), 1.0);
  v6 = (v5 * -2.0 + 3.0) * v5 * v5;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a3, 1.0 - v6), a4, v6).u64[0];
  return result;
}

void CI::f4_f3_clr_clr(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v10;
  double (*v11)(_QWORD *, __n128, __n128, __n128);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;

  v10 = (_QWORD *)a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, __n128))a1[3];
  v12 = v10[1];
  v13 = v10[4];
  v14 = v10[7];
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * v10[10]), a2);
  *(double *)&v15 = v11(a1, *((__n128 *)a2 + 4 * v12), *((__n128 *)a2 + 4 * v13), *((__n128 *)a2 + 4 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v15;
}

double cikernel::_hsvwheel(CI *a1, float32x4_t a2)
{
  float32x2_t *DC;
  float32x4_t v3;
  float32x2_t v4;
  double v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float32x4_t v11;
  float32x4_t v17;
  float32x4_t v19;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float v26;
  float v27;
  float v28;
  double result;
  float32x2_t v30;

  DC = (float32x2_t *)CI::getDC(a1);
  v3 = a2;
  v4 = vsub_f32(*DC, (float32x2_t)vdup_lane_s32(*(int32x2_t *)a2.f32, 1));
  if (v4.f32[0] == 0.0)
  {
    v5 = -1.5;
    if (v4.f32[1] > 0.0)
      v5 = 1.5;
  }
  else
  {
    v30 = v4;
    v6 = atan2f(v4.f32[1], v4.f32[0]);
    v4 = v30;
    v3 = a2;
    v5 = v6 * 3.0 / 3.1415926;
  }
  v7 = sqrtf(vaddv_f32(vmul_f32(v4, v4)));
  v8 = v5;
  v9 = vmuls_lane_f32(v7, v3, 2);
  if (v9 <= 1.0)
    v10 = v9;
  else
    v10 = 1.0;
  if (v9 < 0.0)
    v10 = 0.0;
  v11.i32[3] = 0;
  v11.f32[0] = v8;
  v11.f32[1] = v8 + -2.0;
  v11.f32[2] = v8 + 2.0;
  __asm { FMOV            V16.4S, #3.0 }
  v17 = vabdq_f32(_Q16, vabsq_f32(v11));
  __asm { FMOV            V17.4S, #-1.0 }
  v19 = vmaxnmq_f32(vaddq_f32(v17, _Q17), (float32x4_t)0);
  __asm { FMOV            V17.4S, #1.0 }
  v21 = vminnmq_f32(v19, _Q17);
  v22 = vminnmq_f32(vmaxnmq_f32(v21, (float32x4_t)0), _Q17);
  v23.i64[0] = 0xC0000000C0000000;
  v23.i64[1] = 0xC0000000C0000000;
  v24 = vmulq_n_f32(v21, 1.0 - v3.f32[3]);
  v21.f32[0] = 1.0 - v10;
  v25 = vmulq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 0), vmlaq_laneq_f32(v24, vmulq_f32(vmulq_f32(v22, v22), vmlaq_f32(_Q16, v23, v22)), v3, 3), v10), v3.f32[0]);
  v25.i32[3] = 1.0;
  v26 = v3.f32[1] - v7;
  if (v26 <= 1.0)
    v27 = v26;
  else
    v27 = 1.0;
  if (v26 >= 0.0)
    v28 = v27;
  else
    v28 = 0.0;
  *(_QWORD *)&result = vmulq_n_f32(v25, v28).u64[0];
  return result;
}

void CI::f4_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128);
  int v12;
  uint64_t v13;
  __n128 *v14;
  __int128 v15;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 32)), a2);
  v14 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v14 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v15 = v11(a1, *v14);
  *(_OWORD *)(a3 + 16 * a7) = v15;
}

double cikernel::_hsvwheeldithered(CI *a1, float32x4_t a2, float a3)
{
  float32x2_t *DC;
  float32x4_t v5;
  float32x2_t v6;
  double v7;
  float v8;
  int32x2_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float32x4_t v16;
  float32x4_t v23;
  float32x4_t v25;
  float32x4_t v26;
  float32x2_t v27;
  float v28;
  double v29;
  float v30;
  float32x4_t v31;
  float v32;
  double result;
  float32x2_t v34;
  float32x4_t v36;

  DC = (float32x2_t *)CI::getDC(a1);
  v5 = a2;
  v6 = vsub_f32(*DC, (float32x2_t)vdup_lane_s32(*(int32x2_t *)a2.f32, 1));
  if (v6.f32[0] == 0.0)
  {
    v7 = -1.5;
    if (v6.f32[1] > 0.0)
      v7 = 1.5;
  }
  else
  {
    v34 = v6;
    v8 = atan2f(v6.f32[1], v6.f32[0]);
    v6 = v34;
    v5 = a2;
    v7 = v8 * 3.0 / 3.1415926;
  }
  v9 = (int32x2_t)vmul_f32(v6, v6);
  v10 = sqrtf(vaddv_f32((float32x2_t)v9));
  v11 = v5.f32[1];
  v12 = v7;
  v13 = vmuls_lane_f32(v10, v5, 2);
  v14 = 1.0;
  if (v13 <= 1.0)
    v14 = v13;
  if (v13 >= 0.0)
    v15 = v14;
  else
    v15 = 0.0;
  v16.i32[3] = 0;
  v16.f32[0] = v12;
  v16.f32[1] = v12 + -2.0;
  v16.f32[2] = v12 + 2.0;
  __asm
  {
    FMOV            V3.4S, #3.0
    FMOV            V4.4S, #-1.0
  }
  v23 = vmaxnmq_f32(vaddq_f32(vabdq_f32(_Q3, vabsq_f32(v16)), _Q4), (float32x4_t)0);
  __asm { FMOV            V4.4S, #1.0 }
  v25 = vminnmq_f32(v23, _Q4);
  v26 = vminnmq_f32(vmaxnmq_f32(v25, (float32x4_t)0), _Q4);
  v16.i64[0] = 0xC0000000C0000000;
  v16.i64[1] = 0xC0000000C0000000;
  *(float *)v9.i32 = 1.0 - v15;
  v36 = vmulq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v9, 0), vmlaq_laneq_f32(vmulq_n_f32(v25, 1.0 - v5.f32[3]), vmulq_f32(vmulq_f32(v26, v26), vmlaq_f32(_Q3, v16, v26)), v5, 3), v15), v5.f32[0]);
  v27 = vrndm_f32(*(float32x2_t *)CI::getDC((CI *)DC));
  v28 = (v27.f32[0] * 13.0 + 1111.0) / 17.0;
  v27.f32[0] = (v27.f32[1] * 11.0 + 7777.0) / 19.0;
  v27.f32[0] = v28
             + (float)(v27.f32[0]
                     * (float)((float)(v27.f32[0] + (float)(v27.f32[0] * v28))
                             + (float)(floorf((float)(v27.f32[0] + (float)(v27.f32[0] * v28)) / 37.0) * -37.0)));
  v27.f32[0] = (float)(v27.f32[0] + (float)(floorf(v27.f32[0] / 37.0) * -37.0)) * v28;
  v27.f32[0] = (float)(v27.f32[0] + (float)(floorf(v27.f32[0] / 37.0) * -37.0)) * v28;
  v29 = ((float)((float)(v27.f32[0] + (float)(floorf(v27.f32[0] / 37.0) * -37.0)) / 37.0) + -0.5) * a3;
  *(float *)&v29 = v29;
  v31 = vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v29, 0));
  v30 = 1.0;
  v31.i32[3] = 1.0;
  if ((float)(v11 - v10) <= 1.0)
    v30 = v11 - v10;
  if ((float)(v11 - v10) >= 0.0)
    v32 = v30;
  else
    v32 = 0.0;
  *(_QWORD *)&result = vmulq_n_f32(v31, v32).u64[0];
  return result;
}

void CI::f4_f4_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, float);
  int v12;
  uint64_t v13;
  uint64_t v14;
  __n128 *v15;
  __int128 v16;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, float))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 56)), a2);
  v15 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v15 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v16 = v11(a1, *v15, *((float *)a2 + 16 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v16;
}

id CIGVGraphCreate()
{
  if (CIGVGraphCreate_onceToken != -1)
    dispatch_once(&CIGVGraphCreate_onceToken, &__block_literal_global_36);
  if (CIGVGraphCreate_gvClass)
    return objc_alloc_init(MEMORY[0x1E0D27AC8]);
  else
    return 0;
}

uint64_t CIGVGraphAddNode(void *a1, const char *a2)
{
  return objc_msgSend(a1, "addNode:", a2);
}

uint64_t CIGVGraphAddEdge(void *a1, const char *a2, uint64_t a3)
{
  return objc_msgSend(a1, "addEdgeFrom:to:", a2, a3);
}

uint64_t CIGVGraphRender(void *a1, const char *a2)
{
  return objc_msgSend(a1, "render:", a2);
}

CIGVNode *CIGVNodeCreate()
{
  return objc_alloc_init(CIGVNode);
}

CIGVNode *CIGVNodeCreateForNode(uint64_t a1, double a2, double a3, double a4, double a5)
{
  return -[CIGVNode initWithCINode:extent:]([CIGVNode alloc], "initWithCINode:extent:", a1, a2, a3, a4, a5);
}

uint64_t CIGVNodeSetShape(void *a1, const char *a2)
{
  return objc_msgSend(a1, "setShape:", a2);
}

uint64_t CIGVNodeSetColor(void *a1, const char *a2)
{
  return objc_msgSend(a1, "setColor:", a2);
}

uint64_t CIGVNodeSetTitle(void *a1, const char *a2)
{
  return objc_msgSend(a1, "setTitle:", a2);
}

uint64_t CIGVNodeSetLabel(void *a1, const char *a2)
{
  return objc_msgSend(a1, "setLabel:", a2);
}

uint64_t CIGVNodeAddImage(void *a1, const char *a2)
{
  return objc_msgSend(a1, "addImage:", a2);
}

PDFRenderer *CIGVRendererCreatePDFRenderer()
{
  return objc_alloc_init(PDFRenderer);
}

PNGRenderer *CIGVRendererCreatePNGRenderer()
{
  return objc_alloc_init(PNGRenderer);
}

uint64_t CIGVRendererSetOutputFileURL(void *a1, uint64_t a2)
{
  uint64_t v3;

  if (a2)
    v3 = objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a2));
  else
    v3 = 0;
  return objc_msgSend(a1, "setFileURL:", v3);
}

uint64_t CIGVRendererSetOutputFileTitle(void *a1, uint64_t a2)
{
  return objc_msgSend(a1, "setFileTitle:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a2));
}

void CIGVDumpToFile(void *a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  id v7;
  void *v8;
  void *v9;
  uint64_t v10;

  if (a2 >= 3)
    CIGVDumpToFile_cold_1();
  v7 = objc_alloc_init(*off_1E2EC3FA0[a2]);
  if (v7)
  {
    v8 = v7;
    v9 = (void *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s/%s"), a3, a4);
    objc_msgSend(v8, "setFileTitle:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CI Render Graph"));
    v10 = objc_msgSend(v9, "UTF8String");
    if (v10)
      v10 = objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v10));
    objc_msgSend(v8, "setFileURL:", v10);
    objc_msgSend(a1, "render:", v8);
    objc_msgSend(v8, "flushRender");
    CFRelease(v8);
  }
}

double cikernel::_boxFilter3(cikernel *this, SamplerObj *a2)
{
  float32x2_t v3;
  float32x2_t v4;
  double v5;
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  float64x2_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  float32x2_t v13;
  double v14;
  double v15;
  int8x16_t v16;
  double v17;
  uint8x8_t v18;
  float32x4_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  double v26;
  uint8x8_t v27;
  float32x4_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x2_t v31;
  double v32;
  double v33;
  int8x16_t v34;
  double v35;
  uint8x8_t v36;
  float64x2_t v37;
  int8x16_t v38;
  float32x4_t v39;
  double result;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;

  v3 = *(float32x2_t *)CI::getDC(this);
  v4 = vadd_f32(v3, (float32x2_t)0x3F000000BF000000);
  *(float *)&v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v9, v5, v6, v8, v7, v10, v11);
  v13 = vadd_f32(v3, (float32x2_t)0x3F0000003F800000);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v13, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v15) = *((_DWORD *)this + 6);
  v16.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v17) = *((_DWORD *)this + 9);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v13, 1), *(float *)v16.i32, v13.f32[0]);
  v19 = (float32x4_t)vdupq_n_s32(0x3EE38E39u);
  v44 = vmulq_f32(v12, v19);
  v12.f32[0] = *(float *)&v15 + *(float *)&v14;
  v19.f32[0] = *(float *)&v17 + *(float *)v18.i32;
  v12.f32[1] = *(float *)&v17 + *(float *)v18.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v12.i64, (float64x2_t)v19, v15, v14, v16, v18, v17, v20);
  v22 = vadd_f32(v3, (float32x2_t)0xBF800000BF000000);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v22, 1), *((float *)this + 4), v22.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 6);
  v25.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v26) = *((_DWORD *)this + 9);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v22, 1), *(float *)v25.i32, v22.f32[0]);
  v28 = (float32x4_t)vdupq_n_s32(0x3E638E39u);
  v41 = v28;
  v43 = vmulq_f32(v21, v28);
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  v28.f32[0] = *(float *)&v26 + *(float *)v27.i32;
  v21.f32[1] = *(float *)&v26 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v21.i64, (float64x2_t)v28, v24, v23, v25, v27, v26, v29);
  v31 = vadd_f32(v3, (float32x2_t)0xBF8000003F800000);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v31, 1), *((float *)this + 4), v31.f32[0]);
  LODWORD(v33) = *((_DWORD *)this + 6);
  v34.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v35) = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v31, 1), *(float *)v34.i32, v31.f32[0]);
  v37 = (float64x2_t)v41;
  v42 = vmulq_f32(v30, v41);
  v30.f32[0] = *(float *)&v33 + *(float *)&v32;
  *(float *)v37.f64 = *(float *)&v35 + *(float *)v36.i32;
  v30.f32[1] = *(float *)&v35 + *(float *)v36.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v30.i64, v37, v33, v32, v34, v36, v35, v38);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vaddq_f32(v44, v43), v42), vmulq_f32(v39, (float32x4_t)vdupq_n_s32(0x3DE38E39u))).u64[0];
  return result;
}

double cikernel::_multiplyImages(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vmulq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_subtractImages(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vsubq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_computeAB(int8x16_t a1, int8x16_t a2, int8x16_t a3, double a4, double a5)
{
  int32x4_t v5;
  int8x8_t v6;
  int32x4_t v7;
  double v23;
  float32x4_t v26;
  float v28;
  float32x2_t v29;

  *(float *)&a4 = *(float *)a1.i32 + *(float *)&a5;
  v28 = *(float *)a1.i32 + *(float *)&a5;
  v5 = (int32x4_t)vextq_s8(a2, a2, 8uLL);
  *(float32x2_t *)v5.i8 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)a2.i8, *(int32x2_t *)v5.i8), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0));
  v26 = (float32x4_t)vextq_s8((int8x16_t)vzip1q_s32((int32x4_t)a2, v5), a2, 4uLL);
  v6 = *(int8x8_t *)a1.i8;
  v7 = (int32x4_t)vextq_s8(a1, a1, 8uLL);
  *(float32x2_t *)v7.i8 = vdiv_f32((float32x2_t)vext_s8(v6, *(int8x8_t *)v7.i8, 4uLL), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a4, 0));
  v29 = *(float32x2_t *)v7.i8;
  *(double *)_Q0.i64 = vec2::get_xxy((vec2 *)&v29, v7);
  _Q5 = a1;
  _Q0.i64[0] = vsubq_f32(v26, vmulq_f32((float32x4_t)vzip2q_s32((int32x4_t)vextq_s8(a1, a1, 0xCuLL), (int32x4_t)a1), _Q0)).u64[0];
  _S1 = vsub_f32((float32x2_t)vext_s8(*(int8x8_t *)a3.i8, (int8x8_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), 4uLL), vmul_n_f32(v29, *(float *)a3.i32)).u32[0];
  _S2 = _Q0.i32[1];
  _S3 = _Q0.f32[1] / _Q0.f32[0];
  __asm
  {
    FMLS            S4, S2, V3.S[0]
    FMLS            S2, S1, V3.S[0]
  }
  _S2 = _S2 / _S4;
  __asm { FMLS            S1, S2, V0.S[1] }
  _Q0.f32[0] = _S1 / _Q0.f32[0];
  __asm
  {
    FMLS            S1, S0, V5.S[1]
    FMLS            S1, S2, V5.S[2]
  }
  *(float *)&v23 = _S1 / v28;
  HIDWORD(v23) = _Q0.i32[0];
  return v23;
}

double cikernel::_finalResult(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  double result;

  v2 = vmulq_f32(a1, a2);
  *(_QWORD *)&result = vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)a1, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1)))), 0).u64[0];
  return result;
}

double cikernel::_swizzleXXX1(int32x2_t a1)
{
  double result;

  *(_QWORD *)&result = vdupq_lane_s32(a1, 0).u64[0];
  return result;
}

float cikernel::_swizzleYYZ1(double a1)
{
  return *((float *)&a1 + 1);
}

double cikernel::_swizzleYZZ1(int8x16_t a1)
{
  double result;

  *(_QWORD *)&result = vzip2q_s32((int32x4_t)vextq_s8(a1, a1, 0xCuLL), (int32x4_t)a1).u64[0];
  return result;
}

__n128 cikernel::_dotscreen(CI *a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  float32x2_t v4;
  int32x2_t v5;
  int32x2_t v6;
  float32x2_t v7;
  float32x2_t v8;
  float v9;
  float32x4_t v10;
  __n128 result;
  float v12;
  BOOL v13;

  v4 = vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a3.f32);
  v5 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v4);
  v6 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v4);
  v7 = vadd_f32(*(float32x2_t *)a3.f32, vadd_f32((float32x2_t)vzip1_s32(v5, v6), (float32x2_t)vzip2_s32(v5, v6)));
  v8 = vmul_f32(vminnm_f32(vsub_f32(v7, vrndm_f32(v7)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu)), (float32x2_t)vdup_n_s32(0x40C90FDBu));
  a4.i32[1] = v8.i32[1];
  v9 = sinf(v8.f32[0]);
  result.n128_f64[0] = (float)(v9 + sinf(*(float *)&a4.i32[1])) * 0.25 * (-1.0 / a3.f32[2] + 0.995) + 0.5;
  v10 = vmulq_f32(a2, (float32x4_t)xmmword_192492180);
  result.n128_f32[0] = result.n128_f64[0];
  result.n128_f32[0] = vmuls_lane_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0]- result.n128_f32[0], a3, 2)+ 0.5;
  v12 = 1.0;
  if (result.n128_f32[0] <= 1.0)
    v12 = result.n128_f32[0];
  v13 = result.n128_f32[0] < 0.0;
  result.n128_u32[0] = 0;
  if (!v13)
    result.n128_f32[0] = v12;
  result.n128_f32[0] = vmuls_lane_f32(result.n128_f32[0], a2, 3);
  result.n128_u64[0] = vdupq_lane_s32((int32x2_t)result.n128_u64[0], 0).u64[0];
  result.n128_u32[3] = a2.u32[3];
  return result;
}

void CI::f4_s_f3_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, __n128);
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  __n128 *v17;
  __n128 *v18;
  __int128 v19;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v17 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v16);
  v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v19 = v11(a1, *v18, *((__n128 *)a2 + 4 * v14), *v17);
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_hatchedscreen(CI *a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  float32x2_t v4;
  int32x2_t v5;
  int32x2_t v6;
  float32x2_t v7;
  float32x2_t v8;
  float32x2_t v14;
  float32x4_t v15;
  int32x2_t v16;
  float v17;
  double result;

  v4 = vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a3.f32);
  v5 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v4);
  v6 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v4);
  v7 = vadd_f32(*(float32x2_t *)a3.f32, vadd_f32((float32x2_t)vzip1_s32(v5, v6), (float32x2_t)vzip2_s32(v5, v6)));
  v8 = vminnm_f32(vsub_f32(v7, vrndm_f32(v7)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  __asm { FMOV            V1.2S, #1.0 }
  v14 = vminnm_f32(vsub_f32(_D1, v8), v8);
  v16 = (int32x2_t)vadd_f32(v14, v14);
  _D1.f32[0] = *(float *)&v16.i32[1] * 0.5 + 0.5;
  *(float *)v16.i32 = fminf(*(float *)v16.i32, _D1.f32[0]);
  v15 = vmulq_f32(a2, (float32x4_t)xmmword_192492180);
  *(float *)v16.i32 = vmuls_lane_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0]- *(float *)v16.i32, a3, 2)+ 0.5;
  v17 = 1.0;
  if (*(float *)v16.i32 <= 1.0)
    v17 = *(float *)v16.i32;
  _NF = *(float *)v16.i32 < 0.0;
  v16.i32[0] = 0;
  if (!_NF)
    *(float *)v16.i32 = v17;
  *(float *)v16.i32 = vmuls_lane_f32(*(float *)v16.i32, a2, 3);
  *(_QWORD *)&result = vdupq_lane_s32(v16, 0).u64[0];
  return result;
}

double cikernel::_linescreen(CI *a1, float32x4_t a2, float32x4_t a3, int8x16_t a4)
{
  float32x2_t v4;
  int32x2_t v5;
  int32x2_t v6;
  float32x2_t v7;
  float v8;
  float32x4_t v9;
  int32x2_t v10;
  BOOL v11;
  double result;

  v4 = vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a3.f32);
  v5 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v4);
  v6 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v4);
  v7 = vadd_f32(*(float32x2_t *)a3.f32, vadd_f32((float32x2_t)vzip1_s32(v5, v6), (float32x2_t)vzip2_s32(v5, v6)));
  v10 = (int32x2_t)vminnm_f32(vsub_f32(v7, vrndm_f32(v7)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  v8 = 1.0;
  *(float *)v10.i32 = fminf(1.0 - *(float *)v10.i32, *(float *)v10.i32);
  v9 = vmulq_f32(a2, (float32x4_t)xmmword_192492180);
  *(float *)v10.i32 = vmuls_lane_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0]- (float)(*(float *)v10.i32 + *(float *)v10.i32), a3, 2)+ 0.5;
  if (*(float *)v10.i32 <= 1.0)
    v8 = *(float *)v10.i32;
  v11 = *(float *)v10.i32 < 0.0;
  v10.i32[0] = 0;
  if (!v11)
    *(float *)v10.i32 = v8;
  *(float *)v10.i32 = vmuls_lane_f32(*(float *)v10.i32, a2, 3);
  *(_QWORD *)&result = vdupq_lane_s32(v10, 0).u64[0];
  return result;
}

__n128 cikernel::_circularscreen(CI *a1, float32x4_t a2, float32x4_t a3)
{
  float v3;
  float32x4_t v4;
  __n128 result;
  BOOL v6;

  result.n128_u64[0] = (unint64_t)vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a3.f32);
  result.n128_f32[0] = vmuls_lane_f32(sqrtf(vaddv_f32(vmul_f32((float32x2_t)result.n128_u64[0], (float32x2_t)result.n128_u64[0]))), a3, 2);
  result.n128_f32[0] = result.n128_f32[0] - floorf(result.n128_f32[0]);
  v3 = 1.0;
  v4 = vmulq_f32(a2, (float32x4_t)xmmword_192492180);
  result.n128_f64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0]+ fminf(1.0 - result.n128_f32[0], result.n128_f32[0]) * -2.0;
  result.n128_f32[0] = result.n128_f64[0];
  result.n128_f32[0] = vmuls_lane_f32(result.n128_f32[0], a3, 3) + 0.5;
  if (result.n128_f32[0] <= 1.0)
    v3 = result.n128_f32[0];
  v6 = result.n128_f32[0] < 0.0;
  result.n128_u32[0] = 0;
  if (!v6)
    result.n128_f32[0] = v3;
  result.n128_u64[0] = vmulq_laneq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)result.n128_u64[0], 0), a2, 3).u64[0];
  result.n128_u32[3] = a2.u32[3];
  return result;
}

void CI::f4_s_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __n128 *v16;
  __n128 *v17;
  __int128 v18;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 56)), a2);
  v16 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v16 = (__n128 *)((char *)a2 + 64 * v15);
  v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v18 = v11(a1, *v17, *v16);
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

float32x4_t cikernel::_highlightsAndShadows2(int32x4_t a1, float32x4_t a2, int32x4_t a3)
{
  float32x4_t v3;
  float32x4_t v4;
  long double v5;
  float v6;
  simd_float4 v7;
  float32x4_t v8;
  float v9;
  float v10;
  float v11;
  float v12;
  simd_float4 v13;
  simd_float4 v14;
  float32x4_t v15;
  float v16;
  float32x4_t v17;
  float v18;
  float v19;
  float v20;
  float v21;
  int8x16_t v22;
  simd_float4 v28;
  simd_float4 v29;
  float32x4_t v30;
  float32x4_t v31;
  double v32;
  float v33;
  float v34;
  float v35;
  float v36;
  int32x2_t v37;
  float v38;
  float v39;
  float32x4_t v40;
  float v41;
  float v42;
  float v43;
  float32x4_t v44;
  float v45;
  float32x4_t v46;
  float32x4_t v47;
  float v48;
  double v49;
  float v50;
  float v51;
  float32x4_t v52;
  float32x4_t result;
  float32x4_t v54;
  float v55;
  float v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float v61;
  float32x4_t v62;
  float32x4_t v63;
  float v65;

  v3 = (float32x4_t)a1;
  v3.i32[3] = 0;
  v62 = v3;
  v58 = vmaxnmq_f32(v3, (float32x4_t)0);
  v4 = vmulq_f32(v58, (float32x4_t)xmmword_192495040);
  v5 = pow(fminf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0]/ fmaxf(vaddq_f32((float32x4_t)vdupq_laneq_s32(a1, 2), vaddq_f32((float32x4_t)a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.i8, 1))).f32[0], 0.001), 1.0), 1.0 - *(float *)a3.i32)* *(float *)a3.i32;
  v6 = v5;
  *(float *)&v5 = -v6;
  v7 = (simd_float4)vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v5, 0), a2);
  v7.i32[3] = 0;
  v8 = vaddq_f32((float32x4_t)vdupq_laneq_s32(a3, 2), vmulq_n_f32((float32x4_t)_simd_pow_f4((simd_float4)xmmword_192495050, v7), 1.0 - *(float *)&a3.i32[2]));
  v56 = v8.f32[0];
  v61 = fmaxf(fmaxf(fmaxf(a2.f32[0], a2.f32[1]), a2.f32[2]), 0.0);
  v65 = sqrtf(v61);
  v9 = (float)(*(float *)a3.i32 + -0.5) + (float)(*(float *)a3.i32 + -0.5);
  if (v9 <= 1.0)
    v10 = (float)(*(float *)a3.i32 + -0.5) + (float)(*(float *)a3.i32 + -0.5);
  else
    v10 = 1.0;
  if (v9 >= 0.0)
    v11 = v10;
  else
    v11 = 0.0;
  v12 = (float)((float)(v11 * v11) * (float)((float)(v11 * -2.0) + 3.0)) * 0.5 + 0.5;
  v63 = vminnmq_f32(v62, (float32x4_t)0);
  v55 = v12;
  v13 = (simd_float4)vmulq_n_f32(v58, v12);
  v13.i32[3] = 0;
  v14 = (simd_float4)v8;
  v14.i32[3] = 0;
  v15 = vmulq_n_f32((float32x4_t)_simd_pow_f4(v13, v14), v6 + 1.0);
  v59 = vaddq_f32(v15, v15);
  v54 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_192495080, (float32x4_t)a1, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_192495070, *(float32x2_t *)a1.i8, 1), vmulq_n_f32((float32x4_t)xmmword_192495060, *(float *)a1.i32)));
  v16 = powf(fmaxf(v54.f32[0], 0.0) * v55, v56);
  v17 = vmlaq_f32(vmulq_f32(v59, (float32x4_t)vdupq_n_s32(0x3F266666u)), (float32x4_t)vdupq_n_s32(0x3EB33333u), vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1924950B0, v54, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_1924950A0, *(float32x2_t *)v54.f32, 1), vmulq_n_f32((float32x4_t)xmmword_192495090, v16 + v16))));
  v18 = v6 + 0.1;
  v19 = sqrtf(v65) / v18;
  if (v19 <= 1.0)
    v20 = v19;
  else
    v20 = 1.0;
  if (v19 >= 0.0)
    v21 = v20;
  else
    v21 = 0.0;
  v60 = vmlaq_n_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - (float)((float)(v21 * v21) * (float)((float)(v21 * -2.0) + 3.0))), v17, (float)(v21 * v21) * (float)((float)(v21 * -2.0) + 3.0)), 1.0 - v65), (float32x4_t)a1, v65);
  v22.i64[0] = 0x8000000080000000;
  v22.i64[1] = 0x8000000080000000;
  __asm { FMOV            V1.4S, #1.0 }
  v57 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32((float32x4_t)a1), (int8x16_t)vcgtzq_f32((float32x4_t)a1)), vorrq_s8(vandq_s8((int8x16_t)a1, v22), _Q1), (int8x16_t)0);
  _Q1.i32[1] = a3.i32[1];
  v28 = (simd_float4)vmulq_laneq_f32(vabsq_f32((float32x4_t)a1), (float32x4_t)a3, 3);
  *(float *)_Q1.i32 = 2.0 - *(float *)&a3.i32[1];
  v28.i32[3] = 0;
  v29 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)_Q1.i8, 0);
  v29.i32[3] = 0;
  v30 = vmulq_f32(v57, (float32x4_t)_simd_pow_f4(v28, v29));
  v31 = vmulq_f32(v30, (float32x4_t)xmmword_1924921A0);
  v32 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2), vaddq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1))).f32[0];
  v33 = v32 * -2.6 + v32 * -2.6 * v32 + 0.98;
  v34 = v32 * -6.25 + v32 * -6.25 * v32 + 0.5965;
  v35 = fmaxf(fmaxf(v33, v34), 1.0);
  v36 = *(float *)&a3.i32[1] + 0.3;
  v37.i32[1] = 1071225241;
  v38 = (1.0 - fminf(v36, 1.0)) * 0.4 + 1.0;
  *(float *)v37.i32 = (float)(1.0 - v38) * 0.25;
  v39 = (1.0 - *(float *)&a3.i32[1]) * fminf(v35, v61 * 30.0);
  v40 = vmlaq_n_f32(vmulq_n_f32(v30, 1.0 - v39), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v37, 0), v30, v38), v39);
  v41 = (float)(v65 + -0.2) / 0.6;
  if (v41 <= 1.0)
    v42 = (float)(v65 + -0.2) / 0.6;
  else
    v42 = 1.0;
  if (v41 >= 0.0)
    v43 = v42;
  else
    v43 = 0.0;
  v44 = vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - (float)((float)(v43 * v43) * (float)((float)(v43 * -2.0) + 3.0))), v40, (float)(v43 * v43) * (float)((float)(v43 * -2.0) + 3.0));
  v45 = fminf(v65, 1.0);
  v46 = vmlaq_n_f32(vmulq_n_f32(v60, 1.0 - v45), vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - v61), v44, v61), v45);
  v47 = vmulq_f32(v46, (float32x4_t)xmmword_1924921A0);
  *(double *)v47.i64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1))).f32[0];
  v48 = *(double *)v47.i64 * -2.6 + *(double *)v47.i64 * -2.6 * *(double *)v47.i64 + 0.98;
  v47.f32[0] = *(double *)v47.i64 * -6.25 + *(double *)v47.i64 * -6.25 * *(double *)v47.i64 + 0.5965;
  v47.f32[0] = fmaxf(fmaxf(v48, v47.f32[0]), 1.0);
  v49 = 1.0 - *(float *)&a3.i32[2];
  v50 = v49 * (fabsf(v6) * 0.1);
  v51 = v50 + 1.0;
  *(float *)&v49 = (float)(1.0 - v51) * 0.5;
  v47.f32[0] = fminf(v47.f32[0], v61 * 30.0);
  v52 = vmlaq_n_f32(vmulq_n_f32(v46, 1.0 - v47.f32[0]), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v49, 0), v46, v51), v47.f32[0]);
  v52.i32[3] = 0;
  result = vmaxnmq_f32(v52, (float32x4_t)0);
  result.i64[0] = vaddq_f32(v63, result).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

void CI::f4_s_s_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, __n128);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __n128 *v20;
  __int128 v21;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_DWORD *)(v10 + 64);
  v17 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v15);
  v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v21 = v11(a1, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

float32x4_t cikernel::_highlightsAndShadows_noblur2(float32x4_t a1, int32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float v4;
  float v5;
  long double v6;
  float v7;
  simd_float4 v8;
  float32x4_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  simd_float4 v14;
  simd_float4 v15;
  float32x4_t v16;
  float32x4_t v17;
  int8x16_t v18;
  float v19;
  float v20;
  float v21;
  float32x4_t v22;
  float v23;
  float v24;
  float v25;
  float v26;
  int8x16_t v27;
  simd_float4 v33;
  simd_float4 v34;
  float32x4_t v35;
  float32x4_t v36;
  double v37;
  float v38;
  float v39;
  float v40;
  float v41;
  int32x2_t v42;
  float v43;
  float v44;
  float32x4_t v45;
  float v46;
  float v47;
  float v48;
  float32x4_t v49;
  float v50;
  float32x4_t v51;
  float32x4_t v52;
  float v53;
  double v54;
  float v55;
  float v56;
  float32x4_t v57;
  float32x4_t result;
  float32x4_t v59;
  float v60;
  float v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float v66;
  float32x4_t v67;
  float32x4_t v68;
  float v69;

  v2 = a1;
  v2.i32[3] = 0;
  v67 = v2;
  v63 = vmaxnmq_f32(v2, (float32x4_t)0);
  v3 = vmulq_f32(v63, (float32x4_t)xmmword_192495040);
  v4 = a1.f32[1];
  v5 = a1.f32[2];
  v6 = pow(fminf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0]/ fmaxf(a1.f32[2] + vaddv_f32(*(float32x2_t *)a1.f32), 0.001), 1.0), 1.0 - *(float *)a2.i32)* *(float *)a2.i32;
  v7 = v6;
  *(float *)&v6 = -v7;
  v8 = (simd_float4)vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v6, 0), a1);
  v8.i32[3] = 0;
  v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 2), vmulq_n_f32((float32x4_t)_simd_pow_f4((simd_float4)xmmword_192495050, v8), 1.0 - *(float *)&a2.i32[2]));
  v61 = v9.f32[0];
  v66 = fmaxf(fmaxf(fmaxf(a1.f32[0], v4), v5), 0.0);
  v69 = sqrtf(v66);
  v10 = (float)(*(float *)a2.i32 + -0.5) + (float)(*(float *)a2.i32 + -0.5);
  v11 = 1.0;
  if (v10 <= 1.0)
    v11 = (float)(*(float *)a2.i32 + -0.5) + (float)(*(float *)a2.i32 + -0.5);
  if (v10 >= 0.0)
    v12 = v11;
  else
    v12 = 0.0;
  v13 = (float)((float)(v12 * v12) * (float)((float)(v12 * -2.0) + 3.0)) * 0.5 + 0.5;
  v68 = vminnmq_f32(v67, (float32x4_t)0);
  v60 = v13;
  v14 = (simd_float4)vmulq_n_f32(v63, v13);
  v14.i32[3] = 0;
  v15 = (simd_float4)v9;
  v15.i32[3] = 0;
  v16 = vmulq_n_f32((float32x4_t)_simd_pow_f4(v14, v15), v7 + 1.0);
  v64 = vaddq_f32(v16, v16);
  v17 = vmulq_laneq_f32((float32x4_t)xmmword_192495080, a1, 2);
  v18 = (int8x16_t)vaddq_f32(v17, vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_192495070, *(float32x2_t *)a1.f32, 1), vmulq_n_f32((float32x4_t)xmmword_192495060, a1.f32[0])));
  v59 = (float32x4_t)v18;
  v16.i64[0] = 0x8000000080000000;
  v16.i64[1] = 0x8000000080000000;
  v17.i32[0] = 1.0;
  LODWORD(v19) = vbslq_s8((int8x16_t)v16, (int8x16_t)v17, v18).u32[0];
  if (*(float *)v18.i32 == 0.0)
    v19 = 0.0;
  v20 = v19;
  v21 = powf(fabsf(*(float *)v18.i32) * v60, v61);
  v22 = vmlaq_f32(vmulq_f32(v64, (float32x4_t)vdupq_n_s32(0x3F266666u)), (float32x4_t)vdupq_n_s32(0x3EB33333u), vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1924950B0, v59, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_1924950A0, *(float32x2_t *)v59.f32, 1), vmulq_n_f32((float32x4_t)xmmword_192495090, (float)(v20 * v21) + (float)(v20 * v21)))));
  v23 = v7 + 0.1;
  v24 = sqrtf(v69) / v23;
  if (v24 <= 1.0)
    v25 = v24;
  else
    v25 = 1.0;
  if (v24 >= 0.0)
    v26 = v25;
  else
    v26 = 0.0;
  v65 = vmlaq_n_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - (float)((float)(v26 * v26) * (float)((float)(v26 * -2.0) + 3.0))), v22, (float)(v26 * v26) * (float)((float)(v26 * -2.0) + 3.0)), 1.0 - v69), a1, v69);
  v27.i64[0] = 0x8000000080000000;
  v27.i64[1] = 0x8000000080000000;
  __asm { FMOV            V1.4S, #1.0 }
  v62 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgtzq_f32(a1)), vorrq_s8(vandq_s8((int8x16_t)a1, v27), _Q1), (int8x16_t)0);
  _Q1.i32[1] = a2.i32[1];
  v33 = (simd_float4)vmulq_laneq_f32(vabsq_f32(a1), (float32x4_t)a2, 3);
  *(float *)_Q1.i32 = 2.0 - *(float *)&a2.i32[1];
  v33.i32[3] = 0;
  v34 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)_Q1.i8, 0);
  v34.i32[3] = 0;
  v35 = vmulq_f32(v62, (float32x4_t)_simd_pow_f4(v33, v34));
  v36 = vmulq_f32(v35, (float32x4_t)xmmword_1924921A0);
  v37 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).f32[0];
  v38 = v37 * -2.6 + v37 * -2.6 * v37 + 0.98;
  v39 = v37 * -6.25 + v37 * -6.25 * v37 + 0.5965;
  v40 = fmaxf(fmaxf(v38, v39), 1.0);
  v41 = *(float *)&a2.i32[1] + 0.3;
  v42.i32[1] = 1071225241;
  v43 = (1.0 - fminf(v41, 1.0)) * 0.4 + 1.0;
  *(float *)v42.i32 = (float)(1.0 - v43) * 0.25;
  v44 = (1.0 - *(float *)&a2.i32[1]) * fminf(v40, v66 * 30.0);
  v45 = vmlaq_n_f32(vmulq_n_f32(v35, 1.0 - v44), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v42, 0), v35, v43), v44);
  v46 = (float)(v69 + -0.2) / 0.6;
  if (v46 <= 1.0)
    v47 = (float)(v69 + -0.2) / 0.6;
  else
    v47 = 1.0;
  if (v46 >= 0.0)
    v48 = v47;
  else
    v48 = 0.0;
  v49 = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - v66), vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - (float)((float)(v48 * v48) * (float)((float)(v48 * -2.0) + 3.0))), v45, (float)(v48 * v48) * (float)((float)(v48 * -2.0) + 3.0)), v66);
  v50 = fminf(v69, 1.0);
  v51 = vmlaq_n_f32(vmulq_n_f32(v65, 1.0 - v50), v49, v50);
  v52 = vmulq_f32(v51, (float32x4_t)xmmword_1924921A0);
  *(double *)v52.i64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 2), vaddq_f32(v52, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 1))).f32[0];
  v53 = *(double *)v52.i64 * -2.6 + *(double *)v52.i64 * -2.6 * *(double *)v52.i64 + 0.98;
  v52.f32[0] = *(double *)v52.i64 * -6.25 + *(double *)v52.i64 * -6.25 * *(double *)v52.i64 + 0.5965;
  v52.f32[0] = fmaxf(fmaxf(v53, v52.f32[0]), 1.0);
  v54 = 1.0 - *(float *)&a2.i32[2];
  v55 = v54 * (fabsf(v7) * 0.1);
  v56 = v55 + 1.0;
  *(float *)&v54 = (float)(1.0 - v56) * 0.5;
  v52.f32[0] = fminf(v52.f32[0], v66 * 30.0);
  v57 = vmlaq_n_f32(vmulq_n_f32(v51, 1.0 - v52.f32[0]), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v54, 0), v51, v56), v52.f32[0]);
  v57.i32[3] = 0;
  result = vmaxnmq_f32(v57, (float32x4_t)0);
  result.i64[0] = vaddq_f32(v68, result).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

float32x4_t cikernel::_highlightsAndShadows1(int32x4_t a1, float32x4_t a2, int32x4_t a3)
{
  float32x4_t v3;
  float32x4_t v4;
  long double v5;
  float v6;
  simd_float4 v7;
  float32x4_t v8;
  float v9;
  float v10;
  float v11;
  float v12;
  int8x16_t v13;
  simd_float4 v19;
  simd_float4 v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  float v24;
  float v25;
  float v26;
  float32x4_t v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  int32x2_t v33;
  simd_float4 v34;
  simd_float4 v35;
  float32x4_t v36;
  float32x4_t v37;
  double v38;
  float v39;
  float v40;
  float v41;
  float v42;
  int32x2_t v43;
  float v44;
  float v45;
  float32x4_t v46;
  float v47;
  float v48;
  float v49;
  float32x4_t v50;
  float v51;
  float32x4_t v52;
  float v53;
  double v54;
  float v55;
  float v56;
  float32x4_t v57;
  float v58;
  float32x4_t result;
  float32x4_t v60;
  float v61;
  float v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float v66;
  float v67;
  float32x4_t v69;

  v3 = (float32x4_t)a1;
  v3.i32[3] = 0;
  v4 = vmulq_f32(vmaxnmq_f32(v3, (float32x4_t)0), (float32x4_t)xmmword_192495040);
  v5 = pow(fminf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0]/ fmaxf(vaddq_f32((float32x4_t)vdupq_laneq_s32(a1, 2), vaddq_f32((float32x4_t)a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.i8, 1))).f32[0], 0.001), 1.0), 1.0 - *(float *)a3.i32)* *(float *)a3.i32;
  v6 = v5;
  *(float *)&v5 = -v6;
  v7 = (simd_float4)vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v5, 0), a2);
  v7.i32[3] = 0;
  v8 = vaddq_f32((float32x4_t)vdupq_laneq_s32(a3, 2), vmulq_n_f32((float32x4_t)_simd_pow_f4((simd_float4)xmmword_192495050, v7), 1.0 - *(float *)&a3.i32[2]));
  v61 = v8.f32[0];
  v66 = fmaxf(fmaxf(fmaxf(a2.f32[0], a2.f32[1]), a2.f32[2]), 0.0);
  v67 = sqrtf(v66);
  v9 = (float)(*(float *)a3.i32 + -0.5) + (float)(*(float *)a3.i32 + -0.5);
  v10 = 1.0;
  if (v9 <= 1.0)
    v10 = (float)(*(float *)a3.i32 + -0.5) + (float)(*(float *)a3.i32 + -0.5);
  if (v9 >= 0.0)
    v11 = v10;
  else
    v11 = 0.0;
  v12 = (float)((float)(v11 * v11) * (float)((float)(v11 * -2.0) + 3.0)) * 0.5 + 0.5;
  v62 = v12;
  v13.i64[0] = 0x8000000080000000;
  v13.i64[1] = 0x8000000080000000;
  __asm { FMOV            V1.4S, #1.0 }
  v69 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32((float32x4_t)a1), (int8x16_t)vcgtzq_f32((float32x4_t)a1)), vorrq_s8(vandq_s8((int8x16_t)a1, v13), _Q1), (int8x16_t)0);
  v63 = vabsq_f32((float32x4_t)a1);
  v19 = (simd_float4)vmulq_n_f32(v63, v12);
  v19.i32[3] = 0;
  v20 = (simd_float4)v8;
  v20.i32[3] = 0;
  v21 = vmulq_f32(v69, (float32x4_t)_simd_pow_f4(v19, v20));
  v64 = vaddq_f32(v21, v21);
  v22 = vmulq_laneq_f32((float32x4_t)xmmword_192495080, (float32x4_t)a1, 2);
  v23 = (int8x16_t)vaddq_f32(v22, vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_192495070, *(float32x2_t *)a1.i8, 1), vmulq_n_f32((float32x4_t)xmmword_192495060, *(float *)a1.i32)));
  v60 = (float32x4_t)v23;
  v21.i64[0] = 0x8000000080000000;
  v21.i64[1] = 0x8000000080000000;
  v22.i32[0] = 1.0;
  LODWORD(v24) = vbslq_s8((int8x16_t)v21, (int8x16_t)v22, v23).u32[0];
  if (*(float *)v23.i32 == 0.0)
    v24 = 0.0;
  v25 = v24;
  v26 = powf(fabsf(*(float *)v23.i32) * v62, v61);
  v27 = vmlaq_f32(vmulq_f32(v64, (float32x4_t)vdupq_n_s32(0x3F266666u)), (float32x4_t)vdupq_n_s32(0x3EB33333u), vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1924950B0, v60, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_1924950A0, *(float32x2_t *)v60.f32, 1), vmulq_n_f32((float32x4_t)xmmword_192495090, (float)(v25 * v26) + (float)(v25 * v26)))));
  v28 = v6 + 0.1;
  v29 = sqrtf(v67) / v28;
  if (v29 <= 1.0)
    v30 = v29;
  else
    v30 = 1.0;
  if (v29 >= 0.0)
    v31 = v30;
  else
    v31 = 0.0;
  v32 = sqrtf((float)(v31 * v31) * (float)((float)(v31 * -2.0) + 3.0));
  v65 = vmlaq_n_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - v32), v27, v32), 1.0 - v67), (float32x4_t)a1, v67);
  v33.i32[1] = a3.i32[1];
  v34 = (simd_float4)vmulq_laneq_f32(v63, (float32x4_t)a3, 3);
  *(float *)v33.i32 = 2.0 - *(float *)&a3.i32[1];
  v34.i32[3] = 0;
  v35 = (simd_float4)vdupq_lane_s32(v33, 0);
  v35.i32[3] = 0;
  v36 = vmulq_f32(v69, (float32x4_t)_simd_pow_f4(v34, v35));
  v37 = vmulq_f32(v36, (float32x4_t)xmmword_1924921A0);
  v38 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).f32[0];
  v39 = v38 * -2.6 + v38 * -2.6 * v38 + 0.98;
  v40 = v38 * -6.25 + v38 * -6.25 * v38 + 0.5965;
  v41 = fmaxf(fmaxf(v39, v40), 1.0);
  v42 = *(float *)&a3.i32[1] + 0.3;
  v43.i32[1] = 1071225241;
  v44 = (1.0 - fminf(v42, 1.0)) * 0.4 + 1.0;
  *(float *)v43.i32 = (float)(1.0 - v44) * 0.25;
  v45 = (1.0 - *(float *)&a3.i32[1]) * fminf(v41, v66 * 30.0);
  v46 = vmlaq_n_f32(vmulq_n_f32(v36, 1.0 - v45), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v43, 0), v36, v44), v45);
  v47 = (float)(v67 + -0.2) / 0.6;
  if (v47 <= 1.0)
    v48 = (float)(v67 + -0.2) / 0.6;
  else
    v48 = 1.0;
  if (v47 >= 0.0)
    v49 = v48;
  else
    v49 = 0.0;
  v50 = vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - v66), vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - (float)((float)(v49 * v49) * (float)((float)(v49 * -2.0) + 3.0))), v46, (float)(v49 * v49) * (float)((float)(v49 * -2.0) + 3.0)), v66);
  v51 = fminf(v67, 1.0);
  v52 = vmlaq_n_f32(vmulq_n_f32(v65, 1.0 - v51), v50, v51);
  result = vmulq_f32(v52, (float32x4_t)xmmword_1924921A0);
  *(double *)result.i64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)result, 2), vaddq_f32(result, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)result.f32, 1))).f32[0];
  v53 = *(double *)result.i64 * -2.6 + *(double *)result.i64 * -2.6 * *(double *)result.i64 + 0.98;
  result.f32[0] = *(double *)result.i64 * -6.25 + *(double *)result.i64 * -6.25 * *(double *)result.i64 + 0.5965;
  result.f32[0] = fmaxf(fmaxf(v53, result.f32[0]), 1.0);
  v54 = 1.0 - *(float *)&a3.i32[2];
  v55 = v54 * (fabsf(v6) * 0.1);
  v56 = v55 + 1.0;
  *(float *)&v54 = (float)(1.0 - v56) * 0.5;
  v57 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v54, 0), v52, v56);
  v58 = fminf(result.f32[0], v66 * 30.0);
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(v52, 1.0 - v58), v57, v58).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

float32x4_t cikernel::_highlightsAndShadows_noblur1(float32x4_t a1, int32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float v4;
  float v5;
  long double v6;
  float v7;
  simd_float4 v8;
  float32x4_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  int8x16_t v14;
  simd_float4 v20;
  simd_float4 v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float v25;
  float v26;
  float v27;
  float32x4_t v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  int32x2_t v34;
  simd_float4 v35;
  simd_float4 v36;
  float32x4_t v37;
  float32x4_t v38;
  double v39;
  float v40;
  float v41;
  float v42;
  float v43;
  int32x2_t v44;
  float v45;
  float v46;
  float32x4_t v47;
  float v48;
  float v49;
  float v50;
  float32x4_t v51;
  float v52;
  float32x4_t v53;
  float v54;
  double v55;
  float v56;
  float v57;
  float32x4_t v58;
  float v59;
  float32x4_t result;
  float32x4_t v61;
  float v62;
  float v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float v67;
  float v68;
  float32x4_t v69;

  v2 = a1;
  v2.i32[3] = 0;
  v3 = vmulq_f32(vmaxnmq_f32(v2, (float32x4_t)0), (float32x4_t)xmmword_192495040);
  v4 = a1.f32[1];
  v5 = a1.f32[2];
  v6 = pow(fminf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0]/ fmaxf(a1.f32[2] + vaddv_f32(*(float32x2_t *)a1.f32), 0.001), 1.0), 1.0 - *(float *)a2.i32)* *(float *)a2.i32;
  v7 = v6;
  *(float *)&v6 = -v7;
  v8 = (simd_float4)vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v6, 0), a1);
  v8.i32[3] = 0;
  v9 = vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 2), vmulq_n_f32((float32x4_t)_simd_pow_f4((simd_float4)xmmword_192495050, v8), 1.0 - *(float *)&a2.i32[2]));
  v62 = v9.f32[0];
  v67 = fmaxf(fmaxf(fmaxf(a1.f32[0], v4), v5), 0.0);
  v68 = sqrtf(v67);
  v10 = (float)(*(float *)a2.i32 + -0.5) + (float)(*(float *)a2.i32 + -0.5);
  v11 = 1.0;
  if (v10 <= 1.0)
    v11 = (float)(*(float *)a2.i32 + -0.5) + (float)(*(float *)a2.i32 + -0.5);
  if (v10 >= 0.0)
    v12 = v11;
  else
    v12 = 0.0;
  v13 = (float)((float)(v12 * v12) * (float)((float)(v12 * -2.0) + 3.0)) * 0.5 + 0.5;
  v14.i64[0] = 0x8000000080000000;
  v14.i64[1] = 0x8000000080000000;
  __asm { FMOV            V1.4S, #1.0 }
  v69 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgtzq_f32(a1)), vorrq_s8(vandq_s8((int8x16_t)a1, v14), _Q1), (int8x16_t)0);
  v63 = v13;
  v64 = vabsq_f32(a1);
  v20 = (simd_float4)vmulq_n_f32(v64, v13);
  v20.i32[3] = 0;
  v21 = (simd_float4)v9;
  v21.i32[3] = 0;
  v22 = vmulq_f32(v69, (float32x4_t)_simd_pow_f4(v20, v21));
  v65 = vaddq_f32(v22, v22);
  v23 = vmulq_laneq_f32((float32x4_t)xmmword_192495080, a1, 2);
  v24 = (int8x16_t)vaddq_f32(v23, vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_192495070, *(float32x2_t *)a1.f32, 1), vmulq_n_f32((float32x4_t)xmmword_192495060, a1.f32[0])));
  v61 = (float32x4_t)v24;
  v22.i64[0] = 0x8000000080000000;
  v22.i64[1] = 0x8000000080000000;
  v23.i32[0] = 1.0;
  LODWORD(v25) = vbslq_s8((int8x16_t)v22, (int8x16_t)v23, v24).u32[0];
  if (*(float *)v24.i32 == 0.0)
    v25 = 0.0;
  v26 = v25;
  v27 = powf(fabsf(*(float *)v24.i32) * v63, v62);
  v28 = vmlaq_f32(vmulq_f32(v65, (float32x4_t)vdupq_n_s32(0x3F266666u)), (float32x4_t)vdupq_n_s32(0x3EB33333u), vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_1924950B0, v61, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_1924950A0, *(float32x2_t *)v61.f32, 1), vmulq_n_f32((float32x4_t)xmmword_192495090, (float)(v26 * v27) + (float)(v26 * v27)))));
  v29 = v7 + 0.1;
  v30 = sqrtf(v68) / v29;
  if (v30 <= 1.0)
    v31 = v30;
  else
    v31 = 1.0;
  if (v30 >= 0.0)
    v32 = v31;
  else
    v32 = 0.0;
  v33 = sqrtf((float)(v32 * v32) * (float)((float)(v32 * -2.0) + 3.0));
  v66 = vmlaq_n_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - v33), v28, v33), 1.0 - v68), a1, v68);
  v34.i32[1] = a2.i32[1];
  v35 = (simd_float4)vmulq_laneq_f32(v64, (float32x4_t)a2, 3);
  *(float *)v34.i32 = 2.0 - *(float *)&a2.i32[1];
  v35.i32[3] = 0;
  v36 = (simd_float4)vdupq_lane_s32(v34, 0);
  v36.i32[3] = 0;
  v37 = vmulq_f32(v69, (float32x4_t)_simd_pow_f4(v35, v36));
  v38 = vmulq_f32(v37, (float32x4_t)xmmword_1924921A0);
  v39 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0];
  v40 = v39 * -2.6 + v39 * -2.6 * v39 + 0.98;
  v41 = v39 * -6.25 + v39 * -6.25 * v39 + 0.5965;
  v42 = fmaxf(fmaxf(v40, v41), 1.0);
  v43 = *(float *)&a2.i32[1] + 0.3;
  v44.i32[1] = 1071225241;
  v45 = (1.0 - fminf(v43, 1.0)) * 0.4 + 1.0;
  *(float *)v44.i32 = (float)(1.0 - v45) * 0.25;
  v46 = (1.0 - *(float *)&a2.i32[1]) * fminf(v42, v67 * 30.0);
  v47 = vmlaq_n_f32(vmulq_n_f32(v37, 1.0 - v46), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v44, 0), v37, v45), v46);
  v48 = (float)(v68 + -0.2) / 0.6;
  if (v48 <= 1.0)
    v49 = (float)(v68 + -0.2) / 0.6;
  else
    v49 = 1.0;
  if (v48 >= 0.0)
    v50 = v49;
  else
    v50 = 0.0;
  v51 = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - v67), vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - (float)((float)(v50 * v50) * (float)((float)(v50 * -2.0) + 3.0))), v47, (float)(v50 * v50) * (float)((float)(v50 * -2.0) + 3.0)), v67);
  v52 = fminf(v68, 1.0);
  v53 = vmlaq_n_f32(vmulq_n_f32(v66, 1.0 - v52), v51, v52);
  result = vmulq_f32(v53, (float32x4_t)xmmword_1924921A0);
  *(double *)result.i64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)result, 2), vaddq_f32(result, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)result.f32, 1))).f32[0];
  v54 = *(double *)result.i64 * -2.6 + *(double *)result.i64 * -2.6 * *(double *)result.i64 + 0.98;
  result.f32[0] = *(double *)result.i64 * -6.25 + *(double *)result.i64 * -6.25 * *(double *)result.i64 + 0.5965;
  result.f32[0] = fmaxf(fmaxf(v54, result.f32[0]), 1.0);
  v55 = 1.0 - *(float *)&a2.i32[2];
  v56 = v55 * (fabsf(v7) * 0.1);
  v57 = v56 + 1.0;
  *(float *)&v55 = (float)(1.0 - v57) * 0.5;
  v58 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v55, 0), v53, v57);
  v59 = fminf(result.f32[0], v67 * 30.0);
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(v53, 1.0 - v59), v58, v59).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

float32x4_t cikernel::_highlightsAndShadows0(int32x4_t a1, float32x4_t a2, int32x4_t a3)
{
  float32x4_t v3;
  float32x4_t v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float32x4_t v12;
  float32x4_t v13;
  float v14;
  float v15;
  float v16;
  int32x2_t v17;
  simd_float4 v18;
  simd_float4 v19;
  simd_float4 v20;
  simd_float4 v26;
  float32x4_t v27;
  float32x4_t v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  int32x2_t v35;
  simd_float4 v36;
  simd_float4 v37;
  float32x4_t v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float32x4_t v43;
  float v44;
  int32x2_t v45;
  float v46;
  float32x4_t v47;
  float v48;
  float v49;
  float32x4_t result;
  float v51;
  float32x4_t v52;
  float32x4_t v53;
  int32x2_t v54;
  float32x4_t v55;
  float32x4_t v57;

  v3 = (float32x4_t)a1;
  v3.i32[3] = 0;
  v53 = v3;
  v4 = vmulq_f32(vmaxnmq_f32(v3, (float32x4_t)0), (float32x4_t)xmmword_192495040);
  v5 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0];
  v6 = fmaxf(vaddq_f32((float32x4_t)vdupq_laneq_s32(a1, 2), vaddq_f32((float32x4_t)a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.i8, 1))).f32[0], 0.001);
  v7 = v5 / v6;
  if ((float)(v5 / v6) <= 1.0)
    v8 = v5 / v6;
  else
    v8 = 1.0;
  if (v7 >= 0.0)
    v9 = v8;
  else
    v9 = 0.0;
  v10 = powf(v9, fmaxf(1.0 - *(float *)a3.i32, 0.0));
  v11 = v10 * *(float *)a3.i32;
  v12 = vmaxnmq_f32(v53, (float32x4_t)xmmword_192491FC0);
  v12.i32[3] = 0;
  v13 = vminnmq_f32(v12, (float32x4_t)xmmword_19248E2D0);
  v14 = (float)(v13.f32[2] + vaddv_f32(*(float32x2_t *)v13.f32)) * 0.33333;
  v15 = 1.0 / (1.0 - v14);
  v16 = -(v13.f32[2] - v13.f32[1] * 2.0);
  v13.f32[0] = fmaxf(fminf(v13.f32[0] - v13.f32[1], v16), 0.0)
             * 4.0
             * (1.0 - fmaxf((float)(v13.f32[0] - v14) * v15, (float)(v14 - v13.f32[0]) * (float)(1.0 / v14)))
             * (float)(1.0 / v14);
  *(double *)v13.i64 = fminf(v13.f32[0], 1.0) * 0.7 + 0.15;
  v13.f32[0] = *(double *)v13.i64;
  v54 = *(int32x2_t *)v13.f32;
  *(float *)v17.i32 = -(float)(*(float *)a3.i32 * v10);
  v18 = (simd_float4)vsubq_f32((float32x4_t)vdupq_lane_s32(v17, 0), a2);
  v18.i32[3] = 0;
  v19 = _simd_pow_f4((simd_float4)xmmword_192495050, v18);
  v20 = (simd_float4)vaddq_f32((float32x4_t)vdupq_laneq_s32(a3, 2), vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)v19, 1.0 - *(float *)v54.i32), (float32x4_t)vdupq_lane_s32(v54, 0), fminf(v19.f32[0], fminf(v19.f32[1], v19.f32[2]))), 1.0 - *(float *)&a3.i32[2]));
  v19.i64[0] = 0x8000000080000000;
  v19.i64[1] = 0x8000000080000000;
  __asm { FMOV            V2.4S, #1.0 }
  v52 = vabsq_f32((float32x4_t)a1);
  v55 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32((float32x4_t)a1), (int8x16_t)vcgtzq_f32((float32x4_t)a1)), vorrq_s8(vandq_s8((int8x16_t)a1, (int8x16_t)v19), _Q2), (int8x16_t)0);
  v19.i64[0] = 0x3F0000003F000000;
  v19.i64[1] = 0x3F0000003F000000;
  v26 = (simd_float4)vmulq_f32(v52, (float32x4_t)v19);
  v26.i32[3] = 0;
  v20.i32[3] = 0;
  v27 = vmulq_f32(v55, (float32x4_t)_simd_pow_f4(v26, v20));
  v28 = vaddq_f32(v27, v27);
  v51 = sqrtf(fmaxf(fmaxf(fmaxf(a2.f32[0], a2.f32[1]), a2.f32[2]), 0.0));
  v29 = v11 * 0.5 * v11 + 0.1;
  v30 = v51 / v29;
  if (v30 <= 1.0)
    v31 = v30;
  else
    v31 = 1.0;
  if (v30 >= 0.0)
    v32 = v31;
  else
    v32 = 0.0;
  v33 = sqrtf((float)(v32 * v32) * (float)((float)(v32 * -2.0) + 3.0));
  v34 = (1.0 - v33) * v33;
  v57 = vmlaq_n_f32(vmulq_n_f32(v28, 1.0 - v34), (float32x4_t)a1, v34);
  v35.i32[1] = a3.i32[1];
  v36 = (simd_float4)vmulq_laneq_f32(v52, (float32x4_t)a3, 3);
  *(float *)v35.i32 = 2.0 - *(float *)&a3.i32[1];
  v36.i32[3] = 0;
  v37 = (simd_float4)vdupq_lane_s32(v35, 0);
  v37.i32[3] = 0;
  v38 = vmulq_f32(v55, (float32x4_t)_simd_pow_f4(v36, v37));
  v39 = (float)(v51 + -0.2) / 0.6;
  if (v39 <= 1.0)
    v40 = (float)(v51 + -0.2) / 0.6;
  else
    v40 = 1.0;
  if (v39 >= 0.0)
    v41 = v40;
  else
    v41 = 0.0;
  v42 = 1.0 - (float)((float)(v41 * v41) * (float)((float)(v41 * -2.0) + 3.0));
  v43 = vmlaq_n_f32(vmulq_n_f32(v57, 1.0 - v51), vmlaq_n_f32(vmulq_n_f32(v38, 1.0 - v42), (float32x4_t)a1, v42), v51);
  result = vmulq_f32(v43, (float32x4_t)xmmword_1924921A0);
  *(double *)result.i64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)result, 2), vaddq_f32(result, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)result.f32, 1))).f32[0];
  v44 = *(double *)result.i64 * -2.6 + *(double *)result.i64 * -2.6 * *(double *)result.i64 + 0.98;
  result.f32[0] = *(double *)result.i64 * -6.25 + *(double *)result.i64 * -6.25 * *(double *)result.i64 + 0.5965;
  result.f32[0] = fmaxf(fmaxf(v44, result.f32[0]), 1.0);
  v45.i32[1] = 1068079513;
  v46 = fabsf(v11) * 0.05 + 1.0;
  *(float *)v45.i32 = (float)(1.0 - v46) * 0.5;
  v47 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v45, 0), v43, v46);
  v48 = v51 * 30.0 * v51;
  v49 = fminf(result.f32[0], v48);
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(v43, 1.0 - v49), v47, v49).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

float32x4_t cikernel::_highlightsAndShadows_noblur0(float32x4_t a1, int32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float32x4_t v11;
  float32x4_t v12;
  float v13;
  float v14;
  float v15;
  int32x2_t v16;
  simd_float4 v17;
  simd_float4 v18;
  simd_float4 v19;
  simd_float4 v25;
  float32x4_t v26;
  float32x4_t v27;
  float v28;
  float v29;
  float v30;
  float v31;
  double v32;
  simd_float4 v33;
  simd_float4 v34;
  float32x4_t v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float32x4_t v40;
  float v41;
  int32x2_t v42;
  float v43;
  float32x4_t v44;
  float v45;
  float v46;
  float32x4_t result;
  float v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  int32x2_t v52;
  float32x4_t v53;

  v2 = a1;
  v2.i32[3] = 0;
  v51 = v2;
  v3 = vmulq_f32(vmaxnmq_f32(v2, (float32x4_t)0), (float32x4_t)xmmword_192495040);
  v4 = a1.f32[1];
  v5 = a1.f32[2];
  v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0]/ fmaxf(a1.f32[2] + vaddv_f32(*(float32x2_t *)a1.f32), 0.001);
  if (v6 <= 1.0)
    v7 = v6;
  else
    v7 = 1.0;
  if (v6 >= 0.0)
    v8 = v7;
  else
    v8 = 0.0;
  v9 = powf(v8, fmaxf(1.0 - *(float *)a2.i32, 0.0));
  v10 = v9 * *(float *)a2.i32;
  v11 = vmaxnmq_f32(v51, (float32x4_t)xmmword_192491FC0);
  v11.i32[3] = 0;
  v12 = vminnmq_f32(v11, (float32x4_t)xmmword_19248E2D0);
  v13 = (float)(v12.f32[2] + vaddv_f32(*(float32x2_t *)v12.f32)) * 0.33333;
  v14 = 1.0 / (1.0 - v13);
  v15 = -(v12.f32[2] - v12.f32[1] * 2.0);
  v12.f32[0] = fmaxf(fminf(v12.f32[0] - v12.f32[1], v15), 0.0)
             * 4.0
             * (1.0 - fmaxf((float)(v12.f32[0] - v13) * v14, (float)(v13 - v12.f32[0]) * (float)(1.0 / v13)))
             * (float)(1.0 / v13);
  *(double *)v12.i64 = fminf(v12.f32[0], 1.0) * 0.7 + 0.15;
  v12.f32[0] = *(double *)v12.i64;
  v52 = *(int32x2_t *)v12.f32;
  *(float *)v16.i32 = -(float)(*(float *)a2.i32 * v9);
  v17 = (simd_float4)vsubq_f32((float32x4_t)vdupq_lane_s32(v16, 0), a1);
  v17.i32[3] = 0;
  v18 = _simd_pow_f4((simd_float4)xmmword_192495050, v17);
  v19 = (simd_float4)vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 2), vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)v18, 1.0 - *(float *)v52.i32), (float32x4_t)vdupq_lane_s32(v52, 0), fminf(v18.f32[0], fminf(v18.f32[1], v18.f32[2]))), 1.0 - *(float *)&a2.i32[2]));
  v18.i64[0] = 0x8000000080000000;
  v18.i64[1] = 0x8000000080000000;
  __asm { FMOV            V2.4S, #1.0 }
  v50 = vabsq_f32(a1);
  v53 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgtzq_f32(a1)), vorrq_s8(vandq_s8((int8x16_t)a1, (int8x16_t)v18), _Q2), (int8x16_t)0);
  v18.i64[0] = 0x3F0000003F000000;
  v18.i64[1] = 0x3F0000003F000000;
  v25 = (simd_float4)vmulq_f32(v50, (float32x4_t)v18);
  v25.i32[3] = 0;
  v19.i32[3] = 0;
  v26 = vmulq_f32(v53, (float32x4_t)_simd_pow_f4(v25, v19));
  v27 = vaddq_f32(v26, v26);
  v48 = sqrtf(fmaxf(fmaxf(fmaxf(a1.f32[0], v4), v5), 0.0));
  v28 = v10 * 0.5 * v10 + 0.1;
  v29 = v48 / v28;
  if (v29 <= 1.0)
    v30 = v29;
  else
    v30 = 1.0;
  if (v29 >= 0.0)
    v31 = v30;
  else
    v31 = 0.0;
  v32 = sqrtf((float)(v31 * v31) * (float)((float)(v31 * -2.0) + 3.0));
  *(float *)&v32 = (1.0 - v32) * v32;
  v49 = vmlaq_n_f32(vmulq_n_f32(v27, 1.0 - *(float *)&v32), a1, *(float *)&v32);
  HIDWORD(v32) = a2.i32[1];
  v33 = (simd_float4)vmulq_laneq_f32(v50, (float32x4_t)a2, 3);
  *(float *)&v32 = 2.0 - *(float *)&a2.i32[1];
  v33.i32[3] = 0;
  v34 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)&v32, 0);
  v34.i32[3] = 0;
  v35 = vmulq_f32(v53, (float32x4_t)_simd_pow_f4(v33, v34));
  v36 = (float)(v48 + -0.2) / 0.6;
  if (v36 <= 1.0)
    v37 = (float)(v48 + -0.2) / 0.6;
  else
    v37 = 1.0;
  if (v36 >= 0.0)
    v38 = v37;
  else
    v38 = 0.0;
  v39 = 1.0 - (float)((float)(v38 * v38) * (float)((float)(v38 * -2.0) + 3.0));
  v40 = vmlaq_n_f32(vmulq_n_f32(v49, 1.0 - v48), vmlaq_n_f32(vmulq_n_f32(v35, 1.0 - v39), a1, v39), v48);
  result = vmulq_f32(v40, (float32x4_t)xmmword_1924921A0);
  *(double *)result.i64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)result, 2), vaddq_f32(result, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)result.f32, 1))).f32[0];
  v41 = *(double *)result.i64 * -2.6 + *(double *)result.i64 * -2.6 * *(double *)result.i64 + 0.98;
  result.f32[0] = *(double *)result.i64 * -6.25 + *(double *)result.i64 * -6.25 * *(double *)result.i64 + 0.5965;
  result.f32[0] = fmaxf(fmaxf(v41, result.f32[0]), 1.0);
  v42.i32[1] = 1068079513;
  v43 = fabsf(v10) * 0.05 + 1.0;
  *(float *)v42.i32 = (float)(1.0 - v43) * 0.5;
  v44 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v42, 0), v40, v43);
  v45 = v48 * 30.0 * v48;
  v46 = fminf(result.f32[0], v45);
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(v40, 1.0 - v46), v44, v46).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

float32x4_t cikernel::_shadows_noblur(float32x4_t a1, int32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float32x4_t v11;
  float32x4_t v12;
  float v13;
  float v14;
  float v15;
  int32x2_t v16;
  simd_float4 v17;
  simd_float4 v18;
  simd_float4 v19;
  simd_float4 v25;
  float32x4_t v26;
  float32x4_t result;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float32x4_t v34;
  float32x4_t v35;
  float v36;
  int32x2_t v37;
  float v38;
  float v39;
  float32x4_t v40;
  int32x2_t v41;
  float32x4_t v43;

  v2 = a1;
  v2.i32[3] = 0;
  v40 = v2;
  v3 = vmulq_f32(vmaxnmq_f32(v2, (float32x4_t)0), (float32x4_t)xmmword_192495040);
  v4 = a1.f32[1];
  v5 = a1.f32[2];
  v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0]/ fmaxf(a1.f32[2] + vaddv_f32(*(float32x2_t *)a1.f32), 0.001);
  if (v6 <= 1.0)
    v7 = v6;
  else
    v7 = 1.0;
  if (v6 >= 0.0)
    v8 = v7;
  else
    v8 = 0.0;
  v9 = powf(v8, fmaxf(1.0 - *(float *)a2.i32, 0.0));
  v10 = v9 * *(float *)a2.i32;
  v11 = vmaxnmq_f32(v40, (float32x4_t)xmmword_192491FC0);
  v11.i32[3] = 0;
  v12 = vminnmq_f32(v11, (float32x4_t)xmmword_19248E2D0);
  v13 = (float)(v12.f32[2] + vaddv_f32(*(float32x2_t *)v12.f32)) * 0.33333;
  v14 = 1.0 / (1.0 - v13);
  v15 = -(v12.f32[2] - v12.f32[1] * 2.0);
  v12.f32[0] = fmaxf(fminf(v12.f32[0] - v12.f32[1], v15), 0.0)
             * 4.0
             * (1.0 - fmaxf((float)(v12.f32[0] - v13) * v14, (float)(v13 - v12.f32[0]) * (float)(1.0 / v13)))
             * (float)(1.0 / v13);
  *(double *)v12.i64 = fminf(v12.f32[0], 1.0) * 0.7 + 0.15;
  v12.f32[0] = *(double *)v12.i64;
  v41 = *(int32x2_t *)v12.f32;
  *(float *)v16.i32 = -(float)(*(float *)a2.i32 * v9);
  v17 = (simd_float4)vsubq_f32((float32x4_t)vdupq_lane_s32(v16, 0), a1);
  v17.i32[3] = 0;
  v18 = _simd_pow_f4((simd_float4)xmmword_192495050, v17);
  v19 = (simd_float4)vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 2), vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)v18, 1.0 - *(float *)v41.i32), (float32x4_t)vdupq_lane_s32(v41, 0), fminf(v18.f32[0], fminf(v18.f32[1], v18.f32[2]))), 1.0 - *(float *)&a2.i32[2]));
  v18.i64[0] = 0x8000000080000000;
  v18.i64[1] = 0x8000000080000000;
  __asm { FMOV            V2.4S, #1.0 }
  v43 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgtzq_f32(a1)), vorrq_s8(vandq_s8((int8x16_t)a1, (int8x16_t)v18), (int8x16_t)_Q2), (int8x16_t)0);
  _Q2.i64[0] = 0x3F0000003F000000;
  _Q2.i64[1] = 0x3F0000003F000000;
  v25 = (simd_float4)vmulq_f32(vabsq_f32(a1), _Q2);
  v25.i32[3] = 0;
  v19.i32[3] = 0;
  result = vmulq_f32(v43, (float32x4_t)_simd_pow_f4(v25, v19));
  v26 = vaddq_f32(result, result);
  result.f32[0] = sqrtf(fmaxf(fmaxf(fmaxf(a1.f32[0], v4), v5), 0.0));
  v28 = v10 * 0.5 * v10 + 0.1;
  v29 = result.f32[0] / v28;
  if (v29 <= 1.0)
    v30 = v29;
  else
    v30 = 1.0;
  if (v29 >= 0.0)
    v31 = v30;
  else
    v31 = 0.0;
  v32 = sqrtf((float)(v31 * v31) * (float)((float)(v31 * -2.0) + 3.0));
  v33 = (1.0 - v32) * v32;
  v34 = vmlaq_n_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(v26, 1.0 - v33), a1, v33), 1.0 - result.f32[0]), a1, result.f32[0]);
  v35 = vmulq_f32(v34, (float32x4_t)xmmword_1924921A0);
  *(double *)v35.i64 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), vaddq_f32(v35, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1))).f32[0];
  v36 = *(double *)v35.i64 * -2.6 + *(double *)v35.i64 * -2.6 * *(double *)v35.i64 + 0.98;
  v35.f32[0] = *(double *)v35.i64 * -6.25 + *(double *)v35.i64 * -6.25 * *(double *)v35.i64 + 0.5965;
  v35.f32[0] = fmaxf(fmaxf(v36, v35.f32[0]), 1.0);
  v37.i32[1] = 1068079513;
  v38 = fabsf(v10) * 0.05 + 1.0;
  *(float *)v37.i32 = (float)(1.0 - v38) * 0.5;
  v39 = result.f32[0] * 30.0 * result.f32[0];
  v35.f32[0] = fminf(v35.f32[0], v39);
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(v34, 1.0 - v35.f32[0]), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(v37, 0), v34, v38), v35.f32[0]).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

double cikernel::_histogram_display(uint64_t a1, float a2, double a3)
{
  double v4;
  int8x16_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  float64x2_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float32x4_t v25;
  int8x16_t v26;
  float32x4_t v27;
  float64x2_t v28;
  int8x16_t v29;
  float64x2_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  double result;
  int32x2_t v35;

  v35 = *(int32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v4 = floorf(*(float *)v35.i32) + 0.5;
  v5.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)&v6 = *(float *)(a1 + 24)
                + (float)((float)(*(float *)(a1 + 20) * 0.5) + (float)(*(float *)&v4 * *(float *)(a1 + 16)));
  LODWORD(v7) = *(_DWORD *)(a1 + 32);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.f64 = *(float *)v8.i32
                   + (float)((float)(*(float *)&v7 * 0.5) + (float)(*(float *)&v4 * *(float *)v5.i32));
  *((float *)&v6 + 1) = *(float *)v9.f64;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v6, v9, v4, v7, v5, v8, v10, v11);
  __asm { FMOV            V1.4S, #1.0 }
  v18 = (float32x4_t)vbicq_s8((int8x16_t)_Q1, (int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(v35, 1), vmulq_n_f32(v12, a2)));
  *(double *)_Q1.i64 = v18.f32[1] + v18.f32[1] + v18.f32[0] * 4.0;
  *(double *)v18.i64 = *(double *)_Q1.i64 + v18.f32[2];
  v18.f32[0] = *(double *)v18.i64;
  _Q1.i32[0] = 4.0;
  v19 = (float32x4_t)xmmword_1924951A0;
  v19.i32[0] = 6.0;
  v20.i32[0] = 2.0;
  v21 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(v18, v19), 0), (int8x16_t)xmmword_1924951C0, vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(v18, _Q1), 0), (int8x16_t)xmmword_1924951B0, (int8x16_t)xmmword_1924951A0));
  v22 = (float32x4_t)xmmword_1924951D0;
  v22.i32[0] = 3.0;
  v23 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(v18, v22), 0);
  v24 = vbslq_s8((int8x16_t)v23, (int8x16_t)xmmword_1924951E0, vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(v18, v20), 0), (int8x16_t)xmmword_1924951D0, v21));
  v23.i32[0] = 1.0;
  v25 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(v18, v23), 0);
  v26 = vbslq_s8((int8x16_t)v25, (int8x16_t)xmmword_1924951F0, v24);
  v25.i32[0] = 5.0;
  v27 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(v18, v25), 0);
  v28.f64[1] = 0.00781250183;
  v29 = vbslq_s8((int8x16_t)v27, (int8x16_t)xmmword_192495200, v26);
  v27.i32[0] = 7.0;
  v30 = (float64x2_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(v18, v27), 0);
  v27.i64[1] = 0x3F8000003E99999ALL;
  v31 = (float32x4_t)vbslq_s8((int8x16_t)v30, (int8x16_t)xmmword_192495210, v29);
  v30.f64[0] = *(float *)v35.i32;
  *(double *)v27.i64 = *(float *)&a3 + 0.5;
  v32 = (float32x4_t)vdupq_n_s32(0x3ECCCCCDu);
  v33 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s64(vcgtq_f64((float64x2_t)v27, v30).i64[0], 0), (int8x16_t)vmulq_f32(v31, v32), (int8x16_t)v31);
  v28.f64[0] = *((float *)&a3 + 1) + 0.5;
  *(_QWORD *)&result = vbslq_s8((int8x16_t)vdupq_lane_s64(vmvnq_s8((int8x16_t)vcgeq_f64(v30, v28)).i64[0], 0), (int8x16_t)v33, (int8x16_t)vaddq_f32(vmulq_f32(v33, (float32x4_t)vdupq_n_s32(0x3F19999Au)), v32)).u64[0];
  return result;
}

void CI::f4_sr_f_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, float, double);
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  double *v17;
  __int128 v18;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, float, double))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_QWORD *)(v11 + 32);
  v15 = *(_DWORD *)(v11 + 64);
  v16 = *(_QWORD *)(v11 + 56);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 80)), a2);
  v17 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v17 = (double *)((char *)a2 + 64 * v16);
  *(double *)&v18 = v12(a4 + 80 * v13, *((float *)a2 + 16 * v14), *v17);
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double unionPointWithRect(double a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  CGFloat v5;
  double result;
  CGRect v7;
  CGRect v8;

  v5 = *(float *)&a1;
  v8.origin.y = *((float *)&a1 + 1);
  v8.size.width = 0.0;
  v8.size.height = 0.0;
  v7.origin.x = a2;
  v7.origin.y = a3;
  v7.size.width = a4;
  v7.size.height = a5;
  v8.origin.x = v5;
  *(_QWORD *)&result = (unint64_t)CGRectUnion(v7, v8);
  return result;
}

float32x2_t cikernel::_holeDistortion(CI *a1, float32x2_t a2, float a3)
{
  float32x2_t *DC;
  float32x2_t v5;
  int32x2_t v6;

  DC = (float32x2_t *)CI::getDC(a1);
  v5 = vsub_f32(*DC, a2);
  v6 = (int32x2_t)vmul_f32(v5, v5);
  if (vaddv_f32((float32x2_t)v6) > a3)
    return vsub_f32(*(float32x2_t *)CI::getDC((CI *)DC), vdiv_f32(vmul_n_f32(v5, a3), (float32x2_t)vdup_lane_s32((int32x2_t)vadd_f32((float32x2_t)v6, (float32x2_t)vdup_lane_s32(v6, 1)), 0)));
  return a2;
}

double cikernel::_holeAntialias(CI *a1, float32x4_t a2, float32x2_t a3, float a4)
{
  float32x2_t v5;
  float v6;
  float v7;
  BOOL v8;
  float v9;
  double result;

  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a3);
  v6 = sqrtf(vaddv_f32(vmul_f32(v5, v5))) - a4;
  v7 = 1.0;
  if (v6 <= 1.0)
    v7 = v6;
  v8 = v6 < 0.0;
  v9 = 0.0;
  if (!v8)
    v9 = v7;
  *(_QWORD *)&result = vmulq_n_f32(a2, v9).u64[0];
  return result;
}

void CI::f4_s_f2_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, double, float);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  double *v17;
  __n128 *v18;
  __int128 v19;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, double, float))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v17 = (double *)(a3 + 16 * v15);
  if (v14 != 5)
    v17 = (double *)((char *)a2 + 64 * v15);
  v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v19 = v11(a1, *v18, *v17, *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

void sub_1922D8750(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1922D87E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1922D8880(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1922D8918(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1922D89B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1922D8A48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1922D8AE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1922D8B78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1922D8C10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1922D8CA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float OptionHeadroom(NSDictionary *a1)
{
  float result;
  NSObject *v3;

  if (!-[NSDictionary objectForKey:](a1, "objectForKey:", CFSTR("kCIImageContentHeadroom")))
    return 0.0;
  objc_msgSend(-[NSDictionary objectForKey:](a1, "objectForKey:", CFSTR("kCIImageContentHeadroom")), "floatValue");
  if (result < 1.0 && result != 0.0)
  {
    v3 = ci_logger_api();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      OptionHeadroom();
    return 0.0;
  }
  return result;
}

CI::ColorMatchImage *CI::ColorMatchImage::append_and_unref(CI::ColorMatchImage *this, CI::Image *a2, CGColorSpace *a3)
{
  char v3;
  CI::ColorMatchImage *v6;

  v3 = (char)a3;
  v6 = (CI::ColorMatchImage *)operator new();
  CI::ColorMatchImage::ColorMatchImage(v6, this, a2, v3);
  CI::Object::unref(this);
  return v6;
}

void sub_1922D8F38(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40D5412EDCLL);
  _Unwind_Resume(a1);
}

CI::AffineImage *CI::AffineImage::append_and_unref(CI::AffineImage *this, CI::Image *a2, CGAffineTransform *a3)
{
  int v3;
  CI::AffineImage *v6;
  __int128 v7;
  _OWORD v9[3];

  v3 = (int)a3;
  v6 = (CI::AffineImage *)operator new();
  v7 = *((_OWORD *)a2 + 1);
  v9[0] = *(_OWORD *)a2;
  v9[1] = v7;
  v9[2] = *((_OWORD *)a2 + 2);
  CI::AffineImage::AffineImage(v6, this, (const CI::Affine *)v9, v3);
  CI::Object::unref(this);
  return v6;
}

void sub_1922D8FD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C402ADBAFB5);
  _Unwind_Resume(a1);
}

BOOL orientationTransform@<W0>(CGRect a1@<0:D0, 8:D1, 16:D2, 24:D3>, int a2@<W0>, _OWORD *a3@<X8>)
{
  CGFloat height;
  CGFloat width;
  _BOOL8 result;
  uint64_t v8;
  __int128 v9;
  int v10;
  _OWORD *v11;
  __int128 v12;
  _QWORD v13[11];
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  CGFloat v18;
  CGFloat v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  CGFloat v24;
  __int128 v25;
  __int128 v26;
  CGFloat v27;
  CGFloat v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  CGFloat v33;
  __int128 v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  __int128 v39;
  CGFloat v40;
  uint64_t v41;
  uint64_t v42;

  height = a1.size.height;
  width = a1.size.width;
  v42 = *MEMORY[0x1E0C80C00];
  result = CGRectIsInfinite(a1);
  if (result)
  {
    v8 = MEMORY[0x1E0C9BAA8];
    v9 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
    *a3 = *MEMORY[0x1E0C9BAA8];
    a3[1] = v9;
    a3[2] = *(_OWORD *)(v8 + 32);
  }
  else
  {
    v13[0] = 0x3FF0000000000000;
    v13[1] = 0;
    v13[2] = 0;
    v13[3] = 0x3FF0000000000000;
    v13[4] = 0;
    v13[5] = 0;
    v13[6] = 0xBFF0000000000000;
    v13[7] = 0;
    v13[8] = 0;
    v13[9] = 0x3FF0000000000000;
    *(CGFloat *)&v13[10] = width;
    v14 = xmmword_1924948E0;
    v15 = 0;
    v16 = 0;
    v17 = 0xBFF0000000000000;
    v18 = width;
    v19 = height;
    v21 = 0;
    v22 = 0;
    v20 = 0x3FF0000000000000;
    v23 = xmmword_192493540;
    v24 = height;
    v25 = xmmword_1924948E0;
    v26 = xmmword_192493540;
    v27 = height;
    v28 = width;
    v29 = xmmword_1924948E0;
    v31 = 0;
    v32 = 0;
    v30 = 0x3FF0000000000000;
    v33 = width;
    v34 = xmmword_1924948F0;
    v36 = 0u;
    v37 = 0u;
    v35 = 0x3FF0000000000000;
    v38 = 0x3FF0000000000000;
    v39 = xmmword_192493540;
    v40 = height;
    v41 = 0;
    if ((a2 - 9) >= 0xFFFFFFF8)
      v10 = a2 - 1;
    else
      v10 = 0;
    v11 = &v13[6 * v10];
    v12 = v11[2];
    a3[1] = v11[1];
    a3[2] = v12;
    *a3 = *v11;
  }
  return result;
}

void sub_1922D96F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C402EC69A6DLL);
  _Unwind_Resume(a1);
}

void SetSurfaceDeallocBlock(void *a1, uint64_t a2)
{
  BlockDeallocator *v3;

  if (a1)
  {
    v3 = -[BlockDeallocator initWithBlock:]([BlockDeallocator alloc], "initWithBlock:", a2);
    objc_setAssociatedObject(a1, SetSurfaceDeallocBlock, v3, (void *)1);

  }
}

const __CFDictionary *imageSourceCopyAuxiliaryDataInfo(CGImageSource *a1, size_t a2, const __CFString *a3)
{
  const __CFDictionary *v3;
  const __CFDictionary *v4;

  if (!a3)
    return 0;
  v3 = CGImageSourceCopyAuxiliaryDataInfoAtIndex(a1, a2, a3);
  v4 = v3;
  if (v3 && !CFDictionaryGetCount(v3))
  {
    CFRelease(v4);
    return 0;
  }
  return v4;
}

void SetSurfaceBackingObject(__IOSurface *a1, id value)
{
  if (a1)
    objc_setAssociatedObject(a1, SetSurfaceBackingObject, value, (void *)1);
}

void sub_1922DC5D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E3C40651AB672);
  _Unwind_Resume(a1);
}

uint64_t CI::SampleModeImage::append_and_unref(uint64_t *a1, int a2)
{
  uint64_t v4;

  v4 = operator new();
  CI::SampleModeImage::SampleModeImage(v4, a1, a2);
  CI::Object::unref((CI::Object *)a1);
  return v4;
}

void sub_1922DC654(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

void sub_1922DCD08(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E3C40651AB672);
  _Unwind_Resume(a1);
}

void sub_1922DD6DC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)(v3 - 176) = v1;
  std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100]((void ***)(v3 - 176));
  MEMORY[0x194025AAC](v2, 0x10E1C40DB69F48ELL);
  _Unwind_Resume(a1);
}

void sub_1922DDF68(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40DBE5A1EELL);
  _Unwind_Resume(a1);
}

void sub_1922DE028(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40DBE5A1EELL);
  _Unwind_Resume(a1);
}

void sub_1922DE0A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CIImage *_noiseImage(char a1)
{
  void *v2;
  _BYTE *v3;
  unsigned int v4;
  char v5;
  char v6;
  char v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD v13[3];
  _QWORD v14[3];
  _QWORD v15[4];
  _QWORD v16[5];

  v16[4] = *MEMORY[0x1E0C80C00];
  v2 = (void *)objc_msgSend(MEMORY[0x1E0C99DF0], "dataWithLength:", 0x40000);
  v3 = (_BYTE *)objc_msgSend(v2, "mutableBytes");
  srandom(0x2Au);
  v4 = -4;
  do
  {
    v5 = random();
    v6 = random();
    v7 = random();
    *v3 = random();
    v3[1] = v7;
    v3[2] = v6;
    v3[3] = v5;
    v3 += 4;
    v4 += 4;
  }
  while (v4 < 0x3FFFC);
  if ((a1 & 1) != 0)
  {
    v15[0] = CFSTR("CIImageColorSpace");
    v16[0] = objc_msgSend(MEMORY[0x1E0C99E38], "null");
    v16[1] = MEMORY[0x1E0C9AAB0];
    v15[1] = CFSTR("CIImageClampToEdge");
    v15[2] = CFSTR("CIImageNearestSampling");
    v15[3] = CFSTR("kCIImageCacheHint");
    v16[2] = MEMORY[0x1E0C9AAB0];
    v16[3] = MEMORY[0x1E0C9AAB0];
    v8 = (void *)MEMORY[0x1E0C99D80];
    v9 = v16;
    v10 = v15;
    v11 = 4;
  }
  else
  {
    v13[0] = CFSTR("CIImageColorSpace");
    v14[0] = objc_msgSend(MEMORY[0x1E0C99E38], "null");
    v14[1] = MEMORY[0x1E0C9AAB0];
    v13[1] = CFSTR("CIImageClampToEdge");
    v13[2] = CFSTR("kCIImageCacheHint");
    v14[2] = MEMORY[0x1E0C9AAB0];
    v8 = (void *)MEMORY[0x1E0C99D80];
    v9 = v14;
    v10 = v13;
    v11 = 3;
  }
  return -[CIImage initWithBitmapData:bytesPerRow:size:format:options:]([CIImage alloc], "initWithBitmapData:bytesPerRow:size:format:options:", v2, 1024, 266, objc_msgSend(v8, "dictionaryWithObjects:forKeys:count:", v9, v10, v11), 256.0, 256.0);
}

void sub_1922DE2CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1922DE4F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id hdrRawImage(CIRAWFilter *a1, NSDictionary *a2, double a3)
{
  id result;
  void *v5;
  CGColorSpace *v6;
  uint64_t v7;

  LODWORD(a3) = 1.0;
  -[CIRAWFilter setExtendedDynamicRangeAmount:](a1, "setExtendedDynamicRangeAmount:", a3);
  result = -[CIRAWFilter outputImage](a1, "outputImage");
  if (result)
  {
    v5 = result;
    v6 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D9C8]);
    v7 = objc_msgSend(v5, "imageByTaggingWithColorSpace:", v6);
    CGColorSpaceRelease(v6);
    return (id)v7;
  }
  return result;
}

void sub_1922DEC5C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C402ADBAFB5);
  _Unwind_Resume(a1);
}

void sub_1922DEE18(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C407DA4F8A2);
  _Unwind_Resume(a1);
}

void sub_1922DF01C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

void sub_1922DF148(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

void sub_1922DF1D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C400067BF2CLL);
  _Unwind_Resume(a1);
}

void sub_1922DF28C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

void sub_1922DF380(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40824C6A2FLL);
  _Unwind_Resume(a1);
}

void sub_1922DF634(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40D5412EDCLL);
  _Unwind_Resume(a1);
}

void sub_1922DF794(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40D5412EDCLL);
  _Unwind_Resume(a1);
}

void sub_1922DF910(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40D5412EDCLL);
  _Unwind_Resume(a1);
}

void sub_1922DFA50(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40D5412EDCLL);
  _Unwind_Resume(a1);
}

void sub_1922DFB4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40D5412EDCLL);
  _Unwind_Resume(a1);
}

void sub_1922DFC24(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C401239EDCBLL);
  _Unwind_Resume(a1);
}

void sub_1922DFDD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40112EC1AALL);
  _Unwind_Resume(a1);
}

CIImage *implRenderToIntermediate(CIImage *a1, Trilean a2, int a3)
{
  CI::Image *v7;
  CI::NoopImage *v8;
  Trilean v9;
  CIImage *v10;
  CGRect v11;

  -[CIImage extent](a1, "extent");
  if (CGRectIsEmpty(v11))
    return +[CIImage emptyImage](CIImage, "emptyImage");
  v7 = -[CIImage _internalRepresentation](a1, "_internalRepresentation");
  v8 = (CI::NoopImage *)operator new();
  v9.var0 = a2.var0;
  CI::NoopImage::NoopImage(v8, v7, v9, a3);
  v10 = +[CIImage imageWithInternalRepresentation:](CIImage, "imageWithInternalRepresentation:", v8);
  CI::Object::unref(v8);
  return v10;
}

void sub_1922DFEB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C4076E08ABBLL);
  _Unwind_Resume(a1);
}

void sub_1922E0098(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C4074FE08B2);
  _Unwind_Resume(a1);
}

void sub_1922E0198(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C4074FE08B2);
  _Unwind_Resume(a1);
}

void sub_1922E024C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

void sub_1922E0300(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

void sub_1922E07B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C409BFD4FA3);
  _Unwind_Resume(a1);
}

uint64_t CI::Image::print_graph(CI::Image *this, __sFILE *a2)
{
  uint64_t v4;
  _OWORD v6[2];
  int v7;
  _QWORD v8[9];
  int v9;
  _QWORD v10[6];
  uint64_t v11;
  float *v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t, uint64_t);
  uint64_t (*v15)(uint64_t);
  _BYTE v16[32];
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t (*v22)(uint64_t, uint64_t);
  uint64_t (*v23)(uint64_t);
  _BYTE v24[32];
  uint64_t v25;
  int v26;
  _QWORD v27[5];
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *(*v31)(uint64_t, uint64_t);
  uint64_t (*v32)();
  const char *v33;
  _QWORD v34[131];

  v34[128] = *MEMORY[0x1E0C80C00];
  memset(v6, 0, sizeof(v6));
  v7 = 1065353216;
  if (CI::print_graph_recursive<CI::Image,CI::ImageIndex,CI::Image::ImageStats>(__sFILE *,CI::Image const*,int,std::unordered_map<CI::ImageIndex,CI::Image::ImageStats> const&)::onceToken != -1)
  {
    dispatch_once(&CI::print_graph_recursive<CI::Image,CI::ImageIndex,CI::Image::ImageStats>(__sFILE *,CI::Image const*,int,std::unordered_map<CI::ImageIndex,CI::Image::ImageStats> const&)::onceToken, &__block_literal_global_742);
    if (this)
      goto LABEL_3;
LABEL_5:
    fprintf(a2, "%.*sNULL\n", 2, CI::print_graph_recursive<CI::Image,CI::ImageIndex,CI::Image::ImageStats>(__sFILE *,CI::Image const*,int,std::unordered_map<CI::ImageIndex,CI::Image::ImageStats> const&)::indent_str);
    return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)v6);
  }
  if (!this)
    goto LABEL_5;
LABEL_3:
  v19 = 0;
  v20 = &v19;
  v21 = 0x5812000000;
  v22 = __Block_byref_object_copy__9;
  v23 = __Block_byref_object_dispose__9;
  memset(v24, 0, sizeof(v24));
  v25 = 0;
  v26 = 1065353216;
  v11 = 0;
  v12 = (float *)&v11;
  v13 = 0x5812000000;
  v14 = __Block_byref_object_copy__744;
  v15 = __Block_byref_object_dispose__745;
  memset(v16, 0, sizeof(v16));
  v17 = 0;
  v18 = 1065353216;
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>((uint64_t)&v24[8], 0x80uLL);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>((uint64_t)(v12 + 12), vcvtps_u32_f32(128.0 / v12[20]));
  v4 = MEMORY[0x1E0C809B0];
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___ZN2CIL21print_graph_recursiveINS_5ImageENS_10ImageIndexENS1_10ImageStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke_746;
  v10[3] = &unk_1E2EC4370;
  v10[4] = &v19;
  v10[5] = &v11;
  v28 = MEMORY[0x1E0C809B0];
  v29 = 3221225472;
  v30 = (uint64_t)___ZNK2CI5Image27traverse_preorder_stoppableEU13block_pointerFbPKS0_S2_iiE_block_invoke;
  v31 = (void *(*)(uint64_t, uint64_t))&unk_1E2EC43C0;
  v32 = (uint64_t (*)())v10;
  CI::GraphObject::traverse_preorder_stoppable((uint64_t)this, 0, 0, 0, (uint64_t)&v28);
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::clear(v20 + 6);
  v28 = 0;
  v29 = (uint64_t)&v28;
  v30 = 0x43012000000;
  v31 = __Block_byref_object_copy__748;
  v32 = __Block_byref_object_dispose__749;
  v33 = "";
  bzero(v34, 0x400uLL);
  v8[0] = v4;
  v8[1] = 3221225472;
  v8[2] = ___ZN2CIL21print_graph_recursiveINS_5ImageENS_10ImageIndexENS1_10ImageStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke_751;
  v8[3] = &unk_1E2EC4398;
  v9 = 1;
  v8[4] = &v28;
  v8[5] = &v19;
  v8[6] = &v11;
  v8[7] = a2;
  v8[8] = v6;
  v27[0] = v4;
  v27[1] = 3221225472;
  v27[2] = ___ZNK2CI5Image27traverse_preorder_stoppableEU13block_pointerFbPKS0_S2_iiE_block_invoke;
  v27[3] = &unk_1E2EC43C0;
  v27[4] = v8;
  CI::GraphObject::traverse_preorder_stoppable((uint64_t)this, 0, 0, 0, (uint64_t)v27);
  _Block_object_dispose(&v28, 8);
  _Block_object_dispose(&v11, 8);
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)&v16[8]);
  _Block_object_dispose(&v19, 8);
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)&v24[8]);
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)v6);
}

void sub_1922E0CD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60)
{
  uint64_t v60;
  uint64_t v61;

  _Block_object_dispose(&a60, 8);
  _Block_object_dispose(&a33, 8);
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(v61);
  _Block_object_dispose(&a44, 8);
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(v60);
  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1922E2954(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1922E2A30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t dictionaryDeepCopy(void *a1, uint64_t a2)
{
  id v4;
  id v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  _BYTE v22[128];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!objc_msgSend(a1, "count"))
    return MEMORY[0x1E0C9AA70];
  v4 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v5 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v6 = (void *)objc_msgSend(a1, "allKeys", 0);
  v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
  if (!v7)
    goto LABEL_16;
  v8 = v7;
  v9 = *(_QWORD *)v19;
  do
  {
    for (i = 0; i != v8; ++i)
    {
      if (*(_QWORD *)v19 != v9)
        objc_enumerationMutation(v6);
      v11 = *(_QWORD *)(*((_QWORD *)&v18 + 1) + 8 * i);
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a2 + 16))(a2, v11))
      {
        objc_msgSend(v4, "addObject:", v11);
        v12 = (void *)objc_msgSend(a1, "valueForKey:", v11);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v13 = dictionaryDeepCopy(v12, a2);
          v14 = v5;
        }
        else
        {
          if ((objc_opt_respondsToSelector() & 1) != 0)
          {
            v15 = (void *)objc_msgSend(v12, "copy");
            objc_msgSend(v5, "addObject:", v15);

            continue;
          }
          v14 = v5;
          v13 = (uint64_t)v12;
        }
        objc_msgSend(v14, "addObject:", v13);
      }
    }
    v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
  }
  while (v8);
LABEL_16:
  v16 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:", v5, v4);

  return v16;
}

uint64_t ___ZL35dictionaryDeepCopyExceptOrientationP12NSDictionary_block_invoke(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "isEqual:", CFSTR("Orientation")) ^ 1;
}

uint64_t ___ZL18dictionaryDeepCopyP12NSDictionary_block_invoke()
{
  return 1;
}

CFTypeRef copyMetadataValue(const CGImageMetadata *a1, CFStringRef path)
{
  CGImageMetadataTag *v2;
  CGImageMetadataTag *v3;
  CFTypeRef v4;
  CFTypeID TypeID;

  v2 = CGImageMetadataCopyTagWithPath(a1, 0, path);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = CGImageMetadataTagCopyValue(v2);
  CFRelease(v3);
  if (v4)
  {
    TypeID = CFStringGetTypeID();
    if (TypeID == CFGetTypeID(v4))
    {
      CFAutorelease(v4);
      return v4;
    }
    CFRelease(v4);
    return 0;
  }
  return v4;
}

float32x4_t cikernel::_flexMap(float32x4_t a1, float32x4_t a2, simd_float4 a3, float32x4_t a4, float32x4_t a5, float a6, float32x4_t a7, float32x4_t a8)
{
  float32x4_t v8;
  simd_float4 v9;
  int8x16_t v10;
  simd_float4 v16;
  float32x4_t result;
  float32x4_t v18;

  v18 = vsubq_f32(a5, a4);
  v8 = vabsq_f32(a2);
  v8.i32[3] = 0;
  v9 = (simd_float4)vmaxnmq_f32(v8, (float32x4_t)xmmword_1924952C0);
  v10.i64[0] = 0x8000000080000000;
  v10.i64[1] = 0x8000000080000000;
  __asm { FMOV            V4.4S, #1.0 }
  v9.i32[3] = 0;
  a3.i32[3] = 0;
  v16 = (simd_float4)vmulq_n_f32(vaddq_f32(a4, vmulq_f32(v18, vmulq_f32((float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a2), (int8x16_t)vcgtzq_f32(a2)), vorrq_s8(vandq_s8((int8x16_t)a2, v10), _Q4), (int8x16_t)0), (float32x4_t)_simd_pow_f4(v9, a3)))), a6);
  v16.i32[3] = 0;
  result = (float32x4_t)_simd_exp2_f4(v16);
  result.i64[0] = vsubq_f32(vmulq_f32(vaddq_f32(a1, a7), result), a8).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

void CI::f4_s_s_f3_f3_f3_f_f3_f3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, __n128, float, __n128, __n128);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const vec2 *v20;
  __n128 *v21;
  __n128 *v22;
  __int128 v23;
  const vec2 *v24;
  uint64_t v25;
  int v26;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, float, __n128, __n128))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_QWORD *)(v9 + 80);
  v17 = *(_QWORD *)(v9 + 104);
  v18 = *(_QWORD *)(v9 + 128);
  v19 = *(_QWORD *)(v9 + 152);
  v20 = *(const vec2 **)(v9 + 176);
  if (*(_BYTE *)(a1 + 64))
  {
    v24 = *(const vec2 **)(v9 + 176);
    v25 = *(_QWORD *)(v9 + 104);
    v26 = *(_DWORD *)(v9 + 40);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 200)), v20);
    v20 = v24;
    v17 = v25;
    v13 = v26;
  }
  v21 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v21 = (__n128 *)(a2 + (v14 << 6));
  v22 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v22 = (__n128 *)(a2 + (v12 << 6));
  *(double *)&v23 = v10(*v22, *v21, *(__n128 *)(a2 + (v15 << 6)), *(__n128 *)(a2 + (v16 << 6)), *(__n128 *)(a2 + (v17 << 6)), *(float *)(a2 + (v18 << 6)), *(__n128 *)(a2 + (v19 << 6)), *(__n128 *)(a2 + ((_QWORD)v20 << 6)));
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

__n128 cikernel::_gainMap(float32x4_t a1, simd_float4 a2, float a3)
{
  __n128 result;

  result.n128_f32[0] = (a3 + -1.0) * _simd_pow_f4(a2, (simd_float4)vdupq_n_s64(0x400CCCCD400CCCCDuLL)).f32[0] + 1.0;
  result.n128_u64[0] = vmulq_n_f32(a1, result.n128_f32[0]).u64[0];
  result.n128_u32[3] = a1.u32[3];
  return result;
}

void CI::GLTextureImage::~GLTextureImage(CI::GLTextureImage *this)
{
  CI::TextureImage::~TextureImage(this);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::TextureImage::type(CI::TextureImage *this)
{
  return 25;
}

uint64_t CI::TextureImage::child_count(CI::TextureImage *this)
{
  return 0;
}

uint64_t CI::TextureImage::child(CI::TextureImage *this)
{
  return 0;
}

uint64_t CI::TextureImage::shape_for_graphviz(CI::TextureImage *this)
{
  return 0;
}

uint64_t CI::TextureImage::color_for_graphviz(CI::TextureImage *this)
{
  return 11;
}

_DWORD *CI::TextureImage::extent(_DWORD *this)
{
  if (!this[39])
    return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)this + 96))(this);
  return this;
}

double CI::TextureImage::extent_unclamped(CI::TextureImage *this)
{
  return 0.0;
}

uint64_t CI::TextureImage::max_dimension(CI::TextureImage *this)
{
  unsigned int v1;
  unsigned int v2;

  v1 = *((_DWORD *)this + 36);
  v2 = *((_DWORD *)this + 37);
  if ((int)v1 <= (int)v2)
    return v2;
  else
    return v1;
}

uint64_t CI::Image::tileable(CI::Image *this)
{
  return 0;
}

BOOL CI::TextureImage::alpha_one(CI::TextureImage *this)
{
  return *((_DWORD *)this + 38) == 1;
}

uint64_t CI::Image::is_warp(CI::Image *this)
{
  return 0;
}

uint64_t CI::Image::output_format(CI::Image *this)
{
  return 0;
}

uint64_t CI::Image::print_for_graphviz(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 160))(a1);
}

uint64_t CI::TextureImage::properties(CI::TextureImage *this)
{
  return *((_QWORD *)this + 17);
}

uint64_t CI::Image::avdepthdata(CI::Image *this)
{
  return 0;
}

uint64_t CI::Image::avmatte(CI::Image *this)
{
  return 0;
}

uint64_t CI::Image::ssmatte(CI::Image *this)
{
  return 0;
}

float CI::TextureImage::headroom(CI::TextureImage *this)
{
  return 0.0;
}

uint64_t CI::TextureImage::colorspace(CI::TextureImage *this)
{
  return 0;
}

CI::Image *CI::Image::baseColorspace(CI::Image *this)
{
  CI::Image *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t (**v4)(CI::Image *);
  CI::Image *result;

  v1 = this;
  v2 = (*(uint64_t (**)(CI::Image *))(*(_QWORD *)this + 240))(this);
  v3 = *(_QWORD *)v1;
  if (v2)
  {
    v4 = (uint64_t (**)(CI::Image *))(v3 + 240);
  }
  else
  {
    result = (CI::Image *)(*(uint64_t (**)(CI::Image *, _QWORD))(v3 + 48))(v1, 0);
    if (!result)
      return result;
    v1 = result;
    v4 = (uint64_t (**)(CI::Image *))(*(_QWORD *)result + 248);
  }
  return (CI::Image *)(*v4)(v1);
}

uint64_t CI::Image::is_empty_if_regions_of_children_are_empty(CI::Image *this)
{
  return 0;
}

uint64_t CI::Image::url(CI::Image *this)
{
  return *((_QWORD *)this + 6);
}

uint64_t CI::Image::user_info(CI::Image *this)
{
  return *((_QWORD *)this + 7);
}

uint64_t CI::Image::base_obj(CI::Image *this)
{
  return *((_QWORD *)this + 8);
}

uint64_t CI::GLTextureImage::format(CI::GLTextureImage *this)
{
  return 0;
}

uint64_t CI::TextureImage::alpha_mode(CI::TextureImage *this)
{
  return *((unsigned int *)this + 38);
}

uint64_t CI::TextureImage::texture_id(CI::TextureImage *this)
{
  return *((unsigned int *)this + 28);
}

uint64_t CI::GLTextureImage::texture_ref(CI::GLTextureImage *this)
{
  return 0;
}

uint64_t `non-virtual thunk to'CI::TextureImage::type(CI::TextureImage *this)
{
  return 25;
}

void `non-virtual thunk to'CI::GLTextureImage::~GLTextureImage(CI::GLTextureImage *this)
{
  CI::TextureImage::~TextureImage((CI::GLTextureImage *)((char *)this - 104));
}

{
  CI::TextureImage::~TextureImage((CI::GLTextureImage *)((char *)this - 104));
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::MetalTextureImage::MetalTextureImage(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, const void *a6, int a7, int a8)
{
  CI::TextureImage *v9;
  const void *v10;

  v9 = (CI::TextureImage *)CI::TextureImage::TextureImage(a1, a2, 0, a3, a4, a5, a6, a7, a8);
  *(_QWORD *)v9 = &off_1E2EBD868;
  *((_QWORD *)v9 + 13) = &unk_1E2EBD9D8;
  v10 = (const void *)CI::TextureImage::texture_ref(v9);
  if (v10)
    CFRetain(v10);
  return a1;
}

void sub_1922E3180(_Unwind_Exception *a1)
{
  CI::TextureImage *v1;

  CI::TextureImage::~TextureImage(v1);
  _Unwind_Resume(a1);
}

void std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<IRect>>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::vector<IRect>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v3 = *a1;
  v2 = a1[1];
  if (v2 != *a1)
  {
    v4 = a1[1];
    do
    {
      v6 = *(void **)(v4 - 24);
      v4 -= 24;
      v5 = v6;
      if (v6)
      {
        *(_QWORD *)(v2 - 16) = v5;
        operator delete(v5);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

unint64_t CI::AffineImage::makeDigest(uint64_t a1, char *a2, int a3)
{
  int64x2_t v7[5];
  uint64_t __src;

  XXH64_reset(v7, 0);
  LODWORD(__src) = 2;
  XXH64_update((uint64_t)v7, (char *)&__src, 4uLL);
  __src = a1;
  XXH64_update((uint64_t)v7, (char *)&__src, 8uLL);
  XXH64_update((uint64_t)v7, a2, 0x30uLL);
  LODWORD(__src) = a3;
  XXH64_update((uint64_t)v7, (char *)&__src, 4uLL);
  return XXH64_digest((uint64_t)v7);
}

BOOL CI::Affine::isOrientationWithIntegralTranslation(CI::Affine *this)
{
  double v1;
  double v2;
  double v3;

  if ((fabs(*(double *)this) == 1.0 || *(double *)this == 0.0)
    && ((v1 = *((double *)this + 1), fabs(v1) == 1.0) || v1 == 0.0)
    && ((v2 = *((double *)this + 2), fabs(v2) == 1.0) || v2 == 0.0)
    && ((v3 = *((double *)this + 3), fabs(v3) == 1.0) || v3 == 0.0)
    && vabdd_f64(*((double *)this + 4), round(*((double *)this + 4))) < 1.0e-10)
  {
    return vabdd_f64(*((double *)this + 5), round(*((double *)this + 5))) < 1.0e-10;
  }
  else
  {
    return 0;
  }
}

uint64_t CI::InstanceCounted<(CI::Type)2>::type()
{
  return 2;
}

_QWORD *CI::InstanceCounted<(CI::Type)2>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBBAB0;
  do
    v1 = __ldaxr(dword_1ECF872F0);
  while (__stlxr(v1 - 1, dword_1ECF872F0));
  return result;
}

void CI::InstanceCounted<(CI::Type)2>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBBAB0;
  do
    v1 = __ldaxr(dword_1ECF872F0);
  while (__stlxr(v1 - 1, dword_1ECF872F0));
  JUMPOUT(0x194025AACLL);
}

unint64_t CI::CropImage::makeDigest(uint64_t a1, double a2, double a3, double a4, double a5)
{
  int64x2_t v7[5];
  _QWORD v8[4];
  uint64_t __src;

  *(double *)v8 = a2;
  *(double *)&v8[1] = a3;
  *(double *)&v8[2] = a4;
  *(double *)&v8[3] = a5;
  XXH64_reset(v7, 0);
  LODWORD(__src) = 6;
  XXH64_update((uint64_t)v7, (char *)&__src, 4uLL);
  __src = a1;
  XXH64_update((uint64_t)v7, (char *)&__src, 8uLL);
  XXH64_update((uint64_t)v7, (char *)v8, 0x20uLL);
  return XXH64_digest((uint64_t)v7);
}

uint64_t CI::InstanceCounted<(CI::Type)6>::type()
{
  return 6;
}

_QWORD *CI::InstanceCounted<(CI::Type)6>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBBF88;
  do
    v1 = __ldaxr(&dword_1ECF872F0[4]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[4]));
  return result;
}

void CI::InstanceCounted<(CI::Type)6>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBBF88;
  do
    v1 = __ldaxr(&dword_1ECF872F0[4]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[4]));
  JUMPOUT(0x194025AACLL);
}

CI::ClampImage *CI::ClampImage::ClampImage(CI::ClampImage *this, CI::Image *a2, CGRect a3)
{
  double height;
  double width;
  double y;
  double x;
  unsigned int v9;

  height = a3.size.height;
  width = a3.size.width;
  y = a3.origin.y;
  x = a3.origin.x;
  *((_QWORD *)CI::ImageWithChild::ImageWithChild(this, a2) + 14) = off_1E2EBC000;
  do
    v9 = __ldaxr(&dword_1ECF872F0[5]);
  while (__stlxr(v9 + 1, &dword_1ECF872F0[5]));
  *(_QWORD *)this = &unk_1E2EB82A8;
  *((_QWORD *)this + 14) = &unk_1E2EB8400;
  *((double *)this + 15) = x;
  *((double *)this + 16) = y;
  *((double *)this + 17) = width;
  *((double *)this + 18) = height;
  *((_QWORD *)this + 10) = CI::ClampImage::makeDigest(*((_QWORD *)a2 + 10), x, y, width, height);
  *((_QWORD *)this + 11) = CI::ClampImage::makeDigest(*((_QWORD *)a2 + 11), x, y, width, height);
  return this;
}

void sub_1922E358C(_Unwind_Exception *a1)
{
  CI::ImageWithChild *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v5;
  unsigned int v6;

  *((_QWORD *)v1 + 14) = v2;
  v5 = (unsigned int *)(v3 + 28);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 - 1, v5));
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::ClampImage::makeDigest(uint64_t a1, double a2, double a3, double a4, double a5)
{
  int64x2_t v7[5];
  _QWORD v8[4];
  uint64_t __src;

  *(double *)v8 = a2;
  *(double *)&v8[1] = a3;
  *(double *)&v8[2] = a4;
  *(double *)&v8[3] = a5;
  XXH64_reset(v7, 0);
  LODWORD(__src) = 7;
  XXH64_update((uint64_t)v7, (char *)&__src, 4uLL);
  __src = a1;
  XXH64_update((uint64_t)v7, (char *)&__src, 8uLL);
  XXH64_update((uint64_t)v7, (char *)v8, 0x20uLL);
  return XXH64_digest((uint64_t)v7);
}

uint64_t CI::InstanceCounted<(CI::Type)7>::type()
{
  return 7;
}

_QWORD *CI::InstanceCounted<(CI::Type)7>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBC000;
  do
    v1 = __ldaxr(&dword_1ECF872F0[5]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[5]));
  return result;
}

void CI::InstanceCounted<(CI::Type)7>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBC000;
  do
    v1 = __ldaxr(&dword_1ECF872F0[5]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[5]));
  JUMPOUT(0x194025AACLL);
}

CI::PremultiplyImage *CI::PremultiplyImage::PremultiplyImage(CI::PremultiplyImage *this, CI::Image *a2, int a3)
{
  unsigned int v6;

  *((_QWORD *)CI::ImageWithChild::ImageWithChild(this, a2) + 14) = off_1E2EBB8D0;
  do
    v6 = __ldaxr(&dword_1ECF872F0[14]);
  while (__stlxr(v6 + 1, &dword_1ECF872F0[14]));
  *(_QWORD *)this = &unk_1E2EBD058;
  *((_QWORD *)this + 14) = &unk_1E2EBD1B0;
  *((_DWORD *)this + 30) = a3;
  *((_QWORD *)this + 10) = CI::PremultiplyImage::makeDigest(*((_QWORD *)a2 + 10), a3);
  *((_QWORD *)this + 11) = CI::PremultiplyImage::makeDigest(*((_QWORD *)a2 + 11), a3);
  *((_BYTE *)this + 97) = 0;
  return this;
}

void sub_1922E3748(_Unwind_Exception *a1)
{
  CI::ImageWithChild *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v5;
  unsigned int v6;

  *((_QWORD *)v1 + 14) = v2;
  v5 = (unsigned int *)(v3 + 64);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 - 1, v5));
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::PremultiplyImage::makeDigest(uint64_t a1, int a2)
{
  int64x2_t v5[5];
  uint64_t __src;

  XXH64_reset(v5, 0);
  LODWORD(__src) = 16;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  __src = a1;
  XXH64_update((uint64_t)v5, (char *)&__src, 8uLL);
  LODWORD(__src) = a2;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  return XXH64_digest((uint64_t)v5);
}

uint64_t CI::InstanceCounted<(CI::Type)16>::type()
{
  return 16;
}

_QWORD *CI::InstanceCounted<(CI::Type)16>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBB8D0;
  do
    v1 = __ldaxr(&dword_1ECF872F0[14]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[14]));
  return result;
}

void CI::InstanceCounted<(CI::Type)16>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBB8D0;
  do
    v1 = __ldaxr(&dword_1ECF872F0[14]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[14]));
  JUMPOUT(0x194025AACLL);
}

CI::ClampToAlphaImage *CI::ClampToAlphaImage::ClampToAlphaImage(CI::ClampToAlphaImage *this, CI::Image *a2)
{
  unsigned int v4;

  *((_QWORD *)CI::ImageWithChild::ImageWithChild(this, a2) + 14) = off_1E2EBC0A0;
  do
    v4 = __ldaxr(&dword_1ECF872F0[6]);
  while (__stlxr(v4 + 1, &dword_1ECF872F0[6]));
  *(_QWORD *)this = &unk_1E2EBD3B8;
  *((_QWORD *)this + 14) = &unk_1E2EBD510;
  *((_QWORD *)this + 10) = CI::ClampToAlphaImage::makeDigest(*((_QWORD *)a2 + 10));
  *((_QWORD *)this + 11) = CI::ClampToAlphaImage::makeDigest(*((_QWORD *)a2 + 11));
  return this;
}

void sub_1922E38E8(_Unwind_Exception *a1)
{
  CI::ImageWithChild *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v5;
  unsigned int v6;

  *((_QWORD *)v1 + 14) = v2;
  v5 = (unsigned int *)(v3 + 32);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 - 1, v5));
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::ClampToAlphaImage::makeDigest(uint64_t a1)
{
  int64x2_t v3[5];
  uint64_t __src;

  XXH64_reset(v3, 0);
  LODWORD(__src) = 8;
  XXH64_update((uint64_t)v3, (char *)&__src, 4uLL);
  __src = a1;
  XXH64_update((uint64_t)v3, (char *)&__src, 8uLL);
  return XXH64_digest((uint64_t)v3);
}

uint64_t CI::InstanceCounted<(CI::Type)8>::type()
{
  return 8;
}

_QWORD *CI::InstanceCounted<(CI::Type)8>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBC0A0;
  do
    v1 = __ldaxr(&dword_1ECF872F0[6]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[6]));
  return result;
}

void CI::InstanceCounted<(CI::Type)8>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBC0A0;
  do
    v1 = __ldaxr(&dword_1ECF872F0[6]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[6]));
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::SwizzleImage::SwizzleImage(uint64_t a1, uint64_t *a2, int a3)
{
  unsigned int v6;

  *((_QWORD *)CI::ImageWithChild::ImageWithChild((CI::ImageWithChild *)a1, (CI::Image *)a2) + 14) = off_1E2EBB9E8;
  do
    v6 = __ldaxr(&dword_1ECF872F0[21]);
  while (__stlxr(v6 + 1, &dword_1ECF872F0[21]));
  *(_QWORD *)a1 = &off_1E2EB9A60;
  *(_QWORD *)(a1 + 112) = &unk_1E2EB9BC0;
  *(_DWORD *)(a1 + 120) = a3;
  *(_QWORD *)(a1 + 80) = CI::SwizzleImage::makeDigest(a2[10], a3);
  *(_QWORD *)(a1 + 88) = CI::SwizzleImage::makeDigest(a2[11], a3);
  return a1;
}

void sub_1922E3A88(_Unwind_Exception *a1)
{
  CI::ImageWithChild *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v5;
  unsigned int v6;

  *((_QWORD *)v1 + 14) = v2;
  v5 = (unsigned int *)(v3 + 92);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 - 1, v5));
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::SwizzleImage::makeDigest(uint64_t a1, int a2)
{
  int64x2_t v5[5];
  uint64_t __src;

  XXH64_reset(v5, 0);
  LODWORD(__src) = 23;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  __src = a1;
  XXH64_update((uint64_t)v5, (char *)&__src, 8uLL);
  LODWORD(__src) = a2;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  return XXH64_digest((uint64_t)v5);
}

uint64_t CI::InstanceCounted<(CI::Type)23>::type()
{
  return 23;
}

_QWORD *CI::InstanceCounted<(CI::Type)23>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBB9E8;
  do
    v1 = __ldaxr(&dword_1ECF872F0[21]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[21]));
  return result;
}

void CI::InstanceCounted<(CI::Type)23>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBB9E8;
  do
    v1 = __ldaxr(&dword_1ECF872F0[21]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[21]));
  JUMPOUT(0x194025AACLL);
}

CI::GammaImage *CI::GammaImage::GammaImage(CI::GammaImage *this, CI::Image *a2, double a3)
{
  unsigned int v6;

  *((_QWORD *)CI::ImageWithChild::ImageWithChild(this, a2) + 14) = off_1E2EBB7E0;
  do
    v6 = __ldaxr(&dword_1ECF872F0[8]);
  while (__stlxr(v6 + 1, &dword_1ECF872F0[8]));
  *(_QWORD *)this = &off_1E2EB8428;
  *((_QWORD *)this + 14) = &unk_1E2EB8580;
  *((double *)this + 15) = a3;
  *((_QWORD *)this + 10) = CI::GammaImage::makeDigest(*((_QWORD *)a2 + 10), a3);
  *((_QWORD *)this + 11) = CI::GammaImage::makeDigest(*((_QWORD *)a2 + 11), a3);
  *((_BYTE *)this + 97) = 0;
  return this;
}

void sub_1922E3C44(_Unwind_Exception *a1)
{
  CI::ImageWithChild *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v5;
  unsigned int v6;

  *((_QWORD *)v1 + 14) = v2;
  v5 = (unsigned int *)(v3 + 40);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 - 1, v5));
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::GammaImage::makeDigest(uint64_t a1, double a2)
{
  int64x2_t v5[5];
  double __src;

  XXH64_reset(v5, 0);
  LODWORD(__src) = 10;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  __src = *(double *)&a1;
  XXH64_update((uint64_t)v5, (char *)&__src, 8uLL);
  __src = a2;
  XXH64_update((uint64_t)v5, (char *)&__src, 8uLL);
  return XXH64_digest((uint64_t)v5);
}

uint64_t CI::InstanceCounted<(CI::Type)10>::type()
{
  return 10;
}

_QWORD *CI::InstanceCounted<(CI::Type)10>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBB7E0;
  do
    v1 = __ldaxr(&dword_1ECF872F0[8]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[8]));
  return result;
}

void CI::InstanceCounted<(CI::Type)10>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBB7E0;
  do
    v1 = __ldaxr(&dword_1ECF872F0[8]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[8]));
  JUMPOUT(0x194025AACLL);
}

CI::TagColorSpaceImage *CI::TagColorSpaceImage::TagColorSpaceImage(CI::TagColorSpaceImage *this, CI::Image *a2, CGColorSpace *a3)
{
  unsigned int v6;
  int64x2_t v8[5];
  uint64_t __src;

  *((_QWORD *)CI::ImageWithChild::ImageWithChild(this, a2) + 14) = off_1E2EBBA10;
  do
    v6 = __ldaxr(&dword_1ECF872F0[22]);
  while (__stlxr(v6 + 1, &dword_1ECF872F0[22]));
  *(_QWORD *)this = &off_1E2EBDD70;
  *((_QWORD *)this + 14) = &unk_1E2EBDEC8;
  *((_QWORD *)this + 15) = CGColorSpaceRetain(a3);
  XXH64_reset(v8, 0);
  LODWORD(__src) = (*(uint64_t (**)(CI::TagColorSpaceImage *))(*(_QWORD *)this + 16))(this);
  XXH64_update((uint64_t)v8, (char *)&__src, 4uLL);
  __src = *((_QWORD *)a2 + 10);
  XXH64_update((uint64_t)v8, (char *)&__src, 8uLL);
  CI::XXHashHelper::add((CI::XXHashHelper *)v8, a3);
  *((_QWORD *)this + 10) = XXH64_digest((uint64_t)v8);
  return this;
}

void sub_1922E3E54(_Unwind_Exception *a1)
{
  CI::ImageWithChild *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v5;
  unsigned int v6;

  *((_QWORD *)v1 + 14) = v2;
  v5 = (unsigned int *)(v3 + 96);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 - 1, v5));
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::InstanceCounted<(CI::Type)24>::type()
{
  return 24;
}

_QWORD *CI::InstanceCounted<(CI::Type)24>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBBA10;
  do
    v1 = __ldaxr(&dword_1ECF872F0[22]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[22]));
  return result;
}

void CI::InstanceCounted<(CI::Type)24>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBBA10;
  do
    v1 = __ldaxr(&dword_1ECF872F0[22]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[22]));
  JUMPOUT(0x194025AACLL);
}

size_t CI::XXHashHelper::add(CI::XXHashHelper *this, CFDataRef theData)
{
  char *BytePtr;
  size_t result;
  int __src;

  if (theData)
  {
    BytePtr = (char *)CFDataGetBytePtr(theData);
    result = CFDataGetLength(theData);
    if (BytePtr)
    {
      if (result)
        return XXH64_update((uint64_t)this, BytePtr, result);
    }
  }
  else
  {
    __src = 0;
    return XXH64_update((uint64_t)this, (char *)&__src, 4uLL);
  }
  return result;
}

CI::NoopImage *CI::NoopImage::NoopImage(CI::NoopImage *this, CI::Image *a2, Trilean a3, int a4)
{
  unsigned int v8;

  *((_QWORD *)CI::ImageWithChild::ImageWithChild(this, a2) + 14) = off_1E2EBB8A8;
  do
    v8 = __ldaxr(&dword_1ECF872F0[13]);
  while (__stlxr(v8 + 1, &dword_1ECF872F0[13]));
  *(_QWORD *)this = &unk_1E2EC0568;
  *((_QWORD *)this + 14) = &unk_1E2EC06C0;
  *((Trilean *)this + 120) = a3;
  *((_BYTE *)this + 121) = a4;
  *((_QWORD *)this + 10) = CI::NoopImage::makeDigest(*((_QWORD *)a2 + 10), a3.var0, a4);
  *((_QWORD *)this + 11) = CI::NoopImage::makeDigest(*((_QWORD *)a2 + 11), a3.var0, a4);
  *((_BYTE *)this + 97) = 0;
  return this;
}

void sub_1922E4034(_Unwind_Exception *a1)
{
  CI::ImageWithChild *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v5;
  unsigned int v6;

  *((_QWORD *)v1 + 14) = v2;
  v5 = (unsigned int *)(v3 + 60);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 - 1, v5));
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::NoopImage::makeDigest(uint64_t a1, unsigned __int8 a2, int a3)
{
  int64x2_t v7[5];
  uint64_t __src;

  XXH64_reset(v7, 0);
  LODWORD(__src) = 15;
  XXH64_update((uint64_t)v7, (char *)&__src, 4uLL);
  __src = a1;
  XXH64_update((uint64_t)v7, (char *)&__src, 8uLL);
  LODWORD(__src) = a3;
  XXH64_update((uint64_t)v7, (char *)&__src, 4uLL);
  if (a2 == 255)
  {
    LODWORD(__src) = 0;
    goto LABEL_5;
  }
  if (a2 == 1)
  {
    LODWORD(__src) = 1;
LABEL_5:
    XXH64_update((uint64_t)v7, (char *)&__src, 4uLL);
  }
  return XXH64_digest((uint64_t)v7);
}

uint64_t CI::InstanceCounted<(CI::Type)15>::type()
{
  return 15;
}

_QWORD *CI::InstanceCounted<(CI::Type)15>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBB8A8;
  do
    v1 = __ldaxr(&dword_1ECF872F0[13]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[13]));
  return result;
}

void CI::InstanceCounted<(CI::Type)15>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBB8A8;
  do
    v1 = __ldaxr(&dword_1ECF872F0[13]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[13]));
  JUMPOUT(0x194025AACLL);
}

CI::SetPropsImage *CI::SetPropsImage::SetPropsImage(CI::SetPropsImage *this, CI::Image *a2, const __CFDictionary *a3)
{
  unsigned int v6;
  CFTypeRef v7;

  *((_QWORD *)CI::ImageWithChild::ImageWithChild(this, a2) + 14) = off_1E2EBB998;
  do
    v6 = __ldaxr(&dword_1ECF872F0[19]);
  while (__stlxr(v6 + 1, &dword_1ECF872F0[19]));
  *(_QWORD *)this = &off_1E2EBA5A0;
  *((_QWORD *)this + 14) = &unk_1E2EBA6F8;
  if (a3)
    v7 = CFRetain(a3);
  else
    v7 = 0;
  *((_QWORD *)this + 15) = v7;
  *((_QWORD *)this + 10) = CI::SetPropsImage::makeDigest(*((_QWORD *)a2 + 10));
  *((_QWORD *)this + 11) = CI::SetPropsImage::makeDigest(*((_QWORD *)a2 + 11));
  return this;
}

void sub_1922E4234(_Unwind_Exception *a1)
{
  CI::ImageWithChild *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v5;
  unsigned int v6;

  *((_QWORD *)v1 + 14) = v2;
  v5 = (unsigned int *)(v3 + 84);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 - 1, v5));
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::SetPropsImage::makeDigest(uint64_t a1)
{
  int64x2_t v3[5];
  uint64_t __src;

  XXH64_reset(v3, 0);
  LODWORD(__src) = 21;
  XXH64_update((uint64_t)v3, (char *)&__src, 4uLL);
  __src = a1;
  XXH64_update((uint64_t)v3, (char *)&__src, 8uLL);
  return XXH64_digest((uint64_t)v3);
}

uint64_t CI::InstanceCounted<(CI::Type)21>::type()
{
  return 21;
}

_QWORD *CI::InstanceCounted<(CI::Type)21>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBB998;
  do
    v1 = __ldaxr(&dword_1ECF872F0[19]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[19]));
  return result;
}

void CI::InstanceCounted<(CI::Type)21>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBB998;
  do
    v1 = __ldaxr(&dword_1ECF872F0[19]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[19]));
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::SampleModeImage::SampleModeImage(uint64_t a1, uint64_t *a2, int a3)
{
  unsigned int v6;

  *((_QWORD *)CI::ImageWithChild::ImageWithChild((CI::ImageWithChild *)a1, (CI::Image *)a2) + 14) = off_1E2EBB970;
  do
    v6 = __ldaxr(&dword_1ECF872F0[18]);
  while (__stlxr(v6 + 1, &dword_1ECF872F0[18]));
  *(_QWORD *)a1 = &unk_1E2EBC3F0;
  *(_QWORD *)(a1 + 112) = &unk_1E2EBC548;
  *(_DWORD *)(a1 + 120) = a3;
  *(_QWORD *)(a1 + 80) = CI::SampleModeImage::makeDigest(a2[10], a3);
  *(_QWORD *)(a1 + 88) = CI::SampleModeImage::makeDigest(a2[11], a3);
  *(_BYTE *)(a1 + 97) = 0;
  return a1;
}

void sub_1922E43D8(_Unwind_Exception *a1)
{
  CI::ImageWithChild *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v5;
  unsigned int v6;

  *((_QWORD *)v1 + 14) = v2;
  v5 = (unsigned int *)(v3 + 80);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 - 1, v5));
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::SampleModeImage::makeDigest(uint64_t a1, int a2)
{
  int64x2_t v5[5];
  uint64_t __src;

  XXH64_reset(v5, 0);
  LODWORD(__src) = 20;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  __src = a1;
  XXH64_update((uint64_t)v5, (char *)&__src, 8uLL);
  LODWORD(__src) = a2;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  return XXH64_digest((uint64_t)v5);
}

uint64_t CI::InstanceCounted<(CI::Type)20>::type()
{
  return 20;
}

_QWORD *CI::InstanceCounted<(CI::Type)20>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBB970;
  do
    v1 = __ldaxr(&dword_1ECF872F0[18]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[18]));
  return result;
}

void CI::InstanceCounted<(CI::Type)20>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBB970;
  do
    v1 = __ldaxr(&dword_1ECF872F0[18]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[18]));
  JUMPOUT(0x194025AACLL);
}

CI::SerialObjectPtrArray *CI::SerialObjectPtrArray::SerialObjectPtrArray(CI::SerialObjectPtrArray *this, int a2)
{
  void *v4;
  int v5;

  *((_DWORD *)this + 2) = 0;
  *(_QWORD *)this = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 12) = 0;
  if (a2 > 10)
  {
    *((_DWORD *)this + 1) = a2;
    v4 = malloc_type_calloc((a2 - 10), 8uLL, 0x80040B8603338uLL);
  }
  else
  {
    v4 = 0;
    *((_DWORD *)this + 1) = 10;
  }
  *((_QWORD *)this + 2) = v4;
  if (a2 <= 1)
    v5 = 1;
  else
    v5 = a2;
  *((_DWORD *)this + 2) = v5;
  return this;
}

uint64_t __Block_byref_object_copy__9(uint64_t a1, uint64_t a2)
{
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__hash_table(a1 + 48, (uint64_t *)(a2 + 48));
}

uint64_t __Block_byref_object_dispose__9(uint64_t a1)
{
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(a1 + 48);
}

uint64_t __Block_byref_object_copy__744(uint64_t a1, uint64_t a2)
{
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__hash_table(a1 + 48, (uint64_t *)(a2 + 48));
}

uint64_t __Block_byref_object_dispose__745(uint64_t a1)
{
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(a1 + 48);
}

BOOL ___ZN2CIL21print_graph_recursiveINS_5ImageENS_10ImageIndexENS1_10ImageStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke_746(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;

  v7 = a2;
  v3 = std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::find<CI::Image const*>((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48), &v7);
  if (v3)
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v6 = *(_QWORD *)(v4 + 72);
    std::__hash_table<std::__hash_value_type<CI::Image const*,unsigned long>,std::__unordered_map_hasher<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,true>,std::__unordered_map_equal<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::equal_to<CI::Image const*>,std::hash<CI::Image const*>,true>,std::allocator<std::__hash_value_type<CI::Image const*,unsigned long>>>::__emplace_unique_key_args<CI::Image const*,CI::Image const*&,unsigned long>(v4 + 48, &v7, &v7, &v6);
  }
  else
  {
    std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__emplace_unique_key_args<CI::Image const*,CI::Image const* const&>(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48, &v7, &v7);
  }
  return v3 != 0;
}

void *__Block_byref_object_copy__748(uint64_t a1, uint64_t a2)
{
  return memcpy((void *)(a1 + 48), (const void *)(a2 + 48), 0x400uLL);
}

BOOL ___ZN2CIL21print_graph_recursiveINS_5ImageENS_10ImageIndexENS1_10ImageStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke_751(uint64_t a1, unsigned int *a2, uint64_t a3, int a4, int a5)
{
  unint64_t v9;
  int v10;
  BOOL v11;
  int v12;
  unint64_t v13;
  FILE *v14;
  const char *v15;
  size_t v16;
  _QWORD *v17;
  FILE *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t *v21;
  FILE *v22;
  uint64_t v23;
  _QWORD *v24;
  unsigned int *v26;
  unsigned int **v27;

  v26 = a2;
  fprintf(*(FILE **)(a1 + 56), "%.*s", 2 * *(_DWORD *)(a1 + 72), CI::print_graph_recursive<CI::Image,CI::ImageIndex,CI::Image::ImageStats>(__sFILE *,CI::Image const*,int,std::unordered_map<CI::ImageIndex,CI::Image::ImageStats> const&)::indent_str);
  if (a4 <= 0x3FF)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + a4 + 48) = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)a2 + 40))(a2);
  if (a4 >= 1)
  {
    v9 = 0;
    do
    {
      if (v9 <= 0x3FF
        && (v10 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + v9 + 48),
            v11 = v10 != 0,
            v12 = v10 - 1,
            v12 != 0 && v11))
      {
        v13 = v9 + 1;
        v14 = *(FILE **)(a1 + 56);
        if (v9 + 1 == a4 && v12 == a5)
        {
          fwrite("", 6uLL, 1uLL, v14);
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + v9 + 48) = 0;
        }
        else
        {
          if (v13 == a4)
          {
            v15 = "";
            v16 = 6;
          }
          else
          {
            v15 = " ";
            v16 = 4;
          }
          fwrite(v15, v16, 1uLL, v14);
        }
      }
      else
      {
        fwrite("  ", 2uLL, 1uLL, *(FILE **)(a1 + 56));
        v13 = v9 + 1;
      }
      v9 = v13;
    }
    while (v13 != a4);
  }
  v17 = std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::find<CI::Image const*>((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48), &v26);
  if (v17)
  {
    v18 = *(FILE **)(a1 + 56);
    v19 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 48;
    v27 = &v26;
    v20 = std::__hash_table<std::__hash_value_type<CI::Image const*,unsigned long>,std::__unordered_map_hasher<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,true>,std::__unordered_map_equal<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::equal_to<CI::Image const*>,std::hash<CI::Image const*>,true>,std::allocator<std::__hash_value_type<CI::Image const*,unsigned long>>>::__emplace_unique_key_args<CI::Image const*,std::piecewise_construct_t const&,std::tuple<CI::Image const* const&>,std::tuple<>>(v19, &v26, (uint64_t)&std::piecewise_construct, &v27);
    fprintf(v18, "<%ld>\n", v20[3]);
  }
  else
  {
    v21 = std::__hash_table<std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::__unordered_map_hasher<CI::ImageIndex,std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::hash<CI::ImageIndex>,std::equal_to<CI::ImageIndex>,true>,std::__unordered_map_equal<CI::ImageIndex,std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::equal_to<CI::ImageIndex>,std::hash<CI::ImageIndex>,true>,std::allocator<std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>>>::find<CI::ImageIndex>(*(_QWORD **)(a1 + 64), v26 + 25);
    if (v21)
      (*(void (**)(unsigned int *, _QWORD, uint64_t))(*(_QWORD *)v26 + 152))(v26, *(_QWORD *)(a1 + 56), (uint64_t)v21 + 20);
    else
      (*(void (**)(unsigned int *, _QWORD, unsigned int ***))(*(_QWORD *)v26 + 152))(v26, *(_QWORD *)(a1 + 56), &v27);
    if (std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::find<CI::Image const*>((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 48), &v26))
    {
      v22 = *(FILE **)(a1 + 56);
      v23 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 48;
      v27 = &v26;
      v24 = std::__hash_table<std::__hash_value_type<CI::Image const*,unsigned long>,std::__unordered_map_hasher<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,true>,std::__unordered_map_equal<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::equal_to<CI::Image const*>,std::hash<CI::Image const*>,true>,std::allocator<std::__hash_value_type<CI::Image const*,unsigned long>>>::__emplace_unique_key_args<CI::Image const*,std::piecewise_construct_t const&,std::tuple<CI::Image const* const&>,std::tuple<>>(v23, &v26, (uint64_t)&std::piecewise_construct, &v27);
      fprintf(v22, " <%ld>", v24[3]);
    }
    fputc(10, *(FILE **)(a1 + 56));
    std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__emplace_unique_key_args<CI::Image const*,CI::Image const* const&>(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48, &v26, &v26);
  }
  return v17 != 0;
}

uint64_t std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__hash_table(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = *a2;
  *a2 = 0;
  *(_QWORD *)result = v2;
  *(_QWORD *)(result + 8) = a2[1];
  a2[1] = 0;
  v5 = a2[2];
  v3 = a2 + 2;
  v4 = v5;
  *(_QWORD *)(result + 16) = v5;
  v6 = v3[1];
  *(_QWORD *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    v7 = *(_QWORD *)(v4 + 8);
    v8 = *(_QWORD *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v7 %= v8;
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(_QWORD *)(v2 + 8 * v7) = result + 16;
    *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t ___ZNK2CI5Image27traverse_preorder_stoppableEU13block_pointerFbPKS0_S2_iiE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

_QWORD *std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::find<CI::Image const*>(_QWORD *a1, _QWORD *a2)
{
  int8x8_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = v5;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = v5 & (*(_QWORD *)&v2 - 1);
  }
  v8 = *(_QWORD **)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  result = (_QWORD *)*v8;
  if (*v8)
  {
    do
    {
      v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2)
          return result;
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(_QWORD *)&v2)
            v10 %= *(_QWORD *)&v2;
        }
        else
        {
          v10 &= *(_QWORD *)&v2 - 1;
        }
        if (v10 != v7)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<CI::Image const*,unsigned long>,std::__unordered_map_hasher<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,true>,std::__unordered_map_equal<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::equal_to<CI::Image const*>,std::hash<CI::Image const*>,true>,std::allocator<std::__hash_value_type<CI::Image const*,unsigned long>>>::__emplace_unique_key_args<CI::Image const*,CI::Image const*&,unsigned long>(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t *a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  _QWORD **v13;
  _QWORD *i;
  unint64_t v15;
  uint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;

  v8 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v9 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v8 >> 47) ^ v8);
  v10 = 0x9DDFEA08EB382D69 * (v9 ^ (v9 >> 47));
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      v4 = 0x9DDFEA08EB382D69 * (v9 ^ (v9 >> 47));
      if (v10 >= v11)
        v4 = v10 % v11;
    }
    else
    {
      v4 = v10 & (v11 - 1);
    }
    v13 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      for (i = *v13; i; i = (_QWORD *)*i)
      {
        v15 = i[1];
        if (v15 == v10)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v12.u32[0] > 1uLL)
          {
            if (v15 >= v11)
              v15 %= v11;
          }
          else
          {
            v15 &= v11 - 1;
          }
          if (v15 != v4)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v10;
  v16 = *a4;
  i[2] = *a3;
  i[3] = v16;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    v19 = 1;
    if (v11 >= 3)
      v19 = (v11 & (v11 - 1)) != 0;
    v20 = v19 | (2 * v11);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>(a1, v22);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *i = *v24;
LABEL_38:
    *v24 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v23 + 8 * v4) = a1 + 16;
  if (*i)
  {
    v25 = *(_QWORD *)(*i + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v25 >= v11)
        v25 %= v11;
    }
    else
    {
      v25 &= v11 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1922E4D20(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__emplace_unique_key_args<CI::Image const*,CI::Image const* const&>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = v8 & (v9 - 1);
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x18uLL);
  *i = 0;
  i[1] = v8;
  i[2] = *a3;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>(a1, v19);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *i = *v21;
LABEL_38:
    *v21 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v22 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9)
        v22 %= v9;
    }
    else
    {
      v22 &= v9 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1922E4F70(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::clear(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t i;

  if (result[3])
  {
    v1 = result;
    result = (_QWORD *)result[2];
    if (result)
    {
      do
      {
        v2 = (_QWORD *)*result;
        operator delete(result);
        result = v2;
      }
      while (v2);
    }
    v1[2] = 0;
    v3 = v1[1];
    if (v3)
    {
      for (i = 0; i != v3; ++i)
        *(_QWORD *)(*v1 + 8 * i) = 0;
    }
    v1[3] = 0;
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<CI::Image const*,unsigned long>,std::__unordered_map_hasher<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,true>,std::__unordered_map_equal<CI::Image const*,std::__hash_value_type<CI::Image const*,unsigned long>,std::equal_to<CI::Image const*>,std::hash<CI::Image const*>,true>,std::allocator<std::__hash_value_type<CI::Image const*,unsigned long>>>::__emplace_unique_key_args<CI::Image const*,std::piecewise_construct_t const&,std::tuple<CI::Image const* const&>,std::tuple<>>(uint64_t a1, _QWORD *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  _QWORD **v12;
  _QWORD *i;
  unint64_t v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10)
        v4 = v9 % v10;
    }
    else
    {
      v4 = v9 & (v10 - 1);
    }
    v12 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v12)
    {
      for (i = *v12; i; i = (_QWORD *)*i)
      {
        v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10)
              v14 %= v10;
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v4)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v9;
  i[2] = **a4;
  i[3] = 0;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v10 || (float)(v16 * (float)v10) < v15)
  {
    v17 = 1;
    if (v10 >= 3)
      v17 = (v10 & (v10 - 1)) != 0;
    v18 = v17 | (2 * v10);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>(a1, v20);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *i = *v22;
LABEL_38:
    *v22 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v21 + 8 * v4) = a1 + 16;
  if (*i)
  {
    v23 = *(_QWORD *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v23 >= v10)
        v23 %= v10;
    }
    else
    {
      v23 &= v10 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1922E5228(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::__unordered_map_hasher<CI::ImageIndex,std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::hash<CI::ImageIndex>,std::equal_to<CI::ImageIndex>,true>,std::__unordered_map_equal<CI::ImageIndex,std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::equal_to<CI::ImageIndex>,std::hash<CI::ImageIndex>,true>,std::allocator<std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>>>::find<CI::ImageIndex>(_QWORD *a1, unsigned int *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  uint64_t **v6;
  uint64_t *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (*(_QWORD *)&v2 <= v3)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (v2.i32[0] - 1) & v3;
  }
  v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  for (result = *v6; result; result = (uint64_t *)*result)
  {
    v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == (_DWORD)v3)
        return result;
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(_QWORD *)&v2)
          v8 %= *(_QWORD *)&v2;
      }
      else
      {
        v8 &= *(_QWORD *)&v2 - 1;
      }
      if (v8 != v5)
        return 0;
    }
  }
  return result;
}

int8x16_t cikernel::_RGBtoLAB(float32x4_t a1)
{
  float32x4_t v1;
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  int8x16_t v6;
  int8x16_t v7;
  int8x16_t result;
  int8x16_t v9;
  float32x4_t v10;
  unsigned __int32 v11;

  v11 = a1.u32[3];
  v1 = vmulq_f32(a1, (float32x4_t)xmmword_1924952D0);
  v2 = vmulq_f32(a1, (float32x4_t)xmmword_1924952E0);
  v3.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v1, 2), vaddq_f32(v1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v1.f32, 1))).u32[0];
  v4 = vmulq_f32(a1, (float32x4_t)xmmword_1924952F0);
  v3.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))).u32[0];
  v3.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).u32[0];
  v5 = vmaxnmq_f32(v3, (float32x4_t)0);
  v9 = (int8x16_t)vaddq_f32(vmulq_f32(v5, (float32x4_t)vdupq_n_s32(0x40F92F1Bu)), (float32x4_t)vdupq_n_s32(0x3E0D3DCBu));
  v10 = vaddq_f32(v5, (float32x4_t)vdupq_n_s32(0xBC1118C2));
  v5.i32[3] = 0;
  v6 = (int8x16_t)_simd_pow_f4((simd_float4)v5, (simd_float4)xmmword_192495300);
  v7 = (int8x16_t)vcltzq_f32(v10);
  result = vbslq_s8(v7, v9, v6);
  *(double *)v7.i64 = *(float *)&result.i32[1] * 116.0 + -16.0;
  *(float *)v7.i32 = *(double *)v7.i64;
  *(float32x2_t *)result.i8 = vmul_f32(vsub_f32(*(float32x2_t *)result.i8, (float32x2_t)vext_s8(*(int8x8_t *)result.i8, (int8x8_t)*(_OWORD *)&vextq_s8(result, result, 8uLL), 4uLL)), (float32x2_t)0x4348000043FA0000);
  result.i64[0] = vextq_s8(vextq_s8(v7, v7, 4uLL), result, 0xCuLL).u64[0];
  result.i32[3] = v11;
  return result;
}

double cikernel::_LABtoRGB(__n128 a1, float32x4_t a2)
{
  float32_t v2;
  float32_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  double result;

  v2 = (a1.n128_f32[0] + 16.0) / 116.0;
  a2.f32[0] = a1.n128_f32[1] / 500.0 + v2;
  v3 = v2 + a1.n128_f32[2] / -200.0;
  a2.f32[1] = v2;
  a2.f32[2] = v3;
  v4 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vaddq_f32(a2, (float32x4_t)vdupq_n_s32(0xBE53DCB1))), (int8x16_t)vmulq_f32(vaddq_f32(a2, (float32x4_t)vdupq_n_s32(0xBE0D3DCB)), (float32x4_t)vdupq_n_s32(0x3E038027u)), (int8x16_t)vmulq_f32(a2, vmulq_f32(a2, a2)));
  v5 = vmulq_f32(v4, (float32x4_t)xmmword_192495310);
  v6 = vmulq_f32(v4, (float32x4_t)xmmword_192495320);
  *(_QWORD *)&result = vzip1q_s32((int32x4_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))), (int32x4_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1)))).u64[0];
  return result;
}

void OUTLINED_FUNCTION_6_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

CI::ImageAccumulator::Content *CI::ImageAccumulator::Content::Content(CI::ImageAccumulator::Content *this, CGRect a2, CGColorSpace *a3, int a4)
{
  __CVBuffer *width;
  __CVBuffer *height;
  uint64_t v8;
  __IOSurface *Surface;
  uint64_t v10;
  __IOSurface *v11;
  void *v12;
  const __CFString *v14;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  width = (__CVBuffer *)a2.size.width;
  height = (__CVBuffer *)a2.size.height;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  v8 = CI::PixelFormatType_from_format(a4);
  Surface = CreateSurface(width, height, (void *)0x20, v8, 1);
  *((_QWORD *)this + 1) = Surface;
  if (a3)
  {
    v14 = CFSTR("CIImageColorSpace");
    v15[0] = a3;
    v10 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v15, &v14, 1);
    v11 = (__IOSurface *)*((_QWORD *)this + 1);
  }
  else
  {
    v11 = Surface;
    v10 = 0;
  }
  v12 = -[CIImage _internalRepresentation](+[CIImage imageWithIOSurface:options:](CIImage, "imageWithIOSurface:options:", v11, v10), "_internalRepresentation");
  if (v12)
    v12 = (void *)CI::Object::ref((uint64_t)v12);
  *(_QWORD *)this = v12;
  return this;
}

CI::ImageAccumulator *CI::ImageAccumulator::ImageAccumulator(CI::ImageAccumulator *this, CGRect a2, CGColorSpace *a3, int a4, CIContext *a5, CIBlendKernel *a6)
{
  double height;
  double width;
  double y;
  double x;
  id v13;
  id v14;
  CI::ImageAccumulator::Content *v15;
  CI::ImageAccumulator::Content *v16;
  NSObject *v17;
  __int128 v18;
  CGRect v20;
  CGRect v21;

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  *(CGRect *)this = a2;
  *((_QWORD *)this + 4) = a3;
  *((_DWORD *)this + 10) = a4;
  *((_QWORD *)this + 6) = a5;
  *((_QWORD *)this + 7) = a6;
  *((_BYTE *)this + 96) = 0;
  CGColorSpaceRetain(a3);
  v13 = *((id *)this + 6);
  v14 = *((id *)this + 7);
  *((_QWORD *)this + 11) = +[CIImage clearImage:](CIImage, "clearImage:", x, y, width, height);
  v15 = (CI::ImageAccumulator::Content *)operator new();
  v20.origin.x = x;
  v20.origin.y = y;
  v20.size.width = width;
  v20.size.height = height;
  CI::ImageAccumulator::Content::Content(v15, v20, a3, a4);
  *((_QWORD *)this + 8) = v15;
  v16 = (CI::ImageAccumulator::Content *)operator new();
  v21.origin.x = x;
  v21.origin.y = y;
  v21.size.width = width;
  v21.size.height = height;
  CI::ImageAccumulator::Content::Content(v16, v21, a3, a4);
  *((_QWORD *)this + 9) = v16;
  v17 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *((_QWORD *)this + 17) = dispatch_queue_create("CIImageAccumulator", v17);
  *((_QWORD *)this + 10) = *((_QWORD *)this + 8);
  v18 = *(_OWORD *)(MEMORY[0x1E0C9D628] + 16);
  *(_OWORD *)((char *)this + 104) = *MEMORY[0x1E0C9D628];
  *(_OWORD *)((char *)this + 120) = v18;
  *((_DWORD *)this + 25) = 0;
  return this;
}

void sub_1922E57CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x20C40A4A59CD2);
  _Unwind_Resume(a1);
}

void CI::ImageAccumulator::~ImageAccumulator(CI::ImageAccumulator *this)
{
  CI::Object **v2;
  CI::Object **v3;

  dispatch_sync(*((dispatch_queue_t *)this + 17), &__block_literal_global_40);
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 4));

  v2 = (CI::Object **)*((_QWORD *)this + 8);
  if (v2)
  {
    CI::ImageAccumulator::Content::~Content(v2);
    MEMORY[0x194025AAC]();
  }
  v3 = (CI::Object **)*((_QWORD *)this + 9);
  if (v3)
  {
    CI::ImageAccumulator::Content::~Content(v3);
    MEMORY[0x194025AAC]();
  }

  dispatch_release(*((dispatch_object_t *)this + 17));
}

__n128 CI::ImageAccumulator::sync_content(CI::ImageAccumulator *this)
{
  _QWORD *v2;
  _QWORD *v3;
  __n128 result;
  __int128 v5;

  v2 = (_QWORD *)*((_QWORD *)this + 10);
  v3 = (_QWORD *)*((_QWORD *)this + 8);
  if (v2 == v3)
    v3 = (_QWORD *)*((_QWORD *)this + 9);
  objc_msgSend(*((id *)this + 6), "render:toIOSurface:bounds:colorSpace:", +[CIImage imageWithInternalRepresentation:](CIImage, "imageWithInternalRepresentation:", *v2), v3[1], *((_QWORD *)this + 4), *((double *)this + 13), *((double *)this + 14), *((double *)this + 15), *((double *)this + 16));
  result = *(__n128 *)MEMORY[0x1E0C9D628];
  v5 = *(_OWORD *)(MEMORY[0x1E0C9D628] + 16);
  *(_OWORD *)((char *)this + 104) = *MEMORY[0x1E0C9D628];
  *(_OWORD *)((char *)this + 120) = v5;
  return result;
}

uint64_t CI::ImageAccumulator::get(CI::ImageAccumulator *this, char a2)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD block[6];
  char v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t);
  void (*v11)(uint64_t);
  uint64_t v12;

  v7 = 0;
  v8 = &v7;
  v9 = 0x3052000000;
  v10 = __Block_byref_object_copy__10;
  v11 = __Block_byref_object_dispose__10;
  v12 = 0;
  v2 = *((_QWORD *)this + 17);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN2CI16ImageAccumulator3getEb_block_invoke;
  block[3] = &unk_1E2EC4400;
  block[4] = &v7;
  block[5] = this;
  v6 = a2;
  dispatch_sync(v2, block);
  v3 = v8[5];
  _Block_object_dispose(&v7, 8);
  return v3;
}

void __Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__10(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void CI::ImageAccumulator::set(CI::ImageAccumulator *this, CIImage *a2)
{
  NSObject *v4;
  _QWORD block[7];
  _QWORD v6[5];
  CIImage *v7;

  v6[0] = 0;
  v6[1] = v6;
  v6[2] = 0x3052000000;
  v6[3] = __Block_byref_object_copy__10;
  v6[4] = __Block_byref_object_dispose__10;
  v7 = 0;
  v7 = a2;
  v4 = *((_QWORD *)this + 17);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN2CI16ImageAccumulator3setEP7CIImage_block_invoke;
  block[3] = &unk_1E2EC4428;
  block[5] = v6;
  block[6] = this;
  block[4] = a2;
  dispatch_async(v4, block);
  _Block_object_dispose(v6, 8);
}

void ___ZN2CI16ImageAccumulator3setEP7CIImage_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  CIRenderDestination *v4;
  void *v5;
  void *v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  CGFloat v17;
  CGFloat v18;
  CGFloat v19;
  CGFloat v20;
  CGFloat v21;
  CGFloat v22;
  CGFloat v23;
  CGFloat v24;
  CGRect v25;
  CGRect v26;

  v2 = *(_QWORD *)(a1 + 48);
  if (*(_DWORD *)(v2 + 100) == 1)
  {
    if (!CGRectIsNull(*(CGRect *)(v2 + 104)) && !*(_BYTE *)(v2 + 96))
      CI::ImageAccumulator::sync_content((CI::ImageAccumulator *)v2);
    v3 = *(_QWORD *)(v2 + 64);
    if (*(_QWORD *)(v2 + 80) == v3)
      v3 = *(_QWORD *)(v2 + 72);
    *(_QWORD *)(v2 + 80) = v3;
  }
  v4 = -[CIRenderDestination initWithIOSurface:]([CIRenderDestination alloc], "initWithIOSurface:", *(_QWORD *)(*(_QWORD *)(v2 + 80) + 8));
  -[CIRenderDestination setColorSpace:](v4, "setColorSpace:", *(_QWORD *)(v2 + 32));
  -[CIRenderDestination setBlendKernel:](v4, "setBlendKernel:", *(_QWORD *)(v2 + 56));
  v5 = *(void **)(v2 + 48);
  v6 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
  objc_msgSend(v6, "extent");
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v14 = v13;
  objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), "extent");
  objc_msgSend((id)objc_msgSend(v5, "startTaskToRender:fromRect:toDestination:atPoint:error:", v6, v4, 0, v8, v10, v12, v14, v15, v16), "waitUntilCompletedAndReturnError:", 0);

  *(_BYTE *)(v2 + 96) = 0;
  v17 = *(double *)(v2 + 104);
  v18 = *(double *)(v2 + 112);
  v19 = *(double *)(v2 + 120);
  v20 = *(double *)(v2 + 128);
  objc_msgSend(*(id *)(a1 + 32), "extent");
  v26.origin.x = v21;
  v26.origin.y = v22;
  v26.size.width = v23;
  v26.size.height = v24;
  v25.origin.x = v17;
  v25.origin.y = v18;
  v25.size.width = v19;
  v25.size.height = v20;
  *(CGRect *)(v2 + 104) = CGRectUnion(v25, v26);
  *(_DWORD *)(v2 + 100) = 2;

}

__n128 ___ZN2CI16ImageAccumulator5clearEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  __int128 v3;

  v1 = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v1 + 96) = 1;
  result = *(__n128 *)v1;
  v3 = *(_OWORD *)(v1 + 16);
  *(_OWORD *)(v1 + 104) = *(_OWORD *)v1;
  *(_OWORD *)(v1 + 120) = v3;
  return result;
}

void sub_1922E62CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10A0C407373CF74);
  _Unwind_Resume(a1);
}

double cikernel::_clearer(cikernel *this)
{
  return 0.0;
}

void CI::ImageAccumulator::Content::~Content(CI::Object **this)
{
  CI::Object *v2;
  CI::Object *v3;

  v2 = *this;
  if (v2)
    CI::Object::unref(v2);
  v3 = this[1];
  if (v3)
    CFRelease(v3);
}

uint64_t CGAffineTransformFromObject(uint64_t result, uint64_t a2)
{
  void *v3;
  const char *v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;

  if (!result)
  {
    v5 = MEMORY[0x1E0C9BAA8];
    v6 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
    *(_OWORD *)a2 = *MEMORY[0x1E0C9BAA8];
    *(_OWORD *)(a2 + 16) = v6;
    v7 = *(_OWORD *)(v5 + 32);
LABEL_9:
    *(_OWORD *)(a2 + 32) = v7;
    return result;
  }
  v3 = (void *)result;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v4 = (const char *)objc_msgSend(v3, "objCType");
    if (!strcmp(v4, "{CGAffineTransform=dddddd}"))
      return objc_msgSend(v3, "getValue:size:", a2, 48);
    result = strcmp(v4, "{?=dddddd}");
    if (!(_DWORD)result)
      return objc_msgSend(v3, "getValue:size:", a2, 48);
    return result;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v16 = 0u;
    v17 = 0u;
    v15 = 0u;
    result = objc_msgSend(v3, "transformStruct");
    v8 = v16;
    *(_OWORD *)a2 = v15;
    *(_OWORD *)(a2 + 16) = v8;
    v7 = v17;
    goto LABEL_9;
  }
  objc_opt_class();
  result = objc_opt_isKindOfClass();
  if ((result & 1) != 0)
  {
    result = objc_msgSend(v3, "count");
    if (result == 6)
    {
      objc_msgSend((id)objc_msgSend(v3, "objectAtIndex:", 0), "doubleValue");
      *(_QWORD *)a2 = v9;
      objc_msgSend((id)objc_msgSend(v3, "objectAtIndex:", 1), "doubleValue");
      *(_QWORD *)(a2 + 8) = v10;
      objc_msgSend((id)objc_msgSend(v3, "objectAtIndex:", 2), "doubleValue");
      *(_QWORD *)(a2 + 16) = v11;
      objc_msgSend((id)objc_msgSend(v3, "objectAtIndex:", 3), "doubleValue");
      *(_QWORD *)(a2 + 24) = v12;
      objc_msgSend((id)objc_msgSend(v3, "objectAtIndex:", 4), "doubleValue");
      *(_QWORD *)(a2 + 32) = v13;
      result = objc_msgSend((id)objc_msgSend(v3, "objectAtIndex:", 5), "doubleValue");
      *(_QWORD *)(a2 + 40) = v14;
    }
  }
  return result;
}

void sub_1922EA1E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose(&a33, 8);
  _Unwind_Resume(a1);
}

uint64_t VisionLibrary()
{
  void *v1;
  __int128 v2;
  uint64_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v1 = 0;
  if (!VisionLibraryCore_frameworkLibrary)
  {
    v2 = xmmword_1E2EC44B8;
    v3 = 0;
    VisionLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  if (!VisionLibraryCore_frameworkLibrary)
    VisionLibrary_cold_1(&v1);
  return VisionLibraryCore_frameworkLibrary;
}

void sub_1922EAAC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1922EB4B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1922EB610(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10F1C4010D716A0);
  _Unwind_Resume(a1);
}

void sub_1922EBD84(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10F1C401DCD3065);
  _Unwind_Resume(a1);
}

uint64_t CI::ProcessorImage::format_is_supported(int a1, int a2)
{
  unsigned int v3;
  unint64_t v4;
  uint64_t result;
  unsigned int v6;

  if (a2)
  {
    HIDWORD(v4) = a1 - 274;
    LODWORD(v4) = a1 - 274;
    v3 = v4 >> 8;
    if (v3 < 8 && ((0xBFu >> v3) & 1) != 0)
      return 1;
  }
  result = 1;
  if (a1 > 2052)
  {
    if ((a1 - 2053) <= 3 && a1 != 2055)
      return result;
    v6 = a1 - 2309;
    if (v6 <= 3 && v6 != 2)
      return result;
    return 0;
  }
  if (((a1 - 261) > 5 || ((1 << (a1 - 5)) & 0x23) == 0) && (a1 - 784) >= 2)
    return 0;
  return result;
}

void sub_1922EC198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  _ZZZ136__CIImage_CIImageProcessor__imageWithExtent_processorDescription_argumentDigest_inputFormat_outputFormat_options_roiCallback_processor__EUb_EN13SignpostTimerD1Ev((TimerBase *)va);
  _Unwind_Resume(a1);
}

void _ZZZ136__CIImage_CIImageProcessor__imageWithExtent_processorDescription_argumentDigest_inputFormat_outputFormat_options_roiCallback_processor__EUb_EN13SignpostTimerD1Ev(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  v2 = ci_signpost_log_render();
  v3 = *((_QWORD *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "processor_process", (const char *)&unk_192520C83, v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1922EC24C(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void post_process(void *a1, void *a2, uint64_t a3)
{
  void *v6;
  size_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  unsigned int v11;
  BOOL v12;
  const void *v13;
  const void *v14;
  uint64_t v15;
  unsigned int v16;
  const void *v17;
  _QWORD v18[9];

  if (objc_msgSend(a2, "metalCommandBufferRequested"))
  {
    v6 = (void *)objc_msgSend(a2, "metalCommandBuffer");
    v7 = objc_msgSend(a1, "count");
    if (v7)
    {
      v8 = malloc_type_calloc(8uLL, v7, 0xC0D8C2C5uLL);
      v9 = malloc_type_calloc(8uLL, v7, 0xA96C46DDuLL);
      v10 = 0;
      v11 = 1;
      do
      {
        v8[v10] = objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", v10), "surface");
        v9[v10] = objc_msgSend((id)objc_msgSend(a1, "objectAtIndexedSubscript:", v10), "metalTexture");
        v10 = v11;
        v12 = v7 > v11++;
      }
      while (v12);
    }
    else
    {
      v9 = 0;
      v8 = 0;
    }
    v13 = (const void *)objc_msgSend(a2, "surface");
    v14 = (const void *)objc_msgSend(a2, "metalTexture");
    if (v7)
    {
      v15 = 0;
      v16 = 1;
      do
      {
        RetainSurfaceFromCache((CFTypeRef)v8[v15]);
        v17 = (const void *)v9[v15];
        if (v17)
          CFRetain(v17);
        v15 = v16;
        v12 = v7 > v16++;
      }
      while (v12);
    }
    RetainSurfaceFromCache(v13);
    CFRetain(v14);
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3221225472;
    v18[2] = ___ZL12post_processP7NSArrayIP21CIImageProcessorInputEP22CIImageProcessorOutputPN2CI7ContextE_block_invoke;
    v18[3] = &unk_1E2EC4598;
    v18[6] = v8;
    v18[7] = v9;
    v18[8] = v13;
    v18[4] = v14;
    v18[5] = v7;
    CIMetalCommandBufferAddCompletionHandler(v6, (uint64_t)v18);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a3 + 16))(a3) != 77)
    {
      CIMetalCommandBufferCommit(v6);
      CIMetalCommandBufferWaitUntilScheduled(v6);
    }
  }
}

void _ZZZ136__CIImage_CIImageProcessor__imageWithExtent_processorDescription_argumentDigest_inputFormat_outputFormat_options_roiCallback_processor__EUb_EN13SignpostTimerD1E_0v(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  v2 = ci_signpost_log_render();
  v3 = *((_QWORD *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "processor_postprocess", (const char *)&unk_192520C83, v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1922EC49C(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void digestAdd(CI::XXHashHelper *a1, objc_object *a2, BOOL *a3)
{
  objc_object *v4;
  const char *ClassName;
  CFTypeID v7;
  CFTypeID v8;
  SEL v9;
  const char *v10;
  char *v11;
  NSUInteger v12;
  NSObject *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  size_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t i;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t j;
  objc_object *v43;
  const __CFString *Name;
  int Identifier;
  CI::XXHashHelper *v46;
  size_t v47;
  NSObject *v48;
  NSObject *v50;
  uint32_t v51;
  const __CFData *v52;
  const __CFData *v53;
  char *v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  NSUInteger alignp;
  NSUInteger sizep;
  _BYTE v65[128];
  _BYTE v66[128];
  _BYTE buf[12];
  __int16 v68;
  void *v69;
  uint64_t v70;

  v4 = a2;
  v70 = *MEMORY[0x1E0C80C00];
  ClassName = object_getClassName(a2);
  if ((objc_object *)objc_opt_class() == v4)
  {
LABEL_21:
    *(_QWORD *)buf = ClassName;
    goto LABEL_87;
  }
  while (1)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v10 = "null";
      goto LABEL_86;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v11 = (char *)-[objc_object objCType](v4, "objCType");
      alignp = 0;
      sizep = 0;
      NSGetSizeAndAlignment(v11, &sizep, &alignp);
      if (v11 && (v12 = sizep) != 0)
      {
        if (strchr(v11, 94) || strchr(v11, 42))
        {
          v13 = ci_logger_performance();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "digestAdd";
            v68 = 2082;
            v69 = v11;
            v14 = "%{public}s failed for NSValue object because its encoding %{public}s contains a pointer.";
LABEL_79:
            v50 = v13;
            v51 = 22;
            goto LABEL_80;
          }
        }
        else
        {
          if (!strchr(v11, 64))
          {
            v54 = (char *)malloc_type_calloc(v12, 1uLL, 0x922C3776uLL);
            -[objc_object getValue:size:](v4, "getValue:size:", v54, sizep);
            *(_QWORD *)buf = v11;
            XXH64_update((uint64_t)a1, buf, 8uLL);
            if (v54 && sizep)
              XXH64_update((uint64_t)a1, v54, sizep);
            free(v54);
            return;
          }
          v13 = ci_logger_performance();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "digestAdd";
            v68 = 2082;
            v69 = v11;
            v14 = "%{public}s failed for NSValue object because its encoding %{public}s contains an object.";
            goto LABEL_79;
          }
        }
      }
      else
      {
        v48 = ci_logger_performance();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "digestAdd";
          v14 = "%{public}s failed for NSValue object because it has no type encoding information.";
LABEL_76:
          v50 = v48;
          v51 = 12;
LABEL_80:
          _os_log_impl(&dword_1921E4000, v50, OS_LOG_TYPE_DEFAULT, v14, buf, v51);
          goto LABEL_81;
        }
      }
      goto LABEL_81;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      -[objc_object red](v4, "red");
      *(_QWORD *)buf = v15;
      XXH64_update((uint64_t)a1, buf, 8uLL);
      -[objc_object green](v4, "green");
      *(_QWORD *)buf = v16;
      XXH64_update((uint64_t)a1, buf, 8uLL);
      -[objc_object blue](v4, "blue");
      *(_QWORD *)buf = v17;
      XXH64_update((uint64_t)a1, buf, 8uLL);
      -[objc_object alpha](v4, "alpha");
      *(_QWORD *)buf = v18;
      goto LABEL_87;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v19 = -[objc_object count](v4, "count");
      if (v19)
      {
        v20 = v19;
        v21 = 0;
        v22 = 1;
        do
        {
          -[objc_object valueAtIndex:](v4, "valueAtIndex:", v21);
          *(_QWORD *)buf = v23;
          XXH64_update((uint64_t)a1, buf, 8uLL);
          v21 = v22;
        }
        while (v20 > v22++);
        return;
      }
      v10 = "emptyCIVector";
LABEL_86:
      *(_QWORD *)buf = v10;
LABEL_87:
      v46 = a1;
      v47 = 8;
LABEL_88:
      XXH64_update((uint64_t)v46, buf, v47);
      return;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v25 = -[objc_object _internalRepresentation](v4, "_internalRepresentation");
      if (!v25)
      {
        v10 = "emptyCIImage";
        goto LABEL_86;
      }
      *(_DWORD *)buf = *(_DWORD *)(v25 + 100);
LABEL_67:
      v46 = a1;
      v47 = 4;
      goto LABEL_88;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v26 = -[objc_object length](v4, "length");
      if (!v26 || (v27 = v26, (v28 = (char *)-[objc_object bytes](v4, "bytes")) == 0))
      {
        v10 = "emptyNSData";
        goto LABEL_86;
      }
      goto LABEL_41;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v29 = -[objc_object lengthOfBytesUsingEncoding:](v4, "lengthOfBytesUsingEncoding:", 4);
      if (!v29 || (v27 = v29, (v28 = (char *)-[objc_object UTF8String](v4, "UTF8String")) == 0))
      {
        v10 = "emptyNSString";
        goto LABEL_86;
      }
LABEL_41:
      XXH64_update((uint64_t)a1, v28, v27);
      return;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v30 = -[objc_object count](v4, "count");
      if (v30)
      {
        v31 = v30;
        for (i = 0; i != v31; ++i)
          digestAdd(a1, (objc_object *)-[objc_object objectAtIndex:](v4, "objectAtIndex:", i), a3);
        return;
      }
      v10 = "emptyNSArray";
      goto LABEL_86;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
      break;
    v7 = CFGetTypeID(v4);
    if (v7 == CGColorSpaceGetTypeID())
    {
      Name = CGColorSpaceGetName((CGColorSpaceRef)v4);
      if (Name)
      {
        CI::XXHashHelper::add(a1, Name);
        return;
      }
      v52 = CGColorSpaceCopyICCData((CGColorSpaceRef)v4);
      if (v52)
      {
        v53 = v52;
        CI::XXHashHelper::add(a1, v52);
        CFRelease(v53);
        return;
      }
      goto LABEL_81;
    }
    v8 = CFGetTypeID(v4);
    if (v8 == CGImageGetTypeID())
    {
      Identifier = CGImageGetIdentifier();
      if (!Identifier)
        return;
      *(_DWORD *)buf = Identifier;
      goto LABEL_67;
    }
    if (-[objc_object conformsToProtocol:](v4, "conformsToProtocol:", &unk_1EE2AB4D0))
    {
      *(_QWORD *)buf = -[objc_object uniqueIdentifier](v4, "uniqueIdentifier");
      goto LABEL_87;
    }
    NSClassFromString(CFSTR("MLModel"));
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v9 = NSSelectorFromString(CFSTR("CIImageProcessorDigestObject"));
        if ((objc_opt_respondsToSelector() & 1) != 0)
        {
          v4 = (objc_object *)-[objc_object performSelector:](v4, "performSelector:", v9);
          if (v4)
            goto LABEL_20;
        }
        v13 = ci_logger_performance();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          goto LABEL_78;
      }
      else
      {
        v13 = ci_logger_performance();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
LABEL_78:
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "digestAdd";
          v68 = 2082;
          v69 = (void *)ClassName;
          v14 = "%{public}s failed for %{public}s object.";
          goto LABEL_79;
        }
      }
LABEL_81:
      *a3 = 1;
      return;
    }
    v4 = (objc_object *)-[objc_object valueForKeyPath:](v4, "valueForKeyPath:", CFSTR("configuration.rootModelURL.absoluteString"));
    if (!v4)
    {
      v48 = ci_logger_performance();
      if (!os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
        goto LABEL_81;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "digestAdd";
      v14 = "%{public}s failed forMLModel object because it doesnt have a root URL.";
      goto LABEL_76;
    }
LABEL_20:
    ClassName = object_getClassName(v4);
    if ((objc_object *)objc_opt_class() == v4)
      goto LABEL_21;
  }
  if (!-[objc_object count](v4, "count"))
  {
    v10 = "emptyNSDictionary";
    goto LABEL_86;
  }
  v33 = (void *)-[objc_object allKeys](v4, "allKeys");
  v59 = 0u;
  v60 = 0u;
  v61 = 0u;
  v62 = 0u;
  v34 = objc_msgSend(v33, "countByEnumeratingWithState:objects:count:", &v59, v66, 16);
  if (v34)
  {
    v35 = v34;
    v36 = *(_QWORD *)v60;
LABEL_49:
    v37 = 0;
    while (1)
    {
      if (*(_QWORD *)v60 != v36)
        objc_enumerationMutation(v33);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_81;
      if (v35 == ++v37)
      {
        v35 = objc_msgSend(v33, "countByEnumeratingWithState:objects:count:", &v59, v66, 16);
        if (v35)
          goto LABEL_49;
        break;
      }
    }
  }
  v38 = (void *)objc_msgSend(v33, "sortedArrayUsingSelector:", sel_compare_);
  v55 = 0u;
  v56 = 0u;
  v57 = 0u;
  v58 = 0u;
  v39 = objc_msgSend(v38, "countByEnumeratingWithState:objects:count:", &v55, v65, 16);
  if (v39)
  {
    v40 = v39;
    v41 = *(_QWORD *)v56;
    do
    {
      for (j = 0; j != v40; ++j)
      {
        if (*(_QWORD *)v56 != v41)
          objc_enumerationMutation(v38);
        v43 = *(objc_object **)(*((_QWORD *)&v55 + 1) + 8 * j);
        digestAdd(a1, v43, a3);
        digestAdd(a1, (objc_object *)-[objc_object objectForKey:](v4, "objectForKey:", v43), a3);
      }
      v40 = objc_msgSend(v38, "countByEnumeratingWithState:objects:count:", &v55, v65, 16);
    }
    while (v40);
  }
}

void sub_1922ED7EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10A0C401BD4BA38);
  _Unwind_Resume(a1);
}

void sub_1922ED9E0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1922EE520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char *__p,uint64_t a33,uint64_t a34,char a35)
{
  uint64_t v35;

  _ZZZ65__CIImageProcessorKernel_applyWithExtent_inputs_arguments_error__EUb0_EN13SignpostTimerD1E_0v((TimerBase *)(v35 - 208));
  __p = &a35;
  std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void _ZZZ65__CIImageProcessorKernel_applyWithExtent_inputs_arguments_error__EUb0_EN13SignpostTimerD1Ev(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  v2 = ci_signpost_log_render();
  v3 = *((_QWORD *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "processor_process", (const char *)&unk_192520C83, v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1922EE630(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void _ZZZ65__CIImageProcessorKernel_applyWithExtent_inputs_arguments_error__EUb0_EN13SignpostTimerD1E_0v(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  v2 = ci_signpost_log_render();
  v3 = *((_QWORD *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "processor_postprocess", (const char *)&unk_192520C83, v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1922EE6CC(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

char *std::vector<CGRect>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 59)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void ___ZL12post_processP7NSArrayIP21CIImageProcessorInputEP22CIImageProcessorOutputPN2CI7ContextE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  const void *v4;
  void *v6;
  void *v7;

  if (*(_QWORD *)(a1 + 40))
  {
    v2 = 0;
    v3 = 1;
    do
    {
      ReturnSurfaceToCache(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v2));
      v4 = *(const void **)(*(_QWORD *)(a1 + 56) + 8 * v2);
      if (v4)
        CFRelease(v4);
      v2 = v3;
    }
    while (*(_QWORD *)(a1 + 40) > (unint64_t)v3++);
  }
  v6 = *(void **)(a1 + 48);
  if (v6)
    free(v6);
  v7 = *(void **)(a1 + 56);
  if (v7)
    free(v7);
  ReturnSurfaceToCache(*(_QWORD *)(a1 + 64));
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

_QWORD *std::vector<std::vector<CGRect>>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;
  size_t v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<CI::SWRendererFunctionInputNode>::__vallocate[abi:nn180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_1922EFB94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41)
{
  uint64_t v41;

  *(_QWORD *)(v41 - 176) = v41 - 144;
  std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100]((void ***)(v41 - 176));
  _Unwind_Resume(a1);
}

void CI::Tileable::TileRectGridMakeEqualSizedTilesWithImageSize(unint64_t this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  int v17;
  unint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;

  v9 = this + a3 - 1;
  v10 = v9 / this;
  std::vector<std::vector<CGRect>>::vector(a5, v9 / this);
  if (v9 >= this)
  {
    v11 = 0;
    v12 = a2 + a4 - 1;
    if (v12 / a2 <= 1)
      v13 = 1;
    else
      v13 = v12 / a2;
    v20 = v13;
    if (v10 <= 1)
      v10 = 1;
    do
    {
      std::vector<std::vector<CGRect>>::vector(&v21, v12 / a2);
      v14 = *a5;
      v15 = *a5 + 24 * v11;
      v16 = *(void **)v15;
      if (*(_QWORD *)v15)
      {
        *(_QWORD *)(v14 + 24 * v11 + 8) = v16;
        operator delete(v16);
        *(_QWORD *)v15 = 0;
        *(_QWORD *)(v15 + 8) = 0;
        *(_QWORD *)(v15 + 16) = 0;
      }
      *(_OWORD *)v15 = v21;
      *(_QWORD *)(v14 + 24 * v11 + 16) = v22;
      if (v12 >= a2)
      {
        v17 = 0;
        v18 = (unint64_t *)(*(_QWORD *)(*a5 + 24 * v11) + 8);
        v19 = v20;
        do
        {
          *((_DWORD *)v18 - 2) = v11 * this;
          *((_DWORD *)v18 - 1) = v17;
          v17 += a2;
          *v18 = this;
          v18[1] = a2;
          v18 += 3;
          --v19;
        }
        while (v19);
      }
      ++v11;
    }
    while (v11 != v10);
  }
}

void sub_1922EFDE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100]((void ***)va);
  _Unwind_Resume(a1);
}

void CI::Tileable::TileRectGridMakeFromWidthAndHeightArrays(uint64_t *a1@<X0>, int **a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6;
  int v7;
  int *v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  _QWORD *v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  __int128 v21;
  uint64_t v22;

  std::vector<std::vector<CGRect>>::vector(a3, (a1[1] - *a1) >> 3);
  if (a1[1] != *a1)
  {
    v6 = 0;
    v7 = 0;
    v9 = *a2;
    v8 = a2[1];
    do
    {
      std::vector<std::vector<CGRect>>::vector(&v21, ((char *)v8 - (char *)v9) >> 3);
      v10 = *a3;
      v11 = *a3 + 24 * v6;
      v12 = *(void **)v11;
      if (*(_QWORD *)v11)
      {
        *(_QWORD *)(v10 + 24 * v6 + 8) = v12;
        operator delete(v12);
        *(_QWORD *)v11 = 0;
        *(_QWORD *)(v11 + 8) = 0;
        *(_QWORD *)(v11 + 16) = 0;
      }
      *(_OWORD *)v11 = v21;
      *(_QWORD *)(v10 + 24 * v6 + 16) = v22;
      v9 = *a2;
      v8 = a2[1];
      v13 = *a1;
      if (v8 != *a2)
      {
        v14 = 0;
        v15 = ((char *)v8 - (char *)*a2) >> 3;
        if (v15 <= 1)
          v15 = 1;
        v16 = (_QWORD *)(*(_QWORD *)(*a3 + 24 * v6) + 8);
        v17 = *a2;
        do
        {
          v18 = *(_QWORD *)(v13 + 8 * v6);
          v19 = *(_QWORD *)v17;
          *((_DWORD *)v16 - 2) = v7;
          *((_DWORD *)v16 - 1) = v14;
          *v16 = v18;
          v16[1] = v19;
          v16 += 3;
          v20 = *v17;
          v17 += 2;
          v14 += v20;
          --v15;
        }
        while (v15);
      }
      v7 += *(_QWORD *)(v13 + 8 * v6++);
    }
    while (v6 < (a1[1] - v13) >> 3);
  }
}

void sub_1922EFF24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t getContentDigestFromOptions(NSDictionary *a1, NSString *a2)
{
  id v2;
  uint64_t v3;
  uint64_t v4;
  size_t v5;
  char *p_src;
  NSObject *v8;
  NSObject *v9;
  int64x2_t v10[5];
  uint64_t __src;

  v2 = -[NSDictionary objectForKey:](a1, "objectForKey:", a2);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    if ((unint64_t)objc_msgSend(v2, "length") >= 0x10)
    {
      XXH64_reset(v10, 0);
      v3 = objc_msgSend(v2, "bytes");
      v4 = objc_msgSend(v2, "length");
      if (!v3)
        return XXH64_digest((uint64_t)v10);
      v5 = v4;
      if (!v4)
        return XXH64_digest((uint64_t)v10);
      p_src = (char *)v3;
LABEL_13:
      XXH64_update((uint64_t)v10, p_src, v5);
      return XXH64_digest((uint64_t)v10);
    }
    v8 = ci_logger_api();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      getContentDigestFromOptions();
  }
  else
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
      return objc_msgSend(v2, "unsignedLongLongValue");
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      if ((unint64_t)objc_msgSend(v2, "length") >= 0x10)
      {
        XXH64_reset(v10, 0);
        __src = objc_msgSend(v2, "UTF8String");
        p_src = (char *)&__src;
        v5 = 8;
        goto LABEL_13;
      }
      v9 = ci_logger_api();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        getContentDigestFromOptions();
    }
  }
  return 0;
}

void sub_1922F00E0(void *a1)
{
  objc_begin_catch(a1);
  objc_end_catch();
}

void ___ZL18max_safe_tile_sizev_block_invoke()
{
  unint64_t v0;
  uint64_t v1;
  id v2;

  v2 = MTLCreateSystemDefaultDevice();
  v0 = objc_msgSend(v2, "maxTextureWidth2D");
  if (v0 >= objc_msgSend(v2, "maxTextureHeight2D"))
    v1 = objc_msgSend(v2, "maxTextureHeight2D");
  else
    v1 = objc_msgSend(v2, "maxTextureWidth2D");
  max_safe_tile_size(void)::max_size = v1;

}

void std::vector<std::vector<IRect>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::vector<IRect>>::__clear[abi:nn180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

_QWORD *std::vector<std::vector<IRect>>::__init_with_size[abi:nn180100]<std::vector<IRect>*,std::vector<IRect>*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<CI::SWRendererFunctionInputNode>::__vallocate[abi:nn180100](result, a4);
    return std::vector<std::vector<IRect>>::__construct_at_end<std::vector<IRect>*,std::vector<IRect>*>(v6, a2, a3);
  }
  return result;
}

_QWORD *std::vector<std::vector<IRect>>::__construct_at_end<std::vector<IRect>*,std::vector<IRect>*>(_QWORD *result, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v7;

  v3 = result;
  v4 = result[1];
  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      result = std::vector<IRect>::vector((_QWORD *)(v4 + v7), a2 + v7);
      v7 += 24;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  v3[1] = v4;
  return result;
}

void sub_1922F023C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

_QWORD *std::vector<IRect>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  int64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    std::vector<CI::SWRendererFunctionInputNode>::__vallocate[abi:nn180100](a1, 0xAAAAAAAAAAAAAAABLL * (v5 >> 3));
    v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

__n64 cikernel::_yccCombiner(double a1, float a2)
{
  __n64 result;

  result.n64_f32[1] = a2;
  return result;
}

float addPixel<float>(float *a1, float *a2)
{
  float v2;
  float v3;
  float result;

  if (a2)
  {
    v2 = a1[1];
    *a1 = *a2 + *a1;
    a1[1] = a2[1] + v2;
    v3 = a1[3];
    a1[2] = a2[2] + a1[2];
    result = a2[3] + v3;
    a1[3] = result;
  }
  return result;
}

void OUTLINED_FUNCTION_1_5(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

BOOL ClipSegmentToHalfplane(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float *a9, float *a10, float *a11, float *a12)
{
  float v12;
  float v13;
  _BOOL8 v14;
  float v15;
  float v16;

  v12 = (float)((float)(a2 - a6) * a8) + (float)((float)(a1 - a5) * a7);
  v13 = (float)((float)(a4 - a6) * a8) + (float)((float)(a3 - a5) * a7);
  v14 = v13 > 0.0 || v12 > 0.0;
  if (v14)
  {
    if (v12 <= 0.0 || v13 <= 0.0)
    {
      if (v12 <= 0.0)
      {
        v16 = v13 / (float)(v13 - v12);
        a1 = a3 + (float)((float)(a1 - a3) * v16);
        a2 = a4 + (float)((float)(a2 - a4) * v16);
      }
      else
      {
        v15 = v12 / (float)(v12 - v13);
        a3 = a1 + (float)((float)(a3 - a1) * v15);
        a4 = a2 + (float)((float)(a4 - a2) * v15);
      }
    }
    *a9 = a1;
    *a10 = a2;
    *a11 = a3;
    *a12 = a4;
  }
  return v14;
}

float32x2_t cikernel::_kaleida(CI *a1, float32x4_t a2, int8x16_t a3, int8x16_t a4)
{
  float v4;
  float32x2_t v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  BOOL v13;
  float v14;
  float32x2_t v15;
  int32x2_t v16;
  int32x2_t v17;

  v4 = a2.f32[2];
  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a2.f32);
  v6 = vaddv_f32(vmul_f32(*(float32x2_t *)a3.i8, v5));
  v7 = fabsf(vaddv_f32(vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5)));
  v8 = floor(vmuls_lane_f32(atan2f(v7, v6), a2, 3) + 0.5) * (float)-v4;
  v9 = 3.1416 - v8;
  if (v8 <= 1.5708)
    v9 = v8;
  if (v9 < -1.5708)
    v9 = -3.1416 - v9;
  v10 = v9 * (float)(v9 * v9);
  v11 = v9
      + v10 / -6.0
      + (float)(v9 * (float)(v9 * v10)) / 120.0
      + (float)(v9 * (float)(v9 * (float)(v9 * (float)(v9 * v10)))) / -5040.0
      + (float)(v9 * (float)(v9 * (float)(v9 * (float)(v9 * (float)(v9 * (float)(v9 * v10)))))) / 362880.0;
  v12 = fabsf(v8);
  v13 = v12 <= 1.5708;
  if (v12 > 1.5708)
    v12 = 3.1416 - v12;
  v14 = ((((float)(v12 * v12) * 0.0000248015873 + -0.00138888889) * (float)(v12 * v12) + 0.0416666667)
       * (float)(v12 * v12)
       + -0.5)
      * (float)(v12 * v12)
      + 1.0;
  if (!v13)
    v14 = -v14;
  v15.f32[0] = (float)(v6 * v14) - (float)(v7 * v11);
  v15.i32[1] = fabsf((float)(v7 * v14) + (float)(v6 * v11));
  v16 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v15);
  v17 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v15);
  return vadd_f32(*(float32x2_t *)a2.f32, vadd_f32((float32x2_t)vzip1_s32(v16, v17), (float32x2_t)vzip2_s32(v16, v17)));
}

void CI::f2_f4_f4_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, __n128);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __n128 *v20;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_DWORD *)(v10 + 64);
  v17 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v15);
  v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)(a3 + 16 * a7) = v11(a1, *v20, *v19, *v18);
}

_QWORD *CIKernelError(_QWORD *result, unsigned int a2, NSString *a3, ...)
{
  _QWORD *v4;
  const __CFString *v5;
  _QWORD v6[2];
  va_list va;

  va_start(va, a3);
  v6[1] = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v4 = result;
    v5 = CFSTR("CINonLocalizedDescriptionKey");
    v6[0] = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:arguments:", a3, va);
    result = (_QWORD *)objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", CFSTR("CIKernel"), a2, objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v6, &v5, 1));
    *v4 = result;
  }
  return result;
}

void std::vector<CI::KernelArgumentType>::push_back[abi:nn180100](uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  unint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  int v16;

  v4 = a1 + 16;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_DWORD **)(a1 + 8);
  if ((unint64_t)v6 >= v5)
  {
    v8 = *(_DWORD **)a1;
    v9 = ((uint64_t)v6 - *(_QWORD *)a1) >> 2;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62)
      abort();
    v11 = v5 - (_QWORD)v8;
    if (v11 >> 1 > v10)
      v10 = v11 >> 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>(v4, v12);
      v8 = *(_DWORD **)a1;
      v6 = *(_DWORD **)(a1 + 8);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[4 * v9];
    v15 = &v13[4 * v12];
    *(_DWORD *)v14 = *a2;
    v7 = v14 + 4;
    while (v6 != v8)
    {
      v16 = *--v6;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(_QWORD *)a1 = v14;
    *(_QWORD *)(a1 + 8) = v7;
    *(_QWORD *)(a1 + 16) = v15;
    if (v8)
      operator delete(v8);
  }
  else
  {
    *v6 = *a2;
    v7 = v6 + 1;
  }
  *(_QWORD *)(a1 + 8) = v7;
}

uint64_t CIKernelReflection::reflect(CIKernelReflection *this, CIKernelLibrary *a2, char *a3, NSError **a4)
{
  id *p_var7;
  char **p_var2;
  void *v8;
  void *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  const char *v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  void *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  char *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  char *v48;
  uint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  char *v65;
  uint64_t *v66;
  uint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t *v76;
  uint64_t *v77;
  char *v78;
  char *v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  char *v85;
  uint64_t v86;
  char *v87;
  uint64_t v88;
  char *v89;
  char *v90;
  char *v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  char *v96;
  uint64_t *v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t v100;
  char *v101;
  uint64_t v102;
  void *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t i;
  void *v108;
  uint64_t v109;
  uint64_t v110;
  char *v111;
  char *v112;
  char *v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  char *v118;
  uint64_t *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  char *v123;
  char *v124;
  char *v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  unint64_t v129;
  char *v130;
  uint64_t *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t *v135;
  uint64_t *v136;
  uint64_t v137;
  unint64_t v138;
  unint64_t v139;
  char *v140;
  uint64_t *v141;
  char *v142;
  char *v143;
  uint64_t v144;
  char *v145;
  char *v146;
  std::vector<std::string>::size_type v147;
  vector<std::string, std::allocator<std::string>> *p_var6;
  vector<CI::KernelArgumentType, std::allocator<CI::KernelArgumentType>> *p_var5;
  uint64_t v150;
  int **p_var1;
  __compressed_pair<CI::KernelArgumentType *, std::allocator<CI::KernelArgumentType>> *v152;
  uint64_t v153;
  std::string *v154;
  std::string *v155;
  uint64_t v156;
  int *v157;
  int v158;
  int *v159;
  int *v160;
  int *v161;
  int *v162;
  int *v163;
  int *v164;
  int *v165;
  uint64_t v166;
  int *v167;
  int *v168;
  int *var0;
  uint64_t v170;
  unint64_t v171;
  uint64_t v172;
  unint64_t v173;
  char *v174;
  int *v175;
  int *v176;
  int v177;
  uint64_t v178;
  unint64_t v179;
  uint64_t v180;
  uint64_t v181;
  int *v182;
  int *v183;
  uint64_t v184;
  unint64_t v185;
  uint64_t v186;
  int *v187;
  int *v188;
  uint64_t v189;
  unint64_t v190;
  uint64_t v191;
  uint64_t v192;
  unint64_t v193;
  uint64_t v194;
  uint64_t v195;
  unint64_t v196;
  uint64_t v197;
  uint64_t v198;
  unint64_t v199;
  uint64_t v200;
  int *v201;
  uint64_t v202;
  unint64_t v203;
  uint64_t v204;
  unint64_t v205;
  char *v206;
  uint64_t v207;
  unint64_t v208;
  uint64_t v209;
  uint64_t v210;
  unint64_t v211;
  uint64_t v212;
  uint64_t v213;
  unint64_t v214;
  uint64_t v215;
  uint64_t v216;
  unint64_t v217;
  uint64_t v218;
  uint64_t v219;
  unint64_t v220;
  uint64_t v221;
  uint64_t v222;
  unint64_t v223;
  uint64_t v224;
  uint64_t v225;
  unint64_t v226;
  uint64_t v227;
  uint64_t v228;
  unint64_t v229;
  uint64_t v230;
  uint64_t v231;
  unint64_t v232;
  uint64_t v233;
  uint64_t v234;
  unint64_t v235;
  uint64_t v236;
  int *v237;
  uint64_t v238;
  unint64_t v239;
  uint64_t v240;
  unint64_t v241;
  char *v242;
  int *v243;
  int v244;
  int *v245;
  int v246;
  int *v247;
  uint64_t v248;
  unint64_t v249;
  uint64_t v250;
  unint64_t v251;
  char *v252;
  int *v253;
  uint64_t v254;
  unint64_t v255;
  uint64_t v256;
  unint64_t v257;
  char *v258;
  uint64_t v259;
  unint64_t v260;
  uint64_t v261;
  int *v262;
  uint64_t v263;
  unint64_t v264;
  uint64_t v265;
  unint64_t v266;
  char *v267;
  uint64_t v268;
  unint64_t v269;
  uint64_t v270;
  int *v271;
  uint64_t v272;
  unint64_t v273;
  uint64_t v274;
  unint64_t v275;
  char *v276;
  uint64_t v277;
  unint64_t v278;
  uint64_t v279;
  int *v280;
  int *v281;
  int v282;
  int v283;
  int v284;
  int v285;
  int v286;
  int v287;
  int v288;
  int *v289;
  int v290;
  int v291;
  int v292;
  int v293;
  int v294;
  int v295;
  int v296;
  int v297;
  int v298;
  int v299;
  int v300;
  int *v301;
  int v302;
  int *v303;
  int *v304;
  uint64_t v305;
  unint64_t v306;
  uint64_t v307;
  unint64_t v308;
  char *v309;
  int *v310;
  int v311;
  uint64_t v312;
  unint64_t v313;
  uint64_t v314;
  int *v315;
  uint64_t v316;
  unint64_t v317;
  uint64_t v318;
  unint64_t v319;
  char *v320;
  int *v321;
  uint64_t v322;
  unint64_t v323;
  uint64_t v324;
  unint64_t v325;
  char *v326;
  uint64_t v327;
  unint64_t v328;
  uint64_t v329;
  uint64_t v330;
  unint64_t v331;
  uint64_t v332;
  uint64_t v333;
  unint64_t v334;
  uint64_t v335;
  int *v336;
  int *v337;
  int v338;
  int *v339;
  int v340;
  uint64_t v341;
  int v342;
  int *v343;
  int v344;
  int v345;
  int *v346;
  int v347;
  int v348;
  int v349;
  int *v350;
  int v351;
  uint64_t v352;
  unint64_t v353;
  uint64_t v354;
  int *v355;
  int v356;
  int v357;
  int v358;
  int v359;
  uint64_t v360;
  unint64_t v361;
  uint64_t v362;
  int v363;
  char *v364;
  char *v365;
  char *v366;
  __int128 v367;
  unint64_t v368;
  unint64_t v369;
  unint64_t v370;
  unint64_t v371;
  char *v372;
  char *v373;
  __int128 v374;
  char *v375;
  char *v376;
  char *v377;
  __int128 v378;
  int64x2_t v379;
  void *v380;
  std::string *v381;
  int v382;
  int v383;
  NSObject *v384;
  std::string *v385;
  char v386;
  unsigned int var1;
  char v388;
  uint64_t v389;
  NSObject *v390;
  int v391;
  uint64_t v392;
  NSObject *v393;
  NSObject *v395;
  NSObject *v396;
  NSObject *v397;
  NSObject *v398;
  NSObject *v399;
  uint64_t v400;
  void *v401;
  NSError **v402;
  std::string **v403;
  uint64_t v404;
  std::vector<std::string>::size_type v405;
  id obj;
  char obja;
  uint64_t v408;
  uint64_t v409;
  void *v410[2];
  uint64_t v411;
  __int128 v412;
  __int128 v413;
  __int128 v414;
  __int128 v415;
  void *v416;
  char *v417;
  char *v418;
  void *v419;
  uint64_t *v420;
  char *v421;
  void *__p;
  char *v423;
  char *v424;
  _BYTE v425[128];
  std::__split_buffer<std::string> v426;
  uint64_t v427;

  v427 = *MEMORY[0x1E0C80C00];
  this->var7 = a2;
  p_var7 = &this->var7;
  this->var2 = a3;
  p_var2 = &this->var2;
  this->var4 = (char *)-[NSString UTF8String](-[CIKernelLibrary mtl_source](a2, "mtl_source"), "UTF8String");
  v403 = (std::string **)p_var2;
  v8 = (void *)objc_msgSend(*p_var7, "functionWithName:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", *p_var2));
  if (!v8)
  {
    v12 = objc_msgSend(*p_var7, "functionCount");
    v13 = "";
    if (!v12)
      v13 = "Check if Metal library is linked with -cikernel option.";
    CIKernelError(a4, 1u, CFSTR("Function does not exist in library data. %s"), v13);
    v14 = ci_logger_api();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      CIKernelReflection::reflect();
    v15 = ci_logger_api();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      CIKernelReflection::reflect(p_var7, v15);
    return 0;
  }
  v9 = v8;
  v402 = a4;
  v10 = objc_msgSend((id)objc_msgSend(v8, "returnType"), "dataType");
  v11 = 0;
  if (v10 <= 5)
  {
    if (v10)
    {
      if (v10 != 4)
        goto LABEL_837;
      v11 = 1;
    }
  }
  else
  {
    switch(v10)
    {
      case 6:
        v11 = 2;
        break;
      case 19:
        v11 = 3;
        break;
      case 61:
        break;
      default:
LABEL_837:
        CIKernelError(a4, 2u, CFSTR("Function does not return a supported type, which must be float2 (for CIWarpKernels)or float4 or half4 (for all other kernels)."));
        v393 = ci_logger_api();
        if (os_log_type_enabled(v393, OS_LOG_TYPE_ERROR))
          CIKernelReflection::reflect();
        return 0;
    }
  }
  this->var1 = v11;
  this->var12 = objc_msgSend(v9, "functionType") == 5;
  __p = 0;
  v423 = 0;
  v424 = 0;
  v419 = 0;
  v420 = 0;
  v421 = 0;
  v416 = 0;
  v417 = 0;
  v418 = 0;
  v16 = objc_msgSend((id)objc_msgSend(v9, "arguments"), "count");
  if (v16)
  {
    v17 = 0;
    v18 = &v424;
    do
    {
      v19 = (void *)objc_msgSend((id)objc_msgSend(v9, "arguments"), "objectAtIndexedSubscript:", v17);
      v20 = objc_msgSend(v19, "type");
      if (this->var12 && objc_msgSend((id)objc_msgSend(v19, "dataTypeDescription"), "dataType") == 1)
      {
        v21 = (void *)objc_msgSend(v19, "dataTypeDescription");
        if ((objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:", CFSTR("coreimage::priv::destination")) & 1) == 0
          && (objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:", CFSTR("coreimage::priv::destination_h")) & 1) == 0&& (objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:", CFSTR("coreimage::priv::Destination")) & 1) == 0&& (objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:", CFSTR("coreimage::priv::Destination_h")) & 1) == 0&& (objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:", CFSTR("coreimage::group::destination")) & 1) == 0&& (objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:", CFSTR("coreimage::group::destination_h")) & 1) == 0&& (objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:",
                CFSTR("coreimage::group::Destination")) & 1) == 0
          && !objc_msgSend((id)objc_msgSend(v21, "typeName"), "isEqualToString:", CFSTR("coreimage::group::Destination_h")))
        {
          v103 = (void *)objc_msgSend(v21, "members");
          v414 = 0u;
          v415 = 0u;
          v412 = 0u;
          v413 = 0u;
          obj = v103;
          v104 = objc_msgSend(v103, "countByEnumeratingWithState:objects:count:", &v412, v425, 16);
          if (v104)
          {
            v105 = 0;
            v106 = *(_QWORD *)v413;
            v400 = v16;
            v401 = v9;
            v404 = (uint64_t)v18;
            do
            {
              for (i = 0; i != v104; ++i)
              {
                if (*(_QWORD *)v413 != v106)
                  objc_enumerationMutation(obj);
                v108 = *(void **)(*((_QWORD *)&v412 + 1) + 8 * i);
                v109 = objc_msgSend(v108, "dataType");
                v110 = v109;
                v111 = v423;
                if (v423 >= v424)
                {
                  v113 = (char *)__p;
                  v114 = (v423 - (_BYTE *)__p) >> 3;
                  v115 = v114 + 1;
                  if ((unint64_t)(v114 + 1) >> 61)
                    abort();
                  v116 = v424 - (_BYTE *)__p;
                  if ((v424 - (_BYTE *)__p) >> 2 > v115)
                    v115 = v116 >> 2;
                  if ((unint64_t)v116 >= 0x7FFFFFFFFFFFFFF8)
                    v117 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v117 = v115;
                  if (v117)
                  {
                    v118 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v404, v117);
                    v113 = (char *)__p;
                    v111 = v423;
                  }
                  else
                  {
                    v118 = 0;
                  }
                  v119 = (uint64_t *)&v118[8 * v114];
                  *v119 = v110;
                  v112 = (char *)(v119 + 1);
                  while (v111 != v113)
                  {
                    v120 = *((_QWORD *)v111 - 1);
                    v111 -= 8;
                    *--v119 = v120;
                  }
                  __p = v119;
                  v423 = v112;
                  v424 = &v118[8 * v117];
                  if (v113)
                    operator delete(v113);
                }
                else
                {
                  *(_QWORD *)v423 = v109;
                  v112 = v111 + 8;
                }
                v423 = v112;
                v121 = objc_msgSend(v108, "dataType");
                v122 = v121;
                v123 = v417;
                if (v417 >= v418)
                {
                  v125 = (char *)v416;
                  v126 = (v417 - (_BYTE *)v416) >> 3;
                  v127 = v126 + 1;
                  if ((unint64_t)(v126 + 1) >> 61)
                    abort();
                  v128 = v418 - (_BYTE *)v416;
                  if ((v418 - (_BYTE *)v416) >> 2 > v127)
                    v127 = v128 >> 2;
                  if ((unint64_t)v128 >= 0x7FFFFFFFFFFFFFF8)
                    v129 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v129 = v127;
                  if (v129)
                  {
                    v130 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v418, v129);
                    v125 = (char *)v416;
                    v123 = v417;
                  }
                  else
                  {
                    v130 = 0;
                  }
                  v131 = (uint64_t *)&v130[8 * v126];
                  *v131 = v122;
                  v124 = (char *)(v131 + 1);
                  while (v123 != v125)
                  {
                    v132 = *((_QWORD *)v123 - 1);
                    v123 -= 8;
                    *--v131 = v132;
                  }
                  v416 = v131;
                  v417 = v124;
                  v418 = &v130[8 * v129];
                  if (v125)
                    operator delete(v125);
                }
                else
                {
                  *(_QWORD *)v417 = v121;
                  v124 = v123 + 8;
                }
                v417 = v124;
                v133 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(v19, "name"), "stringByAppendingString:", CFSTR(".coerce")), "stringByAppendingFormat:", CFSTR("%i"), v105);
                v134 = v133;
                v135 = v420;
                if (v420 >= (uint64_t *)v421)
                {
                  v137 = ((char *)v420 - (_BYTE *)v419) >> 3;
                  if ((unint64_t)(v137 + 1) >> 61)
                    abort();
                  v138 = (v421 - (_BYTE *)v419) >> 2;
                  if (v138 <= v137 + 1)
                    v138 = v137 + 1;
                  if ((unint64_t)(v421 - (_BYTE *)v419) >= 0x7FFFFFFFFFFFFFF8)
                    v139 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v139 = v138;
                  if (v139)
                    v140 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v421, v139);
                  else
                    v140 = 0;
                  v141 = (uint64_t *)&v140[8 * v137];
                  *v141 = v134;
                  v136 = v141 + 1;
                  v143 = (char *)v419;
                  v142 = (char *)v420;
                  if (v420 != v419)
                  {
                    do
                    {
                      v144 = *((_QWORD *)v142 - 1);
                      v142 -= 8;
                      *--v141 = v144;
                    }
                    while (v142 != v143);
                    v142 = (char *)v419;
                  }
                  v419 = v141;
                  v420 = v136;
                  v421 = &v140[8 * v139];
                  if (v142)
                    operator delete(v142);
                }
                else
                {
                  *v420 = v133;
                  v136 = v135 + 1;
                }
                v105 = (v105 + 1);
                v420 = v136;
              }
              v104 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v412, v425, 16);
              v16 = v400;
              v9 = v401;
              v18 = (_QWORD *)v404;
            }
            while (v104);
          }
          goto LABEL_170;
        }
        v22 = v423;
        if (v423 >= v424)
        {
          v42 = (char *)__p;
          v43 = (v423 - (_BYTE *)__p) >> 3;
          v44 = v43 + 1;
          if ((unint64_t)(v43 + 1) >> 61)
            abort();
          v45 = v424 - (_BYTE *)__p;
          if ((v424 - (_BYTE *)__p) >> 2 > v44)
            v44 = v45 >> 2;
          if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8)
            v46 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v46 = v44;
          if (v46)
          {
            v47 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)v18, v46);
            v42 = (char *)__p;
            v22 = v423;
          }
          else
          {
            v47 = 0;
          }
          v87 = &v47[8 * v43];
          *(_QWORD *)v87 = 1;
          v23 = v87 + 8;
          while (v22 != v42)
          {
            v88 = *((_QWORD *)v22 - 1);
            v22 -= 8;
            *((_QWORD *)v87 - 1) = v88;
            v87 -= 8;
          }
          __p = v87;
          v423 = v23;
          v424 = &v47[8 * v46];
          if (v42)
            operator delete(v42);
        }
        else
        {
          *(_QWORD *)v423 = 1;
          v23 = v22 + 8;
        }
        v423 = v23;
        v89 = v417;
        if (v417 >= v418)
        {
          v91 = (char *)v416;
          v92 = (v417 - (_BYTE *)v416) >> 3;
          v93 = v92 + 1;
          if ((unint64_t)(v92 + 1) >> 61)
            abort();
          v94 = v418 - (_BYTE *)v416;
          if ((v418 - (_BYTE *)v416) >> 2 > v93)
            v93 = v94 >> 2;
          if ((unint64_t)v94 >= 0x7FFFFFFFFFFFFFF8)
            v95 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v95 = v93;
          if (v95)
          {
            v96 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v418, v95);
            v91 = (char *)v416;
            v89 = v417;
          }
          else
          {
            v96 = 0;
          }
          v97 = (uint64_t *)&v96[8 * v92];
          *v97 = v20;
          v90 = (char *)(v97 + 1);
          while (v89 != v91)
          {
            v98 = *((_QWORD *)v89 - 1);
            v89 -= 8;
            *--v97 = v98;
          }
          v416 = v97;
          v417 = v90;
          v418 = &v96[8 * v95];
          if (v91)
            operator delete(v91);
        }
        else
        {
          *(_QWORD *)v417 = v20;
          v90 = v89 + 8;
        }
        v417 = v90;
        v60 = objc_msgSend(v21, "typeName");
        v61 = v420;
        if (v420 >= (uint64_t *)v421)
        {
          v99 = ((char *)v420 - (_BYTE *)v419) >> 3;
          if ((unint64_t)(v99 + 1) >> 61)
            abort();
          v100 = (v421 - (_BYTE *)v419) >> 2;
          if (v100 <= v99 + 1)
            v100 = v99 + 1;
          if ((unint64_t)(v421 - (_BYTE *)v419) >= 0x7FFFFFFFFFFFFFF8)
            v64 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v64 = v100;
          if (v64)
            v65 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v421, v64);
          else
            v65 = 0;
          v76 = (uint64_t *)&v65[8 * v99];
          *v76 = v60;
          v77 = v76 + 1;
          v101 = (char *)v419;
          v78 = (char *)v420;
          if (v420 != v419)
          {
            do
            {
              v102 = *((_QWORD *)v78 - 1);
              v78 -= 8;
              *--v76 = v102;
            }
            while (v78 != v101);
            goto LABEL_166;
          }
LABEL_167:
          v419 = v76;
          v420 = v77;
          v421 = &v65[8 * v64];
          if (v78)
            operator delete(v78);
          goto LABEL_169;
        }
      }
      else if (v20 == 2)
      {
        v24 = v423;
        if (v423 >= v424)
        {
          v30 = (char *)__p;
          v31 = (v423 - (_BYTE *)__p) >> 3;
          v32 = v31 + 1;
          if ((unint64_t)(v31 + 1) >> 61)
            goto LABEL_852;
          v33 = v424 - (_BYTE *)__p;
          if ((v424 - (_BYTE *)__p) >> 2 > v32)
            v32 = v33 >> 2;
          if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
            v34 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v34 = v32;
          if (v34)
          {
            v35 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)v18, v34);
            v30 = (char *)__p;
            v24 = v423;
          }
          else
          {
            v35 = 0;
          }
          v48 = &v35[8 * v31];
          *(_QWORD *)v48 = 65000;
          v25 = v48 + 8;
          while (v24 != v30)
          {
            v49 = *((_QWORD *)v24 - 1);
            v24 -= 8;
            *((_QWORD *)v48 - 1) = v49;
            v48 -= 8;
          }
          __p = v48;
          v423 = v25;
          v424 = &v35[8 * v34];
          if (v30)
            operator delete(v30);
        }
        else
        {
          *(_QWORD *)v423 = 65000;
          v25 = v24 + 8;
        }
        v423 = v25;
        v50 = v417;
        if (v417 >= v418)
        {
          v52 = (char *)v416;
          v53 = (v417 - (_BYTE *)v416) >> 3;
          v54 = v53 + 1;
          if ((unint64_t)(v53 + 1) >> 61)
            goto LABEL_852;
          v55 = v418 - (_BYTE *)v416;
          if ((v418 - (_BYTE *)v416) >> 2 > v54)
            v54 = v55 >> 2;
          if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8)
            v56 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v56 = v54;
          if (v56)
          {
            v57 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v418, v56);
            v52 = (char *)v416;
            v50 = v417;
          }
          else
          {
            v57 = 0;
          }
          v58 = &v57[8 * v53];
          *(_QWORD *)v58 = 2;
          v51 = v58 + 8;
          while (v50 != v52)
          {
            v59 = *((_QWORD *)v50 - 1);
            v50 -= 8;
            *((_QWORD *)v58 - 1) = v59;
            v58 -= 8;
          }
          v416 = v58;
          v417 = v51;
          v418 = &v57[8 * v56];
          if (v52)
            operator delete(v52);
        }
        else
        {
          *(_QWORD *)v417 = 2;
          v51 = v50 + 8;
        }
        v417 = v51;
        v60 = objc_msgSend(v19, "name");
        v61 = v420;
        if (v420 >= (uint64_t *)v421)
        {
          v62 = ((char *)v420 - (_BYTE *)v419) >> 3;
          if ((unint64_t)(v62 + 1) >> 61)
            abort();
          v63 = (v421 - (_BYTE *)v419) >> 2;
          if (v63 <= v62 + 1)
            v63 = v62 + 1;
          if ((unint64_t)(v421 - (_BYTE *)v419) >= 0x7FFFFFFFFFFFFFF8)
            v64 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v64 = v63;
          if (v64)
            v65 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v421, v64);
          else
            v65 = 0;
          v76 = (uint64_t *)&v65[8 * v62];
          *v76 = v60;
          v77 = v76 + 1;
          v79 = (char *)v419;
          v78 = (char *)v420;
          if (v420 == v419)
            goto LABEL_167;
          do
          {
            v80 = *((_QWORD *)v78 - 1);
            v78 -= 8;
            *--v76 = v80;
          }
          while (v78 != v79);
          goto LABEL_166;
        }
      }
      else
      {
        v26 = objc_msgSend((id)objc_msgSend(v19, "dataTypeDescription"), "dataType");
        v27 = v26;
        v28 = v423;
        if (v423 >= v424)
        {
          v36 = (char *)__p;
          v37 = (v423 - (_BYTE *)__p) >> 3;
          v38 = v37 + 1;
          if ((unint64_t)(v37 + 1) >> 61)
            abort();
          v39 = v424 - (_BYTE *)__p;
          if ((v424 - (_BYTE *)__p) >> 2 > v38)
            v38 = v39 >> 2;
          if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8)
            v40 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v40 = v38;
          if (v40)
          {
            v41 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)v18, v40);
            v36 = (char *)__p;
            v28 = v423;
          }
          else
          {
            v41 = 0;
          }
          v66 = (uint64_t *)&v41[8 * v37];
          *v66 = v27;
          v29 = (char *)(v66 + 1);
          while (v28 != v36)
          {
            v67 = *((_QWORD *)v28 - 1);
            v28 -= 8;
            *--v66 = v67;
          }
          __p = v66;
          v423 = v29;
          v424 = &v41[8 * v40];
          if (v36)
            operator delete(v36);
        }
        else
        {
          *(_QWORD *)v423 = v26;
          v29 = v28 + 8;
        }
        v423 = v29;
        v68 = v417;
        if (v417 >= v418)
        {
          v70 = (char *)v416;
          v71 = (v417 - (_BYTE *)v416) >> 3;
          v72 = v71 + 1;
          if ((unint64_t)(v71 + 1) >> 61)
LABEL_852:
            abort();
          v73 = v418 - (_BYTE *)v416;
          if ((v418 - (_BYTE *)v416) >> 2 > v72)
            v72 = v73 >> 2;
          if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFF8)
            v74 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v74 = v72;
          if (v74)
          {
            v75 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v418, v74);
            v70 = (char *)v416;
            v68 = v417;
          }
          else
          {
            v75 = 0;
          }
          v81 = (uint64_t *)&v75[8 * v71];
          *v81 = v20;
          v69 = (char *)(v81 + 1);
          while (v68 != v70)
          {
            v82 = *((_QWORD *)v68 - 1);
            v68 -= 8;
            *--v81 = v82;
          }
          v416 = v81;
          v417 = v69;
          v418 = &v75[8 * v74];
          if (v70)
            operator delete(v70);
        }
        else
        {
          *(_QWORD *)v417 = v20;
          v69 = v68 + 8;
        }
        v417 = v69;
        v60 = objc_msgSend(v19, "name");
        v61 = v420;
        if (v420 >= (uint64_t *)v421)
        {
          v83 = ((char *)v420 - (_BYTE *)v419) >> 3;
          if ((unint64_t)(v83 + 1) >> 61)
            abort();
          v84 = (v421 - (_BYTE *)v419) >> 2;
          if (v84 <= v83 + 1)
            v84 = v83 + 1;
          if ((unint64_t)(v421 - (_BYTE *)v419) >= 0x7FFFFFFFFFFFFFF8)
            v64 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v64 = v84;
          if (v64)
            v65 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v421, v64);
          else
            v65 = 0;
          v76 = (uint64_t *)&v65[8 * v83];
          *v76 = v60;
          v77 = v76 + 1;
          v85 = (char *)v419;
          v78 = (char *)v420;
          if (v420 == v419)
            goto LABEL_167;
          do
          {
            v86 = *((_QWORD *)v78 - 1);
            v78 -= 8;
            *--v76 = v86;
          }
          while (v78 != v85);
LABEL_166:
          v78 = (char *)v419;
          goto LABEL_167;
        }
      }
      *v61 = v60;
      v77 = v61 + 1;
LABEL_169:
      v420 = v77;
LABEL_170:
      ++v17;
    }
    while (v17 != v16);
  }
  v146 = (char *)__p;
  v145 = v423;
  v147 = (v423 - (_BYTE *)__p) >> 3;
  p_var6 = &this->var6;
  std::vector<std::string>::reserve((std::vector<std::string> *)&this->var6, v147);
  p_var5 = &this->var5;
  std::vector<CI::KernelArgumentType>::reserve((void **)&this->var5.var0, v147);
  if (v145 == v146)
  {
    obja = 0;
    v409 = 0;
LABEL_811:
    v386 = 0;
    var1 = this->var1;
    if (var1 > 3)
    {
      v388 = obja;
      v389 = v409;
    }
    else
    {
      v388 = obja;
      v389 = v409;
      if (var1 != 1)
        v386 = obja ^ 1;
    }
    if (var1 == 1)
    {
      if ((v388 & 1) != 0)
      {
        CIKernelError(v402, 5u, CFSTR("CIWarpKernels cannot have coreimage:sampler arguments."));
        v390 = ci_logger_api();
        if (os_log_type_enabled(v390, OS_LOG_TYPE_ERROR))
          CIKernelReflection::reflect();
        goto LABEL_830;
      }
      if (!v389)
      {
        CIKernelError(v402, 6u, CFSTR("CIWarpKernels must have coreimage:destination argument."));
        v395 = ci_logger_api();
        if (os_log_type_enabled(v395, OS_LOG_TYPE_ERROR))
          CIKernelReflection::reflect();
        goto LABEL_830;
      }
      this->var0 = 3;
    }
    else
    {
      if ((v386 & 1) != 0)
        v391 = 2;
      else
        v391 = 1;
      this->var0 = v391;
      if (!v389)
      {
        this->var8 |= 1u;
LABEL_828:
        v392 = 1;
        goto LABEL_831;
      }
    }
    if ((*(this->var5.var1 - 1) - 30) >= 0xA)
    {
      CIKernelError(v402, 4u, CFSTR("If specified, destination must be the last parameter of a CIKernel function."));
      goto LABEL_830;
    }
    if (v389 == 5)
      *(int64x2_t *)&this->var10 = vdupq_n_s64(2uLL);
    goto LABEL_828;
  }
  v150 = 0;
  v408 = 0;
  v409 = 0;
  obja = 0;
  p_var1 = &this->var5.var1;
  v152 = &this->var5.var2;
  v405 = v147 - 1;
  if (v147 <= 1)
    v153 = 1;
  else
    v153 = v147;
  while (1)
  {
    v154 = (std::string *)objc_msgSend(*((id *)v419 + v150), "stringByTrimmingCharactersInSet:", objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB3500], "characterSetWithCharactersInString:", CFSTR("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz")), "invertedSet"));
    v155 = v154;
    v156 = *((_QWORD *)__p + v150);
    switch(v156)
    {
      case 1:
        goto LABEL_601;
      case 2:
      case 8:
      case 9:
      case 10:
      case 12:
      case 13:
      case 14:
      case 21:
      case 22:
      case 23:
      case 25:
      case 26:
      case 27:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        goto LABEL_844;
      case 3:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v158 = 5;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v192 = v157 - p_var5->var0;
        v193 = v192 + 1;
        if ((unint64_t)(v192 + 1) >> 62)
          abort();
        v194 = (char *)v152->var0 - (char *)var0;
        if (v194 >> 1 > v193)
          v193 = v194 >> 1;
        if ((unint64_t)v194 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v193;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v192];
        *v280 = 5;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v286 = *--v157;
          *--v280 = v286;
        }
        goto LABEL_775;
      case 4:
        if (v408 == 3)
        {
          v161 = *p_var1;
          if (*p_var1 >= v152->var0)
          {
            v247 = p_var5->var0;
            v248 = v161 - p_var5->var0;
            v249 = v248 + 1;
            if ((unint64_t)(v248 + 1) >> 62)
              abort();
            v250 = (char *)v152->var0 - (char *)v247;
            if (v250 >> 1 > v249)
              v249 = v250 >> 1;
            if ((unint64_t)v250 >= 0x7FFFFFFFFFFFFFFCLL)
              v251 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v251 = v249;
            if (v251)
            {
              v252 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v251);
              v161 = *p_var1;
              v247 = p_var5->var0;
            }
            else
            {
              v252 = 0;
            }
            v337 = (int *)&v252[4 * v248];
            *v337 = 2;
            v162 = v337 + 1;
            while (v161 != v247)
            {
              v338 = *--v161;
              *--v337 = v338;
            }
            p_var5->var0 = v337;
            *p_var1 = v162;
            v152->var0 = (int *)&v252[4 * v251];
            if (v247)
              operator delete(v247);
          }
          else
          {
            *v161 = 2;
            v162 = v161 + 1;
          }
          *p_var1 = v162;
          v155 = (std::string *)unk_1EE2AD938(v155, "stringByReplacingOccurrencesOfString:withString:", CFSTR(".coerce3"), &stru_1E2ECD1B0);
          v408 = 0;
          obja = 1;
          goto LABEL_778;
        }
        if ((unk_1EE2AD948(v154, "containsString:", CFSTR(".coerce")) & 1) == 0)
        {
          v181 = unk_1EE2AD940(v155, "length");
          if (v405 != v150 || v181)
          {
            v157 = *p_var1;
            if (*p_var1 >= v152->var0)
            {
              var0 = p_var5->var0;
              v352 = v157 - p_var5->var0;
              v353 = v352 + 1;
              if ((unint64_t)(v352 + 1) >> 62)
                abort();
              v354 = (char *)v152->var0 - (char *)var0;
              if (v354 >> 1 > v353)
                v353 = v354 >> 1;
              if ((unint64_t)v354 >= 0x7FFFFFFFFFFFFFFCLL)
                v173 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v173 = v353;
              if (v173)
              {
                v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
                v157 = *p_var1;
                var0 = p_var5->var0;
              }
              else
              {
                v174 = 0;
              }
              v280 = (int *)&v174[4 * v352];
              *v280 = 6;
              v281 = v280 + 1;
              while (v157 != var0)
              {
                v363 = *--v157;
                *--v280 = v363;
              }
LABEL_775:
              p_var5->var0 = v280;
              *p_var1 = v281;
              v152->var0 = (int *)&v174[4 * v173];
              if (var0)
                operator delete(var0);
            }
            else
            {
              v158 = 6;
LABEL_672:
              *v157 = v158;
              v281 = v157 + 1;
            }
            *p_var1 = v281;
            goto LABEL_778;
          }
        }
        if (!v409)
        {
          v182 = *p_var1;
          if (*p_var1 >= v152->var0)
          {
            v315 = p_var5->var0;
            v316 = v182 - p_var5->var0;
            v317 = v316 + 1;
            if ((unint64_t)(v316 + 1) >> 62)
              abort();
            v318 = (char *)v152->var0 - (char *)v315;
            if (v318 >> 1 > v317)
              v317 = v318 >> 1;
            if ((unint64_t)v318 >= 0x7FFFFFFFFFFFFFFCLL)
              v319 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v319 = v317;
            if (v319)
            {
              v320 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v319);
              v182 = *p_var1;
              v315 = p_var5->var0;
            }
            else
            {
              v320 = 0;
            }
            v350 = (int *)&v320[4 * v316];
            *v350 = 30;
            v183 = v350 + 1;
            while (v182 != v315)
            {
              v351 = *--v182;
              *--v350 = v351;
            }
            p_var5->var0 = v350;
            *p_var1 = v183;
            v152->var0 = (int *)&v320[4 * v319];
            if (v315)
              operator delete(v315);
          }
          else
          {
            *v182 = 30;
            v183 = v182 + 1;
          }
          *p_var1 = v183;
          v341 = 1;
          goto LABEL_751;
        }
        CIKernelError(v402, 5u, CFSTR("Function has too many destination parameters."));
        v398 = ci_logger_api();
        if (os_log_type_enabled(v398, OS_LOG_TYPE_ERROR))
          CIKernelReflection::reflect();
LABEL_830:
        v392 = 0;
LABEL_831:
        if (v416)
        {
          v417 = (char *)v416;
          operator delete(v416);
        }
        if (v419)
        {
          v420 = (uint64_t *)v419;
          operator delete(v419);
        }
        if (__p)
        {
          v423 = (char *)__p;
          operator delete(__p);
        }
        return v392;
      case 5:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v158 = 7;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v198 = v157 - p_var5->var0;
        v199 = v198 + 1;
        if ((unint64_t)(v198 + 1) >> 62)
          abort();
        v200 = (char *)v152->var0 - (char *)var0;
        if (v200 >> 1 > v199)
          v199 = v200 >> 1;
        if ((unint64_t)v200 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v199;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v198];
        *v280 = 7;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v288 = *--v157;
          *--v280 = v288;
        }
        goto LABEL_775;
      case 6:
        v157 = *p_var1;
        v175 = v152->var0;
        if (v409 == 2)
        {
          if (v157 >= v175)
          {
            v271 = p_var5->var0;
            v272 = v157 - p_var5->var0;
            v273 = v272 + 1;
            if ((unint64_t)(v272 + 1) >> 62)
              abort();
            v274 = (char *)v175 - (char *)v271;
            if (v274 >> 1 > v273)
              v273 = v274 >> 1;
            if ((unint64_t)v274 >= 0x7FFFFFFFFFFFFFFCLL)
              v275 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v275 = v273;
            if (v275)
            {
              v276 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v275);
              v157 = *p_var1;
              v271 = p_var5->var0;
            }
            else
            {
              v276 = 0;
            }
            v346 = (int *)&v276[4 * v272];
            *v346 = 36;
            v176 = v346 + 1;
            while (v157 != v271)
            {
              v347 = *--v157;
              *--v346 = v347;
            }
            p_var5->var0 = v346;
            *p_var1 = v176;
            v152->var0 = (int *)&v276[4 * v275];
            if (v271)
              operator delete(v271);
          }
          else
          {
            *v157 = 36;
            v176 = v157 + 1;
          }
          *p_var1 = v176;
          v341 = 3;
          goto LABEL_751;
        }
        if (v157 < v175)
        {
          v158 = 8;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v277 = v157 - p_var5->var0;
        v278 = v277 + 1;
        if ((unint64_t)(v277 + 1) >> 62)
          abort();
        v279 = (char *)v175 - (char *)var0;
        if (v279 >> 1 > v278)
          v278 = v279 >> 1;
        if ((unint64_t)v279 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v278;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v277];
        *v280 = 8;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v348 = *--v157;
          *--v280 = v348;
        }
        goto LABEL_775;
      case 7:
        v163 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v177 = 9;
          goto LABEL_324;
        }
        v201 = p_var5->var0;
        v202 = v163 - p_var5->var0;
        v203 = v202 + 1;
        if ((unint64_t)(v202 + 1) >> 62)
          abort();
        v204 = (char *)v152->var0 - (char *)v201;
        if (v204 >> 1 > v203)
          v203 = v204 >> 1;
        if ((unint64_t)v204 >= 0x7FFFFFFFFFFFFFFCLL)
          v205 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v205 = v203;
        if (v205)
        {
          v206 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v205);
          v163 = *p_var1;
          v201 = p_var5->var0;
        }
        else
        {
          v206 = 0;
        }
        v289 = (int *)&v206[4 * v202];
        *v289 = 9;
        v187 = v289 + 1;
        while (v163 != v201)
        {
          v290 = *--v163;
          *--v289 = v290;
        }
        goto LABEL_696;
      case 11:
        v163 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v177 = 10;
          goto LABEL_324;
        }
        v201 = p_var5->var0;
        v210 = v163 - p_var5->var0;
        v211 = v210 + 1;
        if ((unint64_t)(v210 + 1) >> 62)
          abort();
        v212 = (char *)v152->var0 - (char *)v201;
        if (v212 >> 1 > v211)
          v211 = v212 >> 1;
        if ((unint64_t)v212 >= 0x7FFFFFFFFFFFFFFCLL)
          v205 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v205 = v211;
        if (v205)
        {
          v206 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v205);
          v163 = *p_var1;
          v201 = p_var5->var0;
        }
        else
        {
          v206 = 0;
        }
        v289 = (int *)&v206[4 * v210];
        *v289 = 10;
        v187 = v289 + 1;
        while (v163 != v201)
        {
          v292 = *--v163;
          *--v289 = v292;
        }
        goto LABEL_696;
      case 15:
        v163 = *p_var1;
        v164 = v152->var0;
        if (v409 == 3)
        {
          if (v163 >= v164)
          {
            v253 = p_var5->var0;
            v254 = v163 - p_var5->var0;
            v255 = v254 + 1;
            if ((unint64_t)(v254 + 1) >> 62)
              abort();
            v256 = (char *)v164 - (char *)v253;
            if (v256 >> 1 > v255)
              v255 = v256 >> 1;
            if ((unint64_t)v256 >= 0x7FFFFFFFFFFFFFFCLL)
              v257 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v257 = v255;
            if (v257)
            {
              v258 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v257);
              v163 = *p_var1;
              v253 = p_var5->var0;
            }
            else
            {
              v258 = 0;
            }
            v339 = (int *)&v258[4 * v254];
            *v339 = 37;
            v165 = v339 + 1;
            while (v163 != v253)
            {
              v340 = *--v163;
              *--v339 = v340;
            }
            p_var5->var0 = v339;
            *p_var1 = v165;
            v152->var0 = (int *)&v258[4 * v257];
            if (v253)
              operator delete(v253);
          }
          else
          {
            *v163 = 37;
            v165 = v163 + 1;
          }
          *p_var1 = v165;
          v341 = 4;
          goto LABEL_751;
        }
        if (v163 >= v164)
        {
          v201 = p_var5->var0;
          v259 = v163 - p_var5->var0;
          v260 = v259 + 1;
          if ((unint64_t)(v259 + 1) >> 62)
            abort();
          v261 = (char *)v164 - (char *)v201;
          if (v261 >> 1 > v260)
            v260 = v261 >> 1;
          if ((unint64_t)v261 >= 0x7FFFFFFFFFFFFFFCLL)
            v205 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v205 = v260;
          if (v205)
          {
            v206 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v205);
            v163 = *p_var1;
            v201 = p_var5->var0;
          }
          else
          {
            v206 = 0;
          }
          v289 = (int *)&v206[4 * v259];
          *v289 = 11;
          v187 = v289 + 1;
          while (v163 != v201)
          {
            v342 = *--v163;
            *--v289 = v342;
          }
LABEL_696:
          p_var5->var0 = v289;
          *p_var1 = v187;
          v152->var0 = (int *)&v206[4 * v205];
          if (v201)
            operator delete(v201);
        }
        else
        {
          v177 = 11;
LABEL_324:
          *v163 = v177;
          v187 = v163 + 1;
        }
        *p_var1 = v187;
        v155 = (std::string *)unk_1EE2AD950(v155, "stringByReplacingOccurrencesOfString:withString:", CFSTR(".coerce"), &stru_1E2ECD1B0);
        goto LABEL_778;
      case 16:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v158 = 12;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v195 = v157 - p_var5->var0;
        v196 = v195 + 1;
        if ((unint64_t)(v195 + 1) >> 62)
          abort();
        v197 = (char *)v152->var0 - (char *)var0;
        if (v197 >> 1 > v196)
          v196 = v197 >> 1;
        if ((unint64_t)v197 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v196;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v195];
        *v280 = 12;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v287 = *--v157;
          *--v280 = v287;
        }
        goto LABEL_775;
      case 17:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v158 = 13;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v184 = v157 - p_var5->var0;
        v185 = v184 + 1;
        if ((unint64_t)(v184 + 1) >> 62)
          abort();
        v186 = (char *)v152->var0 - (char *)var0;
        if (v186 >> 1 > v185)
          v185 = v186 >> 1;
        if ((unint64_t)v186 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v185;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v184];
        *v280 = 13;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v283 = *--v157;
          *--v280 = v283;
        }
        goto LABEL_775;
      case 18:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v158 = 14;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v216 = v157 - p_var5->var0;
        v217 = v216 + 1;
        if ((unint64_t)(v216 + 1) >> 62)
          abort();
        v218 = (char *)v152->var0 - (char *)var0;
        if (v218 >> 1 > v217)
          v217 = v218 >> 1;
        if ((unint64_t)v218 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v217;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v216];
        *v280 = 14;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v294 = *--v157;
          *--v280 = v294;
        }
        goto LABEL_775;
      case 19:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v158 = 15;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v222 = v157 - p_var5->var0;
        v223 = v222 + 1;
        if ((unint64_t)(v222 + 1) >> 62)
          abort();
        v224 = (char *)v152->var0 - (char *)var0;
        if (v224 >> 1 > v223)
          v223 = v224 >> 1;
        if ((unint64_t)v224 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v223;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v222];
        *v280 = 15;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v296 = *--v157;
          *--v280 = v296;
        }
        goto LABEL_775;
      case 20:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v158 = 16;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v219 = v157 - p_var5->var0;
        v220 = v219 + 1;
        if ((unint64_t)(v219 + 1) >> 62)
          abort();
        v221 = (char *)v152->var0 - (char *)var0;
        if (v221 >> 1 > v220)
          v220 = v221 >> 1;
        if ((unint64_t)v221 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v220;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v219];
        *v280 = 16;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v295 = *--v157;
          *--v280 = v295;
        }
        goto LABEL_775;
      case 24:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v158 = 17;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v231 = v157 - p_var5->var0;
        v232 = v231 + 1;
        if ((unint64_t)(v231 + 1) >> 62)
          abort();
        v233 = (char *)v152->var0 - (char *)var0;
        if (v233 >> 1 > v232)
          v232 = v233 >> 1;
        if ((unint64_t)v233 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v232;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v231];
        *v280 = 17;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v299 = *--v157;
          *--v280 = v299;
        }
        goto LABEL_775;
      case 28:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v158 = 18;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v213 = v157 - p_var5->var0;
        v214 = v213 + 1;
        if ((unint64_t)(v213 + 1) >> 62)
          abort();
        v215 = (char *)v152->var0 - (char *)var0;
        if (v215 >> 1 > v214)
          v214 = v215 >> 1;
        if ((unint64_t)v215 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v214;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v213];
        *v280 = 18;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v293 = *--v157;
          *--v280 = v293;
        }
        goto LABEL_775;
      case 29:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v158 = 19;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v225 = v157 - p_var5->var0;
        v226 = v225 + 1;
        if ((unint64_t)(v225 + 1) >> 62)
          abort();
        v227 = (char *)v152->var0 - (char *)var0;
        if (v227 >> 1 > v226)
          v226 = v227 >> 1;
        if ((unint64_t)v227 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v226;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v225];
        *v280 = 19;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v297 = *--v157;
          *--v280 = v297;
        }
        goto LABEL_775;
      case 30:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v158 = 20;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v189 = v157 - p_var5->var0;
        v190 = v189 + 1;
        if ((unint64_t)(v189 + 1) >> 62)
          abort();
        v191 = (char *)v152->var0 - (char *)var0;
        if (v191 >> 1 > v190)
          v190 = v191 >> 1;
        if ((unint64_t)v191 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v190;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v189];
        *v280 = 20;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v284 = *--v157;
          *--v280 = v284;
        }
        goto LABEL_775;
      case 31:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v158 = 21;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v178 = v157 - p_var5->var0;
        v179 = v178 + 1;
        if ((unint64_t)(v178 + 1) >> 62)
          abort();
        v180 = (char *)v152->var0 - (char *)var0;
        if (v180 >> 1 > v179)
          v179 = v180 >> 1;
        if ((unint64_t)v180 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v179;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v178];
        *v280 = 21;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v282 = *--v157;
          *--v280 = v282;
        }
        goto LABEL_775;
      case 32:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v158 = 22;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v207 = v157 - p_var5->var0;
        v208 = v207 + 1;
        if ((unint64_t)(v207 + 1) >> 62)
          abort();
        v209 = (char *)v152->var0 - (char *)var0;
        if (v209 >> 1 > v208)
          v208 = v209 >> 1;
        if ((unint64_t)v209 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v208;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v207];
        *v280 = 22;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v291 = *--v157;
          *--v280 = v291;
        }
        goto LABEL_775;
      case 33:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
          v158 = 23;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v228 = v157 - p_var5->var0;
        v229 = v228 + 1;
        if ((unint64_t)(v228 + 1) >> 62)
          abort();
        v230 = (char *)v152->var0 - (char *)var0;
        if (v230 >> 1 > v229)
          v229 = v230 >> 1;
        if ((unint64_t)v230 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v229;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v228];
        *v280 = 23;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v298 = *--v157;
          *--v280 = v298;
        }
        goto LABEL_775;
      case 34:
        v157 = *p_var1;
        v167 = v152->var0;
        if (v409 == 1)
        {
          if (v157 >= v167)
          {
            v262 = p_var5->var0;
            v263 = v157 - p_var5->var0;
            v264 = v263 + 1;
            if ((unint64_t)(v263 + 1) >> 62)
              abort();
            v265 = (char *)v167 - (char *)v262;
            if (v265 >> 1 > v264)
              v264 = v265 >> 1;
            if ((unint64_t)v265 >= 0x7FFFFFFFFFFFFFFCLL)
              v266 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v266 = v264;
            if (v266)
            {
              v267 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v266);
              v157 = *p_var1;
              v262 = p_var5->var0;
            }
            else
            {
              v267 = 0;
            }
            v343 = (int *)&v267[4 * v263];
            *v343 = 35;
            v168 = v343 + 1;
            while (v157 != v262)
            {
              v344 = *--v157;
              *--v343 = v344;
            }
            p_var5->var0 = v343;
            *p_var1 = v168;
            v152->var0 = (int *)&v267[4 * v266];
            if (v262)
              operator delete(v262);
          }
          else
          {
            *v157 = 35;
            v168 = v157 + 1;
          }
          *p_var1 = v168;
          v341 = 2;
          goto LABEL_751;
        }
        if (v157 < v167)
        {
          v158 = 24;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v268 = v157 - p_var5->var0;
        v269 = v268 + 1;
        if ((unint64_t)(v268 + 1) >> 62)
          abort();
        v270 = (char *)v167 - (char *)var0;
        if (v270 >> 1 > v269)
          v269 = v270 >> 1;
        if ((unint64_t)v270 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v269;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v268];
        *v280 = 24;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v345 = *--v157;
          *--v280 = v345;
        }
        goto LABEL_775;
      case 35:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
          goto LABEL_299;
        var0 = p_var5->var0;
        v234 = v157 - p_var5->var0;
        v235 = v234 + 1;
        if ((unint64_t)(v234 + 1) >> 62)
          abort();
        v236 = (char *)v152->var0 - (char *)var0;
        if (v236 >> 1 > v235)
          v235 = v236 >> 1;
        if ((unint64_t)v236 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v235;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v234];
        *v280 = 26;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v300 = *--v157;
          *--v280 = v300;
        }
        goto LABEL_775;
      case 36:
        v157 = *p_var1;
        if (*p_var1 < v152->var0)
        {
LABEL_299:
          v158 = 26;
          goto LABEL_672;
        }
        var0 = p_var5->var0;
        v170 = v157 - p_var5->var0;
        v171 = v170 + 1;
        if ((unint64_t)(v170 + 1) >> 62)
          abort();
        v172 = (char *)v152->var0 - (char *)var0;
        if (v172 >> 1 > v171)
          v171 = v172 >> 1;
        if ((unint64_t)v172 >= 0x7FFFFFFFFFFFFFFCLL)
          v173 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v173 = v171;
        if (v173)
        {
          v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
          v157 = *p_var1;
          var0 = p_var5->var0;
        }
        else
        {
          v174 = 0;
        }
        v280 = (int *)&v174[4 * v170];
        *v280 = 26;
        v281 = v280 + 1;
        while (v157 != var0)
        {
          v285 = *--v157;
          *--v280 = v285;
        }
        goto LABEL_775;
      case 58:
        if (v409 == 5)
        {
          v245 = *p_var1;
          if (*p_var1 < v152->var0)
          {
            v246 = 39;
            goto LABEL_605;
          }
          v304 = p_var5->var0;
          v327 = v245 - p_var5->var0;
          v328 = v327 + 1;
          if ((unint64_t)(v327 + 1) >> 62)
            abort();
          v329 = (char *)v152->var0 - (char *)v304;
          if (v329 >> 1 > v328)
            v328 = v329 >> 1;
          if ((unint64_t)v329 >= 0x7FFFFFFFFFFFFFFCLL)
            v308 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v308 = v328;
          if (v308)
          {
            v309 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v308);
            v245 = *p_var1;
            v304 = p_var5->var0;
          }
          else
          {
            v309 = 0;
          }
          v310 = (int *)&v309[4 * v327];
          *v310 = 39;
          v303 = v310 + 1;
          while (v245 != v304)
          {
            v357 = *--v245;
            *--v310 = v357;
          }
LABEL_748:
          p_var5->var0 = v310;
          *p_var1 = v303;
          v152->var0 = (int *)&v309[4 * v308];
          if (v304)
            operator delete(v304);
LABEL_750:
          *p_var1 = v303;
          v341 = 6;
LABEL_751:
          v409 = v341;
LABEL_778:
          v364 = (char *)unk_1EE2AD958(v155, "UTF8String");
          if (!v364)
            v364 = CI::KernelArguments::name_for_type(*(*p_var1 - 1));
          std::string::basic_string[abi:nn180100]<0>(v410, v364);
          v366 = (char *)this->var6.var1;
          v365 = (char *)this->var6.var2.var0;
          if (v366 >= v365)
          {
            v368 = 0xAAAAAAAAAAAAAAABLL * ((v366 - (char *)p_var6->var0) >> 3);
            v369 = v368 + 1;
            if (v368 + 1 > 0xAAAAAAAAAAAAAAALL)
              abort();
            v370 = 0xAAAAAAAAAAAAAAABLL * ((v365 - (char *)p_var6->var0) >> 3);
            if (2 * v370 > v369)
              v369 = 2 * v370;
            if (v370 >= 0x555555555555555)
              v371 = 0xAAAAAAAAAAAAAAALL;
            else
              v371 = v369;
            v426.__end_cap_.__value_ = (std::allocator<std::string> *)&this->var6.var2;
            if (v371)
              v372 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>((uint64_t)&this->var6.var2, v371);
            else
              v372 = 0;
            v373 = &v372[24 * v368];
            v374 = *(_OWORD *)v410;
            *((_QWORD *)v373 + 2) = v411;
            *(_OWORD *)v373 = v374;
            v410[1] = 0;
            v411 = 0;
            v410[0] = 0;
            v376 = (char *)this->var6.var0;
            v375 = (char *)this->var6.var1;
            if (v375 == v376)
            {
              v379 = vdupq_n_s64((unint64_t)v375);
              v377 = &v372[24 * v368];
            }
            else
            {
              v377 = &v372[24 * v368];
              do
              {
                v378 = *(_OWORD *)(v375 - 24);
                *((_QWORD *)v377 - 1) = *((_QWORD *)v375 - 1);
                *(_OWORD *)(v377 - 24) = v378;
                v377 -= 24;
                *((_QWORD *)v375 - 2) = 0;
                *((_QWORD *)v375 - 1) = 0;
                *((_QWORD *)v375 - 3) = 0;
                v375 -= 24;
              }
              while (v375 != v376);
              v379 = *(int64x2_t *)&p_var6->var0;
            }
            v380 = v373 + 24;
            this->var6.var0 = v377;
            this->var6.var1 = v373 + 24;
            *(int64x2_t *)&v426.__begin_ = v379;
            v381 = (std::string *)this->var6.var2.var0;
            this->var6.var2.var0 = &v372[24 * v371];
            v426.__end_cap_.__value_ = v381;
            v426.__first_ = (std::__split_buffer<std::string>::pointer)v379.i64[0];
            std::__split_buffer<std::string>::~__split_buffer(&v426);
            v382 = SHIBYTE(v411);
            this->var6.var1 = v380;
            if (v382 < 0)
              operator delete(v410[0]);
          }
          else
          {
            v367 = *(_OWORD *)v410;
            *((_QWORD *)v366 + 2) = v411;
            *(_OWORD *)v366 = v367;
            this->var6.var1 = v366 + 24;
          }
          goto LABEL_798;
        }
        if (v409 == 4)
        {
          v243 = *p_var1;
          if (*p_var1 < v152->var0)
          {
            v244 = 38;
            goto LABEL_677;
          }
          v321 = p_var5->var0;
          v322 = v243 - p_var5->var0;
          v323 = v322 + 1;
          if ((unint64_t)(v322 + 1) >> 62)
            abort();
          v324 = (char *)v152->var0 - (char *)v321;
          if (v324 >> 1 > v323)
            v323 = v324 >> 1;
          if ((unint64_t)v324 >= 0x7FFFFFFFFFFFFFFCLL)
            v325 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v325 = v323;
          if (v325)
          {
            v326 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v325);
            v243 = *p_var1;
            v321 = p_var5->var0;
          }
          else
          {
            v326 = 0;
          }
          v355 = (int *)&v326[4 * v322];
          *v355 = 38;
          v336 = v355 + 1;
          while (v243 != v321)
          {
            v356 = *--v243;
            *--v355 = v356;
          }
LABEL_804:
          p_var5->var0 = v355;
          *p_var1 = v336;
          v152->var0 = (int *)&v326[4 * v325];
          if (v321)
            operator delete(v321);
          goto LABEL_806;
        }
        if (v409)
        {
          CIKernelError(v402, 3u, CFSTR("Unsupported type for parameter '%@'."), v154);
          v399 = ci_logger_api();
          if (!os_log_type_enabled(v399, OS_LOG_TYPE_ERROR))
            goto LABEL_830;
          goto LABEL_851;
        }
        ++v408;
        v409 = 0;
LABEL_798:
        if (++v150 == v153)
          goto LABEL_811;
        break;
      case 59:
        if (v408 == 1)
        {
          v166 = 2;
LABEL_293:
          v408 = v166;
          goto LABEL_798;
        }
        CIKernelError(v402, 3u, CFSTR("Unsupported type for parameter '%@'."), v154);
        v397 = ci_logger_api();
        if (!os_log_type_enabled(v397, OS_LOG_TYPE_ERROR))
          goto LABEL_830;
        goto LABEL_851;
      case 60:
        if (v408 == 2)
        {
          v166 = 3;
          goto LABEL_293;
        }
        v157 = *p_var1;
        v188 = v152->var0;
        if (*((_QWORD *)v416 + v150) == 28)
        {
          if (v157 < v188)
          {
            v158 = 29;
            goto LABEL_672;
          }
          var0 = p_var5->var0;
          v330 = v157 - p_var5->var0;
          v331 = v330 + 1;
          if ((unint64_t)(v330 + 1) >> 62)
            abort();
          v332 = (char *)v188 - (char *)var0;
          if (v332 >> 1 > v331)
            v331 = v332 >> 1;
          if ((unint64_t)v332 >= 0x7FFFFFFFFFFFFFFCLL)
            v173 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v173 = v331;
          if (v173)
          {
            v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
            v157 = *p_var1;
            var0 = p_var5->var0;
          }
          else
          {
            v174 = 0;
          }
          v280 = (int *)&v174[4 * v330];
          *v280 = 29;
          v281 = v280 + 1;
          while (v157 != var0)
          {
            v358 = *--v157;
            *--v280 = v358;
          }
        }
        else
        {
          if (v157 < v188)
          {
            v158 = 28;
            goto LABEL_672;
          }
          var0 = p_var5->var0;
          v333 = v157 - p_var5->var0;
          v334 = v333 + 1;
          if ((unint64_t)(v333 + 1) >> 62)
            abort();
          v335 = (char *)v188 - (char *)var0;
          if (v335 >> 1 > v334)
            v334 = v335 >> 1;
          if ((unint64_t)v335 >= 0x7FFFFFFFFFFFFFFCLL)
            v173 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v173 = v334;
          if (v173)
          {
            v174 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v173);
            v157 = *p_var1;
            var0 = p_var5->var0;
          }
          else
          {
            v174 = 0;
          }
          v280 = (int *)&v174[4 * v333];
          *v280 = 28;
          v281 = v280 + 1;
          while (v157 != var0)
          {
            v359 = *--v157;
            *--v280 = v359;
          }
        }
        goto LABEL_775;
      default:
        if (v156 != 65000)
        {
LABEL_844:
          CIKernelError(v402, 3u, CFSTR("Unsupported type for parameter '%@'."), v154);
          v396 = ci_logger_api();
          if (!os_log_type_enabled(v396, OS_LOG_TYPE_ERROR))
            goto LABEL_830;
LABEL_851:
          CIKernelReflection::reflect();
          goto LABEL_830;
        }
        v159 = *p_var1;
        if (*p_var1 >= v152->var0)
        {
          v237 = p_var5->var0;
          v238 = v159 - p_var5->var0;
          v239 = v238 + 1;
          if ((unint64_t)(v238 + 1) >> 62)
            abort();
          v240 = (char *)v152->var0 - (char *)v237;
          if (v240 >> 1 > v239)
            v239 = v240 >> 1;
          if ((unint64_t)v240 >= 0x7FFFFFFFFFFFFFFCLL)
            v241 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v241 = v239;
          if (v241)
          {
            v242 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v241);
            v159 = *p_var1;
            v237 = p_var5->var0;
          }
          else
          {
            v242 = 0;
          }
          v301 = (int *)&v242[4 * v238];
          *v301 = 4;
          v160 = v301 + 1;
          while (v159 != v237)
          {
            v302 = *--v159;
            *--v301 = v302;
          }
          p_var5->var0 = v301;
          *p_var1 = v160;
          v152->var0 = (int *)&v242[4 * v241];
          if (v237)
            operator delete(v237);
        }
        else
        {
          *v159 = 4;
          v160 = v159 + 1;
        }
        *p_var1 = v160;
LABEL_601:
        if ((unk_1EE2AD990(v155, "isEqualToString:", CFSTR("coreimage::priv::destination")) & 1) != 0
          || unk_1EE2AD998(v155, "isEqualToString:", CFSTR("coreimage::priv::Destination")))
        {
          v245 = *p_var1;
          if (*p_var1 >= v152->var0)
          {
            v304 = p_var5->var0;
            v305 = v245 - p_var5->var0;
            v306 = v305 + 1;
            if ((unint64_t)(v305 + 1) >> 62)
              abort();
            v307 = (char *)v152->var0 - (char *)v304;
            if (v307 >> 1 > v306)
              v306 = v307 >> 1;
            if ((unint64_t)v307 >= 0x7FFFFFFFFFFFFFFCLL)
              v308 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v308 = v306;
            if (v308)
            {
              v309 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v308);
              v245 = *p_var1;
              v304 = p_var5->var0;
            }
            else
            {
              v309 = 0;
            }
            v310 = (int *)&v309[4 * v305];
            *v310 = 31;
            v303 = v310 + 1;
            while (v245 != v304)
            {
              v311 = *--v245;
              *--v310 = v311;
            }
            goto LABEL_748;
          }
          v246 = 31;
        }
        else
        {
          if ((unk_1EE2AD980(v155, "isEqualToString:", CFSTR("coreimage::priv::destination_h")) & 1) == 0
            && !unk_1EE2AD988(v155, "isEqualToString:", CFSTR("coreimage::priv::Destination_h")))
          {
            if ((unk_1EE2AD970(v155, "isEqualToString:", CFSTR("coreimage::group::destination")) & 1) != 0
              || unk_1EE2AD978(v155, "isEqualToString:", CFSTR("coreimage::group::Destination")))
            {
              v243 = *p_var1;
              if (*p_var1 >= v152->var0)
              {
                v321 = p_var5->var0;
                v360 = v243 - p_var5->var0;
                v361 = v360 + 1;
                if ((unint64_t)(v360 + 1) >> 62)
                  abort();
                v362 = (char *)v152->var0 - (char *)v321;
                if (v362 >> 1 > v361)
                  v361 = v362 >> 1;
                if ((unint64_t)v362 >= 0x7FFFFFFFFFFFFFFCLL)
                  v325 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v325 = v361;
                if (v325)
                {
                  v326 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v325);
                  v243 = *p_var1;
                  v321 = p_var5->var0;
                }
                else
                {
                  v326 = 0;
                }
                v355 = (int *)&v326[4 * v360];
                *v355 = 33;
                v336 = v355 + 1;
                while (v243 != v321)
                {
                  v383 = *--v243;
                  *--v355 = v383;
                }
                goto LABEL_804;
              }
              v244 = 33;
LABEL_677:
              *v243 = v244;
              v336 = v243 + 1;
LABEL_806:
              *p_var1 = v336;
            }
            else
            {
              if ((unk_1EE2AD960(v155, "isEqualToString:", CFSTR("coreimage::group::destination_h")) & 1) == 0
                && !unk_1EE2AD968(v155, "isEqualToString:", CFSTR("coreimage::group::Destination_h")))
              {
                CIKernelError(v402, 3u, CFSTR("Unsupported type for parameter '%@'."), v155);
                v384 = ci_logger_api();
                if (os_log_type_enabled(v384, OS_LOG_TYPE_ERROR))
                {
                  v385 = *v403;
                  LODWORD(v426.__first_) = 136446466;
                  *(std::__split_buffer<std::string>::pointer *)((char *)&v426.__first_ + 4) = v385;
                  WORD2(v426.__begin_) = 2114;
                  *(std::__split_buffer<std::string>::pointer *)((char *)&v426.__begin_ + 6) = v155;
                  _os_log_error_impl(&dword_1921E4000, v384, OS_LOG_TYPE_ERROR, "Function '%{public}s' has an unsupported type for the parameter '%{public}@'.", (uint8_t *)&v426, 0x16u);
                }
                goto LABEL_778;
              }
              LODWORD(v426.__first_) = 34;
              std::vector<CI::KernelArgumentType>::push_back[abi:nn180100]((uint64_t)&this->var5, &v426);
            }
            v341 = 5;
            goto LABEL_751;
          }
          v245 = *p_var1;
          if (*p_var1 >= v152->var0)
          {
            v304 = p_var5->var0;
            v312 = v245 - p_var5->var0;
            v313 = v312 + 1;
            if ((unint64_t)(v312 + 1) >> 62)
              abort();
            v314 = (char *)v152->var0 - (char *)v304;
            if (v314 >> 1 > v313)
              v313 = v314 >> 1;
            if ((unint64_t)v314 >= 0x7FFFFFFFFFFFFFFCLL)
              v308 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v308 = v313;
            if (v308)
            {
              v309 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&this->var5.var2, v308);
              v245 = *p_var1;
              v304 = p_var5->var0;
            }
            else
            {
              v309 = 0;
            }
            v310 = (int *)&v309[4 * v312];
            *v310 = 32;
            v303 = v310 + 1;
            while (v245 != v304)
            {
              v349 = *--v245;
              *--v310 = v349;
            }
            goto LABEL_748;
          }
          v246 = 32;
        }
LABEL_605:
        *v245 = v246;
        v303 = v245 + 1;
        goto LABEL_750;
    }
  }
}

void sub_1922F5B24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42)
{
  if (__p)
    operator delete(__p);
  if (a38)
    operator delete(a38);
  if (a41)
    operator delete(a41);
  _Unwind_Resume(exception_object);
}

void *CIKernelReflection::reflectConstants(CIKernelReflection *this)
{
  void *v2;
  void *v3;
  uint64_t v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  uint64_t v11;
  void *v12;
  size_t v13;
  void *v14;
  void *v15;
  void *v16;
  size_t v17;
  _QWORD *v18;
  void *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t j;
  uint64_t v26;
  void *v27;
  NSObject *v28;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  CFTypeRef obj;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  _BYTE v39[128];
  _QWORD v40[2];
  _BYTE v41[8];
  size_t v42;
  void *v43;
  char v44;
  size_t v45;
  void *v46;
  _BYTE v47[128];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v2 = (void *)objc_msgSend(this->var7, "functionWithName:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", this->var2));
  if (!v2)
    return 0;
  v3 = v2;
  v4 = objc_msgSend((id)objc_msgSend(v2, "arguments"), "count");
  if (this->var12)
  {
    v5 = (void *)objc_msgSend(v3, "functionConstantsDictionary");
    v6 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
    v35 = 0u;
    v36 = 0u;
    v37 = 0u;
    v38 = 0u;
    v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v35, v47, 16);
    if (v7)
    {
      v8 = v7;
      v9 = *(_QWORD *)v36;
      do
      {
        for (i = 0; i != v8; ++i)
        {
          if (*(_QWORD *)v36 != v9)
            objc_enumerationMutation(v5);
          v11 = *(_QWORD *)(*((_QWORD *)&v35 + 1) + 8 * i);
          v12 = (void *)objc_msgSend(v5, "objectForKeyedSubscript:", v11);
          objc_msgSend(v6, "setValue:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", objc_msgSend(v12, "type")), v11);
        }
        v8 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v35, v47, 16);
      }
      while (v8);
    }
    return v6;
  }
  v13 = v4;
  v14 = (void *)objc_msgSend(v3, "device");
  obj = 0;
  v15 = malloc_type_calloc(v13, 0x18uLL, 0x1000040504FFAC1uLL);
  v16 = v15;
  if (v13)
  {
    v17 = v13;
    v18 = v15;
    do
    {
      *v18 = 3;
      v18 += 3;
      --v17;
    }
    while (v17);
  }
  v41[0] = 0;
  v42 = v13;
  v43 = v15;
  v44 = 0;
  v45 = v13;
  v46 = v15;
  v40[0] = v3;
  v40[1] = v3;
  v19 = (void *)objc_msgSend(v14, "newLibraryWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v40, 2), v41, &obj);
  free(v16);
  if (!v19)
  {
    if (obj)
    {
      v28 = ci_logger_api();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        CIKernelReflection::reflectConstants();
      CFShow(obj);
    }
    return 0;
  }
  v20 = (void *)objc_msgSend(v19, "newFunctionWithName:", CFSTR("ciKernelMain"));
  v21 = (void *)objc_msgSend(v20, "functionConstantsDictionary");
  v6 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v22 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v30, v39, 16);
  if (v22)
  {
    v23 = v22;
    v24 = *(_QWORD *)v31;
    do
    {
      for (j = 0; j != v23; ++j)
      {
        if (*(_QWORD *)v31 != v24)
          objc_enumerationMutation(v21);
        v26 = *(_QWORD *)(*((_QWORD *)&v30 + 1) + 8 * j);
        v27 = (void *)objc_msgSend(v21, "objectForKeyedSubscript:", v26);
        objc_msgSend(v6, "setValue:forKey:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", objc_msgSend(v27, "type")), v26);
      }
      v23 = objc_msgSend(v21, "countByEnumeratingWithState:objects:count:", &v30, v39, 16);
    }
    while (v23);
  }

  return v6;
}

std::string *CIKernelReflection::consolidate@<X0>(CIKernelReflection *this@<X0>, const CIKernelReflection *a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v7;
  _DWORD **v8;
  std::string *result;
  __int128 v10;
  int *var0;
  uint64_t v12;
  unint64_t v13;
  _DWORD *v14;
  int v15;

  v7 = *(_OWORD *)&a2->var3;
  *(_OWORD *)a3 = *(_OWORD *)&a2->var0;
  *(_OWORD *)(a3 + 16) = v7;
  v8 = (_DWORD **)(a3 + 32);
  std::vector<CI::KernelArgumentType>::vector((_QWORD *)(a3 + 32), (uint64_t)&a2->var5);
  *(_QWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 64) = 0;
  *(_QWORD *)(a3 + 72) = 0;
  result = std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)(a3 + 56), (__int128 *)a2->var6.var0, (__int128 *)a2->var6.var1, 0xAAAAAAAAAAAAAAABLL * (((char *)a2->var6.var1 - (char *)a2->var6.var0) >> 3));
  v10 = *(_OWORD *)&a2->var10;
  *(_OWORD *)(a3 + 80) = *(_OWORD *)&a2->var7;
  *(_OWORD *)(a3 + 96) = v10;
  *(_WORD *)(a3 + 112) = *(_WORD *)&a2->var12;
  *(_QWORD *)(a3 + 16) = this->var3;
  *(_DWORD *)(a3 + 92) = this->var9;
  var0 = this->var5.var0;
  v12 = (char *)this->var5.var1 - (char *)var0;
  if (v12)
  {
    v13 = v12 >> 2;
    v14 = *v8;
    if (v13 <= 1)
      v13 = 1;
    do
    {
      v15 = *var0++;
      *v14++ = v15;
      --v13;
    }
    while (v13);
  }
  *(_DWORD *)(a3 + 88) |= this->var8;
  *(_BYTE *)(a3 + 113) = this->var13;
  return result;
}

void sub_1922F6140(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 40) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void CIKernelReflection::~CIKernelReflection(CIKernelReflection *this)
{
  int *var0;
  vector<std::string, std::allocator<std::string>> *p_var6;

  p_var6 = &this->var6;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&p_var6);
  var0 = this->var5.var0;
  if (var0)
  {
    this->var5.var1 = var0;
    operator delete(var0);
  }
}

id KernelKindAlloc(int a1)
{
  if ((a1 - 1) > 3)
    return 0;
  else
    return objc_alloc((Class)objc_opt_class());
}

void sub_1922F6288(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1922F6424(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(exception_object);
}

uint64_t CI::XXHashHelper::add(CI::XXHashHelper *this, CFNumberRef number)
{
  CI::XXHashHelper *v2;
  size_t v4;
  uint64_t v6;
  uint64_t __src;

  v2 = this;
  if (number)
  {
    v6 = 0;
    if (CFNumberIsFloatType(number))
      CFNumberGetValue(number, kCFNumberDoubleType, &v6);
    else
      CFNumberGetValue(number, kCFNumberSInt64Type, &v6);
    __src = v6;
    this = v2;
    v4 = 8;
  }
  else
  {
    LODWORD(__src) = 0;
    v4 = 4;
  }
  return XXH64_update((uint64_t)this, (char *)&__src, v4);
}

CI::XXHashHelper *CI::XXHashHelper::add(CI::XXHashHelper *this, CFArrayRef theArray)
{
  CI::XXHashHelper *v3;
  CFIndex v4;
  uint64_t v5;
  const __CFString *ValueAtIndex;
  CFTypeID v7;

  if (theArray)
  {
    v3 = this;
    this = (CI::XXHashHelper *)CFArrayGetCount(theArray);
    if ((int)this >= 1)
    {
      v4 = 0;
      v5 = this;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v4);
        v7 = CFGetTypeID(ValueAtIndex);
        if (v7 == CFNumberGetTypeID())
        {
          this = (CI::XXHashHelper *)CI::XXHashHelper::add(v3, (CFNumberRef)ValueAtIndex);
        }
        else if (v7 == CFDataGetTypeID())
        {
          this = (CI::XXHashHelper *)CI::XXHashHelper::add(v3, (CFDataRef)ValueAtIndex);
        }
        else
        {
          this = (CI::XXHashHelper *)CFStringGetTypeID();
          if ((CI::XXHashHelper *)v7 == this)
            this = (CI::XXHashHelper *)CI::XXHashHelper::add(v3, ValueAtIndex);
        }
        ++v4;
      }
      while (v5 != v4);
    }
  }
  return this;
}

void sub_1922F6AD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  void *v12;

  objc_sync_exit(v12);
  a12(&a10);
  _Unwind_Resume(a1);
}

uint64_t CIKernelReflection::operator=(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  std::vector<CI::KernelArgumentType>::__move_assign(a1 + 32, (__n128 *)(a2 + 32));
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(a1 + 56));
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  v5 = *(_OWORD *)(a2 + 80);
  v6 = *(_OWORD *)(a2 + 96);
  *(_WORD *)(a1 + 112) = *(_WORD *)(a2 + 112);
  *(_OWORD *)(a1 + 80) = v5;
  *(_OWORD *)(a1 + 96) = v6;
  return a1;
}

void *CI::SerialStringArray::append(CI::SerialStringArray *this, const char *__src, size_t __n)
{
  int v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *result;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v6 = *(_DWORD *)this;
  v7 = *((int *)this + 1);
  v8 = (_BYTE *)*((_QWORD *)this + 5);
  if (v6 >= (int)v7)
  {
    v9 = (_BYTE *)*((_QWORD *)this + 3);
  }
  else
  {
    v9 = (_BYTE *)*((_QWORD *)this + 3);
    if (&v8[__n] < &v9[*((int *)this + 4)])
      goto LABEL_11;
  }
  v10 = *((int *)this + 3);
  v11 = *((int *)this + 2) + v7;
  *((_DWORD *)this + 1) = v11;
  v12 = v11 + v11 * v10;
  if (v12 <= (int)v8 + (int)__n - (int)v9 + 1)
    LODWORD(v12) = (_DWORD)v8 + __n - (_DWORD)v9 + 1;
  *((_DWORD *)this + 4) = v12;
  v13 = v8 - v9;
  *((_QWORD *)this + 3) = malloc_type_realloc(v9, (int)v12, 0x4F7D7E0EuLL);
  v14 = malloc_type_realloc(*((void **)this + 4), 8 * *((int *)this + 1), 0x10040436913F5uLL);
  v15 = *((_QWORD *)this + 3);
  v8 = (_BYTE *)(v15 + v13);
  *((_QWORD *)this + 4) = v14;
  *((_QWORD *)this + 5) = v15 + v13;
  v16 = *(unsigned int *)this;
  if ((int)v16 >= 1)
  {
    v17 = 0;
    v18 = v15 - (_QWORD)v9;
    v19 = 8 * v16;
    do
    {
      *(_QWORD *)(*((_QWORD *)this + 4) + v17) += v18;
      v17 += 8;
    }
    while (v19 != v17);
    v8 = (_BYTE *)*((_QWORD *)this + 5);
  }
LABEL_11:
  result = memcpy(v8, __src, __n);
  *(_BYTE *)(*((_QWORD *)this + 5) + __n) = 0;
  v22 = *((_QWORD *)this + 4);
  v21 = *((_QWORD *)this + 5);
  v23 = *(int *)this;
  *(_DWORD *)this = v23 + 1;
  *(_QWORD *)(v22 + 8 * v23) = v21;
  *((_QWORD *)this + 5) += __n + 1;
  return result;
}

void sub_1922F751C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;

  v3 = (void *)STACK[0x260];
  if (STACK[0x260])
  {
    STACK[0x268] = (unint64_t)v3;
    operator delete(v3);
  }
  CIKernelReflection::~CIKernelReflection((CIKernelReflection *)&STACK[0x338]);
  CIKernelReflection::~CIKernelReflection((CIKernelReflection *)(v1 - 224));
  _Unwind_Resume(a1);
}

void CoreAnalytics(NSString *a1, NSString *a2, int a3)
{
  unsigned __int8 v3;
  void *v4;
  NSObject *v5;
  int v6;
  int v7;
  NSString *v8;
  int v9;
  NSString *v10;
  _QWORD block[6];
  int v12;

  if (a1 && a2 && a3)
  {
    v4 = &unk_1EE281000;
    if ((v3 & 1) == 0)
    {
      v10 = a1;
      v9 = a3;
      v8 = a2;
      v4 = &unk_1EE281000;
      a2 = v8;
      a3 = v9;
      v7 = v6;
      a1 = v10;
      if (v7)
      {
        CoreAnalytics(NSString *,NSString *,int)::queue = (uint64_t)dispatch_queue_create("CoreImageAnalytics", 0);
        v4 = &unk_1EE281000;
        a1 = v10;
        a2 = v8;
        a3 = v9;
      }
    }
    v5 = *((_QWORD *)v4 + 190);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___ZL13CoreAnalyticsP8NSStringS0_i_block_invoke;
    block[3] = &unk_1E2EC47A0;
    block[4] = a1;
    block[5] = a2;
    v12 = a3;
    dispatch_async(v5, block);
  }
}

void sub_1922F7804(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(exception_object);
}

void sub_1922F7A88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(exception_object);
}

void sub_1922F7E50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, void (*a20)(char *))
{
  a20(&a18);
  _Unwind_Resume(a1);
}

void sub_1922F8100(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(exception_object);
}

void sub_1922F8354(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(exception_object);
}

void sub_1922F8870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void (*a13)(char *))
{
  a13(&a11);
  _Unwind_Resume(a1);
}

void sub_1922F8D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void (*a13)(char *))
{
  a13(&a11);
  _Unwind_Resume(a1);
}

void sub_1922F9214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void (*a13)(char *))
{
  a13(&a11);
  _Unwind_Resume(a1);
}

void sub_1922F9B2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, CIKernelReflection *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,CIKernelReflection *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48)
{
  CIKernelReflection::~CIKernelReflection((CIKernelReflection *)&a48);
  _Unwind_Resume(a1);
}

void sub_1922F9D44(_Unwind_Exception *a1)
{
  __44__CIKernel_kernelNamesFromMetalLibraryData___block_invoke();
  _Unwind_Resume(a1);
}

void sub_1922F9F48(_Unwind_Exception *a1)
{
  __40__CIKernel_kernelNamesFromMetalLibrary___block_invoke();
  _Unwind_Resume(a1);
}

void CI::Kernel::set_roi_selector(CI::Kernel *this, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = (CFTypeRef)*((_QWORD *)this + 14);
  if (v3 != cf)
  {
    if (cf)
    {
      CFRetain(cf);
      v3 = (CFTypeRef)*((_QWORD *)this + 14);
    }
    if (v3)
      CFRelease(v3);
    *((_QWORD *)this + 14) = cf;
  }
}

const char *expected_argument_type(int a1)
{
  if ((a1 - 1) > 0x1C)
    return "";
  else
    return off_1E2EC4820[a1 - 1];
}

void sub_1922FAD44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(exception_object);
}

void sub_1922FB0D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;

  MEMORY[0x194025AAC](v20, 0x10F1C40D6B4BB53);
  _Unwind_Resume(a1);
}

void sub_1922FBAB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40AA91B0B9);
  _Unwind_Resume(a1);
}

void sub_1922FBC54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(exception_object);
}

void sub_1922FBFBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  uint64_t v18;

  MEMORY[0x194025AAC](v18, 0x10F1C409D028DB2);
  _Unwind_Resume(a1);
}

void sub_1922FC61C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C4042639F6FLL);
  _Unwind_Resume(a1);
}

void sub_1922FC7C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(exception_object);
}

void sub_1922FCA8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(exception_object);
}

void sub_1922FCCFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(4 * a2);
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:nn180100](uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 3;
      *(_QWORD *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

char *std::vector<CI::KernelArgumentType>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 62)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

std::string *std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(std::string *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  std::string *v6;

  if (a4)
  {
    v6 = result;
    std::vector<CI::SWRendererFunctionInputNode>::__vallocate[abi:nn180100](result, a4);
    result = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>((int)v6 + 16, a2, a3, (std::string *)v6->__r_.__value_.__l.__size_);
    v6->__r_.__value_.__l.__size_ = (std::string::size_type)result;
  }
  return result;
}

void sub_1922FD35C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

std::string *std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(int a1, __int128 *a2, __int128 *a3, std::string *this)
{
  __int128 *v6;
  __int128 v7;

  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)v6, *((_QWORD *)v6 + 1));
      }
      else
      {
        v7 = *v6;
        this->__r_.__value_.__r.__words[2] = *((_QWORD *)v6 + 2);
        *(_OWORD *)&this->__r_.__value_.__l.__data_ = v7;
      }
      v6 = (__int128 *)((char *)v6 + 24);
      ++this;
    }
    while (v6 != a3);
  }
  return this;
}

void std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::string>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

uint64_t ___ZL29check_and_emit_compile_errorsP8NSStringPvP14NSMutableArray_block_invoke(uint64_t result, void *a2, _BYTE *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  const char *v7;
  size_t v8;
  _QWORD *v9;
  const std::locale::facet *v10;
  std::locale v11;

  v3 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
  v4 = *(_QWORD *)(v3 + 24);
  if (v4 == *(_DWORD *)(*(_QWORD *)(result + 40) + 4))
  {
    v6 = result;
    v7 = (const char *)objc_msgSend(a2, "UTF8String");
    v8 = strlen(v7);
    v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A50], (uint64_t)v7, v8);
    std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(_QWORD *)(*v9 - 24)));
    v10 = std::locale::use_facet(&v11, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10);
    std::locale::~locale(&v11);
    std::ostream::put();
    result = std::ostream::flush();
    *a3 = 1;
    v3 = *(_QWORD *)(*(_QWORD *)(v6 + 32) + 8);
    v4 = *(_QWORD *)(v3 + 24);
  }
  *(_QWORD *)(v3 + 24) = v4 + 1;
  return result;
}

void sub_1922FD540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

_QWORD *std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  _BYTE v13[16];
  std::locale v14;

  MEMORY[0x194025998](v13, a1);
  if (v13[0])
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = *(_DWORD *)(v6 + 8);
    v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&v14, MEMORY[0x1E0DE4A90]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20)
      v11 = a2 + a3;
    else
      v11 = a2;
    if (!std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  MEMORY[0x1940259A4](v13);
  return a1;
}

void sub_1922FD65C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  MEMORY[0x1940259A4](&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  int64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void *__p[2];
  char v18;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if (v12 >= 1)
    {
      std::string::basic_string[abi:nn180100](__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(_QWORD *)v6 + 96))(v6, v13, v12);
      if (v18 < 0)
        operator delete(__p[0]);
      if (v14 != v12)
        return 0;
    }
    v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v15) == v15)
      *(_QWORD *)(a5 + 24) = 0;
    else
      return 0;
  }
  return v6;
}

void sub_1922FD7A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::basic_string[abi:nn180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

void CIKLLibraryMaker::CIKLLibraryMaker(CIKLLibraryMaker *this, uint64_t a2)
{
  uint64_t v4;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = objc_opt_new();
  v4 = objc_opt_new();
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 4) = (char *)this + 40;
  *((_QWORD *)this + 2) = v4;
  *((_QWORD *)this + 3) = a2;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  std::vector<short>::reserve((void **)this + 7, 0x10uLL);
  CIKLLibraryMaker::createMetalLibraryFromFoslPool(this, a2);
}

void sub_1922FD8F0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  _QWORD **v4;
  void *v6;

  v6 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 64) = v6;
    operator delete(v6);
  }
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v2, *v4);
  _Unwind_Resume(a1);
}

void std::vector<short>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int16 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 1)
  {
    if ((a2 & 0x8000000000000000) != 0)
      abort();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<short>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFELL];
    v9 = &v6[2 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_WORD *)v11 - 1);
        v11 -= 2;
        *((_WORD *)v12 - 1) = v13;
        v12 -= 2;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void CIKLLibraryMaker::createMetalLibraryFromFoslPool(CIKLLibraryMaker *this, uint64_t a2)
{
  int NumKernels;
  __int16 v5;
  __CFString *v6;
  __CFString *v7;
  CIKernelLibrary *v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  _QWORD v12[6];
  __int16 v13;

  NumKernels = fosl_filter_kernelpool_getNumKernels(a2);
  if (NumKernels << 16 >= 0x10000)
  {
    v5 = NumKernels;
    if (CIKLLibraryMaker::createMetalLibraryFromFoslPool(void *)::onceToken != -1)
      dispatch_once(&CIKLLibraryMaker::createMetalLibraryFromFoslPool(void *)::onceToken, &__block_literal_global_364);
    if (CIKLLibraryMaker::createMetalLibraryFromFoslPool(void *)::_cikl2metal_preamble)
    {
      v12[0] = MEMORY[0x1E0C809B0];
      v12[1] = 3221225472;
      v12[2] = ___ZN16CIKLLibraryMaker30createMetalLibraryFromFoslPoolEPv_block_invoke_2;
      v12[3] = &__block_descriptor_50_e89_v16__0____sFILE__iiss___sbuf__i_i_v___________sbuf__i_____sFILEX_i_3C__1C____sbuf__i_iq_8l;
      v13 = v5;
      v12[4] = this;
      v12[5] = a2;
      v6 = (__CFString *)stream_to_string((uint64_t)v12);
      v7 = v6;
      v11 = 0;
      if (v6 && -[__CFString length](v6, "length", v11))
      {
        v8 = +[CIKernelLibrary libraryWithSource:error:](CIKernelLibrary, "libraryWithSource:error:", v7, &v11);
        *(_QWORD *)this = v8;
        if (v8)
        {
LABEL_14:

          return;
        }
      }
      else
      {
        v9 = ci_logger_compile();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          CIKLLibraryMaker::createMetalLibraryFromFoslPool();
        if (*(_QWORD *)this)
          goto LABEL_14;
      }
      v10 = ci_logger_compile();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        CIKLLibraryMaker::createMetalLibraryFromFoslPool();
      goto LABEL_14;
    }
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<short>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(2 * a2);
}

void ___ZN16CIKLLibraryMaker30createMetalLibraryFromFoslPoolEPv_block_invoke()
{
  char *v0;
  char *v1;
  id v2;
  unint64_t size;

  size = 0;
  v0 = getsectdatafromFramework("CoreImage", "__TEXT", "__cikl2metal_pre", &size);
  if (v0)
  {
    v1 = v0;
    v2 = objc_alloc(MEMORY[0x1E0CB3940]);
    CIKLLibraryMaker::createMetalLibraryFromFoslPool(void *)::_cikl2metal_preamble = objc_msgSend(v2, "initWithBytesNoCopy:length:encoding:freeWhenDone:", v1, size, 1, 0);
    if (CIKLLibraryMaker::createMetalLibraryFromFoslPool(void *)::_cikl2metal_preamble)
      return;
    goto LABEL_3;
  }
  NSLog(CFSTR("Could not initialize cikl2metal preamble file"));
  if (!CIKLLibraryMaker::createMetalLibraryFromFoslPool(void *)::_cikl2metal_preamble)
LABEL_3:
    NSLog(CFSTR("Can't create the cikl2metal preamble string"));
}

void ___ZN16CIKLLibraryMaker30createMetalLibraryFromFoslPoolEPv_block_invoke_2(uint64_t a1, __sFILE *a2)
{
  CIKLLibraryMaker *v4;
  uint64_t v5;
  FILE **v6;
  uint64_t KernelByIdx;
  uint64_t v8;
  const char *KernelName;
  char *PrintedKernel;
  BOOL v11;
  NSObject *v12;
  uint8_t buf;
  _BYTE v14[15];

  v4 = *(CIKLLibraryMaker **)(a1 + 32);
  fputs((const char *)objc_msgSend((id)CIKLLibraryMaker::createMetalLibraryFromFoslPool(void *)::_cikl2metal_preamble, "UTF8String"), a2);
  if (*(__int16 *)(a1 + 48) >= 1)
  {
    v5 = 0;
    v6 = (FILE **)MEMORY[0x1E0C80C10];
    do
    {
      KernelByIdx = fosl_filter_kernelpool_getKernelByIdx(*(_QWORD *)(a1 + 40), v5);
      if (KernelByIdx)
      {
        v8 = KernelByIdx;
        KernelName = (const char *)fosl_filter_kernelpool_getKernelName(KernelByIdx);
        PrintedKernel = (char *)fosl_filter_kernelpool_getPrintedKernel(v8);
        CIKLLibraryMaker::analyzeCIKLSource(v4, a2, PrintedKernel, KernelName);
        if (KernelName)
          v11 = PrintedKernel == 0;
        else
          v11 = 1;
        if (v11)
        {
          NSLog(CFSTR("No valid kernels were found for the kernel"));
          v12 = ci_logger_compile();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            ___ZN16CIKLLibraryMaker30createMetalLibraryFromFoslPoolEPv_block_invoke_2_cold_1(&buf, v14, v12);
        }
        else if (FOSL_PRINT_KERNEL_AST())
        {
          fprintf(*v6, "Printed AST of kernel %s:\n%s\n", KernelName, PrintedKernel);
        }
      }
      v5 = (v5 + 1);
    }
    while ((int)v5 < *(__int16 *)(a1 + 48));
  }
}

void CIKLLibraryMaker::analyzeCIKLSource(CIKLLibraryMaker *this, __sFILE *a2, char *a3, const char *a4)
{
  char *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD v11[14];
  _QWORD v12[3];
  char v13;
  _QWORD v14[3];
  char v15;
  _QWORD v16[3];
  __int16 v17;
  _QWORD v18[3];
  __int16 v19;
  _QWORD v20[3];
  __int16 v21;
  _QWORD v22[6];
  void *v23[3];
  _QWORD v24[6];
  uint64_t v25[3];

  v8 = (char *)this + 32;
  v9 = (_QWORD *)((char *)this + 40);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)this + 32, *((_QWORD **)this + 5));
  *((_QWORD *)this + 4) = v9;
  *v9 = 0;
  v10 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 8) = v10;
  v24[0] = 0;
  v24[1] = v24;
  v24[2] = 0x4812000000;
  v24[3] = __Block_byref_object_copy__11;
  v24[4] = __Block_byref_object_dispose__11;
  v24[5] = "";
  std::set<char const*>::set[abi:nn180100](v25, (uint64_t)v8);
  v22[0] = 0;
  v22[1] = v22;
  v22[2] = 0x4812000000;
  v22[3] = __Block_byref_object_copy__377;
  v22[4] = __Block_byref_object_dispose__378;
  v22[5] = "";
  std::vector<short>::vector(v23, (uint64_t)this + 56);
  v20[0] = 0;
  v20[1] = v20;
  v20[2] = 0x2020000000;
  v21 = 0;
  v18[0] = 0;
  v18[1] = v18;
  v18[2] = 0x2020000000;
  v19 = 0;
  v16[0] = 0;
  v16[1] = v16;
  v16[2] = 0x2020000000;
  v17 = -1;
  v14[0] = 0;
  v14[1] = v14;
  v14[2] = 0x2020000000;
  v15 = 0;
  v12[0] = 0;
  v12[1] = v12;
  v12[2] = 0x2020000000;
  v13 = 0;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = ___ZN16CIKLLibraryMaker17analyzeCIKLSourceEP7__sFILEPKcS3__block_invoke;
  v11[3] = &unk_1E2EC4750;
  v11[4] = v16;
  v11[5] = v20;
  v11[6] = v18;
  v11[7] = v14;
  v11[8] = v12;
  v11[9] = v24;
  v11[10] = v22;
  v11[11] = this;
  v11[12] = a4;
  v11[13] = a2;
  CIKLLibraryMaker::tokenizer((uint64_t)this, a3, (uint64_t)a2, (uint64_t)v11);
  _Block_object_dispose(v12, 8);
  _Block_object_dispose(v14, 8);
  _Block_object_dispose(v16, 8);
  _Block_object_dispose(v18, 8);
  _Block_object_dispose(v20, 8);
  _Block_object_dispose(v22, 8);
  if (v23[0])
  {
    v23[1] = v23[0];
    operator delete(v23[0]);
  }
  _Block_object_dispose(v24, 8);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)v25, (_QWORD *)v25[1]);
}

void sub_1922FDF00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  uint64_t v39;
  uint64_t v40;
  void *v42;

  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a39, 8);
  _Block_object_dispose((const void *)(v40 - 240), 8);
  v42 = *(void **)(v40 - 192);
  if (v42)
  {
    *(_QWORD *)(v40 - 184) = v42;
    operator delete(v42);
  }
  _Block_object_dispose((const void *)(v40 - 168), 8);
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v39, *(_QWORD **)(v40 - 112));
  _Unwind_Resume(a1);
}

_QWORD *__Block_byref_object_copy__11(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  result[6] = a2[6];
  v2 = a2 + 7;
  v3 = a2[7];
  result[7] = v3;
  v4 = result + 7;
  v5 = a2[8];
  result[8] = v5;
  if (v5)
  {
    *(_QWORD *)(v3 + 16) = v4;
    a2[6] = v2;
    *v2 = 0;
    a2[8] = 0;
  }
  else
  {
    result[6] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(a1 + 48, *(_QWORD **)(a1 + 56));
}

__n128 __Block_byref_object_copy__377(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__378(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void CIKLLibraryMaker::tokenizer(uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4)
{
  unsigned __int16 v7;
  uint64_t v8;
  int v9;
  uint64_t i;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;

  v7 = 0;
  v8 = MEMORY[0x1E0C80978];
  while (1)
  {
    v9 = *a2;
    if (v9 == 10)
    {
      (*(void (**)(uint64_t, _BYTE *, uint64_t, _QWORD, uint64_t))(a4 + 16))(a4, a2, 1, v7++, a3);
      goto LABEL_13;
    }
    if (!*a2)
      break;
    if ((char)v9 < 0)
    {
      if (__maskrune((char)v9, 0x4000uLL))
        goto LABEL_6;
LABEL_16:
      v13 = (char)*a2;
      if ((v13 & 0x80000000) != 0)
      {
        if (__maskrune(v13, 0x500uLL))
          goto LABEL_21;
      }
      else if ((*(_DWORD *)(v8 + 4 * v13 + 60) & 0x500) != 0)
      {
        goto LABEL_21;
      }
      if (*a2 == 95)
      {
LABEL_21:
        for (i = 1; ; ++i)
        {
          v14 = (char)a2[i];
          if ((v14 & 0x80000000) != 0)
          {
            if (__maskrune(v14, 0x500uLL))
              continue;
          }
          else if ((*(_DWORD *)(v8 + 4 * v14 + 60) & 0x500) != 0)
          {
            continue;
          }
          if (a2[i] != 95)
            goto LABEL_11;
        }
      }
      (*(void (**)(uint64_t, _BYTE *, uint64_t, _QWORD, uint64_t))(a4 + 16))(a4, a2, 1, v7, a3);
LABEL_13:
      LODWORD(i) = 1;
      goto LABEL_14;
    }
    if ((*(_DWORD *)(v8 + 4 * (char)v9 + 60) & 0x4000) == 0)
      goto LABEL_16;
LABEL_6:
    i = 0;
    do
    {
      v11 = (char)a2[i + 1];
      if ((v11 & 0x80000000) != 0)
        v12 = __maskrune(v11, 0x4000uLL);
      else
        v12 = *(_DWORD *)(v8 + 4 * v11 + 60) & 0x4000;
      ++i;
    }
    while (v12);
LABEL_11:
    (*(void (**)(uint64_t, _BYTE *, uint64_t, _QWORD, uint64_t))(a4 + 16))(a4, a2, i, v7, a3);
LABEL_14:
    a2 += i;
  }
}

void ___ZN16CIKLLibraryMaker17analyzeCIKLSourceEP7__sFILEPKcS3__block_invoke(uint64_t a1, char *__s1, int a3, int a4)
{
  const char *v4;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  BOOL v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  char *v27;
  unint64_t v28;
  _WORD *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  const char *v33;
  char v34;
  unsigned int v35;
  int v36;
  const char *v38;
  BOOL v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  void *v47;
  void *v48;
  int v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  uint64_t j;
  const char *v54;
  char *k;
  char *v56;
  char *v57;
  __int16 v58;
  int v59;
  uint64_t i;
  unsigned int v61;
  int v62;
  unsigned int v63;
  BOOL v64;
  unint64_t v65;
  void *v67;
  int v68;
  _BOOL4 v69;
  int v70;
  char *v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  _BYTE v76[128];
  uint64_t v77;

  v70 = a3;
  v4 = __s1;
  v77 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 88);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v8 = *(__int16 *)(v7 + 24);
  *(_WORD *)(v7 + 24) = a4;
  v9 = *__s1;
  if (v9 == 40)
  {
    ++*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v9 = *__s1;
  }
  if (v9 == 41)
  {
    --*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v9 = *__s1;
  }
  if (v9 == 123)
  {
    ++*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    v9 = *__s1;
  }
  v10 = v8 + 1;
  if (v9 == 125)
    --*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
  if (v10 == a4)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 0;
  if (*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) || *__s1 == 125)
  {
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8);
    v12 = *(_QWORD *)(v11 + 56);
    if (*(_QWORD *)(v11 + 48) != v12 && *__s1 == 41)
    {
      v14 = *(unsigned __int16 *)(v12 - 2);
      v13 = v12 - 2;
      if (*(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) == v14)
      {
        v15 = *(__s1 - 1);
        if (v15 == 40)
          v4 = "_dst)";
        else
          v4 = ", _dst)";
        if (v15 == 40)
          v16 = 5;
        else
          v16 = 7;
        v70 = v16;
        *(_QWORD *)(v11 + 56) = v13;
      }
    }
    v17 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8);
    v20 = *(_QWORD **)(v17 + 56);
    v18 = (_QWORD *)(v17 + 56);
    v19 = v20;
    if (v20)
    {
      v21 = v18;
      do
      {
        v22 = v19[4];
        v23 = v22 >= (unint64_t)v4;
        if (v22 >= (unint64_t)v4)
          v24 = v19;
        else
          v24 = v19 + 1;
        if (v23)
          v21 = v19;
        v19 = (_QWORD *)*v24;
      }
      while (*v24);
      if (v21 != v18 && (unint64_t)v4 >= v21[4])
      {
        v25 = *(_QWORD **)(*(_QWORD *)(a1 + 80) + 8);
        v26 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v27 = (char *)v25[7];
        v28 = v25[8];
        if ((unint64_t)v27 >= v28)
        {
          v40 = (char *)v25[6];
          v41 = v27 - v40;
          if (v27 - v40 <= -3)
            abort();
          v42 = v41 >> 1;
          v43 = v28 - (_QWORD)v40;
          if (v43 <= (v41 >> 1) + 1)
            v44 = v42 + 1;
          else
            v44 = v43;
          if (v43 >= 0x7FFFFFFFFFFFFFFELL)
            v45 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v45 = v44;
          if (v45)
          {
            v46 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<short>>((uint64_t)(v25 + 8), v45);
            v40 = (char *)v25[6];
            v27 = (char *)v25[7];
          }
          else
          {
            v46 = 0;
          }
          v56 = &v46[2 * v42];
          v57 = &v46[2 * v45];
          *(_WORD *)v56 = *(_WORD *)(v26 + 24);
          v29 = v56 + 2;
          while (v27 != v40)
          {
            v58 = *((_WORD *)v27 - 1);
            v27 -= 2;
            *((_WORD *)v56 - 1) = v58;
            v56 -= 2;
          }
          v25[6] = v56;
          v25[7] = v29;
          v25[8] = v57;
          if (v40)
            operator delete(v40);
        }
        else
        {
          *(_WORD *)v27 = *(_WORD *)(v26 + 24);
          v29 = v27 + 2;
        }
        v25[7] = v29;
      }
    }
    if (v70 == 3)
    {
      v69 = 0;
      if (!strncmp(v4, "_dc", 3uLL))
      {
        v4 = "_dst.coord()";
        v59 = 12;
      }
      else
      {
        v59 = 3;
      }
      goto LABEL_94;
    }
    v69 = 0;
    goto LABEL_123;
  }
  if (v10 != a4)
  {
LABEL_111:
    v69 = 0;
    goto LABEL_112;
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) = 0;
  v30 = MEMORY[0x1E0C80978];
  if (a3 == 5 && !strncmp("const ", __s1, 6uLL))
  {
    for (i = 0; ; ++i)
    {
      v61 = v4[i];
      if ((v61 & 0x80000000) != 0)
      {
        if (__maskrune(v61, 0x500uLL))
          continue;
      }
      else if ((*(_DWORD *)(v30 + 4 * v61 + 60) & 0x500) != 0)
      {
        continue;
      }
      v62 = v4[i];
      if ((v62 - 40) >= 8)
      {
        v63 = v62 - 32;
        v64 = v63 > 0x3F;
        v65 = (1 << v63) & 0x8000000020000001;
        if (v64 || v65 == 0)
        {
          v67 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithBytes:length:encoding:", v4, i, 1);
          if (objc_msgSend(*(id *)(v6 + 16), "containsObject:", v67))
          {
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 1;
            v70 = 5;
          }
          else
          {
            objc_msgSend(*(id *)(v6 + 16), "addObject:", v67);
            v70 = 8;
            v4 = "constant";
          }

          goto LABEL_111;
        }
      }
    }
  }
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  while (1)
  {
    v35 = v4[v31];
    if ((v35 & 0x80000000) != 0)
    {
      v36 = __maskrune(v35, 0x500uLL);
      LOBYTE(v35) = v4[v31];
      if (v36)
        goto LABEL_48;
    }
    else if ((*(_DWORD *)(v30 + 4 * v35 + 60) & 0x500) != 0)
    {
      goto LABEL_48;
    }
    if (v35 - 32 > 0x3F
      || ((1 << (v35 - 32)) & 0x8000000000001301) == 0)
    {
      break;
    }
LABEL_48:
    if ((v34 & 1) != 0)
      v38 = &v4[v31];
    else
      v38 = 0;
    v39 = v32 != 0;
    if (!v32)
      v32 = v38;
    if (v35 == 40)
      v33 = &v4[v31];
    if (v35 == 32)
      v34 = 1;
    else
      v34 &= v39;
    ++v31;
  }
  v47 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithBytes:length:encoding:", v4, v31, 1);
  v48 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithBytes:length:encoding:", v32, v33 - v32, 1);
  v49 = strncmp(*(const char **)(a1 + 96), v32, v33 - v32);
  v69 = v49 == 0;
  if (objc_msgSend(*(id *)(v6 + 8), "containsObject:", v47))
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) = 1;
    if (!v49)
      goto LABEL_82;
  }
  else
  {
    objc_msgSend(*(id *)(v6 + 8), "addObject:", v47);
    if (!v49)
      goto LABEL_82;
  }
  v74 = 0u;
  v75 = 0u;
  v72 = 0u;
  v73 = 0u;
  v50 = objc_msgSend(&unk_1E2F1DC90, "countByEnumeratingWithState:objects:count:", &v72, v76, 16);
  if (v50)
  {
    v51 = (char *)&v4[v31];
    v52 = *(_QWORD *)v73;
    do
    {
      for (j = 0; j != v50; ++j)
      {
        if (*(_QWORD *)v73 != v52)
          objc_enumerationMutation(&unk_1E2F1DC90);
        v54 = (const char *)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@%@("), *(_QWORD *)(*((_QWORD *)&v72 + 1) + 8 * j), v48), "UTF8String");
        v71 = 0;
        for (k = v51; ; k = v71 + 1)
        {
          v71 = strstr(k, v54);
          if (!v71)
            break;
          std::__tree<char const*>::__emplace_unique_key_args<char const*,char const* const&>((uint64_t **)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 48), (unint64_t *)&v71, (uint64_t *)&v71);
        }
      }
      v50 = objc_msgSend(&unk_1E2F1DC90, "countByEnumeratingWithState:objects:count:", &v72, v76, 16);
    }
    while (v50);
  }
LABEL_82:

LABEL_112:
  if (!*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24)
    && *v4 == 41
    && !*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24)
    && v4[1] == 32
    && v4[2] == 123)
  {
    v68 = *((unsigned __int8 *)v4 - 1);
    if (v68 == 40)
      v4 = "coreimage::destination _dst)";
    else
      v4 = ", coreimage::destination _dst)";
    if (v68 == 40)
      v59 = 28;
    else
      v59 = 30;
LABEL_94:
    v70 = v59;
  }
LABEL_123:
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24)
    && !*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24))
  {
    if (v69)
      fwrite("[[stitchable]] ", 0xFuLL, 1uLL, *(FILE **)(a1 + 104));
    fprintf(*(FILE **)(a1 + 104), "%.*s", v70, v4);
  }
}

uint64_t *std::set<char const*>::set[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::set<char const*>::insert[abi:nn180100]<std::__tree_const_iterator<char const*,std::__tree_node<char const*,void *> *,long>>(a1, *(_QWORD **)a2, (_QWORD *)(a2 + 8));
  return a1;
}

void sub_1922FE904(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::set<char const*>::insert[abi:nn180100]<std::__tree_const_iterator<char const*,std::__tree_node<char const*,void *> *,long>>(uint64_t *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t **v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = std::__tree<char const*>::__emplace_hint_unique_key_args<char const*,char const* const&>(v5, v6, v4 + 4, v4 + 4);
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *std::__tree<char const*>::__emplace_hint_unique_key_args<char const*,char const* const&>(uint64_t **a1, _QWORD *a2, unint64_t *a3, uint64_t *a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t v10;
  uint64_t v11;

  v6 = (uint64_t **)std::__tree<char const*>::__find_equal<char const*>(a1, a2, &v11, &v10, a3);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    v7 = (uint64_t *)operator new(0x28uLL);
    v7[4] = *a4;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, v11, v8, v7);
  }
  return v7;
}

_QWORD *std::__tree<char const*>::__find_equal<char const*>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, unint64_t *a5)
{
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  BOOL v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = a2[4], *a5 < v7))
  {
    v8 = *a2;
    if ((_QWORD *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (_QWORD *)*a2;
      do
      {
        v10 = v9;
        v9 = (_QWORD *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (_QWORD *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *a5;
    if (v10[4] < *a5)
      goto LABEL_17;
    v16 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = v16;
          v18 = v16[4];
          if (v15 >= v18)
            break;
          v16 = (_QWORD *)*v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = (_QWORD *)v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (_QWORD *)a2[1];
    do
    {
      a4 = v12;
      v12 = (_QWORD *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (_QWORD *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= a4[4])
  {
    v20 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = v20;
          v22 = v20[4];
          if (v6 >= v22)
            break;
          v20 = (_QWORD *)*v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = (_QWORD *)v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

_QWORD *std::vector<short>::vector(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  int64_t v5;
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = *(const void **)a2;
  v3 = *(_QWORD *)(a2 + 8);
  v5 = v3 - *(_QWORD *)a2;
  if (v3 != *(_QWORD *)a2)
  {
    std::vector<short>::__vallocate[abi:nn180100](a1, v5 >> 1);
    v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

char *std::vector<short>::__vallocate[abi:nn180100](_QWORD *a1, uint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 < 0)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<short>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

uint64_t *std::__tree<char const*>::__emplace_unique_key_args<char const*,char const* const&>(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = v5[4];
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

void CIKLLibraryMaker::~CIKLLibraryMaker(id *this)
{
  id v2;

  v2 = this[7];
  if (v2)
  {
    this[8] = v2;
    operator delete(v2);
  }
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(this + 4), this[5]);
}

void sub_1922FED6C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 56);
  if (v3)
  {
    *(_QWORD *)(v1 + 64) = v3;
    operator delete(v3);
  }
  std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy(v1 + 32, *(_QWORD **)(v1 + 40));
  _Unwind_Resume(a1);
}

__n128 std::vector<CI::KernelArgumentType>::__move_assign(uint64_t a1, __n128 *a2)
{
  void *v4;
  __n128 result;

  v4 = *(void **)a1;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = v4;
    operator delete(v4);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  result = *a2;
  *(__n128 *)a1 = *a2;
  *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

char *std::vector<CI::KernelArgumentType>::__assign_with_size[abi:nn180100]<CI::KernelArgumentType*,CI::KernelArgumentType*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 2)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62)
      abort();
    v10 = v8 >> 1;
    if (v8 >> 1 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<CI::KernelArgumentType>::__vallocate[abi:nn180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 2;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

void std::vector<std::string>::__assign_with_size[abi:nn180100]<std::string*,std::string*>(std::vector<std::string> *this, std::string *__str, __int128 *a3, unint64_t a4)
{
  int v8;
  std::string *begin;
  unint64_t v10;
  unint64_t v11;
  std::string *v12;
  std::string *v13;
  std::string *v14;
  std::string *v15;
  std::vector<std::string>::pointer end;

  v8 = (_DWORD)this + 16;
  begin = this->__begin_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_cap_.__value_ - (char *)this->__begin_) >> 3) < a4)
  {
    std::vector<std::string>::__vdeallocate(this);
    if (a4 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v10 = 0x5555555555555556 * (((char *)this->__end_cap_.__value_ - (char *)this->__begin_) >> 3);
    if (v10 <= a4)
      v10 = a4;
    if (0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_cap_.__value_ - (char *)this->__begin_) >> 3) >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v10;
    std::vector<CI::SWRendererFunctionInputNode>::__vallocate[abi:nn180100](this, v11);
    v12 = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(v8, (__int128 *)__str, a3, this->__end_);
    goto LABEL_11;
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_ - (char *)begin) >> 3) < a4)
  {
    v13 = (std::string *)((char *)__str + 8 * (((char *)this->__end_ - (char *)begin) >> 3));
    std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::string *,std::string *,std::string *,0>(__str, v13, begin);
    v12 = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(v8, (__int128 *)v13, a3, this->__end_);
LABEL_11:
    this->__end_ = v12;
    return;
  }
  std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::string *,std::string *,std::string *,0>(__str, (std::string *)a3, begin);
  v15 = v14;
  end = this->__end_;
  if (end != v14)
  {
    do
    {
      if (SHIBYTE(end[-1].__r_.__value_.__r.__words[2]) < 0)
        operator delete(end[-1].__r_.__value_.__l.__data_);
      --end;
    }
    while (end != v15);
  }
  this->__end_ = v15;
}

void sub_1922FF048(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1922FF050(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

std::string *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::string *,std::string *,std::string *,0>(std::string *__str, std::string *a2, std::string *this)
{
  const std::string *v4;

  v4 = __str;
  if (__str != a2)
  {
    do
      std::string::operator=(this++, v4++);
    while (v4 != a2);
    return a2;
  }
  return (std::string *)v4;
}

CI::MetalKernel *CI::PrecompiledGeneralKernel::PrecompiledGeneralKernel(CI::MetalKernel *a1, const char *a2, CIKernelLibrary *a3, char *a4, char *a5, char a6, void **a7, uint64_t a8, unsigned int a9, int a10, int a11, NSDictionary *a12, NSDictionary *a13, uint64_t *a14, char a15)
{
  CI::MetalKernel *v21;

  v21 = CI::MetalKernel::MetalKernel(a1, a2, a3, a12, a13, a15, ((unint64_t)a4 | (unint64_t)a5) != 0);
  CI::GeneralKernel::GeneralKernel((uint64_t)v21 + 80, a2, a4, a5, a6, a7, a8, a9, a10, a11, a14, 0);
  *(_QWORD *)a1 = &unk_1E2EBE400;
  *((_QWORD *)a1 + 10) = &unk_1E2EBE448;
  return a1;
}

void sub_1922FF180(_Unwind_Exception *a1)
{
  id *v1;

  CI::MetalKernel::~MetalKernel(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZL13CoreAnalyticsP8NSStringS0_i_block_invoke()
{
  return AnalyticsSendEventLazy();
}

uint64_t ___ZL13CoreAnalyticsP8NSStringS0_i_block_invoke_2(uint64_t a1)
{
  const __CFString *v2;
  uint64_t v3;
  const __CFString *v4;
  __CFString *v5;
  const __CFString *v6;
  const __CFString *v7;
  const __CFString *v8;
  _QWORD v10[6];
  _QWORD v11[3];
  __int128 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v2 = (const __CFString *)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle"), "bundleIdentifier");
  v3 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle"), "bundlePath"), "pathExtension");
  v4 = CoreAnayticsAppIndentifier(v2);
  v5 = (__CFString *)objc_msgSend(MEMORY[0x1E0CA58E0], "extensionPointRecordForCurrentProcess");
  if (v5)
    v5 = (__CFString *)-[__CFString identifier](v5, "identifier");
  v10[0] = CFSTR("identifier");
  v10[1] = CFSTR("extension");
  v6 = &stru_1E2ECD1B0;
  if (v2)
    v7 = v2;
  else
    v7 = &stru_1E2ECD1B0;
  if (v3)
    v8 = (const __CFString *)v3;
  else
    v8 = &stru_1E2ECD1B0;
  if (v5)
    v8 = v5;
  v11[0] = v7;
  v11[1] = v8;
  if (v4)
    v6 = v4;
  v11[2] = v6;
  v10[2] = CFSTR("client");
  v10[3] = CFSTR("kernelType");
  v12 = *(_OWORD *)(a1 + 32);
  v10[4] = CFSTR("kernelMethod");
  v10[5] = CFSTR("kernelCount");
  v13 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", *(unsigned int *)(a1 + 48));
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v11, v10, 6);
}

CI::Buffer *CI::Buffer::Buffer(CI::Buffer *this, CFTypeRef cf)
{
  unsigned int v3;
  CFTypeRef v4;

  *(_QWORD *)this = &unk_1E2EBED30;
  *((_DWORD *)this + 2) = 1;
  *((_QWORD *)this + 2) = off_1E2EBBEC0;
  do
    v3 = __ldaxr(&dword_1ECF872F0[55]);
  while (__stlxr(v3 + 1, &dword_1ECF872F0[55]));
  *(_QWORD *)this = &off_1E2EBEA58;
  *((_QWORD *)this + 2) = &unk_1E2EBEA90;
  if (cf)
    v4 = CFRetain(cf);
  else
    v4 = 0;
  *((_QWORD *)this + 3) = v4;
  return this;
}

void sub_1922FF3D0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;

  *(_QWORD *)(v1 + 16) = v2;
  v4 = (unsigned int *)(v3 + 228);
  do
    v5 = __ldaxr(v4);
  while (__stlxr(v5 - 1, v4));
  _Unwind_Resume(a1);
}

uint64_t CI::InstanceCounted<(CI::Type)57>::type()
{
  return 57;
}

_QWORD *CI::InstanceCounted<(CI::Type)57>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBBEC0;
  do
    v1 = __ldaxr(&dword_1ECF872F0[55]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[55]));
  return result;
}

void CI::InstanceCounted<(CI::Type)57>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBBEC0;
  do
    v1 = __ldaxr(&dword_1ECF872F0[55]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[55]));
  JUMPOUT(0x194025AACLL);
}

double cikernel::_ci_colormatrix_canonical(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float32x4_t v4;
  float32x4_t v5;
  int8x16_t v6;
  int8x16_t v7;
  double result;

  v4 = vmulq_n_f32(a1, 1.0 / fmaxf(a1.f32[3], 0.00001));
  v4.i32[3] = a1.i32[3];
  v5 = vmulq_f32(a2, v4);
  *(float32x2_t *)v5.f32 = vadd_f32(*(float32x2_t *)v5.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v5, (int8x16_t)v5, 8uLL));
  v6 = (int8x16_t)vmulq_f32(a3, v4);
  *(float32x2_t *)v6.i8 = vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  *(float32x2_t *)v5.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v5.f32, *(int32x2_t *)v6.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v5.f32, *(int32x2_t *)v6.i8));
  v7 = (int8x16_t)vmulq_f32(a4, v4);
  *(float32x2_t *)v7.i8 = vadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  *(float32x2_t *)&v5.u32[2] = vadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 1));
  *(_QWORD *)&result = vmulq_laneq_f32(v5, a1, 3).u64[0];
  return result;
}

void CI::f4_s_f4_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __n128 *v19;
  __n128 *v20;
  __n128 *v21;
  __n128 *v22;
  __int128 v23;
  double (*v24)(__n128, __n128, __n128, __n128);

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  if (*(_BYTE *)(a1 + 64))
  {
    v24 = *(double (**)(__n128, __n128, __n128, __n128))(a1 + 24);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 104)), a2);
    v10 = v24;
  }
  v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v18);
  v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v16);
  v21 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v21 = (__n128 *)((char *)a2 + 64 * v14);
  v22 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v22 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v23 = v10(*v22, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

CI::MetalKernel *CI::PrecompiledColorKernel::PrecompiledColorKernel(CI::MetalKernel *a1, const char *a2, CIKernelLibrary *a3, char *a4, char *a5, char a6, void **a7, uint64_t a8, unsigned int a9, int a10, int a11, NSDictionary *a12, NSDictionary *a13, uint64_t *a14, char a15)
{
  CI::MetalKernel *v21;

  v21 = CI::MetalKernel::MetalKernel(a1, a2, a3, a12, a13, a15, ((unint64_t)a4 | (unint64_t)a5) != 0);
  CI::ColorKernel::ColorKernel((uint64_t)v21 + 80, a2, a4, a5, a6, a7, a8, a9, a10, a11, a14, 0, 0);
  *(_QWORD *)a1 = &unk_1E2EBE348;
  *((_QWORD *)a1 + 10) = &unk_1E2EBE390;
  return a1;
}

void sub_1922FF680(_Unwind_Exception *a1)
{
  id *v1;

  CI::MetalKernel::~MetalKernel(v1);
  _Unwind_Resume(a1);
}

CI::MetalKernel *CI::PrecompiledWarpKernel::PrecompiledWarpKernel(CI::MetalKernel *a1, const char *a2, CIKernelLibrary *a3, char *a4, char *a5, char a6, void **a7, uint64_t a8, unsigned int a9, int a10, NSDictionary *a11, NSDictionary *a12, char a13)
{
  CI::MetalKernel *v20;

  v20 = CI::MetalKernel::MetalKernel(a1, a2, a3, a11, a12, a13, ((unint64_t)a4 | (unint64_t)a5) != 0);
  CI::WarpKernel::WarpKernel((uint64_t)v20 + 80, a2, a4, a5, a6, a7, a8, a9, a10, 0);
  *(_QWORD *)a1 = &unk_1E2EBE2A0;
  *((_QWORD *)a1 + 10) = &unk_1E2EBE2E8;
  return a1;
}

void sub_1922FF754(_Unwind_Exception *a1)
{
  id *v1;

  CI::MetalKernel::~MetalKernel(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::SerialValArray<int>::SerialValArray(uint64_t a1, int a2)
{
  void *v4;
  int v5;

  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  if (a2 > 10)
  {
    *(_DWORD *)(a1 + 4) = a2;
    v4 = malloc_type_calloc((a2 - 10), 4uLL, 0x100004052888210uLL);
  }
  else
  {
    v4 = 0;
    *(_DWORD *)(a1 + 4) = 10;
  }
  *(_QWORD *)(a1 + 16) = v4;
  if (a2 <= 1)
    v5 = 1;
  else
    v5 = a2;
  *(_DWORD *)(a1 + 8) = v5;
  return a1;
}

void OUTLINED_FUNCTION_9_2(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x22u);
}

uint64_t OUTLINED_FUNCTION_13_1(CI::Kernel *a1)
{
  return CI::Kernel::num_apply_arguments(a1);
}

void OUTLINED_FUNCTION_15_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0x16u);
}

uint64_t OUTLINED_FUNCTION_16_0@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_QWORD *)(a2 + 4) = a3;
  *(_WORD *)(a2 + 12) = 2114;
  *(_QWORD *)(a2 + 14) = result;
  return result;
}

void OUTLINED_FUNCTION_17_0(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

void OUTLINED_FUNCTION_18_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, a5, 0xCu);
}

double cikernel::_LabDeltaE(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  int8x16_t v30;
  int8x16_t v32;
  float32x4_t v33;
  float v37;
  float32x4_t v44;
  float32x4_t v45;
  float v46;
  double result;
  int8x16_t v48;
  int8x16_t v49;
  int8x16_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int8x16_t v62;
  float32x4_t v63;

  v58 = a2;
  a2.f32[0] = 1.0 - a1.f32[3];
  v2 = vaddq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0));
  v3 = vmulq_f32(v2, (float32x4_t)xmmword_1924952D0);
  v4 = vmulq_f32(v2, (float32x4_t)xmmword_1924952E0);
  v3.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).u32[0];
  v5 = vmulq_f32(v2, (float32x4_t)xmmword_1924952F0);
  v3.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).u32[0];
  v3.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).u32[0];
  v61 = (float32x4_t)vdupq_n_s32(0xBC1118C2);
  v6 = vmaxnmq_f32(v3, (float32x4_t)0);
  v56 = vaddq_f32(v6, v61);
  v60 = (float32x4_t)vdupq_n_s32(0x40F92F1Bu);
  v59 = (float32x4_t)vdupq_n_s32(0x3E0D3DCBu);
  v49 = (int8x16_t)vaddq_f32(vmulq_f32(v6, v60), v59);
  v6.i32[3] = 0;
  v7 = (int8x16_t)_simd_pow_f4((simd_float4)v6, (simd_float4)xmmword_192495300);
  v8 = (int8x16_t)vcltzq_f32(v56);
  v9 = vbslq_s8(v8, v49, v7);
  *(double *)v8.i64 = *(float *)&v9.i32[1] * 116.0 + -16.0;
  *(float *)v8.i32 = *(double *)v8.i64;
  *(float32x2_t *)v9.i8 = vmul_f32(vsub_f32(*(float32x2_t *)v9.i8, (float32x2_t)vext_s8(*(int8x8_t *)v9.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL), 4uLL)), (float32x2_t)0x4348000043FA0000);
  v57 = (float32x4_t)vextq_s8(vextq_s8(v8, v8, 4uLL), v9, 0xCuLL);
  v10 = vmulq_f32(a1, (float32x4_t)xmmword_1924952D0);
  v11 = vmulq_f32(a1, (float32x4_t)xmmword_1924952E0);
  v10.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).u32[0];
  v8.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).u32[0];
  v12 = vmulq_f32(a1, (float32x4_t)xmmword_1924952F0);
  v10.i32[1] = v8.i32[0];
  v10.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).u32[0];
  v13 = vmaxnmq_f32(v10, (float32x4_t)0);
  v50 = (int8x16_t)vaddq_f32(vmulq_f32(v13, v60), v59);
  v54 = vaddq_f32(v13, v61);
  v13.i32[3] = 0;
  v14 = (int8x16_t)_simd_pow_f4((simd_float4)v13, (simd_float4)xmmword_192495300);
  v15 = (int8x16_t)vcltzq_f32(v54);
  v16 = vbslq_s8(v15, v50, v14);
  *(double *)v15.i64 = *(float *)&v16.i32[1] * 116.0 + -16.0;
  *(float *)v15.i32 = *(double *)v15.i64;
  *(float32x2_t *)v16.i8 = vmul_f32(vsub_f32(*(float32x2_t *)v16.i8, (float32x2_t)vext_s8(*(int8x8_t *)v16.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL), 4uLL)), (float32x2_t)0x4348000043FA0000);
  v17 = vextq_s8(vextq_s8(v15, v15, 4uLL), v16, 0xCuLL);
  v55 = (float32x4_t)v17;
  *(float *)v17.i32 = 1.0 - v58.f32[3];
  v18 = vaddq_f32(v58, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.i8, 0));
  v19 = vmulq_f32(v18, (float32x4_t)xmmword_1924952D0);
  v20 = vmulq_f32(v18, (float32x4_t)xmmword_1924952E0);
  v19.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).u32[0];
  v21 = vmulq_f32(v18, (float32x4_t)xmmword_1924952F0);
  v19.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).u32[0];
  v19.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).u32[0];
  v22 = vmaxnmq_f32(v19, (float32x4_t)0);
  v48 = (int8x16_t)vaddq_f32(vmulq_f32(v22, v60), v59);
  v51 = vaddq_f32(v22, v61);
  v22.i32[3] = 0;
  v23 = (int8x16_t)_simd_pow_f4((simd_float4)v22, (simd_float4)xmmword_192495300);
  v24 = (int8x16_t)vcltzq_f32(v51);
  v25 = vbslq_s8(v24, v48, v23);
  *(double *)v24.i64 = *(float *)&v25.i32[1] * 116.0 + -16.0;
  *(float *)v24.i32 = *(double *)v24.i64;
  *(float32x2_t *)v25.i8 = vmul_f32(vsub_f32(*(float32x2_t *)v25.i8, (float32x2_t)vext_s8(*(int8x8_t *)v25.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL), 4uLL)), (float32x2_t)0x4348000043FA0000);
  v52 = (float32x4_t)vextq_s8(vextq_s8(v24, v24, 4uLL), v25, 0xCuLL);
  v26 = vmulq_f32(v58, (float32x4_t)xmmword_1924952D0);
  v27 = vmulq_f32(v58, (float32x4_t)xmmword_1924952E0);
  v26.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).u32[0];
  v24.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).u32[0];
  v28 = vmulq_f32(v58, (float32x4_t)xmmword_1924952F0);
  v26.i32[1] = v24.i32[0];
  v26.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).u32[0];
  v29 = vmaxnmq_f32(v26, (float32x4_t)0);
  v63 = vaddq_f32(v29, v61);
  v62 = (int8x16_t)vaddq_f32(vmulq_f32(v29, v60), v59);
  v29.i32[3] = 0;
  v30 = (int8x16_t)_simd_pow_f4((simd_float4)v29, (simd_float4)xmmword_192495300);
  _Q1 = (int8x16_t)vcltzq_f32(v63);
  v32 = vbslq_s8(_Q1, v62, v30);
  *(double *)_Q1.i64 = *(float *)&v32.i32[1] * 116.0 + -16.0;
  *(float *)_Q1.i32 = *(double *)_Q1.i64;
  *(float32x2_t *)v32.i8 = vmul_f32(vsub_f32(*(float32x2_t *)v32.i8, (float32x2_t)vext_s8(*(int8x8_t *)v32.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL), 4uLL)), (float32x2_t)0x4348000043FA0000);
  v33 = (float32x4_t)vextq_s8(vextq_s8(_Q1, _Q1, 4uLL), v32, 0xCuLL);
  _Q1.i64[0] = vsubq_f32(v57, v52).u64[0];
  _S2 = _Q1.i32[1];
  _Q3 = vmulq_f32(v57, v57);
  _Q3.f32[0] = sqrtf(COERCE_FLOAT(vaddq_f32(_Q3, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)&_Q3, 2)).i32[1]));
  _Q4 = vmulq_f32(v52, v52);
  _Q4.f32[0] = sqrtf(COERCE_FLOAT(vaddq_f32(_Q4, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)&_Q4, 2)).i32[1]));
  v37 = sqrtf(_Q3.f32[0] * _Q4.f32[0]);
  _Q3.f32[0] = _Q3.f32[0] - _Q4.f32[0];
  __asm { FMLA            S4, S2, V1.S[1] }
  *(float *)_Q1.i32 = sqrtf((float)(fmaxf(_Q4.f32[0] - (float)(_Q3.f32[0] * _Q3.f32[0]), 0.0)/ (float)((float)((float)(v37 * 0.015) + 1.0) * (float)((float)(v37 * 0.015) + 1.0)))+ vmlas_n_f32((float)(_Q3.f32[0] / (float)((float)(v37 * 0.045) + 1.0))* (float)(_Q3.f32[0] / (float)((float)(v37 * 0.045) + 1.0)), *(float *)_Q1.i32, *(float *)_Q1.i32));
  _D2 = vsubq_f32(v55, v33).u64[0];
  _Q3.i32[0] = HIDWORD(_D2);
  _Q5 = vmulq_f32(v55, v55);
  _Q5.f32[0] = sqrtf(COERCE_FLOAT(vaddq_f32(_Q5, (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)&_Q5, 2)).i32[1]));
  v44 = vmulq_f32(v33, v33);
  v45 = vaddq_f32(v44, (float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2));
  v45.f32[0] = sqrtf(v45.f32[1]);
  v46 = sqrtf(_Q5.f32[0] * v45.f32[0]);
  v45.f32[0] = _Q5.f32[0] - v45.f32[0];
  __asm { FMLA            S5, S3, V2.S[1] }
  v45.f32[0] = fmaxf(*(float *)_Q1.i32, sqrtf((float)(fmaxf(_Q5.f32[0] - (float)(v45.f32[0] * v45.f32[0]), 0.0)/ (float)((float)((float)(v46 * 0.015) + 1.0) * (float)((float)(v46 * 0.015) + 1.0)))+ vmlas_n_f32((float)(v45.f32[0] / (float)((float)(v46 * 0.045) + 1.0))* (float)(v45.f32[0] / (float)((float)(v46 * 0.045) + 1.0)), *(float *)&_D2, *(float *)&_D2)));
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)v45.f32, 0).u64[0];
  return result;
}

__n64 cikernel::_LAB_normalize(int8x16_t a1)
{
  float32x2_t v1;
  __n64 result;

  v1 = (float32x2_t)vext_s8(*(int8x8_t *)a1.i8, (int8x8_t)*(_OWORD *)&vextq_s8(a1, a1, 8uLL), 4uLL);
  result.n64_f32[0] = *(float *)a1.i32 / 100.0;
  result.n64_u32[1] = vadd_f32(vmul_f32(v1, (float32x2_t)0x3C0000003C000000), (float32x2_t)0x3F0000003F000000).u32[0];
  return result;
}

__n64 cikernel::_LAB_denormalize(int8x16_t a1)
{
  float32x2_t v1;
  __n64 result;

  v1 = (float32x2_t)vext_s8(*(int8x8_t *)a1.i8, (int8x8_t)*(_OWORD *)&vextq_s8(a1, a1, 8uLL), 4uLL);
  result.n64_f32[0] = 100.0 * *(float *)a1.i32;
  result.n64_u32[1] = vmul_f32(vadd_f32(v1, (float32x2_t)0xBF000000BF000000), (float32x2_t)0x4300000043000000).u32[0];
  return result;
}

CIImage *downBy2H(CIImage *a1)
{
  CIVector *v2;
  double x;
  double y;
  double width;
  double height;
  double v7;
  double v8;
  double v9;
  double v10;
  BOOL IsNull;
  double v12;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  CIKernel *v19;
  _QWORD v21[5];
  Rectangle v22;
  Rectangle v23;
  _QWORD v24[4];
  _QWORD v25[3];
  CGRect v26;
  CGRect v27;

  v25[2] = *MEMORY[0x1E0C80C00];
  v2 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", 2.0, 1.0, 1.0, 0.0);
  -[CIImage extent](a1, "extent");
  x = v26.origin.x;
  y = v26.origin.y;
  width = v26.size.width;
  height = v26.size.height;
  if (CGRectIsInfinite(v26))
  {
    v7 = 1.79769313e308;
    v8 = -8.98846567e307;
    v9 = 1.79769313e308;
    v10 = -8.98846567e307;
  }
  else
  {
    v27.origin.x = x;
    v27.origin.y = y;
    v27.size.width = width;
    v27.size.height = height;
    IsNull = CGRectIsNull(v27);
    v10 = INFINITY;
    if (IsNull)
      v8 = INFINITY;
    else
      v8 = y;
    if (IsNull)
      v7 = 0.0;
    else
      v7 = width;
    if (IsNull)
      v9 = 0.0;
    else
      v9 = height;
    if (!IsNull)
      v10 = x;
  }
  v12 = fabs(v8);
  if (fabs(v10) == INFINITY || v12 == INFINITY)
  {
    *(int64x2_t *)&v22.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    v22.var2 = 0.0;
    v22.var3 = 0.0;
  }
  else if (v10 == -8.98846567e307 && v8 == -8.98846567e307 && v7 == 1.79769313e308 && v9 == 1.79769313e308)
  {
    *(int64x2_t *)&v22.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v22.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v22.var0 = v10 * 0.5;
    v22.var1 = v8;
    v22.var2 = v7 * 0.5;
    v22.var3 = v9;
  }
  Rectangle::inset(&v22, -3.0, -0.0, (uint64_t)&v23);
  *(_QWORD *)&v14 = *(_OWORD *)&Rectangle::integralize(&v23, 0.0001, (uint64_t)v24);
  v15 = *(double *)v24;
  v16 = *(double *)&v24[1];
  v18 = *(double *)&v24[2];
  v17 = *(double *)&v24[3];
  v19 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_lanczosDown2, v14);
  if (v15 == -8.98846567e307 && v16 == -8.98846567e307 && v18 == 1.79769313e308 && v17 == 1.79769313e308)
  {
    v15 = *MEMORY[0x1E0C9D5E0];
    v16 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
    v18 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
    v17 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
  }
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 3221225472;
  v21[2] = ___ZL8downBy2HP7CIImage_block_invoke;
  v21[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
  v21[4] = 0x4012C985F06F6944;
  v25[0] = a1;
  v25[1] = v2;
  return -[CIKernel applyWithExtent:roiCallback:arguments:](v19, "applyWithExtent:roiCallback:arguments:", v21, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v25, 2), v15, v16, v18, v17);
}

CIImage *downBy2V(CIImage *a1)
{
  CIVector *v2;
  double x;
  double y;
  double width;
  double height;
  double v7;
  double v8;
  double v9;
  double v10;
  BOOL IsNull;
  double v12;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  CIKernel *v19;
  _QWORD v21[5];
  Rectangle v22;
  Rectangle v23;
  _QWORD v24[4];
  _QWORD v25[3];
  CGRect v26;
  CGRect v27;

  v25[2] = *MEMORY[0x1E0C80C00];
  v2 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", 1.0, 2.0, 0.0, 1.0);
  -[CIImage extent](a1, "extent");
  x = v26.origin.x;
  y = v26.origin.y;
  width = v26.size.width;
  height = v26.size.height;
  if (CGRectIsInfinite(v26))
  {
    v7 = 1.79769313e308;
    v8 = -8.98846567e307;
    v9 = 1.79769313e308;
    v10 = -8.98846567e307;
  }
  else
  {
    v27.origin.x = x;
    v27.origin.y = y;
    v27.size.width = width;
    v27.size.height = height;
    IsNull = CGRectIsNull(v27);
    v10 = INFINITY;
    if (IsNull)
      v8 = INFINITY;
    else
      v8 = y;
    if (IsNull)
      v7 = 0.0;
    else
      v7 = width;
    if (IsNull)
      v9 = 0.0;
    else
      v9 = height;
    if (!IsNull)
      v10 = x;
  }
  v12 = fabs(v8);
  if (fabs(v10) == INFINITY || v12 == INFINITY)
  {
    *(int64x2_t *)&v22.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    v22.var2 = 0.0;
    v22.var3 = 0.0;
  }
  else if (v10 == -8.98846567e307 && v8 == -8.98846567e307 && v7 == 1.79769313e308 && v9 == 1.79769313e308)
  {
    *(int64x2_t *)&v22.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v22.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v22.var0 = v10;
    v22.var1 = v8 * 0.5;
    v22.var2 = v7;
    v22.var3 = v9 * 0.5;
  }
  Rectangle::inset(&v22, -0.0, -3.0, (uint64_t)&v23);
  *(_QWORD *)&v14 = *(_OWORD *)&Rectangle::integralize(&v23, 0.0001, (uint64_t)v24);
  v15 = *(double *)v24;
  v16 = *(double *)&v24[1];
  v18 = *(double *)&v24[2];
  v17 = *(double *)&v24[3];
  v19 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_lanczosDown2, v14);
  if (v15 == -8.98846567e307 && v16 == -8.98846567e307 && v18 == 1.79769313e308 && v17 == 1.79769313e308)
  {
    v15 = *MEMORY[0x1E0C9D5E0];
    v16 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
    v18 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
    v17 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
  }
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 3221225472;
  v21[2] = ___ZL8downBy2VP7CIImage_block_invoke;
  v21[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
  v21[4] = 0x4012C985F06F6944;
  v25[0] = a1;
  v25[1] = v2;
  return -[CIKernel applyWithExtent:roiCallback:arguments:](v19, "applyWithExtent:roiCallback:arguments:", v21, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v25, 2), v15, v16, v18, v17);
}

void ___ZL8downBy2HP7CIImage_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5;

  v5 = *(double *)(a1 + 32);
  roiDown2(*(CGRect *)&a2, v5, 1);
}

void roiDown2(CGRect a1, float a2, int a3)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  double v7;
  double v8;
  double v9;
  double v10;
  CGAffineTransform v11;
  CGRect v12;
  CGRect v13;

  height = a1.size.height;
  width = a1.size.width;
  y = a1.origin.y;
  x = a1.origin.x;
  v7 = 1.0;
  if (a3)
    v8 = 2.0;
  else
    v8 = 1.0;
  if (a3)
  {
    v9 = (float)-a2;
  }
  else
  {
    v7 = 2.0;
    v9 = 0.0;
  }
  if (a3)
    v10 = 0.0;
  else
    v10 = (float)-a2;
  CGAffineTransformMakeScale(&v11, v8, v7);
  v12.origin.x = x;
  v12.origin.y = y;
  v12.size.width = width;
  v12.size.height = height;
  v13 = CGRectApplyAffineTransform(v12, &v11);
  CGRectInset(v13, v9, v10);
}

double cikernel::_lanczosDown2(uint64_t a1, float64x2_t a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  int8x16_t v10;
  double v11;
  uint8x8_t v12;
  float32x2_t v13;
  float32x2_t v14;
  int8x16_t v15;
  float32x4_t v16;
  double v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  float64x2_t v21;
  double v22;
  int8x16_t v23;
  float32x4_t v24;
  double v25;
  double v26;
  uint8x8_t v27;
  int8x16_t v28;
  float64x2_t v29;
  double v30;
  int8x16_t v31;
  float32x4_t v32;
  double v33;
  double v34;
  uint8x8_t v35;
  int8x16_t v36;
  float64x2_t v37;
  double v38;
  int8x16_t v39;
  float32x4_t v40;
  double v41;
  double v42;
  uint8x8_t v43;
  int8x16_t v44;
  float64x2_t v45;
  double v46;
  int8x16_t v47;
  float32x4_t v48;
  double v49;
  double v50;
  uint8x8_t v51;
  int8x16_t v52;
  float64x2_t v53;
  double v54;
  int8x16_t v55;
  float32x4_t v56;
  double result;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float32x4_t v63;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v4 = a2;
  v5 = vmul_f32(*(float32x2_t *)&a2.f64[0], *DC);
  v6 = (float32x2_t)vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL).u64[0];
  v7 = vmul_f32(v6, (float32x2_t)vdup_n_s32(0x40964C30u));
  *(float32x2_t *)&v4.f64[0] = vsub_f32(v5, v7);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v4.f64[0], 1), *(float *)(a1 + 16), *(float *)v4.f64);
  LODWORD(v9) = *(_DWORD *)(a1 + 24);
  v10.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v11) = *(_DWORD *)(a1 + 36);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v4.f64[0], 1), *(float *)v10.i32, *(float *)v4.f64);
  v13 = vmul_f32(v6, (float32x2_t)vdup_n_s32(0x3F3B9D6Fu));
  *(int32x2_t *)&v4.f64[0] = vdup_n_s32(0x40359F2Cu);
  v14 = vmul_f32(v6, *(float32x2_t *)&v4.f64[0]);
  v6.f32[0] = *(float *)&v9 + *(float *)&v8;
  *(float *)v4.f64 = *(float *)&v11 + *(float *)v12.i32;
  v6.f32[1] = *(float *)&v11 + *(float *)v12.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v4, v9, v8, v10, v12, v11, v15);
  v63 = v16;
  *(float32x2_t *)v16.f32 = vsub_f32(v5, v14);
  *(float *)&v17 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v16.f32, 1), *(float *)(a1 + 16), v16.f32[0]);
  LODWORD(v18) = *(_DWORD *)(a1 + 28);
  v19.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v16.f32, 1), *(float *)&v18, v16.f32[0]);
  v16.f32[0] = *(float *)(a1 + 24) + *(float *)&v17;
  *(float *)v21.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v16.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v16.i64, v21, v17, v18, v20, v19, v22, v23);
  v61 = v24;
  *(float32x2_t *)v24.f32 = vsub_f32(v5, v13);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v24.f32, 1), *(float *)(a1 + 16), v24.f32[0]);
  LODWORD(v26) = *(_DWORD *)(a1 + 28);
  v27.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v24.f32, 1), *(float *)&v26, v24.f32[0]);
  v24.f32[0] = *(float *)(a1 + 24) + *(float *)&v25;
  *(float *)v29.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  v24.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v24.i64, v29, v25, v26, v28, v27, v30, v31);
  v60 = v32;
  *(float32x2_t *)v32.f32 = vadd_f32(v13, v5);
  *(float *)&v33 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v32.f32, 1), *(float *)(a1 + 16), v32.f32[0]);
  LODWORD(v34) = *(_DWORD *)(a1 + 28);
  v35.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v32.f32, 1), *(float *)&v34, v32.f32[0]);
  v32.f32[0] = *(float *)(a1 + 24) + *(float *)&v33;
  *(float *)v37.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  v32.f32[1] = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v32.i64, v37, v33, v34, v36, v35, v38, v39);
  v59 = v40;
  *(float32x2_t *)v40.f32 = vadd_f32(v14, v5);
  *(float *)&v41 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v40.f32, 1), *(float *)(a1 + 16), v40.f32[0]);
  LODWORD(v42) = *(_DWORD *)(a1 + 28);
  v43.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v44.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v40.f32, 1), *(float *)&v42, v40.f32[0]);
  v40.f32[0] = *(float *)(a1 + 24) + *(float *)&v41;
  *(float *)v45.f64 = *(float *)v43.i32 + *(float *)v44.i32;
  v40.f32[1] = *(float *)v43.i32 + *(float *)v44.i32;
  *(double *)v48.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v40.i64, v45, v41, v42, v44, v43, v46, v47);
  v58 = v48;
  *(float32x2_t *)v48.f32 = vadd_f32(v7, v5);
  *(float *)&v49 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v48.f32, 1), *(float *)(a1 + 16), v48.f32[0]);
  LODWORD(v50) = *(_DWORD *)(a1 + 28);
  v51.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v52.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v48.f32, 1), *(float *)&v50, v48.f32[0]);
  v48.f32[0] = *(float *)(a1 + 24) + *(float *)&v49;
  *(float *)v53.f64 = *(float *)v51.i32 + *(float *)v52.i32;
  v48.f32[1] = *(float *)v51.i32 + *(float *)v52.i32;
  *(double *)v56.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v48.i64, v53, v49, v50, v52, v51, v54, v55);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_f32(vaddq_f32(v60, v59), (float32x4_t)vdupq_n_s32(0x3F14F6CFu)), vmulq_f32(vaddq_f32(v61, v58), (float32x4_t)vdupq_n_s32(0xBDCE1A3F))), vmulq_f32(vaddq_f32(v63, v56), (float32x4_t)vdupq_n_s32(0x3C998FBEu))).u64[0];
  return result;
}

float ___ZL8downBy2VP7CIImage_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5;
  float result;

  v5 = *(double *)(a1 + 32);
  roiDown2(*(CGRect *)&a2, v5, 0);
  return result;
}

float ___ZL5downHP7CIImaged_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5;
  float v6;
  float result;

  v5 = *(double *)(a1 + 32);
  v6 = *(double *)(a1 + 40);
  roiDownK(*(CGRect *)&a2, v5, v6, 1);
  return result;
}

double cikernel::_lanczosDownH(uint64_t a1, int8x16_t a2)
{
  float32x2_t *DC;
  double v6;
  int8x16_t v7;
  float64x2_t v8;
  float32x2_t v13;
  int8x16_t v15;
  int8x16_t v16;
  float32x4_t v17;
  double v18;
  double v19;
  float64x2_t v20;
  uint8x8_t v21;
  double v22;
  int8x16_t v23;
  float32x4_t v24;
  double v25;
  double v26;
  float64x2_t v27;
  uint8x8_t v28;
  double v29;
  int8x16_t v30;
  float32x4_t v31;
  double v32;
  double v33;
  float64x2_t v34;
  uint8x8_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  double v39;
  double v40;
  float64x2_t v41;
  uint8x8_t v42;
  double v43;
  int8x16_t v44;
  float32x4_t v45;
  double v46;
  double v47;
  float64x2_t v48;
  double v49;
  int8x16_t v50;
  float32x4_t v51;
  double v52;
  double v53;
  float64x2_t v54;
  uint8x8_t v55;
  double v56;
  int8x16_t v57;
  float32x4_t v58;
  double v59;
  double v60;
  float64x2_t v61;
  uint8x8_t v62;
  double v63;
  int8x16_t v64;
  float32x4_t v65;
  double v66;
  double v67;
  float64x2_t v68;
  uint8x8_t v69;
  double v70;
  int8x16_t v71;
  float32x4_t v72;
  double v73;
  double v74;
  float64x2_t v75;
  uint8x8_t v76;
  double v77;
  int8x16_t v78;
  float32x4_t v79;
  double v80;
  double v81;
  float64x2_t v82;
  uint8x8_t v83;
  double v84;
  int8x16_t v85;
  float32x4_t v86;
  double v87;
  double v88;
  float64x2_t v89;
  uint8x8_t v90;
  double v91;
  int8x16_t v92;
  float32x4_t v93;
  float v94;
  float32x2_t v95;
  float v96;
  double v97;
  float v98;
  double v99;
  long double v100;
  float v101;
  double v102;
  float v103;
  double v104;
  long double v105;
  float v106;
  double v107;
  float v108;
  double v109;
  long double v110;
  float v111;
  double v112;
  float v113;
  double v114;
  long double v115;
  float v116;
  double v117;
  float v118;
  double v119;
  long double v120;
  float v121;
  double v122;
  float v123;
  double v124;
  long double v125;
  float v126;
  float v127;
  float v128;
  double v129;
  float v130;
  double v131;
  long double v132;
  float v133;
  double v134;
  float v135;
  double v136;
  long double v137;
  float v138;
  float v139;
  float v140;
  double v141;
  float v142;
  double v143;
  long double v144;
  float v145;
  double v146;
  float v147;
  double v148;
  long double v149;
  float v150;
  float v151;
  float v152;
  double v153;
  float v154;
  double v155;
  long double v156;
  double v157;
  float v158;
  double v159;
  long double v160;
  double result;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float v174;
  float32x2_t v175;
  float v176;
  int8x16_t v177;
  float v178;
  int8x16_t v179;
  float v180;
  int8x16_t v181;
  float v182;
  int8x16_t v183;
  float v184;
  uint8x8_t v185;
  int8x16_t v186;
  float v187;
  int8x16_t v188;
  float v189;
  int8x16_t v190;
  int8x16_t v191;
  float v192;
  float v193;
  float v194;
  int8x16_t v195;
  float v196;
  float v197;
  int8x16_t v198;
  int8x16_t v199;
  float v201;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  _Q2 = a2;
  *(float32x2_t *)_Q3.i8 = vmul_f32(*(float32x2_t *)a2.i8, *DC);
  v199 = _Q3;
  v6 = 0.5;
  *(float *)&v6 = floor(*(float *)_Q3.i32 + -0.5) + 0.5;
  v185 = *(uint8x8_t *)&v6;
  v7 = _Q3;
  v7.i32[0] = LODWORD(v6);
  v8 = (float64x2_t)vextq_s8(_Q2, _Q2, 8uLL);
  __asm { FMOV            V2.2S, #5.0 }
  *(float32x2_t *)_Q2.i8 = vmul_f32(*(float32x2_t *)&v8.f64[0], *(float32x2_t *)_Q2.i8);
  v13 = vsub_f32(*(float32x2_t *)v7.i8, *(float32x2_t *)_Q2.i8);
  __asm { FMOV            V3.2S, #4.0 }
  *(float32x2_t *)_Q3.i8 = vmul_f32(*(float32x2_t *)&v8.f64[0], *(float32x2_t *)_Q3.i8);
  *(float32x2_t *)_Q4.i8 = vsub_f32(*(float32x2_t *)v7.i8, *(float32x2_t *)_Q3.i8);
  v177 = _Q4;
  __asm { FMOV            V4.2S, #3.0 }
  *(float32x2_t *)_Q4.i8 = vmul_f32(*(float32x2_t *)&v8.f64[0], *(float32x2_t *)_Q4.i8);
  *(float32x2_t *)v15.i8 = vsub_f32(*(float32x2_t *)v7.i8, *(float32x2_t *)_Q4.i8);
  v179 = v15;
  *(float32x2_t *)v15.i8 = vadd_f32(*(float32x2_t *)&v8.f64[0], *(float32x2_t *)&v8.f64[0]);
  *(float32x2_t *)v16.i8 = vsub_f32(*(float32x2_t *)v7.i8, *(float32x2_t *)v15.i8);
  v181 = v16;
  *(float32x2_t *)v16.i8 = vsub_f32(*(float32x2_t *)v7.i8, *(float32x2_t *)&v8.f64[0]);
  v183 = v16;
  *(float32x2_t *)v16.i8 = vadd_f32(*(float32x2_t *)&v8.f64[0], *(float32x2_t *)v7.i8);
  *(float32x2_t *)v15.i8 = vadd_f32(*(float32x2_t *)v15.i8, *(float32x2_t *)v7.i8);
  v186 = v16;
  v188 = v15;
  *(float32x2_t *)_Q4.i8 = vadd_f32(*(float32x2_t *)_Q4.i8, *(float32x2_t *)v7.i8);
  *(float32x2_t *)_Q3.i8 = vadd_f32(*(float32x2_t *)_Q3.i8, *(float32x2_t *)v7.i8);
  v190 = _Q4;
  v191 = _Q3;
  *(float32x2_t *)_Q2.i8 = vadd_f32(*(float32x2_t *)_Q2.i8, *(float32x2_t *)v7.i8);
  v195 = _Q2;
  __asm { FMOV            V2.2S, #6.0 }
  *(float32x2_t *)&v8.f64[0] = vmul_f32(*(float32x2_t *)&v8.f64[0], *(float32x2_t *)_Q2.i8);
  *(float32x2_t *)v7.i8 = vadd_f32(*(float32x2_t *)&v8.f64[0], *(float32x2_t *)v7.i8);
  v198 = v7;
  v175 = v13;
  _Q2.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v7.i32 = *(float *)(a1 + 24)
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v13, 1), *(float *)(a1 + 16), v13.f32[0]);
  _Q3.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v8.f64 = *(float *)_Q3.i32
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v13, 1), *(float *)_Q2.i32, v13.f32[0]);
  v7.i32[1] = LODWORD(v8.f64[0]);
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v7.i64, v8, *(double *)_Q2.i64, *(double *)_Q3.i64, _Q4, *(uint8x8_t *)v15.i8, *(double *)&v13, v16);
  v173 = v17;
  LODWORD(v18) = *(_DWORD *)(a1 + 28);
  v17.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v177.i8, 1), *(float *)(a1 + 16), *(float *)v177.i32);
  LODWORD(v19) = *(_DWORD *)(a1 + 36);
  *(float *)v20.f64 = *(float *)&v19
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v177.i8, 1), *(float *)&v18, *(float *)v177.i32);
  v17.i32[1] = LODWORD(v20.f64[0]);
  *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v17.i64, v20, v18, v19, v177, v21, v22, v23);
  v172 = v24;
  LODWORD(v25) = *(_DWORD *)(a1 + 28);
  v24.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v179.i8, 1), *(float *)(a1 + 16), *(float *)v179.i32);
  LODWORD(v26) = *(_DWORD *)(a1 + 36);
  *(float *)v27.f64 = *(float *)&v26
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v179.i8, 1), *(float *)&v25, *(float *)v179.i32);
  v24.i32[1] = LODWORD(v27.f64[0]);
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v24.i64, v27, v25, v26, v179, v28, v29, v30);
  v171 = v31;
  LODWORD(v32) = *(_DWORD *)(a1 + 28);
  v31.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v181.i8, 1), *(float *)(a1 + 16), *(float *)v181.i32);
  LODWORD(v33) = *(_DWORD *)(a1 + 36);
  *(float *)v34.f64 = *(float *)&v33
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v181.i8, 1), *(float *)&v32, *(float *)v181.i32);
  v31.i32[1] = LODWORD(v34.f64[0]);
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v31.i64, v34, v32, v33, v181, v35, v36, v37);
  v170 = v38;
  LODWORD(v39) = *(_DWORD *)(a1 + 28);
  v38.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v183.i8, 1), *(float *)(a1 + 16), *(float *)v183.i32);
  LODWORD(v40) = *(_DWORD *)(a1 + 36);
  *(float *)v41.f64 = *(float *)&v40
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v183.i8, 1), *(float *)&v39, *(float *)v183.i32);
  v38.i32[1] = LODWORD(v41.f64[0]);
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v41, v39, v40, v183, v42, v43, v44);
  v169 = v45;
  LODWORD(v46) = *(_DWORD *)(a1 + 28);
  v45.f32[0] = *(float *)(a1 + 24)
             + (float)(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v199.i8, 1)
                     + (float)(*(float *)v185.i32 * *(float *)(a1 + 16)));
  LODWORD(v47) = *(_DWORD *)(a1 + 36);
  *(float *)v48.f64 = *(float *)&v47
                    + (float)(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v199.i8, 1)
                            + (float)(*(float *)v185.i32 * *(float *)&v46));
  v45.i32[1] = LODWORD(v48.f64[0]);
  *(double *)v51.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v48, v46, v47, v199, v185, v49, v50);
  v168 = v51;
  LODWORD(v52) = *(_DWORD *)(a1 + 28);
  v51.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v186.i8, 1), *(float *)(a1 + 16), *(float *)v186.i32);
  LODWORD(v53) = *(_DWORD *)(a1 + 36);
  *(float *)v54.f64 = *(float *)&v53
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v186.i8, 1), *(float *)&v52, *(float *)v186.i32);
  v51.i32[1] = LODWORD(v54.f64[0]);
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v51.i64, v54, v52, v53, v186, v55, v56, v57);
  v167 = v58;
  LODWORD(v59) = *(_DWORD *)(a1 + 28);
  v58.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v188.i8, 1), *(float *)(a1 + 16), *(float *)v188.i32);
  LODWORD(v60) = *(_DWORD *)(a1 + 36);
  *(float *)v61.f64 = *(float *)&v60
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v188.i8, 1), *(float *)&v59, *(float *)v188.i32);
  v58.i32[1] = LODWORD(v61.f64[0]);
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v58.i64, v61, v59, v60, v188, v62, v63, v64);
  v166 = v65;
  LODWORD(v66) = *(_DWORD *)(a1 + 28);
  v65.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v190.i8, 1), *(float *)(a1 + 16), *(float *)v190.i32);
  LODWORD(v67) = *(_DWORD *)(a1 + 36);
  *(float *)v68.f64 = *(float *)&v67
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v190.i8, 1), *(float *)&v66, *(float *)v190.i32);
  v65.i32[1] = LODWORD(v68.f64[0]);
  *(double *)v72.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v68, v66, v67, v190, v69, v70, v71);
  v165 = v72;
  LODWORD(v73) = *(_DWORD *)(a1 + 28);
  v72.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v191.i8, 1), *(float *)(a1 + 16), *(float *)v191.i32);
  LODWORD(v74) = *(_DWORD *)(a1 + 36);
  *(float *)v75.f64 = *(float *)&v74
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v191.i8, 1), *(float *)&v73, *(float *)v191.i32);
  v72.i32[1] = LODWORD(v75.f64[0]);
  *(double *)v79.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v72.i64, v75, v73, v74, v191, v76, v77, v78);
  v164 = v79;
  LODWORD(v80) = *(_DWORD *)(a1 + 28);
  v79.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v195.i8, 1), *(float *)(a1 + 16), *(float *)v195.i32);
  LODWORD(v81) = *(_DWORD *)(a1 + 36);
  *(float *)v82.f64 = *(float *)&v81
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v195.i8, 1), *(float *)&v80, *(float *)v195.i32);
  v79.i32[1] = LODWORD(v82.f64[0]);
  *(double *)v86.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v79.i64, v82, v80, v81, v195, v83, v84, v85);
  v163 = v86;
  LODWORD(v87) = *(_DWORD *)(a1 + 28);
  v86.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v198.i8, 1), *(float *)(a1 + 16), *(float *)v198.i32);
  LODWORD(v88) = *(_DWORD *)(a1 + 36);
  *(float *)v89.f64 = *(float *)&v88
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v198.i8, 1), *(float *)&v87, *(float *)v198.i32);
  v86.i32[1] = LODWORD(v89.f64[0]);
  *(double *)v93.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v86.i64, v89, v87, v88, v198, v90, v91, v92);
  v95 = *(float32x2_t *)v199.i8;
  v94 = *(float *)a2.i32;
  v162 = v93;
  v96 = fabsf(vsub_f32(v175, *(float32x2_t *)v199.i8).f32[0] / *(float *)a2.i32);
  v176 = 0.0;
  v174 = 0.0;
  if (v96 < 3.0)
  {
    v97 = v96;
    v174 = 1.0;
    if (v97 >= 0.001)
    {
      v98 = v97 * 3.14159265;
      v99 = sinf(v98) * 3.0;
      v100 = sin(v98 / 3.0);
      v95 = *(float32x2_t *)v199.i8;
      v94 = *(float *)a2.i32;
      *(float *)&v100 = v99 * v100 / (float)(v98 * v98);
      v174 = *(float *)&v100;
    }
  }
  v101 = fabsf(vsub_f32(*(float32x2_t *)v177.i8, v95).f32[0] / v94);
  if (v101 < 3.0)
  {
    v102 = v101;
    v176 = 1.0;
    if (v102 >= 0.001)
    {
      v103 = v102 * 3.14159265;
      v104 = sinf(v103) * 3.0;
      v105 = sin(v103 / 3.0);
      v95 = *(float32x2_t *)v199.i8;
      v94 = *(float *)a2.i32;
      *(float *)&v105 = v104 * v105 / (float)(v103 * v103);
      v176 = *(float *)&v105;
    }
  }
  v106 = fabsf(vsub_f32(*(float32x2_t *)v179.i8, v95).f32[0] / v94);
  v180 = 0.0;
  v178 = 0.0;
  if (v106 < 3.0)
  {
    v107 = v106;
    v178 = 1.0;
    if (v107 >= 0.001)
    {
      v108 = v107 * 3.14159265;
      v109 = sinf(v108) * 3.0;
      v110 = sin(v108 / 3.0);
      v95 = *(float32x2_t *)v199.i8;
      v94 = *(float *)a2.i32;
      *(float *)&v110 = v109 * v110 / (float)(v108 * v108);
      v178 = *(float *)&v110;
    }
  }
  v111 = fabsf(vsub_f32(*(float32x2_t *)v181.i8, v95).f32[0] / v94);
  if (v111 < 3.0)
  {
    v112 = v111;
    v180 = 1.0;
    if (v112 >= 0.001)
    {
      v113 = v112 * 3.14159265;
      v114 = sinf(v113) * 3.0;
      v115 = sin(v113 / 3.0);
      v95 = *(float32x2_t *)v199.i8;
      v94 = *(float *)a2.i32;
      *(float *)&v115 = v114 * v115 / (float)(v113 * v113);
      v180 = *(float *)&v115;
    }
  }
  v116 = fabsf(vsub_f32(*(float32x2_t *)v183.i8, v95).f32[0] / v94);
  v184 = 0.0;
  v182 = 0.0;
  if (v116 < 3.0)
  {
    v117 = v116;
    v182 = 1.0;
    if (v117 >= 0.001)
    {
      v118 = v117 * 3.14159265;
      v119 = sinf(v118) * 3.0;
      v120 = sin(v118 / 3.0);
      v95 = *(float32x2_t *)v199.i8;
      v94 = *(float *)a2.i32;
      *(float *)&v120 = v119 * v120 / (float)(v118 * v118);
      v182 = *(float *)&v120;
    }
  }
  v121 = fabsf((float)(*(float *)v185.i32 - v95.f32[0]) / v94);
  if (v121 < 3.0)
  {
    v122 = v121;
    v184 = 1.0;
    if (v122 >= 0.001)
    {
      v123 = v122 * 3.14159265;
      v124 = sinf(v123) * 3.0;
      v125 = sin(v123 / 3.0);
      v95 = *(float32x2_t *)v199.i8;
      v94 = *(float *)a2.i32;
      *(float *)&v125 = v124 * v125 / (float)(v123 * v123);
      v184 = *(float *)&v125;
    }
  }
  v126 = fabsf(vsub_f32(*(float32x2_t *)v186.i8, v95).f32[0] / v94);
  v127 = 0.0;
  v128 = 0.0;
  if (v126 < 3.0)
  {
    v129 = v126;
    v128 = 1.0;
    if (v129 >= 0.001)
    {
      v130 = v129 * 3.14159265;
      v131 = sinf(v130) * 3.0;
      v132 = sin(v130 / 3.0);
      v127 = 0.0;
      v95 = *(float32x2_t *)v199.i8;
      v94 = *(float *)a2.i32;
      v128 = v131 * v132 / (float)(v130 * v130);
    }
  }
  v133 = fabsf(vsub_f32(*(float32x2_t *)v188.i8, v95).f32[0] / v94);
  v189 = v128;
  if (v133 < 3.0)
  {
    v134 = v133;
    v127 = 1.0;
    if (v134 >= 0.001)
    {
      v135 = v134 * 3.14159265;
      v136 = sinf(v135) * 3.0;
      v137 = sin(v135 / 3.0);
      v128 = v189;
      v95 = *(float32x2_t *)v199.i8;
      v94 = *(float *)a2.i32;
      v127 = v136 * v137 / (float)(v135 * v135);
    }
  }
  v138 = fabsf(vsub_f32(*(float32x2_t *)v190.i8, v95).f32[0] / v94);
  v139 = 0.0;
  v140 = 0.0;
  v187 = v127;
  if (v138 < 3.0)
  {
    v141 = v138;
    v140 = 1.0;
    if (v141 >= 0.001)
    {
      v142 = v141 * 3.14159265;
      v143 = sinf(v142) * 3.0;
      v144 = sin(v142 / 3.0);
      v139 = 0.0;
      v127 = v187;
      v128 = v189;
      v95 = *(float32x2_t *)v199.i8;
      v94 = *(float *)a2.i32;
      v140 = v143 * v144 / (float)(v142 * v142);
    }
  }
  v145 = fabsf(vsub_f32(*(float32x2_t *)v191.i8, v95).f32[0] / v94);
  if (v145 < 3.0)
  {
    v146 = v145;
    v139 = 1.0;
    if (v146 >= 0.001)
    {
      v147 = v146 * 3.14159265;
      v192 = v140;
      v148 = sinf(v147) * 3.0;
      v149 = sin(v147 / 3.0);
      v140 = v192;
      v127 = v187;
      v128 = v189;
      v95 = *(float32x2_t *)v199.i8;
      v94 = *(float *)a2.i32;
      v139 = v148 * v149 / (float)(v147 * v147);
    }
  }
  v150 = fabsf(vsub_f32(*(float32x2_t *)v195.i8, v95).f32[0] / v94);
  v151 = 0.0;
  v152 = 0.0;
  if (v150 < 3.0)
  {
    v153 = v150;
    v152 = 1.0;
    if (v153 >= 0.001)
    {
      v154 = v153 * 3.14159265;
      v193 = v140;
      v196 = v139;
      v155 = sinf(v154) * 3.0;
      v156 = sin(v154 / 3.0);
      v151 = 0.0;
      v140 = v193;
      v139 = v196;
      v127 = v187;
      v128 = v189;
      v95 = *(float32x2_t *)v199.i8;
      v94 = *(float *)a2.i32;
      v152 = v155 * v156 / (float)(v154 * v154);
    }
  }
  v157 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)v198.i8, v95));
  *(float *)&v157 = fabsf(*(float *)&v157 / v94);
  if (*(float *)&v157 < 3.0)
  {
    v157 = *(float *)&v157;
    v151 = 1.0;
    if (v157 >= 0.001)
    {
      v158 = v157 * 3.14159265;
      v194 = v140;
      v197 = v139;
      v201 = v152;
      v159 = sinf(v158) * 3.0;
      v160 = sin(v158 / 3.0);
      v152 = v201;
      v140 = v194;
      v139 = v197;
      v127 = v187;
      v128 = v189;
      v157 = v159 * v160 / (float)(v158 * v158);
      v151 = v157;
    }
  }
  *(float *)&v157 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v174 + v176) + v178)
                                                                                  + v180)
                                                                          + v182)
                                                                  + v184)
                                                          + v128)
                                                  + v127)
                                          + v140)
                                  + v139)
                          + v152)
                  + v151;
  *(_QWORD *)&result = vdivq_f32(vaddq_f32(vmulq_n_f32(v167, v128), vaddq_f32(vmulq_n_f32(v166, v127), vaddq_f32(vmulq_n_f32(v165, v140), vaddq_f32(vmulq_n_f32(v164, v139), vaddq_f32(vmulq_n_f32(v163, v152), vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(v173, v174), vmulq_n_f32(v172, v176)), vmulq_n_f32(v171, v178)), vmulq_n_f32(v170, v180)), vmulq_n_f32(v169, v182)),
                                       vmulq_n_f32(v168, v184)),
                                     vmulq_n_f32(v162, v151))))))),
                         (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v157, 0)).u64[0];
  return result;
}

float ___ZL5downVP7CIImaged_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5;
  float v6;
  float result;

  v5 = *(double *)(a1 + 32);
  v6 = *(double *)(a1 + 40);
  roiDownK(*(CGRect *)&a2, v5, v6, 0);
  return result;
}

double cikernel::_lanczosDownV(uint64_t a1, int8x16_t a2)
{
  float32x2_t *DC;
  int8x16_t v5;
  float v6;
  double v7;
  int8x16_t v8;
  float64x2_t v9;
  float32x2_t v15;
  float32x2_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float v22;
  float32x4_t v23;
  double v24;
  int8x16_t v25;
  double v26;
  float v27;
  float64x2_t v28;
  double v29;
  int8x16_t v30;
  float32x4_t v31;
  double v32;
  double v33;
  float64x2_t v34;
  uint8x8_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  double v39;
  double v40;
  float64x2_t v41;
  uint8x8_t v42;
  double v43;
  int8x16_t v44;
  float32x4_t v45;
  double v46;
  double v47;
  float64x2_t v48;
  uint8x8_t v49;
  double v50;
  int8x16_t v51;
  float32x4_t v52;
  double v53;
  int8x16_t v54;
  double v55;
  float64x2_t v56;
  int8x16_t v57;
  float32x4_t v58;
  double v59;
  double v60;
  float64x2_t v61;
  uint8x8_t v62;
  double v63;
  int8x16_t v64;
  float32x4_t v65;
  double v66;
  double v67;
  float64x2_t v68;
  uint8x8_t v69;
  double v70;
  int8x16_t v71;
  float32x4_t v72;
  double v73;
  double v74;
  float64x2_t v75;
  uint8x8_t v76;
  double v77;
  int8x16_t v78;
  float32x4_t v79;
  double v80;
  double v81;
  float64x2_t v82;
  uint8x8_t v83;
  double v84;
  int8x16_t v85;
  float32x4_t v86;
  double v87;
  double v88;
  float64x2_t v89;
  uint8x8_t v90;
  double v91;
  int8x16_t v92;
  float32x4_t v93;
  double v94;
  double v95;
  float64x2_t v96;
  uint8x8_t v97;
  double v98;
  int8x16_t v99;
  float32x4_t v100;
  float v101;
  float v102;
  double v103;
  float v104;
  double v105;
  float v106;
  double v107;
  float v108;
  double v109;
  float v110;
  float v111;
  float v112;
  double v113;
  float v114;
  double v115;
  float v116;
  double v117;
  float v118;
  double v119;
  float v120;
  float v121;
  float v122;
  float v123;
  double v124;
  float v125;
  double v126;
  long double v127;
  float v128;
  double v129;
  float v130;
  double v131;
  float v132;
  float v133;
  float v134;
  double v135;
  float v136;
  double v137;
  long double v138;
  float v139;
  double v140;
  float v141;
  double v142;
  float v143;
  float v144;
  float v145;
  double v146;
  float v147;
  double v148;
  long double v149;
  float v150;
  double v151;
  float v152;
  double v153;
  long double v154;
  double v155;
  float v156;
  float v157;
  float v158;
  double v159;
  long double v160;
  float v161;
  float v162;
  double v163;
  long double v164;
  double result;
  float v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  double v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x2_t v178;
  float32x4_t v179;
  float32x4_t v180;
  int8x16_t v182;
  float v183;
  int8x16_t v184;
  float v185;
  int8x16_t v186;
  float v187;
  int8x16_t v188;
  uint8x8_t v189;
  float v190;
  int8x16_t v191;
  int8x16_t v192;
  float v193;
  int8x16_t v194;
  float v195;
  int8x16_t v196;
  float v197;
  float v198;
  float v199;
  int8x16_t v200;
  float v201;
  float v202;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  _Q2 = a2;
  *(float32x2_t *)v5.i8 = vmul_f32(*(float32x2_t *)a2.i8, *DC);
  v173 = *(double *)v5.i64;
  v6 = *(float *)&v5.i32[1];
  v7 = 0.5;
  *(float *)&v7 = floor(*(float *)&v5.i32[1] + -0.5) + 0.5;
  v189 = *(uint8x8_t *)&v7;
  v8 = v5;
  v8.i32[1] = LODWORD(v7);
  v9 = (float64x2_t)vextq_s8(_Q2, _Q2, 8uLL);
  __asm { FMOV            V2.2S, #5.0 }
  *(float32x2_t *)_Q2.i8 = vmul_f32(*(float32x2_t *)&v9.f64[0], *(float32x2_t *)_Q2.i8);
  *(float32x2_t *)v5.i8 = vsub_f32(*(float32x2_t *)v8.i8, *(float32x2_t *)_Q2.i8);
  __asm { FMOV            V4.2S, #4.0 }
  v15 = vmul_f32(*(float32x2_t *)&v9.f64[0], _D4);
  v178 = vsub_f32(*(float32x2_t *)v8.i8, v15);
  __asm { FMOV            V5.2S, #3.0 }
  v17 = vmul_f32(*(float32x2_t *)&v9.f64[0], _D5);
  *(float32x2_t *)v18.i8 = vsub_f32(*(float32x2_t *)v8.i8, v17);
  v182 = v18;
  *(float32x2_t *)v18.i8 = vadd_f32(*(float32x2_t *)&v9.f64[0], *(float32x2_t *)&v9.f64[0]);
  *(float32x2_t *)v19.i8 = vsub_f32(*(float32x2_t *)v8.i8, *(float32x2_t *)v18.i8);
  v184 = v19;
  *(float32x2_t *)v19.i8 = vsub_f32(*(float32x2_t *)v8.i8, *(float32x2_t *)&v9.f64[0]);
  v186 = v19;
  *(float32x2_t *)v19.i8 = vadd_f32(*(float32x2_t *)&v9.f64[0], *(float32x2_t *)v8.i8);
  v188 = v19;
  *(float32x2_t *)v18.i8 = vadd_f32(*(float32x2_t *)v18.i8, *(float32x2_t *)v8.i8);
  *(float32x2_t *)v20.i8 = vadd_f32(v17, *(float32x2_t *)v8.i8);
  v191 = v18;
  v192 = v20;
  *(float32x2_t *)v21.i8 = vadd_f32(v15, *(float32x2_t *)v8.i8);
  *(float32x2_t *)_Q2.i8 = vadd_f32(*(float32x2_t *)_Q2.i8, *(float32x2_t *)v8.i8);
  v194 = v21;
  v196 = _Q2;
  __asm { FMOV            V2.2S, #6.0 }
  *(float32x2_t *)&v9.f64[0] = vmul_f32(*(float32x2_t *)&v9.f64[0], *(float32x2_t *)_Q2.i8);
  *(float32x2_t *)v8.i8 = vadd_f32(*(float32x2_t *)&v9.f64[0], *(float32x2_t *)v8.i8);
  v200 = v8;
  _Q2.i32[0] = *(_DWORD *)(a1 + 28);
  v20.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v21.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v5.i8, 1), *(float *)_Q2.i32, *(float *)v5.i32);
  v22 = *(float *)&v5.i32[1];
  *(float *)v8.i32 = *(float *)(a1 + 24)
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v5.i8, 1), *(float *)(a1 + 16), *(float *)v5.i32);
  *(float *)v9.f64 = *(float *)v20.i32 + *(float *)v21.i32;
  *(float *)&v8.i32[1] = *(float *)v20.i32 + *(float *)v21.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v8.i64, v9, *(double *)_Q2.i64, *(double *)v5.i64, v21, *(uint8x8_t *)v20.i8, *(double *)v18.i64, v19);
  v180 = v23;
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v178, 1), *(float *)&v24, v178.f32[0]);
  v27 = v178.f32[1];
  v23.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v178, 1), *(float *)(a1 + 16), v178.f32[0]);
  *(float *)v28.f64 = *(float *)v25.i32 + *(float *)&v26;
  v23.f32[1] = *(float *)v25.i32 + *(float *)&v26;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v23.i64, v28, v24, v26, v25, (uint8x8_t)v178, v29, v30);
  v179 = v31;
  LODWORD(v32) = *(_DWORD *)(a1 + 28);
  v31.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v182.i8, 1), *(float *)(a1 + 16), *(float *)v182.i32);
  LODWORD(v33) = *(_DWORD *)(a1 + 36);
  *(float *)v34.f64 = *(float *)&v33
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v182.i8, 1), *(float *)&v32, *(float *)v182.i32);
  v31.i32[1] = LODWORD(v34.f64[0]);
  *(double *)v38.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v31.i64, v34, v32, v33, v182, v35, v36, v37);
  v177 = v38;
  LODWORD(v39) = *(_DWORD *)(a1 + 28);
  v38.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v184.i8, 1), *(float *)(a1 + 16), *(float *)v184.i32);
  LODWORD(v40) = *(_DWORD *)(a1 + 36);
  *(float *)v41.f64 = *(float *)&v40
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v184.i8, 1), *(float *)&v39, *(float *)v184.i32);
  v38.i32[1] = LODWORD(v41.f64[0]);
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v38.i64, v41, v39, v40, v184, v42, v43, v44);
  v176 = v45;
  LODWORD(v46) = *(_DWORD *)(a1 + 28);
  v45.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v186.i8, 1), *(float *)(a1 + 16), *(float *)v186.i32);
  LODWORD(v47) = *(_DWORD *)(a1 + 36);
  *(float *)v48.f64 = *(float *)&v47
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v186.i8, 1), *(float *)&v46, *(float *)v186.i32);
  v45.i32[1] = LODWORD(v48.f64[0]);
  *(double *)v52.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v48, v46, v47, v186, v49, v50, v51);
  v175 = v52;
  LODWORD(v53) = *(_DWORD *)(a1 + 28);
  v54.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&v55 = vmlas_n_f32(*(float *)(a1 + 32) * *(float *)v189.i32, *(float *)&v53, *(float *)&v173);
  v52.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(*(float *)(a1 + 20) * *(float *)v189.i32, *(float *)(a1 + 16), *(float *)&v173);
  *(float *)v56.f64 = *(float *)v54.i32 + *(float *)&v55;
  v52.f32[1] = *(float *)v54.i32 + *(float *)&v55;
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v52.i64, v56, v53, v55, v54, v189, v173, v57);
  v174 = v58;
  LODWORD(v59) = *(_DWORD *)(a1 + 28);
  v58.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v188.i8, 1), *(float *)(a1 + 16), *(float *)v188.i32);
  LODWORD(v60) = *(_DWORD *)(a1 + 36);
  *(float *)v61.f64 = *(float *)&v60
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v188.i8, 1), *(float *)&v59, *(float *)v188.i32);
  v58.i32[1] = LODWORD(v61.f64[0]);
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v58.i64, v61, v59, v60, v188, v62, v63, v64);
  v172 = v65;
  LODWORD(v66) = *(_DWORD *)(a1 + 28);
  v65.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v191.i8, 1), *(float *)(a1 + 16), *(float *)v191.i32);
  LODWORD(v67) = *(_DWORD *)(a1 + 36);
  *(float *)v68.f64 = *(float *)&v67
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v191.i8, 1), *(float *)&v66, *(float *)v191.i32);
  v65.i32[1] = LODWORD(v68.f64[0]);
  *(double *)v72.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v68, v66, v67, v191, v69, v70, v71);
  v171 = v72;
  LODWORD(v73) = *(_DWORD *)(a1 + 28);
  v72.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v192.i8, 1), *(float *)(a1 + 16), *(float *)v192.i32);
  LODWORD(v74) = *(_DWORD *)(a1 + 36);
  *(float *)v75.f64 = *(float *)&v74
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v192.i8, 1), *(float *)&v73, *(float *)v192.i32);
  v72.i32[1] = LODWORD(v75.f64[0]);
  *(double *)v79.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v72.i64, v75, v73, v74, v192, v76, v77, v78);
  v170 = v79;
  LODWORD(v80) = *(_DWORD *)(a1 + 28);
  v79.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v194.i8, 1), *(float *)(a1 + 16), *(float *)v194.i32);
  LODWORD(v81) = *(_DWORD *)(a1 + 36);
  *(float *)v82.f64 = *(float *)&v81
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v194.i8, 1), *(float *)&v80, *(float *)v194.i32);
  v79.i32[1] = LODWORD(v82.f64[0]);
  *(double *)v86.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v79.i64, v82, v80, v81, v194, v83, v84, v85);
  v169 = v86;
  LODWORD(v87) = *(_DWORD *)(a1 + 28);
  v86.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v196.i8, 1), *(float *)(a1 + 16), *(float *)v196.i32);
  LODWORD(v88) = *(_DWORD *)(a1 + 36);
  *(float *)v89.f64 = *(float *)&v88
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v196.i8, 1), *(float *)&v87, *(float *)v196.i32);
  v86.i32[1] = LODWORD(v89.f64[0]);
  *(double *)v93.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v86.i64, v89, v87, v88, v196, v90, v91, v92);
  v168 = v93;
  LODWORD(v94) = *(_DWORD *)(a1 + 28);
  v93.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v200.i8, 1), *(float *)(a1 + 16), *(float *)v200.i32);
  LODWORD(v95) = *(_DWORD *)(a1 + 36);
  *(float *)v96.f64 = *(float *)&v95
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v200.i8, 1), *(float *)&v94, *(float *)v200.i32);
  v93.i32[1] = LODWORD(v96.f64[0]);
  *(double *)v100.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v93.i64, v96, v94, v95, v200, v97, v98, v99);
  v167 = v100;
  v101 = fabsf((float)(v22 - v6) / *(float *)&a2.i32[1]);
  a2.i32[0] = 0;
  v102 = 0.0;
  if (v101 < 3.0)
  {
    v103 = v101;
    v102 = 1.0;
    if (v103 >= 0.001)
    {
      v104 = v103 * 3.14159265;
      v105 = sinf(v104) * 3.0;
      v102 = v105 * sin(v104 / 3.0) / (float)(v104 * v104);
    }
  }
  v166 = v102;
  v106 = fabsf((float)(v27 - v6) / *(float *)&a2.i32[1]);
  if (v106 < 3.0)
  {
    v107 = v106;
    a2.i32[0] = 1.0;
    if (v107 >= 0.001)
    {
      v108 = v107 * 3.14159265;
      v109 = sinf(v108) * 3.0;
      v110 = v109 * sin(v108 / 3.0) / (float)(v108 * v108);
      *(float *)a2.i32 = v110;
    }
  }
  v111 = fabsf((float)(*(float *)&v182.i32[1] - v6) / *(float *)&a2.i32[1]);
  v185 = 0.0;
  v112 = 0.0;
  if (v111 < 3.0)
  {
    v113 = v111;
    v112 = 1.0;
    if (v113 >= 0.001)
    {
      v114 = v113 * 3.14159265;
      v115 = sinf(v114) * 3.0;
      v112 = v115 * sin(v114 / 3.0) / (float)(v114 * v114);
    }
  }
  v183 = v112;
  v116 = fabsf((float)(*(float *)&v184.i32[1] - v6) / *(float *)&a2.i32[1]);
  if (v116 < 3.0)
  {
    v117 = v116;
    v185 = 1.0;
    if (v117 >= 0.001)
    {
      v118 = v117 * 3.14159265;
      v119 = sinf(v118) * 3.0;
      v120 = v119 * sin(v118 / 3.0) / (float)(v118 * v118);
      v185 = v120;
    }
  }
  v121 = fabsf((float)(*(float *)&v186.i32[1] - v6) / *(float *)&a2.i32[1]);
  v122 = 0.0;
  v123 = 0.0;
  if (v121 < 3.0)
  {
    v124 = v121;
    v123 = 1.0;
    if (v124 >= 0.001)
    {
      v125 = v124 * 3.14159265;
      v126 = sinf(v125) * 3.0;
      v127 = sin(v125 / 3.0);
      v122 = 0.0;
      v123 = v126 * v127 / (float)(v125 * v125);
    }
  }
  v187 = v123;
  v128 = fabsf((float)(*(float *)v189.i32 - v6) / *(float *)&a2.i32[1]);
  if (v128 < 3.0)
  {
    v129 = v128;
    v122 = 1.0;
    if (v129 >= 0.001)
    {
      v130 = v129 * 3.14159265;
      v131 = sinf(v130) * 3.0;
      v122 = v131 * sin(v130 / 3.0) / (float)(v130 * v130);
    }
  }
  v190 = v122;
  v132 = fabsf((float)(*(float *)&v188.i32[1] - v6) / *(float *)&a2.i32[1]);
  v133 = 0.0;
  v134 = 0.0;
  if (v132 < 3.0)
  {
    v135 = v132;
    v134 = 1.0;
    if (v135 >= 0.001)
    {
      v136 = v135 * 3.14159265;
      v137 = sinf(v136) * 3.0;
      v138 = sin(v136 / 3.0);
      v133 = 0.0;
      v134 = v137 * v138 / (float)(v136 * v136);
    }
  }
  *(float *)v191.i32 = v134;
  v139 = fabsf((float)(*(float *)&v191.i32[1] - v6) / *(float *)&a2.i32[1]);
  if (v139 < 3.0)
  {
    v140 = v139;
    v133 = 1.0;
    if (v140 >= 0.001)
    {
      v141 = v140 * 3.14159265;
      v142 = sinf(v141) * 3.0;
      v133 = v142 * sin(v141 / 3.0) / (float)(v141 * v141);
    }
  }
  v143 = fabsf((float)(*(float *)&v192.i32[1] - v6) / *(float *)&a2.i32[1]);
  v144 = 0.0;
  v145 = 0.0;
  v193 = v133;
  if (v143 < 3.0)
  {
    v146 = v143;
    v145 = 1.0;
    if (v146 >= 0.001)
    {
      v147 = v146 * 3.14159265;
      v148 = sinf(v147) * 3.0;
      v149 = sin(v147 / 3.0);
      v144 = 0.0;
      v133 = v193;
      v145 = v148 * v149 / (float)(v147 * v147);
    }
  }
  v150 = fabsf((float)(*(float *)&v194.i32[1] - v6) / *(float *)&a2.i32[1]);
  if (v150 < 3.0)
  {
    v151 = v150;
    v144 = 1.0;
    if (v151 >= 0.001)
    {
      v152 = v151 * 3.14159265;
      v197 = v145;
      v153 = sinf(v152) * 3.0;
      v154 = sin(v152 / 3.0);
      v145 = v197;
      v133 = v193;
      v144 = v153 * v154 / (float)(v152 * v152);
    }
  }
  HIDWORD(v155) = v200.i32[1];
  *(float *)&v155 = fabsf((float)(*(float *)&v196.i32[1] - v6) / *(float *)&a2.i32[1]);
  v156 = 0.0;
  v157 = 0.0;
  if (*(float *)&v155 < 3.0)
  {
    v155 = *(float *)&v155;
    v157 = 1.0;
    if (v155 >= 0.001)
    {
      v158 = v155 * 3.14159265;
      v198 = v145;
      v201 = v144;
      v159 = sinf(v158) * 3.0;
      v160 = sin(v158 / 3.0);
      v156 = 0.0;
      v145 = v198;
      v144 = v201;
      v133 = v193;
      v155 = v159 * v160 / (float)(v158 * v158);
      v157 = v155;
    }
  }
  v161 = fabsf((float)(*(float *)&v200.i32[1] - v6) / *(float *)&a2.i32[1]);
  if (v161 < 3.0)
  {
    v155 = v161;
    v156 = 1.0;
    if (v155 >= 0.001)
    {
      v162 = v155 * 3.14159265;
      v199 = v145;
      v202 = v144;
      v195 = v157;
      v163 = sinf(v162) * 3.0;
      v164 = sin(v162 / 3.0);
      v157 = v195;
      v145 = v199;
      v144 = v202;
      v133 = v193;
      v155 = v163 * v164 / (float)(v162 * v162);
      v156 = v155;
    }
  }
  *(float *)&v155 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v166
                                                                                                  + *(float *)a2.i32)
                                                                                          + v183)
                                                                                  + v185)
                                                                          + v187)
                                                                  + v190)
                                                          + *(float *)v191.i32)
                                                  + v133)
                                          + v145)
                                  + v144)
                          + v157)
                  + v156;
  *(_QWORD *)&result = vdivq_f32(vaddq_f32(vmulq_n_f32(v172, *(float *)v191.i32), vaddq_f32(vmulq_n_f32(v171, v133), vaddq_f32(vmulq_n_f32(v170, v145), vaddq_f32(vmulq_n_f32(v169, v144), vaddq_f32(vmulq_n_f32(v168, v157), vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(v180, v166), vmulq_n_f32(v179, *(float *)a2.i32)), vmulq_n_f32(v177, v183)), vmulq_n_f32(v176, v185)), vmulq_n_f32(v175, v187)),
                                       vmulq_n_f32(v174, v190)),
                                     vmulq_n_f32(v167, v156))))))),
                         (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v155, 0)).u64[0];
  return result;
}

double cikernel::_lanczosUpH(cikernel *this, SamplerObj *a2, float a3)
{
  float64x2_t v5;
  float v6;
  float32x2_t v7;
  float v8;
  int8x16_t v9;
  int8x16_t v10;
  float v11;
  double v12;
  double v13;
  float v14;
  double v15;
  double v16;
  float64x2_t v17;
  float32x4_t v18;
  float64x2_t v19;
  double v20;
  double v21;
  uint8x8_t v22;
  int8x16_t v23;
  double v24;
  int8x16_t v25;
  float32x4_t v26;
  float64x2_t v27;
  double v28;
  double v29;
  uint8x8_t v30;
  int8x16_t v31;
  double v32;
  int8x16_t v33;
  float32x4_t v34;
  float64x2_t v35;
  double v36;
  double v37;
  uint8x8_t v38;
  int8x16_t v39;
  double v40;
  int8x16_t v41;
  float32x4_t v42;
  double result;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float64x2_t v51;

  v5.f64[0] = *(float64_t *)CI::getDC(this);
  v6 = (float)(a3 * *(float *)v5.f64) + -0.5;
  LODWORD(v5.f64[0]) = floorf(v6);
  v7 = *(float32x2_t *)&v5.f64[0];
  v51 = v5;
  v8 = (float)(*(float *)v5.f64 - v6) + 1.0;
  v5.f64[0] = (float)(v8 * v8);
  v9.i32[1] = 1072237884;
  v10.i64[0] = 0x3FF0A64571793F06;
  v11 = v5.f64[0] * (v8 * (v8 * (v8 * -0.41086841 + 0.78286595) + 1.04059357) + -2.41189213) + 1.0;
  v49 = v11;
  v12 = v8 * (v8 * -0.29216512 + 1.02524562) + -0.5242291;
  v13 = v8 * v12 + -0.2088514;
  *(float *)&v13 = v13 * v5.f64[0];
  v14 = 1.0 - v8;
  v15 = (float)(v14 * v14);
  v16 = v14;
  v5.f64[0] = v16 * (v16 * -0.41086841 + 0.78286595) + 1.04059357;
  *(float *)&v15 = v15 * (v16 * v5.f64[0] + -2.41189213) + 1.0;
  v47 = *(float *)&v15;
  v48 = *(float *)&v13;
  *(float *)&v16 = 1.0 - *(float *)&v13 - *(float *)&v15 - v11;
  v50 = *(float *)&v16;
  *(float32x2_t *)&v17.f64[0] = vadd_f32(v7, (float32x2_t)3204448256);
  LODWORD(v13) = *((_DWORD *)this + 7);
  *(float *)&v16 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v17.f64[0], 1), *((float *)this + 4), *(float *)v17.f64);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v5.f64 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v17.f64[0], 1), *(float *)&v13, *(float *)v17.f64);
  *(float *)v17.f64 = *(float *)v9.i32 + *(float *)v5.f64;
  *((float *)&v16 + 1) = *(float *)v9.i32 + *(float *)v5.f64;
  *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v16, v17, v5.f64[0], v13, v9, (uint8x8_t)0xBFDA4BAB03FA3591, v12, v10);
  v46 = v18;
  v19 = v51;
  *(float32x2_t *)v18.f32 = vadd_f32(*(float32x2_t *)&v51.f64[0], (float32x2_t)1056964608);
  *(float *)&v20 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v18.f32, 1), *((float *)this + 4), v18.f32[0]);
  LODWORD(v21) = *((_DWORD *)this + 7);
  v22.i32[0] = *((_DWORD *)this + 9);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v18.f32, 1), *(float *)&v21, v18.f32[0]);
  v18.f32[0] = *((float *)this + 6) + *(float *)&v20;
  *(float *)v19.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v18.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v18.i64, v19, v20, v21, v23, v22, v24, v25);
  v45 = v26;
  v27 = v51;
  *(float32x2_t *)v26.f32 = vadd_f32(*(float32x2_t *)&v51.f64[0], (float32x2_t)1069547520);
  *(float *)&v28 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v26.f32, 1), *((float *)this + 4), v26.f32[0]);
  LODWORD(v29) = *((_DWORD *)this + 7);
  v30.i32[0] = *((_DWORD *)this + 9);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v26.f32, 1), *(float *)&v29, v26.f32[0]);
  v26.f32[0] = *((float *)this + 6) + *(float *)&v28;
  *(float *)v27.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v26.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v26.i64, v27, v28, v29, v31, v30, v32, v33);
  v44 = v34;
  v35 = v51;
  *(float32x2_t *)v34.f32 = vadd_f32(*(float32x2_t *)&v51.f64[0], (float32x2_t)1075838976);
  *(float *)&v36 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v34.f32, 1), *((float *)this + 4), v34.f32[0]);
  LODWORD(v37) = *((_DWORD *)this + 7);
  v38.i32[0] = *((_DWORD *)this + 9);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v34.f32, 1), *(float *)&v37, v34.f32[0]);
  v34.f32[0] = *((float *)this + 6) + *(float *)&v36;
  *(float *)v35.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v34.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)v42.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v34.i64, v35, v36, v37, v39, v38, v40, v41);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(v46, v48), vmulq_n_f32(v45, v47)), vmulq_n_f32(v44, v49)), vmulq_n_f32(v42, v50)).u64[0];
  return result;
}

double upsampleHRect(double a1, float a2)
{
  float32x2_t v2;
  float32x2_t v3;
  float32x2_t v4;
  float32x2_t v5;
  double result;
  float32x2_t v7;
  CGRect v8;
  CGRect v9;
  CGRect v10;
  CGRect v11;
  CGRect v12;
  CGRect v13;
  CGRect v14;

  v7 = (float32x2_t)__PAIR64__(HIDWORD(a1), COERCE_UNSIGNED_INT(floorf((float)(a2 * *(float *)&a1) + -0.5)));
  v2 = vadd_f32(v7, (float32x2_t)3204448256);
  v11.origin.x = v2.f32[0];
  v11.origin.y = v2.f32[1];
  v11.size.width = 0.0;
  v11.size.height = 0.0;
  v8 = CGRectUnion(*MEMORY[0x1E0C9D628], v11);
  v3 = vadd_f32(v7, (float32x2_t)1056964608);
  v12.origin.x = v3.f32[0];
  v12.origin.y = v3.f32[1];
  v12.size.width = 0.0;
  v12.size.height = 0.0;
  v9 = CGRectUnion(v8, v12);
  v4 = vadd_f32(v7, (float32x2_t)1069547520);
  v13.origin.x = v4.f32[0];
  v13.origin.y = v4.f32[1];
  v13.size.width = 0.0;
  v13.size.height = 0.0;
  v10 = CGRectUnion(v9, v13);
  v5 = vadd_f32(v7, (float32x2_t)1075838976);
  v14.origin.x = v5.f32[0];
  v14.origin.y = v5.f32[1];
  v14.size.width = 0.0;
  v14.size.height = 0.0;
  *(_QWORD *)&result = (unint64_t)CGRectUnion(v10, v14);
  return result;
}

double cikernel::_lanczosUpV(cikernel *this, SamplerObj *a2, float a3)
{
  float64x2_t v5;
  float v6;
  float32x2_t v7;
  float v8;
  int8x16_t v9;
  int8x16_t v10;
  float v11;
  double v12;
  double v13;
  float v14;
  double v15;
  double v16;
  float64x2_t v17;
  float32x4_t v18;
  float64x2_t v19;
  double v20;
  double v21;
  uint8x8_t v22;
  int8x16_t v23;
  double v24;
  int8x16_t v25;
  float32x4_t v26;
  float64x2_t v27;
  double v28;
  double v29;
  uint8x8_t v30;
  int8x16_t v31;
  double v32;
  int8x16_t v33;
  float32x4_t v34;
  float64x2_t v35;
  double v36;
  double v37;
  uint8x8_t v38;
  int8x16_t v39;
  double v40;
  int8x16_t v41;
  float32x4_t v42;
  double result;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float64x2_t v51;

  v5.f64[0] = *(float64_t *)CI::getDC(this);
  v6 = vmuls_lane_f32(a3, *(float32x2_t *)&v5.f64[0], 1) + -0.5;
  HIDWORD(v5.f64[0]) = floorf(v6);
  v7 = *(float32x2_t *)&v5.f64[0];
  v51 = v5;
  v8 = (float)(*((float *)v5.f64 + 1) - v6) + 1.0;
  v5.f64[0] = (float)(v8 * v8);
  v9.i32[1] = 1072237884;
  v10.i64[0] = 0x3FF0A64571793F06;
  v11 = v5.f64[0] * (v8 * (v8 * (v8 * -0.41086841 + 0.78286595) + 1.04059357) + -2.41189213) + 1.0;
  v48 = v11;
  v12 = v8 * (v8 * -0.29216512 + 1.02524562) + -0.5242291;
  v13 = v8 * v12 + -0.2088514;
  *(float *)&v13 = v13 * v5.f64[0];
  v50 = *(float *)&v13;
  v14 = 1.0 - v8;
  v15 = (float)(v14 * v14);
  v16 = v14;
  v5.f64[0] = v16 * (v16 * -0.41086841 + 0.78286595) + 1.04059357;
  *(float *)&v15 = v15 * (v16 * v5.f64[0] + -2.41189213) + 1.0;
  v47 = *(float *)&v15;
  *(float *)&v16 = 1.0 - *(float *)&v13 - *(float *)&v15 - v11;
  v49 = *(float *)&v16;
  *(float32x2_t *)&v17.f64[0] = vadd_f32(v7, (float32x2_t)0xBF00000000000000);
  LODWORD(v13) = *((_DWORD *)this + 7);
  *(float *)&v16 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v17.f64[0], 1), *((float *)this + 4), *(float *)v17.f64);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v5.f64 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v17.f64[0], 1), *(float *)&v13, *(float *)v17.f64);
  *(float *)v17.f64 = *(float *)v9.i32 + *(float *)v5.f64;
  *((float *)&v16 + 1) = *(float *)v9.i32 + *(float *)v5.f64;
  *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v16, v17, v5.f64[0], v13, v9, (uint8x8_t)0xBFDA4BAB03FA3591, v12, v10);
  v46 = v18;
  v19 = v51;
  *(float32x2_t *)v18.f32 = vadd_f32(*(float32x2_t *)&v51.f64[0], (float32x2_t)0x3F00000000000000);
  *(float *)&v20 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v18.f32, 1), *((float *)this + 4), v18.f32[0]);
  LODWORD(v21) = *((_DWORD *)this + 7);
  v22.i32[0] = *((_DWORD *)this + 9);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v18.f32, 1), *(float *)&v21, v18.f32[0]);
  v18.f32[0] = *((float *)this + 6) + *(float *)&v20;
  *(float *)v19.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v18.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v18.i64, v19, v20, v21, v23, v22, v24, v25);
  v45 = v26;
  v27 = v51;
  *(float32x2_t *)v26.f32 = vadd_f32(*(float32x2_t *)&v51.f64[0], (float32x2_t)0x3FC0000000000000);
  *(float *)&v28 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v26.f32, 1), *((float *)this + 4), v26.f32[0]);
  LODWORD(v29) = *((_DWORD *)this + 7);
  v30.i32[0] = *((_DWORD *)this + 9);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v26.f32, 1), *(float *)&v29, v26.f32[0]);
  v26.f32[0] = *((float *)this + 6) + *(float *)&v28;
  *(float *)v27.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v26.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v26.i64, v27, v28, v29, v31, v30, v32, v33);
  v44 = v34;
  v35 = v51;
  *(float32x2_t *)v34.f32 = vadd_f32(*(float32x2_t *)&v51.f64[0], (float32x2_t)0x4020000000000000);
  *(float *)&v36 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v34.f32, 1), *((float *)this + 4), v34.f32[0]);
  LODWORD(v37) = *((_DWORD *)this + 7);
  v38.i32[0] = *((_DWORD *)this + 9);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v34.f32, 1), *(float *)&v37, v34.f32[0]);
  v34.f32[0] = *((float *)this + 6) + *(float *)&v36;
  *(float *)v35.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v34.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)v42.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v34.i64, v35, v36, v37, v39, v38, v40, v41);
  *(_QWORD *)&result = vaddq_f32(vaddq_f32(vmulq_n_f32(v46, v50), vaddq_f32(vmulq_n_f32(v45, v47), vmulq_n_f32(v44, v48))), vmulq_n_f32(v42, v49)).u64[0];
  return result;
}

double upsampleVRect(float32x2_t a1, float a2)
{
  float32x2_t v2;
  float32x2_t v3;
  float32x2_t v4;
  float32x2_t v5;
  double result;
  float32x2_t v7;
  CGRect v8;
  CGRect v9;
  CGRect v10;
  CGRect v11;
  CGRect v12;
  CGRect v13;
  CGRect v14;

  v7 = (float32x2_t)__PAIR64__(COERCE_UNSIGNED_INT(floorf(vmuls_lane_f32(a2, a1, 1) + -0.5)), a1.u32[0]);
  v2 = vadd_f32(v7, (float32x2_t)0x3F00000000000000);
  v11.origin.x = v2.f32[0];
  v11.origin.y = v2.f32[1];
  v11.size.width = 0.0;
  v11.size.height = 0.0;
  v8 = CGRectUnion(*MEMORY[0x1E0C9D628], v11);
  v3 = vadd_f32(v7, (float32x2_t)0xBF00000000000000);
  v12.origin.x = v3.f32[0];
  v12.origin.y = v3.f32[1];
  v12.size.width = 0.0;
  v12.size.height = 0.0;
  v9 = CGRectUnion(v8, v12);
  v4 = vadd_f32(v7, (float32x2_t)0x3FC0000000000000);
  v13.origin.x = v4.f32[0];
  v13.origin.y = v4.f32[1];
  v13.size.width = 0.0;
  v13.size.height = 0.0;
  v10 = CGRectUnion(v9, v13);
  v5 = vadd_f32(v7, (float32x2_t)0x4020000000000000);
  v14.origin.x = v5.f32[0];
  v14.origin.y = v5.f32[1];
  v14.size.width = 0.0;
  v14.size.height = 0.0;
  *(_QWORD *)&result = (unint64_t)CGRectUnion(v10, v14);
  return result;
}

double cikernel::_lozengeRefraction(uint64_t a1, float32x2_t a2, float32x2_t a3, float a4, double a5, int8x8_t a6, float a7, float a8)
{
  float32x2_t *DC;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  int8x8_t v18;
  int32x2_t v19;
  float v20;
  float v21;
  float32x2_t v22;
  int8x8_t v23;
  int32x2_t v24;
  float32x2_t *v25;
  float32x4_t v26;
  int32x2_t v27;
  unsigned __int32 v28;
  float v29;
  float32x2_t v30;
  float v31;
  int32x2_t v32;
  int32x2_t v33;
  float32x4_t v34;
  float v35;
  unsigned int v36;
  BOOL v37;
  unsigned int v38;
  int8x8_t v39;
  float v40;
  double v41;
  float32x4_t v42;
  int32x2_t v43;
  float32x2_t v44;
  double v45;
  double v46;
  uint8x8_t v47;
  int8x16_t v48;
  float64x2_t v49;
  double v50;
  int8x16_t v51;
  CI *v52;
  int8x16_t v53;
  float32x4_t v54;
  int8x16_t v55;
  float v56;
  float v57;
  float32x2_t *v58;
  double v59;
  double v60;
  uint8x8_t v61;
  int8x16_t v62;
  double v63;
  float64x2_t v64;
  double v65;
  int8x16_t v66;
  float32x4_t v67;
  double result;
  float v70;
  float32x4_t v72;
  float32x4_t v73;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v15 = vsub_f32(*DC, a2);
  v16.f32[0] = vmlas_n_f32(vmuls_lane_f32(-*(float *)&a5, v15, 1), *((float *)&a5 + 1), v15.f32[0]);
  v17.i32[0] = 0;
  v18 = vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(v17, v16), 0), a6, (int8x8_t)vneg_f32((float32x2_t)a6));
  v19 = (int32x2_t)vmul_f32(v15, v15);
  v20 = fabsf(v16.f32[0]);
  v16.i32[0] = vadd_f32((float32x2_t)v19, (float32x2_t)vdup_lane_s32(v19, 1)).u32[0];
  v21 = sqrtf(vaddv_f32((float32x2_t)v19));
  v22 = vrsqrte_f32((float32x2_t)v16.u32[0]);
  v23 = (int8x8_t)vmul_n_f32(v15, vmul_f32(v22, vrsqrts_f32((float32x2_t)v16.u32[0], vmul_f32(v22, v22))).f32[0]);
  v24 = (int32x2_t)vmul_f32(*(float32x2_t *)&a5, v15);
  v25 = (float32x2_t *)CI::getDC((CI *)DC);
  *(float32x2_t *)v34.f32 = vsub_f32(*v25, a3);
  v27 = (int32x2_t)vmul_f32(*(float32x2_t *)v34.f32, *(float32x2_t *)v34.f32);
  v28 = vadd_f32((float32x2_t)v27, (float32x2_t)vdup_lane_s32(v27, 1)).u32[0];
  v29 = sqrtf(vaddv_f32((float32x2_t)v27));
  v30 = vrsqrte_f32((float32x2_t)v28);
  LODWORD(v31) = vmul_f32(v30, vrsqrts_f32((float32x2_t)v28, vmul_f32(v30, v30))).u32[0];
  v32 = (int32x2_t)vmul_f32(*(float32x2_t *)&a5, *(float32x2_t *)v34.f32);
  v33 = vcltz_f32(vadd_f32((float32x2_t)vzip1_s32(v32, v24), (float32x2_t)vzip2_s32(v32, v24)));
  *(float32x2_t *)v34.f32 = vmul_n_f32(*(float32x2_t *)v34.f32, v31);
  if ((v33.i8[4] & 1) != 0)
    v35 = v20;
  else
    v35 = v21;
  if ((v33.i8[4] & 1) != 0)
    v36 = -1;
  else
    v36 = 0;
  *(int8x8_t *)v26.f32 = vbsl_s8((int8x8_t)vdup_n_s32(v36), v18, v23);
  v37 = (v33.i8[0] & 1) == 0;
  if ((v33.i8[0] & 1) != 0)
    v38 = -1;
  else
    v38 = 0;
  v39 = (int8x8_t)vdup_n_s32(v38);
  if (v37)
    v40 = v35;
  else
    v40 = v29;
  *(float32x2_t *)v34.f32 = vmul_n_f32((float32x2_t)vbsl_s8(v39, *(int8x8_t *)v34.f32, *(int8x8_t *)v26.f32), v40 / a4);
  v41 = sqrt(1.0 - (float)((float)(v40 / a4) * (float)(v40 / a4)));
  *(float *)&v41 = v41;
  v34.i32[2] = LODWORD(v41);
  *(double *)v26.i64 = (float)((float)(1.0 / a7) * (float)(1.0 / a7));
  v26.f32[0] = 1.0 - *(double *)v26.i64 * (1.0 - (float)(*(float *)&v41 * *(float *)&v41));
  v72 = v26;
  v42 = vaddq_f32(vmulq_n_f32((float32x4_t)xmmword_192495E10, 1.0 / a7), vmulq_n_f32(v34, -(float)(sqrtf(fabsf(v26.f32[0])) - (float)((float)(1.0 / a7) * *(float *)&v41))));
  *(float32x2_t *)v42.f32 = vmul_n_f32(*(float32x2_t *)v42.f32, (float)-(float)(a8 + (float)(*(float *)&v41 * a4)) / v42.f32[2]);
  *(float *)&v41 = a4 + a4;
  v43 = vdup_lane_s32(*(int32x2_t *)&v41, 0);
  *(float32x2_t *)v42.f32 = vminnm_f32(*(float32x2_t *)v42.f32, (float32x2_t)v43);
  *(float *)v43.i32 = a4 * -2.0;
  v44 = vadd_f32(vmaxnm_f32(*(float32x2_t *)v42.f32, (float32x2_t)vdup_lane_s32(v43, 0)), *(float32x2_t *)CI::getDC((CI *)v25));
  *(float *)&v45 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v44, 1), *(float *)(a1 + 16), v44.f32[0]);
  LODWORD(v46) = *(_DWORD *)(a1 + 28);
  v47.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v44, 1), *(float *)&v46, v44.f32[0]);
  v44.f32[0] = *(float *)(a1 + 24) + *(float *)&v45;
  *(float *)v49.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  v44.f32[1] = *(float *)v47.i32 + *(float *)v48.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v44, v49, v45, v46, v48, v47, v50, v51);
  v54.i32[0] = 0;
  v55 = vandq_s8(v53, (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgtq_f32(v54, v72)), 0));
  if ((float)(a4 - v40) <= 1.0)
    v56 = a4 - v40;
  else
    v56 = 1.0;
  if ((float)(a4 - v40) >= 0.0)
    v57 = v56;
  else
    v57 = 0.0;
  v70 = v57;
  v73 = (float32x4_t)v55;
  v58 = (float32x2_t *)CI::getDC(v52);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *v58, 1), *(float *)(a1 + 16), COERCE_FLOAT(*v58));
  LODWORD(v60) = *(_DWORD *)(a1 + 28);
  v61.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *v58, 1), *(float *)&v60, COERCE_FLOAT(*v58));
  *(float *)&v63 = *(float *)(a1 + 24) + *(float *)&v59;
  *(float *)v64.f64 = *(float *)v61.i32 + *(float *)v62.i32;
  *((float *)&v63 + 1) = *(float *)v61.i32 + *(float *)v62.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v63, v64, v59, v60, v62, v61, v65, v66);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v67, 1.0 - v70), v73, v70).u64[0];
  return result;
}

void CI::f4_sr_f2_f2_f_f2_f2_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, double, double, float, double, double, float, float);
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  double *v24;
  double *v25;
  double *v26;
  double *v27;
  __int128 v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  double (*v34)(uint64_t, double, double, float, double, double, float, float);

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, double, double, float, double, double, float, float))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  v17 = *(_QWORD *)(v10 + 80);
  v18 = *(_DWORD *)(v10 + 112);
  v19 = *(_QWORD *)(v10 + 104);
  v20 = *(_DWORD *)(v10 + 136);
  v21 = *(_QWORD *)(v10 + 128);
  v22 = *(_QWORD *)(v10 + 152);
  v23 = *(_QWORD *)(v10 + 176);
  if (*(_BYTE *)(a1 + 64))
  {
    v33 = *(_QWORD *)(v10 + 32);
    v34 = *(double (**)(uint64_t, double, double, float, double, double, float, float))(a1 + 24);
    v32 = *(_QWORD *)(v10 + 8);
    v30 = *(_QWORD *)(v10 + 152);
    v31 = *(_DWORD *)(v10 + 64);
    v29 = *(_DWORD *)(v10 + 136);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 200)), a2);
    v20 = v29;
    v15 = v31;
    v12 = v32;
    v14 = v33;
    v22 = v30;
    v11 = v34;
  }
  v24 = (double *)(a3 + 16 * v21);
  if (v20 != 5)
    v24 = (double *)((char *)a2 + 64 * v21);
  v25 = (double *)(a3 + 16 * v19);
  if (v18 != 5)
    v25 = (double *)((char *)a2 + 64 * v19);
  v26 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v26 = (double *)((char *)a2 + 64 * v16);
  v27 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v27 = (double *)((char *)a2 + 64 * v14);
  *(double *)&v28 = v11(a4 + 80 * v12, *v27, *v26, *((float *)a2 + 16 * v17), *v25, *v24, *((float *)a2 + 16 * v22), *((float *)a2 + 16 * v23));
  *(_OWORD *)(a3 + 16 * a7) = v28;
}

double cikernel::_torusRefraction(uint64_t a1, float32x2_t a2, float a3, float a4, float a5, float a6, float a7)
{
  float32x2_t *DC;
  int32x2_t v15;
  float32x2_t v16;
  int8x16_t v17;
  float v18;
  float32x4_t v19;
  float v20;
  BOOL v21;
  float32x4_t v22;
  int8x16_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  int8x16_t v27;
  int8x16_t v28;
  int8x16_t v29;
  float64x2_t v30;
  uint8x8_t v31;
  double v32;
  int8x16_t v33;
  int8x16_t v34;
  float32x4_t v35;
  CI *v36;
  float32x2_t *v37;
  double v38;
  double v39;
  uint8x8_t v40;
  int8x16_t v41;
  double v42;
  float64x2_t v43;
  double v44;
  int8x16_t v45;
  float32x4_t v46;
  double result;
  int8x16_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v17.i8 = vsub_f32(*DC, a2);
  v15 = (int32x2_t)vmul_f32(*(float32x2_t *)v17.i8, *(float32x2_t *)v17.i8);
  v19.i32[0] = vadd_f32((float32x2_t)v15, (float32x2_t)vdup_lane_s32(v15, 1)).u32[0];
  v16 = vrsqrte_f32((float32x2_t)v19.u32[0]);
  *(float32x2_t *)v17.i8 = vmul_n_f32(*(float32x2_t *)v17.i8, vmul_f32(v16, vrsqrts_f32((float32x2_t)v19.u32[0], vmul_f32(v16, v16))).f32[0]);
  v18 = a4 + (float)(a3 * sqrtf(vaddv_f32((float32x2_t)v15)));
  *(double *)v19.i64 = (1.0 - fabsf(v18)) * a5;
  v19.f32[0] = *(double *)v19.i64;
  if (v19.f32[0] <= 1.0)
    v20 = v19.f32[0];
  else
    v20 = 1.0;
  v21 = v19.f32[0] < 0.0;
  v19.i32[0] = 0;
  if (!v21)
    v19.f32[0] = v20;
  v52 = v19;
  *(float32x2_t *)v19.f32 = vmul_n_f32(*(float32x2_t *)v17.i8, v18);
  *(double *)v17.i64 = sqrt(1.0 - (float)(v18 * v18));
  *(float *)v17.i32 = *(double *)v17.i64;
  v19.i32[2] = v17.i32[0];
  v48 = v17;
  v49 = v19;
  v22.i64[0] = *(_QWORD *)CI::getDC((CI *)DC);
  v23 = v48;
  *(double *)v24.i64 = 1.0 - (float)(*(float *)v23.i32 * *(float *)v23.i32);
  v24.f32[0] = 1.0 - (float)((float)(1.0 / a6) * (float)(1.0 / a6)) * *(double *)v24.i64;
  v50 = v24;
  v25 = vmulq_n_f32((float32x4_t)xmmword_192495E10, 1.0 / a6);
  v24.i32[1] = v49.i32[1];
  v26 = vaddq_f32(v25, vmulq_n_f32(v49, -(float)(sqrtf(fabsf(v24.f32[0])) - (float)((float)(1.0 / a6) * *(float *)v48.i32))));
  v27 = (int8x16_t)vaddq_f32(v22, vmulq_n_f32(v26, (float)-(float)(a7 + (float)(*(float *)v48.i32 * a5)) / v26.f32[2]));
  v26.i64[1] = v52.i64[1];
  *(double *)v26.i64 = v52.f32[0];
  v25.i64[0] = 0x3F50624DD2F1A9FCLL;
  v28 = (int8x16_t)vcgtq_f64((float64x2_t)v25, (float64x2_t)v26);
  v29 = (int8x16_t)vdupq_n_s32(0x42480000u);
  v30 = (float64x2_t)vbslq_s8(v28, v29, v27);
  v24.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v27.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v30.f64[0], 1), *(float *)(a1 + 16), *(float *)v30.f64);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v30.f64[0], 1), v24.f32[0], *(float *)v30.f64);
  *(float *)v30.f64 = *(float *)v23.i32 + *(float *)v29.i32;
  *(float *)&v27.i32[1] = *(float *)v23.i32 + *(float *)v29.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v30, *(double *)v29.i64, *(double *)v24.i64, v23, v31, v32, v33);
  v35.i32[0] = 0;
  v51 = (float32x4_t)vandq_s8(v34, (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgtq_f32(v35, v50)), 0));
  v37 = (float32x2_t *)CI::getDC(v36);
  *(float *)&v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *v37, 1), *(float *)(a1 + 16), COERCE_FLOAT(*v37));
  LODWORD(v39) = *(_DWORD *)(a1 + 28);
  v40.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *v37, 1), *(float *)&v39, COERCE_FLOAT(*v37));
  *(float *)&v42 = *(float *)(a1 + 24) + *(float *)&v38;
  *(float *)v43.f64 = *(float *)v40.i32 + *(float *)v41.i32;
  *((float *)&v42 + 1) = *(float *)v40.i32 + *(float *)v41.i32;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v42, v43, v38, v39, v41, v40, v44, v45);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v46, 1.0 - v52.f32[0]), v51, v52.f32[0]).u64[0];
  return result;
}

void CI::f4_sr_f2_f_f_f_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8;
  uint64_t v10;
  double (*v11)(uint64_t, double, float, float, float, float, float);
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double *v21;
  __int128 v22;
  uint64_t v23;

  v8 = a3;
  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, double, float, float, float, float, float))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_QWORD *)(v10 + 80);
  v17 = *(_QWORD *)(v10 + 104);
  v18 = *(_QWORD *)(v10 + 128);
  v19 = *(_QWORD *)(v10 + 152);
  if (*(_BYTE *)(a1 + 64))
  {
    v23 = *(_QWORD *)(v10 + 128);
    v20 = *(_QWORD *)(v10 + 104);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 176)), a2);
    v17 = v20;
    v18 = v23;
    v8 = a3;
  }
  v21 = (double *)(v8 + 16 * v14);
  if (v13 != 5)
    v21 = (double *)((char *)a2 + 64 * v14);
  *(double *)&v22 = v11(a4 + 80 * v12, *v21, *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16), *((float *)a2 + 16 * v17), *((float *)a2 + 16 * v18), *((float *)a2 + 16 * v19));
  *(_OWORD *)(v8 + 16 * a7) = v22;
}

float sampleLinearWithOffset(void *a1, unsigned int a2, double a3, double a4)
{
  uint64_t v8;
  float v9;
  uint64_t v10;
  double v11;
  double v12;
  int v13;
  double v14;
  int v15;
  char v16;
  unsigned int v17;
  double v18;
  _BYTE *v19;
  double v20;
  double v21;
  vImage_Buffer dest;
  vImage_Buffer src;
  float v25;

  v8 = objc_msgSend(a1, "baseAddress");
  v9 = 0.0;
  if (a3 >= 0.0 && a4 >= 0.0)
  {
    v10 = v8;
    objc_msgSend(a1, "region");
    if (a3 + 1.0 <= v11)
    {
      objc_msgSend(a1, "region");
      if (a4 + 1.0 <= v12)
      {
        v13 = objc_msgSend(a1, "format");
        v14 = 4.0;
        switch(v13)
        {
          case 2309:
            v15 = 0;
            v16 = 1;
LABEL_9:
            v17 = 4;
            goto LABEL_10;
          case 2312:
            v15 = 0;
            v16 = 1;
            v14 = 16.0;
            goto LABEL_9;
          case 261:
            v15 = 1;
            v14 = 1.0;
            v16 = 1;
            break;
          case 2056:
            v15 = 0;
            v16 = 0;
            v14 = 8.0;
            v17 = 2;
            goto LABEL_10;
          case 264:
            v16 = 1;
            v15 = 1;
            break;
          default:
            abort();
        }
        v17 = 1;
LABEL_10:
        v18 = floor(a3) * v14
            + floor(a4) * (double)(unint64_t)objc_msgSend(a1, "bytesPerRow")
            + (double)(v17 * (unint64_t)a2);
        v19 = (_BYTE *)(v10 + (unint64_t)v18);
        if (v15)
        {
          LOBYTE(v18) = *v19;
          v20 = (double)*(unint64_t *)&v18;
        }
        else
        {
          if ((v16 & 1) == 0)
          {
            v25 = 0.0;
            src.data = (void *)(v10 + (unint64_t)v18);
            *(int64x2_t *)&src.height = vdupq_n_s64(1uLL);
            src.rowBytes = 2;
            dest.data = &v25;
            *(_OWORD *)&dest.height = *(_OWORD *)&src.height;
            dest.rowBytes = 4;
            vImageConvert_Planar16FtoPlanarF(&src, &dest, 0x10u);
            v21 = 0.0;
            if (v25 != 1.0)
              return v25;
            return v21;
          }
          v20 = (double)(char)*v19;
        }
        return v20 / 255.0;
      }
    }
  }
  return v9;
}

double cikernel::_ciLensModelCalculator(uint64_t a1, uint64_t a2, int8x16_t a3, double a4)
{
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  double v9;
  double v10;
  float64x2_t v11;
  double v12;
  int8x16_t v13;
  int8x16_t v14;
  uint8x8_t v15;
  double v16;
  int8x16_t v17;
  int v18;
  float v19;
  int8x16_t v20;
  float64x2_t v21;
  float v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float v26;
  int v27;
  float32x2_t v28;
  float64x2_t v29;
  float32x2_t v30;
  int v31;
  double v32;
  int v33;
  unint64_t v34;
  int v35;
  unint64_t v36;
  float v37;
  float v38;
  float v39;
  float64x2_t v43;
  _DWORD v44[256];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  bzero(v44, 0x400uLL);
  LODWORD(v6) = *(_DWORD *)(a2 + 28);
  v7.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v8.i32 = *(float *)(a2 + 32) * 0.5;
  *(float *)&v9 = *(float *)v8.i32 + (float)(*(float *)&v6 * 0.5);
  *(float *)&v10 = *(float *)(a2 + 24)
                 + (float)((float)(*(float *)(a2 + 20) * 0.5) + (float)(*(float *)(a2 + 16) * 0.5));
  *(float *)v11.f64 = *(float *)v7.i32 + *(float *)&v9;
  *((float *)&v10 + 1) = *(float *)v7.i32 + *(float *)&v9;
  v21.f64[0] = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v10, v11, v9, v6, v8, v7, v12, v13);
  v18 = 0;
  v19 = floor(*(float *)v21.f64 * 65536.0) * 0.0000152587891;
  v21.f64[0] = ceil(*((float *)v21.f64 + 1) * 65536.0) * 0.0000152587891;
  v20 = a3;
  *(float *)v21.f64 = v21.f64[0];
  v22 = *(float *)v21.f64 - v19;
  v23 = (float32x2_t)vdup_n_s32(0x3C800000u);
  v24 = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL), v23);
  v25 = vmul_f32(v24, (float32x2_t)0x3F0000003F000000);
  v26 = (float)(1.0 / (float)(*(float *)v21.f64 - v19)) * 256.0;
  do
  {
    v27 = 0;
    *(float *)v21.f64 = (float)v18;
    v43 = v21;
    do
    {
      v28.f32[0] = (float)v27;
      v29 = v43;
      v28.i32[1] = LODWORD(v43.f64[0]);
      v30 = vadd_f32(v25, vadd_f32(*(float32x2_t *)v20.i8, vmul_f32(v24, v28)));
      v23.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v30, 1), *(float *)(a1 + 16), v30.f32[0]);
      v20.i32[0] = *(_DWORD *)(a1 + 28);
      v15.i32[0] = *(_DWORD *)(a1 + 36);
      *(float *)v14.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v30, 1), *(float *)v20.i32, v30.f32[0]);
      v30.f32[0] = *(float *)(a1 + 24) + v23.f32[0];
      *(float *)v29.f64 = *(float *)v15.i32 + *(float *)v14.i32;
      v30.f32[1] = *(float *)v15.i32 + *(float *)v14.i32;
      v21.f64[0] = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v30, v29, *(double *)&v23, *(double *)v20.i64, v14, v15, v16, v17);
      v20.i64[0] = a3.i64[0];
      v31 = (int)fminf(v26 * (float)(*(float *)v21.f64 - v19), 255.0);
      if (v31 >= 255)
        v31 = 255;
      ++v44[v31 & ~(v31 >> 31)];
      ++v27;
    }
    while (v27 != 64);
    ++v18;
  }
  while (v18 != 64);
  HIDWORD(v32) = HIDWORD(a4);
  v33 = vcvtmd_s64_f64(*(float *)&a4 * 64.0 * 64.0);
  if (v33 < 1)
  {
    v38 = -1.0;
    v37 = 0.0;
  }
  else
  {
    v34 = 0;
    v35 = 0;
    do
    {
      v36 = v34;
      v35 += v44[v34++];
    }
    while (v36 <= 0xFE && v35 < v33);
    v37 = (float)v35;
    v38 = (float)((int)v34 - 1);
  }
  v39 = (float)(v22 * (float)((float)(fmaxf(v38, 0.0) + fminf(fmaxf((float)v33 / fmaxf(v37, 1.0), 0.0), 1.0)) + 0.5))
      * 0.00390625
      + v19;
  *(float *)&v32 = v39;
  return v32;
}

void CI::f4_sr_f4_sr_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, uint64_t, __n128, __n128);
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __int128 v20;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t, __n128, __n128))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_DWORD *)(v10 + 88);
  v17 = *(_QWORD *)(v10 + 80);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v14);
  *(double *)&v20 = v11(a4 + 80 * v12, a4 + 80 * v15, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

__n64 cikernel::_CILensModelApply(float32x4_t a1, float32x4_t a2)
{
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  __n64 result;

  v2 = fabsf(fminf(vsubq_f32(a1, a2).f32[0], a2.f32[2]));
  v3 = vmuls_lane_f32(v2, a2, 3);
  if (v3 <= 1.0)
    v4 = v3;
  else
    v4 = 1.0;
  if (v3 < 0.0)
    v4 = 0.0;
  v5 = vmuls_lane_f32((float)(v2 * v4) + (float)((float)(1.0 - v4) * 0.0), *(float32x2_t *)a2.f32, 1);
  if (v5 <= 1.0)
    v6 = v5;
  else
    v6 = 1.0;
  if (v5 >= 0.0)
    v7 = v6;
  else
    v7 = 0.0;
  result.n64_f32[0] = sqrtf(v7);
  if (result.n64_f32[0] > 1.0)
    result.n64_f32[0] = 1.0;
  result.n64_u32[1] = 0;
  return result;
}

double cikernel::_lenticularHalo(uint64_t a1, float32x2_t a2, float32x2_t a3, float a4, float a5, float a6, float a7, float32x4_t a8, float32x4_t a9)
{
  float32x2_t v12;
  int32x2_t v13;
  unsigned __int32 v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x2_t v27;
  uint8x8_t v28;
  double v29;
  int8x16_t v30;
  double result;
  float32x4_t v34;
  uint64_t v36;

  v12 = vsub_f32(*(float32x2_t *)CI::getDC((CI *)a1), a2);
  v13 = (int32x2_t)vmul_f32(v12, v12);
  v14 = vadd_f32((float32x2_t)v13, (float32x2_t)vdup_lane_s32(v13, 1)).u32[0];
  *(float *)v13.i32 = sqrtf(vaddv_f32((float32x2_t)v13));
  v15 = vmulq_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(v13, 0), a8), a5);
  v15.i32[3] = 0;
  v16 = vmaxnmq_f32(v15, (float32x4_t)0);
  v16.i32[3] = 0;
  v17 = vminnmq_f32(v16, (float32x4_t)xmmword_192491FD0);
  __asm { FMOV            V3.4S, #1.0 }
  v23 = vsubq_f32(_Q3, v17);
  v17.i32[3] = 0;
  v23.i32[3] = 0;
  v24 = vminnmq_f32(v17, v23);
  v25 = vaddq_f32(v24, v24);
  __asm { FMOV            V4.4S, #3.0 }
  v34 = vmulq_f32(v25, vmulq_f32(v25, vsubq_f32(_Q4, vaddq_f32(v25, v25))));
  *(float32x2_t *)v25.f32 = vrsqrte_f32((float32x2_t)v14);
  *(float32x2_t *)v23.f32 = vmul_f32(*(float32x2_t *)v25.f32, *(float32x2_t *)v25.f32);
  v27 = vrsqrts_f32((float32x2_t)v14, *(float32x2_t *)v23.f32);
  v25.i64[1] = v36;
  *(float32x2_t *)v25.f32 = vadd_f32(a3, vmul_n_f32(vmul_n_f32(v12, vmul_f32(*(float32x2_t *)v25.f32, v27).f32[0]), a4));
  v23.i32[0] = *(_DWORD *)(a1 + 28);
  v12.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v25.f32, 1), *(float *)(a1 + 16), v25.f32[0]);
  _Q4.i32[0] = *(_DWORD *)(a1 + 36);
  v27.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v25.f32, 1), v23.f32[0], v25.f32[0]);
  v25.f32[0] = _Q4.f32[0] + v27.f32[0];
  v12.f32[1] = _Q4.f32[0] + v27.f32[0];
  *(_QWORD *)&result = vmulq_f32(a9, vmulq_n_f32(v34, vmlas_n_f32(a7, a6, COERCE_FLOAT(COERCE_UNSIGNED_INT64(CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v12, (float64x2_t)v25, *(double *)&v27, *(double *)v23.i64, (int8x16_t)_Q4, v28, v29, v30)))))).u64[0];
  return result;
}

void CI::f4_sr_f2_f2_f_f_f_f_f3_clr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, double, double, float, float, float, float, __n128, __n128);
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  const vec2 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  double *v23;
  double *v24;
  __int128 v25;
  uint64_t v26;
  const vec2 *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, double, double, float, float, float, float, __n128, __n128))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  v17 = *(_QWORD *)(v10 + 80);
  v18 = *(const vec2 **)(v10 + 104);
  v19 = *(_QWORD *)(v10 + 128);
  v20 = *(_QWORD *)(v10 + 152);
  v21 = *(_QWORD *)(v10 + 176);
  v22 = *(_QWORD *)(v10 + 200);
  if (*(_BYTE *)(a1 + 64))
  {
    v29 = *(_QWORD *)(v10 + 8);
    v30 = *(_QWORD *)(v10 + 128);
    v26 = *(_QWORD *)(v10 + 200);
    v27 = *(const vec2 **)(v10 + 104);
    v28 = *(_DWORD *)(v10 + 64);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 224)), v18);
    v22 = v26;
    v18 = v27;
    v15 = v28;
    v12 = v29;
    v19 = v30;
  }
  v23 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v23 = (double *)(a2 + (v16 << 6));
  v24 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v24 = (double *)(a2 + (v14 << 6));
  *(double *)&v25 = v11(a4 + 80 * v12, *v24, *v23, *(float *)(a2 + (v17 << 6)), *(float *)(a2 + ((_QWORD)v18 << 6)), *(float *)(a2 + (v19 << 6)), *(float *)(a2 + (v20 << 6)), *(__n128 *)(a2 + (v21 << 6)), *(__n128 *)(a2 + (v22 << 6)));
  *(_OWORD *)(a3 + 16 * a7) = v25;
}

float32x2_t cikernel::_lighttunnel(CI *a1, float32x4_t a2)
{
  float32x2_t v2;
  int32x2_t v3;
  float32x2_t v4;
  float v5;
  __float2 v6;
  float32x2_t v7;
  int32x2_t v8;
  int32x2_t v9;
  float32x2_t v10;
  CI *v11;
  float32x2_t *DC;
  float v13;
  float v15;

  v2 = vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a2.f32);
  v3 = (int32x2_t)vmul_f32(v2, v2);
  v3.i32[0] = vadd_f32((float32x2_t)v3, (float32x2_t)vdup_lane_s32(v3, 1)).u32[0];
  v4 = vrsqrte_f32((float32x2_t)v3.u32[0]);
  v15 = vmuls_lane_f32(vmul_f32(v4, vrsqrts_f32((float32x2_t)v3.u32[0], vmul_f32(v4, v4))).f32[0], a2, 2);
  v5 = logf(v15);
  v6 = __sincosf_stret(vmuls_lane_f32(v5, a2, 3));
  v7.f32[0] = -v6.__sinval;
  v7.i32[1] = LODWORD(v6.__cosval);
  v8 = (int32x2_t)vmul_f32(v2, (float32x2_t)__PAIR64__(LODWORD(v6.__sinval), LODWORD(v6.__cosval)));
  v9 = (int32x2_t)vmul_f32(v2, v7);
  v10 = vadd_f32(*(float32x2_t *)a2.f32, vmul_n_f32(vadd_f32((float32x2_t)vzip1_s32(v8, v9), (float32x2_t)vzip2_s32(v8, v9)), v15));
  DC = (float32x2_t *)CI::getDC(v11);
  v13 = 0.0;
  if (v15 <= 1.0)
    v13 = 1.0;
  return vmla_n_f32(vmul_n_f32(*DC, 1.0 - v13), v10, v13);
}

double cikernel::_localContrast(float32x4_t a1, double a2, double a3)
{
  int32x2_t v3;
  float32x4_t v4;
  float32x4_t v6;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float v17;
  double v18;
  float32x4_t v19;
  float32x4_t v20;
  double result;

  a1.i32[3] = 0;
  v6 = vminnmq_f32(a1, (float32x4_t)0);
  __asm { FMOV            V16.4S, #-1.0 }
  v12 = vaddq_f32(vmaxnmq_f32(a1, (float32x4_t)xmmword_192491FD0), _Q16);
  v13 = vmaxnmq_f32(a1, (float32x4_t)0);
  v13.i32[3] = 0;
  v14 = vminnmq_f32(v13, (float32x4_t)xmmword_192491FD0);
  v15 = vmulq_f32(v14, (float32x4_t)vdupq_n_s32(0x3EAAA64Cu));
  v15.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0]);
  v15.f32[0] = (1.0 - v15.f32[0]) * v15.f32[0];
  v14.i32[3] = 0;
  v16 = vsqrtq_f32(v14);
  v17 = sqrtf(*((float *)&a2 + 1));
  *(float *)v3.i32 = -(float)(v17 * (float)(v15.f32[0] * *(float *)&a3));
  *(double *)_Q16.i64 = (float)(v15.f32[0] * *(float *)&a3);
  *(double *)v4.i64 = *(double *)_Q16.i64 * 0.299;
  v4.f32[0] = *(double *)_Q16.i64 * 0.299;
  v18 = *(double *)_Q16.i64 * 0.587;
  *(float *)&v18 = *(double *)_Q16.i64 * 0.587;
  *(double *)_Q16.i64 = *(double *)_Q16.i64 * 0.114;
  _Q16.f32[0] = *(double *)_Q16.i64;
  *(float *)&a3 = -(float)(v15.f32[0] * *(float *)&a3);
  v19 = vmlaq_f32(vmulq_f32(vmlaq_n_f32(vmulq_n_f32(v16, 1.0 - *(float *)&a3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), v17), (float32x4_t)vdupq_n_s32(0x3E4CCCCCu)), (float32x4_t)vdupq_n_s32(0x3F4CCCCDu), vaddq_f32((float32x4_t)vdupq_lane_s32(v3, 0), vaddq_f32(v16, vaddq_f32(vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q16.f32, 0), v16, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v18, 0), *(float32x2_t *)v16.f32, 1), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v16, v4), 0))))));
  v19.i32[3] = 0;
  v20 = vmaxnmq_f32(v19, (float32x4_t)0);
  *(_QWORD *)&result = vaddq_f32(v12, vaddq_f32(v6, vmulq_f32(v20, v20))).u64[0];
  return result;
}

CIImage *_lightMapImageFromData(NSData *a1, NSNumber *a2, NSNumber *a3)
{
  CIImage *result;
  CIImage *v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  CIImage *v12;
  _QWORD v13[6];
  int v14;
  _QWORD v15[2];
  _QWORD v16[3];

  v16[2] = *MEMORY[0x1E0C80C00];
  result = -[NSData length](a1, "length");
  if (result)
  {
    v7 = result;
    v8 = -[NSNumber intValue](a2, "intValue");
    v9 = -[NSNumber intValue](a3, "intValue");
    if (!v8 || (v10 = v9) == 0)
    {
      v8 = vcvtmd_s64_f64(sqrt((double)(unint64_t)v7 * 0.5));
      v10 = v8;
    }
    if (v7 == (CIImage *)(2 * v8 * v10))
    {
      v15[0] = CFSTR("kCIImageProviderContentDigest");
      v15[1] = CFSTR("kCIImageProviderName");
      v16[0] = a1;
      v16[1] = CFSTR("CILocalLight");
      v11 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v16, v15, 2);
      v12 = [CIImage alloc];
      v13[0] = MEMORY[0x1E0C809B0];
      v13[1] = 3221225472;
      v13[2] = ___ZL22_lightMapImageFromDataP6NSDataP8NSNumberS2__block_invoke;
      v13[3] = &unk_1E2EC4160;
      v14 = v8;
      v13[4] = a1;
      v13[5] = v7;
      return -[CIImage initWithImageProvider:width:height:format:colorSpace:options:](v12, "initWithImageProvider:width:height:format:colorSpace:options:", v13, v8, v10, 262, 0, v11);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CIImage *_scaledLightMapImage(CIImage *a1, CIImage *a2)
{
  CIImage *result;
  double v5;
  CGFloat v6;
  double v7;
  CGFloat v8;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  CIImage *v17;
  _QWORD v18[3];
  _QWORD v19[4];
  CGRect v20;
  CGRect v21;
  CGRect v22;
  CGRect v23;

  result = 0;
  v19[3] = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    -[CIImage extent](a1, "extent");
    v6 = v5;
    v8 = v7;
    v10 = v9;
    v12 = v11;
    -[CIImage extent](a2, "extent");
    v22.origin.x = v13;
    v22.origin.y = v14;
    v22.size.width = v15;
    v22.size.height = v16;
    v20.origin.x = v6;
    v20.origin.y = v8;
    v20.size.width = v10;
    v20.size.height = v12;
    if (CGRectEqualToRect(v20, v22))
    {
      return a1;
    }
    else
    {
      -[CIImage extent](a1, "extent");
      v23.origin.x = 0.0;
      v23.origin.y = 0.0;
      v23.size.width = 1.0;
      v23.size.height = 1.0;
      if (CGRectEqualToRect(v21, v23))
      {
        v17 = -[CIImage imageByClampingToExtent](a1, "imageByClampingToExtent");
        -[CIImage extent](a2, "extent");
        return -[CIImage imageByCroppingToRect:](v17, "imageByCroppingToRect:");
      }
      else
      {
        v18[0] = CFSTR("inputSmallImage");
        v18[1] = CFSTR("inputSpatialSigma");
        v19[0] = a1;
        v19[1] = &unk_1E2F1DA48;
        v18[2] = CFSTR("inputLumaSigma");
        v19[2] = &unk_1E2F1DA58;
        return -[CIImage imageByApplyingFilter:withInputParameters:](a2, "imageByApplyingFilter:withInputParameters:", CFSTR("CIEdgePreserveUpsampleRGFilter"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v19, v18, 3));
      }
    }
  }
  return result;
}

uint64_t `anonymous namespace'::area_light_stats_from_histogram(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  long double v5;
  long double v6;
  double v7;
  double v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  double v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  double v20;
  unint64_t v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  _BYTE v34[2056];
  uint64_t v35;

  v4 = 0;
  v35 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v5 = 0.0;
  v6 = 0.0;
  do
  {
    v7 = fmin((double)v4 / 255.0, 1.0);
    v8 = *(double *)(a1 + 8 * v4);
    v5 = v5 + v8 * log(v7 + 0.00392156863);
    *(long double *)a2 = v5;
    v6 = v6 + v8 * log(1.0 - v7 + 0.00392156863);
    *(long double *)(a2 + 8) = v6;
    ++v4;
  }
  while (v4 != 256);
  *(long double *)a2 = exp(v5);
  *(long double *)(a2 + 8) = exp(v6);
  result = MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14);
  v17 = 0;
  v18 = 1.0e-40;
  do
  {
    v18 = v18 + *(double *)(a1 + v17);
    v17 += 8;
  }
  while (v17 != 2048);
  v19 = 0;
  v20 = 0.0;
  do
  {
    v20 = v20 + *(double *)(a1 + v19);
    *(double *)&v34[v19] = v20 / v18;
    v19 += 8;
  }
  while (v19 != 2048);
  v21 = 0;
  v22 = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  v23 = 0.0;
  v24 = 0.0;
  v25 = 0.0;
  v26 = 0.0;
  v27 = 0.0;
  do
  {
    v28 = *(double *)&v34[8 * v21];
    if (v28 >= 0.001 && v27 == 0.0)
      v27 = (double)v21 / 255.0;
    if (v28 >= 0.02 && v26 == 0.0)
    {
      v26 = (double)v21 / 255.0;
      *(double *)(a2 + 16) = v26;
    }
    if (v28 >= 0.1 && v25 == 0.0)
    {
      v25 = (double)v21 / 255.0;
      *(double *)(a2 + 24) = v25;
    }
    if (v28 >= 0.25 && v24 == 0.0)
    {
      v24 = (double)v21 / 255.0;
      *(double *)(a2 + 32) = v24;
    }
    if (v28 >= 0.5 && v23 == 0.0)
    {
      v23 = (double)v21 / 255.0;
      *(double *)(a2 + 40) = v23;
    }
    if (v28 >= 0.98 && v22 == 0.0)
    {
      v22 = (double)v21 / 255.0;
      *(double *)(a2 + 48) = v22;
    }
    if (v28 >= 1.0 && *(double *)(a2 + 72) == 0.0)
      *(double *)(a2 + 72) = (double)v21 / 255.0;
    ++v21;
  }
  while (v21 != 256);
  *(double *)(a2 + 64) = v27 * ((sqrt(v27) * -0.65 + 1.0) * 0.85);
  v29 = 0.6 - v23 - v24;
  if (v16 >= 0.8 || *(double *)(a2 + 72) >= 1.0)
    v30 = v29 * 0.9;
  else
    v30 = v29 + fmin(0.8 - v16, 0.2);
  v31 = v23 + v24;
  if (v31 > 0.6)
  {
    if (v22 >= 1.0)
      v32 = -0.4;
    else
      v32 = -0.7;
    v30 = v31 + v32;
  }
  v33 = fmax(v30, 0.1);
  if (v26 <= 0.015 || v22 <= 0.95 || v23 <= 0.14)
  {
    if (v26 > 0.055)
      v33 = -v33;
  }
  else
  {
    v33 = -v33;
  }
  *(double *)(a2 + 56) = v33 * 0.68;
  return result;
}

double cikernel::_shadowKernel(float32x4_t a1, float a2, float a3)
{
  double v3;
  float v4;
  double v5;
  float32x4_t v6;
  float64x2_t v7;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float v12;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v21;
  double v22;
  float v23;
  float v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float v29;
  float v30;
  float v31;
  float32x4_t v32;
  double v33;
  double v34;
  double v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  double result;

  v3 = a2 * 3.4 + -1.2;
  *(float *)&v3 = v3;
  v4 = (float)(*(float *)&v3 * a3) + (float)((float)(1.0 - a3) * 0.0);
  v5 = v4;
  if (v4 <= 0.0)
  {
    v7 = vmulq_n_f64(vmulq_n_f64((float64x2_t)xmmword_192496000, v5), v5);
    *(float32x2_t *)&v7.f64[0] = vcvt_f32_f64(v7);
    v6 = (float32x4_t)vzip1q_s32((int32x4_t)v7, (int32x4_t)v7);
  }
  else
  {
    *(float *)&v3 = v4 * 0.0;
    v6 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v3, 0);
  }
  a1.i32[3] = 0;
  v9 = vmaxnmq_f32(a1, (float32x4_t)0);
  v9.i32[3] = 0;
  v10 = vminnmq_f32(v9, (float32x4_t)xmmword_192491FD0);
  v11 = vmulq_f32(v10, (float32x4_t)vdupq_n_s32(0x3EAAAA3Bu));
  v12 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]);
  __asm { FMOV            V18.4S, #-1.0 }
  v18 = vaddq_f32(vmaxnmq_f32(a1, (float32x4_t)xmmword_192491FD0), _Q18);
  v19 = vmulq_f32(v6, vmulq_f32(v10, v10));
  __asm { FMOV            V19.4S, #1.0 }
  v21 = vaddq_f32(vmulq_f32(vsubq_f32(_Q19, v6), v10), v19);
  v22 = v12;
  v23 = 0.1 - v12;
  v24 = v5 * 1.85 * fmaxf(v23, 0.0) + 1.0;
  v25 = vmulq_n_f32(v21, v24);
  v25.i32[3] = 0;
  v26 = vminnmq_f32(a1, (float32x4_t)0);
  v27 = vmaxnmq_f32(v25, (float32x4_t)0);
  v27.i32[3] = 0;
  v28 = vminnmq_f32(v27, (float32x4_t)xmmword_192491FD0);
  v29 = fminf(v4 * v4, 1.0);
  if (v4 >= 0.0)
    v30 = 0.0;
  else
    v30 = v29;
  v31 = (1.0 - v22) * v22;
  v28.i32[3] = 0;
  v32 = vsqrtq_f32(v28);
  v19.f32[0] = (float)(v30 * v31) * -0.4;
  v33 = (float)(v30 * v31);
  *(double *)_Q19.i64 = v33 * 0.299;
  _Q19.f32[0] = v33 * 0.299;
  v34 = v33 * 0.587;
  *(float *)&v34 = v33 * 0.587;
  v35 = v33 * 0.114;
  *(float *)&v35 = v35;
  v36 = vmlaq_f32(vmulq_f32(vmlaq_n_f32(vmulq_n_f32(v32, 1.0 - (float)-(float)(v31 * v30)), (float32x4_t)vdupq_n_s32(0x3ECCCCCDu), -(float)(v31 * v30)), (float32x4_t)vdupq_n_s32(0x3E4CCCCCu)), (float32x4_t)vdupq_n_s32(0x3F4CCCCDu), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 0), vaddq_f32(v32, vaddq_f32(vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v35, 0), v32, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v34, 0), *(float32x2_t *)v32.f32, 1), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v32, _Q19), 0))))));
  v36.i32[3] = 0;
  v37 = vmaxnmq_f32(v36, (float32x4_t)0);
  v38 = vmulq_f32(v37, v37);
  v38.i32[3] = 0;
  v39 = vmaxnmq_f32(v38, (float32x4_t)0);
  v39.i32[3] = 0;
  *(_QWORD *)&result = vaddq_f32(v26, vaddq_f32(v18, vminnmq_f32(v39, (float32x4_t)xmmword_192491FD0))).u64[0];
  return result;
}

double cikernel::_polyKernel(float32x4_t a1, double a2, double a3, double a4, double a5, double a6, double a7, float32x4_t a8)
{
  double v8;
  float32_t v9;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float v14;
  float32x4_t v20;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  double v25;
  float32x4_t v26;
  float v27;
  double v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  double result;

  v8 = *(float *)&a2 * 3.4 + -1.2;
  *(float *)&v8 = v8;
  *(float *)&v8 = (float)(*(float *)&v8 * *(float *)&a3) + (float)((float)(1.0 - *(float *)&a3) * 0.0);
  if (*(float *)&v8 <= 0.0)
  {
    a8.f32[0] = *(float *)&v8 * 1.75;
    v9 = *(float *)&v8 * 1.55;
    a8.i32[1] = a8.i32[0];
    a8.f32[2] = v9;
  }
  else
  {
    *(float *)&v8 = *(float *)&v8 * 1.5;
    a8 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v8, 0);
  }
  a1.i32[3] = 0;
  v11 = vmaxnmq_f32(a1, (float32x4_t)0);
  v11.i32[3] = 0;
  v12 = vminnmq_f32(v11, (float32x4_t)xmmword_192491FD0);
  v13 = vmulq_f32(v12, (float32x4_t)vdupq_n_s32(0x3EAAAA3Bu));
  v14 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0]);
  __asm { FMOV            V18.4S, #-1.0 }
  v20 = vaddq_f32(vmaxnmq_f32(a1, (float32x4_t)xmmword_192491FD0), _Q18);
  __asm { FMOV            V19.4S, #1.0 }
  v22 = vaddq_f32(vmulq_f32(vsubq_f32(_Q19, a8), v12), vmulq_f32(a8, vmulq_f32(v12, v12)));
  v22.i32[3] = 0;
  v23 = vmaxnmq_f32(v22, (float32x4_t)0);
  v23.i32[3] = 0;
  v24 = vminnmq_f32(v23, (float32x4_t)xmmword_192491FD0);
  *(float *)&a3 = fminf(*(float *)&a3, 0.5);
  v25 = v14;
  *(double *)_Q18.i64 = 1.0 - v25;
  *(float *)&v25 = (1.0 - v25) * v25;
  v24.i32[3] = 0;
  v26 = vsqrtq_f32(v24);
  v27 = fmaxf(*((float *)&a2 + 1), 0.5);
  _Q18.f32[0] = -(float)(v27 * (float)(*(float *)&a3 * *(float *)&v25));
  *(double *)v12.i64 = (float)(*(float *)&a3 * *(float *)&v25);
  *(double *)_Q19.i64 = *(double *)v12.i64 * 0.299;
  _Q19.f32[0] = *(double *)v12.i64 * 0.299;
  v28 = *(double *)v12.i64 * 0.587;
  *(float *)&v28 = *(double *)v12.i64 * 0.587;
  *(double *)v12.i64 = *(double *)v12.i64 * 0.114;
  v12.f32[0] = *(double *)v12.i64;
  *(float *)&a3 = -(float)(*(float *)&v25 * *(float *)&a3);
  v29 = vmlaq_f32(vmulq_f32(vmlaq_n_f32(vmulq_n_f32(v26, 1.0 - *(float *)&a3), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), v27), (float32x4_t)vdupq_n_s32(0x3E4CCCCCu)), (float32x4_t)vdupq_n_s32(0x3F4CCCCDu), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q18.f32, 0), vaddq_f32(v26, vaddq_f32(vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 0), v26, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v28, 0), *(float32x2_t *)v26.f32, 1), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v26, _Q19), 0))))));
  v29.i32[3] = 0;
  v30 = vmaxnmq_f32(v29, (float32x4_t)0);
  v31 = vmulq_f32(v30, v30);
  v31.i32[3] = 0;
  v32 = vmaxnmq_f32(v31, (float32x4_t)0);
  v32.i32[3] = 0;
  *(_QWORD *)&result = vaddq_f32(vminnmq_f32(a1, (float32x4_t)0), vaddq_f32(v20, vminnmq_f32(v32, (float32x4_t)xmmword_192491FD0))).u64[0];
  return result;
}

__n128 cikernel::_lumaMap(uint64_t a1, float32x4_t a2, double a3, double a4, double a5, int8x16_t a6, double a7, double a8, int8x16_t a9)
{
  int8x16_t v9;
  float v10;
  float64x2_t v11;
  BOOL v12;
  float v13;
  double v14;
  double v15;
  __n128 result;
  unsigned __int32 v17;

  v17 = a2.u32[3];
  v9 = (int8x16_t)vmulq_f32(a2, (float32x4_t)xmmword_1924921A0);
  v11 = (float64x2_t)vextq_s8(v9, v9, 8uLL);
  v10 = vaddv_f32(vadd_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)&v11.f64[0]));
  LODWORD(v11.f64[0]) = 1.0;
  if (v10 <= 1.0)
    *(float *)v11.f64 = v10;
  v12 = v10 < 0.0;
  v13 = 0.0;
  if (!v12)
    v13 = *(float *)v11.f64;
  HIDWORD(v11.f64[0]) = 1081073664;
  v14 = 0.5;
  *(float *)v11.f64 = v13 * 255.0 + 0.5;
  LODWORD(a5) = 0.5;
  a6.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)&v15 = *(float *)(a1 + 24)
                 + (float)((float)(*(float *)(a1 + 20) * 0.5) + (float)(*(float *)v11.f64 * *(float *)(a1 + 16)));
  LODWORD(a7) = *(_DWORD *)(a1 + 36);
  *(float *)&v14 = *(float *)(a1 + 32) * 0.5;
  *(float *)v11.f64 = *(float *)&a7 + (float)(*(float *)&v14 + (float)(*(float *)v11.f64 * *(float *)a6.i32));
  HIDWORD(v15) = LODWORD(v11.f64[0]);
  result.n128_f64[0] = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v15, v11, v14, a5, a6, *(uint8x8_t *)&a7, a8, a9);
  result.n128_u32[3] = v17;
  return result;
}

void CI::f4_s_sr(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, __n128);
  int v13;
  uint64_t v14;
  uint64_t v15;
  __n128 *v16;
  __int128 v17;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, __n128))(a1 + 24);
  v13 = *(_DWORD *)(v11 + 16);
  v14 = *(_QWORD *)(v11 + 8);
  v15 = *(_QWORD *)(v11 + 32);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 56)), a2);
  v16 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v16 = (__n128 *)((char *)a2 + 64 * v14);
  *(double *)&v17 = v12(a4 + 80 * v15, *v16);
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

CIImage *scaleH(CIImage *a1, double a2)
{
  double v4;
  CIVector *v5;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CIKernel *v10;
  double v11;
  double v12;
  double v13;
  double v14;
  float64x2_t v16;
  float64x2_t v17;
  _QWORD v18[5];
  Rectangle v19;
  float64x2_t v20;
  float64x2_t v21;
  Rectangle v22;
  double v23;
  double v24;
  double v25;
  double v26;
  _QWORD v27[3];
  CGRect v28;
  CGRect v29;

  v27[2] = *MEMORY[0x1E0C80C00];
  if (a2 <= 1.0)
    v4 = 0.0;
  else
    v4 = 1.0;
  v5 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", 1.0 / a2, 1.0, 1.0, 0.0);
  -[CIImage extent](a1, "extent");
  x = v28.origin.x;
  y = v28.origin.y;
  width = v28.size.width;
  height = v28.size.height;
  if (CGRectIsInfinite(v28))
  {
    *(int64x2_t *)&v19.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v19.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v29.origin.x = x;
    v29.origin.y = y;
    v29.size.width = width;
    v29.size.height = height;
    if (CGRectIsNull(v29))
    {
      *(int64x2_t *)&v19.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
      v19.var2 = 0.0;
      v19.var3 = 0.0;
    }
    else
    {
      v19.var0 = x;
      v19.var1 = y;
      v19.var2 = width;
      v19.var3 = height;
    }
  }
  Rectangle::inset(&v19, -v4, -0.0, (uint64_t)&v20);
  if (fabs(v20.f64[0]) == INFINITY || fabs(v20.f64[1]) == INFINITY)
  {
    *(int64x2_t *)&v22.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    v22.var2 = 0.0;
    v22.var3 = 0.0;
  }
  else
  {
    v16 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    v17 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v20, v17), (int32x4_t)vceqq_f64(v21, v16))))) & 1) != 0)
    {
      v22.var0 = v20.f64[0] * a2;
      v22.var1 = v20.f64[1];
      v22.var2 = a2 * v21.f64[0];
      v22.var3 = v21.f64[1];
    }
    else
    {
      *(float64x2_t *)&v22.var0 = v17;
      *(float64x2_t *)&v22.var2 = v16;
    }
  }
  v10 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_maxScale, Rectangle::integralize(&v22, 0.0001, (uint64_t)&v23).f64[0]);
  v11 = v23;
  v12 = v24;
  v14 = v25;
  v13 = v26;
  if (v23 == -8.98846567e307 && v24 == -8.98846567e307 && v25 == 1.79769313e308 && v26 == 1.79769313e308)
  {
    v11 = *MEMORY[0x1E0C9D5E0];
    v12 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
    v14 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
    v13 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
  }
  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 3221225472;
  v18[2] = ___ZL6scaleHP7CIImaged_block_invoke;
  v18[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
  *(double *)&v18[4] = a2;
  v27[0] = a1;
  v27[1] = v5;
  return -[CIKernel applyWithExtent:roiCallback:arguments:](v10, "applyWithExtent:roiCallback:arguments:", v18, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v27, 2), v11, v12, v14, v13);
}

CIImage *scaleV(CIImage *a1, double a2)
{
  double v4;
  CIVector *v5;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CIKernel *v10;
  double v11;
  double v12;
  double v13;
  double v14;
  float64x2_t v16;
  float64x2_t v17;
  _QWORD v18[5];
  Rectangle v19;
  float64x2_t v20;
  float64x2_t v21;
  Rectangle v22;
  double v23;
  double v24;
  double v25;
  double v26;
  _QWORD v27[3];
  CGRect v28;
  CGRect v29;

  v27[2] = *MEMORY[0x1E0C80C00];
  if (a2 <= 1.0)
    v4 = 0.0;
  else
    v4 = 1.0;
  v5 = +[CIVector vectorWithX:Y:Z:W:](CIVector, "vectorWithX:Y:Z:W:", 1.0, 1.0 / a2, 0.0, 1.0);
  -[CIImage extent](a1, "extent");
  x = v28.origin.x;
  y = v28.origin.y;
  width = v28.size.width;
  height = v28.size.height;
  if (CGRectIsInfinite(v28))
  {
    *(int64x2_t *)&v19.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v19.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v29.origin.x = x;
    v29.origin.y = y;
    v29.size.width = width;
    v29.size.height = height;
    if (CGRectIsNull(v29))
    {
      *(int64x2_t *)&v19.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
      v19.var2 = 0.0;
      v19.var3 = 0.0;
    }
    else
    {
      v19.var0 = x;
      v19.var1 = y;
      v19.var2 = width;
      v19.var3 = height;
    }
  }
  Rectangle::inset(&v19, -0.0, -v4, (uint64_t)&v20);
  if (fabs(v20.f64[0]) == INFINITY || fabs(v20.f64[1]) == INFINITY)
  {
    *(int64x2_t *)&v22.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    v22.var2 = 0.0;
    v22.var3 = 0.0;
  }
  else
  {
    v16 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    v17 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v20, v17), (int32x4_t)vceqq_f64(v21, v16))))) & 1) != 0)
    {
      v22.var0 = v20.f64[0];
      v22.var1 = v20.f64[1] * a2;
      v22.var2 = v21.f64[0];
      v22.var3 = vmuld_lane_f64(a2, v21, 1);
    }
    else
    {
      *(float64x2_t *)&v22.var0 = v17;
      *(float64x2_t *)&v22.var2 = v16;
    }
  }
  v10 = +[CIKernel kernelWithInternalRepresentation:](CIKernel, "kernelWithInternalRepresentation:", &CI::_maxScale, Rectangle::integralize(&v22, 0.0001, (uint64_t)&v23).f64[0]);
  v11 = v23;
  v12 = v24;
  v14 = v25;
  v13 = v26;
  if (v23 == -8.98846567e307 && v24 == -8.98846567e307 && v25 == 1.79769313e308 && v26 == 1.79769313e308)
  {
    v11 = *MEMORY[0x1E0C9D5E0];
    v12 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
    v14 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
    v13 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
  }
  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 3221225472;
  v18[2] = ___ZL6scaleVP7CIImaged_block_invoke;
  v18[3] = &__block_descriptor_40_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
  *(double *)&v18[4] = a2;
  v27[0] = a1;
  v27[1] = v5;
  return -[CIKernel applyWithExtent:roiCallback:arguments:](v10, "applyWithExtent:roiCallback:arguments:", v18, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v27, 2), v11, v12, v14, v13);
}

void ___ZL9downBy2x2P7CIImage_block_invoke(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  double v8;
  double v9;
  double v10;
  double v11;
  BOOL IsNull;
  double v13;
  Rectangle v18;
  uint64_t v19;
  CGRect v20;

  if (CGRectIsInfinite(*(CGRect *)&a1))
  {
    v8 = -8.98846567e307;
    v9 = 1.79769313e308;
    v10 = 1.79769313e308;
    v11 = -8.98846567e307;
  }
  else
  {
    v20.origin.x = a1;
    v20.origin.y = a2;
    v20.size.width = a3;
    v20.size.height = a4;
    IsNull = CGRectIsNull(v20);
    v11 = INFINITY;
    if (IsNull)
      v9 = 0.0;
    else
      v9 = a3;
    if (IsNull)
      v10 = 0.0;
    else
      v10 = a4;
    if (IsNull)
      v8 = INFINITY;
    else
      v8 = a2;
    if (!IsNull)
      v11 = a1;
  }
  v13 = fabs(v8);
  if (fabs(v11) == INFINITY || v13 == INFINITY)
  {
    *(int64x2_t *)&v18.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    *(_OWORD *)&v18.var2 = 0uLL;
  }
  else if (v11 == -8.98846567e307 && v8 == -8.98846567e307 && v9 == 1.79769313e308 && v10 == 1.79769313e308)
  {
    *(int64x2_t *)&v18.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v18.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v18.var0 = v11 + v11;
    v18.var1 = v8 + v8;
    v18.var2 = v9 + v9;
    v18.var3 = v10 + v10;
  }
  Rectangle::integralize(&v18, 0.0001, (uint64_t)&v19);
}

double cikernel::_maxScaleDown2x2(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float32x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  float64x2_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  double v22;
  double v23;
  uint8x8_t v24;
  int8x16_t v25;
  float64x2_t v26;
  double v27;
  int8x16_t v28;
  float32x4_t v29;
  double v30;
  double v31;
  uint8x8_t v32;
  int8x16_t v33;
  float64x2_t v34;
  double v35;
  int8x16_t v36;
  float32x4_t v37;
  double result;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;

  DC = (float32x2_t *)CI::getDC(this);
  v4 = vadd_f32(*DC, *DC);
  v5 = vadd_f32(v4, (float32x2_t)0x3F0000003F000000);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v10, v6, v7, v9, v8, v11, v12);
  v41 = v13;
  *(float32x2_t *)v13.f32 = vadd_f32(v4, (float32x2_t)0xBF0000003F000000);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v15) = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  v40 = v21;
  *(float32x2_t *)v21.f32 = vadd_f32(v4, (float32x2_t)0x3F000000BF000000);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v21.f32, 1), *((float *)this + 4), v21.f32[0]);
  LODWORD(v23) = *((_DWORD *)this + 7);
  v24.i32[0] = *((_DWORD *)this + 9);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v21.f32, 1), *(float *)&v23, v21.f32[0]);
  v21.f32[0] = *((float *)this + 6) + *(float *)&v22;
  *(float *)v26.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v21.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v21.i64, v26, v22, v23, v25, v24, v27, v28);
  v39 = v29;
  *(float32x2_t *)v29.f32 = vadd_f32(v4, (float32x2_t)0xBF000000BF000000);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v29.f32, 1), *((float *)this + 4), v29.f32[0]);
  LODWORD(v31) = *((_DWORD *)this + 7);
  v32.i32[0] = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v29.f32, 1), *(float *)&v31, v29.f32[0]);
  v29.f32[0] = *((float *)this + 6) + *(float *)&v30;
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v29.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v29.i64, v34, v30, v31, v33, v32, v35, v36);
  *(_QWORD *)&result = vmaxnmq_f32(vmaxnmq_f32(v41, v40), vmaxnmq_f32(v39, v37)).u64[0];
  return result;
}

void ___ZL8downBy2HP7CIImage_block_invoke_0(double a1, double a2, double a3, double a4)
{
  roiDown2(*(CGRect *)&a1, 1);
}

void roiDown2(CGRect a1, int a2)
{
  double height;
  double width;
  double y;
  double x;
  double v7;
  double v8;
  double v9;
  double v10;
  BOOL IsNull;
  double v12;
  double v13;
  double v14;
  Rectangle v19;
  uint64_t v20;
  CGRect v21;

  height = a1.size.height;
  width = a1.size.width;
  y = a1.origin.y;
  x = a1.origin.x;
  if (CGRectIsInfinite(a1))
  {
    v7 = -8.98846567e307;
    v8 = 1.79769313e308;
    v9 = 1.79769313e308;
    v10 = -8.98846567e307;
  }
  else
  {
    v21.origin.x = x;
    v21.origin.y = y;
    v21.size.width = width;
    v21.size.height = height;
    IsNull = CGRectIsNull(v21);
    v10 = INFINITY;
    if (IsNull)
      v8 = 0.0;
    else
      v8 = width;
    if (IsNull)
      v9 = 0.0;
    else
      v9 = height;
    if (IsNull)
      v7 = INFINITY;
    else
      v7 = y;
    if (!IsNull)
      v10 = x;
  }
  v12 = 1.0;
  if (a2)
    v13 = 2.0;
  else
    v13 = 1.0;
  if (!a2)
    v12 = 2.0;
  v14 = fabs(v7);
  if (fabs(v10) == INFINITY || v14 == INFINITY)
  {
    *(int64x2_t *)&v19.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    *(_OWORD *)&v19.var2 = 0uLL;
  }
  else if (v10 == -8.98846567e307 && v7 == -8.98846567e307 && v8 == 1.79769313e308 && v9 == 1.79769313e308)
  {
    *(int64x2_t *)&v19.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v19.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v19.var0 = v13 * v10;
    v19.var1 = v12 * v7;
    v19.var2 = v13 * v8;
    v19.var3 = v12 * v9;
  }
  Rectangle::integralize(&v19, 0.0001, (uint64_t)&v20);
}

double cikernel::_maxScaleDown2(uint64_t a1, float32x2_t a2)
{
  float32x2_t *DC;
  float64x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  double v21;
  double v22;
  uint8x8_t v23;
  int8x16_t v24;
  float64x2_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  double result;
  float32x4_t v30;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  __asm { FMOV            V1.2S, #1.0 }
  *(float32x2_t *)&v10.f64[0] = vadd_f32(a2, _D1);
  v11 = vmul_f32(*(float32x2_t *)&v10.f64[0], *DC);
  v12 = vmul_f32(a2, (float32x2_t)0x3F0000003F000000);
  v13 = vsub_f32(v11, v12);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v13, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v13, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v10.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v13, v10, v14, v15, v17, v16, v18, v19);
  v30 = v20;
  *(float32x2_t *)v20.f32 = vadd_f32(v12, v11);
  *(float *)&v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v20.f32, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v20.f32, 1), *(float *)&v22, v20.f32[0]);
  v20.f32[0] = *(float *)(a1 + 24) + *(float *)&v21;
  *(float *)v25.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v20.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v25, v21, v22, v24, v23, v26, v27);
  *(_QWORD *)&result = vmaxnmq_f32(v30, v28).u64[0];
  return result;
}

void ___ZL8downBy2VP7CIImage_block_invoke_0(double a1, double a2, double a3, double a4)
{
  roiDown2(*(CGRect *)&a1, 0);
}

void ___ZL6scaleHP7CIImaged_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5;

  v5 = *(double *)(a1 + 32);
  roiDownK(*(CGRect *)&a2, v5, 1);
}

void roiDownK(CGRect a1, float a2, int a3)
{
  double height;
  double width;
  double y;
  double x;
  double v9;
  double v10;
  double v11;
  double v12;
  BOOL IsNull;
  double v14;
  double v15;
  Rectangle v16;
  uint64_t v17;
  CGRect v18;

  height = a1.size.height;
  width = a1.size.width;
  y = a1.origin.y;
  x = a1.origin.x;
  if (CGRectIsInfinite(a1))
  {
    v9 = -8.98846567e307;
    v10 = 1.79769313e308;
    v11 = 1.79769313e308;
    v12 = -8.98846567e307;
  }
  else
  {
    v18.origin.x = x;
    v18.origin.y = y;
    v18.size.width = width;
    v18.size.height = height;
    IsNull = CGRectIsNull(v18);
    v12 = INFINITY;
    if (IsNull)
      v10 = 0.0;
    else
      v10 = width;
    if (IsNull)
      v11 = 0.0;
    else
      v11 = height;
    if (IsNull)
      v9 = INFINITY;
    else
      v9 = y;
    if (!IsNull)
      v12 = x;
  }
  v14 = 1.0 / a2;
  if (a3)
    v15 = 1.0 / a2;
  else
    v15 = 1.0;
  if (a3)
    v14 = 1.0;
  if (fabs(v12) == INFINITY || fabs(v9) == INFINITY)
  {
    *(int64x2_t *)&v16.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    *(_OWORD *)&v16.var2 = 0uLL;
  }
  else if (v12 == -8.98846567e307 && v9 == -8.98846567e307 && v10 == 1.79769313e308 && v11 == 1.79769313e308)
  {
    *(int64x2_t *)&v16.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v16.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v16.var0 = v12 * v15;
    v16.var1 = v9 * v14;
    v16.var2 = v10 * v15;
    v16.var3 = v11 * v14;
  }
  Rectangle::integralize(&v16, 0.0001, (uint64_t)&v17);
}

double cikernel::_maxScale(uint64_t a1, int8x16_t a2)
{
  float32x2_t v3;
  float64x2_t v4;
  float32x2_t v5;
  float32x2_t v11;
  float32x2_t v12;
  int8x16_t v13;
  double v14;
  uint8x8_t v15;
  int8x16_t v16;
  float32x4_t v17;
  double v18;
  int8x16_t v19;
  double v20;
  float64x2_t v21;
  double v22;
  int8x16_t v23;
  float32x4_t v24;
  double result;
  float32x2_t v26;
  float32x4_t v28;

  v3 = vmul_f32(*(float32x2_t *)a2.i8, *(float32x2_t *)CI::getDC((CI *)a1));
  *(float32x2_t *)&v4.f64[0] = vadd_f32(vrndm_f32(vadd_f32(v3, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000);
  v5 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  __asm { FMOV            V3.2S, #1.0 }
  v11 = vsub_f32(_D3, v5);
  v12 = vmla_f32(vmul_f32(v11, v3), v5, *(float32x2_t *)&v4.f64[0]);
  v11.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v12, 1), *(float *)(a1 + 16), v12.f32[0]);
  v13.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v14) = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v12, 1), *(float *)v13.i32, v12.f32[0]);
  v26 = vadd_f32(v5, v12);
  v12.f32[0] = *(float *)(a1 + 24) + v11.f32[0];
  *(float *)v4.f64 = *(float *)&v14 + *(float *)v15.i32;
  v12.f32[1] = *(float *)&v14 + *(float *)v15.i32;
  *(double *)v17.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v12, v4, *(double *)&v5, *(double *)&v11, v13, v15, v14, v16);
  v28 = v17;
  HIDWORD(v18) = v26.i32[1];
  LODWORD(v18) = *(_DWORD *)(a1 + 28);
  v19.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v26, 1), *(float *)&v18, v26.f32[0]);
  v17.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v26, 1), *(float *)(a1 + 16), v26.f32[0]);
  *(float *)v21.f64 = *(float *)v19.i32 + *(float *)&v20;
  v17.f32[1] = *(float *)v19.i32 + *(float *)&v20;
  *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v17.i64, v21, v18, v20, v19, (uint8x8_t)v26, v22, v23);
  *(_QWORD *)&result = vmaxnmq_f32(v28, v24).u64[0];
  return result;
}

float ___ZL6scaleVP7CIImaged_block_invoke(uint64_t a1, double a2, double a3, double a4, double a5)
{
  float v5;
  float result;

  v5 = *(double *)(a1 + 32);
  roiDownK(*(CGRect *)&a2, v5, 0);
  return result;
}

double cikernel::_maskToAlpha(int32x2_t a1)
{
  double result;

  *(_QWORD *)&result = vdupq_lane_s32(a1, 1).u64[0];
  return result;
}

double cikernel::_betterDown2(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  CI *v13;
  float32x2_t *v14;
  float64x2_t v15;
  float32x2_t v16;
  double v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  double v21;
  int8x16_t v22;
  float32x4_t v23;
  CI *v24;
  float32x2_t *v25;
  float64x2_t v26;
  float32x2_t v27;
  double v28;
  double v29;
  uint8x8_t v30;
  int8x16_t v31;
  double v32;
  int8x16_t v33;
  float32x4_t v34;
  CI *v35;
  float32x2_t *v36;
  float64x2_t v37;
  float32x2_t v38;
  double v39;
  double v40;
  uint8x8_t v41;
  int8x16_t v42;
  double v43;
  int8x16_t v44;
  float32x4_t v45;
  double result;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;

  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1065353216;
  v5 = vadd_f32(vadd_f32(*DC, *DC), (float32x2_t)0x3F80000000000000);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v4, v6, v7, v9, v8, v10, v11);
  v54 = v12;
  v14 = (float32x2_t *)CI::getDC(v13);
  HIDWORD(v15.f64[0]) = -1082130432;
  v16 = vadd_f32(vadd_f32(*v14, *v14), (float32x2_t)0xBF80000000000000);
  *(float *)&v17 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v16, 1), *((float *)this + 4), v16.f32[0]);
  LODWORD(v18) = *((_DWORD *)this + 7);
  v19.i32[0] = *((_DWORD *)this + 9);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v16, 1), *(float *)&v18, v16.f32[0]);
  v16.f32[0] = *((float *)this + 6) + *(float *)&v17;
  *(float *)v15.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v16.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v16, v15, v17, v18, v20, v19, v21, v22);
  v53 = v23;
  v25 = (float32x2_t *)CI::getDC(v24);
  HIDWORD(v26.f64[0]) = 0;
  v27 = vadd_f32(vadd_f32(*v25, *v25), (float32x2_t)1065353216);
  *(float *)&v28 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v27, 1), *((float *)this + 4), v27.f32[0]);
  LODWORD(v29) = *((_DWORD *)this + 7);
  v30.i32[0] = *((_DWORD *)this + 9);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v27, 1), *(float *)&v29, v27.f32[0]);
  v27.f32[0] = *((float *)this + 6) + *(float *)&v28;
  *(float *)v26.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v27.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v27, v26, v28, v29, v31, v30, v32, v33);
  v52 = v34;
  v36 = (float32x2_t *)CI::getDC(v35);
  HIDWORD(v37.f64[0]) = 0;
  v38 = vadd_f32(vadd_f32(*v36, *v36), (float32x2_t)3212836864);
  *(float *)&v39 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v38, 1), *((float *)this + 4), v38.f32[0]);
  LODWORD(v40) = *((_DWORD *)this + 7);
  v41.i32[0] = *((_DWORD *)this + 9);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v38, 1), *(float *)&v40, v38.f32[0]);
  v38.f32[0] = *((float *)this + 6) + *(float *)&v39;
  *(float *)v37.f64 = *(float *)v41.i32 + *(float *)v42.i32;
  v38.f32[1] = *(float *)v41.i32 + *(float *)v42.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v38, v37, v39, v40, v42, v41, v43, v44);
  __asm { FMOV            V1.4S, #0.25 }
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v52, vaddq_f32(vaddq_f32(v54, v53), v45)), _Q1).u64[0];
  return result;
}

double cikernel::_maskedVariableBlur(cikernel *this, SamplerObj *a2, SamplerObj *a3, SamplerObj *a4, SamplerObj *a5, SamplerObj *a6, SamplerObj *a7, SamplerObj *a8, float a9, SamplerObj *a10)
{
  float32x2_t *DC;
  int8x16_t v20;
  double v21;
  double v22;
  double v23;
  float64x2_t v24;
  uint8x8_t v25;
  double v26;
  int8x16_t v27;
  double v28;
  float v29;
  float v30;
  float v31;
  int8x16_t v32;
  double v33;
  double v34;
  double v35;
  float v36;
  float64x2_t v37;
  double v38;
  int8x16_t v39;
  float32x4_t v40;
  float64x2_t v41;
  float32x2_t v47;
  float32x2_t v48;
  float32x2_t v49;
  float32x2_t v50;
  float32x2_t v51;
  int8x16_t v52;
  float32x2_t v53;
  int8x16_t v54;
  float64x2_t v55;
  int8x16_t v58;
  float32x4_t v59;
  float64x2_t v60;
  int8x16_t v61;
  double v62;
  double v63;
  double v64;
  float32x4_t v65;
  int8x16_t v66;
  double v67;
  uint8x8_t v68;
  int8x16_t v69;
  float64x2_t v70;
  float32x4_t v71;
  double v72;
  uint8x8_t v73;
  int8x16_t v74;
  float64x2_t v75;
  int8x16_t v76;
  float64x2_t v78;
  float32x2_t v79;
  float32x2_t v80;
  float32x2_t v81;
  int8x16_t v82;
  float32x2_t v83;
  int8x16_t v84;
  float64x2_t v85;
  int8x16_t v86;
  float32x4_t v87;
  float64x2_t v88;
  int8x16_t v89;
  double v90;
  double v91;
  double v92;
  float32x4_t v93;
  int8x16_t v94;
  double v95;
  uint8x8_t v96;
  int8x16_t v97;
  float64x2_t v98;
  float32x4_t v99;
  double v100;
  uint8x8_t v101;
  int8x16_t v102;
  float64x2_t v103;
  int8x16_t v104;
  float32x4_t v105;
  float64x2_t v106;
  float32x2_t v107;
  float32x2_t v108;
  float32x2_t v109;
  int8x16_t v110;
  float32x2_t v111;
  int8x16_t v112;
  float64x2_t v113;
  int8x16_t v114;
  float32x4_t v115;
  float64x2_t v116;
  int8x16_t v117;
  double v118;
  double v119;
  double v120;
  float32x4_t v121;
  int8x16_t v122;
  double v123;
  uint8x8_t v124;
  int8x16_t v125;
  float64x2_t v126;
  float32x4_t v127;
  double v128;
  uint8x8_t v129;
  int8x16_t v130;
  float64x2_t v131;
  int8x16_t v132;
  float32x4_t v133;
  float64x2_t v134;
  float32x2_t v135;
  float32x2_t v136;
  float32x2_t v137;
  int8x16_t v138;
  float32x2_t v139;
  int8x16_t v140;
  float64x2_t v141;
  int8x16_t v142;
  float32x4_t v143;
  float64x2_t v144;
  int8x16_t v145;
  double v146;
  double v147;
  double v148;
  float32x4_t v149;
  int8x16_t v150;
  double v151;
  uint8x8_t v152;
  int8x16_t v153;
  float64x2_t v154;
  float32x4_t v155;
  double v156;
  uint8x8_t v157;
  int8x16_t v158;
  float64x2_t v159;
  int8x16_t v160;
  float32x4_t v161;
  float64x2_t v162;
  float32x2_t v163;
  float32x2_t v164;
  float32x2_t v165;
  int8x16_t v166;
  float32x2_t v167;
  int8x16_t v168;
  float64x2_t v169;
  int8x16_t v170;
  float32x4_t v171;
  float64x2_t v172;
  int8x16_t v173;
  double v174;
  double v175;
  double v176;
  float32x4_t v177;
  int8x16_t v178;
  double v179;
  uint8x8_t v180;
  int8x16_t v181;
  float64x2_t v182;
  float32x4_t v183;
  double v184;
  uint8x8_t v185;
  int8x16_t v186;
  float64x2_t v187;
  int8x16_t v188;
  float32x4_t v189;
  float32x4_t v190;
  float64x2_t v191;
  float32x2_t v192;
  float32x2_t v193;
  float32x2_t v194;
  int8x16_t v195;
  float32x2_t v196;
  int8x16_t v197;
  float32x2_t v198;
  int8x16_t v199;
  float32x4_t v200;
  float64x2_t v201;
  double v202;
  double v203;
  double v204;
  int8x16_t v205;
  float32x4_t v206;
  int8x16_t v207;
  double v208;
  uint8x8_t v209;
  int8x16_t v210;
  float64x2_t v211;
  float32x4_t v212;
  double v213;
  uint8x8_t v214;
  int8x16_t v215;
  float64x2_t v216;
  int8x16_t v217;
  float32x4_t v218;
  float32x4_t *v219;
  float32x4_t *v220;
  float32x4_t v221;
  float32x4_t *v222;
  float32x4_t *v223;
  float32x4_t *v224;
  float32x4_t v225;
  float32x4_t *v226;
  float32x4_t *v227;
  float32x4_t v228;
  float32x4_t *v229;
  float32x4_t *v230;
  float32x4_t v231;
  float32x4_t *v232;
  float32x4_t *v233;
  float32x4_t v234;
  double result;
  float v236;
  float v237;
  float v238;
  float v239;
  float v240;
  float64x2_t v241;
  float32x4_t v242;
  float64x2_t v243;
  float32x4_t v244;
  float64x2_t v245;
  float32x4_t v246;
  float64x2_t v247;
  float32x4_t v248;
  float64x2_t v249;
  float32x4_t v250;
  float32x4_t v251;
  float v252;
  int8x16_t v253;
  float32x4_t v254;
  int8x16_t v255;
  float32x4_t v256;
  int8x16_t v257;
  float32x4_t v258;
  int8x16_t v259;
  float32x4_t v260;
  int8x16_t v261;
  float32x4_t v262;
  float32x4_t v263;
  float32x4_t v264;
  int8x16_t v265;
  int8x16_t v266;
  int8x16_t v267;
  int8x16_t v268;
  int8x16_t v269;
  int8x16_t v270;
  float32x4_t v271;
  float32x2_t v272;
  float32x4_t v273;
  float32x4_t v274;
  float32x4_t v275;
  float32x4_t v276;
  float32x4_t v277;
  int8x16_t v278;
  float32x2_t v279;
  float32x2_t v280;
  float32x2_t v281;
  float32x2_t v282;
  float32x2_t v283;
  float32x2_t v284;
  float32x4_t v285;
  int8x16_t v286;
  float32x2_t v287;
  float32x4_t v288;
  float32x4_t v289;
  float32x4_t v290;
  float32x4_t v291;
  float32x4_t v292;
  float32x4_t v293;
  float32x4_t v294;
  float32x4_t v295;

  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v20.i8 = *DC;
  v286 = v20;
  LODWORD(v21) = *((_DWORD *)this + 7);
  *(float *)&v22 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v23) = *((_DWORD *)this + 9);
  *(float *)v24.f64 = *(float *)&v23
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v21, COERCE_FLOAT(*DC));
  HIDWORD(v22) = LODWORD(v24.f64[0]);
  v28 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v22, v24, v21, v23, v20, v25, v26, v27);
  v29 = 1.0;
  if (*((float *)&v28 + 1) <= 1.0)
    v29 = *((float *)&v28 + 1);
  if (*((float *)&v28 + 1) >= 0.0)
    v30 = v29;
  else
    v30 = 0.0;
  v31 = log2((float)(v30 * a9) * 4.0 / 3.0);
  *(float *)v32.i32 = fmaxf(v31, 0.0);
  v252 = *(float *)v32.i32;
  LODWORD(v33) = *((_DWORD *)a2 + 7);
  *(float *)&v34 = *((float *)a2 + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), *(float32x2_t *)v286.i8, 1), *((float *)a2 + 4), *(float *)v286.i32);
  LODWORD(v35) = *((_DWORD *)a2 + 9);
  v36 = floorf(*(float *)v32.i32);
  *(float *)v37.f64 = *(float *)&v35
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), *(float32x2_t *)v286.i8, 1), *(float *)&v33, *(float *)v286.i32);
  HIDWORD(v34) = LODWORD(v37.f64[0]);
  *(double *)v40.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), v34, v37, v33, v35, v32, *(uint8x8_t *)v286.i8, v38, v39);
  v251 = v40;
  *(float32x2_t *)v40.f32 = vadd_f32(vmul_f32(*(float32x2_t *)v286.i8, (float32x2_t)0x3F0000003F000000), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v41.f64[0] = vrndm_f32(*(float32x2_t *)v40.f32);
  __asm { FMOV            V13.2S, #1.0 }
  v47 = vadd_f32(vsub_f32(*(float32x2_t *)&v41.f64[0], *(float32x2_t *)v40.f32), _D13);
  *(float32x2_t *)v40.f32 = vsub_f32(*(float32x2_t *)v40.f32, *(float32x2_t *)&v41.f64[0]);
  v48 = (float32x2_t)vdup_n_s32(0x3EAAAAABu);
  v49 = vmul_f32(v47, (float32x2_t)0x3F0000003F000000);
  v50 = vmul_f32(v47, v49);
  v51 = (float32x2_t)vdup_n_s32(0x3E2AAAABu);
  *(float32x2_t *)v52.i8 = vadd_f32(vadd_f32(v49, vsub_f32(v50, vmul_f32(v47, vmul_f32(v47, vmul_f32(v47, v48))))), v51);
  v53 = vsub_f32(_D13, *(float32x2_t *)v52.i8);
  *(float32x2_t *)v54.i8 = vadd_f32(vadd_f32(*(float32x2_t *)&v41.f64[0], vdiv_f32(vadd_f32(vadd_f32(v49, vsub_f32(v50, vmul_f32(v47, v50))), v51), *(float32x2_t *)v52.i8)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v55.f64[0] = vmul_f32(*(float32x2_t *)v40.f32, *(float32x2_t *)v40.f32);
  __asm
  {
    FMOV            V9.2S, #6.0
    FMOV            V8.2S, #1.5
  }
  v272 = vadd_f32(vadd_f32(*(float32x2_t *)&v41.f64[0], vdiv_f32(vdiv_f32(vmul_f32(*(float32x2_t *)v40.f32, *(float32x2_t *)&v55.f64[0]), _D9), v53)), _D8);
  v279 = v53;
  v253 = v54;
  v265 = v52;
  v40.f32[0] = *((float *)a3 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 5), *(float32x2_t *)v54.i8, 1), *((float *)a3 + 4), *(float *)v54.i32);
  v53.i32[0] = *((_DWORD *)a3 + 9);
  *(float *)v55.f64 = vmuls_lane_f32(*(float *)v52.i32, *(float32x2_t *)v52.i8, 1);
  v241 = v55;
  *(float *)v41.f64 = v53.f32[0]
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 8), *(float32x2_t *)v54.i8, 1), *((float *)a3 + 7), *(float *)v54.i32);
  v40.i32[1] = LODWORD(v41.f64[0]);
  *(double *)v59.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a3 + 1), *(double *)v40.i64, v41, v55.f64[0], *(double *)&v53, v54, (uint8x8_t)v50, *(double *)v52.i64, v58);
  v60 = v241;
  v61 = (int8x16_t)vmulq_n_f32(v59, *(float *)v241.f64);
  v59.f32[0] = *((float *)a3 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 5), *(float32x2_t *)v253.i8, 1), *((float *)a3 + 4), v272.f32[0]);
  LODWORD(v62) = *((_DWORD *)a3 + 9);
  HIDWORD(v63) = v279.i32[1];
  *(float *)&v63 = vmuls_lane_f32(v279.f32[0], *(float32x2_t *)v265.i8, 1);
  v236 = *(float *)&v63;
  v242 = (float32x4_t)v61;
  *(float *)v60.f64 = *(float *)&v62
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 8), *(float32x2_t *)v253.i8, 1), *((float *)a3 + 7), v272.f32[0]);
  v59.i32[1] = LODWORD(v60.f64[0]);
  *(double *)v65.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a3 + 1), *(double *)v59.i64, v60, v63, v62, v265, *(uint8x8_t *)v253.i8, v64, v61);
  v66 = v253;
  *(float *)&v67 = vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 5), v272, 1), *((float *)a3 + 4), *(float *)v253.i32);
  v68.i32[0] = *((_DWORD *)a3 + 9);
  *(float *)v69.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 8), v272, 1), *((float *)a3 + 7), *(float *)v253.i32);
  v254 = vaddq_f32(v242, vmulq_n_f32(v65, v236));
  v65.f32[0] = *((float *)a3 + 6) + *(float *)&v67;
  *(float *)v70.f64 = *(float *)v68.i32 + *(float *)v69.i32;
  v65.f32[1] = *(float *)v68.i32 + *(float *)v69.i32;
  *(double *)v71.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a3 + 1), *(double *)v65.i64, v70, v67, *(double *)v265.i64, v69, v68, *(double *)v254.i64, v66);
  *(float *)&v72 = vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 5), v272, 1), *((float *)a3 + 4), v272.f32[0]);
  v73.i32[0] = *((_DWORD *)a3 + 9);
  *(float *)v74.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a3 + 8), v272, 1), *((float *)a3 + 7), v272.f32[0]);
  v273 = vaddq_f32(v254, vmulq_n_f32(v71, vmuls_lane_f32(*(float *)v265.i32, v279, 1)));
  v71.f32[0] = *((float *)a3 + 6) + *(float *)&v72;
  *(float *)v75.f64 = *(float *)v73.i32 + *(float *)v74.i32;
  v71.f32[1] = *(float *)v73.i32 + *(float *)v74.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a3 + 1), *(double *)v71.i64, v75, v72, *(double *)v254.i64, v74, v73, *(double *)v273.i64, v76);
  v295 = vaddq_f32(v273, vmulq_n_f32(_Q0, vmuls_lane_f32(v279.f32[0], v279, 1)));
  __asm { FMOV            V0.2S, #0.25 }
  *(_QWORD *)&v78.f64[1] = v286.i64[1];
  *(float32x2_t *)_Q0.f32 = vadd_f32(vmul_f32(*(float32x2_t *)v286.i8, *(float32x2_t *)_Q0.f32), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v78.f64[0] = vrndm_f32(*(float32x2_t *)_Q0.f32);
  v79 = vadd_f32(vsub_f32(*(float32x2_t *)&v78.f64[0], *(float32x2_t *)_Q0.f32), _D13);
  *(float32x2_t *)_Q0.f32 = vsub_f32(*(float32x2_t *)_Q0.f32, *(float32x2_t *)&v78.f64[0]);
  v80 = vmul_f32(v79, (float32x2_t)0x3F0000003F000000);
  v81 = vmul_f32(v79, v80);
  *(float32x2_t *)v82.i8 = vadd_f32(vadd_f32(v80, vsub_f32(v81, vmul_f32(v79, vmul_f32(v79, vmul_f32(v79, v48))))), v51);
  v83 = vsub_f32(_D13, *(float32x2_t *)v82.i8);
  *(float32x2_t *)v84.i8 = vadd_f32(vadd_f32(*(float32x2_t *)&v78.f64[0], vdiv_f32(vadd_f32(vadd_f32(v80, vsub_f32(v81, vmul_f32(v79, v81))), v51), *(float32x2_t *)v82.i8)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v85.f64[0] = vmul_f32(*(float32x2_t *)_Q0.f32, *(float32x2_t *)_Q0.f32);
  *(float32x2_t *)v273.f32 = vadd_f32(vadd_f32(*(float32x2_t *)&v78.f64[0], vdiv_f32(vdiv_f32(vmul_f32(*(float32x2_t *)_Q0.f32, *(float32x2_t *)&v85.f64[0]), _D9), v83)), _D8);
  v280 = v83;
  v255 = v84;
  v266 = v82;
  _Q0.f32[0] = *((float *)a4 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 5), *(float32x2_t *)v84.i8, 1), *((float *)a4 + 4), *(float *)v84.i32);
  v83.i32[0] = *((_DWORD *)a4 + 9);
  *(float *)v85.f64 = vmuls_lane_f32(*(float *)v82.i32, *(float32x2_t *)v82.i8, 1);
  v243 = v85;
  *(float *)v78.f64 = v83.f32[0]
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 8), *(float32x2_t *)v84.i8, 1), *((float *)a4 + 7), *(float *)v84.i32);
  _Q0.i32[1] = LODWORD(v78.f64[0]);
  *(double *)v87.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a4 + 1), *(double *)_Q0.i64, v78, v85.f64[0], *(double *)&v83, v84, (uint8x8_t)v81, *(double *)v82.i64, v86);
  v88 = v243;
  v89 = (int8x16_t)vmulq_n_f32(v87, *(float *)v243.f64);
  v87.f32[0] = *((float *)a4 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 5), *(float32x2_t *)v255.i8, 1), *((float *)a4 + 4), v273.f32[0]);
  LODWORD(v90) = *((_DWORD *)a4 + 9);
  HIDWORD(v91) = v280.i32[1];
  *(float *)&v91 = vmuls_lane_f32(v280.f32[0], *(float32x2_t *)v266.i8, 1);
  v237 = *(float *)&v91;
  v244 = (float32x4_t)v89;
  *(float *)v88.f64 = *(float *)&v90
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 8), *(float32x2_t *)v255.i8, 1), *((float *)a4 + 7), v273.f32[0]);
  v87.i32[1] = LODWORD(v88.f64[0]);
  *(double *)v93.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a4 + 1), *(double *)v87.i64, v88, v91, v90, v266, *(uint8x8_t *)v255.i8, v92, v89);
  v94 = v255;
  *(float *)&v95 = vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 5), *(float32x2_t *)v273.f32, 1), *((float *)a4 + 4), *(float *)v255.i32);
  v96.i32[0] = *((_DWORD *)a4 + 9);
  *(float *)v97.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 8), *(float32x2_t *)v273.f32, 1), *((float *)a4 + 7), *(float *)v255.i32);
  v256 = vaddq_f32(v244, vmulq_n_f32(v93, v237));
  v93.f32[0] = *((float *)a4 + 6) + *(float *)&v95;
  *(float *)v98.f64 = *(float *)v96.i32 + *(float *)v97.i32;
  v93.f32[1] = *(float *)v96.i32 + *(float *)v97.i32;
  *(double *)v99.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a4 + 1), *(double *)v93.i64, v98, v95, *(double *)v266.i64, v97, v96, *(double *)v256.i64, v94);
  *(float *)&v100 = vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 5), *(float32x2_t *)v273.f32, 1), *((float *)a4 + 4), v273.f32[0]);
  v101.i32[0] = *((_DWORD *)a4 + 9);
  *(float *)v102.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a4 + 8), *(float32x2_t *)v273.f32, 1), *((float *)a4 + 7), v273.f32[0]);
  v274 = vaddq_f32(v256, vmulq_n_f32(v99, vmuls_lane_f32(*(float *)v266.i32, v280, 1)));
  v99.f32[0] = *((float *)a4 + 6) + *(float *)&v100;
  *(float *)v103.f64 = *(float *)v101.i32 + *(float *)v102.i32;
  v99.f32[1] = *(float *)v101.i32 + *(float *)v102.i32;
  *(double *)v105.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a4 + 1), *(double *)v99.i64, v103, v100, *(double *)v256.i64, v102, v101, *(double *)v274.i64, v104);
  v294 = vaddq_f32(v274, vmulq_n_f32(v105, vmuls_lane_f32(v280.f32[0], v280, 1)));
  *(_QWORD *)&v106.f64[1] = v286.i64[1];
  *(float32x2_t *)v105.f32 = vadd_f32(vmul_f32(*(float32x2_t *)v286.i8, (float32x2_t)0x3E0000003E000000), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v106.f64[0] = vrndm_f32(*(float32x2_t *)v105.f32);
  v107 = vadd_f32(vsub_f32(*(float32x2_t *)&v106.f64[0], *(float32x2_t *)v105.f32), _D13);
  *(float32x2_t *)v105.f32 = vsub_f32(*(float32x2_t *)v105.f32, *(float32x2_t *)&v106.f64[0]);
  v108 = vmul_f32(v107, (float32x2_t)0x3F0000003F000000);
  v109 = vmul_f32(v107, v108);
  *(float32x2_t *)v110.i8 = vadd_f32(vadd_f32(v108, vsub_f32(v109, vmul_f32(v107, vmul_f32(v107, vmul_f32(v107, v48))))), v51);
  v111 = vsub_f32(_D13, *(float32x2_t *)v110.i8);
  *(float32x2_t *)v112.i8 = vadd_f32(vadd_f32(*(float32x2_t *)&v106.f64[0], vdiv_f32(vadd_f32(vadd_f32(v108, vsub_f32(v109, vmul_f32(v107, v109))), v51), *(float32x2_t *)v110.i8)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v113.f64[0] = vmul_f32(*(float32x2_t *)v105.f32, *(float32x2_t *)v105.f32);
  *(float32x2_t *)v274.f32 = vadd_f32(vadd_f32(*(float32x2_t *)&v106.f64[0], vdiv_f32(vdiv_f32(vmul_f32(*(float32x2_t *)v105.f32, *(float32x2_t *)&v113.f64[0]), _D9), v111)), _D8);
  v281 = v111;
  v257 = v112;
  v267 = v110;
  v105.f32[0] = *((float *)a5 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 5), *(float32x2_t *)v112.i8, 1), *((float *)a5 + 4), *(float *)v112.i32);
  v111.i32[0] = *((_DWORD *)a5 + 9);
  *(float *)v113.f64 = vmuls_lane_f32(*(float *)v110.i32, *(float32x2_t *)v110.i8, 1);
  v245 = v113;
  *(float *)v106.f64 = v111.f32[0]
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 8), *(float32x2_t *)v112.i8, 1), *((float *)a5 + 7), *(float *)v112.i32);
  v105.i32[1] = LODWORD(v106.f64[0]);
  *(double *)v115.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a5 + 1), *(double *)v105.i64, v106, v113.f64[0], *(double *)&v111, v112, (uint8x8_t)v109, *(double *)v110.i64, v114);
  v116 = v245;
  v117 = (int8x16_t)vmulq_n_f32(v115, *(float *)v245.f64);
  v115.f32[0] = *((float *)a5 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 5), *(float32x2_t *)v257.i8, 1), *((float *)a5 + 4), v274.f32[0]);
  LODWORD(v118) = *((_DWORD *)a5 + 9);
  HIDWORD(v119) = v281.i32[1];
  *(float *)&v119 = vmuls_lane_f32(v281.f32[0], *(float32x2_t *)v267.i8, 1);
  v238 = *(float *)&v119;
  v246 = (float32x4_t)v117;
  *(float *)v116.f64 = *(float *)&v118
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 8), *(float32x2_t *)v257.i8, 1), *((float *)a5 + 7), v274.f32[0]);
  v115.i32[1] = LODWORD(v116.f64[0]);
  *(double *)v121.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a5 + 1), *(double *)v115.i64, v116, v119, v118, v267, *(uint8x8_t *)v257.i8, v120, v117);
  v122 = v257;
  *(float *)&v123 = vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 5), *(float32x2_t *)v274.f32, 1), *((float *)a5 + 4), *(float *)v257.i32);
  v124.i32[0] = *((_DWORD *)a5 + 9);
  *(float *)v125.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 8), *(float32x2_t *)v274.f32, 1), *((float *)a5 + 7), *(float *)v257.i32);
  v258 = vaddq_f32(v246, vmulq_n_f32(v121, v238));
  v121.f32[0] = *((float *)a5 + 6) + *(float *)&v123;
  *(float *)v126.f64 = *(float *)v124.i32 + *(float *)v125.i32;
  v121.f32[1] = *(float *)v124.i32 + *(float *)v125.i32;
  *(double *)v127.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a5 + 1), *(double *)v121.i64, v126, v123, *(double *)v267.i64, v125, v124, *(double *)v258.i64, v122);
  *(float *)&v128 = vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 5), *(float32x2_t *)v274.f32, 1), *((float *)a5 + 4), v274.f32[0]);
  v129.i32[0] = *((_DWORD *)a5 + 9);
  *(float *)v130.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a5 + 8), *(float32x2_t *)v274.f32, 1), *((float *)a5 + 7), v274.f32[0]);
  v275 = vaddq_f32(v258, vmulq_n_f32(v127, vmuls_lane_f32(*(float *)v267.i32, v281, 1)));
  v127.f32[0] = *((float *)a5 + 6) + *(float *)&v128;
  *(float *)v131.f64 = *(float *)v129.i32 + *(float *)v130.i32;
  v127.f32[1] = *(float *)v129.i32 + *(float *)v130.i32;
  *(double *)v133.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a5 + 1), *(double *)v127.i64, v131, v128, *(double *)v258.i64, v130, v129, *(double *)v275.i64, v132);
  v293 = vaddq_f32(v275, vmulq_n_f32(v133, vmuls_lane_f32(v281.f32[0], v281, 1)));
  *(_QWORD *)&v134.f64[1] = v286.i64[1];
  *(float32x2_t *)v133.f32 = vadd_f32(vmul_f32(*(float32x2_t *)v286.i8, (float32x2_t)vdup_n_s32(0x3D800000u)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v134.f64[0] = vrndm_f32(*(float32x2_t *)v133.f32);
  v135 = vadd_f32(vsub_f32(*(float32x2_t *)&v134.f64[0], *(float32x2_t *)v133.f32), _D13);
  *(float32x2_t *)v133.f32 = vsub_f32(*(float32x2_t *)v133.f32, *(float32x2_t *)&v134.f64[0]);
  v136 = vmul_f32(v135, (float32x2_t)0x3F0000003F000000);
  v137 = vmul_f32(v135, v136);
  *(float32x2_t *)v138.i8 = vadd_f32(vadd_f32(v136, vsub_f32(v137, vmul_f32(v135, vmul_f32(v135, vmul_f32(v135, v48))))), v51);
  v139 = vsub_f32(_D13, *(float32x2_t *)v138.i8);
  *(float32x2_t *)v140.i8 = vadd_f32(vadd_f32(*(float32x2_t *)&v134.f64[0], vdiv_f32(vadd_f32(vadd_f32(v136, vsub_f32(v137, vmul_f32(v135, v137))), v51), *(float32x2_t *)v138.i8)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v141.f64[0] = vmul_f32(*(float32x2_t *)v133.f32, *(float32x2_t *)v133.f32);
  *(float32x2_t *)v275.f32 = vadd_f32(vadd_f32(*(float32x2_t *)&v134.f64[0], vdiv_f32(vdiv_f32(vmul_f32(*(float32x2_t *)v133.f32, *(float32x2_t *)&v141.f64[0]), _D9), v139)), _D8);
  v282 = v139;
  v259 = v140;
  v268 = v138;
  v133.f32[0] = *((float *)a6 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 5), *(float32x2_t *)v140.i8, 1), *((float *)a6 + 4), *(float *)v140.i32);
  v139.i32[0] = *((_DWORD *)a6 + 9);
  *(float *)v141.f64 = vmuls_lane_f32(*(float *)v138.i32, *(float32x2_t *)v138.i8, 1);
  v247 = v141;
  *(float *)v134.f64 = v139.f32[0]
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 8), *(float32x2_t *)v140.i8, 1), *((float *)a6 + 7), *(float *)v140.i32);
  v133.i32[1] = LODWORD(v134.f64[0]);
  *(double *)v143.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a6 + 1), *(double *)v133.i64, v134, v141.f64[0], *(double *)&v139, v140, (uint8x8_t)v137, *(double *)v138.i64, v142);
  v144 = v247;
  v145 = (int8x16_t)vmulq_n_f32(v143, *(float *)v247.f64);
  v143.f32[0] = *((float *)a6 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 5), *(float32x2_t *)v259.i8, 1), *((float *)a6 + 4), v275.f32[0]);
  LODWORD(v146) = *((_DWORD *)a6 + 9);
  HIDWORD(v147) = v282.i32[1];
  *(float *)&v147 = vmuls_lane_f32(v282.f32[0], *(float32x2_t *)v268.i8, 1);
  v239 = *(float *)&v147;
  v248 = (float32x4_t)v145;
  *(float *)v144.f64 = *(float *)&v146
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 8), *(float32x2_t *)v259.i8, 1), *((float *)a6 + 7), v275.f32[0]);
  v143.i32[1] = LODWORD(v144.f64[0]);
  *(double *)v149.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a6 + 1), *(double *)v143.i64, v144, v147, v146, v268, *(uint8x8_t *)v259.i8, v148, v145);
  v150 = v259;
  *(float *)&v151 = vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 5), *(float32x2_t *)v275.f32, 1), *((float *)a6 + 4), *(float *)v259.i32);
  v152.i32[0] = *((_DWORD *)a6 + 9);
  *(float *)v153.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 8), *(float32x2_t *)v275.f32, 1), *((float *)a6 + 7), *(float *)v259.i32);
  v260 = vaddq_f32(v248, vmulq_n_f32(v149, v239));
  v149.f32[0] = *((float *)a6 + 6) + *(float *)&v151;
  *(float *)v154.f64 = *(float *)v152.i32 + *(float *)v153.i32;
  v149.f32[1] = *(float *)v152.i32 + *(float *)v153.i32;
  *(double *)v155.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a6 + 1), *(double *)v149.i64, v154, v151, *(double *)v268.i64, v153, v152, *(double *)v260.i64, v150);
  *(float *)&v156 = vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 5), *(float32x2_t *)v275.f32, 1), *((float *)a6 + 4), v275.f32[0]);
  v157.i32[0] = *((_DWORD *)a6 + 9);
  *(float *)v158.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a6 + 8), *(float32x2_t *)v275.f32, 1), *((float *)a6 + 7), v275.f32[0]);
  v276 = vaddq_f32(v260, vmulq_n_f32(v155, vmuls_lane_f32(*(float *)v268.i32, v282, 1)));
  v155.f32[0] = *((float *)a6 + 6) + *(float *)&v156;
  *(float *)v159.f64 = *(float *)v157.i32 + *(float *)v158.i32;
  v155.f32[1] = *(float *)v157.i32 + *(float *)v158.i32;
  *(double *)v161.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a6 + 1), *(double *)v155.i64, v159, v156, *(double *)v260.i64, v158, v157, *(double *)v276.i64, v160);
  v292 = vaddq_f32(v276, vmulq_n_f32(v161, vmuls_lane_f32(v282.f32[0], v282, 1)));
  *(_QWORD *)&v162.f64[1] = v286.i64[1];
  *(float32x2_t *)v161.f32 = vadd_f32(vmul_f32(*(float32x2_t *)v286.i8, (float32x2_t)0x3D0000003D000000), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v162.f64[0] = vrndm_f32(*(float32x2_t *)v161.f32);
  v163 = vadd_f32(vsub_f32(*(float32x2_t *)&v162.f64[0], *(float32x2_t *)v161.f32), _D13);
  *(float32x2_t *)v161.f32 = vsub_f32(*(float32x2_t *)v161.f32, *(float32x2_t *)&v162.f64[0]);
  v164 = vmul_f32(v163, (float32x2_t)0x3F0000003F000000);
  v165 = vmul_f32(v163, v164);
  *(float32x2_t *)v166.i8 = vadd_f32(vadd_f32(v164, vsub_f32(v165, vmul_f32(v163, vmul_f32(v163, vmul_f32(v163, v48))))), v51);
  v167 = vsub_f32(_D13, *(float32x2_t *)v166.i8);
  *(float32x2_t *)v168.i8 = vadd_f32(vadd_f32(*(float32x2_t *)&v162.f64[0], vdiv_f32(vadd_f32(vadd_f32(v164, vsub_f32(v165, vmul_f32(v163, v165))), v51), *(float32x2_t *)v166.i8)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v169.f64[0] = vmul_f32(*(float32x2_t *)v161.f32, *(float32x2_t *)v161.f32);
  *(float32x2_t *)v276.f32 = vadd_f32(vadd_f32(*(float32x2_t *)&v162.f64[0], vdiv_f32(vdiv_f32(vmul_f32(*(float32x2_t *)v161.f32, *(float32x2_t *)&v169.f64[0]), _D9), v167)), _D8);
  v283 = v167;
  v261 = v168;
  v269 = v166;
  v161.f32[0] = *((float *)a7 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 5), *(float32x2_t *)v168.i8, 1), *((float *)a7 + 4), *(float *)v168.i32);
  v167.i32[0] = *((_DWORD *)a7 + 9);
  *(float *)v169.f64 = vmuls_lane_f32(*(float *)v166.i32, *(float32x2_t *)v166.i8, 1);
  v249 = v169;
  *(float *)v162.f64 = v167.f32[0]
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 8), *(float32x2_t *)v168.i8, 1), *((float *)a7 + 7), *(float *)v168.i32);
  v161.i32[1] = LODWORD(v162.f64[0]);
  *(double *)v171.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a7 + 1), *(double *)v161.i64, v162, v169.f64[0], *(double *)&v167, v168, (uint8x8_t)v165, *(double *)v166.i64, v170);
  v172 = v249;
  v173 = (int8x16_t)vmulq_n_f32(v171, *(float *)v249.f64);
  v171.f32[0] = *((float *)a7 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 5), *(float32x2_t *)v261.i8, 1), *((float *)a7 + 4), v276.f32[0]);
  LODWORD(v174) = *((_DWORD *)a7 + 9);
  HIDWORD(v175) = v283.i32[1];
  *(float *)&v175 = vmuls_lane_f32(v283.f32[0], *(float32x2_t *)v269.i8, 1);
  v240 = *(float *)&v175;
  v250 = (float32x4_t)v173;
  *(float *)v172.f64 = *(float *)&v174
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 8), *(float32x2_t *)v261.i8, 1), *((float *)a7 + 7), v276.f32[0]);
  v171.i32[1] = LODWORD(v172.f64[0]);
  *(double *)v177.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a7 + 1), *(double *)v171.i64, v172, v175, v174, v269, *(uint8x8_t *)v261.i8, v176, v173);
  v178 = v261;
  *(float *)&v179 = vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 5), *(float32x2_t *)v276.f32, 1), *((float *)a7 + 4), *(float *)v261.i32);
  v180.i32[0] = *((_DWORD *)a7 + 9);
  *(float *)v181.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 8), *(float32x2_t *)v276.f32, 1), *((float *)a7 + 7), *(float *)v261.i32);
  v262 = vaddq_f32(v250, vmulq_n_f32(v177, v240));
  v177.f32[0] = *((float *)a7 + 6) + *(float *)&v179;
  *(float *)v182.f64 = *(float *)v180.i32 + *(float *)v181.i32;
  v177.f32[1] = *(float *)v180.i32 + *(float *)v181.i32;
  *(double *)v183.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a7 + 1), *(double *)v177.i64, v182, v179, *(double *)v269.i64, v181, v180, *(double *)v262.i64, v178);
  *(float *)&v184 = vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 5), *(float32x2_t *)v276.f32, 1), *((float *)a7 + 4), v276.f32[0]);
  v185.i32[0] = *((_DWORD *)a7 + 9);
  *(float *)v186.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a7 + 8), *(float32x2_t *)v276.f32, 1), *((float *)a7 + 7), v276.f32[0]);
  v277 = vaddq_f32(v262, vmulq_n_f32(v183, vmuls_lane_f32(*(float *)v269.i32, v283, 1)));
  v183.f32[0] = *((float *)a7 + 6) + *(float *)&v184;
  *(float *)v187.f64 = *(float *)v185.i32 + *(float *)v186.i32;
  v183.f32[1] = *(float *)v185.i32 + *(float *)v186.i32;
  *(double *)v189.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a7 + 1), *(double *)v183.i64, v187, v184, *(double *)v262.i64, v186, v185, *(double *)v277.i64, v188);
  v190 = vaddq_f32(v277, vmulq_n_f32(v189, vmuls_lane_f32(v283.f32[0], v283, 1)));
  v291 = v190;
  *(_QWORD *)&v191.f64[1] = v286.i64[1];
  *(float32x2_t *)v190.f32 = vadd_f32(vmul_f32(*(float32x2_t *)v286.i8, (float32x2_t)vdup_n_s32(0x3C800000u)), (float32x2_t)0xBF000000BF000000);
  *(float32x2_t *)&v191.f64[0] = vrndm_f32(*(float32x2_t *)v190.f32);
  v192 = vadd_f32(vsub_f32(*(float32x2_t *)&v191.f64[0], *(float32x2_t *)v190.f32), _D13);
  *(float32x2_t *)v190.f32 = vsub_f32(*(float32x2_t *)v190.f32, *(float32x2_t *)&v191.f64[0]);
  v193 = vmul_f32(v192, (float32x2_t)0x3F0000003F000000);
  v194 = vmul_f32(v192, v193);
  *(float32x2_t *)v195.i8 = vadd_f32(vadd_f32(v193, vsub_f32(v194, vmul_f32(v192, vmul_f32(v192, vmul_f32(v192, v48))))), v51);
  v196 = vsub_f32(_D13, *(float32x2_t *)v195.i8);
  *(float32x2_t *)v197.i8 = vadd_f32(vadd_f32(*(float32x2_t *)&v191.f64[0], vdiv_f32(vadd_f32(vadd_f32(v193, vsub_f32(v194, vmul_f32(v192, v194))), v51), *(float32x2_t *)v195.i8)), (float32x2_t)0xBF000000BF000000);
  v198 = vmul_f32(*(float32x2_t *)v190.f32, *(float32x2_t *)v190.f32);
  *(float32x2_t *)v190.f32 = vadd_f32(vadd_f32(*(float32x2_t *)&v191.f64[0], vdiv_f32(vdiv_f32(vmul_f32(*(float32x2_t *)v190.f32, v198), _D9), v196)), _D8);
  v284 = *(float32x2_t *)v190.f32;
  v287 = v196;
  v190.f32[0] = vmuls_lane_f32(*(float *)v195.i32, *(float32x2_t *)v195.i8, 1);
  v263 = v190;
  v270 = v197;
  v278 = v195;
  v198.i32[0] = *((_DWORD *)a8 + 7);
  v190.f32[0] = *((float *)a8 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 5), *(float32x2_t *)v197.i8, 1), *((float *)a8 + 4), *(float *)v197.i32);
  v196.i32[0] = *((_DWORD *)a8 + 9);
  *(float *)v191.f64 = v196.f32[0]
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 8), *(float32x2_t *)v197.i8, 1), v198.f32[0], *(float *)v197.i32);
  v190.i32[1] = LODWORD(v191.f64[0]);
  *(double *)v200.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a8 + 1), *(double *)v190.i64, v191, *(double *)&v198, *(double *)&v196, v197, (uint8x8_t)v194, *(double *)v195.i64, v199);
  v201 = (float64x2_t)v263;
  v264 = vmulq_n_f32(v200, v263.f32[0]);
  v200.f32[0] = *((float *)a8 + 6)
              + vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 5), *(float32x2_t *)v270.i8, 1), *((float *)a8 + 4), v284.f32[0]);
  LODWORD(v202) = *((_DWORD *)a8 + 9);
  HIDWORD(v203) = v287.i32[1];
  *(float *)&v203 = vmuls_lane_f32(v287.f32[0], *(float32x2_t *)v278.i8, 1);
  v250.i32[0] = LODWORD(v203);
  *(float *)v201.f64 = *(float *)&v202
                     + vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 8), *(float32x2_t *)v270.i8, 1), *((float *)a8 + 7), v284.f32[0]);
  v200.i32[1] = LODWORD(v201.f64[0]);
  *(double *)v206.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a8 + 1), *(double *)v200.i64, v201, v203, v202, v278, *(uint8x8_t *)v270.i8, v204, v205);
  v207 = v270;
  *(float *)&v208 = vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 5), v284, 1), *((float *)a8 + 4), *(float *)v270.i32);
  v209.i32[0] = *((_DWORD *)a8 + 9);
  *(float *)v210.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 8), v284, 1), *((float *)a8 + 7), *(float *)v270.i32);
  v271 = vaddq_f32(v264, vmulq_n_f32(v206, v250.f32[0]));
  v206.f32[0] = *((float *)a8 + 6) + *(float *)&v208;
  *(float *)v211.f64 = *(float *)v209.i32 + *(float *)v210.i32;
  v206.f32[1] = *(float *)v209.i32 + *(float *)v210.i32;
  *(double *)v212.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a8 + 1), *(double *)v206.i64, v211, v208, *(double *)v278.i64, v210, v209, *(double *)v271.i64, v207);
  *(float *)&v213 = vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 5), v284, 1), *((float *)a8 + 4), v284.f32[0]);
  v214.i32[0] = *((_DWORD *)a8 + 9);
  *(float *)v215.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)a8 + 8), v284, 1), *((float *)a8 + 7), v284.f32[0]);
  v285 = vaddq_f32(v271, vmulq_n_f32(v212, vmuls_lane_f32(*(float *)v278.i32, v287, 1)));
  v212.f32[0] = *((float *)a8 + 6) + *(float *)&v213;
  *(float *)v216.f64 = *(float *)v214.i32 + *(float *)v215.i32;
  v212.f32[1] = *(float *)v214.i32 + *(float *)v215.i32;
  *(double *)v218.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a8 + 1), *(double *)v212.i64, v216, v213, *(double *)v271.i64, v215, v214, *(double *)v285.i64, v217);
  v289 = v251;
  v290 = vaddq_f32(v285, vmulq_n_f32(v218, vmuls_lane_f32(v287.f32[0], v287, 1)));
  v219 = &v289;
  v220 = &v295;
  if (v36 <= 0.5)
    v220 = &v289;
  v221 = *v220;
  v288 = v295;
  v289 = v221;
  v222 = &v288;
  v223 = &v294;
  if (v36 <= 0.5)
    v224 = &v288;
  else
    v224 = &v294;
  if (v36 <= 1.5)
    v223 = &v289;
  v225 = *v223;
  v288 = *v224;
  v289 = v225;
  v226 = &v293;
  if (v36 <= 1.5)
    v227 = &v288;
  else
    v227 = &v293;
  if (v36 <= 2.5)
    v226 = &v289;
  v228 = *v226;
  v288 = *v227;
  v289 = v228;
  v229 = &v292;
  if (v36 <= 2.5)
    v230 = &v288;
  else
    v230 = &v292;
  if (v36 <= 3.5)
    v229 = &v289;
  v231 = *v229;
  v288 = *v230;
  v289 = v231;
  v232 = &v291;
  if (v36 <= 3.5)
    v233 = &v288;
  else
    v233 = &v291;
  if (v36 <= 4.5)
    v232 = &v289;
  v234 = *v232;
  v288 = *v233;
  v289 = v234;
  if (v36 > 4.5)
    v222 = &v290;
  if (v36 > 5.5)
    v219 = &v290;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(*v219, 1.0 - (float)(v252 - v36)), *v222, v252 - v36).u64[0];
  return result;
}

void CI::f4_sr_sr_sr_sr_sr_sr_sr_sr_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8;
  _QWORD *v10;
  double (*v11)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, float);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const vec2 *v19;
  uint64_t v20;
  double (*v21)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, float);
  __int128 v22;
  uint64_t v23;
  const vec2 *v24;

  v8 = a3;
  v10 = *(_QWORD **)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, float))(a1 + 24);
  v12 = v10[1];
  v13 = v10[4];
  v14 = v10[7];
  v15 = v10[10];
  v16 = v10[13];
  v17 = v10[16];
  v18 = v10[19];
  v19 = (const vec2 *)v10[22];
  v20 = v10[25];
  if (*(_BYTE *)(a1 + 64))
  {
    v24 = (const vec2 *)v10[22];
    v21 = *(double (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, float))(a1 + 24);
    v23 = v10[7];
    CI::setDC((CI *)(a3 + 16 * v10[28]), v19);
    v14 = v23;
    v19 = v24;
    v11 = v21;
    v8 = a3;
  }
  *(double *)&v22 = v11(a4 + 80 * v12, a4 + 80 * v13, a4 + 80 * v14, a4 + 80 * v15, a4 + 80 * v16, a4 + 80 * v17, a4 + 80 * v18, a4 + 80 * (_QWORD)v19, *(float *)(a2 + (v20 << 6)));
  *(_OWORD *)(v8 + 16 * a7) = v22;
}

double cikernel::_median3x3(cikernel *this, SamplerObj *a2)
{
  float64x2_t v3;
  float32x2_t v4;
  double v5;
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  double v9;
  int8x16_t v10;
  float64x2_t v16;
  double v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  double v21;
  int8x16_t v22;
  float32x4_t v23;
  float64x2_t v24;
  double v25;
  double v26;
  uint8x8_t v27;
  int8x16_t v28;
  double v29;
  int8x16_t v30;
  float32x4_t v31;
  float64x2_t v32;
  double v33;
  double v34;
  uint8x8_t v35;
  int8x16_t v36;
  double v37;
  int8x16_t v38;
  float32x4_t v39;
  float64x2_t v40;
  double v41;
  double v42;
  uint8x8_t v43;
  int8x16_t v44;
  double v45;
  int8x16_t v46;
  float64x2_t v48;
  double v49;
  double v50;
  uint8x8_t v51;
  int8x16_t v52;
  double v53;
  int8x16_t v54;
  float32x4_t v55;
  float64x2_t v56;
  double v57;
  double v58;
  uint8x8_t v59;
  int8x16_t v60;
  double v61;
  int8x16_t v62;
  float32x4_t v63;
  float64x2_t v64;
  double v65;
  double v66;
  uint8x8_t v67;
  int8x16_t v68;
  double v69;
  int8x16_t v70;
  float32x4_t v71;
  double v72;
  int8x16_t v73;
  double v74;
  float64x2_t v75;
  double v76;
  int8x16_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  double result;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float64x2_t v107;

  v3.f64[0] = *(float64_t *)CI::getDC(this);
  v107 = v3;
  v4 = vadd_f32(*(float32x2_t *)&v3.f64[0], (float32x2_t)1065353216);
  *(float *)&v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v3.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v3, v5, v6, v8, v7, v9, v10);
  v106 = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  v16 = v107;
  *(float32x2_t *)_Q0.f32 = vadd_f32(*(float32x2_t *)&v107.f64[0], *(float32x2_t *)_Q0.f32);
  *(float *)&v17 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v18) = *((_DWORD *)this + 7);
  v19.i32[0] = *((_DWORD *)this + 9);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v18, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v17;
  *(float *)v16.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  _Q0.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v16, v17, v18, v20, v19, v21, v22);
  v105 = v23;
  v24 = v107;
  *(float32x2_t *)v23.f32 = vadd_f32(*(float32x2_t *)&v107.f64[0], (float32x2_t)0x3F80000000000000);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v23.f32, 1), *((float *)this + 4), v23.f32[0]);
  LODWORD(v26) = *((_DWORD *)this + 7);
  v27.i32[0] = *((_DWORD *)this + 9);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v23.f32, 1), *(float *)&v26, v23.f32[0]);
  v23.f32[0] = *((float *)this + 6) + *(float *)&v25;
  *(float *)v24.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  v23.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v23.i64, v24, v25, v26, v28, v27, v29, v30);
  v104 = v31;
  v32 = v107;
  *(float32x2_t *)v31.f32 = vadd_f32(*(float32x2_t *)&v107.f64[0], (float32x2_t)0x3F800000BF800000);
  *(float *)&v33 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v31.f32, 1), *((float *)this + 4), v31.f32[0]);
  LODWORD(v34) = *((_DWORD *)this + 7);
  v35.i32[0] = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v31.f32, 1), *(float *)&v34, v31.f32[0]);
  v31.f32[0] = *((float *)this + 6) + *(float *)&v33;
  *(float *)v32.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  v31.f32[1] = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v31.i64, v32, v33, v34, v36, v35, v37, v38);
  v103 = v39;
  v40 = v107;
  *(float32x2_t *)v39.f32 = vadd_f32(*(float32x2_t *)&v107.f64[0], (float32x2_t)3212836864);
  *(float *)&v41 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v39.f32, 1), *((float *)this + 4), v39.f32[0]);
  LODWORD(v42) = *((_DWORD *)this + 7);
  v43.i32[0] = *((_DWORD *)this + 9);
  *(float *)v44.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v39.f32, 1), *(float *)&v42, v39.f32[0]);
  v39.f32[0] = *((float *)this + 6) + *(float *)&v41;
  *(float *)v40.f64 = *(float *)v43.i32 + *(float *)v44.i32;
  v39.f32[1] = *(float *)v43.i32 + *(float *)v44.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v39.i64, v40, v41, v42, v44, v43, v45, v46);
  v102 = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  v48 = v107;
  *(float32x2_t *)_Q0.f32 = vadd_f32(*(float32x2_t *)&v107.f64[0], *(float32x2_t *)_Q0.f32);
  *(float *)&v49 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v50) = *((_DWORD *)this + 7);
  v51.i32[0] = *((_DWORD *)this + 9);
  *(float *)v52.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v50, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v49;
  *(float *)v48.f64 = *(float *)v51.i32 + *(float *)v52.i32;
  _Q0.f32[1] = *(float *)v51.i32 + *(float *)v52.i32;
  *(double *)v55.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v48, v49, v50, v52, v51, v53, v54);
  v101 = v55;
  v56 = v107;
  *(float32x2_t *)v55.f32 = vadd_f32(*(float32x2_t *)&v107.f64[0], (float32x2_t)0xBF80000000000000);
  *(float *)&v57 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v55.f32, 1), *((float *)this + 4), v55.f32[0]);
  LODWORD(v58) = *((_DWORD *)this + 7);
  v59.i32[0] = *((_DWORD *)this + 9);
  *(float *)v60.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v55.f32, 1), *(float *)&v58, v55.f32[0]);
  v55.f32[0] = *((float *)this + 6) + *(float *)&v57;
  *(float *)v56.f64 = *(float *)v59.i32 + *(float *)v60.i32;
  v55.f32[1] = *(float *)v59.i32 + *(float *)v60.i32;
  *(double *)v63.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v55.i64, v56, v57, v58, v60, v59, v61, v62);
  v100 = v63;
  v64 = v107;
  *(float32x2_t *)v63.f32 = vadd_f32(*(float32x2_t *)&v107.f64[0], (float32x2_t)0xBF8000003F800000);
  *(float *)&v65 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v63.f32, 1), *((float *)this + 4), v63.f32[0]);
  LODWORD(v66) = *((_DWORD *)this + 7);
  v67.i32[0] = *((_DWORD *)this + 9);
  *(float *)v68.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v63.f32, 1), *(float *)&v66, v63.f32[0]);
  v63.f32[0] = *((float *)this + 6) + *(float *)&v65;
  *(float *)v64.f64 = *(float *)v67.i32 + *(float *)v68.i32;
  v63.f32[1] = *(float *)v67.i32 + *(float *)v68.i32;
  *(double *)v71.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v63.i64, v64, v65, v66, v68, v67, v69, v70);
  v99 = v71;
  HIDWORD(v72) = HIDWORD(v107.f64[0]);
  LODWORD(v72) = *((_DWORD *)this + 7);
  v73.i32[0] = *((_DWORD *)this + 9);
  *(float *)&v74 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v107.f64[0], 1), *(float *)&v72, *(float *)v107.f64);
  v71.f32[0] = *((float *)this + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v107.f64[0], 1), *((float *)this + 4), *(float *)v107.f64);
  *(float *)v75.f64 = *(float *)v73.i32 + *(float *)&v74;
  v71.f32[1] = *(float *)v73.i32 + *(float *)&v74;
  *(double *)v78.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v71.i64, v75, v72, v74, v73, *(uint8x8_t *)&v107.f64[0], v76, v77);
  v79 = vminnmq_f32(v105, v104);
  v80 = vmaxnmq_f32(v105, v104);
  v81 = vminnmq_f32(v102, v101);
  v82 = vmaxnmq_f32(v102, v101);
  v83 = vminnmq_f32(v99, v78);
  v84 = vmaxnmq_f32(v99, v78);
  v85 = vminnmq_f32(v106, v79);
  v86 = vmaxnmq_f32(v106, v79);
  v87 = vminnmq_f32(v103, v81);
  v88 = vmaxnmq_f32(v103, v81);
  v89 = vminnmq_f32(v100, v83);
  v90 = vmaxnmq_f32(v100, v83);
  v91 = vminnmq_f32(v86, v80);
  v92 = vmaxnmq_f32(v86, v80);
  v93 = vminnmq_f32(v88, v82);
  v94 = vmaxnmq_f32(v88, v82);
  v95 = vminnmq_f32(v90, v84);
  v96 = vminnmq_f32(v92, vminnmq_f32(v94, vmaxnmq_f32(v90, v84)));
  v97 = vminnmq_f32(vmaxnmq_f32(v93, v95), vmaxnmq_f32(v91, vminnmq_f32(v93, v95)));
  *(_QWORD *)&result = vminnmq_f32(vmaxnmq_f32(vmaxnmq_f32(vmaxnmq_f32(v85, v87), v89), vminnmq_f32(v97, v96)), vmaxnmq_f32(v97, v96)).u64[0];
  return result;
}

void OUTLINED_FUNCTION_0_2(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x12u);
}

double cikernel::_mesh1(CI *a1, int8x16_t a2, float a3, int8x16_t a4, float a5)
{
  float v5;
  float32x2_t *DC;
  float32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float v10;
  float v11;
  float v12;
  float32x2_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  double result;

  v5 = a3 * 0.5;
  DC = (float32x2_t *)CI::getDC(a1);
  v7 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  v8 = vsub_f32(*DC, *(float32x2_t *)a2.i8);
  v9 = vsub_f32(v7, *(float32x2_t *)a2.i8);
  v10 = fabsf(vmlas_n_f32((float)-v8.f32[1] * v9.f32[0], v9.f32[1], v8.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v9, v9))), 0.01));
  v11 = vmlas_n_f32(vmuls_lane_f32(v9.f32[1], v8, 1), v9.f32[0], v8.f32[0]);
  v12 = sqrtf(vaddv_f32(vmul_f32(v8, v8)));
  if (v11 >= 0.0)
    v12 = v10;
  v13 = vsub_f32(*DC, v7);
  v14 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v9, v13).i32[1]), v9.f32[0], v13.f32[0]);
  v15 = sqrtf(vaddv_f32(vmul_f32(v13, v13)));
  if (v14 < 0.0)
    v15 = v12;
  v16 = 1.0;
  if ((float)(v5 - v15) <= 1.0)
    v16 = v5 - v15;
  v17 = 0.0;
  if ((float)(v5 - v15) >= 0.0)
    v17 = v16;
  v18 = (v17 * -2.0 + 3.0) * v17 * v17;
  v19 = v15 - (v5 + -1.0);
  *(_QWORD *)&result = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v19 < 0.0)), 0x1FuLL)), a4, vandq_s8((int8x16_t)vmulq_n_f32((float32x4_t)a4, v18), (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16((float)(v15 - v5) < 0.0)), 0x1FuLL)))), a5).u64[0];
  return result;
}

void CI::f4_f4_f_clr_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, float, __n128, float);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 *v17;
  __int128 v18;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, float, __n128, float))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_QWORD *)(v10 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
  v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v18 = v11(a1, *v17, *((float *)a2 + 16 * v14), *((__n128 *)a2 + 4 * v15), *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_mesh2(CI *a1, int8x16_t a2, int8x16_t a3, float a4, int8x16_t a5, float a6)
{
  float v6;
  float32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v10;
  float v11;
  float v12;
  float v13;
  float32x2_t v14;
  float v15;
  float v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float v20;
  float v21;
  float v22;
  float32x2_t v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  double result;

  v6 = a4 * 0.5;
  v7 = *(float32x2_t *)CI::getDC(a1);
  v8 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  v9 = vsub_f32(v7, *(float32x2_t *)a2.i8);
  v10 = vsub_f32(v8, *(float32x2_t *)a2.i8);
  v11 = fabsf(vmlas_n_f32((float)-v9.f32[1] * v10.f32[0], v10.f32[1], v9.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v10, v10))), 0.01));
  v12 = vmlas_n_f32(vmuls_lane_f32(v10.f32[1], v9, 1), v10.f32[0], v9.f32[0]);
  v13 = sqrtf(vaddv_f32(vmul_f32(v9, v9)));
  if (v12 >= 0.0)
    v13 = v11;
  v14 = vsub_f32(v7, v8);
  v15 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v10, v14).i32[1]), v10.f32[0], v14.f32[0]);
  v16 = sqrtf(vaddv_f32(vmul_f32(v14, v14)));
  if (v15 < 0.0)
    v16 = v13;
  v17 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  v18 = vsub_f32(v7, *(float32x2_t *)a3.i8);
  v19 = vsub_f32(v17, *(float32x2_t *)a3.i8);
  v20 = fabsf(vmlas_n_f32((float)-v18.f32[1] * v19.f32[0], v19.f32[1], v18.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v19, v19))), 0.01));
  v21 = vmlas_n_f32(vmuls_lane_f32(v19.f32[1], v18, 1), v19.f32[0], v18.f32[0]);
  v22 = sqrtf(vaddv_f32(vmul_f32(v18, v18)));
  if (v21 >= 0.0)
    v22 = v20;
  v23 = vsub_f32(v7, v17);
  v24 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v19, v23).i32[1]), v19.f32[0], v23.f32[0]);
  v25 = sqrtf(vaddv_f32(vmul_f32(v23, v23)));
  if (v24 < 0.0)
    v25 = v22;
  v26 = fminf(v16, v25);
  v27 = 1.0;
  if ((float)(v6 - v26) <= 1.0)
    v27 = v6 - v26;
  v28 = 0.0;
  if ((float)(v6 - v26) >= 0.0)
    v28 = v27;
  v29 = (v28 * -2.0 + 3.0) * v28 * v28;
  v30 = v26 - (v6 + -1.0);
  *(_QWORD *)&result = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v30 < 0.0)), 0x1FuLL)), a5, vandq_s8((int8x16_t)vmulq_n_f32((float32x4_t)a5, v29), (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16((float)(v26 - v6) < 0.0)), 0x1FuLL)))), a6).u64[0];
  return result;
}

void CI::f4_f4_f4_f_clr_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(_QWORD *, __n128, __n128, float, __n128, float);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __int128 v20;

  v9 = a1[6];
  v10 = (double (*)(_QWORD *, __n128, __n128, float, __n128, float))a1[3];
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_QWORD *)(v9 + 80);
  v17 = *(_QWORD *)(v9 + 104);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
  v18 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v14);
  v19 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v20 = v10(a1, *v19, *v18, *((float *)a2 + 16 * v15), *((__n128 *)a2 + 4 * v16), *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_mesh4(CI *a1, int8x16_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, float a6, int8x16_t a7, float a8)
{
  float v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float v13;
  float v14;
  float v15;
  float32x2_t v16;
  float v17;
  float v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float v22;
  float v23;
  float v24;
  float32x2_t v25;
  float v26;
  float v27;
  float v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float v32;
  float v33;
  float v34;
  float32x2_t v35;
  float v36;
  float v37;
  float v38;
  float32x2_t v39;
  float32x2_t v40;
  float32x2_t v41;
  float v42;
  float v43;
  float v44;
  float32x2_t v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  double result;

  v8 = a6 * 0.5;
  v9 = *(float32x2_t *)CI::getDC(a1);
  v10 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  v11 = vsub_f32(v9, *(float32x2_t *)a2.i8);
  v12 = vsub_f32(v10, *(float32x2_t *)a2.i8);
  v13 = fabsf(vmlas_n_f32((float)-v11.f32[1] * v12.f32[0], v12.f32[1], v11.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v12, v12))), 0.01));
  v14 = vmlas_n_f32(vmuls_lane_f32(v12.f32[1], v11, 1), v12.f32[0], v11.f32[0]);
  v15 = sqrtf(vaddv_f32(vmul_f32(v11, v11)));
  if (v14 >= 0.0)
    v15 = v13;
  v16 = vsub_f32(v9, v10);
  v17 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v12, v16).i32[1]), v12.f32[0], v16.f32[0]);
  v18 = sqrtf(vaddv_f32(vmul_f32(v16, v16)));
  if (v17 < 0.0)
    v18 = v15;
  v19 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  v20 = vsub_f32(v9, *(float32x2_t *)a3.i8);
  v21 = vsub_f32(v19, *(float32x2_t *)a3.i8);
  v22 = fabsf(vmlas_n_f32((float)-v20.f32[1] * v21.f32[0], v21.f32[1], v20.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v21, v21))), 0.01));
  v23 = vmlas_n_f32(vmuls_lane_f32(v21.f32[1], v20, 1), v21.f32[0], v20.f32[0]);
  v24 = sqrtf(vaddv_f32(vmul_f32(v20, v20)));
  if (v23 >= 0.0)
    v24 = v22;
  v25 = vsub_f32(v9, v19);
  v26 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v21, v25).i32[1]), v21.f32[0], v25.f32[0]);
  v27 = sqrtf(vaddv_f32(vmul_f32(v25, v25)));
  if (v26 < 0.0)
    v27 = v24;
  v28 = fminf(v18, v27);
  v29 = (float32x2_t)vextq_s8(a4, a4, 8uLL).u64[0];
  v30 = vsub_f32(v9, *(float32x2_t *)a4.i8);
  v31 = vsub_f32(v29, *(float32x2_t *)a4.i8);
  v32 = fabsf(vmlas_n_f32((float)-v30.f32[1] * v31.f32[0], v31.f32[1], v30.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v31, v31))), 0.01));
  v33 = vmlas_n_f32(vmuls_lane_f32(v31.f32[1], v30, 1), v31.f32[0], v30.f32[0]);
  v34 = sqrtf(vaddv_f32(vmul_f32(v30, v30)));
  if (v33 >= 0.0)
    v34 = v32;
  v35 = vsub_f32(v9, v29);
  v36 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v31, v35).i32[1]), v31.f32[0], v35.f32[0]);
  v37 = sqrtf(vaddv_f32(vmul_f32(v35, v35)));
  if (v36 < 0.0)
    v37 = v34;
  v38 = fminf(v28, v37);
  v39 = (float32x2_t)vextq_s8(a5, a5, 8uLL).u64[0];
  v40 = vsub_f32(v9, *(float32x2_t *)a5.i8);
  v41 = vsub_f32(v39, *(float32x2_t *)a5.i8);
  v42 = fabsf(vmlas_n_f32((float)-v40.f32[1] * v41.f32[0], v41.f32[1], v40.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v41, v41))), 0.01));
  v43 = vmlas_n_f32(vmuls_lane_f32(v41.f32[1], v40, 1), v41.f32[0], v40.f32[0]);
  v44 = sqrtf(vaddv_f32(vmul_f32(v40, v40)));
  if (v43 < 0.0)
    v42 = v44;
  v45 = vsub_f32(v9, v39);
  v46 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v41, v45).i32[1]), v41.f32[0], v45.f32[0]);
  v47 = sqrtf(vaddv_f32(vmul_f32(v45, v45)));
  if (v46 < 0.0)
    v47 = v42;
  v48 = fminf(v38, v47);
  v49 = 1.0;
  if ((float)(v8 - v48) <= 1.0)
    v49 = v8 - v48;
  v50 = 0.0;
  if ((float)(v8 - v48) >= 0.0)
    v50 = v49;
  v51 = (v50 * -2.0 + 3.0) * v50 * v50;
  v52 = v48 - (v8 + -1.0);
  *(_QWORD *)&result = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v52 < 0.0)), 0x1FuLL)), a7, vandq_s8((int8x16_t)vmulq_n_f32((float32x4_t)a7, v51), (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16((float)(v48 - v8) < 0.0)), 0x1FuLL)))), a8).u64[0];
  return result;
}

void CI::f4_f4_f4_f4_f4_f_clr_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, float, __n128, float);
  int v11;
  uint64_t v12;
  const vec2 *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __n128 *v22;
  __n128 *v23;
  __n128 *v24;
  __n128 *v25;
  __int128 v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, float, __n128, float))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = (const vec2 *)*(unsigned int *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  v19 = *(_QWORD *)(v9 + 104);
  v20 = *(_QWORD *)(v9 + 128);
  v21 = *(_QWORD *)(v9 + 152);
  if (*(_BYTE *)(a1 + 64))
  {
    v30 = *(_QWORD *)(v9 + 104);
    v28 = *(_QWORD *)(v9 + 152);
    v29 = *(_DWORD *)(v9 + 40);
    v27 = *(_DWORD *)(v9 + 88);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 176)), v13);
    v17 = v27;
    LODWORD(v13) = v29;
    v21 = v28;
    v19 = v30;
  }
  v22 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v22 = (__n128 *)(a2 + (v18 << 6));
  v23 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v23 = (__n128 *)(a2 + (v16 << 6));
  v24 = (__n128 *)(a3 + 16 * v14);
  if ((_DWORD)v13 != 5)
    v24 = (__n128 *)(a2 + (v14 << 6));
  v25 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v25 = (__n128 *)(a2 + (v12 << 6));
  *(double *)&v26 = v10(*v25, *v24, *v23, *v22, *(float *)(a2 + (v19 << 6)), *(__n128 *)(a2 + (v20 << 6)), *(float *)(a2 + (v21 << 6)));
  *(_OWORD *)(a3 + 16 * a7) = v26;
}

double cikernel::_mesh8(CI *a1, int8x16_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, int8x16_t a6, int8x16_t a7, int8x16_t a8, int8x16_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float a17, uint64_t a18, float32x4_t a19, float a20)
{
  float v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float v25;
  float v26;
  float v27;
  float32x2_t v28;
  float v29;
  float v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float v34;
  float v35;
  float v36;
  float32x2_t v37;
  float v38;
  float v39;
  float v40;
  float32x2_t v41;
  float32x2_t v42;
  float32x2_t v43;
  float v44;
  float v45;
  float v46;
  float32x2_t v47;
  float v48;
  float v49;
  float v50;
  float32x2_t v51;
  float32x2_t v52;
  float32x2_t v53;
  float v54;
  float v55;
  float v56;
  float32x2_t v57;
  float v58;
  float v59;
  float v60;
  float32x2_t v61;
  float32x2_t v62;
  float32x2_t v63;
  float v64;
  float v65;
  float v66;
  float32x2_t v67;
  float v68;
  float v69;
  float v70;
  float32x2_t v71;
  float32x2_t v72;
  float32x2_t v73;
  float v74;
  float v75;
  float v76;
  float32x2_t v77;
  float v78;
  float v79;
  float v80;
  float32x2_t v81;
  float32x2_t v82;
  float32x2_t v83;
  float v84;
  float v85;
  float v86;
  float32x2_t v87;
  float v88;
  float v89;
  float v90;
  float32x2_t v91;
  float32x2_t v92;
  float32x2_t v93;
  float v94;
  float v95;
  float v96;
  float32x2_t v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  double result;

  v20 = a17 * 0.5;
  v21 = *(float32x2_t *)CI::getDC(a1);
  v22 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  v23 = vsub_f32(v21, *(float32x2_t *)a2.i8);
  v24 = vsub_f32(v22, *(float32x2_t *)a2.i8);
  v25 = fabsf(vmlas_n_f32((float)-v23.f32[1] * v24.f32[0], v24.f32[1], v23.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v24, v24))), 0.01));
  v26 = vmlas_n_f32(vmuls_lane_f32(v24.f32[1], v23, 1), v24.f32[0], v23.f32[0]);
  v27 = sqrtf(vaddv_f32(vmul_f32(v23, v23)));
  if (v26 >= 0.0)
    v27 = v25;
  v28 = vsub_f32(v21, v22);
  v29 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v24, v28).i32[1]), v24.f32[0], v28.f32[0]);
  v30 = sqrtf(vaddv_f32(vmul_f32(v28, v28)));
  if (v29 < 0.0)
    v30 = v27;
  v31 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  v32 = vsub_f32(v21, *(float32x2_t *)a3.i8);
  v33 = vsub_f32(v31, *(float32x2_t *)a3.i8);
  v34 = fabsf(vmlas_n_f32((float)-v32.f32[1] * v33.f32[0], v33.f32[1], v32.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v33, v33))), 0.01));
  v35 = vmlas_n_f32(vmuls_lane_f32(v33.f32[1], v32, 1), v33.f32[0], v32.f32[0]);
  v36 = sqrtf(vaddv_f32(vmul_f32(v32, v32)));
  if (v35 >= 0.0)
    v36 = v34;
  v37 = vsub_f32(v21, v31);
  v38 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v33, v37).i32[1]), v33.f32[0], v37.f32[0]);
  v39 = sqrtf(vaddv_f32(vmul_f32(v37, v37)));
  if (v38 < 0.0)
    v39 = v36;
  v40 = fminf(v30, v39);
  v41 = (float32x2_t)vextq_s8(a4, a4, 8uLL).u64[0];
  v42 = vsub_f32(v21, *(float32x2_t *)a4.i8);
  v43 = vsub_f32(v41, *(float32x2_t *)a4.i8);
  v44 = fabsf(vmlas_n_f32((float)-v42.f32[1] * v43.f32[0], v43.f32[1], v42.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v43, v43))), 0.01));
  v45 = vmlas_n_f32(vmuls_lane_f32(v43.f32[1], v42, 1), v43.f32[0], v42.f32[0]);
  v46 = sqrtf(vaddv_f32(vmul_f32(v42, v42)));
  if (v45 >= 0.0)
    v46 = v44;
  v47 = vsub_f32(v21, v41);
  v48 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v43, v47).i32[1]), v43.f32[0], v47.f32[0]);
  v49 = sqrtf(vaddv_f32(vmul_f32(v47, v47)));
  if (v48 < 0.0)
    v49 = v46;
  v50 = fminf(v40, v49);
  v51 = (float32x2_t)vextq_s8(a5, a5, 8uLL).u64[0];
  v52 = vsub_f32(v21, *(float32x2_t *)a5.i8);
  v53 = vsub_f32(v51, *(float32x2_t *)a5.i8);
  v54 = fabsf(vmlas_n_f32((float)-v52.f32[1] * v53.f32[0], v53.f32[1], v52.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v53, v53))), 0.01));
  v55 = vmlas_n_f32(vmuls_lane_f32(v53.f32[1], v52, 1), v53.f32[0], v52.f32[0]);
  v56 = sqrtf(vaddv_f32(vmul_f32(v52, v52)));
  if (v55 >= 0.0)
    v56 = v54;
  v57 = vsub_f32(v21, v51);
  v58 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v53, v57).i32[1]), v53.f32[0], v57.f32[0]);
  v59 = sqrtf(vaddv_f32(vmul_f32(v57, v57)));
  if (v58 < 0.0)
    v59 = v56;
  v60 = fminf(v50, v59);
  v61 = (float32x2_t)vextq_s8(a6, a6, 8uLL).u64[0];
  v62 = vsub_f32(v21, *(float32x2_t *)a6.i8);
  v63 = vsub_f32(v61, *(float32x2_t *)a6.i8);
  v64 = fabsf(vmlas_n_f32((float)-v62.f32[1] * v63.f32[0], v63.f32[1], v62.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v63, v63))), 0.01));
  v65 = vmlas_n_f32(vmuls_lane_f32(v63.f32[1], v62, 1), v63.f32[0], v62.f32[0]);
  v66 = sqrtf(vaddv_f32(vmul_f32(v62, v62)));
  if (v65 >= 0.0)
    v66 = v64;
  v67 = vsub_f32(v21, v61);
  v68 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v63, v67).i32[1]), v63.f32[0], v67.f32[0]);
  v69 = sqrtf(vaddv_f32(vmul_f32(v67, v67)));
  if (v68 < 0.0)
    v69 = v66;
  v70 = fminf(v60, v69);
  v71 = (float32x2_t)vextq_s8(a7, a7, 8uLL).u64[0];
  v72 = vsub_f32(v21, *(float32x2_t *)a7.i8);
  v73 = vsub_f32(v71, *(float32x2_t *)a7.i8);
  v74 = fabsf(vmlas_n_f32((float)-v72.f32[1] * v73.f32[0], v73.f32[1], v72.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v73, v73))), 0.01));
  v75 = vmlas_n_f32(vmuls_lane_f32(v73.f32[1], v72, 1), v73.f32[0], v72.f32[0]);
  v76 = sqrtf(vaddv_f32(vmul_f32(v72, v72)));
  if (v75 >= 0.0)
    v76 = v74;
  v77 = vsub_f32(v21, v71);
  v78 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v73, v77).i32[1]), v73.f32[0], v77.f32[0]);
  v79 = sqrtf(vaddv_f32(vmul_f32(v77, v77)));
  if (v78 < 0.0)
    v79 = v76;
  v80 = fminf(v70, v79);
  v81 = (float32x2_t)vextq_s8(a8, a8, 8uLL).u64[0];
  v82 = vsub_f32(v21, *(float32x2_t *)a8.i8);
  v83 = vsub_f32(v81, *(float32x2_t *)a8.i8);
  v84 = fabsf(vmlas_n_f32((float)-v82.f32[1] * v83.f32[0], v83.f32[1], v82.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v83, v83))), 0.01));
  v85 = vmlas_n_f32(vmuls_lane_f32(v83.f32[1], v82, 1), v83.f32[0], v82.f32[0]);
  v86 = sqrtf(vaddv_f32(vmul_f32(v82, v82)));
  if (v85 >= 0.0)
    v86 = v84;
  v87 = vsub_f32(v21, v81);
  v88 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v83, v87).i32[1]), v83.f32[0], v87.f32[0]);
  v89 = sqrtf(vaddv_f32(vmul_f32(v87, v87)));
  if (v88 < 0.0)
    v89 = v86;
  v90 = fminf(v80, v89);
  v91 = (float32x2_t)vextq_s8(a9, a9, 8uLL).u64[0];
  v92 = vsub_f32(v21, *(float32x2_t *)a9.i8);
  v93 = vsub_f32(v91, *(float32x2_t *)a9.i8);
  v94 = fabsf(vmlas_n_f32((float)-v92.f32[1] * v93.f32[0], v93.f32[1], v92.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v93, v93))), 0.01));
  v95 = vmlas_n_f32(vmuls_lane_f32(v93.f32[1], v92, 1), v93.f32[0], v92.f32[0]);
  v96 = sqrtf(vaddv_f32(vmul_f32(v92, v92)));
  if (v95 < 0.0)
    v94 = v96;
  v97 = vsub_f32(v21, v91);
  v98 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v93, v97).i32[1]), v93.f32[0], v97.f32[0]);
  v99 = sqrtf(vaddv_f32(vmul_f32(v97, v97)));
  if (v98 < 0.0)
    v99 = v94;
  v100 = fminf(v90, v99);
  v101 = 1.0;
  if ((float)(v20 - v100) <= 1.0)
    v101 = v20 - v100;
  v102 = 0.0;
  if ((float)(v20 - v100) >= 0.0)
    v102 = v101;
  v103 = (v102 * -2.0 + 3.0) * v102 * v102;
  v104 = v100 - (v20 + -1.0);
  *(_QWORD *)&result = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v104 < 0.0)), 0x1FuLL)), (int8x16_t)a19, vandq_s8((int8x16_t)vmulq_n_f32(a19, v103), (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16((float)(v100 - v20) < 0.0)), 0x1FuLL)))), a20).u64[0];
  return result;
}

void CI::f4_f4_f4_f4_f4_f4_f4_f4_f4_f_clr_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double);
  int v11;
  const vec2 *v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  __n128 *v29;
  __n128 *v30;
  __n128 *v31;
  __n128 *v32;
  __n128 *v33;
  __n128 *v34;
  __n128 *v35;
  __n128 *v36;
  __n128 *v37;
  __n128 *v38;
  __int128 v39;
  double v40;
  int v41;
  int v42;
  int v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  double (*v48)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double);
  int v49;
  const vec2 *v50;
  uint64_t v51;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(const vec2 **)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  v19 = *(_DWORD *)(v9 + 112);
  v20 = *(_QWORD *)(v9 + 104);
  v21 = *(_DWORD *)(v9 + 136);
  v22 = *(_QWORD *)(v9 + 128);
  v23 = *(_DWORD *)(v9 + 160);
  v24 = *(_QWORD *)(v9 + 152);
  v25 = *(_DWORD *)(v9 + 184);
  v26 = *(_QWORD *)(v9 + 176);
  v27 = *(_QWORD *)(v9 + 200);
  if (*(_BYTE *)(a1 + 64))
  {
    v48 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double))(a1 + 24);
    v50 = *(const vec2 **)(v9 + 8);
    v45 = *(_DWORD *)(v9 + 112);
    v28 = *(_DWORD *)(v9 + 40);
    v51 = *(_QWORD *)(v9 + 32);
    v42 = *(_DWORD *)(v9 + 160);
    v43 = *(_DWORD *)(v9 + 136);
    v49 = *(_DWORD *)(v9 + 64);
    v47 = *(_DWORD *)(v9 + 88);
    v46 = *(_QWORD *)(v9 + 80);
    v44 = *(_QWORD *)(v9 + 104);
    v41 = *(_DWORD *)(v9 + 184);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 272)), v12);
    v25 = v41;
    v23 = v42;
    v20 = v44;
    v18 = v46;
    v17 = v47;
    v15 = v49;
    v21 = v43;
    v12 = v50;
    v14 = v51;
    v13 = v28;
    v19 = v45;
    v10 = v48;
  }
  v29 = (__n128 *)(a3 + 16 * v26);
  if (v25 != 5)
    v29 = (__n128 *)(a2 + (v26 << 6));
  v30 = (__n128 *)(a3 + 16 * v24);
  if (v23 != 5)
    v30 = (__n128 *)(a2 + (v24 << 6));
  v31 = (__n128 *)(a3 + 16 * v22);
  if (v21 != 5)
    v31 = (__n128 *)(a2 + (v22 << 6));
  v32 = (__n128 *)(a3 + 16 * v20);
  v33 = (__n128 *)(a2 + (v20 << 6));
  if (v19 != 5)
    v32 = v33;
  v34 = (__n128 *)(a3 + 16 * v18);
  v35 = (__n128 *)(a2 + (v18 << 6));
  if (v17 != 5)
    v34 = v35;
  v36 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v36 = (__n128 *)(a2 + (v16 << 6));
  v37 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v37 = (__n128 *)(a2 + (v14 << 6));
  v38 = (__n128 *)(a3 + 16 * (_QWORD)v12);
  if (v11 != 5)
    v38 = (__n128 *)(a2 + ((_QWORD)v12 << 6));
  LODWORD(v40) = *(_DWORD *)(a2 + (v27 << 6));
  *(double *)&v39 = v10(*v38, *v37, *v36, *v34, *v32, *v31, *v30, *v29, v40);
  *(_OWORD *)(a3 + 16 * a7) = v39;
}

double cikernel::_mesh16(CI *a1, int8x16_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, int8x16_t a6, int8x16_t a7, int8x16_t a8, int8x16_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int8x16_t a17, int8x16_t a18, int8x16_t a19, int8x16_t a20,int8x16_t a21,int8x16_t a22,int8x16_t a23,int8x16_t a24,float a25,uint64_t a26,float32x4_t a27,float a28)
{
  float v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float v33;
  float v34;
  float v35;
  float32x2_t v36;
  float v37;
  float v38;
  float32x2_t v39;
  float32x2_t v40;
  float32x2_t v41;
  float v42;
  float v43;
  float v44;
  float32x2_t v45;
  float v46;
  float v47;
  float v48;
  float32x2_t v49;
  float32x2_t v50;
  float32x2_t v51;
  float v52;
  float v53;
  float v54;
  float32x2_t v55;
  float v56;
  float v57;
  float v58;
  float32x2_t v59;
  float32x2_t v60;
  float32x2_t v61;
  float v62;
  float v63;
  float v64;
  float32x2_t v65;
  float v66;
  float v67;
  float v68;
  float32x2_t v69;
  float32x2_t v70;
  float32x2_t v71;
  float v72;
  float v73;
  float v74;
  float32x2_t v75;
  float v76;
  float v77;
  float v78;
  float32x2_t v79;
  float32x2_t v80;
  float32x2_t v81;
  float v82;
  float v83;
  float v84;
  float32x2_t v85;
  float v86;
  float v87;
  float v88;
  float32x2_t v89;
  float32x2_t v90;
  float32x2_t v91;
  float v92;
  float v93;
  float v94;
  float32x2_t v95;
  float v96;
  float v97;
  float v98;
  float32x2_t v99;
  float32x2_t v100;
  float32x2_t v101;
  float v102;
  float v103;
  float v104;
  float32x2_t v105;
  float v106;
  float v107;
  float v108;
  float32x2_t v109;
  float32x2_t v110;
  float32x2_t v111;
  float v112;
  float v113;
  float v114;
  float32x2_t v115;
  float v116;
  float v117;
  float v118;
  float32x2_t v119;
  float32x2_t v120;
  float32x2_t v121;
  float v122;
  float v123;
  float v124;
  float32x2_t v125;
  float v126;
  float v127;
  float v128;
  float32x2_t v129;
  float32x2_t v130;
  float32x2_t v131;
  float v132;
  float v133;
  float v134;
  float32x2_t v135;
  float v136;
  float v137;
  float v138;
  float32x2_t v139;
  float32x2_t v140;
  float32x2_t v141;
  float v142;
  float v143;
  float v144;
  float32x2_t v145;
  float v146;
  float v147;
  float v148;
  float32x2_t v149;
  float32x2_t v150;
  float32x2_t v151;
  float v152;
  float v153;
  float v154;
  float32x2_t v155;
  float v156;
  float v157;
  float v158;
  float32x2_t v159;
  float32x2_t v160;
  float32x2_t v161;
  float v162;
  float v163;
  float v164;
  float32x2_t v165;
  float v166;
  float v167;
  float v168;
  float32x2_t v169;
  float32x2_t v170;
  float32x2_t v171;
  float v172;
  float v173;
  float v174;
  float32x2_t v175;
  float v176;
  float v177;
  float v178;
  float32x2_t v179;
  float32x2_t v180;
  float32x2_t v181;
  float v182;
  float v183;
  float v184;
  float32x2_t v185;
  float v186;
  float v187;
  float v188;
  float v189;
  float v190;
  float v191;
  float v192;
  double result;

  v28 = a25 * 0.5;
  v29 = *(float32x2_t *)CI::getDC(a1);
  v30 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  v31 = vsub_f32(v29, *(float32x2_t *)a2.i8);
  v32 = vsub_f32(v30, *(float32x2_t *)a2.i8);
  v33 = fabsf(vmlas_n_f32((float)-v31.f32[1] * v32.f32[0], v32.f32[1], v31.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v32, v32))), 0.01));
  v34 = vmlas_n_f32(vmuls_lane_f32(v32.f32[1], v31, 1), v32.f32[0], v31.f32[0]);
  v35 = sqrtf(vaddv_f32(vmul_f32(v31, v31)));
  if (v34 >= 0.0)
    v35 = v33;
  v36 = vsub_f32(v29, v30);
  v37 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v32, v36).i32[1]), v32.f32[0], v36.f32[0]);
  v38 = sqrtf(vaddv_f32(vmul_f32(v36, v36)));
  if (v37 < 0.0)
    v38 = v35;
  v39 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  v40 = vsub_f32(v29, *(float32x2_t *)a3.i8);
  v41 = vsub_f32(v39, *(float32x2_t *)a3.i8);
  v42 = fabsf(vmlas_n_f32((float)-v40.f32[1] * v41.f32[0], v41.f32[1], v40.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v41, v41))), 0.01));
  v43 = vmlas_n_f32(vmuls_lane_f32(v41.f32[1], v40, 1), v41.f32[0], v40.f32[0]);
  v44 = sqrtf(vaddv_f32(vmul_f32(v40, v40)));
  if (v43 >= 0.0)
    v44 = v42;
  v45 = vsub_f32(v29, v39);
  v46 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v41, v45).i32[1]), v41.f32[0], v45.f32[0]);
  v47 = sqrtf(vaddv_f32(vmul_f32(v45, v45)));
  if (v46 < 0.0)
    v47 = v44;
  v48 = fminf(v38, v47);
  v49 = (float32x2_t)vextq_s8(a4, a4, 8uLL).u64[0];
  v50 = vsub_f32(v29, *(float32x2_t *)a4.i8);
  v51 = vsub_f32(v49, *(float32x2_t *)a4.i8);
  v52 = fabsf(vmlas_n_f32((float)-v50.f32[1] * v51.f32[0], v51.f32[1], v50.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v51, v51))), 0.01));
  v53 = vmlas_n_f32(vmuls_lane_f32(v51.f32[1], v50, 1), v51.f32[0], v50.f32[0]);
  v54 = sqrtf(vaddv_f32(vmul_f32(v50, v50)));
  if (v53 >= 0.0)
    v54 = v52;
  v55 = vsub_f32(v29, v49);
  v56 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v51, v55).i32[1]), v51.f32[0], v55.f32[0]);
  v57 = sqrtf(vaddv_f32(vmul_f32(v55, v55)));
  if (v56 < 0.0)
    v57 = v54;
  v58 = fminf(v48, v57);
  v59 = (float32x2_t)vextq_s8(a5, a5, 8uLL).u64[0];
  v60 = vsub_f32(v29, *(float32x2_t *)a5.i8);
  v61 = vsub_f32(v59, *(float32x2_t *)a5.i8);
  v62 = fabsf(vmlas_n_f32((float)-v60.f32[1] * v61.f32[0], v61.f32[1], v60.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v61, v61))), 0.01));
  v63 = vmlas_n_f32(vmuls_lane_f32(v61.f32[1], v60, 1), v61.f32[0], v60.f32[0]);
  v64 = sqrtf(vaddv_f32(vmul_f32(v60, v60)));
  if (v63 >= 0.0)
    v64 = v62;
  v65 = vsub_f32(v29, v59);
  v66 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v61, v65).i32[1]), v61.f32[0], v65.f32[0]);
  v67 = sqrtf(vaddv_f32(vmul_f32(v65, v65)));
  if (v66 < 0.0)
    v67 = v64;
  v68 = fminf(v58, v67);
  v69 = (float32x2_t)vextq_s8(a6, a6, 8uLL).u64[0];
  v70 = vsub_f32(v29, *(float32x2_t *)a6.i8);
  v71 = vsub_f32(v69, *(float32x2_t *)a6.i8);
  v72 = fabsf(vmlas_n_f32((float)-v70.f32[1] * v71.f32[0], v71.f32[1], v70.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v71, v71))), 0.01));
  v73 = vmlas_n_f32(vmuls_lane_f32(v71.f32[1], v70, 1), v71.f32[0], v70.f32[0]);
  v74 = sqrtf(vaddv_f32(vmul_f32(v70, v70)));
  if (v73 >= 0.0)
    v74 = v72;
  v75 = vsub_f32(v29, v69);
  v76 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v71, v75).i32[1]), v71.f32[0], v75.f32[0]);
  v77 = sqrtf(vaddv_f32(vmul_f32(v75, v75)));
  if (v76 < 0.0)
    v77 = v74;
  v78 = fminf(v68, v77);
  v79 = (float32x2_t)vextq_s8(a7, a7, 8uLL).u64[0];
  v80 = vsub_f32(v29, *(float32x2_t *)a7.i8);
  v81 = vsub_f32(v79, *(float32x2_t *)a7.i8);
  v82 = fabsf(vmlas_n_f32((float)-v80.f32[1] * v81.f32[0], v81.f32[1], v80.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v81, v81))), 0.01));
  v83 = vmlas_n_f32(vmuls_lane_f32(v81.f32[1], v80, 1), v81.f32[0], v80.f32[0]);
  v84 = sqrtf(vaddv_f32(vmul_f32(v80, v80)));
  if (v83 >= 0.0)
    v84 = v82;
  v85 = vsub_f32(v29, v79);
  v86 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v81, v85).i32[1]), v81.f32[0], v85.f32[0]);
  v87 = sqrtf(vaddv_f32(vmul_f32(v85, v85)));
  if (v86 < 0.0)
    v87 = v84;
  v88 = fminf(v78, v87);
  v89 = (float32x2_t)vextq_s8(a8, a8, 8uLL).u64[0];
  v90 = vsub_f32(v29, *(float32x2_t *)a8.i8);
  v91 = vsub_f32(v89, *(float32x2_t *)a8.i8);
  v92 = fabsf(vmlas_n_f32((float)-v90.f32[1] * v91.f32[0], v91.f32[1], v90.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v91, v91))), 0.01));
  v93 = vmlas_n_f32(vmuls_lane_f32(v91.f32[1], v90, 1), v91.f32[0], v90.f32[0]);
  v94 = sqrtf(vaddv_f32(vmul_f32(v90, v90)));
  if (v93 >= 0.0)
    v94 = v92;
  v95 = vsub_f32(v29, v89);
  v96 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v91, v95).i32[1]), v91.f32[0], v95.f32[0]);
  v97 = sqrtf(vaddv_f32(vmul_f32(v95, v95)));
  if (v96 < 0.0)
    v97 = v94;
  v98 = fminf(v88, v97);
  v99 = (float32x2_t)vextq_s8(a9, a9, 8uLL).u64[0];
  v100 = vsub_f32(v29, *(float32x2_t *)a9.i8);
  v101 = vsub_f32(v99, *(float32x2_t *)a9.i8);
  v102 = fabsf(vmlas_n_f32((float)-v100.f32[1] * v101.f32[0], v101.f32[1], v100.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v101, v101))), 0.01));
  v103 = vmlas_n_f32(vmuls_lane_f32(v101.f32[1], v100, 1), v101.f32[0], v100.f32[0]);
  v104 = sqrtf(vaddv_f32(vmul_f32(v100, v100)));
  if (v103 >= 0.0)
    v104 = v102;
  v105 = vsub_f32(v29, v99);
  v106 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v101, v105).i32[1]), v101.f32[0], v105.f32[0]);
  v107 = sqrtf(vaddv_f32(vmul_f32(v105, v105)));
  if (v106 < 0.0)
    v107 = v104;
  v108 = fminf(v98, v107);
  v109 = (float32x2_t)vextq_s8(a17, a17, 8uLL).u64[0];
  v110 = vsub_f32(v29, *(float32x2_t *)a17.i8);
  v111 = vsub_f32(v109, *(float32x2_t *)a17.i8);
  v112 = fabsf(vmlas_n_f32((float)-v110.f32[1] * v111.f32[0], v111.f32[1], v110.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v111, v111))), 0.01));
  v113 = vmlas_n_f32(vmuls_lane_f32(v111.f32[1], v110, 1), v111.f32[0], v110.f32[0]);
  v114 = sqrtf(vaddv_f32(vmul_f32(v110, v110)));
  if (v113 >= 0.0)
    v114 = v112;
  v115 = vsub_f32(v29, v109);
  v116 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v111, v115).i32[1]), v111.f32[0], v115.f32[0]);
  v117 = sqrtf(vaddv_f32(vmul_f32(v115, v115)));
  if (v116 < 0.0)
    v117 = v114;
  v118 = fminf(v108, v117);
  v119 = (float32x2_t)vextq_s8(a18, a18, 8uLL).u64[0];
  v120 = vsub_f32(v29, *(float32x2_t *)a18.i8);
  v121 = vsub_f32(v119, *(float32x2_t *)a18.i8);
  v122 = fabsf(vmlas_n_f32((float)-v120.f32[1] * v121.f32[0], v121.f32[1], v120.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v121, v121))), 0.01));
  v123 = vmlas_n_f32(vmuls_lane_f32(v121.f32[1], v120, 1), v121.f32[0], v120.f32[0]);
  v124 = sqrtf(vaddv_f32(vmul_f32(v120, v120)));
  if (v123 >= 0.0)
    v124 = v122;
  v125 = vsub_f32(v29, v119);
  v126 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v121, v125).i32[1]), v121.f32[0], v125.f32[0]);
  v127 = sqrtf(vaddv_f32(vmul_f32(v125, v125)));
  if (v126 < 0.0)
    v127 = v124;
  v128 = fminf(v118, v127);
  v129 = (float32x2_t)vextq_s8(a19, a19, 8uLL).u64[0];
  v130 = vsub_f32(v29, *(float32x2_t *)a19.i8);
  v131 = vsub_f32(v129, *(float32x2_t *)a19.i8);
  v132 = fabsf(vmlas_n_f32((float)-v130.f32[1] * v131.f32[0], v131.f32[1], v130.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v131, v131))), 0.01));
  v133 = vmlas_n_f32(vmuls_lane_f32(v131.f32[1], v130, 1), v131.f32[0], v130.f32[0]);
  v134 = sqrtf(vaddv_f32(vmul_f32(v130, v130)));
  if (v133 >= 0.0)
    v134 = v132;
  v135 = vsub_f32(v29, v129);
  v136 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v131, v135).i32[1]), v131.f32[0], v135.f32[0]);
  v137 = sqrtf(vaddv_f32(vmul_f32(v135, v135)));
  if (v136 < 0.0)
    v137 = v134;
  v138 = fminf(v128, v137);
  v139 = (float32x2_t)vextq_s8(a20, a20, 8uLL).u64[0];
  v140 = vsub_f32(v29, *(float32x2_t *)a20.i8);
  v141 = vsub_f32(v139, *(float32x2_t *)a20.i8);
  v142 = fabsf(vmlas_n_f32((float)-v140.f32[1] * v141.f32[0], v141.f32[1], v140.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v141, v141))), 0.01));
  v143 = vmlas_n_f32(vmuls_lane_f32(v141.f32[1], v140, 1), v141.f32[0], v140.f32[0]);
  v144 = sqrtf(vaddv_f32(vmul_f32(v140, v140)));
  if (v143 >= 0.0)
    v144 = v142;
  v145 = vsub_f32(v29, v139);
  v146 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v141, v145).i32[1]), v141.f32[0], v145.f32[0]);
  v147 = sqrtf(vaddv_f32(vmul_f32(v145, v145)));
  if (v146 < 0.0)
    v147 = v144;
  v148 = fminf(v138, v147);
  v149 = (float32x2_t)vextq_s8(a21, a21, 8uLL).u64[0];
  v150 = vsub_f32(v29, *(float32x2_t *)a21.i8);
  v151 = vsub_f32(v149, *(float32x2_t *)a21.i8);
  v152 = fabsf(vmlas_n_f32((float)-v150.f32[1] * v151.f32[0], v151.f32[1], v150.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v151, v151))), 0.01));
  v153 = vmlas_n_f32(vmuls_lane_f32(v151.f32[1], v150, 1), v151.f32[0], v150.f32[0]);
  v154 = sqrtf(vaddv_f32(vmul_f32(v150, v150)));
  if (v153 >= 0.0)
    v154 = v152;
  v155 = vsub_f32(v29, v149);
  v156 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v151, v155).i32[1]), v151.f32[0], v155.f32[0]);
  v157 = sqrtf(vaddv_f32(vmul_f32(v155, v155)));
  if (v156 < 0.0)
    v157 = v154;
  v158 = fminf(v148, v157);
  v159 = (float32x2_t)vextq_s8(a22, a22, 8uLL).u64[0];
  v160 = vsub_f32(v29, *(float32x2_t *)a22.i8);
  v161 = vsub_f32(v159, *(float32x2_t *)a22.i8);
  v162 = fabsf(vmlas_n_f32((float)-v160.f32[1] * v161.f32[0], v161.f32[1], v160.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v161, v161))), 0.01));
  v163 = vmlas_n_f32(vmuls_lane_f32(v161.f32[1], v160, 1), v161.f32[0], v160.f32[0]);
  v164 = sqrtf(vaddv_f32(vmul_f32(v160, v160)));
  if (v163 >= 0.0)
    v164 = v162;
  v165 = vsub_f32(v29, v159);
  v166 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v161, v165).i32[1]), v161.f32[0], v165.f32[0]);
  v167 = sqrtf(vaddv_f32(vmul_f32(v165, v165)));
  if (v166 < 0.0)
    v167 = v164;
  v168 = fminf(v158, v167);
  v169 = (float32x2_t)vextq_s8(a23, a23, 8uLL).u64[0];
  v170 = vsub_f32(v29, *(float32x2_t *)a23.i8);
  v171 = vsub_f32(v169, *(float32x2_t *)a23.i8);
  v172 = fabsf(vmlas_n_f32((float)-v170.f32[1] * v171.f32[0], v171.f32[1], v170.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v171, v171))), 0.01));
  v173 = vmlas_n_f32(vmuls_lane_f32(v171.f32[1], v170, 1), v171.f32[0], v170.f32[0]);
  v174 = sqrtf(vaddv_f32(vmul_f32(v170, v170)));
  if (v173 >= 0.0)
    v174 = v172;
  v175 = vsub_f32(v29, v169);
  v176 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v171, v175).i32[1]), v171.f32[0], v175.f32[0]);
  v177 = sqrtf(vaddv_f32(vmul_f32(v175, v175)));
  if (v176 < 0.0)
    v177 = v174;
  v178 = fminf(v168, v177);
  v179 = (float32x2_t)vextq_s8(a24, a24, 8uLL).u64[0];
  v180 = vsub_f32(v29, *(float32x2_t *)a24.i8);
  v181 = vsub_f32(v179, *(float32x2_t *)a24.i8);
  v182 = fabsf(vmlas_n_f32((float)-v180.f32[1] * v181.f32[0], v181.f32[1], v180.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v181, v181))), 0.01));
  v183 = vmlas_n_f32(vmuls_lane_f32(v181.f32[1], v180, 1), v181.f32[0], v180.f32[0]);
  v184 = sqrtf(vaddv_f32(vmul_f32(v180, v180)));
  if (v183 < 0.0)
    v182 = v184;
  v185 = vsub_f32(v29, v179);
  v186 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v181, v185).i32[1]), v181.f32[0], v185.f32[0]);
  v187 = sqrtf(vaddv_f32(vmul_f32(v185, v185)));
  if (v186 < 0.0)
    v187 = v182;
  v188 = fminf(v178, v187);
  v189 = 1.0;
  if ((float)(v28 - v188) <= 1.0)
    v189 = v28 - v188;
  v190 = 0.0;
  if ((float)(v28 - v188) >= 0.0)
    v190 = v189;
  v191 = (v190 * -2.0 + 3.0) * v190 * v190;
  v192 = v188 - (v28 + -1.0);
  *(_QWORD *)&result = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v192 < 0.0)), 0x1FuLL)), (int8x16_t)a27, vandq_s8((int8x16_t)vmulq_n_f32(a27, v191), (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16((float)(v188 - v28) < 0.0)), 0x1FuLL)))), a28).u64[0];
  return result;
}

void CI::f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f_clr_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  const vec2 *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  double *v38;
  double *v39;
  double *v40;
  double *v41;
  double *v42;
  double *v43;
  double *v44;
  double *v45;
  double *v46;
  double *v47;
  __n128 *v48;
  __n128 *v49;
  __n128 *v50;
  __n128 *v51;
  __n128 *v52;
  __n128 *v53;
  __n128 *v54;
  __n128 *v55;
  __n128 *v56;
  __n128 *v57;
  __n128 *v58;
  __int128 v59;
  double v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  const vec2 *v69;
  uint64_t v70;
  double (*v71)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double);
  uint64_t v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  uint64_t v81;
  int v82;
  int v83;
  int v84;
  uint64_t v85;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  v19 = *(_QWORD *)(v9 + 104);
  v83 = *(_DWORD *)(v9 + 136);
  v84 = *(_DWORD *)(v9 + 112);
  v20 = *(const vec2 **)(v9 + 128);
  v82 = *(_DWORD *)(v9 + 160);
  v81 = *(_QWORD *)(v9 + 152);
  v21 = *(_QWORD *)(v9 + 176);
  v79 = *(_DWORD *)(v9 + 208);
  v80 = *(_DWORD *)(v9 + 184);
  v22 = *(_QWORD *)(v9 + 200);
  v78 = *(_DWORD *)(v9 + 232);
  v23 = *(_QWORD *)(v9 + 224);
  v24 = *(_DWORD *)(v9 + 256);
  v25 = *(_DWORD *)(v9 + 280);
  v76 = *(_QWORD *)(v9 + 272);
  v77 = *(_QWORD *)(v9 + 248);
  v26 = *(_DWORD *)(v9 + 304);
  v27 = *(unsigned __int8 *)(a1 + 64);
  v28 = *(_QWORD *)(v9 + 296);
  v29 = *(_DWORD *)(v9 + 328);
  v30 = *(_QWORD *)(v9 + 320);
  v31 = *(_DWORD *)(v9 + 352);
  v32 = *(_QWORD *)(v9 + 344);
  v33 = *(_DWORD *)(v9 + 376);
  v34 = *(_QWORD *)(v9 + 368);
  v85 = *(_QWORD *)(v9 + 392);
  if (v27)
  {
    v61 = *(_DWORD *)(v9 + 352);
    v71 = v10;
    v72 = *(_QWORD *)(v9 + 56);
    v74 = *(_QWORD *)(v9 + 32);
    v75 = *(_QWORD *)(v9 + 8);
    v73 = *(_DWORD *)(v9 + 16);
    v35 = *(_DWORD *)(v9 + 40);
    v36 = *(_DWORD *)(v9 + 64);
    v37 = *(_DWORD *)(v9 + 88);
    v70 = *(_QWORD *)(v9 + 104);
    v68 = *(_QWORD *)(v9 + 176);
    v69 = *(const vec2 **)(v9 + 128);
    v66 = *(_QWORD *)(v9 + 224);
    v67 = *(_QWORD *)(v9 + 200);
    v64 = *(_DWORD *)(v9 + 280);
    v65 = *(_DWORD *)(v9 + 256);
    v62 = *(_DWORD *)(v9 + 328);
    v63 = *(_DWORD *)(v9 + 304);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 464)), v20);
    v31 = v61;
    v29 = v62;
    v26 = v63;
    v25 = v64;
    v24 = v65;
    v23 = v66;
    v22 = v67;
    v21 = v68;
    v20 = v69;
    v19 = v70;
    v17 = v37;
    v15 = v36;
    v13 = v35;
    v14 = v74;
    v12 = v75;
    v11 = v73;
    v10 = v71;
    v16 = v72;
  }
  v38 = (double *)(a3 + 16 * v34);
  if (v33 != 5)
    v38 = (double *)(a2 + (v34 << 6));
  v39 = (double *)(a3 + 16 * v32);
  if (v31 != 5)
    v39 = (double *)(a2 + (v32 << 6));
  v40 = (double *)(a3 + 16 * v30);
  if (v29 != 5)
    v40 = (double *)(a2 + (v30 << 6));
  v41 = (double *)(a3 + 16 * v28);
  if (v26 != 5)
    v41 = (double *)(a2 + (v28 << 6));
  v42 = (double *)(a3 + 16 * v76);
  if (v25 != 5)
    v42 = (double *)(a2 + (v76 << 6));
  v43 = (double *)(a3 + 16 * v77);
  if (v24 != 5)
    v43 = (double *)(a2 + (v77 << 6));
  v44 = (double *)(a3 + 16 * v23);
  v45 = (double *)(a2 + (v23 << 6));
  if (v78 != 5)
    v44 = v45;
  v46 = (double *)(a3 + 16 * v22);
  v47 = (double *)(a2 + (v22 << 6));
  if (v79 != 5)
    v46 = v47;
  v48 = (__n128 *)(a3 + 16 * v21);
  v49 = (__n128 *)(a2 + (v21 << 6));
  if (v80 != 5)
    v48 = v49;
  v50 = (__n128 *)(a3 + 16 * v81);
  if (v82 != 5)
    v50 = (__n128 *)(a2 + (v81 << 6));
  v51 = (__n128 *)(a3 + 16 * (_QWORD)v20);
  v52 = (__n128 *)(a2 + ((_QWORD)v20 << 6));
  if (v83 != 5)
    v51 = v52;
  v53 = (__n128 *)(a3 + 16 * v19);
  v54 = (__n128 *)(a2 + (v19 << 6));
  if (v84 != 5)
    v53 = v54;
  v55 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v55 = (__n128 *)(a2 + (v18 << 6));
  v56 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v56 = (__n128 *)(a2 + (v16 << 6));
  v57 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v57 = (__n128 *)(a2 + (v14 << 6));
  v58 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v58 = (__n128 *)(a2 + (v12 << 6));
  LODWORD(v60) = *(_DWORD *)(a2 + (v85 << 6));
  *(double *)&v59 = v10(*v58, *v57, *v56, *v55, *v53, *v51, *v50, *v48, *v46, v46[1], *v44, v44[1], *v43, v43[1], *v42, v42[1], *v41, v41[1], *v40,
                      v40[1],
                      *v39,
                      v39[1],
                      *v38,
                      v38[1],
                      v60);
  *(_OWORD *)(a3 + 16 * a7) = v59;
}

double cikernel::_mesh32(CI *a1, int8x16_t a2, int8x16_t a3, int8x16_t a4, int8x16_t a5, int8x16_t a6, int8x16_t a7, int8x16_t a8, int8x16_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int8x16_t a17, int8x16_t a18, int8x16_t a19, int8x16_t a20,int8x16_t a21,int8x16_t a22,int8x16_t a23,int8x16_t a24,int8x16_t a25,int8x16_t a26,int8x16_t a27,int8x16_t a28,int8x16_t a29,int8x16_t a30,int8x16_t a31,int8x16_t a32,int8x16_t a33,int8x16_t a34,int8x16_t a35,int8x16_t a36,int8x16_t a37,int8x16_t a38,int8x16_t a39,int8x16_t a40,float a41,uint64_t a42,float32x4_t a43,float a44)
{
  float v44;
  float32x2_t v45;
  float32x2_t v46;
  float32x2_t v47;
  float32x2_t v48;
  float v49;
  float v50;
  float v51;
  float32x2_t v52;
  float v53;
  float v54;
  float32x2_t v55;
  float32x2_t v56;
  float32x2_t v57;
  float v58;
  float v59;
  float v60;
  float32x2_t v61;
  float v62;
  float v63;
  float v64;
  float32x2_t v65;
  float32x2_t v66;
  float32x2_t v67;
  float v68;
  float v69;
  float v70;
  float32x2_t v71;
  float v72;
  float v73;
  float v74;
  float32x2_t v75;
  float32x2_t v76;
  float32x2_t v77;
  float v78;
  float v79;
  float v80;
  float32x2_t v81;
  float v82;
  float v83;
  float v84;
  float32x2_t v85;
  float32x2_t v86;
  float32x2_t v87;
  float v88;
  float v89;
  float v90;
  float32x2_t v91;
  float v92;
  float v93;
  float v94;
  float32x2_t v95;
  float32x2_t v96;
  float32x2_t v97;
  float v98;
  float v99;
  float v100;
  float32x2_t v101;
  float v102;
  float v103;
  float v104;
  float32x2_t v105;
  float32x2_t v106;
  float32x2_t v107;
  float v108;
  float v109;
  float v110;
  float32x2_t v111;
  float v112;
  float v113;
  float v114;
  float32x2_t v115;
  float32x2_t v116;
  float32x2_t v117;
  float v118;
  float v119;
  float v120;
  float32x2_t v121;
  float v122;
  float v123;
  float v124;
  float32x2_t v125;
  float32x2_t v126;
  float32x2_t v127;
  float v128;
  float v129;
  float v130;
  float32x2_t v131;
  float v132;
  float v133;
  float v134;
  float32x2_t v135;
  float32x2_t v136;
  float32x2_t v137;
  float v138;
  float v139;
  float v140;
  float32x2_t v141;
  float v142;
  float v143;
  float v144;
  float32x2_t v145;
  float32x2_t v146;
  float32x2_t v147;
  float v148;
  float v149;
  float v150;
  float32x2_t v151;
  float v152;
  float v153;
  float v154;
  float32x2_t v155;
  float32x2_t v156;
  float32x2_t v157;
  float v158;
  float v159;
  float v160;
  float32x2_t v161;
  float v162;
  float v163;
  float v164;
  float32x2_t v165;
  float32x2_t v166;
  float32x2_t v167;
  float v168;
  float v169;
  float v170;
  float32x2_t v171;
  float v172;
  float v173;
  float v174;
  float32x2_t v175;
  float32x2_t v176;
  float32x2_t v177;
  float v178;
  float v179;
  float v180;
  float32x2_t v181;
  float v182;
  float v183;
  float v184;
  float32x2_t v185;
  float32x2_t v186;
  float32x2_t v187;
  float v188;
  float v189;
  float v190;
  float32x2_t v191;
  float v192;
  float v193;
  float v194;
  float32x2_t v195;
  float32x2_t v196;
  float32x2_t v197;
  float v198;
  float v199;
  float v200;
  float32x2_t v201;
  float v202;
  float v203;
  float v204;
  float32x2_t v205;
  float32x2_t v206;
  float32x2_t v207;
  float v208;
  float v209;
  float v210;
  float32x2_t v211;
  float v212;
  float v213;
  float v214;
  float32x2_t v215;
  float32x2_t v216;
  float32x2_t v217;
  float v218;
  float v219;
  float v220;
  float32x2_t v221;
  float v222;
  float v223;
  float v224;
  float32x2_t v225;
  float32x2_t v226;
  float32x2_t v227;
  float v228;
  float v229;
  float v230;
  float32x2_t v231;
  float v232;
  float v233;
  float v234;
  float32x2_t v235;
  float32x2_t v236;
  float32x2_t v237;
  float v238;
  float v239;
  float v240;
  float32x2_t v241;
  float v242;
  float v243;
  float v244;
  float32x2_t v245;
  float32x2_t v246;
  float32x2_t v247;
  float v248;
  float v249;
  float v250;
  float32x2_t v251;
  float v252;
  float v253;
  float v254;
  float32x2_t v255;
  float32x2_t v256;
  float32x2_t v257;
  float v258;
  float v259;
  float v260;
  float32x2_t v261;
  float v262;
  float v263;
  float v264;
  float32x2_t v265;
  float32x2_t v266;
  float32x2_t v267;
  float v268;
  float v269;
  float v270;
  float32x2_t v271;
  float v272;
  float v273;
  float v274;
  float32x2_t v275;
  float32x2_t v276;
  float32x2_t v277;
  float v278;
  float v279;
  float v280;
  float32x2_t v281;
  float v282;
  float v283;
  float v284;
  float32x2_t v285;
  float32x2_t v286;
  float32x2_t v287;
  float v288;
  float v289;
  float v290;
  float32x2_t v291;
  float v292;
  float v293;
  float v294;
  float32x2_t v295;
  float32x2_t v296;
  float32x2_t v297;
  float v298;
  float v299;
  float v300;
  float32x2_t v301;
  float v302;
  float v303;
  float v304;
  float32x2_t v305;
  float32x2_t v306;
  float32x2_t v307;
  float v308;
  float v309;
  float v310;
  float32x2_t v311;
  float v312;
  float v313;
  float v314;
  float32x2_t v315;
  float32x2_t v316;
  float32x2_t v317;
  float v318;
  float v319;
  float v320;
  float32x2_t v321;
  float v322;
  float v323;
  float v324;
  float32x2_t v325;
  float32x2_t v326;
  float32x2_t v327;
  float v328;
  float v329;
  float v330;
  float32x2_t v331;
  float v332;
  float v333;
  float v334;
  float32x2_t v335;
  float32x2_t v336;
  float32x2_t v337;
  float v338;
  float v339;
  float v340;
  float32x2_t v341;
  float v342;
  float v343;
  float v344;
  float32x2_t v345;
  float32x2_t v346;
  float32x2_t v347;
  BOOL v348;
  float v349;
  float v350;
  float32x2_t v351;
  float v352;
  float v353;
  float v354;
  float32x2_t v355;
  float32x2_t v356;
  float32x2_t v357;
  float v358;
  float v359;
  float v360;
  float32x2_t v361;
  float v362;
  float v363;
  float v364;
  float v365;
  float v366;
  double v367;
  float v368;
  int8x16_t v369;
  float v370;
  double result;

  v44 = a41 * 0.5;
  v45 = *(float32x2_t *)CI::getDC(a1);
  v46 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  v47 = vsub_f32(v45, *(float32x2_t *)a2.i8);
  v48 = vsub_f32(v46, *(float32x2_t *)a2.i8);
  v49 = vmlas_n_f32(vmuls_lane_f32(v48.f32[1], v47, 1), v48.f32[0], v47.f32[0]);
  v50 = fabsf(vmlas_n_f32((float)-v47.f32[1] * v48.f32[0], v48.f32[1], v47.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v48, v48))), 0.01));
  v51 = sqrtf(vaddv_f32(vmul_f32(v47, v47)));
  if (v49 >= 0.0)
    v51 = v50;
  v52 = vsub_f32(v45, v46);
  v53 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v48, v52).i32[1]), v48.f32[0], v52.f32[0]);
  v54 = sqrtf(vaddv_f32(vmul_f32(v52, v52)));
  if (v53 < 0.0)
    v54 = v51;
  v55 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  v56 = vsub_f32(v45, *(float32x2_t *)a3.i8);
  v57 = vsub_f32(v55, *(float32x2_t *)a3.i8);
  v58 = vmlas_n_f32(vmuls_lane_f32(v57.f32[1], v56, 1), v57.f32[0], v56.f32[0]);
  v59 = fabsf(vmlas_n_f32((float)-v56.f32[1] * v57.f32[0], v57.f32[1], v56.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v57, v57))), 0.01));
  v60 = sqrtf(vaddv_f32(vmul_f32(v56, v56)));
  if (v58 >= 0.0)
    v60 = v59;
  v61 = vsub_f32(v45, v55);
  v62 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v57, v61).i32[1]), v57.f32[0], v61.f32[0]);
  v63 = sqrtf(vaddv_f32(vmul_f32(v61, v61)));
  if (v62 < 0.0)
    v63 = v60;
  v64 = fminf(v54, v63);
  v65 = (float32x2_t)vextq_s8(a4, a4, 8uLL).u64[0];
  v66 = vsub_f32(v45, *(float32x2_t *)a4.i8);
  v67 = vsub_f32(v65, *(float32x2_t *)a4.i8);
  v68 = vmlas_n_f32(vmuls_lane_f32(v67.f32[1], v66, 1), v67.f32[0], v66.f32[0]);
  v69 = fabsf(vmlas_n_f32((float)-v66.f32[1] * v67.f32[0], v67.f32[1], v66.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v67, v67))), 0.01));
  v70 = sqrtf(vaddv_f32(vmul_f32(v66, v66)));
  if (v68 >= 0.0)
    v70 = v69;
  v71 = vsub_f32(v45, v65);
  v72 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v67, v71).i32[1]), v67.f32[0], v71.f32[0]);
  v73 = sqrtf(vaddv_f32(vmul_f32(v71, v71)));
  if (v72 < 0.0)
    v73 = v70;
  v74 = fminf(v64, v73);
  v75 = (float32x2_t)vextq_s8(a5, a5, 8uLL).u64[0];
  v76 = vsub_f32(v45, *(float32x2_t *)a5.i8);
  v77 = vsub_f32(v75, *(float32x2_t *)a5.i8);
  v78 = vmlas_n_f32(vmuls_lane_f32(v77.f32[1], v76, 1), v77.f32[0], v76.f32[0]);
  v79 = fabsf(vmlas_n_f32((float)-v76.f32[1] * v77.f32[0], v77.f32[1], v76.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v77, v77))), 0.01));
  v80 = sqrtf(vaddv_f32(vmul_f32(v76, v76)));
  if (v78 >= 0.0)
    v80 = v79;
  v81 = vsub_f32(v45, v75);
  v82 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v77, v81).i32[1]), v77.f32[0], v81.f32[0]);
  v83 = sqrtf(vaddv_f32(vmul_f32(v81, v81)));
  if (v82 < 0.0)
    v83 = v80;
  v84 = fminf(v74, v83);
  v85 = (float32x2_t)vextq_s8(a6, a6, 8uLL).u64[0];
  v86 = vsub_f32(v45, *(float32x2_t *)a6.i8);
  v87 = vsub_f32(v85, *(float32x2_t *)a6.i8);
  v88 = vmlas_n_f32(vmuls_lane_f32(v87.f32[1], v86, 1), v87.f32[0], v86.f32[0]);
  v89 = fabsf(vmlas_n_f32((float)-v86.f32[1] * v87.f32[0], v87.f32[1], v86.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v87, v87))), 0.01));
  v90 = sqrtf(vaddv_f32(vmul_f32(v86, v86)));
  if (v88 >= 0.0)
    v90 = v89;
  v91 = vsub_f32(v45, v85);
  v92 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v87, v91).i32[1]), v87.f32[0], v91.f32[0]);
  v93 = sqrtf(vaddv_f32(vmul_f32(v91, v91)));
  if (v92 < 0.0)
    v93 = v90;
  v94 = fminf(v84, v93);
  v95 = (float32x2_t)vextq_s8(a7, a7, 8uLL).u64[0];
  v96 = vsub_f32(v45, *(float32x2_t *)a7.i8);
  v97 = vsub_f32(v95, *(float32x2_t *)a7.i8);
  v98 = vmlas_n_f32(vmuls_lane_f32(v97.f32[1], v96, 1), v97.f32[0], v96.f32[0]);
  v99 = fabsf(vmlas_n_f32((float)-v96.f32[1] * v97.f32[0], v97.f32[1], v96.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v97, v97))), 0.01));
  v100 = sqrtf(vaddv_f32(vmul_f32(v96, v96)));
  if (v98 >= 0.0)
    v100 = v99;
  v101 = vsub_f32(v45, v95);
  v102 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v97, v101).i32[1]), v97.f32[0], v101.f32[0]);
  v103 = sqrtf(vaddv_f32(vmul_f32(v101, v101)));
  if (v102 < 0.0)
    v103 = v100;
  v104 = fminf(v94, v103);
  v105 = (float32x2_t)vextq_s8(a8, a8, 8uLL).u64[0];
  v106 = vsub_f32(v45, *(float32x2_t *)a8.i8);
  v107 = vsub_f32(v105, *(float32x2_t *)a8.i8);
  v108 = vmlas_n_f32(vmuls_lane_f32(v107.f32[1], v106, 1), v107.f32[0], v106.f32[0]);
  v109 = fabsf(vmlas_n_f32((float)-v106.f32[1] * v107.f32[0], v107.f32[1], v106.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v107, v107))), 0.01));
  v110 = sqrtf(vaddv_f32(vmul_f32(v106, v106)));
  if (v108 >= 0.0)
    v110 = v109;
  v111 = vsub_f32(v45, v105);
  v112 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v107, v111).i32[1]), v107.f32[0], v111.f32[0]);
  v113 = sqrtf(vaddv_f32(vmul_f32(v111, v111)));
  if (v112 < 0.0)
    v113 = v110;
  v114 = fminf(v104, v113);
  v115 = (float32x2_t)vextq_s8(a9, a9, 8uLL).u64[0];
  v116 = vsub_f32(v45, *(float32x2_t *)a9.i8);
  v117 = vsub_f32(v115, *(float32x2_t *)a9.i8);
  v118 = vmlas_n_f32(vmuls_lane_f32(v117.f32[1], v116, 1), v117.f32[0], v116.f32[0]);
  v119 = fabsf(vmlas_n_f32((float)-v116.f32[1] * v117.f32[0], v117.f32[1], v116.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v117, v117))), 0.01));
  v120 = sqrtf(vaddv_f32(vmul_f32(v116, v116)));
  if (v118 >= 0.0)
    v120 = v119;
  v121 = vsub_f32(v45, v115);
  v122 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v117, v121).i32[1]), v117.f32[0], v121.f32[0]);
  v123 = sqrtf(vaddv_f32(vmul_f32(v121, v121)));
  if (v122 < 0.0)
    v123 = v120;
  v124 = fminf(v114, v123);
  v125 = (float32x2_t)vextq_s8(a17, a17, 8uLL).u64[0];
  v126 = vsub_f32(v45, *(float32x2_t *)a17.i8);
  v127 = vsub_f32(v125, *(float32x2_t *)a17.i8);
  v128 = vmlas_n_f32(vmuls_lane_f32(v127.f32[1], v126, 1), v127.f32[0], v126.f32[0]);
  v129 = fabsf(vmlas_n_f32((float)-v126.f32[1] * v127.f32[0], v127.f32[1], v126.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v127, v127))), 0.01));
  v130 = sqrtf(vaddv_f32(vmul_f32(v126, v126)));
  if (v128 >= 0.0)
    v130 = v129;
  v131 = vsub_f32(v45, v125);
  v132 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v127, v131).i32[1]), v127.f32[0], v131.f32[0]);
  v133 = sqrtf(vaddv_f32(vmul_f32(v131, v131)));
  if (v132 < 0.0)
    v133 = v130;
  v134 = fminf(v124, v133);
  v135 = (float32x2_t)vextq_s8(a18, a18, 8uLL).u64[0];
  v136 = vsub_f32(v45, *(float32x2_t *)a18.i8);
  v137 = vsub_f32(v135, *(float32x2_t *)a18.i8);
  v138 = vmlas_n_f32(vmuls_lane_f32(v137.f32[1], v136, 1), v137.f32[0], v136.f32[0]);
  v139 = fabsf(vmlas_n_f32((float)-v136.f32[1] * v137.f32[0], v137.f32[1], v136.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v137, v137))), 0.01));
  v140 = sqrtf(vaddv_f32(vmul_f32(v136, v136)));
  if (v138 >= 0.0)
    v140 = v139;
  v141 = vsub_f32(v45, v135);
  v142 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v137, v141).i32[1]), v137.f32[0], v141.f32[0]);
  v143 = sqrtf(vaddv_f32(vmul_f32(v141, v141)));
  if (v142 < 0.0)
    v143 = v140;
  v144 = fminf(v134, v143);
  v145 = (float32x2_t)vextq_s8(a19, a19, 8uLL).u64[0];
  v146 = vsub_f32(v45, *(float32x2_t *)a19.i8);
  v147 = vsub_f32(v145, *(float32x2_t *)a19.i8);
  v148 = fabsf(vmlas_n_f32((float)-v146.f32[1] * v147.f32[0], v147.f32[1], v146.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v147, v147))), 0.01));
  v149 = vmlas_n_f32(vmuls_lane_f32(v147.f32[1], v146, 1), v147.f32[0], v146.f32[0]);
  v150 = sqrtf(vaddv_f32(vmul_f32(v146, v146)));
  if (v149 >= 0.0)
    v150 = v148;
  v151 = vsub_f32(v45, v145);
  v152 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v147, v151).i32[1]), v147.f32[0], v151.f32[0]);
  v153 = sqrtf(vaddv_f32(vmul_f32(v151, v151)));
  if (v152 < 0.0)
    v153 = v150;
  v154 = fminf(v144, v153);
  v155 = (float32x2_t)vextq_s8(a20, a20, 8uLL).u64[0];
  v156 = vsub_f32(v45, *(float32x2_t *)a20.i8);
  v157 = vsub_f32(v155, *(float32x2_t *)a20.i8);
  v158 = fabsf(vmlas_n_f32((float)-v156.f32[1] * v157.f32[0], v157.f32[1], v156.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v157, v157))), 0.01));
  v159 = vmlas_n_f32(vmuls_lane_f32(v157.f32[1], v156, 1), v157.f32[0], v156.f32[0]);
  v160 = sqrtf(vaddv_f32(vmul_f32(v156, v156)));
  if (v159 >= 0.0)
    v160 = v158;
  v161 = vsub_f32(v45, v155);
  v162 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v157, v161).i32[1]), v157.f32[0], v161.f32[0]);
  v163 = sqrtf(vaddv_f32(vmul_f32(v161, v161)));
  if (v162 < 0.0)
    v163 = v160;
  v164 = fminf(v154, v163);
  v165 = (float32x2_t)vextq_s8(a21, a21, 8uLL).u64[0];
  v166 = vsub_f32(v45, *(float32x2_t *)a21.i8);
  v167 = vsub_f32(v165, *(float32x2_t *)a21.i8);
  v168 = fabsf(vmlas_n_f32((float)-v166.f32[1] * v167.f32[0], v167.f32[1], v166.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v167, v167))), 0.01));
  v169 = vmlas_n_f32(vmuls_lane_f32(v167.f32[1], v166, 1), v167.f32[0], v166.f32[0]);
  v170 = sqrtf(vaddv_f32(vmul_f32(v166, v166)));
  if (v169 >= 0.0)
    v170 = v168;
  v171 = vsub_f32(v45, v165);
  v172 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v167, v171).i32[1]), v167.f32[0], v171.f32[0]);
  v173 = sqrtf(vaddv_f32(vmul_f32(v171, v171)));
  if (v172 < 0.0)
    v173 = v170;
  v174 = fminf(v164, v173);
  v175 = (float32x2_t)vextq_s8(a22, a22, 8uLL).u64[0];
  v176 = vsub_f32(v45, *(float32x2_t *)a22.i8);
  v177 = vsub_f32(v175, *(float32x2_t *)a22.i8);
  v178 = fabsf(vmlas_n_f32((float)-v176.f32[1] * v177.f32[0], v177.f32[1], v176.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v177, v177))), 0.01));
  v179 = vmlas_n_f32(vmuls_lane_f32(v177.f32[1], v176, 1), v177.f32[0], v176.f32[0]);
  v180 = sqrtf(vaddv_f32(vmul_f32(v176, v176)));
  if (v179 >= 0.0)
    v180 = v178;
  v181 = vsub_f32(v45, v175);
  v182 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v177, v181).i32[1]), v177.f32[0], v181.f32[0]);
  v183 = sqrtf(vaddv_f32(vmul_f32(v181, v181)));
  if (v182 < 0.0)
    v183 = v180;
  v184 = fminf(v174, v183);
  v185 = (float32x2_t)vextq_s8(a23, a23, 8uLL).u64[0];
  v186 = vsub_f32(v45, *(float32x2_t *)a23.i8);
  v187 = vsub_f32(v185, *(float32x2_t *)a23.i8);
  v188 = fabsf(vmlas_n_f32((float)-v186.f32[1] * v187.f32[0], v187.f32[1], v186.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v187, v187))), 0.01));
  v189 = vmlas_n_f32(vmuls_lane_f32(v187.f32[1], v186, 1), v187.f32[0], v186.f32[0]);
  v190 = sqrtf(vaddv_f32(vmul_f32(v186, v186)));
  if (v189 >= 0.0)
    v190 = v188;
  v191 = vsub_f32(v45, v185);
  v192 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v187, v191).i32[1]), v187.f32[0], v191.f32[0]);
  v193 = sqrtf(vaddv_f32(vmul_f32(v191, v191)));
  if (v192 < 0.0)
    v193 = v190;
  v194 = fminf(v184, v193);
  v195 = (float32x2_t)vextq_s8(a24, a24, 8uLL).u64[0];
  v196 = vsub_f32(v45, *(float32x2_t *)a24.i8);
  v197 = vsub_f32(v195, *(float32x2_t *)a24.i8);
  v198 = fabsf(vmlas_n_f32((float)-v196.f32[1] * v197.f32[0], v197.f32[1], v196.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v197, v197))), 0.01));
  v199 = vmlas_n_f32(vmuls_lane_f32(v197.f32[1], v196, 1), v197.f32[0], v196.f32[0]);
  v200 = sqrtf(vaddv_f32(vmul_f32(v196, v196)));
  if (v199 >= 0.0)
    v200 = v198;
  v201 = vsub_f32(v45, v195);
  v202 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v197, v201).i32[1]), v197.f32[0], v201.f32[0]);
  v203 = sqrtf(vaddv_f32(vmul_f32(v201, v201)));
  if (v202 < 0.0)
    v203 = v200;
  v204 = fminf(v194, v203);
  v205 = (float32x2_t)vextq_s8(a25, a25, 8uLL).u64[0];
  v206 = vsub_f32(v45, *(float32x2_t *)a25.i8);
  v207 = vsub_f32(v205, *(float32x2_t *)a25.i8);
  v208 = fabsf(vmlas_n_f32((float)-v206.f32[1] * v207.f32[0], v207.f32[1], v206.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v207, v207))), 0.01));
  v209 = vmlas_n_f32(vmuls_lane_f32(v207.f32[1], v206, 1), v207.f32[0], v206.f32[0]);
  v210 = sqrtf(vaddv_f32(vmul_f32(v206, v206)));
  if (v209 >= 0.0)
    v210 = v208;
  v211 = vsub_f32(v45, v205);
  v212 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v207, v211).i32[1]), v207.f32[0], v211.f32[0]);
  v213 = sqrtf(vaddv_f32(vmul_f32(v211, v211)));
  if (v212 < 0.0)
    v213 = v210;
  v214 = fminf(v204, v213);
  v215 = (float32x2_t)vextq_s8(a26, a26, 8uLL).u64[0];
  v216 = vsub_f32(v45, *(float32x2_t *)a26.i8);
  v217 = vsub_f32(v215, *(float32x2_t *)a26.i8);
  v218 = fabsf(vmlas_n_f32((float)-v216.f32[1] * v217.f32[0], v217.f32[1], v216.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v217, v217))), 0.01));
  v219 = vmlas_n_f32(vmuls_lane_f32(v217.f32[1], v216, 1), v217.f32[0], v216.f32[0]);
  v220 = sqrtf(vaddv_f32(vmul_f32(v216, v216)));
  if (v219 >= 0.0)
    v220 = v218;
  v221 = vsub_f32(v45, v215);
  v222 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v217, v221).i32[1]), v217.f32[0], v221.f32[0]);
  v223 = sqrtf(vaddv_f32(vmul_f32(v221, v221)));
  if (v222 < 0.0)
    v223 = v220;
  v224 = fminf(v214, v223);
  v225 = (float32x2_t)vextq_s8(a27, a27, 8uLL).u64[0];
  v226 = vsub_f32(v45, *(float32x2_t *)a27.i8);
  v227 = vsub_f32(v225, *(float32x2_t *)a27.i8);
  v228 = fabsf(vmlas_n_f32((float)-v226.f32[1] * v227.f32[0], v227.f32[1], v226.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v227, v227))), 0.01));
  v229 = vmlas_n_f32(vmuls_lane_f32(v227.f32[1], v226, 1), v227.f32[0], v226.f32[0]);
  v230 = sqrtf(vaddv_f32(vmul_f32(v226, v226)));
  if (v229 >= 0.0)
    v230 = v228;
  v231 = vsub_f32(v45, v225);
  v232 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v227, v231).i32[1]), v227.f32[0], v231.f32[0]);
  v233 = sqrtf(vaddv_f32(vmul_f32(v231, v231)));
  if (v232 < 0.0)
    v233 = v230;
  v234 = fminf(v224, v233);
  v235 = (float32x2_t)vextq_s8(a28, a28, 8uLL).u64[0];
  v236 = vsub_f32(v45, *(float32x2_t *)a28.i8);
  v237 = vsub_f32(v235, *(float32x2_t *)a28.i8);
  v238 = fabsf(vmlas_n_f32((float)-v236.f32[1] * v237.f32[0], v237.f32[1], v236.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v237, v237))), 0.01));
  v239 = vmlas_n_f32(vmuls_lane_f32(v237.f32[1], v236, 1), v237.f32[0], v236.f32[0]);
  v240 = sqrtf(vaddv_f32(vmul_f32(v236, v236)));
  if (v239 >= 0.0)
    v240 = v238;
  v241 = vsub_f32(v45, v235);
  v242 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v237, v241).i32[1]), v237.f32[0], v241.f32[0]);
  v243 = sqrtf(vaddv_f32(vmul_f32(v241, v241)));
  if (v242 < 0.0)
    v243 = v240;
  v244 = fminf(v234, v243);
  v245 = (float32x2_t)vextq_s8(a29, a29, 8uLL).u64[0];
  v246 = vsub_f32(v45, *(float32x2_t *)a29.i8);
  v247 = vsub_f32(v245, *(float32x2_t *)a29.i8);
  v248 = fabsf(vmlas_n_f32((float)-v246.f32[1] * v247.f32[0], v247.f32[1], v246.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v247, v247))), 0.01));
  v249 = vmlas_n_f32(vmuls_lane_f32(v247.f32[1], v246, 1), v247.f32[0], v246.f32[0]);
  v250 = sqrtf(vaddv_f32(vmul_f32(v246, v246)));
  if (v249 >= 0.0)
    v250 = v248;
  v251 = vsub_f32(v45, v245);
  v252 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v247, v251).i32[1]), v247.f32[0], v251.f32[0]);
  v253 = sqrtf(vaddv_f32(vmul_f32(v251, v251)));
  if (v252 < 0.0)
    v253 = v250;
  v254 = fminf(v244, v253);
  v255 = (float32x2_t)vextq_s8(a30, a30, 8uLL).u64[0];
  v256 = vsub_f32(v45, *(float32x2_t *)a30.i8);
  v257 = vsub_f32(v255, *(float32x2_t *)a30.i8);
  v258 = fabsf(vmlas_n_f32((float)-v256.f32[1] * v257.f32[0], v257.f32[1], v256.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v257, v257))), 0.01));
  v259 = vmlas_n_f32(vmuls_lane_f32(v257.f32[1], v256, 1), v257.f32[0], v256.f32[0]);
  v260 = sqrtf(vaddv_f32(vmul_f32(v256, v256)));
  if (v259 >= 0.0)
    v260 = v258;
  v261 = vsub_f32(v45, v255);
  v262 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v257, v261).i32[1]), v257.f32[0], v261.f32[0]);
  v263 = sqrtf(vaddv_f32(vmul_f32(v261, v261)));
  if (v262 < 0.0)
    v263 = v260;
  v264 = fminf(v254, v263);
  v265 = (float32x2_t)vextq_s8(a31, a31, 8uLL).u64[0];
  v266 = vsub_f32(v45, *(float32x2_t *)a31.i8);
  v267 = vsub_f32(v265, *(float32x2_t *)a31.i8);
  v268 = fabsf(vmlas_n_f32((float)-v266.f32[1] * v267.f32[0], v267.f32[1], v266.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v267, v267))), 0.01));
  v269 = vmlas_n_f32(vmuls_lane_f32(v267.f32[1], v266, 1), v267.f32[0], v266.f32[0]);
  v270 = sqrtf(vaddv_f32(vmul_f32(v266, v266)));
  if (v269 >= 0.0)
    v270 = v268;
  v271 = vsub_f32(v45, v265);
  v272 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v267, v271).i32[1]), v267.f32[0], v271.f32[0]);
  v273 = sqrtf(vaddv_f32(vmul_f32(v271, v271)));
  if (v272 < 0.0)
    v273 = v270;
  v274 = fminf(v264, v273);
  v275 = (float32x2_t)vextq_s8(a32, a32, 8uLL).u64[0];
  v276 = vsub_f32(v45, *(float32x2_t *)a32.i8);
  v277 = vsub_f32(v275, *(float32x2_t *)a32.i8);
  v278 = fabsf(vmlas_n_f32((float)-v276.f32[1] * v277.f32[0], v277.f32[1], v276.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v277, v277))), 0.01));
  v279 = vmlas_n_f32(vmuls_lane_f32(v277.f32[1], v276, 1), v277.f32[0], v276.f32[0]);
  v280 = sqrtf(vaddv_f32(vmul_f32(v276, v276)));
  if (v279 >= 0.0)
    v280 = v278;
  v281 = vsub_f32(v45, v275);
  v282 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v277, v281).i32[1]), v277.f32[0], v281.f32[0]);
  v283 = sqrtf(vaddv_f32(vmul_f32(v281, v281)));
  if (v282 < 0.0)
    v283 = v280;
  v284 = fminf(v274, v283);
  v285 = (float32x2_t)vextq_s8(a33, a33, 8uLL).u64[0];
  v286 = vsub_f32(v45, *(float32x2_t *)a33.i8);
  v287 = vsub_f32(v285, *(float32x2_t *)a33.i8);
  v288 = fabsf(vmlas_n_f32((float)-v286.f32[1] * v287.f32[0], v287.f32[1], v286.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v287, v287))), 0.01));
  v289 = vmlas_n_f32(vmuls_lane_f32(v287.f32[1], v286, 1), v287.f32[0], v286.f32[0]);
  v290 = sqrtf(vaddv_f32(vmul_f32(v286, v286)));
  if (v289 >= 0.0)
    v290 = v288;
  v291 = vsub_f32(v45, v285);
  v292 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v287, v291).i32[1]), v287.f32[0], v291.f32[0]);
  v293 = sqrtf(vaddv_f32(vmul_f32(v291, v291)));
  if (v292 < 0.0)
    v293 = v290;
  v294 = fminf(v284, v293);
  v295 = (float32x2_t)vextq_s8(a34, a34, 8uLL).u64[0];
  v296 = vsub_f32(v45, *(float32x2_t *)a34.i8);
  v297 = vsub_f32(v295, *(float32x2_t *)a34.i8);
  v298 = fabsf(vmlas_n_f32((float)-v296.f32[1] * v297.f32[0], v297.f32[1], v296.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v297, v297))), 0.01));
  v299 = vmlas_n_f32(vmuls_lane_f32(v297.f32[1], v296, 1), v297.f32[0], v296.f32[0]);
  v300 = sqrtf(vaddv_f32(vmul_f32(v296, v296)));
  if (v299 >= 0.0)
    v300 = v298;
  v301 = vsub_f32(v45, v295);
  v302 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v297, v301).i32[1]), v297.f32[0], v301.f32[0]);
  v303 = sqrtf(vaddv_f32(vmul_f32(v301, v301)));
  if (v302 < 0.0)
    v303 = v300;
  v304 = fminf(v294, v303);
  v305 = (float32x2_t)vextq_s8(a35, a35, 8uLL).u64[0];
  v306 = vsub_f32(v45, *(float32x2_t *)a35.i8);
  v307 = vsub_f32(v305, *(float32x2_t *)a35.i8);
  v308 = fabsf(vmlas_n_f32((float)-v306.f32[1] * v307.f32[0], v307.f32[1], v306.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v307, v307))), 0.01));
  v309 = vmlas_n_f32(vmuls_lane_f32(v307.f32[1], v306, 1), v307.f32[0], v306.f32[0]);
  v310 = sqrtf(vaddv_f32(vmul_f32(v306, v306)));
  if (v309 >= 0.0)
    v310 = v308;
  v311 = vsub_f32(v45, v305);
  v312 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v307, v311).i32[1]), v307.f32[0], v311.f32[0]);
  v313 = sqrtf(vaddv_f32(vmul_f32(v311, v311)));
  if (v312 < 0.0)
    v313 = v310;
  v314 = fminf(v304, v313);
  v315 = (float32x2_t)vextq_s8(a36, a36, 8uLL).u64[0];
  v316 = vsub_f32(v45, *(float32x2_t *)a36.i8);
  v317 = vsub_f32(v315, *(float32x2_t *)a36.i8);
  v318 = fabsf(vmlas_n_f32((float)-v316.f32[1] * v317.f32[0], v317.f32[1], v316.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v317, v317))), 0.01));
  v319 = vmlas_n_f32(vmuls_lane_f32(v317.f32[1], v316, 1), v317.f32[0], v316.f32[0]);
  v320 = sqrtf(vaddv_f32(vmul_f32(v316, v316)));
  if (v319 >= 0.0)
    v320 = v318;
  v321 = vsub_f32(v45, v315);
  v322 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v317, v321).i32[1]), v317.f32[0], v321.f32[0]);
  v323 = sqrtf(vaddv_f32(vmul_f32(v321, v321)));
  if (v322 < 0.0)
    v323 = v320;
  v324 = fminf(v314, v323);
  v325 = (float32x2_t)vextq_s8(a37, a37, 8uLL).u64[0];
  v326 = vsub_f32(v45, *(float32x2_t *)a37.i8);
  v327 = vsub_f32(v325, *(float32x2_t *)a37.i8);
  v328 = fabsf(vmlas_n_f32((float)-v326.f32[1] * v327.f32[0], v327.f32[1], v326.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v327, v327))), 0.01));
  v329 = vmlas_n_f32(vmuls_lane_f32(v327.f32[1], v326, 1), v327.f32[0], v326.f32[0]);
  v330 = sqrtf(vaddv_f32(vmul_f32(v326, v326)));
  if (v329 >= 0.0)
    v330 = v328;
  v331 = vsub_f32(v45, v325);
  v332 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v327, v331).i32[1]), v327.f32[0], v331.f32[0]);
  v333 = sqrtf(vaddv_f32(vmul_f32(v331, v331)));
  if (v332 < 0.0)
    v333 = v330;
  v334 = fminf(v324, v333);
  v335 = (float32x2_t)vextq_s8(a38, a38, 8uLL).u64[0];
  v336 = vsub_f32(v45, *(float32x2_t *)a38.i8);
  v337 = vsub_f32(v335, *(float32x2_t *)a38.i8);
  v338 = fabsf(vmlas_n_f32((float)-v336.f32[1] * v337.f32[0], v337.f32[1], v336.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v337, v337))), 0.01));
  v339 = vmlas_n_f32(vmuls_lane_f32(v337.f32[1], v336, 1), v337.f32[0], v336.f32[0]);
  v340 = sqrtf(vaddv_f32(vmul_f32(v336, v336)));
  if (v339 >= 0.0)
    v340 = v338;
  v341 = vsub_f32(v45, v335);
  v342 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v337, v341).i32[1]), v337.f32[0], v341.f32[0]);
  v343 = sqrtf(vaddv_f32(vmul_f32(v341, v341)));
  if (v342 < 0.0)
    v343 = v340;
  v344 = fminf(v334, v343);
  v345 = (float32x2_t)vextq_s8(a39, a39, 8uLL).u64[0];
  v346 = vsub_f32(v45, *(float32x2_t *)a39.i8);
  v347 = vsub_f32(v345, *(float32x2_t *)a39.i8);
  v348 = vmlas_n_f32(vmuls_lane_f32(v347.f32[1], v346, 1), v347.f32[0], v346.f32[0]) < 0.0;
  v349 = fabsf(vmlas_n_f32((float)-v346.f32[1] * v347.f32[0], v347.f32[1], v346.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v347, v347))), 0.01));
  v350 = sqrtf(vaddv_f32(vmul_f32(v346, v346)));
  if (!v348)
    v350 = v349;
  v351 = vsub_f32(v45, v345);
  v352 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v347, v351).i32[1]), v347.f32[0], v351.f32[0]);
  v353 = sqrtf(vaddv_f32(vmul_f32(v351, v351)));
  if (v352 < 0.0)
    v353 = v350;
  v354 = fminf(v344, v353);
  v355 = (float32x2_t)vextq_s8(a40, a40, 8uLL).u64[0];
  v356 = vsub_f32(v45, *(float32x2_t *)a40.i8);
  v357 = vsub_f32(v355, *(float32x2_t *)a40.i8);
  v358 = vmlas_n_f32(vmuls_lane_f32(v357.f32[1], v356, 1), v357.f32[0], v356.f32[0]);
  v359 = fabsf(vmlas_n_f32((float)-v356.f32[1] * v357.f32[0], v357.f32[1], v356.f32[0])/ fmaxf(sqrtf(vaddv_f32(vmul_f32(v357, v357))), 0.01));
  v360 = sqrtf(vaddv_f32(vmul_f32(v356, v356)));
  if (v358 < 0.0)
    v359 = v360;
  v361 = vsub_f32(v45, v355);
  v362 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v357, v361).i32[1]), v357.f32[0], v361.f32[0]);
  v363 = sqrtf(vaddv_f32(vmul_f32(v361, v361)));
  if (v362 < 0.0)
    v363 = v359;
  v364 = fminf(v354, v363);
  v365 = 1.0;
  if ((float)(v44 - v364) <= 1.0)
    v365 = v44 - v364;
  v366 = 0.0;
  if ((float)(v44 - v364) >= 0.0)
    v366 = v365;
  v367 = v364 - (v44 + -1.0);
  v368 = (v366 * -2.0 + 3.0) * v366 * v366;
  v369 = vandq_s8((int8x16_t)vmulq_n_f32(a43, v368), (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16((float)(v364 - v44) < 0.0)), 0x1FuLL)));
  v370 = v367;
  *(_QWORD *)&result = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v370 < 0.0)), 0x1FuLL)), (int8x16_t)a43, v369), a44).u64[0];
  return result;
}

void CI::f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f4_f_clr_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  const vec2 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  __int128 *v35;
  __int128 *v36;
  __int128 *v37;
  __int128 *v38;
  __int128 *v39;
  __int128 *v40;
  double *v41;
  double *v42;
  double *v43;
  double *v44;
  double *v45;
  double *v46;
  double *v47;
  double *v48;
  double *v49;
  double *v50;
  double *v51;
  double *v52;
  double *v53;
  double *v54;
  double *v55;
  double *v56;
  double *v57;
  double *v58;
  double *v59;
  double *v60;
  double *v61;
  double *v62;
  double *v63;
  double *v64;
  double *v65;
  __n128 *v66;
  __n128 *v67;
  __n128 *v68;
  __n128 *v69;
  __n128 *v70;
  __n128 *v71;
  __n128 *v72;
  __n128 *v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  double v81;
  int v82;
  int v83;
  int v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  const vec2 *v90;
  uint64_t v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  int v106;
  uint64_t v107;
  uint64_t v108;
  __int128 *v109;
  int v110;
  __int128 *v111;
  int v112;
  int v113;
  __int128 *v114;
  uint64_t v115;
  int v116;
  int v117;
  __int128 *v118;
  uint64_t v119;
  int v120;
  int v121;
  __int128 *v122;
  __int128 *v123;
  uint64_t v124;
  int v125;
  uint64_t v126;
  uint64_t v127;
  int v128;
  uint64_t v129;
  int v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  uint64_t v134;
  int v135;
  uint64_t v136;
  int v137;
  uint64_t v138;
  int v139;
  uint64_t v140;
  int v141;
  uint64_t v142;
  int v143;
  double (*v144)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double);

  v9 = *(_QWORD *)(a1 + 48);
  v144 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double))(a1 + 24);
  v143 = *(_DWORD *)(v9 + 16);
  v142 = *(_QWORD *)(v9 + 8);
  v141 = *(_DWORD *)(v9 + 40);
  v140 = *(_QWORD *)(v9 + 32);
  v139 = *(_DWORD *)(v9 + 64);
  v138 = *(_QWORD *)(v9 + 56);
  v137 = *(_DWORD *)(v9 + 88);
  v136 = *(_QWORD *)(v9 + 80);
  v135 = *(_DWORD *)(v9 + 112);
  v134 = *(_QWORD *)(v9 + 104);
  v133 = *(_DWORD *)(v9 + 136);
  v132 = *(_QWORD *)(v9 + 128);
  v10 = *(_DWORD *)(v9 + 160);
  v131 = *(_QWORD *)(v9 + 152);
  v130 = *(_DWORD *)(v9 + 184);
  v129 = *(_QWORD *)(v9 + 176);
  v128 = *(_DWORD *)(v9 + 208);
  v127 = *(_QWORD *)(v9 + 200);
  v125 = *(_DWORD *)(v9 + 232);
  v124 = *(_QWORD *)(v9 + 224);
  v120 = *(_DWORD *)(v9 + 256);
  v119 = *(_QWORD *)(v9 + 248);
  v116 = *(_DWORD *)(v9 + 280);
  v115 = *(_QWORD *)(v9 + 272);
  v112 = *(_DWORD *)(v9 + 304);
  v11 = *(unsigned __int8 *)(a1 + 64);
  v107 = *(_QWORD *)(v9 + 296);
  v106 = *(_DWORD *)(v9 + 328);
  v105 = *(_QWORD *)(v9 + 320);
  v104 = *(_DWORD *)(v9 + 352);
  v103 = *(_QWORD *)(v9 + 344);
  v12 = *(_DWORD *)(v9 + 376);
  v102 = *(_QWORD *)(v9 + 368);
  v13 = *(_DWORD *)(v9 + 400);
  v101 = *(_QWORD *)(v9 + 392);
  v14 = *(_DWORD *)(v9 + 424);
  v100 = *(_QWORD *)(v9 + 416);
  v15 = *(_DWORD *)(v9 + 448);
  v99 = *(_QWORD *)(v9 + 440);
  v98 = *(_DWORD *)(v9 + 472);
  v16 = *(_QWORD *)(v9 + 464);
  v97 = *(_DWORD *)(v9 + 496);
  v17 = *(_QWORD *)(v9 + 488);
  v96 = *(_DWORD *)(v9 + 520);
  v18 = *(const vec2 **)(v9 + 512);
  v95 = *(_DWORD *)(v9 + 544);
  v19 = *(_QWORD *)(v9 + 536);
  v94 = *(_DWORD *)(v9 + 568);
  v20 = *(_QWORD *)(v9 + 560);
  v93 = *(_DWORD *)(v9 + 592);
  v21 = *(_QWORD *)(v9 + 584);
  v92 = *(_DWORD *)(v9 + 616);
  v22 = *(_QWORD *)(v9 + 608);
  v23 = *(_DWORD *)(v9 + 640);
  v24 = *(_QWORD *)(v9 + 632);
  v25 = *(_DWORD *)(v9 + 664);
  v26 = *(_QWORD *)(v9 + 656);
  v27 = *(_DWORD *)(v9 + 688);
  v28 = *(_QWORD *)(v9 + 680);
  v29 = *(_DWORD *)(v9 + 712);
  v30 = *(_QWORD *)(v9 + 704);
  v31 = *(_DWORD *)(v9 + 736);
  v32 = *(_QWORD *)(v9 + 728);
  v33 = *(_DWORD *)(v9 + 760);
  v34 = *(_QWORD *)(v9 + 752);
  v126 = *(_QWORD *)(v9 + 776);
  if (v11)
  {
    v89 = *(_QWORD *)(v9 + 536);
    v90 = *(const vec2 **)(v9 + 512);
    v121 = *(_DWORD *)(v9 + 376);
    v117 = *(_DWORD *)(v9 + 400);
    v113 = *(_DWORD *)(v9 + 424);
    v110 = *(_DWORD *)(v9 + 448);
    v108 = *(_QWORD *)(v9 + 464);
    v91 = *(_QWORD *)(v9 + 488);
    v87 = *(_QWORD *)(v9 + 584);
    v88 = *(_QWORD *)(v9 + 560);
    v86 = *(_QWORD *)(v9 + 608);
    v85 = *(_DWORD *)(v9 + 640);
    v84 = *(_DWORD *)(v9 + 664);
    v83 = *(_DWORD *)(v9 + 688);
    v82 = *(_DWORD *)(v9 + 712);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 848)), v18);
    v29 = v82;
    v27 = v83;
    v25 = v84;
    v23 = v85;
    v22 = v86;
    v21 = v87;
    v20 = v88;
    v19 = v89;
    v18 = v90;
    v17 = v91;
    v16 = v108;
    v15 = v110;
    v14 = v113;
    v13 = v117;
    v12 = v121;
  }
  v35 = (__int128 *)(a3 + 16 * v34);
  if (v33 != 5)
    v35 = (__int128 *)(a2 + (v34 << 6));
  v123 = v35;
  if (v31 == 5)
    v36 = (__int128 *)(a3 + 16 * v32);
  else
    v36 = (__int128 *)(a2 + (v32 << 6));
  v122 = v36;
  if (v29 == 5)
    v37 = (__int128 *)(a3 + 16 * v30);
  else
    v37 = (__int128 *)(a2 + (v30 << 6));
  v118 = v37;
  if (v27 == 5)
    v38 = (__int128 *)(a3 + 16 * v28);
  else
    v38 = (__int128 *)(a2 + (v28 << 6));
  v114 = v38;
  if (v25 == 5)
    v39 = (__int128 *)(a3 + 16 * v26);
  else
    v39 = (__int128 *)(a2 + (v26 << 6));
  v111 = v39;
  if (v23 == 5)
    v40 = (__int128 *)(a3 + 16 * v24);
  else
    v40 = (__int128 *)(a2 + (v24 << 6));
  v109 = v40;
  v41 = (double *)(a3 + 16 * v22);
  v42 = (double *)(a2 + (v22 << 6));
  if (v92 != 5)
    v41 = v42;
  v43 = (double *)(a3 + 16 * v21);
  v44 = (double *)(a2 + (v21 << 6));
  if (v93 != 5)
    v43 = v44;
  v45 = (double *)(a3 + 16 * v20);
  v46 = (double *)(a2 + (v20 << 6));
  if (v94 != 5)
    v45 = v46;
  v47 = (double *)(a3 + 16 * v19);
  v48 = (double *)(a2 + (v19 << 6));
  if (v95 != 5)
    v47 = v48;
  v49 = (double *)(a3 + 16 * (_QWORD)v18);
  v50 = (double *)(a2 + ((_QWORD)v18 << 6));
  if (v96 != 5)
    v49 = v50;
  v51 = (double *)(a3 + 16 * v17);
  v52 = (double *)(a2 + (v17 << 6));
  if (v97 != 5)
    v51 = v52;
  v53 = (double *)(a3 + 16 * v16);
  v54 = (double *)(a2 + (v16 << 6));
  if (v98 != 5)
    v53 = v54;
  v55 = (double *)(a3 + 16 * v99);
  if (v15 != 5)
    v55 = (double *)(a2 + (v99 << 6));
  v56 = (double *)(a3 + 16 * v100);
  if (v14 != 5)
    v56 = (double *)(a2 + (v100 << 6));
  v57 = (double *)(a3 + 16 * v101);
  if (v13 != 5)
    v57 = (double *)(a2 + (v101 << 6));
  v58 = (double *)(a3 + 16 * v102);
  if (v12 != 5)
    v58 = (double *)(a2 + (v102 << 6));
  v59 = (double *)(a3 + 16 * v103);
  if (v104 != 5)
    v59 = (double *)(a2 + (v103 << 6));
  v60 = (double *)(a3 + 16 * v105);
  if (v106 != 5)
    v60 = (double *)(a2 + (v105 << 6));
  v61 = (double *)(a3 + 16 * v107);
  if (v112 != 5)
    v61 = (double *)(a2 + (v107 << 6));
  v62 = (double *)(a3 + 16 * v115);
  if (v116 != 5)
    v62 = (double *)(a2 + (v115 << 6));
  v63 = (double *)(a3 + 16 * v119);
  if (v120 != 5)
    v63 = (double *)(a2 + (v119 << 6));
  v64 = (double *)(a3 + 16 * v124);
  if (v125 != 5)
    v64 = (double *)(a2 + (v124 << 6));
  v65 = (double *)(a3 + 16 * v127);
  if (v128 != 5)
    v65 = (double *)(a2 + (v127 << 6));
  v66 = (__n128 *)(a3 + 16 * v129);
  if (v130 != 5)
    v66 = (__n128 *)(a2 + (v129 << 6));
  v67 = (__n128 *)(a3 + 16 * v131);
  if (v10 != 5)
    v67 = (__n128 *)(a2 + (v131 << 6));
  v68 = (__n128 *)(a2 + (v132 << 6));
  if (v133 == 5)
    v68 = (__n128 *)(a3 + 16 * v132);
  v69 = (__n128 *)(a2 + (v134 << 6));
  if (v135 == 5)
    v69 = (__n128 *)(a3 + 16 * v134);
  v70 = (__n128 *)(a2 + (v136 << 6));
  if (v137 == 5)
    v70 = (__n128 *)(a3 + 16 * v136);
  v71 = (__n128 *)(a2 + (v138 << 6));
  if (v139 == 5)
    v71 = (__n128 *)(a3 + 16 * v138);
  v72 = (__n128 *)(a2 + (v140 << 6));
  if (v141 == 5)
    v72 = (__n128 *)(a3 + 16 * v140);
  v73 = (__n128 *)(a2 + (v142 << 6));
  if (v143 == 5)
    v73 = (__n128 *)(a3 + 16 * v142);
  LODWORD(v81) = *(_DWORD *)(a2 + (v126 << 6));
  v79 = *v122;
  v80 = *v123;
  v77 = *v114;
  v78 = *v118;
  v75 = *v109;
  v76 = *v111;
  *(double *)&v74 = v144(*v73, *v72, *v71, *v70, *v69, *v68, *v67, *v66, *v65, v65[1], *v64, v64[1], *v63, v63[1], *v62, v62[1], *v61, v61[1], *v60,
                      v60[1],
                      *v59,
                      v59[1],
                      *v58,
                      v58[1],
                      *v57,
                      v57[1],
                      *v56,
                      v56[1],
                      *v55,
                      v55[1],
                      *v53,
                      v53[1],
                      *v51,
                      v51[1],
                      *v49,
                      v49[1],
                      *v47,
                      v47[1],
                      *v45,
                      v45[1],
                      *v43,
                      v43[1],
                      *v41,
                      v41[1],
                      *(double *)&v75,
                      *((double *)&v75 + 1),
                      *(double *)&v76,
                      *((double *)&v76 + 1),
                      *(double *)&v77,
                      *((double *)&v77 + 1),
                      *(double *)&v78,
                      *((double *)&v78 + 1),
                      *(double *)&v79,
                      *((double *)&v79 + 1),
                      *(double *)&v80,
                      *((double *)&v80 + 1),
                      v81);
  *(_OWORD *)(a3 + 16 * a7) = v74;
}

objc_object *metaFilterForFilter(uint64_t a1, objc_object *a2)
{
  NSString *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  objc_class *ClassPair;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  objc_ivar *InstanceVariable;
  char *TypeEncoding;
  objc_ivar *v16;
  const char *v17;
  objc_class *Class;
  std::string *p_p;
  unsigned int v20;
  std::string *p_name;
  const char *v22;
  size_t size;
  std::string *v24;
  _BYTE *v25;
  uint64_t v26;
  _BYTE *v27;
  uint64_t v28;
  _BYTE *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  _BOOL4 v33;
  _BOOL4 v34;
  objc_method *InstanceMethod;
  const char *v36;
  _BOOL4 v37;
  objc_method *v38;
  const char *v39;
  _BOOL4 v40;
  objc_object *v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t i;
  NSString *v46;
  objc_object *v47;
  objc_class *superclass;
  uint64_t v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  std::string __p;
  std::string v60;
  std::string name;
  char v62;
  _BYTE v63[128];
  _BYTE v64[128];
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  if (metaFilterForFilter::onceToken != -1)
    dispatch_once(&metaFilterForFilter::onceToken, &__block_literal_global_50);
  superclass = (objc_class *)objc_opt_class();
  v3 = -[NSString stringByAppendingString:](NSStringFromClass(superclass), "stringByAppendingString:", CFSTR("_wrapper"));
  v4 = (void *)wrappedClassDict;
  objc_sync_enter((id)wrappedClassDict);
  v5 = objc_msgSend(MEMORY[0x1E0CB3B18], "valueWithPointer:", objc_opt_class());
  v6 = (void *)objc_msgSend((id)wrappedClassDict, "objectForKeyedSubscript:", v5);
  if (v6)
  {
    ClassPair = (objc_class *)objc_msgSend(v6, "pointerValue");
    if (ClassPair)
    {
      objc_sync_exit(v4);
      goto LABEL_63;
    }
  }
  ClassPair = objc_allocateClassPair(superclass, -[NSString UTF8String](v3, "UTF8String"), 0x100uLL);
  v8 = objc_msgSend(MEMORY[0x1E0CB3B18], "valueWithPointer:", ClassPair);
  objc_msgSend((id)wrappedClassDict, "setObject:forKeyedSubscript:", v8, v5);
  objc_sync_exit(v4);
  v55 = 0u;
  v56 = 0u;
  v57 = 0u;
  v58 = 0u;
  v9 = (void *)-[objc_object inputKeys](a2, "inputKeys");
  v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v55, v64, 16);
  if (v10)
  {
    v11 = *(_QWORD *)v56;
    do
    {
      v12 = 0;
      do
      {
        if (*(_QWORD *)v56 != v11)
          objc_enumerationMutation(v9);
        v13 = *(void **)(*((_QWORD *)&v55 + 1) + 8 * v12);
        InstanceVariable = object_getInstanceVariable(a2, (const char *)objc_msgSend(v13, "UTF8String"), 0);
        if (!InstanceVariable)
        {
          NSLog(CFSTR("ivar is nil for key %@"), v13);
          goto LABEL_30;
        }
        TypeEncoding = (char *)ivar_getTypeEncoding(InstanceVariable);
        v16 = class_getInstanceVariable(ClassPair, (const char *)objc_msgSend(v13, "UTF8String"));
        if (v16)
        {
          v17 = ivar_getTypeEncoding(v16);
          if (v17 && strcmp(TypeEncoding, v17))
            NSLog(CFSTR("Not adding new key to class because types are inconsistent (%s & %s)"), TypeEncoding, v17);
          goto LABEL_30;
        }
        std::string::basic_string[abi:nn180100]<0>(&__p, TypeEncoding);
        Class = 0;
        *(_OWORD *)&name.__r_.__value_.__r.__words[1] = 0uLL;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = &__p;
        else
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        v20 = p_p->__r_.__value_.__s.__data_[0] - 64;
        if (v20 <= 0x33)
        {
          if (((1 << v20) & 0xA1258000A120CLL) != 0)
          {
            *((_BYTE *)&name.__r_.__value_.__s + 23) = 8;
            name.__r_.__value_.__r.__words[0] = 0x7265626D754E534ELL;
            p_name = &name;
            goto LABEL_23;
          }
          if (p_p->__r_.__value_.__s.__data_[0] == 64)
          {
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
            else
              size = __p.__r_.__value_.__l.__size_;
            if (size < 2)
            {
              v26 = -1;
            }
            else
            {
              v24 = &__p;
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                v24 = (std::string *)__p.__r_.__value_.__r.__words[0];
              v25 = memchr((char *)&v24->__r_.__value_.__l.__data_ + 1, 34, size - 1);
              if (v25)
                v26 = v25 - (_BYTE *)p_p;
              else
                v26 = -1;
            }
            if (size <= v26 + 1)
            {
              v28 = -1;
              if (size)
                goto LABEL_48;
              v50 = -1;
LABEL_52:
              v30 = v50;
            }
            else
            {
              v27 = memchr((char *)&p_p->__r_.__value_.__l.__data_ + v26 + 1, 34, size - (v26 + 1));
              v28 = v27 - (_BYTE *)p_p;
              if (!v27)
                v28 = -1;
LABEL_48:
              v50 = v28;
              v29 = memchr(p_p, 60, size);
              if (!v29)
                goto LABEL_52;
              v30 = v29 - (_BYTE *)p_p;
              if (v29 - (_BYTE *)p_p == -1)
                goto LABEL_52;
            }
            if (v26 == -1 || v30 == -1 || (v31 = v30 - v26, v31 < 2))
              std::string::basic_string[abi:nn180100]<0>(&v60, "NSObject");
            else
              std::string::basic_string(&v60, &__p, v26 + 1, v31 - 1, (std::allocator<char> *)&v62);
            name = v60;
            if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              p_name = &name;
            else
              p_name = (std::string *)v60.__r_.__value_.__r.__words[0];
LABEL_23:
            Class = objc_getClass((const char *)p_name);
            if (SHIBYTE(name.__r_.__value_.__r.__words[2]) < 0)
              operator delete(name.__r_.__value_.__l.__data_);
          }
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__p.__r_.__value_.__l.__data_);
          if (!Class)
            goto LABEL_30;
        }
        else if (!Class)
        {
          goto LABEL_30;
        }
        v22 = -[NSString UTF8String](-[NSString stringByAppendingString:](NSStringFromClass(Class), "stringByAppendingString:", CFSTR(" *")), "UTF8String");
        if (!class_addIvar(ClassPair, (const char *)objc_msgSend(v13, "UTF8String"), 8uLL, 3u, v22))
          metaFilterForFilter_cold_3();
LABEL_30:
        ++v12;
      }
      while (v10 != v12);
      v32 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v55, v64, 16);
      v10 = v32;
    }
    while (v32);
  }
  v33 = class_addIvar(ClassPair, "originalObject", 8uLL, 3u, "@\"CIFilter\"");
  v34 = class_addIvar(ClassPair, "inputOutputImage", 8uLL, 3u, "@\"CIImage\"");
  InstanceMethod = class_getInstanceMethod(superclass, sel_valueForUndefinedKey_);
  v36 = method_getTypeEncoding(InstanceMethod);
  v37 = class_addMethod(ClassPair, sel_valueForUndefinedKey_, (IMP)valueForUndefinedKey, v36);
  v38 = class_getInstanceMethod(superclass, sel_setValue_forUndefinedKey_);
  v39 = method_getTypeEncoding(v38);
  v40 = class_addMethod(ClassPair, sel_setValue_forUndefinedKey_, (IMP)setValueForUndefinedKey, v39);
  if (((v33 && v34 && v37) & v40 & class_addMethod(ClassPair, sel_valueForKey_, (IMP)valueForKey, v36) & 1) == 0)
    metaFilterForFilter_cold_2();
LABEL_63:
  v41 = (objc_object *)objc_alloc_init(ClassPair);
  setValueForObject(v41, CFSTR("originalObject"), a2);
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v42 = (void *)-[objc_object inputKeys](a2, "inputKeys");
  v43 = objc_msgSend(v42, "countByEnumeratingWithState:objects:count:", &v51, v63, 16);
  if (v43)
  {
    v44 = *(_QWORD *)v52;
    do
    {
      for (i = 0; i != v43; ++i)
      {
        if (*(_QWORD *)v52 != v44)
          objc_enumerationMutation(v42);
        v46 = *(NSString **)(*((_QWORD *)&v51 + 1) + 8 * i);
        v47 = (objc_object *)-[objc_object valueForKey:](a2, "valueForKey:", v46);
        setValueForObject(v41, v46, v47);
        if ((objc_object *)-[objc_object valueForUndefinedKey:](v41, "valueForUndefinedKey:", v46) != v47)
          metaFilterForFilter_cold_1();
      }
      v43 = objc_msgSend(v42, "countByEnumeratingWithState:objects:count:", &v51, v63, 16);
    }
    while (v43);
  }
  return v41;
}

void sub_192312FF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  void *v45;

  objc_sync_exit(v45);
  _Unwind_Resume(a1);
}

id __metaFilterForFilter_block_invoke()
{
  id result;

  result = (id)objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  wrappedClassDict = (uint64_t)result;
  return result;
}

objc_ivar *valueForUndefinedKey(objc_object *a1, objc_selector *a2, uint64_t a3, ...)
{
  objc_ivar *result;
  void *v5[2];
  va_list va;

  va_start(va, a3);
  v5[0] = 0;
  va_copy((va_list)&v5[1], va);
  result = object_getInstanceVariable(a1, "originalObject", v5);
  if (result)
    return (objc_ivar *)objc_msgSend(object_getIvar(a1, result), "valueForKey:", a3);
  return result;
}

objc_ivar *setValueForUndefinedKey(objc_object *a1, objc_selector *a2, objc_object *a3, NSString *a4, ...)
{
  objc_ivar *result;

  result = getValueForObject(a1, CFSTR("originalObject"));
  if (result)
    return setValueForObject((objc_object *)result, a4, a3);
  return result;
}

Ivar valueForKey(objc_object *a1, objc_selector *a2, NSString *a3, ...)
{
  Ivar result;
  void *v5;
  va_list va;

  va_start(va, a3);
  if (object_getInstanceVariable(a1, -[NSString UTF8String](a3, "UTF8String", 0, va), &v5))
    return getValueForObject(a1, a3);
  result = object_getInstanceVariable(a1, "originalObject", &v5);
  if (result)
    return (Ivar)objc_msgSend(object_getIvar(a1, result), "valueForKey:", a3);
  return result;
}

objc_ivar *setValueForObject(objc_object *a1, NSString *a2, objc_object *a3)
{
  objc_ivar *result;
  objc_ivar *v6;
  objc_object *Ivar;
  objc_object *v8;

  result = object_getInstanceVariable(a1, -[NSString UTF8String](a2, "UTF8String"), 0);
  if (result)
  {
    v6 = result;
    Ivar = (objc_object *)object_getIvar(a1, result);
    if (Ivar != a3)
    {
      if (Ivar)

      object_setIvar(a1, v6, a3);
      if (a3)
        v8 = a3;
    }
    result = (objc_ivar *)object_getIvar(a1, v6);
    if (result != (objc_ivar *)a3)
      setValueForObject();
  }
  return result;
}

objc_ivar *getValueForObject(objc_object *a1, NSString *a2)
{
  objc_ivar *result;

  result = object_getInstanceVariable(a1, -[NSString UTF8String](a2, "UTF8String"), 0);
  if (result)
    return (objc_ivar *)object_getIvar(a1, result);
  return result;
}

void *pixelFormatForMetalTexture(void *result)
{
  if (result)
    return (void *)objc_msgSend(result, "pixelFormat");
  return result;
}

const char *stringForMetalTextureFormat()
{
  MTLPixelFormatGetInfoForDevice();
  return "Unknown";
}

uint64_t CIMetalFormatForFormat(int a1, int a2)
{
  int v2;
  uint64_t result;
  BOOL v4;
  unsigned int v5;

  if (a1 > 1285)
  {
    if (a1 <= 2055)
    {
      if (a1 <= 1797)
      {
        switch(a1)
        {
          case 1286:
            return 589;
          case 1298:
            return 546;
          case 1797:
            return 20;
        }
      }
      else if (a1 > 2052)
      {
        if (a1 == 2053)
          return 25;
        if (a1 == 2054)
          return 65;
      }
      else
      {
        if (a1 == 1798)
          return 60;
        if (a1 == 1800)
          return 110;
      }
    }
    else if (a1 > 2566)
    {
      if (a1 > 3078)
      {
        if (a1 == 3079)
          return 554;
        if (a1 == 3081)
          return 552;
      }
      else
      {
        if (a1 == 2567)
          return 555;
        if (a1 == 2569)
          return 553;
      }
    }
    else if (a1 > 2309)
    {
      if (a1 == 2310)
        return 105;
      if (a1 == 2312)
        return 125;
    }
    else
    {
      if (a1 == 2056)
        return 115;
      if (a1 == 2309)
        return 55;
    }
    return 0;
  }
  if (a1 <= 529)
  {
    v2 = a1 - 257;
    result = 1;
    switch(v2)
    {
      case 0:
        return result;
      case 4:
        v4 = a2 == 0;
        v5 = 10;
        goto LABEL_46;
      case 5:
        v4 = a2 == 0;
        v5 = 30;
        goto LABEL_46;
      case 7:
        v4 = a2 == 0;
        v5 = 70;
        goto LABEL_46;
      case 9:
        v4 = a2 == 0;
        v5 = 80;
LABEL_46:
        if (v4)
          result = v5;
        else
          result = v5 + 1;
        break;
      case 17:
        goto LABEL_13;
      case 19:
        goto LABEL_40;
      case 20:
        goto LABEL_41;
      case 21:
        goto LABEL_42;
      default:
        return 0;
    }
    return result;
  }
  if (a1 > 783)
  {
    switch(a1)
    {
      case 784:
        return 94;
      case 785:
        return 90;
      case 1285:
        return 588;
    }
    return 0;
  }
  switch(a1)
  {
    case 530:
LABEL_13:
      result = 540;
      break;
    case 532:
LABEL_40:
      result = 241;
      break;
    case 533:
LABEL_41:
      result = 240;
      break;
    case 534:
LABEL_42:
      result = 541;
      break;
    default:
      return 0;
  }
  return result;
}

id internalError(void *a1)
{
  return objc_getAssociatedObject(a1, setInternalError);
}

void setInternalError(void *a1, id value)
{
  if (value)
    objc_setAssociatedObject(a1, setInternalError, value, (void *)0x301);
}

uint64_t isImageConversionServiceProcess()
{
  if (isImageConversionServiceProcess_onceToken != -1)
    dispatch_once(&isImageConversionServiceProcess_onceToken, &__block_literal_global_51);
  return isImageConversionServiceProcess_isICS;
}

void *__isImageConversionServiceProcess_block_invoke()
{
  void *result;

  result = (void *)objc_msgSend(MEMORY[0x1E0CB3898], "processInfo");
  if (result)
    result = (void *)objc_msgSend((id)objc_msgSend(result, "processName"), "isEqualToString:", CFSTR("com.apple.photos.ImageConversionService"));
  isImageConversionServiceProcess_isICS = (char)result;
  return result;
}

uint64_t isQuickLookSideCar()
{
  if (isQuickLookSideCar_onceToken != -1)
    dispatch_once(&isQuickLookSideCar_onceToken, &__block_literal_global_2);
  return isQuickLookSideCar_isQL;
}

uint64_t __isQuickLookSideCar_block_invoke()
{
  uint64_t result;
  void *v1;
  void *v2;

  result = objc_msgSend(MEMORY[0x1E0CB3898], "processInfo");
  if (result)
  {
    v1 = (void *)result;
    result = objc_msgSend((id)result, "processName");
    if (result)
    {
      v2 = (void *)objc_msgSend(v1, "processName");
      if ((objc_msgSend(v2, "containsString:", CFSTR("com.apple.quicklook")) & 1) != 0
        || (objc_msgSend(v2, "containsString:", CFSTR("com.apple.sidecar")) & 1) != 0)
      {
        result = 1;
      }
      else
      {
        result = objc_msgSend(v2, "containsString:", CFSTR("ContinuityCamera"));
      }
      isQuickLookSideCar_isQL = result;
    }
  }
  return result;
}

uint64_t isMobileSlideShowOrCamera()
{
  if (isMobileSlideShowOrCamera_onceToken != -1)
    dispatch_once(&isMobileSlideShowOrCamera_onceToken, &__block_literal_global_9);
  return isMobileSlideShowOrCamera_isMobileSlideShowOrCamera;
}

uint64_t __isMobileSlideShowOrCamera_block_invoke()
{
  uint64_t result;
  void *v1;

  result = objc_msgSend(MEMORY[0x1E0CB3898], "processInfo");
  if (result)
  {
    v1 = (void *)result;
    if ((objc_msgSend((id)objc_msgSend((id)result, "processName"), "isEqualToString:", CFSTR("MobileSlideShow")) & 1) != 0)
      result = 1;
    else
      result = objc_msgSend((id)objc_msgSend(v1, "processName"), "isEqualToString:", CFSTR("Camera"));
  }
  isMobileSlideShowOrCamera_isMobileSlideShowOrCamera = result;
  return result;
}

BOOL CIMetalDeviceSupportsMPS(void *a1)
{
  return MEMORY[0x1E0CC6C88] && MPSSupportsMTLDevice(a1);
}

uint64_t CIMetalDeviceSupportsFamilyApple7(void *a1, const char *a2)
{
  return objc_msgSend(a1, "supportsFamily:", 1007);
}

uint64_t CIMetalDeviceSupportsFamilyApple8(void *a1, const char *a2)
{
  return objc_msgSend(a1, "supportsFamily:", 1008);
}

uint64_t CIFormatFromCIMetalTextureFormat(int a1, _BYTE *a2)
{
  uint64_t result;
  CIFormat *v4;

  if (a2)
    *a2 = 0;
  result = 0;
  if (a1 > 79)
  {
    if (a1 > 114)
    {
      switch(a1)
      {
        case 552:
          v4 = &kCIFormatARGB10WideLinear;
          return *v4;
        case 553:
          if (a2)
            *a2 = 1;
          v4 = &kCIFormatARGB10WideGamut;
          return *v4;
        case 554:
          v4 = &kCIFormatRGB10WideLinear;
          return *v4;
        case 555:
          if (a2)
            *a2 = 1;
          v4 = &kCIFormatRGB10WideGamut;
          return *v4;
        default:
          if (a1 == 115)
          {
            v4 = &kCIFormatRGBAh;
          }
          else
          {
            if (a1 != 125)
              return result;
            v4 = &kCIFormatRGBAf;
          }
          break;
      }
    }
    else
    {
      if (a1 > 93)
      {
        switch(a1)
        {
          case '^':
            v4 = &kCIFormatA2RGB10;
            break;
          case 'i':
            v4 = &kCIFormatRGf;
            break;
          case 'n':
            v4 = &kCIFormatRGBA16;
            break;
          default:
            return result;
        }
        return *v4;
      }
      if (a1 != 80)
      {
        if (a1 != 81)
        {
          if (a1 != 90)
            return result;
          v4 = &kCIFormatA2BGR10;
          return *v4;
        }
        if (a2)
          *a2 = 1;
      }
      v4 = &kCIFormatBGRA8;
    }
    return *v4;
  }
  if (a1 > 30)
  {
    if (a1 > 64)
    {
      if (a1 == 65)
      {
        v4 = &kCIFormatRGh;
      }
      else
      {
        if (a1 != 70)
        {
          if (a1 != 71)
            return result;
          if (a2)
            *a2 = 1;
        }
        v4 = &kCIFormatRGBA8;
      }
      return *v4;
    }
    if (a1 != 31)
    {
      if (a1 == 55)
      {
        v4 = &kCIFormatRf;
      }
      else
      {
        if (a1 != 60)
          return result;
        v4 = &kCIFormatRG16;
      }
      return *v4;
    }
    if (a2)
      *a2 = 1;
LABEL_48:
    v4 = &kCIFormatRG8;
    return *v4;
  }
  if (a1 <= 19)
  {
    if (a1 == 1)
    {
      v4 = &kCIFormatA8;
    }
    else
    {
      if (a1 != 10)
      {
        if (a1 != 11)
          return result;
        if (a2)
          *a2 = 1;
      }
      v4 = &kCIFormatR8;
    }
    return *v4;
  }
  switch(a1)
  {
    case 20:
      v4 = &kCIFormatR16;
      return *v4;
    case 25:
      v4 = &kCIFormatRh;
      return *v4;
    case 30:
      goto LABEL_48;
  }
  return result;
}

uint64_t CIMetalTextureGetFormat(void *a1)
{
  return objc_msgSend(a1, "pixelFormat");
}

void *CIMetalTextureCreate(uint64_t a1, void *a2, unsigned int a3, uint64_t a4, uint64_t a5, int a6)
{
  void *TextureDescriptor;
  void *v10;
  void *v11;

  if (!a3)
    return 0;
  TextureDescriptor = CreateTextureDescriptor(a3, a4, a5, a6);
  v10 = TextureDescriptor;
  if (a6 == 3)
    objc_msgSend(TextureDescriptor, "setStorageMode:", 2);
  v11 = (void *)objc_msgSend(a2, "newTextureWithDescriptor:", v10);
  if (CI_ENABLE_METAL_LABEL())
    objc_msgSend(v11, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  return v11;
}

void *CreateTextureDescriptor(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4)
{
  void *v5;

  v5 = (void *)objc_msgSend(MEMORY[0x1E0CC6BB0], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", a1, a2, a3, 0);
  objc_msgSend(v5, "setUsage:", 0);
  if ((a4 & 1) != 0)
  {
    objc_msgSend(v5, "setUsage:", objc_msgSend(v5, "usage") | 1);
    if ((a4 & 2) == 0)
    {
LABEL_3:
      if ((a4 & 4) == 0)
        goto LABEL_4;
LABEL_9:
      objc_msgSend(v5, "setUsage:", objc_msgSend(v5, "usage") | 4);
      if ((a4 & 0x4000) == 0)
        return v5;
      goto LABEL_5;
    }
  }
  else if ((a4 & 2) == 0)
  {
    goto LABEL_3;
  }
  objc_msgSend(v5, "setUsage:", objc_msgSend(v5, "usage") | 2);
  if ((a4 & 4) != 0)
    goto LABEL_9;
LABEL_4:
  if ((a4 & 0x4000) != 0)
LABEL_5:
    objc_msgSend(v5, "setUsage:", objc_msgSend(v5, "usage") | 0x4000);
  return v5;
}

void *CIMetalTextureCreateFromBuffer(uint64_t a1, void *a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, __int16 a7)
{
  void *v8;

  if (!a3)
    return 0;
  v8 = (void *)objc_msgSend(a2, "newTextureWithDescriptor:offset:bytesPerRow:", CreateTextureDescriptor(a3, a4, a5, a7), 0, a6);
  if (CI_ENABLE_METAL_LABEL())
    objc_msgSend(v8, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  return v8;
}

void *CIMetalTextureCreateFromIOSurface(uint64_t a1, void *a2, IOSurfaceRef buffer, size_t planeIndex, unsigned int a5, __int16 a6)
{
  size_t WidthOfPlane;
  size_t HeightOfPlane;

  WidthOfPlane = IOSurfaceGetWidthOfPlane(buffer, planeIndex);
  HeightOfPlane = IOSurfaceGetHeightOfPlane(buffer, planeIndex);
  return CIMetalTextureCreateFromPaddedIOSurface(WidthOfPlane, HeightOfPlane, a1, a2, (uint64_t)buffer, planeIndex, a5, a6);
}

void *CIMetalTextureCreateFromPaddedIOSurface(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, unsigned int a7, __int16 a8)
{
  void *v9;

  if (!a5)
    return 0;
  v9 = 0;
  if (a2)
  {
    if (a1)
    {
      if (a7)
      {
        v9 = (void *)objc_msgSend(a4, "newTextureWithDescriptor:iosurface:plane:", CreateTextureDescriptor(a7, a1, a2, a8), a5, a6);
        if (v9)
        {
          if (CI_ENABLE_METAL_LABEL())
            objc_msgSend(v9, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a3));
        }
      }
    }
  }
  return v9;
}

uint64_t CIMetalTextureSetBytes(void *a1, uint64_t a2, uint64_t a3)
{
  _QWORD v7[6];

  memset(v7, 0, 24);
  v7[3] = objc_msgSend(a1, "width");
  v7[4] = objc_msgSend(a1, "height");
  v7[5] = 1;
  return objc_msgSend(a1, "replaceRegion:mipmapLevel:withBytes:bytesPerRow:", v7, 0, a2, a3);
}

uint64_t CIMetalTextureGetBytes(void *a1, uint64_t a2, uint64_t a3)
{
  _QWORD v7[6];

  memset(v7, 0, 24);
  v7[3] = objc_msgSend(a1, "width");
  v7[4] = objc_msgSend(a1, "height");
  v7[5] = 1;
  return objc_msgSend(a1, "getBytes:bytesPerRow:fromRegion:mipmapLevel:", a2, a3, v7, 0);
}

void *CIMetalBufferCreate(uint64_t a1, void *a2, uint64_t a3)
{
  void *v4;

  v4 = (void *)objc_msgSend(a2, "newBufferWithLength:options:", a3, 0);
  if (CI_ENABLE_METAL_LABEL())
    objc_msgSend(v4, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  return v4;
}

void *CIMetalBufferCreateAndWrapData(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v5;

  v5 = (void *)objc_msgSend(a2, "newBufferWithBytesNoCopy:length:options:deallocator:", a3, a4, 0, 0);
  if (CI_ENABLE_METAL_LABEL())
    objc_msgSend(v5, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  return v5;
}

uint64_t CIGetHarvestingBinaryArchiveDict(uint64_t a1)
{
  uint64_t v2;
  _QWORD block[6];
  _QWORD v5[3];
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  v2 = objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __CIGetHarvestingBinaryArchiveDict_block_invoke;
  block[3] = &unk_1E2EC2EE0;
  block[4] = v2;
  block[5] = a1;
  if (CIGetHarvestingBinaryArchiveDict_onceToken != -1)
    dispatch_once(&CIGetHarvestingBinaryArchiveDict_onceToken, block);
  v5[0] = CFSTR("bin");
  v5[1] = CFSTR("queue");
  v6[0] = CIGetHarvestingBinaryArchiveDict_bin;
  v6[1] = CIGetHarvestingBinaryArchiveDict_queue;
  v5[2] = CFSTR("path");
  v6[2] = CIGetHarvestingBinaryArchiveDict_binary_archive_file_path;
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v6, v5, 3);
}

void serializeHarvestedBinaryArchiveExit()
{
  void *v0;
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  _QWORD v4[6];

  v0 = (void *)CIGetHarvestingBinaryArchiveDict(0);
  v1 = objc_msgSend(v0, "objectForKeyedSubscript:", CFSTR("bin"));
  v2 = objc_msgSend(v0, "objectForKeyedSubscript:", CFSTR("queue"));
  v3 = objc_msgSend(v0, "objectForKeyedSubscript:", CFSTR("path"));
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __serializeHarvestedBinaryArchiveExit_block_invoke;
  v4[3] = &unk_1E2EC2EE0;
  v4[4] = v1;
  v4[5] = v3;
  dispatch_sync(v2, v4);
}

uint64_t CreateComputePipelineState(void *a1, void *a2, void *a3, uint64_t a4)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  v15 = 0;
  v8 = (void *)objc_opt_new();
  objc_msgSend(v8, "setComputeFunction:", a2);
  if (a4)
  {
    v16[0] = a4;
    objc_msgSend(v8, "setPreloadedLibraries:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v16, 1));
  }
  if (a3)
    objc_msgSend(v8, "setBinaryArchives:", a3);
  if ((CI_LOG_BIN_ARCHIVE_MISS() & 1) == 0)
  {
LABEL_14:
    v10 = objc_msgSend(a1, "newComputePipelineStateWithDescriptor:options:reflection:error:", v8, 0, 0, &v15);

    if (v10)
      return v10;
    v13 = ci_logger_compile();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      CreateComputePipelineState_cold_1();
    return 0;
  }
  if (!objc_msgSend(a3, "count"))
  {
    v11 = ci_logger_compile();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      CreateComputePipelineState_cold_2(a2, v11);
    goto LABEL_14;
  }
  v9 = objc_msgSend(a1, "newComputePipelineStateWithDescriptor:options:reflection:error:", v8, 4, 0, &v15);
  if (!v9)
  {
    v12 = ci_logger_compile();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      CreateComputePipelineState_cold_3(a2, v12);
    goto LABEL_14;
  }
  v10 = v9;

  return v10;
}

uint64_t CreateRenderPipelineState(void *a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  void *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v14;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  v14 = 0;
  v10 = (void *)objc_opt_new();
  objc_msgSend(v10, "setTileFunction:", a2);
  objc_msgSend(v10, "setThreadgroupSizeMatchesTileSize:", 1);
  if (a5)
  {
    v15[0] = a5;
    objc_msgSend(v10, "setPreloadedLibraries:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v15, 1));
  }
  if (a3)
    objc_msgSend(v10, "setBinaryArchives:", a3);
  if (CI_ENABLE_METAL_IMAGEBLOCKS() == 2)
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(v10, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setPixelFormat:", a4);
  v11 = objc_msgSend(a1, "newRenderPipelineStateWithTileDescriptor:options:reflection:error:", v10, 0, 0, &v14);

  if (!v11)
  {
    v12 = ci_logger_compile();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      CreateRenderPipelineState_cold_1();
  }
  return v11;
}

void *CIMetalComputePipelineStateCreateFromSource(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *result;
  void *v7;
  uint64_t ComputePipelineState;

  result = CreateFunctionFromSource(a1, a2, a3, a4, a5);
  if (result)
  {
    v7 = result;
    ComputePipelineState = CreateComputePipelineState(a2, result, 0, 0);

    return (void *)ComputePipelineState;
  }
  return result;
}

void *CreateFunctionFromSource(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t i;
  void *v17;
  void *v18;
  void *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _BYTE v32[128];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v27 = 0;
  v10 = (void *)objc_opt_new();
  objc_msgSend(v10, "setAdditionalCompilerArguments:", CFSTR("-w"));
  v11 = (void *)objc_msgSend(a2, "newLibraryWithSource:options:error:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a3), v10, &v27);

  ArchiveLibrary(v11, a5, a4);
  if (!v11)
  {
    v21 = ci_logger_compile();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      CreateFunctionFromSource_cold_1();
    return 0;
  }
  v24 = a3;
  if (CI_ENABLE_METAL_LABEL())
    objc_msgSend(v11, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  v26 = a1;
  if (CI_ENABLE_METAL_DEBUG())
  {
    if (CreateFunctionFromDefaultLibrary_init != -1)
      dispatch_once(&CreateFunctionFromDefaultLibrary_init, &__block_literal_global_80_0);
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v12 = (void *)CreateFunctionFromDefaultLibrary_bundles;
    v13 = objc_msgSend((id)CreateFunctionFromDefaultLibrary_bundles, "countByEnumeratingWithState:objects:count:", &v28, v32, 16, a3);
    if (v13)
    {
      v14 = v13;
      v15 = *(_QWORD *)v29;
      v25 = v11;
      while (2)
      {
        for (i = 0; i != v14; ++i)
        {
          if (*(_QWORD *)v29 != v15)
            objc_enumerationMutation(v12);
          v17 = *(void **)(*((_QWORD *)&v28 + 1) + 8 * i);
          v18 = (void *)objc_msgSend(a2, "newDefaultLibraryWithBundle:error:", v17, 0);
          v19 = (void *)objc_msgSend(v18, "newFunctionWithName:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a4));

          if (v19)
          {
            v22 = ci_logger_compile();
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              CreateFunctionFromSource_cold_3(a4, v17, v22);

            goto LABEL_24;
          }
        }
        v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v28, v32, 16);
        v11 = v25;
        if (v14)
          continue;
        break;
      }
    }
  }
  v19 = (void *)objc_msgSend(v11, "newFunctionWithName:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a4, v24));

  if (!v19)
  {
    v20 = ci_logger_compile();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      CreateFunctionFromSource_cold_2();
    return 0;
  }
LABEL_24:
  if (CI_ENABLE_METAL_LABEL())
    objc_msgSend(v19, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v26));
  return v19;
}

void *CIMetalRenderPipelineStateCreateFromSource(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  void *result;
  void *v9;
  uint64_t RenderPipelineState;

  result = CreateFunctionFromSource(a1, a2, a3, a4, a5);
  if (result)
  {
    v9 = result;
    RenderPipelineState = CreateRenderPipelineState(a2, (uint64_t)result, 0, a6, 0);

    return (void *)RenderPipelineState;
  }
  return result;
}

uint64_t CILoadBinaryArchive(uint64_t a1, int a2)
{
  id v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  id v12;

  v12 = 0;
  if (!a1)
    return 0;
  v4 = MTLCreateSystemDefaultDevice();
  if (!v4)
  {
    v9 = ci_logger_api();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      CILoadBinaryArchive_cold_1();
    return 0;
  }
  v5 = v4;
  if (a2 && (objc_msgSend(v4, "supportsFamily:", 1006) & 1) == 0)
  {
LABEL_12:

    return 0;
  }
  v6 = (void *)objc_opt_new();
  objc_msgSend(v6, "setUrl:", a1);
  v7 = objc_msgSend(v5, "newBinaryArchiveWithDescriptor:error:", v6, &v12);
  if (!v7)
  {
    v10 = ci_logger_api();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      CILoadBinaryArchive_cold_2(a1, &v12, v10);

    goto LABEL_12;
  }
  v8 = v7;

  return v8;
}

uint64_t CILoadAIRArchive(uint64_t a1, int a2)
{
  uint64_t v2;
  id v4;
  void *v5;
  NSObject *v6;
  uint64_t v8;

  v2 = a1;
  v8 = 0;
  if (a1)
  {
    v4 = MTLCreateSystemDefaultDevice();
    if (v4)
    {
      v5 = v4;
      if (!a2 || (objc_msgSend(v4, "supportsFamily:", 1006) & 1) != 0)
      {
        v2 = objc_msgSend(v5, "newLibraryWithURL:error:", v2, &v8);

        return v2;
      }

    }
    else
    {
      v6 = ci_logger_api();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        CILoadAIRArchive_cold_1();
    }
    return 0;
  }
  return v2;
}

void testBinaryArchive(void *a1, uint64_t a2)
{
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  id obj;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE v21[128];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v19 = 0;
  v4 = MTLCreateSystemDefaultDevice();
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  obj = (id)objc_msgSend(a1, "functionNames");
  v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v15, v21, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v16;
    do
    {
      for (i = 0; i != v6; ++i)
      {
        if (*(_QWORD *)v16 != v7)
          objc_enumerationMutation(obj);
        v9 = *(_QWORD *)(*((_QWORD *)&v15 + 1) + 8 * i);
        v10 = objc_msgSend(a1, "newFunctionWithName:", v9);
        if (v10)
        {
          v11 = (void *)v10;
          NSLog(CFSTR("Trying %@"), v9);
          v12 = (void *)objc_opt_new();
          objc_msgSend(v12, "setComputeFunction:", v11);
          v20 = a2;
          objc_msgSend(v12, "setBinaryArchives:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v20, 1));
          v13 = (void *)objc_msgSend(v4, "newComputePipelineStateWithDescriptor:options:reflection:error:", v12, 4, 0, &v19);

          if (!v13)
            testBinaryArchive_cold_1(&v19, v9);

        }
        else
        {
          NSLog(CFSTR("Failed to create %@ MTLFunction"), v9);
        }
      }
      v6 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v15, v21, 16);
    }
    while (v6);
  }

  NSLog(CFSTR("Done with all functions"));
}

uint64_t CIMetalRenderPipelineStateCreateFromDagDescriptor(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  uint64_t result;
  void *v13;
  uint64_t RenderPipelineState;

  result = CreateStitchedFunctionFromDescriptor(a1, a2, a3, a4, a7);
  if (result)
  {
    v13 = (void *)result;
    RenderPipelineState = CreateRenderPipelineState(a3, result, a5, a8, a6);

    return RenderPipelineState;
  }
  return result;
}

uint64_t CreateStitchedFunctionFromDescriptor(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5)
{
  void *v10;
  NSObject *v11;
  const __CFString *v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v17;

  v17 = 0;
  if ((CI_LOG_BIN_ARCHIVE_MISS() & 2) != 0)
  {
    objc_msgSend(a4, "setOptions:", 1);
    v10 = (void *)objc_msgSend(a3, "newLibraryWithDescriptor:error:", a4, &v17);
    objc_msgSend(a4, "setOptions:", 0);
    if (v10)
      goto LABEL_6;
    v11 = ci_logger_compile();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      CreateStitchedFunctionFromDescriptor_cold_3();
  }
  v10 = (void *)objc_msgSend(a3, "newLibraryWithDescriptor:error:", a4, &v17);
LABEL_6:
  if (CI_ENABLE_METAL_LABEL())
    objc_msgSend(v10, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  if (!v10)
  {
    v13 = ci_logger_compile();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      CreateFunctionFromSource_cold_1();
    goto LABEL_17;
  }
  if (CI_HARVEST_BIN_ARCHIVE() == 1)
    v12 = CFSTR("ciKernelMain");
  else
    v12 = (const __CFString *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a2);
  v14 = objc_msgSend(v10, "newFunctionWithName:", v12);
  ArchiveLibrary(v10, a5, a2);

  if (!v14)
  {
    v15 = ci_logger_compile();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      CreateStitchedFunctionFromDescriptor_cold_2();
LABEL_17:
    print_stitched_dag(a3, a4);
    return 0;
  }
  return v14;
}

uint64_t CIMetalComputePipelineStateCreateFromDagDescriptor(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t StitchedFunctionFromDescriptor;
  void *v15;
  char *v16;
  void *v17;
  uint64_t v18;
  uint64_t ComputePipelineState;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t block;
  uint64_t v30;
  void *v31;
  void *v32;
  char *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD v39[2];

  v39[1] = *MEMORY[0x1E0C80C00];
  objc_msgSend(a4, "setBinaryArchives:", a5);
  StitchedFunctionFromDescriptor = CreateStitchedFunctionFromDescriptor(a1, a2, a3, a4, a7);
  if (!StitchedFunctionFromDescriptor)
    return 0;
  v15 = (void *)StitchedFunctionFromDescriptor;
  if (CI_ENABLE_METAL_LABEL())
    objc_msgSend(v15, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  if (CI_HARVEST_BIN_ARCHIVE() != 2)
    goto LABEL_14;
  v16 = CI_HARVEST_PROCESS_NAME_LIST();
  if (!v16)
    goto LABEL_9;
  block = MEMORY[0x1E0C809B0];
  v30 = 3221225472;
  v31 = __isHarvestingForThisProcess_block_invoke;
  v32 = &__block_descriptor_40_e5_v8__0l;
  v33 = v16;
  if (isHarvestingForThisProcess_onceToken != -1)
    dispatch_once(&isHarvestingForThisProcess_onceToken, &block);
  if (isHarvestingForThisProcess_isListed)
  {
LABEL_9:
    v28 = 0;
    v17 = (void *)objc_opt_new();
    objc_msgSend(v17, "setComputeFunction:", v15);
    objc_msgSend(v17, "setBinaryArchives:", a5);
    if (a6)
    {
      v39[0] = a6;
      objc_msgSend(v17, "setPreloadedLibraries:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v39, 1));
    }
    if (objc_msgSend(a5, "count")
      && (v18 = objc_msgSend(a3, "newComputePipelineStateWithDescriptor:options:reflection:error:", v17, 4, 0, &v28)) != 0)
    {
      ComputePipelineState = v18;

    }
    else
    {
      objc_msgSend(v17, "setBinaryArchives:", 0);
      v21 = objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a2);
      if (a7)
      {
        v22 = v21;
        v23 = (void *)CIGetHarvestingBinaryArchiveDict((uint64_t)a3);
        v24 = objc_msgSend(v23, "objectForKeyedSubscript:", CFSTR("bin"));
        v25 = objc_msgSend(v23, "objectForKeyedSubscript:", CFSTR("queue"));
        v26 = objc_msgSend(v23, "objectForKeyedSubscript:", CFSTR("path"));
        block = MEMORY[0x1E0C809B0];
        v30 = 3221225472;
        v31 = __ArchiveLibraryUsingStitchedDagDescriptor_block_invoke;
        v32 = &unk_1E2EC4A10;
        v33 = (char *)v22;
        v34 = v24;
        v35 = a4;
        v36 = v17;
        v37 = v26;
        v38 = a7;
        dispatch_sync(v25, &block);
      }
      ComputePipelineState = objc_msgSend(a3, "newComputePipelineStateWithDescriptor:options:reflection:error:", v17, 0, 0, &v28);

      if (!ComputePipelineState)
      {
        v27 = ci_logger_compile();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          CreateComputePipelineState_cold_1();
        ComputePipelineState = 0;
      }
    }
  }
  else
  {
LABEL_14:
    ComputePipelineState = CreateComputePipelineState(a3, v15, a5, a6);
  }

  if (!ComputePipelineState)
    print_stitched_dag(a3, a4);
  return ComputePipelineState;
}

void print_stitched_dag(void *a1, void *a2)
{
  void *v2;
  NSObject *v3;

  v2 = (void *)objc_msgSend(a1, "newDagStringWithGraphs:", objc_msgSend(a2, "functionGraphs"));
  v3 = ci_logger_compile();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    print_stitched_dag_cold_1();

}

void *CIMetalComputePipelineStateCreateFromDAG(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  void *result;
  void *v9;
  uint64_t ComputePipelineState;

  result = CreateFunctionFromDAG(a1, a2, a3, a4, a5, a6, a7);
  if (result)
  {
    v9 = result;
    ComputePipelineState = CreateComputePipelineState(a3, result, 0, 0);

    return (void *)ComputePipelineState;
  }
  return result;
}

void *CreateFunctionFromDAG(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  void *v12;
  void *v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v17;

  v17 = 0;
  v11 = objc_msgSend(a3, "newLibraryWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:", a4, a5, &v17);
  if (!v11)
  {
    v14 = ci_logger_compile();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      CreateFunctionFromSource_cold_1();
    return 0;
  }
  v12 = (void *)v11;
  if (CI_ENABLE_METAL_LABEL())
    objc_msgSend(v12, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  ArchiveLibrary(v12, a7, a2);
  v13 = (void *)objc_msgSend(v12, "newFunctionWithName:constantValues:error:", CFSTR("ciKernelMain"), a6, &v17);

  if (!v13)
  {
    v15 = ci_logger_compile();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      CreateStitchedFunctionFromDescriptor_cold_2();
    return 0;
  }
  if (CI_ENABLE_METAL_LABEL())
    objc_msgSend(v13, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  return v13;
}

void *CIMetalRenderPipelineStateCreateFromDAG(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  void *result;
  void *v11;
  uint64_t RenderPipelineState;

  result = CreateFunctionFromDAG(a1, a2, a3, a4, a5, a6, a7);
  if (result)
  {
    v11 = result;
    RenderPipelineState = CreateRenderPipelineState(a3, (uint64_t)result, 0, a8, 0);

    return (void *)RenderPipelineState;
  }
  return result;
}

uint64_t isWidget()
{
  if (isWidget_once != -1)
    dispatch_once(&isWidget_once, &__block_literal_global_47);
  return isWidget_bWidget;
}

uint64_t __isWidget_block_invoke()
{
  uint64_t result;

  result = objc_msgSend((id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CA58E0], "extensionPointRecordForCurrentProcess"), "identifier"), "isEqualToString:", CFSTR("com.apple.widgetkit-extension"));
  isWidget_bWidget = result;
  return result;
}

uint64_t CIMetalCommandQueueSetPriority(void *a1, const char *a2)
{
  uint64_t v2;

  if ((int)a2 >= 0)
    v2 = (_DWORD)a2 == 0;
  else
    v2 = 2;
  return objc_msgSend(a1, "setGPUPriority:", v2);
}

void *CIMetalCommandBufferCreate(uint64_t a1, void *a2, int a3, const void *a4)
{
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  if (a3)
    v6 = (void *)objc_msgSend(a2, "commandBufferWithUnretainedReferences");
  else
    v6 = (void *)objc_msgSend(a2, "commandBuffer");
  v7 = v6;
  if (a4)
  {
    v8 = (void *)objc_msgSend(v6, "userDictionary");
    v9 = _Block_copy(a4);
    objc_msgSend(v8, "setObject:forKeyedSubscript:", v9, CFSTR("RendererStatsPerfCallback"));
    _Block_release(v9);
  }
  if (CI_ENABLE_METAL_LABEL())
    objc_msgSend(v7, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a1));
  return v7;
}

uint64_t CIMetalRenderToTextures(uint64_t a1, int a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11, uint64_t a12, uint64_t a13, unint64_t *a14, unint64_t *a15)
{
  void *v22;
  void *v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t result;
  uint64_t v45;
  char v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  _QWORD v54[9];
  int v55;
  _QWORD v56[7];
  int v57;
  _QWORD v58[3];
  _QWORD v59[4];

  v22 = (void *)objc_opt_new();
  v23 = (void *)objc_opt_new();
  v24 = objc_msgSend(a4, "maxTotalThreadsPerThreadgroup");
  if (v24 >= 0x100)
    v25 = 256;
  else
    v25 = v24;
  v26 = objc_msgSend(a4, "threadExecutionWidth");
  v27 = 32;
  if (v26)
    v27 = v26;
  v28 = a14[1];
  if (*a14)
    v29 = *a14;
  else
    v29 = v27;
  if (!v28)
    v28 = v25 / v29;
  if (a14[2] <= 1)
    v30 = 1;
  else
    v30 = a14[2];
  v31 = (unint64_t)((a9 + (double)(v29 - 1)) / (double)v29);
  v32 = (unint64_t)((a10 + (double)(v28 - 1)) / (double)v28);
  v49 = v28;
  v50 = v29;
  v48 = v30;
  if (a15 && *a15 && a15[1] && a15[2])
  {
    v45 = a15[2];
    v31 = *a15;
    v32 = a15[1];
  }
  else
  {
    v45 = 1;
  }
  v33 = objc_msgSend(a3, "label");
  if (a13
    && v33
    && objc_msgSend((id)objc_msgSend(a3, "label"), "isEqualToString:", CFSTR("com.apple.CoreImage")))
  {
    objc_msgSend(a3, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.%s"), objc_msgSend(a3, "label"), a13));
  }
  if (isImageConversionServiceProcess_onceToken != -1)
    dispatch_once(&isImageConversionServiceProcess_onceToken, &__block_literal_global_51);
  v34 = isImageConversionServiceProcess_isICS;
  if (useOneDispatchPerCommandBuffer_onceToken != -1)
    dispatch_once(&useOneDispatchPerCommandBuffer_onceToken, &__block_literal_global_109);
  if (useOneDispatchPerCommandBuffer_setOverride == 1)
  {
    if (!useOneDispatchPerCommandBuffer_result)
    {
      v46 = 0;
      goto LABEL_35;
    }
    goto LABEL_33;
  }
  if (v34 && useOneDispatchPerCommandBuffer_result)
  {
LABEL_33:
    v35 = objc_msgSend(a3, "label");
    a3 = (void *)objc_msgSend((id)objc_msgSend(a3, "commandQueue"), "commandBuffer");
    objc_msgSend(a3, "setLabel:", v35);
    v46 = 1;
    goto LABEL_35;
  }
  v46 = 0;
LABEL_35:
  v47 = v31;
  v36 = (void *)objc_msgSend(a3, "computeCommandEncoder");
  if (a13)
    objc_msgSend(v36, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:"));
  objc_msgSend(v36, "setComputePipelineState:", a4);
  objc_msgSend(v22, "addObject:", a4);
  if (a6)
  {
    v37 = 0;
    do
    {
      v38 = *(void **)(a7 + 8 * v37);
      if (v38)
      {
        if (!objc_msgSend(*(id *)(a7 + 8 * v37), "iosurfacePlane"))
        {
          objc_msgSend(v38, "width");
          objc_msgSend(v38, "height");
        }
        if (v37)
          v39 = a8 + v37;
        else
          v39 = 0;
        objc_msgSend(v36, "setTexture:atIndex:", v38, v39);
        objc_msgSend(v22, "addObject:", v38);
      }
      ++v37;
    }
    while (a6 != v37);
  }
  if (a8)
  {
    v40 = 0;
    do
    {
      v41 = *(_QWORD *)(a11 + 8 * v40);
      objc_msgSend(v36, "setTexture:atIndex:", v41, v40 + 1);
      objc_msgSend(v23, "addObject:", v41);
      v42 = *(_QWORD *)(a12 + 8 * v40);
      objc_msgSend(v36, "setSamplerState:atIndex:", v42, v40);
      objc_msgSend(v22, "addObject:", v42);
      ++v40;
    }
    while (a8 != v40);
  }
  objc_msgSend(v36, "setBuffer:offset:atIndex:", a5, 0, 0);
  objc_msgSend(v22, "addObject:", a5);
  v59[0] = v47;
  v59[1] = v32;
  v59[2] = v45;
  v58[0] = v50;
  v58[1] = v49;
  v58[2] = v48;
  objc_msgSend(v36, "dispatchThreadgroups:threadsPerThreadgroup:", v59, v58);
  objc_msgSend(v36, "endEncoding");
  v43 = MEMORY[0x1E0C809B0];
  v56[0] = MEMORY[0x1E0C809B0];
  v56[1] = 3221225472;
  v56[2] = __CIMetalRenderToTextures_block_invoke;
  v56[3] = &__block_descriptor_60_e28_v16__0___MTLCommandBuffer__8l;
  *(double *)&v56[4] = a9;
  *(double *)&v56[5] = a10;
  v56[6] = a1;
  v57 = a2;
  objc_msgSend(a3, "addScheduledHandler:", v56);
  v54[0] = v43;
  v54[1] = 3221225472;
  v54[2] = __CIMetalRenderToTextures_block_invoke_57;
  v54[3] = &unk_1E2EC4998;
  *(double *)&v54[6] = a9;
  *(double *)&v54[7] = a10;
  v54[8] = a1;
  v55 = a2;
  v54[4] = v23;
  v54[5] = v22;
  result = objc_msgSend(a3, "addCompletedHandler:", v54);
  if ((v46 & 1) != 0)
  {
    objc_msgSend(a3, "commit");
    return objc_msgSend(a3, "waitUntilScheduled");
  }
  return result;
}

uint64_t CIMetalRenderToImageblocks(uint64_t a1, int a2, void *a3, void *a4, uint64_t a5, double a6, double a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  uint64_t v31;
  _QWORD v33[8];
  int v34;
  _QWORD v35[8];
  int v36;
  _QWORD v37[4];

  v30 = a1;
  v20 = (void *)objc_opt_new();
  v21 = *a9;
  v22 = (void *)objc_msgSend(MEMORY[0x1E0CC6B50], "renderPassDescriptor");
  objc_msgSend(v22, "setImageblockSampleLength:", objc_msgSend(a4, "imageblockSampleLength"));
  if (CI_ENABLE_METAL_IMAGEBLOCKS() == 2)
  {
    v23 = (void *)objc_msgSend((id)objc_msgSend(v22, "colorAttachments"), "objectAtIndexedSubscript:", 0);
    objc_msgSend(v23, "setTexture:", v21);
    objc_msgSend(v23, "setStoreAction:", 1);
    if (a6 < (double)(unint64_t)objc_msgSend(v21, "width")
      || a7 < (double)(unint64_t)objc_msgSend(v21, "height"))
    {
      objc_msgSend(v23, "setLoadAction:", 1, v30);
    }
  }
  else
  {
    objc_msgSend(v22, "setDefaultColorSampleCount:", 1);
    objc_msgSend(v22, "setRenderTargetWidth:", objc_msgSend(v21, "width"));
    objc_msgSend(v22, "setRenderTargetHeight:", objc_msgSend(v21, "height"));
  }
  v24 = (void *)objc_msgSend(a3, "renderCommandEncoderWithDescriptor:", v22, v30);
  if (a13)
    objc_msgSend(v24, "setLabel:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a13));
  objc_msgSend(v24, "setRenderPipelineState:", a4);
  objc_msgSend(v20, "addObject:", a4);
  objc_msgSend(v24, "setTileTexture:atIndex:", v21, 0);
  objc_msgSend(v20, "addObject:", v21);
  if (a10)
  {
    v25 = 0;
    do
    {
      v26 = *(_QWORD *)(a11 + 8 * v25);
      objc_msgSend(v24, "setTileTexture:atIndex:", v26, v25 + 1);
      objc_msgSend(v20, "addObject:", v26);
      v27 = *(_QWORD *)(a12 + 8 * v25);
      objc_msgSend(v24, "setTileSamplerState:atIndex:", v27, v25);
      objc_msgSend(v20, "addObject:", v27);
      ++v25;
    }
    while (a10 != v25);
  }
  objc_msgSend(v24, "setTileBuffer:offset:atIndex:", a5, 0, 0);
  objc_msgSend(v20, "addObject:", a5);
  v37[0] = objc_msgSend(v24, "tileWidth");
  v37[1] = objc_msgSend(v24, "tileHeight");
  v37[2] = 1;
  objc_msgSend(v24, "dispatchThreadsPerTile:", v37);
  objc_msgSend(v24, "endEncoding");
  v28 = MEMORY[0x1E0C809B0];
  v35[0] = MEMORY[0x1E0C809B0];
  v35[1] = 3221225472;
  v35[2] = __CIMetalRenderToImageblocks_block_invoke;
  v35[3] = &unk_1E2EC49C0;
  v35[4] = a3;
  *(double *)&v35[5] = a6;
  *(double *)&v35[6] = a7;
  v35[7] = v31;
  v36 = a2;
  objc_msgSend(a3, "addScheduledHandler:", v35);
  v33[0] = v28;
  v33[1] = 3221225472;
  v33[2] = __CIMetalRenderToImageblocks_block_invoke_64;
  v33[3] = &unk_1E2EC49C0;
  *(double *)&v33[5] = a6;
  *(double *)&v33[6] = a7;
  v33[7] = v31;
  v34 = a2;
  v33[4] = v20;
  return objc_msgSend(a3, "addCompletedHandler:", v33);
}

void __CIMetalRenderToImageblocks_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  os_signpost_id_t v5;
  NSObject *v6;
  double v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  unsigned int v12;
  __int16 v13;
  unsigned int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (CI_KDEBUG())
    kdebug_trace();
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v4 = ci_signpost_log_render();
    v5 = *(int *)(a1 + 64) | (*(_QWORD *)(a1 + 56) << 32);
    if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v6 = v4;
      if (os_signpost_enabled(v4))
      {
        v7 = *(double *)(a1 + 48);
        v8 = *(double *)(a1 + 40);
        v9 = 134218496;
        v10 = a2;
        v11 = 1024;
        v12 = v8;
        v13 = 1024;
        v14 = v7;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v6, OS_SIGNPOST_INTERVAL_BEGIN, v5, "gpu_compute", "cb:%p [%u, %u]", (uint8_t *)&v9, 0x18u);
      }
    }
  }
}

void __CIMetalRenderToImageblocks_block_invoke_64(uint64_t a1, void *a2)
{
  NSObject *v4;
  os_signpost_id_t v5;
  NSObject *v6;
  double v7;
  unsigned int v8;
  int v9;
  void *v10;
  __int16 v11;
  unsigned int v12;
  __int16 v13;
  unsigned int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (CI_KDEBUG())
    kdebug_trace();
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v4 = ci_signpost_log_render();
    v5 = *(int *)(a1 + 64) | (*(_QWORD *)(a1 + 56) << 32);
    if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v6 = v4;
      if (os_signpost_enabled(v4))
      {
        v7 = *(double *)(a1 + 48);
        v8 = *(double *)(a1 + 40);
        v9 = 134218496;
        v10 = a2;
        v11 = 1024;
        v12 = v8;
        v13 = 1024;
        v14 = v7;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v6, OS_SIGNPOST_INTERVAL_END, v5, "gpu_compute", "cb:%p [%u, %u]", (uint8_t *)&v9, 0x18u);
      }
    }
  }
  CIAbortIfICSAndUnsuccessfulCommandBufferExecution(a2);

}

void CIAbortIfICSAndUnsuccessfulCommandBufferExecution(void *a1)
{
  const char *v2;
  NSObject *v3;
  NSObject *v4;

  if (objc_msgSend(a1, "status") == 5)
  {
    if (objc_msgSend(a1, "label"))
      v2 = (const char *)objc_msgSend((id)objc_msgSend(a1, "label"), "UTF8String");
    else
      v2 = "";
    if (objc_msgSend(a1, "error"))
    {
      v3 = ci_logger_render();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        CIAbortIfICSAndUnsuccessfulCommandBufferExecution_cold_2(a1, (uint64_t)v2, v3);
    }
    if (isImageConversionServiceProcess_onceToken != -1)
      dispatch_once(&isImageConversionServiceProcess_onceToken, &__block_literal_global_51);
    if (isImageConversionServiceProcess_isICS)
    {
      v4 = ci_logger_render();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        CIAbortIfICSAndUnsuccessfulCommandBufferExecution_cold_1();
      exit(1);
    }
  }
}

void *CIMetalCommandBufferAddCompletionHandler(void *result, uint64_t a2)
{
  _QWORD v2[5];

  if (a2)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = __CIMetalCommandBufferAddCompletionHandler_block_invoke;
    v2[3] = &unk_1E2EC49E8;
    v2[4] = a2;
    return (void *)objc_msgSend(result, "addCompletedHandler:", v2);
  }
  return result;
}

void *CIMetalCommandBufferCopyTexture(void *result, uint64_t a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  void *v17;
  _QWORD v18[3];
  _QWORD v19[3];
  _QWORD v20[3];

  if (a2 && result)
  {
    if (a3)
    {
      v17 = (void *)objc_msgSend(result, "blitCommandEncoder");
      v20[0] = (unint64_t)a6;
      v20[1] = (unint64_t)a7;
      v20[2] = 0;
      v19[0] = (unint64_t)a8;
      v19[1] = (unint64_t)a9;
      v19[2] = 1;
      v18[0] = (unint64_t)a4;
      v18[1] = (unint64_t)a5;
      v18[2] = 0;
      objc_msgSend(v17, "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:", a3, 0, 0, v20, v19, a2, 0, 0, v18);
      return (void *)objc_msgSend(v17, "endEncoding");
    }
  }
  return result;
}

void CIMetalCommandBufferWaitUntilScheduled(void *a1)
{
  if ((unint64_t)objc_msgSend(a1, "status") < 2)
    NSLog(CFSTR("Metal command buffer was not committed due to some compile/render failure.\n"));
  else
    objc_msgSend(a1, "waitUntilScheduled");
}

void CIMetalCommandBufferWaitUntilCompleted(void *a1)
{
  if ((unint64_t)objc_msgSend(a1, "status") < 2)
    NSLog(CFSTR("Metal command buffer was not committed due to some compile/render failure.\n"));
  else
    objc_msgSend(a1, "waitUntilCompleted");
}

unint64_t CIMetalCommandBufferGetGPUTime(void *a1)
{
  unint64_t result;

  result = objc_msgSend(a1, "status");
  if (result >= 4)
  {
    objc_msgSend(a1, "GPUEndTime", -1.0);
    return objc_msgSend(a1, "GPUStartTime");
  }
  return result;
}

void __serializeHarvestedBinaryArchiveExit_block_invoke(uint64_t a1)
{
  serializeBinaryArchive(*(void **)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void serializeBinaryArchive(void *a1, uint64_t a2)
{
  char v3;
  NSObject *v4;
  NSObject *v5;
  id v6;
  uint8_t buf[4];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  v3 = objc_msgSend(a1, "serializeToURL:error:", objc_msgSend(MEMORY[0x1E0C99E98], "URLWithString:", a2), &v6);
  v4 = ci_logger_render();
  v5 = v4;
  if ((v3 & 1) != 0)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138543362;
      v8 = a2;
      _os_log_impl(&dword_1921E4000, v5, OS_LOG_TYPE_INFO, "Serialized binary archive to %{public}@\n", buf, 0xCu);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    serializeBinaryArchive_cold_1(a2, &v6, v5);
  }
}

void ArchiveLibrary(void *a1, uint64_t a2, uint64_t a3)
{
  int v6;
  void *v7;
  void *v8;
  uint64_t v9;
  int v10;
  void *v11;
  void *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD block[5];
  uint8_t buf[4];
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v6 = CI_HARVEST_BIN_ARCHIVE();
  if (a2 && v6 == 1)
  {
    v7 = (void *)objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __ArchiveLibrary_block_invoke;
    block[3] = &unk_1E2EC3CC8;
    block[4] = v7;
    if (ArchiveLibrary_onceToken != -1)
      dispatch_once(&ArchiveLibrary_onceToken, block);
    v8 = (void *)objc_msgSend(v7, "temporaryDirectory");
    v9 = objc_msgSend(v8, "URLByAppendingPathComponent:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%s/ci_%016llX.metallib"), CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME(), a2));
    v21 = 0;
    v10 = CI_ADD_PROCESS_NAME_TO_BIN_ARCHIVE();
    v11 = (void *)objc_msgSend(v7, "temporaryDirectory");
    v12 = (void *)MEMORY[0x1E0CB3940];
    v13 = CI_HARVEST_BIN_ARCHIVE_FOLDER_NAME();
    if (v10)
      v14 = objc_msgSend(v12, "stringWithFormat:", CFSTR("%s/ci_%016llX_%@.txt"), v13, a2, objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB3898], "processInfo"), "processName"));
    else
      v14 = objc_msgSend(v12, "stringWithFormat:", CFSTR("%s/ci_%016llX.txt"), v13, a2, v20);
    v15 = objc_msgSend((id)objc_msgSend(v11, "URLByAppendingPathComponent:", v14), "path");
    if ((objc_msgSend(v7, "createFileAtPath:contents:attributes:", v15, objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("0x%016llX %s\n"), a2, a3), "dataUsingEncoding:", 4), 0) & 1) == 0)
    {
      v16 = ci_logger_render();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        ArchiveLibrary_cold_2();
    }
    objc_msgSend(a1, "serializeToURL:error:", v9, &v21);
    v17 = v21;
    v18 = ci_logger_render();
    v19 = v18;
    if (v17)
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        ArchiveLibrary_cold_1();
    }
    else if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138543618;
      v24 = v9;
      v25 = 2082;
      v26 = a3;
      _os_log_impl(&dword_1921E4000, v19, OS_LOG_TYPE_INFO, "CI library serialized to : %{public}@ for %{public}s", buf, 0x16u);
    }
  }
}

void *__isHarvestingForThisProcess_block_invoke(uint64_t a1)
{
  void *v1;
  void *result;

  v1 = (void *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", *(_QWORD *)(a1 + 32), 1);
  result = (void *)objc_msgSend(MEMORY[0x1E0CB3898], "processInfo");
  if (result)
    result = (void *)objc_msgSend(v1, "containsString:", objc_msgSend(result, "processName"));
  isHarvestingForThisProcess_isListed = (char)result;
  return result;
}

void __scheduleSerializingHarvestedBinaryArchive_block_invoke(uint64_t a1)
{
  NSObject *v1;
  _QWORD v2[4];
  __int128 v3;

  v1 = *(NSObject **)(a1 + 32);
  v2[0] = MEMORY[0x1E0C809B0];
  v2[1] = 3221225472;
  v2[2] = __scheduleSerializingHarvestedBinaryArchive_block_invoke_2;
  v2[3] = &unk_1E2EC2EE0;
  v3 = *(_OWORD *)(a1 + 40);
  dispatch_sync(v1, v2);
}

void __scheduleSerializingHarvestedBinaryArchive_block_invoke_2(uint64_t a1)
{
  serializeBinaryArchive(*(void **)(a1 + 32), *(_QWORD *)(a1 + 40));
  scheduleSerializingHarvestedBinaryArchive_serialization_pending = 0;
}

uint64_t __configureQueue_block_invoke(uint64_t result, void *a2, void *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  _QWORD *v14;

  if (a4)
  {
    v6 = result;
    v7 = objc_msgSend(a3, "bytes");
    v8 = 0;
    v9 = 0;
    v10 = *(_QWORD *)(v6 + 32);
    v11 = 2 * v10;
    v12 = v7 + 8 * v10;
    v13 = 0.0;
    do
    {
      v14 = (_QWORD *)(v12 + 8 * v8);
      v13 = v13 + (double)(unint64_t)(*v14 - *(_QWORD *)(v7 + 8 * v8));
      v9 = v9 - *(_QWORD *)(v7 + ((8 * v8) | 8)) + v14[1];
      v8 += v11;
    }
    while (v8 < a4);
    result = objc_msgSend((id)objc_msgSend(a2, "userDictionary"), "objectForKeyedSubscript:", CFSTR("RendererStatsPerfCallback"));
    if (result)
      return (*(uint64_t (**)(uint64_t, uint64_t, unint64_t))(result + 16))(result, v9, (unint64_t)v13);
  }
  return result;
}

void *__useOneDispatchPerCommandBuffer_block_invoke()
{
  void *result;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;

  result = (void *)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0C99EA0], "standardUserDefaults"), "objectForKey:", CFSTR("com.apple.coreimage.perDispatchCommandBuffer"));
  if (result)
  {
    v1 = objc_msgSend(result, "BOOLValue");
    useOneDispatchPerCommandBuffer_result = v1;
    useOneDispatchPerCommandBuffer_setOverride = 1;
    v9 = "NO";
    if ((_DWORD)v1)
      v9 = "YES";
    return (void *)x_log(v1, v2, v3, v4, v5, v6, v7, v8, (char)v9);
  }
  return result;
}

uint64_t x_log(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return vfprintf((FILE *)*MEMORY[0x1E0C80C10], "com.apple.coreimage.perDispatchCommandBuffer: %s\n", &a9);
}

uint64_t OUTLINED_FUNCTION_8_2(id *a1)
{
  return objc_msgSend(*a1, "localizedDescription");
}

void OUTLINED_FUNCTION_12_1(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x1Cu);
}

double cikernel::_minimumComponent(__n128 a1, double a2)
{
  double result;

  *(float *)&a2 = fminf(fminf(a1.n128_f32[0], a1.n128_f32[1]), a1.n128_f32[2]);
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

double cikernel::_maximumComponent(__n128 a1, double a2)
{
  double result;

  *(float *)&a2 = fmaxf(fmaxf(a1.n128_f32[0], a1.n128_f32[1]), a1.n128_f32[2]);
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)&a2, 0).u64[0];
  return result;
}

__n128 extendDOD@<Q0>(uint64_t a1@<X0>, _OWORD *a2@<X8>, float32x2_t a3@<D0>, float32x2_t a4@<D1>, __n128 a5@<Q2>, int8x16_t a6@<Q3>, int8x16_t a7@<Q4>)
{
  __int128 v11;
  float32x2_t v12;
  int32x2_t v13;
  int32x2_t v14;
  __int128 v15;
  __n128 result;
  __int128 v17;
  float32x2_t v20;
  __int128 v21;
  __int128 v22;
  float32x2_t v23;

  v23 = vsub_f32(a3, *(float32x2_t *)a6.i8);
  if ((float)(a5.n128_f32[2] + vaddv_f32(vmul_f32((float32x2_t)a5.n128_u64[0], v23))) < 0.001)
  {
    Rectangle::Union((Rectangle *)a1, (const vec2 *)&v23, (uint64_t)&v21);
    if (&v21 != (__int128 *)a1)
    {
      v11 = v22;
      *(_OWORD *)a1 = v21;
      *(_OWORD *)(a1 + 16) = v11;
    }
    v12 = vsub_f32(vsub_f32(a3, a4), (float32x2_t)*(_OWORD *)&vextq_s8(a6, a6, 8uLL));
    v13 = (int32x2_t)vmul_f32(v12, *(float32x2_t *)a7.i8);
    v14 = (int32x2_t)vmul_f32(v12, (float32x2_t)*(_OWORD *)&vextq_s8(a7, a7, 8uLL));
    v23 = vadd_f32((float32x2_t)vzip1_s32(v13, v14), (float32x2_t)vzip2_s32(v13, v14));
    v20 = vadd_f32(a4, v23);
    Rectangle::Union((Rectangle *)a1, (const vec2 *)&v20, (uint64_t)&v21);
    if (&v21 != (__int128 *)a1)
    {
      v15 = v22;
      *(_OWORD *)a1 = v21;
      *(_OWORD *)(a1 + 16) = v15;
    }
  }
  result = *(__n128 *)a1;
  v17 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v17;
  return result;
}

float32x2_t cikernel::_mirror(CI *a1, float32x2_t a2, __n128 a3, int8x16_t a4, int8x16_t a5)
{
  float32x2_t *DC;
  float v7;
  float32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  double v11;
  double v12;

  DC = (float32x2_t *)CI::getDC(a1);
  v7 = a3.n128_f32[2] + vaddv_f32(vmul_f32((float32x2_t)a3.n128_u64[0], *DC));
  v8 = vsub_f32(*(float32x2_t *)CI::getDC((CI *)DC), a2);
  v9 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, v8);
  v10 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a5, a5, 8uLL), v8);
  v11 = COERCE_DOUBLE(vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), vadd_f32((float32x2_t)vzip1_s32(v9, v10), (float32x2_t)vzip2_s32(v9, v10))));
  v12 = COERCE_DOUBLE(vadd_f32(*(float32x2_t *)a4.i8, v8));
  if (v7 >= 0.0)
    v12 = v11;
  return vadd_f32(a2, *(float32x2_t *)&v12);
}

