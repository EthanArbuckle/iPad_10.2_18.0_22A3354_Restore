void CI::f2_f2_f3_f4_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(_QWORD *, double, __n128, __n128, __n128);
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  double *v20;

  v9 = a1[6];
  v10 = (double (*)(_QWORD *, double, __n128, __n128, __n128))a1[3];
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_QWORD *)(v9 + 32);
  v14 = *(_DWORD *)(v9 + 64);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_DWORD *)(v9 + 88);
  v17 = *(_QWORD *)(v9 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 104)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v15);
  v20 = (double *)(a3 + 16 * v12);
  if (v11 != 5)
    v20 = (double *)((char *)a2 + 64 * v12);
  *(double *)(a3 + 16 * a7) = v10(a1, *v20, *((__n128 *)a2 + 4 * v13), *v19, *v18);
}

float64_t Rectangle::Union@<D0>(Rectangle *this@<X0>, const vec2 *a2@<X1>, uint64_t a3@<X8>)
{
  double var0;
  double var1;
  float64x2_t v5;
  BOOL v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;

  var0 = this->var0;
  if (fabs(this->var0) == INFINITY || (var1 = this->var1, fabs(var1) == INFINITY))
  {
    v5 = vcvtq_f64_f32(*(float32x2_t *)a2);
    *(float64x2_t *)a3 = v5;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)(a3 + 24) = 0;
  }
  else
  {
    v6 = var0 == -8.98846567e307 && var1 == -8.98846567e307;
    if (v6 && this->var2 == 1.79769313e308 && this->var3 == 1.79769313e308)
    {
      v5 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
      *(float64x2_t *)a3 = v5;
      *(int64x2_t *)(a3 + 16) = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    }
    else
    {
      v7 = var0 + this->var2;
      v8 = COERCE_FLOAT(*(_QWORD *)a2);
      v9 = fmin(fmin(var0, v7), v8);
      v10 = var1 + this->var3;
      v11 = COERCE_FLOAT(HIDWORD(*(_QWORD *)a2));
      v12 = fmin(fmin(var1, v10), v11);
      v5.f64[0] = fmax(fmax(var0, v7), v8) - v9;
      *(double *)a3 = v9;
      *(double *)(a3 + 8) = v12;
      *(float64_t *)(a3 + 16) = v5.f64[0];
      *(double *)(a3 + 24) = fmax(fmax(var1, v10), v11) - v12;
    }
  }
  return v5.f64[0];
}

__n128 extendROI@<Q0>(uint64_t a1@<X0>, _OWORD *a2@<X8>, float32x2_t a3@<D0>, float32x2_t a4@<D1>, __n128 a5@<Q2>, int8x16_t a6@<Q3>, int8x16_t a7@<Q4>)
{
  float v9;
  float32x2_t v10;
  BOOL v11;
  int32x2_t v12;
  int32x2_t v13;
  double v14;
  double v15;
  __int128 v16;
  __n128 result;
  __int128 v18;
  _OWORD v19[2];
  float32x2_t v20;

  if ((float)(a5.n128_f32[2] + vaddv_f32(vmul_f32((float32x2_t)a5.n128_u64[0], vsub_f32(a3, *(float32x2_t *)a6.i8)))) < 0.001)
  {
    v9 = a5.n128_f32[2] + vaddv_f32(vmul_f32(a3, (float32x2_t)a5.n128_u64[0]));
    v10 = vsub_f32(a3, a4);
    v11 = v9 < 0.0;
    v12 = (int32x2_t)vmul_f32(v10, *(float32x2_t *)a7.i8);
    v13 = (int32x2_t)vmul_f32(v10, (float32x2_t)*(_OWORD *)&vextq_s8(a7, a7, 8uLL));
    v14 = COERCE_DOUBLE(vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a6, a6, 8uLL), vadd_f32((float32x2_t)vzip1_s32(v12, v13), (float32x2_t)vzip2_s32(v12, v13))));
    v15 = COERCE_DOUBLE(vadd_f32(v10, *(float32x2_t *)a6.i8));
    if (!v11)
      v15 = v14;
    v20 = vadd_f32(a4, *(float32x2_t *)&v15);
    Rectangle::Union((Rectangle *)a1, (const vec2 *)&v20, (uint64_t)v19);
    if (v19 != (_OWORD *)a1)
    {
      v16 = v19[1];
      *(_OWORD *)a1 = v19[0];
      *(_OWORD *)(a1 + 16) = v16;
    }
  }
  result = *(__n128 *)a1;
  v18 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v18;
  return result;
}

double cikernel::_modTransition(CI *a1, float32x4_t a2, float32x4_t a3, float32x2_t a4, float32x4_t a5, int8x16_t a6, __n128 a7, __n128 a8)
{
  float32x2_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  int32x2_t v14;
  int32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v23;
  float32x2_t v24;
  float v25;
  float v26;
  float v27;
  double result;

  v9 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a4);
  v10 = vmuls_lane_f32(v9.f32[0], a5, 2);
  v11 = a7.n128_f32[3] + (float)(a7.n128_f32[2] / vmlas_n_f32(a7.n128_f32[1], v10, a7.n128_f32[0]));
  v12 = a8.n128_f32[3] + (float)(a8.n128_f32[2] / vmlas_n_f32(a8.n128_f32[1], v10, a8.n128_f32[0]));
  if (v10 >= 0.5)
    v13 = v12;
  else
    v13 = v11;
  v9.i32[0] = vmuls_lane_f32(v13, a5, 3);
  v14 = (int32x2_t)vmul_f32(*(float32x2_t *)a6.i8, v9);
  v15 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a6, a6, 8uLL), v9);
  v16 = vadd_f32(a4, vadd_f32((float32x2_t)vzip1_s32(v14, v15), (float32x2_t)vzip2_s32(v14, v15)));
  v17 = vminnm_f32(vsub_f32(v16, vrndm_f32(v16)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  __asm { FMOV            V1.2S, #1.0 }
  v23 = vminnm_f32(v17, vsub_f32(_D1, v17));
  v24 = vadd_f32(v23, v23);
  v25 = vmlas_n_f32(a5.f32[1], sqrtf(vaddv_f32(vmul_f32(v24, v24))), a5.f32[0]);
  if (v25 <= 1.0)
    v26 = v25;
  else
    v26 = 1.0;
  _NF = v25 < 0.0;
  v27 = 0.0;
  if (!_NF)
    v27 = v26;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a3, 1.0 - v27), a2, v27).u64[0];
  return result;
}

void CI::f4_s_s_f2_f4_f4_f4_f4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, double, __n128, __n128, __n128, __n128);
  int v11;
  uint64_t v12;
  int v13;
  const vec2 *v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  __n128 *v25;
  __n128 *v26;
  __n128 *v27;
  __n128 *v28;
  double *v29;
  double *v30;
  __n128 *v31;
  __n128 *v32;
  __int128 v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  double (*v39)(__n128, __n128, double, __n128, __n128, __n128, __n128);
  const vec2 *v40;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, double, __n128, __n128, __n128, __n128))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(const vec2 **)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  v19 = *(_DWORD *)(v9 + 112);
  v20 = *(_QWORD *)(v9 + 104);
  v21 = *(_DWORD *)(v9 + 136);
  v22 = *(_QWORD *)(v9 + 128);
  v23 = *(_DWORD *)(v9 + 160);
  v24 = *(_QWORD *)(v9 + 152);
  if (*(_BYTE *)(a1 + 64))
  {
    v39 = *(double (**)(__n128, __n128, double, __n128, __n128, __n128, __n128))(a1 + 24);
    v40 = *(const vec2 **)(v9 + 32);
    v37 = *(_QWORD *)(v9 + 8);
    v38 = *(_QWORD *)(v9 + 56);
    v36 = *(_DWORD *)(v9 + 112);
    v35 = *(_QWORD *)(v9 + 80);
    v34 = *(_DWORD *)(v9 + 160);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 176)), v14);
    v23 = v34;
    v18 = v35;
    v19 = v36;
    v12 = v37;
    v16 = v38;
    v10 = v39;
    v14 = v40;
  }
  v25 = (__n128 *)(a3 + 16 * v24);
  if (v23 != 5)
    v25 = (__n128 *)(a2 + (v24 << 6));
  v26 = (__n128 *)(a3 + 16 * v22);
  if (v21 != 5)
    v26 = (__n128 *)(a2 + (v22 << 6));
  v27 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5)
    v27 = (__n128 *)(a2 + (v20 << 6));
  v28 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v28 = (__n128 *)(a2 + (v18 << 6));
  v29 = (double *)(a3 + 16 * v16);
  v30 = (double *)(a2 + (v16 << 6));
  if (v15 != 5)
    v29 = v30;
  v31 = (__n128 *)(a3 + 16 * (_QWORD)v14);
  if (v13 != 5)
    v31 = (__n128 *)(a2 + ((_QWORD)v14 << 6));
  v32 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v32 = (__n128 *)(a2 + (v12 << 6));
  *(double *)&v33 = v10(*v32, *v31, *v29, *v28, *v27, *v26, *v25);
  *(_OWORD *)(a3 + 16 * a7) = v33;
}

double cikernel::_maxDisk(cikernel *this, SamplerObj *a2, float a3)
{
  CI *DC;
  float32x2_t v6;
  float32x2_t *v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  float64x2_t v13;
  double v14;
  int8x16_t v15;
  float32x4_t v16;
  float64x2_t v17;
  __int128 v18;
  int8x16_t v19;
  uint8x8_t v20;
  double v21;
  int8x16_t v22;
  float32x4_t v23;
  float v24;
  float v25;
  float32x2_t v26;
  float32x4_t v27;
  __int128 v29;
  int8x16_t v30;
  float32x4_t v31;

  DC = (CI *)CI::getDC(this);
  v6 = *(float32x2_t *)DC;
  v7 = (float32x2_t *)CI::getDC(DC);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *v7, 1), *((float *)this + 4), COERCE_FLOAT(*v7));
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *v7, 1), *(float *)&v9, COERCE_FLOAT(*v7));
  *(float *)&v12 = *((float *)this + 6) + *(float *)&v8;
  *(float *)v13.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  *((float *)&v12 + 1) = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v12, v13, v8, v9, v11, v10, v14, v15);
  v23 = v16;
  v24 = ceilf(a3);
  if (v24 >= 0.0)
  {
    v25 = a3 * a3;
    *(float *)&v18 = -v24;
    do
    {
      *(float *)v19.i32 = -v24;
      v29 = v18;
      do
      {
        *(float32x2_t *)&v17.f64[0] = vmul_f32((float32x2_t)__PAIR64__(v19.u32[0], v18), (float32x2_t)__PAIR64__(v19.u32[0], v18));
        if (vaddv_f32(*(float32x2_t *)&v17.f64[0]) <= v25)
        {
          v26 = vadd_f32(v6, (float32x2_t)__PAIR64__(v19.u32[0], v18));
          v30 = v19;
          v31 = v23;
          v23.f32[0] = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v26, 1), *((float *)this + 4), v26.f32[0]);
          LODWORD(v18) = *((_DWORD *)this + 7);
          v20.i32[0] = *((_DWORD *)this + 9);
          *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v26, 1), *(float *)&v18, v26.f32[0]);
          v26.f32[0] = *((float *)this + 6) + v23.f32[0];
          *(float *)v17.f64 = *(float *)v20.i32 + *(float *)v19.i32;
          v26.f32[1] = *(float *)v20.i32 + *(float *)v19.i32;
          *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v26, v17, *(double *)v23.i64, *(double *)&v18, v19, v20, v21, v22);
          v18 = v29;
          v19 = v30;
          v23 = vmaxnmq_f32(v31, v27);
        }
        *(float *)v19.i32 = *(float *)v19.i32 + 1.0;
      }
      while (*(float *)v19.i32 <= v24);
      *(float *)&v18 = *(float *)&v18 + 1.0;
    }
    while (*(float *)&v18 <= v24);
  }
  return *(double *)v23.i64;
}

double cikernel::_minDisk(cikernel *this, SamplerObj *a2, float a3)
{
  CI *DC;
  float32x2_t v6;
  float32x2_t *v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  float64x2_t v13;
  double v14;
  int8x16_t v15;
  float32x4_t v16;
  float64x2_t v17;
  __int128 v18;
  int8x16_t v19;
  uint8x8_t v20;
  double v21;
  int8x16_t v22;
  float32x4_t v23;
  float v24;
  float v25;
  float32x2_t v26;
  float32x4_t v27;
  __int128 v29;
  int8x16_t v30;
  float32x4_t v31;

  DC = (CI *)CI::getDC(this);
  v6 = *(float32x2_t *)DC;
  v7 = (float32x2_t *)CI::getDC(DC);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *v7, 1), *((float *)this + 4), COERCE_FLOAT(*v7));
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *v7, 1), *(float *)&v9, COERCE_FLOAT(*v7));
  *(float *)&v12 = *((float *)this + 6) + *(float *)&v8;
  *(float *)v13.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  *((float *)&v12 + 1) = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v12, v13, v8, v9, v11, v10, v14, v15);
  v23 = v16;
  v24 = ceilf(a3);
  if (v24 >= 0.0)
  {
    v25 = a3 * a3;
    *(float *)&v18 = -v24;
    do
    {
      *(float *)v19.i32 = -v24;
      v29 = v18;
      do
      {
        *(float32x2_t *)&v17.f64[0] = vmul_f32((float32x2_t)__PAIR64__(v19.u32[0], v18), (float32x2_t)__PAIR64__(v19.u32[0], v18));
        if (vaddv_f32(*(float32x2_t *)&v17.f64[0]) <= v25)
        {
          v26 = vadd_f32(v6, (float32x2_t)__PAIR64__(v19.u32[0], v18));
          v30 = v19;
          v31 = v23;
          v23.f32[0] = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v26, 1), *((float *)this + 4), v26.f32[0]);
          LODWORD(v18) = *((_DWORD *)this + 7);
          v20.i32[0] = *((_DWORD *)this + 9);
          *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v26, 1), *(float *)&v18, v26.f32[0]);
          v26.f32[0] = *((float *)this + 6) + v23.f32[0];
          *(float *)v17.f64 = *(float *)v20.i32 + *(float *)v19.i32;
          v26.f32[1] = *(float *)v20.i32 + *(float *)v19.i32;
          *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v26, v17, *(double *)v23.i64, *(double *)&v18, v19, v20, v21, v22);
          v18 = v29;
          v19 = v30;
          v23 = vminnmq_f32(v31, v27);
        }
        *(float *)v19.i32 = *(float *)v19.i32 + 1.0;
      }
      while (*(float *)v19.i32 <= v24);
      *(float *)&v18 = *(float *)&v18 + 1.0;
    }
    while (*(float *)&v18 <= v24);
  }
  return *(double *)v23.i64;
}

double cikernel::_max3x3(uint64_t a1, int8x16_t a2)
{
  int8x16_t v3;
  float64x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  float64x2_t v13;
  float32x2_t v14;
  double v15;
  double v16;
  uint8x8_t v17;
  int8x16_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  double v22;
  float32x2_t v23;
  float32x2_t v24;
  double v25;
  int8x16_t v26;
  double v27;
  uint8x8_t v28;
  float64x2_t v29;
  int8x16_t v30;
  float32x4_t v31;
  double v32;
  float32x2_t v33;
  double v34;
  int8x16_t v35;
  double v36;
  uint8x8_t v37;
  float64x2_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float64x2_t v41;
  double v42;
  double v43;
  uint8x8_t v44;
  double v45;
  int8x16_t v46;
  float32x4_t v47;
  double v48;
  float32x2_t v49;
  double v50;
  int8x16_t v51;
  double v52;
  uint8x8_t v53;
  float64x2_t v54;
  int8x16_t v55;
  float32x4_t v56;
  float32x2_t v57;
  double v58;
  double v59;
  int8x16_t v60;
  double v61;
  uint8x8_t v62;
  float64x2_t v63;
  int8x16_t v64;
  float32x4_t v65;
  float32x2_t v66;
  double v67;
  double v68;
  int8x16_t v69;
  double v70;
  uint8x8_t v71;
  float64x2_t v72;
  int8x16_t v73;
  float32x4_t v74;
  float32x2_t v75;
  double v76;
  double v77;
  int8x16_t v78;
  double v79;
  uint8x8_t v80;
  float64x2_t v81;
  int8x16_t v82;
  float32x4_t v83;
  double result;
  float32x4_t v85;
  float32x4_t v86;
  int8x8_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  int8x16_t v94;
  float32x4_t v95;

  v3.i64[0] = *(_QWORD *)CI::getDC((CI *)a1);
  v94 = v3;
  v4 = (float64x2_t)a2;
  v5 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)a2.i8, 1);
  *(float32x2_t *)v3.i8 = vsub_f32(*(float32x2_t *)v3.i8, v5);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v3.i8, 1), *(float *)(a1 + 16), *(float *)v3.i32);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v3.i8, 1), *(float *)&v7, *(float *)v3.i32);
  *(float *)v3.i32 = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  *(float *)&v3.i32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v3.i64, v4, v6, v7, v9, v8, v10, v11);
  v85 = v12;
  v13 = (float64x2_t)vextq_s8(a2, a2, 8uLL);
  v87 = *(int8x8_t *)&v13.f64[0];
  v14 = (float32x2_t)vext_s8(*(int8x8_t *)&v13.f64[0], *(int8x8_t *)a2.i8, 4uLL);
  *(float32x2_t *)v12.f32 = vsub_f32(*(float32x2_t *)v94.i8, v14);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v16, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v15;
  *(float *)v13.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v12.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v13, v15, v16, v18, v17, v19, v20);
  HIDWORD(v22) = a2.i32[1];
  v23 = (float32x2_t)vext_s8(*(int8x8_t *)a2.i8, v87, 4uLL);
  v24 = vadd_f32(v23, *(float32x2_t *)v94.i8);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v24, 1), *(float *)(a1 + 16), v24.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 24);
  v26.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v27) = *(_DWORD *)(a1 + 36);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v24, 1), *(float *)v26.i32, v24.f32[0]);
  v29 = (float64x2_t)v85;
  v86 = vmaxnmq_f32(v85, v21);
  v21.f32[0] = *(float *)&v22 + *(float *)&v25;
  *(float *)v29.f64 = *(float *)&v27 + *(float *)v28.i32;
  v21.f32[1] = *(float *)&v27 + *(float *)v28.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v29, v22, v25, v26, v28, v27, v30);
  a2.i64[0] = __PAIR64__(v87.u32[1], a2.u32[0]);
  v32 = *(double *)a2.i64;
  v33 = vsub_f32(*(float32x2_t *)v94.i8, *(float32x2_t *)a2.i8);
  *(float *)&v34 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v33, 1), *(float *)(a1 + 16), v33.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 24);
  v35.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v36) = *(_DWORD *)(a1 + 36);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v33, 1), *(float *)v35.i32, v33.f32[0]);
  v38 = (float64x2_t)v86;
  v88 = vmaxnmq_f32(v86, v31);
  v31.f32[0] = *(float *)&v32 + *(float *)&v34;
  *(float *)v38.f64 = *(float *)&v36 + *(float *)v37.i32;
  v31.f32[1] = *(float *)&v36 + *(float *)v37.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v31.i64, v38, v32, v34, v35, v37, v36, v39);
  v41 = (float64x2_t)v88;
  v89 = vmaxnmq_f32(v88, v40);
  LODWORD(v42) = *(_DWORD *)(a1 + 28);
  v40.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v94.i8, 1), *(float *)(a1 + 16), *(float *)v94.i32);
  LODWORD(v43) = *(_DWORD *)(a1 + 36);
  *(float *)v41.f64 = *(float *)&v43
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v94.i8, 1), *(float *)&v42, *(float *)v94.i32);
  v40.i32[1] = LODWORD(v41.f64[0]);
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v40.i64, v41, v42, v43, v94, v44, v45, v46);
  HIDWORD(v48) = a2.i32[1];
  v49 = vadd_f32(*(float32x2_t *)a2.i8, *(float32x2_t *)v94.i8);
  *(float *)&v50 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v49, 1), *(float *)(a1 + 16), v49.f32[0]);
  LODWORD(v48) = *(_DWORD *)(a1 + 24);
  v51.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v52) = *(_DWORD *)(a1 + 36);
  *(float *)v53.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v49, 1), *(float *)v51.i32, v49.f32[0]);
  v54 = (float64x2_t)v89;
  v91 = vmaxnmq_f32(v89, v47);
  v47.f32[0] = *(float *)&v48 + *(float *)&v50;
  *(float *)v54.f64 = *(float *)&v52 + *(float *)v53.i32;
  v47.f32[1] = *(float *)&v52 + *(float *)v53.i32;
  *(double *)v56.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v47.i64, v54, v48, v50, v51, v53, v52, v55);
  v57 = vsub_f32(*(float32x2_t *)v94.i8, v23);
  *(float *)&v58 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v57, 1), *(float *)(a1 + 16), v57.f32[0]);
  LODWORD(v59) = *(_DWORD *)(a1 + 24);
  v60.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v61) = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v57, 1), *(float *)v60.i32, v57.f32[0]);
  v63 = (float64x2_t)v91;
  v92 = vmaxnmq_f32(v91, v56);
  v56.f32[0] = *(float *)&v59 + *(float *)&v58;
  *(float *)v63.f64 = *(float *)&v61 + *(float *)v62.i32;
  v56.f32[1] = *(float *)&v61 + *(float *)v62.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v56.i64, v63, v59, v58, v60, v62, v61, v64);
  v66 = vadd_f32(v14, *(float32x2_t *)v94.i8);
  *(float *)&v67 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v66, 1), *(float *)(a1 + 16), v66.f32[0]);
  LODWORD(v68) = *(_DWORD *)(a1 + 24);
  v69.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v70) = *(_DWORD *)(a1 + 36);
  *(float *)v71.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v66, 1), *(float *)v69.i32, v66.f32[0]);
  v72 = (float64x2_t)v92;
  v93 = vmaxnmq_f32(v92, v65);
  v65.f32[0] = *(float *)&v68 + *(float *)&v67;
  *(float *)v72.f64 = *(float *)&v70 + *(float *)v71.i32;
  v65.f32[1] = *(float *)&v70 + *(float *)v71.i32;
  *(double *)v74.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v72, v68, v67, v69, v71, v70, v73);
  v75 = vadd_f32(v5, *(float32x2_t *)v94.i8);
  *(float *)&v76 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v75, 1), *(float *)(a1 + 16), v75.f32[0]);
  LODWORD(v77) = *(_DWORD *)(a1 + 24);
  v78.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v79) = *(_DWORD *)(a1 + 36);
  *(float *)v80.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v75, 1), *(float *)v78.i32, v75.f32[0]);
  v81 = (float64x2_t)v93;
  v95 = vmaxnmq_f32(v93, v74);
  v74.f32[0] = *(float *)&v77 + *(float *)&v76;
  *(float *)v81.f64 = *(float *)&v79 + *(float *)v80.i32;
  v74.f32[1] = *(float *)&v79 + *(float *)v80.i32;
  *(double *)v83.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v74.i64, v81, v77, v76, v78, v80, v79, v82);
  *(_QWORD *)&result = vmaxnmq_f32(v95, v83).u64[0];
  return result;
}

double cikernel::_min3x3(uint64_t a1, int8x16_t a2)
{
  int8x16_t v3;
  float64x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  float64x2_t v13;
  float32x2_t v14;
  double v15;
  double v16;
  uint8x8_t v17;
  int8x16_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  double v22;
  float32x2_t v23;
  float32x2_t v24;
  double v25;
  int8x16_t v26;
  double v27;
  uint8x8_t v28;
  float64x2_t v29;
  int8x16_t v30;
  float32x4_t v31;
  double v32;
  float32x2_t v33;
  double v34;
  int8x16_t v35;
  double v36;
  uint8x8_t v37;
  float64x2_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float64x2_t v41;
  double v42;
  double v43;
  uint8x8_t v44;
  double v45;
  int8x16_t v46;
  float32x4_t v47;
  double v48;
  float32x2_t v49;
  double v50;
  int8x16_t v51;
  double v52;
  uint8x8_t v53;
  float64x2_t v54;
  int8x16_t v55;
  float32x4_t v56;
  float32x2_t v57;
  double v58;
  double v59;
  int8x16_t v60;
  double v61;
  uint8x8_t v62;
  float64x2_t v63;
  int8x16_t v64;
  float32x4_t v65;
  float32x2_t v66;
  double v67;
  double v68;
  int8x16_t v69;
  double v70;
  uint8x8_t v71;
  float64x2_t v72;
  int8x16_t v73;
  float32x4_t v74;
  float32x2_t v75;
  double v76;
  double v77;
  int8x16_t v78;
  double v79;
  uint8x8_t v80;
  float64x2_t v81;
  int8x16_t v82;
  float32x4_t v83;
  double result;
  float32x4_t v85;
  float32x4_t v86;
  int8x8_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  int8x16_t v94;
  float32x4_t v95;

  v3.i64[0] = *(_QWORD *)CI::getDC((CI *)a1);
  v94 = v3;
  v4 = (float64x2_t)a2;
  v5 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)a2.i8, 1);
  *(float32x2_t *)v3.i8 = vsub_f32(*(float32x2_t *)v3.i8, v5);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v3.i8, 1), *(float *)(a1 + 16), *(float *)v3.i32);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v3.i8, 1), *(float *)&v7, *(float *)v3.i32);
  *(float *)v3.i32 = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  *(float *)&v3.i32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v3.i64, v4, v6, v7, v9, v8, v10, v11);
  v85 = v12;
  v13 = (float64x2_t)vextq_s8(a2, a2, 8uLL);
  v87 = *(int8x8_t *)&v13.f64[0];
  v14 = (float32x2_t)vext_s8(*(int8x8_t *)&v13.f64[0], *(int8x8_t *)a2.i8, 4uLL);
  *(float32x2_t *)v12.f32 = vsub_f32(*(float32x2_t *)v94.i8, v14);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v16, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v15;
  *(float *)v13.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v12.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v13, v15, v16, v18, v17, v19, v20);
  HIDWORD(v22) = a2.i32[1];
  v23 = (float32x2_t)vext_s8(*(int8x8_t *)a2.i8, v87, 4uLL);
  v24 = vadd_f32(v23, *(float32x2_t *)v94.i8);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v24, 1), *(float *)(a1 + 16), v24.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 24);
  v26.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v27) = *(_DWORD *)(a1 + 36);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v24, 1), *(float *)v26.i32, v24.f32[0]);
  v29 = (float64x2_t)v85;
  v86 = vminnmq_f32(v85, v21);
  v21.f32[0] = *(float *)&v22 + *(float *)&v25;
  *(float *)v29.f64 = *(float *)&v27 + *(float *)v28.i32;
  v21.f32[1] = *(float *)&v27 + *(float *)v28.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v29, v22, v25, v26, v28, v27, v30);
  a2.i64[0] = __PAIR64__(v87.u32[1], a2.u32[0]);
  v32 = *(double *)a2.i64;
  v33 = vsub_f32(*(float32x2_t *)v94.i8, *(float32x2_t *)a2.i8);
  *(float *)&v34 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v33, 1), *(float *)(a1 + 16), v33.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 24);
  v35.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v36) = *(_DWORD *)(a1 + 36);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v33, 1), *(float *)v35.i32, v33.f32[0]);
  v38 = (float64x2_t)v86;
  v88 = vminnmq_f32(v86, v31);
  v31.f32[0] = *(float *)&v32 + *(float *)&v34;
  *(float *)v38.f64 = *(float *)&v36 + *(float *)v37.i32;
  v31.f32[1] = *(float *)&v36 + *(float *)v37.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v31.i64, v38, v32, v34, v35, v37, v36, v39);
  v41 = (float64x2_t)v88;
  v89 = vminnmq_f32(v88, v40);
  LODWORD(v42) = *(_DWORD *)(a1 + 28);
  v40.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v94.i8, 1), *(float *)(a1 + 16), *(float *)v94.i32);
  LODWORD(v43) = *(_DWORD *)(a1 + 36);
  *(float *)v41.f64 = *(float *)&v43
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v94.i8, 1), *(float *)&v42, *(float *)v94.i32);
  v40.i32[1] = LODWORD(v41.f64[0]);
  *(double *)v47.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v40.i64, v41, v42, v43, v94, v44, v45, v46);
  HIDWORD(v48) = a2.i32[1];
  v49 = vadd_f32(*(float32x2_t *)a2.i8, *(float32x2_t *)v94.i8);
  *(float *)&v50 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v49, 1), *(float *)(a1 + 16), v49.f32[0]);
  LODWORD(v48) = *(_DWORD *)(a1 + 24);
  v51.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v52) = *(_DWORD *)(a1 + 36);
  *(float *)v53.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v49, 1), *(float *)v51.i32, v49.f32[0]);
  v54 = (float64x2_t)v89;
  v91 = vminnmq_f32(v89, v47);
  v47.f32[0] = *(float *)&v48 + *(float *)&v50;
  *(float *)v54.f64 = *(float *)&v52 + *(float *)v53.i32;
  v47.f32[1] = *(float *)&v52 + *(float *)v53.i32;
  *(double *)v56.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v47.i64, v54, v48, v50, v51, v53, v52, v55);
  v57 = vsub_f32(*(float32x2_t *)v94.i8, v23);
  *(float *)&v58 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v57, 1), *(float *)(a1 + 16), v57.f32[0]);
  LODWORD(v59) = *(_DWORD *)(a1 + 24);
  v60.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v61) = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v57, 1), *(float *)v60.i32, v57.f32[0]);
  v63 = (float64x2_t)v91;
  v92 = vminnmq_f32(v91, v56);
  v56.f32[0] = *(float *)&v59 + *(float *)&v58;
  *(float *)v63.f64 = *(float *)&v61 + *(float *)v62.i32;
  v56.f32[1] = *(float *)&v61 + *(float *)v62.i32;
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v56.i64, v63, v59, v58, v60, v62, v61, v64);
  v66 = vadd_f32(v14, *(float32x2_t *)v94.i8);
  *(float *)&v67 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v66, 1), *(float *)(a1 + 16), v66.f32[0]);
  LODWORD(v68) = *(_DWORD *)(a1 + 24);
  v69.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v70) = *(_DWORD *)(a1 + 36);
  *(float *)v71.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v66, 1), *(float *)v69.i32, v66.f32[0]);
  v72 = (float64x2_t)v92;
  v93 = vminnmq_f32(v92, v65);
  v65.f32[0] = *(float *)&v68 + *(float *)&v67;
  *(float *)v72.f64 = *(float *)&v70 + *(float *)v71.i32;
  v65.f32[1] = *(float *)&v70 + *(float *)v71.i32;
  *(double *)v74.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v72, v68, v67, v69, v71, v70, v73);
  v75 = vadd_f32(v5, *(float32x2_t *)v94.i8);
  *(float *)&v76 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v75, 1), *(float *)(a1 + 16), v75.f32[0]);
  LODWORD(v77) = *(_DWORD *)(a1 + 24);
  v78.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v79) = *(_DWORD *)(a1 + 36);
  *(float *)v80.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v75, 1), *(float *)v78.i32, v75.f32[0]);
  v81 = (float64x2_t)v93;
  v95 = vminnmq_f32(v93, v74);
  v74.f32[0] = *(float *)&v77 + *(float *)&v76;
  *(float *)v81.f64 = *(float *)&v79 + *(float *)v80.i32;
  v74.f32[1] = *(float *)&v79 + *(float *)v80.i32;
  *(double *)v83.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v74.i64, v81, v77, v76, v78, v80, v79, v82);
  *(_QWORD *)&result = vminnmq_f32(v95, v83).u64[0];
  return result;
}

double cikernel::_gradient(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  double result;

  v2.i64[0] = 0x3F0000003F000000;
  v2.i64[1] = 0x3F0000003F000000;
  *(_QWORD *)&result = vmulq_f32(vsubq_f32(a1, a2), v2).u64[0];
  return result;
}

double cikernel::_laplacian(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  float32x4_t v3;
  float32x4_t v4;
  double result;

  v3 = vsubq_f32(vaddq_f32(a2, a3), vaddq_f32(a1, a1));
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  *(_QWORD *)&result = vmulq_f32(v3, v4).u64[0];
  return result;
}

double cikernel::_average(float32x4_t a1, float32x4_t a2, float a3)
{
  double result;

  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a3), a2, a3).u64[0];
  return result;
}

void cikernel::_morphmin(uint64_t a1, float a2, float32x2_t a3)
{
  float32x2_t *DC;
  int8x16_t v7;
  double v8;
  double v9;
  double v10;
  float64x2_t v11;
  uint8x8_t v12;
  double v13;
  int8x16_t v14;
  float32x4_t v15;
  __int128 v16;
  double v17;
  double v18;
  int8x16_t v19;
  uint8x8_t v20;
  double v21;
  int8x16_t v22;
  float32x2_t v23;
  float64x2_t v24;
  float32x2_t v25;
  float32x4_t v26;
  float64x2_t v27;
  __int128 v28;
  float32x4_t v29;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v7.i8 = *DC;
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  *(float *)&v9 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v10) = *(_DWORD *)(a1 + 36);
  v27 = (float64x2_t)v7;
  *(float *)v11.f64 = *(float *)&v10
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v8, COERCE_FLOAT(*DC));
  HIDWORD(v9) = LODWORD(v11.f64[0]);
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v9, v11, v8, v10, v7, v12, v13, v14);
  if (a2 >= 0.0)
  {
    *(float *)&v16 = -a2;
    do
    {
      v28 = v16;
      v29 = v15;
      v23 = vmul_n_f32(a3, *(float *)&v16);
      v24 = v27;
      v25 = vadd_f32(*(float32x2_t *)&v27.f64[0], v23);
      *(float *)&v17 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v25, 1), *(float *)(a1 + 16), v25.f32[0]);
      LODWORD(v18) = *(_DWORD *)(a1 + 28);
      v20.i32[0] = *(_DWORD *)(a1 + 36);
      *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v25, 1), *(float *)&v18, v25.f32[0]);
      v25.f32[0] = *(float *)(a1 + 24) + *(float *)&v17;
      *(float *)v24.f64 = *(float *)v20.i32 + *(float *)v19.i32;
      v25.f32[1] = *(float *)v20.i32 + *(float *)v19.i32;
      *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v25, v24, v17, v18, v19, v20, v21, v22);
      v16 = v28;
      v15 = vminnmq_f32(v29, v26);
      *(float *)&v16 = *(float *)&v28 + 1.0;
    }
    while ((float)(*(float *)&v28 + 1.0) <= a2);
  }
}

void cikernel::_morphmax(uint64_t a1, float a2, float32x2_t a3)
{
  float32x2_t *DC;
  int8x16_t v7;
  double v8;
  double v9;
  double v10;
  float64x2_t v11;
  uint8x8_t v12;
  double v13;
  int8x16_t v14;
  float32x4_t v15;
  __int128 v16;
  double v17;
  double v18;
  int8x16_t v19;
  uint8x8_t v20;
  double v21;
  int8x16_t v22;
  float32x2_t v23;
  float64x2_t v24;
  float32x2_t v25;
  float32x4_t v26;
  float64x2_t v27;
  __int128 v28;
  float32x4_t v29;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)v7.i8 = *DC;
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  *(float *)&v9 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v10) = *(_DWORD *)(a1 + 36);
  v27 = (float64x2_t)v7;
  *(float *)v11.f64 = *(float *)&v10
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v8, COERCE_FLOAT(*DC));
  HIDWORD(v9) = LODWORD(v11.f64[0]);
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v9, v11, v8, v10, v7, v12, v13, v14);
  if (a2 >= 0.0)
  {
    *(float *)&v16 = -a2;
    do
    {
      v28 = v16;
      v29 = v15;
      v23 = vmul_n_f32(a3, *(float *)&v16);
      v24 = v27;
      v25 = vadd_f32(*(float32x2_t *)&v27.f64[0], v23);
      *(float *)&v17 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v25, 1), *(float *)(a1 + 16), v25.f32[0]);
      LODWORD(v18) = *(_DWORD *)(a1 + 28);
      v20.i32[0] = *(_DWORD *)(a1 + 36);
      *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v25, 1), *(float *)&v18, v25.f32[0]);
      v25.f32[0] = *(float *)(a1 + 24) + *(float *)&v17;
      *(float *)v24.f64 = *(float *)v20.i32 + *(float *)v19.i32;
      v25.f32[1] = *(float *)v20.i32 + *(float *)v19.i32;
      *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v25, v24, v17, v18, v19, v20, v21, v22);
      v16 = v28;
      v15 = vmaxnmq_f32(v29, v26);
      *(float *)&v16 = *(float *)&v28 + 1.0;
    }
    while ((float)(*(float *)&v28 + 1.0) <= a2);
  }
}

int64x2_t Rectangle::Union@<Q0>(Rectangle *this@<X0>, const Rectangle *a2@<X1>, uint64_t a3@<X8>, int64x2_t result@<Q0>)
{
  double var0;
  double var1;
  int64x2_t v6;
  double v7;
  double v8;
  BOOL v9;
  float64x2_t v10;
  float64x2_t v11;
  double v12;
  double v13;
  double v14;
  double v15;

  var0 = this->var0;
  if (fabs(this->var0) == INFINITY || (var1 = this->var1, fabs(var1) == INFINITY))
  {
    result = *(int64x2_t *)&a2->var0;
    v6 = *(int64x2_t *)&a2->var2;
LABEL_4:
    *(int64x2_t *)a3 = result;
    *(int64x2_t *)(a3 + 16) = v6;
    return result;
  }
  v7 = a2->var0;
  if (fabs(a2->var0) == INFINITY || (v8 = a2->var1, fabs(v8) == INFINITY))
  {
    result = *(int64x2_t *)&this->var0;
    v6 = *(int64x2_t *)&this->var2;
    goto LABEL_4;
  }
  v9 = var0 == -8.98846567e307 && var1 == -8.98846567e307;
  if (v9 && this->var2 == 1.79769313e308 && this->var3 == 1.79769313e308)
  {
    result = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    v6 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    goto LABEL_4;
  }
  v10 = *(float64x2_t *)&a2->var2;
  v11 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)&a2->var0, (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL)), (int32x4_t)vceqq_f64(v10, v11))))) & 1) != 0)
  {
    v12 = var0 + this->var2;
    v13 = fmin(fmin(var0, v12), fmin(v7, v7 + v10.f64[0]));
    v14 = var1 + this->var3;
    v15 = fmin(fmin(var1, v14), fmin(v8, v8 + v10.f64[1]));
    *(double *)result.i64 = fmax(fmax(var0, v12), fmax(v7, v7 + v10.f64[0])) - v13;
    *(double *)a3 = v13;
    *(double *)(a3 + 8) = v15;
    *(_QWORD *)(a3 + 16) = result.i64[0];
    *(double *)(a3 + 24) = fmax(fmax(var1, v14), fmax(v8, v8 + v10.f64[1])) - v15;
  }
  else
  {
    result = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)a3 = result;
    *(float64x2_t *)(a3 + 16) = v11;
  }
  return result;
}

double cikernel::_motionBlur(uint64_t a1, float32x4_t a2)
{
  float64x2_t v3;
  float32x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  float64x2_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  double v21;
  double v22;
  float64x2_t v23;
  uint8x8_t v24;
  double v25;
  int8x16_t v26;
  float32x4_t v27;
  float64x2_t v28;
  double v29;
  double v30;
  uint8x8_t v31;
  int8x16_t v32;
  double v33;
  int8x16_t v34;
  float32x4_t v35;
  double v36;
  double v37;
  uint8x8_t v38;
  int8x16_t v39;
  float64x2_t v40;
  double v41;
  int8x16_t v42;
  float32x4_t v43;
  double result;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  int8x16_t v49;

  v3.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  v49 = (int8x16_t)v3;
  v4 = vadd_f32(*(float32x2_t *)a2.f32, *(float32x2_t *)a2.f32);
  v5 = vsub_f32(*(float32x2_t *)&v3.f64[0], v4);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v3.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v3, v6, v7, v9, v8, v10, v11);
  v48 = v12;
  v13 = (float64x2_t)v49;
  *(float32x2_t *)v12.f32 = vsub_f32(*(float32x2_t *)v49.i8, *(float32x2_t *)a2.f32);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v15, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v13.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v12.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v13, v14, v15, v17, v16, v18, v19);
  v47 = v20;
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v20.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v49.i8, 1), *(float *)(a1 + 16), *(float *)v49.i32);
  LODWORD(v22) = *(_DWORD *)(a1 + 36);
  *(float *)v23.f64 = *(float *)&v22
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v49.i8, 1), *(float *)&v21, *(float *)v49.i32);
  v20.i32[1] = LODWORD(v23.f64[0]);
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v23, v21, v22, v49, v24, v25, v26);
  v46 = v27;
  v28 = (float64x2_t)v49;
  *(float32x2_t *)v27.f32 = vadd_f32(*(float32x2_t *)a2.f32, *(float32x2_t *)v49.i8);
  *(float *)&v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v27.f32, 1), *(float *)(a1 + 16), v27.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 28);
  v31.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v27.f32, 1), *(float *)&v30, v27.f32[0]);
  v27.f32[0] = *(float *)(a1 + 24) + *(float *)&v29;
  *(float *)v28.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v27.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v28, v29, v30, v32, v31, v33, v34);
  v45 = v35;
  *(float32x2_t *)v35.f32 = vadd_f32(v4, *(float32x2_t *)v49.i8);
  *(float *)&v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v35.f32, 1), *(float *)(a1 + 16), v35.f32[0]);
  LODWORD(v37) = *(_DWORD *)(a1 + 28);
  v38.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v35.f32, 1), *(float *)&v37, v35.f32[0]);
  v35.f32[0] = *(float *)(a1 + 24) + *(float *)&v36;
  *(float *)v40.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v35.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)v43.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v40, v36, v37, v39, v38, v41, v42);
  *(_QWORD *)&result = vaddq_f32(vmulq_laneq_f32(v46, a2, 2), vmulq_laneq_f32(vaddq_f32(vaddq_f32(v47, v45), vmulq_laneq_f32(vaddq_f32(v48, v43), a2, 3)), a2, 3)).u64[0];
  return result;
}

double cikernel::_zoomBlur(uint64_t a1, float32x2_t a2, float32x4_t a3, float32x4_t a4, float a5)
{
  float32x2_t *DC;
  float32x2_t v8;
  float32x2_t *v9;
  double v10;
  double v11;
  uint8x8_t v12;
  int8x16_t v13;
  double v14;
  float64x2_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  double v19;
  double v20;
  uint8x8_t v21;
  int8x16_t v22;
  float64x2_t v23;
  double v24;
  int8x16_t v25;
  float32x4_t v26;
  double v27;
  double v28;
  uint8x8_t v29;
  int8x16_t v30;
  float64x2_t v31;
  double v32;
  int8x16_t v33;
  float32x4_t v34;
  double v35;
  double v36;
  uint8x8_t v37;
  int8x16_t v38;
  float64x2_t v39;
  double v40;
  int8x16_t v41;
  float32x4_t v42;
  double v43;
  double v44;
  uint8x8_t v45;
  int8x16_t v46;
  float64x2_t v47;
  double v48;
  int8x16_t v49;
  float32x4_t v50;
  double result;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v8 = vsub_f32(*DC, a2);
  v9 = (float32x2_t *)CI::getDC((CI *)DC);
  *(float *)&v10 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *v9, 1), *(float *)(a1 + 16), COERCE_FLOAT(*v9));
  LODWORD(v11) = *(_DWORD *)(a1 + 28);
  v12.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *v9, 1), *(float *)&v11, COERCE_FLOAT(*v9));
  *(float *)&v14 = *(float *)(a1 + 24) + *(float *)&v10;
  *(float *)v15.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  *((float *)&v14 + 1) = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v14, v15, v10, v11, v13, v12, v16, v17);
  v55 = v18;
  *(float32x2_t *)v18.f32 = vadd_f32(a2, vmul_n_f32(v8, a3.f32[0]));
  *(float *)&v19 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v18.f32, 1), *(float *)(a1 + 16), v18.f32[0]);
  LODWORD(v20) = *(_DWORD *)(a1 + 28);
  v21.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v18.f32, 1), *(float *)&v20, v18.f32[0]);
  v18.f32[0] = *(float *)(a1 + 24) + *(float *)&v19;
  *(float *)v23.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  v18.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v23, v19, v20, v22, v21, v24, v25);
  v54 = v26;
  *(float32x2_t *)v26.f32 = vadd_f32(a2, vmul_lane_f32(v8, *(float32x2_t *)a3.f32, 1));
  *(float *)&v27 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v26.f32, 1), *(float *)(a1 + 16), v26.f32[0]);
  LODWORD(v28) = *(_DWORD *)(a1 + 28);
  v29.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v30.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v26.f32, 1), *(float *)&v28, v26.f32[0]);
  v26.f32[0] = *(float *)(a1 + 24) + *(float *)&v27;
  *(float *)v31.f64 = *(float *)v29.i32 + *(float *)v30.i32;
  v26.f32[1] = *(float *)v29.i32 + *(float *)v30.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v26.i64, v31, v27, v28, v30, v29, v32, v33);
  v53 = v34;
  *(float32x2_t *)v34.f32 = vadd_f32(a2, vmul_laneq_f32(v8, a3, 2));
  *(float *)&v35 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v34.f32, 1), *(float *)(a1 + 16), v34.f32[0]);
  LODWORD(v36) = *(_DWORD *)(a1 + 28);
  v37.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v34.f32, 1), *(float *)&v36, v34.f32[0]);
  v34.f32[0] = *(float *)(a1 + 24) + *(float *)&v35;
  *(float *)v39.f64 = *(float *)v37.i32 + *(float *)v38.i32;
  v34.f32[1] = *(float *)v37.i32 + *(float *)v38.i32;
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v34.i64, v39, v35, v36, v38, v37, v40, v41);
  v52 = v42;
  *(float32x2_t *)v42.f32 = vadd_f32(a2, vmul_laneq_f32(v8, a3, 3));
  *(float *)&v43 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v42.f32, 1), *(float *)(a1 + 16), v42.f32[0]);
  LODWORD(v44) = *(_DWORD *)(a1 + 28);
  v45.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v46.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v42.f32, 1), *(float *)&v44, v42.f32[0]);
  v42.f32[0] = *(float *)(a1 + 24) + *(float *)&v43;
  *(float *)v47.f64 = *(float *)v45.i32 + *(float *)v46.i32;
  v42.f32[1] = *(float *)v45.i32 + *(float *)v46.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v42.i64, v47, v43, v44, v46, v45, v48, v49);
  *(_QWORD *)&result = vaddq_f32(vmulq_n_f32(v55, a5), vaddq_f32(vmulq_laneq_f32(v54, a4, 3), vaddq_f32(vmulq_laneq_f32(v53, a4, 2), vaddq_f32(vmulq_lane_f32(v52, *(float32x2_t *)a4.f32, 1), vmulq_n_f32(v50, a4.f32[0]))))).u64[0];
  return result;
}

void CI::f4_sr_f2_f4_f4_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, double, __n128, __n128, float);
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  __n128 *v20;
  __n128 *v21;
  double *v22;
  __int128 v23;
  int v24;
  int v25;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, double, __n128, __n128, float))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  v17 = *(_DWORD *)(v10 + 88);
  v18 = *(_QWORD *)(v10 + 80);
  v19 = *(_QWORD *)(v10 + 104);
  if (*(_BYTE *)(a1 + 64))
  {
    v24 = *(_DWORD *)(v10 + 88);
    v25 = *(_DWORD *)(v10 + 40);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 128)), a2);
    v17 = v24;
    v13 = v25;
  }
  v20 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v18);
  v21 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v21 = (__n128 *)((char *)a2 + 64 * v16);
  v22 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v22 = (double *)((char *)a2 + 64 * v14);
  *(double *)&v23 = v11(a4 + 80 * v12, *v22, *v21, *v20, *((float *)a2 + 16 * v19));
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

void cikernel::_zoom(uint64_t a1, float32x2_t a2, float a3)
{
  int v6;
  double v7;
  double v8;
  int8x16_t v9;
  uint8x8_t v10;
  double v11;
  int8x16_t v12;
  float32x2_t v13;
  float32x4_t v14;
  float64x2_t v15;
  float v16;
  float32x2_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;

  v6 = 0;
  v13 = vsub_f32(*(float32x2_t *)CI::getDC((CI *)a1), a2);
  v14 = 0uLL;
  v15 = (float64x2_t)vdupq_n_s32(0x3C23D70Au);
  v19 = (float32x4_t)v15;
  do
  {
    v20 = v14;
    v16 = (float)((float)((float)((float)v6 / 99.0) + -0.5)
                + (float)((float)((float)((float)((float)v6 / 99.0) + -0.5) * (float)((float)((float)v6 / 99.0) + -0.5))
                        * (float)((float)((float)v6 / 99.0) + -0.5)))
        * 0.8
        + 0.5;
    v17 = vadd_f32(a2, vmul_n_f32(v13, v16 + (float)(a3 * (float)(1.0 - v16))));
    *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v17, 1), *(float *)(a1 + 16), v17.f32[0]);
    LODWORD(v8) = *(_DWORD *)(a1 + 28);
    v10.i32[0] = *(_DWORD *)(a1 + 36);
    *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v17, 1), *(float *)&v8, v17.f32[0]);
    v17.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
    *(float *)v15.f64 = *(float *)v10.i32 + *(float *)v9.i32;
    v17.f32[1] = *(float *)v10.i32 + *(float *)v9.i32;
    *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v17, v15, v7, v8, v9, v10, v11, v12);
    v15 = (float64x2_t)vaddq_f32(v20, vmulq_f32(v18, v19));
    v14 = (float32x4_t)v15;
    ++v6;
  }
  while (v6 != 100);
}

void CI::f4_sr_f2_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, double, float);
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  double *v17;
  __int128 v18;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, double, float))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_DWORD *)(v11 + 40);
  v15 = *(_QWORD *)(v11 + 32);
  v16 = *(_QWORD *)(v11 + 56);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 80)), a2);
  v17 = (double *)(a3 + 16 * v15);
  if (v14 != 5)
    v17 = (double *)((char *)a2 + 64 * v15);
  *(double *)&v18 = v12(a4 + 80 * v13, *v17, *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_opTile(uint64_t a1, float32x2_t a2, double a3, int8x16_t a4)
{
  float32x2_t v6;
  float32x2_t v7;
  float32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  float32x2_t v11;
  float64x2_t v12;
  int8x16_t v13;
  uint8x8_t v14;
  double v15;
  int8x16_t v16;

  v6 = vsub_f32(*(float32x2_t *)CI::getDC((CI *)a1), a2);
  v7 = vmul_lane_f32(vrndm_f32(vmul_n_f32(v6, *(float *)&a3)), *(float32x2_t *)&a3, 1);
  v8 = vsub_f32(v6, v7);
  v9 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v7);
  v10 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v7);
  v11 = (float32x2_t)vzip1_s32(v9, v10);
  *(float32x2_t *)&v12.f64[0] = vadd_f32(a2, vadd_f32(v8, vadd_f32(v11, (float32x2_t)vzip2_s32(v9, v10))));
  v11.i32[0] = *(_DWORD *)(a1 + 28);
  v8.f32[0] = *(float *)(a1 + 24)
            + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v12.f64[0], 1), *(float *)(a1 + 16), *(float *)v12.f64);
  v13.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v12.f64[0], 1), v11.f32[0], *(float *)v12.f64);
  *(float *)v12.f64 = *(float *)v13.i32 + *(float *)v9.i32;
  v8.f32[1] = *(float *)v13.i32 + *(float *)v9.i32;
  return CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v8, v12, *(double *)&v9, *(double *)&v11, v13, v14, v15, v16);
}

void CI::f4_sr_f2_f2_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, double, double, __n128);
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __n128 *v19;
  double *v20;
  double *v21;
  __int128 v22;
  int v23;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, double, double, __n128))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  v17 = *(_DWORD *)(v10 + 88);
  v18 = *(_QWORD *)(v10 + 80);
  if (*(_BYTE *)(a1 + 64))
  {
    v23 = *(_DWORD *)(v10 + 64);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
    v15 = v23;
  }
  v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v18);
  v20 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v20 = (double *)((char *)a2 + 64 * v16);
  v21 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v21 = (double *)((char *)a2 + 64 * v14);
  *(double *)&v22 = v11(a4 + 80 * v12, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

void pageCurlMapInverse(CGPoint a1, CGAffineTransform *a2, CGAffineTransform *a3)
{
  CGFloat v3;

  v3 = a2->tx + a1.y * a2->c + a2->a * a1.x;
  if (v3 > 0.0 && v3 < 3.14159265)
    sin(v3);
}

uint64_t CriticalPointsDOD(CGRect a1, CGAffineTransform *a2, CGPoint *a3)
{
  double tx;
  double a;
  double c;
  double v8;
  double v9;
  uint64_t result;
  double v12;
  double v13;
  CGPoint *v15;
  double v16;
  CGPoint *v18;
  double v19;
  CGPoint *v21;
  CGRect v22;

  v22 = CGRectStandardize(a1);
  tx = a2->tx + -1.57079633;
  a2->tx = tx;
  a = a2->a;
  c = a2->c;
  v8 = -(tx + v22.origin.x * a2->a) / c;
  v9 = v22.origin.y + v22.size.height;
  if (v8 < v22.origin.y || v8 > v9)
  {
    result = 0;
  }
  else
  {
    a3->x = v22.origin.x;
    a3->y = v8;
    a = a2->a;
    tx = a2->tx;
    result = 1;
    c = a2->c;
  }
  v12 = v22.origin.x + v22.size.width;
  v13 = -(tx + v12 * a) / c;
  if (v13 >= v22.origin.y && v13 <= v9)
  {
    v15 = &a3[result];
    result = (result + 1);
    v15->x = v12;
    v15->y = v13;
    c = a2->c;
    tx = a2->tx;
    a = a2->a;
  }
  v16 = -(tx + v22.origin.y * c) / a;
  if (v16 >= v22.origin.x && v16 <= v12)
  {
    v18 = &a3[result];
    result = (result + 1);
    v18->x = v16;
    v18->y = v22.origin.y;
    c = a2->c;
    tx = a2->tx;
    a = a2->a;
  }
  v19 = -(tx + v9 * c) / a;
  if (v19 >= v22.origin.x && v19 <= v12)
  {
    v21 = &a3[result];
    result = (result + 1);
    v21->x = v19;
    v21->y = v9;
  }
  return result;
}

void pageCurlROI(int a1, float64x2_t *a2, double *a3, double *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  double y;
  double v17;
  double width;
  double height;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  unsigned int v27;
  double v28;
  double v29;
  double *v31;
  double v32;
  double *v34;
  double v35;
  double *v37;
  double *v38;
  double *v39;
  double *v40;
  CGFloat v41;
  double v42;
  double v43;
  double v44;
  double *v45;
  double *v46;
  uint64_t v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  long double v55;
  double *v56;
  float64x2_t v57;
  double *v58;
  uint64_t v59;
  double v60;
  CGFloat v61;
  double v62;
  uint64_t v63;
  uint64_t v64;
  CGFloat v65;
  CGFloat v66;
  _BYTE v67[32];
  float64x2_t v68;
  double v69;
  double v70;
  double v71;
  double v72;
  double v73;
  double v74;
  double v75;
  CGFloat r1;
  CGFloat v77;
  CGFloat v78;
  CGFloat v79;
  CGFloat v80;
  CGFloat v81;
  CGFloat v82;
  CGFloat v83;
  float64x2_t v84;
  float64x2_t v85;
  double v86[2];
  double v87[2];
  CGFloat x;
  double v89[17];
  CGRect v90;
  CGRect v91;
  CGRect v92;
  CGRect v93;
  CGRect v94;
  CGRect v95;

  v89[15] = *(double *)MEMORY[0x1E0C80C00];
  if (a1 == 2)
    return;
  *(double *)v67 = a9;
  *(double *)&v67[8] = a10;
  *(double *)&v67[16] = a11;
  *(double *)&v67[24] = a12;
  v17 = *MEMORY[0x1E0C9D628];
  y = *(double *)(MEMORY[0x1E0C9D628] + 8);
  width = *(double *)(MEMORY[0x1E0C9D628] + 16);
  height = *(double *)(MEMORY[0x1E0C9D628] + 24);
  v20 = a2->f64[0];
  v21 = a2[1].f64[0];
  v22 = a2[2].f64[0];
  v90 = CGRectStandardize(*(CGRect *)&a5);
  v23 = v22 + -0.999;
  v24 = -(v22 + -0.999 + v90.origin.x * v20) / v21;
  v25 = v90.origin.y + v90.size.height;
  if (v24 < v90.origin.y || v24 > v25)
  {
    v27 = 0;
  }
  else
  {
    x = v90.origin.x;
    v89[0] = -(v22 + -0.999 + v90.origin.x * v20) / v21;
    v27 = 1;
  }
  v28 = v90.origin.x + v90.size.width;
  v29 = -(v23 + v28 * v20) / v21;
  if (v29 >= v90.origin.y && v29 <= v25)
  {
    v31 = &v89[2 * v27++ - 1];
    *v31 = v28;
    v31[1] = v29;
  }
  v32 = -(v23 + v90.origin.y * v21) / v20;
  if (v32 >= v90.origin.x && v32 <= v28)
  {
    v34 = &v89[2 * v27++ - 1];
    *v34 = v32;
    v34[1] = v90.origin.y;
  }
  v35 = -(v23 + v25 * v21) / v20;
  if (v35 >= v90.origin.x && v35 <= v28)
  {
    v37 = &v89[2 * v27++ - 1];
    *v37 = v35;
    v37[1] = v25;
  }
  if (v23 + v21 * v90.origin.y + v90.origin.x * v20 <= 0.0)
  {
    v38 = &v89[2 * v27++ - 1];
    *v38 = v90.origin.x;
    v38[1] = v90.origin.y;
  }
  if (v23 + v21 * v25 + v90.origin.x * v20 <= 0.0)
  {
    v39 = &v89[2 * v27++ - 1];
    *v39 = v90.origin.x;
    v39[1] = v25;
  }
  if (v23 + v21 * v25 + v28 * v20 <= 0.0)
  {
    v40 = &v89[2 * v27++ - 1];
    *v40 = v28;
    v40[1] = v25;
  }
  if (v23 + v21 * v90.origin.y + v28 * v20 <= 0.0)
  {
    v45 = &v89[2 * v27++ - 1];
    *v45 = v28;
    v45[1] = v90.origin.y;
LABEL_33:
    v46 = v89;
    v44 = height;
    v43 = width;
    v42 = y;
    v41 = v17;
    v47 = v27;
    do
    {
      r1 = v44;
      v77 = height;
      v78 = width;
      v79 = v17;
      v80 = y;
      v81 = v43;
      v82 = v42;
      v83 = v41;
      v70 = *v46;
      v48 = *a3;
      v49 = a3[1];
      v50 = a3[2];
      v51 = a3[3];
      v52 = a3[4];
      v53 = a3[5];
      v54 = a4[2];
      v74 = *a4;
      v75 = a4[1];
      v71 = a4[4];
      v72 = a4[5];
      v73 = a4[3];
      v87[0] = *(v46 - 1);
      v69 = v87[0];
      v87[1] = v70;
      v68 = vaddq_f64(a2[2], vmlaq_n_f64(vmulq_n_f64(a2[1], v70), *a2, v87[0]));
      v84 = v68;
      v85 = v68;
      v55 = asin(v68.f64[0]);
      v85.f64[0] = v52 + v50 * v85.f64[1] + v48 * v55;
      v85.f64[1] = v53 + v51 * v85.f64[1] + v49 * v55;
      v84.f64[0] = v52 + vmuld_lane_f64(v50, v68, 1) + v48 * (3.14159265 - v55);
      v84.f64[1] = v53 + vmuld_lane_f64(v51, v68, 1) + v49 * (3.14159265 - v55);
      if (v68.f64[0] > 0.0)
        v56 = (double *)&v85;
      else
        v56 = v87;
      v57 = *(float64x2_t *)v56;
      v86[0] = v71 + v70 * v54 + v74 * v69;
      v86[1] = v72 + v70 * v73 + v75 * v69;
      if (v68.f64[0] > 0.0)
        v58 = (double *)&v84;
      else
        v58 = v86;
      v84 = *(float64x2_t *)v58;
      v85 = v57;
      if (v68.f64[0] > 0.0)
        v60 = v57.f64[1];
      else
        v60 = v70;
      v61 = *v58;
      if (v68.f64[0] > 0.0)
        v62 = v84.f64[1];
      else
        v62 = v72 + v70 * v73 + v75 * v69;
      v63 = 0;
      v64 = 0;
      v91.origin.x = v79;
      v91.origin.y = v80;
      v91.size.height = v77;
      v91.size.width = v78;
      v59 = *(_QWORD *)v56;
      v92 = CGRectUnion(v91, *(CGRect *)(&v60 - 1));
      v17 = v92.origin.x;
      y = v92.origin.y;
      width = v92.size.width;
      height = v92.size.height;
      v94.size.width = 0.0;
      v94.size.height = 0.0;
      v92.origin.y = v82;
      v92.origin.x = v83;
      v92.size.width = v81;
      v92.size.height = r1;
      v94.origin.x = v61;
      v94.origin.y = v62;
      *(CGRect *)&v41 = CGRectUnion(v92, v94);
      v46 += 2;
      --v47;
    }
    while (v47);
    goto LABEL_47;
  }
  if (v27)
    goto LABEL_33;
  v41 = v17;
  v42 = y;
  v43 = width;
  v44 = height;
LABEL_47:
  if (a1)
    v65 = v44;
  else
    v65 = height;
  if (a1)
    v66 = v43;
  else
    v66 = width;
  if (a1)
  {
    y = v42;
    v17 = v41;
  }
  v95 = CGRectInset(*(CGRect *)v67, -1.0, -1.0);
  v93.origin.x = v17;
  v93.origin.y = y;
  v93.size.width = v66;
  v93.size.height = v65;
  CGRectIntersection(v93, v95);
}

double cikernel::_pageCurlTransition(uint64_t a1, uint64_t a2, uint64_t a3, int8x16_t a4, float32x2_t a5, int8x16_t a6, float32x2_t a7, int8x16_t a8, float32x2_t a9, float a10, int8x16_t a11)
{
  float32x2_t v18;
  int32x2_t v19;
  int32x2_t v20;
  float64x2_t v21;
  double v22;
  float v23;
  float v24;
  float64x2_t v25;
  unsigned int v26;
  float32x2_t v27;
  int32x2_t v28;
  float32x2_t v29;
  double v30;
  int8x8_t v31;
  int32x2_t v32;
  int8x8_t v33;
  int32x2_t v34;
  int8x16_t v35;
  float32x2_t v36;
  int8x8_t v37;
  int8x16_t v38;
  float32x4_t v39;
  double v40;
  int8x16_t v41;
  double v42;
  float64x2_t v43;
  double v44;
  int8x16_t v45;
  float32x4_t v46;
  int8x16_t v53;
  float64x2_t v54;
  double v55;
  uint8x8_t v56;
  int8x16_t v57;
  double v58;
  int8x16_t v59;
  float32x4_t v60;
  float32x4_t v61;
  float v62;
  float32x4_t v63;
  float32x4_t v64;
  float v65;
  float v66;
  double result;
  float32x4_t v69;
  float32x4_t v71;
  float64x2_t v73;

  v18 = *(float32x2_t *)CI::getDC((CI *)a1);
  v19 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v18);
  v20 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v18);
  *(float32x2_t *)&v21.f64[0] = vadd_f32(a5, vadd_f32((float32x2_t)vzip1_s32(v19, v20), (float32x2_t)vzip2_s32(v19, v20)));
  v73 = v21;
  v22 = *(float *)v21.f64;
  v23 = sqrt(1.0 - pow(*(float *)v21.f64, 1.5)) + -1.0;
  v24 = v22 + (float)(v23 * v23) * 0.5625;
  v25 = v73;
  *(float *)v25.f64 = v24;
  *(float *)&v26 = 3.14159265 - v24;
  v27 = (float32x2_t)__PAIR64__(HIDWORD(v73.f64[0]), v26);
  v28 = (int32x2_t)vmul_f32(*(float32x2_t *)a6.i8, *(float32x2_t *)&v25.f64[0]);
  v29 = (float32x2_t)vextq_s8(a6, a6, 8uLL).u64[0];
  v30 = *(double *)a6.i64;
  *(float32x2_t *)&v25.f64[0] = vmul_f32(v29, *(float32x2_t *)&v25.f64[0]);
  v31 = (int8x8_t)vadd_f32(a7, vadd_f32((float32x2_t)vzip1_s32(v28, *(int32x2_t *)&v25.f64[0]), (float32x2_t)vzip2_s32(v28, *(int32x2_t *)&v25.f64[0])));
  *(float32x2_t *)&v25.f64[0] = vmul_f32(*(float32x2_t *)a6.i8, v27);
  v32 = (int32x2_t)vmul_f32(v29, v27);
  *(float32x2_t *)&v25.f64[0] = vadd_f32(a7, vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v25.f64[0], v32), (float32x2_t)vzip2_s32(*(int32x2_t *)&v25.f64[0], v32)));
  a7.i32[0] = 0;
  v33 = (int8x8_t)vdup_lane_s32(vcge_f32(a7, *(float32x2_t *)&v73.f64[0]), 0);
  v34 = (int32x2_t)vmul_f32(*(float32x2_t *)a8.i8, v18);
  v35 = vextq_s8(a8, a8, 8uLL);
  *(float32x2_t *)v35.i8 = vmul_f32(*(float32x2_t *)v35.i8, v18);
  v36 = (float32x2_t)vzip1_s32(v34, *(int32x2_t *)v35.i8);
  v37 = (int8x8_t)vadd_f32(a9, vadd_f32(v36, (float32x2_t)vzip2_s32(v34, *(int32x2_t *)v35.i8)));
  *(int8x8_t *)a6.i8 = vbsl_s8(v33, v37, *(int8x8_t *)&v25.f64[0]);
  *(int8x8_t *)&v25.f64[0] = vbsl_s8(v33, (int8x8_t)v18, v31);
  v37.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v31.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v25.f64[0], 1), *(float *)(a1 + 16), *(float *)v25.f64);
  v35.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v25.f64[0], 1), *(float *)v37.i32, *(float *)v25.f64);
  *(float *)v25.f64 = *(float *)v35.i32 + *(float *)v33.i32;
  *(float *)&v31.i32[1] = *(float *)v35.i32 + *(float *)v33.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v31, v25, *(double *)&v33, *(double *)&v37, v35, (uint8x8_t)v36, v30, v38);
  v71 = v39;
  HIDWORD(v40) = a6.i32[1];
  LODWORD(v40) = *(_DWORD *)(a2 + 28);
  v41.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&v42 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)a6.i8, 1), *(float *)&v40, *(float *)a6.i32);
  v39.f32[0] = *(float *)(a2 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)a6.i8, 1), *(float *)(a2 + 16), *(float *)a6.i32);
  *(float *)v43.f64 = *(float *)v41.i32 + *(float *)&v42;
  v39.f32[1] = *(float *)v41.i32 + *(float *)&v42;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v39.i64, v43, v40, v42, v41, *(uint8x8_t *)a6.i8, v44, v45);
  v69 = v46;
  __asm { FMOV            V1.2S, #-1.0 }
  *(float32x2_t *)v46.f32 = vmaxnm_f32(vmul_n_f32(*(float32x2_t *)a4.i8, a10 * *(float *)v73.f64), _D1);
  __asm { FMOV            V1.2S, #1.0 }
  *(int8x8_t *)v46.f32 = vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(a7, *(float32x2_t *)&v73.f64[0]), 0), (int8x8_t)0x3F0000003F000000, (int8x8_t)vadd_f32(vmul_f32(vminnm_f32(*(float32x2_t *)v46.f32, _D1), (float32x2_t)0x3F0000003F000000), (float32x2_t)0x3F0000003F000000));
  v53 = a11;
  v54 = (float64x2_t)vextq_s8(v53, v53, 8uLL);
  *(float32x2_t *)v46.f32 = vadd_f32(*(float32x2_t *)a11.i8, vmul_f32(*(float32x2_t *)&v54.f64[0], *(float32x2_t *)v46.f32));
  *(float *)v53.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 20), *(float32x2_t *)v46.f32, 1), *(float *)(a3 + 16), v46.f32[0]);
  LODWORD(v55) = *(_DWORD *)(a3 + 28);
  v56.i32[0] = *(_DWORD *)(a3 + 36);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 32), *(float32x2_t *)v46.f32, 1), *(float *)&v55, v46.f32[0]);
  v46.f32[0] = *(float *)(a3 + 24) + *(float *)v53.i32;
  *(float *)v54.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v46.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v60.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a3 + 8), *(double *)v46.i64, v54, *(double *)v53.i64, v55, v57, v56, v58, v59);
  v61 = vmulq_laneq_f32(v60, v69, 3);
  v62 = 1.0;
  v63 = vaddq_f32(v61, vmulq_n_f32(v69, 1.0 - v61.f32[3]));
  v64 = vaddq_f32(v63, vmulq_n_f32(v71, 1.0 - v63.f32[3]));
  v65 = (1.0 - v22) * a10;
  if (v65 <= 1.0)
    v62 = (1.0 - v22) * a10;
  if (v65 >= 0.0)
    v66 = v62;
  else
    v66 = 0.0;
  *(_QWORD *)&result = vmulq_n_f32(v64, v66).u64[0];
  return result;
}

void CI::f4_sr_sr_sr_f4_f2_f4_f2_f4_f2_f_f4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(uint64_t, uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128);
  uint64_t v11;
  const vec2 *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  const vec2 *v30;
  __n128 *v31;
  double *v32;
  __n128 *v33;
  double *v34;
  double *v35;
  __n128 *v36;
  __n128 *v37;
  double *v38;
  __n128 *v39;
  __int128 v40;
  int v41;
  int v42;
  int v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  int v51;
  double (*v52)(uint64_t, uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128);

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(uint64_t, uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128))(a1 + 24);
  v11 = *(_QWORD *)(v9 + 8);
  v12 = *(const vec2 **)(v9 + 32);
  v13 = *(_QWORD *)(v9 + 56);
  v14 = *(_DWORD *)(v9 + 88);
  v15 = *(_QWORD *)(v9 + 80);
  v16 = *(_DWORD *)(v9 + 112);
  v17 = *(_QWORD *)(v9 + 104);
  v18 = *(_DWORD *)(v9 + 136);
  v19 = *(_QWORD *)(v9 + 128);
  v20 = *(_DWORD *)(v9 + 160);
  v21 = *(_QWORD *)(v9 + 152);
  v22 = *(_DWORD *)(v9 + 184);
  v23 = *(_QWORD *)(v9 + 176);
  v24 = *(_DWORD *)(v9 + 208);
  v25 = *(_QWORD *)(v9 + 200);
  v26 = *(_QWORD *)(v9 + 224);
  v27 = *(_DWORD *)(v9 + 256);
  v28 = *(_QWORD *)(v9 + 248);
  if (*(_BYTE *)(a1 + 64))
  {
    v52 = *(double (**)(uint64_t, uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128))(a1 + 24);
    v42 = *(_DWORD *)(v9 + 208);
    v43 = *(_DWORD *)(v9 + 184);
    v29 = *(_QWORD *)(v9 + 8);
    v50 = a4;
    v45 = *(_DWORD *)(v9 + 160);
    v30 = *(const vec2 **)(v9 + 32);
    v48 = *(_QWORD *)(v9 + 56);
    v51 = *(_DWORD *)(v9 + 88);
    v49 = *(_DWORD *)(v9 + 112);
    v47 = *(_DWORD *)(v9 + 136);
    v46 = *(_QWORD *)(v9 + 128);
    v44 = *(_QWORD *)(v9 + 152);
    v41 = *(_DWORD *)(v9 + 256);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 272)), v12);
    v27 = v41;
    v24 = v42;
    v21 = v44;
    v19 = v46;
    v18 = v47;
    v16 = v49;
    v14 = v51;
    v13 = v48;
    v12 = v30;
    v20 = v45;
    a4 = v50;
    v11 = v29;
    v22 = v43;
    v10 = v52;
  }
  v31 = (__n128 *)(a3 + 16 * v28);
  if (v27 != 5)
    v31 = (__n128 *)(a2 + (v28 << 6));
  v32 = (double *)(a3 + 16 * v25);
  if (v24 != 5)
    v32 = (double *)(a2 + (v25 << 6));
  v33 = (__n128 *)(a3 + 16 * v23);
  if (v22 != 5)
    v33 = (__n128 *)(a2 + (v23 << 6));
  v34 = (double *)(a3 + 16 * v21);
  v35 = (double *)(a2 + (v21 << 6));
  if (v20 != 5)
    v34 = v35;
  v36 = (__n128 *)(a3 + 16 * v19);
  v37 = (__n128 *)(a2 + (v19 << 6));
  if (v18 != 5)
    v36 = v37;
  v38 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v38 = (double *)(a2 + (v17 << 6));
  v39 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v39 = (__n128 *)(a2 + (v15 << 6));
  *(double *)&v40 = v10(a4 + 80 * v11, a4 + 80 * (_QWORD)v12, a4 + 80 * v13, *v39, *v38, *v36, *v34, *v33, *v32, *(float *)(a2 + (v26 << 6)), *v31);
  *(_OWORD *)(a3 + 16 * a7) = v40;
}

double cikernel::_pageCurlTransNoEmap(uint64_t a1, uint64_t a2, int8x16_t a3, float32x2_t a4, int8x16_t a5, float32x2_t a6, int8x16_t a7, float32x2_t a8, float a9)
{
  float32x2_t v15;
  int32x2_t v16;
  int32x2_t v17;
  float64x2_t v18;
  double v19;
  float v20;
  float v21;
  float64x2_t v22;
  unsigned int v23;
  float32x2_t v24;
  int32x2_t v25;
  float32x2_t v26;
  int8x8_t v27;
  int32x2_t v28;
  int8x8_t v29;
  int32x2_t v30;
  int8x16_t v31;
  float32x2_t v32;
  int8x8_t v33;
  int8x16_t v34;
  float32x4_t v35;
  double v36;
  int8x16_t v37;
  double v38;
  float64x2_t v39;
  double v40;
  int8x16_t v41;
  float32x4_t v42;
  float v43;
  float32x4_t v44;
  float v45;
  float v46;
  double result;
  float64x2_t v49;
  float32x4_t v51;

  v15 = *(float32x2_t *)CI::getDC((CI *)a1);
  v16 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v15);
  v17 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v15);
  *(float32x2_t *)&v18.f64[0] = vadd_f32(a4, vadd_f32((float32x2_t)vzip1_s32(v16, v17), (float32x2_t)vzip2_s32(v16, v17)));
  v49 = v18;
  v19 = *(float *)v18.f64;
  v20 = sqrt(1.0 - pow(*(float *)v18.f64, 1.5)) + -1.0;
  v21 = v19 + (float)(v20 * v20) * 0.5625;
  v22 = v49;
  *(float *)v22.f64 = v21;
  *(float *)&v23 = 3.14159265 - v21;
  v24 = (float32x2_t)__PAIR64__(HIDWORD(v49.f64[0]), v23);
  v25 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, *(float32x2_t *)&v22.f64[0]);
  v26 = (float32x2_t)vextq_s8(a5, a5, 8uLL).u64[0];
  *(float32x2_t *)&v22.f64[0] = vmul_f32(v26, *(float32x2_t *)&v22.f64[0]);
  v27 = (int8x8_t)vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(v25, *(int32x2_t *)&v22.f64[0]), (float32x2_t)vzip2_s32(v25, *(int32x2_t *)&v22.f64[0])));
  *(float32x2_t *)&v22.f64[0] = vmul_f32(*(float32x2_t *)a5.i8, v24);
  v28 = (int32x2_t)vmul_f32(v26, v24);
  *(float32x2_t *)&v22.f64[0] = vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v22.f64[0], v28), (float32x2_t)vzip2_s32(*(int32x2_t *)&v22.f64[0], v28)));
  a6.i32[0] = 0;
  v29 = (int8x8_t)vdup_lane_s32(vcge_f32(a6, *(float32x2_t *)&v49.f64[0]), 0);
  v30 = (int32x2_t)vmul_f32(*(float32x2_t *)a7.i8, v15);
  v31 = vextq_s8(a7, a7, 8uLL);
  *(float32x2_t *)v31.i8 = vmul_f32(*(float32x2_t *)v31.i8, v15);
  v32 = (float32x2_t)vzip1_s32(v30, *(int32x2_t *)v31.i8);
  v33 = (int8x8_t)vadd_f32(a8, vadd_f32(v32, (float32x2_t)vzip2_s32(v30, *(int32x2_t *)v31.i8)));
  *(int8x8_t *)a7.i8 = vbsl_s8(v29, v33, *(int8x8_t *)&v22.f64[0]);
  *(int8x8_t *)&v22.f64[0] = vbsl_s8(v29, (int8x8_t)v15, v27);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v27.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v22.f64[0], 1), *(float *)(a1 + 16), *(float *)v22.f64);
  v31.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v22.f64[0], 1), *(float *)v33.i32, *(float *)v22.f64);
  *(float *)v22.f64 = *(float *)v31.i32 + *(float *)v29.i32;
  *(float *)&v27.i32[1] = *(float *)v31.i32 + *(float *)v29.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v27, v22, *(double *)&v29, *(double *)&v33, v31, (uint8x8_t)v32, v49.f64[0], v34);
  v51 = v35;
  HIDWORD(v36) = a7.i32[1];
  LODWORD(v36) = *(_DWORD *)(a2 + 28);
  v37.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)a7.i8, 1), *(float *)&v36, *(float *)a7.i32);
  v35.f32[0] = *(float *)(a2 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)a7.i8, 1), *(float *)(a2 + 16), *(float *)a7.i32);
  *(float *)v39.f64 = *(float *)v37.i32 + *(float *)&v38;
  v35.f32[1] = *(float *)v37.i32 + *(float *)&v38;
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v35.i64, v39, v36, v38, v37, *(uint8x8_t *)a7.i8, v40, v41);
  v43 = 1.0;
  v44 = vaddq_f32(v42, vmulq_n_f32(v51, 1.0 - v42.f32[3]));
  v45 = (1.0 - v19) * a9;
  if (v45 <= 1.0)
    v43 = (1.0 - v19) * a9;
  if (v45 >= 0.0)
    v46 = v43;
  else
    v46 = 0.0;
  *(_QWORD *)&result = vmulq_n_f32(v44, v46).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f2_f4_f2_f4_f2_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float);
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  double *v27;
  __n128 *v28;
  double *v29;
  __n128 *v30;
  __n128 *v31;
  double *v32;
  __n128 *v33;
  __int128 v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  double (*v43)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float);

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_QWORD *)(v10 + 32);
  v14 = *(_DWORD *)(v10 + 64);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_DWORD *)(v10 + 88);
  v17 = *(_QWORD *)(v10 + 80);
  v18 = *(_DWORD *)(v10 + 112);
  v19 = *(_QWORD *)(v10 + 104);
  v20 = *(_DWORD *)(v10 + 136);
  v21 = *(_QWORD *)(v10 + 128);
  v22 = *(_DWORD *)(v10 + 160);
  v23 = *(_QWORD *)(v10 + 152);
  v24 = *(_DWORD *)(v10 + 184);
  v25 = *(_QWORD *)(v10 + 176);
  v26 = *(_QWORD *)(v10 + 200);
  if (*(_BYTE *)(a1 + 64))
  {
    v42 = *(_QWORD *)(v10 + 200);
    v43 = *(double (**)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float))(a1 + 24);
    v40 = *(_QWORD *)(v10 + 80);
    v41 = *(_QWORD *)(v10 + 8);
    v39 = *(_DWORD *)(v10 + 64);
    v38 = *(_QWORD *)(v10 + 104);
    v36 = *(_DWORD *)(v10 + 160);
    v37 = *(_DWORD *)(v10 + 136);
    v35 = *(_DWORD *)(v10 + 184);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 224)), a2);
    v24 = v35;
    v22 = v36;
    v20 = v37;
    v19 = v38;
    v17 = v40;
    v12 = v41;
    v26 = v42;
    v11 = v43;
    v14 = v39;
  }
  v27 = (double *)(a3 + 16 * v25);
  if (v24 != 5)
    v27 = (double *)((char *)a2 + 64 * v25);
  v28 = (__n128 *)(a3 + 16 * v23);
  if (v22 != 5)
    v28 = (__n128 *)((char *)a2 + 64 * v23);
  v29 = (double *)(a3 + 16 * v21);
  if (v20 != 5)
    v29 = (double *)((char *)a2 + 64 * v21);
  v30 = (__n128 *)(a3 + 16 * v19);
  v31 = (__n128 *)((char *)a2 + 64 * v19);
  if (v18 != 5)
    v30 = v31;
  v32 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v32 = (double *)((char *)a2 + 64 * v17);
  v33 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v33 = (__n128 *)((char *)a2 + 64 * v15);
  *(double *)&v34 = v11(a4 + 80 * v12, a4 + 80 * v13, *v33, *v32, *v30, *v29, *v28, *v27, *((float *)a2 + 16 * v26));
  *(_OWORD *)(a3 + 16 * a7) = v34;
}

double cikernel::_pageCurlWithShadowTransition(uint64_t a1, uint64_t a2, int8x16_t a3, float32x2_t a4, int8x16_t a5, float32x2_t a6, int8x16_t a7, float32x2_t a8, float a9, int8x16_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float a17, float a18, uint64_t a19, float32x4_t a20,float32x4_t a21)
{
  float32x2_t v21;
  int8x16_t v27;
  float32x2_t v28;
  int32x2_t v29;
  float32x2_t v30;
  double v31;
  float32x2_t v32;
  float64x2_t v33;
  float v34;
  float v35;
  long double v36;
  double v37;
  double v38;
  float v39;
  float v40;
  float32x2_t v41;
  float32x2_t v42;
  int32x2_t v43;
  int8x8_t v44;
  int32x2_t v45;
  int8x8_t v46;
  int32x2_t v47;
  int8x16_t v48;
  float32x2_t v49;
  float32x2_t v50;
  float32x2_t v51;
  float32x4_t v52;
  double v53;
  int8x16_t v54;
  double v55;
  float64x2_t v56;
  double v57;
  int8x16_t v58;
  float32x4_t v59;
  float v60;
  float v61;
  double v62;
  double v63;
  double v64;
  float v65;
  float v66;
  float32x4_t v67;
  float32x2_t v68;
  int32x2_t v69;
  int32x2_t v70;
  float32x2_t v71;
  float32x2_t v72;
  int32x2_t v73;
  int32x2_t v74;
  float32x2_t v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float32x4_t v80;
  float32x2_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  double v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float32x4_t v112;
  float v113;
  float32x4_t v114;
  float32x4_t v115;
  float v116;
  float32x4_t v117;
  double result;
  float32x2_t v119;
  float32x4_t v121;
  float32x2_t v122;
  float v123;
  float32x2_t v127;

  v28 = *(float32x2_t *)CI::getDC((CI *)a1);
  v29 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v28);
  v33 = (float64x2_t)vextq_s8(a3, a3, 8uLL);
  *(float32x2_t *)&v33.f64[0] = vmul_f32(*(float32x2_t *)&v33.f64[0], v28);
  v30 = vadd_f32(a4, vadd_f32((float32x2_t)vzip1_s32(v29, *(int32x2_t *)&v33.f64[0]), (float32x2_t)vzip2_s32(v29, *(int32x2_t *)&v33.f64[0])));
  v31 = v30.f32[0];
  v32 = v30;
  LODWORD(v33.f64[0]) = v30.i32[0];
  v34 = 0.0;
  v35 = v30.f32[0];
  v127 = v30;
  if (v30.f32[0] > 0.0)
  {
    v36 = pow(v30.f32[0], 1.5);
    v30 = v127;
    *(float *)&v36 = sqrt(1.0 - v36) + -1.0;
    v37 = v31 + (float)(*(float *)&v36 * *(float *)&v36) * 0.5625;
    v38 = v31 * 9999.0;
    v39 = 1.0;
    if (v127.f32[0] < 1.0)
      v38 = v37;
    *(float *)v33.f64 = v38;
    v32 = (float32x2_t)__PAIR64__(v127.u32[1], LODWORD(v33.f64[0]));
    v40 = (float)(v127.f32[0] + -0.607) / 0.693;
    if (v40 <= 1.0)
      v39 = (float)(v127.f32[0] + -0.607) / 0.693;
    if (v40 < 0.0)
      v39 = 0.0;
    if (v31 >= 0.9)
      v37 = v31 + (float)((float)(v39 * v39) * (float)((float)(v39 * -2.0) + 3.0)) * 0.570796327;
    v35 = v37;
    v34 = v127.f32[0];
  }
  v123 = v35;
  v41.i32[1] = v30.i32[1];
  v41.f32[0] = 3.1416 - *(float *)v33.f64;
  *(float32x2_t *)&v33.f64[0] = vmul_f32(*(float32x2_t *)a5.i8, v32);
  v42 = (float32x2_t)vextq_s8(a5, a5, 8uLL).u64[0];
  v43 = (int32x2_t)vmul_f32(v42, v32);
  v44 = (int8x8_t)vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v33.f64[0], v43), (float32x2_t)vzip2_s32(*(int32x2_t *)&v33.f64[0], v43)));
  *(float32x2_t *)&v33.f64[0] = vmul_f32(*(float32x2_t *)a5.i8, v41);
  v122 = v42;
  v45 = (int32x2_t)vmul_f32(v42, v41);
  *(float32x2_t *)&v33.f64[0] = vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v33.f64[0], v45), (float32x2_t)vzip2_s32(*(int32x2_t *)&v33.f64[0], v45)));
  v21.i32[0] = 0;
  v46 = (int8x8_t)vdup_lane_s32(vcgt_f32(v21, v30), 0);
  v47 = (int32x2_t)vmul_f32(*(float32x2_t *)a7.i8, v28);
  v48 = vextq_s8(a7, a7, 8uLL);
  *(float32x2_t *)v48.i8 = vmul_f32(*(float32x2_t *)v48.i8, v28);
  v49 = (float32x2_t)vzip1_s32(v47, *(int32x2_t *)v48.i8);
  v50 = vadd_f32(v49, (float32x2_t)vzip2_s32(v47, *(int32x2_t *)v48.i8));
  v51 = vadd_f32(a8, v50);
  v119 = (float32x2_t)vbsl_s8(v46, (int8x8_t)v51, *(int8x8_t *)&v33.f64[0]);
  *(int8x8_t *)&v33.f64[0] = vbsl_s8(v46, (int8x8_t)v28, v44);
  v50.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v44.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v33.f64[0], 1), *(float *)(a1 + 16), *(float *)v33.f64);
  v48.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v46.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v33.f64[0], 1), v50.f32[0], *(float *)v33.f64);
  *(float *)v33.f64 = *(float *)v48.i32 + *(float *)v46.i32;
  *(float *)&v44.i32[1] = *(float *)v48.i32 + *(float *)v46.i32;
  *(double *)v52.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v44, v33, *(double *)&v46, *(double *)&v50, v48, (uint8x8_t)v49, *(double *)&v30, v27);
  v121 = v52;
  HIDWORD(v53) = v119.i32[1];
  LODWORD(v53) = *(_DWORD *)(a2 + 28);
  v54.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&v55 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v119, 1), *(float *)&v53, v119.f32[0]);
  v52.f32[0] = *(float *)(a2 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v119, 1), *(float *)(a2 + 16), v119.f32[0]);
  *(float *)v56.f64 = *(float *)v54.i32 + *(float *)&v55;
  v52.f32[1] = *(float *)v54.i32 + *(float *)&v55;
  *(double *)v59.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v52.i64, v56, v53, v55, v54, (uint8x8_t)v119, v57, v58);
  v60 = (v34 + -0.6) * 2.5;
  v61 = 1.0;
  if (v60 <= 1.0)
    v61 = (v34 + -0.6) * 2.5;
  if (v60 < 0.0)
    v61 = 0.0;
  v62 = v61;
  if (v61 <= 0.75)
    v63 = v62 * 0.375 * v62 + v62 * 0.35;
  else
    v63 = (v62 + -0.82) * 15.0 * (v62 + -0.82) + 0.4;
  v64 = 1.0 - v31;
  v65 = (1.0 - v31) * a9;
  if (v65 <= 1.0)
    v66 = (1.0 - v31) * a9;
  else
    v66 = 1.0;
  if (v65 < 0.0)
    v66 = 0.0;
  v67 = vmulq_n_f32(v121, v66);
  v68.i32[1] = v127.i32[1];
  v68.f32[0] = 3.1416 - v123;
  v69 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, v68);
  v70 = (int32x2_t)vmul_f32(v122, v68);
  v71 = vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(v69, v70), (float32x2_t)vzip2_s32(v69, v70)));
  *(float *)v70.i32 = 1.0 - (float)(a17 + a17);
  v72 = vmla_n_f32(vmul_n_f32(v71, *(float *)v70.i32), v51, a17 + a17);
  v73 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, (float32x2_t)__PAIR64__(v127.u32[1], LODWORD(v123)));
  v74 = (int32x2_t)vmul_f32(v122, (float32x2_t)__PAIR64__(v127.u32[1], LODWORD(v123)));
  v75 = vmla_n_f32(vmul_n_f32(vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(v73, v74), (float32x2_t)vzip2_s32(v73, v74))), *(float *)v70.i32), v28, a17 + a17);
  v76 = (float)(v127.f32[0] + -0.5) + (float)(v127.f32[0] + -0.5);
  if (v76 <= 1.0)
    v77 = (float)(v127.f32[0] + -0.5) + (float)(v127.f32[0] + -0.5);
  else
    v77 = 1.0;
  if (v76 >= 0.0)
    v78 = v77;
  else
    v78 = 0.0;
  v79 = (float)(vmuls_lane_f32((float)((float)((float)(v78 * v78) * (float)((float)(v78 * -2.0) + 3.0)) * 1.25)+ (float)((float)(1.0 - (float)((float)(v78 * v78) * (float)((float)(v78 * -2.0) + 3.0))) * 2.0), v67, 3)+ (float)((float)(1.0 - v67.f32[3]) * 2.3))* a17;
  *(float *)v73.i32 = v79 * a9;
  *(float32x2_t *)v80.f32 = vsub_f32(v72, *(float32x2_t *)a10.i8);
  v81 = (float32x2_t)vextq_s8(a10, a10, 8uLL).u64[0];
  *(float32x2_t *)&v80.u32[2] = vsub_f32(v81, v72);
  v82 = vdivq_f32(v80, (float32x4_t)vdupq_lane_s32(v73, 0));
  v83 = (float32x4_t)vdupq_n_s32(0x3F23D70Au);
  v84.i64[0] = 0x3F0000003F000000;
  v84.i64[1] = 0x3F0000003F000000;
  v85 = (float32x4_t)vdupq_n_s32(0x3E0F5C29u);
  __asm
  {
    FMOV            V19.4S, #1.0
    FMOV            V24.4S, #-1.0
  }
  v91 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vaddq_f32(v82, _Q24)), vbicq_s8((int8x16_t)vsubq_f32(vaddq_f32(vmulq_f32(v82, v83), v84), vmulq_f32(v82, vmulq_f32(v82, vmulq_f32(v82, v85)))), (int8x16_t)vcltzq_f32(vaddq_f32(v82, _Q19))), (int8x16_t)_Q19);
  v92 = v64 / v79;
  v93 = v92 * 0.64 + 0.5 + v92 * -0.14 * v92 * v92;
  if (v92 <= -1.0)
    v93 = 0.0;
  if (v92 < 1.0)
    v94 = v93;
  else
    v94 = 1.0;
  v95 = v94 * vmulq_laneq_f32(vmulq_laneq_f32(vmulq_lane_f32(v91, *(float32x2_t *)v91.f32, 1), v91, 2), v91, 3).f32[0];
  if (v95 <= 1.0)
    v96 = v95;
  else
    v96 = 1.0;
  if (v95 >= 0.0)
    v97 = v96;
  else
    v97 = 0.0;
  v98 = vmul_f32(v127, v127).f32[0];
  if (v98 > 1.5)
    v98 = 1.5;
  v99 = v98 * 0.65;
  *(float *)&v99 = v99;
  v100 = v64 / (float)(a17 * 2.5);
  v101 = v100 * 0.64 + 0.5 + v100 * -0.14 * v100 * v100;
  if (v100 <= -1.0)
    v101 = 0.0;
  if (v100 < 1.0)
    v102 = v101;
  else
    v102 = 1.0;
  if (v127.f32[0] <= 1.0)
    v103 = v127.f32[0];
  else
    v103 = 1.0;
  if (v127.f32[0] < 0.0)
    *(float *)&v99 = 0.0;
  *(float *)&v99 = (float)((float)(*(float *)&v99 * a17) * 2.5) * a9;
  *(float32x2_t *)v104.f32 = vsub_f32(v75, *(float32x2_t *)a10.i8);
  *(float32x2_t *)&v104.u32[2] = vsub_f32(v81, v75);
  v105 = vdivq_f32(v104, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v99, 0));
  v106 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_f32(vaddq_f32(v105, _Q24)), vbicq_s8((int8x16_t)vsubq_f32(vaddq_f32(vmulq_f32(v105, v83), v84), vmulq_f32(v105, vmulq_f32(v105, vmulq_f32(v105, v85)))), (int8x16_t)vcltzq_f32(vaddq_f32(v105, _Q19))), (int8x16_t)_Q19);
  v107 = (1.0 - v67.f32[3])
       * (float)(v102
               * vmulq_laneq_f32(vmulq_laneq_f32(vmulq_lane_f32(v106, *(float32x2_t *)v106.f32, 1), v106, 2), v106, 3).f32[0]);
  if (v127.f32[0] >= 0.0)
    v108 = v103;
  else
    v108 = 0.0;
  v109 = v108 * v107;
  if (v109 <= 1.0)
    v110 = v109;
  else
    v110 = 1.0;
  _NF = v109 < 0.0 || v127.f32[0] < 0.0;
  v112 = vmulq_n_f32(v59, v66);
  v113 = v63;
  v114 = vmulq_laneq_f32(vmlaq_n_f32(vmulq_n_f32(a20, 1.0 - v113), a21, v113), v112, 3);
  v115 = vaddq_f32(v114, vmulq_n_f32(v112, 1.0 - v114.f32[3]));
  if (_NF)
    v116 = 0.0;
  else
    v116 = v110;
  v117.i64[0] = 0;
  v117.i32[2] = 0;
  v117.f32[3] = fminf(fmaxf(v97, v116), 0.5) * a18;
  *(_QWORD *)&result = vaddq_f32(v115, vmulq_n_f32(vaddq_f32(v117, vmulq_n_f32(v67, 1.0 - v117.f32[3])), 1.0 - v115.f32[3])).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f2_f4_f2_f4_f2_f_f4_f_f_f4_f4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128, double);
  uint64_t v11;
  const vec2 *v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const vec2 *v30;
  uint64_t v31;
  int v32;
  int v33;
  __n128 *v34;
  double *v35;
  double *v36;
  __n128 *v37;
  __n128 *v38;
  double *v39;
  double *v40;
  __n128 *v41;
  __n128 *v42;
  double *v43;
  __n128 *v44;
  __int128 v45;
  double v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  double (*v59)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128, double);
  int v60;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128, double))(a1 + 24);
  v11 = *(_QWORD *)(v9 + 8);
  v12 = *(const vec2 **)(v9 + 32);
  v13 = *(_DWORD *)(v9 + 64);
  v14 = *(_QWORD *)(v9 + 56);
  v15 = *(_DWORD *)(v9 + 88);
  v16 = *(_QWORD *)(v9 + 80);
  v17 = *(_DWORD *)(v9 + 112);
  v18 = *(_QWORD *)(v9 + 104);
  v19 = *(_DWORD *)(v9 + 136);
  v20 = *(_QWORD *)(v9 + 128);
  v21 = *(_DWORD *)(v9 + 160);
  v22 = *(_QWORD *)(v9 + 152);
  v23 = *(_DWORD *)(v9 + 184);
  v24 = *(_QWORD *)(v9 + 176);
  v25 = *(_QWORD *)(v9 + 200);
  v60 = *(_DWORD *)(v9 + 232);
  v26 = *(_QWORD *)(v9 + 224);
  v27 = *(_QWORD *)(v9 + 248);
  v28 = *(_QWORD *)(v9 + 272);
  if (*(_BYTE *)(a1 + 64))
  {
    v59 = *(double (**)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128, double))(a1 + 24);
    v53 = *(_DWORD *)(v9 + 112);
    v29 = a4;
    v55 = *(_QWORD *)(v9 + 8);
    v51 = *(_DWORD *)(v9 + 136);
    v30 = *(const vec2 **)(v9 + 32);
    v57 = *(_QWORD *)(v9 + 248);
    v56 = *(_QWORD *)(v9 + 56);
    v31 = *(_QWORD *)(v9 + 200);
    v58 = *(_QWORD *)(v9 + 272);
    v54 = *(_QWORD *)(v9 + 80);
    v32 = *(_DWORD *)(v9 + 64);
    v49 = *(_DWORD *)(v9 + 160);
    v33 = *(_DWORD *)(v9 + 88);
    v52 = *(_QWORD *)(v9 + 104);
    v50 = *(_QWORD *)(v9 + 128);
    v48 = *(_QWORD *)(v9 + 152);
    v47 = *(_QWORD *)(v9 + 176);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 344)), v12);
    v24 = v47;
    v22 = v48;
    v20 = v50;
    v18 = v52;
    v15 = v33;
    v21 = v49;
    v13 = v32;
    v16 = v54;
    v11 = v55;
    v27 = v57;
    v28 = v58;
    v25 = v31;
    v14 = v56;
    v12 = v30;
    v19 = v51;
    a4 = v29;
    v17 = v53;
    v10 = v59;
  }
  v34 = (__n128 *)(a3 + 16 * v26);
  if (v60 != 5)
    v34 = (__n128 *)(a2 + (v26 << 6));
  v35 = (double *)(a3 + 16 * v24);
  v36 = (double *)(a2 + (v24 << 6));
  if (v23 != 5)
    v35 = v36;
  v37 = (__n128 *)(a3 + 16 * v22);
  v38 = (__n128 *)(a2 + (v22 << 6));
  if (v21 != 5)
    v37 = v38;
  v39 = (double *)(a3 + 16 * v20);
  v40 = (double *)(a2 + (v20 << 6));
  if (v19 != 5)
    v39 = v40;
  v41 = (__n128 *)(a3 + 16 * v18);
  v42 = (__n128 *)(a2 + (v18 << 6));
  if (v17 != 5)
    v41 = v42;
  v43 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v43 = (double *)(a2 + (v16 << 6));
  v44 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v44 = (__n128 *)(a2 + (v14 << 6));
  LODWORD(v46) = *(_DWORD *)(a2 + (v27 << 6));
  HIDWORD(v46) = *(_DWORD *)(a2 + (v28 << 6));
  *(double *)&v45 = v10(a4 + 80 * v11, a4 + 80 * (_QWORD)v12, *v44, *v43, *v41, *v39, *v37, *v35, *(float *)(a2 + (v25 << 6)), *v34, v46);
  *(_OWORD *)(a3 + 16 * a7) = v45;
}

double cikernel::_pageCurlNoShadowTransition(uint64_t a1, uint64_t a2, int8x16_t a3, float32x2_t a4, int8x16_t a5, float32x2_t a6, int8x16_t a7, float32x2_t a8, float a9, float32x4_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float32x4_t a17)
{
  float32x2_t v17;
  float32x2_t v24;
  int32x2_t v25;
  int32x2_t v26;
  float64x2_t v27;
  double v28;
  double v29;
  double v30;
  int8x16_t v31;
  double v32;
  float v33;
  float v34;
  float32x2_t v35;
  float64x2_t v36;
  int32x2_t v37;
  float32x2_t v38;
  int8x8_t v39;
  int32x2_t v40;
  int8x8_t v41;
  int32x2_t v42;
  int8x16_t v43;
  float32x2_t v44;
  int8x8_t v45;
  float32x4_t v46;
  double v47;
  int8x16_t v48;
  double v49;
  float64x2_t v50;
  double v51;
  int8x16_t v52;
  float32x4_t v53;
  float v54;
  float v55;
  float v56;
  double v57;
  double v58;
  float v59;
  float v60;
  BOOL v61;
  float v62;
  float32x4_t v63;
  float v64;
  float32x4_t v65;
  float32x4_t v66;
  double result;
  float32x2_t v69;
  float32x4_t v71;
  float64x2_t v73;

  v24 = *(float32x2_t *)CI::getDC((CI *)a1);
  v25 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v24);
  v26 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v24);
  *(float32x2_t *)&v27.f64[0] = vadd_f32(a4, vadd_f32((float32x2_t)vzip1_s32(v25, v26), (float32x2_t)vzip2_s32(v25, v26)));
  v73 = v27;
  v17.i32[0] = LODWORD(v27.f64[0]);
  v28 = *(float *)v27.f64;
  v29 = pow(*(float *)v27.f64, 1.5);
  v32 = v28;
  if (v17.f32[0] > 0.0)
  {
    if (v17.f32[0] >= 1.0)
    {
      v32 = v28 * 9999.0;
    }
    else
    {
      v33 = sqrt(1.0 - v29) + -1.0;
      v32 = v28 + (float)(v33 * v33) * 0.5625;
    }
  }
  v34 = v32;
  v35.i32[1] = HIDWORD(v73.f64[0]);
  v36 = v73;
  *(float *)v36.f64 = v34;
  v35.f32[0] = 3.1416 - v34;
  v37 = (int32x2_t)vmul_f32(*(float32x2_t *)a5.i8, *(float32x2_t *)&v36.f64[0]);
  v38 = (float32x2_t)vextq_s8(a5, a5, 8uLL).u64[0];
  *(float32x2_t *)&v36.f64[0] = vmul_f32(v38, *(float32x2_t *)&v36.f64[0]);
  v39 = (int8x8_t)vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(v37, *(int32x2_t *)&v36.f64[0]), (float32x2_t)vzip2_s32(v37, *(int32x2_t *)&v36.f64[0])));
  *(float32x2_t *)&v36.f64[0] = vmul_f32(*(float32x2_t *)a5.i8, v35);
  v40 = (int32x2_t)vmul_f32(v38, v35);
  *(float32x2_t *)&v36.f64[0] = vadd_f32(a6, vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v36.f64[0], v40), (float32x2_t)vzip2_s32(*(int32x2_t *)&v36.f64[0], v40)));
  a6.i32[0] = 0;
  v41 = (int8x8_t)vdup_lane_s32(vcgt_f32(a6, v17), 0);
  v42 = (int32x2_t)vmul_f32(*(float32x2_t *)a7.i8, v24);
  v43 = vextq_s8(a7, a7, 8uLL);
  *(float32x2_t *)v43.i8 = vmul_f32(*(float32x2_t *)v43.i8, v24);
  v44 = (float32x2_t)vzip1_s32(v42, *(int32x2_t *)v43.i8);
  v45 = (int8x8_t)vadd_f32(a8, vadd_f32(v44, (float32x2_t)vzip2_s32(v42, *(int32x2_t *)v43.i8)));
  v69 = (float32x2_t)vbsl_s8(v41, v45, *(int8x8_t *)&v36.f64[0]);
  *(int8x8_t *)&v36.f64[0] = vbsl_s8(v41, (int8x8_t)v24, v39);
  v45.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v39.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v36.f64[0], 1), *(float *)(a1 + 16), *(float *)v36.f64);
  v43.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v36.f64[0], 1), *(float *)v45.i32, *(float *)v36.f64);
  *(float *)v36.f64 = *(float *)v43.i32 + *(float *)v41.i32;
  *(float *)&v39.i32[1] = *(float *)v43.i32 + *(float *)v41.i32;
  *(double *)v46.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v39, v36, *(double *)&v41, *(double *)&v45, v43, (uint8x8_t)v44, v30, v31);
  v71 = v46;
  HIDWORD(v47) = v69.i32[1];
  LODWORD(v47) = *(_DWORD *)(a2 + 28);
  v48.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&v49 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v69, 1), *(float *)&v47, v69.f32[0]);
  v46.f32[0] = *(float *)(a2 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v69, 1), *(float *)(a2 + 16), v69.f32[0]);
  *(float *)v50.f64 = *(float *)v48.i32 + *(float *)&v49;
  v46.f32[1] = *(float *)v48.i32 + *(float *)&v49;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v46.i64, v50, v47, v49, v48, (uint8x8_t)v69, v51, v52);
  if (v17.f32[0] > 0.0)
    v54 = v17.f32[0];
  else
    v54 = 0.0;
  v55 = (v54 + -0.6) * 2.5;
  v56 = 1.0;
  if (v55 <= 1.0)
    v56 = v55;
  if (v55 < 0.0)
    v56 = 0.0;
  v57 = v56;
  if (v56 <= 0.75)
    v58 = v57 * 0.375 * v57 + v57 * 0.35;
  else
    v58 = (v57 + -0.82) * 15.0 * (v57 + -0.82) + 0.4;
  v59 = (1.0 - v28) * a9;
  if (v59 <= 1.0)
    v60 = (1.0 - v28) * a9;
  else
    v60 = 1.0;
  v61 = v59 < 0.0;
  v62 = 0.0;
  if (!v61)
    v62 = v60;
  v63 = vmulq_n_f32(v53, v62);
  v64 = v58;
  v65 = vmulq_laneq_f32(vmlaq_n_f32(vmulq_n_f32(a10, 1.0 - v64), a17, v64), v63, 3);
  v66 = vaddq_f32(v65, vmulq_n_f32(v63, 1.0 - v65.f32[3]));
  *(_QWORD *)&result = vaddq_f32(v66, vmulq_n_f32(vmulq_n_f32(v71, v62), 1.0 - v66.f32[3])).u64[0];
  return result;
}

void CI::f4_sr_sr_f4_f2_f4_f2_f4_f2_f_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128, double, double);
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  double *v33;
  __n128 *v34;
  double *v35;
  __n128 *v36;
  __n128 *v37;
  double *v38;
  double *v39;
  __n128 *v40;
  __n128 *v41;
  double *v42;
  __n128 *v43;
  __int128 v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  double (*v57)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128, double, double);

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128, double, double))(a1 + 24);
  v11 = *(_QWORD *)(v9 + 8);
  v12 = *(_QWORD *)(v9 + 32);
  v13 = *(_DWORD *)(v9 + 64);
  v14 = *(_QWORD *)(v9 + 56);
  v15 = *(_DWORD *)(v9 + 88);
  v16 = *(_QWORD *)(v9 + 80);
  v17 = *(_DWORD *)(v9 + 112);
  v18 = *(_QWORD *)(v9 + 104);
  v19 = *(_DWORD *)(v9 + 136);
  v20 = *(_QWORD *)(v9 + 128);
  v21 = *(_DWORD *)(v9 + 160);
  v22 = *(_QWORD *)(v9 + 152);
  v23 = *(_DWORD *)(v9 + 184);
  v24 = *(_QWORD *)(v9 + 176);
  v25 = *(_QWORD *)(v9 + 200);
  v26 = *(_DWORD *)(v9 + 232);
  v27 = *(_QWORD *)(v9 + 224);
  v28 = *(_DWORD *)(v9 + 256);
  v29 = *(_QWORD *)(v9 + 248);
  if (*(_BYTE *)(a1 + 64))
  {
    v57 = *(double (**)(uint64_t, uint64_t, __n128, double, __n128, double, __n128, double, float, __n128, double, double))(a1 + 24);
    v46 = *(_DWORD *)(v9 + 232);
    v47 = *(_DWORD *)(v9 + 184);
    v30 = a4;
    v53 = *(_QWORD *)(v9 + 8);
    v54 = *(_QWORD *)(v9 + 80);
    v55 = *(_QWORD *)(v9 + 200);
    v56 = *(_QWORD *)(v9 + 56);
    v51 = *(_DWORD *)(v9 + 136);
    v31 = *(_DWORD *)(v9 + 64);
    v49 = *(_DWORD *)(v9 + 160);
    v32 = *(_DWORD *)(v9 + 88);
    v52 = *(_QWORD *)(v9 + 104);
    v50 = *(_QWORD *)(v9 + 128);
    v48 = *(_QWORD *)(v9 + 152);
    v45 = *(_DWORD *)(v9 + 256);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 272)), a2);
    v28 = v45;
    v26 = v46;
    v22 = v48;
    v20 = v50;
    v18 = v52;
    v11 = v53;
    v16 = v54;
    v25 = v55;
    v15 = v32;
    v21 = v49;
    v14 = v56;
    v13 = v31;
    v19 = v51;
    a4 = v30;
    v23 = v47;
    v10 = v57;
  }
  v33 = (double *)(a3 + 16 * v29);
  if (v28 != 5)
    v33 = (double *)((char *)a2 + 64 * v29);
  v34 = (__n128 *)(a3 + 16 * v27);
  if (v26 != 5)
    v34 = (__n128 *)((char *)a2 + 64 * v27);
  v35 = (double *)(a3 + 16 * v24);
  if (v23 != 5)
    v35 = (double *)((char *)a2 + 64 * v24);
  v36 = (__n128 *)(a3 + 16 * v22);
  v37 = (__n128 *)((char *)a2 + 64 * v22);
  if (v21 != 5)
    v36 = v37;
  v38 = (double *)(a3 + 16 * v20);
  v39 = (double *)((char *)a2 + 64 * v20);
  if (v19 != 5)
    v38 = v39;
  v40 = (__n128 *)(a3 + 16 * v18);
  v41 = (__n128 *)((char *)a2 + 64 * v18);
  if (v17 != 5)
    v40 = v41;
  v42 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v42 = (double *)((char *)a2 + 64 * v16);
  v43 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v43 = (__n128 *)((char *)a2 + 64 * v14);
  *(double *)&v44 = v10(a4 + 80 * v11, a4 + 80 * v12, *v43, *v42, *v40, *v38, *v36, *v35, *((float *)a2 + 16 * v25), *v34, *v33, v33[1]);
  *(_OWORD *)(a3 + 16 * a7) = v44;
}

float32x2_t cikernel::_parallelogramTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v15;
  float32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;

  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  v8 = vadd_f32((float32x2_t)vzip1_s32(v6, v7), (float32x2_t)vzip2_s32(v6, v7));
  v9 = vminnm_f32(vsub_f32(v8, vrndm_f32(v8)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  __asm { FMOV            V1.2S, #1.0 }
  v15 = vminnm_f32(v9, vsub_f32(_D1, v9));
  v16 = vadd_f32(v15, v15);
  v17 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v16);
  v18 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v16);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v17, v18), (float32x2_t)vzip2_s32(v17, v18)));
}

void CI::f2_f2_f4_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, double, __n128, __n128);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  double *v20;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, double, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_DWORD *)(v10 + 64);
  v17 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v15);
  v20 = (double *)(a3 + 16 * v13);
  if (v12 != 5)
    v20 = (double *)((char *)a2 + 64 * v13);
  *(double *)(a3 + 16 * a7) = v11(a1, *v20, *v19, *v18);
}

void sub_192323D0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__12(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__12(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

Class __getVNGeneratePersonSegmentationRequestClass_block_invoke(uint64_t a1)
{
  Class result;

  VisionLibrary_0();
  result = objc_getClass("VNGeneratePersonSegmentationRequest");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getVNGeneratePersonSegmentationRequestClass_block_invoke_cold_1();
  getVNGeneratePersonSegmentationRequestClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

void VisionLibrary_0()
{
  void *v0;
  __int128 v1;
  uint64_t v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v0 = 0;
  if (!VisionLibraryCore_frameworkLibrary_0)
  {
    v1 = xmmword_1E2EC4AD8;
    v2 = 0;
    VisionLibraryCore_frameworkLibrary_0 = _sl_dlopen();
  }
  if (!VisionLibraryCore_frameworkLibrary_0)
    VisionLibrary_cold_1(&v0);
}

Class __getVNImageRequestHandlerClass_block_invoke(uint64_t a1)
{
  Class result;

  VisionLibrary_0();
  result = objc_getClass("VNImageRequestHandler");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getVNImageRequestHandlerClass_block_invoke_cold_1();
  getVNImageRequestHandlerClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t ci_signpost_log_perspectiveAC(void)
{
  if (ci_signpost_log_perspectiveAC(void)::onceToken != -1)
    dispatch_once(&ci_signpost_log_perspectiveAC(void)::onceToken, &__block_literal_global_52);
  return ci_signpost_log_perspectiveAC(void)::log;
}

os_log_t ___Z29ci_signpost_log_perspectiveACv_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "signpost_perspectiveAC");
  ci_signpost_log_perspectiveAC(void)::log = (uint64_t)result;
  return result;
}

uint64_t CIPerspectiveAutoCalcDefaultImpl(void)
{
  void *v0;
  unint64_t v1;
  uint64_t v2;

  v0 = (void *)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0C99EA0], "standardUserDefaults"), "objectForKey:", CFSTR("com.apple.CoreImage.PerspectiveACVersion"));
  if (v0)
  {
    v1 = objc_msgSend(v0, "integerValue");
    v2 = 2;
    if (v1 < 2)
      v2 = v1;
    if (v2 != 1 && v2 != 2)
      CIPerspectiveAutoCalcDefaultImpl();
  }
  return objc_opt_class();
}

void sub_1923253F8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::Perspective::plotLines<CI::Perspective::Line>(void *a1, CGColor *a2, uint64_t **a3)
{
  double v6;
  size_t v7;
  double v8;
  size_t v9;
  unint64_t v10;
  unint64_t v11;
  double v12;
  float v13;
  double v14;
  float v15;
  CGColorSpace *DeviceRGB;
  CGContext *v17;
  uint64_t *v18;
  uint64_t *v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  float v23;
  float v24;
  CGFloat v25;
  CGFloat v26;
  CGFloat v27;
  CGFloat v28;
  CGFloat v29;
  CGFloat v30;
  CGFloat v31;
  CGFloat v32;
  CGFloat v33;
  CGFloat v34;
  CGFloat v35;
  CGFloat v36;
  CGFloat v37;
  CGImage *Image;
  CIImage *v39;
  uint64_t v40;
  float v42;
  CGAffineTransform v43;

  objc_msgSend(a1, "extent");
  v7 = (unint64_t)v6;
  objc_msgSend(a1, "extent");
  v9 = (unint64_t)v8;
  if (v7 <= (unint64_t)v8)
    v10 = (unint64_t)v8;
  else
    v10 = v7;
  if (v10 < 0x1F4)
    v11 = 1;
  else
    v11 = v10 / 0x1F4;
  objc_msgSend(a1, "extent");
  v13 = v12;
  objc_msgSend(a1, "extent");
  v15 = v14;
  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  v17 = CGBitmapContextCreate(0, v7, v9, 8uLL, 4 * v7, DeviceRGB, 1u);
  CGContextSetStrokeColorWithColor(v17, a2);
  CGContextSetLineWidth(v17, (double)v11);
  v19 = *a3;
  v18 = a3[1];
  if (v19 != v18)
  {
    v20 = (double)(2 * v11);
    v42 = v15;
    do
    {
      v21 = *v19;
      v22 = v19[1];
      v19 += 2;
      v23 = *(float *)&v22 - v13;
      v24 = *((float *)&v22 + 1) - v15;
      v25 = (float)(*(float *)&v21 - v13);
      v26 = (float)(*((float *)&v21 + 1) - v15);
      CGContextMoveToPoint(v17, v25, v26);
      v27 = v23;
      v28 = v24;
      CGContextAddLineToPoint(v17, v27, v28);
      v29 = v25 - v20;
      v30 = v20 + v26;
      CGContextMoveToPoint(v17, v25 - v20, v20 + v26);
      v31 = v20 + v25;
      v32 = v26 - v20;
      CGContextAddLineToPoint(v17, v31, v32);
      CGContextMoveToPoint(v17, v29, v32);
      CGContextAddLineToPoint(v17, v31, v30);
      v33 = v27 - v20;
      v34 = v20 + v28;
      CGContextMoveToPoint(v17, v27 - v20, v20 + v28);
      v35 = v20 + v27;
      v36 = v28 - v20;
      CGContextAddLineToPoint(v17, v35, v36);
      CGContextMoveToPoint(v17, v33, v36);
      v37 = v34;
      v15 = v42;
      CGContextAddLineToPoint(v17, v35, v37);
    }
    while (v19 != v18);
  }
  CGContextStrokePath(v17);
  Image = CGBitmapContextCreateImage(v17);
  v39 = +[CIImage imageWithCGImage:](CIImage, "imageWithCGImage:", Image);
  CGAffineTransformMakeTranslation(&v43, v13, v15);
  v40 = -[CIImage imageByCompositingOverImage:](-[CIImage imageByApplyingTransform:](v39, "imageByApplyingTransform:", &v43), "imageByCompositingOverImage:", a1);
  CGImageRelease(Image);
  CGContextRelease(v17);
  CGColorSpaceRelease(DeviceRGB);
  return v40;
}

void sub_192327048(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,uint64_t a30,void *a31,uint64_t a32)
{
  void *v32;
  uint64_t v33;
  void *v35;

  operator delete(v32);
  if (__p)
    operator delete(__p);
  if (a31)
    operator delete(a31);
  v35 = *(void **)(v33 - 168);
  if (v35)
  {
    *(_QWORD *)(v33 - 160) = v35;
    operator delete(v35);
  }
  _Unwind_Resume(a1);
}

void std::vector<CI::Perspective::Line>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 4)
  {
    if (a2 >> 60)
      abort();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF0];
    v9 = &v6[16 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - 1) = *((_OWORD *)v10 - 1);
        v12 -= 16;
        v10 -= 16;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void sub_192327924(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_192328790(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

char *std::vector<CI::Perspective::Line>::__vallocate[abi:nn180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    abort();
  result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(16 * a2);
}

double cikernel::_gradientNormalizeV1(float32x4_t a1, float a2)
{
  double result;

  *(_QWORD *)&result = vmulq_n_f32(a1, a2).u64[0];
  return result;
}

float32x2_t cikernel::_gradientThresholdV1(float32x4_t a1, float a2, float a3)
{
  float v3;
  float v4;
  BOOL v5;
  float v6;

  v3 = (float)(sqrtf(vaddv_f32((float32x2_t)*(_OWORD *)&vmulq_f32(a1, a1))) - a2) / (float)(a3 - a2);
  v4 = 1.0;
  if (v3 <= 1.0)
    v4 = v3;
  v5 = v3 < 0.0;
  v6 = 0.0;
  if (!v5)
    v6 = v4;
  return vmul_n_f32(*(float32x2_t *)a1.f32, (float)(v6 * v6) * (float)((float)(v6 * -2.0) + 3.0));
}

double cikernel::_gradientRangeLimit(float32x4_t a1, float a2, float a3, float a4, float a5)
{
  float v5;
  float v6;
  double v7;
  float v8;
  float v9;
  BOOL v10;
  float v11;

  v5 = fabsf(a1.f32[1]);
  v6 = fabsf(a1.f32[0]);
  v7 = 0.0;
  if ((float)(v5 + v6) >= 0.001)
  {
    if (v6 >= v5)
      v8 = (float)((float)(a1.f32[1] / a1.f32[0]) - a4) / (float)(a5 - a4);
    else
      v8 = (float)((float)(a1.f32[0] / a1.f32[1]) - a2) / (float)(a3 - a2);
    if (v8 <= 1.0)
      v9 = v8;
    else
      v9 = 1.0;
    v10 = v8 < 0.0;
    v11 = 0.0;
    if (!v10)
      v11 = v9;
    *(_QWORD *)&v7 = vmulq_n_f32(a1, 1.0 - (float)((float)(v11 * v11) * (float)((float)(v11 * -2.0) + 3.0))).u64[0];
  }
  return v7;
}

void CI::f4_s_f_f_f_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, float, float, float, float);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __n128 *v18;
  __int128 v19;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, float, float, float, float))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_QWORD *)(v10 + 80);
  v17 = *(_QWORD *)(v10 + 104);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 128)), a2);
  v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v19 = v11(a1, *v18, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16), *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

uint64_t std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,-[CIPerspectiveAutoCalcV1 clusterLineSegments]::$_0::operator() const(std::vector<CI::Perspective::Line> const&,unsigned long)::{lambda(-[CIPerspectiveAutoCalcV1 clusterLineSegments]::Hypothesis const&,-[CIPerspectiveAutoCalcV1 clusterLineSegments]::Hypothesis const&)#1} &,std::__wrap_iter<-[CIPerspectiveAutoCalcV1 clusterLineSegments]::Hypothesis*>>(uint64_t result, uint64_t a2, float *a3)
{
  int64_t v3;
  int64_t v4;
  __int128 *v5;
  float v6;
  int v7;
  float *v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  if (a2 >= 2)
  {
    v3 = (unint64_t)(a2 - 2) >> 1;
    if (v3 >= (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)a3 - result) >> 3)))
    {
      v4 = (0x999999999999999ALL * (((uint64_t)a3 - result) >> 3)) | 1;
      v5 = (__int128 *)(result + 40 * v4);
      if ((uint64_t)(0x999999999999999ALL * (((uint64_t)a3 - result) >> 3) + 2) < a2
        && *(float *)(result + 40 * v4 + 32) > *((float *)v5 + 18))
      {
        v5 = (__int128 *)((char *)v5 + 40);
        v4 = 0x999999999999999ALL * (((uint64_t)a3 - result) >> 3) + 2;
      }
      v6 = a3[8];
      if (*((float *)v5 + 8) <= v6)
      {
        v13 = *(_OWORD *)a3;
        v14 = *((_OWORD *)a3 + 1);
        v7 = *((_DWORD *)a3 + 9);
        do
        {
          v8 = a3;
          a3 = (float *)v5;
          v9 = *v5;
          v10 = v5[1];
          *((_QWORD *)v8 + 4) = *((_QWORD *)v5 + 4);
          *(_OWORD *)v8 = v9;
          *((_OWORD *)v8 + 1) = v10;
          if (v3 < v4)
            break;
          v11 = (2 * v4) | 1;
          v5 = (__int128 *)(result + 40 * v11);
          v12 = 2 * v4 + 2;
          if (v12 < a2 && *(float *)(result + 40 * v11 + 32) > *((float *)v5 + 18))
          {
            v5 = (__int128 *)((char *)v5 + 40);
            v11 = v12;
          }
          v4 = v11;
        }
        while (*((float *)v5 + 8) <= v6);
        *(_OWORD *)a3 = v13;
        *((_OWORD *)a3 + 1) = v14;
        a3[8] = v6;
        *((_DWORD *)a3 + 9) = v7;
      }
    }
  }
  return result;
}

char *std::vector<CI::Perspective::Line>::__assign_with_size[abi:nn180100]<CI::Perspective::Line*,CI::Perspective::Line*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60)
      abort();
    v10 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<CI::Perspective::Line>::__vallocate[abi:nn180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 4;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

void sub_19232BF68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,uint64_t a30,void *a31,uint64_t a32)
{
  void *v32;
  uint64_t v33;
  void *v35;

  operator delete(v32);
  if (__p)
    operator delete(__p);
  if (a31)
    operator delete(a31);
  v35 = *(void **)(v33 - 168);
  if (v35)
  {
    *(_QWORD *)(v33 - 160) = v35;
    operator delete(v35);
  }
  _Unwind_Resume(a1);
}

void sub_19232C7A0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<LineCostProxy>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (_BYTE *)*a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL)
      abort();
    v5 = ((_BYTE *)a1[1] - (_BYTE *)*a1) / 24;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(v3, a2);
    v7 = &v6[24 * v5];
    v9 = &v6[24 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *(_OWORD *)(v10 - 24);
        *((_QWORD *)v12 - 1) = *((_QWORD *)v10 - 1);
        *(_OWORD *)(v12 - 24) = v13;
        v12 -= 24;
        v10 -= 24;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

double cikernel::_lumaRange(float32x4_t a1, float a2, float a3)
{
  float32x4_t v3;
  int32x2_t v4;
  float v5;
  BOOL v6;
  double result;

  v3 = vmulq_f32(a1, (float32x4_t)xmmword_1924967C0);
  v4 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).u64[0];
  *(float *)v4.i32 = (float)(*(float *)v4.i32 - a2) / (float)(a3 - a2);
  if (*(float *)v4.i32 <= 1.0)
    v5 = *(float *)v4.i32;
  else
    v5 = 1.0;
  v6 = *(float *)v4.i32 < 0.0;
  v4.i32[0] = 0;
  if (!v6)
    *(float *)v4.i32 = v5;
  *(float *)v4.i32 = (float)(*(float *)v4.i32 * *(float *)v4.i32) * (float)((float)(*(float *)v4.i32 * -2.0) + 3.0);
  *(_QWORD *)&result = vdupq_lane_s32(v4, 0).u64[0];
  return result;
}

double cikernel::_gradientNormalizeV2(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vmulq_n_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0)), 1.0 / vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 1), a2).f32[0]).u64[0];
  return result;
}

float32x2_t cikernel::_gradientThresholdV2(float32x4_t a1, float a2, float a3)
{
  float v3;
  float v4;
  BOOL v5;
  float v6;

  v3 = (float)(sqrtf(vaddv_f32((float32x2_t)*(_OWORD *)&vmulq_f32(a1, a1))) - a2) / (float)(a3 - a2);
  v4 = 1.0;
  if (v3 <= 1.0)
    v4 = v3;
  v5 = v3 < 0.0;
  v6 = 0.0;
  if (!v5)
    v6 = v4;
  return vmul_n_f32(*(float32x2_t *)a1.f32, (float)(v6 * v6) * (float)((float)(v6 * -2.0) + 3.0));
}

uint64_t _ZN2CI11Perspective9NMSimplexIDv3_fEC2ENS0_8NMParamsEU13block_pointerFfRKS2_EPS5_m(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  __int128 v10;
  char **v11;
  uint64_t v12;
  float v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  float *v22;
  char *v23;
  char *v24;
  float *v25;
  __int128 v26;
  unint64_t v28;
  __n128 *v29;
  unint64_t v30;
  uint64_t v31;
  int32x2_t v32;
  uint64_t v33;
  float32x4_t *v34;
  uint64_t v35;
  float32x4_t v36;
  unint64_t v37;
  float32x4_t *v38;
  uint64_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t *v42;
  float v43;
  float32x4_t v45;
  int8x16_t v46;
  float v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  float v51;
  float32x4_t *v52;
  float32x4_t v53;
  int8x16_t v54;
  float32x4_t v55;
  __int128 v56;
  float32x4_t v57;
  int8x16_t v58;
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  int8x16_t v62;
  float32x4_t v63;

  v10 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v10;
  *(_QWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 40) = 0;
  v11 = (char **)(a1 + 40);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  _ZNSt3__16vectorIN2CI11Perspective9NMSimplexIDv3_fE8NMVertexENS_9allocatorIS6_EEE7reserveEm((void **)(a1 + 40), a5);
  if (a5)
  {
    v12 = 0;
    do
    {
      v56 = *(_OWORD *)(a4 + 16 * v12);
      v13 = (*(float (**)(uint64_t))(a3 + 16))(a3);
      v15 = *(_QWORD *)(a1 + 48);
      v14 = *(_QWORD *)(a1 + 56);
      if (v15 >= v14)
      {
        v17 = (uint64_t)(v15 - (_QWORD)*v11) >> 5;
        v18 = v17 + 1;
        if ((unint64_t)(v17 + 1) >> 59)
          abort();
        v19 = v14 - (_QWORD)*v11;
        if (v19 >> 4 > v18)
          v18 = v19 >> 4;
        if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFE0)
          v20 = 0x7FFFFFFFFFFFFFFLL;
        else
          v20 = v18;
        if (v20)
          v21 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>(a1 + 56, v20);
        else
          v21 = 0;
        v22 = (float *)&v21[32 * v17];
        *(_OWORD *)v22 = v56;
        v22[4] = v13;
        v24 = *(char **)(a1 + 40);
        v23 = *(char **)(a1 + 48);
        v25 = v22;
        if (v23 != v24)
        {
          do
          {
            v26 = *((_OWORD *)v23 - 1);
            *((_OWORD *)v25 - 2) = *((_OWORD *)v23 - 2);
            *((_OWORD *)v25 - 1) = v26;
            v25 -= 8;
            v23 -= 32;
          }
          while (v23 != v24);
          v23 = *v11;
        }
        v16 = (char *)(v22 + 8);
        *(_QWORD *)(a1 + 40) = v25;
        *(_QWORD *)(a1 + 48) = v22 + 8;
        *(_QWORD *)(a1 + 56) = &v21[32 * v20];
        if (v23)
          operator delete(v23);
      }
      else
      {
        *(_OWORD *)v15 = v56;
        *(float *)(v15 + 16) = v13;
        v16 = (char *)(v15 + 32);
      }
      *(_QWORD *)(a1 + 48) = v16;
      ++v12;
    }
    while (v12 != a5);
  }
  for (*(_QWORD *)(a1 + 64) = 1;
        (_ZNK2CI11Perspective9NMSimplexIDv3_fE15shouldTerminateEv(a1) & 1) == 0;
        ++*(_QWORD *)(a1 + 64))
  {
    v28 = *(_QWORD *)(a1 + 40);
    v29 = *(__n128 **)(a1 + 48);
    v30 = 126 - 2 * __clz((uint64_t)((uint64_t)v29 - v28) >> 5);
    if (v29 == (__n128 *)v28)
      v31 = 0;
    else
      v31 = v30;
    _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_Lb0EEEvT1_SD_T0_NS_15iterator_traitsISD_E15difference_typeEb(v28, v29, (uint64_t)&v63, v31, 1);
    v34 = *(float32x4_t **)(a1 + 40);
    v33 = *(_QWORD *)(a1 + 48);
    v35 = (v33 - (uint64_t)v34) >> 5;
    v36 = 0uLL;
    v37 = v35 - 1;
    if (v35 != 1)
    {
      v38 = *(float32x4_t **)(a1 + 40);
      v39 = v35 - 1;
      do
      {
        v40 = *v38;
        v38 += 2;
        v32.i32[1] = v40.i32[1];
        v36 = vaddq_f32(v36, v40);
        --v39;
      }
      while (v39);
    }
    *(float *)v32.i32 = (float)v37;
    v63.i32[2] = 0;
    v63.i64[0] = 0;
    v57 = vdivq_f32(v36, (float32x4_t)vdupq_lane_s32(v32, 0));
    v54 = (int8x16_t)vmlaq_n_f32(v57, vsubq_f32(v57, *(float32x4_t *)(v33 - 32)), *(float *)a1);
    v63 = (float32x4_t)v54;
    v41.i32[0] = (*(float (**)(uint64_t, float32x4_t *))(a3 + 16))(a3, &v63);
    v42 = &v34[2 * v37];
    v43 = v34[1].f32[0];
    if (v43 <= v41.f32[0] && v41.f32[0] < v34[2 * v35 - 3].f32[0])
    {
      *v42 = (float32x4_t)v54;
      v42[1].i32[0] = v41.i32[0];
    }
    else
    {
      if (v41.f32[0] < v43)
      {
        v53 = v41;
        v58 = (int8x16_t)vmlaq_n_f32(v57, vsubq_f32(v63, v57), *(float *)(a1 + 4));
        v62 = v58;
        *(double *)v45.i64 = (*(double (**)(uint64_t, int8x16_t *))(a3 + 16))(a3, &v62);
        v46 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v53, v45), 0), v58, v54);
        v42[1].i32[3] = 0;
        *(uint64_t *)((char *)v42[1].i64 + 4) = 0;
        if (v45.f32[0] >= v53.f32[0])
          v45.f32[0] = v53.f32[0];
        *v42 = (float32x4_t)v46;
        v42[1].i32[0] = v45.i32[0];
        continue;
      }
      v62.i32[2] = 0;
      v62.i64[0] = 0;
      v59 = vmlaq_n_f32(v57, vsubq_f32(*(float32x4_t *)(*(_QWORD *)(a1 + 48) - 32), v57), *(float *)(a1 + 8));
      v62 = (int8x16_t)v59;
      v47 = (*(float (**)(uint64_t, int8x16_t *))(a3 + 16))(a3, &v62);
      if (v47 >= v34[2 * v37 + 1].f32[0])
      {
        v48 = *(_QWORD *)(a1 + 40);
        if ((unint64_t)(*(_QWORD *)(a1 + 48) - v48) >= 0x21)
        {
          v49 = 0;
          v55 = *v34;
          v50 = 1;
          do
          {
            v61.i32[2] = 0;
            v61.i64[0] = 0;
            v60 = vmlaq_n_f32(v55, vsubq_f32(*(float32x4_t *)(v48 + v49 + 32), v55), *(float *)(a2 + 12));
            v61 = v60;
            v51 = (*(float (**)(uint64_t, float32x4_t *))(a3 + 16))(a3, &v61);
            v52 = (float32x4_t *)(*(_QWORD *)(a1 + 40) + v49);
            v52[2] = v60;
            v52[3].f32[0] = v51;
            ++v50;
            v48 = *(_QWORD *)(a1 + 40);
            v49 += 32;
          }
          while (v50 < (*(_QWORD *)(a1 + 48) - v48) >> 5);
        }
        continue;
      }
      *v42 = v59;
      v42[1].f32[0] = v47;
    }
    *(uint64_t *)((char *)v42[1].i64 + 4) = 0;
    v42[1].i32[3] = 0;
  }
  return a1;
}

void sub_19232F10C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 48) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void _ZNSt3__16vectorIN2CI11Perspective9NMSimplexIDv3_fE8NMVertexENS_9allocatorIS6_EEE7reserveEm(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 5)
  {
    if (a2 >> 59)
      abort();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFE0];
    v9 = &v6[32 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v13;
        v12 -= 32;
        v10 -= 32;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t _ZNK2CI11Perspective9NMSimplexIDv3_fE15shouldTerminateEv(uint64_t a1)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  float v4;
  uint64_t v5;
  float v6;
  float v7;
  float v8;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1 && *(_QWORD *)(a1 + 64) >= v1)
    return 1;
  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 48);
  if (v2 == v3)
  {
    v6 = (float)(unint64_t)((v3 - v2) >> 5);
  }
  else
  {
    v4 = 0.0;
    v5 = *(_QWORD *)(a1 + 40);
    do
    {
      v4 = v4 + *(float *)(v5 + 16);
      v5 += 32;
    }
    while (v5 != v3);
    v6 = (float)(unint64_t)((v3 - v2) >> 5);
    if (v3 != v2)
    {
      v7 = 0.0;
      v8 = v4 / v6;
      do
      {
        v7 = v7 + (float)((float)(*(float *)(v2 + 16) - v8) * (float)(*(float *)(v2 + 16) - v8));
        v2 += 32;
      }
      while (v2 != v3);
      return sqrtf(v7 / v6) < *(float *)(a1 + 16);
    }
  }
  v7 = 0.0;
  return sqrtf(v7 / v6) < *(float *)(a1 + 16);
}

void _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_Lb0EEEvT1_SD_T0_NS_15iterator_traitsISD_E15difference_typeEb(unint64_t a1, __n128 *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  __int128 v16;
  unint64_t v17;
  char v18;
  BOOL v19;
  __n128 v20;
  __n128 v21;
  __n128 v22;
  __int128 v23;
  __n128 v24;

LABEL_1:
  v9 = a1;
LABEL_2:
  v10 = 1 - a4;
  while (2)
  {
    a1 = v9;
    v11 = v10;
    v12 = (uint64_t)a2 - v9;
    v13 = (uint64_t)((uint64_t)a2 - v9) >> 5;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (a2[-1].n128_f32[0] < *(float *)(v9 + 16))
        {
          v22 = *(__n128 *)v9;
          v24 = *(__n128 *)(v9 + 16);
          v20 = a2[-1];
          *(__n128 *)v9 = a2[-2];
          *(__n128 *)(v9 + 16) = v20;
          a2[-2] = v22;
          a2[-1] = v24;
        }
        return;
      case 3uLL:
        _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)v9, (float *)(v9 + 32), (float *)&a2[-2]);
        return;
      case 4uLL:
        _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_((__n128 *)v9, (__n128 *)(v9 + 32), (__n128 *)(v9 + 64), a2 - 2);
        return;
      case 5uLL:
        _ZNSt3__17__sort5B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_SD_T0_((__n128 *)v9, (__n128 *)(v9 + 32), (__n128 *)(v9 + 64), (__n128 *)(v9 + 96), a2 - 2);
        return;
      default:
        if (v12 <= 767)
        {
          if ((a5 & 1) != 0)
            _ZNSt3__116__insertion_sortB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_(v9, a2);
          else
            _ZNSt3__126__insertion_sort_unguardedB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_((__int128 *)v9, (__int128 *)a2);
          return;
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = v9 + 32 * (v13 >> 1);
          if ((unint64_t)v12 <= 0x1000)
          {
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)(v9 + 32 * (v13 >> 1)), (float *)v9, (float *)&a2[-2]);
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          else
          {
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)v9, (float *)(v9 + 32 * (v13 >> 1)), (float *)&a2[-2]);
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)(v9 + 32), (float *)(v15 - 32), (float *)&a2[-4]);
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)(v9 + 64), (float *)(v9 + 32 + 32 * v14), (float *)&a2[-6]);
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)(v15 - 32), (float *)v15, (float *)(v9 + 32 + 32 * v14));
            v21 = *(__n128 *)v9;
            v23 = *(_OWORD *)(v9 + 16);
            v16 = *(_OWORD *)(v15 + 16);
            *(_OWORD *)v9 = *(_OWORD *)v15;
            *(_OWORD *)(v9 + 16) = v16;
            *(__n128 *)v15 = v21;
            *(_OWORD *)(v15 + 16) = v23;
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          if (*(float *)(v9 - 16) >= *(float *)(v9 + 16))
          {
            v9 = _ZNSt3__131__partition_with_equals_on_leftB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv3_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EET0_SD_SD_T1_((__int128 *)v9, (float *)a2);
            goto LABEL_16;
          }
LABEL_11:
          v17 = _ZNSt3__132__partition_with_equals_on_rightB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv3_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EENS_4pairIT0_bEESE_SE_T1_((__int128 *)v9, (float *)a2);
          if ((v18 & 1) == 0)
            goto LABEL_14;
          v19 = _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEbT1_SD_T0_(v9, v17);
          v9 = v17 + 32;
          if (!_ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEbT1_SD_T0_(v17 + 32, (uint64_t)a2))
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_14:
            _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_Lb0EEEvT1_SD_T0_NS_15iterator_traitsISD_E15difference_typeEb(a1, v17, a3, -v11, a5 & 1);
            v9 = v17 + 32;
LABEL_16:
            a5 = 0;
            a4 = -v11;
            goto LABEL_2;
          }
          a4 = -v11;
          a2 = (__n128 *)v17;
          if (v19)
            return;
          goto LABEL_1;
        }
        if ((__n128 *)v9 != a2)
          _ZNSt3__119__partial_sort_implB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_SC_EET1_SD_SD_T2_OT0_(v9, (float *)a2, (float *)a2, a3);
        return;
    }
  }
}

  v9 = a1;
LABEL_2:
  v10 = 1 - a4;
  while (2)
  {
    a1 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = a2 - v9;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (a2[-1].n128_f32[2] < v9->n128_f32[2])
        {
          v20 = *v9;
          *v9 = a2[-1];
          a2[-1] = v20;
        }
        return;
      case 3uLL:
        _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)v9, (float *)&v9[1], (float *)&a2[-1]);
        return;
      case 4uLL:
        _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_((float *)v9, (uint64_t)&v9[1], (uint64_t)&v9[2], (uint64_t)&a2[-1]);
        return;
      case 5uLL:
        _ZNSt3__17__sort5B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_SD_T0_((float *)v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1);
        return;
      default:
        if (v12 <= 383)
        {
          if ((a5 & 1) != 0)
            _ZNSt3__116__insertion_sortB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_((uint64_t)v9, a2);
          else
            _ZNSt3__126__insertion_sort_unguardedB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_(v9, a2);
          return;
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = (float *)&v9[v13 >> 1];
          if ((unint64_t)v12 < 0x801)
          {
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)&v9[v13 >> 1], (float *)v9, (float *)&a2[-1]);
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          else
          {
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)v9, (float *)&v9[v13 >> 1], (float *)&a2[-1]);
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)&v9[1], v15 - 4, (float *)&a2[-2]);
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)&v9[2], (float *)&v9[v14 + 1], (float *)&a2[-3]);
            _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_(v15 - 4, v15, (float *)&v9[v14 + 1]);
            v19 = *v9;
            *v9 = *(__n128 *)v15;
            *(__n128 *)v15 = v19;
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          if (v9[-1].n128_f32[2] >= v9->n128_f32[2])
          {
            v9 = (__n128 *)_ZNSt3__131__partition_with_equals_on_leftB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv2_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EET0_SD_SD_T1_((float *)v9, (float *)a2);
            goto LABEL_16;
          }
LABEL_11:
          v16 = (__n128 *)_ZNSt3__132__partition_with_equals_on_rightB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv2_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EENS_4pairIT0_bEESE_SE_T1_((float *)v9, (float *)a2);
          if ((v17 & 1) == 0)
            goto LABEL_14;
          v18 = _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEbT1_SD_T0_(v9, v16);
          v9 = v16 + 1;
          if (!_ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEbT1_SD_T0_(v16 + 1, a2))
          {
            v10 = v11 + 1;
            if (v18)
              continue;
LABEL_14:
            _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_Lb0EEEvT1_SD_T0_NS_15iterator_traitsISD_E15difference_typeEb(a1, v16, a3, -v11, a5 & 1);
            v9 = v16 + 1;
LABEL_16:
            a5 = 0;
            a4 = -v11;
            goto LABEL_2;
          }
          a4 = -v11;
          a2 = v16;
          if (v18)
            return;
          goto LABEL_1;
        }
        if (v9 != a2)
          _ZNSt3__119__partial_sort_implB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_SC_EET1_SD_SD_T2_OT0_((float *)v9, (float *)a2, (float *)a2, a3);
        return;
    }
  }
}

uint64_t _ZNSt3__116__insertion_sortB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_(uint64_t result, _OWORD *a2)
{
  _OWORD *v2;
  uint64_t v3;
  _OWORD *v4;
  _OWORD *v5;
  float v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  int v13;

  if ((_OWORD *)result != a2)
  {
    v2 = (_OWORD *)(result + 32);
    if ((_OWORD *)(result + 32) != a2)
    {
      v3 = 0;
      v4 = (_OWORD *)result;
      do
      {
        v5 = v2;
        v6 = *((float *)v4 + 12);
        if (v6 < *((float *)v4 + 4))
        {
          v11 = *v2;
          v12 = *(_QWORD *)((char *)v4 + 52);
          v13 = *((_DWORD *)v4 + 15);
          v7 = v3;
          while (1)
          {
            v8 = result + v7;
            v9 = *(_OWORD *)(result + v7 + 16);
            *(_OWORD *)(v8 + 32) = *(_OWORD *)(result + v7);
            *(_OWORD *)(v8 + 48) = v9;
            if (!v7)
              break;
            v7 -= 32;
            if (v6 >= *(float *)(v8 - 16))
            {
              v10 = result + v7 + 32;
              goto LABEL_10;
            }
          }
          v10 = result;
LABEL_10:
          *(_OWORD *)v10 = v11;
          *(float *)(v10 + 16) = v6;
          *(_QWORD *)(v10 + 20) = v12;
          *(_DWORD *)(v10 + 28) = v13;
        }
        v2 = v5 + 2;
        v3 += 32;
        v4 = v5;
      }
      while (v5 + 2 != a2);
    }
  }
  return result;
}

__int128 *_ZNSt3__126__insertion_sort_unguardedB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_(__int128 *result, __int128 *a2)
{
  __int128 *v2;
  __int128 *v3;
  float v4;
  __int128 v5;
  float v6;
  __int128 v7;
  uint64_t v8;
  int v9;

  if (result != a2)
  {
    v2 = result + 2;
    while (v2 != a2)
    {
      v3 = v2;
      v4 = *((float *)result + 12);
      if (v4 < *((float *)result + 4))
      {
        v7 = *v2;
        v8 = *(_QWORD *)((char *)result + 52);
        v9 = *((_DWORD *)result + 15);
        do
        {
          v5 = *(v2 - 1);
          *v2 = *(v2 - 2);
          v2[1] = v5;
          v6 = *((float *)v2 - 12);
          v2 -= 2;
        }
        while (v4 < v6);
        *v2 = v7;
        *((float *)v2 + 4) = v4;
        *(_QWORD *)((char *)v2 + 20) = v8;
        *((_DWORD *)v2 + 7) = v9;
      }
      v2 = v3 + 2;
      result = v3;
    }
  }
  return result;
}

uint64_t _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_(float *a1, float *a2, float *a3)
{
  float v3;
  float v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;

  v3 = a2[4];
  v4 = a3[4];
  if (v3 < a1[4])
  {
    if (v4 < v3)
    {
      v6 = *(_OWORD *)a1;
      v5 = *((_OWORD *)a1 + 1);
      v7 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *((_OWORD *)a1 + 1) = v7;
      *(_OWORD *)a3 = v6;
      *((_OWORD *)a3 + 1) = v5;
      return 1;
    }
    v15 = *(_OWORD *)a1;
    v14 = *((_OWORD *)a1 + 1);
    v16 = *((_OWORD *)a2 + 1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *((_OWORD *)a1 + 1) = v16;
    *(_OWORD *)a2 = v15;
    *((_OWORD *)a2 + 1) = v14;
    if (a3[4] >= a2[4])
      return 1;
    v18 = *(_OWORD *)a2;
    v17 = *((_OWORD *)a2 + 1);
    v19 = *((_OWORD *)a3 + 1);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *((_OWORD *)a2 + 1) = v19;
    *(_OWORD *)a3 = v18;
    *((_OWORD *)a3 + 1) = v17;
    return 2;
  }
  if (v4 < v3)
  {
    v9 = *(_OWORD *)a2;
    v8 = *((_OWORD *)a2 + 1);
    v10 = *((_OWORD *)a3 + 1);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *((_OWORD *)a2 + 1) = v10;
    *(_OWORD *)a3 = v9;
    *((_OWORD *)a3 + 1) = v8;
    if (a2[4] >= a1[4])
      return 1;
    v12 = *(_OWORD *)a1;
    v11 = *((_OWORD *)a1 + 1);
    v13 = *((_OWORD *)a2 + 1);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *((_OWORD *)a1 + 1) = v13;
    *(_OWORD *)a2 = v12;
    *((_OWORD *)a2 + 1) = v11;
    return 2;
  }
  return 0;
}

unint64_t _ZNSt3__131__partition_with_equals_on_leftB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv3_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EET0_SD_SD_T1_(__int128 *a1, float *a2)
{
  float v2;
  float *v3;
  unint64_t v4;
  float v5;
  unint64_t v6;
  float v7;
  float *v8;
  float v9;
  __int128 v10;
  float v11;
  float v12;
  __int128 *v13;
  __int128 v14;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  int v20;

  v16 = *a1;
  v2 = *((float *)a1 + 4);
  v19 = *(_QWORD *)((char *)a1 + 20);
  v20 = *((_DWORD *)a1 + 7);
  if (v2 >= *(a2 - 4))
  {
    v6 = (unint64_t)(a1 + 2);
    do
    {
      v4 = v6;
      if (v6 >= (unint64_t)a2)
        break;
      v7 = *(float *)(v6 + 16);
      v6 += 32;
    }
    while (v2 >= v7);
  }
  else
  {
    v3 = (float *)a1;
    do
    {
      v4 = (unint64_t)(v3 + 8);
      v5 = v3[12];
      v3 += 8;
    }
    while (v2 >= v5);
  }
  if (v4 >= (unint64_t)a2)
  {
    v8 = a2;
  }
  else
  {
    do
    {
      v8 = a2 - 8;
      v9 = *(a2 - 4);
      a2 -= 8;
    }
    while (v2 < v9);
  }
  while (v4 < (unint64_t)v8)
  {
    v17 = *(_OWORD *)v4;
    v18 = *(_OWORD *)(v4 + 16);
    v10 = *((_OWORD *)v8 + 1);
    *(_OWORD *)v4 = *(_OWORD *)v8;
    *(_OWORD *)(v4 + 16) = v10;
    *(_OWORD *)v8 = v17;
    *((_OWORD *)v8 + 1) = v18;
    do
    {
      v11 = *(float *)(v4 + 48);
      v4 += 32;
    }
    while (v2 >= v11);
    do
    {
      v12 = *(v8 - 4);
      v8 -= 8;
    }
    while (v2 < v12);
  }
  v13 = (__int128 *)(v4 - 32);
  if ((__int128 *)(v4 - 32) != a1)
  {
    v14 = *(_OWORD *)(v4 - 16);
    *a1 = *v13;
    a1[1] = v14;
  }
  *v13 = v16;
  *(float *)(v4 - 16) = v2;
  *(_DWORD *)(v4 - 4) = v20;
  *(_QWORD *)(v4 - 12) = v19;
  return v4;
}

unint64_t _ZNSt3__132__partition_with_equals_on_rightB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv3_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EENS_4pairIT0_bEESE_SE_T1_(__int128 *a1, float *a2)
{
  uint64_t v2;
  float v3;
  float v4;
  unint64_t v5;
  float *v6;
  float v7;
  float v8;
  unint64_t v9;
  float *v10;
  __int128 v11;
  __int128 v12;
  float v13;
  float v14;
  __int128 *v15;
  __int128 v16;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  int v21;

  v2 = 0;
  v18 = *a1;
  v3 = *((float *)a1 + 4);
  v20 = *(_QWORD *)((char *)a1 + 20);
  v21 = *((_DWORD *)a1 + 7);
  do
  {
    v4 = *(float *)&a1[v2 + 3];
    v2 += 2;
  }
  while (v4 < v3);
  v5 = (unint64_t)&a1[v2];
  if (v2 == 2)
  {
    while (v5 < (unint64_t)a2)
    {
      v6 = a2 - 8;
      v8 = *(a2 - 4);
      a2 -= 8;
      if (v8 < v3)
        goto LABEL_9;
    }
    v6 = a2;
  }
  else
  {
    do
    {
      v6 = a2 - 8;
      v7 = *(a2 - 4);
      a2 -= 8;
    }
    while (v7 >= v3);
  }
LABEL_9:
  v9 = (unint64_t)&a1[v2];
  if (v5 < (unint64_t)v6)
  {
    v10 = v6;
    do
    {
      v11 = *(_OWORD *)v9;
      v19 = *(_OWORD *)(v9 + 16);
      v12 = *((_OWORD *)v10 + 1);
      *(_OWORD *)v9 = *(_OWORD *)v10;
      *(_OWORD *)(v9 + 16) = v12;
      *(_OWORD *)v10 = v11;
      *((_OWORD *)v10 + 1) = v19;
      do
      {
        v13 = *(float *)(v9 + 48);
        v9 += 32;
      }
      while (v13 < v3);
      do
      {
        v14 = *(v10 - 4);
        v10 -= 8;
      }
      while (v14 >= v3);
    }
    while (v9 < (unint64_t)v10);
  }
  v15 = (__int128 *)(v9 - 32);
  if ((__int128 *)(v9 - 32) != a1)
  {
    v16 = *(_OWORD *)(v9 - 16);
    *a1 = *v15;
    a1[1] = v16;
  }
  *v15 = v18;
  *(float *)(v9 - 16) = v3;
  *(_DWORD *)(v9 - 4) = v21;
  *(_QWORD *)(v9 - 12) = v20;
  return v9 - 32;
}

BOOL _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEbT1_SD_T0_(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  int v20;

  v4 = (a2 - a1) >> 5;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(float *)(a2 - 16) < *(float *)(a1 + 16))
      {
        v7 = *(_OWORD *)a1;
        v6 = *(_OWORD *)(a1 + 16);
        v8 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)(a1 + 16) = v8;
        *(_OWORD *)(a2 - 32) = v7;
        *(_OWORD *)(a2 - 16) = v6;
      }
      return result;
    case 3:
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)a1, (float *)(a1 + 32), (float *)(a2 - 32));
      return 1;
    case 4:
      _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_((__n128 *)a1, (__n128 *)(a1 + 32), (__n128 *)(a1 + 64), (__n128 *)(a2 - 32));
      return 1;
    case 5:
      _ZNSt3__17__sort5B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_SD_T0_((__n128 *)a1, (__n128 *)(a1 + 32), (__n128 *)(a1 + 64), (__n128 *)(a1 + 96), (__n128 *)(a2 - 32));
      return 1;
    default:
      v9 = a1 + 64;
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)a1, (float *)(a1 + 32), (float *)(a1 + 64));
      v10 = a1 + 96;
      if (a1 + 96 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    v13 = *(float *)(v10 + 16);
    if (v13 < *(float *)(v9 + 16))
    {
      v18 = *(_OWORD *)v10;
      v19 = *(_QWORD *)(v10 + 20);
      v20 = *(_DWORD *)(v10 + 28);
      v14 = v11;
      while (1)
      {
        v15 = a1 + v14;
        v16 = *(_OWORD *)(a1 + v14 + 80);
        *(_OWORD *)(v15 + 96) = *(_OWORD *)(a1 + v14 + 64);
        *(_OWORD *)(v15 + 112) = v16;
        if (v14 == -64)
          break;
        v14 -= 32;
        if (v13 >= *(float *)(v15 + 48))
        {
          v17 = a1 + v14 + 96;
          goto LABEL_12;
        }
      }
      v17 = a1;
LABEL_12:
      *(_OWORD *)v17 = v18;
      *(float *)(v17 + 16) = v13;
      *(_QWORD *)(v17 + 20) = v19;
      *(_DWORD *)(v17 + 28) = v20;
      if (++v12 == 8)
        return v10 + 32 == a2;
    }
    v9 = v10;
    v11 += 32;
    v10 += 32;
    if (v10 == a2)
      return 1;
  }
}

__n128 _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4)
{
  __n128 result;
  __n128 v9;
  __n128 v10;
  __n128 v11;
  __n128 v12;
  __n128 v13;
  __n128 v14;

  _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)a1, (float *)a2, (float *)a3);
  result.n128_u32[0] = a4[1].n128_u32[0];
  if (result.n128_f32[0] < a3[1].n128_f32[0])
  {
    v9 = *a3;
    result = a3[1];
    v10 = a4[1];
    *a3 = *a4;
    a3[1] = v10;
    *a4 = v9;
    a4[1] = result;
    result.n128_u32[0] = a3[1].n128_u32[0];
    if (result.n128_f32[0] < a2[1].n128_f32[0])
    {
      v11 = *a2;
      result = a2[1];
      v12 = a3[1];
      *a2 = *a3;
      a2[1] = v12;
      *a3 = v11;
      a3[1] = result;
      result.n128_u32[0] = a2[1].n128_u32[0];
      if (result.n128_f32[0] < a1[1].n128_f32[0])
      {
        v13 = *a1;
        result = a1[1];
        v14 = a2[1];
        *a1 = *a2;
        a1[1] = v14;
        *a2 = v13;
        a2[1] = result;
      }
    }
  }
  return result;
}

__n128 _ZNSt3__17__sort5B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_SD_T0_(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  __n128 result;
  __n128 v11;
  __n128 v12;
  __n128 v13;
  __n128 v14;
  __n128 v15;
  __n128 v16;
  __n128 v17;
  __n128 v18;

  result = _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_(a1, a2, a3, a4);
  result.n128_u32[0] = a5[1].n128_u32[0];
  if (result.n128_f32[0] < a4[1].n128_f32[0])
  {
    v11 = *a4;
    result = a4[1];
    v12 = a5[1];
    *a4 = *a5;
    a4[1] = v12;
    *a5 = v11;
    a5[1] = result;
    result.n128_u32[0] = a4[1].n128_u32[0];
    if (result.n128_f32[0] < a3[1].n128_f32[0])
    {
      v13 = *a3;
      result = a3[1];
      v14 = a4[1];
      *a3 = *a4;
      a3[1] = v14;
      *a4 = v13;
      a4[1] = result;
      result.n128_u32[0] = a3[1].n128_u32[0];
      if (result.n128_f32[0] < a2[1].n128_f32[0])
      {
        v15 = *a2;
        result = a2[1];
        v16 = a3[1];
        *a2 = *a3;
        a2[1] = v16;
        *a3 = v15;
        a3[1] = result;
        result.n128_u32[0] = a2[1].n128_u32[0];
        if (result.n128_f32[0] < a1[1].n128_f32[0])
        {
          v17 = *a1;
          result = a1[1];
          v18 = a2[1];
          *a1 = *a2;
          a1[1] = v18;
          *a2 = v17;
          a2[1] = result;
        }
      }
    }
  }
  return result;
}

float *_ZNSt3__119__partial_sort_implB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_SC_EET1_SD_SD_T2_OT0_(uint64_t a1, float *a2, float *a3, uint64_t a4)
{
  float *v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  float *v12;
  float *v13;
  float *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD *v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v28;
  __int128 v29;

  if ((float *)a1 != a2)
  {
    v6 = a2;
    v8 = (uint64_t)a2 - a1;
    v9 = ((uint64_t)a2 - a1) >> 5;
    if ((uint64_t)a2 - a1 >= 33)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = (float *)(a1 + 32 * v10);
      do
      {
        _ZNSt3__111__sift_downB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_OT0_NS_15iterator_traitsISD_E15difference_typeESD_(a1, a4, v9, v12);
        v12 -= 8;
        --v11;
      }
      while (v11);
    }
    v13 = v6;
    if (v6 != a3)
    {
      v14 = v6;
      do
      {
        if (v14[4] < *(float *)(a1 + 16))
        {
          v16 = *(_OWORD *)v14;
          v15 = *((_OWORD *)v14 + 1);
          v17 = *(_OWORD *)(a1 + 16);
          *(_OWORD *)v14 = *(_OWORD *)a1;
          *((_OWORD *)v14 + 1) = v17;
          *(_OWORD *)a1 = v16;
          *(_OWORD *)(a1 + 16) = v15;
          _ZNSt3__111__sift_downB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_OT0_NS_15iterator_traitsISD_E15difference_typeESD_(a1, a4, v9, (float *)a1);
        }
        v14 += 8;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 33)
    {
      v18 = (unint64_t)v8 >> 5;
      do
      {
        v19 = 0;
        v28 = *(_OWORD *)a1;
        v29 = *(_OWORD *)(a1 + 16);
        v20 = a1;
        do
        {
          v21 = (_OWORD *)v20;
          v20 += 32 * (v19 + 1);
          v22 = 2 * v19;
          v19 = (2 * v19) | 1;
          v23 = v22 + 2;
          if (v23 < v18 && *(float *)(v20 + 16) < *(float *)(v20 + 48))
          {
            v20 += 32;
            v19 = v23;
          }
          v24 = *(_OWORD *)(v20 + 16);
          *v21 = *(_OWORD *)v20;
          v21[1] = v24;
        }
        while (v19 <= (uint64_t)((unint64_t)(v18 - 2) >> 1));
        v6 -= 8;
        if ((float *)v20 == v6)
        {
          *(_OWORD *)v20 = v28;
          *(_OWORD *)(v20 + 16) = v29;
        }
        else
        {
          v25 = *((_OWORD *)v6 + 1);
          *(_OWORD *)v20 = *(_OWORD *)v6;
          *(_OWORD *)(v20 + 16) = v25;
          *(_OWORD *)v6 = v28;
          *((_OWORD *)v6 + 1) = v29;
          _ZNSt3__19__sift_upB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_OT0_NS_15iterator_traitsISD_E15difference_typeE(a1, v20 + 32, a4, (v20 + 32 - a1) >> 5);
        }
      }
      while (v18-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t _ZNSt3__111__sift_downB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_OT0_NS_15iterator_traitsISD_E15difference_typeESD_(uint64_t result, uint64_t a2, uint64_t a3, float *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float v10;
  float *v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  int v17;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 5)
    {
      v6 = v4 >> 4;
      v7 = (v4 >> 4) + 1;
      v8 = (float *)(result + 32 * v7);
      v9 = v6 + 2;
      if (v9 < a3 && v8[4] < v8[12])
      {
        v8 += 8;
        v7 = v9;
      }
      v10 = a4[4];
      if (v8[4] >= v10)
      {
        v15 = *(_OWORD *)a4;
        v16 = *(_QWORD *)(a4 + 5);
        v17 = *((_DWORD *)a4 + 7);
        do
        {
          v11 = a4;
          a4 = v8;
          v12 = *((_OWORD *)v8 + 1);
          *(_OWORD *)v11 = *(_OWORD *)v8;
          *((_OWORD *)v11 + 1) = v12;
          if (v5 < v7)
            break;
          v13 = 2 * v7;
          v7 = (2 * v7) | 1;
          v8 = (float *)(result + 32 * v7);
          v14 = v13 + 2;
          if (v14 < a3 && v8[4] < v8[12])
          {
            v8 += 8;
            v7 = v14;
          }
        }
        while (v8[4] >= v10);
        *(_OWORD *)a4 = v15;
        a4[4] = v10;
        *(_QWORD *)(a4 + 5) = v16;
        *((_DWORD *)a4 + 7) = v17;
      }
    }
  }
  return result;
}

uint64_t _ZNSt3__19__sift_upB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv3_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_OT0_NS_15iterator_traitsISD_E15difference_typeE(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  float v5;
  uint64_t v6;
  _OWORD *v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  int v11;

  if (a4 >= 2)
  {
    v4 = (unint64_t)(a4 - 2) >> 1;
    v5 = *(float *)(a2 - 16);
    if (*(float *)(result + 32 * v4 + 16) < v5)
    {
      v6 = a2 - 32;
      v9 = *(_OWORD *)(a2 - 32);
      v10 = *(_QWORD *)(a2 - 12);
      v11 = *(_DWORD *)(a2 - 4);
      do
      {
        v7 = (_OWORD *)v6;
        v6 = result + 32 * v4;
        v8 = *(_OWORD *)(v6 + 16);
        *v7 = *(_OWORD *)v6;
        v7[1] = v8;
        if (!v4)
          break;
        v4 = (v4 - 1) >> 1;
      }
      while (*(float *)(result + 32 * v4 + 16) < v5);
      *(_OWORD *)v6 = v9;
      *(float *)(v6 + 16) = v5;
      *(_QWORD *)(v6 + 20) = v10;
      *(_DWORD *)(v6 + 28) = v11;
    }
  }
  return result;
}

uint64_t _ZN2CI11Perspective9NMSimplexIDv2_fEC2ENS0_8NMParamsEU13block_pointerFfRKS2_EPS5_m(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  float32x2_t v5;
  __int128 v11;
  char **v12;
  uint64_t v13;
  uint64_t v14;
  float v15;
  float v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  float *v25;
  char *v26;
  char *v27;
  float *v28;
  __n128 *v30;
  __n128 *v31;
  unint64_t v32;
  uint64_t v33;
  int32x2_t v34;
  uint64_t v35;
  float32x2_t *v36;
  uint64_t v37;
  float32x2_t v38;
  unint64_t v39;
  float32x2_t *v40;
  uint64_t v41;
  float32x2_t v42;
  float32x2_t v43;
  int8x8_t v44;
  int8x8_t *v45;
  float v46;
  int8x8_t v48;
  double v49;
  float32x2_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  float32x2_t v54;
  float v55;
  float32x2_t *v56;
  float32x2_t v57;
  float32x2_t v58;
  float32x2_t v59;

  v11 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v11;
  *(_QWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 40) = 0;
  v12 = (char **)(a1 + 40);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  std::vector<CI::Perspective::Line>::reserve((void **)(a1 + 40), a5);
  if (a5)
  {
    v13 = 0;
    do
    {
      v14 = *(_QWORD *)(a4 + 8 * v13);
      v15 = (*(float (**)(uint64_t))(a3 + 16))(a3);
      v16 = v15;
      v18 = *(_QWORD *)(a1 + 48);
      v17 = *(_QWORD *)(a1 + 56);
      if (v18 >= v17)
      {
        v20 = (uint64_t)(v18 - (_QWORD)*v12) >> 4;
        v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 60)
          abort();
        v22 = v17 - (_QWORD)*v12;
        if (v22 >> 3 > v21)
          v21 = v22 >> 3;
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0)
          v23 = 0xFFFFFFFFFFFFFFFLL;
        else
          v23 = v21;
        if (v23)
          v24 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>(a1 + 56, v23);
        else
          v24 = 0;
        v25 = (float *)&v24[16 * v20];
        *(_QWORD *)v25 = v14;
        v25[2] = v16;
        v27 = *(char **)(a1 + 40);
        v26 = *(char **)(a1 + 48);
        v28 = v25;
        if (v26 != v27)
        {
          do
          {
            *((_OWORD *)v28 - 1) = *((_OWORD *)v26 - 1);
            v28 -= 4;
            v26 -= 16;
          }
          while (v26 != v27);
          v26 = *v12;
        }
        v19 = (char *)(v25 + 4);
        *(_QWORD *)(a1 + 40) = v28;
        *(_QWORD *)(a1 + 48) = v25 + 4;
        *(_QWORD *)(a1 + 56) = &v24[16 * v23];
        if (v26)
          operator delete(v26);
      }
      else
      {
        *(_QWORD *)v18 = v14;
        *(float *)(v18 + 8) = v15;
        v19 = (char *)(v18 + 16);
      }
      *(_QWORD *)(a1 + 48) = v19;
      ++v13;
    }
    while (v13 != a5);
  }
  for (*(_QWORD *)(a1 + 64) = 1;
        (_ZNK2CI11Perspective9NMSimplexIDv2_fE15shouldTerminateEv(a1) & 1) == 0;
        ++*(_QWORD *)(a1 + 64))
  {
    v30 = *(__n128 **)(a1 + 40);
    v31 = *(__n128 **)(a1 + 48);
    v32 = 126 - 2 * __clz(v31 - v30);
    if (v31 == v30)
      v33 = 0;
    else
      v33 = v32;
    _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_Lb0EEEvT1_SD_T0_NS_15iterator_traitsISD_E15difference_typeEb(v30, v31, (uint64_t)&v59, v33, 1);
    v36 = *(float32x2_t **)(a1 + 40);
    v35 = *(_QWORD *)(a1 + 48);
    v37 = (v35 - (uint64_t)v36) >> 4;
    v38 = 0;
    v39 = v37 - 1;
    if (v37 != 1)
    {
      v40 = *(float32x2_t **)(a1 + 40);
      v41 = v37 - 1;
      do
      {
        v42 = *v40;
        v40 += 2;
        v34.i32[1] = v42.i32[1];
        v38 = vadd_f32(v38, v42);
        --v41;
      }
      while (v41);
    }
    *(float *)v34.i32 = (float)v39;
    v43 = vdiv_f32(v38, (float32x2_t)vdup_lane_s32(v34, 0));
    v59 = 0;
    v44 = (int8x8_t)vmla_n_f32(v43, vsub_f32(v43, *(float32x2_t *)(v35 - 16)), *(float *)a1);
    v59 = (float32x2_t)v44;
    v5.i32[0] = (*(float (**)(uint64_t, float32x2_t *))(a3 + 16))(a3, &v59);
    v45 = (int8x8_t *)&v36[2 * v39];
    v46 = v36[1].f32[0];
    if (v46 <= v5.f32[0] && v5.f32[0] < v36[2 * v37 - 3].f32[0])
    {
      *v45 = v44;
      v45[1].i32[0] = v5.i32[0];
    }
    else
    {
      if (v5.f32[0] >= v46)
      {
        v58 = 0;
        v50 = vmla_n_f32(v43, vsub_f32(*(float32x2_t *)(*(_QWORD *)(a1 + 48) - 16), v43), *(float *)(a1 + 8));
        v58 = v50;
        *(float *)&v49 = (*(float (**)(uint64_t, float32x2_t *))(a3 + 16))(a3, &v58);
        if (*(float *)&v49 >= v36[2 * v39 + 1].f32[0])
        {
          v51 = *(_QWORD *)(a1 + 40);
          if ((unint64_t)(*(_QWORD *)(a1 + 48) - v51) >= 0x11)
          {
            v52 = 0;
            v5 = *v36;
            v53 = 1;
            do
            {
              v57 = 0;
              v54 = vmla_n_f32(v5, vsub_f32(*(float32x2_t *)(v51 + v52 + 16), v5), *(float *)(a2 + 12));
              v57 = v54;
              v55 = (*(float (**)(uint64_t, float32x2_t *))(a3 + 16))(a3, &v57);
              v56 = (float32x2_t *)(*(_QWORD *)(a1 + 40) + v52);
              v56[2] = v54;
              v56[3].f32[0] = v55;
              ++v53;
              v51 = *(_QWORD *)(a1 + 40);
              v52 += 16;
            }
            while (v53 < (*(_QWORD *)(a1 + 48) - v51) >> 4);
          }
          continue;
        }
        *v45 = (int8x8_t)v50;
      }
      else
      {
        v48 = (int8x8_t)vmla_n_f32(v43, vsub_f32(v59, v43), *(float *)(a1 + 4));
        v58 = (float32x2_t)v48;
        v49 = (*(double (**)(uint64_t, float32x2_t *))(a3 + 16))(a3, &v58);
        *v45 = vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(v5, *(float32x2_t *)&v49), 0), v48, v44);
        if (*(float *)&v49 >= v5.f32[0])
          *(float *)&v49 = v5.f32[0];
      }
      v45[1].i32[0] = LODWORD(v49);
    }
    v45[1].i32[1] = 0;
  }
  return a1;
}

void sub_192330534(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 48) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _ZNK2CI11Perspective9NMSimplexIDv2_fE15shouldTerminateEv(uint64_t a1)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  float v4;
  uint64_t v5;
  float v6;
  float v7;
  float v8;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1 && *(_QWORD *)(a1 + 64) >= v1)
    return 1;
  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 48);
  if (v2 == v3)
  {
    v6 = (float)(unint64_t)((v3 - v2) >> 4);
  }
  else
  {
    v4 = 0.0;
    v5 = *(_QWORD *)(a1 + 40);
    do
    {
      v4 = v4 + *(float *)(v5 + 8);
      v5 += 16;
    }
    while (v5 != v3);
    v6 = (float)(unint64_t)((v3 - v2) >> 4);
    if (v3 != v2)
    {
      v7 = 0.0;
      v8 = v4 / v6;
      do
      {
        v7 = v7 + (float)((float)(*(float *)(v2 + 8) - v8) * (float)(*(float *)(v2 + 8) - v8));
        v2 += 16;
      }
      while (v2 != v3);
      return sqrtf(v7 / v6) < *(float *)(a1 + 16);
    }
  }
  v7 = 0.0;
  return sqrtf(v7 / v6) < *(float *)(a1 + 16);
}

void _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_Lb0EEEvT1_SD_T0_NS_15iterator_traitsISD_E15difference_typeEb(__n128 *a1, __n128 *a2, uint64_t a3, uint64_t a4, char a5)
{
  __n128 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  float *v15;
  __n128 *v16;
  char v17;
  BOOL v18;
  __n128 v19;
  __n128 v20;

uint64_t _ZNSt3__116__insertion_sortB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_(uint64_t result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  float *v4;
  _QWORD *v5;
  float v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  float v10;
  uint64_t v11;

  if ((_QWORD *)result != a2)
  {
    v2 = (_QWORD *)(result + 16);
    if ((_QWORD *)(result + 16) != a2)
    {
      v3 = 0;
      v4 = (float *)result;
      do
      {
        v5 = v2;
        v6 = v4[6];
        if (v6 < v4[2])
        {
          v7 = *v2;
          v8 = *((_DWORD *)v4 + 7);
          v9 = v3;
          while (1)
          {
            *(_OWORD *)(result + v9 + 16) = *(_OWORD *)(result + v9);
            if (!v9)
              break;
            v10 = *(float *)(result + v9 - 8);
            v9 -= 16;
            if (v6 >= v10)
            {
              v11 = result + v9 + 16;
              goto LABEL_10;
            }
          }
          v11 = result;
LABEL_10:
          *(_QWORD *)v11 = v7;
          *(float *)(v11 + 8) = v6;
          *(_DWORD *)(v11 + 12) = v8;
        }
        v2 = v5 + 2;
        v3 += 16;
        v4 = (float *)v5;
      }
      while (v5 + 2 != a2);
    }
  }
  return result;
}

_QWORD *_ZNSt3__126__insertion_sort_unguardedB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_T0_(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  float v4;
  uint64_t v5;
  int v6;
  _QWORD *v7;
  float v8;

  if (result != a2)
  {
    v2 = result + 2;
    while (v2 != a2)
    {
      v3 = v2;
      v4 = *((float *)result + 6);
      if (v4 < *((float *)result + 2))
      {
        v5 = *v2;
        v6 = *((_DWORD *)result + 7);
        v7 = v3;
        do
        {
          *(_OWORD *)v7 = *((_OWORD *)v7 - 1);
          v8 = *((float *)v7 - 6);
          v7 -= 2;
        }
        while (v4 < v8);
        *v7 = v5;
        *((float *)v7 + 2) = v4;
        *((_DWORD *)v7 + 3) = v6;
      }
      v2 = v3 + 2;
      result = v3;
    }
  }
  return result;
}

uint64_t _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_(float *a1, float *a2, float *a3)
{
  float v3;
  float v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  v3 = a2[2];
  v4 = a3[2];
  if (v3 < a1[2])
  {
    if (v4 < v3)
    {
      v5 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v5;
      return 1;
    }
    v8 = *(_OWORD *)a1;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)a2 = v8;
    if (a3[2] >= a2[2])
      return 1;
    v9 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v9;
    return 2;
  }
  if (v4 < v3)
  {
    v6 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v6;
    if (a2[2] >= a1[2])
      return 1;
    v7 = *(_OWORD *)a1;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)a2 = v7;
    return 2;
  }
  return 0;
}

unint64_t _ZNSt3__131__partition_with_equals_on_leftB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv2_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EET0_SD_SD_T1_(float *a1, float *a2)
{
  float v2;
  float *v3;
  unint64_t v4;
  float v5;
  unint64_t v6;
  float v7;
  float *v8;
  float v9;
  uint64_t v10;
  int v11;
  float v12;
  float v13;
  __int128 v15;

  v2 = a1[2];
  if (v2 >= *(a2 - 2))
  {
    v6 = (unint64_t)(a1 + 4);
    do
    {
      v4 = v6;
      if (v6 >= (unint64_t)a2)
        break;
      v7 = *(float *)(v6 + 8);
      v6 += 16;
    }
    while (v2 >= v7);
  }
  else
  {
    v3 = a1;
    do
    {
      v4 = (unint64_t)(v3 + 4);
      v5 = v3[6];
      v3 += 4;
    }
    while (v2 >= v5);
  }
  if (v4 >= (unint64_t)a2)
  {
    v8 = a2;
  }
  else
  {
    do
    {
      v8 = a2 - 4;
      v9 = *(a2 - 2);
      a2 -= 4;
    }
    while (v2 < v9);
  }
  v10 = *(_QWORD *)a1;
  v11 = *((_DWORD *)a1 + 3);
  while (v4 < (unint64_t)v8)
  {
    v15 = *(_OWORD *)v4;
    *(_OWORD *)v4 = *(_OWORD *)v8;
    *(_OWORD *)v8 = v15;
    do
    {
      v12 = *(float *)(v4 + 24);
      v4 += 16;
    }
    while (v2 >= v12);
    do
    {
      v13 = *(v8 - 2);
      v8 -= 4;
    }
    while (v2 < v13);
  }
  if ((float *)(v4 - 16) != a1)
    *(_OWORD *)a1 = *(_OWORD *)(v4 - 16);
  *(_QWORD *)(v4 - 16) = v10;
  *(float *)(v4 - 8) = v2;
  *(_DWORD *)(v4 - 4) = v11;
  return v4;
}

unint64_t _ZNSt3__132__partition_with_equals_on_rightB8nn180100INS_17_ClassicAlgPolicyEPN2CI11Perspective9NMSimplexIDv2_fE8NMVertexERZNS6_13orderVerticesEvEUlRKS7_SA_E_EENS_4pairIT0_bEESE_SE_T1_(float *a1, float *a2)
{
  uint64_t v2;
  uint64_t v3;
  float v4;
  int v5;
  float v6;
  unint64_t v7;
  float *v8;
  float v9;
  float v10;
  unint64_t v11;
  float *v12;
  __int128 v13;
  float v14;
  float v15;

  v2 = 0;
  v3 = *(_QWORD *)a1;
  v4 = a1[2];
  v5 = *((_DWORD *)a1 + 3);
  do
  {
    v6 = a1[v2 + 6];
    v2 += 4;
  }
  while (v6 < v4);
  v7 = (unint64_t)&a1[v2];
  if (v2 == 4)
  {
    while (v7 < (unint64_t)a2)
    {
      v8 = a2 - 4;
      v10 = *(a2 - 2);
      a2 -= 4;
      if (v10 < v4)
        goto LABEL_9;
    }
    v8 = a2;
  }
  else
  {
    do
    {
      v8 = a2 - 4;
      v9 = *(a2 - 2);
      a2 -= 4;
    }
    while (v9 >= v4);
  }
LABEL_9:
  v11 = (unint64_t)&a1[v2];
  if (v7 < (unint64_t)v8)
  {
    v12 = v8;
    do
    {
      v13 = *(_OWORD *)v11;
      *(_OWORD *)v11 = *(_OWORD *)v12;
      *(_OWORD *)v12 = v13;
      do
      {
        v14 = *(float *)(v11 + 24);
        v11 += 16;
      }
      while (v14 < v4);
      do
      {
        v15 = *(v12 - 2);
        v12 -= 4;
      }
      while (v15 >= v4);
    }
    while (v11 < (unint64_t)v12);
  }
  if ((float *)(v11 - 16) != a1)
    *(_OWORD *)a1 = *(_OWORD *)(v11 - 16);
  *(_QWORD *)(v11 - 16) = v3;
  *(float *)(v11 - 8) = v4;
  *(_DWORD *)(v11 - 4) = v5;
  return v11 - 16;
}

BOOL _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEbT1_SD_T0_(__n128 *a1, __n128 *a2)
{
  uint64_t v4;
  _BOOL8 result;
  __n128 v6;
  __n128 *v7;
  __n128 *v8;
  uint64_t v9;
  int v10;
  float v11;
  unint64_t v12;
  unsigned __int32 v13;
  uint64_t v14;
  float v15;
  uint64_t v16;

  v4 = a2 - a1;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (a2[-1].n128_f32[2] < a1->n128_f32[2])
      {
        v6 = *a1;
        *a1 = a2[-1];
        a2[-1] = v6;
      }
      return result;
    case 3:
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)a1, (float *)&a1[1], (float *)&a2[-1]);
      return 1;
    case 4:
      _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_((float *)a1, (uint64_t)&a1[1], (uint64_t)&a1[2], (uint64_t)&a2[-1]);
      return 1;
    case 5:
      _ZNSt3__17__sort5B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_SD_T0_((float *)a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      v7 = a1 + 2;
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_((float *)a1, (float *)&a1[1], (float *)&a1[2]);
      v8 = a1 + 3;
      if (&a1[3] == a2)
        return 1;
      v9 = 0;
      v10 = 0;
      break;
  }
  while (1)
  {
    v11 = v8->n128_f32[2];
    if (v11 < v7->n128_f32[2])
    {
      v12 = v8->n128_u64[0];
      v13 = v8->n128_u32[3];
      v14 = v9;
      while (1)
      {
        *(__n128 *)((char *)a1 + v14 + 48) = *(__n128 *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = *(float *)((char *)&a1[1].n128_f32[2] + v14);
        v14 -= 16;
        if (v11 >= v15)
        {
          v16 = (uint64_t)&a1[3] + v14;
          goto LABEL_12;
        }
      }
      v16 = (uint64_t)a1;
LABEL_12:
      *(_QWORD *)v16 = v12;
      *(float *)(v16 + 8) = v11;
      *(_DWORD *)(v16 + 12) = v13;
      if (++v10 == 8)
        return &v8[1] == a2;
    }
    v7 = v8;
    v9 += 16;
    if (++v8 == a2)
      return 1;
  }
}

__n128 _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_(float *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result;

  _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEjT1_SD_SD_T0_(a1, (float *)a2, (float *)a3);
  result.n128_u32[0] = *(_DWORD *)(a4 + 8);
  if (result.n128_f32[0] < *(float *)(a3 + 8))
  {
    result = *(__n128 *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(__n128 *)a4 = result;
    result.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (result.n128_f32[0] < *(float *)(a2 + 8))
    {
      result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      result.n128_u32[0] = *(_DWORD *)(a2 + 8);
      if (result.n128_f32[0] < a1[2])
      {
        result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 _ZNSt3__17__sort5B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_SD_T0_(float *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  __n128 result;

  result = _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_SD_SD_T0_(a1, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4);
  result.n128_u32[0] = a5->n128_u32[2];
  if (result.n128_f32[0] < a4->n128_f32[2])
  {
    result = *a4;
    *a4 = *a5;
    *a5 = result;
    result.n128_u32[0] = a4->n128_u32[2];
    if (result.n128_f32[0] < a3->n128_f32[2])
    {
      result = *a3;
      *a3 = *a4;
      *a4 = result;
      result.n128_u32[0] = a3->n128_u32[2];
      if (result.n128_f32[0] < a2->n128_f32[2])
      {
        result = *a2;
        *a2 = *a3;
        *a3 = result;
        result.n128_u32[0] = a2->n128_u32[2];
        if (result.n128_f32[0] < a1[2])
        {
          result = *(__n128 *)a1;
          *(__n128 *)a1 = *a2;
          *a2 = result;
        }
      }
    }
  }
  return result;
}

float *_ZNSt3__119__partial_sort_implB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_SC_EET1_SD_SD_T2_OT0_(float *a1, float *a2, float *a3, uint64_t a4)
{
  float *v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  float *v12;
  float *v13;
  float *v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  float *v18;
  float *v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v24;

  if (a1 != a2)
  {
    v6 = a2;
    v8 = (char *)a2 - (char *)a1;
    v9 = ((char *)a2 - (char *)a1) >> 4;
    if ((char *)a2 - (char *)a1 >= 17)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[4 * v10];
      do
      {
        _ZNSt3__111__sift_downB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_OT0_NS_15iterator_traitsISD_E15difference_typeESD_((uint64_t)a1, a4, v9, v12);
        v12 -= 4;
        --v11;
      }
      while (v11);
    }
    v13 = v6;
    if (v6 != a3)
    {
      v14 = v6;
      do
      {
        if (v14[2] < a1[2])
        {
          v15 = *(_OWORD *)v14;
          *(_OWORD *)v14 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          _ZNSt3__111__sift_downB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_OT0_NS_15iterator_traitsISD_E15difference_typeESD_((uint64_t)a1, a4, v9, a1);
        }
        v14 += 4;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 17)
    {
      v16 = (unint64_t)v8 >> 4;
      do
      {
        v17 = 0;
        v24 = *(_OWORD *)a1;
        v18 = a1;
        do
        {
          v19 = v18;
          v18 += 4 * v17 + 4;
          v20 = 2 * v17;
          v17 = (2 * v17) | 1;
          v21 = v20 + 2;
          if (v21 < v16 && v18[2] < v18[6])
          {
            v18 += 4;
            v17 = v21;
          }
          *(_OWORD *)v19 = *(_OWORD *)v18;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        v6 -= 4;
        if (v18 == v6)
        {
          *(_OWORD *)v18 = v24;
        }
        else
        {
          *(_OWORD *)v18 = *(_OWORD *)v6;
          *(_OWORD *)v6 = v24;
          _ZNSt3__19__sift_upB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_OT0_NS_15iterator_traitsISD_E15difference_typeE((uint64_t)a1, (uint64_t)(v18 + 4), a4, ((char *)(v18 + 4) - (char *)a1) >> 4);
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t _ZNSt3__111__sift_downB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_OT0_NS_15iterator_traitsISD_E15difference_typeESD_(uint64_t result, uint64_t a2, uint64_t a3, float *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  float *v8;
  uint64_t v9;
  float v10;
  uint64_t v11;
  int v12;
  float *v13;
  uint64_t v14;
  uint64_t v15;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 4)
    {
      v6 = v4 >> 3;
      v7 = (v4 >> 3) + 1;
      v8 = (float *)(result + 16 * v7);
      v9 = v6 + 2;
      if (v9 < a3 && v8[2] < v8[6])
      {
        v8 += 4;
        v7 = v9;
      }
      v10 = a4[2];
      if (v8[2] >= v10)
      {
        v11 = *(_QWORD *)a4;
        v12 = *((_DWORD *)a4 + 3);
        do
        {
          v13 = a4;
          a4 = v8;
          *(_OWORD *)v13 = *(_OWORD *)v8;
          if (v5 < v7)
            break;
          v14 = 2 * v7;
          v7 = (2 * v7) | 1;
          v8 = (float *)(result + 16 * v7);
          v15 = v14 + 2;
          if (v15 < a3 && v8[2] < v8[6])
          {
            v8 += 4;
            v7 = v15;
          }
        }
        while (v8[2] >= v10);
        *(_QWORD *)a4 = v11;
        a4[2] = v10;
        *((_DWORD *)a4 + 3) = v12;
      }
    }
  }
  return result;
}

uint64_t _ZNSt3__19__sift_upB8nn180100INS_17_ClassicAlgPolicyERZN2CI11Perspective9NMSimplexIDv2_fE13orderVerticesEvEUlRKNS6_8NMVertexES9_E_PS7_EEvT1_SD_OT0_NS_15iterator_traitsISD_E15difference_typeE(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  float v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  _OWORD *v10;

  if (a4 >= 2)
  {
    v4 = (unint64_t)(a4 - 2) >> 1;
    v5 = *(float *)(a2 - 8);
    if (*(float *)(result + 16 * v4 + 8) < v5)
    {
      v7 = *(_QWORD *)(a2 - 16);
      v6 = a2 - 16;
      v8 = v7;
      v9 = *(_DWORD *)(v6 + 12);
      do
      {
        v10 = (_OWORD *)v6;
        v6 = result + 16 * v4;
        *v10 = *(_OWORD *)v6;
        if (!v4)
          break;
        v4 = (v4 - 1) >> 1;
      }
      while (*(float *)(result + 16 * v4 + 8) < v5);
      *(_QWORD *)v6 = v8;
      *(float *)(v6 + 8) = v5;
      *(_DWORD *)(v6 + 12) = v9;
    }
  }
  return result;
}

CIImage *perspectiveTransformImage(CIImage *a1, simd::float3x3 a2)
{
  unsigned __int8 v3;
  float32x4_t v4;
  uint32x4_t v5;
  CIWarpKernel *v6;
  double v7;
  float64_t v8;
  float64x2_t v9;
  double v10;
  float32x4_t v11;
  float32x2_t v12;
  int32x4_t v13;
  float32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;
  float32x2_t v18;
  double v19;
  double v20;
  float v21;
  double v22;
  float v23;
  double v24;
  CIVector *v25;
  CIVector *v26;
  CIVector *v27;
  int v29;
  simd::float3x3 v30;
  simd::float3x3 v31;
  _QWORD v32[4];
  simd::float3x3 v33;
  _OWORD v34[2];
  _QWORD v35[4];
  simd_float3x3 v36;

  v35[3] = *MEMORY[0x1E0C80C00];
  if ((v3 & 1) == 0)
  {
    v31 = a2;
    a2 = v31;
    if (v29)
    {
      perspectiveTransformImage(CIImage *,simd::float3x3)::I = xmmword_192496870;
      *(_OWORD *)algn_1EE283D70 = xmmword_192496880;
      xmmword_1EE283D80 = xmmword_192496890;
      a2 = v31;
    }
  }
  v4 = (float32x4_t)vdupq_n_s32(0x358637BDu);
  v5 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v4, vabdq_f32((float32x4_t)a2.columns[1], *(float32x4_t *)algn_1EE283D70)), (int8x16_t)vcgeq_f32(v4, vabdq_f32((float32x4_t)a2.columns[0], (float32x4_t)perspectiveTransformImage(CIImage *,simd::float3x3)::I))), (int8x16_t)vcgeq_f32(v4, vabdq_f32((float32x4_t)a2.columns[2], (float32x4_t)xmmword_1EE283D80)));
  v5.i32[3] = v5.i32[2];
  if ((vminvq_u32(v5) & 0x80000000) == 0)
  {
    v30 = a2;
    v6 = +[CIKernel kernelWithInternalRepresentation:](CIWarpKernel, "kernelWithInternalRepresentation:", &CI::_perspectiveWarp);
    -[CIImage extent](a1, "extent");
    *(float *)&v7 = v7;
    v9.f64[1] = v8;
    *(float *)&v10 = v10;
    v11 = vmulq_n_f32((float32x4_t)v30.columns[0], *(float *)&v7);
    HIDWORD(v7) = LODWORD(v10);
    v12 = vadd_f32(*(float32x2_t *)&v7, vcvt_f32_f64(v9));
    v13 = (int32x4_t)vaddq_f32((float32x4_t)v30.columns[2], vmlaq_n_f32(v11, (float32x4_t)v30.columns[1], *(float *)&v10));
    v14 = vmulq_n_f32((float32x4_t)v30.columns[0], v12.f32[0]);
    v15 = (int32x4_t)vaddq_f32((float32x4_t)v30.columns[2], vmlaq_n_f32(v14, (float32x4_t)v30.columns[1], *(float *)&v10));
    *(float32x2_t *)v13.i8 = vdiv_f32(*(float32x2_t *)v13.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2));
    v16 = (int32x4_t)vaddq_f32((float32x4_t)v30.columns[2], vmlaq_lane_f32(v14, (float32x4_t)v30.columns[1], v12, 1));
    *(float32x2_t *)v16.i8 = vdiv_f32(*(float32x2_t *)v16.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v16, 2));
    v17 = (int32x4_t)vaddq_f32((float32x4_t)v30.columns[2], vmlaq_lane_f32(v11, (float32x4_t)v30.columns[1], v12, 1));
    v13.u64[1] = (unint64_t)vdiv_f32(*(float32x2_t *)v15.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v15, 2));
    v16.u64[1] = (unint64_t)vdiv_f32(*(float32x2_t *)v17.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v17, 2));
    v34[0] = v13;
    v34[1] = v16;
    v18 = CI::Perspective::bbox((float32x2_t *)v34);
    v19 = v18.f32[0];
    v20 = v18.f32[1];
    v22 = v21;
    v32[0] = MEMORY[0x1E0C809B0];
    v32[1] = 3221225472;
    v32[2] = ___ZL25perspectiveTransformImageP7CIImageN4simd8float3x3E_block_invoke;
    v32[3] = &__block_descriptor_80_e73__CGRect__CGPoint_dd__CGSize_dd__44__0i8_CGRect__CGPoint_dd__CGSize_dd__12l;
    v24 = v23;
    v33 = v30;
    v36 = __invert_f3(v30.simd_float3x3);
    v30.columns[0].i32[2] = v36.columns[0].i32[2];
    v30.columns[1] = v36.columns[1];
    v30.columns[2] = v36.columns[2];
    v25 = +[CIVector vectorWithX:Y:Z:](CIVector, "vectorWithX:Y:Z:", v36.columns[0].f32[0], v36.columns[1].f32[0], v36.columns[2].f32[0], v36.columns[0].i64[0]);
    v26 = +[CIVector vectorWithX:Y:Z:](CIVector, "vectorWithX:Y:Z:", v30.columns[0].f32[1], v30.columns[1].f32[1], v30.columns[2].f32[1]);
    v27 = +[CIVector vectorWithX:Y:Z:](CIVector, "vectorWithX:Y:Z:", v30.columns[0].f32[2], v30.columns[1].f32[2], v30.columns[2].f32[2]);
    v35[0] = v25;
    v35[1] = v26;
    v35[2] = v27;
    return -[CIWarpKernel applyWithExtent:roiCallback:inputImage:arguments:](v6, "applyWithExtent:roiCallback:inputImage:arguments:", v32, a1, objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v35, 3), v19, v20, v22, v24);
  }
  return a1;
}

double ___ZL25perspectiveTransformImageP7CIImageN4simd8float3x3E_block_invoke(uint64_t a1, double a2, double a3, float64x2_t a4, float64_t a5)
{
  unsigned int v5;
  unsigned int v6;
  float32x4_t v7;
  int32x4_t v8;
  int32x4_t v9;
  float v11;
  float v12;
  float32x2_t v13;
  _OWORD v14[2];
  simd_float3x3 v15;

  *(float *)&v5 = a2;
  *(float *)&v6 = a3;
  v11 = *(float *)&v5;
  v12 = *(float *)&v6;
  a4.f64[1] = a5;
  v13 = vadd_f32((float32x2_t)__PAIR64__(v6, v5), vcvt_f32_f64(a4));
  v15 = __invert_f3(*(simd_float3x3 *)(a1 + 32));
  v7 = vmulq_n_f32((float32x4_t)v15.columns[0], v11);
  v8 = (int32x4_t)vaddq_f32((float32x4_t)v15.columns[2], vmlaq_n_f32(v7, (float32x4_t)v15.columns[1], v12));
  v15.columns[0] = (simd_float3)vmulq_n_f32((float32x4_t)v15.columns[0], v13.f32[0]);
  v9 = (int32x4_t)vaddq_f32((float32x4_t)v15.columns[2], vmlaq_n_f32((float32x4_t)v15.columns[0], (float32x4_t)v15.columns[1], v12));
  *(float32x2_t *)v8.i8 = vdiv_f32(*(float32x2_t *)v8.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v8, 2));
  v15.columns[0] = (simd_float3)vaddq_f32((float32x4_t)v15.columns[2], vmlaq_lane_f32((float32x4_t)v15.columns[0], (float32x4_t)v15.columns[1], v13, 1));
  *(float32x2_t *)v15.columns[0].f32 = vdiv_f32(*(float32x2_t *)v15.columns[0].f32, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v15.columns[0], 2));
  v15.columns[1] = (simd_float3)vaddq_f32((float32x4_t)v15.columns[2], vmlaq_lane_f32(v7, (float32x4_t)v15.columns[1], v13, 1));
  v8.u64[1] = (unint64_t)vdiv_f32(*(float32x2_t *)v9.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v9, 2));
  *(float32x2_t *)&v15.columns[0].u32[2] = vdiv_f32(*(float32x2_t *)v15.columns[1].f32, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v15.columns[1], 2));
  v14[0] = v8;
  v14[1] = v15.columns[0];
  return CI::Perspective::bbox((float32x2_t *)v14).f32[0];
}

float32x2_t cikernel::_perspectiveWarp(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  uint64_t *DC;
  int32x4_t v10;
  int32x4_t v11;
  int32x4_t v12;

  DC = (uint64_t *)CI::getDC(a1);
  __asm { FMOV            V1.4S, #1.0 }
  _Q1.i64[0] = *DC;
  v10 = (int32x4_t)vmulq_f32(a2, _Q1);
  v11 = (int32x4_t)vmulq_f32(a3, _Q1);
  v12 = (int32x4_t)vmulq_f32(a4, _Q1);
  return vdiv_f32((float32x2_t)vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v10, 2), vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v10.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v11, 2), vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 1)))), (float32x2_t)vdup_lane_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v12, 2), vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v12.i8, 1))), 0));
}

void CI::f2_f3_f3_f3(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v10;
  double (*v11)(_QWORD *, __n128, __n128, __n128);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v10 = (_QWORD *)a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, __n128))a1[3];
  v12 = v10[1];
  v13 = v10[4];
  v14 = v10[7];
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * v10[10]), a2);
  *(double *)(a3 + 16 * a7) = v11(a1, *((__n128 *)a2 + 4 * v12), *((__n128 *)a2 + 4 * v13), *((__n128 *)a2 + 4 * v14));
}

double computeHomogeneousPerspectiveTransformAndInverse(double *a1, uint64_t a2, double a3, float32x2_t a4, float32x2_t a5, float32x2_t a6)
{
  float32x2_t v6;
  int32x2_t v7;
  float64x2_t v9;
  double v10;
  float32x2_t v12;
  float32x2_t v13;
  double v14;
  double v15;
  double v17;
  double v18;
  double v19;
  double result;

  v6 = vsub_f32(vadd_f32(vsub_f32(*(float32x2_t *)&a3, a4), a5), a6);
  v7 = vceqz_f32(v6);
  if ((v7.i32[0] & v7.i32[1] & 1) != 0)
  {
    _Q4 = vcvtq_f64_f32(vsub_f32(a4, *(float32x2_t *)&a3));
    v9 = vcvtq_f64_f32(vsub_f32(a5, a4));
    v10 = 0.0;
    _D5 = 0.0;
  }
  else
  {
    v12 = vsub_f32(a6, a5);
    v13 = vsub_f32(a4, a5);
    v14 = vmlas_n_f32((float)-v13.f32[1] * v12.f32[0], v12.f32[1], v13.f32[0]);
    v10 = vmlas_n_f32((float)-v6.f32[1] * v12.f32[0], v12.f32[1], v6.f32[0]) / v14;
    _D5 = vmlas_n_f32((float)-v13.f32[1] * v6.f32[0], v6.f32[1], v13.f32[0]) / v14;
    _Q4 = vmlaq_n_f64(vcvtq_f64_f32(vsub_f32(a4, *(float32x2_t *)&a3)), vcvtq_f64_f32(a4), v10);
    v9 = vmlaq_n_f64(vcvtq_f64_f32(vsub_f32(a6, *(float32x2_t *)&a3)), vcvtq_f64_f32(a6), _D5);
  }
  v15 = *((float *)&a3 + 1);
  _D0 = *(float *)&a3;
  *(float64x2_t *)a2 = _Q4;
  *(double *)(a2 + 16) = v10;
  *(float64x2_t *)(a2 + 24) = v9;
  *(double *)(a2 + 40) = _D5;
  *(double *)(a2 + 48) = _D0;
  *(double *)(a2 + 56) = v15;
  *(_QWORD *)(a2 + 64) = 0x3FF0000000000000;
  v17 = -_Q4.f64[1] * v9.f64[0];
  v18 = -(_Q4.f64[0] * _D5);
  v19 = v17
      + vmuld_lane_f64(_Q4.f64[0], v9, 1)
      + vmuld_lane_f64(_D5, _Q4, 1) * _D0
      + v10 * v9.f64[0] * v15
      + vmuld_lane_f64(-v10, v9, 1) * _D0
      + v18 * v15;
  *a1 = (v9.f64[1] - _D5 * v15) / v19;
  a1[1] = -(_Q4.f64[1] - v10 * v15) / v19;
  __asm { FMLA            D17, D5, V4.D[1] }
  a1[2] = _D17 / v19;
  a1[3] = -(v9.f64[0] - _D5 * _D0) / v19;
  a1[4] = (_Q4.f64[0] - v10 * _D0) / v19;
  a1[5] = vmlad_n_f64(v18, v10, v9.f64[0]) / v19;
  __asm { FMLA            D2, D0, V4.D[1] }
  a1[6] = vmlad_n_f64(-(v9.f64[1] * _D0), v15, v9.f64[0]) / v19;
  a1[7] = _D2 / v19;
  result = vmlad_n_f64(v17, v9.f64[1], _Q4.f64[0]) / v19;
  a1[8] = result;
  return result;
}

float32x2_t cikernel::_perspectiveTransform(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x2_t a5)
{
  uint64_t *DC;
  int32x4_t v12;
  int32x4_t v13;
  float32x4_t v14;

  DC = (uint64_t *)CI::getDC(a1);
  __asm { FMOV            V1.4S, #1.0 }
  _Q1.i64[0] = *DC;
  v12 = (int32x4_t)vmulq_f32(a2, _Q1);
  v13 = (int32x4_t)vmulq_f32(a3, _Q1);
  v14 = vmulq_f32(a4, _Q1);
  return vadd_f32(a5, vmul_n_f32((float32x2_t)vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v12, 2), vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v12.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2), vadd_f32(*(float32x2_t *)v13.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v13.i8, 1)))), 1.0/ fmaxf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).f32[0], 0.000001)));
}

void CI::f2_f3_f3_f3_f2(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, __n128, double);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  double *v17;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, __n128, double))a1[3];
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_QWORD *)(v10 + 32);
  v14 = *(_QWORD *)(v10 + 56);
  v15 = *(_DWORD *)(v10 + 88);
  v16 = *(_QWORD *)(v10 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
  v17 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v17 = (double *)((char *)a2 + 64 * v16);
  *(double *)(a3 + 16 * a7) = v11(a1, *((__n128 *)a2 + 4 * v12), *((__n128 *)a2 + 4 * v13), *((__n128 *)a2 + 4 * v14), *v17);
}

double cikernel::_perspectiveMask(CI *a1, float32x4_t a2, float32x4_t a3)
{
  uint64_t *DC;
  float32x4_t v9;
  double v10;
  float v11;
  double result;

  DC = (uint64_t *)CI::getDC(a1);
  __asm { FMOV            V1.4S, #1.0 }
  _Q1.i64[0] = *DC;
  v9 = vmulq_f32(a3, _Q1);
  _NF = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0] < 0.000001;
  v10 = 1.0;
  if (_NF)
    v10 = 0.0;
  v11 = v10;
  *(_QWORD *)&result = vmulq_n_f32(a2, v11).u64[0];
  return result;
}

void CI::f4_s_f3(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128);
  int v12;
  uint64_t v13;
  uint64_t v14;
  __n128 *v15;
  __int128 v16;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 56)), a2);
  v15 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v15 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v16 = v11(a1, *v15, *((__n128 *)a2 + 4 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v16;
}

float32x2_t cikernel::_perspectiveCorrection(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  uint64_t *DC;
  int32x4_t v10;
  int32x4_t v11;
  float32x4_t v12;

  DC = (uint64_t *)CI::getDC(a1);
  __asm { FMOV            V1.4S, #1.0 }
  _Q1.i64[0] = *DC;
  v10 = (int32x4_t)vmulq_f32(a2, _Q1);
  v11 = (int32x4_t)vmulq_f32(a3, _Q1);
  v12 = vmulq_f32(a4, _Q1);
  v12.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).u64[0];
  v12.f32[0] = fmaxf(v12.f32[0], 0.000001);
  return vdiv_f32((float32x2_t)vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v10, 2), vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v10.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v11, 2), vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 1)))), (float32x2_t)vdup_lane_s32(*(int32x2_t *)v12.f32, 0));
}

void __Block_byref_object_copy__13(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__13(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __Block_byref_object_copy__14(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__14(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

double cikernel::_photoEffectDepthBlend(float32x4_t a1, float32x4_t a2, float a3, float a4)
{
  float v4;
  float32x4_t v5;
  float v6;
  float v7;
  float v8;
  BOOL v9;
  float v10;
  double result;

  v4 = fminf(a3 + a3, 1.0);
  v5 = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - v4), a2, v4);
  v6 = a4 + 0.15;
  v7 = (float)(v4 - a4) / (float)(v6 - a4);
  if (v7 <= 1.0)
    v8 = v7;
  else
    v8 = 1.0;
  v9 = v7 < 0.0;
  v10 = 0.0;
  if (!v9)
    v10 = v8;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - (float)((float)(v10 * v10) * (float)((float)(v10 * -2.0) + 3.0))), v5, (float)(v10 * v10) * (float)((float)(v10 * -2.0) + 3.0)).u64[0];
  return result;
}

double cikernel::_blendGrains(__n128 _Q0, float a2)
{
  double v2;
  float v3;
  float v4;
  float v5;
  float v12;
  double v15;
  float v16;
  double result;

  v2 = a2;
  v3 = v2 * 1.43067656 + -1.43067656;
  v4 = vmlas_n_f32(vmuls_lane_f32(v3, (float32x2_t)_Q0.n128_u64[0], 1), 1.0 - v3, _Q0.n128_f32[0]);
  v5 = v2 * 1.10730936 + -1.8812854;
  _S6 = 1.0 - v5;
  __asm { FMLA            S4, S6, V0.S[1] }
  v12 = v2 * 1.10730936 + -2.8812854;
  _S6 = 1.0 - v12;
  __asm { FMLA            S5, S6, V0.S[2] }
  v15 = v2 + -1.69897;
  *(float *)&v15 = v2 + -1.69897;
  *(float *)&v2 = v2 + -2.60205999;
  if (*(float *)&v2 >= 0.0)
    v16 = _S5;
  else
    v16 = _S4;
  if (*(float *)&v15 >= 0.0)
    *(float *)&v15 = v16;
  else
    *(float *)&v15 = v4;
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)&v15, 0).u64[0];
  return result;
}

double cikernel::_grainBlendAndMix(float32x4_t a1, float a2, float a3, float a4, int32x2_t a5)
{
  float32x4_t v6;
  float v7;
  float v8;
  float v9;
  int8x16_t v10;
  int8x16_t v16;
  simd_float4 v17;
  simd_float4 v18;
  float32x4_t v19;
  double v20;
  float32x4_t v21;
  int8x16_t v22;
  simd_float4 v23;
  simd_float4 v24;
  float32x4_t v25;
  float32x4_t v26;
  double result;
  float32x4_t v28;
  int8x16_t v29;
  int32x2_t v30;
  float32x4_t v32;

  v6 = vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x3EAAAA9Fu));
  v7 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0];
  if (v7 <= 1.0)
    v8 = v7;
  else
    v8 = 1.0;
  if (v7 >= 0.0)
    v9 = v8;
  else
    v9 = 0.0;
  *(float *)a5.i32 = v9 * -2.0 + 4.01;
  v10.i64[0] = 0x8000000080000000;
  v10.i64[1] = 0x8000000080000000;
  __asm { FMOV            V2.4S, #1.0 }
  v29 = _Q2;
  v30 = a5;
  v16 = vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgtzq_f32(a1)), vorrq_s8(vandq_s8((int8x16_t)a1, v10), _Q2), (int8x16_t)0);
  v28 = (float32x4_t)v16;
  v17 = (simd_float4)vabsq_f32(a1);
  *(float *)v16.i32 = 1.0 / *(float *)a5.i32;
  v17.i32[3] = 0;
  v18 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)v16.i8, 0);
  v18.i32[3] = 0;
  v19 = (float32x4_t)_simd_pow_f4(v17, v18);
  v20 = (1.0 - v9) * (float)((float)((float)(a2 + -0.5) * a3) * fmaxf(v9, 0.5));
  *(float *)&v20 = v20;
  v21 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v20, 0), vmulq_f32(v28, v19));
  v22.i64[0] = 0x8000000080000000;
  v22.i64[1] = 0x8000000080000000;
  v32 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v21), (int8x16_t)vcgtzq_f32(v21)), vorrq_s8(vandq_s8((int8x16_t)v21, v22), v29), (int8x16_t)0);
  v23 = (simd_float4)vabsq_f32(v21);
  v23.i32[3] = 0;
  v24 = (simd_float4)vdupq_lane_s32(v30, 0);
  v24.i32[3] = 0;
  v25 = vmulq_f32((float32x4_t)_simd_pow_f4(v23, v24), v32);
  v25.i32[3] = 0;
  v26 = vminnmq_f32(v25, (float32x4_t)xmmword_192491FD0);
  v26.i32[3] = a1.i32[3];
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a4), v26, a4).u64[0];
  return result;
}

float32x2_t cikernel::_paddedTile2(CI *a1, int8x16_t a2)
{
  float32x2_t v2;

  v2 = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), *(float32x2_t *)CI::getDC(a1));
  __asm { FMOV            V1.2S, #1.0 }
  return vadd_f32(vmul_f32(*(float32x2_t *)a2.i8, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu))), _D1);
}

double map_point_inv(float32x2_t a1, float32x2_t a2, double a3, float a4, double a5, double a6, double a7, double a8)
{
  float32x2_t v9;
  float32x2_t v10;
  long double v11;
  float32x2_t v12;
  float32x2_t v13;
  double v14;
  double v15;
  long double v16;
  float v17;
  float32x2_t v18;
  float v19;
  float v21;

  v9 = a1;
  v10 = vsub_f32(a1, a2);
  *(float *)&a8 = sqrtf(vaddv_f32(vmul_f32(v10, v10)));
  v11 = *(float *)&a8;
  if (*(float *)&a8 >= 0.001)
  {
    if (fabsf(a4 + -1.0) >= 0.001)
    {
      v14 = a4;
      if (a4 >= 1.0 && *(float *)&a8 >= *(float *)&a3)
      {
        v21 = *(float *)&a3;
        v15 = pow(v11, v14 / (2.0 - v14));
        v16 = pow(v21, v14 / (v14 + -2.0));
        v17 = v15;
        *(float *)&v16 = v16;
        v18 = vmul_n_f32(vmul_n_f32(v10, v17), *(float *)&v16);
LABEL_9:
        v9 = vadd_f32(a2, v18);
        return *(double *)&v9;
      }
      v19 = ((float)((float)(*(float *)&a3 * a4) * a4)
           + v14 * -2.0 * v11
           + v11 * 2.0
           - sqrt((float)((float)(*(float *)&a3 * a4) * a4) + v14 * -4.0 * v11 + v11 * 4.0)
           * (float)(sqrtf(*(float *)&a3) * a4))
          / ((float)(a4 * a4) + v14 * -2.0 + 1.0 + (float)(a4 * a4) + v14 * -2.0 + 1.0);
      v12 = vmul_n_f32(v10, v19);
      v13 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a8, 0);
    }
    else
    {
      v12 = vmul_n_f32(v10, *(float *)&a8);
      v13 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0);
    }
    v18 = vdiv_f32(v12, v13);
    goto LABEL_9;
  }
  return *(double *)&v9;
}

double regionOf(CGRect a1, float32x2_t a2, float32_t a3, float a4, float a5)
{
  double y;
  double x;
  CGFloat v9;
  CGFloat v10;
  CGFloat v11;
  CGFloat v12;
  float32x2_t v13;
  float32_t v14;
  double v15;
  double v16;
  double v17;
  CGFloat v18;
  double v19;
  CGFloat v20;
  double v21;
  CGFloat v22;
  double v23;
  double v24;
  double v25;
  CGFloat v26;
  double v27;
  CGFloat v28;
  double v29;
  CGFloat v30;
  float32x2_t v31;
  double v32;
  double v33;
  double v34;
  CGFloat v35;
  double v36;
  CGFloat v37;
  double v38;
  CGFloat v39;
  CGFloat v40;
  double v41;
  double v42;
  double v43;
  double v44;
  CGFloat v45;
  double v46;
  CGFloat v47;
  double v48;
  double v49;
  CGFloat v50;
  double v51;
  CGFloat v52;
  double v53;
  CGFloat v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  double v60;
  double v61;
  CGFloat v62;
  double v63;
  CGFloat v64;
  double v65;
  CGFloat v66;
  double v67;
  float v69;
  CGFloat v70;
  CGFloat v71;
  float v72;
  unsigned int v74;
  __int32 v75;
  __int32 v76;
  __int32 v77;
  double width;
  CGFloat v79;
  double v80;
  double height;
  float32x2_t v82;
  CGRect v83;
  CGRect v84;
  CGRect v85;
  CGRect v86;

  v72 = a2.f32[0];
  height = a1.size.height;
  width = a1.size.width;
  y = a1.origin.y;
  v71 = a1.origin.y;
  x = a1.origin.x;
  v9 = *MEMORY[0x1E0C9D628];
  v10 = *(double *)(MEMORY[0x1E0C9D628] + 8);
  a2.f32[1] = a3;
  v82 = a2;
  v11 = *(double *)(MEMORY[0x1E0C9D628] + 16);
  v12 = *(double *)(MEMORY[0x1E0C9D628] + 24);
  v13.f32[0] = a1.origin.x;
  v77 = v13.i32[0];
  v14 = a1.origin.y;
  v75 = LODWORD(v14);
  v13.f32[1] = v14;
  map_point(v13, a2, a5, a4);
  v16 = unionPointWithRect(v15, v9, v10, v11, v12);
  v18 = v17;
  v20 = v19;
  v22 = v21;
  v70 = x;
  *(float *)&v17 = y + height;
  v74 = LODWORD(v17);
  map_point((float32x2_t)__PAIR64__(LODWORD(v17), v77), v82, a5, a4);
  v24 = unionPointWithRect(v23, v16, v18, v20, v22);
  v26 = v25;
  v28 = v27;
  v30 = v29;
  v31.f32[0] = x + width;
  v76 = v31.i32[0];
  v31.i32[1] = v75;
  map_point(v31, v82, a5, a4);
  v33 = unionPointWithRect(v32, v24, v26, v28, v30);
  v35 = v34;
  v37 = v36;
  v39 = v38;
  v69 = a4;
  v40 = width;
  map_point((float32x2_t)__PAIR64__(v74, v76), v82, a5, a4);
  v42 = unionPointWithRect(v41, v33, v35, v37, v39);
  v79 = v43;
  v45 = v44;
  v47 = v46;
  v83.origin.x = v70;
  v83.origin.y = v71;
  v83.size.width = width;
  v83.size.height = height;
  if (CGRectGetMinX(v83) < v72)
  {
    v84.origin.x = v70;
    v84.origin.y = v71;
    v84.size.width = width;
    v84.size.height = height;
    if (CGRectGetMaxX(v84) > v72)
    {
      map_point((float32x2_t)__PAIR64__(v75, v82.u32[0]), v82, a5, a4);
      v80 = unionPointWithRect(v48, v42, v79, v45, v47);
      v50 = v49;
      v52 = v51;
      v54 = v53;
      v40 = width;
      map_point((float32x2_t)__PAIR64__(v74, v82.u32[0]), v82, a5, a4);
      v42 = unionPointWithRect(v55, v80, v50, v52, v54);
      v79 = v56;
      v45 = v57;
      v47 = v58;
    }
  }
  v85.origin.x = v70;
  v85.origin.y = v71;
  v85.size.width = v40;
  v85.size.height = height;
  if (CGRectGetMinY(v85) < a3)
  {
    v86.origin.x = v70;
    v86.origin.y = v71;
    v86.size.width = v40;
    v86.size.height = height;
    if (CGRectGetMaxY(v86) > a3)
    {
      map_point((float32x2_t)__PAIR64__(v82.u32[1], v77), v82, a5, a4);
      v60 = unionPointWithRect(v59, v42, v79, v45, v47);
      v62 = v61;
      v64 = v63;
      v66 = v65;
      map_point((float32x2_t)__PAIR64__(v82.u32[1], v76), v82, a5, v69);
      return unionPointWithRect(v67, v60, v62, v64, v66);
    }
  }
  return v42;
}

float32x2_t cikernel::_pinchDistortionScaleLT1(CI *a1, float32x2_t a2, float32x4_t a3)
{
  float32x2_t *DC;
  float32x2_t v5;
  unsigned int v6;
  float v7;
  float32x2_t v8;

  DC = (float32x2_t *)CI::getDC(a1);
  v5 = vsub_f32(*DC, a2);
  *(float *)&v6 = vmuls_lane_f32(sqrtf(vaddv_f32(vmul_f32(v5, v5))), *(float32x2_t *)a3.f32, 1) + 0.000001;
  v7 = *(float *)&v6;
  v8 = vrsqrte_f32((float32x2_t)v6);
  return vmla_laneq_f32(vmul_n_f32(*(float32x2_t *)CI::getDC((CI *)DC), 1.0 - a3.f32[2]), vadd_f32(a2, vmul_n_f32(v5, vmul_f32(v8, vrsqrts_f32((float32x2_t)LODWORD(v7), vmul_f32(v8, v8))).f32[0])), a3, 2);
}

int8x8_t cikernel::_pinchDistortionScaleGE1(CI *a1, float32x2_t a2, float32x4_t a3)
{
  float32x2_t v4;
  float32x2_t v5;
  int8x8_t v6;
  float32x2_t v7;
  float32x2_t v8;
  CI *v9;
  float32x2_t *DC;
  float32x2_t v11;
  float32x2_t v14;

  v4 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  *(double *)&v5 = vmuls_lane_f32(sqrtf(vaddv_f32(vmul_f32(v4, v4))), *(float32x2_t *)a3.f32, 1) + 0.000001;
  v5.f32[0] = *(double *)&v5;
  v14 = v5;
  v6 = (int8x8_t)vadd_f32(a2, vmul_n_f32(v4, powf(v5.f32[0], a3.f32[3])));
  v7 = vrsqrte_f32((float32x2_t)v14.u32[0]);
  v8 = vadd_f32(a2, vmul_n_f32(v4, vmul_f32(v7, vrsqrts_f32((float32x2_t)v14.u32[0], vmul_f32(v7, v7))).f32[0]));
  DC = (float32x2_t *)CI::getDC(v9);
  v11.i32[0] = 1.0;
  return vbsl_s8((int8x8_t)vdup_lane_s32(vcge_f32(v11, v14), 0), (int8x8_t)vmla_laneq_f32(vmul_n_f32(*DC, 1.0 - a3.f32[2]), v8, a3, 2), v6);
}

void map_point(float32x2_t a1, float32x2_t a2, float a3, float a4)
{
  float32x2_t v4;
  float v5;

  if (a4 >= 1.0)
  {
    v4 = vsub_f32(a1, a2);
    v5 = (float)((float)(1.0 / a3) * sqrtf(vaddv_f32(vmul_f32(v4, v4)))) + 0.000001;
    powf(v5, a4 * -0.5);
  }
}

float32x2_t cikernel::_pixellate(CI *a1, float32x2_t a2, double a3)
{
  return vadd_f32(a2, vmul_lane_f32(vadd_f32(vrndm_f32(vmul_n_f32(vsub_f32(*(float32x2_t *)CI::getDC(a1), a2), *(float *)&a3)), (float32x2_t)0x3F0000003F000000), *(float32x2_t *)&a3, 1));
}

void CI::f2_f2_f2(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, double, double);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  double *v16;
  double *v17;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, double, double))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 56)), a2);
  v16 = (double *)(a3 + 16 * v15);
  if (v14 != 5)
    v16 = (double *)((char *)a2 + 64 * v15);
  v17 = (double *)(a3 + 16 * v13);
  if (v12 != 5)
    v17 = (double *)((char *)a2 + 64 * v13);
  *(double *)(a3 + 16 * a7) = v11(a1, *v17, *v16);
}

double cikernel::_hexagonalPixellate(uint64_t a1, float32x2_t a2, float32x2_t a3, float32x2_t a4, float a5)
{
  float32x2_t v16;
  float32x2_t v17;
  int8x16_t v23;
  float32x2_t v24;
  int32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  int32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  int32x2_t v34;
  float32x2_t v35;
  int8x16_t v36;
  float32x2_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;
  int8x16_t v41;
  int8x16_t v42;
  float32x4_t v43;
  int8x16_t v44;
  float32x4_t v45;
  double v46;
  double v47;
  uint8x8_t v48;
  int8x16_t v49;
  float64x2_t v50;
  double v51;
  int8x16_t v52;
  float32x4_t v53;
  float v54;
  float v55;
  double result;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;

  _S9 = a5;
  _D1 = vsub_f32(*(float32x2_t *)CI::getDC((CI *)a1), a2);
  __asm { FMLS            S0, S9, V1.S[1] }
  v16 = vmul_f32(a3, (float32x2_t)__PAIR64__(_D1.u32[1], _S0));
  v17 = vrndm_f32(v16);
  _D3 = vsub_f32(v16, v17);
  *(float32x2_t *)_Q0.i8 = vmul_f32(a4, v17);
  _D4 = vadd_f32(a4, *(float32x2_t *)_Q0.i8);
  *(float32x2_t *)_Q2.i8 = vadd_f32(*(float32x2_t *)_Q0.i8, (float32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32((float)(vaddv_f32(_D3) + -1.0) < 0.0), 0x1FuLL)), (int8x8_t)0x8000000080000000, (int8x8_t)a4));
  __asm { FMLA            S3, S9, V2.S[1] }
  _Q2.i32[0] = _D3.i32[0];
  __asm { FMLA            S5, S9, V4.S[1] }
  v23.i64[0] = __PAIR64__(_D4.u32[1], _S5);
  __asm { FMLA            S4, S9, V0.S[1] }
  _Q0.i32[0] = _D4.i32[0];
  v24 = vsub_f32(_D1, *(float32x2_t *)_Q2.i8);
  v25 = (int32x2_t)vmul_f32(v24, v24);
  v26 = vadd_f32((float32x2_t)v25, (float32x2_t)vdup_lane_s32(v25, 1));
  v27 = vrsqrte_f32((float32x2_t)v26.u32[0]);
  _Q2.u64[1] = (unint64_t)vmul_f32(vmul_f32(v27, vrsqrts_f32((float32x2_t)v26.u32[0], vmul_f32(v27, v27))), v26);
  v28 = vsub_f32(_D1, *(float32x2_t *)v23.i8);
  v29 = (int32x2_t)vmul_f32(v28, v28);
  v30 = vadd_f32((float32x2_t)v29, (float32x2_t)vdup_lane_s32(v29, 1));
  v31 = vrsqrte_f32((float32x2_t)v30.u32[0]);
  v32 = vmul_f32(vmul_f32(v31, vrsqrts_f32((float32x2_t)v30.u32[0], vmul_f32(v31, v31))), v30);
  v23.u64[1] = (unint64_t)v32;
  v33 = vsub_f32(_D1, *(float32x2_t *)_Q0.i8);
  v34 = (int32x2_t)vmul_f32(v33, v33);
  v35 = vadd_f32((float32x2_t)v34, (float32x2_t)vdup_lane_s32(v34, 1));
  *(float32x2_t *)v36.i8 = vrsqrte_f32((float32x2_t)v35.u32[0]);
  v37 = vmul_f32(*(float32x2_t *)v36.i8, vrsqrts_f32((float32x2_t)v35.u32[0], vmul_f32(*(float32x2_t *)v36.i8, *(float32x2_t *)v36.i8)));
  _Q0.u64[1] = (unint64_t)vmul_f32(v37, v35);
  v38 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(vsub_f32((float32x2_t)_Q2.u64[1], v32).f32[0] < 0.0)), 0x1FuLL));
  v39 = (float32x4_t)vbslq_s8(v38, _Q2, v23);
  v40 = (float32x4_t)vbslq_s8(v38, v23, _Q2);
  v41 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(COERCE_FLOAT(vsubq_f32(v39, v40).i32[2]) < 0.0)), 0x1FuLL));
  v42 = vbslq_s8(v41, (int8x16_t)v39, _Q0);
  v43 = (float32x4_t)vbslq_s8(v41, _Q0, (int8x16_t)v39);
  v44 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(COERCE_FLOAT(vsubq_f32(v40, v43).i32[2]) < 0.0)), 0x1FuLL));
  v58 = (float32x4_t)v42;
  v59 = (float32x4_t)vbslq_s8(v44, (int8x16_t)v40, (int8x16_t)v43);
  *(float32x2_t *)v40.f32 = vadd_f32(a2, *(float32x2_t *)v42.i8);
  v42.i32[0] = *(_DWORD *)(a1 + 28);
  v43.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v40.f32, 1), *(float *)(a1 + 16), v40.f32[0]);
  v39.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v44.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v40.f32, 1), *(float *)v42.i32, v40.f32[0]);
  v40.f32[0] = v39.f32[0] + *(float *)v44.i32;
  v43.f32[1] = v39.f32[0] + *(float *)v44.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v43.i64, (float64x2_t)v40, *(double *)v44.i64, *(double *)v42.i64, (int8x16_t)v39, (uint8x8_t)v32, *(double *)&v37, v36);
  v57 = v45;
  *(float32x2_t *)v45.f32 = vadd_f32(a2, *(float32x2_t *)v59.f32);
  *(float *)&v46 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v45.f32, 1), *(float *)(a1 + 16), v45.f32[0]);
  LODWORD(v47) = *(_DWORD *)(a1 + 28);
  v48.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v45.f32, 1), *(float *)&v47, v45.f32[0]);
  v45.f32[0] = *(float *)(a1 + 24) + *(float *)&v46;
  *(float *)v50.f64 = *(float *)v48.i32 + *(float *)v49.i32;
  v45.f32[1] = *(float *)v48.i32 + *(float *)v49.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v50, v46, v47, v49, v48, v51, v52);
  v54 = COERCE_FLOAT(vsubq_f32(v58, v59).i32[2]) * 0.5 + 0.5;
  if (v54 <= 1.0)
    v55 = v54;
  else
    v55 = 1.0;
  if (v54 < 0.0)
    v55 = 0.0;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v57, 1.0 - v55), v53, v55).u64[0];
  return result;
}

void CI::f4_sr_f2_f2_f2_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, double, double, double, float);
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  double *v20;
  double *v21;
  double *v22;
  __int128 v23;
  int v24;
  int v25;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, double, double, double, float))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  v17 = *(_DWORD *)(v10 + 88);
  v18 = *(_QWORD *)(v10 + 80);
  v19 = *(_QWORD *)(v10 + 104);
  if (*(_BYTE *)(a1 + 64))
  {
    v24 = *(_DWORD *)(v10 + 88);
    v25 = *(_DWORD *)(v10 + 40);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 128)), a2);
    v17 = v24;
    v13 = v25;
  }
  v20 = (double *)(a3 + 16 * v18);
  if (v17 != 5)
    v20 = (double *)((char *)a2 + 64 * v18);
  v21 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v21 = (double *)((char *)a2 + 64 * v16);
  v22 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v22 = (double *)((char *)a2 + 64 * v14);
  *(double *)&v23 = v11(a4 + 80 * v12, *v22, *v21, *v20, *((float *)a2 + 16 * v19));
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

double cikernel::_interleavedToPlanar3(cikernel *this, SamplerObj *a2, float a3)
{
  float64x2_t v5;
  int8x16_t v6;
  uint8x8_t v7;
  double v8;
  int8x16_t v9;
  float v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  int v19;
  double v20;

  v5.f64[0] = *(float64_t *)CI::getDC(this);
  v10 = *((float *)v5.f64 + 1);
  v11 = *((float *)v5.f64 + 1);
  v12 = a3;
  v13 = v12 + v12;
  v14 = *((float *)v5.f64 + 1) + a3 * -2.0;
  if (v12 + v12 > *((float *)v5.f64 + 1))
    v14 = *((float *)v5.f64 + 1) - a3;
  HIDWORD(v15) = 0x80000000;
  v16 = v11 + v12 * -0.0;
  if (*((float *)v5.f64 + 1) >= a3)
    v16 = v14;
  *(float *)&v14 = v16;
  v6.i32[0] = *((_DWORD *)this + 7);
  *(float *)&v17 = *((float *)this + 6)
                 + vmlas_n_f32(*((float *)this + 5) * *(float *)&v14, *((float *)this + 4), *(float *)v5.f64);
  LODWORD(v15) = *((_DWORD *)this + 8);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)&v14 = vmlas_n_f32(*(float *)&v15 * *(float *)&v14, *(float *)v6.i32, *(float *)v5.f64);
  *(float *)v5.f64 = *(float *)v7.i32 + *(float *)&v14;
  *((float *)&v17 + 1) = *(float *)v7.i32 + *(float *)&v14;
  v18 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v17, v5, v14, v15, v6, v7, v8, v9);
  HIDWORD(v20) = 0;
  if (v10 >= a3)
  {
    if (v13 <= v11)
      LODWORD(v20) = LODWORD(v18);
    else
      LODWORD(v20) = HIDWORD(v18);
  }
  else
  {
    LODWORD(v20) = v19;
  }
  return v20;
}

double cikernel::_planarToInterleaved3(cikernel *this, SamplerObj *a2, double a3)
{
  _QWORD *DC;
  int8x16_t v5;
  uint8x8_t v6;
  double v7;
  int8x16_t v8;
  double v9;
  float64x2_t v10;
  double v11;
  float32x2_t v14;
  float32x2_t v15;
  double v16;
  float64x2_t v17;
  float32x2_t v18;
  double v19;
  double v20;
  uint8x8_t v21;
  int8x16_t v22;
  double v23;
  int8x16_t v24;
  double v25;
  float64x2_t v26;
  float32x2_t v27;
  double v28;
  double v29;
  uint8x8_t v30;
  int8x16_t v31;
  double v32;
  int8x16_t v33;
  float64x2_t v35;
  float32x2_t v36;
  unsigned int v38;
  unint64_t v39;

  DC = (_QWORD *)CI::getDC(this);
  HIDWORD(v9) = HIDWORD(a3);
  v10.f64[0] = *(float64_t *)DC;
  v11 = 0.0;
  if (COERCE_FLOAT(*DC) >= 0.0
    && *(float *)v10.f64 <= *(float *)&a3
    && *((float *)v10.f64 + 1) >= 0.0
    && *((float *)v10.f64 + 1) <= *(float *)&a3)
  {
    v14.i32[0] = 0;
    v14.i32[1] = LODWORD(a3);
    v35 = v10;
    v36 = v14;
    v15 = vadd_f32(vadd_f32(v14, v14), *(float32x2_t *)&v10.f64[0]);
    *(float *)&v11 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v15, 1), *((float *)this + 4), v15.f32[0]);
    LODWORD(v9) = *((_DWORD *)this + 7);
    v6.i32[0] = *((_DWORD *)this + 9);
    *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v15, 1), *(float *)&v9, v15.f32[0]);
    v15.f32[0] = *((float *)this + 6) + *(float *)&v11;
    *(float *)v10.f64 = *(float *)v6.i32 + *(float *)v5.i32;
    v15.f32[1] = *(float *)v6.i32 + *(float *)v5.i32;
    v16 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v15, v10, v11, v9, v5, v6, v7, v8);
    v38 = LODWORD(v16);
    v17 = v35;
    v18 = vadd_f32(v36, *(float32x2_t *)&v35.f64[0]);
    *(float *)&v19 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v18, 1), *((float *)this + 4), v18.f32[0]);
    LODWORD(v20) = *((_DWORD *)this + 7);
    v21.i32[0] = *((_DWORD *)this + 9);
    *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v18, 1), *(float *)&v20, v18.f32[0]);
    v18.f32[0] = *((float *)this + 6) + *(float *)&v19;
    *(float *)v17.f64 = *(float *)v21.i32 + *(float *)v22.i32;
    v18.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
    v25 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v18, v17, v19, v20, v22, v21, v23, v24);
    v39 = __PAIR64__(LODWORD(v25), v38);
    v26 = v35;
    v27 = vadd_f32(vmul_f32(v36, 0), *(float32x2_t *)&v35.f64[0]);
    *(float *)&v28 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v27, 1), *((float *)this + 4), v27.f32[0]);
    LODWORD(v29) = *((_DWORD *)this + 7);
    v30.i32[0] = *((_DWORD *)this + 9);
    *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v27, 1), *(float *)&v29, v27.f32[0]);
    v27.f32[0] = *((float *)this + 6) + *(float *)&v28;
    *(float *)v26.f64 = *(float *)v30.i32 + *(float *)v31.i32;
    v27.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
    CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v27, v26, v28, v29, v31, v30, v32, v33);
    return *(double *)&v39;
  }
  return v11;
}

double cikernel::_interleavedToPlanar4(cikernel *this, SamplerObj *a2, float a3)
{
  float64x2_t v5;
  double v6;
  int8x16_t v7;
  uint8x8_t v8;
  double v9;
  int8x16_t v10;
  float v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  unsigned int v19;
  unsigned int v20;
  double v21;

  v5.f64[0] = *(float64_t *)CI::getDC(this);
  v11 = *((float *)v5.f64 + 1);
  v12 = *((float *)v5.f64 + 1);
  v13 = a3;
  v14 = v13 + v13;
  v15 = *((float *)v5.f64 + 1) + a3 * -3.0;
  if (a3 * 3.0 > *((float *)v5.f64 + 1))
    v15 = *((float *)v5.f64 + 1) + a3 * -2.0;
  if (v14 > v12)
    v15 = v12 - v13;
  v16 = v12 + v13 * -0.0;
  if (*((float *)v5.f64 + 1) < a3)
    v15 = v12 + v13 * -0.0;
  *(float *)&v16 = v15;
  v7.i32[0] = *((_DWORD *)this + 7);
  *(float *)&v17 = *((float *)this + 6)
                 + vmlas_n_f32(*((float *)this + 5) * *(float *)&v16, *((float *)this + 4), *(float *)v5.f64);
  LODWORD(v6) = *((_DWORD *)this + 8);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)&v16 = vmlas_n_f32(*(float *)&v6 * *(float *)&v16, *(float *)v7.i32, *(float *)v5.f64);
  *(float *)v5.f64 = *(float *)v8.i32 + *(float *)&v16;
  *((float *)&v17 + 1) = *(float *)v8.i32 + *(float *)&v16;
  v18 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v17, v5, v16, v6, v7, v8, v9, v10);
  if (v11 >= a3)
  {
    if (v14 <= v12)
    {
      HIDWORD(v21) = 0;
      if (v13 * 3.0 <= v12)
        LODWORD(v21) = LODWORD(v18);
      else
        LODWORD(v21) = HIDWORD(v18);
    }
    else
    {
      *(_QWORD *)&v21 = v19;
    }
  }
  else
  {
    *(_QWORD *)&v21 = v20;
  }
  return v21;
}

double cikernel::_planarToInterleaved4(cikernel *this, SamplerObj *a2, double a3)
{
  _QWORD *DC;
  int8x16_t v5;
  uint8x8_t v6;
  double v7;
  int8x16_t v8;
  double v9;
  float64x2_t v10;
  double v11;
  double v14;
  float32x2_t v20;
  int32x4_t v21;
  float64x2_t v22;
  double v23;
  double v24;
  uint8x8_t v25;
  int8x16_t v26;
  double v27;
  int8x16_t v28;
  int32x4_t v29;
  double v30;
  float32x2_t v31;
  double v32;
  int8x16_t v33;
  double v34;
  uint8x8_t v35;
  float64x2_t v36;
  int8x16_t v37;
  float64x2_t v38;
  float32x2_t v39;
  double v40;
  double v41;
  uint8x8_t v42;
  int8x16_t v43;
  double v44;
  int8x16_t v45;
  int32x4_t v47;
  float64x2_t v48;
  float32x2_t v50;

  DC = (_QWORD *)CI::getDC(this);
  HIDWORD(v9) = HIDWORD(a3);
  v10.f64[0] = *(float64_t *)DC;
  v11 = 0.0;
  if (COERCE_FLOAT(*DC) >= 0.0
    && *(float *)v10.f64 <= *(float *)&a3
    && *((float *)v10.f64 + 1) >= 0.0
    && *((float *)v10.f64 + 1) <= *(float *)&a3)
  {
    LODWORD(v14) = 0;
    HIDWORD(v14) = LODWORD(a3);
    v48 = v10;
    v50 = *(float32x2_t *)&v14;
    __asm { FMOV            V0.2S, #3.0 }
    v20 = vadd_f32(vmul_f32(*(float32x2_t *)&v14, _D0), *(float32x2_t *)&v10.f64[0]);
    *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v20, 1), *((float *)this + 4), v20.f32[0]);
    LODWORD(v9) = *((_DWORD *)this + 7);
    v6.i32[0] = *((_DWORD *)this + 9);
    *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v20, 1), *(float *)&v9, v20.f32[0]);
    v20.f32[0] = *((float *)this + 6) + *(float *)&v14;
    *(float *)v10.f64 = *(float *)v6.i32 + *(float *)v5.i32;
    v20.f32[1] = *(float *)v6.i32 + *(float *)v5.i32;
    *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v20, v10, v14, v9, v5, v6, v7, v8);
    v47 = v21;
    v22 = v48;
    *(float32x2_t *)v21.i8 = vadd_f32(vadd_f32(v50, v50), *(float32x2_t *)&v48.f64[0]);
    *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v21.i8, 1), *((float *)this + 4), *(float *)v21.i32);
    LODWORD(v24) = *((_DWORD *)this + 7);
    v25.i32[0] = *((_DWORD *)this + 9);
    *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v21.i8, 1), *(float *)&v24, *(float *)v21.i32);
    *(float *)v21.i32 = *((float *)this + 6) + *(float *)&v23;
    *(float *)v22.f64 = *(float *)v25.i32 + *(float *)v26.i32;
    *(float *)&v21.i32[1] = *(float *)v25.i32 + *(float *)v26.i32;
    *(double *)v29.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v21.i64, v22, v23, v24, v26, v25, v27, v28);
    HIDWORD(v30) = HIDWORD(v48.f64[0]);
    v31 = vadd_f32(v50, *(float32x2_t *)&v48.f64[0]);
    *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v31, 1), *((float *)this + 4), v31.f32[0]);
    LODWORD(v30) = *((_DWORD *)this + 6);
    v33.i32[0] = *((_DWORD *)this + 7);
    LODWORD(v34) = *((_DWORD *)this + 9);
    *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v31, 1), *(float *)v33.i32, v31.f32[0]);
    v36 = (float64x2_t)v47;
    v47.i64[0] = vzip1q_s32(v47, v29).u64[0];
    *(float *)v29.i32 = *(float *)&v30 + *(float *)&v32;
    *(float *)v36.f64 = *(float *)&v34 + *(float *)v35.i32;
    *(float *)&v29.i32[1] = *(float *)&v34 + *(float *)v35.i32;
    CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v29.i64, v36, v30, v32, v33, v35, v34, v37);
    v38 = v48;
    v39 = vadd_f32(vmul_f32(v50, 0), *(float32x2_t *)&v48.f64[0]);
    *(float *)&v40 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v39, 1), *((float *)this + 4), v39.f32[0]);
    LODWORD(v41) = *((_DWORD *)this + 7);
    v42.i32[0] = *((_DWORD *)this + 9);
    *(float *)v43.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v39, 1), *(float *)&v41, v39.f32[0]);
    v39.f32[0] = *((float *)this + 6) + *(float *)&v40;
    *(float *)v38.f64 = *(float *)v42.i32 + *(float *)v43.i32;
    v39.f32[1] = *(float *)v42.i32 + *(float *)v43.i32;
    CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v39, v38, v40, v41, v43, v42, v44, v45);
    return *(double *)v47.i64;
  }
  return v11;
}

double cikernel::_pointillize(uint64_t a1, uint64_t a2, int8x16_t a3)
{
  float32x2_t *DC;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  float64x2_t v11;
  double v12;
  int8x16_t v13;
  float32x4_t v14;
  float32x2_t v15;
  CI *v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float64x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  double v24;
  double v25;
  uint8x8_t v26;
  int8x16_t v27;
  double v28;
  int8x16_t v29;
  __int128 v30;
  double v31;
  int8x16_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float64x2_t v35;
  uint8x8_t v36;
  double v37;
  int8x16_t v38;
  float32x4_t v39;
  int32x2_t v40;
  float32x4_t v41;
  CI *v42;
  float32x2_t v43;
  float32x2_t v44;
  float32x2_t v45;
  float64x2_t v46;
  float32x2_t v47;
  double v48;
  double v49;
  uint8x8_t v50;
  int8x16_t v51;
  double v52;
  int8x16_t v53;
  __int128 v54;
  double v55;
  int8x16_t v56;
  float32x2_t v57;
  float64x2_t v58;
  uint8x8_t v59;
  double v60;
  int8x16_t v61;
  float32x4_t v62;
  int32x2_t v63;
  float32x4_t v64;
  CI *v65;
  float32x2_t v66;
  float32x2_t v67;
  float32x2_t v68;
  float64x2_t v69;
  float32x2_t v70;
  double v71;
  double v72;
  uint8x8_t v73;
  int8x16_t v74;
  double v75;
  int8x16_t v76;
  __int128 v77;
  double v78;
  int8x16_t v79;
  float32x2_t v80;
  float64x2_t v81;
  uint8x8_t v82;
  int32x2_t v83;
  double v84;
  int8x16_t v85;
  float32x4_t v86;
  int32x2_t v87;
  float32x4_t v88;
  CI *v89;
  float32x2_t v90;
  float32x2_t v91;
  float32x2_t v92;
  float64x2_t v93;
  float32x2_t v94;
  double v95;
  double v96;
  uint8x8_t v97;
  int8x16_t v98;
  double v99;
  int8x16_t v100;
  float32x4_t v101;
  int8x16_t v102;
  float64x2_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float64x2_t v106;
  float64x2_t v112;
  float64x2_t v113;
  float64x2_t v115;
  int32x2_t v116;
  float32x4_t v117;
  float32x2_t v118;
  float v119;
  double v120;
  double v121;
  double v122;
  float v123;
  float32x4_t v124;
  double v125;
  float v126;
  float32x4_t v127;
  float v128;
  double v129;
  float v130;
  float32x4_t v131;
  int8x16_t v132;
  double v133;
  double v134;
  float v135;
  double v136;
  float32x4_t v137;
  int32x2_t v138;
  float32x4_t v139;
  double result;
  __int128 v141;
  __int128 v142;
  float32x4_t v143;
  int32x2_t v144;
  __int128 v145;
  float32x4_t v146;
  float32x2_t v147;
  float32x2_t v148;
  float32x4_t v149;
  float32x4_t v150;
  unsigned __int32 v151;
  float32x4_t v152;
  float v153;
  float32x4_t v155;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v7, COERCE_FLOAT(*DC));
  *(float *)&v10 = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v11.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  *((float *)&v10 + 1) = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v10, v11, v6, v7, v9, v8, v12, v13);
  v150 = v14;
  v15.i32[0] = vextq_s8(a3, a3, 8uLL).u32[0];
  v151 = v15.i32[0];
  v15.i32[1] = a3.i32[2];
  v148 = v15;
  v17 = *(float32x2_t *)CI::getDC(v16);
  v18 = vmul_laneq_f32(v17, (float32x4_t)a3, 3);
  v19 = vadd_f32(vadd_f32(*(float32x2_t *)a3.i8, (float32x2_t)0x3F0000003F000000), vrndm_f32(vadd_f32(v18, (float32x2_t)0x3F0000003F000000)));
  v20 = (float32x2_t)vdup_n_s32(0x3B800000u);
  *(float32x2_t *)&v21.f64[0] = vrndm_f32(vmul_f32(v19, v20));
  v22 = (float32x2_t)vdup_n_s32(0xC3800000);
  v23 = vmla_f32(v19, v22, *(float32x2_t *)&v21.f64[0]);
  *(float *)&v24 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v23, 1), *(float *)(a2 + 16), v23.f32[0]);
  LODWORD(v25) = *(_DWORD *)(a2 + 28);
  v26.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v23, 1), *(float *)&v25, v23.f32[0]);
  v23.f32[0] = *(float *)(a2 + 24) + *(float *)&v24;
  *(float *)v21.f64 = *(float *)v26.i32 + *(float *)v27.i32;
  v23.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
  *(double *)&v30 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v23, v21, v24, v25, v27, v26, v28, v29);
  v145 = v30;
  HIDWORD(v31) = a3.i32[1];
  *(float32x2_t *)v32.i8 = vadd_f32(vmul_laneq_f32(vadd_f32(vrndm_f32(vadd_f32(v18, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000), (float32x4_t)a3, 2), (float32x2_t)0x3F0000003F000000);
  v33 = vadd_f32(v148, *(float32x2_t *)v32.i8);
  v34 = (float32x2_t)vdup_n_s32(0x3F266666u);
  *(float32x2_t *)&v35.f64[0] = vmul_f32(vmul_laneq_f32(vadd_f32(*(float32x2_t *)&v30, (float32x2_t)0xBF000000BF000000), (float32x4_t)a3, 2), v34);
  *(float32x2_t *)&v30 = vadd_f32(v33, *(float32x2_t *)&v35.f64[0]);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v30, 1), *(float *)(a1 + 16), *(float *)&v30);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  v36.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v30, 1), v33.f32[0], *(float *)&v30);
  *(float32x2_t *)&v30 = vsub_f32(*(float32x2_t *)&v30, v17);
  v147 = vmul_f32(*(float32x2_t *)&v30, *(float32x2_t *)&v30);
  *(float *)&v30 = *(float *)(a1 + 24) + *(float *)&v31;
  *(float *)v35.f64 = *(float *)v36.i32 + *(float *)v32.i32;
  *((float *)&v30 + 1) = *(float *)v36.i32 + *(float *)v32.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v30, v35, v31, *(double *)&v33, v32, v36, v37, v38);
  v40.i32[1] = DWORD1(v145);
  *(float *)v40.i32 = (float)(*((float *)&v145 + 2) + -0.5) * 0.1;
  v41 = vaddq_f32(v39, vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(v40, 0), v39, 3));
  v41.i32[3] = v39.i32[3];
  v149 = v41;
  v41.i32[0] = 0;
  v41.i32[1] = v151;
  *(_QWORD *)&v145 = v41.i64[0];
  v43 = *(float32x2_t *)CI::getDC(v42);
  v44 = vmul_laneq_f32(v43, (float32x4_t)a3, 3);
  v45 = vadd_f32(vadd_f32(*(float32x2_t *)a3.i8, (float32x2_t)0x3F000000BF000000), vrndm_f32(vadd_f32(v44, (float32x2_t)0x3F0000003F000000)));
  *(float32x2_t *)&v46.f64[0] = vrndm_f32(vmul_f32(v45, v20));
  v47 = vmla_f32(v45, v22, *(float32x2_t *)&v46.f64[0]);
  *(float *)&v48 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v47, 1), *(float *)(a2 + 16), v47.f32[0]);
  LODWORD(v49) = *(_DWORD *)(a2 + 28);
  v50.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v51.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v47, 1), *(float *)&v49, v47.f32[0]);
  v47.f32[0] = *(float *)(a2 + 24) + *(float *)&v48;
  *(float *)v46.f64 = *(float *)v50.i32 + *(float *)v51.i32;
  v47.f32[1] = *(float *)v50.i32 + *(float *)v51.i32;
  *(double *)&v54 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v47, v46, v48, v49, v51, v50, v52, v53);
  v141 = v54;
  HIDWORD(v55) = a3.i32[1];
  *(float32x2_t *)v56.i8 = vadd_f32(vmul_laneq_f32(vadd_f32(vrndm_f32(vadd_f32(v44, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000), (float32x4_t)a3, 2), (float32x2_t)0x3F0000003F000000);
  v57 = vadd_f32(*(float32x2_t *)&v145, *(float32x2_t *)v56.i8);
  *(float32x2_t *)&v58.f64[0] = vmul_f32(vmul_laneq_f32(vadd_f32(*(float32x2_t *)&v54, (float32x2_t)0xBF000000BF000000), (float32x4_t)a3, 2), v34);
  *(float32x2_t *)&v54 = vadd_f32(v57, *(float32x2_t *)&v58.f64[0]);
  *(float *)&v55 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v54, 1), *(float *)(a1 + 16), *(float *)&v54);
  v57.i32[0] = *(_DWORD *)(a1 + 28);
  v59.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v56.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v54, 1), v57.f32[0], *(float *)&v54);
  *(float32x2_t *)&v54 = vsub_f32(*(float32x2_t *)&v54, v43);
  v144 = (int32x2_t)vmul_f32(*(float32x2_t *)&v54, *(float32x2_t *)&v54);
  *(float *)&v54 = *(float *)(a1 + 24) + *(float *)&v55;
  *(float *)v58.f64 = *(float *)v59.i32 + *(float *)v56.i32;
  *((float *)&v54 + 1) = *(float *)v59.i32 + *(float *)v56.i32;
  *(double *)v62.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v54, v58, v55, *(double *)&v57, v56, v59, v60, v61);
  v63.i32[1] = DWORD1(v141);
  *(float *)v63.i32 = (float)(*((float *)&v141 + 2) + -0.5) * 0.1;
  v64 = vaddq_f32(v62, vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(v63, 0), v62, 3));
  v64.i32[3] = v62.i32[3];
  v146 = v64;
  v66 = *(float32x2_t *)CI::getDC(v65);
  v67 = vmul_laneq_f32(v66, (float32x4_t)a3, 3);
  v68 = vadd_f32(vadd_f32(*(float32x2_t *)a3.i8, (float32x2_t)0xBF0000003F000000), vrndm_f32(vadd_f32(v67, (float32x2_t)0x3F0000003F000000)));
  *(float32x2_t *)&v69.f64[0] = vrndm_f32(vmul_f32(v68, v20));
  v70 = vmla_f32(v68, v22, *(float32x2_t *)&v69.f64[0]);
  *(float *)&v71 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v70, 1), *(float *)(a2 + 16), v70.f32[0]);
  LODWORD(v72) = *(_DWORD *)(a2 + 28);
  v73.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v74.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v70, 1), *(float *)&v72, v70.f32[0]);
  v70.f32[0] = *(float *)(a2 + 24) + *(float *)&v71;
  *(float *)v69.f64 = *(float *)v73.i32 + *(float *)v74.i32;
  v70.f32[1] = *(float *)v73.i32 + *(float *)v74.i32;
  *(double *)&v77 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v70, v69, v71, v72, v74, v73, v75, v76);
  v142 = v77;
  HIDWORD(v78) = a3.i32[1];
  *(float32x2_t *)v79.i8 = vadd_f32(vmul_laneq_f32(vadd_f32(vrndm_f32(vadd_f32(v67, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000), (float32x4_t)a3, 2), (float32x2_t)0x3F0000003F000000);
  v80 = vadd_f32((float32x2_t)v151, *(float32x2_t *)v79.i8);
  *(float32x2_t *)&v81.f64[0] = vmul_f32(vmul_laneq_f32(vadd_f32(*(float32x2_t *)&v77, (float32x2_t)0xBF000000BF000000), (float32x4_t)a3, 2), v34);
  *(float32x2_t *)&v77 = vadd_f32(v80, *(float32x2_t *)&v81.f64[0]);
  *(float *)&v78 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v77, 1), *(float *)(a1 + 16), *(float *)&v77);
  v80.i32[0] = *(_DWORD *)(a1 + 28);
  v82.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v79.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v77, 1), v80.f32[0], *(float *)&v77);
  *(float32x2_t *)&v77 = vsub_f32(*(float32x2_t *)&v77, v66);
  v83 = (int32x2_t)vmul_f32(*(float32x2_t *)&v77, *(float32x2_t *)&v77);
  *(float *)&v77 = *(float *)(a1 + 24) + *(float *)&v78;
  *(float *)v81.f64 = *(float *)v82.i32 + *(float *)v79.i32;
  *((float *)&v77 + 1) = *(float *)v82.i32 + *(float *)v79.i32;
  *(double *)v86.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v77, v81, v78, *(double *)&v80, v79, v82, v84, v85);
  v87.i32[1] = DWORD1(v142);
  *(float *)v87.i32 = (float)(*((float *)&v142 + 2) + -0.5) * 0.1;
  v88 = vaddq_f32(v86, vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(v87, 0), v86, 3));
  v88.i32[3] = v86.i32[3];
  v152 = v88;
  v90 = *(float32x2_t *)CI::getDC(v89);
  v91 = vmul_laneq_f32(v90, (float32x4_t)a3, 3);
  v92 = vadd_f32(vadd_f32(*(float32x2_t *)a3.i8, (float32x2_t)0xBF000000BF000000), vrndm_f32(vadd_f32(v91, (float32x2_t)0x3F0000003F000000)));
  *(float32x2_t *)&v93.f64[0] = vrndm_f32(vmul_f32(v92, v20));
  v94 = vmla_f32(v92, v22, *(float32x2_t *)&v93.f64[0]);
  *(float *)&v95 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v94, 1), *(float *)(a2 + 16), v94.f32[0]);
  LODWORD(v96) = *(_DWORD *)(a2 + 28);
  v97.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v98.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v94, 1), *(float *)&v96, v94.f32[0]);
  v94.f32[0] = *(float *)(a2 + 24) + *(float *)&v95;
  *(float *)v93.f64 = *(float *)v97.i32 + *(float *)v98.i32;
  v94.f32[1] = *(float *)v97.i32 + *(float *)v98.i32;
  *(double *)v101.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)&v94, v93, v95, v96, v98, v97, v99, v100);
  v143 = v101;
  *(float32x2_t *)&v103.f64[0] = vadd_f32(vadd_f32(vmul_laneq_f32(vadd_f32(vrndm_f32(vadd_f32(v91, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000), (float32x4_t)a3, 2), (float32x2_t)0x3F0000003F000000), vmul_f32(vmul_laneq_f32(vadd_f32(*(float32x2_t *)v101.f32, (float32x2_t)0xBF000000BF000000), (float32x4_t)a3, 2), v34));
  *(float32x2_t *)v101.f32 = vsub_f32(*(float32x2_t *)&v103.f64[0], v90);
  *(float32x2_t *)v101.f32 = vmul_f32(*(float32x2_t *)v101.f32, *(float32x2_t *)v101.f32);
  *(int32x2_t *)v104.f32 = vzip1_s32(*(int32x2_t *)v101.f32, v83);
  v104.i64[1] = __PAIR64__(v147.u32[0], v144.u32[0]);
  *(int32x2_t *)v101.f32 = vzip2_s32(*(int32x2_t *)v101.f32, v83);
  v101.i64[1] = __PAIR64__(v147.u32[1], vdup_lane_s32(v144, 1).u32[0]);
  v105 = vdivq_f32(vmulq_laneq_f32(vsqrtq_f32(vaddq_f32(v104, v101)), (float32x4_t)a3, 3), (float32x4_t)vdupq_n_s32(0xBF35C28F));
  v106 = vcvt_hight_f64_f32(v105);
  __asm { FMOV            V3.2D, #1.0 }
  v112 = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)v105.f32), _Q3);
  v113 = vaddq_f64(v106, _Q3);
  __asm { FMOV            V3.2D, #3.0 }
  v115 = vmulq_f64(v113, _Q3);
  v116 = (int32x2_t)vcvt_f32_f64(vmulq_f64(v112, _Q3));
  v117 = vcvt_hight_f32_f64(v116, v115);
  v118 = vcvt_f32_f64(v115);
  v119 = v118.f32[1];
  if (v118.f32[1] > 1.0)
    v119 = 1.0;
  v120 = COERCE_DOUBLE(vmovn_s32(vcltzq_f32(v117)));
  v121 = v119;
  if ((BYTE6(v120) & 1) != 0)
    v121 = 0.0;
  v102.i64[0] = -2.0;
  v122 = (v121 * -2.0 + 3.0) * v121;
  v123 = v122 * v121;
  *(float *)&v122 = 1.0 - v123;
  v124 = vmlaq_n_f32(vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v122, 0), v150, 3), v149, v123);
  if (v118.f32[0] > 1.0)
    v118.f32[0] = 1.0;
  v125 = v118.f32[0];
  if ((BYTE4(v120) & 1) != 0)
    v125 = 0.0;
  v126 = (v125 * -2.0 + 3.0) * v125 * v125;
  v127 = vmlaq_n_f32(vmulq_n_f32(v124, 1.0 - v126), v146, v126);
  v128 = *(float *)&v116.i32[1];
  if (*(float *)&v116.i32[1] > 1.0)
    v128 = 1.0;
  v129 = v128;
  if ((BYTE2(v120) & 1) != 0)
    v129 = 0.0;
  v130 = (v129 * -2.0 + 3.0) * v129 * v129;
  v131 = vmulq_n_f32(v127, 1.0 - v130);
  v132 = (int8x16_t)v152;
  v155 = vmlaq_n_f32(v131, v152, v130);
  if (*(float *)v116.i32 > 1.0)
    *(float *)v116.i32 = 1.0;
  v133 = *(float *)v116.i32;
  if ((LOBYTE(v120) & 1) != 0)
    v133 = 0.0;
  v134 = (v133 * -2.0 + 3.0) * v133;
  v135 = v134 * v133;
  v153 = v135;
  LODWORD(v120) = *(_DWORD *)(a1 + 28);
  *(float *)&v136 = *(float *)(a1 + 24)
                  + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v103.f64[0], 1), *(float *)(a1 + 16), *(float *)v103.f64);
  v132.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&v134 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v103.f64[0], 1), *(float *)&v120, *(float *)v103.f64);
  *(float *)v103.f64 = *(float *)v132.i32 + *(float *)&v134;
  *((float *)&v136 + 1) = *(float *)v132.i32 + *(float *)&v134;
  *(double *)v137.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v136, v103, v134, v120, v132, 0, 3.0, v102);
  v138.i32[1] = v143.i32[1];
  *(float *)v138.i32 = (float)(v143.f32[2] + -0.5) * 0.1;
  v139 = vaddq_f32(v137, vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(v138, 0), v137, 3));
  v139.i32[3] = v137.i32[3];
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v155, 1.0 - v153), v139, v153).u64[0];
  return result;
}

void sub_19233AA80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_19233BD18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  _Block_object_dispose(&a34, 8);
  _Unwind_Resume(a1);
}

__n64 cikernel::_xSmooth(cikernel *this, SamplerObj *a2)
{
  double v3;
  double v4;
  int8x16_t v5;
  uint8x8_t v6;
  double v7;
  int8x16_t v8;
  float32x2_t v9;
  int v10;
  float v11;
  float64x2_t v12;
  float32x2_t v13;
  float32x4_t v14;
  __n64 result;
  float64x2_t v16;

  v9 = *(float32x2_t *)CI::getDC(this);
  v10 = -4;
  v11 = 0.0;
  LODWORD(v12.f64[0]) = 1120403456;
  do
  {
    v16 = v12;
    HIDWORD(v12.f64[0]) = 0;
    v13 = vadd_f32(v9, (float32x2_t)COERCE_UNSIGNED_INT((float)v10));
    *(float *)&v3 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v13, 1), *((float *)this + 4), v13.f32[0]);
    LODWORD(v4) = *((_DWORD *)this + 7);
    v6.i32[0] = *((_DWORD *)this + 9);
    *(float *)v5.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v13, 1), *(float *)&v4, v13.f32[0]);
    v13.f32[0] = *((float *)this + 6) + *(float *)&v3;
    *(float *)v12.f64 = *(float *)v6.i32 + *(float *)v5.i32;
    v13.f32[1] = *(float *)v6.i32 + *(float *)v5.i32;
    *(double *)v14.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v13, v12, v3, v4, v5, v6, v7, v8);
    v3 = v11;
    v11 = v11 + vmulq_f32(v14, v14).f32[0] * 0.111111111;
    v12 = v16;
    *(float *)v12.f64 = fminf(*(float *)v16.f64, v14.f32[0]);
    ++v10;
  }
  while (v10 != 5);
  result.n64_f32[0] = sqrtf(v11);
  result.n64_u32[1] = LODWORD(v12.f64[0]);
  return result;
}

double cikernel::_ySmooth(uint64_t a1, uint64_t a2, int8x16_t a3)
{
  float64x2_t v5;
  double v6;
  double v7;
  int8x16_t v8;
  uint8x8_t v9;
  double v10;
  int8x16_t v11;
  float32x2_t v12;
  int v13;
  float v14;
  float64x2_t v15;
  float32x2_t v16;
  CI *v17;
  float32x4_t v18;
  float32x2_t *DC;
  double v20;
  double v21;
  uint8x8_t v22;
  int8x16_t v23;
  double v24;
  float64x2_t v25;
  double v26;
  int8x16_t v27;
  double v28;
  float32x2_t v29;
  unint64_t v31;
  float32x2_t v32;
  float32x2_t v38;
  float32x2_t v39;
  double result;
  float64x2_t v42;

  v12 = *(float32x2_t *)CI::getDC((CI *)a1);
  v13 = -4;
  v14 = 0.0;
  LODWORD(v15.f64[0]) = 1120403456;
  v42 = v15;
  do
  {
    LODWORD(v5.f64[0]) = 0;
    *((float *)v5.f64 + 1) = (float)v13;
    v16 = vadd_f32(v12, *(float32x2_t *)&v5.f64[0]);
    *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v16, 1), *(float *)(a1 + 16), v16.f32[0]);
    LODWORD(v7) = *(_DWORD *)(a1 + 28);
    v9.i32[0] = *(_DWORD *)(a1 + 36);
    *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v16, 1), *(float *)&v7, v16.f32[0]);
    v16.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
    *(float *)v5.f64 = *(float *)v9.i32 + *(float *)v8.i32;
    v16.f32[1] = *(float *)v9.i32 + *(float *)v8.i32;
    *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v16, v5, v6, v7, v8, v9, v10, v11);
    v6 = v14;
    v14 = v14 + vmulq_f32(v18, v18).f32[0] * 0.111111111;
    v5 = v42;
    *(float *)v5.f64 = fminf(*(float *)v42.f64, v18.f32[1]);
    v42 = v5;
    ++v13;
  }
  while (v13 != 5);
  DC = (float32x2_t *)CI::getDC(v17);
  *(float *)&v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v21) = *(_DWORD *)(a2 + 28);
  v22.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v21, COERCE_FLOAT(*DC));
  *(float *)&v24 = *(float *)(a2 + 24) + *(float *)&v20;
  *(float *)v25.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  *((float *)&v24 + 1) = *(float *)v22.i32 + *(float *)v23.i32;
  v28 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v24, v25, v20, v21, v23, v22, v26, v27);
  v29 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v28, 0);
  _Q4 = a3;
  v29.i32[0] = LODWORD(v42.f64[0]);
  v31 = vextq_s8(_Q4, _Q4, 8uLL).u64[0];
  _Q4.i32[0] = HIDWORD(v31);
  v32 = vdiv_f32(vsub_f32(v29, (float32x2_t)__PAIR64__(a3.u32[0], v31)), vsub_f32(*(float32x2_t *)_Q4.i8, (float32x2_t)__PAIR64__(a3.u32[0], v31)));
  __asm { FMOV            V3.2S, #1.0 }
  v38 = (float32x2_t)vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v32, _D3), (int8x8_t)_D3, (int8x8_t)v32), (int8x8_t)vcltz_f32(v32));
  __asm { FMOV            V4.2S, #3.0 }
  v39 = vmul_f32(vmul_f32(v38, v38), vmla_f32(*(float32x2_t *)_Q4.i8, (float32x2_t)0xC0000000C0000000, v38));
  v39.f32[0] = vmul_lane_f32(v39, v39, 1).f32[0];
  *(_QWORD *)&result = COERCE_UNSIGNED_INT(vmlas_n_f32(sqrtf(v14) * v39.f32[0], 1.0 - v39.f32[0], *(float *)&v28));
  return result;
}

float32x4_t cikernel::_CIPortraitBlurDir(uint64_t a1, int8x16_t a2)
{
  float32x2_t v3;
  float64x2_t v4;
  float32x2_t v10;
  float32x2_t v11;
  double v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  float32x2_t v19;
  double v20;
  double v21;
  uint8x8_t v22;
  int8x16_t v23;
  float64x2_t v24;
  double v25;
  int8x16_t v26;
  float32x4_t v27;
  double v28;
  double v29;
  uint8x8_t v30;
  int8x16_t v31;
  float64x2_t v32;
  double v33;
  int8x16_t v34;
  float32x4_t v35;
  double v36;
  double v37;
  float64x2_t v38;
  uint8x8_t v39;
  double v40;
  int8x16_t v41;
  float32x4_t v42;
  double v43;
  double v44;
  uint8x8_t v45;
  int8x16_t v46;
  float64x2_t v47;
  double v48;
  int8x16_t v49;
  float32x4_t v50;
  double v51;
  double v52;
  uint8x8_t v53;
  int8x16_t v54;
  float64x2_t v55;
  double v56;
  int8x16_t v57;
  float32x4_t v58;
  double v59;
  double v60;
  uint8x8_t v61;
  int8x16_t v62;
  float64x2_t v63;
  double v64;
  int8x16_t v65;
  float32x4_t v66;
  float v80;
  float v81;
  float v82;
  float32x4_t result;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  int8x16_t v94;
  float32x4_t v95;

  v87 = *(float *)a2.i32;
  v3 = (float32x2_t)vext_s8(*(int8x8_t *)a2.i8, (int8x8_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), 4uLL);
  v4.f64[0] = *(float64_t *)CI::getDC((CI *)a1);
  v94 = (int8x16_t)v4;
  __asm { FMOV            V0.2S, #3.0 }
  v10 = vmul_f32(v3, _D0);
  v11 = vsub_f32(*(float32x2_t *)&v4.f64[0], v10);
  *(float *)&v12 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v11, 1), *(float *)(a1 + 16), v11.f32[0]);
  LODWORD(v13) = *(_DWORD *)(a1 + 28);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *(float *)(a1 + 24) + *(float *)&v12;
  *(float *)v4.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v11, v4, v12, v13, v15, v14, v16, v17);
  v93 = v18;
  v19 = vadd_f32(v3, v3);
  *(float32x2_t *)v18.f32 = vsub_f32(*(float32x2_t *)v94.i8, v19);
  *(float *)&v20 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v18.f32, 1), *(float *)(a1 + 16), v18.f32[0]);
  LODWORD(v21) = *(_DWORD *)(a1 + 28);
  v22.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v18.f32, 1), *(float *)&v21, v18.f32[0]);
  v18.f32[0] = *(float *)(a1 + 24) + *(float *)&v20;
  *(float *)v24.f64 = *(float *)v22.i32 + *(float *)v23.i32;
  v18.f32[1] = *(float *)v22.i32 + *(float *)v23.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v18.i64, v24, v20, v21, v23, v22, v25, v26);
  v92 = v27;
  *(float32x2_t *)v27.f32 = vsub_f32(*(float32x2_t *)v94.i8, v3);
  *(float *)&v28 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v27.f32, 1), *(float *)(a1 + 16), v27.f32[0]);
  LODWORD(v29) = *(_DWORD *)(a1 + 28);
  v30.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v27.f32, 1), *(float *)&v29, v27.f32[0]);
  v27.f32[0] = *(float *)(a1 + 24) + *(float *)&v28;
  *(float *)v32.f64 = *(float *)v30.i32 + *(float *)v31.i32;
  v27.f32[1] = *(float *)v30.i32 + *(float *)v31.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v32, v28, v29, v31, v30, v33, v34);
  v91 = v35;
  LODWORD(v36) = *(_DWORD *)(a1 + 28);
  v35.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v94.i8, 1), *(float *)(a1 + 16), *(float *)v94.i32);
  LODWORD(v37) = *(_DWORD *)(a1 + 36);
  *(float *)v38.f64 = *(float *)&v37
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v94.i8, 1), *(float *)&v36, *(float *)v94.i32);
  v35.i32[1] = LODWORD(v38.f64[0]);
  *(double *)v42.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v38, v36, v37, v94, v39, v40, v41);
  v90 = v42;
  *(float32x2_t *)v42.f32 = vadd_f32(v3, *(float32x2_t *)v94.i8);
  *(float *)&v43 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v42.f32, 1), *(float *)(a1 + 16), v42.f32[0]);
  LODWORD(v44) = *(_DWORD *)(a1 + 28);
  v45.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v46.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v42.f32, 1), *(float *)&v44, v42.f32[0]);
  v42.f32[0] = *(float *)(a1 + 24) + *(float *)&v43;
  *(float *)v47.f64 = *(float *)v45.i32 + *(float *)v46.i32;
  v42.f32[1] = *(float *)v45.i32 + *(float *)v46.i32;
  *(double *)v50.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v42.i64, v47, v43, v44, v46, v45, v48, v49);
  v89 = v50;
  *(float32x2_t *)v50.f32 = vadd_f32(v19, *(float32x2_t *)v94.i8);
  *(float *)&v51 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v50.f32, 1), *(float *)(a1 + 16), v50.f32[0]);
  LODWORD(v52) = *(_DWORD *)(a1 + 28);
  v53.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v50.f32, 1), *(float *)&v52, v50.f32[0]);
  v50.f32[0] = *(float *)(a1 + 24) + *(float *)&v51;
  *(float *)v55.f64 = *(float *)v53.i32 + *(float *)v54.i32;
  v50.f32[1] = *(float *)v53.i32 + *(float *)v54.i32;
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v50.i64, v55, v51, v52, v54, v53, v56, v57);
  v88 = v58;
  *(float32x2_t *)v58.f32 = vadd_f32(v10, *(float32x2_t *)v94.i8);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v58.f32, 1), *(float *)(a1 + 16), v58.f32[0]);
  LODWORD(v60) = *(_DWORD *)(a1 + 28);
  v61.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v58.f32, 1), *(float *)&v60, v58.f32[0]);
  v58.f32[0] = *(float *)(a1 + 24) + *(float *)&v59;
  *(float *)v63.f64 = *(float *)v61.i32 + *(float *)v62.i32;
  v58.f32[1] = *(float *)v61.i32 + *(float *)v62.i32;
  *(double *)v66.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v58.i64, v63, v59, v60, v62, v61, v64, v65);
  v95 = v66;
  v84 = vmulq_f32(v93, v93);
  v85 = vmulq_f32(v66, v66);
  v86 = vmulq_f32(v90, v90);
  v66.f32[0] = fmaxf(vmuls_lane_f32(v87, v86, 3), 0.01);
  v66.f32[0] = -1.0 / ((v66.f32[0] + v66.f32[0]) * v66.f32[0]);
  _S0 = exp(v66.f32[0]);
  _S1 = (float)((float)(_S0 * _S0) * _S0) * _S0;
  _S2 = (float)(_S1 * _S1) * _S0;
  _V5.S[3] = v84.i32[3];
  __asm { FMLA            S3, S2, V5.S[3] }
  _Q18 = vmulq_f32(v91, v91);
  _Q17 = vmulq_f32(v89, v89);
  __asm
  {
    FMLA            S3, S0, V18.S[3]
    FMLA            S3, S0, V17.S[3]
  }
  _Q16 = vmulq_f32(v88, v88);
  _V7.S[3] = v85.i32[3];
  __asm
  {
    FMLA            S3, S1, V16.S[3]
    FMLA            S3, S2, V7.S[3]
  }
  v80 = 1.0 / _S3;
  v81 = _S1 * v80;
  v82 = _S2 * v80;
  result = vaddq_f32(vmulq_n_f32(v89, vmuls_lane_f32(v80 * _S0, _Q17, 3)), vaddq_f32(vmulq_n_f32(v90, vmuls_lane_f32(v80, v86, 3)), vaddq_f32(vmulq_n_f32(v91, vmuls_lane_f32(v80 * _S0, _Q18, 3)), vaddq_f32(vmulq_n_f32(v92, vmuls_lane_f32(v81, vmulq_f32(v92, v92), 3)), vmulq_n_f32(v93, vmuls_lane_f32(v82, v84, 3))))));
  result.i64[0] = vaddq_f32(vmulq_n_f32(v95, vmuls_lane_f32(v82, v85, 3)), vaddq_f32(vmulq_n_f32(v88, vmuls_lane_f32(v81, _Q16, 3)), result)).u64[0];
  result.i32[3] = v90.i32[3];
  return result;
}

double cikernel::_CIPortraitBlurBlendWithMaskFromAlpha(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  float v3;
  float v4;
  double result;

  v3 = (float)(vmuls_lane_f32(vmuls_lane_f32(vmulq_laneq_f32(a3, a3, 3).f32[0], a2, 3), a2, 3) - a3.f32[1]) / a3.f32[2];
  if (v3 <= 1.0)
    v4 = v3;
  else
    v4 = 1.0;
  if (v3 < 0.0)
    v4 = 0.0;
  a2.f32[3] = v4;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - v4), a2, v4).u64[0];
  return result;
}

void sub_19233E8E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

void sub_19233EF30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nRingsFromTuningParameters(NSDictionary *a1, float a2, uint64_t a3, NSNumber *a4)
{
  float v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  double v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  unsigned int v26;
  unsigned int v27;

  SDOFRenderingValue(CFSTR("nRings"), a1);
  v9 = (int)v8;
  SDOFRenderingValue(CFSTR("minimumSimulatedAperture"), a1);
  v11 = v10;
  SDOFSimpleLensModelValue(CFSTR("maximumSimulatedAperture"), a1);
  v13 = v12;
  SDOFSimpleLensModelValue(CFSTR("defaultSimulatedAperture"), a1);
  v15 = v14;
  -[NSNumber floatValue](a4, "floatValue");
  v17 = v16;
  if (a2 <= 1.0)
    v18 = a2;
  else
    v18 = 1.0;
  v19 = v18;
  if (v18 >= 1.0 || v11 <= 0.0 || v13 <= 0.0 || v15 <= 0.0)
  {
    if (v19 < 0.5)
      v19 = 0.5;
    v23 = v19 * (double)(int)v9;
    v24 = ceilf(v23);
  }
  else
  {
    if (v17 >= v15)
    {
      v25 = 0.699999988 / (float)(v13 - v15) * (float)(v17 - v15) + 1.0;
      v21 = pow(v19, 0.2);
      v22 = (float)(int)v9 * v25;
    }
    else
    {
      v20 = (float)((float)((float)(v17 - v11) / (float)(v15 - v11)) * -0.5) + 1.0;
      v21 = pow(v19, 0.0833333333);
      v22 = v20 * (float)(int)v9;
    }
    v24 = v22 * v21;
  }
  v26 = (int)v24;
  if ((int)v24 <= 4)
    v26 = 4;
  if (a3 != 2)
  {
    if ((_DWORD)v9 == 4)
      v27 = 2;
    else
      v27 = 4;
    if (a3 == 1)
      return v27;
    else
      return v26;
  }
  return v9;
}

void sub_192340604(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  _Unwind_Resume(exception_object);
}

double cikernel::_sparserendering_add_noise(float32x4_t a1, float a2, double a3)
{
  double v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  double result;

  v3 = a2 * 10.0 + -5.0;
  *(float *)&v3 = v3;
  v4 = vmulq_f32(a1, (float32x4_t)xmmword_1924921A0);
  *(float *)&v3 = vmuls_lane_f32((float)(1.0 - *(float *)&a3)+ vmuls_n_f32(*(float *)&a3, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0]), *(float32x2_t *)&a3, 1)* *(float *)&v3;
  v5 = vaddq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v3, 0));
  v5.i32[3] = 0;
  v6 = vmaxnmq_f32(v5, (float32x4_t)0);
  v6.i32[3] = 0;
  v7 = vminnmq_f32(v6, (float32x4_t)xmmword_192491FD0);
  v7.i32[3] = a1.i32[3];
  v8 = vmaxnmq_f32(v7, (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  *(_QWORD *)&result = vminnmq_f32(v8, _Q1).u64[0];
  return result;
}

void CI::f4_s_s_f2(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, double);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  double *v18;
  __n128 *v19;
  __n128 *v20;
  __int128 v21;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, double))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_DWORD *)(v10 + 64);
  v17 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (double *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v15);
  v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v21 = v11(a1, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

double cikernel::_CIPortraitBlurBlendWithMaskMatteFromAlpha(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  double result;

  v4 = vmuls_lane_f32(vmuls_lane_f32(a4.f32[0], a2, 3), a2, 3);
  v5 = (float)(v4 - a4.f32[1]) / a4.f32[2];
  if (v5 <= 1.0)
    v6 = (float)(v4 - a4.f32[1]) / a4.f32[2];
  else
    v6 = 1.0;
  if (v5 < 0.0)
    v6 = 0.0;
  v7 = vmulq_laneq_f32(a3, a4, 3).f32[0];
  v8 = 1.0 - v7;
  if (v7 > 1.0)
    v8 = 0.0;
  if (v7 >= 0.0)
    v9 = v8;
  else
    v9 = 1.0;
  a2.i32[3] = fminf(v6, v9);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a2.f32[3]), a2, a2.f32[3]).u64[0];
  return result;
}

double cikernel::_CIPortraitBlurBlendWithMaskMatteFromAlphaYCC(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float a5)
{
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float32x4_t v13;
  double result;
  float32x4_t v15;
  float v16;

  v6 = vmuls_lane_f32(vmuls_lane_f32(a4.f32[0], a2, 3), a2, 3);
  v7 = (float)(v6 - a4.f32[1]) / a4.f32[2];
  if (v7 <= 1.0)
    v8 = (float)(v6 - a4.f32[1]) / a4.f32[2];
  else
    v8 = 1.0;
  if (v7 < 0.0)
    v8 = 0.0;
  v9 = a5 * a3.f32[0];
  v10 = 1.0 - (float)(a5 * a3.f32[0]);
  if (v9 > 1.0)
    v10 = 0.0;
  if (v9 >= 0.0)
    v11 = v10;
  else
    v11 = 1.0;
  v12 = fminf(v8, v11);
  v13 = vmlaq_laneq_f32(vmulq_n_f32(a1, 1.0 - a2.f32[3]), a2, a2, 3);
  result = *(double *)v13.i64;
  if (v12 < 1.0)
  {
    v15 = vmulq_laneq_f32(a3, a4, 3);
    v16 = 1.0 - v15.f32[0];
    if (v15.f32[0] > 1.0)
      v16 = 0.0;
    if (v15.f32[0] >= 0.0)
      v15.f32[0] = v16;
    else
      v15.f32[0] = 1.0;
    v15.f32[0] = fminf(v8, v15.f32[0]);
    v15.f32[1] = v12;
    v15.f32[2] = v12;
    *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v15, 1.0 - v12), v13, v12).u64[0];
  }
  return result;
}

void CI::f4_s_s_s_f4_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, float);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  __n128 *v20;
  __n128 *v21;
  __n128 *v22;
  __n128 *v23;
  __int128 v24;
  int v25;
  int v26;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, float))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  v19 = *(_QWORD *)(v9 + 104);
  if (*(_BYTE *)(a1 + 64))
  {
    v25 = *(_DWORD *)(v9 + 88);
    v26 = *(_DWORD *)(v9 + 64);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
    v17 = v25;
    v15 = v26;
  }
  v20 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v18);
  v21 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v21 = (__n128 *)((char *)a2 + 64 * v16);
  v22 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v22 = (__n128 *)((char *)a2 + 64 * v14);
  v23 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v23 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v24 = v10(*v23, *v22, *v21, *v20, *((float *)a2 + 16 * v19));
  *(_OWORD *)(a3 + 16 * a7) = v24;
}

uint64_t dictionaryDeepCopy(void *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE v18[128];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (objc_msgSend(a1, "count"))
  {
    v2 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v14 = 0u;
    v15 = 0u;
    v16 = 0u;
    v17 = 0u;
    v3 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
    if (!v3)
      return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:", v2, objc_msgSend(a1, "allKeys"));
    v4 = v3;
    v5 = *(_QWORD *)v15;
    while (1)
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v15 != v5)
          objc_enumerationMutation(a1);
        v7 = (void *)objc_msgSend(a1, "valueForKey:", *(_QWORD *)(*((_QWORD *)&v14 + 1) + 8 * v6));
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v8 = dictionaryDeepCopy(v7);
          goto LABEL_11;
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v8 = arrayDeepCopy(v7);
LABEL_11:
          v9 = (void *)v8;
          v10 = v2;
LABEL_12:
          objc_msgSend(v10, "addObject:", v9);
          goto LABEL_13;
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_respondsToSelector() & 1) == 0)
        {
          v10 = v2;
          v9 = v7;
          goto LABEL_12;
        }
        v11 = (void *)objc_msgSend(v7, "copy");
        objc_msgSend(v2, "addObject:", v11);

LABEL_13:
        ++v6;
      }
      while (v4 != v6);
      v12 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
      v4 = v12;
      if (!v12)
        return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:", v2, objc_msgSend(a1, "allKeys"));
    }
  }
  return MEMORY[0x1E0C9AA70];
}

uint64_t scaleImageWithQuality(void *a1, _OWORD *a2)
{
  __int128 v4;
  _OWORD v6[3];

  if (isMetalFamily3_onceToken != -1)
    dispatch_once(&isMetalFamily3_onceToken, &__block_literal_global_60);
  v4 = a2[1];
  v6[0] = *a2;
  v6[1] = v4;
  v6[2] = a2[2];
  if (isMetalFamily3_supports)
    return objc_msgSend(a1, "imageByApplyingTransform:highQualityDownsample:", v6, 1);
  else
    return objc_msgSend(a1, "imageByApplyingTransform:", v6);
}

uint64_t arrayDeepCopy(void *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE v18[128];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (objc_msgSend(a1, "count"))
  {
    v2 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "array");
    v14 = 0u;
    v15 = 0u;
    v16 = 0u;
    v17 = 0u;
    v3 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
    if (!v3)
      return objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v2);
    v4 = v3;
    v5 = *(_QWORD *)v15;
    while (1)
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v15 != v5)
          objc_enumerationMutation(a1);
        v7 = *(void **)(*((_QWORD *)&v14 + 1) + 8 * v6);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v8 = dictionaryDeepCopy(v7);
          goto LABEL_11;
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          v8 = arrayDeepCopy(v7);
LABEL_11:
          v9 = (void *)v8;
          v10 = v2;
LABEL_12:
          objc_msgSend(v10, "addObject:", v9);
          goto LABEL_13;
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_respondsToSelector() & 1) == 0)
        {
          v10 = v2;
          v9 = v7;
          goto LABEL_12;
        }
        v11 = (void *)objc_msgSend(v7, "copy");
        objc_msgSend(v2, "addObject:", v11);

LABEL_13:
        ++v6;
      }
      while (v4 != v6);
      v12 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
      v4 = v12;
      if (!v12)
        return objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithArray:", v2);
    }
  }
  return MEMORY[0x1E0C9AA60];
}

void __isMetalFamily3_block_invoke()
{
  id v0;

  v0 = MTLCreateSystemDefaultDevice();
  isMetalFamily3_supports = objc_msgSend(v0, "supportsFamily:", 1003);

}

double GetAdaptationMatrix(const double *a1, const double *a2, double *a3)
{
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v15;
  __int128 v16;
  uint64_t v17;
  double v18;
  __int128 v19;
  uint64_t v20;
  double v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v4 = a1[1];
  v5 = a1[2];
  v6 = v4 * 0.2664 + *a1 * 0.8951 + v5 * -0.1614;
  v7 = v4 * 1.7135 + *a1 * -0.7502 + v5 * 0.0367;
  v8 = v4 * -0.0685 + *a1 * 0.0389 + v5 * 1.0296;
  v9 = a2[1];
  v10 = a2[2];
  v11 = v9 * 0.2664 + *a2 * 0.8951 + v10 * -0.1614;
  v12 = v9 * 1.7135 + *a2 * -0.7502 + v10 * 0.0367;
  v13 = v9 * -0.0685 + *a2 * 0.0389 + v10 * 1.0296;
  v17 = 0;
  v20 = 0;
  v19 = 0u;
  v16 = 0u;
  v15 = v11 / v6;
  v18 = v12 / v7;
  v21 = v13 / v8;
  MatrixMatrix(GetAdaptationMatrix(double const*,double const*,double *)::Bradford_mtx, &v15, a3);
  return MatrixMatrix(a3, GetAdaptationMatrix(double const*,double const*,double *)::invBradford_mtx, a3);
}

double MatrixMatrix(double *a1, double *a2, double *a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double result;

  v3 = *a1;
  v4 = a1[1];
  v5 = a1[2];
  v6 = a1[3];
  v7 = a1[4];
  v8 = a1[5];
  v9 = a1[6];
  v10 = a1[7];
  v11 = a1[8];
  v12 = *a2;
  v13 = a2[1];
  v14 = a2[2];
  v15 = a2[3];
  v16 = a2[4];
  v17 = a2[5];
  v18 = a2[6];
  v19 = a2[7];
  v20 = a2[8];
  v21 = v7 * v13 + v4 * *a2 + v10 * v14;
  *a3 = v6 * v13 + *a1 * *a2 + v9 * v14;
  a3[1] = v21;
  a3[2] = v8 * v13 + v5 * v12 + v11 * v14;
  a3[3] = v6 * v16 + v3 * v15 + v9 * v17;
  a3[4] = v7 * v16 + v4 * v15 + v10 * v17;
  a3[5] = v8 * v16 + v5 * v15 + v11 * v17;
  a3[6] = v6 * v19 + v3 * v18 + v9 * v20;
  a3[7] = v7 * v19 + v4 * v18 + v10 * v20;
  result = v8 * v19 + v5 * v18 + v11 * v20;
  a3[8] = result;
  return result;
}

void ___ZL17GetLinearAdobeRGBv_block_invoke()
{
  CGDataProvider *v0;

  v0 = CGDataProviderCreateWithData(0, &GetLinearAdobeRGB(void)::data, 0x210uLL, 0);
  GetLinearAdobeRGB(void)::space = (uint64_t)CGColorSpaceCreateICCBased(3uLL, 0, v0, 0);
  CFRelease(v0);
}

double cikernel::_convertUsingColorMatrix(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  double result;

  *(_QWORD *)&result = vaddq_f32(vmulq_laneq_f32(a4, a1, 2), vaddq_f32(vmulq_n_f32(a2, a1.f32[0]), vmulq_lane_f32(a3, *(float32x2_t *)a1.f32, 1))).u64[0];
  return result;
}

double cikernel::_localBoost(float32x4_t a1, int32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float a7)
{
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  int8x16_t v10;
  int32x2_t v11;
  int8x16_t v12;
  int32x2_t v13;
  int8x16_t v14;
  int32x2_t v15;
  int8x16_t v16;
  int32x2_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float64x2_t v28;
  float32x4_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  double result;

  v7 = vmulq_f32(a1, a1);
  v8 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 0);
  v9 = vmulq_f32(a1, v7);
  v8.i32[0] = v9.i32[0];
  v8.i64[1] = __PAIR64__(1.0, vdupq_lane_s32(*(int32x2_t *)&a1, 0).u32[2]);
  v10 = (int8x16_t)vmulq_f32(a3, v8);
  v11 = (int32x2_t)vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL));
  v12 = (int8x16_t)vmulq_f32(a4, v8);
  v13 = (int32x2_t)vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  v14 = (int8x16_t)vmulq_f32(a5, v8);
  v15 = (int32x2_t)vadd_f32(*(float32x2_t *)v14.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL));
  v16 = (int8x16_t)vmulq_f32(v8, a6);
  v17 = (int32x2_t)vadd_f32(*(float32x2_t *)v16.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL));
  v18 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.f32, 1);
  v18.i64[0] = __PAIR64__(v7.u32[1], v9.u32[1]);
  *(double *)v16.i64 = a7;
  v18.i32[3] = v8.i32[3];
  v19 = (int8x16_t)vmulq_f32(a3, v18);
  *(float32x2_t *)v19.i8 = vadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL));
  *(float32x2_t *)v19.i8 = vadd_f32((float32x2_t)vzip1_s32(v11, *(int32x2_t *)v19.i8), (float32x2_t)vzip2_s32(v11, *(int32x2_t *)v19.i8));
  v20 = (int8x16_t)vmulq_f32(a4, v18);
  *(float32x2_t *)v20.i8 = vadd_f32(*(float32x2_t *)v20.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL));
  *(float32x2_t *)v20.i8 = vadd_f32((float32x2_t)vzip1_s32(v13, *(int32x2_t *)v20.i8), (float32x2_t)vzip2_s32(v13, *(int32x2_t *)v20.i8));
  v21 = (int8x16_t)vmulq_f32(v18, a5);
  *(float32x2_t *)v21.i8 = vadd_f32(*(float32x2_t *)v21.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL));
  *(float32x2_t *)v21.i8 = vadd_f32((float32x2_t)vzip1_s32(v15, *(int32x2_t *)v21.i8), (float32x2_t)vzip2_s32(v15, *(int32x2_t *)v21.i8));
  v22 = (int8x16_t)vmulq_f32(v18, a6);
  *(float32x2_t *)v22.i8 = vadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL));
  *(float32x2_t *)v22.i8 = vadd_f32((float32x2_t)vzip1_s32(v17, *(int32x2_t *)v22.i8), (float32x2_t)vzip2_s32(v17, *(int32x2_t *)v22.i8));
  __asm { FMOV            V23.2D, #-1.0 }
  v28 = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)a1.f32), _Q23);
  __asm { FMOV            V23.2D, #1.0 }
  v30 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2);
  v30.i32[0] = v9.i32[2];
  v30.i64[1] = __PAIR64__(1.0, a1.u32[2]);
  v31 = (int8x16_t)vmulq_f32(a3, v30);
  *(float32x2_t *)v31.i8 = vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v31, v31, 8uLL));
  v19.u64[1] = (unint64_t)vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v31.i8, 1));
  *(float32x2_t *)v31.i8 = vcvt_f32_f64(vmlaq_n_f64(_Q23, v28, *(double *)v16.i64));
  v32 = (int8x16_t)vmulq_f32(a4, v30);
  *(float32x2_t *)v32.i8 = vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
  v20.u64[1] = (unint64_t)vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v32.i8, 1));
  v33 = (int8x16_t)vmulq_f32(a5, v30);
  *(float32x2_t *)v33.i8 = vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
  v21.u64[1] = (unint64_t)vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v33.i8, 1));
  v34 = (int8x16_t)vmulq_f32(v30, a6);
  *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
  v22.u64[1] = (unint64_t)vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v34.i8, 1));
  *(float *)v34.i32 = (a1.f32[2] + -1.0) * *(double *)v16.i64 + 1.0;
  v31.i32[2] = v34.i32[0];
  *(_QWORD *)&result = vbicq_s8(vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 0))), v19, vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 1))), v20, vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_laneq_s32(a2, 2))), v21, vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_laneq_s32(a2, 3))), v22, v31)))), (int8x16_t)vcltzq_f32(a1)).u64[0];
  return result;
}

void CI::f4_s_f4_f4_f4_f4_f4_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, __n128, __n128, float);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  __n128 *v24;
  __n128 *v25;
  __n128 *v26;
  __n128 *v27;
  __n128 *v28;
  __n128 *v29;
  __int128 v30;
  int v31;
  uint64_t v32;
  int v33;
  double (*v34)(__n128, __n128, __n128, __n128, __n128, __n128, float);
  int v35;
  int v36;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, float))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  v19 = *(_DWORD *)(v9 + 112);
  v20 = *(_QWORD *)(v9 + 104);
  v21 = *(_DWORD *)(v9 + 136);
  v22 = *(_QWORD *)(v9 + 128);
  v23 = *(_QWORD *)(v9 + 152);
  if (*(_BYTE *)(a1 + 64))
  {
    v34 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, float))(a1 + 24);
    v32 = *(_QWORD *)(v9 + 8);
    v35 = *(_DWORD *)(v9 + 64);
    v36 = *(_DWORD *)(v9 + 40);
    v33 = *(_DWORD *)(v9 + 88);
    v31 = *(_DWORD *)(v9 + 136);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 176)), a2);
    v21 = v31;
    v17 = v33;
    v15 = v35;
    v13 = v36;
    v12 = v32;
    v10 = v34;
  }
  v24 = (__n128 *)(a3 + 16 * v22);
  if (v21 != 5)
    v24 = (__n128 *)((char *)a2 + 64 * v22);
  v25 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5)
    v25 = (__n128 *)((char *)a2 + 64 * v20);
  v26 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v26 = (__n128 *)((char *)a2 + 64 * v18);
  v27 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v27 = (__n128 *)((char *)a2 + 64 * v16);
  v28 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v28 = (__n128 *)((char *)a2 + 64 * v14);
  v29 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v29 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v30 = v10(*v29, *v28, *v27, *v26, *v25, *v24, *((float *)a2 + 16 * v23));
  *(_OWORD *)(a3 + 16 * a7) = v30;
}

double cikernel::_boostRGB(float32x4_t a1, int32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float a7)
{
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int32x2_t v12;
  int8x16_t v13;
  int32x2_t v14;
  int8x16_t v15;
  float32x4_t v16;
  int8x16_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float64x2_t v31;
  float32x4_t v33;
  double result;

  v7 = vmulq_f32(a1, a1);
  v8 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 0);
  v9 = vmulq_f32(a1, v7);
  v8.i32[0] = v9.i32[0];
  v8.i64[1] = __PAIR64__(1.0, vdupq_lane_s32(*(int32x2_t *)&a1, 0).u32[2]);
  v10 = (int8x16_t)vmulq_f32(a3, v8);
  *(float32x2_t *)v10.i8 = vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL));
  v11 = (int8x16_t)vmulq_f32(a4, v8);
  v12 = (int32x2_t)vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL));
  v13 = (int8x16_t)vmulq_f32(a5, v8);
  v14 = (int32x2_t)vadd_f32(*(float32x2_t *)v13.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 8uLL));
  v15 = (int8x16_t)vmulq_f32(v8, a6);
  *(float32x2_t *)v15.i8 = vadd_f32(*(float32x2_t *)v15.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL));
  v16 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.f32, 1);
  v16.i64[0] = __PAIR64__(v7.u32[1], v9.u32[1]);
  v16.i32[3] = 1.0;
  v17 = (int8x16_t)vmulq_f32(a3, v16);
  *(float32x2_t *)v17.i8 = vadd_f32(*(float32x2_t *)v17.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL));
  *(float32x2_t *)v10.i8 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v10.i8, *(int32x2_t *)v17.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v10.i8, *(int32x2_t *)v17.i8));
  v18 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2);
  v18.i32[0] = v9.i32[2];
  v18.i64[1] = __PAIR64__(1.0, a1.u32[2]);
  v19 = (int8x16_t)vmulq_f32(a3, v18);
  *(float32x2_t *)v19.i8 = vadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL));
  v10.i64[1] = vadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v19.i8, 1)).u32[0];
  v20 = (int8x16_t)vmulq_f32(a4, v16);
  *(float32x2_t *)v20.i8 = vadd_f32(*(float32x2_t *)v20.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v20, v20, 8uLL));
  v21 = (int8x16_t)vmulq_f32(a4, v18);
  *(float32x2_t *)v21.i8 = vadd_f32(*(float32x2_t *)v21.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL));
  *(float32x2_t *)v20.i8 = vadd_f32((float32x2_t)vzip1_s32(v12, *(int32x2_t *)v20.i8), (float32x2_t)vzip2_s32(v12, *(int32x2_t *)v20.i8));
  v20.i64[1] = vadd_f32(*(float32x2_t *)v21.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v21.i8, 1)).u32[0];
  v22 = (int8x16_t)vmulq_f32(v16, a5);
  *(float32x2_t *)v22.i8 = vadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL));
  *(float32x2_t *)v22.i8 = vadd_f32((float32x2_t)vzip1_s32(v14, *(int32x2_t *)v22.i8), (float32x2_t)vzip2_s32(v14, *(int32x2_t *)v22.i8));
  v23 = (int8x16_t)vmulq_f32(a5, v18);
  *(float32x2_t *)v23.i8 = vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL));
  v22.i64[1] = vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v23.i8, 1)).u32[0];
  v24 = (int8x16_t)vmulq_f32(v16, a6);
  *(float32x2_t *)v24.i8 = vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL));
  *(float32x2_t *)v24.i8 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v15.i8, *(int32x2_t *)v24.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v15.i8, *(int32x2_t *)v24.i8));
  v25 = (int8x16_t)vmulq_f32(v18, a6);
  *(float32x2_t *)v25.i8 = vadd_f32(*(float32x2_t *)v25.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v25, v25, 8uLL));
  v24.i64[1] = vadd_f32(*(float32x2_t *)v25.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v25.i8, 1)).u32[0];
  *(double *)v25.i64 = a7;
  __asm { FMOV            V16.2D, #-1.0 }
  v31 = vaddq_f64(vcvtq_f64_f32(*(float32x2_t *)a1.f32), _Q16);
  __asm { FMOV            V16.2D, #1.0 }
  *(float32x2_t *)&v31.f64[0] = vcvt_f32_f64(vmlaq_n_f64(_Q16, v31, *(double *)v25.i64));
  *(float *)v25.i32 = (a1.f32[2] + -1.0) * *(double *)v25.i64 + 1.0;
  *(_QWORD *)&v31.f64[1] = v25.u32[0];
  v33 = (float32x4_t)vbicq_s8(vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 0))), v10, vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 1))), v20, vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_laneq_s32(a2, 2))), v22, vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_laneq_s32(a2, 3))), v24, (int8x16_t)v31)))), (int8x16_t)vcltzq_f32(a1));
  *(_QWORD *)&result = vbicq_s8((int8x16_t)v33, (int8x16_t)vcltzq_f32(v33)).u64[0];
  return result;
}

double cikernel::_boostRGBLNoGamma(float32x4_t a1, int32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float a7)
{
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  int8x16_t v10;
  int32x2_t v11;
  int8x16_t v12;
  int32x2_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int32x2_t v18;
  int8x16_t v19;
  int32x2_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float32x4_t v23;
  int8x16_t v24;
  int32x2_t v25;
  int8x16_t v26;
  int32x2_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int32x2_t v31;
  float32x4_t v32;
  float32x4_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  int8x16_t v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  int8x16_t v43;

  v7 = vmulq_f32(a1, a1);
  v8 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 0);
  v9 = vmulq_f32(a1, v7);
  v8.i32[0] = v9.i32[0];
  v8.i64[1] = __PAIR64__(1.0, vdupq_lane_s32(*(int32x2_t *)&a1, 0).u32[2]);
  v10 = (int8x16_t)vmulq_f32(a3, v8);
  v11 = (int32x2_t)vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL));
  v12 = (int8x16_t)vmulq_f32(a4, v8);
  v13 = (int32x2_t)vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL));
  v14 = vmulq_f32(a5, v8);
  *(float32x2_t *)v14.f32 = vadd_f32(*(float32x2_t *)v14.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL));
  v15 = vmulq_f32(v8, a6);
  v16 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.f32, 1);
  v16.i64[0] = __PAIR64__(v7.u32[1], v9.u32[1]);
  *(float32x2_t *)v15.f32 = vadd_f32(*(float32x2_t *)v15.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL));
  v16.i32[3] = 1.0;
  v17 = (int8x16_t)vmulq_f32(a3, v16);
  v18 = (int32x2_t)vadd_f32(*(float32x2_t *)v17.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v17, v17, 8uLL));
  v19 = (int8x16_t)vmulq_f32(a4, v16);
  v20 = (int32x2_t)vadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL));
  v21 = (int8x16_t)vmulq_f32(v16, a5);
  *(float32x2_t *)v21.i8 = vadd_f32(*(float32x2_t *)v21.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL));
  v22 = (int8x16_t)vmulq_f32(v16, a6);
  v23 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2);
  v23.i32[0] = v9.i32[2];
  v23.i64[1] = __PAIR64__(1.0, a1.u32[2]);
  *(float32x2_t *)v7.f32 = vadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL));
  v24 = (int8x16_t)vmulq_f32(a3, v23);
  v25 = (int32x2_t)vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL));
  v26 = (int8x16_t)vmulq_f32(a4, v23);
  v27 = (int32x2_t)vadd_f32(*(float32x2_t *)v26.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v26, v26, 8uLL));
  v28 = (int8x16_t)vmulq_f32(a5, v23);
  *(float32x2_t *)v22.i8 = vadd_f32(*(float32x2_t *)v28.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL));
  v29 = vmulq_f32(a1, (float32x4_t)xmmword_1924921A0);
  v30 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1)));
  v31 = (int32x2_t)vmulq_f32(v30, v30).u64[0];
  v32 = (float32x4_t)vdupq_lane_s32(v31, 0);
  v33 = vmulq_f32(v23, a6);
  v32.i32[0] = vmuls_n_f32(v30.f32[0], *(float *)v31.i32);
  v32.i64[1] = __PAIR64__(1.0, vdupq_lane_s32(*(int32x2_t *)&v30, 0).u32[2]);
  v34 = (int8x16_t)vmulq_f32(a3, v32);
  *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
  *(int32x2_t *)v35.f32 = vzip1_s32(v11, v18);
  v35.i64[1] = __PAIR64__(v34.u32[0], v25.u32[0]);
  *(int32x2_t *)v36.f32 = vzip2_s32(v11, v18);
  v36.i32[2] = vdup_lane_s32(v25, 1).u32[0];
  v36.i32[3] = v34.i32[1];
  *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v33.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v33, (int8x16_t)v33, 8uLL));
  v37 = (int8x16_t)vmulq_f32(a4, v32);
  *(int32x2_t *)v33.f32 = vzip1_s32(v13, v20);
  v33.i32[2] = v27.i32[0];
  *(float32x2_t *)v37.i8 = vadd_f32(*(float32x2_t *)v37.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL));
  v33.i32[3] = v37.i32[0];
  *(int32x2_t *)v38.f32 = vzip2_s32(v13, v20);
  v38.i32[2] = vdup_lane_s32(v27, 1).u32[0];
  v38.i32[3] = v37.i32[1];
  v39 = (int8x16_t)vmulq_f32(a5, v32);
  *(float32x2_t *)v39.i8 = vadd_f32(*(float32x2_t *)v39.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL));
  *(int32x2_t *)v40.f32 = vzip1_s32(*(int32x2_t *)v14.f32, *(int32x2_t *)v21.i8);
  v40.i64[1] = __PAIR64__(v39.u32[0], v22.u32[0]);
  *(int32x2_t *)v14.f32 = vzip2_s32(*(int32x2_t *)v14.f32, *(int32x2_t *)v21.i8);
  v14.i32[2] = vdup_lane_s32(*(int32x2_t *)v22.i8, 1).u32[0];
  v14.i32[3] = v39.i32[1];
  v41 = (int8x16_t)vmulq_f32(a6, v32);
  *(float32x2_t *)v41.i8 = vadd_f32(*(float32x2_t *)v41.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL));
  *(int32x2_t *)v42.f32 = vzip1_s32(*(int32x2_t *)v15.f32, *(int32x2_t *)v7.f32);
  v42.i64[1] = __PAIR64__(v41.u32[0], v34.u32[0]);
  *(int32x2_t *)v15.f32 = vzip2_s32(*(int32x2_t *)v15.f32, *(int32x2_t *)v7.f32);
  v15.i64[1] = __PAIR64__(v41.u32[1], vdup_lane_s32(*(int32x2_t *)v34.i8, 1).u32[0]);
  v43 = (int8x16_t)vaddq_f32(v42, v15);
  a1.i32[3] = v30.i32[0];
  v42.f32[0] = v32.f32[3] - a7;
  a1.i64[0] = vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 0))), (int8x16_t)vaddq_f32(v35, v36), vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 1))), (int8x16_t)vaddq_f32(v33, v38), vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_laneq_s32(a2, 2))), (int8x16_t)vaddq_f32(v40, v14), vbslq_s8((int8x16_t)vcltzq_f32(vsubq_f32(a1, (float32x4_t)vdupq_laneq_s32(a2, 3))), v43, (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 0), vmulq_n_f32(a1, a7)))))).u64[0];
  return *(double *)a1.i64;
}

float32x4_t cikernel::_boostHybrid(uint64_t a1, float32x4_t a2, float a3, float a4, float a5)
{
  float32x4_t v9;
  float32x2_t *DC;
  double v11;
  double v12;
  uint8x8_t v13;
  int8x16_t v14;
  double v15;
  float64x2_t v16;
  double v17;
  int8x16_t v18;
  int8x16_t v19;
  float32x4_t v20;
  float32x4_t result;
  float32x4_t v22;
  float32x4_t v23;
  float v24;
  float v25;
  BOOL v26;
  float v27;
  float v28;
  float v29;

  v9 = vmulq_f32(a2, (float32x4_t)xmmword_1924921A0);
  v29 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0];
  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v11 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v12) = *(_DWORD *)(a1 + 28);
  v13.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v14.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v12, COERCE_FLOAT(*DC));
  *(float *)&v15 = *(float *)(a1 + 24) + *(float *)&v11;
  *(float *)v16.f64 = *(float *)v13.i32 + *(float *)v14.i32;
  *((float *)&v15 + 1) = *(float *)v13.i32 + *(float *)v14.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v15, v16, v11, v12, v14, v13, v17, v18);
  v20 = a2;
  v20.f32[3] = v29;
  result = vmaxnmq_f32((float32x4_t)vbicq_s8(v19, (int8x16_t)vcltzq_f32(v20)), (float32x4_t)0);
  v22 = vmulq_n_f32(a2, result.f32[3] / fmaxf(v29, 0.000001));
  v22.i32[3] = 0;
  v23 = vmaxnmq_f32(v22, (float32x4_t)0);
  v24 = (v29 - (a3 + a4 * -0.5)) / a4;
  if (v24 <= 1.0)
    v25 = (v29 - (a3 + a4 * -0.5)) / a4;
  else
    v25 = 1.0;
  v26 = v24 < 0.0;
  v27 = 0.0;
  if (!v26)
    v27 = v25;
  v28 = -((v27 * -2.0 + 3.0) * v27) * v27 + 1.0;
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(result, 1.0 - (float)(v28 * a5)), v23, v28 * a5).u64[0];
  result.i32[3] = a2.i32[3];
  return result;
}

void CI::f4_s_s_f_f_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(_QWORD *, __n128, __n128, float, float, float);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __int128 v20;

  v9 = a1[6];
  v10 = (double (*)(_QWORD *, __n128, __n128, float, float, float))a1[3];
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_QWORD *)(v9 + 80);
  v17 = *(_QWORD *)(v9 + 104);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
  v18 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v14);
  v19 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v20 = v10(a1, *v19, *v18, *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16), *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

float32x2_t cikernel::_paddedTile(CI *a1, int8x16_t a2)
{
  float32x2_t v2;

  v2 = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), *(float32x2_t *)CI::getDC(a1));
  __asm { FMOV            V1.2S, #1.0 }
  return vadd_f32(vmul_f32(*(float32x2_t *)a2.i8, vminnm_f32(vsub_f32(v2, vrndm_f32(v2)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu))), _D1);
}

void sub_19234E464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,void (*a43)(char *))
{
  a43(&a41);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__15(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

Class ___ZL33getVNDetectRectanglesRequestClassv_block_invoke(uint64_t a1)
{
  Class result;

  VisionLibrary();
  result = objc_getClass("VNDetectRectanglesRequest");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL33getVNDetectRectanglesRequestClassv_block_invoke_cold_1();
  getVNDetectRectanglesRequestClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class ___ZL29getVNImageRequestHandlerClassv_block_invoke_0(uint64_t a1)
{
  Class result;

  VisionLibrary();
  result = objc_getClass("VNImageRequestHandler");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL29getVNImageRequestHandlerClassv_block_invoke_cold_1();
  getVNImageRequestHandlerClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

double cikernel::_rectangle(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  int32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v15;
  double result;
  uint64_t v20;

  v20 = *(_QWORD *)CI::getDC(a1);
  v4.i64[0] = v20;
  *(double *)v5.i64 = vec2::get_xxy((vec2 *)&v20, v4);
  v6 = vaddq_f32(a3, vmulq_f32(a2, v5));
  __asm { FMOV            V2.4S, #1.0 }
  v12 = vminnmq_f32(vmaxnmq_f32(vminnmq_f32(vmaxnmq_f32(vmaxnmq_f32(v6, (float32x4_t)vrev64q_s32((int32x4_t)v6)), (float32x4_t)0), _Q2), (float32x4_t)0), _Q2);
  v13.i64[0] = 0xC0000000C0000000;
  v13.i64[1] = 0xC0000000C0000000;
  __asm { FMOV            V4.4S, #3.0 }
  v15 = vsubq_f32(_Q2, vmulq_f32(vmulq_f32(v12, v12), vmlaq_f32(_Q4, v13, v12)));
  *(_QWORD *)&result = vmulq_n_f32(a4, vmulq_laneq_f32(v15, v15, 2).f32[0]).u64[0];
  return result;
}

void CI::f4_f4_f4_clr(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, __n128);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  __n128 *v17;
  __n128 *v18;
  __int128 v19;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v17 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v15);
  v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v19 = v11(a1, *v18, *v17, *((__n128 *)a2 + 4 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_roundedrect(CI *a1, int8x16_t a2, double a3, float32x4_t a4)
{
  float32x2_t *DC;
  float32x2_t v5;
  float32x2_t v6;
  float v7;
  float v8;
  BOOL v9;
  float v10;
  double result;

  DC = (float32x2_t *)CI::getDC(a1);
  v5 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0);
  v6 = vmaxnm_f32(vminnm_f32(vsub_f32(*DC, vadd_f32(*(float32x2_t *)a2.i8, v5)), 0), vsub_f32(*DC, vsub_f32((float32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), v5)));
  v7 = (float)(*(float *)&a3 - sqrtf(vaddv_f32(vmul_f32(v6, v6)))) + 0.5;
  v8 = 1.0;
  if (v7 <= 1.0)
    v8 = v7;
  v9 = v7 < 0.0;
  v10 = 0.0;
  if (!v9)
    v10 = v8;
  *(_QWORD *)&result = vmulq_n_f32(a4, v10).u64[0];
  return result;
}

void CI::f4_f4_f_clr(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, float, __n128);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __n128 *v16;
  __int128 v17;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, float, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v16 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v16 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v17 = v11(a1, *v16, *((float *)a2 + 16 * v14), *((__n128 *)a2 + 4 * v15));
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

double cikernel::_blurredrect(CI *a1, int8x16_t a2, float a3, float32x4_t a4)
{
  float32x2_t *DC;
  double v6;
  float32x2_t v7;
  float32x2_t v8;
  float32x2_t v14;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  double result;

  DC = (float32x2_t *)CI::getDC(a1);
  v6 = a3 * 2.4;
  *(float *)&v6 = v6;
  v7 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v6, 0);
  *(float *)&v6 = *(float *)&v6 + *(float *)&v6;
  v8 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v6, 0);
  __asm { FMOV            V6.2S, #1.0 }
  v14 = vminnm_f32(vmaxnm_f32(vdiv_f32(vsub_f32(*DC, vsub_f32(*(float32x2_t *)a2.i8, v7)), v8), 0), _D6);
  __asm
  {
    FMOV            V16.2S, #6.0
    FMOV            V18.2S, #-15.0
    FMOV            V17.2S, #10.0
  }
  v18 = vmul_f32(vmul_f32(v14, vmul_f32(v14, v14)), vadd_f32(vmul_f32(v14, vadd_f32(vmul_f32(v14, _D16), _D18)), _D17));
  v19 = vminnm_f32(vmaxnm_f32(vdiv_f32(vsub_f32(vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), v7), *DC), v8), 0), _D6);
  v20 = vmul_f32(vmul_f32(v19, vmul_f32(v19, v19)), vadd_f32(vmul_f32(v19, vadd_f32(vmul_f32(v19, _D16), _D18)), _D17));
  *(_QWORD *)&result = vmulq_n_f32(a4, vmul_lane_f32(vmul_f32(vmul_lane_f32(v18, v18, 1), v20), v20, 1).f32[0]).u64[0];
  return result;
}

double cikernel::_roundedstroke(CI *a1, int8x16_t a2, double a3, double a4, float32x4_t a5)
{
  float32x2_t *DC;
  float32x2_t v6;
  float32x2_t v7;
  float32x2_t v8;
  int32x2_t v9;
  float v10;
  float v11;
  BOOL v12;
  float v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float v17;
  float32x4_t v18;
  double result;

  DC = (float32x2_t *)CI::getDC(a1);
  v6 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0);
  v7 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  v8 = vmaxnm_f32(vminnm_f32(vsub_f32(*DC, vadd_f32(*(float32x2_t *)a2.i8, v6)), 0), vsub_f32(*DC, vsub_f32(v7, v6)));
  v9.i32[1] = HIDWORD(a3);
  v10 = (float)(*(float *)&a3 - sqrtf(vaddv_f32(vmul_f32(v8, v8)))) + 0.5;
  if (v10 <= 1.0)
    v11 = v10;
  else
    v11 = 1.0;
  v12 = v10 < 0.0;
  v13 = 0.0;
  *(float *)v9.i32 = fmaxf(*(float *)&a3 - *(float *)&a4, 0.5);
  v14 = (float32x2_t)vdup_lane_s32(v9, 0);
  if (v12)
    v11 = 0.0;
  v15 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a4, 0);
  v16 = vmaxnm_f32(vminnm_f32(vsub_f32(*DC, vadd_f32(v15, vadd_f32(*(float32x2_t *)a2.i8, v14))), 0), vsub_f32(*DC, vsub_f32(vsub_f32(v7, v14), v15)));
  v17 = (float)(*(float *)v9.i32 - sqrtf(vaddv_f32(vmul_f32(v16, v16)))) + 0.5;
  if (v17 <= 1.0)
    v13 = 1.0 - v17;
  v18 = vmulq_n_f32(a5, v11);
  if (v17 < 0.0)
    v13 = 1.0;
  *(_QWORD *)&result = vmulq_n_f32(v18, v13).u64[0];
  return result;
}

void CI::f4_f4_f_f_clr(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, float, float, __n128);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 *v17;
  __int128 v18;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, float, float, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_QWORD *)(v10 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
  v17 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v17 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v18 = v11(a1, *v17, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *((__n128 *)a2 + 4 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_rectstroke(CI *a1, int8x16_t a2, int32x2_t a3, float32x4_t a4)
{
  float32x2_t *DC;
  float32x2_t v5;
  float32x2_t v6;
  float32x2_t v7;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  double result;

  DC = (float32x2_t *)CI::getDC(a1);
  v5 = vadd_f32(*(float32x2_t *)a2.i8, (float32x2_t)0xBF000000BF000000);
  v6 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), (float32x2_t)0x3F0000003F000000);
  v7 = vminnm_f32(vsub_f32(*DC, v5), vsub_f32(v6, *DC));
  __asm { FMOV            V5.2S, #1.0 }
  v13 = (float32x2_t)vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v7, _D5), (int8x8_t)_D5, (int8x8_t)v7), (int8x8_t)vcltz_f32(v7));
  v14 = (float32x2_t)vdup_lane_s32(a3, 0);
  v15 = vminnm_f32(vsub_f32(*DC, vadd_f32(v14, v5)), vsub_f32(vsub_f32(v6, v14), *DC));
  v16 = (float32x2_t)vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v15, _D5), (int8x8_t)_D5, (int8x8_t)v15), (int8x8_t)vcltz_f32(v15));
  *(_QWORD *)&result = vmulq_n_f32(vmulq_n_f32(a4, vmul_lane_f32(v13, v13, 1).f32[0]), 1.0 - vmul_lane_f32(v16, v16, 1).f32[0]).u64[0];
  return result;
}

void sub_192351110(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Unwind_Resume(exception_object);
}

void _ZZZ33__CIRedEyeCorrection_outputImage_EUb_EN13SignpostTimerD1Ev(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  v2 = ci_signpost_log_render();
  v3 = *((_QWORD *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "CIRedEyeCorrection_processor", (const char *)&unk_192520C83, v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1923511C0(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void clearOutput(void *a1)
{
  int v2;
  double v3;
  uint64_t v4;
  double v5;

  v2 = CI::format_bytes_per_pixel(objc_msgSend(a1, "format"));
  objc_msgSend(a1, "region");
  v4 = objc_msgSend(a1, "bytesPerRow") * ((int)v3 - 1);
  objc_msgSend(a1, "region");
  bzero((void *)objc_msgSend(a1, "baseAddress"), v4 + (int)v5 * (uint64_t)v2);
}

uint64_t CIRedEyeUtilsSizeFromScale(float a1)
{
  uint64_t v1;

  v1 = 90;
  if (a1 < 90.0)
    v1 = 35;
  if (a1 >= 35.0)
    return v1;
  else
    return 0;
}

float stretch(float a1, float a2, float a3, float a4, float a5)
{
  float result;

  result = a4 + (float)((float)((float)(a1 - a2) / (float)(a3 - a2)) * (float)(a5 - a4));
  if (result >= a5)
    result = a5;
  if (result <= a4)
    return a4;
  return result;
}

float interpolate(float result, float a2, float a3)
{
  float v3;
  float v4;
  float v5;

  v3 = result + (float)(a3 * (float)(a2 - result));
  if (a2 >= result)
    v4 = result;
  else
    v4 = a2;
  if (a2 >= result)
    result = a2;
  if (v3 <= v4)
    v5 = v4;
  else
    v5 = v3;
  if (v5 < result)
    return v5;
  return result;
}

const __CFString *tagForEye(uint64_t a1)
{
  const __CFString *v1;

  v1 = CFSTR("L");
  if (a1 == 35)
    v1 = CFSTR("M");
  if (a1)
    return v1;
  else
    return CFSTR("S");
}

CIImage *refilter(CIImage *a1, CIImage *a2, float a3, float a4)
{
  double v6;
  CIImage *v7;
  _QWORD v9[3];
  _QWORD v10[4];

  v10[3] = *MEMORY[0x1E0C80C00];
  if (a3 > 0.0 && a4 > 0.0)
  {
    v10[0] = a2;
    v9[0] = CFSTR("inputSource");
    v9[1] = CFSTR("inputSigmaSpace");
    v10[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:");
    v9[2] = CFSTR("inputSigmaRange");
    *(float *)&v6 = a4;
    v10[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v6);
    v7 = -[CIImage imageByApplyingFilter:withInputParameters:](a1, "imageByApplyingFilter:withInputParameters:", CFSTR("CICheapBilateral"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v10, v9, 3));
    -[CIImage extent](a1, "extent");
    return -[CIImage imageByCroppingToRect:](v7, "imageByCroppingToRect:");
  }
  return a1;
}

unint64_t radialFillRGBA8(void *a1, void *a2, int a3, unsigned int a4, unint64_t a5, double a6, double a7)
{
  double v13;
  double v14;
  double v15;
  void *v16;
  double v17;
  double v18;
  double v19;
  double v20;
  void *v21;
  double v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  float v29;
  int v30;
  int v31;
  int v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  int v40;
  unint64_t result;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  unint64_t v52;
  int v53;
  int v54;
  int v55;
  int v56;
  unint64_t v57;
  int v58;
  int v59;
  int v60;
  unint64_t v61;
  int v62;
  int v63;
  int v64;
  int v65;
  unint64_t v66;
  int v67;
  int v70;
  int v71;
  int v72;

  objc_msgSend(a1, "region");
  v14 = v13;
  objc_msgSend(a2, "region");
  if (v14 >= v15)
    v16 = a2;
  else
    v16 = a1;
  objc_msgSend(v16, "region");
  v71 = (int)v17;
  objc_msgSend(a1, "region");
  v19 = v18;
  objc_msgSend(a2, "region");
  if (v19 >= v20)
    v21 = a2;
  else
    v21 = a1;
  objc_msgSend(v21, "region");
  v70 = (int)v22;
  v23 = objc_msgSend(a1, "bytesPerRow");
  v24 = objc_msgSend(a2, "bytesPerRow");
  v25 = objc_msgSend(a1, "baseAddress");
  v26 = objc_msgSend(a2, "baseAddress");
  v27 = (int)a6;
  v28 = (int)a7;
  v29 = sqrtf((float)a5);
  v30 = (int)(v29 + v29);
  if ((int)a6 >= (int)a7)
    v31 = (int)a7;
  else
    v31 = (int)a6;
  if (v31 < v30)
    v30 = v31;
  v32 = v71 + ~v27;
  if (v32 >= v70 + ~v28)
    v32 = v70 + ~v28;
  if (v32 < v30)
    v30 = v32;
  v72 = v30;
  objc_msgSend(a1, "region");
  v34 = v33;
  objc_msgSend(a2, "region");
  v36 = v35;
  objc_msgSend(a1, "region");
  v38 = v37;
  objc_msgSend(a2, "region");
  if (v72 < 1)
    return 0;
  v40 = 0;
  result = 0;
  v42 = a3 + (v28 + (int)(v38 - v39)) * v24 + 4 * (v27 + (int)(v34 - v36));
  v43 = a3 + v28 * v23 + 4 * v27;
  v44 = 1;
  v45 = v43;
  v46 = v42;
  v47 = v43;
  v48 = v42;
  do
  {
    v49 = v44;
    v50 = v47;
    v51 = v48;
    do
    {
      v52 = result;
      v53 = *(unsigned __int8 *)(v25 + v50) > a4;
      if (*(unsigned __int8 *)(v25 + v50) > a4)
        ++result;
      if (v52 >= a5)
        v53 = 0;
      *(_BYTE *)(v26 + v51) = v53 << 31 >> 31;
      v51 += v24;
      v50 += v23;
      --v49;
    }
    while (v49);
    v54 = v44;
    v55 = v45;
    v56 = v46;
    if (result > a5)
      break;
    do
    {
      v57 = result;
      v58 = *(unsigned __int8 *)(v25 + v55) > a4;
      if (*(unsigned __int8 *)(v25 + v55) > a4)
        ++result;
      if (v57 >= a5)
        v58 = 0;
      *(_BYTE *)(v26 + v56) = v58 << 31 >> 31;
      v56 += v24;
      v55 += v23;
      --v54;
    }
    while (v54);
    if (result > a5)
      break;
    v59 = 0;
    v60 = v44;
    do
    {
      v61 = result;
      v62 = *(unsigned __int8 *)(v25 + v47 + v59) > a4;
      if (*(unsigned __int8 *)(v25 + v47 + v59) > a4)
        ++result;
      if (v61 >= a5)
        v62 = 0;
      *(_BYTE *)(v26 + v48 + v59) = v62 << 31 >> 31;
      v59 += 4;
      --v60;
    }
    while (v60);
    v63 = v44;
    v64 = v42;
    v65 = v43;
    if (result > a5)
      break;
    do
    {
      v66 = result;
      v67 = *(unsigned __int8 *)(v25 + v65) > a4;
      if (*(unsigned __int8 *)(v25 + v65) > a4)
        ++result;
      if (v66 >= a5)
        v67 = 0;
      *(_BYTE *)(v26 + v64) = v67 << 31 >> 31;
      v65 += 4;
      v64 += 4;
      --v63;
    }
    while (v63);
    ++v40;
    v48 += -4 - v24;
    v47 += -4 - v23;
    v44 += 2;
    v46 += 4 - v24;
    v45 += 4 - v23;
    v43 += v23 - 4;
    v42 += v24 - 4;
  }
  while (result <= a5 && v40 != v72);
  return result;
}

uint64_t radialFillRGBA8_circular(void *a1, void *a2, int a3, unsigned int a4, unint64_t a5, float a6, double a7, double a8)
{
  double v14;
  double v15;
  double v16;
  void *v17;
  double v18;
  int v19;
  double v20;
  double v21;
  double v22;
  void *v23;
  double v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  uint64_t result;
  double v45;
  uint64_t v46;
  int v47;
  int v48;
  int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _BOOL4 v55;
  char v56;
  unsigned int v57;
  BOOL v58;
  char v59;
  int v60;
  unsigned int v61;
  BOOL v62;
  char v63;
  unsigned int v64;
  BOOL v65;
  int v66;
  uint64_t v67;
  int v68;
  int v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  int v77;
  int v78;
  uint64_t v79;
  unsigned int v80;
  BOOL v81;
  char v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  unsigned int v88;
  BOOL v89;
  char v90;
  uint64_t v91;
  int v92;
  unsigned int v93;
  BOOL v94;
  char v95;
  int v96;
  int v97;
  int v98;
  unsigned int v99;
  BOOL v100;
  char v101;
  uint64_t v102;
  uint64_t v103;
  unsigned int v104;
  BOOL v105;
  char v106;
  uint64_t v107;
  uint64_t v108;
  unsigned int v109;
  BOOL v110;
  char v111;
  uint64_t v112;
  unsigned int v113;
  BOOL v114;
  char v115;
  unsigned int v116;
  BOOL v117;
  char v118;
  BOOL v119;
  int v120;
  int v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  uint64_t v134;
  int v135;
  uint64_t v136;
  int v138;
  int v139;
  uint64_t v140;
  uint64_t v141;
  int v143;

  objc_msgSend(a1, "region");
  v15 = v14;
  objc_msgSend(a2, "region");
  if (v15 >= v16)
    v17 = a2;
  else
    v17 = a1;
  objc_msgSend(v17, "region");
  v19 = (int)v18;
  objc_msgSend(a1, "region");
  v21 = v20;
  objc_msgSend(a2, "region");
  if (v21 >= v22)
    v23 = a2;
  else
    v23 = a1;
  objc_msgSend(v23, "region");
  v25 = (int)v24;
  v26 = objc_msgSend(a1, "bytesPerRow");
  v27 = objc_msgSend(a2, "bytesPerRow");
  v28 = objc_msgSend(a1, "baseAddress");
  v29 = objc_msgSend(a2, "baseAddress");
  v30 = (int)a7;
  v31 = (float)a5;
  v32 = sqrtf((float)a5);
  v33 = (int)(v32 + v32);
  if ((int)v30 >= (int)a8)
    v34 = (int)a8;
  else
    v34 = (int)a7;
  if (v34 < v33)
    v33 = v34;
  v35 = v19 + ~(_DWORD)v30;
  v36 = (int)a8;
  if (v35 >= v25 + ~(int)a8)
    v35 = v25 + ~(int)a8;
  if (v35 >= v33)
    v37 = v33;
  else
    v37 = v35;
  objc_msgSend(a1, "region");
  v39 = v38;
  objc_msgSend(a2, "region");
  v41 = v40;
  objc_msgSend(a1, "region");
  v43 = v42;
  result = objc_msgSend(a2, "region");
  v132 = v37;
  if ((int)v37 >= 1)
  {
    v46 = 0;
    v47 = 0;
    v48 = (int)(v39 - v41);
    v49 = (int)(v43 - v45);
    v50 = v27;
    v51 = v26;
    v52 = v26;
    v53 = a3;
    v131 = 4 * (int)v30 + (uint64_t)a3;
    v130 = 4 * (v48 + (int)v30) + (uint64_t)a3;
    v127 = a3 + v27 * (uint64_t)(v49 + v36);
    v128 = a3 + (int)v52 * (uint64_t)v36;
    v126 = v49;
    v54 = v36 + (uint64_t)v49;
    v129 = v36;
    v124 = v28 + (v36 - 1) * v52;
    v125 = v29 + (v54 - 1) * v27;
    v123 = v29 + v27 * v54 + v27;
    v122 = v28 + v52 + (int)v52 * (uint64_t)v36;
    v121 = 4 * v30 - 4;
    v120 = 4 * v30 + 4;
    v139 = v36;
    v138 = 4 * v48;
    v136 = -(uint64_t)v27;
    v143 = v48;
    v135 = v49;
    v141 = v28;
    v140 = v29;
    do
    {
      v55 = *(unsigned __int8 *)(v28 + v131 + v52 * (v46 + v129)) > a4;
      if (*(unsigned __int8 *)(v28 + v131 + v52 * (v46 + v129)) <= a4)
        v56 = 0;
      else
        v56 = -1;
      *(_BYTE *)(v29 + v130 + v50 * (v46 + v129 + v126)) = v56;
      v57 = *(unsigned __int8 *)(v28 + v131 + v52 * (v129 - v46));
      v58 = v57 > a4;
      if (v57 <= a4)
        v59 = 0;
      else
        v59 = -1;
      *(_BYTE *)(v29 + v130 + v50 * (v129 - v46 + v126)) = v59;
      if (v58)
        v60 = v55 + 1;
      else
        v60 = v55;
      v61 = *(unsigned __int8 *)(v28 + v128 + 4 * ((int)v30 - (int)v46));
      v62 = v61 > a4;
      if (v61 <= a4)
        v63 = 0;
      else
        v63 = -1;
      *(_BYTE *)(v29 + v127 + 4 * ((int)v30 - (int)v46 + v48)) = v63;
      if (v62)
        ++v60;
      v64 = *(unsigned __int8 *)(v28 + v128 + 4 * ((int)v46 + (int)v30));
      v65 = v64 > a4;
      if (v64 <= a4)
        result = 0;
      else
        result = 0xFFFFFFFFLL;
      *(_BYTE *)(v29 + v127 + 4 * ((int)v46 + (int)v30 + v48)) = result;
      if (v65)
        v66 = v60 + 1;
      else
        v66 = v60;
      v134 = v46;
      v133 = v47;
      if (v46)
      {
        v67 = 0;
        LODWORD(result) = 1 - v46;
        v68 = 3;
        v70 = v120;
        v69 = v121;
        v72 = v122;
        v71 = v123;
        v74 = v124;
        v73 = v125;
        v75 = v46;
        v76 = -2 * v46;
        do
        {
          v77 = v76 + 2;
          if ((int)result >= 0)
            v76 += 2;
          v75 += ~(_DWORD)result >> 31;
          v78 = v75 + v139;
          v79 = v53 + v70;
          v80 = *(unsigned __int8 *)(v141 + v79 + (int)v52 * (uint64_t)(v75 + v139));
          v81 = v80 > a4;
          if (v80 <= a4)
            v82 = 0;
          else
            v82 = -1;
          v83 = v78 + v135;
          v84 = v53 + v138 + v70;
          v85 = v30;
          *(_BYTE *)(v140 + v84 + (int)v50 * (uint64_t)(v78 + v135)) = v82;
          if (v81)
            v86 = v66 + 1;
          else
            v86 = v66;
          v87 = v53 + v69;
          v88 = *(unsigned __int8 *)(v141 + v87 + (int)v52 * (uint64_t)v78);
          v89 = v88 > a4;
          if (v88 <= a4)
            v90 = 0;
          else
            v90 = -1;
          v91 = v53 + v138 + v69;
          *(_BYTE *)(v140 + v91 + (int)v50 * (uint64_t)v83) = v90;
          if (v89)
            ++v86;
          v92 = v139 - v75;
          v93 = *(unsigned __int8 *)(v141 + v79 + (int)v52 * (uint64_t)(v139 - v75));
          v94 = v93 > a4;
          if (v93 <= a4)
            v95 = 0;
          else
            v95 = -1;
          v96 = v92 + v135;
          *(_BYTE *)(v140 + v84 + (int)v50 * (uint64_t)(v92 + v135)) = v95;
          v97 = v77 & ~((int)result >> 31);
          ++v67;
          v98 = v68 + result;
          if (v94)
            ++v86;
          v99 = *(unsigned __int8 *)(v141 + v87 + (int)v52 * (uint64_t)v92);
          v100 = v99 > a4;
          if (v99 <= a4)
            v101 = 0;
          else
            v101 = -1;
          v102 = v91 + (int)v50 * (uint64_t)v96;
          v30 = v85;
          *(_BYTE *)(v140 + v102) = v101;
          if (v100)
            ++v86;
          v103 = v53 + 4 * (v75 + (int)v85);
          v104 = *(unsigned __int8 *)(v72 + v103);
          v105 = v104 > a4;
          if (v104 <= a4)
            v106 = 0;
          else
            v106 = -1;
          v107 = v53 + 4 * (v75 + (int)v85 + v143);
          *(_BYTE *)(v71 + v107) = v106;
          if (v105)
            ++v86;
          v108 = v53 + 4 * ((int)v85 - v75);
          v109 = *(unsigned __int8 *)(v72 + v108);
          v110 = v109 > a4;
          if (v109 <= a4)
            v111 = 0;
          else
            v111 = -1;
          v112 = v53 + 4 * ((int)v85 - v75 + v143);
          *(_BYTE *)(v71 + v112) = v111;
          result = (v98 + v97);
          if (v110)
            ++v86;
          v113 = *(unsigned __int8 *)(v74 + v103);
          v114 = v113 > a4;
          if (v113 <= a4)
            v115 = 0;
          else
            v115 = -1;
          *(_BYTE *)(v73 + v107) = v115;
          if (v114)
            ++v86;
          v116 = *(unsigned __int8 *)(v74 + v108);
          v117 = v116 > a4;
          if (v116 <= a4)
            v118 = 0;
          else
            v118 = -1;
          *(_BYTE *)(v73 + v112) = v118;
          if (v117)
            v66 = v86 + 1;
          else
            v66 = v86;
          v73 += v136;
          v74 -= v51;
          v71 += v50;
          v72 += v52;
          v69 -= 4;
          v70 += 4;
          v68 += 2;
        }
        while (v67 < v75);
      }
      v47 = v66 + v133;
      v46 = v134 + 1;
      v119 = v66 + v133 > (int)(float)(v31 * a6) || v46 == v132;
      v48 = (int)(v39 - v41);
      v28 = v141;
      v29 = v140;
    }
    while (!v119);
  }
  return result;
}

void radialSplatR8(unsigned __int8 *a1, unsigned __int8 *a2, int a3, int a4, unint64_t a5, uint64_t a6, unint64_t a7, CGPoint a8)
{
  int x;
  int y;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unsigned __int8 *v21;
  int v22;
  uint64_t v23;
  int v24;
  unsigned __int8 *v25;
  int v26;

  x = (int)a8.x;
  y = (int)a8.y;
  LODWORD(v10) = (int)sqrt((double)a7 / 3.14159265);
  if ((int)a8.x >= (int)a8.y)
    v11 = (int)a8.y;
  else
    v11 = (int)a8.x;
  if (v11 >= (int)v10)
    v11 = v10;
  LODWORD(v12) = ~x + a3;
  v13 = ~y + a4;
  if ((int)v12 >= v13)
    v14 = ~y + a4;
  else
    v14 = ~x + a3;
  if (v14 >= v11)
    v15 = v11;
  else
    v15 = v14;
  if ((v15 & 0x80000000) == 0)
  {
    v16 = v15 * v15;
    v17 = x;
    v18 = -v15;
    v19 = y;
    v20 = v15 + 1;
    if (v19 < x)
      v17 = v19;
    if (v17 >= (int)v10)
      v10 = (int)v10;
    else
      v10 = v17;
    if (v10 >= v13)
      v10 = v13;
    if (v10 >= (int)v12)
      v12 = (int)v12;
    else
      v12 = v10;
    v21 = &a2[a6 * (v19 - v12) + x];
    v22 = ~(v15 + v12);
    v23 = v18;
    do
    {
      v24 = v22;
      v25 = v21;
      v26 = v18;
      do
      {
        if (v16 >= (int)v23 * (int)v23 + v26 * v26)
          v25[v23] = -1;
        ++v26;
        v25 += a6;
      }
      while (!__CFADD__(v24++, 1));
      ++v23;
    }
    while (v20 != (_DWORD)v23);
  }
}

float findPercentileNonZero(unint64_t *a1, float a2, unint64_t a3, unint64_t a4)
{
  float result;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t i;
  unint64_t v11;
  unint64_t v12;
  float v13;

  result = 0.0;
  if (a4)
  {
    if (a4 == 1)
    {
      v6 = 0;
      v7 = 0;
      v8 = (unint64_t)(float)(a2 * 0.0);
      v12 = 1;
    }
    else
    {
      v9 = 0;
      for (i = 1; i != a4; ++i)
        v9 += a1[i];
      v8 = (unint64_t)(float)((float)v9 * a2);
      v7 = 0;
      v6 = 0;
      v12 = 1;
      while (1)
      {
        v11 = a1[v12];
        v7 += v11;
        if (v7 >= v8)
          break;
        v6 += v11;
        if (a4 == ++v12)
        {
          v12 = a4;
          break;
        }
      }
    }
    if (v8)
    {
      v13 = (float)(v7 - v6);
      if (v13 > 0.00001)
      {
        result = (float)((float)((float)((float)(v8 - v6) / v13) + (float)v12) * (float)a3) / (float)a4;
        if (result > (float)a3)
          result = (float)a3;
        if (result < 0.0)
          return 0.0;
      }
    }
  }
  return result;
}

BOOL computeDensity(unsigned __int8 *a1, unsigned int a2, int a3, int a4, uint64_t a5, unsigned int a6, CGPoint a7, int a8, float *a9)
{
  int x;
  int y;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  float v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  _BOOL8 result;

  x = (int)a7.x;
  y = (int)a7.y;
  LODWORD(v11) = (int)a7.x - 1;
  v12 = (int)a7.y - 1;
  if ((int)v11 >= v12)
    v13 = (int)a7.y - 1;
  else
    v13 = (int)a7.x - 1;
  if (v13 >= a8)
    v13 = a8;
  v14 = ~x + a3;
  v15 = ~y + a4;
  if (v14 >= v15)
    v16 = ~y + a4;
  else
    v16 = v14;
  if (v16 < v13)
    v13 = v16;
  v17 = 0.0;
  if (v13 >= 2)
  {
    v18 = 0;
    v19 = 0;
    v20 = a2;
    v21 = v15;
    if (v15 >= (uint64_t)v14)
      v21 = v14;
    v22 = 4 * x;
    if (v21 >= v12)
      v21 = v12;
    if (v21 >= (int)v11)
      v11 = (int)v11;
    else
      v11 = v21;
    v23 = a8;
    if (v11 < a8)
      v23 = v11;
    v24 = v22 - 4 * v23;
    v25 = ~(v13 + v23);
    v26 = -v13;
    do
    {
      v27 = v25;
      v28 = v24;
      v29 = -v13;
      do
      {
        if (v13 * v13 > (v26 * v26 + v29 * v29))
        {
          if (a1[v20 + (v26 + y) * a5 + v28] > a6)
            ++v19;
          ++v18;
        }
        ++v29;
        v28 += 4;
      }
      while (!__CFADD__(v27++, 1));
      ++v26;
    }
    while (v13 + 1 != (_DWORD)v26);
    if (v18)
      v17 = (float)v19 / (float)v18;
    else
      v17 = 1.0;
  }
  result = v13 > 1;
  *a9 = v17;
  return result;
}

uint64_t clipRepair(void *a1, void *a2, int a3, unsigned int a4)
{
  double v8;
  double v9;
  double v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  uint64_t result;
  double v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  unsigned int v29;

  objc_msgSend(a1, "region");
  v9 = v8;
  objc_msgSend(a1, "region");
  v11 = (int)v10;
  v12 = objc_msgSend(a1, "bytesPerRow");
  v13 = objc_msgSend(a2, "bytesPerRow");
  v14 = objc_msgSend(a1, "baseAddress");
  v15 = objc_msgSend(a2, "baseAddress");
  objc_msgSend(a1, "region");
  v17 = v16;
  objc_msgSend(a2, "region");
  v19 = v18;
  objc_msgSend(a1, "region");
  v21 = v20;
  result = objc_msgSend(a2, "region");
  if (v11 >= 1)
  {
    v24 = 0;
    v25 = (int)(v21 - v23) * v13 + 4 * (int)(v17 - v19) + a3;
    do
    {
      v26 = (int)v9;
      v27 = v25;
      v28 = a3;
      if ((int)v9 >= 1)
      {
        do
        {
          v29 = *(unsigned __int8 *)(v14 + v28);
          if (v29 <= a4)
            LOBYTE(v29) = 0;
          *(_BYTE *)(v15 + v27) = v29;
          v28 += 4;
          v27 += 4;
          --v26;
        }
        while (v26);
      }
      ++v24;
      a3 += v12;
      v25 += v13;
    }
    while (v24 != v11);
  }
  return result;
}

uint64_t sampleUnderCentroid(void *a1, double a2, double a3, float a4)
{
  double v8;
  int v9;
  double v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *v20;
  uint64_t v21;
  unsigned __int8 *v22;
  int v23;
  int v25[256];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  objc_msgSend(a1, "region");
  v9 = (int)v8;
  v11 = (int)v10;
  v12 = objc_msgSend(a1, "bytesPerRow");
  v13 = objc_msgSend(a1, "baseAddress");
  if (v9 >= v11)
    v14 = v11;
  else
    v14 = v9;
  v15 = (int)(float)((float)v14 * a4);
  bzero(v25, 0x400uLL);
  v16 = ((int)a3 - v15) & ~(((int)a3 - v15) >> 31);
  LODWORD(v17) = v15 + (int)a3;
  if ((int)v17 >= v11)
    v17 = v11;
  else
    v17 = v17;
  if ((int)v16 < (int)v17)
  {
    LODWORD(v18) = v15 + (int)a2;
    if ((int)v18 >= v9)
      v18 = v9;
    else
      v18 = v18;
    v19 = ((int)a2 - v15) & ~(((int)a2 - v15) >> 31);
    v20 = (unsigned __int8 *)(v13 + v19 + v12 * v16);
    do
    {
      v21 = v18 - v19;
      v22 = v20;
      if ((int)v19 < (int)v18)
      {
        do
        {
          v23 = *v22++;
          ++v25[v23];
          --v21;
        }
        while (v21);
      }
      ++v16;
      v20 += v12;
    }
    while (v16 != v17);
  }
  percentile(v25, 0.25);
  return percentile(v25, 0.75);
}

uint64_t percentile(int *a1, float a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  double v5;
  int v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;

  v2 = 0;
  v3 = 0;
  do
    v3 += a1[v2++];
  while (v2 != 255);
  v4 = 0;
  v5 = a2;
  if (v5 > 1.0)
    v5 = 1.0;
  if (v5 < 0.0)
    v5 = 0.0;
  v6 = (int)(v5 * (double)v3);
  v7 = (float)v6;
  v8 = 0.0;
  v9 = 0.0;
  while (1)
  {
    v10 = (float)a1[v4];
    v8 = v8 + v10;
    if (v8 >= v7)
      break;
    v9 = v9 + v10;
    if (++v4 == 255)
    {
      v11 = 255.0;
      goto LABEL_12;
    }
  }
  v11 = (float)(int)v4;
LABEL_12:
  v12 = 0.0;
  if (v6 >= 1)
  {
    v13 = v8 - v9;
    if (v13 > 0.0)
      v12 = (float)(v7 - v9) / v13;
  }
  v14 = roundf(v12 + v11);
  if (v14 > 255.0)
    return 255;
  if (v14 >= 0.0)
    return (int)v14;
  return 0;
}

uint64_t calculateMeans(void *a1, void *a2, int a3, double a4, double a5)
{
  double v10;
  double v11;
  double v12;
  void *v13;
  double v14;
  int v15;
  double v16;
  double v17;
  double v18;
  void *v19;
  double v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t result;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  unsigned __int8 *v35;
  float v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  unsigned __int8 *v40;
  int v41;
  unsigned int v42;
  float v43;

  objc_msgSend(a2, "region");
  v11 = v10;
  objc_msgSend(a1, "region");
  if (v11 >= v12)
    v13 = a1;
  else
    v13 = a2;
  objc_msgSend(v13, "region");
  v15 = (int)v14;
  objc_msgSend(a2, "region");
  v17 = v16;
  objc_msgSend(a1, "region");
  if (v17 >= v18)
    v19 = a1;
  else
    v19 = a2;
  objc_msgSend(v19, "region");
  v21 = (int)v20;
  v22 = objc_msgSend(a1, "bytesPerRow");
  v23 = objc_msgSend(a2, "bytesPerRow");
  v24 = objc_msgSend(a1, "baseAddress");
  result = objc_msgSend(a2, "baseAddress");
  if (v15 >= v21)
    v26 = v21;
  else
    v26 = v15;
  v27 = (int)((double)v26 * 0.3);
  v28 = ((int)a5 - v27) & ~(((int)a5 - v27) >> 31);
  v29 = v27 + (int)a5;
  if (v29 >= v21)
    v30 = v21;
  else
    v30 = v29;
  if ((int)v28 < (int)v30)
  {
    v31 = 0;
    v32 = 0;
    LODWORD(v33) = v27 + (int)a4;
    if ((int)v33 >= v15)
      v33 = v15;
    else
      v33 = v33;
    v34 = ((int)a4 - v27) & ~(((int)a4 - v27) >> 31);
    v35 = (unsigned __int8 *)(v24 + v34 + v22 * v28);
    v36 = 0.0;
    v37 = 0.0;
    do
    {
      if ((int)v33 > (int)v34)
      {
        v38 = a3 + v23 * v28;
        v39 = v33 - v34;
        v40 = v35;
        v41 = 4 * v34;
        do
        {
          v42 = *v40++;
          v43 = (float)v42;
          v37 = v37 + (float)v42;
          if (!*(_BYTE *)(result + v38 + (v41 & 0xFFFFFFFC)))
            v43 = -0.0;
          v36 = v36 + v43;
          if (*(_BYTE *)(result + v38 + (v41 & 0xFFFFFFFC)))
            ++v31;
          v41 += 4;
          --v39;
        }
        while (v39);
        v32 += v33 - v34;
      }
      ++v28;
      v35 += v22;
    }
    while (v28 != v30);
  }
  return result;
}

CIImage *RRradialCentroidMask(CIImage *a1, CGRect a2, float a3, float a4, int a5)
{
  double height;
  double width;
  CIColorKernel *v11;
  CIColorKernel *v12;
  CIVector *v13;
  double v14;
  double v15;
  float v16;
  CIVector *v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  _QWORD v24[5];

  height = a2.size.height;
  width = a2.size.width;
  v24[4] = *MEMORY[0x1E0C80C00];
  v11 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_puncturec2, a2.origin.x, a2.origin.y);
  v12 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_puncturec2_hard);
  v13 = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", 1.0 / (width * width), 1.0 / (height * height));
  if (a5)
  {
    if (width >= height)
      v15 = height;
    else
      v15 = width;
    v16 = v15;
    v13 = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", 1.0 / (float)(v16 * v16), 1.0 / (float)(v16 * v16));
  }
  v17 = v13;
  *(float *)&v14 = a3 * 0.5;
  if (a4 >= 1.0)
    v11 = v12;
  v18 = *MEMORY[0x1E0C9D5E0];
  v19 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
  v20 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
  v21 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
  v24[0] = a1;
  v24[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v14);
  *(float *)&v22 = a4;
  v24[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v22);
  v24[3] = v17;
  return -[CIColorKernel applyWithExtent:arguments:](v11, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v24, 4), v18, v19, v20, v21);
}

uint64_t RRmaximumRh(void *a1, void *a2)
{
  CIColorKernel *v4;
  double v5;
  CGFloat v6;
  double v7;
  CGFloat v8;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  _QWORD v18[3];
  CGRect v19;
  CGRect v20;
  CGRect v21;

  v18[2] = *MEMORY[0x1E0C80C00];
  v4 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_maximumRh);
  objc_msgSend(a1, "extent");
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  objc_msgSend(a2, "extent");
  v21.origin.x = v13;
  v21.origin.y = v14;
  v21.size.width = v15;
  v21.size.height = v16;
  v19.origin.x = v6;
  v19.origin.y = v8;
  v19.size.width = v10;
  v19.size.height = v12;
  v20 = CGRectUnion(v19, v21);
  v18[0] = a1;
  v18[1] = a2;
  return (uint64_t)-[CIColorKernel applyWithExtent:arguments:](v4, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v18, 2), v20.origin.x, v20.origin.y, v20.size.width, v20.size.height);
}

uint64_t convexFill(unsigned __int8 *a1, unsigned __int8 *a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int a7, CGPoint a8)
{
  double y;
  CGFloat x;
  uint64_t v17;
  CGPoint v19;

  y = a8.y;
  x = a8.x;
  v17 = convexFillHorizontal(a1, a2, a3, a4, a5, a6, a7, a8, 1);
  v19.y = y + -1.0;
  v19.x = x;
  return convexFillHorizontal(a1, a2, a3, a4, a5, a6, a7, v19, -1) + v17;
}

uint64_t convexFillHorizontal(unsigned __int8 *a1, unsigned __int8 *a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, int a7, CGPoint a8, int a9)
{
  unint64_t y;
  unint64_t x;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  _BOOL4 v16;
  int v17;
  int v18;
  uint64_t v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unsigned __int8 *v27;
  int v28;
  int v29;
  unsigned __int8 *v30;
  int v31;
  int v32;
  float v33;
  int v34;
  int v35;
  char *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  int v42;
  unsigned __int8 v43;
  _DWORD *v44;
  uint64_t i;
  int v46;
  int v47;
  int v48;
  int v49;
  uint64_t j;
  _DWORD *v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  BOOL v57;
  BOOL v58;
  int v59;
  int v60;
  int v61;
  int v62;
  char *v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int8 *v67;
  unsigned __int8 *v68;
  int v69;
  unsigned __int8 v70;
  BOOL v71;
  NSObject *v72;
  NSObject *v74;
  _BYTE v75[4];
  int v76;
  int v77;
  int v78;
  _OWORD v79[9];
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  memset(v79, 0, 140);
  y = (int)a8.y;
  if ((y & 0x80000000) != 0 || y >= a4 || (x = (int)a8.x, (x & 0x80000000) != 0) || x >= a3)
  {
    if (CI_LOG_DUALRED())
    {
      v72 = ci_logger_api();
      if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
        convexFillHorizontal(v72);
    }
    return 0;
  }
  if (a9 == -1)
    v12 = -a5;
  else
    LODWORD(v12) = a5;
  if (a9 == -1)
    v13 = 0;
  else
    v13 = a5 * a4;
  v14 = y * a5;
  v15 = &a1[x + y * a5];
  if (*v15 <= a7)
  {
    if (CI_LOG_DUALRED())
    {
      v74 = ci_logger_api();
      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
        convexFillHorizontal(v15, a7, v74);
    }
    return 0;
  }
  v16 = v14 >= v13;
  if (a9 != -1)
    v16 = v14 < v13;
  if (!v16)
    return 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = &a1[v13];
  v21 = &a1[v14];
  v22 = -1;
  v23 = -1;
  do
  {
    if ((x & 0x80000000) != 0)
    {
      v26 = 0;
      v25 = 0;
      v28 = x;
    }
    else
    {
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v27 = &v21[x];
      do
      {
        if (v27[v24] <= a7)
          break;
        v26 += ((int)x + (int)v24) * (unint64_t)v27[v24];
        v25 += v27[v24];
        ++v19;
        --v24;
      }
      while (&v27[v24] >= v21);
      v28 = x + v24;
    }
    v29 = x + 1;
    if ((int)x + 1 < (uint64_t)a3)
    {
      v30 = &v21[v29];
      do
      {
        if (*v30 <= a7)
          break;
        v26 += *v30 * (uint64_t)v29;
        v25 += *v30;
        ++v19;
        ++v29;
        ++v30;
      }
      while (v30 < &v21[a3]);
    }
    v31 = v28 + 1;
    v32 = v29 - v31;
    v33 = (float)v25;
    if (v29 - v31 < 1)
      v34 = 0;
    else
      v34 = (int)(float)(v33 / (float)v32);
    if (v23 == -1)
    {
      v35 = -1;
    }
    else
    {
      if (v31 > v23)
        v23 = v31;
      if (v29 < v22)
        v22 = v29;
      v35 = v22 - v23;
    }
    if (v32 < 1)
      break;
    if (v18 == 5)
    {
      v36 = (char *)v79 + 28 * v17;
      v37 = *((_DWORD *)v36 + 2);
      v38 = *((int *)v36 + 1);
      if (v37 > (int)v38)
      {
        v39 = *((int *)v79 + 7 * v17);
        v40 = &a2[v39 * a6 + v38];
        v41 = &a1[v39 * a5 + v38];
        v42 = v37 - v38;
        do
        {
          v43 = *v41++;
          *v40++ = v43;
          --v42;
        }
        while (v42);
      }
      v18 = 4;
    }
    v44 = (_DWORD *)v79 + 7 * v17;
    *v44 = y;
    v44[1] = v31;
    v44[2] = v29;
    v44[3] = v35;
    v44[4] = v34;
    ++v18;
    if (v17 == 4)
      v17 = 0;
    else
      ++v17;
    if (v18 == 5)
    {
      for (i = 0; i != 5; ++i)
      {
        v46 = v17 + i;
        if (v17 + (int)i > 4)
          v46 = v17 - 5 + i;
        *(_DWORD *)&v75[4 * i] = v46;
      }
      v47 = v76;
      v48 = v76;
      v49 = *((_DWORD *)v79 + 7 * v76 + 3);
      for (j = 8; j != 20; j += 4)
      {
        v51 = (_DWORD *)v79 + 7 * v47;
        v52 = *(_DWORD *)&v75[j];
        v53 = *((_DWORD *)v79 + 7 * v52 + 3);
        if (v49 >= v53)
          v49 = *((_DWORD *)v79 + 7 * v52 + 3);
        v51[5] = v51[4] * v49 * (v51[2] - v51[1]);
        v51[6] = v49;
        v49 = v53;
        v47 = v52;
      }
      if (*((int *)&v79[1] + 7 * v77 + 2) <= 7)
      {
        v54 = *((_DWORD *)&v79[1] + 7 * v77 + 1);
        v55 = *((_DWORD *)&v79[1] + 7 * v48 + 1);
        if (v54 < v55)
        {
          v56 = *((_DWORD *)&v79[1] + 7 * v78 + 1);
          if (v54 < v56 && (float)v54 * 2.8 < (float)(v56 + v55))
          {
            v18 = 3;
            goto LABEL_64;
          }
        }
      }
      v18 = 5;
    }
    if (v32 < 5)
      break;
    LODWORD(x) = (int)(float)((float)v26 / v33);
    LODWORD(y) = y + a9;
    v21 += (int)v12;
    v57 = v21 >= v20;
    if (a9 != -1)
      v57 = v21 < v20;
    v22 = v29;
    v23 = v31;
  }
  while (v57);
  if (v18 < 1)
    return v19;
LABEL_64:
  v59 = v17 - v18;
  v58 = v17 < v18;
  v60 = v17 - v18 + 5;
  if (v58)
    v61 = v60;
  else
    v61 = v59;
  do
  {
    v62 = v61;
    v63 = (char *)v79 + 28 * v61;
    v64 = *((_DWORD *)v63 + 2);
    v65 = *((int *)v63 + 1);
    if (v64 > (int)v65)
    {
      v66 = *((int *)v79 + 7 * v62);
      v67 = &a2[v66 * a6 + v65];
      v68 = &a1[v66 * a5 + v65];
      v69 = v64 - v65;
      do
      {
        v70 = *v68++;
        *v67++ = v70;
        --v69;
      }
      while (v69);
    }
    if (v62 == 4)
      v61 = 0;
    else
      v61 = v62 + 1;
    v71 = __OFSUB__(v18--, 1);
  }
  while (!((v18 < 0) ^ v71 | (v18 == 0)));
  return v19;
}

BOOL fillR8(_QWORD *a1, unsigned __int8 *a2, int a3, int a4)
{
  unsigned int v4;
  unsigned int v5;

  v4 = a2[a1[1] * a4 + a3];
  v5 = *(unsigned __int8 *)a1;
  ++*((_DWORD *)a1 + 8);
  return v4 > v5;
}

CIImage *RRcombineRGBA(CIImage *a1, CIImage *a2, CIImage *a3, CIImage *a4)
{
  CIColorKernel *v8;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat v12;
  double v13;
  CGFloat v14;
  double v15;
  CGFloat v16;
  CGFloat v17;
  CGFloat v18;
  CGFloat v19;
  CGFloat v20;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double v25;
  CGFloat v26;
  double v27;
  CGFloat v28;
  double v29;
  CGFloat v30;
  double v31;
  CGFloat v32;
  CGFloat v33;
  CGFloat v34;
  CGFloat v35;
  CGFloat v36;
  _QWORD v38[5];
  CGRect v39;
  CGRect v40;
  CGRect v41;
  CGRect v42;
  CGRect v43;
  CGRect v44;
  CGRect v45;
  CGRect v46;

  v38[4] = *MEMORY[0x1E0C80C00];
  v8 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_combine_rgba);
  -[CIImage extent](a1, "extent");
  v10 = v9;
  v12 = v11;
  v14 = v13;
  v16 = v15;
  -[CIImage extent](a2, "extent");
  v44.origin.x = v17;
  v44.origin.y = v18;
  v44.size.width = v19;
  v44.size.height = v20;
  v39.origin.x = v10;
  v39.origin.y = v12;
  v39.size.width = v14;
  v39.size.height = v16;
  v40 = CGRectUnion(v39, v44);
  x = v40.origin.x;
  y = v40.origin.y;
  width = v40.size.width;
  height = v40.size.height;
  -[CIImage extent](a3, "extent");
  v26 = v25;
  v28 = v27;
  v30 = v29;
  v32 = v31;
  -[CIImage extent](a4, "extent");
  v45.origin.x = v33;
  v45.origin.y = v34;
  v45.size.width = v35;
  v45.size.height = v36;
  v41.origin.x = v26;
  v41.origin.y = v28;
  v41.size.width = v30;
  v41.size.height = v32;
  v46 = CGRectUnion(v41, v45);
  v42.origin.x = x;
  v42.origin.y = y;
  v42.size.width = width;
  v42.size.height = height;
  v43 = CGRectUnion(v42, v46);
  v38[0] = a1;
  v38[1] = a2;
  v38[2] = a3;
  v38[3] = a4;
  return -[CIColorKernel applyWithExtent:arguments:](v8, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v38, 4), v43.origin.x, v43.origin.y, v43.size.width, v43.size.height);
}

CIImage *RRextractR8(CIImage *a1)
{
  CIColorKernel *v2;
  double v3;
  double v4;
  double v5;
  double v6;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  v2 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_r);
  -[CIImage extent](a1, "extent");
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 1), v3, v4, v5, v6);
}

CIImage *RRextractG8(CIImage *a1)
{
  CIColorKernel *v2;
  double v3;
  double v4;
  double v5;
  double v6;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  v2 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_g);
  -[CIImage extent](a1, "extent");
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 1), v3, v4, v5, v6);
}

CIImage *RRextractB8(CIImage *a1)
{
  CIColorKernel *v2;
  double v3;
  double v4;
  double v5;
  double v6;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  v2 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_b);
  -[CIImage extent](a1, "extent");
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 1), v3, v4, v5, v6);
}

CIImage *RRextractA8(CIImage *a1)
{
  CIColorKernel *v2;
  double v3;
  double v4;
  double v5;
  double v6;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  v2 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_a);
  -[CIImage extent](a1, "extent");
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 1), v3, v4, v5, v6);
}

CIImage *RRsmoothstep(CIImage *a1, float a2)
{
  CIColorKernel *v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v4 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_smoothstepRh);
  -[CIImage extent](a1, "extent");
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v14[0] = a1;
  *(float *)&v5 = a2;
  v14[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v5);
  return -[CIColorKernel applyWithExtent:arguments:](v4, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v14, 2), v6, v8, v10, v12);
}

CIImage *RRmaxIfGreaterThanZeroRh(CIImage *a1, CIImage *a2)
{
  CIColorKernel *v4;
  double v5;
  CGFloat v6;
  double v7;
  CGFloat v8;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  _QWORD v18[3];
  CGRect v19;
  CGRect v20;
  CGRect v21;

  v18[2] = *MEMORY[0x1E0C80C00];
  v4 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_maxmask);
  -[CIImage extent](a1, "extent");
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  -[CIImage extent](a2, "extent");
  v21.origin.x = v13;
  v21.origin.y = v14;
  v21.size.width = v15;
  v21.size.height = v16;
  v19.origin.x = v6;
  v19.origin.y = v8;
  v19.size.width = v10;
  v19.size.height = v12;
  v20 = CGRectUnion(v19, v21);
  v18[0] = a1;
  v18[1] = a2;
  return -[CIColorKernel applyWithExtent:arguments:](v4, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v18, 2), v20.origin.x, v20.origin.y, v20.size.width, v20.size.height);
}

CIImage *RRmaxRhScalar(CIImage *a1, float a2)
{
  CIColorKernel *v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v4 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_maxScalarRh);
  -[CIImage extent](a1, "extent");
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v14[0] = a1;
  *(float *)&v5 = a2;
  v14[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v5);
  return -[CIColorKernel applyWithExtent:arguments:](v4, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v14, 2), v6, v8, v10, v12);
}

CIImage *RRminimumRh(CIImage *a1, CIImage *a2)
{
  CIColorKernel *v4;
  double v5;
  CGFloat v6;
  double v7;
  CGFloat v8;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  _QWORD v18[3];
  CGRect v19;
  CGRect v20;
  CGRect v21;

  v18[2] = *MEMORY[0x1E0C80C00];
  v4 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_minimumRh);
  -[CIImage extent](a1, "extent");
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  -[CIImage extent](a2, "extent");
  v21.origin.x = v13;
  v21.origin.y = v14;
  v21.size.width = v15;
  v21.size.height = v16;
  v19.origin.x = v6;
  v19.origin.y = v8;
  v19.size.width = v10;
  v19.size.height = v12;
  v20 = CGRectUnion(v19, v21);
  v18[0] = a1;
  v18[1] = a2;
  return -[CIColorKernel applyWithExtent:arguments:](v4, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v18, 2), v20.origin.x, v20.origin.y, v20.size.width, v20.size.height);
}

CIImage *RRmultiplyRh(CIImage *a1, CIImage *a2)
{
  CIColorKernel *v4;
  CIColorKernel *v5;
  double v6;
  CGFloat v7;
  double v8;
  CGFloat v9;
  double v10;
  CGFloat v11;
  double v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  CGFloat v17;
  _QWORD v19[3];
  CGRect v20;
  CGRect v21;
  CGRect v22;

  v19[2] = *MEMORY[0x1E0C80C00];
  v4 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_multiply);
  if (!a1 || !a2)
    return +[CIImage emptyImage](CIImage, "emptyImage");
  v5 = v4;
  -[CIImage extent](a1, "extent");
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v13 = v12;
  -[CIImage extent](a2, "extent");
  v22.origin.x = v14;
  v22.origin.y = v15;
  v22.size.width = v16;
  v22.size.height = v17;
  v20.origin.x = v7;
  v20.origin.y = v9;
  v20.size.width = v11;
  v20.size.height = v13;
  v21 = CGRectUnion(v20, v22);
  v19[0] = a1;
  v19[1] = a2;
  return -[CIColorKernel applyWithExtent:arguments:](v5, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v19, 2), v21.origin.x, v21.origin.y, v21.size.width, v21.size.height);
}

CIImage *refilterChannel(CIImage *a1)
{
  CIColorKernel *v2;
  double v3;
  double v4;
  double v5;
  double v6;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  v2 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_refilter_chan);
  -[CIImage extent](a1, "extent");
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 1), v3, v4, v5, v6);
}

CIImage *RRbinarize(CIImage *a1)
{
  CIColorKernel *v2;
  double v3;
  double v4;
  double v5;
  double v6;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  v2 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_binarize);
  -[CIImage extent](a1, "extent");
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 1), v3, v4, v5, v6);
}

CIImage *RRbinarizeInverse(CIImage *a1)
{
  CIColorKernel *v2;
  double v3;
  double v4;
  double v5;
  double v6;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  v2 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_binarize_inv);
  -[CIImage extent](a1, "extent");
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 1), v3, v4, v5, v6);
}

CIImage *RRbinarizeAlpha(CIImage *a1, CIImage *a2, float a3)
{
  CIColorKernel *v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  _QWORD v13[4];

  v13[3] = *MEMORY[0x1E0C80C00];
  v6 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_binarize_alpha);
  v7 = *MEMORY[0x1E0C9D5E0];
  v8 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
  v9 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
  v10 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
  *(float *)&v11 = a3;
  v13[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v11, a1, a2);
  return -[CIColorKernel applyWithExtent:arguments:](v6, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v13, 3), v7, v8, v9, v10);
}

CIImage *RRbinarizeAlphaInverse(CIImage *a1, CIImage *a2, float a3)
{
  CIColorKernel *v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  _QWORD v13[4];

  v13[3] = *MEMORY[0x1E0C80C00];
  v6 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_binarize_alpha_inv);
  v7 = *MEMORY[0x1E0C9D5E0];
  v8 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
  v9 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
  v10 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
  *(float *)&v11 = a3;
  v13[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v11, a1, a2);
  return -[CIColorKernel applyWithExtent:arguments:](v6, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v13, 3), v7, v8, v9, v10);
}

CIImage *RRconditionalZero(CIImage *a1, CIImage *a2, float a3)
{
  CIColorKernel *v6;
  double v7;
  CGFloat v8;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat v12;
  double v13;
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  CGFloat v17;
  CGFloat v18;
  double x;
  double y;
  double width;
  double height;
  _QWORD v24[4];
  CGRect v25;
  CGRect v26;
  CGRect v27;

  v24[3] = *MEMORY[0x1E0C80C00];
  v6 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_conditionalZeroRh);
  -[CIImage extent](a1, "extent");
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v14 = v13;
  -[CIImage extent](a2, "extent");
  v27.origin.x = v15;
  v27.origin.y = v16;
  v27.size.width = v17;
  v27.size.height = v18;
  v25.origin.x = v8;
  v25.origin.y = v10;
  v25.size.width = v12;
  v25.size.height = v14;
  v26 = CGRectUnion(v25, v27);
  x = v26.origin.x;
  y = v26.origin.y;
  width = v26.size.width;
  height = v26.size.height;
  *(float *)&v26.origin.x = a3;
  v24[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v26.origin.x, a1, a2);
  return -[CIColorKernel applyWithExtent:arguments:](v6, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v24, 3), x, y, width, height);
}

CIImage *feather(CIImage *a1, CGRect a2, float a3, float a4, float a5)
{
  double height;
  double width;
  double y;
  double x;
  double v10;
  float v11;
  CIImage *v12;
  double v13;
  char v14;
  CIImage *v15;
  double v16;
  char v17;
  CIImage *v18;
  const __CFString *v20;
  uint64_t v21;
  const __CFString *v22;
  _QWORD v23[2];

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  v23[1] = *MEMORY[0x1E0C80C00];
  v10 = round(a4 * 0.1 * a3);
  if (v10 <= 3.0)
    v10 = 3.0;
  v11 = v10;
  v12 = -[CIImage imageByCroppingToRect:](a1, "imageByCroppingToRect:", x, a2.origin.y);
  *(float *)&v13 = (float)(v11 + v11) * a5;
  v22 = CFSTR("inputRadius");
  v23[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v13);
  v14 = 1;
  v15 = -[CIImage imageByCroppingToRect:](-[CIImage imageByApplyingFilter:withInputParameters:](v12, "imageByApplyingFilter:withInputParameters:", CFSTR("CIMorphologyMaximum"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v23, &v22, 1)), "imageByCroppingToRect:", x, y, width, height);
  do
  {
    v17 = v14;
    v20 = CFSTR("inputRadius");
    *(float *)&v16 = v11;
    v21 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v16);
    v18 = -[CIImage imageByCroppingToRect:](-[CIImage imageByApplyingFilter:withInputParameters:](v15, "imageByApplyingFilter:withInputParameters:", CFSTR("CIBoxBlur"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v21, &v20, 1)), "imageByCroppingToRect:", x, y, width, height);
    v15 = v18;
    v14 = 0;
  }
  while ((v17 & 1) != 0);
  return -[CIImage imageByCroppingToRect:](v18, "imageByCroppingToRect:", x, y, width, height);
}

CIImage *chromaExclusion(CIImage *a1, CIImage *a2, CGRect a3, float a4, float a5, float a6, float a7)
{
  double height;
  double width;
  double y;
  double x;
  CIImage *v16;
  CIImage *v17;
  CIImage *v18;
  CIImage *v19;
  CIImage *v20;
  CIImage *v21;
  CIImage *v22;
  uint64_t v23;
  CIImage *v24;
  uint64_t v25;
  CIColorKernel *v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  _QWORD v35[5];
  const __CFString *v36;
  CIVector *v37;
  const __CFString *v38;
  _QWORD v39[2];

  height = a3.size.height;
  width = a3.size.width;
  y = a3.origin.y;
  x = a3.origin.x;
  v39[1] = *MEMORY[0x1E0C80C00];
  v16 = -[CIImage imageByClampingToExtent](a1, "imageByClampingToExtent");
  v17 = -[CIImage imageByClampingToExtent](a2, "imageByClampingToExtent");
  v18 = RRbinarizeAlphaInverse(v16, v17, a5);
  v19 = RRbinarizeAlpha(v16, v17, a5);
  v38 = CFSTR("inputExtent");
  v39[0] = +[CIVector vectorWithCGRect:](CIVector, "vectorWithCGRect:", x, y, width, height);
  v20 = -[CIImage imageByApplyingFilter:withInputParameters:](v18, "imageByApplyingFilter:withInputParameters:", CFSTR("CIAreaAverage"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v39, &v38, 1));
  v36 = CFSTR("inputExtent");
  v37 = +[CIVector vectorWithCGRect:](CIVector, "vectorWithCGRect:", x, y, width, height);
  v21 = -[CIImage imageByApplyingFilter:withInputParameters:](v19, "imageByApplyingFilter:withInputParameters:", CFSTR("CIAreaAverage"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v37, &v36, 1));
  v22 = -[CIImage imageByUnpremultiplyingAlpha](v20, "imageByUnpremultiplyingAlpha");
  -[CIImage extent](v22, "extent");
  v23 = -[CIImage imageByClampingToExtent](-[CIImage imageBySettingAlphaOneInExtent:](v22, "imageBySettingAlphaOneInExtent:"), "imageByClampingToExtent");
  v24 = -[CIImage imageByUnpremultiplyingAlpha](v21, "imageByUnpremultiplyingAlpha");
  -[CIImage extent](v24, "extent");
  v25 = -[CIImage imageByClampingToExtent](-[CIImage imageBySettingAlphaOneInExtent:](v24, "imageBySettingAlphaOneInExtent:"), "imageByClampingToExtent");
  v26 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_chromaexc);
  *(float *)&v27 = a4 * a4;
  v28 = *MEMORY[0x1E0C9D5E0];
  v29 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
  v30 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
  v31 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
  v35[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v27, v23, v25);
  *(float *)&v32 = a6;
  v35[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v32);
  *(float *)&v33 = a7;
  v35[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v33);
  return -[CIColorKernel applyWithExtent:arguments:](v26, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v35, 5), v28, v29, v30, v31);
}

CIImage *RRspecularMask(CIImage *a1, CIImage *a2, float a3, float a4)
{
  CIColorKernel *v8;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat v12;
  double v13;
  CGFloat v14;
  double v15;
  CGFloat v16;
  CGFloat v17;
  CGFloat v18;
  CGFloat v19;
  CGFloat v20;
  double x;
  double y;
  double width;
  double height;
  double v25;
  _QWORD v27[5];
  CGRect v28;
  CGRect v29;
  CGRect v30;

  v27[4] = *MEMORY[0x1E0C80C00];
  v8 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_detect_specs);
  -[CIImage extent](a1, "extent");
  v10 = v9;
  v12 = v11;
  v14 = v13;
  v16 = v15;
  -[CIImage extent](a2, "extent");
  v30.origin.x = v17;
  v30.origin.y = v18;
  v30.size.width = v19;
  v30.size.height = v20;
  v28.origin.x = v10;
  v28.origin.y = v12;
  v28.size.width = v14;
  v28.size.height = v16;
  v29 = CGRectUnion(v28, v30);
  x = v29.origin.x;
  y = v29.origin.y;
  width = v29.size.width;
  height = v29.size.height;
  v27[0] = a1;
  v27[1] = a2;
  *(float *)&v29.origin.x = a4;
  v27[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v29.origin.x);
  *(float *)&v25 = a3;
  v27[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v25);
  return -[CIColorKernel applyWithExtent:arguments:](v8, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v27, 4), x, y, width, height);
}

CIImage *RRradialEllipticalMask(CGRect a1, CIVector *a2, objc_object *a3, float a4, float a5, float a6, float a7)
{
  double height;
  double width;
  CIColorKernel *v15;
  CIColorKernel *v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  float v26;
  double v27;
  double v28;
  double v29;
  CIVector *v30;
  double v31;
  double v32;
  double v33;
  CIVector *v34;
  double v35;
  double v36;
  float v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  float v44;
  _QWORD v45[9];

  height = a1.size.height;
  width = a1.size.width;
  v45[8] = *MEMORY[0x1E0C80C00];
  v15 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_mmv, a1.origin.x, a1.origin.y);
  v16 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_mmi);
  objc_opt_class();
  v44 = a6;
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
      v15 = v16;
    else
      v15 = 0;
  }
  -[CIVector X](a2, "X");
  v18 = v17;
  -[CIVector X](a2, "X");
  v20 = v19;
  -[CIVector Y](a2, "Y");
  v22 = v21;
  -[CIVector Y](a2, "Y");
  *(float *)&v23 = sqrt(v22 * v23 + v18 * v20);
  v24 = *(float *)&v23;
  if (*(float *)&v23 < 0.000001)
    return +[CIImage emptyImage](CIImage, "emptyImage");
  v26 = 1.0 / sqrt(height * height + width * width);
  -[CIVector X](a2, "X");
  v28 = v27 / v24;
  -[CIVector Y](a2, "Y");
  v30 = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v28, v29 / v24);
  -[CIVector Y](v30, "Y");
  v32 = -v31;
  -[CIVector X](v30, "X");
  v34 = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", v32, v33);
  *(float *)&v32 = v26 / a5;
  v35 = *MEMORY[0x1E0C9D5E0];
  v36 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
  v37 = v26 / a4;
  v38 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
  v39 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
  v45[0] = a3;
  v45[1] = v30;
  v45[2] = v34;
  v45[3] = &unk_1E2F1DAD8;
  *(float *)&v40 = v44;
  v45[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v40);
  LODWORD(v41) = LODWORD(v32);
  v45[5] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v41);
  *(float *)&v42 = v37;
  v45[6] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v42);
  *(float *)&v43 = a7;
  v45[7] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v43);
  return -[CIColorKernel applyWithExtent:arguments:](v15, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v45, 8), v35, v36, v38, v39);
}

CIImage *RRradialMask(CIVector *a1, CGRect a2, float a3, float a4, int a5)
{
  double height;
  double width;
  double y;
  double x;
  CIColorKernel *v13;
  CIColorKernel *v14;
  CIVector *v15;
  double v16;
  double v17;
  float v18;
  CIVector *v19;
  float v20;
  float v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  _QWORD v28[5];

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  v28[4] = *MEMORY[0x1E0C80C00];
  v13 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_puncture2);
  v14 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_puncture2_hard);
  v15 = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", 1.0 / (width * width), 1.0 / (height * height));
  if (a5)
  {
    if (width >= height)
      v17 = height;
    else
      v17 = width;
    v18 = v17;
    v15 = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", 1.0 / (float)(v18 * v18), 1.0 / (float)(v18 * v18));
  }
  v19 = v15;
  if (!a1)
  {
    v20 = x + width * 0.5;
    v21 = y + height * 0.5;
    a1 = +[CIVector vectorWithX:Y:](CIVector, "vectorWithX:Y:", roundf(v20), roundf(v21));
  }
  *(float *)&v16 = a3 * 0.5;
  if (a4 >= 1.0)
    v13 = v14;
  v22 = *MEMORY[0x1E0C9D5E0];
  v23 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
  v24 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
  v25 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
  v28[0] = a1;
  v28[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v16);
  *(float *)&v26 = a4;
  v28[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v26);
  v28[3] = v19;
  return -[CIColorKernel applyWithExtent:arguments:](v13, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v28, 4), v22, v23, v24, v25);
}

CIImage *RRradialCenterMask(CIImage *a1, CGRect a2, float a3, float a4, float a5)
{
  CIColorKernel *v9;
  float v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  float v16;
  double v17;
  double v18;
  _QWORD v20[5];

  v20[4] = *MEMORY[0x1E0C80C00];
  v9 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_rcsoft, a2.origin.x, a2.origin.y, a2.size.width, a2.size.height);
  v10 = a3 * a3;
  v11 = *MEMORY[0x1E0C9D5E0];
  v12 = *(double *)(MEMORY[0x1E0C9D5E0] + 8);
  v13 = *(double *)(MEMORY[0x1E0C9D5E0] + 16);
  v14 = *(double *)(MEMORY[0x1E0C9D5E0] + 24);
  v20[0] = a1;
  *(float *)&v15 = a4 * a4;
  v16 = 1.0 / v10;
  v20[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v15);
  *(float *)&v17 = a5;
  v20[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v17);
  *(float *)&v18 = v16;
  v20[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v18);
  return -[CIColorKernel applyWithExtent:arguments:](v9, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v20, 4), v11, v12, v13, v14);
}

CIImage *RRcloseByDilation(CIImage *a1, float a2)
{
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  CIImage *v12;
  double v13;
  CIImage *v14;
  const __CFString *v16;
  uint64_t v17;
  const __CFString *v18;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  -[CIImage extent](a1, "extent");
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v18 = CFSTR("inputRadius");
  *(float *)&v4 = a2;
  v19[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v4);
  v12 = -[CIImage imageByApplyingFilter:withInputParameters:](a1, "imageByApplyingFilter:withInputParameters:", CFSTR("CIMorphologyMaximum"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v19, &v18, 1));
  v16 = CFSTR("inputRadius");
  *(float *)&v13 = a2;
  v17 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v13);
  v14 = -[CIImage imageByApplyingFilter:withInputParameters:](v12, "imageByApplyingFilter:withInputParameters:", CFSTR("CIMorphologyMinimum"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v17, &v16, 1));
  -[CIImage extent](a1, "extent");
  return -[CIImage imageByCroppingToRect:](-[CIImage imageByCroppingToRect:](v14, "imageByCroppingToRect:"), "imageByCroppingToRect:", v5, v7, v9, v11);
}

CIImage *RRcloseByErosion(CIImage *a1, float a2)
{
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  CIImage *v12;
  double v13;
  CIImage *v14;
  const __CFString *v16;
  uint64_t v17;
  const __CFString *v18;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  -[CIImage extent](a1, "extent");
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v18 = CFSTR("inputRadius");
  *(float *)&v4 = a2;
  v19[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v4);
  v12 = -[CIImage imageByApplyingFilter:withInputParameters:](a1, "imageByApplyingFilter:withInputParameters:", CFSTR("CIMorphologyMinimum"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v19, &v18, 1));
  v16 = CFSTR("inputRadius");
  *(float *)&v13 = a2;
  v17 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v13);
  v14 = -[CIImage imageByApplyingFilter:withInputParameters:](v12, "imageByApplyingFilter:withInputParameters:", CFSTR("CIMorphologyMaximum"), objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v17, &v16, 1));
  -[CIImage extent](a1, "extent");
  return -[CIImage imageByCroppingToRect:](-[CIImage imageByCroppingToRect:](v14, "imageByCroppingToRect:"), "imageByCroppingToRect:", v5, v7, v9, v11);
}

CIImage *RRclip(CIImage *a1, float a2)
{
  CIColorKernel *v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v4 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_pclip);
  -[CIImage extent](a1, "extent");
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v14[0] = a1;
  *(float *)&v5 = a2;
  v14[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v5);
  return -[CIColorKernel applyWithExtent:arguments:](v4, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v14, 2), v6, v8, v10, v12);
}

CIImage *RRspecularResponse(CIImage *a1)
{
  CIColorKernel *v2;
  double v3;
  double v4;
  double v5;
  double v6;
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  v2 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_specular);
  -[CIImage extent](a1, "extent");
  v8[0] = a1;
  return -[CIColorKernel applyWithExtent:arguments:](v2, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 1), v3, v4, v5, v6);
}

CIImage *RRrawRedWhiteResponseSmallMedium(CIImage *a1, float a2, float a3)
{
  CIColorKernel *v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  _QWORD v17[4];

  v17[3] = *MEMORY[0x1E0C80C00];
  v6 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_rawred_sm);
  -[CIImage extent](a1, "extent");
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v14 = v13;
  *(float *)&v7 = a2;
  v17[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v7, a1);
  *(float *)&v15 = a3;
  v17[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v15);
  return -[CIColorKernel applyWithExtent:arguments:](v6, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v17, 3), v8, v10, v12, v14);
}

CIImage *RRrawRedWhiteResponseLarge(CIImage *a1, float a2, float a3)
{
  CIColorKernel *v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  _QWORD v17[4];

  v17[3] = *MEMORY[0x1E0C80C00];
  v6 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_drr_rawred_large);
  -[CIImage extent](a1, "extent");
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v14 = v13;
  *(float *)&v7 = a2;
  v17[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v7, a1);
  *(float *)&v15 = a3;
  v17[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v15);
  return -[CIColorKernel applyWithExtent:arguments:](v6, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v17, 3), v8, v10, v12, v14);
}

__n64 cikernel::_drr_puncturec2(CI *a1, double a2, float a3, float a4, double a5)
{
  _QWORD *DC;
  float v8;
  float v9;
  BOOL v10;
  float v11;
  __n64 result;

  DC = (_QWORD *)CI::getDC(a1);
  v8 = (float)(vmlas_n_f32(vmuls_lane_f32((float)(COERCE_FLOAT(HIDWORD(*DC)) - *((float *)&a2 + 1))* (float)(COERCE_FLOAT(HIDWORD(*DC)) - *((float *)&a2 + 1)), *(float32x2_t *)&a5, 1), (float)(COERCE_FLOAT(*DC) - *(float *)&a2) * (float)(COERCE_FLOAT(*DC) - *(float *)&a2), *(float *)&a5)- (float)((float)(a3 * a4) * a3))/ (float)((float)(a3 * a3) - (float)((float)(a3 * a4) * a3));
  if (v8 <= 1.0)
    v9 = v8;
  else
    v9 = 1.0;
  v10 = v8 < 0.0;
  v11 = 0.0;
  if (!v10)
    v11 = v9;
  result.n64_f32[0] = 1.0 - (float)((float)(v11 * v11) * (float)((float)(v11 * -2.0) + 3.0));
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_s_f_f_f2(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, float, float, double);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  double *v18;
  __n128 *v19;
  __int128 v20;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, float, float, double))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_DWORD *)(v10 + 88);
  v17 = *(_QWORD *)(v10 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
  v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (double *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v20 = v11(a1, *v19, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_drr_puncturec2_hard(CI *a1, double a2, float a3, double a4, double a5)
{
  BOOL v6;
  int32x2_t v7;
  double result;

  v7 = *(int32x2_t *)CI::getDC(a1);
  v6 = vmlas_n_f32(vmuls_lane_f32((float)(*(float *)&v7.i32[1] - *((float *)&a2 + 1)) * (float)(*(float *)&v7.i32[1] - *((float *)&a2 + 1)), *(float32x2_t *)&a5, 1), (float)(*(float *)v7.i32 - *(float *)&a2) * (float)(*(float *)v7.i32 - *(float *)&a2), *(float *)&a5) > (float)(a3 * a3);
  v7.i32[0] = 0;
  if (!v6)
    *(float *)v7.i32 = 1.0;
  *(_QWORD *)&result = vdupq_lane_s32(v7, 0).u64[0];
  return result;
}

double cikernel::_drr_maximumRh(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vmaxnmq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_drr_combine_rgba(int32x4_t a1, int32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vzip1q_s32(a1, a2).u64[0];
  return result;
}

void CI::f4_s_s_s_s(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __n128 *v19;
  __n128 *v20;
  __n128 *v21;
  __n128 *v22;
  __int128 v23;
  double (*v24)(__n128, __n128, __n128, __n128);

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  if (*(_BYTE *)(a1 + 64))
  {
    v24 = *(double (**)(__n128, __n128, __n128, __n128))(a1 + 24);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 104)), a2);
    v10 = v24;
  }
  v19 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v18);
  v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v16);
  v21 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v21 = (__n128 *)((char *)a2 + 64 * v14);
  v22 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v22 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v23 = v10(*v22, *v21, *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v23;
}

float cikernel::_drr_g(double a1)
{
  return *((float *)&a1 + 1);
}

float cikernel::_drr_b(__n128 a1)
{
  return a1.n128_f32[2];
}

float cikernel::_drr_a(__n128 a1)
{
  return a1.n128_f32[3];
}

__n64 cikernel::_drr_smoothstepRh(float a1, float a2)
{
  float v2;
  float v3;
  BOOL v4;
  float v5;
  __n64 result;

  v2 = a1 / a2;
  if (v2 <= 1.0)
    v3 = v2;
  else
    v3 = 1.0;
  v4 = v2 < 0.0;
  v5 = 0.0;
  if (!v4)
    v5 = v3;
  result.n64_f32[0] = (float)(v5 * v5) * (float)((float)(v5 * -2.0) + 3.0);
  result.n64_u32[1] = 0;
  return result;
}

double cikernel::_drr_maxmask(float32x4_t a1, float32x4_t a2)
{
  if (a1.f32[0] > 0.0)
    a1.i64[0] = vmaxnmq_f32(a1, a2).u64[0];
  return *(double *)a1.i64;
}

float cikernel::_drr_maxScalarRh(float a1, float a2)
{
  return fmaxf(a1, a2);
}

double cikernel::_drr_minimumRh(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vminnmq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_drr_multiply(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vmulq_f32(a1, a2).u64[0];
  return result;
}

double cikernel::_drr_refilter_chan(float a1)
{
  double v1;

  *(float *)&v1 = a1;
  *((float *)&v1 + 1) = a1;
  return v1;
}

float cikernel::_drr_binarize(float a1)
{
  double v1;

  v1 = 0.0;
  if (a1 > 0.00001)
    return 1.0;
  return v1;
}

float cikernel::_drr_binarize_inv(float a1)
{
  double v1;

  v1 = 1.0;
  if (a1 > 0.00001)
    return 0.0;
  return v1;
}

double cikernel::_drr_binarize_alpha(float32x4_t a1, float a2, float a3)
{
  BOOL v3;
  double v4;
  float v5;
  float32x4_t v6;
  float v7;
  double result;

  v3 = a2 <= 0.001;
  v4 = 0.0;
  if (!v3)
    v4 = 1.0;
  v5 = v4;
  v6 = vmulq_n_f32(a1, v5);
  v7 = 1.0;
  if (fminf(1.0 - v6.f32[0], v6.f32[0]) <= a3)
    v7 = 0.0;
  *(_QWORD *)&result = vmulq_n_f32(v6, v7).u64[0];
  return result;
}

double cikernel::_drr_binarize_alpha_inv(float32x4_t a1, float a2, float a3)
{
  BOOL v3;
  double v4;
  float v5;
  float32x4_t v6;
  float v7;
  double result;

  v3 = a2 <= 0.001;
  v4 = 1.0;
  if (!v3)
    v4 = 0.0;
  v5 = v4;
  v6 = vmulq_n_f32(a1, v5);
  v7 = 1.0;
  if (fminf(1.0 - v6.f32[0], v6.f32[0]) <= a3)
    v7 = 0.0;
  *(_QWORD *)&result = vmulq_n_f32(v6, v7).u64[0];
  return result;
}

double cikernel::_drr_conditionalZeroRh(float32x4_t a1, float a2, float a3)
{
  BOOL v3;
  float v4;
  double result;

  v3 = a2 <= a3;
  v4 = 0.0;
  if (!v3)
    v4 = 1.0;
  *(_QWORD *)&result = vmulq_n_f32(a1, v4).u64[0];
  return result;
}

__n64 cikernel::_drr_chromaexc(float32x4_t a1, float32x4_t a2, float a3, float a4, float32_t a5)
{
  float32x4_t v5;
  float32x4_t v6;
  float v7;
  float v8;
  __n64 result;

  v5 = vsubq_f32(a2, a1);
  v6 = vmulq_f32(v5, v5);
  LODWORD(v7) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).u32[0];
  v8 = fminf(a2.f32[0], a1.f32[0]) * a3;
  if ((float)(fmaxf(a2.f32[0] - fminf(a2.f32[1], a2.f32[2]), 0.0) / fmaxf(a2.f32[0], 0.00001)) < a4 && a2.f32[0] > a5
    || v7 < v8)
  {
    result.n64_f32[0] = 0.0;
  }
  else
  {
    result.n64_f32[0] = 1.0;
  }
  result.n64_u32[1] = 0;
  return result;
}

__n64 cikernel::_drr_detect_specs(int8x16_t _Q0, int8x16_t _Q1, float _S2, int8x16_t a4)
{
  float v4;
  int8x16_t v9;
  float v10;
  float v11;
  float v12;
  __n64 result;

  v4 = fminf(*(float *)_Q1.i32, *(float *)&_Q1.i32[2]);
  __asm { FMLS            S0, S2, V1.S[1] }
  _Q1.i32[0] = 1.0;
  v9.i64[0] = 0x8000000080000000;
  v9.i64[1] = 0x8000000080000000;
  LODWORD(v10) = vbslq_s8(v9, _Q1, _Q0).u32[0];
  if (*(float *)_Q0.i32 == 0.0)
    v10 = 0.0;
  v11 = v4 * fmaxf(v10, 0.0);
  *(float *)a4.i32 = v11 - *(float *)a4.i32;
  LODWORD(v12) = vbslq_s8(v9, _Q1, a4).u32[0];
  if (*(float *)a4.i32 == 0.0)
    v12 = 0.0;
  result.n64_f32[0] = 1.0 - (float)(v11 * fmaxf(v12, 0.0));
  result.n64_u32[1] = 0;
  return result;
}

__n64 cikernel::_drr_mmv(CI *a1, float32x2_t a2, float32x2_t a3, float32x2_t a4, float a5, float a6, float a7, float a8, float a9)
{
  float32x2_t v14;
  int32x2_t v15;
  float32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;
  int32x2_t v19;
  float32x2_t v20;
  int32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v29;
  __n64 result;

  v14 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v15 = (int32x2_t)vmul_f32(a3, v14);
  v16 = vsub_f32(v14, vmul_n_f32(a3, vadd_f32((float32x2_t)v15, (float32x2_t)vdup_lane_s32(v15, 1)).f32[0]));
  v17 = (int32x2_t)vmul_f32(a4, v14);
  v18 = vdup_lane_s32(v17, 1);
  v19 = (int32x2_t)vmul_n_f32(a4, vadd_f32((float32x2_t)v17, (float32x2_t)v18).f32[0]);
  v20 = vsub_f32(v14, (float32x2_t)v19);
  v21 = (int32x2_t)vmul_f32(v16, v16);
  v22 = (int32x2_t)vmul_f32(v20, v20);
  *(float *)v19.i32 = a5 * a6;
  *(float *)v18.i32 = a5 - (float)(a5 * a6);
  v23 = vdiv_f32(vsub_f32(vmul_f32(vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(v21, v22), (float32x2_t)vzip2_s32(v21, v22))), (float32x2_t)__PAIR64__(LODWORD(a8), LODWORD(a7))), (float32x2_t)vdup_lane_s32(v19, 0)), (float32x2_t)vdup_lane_s32(v18, 0));
  __asm { FMOV            V2.2S, #1.0 }
  v29 = (float32x2_t)vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v23, _D2), (int8x8_t)_D2, (int8x8_t)v23), (int8x8_t)vcltz_f32(v23));
  __asm { FMOV            V4.2S, #3.0 }
  result.n64_u64[0] = (unint64_t)vsub_f32(_D2, vmul_f32(vmul_f32(v29, v29), vmla_f32(_D4, (float32x2_t)0xC0000000C0000000, v29)));
  result.n64_f32[0] = vmul_lane_f32((float32x2_t)result.n64_u64[0], (float32x2_t)result.n64_u64[0], 1).f32[0];
  if (result.n64_f32[0] > a9)
    result.n64_f32[0] = 1.0;
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_f2_f2_f2_f_f_f_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(double, double, double, float, float, float, float, float);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  double *v22;
  double *v23;
  double *v24;
  __int128 v25;
  int v26;
  double (*v27)(double, double, double, float, float, float, float, float);
  uint64_t v28;
  uint64_t v29;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(double, double, double, float, float, float, float, float))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_QWORD *)(v9 + 80);
  v18 = *(_QWORD *)(v9 + 104);
  v19 = *(_QWORD *)(v9 + 128);
  v20 = *(_QWORD *)(v9 + 152);
  v21 = *(_QWORD *)(v9 + 176);
  if (*(_BYTE *)(a1 + 64))
  {
    v27 = *(double (**)(double, double, double, float, float, float, float, float))(a1 + 24);
    v28 = *(_QWORD *)(v9 + 152);
    v29 = *(_QWORD *)(v9 + 128);
    v26 = *(_DWORD *)(v9 + 64);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 200)), a2);
    v15 = v26;
    v20 = v28;
    v19 = v29;
    v10 = v27;
  }
  v22 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v22 = (double *)((char *)a2 + 64 * v16);
  v23 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v23 = (double *)((char *)a2 + 64 * v14);
  v24 = (double *)(a3 + 16 * v12);
  if (v11 != 5)
    v24 = (double *)((char *)a2 + 64 * v12);
  *(double *)&v25 = v10(*v24, *v23, *v22, *((float *)a2 + 16 * v17), *((float *)a2 + 16 * v18), *((float *)a2 + 16 * v19), *((float *)a2 + 16 * v20), *((float *)a2 + 16 * v21));
  *(_OWORD *)(a3 + 16 * a7) = v25;
}

__n64 cikernel::_drr_mmi(CI *a1, float32x2_t a2, float32x2_t a3, float32x2_t a4, float a5, float a6, float a7, float a8, float a9)
{
  float32x2_t v14;
  int32x2_t v15;
  float32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;
  int32x2_t v19;
  float32x2_t v20;
  int32x2_t v21;
  int32x2_t v22;
  float32x2_t v23;
  float32x2_t v29;
  __n64 result;

  v14 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v15 = (int32x2_t)vmul_f32(a3, v14);
  v16 = vsub_f32(v14, vmul_n_f32(a3, vadd_f32((float32x2_t)v15, (float32x2_t)vdup_lane_s32(v15, 1)).f32[0]));
  v17 = (int32x2_t)vmul_f32(a4, v14);
  v18 = vdup_lane_s32(v17, 1);
  v19 = (int32x2_t)vmul_n_f32(a4, vadd_f32((float32x2_t)v17, (float32x2_t)v18).f32[0]);
  v20 = vsub_f32(v14, (float32x2_t)v19);
  v21 = (int32x2_t)vmul_f32(v16, v16);
  v22 = (int32x2_t)vmul_f32(v20, v20);
  *(float *)v19.i32 = a5 * a6;
  *(float *)v18.i32 = a5 - (float)(a5 * a6);
  v23 = vdiv_f32(vsub_f32(vmul_f32(vsqrt_f32(vadd_f32((float32x2_t)vzip1_s32(v21, v22), (float32x2_t)vzip2_s32(v21, v22))), (float32x2_t)__PAIR64__(LODWORD(a8), LODWORD(a7))), (float32x2_t)vdup_lane_s32(v19, 0)), (float32x2_t)vdup_lane_s32(v18, 0));
  __asm { FMOV            V2.2S, #1.0 }
  v29 = (float32x2_t)vbic_s8(vbsl_s8((int8x8_t)vcgt_f32(v23, _D2), (int8x8_t)_D2, (int8x8_t)v23), (int8x8_t)vcltz_f32(v23));
  __asm { FMOV            V4.2S, #3.0 }
  result.n64_u64[0] = (unint64_t)vsub_f32(_D2, vmul_f32(vmul_f32(v29, v29), vmla_f32(_D4, (float32x2_t)0xC0000000C0000000, v29)));
  result.n64_f32[0] = vmul_lane_f32((float32x2_t)result.n64_u64[0], (float32x2_t)result.n64_u64[0], 1).f32[0];
  if (result.n64_f32[0] > a9)
    result.n64_f32[0] = 1.0;
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_s_f2_f2_f_f_f_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, double, double, float, float, float, float, float);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  double *v22;
  double *v23;
  __n128 *v24;
  __int128 v25;
  int v26;
  double (*v27)(__n128, double, double, float, float, float, float, float);
  uint64_t v28;
  uint64_t v29;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, double, double, float, float, float, float, float))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_QWORD *)(v9 + 80);
  v18 = *(_QWORD *)(v9 + 104);
  v19 = *(_QWORD *)(v9 + 128);
  v20 = *(_QWORD *)(v9 + 152);
  v21 = *(_QWORD *)(v9 + 176);
  if (*(_BYTE *)(a1 + 64))
  {
    v27 = *(double (**)(__n128, double, double, float, float, float, float, float))(a1 + 24);
    v28 = *(_QWORD *)(v9 + 152);
    v29 = *(_QWORD *)(v9 + 128);
    v26 = *(_DWORD *)(v9 + 64);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 200)), a2);
    v15 = v26;
    v20 = v28;
    v19 = v29;
    v10 = v27;
  }
  v22 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v22 = (double *)((char *)a2 + 64 * v16);
  v23 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v23 = (double *)((char *)a2 + 64 * v14);
  v24 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v24 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v25 = v10(*v24, *v23, *v22, *((float *)a2 + 16 * v17), *((float *)a2 + 16 * v18), *((float *)a2 + 16 * v19), *((float *)a2 + 16 * v20), *((float *)a2 + 16 * v21));
  *(_OWORD *)(a3 + 16 * a7) = v25;
}

__n64 cikernel::_drr_puncture2(CI *a1, float32x2_t a2, float a3, float a4, double a5)
{
  float32x2_t v7;
  float32x2_t v8;
  float v9;
  float v10;
  BOOL v11;
  float v12;
  __n64 result;

  v7 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v8 = vmul_f32(v7, v7);
  v9 = (float)(vmlas_n_f32(COERCE_FLOAT(vmul_f32(*(float32x2_t *)&a5, v8).i32[1]), *(float *)&a5, v8.f32[0])
             - (float)((float)(a3 * a4) * a3))
     / (float)((float)(a3 * a3) - (float)((float)(a3 * a4) * a3));
  if (v9 <= 1.0)
    v10 = v9;
  else
    v10 = 1.0;
  v11 = v9 < 0.0;
  v12 = 0.0;
  if (!v11)
    v12 = v10;
  result.n64_f32[0] = 1.0 - (float)((float)(v12 * v12) * (float)((float)(v12 * -2.0) + 3.0));
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_f2_f_f_f2(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, double, float, float, double);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  double *v18;
  double *v19;
  __int128 v20;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, double, float, float, double))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  v16 = *(_DWORD *)(v10 + 88);
  v17 = *(_QWORD *)(v10 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
  v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (double *)((char *)a2 + 64 * v17);
  v19 = (double *)(a3 + 16 * v13);
  if (v12 != 5)
    v19 = (double *)((char *)a2 + 64 * v13);
  *(double *)&v20 = v11(a1, *v19, *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_drr_puncture2_hard(CI *a1, float32x2_t a2, float a3, double a4, double a5)
{
  float32x2_t v6;
  float v7;
  int32x2_t v8;
  double result;

  v6 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v8 = (int32x2_t)vmul_f32(v6, v6);
  v7 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(*(float32x2_t *)&a5, *(float32x2_t *)&v8).i32[1]), *(float *)&a5, *(float *)v8.i32);
  v8.i32[0] = 0;
  if (v7 <= (float)(a3 * a3))
    *(float *)v8.i32 = 1.0;
  *(_QWORD *)&result = vdupq_lane_s32(v8, 0).u64[0];
  return result;
}

__n64 cikernel::_drr_rcsoft(CI *a1, double a2, float a3, float a4, float a5)
{
  _QWORD *DC;
  float v9;
  float v10;
  BOOL v11;
  float v12;
  __n64 result;

  DC = (_QWORD *)CI::getDC(a1);
  v9 = (float)((float)((float)((float)((float)(COERCE_FLOAT(HIDWORD(*DC)) - *((float *)&a2 + 1))
                                     * (float)(COERCE_FLOAT(HIDWORD(*DC)) - *((float *)&a2 + 1)))
                             * a5)
                     + (float)((float)((float)(COERCE_FLOAT(*DC) - *(float *)&a2)
                                     * (float)(COERCE_FLOAT(*DC) - *(float *)&a2))
                             * a5))
             - (float)(a3 * a4))
     / (float)(a3 - (float)(a3 * a4));
  if (v9 <= 1.0)
    v10 = (float)((float)((float)((float)((float)(COERCE_FLOAT(HIDWORD(*DC)) - *((float *)&a2 + 1))
                                        * (float)(COERCE_FLOAT(HIDWORD(*DC)) - *((float *)&a2 + 1)))
                                * a5)
                        + (float)((float)((float)(COERCE_FLOAT(*DC) - *(float *)&a2)
                                        * (float)(COERCE_FLOAT(*DC) - *(float *)&a2))
                                * a5))
                - (float)(a3 * a4))
        / (float)(a3 - (float)(a3 * a4));
  else
    v10 = 1.0;
  v11 = v9 < 0.0;
  v12 = 0.0;
  if (!v11)
    v12 = v10;
  result.n64_f32[0] = 1.0 - (float)((float)(v12 * v12) * (float)((float)(v12 * -2.0) + 3.0));
  result.n64_u32[1] = 0;
  return result;
}

void CI::f4_sr_sr_f_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v11;
  double (*v12)(uint64_t, uint64_t, float, float);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;

  v11 = *(_QWORD **)(a1 + 48);
  v12 = *(double (**)(uint64_t, uint64_t, float, float))(a1 + 24);
  v13 = v11[1];
  v14 = v11[4];
  v15 = v11[7];
  v16 = v11[10];
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * v11[13]), a2);
  *(double *)&v17 = v12(a4 + 80 * v13, a4 + 80 * v14, *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16));
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

int8x8_t cikernel::_drr_pclip(int8x8_t a1, int32x2_t a2)
{
  return vbic_s8(a1, (int8x8_t)vcgt_f32((float32x2_t)vdup_lane_s32(a2, 0), (float32x2_t)a1));
}

double cikernel::_drr_specular(__n128 a1)
{
  a1.n128_f32[0] = (float)((float)(a1.n128_f32[2] + vaddv_f32((float32x2_t)a1.n128_u64[0]))
                         - fminf(fminf(a1.n128_f32[0], a1.n128_f32[1]), a1.n128_f32[2]))
                 * 0.5;
  a1.n128_u64[0] = vdupq_lane_s32((int32x2_t)a1.n128_u64[0], 0).u64[0];
  return a1.n128_f64[0];
}

__n64 cikernel::_drr_rawred_sm(float32x4_t a1, float a2, float a3)
{
  __n64 result;
  float32x4_t v4;
  float32x4_t v5;
  float v6;

  if (a1.f32[0] >= 0.005)
  {
    v4 = vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x3EAAAAABu));
    v5 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1)));
    LODWORD(v6) = vsubq_f32(a1, v5).u32[0];
    v5.f32[0] = fminf(fmaxf(a1.f32[0] - a1.f32[1], 0.0) / fmaxf(a1.f32[0] + a1.f32[1], 0.00001), fmaxf(a1.f32[0] - a1.f32[2], 0.0) / fmaxf(a1.f32[0] + a1.f32[2], 0.00001))* (float)((float)(vmlas_n_f32((float)(a1.f32[1] - v5.f32[0]) * (float)(a1.f32[1] - v5.f32[0]), v6, v6)+ (float)((float)(a1.f32[2] - v5.f32[0]) * (float)(a1.f32[2] - v5.f32[0])))/ fmaxf(v5.f32[0], 0.0001));
    result.n64_f32[0] = (float)(fmaxf(a1.f32[0] - (float)(a2 * fmaxf(a1.f32[1], a1.f32[2])), 0.0) * a3)
                      + (float)((float)((float)(v5.f32[0] * 10.0) * (float)(v5.f32[0] * 10.0)) * (float)(1.0 - a3));
    result.n64_u32[1] = 0;
  }
  else
  {
    return 0;
  }
  return result;
}

__n64 cikernel::_drr_rawred_large(float32x4_t a1, float a2, float a3)
{
  __n64 result;
  float32x4_t v4;
  float32x4_t v5;
  float v6;

  if (a1.f32[0] >= 0.005)
  {
    v4 = vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x3EAAAAABu));
    v5 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1)));
    LODWORD(v6) = vsubq_f32(a1, v5).u32[0];
    result.n64_f32[0] = (float)(a1.f32[0] * a2)
                      + (float)((float)(fminf(fmaxf(a1.f32[0] - a1.f32[1], 0.0) / fmaxf(a1.f32[0] + a1.f32[1], 0.00001), fmaxf(a1.f32[0] - a1.f32[2], 0.0) / fmaxf(a1.f32[0] + a1.f32[2], 0.00001))* (float)((float)(1.0 - a3)+ (float)((float)((float)(vmlas_n_f32((float)(a1.f32[1] - v5.f32[0])* (float)(a1.f32[1] - v5.f32[0]), v6, v6)+ (float)((float)(a1.f32[2] - v5.f32[0])* (float)(a1.f32[2] - v5.f32[0])))/ fmaxf(v5.f32[0], 0.0001))* a3)))* (float)(1.0 - a2));
    result.n64_u32[1] = 0;
  }
  else
  {
    return 0;
  }
  return result;
}

void ReductionROIwh(CGRect cgrect, float a2, float a3, float a4, float a5)
{
  CGRect v7;

  ReductionROIw(cgrect, a2, a4);
  ReductionROIh(v7, a3, a5);
}

void ReductionROIh(CGRect a1, float a2, float a3)
{
  double v3;
  CGFloat v4;
  CGFloat v5;

  v3 = a2;
  v4 = a1.origin.y * v3;
  v5 = a1.size.height * v3;
  CGRectIntegral(a1);
}

void ReductionROIw(CGRect a1, float a2, float a3)
{
  double v3;
  CGFloat v4;
  CGFloat v5;

  v3 = a2;
  v4 = a1.origin.x * v3;
  v5 = a1.size.width * v3;
  CGRectIntegral(a1);
}

void ReductionROI(CGRect a1, float a2, float a3)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  CGAffineTransform v7;
  CGAffineTransform v8;
  CGRect v9;
  CGRect v10;

  height = a1.size.height;
  width = a1.size.width;
  y = a1.origin.y;
  x = a1.origin.x;
  memset(&v8, 0, sizeof(v8));
  CGAffineTransformMakeScale(&v8, a2, a3);
  v7 = v8;
  v9.origin.x = x;
  v9.origin.y = y;
  v9.size.width = width;
  v9.size.height = height;
  v10 = CGRectApplyAffineTransform(v9, &v7);
  CGRectIntegral(v10);
}

double cikernel::_reduceCrop(cikernel *this, SamplerObj *a2, double a3, float64x2_t a4, double a5, double a6, int8x16_t a7, uint8x8_t a8, double a9, int8x16_t a10)
{
  double v10;
  int8x16_t v11;
  CI *v12;
  float32x4_t v13;
  float32x4_t v14;
  double result;
  int8x16_t v16;

  a7.i32[0] = 0.5;
  LODWORD(a5) = *((_DWORD *)this + 7);
  *(float *)&v10 = *((float *)this + 6)
                 + (float)((float)(*((float *)this + 5) * 0.5) + (float)(*((float *)this + 4) * 0.5));
  LODWORD(a6) = *((_DWORD *)this + 9);
  *(float *)a4.f64 = *(float *)&a6 + (float)((float)(*((float *)this + 8) * 0.5) + (float)(*(float *)&a5 * 0.5));
  *((float *)&v10 + 1) = *(float *)a4.f64;
  *(double *)v11.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v10, a4, a5, a6, a7, a8, a9, a10);
  v16 = v11;
  *(float32x2_t *)v13.f32 = vabs_f32(vadd_f32(*(float32x2_t *)CI::getDC(v12), (float32x2_t)0xBF000000BF000000));
  v13.f32[0] = fmaxf(v13.f32[0], v13.f32[1]);
  v14.i64[0] = COERCE_UNSIGNED_INT(0.5) | 0xBF00000000000000;
  *(_QWORD *)&result = vandq_s8(v16, (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v14, v13), 0)).u64[0];
  return result;
}

double cikernel::_areaAvg8(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  float32x2_t v11;
  double v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  double v19;
  double v20;
  uint8x8_t v21;
  int8x16_t v22;
  float64x2_t v23;
  double v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x2_t v27;
  double v28;
  double v29;
  int8x16_t v30;
  double v31;
  uint8x8_t v32;
  float64x2_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x2_t v36;
  double v37;
  double v38;
  int8x16_t v39;
  double v40;
  uint8x8_t v41;
  float64x2_t v42;
  int8x16_t v43;
  float32x4_t v44;
  float32x2_t v45;
  double v46;
  double v47;
  int8x16_t v48;
  double v49;
  uint8x8_t v50;
  float64x2_t v51;
  int8x16_t v52;
  float32x4_t v53;
  float32x2_t v55;
  double v56;
  double v57;
  int8x16_t v58;
  double v59;
  uint8x8_t v60;
  float64x2_t v61;
  int8x16_t v62;
  float32x4_t v63;
  float32x2_t v64;
  double v65;
  double v66;
  int8x16_t v67;
  double v68;
  uint8x8_t v69;
  float64x2_t v70;
  int8x16_t v71;
  float32x4_t v72;
  float32x2_t v73;
  double v74;
  double v75;
  int8x16_t v76;
  double v77;
  uint8x8_t v78;
  float64x2_t v79;
  int8x16_t v80;
  float32x4_t v81;
  float32x2_t v82;
  double v83;
  double v84;
  int8x16_t v85;
  double v86;
  uint8x8_t v87;
  float64x2_t v88;
  int8x16_t v89;
  float32x4_t v90;
  float32x2_t v91;
  double v92;
  double v93;
  int8x16_t v94;
  double v95;
  uint8x8_t v96;
  float64x2_t v97;
  int8x16_t v98;
  float32x4_t v99;
  float32x2_t v101;
  double v102;
  double v103;
  int8x16_t v104;
  double v105;
  uint8x8_t v106;
  float64x2_t v107;
  int8x16_t v108;
  float32x4_t v109;
  float32x2_t v110;
  double v111;
  double v112;
  int8x16_t v113;
  double v114;
  uint8x8_t v115;
  float64x2_t v116;
  int8x16_t v117;
  float32x4_t v118;
  float32x2_t v119;
  double v120;
  double v121;
  int8x16_t v122;
  double v123;
  uint8x8_t v124;
  float64x2_t v125;
  int8x16_t v126;
  float32x4_t v127;
  float32x2_t v128;
  double v129;
  double v130;
  int8x16_t v131;
  double v132;
  uint8x8_t v133;
  float64x2_t v134;
  int8x16_t v135;
  float32x4_t v136;
  float32x2_t v137;
  double v138;
  double v139;
  int8x16_t v140;
  double v141;
  uint8x8_t v142;
  float64x2_t v143;
  int8x16_t v144;
  float32x4_t v145;
  float32x2_t v147;
  double v148;
  double v149;
  int8x16_t v150;
  double v151;
  uint8x8_t v152;
  float64x2_t v153;
  int8x16_t v154;
  float32x4_t v155;
  double result;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;

  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1090519040;
  v5 = vmul_f32(*DC, (float32x2_t)0x4100000041000000);
  __asm { FMOV            V0.2S, #-3.0 }
  v11 = vadd_f32(v5, _D0);
  *(float *)&v12 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v11, 1), *((float *)this + 4), v11.f32[0]);
  LODWORD(v13) = *((_DWORD *)this + 7);
  v14.i32[0] = *((_DWORD *)this + 9);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *((float *)this + 6) + *(float *)&v12;
  *(float *)v4.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v11, v4, v12, v13, v15, v14, v16, v17);
  v157 = v18;
  *(float32x2_t *)v18.f32 = vadd_f32(v5, (float32x2_t)0xC0400000BF800000);
  *(float *)&v19 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v18.f32, 1), *((float *)this + 4), v18.f32[0]);
  LODWORD(v20) = *((_DWORD *)this + 7);
  v21.i32[0] = *((_DWORD *)this + 9);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v18.f32, 1), *(float *)&v20, v18.f32[0]);
  v18.f32[0] = *((float *)this + 6) + *(float *)&v19;
  *(float *)v23.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  v18.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v18.i64, v23, v19, v20, v22, v21, v24, v25);
  v27 = vadd_f32(v5, (float32x2_t)0xC04000003F800000);
  *(float *)&v28 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v27, 1), *((float *)this + 4), v27.f32[0]);
  LODWORD(v29) = *((_DWORD *)this + 6);
  v30.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v31) = *((_DWORD *)this + 9);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v27, 1), *(float *)v30.i32, v27.f32[0]);
  v33 = (float64x2_t)v157;
  v158 = vaddq_f32(v157, v26);
  v26.f32[0] = *(float *)&v29 + *(float *)&v28;
  *(float *)v33.f64 = *(float *)&v31 + *(float *)v32.i32;
  v26.f32[1] = *(float *)&v31 + *(float *)v32.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v26.i64, v33, v29, v28, v30, v32, v31, v34);
  v36 = vadd_f32(v5, (float32x2_t)0xC040000040400000);
  *(float *)&v37 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v36, 1), *((float *)this + 4), v36.f32[0]);
  LODWORD(v38) = *((_DWORD *)this + 6);
  v39.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v40) = *((_DWORD *)this + 9);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v36, 1), *(float *)v39.i32, v36.f32[0]);
  v42 = (float64x2_t)v158;
  v159 = vaddq_f32(v158, v35);
  v35.f32[0] = *(float *)&v38 + *(float *)&v37;
  *(float *)v42.f64 = *(float *)&v40 + *(float *)v41.i32;
  v35.f32[1] = *(float *)&v40 + *(float *)v41.i32;
  *(double *)v44.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v35.i64, v42, v38, v37, v39, v41, v40, v43);
  v45 = vadd_f32(v5, (float32x2_t)0xBF800000C0400000);
  *(float *)&v46 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v45, 1), *((float *)this + 4), v45.f32[0]);
  LODWORD(v47) = *((_DWORD *)this + 6);
  v48.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v49) = *((_DWORD *)this + 9);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v45, 1), *(float *)v48.i32, v45.f32[0]);
  v51 = (float64x2_t)v159;
  v160 = vaddq_f32(v159, v44);
  v44.f32[0] = *(float *)&v47 + *(float *)&v46;
  *(float *)v51.f64 = *(float *)&v49 + *(float *)v50.i32;
  v44.f32[1] = *(float *)&v49 + *(float *)v50.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v44.i64, v51, v47, v46, v48, v50, v49, v52);
  __asm { FMOV            V1.2S, #-1.0 }
  v55 = vadd_f32(v5, _D1);
  *(float *)&v56 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v55, 1), *((float *)this + 4), v55.f32[0]);
  LODWORD(v57) = *((_DWORD *)this + 6);
  v58.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v59) = *((_DWORD *)this + 9);
  *(float *)v60.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v55, 1), *(float *)v58.i32, v55.f32[0]);
  v61 = (float64x2_t)v160;
  v161 = vaddq_f32(v160, v53);
  v53.f32[0] = *(float *)&v57 + *(float *)&v56;
  *(float *)v61.f64 = *(float *)&v59 + *(float *)v60.i32;
  v53.f32[1] = *(float *)&v59 + *(float *)v60.i32;
  *(double *)v63.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v53.i64, v61, v57, v56, v58, v60, v59, v62);
  v64 = vadd_f32(v5, (float32x2_t)0xBF8000003F800000);
  *(float *)&v65 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v64, 1), *((float *)this + 4), v64.f32[0]);
  LODWORD(v66) = *((_DWORD *)this + 6);
  v67.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v68) = *((_DWORD *)this + 9);
  *(float *)v69.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v64, 1), *(float *)v67.i32, v64.f32[0]);
  v70 = (float64x2_t)v161;
  v162 = vaddq_f32(v161, v63);
  v63.f32[0] = *(float *)&v66 + *(float *)&v65;
  *(float *)v70.f64 = *(float *)&v68 + *(float *)v69.i32;
  v63.f32[1] = *(float *)&v68 + *(float *)v69.i32;
  *(double *)v72.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v63.i64, v70, v66, v65, v67, v69, v68, v71);
  v73 = vadd_f32(v5, (float32x2_t)0xBF80000040400000);
  *(float *)&v74 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v73, 1), *((float *)this + 4), v73.f32[0]);
  LODWORD(v75) = *((_DWORD *)this + 6);
  v76.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v77) = *((_DWORD *)this + 9);
  *(float *)v78.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v73, 1), *(float *)v76.i32, v73.f32[0]);
  v79 = (float64x2_t)v162;
  v163 = vaddq_f32(v162, v72);
  v72.f32[0] = *(float *)&v75 + *(float *)&v74;
  *(float *)v79.f64 = *(float *)&v77 + *(float *)v78.i32;
  v72.f32[1] = *(float *)&v77 + *(float *)v78.i32;
  *(double *)v81.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v72.i64, v79, v75, v74, v76, v78, v77, v80);
  v82 = vadd_f32(v5, (float32x2_t)0x3F800000C0400000);
  *(float *)&v83 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v82, 1), *((float *)this + 4), v82.f32[0]);
  LODWORD(v84) = *((_DWORD *)this + 6);
  v85.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v86) = *((_DWORD *)this + 9);
  *(float *)v87.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v82, 1), *(float *)v85.i32, v82.f32[0]);
  v88 = (float64x2_t)v163;
  v164 = vaddq_f32(v163, v81);
  v81.f32[0] = *(float *)&v84 + *(float *)&v83;
  *(float *)v88.f64 = *(float *)&v86 + *(float *)v87.i32;
  v81.f32[1] = *(float *)&v86 + *(float *)v87.i32;
  *(double *)v90.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v81.i64, v88, v84, v83, v85, v87, v86, v89);
  v91 = vadd_f32(v5, (float32x2_t)0x3F800000BF800000);
  *(float *)&v92 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v91, 1), *((float *)this + 4), v91.f32[0]);
  LODWORD(v93) = *((_DWORD *)this + 6);
  v94.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v95) = *((_DWORD *)this + 9);
  *(float *)v96.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v91, 1), *(float *)v94.i32, v91.f32[0]);
  v97 = (float64x2_t)v164;
  v165 = vaddq_f32(v164, v90);
  v90.f32[0] = *(float *)&v93 + *(float *)&v92;
  *(float *)v97.f64 = *(float *)&v95 + *(float *)v96.i32;
  v90.f32[1] = *(float *)&v95 + *(float *)v96.i32;
  *(double *)v99.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v90.i64, v97, v93, v92, v94, v96, v95, v98);
  __asm { FMOV            V1.2S, #1.0 }
  v101 = vadd_f32(v5, _D1);
  *(float *)&v102 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v101, 1), *((float *)this + 4), v101.f32[0]);
  LODWORD(v103) = *((_DWORD *)this + 6);
  v104.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v105) = *((_DWORD *)this + 9);
  *(float *)v106.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v101, 1), *(float *)v104.i32, v101.f32[0]);
  v107 = (float64x2_t)v165;
  v166 = vaddq_f32(v165, v99);
  v99.f32[0] = *(float *)&v103 + *(float *)&v102;
  *(float *)v107.f64 = *(float *)&v105 + *(float *)v106.i32;
  v99.f32[1] = *(float *)&v105 + *(float *)v106.i32;
  *(double *)v109.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v99.i64, v107, v103, v102, v104, v106, v105, v108);
  v110 = vadd_f32(v5, (float32x2_t)0x3F80000040400000);
  *(float *)&v111 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v110, 1), *((float *)this + 4), v110.f32[0]);
  LODWORD(v112) = *((_DWORD *)this + 6);
  v113.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v114) = *((_DWORD *)this + 9);
  *(float *)v115.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v110, 1), *(float *)v113.i32, v110.f32[0]);
  v116 = (float64x2_t)v166;
  v167 = vaddq_f32(v166, v109);
  v109.f32[0] = *(float *)&v112 + *(float *)&v111;
  *(float *)v116.f64 = *(float *)&v114 + *(float *)v115.i32;
  v109.f32[1] = *(float *)&v114 + *(float *)v115.i32;
  *(double *)v118.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v109.i64, v116, v112, v111, v113, v115, v114, v117);
  v119 = vadd_f32(v5, (float32x2_t)0x40400000C0400000);
  *(float *)&v120 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v119, 1), *((float *)this + 4), v119.f32[0]);
  LODWORD(v121) = *((_DWORD *)this + 6);
  v122.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v123) = *((_DWORD *)this + 9);
  *(float *)v124.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v119, 1), *(float *)v122.i32, v119.f32[0]);
  v125 = (float64x2_t)v167;
  v168 = vaddq_f32(v167, v118);
  v118.f32[0] = *(float *)&v121 + *(float *)&v120;
  *(float *)v125.f64 = *(float *)&v123 + *(float *)v124.i32;
  v118.f32[1] = *(float *)&v123 + *(float *)v124.i32;
  *(double *)v127.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v118.i64, v125, v121, v120, v122, v124, v123, v126);
  v128 = vadd_f32(v5, (float32x2_t)0x40400000BF800000);
  *(float *)&v129 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v128, 1), *((float *)this + 4), v128.f32[0]);
  LODWORD(v130) = *((_DWORD *)this + 6);
  v131.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v132) = *((_DWORD *)this + 9);
  *(float *)v133.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v128, 1), *(float *)v131.i32, v128.f32[0]);
  v134 = (float64x2_t)v168;
  v169 = vaddq_f32(v168, v127);
  v127.f32[0] = *(float *)&v130 + *(float *)&v129;
  *(float *)v134.f64 = *(float *)&v132 + *(float *)v133.i32;
  v127.f32[1] = *(float *)&v132 + *(float *)v133.i32;
  *(double *)v136.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v127.i64, v134, v130, v129, v131, v133, v132, v135);
  v137 = vadd_f32(v5, (float32x2_t)0x404000003F800000);
  *(float *)&v138 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v137, 1), *((float *)this + 4), v137.f32[0]);
  LODWORD(v139) = *((_DWORD *)this + 6);
  v140.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v141) = *((_DWORD *)this + 9);
  *(float *)v142.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v137, 1), *(float *)v140.i32, v137.f32[0]);
  v143 = (float64x2_t)v169;
  v170 = vaddq_f32(v169, v136);
  v136.f32[0] = *(float *)&v139 + *(float *)&v138;
  *(float *)v143.f64 = *(float *)&v141 + *(float *)v142.i32;
  v136.f32[1] = *(float *)&v141 + *(float *)v142.i32;
  *(double *)v145.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v136.i64, v143, v139, v138, v140, v142, v141, v144);
  __asm { FMOV            V1.2S, #3.0 }
  v147 = vadd_f32(v5, _D1);
  *(float *)&v148 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v147, 1), *((float *)this + 4), v147.f32[0]);
  LODWORD(v149) = *((_DWORD *)this + 6);
  v150.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v151) = *((_DWORD *)this + 9);
  *(float *)v152.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v147, 1), *(float *)v150.i32, v147.f32[0]);
  v153 = (float64x2_t)v170;
  v171 = vaddq_f32(v170, v145);
  v145.f32[0] = *(float *)&v149 + *(float *)&v148;
  *(float *)v153.f64 = *(float *)&v151 + *(float *)v152.i32;
  v145.f32[1] = *(float *)&v151 + *(float *)v152.i32;
  *(double *)v155.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v145.i64, v153, v149, v148, v150, v152, v151, v154);
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v171, v155), (float32x4_t)vdupq_n_s32(0x3D800000u)).u64[0];
  return result;
}

double cikernel::_areaAvg4(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float32x2_t v9;
  float32x2_t v11;
  double v12;
  double v13;
  uint8x8_t v14;
  int8x16_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  double v19;
  double v20;
  uint8x8_t v21;
  int8x16_t v22;
  float64x2_t v23;
  double v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x2_t v27;
  double v28;
  double v29;
  int8x16_t v30;
  double v31;
  uint8x8_t v32;
  float64x2_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x2_t v37;
  double v38;
  double v39;
  int8x16_t v40;
  double v41;
  uint8x8_t v42;
  float64x2_t v43;
  int8x16_t v44;
  float32x4_t v45;
  double result;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;

  DC = (float32x2_t *)CI::getDC(this);
  __asm { FMOV            V1.2S, #4.0 }
  v9 = vmul_f32(*DC, *(float32x2_t *)&_Q1.f64[0]);
  __asm { FMOV            V0.2S, #-1.0 }
  v11 = vadd_f32(v9, _D0);
  *(float *)&v12 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v11, 1), *((float *)this + 4), v11.f32[0]);
  LODWORD(v13) = *((_DWORD *)this + 7);
  v14.i32[0] = *((_DWORD *)this + 9);
  *(float *)v15.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v11, 1), *(float *)&v13, v11.f32[0]);
  v11.f32[0] = *((float *)this + 6) + *(float *)&v12;
  *(float *)_Q1.f64 = *(float *)v14.i32 + *(float *)v15.i32;
  v11.f32[1] = *(float *)v14.i32 + *(float *)v15.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v11, _Q1, v12, v13, v15, v14, v16, v17);
  v48 = v18;
  *(float32x2_t *)v18.f32 = vadd_f32(v9, (float32x2_t)0xBF8000003F800000);
  *(float *)&v19 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v18.f32, 1), *((float *)this + 4), v18.f32[0]);
  LODWORD(v20) = *((_DWORD *)this + 7);
  v21.i32[0] = *((_DWORD *)this + 9);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v18.f32, 1), *(float *)&v20, v18.f32[0]);
  v18.f32[0] = *((float *)this + 6) + *(float *)&v19;
  *(float *)v23.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  v18.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v26.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v18.i64, v23, v19, v20, v22, v21, v24, v25);
  v27 = vadd_f32(v9, (float32x2_t)0x3F800000BF800000);
  *(float *)&v28 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v27, 1), *((float *)this + 4), v27.f32[0]);
  LODWORD(v29) = *((_DWORD *)this + 6);
  v30.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v31) = *((_DWORD *)this + 9);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v27, 1), *(float *)v30.i32, v27.f32[0]);
  v33 = (float64x2_t)v48;
  v49 = vaddq_f32(v48, v26);
  v26.f32[0] = *(float *)&v29 + *(float *)&v28;
  *(float *)v33.f64 = *(float *)&v31 + *(float *)v32.i32;
  v26.f32[1] = *(float *)&v31 + *(float *)v32.i32;
  *(double *)v35.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v26.i64, v33, v29, v28, v30, v32, v31, v34);
  __asm { FMOV            V1.2S, #1.0 }
  v37 = vadd_f32(v9, _D1);
  *(float *)&v38 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v37, 1), *((float *)this + 4), v37.f32[0]);
  LODWORD(v39) = *((_DWORD *)this + 6);
  v40.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v41) = *((_DWORD *)this + 9);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v37, 1), *(float *)v40.i32, v37.f32[0]);
  v43 = (float64x2_t)v49;
  v50 = vaddq_f32(v49, v35);
  v35.f32[0] = *(float *)&v39 + *(float *)&v38;
  *(float *)v43.f64 = *(float *)&v41 + *(float *)v42.i32;
  v35.f32[1] = *(float *)&v41 + *(float *)v42.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v35.i64, v43, v39, v38, v40, v42, v41, v44);
  __asm { FMOV            V1.4S, #0.25 }
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v50, v45), _Q1).u64[0];
  return result;
}

double cikernel::_areaAvg2(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float32x2_t v4;
  double v5;
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  float64x2_t v9;
  double v10;
  int8x16_t v11;

  DC = (float32x2_t *)CI::getDC(this);
  v4 = vadd_f32(*DC, *DC);
  *(float *)&v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  return CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v9, v5, v6, v8, v7, v10, v11);
}

double cikernel::_vertAvg16(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  double v26;
  uint8x8_t v27;
  float64x2_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x2_t v31;
  double v32;
  double v33;
  int8x16_t v34;
  double v35;
  uint8x8_t v36;
  float64x2_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x2_t v40;
  double v41;
  double v42;
  int8x16_t v43;
  double v44;
  uint8x8_t v45;
  float64x2_t v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x2_t v49;
  double v50;
  double v51;
  int8x16_t v52;
  double v53;
  uint8x8_t v54;
  float64x2_t v55;
  int8x16_t v56;
  float32x4_t v57;
  float32x2_t v58;
  double v59;
  double v60;
  int8x16_t v61;
  double v62;
  uint8x8_t v63;
  float64x2_t v64;
  int8x16_t v65;
  float32x4_t v66;
  float32x2_t v67;
  double v68;
  double v69;
  int8x16_t v70;
  double v71;
  uint8x8_t v72;
  float64x2_t v73;
  int8x16_t v74;
  float32x4_t v75;
  float32x4_t v76;
  double result;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;

  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1098907648;
  v5 = vmul_f32(*DC, (float32x2_t)0x418000003F800000);
  v6 = vadd_f32(v5, (float32x2_t)0xC0E0000000000000);
  *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v6, 1), *((float *)this + 4), v6.f32[0]);
  LODWORD(v8) = *((_DWORD *)this + 7);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *((float *)this + 6) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v6, v4, v7, v8, v10, v9, v11, v12);
  v78 = v13;
  *(float32x2_t *)v13.f32 = vadd_f32(v5, (float32x2_t)0xC0A0000000000000);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v15) = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  v22 = vadd_f32(v5, (float32x2_t)0xC040000000000000);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v22, 1), *((float *)this + 4), v22.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 6);
  v25.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v26) = *((_DWORD *)this + 9);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v22, 1), *(float *)v25.i32, v22.f32[0]);
  v28 = (float64x2_t)v78;
  v79 = vaddq_f32(v78, v21);
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  *(float *)v28.f64 = *(float *)&v26 + *(float *)v27.i32;
  v21.f32[1] = *(float *)&v26 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v21.i64, v28, v24, v23, v25, v27, v26, v29);
  v31 = vadd_f32(v5, (float32x2_t)0xBF80000000000000);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v31, 1), *((float *)this + 4), v31.f32[0]);
  LODWORD(v33) = *((_DWORD *)this + 6);
  v34.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v35) = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v31, 1), *(float *)v34.i32, v31.f32[0]);
  v37 = (float64x2_t)v79;
  v80 = vaddq_f32(v79, v30);
  v30.f32[0] = *(float *)&v33 + *(float *)&v32;
  *(float *)v37.f64 = *(float *)&v35 + *(float *)v36.i32;
  v30.f32[1] = *(float *)&v35 + *(float *)v36.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v30.i64, v37, v33, v32, v34, v36, v35, v38);
  v40 = vadd_f32(v5, (float32x2_t)0x3F80000000000000);
  *(float *)&v41 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v40, 1), *((float *)this + 4), v40.f32[0]);
  LODWORD(v42) = *((_DWORD *)this + 6);
  v43.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v44) = *((_DWORD *)this + 9);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v40, 1), *(float *)v43.i32, v40.f32[0]);
  v46 = (float64x2_t)v80;
  v81 = vaddq_f32(v80, v39);
  v39.f32[0] = *(float *)&v42 + *(float *)&v41;
  *(float *)v46.f64 = *(float *)&v44 + *(float *)v45.i32;
  v39.f32[1] = *(float *)&v44 + *(float *)v45.i32;
  *(double *)v48.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v39.i64, v46, v42, v41, v43, v45, v44, v47);
  v49 = vadd_f32(v5, (float32x2_t)0x4040000000000000);
  *(float *)&v50 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v49, 1), *((float *)this + 4), v49.f32[0]);
  LODWORD(v51) = *((_DWORD *)this + 6);
  v52.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v53) = *((_DWORD *)this + 9);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v49, 1), *(float *)v52.i32, v49.f32[0]);
  v55 = (float64x2_t)v81;
  v82 = vaddq_f32(v81, v48);
  v48.f32[0] = *(float *)&v51 + *(float *)&v50;
  *(float *)v55.f64 = *(float *)&v53 + *(float *)v54.i32;
  v48.f32[1] = *(float *)&v53 + *(float *)v54.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v48.i64, v55, v51, v50, v52, v54, v53, v56);
  v58 = vadd_f32(v5, (float32x2_t)0x40A0000000000000);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v58, 1), *((float *)this + 4), v58.f32[0]);
  LODWORD(v60) = *((_DWORD *)this + 6);
  v61.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v62) = *((_DWORD *)this + 9);
  *(float *)v63.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v58, 1), *(float *)v61.i32, v58.f32[0]);
  v64 = (float64x2_t)v82;
  v83 = vaddq_f32(v82, v57);
  v57.f32[0] = *(float *)&v60 + *(float *)&v59;
  *(float *)v64.f64 = *(float *)&v62 + *(float *)v63.i32;
  v57.f32[1] = *(float *)&v62 + *(float *)v63.i32;
  *(double *)v66.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v57.i64, v64, v60, v59, v61, v63, v62, v65);
  v67 = vadd_f32(v5, (float32x2_t)0x40E0000000000000);
  *(float *)&v68 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v67, 1), *((float *)this + 4), v67.f32[0]);
  LODWORD(v69) = *((_DWORD *)this + 6);
  v70.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v71) = *((_DWORD *)this + 9);
  *(float *)v72.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v67, 1), *(float *)v70.i32, v67.f32[0]);
  v73 = (float64x2_t)v83;
  v84 = vaddq_f32(v83, v66);
  v66.f32[0] = *(float *)&v69 + *(float *)&v68;
  *(float *)v73.f64 = *(float *)&v71 + *(float *)v72.i32;
  v66.f32[1] = *(float *)&v71 + *(float *)v72.i32;
  *(double *)v75.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v66.i64, v73, v69, v68, v70, v72, v71, v74);
  v76.i64[0] = 0x3E0000003E000000;
  v76.i64[1] = 0x3E0000003E000000;
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v84, v75), v76).u64[0];
  return result;
}

double cikernel::_vertAvg8(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  double v26;
  uint8x8_t v27;
  float64x2_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x2_t v31;
  double v32;
  double v33;
  int8x16_t v34;
  double v35;
  uint8x8_t v36;
  float64x2_t v37;
  int8x16_t v38;
  float32x4_t v39;
  double result;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;

  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1090519040;
  v5 = vmul_f32(*DC, (float32x2_t)0x410000003F800000);
  v6 = vadd_f32(v5, (float32x2_t)0xC040000000000000);
  *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v6, 1), *((float *)this + 4), v6.f32[0]);
  LODWORD(v8) = *((_DWORD *)this + 7);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *((float *)this + 6) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v6, v4, v7, v8, v10, v9, v11, v12);
  v46 = v13;
  *(float32x2_t *)v13.f32 = vadd_f32(v5, (float32x2_t)0xBF80000000000000);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v15) = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  v22 = vadd_f32(v5, (float32x2_t)0x3F80000000000000);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v22, 1), *((float *)this + 4), v22.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 6);
  v25.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v26) = *((_DWORD *)this + 9);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v22, 1), *(float *)v25.i32, v22.f32[0]);
  v28 = (float64x2_t)v46;
  v47 = vaddq_f32(v46, v21);
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  *(float *)v28.f64 = *(float *)&v26 + *(float *)v27.i32;
  v21.f32[1] = *(float *)&v26 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v21.i64, v28, v24, v23, v25, v27, v26, v29);
  v31 = vadd_f32(v5, (float32x2_t)0x4040000000000000);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v31, 1), *((float *)this + 4), v31.f32[0]);
  LODWORD(v33) = *((_DWORD *)this + 6);
  v34.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v35) = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v31, 1), *(float *)v34.i32, v31.f32[0]);
  v37 = (float64x2_t)v47;
  v48 = vaddq_f32(v47, v30);
  v30.f32[0] = *(float *)&v33 + *(float *)&v32;
  *(float *)v37.f64 = *(float *)&v35 + *(float *)v36.i32;
  v30.f32[1] = *(float *)&v35 + *(float *)v36.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v30.i64, v37, v33, v32, v34, v36, v35, v38);
  __asm { FMOV            V1.4S, #0.25 }
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v48, v39), _Q1).u64[0];
  return result;
}

double cikernel::_vertAvg4(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  double result;
  float32x4_t v24;

  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1082130432;
  v5 = vmul_f32(*DC, (float32x2_t)0x408000003F800000);
  v6 = vadd_f32(v5, (float32x2_t)0xBF80000000000000);
  *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v6, 1), *((float *)this + 4), v6.f32[0]);
  LODWORD(v8) = *((_DWORD *)this + 7);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *((float *)this + 6) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v6, v4, v7, v8, v10, v9, v11, v12);
  v24 = v13;
  *(float32x2_t *)v13.f32 = vadd_f32(v5, (float32x2_t)0x3F80000000000000);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v15) = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  v22.i64[0] = 0x3F0000003F000000;
  v22.i64[1] = 0x3F0000003F000000;
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v24, v21), v22).u64[0];
  return result;
}

double cikernel::_vertAvg2(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  int8x16_t v11;

  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 0x40000000;
  v5 = vmul_f32(*DC, (float32x2_t)0x400000003F800000);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  return CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v4, v6, v7, v9, v8, v10, v11);
}

double cikernel::_horizAvg16(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  double v26;
  uint8x8_t v27;
  float64x2_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x2_t v31;
  double v32;
  double v33;
  int8x16_t v34;
  double v35;
  uint8x8_t v36;
  float64x2_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x2_t v40;
  double v41;
  double v42;
  int8x16_t v43;
  double v44;
  uint8x8_t v45;
  float64x2_t v46;
  int8x16_t v47;
  float32x4_t v48;
  float32x2_t v49;
  double v50;
  double v51;
  int8x16_t v52;
  double v53;
  uint8x8_t v54;
  float64x2_t v55;
  int8x16_t v56;
  float32x4_t v57;
  float32x2_t v58;
  double v59;
  double v60;
  int8x16_t v61;
  double v62;
  uint8x8_t v63;
  float64x2_t v64;
  int8x16_t v65;
  float32x4_t v66;
  float32x2_t v67;
  double v68;
  double v69;
  int8x16_t v70;
  double v71;
  uint8x8_t v72;
  float64x2_t v73;
  int8x16_t v74;
  float32x4_t v75;
  float32x4_t v76;
  double result;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t v84;

  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1065353216;
  v5 = vmul_f32(*DC, (float32x2_t)0x3F80000041800000);
  v6 = vadd_f32(v5, (float32x2_t)3235905536);
  *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v6, 1), *((float *)this + 4), v6.f32[0]);
  LODWORD(v8) = *((_DWORD *)this + 7);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *((float *)this + 6) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v6, v4, v7, v8, v10, v9, v11, v12);
  v78 = v13;
  *(float32x2_t *)v13.f32 = vadd_f32(v5, (float32x2_t)3231711232);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v15) = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  v22 = vadd_f32(v5, (float32x2_t)3225419776);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v22, 1), *((float *)this + 4), v22.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 6);
  v25.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v26) = *((_DWORD *)this + 9);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v22, 1), *(float *)v25.i32, v22.f32[0]);
  v28 = (float64x2_t)v78;
  v79 = vaddq_f32(v78, v21);
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  *(float *)v28.f64 = *(float *)&v26 + *(float *)v27.i32;
  v21.f32[1] = *(float *)&v26 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v21.i64, v28, v24, v23, v25, v27, v26, v29);
  v31 = vadd_f32(v5, (float32x2_t)3212836864);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v31, 1), *((float *)this + 4), v31.f32[0]);
  LODWORD(v33) = *((_DWORD *)this + 6);
  v34.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v35) = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v31, 1), *(float *)v34.i32, v31.f32[0]);
  v37 = (float64x2_t)v79;
  v80 = vaddq_f32(v79, v30);
  v30.f32[0] = *(float *)&v33 + *(float *)&v32;
  *(float *)v37.f64 = *(float *)&v35 + *(float *)v36.i32;
  v30.f32[1] = *(float *)&v35 + *(float *)v36.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v30.i64, v37, v33, v32, v34, v36, v35, v38);
  v40 = vadd_f32(v5, (float32x2_t)1065353216);
  *(float *)&v41 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v40, 1), *((float *)this + 4), v40.f32[0]);
  LODWORD(v42) = *((_DWORD *)this + 6);
  v43.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v44) = *((_DWORD *)this + 9);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v40, 1), *(float *)v43.i32, v40.f32[0]);
  v46 = (float64x2_t)v80;
  v81 = vaddq_f32(v80, v39);
  v39.f32[0] = *(float *)&v42 + *(float *)&v41;
  *(float *)v46.f64 = *(float *)&v44 + *(float *)v45.i32;
  v39.f32[1] = *(float *)&v44 + *(float *)v45.i32;
  *(double *)v48.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v39.i64, v46, v42, v41, v43, v45, v44, v47);
  v49 = vadd_f32(v5, (float32x2_t)1077936128);
  *(float *)&v50 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v49, 1), *((float *)this + 4), v49.f32[0]);
  LODWORD(v51) = *((_DWORD *)this + 6);
  v52.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v53) = *((_DWORD *)this + 9);
  *(float *)v54.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v49, 1), *(float *)v52.i32, v49.f32[0]);
  v55 = (float64x2_t)v81;
  v82 = vaddq_f32(v81, v48);
  v48.f32[0] = *(float *)&v51 + *(float *)&v50;
  *(float *)v55.f64 = *(float *)&v53 + *(float *)v54.i32;
  v48.f32[1] = *(float *)&v53 + *(float *)v54.i32;
  *(double *)v57.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v48.i64, v55, v51, v50, v52, v54, v53, v56);
  v58 = vadd_f32(v5, (float32x2_t)1084227584);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v58, 1), *((float *)this + 4), v58.f32[0]);
  LODWORD(v60) = *((_DWORD *)this + 6);
  v61.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v62) = *((_DWORD *)this + 9);
  *(float *)v63.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v58, 1), *(float *)v61.i32, v58.f32[0]);
  v64 = (float64x2_t)v82;
  v83 = vaddq_f32(v82, v57);
  v57.f32[0] = *(float *)&v60 + *(float *)&v59;
  *(float *)v64.f64 = *(float *)&v62 + *(float *)v63.i32;
  v57.f32[1] = *(float *)&v62 + *(float *)v63.i32;
  *(double *)v66.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v57.i64, v64, v60, v59, v61, v63, v62, v65);
  v67 = vadd_f32(v5, (float32x2_t)1088421888);
  *(float *)&v68 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v67, 1), *((float *)this + 4), v67.f32[0]);
  LODWORD(v69) = *((_DWORD *)this + 6);
  v70.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v71) = *((_DWORD *)this + 9);
  *(float *)v72.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v67, 1), *(float *)v70.i32, v67.f32[0]);
  v73 = (float64x2_t)v83;
  v84 = vaddq_f32(v83, v66);
  v66.f32[0] = *(float *)&v69 + *(float *)&v68;
  *(float *)v73.f64 = *(float *)&v71 + *(float *)v72.i32;
  v66.f32[1] = *(float *)&v71 + *(float *)v72.i32;
  *(double *)v75.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v66.i64, v73, v69, v68, v70, v72, v71, v74);
  v76.i64[0] = 0x3E0000003E000000;
  v76.i64[1] = 0x3E0000003E000000;
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v84, v75), v76).u64[0];
  return result;
}

double cikernel::_horizAvg8(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  double v26;
  uint8x8_t v27;
  float64x2_t v28;
  int8x16_t v29;
  float32x4_t v30;
  float32x2_t v31;
  double v32;
  double v33;
  int8x16_t v34;
  double v35;
  uint8x8_t v36;
  float64x2_t v37;
  int8x16_t v38;
  float32x4_t v39;
  double result;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;

  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1065353216;
  v5 = vmul_f32(*DC, (float32x2_t)0x3F80000041000000);
  v6 = vadd_f32(v5, (float32x2_t)3225419776);
  *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v6, 1), *((float *)this + 4), v6.f32[0]);
  LODWORD(v8) = *((_DWORD *)this + 7);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *((float *)this + 6) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v6, v4, v7, v8, v10, v9, v11, v12);
  v46 = v13;
  *(float32x2_t *)v13.f32 = vadd_f32(v5, (float32x2_t)3212836864);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v15) = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  v22 = vadd_f32(v5, (float32x2_t)1065353216);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v22, 1), *((float *)this + 4), v22.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 6);
  v25.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v26) = *((_DWORD *)this + 9);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v22, 1), *(float *)v25.i32, v22.f32[0]);
  v28 = (float64x2_t)v46;
  v47 = vaddq_f32(v46, v21);
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  *(float *)v28.f64 = *(float *)&v26 + *(float *)v27.i32;
  v21.f32[1] = *(float *)&v26 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v21.i64, v28, v24, v23, v25, v27, v26, v29);
  v31 = vadd_f32(v5, (float32x2_t)1077936128);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v31, 1), *((float *)this + 4), v31.f32[0]);
  LODWORD(v33) = *((_DWORD *)this + 6);
  v34.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v35) = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v31, 1), *(float *)v34.i32, v31.f32[0]);
  v37 = (float64x2_t)v47;
  v48 = vaddq_f32(v47, v30);
  v30.f32[0] = *(float *)&v33 + *(float *)&v32;
  *(float *)v37.f64 = *(float *)&v35 + *(float *)v36.i32;
  v30.f32[1] = *(float *)&v35 + *(float *)v36.i32;
  *(double *)v39.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v30.i64, v37, v33, v32, v34, v36, v35, v38);
  __asm { FMOV            V1.4S, #0.25 }
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v48, v39), _Q1).u64[0];
  return result;
}

double cikernel::_horizAvg4(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x4_t v22;
  double result;
  float32x4_t v24;

  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1065353216;
  v5 = vmul_f32(*DC, (float32x2_t)0x3F80000040800000);
  v6 = vadd_f32(v5, (float32x2_t)3212836864);
  *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v6, 1), *((float *)this + 4), v6.f32[0]);
  LODWORD(v8) = *((_DWORD *)this + 7);
  v9.i32[0] = *((_DWORD *)this + 9);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *((float *)this + 6) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v6, v4, v7, v8, v10, v9, v11, v12);
  v24 = v13;
  *(float32x2_t *)v13.f32 = vadd_f32(v5, (float32x2_t)1065353216);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.f32, 1), *((float *)this + 4), v13.f32[0]);
  LODWORD(v15) = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.f32, 1), *(float *)&v15, v13.f32[0]);
  v13.f32[0] = *((float *)this + 6) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v13.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  v22.i64[0] = 0x3F0000003F000000;
  v22.i64[1] = 0x3F0000003F000000;
  *(_QWORD *)&result = vmulq_f32(vaddq_f32(v24, v21), v22).u64[0];
  return result;
}

double cikernel::_horizAvg2(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  int8x16_t v11;

  DC = (float32x2_t *)CI::getDC(this);
  HIDWORD(v4.f64[0]) = 1065353216;
  v5 = vmul_f32(*DC, (float32x2_t)0x3F80000040000000);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  return CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v4, v6, v7, v9, v8, v10, v11);
}

double cikernel::_areaMax4(uint64_t a1, double a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  float64x2_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  float64x2_t v21;
  double v22;
  double v23;
  uint8x8_t v24;
  int8x16_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  float64x2_t v29;
  double v30;
  double v31;
  uint8x8_t v32;
  int8x16_t v33;
  double v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float64x2_t v44;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)&v4.f64[0] = vadd_f32(*DC, *DC);
  v44 = v4;
  v5 = vadd_f32(*(float32x2_t *)&v4.f64[0], (float32x2_t)0xBF000000BF000000);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v4, v6, v7, v9, v8, v10, v11);
  v42 = v12;
  v13 = v44;
  *(float32x2_t *)v12.f32 = vadd_f32(*(float32x2_t *)&v44.f64[0], (float32x2_t)0xBF0000003F000000);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v15, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v13.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v12.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v13, v14, v15, v17, v16, v18, v19);
  v40 = v20;
  v21 = v44;
  *(float32x2_t *)v20.f32 = vadd_f32(*(float32x2_t *)&v44.f64[0], (float32x2_t)0x3F000000BF000000);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v20.f32, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v20.f32, 1), *(float *)&v23, v20.f32[0]);
  v20.f32[0] = *(float *)(a1 + 24) + *(float *)&v22;
  *(float *)v21.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v20.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v21, v22, v23, v25, v24, v26, v27);
  v41 = v28;
  v29 = v44;
  *(float32x2_t *)v28.f32 = vadd_f32(*(float32x2_t *)&v44.f64[0], (float32x2_t)0x3F0000003F000000);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v28.f32, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v28.f32, 1), *(float *)&v31, v28.f32[0]);
  v28.f32[0] = *(float *)(a1 + 24) + *(float *)&v30;
  *(float *)v29.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v28.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v29, v30, v31, v33, v32, v34, v35);
  if (*(float *)v44.f64 + 0.5 >= *(float *)&a2)
  {
    v37 = v41;
    v38 = v42;
  }
  else
  {
    v37 = vmaxnmq_f32(v41, v36);
    v38 = vmaxnmq_f32(v42, v40);
  }
  if (*((float *)v44.f64 + 1) + 0.5 < *((float *)&a2 + 1))
    v38.i64[0] = vmaxnmq_f32(v38, v37).u64[0];
  return *(double *)v38.i64;
}

double cikernel::_horizMax4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  float64x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  int8x16_t v13;
  float32x4_t v14;
  float64x2_t v15;
  double v16;
  double v17;
  uint8x8_t v18;
  int8x16_t v19;
  double v20;
  int8x16_t v21;
  float32x4_t v22;
  float64x2_t v23;
  double v24;
  double v25;
  uint8x8_t v26;
  int8x16_t v27;
  double v28;
  int8x16_t v29;
  float32x4_t v30;
  float64x2_t v31;
  double v32;
  double v33;
  uint8x8_t v34;
  int8x16_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  double v40;
  double v41;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float64x2_t v46;

  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x3F80000040800000);
  v46 = v6;
  v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)3217031168);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12, v13);
  v45 = v14;
  v15 = v46;
  *(float32x2_t *)v14.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)3204448256);
  *(float *)&v16 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v14.f32, 1), *((float *)this + 4), v14.f32[0]);
  LODWORD(v17) = *((_DWORD *)this + 7);
  v18.i32[0] = *((_DWORD *)this + 9);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v14.f32, 1), *(float *)&v17, v14.f32[0]);
  v14.f32[0] = *((float *)this + 6) + *(float *)&v16;
  *(float *)v15.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v14.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v14.i64, v15, v16, v17, v19, v18, v20, v21);
  v44 = v22;
  v23 = v46;
  *(float32x2_t *)v22.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)1056964608);
  *(float *)&v24 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v22.f32, 1), *((float *)this + 4), v22.f32[0]);
  LODWORD(v25) = *((_DWORD *)this + 7);
  v26.i32[0] = *((_DWORD *)this + 9);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v22.f32, 1), *(float *)&v25, v22.f32[0]);
  v22.f32[0] = *((float *)this + 6) + *(float *)&v24;
  *(float *)v23.f64 = *(float *)v26.i32 + *(float *)v27.i32;
  v22.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v22.i64, v23, v24, v25, v27, v26, v28, v29);
  v43 = v30;
  v31 = v46;
  *(float32x2_t *)v30.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)1069547520);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v30.f32, 1), *((float *)this + 4), v30.f32[0]);
  LODWORD(v33) = *((_DWORD *)this + 7);
  v34.i32[0] = *((_DWORD *)this + 9);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v30.f32, 1), *(float *)&v33, v30.f32[0]);
  v30.f32[0] = *((float *)this + 6) + *(float *)&v32;
  *(float *)v31.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v30.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v30.i64, v31, v32, v33, v35, v34, v36, v37);
  v39 = v45;
  v40 = *(float *)v46.f64;
  v41 = a3;
  if (*(float *)v46.f64 + -0.5 < a3)
    v39 = vmaxnmq_f32(v45, v44);
  if (v40 + 0.5 < v41)
    v39 = vmaxnmq_f32(v39, v43);
  if (v40 + 1.5 < v41)
    v39.i64[0] = vmaxnmq_f32(v39, v38).u64[0];
  return *(double *)v39.i64;
}

double cikernel::_vertMax4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  float64x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  int8x16_t v13;
  float32x4_t v14;
  float64x2_t v15;
  double v16;
  double v17;
  uint8x8_t v18;
  int8x16_t v19;
  double v20;
  int8x16_t v21;
  float32x4_t v22;
  float64x2_t v23;
  double v24;
  double v25;
  uint8x8_t v26;
  int8x16_t v27;
  double v28;
  int8x16_t v29;
  float32x4_t v30;
  float64x2_t v31;
  double v32;
  double v33;
  uint8x8_t v34;
  int8x16_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  double v40;
  double v41;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float64x2_t v46;

  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x408000003F800000);
  v46 = v6;
  v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)0xBFC0000000000000);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12, v13);
  v45 = v14;
  v15 = v46;
  *(float32x2_t *)v14.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)0xBF00000000000000);
  *(float *)&v16 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v14.f32, 1), *((float *)this + 4), v14.f32[0]);
  LODWORD(v17) = *((_DWORD *)this + 7);
  v18.i32[0] = *((_DWORD *)this + 9);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v14.f32, 1), *(float *)&v17, v14.f32[0]);
  v14.f32[0] = *((float *)this + 6) + *(float *)&v16;
  *(float *)v15.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v14.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v14.i64, v15, v16, v17, v19, v18, v20, v21);
  v44 = v22;
  v23 = v46;
  *(float32x2_t *)v22.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)0x3F00000000000000);
  *(float *)&v24 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v22.f32, 1), *((float *)this + 4), v22.f32[0]);
  LODWORD(v25) = *((_DWORD *)this + 7);
  v26.i32[0] = *((_DWORD *)this + 9);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v22.f32, 1), *(float *)&v25, v22.f32[0]);
  v22.f32[0] = *((float *)this + 6) + *(float *)&v24;
  *(float *)v23.f64 = *(float *)v26.i32 + *(float *)v27.i32;
  v22.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v22.i64, v23, v24, v25, v27, v26, v28, v29);
  v43 = v30;
  v31 = v46;
  *(float32x2_t *)v30.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)0x3FC0000000000000);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v30.f32, 1), *((float *)this + 4), v30.f32[0]);
  LODWORD(v33) = *((_DWORD *)this + 7);
  v34.i32[0] = *((_DWORD *)this + 9);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v30.f32, 1), *(float *)&v33, v30.f32[0]);
  v30.f32[0] = *((float *)this + 6) + *(float *)&v32;
  *(float *)v31.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v30.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v30.i64, v31, v32, v33, v35, v34, v36, v37);
  v39 = v45;
  v40 = *((float *)v46.f64 + 1);
  v41 = a3;
  if (*((float *)v46.f64 + 1) + -0.5 < a3)
    v39 = vmaxnmq_f32(v45, v44);
  if (v40 + 0.5 < v41)
    v39 = vmaxnmq_f32(v39, v43);
  if (v40 + 1.5 < v41)
    v39.i64[0] = vmaxnmq_f32(v39, v38).u64[0];
  return *(double *)v39.i64;
}

double cikernel::_areaMin4(uint64_t a1, double a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  float64x2_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  float64x2_t v21;
  double v22;
  double v23;
  uint8x8_t v24;
  int8x16_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  float64x2_t v29;
  double v30;
  double v31;
  uint8x8_t v32;
  int8x16_t v33;
  double v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float64x2_t v44;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)&v4.f64[0] = vadd_f32(*DC, *DC);
  v44 = v4;
  v5 = vadd_f32(*(float32x2_t *)&v4.f64[0], (float32x2_t)0xBF000000BF000000);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v4, v6, v7, v9, v8, v10, v11);
  v42 = v12;
  v13 = v44;
  *(float32x2_t *)v12.f32 = vadd_f32(*(float32x2_t *)&v44.f64[0], (float32x2_t)0xBF0000003F000000);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v15) = *(_DWORD *)(a1 + 28);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v15, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v14;
  *(float *)v13.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  v12.f32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v13, v14, v15, v17, v16, v18, v19);
  v40 = v20;
  v21 = v44;
  *(float32x2_t *)v20.f32 = vadd_f32(*(float32x2_t *)&v44.f64[0], (float32x2_t)0x3F000000BF000000);
  *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v20.f32, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 28);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v20.f32, 1), *(float *)&v23, v20.f32[0]);
  v20.f32[0] = *(float *)(a1 + 24) + *(float *)&v22;
  *(float *)v21.f64 = *(float *)v24.i32 + *(float *)v25.i32;
  v20.f32[1] = *(float *)v24.i32 + *(float *)v25.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v21, v22, v23, v25, v24, v26, v27);
  v41 = v28;
  v29 = v44;
  *(float32x2_t *)v28.f32 = vadd_f32(*(float32x2_t *)&v44.f64[0], (float32x2_t)0x3F0000003F000000);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v28.f32, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v31) = *(_DWORD *)(a1 + 28);
  v32.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v28.f32, 1), *(float *)&v31, v28.f32[0]);
  v28.f32[0] = *(float *)(a1 + 24) + *(float *)&v30;
  *(float *)v29.f64 = *(float *)v32.i32 + *(float *)v33.i32;
  v28.f32[1] = *(float *)v32.i32 + *(float *)v33.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v29, v30, v31, v33, v32, v34, v35);
  if (*(float *)v44.f64 + 0.5 >= *(float *)&a2)
  {
    v37 = v41;
    v38 = v42;
  }
  else
  {
    v37 = vminnmq_f32(v41, v36);
    v38 = vminnmq_f32(v42, v40);
  }
  if (*((float *)v44.f64 + 1) + 0.5 < *((float *)&a2 + 1))
    v38.i64[0] = vminnmq_f32(v38, v37).u64[0];
  return *(double *)v38.i64;
}

double cikernel::_horizMin4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  float64x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  int8x16_t v13;
  float32x4_t v14;
  float64x2_t v15;
  double v16;
  double v17;
  uint8x8_t v18;
  int8x16_t v19;
  double v20;
  int8x16_t v21;
  float32x4_t v22;
  float64x2_t v23;
  double v24;
  double v25;
  uint8x8_t v26;
  int8x16_t v27;
  double v28;
  int8x16_t v29;
  float32x4_t v30;
  float64x2_t v31;
  double v32;
  double v33;
  uint8x8_t v34;
  int8x16_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  double v40;
  double v41;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float64x2_t v46;

  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x3F80000040800000);
  v46 = v6;
  v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)3217031168);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12, v13);
  v45 = v14;
  v15 = v46;
  *(float32x2_t *)v14.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)3204448256);
  *(float *)&v16 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v14.f32, 1), *((float *)this + 4), v14.f32[0]);
  LODWORD(v17) = *((_DWORD *)this + 7);
  v18.i32[0] = *((_DWORD *)this + 9);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v14.f32, 1), *(float *)&v17, v14.f32[0]);
  v14.f32[0] = *((float *)this + 6) + *(float *)&v16;
  *(float *)v15.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v14.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v14.i64, v15, v16, v17, v19, v18, v20, v21);
  v44 = v22;
  v23 = v46;
  *(float32x2_t *)v22.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)1056964608);
  *(float *)&v24 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v22.f32, 1), *((float *)this + 4), v22.f32[0]);
  LODWORD(v25) = *((_DWORD *)this + 7);
  v26.i32[0] = *((_DWORD *)this + 9);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v22.f32, 1), *(float *)&v25, v22.f32[0]);
  v22.f32[0] = *((float *)this + 6) + *(float *)&v24;
  *(float *)v23.f64 = *(float *)v26.i32 + *(float *)v27.i32;
  v22.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v22.i64, v23, v24, v25, v27, v26, v28, v29);
  v43 = v30;
  v31 = v46;
  *(float32x2_t *)v30.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)1069547520);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v30.f32, 1), *((float *)this + 4), v30.f32[0]);
  LODWORD(v33) = *((_DWORD *)this + 7);
  v34.i32[0] = *((_DWORD *)this + 9);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v30.f32, 1), *(float *)&v33, v30.f32[0]);
  v30.f32[0] = *((float *)this + 6) + *(float *)&v32;
  *(float *)v31.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v30.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v30.i64, v31, v32, v33, v35, v34, v36, v37);
  v39 = v45;
  v40 = *(float *)v46.f64;
  v41 = a3;
  if (*(float *)v46.f64 + -0.5 < a3)
    v39 = vminnmq_f32(v45, v44);
  if (v40 + 0.5 < v41)
    v39 = vminnmq_f32(v39, v43);
  if (v40 + 1.5 < v41)
    v39.i64[0] = vminnmq_f32(v39, v38).u64[0];
  return *(double *)v39.i64;
}

double cikernel::_vertMin4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  float64x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  int8x16_t v13;
  float32x4_t v14;
  float64x2_t v15;
  double v16;
  double v17;
  uint8x8_t v18;
  int8x16_t v19;
  double v20;
  int8x16_t v21;
  float32x4_t v22;
  float64x2_t v23;
  double v24;
  double v25;
  uint8x8_t v26;
  int8x16_t v27;
  double v28;
  int8x16_t v29;
  float32x4_t v30;
  float64x2_t v31;
  double v32;
  double v33;
  uint8x8_t v34;
  int8x16_t v35;
  double v36;
  int8x16_t v37;
  float32x4_t v38;
  float32x4_t v39;
  double v40;
  double v41;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float64x2_t v46;

  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x408000003F800000);
  v46 = v6;
  v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)0xBFC0000000000000);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12, v13);
  v45 = v14;
  v15 = v46;
  *(float32x2_t *)v14.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)0xBF00000000000000);
  *(float *)&v16 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v14.f32, 1), *((float *)this + 4), v14.f32[0]);
  LODWORD(v17) = *((_DWORD *)this + 7);
  v18.i32[0] = *((_DWORD *)this + 9);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v14.f32, 1), *(float *)&v17, v14.f32[0]);
  v14.f32[0] = *((float *)this + 6) + *(float *)&v16;
  *(float *)v15.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v14.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v14.i64, v15, v16, v17, v19, v18, v20, v21);
  v44 = v22;
  v23 = v46;
  *(float32x2_t *)v22.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)0x3F00000000000000);
  *(float *)&v24 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v22.f32, 1), *((float *)this + 4), v22.f32[0]);
  LODWORD(v25) = *((_DWORD *)this + 7);
  v26.i32[0] = *((_DWORD *)this + 9);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v22.f32, 1), *(float *)&v25, v22.f32[0]);
  v22.f32[0] = *((float *)this + 6) + *(float *)&v24;
  *(float *)v23.f64 = *(float *)v26.i32 + *(float *)v27.i32;
  v22.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
  *(double *)v30.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v22.i64, v23, v24, v25, v27, v26, v28, v29);
  v43 = v30;
  v31 = v46;
  *(float32x2_t *)v30.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)0x3FC0000000000000);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v30.f32, 1), *((float *)this + 4), v30.f32[0]);
  LODWORD(v33) = *((_DWORD *)this + 7);
  v34.i32[0] = *((_DWORD *)this + 9);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v30.f32, 1), *(float *)&v33, v30.f32[0]);
  v30.f32[0] = *((float *)this + 6) + *(float *)&v32;
  *(float *)v31.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v30.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  *(double *)v38.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v30.i64, v31, v32, v33, v35, v34, v36, v37);
  v39 = v45;
  v40 = *((float *)v46.f64 + 1);
  v41 = a3;
  if (*((float *)v46.f64 + 1) + -0.5 < a3)
    v39 = vminnmq_f32(v45, v44);
  if (v40 + 0.5 < v41)
    v39 = vminnmq_f32(v39, v43);
  if (v40 + 1.5 < v41)
    v39.i64[0] = vminnmq_f32(v39, v38).u64[0];
  return *(double *)v39.i64;
}

double cikernel::_areaMaxAlphaS4(uint64_t a1, double a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  double v13;
  float64x2_t v14;
  float32x2_t v15;
  double v16;
  uint8x8_t v17;
  int8x16_t v18;
  int8x16_t v19;
  float32x4_t v20;
  double v21;
  float64x2_t v22;
  float32x2_t v23;
  double v24;
  uint8x8_t v25;
  int8x16_t v26;
  int8x16_t v27;
  float32x4_t v28;
  double v29;
  float64x2_t v30;
  float32x2_t v31;
  double v32;
  uint8x8_t v33;
  int8x16_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t *v37;
  float32x4_t *v38;
  float32x4_t *v39;
  float v40;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float64x2_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)&v4.f64[0] = vadd_f32(*DC, *DC);
  v46 = v4;
  v5 = vadd_f32(*(float32x2_t *)&v4.f64[0], (float32x2_t)0xBF000000BF000000);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v4, v6, v7, v9, v8, v10, v11);
  HIDWORD(v13) = -1090519040;
  v14 = v46;
  v15 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)0xBF0000003F000000);
  *(float *)&v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v15, 1), *(float *)(a1 + 16), v15.f32[0]);
  LODWORD(v14.f64[0]) = *(_DWORD *)(a1 + 24);
  LODWORD(v16) = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v15, 1), *(float *)&v16, v15.f32[0]);
  v44 = v12;
  v50 = v12;
  v12.f32[0] = *(float *)v14.f64 + *(float *)&v13;
  *(float *)v14.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v12.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v14, v13, v16, v18, v17, *(double *)&v15, v19);
  HIDWORD(v21) = 1056964608;
  v22 = v46;
  v23 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)0x3F000000BF000000);
  *(float *)&v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v23, 1), *(float *)(a1 + 16), v23.f32[0]);
  LODWORD(v22.f64[0]) = *(_DWORD *)(a1 + 24);
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v23, 1), *(float *)&v24, v23.f32[0]);
  v43 = v20;
  v49 = v20;
  v20.f32[0] = *(float *)v22.f64 + *(float *)&v21;
  *(float *)v22.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v20.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v22, v21, v24, v26, v25, *(double *)&v23, v27);
  HIDWORD(v29) = 1056964608;
  v30 = v46;
  v31 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)0x3F0000003F000000);
  *(float *)&v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v31, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v30.f64[0]) = *(_DWORD *)(a1 + 24);
  LODWORD(v32) = *(_DWORD *)(a1 + 28);
  v33.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v31, 1), *(float *)&v32, v31.f32[0]);
  v42 = v28;
  v48 = v28;
  v28.f32[0] = *(float *)v30.f64 + *(float *)&v29;
  *(float *)v30.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v28.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v30, v29, v32, v34, v33, *(double *)&v31, v35);
  v47 = v36;
  v37 = &v48;
  if (*(float *)v46.f64 + 0.5 >= *(float *)&a2)
  {
    v40 = v44.f32[3];
    v39 = &v48;
  }
  else
  {
    v38 = &v49;
    if ((vmovn_s32(vcgeq_f32(v44, v43)).i8[6] & 1) != 0)
      v38 = &v50;
    v50 = *v38;
    v39 = &v47;
    if ((vmovn_s32(vcgeq_f32(v42, v36)).i8[6] & 1) != 0)
      v39 = &v48;
    v40 = v50.f32[3];
  }
  v48 = *v39;
  if (v40 >= v48.f32[3])
    v37 = &v50;
  if (*((float *)v46.f64 + 1) + 0.5 >= *((float *)&a2 + 1))
    v37 = &v50;
  return *(double *)v37->i64;
}

double cikernel::_areaMaxAlphaH4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  float64x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  int8x16_t v13;
  float32x4_t v14;
  float64x2_t v15;
  float32x2_t v16;
  unsigned int v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float64x2_t v23;
  float32x2_t v24;
  unsigned int v25;
  double v26;
  uint8x8_t v27;
  int8x16_t v28;
  int8x16_t v29;
  __int128 v30;
  float64x2_t v31;
  float32x2_t v32;
  unsigned int v33;
  double v34;
  uint8x8_t v35;
  int8x16_t v36;
  int8x16_t v37;
  __int128 v38;
  double v39;
  double v40;
  float32x4_t *v41;
  float32x4_t *v42;
  double v43;
  float32x4_t *v44;
  float v46;
  float32x4_t v47;
  float32x4_t v48;
  float64x2_t v49;
  __int128 v50;
  __int128 v51;
  float32x4_t v52;
  float32x4_t v53;

  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x3F80000040800000);
  v49 = v6;
  v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)3217031168);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12, v13);
  v48 = v14;
  v15 = v49;
  v16 = vadd_f32(*(float32x2_t *)&v49.f64[0], (float32x2_t)3204448256);
  *(float *)&v17 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v16, 1), *((float *)this + 4), v16.f32[0]);
  LODWORD(v15.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v18) = *((_DWORD *)this + 7);
  v19.i32[0] = *((_DWORD *)this + 9);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v16, 1), *(float *)&v18, v16.f32[0]);
  v53 = v14;
  v14.f32[0] = *(float *)v15.f64 + *(float *)&v17;
  *(float *)v15.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v14.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v14.i64, v15, COERCE_DOUBLE((unint64_t)v17), v18, v20, v19, *(double *)&v16, v21);
  v47 = v22;
  v23 = v49;
  v24 = vadd_f32(*(float32x2_t *)&v49.f64[0], (float32x2_t)1056964608);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v24, 1), *((float *)this + 4), v24.f32[0]);
  LODWORD(v23.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v26) = *((_DWORD *)this + 7);
  v27.i32[0] = *((_DWORD *)this + 9);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v24, 1), *(float *)&v26, v24.f32[0]);
  v52 = v22;
  v22.f32[0] = *(float *)v23.f64 + *(float *)&v25;
  *(float *)v23.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  v22.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)&v30 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v22.i64, v23, COERCE_DOUBLE((unint64_t)v25), v26, v28, v27, *(double *)&v24, v29);
  v46 = *((float *)&v30 + 3);
  v31 = v49;
  v32 = vadd_f32(*(float32x2_t *)&v49.f64[0], (float32x2_t)1069547520);
  *(float *)&v33 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v32, 1), *((float *)this + 4), v32.f32[0]);
  LODWORD(v31.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v34) = *((_DWORD *)this + 7);
  v35.i32[0] = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v32, 1), *(float *)&v34, v32.f32[0]);
  v51 = v30;
  *(float *)&v30 = *(float *)v31.f64 + *(float *)&v33;
  *(float *)v31.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  *((float *)&v30 + 1) = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)&v38 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v30, v31, COERCE_DOUBLE((unint64_t)v33), v34, v36, v35, *(double *)&v32, v37);
  v50 = v38;
  v39 = *(float *)v49.f64;
  v40 = a3;
  v41 = &v52;
  if ((vmovn_s32(vcgeq_f32(v48, v47)).i8[6] & 1) != 0)
    v41 = &v53;
  if (*(float *)v49.f64 + -0.5 >= v40)
    v41 = &v53;
  v53 = *v41;
  v42 = (float32x4_t *)&v51;
  if (v53.f32[3] >= v46)
    v42 = &v53;
  if (v39 + 0.5 >= v40)
    v42 = &v53;
  v53 = *v42;
  v43 = v39 + 1.5;
  v44 = (float32x4_t *)&v50;
  if (v53.f32[3] >= *((float *)&v38 + 3))
    v44 = &v53;
  if (v43 >= v40)
    v44 = &v53;
  return *(double *)v44->i64;
}

double cikernel::_areaMaxAlphaV4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  float64x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  int8x16_t v13;
  float32x4_t v14;
  double v15;
  float64x2_t v16;
  float32x2_t v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float32x4_t v22;
  double v23;
  float64x2_t v24;
  float32x2_t v25;
  double v26;
  uint8x8_t v27;
  int8x16_t v28;
  int8x16_t v29;
  __int128 v30;
  double v31;
  float64x2_t v32;
  float32x2_t v33;
  double v34;
  uint8x8_t v35;
  int8x16_t v36;
  int8x16_t v37;
  __int128 v38;
  double v39;
  double v40;
  float32x4_t *v41;
  float32x4_t *v42;
  double v43;
  float32x4_t *v44;
  float v46;
  float32x4_t v47;
  float32x4_t v48;
  float64x2_t v49;
  __int128 v50;
  __int128 v51;
  float32x4_t v52;
  float32x4_t v53;

  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x408000003F800000);
  v49 = v6;
  v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)0xBFC0000000000000);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12, v13);
  v48 = v14;
  HIDWORD(v15) = -1090519040;
  v16 = v49;
  v17 = vadd_f32(*(float32x2_t *)&v49.f64[0], (float32x2_t)0xBF00000000000000);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v17, 1), *((float *)this + 4), v17.f32[0]);
  LODWORD(v16.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v18) = *((_DWORD *)this + 7);
  v19.i32[0] = *((_DWORD *)this + 9);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v17, 1), *(float *)&v18, v17.f32[0]);
  v53 = v14;
  v14.f32[0] = *(float *)v16.f64 + *(float *)&v15;
  *(float *)v16.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v14.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v14.i64, v16, v15, v18, v20, v19, *(double *)&v17, v21);
  v47 = v22;
  HIDWORD(v23) = 1056964608;
  v24 = v49;
  v25 = vadd_f32(*(float32x2_t *)&v49.f64[0], (float32x2_t)0x3F00000000000000);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v25, 1), *((float *)this + 4), v25.f32[0]);
  LODWORD(v24.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v26) = *((_DWORD *)this + 7);
  v27.i32[0] = *((_DWORD *)this + 9);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v25, 1), *(float *)&v26, v25.f32[0]);
  v52 = v22;
  v22.f32[0] = *(float *)v24.f64 + *(float *)&v23;
  *(float *)v24.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  v22.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)&v30 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v22.i64, v24, v23, v26, v28, v27, *(double *)&v25, v29);
  v46 = *((float *)&v30 + 3);
  HIDWORD(v31) = 1069547520;
  v32 = v49;
  v33 = vadd_f32(*(float32x2_t *)&v49.f64[0], (float32x2_t)0x3FC0000000000000);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v33, 1), *((float *)this + 4), v33.f32[0]);
  LODWORD(v32.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v34) = *((_DWORD *)this + 7);
  v35.i32[0] = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v33, 1), *(float *)&v34, v33.f32[0]);
  v51 = v30;
  *(float *)&v30 = *(float *)v32.f64 + *(float *)&v31;
  *(float *)v32.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  *((float *)&v30 + 1) = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)&v38 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v30, v32, v31, v34, v36, v35, *(double *)&v33, v37);
  v50 = v38;
  v39 = *((float *)v49.f64 + 1);
  v40 = a3;
  v41 = &v52;
  if ((vmovn_s32(vcgeq_f32(v48, v47)).i8[6] & 1) != 0)
    v41 = &v53;
  if (*((float *)v49.f64 + 1) + -0.5 >= v40)
    v41 = &v53;
  v53 = *v41;
  v42 = (float32x4_t *)&v51;
  if (v53.f32[3] >= v46)
    v42 = &v53;
  if (v39 + 0.5 >= v40)
    v42 = &v53;
  v53 = *v42;
  v43 = v39 + 1.5;
  v44 = (float32x4_t *)&v50;
  if (v53.f32[3] >= *((float *)&v38 + 3))
    v44 = &v53;
  if (v43 >= v40)
    v44 = &v53;
  return *(double *)v44->i64;
}

double cikernel::_areaMinAlphaS4(uint64_t a1, double a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  double v13;
  float64x2_t v14;
  float32x2_t v15;
  double v16;
  uint8x8_t v17;
  int8x16_t v18;
  int8x16_t v19;
  float32x4_t v20;
  double v21;
  float64x2_t v22;
  float32x2_t v23;
  double v24;
  uint8x8_t v25;
  int8x16_t v26;
  int8x16_t v27;
  float32x4_t v28;
  double v29;
  float64x2_t v30;
  float32x2_t v31;
  double v32;
  uint8x8_t v33;
  int8x16_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float32x4_t *v37;
  float32x4_t *v38;
  float32x4_t *v39;
  float v40;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float64x2_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)&v4.f64[0] = vadd_f32(*DC, *DC);
  v46 = v4;
  v5 = vadd_f32(*(float32x2_t *)&v4.f64[0], (float32x2_t)0xBF000000BF000000);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v5, 1), *(float *)(a1 + 16), v5.f32[0]);
  LODWORD(v7) = *(_DWORD *)(a1 + 28);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *(float *)(a1 + 24) + *(float *)&v6;
  *(float *)v4.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v5, v4, v6, v7, v9, v8, v10, v11);
  HIDWORD(v13) = -1090519040;
  v14 = v46;
  v15 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)0xBF0000003F000000);
  *(float *)&v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v15, 1), *(float *)(a1 + 16), v15.f32[0]);
  LODWORD(v14.f64[0]) = *(_DWORD *)(a1 + 24);
  LODWORD(v16) = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v15, 1), *(float *)&v16, v15.f32[0]);
  v44 = v12;
  v50 = v12;
  v12.f32[0] = *(float *)v14.f64 + *(float *)&v13;
  *(float *)v14.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v12.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v14, v13, v16, v18, v17, *(double *)&v15, v19);
  HIDWORD(v21) = 1056964608;
  v22 = v46;
  v23 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)0x3F000000BF000000);
  *(float *)&v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v23, 1), *(float *)(a1 + 16), v23.f32[0]);
  LODWORD(v22.f64[0]) = *(_DWORD *)(a1 + 24);
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v23, 1), *(float *)&v24, v23.f32[0]);
  v43 = v20;
  v49 = v20;
  v20.f32[0] = *(float *)v22.f64 + *(float *)&v21;
  *(float *)v22.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v20.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v22, v21, v24, v26, v25, *(double *)&v23, v27);
  HIDWORD(v29) = 1056964608;
  v30 = v46;
  v31 = vadd_f32(*(float32x2_t *)&v46.f64[0], (float32x2_t)0x3F0000003F000000);
  *(float *)&v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v31, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v30.f64[0]) = *(_DWORD *)(a1 + 24);
  LODWORD(v32) = *(_DWORD *)(a1 + 28);
  v33.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v31, 1), *(float *)&v32, v31.f32[0]);
  v42 = v28;
  v48 = v28;
  v28.f32[0] = *(float *)v30.f64 + *(float *)&v29;
  *(float *)v30.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v28.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v30, v29, v32, v34, v33, *(double *)&v31, v35);
  v47 = v36;
  v37 = &v48;
  if (*(float *)v46.f64 + 0.5 >= *(float *)&a2)
  {
    v40 = v44.f32[3];
    v39 = &v48;
  }
  else
  {
    v38 = &v49;
    if ((vmovn_s32(vcgeq_f32(v43, v44)).i8[6] & 1) != 0)
      v38 = &v50;
    v50 = *v38;
    v39 = &v47;
    if ((vmovn_s32(vcgeq_f32(v36, v42)).i8[6] & 1) != 0)
      v39 = &v48;
    v40 = v50.f32[3];
  }
  v48 = *v39;
  if (v40 <= v48.f32[3])
    v37 = &v50;
  if (*((float *)v46.f64 + 1) + 0.5 >= *((float *)&a2 + 1))
    v37 = &v50;
  return *(double *)v37->i64;
}

double cikernel::_areaMinAlphaH4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  float64x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  int8x16_t v13;
  float32x4_t v14;
  float64x2_t v15;
  float32x2_t v16;
  unsigned int v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float64x2_t v23;
  float32x2_t v24;
  unsigned int v25;
  double v26;
  uint8x8_t v27;
  int8x16_t v28;
  int8x16_t v29;
  __int128 v30;
  float64x2_t v31;
  float32x2_t v32;
  unsigned int v33;
  double v34;
  uint8x8_t v35;
  int8x16_t v36;
  int8x16_t v37;
  __int128 v38;
  double v39;
  double v40;
  float32x4_t *v41;
  float32x4_t *v42;
  double v43;
  float32x4_t *v44;
  float v46;
  float32x4_t v47;
  float32x4_t v48;
  float64x2_t v49;
  __int128 v50;
  __int128 v51;
  float32x4_t v52;
  float32x4_t v53;

  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x3F80000040800000);
  v49 = v6;
  v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)3217031168);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12, v13);
  v48 = v14;
  v15 = v49;
  v16 = vadd_f32(*(float32x2_t *)&v49.f64[0], (float32x2_t)3204448256);
  *(float *)&v17 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v16, 1), *((float *)this + 4), v16.f32[0]);
  LODWORD(v15.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v18) = *((_DWORD *)this + 7);
  v19.i32[0] = *((_DWORD *)this + 9);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v16, 1), *(float *)&v18, v16.f32[0]);
  v53 = v14;
  v14.f32[0] = *(float *)v15.f64 + *(float *)&v17;
  *(float *)v15.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v14.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v14.i64, v15, COERCE_DOUBLE((unint64_t)v17), v18, v20, v19, *(double *)&v16, v21);
  v47 = v22;
  v23 = v49;
  v24 = vadd_f32(*(float32x2_t *)&v49.f64[0], (float32x2_t)1056964608);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v24, 1), *((float *)this + 4), v24.f32[0]);
  LODWORD(v23.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v26) = *((_DWORD *)this + 7);
  v27.i32[0] = *((_DWORD *)this + 9);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v24, 1), *(float *)&v26, v24.f32[0]);
  v52 = v22;
  v22.f32[0] = *(float *)v23.f64 + *(float *)&v25;
  *(float *)v23.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  v22.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)&v30 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v22.i64, v23, COERCE_DOUBLE((unint64_t)v25), v26, v28, v27, *(double *)&v24, v29);
  v46 = *((float *)&v30 + 3);
  v31 = v49;
  v32 = vadd_f32(*(float32x2_t *)&v49.f64[0], (float32x2_t)1069547520);
  *(float *)&v33 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v32, 1), *((float *)this + 4), v32.f32[0]);
  LODWORD(v31.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v34) = *((_DWORD *)this + 7);
  v35.i32[0] = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v32, 1), *(float *)&v34, v32.f32[0]);
  v51 = v30;
  *(float *)&v30 = *(float *)v31.f64 + *(float *)&v33;
  *(float *)v31.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  *((float *)&v30 + 1) = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)&v38 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v30, v31, COERCE_DOUBLE((unint64_t)v33), v34, v36, v35, *(double *)&v32, v37);
  v50 = v38;
  v39 = *(float *)v49.f64;
  v40 = a3;
  v41 = &v52;
  if ((vmovn_s32(vcgeq_f32(v47, v48)).i8[6] & 1) != 0)
    v41 = &v53;
  if (*(float *)v49.f64 + -0.5 >= v40)
    v41 = &v53;
  v53 = *v41;
  v42 = (float32x4_t *)&v51;
  if (v53.f32[3] <= v46)
    v42 = &v53;
  if (v39 + 0.5 >= v40)
    v42 = &v53;
  v53 = *v42;
  v43 = v39 + 1.5;
  v44 = (float32x4_t *)&v50;
  if (v53.f32[3] <= *((float *)&v38 + 3))
    v44 = &v53;
  if (v43 >= v40)
    v44 = &v53;
  return *(double *)v44->i64;
}

double cikernel::_areaMinAlphaV4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  float64x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  int8x16_t v13;
  float32x4_t v14;
  double v15;
  float64x2_t v16;
  float32x2_t v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float32x4_t v22;
  double v23;
  float64x2_t v24;
  float32x2_t v25;
  double v26;
  uint8x8_t v27;
  int8x16_t v28;
  int8x16_t v29;
  __int128 v30;
  double v31;
  float64x2_t v32;
  float32x2_t v33;
  double v34;
  uint8x8_t v35;
  int8x16_t v36;
  int8x16_t v37;
  __int128 v38;
  double v39;
  double v40;
  float32x4_t *v41;
  float32x4_t *v42;
  double v43;
  float32x4_t *v44;
  float v46;
  float32x4_t v47;
  float32x4_t v48;
  float64x2_t v49;
  __int128 v50;
  __int128 v51;
  float32x4_t v52;
  float32x4_t v53;

  *(float32x2_t *)&v6.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x408000003F800000);
  v49 = v6;
  v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)0xBFC0000000000000);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v7, 1), *((float *)this + 4), v7.f32[0]);
  LODWORD(v9) = *((_DWORD *)this + 7);
  v10.i32[0] = *((_DWORD *)this + 9);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *((float *)this + 6) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v7, v6, v8, v9, v11, v10, v12, v13);
  v48 = v14;
  HIDWORD(v15) = -1090519040;
  v16 = v49;
  v17 = vadd_f32(*(float32x2_t *)&v49.f64[0], (float32x2_t)0xBF00000000000000);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v17, 1), *((float *)this + 4), v17.f32[0]);
  LODWORD(v16.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v18) = *((_DWORD *)this + 7);
  v19.i32[0] = *((_DWORD *)this + 9);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v17, 1), *(float *)&v18, v17.f32[0]);
  v53 = v14;
  v14.f32[0] = *(float *)v16.f64 + *(float *)&v15;
  *(float *)v16.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v14.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v14.i64, v16, v15, v18, v20, v19, *(double *)&v17, v21);
  v47 = v22;
  HIDWORD(v23) = 1056964608;
  v24 = v49;
  v25 = vadd_f32(*(float32x2_t *)&v49.f64[0], (float32x2_t)0x3F00000000000000);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v25, 1), *((float *)this + 4), v25.f32[0]);
  LODWORD(v24.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v26) = *((_DWORD *)this + 7);
  v27.i32[0] = *((_DWORD *)this + 9);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v25, 1), *(float *)&v26, v25.f32[0]);
  v52 = v22;
  v22.f32[0] = *(float *)v24.f64 + *(float *)&v23;
  *(float *)v24.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  v22.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)&v30 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v22.i64, v24, v23, v26, v28, v27, *(double *)&v25, v29);
  v46 = *((float *)&v30 + 3);
  HIDWORD(v31) = 1069547520;
  v32 = v49;
  v33 = vadd_f32(*(float32x2_t *)&v49.f64[0], (float32x2_t)0x3FC0000000000000);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v33, 1), *((float *)this + 4), v33.f32[0]);
  LODWORD(v32.f64[0]) = *((_DWORD *)this + 6);
  LODWORD(v34) = *((_DWORD *)this + 7);
  v35.i32[0] = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v33, 1), *(float *)&v34, v33.f32[0]);
  v51 = v30;
  *(float *)&v30 = *(float *)v32.f64 + *(float *)&v31;
  *(float *)v32.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  *((float *)&v30 + 1) = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)&v38 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v30, v32, v31, v34, v36, v35, *(double *)&v33, v37);
  v50 = v38;
  v39 = *((float *)v49.f64 + 1);
  v40 = a3;
  v41 = &v52;
  if ((vmovn_s32(vcgeq_f32(v47, v48)).i8[6] & 1) != 0)
    v41 = &v53;
  if (*((float *)v49.f64 + 1) + -0.5 >= v40)
    v41 = &v53;
  v53 = *v41;
  v42 = (float32x4_t *)&v51;
  if (v53.f32[3] <= v46)
    v42 = &v53;
  if (v39 + 0.5 >= v40)
    v42 = &v53;
  v53 = *v42;
  v43 = v39 + 1.5;
  v44 = (float32x4_t *)&v50;
  if (v53.f32[3] <= *((float *)&v38 + 3))
    v44 = &v53;
  if (v43 >= v40)
    v44 = &v53;
  return *(double *)v44->i64;
}

double cikernel::_reduceCropMinMaxRed(cikernel *this, SamplerObj *a2, double a3, float64x2_t a4, double a5, double a6, int8x16_t a7, uint8x8_t a8, double a9, int8x16_t a10)
{
  double v10;
  int8x16_t v11;
  CI *v12;
  float32x4_t v13;
  float32x4_t v14;
  double result;
  int8x16_t v16;

  a7.i32[0] = 0.5;
  LODWORD(a5) = *((_DWORD *)this + 7);
  *(float *)&v10 = *((float *)this + 6)
                 + (float)((float)(*((float *)this + 5) * 0.5) + (float)(*((float *)this + 4) * 0.5));
  LODWORD(a6) = *((_DWORD *)this + 9);
  *(float *)a4.f64 = *(float *)&a6 + (float)((float)(*((float *)this + 8) * 0.5) + (float)(*(float *)&a5 * 0.5));
  *((float *)&v10 + 1) = *(float *)a4.f64;
  *(double *)v11.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v10, a4, a5, a6, a7, a8, a9, a10);
  v16 = v11;
  *(float32x2_t *)v13.f32 = vabs_f32(vadd_f32(*(float32x2_t *)CI::getDC(v12), (float32x2_t)0xBF000000BF000000));
  v13.f32[0] = fmaxf(v13.f32[0], v13.f32[1]);
  v14.i64[0] = COERCE_UNSIGNED_INT(0.5) | 0xBF00000000000000;
  *(_QWORD *)&result = vandq_s8(v16, (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v14, v13), 0)).u64[0];
  return result;
}

float64_t cikernel::_areaMinMaxRed16(uint64_t a1, float32x2_t a2, float a3)
{
  float32x2_t *DC;
  float64x2_t v7;
  double v8;
  int8x16_t v9;
  uint8x8_t v10;
  double v11;
  int8x16_t v12;
  float32x2_t v18;
  double v19;
  float64x2_t v20;
  float64x2_t v21;
  double v22;
  double v23;
  int32x2_t v24;
  float64x2_t v26;
  float64x2_t v27;
  float32x2_t v28;
  float64x2_t v29;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  __asm { FMOV            V1.2S, #4.0 }
  v18 = vmul_f32(*DC, _D1);
  v20.f64[0] = -5.05804416e157;
  v26 = v20;
  v19 = a3;
  LODWORD(v20.f64[0]) = -1.5;
  v27 = v20;
  do
  {
    LODWORD(v20.f64[0]) = -1.5;
    do
    {
      v29 = v20;
      v21 = v27;
      HIDWORD(v20.f64[0]) = LODWORD(v27.f64[0]);
      *(float32x2_t *)v9.i8 = vadd_f32(v18, *(float32x2_t *)&v20.f64[0]);
      LODWORD(v7.f64[0]) = *(_DWORD *)(a1 + 28);
      *(float *)&v22 = *(float *)(a1 + 24)
                     + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v9.i8, 1), *(float *)(a1 + 16), *(float *)v9.i32);
      LODWORD(v8) = *(_DWORD *)(a1 + 36);
      v28 = *(float32x2_t *)v9.i8;
      *(float *)v21.f64 = *(float *)&v8
                        + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v9.i8, 1), *(float *)v7.f64, *(float *)v9.i32);
      HIDWORD(v22) = LODWORD(v21.f64[0]);
      v23 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v22, v21, v7.f64[0], v8, v9, v10, v11, v12);
      if (v19 < 0.9)
        v23 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)&v23, 0));
      v24 = vcgt_f32(a2, v28);
      if ((v24.i8[0] & 1) != 0 && (v24.i8[4] & 1) != 0)
      {
        v7.f64[1] = v26.f64[1];
        *(float *)v7.f64 = fminf(*(float *)&v23, *(float *)v26.f64);
        HIDWORD(v7.f64[0]) = fmaxf(*((float *)&v23 + 1), *((float *)v26.f64 + 1));
        v26 = v7;
      }
      v20 = v29;
      *(float *)v20.f64 = *(float *)v29.f64 + 1.0;
    }
    while ((float)(*(float *)v29.f64 + 1.0) < 2.0);
    v20 = v27;
    *(float *)v20.f64 = *(float *)v27.f64 + 1.0;
    v27 = v20;
  }
  while (*(float *)v20.f64 < 2.0);
  return v26.f64[0];
}

__n64 cikernel::_areaMinMaxRed4(uint64_t a1, double a2, float a3)
{
  float32x2_t *DC;
  float64x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  int8x16_t v13;
  float64x2_t v14;
  float32x2_t v15;
  double v16;
  double v17;
  uint8x8_t v18;
  int8x16_t v19;
  double v20;
  int8x16_t v21;
  float64x2_t v22;
  float32x2_t v23;
  double v24;
  double v25;
  uint8x8_t v26;
  int8x16_t v27;
  double v28;
  int8x16_t v29;
  float64x2_t v30;
  float32x2_t v31;
  double v32;
  double v33;
  uint8x8_t v34;
  int8x16_t v35;
  double v36;
  int8x16_t v37;
  double v38;
  int32x2_t v39;
  int32x2_t v40;
  int32x2_t v41;
  double v42;
  float v43;
  float v44;
  double v45;
  double v46;
  float v47;
  BOOL v48;
  __n64 result;
  float v50;
  double v51;
  double v52;
  double v53;
  float64x2_t v55;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float32x2_t *)&v6.f64[0] = vadd_f32(*DC, *DC);
  v55 = v6;
  v7 = vadd_f32(*(float32x2_t *)&v6.f64[0], (float32x2_t)0xBF000000BF000000);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v7, 1), *(float *)(a1 + 16), v7.f32[0]);
  LODWORD(v9) = *(_DWORD *)(a1 + 28);
  v10.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v7, 1), *(float *)&v9, v7.f32[0]);
  v7.f32[0] = *(float *)(a1 + 24) + *(float *)&v8;
  *(float *)v6.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  v7.f32[1] = *(float *)v10.i32 + *(float *)v11.i32;
  v53 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v7, v6, v8, v9, v11, v10, v12, v13);
  v14 = v55;
  v15 = vadd_f32(*(float32x2_t *)&v55.f64[0], (float32x2_t)0xBF0000003F000000);
  *(float *)&v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v15, 1), *(float *)(a1 + 16), v15.f32[0]);
  LODWORD(v17) = *(_DWORD *)(a1 + 28);
  v18.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v15, 1), *(float *)&v17, v15.f32[0]);
  v15.f32[0] = *(float *)(a1 + 24) + *(float *)&v16;
  *(float *)v14.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v15.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  v52 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v15, v14, v16, v17, v19, v18, v20, v21);
  v22 = v55;
  v23 = vadd_f32(*(float32x2_t *)&v55.f64[0], (float32x2_t)0x3F000000BF000000);
  *(float *)&v24 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v23, 1), *(float *)(a1 + 16), v23.f32[0]);
  LODWORD(v25) = *(_DWORD *)(a1 + 28);
  v26.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v23, 1), *(float *)&v25, v23.f32[0]);
  v23.f32[0] = *(float *)(a1 + 24) + *(float *)&v24;
  *(float *)v22.f64 = *(float *)v26.i32 + *(float *)v27.i32;
  v23.f32[1] = *(float *)v26.i32 + *(float *)v27.i32;
  v51 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v23, v22, v24, v25, v27, v26, v28, v29);
  v30 = v55;
  v31 = vadd_f32(*(float32x2_t *)&v55.f64[0], (float32x2_t)0x3F0000003F000000);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v31, 1), *(float *)(a1 + 16), v31.f32[0]);
  LODWORD(v33) = *(_DWORD *)(a1 + 28);
  v34.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v31, 1), *(float *)&v33, v31.f32[0]);
  v31.f32[0] = *(float *)(a1 + 24) + *(float *)&v32;
  *(float *)v30.f64 = *(float *)v34.i32 + *(float *)v35.i32;
  v31.f32[1] = *(float *)v34.i32 + *(float *)v35.i32;
  v38 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v31, v30, v32, v33, v35, v34, v36, v37);
  if (a3 >= 0.9)
  {
    v40 = *(int32x2_t *)&v52;
    v39 = *(int32x2_t *)&v53;
    v41 = *(int32x2_t *)&v51;
  }
  else
  {
    v39 = vdup_lane_s32(*(int32x2_t *)&v53, 0);
    v40 = vdup_lane_s32(*(int32x2_t *)&v52, 0);
    v41 = vdup_lane_s32(*(int32x2_t *)&v51, 0);
    v38 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)&v38, 0));
  }
  v42 = COERCE_DOUBLE(vzip2_s32(v39, v41));
  v43 = fminf(*(float *)v41.i32, *(float *)&v38);
  v44 = fminf(*(float *)v39.i32, *(float *)v40.i32);
  v45 = COERCE_DOUBLE(vmaxnm_f32(*(float32x2_t *)&v42, (float32x2_t)vzip2_s32(v40, *(int32x2_t *)&v38)));
  if (*(float *)v55.f64 + 0.5 < *(float *)&a2)
  {
    v42 = v45;
  }
  else
  {
    v43 = *(float *)v41.i32;
    v44 = *(float *)v39.i32;
  }
  v46 = *((float *)v55.f64 + 1) + 0.5;
  v47 = fminf(v44, v43);
  v48 = v46 < *((float *)&a2 + 1);
  if (v46 >= *((float *)&a2 + 1))
    result.n64_f32[0] = v44;
  else
    result.n64_f32[0] = v47;
  v50 = fmaxf(*(float *)&v42, *((float *)&v42 + 1));
  if (v48)
    *(float *)&v42 = v50;
  result.n64_u32[1] = LODWORD(v42);
  return result;
}

double cikernel::_horizMinMaxRed4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  float64x2_t v7;
  float32x2_t v8;
  double v9;
  double v10;
  uint8x8_t v11;
  int8x16_t v12;
  double v13;
  int8x16_t v14;
  float64x2_t v15;
  float32x2_t v16;
  double v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  double v21;
  int8x16_t v22;
  float64x2_t v23;
  float32x2_t v24;
  double v25;
  double v26;
  uint8x8_t v27;
  int8x16_t v28;
  double v29;
  int8x16_t v30;
  float64x2_t v31;
  float32x2_t v32;
  double v33;
  double v34;
  uint8x8_t v35;
  int8x16_t v36;
  double v37;
  int8x16_t v38;
  double v39;
  int32x2_t v40;
  int32x2_t v41;
  int32x2_t v42;
  double v43;
  double v44;
  float v45;
  float v46;
  float v47;
  double v48;
  double v49;
  float v50;
  BOOL v51;
  double v52;
  float v53;
  float v54;
  float v55;
  double v57;
  double v58;
  double v59;
  float64x2_t v60;

  *(float32x2_t *)&v7.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x3F80000040800000);
  v60 = v7;
  v8 = vadd_f32(*(float32x2_t *)&v7.f64[0], (float32x2_t)3217031168);
  *(float *)&v9 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v8, 1), *((float *)this + 4), v8.f32[0]);
  LODWORD(v10) = *((_DWORD *)this + 7);
  v11.i32[0] = *((_DWORD *)this + 9);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v8, 1), *(float *)&v10, v8.f32[0]);
  v8.f32[0] = *((float *)this + 6) + *(float *)&v9;
  *(float *)v7.f64 = *(float *)v11.i32 + *(float *)v12.i32;
  v8.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  v59 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v8, v7, v9, v10, v12, v11, v13, v14);
  v15 = v60;
  v16 = vadd_f32(*(float32x2_t *)&v60.f64[0], (float32x2_t)3204448256);
  *(float *)&v17 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v16, 1), *((float *)this + 4), v16.f32[0]);
  LODWORD(v18) = *((_DWORD *)this + 7);
  v19.i32[0] = *((_DWORD *)this + 9);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v16, 1), *(float *)&v18, v16.f32[0]);
  v16.f32[0] = *((float *)this + 6) + *(float *)&v17;
  *(float *)v15.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v16.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  v58 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v16, v15, v17, v18, v20, v19, v21, v22);
  v23 = v60;
  v24 = vadd_f32(*(float32x2_t *)&v60.f64[0], (float32x2_t)1056964608);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v24, 1), *((float *)this + 4), v24.f32[0]);
  LODWORD(v26) = *((_DWORD *)this + 7);
  v27.i32[0] = *((_DWORD *)this + 9);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v24, 1), *(float *)&v26, v24.f32[0]);
  v24.f32[0] = *((float *)this + 6) + *(float *)&v25;
  *(float *)v23.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  v24.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  v57 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v24, v23, v25, v26, v28, v27, v29, v30);
  v31 = v60;
  v32 = vadd_f32(*(float32x2_t *)&v60.f64[0], (float32x2_t)1069547520);
  *(float *)&v33 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v32, 1), *((float *)this + 4), v32.f32[0]);
  LODWORD(v34) = *((_DWORD *)this + 7);
  v35.i32[0] = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v32, 1), *(float *)&v34, v32.f32[0]);
  v32.f32[0] = *((float *)this + 6) + *(float *)&v33;
  *(float *)v31.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  v32.f32[1] = *(float *)v35.i32 + *(float *)v36.i32;
  v39 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v32, v31, v33, v34, v36, v35, v37, v38);
  if (a4 >= 0.9)
  {
    v41 = *(int32x2_t *)&v58;
    v40 = *(int32x2_t *)&v59;
    v42 = *(int32x2_t *)&v57;
  }
  else
  {
    v40 = vdup_lane_s32(*(int32x2_t *)&v59, 0);
    v41 = vdup_lane_s32(*(int32x2_t *)&v58, 0);
    v42 = vdup_lane_s32(*(int32x2_t *)&v57, 0);
    v39 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)&v39, 0));
  }
  v43 = *(float *)v60.f64;
  v44 = a3;
  v45 = *(float *)&v40.i32[1];
  v46 = fminf(*(float *)v40.i32, *(float *)v41.i32);
  v47 = fmaxf(*(float *)&v40.i32[1], *(float *)&v41.i32[1]);
  if (*(float *)v60.f64 + -0.5 < a3)
    v45 = v47;
  else
    v46 = *(float *)v40.i32;
  v48 = v43 + 1.5;
  v49 = v43 + 0.5;
  v50 = fminf(v46, *(float *)v42.i32);
  v51 = v49 < v44;
  if (v49 >= v44)
    *(float *)&v52 = v46;
  else
    *(float *)&v52 = v50;
  v53 = fminf(*(float *)&v52, *(float *)&v39);
  v54 = fmaxf(v45, *(float *)&v42.i32[1]);
  if (v51)
    v45 = v54;
  if (v48 < v44)
    *(float *)&v52 = v53;
  v55 = fmaxf(v45, *((float *)&v39 + 1));
  if (v48 >= v44)
    v55 = v45;
  *((float *)&v52 + 1) = v55;
  return v52;
}

double cikernel::_vertMinMaxRed4(cikernel *this, SamplerObj *a2, float a3, float a4)
{
  float64x2_t v7;
  float32x2_t v8;
  double v9;
  double v10;
  uint8x8_t v11;
  int8x16_t v12;
  double v13;
  int8x16_t v14;
  float64x2_t v15;
  float32x2_t v16;
  double v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  double v21;
  int8x16_t v22;
  float64x2_t v23;
  float32x2_t v24;
  double v25;
  double v26;
  uint8x8_t v27;
  int8x16_t v28;
  double v29;
  int8x16_t v30;
  float64x2_t v31;
  float32x2_t v32;
  double v33;
  double v34;
  uint8x8_t v35;
  int8x16_t v36;
  double v37;
  int8x16_t v38;
  double v39;
  int32x2_t v40;
  int32x2_t v41;
  int32x2_t v42;
  double v43;
  double v44;
  float v45;
  float v46;
  float v47;
  double v48;
  double v49;
  float v50;
  BOOL v51;
  double v52;
  float v53;
  float v54;
  float v55;
  double v57;
  double v58;
  double v59;
  float64x2_t v60;

  *(float32x2_t *)&v7.f64[0] = vmul_f32(*(float32x2_t *)CI::getDC(this), (float32x2_t)0x408000003F800000);
  v60 = v7;
  v8 = vadd_f32(*(float32x2_t *)&v7.f64[0], (float32x2_t)0xBFC0000000000000);
  *(float *)&v9 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v8, 1), *((float *)this + 4), v8.f32[0]);
  LODWORD(v10) = *((_DWORD *)this + 7);
  v11.i32[0] = *((_DWORD *)this + 9);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v8, 1), *(float *)&v10, v8.f32[0]);
  v8.f32[0] = *((float *)this + 6) + *(float *)&v9;
  *(float *)v7.f64 = *(float *)v11.i32 + *(float *)v12.i32;
  v8.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  v59 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v8, v7, v9, v10, v12, v11, v13, v14);
  v15 = v60;
  v16 = vadd_f32(*(float32x2_t *)&v60.f64[0], (float32x2_t)0xBF00000000000000);
  *(float *)&v17 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v16, 1), *((float *)this + 4), v16.f32[0]);
  LODWORD(v18) = *((_DWORD *)this + 7);
  v19.i32[0] = *((_DWORD *)this + 9);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v16, 1), *(float *)&v18, v16.f32[0]);
  v16.f32[0] = *((float *)this + 6) + *(float *)&v17;
  *(float *)v15.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v16.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  v58 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v16, v15, v17, v18, v20, v19, v21, v22);
  v23 = v60;
  v24 = vadd_f32(*(float32x2_t *)&v60.f64[0], (float32x2_t)0x3F00000000000000);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v24, 1), *((float *)this + 4), v24.f32[0]);
  LODWORD(v26) = *((_DWORD *)this + 7);
  v27.i32[0] = *((_DWORD *)this + 9);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v24, 1), *(float *)&v26, v24.f32[0]);
  v24.f32[0] = *((float *)this + 6) + *(float *)&v25;
  *(float *)v23.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  v24.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  v57 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v24, v23, v25, v26, v28, v27, v29, v30);
  v31 = v60;
  v32 = vadd_f32(*(float32x2_t *)&v60.f64[0], (float32x2_t)0x3FC0000000000000);
  *(float *)&v33 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v32, 1), *((float *)this + 4), v32.f32[0]);
  LODWORD(v34) = *((_DWORD *)this + 7);
  v35.i32[0] = *((_DWORD *)this + 9);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v32, 1), *(float *)&v34, v32.f32[0]);
  v32.f32[0] = *((float *)this + 6) + *(float *)&v33;
  *(float *)v31.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  v32.f32[1] = *(float *)v35.i32 + *(float *)v36.i32;
  v39 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v32, v31, v33, v34, v36, v35, v37, v38);
  if (a4 >= 0.9)
  {
    v41 = *(int32x2_t *)&v58;
    v40 = *(int32x2_t *)&v59;
    v42 = *(int32x2_t *)&v57;
  }
  else
  {
    v40 = vdup_lane_s32(*(int32x2_t *)&v59, 0);
    v41 = vdup_lane_s32(*(int32x2_t *)&v58, 0);
    v42 = vdup_lane_s32(*(int32x2_t *)&v57, 0);
    v39 = COERCE_DOUBLE(vdup_lane_s32(*(int32x2_t *)&v39, 0));
  }
  v43 = *((float *)v60.f64 + 1);
  v44 = a3;
  v45 = *(float *)&v40.i32[1];
  v46 = fminf(*(float *)v40.i32, *(float *)v41.i32);
  v47 = fmaxf(*(float *)&v40.i32[1], *(float *)&v41.i32[1]);
  if (*((float *)v60.f64 + 1) + -0.5 < a3)
    v45 = v47;
  else
    v46 = *(float *)v40.i32;
  v48 = v43 + 1.5;
  v49 = v43 + 0.5;
  v50 = fminf(v46, *(float *)v42.i32);
  v51 = v49 < v44;
  if (v49 >= v44)
    *(float *)&v52 = v46;
  else
    *(float *)&v52 = v50;
  v53 = fminf(*(float *)&v52, *(float *)&v39);
  v54 = fmaxf(v45, *(float *)&v42.i32[1]);
  if (v51)
    v45 = v54;
  if (v48 < v44)
    *(float *)&v52 = v53;
  v55 = fmaxf(v45, *((float *)&v39 + 1));
  if (v48 >= v44)
    v55 = v45;
  *((float *)&v52 + 1) = v55;
  return v52;
}

float64_t cikernel::_redThreshold(float64x2_t a1, float64x2_t a2)
{
  a1.f64[0] = *(float *)a1.f64;
  a2.f64[0] = 0.00001;
  *(_QWORD *)&a1.f64[0] = vbslq_s8((int8x16_t)vdupq_lane_s64(vcgtq_f64(a1, a2).i64[0], 0), (int8x16_t)xmmword_1924947C0, (int8x16_t)xmmword_19248E050).u64[0];
  return a1.f64[0];
}

uint64_t cikernel::_maskBoundsInit(CI *a1, float a2)
{
  uint64_t result;

  result = CI::getDC(a1);
  if (a2 > 0.00001)
  {
    __asm
    {
      FMOV            V1.2S, #1.0
      FMOV            V2.2S, #0.25
    }
  }
  return result;
}

void cikernel::_maskBoundsReduce(cikernel *this, SamplerObj *a2)
{
  float32x2_t *DC;
  float32x2_t v4;
  float32x2_t v5;
  double v6;
  double v7;
  uint8x8_t v8;
  int8x16_t v9;
  float64x2_t v10;
  double v11;
  int8x16_t v12;
  int8x16_t v13;
  double v14;
  double v15;
  uint8x8_t v16;
  int8x16_t v17;
  float64x2_t v18;
  double v19;
  int8x16_t v20;
  int8x16_t v21;
  float64x2_t v22;
  int8x16_t v23;
  double v24;
  int8x16_t v25;
  uint8x8_t v26;
  double v27;
  int8x16_t v28;
  float32x2_t v29;
  double v30;
  float64x2_t v31;
  double v32;
  double v33;
  int8x16_t v34;
  uint8x8_t v35;
  double v36;
  int8x16_t v37;
  float v38;
  float32x2_t v39;
  int8x16_t v40;

  DC = (float32x2_t *)CI::getDC(this);
  v4 = vadd_f32(*DC, *DC);
  v5 = vadd_f32(v4, (float32x2_t)0x3F0000003F000000);
  *(float *)&v6 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v5, 1), *((float *)this + 4), v5.f32[0]);
  LODWORD(v7) = *((_DWORD *)this + 7);
  v8.i32[0] = *((_DWORD *)this + 9);
  *(float *)v9.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v5, 1), *(float *)&v7, v5.f32[0]);
  v5.f32[0] = *((float *)this + 6) + *(float *)&v6;
  *(float *)v10.f64 = *(float *)v8.i32 + *(float *)v9.i32;
  v5.f32[1] = *(float *)v8.i32 + *(float *)v9.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v5, v10, v6, v7, v9, v8, v11, v12);
  v40 = v13;
  *(float32x2_t *)v13.i8 = vadd_f32(v4, (float32x2_t)0xBF0000003F000000);
  *(float *)&v14 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v13.i8, 1), *((float *)this + 4), *(float *)v13.i32);
  LODWORD(v15) = *((_DWORD *)this + 7);
  v16.i32[0] = *((_DWORD *)this + 9);
  *(float *)v17.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v13.i8, 1), *(float *)&v15, *(float *)v13.i32);
  *(float *)v13.i32 = *((float *)this + 6) + *(float *)&v14;
  *(float *)v18.f64 = *(float *)v16.i32 + *(float *)v17.i32;
  *(float *)&v13.i32[1] = *(float *)v16.i32 + *(float *)v17.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v13.i64, v18, v14, v15, v17, v16, v19, v20);
  if (*(float *)&v21.i32[2] > 0.0)
  {
    v23.i32[1] = v40.i32[1];
    if (*(float *)&v40.i32[2] <= 0.0)
    {
      v40 = v21;
    }
    else
    {
      v22 = (float64x2_t)vextq_s8(v40, v40, 8uLL);
      *(float32x2_t *)v23.i8 = vminnm_f32(*(float32x2_t *)v21.i8, *(float32x2_t *)v40.i8);
      v23.u64[1] = (unint64_t)vmaxnm_f32((float32x2_t)*(_OWORD *)&vextq_s8(v21, v21, 8uLL), *(float32x2_t *)&v22.f64[0]);
      v40 = v23;
    }
  }
  v29 = vadd_f32(v4, (float32x2_t)0x3F000000BF000000);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v29, 1), *((float *)this + 4), v29.f32[0]);
  LODWORD(v24) = *((_DWORD *)this + 7);
  v26.i32[0] = *((_DWORD *)this + 9);
  *(float *)v25.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v29, 1), *(float *)&v24, v29.f32[0]);
  v29.f32[0] = *((float *)this + 6) + *(float *)v23.i32;
  *(float *)v22.f64 = *(float *)v26.i32 + *(float *)v25.i32;
  v29.f32[1] = *(float *)v26.i32 + *(float *)v25.i32;
  v30 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v29, v22, *(double *)v23.i64, v24, v25, v26, v27, v28);
  if (v38 > 0.0)
  {
    HIDWORD(v32) = v40.i32[1];
    if (*(float *)&v40.i32[2] > 0.0)
    {
      v31 = (float64x2_t)vextq_s8(v40, v40, 8uLL);
      v32 = COERCE_DOUBLE(vminnm_f32(*(float32x2_t *)&v30, *(float32x2_t *)v40.i8));
    }
  }
  v39 = vadd_f32(v4, (float32x2_t)0xBF000000BF000000);
  *(float *)&v32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v39, 1), *((float *)this + 4), v39.f32[0]);
  LODWORD(v33) = *((_DWORD *)this + 7);
  v35.i32[0] = *((_DWORD *)this + 9);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v39, 1), *(float *)&v33, v39.f32[0]);
  v39.f32[0] = *((float *)this + 6) + *(float *)&v32;
  *(float *)v31.f64 = *(float *)v35.i32 + *(float *)v34.i32;
  v39.f32[1] = *(float *)v35.i32 + *(float *)v34.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v39, v31, v32, v33, v34, v35, v36, v37);
}

double cikernel::_minMaxNormalize(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  float32x4_t v3;
  float32x4_t v4;
  double result;

  v3 = vsubq_f32(a1, a2);
  v4 = vsubq_f32(a3, a2);
  v4.i32[3] = 0;
  *(_QWORD *)&result = vdivq_f32(v3, vmaxnmq_f32(v4, (float32x4_t)xmmword_192491FC0)).u64[0];
  return result;
}

float cikernel::_minMaxRedNormalize(float32x4_t a1, float32x4_t a2)
{
  return vsubq_f32(a1, a2).f32[0]
       / fmaxf(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 1), a2).f32[0], 0.00001);
}

double cikernel::_KM_select(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4, float a5)
{
  float32x2_t *DC;
  double v10;
  double v11;
  uint8x8_t v12;
  int8x16_t v13;
  double v14;
  float64x2_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  double v19;
  uint8x8_t v20;
  int8x16_t v21;
  double v22;
  float64x2_t v23;
  double v24;
  int8x16_t v25;
  float32x4_t v26;
  double v27;
  int8x16_t v28;
  uint8x8_t v29;
  double v30;
  int8x16_t v31;
  int v32;
  double v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float v37;
  double v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v43;
  float32x4_t v44;

  DC = (float32x2_t *)CI::getDC(this);
  *(float *)&v10 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v11) = *((_DWORD *)this + 7);
  v12.i32[0] = *((_DWORD *)this + 9);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v11, COERCE_FLOAT(*DC));
  *(float *)&v14 = *((float *)this + 6) + *(float *)&v10;
  *(float *)v15.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  *((float *)&v14 + 1) = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v14, v15, v10, v11, v13, v12, v16, v17);
  v44 = v18;
  LODWORD(v19) = *((_DWORD *)a2 + 6);
  v20.i32[0] = *((_DWORD *)a2 + 9);
  *(float *)v21.i32 = *((float *)a2 + 8) * 0.5;
  *(float *)&v22 = *(float *)v21.i32 + (float)((float)(a5 + 0.5) * *((float *)a2 + 7));
  v18.f32[0] = *(float *)&v19
             + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)((float)(a5 + 0.5) * *((float *)a2 + 4)));
  *(float *)v23.f64 = *(float *)v20.i32 + *(float *)&v22;
  v18.f32[1] = *(float *)v20.i32 + *(float *)&v22;
  *(double *)v26.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v18.i64, v23, v19, v22, v21, v20, v24, v25);
  if ((int)a4 < 1)
    return *(double *)v44.i64;
  v32 = 0;
  v33 = *(double *)v44.i64;
  v34 = vsubq_f32(v44, v26);
  v35 = vmulq_f32(v34, v34);
  v36 = vaddq_f32(v35, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1));
  v43 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), v36);
  while (1)
  {
    if ((int)a5 != v32)
    {
      v37 = (float)v32 + 0.5;
      LODWORD(v33) = *((_DWORD *)a2 + 6);
      v29.i32[0] = *((_DWORD *)a2 + 9);
      *(float *)v28.i32 = *((float *)a2 + 8) * 0.5;
      *(float *)&v27 = *(float *)v28.i32 + (float)(v37 * *((float *)a2 + 7));
      *(float *)&v38 = *(float *)&v33 + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)(v37 * *((float *)a2 + 4)));
      v36.f32[0] = *(float *)v29.i32 + *(float *)&v27;
      *((float *)&v38 + 1) = *(float *)v29.i32 + *(float *)&v27;
      *(double *)v39.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), v38, (float64x2_t)v36, v33, v27, v28, v29, v30, v31);
      v33 = *(double *)v44.i64;
      v40 = vsubq_f32(v44, v39);
      v41 = vmulq_f32(v40, v40);
      v36 = v43;
      if ((vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgtq_f32(v43, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v41, 2), vaddq_f32(v41, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 1)))))).u8[0] & 1) == 0)break;
    }
    if ((int)a4 == ++v32)
      return v33;
  }
  return 0.0;
}

void cikernel::_KM_defuse(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4, float a5)
{
  float32x2_t *DC;
  int8x16_t v10;
  double v11;
  double v12;
  double v13;
  float64x2_t v14;
  uint8x8_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  double v19;
  double v20;
  float64x2_t v21;
  uint8x8_t v22;
  double v23;
  int8x16_t v24;
  double v25;
  float32x4_t v26;
  float32x4_t v27;
  uint8x8_t v28;
  double v29;
  float32x4_t v30;
  float64x2_t v31;
  int v32;
  float v33;
  double v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int v38;
  __int32 v39;
  __int32 v40;
  int8x16_t v41;

  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v10.i8 = *DC;
  v41 = v10;
  LODWORD(v11) = *((_DWORD *)this + 7);
  *(float *)&v12 = *((float *)this + 6)
                 + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v13) = *((_DWORD *)this + 9);
  *(float *)v14.f64 = *(float *)&v13
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v11, COERCE_FLOAT(*DC));
  HIDWORD(v12) = LODWORD(v14.f64[0]);
  *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v12, v14, v11, v13, v10, v15, v16, v17);
  v37 = v18;
  LODWORD(v19) = *((_DWORD *)a2 + 7);
  v18.f32[0] = *((float *)a2 + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 5), *(float32x2_t *)v41.i8, 1), *((float *)a2 + 4), *(float *)v41.i32);
  LODWORD(v20) = *((_DWORD *)a2 + 9);
  *(float *)v21.f64 = *(float *)&v20
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)a2 + 8), *(float32x2_t *)v41.i8, 1), *(float *)&v19, *(float *)v41.i32);
  v18.i32[1] = LODWORD(v21.f64[0]);
  CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v18.i64, v21, v19, v20, v41, v22, v23, v24);
  v31.f64[0] = -0.5;
  v32 = (int)(*(float *)v41.i32 + -0.5) + 1;
  do
  {
    if (v32 >= (int)a4)
      break;
    v33 = (float)v32 + 0.5;
    LODWORD(v25) = *((_DWORD *)this + 6);
    v28.i32[0] = *((_DWORD *)this + 9);
    v27.f32[0] = *((float *)this + 8) * 0.5;
    v26.f32[0] = v27.f32[0] + (float)(v33 * *((float *)this + 7));
    *(float *)&v34 = *(float *)&v25 + (float)((float)(*((float *)this + 5) * 0.5) + (float)(v33 * *((float *)this + 4)));
    *(float *)v31.f64 = *(float *)v28.i32 + v26.f32[0];
    *((float *)&v34 + 1) = *(float *)v28.i32 + v26.f32[0];
    *(double *)v35.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v34, v31, v25, *(double *)v26.i64, (int8x16_t)v27, v28, v29, (int8x16_t)v30);
    v28.i32[1] = v37.i32[1];
    v31 = (float64x2_t)v37;
    HIDWORD(v31.f64[1]) = v38;
    HIDWORD(v25) = v35.i32[1];
    v26 = vsubq_f32(v37, v35);
    v27 = v26;
    v27.i32[3] = v39;
    v26.i32[3] = v40;
    v36 = vmulq_f32(v27, v26);
    v30 = vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1));
    *(_QWORD *)&v29 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), v30).u64[0];
    ++v32;
  }
  while (*(float *)&v29 >= a5);
}

double cikernel::_ACWeightedCoordinatesR(CI *a1, float a2, int8x16_t a3)
{
  float32x4_t v3;
  double result;

  *(float32x2_t *)v3.f32 = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a3.i8));
  __asm { FMOV            V1.2S, #1.0 }
  v3.i64[1] = _D1;
  *(_QWORD *)&result = vmulq_n_f32(v3, a2).u64[0];
  return result;
}

float32x2_t cikernel::_ACCentroid(__n128 a1, int8x16_t a2, double a3)
{
  *(float *)&a3 = fmaxf(a1.n128_f32[2], 0.0001);
  return vadd_f32(*(float32x2_t *)a2.i8, vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), vdiv_f32((float32x2_t)a1.n128_u64[0], (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0))));
}

double cikernel::_RCFalloffGaussian(CI *a1, float32x4_t a2, float32x2_t a3, float a4)
{
  float32x2_t v5;
  double result;

  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a3);
  *(_QWORD *)&result = vmulq_n_f32(a2, expf(-(float)(vaddv_f32(vmul_f32(v5, v5)) * a4))).u64[0];
  return result;
}

double cikernel::_RCFalloffDisk(CI *a1, float32x4_t a2, float32x2_t a3, float a4)
{
  float32x2_t v5;
  BOOL v6;
  float v7;
  double result;

  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a3);
  v6 = vaddv_f32(vmul_f32(v5, v5)) < a4;
  v7 = 0.0;
  if (v6)
    v7 = 1.0;
  *(_QWORD *)&result = vmulq_n_f32(a2, v7).u64[0];
  return result;
}

void CI::f4_f2(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, double);
  int v12;
  uint64_t v13;
  double *v14;
  __int128 v15;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, double))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 32)), a2);
  v14 = (double *)(a3 + 16 * v13);
  if (v12 != 5)
    v14 = (double *)((char *)a2 + 64 * v13);
  *(double *)&v15 = v11(a1, *v14);
  *(_OWORD *)(a3 + 16 * a7) = v15;
}

double cikernel::_RCSelectGreaterThan(int8x16_t a1, int8x16_t a2, int32x2_t a3, float32x4_t a4)
{
  double result;

  *(_QWORD *)&result = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32((float32x4_t)vdupq_lane_s32(a3, 1), a4), 0), a1, a2).u64[0];
  return result;
}

double cikernel::_PSDrawSpread(CI *a1, float32x2_t a2, double a3)
{
  float32x2_t v3;
  float32x4_t v4;
  double result;
  float32x4_t v11;

  *(double *)v11.i64 = a3;
  v3 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  *(float32x2_t *)v4.f32 = vmul_f32(v3, v3);
  v4.f32[0] = vaddv_f32(*(float32x2_t *)v4.f32);
  __asm { FMOV            V1.4S, #1.0 }
  *(_QWORD *)&result = vandq_s8(_Q1, (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgeq_f32(v11, v4), 0)).u64[0];
  return result;
}

double cikernel::_PC_coord(cikernel *this, SamplerObj *a2, SamplerObj *a3, float a4, float a5)
{
  float32x2_t *DC;
  double v10;
  double v11;
  uint8x8_t v12;
  int8x16_t v13;
  double v14;
  float64x2_t v15;
  double v16;
  int8x16_t v17;
  float32x4_t v18;
  double v19;
  uint8x8_t v20;
  int8x16_t v21;
  double v22;
  float64x2_t v23;
  double v24;
  int8x16_t v25;
  float32x4_t v26;
  int8x16_t v27;
  uint8x8_t v28;
  double v29;
  int8x16_t v30;
  uint64_t v31;
  int v32;
  double v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float v38;
  double v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v44;
  float32x4_t v45;

  DC = (float32x2_t *)CI::getDC(this);
  *(float *)&v10 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v11) = *((_DWORD *)this + 7);
  v12.i32[0] = *((_DWORD *)this + 9);
  *(float *)v13.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v11, COERCE_FLOAT(*DC));
  *(float *)&v14 = *((float *)this + 6) + *(float *)&v10;
  *(float *)v15.f64 = *(float *)v12.i32 + *(float *)v13.i32;
  *((float *)&v14 + 1) = *(float *)v12.i32 + *(float *)v13.i32;
  *(double *)v18.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v14, v15, v10, v11, v13, v12, v16, v17);
  v45 = v18;
  LODWORD(v19) = *((_DWORD *)a2 + 6);
  v20.i32[0] = *((_DWORD *)a2 + 9);
  *(float *)v21.i32 = *((float *)a2 + 8) * 0.5;
  *(float *)&v22 = *(float *)v21.i32 + (float)((float)(a5 + 0.5) * *((float *)a2 + 7));
  v18.f32[0] = *(float *)&v19
             + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)((float)(a5 + 0.5) * *((float *)a2 + 4)));
  *(float *)v23.f64 = *(float *)v20.i32 + *(float *)&v22;
  v18.f32[1] = *(float *)v20.i32 + *(float *)&v22;
  *(double *)v26.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), *(double *)v18.i64, v23, v19, v22, v21, v20, v24, v25);
  v31 = 1065353216;
  if ((int)a4 >= 1)
  {
    v32 = 0;
    HIDWORD(v33) = v45.i32[1];
    v34 = vsubq_f32(v45, v26);
    v35 = vmulq_f32(v34, v34);
    v36 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1);
    v37 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2);
    v44 = vaddq_f32(v37, vaddq_f32(v35, v36));
    while (1)
    {
      if ((int)a5 != v32)
      {
        v38 = (float)v32 + 0.5;
        v37.i32[0] = *((_DWORD *)a2 + 6);
        v28.i32[0] = *((_DWORD *)a2 + 9);
        *(float *)v27.i32 = *((float *)a2 + 8) * 0.5;
        *(float *)&v33 = *(float *)v27.i32 + (float)(v38 * *((float *)a2 + 7));
        *(float *)&v39 = v37.f32[0] + (float)((float)(*((float *)a2 + 5) * 0.5) + (float)(v38 * *((float *)a2 + 4)));
        v36.f32[0] = *(float *)v28.i32 + *(float *)&v33;
        *((float *)&v39 + 1) = *(float *)v28.i32 + *(float *)&v33;
        *(double *)v40.i64 = CI::BitmapSampler::read(*((uint64x2_t **)a2 + 1), v39, (float64x2_t)v36, *(double *)v37.i64, v33, v27, v28, v29, v30);
        HIDWORD(v33) = v45.i32[1];
        v41 = vsubq_f32(v45, v40);
        v42 = vmulq_f32(v41, v41);
        v36 = v44;
        if ((vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgtq_f32(v44, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1)))))).u8[0] & 1) == 0)break;
      }
      if ((int)a4 == ++v32)
      {
        v31 = 1065353216;
        return *(double *)&v31;
      }
    }
    *(double *)&v31 = 0.0;
  }
  return *(double *)&v31;
}

void sub_192368BD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__16(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

double affine::inverse@<D0>(affine *this@<X0>, double *a2@<X8>)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double result;
  double v9;

  v3 = *(double *)this;
  v4 = *((double *)this + 1);
  v5 = *((double *)this + 2);
  v6 = *((double *)this + 3);
  v7 = *(double *)this * v6 - v4 * v5;
  if (fabs(v7) >= 1.0e-10)
  {
    v9 = 1.0 / v7;
    *a2 = v6 * v9;
    a2[1] = v9 * -v4;
    result = v3 * v9;
    a2[2] = -(v5 * v9);
    a2[3] = result;
  }
  else
  {
    printf("singular matrix cannot be inverted");
    result = 0.0;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
  }
  return result;
}

void roiForPoints(double a1, double a2, double a3, double a4)
{
  CGFloat v4;
  float v5;
  float v6;
  float v7;
  CGRect v8;
  CGRect v9;
  CGRect v10;

  v4 = fminf(fminf(fminf(*(float *)&a1, *(float *)&a2), *(float *)&a3), *(float *)&a4);
  v5 = fmaxf(fmaxf(fmaxf(*(float *)&a1, *(float *)&a2), *(float *)&a3), *(float *)&a4);
  v6 = *((float *)&a2 + 1);
  v8.origin.y = fminf(fminf(fminf(*((float *)&a1 + 1), *((float *)&a2 + 1)), *((float *)&a3 + 1)), *((float *)&a4 + 1));
  v7 = fmaxf(fmaxf(fmaxf(*((float *)&a1 + 1), v6), *((float *)&a3 + 1)), *((float *)&a4 + 1));
  v8.size.width = v5 - v4;
  v8.size.height = v7 - v8.origin.y;
  v8.origin.x = v4;
  v9 = CGRectInset(v8, -0.0001, -0.0001);
  v10 = CGRectIntegral(v9);
  if (v10.size.height < 1.5)
    v10 = CGRectInset(v10, 0.0, -1.0);
  if (v10.size.width < 1.5)
    CGRectInset(v10, 0.0, -1.0);
}

void roiForPoints(double a1, double a2, double a3)
{
  CGFloat v3;
  float v4;
  float v5;
  float v6;
  CGRect v7;
  CGRect v8;
  CGRect v9;

  v3 = fminf(fminf(*(float *)&a1, *(float *)&a2), *(float *)&a3);
  v4 = fmaxf(fmaxf(*(float *)&a1, *(float *)&a2), *(float *)&a3);
  v5 = *((float *)&a2 + 1);
  v7.origin.y = fminf(fminf(*((float *)&a1 + 1), *((float *)&a2 + 1)), *((float *)&a3 + 1));
  v6 = fmaxf(fmaxf(*((float *)&a1 + 1), v5), *((float *)&a3 + 1));
  v7.size.width = v4 - v3;
  v7.size.height = v6 - v7.origin.y;
  v7.origin.x = v3;
  v8 = CGRectInset(v7, -0.0001, -0.0001);
  v9 = CGRectIntegral(v8);
  if (v9.size.height < 1.5)
    v9 = CGRectInset(v9, 0.0, -1.0);
  if (v9.size.width < 1.5)
    CGRectInset(v9, 0.0, -1.0);
}

float32x2_t cikernel::_fourfoldRotatedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v20;
  float32x2_t v21;
  int32x2_t v22;
  int32x2_t v23;

  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  v8 = vadd_f32((float32x2_t)vzip1_s32(v6, v7), (float32x2_t)vzip2_s32(v6, v7));
  v9 = vrndm_f32(v8);
  v10 = vmul_f32(v9, (float32x2_t)0x3F0000003F000000);
  v11 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
  v12 = vminnm_f32(vsub_f32(v10, vrndm_f32(v10)), v11);
  v13 = vadd_f32(v12, v12);
  v14 = vminnm_f32(vsub_f32(v8, v9), v11);
  __asm { FMOV            V1.2S, #1.0 }
  v20 = vsub_f32(_D1, v14);
  v21 = vmla_lane_f32(vmul_n_f32(vmla_n_f32(vmul_n_f32(v14, 1.0 - v13.f32[0]), (float32x2_t)vext_s8((int8x8_t)v14, (int8x8_t)v20, 4uLL), v13.f32[0]), 1.0 - v13.f32[1]), vmla_n_f32(vmul_n_f32((float32x2_t)vext_s8((int8x8_t)v20, (int8x8_t)v14, 4uLL), 1.0 - v13.f32[0]), v20, v13.f32[0]), v13, 1);
  v22 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v21);
  v23 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v21);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v22, v23), (float32x2_t)vzip2_s32(v22, v23)));
}

float32x2_t cikernel::_sixfoldRotatedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  int32x2_t v12;
  int8x8_t v13;
  __int32 v14;
  int32x2_t v15;
  double v16;
  int32x2_t v17;
  __int32 v18;
  int8x8_t v19;
  float32x2_t v20;
  int32x2_t v21;
  int32x2_t v22;

  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  v8 = (float32x2_t)vzip1_s32(v6, v7);
  v9 = vadd_f32(v8, (float32x2_t)vzip2_s32(v6, v7));
  v10 = vminnm_f32(vsub_f32(v9, vrndm_f32(v9)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  *(float *)v6.i32 = 1.0 - v10.f32[1];
  v8.f32[0] = vaddv_f32(v10) + -1.0;
  v6.i32[1] = v8.i32[0];
  v11.i32[0] = 0;
  v12 = (int32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vcgt_f32(v11, v8), 0), (int8x8_t)v10, (int8x8_t)v6);
  v13.i32[0] = vdup_lane_s32(v12, 1).u32[0];
  *(float *)&v14 = 1.0 - *(float *)v12.i32 - *(float *)&v12.i32[1];
  v13.i32[1] = v14;
  v15 = (int32x2_t)vbsl_s8((int8x8_t)vcgtd_f64(0.0, *(float *)v12.i32 * -2.0 + 1.0 - *(float *)&v12.i32[1]), v13, (int8x8_t)v12);
  v16 = 1.0 - *(float *)v15.i32 - *(float *)&v15.i32[1];
  *(float *)&v16 = v16;
  v17 = (int32x2_t)vbsl_s8((int8x8_t)vcgtd_f64(0.0, *(float *)&v15.i32[1] * -2.0 + 1.0 - *(float *)v15.i32), (int8x8_t)vzip1_s32(*(int32x2_t *)&v16, v15), (int8x8_t)v15);
  *(float *)&v18 = 1.0 - *(float *)v17.i32 - *(float *)&v17.i32[1];
  v19.i32[0] = vdup_lane_s32(v17, 1).u32[0];
  v19.i32[1] = v18;
  v20 = (float32x2_t)vbsl_s8((int8x8_t)vcgtd_f64(0.0, *(float *)v17.i32 * -2.0 + 1.0 - *(float *)&v17.i32[1]), v19, (int8x8_t)v17);
  v21 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v20);
  v22 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v20);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v21, v22), (float32x2_t)vzip2_s32(v21, v22)));
}

float32x2_t cikernel::_twelvefoldReflectedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  int32x2_t v8;
  float32x2_t v9;
  int32x2_t v10;
  float32x2_t v16;
  double v17;
  float32x2_t v18;
  float32x2_t v19;
  double v20;
  float v21;
  float v22;
  float v23;
  int32x2_t v24;
  int32x2_t v25;

  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v7 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  v8 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  v9 = vadd_f32((float32x2_t)vzip1_s32(v7, v8), (float32x2_t)vzip2_s32(v7, v8));
  v10 = (int32x2_t)vminnm_f32(vsub_f32(v9, vrndm_f32(v9)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  if (vsub_f32((float32x2_t)v10, (float32x2_t)vdup_lane_s32(v10, 1)).f32[0] >= 0.0)
    *(float *)v6.i32 = 0.0;
  else
    *(float *)v6.i32 = 1.0;
  __asm { FMOV            V6.2S, #1.0 }
  v16 = vmla_n_f32(vmul_f32((float32x2_t)vrev64_s32(v10), vsub_f32(_D6, (float32x2_t)vdup_lane_s32(v6, 0))), (float32x2_t)v10, *(float *)v6.i32);
  v17 = 1.0 - v16.f32[0] - v16.f32[1];
  *(float *)&v17 = v17;
  v18 = (float32x2_t)vrev64_s32((int32x2_t)vsub_f32(_D6, v16));
  if (*(float *)&v17 >= 0.0)
    *(float *)&v17 = 0.0;
  else
    *(float *)&v17 = 1.0;
  v19 = vmla_n_f32(vmul_f32(v16, vsub_f32(_D6, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v17, 0))), v18, *(float *)&v17);
  v20 = v19.f32[1];
  v21 = v19.f32[0] * -2.0 + 1.0 - v19.f32[1];
  *(float *)&v17 = 1.0 - v19.f32[0] - v19.f32[1];
  if (v21 >= 0.0)
    *(float *)&v17 = v19.f32[0];
  v22 = *(float *)&v17 * -0.5 + 0.5 - v20;
  v23 = 1.0 - *(float *)&v17 - v20;
  if (v22 >= 0.0)
    v23 = v19.f32[1];
  *((float *)&v17 + 1) = v23;
  v24 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, *(float32x2_t *)&v17);
  v25 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), *(float32x2_t *)&v17);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v24, v25), (float32x2_t)vzip2_s32(v24, v25)));
}

float32x2_t cikernel::_fourfoldTranslatedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  int32x2_t v10;
  int32x2_t v11;

  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  v8 = vadd_f32((float32x2_t)vzip1_s32(v6, v7), (float32x2_t)vzip2_s32(v6, v7));
  v9 = vminnm_f32(vsub_f32(v8, vrndm_f32(v8)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  v10 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v9);
  v11 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v9);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v10, v11), (float32x2_t)vzip2_s32(v10, v11)));
}

float32x2_t cikernel::_glideReflectedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x2_t v23;
  int32x2_t v24;

  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  v8 = vadd_f32((float32x2_t)vzip1_s32(v6, v7), (float32x2_t)vzip2_s32(v6, v7));
  v9 = vrndm_f32(v8);
  v10 = vmul_f32(v9, (float32x2_t)0x3F0000003F000000);
  v11 = (float32x2_t)vdup_n_s32(0x3F7FFFFFu);
  v12 = vminnm_f32(vsub_f32(v10, vrndm_f32(v10)), v11);
  v13 = vadd_f32(v12, v12);
  v14 = vminnm_f32(vsub_f32(v8, v9), v11);
  __asm { FMOV            V1.2S, #1.0 }
  v11.i32[0] = vsub_f32(_D1, v14).u32[0];
  v11.i32[1] = vadd_f32(v14, _D1).i32[1];
  v20 = (float32x2_t)__PAIR64__(v14.u32[1], v11.u32[0]);
  v21 = vmul_n_f32(v14, 1.0 - v13.f32[0]);
  v14.i32[1] = v11.i32[1];
  v22 = vmla_lane_f32(vmul_n_f32(vmla_n_f32(v21, v11, v13.f32[0]), 1.0 - v13.f32[1]), vmla_n_f32(vmul_n_f32(v14, 1.0 - v13.f32[0]), v20, v13.f32[0]), v13, 1);
  v23 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v22);
  v24 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v22);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v23, v24), (float32x2_t)vzip2_s32(v23, v24)));
}

float32x2_t cikernel::_eightfoldReflectedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  int32x2_t v15;
  int32x2_t v16;
  float32x2_t v17;
  int32x2_t v18;
  int32x2_t v19;

  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  v8 = vadd_f32((float32x2_t)vzip1_s32(v6, v7), (float32x2_t)vzip2_s32(v6, v7));
  v9 = vminnm_f32(vsub_f32(v8, vrndm_f32(v8)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  __asm { FMOV            V1.2S, #1.0 }
  v15 = (int32x2_t)vminnm_f32(v9, vsub_f32(_D1, v9));
  v16 = (int32x2_t)vsub_f32((float32x2_t)vdup_lane_s32(v15, 1), (float32x2_t)v15);
  _NF = *(float *)v16.i32 < 0.0;
  v16.i32[0] = 0;
  if (_NF)
    *(float *)v16.i32 = 1.0;
  v17 = vmla_n_f32(vmul_f32((float32x2_t)vrev64_s32(v15), vsub_f32(_D1, (float32x2_t)vdup_lane_s32(v16, 0))), (float32x2_t)v15, *(float *)v16.i32);
  v18 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v17);
  v19 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v17);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v18, v19), (float32x2_t)vzip2_s32(v18, v19)));
}

float32x2_t cikernel::_fourfoldReflectedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v15;
  float32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;

  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  v8 = vadd_f32((float32x2_t)vzip1_s32(v6, v7), (float32x2_t)vzip2_s32(v6, v7));
  v9 = vminnm_f32(vsub_f32(v8, vrndm_f32(v8)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  __asm { FMOV            V1.2S, #1.0 }
  v15 = vminnm_f32(v9, vsub_f32(_D1, v9));
  v16 = vadd_f32(v15, v15);
  v17 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v16);
  v18 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v16);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v17, v18), (float32x2_t)vzip2_s32(v17, v18)));
}

float32x2_t cikernel::_sixfoldReflectedTile(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  int32x2_t v8;
  float32x2_t v9;
  int32x2_t v10;
  float32x2_t v16;
  float v17;
  float v18;
  int32x2_t v19;
  float v20;
  float32x2_t v21;
  int32x2_t v22;
  int32x2_t v23;

  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v7 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  v8 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  v9 = vadd_f32((float32x2_t)vzip1_s32(v7, v8), (float32x2_t)vzip2_s32(v7, v8));
  v10 = (int32x2_t)vminnm_f32(vsub_f32(v9, vrndm_f32(v9)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  if (vsub_f32((float32x2_t)v10, (float32x2_t)vdup_lane_s32(v10, 1)).f32[0] >= 0.0)
    *(float *)v6.i32 = 0.0;
  else
    *(float *)v6.i32 = 1.0;
  __asm { FMOV            V6.2S, #1.0 }
  v16 = vmla_n_f32(vmul_f32((float32x2_t)vrev64_s32(v10), vsub_f32(_D6, (float32x2_t)vdup_lane_s32(v6, 0))), (float32x2_t)v10, *(float *)v6.i32);
  v17 = v16.f32[1];
  v18 = vaddv_f32(v16);
  if ((float)((float)(2.0 - v18) - v16.f32[1]) < 0.0)
    v17 = 2.0 - v18;
  *(float *)v19.i32 = 1.0 - v18;
  v20 = v16.f32[0] - *(float *)v19.i32;
  if (v20 >= 0.0)
    *(float *)v19.i32 = v16.f32[0];
  *(float *)&v19.i32[1] = v17;
  if ((float)(*(float *)v19.i32 - v17) >= 0.0)
    *(float *)v10.i32 = 0.0;
  else
    *(float *)v10.i32 = 1.0;
  v21 = vmla_n_f32(vmul_f32((float32x2_t)vrev64_s32(v19), vsub_f32(_D6, (float32x2_t)vdup_lane_s32(v10, 0))), (float32x2_t)v19, *(float *)v10.i32);
  v22 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v21);
  v23 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v21);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v22, v23), (float32x2_t)vzip2_s32(v22, v23)));
}

CFTypeRef CI::RenderDestination::setColorspace(CI::RenderDestination *this, CFTypeRef cf)
{
  CFTypeRef result;

  if (cf)
    CFRetain(cf);
  result = (CFTypeRef)*((_QWORD *)this + 3);
  if (result)
    result = CFAutorelease(result);
  *((_QWORD *)this + 3) = cf;
  return result;
}

void sub_19236AF68(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10F1C40D5E332FALL);
  _Unwind_Resume(a1);
}

void sub_19236B434(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40E019140BLL);
  _Unwind_Resume(a1);
}

BOOL checkFormat(int a1)
{
  unsigned int v6;
  unint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v11;

  if (a1 == 274 || a1 == 530 || a1 == 1298 || a1 == 1554 || a1 == 786 || a1 == 1042)
    return 1;
  HIDWORD(v7) = a1 - 1810;
  LODWORD(v7) = a1 - 1810;
  v6 = v7 >> 8;
  if (v6 >= 9)
  {
    if (a1 == 2066)
      return 1;
  }
  else
  {
    v8 = 0x1C1u >> v6;
    v9 = 1;
    if ((v8 & 1) != 0 || a1 == 2066)
      return v9;
  }
  HIDWORD(v11) = a1 - 278;
  LODWORD(v11) = a1 - 278;
  v10 = v11 >> 8;
  if (v10 < 0xF && ((0x70FFu >> v10) & 1) != 0)
    return 1;
  v9 = 1;
  if (a1 > 1554)
  {
    if (a1 > 3346)
    {
      if (a1 == 3347 || a1 == 3603 || a1 == 3859)
        return v9;
    }
    else if (a1 == 1555 || a1 == 1811 || a1 == 2067)
    {
      return v9;
    }
  }
  else if (a1 > 786)
  {
    if (a1 == 787 || a1 == 1043 || a1 == 1299)
      return v9;
  }
  else if (a1 == 275 || a1 == 531 || a1 == 535)
  {
    return v9;
  }
  return a1 == 264
      || a1 == 265
      || a1 == 266
      || a1 == 267
      || a1 == 268
      || a1 == 269
      || a1 == 270
      || a1 == 271
      || a1 == 2056
      || a1 == 2060
      || a1 == 2567
      || a1 == 2569
      || a1 == 3079
      || a1 == 3081
      || a1 == 775
      || a1 == 784
      || a1 == 785
      || a1 == 1800
      || a1 == 1801
      || a1 == 1804
      || a1 == 2312
      || a1 == 2316
      || a1 == 2313
      || a1 == 263
      || a1 == 1799
      || a1 == 2310
      || a1 == 2309
      || a1 == 2308
      || a1 == 2307
      || a1 == 262
      || a1 == 774
      || a1 == 3334
      || a1 == 1798
      || a1 == 2054
      || a1 == 260
      || a1 == 1796
      || a1 == 261
      || a1 == 773
      || a1 == 3333
      || a1 == 1797
      || a1 == 2053
      || a1 == 259
      || a1 == 771
      || a1 == 3331
      || a1 == 1795
      || a1 == 2051;
}

void sub_19236BD78(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40E019140BLL);
  _Unwind_Resume(a1);
}

void sub_19236C120(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E3C408FEBF924);
  _Unwind_Resume(a1);
}

CGColorSpaceRef default_colorspace_for_format(int a1, int a2)
{
  CFStringRef *v4;
  int is_float;

  if (CI::format_is_rgb(a1))
  {
    if (CI::format_is_float(a1) | a2)
      v4 = (CFStringRef *)MEMORY[0x1E0C9D958];
    else
      v4 = (CFStringRef *)MEMORY[0x1E0C9DA10];
    return CGColorSpaceCreateWithName(*v4);
  }
  if (CI::format_is_luminance(a1))
  {
    is_float = CI::format_is_float(a1);
    v4 = (CFStringRef *)MEMORY[0x1E0C9D978];
    if (is_float)
      v4 = (CFStringRef *)MEMORY[0x1E0C9D948];
    return CGColorSpaceCreateWithName(*v4);
  }
  return 0;
}

void sub_19236C34C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C4067939989);
  _Unwind_Resume(a1);
}

void sub_19236C4B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E3C400736B9BCLL);
  _Unwind_Resume(a1);
}

void sub_19236C7AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C4095EC1125);
  _Unwind_Resume(a1);
}

CFTypeRef CI::RenderDestination::setLabel(CI::RenderDestination *this, CFTypeRef cf)
{
  CFTypeRef result;

  if (cf)
    CFRetain(cf);
  result = (CFTypeRef)*((_QWORD *)this + 2);
  if (result)
    result = CFAutorelease(result);
  *((_QWORD *)this + 2) = cf;
  return result;
}

const void *CI::RenderToMTLTextureProvider::texture(CI::RenderToMTLTextureProvider *this)
{
  const void *result;

  result = (const void *)*((_QWORD *)this + 10);
  if (!result)
  {
    result = (const void *)(*(uint64_t (**)(void))(*((_QWORD *)this + 9) + 16))();
    *((_QWORD *)this + 10) = result;
    if (result)
    {
      CFRetain(result);
      return (const void *)*((_QWORD *)this + 10);
    }
  }
  return result;
}

void sub_19236E24C(_Unwind_Exception *a1)
{
  CI::Object *v1;

  CI::Object::unref(v1);
  _Unwind_Resume(a1);
}

double cikernel::_destDither(float32x4_t a1, int32x4_t a2, float a3)
{
  double v3;
  float32x4_t v4;
  float32x4_t v5;
  double result;

  v3 = vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32(a2, 2), vaddq_f32((float32x4_t)a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 1)))).f32[0]* 0.25+ -0.5;
  *(float *)&v3 = v3;
  *(float *)&v3 = *(float *)&v3 * a3;
  v4 = vaddq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v3, 0));
  v4.i32[3] = 0;
  v5 = vmaxnmq_f32(v4, (float32x4_t)0);
  v5.i32[3] = 0;
  *(_QWORD *)&result = vminnmq_f32(v5, (float32x4_t)xmmword_192491FD0).u64[0];
  return result;
}

double cikernel::_rippleTransition(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t a4, float32x4_t a5, float32x2_t a6)
{
  float32x2_t *DC;
  float32x2_t v12;
  int32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x4_t v16;
  int32x4_t v17;
  float32x4_t v23;
  int8x16_t v25;
  int8x16_t v26;
  float32x2_t v27;
  float64x2_t v28;
  double v29;
  float32x4_t v30;
  double v31;
  int8x16_t v32;
  double v33;
  float64x2_t v34;
  double v35;
  int8x16_t v36;
  float32x4_t v37;
  double v38;
  int8x16_t v39;
  double v40;
  float64x2_t v41;
  double v42;
  int8x16_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  double result;
  float32x2_t v48;
  float32x4_t v49;
  float32x2_t v50;
  float32x4_t v52;
  float32x4_t v53;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v12 = vsub_f32(*DC, a4);
  v13 = (int32x2_t)vmul_f32(v12, v12);
  *(float *)v13.i32 = sqrtf(vaddv_f32((float32x2_t)v13));
  v14 = (float32x2_t)vdup_lane_s32(v13, 0);
  *(float *)v13.i32 = vmuls_lane_f32(vmuls_lane_f32(*(float *)v13.i32 - a5.f32[0], *(float32x2_t *)a5.f32, 1), a5, 2);
  v15 = vdiv_f32(v12, v14);
  v16 = vaddq_f32((float32x4_t)vdupq_lane_s32(v13, 0), (float32x4_t)xmmword_192497B10);
  v17 = vcltzq_f32(v16);
  v16.i32[3] = v16.i32[1];
  __asm { FMOV            V5.4S, #1.0 }
  v23 = vminnmq_f32(vmaxnmq_f32(vminnmq_f32(vmaxnmq_f32(v16, (float32x4_t)0), _Q5), (float32x4_t)0), _Q5);
  _Q5.i64[0] = 0xC0000000C0000000;
  _Q5.i64[1] = 0xC0000000C0000000;
  __asm { FMOV            V6.4S, #3.0 }
  v53 = vaddq_f32(vmulq_f32(vmulq_f32(vmulq_f32(v23, v23), vmlaq_f32(_Q6, _Q5, v23)), (float32x4_t)xmmword_192497B20), (float32x4_t)xmmword_192497B30);
  *(int16x4_t *)v23.f32 = vmovn_s32(v17);
  v25 = (int8x16_t)vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v23.f32, 1)), 0x1FuLL));
  _Q5.i64[0] = vdupq_laneq_s32((int32x4_t)v53, 2).u64[0];
  _Q6.i64[0] = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v23.f32, 2)), 0x1FuLL)).u64[0];
  *(int32x2_t *)v26.i8 = vdup_lane_s32(*(int32x2_t *)v53.f32, 1);
  *(int8x8_t *)v17.i8 = vbsl_s8(*(int8x8_t *)_Q6.f32, vbsl_s8(*(int8x8_t *)v25.i8, vand_s8((int8x8_t)vdup_lane_s32(*(int32x2_t *)v53.f32, 0), (int8x8_t)*(_OWORD *)&vcgezq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v23.f32, 0)), 0x1FuLL))), *(int8x8_t *)v26.i8), *(int8x8_t *)_Q5.f32);
  v27 = vmul_f32(v15, (float32x2_t)vand_s8(*(int8x8_t *)v17.i8, (int8x8_t)*(_OWORD *)&vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_lane_s16(*(int16x4_t *)v23.f32, 3)), 0x1FuLL))));
  *(float32x2_t *)v23.f32 = vmul_laneq_f32(v27, a5, 3);
  *(float32x2_t *)v25.i8 = vadd_f32(*DC, *(float32x2_t *)v23.f32);
  *(float32x2_t *)&v28.f64[0] = vmul_f32(v27, (float32x2_t)0x3F0000003F000000);
  v48 = *(float32x2_t *)v25.i8;
  v50 = vmul_f32(a6, vadd_f32(*(float32x2_t *)&v28.f64[0], (float32x2_t)0x3F0000003F000000));
  v23.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)&v29 = *(float *)(a1 + 24)
                 + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v25.i8, 1), *(float *)(a1 + 16), *(float *)v25.i32);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v28.f64 = *(float *)v17.i32
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v25.i8, 1), v23.f32[0], *(float *)v25.i32);
  HIDWORD(v29) = LODWORD(v28.f64[0]);
  *(double *)v30.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v29, v28, *(double *)v23.i64, *(double *)v17.i64, v25, *(uint8x8_t *)_Q5.f32, *(double *)_Q6.i64, v26);
  v52 = v30;
  HIDWORD(v31) = v48.i32[1];
  LODWORD(v31) = *(_DWORD *)(a2 + 28);
  v32.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)&v33 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), v48, 1), *(float *)&v31, v48.f32[0]);
  v30.f32[0] = *(float *)(a2 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), v48, 1), *(float *)(a2 + 16), v48.f32[0]);
  *(float *)v34.f64 = *(float *)v32.i32 + *(float *)&v33;
  v30.f32[1] = *(float *)v32.i32 + *(float *)&v33;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v30.i64, v34, v31, v33, v32, (uint8x8_t)v48, v35, v36);
  v49 = v37;
  HIDWORD(v38) = v50.i32[1];
  LODWORD(v38) = *(_DWORD *)(a3 + 28);
  v39.i32[0] = *(_DWORD *)(a3 + 36);
  *(float *)&v40 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 32), v50, 1), *(float *)&v38, v50.f32[0]);
  v37.f32[0] = *(float *)(a3 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a3 + 20), v50, 1), *(float *)(a3 + 16), v50.f32[0]);
  *(float *)v41.f64 = *(float *)v39.i32 + *(float *)&v40;
  v37.f32[1] = *(float *)v39.i32 + *(float *)&v40;
  *(double *)v44.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a3 + 8), *(double *)v37.i64, v41, v38, v40, v39, (uint8x8_t)v50, v42, v43);
  v45 = vmlaq_laneq_f32(vmulq_n_f32(v49, 1.0 - v53.f32[3]), v52, v53, 3);
  v46 = vmulq_laneq_f32(v44, v45, 3);
  *(_QWORD *)&result = vaddq_f32(v46, vmulq_n_f32(v45, 1.0 - v46.f32[3])).u64[0];
  return result;
}

void CI::f4_sr_sr_sr_f2_f4_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, uint64_t, uint64_t, double, __n128, double);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  double *v21;
  __n128 *v22;
  double *v23;
  __int128 v24;
  int v25;
  uint64_t v26;
  int v27;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, uint64_t, uint64_t, double, __n128, double))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_QWORD *)(v10 + 32);
  v14 = *(_QWORD *)(v10 + 56);
  v15 = *(_DWORD *)(v10 + 88);
  v16 = *(_QWORD *)(v10 + 80);
  v17 = *(_DWORD *)(v10 + 112);
  v18 = *(_QWORD *)(v10 + 104);
  v19 = *(_DWORD *)(v10 + 136);
  v20 = *(_QWORD *)(v10 + 128);
  if (*(_BYTE *)(a1 + 64))
  {
    v26 = *(_QWORD *)(v10 + 32);
    v27 = *(_DWORD *)(v10 + 88);
    v25 = *(_DWORD *)(v10 + 136);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 152)), a2);
    v19 = v25;
    v15 = v27;
    v13 = v26;
  }
  v21 = (double *)(a3 + 16 * v20);
  if (v19 != 5)
    v21 = (double *)((char *)a2 + 64 * v20);
  v22 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v22 = (__n128 *)((char *)a2 + 64 * v18);
  v23 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v23 = (double *)((char *)a2 + 64 * v16);
  *(double *)&v24 = v11(a4 + 80 * v12, a4 + 80 * v13, a4 + 80 * v14, *v23, *v22, *v21);
  *(_OWORD *)(a3 + 16 * a7) = v24;
}

void sub_19236F160(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

void sub_19236F330(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40191B4CE2);
  _Unwind_Resume(a1);
}

CI::SRGBImage *CI::SRGBImage::SRGBImage(CI::SRGBImage *this, CI::Image *a2, int a3)
{
  unsigned int v6;

  *((_QWORD *)CI::ImageWithChild::ImageWithChild(this, a2) + 14) = off_1E2EBB880;
  do
    v6 = __ldaxr(&dword_1ECF872F0[12]);
  while (__stlxr(v6 + 1, &dword_1ECF872F0[12]));
  *(_QWORD *)this = &off_1E2EC06E8;
  *((_QWORD *)this + 14) = &unk_1E2EC0840;
  *((_DWORD *)this + 30) = a3;
  *((_QWORD *)this + 10) = CI::SRGBImage::makeDigest(*((_QWORD *)a2 + 10), a3);
  *((_QWORD *)this + 11) = CI::SRGBImage::makeDigest(*((_QWORD *)a2 + 11), a3);
  *((_BYTE *)this + 97) = 0;
  return this;
}

void sub_19236F414(_Unwind_Exception *a1)
{
  CI::ImageWithChild *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int *v5;
  unsigned int v6;

  *((_QWORD *)v1 + 14) = v2;
  v5 = (unsigned int *)(v3 + 56);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 - 1, v5));
  CI::ImageWithChild::~ImageWithChild(v1);
  _Unwind_Resume(a1);
}

unint64_t CI::SRGBImage::makeDigest(uint64_t a1, int a2)
{
  int64x2_t v5[5];
  uint64_t __src;

  XXH64_reset(v5, 0);
  LODWORD(__src) = 14;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  __src = a1;
  XXH64_update((uint64_t)v5, (char *)&__src, 8uLL);
  LODWORD(__src) = a2;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  return XXH64_digest((uint64_t)v5);
}

uint64_t CI::InstanceCounted<(CI::Type)14>::type()
{
  return 14;
}

_QWORD *CI::InstanceCounted<(CI::Type)14>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBB880;
  do
    v1 = __ldaxr(&dword_1ECF872F0[12]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[12]));
  return result;
}

void CI::InstanceCounted<(CI::Type)14>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBB880;
  do
    v1 = __ldaxr(&dword_1ECF872F0[12]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[12]));
  JUMPOUT(0x194025AACLL);
}

void sub_19236F7F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__17(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__17(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

Class ___ZL52getVNGenerateAttentionBasedSaliencyImageRequestClassv_block_invoke(uint64_t a1)
{
  Class result;

  VisionLibrary();
  result = objc_getClass("VNGenerateAttentionBasedSaliencyImageRequest");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL52getVNGenerateAttentionBasedSaliencyImageRequestClassv_block_invoke_cold_1();
  getVNGenerateAttentionBasedSaliencyImageRequestClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32)
                                                                                                + 8)
                                                                                    + 40);
  return result;
}

void VisionLibrary(void)
{
  void *v0;
  __int128 v1;
  uint64_t v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v0 = 0;
  if (!VisionLibraryCore(char **)::frameworkLibrary)
  {
    v1 = xmmword_1E2EC5258;
    v2 = 0;
    VisionLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  if (!VisionLibraryCore(char **)::frameworkLibrary)
    VisionLibrary(&v0);
}

Class ___ZL29getVNImageRequestHandlerClassv_block_invoke_1(uint64_t a1)
{
  Class result;

  VisionLibrary();
  result = objc_getClass("VNImageRequestHandler");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL29getVNImageRequestHandlerClassv_block_invoke_cold_1();
  getVNImageRequestHandlerClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

double cikernel::_sepia(float32x4_t a1, float a2)
{
  float32x4_t v2;
  int32x2_t v3;
  float v4;
  float32x4_t v5;
  float v6;
  double result;

  v2 = vmulq_f32(a1, (float32x4_t)xmmword_192492180);
  v3 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))).u64[0];
  if (vmlas_n_f32(-*(float *)v3.i32, *(float *)v3.i32, *(float *)v3.i32) >= 0.0)
  {
    v5 = (float32x4_t)vdupq_lane_s32(v3, 0);
  }
  else
  {
    v4 = *(float *)v3.i32 / fmaxf(a1.f32[3], 0.0001);
    v5 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_192497BC0, a1, 3), vmulq_n_f32(vaddq_f32(vmulq_n_f32(vaddq_f32(vmulq_n_f32(vaddq_f32(vmulq_n_f32((float32x4_t)xmmword_192497B80, v4), (float32x4_t)xmmword_192497B90), v4), (float32x4_t)xmmword_192497BA0), v4), (float32x4_t)xmmword_192497BB0), *(float *)v3.i32));
    if (a1.f32[3] * 0.085 <= *(float *)v3.i32)
      v6 = v5.f32[3];
    else
      v6 = v5.f32[0];
    v5.f32[0] = v6;
  }
  v5.i32[3] = a1.i32[3];
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - a2), vmulq_f32(v5, (float32x4_t)xmmword_192497BD0), a2).u64[0];
  return result;
}

uint64_t encodePointForKey(void *a1, uint64_t a2, double a3)
{
  objc_msgSend(a1, "encodeDouble:forKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.%@"), a2, CFSTR("suffix")), a3);
  return objc_msgSend(a1, "encodeDouble:forKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.%@"), a2, CFSTR("suffix")), a3);
}

uint64_t encodeRectForKey(void *a1, uint64_t a2, double a3, double a4, double a5, double a6)
{
  objc_msgSend(a1, "encodeDouble:forKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.%@"), a2, CFSTR("suffix")), a3);
  objc_msgSend(a1, "encodeDouble:forKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.%@"), a2, CFSTR("suffix")), a4);
  objc_msgSend(a1, "encodeDouble:forKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.%@"), a2, CFSTR("suffix")), a5);
  return objc_msgSend(a1, "encodeDouble:forKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.%@"), a2, CFSTR("suffix")), a6);
}

double decodePointForKey(void *a1, uint64_t a2)
{
  double v4;
  double v5;

  objc_msgSend(a1, "decodeDoubleForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.%@"), a2, CFSTR("suffix")));
  v5 = v4;
  objc_msgSend(a1, "decodeDoubleForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.%@"), a2, CFSTR("suffix")));
  return v5;
}

double decodeRectForKey(void *a1, uint64_t a2)
{
  double v4;
  double v5;

  objc_msgSend(a1, "decodeDoubleForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.%@"), a2, CFSTR("suffix")));
  v5 = v4;
  objc_msgSend(a1, "decodeDoubleForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.%@"), a2, CFSTR("suffix")));
  objc_msgSend(a1, "decodeDoubleForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.%@"), a2, CFSTR("suffix")));
  objc_msgSend(a1, "decodeDoubleForKey:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.%@"), a2, CFSTR("suffix")));
  return v5;
}

uint64_t valueWithPoint(double a1, double a2)
{
  _QWORD v3[2];

  *(double *)v3 = a1;
  *(double *)&v3[1] = a2;
  return objc_msgSend(MEMORY[0x1E0CB3B18], "valueWithBytes:objCType:", v3, "{CGPoint=dd}");
}

uint64_t valueWithRect(double a1, double a2, double a3, double a4)
{
  _QWORD v5[4];

  *(double *)v5 = a1;
  *(double *)&v5[1] = a2;
  *(double *)&v5[2] = a3;
  *(double *)&v5[3] = a4;
  return objc_msgSend(MEMORY[0x1E0CB3B18], "valueWithBytes:objCType:", v5, "{CGRect={CGPoint=dd}{CGSize=dd}}");
}

double pointFromValue(void *a1)
{
  _QWORD v2[2];

  v2[0] = 0;
  v2[1] = 0;
  objc_msgSend(a1, "getValue:", v2);
  return *(double *)v2;
}

double rectFromValue(void *a1)
{
  _OWORD v2[2];

  memset(v2, 0, sizeof(v2));
  objc_msgSend(a1, "getValue:", v2);
  return *(double *)v2;
}

uint64_t unarchiveObjectOfClass(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(MEMORY[0x1E0CB3710], "unarchivedObjectOfClass:fromData:error:", a1, a2, 0);
}

uint64_t unarchiveObjectOfClassAllowCommon(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v14;
  void *v15;

  v15 = (void *)MEMORY[0x1E0C99E60];
  v14 = objc_opt_self();
  v2 = objc_opt_self();
  v3 = objc_opt_self();
  v4 = objc_opt_self();
  v5 = objc_opt_self();
  v6 = objc_opt_self();
  v7 = objc_opt_self();
  v8 = objc_opt_self();
  v9 = objc_opt_self();
  v10 = objc_opt_self();
  v11 = objc_opt_self();
  return objc_msgSend(MEMORY[0x1E0CB3710], "unarchivedObjectOfClasses:fromData:error:", objc_msgSend(v15, "setWithObjects:", v14, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, objc_opt_self(), a1, 0), a2, 0);
}

uint64_t archivedDataWithRootObject(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0CB36F8], "archivedDataWithRootObject:requiringSecureCoding:error:", a1, 1, 0);
}

double cikernel::_shadedmaterial(uint64_t a1, uint64_t a2, float32_t a3, float32x2_t a4)
{
  float32x2_t v7;
  float32x2_t v8;
  double v9;
  double v10;
  uint8x8_t v11;
  int8x16_t v12;
  float64x2_t v13;
  double v14;
  int8x16_t v15;
  float32x4_t v16;
  double v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  float64x2_t v21;
  double v22;
  int8x16_t v23;
  float32x4_t v24;
  double v25;
  double v26;
  uint8x8_t v27;
  int8x16_t v28;
  float64x2_t v29;
  double v30;
  int8x16_t v31;
  float32x4_t v32;
  double v33;
  double v34;
  uint8x8_t v35;
  int8x16_t v36;
  float64x2_t v37;
  double v38;
  int8x16_t v39;
  float32x4_t v40;
  CI *v41;
  float32x2_t *DC;
  double v43;
  double v44;
  uint8x8_t v45;
  int8x16_t v46;
  double v47;
  float64x2_t v48;
  double v49;
  int8x16_t v50;
  float32x4_t v51;
  int32x4_t v52;
  float32x4_t v53;
  float64x2_t v54;
  float32x2_t v55;
  float32x2_t v56;
  int8x16_t v57;
  uint8x8_t v58;
  double v59;
  int8x16_t v60;
  float32x4_t v61;
  double result;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;

  v7 = *(float32x2_t *)CI::getDC((CI *)a1);
  v8 = vadd_f32(v7, (float32x2_t)0x3F80000000000000);
  *(float *)&v9 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v8, 1), *(float *)(a1 + 16), v8.f32[0]);
  LODWORD(v10) = *(_DWORD *)(a1 + 28);
  v11.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v12.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v8, 1), *(float *)&v10, v8.f32[0]);
  v8.f32[0] = *(float *)(a1 + 24) + *(float *)&v9;
  *(float *)v13.f64 = *(float *)v11.i32 + *(float *)v12.i32;
  v8.f32[1] = *(float *)v11.i32 + *(float *)v12.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v8, v13, v9, v10, v12, v11, v14, v15);
  v67 = v16;
  *(float32x2_t *)v16.f32 = vadd_f32(v7, (float32x2_t)0xBF80000000000000);
  *(float *)&v17 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v16.f32, 1), *(float *)(a1 + 16), v16.f32[0]);
  LODWORD(v18) = *(_DWORD *)(a1 + 28);
  v19.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v16.f32, 1), *(float *)&v18, v16.f32[0]);
  v16.f32[0] = *(float *)(a1 + 24) + *(float *)&v17;
  *(float *)v21.f64 = *(float *)v19.i32 + *(float *)v20.i32;
  v16.f32[1] = *(float *)v19.i32 + *(float *)v20.i32;
  *(double *)v24.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v16.i64, v21, v17, v18, v20, v19, v22, v23);
  v66 = v24;
  *(float32x2_t *)v24.f32 = vadd_f32(v7, (float32x2_t)3212836864);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v24.f32, 1), *(float *)(a1 + 16), v24.f32[0]);
  LODWORD(v26) = *(_DWORD *)(a1 + 28);
  v27.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v24.f32, 1), *(float *)&v26, v24.f32[0]);
  v24.f32[0] = *(float *)(a1 + 24) + *(float *)&v25;
  *(float *)v29.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  v24.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)v32.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v24.i64, v29, v25, v26, v28, v27, v30, v31);
  v65 = v32;
  *(float32x2_t *)v32.f32 = vadd_f32(v7, (float32x2_t)1065353216);
  *(float *)&v33 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v32.f32, 1), *(float *)(a1 + 16), v32.f32[0]);
  LODWORD(v34) = *(_DWORD *)(a1 + 28);
  v35.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v36.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v32.f32, 1), *(float *)&v34, v32.f32[0]);
  v32.f32[0] = *(float *)(a1 + 24) + *(float *)&v33;
  *(float *)v37.f64 = *(float *)v35.i32 + *(float *)v36.i32;
  v32.f32[1] = *(float *)v35.i32 + *(float *)v36.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v32.i64, v37, v33, v34, v36, v35, v38, v39);
  v63 = v40;
  DC = (float32x2_t *)CI::getDC(v41);
  *(float *)&v43 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v44) = *(_DWORD *)(a1 + 28);
  v45.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v46.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v44, COERCE_FLOAT(*DC));
  *(float *)&v47 = *(float *)(a1 + 24) + *(float *)&v43;
  *(float *)v48.f64 = *(float *)v45.i32 + *(float *)v46.i32;
  *((float *)&v47 + 1) = *(float *)v45.i32 + *(float *)v46.i32;
  *(double *)v51.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v47, v48, v43, v44, v46, v45, v49, v50);
  v64 = v51;
  v52 = vzip1q_s32((int32x4_t)vsubq_f32(v65, v63), (int32x4_t)vsubq_f32(v66, v67));
  v53 = (float32x4_t)v52;
  v53.f32[2] = a3;
  v54 = (float64x2_t)vmulq_f32(v53, v53);
  LODWORD(v54.f64[0]) = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v54, 2), vadd_f32(*(float32x2_t *)&v54.f64[0], (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v54.f64[0], 1))).u32[0];
  v55 = vrsqrte_f32((float32x2_t)LODWORD(v54.f64[0]));
  v56 = vmul_f32(v55, v55);
  *(float32x2_t *)&v54.f64[0] = vmul_f32(a4, vadd_f32(vmul_f32(vmul_n_f32(*(float32x2_t *)v52.i8, vmul_f32(v55, vrsqrts_f32((float32x2_t)LODWORD(v54.f64[0]), v56)).f32[0]), (float32x2_t)vdup_n_s32(0x3EFD70A4u)), (float32x2_t)0x3F0000003F000000));
  v56.i32[0] = *(_DWORD *)(a2 + 28);
  *(float *)v52.i32 = *(float *)(a2 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)&v54.f64[0], 1), *(float *)(a2 + 16), *(float *)v54.f64);
  v57.i32[0] = *(_DWORD *)(a2 + 36);
  v55.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)&v54.f64[0], 1), v56.f32[0], *(float *)v54.f64);
  *(float *)v54.f64 = *(float *)v57.i32 + v55.f32[0];
  *(float *)&v52.i32[1] = *(float *)v57.i32 + v55.f32[0];
  *(double *)v61.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v52.i64, v54, *(double *)&v55, *(double *)&v56, v57, v58, v59, v60);
  *(_QWORD *)&result = vmulq_laneq_f32(v61, v64, 3).u64[0];
  return result;
}

void CI::f4_sr_sr_f_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, uint64_t, float, double);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  double *v18;
  __int128 v19;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, uint64_t, float, double))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_QWORD *)(v11 + 32);
  v15 = *(_QWORD *)(v11 + 56);
  v16 = *(_DWORD *)(v11 + 88);
  v17 = *(_QWORD *)(v11 + 80);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 104)), a2);
  v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (double *)((char *)a2 + 64 * v17);
  *(double *)&v19 = v12(a4 + 80 * v13, a4 + 80 * v14, *((float *)a2 + 16 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_shadedmaterial_0(uint64_t a1, uint64_t a2, float32x2_t a3)
{
  float32x2_t *DC;
  double v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  double v11;
  float64x2_t v12;
  double v13;
  int8x16_t v14;
  float32x4_t v15;
  double v16;
  double v17;
  uint8x8_t v18;
  int8x16_t v19;
  float64x2_t v20;
  double v21;
  int8x16_t v22;
  float32x4_t v23;
  double result;
  float32x4_t v25;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *DC, 1), *(float *)(a1 + 16), COERCE_FLOAT(*DC));
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *DC, 1), *(float *)&v8, COERCE_FLOAT(*DC));
  *(float *)&v11 = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v12.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  *((float *)&v11 + 1) = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v15.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v11, v12, v7, v8, v10, v9, v13, v14);
  v25 = v15;
  *(float32x2_t *)v15.f32 = vmul_f32(a3, (float32x2_t)0x3F0000003F000000);
  *(float *)&v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *(float32x2_t *)v15.f32, 1), *(float *)(a2 + 16), v15.f32[0]);
  LODWORD(v17) = *(_DWORD *)(a2 + 28);
  v18.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *(float32x2_t *)v15.f32, 1), *(float *)&v17, v15.f32[0]);
  v15.f32[0] = *(float *)(a2 + 24) + *(float *)&v16;
  *(float *)v20.f64 = *(float *)v18.i32 + *(float *)v19.i32;
  v15.f32[1] = *(float *)v18.i32 + *(float *)v19.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), *(double *)v15.i64, v20, v16, v17, v19, v18, v21, v22);
  *(_QWORD *)&result = vmulq_laneq_f32(v23, v25, 3).u64[0];
  return result;
}

void CI::f4_sr_sr_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, uint64_t, double);
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  double *v17;
  __int128 v18;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, uint64_t, double))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_QWORD *)(v11 + 32);
  v15 = *(_DWORD *)(v11 + 64);
  v16 = *(_QWORD *)(v11 + 56);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 80)), a2);
  v17 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v17 = (double *)((char *)a2 + 64 * v16);
  *(double *)&v18 = v12(a4 + 80 * v13, a4 + 80 * v14, *v17);
  *(_OWORD *)(a3 + 16 * a7) = v18;
}

double cikernel::_noiseReduction(uint64_t a1, double a2, float32x4_t a3, __n128 a4)
{
  int8x16_t v5;
  double v6;
  double v7;
  double v8;
  float64x2_t v9;
  uint8x8_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  float64x2_t v14;
  double v15;
  double v16;
  uint8x8_t v17;
  int8x16_t v18;
  double v19;
  int8x16_t v20;
  float32x4_t v21;
  float64x2_t v22;
  double v23;
  double v24;
  uint8x8_t v25;
  int8x16_t v26;
  double v27;
  int8x16_t v28;
  float32x4_t v29;
  float64x2_t v30;
  double v31;
  double v32;
  uint8x8_t v33;
  int8x16_t v34;
  double v35;
  int8x16_t v36;
  float32x4_t v37;
  float64x2_t v38;
  double v39;
  double v40;
  uint8x8_t v41;
  int8x16_t v42;
  double v43;
  int8x16_t v44;
  float32x4_t v45;
  float64x2_t v46;
  double v47;
  double v48;
  uint8x8_t v49;
  int8x16_t v50;
  int8x16_t v51;
  float32x4_t v52;
  float64x2_t v53;
  double v54;
  double v55;
  uint8x8_t v56;
  int8x16_t v57;
  double v58;
  int8x16_t v59;
  float32x4_t v60;
  float64x2_t v61;
  double v62;
  double v63;
  uint8x8_t v64;
  int8x16_t v65;
  double v66;
  int8x16_t v67;
  float32x4_t v68;
  float64x2_t v69;
  double v70;
  double v71;
  uint8x8_t v72;
  int8x16_t v73;
  double v74;
  int8x16_t v75;
  float32x4_t v76;
  float32x4_t v77;
  float v85;
  float v86;
  double result;
  float32x4_t v88;
  float64x2_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  int32x2_t v99;
  float64x2_t v101;

  v5.i64[0] = *(_QWORD *)CI::getDC((CI *)a1);
  v101 = (float64x2_t)v5;
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  *(float *)&v7 = *(float *)(a1 + 24)
                + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v5.i8, 1), *(float *)(a1 + 16), *(float *)v5.i32);
  LODWORD(v8) = *(_DWORD *)(a1 + 36);
  *(float *)v9.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v5.i8, 1), *(float *)&v6, *(float *)v5.i32);
  HIDWORD(v7) = LODWORD(v9.f64[0]);
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v7, v9, v6, v8, v5, v10, v11, v12);
  v96 = v13;
  v13.i32[0] = 0;
  v13.f32[1] = -*(float *)&a2;
  v14 = v101;
  *(float32x2_t *)v13.f32 = vadd_f32(*(float32x2_t *)v13.f32, *(float32x2_t *)&v101.f64[0]);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v13.f32, 1), *(float *)(a1 + 16), v13.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 28);
  v17.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v18.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v13.f32, 1), *(float *)&v16, v13.f32[0]);
  v13.f32[0] = *(float *)(a1 + 24) + *(float *)&v15;
  *(float *)v14.f64 = *(float *)v17.i32 + *(float *)v18.i32;
  v13.f32[1] = *(float *)v17.i32 + *(float *)v18.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, v14, v15, v16, v18, v17, v19, v20);
  v95 = v21;
  v22 = v101;
  *(float32x2_t *)v21.f32 = vadd_f32((float32x2_t)vzip1_s32(0, *(int32x2_t *)&a2), *(float32x2_t *)&v101.f64[0]);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v21.f32, 1), *(float *)(a1 + 16), v21.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 28);
  v25.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v21.f32, 1), *(float *)&v24, v21.f32[0]);
  v21.f32[0] = *(float *)(a1 + 24) + *(float *)&v23;
  *(float *)v22.f64 = *(float *)v25.i32 + *(float *)v26.i32;
  v21.f32[1] = *(float *)v25.i32 + *(float *)v26.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v22, v23, v24, v26, v25, v27, v28);
  v94 = v29;
  *(_QWORD *)&v30.f64[0] = COERCE_UNSIGNED_INT(-*(float *)&a2);
  *(float32x2_t *)v29.f32 = vadd_f32(*(float32x2_t *)&v30.f64[0], *(float32x2_t *)&v101.f64[0]);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v29.f32, 1), *(float *)(a1 + 16), v29.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 28);
  v33.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v34.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v29.f32, 1), *(float *)&v32, v29.f32[0]);
  v29.f32[0] = *(float *)(a1 + 24) + *(float *)&v31;
  *(float *)v30.f64 = *(float *)v33.i32 + *(float *)v34.i32;
  v29.f32[1] = *(float *)v33.i32 + *(float *)v34.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v30, v31, v32, v34, v33, v35, v36);
  v93 = v37;
  v38 = v101;
  *(float32x2_t *)v37.f32 = vadd_f32((float32x2_t)LODWORD(a2), *(float32x2_t *)&v101.f64[0]);
  *(float *)&v39 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v37.f32, 1), *(float *)(a1 + 16), v37.f32[0]);
  LODWORD(v40) = *(_DWORD *)(a1 + 28);
  v41.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v42.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v37.f32, 1), *(float *)&v40, v37.f32[0]);
  v37.f32[0] = *(float *)(a1 + 24) + *(float *)&v39;
  *(float *)v38.f64 = *(float *)v41.i32 + *(float *)v42.i32;
  v37.f32[1] = *(float *)v41.i32 + *(float *)v42.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v37.i64, v38, v39, v40, v42, v41, v43, v44);
  v92 = v45;
  *(int32x2_t *)&v46.f64[0] = vdup_lane_s32(*(int32x2_t *)&a2, 1);
  v89 = v46;
  *(float32x2_t *)v45.f32 = vadd_f32(*(float32x2_t *)&v46.f64[0], *(float32x2_t *)&v101.f64[0]);
  *(float *)&v47 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v45.f32, 1), *(float *)(a1 + 16), v45.f32[0]);
  LODWORD(v48) = *(_DWORD *)(a1 + 28);
  v49.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v50.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v45.f32, 1), *(float *)&v48, v45.f32[0]);
  v45.f32[0] = *(float *)(a1 + 24) + *(float *)&v47;
  *(float *)v46.f64 = *(float *)v49.i32 + *(float *)v50.i32;
  v45.f32[1] = *(float *)v49.i32 + *(float *)v50.i32;
  *(double *)v52.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v46, v47, v48, v50, v49, a2, v51);
  v91 = v52;
  v52.f32[0] = -*((float *)&a2 + 1);
  v99 = *(int32x2_t *)v52.f32;
  v53 = v89;
  *((float *)v53.f64 + 1) = -*((float *)&a2 + 1);
  *(float32x2_t *)v52.f32 = vadd_f32(*(float32x2_t *)&v53.f64[0], *(float32x2_t *)&v101.f64[0]);
  *(float *)&v54 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v52.f32, 1), *(float *)(a1 + 16), v52.f32[0]);
  LODWORD(v55) = *(_DWORD *)(a1 + 28);
  v56.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v52.f32, 1), *(float *)&v55, v52.f32[0]);
  v52.f32[0] = *(float *)(a1 + 24) + *(float *)&v54;
  *(float *)v53.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v52.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v60.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v52.i64, v53, v54, v55, v57, v56, v58, v59);
  v90 = v60;
  v61 = v101;
  *(float32x2_t *)v60.f32 = vadd_f32((float32x2_t)vdup_lane_s32(v99, 0), *(float32x2_t *)&v101.f64[0]);
  *(float *)&v62 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v60.f32, 1), *(float *)(a1 + 16), v60.f32[0]);
  LODWORD(v63) = *(_DWORD *)(a1 + 28);
  v64.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v60.f32, 1), *(float *)&v63, v60.f32[0]);
  v60.f32[0] = *(float *)(a1 + 24) + *(float *)&v62;
  *(float *)v61.f64 = *(float *)v64.i32 + *(float *)v65.i32;
  v60.f32[1] = *(float *)v64.i32 + *(float *)v65.i32;
  *(double *)v68.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v60.i64, v61, v62, v63, v65, v64, v66, v67);
  v88 = v68;
  v69 = v101;
  *(float32x2_t *)v68.f32 = vadd_f32(*(float32x2_t *)&a2, *(float32x2_t *)&v101.f64[0]);
  *(float *)&v70 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v68.f32, 1), *(float *)(a1 + 16), v68.f32[0]);
  LODWORD(v71) = *(_DWORD *)(a1 + 28);
  v72.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v73.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v68.f32, 1), *(float *)&v71, v68.f32[0]);
  v68.f32[0] = *(float *)(a1 + 24) + *(float *)&v70;
  *(float *)v69.f64 = *(float *)v72.i32 + *(float *)v73.i32;
  v68.f32[1] = *(float *)v72.i32 + *(float *)v73.i32;
  *(double *)v76.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v68.i64, v69, v70, v71, v73, v72, v74, v75);
  v77 = vaddq_f32(vmulq_laneq_f32(v96, a3, 2), vaddq_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vaddq_f32(v95, v94), v93), v92), a3.f32[0]), vmulq_lane_f32(vaddq_f32(vaddq_f32(vaddq_f32(v91, v90), v88), v76), *(float32x2_t *)a3.f32, 1)));
  _Q0 = vabdq_f32(v77, v96);
  _Q0.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)_Q0, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q0.f32, 1), _Q0)).u32[0];
  _V3.S[1] = a4.n128_u32[1];
  __asm { FMLA            S2, S0, V3.S[1] }
  if (_S2 <= 1.0)
    v85 = _S2;
  else
    v85 = 1.0;
  if (_S2 >= a4.n128_f32[2])
    v86 = v85;
  else
    v86 = a4.n128_f32[2];
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v96, 1.0 - v86), v77, v86).u64[0];
  return result;
}

double cikernel::_convertRGBtoY(float32x4_t a1, double a2)
{
  float32x4_t v2;
  double result;

  *(float *)&a2 = fmaxf(a1.f32[3], 0.00001);
  v2 = vmulq_f32(vdivq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0)), (float32x4_t)xmmword_1924921A0);
  v2.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))).u64[0];
  v2.f32[0] = sqrtf(fmaxf(v2.f32[0], 0.0));
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)v2.f32, 0).u64[0];
  return result;
}

double cikernel::_blur1(cikernel *this, SamplerObj *a2)
{
  float64x2_t v3;
  float32x2_t v4;
  double v5;
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  double v9;
  int8x16_t v10;
  float32x4_t v11;
  float64x2_t v12;
  double v13;
  double v14;
  uint8x8_t v15;
  int8x16_t v16;
  double v17;
  int8x16_t v18;
  float64x2_t v24;
  double v25;
  double v26;
  uint8x8_t v27;
  int8x16_t v28;
  double v29;
  int8x16_t v30;
  float32x4_t v31;
  double v32;
  float32x2_t v33;
  double v34;
  int8x16_t v35;
  double v36;
  uint8x8_t v37;
  float64x2_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float64x2_t v41;
  double v42;
  double v43;
  uint8x8_t v44;
  double v45;
  int8x16_t v46;
  double v47;
  float64x2_t v48;
  float32x2_t v49;
  double v50;
  double v51;
  uint8x8_t v52;
  int8x16_t v53;
  double v54;
  int8x16_t v55;
  float32x4_t v56;
  double v58;
  float32x2_t v59;
  double v60;
  int8x16_t v61;
  double v62;
  uint8x8_t v63;
  float64x2_t v64;
  int8x16_t v65;
  float32x4_t v66;
  double v67;
  float32x2_t v68;
  double v69;
  int8x16_t v70;
  double v71;
  uint8x8_t v72;
  float64x2_t v73;
  int8x16_t v74;
  float32x4_t v75;
  double v76;
  float32x2_t v77;
  double v78;
  int8x16_t v79;
  double v80;
  uint8x8_t v81;
  float64x2_t v82;
  int8x16_t v83;
  float32x4_t v84;
  unsigned int v85;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  int8x16_t v93;

  v3.f64[0] = *(float64_t *)CI::getDC(this);
  v93 = (int8x16_t)v3;
  v4 = vadd_f32(*(float32x2_t *)&v3.f64[0], (float32x2_t)0x3F800000BF800000);
  *(float *)&v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v3.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v3, v5, v6, v8, v7, v9, v10);
  v92 = v11;
  v12 = (float64x2_t)v93;
  *(float32x2_t *)v11.f32 = vadd_f32(*(float32x2_t *)v93.i8, (float32x2_t)0x3F80000000000000);
  *(float *)&v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v11.f32, 1), *((float *)this + 4), v11.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v11.f32, 1), *(float *)&v14, v11.f32[0]);
  v11.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v12.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v11.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v11.i64, v12, v13, v14, v16, v15, v17, v18);
  v87 = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  v24 = (float64x2_t)v93;
  *(float32x2_t *)_Q0.f32 = vadd_f32(*(float32x2_t *)v93.i8, *(float32x2_t *)_Q0.f32);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v26) = *((_DWORD *)this + 7);
  v27.i32[0] = *((_DWORD *)this + 9);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v26, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v25;
  *(float *)v24.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  _Q0.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v24, v25, v26, v28, v27, v29, v30);
  HIDWORD(v32) = v93.i32[1];
  v33 = vadd_f32(*(float32x2_t *)v93.i8, (float32x2_t)3212836864);
  *(float *)&v34 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v33, 1), *((float *)this + 4), v33.f32[0]);
  LODWORD(v32) = *((_DWORD *)this + 6);
  v35.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v36) = *((_DWORD *)this + 9);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v33, 1), *(float *)v35.i32, v33.f32[0]);
  v38 = (float64x2_t)v92;
  v90 = vaddq_f32(v92, v31);
  v31.f32[0] = *(float *)&v32 + *(float *)&v34;
  *(float *)v38.f64 = *(float *)&v36 + *(float *)v37.i32;
  v31.f32[1] = *(float *)&v36 + *(float *)v37.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v31.i64, v38, v32, v34, v35, v37, v36, v39);
  v41 = (float64x2_t)v87;
  v88 = vaddq_f32(v87, v40);
  LODWORD(v42) = *((_DWORD *)this + 7);
  v40.f32[0] = *((float *)this + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v93.i8, 1), *((float *)this + 4), *(float *)v93.i32);
  LODWORD(v43) = *((_DWORD *)this + 9);
  *(float *)v41.f64 = *(float *)&v43
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v93.i8, 1), *(float *)&v42, *(float *)v93.i32);
  v40.i32[1] = LODWORD(v41.f64[0]);
  v47 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v40.i64, v41, v42, v43, v93, v44, v45, v46);
  v92.i32[0] = LODWORD(v47);
  v48 = (float64x2_t)v93;
  v49 = vadd_f32(*(float32x2_t *)v93.i8, (float32x2_t)1065353216);
  *(float *)&v50 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v49, 1), *((float *)this + 4), v49.f32[0]);
  LODWORD(v51) = *((_DWORD *)this + 7);
  v52.i32[0] = *((_DWORD *)this + 9);
  *(float *)v53.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v49, 1), *(float *)&v51, v49.f32[0]);
  v49.f32[0] = *((float *)this + 6) + *(float *)&v50;
  *(float *)v48.f64 = *(float *)v52.i32 + *(float *)v53.i32;
  v49.f32[1] = *(float *)v52.i32 + *(float *)v53.i32;
  *(double *)v56.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v49, v48, v50, v51, v53, v52, v54, v55);
  __asm { FMOV            V1.2S, #-1.0 }
  HIDWORD(v58) = v93.i32[1];
  v59 = vadd_f32(*(float32x2_t *)v93.i8, _D1);
  *(float *)&v60 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v59, 1), *((float *)this + 4), v59.f32[0]);
  LODWORD(v58) = *((_DWORD *)this + 6);
  v61.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v62) = *((_DWORD *)this + 9);
  *(float *)v63.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v59, 1), *(float *)v61.i32, v59.f32[0]);
  v64 = (float64x2_t)v88;
  v89 = vaddq_f32(v88, v56);
  v56.f32[0] = *(float *)&v58 + *(float *)&v60;
  *(float *)v64.f64 = *(float *)&v62 + *(float *)v63.i32;
  v56.f32[1] = *(float *)&v62 + *(float *)v63.i32;
  *(double *)v66.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v56.i64, v64, v58, v60, v61, v63, v62, v65);
  HIDWORD(v67) = v93.i32[1];
  v68 = vadd_f32(*(float32x2_t *)v93.i8, (float32x2_t)0xBF80000000000000);
  *(float *)&v69 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v68, 1), *((float *)this + 4), v68.f32[0]);
  LODWORD(v67) = *((_DWORD *)this + 6);
  v70.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v71) = *((_DWORD *)this + 9);
  *(float *)v72.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v68, 1), *(float *)v70.i32, v68.f32[0]);
  v73 = (float64x2_t)v90;
  v91 = vaddq_f32(v90, v66);
  v66.f32[0] = *(float *)&v67 + *(float *)&v69;
  *(float *)v73.f64 = *(float *)&v71 + *(float *)v72.i32;
  v66.f32[1] = *(float *)&v71 + *(float *)v72.i32;
  *(double *)v75.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v66.i64, v73, v67, v69, v70, v72, v71, v74);
  HIDWORD(v76) = v93.i32[1];
  v77 = vadd_f32(*(float32x2_t *)v93.i8, (float32x2_t)0xBF8000003F800000);
  *(float *)&v78 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v77, 1), *((float *)this + 4), v77.f32[0]);
  LODWORD(v76) = *((_DWORD *)this + 6);
  v79.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v80) = *((_DWORD *)this + 9);
  *(float *)v81.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v77, 1), *(float *)v79.i32, v77.f32[0]);
  v82 = (float64x2_t)v89;
  *(float *)v93.i32 = vaddq_f32(v89, v75).f32[0];
  v75.f32[0] = *(float *)&v76 + *(float *)&v78;
  *(float *)v82.f64 = *(float *)&v80 + *(float *)v81.i32;
  v75.f32[1] = *(float *)&v80 + *(float *)v81.i32;
  *(double *)v84.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v75.i64, v82, v76, v78, v79, v81, v80, v83);
  *(float *)&v85 = *(float *)v93.i32 * 0.125 + v92.f32[0] * 0.25 + vaddq_f32(v91, v84).f32[0] * 0.0625;
  return COERCE_DOUBLE(__PAIR64__(v85, v92.u32[0]));
}

__n128 cikernel::_blur2(cikernel *this, SamplerObj *a2)
{
  float64x2_t v3;
  float32x2_t v4;
  double v5;
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  double v9;
  int8x16_t v10;
  float32x4_t v11;
  float64x2_t v12;
  double v13;
  double v14;
  uint8x8_t v15;
  int8x16_t v16;
  double v17;
  int8x16_t v18;
  float32x4_t v19;
  float64x2_t v20;
  double v21;
  double v22;
  uint8x8_t v23;
  int8x16_t v24;
  double v25;
  int8x16_t v26;
  float32x4_t v27;
  double v28;
  float32x2_t v29;
  double v30;
  int8x16_t v31;
  double v32;
  uint8x8_t v33;
  float64x2_t v34;
  int8x16_t v35;
  float32x4_t v36;
  float64x2_t v37;
  double v38;
  double v39;
  uint8x8_t v40;
  double v41;
  int8x16_t v42;
  __int128 v43;
  float64x2_t v44;
  double v45;
  double v46;
  uint8x8_t v47;
  int8x16_t v48;
  double v49;
  int8x16_t v50;
  float32x4_t v51;
  double v52;
  float32x2_t v53;
  double v54;
  int8x16_t v55;
  double v56;
  uint8x8_t v57;
  float64x2_t v58;
  int8x16_t v59;
  double v60;
  float32x2_t v61;
  double v62;
  int8x16_t v63;
  double v64;
  uint8x8_t v65;
  float64x2_t v66;
  double v67;
  int8x16_t v68;
  double v69;
  float32x2_t v70;
  double v71;
  int8x16_t v72;
  double v73;
  uint8x8_t v74;
  float64x2_t v75;
  double v76;
  int8x16_t v77;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float32x4_t v82;
  float32x4_t v83;
  __int128 v84;
  int8x16_t v85;

  v3.f64[0] = *(float64_t *)CI::getDC(this);
  v85 = (int8x16_t)v3;
  v4 = vadd_f32(*(float32x2_t *)&v3.f64[0], (float32x2_t)0x40000000C0000000);
  *(float *)&v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v3.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v3, v5, v6, v8, v7, v9, v10);
  v83 = v11;
  v12 = (float64x2_t)v85;
  *(float32x2_t *)v11.f32 = vadd_f32(*(float32x2_t *)v85.i8, (float32x2_t)0x4000000000000000);
  *(float *)&v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v11.f32, 1), *((float *)this + 4), v11.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v11.f32, 1), *(float *)&v14, v11.f32[0]);
  v11.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v12.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v11.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v19.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v11.i64, v12, v13, v14, v16, v15, v17, v18);
  v79 = v19;
  v20 = (float64x2_t)v85;
  *(float32x2_t *)v19.f32 = vadd_f32(*(float32x2_t *)v85.i8, (float32x2_t)0x4000000040000000);
  *(float *)&v21 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v19.f32, 1), *((float *)this + 4), v19.f32[0]);
  LODWORD(v22) = *((_DWORD *)this + 7);
  v23.i32[0] = *((_DWORD *)this + 9);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v19.f32, 1), *(float *)&v22, v19.f32[0]);
  v19.f32[0] = *((float *)this + 6) + *(float *)&v21;
  *(float *)v20.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v19.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v27.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v19.i64, v20, v21, v22, v24, v23, v25, v26);
  HIDWORD(v28) = v85.i32[1];
  v29 = vadd_f32(*(float32x2_t *)v85.i8, (float32x2_t)3221225472);
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v29, 1), *((float *)this + 4), v29.f32[0]);
  LODWORD(v28) = *((_DWORD *)this + 6);
  v31.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v32) = *((_DWORD *)this + 9);
  *(float *)v33.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v29, 1), *(float *)v31.i32, v29.f32[0]);
  v34 = (float64x2_t)v83;
  v82 = vaddq_f32(v83, v27);
  v27.f32[0] = *(float *)&v28 + *(float *)&v30;
  *(float *)v34.f64 = *(float *)&v32 + *(float *)v33.i32;
  v27.f32[1] = *(float *)&v32 + *(float *)v33.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v27.i64, v34, v28, v30, v31, v33, v32, v35);
  v37 = (float64x2_t)v79;
  v80 = vaddq_f32(v79, v36);
  LODWORD(v38) = *((_DWORD *)this + 7);
  v36.f32[0] = *((float *)this + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v85.i8, 1), *((float *)this + 4), *(float *)v85.i32);
  LODWORD(v39) = *((_DWORD *)this + 9);
  *(float *)v37.f64 = *(float *)&v39
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v85.i8, 1), *(float *)&v38, *(float *)v85.i32);
  v36.i32[1] = LODWORD(v37.f64[0]);
  *(double *)&v43 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v36.i64, v37, v38, v39, v85, v40, v41, v42);
  v84 = v43;
  v44 = (float64x2_t)v85;
  *(float32x2_t *)&v43 = vadd_f32(*(float32x2_t *)v85.i8, (float32x2_t)0x40000000);
  *(float *)&v45 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v43, 1), *((float *)this + 4), *(float *)&v43);
  LODWORD(v46) = *((_DWORD *)this + 7);
  v47.i32[0] = *((_DWORD *)this + 9);
  *(float *)v48.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v43, 1), *(float *)&v46, *(float *)&v43);
  *(float *)&v43 = *((float *)this + 6) + *(float *)&v45;
  *(float *)v44.f64 = *(float *)v47.i32 + *(float *)v48.i32;
  *((float *)&v43 + 1) = *(float *)v47.i32 + *(float *)v48.i32;
  *(double *)v51.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v43, v44, v45, v46, v48, v47, v49, v50);
  HIDWORD(v52) = v85.i32[1];
  v53 = vadd_f32(*(float32x2_t *)v85.i8, (float32x2_t)0xC0000000C0000000);
  *(float *)&v54 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v53, 1), *((float *)this + 4), v53.f32[0]);
  LODWORD(v52) = *((_DWORD *)this + 6);
  v55.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v56) = *((_DWORD *)this + 9);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v53, 1), *(float *)v55.i32, v53.f32[0]);
  v58 = (float64x2_t)v80;
  v81 = vaddq_f32(v80, v51);
  v51.f32[0] = *(float *)&v52 + *(float *)&v54;
  *(float *)v58.f64 = *(float *)&v56 + *(float *)v57.i32;
  v51.f32[1] = *(float *)&v56 + *(float *)v57.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v51.i64, v58, v52, v54, v55, v57, v56, v59);
  HIDWORD(v60) = v85.i32[1];
  v61 = vadd_f32(*(float32x2_t *)v85.i8, (float32x2_t)0xC000000000000000);
  *(float *)&v62 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v61, 1), *((float *)this + 4), v61.f32[0]);
  LODWORD(v60) = *((_DWORD *)this + 6);
  v63.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v64) = *((_DWORD *)this + 9);
  *(float *)v65.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v61, 1), *(float *)v63.i32, v61.f32[0]);
  v66 = (float64x2_t)v82;
  *(float *)&v67 = *(float *)&v60 + *(float *)&v62;
  *(float *)v66.f64 = *(float *)&v64 + *(float *)v65.i32;
  *((float *)&v67 + 1) = *(float *)&v64 + *(float *)v65.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v67, v66, v60, v62, v63, v65, v64, v68);
  HIDWORD(v69) = v85.i32[1];
  v70 = vadd_f32(*(float32x2_t *)v85.i8, (float32x2_t)0xC000000040000000);
  *(float *)&v71 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v70, 1), *((float *)this + 4), v70.f32[0]);
  LODWORD(v69) = *((_DWORD *)this + 6);
  v72.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v73) = *((_DWORD *)this + 9);
  *(float *)v74.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v70, 1), *(float *)v72.i32, v70.f32[0]);
  v75 = (float64x2_t)v81;
  *(float *)&v76 = *(float *)&v69 + *(float *)&v71;
  *(float *)v75.f64 = *(float *)&v73 + *(float *)v74.i32;
  *((float *)&v76 + 1) = *(float *)&v73 + *(float *)v74.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v76, v75, v69, v71, v72, v74, v73, v77);
  return (__n128)v84;
}

__n128 cikernel::_blur4(cikernel *this, SamplerObj *a2)
{
  float64x2_t v3;
  float32x2_t v4;
  double v5;
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  double v9;
  int8x16_t v10;
  float32x4_t v11;
  float64x2_t v12;
  double v13;
  double v14;
  uint8x8_t v15;
  int8x16_t v16;
  double v17;
  int8x16_t v18;
  float64x2_t v24;
  double v25;
  double v26;
  uint8x8_t v27;
  int8x16_t v28;
  double v29;
  int8x16_t v30;
  float32x4_t v31;
  double v32;
  float32x2_t v33;
  double v34;
  int8x16_t v35;
  double v36;
  uint8x8_t v37;
  float64x2_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float64x2_t v41;
  double v42;
  double v43;
  uint8x8_t v44;
  double v45;
  int8x16_t v46;
  __int128 v47;
  float64x2_t v48;
  double v49;
  double v50;
  uint8x8_t v51;
  int8x16_t v52;
  double v53;
  int8x16_t v54;
  float32x4_t v55;
  double v57;
  float32x2_t v58;
  double v59;
  int8x16_t v60;
  double v61;
  uint8x8_t v62;
  float64x2_t v63;
  int8x16_t v64;
  double v65;
  float32x2_t v66;
  double v67;
  int8x16_t v68;
  double v69;
  uint8x8_t v70;
  float64x2_t v71;
  double v72;
  int8x16_t v73;
  double v74;
  float32x2_t v75;
  double v76;
  int8x16_t v77;
  double v78;
  uint8x8_t v79;
  float64x2_t v80;
  double v81;
  int8x16_t v82;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  float32x4_t v88;
  __int128 v89;
  int8x16_t v90;

  v3.f64[0] = *(float64_t *)CI::getDC(this);
  v90 = (int8x16_t)v3;
  v4 = vadd_f32(*(float32x2_t *)&v3.f64[0], (float32x2_t)0x40800000C0800000);
  *(float *)&v5 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v4, 1), *((float *)this + 4), v4.f32[0]);
  LODWORD(v6) = *((_DWORD *)this + 7);
  v7.i32[0] = *((_DWORD *)this + 9);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *((float *)this + 6) + *(float *)&v5;
  *(float *)v3.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v11.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v4, v3, v5, v6, v8, v7, v9, v10);
  v88 = v11;
  v12 = (float64x2_t)v90;
  *(float32x2_t *)v11.f32 = vadd_f32(*(float32x2_t *)v90.i8, (float32x2_t)0x4080000000000000);
  *(float *)&v13 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v11.f32, 1), *((float *)this + 4), v11.f32[0]);
  LODWORD(v14) = *((_DWORD *)this + 7);
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v11.f32, 1), *(float *)&v14, v11.f32[0]);
  v11.f32[0] = *((float *)this + 6) + *(float *)&v13;
  *(float *)v12.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v11.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v11.i64, v12, v13, v14, v16, v15, v17, v18);
  v84 = _Q0;
  __asm { FMOV            V0.2S, #4.0 }
  v24 = (float64x2_t)v90;
  *(float32x2_t *)_Q0.f32 = vadd_f32(*(float32x2_t *)v90.i8, *(float32x2_t *)_Q0.f32);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v26) = *((_DWORD *)this + 7);
  v27.i32[0] = *((_DWORD *)this + 9);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v26, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v25;
  *(float *)v24.f64 = *(float *)v27.i32 + *(float *)v28.i32;
  _Q0.f32[1] = *(float *)v27.i32 + *(float *)v28.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v24, v25, v26, v28, v27, v29, v30);
  HIDWORD(v32) = v90.i32[1];
  v33 = vadd_f32(*(float32x2_t *)v90.i8, (float32x2_t)3229614080);
  *(float *)&v34 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v33, 1), *((float *)this + 4), v33.f32[0]);
  LODWORD(v32) = *((_DWORD *)this + 6);
  v35.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v36) = *((_DWORD *)this + 9);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v33, 1), *(float *)v35.i32, v33.f32[0]);
  v38 = (float64x2_t)v88;
  v87 = vaddq_f32(v88, v31);
  v31.f32[0] = *(float *)&v32 + *(float *)&v34;
  *(float *)v38.f64 = *(float *)&v36 + *(float *)v37.i32;
  v31.f32[1] = *(float *)&v36 + *(float *)v37.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v31.i64, v38, v32, v34, v35, v37, v36, v39);
  v41 = (float64x2_t)v84;
  v85 = vaddq_f32(v84, v40);
  LODWORD(v42) = *((_DWORD *)this + 7);
  v40.f32[0] = *((float *)this + 6)
             + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v90.i8, 1), *((float *)this + 4), *(float *)v90.i32);
  LODWORD(v43) = *((_DWORD *)this + 9);
  *(float *)v41.f64 = *(float *)&v43
                    + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v90.i8, 1), *(float *)&v42, *(float *)v90.i32);
  v40.i32[1] = LODWORD(v41.f64[0]);
  *(double *)&v47 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v40.i64, v41, v42, v43, v90, v44, v45, v46);
  v89 = v47;
  v48 = (float64x2_t)v90;
  *(float32x2_t *)&v47 = vadd_f32(*(float32x2_t *)v90.i8, (float32x2_t)1082130432);
  *(float *)&v49 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)&v47, 1), *((float *)this + 4), *(float *)&v47);
  LODWORD(v50) = *((_DWORD *)this + 7);
  v51.i32[0] = *((_DWORD *)this + 9);
  *(float *)v52.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)&v47, 1), *(float *)&v50, *(float *)&v47);
  *(float *)&v47 = *((float *)this + 6) + *(float *)&v49;
  *(float *)v48.f64 = *(float *)v51.i32 + *(float *)v52.i32;
  *((float *)&v47 + 1) = *(float *)v51.i32 + *(float *)v52.i32;
  *(double *)v55.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)&v47, v48, v49, v50, v52, v51, v53, v54);
  __asm { FMOV            V1.2S, #-4.0 }
  HIDWORD(v57) = v90.i32[1];
  v58 = vadd_f32(*(float32x2_t *)v90.i8, _D1);
  *(float *)&v59 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v58, 1), *((float *)this + 4), v58.f32[0]);
  LODWORD(v57) = *((_DWORD *)this + 6);
  v60.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v61) = *((_DWORD *)this + 9);
  *(float *)v62.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v58, 1), *(float *)v60.i32, v58.f32[0]);
  v63 = (float64x2_t)v85;
  v86 = vaddq_f32(v85, v55);
  v55.f32[0] = *(float *)&v57 + *(float *)&v59;
  *(float *)v63.f64 = *(float *)&v61 + *(float *)v62.i32;
  v55.f32[1] = *(float *)&v61 + *(float *)v62.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v55.i64, v63, v57, v59, v60, v62, v61, v64);
  HIDWORD(v65) = v90.i32[1];
  v66 = vadd_f32(*(float32x2_t *)v90.i8, (float32x2_t)0xC080000000000000);
  *(float *)&v67 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v66, 1), *((float *)this + 4), v66.f32[0]);
  LODWORD(v65) = *((_DWORD *)this + 6);
  v68.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v69) = *((_DWORD *)this + 9);
  *(float *)v70.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v66, 1), *(float *)v68.i32, v66.f32[0]);
  v71 = (float64x2_t)v87;
  *(float *)&v72 = *(float *)&v65 + *(float *)&v67;
  *(float *)v71.f64 = *(float *)&v69 + *(float *)v70.i32;
  *((float *)&v72 + 1) = *(float *)&v69 + *(float *)v70.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v72, v71, v65, v67, v68, v70, v69, v73);
  HIDWORD(v74) = v90.i32[1];
  v75 = vadd_f32(*(float32x2_t *)v90.i8, (float32x2_t)0xC080000040800000);
  *(float *)&v76 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v75, 1), *((float *)this + 4), v75.f32[0]);
  LODWORD(v74) = *((_DWORD *)this + 6);
  v77.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v78) = *((_DWORD *)this + 9);
  *(float *)v79.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v75, 1), *(float *)v77.i32, v75.f32[0]);
  v80 = (float64x2_t)v86;
  *(float *)&v81 = *(float *)&v74 + *(float *)&v76;
  *(float *)v80.f64 = *(float *)&v78 + *(float *)v79.i32;
  *((float *)&v81 + 1) = *(float *)&v78 + *(float *)v79.i32;
  CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v81, v80, v74, v76, v77, v79, v78, v82);
  return (__n128)v89;
}

double cikernel::_edgesPrep(float32x4_t a1, double a2)
{
  float32x4_t v2;
  float32x4_t v3;
  double result;

  *(float *)&a2 = fmaxf(a1.f32[3], 0.00001);
  v2 = vdivq_f32(a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0));
  v2.i32[3] = 0;
  v3 = vmaxnmq_f32(v2, (float32x4_t)0);
  v3.i32[3] = 0;
  *(_QWORD *)&result = vsqrtq_f32(v3).u64[0];
  return result;
}

double cikernel::_findEdges(cikernel *this, SamplerObj *a2, float a3)
{
  float32x2_t *DC;
  int8x16_t v5;
  double v6;
  double v7;
  double v8;
  float64x2_t v9;
  uint8x8_t v10;
  double v11;
  int8x16_t v12;
  float64x2_t v18;
  double v19;
  double v20;
  uint8x8_t v21;
  int8x16_t v22;
  double v23;
  int8x16_t v24;
  float32x4_t v25;
  double v26;
  float32x2_t v27;
  double v28;
  int8x16_t v29;
  double v30;
  uint8x8_t v31;
  float64x2_t v32;
  int8x16_t v33;
  float32x4_t v34;
  float64x2_t v35;
  double v36;
  double v37;
  uint8x8_t v38;
  int8x16_t v39;
  double v40;
  int8x16_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  double result;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float64x2_t v50;

  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v5.i8 = *DC;
  v50 = (float64x2_t)v5;
  LODWORD(v6) = *((_DWORD *)this + 7);
  *(float *)&v7 = *((float *)this + 6)
                + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *DC, 1), *((float *)this + 4), COERCE_FLOAT(*DC));
  LODWORD(v8) = *((_DWORD *)this + 9);
  *(float *)v9.f64 = *(float *)&v8
                   + vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *DC, 1), *(float *)&v6, COERCE_FLOAT(*DC));
  HIDWORD(v7) = LODWORD(v9.f64[0]);
  *(double *)_Q0.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v7, v9, v6, v8, v5, v10, v11, v12);
  v47 = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  v18 = v50;
  *(float32x2_t *)_Q0.f32 = vadd_f32(*(float32x2_t *)&v50.f64[0], *(float32x2_t *)_Q0.f32);
  *(float *)&v19 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)_Q0.f32, 1), *((float *)this + 4), _Q0.f32[0]);
  LODWORD(v20) = *((_DWORD *)this + 7);
  v21.i32[0] = *((_DWORD *)this + 9);
  *(float *)v22.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)_Q0.f32, 1), *(float *)&v20, _Q0.f32[0]);
  _Q0.f32[0] = *((float *)this + 6) + *(float *)&v19;
  *(float *)v18.f64 = *(float *)v21.i32 + *(float *)v22.i32;
  _Q0.f32[1] = *(float *)v21.i32 + *(float *)v22.i32;
  *(double *)v25.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)_Q0.i64, v18, v19, v20, v22, v21, v23, v24);
  HIDWORD(v26) = HIDWORD(v50.f64[0]);
  v27 = vadd_f32(*(float32x2_t *)&v50.f64[0], (float32x2_t)0x3F80000000000000);
  *(float *)&v28 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), v27, 1), *((float *)this + 4), v27.f32[0]);
  LODWORD(v26) = *((_DWORD *)this + 6);
  v29.i32[0] = *((_DWORD *)this + 7);
  LODWORD(v30) = *((_DWORD *)this + 9);
  *(float *)v31.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), v27, 1), *(float *)v29.i32, v27.f32[0]);
  v32 = (float64x2_t)v47;
  v48 = vsubq_f32(v47, v25);
  v25.f32[0] = *(float *)&v26 + *(float *)&v28;
  *(float *)v32.f64 = *(float *)&v30 + *(float *)v31.i32;
  v25.f32[1] = *(float *)&v30 + *(float *)v31.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v25.i64, v32, v26, v28, v29, v31, v30, v33);
  v46 = v34;
  v35 = v50;
  *(float32x2_t *)v34.f32 = vadd_f32(*(float32x2_t *)&v50.f64[0], (float32x2_t)1065353216);
  *(float *)&v36 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v34.f32, 1), *((float *)this + 4), v34.f32[0]);
  LODWORD(v37) = *((_DWORD *)this + 7);
  v38.i32[0] = *((_DWORD *)this + 9);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v34.f32, 1), *(float *)&v37, v34.f32[0]);
  v34.f32[0] = *((float *)this + 6) + *(float *)&v36;
  *(float *)v35.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v34.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)v42.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v34.i64, v35, v36, v37, v39, v38, v40, v41);
  v43 = vsubq_f32(v46, v42);
  v44 = vmulq_n_f32(vaddq_f32(vmulq_f32(v48, v48), vmulq_f32(v43, v43)), a3);
  v44.f32[0] = fminf(fmaxf(fmaxf(v44.f32[0], v44.f32[1]), v44.f32[2]), 1.0);
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)v44.f32, 0).u64[0];
  return result;
}

double cikernel::_sharpenCombineEdges(int8x16_t a1, int8x16_t a2, float32x4_t a3, float a4, double a5)
{
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  double result;

  *(float *)&a5 = fmaxf(*(float *)&a1.i32[3], 0.00001);
  v5 = vmulq_f32(a3, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.i8, 0), (float32x4_t)vextq_s8(a2, a1, 4uLL)));
  v6 = vdivq_f32((float32x4_t)a1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 0));
  v7 = vaddq_f32((float32x4_t)a2, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))));
  v8 = vmulq_laneq_f32(vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_192497C90, v6, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_192497C80, *(float32x2_t *)v6.f32, 1), vaddq_f32(vmulq_n_f32((float32x4_t)xmmword_192497C70, v6.f32[0]), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v7, v7), 0)))), (float32x4_t)a1, 3);
  v8.i32[3] = a1.i32[3];
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32((float32x4_t)a1, 1.0 - a4), v8, a4).u64[0];
  return result;
}

void CI::f4_s_s_f3_s(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(_QWORD *, __n128, __n128, __n128, __n128);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __n128 *v20;
  __int128 v21;

  v9 = a1[6];
  v10 = (double (*)(_QWORD *, __n128, __n128, __n128, __n128))a1[3];
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_DWORD *)(v9 + 88);
  v17 = *(_QWORD *)(v9 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 104)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v14);
  v20 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v21 = v10(a1, *v20, *v19, *((__n128 *)a2 + 4 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

double cikernel::_sharpenLuminance(float32x4_t a1, float32x4_t a2, float a3)
{
  float32x4_t v3;
  int8x16_t v4;
  float32x4_t v5;
  float32x4_t v6;
  int8x16_t v7;
  int8x16_t v8;
  float32x4_t v9;
  float32x4_t v10;

  v3 = vmulq_f32(a2, (float32x4_t)xmmword_1924921A0);
  v4 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1)));
  *(float32x2_t *)a2.f32 = vsub_f32((float32x2_t)vzip1_s32(*(int32x2_t *)a2.f32, (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a2, (int8x16_t)a2, 8uLL)), (float32x2_t)vdup_lane_s32(*(int32x2_t *)v4.i8, 0));
  v5 = (float32x4_t)vextq_s8(vextq_s8(v4, v4, 4uLL), (int8x16_t)a2, 0xCuLL);
  v6 = vmulq_f32(a1, (float32x4_t)xmmword_1924921A0);
  v7 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1)));
  v8 = vextq_s8((int8x16_t)a1, (int8x16_t)a1, 8uLL);
  *(float32x2_t *)v8.i8 = vsub_f32((float32x2_t)vzip1_s32(*(int32x2_t *)a1.f32, *(int32x2_t *)v8.i8), (float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 0));
  v9 = vmlaq_n_f32(vmulq_n_f32(v5, 1.0 - (float)(a3 + 1.0)), (float32x4_t)vextq_s8(vextq_s8(v7, v7, 4uLL), v8, 0xCuLL), a3 + 1.0);
  v10 = vmulq_f32(v9, (float32x4_t)xmmword_192497D50);
  a1.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).u32[0];
  *(float32x2_t *)v9.f32 = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v9.f32, 0), (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v9, (int8x16_t)v9, 4uLL));
  a1.i64[0] = vtrn2q_s32(vzip1q_s32((int32x4_t)a1, (int32x4_t)v9), (int32x4_t)a1).u64[0];
  return *(double *)a1.i64;
}

simd_float4 cikernel::_grassAndSkyAdjust(float32x4_t a1, double a2)
{
  float v2;
  float32x4_t v3;
  int8x16_t v4;
  simd_float4 v10;
  float v14;
  float v15;
  float v16;
  float v18;
  float v19;
  float v20;
  float v22;
  float v23;
  float v24;
  int8x16_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float32x4_t v36;
  int8x16_t v37;
  simd_float4 v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  int32x2_t v42;
  float32x4_t v43;
  float32x4_t v44;
  simd_float4 result;
  float32x2_t v46;
  float32x2_t v47;
  float v48;
  int8x16_t v49;
  float v50;
  float32x4_t v51;
  float32x4_t v52;
  float v53;
  float v54;
  float32x4_t v55;
  float32x4_t v56;
  float32x4_t v57;
  unsigned __int32 v58;

  v54 = *(float *)&a2;
  v58 = a1.u32[3];
  v2 = *((float *)&a2 + 1);
  v3 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_192497DE0, a1, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_192497DD0, *(float32x2_t *)a1.f32, 1), vmulq_n_f32((float32x4_t)xmmword_192497DC0, a1.f32[0])));
  v4.i64[0] = 0x8000000080000000;
  v4.i64[1] = 0x8000000080000000;
  __asm { FMOV            V2.4S, #1.0 }
  v49 = _Q2;
  v51 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v3), (int8x16_t)vcgtzq_f32(v3)), vorrq_s8(vandq_s8((int8x16_t)v3, v4), _Q2), (int8x16_t)0);
  v10 = (simd_float4)vabsq_f32(v3);
  v10.i32[3] = 0;
  _Q0 = vmulq_f32(v51, (float32x4_t)_simd_pow_f4(v10, (simd_float4)xmmword_192497DF0));
  v52 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_192497E20, _Q0, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_192497E10, *(float32x2_t *)_Q0.f32, 1), vmulq_n_f32((float32x4_t)xmmword_192497E00, _Q0.f32[0])));
  _S8 = v52.i32[2];
  _S14 = v52.i32[1];
  __asm { FMLA            S0, S8, V1.S[2] }
  v14 = atan2f(sqrtf(_Q0.f32[0]) - v52.f32[1], v52.f32[2]) / 3.1416 + 0.5;
  v15 = v14 + -0.88;
  v16 = exp(v15 * v15 / -0.015488);
  _V3.S[1] = v52.i32[1];
  v18 = (float)(v52.f32[0] + -0.4) / 0.1;
  if (v18 <= 1.0)
    v19 = (float)(v52.f32[0] + -0.4) / 0.1;
  else
    v19 = 1.0;
  if (v18 >= 0.0)
    v20 = v19;
  else
    v20 = 0.0;
  v47 = (float32x2_t)vextq_s8((int8x16_t)v52, (int8x16_t)v52, 4uLL).u64[0];
  v48 = (float)(1.0 - (float)((float)(v20 * v20) * (float)((float)(v20 * -2.0) + 3.0))) * v16;
  v46 = vsub_f32((float32x2_t)0x3DCCCCCDBCF5C28FLL, v47);
  __asm { FMLA            S0, S14, V3.S[1] }
  v22 = _S0 * 4.0;
  v23 = pow((float)(_S0 * 4.0), 0.2) * v54;
  v24 = 0.1 / (sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v46, v46).i32[1]), v46.f32[0], v46.f32[0])) + 0.05);
  *(float32x2_t *)v25.i8 = vmul_n_f32(vadd_f32(v47, vmul_n_f32(vmul_n_f32(v46, fminf(fminf(1.0 - (float)(v22 * v22), 1.0) * v23, 1.5)), fminf(v24, 1.0))), v54);
  v26 = (float32x4_t)vextq_s8(v25, v25, 0xCuLL);
  v26.i32[0] = v52.i32[0];
  v27 = vmlaq_n_f32(vmulq_n_f32(v52, 1.0 - v48), v26, v48);
  v55 = v27;
  v28 = (float)(v27.f32[0] + -0.2) / 0.3;
  if (v28 <= 1.0)
    v29 = (float)(v27.f32[0] + -0.2) / 0.3;
  else
    v29 = 1.0;
  if (v28 >= 0.0)
    v30 = v29;
  else
    v30 = 0.0;
  v31 = (float)(v30 * v30) * (float)((float)(v30 * -2.0) + 3.0);
  v32 = v27.f32[1] + 0.04;
  v33 = exp(v32 * v32 / -0.045) * v31;
  v34 = v55.f32[2] + 0.1;
  v35 = exp(v34 * v34 / -0.08) * v33;
  v53 = v35;
  v36 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_192497E40, v55, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 0), vmulq_lane_f32((float32x4_t)xmmword_192497E30, *(float32x2_t *)v55.f32, 1)));
  v37.i64[0] = 0x8000000080000000;
  v37.i64[1] = 0x8000000080000000;
  v56 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v36), (int8x16_t)vcgtzq_f32(v36)), vorrq_s8(vandq_s8((int8x16_t)v36, v37), v49), (int8x16_t)0);
  v38 = (simd_float4)vabsq_f32(v36);
  v38.i32[3] = 0;
  v39 = vmulq_f32((float32x4_t)_simd_pow_f4(v38, (simd_float4)xmmword_192497E50), v56);
  v40 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_192497E80, v39, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_192497E70, *(float32x2_t *)v39.f32, 1), vmulq_n_f32((float32x4_t)xmmword_192497E60, v39.f32[0])));
  v40.i32[3] = 0;
  v41 = vmaxnmq_f32(v40, (float32x4_t)0);
  v41.i32[3] = v58;
  v57 = v41;
  v50 = fabsf(v2);
  result = _simd_pow_f4((simd_float4)vmulq_n_f32(v41, fmaxf(v2 + 1.0, 1.0)), (simd_float4)vdupq_lane_s32((int32x2_t)COERCE_UNSIGNED_INT(v50 + 1.0), 0));
  v42 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)result.f32, 1), vaddq_f32((float32x4_t)result, (float32x4_t)vdupq_laneq_s32((int32x4_t)result, 2))).u64[0];
  *(float *)v42.i32 = *(float *)v42.i32 / 3.0;
  v43.i64[0] = 0x3F0000003F000000;
  v43.i64[1] = 0x3F0000003F000000;
  v44 = vaddq_f32((float32x4_t)result, vmulq_f32(vmulq_n_f32(vsubq_f32((float32x4_t)result, (float32x4_t)vdupq_lane_s32(v42, 0)), v50), v43));
  v44.i32[3] = result.i32[3];
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(v57, 1.0 - v53), v44, v53).u64[0];
  result.i32[3] = v58;
  return result;
}

__n128 cikernel::_smartBlackAndWhite(uint64x2_t *a1, float32x4_t a2, float32x4_t a3, __n128 a4)
{
  float v5;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float v19;
  float v20;
  float64x2_t v21;
  float v22;
  double v23;
  int8x16_t v24;
  uint8x8_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float32x4_t v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  __n128 result;
  float v46;
  double v47;
  float v49;
  float32x4_t v50;

  v47 = a4.n128_f64[0];
  v49 = a4.n128_f32[2];
  v5 = a4.n128_f32[3];
  __asm { FMOV            V1.4S, #1.0 }
  v50 = vminnmq_f32(vmaxnmq_f32(a2, (float32x4_t)0), _Q1);
  v11 = vmulq_f32(v50, (float32x4_t)xmmword_192497F10);
  v11.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).u32[0];
  v12 = vmulq_f32(v50, (float32x4_t)xmmword_192497F20);
  v13 = vmulq_f32(v50, (float32x4_t)xmmword_192497F30);
  v11.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).u32[0];
  v11.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).u32[0];
  v14 = (float32x4_t)_simd_pow_f4((simd_float4)v11, (simd_float4)xmmword_192497DF0);
  v15 = vmulq_f32(v14, (float32x4_t)xmmword_192497F40);
  v46 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1))).f32[0];
  v16 = vmulq_f32(v14, (float32x4_t)xmmword_192497F50);
  v16.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), vaddq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v16.f32, 1))).u32[0];
  v17 = vmulq_f32(v14, (float32x4_t)xmmword_192497F60);
  v18 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1)));
  v19 = sqrtf(vmlas_n_f32(vmulq_f32(v18, v18).f32[0], v16.f32[0], v16.f32[0]));
  v20 = atan2f(v18.f32[0], v16.f32[0]);
  v21.f64[0] = 0.5;
  v22 = v20 / 6.28318531 + 0.5;
  *(float *)v21.f64 = vmlas_n_f32(*((float *)&v47 + 1), v22, *(float *)&v47);
  *(double *)v28.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(LODWORD(v21.f64[0]) | 0x3F00000000000000), v21, v47, v23, v24, v25, v26, v27);
  v29 = vmulq_f32(a3, v28);
  v30 = fabs(v46 + -0.5) * 0.53 + 0.06;
  if ((float)(25.0 * v46) <= 1.0)
    v31 = 25.0 * v46;
  else
    v31 = 1.0;
  if ((float)(25.0 * v46) >= 0.0)
    v32 = v31;
  else
    v32 = 0.0;
  v33 = (float)(v32 * v32) * (float)((float)(v32 * -2.0) + 3.0);
  v34 = v19 / v30;
  if (v34 <= 1.0)
    v35 = v34;
  else
    v35 = 1.0;
  if (v34 >= 0.0)
    v36 = v35;
  else
    v36 = 0.0;
  v37 = (1.0 - v46) * (float)((float)(v36 * v36) * (float)((float)(v36 * -2.0) + 3.0)) * v33 * (v29.f32[3] + -1.0) + 1.0;
  v38 = vmulq_f32(a3, v50);
  v39 = powf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0], v37);
  if ((float)(v19 * 10.0) <= 1.0)
    v40 = v19 * 10.0;
  else
    v40 = 1.0;
  if ((float)(v19 * 10.0) >= 0.0)
    v41 = v40;
  else
    v41 = 0.0;
  v42 = (1.0 - v39)
      * v39
      * (float)(1.0 - (float)((float)(v41 * v41) * (float)((float)(v41 * -2.0) + 3.0)))
      * (v49 + -1.0)
      + 1.0;
  v43 = v42 * -4.0 + 5.0;
  result.n128_f32[0] = powf(v39, v43);
  v44 = result.n128_f32[0] * -2.1972 * result.n128_f32[0]
      + result.n128_f32[0] * 1.8031 * result.n128_f32[0] * result.n128_f32[0]
      + result.n128_f32[0] * 1.3823;
  result.n128_f32[0] = (float)(result.n128_f32[0] * (float)(v5 + 1.0)) - (float)(v5 * v44);
  result.n128_u64[0] = vdupq_lane_s32((int32x2_t)result.n128_u64[0], 0).u64[0];
  result.n128_u32[3] = v50.u32[3];
  return result;
}

void CI::f4_s_sr2d_f4_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(uint64_t, __n128, __n128, __n128);
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __n128 *v20;
  __int128 v21;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(uint64_t, __n128, __n128, __n128))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *((_QWORD *)a2 + 8 * *(_QWORD *)(v9 + 32));
  v13 = *(_QWORD *)(v9 + 8);
  v14 = *(_DWORD *)(v9 + 64);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_DWORD *)(v9 + 88);
  v17 = *(_QWORD *)(v9 + 80);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 104)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v15);
  v20 = (__n128 *)(a3 + 16 * v13);
  if (v11 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v21 = v10(v12, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

uint64_t `anonymous namespace'::smart_tone_stats_from_histogram(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  long double v5;
  long double v6;
  double v7;
  double v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  double v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  double v20;
  unint64_t v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  BOOL v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  _BYTE v37[4104];
  uint64_t v38;

  v4 = 0;
  v38 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v5 = 0.0;
  v6 = 0.0;
  do
  {
    v7 = fmin((double)v4 / 255.0, 1.0);
    v8 = *(double *)(a1 + 8 * v4);
    v5 = v5 + v8 * log(v7 + 0.00392156863);
    *(long double *)a2 = v5;
    v6 = v6 + v8 * log(1.0 - v7 + 0.00392156863);
    *(long double *)(a2 + 8) = v6;
    ++v4;
  }
  while (v4 != 512);
  *(long double *)a2 = exp(v5);
  *(long double *)(a2 + 8) = exp(v6);
  result = MEMORY[0x1E0C80A78](v9, v10, v11, v12, v13, v14);
  v17 = 0;
  v18 = 1.0e-40;
  do
  {
    v18 = v18 + *(double *)(a1 + v17);
    v17 += 8;
  }
  while (v17 != 4096);
  v19 = 0;
  v20 = 0.0;
  do
  {
    v20 = v20 + *(double *)(a1 + v19);
    *(double *)&v37[v19] = v20 / v18;
    v19 += 8;
  }
  while (v19 != 4096);
  v21 = 0;
  v22 = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  v23 = 0.0;
  v24 = 0.0;
  v25 = 0.0;
  v26 = 0.0;
  v27 = 0.0;
  v28 = 0.0;
  do
  {
    v29 = *(double *)&v37[8 * v21];
    if (v29 >= 0.001 && v22 == 0.0)
      v22 = (double)v21 / 255.0;
    if (v29 >= 0.02 && v23 == 0.0)
    {
      v23 = (double)v21 / 255.0;
      *(double *)(a2 + 16) = v23;
    }
    if (v29 >= 0.1 && v24 == 0.0)
    {
      v24 = (double)v21 / 255.0;
      *(double *)(a2 + 24) = v24;
    }
    if (v29 >= 0.25 && v25 == 0.0)
    {
      v25 = (double)v21 / 255.0;
      *(double *)(a2 + 32) = v25;
    }
    if (v29 >= 0.5 && v26 == 0.0)
    {
      v26 = (double)v21 / 255.0;
      *(double *)(a2 + 40) = v26;
    }
    if (v29 >= 0.98 && v27 == 0.0)
    {
      v27 = (double)v21 / 255.0;
      *(double *)(a2 + 48) = v27;
    }
    if (v29 >= 1.0 && v28 == 0.0)
    {
      v28 = (double)v21 / 255.0;
      *(double *)(a2 + 72) = v28;
    }
    ++v21;
  }
  while (v21 != 512);
  *(double *)(a2 + 64) = v22 * ((sqrt(v22) * -0.65 + 1.0) * 0.85);
  v30 = 0.6 - v26 - v25;
  v31 = v28 < 1.0 && v16 < 0.8;
  v32 = v30 + fmin(0.8 - v16, 0.2);
  v33 = v30 * 0.9;
  if (v31)
    v33 = v32;
  v34 = v26 + v25;
  if (v26 + v25 > 0.6)
  {
    if (v27 >= 1.0)
      v35 = -0.4;
    else
      v35 = -0.7;
    v33 = v34 + v35;
  }
  v36 = fmax(v33, 0.1);
  if (v26 <= 0.14 || v23 <= 0.015 || v27 <= 0.95)
  {
    if (v23 > 0.055)
      v36 = -v36;
  }
  else
  {
    v36 = -v36;
  }
  *(double *)(a2 + 56) = v36 * 0.68;
  return result;
}

uint64_t `anonymous namespace'::assemble_smart_tone_stats(void *a1, uint64_t a2, double a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;

  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", CFSTR("tonalRange")), "doubleValue");
  *(_QWORD *)a2 = v6;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", CFSTR("highKey")), "doubleValue");
  *(_QWORD *)(a2 + 8) = v7;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", CFSTR("p02")), "doubleValue");
  *(_QWORD *)(a2 + 16) = v8;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", CFSTR("p10")), "doubleValue");
  *(_QWORD *)(a2 + 24) = v9;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", CFSTR("p25")), "doubleValue");
  *(_QWORD *)(a2 + 32) = v10;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", CFSTR("p50")), "doubleValue");
  *(_QWORD *)(a2 + 40) = v11;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", CFSTR("p98")), "doubleValue");
  *(_QWORD *)(a2 + 48) = v12;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", CFSTR("autoValue")), "doubleValue");
  *(_QWORD *)(a2 + 56) = v13;
  objc_msgSend((id)objc_msgSend(a1, "objectForKey:", CFSTR("blackPoint")), "doubleValue");
  *(_QWORD *)(a2 + 64) = v14;
  result = objc_msgSend((id)objc_msgSend(a1, "objectForKey:", CFSTR("whitePoint")), "doubleValue");
  *(_QWORD *)(a2 + 72) = v16;
  *(double *)(a2 + 80) = a3;
  return result;
}

void `anonymous namespace'::smart_tone_adjustments_from_stats(uint64_t a1, double *a2, double a3)
{
  double v5;
  double v6;
  double v7;
  double v8;
  BOOL v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  long double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  long double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  BOOL v36;
  double v37;
  double v38;
  double v39;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;

  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  v5 = a2[6];
  if (a3 == 0.0 || v5 >= 0.01)
  {
    v6 = a2[10];
    v7 = fabs(v6);
    v8 = a3 * 0.75;
    v9 = v7 < 1.0e-10;
    if (v7 >= 1.0e-10)
      v10 = a3 * 0.75;
    else
      v10 = a3;
    v11 = 0.0;
    if (!v9)
    {
      v12 = fabs(a3) * 0.75 * v6;
      v13 = a2[7];
      v11 = v12 / fabs(v13);
      if (v11 > v6)
        v11 = v6 - fabs(v13 * 0.75) + fabs(v8) * 0.5;
    }
    *(double *)(a1 + 48) = v11;
    v14 = a2[2];
    v15 = pow(fabs(v10 / 1.5), 1.3) * 1.5;
    v16 = a2[4];
    v17 = *a2;
    v18 = a2[1];
    v19 = fmin(v5, v18);
    v20 = 0.5;
    v21 = a2[9];
    v46 = v21;
    if (v21 <= 1.0)
    {
      v27 = 1.0 - v5 - v15;
    }
    else
    {
      v22 = v14;
      v23 = a2[4];
      v24 = v10;
      v25 = *a2;
      v26 = log2(v21);
      v20 = 0.5;
      v17 = v25;
      v10 = v24;
      v16 = v23;
      v14 = v22;
      v27 = -0.25 - v26;
    }
    v28 = v5 - v14;
    v29 = fmax(v19, v20);
    v30 = fmax(v27, -0.25);
    if (v10 >= 0.0)
    {
      v32 = v16 + -0.14;
      v33 = fmax(-v15, -0.25);
      if (v46 == 1.0)
        v30 = v33;
      if (v32 >= 0.0)
      {
        if (v5 < 0.82)
        {
          if (v32 < 0.06)
            v32 = sqrt(v32);
          v32 = v32 * -2.0;
        }
      }
      else
      {
        v36 = v32 <= -0.05;
        v34 = v32 * 3.5;
        v32 = sqrt(-v32) * -3.0;
        if (v36)
          v32 = v34;
      }
      v35 = a2[5];
      if (v28 < 0.68 && v35 < 0.35 && v14 > 0.04)
        v32 = v32 / (v28 * (v18 - v17));
      if (v35 - v16 > 0.35)
        v32 = v32 * 2.5;
      v36 = v16 <= 0.7 && a2[3] <= 0.45;
      if (!v36)
        v32 = -v32;
      if (v32 > 0.0)
        v32 = -v32;
      v37 = fmax(fmin(v32, 0.8), -0.8);
      v38 = fmin(fmin(v15 * 1.75 / v28, v15 + v15) / 3.4, 1.0);
      v39 = fmin(0.35 / v28 * (1.0 - v35) / v29, 0.85);
      if (v39 < 0.5 && v16 < 0.08)
        v41 = v39 * 1.5;
      else
        v41 = v39;
      v42 = v38 * 0.65;
      if (v18 < 0.4)
        v37 = v37 * 1.2;
      else
        v42 = v38;
      if (v18 >= 0.4)
        v43 = v41;
      else
        v43 = v41 * 1.25;
      *(double *)a1 = v10 * v30 * 0.5;
      *(double *)(a1 + 8) = v42;
      *(double *)(a1 + 16) = -(v10 * v37);
      *(double *)(a1 + 24) = fmin(v15 * 0.95 * v43, 1.0);
      v44 = v15 * 0.8;
      if (v5 <= 0.85)
        v44 = v5 * (v10 * 0.8);
      *(double *)(a1 + 32) = -fmin(v44, 0.75);
      if (v46 > 1.0)
      {
        *(double *)(a1 + 56) = 1.0 / (v46 * 1.25);
        *(double *)(a1 + 32) = -fmin(v5 * (v15 * 0.65), 0.75);
      }
      v45 = fmin(v10 * 20.0 * a2[8] / fabs(a2[7]), a2[8] * 20.0);
      v31 = fmax(v45 + v42 * -2.0 * v45, 0.0);
    }
    else
    {
      *(double *)(a1 + 8) = fmin(1.0 / v28, 1.25) * v10 / -3.0;
      *(double *)(a1 + 16) = v10 * 0.6666667;
      *(double *)(a1 + 24) = -(v10 * fmin(v29 * 0.75, 0.5));
      *(double *)(a1 + 32) = fmin(v5 * (v10 * 0.8), 0.75);
      if (v46 > 1.0)
      {
        *(double *)a1 = v10 * (fabs(v30) * 0.625);
        *(double *)(a1 + 56) = 1.0 / (v46 * 1.25);
        *(double *)(a1 + 32) = fmax(v15 * -0.75 * v46, -1.0);
      }
      v31 = fmin(v10 * -20.0 * a2[8] / fabs(a2[7]), a2[8] * 20.0);
    }
    *(double *)(a1 + 40) = v31;
  }
}

float32x4_t cikernel::_smarttone_brightness_neg(float32x4_t a1, int32x2_t a2)
{
  simd_float4 v2;
  simd_float4 v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t result;
  float32x4_t v7;
  float v8;
  int32x2_t v9;
  float v10;
  float32x4_t v11;
  float32x4_t v12;
  unsigned __int32 v13;
  float32x4_t v14;

  v13 = a1.u32[3];
  a1.i32[3] = 0;
  v12 = a1;
  v2 = (simd_float4)vmaxnmq_f32(a1, (float32x4_t)0);
  v14 = (float32x4_t)v2;
  v2.i32[3] = 0;
  v10 = *(float *)a2.i32;
  v3 = (simd_float4)vdupq_lane_s32(a2, 0);
  v3.i32[3] = 0;
  v4 = (float32x4_t)_simd_pow_f4(v2, v3);
  v5 = vmulq_f32(v14, (float32x4_t)xmmword_192498030);
  result = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1)));
  v7 = 0uLL;
  if (result.f32[0] > 0.0)
  {
    v8 = v10;
    v9 = *(int32x2_t *)result.f32;
    v11 = v4;
    result.f32[0] = powf(result.f32[0], v8);
    v4 = v11;
    v7 = vdivq_f32(vmulq_n_f32(v14, result.f32[0]), (float32x4_t)vdupq_lane_s32(v9, 0));
  }
  result.i64[0] = vaddq_f32(vminnmq_f32(v12, (float32x4_t)0), vmlaq_f32(vmulq_f32(v4, (float32x4_t)vdupq_n_s32(0x3E4CCCCCu)), (float32x4_t)vdupq_n_s32(0x3F4CCCCDu), v7)).u64[0];
  result.i32[3] = v13;
  return result;
}

float32x4_t cikernel::_smarttone_brightness_pos(float32x4_t a1, double a2)
{
  float32x4_t v2;
  float32x4_t v8;
  simd_float4 v10;
  simd_float4 v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  simd_float4 v15;
  simd_float4 v16;
  float32x4_t result;
  float v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  unsigned __int32 v25;

  v18 = *(float *)&a2;
  v25 = a1.u32[3];
  v2 = a1;
  v2.i32[3] = 0;
  v24 = vminnmq_f32(v2, (float32x4_t)0);
  __asm { FMOV            V4.4S, #-1.0 }
  v23 = vaddq_f32(vmaxnmq_f32(v2, (float32x4_t)xmmword_192491FD0), _Q4);
  v8 = vmaxnmq_f32(v2, (float32x4_t)0);
  v8.i32[3] = 0;
  __asm { FMOV            V2.4S, #1.0 }
  v20 = _Q2;
  v22 = vminnmq_f32(v8, (float32x4_t)xmmword_192491FD0);
  v10 = (simd_float4)vsubq_f32(_Q2, v22);
  v19 = (float32x4_t)v10;
  v10.i32[3] = 0;
  v11 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)&a2, 0);
  v11.i32[3] = 0;
  v12 = (float32x4_t)_simd_pow_f4(v10, v11);
  v13 = vsubq_f32(v20, vmulq_f32(v19, v19));
  v14 = vmulq_f32(vmulq_n_f32(v19, v18 + -1.0), v13);
  v13.f32[0] = v18 * v18;
  v21 = vsubq_f32(v20, vaddq_f32(v12, vmulq_f32(vdivq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 0)), (float32x4_t)vdupq_n_s32(0x3F19999Au))));
  v14.i64[0] = 1.0;
  v14.f32[0] = (fminf(v18, 2.95) + -1.0) / -2.6 + 1.0;
  v15 = (simd_float4)v22;
  v15.i32[3] = 0;
  v16 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)v14.f32, 0);
  v16.i32[3] = 0;
  result = (float32x4_t)_simd_pow_f4(v15, v16);
  result.i64[0] = vaddq_f32(v23, vaddq_f32(v24, vmlaq_f32(vmulq_f32(result, (float32x4_t)vdupq_n_s32(0x3E199998u)), (float32x4_t)vdupq_n_s32(0x3F59999Au), v21))).u64[0];
  result.i32[3] = v25;
  return result;
}

double cikernel::_smarttone_contrast(float32x4_t a1, float a2)
{
  float32x4_t v2;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  double v13;
  double v14;
  double v15;
  double v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float v21;
  float32x4_t v22;
  float32x4_t v23;
  double result;

  a1.i32[3] = 0;
  __asm { FMOV            V6.4S, #-1.0 }
  v9 = vmaxnmq_f32(a1, (float32x4_t)0);
  v9.i32[3] = 0;
  v10 = vaddq_f32(vmaxnmq_f32(a1, (float32x4_t)xmmword_192491FD0), _Q6);
  v11 = vminnmq_f32(v9, (float32x4_t)xmmword_192491FD0);
  v12 = vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x3EAAA64Cu));
  v12.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0]);
  v9.f32[0] = (float)((float)((float)(v11.f32[1] - v12.f32[0]) * (float)(v11.f32[1] - v12.f32[0]))
                    + (float)((float)(v11.f32[0] - v12.f32[0]) * (float)(v11.f32[0] - v12.f32[0])))
            + (float)((float)(v11.f32[2] - v12.f32[0]) * (float)(v11.f32[2] - v12.f32[0]));
  *(double *)v12.i64 = v12.f32[0];
  v13 = 1.0 - *(double *)v12.i64;
  v12.f32[0] = (1.0 - *(double *)v12.i64) * *(double *)v12.i64;
  v14 = (float)(v12.f32[0] * a2);
  *(float *)&v13 = (float)(v12.f32[0] * a2) * -0.5;
  *(double *)v2.i64 = v14 * 0.299;
  v15 = v14 * 0.587;
  v16 = v14 * 0.114;
  v11.i32[3] = 0;
  v17 = vsqrtq_f32(v11);
  v2.f32[0] = *(double *)v2.i64;
  *(float *)&v15 = v15;
  *(float *)&v16 = v16;
  v18 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v13, 0), vaddq_f32(v17, vaddq_f32(vmulq_laneq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v16, 0), v17, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v15, 0), *(float32x2_t *)v17.f32, 1), (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmulq_f32(v17, v2), 0)))));
  v19.i64[0] = 0x3F0000003F000000;
  v19.i64[1] = 0x3F0000003F000000;
  v20 = vmlaq_n_f32(vmulq_n_f32(v17, 1.0 - (float)-(float)(v12.f32[0] * a2)), v19, -(float)(v12.f32[0] * a2));
  v21 = v9.f32[0] + 0.8;
  v22 = vmlaq_n_f32(vmulq_n_f32(v20, 1.0 - v21), v18, v21);
  v22.i32[3] = 0;
  v23 = vmaxnmq_f32(v22, (float32x4_t)0);
  *(_QWORD *)&result = vaddq_f32(v10, vaddq_f32(vminnmq_f32(a1, (float32x4_t)0), vmulq_f32(v23, v23))).u64[0];
  return result;
}

float32x4_t cikernel::_smarttone_highlightcontrast(float32x4_t a1, float a2, float a3)
{
  float32x4_t v4;
  float32x4_t v5;
  unint64_t v6;
  float v7;
  BOOL v8;
  simd_float4 v9;
  double v10;
  simd_float4 v11;
  float v12;
  double v13;
  float32x4_t result;
  int32x2_t v15;

  v4 = vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x3EAAA64Cu));
  v5 = a1;
  v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).u64[0];
  if (*(float *)&v6 <= 1.0)
    v7 = *(float *)&v6;
  else
    v7 = 1.0;
  v8 = *(float *)&v6 < 0.0;
  LODWORD(v6) = 0;
  if (!v8)
    *(float *)&v6 = v7;
  v5.i32[3] = 0;
  v15 = (int32x2_t)v6;
  v9 = (simd_float4)vmaxnmq_f32(v5, (float32x4_t)0);
  v10 = a2 * -2.0 + 3.0;
  *(float *)&v10 = v10;
  v9.i32[3] = 0;
  v11 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)&v10, 0);
  v11.i32[3] = 0;
  result = vaddq_f32((float32x4_t)_simd_pow_f4(v9, v11), vminnmq_f32(v5, (float32x4_t)0));
  v12 = a2 * -3.0 + 4.0;
  v13 = (float)((float)((float)(a2 * a2) * a2) * a2) * -3.0 + 4.0;
  *(float *)&v13 = v13;
  *(float *)&v13 = (float)((float)(*(float *)v15.i32 + -0.8) * *(float *)&v13) + 0.8;
  result.i64[0] = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - (float)(*(float *)v15.i32 * *(float *)v15.i32)), vmlaq_n_f32(vmulq_n_f32(vsubq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v13, 0), result), (float32x4_t)vdupq_lane_s32(v15, 0)), 1.0 - a3), vaddq_f32(vmulq_n_f32(vaddq_f32(result, (float32x4_t)vdupq_n_s32(0xBF4CCCCD)), v12), (float32x4_t)vdupq_n_s32(0x3F4CCCCDu)), a3), *(float *)v15.i32 * *(float *)v15.i32).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

double cikernel::_rawHighlights(float32x4_t a1, float a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float v4;
  float v5;
  BOOL v6;
  float v7;
  float32x4_t v8;
  float32x4_t v9;
  double result;

  v2 = vmulq_n_f32(a1, a2);
  v3 = vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x3EAAA64Cu));
  v4 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0];
  if (v4 <= 1.0)
    v5 = v4;
  else
    v5 = 1.0;
  v6 = v4 < 0.0;
  v7 = 0.0;
  if (!v6)
    v7 = v5;
  v8 = v2;
  v8.i32[3] = 0;
  v9 = a1;
  v9.i32[3] = 0;
  *(_QWORD *)&result = vaddq_f32(vminnmq_f32(v8, (float32x4_t)0), vmlaq_n_f32(vmulq_n_f32(vmaxnmq_f32(v9, (float32x4_t)0), 1.0 - (float)(v7 * v7)), v2, v7 * v7)).u64[0];
  return result;
}

uint64_t ___ZL22CI_SMART_TONE_USE_CUBEv_block_invoke()
{
  char *v0;
  uint64_t result;

  v0 = getenv("CI_SMART_TONE_USE_CUBE");
  if (v0)
    result = atoi(v0);
  else
    result = CI_SMART_TONE_USE_CUBE(void)::v;
  CI_SMART_TONE_USE_CUBE(void)::v = result;
  return result;
}

double cikernel::_smartcolor_contrast(float32x4_t a1, float a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float v5;
  float v6;
  float32x4_t v7;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x2_t v16;
  float v17;
  double result;

  v2 = vmulq_f32(a1, (float32x4_t)xmmword_192498040);
  v3 = vaddq_f32(vsubq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))), 0), a1), (float32x4_t)0);
  v4 = vmulq_f32(v3, v3);
  v5 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0]);
  if (v5 > 1.0)
    v5 = 1.0;
  v6 = (float)((float)(v5 * v5) * (float)((float)(v5 * -2.0) + 3.0)) * 5.0 * a2;
  v7 = a1;
  v7.i32[3] = 0;
  __asm { FMOV            V7.4S, #-1.0 }
  v13 = vaddq_f32(vminnmq_f32(v7, (float32x4_t)0), vaddq_f32(vmaxnmq_f32(v7, (float32x4_t)xmmword_192491FD0), _Q7));
  v14 = vmaxnmq_f32(v7, (float32x4_t)0);
  v14.i32[3] = 0;
  v15 = vminnmq_f32(v14, (float32x4_t)xmmword_192491FD0);
  v16 = (float32x2_t)vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), v15).u64[0];
  v17 = fmaxf(vmuls_lane_f32(v6, v16, 1), -0.35);
  v16.f32[0] = v17 + 1.0;
  *(_QWORD *)&result = vaddq_f32(v13, vdivq_f32(v15, vsubq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)v16, 0), vmulq_n_f32(v15, v17)))).u64[0];
  return result;
}

double cikernel::_smartcolor_contrast_darken(float32x4_t a1, float a2)
{
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  double v12;
  float32x4_t v13;
  simd_float4 v14;
  float32x4_t v15;
  double result;
  float32x4_t v22;

  v3 = vmulq_f32(a1, (float32x4_t)xmmword_192498040);
  v4 = vaddq_f32(vsubq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))), 0), a1), (float32x4_t)0);
  v5 = vmulq_f32(v4, v4);
  v6 = vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1));
  v7 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), v6).f32[0]);
  if (v7 > 1.0)
    v7 = 1.0;
  v12 = a2;
  v8 = a1;
  v8.i32[3] = 0;
  *(float *)&v12 = (float)((float)(v7 * v7) * (float)((float)(v7 * -2.0) + 3.0)) * 5.0 * v12;
  v9 = vmaxnmq_f32(v8, (float32x4_t)0);
  v9.i32[3] = 0;
  v10 = (float32x4_t)xmmword_192491FD0;
  v11 = vminnmq_f32(v9, (float32x4_t)xmmword_192491FD0);
  *(float *)&v12 = vmuls_lane_f32(*(float *)&v12, (float32x2_t)*(_OWORD *)&vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), v11), 1);
  if (*(float *)&v12 >= 0.0)
  {
    v6.f32[0] = *(float *)&v12 + 1.0;
    v15 = vdivq_f32(v11, vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 0), vmulq_n_f32(v11, *(float *)&v12)));
  }
  else
  {
    v13 = vmulq_f32(v11, (float32x4_t)xmmword_192498050);
    v22 = v8;
    *(float *)&v12 = 1.0
                   - (float)(*(float *)&v12
                           * (float)(1.0
                                   - fminf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0], 1.0)));
    v11.i32[3] = 0;
    v14 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)&v12, 0);
    v14.i32[3] = 0;
    v15 = (float32x4_t)_simd_pow_f4((simd_float4)v11, v14);
    v10 = (float32x4_t)xmmword_192491FD0;
    v8 = v22;
  }
  __asm { FMOV            V3.4S, #-1.0 }
  *(_QWORD *)&result = vaddq_f32(v15, vaddq_f32(vminnmq_f32(v8, (float32x4_t)0), vaddq_f32(vmaxnmq_f32(v8, v10), _Q3))).u64[0];
  return result;
}

double cikernel::_smartcolor_vibrancy_gt1(float32x4_t a1, float a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  double v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float32x4_t v14;
  float32x4_t v15;
  double result;

  v2 = a1;
  v2.i32[3] = 0;
  v3 = vmaxnmq_f32(v2, (float32x4_t)0);
  v3.i32[3] = 0;
  v4 = vminnmq_f32(v3, (float32x4_t)xmmword_192491FD0);
  v5 = vmulq_f32(v4, (float32x4_t)xmmword_192498060);
  v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0];
  v8 = 1.0 / (float)(a1.f32[2] + vaddv_f32(*(float32x2_t *)a1.f32));
  v9 = (float)((float)((float)(v8 * a1.f32[0]) - vmuls_lane_f32(v8, a1, 2)) + -0.2) / 0.2;
  if (v9 <= 1.0)
    v10 = v9;
  else
    v10 = 1.0;
  if (v9 < 0.0)
    v10 = 0.0;
  v11 = (float)((float)(v10 * v10) * (float)((float)(v10 * -2.0) + 3.0)) * -0.8 + 1.0;
  v7 = v6 * -4.0 * (1.0 - v6) + 1.0;
  v12 = v11 * v7;
  if (a2 > 2.5)
  {
    v13 = (a2 + -2.5) / 5.0 + v12;
    v12 = fminf(v13, 1.0);
  }
  v14 = vmulq_f32(v4, (float32x4_t)xmmword_192498070);
  v15 = (float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))), 0);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a1, 1.0 - v12), vaddq_f32(v15, vmulq_n_f32(vsubq_f32(a1, v15), fminf(a2, 3.0))), v12).u64[0];
  return result;
}

double cikernel::_smartcolor_vibrancy_lt1(float32x4_t a1, float a2)
{
  float32x4_t v2;
  double result;

  v2 = vmulq_f32(a1, (float32x4_t)vdupq_n_s32(0x3EAAAA9Fu));
  v2.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))).u64[0];
  v2.f32[0] = (float)(1.0 - a2) * v2.f32[0];
  *(_QWORD *)&result = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 0), a1, a2).u64[0];
  return result;
}

float32x4_t cikernel::_smartcolor_cast(float32x4_t a1, float a2, float a3, float a4, float a5)
{
  simd_float4 v12;
  float32x4_t v13;
  float32x4_t v14;
  int8x16_t v15;
  float v16;
  int8x16_t v17;
  float v18;
  float v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t result;
  uint64_t v28;
  unsigned __int32 v30;

  __asm { FMOV            V1.4S, #1.0 }
  v12 = (simd_float4)vminnmq_f32(vmaxnmq_f32(a1, (float32x4_t)0), _Q1);
  v30 = v12.u32[3];
  v12.i32[3] = 0;
  v13 = (float32x4_t)_simd_pow_f4(v12, (simd_float4)xmmword_192491EC0);
  v14 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_192491EB0, v13, 2), vaddq_f32(vmulq_lane_f32((float32x4_t)xmmword_192491EA0, *(float32x2_t *)v13.f32, 1), vmulq_n_f32((float32x4_t)xmmword_192491E90, v13.f32[0])));
  v15.i64[1] = v28;
  v16 = (a5 + -1.0) * (1.0 - v14.f32[0]) + 1.0;
  v17 = vextq_s8((int8x16_t)v14, (int8x16_t)v14, 4uLL);
  *(float32x2_t *)v15.i8 = vadd_f32(*(float32x2_t *)v17.i8, vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)), v16));
  v18 = v14.f32[0] / (a2 + 0.00001);
  v19 = fmaxf(fminf(v18, 1.0), 0.0);
  v20 = vmlaq_n_f32(vmulq_n_f32(v14, 1.0 - v19), (float32x4_t)vextq_s8(v17, v15, 0xCuLL), v19);
  v21 = vaddq_f32(vmulq_laneq_f32((float32x4_t)xmmword_192491F10, v20, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 0), vmulq_lane_f32((float32x4_t)xmmword_192491F00, *(float32x2_t *)v20.f32, 1)));
  v21.i32[3] = 0;
  v22 = vmaxnmq_f32(v21, (float32x4_t)0);
  v22.i32[3] = 0;
  result = vminnmq_f32(v22, (float32x4_t)xmmword_192491FD0);
  v23 = a1;
  v23.i32[3] = 0;
  __asm { FMOV            V2.4S, #-1.0 }
  result.i64[0] = vaddq_f32(vmulq_f32(result, vmulq_f32(result, vmulq_f32(result, result))), vaddq_f32(vaddq_f32(vminnmq_f32(v23, (float32x4_t)0), vmaxnmq_f32(v23, (float32x4_t)xmmword_192491FD0)), _Q2)).u64[0];
  result.i32[3] = v30;
  return result;
}

uint64_t ___ZL23CI_SMART_COLOR_USE_CUBEv_block_invoke()
{
  char *v0;
  uint64_t result;

  v0 = getenv("CI_SMART_COLOR_USE_CUBE");
  if (v0)
    result = atoi(v0);
  else
    result = CI_SMART_COLOR_USE_CUBE(void)::v;
  CI_SMART_COLOR_USE_CUBE(void)::v = result;
  return result;
}

void downsampleRoiH(CGRect a1, float a2)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  float64x2_t v7;
  float64x2_t v8;
  Rectangle v9;
  float64x2_t v10;
  float64x2_t v11;
  Rectangle v12;
  uint64_t v13;
  CGRect v14;

  height = a1.size.height;
  width = a1.size.width;
  y = a1.origin.y;
  x = a1.origin.x;
  if (CGRectIsInfinite(a1))
  {
    *(int64x2_t *)&v9.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v9.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v14.origin.x = x;
    v14.origin.y = y;
    v14.size.width = width;
    v14.size.height = height;
    if (CGRectIsNull(v14))
    {
      *(int64x2_t *)&v9.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
      *(_OWORD *)&v9.var2 = 0uLL;
    }
    else
    {
      v9.var0 = x;
      v9.var1 = y;
      v9.var2 = width;
      v9.var3 = height;
    }
  }
  Rectangle::inset(&v9, -2.0, -0.0, (uint64_t)&v10);
  if (fabs(v10.f64[0]) == INFINITY || fabs(v10.f64[1]) == INFINITY)
  {
    *(int64x2_t *)&v12.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    v12.var2 = 0.0;
    v12.var3 = 0.0;
  }
  else
  {
    v7 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    v8 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v10, v8), (int32x4_t)vceqq_f64(v11, v7))))) & 1) != 0)
    {
      v12.var0 = v10.f64[0] * a2;
      v12.var1 = v10.f64[1];
      v12.var2 = a2 * v11.f64[0];
      v12.var3 = v11.f64[1];
    }
    else
    {
      *(float64x2_t *)&v12.var0 = v8;
      *(float64x2_t *)&v12.var2 = v7;
    }
  }
  Rectangle::integralize(&v12, 0.0001, (uint64_t)&v13);
}

void downsampleRoiV(CGRect a1, float a2)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  float64x2_t v7;
  float64x2_t v8;
  Rectangle v9;
  float64x2_t v10;
  float64x2_t v11;
  Rectangle v12;
  uint64_t v13;
  CGRect v14;

  height = a1.size.height;
  width = a1.size.width;
  y = a1.origin.y;
  x = a1.origin.x;
  if (CGRectIsInfinite(a1))
  {
    *(int64x2_t *)&v9.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v9.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  }
  else
  {
    v14.origin.x = x;
    v14.origin.y = y;
    v14.size.width = width;
    v14.size.height = height;
    if (CGRectIsNull(v14))
    {
      *(int64x2_t *)&v9.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
      *(_OWORD *)&v9.var2 = 0uLL;
    }
    else
    {
      v9.var0 = x;
      v9.var1 = y;
      v9.var2 = width;
      v9.var3 = height;
    }
  }
  Rectangle::inset(&v9, -0.0, -2.0, (uint64_t)&v10);
  if (fabs(v10.f64[0]) == INFINITY || fabs(v10.f64[1]) == INFINITY)
  {
    *(int64x2_t *)&v12.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    v12.var2 = 0.0;
    v12.var3 = 0.0;
  }
  else
  {
    v7 = (float64x2_t)vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    v8 = (float64x2_t)vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqq_f64(v10, v8), (int32x4_t)vceqq_f64(v11, v7))))) & 1) != 0)
    {
      v12.var0 = v10.f64[0];
      v12.var1 = v10.f64[1] * a2;
      v12.var2 = v11.f64[0];
      v12.var3 = vmuld_lane_f64(a2, v11, 1);
    }
    else
    {
      *(float64x2_t *)&v12.var0 = v8;
      *(float64x2_t *)&v12.var2 = v7;
    }
  }
  Rectangle::integralize(&v12, 0.0001, (uint64_t)&v13);
}

double upsampleRoi(float64_t a1, float64_t a2, double a3, double a4, float32x2_t a5)
{
  float64x2_t v8;
  float32x2_t v9;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  double v19;
  uint64_t v20;
  uint64_t v21;
  float32x2_t v22;
  float32_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v30;
  float32x2_t v33;
  CGRect v34;
  CGRect v35;
  CGRect v36;
  CGRect v37;
  CGRect v38;
  CGRect v39;
  CGRect v40;
  CGRect v41;

  v8.f64[0] = a1;
  v8.f64[1] = a2;
  *(float32x2_t *)&v8.f64[0] = vadd_f32(vmul_f32(a5, vcvt_f32_f64(v8)), (float32x2_t)0xBF000000BF000000);
  v9 = vrndm_f32(*(float32x2_t *)&v8.f64[0]);
  __asm { FMOV            V13.2S, #1.0 }
  v15 = vadd_f32(vsub_f32(v9, *(float32x2_t *)&v8.f64[0]), _D13);
  *(float32x2_t *)&v8.f64[0] = vsub_f32(*(float32x2_t *)&v8.f64[0], v9);
  v16 = (float32x2_t)vdup_n_s32(0x3E4CCCCDu);
  v17 = vadd_f32(vsub_f32(v9, vmul_f32(v15, vmul_f32(v15, v16))), (float32x2_t)0x3F0000003F000000);
  __asm { FMOV            V15.2S, #1.5 }
  v30 = vadd_f32(vadd_f32(v9, vmul_f32(*(float32x2_t *)&v8.f64[0], vmul_f32(*(float32x2_t *)&v8.f64[0], v16))), _D15);
  v8.f64[0] = v17.f32[0];
  v19 = v17.f32[1];
  v20 = 0;
  v21 = 0;
  v34 = CGRectUnion(*MEMORY[0x1E0C9D628], *(CGRect *)v8.f64);
  v39.origin.x = v30.f32[0];
  v39.origin.y = v30.f32[1];
  v39.size.width = 0.0;
  v39.size.height = 0.0;
  v35 = CGRectUnion(v34, v39);
  v22.f32[0] = a1 + a3;
  v23 = a2 + a4;
  v22.f32[1] = v23;
  v24 = vadd_f32(vmul_f32(a5, v22), (float32x2_t)0xBF000000BF000000);
  v25 = vrndm_f32(v24);
  v26 = vadd_f32(vsub_f32(v25, v24), _D13);
  v27 = vsub_f32(v24, v25);
  v28 = vadd_f32(vsub_f32(v25, vmul_f32(v26, vmul_f32(v26, v16))), (float32x2_t)0x3F0000003F000000);
  v33 = vadd_f32(vadd_f32(v25, vmul_f32(v27, vmul_f32(v27, v16))), _D15);
  v40.origin.x = v28.f32[0];
  v40.origin.y = v28.f32[1];
  v40.size.width = 0.0;
  v40.size.height = 0.0;
  v36 = CGRectUnion(v35, v40);
  v41.origin.x = v33.f32[0];
  v41.origin.y = v33.f32[1];
  v41.size.width = 0.0;
  v41.size.height = 0.0;
  v37 = CGRectUnion(v36, v41);
  v38 = CGRectInset(v37, 0.0001, 0.0001);
  return COERCE_DOUBLE(CGRectIntegral(v38)) + -1.0;
}

double cikernel::_cubicDownsample2(uint64_t a1, int8x16_t a2)
{
  float32x2_t *DC;
  float32x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  float64x2_t v11;
  double v12;
  int8x16_t v13;
  float32x4_t v14;
  float32x2_t v15;
  double v16;
  double v17;
  int8x16_t v18;
  double v19;
  uint8x8_t v20;
  int8x16_t v21;
  float32x4_t v22;
  double v23;
  float32x2_t v24;
  double v25;
  int8x16_t v26;
  double v27;
  uint8x8_t v28;
  float64x2_t v29;
  int8x16_t v30;
  float32x4_t v31;
  double v32;
  float32x2_t v33;
  double v34;
  int8x16_t v35;
  double v36;
  uint8x8_t v37;
  float64x2_t v38;
  int8x16_t v39;
  float32x4_t v40;
  float32x2_t v41;
  double v42;
  double v43;
  int8x16_t v44;
  double v45;
  uint8x8_t v46;
  float64x2_t v47;
  int8x16_t v48;
  float32x4_t v49;
  float32x2_t v50;
  double v51;
  double v52;
  int8x16_t v53;
  double v54;
  uint8x8_t v55;
  float64x2_t v56;
  int8x16_t v57;
  float32x4_t v58;
  double v59;
  float32x2_t v60;
  double v61;
  int8x16_t v62;
  double v63;
  uint8x8_t v64;
  float64x2_t v65;
  int8x16_t v66;
  float32x4_t v67;
  double v68;
  float32x2_t v69;
  double v70;
  int8x16_t v71;
  double v72;
  uint8x8_t v73;
  float64x2_t v74;
  int8x16_t v75;
  float32x4_t v76;
  double v77;
  float32x2_t v78;
  double v79;
  int8x16_t v80;
  double v81;
  uint8x8_t v82;
  float64x2_t v83;
  int8x16_t v84;
  float32x4_t v85;
  double v86;
  float32x2_t v87;
  double v88;
  int8x16_t v89;
  double v90;
  uint8x8_t v91;
  float64x2_t v92;
  int8x16_t v93;
  float32x4_t v94;
  float32x2_t v95;
  double v96;
  double v97;
  int8x16_t v98;
  double v99;
  uint8x8_t v100;
  float64x2_t v101;
  float32x4_t v102;
  float32x2_t v103;
  double v104;
  double v105;
  int8x16_t v106;
  double v107;
  uint8x8_t v108;
  float64x2_t v109;
  int8x16_t v110;
  float32x4_t v111;
  double v112;
  float32x2_t v113;
  double v114;
  int8x16_t v115;
  double v116;
  uint8x8_t v117;
  float64x2_t v118;
  int8x16_t v119;
  float32x4_t v120;
  double v121;
  float32x2_t v122;
  double v123;
  int8x16_t v124;
  double v125;
  uint8x8_t v126;
  float64x2_t v127;
  int8x16_t v128;
  float32x4_t v129;
  float32x2_t v130;
  double v131;
  double v132;
  int8x16_t v133;
  double v134;
  uint8x8_t v135;
  float64x2_t v136;
  int8x16_t v137;
  float32x4_t v138;
  float32x2_t v139;
  double v140;
  double v141;
  int8x16_t v142;
  double v143;
  uint8x8_t v144;
  float64x2_t v145;
  float32x4_t v146;
  double result;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  int32x2_t v160;
  int32x2_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  v4 = vadd_f32(*DC, *DC);
  v160 = (int32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  v5 = (float32x2_t)vrev64_s32(v160);
  v161 = (int32x2_t)vneg_f32(v5);
  v6 = vadd_f32((float32x2_t)vdup_lane_s32(v161, 0), v4);
  *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v6, 1), *(float *)(a1 + 16), v6.f32[0]);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v11.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v14.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v11, v7, v8, v10, v9, v12, v13);
  v15 = vadd_f32((float32x2_t)vrev64_s32(v161), v4);
  *(float *)&v16 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v15, 1), *(float *)(a1 + 16), v15.f32[0]);
  LODWORD(v17) = *(_DWORD *)(a1 + 24);
  v18.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v19) = *(_DWORD *)(a1 + 36);
  *(float *)v20.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v15, 1), *(float *)v18.i32, v15.f32[0]);
  v148 = vaddq_f32(vmulq_lane_f32(vmulq_lane_f32(v14, *(float32x2_t *)a2.i8, 1), *(float32x2_t *)a2.i8, 1), (float32x4_t)0);
  v14.f32[0] = *(float *)&v17 + *(float *)&v16;
  v14.f32[1] = *(float *)&v19 + *(float *)v20.i32;
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v14.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)&v19 + *(float *)v20.i32), v17, v16, v18, v20, v19, v21);
  HIDWORD(v23) = v161.i32[1];
  v24 = vadd_f32((float32x2_t)__PAIR64__(v161.u32[0], v160.u32[0]), v4);
  *(float *)&v25 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v24, 1), *(float *)(a1 + 16), v24.f32[0]);
  LODWORD(v23) = *(_DWORD *)(a1 + 24);
  v26.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v27) = *(_DWORD *)(a1 + 36);
  *(float *)v28.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v24, 1), *(float *)v26.i32, v24.f32[0]);
  v29 = (float64x2_t)v148;
  v149 = vaddq_f32(v148, vmulq_lane_f32(vmulq_n_f32(v22, *(float *)a2.i32), *(float32x2_t *)a2.i8, 1));
  v22.f32[0] = *(float *)&v23 + *(float *)&v25;
  *(float *)v29.f64 = *(float *)&v27 + *(float *)v28.i32;
  v22.f32[1] = *(float *)&v27 + *(float *)v28.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v22.i64, v29, v23, v25, v26, v28, v27, v30);
  HIDWORD(v32) = v161.i32[1];
  v33 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v160, (int8x8_t)v161, 4uLL), v4);
  *(float *)&v34 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v33, 1), *(float *)(a1 + 16), v33.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 24);
  v35.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v36) = *(_DWORD *)(a1 + 36);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v33, 1), *(float *)v35.i32, v33.f32[0]);
  v38 = (float64x2_t)v149;
  v150 = vaddq_f32(v149, vmulq_lane_f32(vmulq_n_f32(v31, *(float *)a2.i32), *(float32x2_t *)a2.i8, 1));
  v31.f32[0] = *(float *)&v32 + *(float *)&v34;
  *(float *)v38.f64 = *(float *)&v36 + *(float *)v37.i32;
  v31.f32[1] = *(float *)&v36 + *(float *)v37.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v31.i64, v38, v32, v34, v35, v37, v36, v39);
  v41 = vsub_f32(v4, v5);
  *(float *)&v42 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v41, 1), *(float *)(a1 + 16), v41.f32[0]);
  LODWORD(v43) = *(_DWORD *)(a1 + 24);
  v44.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v45) = *(_DWORD *)(a1 + 36);
  *(float *)v46.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v41, 1), *(float *)v44.i32, v41.f32[0]);
  v47 = (float64x2_t)v150;
  v151 = vaddq_f32(v150, vmulq_lane_f32(vmulq_lane_f32(v40, *(float32x2_t *)a2.i8, 1), *(float32x2_t *)a2.i8, 1));
  v40.f32[0] = *(float *)&v43 + *(float *)&v42;
  *(float *)v47.f64 = *(float *)&v45 + *(float *)v46.i32;
  v40.f32[1] = *(float *)&v45 + *(float *)v46.i32;
  *(double *)v49.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v40.i64, v47, v43, v42, v44, v46, v45, v48);
  v50 = vadd_f32((float32x2_t)vdup_lane_s32(v161, 1), v4);
  *(float *)&v51 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v50, 1), *(float *)(a1 + 16), v50.f32[0]);
  LODWORD(v52) = *(_DWORD *)(a1 + 24);
  v53.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v54) = *(_DWORD *)(a1 + 36);
  *(float *)v55.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v50, 1), *(float *)v53.i32, v50.f32[0]);
  v56 = (float64x2_t)v151;
  v152 = vaddq_f32(v151, vmulq_n_f32(vmulq_lane_f32(v49, *(float32x2_t *)a2.i8, 1), *(float *)a2.i32));
  v49.f32[0] = *(float *)&v52 + *(float *)&v51;
  *(float *)v56.f64 = *(float *)&v54 + *(float *)v55.i32;
  v49.f32[1] = *(float *)&v54 + *(float *)v55.i32;
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v49.i64, v56, v52, v51, v53, v55, v54, v57);
  HIDWORD(v59) = v161.i32[1];
  v60 = vadd_f32((float32x2_t)__PAIR64__(v161.u32[1], v160.u32[0]), v4);
  *(float *)&v61 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v60, 1), *(float *)(a1 + 16), v60.f32[0]);
  LODWORD(v59) = *(_DWORD *)(a1 + 24);
  v62.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v63) = *(_DWORD *)(a1 + 36);
  *(float *)v64.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v60, 1), *(float *)v62.i32, v60.f32[0]);
  v65 = (float64x2_t)v152;
  v153 = vaddq_f32(v152, vmulq_n_f32(vmulq_n_f32(v58, *(float *)a2.i32), *(float *)a2.i32));
  v58.f32[0] = *(float *)&v59 + *(float *)&v61;
  *(float *)v65.f64 = *(float *)&v63 + *(float *)v64.i32;
  v58.f32[1] = *(float *)&v63 + *(float *)v64.i32;
  *(double *)v67.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v58.i64, v65, v59, v61, v62, v64, v63, v66);
  HIDWORD(v68) = v160.i32[1];
  v69 = vadd_f32((float32x2_t)__PAIR64__(v161.u32[1], v160.u32[1]), v4);
  *(float *)&v70 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v69, 1), *(float *)(a1 + 16), v69.f32[0]);
  LODWORD(v68) = *(_DWORD *)(a1 + 24);
  v71.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v72) = *(_DWORD *)(a1 + 36);
  *(float *)v73.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v69, 1), *(float *)v71.i32, v69.f32[0]);
  v74 = (float64x2_t)v153;
  v154 = vaddq_f32(v153, vmulq_n_f32(vmulq_n_f32(v67, *(float *)a2.i32), *(float *)a2.i32));
  v67.f32[0] = *(float *)&v68 + *(float *)&v70;
  *(float *)v74.f64 = *(float *)&v72 + *(float *)v73.i32;
  v67.f32[1] = *(float *)&v72 + *(float *)v73.i32;
  *(double *)v76.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v67.i64, v74, v68, v70, v71, v73, v72, v75);
  HIDWORD(v77) = v161.i32[1];
  v78 = vadd_f32((float32x2_t)vzip1_s32(v161, v160), v4);
  *(float *)&v79 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v78, 1), *(float *)(a1 + 16), v78.f32[0]);
  LODWORD(v77) = *(_DWORD *)(a1 + 24);
  v80.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v81) = *(_DWORD *)(a1 + 36);
  *(float *)v82.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v78, 1), *(float *)v80.i32, v78.f32[0]);
  v83 = (float64x2_t)v154;
  v155 = vaddq_f32(v154, vmulq_n_f32(vmulq_lane_f32(v76, *(float32x2_t *)a2.i8, 1), *(float *)a2.i32));
  v76.f32[0] = *(float *)&v77 + *(float *)&v79;
  *(float *)v83.f64 = *(float *)&v81 + *(float *)v82.i32;
  v76.f32[1] = *(float *)&v81 + *(float *)v82.i32;
  *(double *)v85.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v76.i64, v83, v77, v79, v80, v82, v81, v84);
  HIDWORD(v86) = v161.i32[1];
  v87 = vadd_f32((float32x2_t)vext_s8((int8x8_t)v161, (int8x8_t)v160, 4uLL), v4);
  *(float *)&v88 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v87, 1), *(float *)(a1 + 16), v87.f32[0]);
  LODWORD(v86) = *(_DWORD *)(a1 + 24);
  v89.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v90) = *(_DWORD *)(a1 + 36);
  *(float *)v91.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v87, 1), *(float *)v89.i32, v87.f32[0]);
  v92 = (float64x2_t)v155;
  v156 = vaddq_f32(v155, vmulq_n_f32(vmulq_lane_f32(v85, *(float32x2_t *)a2.i8, 1), *(float *)a2.i32));
  v85.f32[0] = *(float *)&v86 + *(float *)&v88;
  *(float *)v92.f64 = *(float *)&v90 + *(float *)v91.i32;
  v85.f32[1] = *(float *)&v90 + *(float *)v91.i32;
  *(double *)v94.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v85.i64, v92, v86, v88, v89, v91, v90, v93);
  v95 = vadd_f32((float32x2_t)vdup_laneq_s32((int32x4_t)a2, 2), v4);
  *(float *)&v96 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v95, 1), *(float *)(a1 + 16), v95.f32[0]);
  LODWORD(v97) = *(_DWORD *)(a1 + 24);
  v98.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v99) = *(_DWORD *)(a1 + 36);
  *(float *)v100.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v95, 1), *(float *)v98.i32, v95.f32[0]);
  v101 = (float64x2_t)v156;
  v157 = vaddq_f32(v156, vmulq_n_f32(vmulq_n_f32(v94, *(float *)a2.i32), *(float *)a2.i32));
  v94.f32[0] = *(float *)&v97 + *(float *)&v96;
  *(float *)v101.f64 = *(float *)&v99 + *(float *)v100.i32;
  v94.f32[1] = *(float *)&v99 + *(float *)v100.i32;
  *(double *)v102.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v94.i64, v101, v97, v96, v98, v100, v99, a2);
  v103 = vadd_f32(v5, v4);
  *(float *)&v104 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v103, 1), *(float *)(a1 + 16), v103.f32[0]);
  LODWORD(v105) = *(_DWORD *)(a1 + 24);
  v106.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v107) = *(_DWORD *)(a1 + 36);
  *(float *)v108.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v103, 1), *(float *)v106.i32, v103.f32[0]);
  v109 = (float64x2_t)v157;
  v158 = vaddq_f32(v157, vmulq_n_f32(vmulq_n_f32(v102, *(float *)a2.i32), *(float *)a2.i32));
  v102.f32[0] = *(float *)&v105 + *(float *)&v104;
  *(float *)v109.f64 = *(float *)&v107 + *(float *)v108.i32;
  v102.f32[1] = *(float *)&v107 + *(float *)v108.i32;
  *(double *)v111.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v102.i64, v109, v105, v104, v106, v108, v107, v110);
  HIDWORD(v112) = v160.i32[1];
  v113 = vadd_f32((float32x2_t)__PAIR64__(v160.u32[1], v161.u32[0]), v4);
  *(float *)&v114 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v113, 1), *(float *)(a1 + 16), v113.f32[0]);
  LODWORD(v112) = *(_DWORD *)(a1 + 24);
  v115.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v116) = *(_DWORD *)(a1 + 36);
  *(float *)v117.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v113, 1), *(float *)v115.i32, v113.f32[0]);
  v118 = (float64x2_t)v158;
  v159 = vaddq_f32(v158, vmulq_n_f32(vmulq_lane_f32(v111, *(float32x2_t *)a2.i8, 1), *(float *)a2.i32));
  v111.f32[0] = *(float *)&v112 + *(float *)&v114;
  *(float *)v118.f64 = *(float *)&v116 + *(float *)v117.i32;
  v111.f32[1] = *(float *)&v116 + *(float *)v117.i32;
  *(double *)v120.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v111.i64, v118, v112, v114, v115, v117, v116, v119);
  HIDWORD(v121) = v161.i32[1];
  v122 = vadd_f32((float32x2_t)vzip2_s32(v161, v160), v4);
  *(float *)&v123 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v122, 1), *(float *)(a1 + 16), v122.f32[0]);
  LODWORD(v121) = *(_DWORD *)(a1 + 24);
  v124.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v125) = *(_DWORD *)(a1 + 36);
  *(float *)v126.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v122, 1), *(float *)v124.i32, v122.f32[0]);
  v127 = (float64x2_t)v159;
  v162 = vaddq_f32(v159, vmulq_lane_f32(vmulq_lane_f32(v120, *(float32x2_t *)a2.i8, 1), *(float32x2_t *)a2.i8, 1));
  v120.f32[0] = *(float *)&v121 + *(float *)&v123;
  *(float *)v127.f64 = *(float *)&v125 + *(float *)v126.i32;
  v120.f32[1] = *(float *)&v125 + *(float *)v126.i32;
  *(double *)v129.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v120.i64, v127, v121, v123, v124, v126, v125, v128);
  v130 = vadd_f32((float32x2_t)v160, v4);
  *(float *)&v131 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v130, 1), *(float *)(a1 + 16), v130.f32[0]);
  LODWORD(v132) = *(_DWORD *)(a1 + 24);
  v133.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v134) = *(_DWORD *)(a1 + 36);
  *(float *)v135.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v130, 1), *(float *)v133.i32, v130.f32[0]);
  v136 = (float64x2_t)v162;
  v163 = vaddq_f32(v162, vmulq_lane_f32(vmulq_n_f32(v129, *(float *)a2.i32), *(float32x2_t *)a2.i8, 1));
  v129.f32[0] = *(float *)&v132 + *(float *)&v131;
  *(float *)v136.f64 = *(float *)&v134 + *(float *)v135.i32;
  v129.f32[1] = *(float *)&v134 + *(float *)v135.i32;
  *(double *)v138.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v129.i64, v136, v132, v131, v133, v135, v134, v137);
  v139 = vadd_f32((float32x2_t)vdup_laneq_s32((int32x4_t)a2, 3), v4);
  *(float *)&v140 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v139, 1), *(float *)(a1 + 16), v139.f32[0]);
  LODWORD(v141) = *(_DWORD *)(a1 + 24);
  v142.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v143) = *(_DWORD *)(a1 + 36);
  *(float *)v144.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v139, 1), *(float *)v142.i32, v139.f32[0]);
  v145 = (float64x2_t)v163;
  v164 = vaddq_f32(v163, vmulq_lane_f32(vmulq_n_f32(v138, *(float *)a2.i32), *(float32x2_t *)a2.i8, 1));
  v138.f32[0] = *(float *)&v141 + *(float *)&v140;
  *(float *)v145.f64 = *(float *)&v143 + *(float *)v144.i32;
  v138.f32[1] = *(float *)&v143 + *(float *)v144.i32;
  *(double *)v146.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v138.i64, v145, v141, v140, v142, v144, v143, a2);
  *(_QWORD *)&result = vaddq_f32(v164, vmulq_lane_f32(vmulq_lane_f32(v146, *(float32x2_t *)a2.i8, 1), *(float32x2_t *)a2.i8, 1)).u64[0];
  return result;
}

double cikernel::_cubicDownsample2h(uint64_t a1, int8x16_t a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  float32x2_t v14;
  double v15;
  double v16;
  int8x16_t v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  double v26;
  uint8x8_t v27;
  float64x2_t v28;
  float32x4_t v29;
  float32x2_t v30;
  double v31;
  double v32;
  int8x16_t v33;
  double v34;
  uint8x8_t v35;
  float64x2_t v36;
  float32x4_t v37;
  double result;
  float32x2_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  HIDWORD(v4.f64[0]) = 1065353216;
  v5 = vmul_f32(*DC, (float32x2_t)0x3F80000040000000);
  v39 = vneg_f32((float32x2_t)vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL)));
  v6 = vadd_f32(vmul_n_f32((float32x2_t)1065353216, v39.f32[0]), v5);
  *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v6, 1), *(float *)(a1 + 16), v6.f32[0]);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v4, v7, v8, v10, v9, v11, v12);
  v14 = vadd_f32(vmul_lane_f32((float32x2_t)1065353216, v39, 1), v5);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v14, 1), *(float *)(a1 + 16), v14.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 24);
  v17.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v18) = *(_DWORD *)(a1 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v14, 1), *(float *)v17.i32, v14.f32[0]);
  v40 = vaddq_f32(vmulq_lane_f32(v13, *(float32x2_t *)a2.i8, 1), (float32x4_t)0);
  v13.f32[0] = *(float *)&v16 + *(float *)&v15;
  v13.f32[1] = *(float *)&v18 + *(float *)v19.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)&v18 + *(float *)v19.i32), v16, v15, v17, v19, v18, v20);
  v22 = vadd_f32(vmul_laneq_f32((float32x2_t)1065353216, (float32x4_t)a2, 2), v5);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 24);
  v25.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v26) = *(_DWORD *)(a1 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)v25.i32, v22.f32[0]);
  v28 = (float64x2_t)v40;
  v41 = vaddq_f32(v40, vmulq_n_f32(v21, *(float *)a2.i32));
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  *(float *)v28.f64 = *(float *)&v26 + *(float *)v27.i32;
  v21.f32[1] = *(float *)&v26 + *(float *)v27.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v28, v24, v23, v25, v27, v26, a2);
  v30 = vadd_f32(vmul_laneq_f32((float32x2_t)1065353216, (float32x4_t)a2, 3), v5);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v30, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 24);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v34) = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v30, 1), *(float *)v33.i32, v30.f32[0]);
  v36 = (float64x2_t)v41;
  v42 = vaddq_f32(v41, vmulq_n_f32(v29, *(float *)a2.i32));
  v29.f32[0] = *(float *)&v32 + *(float *)&v31;
  *(float *)v36.f64 = *(float *)&v34 + *(float *)v35.i32;
  v29.f32[1] = *(float *)&v34 + *(float *)v35.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v36, v32, v31, v33, v35, v34, a2);
  *(_QWORD *)&result = vaddq_f32(v42, vmulq_lane_f32(v37, *(float32x2_t *)a2.i8, 1)).u64[0];
  return result;
}

double cikernel::_cubicDownsample2v(uint64_t a1, int8x16_t a2)
{
  float32x2_t *DC;
  float64x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  uint8x8_t v9;
  int8x16_t v10;
  double v11;
  int8x16_t v12;
  float32x4_t v13;
  float32x2_t v14;
  double v15;
  double v16;
  int8x16_t v17;
  double v18;
  uint8x8_t v19;
  int8x16_t v20;
  float32x4_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  int8x16_t v25;
  double v26;
  uint8x8_t v27;
  float64x2_t v28;
  float32x4_t v29;
  float32x2_t v30;
  double v31;
  double v32;
  int8x16_t v33;
  double v34;
  uint8x8_t v35;
  float64x2_t v36;
  float32x4_t v37;
  double result;
  float32x2_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  HIDWORD(v4.f64[0]) = 0x40000000;
  v5 = vmul_f32(*DC, (float32x2_t)0x400000003F800000);
  v39 = vneg_f32((float32x2_t)vrev64_s32((int32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL)));
  v6 = vadd_f32(vmul_n_f32((float32x2_t)0x3F80000000000000, v39.f32[0]), v5);
  *(float *)&v7 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v6, 1), *(float *)(a1 + 16), v6.f32[0]);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  v9.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v10.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v6, 1), *(float *)&v8, v6.f32[0]);
  v6.f32[0] = *(float *)(a1 + 24) + *(float *)&v7;
  *(float *)v4.f64 = *(float *)v9.i32 + *(float *)v10.i32;
  v6.f32[1] = *(float *)v9.i32 + *(float *)v10.i32;
  *(double *)v13.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v6, v4, v7, v8, v10, v9, v11, v12);
  v14 = vadd_f32(vmul_lane_f32((float32x2_t)0x3F80000000000000, v39, 1), v5);
  *(float *)&v15 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v14, 1), *(float *)(a1 + 16), v14.f32[0]);
  LODWORD(v16) = *(_DWORD *)(a1 + 24);
  v17.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v18) = *(_DWORD *)(a1 + 36);
  *(float *)v19.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v14, 1), *(float *)v17.i32, v14.f32[0]);
  v40 = vaddq_f32(vmulq_lane_f32(v13, *(float32x2_t *)a2.i8, 1), (float32x4_t)0);
  v13.f32[0] = *(float *)&v16 + *(float *)&v15;
  v13.f32[1] = *(float *)&v18 + *(float *)v19.i32;
  *(double *)v21.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v13.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)&v18 + *(float *)v19.i32), v16, v15, v17, v19, v18, v20);
  v22 = vadd_f32(vmul_laneq_f32((float32x2_t)0x3F80000000000000, (float32x4_t)a2, 2), v5);
  *(float *)&v23 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v22, 1), *(float *)(a1 + 16), v22.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 24);
  v25.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v26) = *(_DWORD *)(a1 + 36);
  *(float *)v27.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v22, 1), *(float *)v25.i32, v22.f32[0]);
  v28 = (float64x2_t)v40;
  v41 = vaddq_f32(v40, vmulq_n_f32(v21, *(float *)a2.i32));
  v21.f32[0] = *(float *)&v24 + *(float *)&v23;
  *(float *)v28.f64 = *(float *)&v26 + *(float *)v27.i32;
  v21.f32[1] = *(float *)&v26 + *(float *)v27.i32;
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v21.i64, v28, v24, v23, v25, v27, v26, a2);
  v30 = vadd_f32(vmul_laneq_f32((float32x2_t)0x3F80000000000000, (float32x4_t)a2, 3), v5);
  *(float *)&v31 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v30, 1), *(float *)(a1 + 16), v30.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 24);
  v33.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v34) = *(_DWORD *)(a1 + 36);
  *(float *)v35.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v30, 1), *(float *)v33.i32, v30.f32[0]);
  v36 = (float64x2_t)v41;
  v42 = vaddq_f32(v41, vmulq_n_f32(v29, *(float *)a2.i32));
  v29.f32[0] = *(float *)&v32 + *(float *)&v31;
  *(float *)v36.f64 = *(float *)&v34 + *(float *)v35.i32;
  v29.f32[1] = *(float *)&v34 + *(float *)v35.i32;
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v36, v32, v31, v33, v35, v34, a2);
  *(_QWORD *)&result = vaddq_f32(v42, vmulq_lane_f32(v37, *(float32x2_t *)a2.i8, 1)).u64[0];
  return result;
}

double cikernel::_cubicDownsampleH(uint64_t a1, __n128 a2, int8x16_t a3, int8x16_t a4)
{
  float32x4_t v5;
  double v6;
  int8x16_t v7;
  int8x16_t v13;
  float v14;
  float32x4_t v15;
  float v16;
  float32x2_t v17;
  int8x16_t v18;
  float v19;
  float32x4_t v21;
  double v22;
  int8x16_t v23;
  float64x2_t v24;
  float v25;
  float32x4_t v26;
  double result;
  unsigned int v28;
  float v31;
  int8x16_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v36;

  v5.i64[0] = *(_QWORD *)CI::getDC((CI *)a1);
  __asm { FMOV            V2.2D, #0.5 }
  *(float32x2_t *)v13.i8 = vcvt_f32_f64(vaddq_f64(vrndmq_f64(vaddq_f64(vcvtq_f64_f32(vmul_n_f32(vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.f32, 0), (float32x2_t)0x40000000C0000000), a2.n128_f32[0])), (float64x2_t)xmmword_192498230)), _Q2));
  v14 = *(float *)&v13.i32[1];
  if (*(float *)v13.i32 <= *(float *)&v13.i32[1])
  {
    v16 = a2.n128_f32[2];
    v17 = vmul_f32((float32x2_t)a2.n128_u64[0], *(float32x2_t *)v5.f32);
    v18 = v13;
    v18.i32[1] = v17.i32[1];
    *(float32x2_t *)v5.f32 = vsub_f32(*(float32x2_t *)v13.i8, v17);
    v19 = a2.n128_f32[2] * v5.f32[0];
    v15 = 0uLL;
    v5.i32[0] = 0;
    __asm { FMOV            V2.4S, #1.0 }
    v28 = HIDWORD(_Q2);
    do
    {
      v32 = v18;
      v33 = v5;
      v34 = v15;
      v36 = v13;
      v5.f32[0] = fabsf(v19);
      v21.f32[0] = (float)(v19 * v19) * v5.f32[0];
      v21.f32[1] = v19 * v19;
      v21.i64[1] = __PAIR64__(v28, v5.u32[0]);
      v15.i32[0] = 1.0;
      HIDWORD(v22) = a3.i32[1];
      v23 = (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v15, v5), 0), a3, a4), v21);
      v24 = (float64x2_t)vextq_s8(v23, v23, 8uLL);
      *(float32x2_t *)&v24.f64[0] = vadd_f32(*(float32x2_t *)v23.i8, *(float32x2_t *)&v24.f64[0]);
      *(float *)v23.i32 = *(float *)(a1 + 24)
                        + (float)(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v18.i8, 1)
                                + (float)(*(float *)v13.i32 * *(float *)(a1 + 16)));
      v13.i32[0] = *(_DWORD *)(a1 + 36);
      *(float *)&v22 = vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v18.i8, 1)
                     + (float)(*(float *)v36.i32 * *(float *)(a1 + 28));
      *(float32x2_t *)v21.f32 = vadd_f32(*(float32x2_t *)&v24.f64[0], (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v24.f64[0], 1));
      v31 = v21.f32[0];
      v25 = vaddv_f32(*(float32x2_t *)&v24.f64[0]);
      *(float *)v24.f64 = *(float *)v13.i32 + *(float *)&v22;
      *(float *)&v23.i32[1] = *(float *)v13.i32 + *(float *)&v22;
      *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v23.i64, v24, v22, *(double *)v21.i64, v13, *(uint8x8_t *)v36.i8, v6, v7);
      v18 = v32;
      v13 = v36;
      v15 = vaddq_f32(v34, vmulq_n_f32(v26, v31));
      v5 = v33;
      v5.f32[0] = v33.f32[0] + v25;
      v19 = v16 + v19;
      *(float *)v13.i32 = *(float *)v36.i32 + 1.0;
      *(float *)v18.i32 = *(float *)v36.i32 + 1.0;
    }
    while ((float)(*(float *)v36.i32 + 1.0) <= v14);
  }
  else
  {
    v5.i32[0] = 0;
    v15 = 0uLL;
  }
  *(_QWORD *)&result = vdivq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 0)).u64[0];
  return result;
}

double cikernel::_cubicDownsampleV(uint64_t a1, __n128 a2, int8x16_t a3, int8x16_t a4)
{
  float32x4_t v5;
  int8x16_t v6;
  double v7;
  int8x16_t v8;
  float32x4_t v14;
  float v15;
  float32x4_t v16;
  float v17;
  int32x2_t v18;
  float v19;
  float32x4_t v21;
  double v22;
  int8x16_t v23;
  float64x2_t v24;
  float v25;
  float32x4_t v26;
  double result;
  unsigned int v28;
  float v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  int8x16_t v36;

  v5.i64[0] = *(_QWORD *)CI::getDC((CI *)a1);
  __asm { FMOV            V2.2D, #0.5 }
  v14 = (float32x4_t)vaddq_f64(vrndmq_f64(vaddq_f64(vcvtq_f64_f32(vmul_lane_f32(vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.f32, 1), (float32x2_t)0x40000000C0000000), (float32x2_t)a2.n128_u64[0], 1)), (float64x2_t)xmmword_192498230)), _Q2);
  *(float32x2_t *)v14.f32 = vcvt_f32_f64((float64x2_t)v14);
  v15 = v14.f32[1];
  if (v14.f32[0] <= v14.f32[1])
  {
    v17 = a2.n128_f32[3];
    v18 = (int32x2_t)vmul_f32((float32x2_t)a2.n128_u64[0], *(float32x2_t *)v5.f32);
    *(int32x2_t *)v6.i8 = vzip1_s32(v18, *(int32x2_t *)v14.f32);
    *(float32x2_t *)v5.f32 = vsub_f32(*(float32x2_t *)v14.f32, (float32x2_t)vdup_lane_s32(v18, 1));
    v19 = a2.n128_f32[3] * v5.f32[0];
    v16 = 0uLL;
    v5.i32[0] = 0;
    __asm { FMOV            V3.4S, #1.0 }
    v28 = HIDWORD(_Q3);
    do
    {
      v36 = v6;
      v32 = v5;
      v33 = v16;
      v34 = v14;
      v5.f32[0] = fabsf(v19);
      v21.f32[0] = (float)(v19 * v19) * v5.f32[0];
      v21.f32[1] = v19 * v19;
      v21.i64[1] = __PAIR64__(v28, v5.u32[0]);
      v14.i32[0] = 1.0;
      HIDWORD(v22) = a3.i32[1];
      v23 = (int8x16_t)vmulq_f32((float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v14, v5), 0), a3, a4), v21);
      v24 = (float64x2_t)vextq_s8(v23, v23, 8uLL);
      *(float32x2_t *)&v24.f64[0] = vadd_f32(*(float32x2_t *)v23.i8, *(float32x2_t *)&v24.f64[0]);
      *(float *)v23.i32 = *(float *)(a1 + 24)
                        + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v6.i8, 1), *(float *)(a1 + 16), *(float *)v6.i32);
      v6.i32[0] = *(_DWORD *)(a1 + 36);
      *(float *)&v22 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v36.i8, 1), *(float *)(a1 + 28), *(float *)v36.i32);
      *(float32x2_t *)v21.f32 = vadd_f32(*(float32x2_t *)&v24.f64[0], (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v24.f64[0], 1));
      v31 = v21.f32[0];
      v25 = vaddv_f32(*(float32x2_t *)&v24.f64[0]);
      *(float *)v24.f64 = *(float *)v6.i32 + *(float *)&v22;
      *(float *)&v23.i32[1] = *(float *)v6.i32 + *(float *)&v22;
      *(double *)v26.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v23.i64, v24, v22, *(double *)v21.i64, v6, *(uint8x8_t *)v36.i8, v7, v8);
      v14 = v34;
      v6 = v36;
      v16 = vaddq_f32(v33, vmulq_n_f32(v26, v31));
      v5 = v32;
      v5.f32[0] = v32.f32[0] + v25;
      v19 = v17 + v19;
      v14.f32[0] = v34.f32[0] + 1.0;
      *(float *)&v6.i32[1] = v34.f32[0] + 1.0;
    }
    while ((float)(v34.f32[0] + 1.0) <= v15);
  }
  else
  {
    v5.i32[0] = 0;
    v16 = 0uLL;
  }
  *(_QWORD *)&result = vdivq_f32(v16, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 0)).u64[0];
  return result;
}

double cikernel::_cubicUpsample10(uint64_t a1, float32x2_t a2)
{
  float32x2_t v3;
  float32x2_t v4;
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  int8x16_t v13;
  float32x2_t v14;
  int8x16_t v15;
  int8x16_t v16;
  float32x2_t v18;
  float64x2_t v20;
  int8x16_t v21;
  float32x4_t v22;
  float64x2_t v23;
  double v24;
  double v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  int8x16_t v29;
  double v30;
  uint8x8_t v31;
  int8x16_t v32;
  float64x2_t v33;
  float32x4_t v34;
  double v35;
  double v36;
  uint8x8_t v37;
  int8x16_t v38;
  float64x2_t v39;
  int8x16_t v40;
  float32x4_t v41;
  double result;
  float v43;
  float64x2_t v44;
  float32x4_t v45;
  int8x16_t v46;
  float32x4_t v47;
  int8x16_t v48;
  double v49;
  float32x4_t v50;
  float32x2_t v51;

  v3 = vadd_f32(vmul_f32(a2, *(float32x2_t *)CI::getDC((CI *)a1)), (float32x2_t)0xBF000000BF000000);
  v4 = vrndm_f32(v3);
  __asm { FMOV            V4.2S, #1.0 }
  v10 = vadd_f32(vsub_f32(v4, v3), _D4);
  v11 = vsub_f32(v3, v4);
  v12 = vmul_f32(v10, (float32x2_t)0x3F0000003F000000);
  *(float32x2_t *)v13.i8 = vmul_f32(v10, v12);
  v14 = (float32x2_t)vdup_n_s32(0x3E2AAAABu);
  *(float32x2_t *)v15.i8 = vadd_f32(vadd_f32(v12, vadd_f32(*(float32x2_t *)v13.i8, vmul_f32(v10, vmul_f32(v10, vmul_f32(v10, (float32x2_t)vdup_n_s32(0xBEAAAAAB)))))), v14);
  v51 = vsub_f32(_D4, *(float32x2_t *)v15.i8);
  *(float32x2_t *)v16.i8 = vadd_f32(vadd_f32(v4, vdiv_f32(vadd_f32(vadd_f32(v12, vsub_f32(*(float32x2_t *)v13.i8, vmul_f32(v10, *(float32x2_t *)v13.i8))), v14), *(float32x2_t *)v15.i8)), (float32x2_t)0xBF000000BF000000);
  __asm { FMOV            V1.2S, #6.0 }
  v18 = vadd_f32(v4, vdiv_f32(vdiv_f32(vmul_f32(v11, vmul_f32(v11, v11)), _D1), v51));
  __asm { FMOV            V1.2S, #1.5 }
  *(float32x2_t *)&v20.f64[0] = vadd_f32(v18, *(float32x2_t *)&_Q1.f64[0]);
  v48 = v15;
  v49 = v20.f64[0];
  *(float *)v20.f64 = vmuls_lane_f32(*(float *)v15.i32, *(float32x2_t *)v15.i8, 1);
  v44 = v20;
  v46 = v16;
  v21 = v16;
  v4.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v20.f64 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v16.i8, 1), *(float *)(a1 + 16), *(float *)v16.i32);
  v16.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)_Q1.f64 = *(float *)v16.i32
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v21.i8, 1), v4.f32[0], *(float *)v21.i32);
  HIDWORD(v20.f64[0]) = LODWORD(_Q1.f64[0]);
  *(double *)v22.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v20.f64[0], _Q1, *(double *)&v4, *(double *)v16.i64, v21, *(uint8x8_t *)v15.i8, *(double *)&v12, v13);
  v23 = v44;
  v45 = vmulq_n_f32(v22, *(float *)v44.f64);
  v22.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v46.i8, 1), *(float *)(a1 + 16), *(float *)&v49);
  LODWORD(v24) = *(_DWORD *)(a1 + 36);
  HIDWORD(v25) = v51.i32[1];
  *(float *)&v25 = vmuls_lane_f32(v51.f32[0], *(float32x2_t *)v48.i8, 1);
  v43 = *(float *)&v25;
  *(float *)v23.f64 = *(float *)&v24
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v46.i8, 1), *(float *)(a1 + 28), *(float *)&v49);
  v22.i32[1] = LODWORD(v23.f64[0]);
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v22.i64, v23, v25, v24, v48, *(uint8x8_t *)v46.i8, v26, v27);
  v29 = v46;
  *(float *)&v30 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v49, 1), *(float *)(a1 + 16), *(float *)v46.i32);
  v31.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v49, 1), *(float *)(a1 + 28), *(float *)v46.i32);
  v47 = vaddq_f32(v45, vmulq_n_f32(v28, v43));
  v28.f32[0] = *(float *)(a1 + 24) + *(float *)&v30;
  *(float *)v33.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v28.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v34.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v33, v30, *(double *)v48.i64, v32, v31, v49, v29);
  v35 = v49;
  *(float *)&v36 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v49, 1), *(float *)(a1 + 16), *(float *)&v49);
  v37.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v38.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v49, 1), *(float *)(a1 + 28), *(float *)&v49);
  v50 = vaddq_f32(v47, vmulq_n_f32(v34, vmuls_lane_f32(*(float *)v48.i32, v51, 1)));
  v34.f32[0] = *(float *)(a1 + 24) + *(float *)&v36;
  *(float *)v39.f64 = *(float *)v37.i32 + *(float *)v38.i32;
  v34.f32[1] = *(float *)v37.i32 + *(float *)v38.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v34.i64, v39, v36, *(double *)v47.i64, v38, v37, v35, v40);
  *(_QWORD *)&result = vaddq_f32(v50, vmulq_n_f32(v41, vmuls_lane_f32(v51.f32[0], v51, 1))).u64[0];
  return result;
}

double cikernel::_cubicUpsampleX0(uint64_t a1, float32x2_t a2, int32x4_t a3, int32x4_t a4)
{
  float32x2_t v5;
  float32x2_t v6;
  float32x2_t v7;
  float32x2_t v13;
  int8x16_t v14;
  float32x2_t v15;
  int8x16_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v22;
  int8x8_t v23;
  int8x16_t v24;
  int8x8_t v25;
  float64x2_t v26;
  float64x2_t v27;
  int8x16_t v28;
  float32x4_t v29;
  float64x2_t v30;
  double v31;
  double v32;
  double v33;
  int8x16_t v34;
  float32x4_t v35;
  int8x16_t v36;
  double v37;
  uint8x8_t v38;
  int8x16_t v39;
  float64x2_t v40;
  float32x4_t v41;
  double v42;
  double v43;
  uint8x8_t v44;
  int8x16_t v45;
  float64x2_t v46;
  int8x16_t v47;
  float32x4_t v48;
  double result;
  float v50;
  float64x2_t v51;
  float32x4_t v52;
  int8x16_t v53;
  float32x4_t v54;
  int8x16_t v55;
  float32x4_t v57;

  v5 = vmul_f32(a2, *(float32x2_t *)CI::getDC((CI *)a1));
  v6 = vadd_f32(vrndm_f32(vadd_f32(v5, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000);
  v7 = vsub_f32(v6, v5);
  __asm { FMOV            V3.2S, #-1.0 }
  v13 = vabs_f32(vadd_f32(v7, _D3));
  v14.i64[1] = a4.i64[1];
  v15 = (float32x2_t)vdup_laneq_s32(a4, 3);
  v16.i64[1] = a4.i64[1];
  v17 = vabd_f32(v6, v5);
  v18 = vadd_f32((float32x2_t)vdup_laneq_s32(a3, 3), vadd_f32(vmul_laneq_f32(v17, (float32x4_t)a3, 2), vadd_f32(vmul_f32(vmul_lane_f32(v17, *(float32x2_t *)a3.i8, 1), v17), vmul_f32(vmul_f32(vmul_n_f32(v17, *(float *)a3.i32), v17), v17))));
  v19 = vabs_f32(vadd_f32(v7, (float32x2_t)0x4000000040000000));
  v20 = vadd_f32(v15, vadd_f32(vmul_laneq_f32(v19, (float32x4_t)a4, 2), vadd_f32(vmul_f32(vmul_lane_f32(v19, *(float32x2_t *)a4.i8, 1), v19), vmul_f32(vmul_f32(vmul_n_f32(v19, *(float *)a4.i32), v19), v19))));
  *(float32x2_t *)v16.i8 = vadd_f32(v18, vadd_f32(v15, vadd_f32(vmul_laneq_f32(v13, (float32x4_t)a4, 2), vadd_f32(vmul_f32(vmul_lane_f32(v13, *(float32x2_t *)a4.i8, 1), v13), vmul_f32(vmul_f32(vmul_n_f32(v13, *(float *)a4.i32), v13), v13)))));
  __asm { FMOV            V4.2S, #1.0 }
  *(float32x2_t *)v14.i8 = vsub_f32(_D4, *(float32x2_t *)v16.i8);
  v22 = (float32x2_t)vdup_n_s32(0xB8D1B717);
  v55 = v16;
  v23 = (int8x8_t)vcltz_f32(vadd_f32(*(float32x2_t *)v16.i8, v22));
  *(float32x2_t *)v24.i8 = vadd_f32(vadd_f32(v6, _D3), (float32x2_t)vbic_s8((int8x8_t)vdiv_f32(v18, *(float32x2_t *)v16.i8), v23));
  a3.i64[0] = v14.i64[0];
  v25 = (int8x8_t)vdiv_f32(v20, *(float32x2_t *)v14.i8);
  *(float32x2_t *)&v26.f64[0] = vadd_f32(v6, _D4);
  *(float32x2_t *)&v27.f64[0] = vadd_f32(*(float32x2_t *)&v26.f64[0], (float32x2_t)vbic_s8(v25, (int8x8_t)vcltz_f32(vadd_f32(*(float32x2_t *)v14.i8, v22))));
  a4.i64[0] = *(_QWORD *)&v27.f64[0];
  *(float *)v27.f64 = vmuls_lane_f32(*(float *)v16.i32, *(float32x2_t *)v16.i8, 1);
  v51 = v27;
  v53 = v24;
  v28 = v24;
  v25.i32[0] = *(_DWORD *)(a1 + 28);
  *(float *)v27.f64 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v24.i8, 1), *(float *)(a1 + 16), *(float *)v24.i32);
  v24.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v26.f64 = *(float *)v24.i32
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v28.i8, 1), *(float *)v25.i32, *(float *)v28.i32);
  HIDWORD(v27.f64[0]) = LODWORD(v26.f64[0]);
  *(double *)v29.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), v27.f64[0], v26, *(double *)&v25, *(double *)v24.i64, v28, (uint8x8_t)v22, *(double *)&v23, v14);
  v30 = v51;
  v52 = vmulq_n_f32(v29, *(float *)v51.f64);
  v29.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v53.i8, 1), *(float *)(a1 + 16), *(float *)a4.i32);
  LODWORD(v31) = *(_DWORD *)(a1 + 36);
  HIDWORD(v32) = a3.i32[1];
  *(float *)&v32 = vmuls_lane_f32(*(float *)a3.i32, *(float32x2_t *)v55.i8, 1);
  v50 = *(float *)&v32;
  *(float *)v30.f64 = *(float *)&v31
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v53.i8, 1), *(float *)(a1 + 28), *(float *)a4.i32);
  v29.i32[1] = LODWORD(v30.f64[0]);
  *(double *)v35.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v29.i64, v30, v32, v31, v55, *(uint8x8_t *)v53.i8, v33, v34);
  v36 = v53;
  *(float *)&v37 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)a4.i8, 1), *(float *)(a1 + 16), *(float *)v53.i32);
  v38.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v39.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)a4.i8, 1), *(float *)(a1 + 28), *(float *)v53.i32);
  v54 = vaddq_f32(v52, vmulq_n_f32(v35, v50));
  v35.f32[0] = *(float *)(a1 + 24) + *(float *)&v37;
  *(float *)v40.f64 = *(float *)v38.i32 + *(float *)v39.i32;
  v35.f32[1] = *(float *)v38.i32 + *(float *)v39.i32;
  *(double *)v41.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v35.i64, v40, v37, *(double *)v55.i64, v39, v38, *(double *)a4.i64, v36);
  v42 = *(double *)a4.i64;
  *(float *)&v43 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)a4.i8, 1), *(float *)(a1 + 16), *(float *)a4.i32);
  v44.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v45.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)a4.i8, 1), *(float *)(a1 + 28), *(float *)a4.i32);
  v57 = vaddq_f32(v54, vmulq_n_f32(v41, vmuls_lane_f32(*(float *)v55.i32, *(float32x2_t *)a3.i8, 1)));
  v41.f32[0] = *(float *)(a1 + 24) + *(float *)&v43;
  *(float *)v46.f64 = *(float *)v44.i32 + *(float *)v45.i32;
  v41.f32[1] = *(float *)v44.i32 + *(float *)v45.i32;
  *(double *)v48.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v41.i64, v46, v43, *(double *)v54.i64, v45, v44, v42, v47);
  *(_QWORD *)&result = vaddq_f32(v57, vmulq_n_f32(v48, vmuls_lane_f32(*(float *)a3.i32, *(float32x2_t *)a3.i8, 1))).u64[0];
  return result;
}

double cikernel::_cubicUpsample(uint64_t a1, float32x2_t a2, float32x4_t a3, int32x4_t a4)
{
  float32x2_t v5;
  float32x2_t v7;
  int8x16_t v8;
  float32x2_t v13;
  int8x16_t v14;
  float32x2_t v15;
  int8x16_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v20;
  float32x2_t v21;
  float64x2_t v22;
  float32x4_t v23;
  double v24;
  float32x2_t v25;
  double v26;
  int8x16_t v27;
  double v28;
  uint8x8_t v29;
  int8x16_t v30;
  float32x4_t v31;
  double v32;
  float32x2_t v33;
  double v34;
  int8x16_t v35;
  double v36;
  uint8x8_t v37;
  float64x2_t v38;
  int8x16_t v39;
  float32x4_t v40;
  double v41;
  float32x2_t v42;
  double v43;
  int8x16_t v44;
  double v45;
  uint8x8_t v46;
  float64x2_t v47;
  int8x16_t v48;
  float32x4_t v49;
  double v50;
  float32x2_t v51;
  double v52;
  int8x16_t v53;
  double v54;
  uint8x8_t v55;
  float64x2_t v56;
  int8x16_t v57;
  float32x4_t v58;
  float64x2_t v59;
  double v60;
  double v61;
  uint8x8_t v62;
  double v63;
  int8x16_t v64;
  float32x4_t v65;
  double v66;
  float32x2_t v67;
  double v68;
  int8x16_t v69;
  double v70;
  uint8x8_t v71;
  float64x2_t v72;
  int8x16_t v73;
  float32x4_t v74;
  double v75;
  float32x2_t v76;
  double v77;
  int8x16_t v78;
  double v79;
  uint8x8_t v80;
  float64x2_t v81;
  int8x16_t v82;
  float32x4_t v83;
  double v84;
  float32x2_t v85;
  double v86;
  int8x16_t v87;
  double v88;
  uint8x8_t v89;
  float64x2_t v90;
  int8x16_t v91;
  float32x4_t v92;
  double v93;
  float32x2_t v94;
  double v95;
  int8x16_t v96;
  double v97;
  uint8x8_t v98;
  float64x2_t v99;
  int8x16_t v100;
  float32x4_t v101;
  float32x2_t v102;
  double v103;
  double v104;
  int8x16_t v105;
  double v106;
  uint8x8_t v107;
  float64x2_t v108;
  int8x16_t v109;
  float32x4_t v110;
  double v111;
  float32x2_t v112;
  double v113;
  int8x16_t v114;
  double v115;
  uint8x8_t v116;
  float64x2_t v117;
  int8x16_t v118;
  float32x4_t v119;
  double v120;
  float32x2_t v121;
  double v122;
  int8x16_t v123;
  double v124;
  uint8x8_t v125;
  float64x2_t v126;
  int8x16_t v127;
  float32x4_t v128;
  double v129;
  float32x2_t v130;
  double v131;
  int8x16_t v132;
  double v133;
  uint8x8_t v134;
  float64x2_t v135;
  int8x16_t v136;
  float32x4_t v137;
  double v138;
  float32x2_t v139;
  double v140;
  int8x16_t v141;
  double v142;
  uint8x8_t v143;
  float64x2_t v144;
  int8x16_t v145;
  float32x4_t v146;
  double v147;
  float32x2_t v148;
  double v149;
  int8x16_t v150;
  double v151;
  uint8x8_t v152;
  float64x2_t v153;
  int8x16_t v154;
  float32x4_t v155;
  double result;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x2_t v169;
  float32x2_t v170;
  float32x4_t v172;
  float32x4_t v173;
  int8x16_t v175;
  float32x4_t v176;

  v5 = vmul_f32(a2, *(float32x2_t *)CI::getDC((CI *)a1));
  *(float32x2_t *)_Q2.i8 = vadd_f32(vrndm_f32(vadd_f32(v5, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000);
  v7 = vsub_f32(*(float32x2_t *)_Q2.i8, v5);
  v8 = _Q2;
  __asm { FMOV            V2.2S, #-1.0 }
  v13 = vabs_f32(vadd_f32(v7, *(float32x2_t *)_Q2.i8));
  v14 = (int8x16_t)a4;
  *(float32x2_t *)a4.i8 = vadd_f32((float32x2_t)vdup_laneq_s32(a4, 3), vadd_f32(vmul_laneq_f32(v13, (float32x4_t)a4, 2), vadd_f32(vmul_f32(vmul_lane_f32(v13, *(float32x2_t *)a4.i8, 1), v13), vmul_f32(vmul_f32(vmul_n_f32(v13, *(float *)a4.i32), v13), v13))));
  v15 = vabd_f32(*(float32x2_t *)v8.i8, v5);
  v175 = v8;
  *(float32x2_t *)v16.i8 = vmul_f32(vmul_lane_f32(v15, *(float32x2_t *)a3.f32, 1), v15);
  v17 = vadd_f32(*(float32x2_t *)v16.i8, vmul_f32(vmul_f32(vmul_n_f32(v15, a3.f32[0]), v15), v15));
  v18 = vadd_f32(vmul_laneq_f32(v15, a3, 2), v17);
  __asm { FMOV            V8.2S, #1.0 }
  v20 = vabs_f32(vadd_f32(v7, _D8));
  *(float32x2_t *)_Q2.i8 = vadd_f32(*(float32x2_t *)v8.i8, *(float32x2_t *)_Q2.i8);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)_Q2.i8, 1), *(float *)(a1 + 16), *(float *)_Q2.i32);
  v17.i32[0] = *(_DWORD *)(a1 + 24);
  v14.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)_Q2.i8, 1), *(float *)(a1 + 28), *(float *)_Q2.i32);
  v21 = vmul_f32(vmul_lane_f32(v20, *(float32x2_t *)a3.f32, 1), v20);
  *(int32x2_t *)_Q2.i8 = vdup_laneq_s32((int32x4_t)a3, 3);
  *(float32x2_t *)&v22.f64[0] = vadd_f32(*(float32x2_t *)_Q2.i8, vadd_f32(vmul_laneq_f32(v20, a3, 2), vadd_f32(v21, vmul_f32(vmul_f32(vmul_n_f32(v20, a3.f32[0]), v20), v20))));
  v169 = vadd_f32(*(float32x2_t *)_Q2.i8, v18);
  v170 = *(float32x2_t *)&v22.f64[0];
  *(float32x2_t *)a3.f32 = vsub_f32(_D8, vadd_f32(*(float32x2_t *)&v22.f64[0], vadd_f32(v169, *(float32x2_t *)a4.i8)));
  v18.f32[0] = v17.f32[0] + *(float *)v16.i32;
  *(float *)v22.f64 = *(float *)v14.i32 + *(float *)v8.i32;
  v18.f32[1] = *(float *)v14.i32 + *(float *)v8.i32;
  *(double *)v23.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v18, v22, *(double *)_Q2.i64, *(double *)&v17, v16, (uint8x8_t)v21, *(double *)v8.i64, v14);
  HIDWORD(v24) = v175.i32[1];
  v25 = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)0xBF80000000000000);
  *(float *)&v26 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v25, 1), *(float *)(a1 + 16), v25.f32[0]);
  LODWORD(v24) = *(_DWORD *)(a1 + 24);
  v27.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v28) = *(_DWORD *)(a1 + 36);
  *(float *)v29.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v25, 1), *(float *)v27.i32, v25.f32[0]);
  v157 = vaddq_f32(vmulq_lane_f32(vmulq_n_f32(v23, *(float *)a4.i32), *(float32x2_t *)a4.i8, 1), (float32x4_t)0);
  v23.f32[0] = *(float *)&v24 + *(float *)&v26;
  v23.f32[1] = *(float *)&v28 + *(float *)v29.i32;
  *(double *)v31.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v23.i64, (float64x2_t)COERCE_UNSIGNED_INT(*(float *)&v28 + *(float *)v29.i32), v24, v26, v27, v29, v28, v30);
  HIDWORD(v32) = v175.i32[1];
  v33 = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)0xBF8000003F800000);
  *(float *)&v34 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v33, 1), *(float *)(a1 + 16), v33.f32[0]);
  LODWORD(v32) = *(_DWORD *)(a1 + 24);
  v35.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v36) = *(_DWORD *)(a1 + 36);
  *(float *)v37.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v33, 1), *(float *)v35.i32, v33.f32[0]);
  v38 = (float64x2_t)v157;
  v158 = vaddq_f32(vmulq_lane_f32(vmulq_n_f32(v31, v169.f32[0]), *(float32x2_t *)a4.i8, 1), v157);
  v31.f32[0] = *(float *)&v32 + *(float *)&v34;
  *(float *)v38.f64 = *(float *)&v36 + *(float *)v37.i32;
  v31.f32[1] = *(float *)&v36 + *(float *)v37.i32;
  *(double *)v40.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v31.i64, v38, v32, v34, v35, v37, v36, v39);
  HIDWORD(v41) = v175.i32[1];
  v42 = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)0xBF80000040000000);
  *(float *)&v43 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v42, 1), *(float *)(a1 + 16), v42.f32[0]);
  LODWORD(v41) = *(_DWORD *)(a1 + 24);
  v44.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v45) = *(_DWORD *)(a1 + 36);
  *(float *)v46.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v42, 1), *(float *)v44.i32, v42.f32[0]);
  v47 = (float64x2_t)v158;
  v159 = vaddq_f32(v158, vmulq_lane_f32(vmulq_n_f32(v40, v170.f32[0]), *(float32x2_t *)a4.i8, 1));
  v40.f32[0] = *(float *)&v41 + *(float *)&v43;
  *(float *)v47.f64 = *(float *)&v45 + *(float *)v46.i32;
  v40.f32[1] = *(float *)&v45 + *(float *)v46.i32;
  *(double *)v49.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v40.i64, v47, v41, v43, v44, v46, v45, v48);
  HIDWORD(v50) = v175.i32[1];
  v51 = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)3212836864);
  *(float *)&v52 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v51, 1), *(float *)(a1 + 16), v51.f32[0]);
  LODWORD(v50) = *(_DWORD *)(a1 + 24);
  v53.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v54) = *(_DWORD *)(a1 + 36);
  *(float *)v55.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v51, 1), *(float *)v53.i32, v51.f32[0]);
  v56 = (float64x2_t)v159;
  v160 = vaddq_f32(v159, vmulq_lane_f32(vmulq_n_f32(v49, a3.f32[0]), *(float32x2_t *)a4.i8, 1));
  v49.f32[0] = *(float *)&v50 + *(float *)&v52;
  *(float *)v56.f64 = *(float *)&v54 + *(float *)v55.i32;
  v49.f32[1] = *(float *)&v54 + *(float *)v55.i32;
  *(double *)v58.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v49.i64, v56, v50, v52, v53, v55, v54, v57);
  v59 = (float64x2_t)v160;
  v161 = vaddq_f32(v160, vmulq_lane_f32(vmulq_n_f32(v58, *(float *)a4.i32), v169, 1));
  LODWORD(v60) = *(_DWORD *)(a1 + 28);
  v58.f32[0] = *(float *)(a1 + 24)
             + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v175.i8, 1), *(float *)(a1 + 16), *(float *)v175.i32);
  LODWORD(v61) = *(_DWORD *)(a1 + 36);
  *(float *)v59.f64 = *(float *)&v61
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v175.i8, 1), *(float *)&v60, *(float *)v175.i32);
  v58.i32[1] = LODWORD(v59.f64[0]);
  *(double *)v65.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v58.i64, v59, v60, v61, v175, v62, v63, v64);
  HIDWORD(v66) = v175.i32[1];
  v67 = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)1065353216);
  *(float *)&v68 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v67, 1), *(float *)(a1 + 16), v67.f32[0]);
  LODWORD(v66) = *(_DWORD *)(a1 + 24);
  v69.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v70) = *(_DWORD *)(a1 + 36);
  *(float *)v71.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v67, 1), *(float *)v69.i32, v67.f32[0]);
  v72 = (float64x2_t)v161;
  v162 = vaddq_f32(v161, vmulq_lane_f32(vmulq_n_f32(v65, v169.f32[0]), v169, 1));
  v65.f32[0] = *(float *)&v66 + *(float *)&v68;
  *(float *)v72.f64 = *(float *)&v70 + *(float *)v71.i32;
  v65.f32[1] = *(float *)&v70 + *(float *)v71.i32;
  *(double *)v74.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v65.i64, v72, v66, v68, v69, v71, v70, v73);
  HIDWORD(v75) = v175.i32[1];
  v76 = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)0x40000000);
  *(float *)&v77 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v76, 1), *(float *)(a1 + 16), v76.f32[0]);
  LODWORD(v75) = *(_DWORD *)(a1 + 24);
  v78.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v79) = *(_DWORD *)(a1 + 36);
  *(float *)v80.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v76, 1), *(float *)v78.i32, v76.f32[0]);
  v81 = (float64x2_t)v162;
  v163 = vaddq_f32(v162, vmulq_lane_f32(vmulq_n_f32(v74, v170.f32[0]), v169, 1));
  v74.f32[0] = *(float *)&v75 + *(float *)&v77;
  *(float *)v81.f64 = *(float *)&v79 + *(float *)v80.i32;
  v74.f32[1] = *(float *)&v79 + *(float *)v80.i32;
  *(double *)v83.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v74.i64, v81, v75, v77, v78, v80, v79, v82);
  HIDWORD(v84) = v175.i32[1];
  v85 = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)0x3F800000BF800000);
  *(float *)&v86 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v85, 1), *(float *)(a1 + 16), v85.f32[0]);
  LODWORD(v84) = *(_DWORD *)(a1 + 24);
  v87.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v88) = *(_DWORD *)(a1 + 36);
  *(float *)v89.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v85, 1), *(float *)v87.i32, v85.f32[0]);
  v90 = (float64x2_t)v163;
  v164 = vaddq_f32(v163, vmulq_lane_f32(vmulq_n_f32(v83, a3.f32[0]), v169, 1));
  v83.f32[0] = *(float *)&v84 + *(float *)&v86;
  *(float *)v90.f64 = *(float *)&v88 + *(float *)v89.i32;
  v83.f32[1] = *(float *)&v88 + *(float *)v89.i32;
  *(double *)v92.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v83.i64, v90, v84, v86, v87, v89, v88, v91);
  HIDWORD(v93) = v175.i32[1];
  v94 = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)0x3F80000000000000);
  *(float *)&v95 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v94, 1), *(float *)(a1 + 16), v94.f32[0]);
  LODWORD(v93) = *(_DWORD *)(a1 + 24);
  v96.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v97) = *(_DWORD *)(a1 + 36);
  *(float *)v98.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v94, 1), *(float *)v96.i32, v94.f32[0]);
  v99 = (float64x2_t)v164;
  v165 = vaddq_f32(v164, vmulq_lane_f32(vmulq_n_f32(v92, *(float *)a4.i32), v170, 1));
  v92.f32[0] = *(float *)&v93 + *(float *)&v95;
  *(float *)v99.f64 = *(float *)&v97 + *(float *)v98.i32;
  v92.f32[1] = *(float *)&v97 + *(float *)v98.i32;
  *(double *)v101.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v92.i64, v99, v93, v95, v96, v98, v97, v100);
  v102 = vadd_f32(*(float32x2_t *)v175.i8, _D8);
  *(float *)&v103 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v102, 1), *(float *)(a1 + 16), v102.f32[0]);
  LODWORD(v104) = *(_DWORD *)(a1 + 24);
  v105.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v106) = *(_DWORD *)(a1 + 36);
  *(float *)v107.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v102, 1), *(float *)v105.i32, v102.f32[0]);
  v108 = (float64x2_t)v165;
  v166 = vaddq_f32(v165, vmulq_lane_f32(vmulq_n_f32(v101, v169.f32[0]), v170, 1));
  v101.f32[0] = *(float *)&v104 + *(float *)&v103;
  *(float *)v108.f64 = *(float *)&v106 + *(float *)v107.i32;
  v101.f32[1] = *(float *)&v106 + *(float *)v107.i32;
  *(double *)v110.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v101.i64, v108, v104, v103, v105, v107, v106, v109);
  HIDWORD(v111) = v175.i32[1];
  v112 = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)0x3F80000040000000);
  *(float *)&v113 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v112, 1), *(float *)(a1 + 16), v112.f32[0]);
  LODWORD(v111) = *(_DWORD *)(a1 + 24);
  v114.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v115) = *(_DWORD *)(a1 + 36);
  *(float *)v116.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v112, 1), *(float *)v114.i32, v112.f32[0]);
  v117 = (float64x2_t)v166;
  v167 = vaddq_f32(v166, vmulq_lane_f32(vmulq_n_f32(v110, v170.f32[0]), v170, 1));
  v110.f32[0] = *(float *)&v111 + *(float *)&v113;
  *(float *)v117.f64 = *(float *)&v115 + *(float *)v116.i32;
  v110.f32[1] = *(float *)&v115 + *(float *)v116.i32;
  *(double *)v119.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v110.i64, v117, v111, v113, v114, v116, v115, v118);
  HIDWORD(v120) = v175.i32[1];
  v121 = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)0x40000000BF800000);
  *(float *)&v122 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v121, 1), *(float *)(a1 + 16), v121.f32[0]);
  LODWORD(v120) = *(_DWORD *)(a1 + 24);
  v123.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v124) = *(_DWORD *)(a1 + 36);
  *(float *)v125.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v121, 1), *(float *)v123.i32, v121.f32[0]);
  v126 = (float64x2_t)v167;
  v168 = vaddq_f32(v167, vmulq_lane_f32(vmulq_n_f32(v119, a3.f32[0]), v170, 1));
  v119.f32[0] = *(float *)&v120 + *(float *)&v122;
  *(float *)v126.f64 = *(float *)&v124 + *(float *)v125.i32;
  v119.f32[1] = *(float *)&v124 + *(float *)v125.i32;
  *(double *)v128.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v119.i64, v126, v120, v122, v123, v125, v124, v127);
  HIDWORD(v129) = v175.i32[1];
  v130 = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)0x4000000000000000);
  *(float *)&v131 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v130, 1), *(float *)(a1 + 16), v130.f32[0]);
  LODWORD(v129) = *(_DWORD *)(a1 + 24);
  v132.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v133) = *(_DWORD *)(a1 + 36);
  *(float *)v134.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v130, 1), *(float *)v132.i32, v130.f32[0]);
  v135 = (float64x2_t)v168;
  v172 = vaddq_f32(v168, vmulq_lane_f32(vmulq_n_f32(v128, *(float *)a4.i32), *(float32x2_t *)a3.f32, 1));
  v128.f32[0] = *(float *)&v129 + *(float *)&v131;
  *(float *)v135.f64 = *(float *)&v133 + *(float *)v134.i32;
  v128.f32[1] = *(float *)&v133 + *(float *)v134.i32;
  *(double *)v137.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v128.i64, v135, v129, v131, v132, v134, v133, v136);
  HIDWORD(v138) = v175.i32[1];
  v139 = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)0x400000003F800000);
  *(float *)&v140 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v139, 1), *(float *)(a1 + 16), v139.f32[0]);
  LODWORD(v138) = *(_DWORD *)(a1 + 24);
  v141.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v142) = *(_DWORD *)(a1 + 36);
  *(float *)v143.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v139, 1), *(float *)v141.i32, v139.f32[0]);
  v144 = (float64x2_t)v172;
  v173 = vaddq_f32(v172, vmulq_lane_f32(vmulq_n_f32(v137, v169.f32[0]), *(float32x2_t *)a3.f32, 1));
  v137.f32[0] = *(float *)&v138 + *(float *)&v140;
  *(float *)v144.f64 = *(float *)&v142 + *(float *)v143.i32;
  v137.f32[1] = *(float *)&v142 + *(float *)v143.i32;
  *(double *)v146.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v137.i64, v144, v138, v140, v141, v143, v142, v145);
  HIDWORD(v147) = v175.i32[1];
  v148 = vadd_f32(*(float32x2_t *)v175.i8, (float32x2_t)0x4000000040000000);
  *(float *)&v149 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v148, 1), *(float *)(a1 + 16), v148.f32[0]);
  LODWORD(v147) = *(_DWORD *)(a1 + 24);
  v150.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v151) = *(_DWORD *)(a1 + 36);
  *(float *)v152.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v148, 1), *(float *)v150.i32, v148.f32[0]);
  v153 = (float64x2_t)v173;
  v176 = vaddq_f32(v173, vmulq_lane_f32(vmulq_n_f32(v146, v170.f32[0]), *(float32x2_t *)a3.f32, 1));
  v146.f32[0] = *(float *)&v147 + *(float *)&v149;
  *(float *)v153.f64 = *(float *)&v151 + *(float *)v152.i32;
  v146.f32[1] = *(float *)&v151 + *(float *)v152.i32;
  *(double *)v155.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v146.i64, v153, v147, v149, v150, v152, v151, v154);
  *(_QWORD *)&result = vaddq_f32(v176, vmulq_lane_f32(vmulq_n_f32(v155, a3.f32[0]), *(float32x2_t *)a3.f32, 1)).u64[0];
  return result;
}

double cikernel::_cubicUpsample10v(cikernel *this, SamplerObj *a2, float a3)
{
  float32x2_t *DC;
  int8x16_t v6;
  float v7;
  float v8;
  float v9;
  float v10;
  double v11;
  double v12;
  int8x16_t v13;
  float64x2_t v14;
  int8x16_t v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  float64x2_t v21;
  float v22;
  float32x4_t v23;
  float64x2_t v24;
  double v25;
  double v26;
  uint8x8_t v27;
  double v28;
  int8x16_t v29;
  float32x4_t v30;
  double result;
  int8x16_t v32;
  float64x2_t v33;
  float32x4_t v34;
  float v35;

  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v6.i8 = *DC;
  v7 = vmuls_lane_f32(a3, *DC, 1) + -0.5;
  v8 = floorf(v7);
  v9 = (float)(v8 - v7) + 1.0;
  v10 = v7 - v8;
  v11 = v9;
  v12 = v11 * 0.5 * v11;
  v13.i64[0] = 0x3FC5555555555555;
  *(float *)v14.f64 = v12 + v11 * -0.333333333 * v11 * v11 + v11 * 0.5 + 0.166666667;
  *(double *)v15.i64 = *(float *)v14.f64;
  v33 = v14;
  v35 = 1.0 - *(float *)v14.f64;
  v16 = v12 + v11 * -0.5 * v11 * v11;
  v17 = v8;
  v18 = (v16 + v11 * 0.5 + 0.166666667) / *(float *)v14.f64 + v17 + -0.5;
  *(float *)&v18 = v18;
  v19 = (float)(1.0 - *(float *)v14.f64);
  v20 = (float)(v10 * (float)(v10 * v10)) / 6.0 / v19 + v17;
  v21.f64[0] = 1.5;
  v22 = v20 + 1.5;
  v32 = v6;
  LODWORD(v19) = *((_DWORD *)this + 7);
  *(float *)&v20 = *((float *)this + 6)
                 + vmlas_n_f32(*((float *)this + 5) * *(float *)&v18, *((float *)this + 4), COERCE_FLOAT(*DC));
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v21.f64 = *(float *)v15.i32
                    + vmlas_n_f32(*((float *)this + 8) * *(float *)&v18, *(float *)&v19, COERCE_FLOAT(*DC));
  HIDWORD(v20) = LODWORD(v21.f64[0]);
  *(double *)v23.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v20, v21, v18, v19, v15, COERCE_UINT8X8_T(0.5), v16, v13);
  v24 = v33;
  v34 = vmulq_n_f32(v23, *(float *)v33.f64);
  LODWORD(v25) = *((_DWORD *)this + 7);
  v23.f32[0] = *((float *)this + 6) + vmlas_n_f32(*((float *)this + 5) * v22, *((float *)this + 4), *(float *)v32.i32);
  LODWORD(v26) = *((_DWORD *)this + 9);
  *(float *)v24.f64 = *(float *)&v26 + vmlas_n_f32(*((float *)this + 8) * v22, *(float *)&v25, *(float *)v32.i32);
  v23.i32[1] = LODWORD(v24.f64[0]);
  *(double *)v30.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v23.i64, v24, v25, v26, v32, v27, v28, v29);
  *(_QWORD *)&result = vaddq_f32(v34, vmulq_n_f32(v30, v35)).u64[0];
  return result;
}

double cikernel::_cubicUpsample10h(cikernel *this, SamplerObj *a2, float a3)
{
  float32x2_t *DC;
  int8x16_t v6;
  float v7;
  float v8;
  float v9;
  float v10;
  double v11;
  double v12;
  int8x16_t v13;
  float64x2_t v14;
  int8x16_t v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  float64x2_t v21;
  float v22;
  float32x4_t v23;
  float64x2_t v24;
  double v25;
  double v26;
  uint8x8_t v27;
  double v28;
  int8x16_t v29;
  float32x4_t v30;
  double result;
  int8x16_t v32;
  float64x2_t v33;
  float32x4_t v34;
  float v35;

  DC = (float32x2_t *)CI::getDC(this);
  *(float32x2_t *)v6.i8 = *DC;
  v7 = (float)(a3 * COERCE_FLOAT(*DC)) + -0.5;
  v8 = floorf(v7);
  v9 = (float)(v8 - v7) + 1.0;
  v10 = v7 - v8;
  v11 = v9;
  v12 = v11 * 0.5 * v11;
  v13.i64[0] = 0x3FC5555555555555;
  *(float *)v14.f64 = v12 + v11 * -0.333333333 * v11 * v11 + v11 * 0.5 + 0.166666667;
  *(double *)v15.i64 = *(float *)v14.f64;
  v33 = v14;
  v35 = 1.0 - *(float *)v14.f64;
  v16 = v12 + v11 * -0.5 * v11 * v11;
  v17 = v8;
  v18 = (v16 + v11 * 0.5 + 0.166666667) / *(float *)v14.f64 + v17 + -0.5;
  *(float *)&v18 = v18;
  v19 = (float)(1.0 - *(float *)v14.f64);
  v20 = (float)(v10 * (float)(v10 * v10)) / 6.0 / v19 + v17;
  v21.f64[0] = 1.5;
  v22 = v20 + 1.5;
  v32 = v6;
  LODWORD(v19) = *((_DWORD *)this + 7);
  *(float *)&v20 = *((float *)this + 6)
                 + (float)(vmuls_lane_f32(*((float *)this + 5), *DC, 1) + (float)(*(float *)&v18 * *((float *)this + 4)));
  v15.i32[0] = *((_DWORD *)this + 9);
  *(float *)v21.f64 = *(float *)v15.i32
                    + (float)(vmuls_lane_f32(*((float *)this + 8), *DC, 1) + (float)(*(float *)&v18 * *(float *)&v19));
  HIDWORD(v20) = LODWORD(v21.f64[0]);
  *(double *)v23.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), v20, v21, v18, v19, v15, COERCE_UINT8X8_T(0.5), v16, v13);
  v24 = v33;
  v34 = vmulq_n_f32(v23, *(float *)v33.f64);
  LODWORD(v25) = *((_DWORD *)this + 7);
  v23.f32[0] = *((float *)this + 6)
             + (float)(vmuls_lane_f32(*((float *)this + 5), *(float32x2_t *)v32.i8, 1)
                     + (float)(v22 * *((float *)this + 4)));
  LODWORD(v26) = *((_DWORD *)this + 9);
  *(float *)v24.f64 = *(float *)&v26
                    + (float)(vmuls_lane_f32(*((float *)this + 8), *(float32x2_t *)v32.i8, 1)
                            + (float)(v22 * *(float *)&v25));
  v23.i32[1] = LODWORD(v24.f64[0]);
  *(double *)v30.i64 = CI::BitmapSampler::read(*((uint64x2_t **)this + 1), *(double *)v23.i64, v24, v25, v26, v32, v27, v28, v29);
  *(_QWORD *)&result = vaddq_f32(v34, vmulq_n_f32(v30, v35)).u64[0];
  return result;
}

double cikernel::_spotLight(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float a6)
{
  float32x4_t v6;
  float32x4_t v7;
  int8x16_t v8;
  float32x2_t v9;
  float32x4_t v10;
  float v11;
  float v12;
  BOOL v13;
  float v14;
  double result;
  float32x4_t v17;

  v6.i64[0] = *(_QWORD *)CI::getDC(a1);
  v6.i32[2] = 0;
  v7 = vsubq_f32(a3, v6);
  v7.i32[3] = 0;
  v8 = (int8x16_t)vmulq_f32(v7, v7);
  *(float32x2_t *)v8.i8 = vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL));
  v8.i32[0] = vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v8.i8, 1)).u32[0];
  v9 = vrsqrte_f32((float32x2_t)v8.u32[0]);
  v17 = vmulq_n_f32(v7, vmul_f32(v9, vrsqrts_f32((float32x2_t)v8.u32[0], vmul_f32(v9, v9))).f32[0]);
  v10 = vmulq_f32(a4, v17);
  v11 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0];
  v12 = 1.0;
  if (v11 <= 1.0)
    v12 = v11;
  v13 = v11 < 0.0;
  v14 = 0.0;
  if (!v13)
    v14 = v12;
  *(_QWORD *)&result = vmulq_f32(a2, vmulq_laneq_f32(vmulq_n_f32(a5, powf(v14, a6)), v17, 2)).u64[0];
  return result;
}

void CI::f4_s_f3_f3_f4_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, double);
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  double *v19;
  __n128 *v20;
  __n128 *v21;
  __int128 v22;
  int v23;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, double))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_QWORD *)(v9 + 32);
  v14 = *(_QWORD *)(v9 + 56);
  v15 = *(_DWORD *)(v9 + 88);
  v16 = *(_QWORD *)(v9 + 80);
  v17 = *(_DWORD *)(v9 + 112);
  v18 = *(_QWORD *)(v9 + 104);
  if (*(_BYTE *)(a1 + 64))
  {
    v23 = *(_DWORD *)(v9 + 88);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
    v15 = v23;
  }
  v19 = (double *)(a3 + 16 * v18);
  if (v17 != 5)
    v19 = (double *)((char *)a2 + 64 * v18);
  v20 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v16);
  v21 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v21 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v22 = v10(*v21, *((__n128 *)a2 + 4 * v13), *((__n128 *)a2 + 4 * v14), *v20, *v19);
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

double cikernel::_starshine(CI *a1, float32x2_t a2, int8x16_t a3, int32x4_t a4, float a5, float32x4_t a6)
{
  float32x2_t v6;
  int32x2_t v7;
  int32x2_t v8;
  float32x2_t v9;
  float v10;
  float32x2_t v11;
  float32x2_t v12;
  float v13;
  int32x2_t v14;
  float v15;
  BOOL v16;
  double result;

  v6 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v7 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v6);
  v8 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v6);
  v9 = vadd_f32((float32x2_t)vzip1_s32(v7, v8), (float32x2_t)vzip2_s32(v7, v8));
  v14 = (int32x2_t)vmul_f32(v6, v6);
  *(float *)v14.i32 = sqrtf(vaddv_f32((float32x2_t)v14));
  v10 = *(float *)a4.i32 / *(float *)v14.i32;
  v11 = vabs_f32(vdiv_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)a4.i8, 0), vmaxnm_f32(vadd_f32((float32x2_t)vdup_laneq_s32(a4, 3), vmul_n_f32(vabs_f32(v9), a5)), (float32x2_t)vdup_n_s32(0x33D6BF95u))));
  v12 = vmul_f32(vmul_f32(v11, v11), v11);
  v13 = vmuls_lane_f32(vmul_lane_f32(v12, v12, 1).f32[0], (float32x4_t)a4, 2);
  *(float *)v14.i32 = 1.0 - vmuls_lane_f32(*(float *)v14.i32, *(float32x2_t *)a4.i8, 1);
  if (*(float *)v14.i32 <= 1.0)
    v15 = *(float *)v14.i32;
  else
    v15 = 1.0;
  v16 = *(float *)v14.i32 < 0.0;
  v14.i32[0] = 0;
  if (!v16)
    *(float *)v14.i32 = v15;
  *(float *)v14.i32 = v13 * (float)(*(float *)v14.i32 * *(float *)v14.i32);
  *(_QWORD *)&result = vaddq_f32(vmulq_n_f32(a6, v10 * v10), (float32x4_t)vdupq_lane_s32(v14, 0)).u64[0];
  return result;
}

void CI::f4_f2_f4_f4_f_clr(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(double, __n128, __n128, float, __n128);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __n128 *v19;
  __n128 *v20;
  double *v21;
  __int128 v22;
  int v23;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(double, __n128, __n128, float, __n128))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_QWORD *)(v9 + 80);
  v18 = *(_QWORD *)(v9 + 104);
  if (*(_BYTE *)(a1 + 64))
  {
    v23 = *(_DWORD *)(v9 + 40);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 128)), a2);
    v13 = v23;
  }
  v19 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v16);
  v20 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v14);
  v21 = (double *)(a3 + 16 * v12);
  if (v11 != 5)
    v21 = (double *)((char *)a2 + 64 * v12);
  *(double *)&v22 = v10(*v21, *v20, *v19, *((float *)a2 + 16 * v17), *((__n128 *)a2 + 4 * v18));
  *(_OWORD *)(a3 + 16 * a7) = v22;
}

float32x2_t cikernel::_stretch(CI *a1, float32x2_t a2, float32x4_t a3)
{
  float32x2_t *DC;
  float32x2_t v9;
  float32x2_t v11;
  simd_float4 v12;
  float32x2_t v13;
  CI *v14;

  DC = (float32x2_t *)CI::getDC(a1);
  __asm { FMOV            V1.2S, #1.0 }
  v9 = vsub_f32(_D1, vminnm_f32(vmaxnm_f32(vmul_n_f32(vabd_f32(*DC, a2), a3.f32[0]), 0), _D1));
  __asm { FMOV            V2.2S, #3.0 }
  v11 = vmul_f32(v9, vmul_f32(v9, vsub_f32(_D2, vadd_f32(v9, v9))));
  *(float32x2_t *)v12.f32 = vmul_laneq_f32(vsub_f32(*(float32x2_t *)CI::getDC((CI *)DC), (float32x2_t)vdup_lane_s32((int32x2_t)a2, 1)), a3, 2);
  v13 = vmul_f32(vmul_lane_f32((float32x2_t)*(_OWORD *)&_simd_sin_f4(v12), *(float32x2_t *)a3.f32, 1), v11);
  return vsub_f32(*(float32x2_t *)CI::getDC(v14), v13);
}

void CI::f2_f2_f3(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, double, __n128);
  int v12;
  uint64_t v13;
  uint64_t v14;
  double *v15;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, double, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 56)), a2);
  v15 = (double *)(a3 + 16 * v13);
  if (v12 != 5)
    v15 = (double *)((char *)a2 + 64 * v13);
  *(double *)(a3 + 16 * a7) = v11(a1, *v15, *((__n128 *)a2 + 4 * v14));
}

void minMax(double a1, double a2, double a3, double a4, double a5, int a6, double *a7, double *a8)
{
  double v14;
  double v16;
  double v17;
  double v18;

  v14 = a2;
  if (a1 >= a3)
  {
    v16 = a4 + a5;
    if (a4 + a5 >= a1)
    {
      if (v16 >= v14)
      {
        *a7 = minForMiddleRange(a1, v14, a3, a4, a5, a6);
        v18 = a1;
        goto LABEL_13;
      }
      v17 = minForMiddleRange(a1, v16, a3, a4, a5, a6);
    }
    else
    {
      v17 = a1 - a5;
    }
    *a7 = v17;
LABEL_11:
    v14 = v14 - a5;
    goto LABEL_14;
  }
  if (a2 >= a3)
  {
    *a7 = a1;
    if (a4 + a5 >= a2)
    {
      v18 = a3;
LABEL_13:
      v14 = maxForMiddleRange(v18, v14, a3, a4, a5, a6);
      goto LABEL_14;
    }
    goto LABEL_11;
  }
  *a7 = a1;
LABEL_14:
  *a8 = v14;
}

float32x2_t cikernel::_stretchcrop(CI *a1, float32x2_t a2, float32x2_t a3, int8x16_t a4)
{
  float32x2_t v5;
  float32x2_t v7;
  float32x2_t v8;

  v7 = (float32x2_t)vextq_s8(a4, a4, 8uLL).u64[0];
  v8 = *(float32x2_t *)a4.i8;
  v5 = vdiv_f32(vsub_f32(*(float32x2_t *)CI::getDC(a1), a3), a2);
  return vmul_f32(a2, vadd_f32(vdiv_f32(v5, vadd_f32(v8, vmul_f32(v7, vabs_f32(v5)))), (float32x2_t)0x3F0000003F000000));
}

void CI::f2_f2_f2_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, double, double, __n128);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  double *v19;
  double *v20;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, double, double, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_DWORD *)(v10 + 64);
  v17 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (double *)((char *)a2 + 64 * v15);
  v20 = (double *)(a3 + 16 * v13);
  if (v12 != 5)
    v20 = (double *)((char *)a2 + 64 * v13);
  *(double *)(a3 + 16 * a7) = v11(a1, *v20, *v19, *v18);
}

float32x2_t cikernel::_ninePartStretched(CI *a1, float32x2_t a2, float32x2_t a3, float32x2_t a4)
{
  float32x2_t *DC;

  DC = (float32x2_t *)CI::getDC(a1);
  return vmaxnm_f32(vminnm_f32(*DC, vadd_f32(a2, vmul_f32(a4, vsub_f32(*DC, a2)))), vsub_f32(*DC, a3));
}

int8x8_t cikernel::_ninePartTiledAlt(CI *a1, int8x16_t a2, float32x2_t a3, float32x2_t a4)
{
  float32x2_t *DC;
  float32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;

  DC = (float32x2_t *)CI::getDC(a1);
  v7 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  v8 = vsub_f32(*DC, a4);
  v9 = vsub_f32(v7, *(float32x2_t *)a2.i8);
  return vbsl_s8((int8x8_t)vcltz_f32(vsub_f32(*DC, vadd_f32(a3, v7))), vbsl_s8((int8x8_t)vcltz_f32(vsub_f32(*DC, *(float32x2_t *)a2.i8)), (int8x8_t)*DC, (int8x8_t)vadd_f32(*(float32x2_t *)a2.i8, vsub_f32(v8, vmul_f32(v9, vrndm_f32(vdiv_f32(v8, v9)))))), (int8x8_t)vsub_f32(*DC, a3));
}

void CI::f2_f4_f2_f2(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, double, double);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  double *v18;
  double *v19;
  __n128 *v20;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, double, double))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_DWORD *)(v10 + 64);
  v17 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (double *)((char *)a2 + 64 * v17);
  v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (double *)((char *)a2 + 64 * v15);
  v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)(a3 + 16 * a7) = v11(a1, *v20, *v19, *v18);
}

double maxForMiddleRange(double a1, double a2, double a3, double a4, double a5, int a6)
{
  double v6;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;

  v6 = a4;
  v10 = a1 - a3;
  v11 = a4 - a3;
  v12 = v10 / (a4 - a3);
  v13 = a4 + a5;
  v14 = a1 - (a4 + a5);
  if (a6)
  {
    v12 = v14 / v11;
    v15 = a4 + a5;
  }
  else
  {
    v15 = a3;
  }
  if (vcvtmd_s64_f64(v12) == vcvtmd_s64_f64((a2 - v15) / v11))
  {
    if (a6)
    {
      v11 = v6 - a3;
      v16 = fmod(v14, v6 - a3) + v6;
    }
    else
    {
      v16 = fmod(v10, v11) + a3;
      v13 = a3;
      v6 = a3;
    }
    v17 = fmod(a2 - v13, v11) + v6;
    if (v16 <= v17)
      return v17;
    else
      return v16;
  }
  return v6;
}

double minForMiddleRange(double a1, double a2, double a3, double a4, double a5, int a6)
{
  double v6;
  double v7;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;

  v6 = a4;
  v7 = a3;
  v10 = a1 - a3;
  v11 = a4 - a3;
  v12 = v10 / (a4 - a3);
  v13 = a4 + a5;
  v14 = a1 - (a4 + a5);
  if (a6)
  {
    v12 = v14 / v11;
    v15 = a4 + a5;
  }
  else
  {
    v15 = v7;
  }
  if (vcvtmd_s64_f64(v12) == vcvtmd_s64_f64((a2 - v15) / v11))
  {
    if (a6)
    {
      v11 = v6 - v7;
      v16 = fmod(v14, v6 - v7) + v6;
    }
    else
    {
      v16 = fmod(v10, v11) + v7;
      v13 = v7;
      v6 = v7;
    }
    v17 = fmod(a2 - v13, v11) + v6;
    if (v16 >= v17)
      return v17;
    else
      return v16;
  }
  return v7;
}

double cikernel::_stripes(CI *a1, float a2, float32x4_t a3, float32x4_t a4, double a5)
{
  _QWORD *DC;
  float v7;
  float v8;
  float v15;
  float v16;
  double result;

  DC = (_QWORD *)CI::getDC(a1);
  _V3.S[1] = HIDWORD(a5);
  v7 = (float)((float)(COERCE_FLOAT(*DC) - a2) * *(float *)&a5) + -0.25;
  v8 = v7 - floorf(v7);
  _S0 = fminf(1.0 - v8, v8);
  __asm { FMLA            S2, S0, V3.S[1] }
  if (_S2 <= 1.0)
    v15 = _S2;
  else
    v15 = 1.0;
  if (_S2 < 0.0)
    v15 = 0.0;
  v16 = (v15 * -2.0 + 3.0) * v15 * v15;
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(a4, 1.0 - v16), a3, v16).u64[0];
  return result;
}

void cikernel::_sunbeams(uint64_t a1, int8x16_t a2)
{
  float32x2_t v3;
  int32x2_t v4;
  unsigned __int32 v5;
  float64x2_t v6;
  float32x2_t v7;
  int8x16_t v8;
  double v9;
  float32x2_t v10;
  uint8x8_t v11;
  double v12;
  int8x16_t v13;

  v3 = vsub_f32(*(float32x2_t *)CI::getDC((CI *)a1), *(float32x2_t *)a2.i8);
  v4 = (int32x2_t)vmul_f32(v3, v3);
  v5 = vadd_f32((float32x2_t)v4, (float32x2_t)vdup_lane_s32(v4, 1)).u32[0];
  v6 = (float64x2_t)vextq_s8(a2, a2, 8uLL);
  v7 = vrsqrte_f32((float32x2_t)v5);
  *(float32x2_t *)v8.i8 = vmul_f32(v7, v7);
  v9 = COERCE_DOUBLE(vmul_f32(v7, vrsqrts_f32((float32x2_t)v5, *(float32x2_t *)v8.i8)));
  v10 = (float32x2_t)vdup_n_s32(0x42480000u);
  *(float32x2_t *)&v6.f64[0] = vadd_f32(*(float32x2_t *)&v6.f64[0], vmul_f32(vmul_n_f32(v3, *(float *)&v9), v10));
  v10.i32[0] = *(_DWORD *)(a1 + 28);
  v3.f32[0] = *(float *)(a1 + 24)
            + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v6.f64[0], 1), *(float *)(a1 + 16), *(float *)v6.f64);
  v8.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)&v9 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v6.f64[0], 1), v10.f32[0], *(float *)v6.f64);
  *(float *)v6.f64 = *(float *)v8.i32 + *(float *)&v9;
  v3.f32[1] = *(float *)v8.i32 + *(float *)&v9;
  CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v3, v6, v9, *(double *)&v10, v8, v11, v12, v13);
}

void CI::f4_sr_f4_f4_clr(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, __n128, __n128, __n128);
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __int128 v20;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, __n128, __n128, __n128))(a1 + 24);
  v12 = *(_QWORD *)(v10 + 8);
  v13 = *(_DWORD *)(v10 + 40);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  v17 = *(_QWORD *)(v10 + 80);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
  v18 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v16);
  v19 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v14);
  *(double *)&v20 = v11(a4 + 80 * v12, *v19, *v18, *((__n128 *)a2 + 4 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

double cikernel::_swipeTransition(CI *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  float32x4_t v5;
  int8x16_t v6;
  float v7;
  float v8;
  BOOL v9;
  float v10;
  float v11;
  float v12;
  double result;

  v5.i64[0] = *(_QWORD *)CI::getDC(a1);
  v5.i64[1] = 1065353216;
  v6 = (int8x16_t)vmulq_f32(a5, v5);
  v7 = vaddv_f32(vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL)));
  if (v7 <= 1.0)
    v8 = v7;
  else
    v8 = 1.0;
  v9 = v7 < 0.0;
  v10 = 0.0;
  if (!v9)
    v10 = v8;
  v11 = fminf(1.0 - v10, v10);
  v12 = (v11 + v11) * a5.f32[3];
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(a3, 1.0 - v10), a2, v10), 1.0 - v12), a4, v12).u64[0];
  return result;
}

void CI::f4_s_s_clr_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(_QWORD *, __n128, __n128, __n128, __n128);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __n128 *v20;
  __int128 v21;

  v9 = a1[6];
  v10 = (double (*)(_QWORD *, __n128, __n128, __n128, __n128))a1[3];
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_DWORD *)(v9 + 88);
  v17 = *(_QWORD *)(v9 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 104)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v14);
  if (v13 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v14);
  v20 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v21 = v10(a1, *v20, *v19, *((__n128 *)a2 + 4 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

double get_input_xy(CIVector *a1, double *a2, double *a3)
{
  double v6;
  double v7;
  double v8;
  double v9;
  double result;
  BOOL v11;
  double v12;

  -[CIVector X](a1, "X");
  v7 = v6;
  -[CIVector Y](a1, "Y");
  v9 = v8;
  result = 1.0;
  if (v7 < 1.0 && (v7 > 0.0 ? (v11 = v9 < 1.0) : (v11 = 0), v11 && v9 > 0.0))
  {
    *a2 = v7;
    *a3 = v9;
  }
  else
  {
    if (v7 < 2000.0 || v7 > 500000.0)
    {
      v12 = 6500.0;
      v9 = 0.0;
    }
    else
    {
      v12 = v7;
    }
    return tempTint_to_xy(v12, v9, a2, a3);
  }
  return result;
}

double tempTint_to_xy(double a1, double a2, double *a3, double *a4)
{
  uint64_t v4;
  double v5;
  double v6;
  uint64_t v7;
  double v8;
  double *v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double result;

  v4 = 0x20u;
  v5 = 1000000.0 / a1;
  do
  {
    v6 = *(double *)((char *)&kTempTable + v4);
    v7 = v4 + 32;
    if (v4 == 960)
      break;
    v4 += 32;
  }
  while (v5 >= v6);
  v8 = a2 * -0.000333333333;
  v9 = (double *)((char *)&kTempTable + v7);
  v10 = (v6 - v5) / (v6 - *(double *)((char *)&kTempTable + v7 - 64));
  v11 = *(v9 - 3) * (1.0 - v10) + *(v9 - 7) * v10;
  v12 = *(double *)((char *)&kTempTable + v7 - 40);
  v13 = (1.0 - v10) * *(v9 - 2) + *(v9 - 6) * v10;
  v14 = *(double *)((char *)&kTempTable + v7 - 8);
  v15 = sqrt(v12 * v12 + 1.0);
  v16 = sqrt(v14 * v14 + 1.0);
  v17 = (1.0 - v10) * (1.0 / v16) + 1.0 / v15 * v10;
  v18 = (1.0 - v10) * (v14 / v16) + v12 / v15 * v10;
  v19 = sqrt(v18 * v18 + v17 * v17);
  v20 = v11 + v17 / v19 * v8;
  v21 = v13 + v18 / v19 * v8;
  v22 = v20 * 1.5;
  v23 = v20 + v21 * -4.0 + 2.0;
  *a3 = v22 / v23;
  result = v21 / v23;
  *a4 = result;
  return result;
}

double cikernel::_whitepointadjust(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vmulq_f32(a1, a2).u64[0];
  return result;
}

void CI::f4_s_clr(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128);
  int v12;
  uint64_t v13;
  uint64_t v14;
  __n128 *v15;
  __int128 v16;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 56)), a2);
  v15 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v15 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v16 = v11(a1, *v15, *((__n128 *)a2 + 4 * v14));
  *(_OWORD *)(a3 + 16 * a7) = v16;
}

double cikernel::_falseColor(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  float32x4_t v3;
  double result;

  v3 = vmulq_f32(a1, (float32x4_t)xmmword_192492180);
  v3.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0];
  *(_QWORD *)&result = vmulq_laneq_f32(vmlaq_n_f32(vmulq_n_f32(a2, 1.0 - v3.f32[0]), a3, v3.f32[0]), a1, 3).u64[0];
  return result;
}

void CI::f4_s_clr_clr(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, __n128);
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __n128 *v16;
  __int128 v17;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_QWORD *)(v10 + 32);
  v15 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v16 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v16 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v17 = v11(a1, *v16, *((__n128 *)a2 + 4 * v14), *((__n128 *)a2 + 4 * v15));
  *(_OWORD *)(a3 + 16 * a7) = v17;
}

void sub_192385468(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(v1 - 200))(v1 - 216);
  _Unwind_Resume(a1);
}

double makeBoundingBox(void *a1, float a2)
{
  double v4;
  double v5;

  objc_msgSend(a1, "boundingBox");
  v5 = v4 * a2;
  objc_msgSend(a1, "boundingBox");
  objc_msgSend(a1, "boundingBox");
  objc_msgSend(a1, "boundingBox");
  objc_msgSend(a1, "boundingBox");
  return v5;
}

CGFloat makeCorners(void *a1, CGPoint *a2, CGPoint *a3, CGPoint *a4, CGPoint *a5, float a6, float a7)
{
  double v14;
  CGFloat v15;
  CGFloat v16;
  CGFloat v17;
  CGFloat result;
  CGFloat v19;

  CGPointMakeWithDictionaryRepresentation((CFDictionaryRef)objc_msgSend((id)objc_msgSend(a1, "corners"), "objectAtIndex:", 0), a2);
  CGPointMakeWithDictionaryRepresentation((CFDictionaryRef)objc_msgSend((id)objc_msgSend(a1, "corners"), "objectAtIndex:", 1), a3);
  CGPointMakeWithDictionaryRepresentation((CFDictionaryRef)objc_msgSend((id)objc_msgSend(a1, "corners"), "objectAtIndex:", 2), a5);
  CGPointMakeWithDictionaryRepresentation((CFDictionaryRef)objc_msgSend((id)objc_msgSend(a1, "corners"), "objectAtIndex:", 3), a4);
  v14 = a7;
  v15 = v14 - a2->y * v14;
  a2->x = a2->x * a6;
  a2->y = v15;
  v16 = v14 - a3->y * v14;
  a3->x = a3->x * a6;
  a3->y = v16;
  v17 = v14 - a4->y * v14;
  a4->x = a4->x * a6;
  a4->y = v17;
  result = a5->x * a6;
  v19 = v14 - a5->y * v14;
  a5->x = result;
  a5->y = v19;
  return result;
}

double cikernel::_toneCurve(float32x4_t a1, float a2, int8x16_t a3, float32x4_t a4, int8x16_t a5, float32x4_t a6, int8x16_t a7, float32x4_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int8x16_t a17, float a18, uint64_t a19, int8x16_t a20,float a21)
{
  float32x4_t v21;
  int8x16_t v23;
  float v24;
  int8x16_t v25;
  int8x16_t v26;
  float v34;
  float v35;
  float v37;
  float v38;
  float v39;
  float32x4_t v40;
  int8x16_t v41;
  float v42;
  int8x16_t v43;
  int8x16_t v44;
  float v46;
  float v49;
  float v51;
  float v52;
  float v53;
  float v54;
  float32x4_t v55;
  int8x16_t v56;
  float v57;
  int8x16_t v58;
  float v59;
  int8x16_t v60;
  float v61;
  float v63;

  v21.f32[0] = a18;
  _V17.S[1] = a20.i32[1];
  v23 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v21, a1), 0), a17, a20);
  if (a1.f32[0] >= a18)
    v24 = a18;
  else
    v24 = a8.f32[0];
  v25 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a8, a1), 0), a7, v23);
  if (a1.f32[0] < a8.f32[0])
    v24 = a6.f32[0];
  v26 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a6, a1), 0), a5, v25);
  if (a1.f32[0] < a6.f32[0])
    v24 = a4.f32[0];
  _Q19 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a4, a1), 0), a3, v26);
  if (a1.f32[0] < a4.f32[0])
    v24 = a2;
  _S21 = a1.f32[0] - v24;
  __asm { FMLA            S22, S21, V19.S[1] }
  v34 = (float)(_S22 + (float)(vmuls_lane_f32(_S21, _Q19, 2) * _S21))
      + (float)((float)(_S21 * vmuls_lane_f32(_S21, _Q19, 3)) * _S21);
  if (a1.f32[0] >= a2)
    v35 = v34;
  else
    v35 = *(float *)a3.i32;
  __asm { FMLA            S23, S21, V17.S[1] }
  if (a1.f32[0] <= a18)
    _S23 = v35;
  v37 = fmaxf(_S23, 0.0);
  if (a1.f32[0] > a18)
    v35 = *(float *)a20.i32;
  if (v35 <= 1.0)
    v38 = v35;
  else
    v38 = 1.0;
  if (v35 >= 0.0)
    v39 = v38;
  else
    v39 = 0.0;
  if (a21 >= 0.5)
    v39 = v37;
  v40 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.f32, 1);
  v41 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v21, v40), 0), a17, a20);
  if (a1.f32[1] >= a18)
    v42 = a18;
  else
    v42 = a8.f32[0];
  v43 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a8, v40), 0), a7, v41);
  if (a1.f32[1] < a8.f32[0])
    v42 = a6.f32[0];
  v44 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a6, v40), 0), a5, v43);
  if (a1.f32[1] < a6.f32[0])
    v42 = a4.f32[0];
  _Q25 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a4, v40), 0), a3, v44);
  if (a1.f32[1] >= a4.f32[0])
    v46 = v42;
  else
    v46 = a2;
  _S26 = a1.f32[1] - v46;
  __asm { FMLA            S27, S26, V25.S[1] }
  v49 = (float)(_S27 + (float)(vmuls_lane_f32(_S26, _Q25, 2) * _S26))
      + (float)((float)(_S26 * vmuls_lane_f32(_S26, _Q25, 3)) * _S26);
  if (a1.f32[1] < a2)
    v49 = *(float *)a3.i32;
  __asm { FMLA            S27, S26, V17.S[1] }
  if (a1.f32[1] <= a18)
    v51 = v49;
  else
    v51 = _S27;
  v52 = fmaxf(v51, 0.0);
  if (a1.f32[1] > a18)
    v49 = *(float *)a20.i32;
  if (v49 <= 1.0)
    v53 = v49;
  else
    v53 = 1.0;
  if (v49 >= 0.0)
    v54 = v53;
  else
    v54 = 0.0;
  if (a21 < 0.5)
    v52 = v54;
  v55 = (float32x4_t)vdupq_laneq_s32((int32x4_t)a1, 2);
  v56 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v21, v55), 0), a17, a20);
  if (a1.f32[2] >= a18)
    v57 = a18;
  else
    v57 = a8.f32[0];
  v58 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a8, v55), 0), a7, v56);
  if (a1.f32[2] >= a8.f32[0])
    v59 = v57;
  else
    v59 = a6.f32[0];
  v60 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a6, v55), 0), a5, v58);
  if (a1.f32[2] >= a6.f32[0])
    v61 = v59;
  else
    v61 = a4.f32[0];
  _Q4 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(a4, v55), 0), a3, v60);
  if (a1.f32[2] >= a4.f32[0])
    v63 = v61;
  else
    v63 = a2;
  _S3 = a1.f32[2] - v63;
  __asm
  {
    FMLA            S5, S3, V4.S[1]
    FMLA            S2, S3, V17.S[1]
  }
  return COERCE_DOUBLE(__PAIR64__(LODWORD(v52), LODWORD(v39)));
}

void CI::f4_s_f_f4_f_f4_f_f4_f_f4_f_f4_f(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, float, __n128, float, __n128, float, __n128, float, double, double, double);
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  double *v27;
  __n128 *v28;
  __n128 *v29;
  __n128 *v30;
  __n128 *v31;
  __n128 *v32;
  __n128 *v33;
  __n128 *v34;
  __int128 v35;
  double v36;
  int v37;
  int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  double (*v42)(__n128, float, __n128, float, __n128, float, __n128, float, double, double, double);
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, float, __n128, float, __n128, float, __n128, float, double, double, double))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_QWORD *)(v9 + 32);
  v14 = *(_DWORD *)(v9 + 64);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_QWORD *)(v9 + 80);
  v17 = *(_DWORD *)(v9 + 112);
  v18 = *(_QWORD *)(v9 + 104);
  v19 = *(_QWORD *)(v9 + 128);
  v20 = *(_DWORD *)(v9 + 160);
  v21 = *(_QWORD *)(v9 + 152);
  v22 = *(_QWORD *)(v9 + 176);
  v23 = *(_DWORD *)(v9 + 208);
  v24 = *(_QWORD *)(v9 + 200);
  v25 = *(_QWORD *)(v9 + 224);
  if (*(_BYTE *)(a1 + 64))
  {
    v42 = *(double (**)(__n128, float, __n128, float, __n128, float, __n128, float, double, double, double))(a1 + 24);
    v38 = *(_DWORD *)(v9 + 160);
    v26 = *(_QWORD *)(v9 + 32);
    v46 = *(_QWORD *)(v9 + 80);
    v44 = *(_QWORD *)(v9 + 224);
    v45 = *(_QWORD *)(v9 + 8);
    v43 = *(_DWORD *)(v9 + 64);
    v41 = *(_QWORD *)(v9 + 56);
    v40 = *(_DWORD *)(v9 + 112);
    v39 = *(_QWORD *)(v9 + 104);
    v37 = *(_DWORD *)(v9 + 208);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 272)), a2);
    v23 = v37;
    v18 = v39;
    v17 = v40;
    v15 = v41;
    v10 = v42;
    v14 = v43;
    v12 = v45;
    v16 = v46;
    v25 = v44;
    v13 = v26;
    v20 = v38;
  }
  v27 = (double *)(a3 + 16 * v24);
  if (v23 != 5)
    v27 = (double *)((char *)a2 + 64 * v24);
  v28 = (__n128 *)(a3 + 16 * v21);
  if (v20 != 5)
    v28 = (__n128 *)((char *)a2 + 64 * v21);
  v29 = (__n128 *)(a3 + 16 * v18);
  v30 = (__n128 *)((char *)a2 + 64 * v18);
  if (v17 != 5)
    v29 = v30;
  v31 = (__n128 *)(a3 + 16 * v15);
  v32 = (__n128 *)((char *)a2 + 64 * v15);
  if (v14 != 5)
    v31 = v32;
  v33 = (__n128 *)(a3 + 16 * v12);
  v34 = (__n128 *)((char *)a2 + 64 * v12);
  if (v11 != 5)
    v33 = v34;
  LODWORD(v36) = *((_DWORD *)a2 + 16 * v25);
  *(double *)&v35 = v10(*v33, *((float *)a2 + 16 * v13), *v31, *((float *)a2 + 16 * v16), *v29, *((float *)a2 + 16 * v19), *v28, *((float *)a2 + 16 * v22), *v27, v27[1], v36);
  *(_OWORD *)(a3 + 16 * a7) = v35;
}

__n128 cikernel::_triangleKaleidoscopeColor(CI *a1, float32x4_t a2, float32x2_t a3, int8x16_t a4, float a5)
{
  float32x2_t v6;
  double v7;
  double v8;
  unsigned int v9;
  unsigned int v10;
  float32x4_t v11;
  float32x4_t v12;
  __n128 result;

  v6 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a3);
  v7 = vaddv_f32(vmul_f32(*(float32x2_t *)a4.i8, v6));
  v8 = vaddv_f32(vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v6));
  *(float *)&v9 = v7 + 1.0 - v8;
  *(float *)&v10 = 2.0 - v7 + v8 * -2.0;
  *(float *)&v8 = v7 * -2.0 + 2.0 - v8;
  v11.i64[0] = __PAIR64__(v10, v9);
  v11.i64[1] = LODWORD(v8);
  v12 = vabsq_f32(vrndmq_f32(v11));
  result.n128_u64[0] = vmulq_n_f32(a2, powf(a5, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1), v12)).f32[0])).u64[0];
  result.n128_u32[3] = a2.u32[3];
  return result;
}

void CI::f4_s_f2_f4_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(_QWORD *, __n128, double, __n128, float);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  __n128 *v18;
  double *v19;
  __n128 *v20;
  __int128 v21;

  v9 = a1[6];
  v10 = (double (*)(_QWORD *, __n128, double, __n128, float))a1[3];
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_QWORD *)(v9 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 104)), a2);
  v18 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v16);
  v19 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v19 = (double *)((char *)a2 + 64 * v14);
  v20 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v21 = v10(a1, *v20, *v19, *v18, *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

float32x2_t cikernel::_triangleKaleidoscopeGeom(CI *a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  float32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  float32x2_t v11;
  double v12;
  double v13;
  float32_t v14;
  double v15;
  float v16;
  int32x2_t v17;
  float32x2_t v18;
  int32x2_t v19;
  int32x2_t v20;

  v5 = vsub_f32(*(float32x2_t *)CI::getDC(a1), a2);
  v6 = (int32x2_t)vmul_f32(*(float32x2_t *)a3.i8, v5);
  v7 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v5);
  v8 = vadd_f32((float32x2_t)vzip1_s32(v6, v7), (float32x2_t)vzip2_s32(v6, v7));
  v9 = (int32x2_t)vminnm_f32(vsub_f32(v8, vrndm_f32(v8)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  v11 = (float32x2_t)vdup_lane_s32(vcgt_f32((float32x2_t)v9, (float32x2_t)vdup_lane_s32(v9, 1)), 0);
  v10 = (int32x2_t)vbsl_s8((int8x8_t)v11, (int8x8_t)vrev64_s32(v9), (int8x8_t)v9);
  v11.i32[0] = v10.i32[1];
  v12 = *(float *)v10.i32;
  v13 = 2.0 - *(float *)v10.i32 - *(float *)&v10.i32[1];
  if (v13 < *(float *)&v10.i32[1])
  {
    v14 = v13;
    v11.f32[0] = v14;
  }
  v15 = 1.0 - v12 - v11.f32[0];
  if (v15 > v12)
  {
    v16 = v15;
    *(float *)v10.i32 = v16;
  }
  v17 = vcgt_f32((float32x2_t)v10, v11);
  v10.i32[1] = v11.i32[0];
  v18 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(v17, 0), (int8x8_t)vrev64_s32(v10), (int8x8_t)v10);
  v19 = (int32x2_t)vmul_f32(*(float32x2_t *)a4.i8, v18);
  v20 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v18);
  return vadd_f32(a2, vadd_f32((float32x2_t)vzip1_s32(v19, v20), (float32x2_t)vzip2_s32(v19, v20)));
}

double triangleBounds(float a1, float a2, float32x2_t a3)
{
  __double2 v4;
  float32x2_t v5;
  float32_t v6;
  float32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  double v10;
  uint64_t v11;
  uint64_t v12;
  double result;
  float32x2_t v15;
  CGRect v16;
  CGRect v17;
  CGRect v18;

  v4 = __sincos_stret(a2);
  v5.f32[0] = v4.__sinval * 0.288675129 + v4.__cosval * -0.5;
  v6 = v4.__cosval * -0.288675129 + v4.__sinval * -0.5;
  v5.f32[1] = v6;
  v7 = vadd_f32(a3, vmul_n_f32(v5, a1));
  v8.f32[0] = v4.__sinval * 0.288675129 + v4.__cosval * 0.5;
  v5.f32[0] = v4.__cosval * -0.288675129 + v4.__sinval * 0.5;
  v8.i32[1] = v5.i32[0];
  v9 = vadd_f32(a3, vmul_n_f32(v8, a1));
  v15 = vadd_f32(a3, vmul_n_f32(vcvt_f32_f64(vmlaq_f64(vmulq_f64((float64x2_t)v4, (float64x2_t)xmmword_192498970), (float64x2_t)0, (float64x2_t)vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL))), a1));
  v4.__sinval = v7.f32[0];
  v10 = v7.f32[1];
  v17.origin.x = v9.f32[0];
  v17.origin.y = v9.f32[1];
  v11 = 0;
  v12 = 0;
  v17.size.width = 0.0;
  v17.size.height = 0.0;
  v16 = CGRectUnion(*(CGRect *)&v4.__sinval, v17);
  v18.origin.x = v15.f32[0];
  v18.origin.y = v15.f32[1];
  v18.size.width = 0.0;
  v18.size.height = 0.0;
  *(_QWORD *)&result = (unint64_t)CGRectUnion(v16, v18);
  return result;
}

double cikernel::_triangleTile(uint64_t a1, float32x2_t a2, int8x16_t a3, int8x16_t a4)
{
  float32x2_t v6;
  double v7;
  int8x16_t v8;
  int32x2_t v9;
  float32x2_t v10;
  int32x2_t v11;
  int32x2_t v12;
  float64x2_t v13;
  double v14;
  int8x16_t v15;
  uint8x8_t v16;
  double v17;
  float v18;
  int32x2_t v19;
  float32x2_t v20;
  int32x2_t v21;
  float32x2_t v22;

  v6 = vsub_f32(*(float32x2_t *)CI::getDC((CI *)a1), a2);
  *(float32x2_t *)&v13.f64[0] = vmul_f32(*(float32x2_t *)a3.i8, v6);
  v9 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), v6);
  v10 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v13.f64[0], v9), (float32x2_t)vzip2_s32(*(int32x2_t *)&v13.f64[0], v9));
  v11 = (int32x2_t)vminnm_f32(vsub_f32(v10, vrndm_f32(v10)), (float32x2_t)vdup_n_s32(0x3F7FFFFFu));
  *(int32x2_t *)&v13.f64[0] = vdup_lane_s32(vcgt_f32((float32x2_t)v11, (float32x2_t)vdup_lane_s32(v11, 1)), 0);
  v12 = (int32x2_t)vbsl_s8(*(int8x8_t *)&v13.f64[0], (int8x8_t)vrev64_s32(v11), (int8x8_t)v11);
  LODWORD(v13.f64[0]) = v12.i32[1];
  v14 = *(float *)v12.i32;
  *(double *)v15.i64 = 2.0 - *(float *)v12.i32 - *(float *)&v12.i32[1];
  *(float *)v16.i32 = *(double *)v15.i64;
  if (*(double *)v15.i64 < *(float *)&v12.i32[1])
    *(float *)v13.f64 = *(double *)v15.i64;
  *(double *)v15.i64 = *(float *)v13.f64;
  v17 = 1.0 - v14 - *(float *)v13.f64;
  if (v17 > v14)
  {
    v18 = v17;
    *(float *)v12.i32 = v18;
  }
  v19 = vcgt_f32((float32x2_t)v12, *(float32x2_t *)&v13.f64[0]);
  v12.i32[1] = LODWORD(v13.f64[0]);
  v20 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(v19, 0), (int8x8_t)vrev64_s32(v12), (int8x8_t)v12);
  *(float32x2_t *)&v13.f64[0] = vmul_f32(*(float32x2_t *)a4.i8, v20);
  v21 = (int32x2_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL), v20);
  v22 = (float32x2_t)vzip1_s32(*(int32x2_t *)&v13.f64[0], v21);
  *(float32x2_t *)&v13.f64[0] = vadd_f32(a2, vadd_f32(v22, (float32x2_t)vzip2_s32(*(int32x2_t *)&v13.f64[0], v21)));
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  *(float *)v21.i32 = *(float *)(a1 + 24)
                    + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v13.f64[0], 1), *(float *)(a1 + 16), *(float *)v13.f64);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  v22.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v13.f64[0], 1), *(float *)&v14, *(float *)v13.f64);
  *(float *)v13.f64 = *(float *)v15.i32 + v22.f32[0];
  *(float *)&v21.i32[1] = *(float *)v15.i32 + v22.f32[0];
  return CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v21, v13, *(double *)&v22, v14, v15, v16, v7, v8);
}

void cikernel::_twirl(CI *a1, float32x4_t a2)
{
  float32x2_t *DC;
  float32x2_t v3;
  float v4;
  float v5;

  DC = (float32x2_t *)CI::getDC(a1);
  v3 = vsub_f32(*DC, *(float32x2_t *)a2.f32);
  v4 = fminf(vmuls_lane_f32(sqrtf(vaddv_f32(vmul_f32(v3, v3))), a2, 2), 1.0);
  if (v4 >= 1.0)
  {
    CI::getDC((CI *)DC);
  }
  else
  {
    v5 = ((float)(1.0 - v4) * -2.0 + 3.0) * (float)(1.0 - v4) * (float)(1.0 - v4);
    __sincosf_stret(vmuls_lane_f32(v5, a2, 3));
  }
}

void twirlTracePoint(double a1, double a2, CGPoint a3, float a4, float a5, CGRect *a6)
{
  double v7;
  double v8;
  double v9;
  double v10;
  float v11;
  float v12;
  double y;
  double x;
  float v15;
  __float2 v16;
  float v17;
  float v18;
  CGPoint v19;
  CGRect v20;

  v7 = a2;
  v8 = a1;
  v9 = a1 - a3.x;
  v10 = a2 - a3.y;
  v11 = v10 * v10 + v9 * v9;
  v12 = fminf(sqrtf(v11) * a4, 1.0);
  if (v12 < 1.0)
  {
    y = a3.y;
    x = a3.x;
    v15 = ((float)(1.0 - v12) * -2.0 + 3.0) * (float)(1.0 - v12) * (float)(1.0 - v12);
    v16 = __sincosf_stret(v15 * a5);
    v17 = v10 * v16.__sinval + v9 * v16.__cosval;
    v18 = v10 * v16.__cosval - v9 * v16.__sinval;
    v8 = x + v17;
    v7 = y + v18;
  }
  v19.x = v8;
  v19.y = v7;
  if (!CGRectContainsPoint(*a6, v19))
  {
    v20.size.width = 0.0;
    v20.size.height = 0.0;
    v20.origin.x = v8;
    v20.origin.y = v7;
    *a6 = CGRectUnion(*a6, v20);
  }
}

double cikernel::_unsharpmask(float32x4_t a1, float32x4_t a2, float a3)
{
  double result;

  *(_QWORD *)&result = vaddq_f32(a1, vmulq_n_f32(vsubq_f32(a1, vmulq_n_f32(a2, a1.f32[3] / fmaxf(a2.f32[3], 0.0001))), a3)).u64[0];
  return result;
}

void sub_19238A004(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x218], 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__18(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__18(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

Class __getVNFaceObservationClass_block_invoke(uint64_t a1)
{
  Class result;

  VisionLibrary_1();
  result = objc_getClass("VNFaceObservation");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getVNFaceObservationClass_block_invoke_cold_1();
  getVNFaceObservationClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t VisionLibrary_1()
{
  void *v1;
  __int128 v2;
  uint64_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v1 = 0;
  if (!VisionLibraryCore_frameworkLibrary_1)
  {
    v2 = xmmword_1E2EC5390;
    v3 = 0;
    VisionLibraryCore_frameworkLibrary_1 = _sl_dlopen();
  }
  if (!VisionLibraryCore_frameworkLibrary_1)
    VisionLibrary_cold_1(&v1);
  return VisionLibraryCore_frameworkLibrary_1;
}

double cikernel::_variableBoxBlur(uint64_t a1, uint64_t a2, float a3, int8x16_t a4)
{
  float32x2_t *DC;
  double v8;
  double v9;
  uint8x8_t v10;
  int8x16_t v11;
  double v12;
  float64x2_t v13;
  double v14;
  int8x16_t v15;
  float32x4_t v16;
  float32x4_t v17;
  CI *v18;
  float32x2_t *v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int8x16_t v23;
  float32x2_t v24;
  int8x16_t v25;
  float64x2_t v26;
  int8x16_t v27;
  float32x2_t v28;
  double v29;
  float32x2_t v35;
  int8x16_t v36;
  float32x4_t v37;
  double v38;
  double v39;
  uint8x8_t v40;
  int8x16_t v41;
  float64x2_t v42;
  double v43;
  int8x16_t v44;
  float32x4_t v45;
  double v46;
  double v47;
  uint8x8_t v48;
  int8x16_t v49;
  float64x2_t v50;
  double v51;
  int8x16_t v52;
  float32x4_t v53;
  double v54;
  double v55;
  uint8x8_t v56;
  int8x16_t v57;
  float64x2_t v58;
  double v59;
  int8x16_t v60;
  float32x4_t v61;
  int8x16_t v62;
  float32x4_t v63;
  uint8x8_t v64;
  float32x4_t v65;
  float32x2_t v66;
  double v67;
  double v68;
  float32x2_t v69;
  int8x16_t v70;
  float32x4_t v71;
  double v72;
  double v73;
  uint8x8_t v74;
  int8x16_t v75;
  float64x2_t v76;
  double v77;
  int8x16_t v78;
  float32x4_t v79;
  double v80;
  double v81;
  uint8x8_t v82;
  int8x16_t v83;
  float64x2_t v84;
  double v85;
  int8x16_t v86;
  float32x4_t v87;
  double v88;
  double v89;
  uint8x8_t v90;
  int8x16_t v91;
  float64x2_t v92;
  double v93;
  int8x16_t v94;
  float32x4_t v95;
  int8x16_t v96;
  float32x4_t v97;
  uint8x8_t v98;
  float32x4_t v99;
  float32x2_t v100;
  double v101;
  double v102;
  float32x2_t v103;
  int8x16_t v104;
  float32x4_t v105;
  double v106;
  double v107;
  uint8x8_t v108;
  int8x16_t v109;
  float64x2_t v110;
  double v111;
  int8x16_t v112;
  float32x4_t v113;
  double v114;
  double v115;
  uint8x8_t v116;
  int8x16_t v117;
  float64x2_t v118;
  double v119;
  int8x16_t v120;
  float32x4_t v121;
  double v122;
  double v123;
  uint8x8_t v124;
  int8x16_t v125;
  float64x2_t v126;
  double v127;
  int8x16_t v128;
  float32x4_t v129;
  int8x16_t v130;
  float32x4_t v131;
  float64x2_t v132;
  float32x2_t v133;
  float32x2_t v134;
  double v135;
  double v136;
  int8x16_t v137;
  float32x4_t v138;
  double v139;
  double v140;
  uint8x8_t v141;
  int8x16_t v142;
  float64x2_t v143;
  double v144;
  int8x16_t v145;
  float32x4_t v146;
  double v147;
  double v148;
  uint8x8_t v149;
  int8x16_t v150;
  float64x2_t v151;
  double v152;
  int8x16_t v153;
  float32x4_t v154;
  double v155;
  double v156;
  uint8x8_t v157;
  int8x16_t v158;
  float64x2_t v159;
  double v160;
  int8x16_t v161;
  float32x4_t v162;
  float32x4_t v163;
  double result;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float v180;
  int8x16_t v181;
  float32x4_t v182;
  float64x2_t v184;
  float32x4_t v185;
  int8x16_t v186;

  DC = (float32x2_t *)CI::getDC((CI *)a1);
  *(float *)&v8 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 20), *DC, 1), *(float *)(a2 + 16), COERCE_FLOAT(*DC));
  LODWORD(v9) = *(_DWORD *)(a2 + 28);
  v10.i32[0] = *(_DWORD *)(a2 + 36);
  *(float *)v11.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a2 + 32), *DC, 1), *(float *)&v9, COERCE_FLOAT(*DC));
  *(float *)&v12 = *(float *)(a2 + 24) + *(float *)&v8;
  *(float *)v13.f64 = *(float *)v10.i32 + *(float *)v11.i32;
  *((float *)&v12 + 1) = *(float *)v10.i32 + *(float *)v11.i32;
  *(double *)v16.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a2 + 8), v12, v13, v8, v9, v11, v10, v14, v15);
  v17 = vmulq_f32(vmulq_n_f32(v16, 1.0 / fmaxf(v16.f32[3], 0.00001)), (float32x4_t)xmmword_1924967C0);
  v180 = fmaxf(a3* vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0], 0.5);
  v19 = (float32x2_t *)CI::getDC(v18);
  v20.f32[0] = -1.0 - v180;
  v21.f32[0] = v180;
  v20.f32[1] = -v180;
  v22 = vadd_f32(*v19, v20);
  v23 = a4;
  v24 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v23, v23, 8uLL), *(float32x2_t *)a4.i8);
  v25 = a4;
  *(float32x2_t *)v23.i8 = vminnm_f32(vmaxnm_f32(v22, *(float32x2_t *)a4.i8), v24);
  v186 = v23;
  v21.f32[1] = v180 + 1.0;
  *(float32x2_t *)&v26.f64[0] = vminnm_f32(vmaxnm_f32(vadd_f32(*v19, v21), *(float32x2_t *)a4.i8), v24);
  v184 = v26;
  v27 = v23;
  v27.i32[1] = HIDWORD(v26.f64[0]);
  *(float32x2_t *)v27.i8 = vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)0xBF000000BF000000);
  v28 = vrndm_f32(*(float32x2_t *)v27.i8);
  *(float32x2_t *)&v26.f64[0] = vadd_f32(v28, (float32x2_t)0x3F0000003F000000);
  *(float *)v23.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v26.f64[0], 1), *(float *)(a1 + 16), *(float *)v26.f64);
  v24.i32[0] = *(_DWORD *)(a1 + 24);
  v25.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v29) = *(_DWORD *)(a1 + 36);
  v21.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v26.f64[0], 1), *(float *)v25.i32, *(float *)v26.f64);
  __asm { FMOV            V12.2S, #1.0 }
  v35 = vadd_f32(v28, _D12);
  *(float32x2_t *)v27.i8 = vsub_f32(v35, *(float32x2_t *)v27.i8);
  v181 = v27;
  *(float *)v27.i32 = v24.f32[0] + *(float *)v23.i32;
  *(float *)v26.f64 = *(float *)&v29 + v21.f32[0];
  *(float *)&v27.i32[1] = *(float *)&v29 + v21.f32[0];
  *(double *)v37.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v27.i64, v26, *(double *)&v24, *(double *)v23.i64, v25, (uint8x8_t)v21, v29, v36);
  v177 = v37;
  *(float32x2_t *)v37.f32 = vadd_f32(v35, (float32x2_t)0x3F0000003F000000);
  *(float *)&v38 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v37.f32, 1), *(float *)(a1 + 16), v37.f32[0]);
  LODWORD(v39) = *(_DWORD *)(a1 + 28);
  v40.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v41.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v37.f32, 1), *(float *)&v39, v37.f32[0]);
  v37.f32[0] = *(float *)(a1 + 24) + *(float *)&v38;
  *(float *)v42.f64 = *(float *)v40.i32 + *(float *)v41.i32;
  v37.f32[1] = *(float *)v40.i32 + *(float *)v41.i32;
  *(double *)v45.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v37.i64, v42, v38, v39, v41, v40, v43, v44);
  v173 = v45;
  *(float32x2_t *)v45.f32 = vadd_f32(vadd_f32(v28, (float32x2_t)0x800000003F800000), (float32x2_t)0x3F0000003F000000);
  *(float *)&v46 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v45.f32, 1), *(float *)(a1 + 16), v45.f32[0]);
  LODWORD(v47) = *(_DWORD *)(a1 + 28);
  v48.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v49.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v45.f32, 1), *(float *)&v47, v45.f32[0]);
  v45.f32[0] = *(float *)(a1 + 24) + *(float *)&v46;
  *(float *)v50.f64 = *(float *)v48.i32 + *(float *)v49.i32;
  v45.f32[1] = *(float *)v48.i32 + *(float *)v49.i32;
  *(double *)v53.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v45.i64, v50, v46, v47, v49, v48, v51, v52);
  v169 = v53;
  *(float32x2_t *)v53.f32 = vadd_f32(vadd_f32(v28, (float32x2_t)0x3F80000080000000), (float32x2_t)0x3F0000003F000000);
  *(float *)&v54 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v53.f32, 1), *(float *)(a1 + 16), v53.f32[0]);
  LODWORD(v55) = *(_DWORD *)(a1 + 28);
  v56.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v57.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v53.f32, 1), *(float *)&v55, v53.f32[0]);
  v53.f32[0] = *(float *)(a1 + 24) + *(float *)&v54;
  *(float *)v58.f64 = *(float *)v56.i32 + *(float *)v57.i32;
  v53.f32[1] = *(float *)v56.i32 + *(float *)v57.i32;
  *(double *)v61.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v53.i64, v58, v54, v55, v57, v56, v59, v60);
  v62 = v181;
  v63 = vmlaq_n_f32(vmulq_n_f32(v169, 1.0 - *(float *)v181.i32), v177, *(float *)v181.i32);
  v64.i32[1] = v173.i32[1];
  v65 = vmlaq_n_f32(vmulq_n_f32(v173, 1.0 - *(float *)v181.i32), v61, *(float *)v181.i32);
  v182 = vmlaq_lane_f32(vmulq_n_f32(v65, 1.0 - *(float *)&v181.i32[1]), v63, *(float32x2_t *)v181.i8, 1);
  v61.i64[1] = *(_QWORD *)&v184.f64[1];
  *(float32x2_t *)v61.f32 = vadd_f32(*(float32x2_t *)&v184.f64[0], (float32x2_t)0xBF000000BF000000);
  v66 = vrndm_f32(*(float32x2_t *)v61.f32);
  *(float32x2_t *)v65.f32 = vadd_f32(v66, (float32x2_t)0x3F0000003F000000);
  *(float *)&v67 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v65.f32, 1), *(float *)(a1 + 16), v65.f32[0]);
  v63.i32[0] = *(_DWORD *)(a1 + 24);
  v62.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v68) = *(_DWORD *)(a1 + 36);
  *(float *)v64.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v65.f32, 1), *(float *)v62.i32, v65.f32[0]);
  v69 = vadd_f32(v66, _D12);
  *(float32x2_t *)v61.f32 = vsub_f32(v69, *(float32x2_t *)v61.f32);
  v178 = v61;
  v61.f32[0] = v63.f32[0] + *(float *)&v67;
  v65.f32[0] = *(float *)&v68 + *(float *)v64.i32;
  v61.f32[1] = *(float *)&v68 + *(float *)v64.i32;
  *(double *)v71.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v61.i64, (float64x2_t)v65, *(double *)v63.i64, v67, v62, v64, v68, v70);
  v174 = v71;
  *(float32x2_t *)v71.f32 = vadd_f32(v69, (float32x2_t)0x3F0000003F000000);
  *(float *)&v72 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v71.f32, 1), *(float *)(a1 + 16), v71.f32[0]);
  LODWORD(v73) = *(_DWORD *)(a1 + 28);
  v74.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v75.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v71.f32, 1), *(float *)&v73, v71.f32[0]);
  v71.f32[0] = *(float *)(a1 + 24) + *(float *)&v72;
  *(float *)v76.f64 = *(float *)v74.i32 + *(float *)v75.i32;
  v71.f32[1] = *(float *)v74.i32 + *(float *)v75.i32;
  *(double *)v79.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v71.i64, v76, v72, v73, v75, v74, v77, v78);
  v170 = v79;
  *(float32x2_t *)v79.f32 = vadd_f32(vadd_f32(v66, (float32x2_t)0x800000003F800000), (float32x2_t)0x3F0000003F000000);
  *(float *)&v80 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v79.f32, 1), *(float *)(a1 + 16), v79.f32[0]);
  LODWORD(v81) = *(_DWORD *)(a1 + 28);
  v82.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v83.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v79.f32, 1), *(float *)&v81, v79.f32[0]);
  v79.f32[0] = *(float *)(a1 + 24) + *(float *)&v80;
  *(float *)v84.f64 = *(float *)v82.i32 + *(float *)v83.i32;
  v79.f32[1] = *(float *)v82.i32 + *(float *)v83.i32;
  *(double *)v87.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v79.i64, v84, v80, v81, v83, v82, v85, v86);
  v166 = v87;
  *(float32x2_t *)v87.f32 = vadd_f32(vadd_f32(v66, (float32x2_t)0x3F80000080000000), (float32x2_t)0x3F0000003F000000);
  *(float *)&v88 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v87.f32, 1), *(float *)(a1 + 16), v87.f32[0]);
  LODWORD(v89) = *(_DWORD *)(a1 + 28);
  v90.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v91.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v87.f32, 1), *(float *)&v89, v87.f32[0]);
  v87.f32[0] = *(float *)(a1 + 24) + *(float *)&v88;
  *(float *)v92.f64 = *(float *)v90.i32 + *(float *)v91.i32;
  v87.f32[1] = *(float *)v90.i32 + *(float *)v91.i32;
  *(double *)v95.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v87.i64, v92, v88, v89, v91, v90, v93, v94);
  v96 = (int8x16_t)v178;
  v97 = vmlaq_n_f32(vmulq_n_f32(v166, 1.0 - v178.f32[0]), v174, v178.f32[0]);
  v98.i32[1] = v170.i32[1];
  v99 = vmlaq_n_f32(vmulq_n_f32(v170, 1.0 - v178.f32[0]), v95, v178.f32[0]);
  v179 = vmlaq_lane_f32(vmulq_n_f32(v99, 1.0 - v178.f32[1]), v97, *(float32x2_t *)v178.f32, 1);
  v95.i64[1] = v186.i64[1];
  *(float32x2_t *)v95.f32 = vadd_f32(*(float32x2_t *)v186.i8, (float32x2_t)0xBF000000BF000000);
  v100 = vrndm_f32(*(float32x2_t *)v95.f32);
  *(float32x2_t *)v99.f32 = vadd_f32(v100, (float32x2_t)0x3F0000003F000000);
  *(float *)&v101 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v99.f32, 1), *(float *)(a1 + 16), v99.f32[0]);
  v97.i32[0] = *(_DWORD *)(a1 + 24);
  v96.i32[0] = *(_DWORD *)(a1 + 28);
  LODWORD(v102) = *(_DWORD *)(a1 + 36);
  *(float *)v98.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v99.f32, 1), *(float *)v96.i32, v99.f32[0]);
  v103 = vadd_f32(v100, _D12);
  *(float32x2_t *)v95.f32 = vsub_f32(v103, *(float32x2_t *)v95.f32);
  v175 = v95;
  v95.f32[0] = v97.f32[0] + *(float *)&v101;
  v99.f32[0] = *(float *)&v102 + *(float *)v98.i32;
  v95.f32[1] = *(float *)&v102 + *(float *)v98.i32;
  *(double *)v105.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v95.i64, (float64x2_t)v99, *(double *)v97.i64, v101, v96, v98, v102, v104);
  v171 = v105;
  *(float32x2_t *)v105.f32 = vadd_f32(v103, (float32x2_t)0x3F0000003F000000);
  *(float *)&v106 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v105.f32, 1), *(float *)(a1 + 16), v105.f32[0]);
  LODWORD(v107) = *(_DWORD *)(a1 + 28);
  v108.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v109.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v105.f32, 1), *(float *)&v107, v105.f32[0]);
  v105.f32[0] = *(float *)(a1 + 24) + *(float *)&v106;
  *(float *)v110.f64 = *(float *)v108.i32 + *(float *)v109.i32;
  v105.f32[1] = *(float *)v108.i32 + *(float *)v109.i32;
  *(double *)v113.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v105.i64, v110, v106, v107, v109, v108, v111, v112);
  v167 = v113;
  *(float32x2_t *)v113.f32 = vadd_f32(vadd_f32(v100, (float32x2_t)0x800000003F800000), (float32x2_t)0x3F0000003F000000);
  *(float *)&v114 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v113.f32, 1), *(float *)(a1 + 16), v113.f32[0]);
  LODWORD(v115) = *(_DWORD *)(a1 + 28);
  v116.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v117.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v113.f32, 1), *(float *)&v115, v113.f32[0]);
  v113.f32[0] = *(float *)(a1 + 24) + *(float *)&v114;
  *(float *)v118.f64 = *(float *)v116.i32 + *(float *)v117.i32;
  v113.f32[1] = *(float *)v116.i32 + *(float *)v117.i32;
  *(double *)v121.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v113.i64, v118, v114, v115, v117, v116, v119, v120);
  v165 = v121;
  *(float32x2_t *)v121.f32 = vadd_f32(vadd_f32(v100, (float32x2_t)0x3F80000080000000), (float32x2_t)0x3F0000003F000000);
  *(float *)&v122 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v121.f32, 1), *(float *)(a1 + 16), v121.f32[0]);
  LODWORD(v123) = *(_DWORD *)(a1 + 28);
  v124.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v125.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v121.f32, 1), *(float *)&v123, v121.f32[0]);
  v121.f32[0] = *(float *)(a1 + 24) + *(float *)&v122;
  *(float *)v126.f64 = *(float *)v124.i32 + *(float *)v125.i32;
  v121.f32[1] = *(float *)v124.i32 + *(float *)v125.i32;
  *(double *)v129.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v121.i64, v126, v122, v123, v125, v124, v127, v128);
  v130 = (int8x16_t)v175;
  v131 = vmlaq_n_f32(vmulq_n_f32(v165, 1.0 - v175.f32[0]), v171, v175.f32[0]);
  v176 = vmlaq_lane_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(v167, 1.0 - v175.f32[0]), v129, v175.f32[0]), 1.0 - v175.f32[1]), v131, *(float32x2_t *)v175.f32, 1);
  *(_QWORD *)&v132.f64[1] = v186.i64[1];
  *(float32x2_t *)v129.f32 = vadd_f32((float32x2_t)__PAIR64__(v186.u32[1], LODWORD(v184.f64[0])), (float32x2_t)0xBF000000BF000000);
  v133 = vrndm_f32(*(float32x2_t *)v129.f32);
  v134 = vadd_f32(v133, _D12);
  *(float32x2_t *)v186.i8 = vsub_f32(v134, *(float32x2_t *)v129.f32);
  *(float32x2_t *)&v132.f64[0] = vadd_f32(v133, (float32x2_t)0x3F0000003F000000);
  LODWORD(v135) = *(_DWORD *)(a1 + 28);
  v129.f32[0] = *(float *)(a1 + 24)
              + vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)&v132.f64[0], 1), *(float *)(a1 + 16), *(float *)v132.f64);
  v130.i32[0] = *(_DWORD *)(a1 + 36);
  v131.f32[0] = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)&v132.f64[0], 1), *(float *)&v135, *(float *)v132.f64);
  *(float *)v132.f64 = *(float *)v130.i32 + v131.f32[0];
  v129.f32[1] = *(float *)v130.i32 + v131.f32[0];
  *(double *)v138.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v129.i64, v132, *(double *)v131.i64, v135, v130, *(uint8x8_t *)v167.f32, v136, v137);
  v185 = v138;
  *(float32x2_t *)v138.f32 = vadd_f32(v134, (float32x2_t)0x3F0000003F000000);
  *(float *)&v139 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v138.f32, 1), *(float *)(a1 + 16), v138.f32[0]);
  LODWORD(v140) = *(_DWORD *)(a1 + 28);
  v141.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v142.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v138.f32, 1), *(float *)&v140, v138.f32[0]);
  v138.f32[0] = *(float *)(a1 + 24) + *(float *)&v139;
  *(float *)v143.f64 = *(float *)v141.i32 + *(float *)v142.i32;
  v138.f32[1] = *(float *)v141.i32 + *(float *)v142.i32;
  *(double *)v146.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v138.i64, v143, v139, v140, v142, v141, v144, v145);
  v172 = v146;
  *(float32x2_t *)v146.f32 = vadd_f32(vadd_f32(v133, (float32x2_t)0x800000003F800000), (float32x2_t)0x3F0000003F000000);
  *(float *)&v147 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v146.f32, 1), *(float *)(a1 + 16), v146.f32[0]);
  LODWORD(v148) = *(_DWORD *)(a1 + 28);
  v149.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v150.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v146.f32, 1), *(float *)&v148, v146.f32[0]);
  v146.f32[0] = *(float *)(a1 + 24) + *(float *)&v147;
  *(float *)v151.f64 = *(float *)v149.i32 + *(float *)v150.i32;
  v146.f32[1] = *(float *)v149.i32 + *(float *)v150.i32;
  *(double *)v154.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v146.i64, v151, v147, v148, v150, v149, v152, v153);
  v168 = v154;
  *(float32x2_t *)v154.f32 = vadd_f32(vadd_f32(v133, (float32x2_t)0x3F80000080000000), (float32x2_t)0x3F0000003F000000);
  *(float *)&v155 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v154.f32, 1), *(float *)(a1 + 16), v154.f32[0]);
  LODWORD(v156) = *(_DWORD *)(a1 + 28);
  v157.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v158.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v154.f32, 1), *(float *)&v156, v154.f32[0]);
  v154.f32[0] = *(float *)(a1 + 24) + *(float *)&v155;
  *(float *)v159.f64 = *(float *)v157.i32 + *(float *)v158.i32;
  v154.f32[1] = *(float *)v157.i32 + *(float *)v158.i32;
  *(double *)v162.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v154.i64, v159, v155, v156, v158, v157, v160, v161);
  v163 = vsubq_f32(vsubq_f32(vaddq_f32(v182, vmlaq_lane_f32(vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(v172, 1.0 - *(float *)v186.i32), v162, *(float *)v186.i32), 1.0 - *(float *)&v186.i32[1]), vmlaq_n_f32(vmulq_n_f32(v168, 1.0 - *(float *)v186.i32), v185, *(float *)v186.i32), *(float32x2_t *)v186.i8, 1)), v179), v176);
  *(_QWORD *)&result = vdivq_f32(v163, (float32x4_t)vdupq_laneq_s32((int32x4_t)v163, 3)).u64[0];
  return result;
}

void CI::f4_sr_sr_f_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  double (*v12)(uint64_t, uint64_t, float, __n128);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  __int128 v19;

  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(double (**)(uint64_t, uint64_t, float, __n128))(a1 + 24);
  v13 = *(_QWORD *)(v11 + 8);
  v14 = *(_QWORD *)(v11 + 32);
  v15 = *(_QWORD *)(v11 + 56);
  v16 = *(_DWORD *)(v11 + 88);
  v17 = *(_QWORD *)(v11 + 80);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v11 + 104)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  *(double *)&v19 = v12(a4 + 80 * v13, a4 + 80 * v14, *((float *)a2 + 16 * v15), *v18);
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

double cikernel::_vibrance_neg(float32x4_t a1, float a2)
{
  float32x4_t v2;
  float32x4_t v3;
  double v4;
  float v5;
  float v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v17;
  float v18;
  float v19;
  float32x4_t v20;
  double result;

  v2 = vminnmq_f32(vmaxnmq_f32(a1, (float32x4_t)vdupq_n_s32(0x38D1B717u)), (float32x4_t)vdupq_n_s32(0x3F7FF972u));
  v3 = vsubq_f32(a1, v2);
  v4 = (float)(v2.f32[2] + vaddv_f32(*(float32x2_t *)v2.f32)) * 0.33333;
  *(float *)&v4 = v4;
  v5 = 1.0 / *(float *)&v4;
  v6 = 1.0 / (1.0 - *(float *)&v4);
  v7 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v4, 0);
  v8 = vsubq_f32(v2, v7);
  v9 = vmulq_n_f32(v8, v6);
  v10 = vmulq_n_f32(vsubq_f32(v7, v2), v5);
  v9.i32[3] = 0;
  v10.i32[3] = 0;
  v11 = vmaxnmq_f32(v9, v10);
  v12 = fmaxf(fmaxf(v11.f32[0], v11.f32[1]), v11.f32[2]);
  v13 = -(v2.f32[2] - v2.f32[1] * 2.0);
  v14 = (1.0 - v11.f32[0]) * (fminf(v2.f32[0] - v2.f32[1], v13) * 4.0) * v5;
  if (v14 <= 1.0)
    v15 = v14;
  else
    v15 = 1.0;
  _NF = v14 < 0.0;
  v17 = 0.0;
  if (!_NF)
    v17 = v15;
  v18 = v17 * 0.7 + 0.15;
  v19 = (v12 * (v12 + -1.0) + 1.0) * a2 * (1.0 - v18);
  v20 = vmaxnmq_f32(vaddq_f32(v2, vmulq_n_f32(v8, v19)), (float32x4_t)0);
  __asm { FMOV            V3.4S, #1.0 }
  *(_QWORD *)&result = vaddq_f32(v3, vminnmq_f32(v20, _Q3)).u64[0];
  return result;
}

double cikernel::_vibrance_pos(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  int32x2_t v4;
  float v5;
  float v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v17;
  float v18;
  float32x4_t v23;
  int8x16_t v24;
  double result;

  v2 = vminnmq_f32(vmaxnmq_f32(a1, (float32x4_t)vdupq_n_s32(0x38D1B717u)), (float32x4_t)vdupq_n_s32(0x3F7FF972u));
  v3 = vsubq_f32(a1, v2);
  v4.i32[1] = 1070945607;
  *(float *)v4.i32 = (float)(v2.f32[2] + vaddv_f32(*(float32x2_t *)v2.f32)) * 0.33333;
  v5 = 1.0 / *(float *)v4.i32;
  v6 = 1.0 / (1.0 - *(float *)v4.i32);
  v7 = (float32x4_t)vdupq_lane_s32(v4, 0);
  v8 = vsubq_f32(v2, v7);
  v9 = vmulq_n_f32(v8, v6);
  v10 = vmulq_n_f32(vsubq_f32(v7, v2), v5);
  v9.i32[3] = 0;
  v10.i32[3] = 0;
  v11 = vmaxnmq_f32(v9, v10);
  v12 = fmaxf(fmaxf(v11.f32[0], v11.f32[1]), v11.f32[2]);
  v13 = -(v2.f32[2] - v2.f32[1] * 2.0);
  v14 = (1.0 - v11.f32[0]) * (fminf(v2.f32[0] - v2.f32[1], v13) * 4.0) * v5;
  if (v14 <= 1.0)
    v15 = v14;
  else
    v15 = 1.0;
  _NF = v14 < 0.0;
  v17 = 0.0;
  if (!_NF)
    v17 = v15;
  v18 = v17 * 0.7 + 0.15;
  __asm { FMOV            V17.4S, #1.0 }
  v23.i64[0] = __PAIR64__(LODWORD(v12), _Q17.u32[0]);
  v23.f32[2] = v12 * v12;
  v23.f32[3] = v12 * (float)(v12 * v12);
  v24 = (int8x16_t)vmulq_f32(a2, v23);
  *(float *)v24.i32 = (1.0 - v18)
                    * vaddv_f32(vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL)));
  *(_QWORD *)&result = vaddq_f32(v3, vminnmq_f32(vmaxnmq_f32(vaddq_f32(v2, vmulq_n_f32(v8, *(float *)v24.i32)), (float32x4_t)0), _Q17)).u64[0];
  return result;
}

__n128 cikernel::_vignette(CI *a1, float32x4_t a2, float32x4_t a3)
{
  float32x2_t v3;
  __n128 result;

  v3 = vsub_f32(*(float32x2_t *)CI::getDC(a1), *(float32x2_t *)a3.f32);
  result.n128_u64[0] = vmulq_n_f32(a2, powf(fmaxf(1.0 - vmuls_lane_f32(vaddv_f32(vmul_f32(v3, v3)), a3, 3), 0.0), a3.f32[2])).u64[0];
  result.n128_u32[3] = a2.u32[3];
  return result;
}

__n128 cikernel::_vignetteeffect(CI *a1, float32x4_t a2, float32x2_t a3, float32x4_t a4)
{
  __n128 result;
  float v5;
  BOOL v6;
  float v7;
  float v8;
  float v9;
  float v10;

  result.n128_u64[0] = (unint64_t)vmul_n_f32(vsub_f32(*(float32x2_t *)CI::getDC(a1), a3), a4.f32[0]);
  result.n128_f32[0] = vmuls_lane_f32(sqrtf(vaddv_f32(vmul_f32((float32x2_t)result.n128_u64[0], (float32x2_t)result.n128_u64[0])))- a4.f32[1], a4, 2);
  if (result.n128_f32[0] <= 1.0)
    v5 = result.n128_f32[0];
  else
    v5 = 1.0;
  v6 = result.n128_f32[0] < 0.0;
  v7 = 0.0;
  if (!v6)
    v7 = v5;
  v8 = ((v7 * 6.0 + -15.0) * v7 + 10.0) * (float)(v7 * (float)(v7 * v7));
  v9 = vmuls_lane_f32(v8, a4, 3);
  v10 = ((((float)(1.0 - v9) * -0.120638501 + 0.543878646) * (float)(1.0 - v9) + 0.538772615) * (float)(1.0 - v9)
       + 0.0376009997)
      * (float)(1.0 - v9);
  result.n128_u64[0] = vmulq_n_f32(a2, v10).u64[0];
  result.n128_u32[3] = a2.u32[3];
  return result;
}

void CI::f4_s_f2_f4(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, double, __n128);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __n128 *v18;
  double *v19;
  __n128 *v20;
  __int128 v21;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, double, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_DWORD *)(v10 + 64);
  v17 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v18 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v17);
  v19 = (double *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (double *)((char *)a2 + 64 * v15);
  v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v21 = v11(a1, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

__n128 cikernel::_vignetteeffectneg(CI *a1, float32x4_t a2, float32x2_t a3, float32x4_t a4)
{
  __n128 result;
  float v5;
  BOOL v6;
  float v7;
  float v8;
  float v9;

  result.n128_u64[0] = (unint64_t)vmul_n_f32(vsub_f32(*(float32x2_t *)CI::getDC(a1), a3), a4.f32[0]);
  result.n128_f32[0] = vmuls_lane_f32(sqrtf(vaddv_f32(vmul_f32((float32x2_t)result.n128_u64[0], (float32x2_t)result.n128_u64[0])))- a4.f32[1], a4, 2);
  v5 = 1.0;
  if (result.n128_f32[0] <= 1.0)
    v5 = result.n128_f32[0];
  v6 = result.n128_f32[0] < 0.0;
  v7 = 0.0;
  if (!v6)
    v7 = v5;
  v8 = ((v7 * 6.0 + -15.0) * v7 + 10.0) * (float)(v7 * (float)(v7 * v7));
  v9 = v8 * 16.0 * a4.f32[3] + 1.0;
  result.n128_u64[0] = vmulq_n_f32(a2, v9).u64[0];
  result.n128_u32[3] = a2.u32[3];
  return result;
}

uint64_t CIVNgetOrientation(void *a1)
{
  void *v2;

  if (objc_msgSend(a1, "properties")
    && objc_msgSend((id)objc_msgSend(a1, "properties"), "objectForKey:", CFSTR("Orientation")))
  {
    v2 = (void *)objc_msgSend((id)objc_msgSend(a1, "properties"), "objectForKey:", CFSTR("Orientation"));
  }
  else
  {
    v2 = &unk_1E2F1BF98;
  }
  return objc_msgSend(v2, "intValue");
}

uint64_t CIVNDetectFaces(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  void *v8;
  _QWORD *v9;
  void *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  objc_class *v15;
  void *v16;
  objc_class *v17;
  id v18;
  NSObject *v19;
  uint64_t v20;
  objc_class *v21;
  id v22;
  NSObject *v23;
  objc_class *v24;
  id v25;
  NSObject *v26;
  objc_class *v27;
  id v28;
  NSObject *v29;
  objc_class *v30;
  id v31;
  NSObject *v32;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  Class (*v38)(uint64_t);
  void *v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  void (*v44)(uint64_t, uint64_t);
  void (*v45)(uint64_t);
  uint64_t v46;
  id v47;
  id v48;
  id v49;
  id v50;
  _QWORD v51[3];

  v51[1] = *MEMORY[0x1E0C80C00];
  v8 = (void *)objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  if (a3)
  {
    v41 = 0;
    v42 = &v41;
    v43 = 0x2020000000;
    v9 = (_QWORD *)getVNImageOptionCIContextSymbolLoc_ptr;
    v44 = (void (*)(uint64_t, uint64_t))getVNImageOptionCIContextSymbolLoc_ptr;
    if (!getVNImageOptionCIContextSymbolLoc_ptr)
    {
      v10 = (void *)VisionLibrary_2();
      v9 = dlsym(v10, "VNImageOptionCIContext");
      v42[3] = (uint64_t)v9;
      getVNImageOptionCIContextSymbolLoc_ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v41, 8);
    if (!v9)
      CIVNDetectFaces_cold_6();
    objc_msgSend(v8, "setObject:forKey:", a3, *v9);
  }
  if (a4)
  {
    if (objc_msgSend(a4, "objectForKey:", CFSTR("kCIVNDetectOptionRequestLandmarks")))
      v11 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", CFSTR("kCIVNDetectOptionRequestLandmarks")), "BOOLValue");
    else
      v11 = 0;
    if (objc_msgSend(a4, "objectForKey:", CFSTR("kCIVNDetectOptionRequestAttributes")))
      v13 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", CFSTR("kCIVNDetectOptionRequestAttributes")), "BOOLValue");
    else
      v13 = 0;
    if (objc_msgSend(a4, "objectForKey:", CFSTR("kCIVNDetectOptionRequestPose")))
      v14 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", CFSTR("kCIVNDetectOptionRequestPose")), "BOOLValue");
    else
      v14 = 0;
    if (objc_msgSend(a4, "objectForKey:", CFSTR("kCIVNDetectOptionRequestFast")))
      v12 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", CFSTR("kCIVNDetectOptionRequestFast")), "BOOLValue");
    else
      v12 = 0;
    if (objc_msgSend(a4, "objectForKey:", CFSTR("kCIVNDetectOptionRequestSegments")))
    {
      v34 = objc_msgSend((id)objc_msgSend(a4, "objectForKey:", CFSTR("kCIVNDetectOptionRequestSegments")), "BOOLValue");
      goto LABEL_23;
    }
  }
  else
  {
    v12 = 0;
    v13 = 0;
    v11 = 0;
    v14 = 0;
  }
  v34 = 0;
LABEL_23:
  v41 = 0;
  v42 = &v41;
  v43 = 0x3052000000;
  v44 = __Block_byref_object_copy__19;
  v45 = __Block_byref_object_dispose__19;
  v15 = (objc_class *)getVNImageRequestHandlerClass_softClass_0;
  v46 = getVNImageRequestHandlerClass_softClass_0;
  if (!getVNImageRequestHandlerClass_softClass_0)
  {
    v36 = MEMORY[0x1E0C809B0];
    v37 = 3221225472;
    v38 = __getVNImageRequestHandlerClass_block_invoke_0;
    v39 = &unk_1E2EC2EB8;
    v40 = &v41;
    __getVNImageRequestHandlerClass_block_invoke_0((uint64_t)&v36);
    v15 = (objc_class *)v42[5];
  }
  _Block_object_dispose(&v41, 8);
  v16 = (void *)objc_msgSend([v15 alloc], "initWithCIImage:orientation:options:", a1, a2, v8);
  v35 = 0;
  v41 = 0;
  v42 = &v41;
  v43 = 0x3052000000;
  v44 = __Block_byref_object_copy__19;
  v45 = __Block_byref_object_dispose__19;
  v17 = (objc_class *)getVNDetectFaceRectanglesRequestClass_softClass;
  v46 = getVNDetectFaceRectanglesRequestClass_softClass;
  if (!getVNDetectFaceRectanglesRequestClass_softClass)
  {
    v36 = MEMORY[0x1E0C809B0];
    v37 = 3221225472;
    v38 = __getVNDetectFaceRectanglesRequestClass_block_invoke;
    v39 = &unk_1E2EC2EB8;
    v40 = &v41;
    __getVNDetectFaceRectanglesRequestClass_block_invoke((uint64_t)&v36);
    v17 = (objc_class *)v42[5];
  }
  _Block_object_dispose(&v41, 8);
  v18 = objc_alloc_init(v17);
  objc_msgSend(v18, "setRevision:", 3);
  if (v12)
    objc_msgSend(v18, "setDetectionLevel:", 2);
  v51[0] = v18;
  objc_msgSend(v16, "performRequests:error:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v51, 1), &v35);
  if (v35)
  {
    v19 = ci_logger_api();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      CIVNDetectFaces_cold_5((uint64_t)&v35);
    v20 = 0;
  }
  else
  {
    v20 = objc_msgSend(v18, "results");
  }

  if (v13)
  {
    v41 = 0;
    v42 = &v41;
    v43 = 0x3052000000;
    v44 = __Block_byref_object_copy__19;
    v45 = __Block_byref_object_dispose__19;
    v21 = (objc_class *)getVNClassifyFaceAttributesRequestClass_softClass;
    v46 = getVNClassifyFaceAttributesRequestClass_softClass;
    if (!getVNClassifyFaceAttributesRequestClass_softClass)
    {
      v36 = MEMORY[0x1E0C809B0];
      v37 = 3221225472;
      v38 = __getVNClassifyFaceAttributesRequestClass_block_invoke;
      v39 = &unk_1E2EC2EB8;
      v40 = &v41;
      __getVNClassifyFaceAttributesRequestClass_block_invoke((uint64_t)&v36);
      v21 = (objc_class *)v42[5];
    }
    _Block_object_dispose(&v41, 8);
    v22 = objc_alloc_init(v21);
    objc_msgSend(v22, "setRevision:error:", 3737841666, 0);
    objc_msgSend(v22, "setInputFaceObservations:", v20);
    v50 = v22;
    objc_msgSend(v16, "performRequests:error:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v50, 1), &v35);
    if (v35)
    {
      v23 = ci_logger_api();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        CIVNDetectFaces_cold_4((uint64_t)&v35);
    }
    else
    {
      v20 = objc_msgSend(v22, "results");
    }

  }
  if (v11)
  {
    v41 = 0;
    v42 = &v41;
    v43 = 0x3052000000;
    v44 = __Block_byref_object_copy__19;
    v45 = __Block_byref_object_dispose__19;
    v24 = (objc_class *)getVNDetectFaceLandmarksRequestClass_softClass;
    v46 = getVNDetectFaceLandmarksRequestClass_softClass;
    if (!getVNDetectFaceLandmarksRequestClass_softClass)
    {
      v36 = MEMORY[0x1E0C809B0];
      v37 = 3221225472;
      v38 = __getVNDetectFaceLandmarksRequestClass_block_invoke;
      v39 = &unk_1E2EC2EB8;
      v40 = &v41;
      __getVNDetectFaceLandmarksRequestClass_block_invoke((uint64_t)&v36);
      v24 = (objc_class *)v42[5];
    }
    _Block_object_dispose(&v41, 8);
    v25 = objc_alloc_init(v24);
    objc_msgSend(v25, "setRevision:", 2);
    objc_msgSend(v25, "setInputFaceObservations:", v20);
    v49 = v25;
    objc_msgSend(v16, "performRequests:error:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v49, 1), &v35);
    if (v35)
    {
      v26 = ci_logger_api();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        CIVNDetectFaces_cold_3((uint64_t)&v35);
    }
    else
    {
      v20 = objc_msgSend(v25, "results");
    }

  }
  if (v14)
  {
    v41 = 0;
    v42 = &v41;
    v43 = 0x3052000000;
    v44 = __Block_byref_object_copy__19;
    v45 = __Block_byref_object_dispose__19;
    v27 = (objc_class *)getVNDetectFacePoseRequestClass_softClass;
    v46 = getVNDetectFacePoseRequestClass_softClass;
    if (!getVNDetectFacePoseRequestClass_softClass)
    {
      v36 = MEMORY[0x1E0C809B0];
      v37 = 3221225472;
      v38 = __getVNDetectFacePoseRequestClass_block_invoke;
      v39 = &unk_1E2EC2EB8;
      v40 = &v41;
      __getVNDetectFacePoseRequestClass_block_invoke((uint64_t)&v36);
      v27 = (objc_class *)v42[5];
    }
    _Block_object_dispose(&v41, 8);
    v28 = objc_alloc_init(v27);
    objc_msgSend(v28, "setRevision:", 1);
    objc_msgSend(v28, "setInputFaceObservations:", v20);
    v48 = v28;
    objc_msgSend(v16, "performRequests:error:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v48, 1), &v35);
    if (v35)
    {
      v29 = ci_logger_api();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        CIVNDetectFaces_cold_2((uint64_t)&v35);
    }
    else
    {
      v20 = objc_msgSend(v28, "results");
    }

  }
  if (v34)
  {
    v41 = 0;
    v42 = &v41;
    v43 = 0x3052000000;
    v44 = __Block_byref_object_copy__19;
    v45 = __Block_byref_object_dispose__19;
    v30 = (objc_class *)getVNGenerateFaceSegmentsRequestClass_softClass;
    v46 = getVNGenerateFaceSegmentsRequestClass_softClass;
    if (!getVNGenerateFaceSegmentsRequestClass_softClass)
    {
      v36 = MEMORY[0x1E0C809B0];
      v37 = 3221225472;
      v38 = __getVNGenerateFaceSegmentsRequestClass_block_invoke;
      v39 = &unk_1E2EC2EB8;
      v40 = &v41;
      __getVNGenerateFaceSegmentsRequestClass_block_invoke((uint64_t)&v36);
      v30 = (objc_class *)v42[5];
    }
    _Block_object_dispose(&v41, 8);
    v31 = objc_alloc_init(v30);
    objc_msgSend(v31, "setInputFaceObservations:", v20);
    v47 = v31;
    objc_msgSend(v16, "performRequests:error:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v47, 1), &v35);
    if (v35)
    {
      v32 = ci_logger_api();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        CIVNDetectFaces_cold_1((uint64_t)&v35);
    }
    else
    {
      v20 = objc_msgSend(v31, "results");
    }

  }
  return v20;
}

void sub_19238D99C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n64 CIVNBoundsOfLandmarkRegion(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __n64 result;
  uint64_t v8;
  CGFloat *v9;
  CGRect v10;

  v2 = objc_msgSend(a1, "pointsInImageOfSize:");
  v3 = objc_msgSend(a1, "pointCount");
  if (v3 && v2)
  {
    v4 = v3;
    v5 = *(_QWORD *)(MEMORY[0x1E0C9D628] + 16);
    v6 = *(_QWORD *)(MEMORY[0x1E0C9D628] + 24);
    result.n64_u64[0] = *MEMORY[0x1E0C9D628];
    v8 = *(_QWORD *)(MEMORY[0x1E0C9D628] + 8);
    v9 = (CGFloat *)(v2 + 8);
    do
    {
      v10.origin.x = *(v9 - 1);
      v10.origin.y = *v9;
      v10.size.width = 0.0;
      v10.size.height = 0.0;
      *(CGRect *)result.n64_u64 = CGRectUnion(*(CGRect *)result.n64_u64, v10);
      v9 += 2;
      --v4;
    }
    while (v4);
  }
  else
  {
    return *(__n64 *)MEMORY[0x1E0C9D628];
  }
  return result;
}

double CIVNAreaOfBoundsOfLandmarkRegion(void *a1)
{
  double v1;
  double v2;

  CIVNBoundsOfLandmarkRegion(a1);
  return v1 * v2;
}

double CIVNAverage(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  double v5;
  double v6;
  uint64_t i;
  void *v8;
  double v9;
  double v10;
  unint64_t v11;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _BYTE v17[128];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v2 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
  if (v2)
  {
    v3 = v2;
    v4 = *(_QWORD *)v14;
    v5 = 0.0;
    v6 = 0.0;
    do
    {
      for (i = 0; i != v3; ++i)
      {
        if (*(_QWORD *)v14 != v4)
          objc_enumerationMutation(a1);
        v8 = *(void **)(*((_QWORD *)&v13 + 1) + 8 * i);
        objc_msgSend(v8, "X");
        v6 = v6 + v9;
        objc_msgSend(v8, "Y");
        v5 = v5 + v10;
      }
      v3 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
    }
    while (v3);
  }
  else
  {
    v6 = 0.0;
  }
  v11 = objc_msgSend(a1, "count");
  objc_msgSend(a1, "count");
  return v6 / (double)v11;
}

double CIVNBoundingRect(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  double v5;
  double v6;
  double v7;
  double v8;
  uint64_t i;
  void *v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  _BYTE v24[128];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v2 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v20, v24, 16);
  if (!v2)
    return 1.79769313e308;
  v3 = v2;
  v4 = *(_QWORD *)v21;
  v5 = -1.79769313e308;
  v6 = 1.79769313e308;
  v7 = 1.79769313e308;
  v8 = -1.79769313e308;
  do
  {
    for (i = 0; i != v3; ++i)
    {
      if (*(_QWORD *)v21 != v4)
        objc_enumerationMutation(a1);
      v10 = *(void **)(*((_QWORD *)&v20 + 1) + 8 * i);
      objc_msgSend(v10, "X");
      if (v6 >= v11)
      {
        objc_msgSend(v10, "X");
        v6 = v12;
      }
      objc_msgSend(v10, "Y");
      if (v7 >= v13)
      {
        objc_msgSend(v10, "Y");
        v7 = v14;
      }
      objc_msgSend(v10, "X");
      if (v5 <= v15)
      {
        objc_msgSend(v10, "X");
        v5 = v16;
      }
      objc_msgSend(v10, "Y");
      if (v8 <= v17)
      {
        objc_msgSend(v10, "Y");
        v8 = v18;
      }
    }
    v3 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v20, v24, 16);
  }
  while (v3);
  return v6;
}

id CIVNLandmarkInOrientedImage(void *a1, void *a2)
{
  uint64_t v4;

  v4 = CIVNgetOrientation(a2);
  return denormalizedOrientatedLandmarkPoints(a1, a2, v4);
}

id denormalizedOrientatedLandmarkPoints(void *a1, void *a2, uint64_t a3)
{
  uint64_t v6;
  double v7;
  double v8;
  double v9;
  double v10;
  uint64_t v11;
  __int128 v12;
  void *v13;
  double *v14;
  CGAffineTransform v16;
  CGAffineTransform v17;
  CGAffineTransform v18;

  v6 = objc_msgSend(a1, "pointCount");
  objc_msgSend(a2, "extent");
  if ((a3 - 5) >= 4)
    v9 = v7;
  else
    v9 = v8;
  if ((a3 - 5) >= 4)
    v10 = v8;
  else
    v10 = v7;
  v11 = objc_msgSend(a1, "pointsInImageOfSize:", v9, v10);
  v12 = 0uLL;
  memset(&v18, 0, sizeof(v18));
  if (a2)
  {
    objc_msgSend(a2, "imageTransformForOrientation:", a3);
    v12 = 0uLL;
  }
  *(_OWORD *)&v17.c = v12;
  *(_OWORD *)&v17.tx = v12;
  *(_OWORD *)&v17.a = v12;
  v16 = v18;
  CGAffineTransformInvert(&v17, &v16);
  v13 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", v6);
  if (v6)
  {
    v14 = (double *)(v11 + 8);
    do
    {
      objc_msgSend(v13, "addObject:", +[CIVector vectorWithCGPoint:](CIVector, "vectorWithCGPoint:", vaddq_f64(*(float64x2_t *)&v17.tx, vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&v17.c, *v14), *(float64x2_t *)&v17.a, *(v14 - 1)))));
      v14 += 2;
      --v6;
    }
    while (v6);
  }
  return v13;
}

void CIVNRectInOrientedImage(void *a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CGAffineTransform v14;
  CGAffineTransform v15;
  CGAffineTransform v16;
  CGRect v17;
  CGRect v18;
  CGRect v19;

  memset(&v16, 0, sizeof(v16));
  denormalizationTransform(a1, (uint64_t)&v16);
  v15 = v16;
  v17.origin.x = a2;
  v17.origin.y = a3;
  v17.size.width = a4;
  v17.size.height = a5;
  v18 = CGRectApplyAffineTransform(v17, &v15);
  x = v18.origin.x;
  y = v18.origin.y;
  width = v18.size.width;
  height = v18.size.height;
  memset(&v15, 0, sizeof(v15));
  orientationTransform(a1, (uint64_t)&v15);
  v14 = v15;
  v19.origin.x = x;
  v19.origin.y = y;
  v19.size.width = width;
  v19.size.height = height;
  CGRectApplyAffineTransform(v19, &v14);
}

CGAffineTransform *denormalizationTransform@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  double v4;
  double v5;
  double v6;
  double v7;
  unsigned int v8;
  CGFloat v9;
  CGFloat v10;

  objc_msgSend(a1, "extent");
  v5 = v4;
  v7 = v6;
  v8 = CIVNgetOrientation(a1) - 5;
  if (v8 >= 4)
    v9 = v5;
  else
    v9 = v7;
  if (v8 >= 4)
    v10 = v7;
  else
    v10 = v5;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  return CGAffineTransformMakeScale((CGAffineTransform *)a2, v9, v10);
}

CGAffineTransform *orientationTransform@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  __int128 v5;
  CGAffineTransform v7[2];

  v4 = CIVNgetOrientation(a1);
  v5 = 0uLL;
  memset(&v7[1], 0, sizeof(CGAffineTransform));
  if (a1)
  {
    objc_msgSend(a1, "imageTransformForOrientation:", v4);
    v5 = 0uLL;
  }
  *(_OWORD *)(a2 + 16) = v5;
  *(_OWORD *)(a2 + 32) = v5;
  *(_OWORD *)a2 = v5;
  v7[0] = v7[1];
  return CGAffineTransformInvert((CGAffineTransform *)a2, v7);
}

double CIVNPointInOrientedImage(void *a1, double a2, double a3)
{
  double result;
  double v7;
  double v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  v13 = 0u;
  v14 = 0u;
  v12 = 0u;
  denormalizationTransform(a1, (uint64_t)&v12);
  v8 = *(double *)&v14 + a3 * *(double *)&v13 + *(double *)&v12 * a2;
  v7 = *((double *)&v14 + 1) + a3 * *((double *)&v13 + 1) + *((double *)&v12 + 1) * a2;
  v10 = 0u;
  v11 = 0u;
  v9 = 0u;
  orientationTransform(a1, (uint64_t)&v9);
  *(_QWORD *)&result = *(_OWORD *)&vaddq_f64(v11, vmlaq_n_f64(vmulq_n_f64(v10, v7), v9, v8));
  return result;
}

void *CIVNOrientedImageLandmarkEyeRegions(void *a1, void *a2, CIContext *a3)
{
  CIContext *v3;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t i;
  CGFloat v10;
  CGFloat v11;
  CGFloat v12;
  CGFloat v13;
  void *v14;
  void *v15;
  uint64_t v16;
  id v17;
  void *v18;
  uint64_t v19;
  id v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double height;
  double width;
  double y;
  double x;
  _QWORD v34[3];
  _QWORD v35[3];
  _QWORD v36[3];
  _QWORD v37[5];
  CGRect v38;
  CGRect v39;
  CGRect v40;
  CGRect v41;
  CGRect v42;
  CGRect v43;

  v3 = a3;
  v37[3] = *MEMORY[0x1E0C80C00];
  if (!a3)
    v3 = +[CIContext context](CIContext, "context");
  v36[0] = CFSTR("kCIVNDetectOptionRequestLandmarks");
  v36[1] = CFSTR("kCIVNDetectOptionRequestAttributes");
  v37[0] = MEMORY[0x1E0C9AAB0];
  v37[1] = MEMORY[0x1E0C9AAA0];
  v36[2] = CFSTR("kCIVNDetectOptionRequestPose");
  v37[2] = MEMORY[0x1E0C9AAA0];
  v6 = (void *)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v37, v36, 3);
  if (!a2)
  {
    a2 = (void *)CIVNDetectFaces((uint64_t)a1, 1, (uint64_t)v3, v6);
    if (!a2)
      return 0;
  }
  if (!objc_msgSend(a2, "count"))
    return 0;
  v7 = objc_msgSend(a2, "count");
  v8 = (void *)objc_msgSend(MEMORY[0x1E0C99DE8], "arrayWithCapacity:", v7);
  if (v7)
  {
    for (i = 0; i != v7; ++i)
    {
      objc_msgSend((id)objc_msgSend(a2, "objectAtIndexedSubscript:", i), "boundingBox");
      CIVNRectInOrientedImage(a1, v10, v11, v12, v13);
      v39 = CGRectIntegral(v38);
      y = v39.origin.y;
      x = v39.origin.x;
      height = v39.size.height;
      width = v39.size.width;
      v14 = (void *)objc_msgSend(a2, "objectAtIndex:", i);
      v15 = (void *)objc_msgSend((id)objc_msgSend(v14, "landmarks"), "leftEye");
      v16 = CIVNgetOrientation(a1);
      v17 = denormalizedOrientatedLandmarkPoints(v15, a1, v16);
      v18 = (void *)objc_msgSend((id)objc_msgSend(v14, "landmarks"), "rightEye");
      v19 = CIVNgetOrientation(a1);
      v20 = denormalizedOrientatedLandmarkPoints(v18, a1, v19);
      v40.origin.x = CIVNBoundingRect(v17);
      v41 = CGRectIntegral(v40);
      v21 = v41.origin.x;
      v22 = v41.origin.y;
      v23 = v41.size.width;
      v24 = v41.size.height;
      v42.origin.x = CIVNBoundingRect(v20);
      v43 = CGRectIntegral(v42);
      v25 = v43.origin.x;
      v26 = v43.origin.y;
      v27 = v43.size.width;
      v28 = v43.size.height;
      v34[0] = CFSTR("face");
      v35[0] = +[CIVector vectorWithCGRect:](CIVector, "vectorWithCGRect:", x, y, width, height);
      v34[1] = CFSTR("leftEye");
      v35[1] = +[CIVector vectorWithCGRect:](CIVector, "vectorWithCGRect:", v21, v22, v23, v24);
      v34[2] = CFSTR("rightEye");
      v35[2] = +[CIVector vectorWithCGRect:](CIVector, "vectorWithCGRect:", v25, v26, v27, v28);
      objc_msgSend(v8, "setObject:atIndexedSubscript:", objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v35, v34, 3), i);
    }
  }
  return v8;
}

uint64_t CIVNDenormalizedLandmarks(void *a1, uint64_t a2, void *a3)
{
  void *v5;
  _QWORD v7[13];
  _QWORD v8[14];

  v8[13] = *MEMORY[0x1E0C80C00];
  v5 = (void *)objc_msgSend(a3, "landmarks");
  v7[0] = CFSTR("allPoints");
  v8[0] = denormalizedOrientatedLandmarkPoints((void *)objc_msgSend(v5, "allPoints"), a1, a2);
  v7[1] = CFSTR("faceContour");
  v8[1] = denormalizedOrientatedLandmarkPoints((void *)objc_msgSend(v5, "faceContour"), a1, a2);
  v7[2] = CFSTR("innerLips");
  v8[2] = denormalizedOrientatedLandmarkPoints((void *)objc_msgSend(v5, "innerLips"), a1, a2);
  v7[3] = CFSTR("leftEye");
  v8[3] = denormalizedOrientatedLandmarkPoints((void *)objc_msgSend(v5, "leftEye"), a1, a2);
  v7[4] = CFSTR("leftEyebrow");
  v8[4] = denormalizedOrientatedLandmarkPoints((void *)objc_msgSend(v5, "leftEyebrow"), a1, a2);
  v7[5] = CFSTR("leftPupil");
  v8[5] = denormalizedOrientatedLandmarkPoints((void *)objc_msgSend(v5, "leftPupil"), a1, a2);
  v7[6] = CFSTR("medianLine");
  v8[6] = denormalizedOrientatedLandmarkPoints((void *)objc_msgSend(v5, "medianLine"), a1, a2);
  v7[7] = CFSTR("nose");
  v8[7] = denormalizedOrientatedLandmarkPoints((void *)objc_msgSend(v5, "nose"), a1, a2);
  v7[8] = CFSTR("noseCrest");
  v8[8] = denormalizedOrientatedLandmarkPoints((void *)objc_msgSend(v5, "noseCrest"), a1, a2);
  v7[9] = CFSTR("outerLips");
  v8[9] = denormalizedOrientatedLandmarkPoints((void *)objc_msgSend(v5, "outerLips"), a1, a2);
  v7[10] = CFSTR("rightEye");
  v8[10] = denormalizedOrientatedLandmarkPoints((void *)objc_msgSend(v5, "rightEye"), a1, a2);
  v7[11] = CFSTR("rightEyebrow");
  v8[11] = denormalizedOrientatedLandmarkPoints((void *)objc_msgSend(v5, "rightEyebrow"), a1, a2);
  v7[12] = CFSTR("rightPupil");
  v8[12] = denormalizedOrientatedLandmarkPoints((void *)objc_msgSend(v5, "rightPupil"), a1, a2);
  return objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v8, v7, 13);
}

uint64_t VisionLibrary_2()
{
  void *v1;
  __int128 v2;
  uint64_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v1 = 0;
  if (!VisionLibraryCore_frameworkLibrary_2)
  {
    v2 = xmmword_1E2EC5450;
    v3 = 0;
    VisionLibraryCore_frameworkLibrary_2 = _sl_dlopen();
  }
  if (!VisionLibraryCore_frameworkLibrary_2)
    VisionLibrary_cold_1(&v1);
  return VisionLibraryCore_frameworkLibrary_2;
}

void __Block_byref_object_copy__19(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__19(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

Class __getVNImageRequestHandlerClass_block_invoke_0(uint64_t a1)
{
  Class result;

  VisionLibrary_2();
  result = objc_getClass("VNImageRequestHandler");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getVNImageRequestHandlerClass_block_invoke_cold_1();
  getVNImageRequestHandlerClass_softClass_0 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getVNDetectFaceRectanglesRequestClass_block_invoke(uint64_t a1)
{
  Class result;

  VisionLibrary_2();
  result = objc_getClass("VNDetectFaceRectanglesRequest");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getVNDetectFaceRectanglesRequestClass_block_invoke_cold_1();
  getVNDetectFaceRectanglesRequestClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getVNClassifyFaceAttributesRequestClass_block_invoke(uint64_t a1)
{
  Class result;

  VisionLibrary_2();
  result = objc_getClass("VNClassifyFaceAttributesRequest");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getVNClassifyFaceAttributesRequestClass_block_invoke_cold_1();
  getVNClassifyFaceAttributesRequestClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getVNDetectFaceLandmarksRequestClass_block_invoke(uint64_t a1)
{
  Class result;

  VisionLibrary_2();
  result = objc_getClass("VNDetectFaceLandmarksRequest");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getVNDetectFaceLandmarksRequestClass_block_invoke_cold_1();
  getVNDetectFaceLandmarksRequestClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getVNDetectFacePoseRequestClass_block_invoke(uint64_t a1)
{
  Class result;

  VisionLibrary_2();
  result = objc_getClass("VNDetectFacePoseRequest");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getVNDetectFacePoseRequestClass_block_invoke_cold_1();
  getVNDetectFacePoseRequestClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class __getVNGenerateFaceSegmentsRequestClass_block_invoke(uint64_t a1)
{
  Class result;

  VisionLibrary_2();
  result = objc_getClass("VNGenerateFaceSegmentsRequest");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    __getVNGenerateFaceSegmentsRequestClass_block_invoke_cold_1();
  getVNGenerateFaceSegmentsRequestClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t OUTLINED_FUNCTION_3_6(uint64_t a1)
{
  return *(_QWORD *)a1;
}

void cikernel::_vortexDistortion(CI *a1, float32x2_t a2, double a3)
{
  float32x2_t *DC;
  float32x2_t v5;
  float v6;
  float v7;

  DC = (float32x2_t *)CI::getDC(a1);
  v5 = vsub_f32(*DC, a2);
  v6 = sqrtf(vaddv_f32(vmul_f32(v5, v5)));
  v7 = (float)(v6 * *(float *)&a3) + -1.0;
  if (v7 >= 0.0)
    CI::getDC((CI *)DC);
  else
    __sincosf_stret(vmuls_lane_f32(v7 * v7, *(float32x2_t *)&a3, 1) / v6);
}

void vortexTracePoint(CGRect *a1, double a2, float32x2_t a3, float a4, float a5)
{
  float32x2_t v7;
  double v8;
  double v9;
  float v10;
  __float2 v12;
  int32x2_t v14;
  float32x2_t v20;
  CGRect v21;

  v7 = vsub_f32(*(float32x2_t *)&a2, a3);
  v8 = sqrtf(vaddv_f32(vmul_f32(v7, v7)));
  v9 = a4 * v8;
  if (v9 < 1.0)
  {
    v10 = a5 / v8 * ((1.0 - v9) * (1.0 - v9));
    v20 = v7;
    v12 = __sincosf_stret(v10);
    _S0 = v12.__sinval;
    _S4 = v20.i32[0];
    v14 = (int32x2_t)vmul_f32(v20, (float32x2_t)__PAIR64__(LODWORD(v12.__sinval), LODWORD(v12.__cosval)));
    v14.i32[0] = vadd_f32((float32x2_t)v14, (float32x2_t)vdup_lane_s32(v14, 1)).u32[0];
    __asm { FMLS            S1, S0, V4.S[0] }
    v14.i32[1] = _S1;
    a2 = COERCE_DOUBLE(vadd_f32(a3, (float32x2_t)v14));
  }
  v21.origin.x = *(float *)&a2;
  v21.origin.y = *((float *)&a2 + 1);
  v21.size.width = 0.0;
  v21.size.height = 0.0;
  *a1 = CGRectUnion(*a1, v21);
}

float32x2_t cikernel::_wrapMirror(CI *a1, int8x16_t a2)
{
  float32x2_t *DC;
  float32x2_t v3;

  DC = (float32x2_t *)CI::getDC(a1);
  v3 = (float32x2_t)vextq_s8(a2, a2, 8uLL).u64[0];
  return vminnm_f32(vsub_f32(vadd_f32(v3, v3), vsub_f32(*DC, *(float32x2_t *)a2.i8)), vabd_f32(*DC, *(float32x2_t *)a2.i8));
}

uint64_t ci_logger_general()
{
  if (ci_logger_general_onceToken != -1)
    dispatch_once(&ci_logger_general_onceToken, &__block_literal_global_71);
  return ci_logger_general_logger;
}

os_log_t __ci_logger_general_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "general");
  ci_logger_general_logger = (uint64_t)result;
  return result;
}

uint64_t ci_logger_api()
{
  if (ci_logger_api_onceToken != -1)
    dispatch_once(&ci_logger_api_onceToken, &__block_literal_global_4_0);
  return ci_logger_api_logger;
}

os_log_t __ci_logger_api_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "api");
  ci_logger_api_logger = (uint64_t)result;
  return result;
}

uint64_t ci_logger_render()
{
  if (ci_logger_render_onceToken != -1)
    dispatch_once(&ci_logger_render_onceToken, &__block_literal_global_7);
  return ci_logger_render_logger;
}

os_log_t __ci_logger_render_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "render");
  ci_logger_render_logger = (uint64_t)result;
  return result;
}

uint64_t ci_logger_performance()
{
  if (ci_logger_performance_onceToken != -1)
    dispatch_once(&ci_logger_performance_onceToken, &__block_literal_global_10_0);
  return ci_logger_performance_logger;
}

os_log_t __ci_logger_performance_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "performance");
  ci_logger_performance_logger = (uint64_t)result;
  return result;
}

uint64_t ci_logger_compile()
{
  if (ci_logger_compile_onceToken != -1)
    dispatch_once(&ci_logger_compile_onceToken, &__block_literal_global_13);
  return ci_logger_compile_logger;
}

os_log_t __ci_logger_compile_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "compile");
  ci_logger_compile_logger = (uint64_t)result;
  return result;
}

uint64_t ci_logger_cache()
{
  if (ci_logger_cache_onceToken != -1)
    dispatch_once(&ci_logger_cache_onceToken, &__block_literal_global_16);
  return ci_logger_cache_logger;
}

os_log_t __ci_logger_cache_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "cache");
  ci_logger_cache_logger = (uint64_t)result;
  return result;
}

uint64_t ci_logger_filter()
{
  if (ci_logger_filter_onceToken != -1)
    dispatch_once(&ci_logger_filter_onceToken, &__block_literal_global_19);
  return ci_logger_filter_logger;
}

os_log_t __ci_logger_filter_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "filter");
  ci_logger_filter_logger = (uint64_t)result;
  return result;
}

uint64_t ci_signpost_log_compile()
{
  if (ci_signpost_log_compile_onceToken != -1)
    dispatch_once(&ci_signpost_log_compile_onceToken, &__block_literal_global_4_1);
  return ci_signpost_log_compile_log;
}

os_log_t __ci_signpost_log_compile_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "signpost_compile");
  ci_signpost_log_compile_log = (uint64_t)result;
  return result;
}

uint64_t ci_signpost_log_cache()
{
  if (ci_signpost_log_cache_onceToken != -1)
    dispatch_once(&ci_signpost_log_cache_onceToken, &__block_literal_global_7_0);
  return ci_signpost_log_cache_log;
}

os_log_t __ci_signpost_log_cache_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "signpost_cache");
  ci_signpost_log_cache_log = (uint64_t)result;
  return result;
}

uint64_t ci_signpost_log_detector()
{
  if (ci_signpost_log_detector_onceToken != -1)
    dispatch_once(&ci_signpost_log_detector_onceToken, &__block_literal_global_10_1);
  return ci_signpost_log_detector_log;
}

os_log_t __ci_signpost_log_detector_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "signpost_detector");
  ci_signpost_log_detector_log = (uint64_t)result;
  return result;
}

uint64_t ci_signpost_log_dualredeye()
{
  if (ci_signpost_log_dualredeye_onceToken != -1)
    dispatch_once(&ci_signpost_log_dualredeye_onceToken, &__block_literal_global_19_0);
  return ci_signpost_log_dualredeye_log;
}

os_log_t __ci_signpost_log_dualredeye_block_invoke()
{
  os_log_t result;

  result = os_log_create("com.apple.coreimage", "signpost_dualredeye");
  ci_signpost_log_dualredeye_log = (uint64_t)result;
  return result;
}

const char *_indent_str()
{
  return " . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "
         ". . . . . . . . . . . . . . . . . .";
}

CFTypeRef linearP3ColorSpace()
{
  if (linearP3ColorSpace::onceToken != -1)
    dispatch_once(&linearP3ColorSpace::onceToken, &__block_literal_global_73);
  CGColorSpaceRetain((CGColorSpaceRef)linearP3ColorSpace::cachedCS);
  return CFAutorelease((CFTypeRef)linearP3ColorSpace::cachedCS);
}

void __linearP3ColorSpace_block_invoke()
{
  CFDataRef v0;

  v0 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], linearP3ColorSpace::data, 572, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  linearP3ColorSpace::cachedCS = MEMORY[0x194024A50]();
  CFRelease(v0);
}

uint64_t SDOFV2MetalLib()
{
  if (SDOFV2MetalLib::onceToken != -1)
    dispatch_once(&SDOFV2MetalLib::onceToken, &__block_literal_global_15);
  return SDOFV2MetalLib::data;
}

double shiftmapSize(double a1, double a2, double a3, double a4, double a5, double a6)
{
  double v6;

  v6 = a2 * 0.5;
  if (a2 * 0.5 <= a4 * (a6 * 0.5 / a4))
    v6 = a4 * (a6 * 0.5 / a4);
  if (v6 >= a2)
    v6 = a2;
  if (v6 <= a4)
    v6 = a4;
  return v6 / (a2 / a1);
}

uint64_t useMetalImage(void *a1)
{
  if (useMetalImage::onceToken != -1)
    dispatch_once(&useMetalImage::onceToken, &__block_literal_global_36_2);
  if (useMetalImage::useNativeImageAlways == 1)
    return objc_msgSend((id)objc_msgSend(a1, "objectForKey:", CFSTR("kContextInfoIsMetal")), "BOOLValue");
  else
    return 0;
}

const char *__useMetalImage_block_invoke()
{
  const char *result;

  result = getenv("CI_METAL_SDOF");
  if (result)
  {
    result = (const char *)atoi(result);
    if ((_DWORD)result)
      useMetalImage::useNativeImageAlways = 1;
  }
  return result;
}

void *SDOFBlurmapSmoothingParameterValue(NSString *a1, void *a2)
{
  void *v3;
  void *v4;

  if (a2
    && (v3 = (void *)objc_msgSend(a2, "objectForKey:", CFSTR("BlurMapSmoothing"))) != 0
    && (v4 = (void *)objc_msgSend(v3, "objectForKey:", a1)) != 0)
  {
    return (void *)objc_msgSend(v4, "floatValue");
  }
  else
  {
    return SDOFParameterValue(CFSTR("BlurMapSmoothing"), a1);
  }
}

void *SDOFParameterValue(NSString *a1, NSString *a2)
{
  void *result;
  uint64_t v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;

  if (SDOFParameterValue(NSString *,NSString *)::onceToken != -1)
    dispatch_once(&SDOFParameterValue(NSString *,NSString *)::onceToken, &__block_literal_global_821);
  if (SDOFParameterValue(NSString *,NSString *)::onceToken2 != -1)
    dispatch_once(&SDOFParameterValue(NSString *,NSString *)::onceToken2, &__block_literal_global_824);
  result = (void *)objc_msgSend((id)SDOFParameterValue(NSString *,NSString *)::sdofParameters, "objectForKeyedSubscript:", a1);
  if (result)
  {
    v5 = objc_msgSend(result, "objectForKey:", a2);
    if (!v5)
    {
      if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("RenderingV3"))
        && (v6 = (void *)objc_msgSend((id)SDOFParameterValue(NSString *,NSString *)::sdofParameters, "objectForKeyedSubscript:", CFSTR("Rendering"))) != 0)
      {
        v5 = objc_msgSend(v6, "objectForKey:", a2);
      }
      else
      {
        v5 = 0;
      }
    }
    if (SDOFParameterValue(NSString *,NSString *)::sdofParametersOnDevice)
    {
      v7 = (void *)objc_msgSend((id)SDOFParameterValue(NSString *,NSString *)::sdofParametersOnDevice, "objectForKey:", a1);
      if (!v7
        || (v8 = objc_msgSend(v7, "objectForKey:", a2)) == 0
        || (v9 = (void *)v8, objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
      {
        v9 = (void *)v5;
        if (!v5)
        {
          if (-[NSString isEqualToString:](a1, "isEqualToString:", CFSTR("RenderingV3"))
            && (v10 = (void *)objc_msgSend((id)SDOFParameterValue(NSString *,NSString *)::sdofParametersOnDevice, "objectForKey:", CFSTR("Rendering"))) != 0&& (v11 = objc_msgSend(v10, "objectForKey:", a2)) != 0)
          {
            v12 = (void *)v11;
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0)
              v9 = v12;
            else
              v9 = 0;
          }
          else
          {
            v9 = 0;
          }
        }
      }
    }
    else
    {
      v9 = (void *)v5;
    }
    return (void *)objc_msgSend(v9, "floatValue");
  }
  return result;
}

void *SDOFDisparitySmoothingParameterValue(NSString *a1, void *a2)
{
  void *v3;
  void *v4;

  if (a2
    && (v3 = (void *)objc_msgSend(a2, "objectForKey:", CFSTR("DisparitySmoothing"))) != 0
    && (v4 = (void *)objc_msgSend(v3, "objectForKey:", a1)) != 0)
  {
    return (void *)objc_msgSend(v4, "floatValue");
  }
  else
  {
    return SDOFParameterValue(CFSTR("DisparitySmoothing"), a1);
  }
}

void *SDOFDisparityRefinementParameterValue(NSString *a1, void *a2)
{
  void *v3;
  void *v4;

  if (a2
    && (v3 = (void *)objc_msgSend(a2, "objectForKey:", CFSTR("DisparityRefinement"))) != 0
    && (v4 = (void *)objc_msgSend(v3, "objectForKey:", a1)) != 0)
  {
    return (void *)objc_msgSend(v4, "floatValue");
  }
  else
  {
    return SDOFParameterValue(CFSTR("DisparityRefinement"), a1);
  }
}

void *SDOFRenderingValue(NSString *a1, void *a2)
{
  void *v4;
  void *v5;
  __CFString *v7;

  if (a2)
  {
    v4 = (void *)objc_msgSend(a2, "objectForKey:", CFSTR("Rendering"));
    if (v4)
    {
      v5 = (void *)objc_msgSend(v4, "objectForKey:", a1);
      if (v5)
        return (void *)objc_msgSend(v5, "floatValue");
    }
  }
  if (objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("Version")), "intValue") == 2)
    v7 = CFSTR("RenderingV3");
  else
    v7 = CFSTR("Rendering");
  return SDOFParameterValue(&v7->isa, a1);
}

uint64_t SDOFSimpleLensModelValue(void *a1, void *a2)
{
  void *v3;
  void *v4;
  uint64_t result;

  if (a2)
  {
    v3 = (void *)objc_msgSend(a2, "objectForKey:", CFSTR("SLM"));
    if (v3)
    {
      v4 = (void *)objc_msgSend(v3, "objectForKey:", a1);
      if (v4)
        return objc_msgSend(v4, "floatValue");
    }
  }
  result = objc_msgSend(a1, "isEqualToString:", CFSTR("defaultSimulatedAperture"));
  if ((result & 1) == 0)
  {
    result = objc_msgSend(a1, "isEqualToString:", CFSTR("disparityScalingFactor"));
    if ((result & 1) == 0)
      return (uint64_t)SDOFParameterValue(CFSTR("SLM"), (NSString *)a1);
  }
  return result;
}

void *SDOFFaceMaskValue(uint64_t a1, void *a2)
{
  NSString *v3;
  void *v4;

  v3 = (NSString *)objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("faces.%@"), a1);
  if (a2
    && objc_msgSend(a2, "objectForKey:", CFSTR("Rendering"))
    && (v4 = (void *)objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("Rendering")), "objectForKey:", v3)) != 0)
  {
    return (void *)objc_msgSend(v4, "floatValue");
  }
  else
  {
    return SDOFParameterValue(CFSTR("Rendering"), v3);
  }
}

void *SDOFHighlightRecoveryValue(NSString *a1, void *a2)
{
  void *v3;
  void *v4;

  if (a2
    && (v3 = (void *)objc_msgSend(a2, "objectForKey:", CFSTR("HighlightRecovery"))) != 0
    && (v4 = (void *)objc_msgSend(v3, "objectForKey:", a1)) != 0)
  {
    return (void *)objc_msgSend(v4, "floatValue");
  }
  else
  {
    return SDOFParameterValue(CFSTR("xhlrb"), a1);
  }
}

uint64_t SDOFFusionValue(NSString *a1, NSDictionary *a2)
{
  id v3;
  void *v4;

  if (!a2
    || (v3 = -[NSDictionary objectForKey:](a2, "objectForKey:", CFSTR("Fusion"))) == 0
    || (v4 = (void *)objc_msgSend(v3, "objectForKey:", a1)) == 0)
  {
    v4 = (void *)objc_msgSend(&unk_1E2F1D760, "objectForKeyedSubscript:", a1);
  }
  return objc_msgSend(v4, "floatValue");
}

CIVector *transformNormalizedMetalToCI(void *a1, unsigned int a2, double a3)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unsigned int v9;
  double v10;
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)objc_msgSend(a1, "count") >= 8)
  {
    v13 = xmmword_192498DB8;
    v14 = unk_192498DC8;
    v7 = 4;
  }
  else
  {
    v6 = objc_msgSend(a1, "count");
    v13 = xmmword_192498DB8;
    v14 = unk_192498DC8;
    if (v6 < 2)
      return +[CIVector vectorWithValues:count:](CIVector, "vectorWithValues:count:", &v13, 4);
    v7 = v6 >> 1;
  }
  v8 = 0;
  v9 = 1;
  do
  {
    objc_msgSend(a1, "valueAtIndex:", a2, v13, v14);
    *((double *)&v13 + v8) = v10 * a3;
    v8 = v9;
    a2 += 2;
  }
  while (v7 > v9++);
  return +[CIVector vectorWithValues:count:](CIVector, "vectorWithValues:count:", &v13, 4);
}

uint64_t SDOFBlurMapRefinementValue(NSString *a1, NSDictionary *a2)
{
  id v3;
  void *v4;

  if (!a2
    || (v3 = -[NSDictionary objectForKey:](a2, "objectForKey:", CFSTR("BlurMapRefinement"))) == 0
    || (v4 = (void *)objc_msgSend(v3, "objectForKey:", a1)) == 0)
  {
    v4 = (void *)objc_msgSend(&unk_1E2F1D788, "objectForKeyedSubscript:", a1);
  }
  return objc_msgSend(v4, "floatValue");
}

void sub_1923968E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id getRenderingParametersFromCGImageMetadata(const CGImageMetadata *a1)
{
  CFTypeID TypeID;
  CGImageMetadataTag *v3;
  CGImageMetadataTag *v4;
  CFTypeRef v5;
  id v7;

  TypeID = CGImageMetadataGetTypeID();
  if (TypeID != CFGetTypeID(a1))
    return 0;
  v3 = CGImageMetadataCopyTagWithPath(a1, 0, CFSTR("depthBlurEffect:RenderingParameters"));
  if (!v3)
    return 0;
  v4 = v3;
  if (CGImageMetadataTagGetType(v3) == kCGImageMetadataTypeString)
  {
    v5 = CGImageMetadataTagCopyValue(v4);
    v7 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBase64EncodedString:options:", (id)CFMakeCollectable(v5), 0);
  }
  else
  {
    v7 = 0;
  }
  CFRelease(v4);
  return v7;
}

CFTypeRef metadataFromValue(CFTypeRef cf)
{
  void *v1;
  CFTypeID v2;
  CGImageMetadataRef v3;

  v1 = (void *)cf;
  if (!cf)
    return v1;
  v2 = CFGetTypeID(cf);
  if (CGImageMetadataGetTypeID() == v2)
    return v1;
  if (CFStringGetTypeID() == v2)
  {
    if ((unint64_t)objc_msgSend(v1, "length") > 1)
    {
      v1 = (void *)objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", objc_msgSend(v1, "UTF8String"), objc_msgSend(v1, "length"));
      if (!v1)
        return v1;
      goto LABEL_8;
    }
  }
  else if (CFDataGetTypeID() == v2)
  {
LABEL_8:
    v3 = CGImageMetadataCreateFromXMPData((CFDataRef)v1);
    if (v3)
      return CFAutorelease(v3);
  }
  return 0;
}

const CGImageMetadata *tuningParametersFromMetaData(const CGImageMetadata *a1)
{
  CFTypeID TypeID;
  CGImageMetadataTag *v3;
  CGImageMetadataTag *v4;
  CFTypeRef v5;
  id v6;
  uint64_t v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  void *v28;
  uint64_t *v29;
  const __CFString **v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  double v47;
  uint64_t v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  uint64_t v59;
  double v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  double v66;
  double v67;
  double v68;
  double v69;
  double v70;
  double v71;
  double v72;
  double v73;
  double v74;
  double v75;
  double v76;
  double v77;
  double v78;
  double v79;
  double v80;
  double v81;
  double v82;
  double v83;
  double v84;
  double v85;
  double v86;
  double v87;
  double v88;
  double v89;
  double v90;
  double v91;
  double v92;
  double v93;
  double v94;
  double v95;
  double v96;
  double v97;
  double v98;
  double v99;
  double v100;
  double v101;
  double v102;
  double v103;
  int v104;
  double v105;
  double v106;
  double v107;
  double v108;
  double v109;
  double v110;
  double v111;
  double v112;
  uint64_t v113;
  double v114;
  double v115;
  double v116;
  double v117;
  double v118;
  double v119;
  double v120;
  double v121;
  double v122;
  double v123;
  uint64_t v124;
  double v125;
  double v126;
  double v127;
  double v128;
  double v129;
  double v130;
  double v131;
  double v132;
  double v133;
  double v134;
  double v135;
  double v136;
  double v137;
  double v138;
  double v139;
  double v140;
  double v141;
  double v142;
  double v143;
  double v144;
  double v145;
  double v146;
  double v147;
  double v148;
  double v149;
  double v150;
  double v151;
  double v152;
  double v153;
  double v154;
  double v155;
  double v156;
  double v157;
  double v158;
  double v159;
  double v160;
  double v161;
  double v162;
  double v163;
  double v164;
  double v165;
  double v166;
  double v167;
  double v168;
  double v169;
  double v170;
  double v171;
  double v172;
  double v173;
  double v174;
  double v175;
  double v176;
  double v177;
  double v178;
  double v179;
  double v180;
  double v181;
  double v182;
  double v183;
  double v184;
  double v185;
  double v186;
  double v187;
  double v188;
  double v189;
  double v190;
  double v191;
  double v192;
  double v193;
  double v194;
  double v195;
  double v196;
  double v197;
  double v198;
  double v199;
  double v200;
  double v201;
  double v202;
  double v203;
  double v204;
  double v205;
  char v206;
  __int128 v207;
  float v208;
  int v209;
  int v210;
  int v211;
  int v212;
  int v213;
  int v214;
  int v215;
  int v216;
  unsigned int v217;
  int v218;
  int v219;
  int v220;
  unsigned int v221;
  int v222;
  int v223;
  int v224;
  int v225;
  int v226;
  int v227;
  int v228;
  int v229;
  float v230;
  float v231;
  float v232;
  float v233;
  float v234;
  float v235;
  unsigned int v236;
  float v237;
  float v238;
  float v239;
  float v240;
  float v241;
  float v242;
  unsigned int v243;
  unsigned int v244;
  int v245;
  float v246;
  int v247;
  unsigned int v248;
  int v249;
  int v250;
  float v251;
  float v252;
  float v253;
  float v254;
  float v255;
  float v256;
  int v257;
  int v258;
  int v259;
  int v260;
  int v261;
  int v262;
  float v263;
  int v264;
  int v265;
  float v266;
  int v267;
  int v268;
  int v269;
  int v270;
  float v271;
  int v272;
  float v273;
  unsigned int v274;
  float v275;
  float v276;
  int v277;
  int v278;
  int v279;
  int v280;
  int v281;
  int v282;
  int v283;
  int v284;
  int v285;
  int v286;
  int v287;
  int v288;
  int v289;
  int v290;
  int v291;
  int v292;
  int v293;
  int v294;
  int v295;
  int v296;
  int v297;
  int v298;
  int v299;
  int v300;
  unsigned int v301;
  int v302;
  int v303;
  int v304;
  int v305;
  int v306;
  int v307;
  int v308;
  int v309;
  int v310;
  int v311;
  int v312;
  int v313;
  int v314;
  const __CFString *v315;
  uint64_t v316;
  const __CFString *v317;
  const __CFString *v318;
  const __CFString *v319;
  const __CFString *v320;
  const __CFString *v321;
  const __CFString *v322;
  const __CFString *v323;
  const __CFString *v324;
  const __CFString *v325;
  const __CFString *v326;
  const __CFString *v327;
  const __CFString *v328;
  const __CFString *v329;
  const __CFString *v330;
  const __CFString *v331;
  const __CFString *v332;
  const __CFString *v333;
  const __CFString *v334;
  const __CFString *v335;
  const __CFString *v336;
  const __CFString *v337;
  const __CFString *v338;
  const __CFString *v339;
  const __CFString *v340;
  const __CFString *v341;
  const __CFString *v342;
  const __CFString *v343;
  const __CFString *v344;
  const __CFString *v345;
  const __CFString *v346;
  const __CFString *v347;
  const __CFString *v348;
  const __CFString *v349;
  const __CFString *v350;
  const __CFString *v351;
  const __CFString *v352;
  const __CFString *v353;
  const __CFString *v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  void *v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  void *v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  const __CFString *v393;
  const __CFString *v394;
  const __CFString *v395;
  const __CFString *v396;
  const __CFString *v397;
  const __CFString *v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  const __CFString *v405;
  const __CFString *v406;
  const __CFString *v407;
  const __CFString *v408;
  const __CFString *v409;
  const __CFString *v410;
  const __CFString *v411;
  const __CFString *v412;
  const __CFString *v413;
  const __CFString *v414;
  const __CFString *v415;
  const __CFString *v416;
  const __CFString *v417;
  const __CFString *v418;
  const __CFString *v419;
  const __CFString *v420;
  const __CFString *v421;
  const __CFString *v422;
  const __CFString *v423;
  const __CFString *v424;
  const __CFString *v425;
  const __CFString *v426;
  const __CFString *v427;
  const __CFString *v428;
  const __CFString *v429;
  const __CFString *v430;
  const __CFString *v431;
  const __CFString *v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  void *v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  void *v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  uint64_t v456;
  uint64_t v457;
  void *v458;
  uint64_t v459;
  uint64_t v460;
  const __CFString *v461;
  const __CFString *v462;
  const __CFString *v463;
  const __CFString *v464;
  const __CFString *v465;
  const __CFString *v466;
  const __CFString *v467;
  const __CFString *v468;
  const __CFString *v469;
  const __CFString *v470;
  const __CFString *v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  uint64_t v475;
  void *v476;
  uint64_t v477;
  void *v478;
  uint64_t v479;
  uint64_t v480;
  uint64_t v481;
  uint64_t v482;
  const __CFString *v483;
  const __CFString *v484;
  const __CFString *v485;
  const __CFString *v486;
  const __CFString *v487;
  const __CFString *v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  const __CFString *v495;
  const __CFString *v496;
  const __CFString *v497;
  const __CFString *v498;
  const __CFString *v499;
  const __CFString *v500;
  const __CFString *v501;
  const __CFString *v502;
  const __CFString *v503;
  const __CFString *v504;
  const __CFString *v505;
  const __CFString *v506;
  const __CFString *v507;
  const __CFString *v508;
  const __CFString *v509;
  const __CFString *v510;
  const __CFString *v511;
  uint64_t v512;
  void *v513;
  void *v514;
  uint64_t v515;
  void *v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  uint64_t v521;
  uint64_t v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  _QWORD v529[5];
  _QWORD v530[5];
  const __CFString *v531;
  const __CFString *v532;
  const __CFString *v533;
  const __CFString *v534;
  const __CFString *v535;
  const __CFString *v536;
  const __CFString *v537;
  const __CFString *v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v543;
  uint64_t v544;
  uint64_t v545;
  void *v546;
  uint64_t v547;

  v547 = *MEMORY[0x1E0C80C00];
  TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a1))
    return a1;
  v3 = CGImageMetadataCopyTagWithPath(a1, 0, CFSTR("depthBlurEffect:RenderingParameters"));
  if (!v3)
    return (const CGImageMetadata *)&unk_1E2F1D7B0;
  v4 = v3;
  if (CGImageMetadataTagGetType(v3) != kCGImageMetadataTypeString
    || (v5 = CGImageMetadataTagCopyValue(v4),
        v6 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBase64EncodedString:options:", (id)CFMakeCollectable(v5), 0), (unint64_t)objc_msgSend(v6, "length") <= 0xB))
  {
    CFRelease(v4);
    return (const CGImageMetadata *)&unk_1E2F1D7B0;
  }
  objc_msgSend(v6, "getBytes:length:", &v355, 12);
  v8 = HIDWORD(v355);
  v206 = 1;
  v9 = +[CIFilter maxSDOFRenderingVersionSupported](CIFilter, "maxSDOFRenderingVersionSupported");
  if (v9 < 4)
    goto LABEL_15;
  if ((int)v8 <= v9)
  {
    v17 = 0;
  }
  else
  {
    v10 = ci_logger_api();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      tuningParametersFromMetaData(v8, v10, v11, v12, v13, v14, v15, v16);
    v17 = 1;
  }
  if ((int)v8 <= 3)
  {
LABEL_15:
    switch((_DWORD)v8)
    {
      case 3:
        v18 = FigDepthBlurEffectRenderingParametersV3FromCFData(v6, &v207);
        break;
      case 2:
        v18 = FigDepthBlurEffectRenderingParametersV2FromCFData(v6, (char *)&v207, (BOOL *)&v206);
        break;
      case 1:
        v18 = FigDepthBlurEffectRenderingParametersV1FromCFData(v6, &v207);
        break;
      default:
        v32 = ci_logger_api();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          tuningParametersFromMetaData(v8, v32, v33, v34, v35, v36, v37, v38);
        CFRelease(v4);
        if ((int)v8 < 1)
          return (const CGImageMetadata *)&unk_1E2F1D7B0;
        v17 = 1;
        goto LABEL_23;
    }
    v17 = v18;
  }
  CFRelease(v4);
LABEL_23:
  v19 = +[CIFilter maxSDOFRenderingVersionSupported](CIFilter, "maxSDOFRenderingVersionSupported");
  a1 = (const CGImageMetadata *)&unk_1E2F1D7B0;
  if (!v17 && (int)v8 <= v19)
  {
    switch((_DWORD)v8)
    {
      case 3:
        v104 = v206;
        v531 = CFSTR("BlurMapSmoothing");
        v529[0] = CFSTR("nIterations");
        v530[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v243);
        v529[1] = CFSTR("originalBlurValueT0");
        LODWORD(v105) = v267;
        v530[1] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v105);
        v529[2] = CFSTR("originalBlurValueT1");
        LODWORD(v106) = v268;
        v530[2] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v106);
        v529[3] = CFSTR("localMinimumBlurValueT0");
        LODWORD(v107) = v269;
        v530[3] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v107);
        v529[4] = CFSTR("localMinimumBlurValueT1");
        LODWORD(v108) = v270;
        v530[4] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v108);
        v539 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v530, v529, 5);
        v532 = CFSTR("DisparityRefinement");
        v495 = CFSTR("radius");
        v512 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", HIDWORD(v207));
        v496 = CFSTR("weightScaling");
        v109 = v232;
        if (!v104)
          v109 = 0.2;
        v513 = (void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v109);
        v497 = CFSTR("maxReconstructionWeight");
        v110 = v233;
        if (!v104)
          v110 = 0.1;
        v514 = (void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v110);
        v498 = CFSTR("innerSamplingRadius");
        v111 = v234;
        if (!v104)
          v111 = 0.5;
        v515 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v111);
        v499 = CFSTR("outerSamplingRadius");
        v112 = v235;
        if (!v104)
          v112 = 2.5;
        v516 = (void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v112);
        v500 = CFSTR("nSamples");
        if (v104)
          v113 = v236;
        else
          v113 = 20;
        v517 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v113);
        v501 = CFSTR("lumaSigma");
        v114 = v237;
        if (!v104)
          v114 = 0.05;
        v518 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v114);
        v502 = CFSTR("chromaSigma");
        v115 = v238;
        if (!v104)
          v115 = 0.02;
        v519 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v115);
        v503 = CFSTR("disparitySigma");
        v116 = v208;
        if (!v104)
          v116 = 0.03;
        v520 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v116);
        v504 = CFSTR("accumulatedWeightT0");
        v117 = v239;
        if (!v104)
          v117 = 0.01;
        v521 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v117);
        v505 = CFSTR("accumulatedWeightT1");
        v118 = v240;
        if (!v104)
          v118 = 0.1;
        v522 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v118);
        v506 = CFSTR("aaLumaSigma");
        LODWORD(v119) = v209;
        v523 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v119);
        v507 = CFSTR("aaChromaSigma");
        LODWORD(v120) = v210;
        v524 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v120);
        v508 = CFSTR("aaSpatialSigma");
        LODWORD(v121) = v211;
        v525 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v121);
        v509 = CFSTR("segmentationSigma");
        LODWORD(v122) = v272;
        if (!v104)
          *(float *)&v122 = 1000.0;
        v526 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v122);
        v510 = CFSTR("aaSegmentationSigma");
        v123 = v273;
        if (!v104)
          v123 = 1.4;
        v527 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v123);
        v511 = CFSTR("Version");
        if (v104)
          v124 = v274;
        else
          v124 = 0;
        v528 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v124);
        v540 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v512, &v495, 17);
        v533 = CFSTR("SLM");
        v483 = CFSTR("shiftDeadZone");
        LODWORD(v125) = v212;
        v489 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v125);
        v484 = CFSTR("zeroShiftPercentile");
        v126 = v241;
        if (!v104)
          v126 = 0.75;
        v490 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v126);
        v485 = CFSTR("maxFGBlur");
        v127 = v242;
        if (!v104)
          v127 = 0.0002;
        v491 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v127);
        v486 = CFSTR("maximumSimulatedAperture");
        v128 = v271;
        if (!v104)
          v128 = 0.0;
        v492 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v128);
        v487 = CFSTR("defaultSimulatedAperture");
        v129 = v275;
        if (!v104)
          v129 = 0.0;
        v493 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v129);
        v488 = CFSTR("disparityScalingFactor");
        v130 = v276;
        if (!v104)
          v130 = 0.0;
        v494 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v130);
        v541 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v489, &v483, 6);
        v534 = CFSTR("HighlightRecovery");
        v461 = CFSTR("iterations");
        v472 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v217);
        v462 = CFSTR("preFilterGain");
        LODWORD(v131) = v218;
        v473 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v131);
        v463 = CFSTR("weightGain");
        LODWORD(v132) = v219;
        v474 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v132);
        v464 = CFSTR("intensityGain");
        LODWORD(v133) = v220;
        v475 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v133);
        v465 = CFSTR("mode");
        v476 = &unk_1E2F1BFB0;
        v466 = CFSTR("blurRadiusT0");
        v134 = v251;
        if (!v104)
          v134 = 0.0025;
        v477 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v134);
        v467 = CFSTR("blurRadiusT1");
        v135 = v252;
        if (!v104)
          v135 = 0.0075;
        v478 = (void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v135);
        v468 = CFSTR("maxIntensityT0");
        v136 = v253;
        if (!v104)
          v136 = 0.9;
        v479 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v136);
        v469 = CFSTR("maxIntensityT1");
        v137 = v254;
        if (!v104)
          v137 = 1.0;
        v480 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v137);
        v470 = CFSTR("minIntensityT0");
        v138 = v255;
        if (!v104)
          v138 = 0.0;
        v481 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v138);
        v471 = CFSTR("minIntensityT1");
        v139 = v256;
        if (!v104)
          v139 = 0.2;
        v482 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v139);
        v542 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v472, &v461, 11);
        v535 = CFSTR("Rendering");
        v405 = CFSTR("faces.linearBlurGrowthC");
        LODWORD(v140) = v214;
        v433 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v140);
        v406 = CFSTR("faces.linearBlurGrowthM");
        LODWORD(v141) = v213;
        v434 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v141);
        v407 = CFSTR("faces.distToBlurScaling");
        LODWORD(v142) = v215;
        v435 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v142);
        v408 = CFSTR("faces.eyeToEyebrowRatio");
        LODWORD(v143) = v216;
        v436 = (void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v143);
        v409 = CFSTR("faces.maxBlurOnEyes");
        LODWORD(v144) = v257;
        v437 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v144);
        v410 = CFSTR("faces.maxBlurDistFromFocus");
        LODWORD(v145) = v258;
        v438 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v145);
        v411 = CFSTR("faces.capMultip");
        LODWORD(v146) = v259;
        v439 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v146);
        v412 = CFSTR("faces.gainMultip");
        LODWORD(v147) = v260;
        v440 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v147);
        v413 = CFSTR("lumaNoiseModelCoeff");
        LODWORD(v148) = v247;
        v441 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v148);
        v414 = CFSTR("relativeWeightThreshold");
        LODWORD(v149) = v222;
        v442 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v149);
        v415 = CFSTR("highlightBoostGain");
        LODWORD(v150) = v223;
        v443 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v150);
        v416 = CFSTR("shapeObstructionCoeff");
        LODWORD(v151) = v224;
        v444 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v151);
        v417 = CFSTR("ringAmplitude");
        LODWORD(v152) = v225;
        v445 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v152);
        v418 = CFSTR("ringSharpness");
        LODWORD(v153) = v226;
        v446 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v153);
        v419 = CFSTR("antiAliasBlurStrength");
        LODWORD(v154) = v228;
        v447 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v154);
        v420 = CFSTR("minimumSimulatedAperture");
        LODWORD(v155) = v229;
        v448 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v155);
        v421 = CFSTR("antiAliasRadius");
        v449 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v248);
        v422 = CFSTR("alphaEpsilon");
        LODWORD(v156) = v249;
        v450 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v156);
        v423 = CFSTR("alphaGain");
        LODWORD(v157) = v250;
        v451 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v157);
        v424 = CFSTR("maxBlur");
        v452 = &unk_1E2F1B2B0;
        v425 = CFSTR("nRings");
        v453 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v221);
        v426 = CFSTR("preFilterBlurStrength");
        LODWORD(v158) = v227;
        v454 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v158);
        v427 = CFSTR("preFilterRadius");
        v455 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v244);
        v428 = CFSTR("sharpRadius");
        LODWORD(v159) = v245;
        v456 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v159);
        v429 = CFSTR("softRadius");
        v160 = v246;
        if (!v104)
          v160 = 1.0;
        v457 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v160);
        v430 = CFSTR("basePixelWeight");
        v458 = &unk_1E2F1B2C0;
        v431 = CFSTR("blendingQuarterResAlphaGain");
        v161 = v230;
        if (!v104)
          v161 = 1.0;
        v459 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v161);
        v432 = CFSTR("blendingFullResAlphaGain");
        v162 = v231;
        if (!v104)
          v162 = 1.0;
        v460 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v162);
        v543 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v433, &v405, 28);
        v536 = CFSTR("Fusion");
        v393 = CFSTR("subtractiveLowerAlpha");
        LODWORD(v163) = v261;
        if (!v104)
          *(float *)&v163 = 0.8;
        v399 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v163);
        v394 = CFSTR("subtractiveUpperAlpha");
        LODWORD(v164) = v262;
        if (!v104)
          *(float *)&v164 = 1.0;
        v400 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v164);
        v395 = CFSTR("subtractiveMaxBlur");
        v165 = v263;
        if (!v104)
          v165 = 0.0;
        v401 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v165);
        v396 = CFSTR("additiveLowerAlpha");
        LODWORD(v166) = v264;
        if (!v104)
          *(float *)&v166 = 0.0;
        v402 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v166);
        v397 = CFSTR("additiveUpperAlpha");
        LODWORD(v167) = v265;
        if (!v104)
          *(float *)&v167 = 0.2;
        v403 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v167);
        v398 = CFSTR("additiveMaxBlur");
        v168 = v266;
        if (!v104)
          v168 = 0.0;
        v404 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v168);
        v544 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v399, &v393, 6);
        v537 = CFSTR("BlurMapRefinement");
        v317 = CFSTR("minimumFocusDistance");
        LODWORD(v169) = v277;
        v355 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v169);
        v318 = CFSTR("maximumFocusDistance");
        LODWORD(v170) = v278;
        v356 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v170);
        v319 = CFSTR("subjectDistanceScalingFactor");
        LODWORD(v171) = v279;
        v357 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v171);
        v320 = CFSTR("subjectDistanceOffset");
        LODWORD(v172) = v280;
        v358 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v172);
        v321 = CFSTR("relativeApertureScalingStrength");
        LODWORD(v173) = v300;
        v359 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v173);
        v322 = CFSTR("protectBodyStrength");
        LODWORD(v174) = v281;
        v360 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v174);
        v323 = CFSTR("distanceAdd");
        LODWORD(v175) = v285;
        v361 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v175);
        v324 = CFSTR("hairAdditiveLowerAlpha");
        LODWORD(v176) = v296;
        v362 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v176);
        v325 = CFSTR("hairAdditiveUpperAlpha");
        LODWORD(v177) = v297;
        v363 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v177);
        v326 = CFSTR("hairAdditiveMaxBlur");
        LODWORD(v178) = v298;
        v364 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v178);
        v327 = CFSTR("hairSubtractiveLowerAlpha");
        LODWORD(v179) = v294;
        v365 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v179);
        v328 = CFSTR("hairSubtractiveUpperAlpha");
        LODWORD(v180) = v295;
        v366 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v180);
        v329 = CFSTR("hairSubtractiveMaxBlur");
        LODWORD(v181) = v299;
        v367 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v181);
        v330 = CFSTR("faceMaskAdditiveMaxBlur");
        LODWORD(v182) = v286;
        v368 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v182);
        v331 = CFSTR("faceMaskSubtractiveMaxBlur");
        LODWORD(v183) = v287;
        v369 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v183);
        v332 = CFSTR("smoothstepMin");
        LODWORD(v184) = v283;
        v370 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v184);
        v333 = CFSTR("smoothstepMax");
        LODWORD(v185) = v284;
        v371 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v185);
        v334 = CFSTR("maxBlur");
        LODWORD(v186) = v282;
        v372 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v186);
        v335 = CFSTR("personDistance");
        LODWORD(v187) = v288;
        v373 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v187);
        v336 = CFSTR("personThreshold");
        LODWORD(v188) = v289;
        v374 = (void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v188);
        v337 = CFSTR("personMaxBlur");
        LODWORD(v189) = v290;
        v375 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v189);
        v338 = CFSTR("hairDistance");
        LODWORD(v190) = v291;
        v376 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v190);
        v339 = CFSTR("hairThreshold");
        LODWORD(v191) = v292;
        v377 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v191);
        v340 = CFSTR("hairMaxBlur");
        LODWORD(v192) = v293;
        v378 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v192);
        v341 = CFSTR("eyeProtectionMaxFaces");
        v379 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v301);
        v342 = CFSTR("eyeProtectionFaceWeightsSmoothStepMin");
        LODWORD(v193) = v302;
        v380 = (void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v193);
        v343 = CFSTR("eyeProtectionFaceWeightsSmoothStepMax");
        LODWORD(v194) = v303;
        v381 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v194);
        v344 = CFSTR("eyeProtectionOvalDimsDistanceScale");
        LODWORD(v195) = v304;
        v382 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v195);
        v345 = CFSTR("eyeProtectionOvalDimsDistanceOffset");
        LODWORD(v196) = v305;
        v383 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v196);
        v346 = CFSTR("eyeProtectionOvalDimsRadiusHorizontal");
        LODWORD(v197) = v306;
        v384 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v197);
        v347 = CFSTR("eyeProtectionOvalDimsRadiusVertical");
        LODWORD(v198) = v307;
        v385 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v198);
        v348 = CFSTR("eyeProtectionOvalFallOffSmoothStepMin");
        LODWORD(v199) = v308;
        v386 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v199);
        v349 = CFSTR("eyeProtectionOvalFallOffSmoothStepMax");
        LODWORD(v200) = v309;
        v387 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v200);
        v350 = CFSTR("eyeProtectionPersonMaskSmoothStepMin");
        LODWORD(v201) = v310;
        v388 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v201);
        v351 = CFSTR("eyeProtectionPersonMaskSmoothStepMax");
        LODWORD(v202) = v311;
        v389 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v202);
        v352 = CFSTR("eyeProtectionPreventStrength");
        LODWORD(v203) = v312;
        v390 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v203);
        v353 = CFSTR("eyeProtectionSubtractiveMaxBlur");
        LODWORD(v204) = v313;
        v391 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v204);
        v354 = CFSTR("eyeProtectionSubtractiveApertureScaling");
        LODWORD(v205) = v314;
        v392 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v205);
        v545 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v355, &v317, 38);
        v538 = CFSTR("Version");
        v546 = &unk_1E2F1C040;
        v28 = (void *)MEMORY[0x1E0C99D80];
        v29 = &v539;
        v30 = &v531;
        v31 = 8;
        break;
      case 2:
        v39 = v206;
        v461 = CFSTR("BlurMapSmoothing");
        v393 = CFSTR("nIterations");
        v399 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v243);
        v394 = CFSTR("originalBlurValueT0");
        LODWORD(v40) = v267;
        v400 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v40);
        v395 = CFSTR("originalBlurValueT1");
        LODWORD(v41) = v268;
        v401 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v41);
        v396 = CFSTR("localMinimumBlurValueT0");
        LODWORD(v42) = v269;
        v402 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v42);
        v397 = CFSTR("localMinimumBlurValueT1");
        LODWORD(v43) = v270;
        v403 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v43);
        v472 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v399, &v393, 5);
        v462 = CFSTR("DisparityRefinement");
        v405 = CFSTR("radius");
        v433 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", HIDWORD(v207));
        v406 = CFSTR("weightScaling");
        v44 = v232;
        if (!v39)
          v44 = 0.2;
        v434 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v44);
        v407 = CFSTR("maxReconstructionWeight");
        v45 = v233;
        if (!v39)
          v45 = 0.1;
        v435 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v45);
        v408 = CFSTR("innerSamplingRadius");
        v46 = v234;
        if (!v39)
          v46 = 0.5;
        v436 = (void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v46);
        v409 = CFSTR("outerSamplingRadius");
        v47 = v235;
        if (!v39)
          v47 = 2.5;
        v437 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v47);
        v410 = CFSTR("nSamples");
        if (v39)
          v48 = v236;
        else
          v48 = 20;
        v438 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v48);
        v411 = CFSTR("lumaSigma");
        v49 = v237;
        if (!v39)
          v49 = 0.05;
        v439 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v49);
        v412 = CFSTR("chromaSigma");
        v50 = v238;
        if (!v39)
          v50 = 0.02;
        v440 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v50);
        v413 = CFSTR("disparitySigma");
        v51 = v208;
        if (!v39)
          v51 = 0.03;
        v441 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v51);
        v414 = CFSTR("accumulatedWeightT0");
        v52 = v239;
        if (!v39)
          v52 = 0.01;
        v442 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v52);
        v415 = CFSTR("accumulatedWeightT1");
        v53 = v240;
        if (!v39)
          v53 = 0.1;
        v443 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v53);
        v416 = CFSTR("aaLumaSigma");
        LODWORD(v54) = v209;
        v444 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v54);
        v417 = CFSTR("aaChromaSigma");
        LODWORD(v55) = v210;
        v445 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v55);
        v418 = CFSTR("aaSpatialSigma");
        LODWORD(v56) = v211;
        v446 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v56);
        v419 = CFSTR("segmentationSigma");
        LODWORD(v57) = v272;
        if (!v39)
          *(float *)&v57 = 1000.0;
        v447 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v57);
        v420 = CFSTR("aaSegmentationSigma");
        v58 = v273;
        if (!v39)
          v58 = 1.4;
        v448 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v58);
        v421 = CFSTR("Version");
        if (v39)
          v59 = v274;
        else
          v59 = 0;
        v449 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v59);
        v473 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v433, &v405, 17);
        v463 = CFSTR("SLM");
        v531 = CFSTR("shiftDeadZone");
        LODWORD(v60) = v212;
        v539 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v60);
        v532 = CFSTR("zeroShiftPercentile");
        v61 = v241;
        if (!v39)
          v61 = 0.75;
        v540 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v61);
        v533 = CFSTR("maxFGBlur");
        v62 = v242;
        if (!v39)
          v62 = 0.0002;
        v541 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v62);
        v534 = CFSTR("maximumSimulatedAperture");
        v63 = v271;
        if (!v39)
          v63 = 0.0;
        v542 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v63);
        v535 = CFSTR("defaultSimulatedAperture");
        v64 = v275;
        if (!v39)
          v64 = 0.0;
        v543 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v64);
        v536 = CFSTR("disparityScalingFactor");
        v65 = v276;
        if (!v39)
          v65 = 0.0;
        v544 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v65);
        v474 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v539, &v531, 6);
        v464 = CFSTR("HighlightRecovery");
        v495 = CFSTR("iterations");
        v512 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v217);
        v496 = CFSTR("preFilterGain");
        LODWORD(v66) = v218;
        v513 = (void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v66);
        v497 = CFSTR("weightGain");
        LODWORD(v67) = v219;
        v514 = (void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v67);
        v498 = CFSTR("intensityGain");
        LODWORD(v68) = v220;
        v515 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v68);
        v499 = CFSTR("mode");
        v516 = &unk_1E2F1BFB0;
        v500 = CFSTR("blurRadiusT0");
        v69 = v251;
        if (!v39)
          v69 = 0.0025;
        v517 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v69);
        v501 = CFSTR("blurRadiusT1");
        v70 = v252;
        if (!v39)
          v70 = 0.0075;
        v518 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v70);
        v502 = CFSTR("maxIntensityT0");
        v71 = v253;
        if (!v39)
          v71 = 0.9;
        v519 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v71);
        v503 = CFSTR("maxIntensityT1");
        v72 = v254;
        if (!v39)
          v72 = 1.0;
        v520 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v72);
        v504 = CFSTR("minIntensityT0");
        v73 = v255;
        if (!v39)
          v73 = 0.0;
        v521 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v73);
        v505 = CFSTR("minIntensityT1");
        v74 = v256;
        if (!v39)
          v74 = 0.2;
        v522 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v74);
        v475 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v512, &v495, 11);
        v465 = CFSTR("Rendering");
        v317 = CFSTR("faces.linearBlurGrowthC");
        LODWORD(v75) = v214;
        v355 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v75);
        v318 = CFSTR("faces.linearBlurGrowthM");
        LODWORD(v76) = v213;
        v356 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v76);
        v319 = CFSTR("faces.distToBlurScaling");
        LODWORD(v77) = v215;
        v357 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v77);
        v320 = CFSTR("faces.eyeToEyebrowRatio");
        LODWORD(v78) = v216;
        v358 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v78);
        v321 = CFSTR("faces.maxBlurOnEyes");
        LODWORD(v79) = v257;
        v359 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v79);
        v322 = CFSTR("faces.maxBlurDistFromFocus");
        LODWORD(v80) = v258;
        v360 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v80);
        v323 = CFSTR("faces.capMultip");
        LODWORD(v81) = v259;
        v361 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v81);
        v324 = CFSTR("faces.gainMultip");
        LODWORD(v82) = v260;
        v362 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v82);
        v325 = CFSTR("lumaNoiseModelCoeff");
        LODWORD(v83) = v247;
        v363 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v83);
        v326 = CFSTR("relativeWeightThreshold");
        LODWORD(v84) = v222;
        v364 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v84);
        v327 = CFSTR("highlightBoostGain");
        LODWORD(v85) = v223;
        v365 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v85);
        v328 = CFSTR("shapeObstructionCoeff");
        LODWORD(v86) = v224;
        v366 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v86);
        v329 = CFSTR("ringAmplitude");
        LODWORD(v87) = v225;
        v367 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v87);
        v330 = CFSTR("ringSharpness");
        LODWORD(v88) = v226;
        v368 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v88);
        v331 = CFSTR("antiAliasBlurStrength");
        LODWORD(v89) = v228;
        v369 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v89);
        v332 = CFSTR("minimumSimulatedAperture");
        LODWORD(v90) = v229;
        v370 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v90);
        v333 = CFSTR("antiAliasRadius");
        v371 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v248);
        v334 = CFSTR("alphaEpsilon");
        LODWORD(v91) = v249;
        v372 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v91);
        v335 = CFSTR("alphaGain");
        LODWORD(v92) = v250;
        v373 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v92);
        v336 = CFSTR("maxBlur");
        v374 = &unk_1E2F1B2B0;
        v337 = CFSTR("nRings");
        v375 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v221);
        v338 = CFSTR("preFilterBlurStrength");
        LODWORD(v93) = v227;
        v376 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v93);
        v339 = CFSTR("preFilterRadius");
        v377 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v244);
        v340 = CFSTR("sharpRadius");
        LODWORD(v94) = v245;
        v378 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v94);
        v341 = CFSTR("softRadius");
        v95 = v246;
        if (!v39)
          v95 = 1.0;
        v379 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v95);
        v342 = CFSTR("basePixelWeight");
        v380 = &unk_1E2F1B2C0;
        v343 = CFSTR("blendingQuarterResAlphaGain");
        v96 = v230;
        if (!v39)
          v96 = 1.0;
        v381 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v96);
        v344 = CFSTR("blendingFullResAlphaGain");
        v97 = v231;
        if (!v39)
          v97 = 1.0;
        v382 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v97);
        v476 = (void *)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v355, &v317, 28);
        v466 = CFSTR("Fusion");
        v483 = CFSTR("subtractiveLowerAlpha");
        LODWORD(v98) = v261;
        if (!v39)
          *(float *)&v98 = 0.8;
        v489 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v98);
        v484 = CFSTR("subtractiveUpperAlpha");
        LODWORD(v99) = v262;
        if (!v39)
          *(float *)&v99 = 1.0;
        v490 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v99);
        v485 = CFSTR("subtractiveMaxBlur");
        v100 = v263;
        if (!v39)
          v100 = 0.0;
        v491 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v100);
        v486 = CFSTR("additiveLowerAlpha");
        LODWORD(v101) = v264;
        if (!v39)
          *(float *)&v101 = 0.0;
        v492 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v101);
        v487 = CFSTR("additiveUpperAlpha");
        LODWORD(v102) = v265;
        if (!v39)
          *(float *)&v102 = 0.2;
        v493 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v102);
        v488 = CFSTR("additiveMaxBlur");
        v103 = v266;
        if (!v39)
          v103 = 0.0;
        v494 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v103);
        v477 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v489, &v483, 6);
        v467 = CFSTR("Version");
        v478 = &unk_1E2F1BFC8;
        v28 = (void *)MEMORY[0x1E0C99D80];
        v29 = &v472;
        v30 = &v461;
        v31 = 7;
        break;
      case 1:
        v405 = CFSTR("DisparitySmoothing");
        v461 = CFSTR("nIterations");
        v472 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", HIDWORD(v207));
        v433 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v472, &v461, 1);
        v406 = CFSTR("SLM");
        v495 = CFSTR("shiftDeadZone");
        *(float *)&v20 = v208;
        v512 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v20);
        v496 = CFSTR("maximumSimulatedAperture");
        v513 = &unk_1E2F1B250;
        v497 = CFSTR("defaultSimulatedAperture");
        v514 = &unk_1E2F1B250;
        v434 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v512, &v495, 3);
        v407 = CFSTR("Rendering");
        v317 = CFSTR("faces.linearBlurGrowthC");
        LODWORD(v21) = v210;
        v355 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v21);
        v318 = CFSTR("faces.linearBlurGrowthM");
        LODWORD(v22) = v209;
        v356 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v22);
        v319 = CFSTR("faces.distToBlurScaling");
        LODWORD(v23) = v211;
        v357 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v23);
        v320 = CFSTR("faces.eyeToEyebrowRatio");
        LODWORD(v24) = v212;
        v358 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v24);
        v321 = CFSTR("relativeWeightThreshold");
        LODWORD(v25) = v213;
        v359 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v25);
        v322 = CFSTR("highlightBoostGain");
        LODWORD(v26) = v214;
        v360 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v26);
        v323 = CFSTR("antiAliasBlurStrength");
        LODWORD(v27) = v215;
        v361 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v27);
        v435 = objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v355, &v317, 7);
        v408 = CFSTR("Version");
        v436 = &unk_1E2F1BFF8;
        v28 = (void *)MEMORY[0x1E0C99D80];
        v29 = &v433;
        v30 = &v405;
        v31 = 4;
        break;
      default:
        v315 = CFSTR("Version");
        v316 = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v8);
        v28 = (void *)MEMORY[0x1E0C99D80];
        v29 = &v316;
        v30 = &v315;
        v31 = 1;
        break;
    }
    return (const CGImageMetadata *)objc_msgSend(v28, "dictionaryWithObjects:forKeys:count:", v29, v30, v31);
  }
  return a1;
}

const CGImageMetadata *tuningParametersFromImage(CIImage *a1)
{
  NSDictionary *v2;
  const CGImageMetadata *v3;

  if (a1
    && -[CIImage properties](a1, "properties")
    && (v2 = -[CIImage properties](a1, "properties"),
        (v3 = -[NSDictionary objectForKeyedSubscript:](v2, "objectForKeyedSubscript:", *MEMORY[0x1E0CBC6D0])) != 0))
  {
    return tuningParametersFromMetaData(v3);
  }
  else
  {
    return (const CGImageMetadata *)MEMORY[0x1E0C9AA70];
  }
}

void getSimulatedAperture(CIImage *a1, const CGImageMetadata *a2, NSNumber *a3, NSDictionary *a4)
{
  double v7;
  float v8;
  NSDictionary *v9;
  const CGImageMetadata *v10;
  int v11;
  CGImageMetadataTag *v12;
  CGImageMetadataTag *v13;
  CFTypeRef v14;
  void *v15;
  int v16;
  int v17;
  int v18;

  -[NSNumber floatValue](a3, "floatValue");
  if (*(float *)&v7 != 0.0)
    goto LABEL_10;
  if (a2)
  {
    getSimulatedApertureFromAuxMetadata(a2);
    v8 = *(float *)&v7;
    if (!a1)
      goto LABEL_11;
  }
  else
  {
    v8 = 0.0;
    if (!a1)
      goto LABEL_11;
  }
  if (v8 == 0.0)
  {
    if (-[CIImage properties](a1, "properties"))
    {
      v9 = -[CIImage properties](a1, "properties");
      v10 = -[NSDictionary objectForKeyedSubscript:](v9, "objectForKeyedSubscript:", *MEMORY[0x1E0CBC6D0]);
      a2 = v10;
      if (v10)
      {
        getSimulatedApertureFromAuxMetadata(v10);
LABEL_10:
        v8 = *(float *)&v7;
      }
    }
  }
LABEL_11:
  if (v8 == 0.0)
  {
    SDOFSimpleLensModelValue(CFSTR("simulatedAperture"), 0);
    v8 = *(float *)&v7;
  }
  LODWORD(v7) = 4.5;
  if (v8 != 0.0)
  {
    if (a4)
    {
      v11 = objc_msgSend(-[NSDictionary objectForKeyedSubscript:](a4, "objectForKeyedSubscript:", CFSTR("Version"), v7), "intValue");
      if (v11 >= 2)
      {
        v17 = 1083179008;
        v18 = 1083179008;
        if (v11 > 3)
        {
          if (a2)
          {
            v12 = CGImageMetadataCopyTagWithPath(a2, 0, CFSTR("depthBlurEffect:RenderingParameters"));
            if (v12)
            {
              v13 = v12;
              if (CGImageMetadataTagGetType(v12) == kCGImageMetadataTypeString)
              {
                v14 = CGImageMetadataTagCopyValue(v13);
                v15 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithBase64EncodedString:options:", (id)CFMakeCollectable(v14), 0);
                CFRelease(v13);
                if (v15)
                {
                  v16 = 0;
                  +[CIFilter getMinMaxSimulatedApertureFrom:minValue:maxValue:version:](CIFilter, "getMinMaxSimulatedApertureFrom:minValue:maxValue:version:", v15, &v18, &v17, &v16);

                }
              }
              else
              {
                CFRelease(v13);
              }
            }
          }
        }
        else
        {
          SDOFRenderingValue(CFSTR("minimumSimulatedAperture"), a4);
          SDOFSimpleLensModelValue(CFSTR("maximumSimulatedAperture"), a4);
        }
      }
    }
  }
}

uint64_t envCCSDOFMetadataClass(void)
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  void (*v7)(uint64_t);
  uint64_t v8;

  if (CCPBundleEnvar(void)::onceToken != -1)
    dispatch_once(&CCPBundleEnvar(void)::onceToken, &__block_literal_global_876);
  v0 = objc_msgSend((id)CCPBundleEnvar(void)::b, "classNamed:", CFSTR("CCSDOFMetadata"));
  if (!v0)
  {
    v3 = 0;
    v4 = &v3;
    v5 = 0x3052000000;
    v6 = __Block_byref_object_copy__20;
    v7 = __Block_byref_object_dispose__20;
    v0 = getCCSDOFMetadataClass(void)::softClass;
    v8 = getCCSDOFMetadataClass(void)::softClass;
    if (!getCCSDOFMetadataClass(void)::softClass)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 3221225472;
      v2[2] = ___ZL22getCCSDOFMetadataClassv_block_invoke;
      v2[3] = &unk_1E2EC2EB8;
      v2[4] = &v3;
      ___ZL22getCCSDOFMetadataClassv_block_invoke((uint64_t)v2);
      v0 = v4[5];
    }
    _Block_object_dispose(&v3, 8);
  }
  return v0;
}

void sub_19239A924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t FigDepthBlurEffectRenderingParametersV1FromCFData(void *a1, _OWORD *a2)
{
  NSObject *v4;
  uint64_t result;
  __int128 v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  _OWORD v10[3];

  if ((unint64_t)objc_msgSend(a1, "length") > 0x2F)
  {
    objc_msgSend(a1, "getBytes:length:", v10, 48);
    if (LODWORD(v10[0]) == 1145980242)
    {
      if (DWORD1(v10[0]) == 1)
      {
        if (DWORD2(v10[0]) == 48)
        {
          result = 0;
          v6 = v10[1];
          *a2 = v10[0];
          a2[1] = v6;
          a2[2] = v10[2];
        }
        else
        {
          v9 = ci_logger_api();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            FigDepthBlurEffectRenderingParametersV1FromCFData();
          return 4;
        }
      }
      else
      {
        v8 = ci_logger_api();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          FigDepthBlurEffectRenderingParametersV1FromCFData();
        return 3;
      }
    }
    else
    {
      v7 = ci_logger_api();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        FigDepthBlurEffectRenderingParametersV1FromCFData();
      return 2;
    }
  }
  else
  {
    v4 = ci_logger_api();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      FigDepthBlurEffectRenderingParametersV1FromCFData();
    return 1;
  }
  return result;
}

uint64_t FigDepthBlurEffectRenderingParametersV2FromCFData(void *a1, char *a2, BOOL *a3)
{
  NSObject *v6;
  size_t v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  _DWORD v12[2];
  size_t __n;

  if (objc_msgSend(a1, "length") == 112 || (unint64_t)objc_msgSend(a1, "length") > 0x13F)
  {
    objc_msgSend(a1, "getBytes:length:", v12, objc_msgSend(a1, "length"));
    if (v12[0] == 1145980242)
    {
      if (v12[1] == 2)
      {
        v8 = __n;
        if ((_DWORD)__n == 112 || (_DWORD)__n == 320)
        {
          *a3 = (_DWORD)__n == 320;
          memcpy(a2, v12, v8);
          if ((_DWORD)v8 != 320)
            bzero(&a2[v8], 320 - v8);
          return 0;
        }
        else
        {
          v11 = ci_logger_api();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            FigDepthBlurEffectRenderingParametersV1FromCFData();
          return 4;
        }
      }
      else
      {
        v10 = ci_logger_api();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          FigDepthBlurEffectRenderingParametersV1FromCFData();
        return 3;
      }
    }
    else
    {
      v9 = ci_logger_api();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        FigDepthBlurEffectRenderingParametersV1FromCFData();
      return 2;
    }
  }
  else
  {
    v6 = ci_logger_api();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      FigDepthBlurEffectRenderingParametersV1FromCFData();
    return 1;
  }
}

uint64_t FigDepthBlurEffectRenderingParametersV3FromCFData(void *a1, void *a2)
{
  NSObject *v4;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  _DWORD __src[118];

  if ((unint64_t)objc_msgSend(a1, "length") > 0x1D7)
  {
    objc_msgSend(a1, "getBytes:length:", __src, 472);
    if (__src[0] == 1145980242)
    {
      if (__src[1] == 3)
      {
        if (__src[2] == 472)
        {
          memcpy(a2, __src, 0x1D8uLL);
          return 0;
        }
        else
        {
          v8 = ci_logger_api();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            FigDepthBlurEffectRenderingParametersV1FromCFData();
          return 4;
        }
      }
      else
      {
        v7 = ci_logger_api();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          FigDepthBlurEffectRenderingParametersV1FromCFData();
        return 3;
      }
    }
    else
    {
      v6 = ci_logger_api();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        FigDepthBlurEffectRenderingParametersV1FromCFData();
      return 2;
    }
  }
  else
  {
    v4 = ci_logger_api();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      FigDepthBlurEffectRenderingParametersV1FromCFData();
    return 1;
  }
}

id ___ZL18SDOFParameterValueP8NSStringS0__block_invoke()
{
  uint64_t v0;
  uint64_t v2;

  v2 = 0;
  v0 = objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", aXmlVersion10En, 6332);
  SDOFParameterValue(NSString *,NSString *)::sdofParameters = objc_msgSend(MEMORY[0x1E0CB38B0], "propertyListWithData:options:format:error:", v0, 0, 0, &v2);
  return (id)SDOFParameterValue(NSString *,NSString *)::sdofParameters;
}

id ___ZL18SDOFParameterValueP8NSStringS0__block_invoke_2()
{
  id result;
  BOOL v1;
  void *v2;
  id v3;
  uint64_t v4;

  result = (id)objc_msgSend((id)objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager"), "contentsAtPath:", CFSTR("/System/Library/Frameworks/MediaToolbox.framework/D11/CameraSetup.plist"));
  if (result)
  {
    v4 = 0;
    result = (id)objc_msgSend(MEMORY[0x1E0CB38B0], "propertyListWithData:options:format:error:", result, 0, 0, &v4);
    if (result)
      v1 = v4 == 0;
    else
      v1 = 0;
    if (v1)
    {
      result = (id)objc_msgSend(result, "valueForKey:", CFSTR("TuningParameters"));
      if (result)
      {
        v2 = result;
        result = (id)objc_msgSend(result, "valueForKey:", CFSTR("DefaultSensorIDs"));
        if (result)
        {
          result = (id)objc_msgSend(result, "valueForKey:", CFSTR("PortTypeBackTelephoto"));
          if (result)
          {
            v3 = result;
            result = (id)objc_msgSend(v2, "valueForKey:", CFSTR("PortTypeBackTelephoto"));
            if (result)
            {
              result = (id)objc_msgSend(result, "objectForKey:", v3);
              if (result)
              {
                result = (id)objc_msgSend(result, "valueForKey:", CFSTR("SDOFRenderingParameters"));
                if (result)
                {
                  SDOFParameterValue(NSString *,NSString *)::sdofParametersOnDevice = (uint64_t)result;
                  return result;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

float cikernel::_convertDepthOrDisparity(float a1)
{
  return 1.0 / fmaxf(a1, 0.000001);
}

double cikernel::_segmentationFusion(double a1, float a2, __n128 a3, __n128 a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  double result;

  v4 = vmlas_n_f32(a3.n128_f32[1], a2, a3.n128_f32[0]);
  a3.n128_u32[0] = a3.n128_u32[2];
  if (v4 <= a3.n128_f32[2])
    a3.n128_f32[0] = v4;
  if (v4 < 0.0)
    a3.n128_f32[0] = 0.0;
  v5 = vmlas_n_f32(a4.n128_f32[1], a2, a4.n128_f32[0]);
  v6 = a4.n128_f32[2];
  if (v5 <= a4.n128_f32[2])
    v6 = v5;
  if (v5 < 0.0)
    v6 = 0.0;
  v7 = vmlas_n_f32(a3.n128_f32[0], *(float *)&a1, *(float *)&a1) - v6;
  if (v7 <= 1.0)
    v8 = v7;
  else
    v8 = 1.0;
  if (v7 >= 0.0)
    *(float *)&a1 = v8;
  else
    *(float *)&a1 = 0.0;
  *(float *)&a1 = sqrtf(*(float *)&a1);
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)&a1, 0).u64[0];
  return result;
}

void CI::f4_s_s_f3_f3(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, __n128, __n128);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __n128 *v18;
  __n128 *v19;
  __int128 v20;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, __n128, __n128))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_QWORD *)(v10 + 56);
  v17 = *(_QWORD *)(v10 + 80);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 104)), a2);
  v18 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v15);
  v19 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v20 = v11(a1, *v19, *v18, *((__n128 *)a2 + 4 * v16), *((__n128 *)a2 + 4 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v20;
}

void __Block_byref_object_copy__20(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__20(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

Class ___ZL20getCCFacePointsClassv_block_invoke(uint64_t a1)
{
  Class result;

  CCPortraitLibrary();
  result = objc_getClass("CCFacePoints");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL20getCCFacePointsClassv_block_invoke_cold_1();
  getCCFacePointsClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

void CCPortraitLibrary(void)
{
  void *v0;
  __int128 v1;
  uint64_t v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v0 = 0;
  if (!CCPortraitLibraryCore(char **)::frameworkLibrary)
  {
    v1 = xmmword_1E2EC5788;
    v2 = 0;
    CCPortraitLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  }
  if (!CCPortraitLibraryCore(char **)::frameworkLibrary)
    CCPortraitLibrary(&v0);
}

Class ___ZL25getCCMakeBlurMapArgsClassv_block_invoke(uint64_t a1)
{
  Class result;

  CCPortraitLibrary();
  result = objc_getClass("CCMakeBlurMapArgs");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL25getCCMakeBlurMapArgsClassv_block_invoke_cold_1();
  getCCMakeBlurMapArgsClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class ___ZL21getCCMakeBlurMapClassv_block_invoke(uint64_t a1)
{
  Class result;

  CCPortraitLibrary();
  result = objc_getClass("CCMakeBlurMap");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL21getCCMakeBlurMapClassv_block_invoke_cold_1();
  getCCMakeBlurMapClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

void getSimulatedApertureFromAuxMetadata(const CGImageMetadata *a1)
{
  CGImageMetadataTag *v1;
  CGImageMetadataTag *v2;
  CFTypeRef v3;

  v1 = CGImageMetadataCopyTagWithPath(a1, 0, CFSTR("depthBlurEffect:SimulatedAperture"));
  if (v1)
  {
    v2 = v1;
    v3 = CGImageMetadataTagCopyValue(v1);
    objc_msgSend((id)(id)CFMakeCollectable(v3), "floatValue");
    CFRelease(v2);
  }
}

uint64_t envCCApplyBlurMapArgsClass(void)
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  void (*v7)(uint64_t);
  uint64_t v8;

  if (CCPBundleEnvar(void)::onceToken != -1)
    dispatch_once(&CCPBundleEnvar(void)::onceToken, &__block_literal_global_876);
  v0 = objc_msgSend((id)CCPBundleEnvar(void)::b, "classNamed:", CFSTR("CCApplyBlurMapArgs"));
  if (!v0)
  {
    v3 = 0;
    v4 = &v3;
    v5 = 0x3052000000;
    v6 = __Block_byref_object_copy__20;
    v7 = __Block_byref_object_dispose__20;
    v0 = getCCApplyBlurMapArgsClass(void)::softClass;
    v8 = getCCApplyBlurMapArgsClass(void)::softClass;
    if (!getCCApplyBlurMapArgsClass(void)::softClass)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 3221225472;
      v2[2] = ___ZL26getCCApplyBlurMapArgsClassv_block_invoke;
      v2[3] = &unk_1E2EC2EB8;
      v2[4] = &v3;
      ___ZL26getCCApplyBlurMapArgsClassv_block_invoke((uint64_t)v2);
      v0 = v4[5];
    }
    _Block_object_dispose(&v3, 8);
  }
  return v0;
}

void sub_19239E74C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t envCCApplyBlurMapClass(void)
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  void (*v7)(uint64_t);
  uint64_t v8;

  if (CCPBundleEnvar(void)::onceToken != -1)
    dispatch_once(&CCPBundleEnvar(void)::onceToken, &__block_literal_global_876);
  v0 = objc_msgSend((id)CCPBundleEnvar(void)::b, "classNamed:", CFSTR("CCApplyBlurMap"));
  if (!v0)
  {
    v3 = 0;
    v4 = &v3;
    v5 = 0x3052000000;
    v6 = __Block_byref_object_copy__20;
    v7 = __Block_byref_object_dispose__20;
    v0 = getCCApplyBlurMapClass(void)::softClass;
    v8 = getCCApplyBlurMapClass(void)::softClass;
    if (!getCCApplyBlurMapClass(void)::softClass)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 3221225472;
      v2[2] = ___ZL22getCCApplyBlurMapClassv_block_invoke;
      v2[3] = &unk_1E2EC2EB8;
      v2[4] = &v3;
      ___ZL22getCCApplyBlurMapClassv_block_invoke((uint64_t)v2);
      v0 = v4[5];
    }
    _Block_object_dispose(&v3, 8);
  }
  return v0;
}

void sub_19239E854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class ___ZL26getCCApplyBlurMapArgsClassv_block_invoke(uint64_t a1)
{
  Class result;

  CCPortraitLibrary();
  result = objc_getClass("CCApplyBlurMapArgs");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL26getCCApplyBlurMapArgsClassv_block_invoke_cold_1();
  getCCApplyBlurMapArgsClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class ___ZL22getCCApplyBlurMapClassv_block_invoke(uint64_t a1)
{
  Class result;

  CCPortraitLibrary();
  result = objc_getClass("CCApplyBlurMap");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL22getCCApplyBlurMapClassv_block_invoke_cold_1();
  getCCApplyBlurMapClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

Class ___ZL22getCCSDOFMetadataClassv_block_invoke(uint64_t a1)
{
  Class result;

  CCPortraitLibrary();
  result = objc_getClass("CCSDOFMetadata");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
    ___ZL22getCCSDOFMetadataClassv_block_invoke_cold_1();
  getCCSDOFMetadataClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  return result;
}

uint64_t ___ZL23prewarmSDOFFilterGraphsP9CIContext_block_invoke(uint64_t a1)
{
  uint64_t result;
  CIContext *v3;
  void *v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  void *v10;
  void *v11;
  CIRenderDestination *v12;
  double v13;
  double v14;
  double v15;
  CIRenderDestination *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  __int128 v21;
  char v22;
  _BYTE v23[15];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  char v29;
  _BYTE v30[7];
  _QWORD v31[5];
  _QWORD v32[6];
  char v33;
  _BYTE v34[15];
  _BYTE v35[128];
  _QWORD v36[4];
  _QWORD v37[4];
  uint8_t buf[4];
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  result = objc_msgSend(*(id *)(a1 + 32), "count");
  if (result)
  {
    v3 = *(CIContext **)(a1 + 40);
    if (!v3)
    {
      v36[0] = CFSTR("working_format");
      v37[0] = objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", 2056);
      v37[1] = &unk_1E2F1C058;
      v36[1] = CFSTR("kCIContextIntermediateMemoryTarget");
      v36[2] = CFSTR("kCIContextCacheIntermediates");
      v36[3] = CFSTR("kCIContextUseMetalRenderer");
      v37[2] = MEMORY[0x1E0C9AAA0];
      v37[3] = MEMORY[0x1E0C9AAB0];
      v3 = +[CIContext contextWithOptions:](CIContext, "contextWithOptions:", objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v37, v36, 4));
    }
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v4 = *(void **)(a1 + 32);
    result = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v24, v35, 16);
    v6 = result;
    if (result)
    {
      v7 = *(_QWORD *)v25;
      *(_QWORD *)&v5 = 138543362;
      v21 = v5;
      do
      {
        v8 = 0;
        do
        {
          if (*(_QWORD *)v25 != v7)
            objc_enumerationMutation(v4);
          v9 = +[CIFilter prewarmedFilterFromString:](CIFilter, "prewarmedFilterFromString:", *(_QWORD *)(*((_QWORD *)&v24 + 1) + 8 * v8), v21);
          if (v9)
          {
            v10 = (void *)MEMORY[0x194026220]();
            v11 = (void *)objc_msgSend(v9, "outputImage");
            if (v11)
            {
              v32[0] = 0;
              v32[1] = v32;
              v32[2] = 0x3052000000;
              v32[3] = __Block_byref_object_copy__20;
              v32[4] = __Block_byref_object_dispose__20;
              v32[5] = 0;
              v12 = [CIRenderDestination alloc];
              objc_msgSend(v11, "extent");
              v14 = v13;
              objc_msgSend(v11, "extent");
              v31[0] = MEMORY[0x1E0C809B0];
              v31[1] = 3221225472;
              v31[2] = ___ZL20renderPrewarmedImageP9CIContextP8CIFilter_block_invoke;
              v31[3] = &unk_1E2EC57A8;
              v31[4] = v32;
              v16 = -[CIRenderDestination initWithWidth:height:pixelFormat:commandBuffer:mtlTextureProvider:](v12, "initWithWidth:height:pixelFormat:commandBuffer:mtlTextureProvider:", (unint64_t)v14, (unint64_t)v15, 70, 0, v31);
              if (v16)
              {
                v28 = 0;
                objc_msgSend(v11, "extent");
                -[CIContext prepareRender:fromRect:toDestination:atPoint:error:](v3, "prepareRender:fromRect:toDestination:atPoint:error:", v11, v16, &v28);
                if (v28)
                {
                  v17 = ci_logger_api();
                  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = v21;
                    v39 = v28;
                    _os_log_error_impl(&dword_1921E4000, v17, OS_LOG_TYPE_ERROR, "Error asking CI to prepare render = %{public}@", buf, 0xCu);
                  }
                }

              }
              else
              {
                v20 = ci_logger_api();
                if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
                  ___ZL23prewarmSDOFFilterGraphsP9CIContext_block_invoke_cold_3(&v29, v30);
              }
              _Block_object_dispose(v32, 8);
            }
            else
            {
              v19 = ci_logger_api();
              if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
                ___ZL23prewarmSDOFFilterGraphsP9CIContext_block_invoke_cold_2(&v33, v34);
            }
            objc_autoreleasePoolPop(v10);
          }
          else
          {
            v18 = ci_logger_api();
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
              ___ZL23prewarmSDOFFilterGraphsP9CIContext_block_invoke_cold_1(&v22, v23);
          }
          ++v8;
        }
        while (v6 != v8);
        result = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v24, v35, 16);
        v6 = result;
      }
      while (result);
    }
  }
  return result;
}

void sub_19239ED2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose(&a33, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL20renderPrewarmedImageP9CIContextP8CIFilter_block_invoke(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
}

void OUTLINED_FUNCTION_1_7(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 2u);
}

void OUTLINED_FUNCTION_4_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

_BYTE *OUTLINED_FUNCTION_5_2(_BYTE *result, _BYTE *a2)
{
  *result = 0;
  *a2 = 0;
  return result;
}

CIImage *_CUIMappedBlurImageWithSize(CIImage *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3;
  CIImage *v4;
  unsigned int v5;
  double v6;
  __int128 *v7;
  CIVector *v8;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  _OWORD v15[4];
  uint64_t v16;
  uint64_t v17;

  v3 = a2;
  v4 = a1;
  v17 = *MEMORY[0x1E0C80C00];
  v5 = vcvtad_u64_f64((double)a3 * 0.01 * (double)a2);
  if (v5)
  {
    v3 -= v5;
    v4 = -[CIImage filteredImage:keysAndValues:](a1, "filteredImage:keysAndValues:", CFSTR("CUIScaleClampFilter"), CFSTR("inputImage"), _CUIMappedBlurImageWithSize(a1, v5, 0), CFSTR("inputScale"), objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", (float)((float)v5 * 5.0)), 0);
  }
  v15[2] = xmmword_192498F98;
  v15[3] = unk_192498FA8;
  v16 = 0x3FB0000000000000;
  v15[0] = xmmword_192498F78;
  v15[1] = unk_192498F88;
  v12 = xmmword_192498FE0;
  v13 = unk_192498FF0;
  v14 = 0x3FBC71C71C71C71CLL;
  HIDWORD(v6) = unk_192498FD4;
  v10 = xmmword_192498FC0;
  v11 = unk_192498FD0;
  if (!v3)
    return v4;
  if (v3 == 1)
  {
    v7 = v15;
LABEL_8:
    v8 = +[CIVector vectorWithValues:count:](CIVector, "vectorWithValues:count:", v7, 9);
    return (CIImage *)-[CIImage filteredImage:keysAndValues:](v4, "filteredImage:keysAndValues:", CFSTR("CIConvolution3X3"), CFSTR("inputWeights"), v8, CFSTR("inputBias"), &unk_1E2F1B2D0, 0, v10, v11, v12, v13, v14);
  }
  if (v3 <= 2)
  {
    v7 = &v10;
    goto LABEL_8;
  }
  *(float *)&v6 = (float)v3 / 2.853;
  return (CIImage *)-[CIImage filteredImage:keysAndValues:](v4, "filteredImage:keysAndValues:", CFSTR("CIGaussianBlur"), CFSTR("inputRadius"), objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v6), 0);
}

__n128 convolve(double *a1, const double *a2)
{
  uint64_t v2;
  int v3;
  uint64_t i;
  __int128 v5;
  __n128 result;
  __int128 v7;
  __n128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;

  v2 = 0;
  v12 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  v3 = -1;
  do
  {
    for (i = 0; i != 3; ++i)
    {
      if ((v3 + i) <= 8)
        *((double *)&v7 + (v3 + i)) = *((double *)&v7 + (v3 + i)) + a1[v2] * a2[i];
    }
    ++v2;
    ++v3;
  }
  while (v2 != 9);
  v5 = v10;
  *((_OWORD *)a1 + 2) = v9;
  *((_OWORD *)a1 + 3) = v5;
  *((_QWORD *)a1 + 8) = v11;
  result = v8;
  *(_OWORD *)a1 = v7;
  *((__n128 *)a1 + 1) = result;
  return result;
}

double cikernel::_cui_hueSaturation(int32x4_t a1, float a2, double a3, float a4, float32x2_t a5, double a6)
{
  double v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  int32x4_t v14;
  float v15;
  float v16;
  int v17;
  float v18;
  float64x2_t v19;
  float64x2_t v25;
  float v26;
  float32x2_t v27;

  if (*(float *)&a3 > 0.0)
  {
    v6 = *(float *)&a3;
    *(float *)&a3 = fminf(*(float *)a1.i32, fminf(*(float *)&a1.i32[1], *(float *)&a1.i32[2]));
    v7 = fmaxf(*(float *)a1.i32, fmaxf(*(float *)&a1.i32[1], *(float *)&a1.i32[2]));
    v8 = v7 - *(float *)&a3;
    v9 = (float)(v7 - *(float *)&a3) / v7;
    v10 = 0.0;
    if (v7 == 0.0)
      v9 = 0.0;
    if (v9 != 0.0)
    {
      v11 = (float)((float)(*(float *)a1.i32 - *(float *)&a1.i32[1]) / v8) + 4.0;
      if (*(float *)&a1.i32[1] == v7)
        v11 = (float)((float)(*(float *)&a1.i32[2] - *(float *)a1.i32) / v8) + 2.0;
      v12 = (float)(*(float *)&a1.i32[1] - *(float *)&a1.i32[2]) / v8;
      if (*(float *)a1.i32 != v7)
        v12 = v11;
      v10 = v12 / 6.0;
      if ((float)(v12 / 6.0) < 0.0)
        v10 = v10 + 1.0;
    }
    v13 = (float)((float)(v10 * 360.0) - a2) / 6.0;
    if (v13 < 0.0)
      v13 = v13 + 360.0;
    if (v6 * 0.5 > v13)
    {
      if (v9 == 0.0)
      {
        v14.i64[0] = 0;
        v14.i32[2] = 0;
      }
      else
      {
        v15 = v13 + a4;
        if (v15 < 0.0)
          v15 = v15 + 360.0;
        if (v15 > 360.0)
          v15 = v15 + -360.0;
        v16 = v15 / 60.0;
        v17 = (int)v16;
        v18 = v16 - floorf(v16);
        v19.f64[0] = v9;
        v19.f64[1] = (float)(v9 * v18);
        __asm { FMOV            V1.2D, #1.0 }
        v25 = vmulq_n_f64(vsubq_f64(_Q1, v19), v7);
        *(float32x2_t *)&v25.f64[0] = vcvt_f32_f64(v25);
        v26 = (1.0 - v9 * (1.0 - v18)) * v7;
        switch(v17)
        {
          case 0:
            a1.i64[0] = __PAIR64__(LODWORD(v26), LODWORD(v7));
            a1.i32[2] = LODWORD(v25.f64[0]);
            goto LABEL_28;
          case 1:
            v14.i32[0] = vtrn2q_s32((int32x4_t)v25, a1).u32[0];
            *(float *)&v14.i32[1] = v7;
            v14.i32[2] = LODWORD(v25.f64[0]);
            break;
          case 2:
            HIDWORD(v25.f64[1]) = vextq_s8(*(int8x16_t *)&a1, *(int8x16_t *)&a1, 8uLL).i32[1];
            *((float *)v25.f64 + 1) = v7;
            *(float *)&v25.f64[1] = v26;
            goto LABEL_26;
          case 3:
            HIDWORD(v25.f64[1]) = vextq_s8(*(int8x16_t *)&a1, *(int8x16_t *)&a1, 8uLL).i32[1];
            *(float *)&v25.f64[1] = v7;
LABEL_26:
            v14 = (int32x4_t)v25;
            break;
          case 4:
            a1.i64[0] = __PAIR64__(LODWORD(v25.f64[0]), LODWORD(v26));
            *(float *)&a1.i32[2] = v7;
            goto LABEL_28;
          default:
            a1.i64[0] = __PAIR64__(LODWORD(v25.f64[0]), LODWORD(v7));
            a1.i32[2] = HIDWORD(v25.f64[0]);
LABEL_28:
            v14 = a1;
            break;
        }
      }
      v27 = vmls_lane_f32(*(float32x2_t *)v14.i8, vsub_f32(*(float32x2_t *)v14.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0)), *(float32x2_t *)&a6, 0);
      *(float *)&a3 = (float)((float)(*(float *)&v14.i32[2]
                                    - (float)((float)(*(float *)&v14.i32[2] - *(float *)&a3) * *(float *)&a6))
                            + vaddv_f32(v27))
                    / 3.0;
      *(float32x2_t *)a1.i8 = vmls_lane_f32(v27, vsub_f32(v27, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0)), a5, 0);
    }
  }
  return *(double *)a1.i64;
}

double cikernel::_scaleClamp(float32x4_t a1, float a2)
{
  float32x4_t v2;
  double result;

  v2 = vmaxnmq_f32(vmulq_n_f32(a1, a2), (float32x4_t)0);
  __asm { FMOV            V1.4S, #1.0 }
  *(_QWORD *)&result = vminnmq_f32(v2, _Q1).u64[0];
  return result;
}

double cikernel::_innerGorS(__n128 a1, float32x4_t a2, float a3)
{
  float v3;
  float v4;
  BOOL v5;
  float v6;
  double result;

  v3 = (1.0 - a1.n128_f32[3]) / a3;
  v4 = 1.0;
  if (v3 <= 1.0)
    v4 = v3;
  v5 = v3 < 0.0;
  v6 = 0.0;
  if (!v5)
    v6 = v4;
  *(_QWORD *)&result = vmulq_n_f32(a2, v6).u64[0];
  return result;
}

double cikernel::_outerGorS(__n128 a1, float32x4_t a2, float a3)
{
  float v3;
  float v4;
  BOOL v5;
  float v6;
  double result;

  v3 = a1.n128_f32[3] / a3;
  v4 = 1.0;
  if (v3 <= 1.0)
    v4 = v3;
  v5 = v3 < 0.0;
  v6 = 0.0;
  if (!v5)
    v6 = v4;
  *(_QWORD *)&result = vmulq_n_f32(a2, v6).u64[0];
  return result;
}

double cikernel::_shapeEffectBlur_1(float32x4_t a1, __n128 _Q1, __n128 a3, __n128 a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, float32x4_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float32x4_t a17, float a18, float a19)
{
  float v19;
  float v20;
  float32x4_t v21;
  float v22;
  float v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v32;
  float32x4_t v33;
  float v34;
  float32x4_t v35;
  double result;

  v19 = 1.0 - a3.n128_f32[3] + 1.0 - a3.n128_f32[3];
  if (v19 <= 1.0)
    v20 = 1.0 - a3.n128_f32[3] + 1.0 - a3.n128_f32[3];
  else
    v20 = 1.0;
  if (v19 < 0.0)
    v20 = 0.0;
  v21 = vmulq_n_f32(a6, v20);
  if ((float)(a3.n128_f32[3] + a3.n128_f32[3]) <= 1.0)
    v22 = a3.n128_f32[3] + a3.n128_f32[3];
  else
    v22 = 1.0;
  if ((float)(a3.n128_f32[3] + a3.n128_f32[3]) >= 0.0)
    v23 = v22;
  else
    v23 = 0.0;
  v24 = vmulq_n_f32(a7, v23);
  v25 = vmulq_n_f32(a8, (float)((float)(1.0 - a4.n128_f32[3]) * a18) + (float)((float)(1.0 - _Q1.n128_f32[3]) * (float)(1.0 - a18)));
  _S7 = 1.0 - a19;
  __asm { FMLA            S3, S7, V1.S[3] }
  v32 = vmulq_n_f32(a17, _S3);
  v33 = vaddq_f32(v25, vmulq_n_f32(vaddq_f32(v21, vmulq_n_f32(a5, 1.0 - v21.f32[3])), 1.0 - v25.f32[3]));
  v34 = a1.f32[3];
  v35 = vmulq_laneq_f32(v33, a1, 3);
  *(_QWORD *)&result = vaddq_f32(v35, vmulq_n_f32(vmulq_n_f32(vaddq_f32(v24, vmulq_n_f32(v32, 1.0 - v24.f32[3])), 1.0 - v34), 1.0 - v35.f32[3])).u64[0];
  return result;
}

void CI::f4_s_s_s_s_s_clr_clr_clr_clr_f2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  const vec2 *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  double *v27;
  __n128 *v28;
  __n128 *v29;
  __n128 *v30;
  __n128 *v31;
  __n128 *v32;
  __n128 *v33;
  __n128 *v34;
  __int128 v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  double (*v40)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double);
  uint64_t v41;
  const vec2 *v42;
  uint64_t v43;
  int v44;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_DWORD *)(v9 + 88);
  v18 = *(_QWORD *)(v9 + 80);
  v19 = *(_DWORD *)(v9 + 112);
  v20 = *(_QWORD *)(v9 + 104);
  v21 = *(const vec2 **)(v9 + 128);
  v22 = *(_QWORD *)(v9 + 152);
  v23 = *(_QWORD *)(v9 + 176);
  v24 = *(_QWORD *)(v9 + 200);
  v25 = *(_DWORD *)(v9 + 232);
  v26 = *(_QWORD *)(v9 + 224);
  if (*(_BYTE *)(a1 + 64))
  {
    v40 = *(double (**)(__n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128, double, double, double))(a1 + 24);
    v41 = *(_QWORD *)(v9 + 32);
    v44 = *(_DWORD *)(v9 + 16);
    v42 = *(const vec2 **)(v9 + 128);
    v43 = *(_QWORD *)(v9 + 200);
    v39 = *(_QWORD *)(v9 + 56);
    v37 = *(_DWORD *)(v9 + 112);
    v38 = *(_DWORD *)(v9 + 88);
    v36 = *(_DWORD *)(v9 + 232);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 248)), v21);
    v25 = v36;
    v19 = v37;
    v17 = v38;
    v16 = v39;
    v10 = v40;
    v14 = v41;
    v21 = v42;
    v24 = v43;
    v11 = v44;
  }
  v27 = (double *)(a3 + 16 * v26);
  if (v25 != 5)
    v27 = (double *)(a2 + (v26 << 6));
  v28 = (__n128 *)(a3 + 16 * v20);
  if (v19 != 5)
    v28 = (__n128 *)(a2 + (v20 << 6));
  v29 = (__n128 *)(a3 + 16 * v18);
  if (v17 != 5)
    v29 = (__n128 *)(a2 + (v18 << 6));
  v30 = (__n128 *)(a3 + 16 * v16);
  v31 = (__n128 *)(a2 + (v16 << 6));
  if (v15 != 5)
    v30 = v31;
  v32 = (__n128 *)(a3 + 16 * v14);
  v33 = (__n128 *)(a2 + (v14 << 6));
  if (v13 != 5)
    v32 = v33;
  v34 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v34 = (__n128 *)(a2 + (v12 << 6));
  *(double *)&v35 = v10(*v34, *v32, *v30, *v29, *v28, *(__n128 *)(a2 + ((_QWORD)v21 << 6)), *(__n128 *)(a2 + (v22 << 6)), *(__n128 *)(a2 + (v23 << 6)), *(double *)(a2 + (v24 << 6)), *(double *)(a2 + (v24 << 6) + 8), *v27);
  *(_OWORD *)(a3 + 16 * a7) = v35;
}

double cikernel::_outerBevelEmboss(uint64_t a1, int32x2_t a2)
{
  float32x2_t v3;
  float32x2_t v4;
  double v5;
  double v6;
  uint8x8_t v7;
  int8x16_t v8;
  float64x2_t v9;
  double v10;
  int8x16_t v11;
  float32x4_t v12;
  double v13;
  double v14;
  uint8x8_t v15;
  int8x16_t v16;
  float64x2_t v17;
  double v18;
  int8x16_t v19;
  float32x4_t v20;
  double v21;
  double v22;
  uint8x8_t v23;
  int8x16_t v24;
  float64x2_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  double v29;
  double v30;
  uint8x8_t v31;
  int8x16_t v32;
  float64x2_t v33;
  double v34;
  int8x16_t v35;
  float32x4_t v36;
  double v37;
  float v38;
  BOOL v39;
  double result;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;

  v3 = *(float32x2_t *)CI::getDC((CI *)a1);
  v4 = vadd_f32((float32x2_t)vdup_lane_s32(a2, 1), v3);
  *(float *)&v5 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), v4, 1), *(float *)(a1 + 16), v4.f32[0]);
  LODWORD(v6) = *(_DWORD *)(a1 + 28);
  v7.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v8.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), v4, 1), *(float *)&v6, v4.f32[0]);
  v4.f32[0] = *(float *)(a1 + 24) + *(float *)&v5;
  *(float *)v9.f64 = *(float *)v7.i32 + *(float *)v8.i32;
  v4.f32[1] = *(float *)v7.i32 + *(float *)v8.i32;
  *(double *)v12.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)&v4, v9, v5, v6, v8, v7, v10, v11);
  v43 = v12;
  *(float32x2_t *)v12.f32 = vadd_f32((float32x2_t)a2, v3);
  *(float *)&v13 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v12.f32, 1), *(float *)(a1 + 16), v12.f32[0]);
  LODWORD(v14) = *(_DWORD *)(a1 + 28);
  v15.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v16.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v12.f32, 1), *(float *)&v14, v12.f32[0]);
  v12.f32[0] = *(float *)(a1 + 24) + *(float *)&v13;
  *(float *)v17.f64 = *(float *)v15.i32 + *(float *)v16.i32;
  v12.f32[1] = *(float *)v15.i32 + *(float *)v16.i32;
  *(double *)v20.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v12.i64, v17, v13, v14, v16, v15, v18, v19);
  v42 = v20;
  *(float32x2_t *)v20.f32 = vadd_f32((float32x2_t)vrev64_s32(a2), v3);
  *(float *)&v21 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v20.f32, 1), *(float *)(a1 + 16), v20.f32[0]);
  LODWORD(v22) = *(_DWORD *)(a1 + 28);
  v23.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v24.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v20.f32, 1), *(float *)&v22, v20.f32[0]);
  v20.f32[0] = *(float *)(a1 + 24) + *(float *)&v21;
  *(float *)v25.f64 = *(float *)v23.i32 + *(float *)v24.i32;
  v20.f32[1] = *(float *)v23.i32 + *(float *)v24.i32;
  *(double *)v28.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v20.i64, v25, v21, v22, v24, v23, v26, v27);
  v41 = v28;
  *(float32x2_t *)v28.f32 = vadd_f32((float32x2_t)vdup_lane_s32(a2, 0), v3);
  *(float *)&v29 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 20), *(float32x2_t *)v28.f32, 1), *(float *)(a1 + 16), v28.f32[0]);
  LODWORD(v30) = *(_DWORD *)(a1 + 28);
  v31.i32[0] = *(_DWORD *)(a1 + 36);
  *(float *)v32.i32 = vmlas_n_f32(vmuls_lane_f32(*(float *)(a1 + 32), *(float32x2_t *)v28.f32, 1), *(float *)&v30, v28.f32[0]);
  v28.f32[0] = *(float *)(a1 + 24) + *(float *)&v29;
  *(float *)v33.f64 = *(float *)v31.i32 + *(float *)v32.i32;
  v28.f32[1] = *(float *)v31.i32 + *(float *)v32.i32;
  *(double *)v36.i64 = CI::BitmapSampler::read(*(uint64x2_t **)(a1 + 8), *(double *)v28.i64, v33, v29, v30, v32, v31, v34, v35);
  v36.f32[0] = COERCE_FLOAT(vaddq_f32(v43, v42).i32[3]) + COERCE_FLOAT(vaddq_f32(v41, v36).i32[3]) * -1.3;
  v37 = v36.f32[0] * 0.5 + 0.5;
  *(float *)&v37 = v37;
  v38 = 1.0;
  if (*(float *)&v37 <= 1.0)
    v38 = *(float *)&v37;
  v39 = *(float *)&v37 < 0.0;
  LODWORD(v37) = 0;
  if (!v39)
    *(float *)&v37 = v38;
  *(_QWORD *)&result = vdupq_lane_s32(*(int32x2_t *)&v37, 0).u64[0];
  return result;
}

double cikernel::_outerBevelEmbossC(__n128 a1, float32x4_t a2, float32x4_t a3)
{
  float v3;
  float v4;
  float v5;
  BOOL v6;
  BOOL v7;
  float v8;
  float32x4_t v9;
  double result;

  v3 = a1.n128_f32[3] * 2.0 + -1.0;
  v4 = 1.0;
  if (v3 <= 1.0)
    v5 = a1.n128_f32[3] * 2.0 + -1.0;
  else
    v5 = 1.0;
  if (v3 >= -1.0)
    v4 = -v3;
  v6 = v3 < 0.0;
  v7 = v3 <= 0.0;
  v8 = 0.0;
  if (v6)
    v5 = 0.0;
  v9 = vmulq_n_f32(a2, v5);
  if (v7)
    v8 = v4;
  *(_QWORD *)&result = vaddq_f32(vmulq_n_f32(a3, v8), v9).u64[0];
  return result;
}

double cikernel::_invertedMask()
{
  return 0.0;
}

double cikernel::_multiplyByMask(float32x4_t a1, float32x4_t a2)
{
  double result;

  *(_QWORD *)&result = vmulq_laneq_f32(a1, a2, 3).u64[0];
  return result;
}

void CI::f4_s_f_f_f_f_f(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(_QWORD *, __n128, float, float, float, float, float);
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __n128 *v18;
  __int128 v19;

  v9 = a1[6];
  v10 = (double (*)(_QWORD *, __n128, float, float, float, float, float))a1[3];
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_QWORD *)(v9 + 32);
  v14 = *(_QWORD *)(v9 + 56);
  v15 = *(_QWORD *)(v9 + 80);
  v16 = *(_QWORD *)(v9 + 104);
  v17 = *(_QWORD *)(v9 + 128);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 152)), a2);
  v18 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v19 = v10(a1, *v18, *((float *)a2 + 16 * v13), *((float *)a2 + 16 * v14), *((float *)a2 + 16 * v15), *((float *)a2 + 16 * v16), *((float *)a2 + 16 * v17));
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

void CI::snprintf_cs(CI *this, char *a2, CGColorSpace *a3, CGColorSpace *a4)
{
  int v4;
  int Type;
  const char *v9;
  BOOL v10;
  const char *v11;
  const char *v12;
  BOOL v13;
  const char *v14;
  unsigned __int8 v15;
  CFStringRef Name;
  const __CFString *v17;
  const char *v18;
  double v19;
  const char *v20;
  const char *v21;
  char v22;
  BOOL v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  char buffer[16];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _OWORD v34[5];
  uint64_t v35;

  v4 = (int)a4;
  v35 = *MEMORY[0x1E0C80C00];
  Type = CGColorSpaceGetType();
  if (a3)
  {
    switch(Type)
    {
      case 0:
        snprintf((char *)this, (size_t)a2, "devicegray");
        return;
      case 1:
      case 2:
        snprintf((char *)this, (size_t)a2, "devicergb");
        return;
      case 3:
        *(_QWORD *)&v33 = 0;
        v31 = 0u;
        v32 = 0u;
        *(_OWORD *)buffer = 0u;
        CGColorSpaceGetCalibratedGrayData();
        snprintf((char *)this, (size_t)a2, "calGray(");
        v10 = 0.96420002 == 0.0 && *(double *)&buffer[8] == 1.0;
        if (v10 && *(double *)&v31 == 0.824899971)
        {
          v11 = "wp=d50 ";
        }
        else
        {
          *(_QWORD *)&v26 = v31;
          v24 = *(_OWORD *)buffer;
          v11 = "wp=%.3f,%.3f,%.3f ";
        }
        CI::snprintfcat(this, a2, v11, v9, 0.0, 0.0, 0.0, v24, (_QWORD)v26);
        if (*((double *)&v31 + 1) != 0.0 || *(double *)&v32 != 0.0 || *((double *)&v32 + 1) != 0.0)
          CI::snprintfcat(this, a2, "bp=%.3f,%.3f,%.3f ", v18, *((_QWORD *)&v31 + 1), v32);
        v19 = *(double *)&v33;
        if (*(double *)&v33 == 1.0)
        {
          v20 = "gamma=1)";
          goto LABEL_56;
        }
        CI::snprintfcat(this, a2, "gamma=%.3f)", v18, *(double *)&v33, (_QWORD)v33, *((_QWORD *)&v25 + 1), (_QWORD)v26);
        return;
      case 4:
        v33 = 0u;
        memset(v34, 0, sizeof(v34));
        v31 = 0u;
        v32 = 0u;
        *(_OWORD *)buffer = 0u;
        CGColorSpaceGetCalibratedRGBData();
        snprintf((char *)this, (size_t)a2, "calRGB(");
        v13 = 0.96420002 == 0.0 && *(double *)&buffer[8] == 1.0;
        if (v13 && *(double *)&v31 == 0.824899971)
          snprintf((char *)this, (size_t)a2, "wp=d50 ", 0.0, 0.0, 0.0);
        else
          CI::snprintfcat(this, a2, "wp=%.3f,%.3f,%.3f ", v12, *(_QWORD *)buffer, *(_QWORD *)&buffer[8], (_QWORD)v31);
        if (*((double *)&v31 + 1) != 0.0 || *(double *)&v32 != 0.0 || *((double *)&v32 + 1) != 0.0)
          CI::snprintfcat(this, a2, "bp=%.3f,%.3f,%.3f ", v14, *((_QWORD *)&v31 + 1), v32);
        if (*(double *)&v33 == 1.0 && *((double *)&v33 + 1) == 1.0 && *(double *)v34 == 1.0)
        {
          v21 = "gamma=1 ";
        }
        else
        {
          if (*(double *)&v33 == *((double *)&v33 + 1) && *((double *)&v33 + 1) == *(double *)v34)
          {
            CI::snprintfcat(this, a2, "gamma=%.3f ", v14, *((double *)&v33 + 1), *(double *)&v33, *(double *)v34, *((_QWORD *)&v33 + 1), *((_QWORD *)&v24 + 1), (_QWORD)v26);
            goto LABEL_55;
          }
          *(_QWORD *)&v26 = *(_QWORD *)&v34[0];
          v24 = v33;
          v21 = "gamma=%.3f,%.3f,%.3f ";
        }
        CI::snprintfcat(this, a2, v21, v14, *((double *)&v33 + 1), *(double *)&v33, *(double *)v34, v24, (_QWORD)v26);
LABEL_55:
        v19 = *((double *)v34 + 1);
        v29 = *((_QWORD *)&v34[4] + 1);
        v27 = *(_OWORD *)((char *)&v34[2] + 8);
        v28 = *(_OWORD *)((char *)&v34[3] + 8);
        v25 = *(_OWORD *)((char *)v34 + 8);
        v26 = *(_OWORD *)((char *)&v34[1] + 8);
        v20 = "mtx=%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)";
LABEL_56:
        CI::snprintfcat(this, a2, v20, v18, v19, v25, v26, v27, v28, v29);
        return;
      case 5:
        snprintf((char *)this, (size_t)a2, "Lab Colorspace %p");
        return;
      case 6:
        if ((v15 & 1) == 0
        {
          CI::snprintf_cs(char *,unsigned long,CGColorSpace *,BOOL)::sRGB_cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
        }
        if ((CGColorSpace *)CI::snprintf_cs(char *,unsigned long,CGColorSpace *,BOOL)::sRGB_cs == a3)
        {
          snprintf((char *)this, (size_t)a2, "sRGB");
          return;
        }
        memset(v34, 0, 64);
        v32 = 0u;
        v33 = 0u;
        *(_OWORD *)buffer = 0u;
        v31 = 0u;
        Name = CGColorSpaceGetName(a3);
        if (Name)
        {
          v17 = Name;
          CFRetain(Name);
LABEL_59:
          CFStringGetCString(v17, buffer, 128, 0x8000100u);
          v22 = 0;
          goto LABEL_60;
        }
        v17 = (const __CFString *)CGColorSpaceCopyICCProfileDescription();
        if (v17)
          goto LABEL_59;
        v22 = 1;
LABEL_60:
        v23 = *(_QWORD *)buffer == 0x726F6C6F4347436BLL && *(_QWORD *)&buffer[5] == 0x6563617053726F6CLL;
        if (v23 || !v4)
          snprintf((char *)this, (size_t)a2, "%s");
        else
          snprintf((char *)this, (size_t)a2, "\"%s\"");
        if ((v22 & 1) == 0)
          CFRelease(v17);
        break;
      case 7:
        snprintf((char *)this, (size_t)a2, "Indexed Colorspace %p");
        return;
      case 8:
        snprintf((char *)this, (size_t)a2, "DeviceN Colorspace %p");
        return;
      case 9:
        snprintf((char *)this, (size_t)a2, "Pattern Colorspace %p");
        return;
      case 10:
        snprintf((char *)this, (size_t)a2, "PlatformSets Colorspace %p");
        return;
      default:
        snprintf((char *)this, (size_t)a2, "%p");
        return;
    }
  }
  else
  {
    snprintf((char *)this, (size_t)a2, "nil");
  }
}

size_t CI::snprintfcat(CI *this, char *a2, const char *a3, const char *a4, ...)
{
  size_t result;
  va_list va;

  va_start(va, a4);
  result = strlen((const char *)this);
  if ((unint64_t)a2 > result)
    return vsnprintf((char *)this + result, (size_t)&a2[-result], a3, va);
  return result;
}

uint64_t CI::fprintf_cs(FILE *this, __sFILE *a2, CGColorSpace *a3)
{
  char v5[256];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  CI::snprintf_cs((CI *)v5, (char *)0x100, (CGColorSpace *)a2, a3);
  return fputs(v5, this);
}

CGColorSpace *CI::ColorSpace_is_RGB(CGColorSpace *this, CGColorSpace *a2)
{
  CGColorSpace *v2;
  CFTypeID v3;

  if (this)
  {
    v2 = this;
    v3 = CFGetTypeID(this);
    if (v3 == CGColorSpaceGetTypeID())
      return (CGColorSpace *)(CGColorSpaceGetModel(v2) == kCGColorSpaceModelRGB);
    else
      return 0;
  }
  return this;
}

CGColorSpace *CI::ColorSpace_is_RGB_or_Gray(CGColorSpace *this, CGColorSpace *a2)
{
  CGColorSpace *v2;
  CFTypeID v3;

  if (this)
  {
    v2 = this;
    v3 = CFGetTypeID(this);
    if (v3 == CGColorSpaceGetTypeID())
      return (CGColorSpace *)(CGColorSpaceGetModel(v2) < kCGColorSpaceModelCMYK);
    else
      return 0;
  }
  return this;
}

BOOL CI::ColorSpace_is_RGB_and_supports_output(_BOOL8 this, CGColorSpace *a2)
{
  CGColorSpace *v2;
  CFTypeID v3;

  if (this)
  {
    v2 = (CGColorSpace *)this;
    v3 = CFGetTypeID((CFTypeRef)this);
    if (v3 == CGColorSpaceGetTypeID())
    {
      this = CGColorSpaceSupportsOutput(v2);
      if ((_DWORD)this)
        return CGColorSpaceGetModel(v2) == kCGColorSpaceModelRGB;
    }
    else
    {
      return 0;
    }
  }
  return this;
}

BOOL CI::ColorSpace_is_RGB_or_Gray_and_supports_output(_BOOL8 this, CGColorSpace *a2)
{
  CGColorSpace *v2;
  CFTypeID v3;

  if (this)
  {
    v2 = (CGColorSpace *)this;
    v3 = CFGetTypeID((CFTypeRef)this);
    if (v3 == CGColorSpaceGetTypeID())
    {
      this = CGColorSpaceSupportsOutput(v2);
      if ((_DWORD)this)
        return CGColorSpaceGetModel(v2) < kCGColorSpaceModelCMYK;
    }
    else
    {
      return 0;
    }
  }
  return this;
}

CGColorSpace *CI::ColorSpace_is_HDR(CGColorSpace *this, CGColorSpace *a2)
{
  if (this)
    return (CGColorSpace *)CGColorSpaceIsHDR(this);
  return this;
}

CGColorSpace *CI::ColorSpaceCreateSDRCopy(CGColorSpace *this, CGColorSpace *a2)
{
  CGColorSpace *v2;
  CGColorSpace *v3;
  CGColorSpace *v4;
  CGColorSpace *v5;
  CGColorSpace *v6;
  CGColorSpace *v7;
  char v8;
  char v9;
  int v10;
  int v11;
  int v12;
  CFStringRef *v13;

  if (this)
  {
    v2 = this;
    if (CGColorSpaceIsHDR(this))
    {
      v3 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D918]);
      v4 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D920]);
      v5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D910]);
      v6 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D9E0]);
      v7 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D9D8]);
      v8 = CGColorSpaceEqualToColorSpace();
      v9 = CGColorSpaceEqualToColorSpace();
      v10 = CGColorSpaceEqualToColorSpace();
      v11 = CGColorSpaceEqualToColorSpace();
      v12 = CGColorSpaceEqualToColorSpace();
      CGColorSpaceRelease(v3);
      CGColorSpaceRelease(v4);
      CGColorSpaceRelease(v5);
      CGColorSpaceRelease(v6);
      CGColorSpaceRelease(v7);
      if ((v8 & 1) != 0 || (v9 & 1) != 0 || v10 || (v11 | v12) != 1)
        v13 = (CFStringRef *)MEMORY[0x1E0C9D908];
      else
        v13 = (CFStringRef *)MEMORY[0x1E0C9DA10];
      return CGColorSpaceCreateWithName(*v13);
    }
    else
    {
      return CGColorSpaceRetain(v2);
    }
  }
  return this;
}

CGColorSpace *CI::ColorSpaceCreatePQBasedCopy(CGColorSpace *this, CGColorSpace *a2)
{
  CGColorSpace *v2;
  CGColorSpace *v3;
  CGColorSpace *v4;
  CGColorSpace *v5;
  int v6;
  int v7;
  int v8;
  CFStringRef *v9;

  if (this)
  {
    v2 = this;
    if (CGColorSpaceIsPQBased(this))
    {
      return CGColorSpaceRetain(v2);
    }
    else
    {
      v3 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D908]);
      v4 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
      v5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D9D0]);
      v6 = CGColorSpaceEqualToColorSpace();
      v7 = CGColorSpaceEqualToColorSpace();
      v8 = CGColorSpaceEqualToColorSpace();
      CGColorSpaceRelease(v3);
      CGColorSpaceRelease(v4);
      CGColorSpaceRelease(v5);
      if (v6)
      {
        v9 = (CFStringRef *)MEMORY[0x1E0C9D918];
      }
      else if ((v7 | v8) == 1)
      {
        v9 = (CFStringRef *)MEMORY[0x1E0C9D9E0];
      }
      else
      {
        v9 = (CFStringRef *)MEMORY[0x1E0C9D9C8];
      }
      return CGColorSpaceCreateWithName(*v9);
    }
  }
  return this;
}

unsigned __int8 **ConvertYCbCrtoREDEYEFORMAT(unsigned __int8 **result, unsigned __int8 **a2, uint64_t a3, int a4)
{
  int v4;
  int v5;
  const char *v6;
  int v7;
  int v8;
  unsigned __int8 *v9;
  char *v10;
  int v11;
  unsigned __int8 *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  unsigned __int8 *v18;
  char *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;
  char v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  char v37;
  int v38;
  char *v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  char v48;
  char v49;
  char v50;
  char v51;
  uint64_t v52;
  unsigned __int8 *v53;
  int v54;
  unsigned int v55;
  unsigned int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  char v64;
  char v65;
  char v66;
  char v67;
  int v68;
  char *v69;
  unsigned int v70;
  unsigned int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  char v79;
  char v80;
  char v81;
  char v82;
  char v83;
  unsigned __int8 *v84;
  int v85;
  char *v86;
  unsigned __int8 *v87;

  v4 = *((_DWORD *)result + 2);
  v5 = *((_DWORD *)a2 + 2);
  if (v4 != 2 * v5)
  {
    v6 = "ConvertYCbCrtoREDEYEFORMAT: widths do not match";
    return (unsigned __int8 **)puts(v6);
  }
  if (*((_DWORD *)result + 3) != 2 * *((_DWORD *)a2 + 3))
  {
    v6 = "ConvertYCbCrtoREDEYEFORMAT: heights do not match";
    return (unsigned __int8 **)puts(v6);
  }
  if (*((_DWORD *)result + 4) < *((_DWORD *)result + 7) * v4)
  {
    v6 = "ConvertYCbCrtoREDEYEFORMAT: rowSamples is too small for Y bitmap";
    return (unsigned __int8 **)puts(v6);
  }
  v7 = *((_DWORD *)a2 + 4);
  if (v7 < *((_DWORD *)a2 + 7) * v5)
  {
    v6 = "ConvertYCbCrtoREDEYEFORMAT: rowSamples is too small for CbCr bitmap";
    return (unsigned __int8 **)puts(v6);
  }
  if (*(int *)(a3 + 12) >= 1)
  {
    v8 = 0;
    v9 = *a2;
    v10 = *(char **)a3;
    v87 = *result;
    while (1)
    {
      if ((v8 & 1) != 0)
      {
        v11 = *((_DWORD *)result + 3) - 1;
      }
      else
      {
        v11 = 0;
        v7 = -v7;
      }
      if (v8 == v11)
        v7 = 0;
      v12 = &v9[v7];
      v13 = *v9;
      v14 = v9[1];
      v15 = *v12;
      v16 = v12[1];
      v86 = v10;
      if (*((int *)result + 2) >= 3)
        break;
      v23 = *v9;
      v22 = v9[1];
      v21 = *v12;
      v20 = v12[1];
      v53 = v87;
      v19 = v10;
      v18 = v9;
LABEL_61:
      v54 = *v53;
      v55 = ((9 * v13 + v21 + 3 * (v15 + v23) + 8) >> 4) - 128;
      v56 = ((9 * v14 + v20 + 3 * (v16 + v22) + 8) >> 4) - 128;
      v57 = v54 + ((int)(22970 * v56 + 0x2000) >> 14);
      v58 = v54 + ((int)(-11700 * v56 - 5638 * v55 + 0x2000) >> 14);
      v59 = v54 + ((int)(29032 * v55 + 0x2000) >> 14);
      if (v57 >= 255)
        v60 = 255;
      else
        v60 = v57;
      v61 = v60 & ~(v60 >> 31);
      if (v58 >= 255)
        v58 = 255;
      v62 = v58 & ~(v58 >> 31);
      if (v59 >= 255)
        v59 = 255;
      v63 = v59 & ~(v59 >> 31);
      if (a4)
        v64 = v61;
      else
        v64 = -1;
      if (a4)
        v65 = v62;
      else
        v65 = v61;
      if (a4)
        v66 = v63;
      else
        v66 = v62;
      if (a4)
        v67 = -1;
      else
        v67 = v63;
      if (a4 == 2)
      {
        v64 = v63;
        v65 = v62;
        v66 = v61;
        v67 = -1;
      }
      if (a4 == 3)
      {
        v64 = -1;
      }
      else
      {
        LOBYTE(v63) = v65;
        LOBYTE(v62) = v66;
        LOBYTE(v61) = v67;
      }
      *v19 = v64;
      v19[1] = v63;
      v19[2] = v62;
      v19[3] = v61;
      if (*(_DWORD *)(a3 + 8) == *((_DWORD *)result + 2))
      {
        v68 = v53[1];
        v69 = &v19[*(int *)(a3 + 28)];
        v70 = ((9 * *v18 + *v12 + 3 * (*v12 + *v18) + 8) >> 4) - 128;
        v71 = ((9 * v18[1] + v12[1] + 3 * (v12[1] + v18[1]) + 8) >> 4) - 128;
        v72 = v68 + ((int)(22970 * v71 + 0x2000) >> 14);
        v73 = v68 + ((int)(-5638 * v70 - 11700 * v71 + 0x2000) >> 14);
        v74 = v68 + ((int)(29032 * v70 + 0x2000) >> 14);
        if (v72 >= 255)
          v75 = 255;
        else
          v75 = v72;
        v76 = v75 & ~(v75 >> 31);
        if (v73 >= 255)
          v73 = 255;
        v77 = v73 & ~(v73 >> 31);
        if (v74 >= 255)
          v74 = 255;
        v78 = v74 & ~(v74 >> 31);
        if (a4)
          v79 = v76;
        else
          v79 = -1;
        if (a4)
          v80 = v77;
        else
          v80 = v76;
        if (a4)
          v81 = v78;
        else
          v81 = v77;
        if (a4)
          v82 = -1;
        else
          v82 = v78;
        if (a4 == 2)
        {
          v79 = v78;
          v80 = v77;
          v81 = v76;
          v82 = -1;
        }
        if (a4 == 3)
        {
          v79 = -1;
        }
        else
        {
          LOBYTE(v78) = v80;
          LOBYTE(v77) = v81;
        }
        *v69 = v79;
        v69[1] = v78;
        if (a4 == 3)
          v83 = v76;
        else
          v83 = v82;
        v69[2] = v77;
        v69[3] = v83;
      }
      v7 = *((_DWORD *)a2 + 4);
      v9 += v7 * (v8++ & 1);
      v87 += *((int *)result + 4);
      v10 = &v86[*(int *)(a3 + 16)];
      if (v8 >= *(_DWORD *)(a3 + 12))
        return result;
    }
    v85 = v8;
    v17 = 0;
    v84 = v9;
    v18 = v9;
    v19 = v10;
    v20 = v12[1];
    v21 = *v12;
    v22 = v9[1];
    v23 = *v9;
    while (1)
    {
      v24 = v87[v17];
      v25 = (9 * v14 + v20 + 3 * (v16 + v22) + 8) >> 4;
      v26 = ((9 * v13 + v21 + 3 * (v15 + v23) + 8) >> 4) - 128;
      v27 = v25 - 128;
      v28 = v24 + ((int)(-11700 * v27 - 5638 * v26 + 0x2000) >> 14);
      v29 = v24 + ((int)(29032 * v26 + 0x2000) >> 14);
      v30 = -1;
      if (v24 + ((int)(22970 * v27 + 0x2000) >> 14) >= 255)
        v31 = 255;
      else
        v31 = v24 + ((int)(22970 * v27 + 0x2000) >> 14);
      v32 = v31 & ~(v31 >> 31);
      if (v28 >= 255)
        v33 = 255;
      else
        v33 = v28;
      v34 = v33 & ~(v33 >> 31);
      if (v29 >= 255)
        v35 = 255;
      else
        v35 = v29;
      v36 = v35 & ~(v35 >> 31);
      if (a4 == 3)
      {
        v37 = v34;
        v30 = v32;
        LOBYTE(v32) = -1;
        LOBYTE(v34) = v36;
      }
      else
      {
        if (a4 != 2)
        {
          if (!a4)
          {
            v30 = v36;
            LOBYTE(v36) = v34;
            LOBYTE(v34) = v32;
            LOBYTE(v32) = -1;
          }
          goto LABEL_35;
        }
        v37 = v32;
        LOBYTE(v32) = v36;
      }
      LOBYTE(v36) = v37;
LABEL_35:
      *v19 = v32;
      v19[1] = v34;
      v19[2] = v36;
      v19[3] = v30;
      v38 = v87[v17 + 1];
      v23 = *v18;
      v22 = v18[1];
      v13 = v18[2];
      v14 = v18[3];
      v21 = *v12;
      v20 = v12[1];
      v15 = v12[2];
      v16 = v12[3];
      v39 = &v19[*(int *)(a3 + 28)];
      v40 = ((9 * v23 + v15 + 3 * (v21 + v13) + 8) >> 4) - 128;
      v41 = ((9 * v22 + v16 + 3 * (v20 + v14) + 8) >> 4) - 128;
      v42 = v38 + ((int)(22970 * v41 + 0x2000) >> 14);
      v43 = v38 + ((int)(-11700 * v41 - 5638 * v40 + 0x2000) >> 14);
      v44 = v38 + ((int)(29032 * v40 + 0x2000) >> 14);
      if (v42 >= 255)
        v42 = 255;
      v45 = v42 & ~(v42 >> 31);
      if (v43 >= 255)
        v43 = 255;
      v46 = v43 & ~(v43 >> 31);
      if (v44 >= 255)
        v44 = 255;
      v47 = v44 & ~(v44 >> 31);
      if (a4)
        v48 = v45;
      else
        v48 = -1;
      if (a4)
        v49 = v46;
      else
        v49 = v45;
      if (a4)
        v50 = v47;
      else
        v50 = v46;
      if (a4)
        v51 = -1;
      else
        v51 = v47;
      if (a4 == 2)
      {
        v48 = v47;
        v49 = v46;
        v50 = v45;
        v51 = -1;
      }
      if (a4 == 3)
      {
        v48 = -1;
        v49 = v47;
      }
      else
      {
        LOBYTE(v46) = v50;
        LOBYTE(v45) = v51;
      }
      *v39 = v48;
      v39[1] = v49;
      v39[2] = v46;
      v39[3] = v45;
      v52 = *((int *)a2 + 7);
      v18 += v52;
      v12 += v52;
      v19 += 2 * *(int *)(a3 + 28);
      v17 += 2;
      if ((int)v17 >= *((_DWORD *)result + 2) - 2)
      {
        v53 = &v87[v17];
        v8 = v85;
        v9 = v84;
        goto LABEL_61;
      }
    }
  }
  return result;
}

_DWORD *ConvertREDEYEFORMATtoYCbCr(_DWORD *result, uint64_t *a2, uint64_t *a3, int a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  unsigned __int8 *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _BYTE *v27;
  int v28;
  uint64_t v29;
  int v30;
  _BYTE *v31;
  unsigned __int8 *v32;
  int v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  unsigned __int8 *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  unsigned int v47;
  int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unsigned __int8 *v57;
  int v58;
  _BYTE *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  _DWORD *v75;
  uint64_t v76;

  v75 = result;
  v4 = result[3];
  if (v4 >= 1)
  {
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = *a3;
    v74 = *((int *)a3 + 7);
    v56 = *((int *)a3 + 4);
    v18 = (int)result[7];
    v64 = v18 + 3;
    v19 = (int)result[4];
    v71 = v18 + 2;
    v20 = *((int *)a2 + 7);
    v62 = v18 + v19 + 3;
    v21 = *((int *)a2 + 4);
    v70 = (int)v18 + (int)v19 + 2;
    v69 = (int)v18 + (int)v19 + 1;
    v61 = (int)v18 + (int)v19;
    v73 = 2 * v20;
    v55 = 2 * v21;
    v22 = (_BYTE *)(v17 + 1);
    v23 = *(unsigned __int8 **)v75;
    v76 = *a2 + v20;
    v24 = *a2 + v21;
    v25 = *a2;
    v26 = *a2 + v20 + v21;
    v27 = v22;
    v68 = v18 + 1;
    v60 = v19 + 3;
    v67 = v19 + 2;
    v65 = (int)v75[7];
    v66 = v19 + 1;
    v72 = 2 * v18;
    v63 = (int)v75[4];
    v54 = 2 * v19;
    v28 = v75[2];
    do
    {
      v59 = v27;
      if (v28 >= 1)
      {
        v58 = v16;
        v29 = 0;
        v30 = 0;
        v31 = v27;
        v57 = v23;
        v32 = v23;
        do
        {
          v33 = a4;
          switch(a4)
          {
            case 0:
              v34 = v32 + 1;
              v35 = v32 + 2;
              v36 = v32 + 3;
              v37 = v67;
              v38 = v68;
              v40 = v70;
              v39 = v71;
              v41 = v64;
              v42 = v66;
              v43 = v60;
              v44 = v69;
              v45 = v62;
              goto LABEL_10;
            case 1:
              v35 = v32 + 1;
              v36 = v32 + 2;
              v38 = v65;
              v37 = v66;
              v43 = v67;
              v39 = v68;
              v45 = v70;
              v41 = v71;
              v42 = v63;
              v44 = v61;
              v40 = v69;
              v34 = v32;
              goto LABEL_10;
            case 2:
              v34 = v32 + 2;
              v35 = v32 + 1;
              v36 = v32;
              v44 = v70;
              v38 = v71;
              v42 = v67;
              v39 = v68;
              v41 = v65;
              v37 = v66;
              v43 = v63;
              v40 = v69;
              v45 = v61;
              goto LABEL_10;
            case 3:
              v34 = v32 + 3;
              v35 = v32 + 2;
              v36 = v32 + 1;
              v38 = v64;
              v40 = v70;
              v39 = v71;
              v37 = v67;
              v41 = v68;
              v42 = v60;
              v43 = v66;
              v44 = v62;
              v45 = v69;
LABEL_10:
              v14 = *v35;
              v15 = *v34;
              v13 = *v36;
              v12 = v32[v38];
              v11 = v32[v39];
              v10 = v32[v41];
              v9 = v32[v42];
              v8 = v32[v37];
              v33 = v32[v43];
              v7 = v32[v44];
              v6 = v32[v40];
              v5 = v32[v45];
              break;
            default:
              break;
          }
          v46 = (v15 + v12 + v9 + v7 + 2) >> 2;
          v47 = (v14 + v11 + v8 + v6 + 2) >> 2;
          v48 = -5427 * v47 - 2765 * v46;
          v49 = -6860 * v47 + (v46 << 13);
          v50 = (v13 + v10 + v33 + v5 + 2) >> 2;
          v51 = v49 - 1332 * v50;
          *(_BYTE *)(v25 + v29) = (9617 * v14 + 4899 * v15 + 1868 * v13 + 0x2000) >> 14;
          *(_BYTE *)(v76 + v29) = (9617 * v11 + 4899 * v12 + 1868 * v10 + 0x2000) >> 14;
          *(_BYTE *)(v24 + v29) = (9617 * v8 + 4899 * v9 + 1868 * v33 + 0x2000) >> 14;
          *(_BYTE *)(v26 + v29) = (9617 * v6 + 4899 * v7 + 1868 * v5 + 0x2000) >> 14;
          v52 = (int)(v48 + (v50 << 13) + 0x2000) >> 14;
          if (v52 >= 127)
            LOBYTE(v52) = 127;
          *(v31 - 1) = v52 ^ 0x80;
          v53 = (int)(v51 + 0x2000) >> 14;
          if (v53 >= 127)
            LOBYTE(v53) = 127;
          *v31 = v53 ^ 0x80;
          v30 += 2;
          v32 += v72;
          v28 = v75[2];
          v31 += v74;
          v29 += v73;
        }
        while (v30 < v28);
        v4 = v75[3];
        v16 = v58;
        v23 = v57;
      }
      v16 += 2;
      result = (_DWORD *)v55;
      v23 += v54;
      v25 += v55;
      v27 = &v59[v56];
      v76 += v55;
      v24 += v55;
      v26 += v55;
    }
    while (v16 < v4);
  }
  return result;
}

unsigned __int8 **ConvertRedChannel2toY(unsigned __int8 **result, unsigned __int8 **a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  const char *v6;
  int v7;
  int v8;
  unsigned __int8 *v9;
  _BYTE *v10;
  unsigned __int8 *v11;
  int v12;
  unsigned __int8 *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  unsigned __int8 *v19;
  _BYTE *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  unsigned __int8 *v44;
  int v45;
  unsigned int v46;
  unsigned int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;

  v3 = *((_DWORD *)result + 2);
  v4 = *((_DWORD *)a2 + 2);
  if (v3 != 2 * v4)
  {
    v6 = "ConvertRedChannel2toY: widths do not match";
    return (unsigned __int8 **)puts(v6);
  }
  v5 = *((_DWORD *)result + 3);
  if (v5 != 2 * *((_DWORD *)a2 + 3))
  {
    v6 = "ConvertRedChannel2toY: heights do not match";
    return (unsigned __int8 **)puts(v6);
  }
  if (*((_DWORD *)result + 4) < *((_DWORD *)result + 7) * v3)
  {
    v6 = "ConvertRedChannel2toY: rowSamples is too small for Y bitmap";
    return (unsigned __int8 **)puts(v6);
  }
  v7 = *((_DWORD *)a2 + 4);
  if (v7 < *((_DWORD *)a2 + 7) * v4)
  {
    v6 = "ConvertRedChannel2toY: rowSamples is too small for CbCr bitmap";
    return (unsigned __int8 **)puts(v6);
  }
  if (*(_DWORD *)(a3 + 16) < *(_DWORD *)(a3 + 28) * *(_DWORD *)(a3 + 8))
  {
    v6 = "ConvertRedChannel2toY: rowSamples is too small for ARGB bitmap";
    return (unsigned __int8 **)puts(v6);
  }
  if (v5 >= 1)
  {
    v8 = 0;
    v9 = *a2;
    v10 = *(_BYTE **)a3;
    v11 = *result;
    do
    {
      v12 = v8 & 1;
      if ((v8 & 1) == 0)
        v7 = -v7;
      if (v8 == ((v8 << 31 >> 31) & (v5 - 1)))
        v7 = 0;
      v13 = &v9[v7];
      v14 = *v9;
      v15 = v9[1];
      v16 = *v13;
      v17 = v13[1];
      if (*((int *)result + 2) < 3)
      {
        v24 = *v9;
        v23 = v9[1];
        v22 = *v13;
        v21 = v13[1];
        v44 = v11;
        v20 = v10;
        v19 = v9;
      }
      else
      {
        v18 = 0;
        v19 = v9;
        v20 = v10;
        v21 = v13[1];
        v22 = *v13;
        v23 = v9[1];
        v24 = *v9;
        do
        {
          v25 = v11[v18];
          v26 = (9 * v15 + v21 + 3 * (v17 + v23) + 8) >> 4;
          v27 = ((9 * v14 + v22 + 3 * (v16 + v24) + 8) >> 4) - 128;
          v26 -= 128;
          v28 = v25 + ((int)(22970 * v26 + 0x2000) >> 14);
          v29 = v25 + ((int)(-11700 * v26 - 5638 * v27 + 0x2000) >> 14);
          v30 = v25 + ((int)(29032 * v27 + 0x2000) >> 14);
          if (v28 >= 255)
            v28 = 255;
          v31 = v28 & ~(v28 >> 31);
          if (v29 >= 255)
            v29 = 255;
          v32 = v29 & ~(v29 >> 31);
          if (v30 >= 255)
            v30 = 255;
          v33 = v31 - (((v30 & ~(v30 >> 31)) + v32 + 1) >> 1);
          *v20 = v33 & ~(v33 >> 31);
          v34 = v11[v18 + 1];
          v24 = *v19;
          v23 = v19[1];
          v14 = v19[2];
          v15 = v19[3];
          v22 = *v13;
          v21 = v13[1];
          v16 = v13[2];
          v17 = v13[3];
          v35 = ((9 * v24 + v16 + 3 * (v22 + v14) + 8) >> 4) - 128;
          v36 = ((9 * v23 + v17 + 3 * (v21 + v15) + 8) >> 4) - 128;
          v37 = v34 + ((int)(22970 * v36 + 0x2000) >> 14);
          v38 = v34 + ((int)(-11700 * v36 - 5638 * v35 + 0x2000) >> 14);
          v39 = v34 + ((int)(29032 * v35 + 0x2000) >> 14);
          if (v37 >= 255)
            v40 = 255;
          else
            v40 = v37;
          v41 = v40 & ~(v40 >> 31);
          if (v38 >= 255)
            v38 = 255;
          v42 = v38 & ~(v38 >> 31);
          if (v39 >= 255)
            v39 = 255;
          v20[1] = (v41 - (((v39 & ~(v39 >> 31)) + v42 + 1) >> 1)) & ~((int)(v41 - (((v39 & ~(v39 >> 31)) + v42 + 1) >> 1)) >> 31);
          v43 = *((int *)a2 + 7);
          v19 += v43;
          v13 += v43;
          v20 += 2 * *(int *)(a3 + 28);
          v18 += 2;
        }
        while ((int)v18 < *((_DWORD *)result + 2) - 2);
        v44 = &v11[v18];
        v12 = v8 & 1;
      }
      v45 = *v44;
      v46 = (9 * v15 + v21 + 3 * (v17 + v23) + 8) >> 4;
      v47 = ((9 * v14 + v22 + 3 * (v16 + v24) + 8) >> 4) - 128;
      v46 -= 128;
      v48 = v45 + ((int)(22970 * v46 + 0x2000) >> 14);
      v49 = v45 + ((int)(-11700 * v46 - 5638 * v47 + 0x2000) >> 14);
      v50 = v45 + ((int)(29032 * v47 + 0x2000) >> 14);
      if (v48 >= 255)
        v51 = 255;
      else
        v51 = v48;
      v52 = v51 & ~(v51 >> 31);
      if (v49 >= 255)
        v49 = 255;
      v53 = v49 & ~(v49 >> 31);
      if (v50 >= 255)
        v50 = 255;
      v54 = v52 - (((v50 & ~(v50 >> 31)) + v53 + 1) >> 1);
      *v20 = v54 & ~(v54 >> 31);
      v55 = v44[1];
      v56 = (9 * *v19 + *v13 + 3 * (*v13 + *v19) + 8) >> 4;
      v57 = (9 * v19[1] + v13[1] + 3 * (v13[1] + v19[1]) + 8) >> 4;
      v58 = v56 - 128;
      v57 -= 128;
      v59 = v55 + ((int)(22970 * v57 + 0x2000) >> 14);
      v60 = v55 + ((int)(-11700 * v57 - 5638 * v58 + 0x2000) >> 14);
      v61 = v55 + ((int)(29032 * v58 + 0x2000) >> 14);
      if (v59 >= 255)
        v62 = 255;
      else
        v62 = v59;
      v63 = v62 & ~(v62 >> 31);
      if (v60 >= 255)
        v60 = 255;
      v64 = v60 & ~(v60 >> 31);
      if (v61 >= 255)
        v61 = 255;
      v65 = v63 - (((v61 & ~(v61 >> 31)) + v64 + 1) >> 1);
      v20[1] = v65 & ~(v65 >> 31);
      v7 = *((_DWORD *)a2 + 4);
      v9 += v7 * v12;
      ++v8;
      v5 = *((_DWORD *)result + 3);
      v11 += *((int *)result + 4);
      v10 += *(int *)(a3 + 16);
    }
    while (v8 < v5);
  }
  return result;
}

unsigned __int8 **ConvertRedChannel5toY(unsigned __int8 **result, unsigned __int8 **a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  const char *v6;
  int v7;
  int v8;
  unsigned __int8 *v9;
  _BYTE *v10;
  unsigned __int8 *v11;
  int v12;
  unsigned __int8 *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  unsigned __int8 *v19;
  _BYTE *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  unsigned __int8 *v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  _BYTE *v53;

  v3 = *((_DWORD *)result + 2);
  v4 = *((_DWORD *)a2 + 2);
  if (v3 != 2 * v4)
  {
    v6 = "ConvertRedChannel5toY: widths do not match";
    return (unsigned __int8 **)puts(v6);
  }
  v5 = *((_DWORD *)result + 3);
  if (v5 != 2 * *((_DWORD *)a2 + 3))
  {
    v6 = "ConvertRedChannel5toY: heights do not match";
    return (unsigned __int8 **)puts(v6);
  }
  if (*((_DWORD *)result + 4) < *((_DWORD *)result + 7) * v3)
  {
    v6 = "ConvertRedChannel5toY: rowSamples is too small for Y bitmap";
    return (unsigned __int8 **)puts(v6);
  }
  v7 = *((_DWORD *)a2 + 4);
  if (v7 < *((_DWORD *)a2 + 7) * v4)
  {
    v6 = "ConvertRedChannel5toY: rowSamples is too small for CbCr bitmap";
    return (unsigned __int8 **)puts(v6);
  }
  if (*(_DWORD *)(a3 + 16) < *(_DWORD *)(a3 + 28) * *(_DWORD *)(a3 + 8))
  {
    v6 = "ConvertRedChannel5toY: rowSamples is too small for ARGB bitmap";
    return (unsigned __int8 **)puts(v6);
  }
  if (v5 >= 1)
  {
    v8 = 0;
    v9 = *a2;
    v10 = *(_BYTE **)a3;
    v11 = *result;
    do
    {
      v12 = v8 & 1;
      if ((v8 & 1) == 0)
        v7 = -v7;
      if (v8 == ((v8 << 31 >> 31) & (v5 - 1)))
        v7 = 0;
      v13 = &v9[v7];
      v14 = *v9;
      v15 = v9[1];
      v16 = *v13;
      v17 = v13[1];
      if (*((int *)result + 2) < 3)
      {
        v24 = *v9;
        v23 = v9[1];
        v22 = *v13;
        v21 = v13[1];
        v38 = v11;
        v20 = v10;
        v19 = v9;
      }
      else
      {
        v18 = 0;
        v19 = v9;
        v53 = v10;
        v20 = v10;
        v21 = v13[1];
        v22 = *v13;
        v23 = v9[1];
        v24 = *v9;
        do
        {
          v25 = v11[v18];
          v26 = ((9 * v15 + v21 + 3 * (v17 + v23) + 8) >> 4) - 128;
          v27 = v25 + ((int)(22970 * v26 + 0x2000) >> 14);
          v28 = v25
              + ((int)(-5638 * ((9 * v14 + v22 + 3 * (v16 + v24) + 8) >> 4) + 729856 - 11700 * v26) >> 14);
          if (v27 >= 255)
            v27 = 255;
          v29 = v27 & ~(v27 >> 31);
          if (v28 >= 255)
            v28 = 255;
          v30 = v29 - ((v28 & ~(v28 >> 31)) + ((v29 * (v28 & ~(v28 >> 31)) + 128) >> 8));
          *v20 = v30 & ~(v30 >> 31);
          v31 = v11[v18 + 1];
          v24 = *v19;
          v23 = v19[1];
          v14 = v19[2];
          v15 = v19[3];
          v22 = *v13;
          v21 = v13[1];
          v16 = v13[2];
          v17 = v13[3];
          v32 = ((9 * v23 + v17 + 3 * (v21 + v15) + 8) >> 4) - 128;
          v33 = v31 + ((int)(22970 * v32 + 0x2000) >> 14);
          v34 = v31
              + ((int)(-5638 * ((9 * v24 + v16 + 3 * (v22 + v14) + 8) >> 4) + 729856 - 11700 * v32) >> 14);
          if (v33 >= 255)
            v35 = 255;
          else
            v35 = v33;
          v36 = v35 & ~(v35 >> 31);
          if (v34 >= 255)
            v34 = 255;
          v20[1] = (v36
                  - ((v34 & ~(v34 >> 31))
                   + ((unsigned __int16)(v36 * (v34 & ~(unsigned __int16)(v34 >> 31)) + 128) >> 8))) & ~((int)(v36 - ((v34 & ~(v34 >> 31)) + ((v36 * (v34 & ~(v34 >> 31)) + 128) >> 8))) >> 31);
          v37 = *((int *)a2 + 7);
          v19 += v37;
          v13 += v37;
          v20 += 2 * *(int *)(a3 + 28);
          v18 += 2;
        }
        while ((int)v18 < *((_DWORD *)result + 2) - 2);
        v38 = &v11[v18];
        v10 = v53;
        v12 = v8 & 1;
      }
      v39 = *v38;
      v40 = ((9 * v15 + v21 + 3 * (v17 + v23) + 8) >> 4) - 128;
      v41 = v39 + ((int)(22970 * v40 + 0x2000) >> 14);
      v42 = v39
          + ((int)(-5638 * ((9 * v14 + v22 + 3 * (v16 + v24) + 8) >> 4) + 729856 - 11700 * v40) >> 14);
      if (v41 >= 255)
        v43 = 255;
      else
        v43 = v41;
      v44 = v43 & ~(v43 >> 31);
      if (v42 >= 255)
        v42 = 255;
      v45 = v44 - ((v42 & ~(v42 >> 31)) + ((v44 * (v42 & ~(v42 >> 31)) + 128) >> 8));
      *v20 = v45 & ~(v45 >> 31);
      v46 = v38[1];
      v47 = (9 * *v19 + *v13 + 3 * (*v13 + *v19) + 8) >> 4;
      v48 = ((9 * v19[1] + v13[1] + 3 * (v13[1] + v19[1]) + 8) >> 4) - 128;
      v49 = v46 + ((int)(22970 * v48 + 0x2000) >> 14);
      v50 = v46 + ((int)(-5638 * v47 + 729856 - 11700 * v48) >> 14);
      if (v49 >= 255)
        v51 = 255;
      else
        v51 = v49;
      v52 = v51 & ~(v51 >> 31);
      if (v50 >= 255)
        v50 = 255;
      v20[1] = (v52
              - ((v50 & ~(v50 >> 31))
               + ((unsigned __int16)(v52 * (v50 & ~(unsigned __int16)(v50 >> 31)) + 128) >> 8))) & ~((int)(v52 - ((v50 & ~(v50 >> 31)) + ((v52 * (v50 & ~(v50 >> 31)) + 128) >> 8))) >> 31);
      v7 = *((_DWORD *)a2 + 4);
      v9 += v7 * v12;
      ++v8;
      v5 = *((_DWORD *)result + 3);
      v11 += *((int *)result + 4);
      v10 += *(int *)(a3 + 16);
    }
    while (v8 < v5);
  }
  return result;
}

uint64_t CI::Perspective::EDLinesCPU::EDLinesCPU(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  void *v7;

  *(_QWORD *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  v7 = &CI::Perspective::EDLinesParamsDefault;
  *(_QWORD *)(a1 + 152) = 0;
  if (a6)
    v7 = a6;
  *(_QWORD *)a1 = &off_1E2EB8AB0;
  *(_QWORD *)(a1 + 8) = v7;
  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = a3;
  *(_QWORD *)(a1 + 32) = a4;
  *(_QWORD *)(a1 + 40) = a5;
  CI::Perspective::EDLinesCPU::createGradMap((CI::Perspective::EDLinesCPU *)a1);
  CI::Perspective::EDLinesCPU::sparseAnchors((CI::Perspective::EDLinesCPU *)a1);
  CI::Perspective::EDLinesCPU::edgeDrawing((CI::Perspective::EDLinesCPU *)a1);
  CI::Perspective::EDLinesCPU::extractLines((CI::Perspective::EDLinesCPU *)a1);
  CI::Perspective::EDLinesCPU::mergeLines((CI::Perspective::EDLinesCPU *)a1);
  return a1;
}

void sub_1923A3FF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  _QWORD *v2;
  void **v3;
  void **v4;
  void *v6;
  void *v7;
  void *v8;
  va_list va;

  va_start(va, a2);
  v6 = (void *)v2[17];
  if (v6)
  {
    v2[18] = v6;
    operator delete(v6);
  }
  std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100]((void ***)va);
  v7 = *v4;
  if (*v4)
  {
    v2[12] = v7;
    operator delete(v7);
  }
  v8 = *v3;
  if (*v3)
  {
    v2[8] = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

void CI::Perspective::EDLinesCPU::createGradMap(CI::Perspective::EDLinesCPU *this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  float v16;
  float v17;
  unsigned __int8 v18;
  CIImage *v19;
  NSString *v20;

  v2 = (uint64_t *)operator new();
  v3 = *((_QWORD *)this + 3);
  v4 = *((_QWORD *)this + 4);
  *v2 = v3;
  v2[1] = v4;
  v5 = (4 * v3 + 15) & 0xFFFFFFFFFFFFFFF0;
  v2[2] = v5;
  v6 = (char *)malloc_type_malloc(v5 * v4, 0x6457AB2BuLL);
  v2[3] = (uint64_t)v6;
  *((_QWORD *)this + 6) = v2;
  v7 = v2[1];
  if (v7)
  {
    v8 = 0;
    v9 = (uint64_t *)*((_QWORD *)this + 2);
    v10 = *((_QWORD *)this + 5);
    v11 = *v2;
    do
    {
      if (v11)
      {
        v12 = (float *)&v6[v2[2] * v8];
        v13 = v9;
        v14 = v11;
        do
        {
          v15 = *v13++;
          v16 = vaddv_f32((float32x2_t)(v15 & 0x7FFFFFFF7FFFFFFFLL));
          if (COERCE_FLOAT(v15 & 0x7FFFFFFF) >= COERCE_FLOAT(HIDWORD(v15) & 0x7FFFFFFF))
            v17 = -v16;
          else
            v17 = v16;
          *v12++ = v17;
          --v14;
        }
        while (v14);
      }
      ++v8;
      v9 = (uint64_t *)((char *)v9 + v10);
    }
    while (v8 != v7);
  }
  if (EDLines_Debug(void)::token != -1)
    dispatch_once(&EDLines_Debug(void)::token, &__block_literal_global_74);
  if (EDLines_Debug(void)::v)
  {
    if ((v18 & 1) == 0)
    {
      {
        CI::Perspective::EDLinesCPU::createGradMap(void)::linearGray = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D9F0]);
      }
    }
    v19 = CI::Perspective::Bitmap<float>::imageRepresentation(*((unint64_t **)this + 6), 2307, CI::Perspective::EDLinesCPU::createGradMap(void)::linearGray);
    CI::Perspective::CIImageToFile((CI::Perspective *)v19, (CIImage *)CFSTR("/tmp/ED_gradMap.png"), v20, *MEMORY[0x1E0C9D628]);
  }
}

void sub_1923A41C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CI::Perspective::EDLinesCPU::sparseAnchors(CI::Perspective::EDLinesCPU *this)
{
  float *v2;
  float v3;
  char **v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  unint64_t v19;
  int *v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  int *v27;
  char *v28;
  char *v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  int v42;
  unint64_t v43;
  int *v44;
  _DWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  int *v51;
  char *v52;
  char *v53;
  int v54;
  CI::Perspective *v55;
  NSString *v56;
  unint64_t v57;

  v2 = (float *)*((_QWORD *)this + 1);
  v3 = v2[1];
  v57 = *(unsigned __int16 *)v2;
  v4 = (char **)((char *)this + 56);
  std::vector<EDAnchor>::reserve((void **)this + 7, (*(_QWORD *)(*((_QWORD *)this + 6) + 8) / v57 * (**((_QWORD **)this + 6) / v57)) >> 1);
  v5 = (uint64_t *)*((_QWORD *)this + 6);
  if ((unint64_t)(v5[1] - 3) < 0xFFFFFFFFFFFFFFFELL)
  {
    v6 = *v5;
    v7 = 1;
    v8 = 1;
    while ((unint64_t)(v6 - 3) > 0xFFFFFFFFFFFFFFFDLL)
    {
LABEL_38:
      v8 += v57;
      v7 = v8;
      if (v5[1] - 1 <= (unint64_t)v8)
        goto LABEL_41;
    }
    v9 = 1;
    while (1)
    {
      v11 = v5[2];
      v10 = v5[3];
      v12 = v10 + v11 * v7;
      v13 = *(float *)(v12 + 4 * v9);
      v14 = -v13;
      if (v13 >= 0.0)
        v14 = *(float *)(v12 + 4 * v9);
      if (v14 >= 0.001)
      {
        if (v13 <= 0.0)
        {
          v17 = *(float *)(v12 + 4 * v9 - 4);
          if (v17 < 0.0)
            v17 = -v17;
          if ((float)(v14 - v17) >= v3)
          {
            v16 = *(float *)(v12 + 4 * (v9 + 1));
LABEL_17:
            if (v16 < 0.0)
              v16 = -v16;
            if ((float)(v14 - v16) >= v3)
            {
              v18 = (unsigned __int16)v9 | (v8 << 16);
              v20 = (int *)*((_QWORD *)this + 8);
              v19 = *((_QWORD *)this + 9);
              if ((unint64_t)v20 >= v19)
              {
                v22 = ((char *)v20 - *v4) >> 2;
                if ((unint64_t)(v22 + 1) >> 62)
LABEL_85:
                  abort();
                v23 = v19 - (_QWORD)*v4;
                v24 = v23 >> 1;
                if (v23 >> 1 <= (unint64_t)(v22 + 1))
                  v24 = v22 + 1;
                if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL)
                  v25 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v25 = v24;
                if (v25)
                  v26 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)this + 72, v25);
                else
                  v26 = 0;
                v27 = (int *)&v26[4 * v22];
                *v27 = v18;
                v21 = v27 + 1;
                v29 = (char *)*((_QWORD *)this + 7);
                v28 = (char *)*((_QWORD *)this + 8);
                if (v28 != v29)
                {
                  do
                  {
                    v30 = *((_DWORD *)v28 - 1);
                    v28 -= 4;
                    *--v27 = v30;
                  }
                  while (v28 != v29);
                  v28 = *v4;
                }
                *((_QWORD *)this + 7) = v27;
                *((_QWORD *)this + 8) = v21;
                *((_QWORD *)this + 9) = &v26[4 * v25];
                if (v28)
                  operator delete(v28);
              }
              else
              {
                *v20 = v18;
                v21 = v20 + 1;
              }
              *((_QWORD *)this + 8) = v21;
              v5 = (uint64_t *)*((_QWORD *)this + 6);
              v6 = *v5;
            }
          }
        }
        else
        {
          v15 = *(float *)(v10 + v11 * (v8 - 1) + 4 * v9);
          if (v15 < 0.0)
            v15 = -v15;
          if ((float)(v14 - v15) >= v3)
          {
            v16 = *(float *)(v10 + v11 * (v8 + 1) + 4 * v9);
            goto LABEL_17;
          }
        }
      }
      if (v6 - 1 <= (unint64_t)++v9)
        goto LABEL_38;
    }
  }
  v6 = *v5;
LABEL_41:
  if ((unint64_t)(v6 - 3) > 0xFFFFFFFFFFFFFFFDLL)
    goto LABEL_80;
  v31 = 1;
  v32 = 1;
  do
  {
    if ((unint64_t)(v5[1] - 3) > 0xFFFFFFFFFFFFFFFDLL)
      goto LABEL_79;
    v33 = 1;
    do
    {
      v35 = v5[2];
      v34 = v5[3];
      v36 = v34 + v35 * v33;
      v37 = *(float *)(v36 + 4 * v31);
      v38 = -v37;
      if (v37 >= 0.0)
        v38 = *(float *)(v36 + 4 * v31);
      if (v38 >= 0.001)
      {
        if (v37 <= 0.0)
        {
          v41 = *(float *)(v36 + 4 * (v32 - 1));
          if (v41 < 0.0)
            v41 = -v41;
          if ((float)(v38 - v41) < v3)
            goto LABEL_48;
          v40 = *(float *)(v36 + 4 * (v32 + 1));
        }
        else
        {
          v39 = *(float *)(v34 + v35 * (v33 - 1) + 4 * v31);
          if (v39 < 0.0)
            v39 = -v39;
          if ((float)(v38 - v39) < v3)
            goto LABEL_48;
          v40 = *(float *)(v34 + v35 * (v33 + 1) + 4 * v31);
        }
        if (v40 < 0.0)
          v40 = -v40;
        if ((float)(v38 - v40) >= v3)
        {
          v42 = (unsigned __int16)v32 | ((_DWORD)v33 << 16);
          v44 = (int *)*((_QWORD *)this + 8);
          v43 = *((_QWORD *)this + 9);
          if ((unint64_t)v44 >= v43)
          {
            v46 = ((char *)v44 - *v4) >> 2;
            if ((unint64_t)(v46 + 1) >> 62)
              goto LABEL_85;
            v47 = v43 - (_QWORD)*v4;
            v48 = v47 >> 1;
            if (v47 >> 1 <= (unint64_t)(v46 + 1))
              v48 = v46 + 1;
            if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL)
              v49 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v49 = v48;
            if (v49)
              v50 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)this + 72, v49);
            else
              v50 = 0;
            v51 = (int *)&v50[4 * v46];
            *v51 = v42;
            v45 = v51 + 1;
            v53 = (char *)*((_QWORD *)this + 7);
            v52 = (char *)*((_QWORD *)this + 8);
            if (v52 != v53)
            {
              do
              {
                v54 = *((_DWORD *)v52 - 1);
                v52 -= 4;
                *--v51 = v54;
              }
              while (v52 != v53);
              v52 = *v4;
            }
            *((_QWORD *)this + 7) = v51;
            *((_QWORD *)this + 8) = v45;
            *((_QWORD *)this + 9) = &v50[4 * v49];
            if (v52)
              operator delete(v52);
          }
          else
          {
            *v44 = v42;
            v45 = v44 + 1;
          }
          *((_QWORD *)this + 8) = v45;
          v5 = (uint64_t *)*((_QWORD *)this + 6);
        }
      }
LABEL_48:
      ++v33;
    }
    while (v5[1] - 1 > (unint64_t)v33);
    v6 = *v5;
LABEL_79:
    v32 += v57;
    v31 = v32;
  }
  while (v6 - 1 > (unint64_t)v32);
LABEL_80:
  if (EDLines_Debug(void)::token != -1)
    dispatch_once(&EDLines_Debug(void)::token, &__block_literal_global_74);
  if (EDLines_Debug(void)::v)
  {
    v55 = (CI::Perspective *)(*(uint64_t (**)(CI::Perspective::EDLinesCPU *))(*(_QWORD *)this + 24))(this);
    CI::Perspective::CIImageToFile(v55, (CIImage *)CFSTR("/tmp/ED_anchors.png"), v56, *MEMORY[0x1E0C9D628]);
  }
}

void CI::Perspective::EDLinesCPU::edgeDrawing(CI::Perspective::EDLinesCPU *this)
{
  _QWORD *v2;
  _QWORD *v3;
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  void *v8;
  int *v9;
  int *v10;
  char **v11;
  int v12;
  char *v13;
  char *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  int v22;
  unint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char *v29;
  char *v30;
  char *v31;
  char *v32;
  int v33;
  unint64_t v34;
  char **v35;
  int *v36;
  uint64_t v37;
  int v38;
  unint64_t v39;
  uint64_t v40;
  unsigned __int16 *v41;
  unsigned __int16 *v42;
  _BYTE *v43;
  char *v44;
  unint64_t v45;
  unint64_t v46;
  int v47;
  unint64_t *v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unsigned __int16 **v52;
  _QWORD *v53;
  unsigned __int16 *v54;
  unint64_t v55;
  unsigned int v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  char *v65;
  char *v66;
  CI::Perspective *v67;
  NSString *v68;
  char **v69;
  int v70;
  void *__p;
  char *v72;
  char *v73;
  void *v74;
  char *v75;
  char *v76;

  v2 = (_QWORD *)operator new();
  v3 = v2;
  v4 = (unint64_t *)*((_QWORD *)this + 6);
  v6 = *v4;
  v5 = v4[1];
  *v2 = v6;
  v2[1] = v5;
  if ((v6 & 7) != 0)
    v7 = (v6 >> 3) + 1;
  else
    v7 = v6 >> 3;
  v2[2] = v7;
  v8 = malloc_type_malloc(v7 * v5, 0xAD3CE366uLL);
  v3[3] = v8;
  *((_QWORD *)this + 10) = v3;
  bzero(v8, v3[2] * v3[1]);
  v69 = (char **)((char *)this + 88);
  std::vector<CI::Perspective::Line>::reserve((void **)this + 11, 0x100uLL);
  v74 = 0;
  v75 = 0;
  v76 = 0;
  std::vector<EDAnchor>::reserve(&v74, 0x200uLL);
  __p = 0;
  v72 = 0;
  v73 = 0;
  std::vector<EDAnchor>::reserve(&__p, 0x200uLL);
  v10 = (int *)*((_QWORD *)this + 7);
  v9 = (int *)*((_QWORD *)this + 8);
  if (v10 != v9)
  {
    v11 = &v76;
    do
    {
      if (((*(unsigned __int8 *)(*(_QWORD *)(*((_QWORD *)this + 10) + 24)
                                + *(_QWORD *)(*((_QWORD *)this + 10) + 16) * *((unsigned __int16 *)v10 + 1)
                                + ((unint64_t)(*(_WORD *)v10 & 0xFFF8) >> 3)) >> (~*(_WORD *)v10 & 7)) & 1) == 0)
      {
        v12 = *v10;
        v70 = *v10;
        if (CI::Perspective::EDLinesCPU::traceForeward((uint64_t)this, (unsigned __int16 *)&v70))
        {
          do
          {
            if (((*(unsigned __int8 *)(*(_QWORD *)(*((_QWORD *)this + 10) + 24)
                                      + *(_QWORD *)(*((_QWORD *)this + 10) + 16) * HIWORD(v70)
                                      + ((unint64_t)((unsigned __int16)v70 & 0xFFF8) >> 3)) >> (~(unsigned __int16)v70 & 7)) & 1) != 0)
              break;
            v13 = v75;
            if (v75 >= v76)
            {
              v15 = (v75 - (_BYTE *)v74) >> 2;
              if ((unint64_t)(v15 + 1) >> 62)
                abort();
              v16 = (v76 - (_BYTE *)v74) >> 1;
              if (v16 <= v15 + 1)
                v16 = v15 + 1;
              if ((unint64_t)(v76 - (_BYTE *)v74) >= 0x7FFFFFFFFFFFFFFCLL)
                v17 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v17 = v16;
              if (v17)
                v18 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)v11, v17);
              else
                v18 = 0;
              v19 = &v18[4 * v15];
              *(_DWORD *)v19 = v70;
              v14 = v19 + 4;
              v21 = (char *)v74;
              v20 = v75;
              if (v75 != v74)
              {
                do
                {
                  v22 = *((_DWORD *)v20 - 1);
                  v20 -= 4;
                  *((_DWORD *)v19 - 1) = v22;
                  v19 -= 4;
                }
                while (v20 != v21);
                v20 = (char *)v74;
              }
              v74 = v19;
              v75 = v14;
              v76 = &v18[4 * v17];
              if (v20)
                operator delete(v20);
            }
            else
            {
              *(_DWORD *)v75 = v70;
              v14 = v13 + 4;
            }
            v75 = v14;
            v23 = *(_QWORD *)(*((_QWORD *)this + 10) + 16) * HIWORD(v70)
                + ((unint64_t)(unsigned __int16)v70 >> 3);
            *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 10) + 24) + v23) |= 1 << (~(_BYTE)v70 & 7);
          }
          while ((CI::Perspective::EDLinesCPU::traceForeward((uint64_t)this, (unsigned __int16 *)&v70) & 1) != 0);
          v12 = *v10;
        }
        v70 = v12;
        if (CI::Perspective::EDLinesCPU::traceBackward((uint64_t)this, (unsigned __int16 *)&v70))
        {
          do
          {
            if (((*(unsigned __int8 *)(*(_QWORD *)(*((_QWORD *)this + 10) + 24)
                                      + *(_QWORD *)(*((_QWORD *)this + 10) + 16) * HIWORD(v70)
                                      + ((unint64_t)((unsigned __int16)v70 & 0xFFF8) >> 3)) >> (~(unsigned __int16)v70 & 7)) & 1) != 0)
              break;
            v24 = v72;
            if (v72 >= v73)
            {
              v26 = (v72 - (_BYTE *)__p) >> 2;
              if ((unint64_t)(v26 + 1) >> 62)
                abort();
              v27 = (v73 - (_BYTE *)__p) >> 1;
              if (v27 <= v26 + 1)
                v27 = v26 + 1;
              if ((unint64_t)(v73 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFFCLL)
                v28 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v28 = v27;
              if (v28)
                v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>((uint64_t)&v73, v28);
              else
                v29 = 0;
              v30 = &v29[4 * v26];
              *(_DWORD *)v30 = v70;
              v25 = v30 + 4;
              v32 = (char *)__p;
              v31 = v72;
              if (v72 != __p)
              {
                do
                {
                  v33 = *((_DWORD *)v31 - 1);
                  v31 -= 4;
                  *((_DWORD *)v30 - 1) = v33;
                  v30 -= 4;
                }
                while (v31 != v32);
                v31 = (char *)__p;
              }
              __p = v30;
              v72 = v25;
              v73 = &v29[4 * v28];
              if (v31)
                operator delete(v31);
            }
            else
            {
              *(_DWORD *)v72 = v70;
              v25 = v24 + 4;
            }
            v72 = v25;
            v34 = *(_QWORD *)(*((_QWORD *)this + 10) + 16) * HIWORD(v70)
                + ((unint64_t)(unsigned __int16)v70 >> 3);
            *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 10) + 24) + v34) |= 1 << (~(_BYTE)v70 & 7);
          }
          while ((CI::Perspective::EDLinesCPU::traceBackward((uint64_t)this, (unsigned __int16 *)&v70) & 1) != 0);
          LOWORD(v12) = *(_WORD *)v10;
        }
        v35 = v11;
        v36 = v9;
        v37 = ((unsigned __int16)v12 >> 3) + *(_QWORD *)(*((_QWORD *)this + 10) + 16) * *((unsigned __int16 *)v10 + 1);
        *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 10) + 24) + v37) |= 1 << (~(_BYTE)v12 & 7);
        v38 = *v10;
        v39 = (unsigned __int16)((((_DWORD)v75 - (_DWORD)v74) >> 2)
                               + (((_DWORD)v72 - (_DWORD)__p) >> 2)
                               + 1);
        v40 = 4 * v39;
        v41 = (unsigned __int16 *)malloc_type_malloc(4 * v39, 0x100004052888210uLL);
        v42 = v41;
        v43 = v72;
        if (v72 == __p)
        {
          v44 = v72;
        }
        else
        {
          memcpy(v41, __p, v72 - (_BYTE *)__p);
          v43 = __p;
          v44 = v72;
          v45 = ((v72 - (_BYTE *)__p) >> 2) - 1;
          if ((v72 - (_BYTE *)__p) >> 2 != 1)
          {
            v46 = 0;
            do
            {
              v47 = *(_DWORD *)&v42[2 * v46];
              *(_DWORD *)&v42[2 * v46] = *(_DWORD *)&v42[2 * v45];
              *(_DWORD *)&v42[2 * v45] = v47;
              ++v46;
              --v45;
            }
            while (v46 < v45);
            v43 = __p;
            v44 = v72;
          }
        }
        *(_DWORD *)((char *)v42 + v44 - v43) = v38;
        if (v75 != v74)
          memcpy((char *)v42 + v72 - (_BYTE *)__p + 4, v74, v75 - (_BYTE *)v74);
        v48 = (unint64_t *)*((_QWORD *)this + 6);
        v50 = *v48;
        v49 = v48[1];
        if (v50 > v49)
          v49 = v50;
        if (v39 <= (unint64_t)(float)(*(float *)(*((_QWORD *)this + 1) + 12) * (float)v49))
        {
          if (v39)
          {
            v54 = v42 + 1;
            do
            {
              v55 = *(v54 - 1);
              v56 = *v54;
              v54 += 2;
              v57 = *(_QWORD *)(*((_QWORD *)this + 10) + 16) * v56 + (v55 >> 3);
              *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 10) + 24) + v57) |= ~(1 << (~(_BYTE)v55 & 7));
              v40 -= 4;
            }
            while (v40);
          }
          free(v42);
          v9 = v36;
          v11 = v35;
        }
        else
        {
          v52 = (unsigned __int16 **)*((_QWORD *)this + 12);
          v51 = *((_QWORD *)this + 13);
          if ((unint64_t)v52 >= v51)
          {
            v58 = ((char *)v52 - *v69) >> 4;
            v59 = v58 + 1;
            if ((unint64_t)(v58 + 1) >> 60)
              abort();
            v60 = v51 - (_QWORD)*v69;
            if (v60 >> 3 > v59)
              v59 = v60 >> 3;
            if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF0)
              v61 = 0xFFFFFFFFFFFFFFFLL;
            else
              v61 = v59;
            if (v61)
              v62 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)this + 104, v61);
            else
              v62 = 0;
            v63 = &v62[16 * v58];
            *(_QWORD *)v63 = v42;
            *((_QWORD *)v63 + 1) = v39;
            v65 = (char *)*((_QWORD *)this + 11);
            v64 = (char *)*((_QWORD *)this + 12);
            v66 = v63;
            v9 = v36;
            if (v64 == v65)
            {
              v11 = v35;
            }
            else
            {
              do
              {
                *((_OWORD *)v66 - 1) = *((_OWORD *)v64 - 1);
                v66 -= 16;
                v64 -= 16;
              }
              while (v64 != v65);
              v64 = *v69;
              v11 = v35;
            }
            v53 = v63 + 16;
            *((_QWORD *)this + 11) = v66;
            *((_QWORD *)this + 12) = v63 + 16;
            *((_QWORD *)this + 13) = &v62[16 * v61];
            if (v64)
              operator delete(v64);
          }
          else
          {
            *v52 = v42;
            v52[1] = (unsigned __int16 *)v39;
            v53 = v52 + 2;
            v9 = v36;
            v11 = v35;
          }
          *((_QWORD *)this + 12) = v53;
        }
        v75 = (char *)v74;
        v72 = (char *)__p;
      }
      ++v10;
    }
    while (v10 != v9);
  }
  if (EDLines_Debug(void)::token != -1)
    dispatch_once(&EDLines_Debug(void)::token, &__block_literal_global_74);
  if (EDLines_Debug(void)::v)
  {
    v67 = (CI::Perspective *)(*(uint64_t (**)(CI::Perspective::EDLinesCPU *))(*(_QWORD *)this + 32))(this);
    CI::Perspective::CIImageToFile(v67, (CIImage *)CFSTR("/tmp/ED_edgeDrawing.png"), v68, *MEMORY[0x1E0C9D628]);
  }
  if (__p)
  {
    v72 = (char *)__p;
    operator delete(__p);
  }
  if (v74)
  {
    v75 = (char *)v74;
    operator delete(v74);
  }
}

void sub_1923A4D5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  if (a16)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

void CI::Perspective::EDLinesCPU::extractLines(CI::Perspective::EDLinesCPU *this)
{
  uint64_t v2;
  unint64_t v3;
  float v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  float v8;
  float v9;
  unint64_t v10;
  float v11;
  char *v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  _WORD *v23;
  float v24;
  float v25;
  float v26;
  float v27;
  unint64_t v28;
  unint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t *v45;
  uint64_t *v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  float v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  char *v56;
  char *v57;
  char *v58;
  char *v59;
  char *v60;
  void *v61;
  CGColor *v62;
  CI::Perspective *v63;
  NSString *v64;
  uint64_t i;
  uint64_t v66;
  _QWORD *v67;
  uint64_t v68;
  void *__p[2];
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  uint64_t v74;

  v2 = *((_QWORD *)this + 1);
  v3 = *(_QWORD *)(v2 + 16);
  v4 = *(float *)(v2 + 24);
  v67 = (_QWORD *)((char *)this + 112);
  std::vector<std::vector<CI::Perspective::LSR<EDAnchor>>>::reserve((_QWORD *)this + 14, (uint64_t)(*((_QWORD *)this + 12) - *((_QWORD *)this + 11)) >> 4);
  v5 = *((_QWORD *)this + 11);
  for (i = *((_QWORD *)this + 12); v5 != i; v5 += 16)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(_QWORD *)&v70 = 0;
    std::vector<std::vector<CI::Perspective::LSR<EDAnchor>>>::emplace_back<std::vector<CI::Perspective::LSR<EDAnchor>>>(v67, (uint64_t)__p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v3 < *(unsigned __int16 *)(v5 + 8))
    {
      v6 = 0;
      v7 = *((_QWORD *)this + 15);
      do
      {
        CI::Perspective::LSRInit<EDAnchor>(*(_QWORD *)v5 + 4 * v6, v3, (uint64_t)__p);
        v6 += v3;
        v10 = *(unsigned __int16 *)(v5 + 8);
        v11 = *((float *)&v74 + 1);
        if (v6 < v10 && *((float *)&v74 + 1) <= v4)
        {
          v13 = (char *)__p[1];
          v14 = *((float *)&v70 + 1);
          LODWORD(v15) = v70;
          v16 = *((float *)&v70 + 3);
          v17 = *((float *)&v70 + 2);
          v18 = *((float *)&v71 + 1);
          LODWORD(v19) = v71;
          v20 = *((float *)&v71 + 3);
          v21 = *((float *)&v71 + 2);
          v22 = *(float *)&v72;
          v23 = (char *)__p[0] + 4 * (uint64_t)__p[1] + 2;
          do
          {
            LOWORD(v8) = *(v23 - 1);
            v24 = (float)LODWORD(v8);
            LOWORD(v9) = *v23;
            v9 = (float)LODWORD(v9);
            v15 = v15 + v24;
            v14 = v14 + v9;
            v17 = v17 + (float)(v24 * v24);
            v16 = v16 + (float)(v9 * v9);
            v19 = v19 + (float)(v24 * v9);
            if (v18 >= v24)
              v18 = v24;
            if (v21 <= v24)
              v21 = v24;
            if (v20 >= v9)
              v20 = v9;
            if (v22 <= v9)
              v22 = v9;
            v25 = v11 * (float)(unint64_t)v13;
            v26 = v25
                + (float)((float)((float)((float)(*(float *)&v74 + (float)(*((float *)&v73 + 3) * v9))
                                        / *((float *)&v73 + 2))
                                + v24)
                        * (float)((float)((float)(*(float *)&v74 + (float)(*((float *)&v73 + 3) * v9))
                                        / *((float *)&v73 + 2))
                                + v24));
            v27 = v25
                + (float)((float)((float)((float)(*(float *)&v74 + (float)(*((float *)&v73 + 2) * v24))
                                        / *((float *)&v73 + 3))
                                + v9)
                        * (float)((float)((float)(*(float *)&v74 + (float)(*((float *)&v73 + 2) * v24))
                                        / *((float *)&v73 + 3))
                                + v9));
            if ((float)(v21 - v18) <= (float)(v22 - v20))
              v27 = v26;
            v8 = (float)(unint64_t)++v13;
            v11 = v27 / (float)(unint64_t)v13;
            if (++v6 >= v10)
              break;
            v23 += 2;
          }
          while (v11 <= v4);
          __p[1] = v13;
          *(_QWORD *)&v70 = __PAIR64__(LODWORD(v14), LODWORD(v15));
          *((_QWORD *)&v70 + 1) = __PAIR64__(LODWORD(v16), LODWORD(v17));
          *(_QWORD *)&v71 = __PAIR64__(LODWORD(v18), LODWORD(v19));
          *((_QWORD *)&v71 + 1) = __PAIR64__(LODWORD(v20), LODWORD(v21));
          *(float *)&v72 = v22;
        }
        *((float *)&v74 + 1) = v11;
        CI::Perspective::LSRUpdateFit<EDAnchor>((uint64_t)__p);
        v28 = *(_QWORD *)(v7 - 16);
        v29 = *(_QWORD *)(v7 - 8);
        if (v28 >= v29)
        {
          v31 = *(_QWORD *)(v7 - 24);
          v32 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v28 - v31) >> 3);
          v33 = v32 + 1;
          if ((unint64_t)(v32 + 1) > 0x2E8BA2E8BA2E8BALL)
            abort();
          v34 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v29 - v31) >> 3);
          if (2 * v34 > v33)
            v33 = 2 * v34;
          if (v34 >= 0x1745D1745D1745DLL)
            v35 = 0x2E8BA2E8BA2E8BALL;
          else
            v35 = v33;
          if (v35)
            v36 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::LSR<EDAnchor>>>(v7 - 8, v35);
          else
            v36 = 0;
          v37 = &v36[88 * v32];
          *(_OWORD *)v37 = *(_OWORD *)__p;
          *((_OWORD *)v37 + 1) = v70;
          *((_QWORD *)v37 + 10) = v74;
          *((_OWORD *)v37 + 4) = v73;
          *((_OWORD *)v37 + 3) = v72;
          *((_OWORD *)v37 + 2) = v71;
          v39 = *(char **)(v7 - 24);
          v38 = *(char **)(v7 - 16);
          v40 = v37;
          if (v38 != v39)
          {
            do
            {
              v41 = *(_OWORD *)(v38 - 88);
              *(_OWORD *)(v40 - 72) = *(_OWORD *)(v38 - 72);
              *(_OWORD *)(v40 - 88) = v41;
              v42 = *(_OWORD *)(v38 - 56);
              v43 = *(_OWORD *)(v38 - 40);
              v44 = *(_OWORD *)(v38 - 24);
              *((_QWORD *)v40 - 1) = *((_QWORD *)v38 - 1);
              *(_OWORD *)(v40 - 24) = v44;
              *(_OWORD *)(v40 - 40) = v43;
              *(_OWORD *)(v40 - 56) = v42;
              v40 -= 88;
              v38 -= 88;
            }
            while (v38 != v39);
            v38 = *(char **)(v7 - 24);
          }
          v30 = v37 + 88;
          *(_QWORD *)(v7 - 24) = v40;
          *(_QWORD *)(v7 - 16) = v37 + 88;
          *(_QWORD *)(v7 - 8) = &v36[88 * v35];
          if (v38)
            operator delete(v38);
        }
        else
        {
          *(_OWORD *)(v28 + 32) = v71;
          *(_OWORD *)(v28 + 48) = v72;
          *(_OWORD *)(v28 + 64) = v73;
          *(_QWORD *)(v28 + 80) = v74;
          *(_OWORD *)v28 = *(_OWORD *)__p;
          *(_OWORD *)(v28 + 16) = v70;
          v30 = (char *)(v28 + 88);
        }
        *(_QWORD *)(v7 - 16) = v30;
      }
      while (*(unsigned __int16 *)(v5 + 8) - v6 > v3);
    }
  }
  if (EDLines_Debug(void)::token != -1)
    dispatch_once(&EDLines_Debug(void)::token, &__block_literal_global_74);
  if (EDLines_Debug(void)::v)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(_QWORD *)&v70 = 0;
    v45 = (uint64_t *)*((_QWORD *)this + 14);
    v46 = (uint64_t *)*((_QWORD *)this + 15);
    if (v45 != v46)
    {
      v47 = 0;
      do
      {
        v48 = *v45;
        v49 = v45[1];
        while (v48 != v49)
        {
          v50 = (float)*(unint64_t *)(*((_QWORD *)this + 6) + 8);
          v51 = *(_QWORD *)(v48 + 56);
          v52 = *(_QWORD *)(v48 + 64);
          *((float *)&v51 + 1) = v50 - *((float *)&v51 + 1);
          *((float *)&v52 + 1) = v50 - *((float *)&v52 + 1);
          if ((unint64_t)v47 >= (unint64_t)v70)
          {
            v66 = v52;
            v68 = v51;
            v53 = (v47 - (char *)__p[0]) >> 4;
            if ((unint64_t)(v53 + 1) >> 60)
              abort();
            v54 = (uint64_t)(v70 - (unint64_t)__p[0]) >> 3;
            if (v54 <= v53 + 1)
              v54 = v53 + 1;
            if ((unint64_t)v70 - (unint64_t)__p[0] >= 0x7FFFFFFFFFFFFFF0)
              v55 = 0xFFFFFFFFFFFFFFFLL;
            else
              v55 = v54;
            if (v55)
              v56 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)&v70, v55);
            else
              v56 = 0;
            v57 = &v56[16 * v53];
            *(_QWORD *)v57 = v68;
            *((_QWORD *)v57 + 1) = v66;
            v59 = (char *)__p[0];
            v58 = (char *)__p[1];
            v60 = v57;
            if (__p[1] != __p[0])
            {
              do
              {
                *((_OWORD *)v60 - 1) = *((_OWORD *)v58 - 1);
                v60 -= 16;
                v58 -= 16;
              }
              while (v58 != v59);
              v58 = (char *)__p[0];
            }
            v47 = v57 + 16;
            __p[0] = v60;
            __p[1] = v57 + 16;
            *(_QWORD *)&v70 = &v56[16 * v55];
            if (v58)
              operator delete(v58);
          }
          else
          {
            *(_QWORD *)v47 = v51;
            *((_QWORD *)v47 + 1) = v52;
            v47 += 16;
          }
          __p[1] = v47;
          v48 += 88;
        }
        v45 += 3;
      }
      while (v45 != v46);
    }
    v61 = (void *)(*(uint64_t (**)(CI::Perspective::EDLinesCPU *))(*(_QWORD *)this + 32))(this);
    v62 = CGColorCreateSRGB(0.0, 1.0, 0.0, 1.0);
    v63 = (CI::Perspective *)CI::Perspective::plotLines<CI::Perspective::Line>(v61, v62, (uint64_t **)__p);
    CI::Perspective::CIImageToFile(v63, (CIImage *)CFSTR("/tmp/ED_linesExtracted.png"), v64, *MEMORY[0x1E0C9D628]);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
}

void sub_1923A530C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CI::Perspective::EDLinesCPU::mergeLines(CI::Perspective::EDLinesCPU *this)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  float32x2_t **v5;
  float *v6;
  float v7;
  float v8;
  float v9;
  float32x2_t *v10;
  float32x2_t *v11;
  unint64_t v12;
  float32x2_t *v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  unint64_t v17;
  _OWORD *v18;
  _OWORD *v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  float32x2_t *v25;
  unint64_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  int32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  int32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  float32x2_t v39;
  float v40;
  float v41;
  float32x2_t v42;
  float32x2_t v43;
  float32x2_t *v44;
  float32x2_t v45;
  unint64_t v46;
  float32x2_t *v47;
  float32x2_t *v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  float32x2_t *v55;
  char *v56;
  char *v57;
  float32x2_t *v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  char *v66;
  char *v67;
  char *v68;
  uint64_t *v69;
  uint64_t *v70;
  char *v71;
  float v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  char *v78;
  char *v79;
  char *v80;
  char *v81;
  char *v82;
  void *v83;
  CGColor *v84;
  CI::Perspective *v85;
  NSString *v86;
  uint64_t v87;
  float32x2_t **v88;
  uint64_t v89;
  void *__p;
  char *v91;
  _QWORD v92[10];

  v2 = (unint64_t *)*((_QWORD *)this + 6);
  v4 = *v2;
  v3 = v2[1];
  if (v4 > v3)
    v3 = v4;
  v5 = (float32x2_t **)*((_QWORD *)this + 14);
  v88 = (float32x2_t **)*((_QWORD *)this + 15);
  if (v5 != v88)
  {
    v6 = (float *)*((_QWORD *)this + 1);
    v7 = v6[7];
    v8 = v6[8];
    v9 = v6[9] * (float)v3;
    do
    {
      v11 = *v5;
      v10 = v5[1];
      v12 = 0x2E8BA2E8BA2E8BA3 * (v10 - *v5);
      if (v12 >= 2)
      {
        if (v10 != v11)
        {
          v20 = 0;
          do
          {
            v21 = v20 + 1;
            if (v20 + 1 >= v12)
              goto LABEL_21;
            v22 = (uint64_t *)&v11[11 * v20];
            v23 = *v22;
            v24 = v22[1];
            v25 = &v11[11 * v20 + 19];
            v26 = v24;
            while (1)
            {
              v27 = v25[-11];
              v28 = v25[-1];
              v29 = vsub_f32(v27, v28);
              if (sqrtf(vaddv_f32(vmul_f32(v29, v29))) > v8)
                break;
              v30 = vsub_f32(v27, v25[-12]);
              v31 = (int32x2_t)vmul_f32(v30, v30);
              v31.i32[0] = vadd_f32((float32x2_t)v31, (float32x2_t)vdup_lane_s32(v31, 1)).u32[0];
              v32 = vrsqrte_f32((float32x2_t)v31.u32[0]);
              v33 = vmul_f32(v32, vrsqrts_f32((float32x2_t)v31.u32[0], vmul_f32(v32, v32)));
              v34 = vmul_n_f32(v30, vmul_f32(v33, vrsqrts_f32((float32x2_t)v31.u32[0], vmul_f32(v33, v33))).f32[0]);
              v35 = vsub_f32(*v25, v28);
              v36 = (int32x2_t)vmul_f32(v35, v35);
              v36.i32[0] = vadd_f32((float32x2_t)v36, (float32x2_t)vdup_lane_s32(v36, 1)).u32[0];
              v37 = vrsqrte_f32((float32x2_t)v36.u32[0]);
              v38 = vmul_f32(v37, vrsqrts_f32((float32x2_t)v36.u32[0], vmul_f32(v37, v37)));
              v39 = vmul_n_f32(v35, vmul_f32(v38, vrsqrts_f32((float32x2_t)v36.u32[0], vmul_f32(v38, v38))).f32[0]);
              v39.f32[0] = (float)-v34.f32[1] * v39.f32[0];
              v40 = -(float)(v39.f32[0] + (float)(v34.f32[0] * v39.f32[1]));
              v41 = vmlas_n_f32(v39.f32[0], v39.f32[1], v34.f32[0]);
              if (v41 < 0.0)
                v41 = v40;
              if (v41 > v7)
                break;
              v26 += *(_QWORD *)&v25[-7];
              ++v21;
              v25 += 11;
              if (v12 == v21)
              {
                v21 = v12;
                break;
              }
            }
            if (v26 <= v24)
            {
LABEL_21:
              v44 = &v11[11 * v20];
              v42 = v44[7];
              v43 = v44[8];
            }
            else
            {
              CI::Perspective::LSRInit<EDAnchor>(v23, v26, (uint64_t)&__p);
              v42 = (float32x2_t)v92[5];
              v43 = (float32x2_t)v92[6];
            }
            v20 = v21;
            v45 = vsub_f32(v42, v43);
            if (sqrtf(vaddv_f32(vmul_f32(v45, v45))) > v9)
            {
              v47 = (float32x2_t *)*((_QWORD *)this + 18);
              v46 = *((_QWORD *)this + 19);
              if ((unint64_t)v47 >= v46)
              {
                v49 = *((_QWORD *)this + 17);
                v50 = ((uint64_t)v47 - v49) >> 4;
                v51 = v50 + 1;
                if ((unint64_t)(v50 + 1) >> 60)
                  goto LABEL_83;
                v52 = v46 - v49;
                if (v52 >> 3 > v51)
                  v51 = v52 >> 3;
                if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF0)
                  v53 = 0xFFFFFFFFFFFFFFFLL;
                else
                  v53 = v51;
                if (v53)
                  v54 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)this + 152, v53);
                else
                  v54 = 0;
                v55 = (float32x2_t *)&v54[16 * v50];
                *v55 = v42;
                v55[1] = v43;
                v57 = (char *)*((_QWORD *)this + 17);
                v56 = (char *)*((_QWORD *)this + 18);
                v58 = v55;
                if (v56 != v57)
                {
                  do
                  {
                    *(_OWORD *)v58[-2].f32 = *((_OWORD *)v56 - 1);
                    v58 -= 2;
                    v56 -= 16;
                  }
                  while (v56 != v57);
                  v56 = (char *)*((_QWORD *)this + 17);
                }
                v48 = v55 + 2;
                *((_QWORD *)this + 17) = v58;
                *((_QWORD *)this + 18) = v55 + 2;
                *((_QWORD *)this + 19) = &v54[16 * v53];
                if (v56)
                  operator delete(v56);
              }
              else
              {
                *v47 = v42;
                v47[1] = v43;
                v48 = v47 + 2;
              }
              *((_QWORD *)this + 18) = v48;
            }
            v11 = *v5;
            v12 = 0x2E8BA2E8BA2E8BA3 * (v5[1] - *v5);
          }
          while (v20 < v12);
        }
      }
      else
      {
        v14 = v11[7];
        v15 = v11[8];
        v13 = v11 + 7;
        v16 = vsub_f32(v14, v15);
        if (sqrtf(vaddv_f32(vmul_f32(v16, v16))) > v9)
        {
          v18 = (_OWORD *)*((_QWORD *)this + 18);
          v17 = *((_QWORD *)this + 19);
          if ((unint64_t)v18 >= v17)
          {
            v59 = *((_QWORD *)this + 17);
            v60 = ((uint64_t)v18 - v59) >> 4;
            v61 = v60 + 1;
            if ((unint64_t)(v60 + 1) >> 60)
LABEL_83:
              abort();
            v62 = v17 - v59;
            if (v62 >> 3 > v61)
              v61 = v62 >> 3;
            if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF0)
              v63 = 0xFFFFFFFFFFFFFFFLL;
            else
              v63 = v61;
            if (v63)
              v64 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)this + 152, v63);
            else
              v64 = 0;
            v65 = &v64[16 * v60];
            *(_OWORD *)v65 = *(_OWORD *)v13->f32;
            v67 = (char *)*((_QWORD *)this + 17);
            v66 = (char *)*((_QWORD *)this + 18);
            v68 = v65;
            if (v66 != v67)
            {
              do
              {
                *((_OWORD *)v68 - 1) = *((_OWORD *)v66 - 1);
                v68 -= 16;
                v66 -= 16;
              }
              while (v66 != v67);
              v66 = (char *)*((_QWORD *)this + 17);
            }
            v19 = v65 + 16;
            *((_QWORD *)this + 17) = v68;
            *((_QWORD *)this + 18) = v65 + 16;
            *((_QWORD *)this + 19) = &v64[16 * v63];
            if (v66)
              operator delete(v66);
          }
          else
          {
            *v18 = *(_OWORD *)v13->f32;
            v19 = v18 + 1;
          }
          *((_QWORD *)this + 18) = v19;
        }
      }
      v5 += 3;
    }
    while (v5 != v88);
  }
  if (EDLines_Debug(void)::token != -1)
    dispatch_once(&EDLines_Debug(void)::token, &__block_literal_global_74);
  if (EDLines_Debug(void)::v)
  {
    __p = 0;
    v91 = 0;
    v92[0] = 0;
    v69 = (uint64_t *)*((_QWORD *)this + 17);
    v70 = (uint64_t *)*((_QWORD *)this + 18);
    if (v69 != v70)
    {
      v71 = 0;
      do
      {
        v72 = (float)*(unint64_t *)(*((_QWORD *)this + 6) + 8);
        v73 = *v69;
        v74 = v69[1];
        *((float *)&v73 + 1) = v72 - COERCE_FLOAT(HIDWORD(*v69));
        *((float *)&v74 + 1) = v72 - *((float *)&v74 + 1);
        if ((unint64_t)v71 >= v92[0])
        {
          v87 = v74;
          v89 = v73;
          v75 = (v71 - (_BYTE *)__p) >> 4;
          if ((unint64_t)(v75 + 1) >> 60)
            abort();
          v76 = (uint64_t)(v92[0] - (_QWORD)__p) >> 3;
          if (v76 <= v75 + 1)
            v76 = v75 + 1;
          if (v92[0] - (_QWORD)__p >= 0x7FFFFFFFFFFFFFF0uLL)
            v77 = 0xFFFFFFFFFFFFFFFLL;
          else
            v77 = v76;
          if (v77)
            v78 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)v92, v77);
          else
            v78 = 0;
          v79 = &v78[16 * v75];
          *(_QWORD *)v79 = v89;
          *((_QWORD *)v79 + 1) = v87;
          v81 = (char *)__p;
          v80 = v91;
          v82 = v79;
          if (v91 != __p)
          {
            do
            {
              *((_OWORD *)v82 - 1) = *((_OWORD *)v80 - 1);
              v82 -= 16;
              v80 -= 16;
            }
            while (v80 != v81);
            v80 = (char *)__p;
          }
          v71 = v79 + 16;
          __p = v82;
          v91 = v79 + 16;
          v92[0] = &v78[16 * v77];
          if (v80)
            operator delete(v80);
        }
        else
        {
          *(_QWORD *)v71 = v73;
          *((_QWORD *)v71 + 1) = v74;
          v71 += 16;
        }
        v91 = v71;
        v69 += 2;
      }
      while (v69 != v70);
    }
    v83 = (void *)(*(uint64_t (**)(CI::Perspective::EDLinesCPU *))(*(_QWORD *)this + 32))(this);
    v84 = CGColorCreateSRGB(0.0, 1.0, 0.0, 1.0);
    v85 = (CI::Perspective *)CI::Perspective::plotLines<CI::Perspective::Line>(v83, v84, (uint64_t **)&__p);
    CI::Perspective::CIImageToFile(v85, (CIImage *)CFSTR("/tmp/ED_linesMerged.png"), v86, *MEMORY[0x1E0C9D628]);
    if (__p)
    {
      v91 = (char *)__p;
      operator delete(__p);
    }
  }
}

void sub_1923A58B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CI::Perspective::EDLinesCPU::~EDLinesCPU(CI::Perspective::EDLinesCPU *this)
{
  void **v2;
  void **v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  void **v10;

  *(_QWORD *)this = &off_1E2EB8AB0;
  v2 = (void **)*((_QWORD *)this + 11);
  v3 = (void **)*((_QWORD *)this + 12);
  while (v2 != v3)
  {
    v4 = *v2;
    v2 += 2;
    free(v4);
  }
  v5 = *((_QWORD *)this + 6);
  if (v5)
  {
    free(*(void **)(v5 + 24));
    MEMORY[0x194025AAC](v5, 0x1080C4019856BD9);
  }
  v6 = *((_QWORD *)this + 10);
  if (v6)
  {
    free(*(void **)(v6 + 24));
    MEMORY[0x194025AAC](v6, 0x1010C40313BCFEBLL);
  }
  v7 = (void *)*((_QWORD *)this + 17);
  if (v7)
  {
    *((_QWORD *)this + 18) = v7;
    operator delete(v7);
  }
  v10 = (void **)((char *)this + 112);
  std::vector<std::vector<IRect>>::__destroy_vector::operator()[abi:nn180100](&v10);
  v8 = (void *)*((_QWORD *)this + 11);
  if (v8)
  {
    *((_QWORD *)this + 12) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 7);
  if (v9)
  {
    *((_QWORD *)this + 8) = v9;
    operator delete(v9);
  }
}

{
  CI::Perspective::EDLinesCPU::~EDLinesCPU(this);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::Perspective::EDLinesCPU::getLines(CI::Perspective::EDLinesCPU *this)
{
  return (uint64_t)this + 136;
}

CIImage *CI::Perspective::EDLinesCPU::getAnchorsImage(CI::Perspective::EDLinesCPU *this)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  size_t v6;
  void *v7;
  unsigned __int16 *v8;
  unsigned __int16 *i;
  unint64_t v10;
  uint64_t v11;
  CIImage *v12;
  _QWORD v14[3];
  void *v15;

  v2 = (unint64_t *)*((_QWORD *)this + 6);
  v4 = *v2;
  v3 = v2[1];
  v14[0] = v4;
  v14[1] = v3;
  if ((v4 & 7) != 0)
    v5 = (v4 >> 3) + 1;
  else
    v5 = v4 >> 3;
  v14[2] = v5;
  v6 = v5 * v3;
  v7 = malloc_type_malloc(v5 * v3, 0xAD3CE366uLL);
  v15 = v7;
  bzero(v7, v6);
  v8 = (unsigned __int16 *)*((_QWORD *)this + 7);
  for (i = (unsigned __int16 *)*((_QWORD *)this + 8); v8 != i; v8 += 2)
  {
    v10 = *v8;
    v11 = v5 * v8[1] + (v10 >> 3);
    *((_BYTE *)v7 + v11) |= 1 << (~(_BYTE)v10 & 7);
  }
  v12 = CI::Perspective::Bitmask::imageRepresentation((CI::Perspective::Bitmask *)v14);
  free(v15);
  return v12;
}

void sub_1923A5AB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  free(a12);
  _Unwind_Resume(a1);
}

CIImage *CI::Perspective::Bitmask::imageRepresentation(CI::Perspective::Bitmask *this)
{
  unint64_t v2;
  void *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  char v9;
  unsigned __int8 v10;
  char **v11;
  char *v12;
  int v14;
  _QWORD v15[2];
  _QWORD v16[3];

  v16[2] = *MEMORY[0x1E0C80C00];
  v2 = (*(_QWORD *)this + 15) ^ 0xFFFFFFFFFFFFFFEFLL;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0C99DF0], "dataWithLength:", *((_QWORD *)this + 1) * v2);
  v4 = objc_msgSend(v3, "mutableBytes");
  v5 = *((_QWORD *)this + 1);
  if (v5)
  {
    v6 = 0;
    v7 = *(_QWORD *)this;
    do
    {
      if (v7)
      {
        v8 = 0;
        do
        {
          if (((*(unsigned __int8 *)(*((_QWORD *)this + 3) + *((_QWORD *)this + 2) * v6 + (v8 >> 3)) >> (~(_BYTE)v8 & 7)) & 1) != 0)
            v9 = -1;
          else
            v9 = 0;
          *(_BYTE *)(v4 + v8++) = v9;
          v7 = *(_QWORD *)this;
        }
        while (v8 < *(_QWORD *)this);
        v5 = *((_QWORD *)this + 1);
      }
      ++v6;
      v4 += v2;
    }
    while (v6 < v5);
  }
  v11 = off_1EE27F000;
  if ((v10 & 1) == 0)
  {
    v11 = off_1EE27F000;
    if (v14)
    {
      CI::Perspective::Bitmask::imageRepresentation(void)const::linearGray = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D9F0]);
      v11 = off_1EE27F000;
    }
  }
  v12 = v11[126];
  v15[0] = CFSTR("CIImageColorSpace");
  v15[1] = CFSTR("CIImageFlipped");
  v16[0] = v12;
  v16[1] = MEMORY[0x1E0C9AAB0];
  return +[CIImage imageWithBitmapData:bytesPerRow:size:format:options:](CIImage, "imageWithBitmapData:bytesPerRow:size:format:options:", v3, v2, 259, objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v16, v15, 2), (double)*(unint64_t *)this, (double)*((unint64_t *)this + 1));
}

void sub_1923A5C6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CIImage *CI::Perspective::EDLinesCPU::getEdgeDrawingImage(CI::Perspective::EDLinesCPU *this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  size_t v8;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  uint64_t i;
  uint64_t v13;
  uint32_t v14;
  unsigned int v15;
  int v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  unsigned __int8 v21;
  uint64_t v22;
  uint64_t v23;
  CIImage *v24;
  _QWORD v26[2];
  _QWORD v27[3];

  v27[2] = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 3);
  v3 = *((_QWORD *)this + 4);
  v4 = (4 * v2 + 15) & 0xFFFFFFFFFFFFFFF0;
  v5 = (char *)malloc_type_malloc(v4 * v3, 0x6457AB2BuLL);
  v6 = v5;
  if (v3)
  {
    if (v2 <= 1)
      v7 = 1;
    else
      v7 = v2;
    v8 = 4 * v7;
    v9 = v3;
    v10 = v5;
    v11 = v2;
    do
    {
      if (v11)
      {
        memset_pattern16(v10, &unk_192499130, v8);
        v11 = v2;
      }
      v10 += v4;
      --v9;
    }
    while (v9);
  }
  v13 = *((_QWORD *)this + 11);
  for (i = *((_QWORD *)this + 12); v13 != i; v13 += 16)
  {
    v14 = arc4random();
    if ((v14 & 0xF80000) <= 0x770000)
      v15 = -8978432;
    else
      v15 = v14 & 0xFF0000 | 0xFF000000;
    if ((v14 & 0xF800) <= 0x7700)
      v16 = 30464;
    else
      v16 = v14 & 0xFF00;
    if ((v14 & 0xF8) <= 0x77)
      v17 = 119;
    else
      v17 = v14;
    if (*(_WORD *)(v13 + 8))
    {
      v18 = 0;
      v19 = 0;
      v20 = v15 | v16 | v17;
      do
      {
        *(_DWORD *)&v6[4 * *(unsigned __int16 *)(*(_QWORD *)v13 + v18)
                     + v4 * *(unsigned __int16 *)(*(_QWORD *)v13 + v18 + 2)] = v20;
        ++v19;
        v18 += 4;
      }
      while (v19 < *(unsigned __int16 *)(v13 + 8));
    }
  }
  if ((v21 & 1) == 0
  {
    CI::Perspective::EDLinesCPU::getEdgeDrawingImage(void)const::sRGB = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  }
  v22 = CI::Perspective::EDLinesCPU::getEdgeDrawingImage(void)const::sRGB;
  v23 = objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v6, v4 * v3);
  v26[0] = CFSTR("CIImageColorSpace");
  v26[1] = CFSTR("CIImageFlipped");
  v27[0] = v22;
  v27[1] = MEMORY[0x1E0C9AAB0];
  v24 = +[CIImage imageWithBitmapData:bytesPerRow:size:format:options:](CIImage, "imageWithBitmapData:bytesPerRow:size:format:options:", v23, v4, 264, objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v27, v26, 2), (double)v2, (double)v3);
  free(v6);
  return v24;
}

void sub_1923A5EEC(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

CIImage *CI::Perspective::Bitmap<float>::imageRepresentation(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD v8[2];
  _QWORD v9[3];

  v9[2] = *MEMORY[0x1E0C80C00];
  v6 = objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", a1[3], a1[2] * a1[1]);
  v8[0] = CFSTR("CIImageColorSpace");
  v8[1] = CFSTR("CIImageFlipped");
  v9[0] = a3;
  v9[1] = MEMORY[0x1E0C9AAB0];
  return +[CIImage imageWithBitmapData:bytesPerRow:size:format:options:](CIImage, "imageWithBitmapData:bytesPerRow:size:format:options:", v6, a1[2], a2, objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v9, v8, 2), (double)*a1, (double)a1[1]);
}

void std::vector<EDAnchor>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  int v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 2)
  {
    if (a2 >> 62)
      abort();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::KernelArgumentType>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = &v6[4 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_DWORD *)v10 - 1);
        v10 -= 4;
        *((_DWORD *)v12 - 1) = v13;
        v12 -= 4;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t CI::Perspective::EDLinesCPU::traceForeward(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  float v10;
  float v11;
  unsigned __int16 v12;
  float v13;
  float v14;
  unsigned __int16 v15;
  float v16;
  unsigned __int16 v17;
  float v18;
  float v19;
  uint64_t v21;
  float v22;
  float v23;
  unsigned __int16 v24;
  float v25;

  v2 = *a2;
  if (!*a2)
    return 0;
  v3 = a2[1];
  v4 = *(_QWORD **)(a1 + 48);
  v5 = *v4 - 2 < (unint64_t)*a2 || (_DWORD)v3 == 0;
  if (v5 || v4[1] - 2 < (unint64_t)a2[1])
    return 0;
  v8 = v4 + 2;
  v7 = v4[2];
  v6 = v8[1];
  v9 = v6 + v7 * v3;
  v10 = *(float *)(v9 + 4 * v2);
  v11 = -v10;
  if (v10 >= 0.0)
    v11 = *(float *)(v9 + 4 * v2);
  if (v11 < *(float *)(*(_QWORD *)(a1 + 8) + 8))
    return 0;
  if (v10 <= 0.0)
  {
    v17 = v3 + 1;
    v21 = v6 + v7 * v17;
    v22 = *(float *)(v21 + 4 * v2);
    if (v22 >= 0.0)
      v23 = *(float *)(v21 + 4 * v2);
    else
      v23 = -v22;
    v24 = v2 - 1;
    v25 = *(float *)(v21 + 4 * (unsigned __int16)(v2 - 1));
    if (v25 < 0.0)
      v25 = -v25;
    v12 = v2 + 1;
    v18 = *(float *)(v21 + 4 * v12);
    if (v18 < 0.0)
      v18 = -v18;
    if (v25 <= v18)
      v19 = v18;
    else
      v19 = v25;
    if (v23 > v19)
      v19 = v23;
    if (v19 == v23)
      goto LABEL_45;
    if (v19 == v25)
    {
      *a2 = v24;
      goto LABEL_45;
    }
LABEL_43:
    if (v19 != v18)
      return 1;
    *a2 = v12;
LABEL_45:
    a2[1] = v17;
    return 1;
  }
  v12 = v2 + 1;
  v13 = *(float *)(v9 + 4 * v12);
  if (v13 >= 0.0)
    v14 = *(float *)(v9 + 4 * v12);
  else
    v14 = -v13;
  v15 = v3 - 1;
  v16 = *(float *)(v6 + v7 * (unsigned __int16)(v3 - 1) + 4 * v12);
  if (v16 < 0.0)
    v16 = -v16;
  v17 = v3 + 1;
  v18 = *(float *)(v6 + v7 * v17 + 4 * v12);
  if (v18 < 0.0)
    v18 = -v18;
  if (v16 <= v18)
    v19 = v18;
  else
    v19 = v16;
  if (v14 > v19)
    v19 = v14;
  if (v19 != v14)
  {
    if (v19 == v16)
    {
      *a2 = v12;
      a2[1] = v15;
      return 1;
    }
    goto LABEL_43;
  }
  *a2 = v12;
  return 1;
}

uint64_t CI::Perspective::EDLinesCPU::traceBackward(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  float v10;
  float v11;
  unsigned __int16 v12;
  float v13;
  float v14;
  unsigned __int16 v15;
  float v16;
  unsigned __int16 v17;
  float v18;
  float v19;
  uint64_t v21;
  float v22;
  float v23;
  unsigned __int16 v24;
  float v25;

  v2 = *a2;
  if (!*a2)
    return 0;
  v3 = a2[1];
  v4 = *(_QWORD **)(a1 + 48);
  v5 = *v4 - 2 < (unint64_t)*a2 || (_DWORD)v3 == 0;
  if (v5 || v4[1] - 2 < (unint64_t)a2[1])
    return 0;
  v8 = v4 + 2;
  v7 = v4[2];
  v6 = v8[1];
  v9 = v6 + v7 * v3;
  v10 = *(float *)(v9 + 4 * v2);
  v11 = -v10;
  if (v10 >= 0.0)
    v11 = *(float *)(v9 + 4 * v2);
  if (v11 < *(float *)(*(_QWORD *)(a1 + 8) + 8))
    return 0;
  if (v10 <= 0.0)
  {
    v17 = v3 - 1;
    v21 = v6 + v7 * v17;
    v22 = *(float *)(v21 + 4 * v2);
    if (v22 >= 0.0)
      v23 = *(float *)(v21 + 4 * v2);
    else
      v23 = -v22;
    v24 = v2 - 1;
    v25 = *(float *)(v21 + 4 * (unsigned __int16)(v2 - 1));
    if (v25 < 0.0)
      v25 = -v25;
    v12 = v2 + 1;
    v18 = *(float *)(v21 + 4 * v12);
    if (v18 < 0.0)
      v18 = -v18;
    if (v25 <= v18)
      v19 = v18;
    else
      v19 = v25;
    if (v23 > v19)
      v19 = v23;
    if (v19 == v23)
      goto LABEL_45;
    if (v19 == v25)
    {
      *a2 = v24;
      goto LABEL_45;
    }
LABEL_43:
    if (v19 != v18)
      return 1;
    *a2 = v12;
LABEL_45:
    a2[1] = v17;
    return 1;
  }
  v12 = v2 - 1;
  v13 = *(float *)(v9 + 4 * v12);
  if (v13 >= 0.0)
    v14 = *(float *)(v9 + 4 * v12);
  else
    v14 = -v13;
  v15 = v3 - 1;
  v16 = *(float *)(v6 + v7 * (unsigned __int16)(v3 - 1) + 4 * v12);
  if (v16 < 0.0)
    v16 = -v16;
  v17 = v3 + 1;
  v18 = *(float *)(v6 + v7 * v17 + 4 * v12);
  if (v18 < 0.0)
    v18 = -v18;
  if (v16 <= v18)
    v19 = v18;
  else
    v19 = v16;
  if (v14 > v19)
    v19 = v14;
  if (v19 != v14)
  {
    if (v19 == v16)
    {
      *a2 = v12;
      a2[1] = v15;
      return 1;
    }
    goto LABEL_43;
  }
  *a2 = v12;
  return 1;
}

uint64_t std::vector<std::vector<CI::Perspective::LSR<EDAnchor>>>::reserve(_QWORD *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL)
      abort();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 24 * v6;
    std::vector<std::vector<CI::Perspective::LSR<EDAnchor>>>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<std::vector<CI::Perspective::LSR<EDAnchor>>>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1923A642C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<CI::Perspective::LSR<EDAnchor>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<std::vector<CI::Perspective::LSR<EDAnchor>>>::emplace_back<std::vector<CI::Perspective::LSR<EDAnchor>>>(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  _QWORD v17[5];

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL)
      abort();
    v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0x555555555555555)
      v12 = 0xAAAAAAAAAAAAAAALL;
    else
      v12 = v10;
    v17[4] = v4;
    v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SWRendererFunctionInputNode>>(v4, v12);
    v14 = &v13[24 * v9];
    v17[0] = v13;
    v17[1] = v14;
    v17[3] = &v13[24 * v15];
    *((_QWORD *)v14 + 1) = 0;
    *((_QWORD *)v14 + 2) = 0;
    *(_QWORD *)v14 = 0;
    *(_OWORD *)v14 = *(_OWORD *)a2;
    *((_QWORD *)v14 + 2) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v17[2] = v14 + 24;
    std::vector<std::vector<CI::Perspective::LSR<EDAnchor>>>::__swap_out_circular_buffer(a1, v17);
    v8 = (_QWORD *)a1[1];
    std::__split_buffer<std::vector<CI::Perspective::LSR<EDAnchor>>>::~__split_buffer((uint64_t)v17);
  }
  else
  {
    *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)v7 = *(_OWORD *)a2;
    v7[2] = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v8 = v7 + 3;
    a1[1] = v7 + 3;
  }
  a1[1] = v8;
  return v8 - 3;
}

void sub_1923A6568(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<CI::Perspective::LSR<EDAnchor>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

float CI::Perspective::LSRInit<EDAnchor>@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  float v3;
  float v4;
  _WORD *v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float result;
  unint64_t v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  _WORD *v23;
  float v24;
  uint64_t v25;
  uint64_t v26;

  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)(a3 + 36) = xmmword_192499120;
  *(_QWORD *)a3 = a1;
  *(_QWORD *)(a3 + 8) = a2;
  if (a2)
  {
    v6 = (_WORD *)(a1 + 2);
    v7 = 0.0;
    v8 = -INFINITY;
    v9 = INFINITY;
    v10 = 0.0;
    v11 = 0.0;
    v12 = 0.0;
    v13 = 0.0;
    v14 = INFINITY;
    v15 = -INFINITY;
    do
    {
      LOWORD(v3) = *(v6 - 1);
      v3 = (float)LODWORD(v3);
      LOWORD(v4) = *v6;
      v4 = (float)LODWORD(v4);
      v13 = v13 + v3;
      v12 = v12 + v4;
      v11 = v11 + (float)(v3 * v3);
      v10 = v10 + (float)(v4 * v4);
      v7 = v7 + (float)(v3 * v4);
      if (v9 >= v3)
        v9 = v3;
      if (v8 <= v3)
        v8 = v3;
      if (v14 >= v4)
        v14 = v4;
      if (v15 <= v4)
        v15 = v4;
      v6 += 2;
      --a2;
    }
    while (a2);
    *(float *)(a3 + 16) = v13;
    *(float *)(a3 + 20) = v12;
    *(float *)(a3 + 24) = v11;
    *(float *)(a3 + 28) = v10;
    *(float *)(a3 + 32) = v7;
    *(float *)(a3 + 36) = v9;
    *(float *)(a3 + 40) = v8;
    *(float *)(a3 + 44) = v14;
    *(float *)(a3 + 48) = v15;
  }
  CI::Perspective::LSRUpdateFit<EDAnchor>(a3);
  v17 = *(_QWORD *)(a3 + 8);
  if (v17)
  {
    v18 = *(float *)(a3 + 72);
    v19 = *(float *)(a3 + 76);
    v20 = *(float *)(a3 + 80);
    v21 = *(float *)(a3 + 44);
    v22 = *(float *)(a3 + 48) - v21;
    v23 = (_WORD *)(*(_QWORD *)a3 + 2);
    if ((float)(*(float *)(a3 + 40) - *(float *)(a3 + 36)) <= v22)
    {
      v24 = 0.0;
      v26 = *(_QWORD *)(a3 + 8);
      do
      {
        LOWORD(v22) = *(v23 - 1);
        LOWORD(v21) = *v23;
        v21 = (float)(v20 + (float)(v19 * (float)LODWORD(v21))) / v18;
        v22 = v21 + (float)LODWORD(v22);
        v24 = v24 + (float)(v22 * v22);
        v23 += 2;
        --v26;
      }
      while (v26);
    }
    else
    {
      v24 = 0.0;
      v25 = *(_QWORD *)(a3 + 8);
      do
      {
        LOWORD(v22) = *(v23 - 1);
        LOWORD(v21) = *v23;
        v21 = (float)LODWORD(v21);
        v22 = (float)((float)(v20 + (float)(v18 * (float)LODWORD(v22))) / v19) + v21;
        v24 = v24 + (float)(v22 * v22);
        v23 += 2;
        --v25;
      }
      while (v25);
    }
    result = v24 / (float)v17;
    *(float *)(a3 + 84) = result;
  }
  return result;
}

uint64_t CI::Perspective::LSRUpdateFit<EDAnchor>(uint64_t result)
{
  unint64_t v1;
  float v2;
  float v3;
  float v4;
  float v5;
  _WORD *v6;
  uint64_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  uint64_t v22;

  v1 = *(_QWORD *)(result + 8);
  if (v1)
  {
    v2 = *(float *)(result + 16);
    v3 = *(float *)(result + 20);
    v4 = (float)v1;
    v5 = v2 / (float)v1;
    v6 = *(_WORD **)result;
    v7 = *(_QWORD *)result + 4 * v1;
    v8 = *(float *)(result + 32);
    v9 = *(float *)(result + 44);
    v10 = *(float *)(result + 48) - v9;
    v11 = v3 / v4;
    if ((float)(*(float *)(result + 40) - *(float *)(result + 36)) <= v10)
    {
      LOWORD(v10) = v6[1];
      v16 = (float)LODWORD(v10);
      LOWORD(v9) = *(_WORD *)(v7 - 2);
      v17 = (float)LODWORD(v9);
      v18 = *(float *)(result + 28) - (float)((float)(v3 * v3) / v4);
      if (v18 == 0.0)
        v19 = 0.0;
      else
        v19 = (float)(v8 - (float)((float)(v2 * v3) / v4)) / v18;
      v21 = v5 - (float)(v19 * v11);
      if (v19 != 0.0)
        v5 = v21;
      *(_DWORD *)(result + 72) = -1082130432;
      *(float *)(result + 76) = v19;
      *(float *)(result + 80) = v5;
      *(float *)&v22 = v5 + (float)(v19 * v16);
      *((float *)&v22 + 1) = v16;
      *(_QWORD *)(result + 56) = v22;
      *(float *)&v13 = v5 + (float)(v19 * v17);
      *((float *)&v13 + 1) = v17;
    }
    else
    {
      LOWORD(v10) = *v6;
      *(float *)&v12 = (float)LODWORD(v10);
      LOWORD(v10) = *(_WORD *)(v7 - 4);
      *(float *)&v13 = (float)LODWORD(v10);
      v14 = *(float *)(result + 24) - (float)((float)(v2 * v2) / v4);
      if (v14 == 0.0)
        v15 = 0.0;
      else
        v15 = (float)(v8 - (float)((float)(v2 * v3) / v4)) / v14;
      v20 = v11 - (float)(v15 * v5);
      if (v15 == 0.0)
        v20 = v3 / v4;
      *(float *)(result + 72) = v15;
      *(_DWORD *)(result + 76) = -1082130432;
      *(float *)(result + 80) = v20;
      *((float *)&v12 + 1) = v20 + (float)(v15 * *(float *)&v12);
      *(_QWORD *)(result + 56) = v12;
      *((float *)&v13 + 1) = v20 + (float)(v15 * *(float *)&v13);
    }
    *(_QWORD *)(result + 64) = v13;
  }
  return result;
}

uint64_t CI::Perspective::EDLines::Create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v10;

  v10 = operator new();
  CI::Perspective::EDLinesCPU::EDLinesCPU(v10, a1, a2, a3, a4, a5);
  return v10;
}

void sub_1923A6890(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10E1C40EBE27C8DLL);
  _Unwind_Resume(a1);
}

uint64_t ___ZL13EDLines_Debugv_block_invoke()
{
  char *v0;
  uint64_t result;

  v0 = getenv("EDLINES_DEBUG");
  if (v0)
    result = atoi(v0);
  else
    result = EDLines_Debug(void)::v;
  EDLines_Debug(void)::v = (_DWORD)result != 0;
  return result;
}

_QWORD *std::vector<std::vector<CI::Perspective::LSR<EDAnchor>>>::__swap_out_circular_buffer(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  __int128 v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = (_QWORD *)*result;
  v2 = (_QWORD *)result[1];
  v4 = a2[1];
  while (v2 != v3)
  {
    *(_QWORD *)(v4 - 24) = 0;
    *(_QWORD *)(v4 - 16) = 0;
    v4 -= 24;
    *(_QWORD *)(v4 + 16) = 0;
    v5 = *(_OWORD *)(v2 - 3);
    v2 -= 3;
    *(_OWORD *)v4 = v5;
    *(_QWORD *)(v4 + 16) = v2[2];
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  a2[1] = v4;
  v6 = (_QWORD *)*result;
  *result = v4;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::vector<CI::Perspective::LSR<EDAnchor>>>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<std::vector<CI::Perspective::LSR<EDAnchor>>>::__destruct_at_end[abi:nn180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<std::vector<CI::Perspective::LSR<EDAnchor>>>::__destruct_at_end[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    v5 = *(void **)(v2 - 24);
    *(_QWORD *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::LSR<EDAnchor>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2E8BA2E8BA2E8BBLL)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(88 * a2);
}

uint64_t FastRegistration_computeSignatures(uint64_t a1, int a2, NSObject *a3, uint64_t a4)
{
  int v8;
  int v9;
  uint64_t v10;
  _BOOL4 v11;
  int v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  char *StatusDescription;
  int v19;
  char *v20;
  char *v21;
  char *v22;
  _QWORD v23[7];
  _BOOL4 v24;
  char v25;
  _QWORD block[7];
  _BOOL4 v27;
  char v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  int v44;

  v8 = Projections_projectionRowsCols_planar8UtoF();
  v9 = v8;
  if (v8 < 0)
  {
    StatusDescription = Projections_getStatusDescription(v8);
    v19 = 45;
    goto LABEL_24;
  }
  v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a4 + 40) = v10;
  *(_QWORD *)(a4 + 8) = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)(a4 + 24) && *(_QWORD *)(a4 + 16) && *(_QWORD *)(a4 + 56))
  {
    v11 = *(_QWORD *)(a4 + 48) != 0;
    if (!a3)
      goto LABEL_6;
LABEL_14:
    v41 = 0;
    v42 = &v41;
    v43 = 0x2000000000;
    v44 = 0;
    v37 = 0;
    v38 = &v37;
    v39 = 0x2000000000;
    v40 = 0;
    v33 = 0;
    v34 = &v33;
    v35 = 0x2000000000;
    v36 = 0;
    v29 = 0;
    v30 = &v29;
    v31 = 0x2000000000;
    v32 = 0;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __FastRegistration_computeSignatures_block_invoke;
    block[3] = &unk_1E2EC0B80;
    v28 = a2;
    block[5] = &v33;
    block[6] = a4;
    v27 = v11;
    block[4] = &v41;
    v23[0] = MEMORY[0x1E0C809B0];
    v23[1] = 0x40000000;
    v23[2] = __FastRegistration_computeSignatures_block_invoke_2;
    v23[3] = &unk_1E2EC57D0;
    v25 = a2;
    v23[5] = &v29;
    v23[6] = a4;
    v24 = v11;
    v23[4] = &v37;
    dispatch_async(a3, block);
    dispatch_async(a3, v23);
    dispatch_barrier_sync(a3, &__block_literal_global_75);
    v16 = *((_DWORD *)v42 + 6);
    if (!v16)
    {
      v16 = *((_DWORD *)v38 + 6);
      if (!v16)
      {
        if (*((_DWORD *)v30 + 6) | *((_DWORD *)v34 + 6))
          v16 = -7;
        else
          v16 = 0;
      }
    }
    _Block_object_dispose(&v29, 8);
    _Block_object_dispose(&v33, 8);
    _Block_object_dispose(&v37, 8);
    _Block_object_dispose(&v41, 8);
    goto LABEL_20;
  }
  v11 = 0;
  if (a3)
    goto LABEL_14;
LABEL_6:
  if (!a2)
  {
LABEL_9:
    if (!v11)
    {
LABEL_12:
      v16 = 0;
      goto LABEL_20;
    }
    v14 = Projections_computeMeanStdTable(*(float **)(a4 + 32), *(_DWORD *)(a4 + 40), (_QWORD *)(a4 + 48));
    if ((v14 & 0x80000000) == 0)
    {
      v15 = Projections_computeMeanStdTable(*(float **)a4, *(_DWORD *)(a4 + 8), (_QWORD *)(a4 + 16));
      v9 = v15;
      if ((v15 & 0x80000000) == 0)
        goto LABEL_12;
      v22 = Projections_getStatusDescription(v15);
      syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v9, v22, "FastRegistration_status FastRegistration_computeSignatures(const vImage_Buffer *, _Bool, dispatch_queue_t, FastRegistration_Signatures *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", 110);
      return 4294967289;
    }
    v9 = v14;
    StatusDescription = Projections_getStatusDescription(v14);
    v19 = 109;
LABEL_24:
    syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v9, StatusDescription, "FastRegistration_status FastRegistration_computeSignatures(const vImage_Buffer *, _Bool, dispatch_queue_t, FastRegistration_Signatures *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", v19);
    return 4294967289;
  }
  v12 = FastRegistration_processProjections(*(_QWORD *)(a4 + 32), v10);
  if (v12 < 0)
  {
    v16 = v12;
    v20 = FastRegistration_getStatusDescription(v12);
    syslog(3, "FastRegistration error %d:%s in %s @ %s:%d\n", v16, v20, "FastRegistration_status FastRegistration_computeSignatures(const vImage_Buffer *, _Bool, dispatch_queue_t, FastRegistration_Signatures *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", 105);
  }
  else
  {
    v13 = FastRegistration_processProjections(*(_QWORD *)a4, *(_QWORD *)(a4 + 8));
    if ((v13 & 0x80000000) == 0)
      goto LABEL_9;
    v16 = v13;
    v21 = FastRegistration_getStatusDescription(v13);
    syslog(3, "FastRegistration error %d:%s in %s @ %s:%d\n", v16, v21, "FastRegistration_status FastRegistration_computeSignatures(const vImage_Buffer *, _Bool, dispatch_queue_t, FastRegistration_Signatures *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", 106);
  }
LABEL_20:
  if (v9)
    return 4294967289;
  else
    return v16;
}

uint64_t FastRegistration_processProjections(uint64_t a1, uint64_t a2, ...)
{
  uint64_t v2;
  unint64_t v3;
  int v4;
  float *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v11;
  char *StatusDescription;
  char *v13;
  va_list __B;

  va_start(__B, a2);
  v2 = MEMORY[0x1E0C80A78]();
  v4 = v3;
  v5 = (float *)v2;
  STACK[0x3348] = *MEMORY[0x1E0C80C00];
  if ((int)(float)((float)v3 * 0.03) <= 3)
    v6 = 3;
  else
    v6 = (int)(float)((float)v3 * 0.03);
  v7 = Projections_smoothProjection(v2, v3, v6, (uint64_t)__B);
  if (v7 < 0)
  {
    v11 = v7;
    StatusDescription = Projections_getStatusDescription(v7);
    syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v11, StatusDescription, "FastRegistration_status FastRegistration_processProjections(float *, vImagePixelCount)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", 25);
    return 4294967289;
  }
  v8 = Projections_computeProjectionDerivative((const float *)__B, v4, v5);
  v9 = v8;
  if (v8 < 0)
  {
    v13 = Projections_getStatusDescription(v8);
    syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v9, v13, "FastRegistration_status FastRegistration_processProjections(float *, vImagePixelCount)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", 26);
    return 4294967289;
  }
  if (v8)
    return 4294967289;
  else
    return 0;
}

uint64_t FastRegistration_register(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,uint64_t block,uint64_t a24,uint64_t (*a25)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9),void *a26,uint64_t *a27,_QWORD *a28,uint64_t a29,float *a30,float *a31,int a32,uint64_t a33,uint64_t *a34,uint64_t a35,int a36,uint64_t a37,uint64_t *a38,uint64_t a39,int a40,int a41,float a42)
{
  _QWORD *v42;
  NSObject *v43;
  float *v44;
  float *v45;
  float v46;
  float *v47;
  float *v48;
  float *v49;
  float *v50;
  float *v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  int v58;
  unint64_t v59;
  int v60;
  NSObject *v61;
  int v62;
  int v63;
  int v64;
  int v65;
  uint64_t v66;
  char *v68;
  char *StatusDescription;
  _QWORD var10[4];

  v42 = (_QWORD *)MEMORY[0x1E0C80A78]();
  v48 = v47;
  v50 = v49;
  v51 = v44;
  v53 = v52;
  v54 = v42;
  STACK[0xCD38] = *MEMORY[0x1E0C80C00];
  v55 = v42[5];
  v56 = *(_QWORD *)(v53 + 40);
  if (v55 >= v56)
    v57 = *(_QWORD *)(v53 + 40);
  else
    v57 = v42[5];
  v58 = (int)(float)((float)v57 * v46);
  v59 = v42[1];
  if (v59 >= *(_QWORD *)(v53 + 8))
    v59 = *(_QWORD *)(v53 + 8);
  v60 = (int)(float)((float)v59 * v46);
  a37 = 0;
  a38 = &a37;
  a39 = 0x2000000000;
  a40 = 0;
  a33 = 0;
  a34 = &a33;
  a35 = 0x2000000000;
  a36 = 0;
  if (v43)
  {
    v61 = v43;
    block = MEMORY[0x1E0C809B0];
    a24 = 0x40000000;
    a25 = __FastRegistration_register_block_invoke;
    a26 = &unk_1E2EC5818;
    a27 = &a37;
    a28 = v42;
    a32 = v58;
    a29 = v53;
    a30 = v44;
    a31 = v45;
    var10[0] = MEMORY[0x1E0C809B0];
    var10[1] = 0x40000000;
    var10[2] = __FastRegistration_register_block_invoke_2;
    var10[3] = &unk_1E2EC5840;
    dispatch_async(v43, &block);
    dispatch_async(v61, var10);
    dispatch_barrier_sync(v61, &__block_literal_global_9_0);
  }
  else
  {
    v62 = Projections_computeShiftBruteForce(v42[4], v55, v42 + 6, *(_QWORD *)(v53 + 32), v56, (_QWORD *)(v53 + 48), v58, (float *)&STACK[0x6720], 0.0, &a42, v44, v45);
    *((_DWORD *)a38 + 6) = v62;
    if (v62 < 0)
    {
      v65 = v62;
      StatusDescription = Projections_getStatusDescription(v62);
      syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v65, StatusDescription, "FastRegistration_status FastRegistration_register(const FastRegistration_Signatures *, const FastRegistration_Signatures *, float, dispatch_queue_t, float *, float *, float *, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", 185);
      goto LABEL_13;
    }
    v63 = Projections_computeShiftBruteForce(*v54, *((_DWORD *)v54 + 2), v54 + 2, *(_QWORD *)v53, *(_DWORD *)(v53 + 8), (_QWORD *)(v53 + 16), v60, (float *)&STACK[0x6720], 0.0, &a42, v50, v48);
    *((_DWORD *)a34 + 6) = v63;
    if (v63 < 0)
    {
      v64 = v63;
      v68 = Projections_getStatusDescription(v63);
      syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v64, v68, "FastRegistration_status FastRegistration_register(const FastRegistration_Signatures *, const FastRegistration_Signatures *, float, dispatch_queue_t, float *, float *, float *, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/FastRegistration_Core.c", 195);
      goto LABEL_13;
    }
  }
  *v51 = -*v51;
  *v50 = -*v50;
LABEL_13:
  if (*((_DWORD *)a38 + 6) || *((_DWORD *)a34 + 6))
    v66 = 4294967289;
  else
    v66 = 0;
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose(&a37, 8);
  return v66;
}

uint64_t FastRegistration_compareSignatures@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, float *a3@<X2>, vDSP_Length *a4@<X3>, float *a5@<X4>, vDSP_Length *a6@<X5>, uint64_t a7@<X8>, float a8@<S0>, float a9@<S1>)
{
  uint64_t v14;

  FastRegistration_compareSignature(a1[4], a1[5], a2[4], a2[5], a3, a4, a7, a8);
  FastRegistration_compareSignature(*a1, a1[1], *a2, a2[1], a5, a6, v14, a9);
  return 0;
}

void FastRegistration_compareSignature(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, int a4@<W3>, float *a5@<X4>, vDSP_Length *a6@<X5>, uint64_t a7@<X8>, float a8@<S0>)
{
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  BOOL v15;
  vDSP_Length v16;

  LODWORD(a7) = vcvtms_s32_f32(a8 + 0.5);
  v10 = -(int)a7;
  v11 = ~(_DWORD)a7 + a2;
  if (v11 >= a4)
    v11 = a4 - 1;
  v12 = v11 + a7;
  v13 = a7 + a4;
  if ((int)a7 + a4 >= a2)
    v13 = a2;
  v14 = v13 + ~(_DWORD)a7;
  v15 = (int)a7 >= 0;
  if ((int)a7 >= 0)
    v10 = 0;
  else
    a7 = 0;
  if (!v15)
    v14 = v12;
  v16 = v14 + 1;
  vDSP_vsub((const float *)(a1 + 4 * a7), 1, (const float *)(a3 + 4 * v10), 1, a5, 1, v16);
  vDSP_vabs(a5, 1, a5, 1, v16);
  *a6 = v16;
}

char *allocateSignatureBuffers(uint64_t a1, uint64_t a2, int a3)
{
  char *result;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;

  result = 0;
  if (a1 && a2)
  {
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    v7 = *(_QWORD *)(a2 + 8);
    v6 = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a1 + 40) = v6;
    *(_QWORD *)(a1 + 8) = v7;
    LODWORD(v6) = 4 * v6;
    v8 = (v6 + 31) & 0xFFFFFFE0;
    LODWORD(v7) = 4 * v7;
    v9 = (v7 + 31) & 0xFFFFFFE0;
    v10 = (v6 + 35) & 0xFFFFFFE0;
    v11 = (v7 + 35) & 0xFFFFFFE0;
    v12 = 2 * (v11 + v10);
    if (!a3)
      v12 = 0;
    result = (char *)malloc_type_calloc(1uLL, v9 + v8 + v12, 0xD30F4451uLL);
    if (result)
    {
      *(_QWORD *)(a1 + 32) = result;
      v13 = &result[v8];
      *(_QWORD *)a1 = v13;
      if (a3)
      {
        v14 = &v13[v9];
        v15 = &v14[v11];
        *(_QWORD *)(a1 + 16) = v14;
        *(_QWORD *)(a1 + 24) = v15;
        v16 = &v15[v11];
        *(_QWORD *)(a1 + 48) = v16;
        *(_QWORD *)(a1 + 56) = &v16[v10];
      }
    }
  }
  return result;
}

_QWORD *CI::SWContext::SWContext(_QWORD *a1, CGColorSpace *a2, CGColorSpace *a3, int a4, char a5, uint64_t a6, uint64_t a7)
{
  int v13;
  NSObject *v14;
  unsigned int v15;
  CI::TextureManager *v16;
  int v17;
  uint8_t buf[16];

  if (!a4)
  {
LABEL_5:
    v13 = 2056;
    goto LABEL_6;
  }
  v13 = a4;
  if ((int)CI::format_bits_per_component(a4) <= 8)
  {
    v14 = ci_logger_api();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1921E4000, v14, OS_LOG_TYPE_INFO, "Software context does not yet support 8bit working format", buf, 2u);
    }
    goto LABEL_5;
  }
LABEL_6:
  CI::Context::Context((uint64_t)a1, a2, a3, v13, a5, a6, a7, 0, 0, 0);
  a1[48] = off_1E2EBBFB0;
  do
    v15 = __ldaxr(&dword_1ECF873D0[17]);
  while (__stlxr(v15 + 1, &dword_1ECF873D0[17]));
  *a1 = &off_1E2EB7C80;
  a1[49] = 0;
  a1[50] = 0;
  a1[48] = &unk_1E2EB7F00;
  v16 = (CI::TextureManager *)operator new();
  v17 = (*(uint64_t (**)(_QWORD *))(*a1 + 272))(a1);
  CI::TextureManager::TextureManager(v16, v17);
  *(_QWORD *)v16 = &off_1E2EB7BA8;
  *((_QWORD *)v16 + 21) = a1;
  a1[51] = v16;
  a1[52] = 0;
  return a1;
}

CI::SWContext *CI::SWContext::SWContext(CI::SWContext *this, const CI::Context *a2)
{
  unsigned int v3;
  CI::TextureManager *v4;
  int v5;

  *((_QWORD *)CI::Context::Context(this, a2) + 48) = off_1E2EBBFB0;
  do
    v3 = __ldaxr(&dword_1ECF873D0[17]);
  while (__stlxr(v3 + 1, &dword_1ECF873D0[17]));
  *(_QWORD *)this = &off_1E2EB7C80;
  *((_QWORD *)this + 49) = 0;
  *((_QWORD *)this + 50) = 0;
  *((_QWORD *)this + 48) = &unk_1E2EB7F00;
  v4 = (CI::TextureManager *)operator new();
  v5 = (*(uint64_t (**)(CI::SWContext *))(*(_QWORD *)this + 272))(this);
  CI::TextureManager::TextureManager(v4, v5);
  *(_QWORD *)v4 = &off_1E2EB7BA8;
  *((_QWORD *)v4 + 21) = this;
  *((_QWORD *)this + 51) = v4;
  *((_QWORD *)this + 52) = 0;
  return this;
}

void CI::SWContext::~SWContext(CI::SWContext *this)
{
  CI::Object *v2;
  uint64_t v3;
  unsigned int v4;

  *(_QWORD *)this = &off_1E2EB7C80;
  *((_QWORD *)this + 48) = &unk_1E2EB7F00;
  v2 = (CI::Object *)*((_QWORD *)this + 49);
  if (v2)
    CI::Object::unref(v2);
  v3 = *((_QWORD *)this + 51);
  *((_QWORD *)this + 51) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 32))(v3);
  *((_QWORD *)this + 48) = off_1E2EBBFB0;
  do
    v4 = __ldaxr(&dword_1ECF873D0[17]);
  while (__stlxr(v4 - 1, &dword_1ECF873D0[17]));
  CI::Context::~Context((CGColorSpaceRef *)this);
}

{
  CI::SWContext::~SWContext(this);
  JUMPOUT(0x194025AACLL);
}

void `non-virtual thunk to'CI::SWContext::~SWContext(CI::SWContext *this)
{
  CI::SWContext::~SWContext((CI::SWContext *)((char *)this - 384));
}

{
  CI::SWContext::~SWContext((CI::SWContext *)((char *)this - 384));
  JUMPOUT(0x194025AACLL);
}

void *CI::SWContext::deviceName(CI::SWContext *this)
{
  if (CI::SWContext::deviceName(void)const::onceToken != -1)
    dispatch_once(&CI::SWContext::deviceName(void)const::onceToken, &__block_literal_global_76);
  return &CI::SWContext::deviceName(void)const::name;
}

uint64_t ___ZNK2CI9SWContext10deviceNameEv_block_invoke()
{
  size_t v1;

  v1 = 64;
  return sysctlbyname("machdep.cpu.brand_string", &CI::SWContext::deviceName(void)const::name, &v1, 0, 0);
}

uint64_t CI::SWContext::max_texture_size(CI::SWContext *this)
{
  _QWORD v2[3];

  iosurface_limits((uint64_t)v2);
  return v2[0];
}

uint64_t CI::SWContext::max_input_image_size(CI::SWContext *this)
{
  _QWORD v2[3];

  iosurface_limits((uint64_t)v2);
  return v2[0];
}

uint64_t CI::SWContext::max_output_image_size(CI::SWContext *this)
{
  _QWORD v2[3];

  iosurface_limits((uint64_t)v2);
  return v2[0];
}

uint64_t CI::SWContext::max_texture_image_units(CI::SWContext *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t CI::SWContext::max_fragment_uniform_vectors(CI::SWContext *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t CI::SWContext::max_fragment_uniform_size(CI::SWContext *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t CI::SWContext::max_render_load_bytes(CI::SWContext *this)
{
  return 0x20000000;
}

uint64_t CI::SWContext::max_device_memory(CI::SWContext *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t CI::SWContext::createMainProgram()
{
  return 0;
}

double CI::SWContext::sampler_transform_for_extent@<D0>(const CGRect *a1@<X1>, double *a2@<X8>)
{
  double y;
  double v4;
  CGFloat v5;
  double v6;
  double v7;
  double result;

  y = a1->origin.y;
  v4 = 1.0 / a1->size.height;
  v5 = a1->origin.x * -0.0 - y * v4 + 0.0;
  v6 = 1.0 / a1->size.width;
  v7 = y * -0.0 - a1->origin.x * v6;
  *a2 = v6 + 0.0;
  a2[1] = v4 * 0.0 + 0.0;
  a2[2] = v6 * 0.0 + 0.0;
  a2[3] = v4 + 0.0;
  result = v7 + 0.0;
  a2[4] = result;
  a2[5] = v5;
  return result;
}

uint64_t CI::SWContext::format_is_directly_supported_for_input(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  if (CI::format_is_ycc_biplanar(a2))
  {
    v4 = CI::format_of_plane(a2, 0);
    v5 = CI::format_of_plane(a2, 1);
    LODWORD(v4) = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 424))(a1, v4);
    return v4 & (*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 424))(a1, v5);
  }
  result = 1;
  if (a2 <= 1796)
  {
    if (((a2 - 257) > 0xA || ((1 << (a2 - 1)) & 0x7F1) == 0) && a2 != 785)
      return 0;
  }
  else if ((a2 - 1797) >= 4 && (a2 - 2053) >= 4 && (a2 - 2309) >= 4)
  {
    return 0;
  }
  return result;
}

uint64_t CI::SWContext::format_is_directly_supported_for_output(uint64_t a1, int a2)
{
  uint64_t result;

  result = 1;
  if (a2 > 2052)
  {
    if ((a2 - 2053) >= 4 && (a2 - 2309) >= 4)
      return 0;
  }
  else if (((a2 - 261) > 5 || a2 == 265) && (a2 - 1797) >= 4 && a2 != 785)
  {
    return 0;
  }
  return result;
}

uint64_t CI::SWContext::bind_cgimage()
{
  return 0;
}

uint64_t CI::SWContext::bind_surface()
{
  return 0;
}

uint64_t CI::SWContext::bind_texture()
{
  return 0;
}

{
  return 0;
}

uint64_t CI::SWContext::bind_intermediate()
{
  return 0;
}

uint64_t CI::SWContext::set_bitmap_destination(uint64_t result, CI::Object *this)
{
  if (this)
  {
    *(_QWORD *)(result + 392) = this;
    return CI::Object::ref((uint64_t)this);
  }
  return result;
}

CI::Bitmap *CI::SWContext::set_surface_destination(CI::Bitmap *result, IOSurfaceRef buffer)
{
  CI::Bitmap *v3;
  CI::Bitmap *v4;

  if (buffer)
  {
    v3 = result;
    *((_QWORD *)result + 50) = buffer;
    IOSurfaceLock(buffer, 0, 0);
    v4 = (CI::Bitmap *)operator new();
    result = CI::Bitmap::Bitmap(v4, buffer, 0);
    *(_QWORD *)result = &off_1E2EB7688;
    *((_QWORD *)result + 2) = &unk_1E2EB76C0;
    *((_WORD *)result + 69) = 0;
    *((_QWORD *)v3 + 49) = result;
  }
  return result;
}

uint64_t CI::SWContext::set_texture_destination(CI::SWContext *this, Texture a2, const CGSize *a3)
{
  return 0;
}

uint64_t CI::SWContext::set_user_destination(CI::SWContext *this)
{
  return 0;
}

uint64_t CI::SWContext::unset_destination(CI::SWContext *this)
{
  CI::Object *v2;
  uint64_t result;

  v2 = (CI::Object *)*((_QWORD *)this + 49);
  if (v2)
    CI::Object::unref(v2);
  *((_QWORD *)this + 49) = 0;
  result = IOSurfaceUnlock(*((IOSurfaceRef *)this + 50), 0, 0);
  *((_QWORD *)this + 50) = 0;
  return result;
}

void CI::SWContext::render_node(CI::SWContext *this, dispatch_queue_t *a2, const CGRect *a3, const CGRect *a4, const CI::Bitmap *a5)
{
  uint64_t *v6;
  uint64_t *v7;
  CI::ProgramNode *v10;
  dispatch_queue_t v12;
  CI::MainProgram *v13;
  CGFloat MidY;
  CGFloat v15;
  double x;
  double y;
  double height;
  double v19;
  double v20;
  int v21;
  uint64_t v22;
  int v23;
  void *v24;
  int v25;
  double v26;
  double v27;
  unint64_t v28;
  int **v29;
  int v30;
  int v31;
  int **v32;
  int *v33;
  char can_sample_nearest;
  CI::ProgramNode *v35;
  unsigned __int8 *v36;
  int v37;
  uint64_t v38;
  CGFloat v39;
  CGFloat v40;
  CGFloat v41;
  __IOSurface *v42;
  CI::SWContext *v43;
  int v44;
  CI::Bitmap *v45;
  char v46;
  CI::Bitmap *v47;
  CI::TextureManager *v48;
  CGFloat v49;
  CGFloat v50;
  CGFloat v51;
  uint64_t v52;
  uint64_t v53;
  CGFloat v54;
  CGFloat v55;
  CGFloat v56;
  double v57;
  double v58;
  double v59;
  double v60;
  CI::Object *v61;
  CGFloat v62;
  CGFloat v63;
  CGFloat v64;
  CGFloat v65;
  CGSize size;
  double v67;
  double v68;
  double v69;
  double v70;
  CI::Vector *v71;
  CGAffineTransform *v72;
  _BOOL4 v73;
  int v74;
  double v75;
  CGFloat v76;
  CGFloat v77;
  CGFloat v78;
  char v79;
  CGFloat v80;
  CGFloat v81;
  CGFloat v82;
  CGFloat v83;
  CGFloat v84;
  CGFloat v85;
  CGFloat v86;
  int v87;
  CI::Bitmap *v88;
  char v89;
  CI::Bitmap *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t (***intermediate_for_node)(_QWORD);
  uint64_t v94;
  __IOSurface *v95;
  NSObject *v96;
  uint64_t v97;
  int v98;
  _QWORD *v99;
  _QWORD *v100;
  char *v101;
  unint64_t v102;
  unsigned int v103;
  unint64_t i;
  double v105;
  unint64_t v106;
  dispatch_queue_attr_t v107;
  dispatch_queue_t *v108;
  dispatch_queue_t *v109;
  CI::Node *v110;
  CI::Node *v111;
  int64_t v112;
  unint64_t v113;
  unint64_t v114;
  char *v115;
  CI::Node *v116;
  CI::Node *v117;
  CI::Node *v118;
  uint64_t v119;
  dispatch_queue_t **v120;
  CI::Node *v121;
  dispatch_queue_t *v122;
  int v123;
  CGFloat v124;
  NSObject *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  NSObject *v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  NSObject *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  NSObject *v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  NSObject *v157;
  NSObject *v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  NSObject *v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  NSObject *v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  NSObject *v182;
  _BOOL4 v183;
  double width;
  double v185;
  uint64_t v186;
  CI::MainProgram *v187;
  int v188[2];
  int v189;
  CI::Object *v190;
  CI::Node *v191[2];
  CI::Node *v192;
  CGRect __p[2];
  CGRect v194;
  __int128 v195;
  _QWORD v196[2];
  CGSize v197;
  double v198;
  double v199;
  CGAffineTransform v200;
  CFTypeRef cf;
  _QWORD v202[2];
  uint64_t v203;
  int v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  uint64_t v210;
  CGAffineTransform v211;
  CGRect buf;
  __int128 v213;
  void *v214;
  char v215;
  _QWORD v216[22];
  CGRect v217;
  CGRect v218;
  CGRect v219;
  CGRect v220;
  CGRect v221;
  CGRect v222;
  CGRect v223;
  CGRect v224;
  CGRect v225;

  v216[19] = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    v141 = ci_logger_render();
    if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
      CI::SWContext::render_node(v141, v142, v143, v144, v145, v146, v147, v148);
LABEL_114:
    abort();
  }
  if (!a5)
  {
    v149 = ci_logger_render();
    if (os_log_type_enabled(v149, OS_LOG_TYPE_ERROR))
    {
      CI::SWContext::render_node(v149, v150, v151, v152, v153, v154, v155, v156);
      abort();
    }
    goto LABEL_114;
  }
  v6 = (uint64_t *)((char *)a5 + 80);
  v7 = (uint64_t *)((char *)a5 + 88);
  if (!(*((_QWORD *)a5 + 11) * *((_QWORD *)a5 + 10)))
  {
    v157 = ci_logger_render();
    if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR))
    {
      CI::SWContext::render_node(v6, v7, v157);
      abort();
    }
    goto LABEL_114;
  }
  v10 = (CI::ProgramNode *)a2;
  v12 = CI::ProgramNode::mainProgram(a2);
  if (v12)
  {
    v13 = (CI::MainProgram *)v12;
    v217 = CGRectIntersection(*a3, *a4);
    v190 = a5;
    if (*((_BYTE *)v10 + 148))
    {
      MidY = CGRectGetMidY(*a4);
      v15 = MidY + MidY;
      v218 = *a3;
      v211.b = 0.0;
      v211.c = 0.0;
      v211.a = 1.0;
      *(_OWORD *)&v211.d = xmmword_192493540;
      v211.ty = v15;
      v219 = CGRectApplyAffineTransform(v218, &v211);
      v220 = CGRectIntersection(v219, *a4);
      x = v220.origin.x;
      y = v220.origin.y;
      width = v220.size.width;
      height = -v220.size.height;
    }
    else
    {
      x = v217.origin.x;
      y = v217.origin.y;
      height = v217.size.height;
      width = v217.size.width;
    }
    v19 = a4->origin.x;
    v20 = a4->origin.y;
    v21 = CI::MainProgram::num_arguments(v13);
    dispatch_sync(*((dispatch_queue_t *)v10 + 13), &__block_literal_global_25_0);
    v22 = *((_QWORD *)v10 + 16);
    v23 = *(_DWORD *)v22;
    v204 = 0;
    v203 = 0;
    v205 = 0u;
    v206 = 0u;
    v207 = 0u;
    v208 = 0u;
    v209 = 0u;
    v210 = 0;
    if (v23 > 10)
    {
      HIDWORD(v203) = v23;
      v24 = malloc_type_calloc((v23 - 10), 8uLL, 0x80040B8603338uLL);
    }
    else
    {
      v24 = 0;
      HIDWORD(v203) = 10;
    }
    *(_QWORD *)&v205 = v24;
    if (v23 <= 1)
      v25 = 1;
    else
      v25 = v23;
    v204 = v25;
    if (*(_DWORD *)v22 == v21)
    {
      v26 = x - v19;
      v27 = y - v20;
      if (v21 >= 1)
      {
        v28 = 0;
        *(_QWORD *)v188 = v21;
        v29 = (int **)(v22 + 24);
        v185 = v26;
        v186 = v22;
        v187 = v13;
        while (1)
        {
          v30 = (*(uint64_t (**)(CI::MainProgram *, unint64_t))(*(_QWORD *)v13 + 40))(v13, v28);
          v31 = v30;
          v32 = v29;
          if (v28 >= 0xA)
            v32 = (int **)(*(_QWORD *)(v22 + 16) + 8 * (v28 - 10));
          v33 = *v32;
          if (v30 <= 39)
          {
            if ((v30 - 1) < 4)
            {
              if ((*(unsigned int (**)(int *))(*(_QWORD *)v33 + 16))(v33) != 60)
                goto LABEL_106;
              can_sample_nearest = CI::ProgramNode::child_can_sample_nearest(v10, v33[8]);
              v35 = v10;
              CI::ProgramNode::roiKeys_of_child(v10, *a3, v33[8], __p);
              if (*(_QWORD *)&__p[0].origin.y == *(_QWORD *)&__p[0].origin.x)
              {
                v125 = ci_logger_render();
                if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR))
                {
                  CI::SWContext::render_node(v125, v126, v127, v128, v129, v130, v131, v132);
                  abort();
                }
                goto LABEL_114;
              }
              *(_OWORD *)v191 = **(_OWORD **)&__p[0].origin.x;
              v36 = (unsigned __int8 *)*((_QWORD *)v33 + 3);
              if (!v36)
              {
                v133 = ci_logger_render();
                if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
                {
                  CI::SWContext::render_node(v133, v134, v135, v136, v137, v138, v139, v140);
                  abort();
                }
                goto LABEL_114;
              }
              v202[0] = 0;
              v202[1] = 0;
              v37 = (*(uint64_t (**)(unsigned __int8 *))(*(_QWORD *)v36 + 16))(v36);
              v38 = 0;
              if (v37 > 45)
              {
                if (v37 != 52)
                {
                  if (v37 != 46)
                    goto LABEL_63;
                  v222.origin.x = CI::Node::roi(v191[0], (int)v191[1]);
                  if (CGRectIsEmpty(v222))
                  {
                    v166 = ci_logger_render();
                    if (os_log_type_enabled(v166, OS_LOG_TYPE_ERROR))
                    {
                      CI::SWContext::render_node(v166, v167, v168, v169, v170, v171, v172, v173);
                      abort();
                    }
                    goto LABEL_114;
                  }
                  v73 = v31 == 3;
                  v74 = v36[104];
                  v38 = operator new();
                  v75 = CI::Node::roi(v191[0], (int)v191[1]);
                  CI::SurfaceNode::surfaceForROI((uint64_t)v36, (uint64_t)this, (uint64_t)v202, (__IOSurface **)&buf, v75, v76, v77, v78);
                  v79 = v74 ? 1 : can_sample_nearest;
                  CI::Bitmap::Bitmap((CI::Bitmap *)v38, *(__IOSurface **)&buf.origin.x, v73);
                  *(_QWORD *)v38 = &off_1E2EB7688;
                  *(_QWORD *)(v38 + 16) = &unk_1E2EB76C0;
                  *(_BYTE *)(v38 + 138) = v79;
                  *(_BYTE *)(v38 + 139) = 1;
                  v80 = buf.origin.x;
                  buf.origin.x = 0.0;
                  if (v80 == 0.0)
                    goto LABEL_63;
                  goto LABEL_57;
                }
                v224.origin.x = CI::Node::roi(v191[0], (int)v191[1]);
                if (CGRectIsEmpty(v224))
                {
                  v38 = operator new();
                  CI::Bitmap::Bitmap((CI::Bitmap *)v38);
                  *(_QWORD *)v91 = &off_1E2EB7688;
                  *(_QWORD *)(v91 + 16) = &unk_1E2EB76C0;
                  *(_WORD *)(v91 + 138) = 1;
                }
                else
                {
                  v92 = (*(uint64_t (**)(CI::SWContext *))(*(_QWORD *)this + 112))(this);
                  intermediate_for_node = (uint64_t (***)(_QWORD))CI::TextureManager::get_intermediate_for_node(v92, (uint64_t)v191);
                  if ((v36[144] & 4) != 0)
                  {
                    v94 = (*(uint64_t (**)(CI::SWContext *))(*(_QWORD *)this + 112))(this);
                    (*(void (**)(uint64_t, uint64_t (***)(_QWORD)))(*(_QWORD *)v94 + 56))(v94, intermediate_for_node);
                  }
                  v38 = operator new();
                  v95 = (__IOSurface *)(**intermediate_for_node)(intermediate_for_node);
                  CI::Bitmap::Bitmap((CI::Bitmap *)v38, v95, 0);
                  *(_QWORD *)v38 = &off_1E2EB7688;
                  *(_QWORD *)(v38 + 16) = &unk_1E2EB76C0;
                  *(_BYTE *)(v38 + 138) = can_sample_nearest;
                  *(_BYTE *)(v38 + 139) = 1;
                }
              }
              else
              {
                if (v37 != 29)
                {
                  if (v37 == 44)
                  {
                    v221.origin.x = CI::Node::roi(v191[0], (int)v191[1]);
                    if (CGRectIsEmpty(v221))
                    {
                      v158 = ci_logger_render();
                      if (os_log_type_enabled(v158, OS_LOG_TYPE_ERROR))
                      {
                        CI::SWContext::render_node(v158, v159, v160, v161, v162, v163, v164, v165);
                        abort();
                      }
                      goto LABEL_114;
                    }
                    v183 = v31 == 3;
                    buf.origin.x = CI::Node::roi(v191[0], (int)v191[1]);
                    buf.origin.y = v39;
                    buf.size.width = v40;
                    buf.size.height = v41;
                    v42 = (__IOSurface *)CI::ProviderNode::surfaceForROI((uint64_t)v36, this, &buf.origin.x, (uint64_t)v202);
                    v43 = this;
                    v44 = v36[184];
                    v45 = (CI::Bitmap *)operator new();
                    v38 = (uint64_t)v45;
                    if (v44)
                      v46 = 1;
                    else
                      v46 = can_sample_nearest;
                    v47 = CI::Bitmap::Bitmap(v45, v42, v183);
                    *(_QWORD *)v47 = &off_1E2EB7688;
                    *((_QWORD *)v47 + 2) = &unk_1E2EB76C0;
                    *((_BYTE *)v47 + 138) = v46;
                    this = v43;
                    *((_BYTE *)v47 + 139) = 1;
                    v48 = (CI::TextureManager *)(*(uint64_t (**)(CI::SWContext *))(*(_QWORD *)v43 + 112))(v43);
                    buf.origin.x = CI::Node::roi(v191[0], (int)v191[1]);
                    buf.origin.y = v49;
                    buf.size.width = v50;
                    buf.size.height = v51;
                    v52 = CI::TextureManager::intermediate(v48, v42, &buf, 2uLL, 0, 1);
                    v53 = (*(uint64_t (**)(CI::SWContext *))(*(_QWORD *)this + 112))(this);
                    CI::TextureManager::add_intermediate_for_node(v53, v191, v52);
                  }
                  goto LABEL_63;
                }
                v223.origin.x = CI::Node::roi(v191[0], (int)v191[1]);
                if (CGRectIsEmpty(v223))
                {
                  v174 = ci_logger_render();
                  if (os_log_type_enabled(v174, OS_LOG_TYPE_ERROR))
                  {
                    CI::SWContext::render_node(v174, v175, v176, v177, v178, v179, v180, v181);
                    abort();
                  }
                  goto LABEL_114;
                }
                buf.origin.x = CI::Node::roi(v191[0], (int)v191[1]);
                buf.origin.y = v84;
                buf.size.width = v85;
                buf.size.height = v86;
                CI::CGNode::cgImageForROI((CGImageRef *)v36, &buf, (CGImageRef *)&cf);
                v87 = v36[152];
                v88 = (CI::Bitmap *)operator new();
                v38 = (uint64_t)v88;
                if (v87)
                  v89 = 1;
                else
                  v89 = can_sample_nearest;
                v90 = CI::Bitmap::Bitmap(v88, (CGImage *)cf);
                *(_QWORD *)v90 = &off_1E2EB7688;
                *((_QWORD *)v90 + 2) = &unk_1E2EB76C0;
                *((_BYTE *)v90 + 138) = v89;
                *((_BYTE *)v90 + 139) = 1;
                v80 = *(double *)&cf;
                cf = 0;
                if (v80 == 0.0)
                  goto LABEL_63;
LABEL_57:
                CFRelease(*(CFTypeRef *)&v80);
              }
LABEL_63:
              if (!*(_QWORD *)(v38 + 72))
              {
                v225.origin.x = CI::Node::roi(v191[0], (int)v191[1]);
                if (!CGRectIsEmpty(v225))
                {
                  v96 = ci_logger_render();
                  if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
                  {
                    v97 = (*(uint64_t (**)(unsigned __int8 *))(*(_QWORD *)v36 + 104))(v36);
                    v98 = *((_DWORD *)v36 + 9);
                    LODWORD(buf.origin.x) = 136446722;
                    *(_QWORD *)((char *)&buf.origin.x + 4) = "void CI::SWContext::render_node(ProgramNode *, const CGRect"
                                                             " &, const CGRect &, const Bitmap *)";
                    WORD2(buf.origin.y) = 2080;
                    *(_QWORD *)((char *)&buf.origin.y + 6) = v97;
                    HIWORD(buf.size.width) = 1024;
                    LODWORD(buf.size.height) = v98;
                    _os_log_error_impl(&dword_1921E4000, v96, OS_LOG_TYPE_ERROR, "%{public}s: Bad bitmap argument for %s:%d leaf", (uint8_t *)&buf, 0x1Cu);
                  }
                }
              }
              CI::SerialObjectPtrArray::append((uint64_t)&v203, (CI::Object *)v38);
              CI::Object::unref((CI::Object *)v38);
              v22 = v186;
              if (*(_QWORD *)&__p[0].origin.x)
              {
                __p[0].origin.y = __p[0].origin.x;
                operator delete(*(void **)&__p[0].origin.x);
              }
              v10 = v35;
              v13 = v187;
              goto LABEL_70;
            }
LABEL_51:
            CI::SerialObjectPtrArray::append((uint64_t)&v203, (CI::Object *)v33);
            goto LABEL_70;
          }
          if ((v30 - 44) < 2)
            break;
          if (v30 == 40)
          {
            if ((*(unsigned int (**)(int *))(*(_QWORD *)v33 + 16))(v33) != 60)
              goto LABEL_106;
            memset(&buf, 0, sizeof(buf));
            buf.origin.x = CI::Node::region_of_child(v10, *a3);
            buf.origin.y = v81;
            buf.size.width = v82;
            buf.size.height = v83;
            v61 = (CI::Object *)operator new();
            CI::TextureSampler::transform((CI::TextureSampler *)v33, this, &buf, (float64x2_t *)&v200);
            v72 = &v200;
            v71 = v61;
            goto LABEL_49;
          }
          if (v30 != 41)
            goto LABEL_51;
          if ((*(unsigned int (**)(int *))(*(_QWORD *)v33 + 16))(v33) != 60)
            goto LABEL_106;
          memset(__p, 0, 32);
          __p[0].origin.x = CI::Node::region_of_child(v10, *a3);
          __p[0].origin.y = v54;
          __p[0].size.width = v55;
          __p[0].size.height = v56;
          CI::TextureSampler::transform((CI::TextureSampler *)v33, this, __p, (float64x2_t *)&buf);
          v57 = *((double *)v33 + 11);
          v58 = *((double *)v33 + 12);
          v59 = *((double *)v33 + 13);
          v60 = *((double *)v33 + 14);
          v61 = (CI::Object *)operator new();
          v194 = buf;
          v195 = v213;
          CI::Vector::Vector(v61, &v194, v57, v58, v59, v60);
LABEL_50:
          CI::SerialObjectPtrArray::append((uint64_t)&v203, v61);
          CI::Object::unref(v61);
LABEL_70:
          ++v28;
          ++v29;
          if (*(_QWORD *)v188 == v28)
            goto LABEL_71;
        }
        if ((*(unsigned int (**)(int *))(*(_QWORD *)v33 + 16))(v33) != 58)
          goto LABEL_106;
        CI::Vector::affine((CI::Vector *)v33, &buf.origin.x);
        v62 = a3->origin.x - v26;
        v63 = a3->origin.y - v27;
        v64 = buf.origin.x;
        v65 = buf.origin.y;
        size = buf.size;
        v67 = *(double *)&v213 + buf.origin.x * v62 + buf.size.width * v63;
        v68 = v27;
        v69 = height;
        v70 = *((double *)&v213 + 1) + buf.origin.y * v62 + buf.size.height * v63;
        v71 = (CI::Vector *)operator new();
        v61 = v71;
        *(CGFloat *)v196 = v64;
        *(CGFloat *)&v196[1] = v65;
        v197 = size;
        v198 = v67;
        v199 = v70;
        height = v69;
        v27 = v68;
        v26 = v185;
        v72 = (CGAffineTransform *)v196;
LABEL_49:
        CI::Vector::Vector(v71, v72);
        goto LABEL_50;
      }
LABEL_71:
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)&buf);
      v99 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&buf.size.width, (uint64_t)"CI::SWContextRenderQ", 20);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v99, (uint64_t)"-", 1);
      (*(void (**)(CI::SWContext *))(*(_QWORD *)this + 272))(this);
      v100 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v100, (uint64_t)"-", 1);
      std::ostream::operator<<();
      std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)&buf.size.height, v191);
      if (SHIBYTE(v192) >= 0)
        v101 = (char *)v191;
      else
        v101 = (char *)v191[0];
      QueuePool<4>::QueuePool((uint64_t)__p, v101);
      if (SHIBYTE(v192) < 0)
        operator delete(v191[0]);
      v191[0] = 0;
      v191[1] = 0;
      v192 = 0;
      v102 = vcvtd_n_u64_f64(ceil(a3->size.height * 0.125), 3uLL);
      v103 = atomic_load((unsigned int *)v190 + 2);
      v189 = v103;
      if (v102)
      {
        for (i = 0; i < v102; i += 8)
        {
          v105 = height - (double)i;
          if ((unint64_t)v105 >= 8)
            v106 = 8;
          else
            v106 = (unint64_t)v105;
          v107 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
          v108 = (dispatch_queue_t *)QueuePool<4>::get_new((uint64_t)__p, (uint64_t)v107);
          v109 = v108;
          v110 = v191[1];
          if (v191[1] >= v192)
          {
            v112 = (v191[1] - v191[0]) >> 3;
            if ((unint64_t)(v112 + 1) >> 61)
              goto LABEL_114;
            v113 = (v192 - v191[0]) >> 2;
            if (v113 <= v112 + 1)
              v113 = v112 + 1;
            if ((unint64_t)(v192 - v191[0]) >= 0x7FFFFFFFFFFFFFF8)
              v114 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v114 = v113;
            if (v114)
              v115 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v192, v114);
            else
              v115 = 0;
            v116 = (CI::Node *)&v115[8 * v112];
            *(_QWORD *)v116 = v109;
            v111 = (CI::Node *)((char *)v116 + 8);
            v118 = v191[0];
            v117 = v191[1];
            if (v191[1] != v191[0])
            {
              do
              {
                v119 = *((_QWORD *)v117 - 1);
                v117 = (CI::Node *)((char *)v117 - 8);
                *((_QWORD *)v116 - 1) = v119;
                v116 = (CI::Node *)((char *)v116 - 8);
              }
              while (v117 != v118);
              v117 = v191[0];
            }
            v191[0] = v116;
            v191[1] = v111;
            v192 = (CI::Node *)&v115[8 * v114];
            if (v117)
              operator delete(v117);
          }
          else
          {
            *(_QWORD *)v191[1] = v108;
            v111 = (CI::Node *)((char *)v110 + 8);
          }
          v191[1] = v111;
          CI::SoftwareDAG::execute((uint64_t)v13, (uint64_t)&v203, v109, v190, 0, v26, v27 + (double)i, (double)(unint64_t)width, (double)v106);
        }
      }
      v120 = (dispatch_queue_t **)v191[0];
      v121 = v191[1];
      while (v120 != (dispatch_queue_t **)v121)
      {
        v122 = *v120++;
        dispatch_sync(*v122, &__block_literal_global_25_0);
        Queue::~Queue(v122);
        MEMORY[0x194025AAC]();
      }
      v123 = atomic_load((unsigned int *)v190 + 2);
      if (v189 != v123)
      {
        v182 = ci_logger_render();
        if (os_log_type_enabled(v182, OS_LOG_TYPE_ERROR))
        {
          CI::SWContext::render_node(v189, v123, v182);
          abort();
        }
        goto LABEL_114;
      }
      if (v191[0])
      {
        v191[1] = v191[0];
        operator delete(v191[0]);
      }
      QueuePool<4>::~QueuePool((uint64_t)__p);
      buf.origin.x = *(CGFloat *)MEMORY[0x1E0DE4F50];
      v124 = *(double *)(MEMORY[0x1E0DE4F50] + 72);
      *(CGFloat *)((char *)&buf.origin.x + *(_QWORD *)(*(_QWORD *)&buf.origin.x - 24)) = *(CGFloat *)(MEMORY[0x1E0DE4F50] + 64);
      buf.size.width = v124;
      *(_QWORD *)&buf.size.height = MEMORY[0x1E0DE4FB8] + 16;
      if (v215 < 0)
        operator delete(v214);
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x194025A58](v216);
    }
LABEL_106:
    CI::SerialObjectPtrArray::~SerialObjectPtrArray((CI::SerialObjectPtrArray *)&v203);
  }
}

dispatch_queue_t CI::ProgramNode::mainProgram(dispatch_queue_t *this)
{
  std::chrono::steady_clock::now();
  dispatch_sync(this[13], &__block_literal_global_25_0);
  std::chrono::steady_clock::now().__d_.__rep_;
  return this[15];
}

double CI::Node::region_of_child(CI::Node *this, CGRect a2)
{
  double v2;
  double v3;
  void *__p[3];

  (*(void (**)(void **__return_ptr, CGPoint, __n128, CGSize, __n128))(*(_QWORD *)this + 368))(__p, a2.origin, *(__n128 *)&a2.origin.y, a2.size, *(__n128 *)&a2.size.height);
  CI::CGRectArray::unionRect((CGRect **)__p);
  v3 = v2;
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v3;
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  std::ios_base *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = MEMORY[0x1E0DE4FD0];
  v3 = MEMORY[0x1E0DE4FD0] + 104;
  *(_QWORD *)(a1 + 128) = MEMORY[0x1E0DE4FD0] + 104;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  v4 = (_QWORD *)(a1 + 16);
  v5 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v6 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + *(_QWORD *)(v6 - 24)) = v7;
  *(_QWORD *)(a1 + 8) = 0;
  v8 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  v9 = v5[4];
  v10 = v5[5];
  *v4 = v9;
  *(_QWORD *)((char *)v4 + *(_QWORD *)(v9 - 24)) = v10;
  v11 = v5[1];
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + *(_QWORD *)(v11 - 24)) = v5[6];
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 128) = v3;
  *v4 = v2 + 64;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 24) = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

_QWORD *QueuePool<4>::get_new(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  _QWORD *v3;
  _QWORD block[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v2 = *(NSObject **)(a1 + 8);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN9QueuePoolILi4EE7get_newEP21dispatch_queue_attr_s_block_invoke;
  block[3] = &unk_1E2EC58F0;
  block[4] = &v6;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync(v2, block);
  v3 = (_QWORD *)operator new();
  *v3 = v7[3];
  v3[1] = dispatch_group_create();
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t CI::SWContext::render_root_node(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;
  _QWORD *v11;
  void **v12;
  NSObject *v13;
  uint64_t v14;
  _QWORD v16[9];
  void *__p[2];
  char v18;
  _QWORD v19[2];
  uint64_t v20;
  _QWORD v21[10];
  char v22;
  uint64_t v23;

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)v19);
  v10 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v20, (uint64_t)"CI::SWContext-root", 18);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)"-", 1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
  v11 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)"-", 1);
  std::ostream::operator<<();
  std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)v21, __p);
  if (v18 >= 0)
    v12 = __p;
  else
    v12 = (void **)__p[0];
  v13 = dispatch_queue_create((const char *)v12, 0);
  if (v18 < 0)
    operator delete(__p[0]);
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 0x40000000;
  v16[2] = ___ZN2CI9SWContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke;
  v16[3] = &unk_1E2EC5888;
  v16[6] = a1;
  v16[7] = a3;
  v16[8] = a2;
  v16[4] = a4;
  v16[5] = a5;
  dispatch_sync(v13, v16);
  dispatch_release(v13);
  v19[0] = *MEMORY[0x1E0DE4F50];
  v14 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v19 + *(_QWORD *)(v19[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v20 = v14;
  v21[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v22 < 0)
    operator delete((void *)v21[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x194025A58](&v23);
}

void ___ZN2CI9SWContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke(uint64_t a1)
{
  CI::parentROI *v2;
  CI::SWContext *v3;
  uint64_t v4;
  CGFloat v5;
  CGFloat v6;
  CGFloat v7;
  NSObject *v8;
  os_signpost_id_t v9;
  const CI::ProgramNode *v10;
  uint64_t v11;
  double Current;
  uint64x2_t *v13;
  CI::TileTask *v14;
  CFAbsoluteTime v15;
  uint64_t v16;
  NSObject *v17;
  os_signpost_id_t v18;
  NSObject *v19;
  CGRect v20;
  CGRect v21;
  uint8_t buf[4];
  int v23;
  _QWORD v24[7];

  v24[6] = *MEMORY[0x1E0C80C00];
  v3 = *(CI::SWContext **)(a1 + 48);
  v2 = *(CI::parentROI **)(a1 + 56);
  v4 = *(_QWORD *)v2;
  v21.origin.x = CI::parentROI::roi(v2);
  v21.origin.y = v5;
  v21.size.width = v6;
  v21.size.height = v7;
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v8 = ci_signpost_log_render();
    v9 = *(int *)(v4 + 36) | (unint64_t)((*(uint64_t (**)(CI::SWContext *))(*(_QWORD *)v3 + 272))(v3) << 32);
    if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
    {
      *(_DWORD *)buf = 68289026;
      v23 = 256;
      LOWORD(v24[0]) = 2082;
      *(_QWORD *)((char *)v24 + 2) = CI::Context::programName((dispatch_queue_t *)v4, v10);
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v8, OS_SIGNPOST_INTERVAL_BEGIN, v9, "render_node", "%{public}.256s", buf, 0x12u);
    }
  }
  v11 = (*(uint64_t (**)(CI::SWContext *))(*(_QWORD *)v3 + 272))(v3);
  TimerBase::TimerBase((uint64_t)buf, v11, *(_DWORD *)(v4 + 36), (uint64_t)"render_node", 0);
  Current = CFAbsoluteTimeGetCurrent();
  CI::TileTask::addROIForNode(*(CI::TileTask **)(a1 + 64), (CI::ProgramNode *)v4, &v21);
  v13 = (uint64x2_t *)*((_QWORD *)v3 + 49);
  v20.origin.x = 0.0;
  v20.origin.y = 0.0;
  v20.size = (CGSize)vcvtq_f64_u64(v13[5]);
  CI::SWContext::render_node(v3, (dispatch_queue_t *)v4, &v21, &v20, (const CI::Bitmap *)v13);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  v14 = *(CI::TileTask **)(a1 + 64);
  v15 = CFAbsoluteTimeGetCurrent();
  CI::TileTask::incrementTimeForNode(v14, (const CI::ProgramNode *)v4, v15 - Current);
  v16 = *(_QWORD *)(a1 + 64);
  *(CFAbsoluteTime *)(v16 + 40) = CFAbsoluteTimeGetCurrent();
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v17 = ci_signpost_log_render();
    v18 = v24[0];
    if ((unint64_t)(v24[0] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v19 = v17;
      if (os_signpost_enabled(v17))
      {
        LOWORD(v20.origin.x) = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v19, OS_SIGNPOST_INTERVAL_END, v18, "render_node", (const char *)&unk_192520C83, (uint8_t *)&v20, 2u);
      }
    }
  }
  TimerBase::~TimerBase((TimerBase *)buf);
}

const char *CI::Context::programName(dispatch_queue_t *this, const CI::ProgramNode *a2)
{
  if (!this)
    return "";
  if (CI::ProgramNode::mainProgram(this) && CI::ProgramNode::mainProgram(this)[6].isa)
    return (const char *)CI::ProgramNode::mainProgram(this)[6].isa;
  return "";
}

void CI::SWContext::render_intermediate_node(uint64_t a1, CFAbsoluteTime *a2, CI::parentROI *this, uint64_t (***a4)(_QWORD), uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  CGFloat v11;
  CGFloat v12;
  CGFloat v13;
  NSObject *v14;
  os_signpost_id_t v15;
  const CI::ProgramNode *v16;
  uint64_t v17;
  double Current;
  _QWORD *v19;
  _QWORD *v20;
  void **v21;
  NSObject *v22;
  CFAbsoluteTime v23;
  uint64_t v24;
  NSObject *v25;
  os_signpost_id_t v26;
  NSObject *v27;
  _QWORD v28[7];
  CGRect v29;
  void *__p[2];
  char v31;
  _BYTE v32[8];
  os_signpost_id_t v33;
  CGRect v34;
  uint8_t buf[8];
  __int16 v36;
  _BYTE v37[14];
  _QWORD v38[10];
  char v39;
  _QWORD v40[20];

  v40[19] = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)this;
  v34.origin.x = CI::parentROI::roi(this);
  v34.origin.y = v11;
  v34.size.width = v12;
  v34.size.height = v13;
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v14 = ci_signpost_log_render();
    v15 = *(int *)(v10 + 36) | (unint64_t)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1) << 32);
    if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v14))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 256;
      v36 = 2082;
      *(_QWORD *)v37 = CI::Context::programName((dispatch_queue_t *)v10, v16);
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v14, OS_SIGNPOST_INTERVAL_BEGIN, v15, "render_node", "%{public}.256s", buf, 0x12u);
    }
  }
  v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
  TimerBase::TimerBase((uint64_t)v32, v17, *(_DWORD *)(v10 + 36), (uint64_t)"render_node", 0);
  Current = CFAbsoluteTimeGetCurrent();
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:nn180100]((uint64_t)buf);
  v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v37[6], (uint64_t)"CI::SWContext-intermediate", 26);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"-", 1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
  v20 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"-", 1);
  std::ostream::operator<<();
  std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)v38, __p);
  if (v31 >= 0)
    v21 = __p;
  else
    v21 = (void **)__p[0];
  v22 = dispatch_queue_create((const char *)v21, 0);
  if (v31 < 0)
    operator delete(__p[0]);
  CI::TileTask::addROIForNode((CI::TileTask *)a2, (CI::ProgramNode *)v10, &v34);
  if ((**a4)(a4))
  {
    v28[1] = 0x40000000;
    v29 = v34;
    v28[0] = MEMORY[0x1E0C809B0];
    v28[2] = ___ZN2CI9SWContext24render_intermediate_nodeEPNS_8TileTaskERKNS_9parentROIEPNS_14intermediate_tEbU13block_pointerFvvE_block_invoke;
    v28[3] = &__block_descriptor_tmp_7_0;
    v28[4] = a1;
    v28[5] = a4;
    v28[6] = v10;
    dispatch_sync(v22, v28);
    dispatch_release(v22);
    v23 = CFAbsoluteTimeGetCurrent();
    CI::TileTask::incrementTimeForNode((CI::TileTask *)a2, (const CI::ProgramNode *)v10, v23 - Current);
    a2[5] = CFAbsoluteTimeGetCurrent();
    (*(void (**)(uint64_t))(a6 + 16))(a6);
  }
  *(_QWORD *)buf = *MEMORY[0x1E0DE4F50];
  v24 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)] = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  *(_QWORD *)&v37[6] = v24;
  v38[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (v39 < 0)
    operator delete((void *)v38[8]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x194025A58](v40);
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v25 = ci_signpost_log_render();
    v26 = v33;
    if (v33 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v27 = v25;
      if (os_signpost_enabled(v25))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v27, OS_SIGNPOST_INTERVAL_END, v26, "render_node", (const char *)&unk_192520C83, buf, 2u);
      }
    }
  }
  TimerBase::~TimerBase((TimerBase *)v32);
}

void ___ZN2CI9SWContext24render_intermediate_nodeEPNS_8TileTaskERKNS_9parentROIEPNS_14intermediate_tEbU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  CI::SWContext *v2;
  __IOSurface *v3;
  dispatch_queue_t *v4;
  const CGRect *v5;
  _QWORD v6[17];
  __int16 v7;

  v2 = *(CI::SWContext **)(a1 + 32);
  v3 = (__IOSurface *)(***(uint64_t (****)(_QWORD))(a1 + 40))(*(_QWORD *)(a1 + 40));
  CI::Bitmap::Bitmap((CI::Bitmap *)v6, v3, 0);
  v6[0] = &off_1E2EB7688;
  v6[2] = &unk_1E2EB76C0;
  v7 = 0;
  v4 = *(dispatch_queue_t **)(a1 + 48);
  v5 = (const CGRect *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 40) + 32))(*(_QWORD *)(a1 + 40));
  CI::SWContext::render_node(v2, v4, (const CGRect *)(a1 + 56), v5, (const CI::Bitmap *)v6);
  CI::Bitmap::~Bitmap((CI::Bitmap *)v6);
}

void CI::SWContext::after_render(IOSurfaceRef *this)
{
  NSObject *v2;
  os_signpost_id_t v3;
  uint64_t v4;
  CI::Object *v5;
  NSObject *v6;
  os_signpost_id_t v7;
  NSObject *v8;
  uint8_t v9[8];
  os_signpost_id_t v10;
  uint8_t buf[16];

  v2 = ci_signpost_log_render();
  v3 = (*((uint64_t (**)(IOSurfaceRef *))*this + 34))(this) << 32;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)v9 = 0;
    _os_signpost_emit_with_name_impl(&dword_1921E4000, v2, OS_SIGNPOST_INTERVAL_BEGIN, v3, "after_render", (const char *)&unk_192520C83, v9, 2u);
  }
  v4 = (*((uint64_t (**)(IOSurfaceRef *))*this + 34))(this);
  TimerBase::TimerBase((uint64_t)v9, v4, 0, (uint64_t)"after_render", 8);
  IOSurfaceUnlock(this[50], 0, 0);
  this[50] = 0;
  v5 = this[49];
  if (v5)
    CI::Object::unref(v5);
  this[49] = 0;
  v6 = ci_signpost_log_render();
  v7 = v10;
  if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v8 = v6;
    if (os_signpost_enabled(v6))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v8, OS_SIGNPOST_INTERVAL_END, v7, "after_render", (const char *)&unk_192520C83, buf, 2u);
    }
  }
  TimerBase::~TimerBase((TimerBase *)v9);
}

void CI::SWTextureManager::~SWTextureManager(dispatch_queue_t *this)
{
  *this = (dispatch_queue_t)&off_1E2EB7BA8;
  CI::TextureManager::purge_intermediates((CI::TextureManager *)this);
  dispatch_sync(this[12], &__block_literal_global_9_1);
  CI::TextureManager::remove_all((CI::TextureManager *)this);
  CI::TextureManager::~TextureManager(this);
}

{
  CI::SWTextureManager::~SWTextureManager(this);
  JUMPOUT(0x194025AACLL);
}

__CFDictionary *CI::SWContext::switch_dictionary(CI::SWContext *this)
{
  __CFDictionary *result;
  __CFDictionary *Mutable;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  result = (__CFDictionary *)*((_QWORD *)this + 52);
  if (!result)
  {
    Mutable = CFDictionaryCreateMutable(0, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *((_QWORD *)this + 52) = Mutable;
    __CFDictionary::setValue(Mutable, (__CFDictionary *)CFSTR("kContextInfoSupportsMPS"), 0, v4);
    __CFDictionary::setValue(*((__CFDictionary **)this + 52), (__CFDictionary *)CFSTR("kContextInfoIsMetal"), 0, v5);
    __CFDictionary::setValue(*((__CFDictionary **)this + 52), (__CFDictionary *)CFSTR("kContextInfoIsSoftware"), (const __CFString *)1, v6);
    __CFDictionary::setValue(*((__CFDictionary **)this + 52), (__CFDictionary *)CFSTR("kContextInfoWorkingFormat"), (const __CFString *)*((unsigned int *)this + 8));
    v8 = (const void *)*((_QWORD *)this + 3);
    result = (__CFDictionary *)*((_QWORD *)this + 52);
    if (v8)
    {
      __CFDictionary::setValue(result, CFSTR("kContextInfoWorkingSpace"), v8, v7);
      return (__CFDictionary *)*((_QWORD *)this + 52);
    }
  }
  return result;
}

void __CFDictionary::setValue(__CFDictionary *this, __CFDictionary *a2, const __CFString *a3)
{
  CFNumberRef v5;
  const void *v6;
  int valuePtr;

  valuePtr = (int)a3;
  v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  __CFDictionary::setValue(this, a2, v5, v6);
  if (v5)
    CFRelease(v5);
}

{
  CFNumberRef v5;
  const void *v6;
  const __CFString *valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  __CFDictionary::setValue(this, a2, v5, v6);
  if (v5)
    CFRelease(v5);
}

uint64_t CI::SWTextureManager::create_intermediate(uint64_t a1, int *a2, uint64_t a3, CGFloat *a4, uint64_t a5, uint64_t a6, char a7)
{
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  unint64_t width;
  unint64_t height;
  BOOL v18;
  uint64_t v19;
  __int128 v21;
  CFStringRef v22;
  int v23;
  _QWORD *v24;
  uint64_t v25;
  int v26;
  int v27;
  NSObject *v28;
  unint64_t v29;
  _QWORD block[7];
  __int128 v31;
  uint64_t v32;
  __int128 v33;
  unint64_t v34;
  CGRect v35;
  CGRect v36;
  CGRect v37;
  CGRect v38;
  CGRect v39;

  if ((a7 & 1) != 0)
    return 0;
  v12 = *a4;
  v13 = a4[1];
  v14 = a4[2];
  v15 = a4[3];
  v35.origin.x = *a4;
  v35.origin.y = v13;
  v35.size.width = v14;
  v35.size.height = v15;
  if (CGRectIsNull(v35))
    return 0;
  v36.origin.x = v12;
  v36.origin.y = v13;
  v36.size.width = v14;
  v36.size.height = v15;
  if (!CGRectIsInfinite(v36))
  {
    v37.origin.x = v12;
    v37.origin.y = v13;
    v37.size.width = v14;
    v37.size.height = v15;
    v38 = CGRectInset(v37, 0.000001, 0.000001);
    v39 = CGRectIntegral(v38);
    width = (unint64_t)v39.size.width;
    height = (unint64_t)v39.size.height;
    if ((unint64_t)v39.size.width)
      v18 = height == 0;
    else
      v18 = 1;
    if (!v18)
    {
      LODWORD(v29) = (int)v39.origin.x;
      HIDWORD(v29) = (int)v39.origin.y;
      goto LABEL_12;
    }
    return 0;
  }
  v29 = 0x8000000180000001;
  width = 0xFFFFFFFFLL;
  height = 0xFFFFFFFFLL;
LABEL_12:
  v19 = operator new();
  *(_QWORD *)v19 = off_1E2EBAFD0;
  *(_QWORD *)(v19 + 8) = 0;
  *(_WORD *)(v19 + 72) = 1;
  *(_QWORD *)(v19 + 24) = 0;
  v21 = *((_OWORD *)a4 + 1);
  *(_OWORD *)(v19 + 32) = *(_OWORD *)a4;
  *(_OWORD *)(v19 + 48) = v21;
  *(_QWORD *)(v19 + 64) = a6;
  if (CI_IOSURFACE_INTERMEDIATES())
  {
    v22 = CFStringCreateWithFormat(0, 0, CFSTR("%llX(%04X)"), a3, *a2);
    v23 = CI::PixelFormatType_from_format(*a2);
    *(_QWORD *)&v33 = v29;
    *((_QWORD *)&v33 + 1) = width;
    v34 = height;
    LODWORD(v31) = 0;
    v24 = *(_QWORD **)(a1 + 168);
    v25 = v24[47];
    *((_QWORD *)&v31 + 1) = 0;
    v32 = v25;
    v26 = (*(uint64_t (**)(_QWORD *))(*v24 + 272))(v24);
    v27 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 168) + 232))(*(_QWORD *)(a1 + 168));
    *(_QWORD *)(v19 + 24) = GetSurfaceFromCache(&v33, 1, 1, v23, &v31, v26, 0, v27, (uint64_t)v22, v19 + 72, 0);
    CFRelease(v22);
  }
  else
  {
    *(_QWORD *)(v19 + 24) = 0;
    *(_BYTE *)(v19 + 72) = 1;
  }
  v28 = *(NSObject **)(a1 + 104);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI16SWTextureManager19create_intermediateERKNS_22IntermediateDescriptorENS_17NodeContentDigestERK6CGRectmmb_block_invoke;
  block[3] = &__block_descriptor_tmp_21;
  block[4] = a1;
  block[5] = v19;
  block[6] = a6;
  dispatch_sync(v28, block);
  return v19;
}

void ___ZN2CI16SWTextureManager19create_intermediateERKNS_22IntermediateDescriptorENS_17NodeContentDigestERK6CGRectmmb_block_invoke(_QWORD *a1)
{
  uint64_t *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t (***v5)(_QWORD);
  unint64_t v6;
  const void *v7;

  v2 = *(uint64_t **)(a1[4] + 136);
  v3 = operator new(0x18uLL);
  v3[2] = a1[5];
  v4 = *v2;
  *v3 = *v2;
  v3[1] = v2;
  *(_QWORD *)(v4 + 8) = v3;
  *v2 = (uint64_t)v3;
  ++v2[2];
  v5 = (uint64_t (***)(_QWORD))a1[5];
  if (v5 && (**v5)(v5) && a1[6] >= 2uLL)
  {
    v6 = 1;
    do
    {
      v7 = (const void *)(**(uint64_t (***)(_QWORD))a1[5])(a1[5]);
      RetainSurfaceFromCache(v7);
      ++v6;
    }
    while (v6 < a1[6]);
  }
}

uint64_t CI::TextureManager::create_intermediate()
{
  return 0;
}

void CI::TextureManager::convert_to_sRGB()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v0 = ci_logger_render();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
    CI::TextureManager::convert_to_sRGB(v0, v1, v2, v3, v4, v5, v6, v7);
}

uint64_t CI::TextureManager::wiredBytes(CI::TextureManager *this)
{
  return 0;
}

uint64_t CI::SWContext::type(CI::SWContext *this)
{
  return 75;
}

uint64_t CI::Context::blitSurface()
{
  return 0;
}

uint64_t CI::SWContext::texture_manager(CI::SWContext *this)
{
  return *((_QWORD *)this + 51);
}

__n128 CI::Context::setCTM(CI::Context *this, CGAffineTransform *a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)&a2->a;
  v3 = *(_OWORD *)&a2->tx;
  *((_OWORD *)this + 7) = *(_OWORD *)&a2->c;
  *((_OWORD *)this + 8) = v3;
  *((__n128 *)this + 6) = result;
  return result;
}

__n128 CI::Context::CTM@<Q0>(CI::Context *this@<X0>, uint64_t a2@<X8>)
{
  __int128 v2;
  __n128 result;

  v2 = *((_OWORD *)this + 7);
  *(_OWORD *)a2 = *((_OWORD *)this + 6);
  *(_OWORD *)(a2 + 16) = v2;
  result = *((__n128 *)this + 8);
  *(__n128 *)(a2 + 32) = result;
  return result;
}

uint64_t CI::Context::setHLGOpticalScale(uint64_t this, float a2)
{
  *(float *)(this + 36) = a2;
  return this;
}

float CI::Context::HLGOpticalScale(CI::Context *this)
{
  return *((float *)this + 9);
}

uint64_t CI::Context::lossyIntermediates(CI::Context *this)
{
  return 0;
}

CGRect *CI::Context::setBounds(CGRect *this, CGRect a2)
{
  this[2] = a2;
  return this;
}

double CI::Context::bounds(CI::Context *this)
{
  return *((double *)this + 8);
}

float CI::Context::setQuality(CI::Context *this, float a2)
{
  float result;

  result = fmaxf(fminf(a2, 1.0), -1.0);
  *((float *)this + 14) = result;
  return result;
}

float CI::Context::quality(CI::Context *this)
{
  return *((float *)this + 14);
}

uint64_t CI::Context::downsampleQuality(CI::Context *this)
{
  return *((unsigned __int8 *)this + 60);
}

uint64_t CI::Context::cacheVolatility(CI::Context *this)
{
  return *((unsigned int *)this + 58);
}

uint64_t CI::Context::setAbortflag(uint64_t this, char a2)
{
  *(_BYTE *)(this + 44) = a2;
  return this;
}

uint64_t CI::Context::abortflag(CI::Context *this)
{
  return *((unsigned __int8 *)this + 44);
}

uint64_t CI::Context::priority(CI::Context *this)
{
  return 0;
}

uint64_t CI::Context::setDefaultBlendingEnabled(uint64_t this, char a2)
{
  *(_BYTE *)(this + 300) = a2;
  return this;
}

uint64_t CI::Context::defaultBlendingEnabled(CI::Context *this)
{
  return *((unsigned __int8 *)this + 300);
}

uint64_t CI::SWContext::is_cpu(CI::SWContext *this)
{
  return 1;
}

const char *CI::SWContext::name(CI::SWContext *this)
{
  return "sw";
}

uint64_t CI::Context::pre_render(CI::Context *this)
{
  return 1;
}

void CI::Context::destination_descriptor(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 4) = 0;
}

uint64_t CI::Context::set_texture_destination()
{
  return 0;
}

uint64_t CI::Context::set_texture_destination(CI::Context *this, Texture a2, const CGRect *a3)
{
  return (*(uint64_t (**)(CI::Context *, unint64_t, void *, CGSize *))(*(_QWORD *)this + 368))(this, a2.var0.var0, a2.var0.var2.var1, &a3->size);
}

uint64_t CI::Context::max_kernel_arguments_size(CI::Context *this)
{
  return (*(uint64_t (**)(CI::Context *))(*(_QWORD *)this + 480))(this);
}

uint64_t CI::Context::resticted_kernel_arguments_size(CI::Context *this)
{
  return (*(uint64_t (**)(CI::Context *))(*(_QWORD *)this + 480))(this);
}

uint64_t CI::Context::bitmap_destination_rowbytes_alignment(uint64_t a1, int a2)
{
  if (CI::format_is_half_float(a2))
    return 8;
  else
    return 4;
}

uint64_t CI::SWContext::surface_rowbytes_alignment_for_input()
{
  return 16;
}

uint64_t CI::SWContext::surface_rowbytes_alignment_for_output()
{
  return 16;
}

uint64_t CI::SWContext::supportsDeferredCGImage(CI::SWContext *this)
{
  return 1;
}

BOOL CI::SWContext::supports_edge_mode(uint64_t a1, int a2)
{
  return a2 == 1;
}

uint64_t CI::SWContext::supports_sample_mode()
{
  return 1;
}

uint64_t CI::SWContext::supported_compute_features(CI::SWContext *this)
{
  return 0;
}

uint64_t CI::Context::supports_sRGB_texture_for_format()
{
  return 0;
}

uint64_t CI::Context::protectionOptions(CI::Context *this)
{
  return 0;
}

uint64_t `non-virtual thunk to'CI::SWContext::type(CI::SWContext *this)
{
  return 75;
}

void CI::BitmapSampler::~BitmapSampler(CI::BitmapSampler *this)
{
  CI::Bitmap::~Bitmap(this);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::BitmapSampler::type(CI::BitmapSampler *this)
{
  return 56;
}

uint64_t `non-virtual thunk to'CI::BitmapSampler::type(CI::BitmapSampler *this)
{
  return 56;
}

void `non-virtual thunk to'CI::BitmapSampler::~BitmapSampler(CI::BitmapSampler *this)
{
  CI::Bitmap::~Bitmap((CI::BitmapSampler *)((char *)this - 16));
}

{
  CI::Bitmap::~Bitmap((CI::BitmapSampler *)((char *)this - 16));
  JUMPOUT(0x194025AACLL);
}

void CI::CGRectArray::unionRect(CGRect **this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  CGRect *v5;
  CGRect *v6;

  v1 = *MEMORY[0x1E0C9D628];
  v2 = *(_QWORD *)(MEMORY[0x1E0C9D628] + 8);
  v3 = *(_QWORD *)(MEMORY[0x1E0C9D628] + 16);
  v4 = *(_QWORD *)(MEMORY[0x1E0C9D628] + 24);
  v5 = *this;
  v6 = this[1];
  while (v5 != v6)
    *(CGRect *)&v1 = CGRectUnion(*(CGRect *)&v1, *v5++);
}

uint64_t CI::TextureManager::tmIntermediate_t::surface(CI::TextureManager::tmIntermediate_t *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t CI::TextureManager::tmIntermediate_t::needs_rendering(CI::TextureManager::tmIntermediate_t *this)
{
  return *((unsigned __int8 *)this + 72);
}

uint64_t CI::TextureManager::tmIntermediate_t::useCount(CI::TextureManager::tmIntermediate_t *this)
{
  return *((_QWORD *)this + 8);
}

uint64_t CI::TextureManager::tmIntermediate_t::texture(CI::TextureManager::tmIntermediate_t *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t CI::TextureManager::tmIntermediate_t::roi(CI::TextureManager::tmIntermediate_t *this)
{
  return (uint64_t)this + 32;
}

void CI::TextureManager::tmIntermediate_t::~tmIntermediate_t(CI::TextureManager::tmIntermediate_t *this)
{
  JUMPOUT(0x194025AACLL);
}

_QWORD *CI::TextureManager::tmIntermediate_t::updateSurface(_QWORD *this, CFTypeRef cf, int a3)
{
  this[3] = cf;
  if (a3)
    return CFRetain(cf);
  return this;
}

uint64_t CI::TextureManager::tmIntermediate_t::preventInFlight(CI::TextureManager::tmIntermediate_t *this)
{
  return *((unsigned __int8 *)this + 73);
}

uint64_t CI::InstanceCounted<(CI::Type)75>::type()
{
  return 75;
}

_QWORD *CI::InstanceCounted<(CI::Type)75>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBBFB0;
  do
    v1 = __ldaxr(&dword_1ECF873D0[17]);
  while (__stlxr(v1 - 1, &dword_1ECF873D0[17]));
  return result;
}

void CI::InstanceCounted<(CI::Type)75>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBBFB0;
  do
    v1 = __ldaxr(&dword_1ECF873D0[17]);
  while (__stlxr(v1 - 1, &dword_1ECF873D0[17]));
  JUMPOUT(0x194025AACLL);
}

uint64_t std::stringbuf::str[abi:nn180100]<std::allocator<char>>@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  unint64_t v4;
  const void *v5;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;

  result = std::stringbuf::view[abi:nn180100](a1);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v5 = (const void *)result;
  v6 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((_BYTE *)a2 + 23) = v4;
    if (!v4)
      goto LABEL_9;
  }
  result = (uint64_t)memmove(a2, v5, v6);
LABEL_9:
  *((_BYTE *)a2 + v6) = 0;
  return result;
}

uint64_t std::stringbuf::view[abi:nn180100](uint64_t a1)
{
  int v1;
  unint64_t v3;

  v1 = *(_DWORD *)(a1 + 96);
  if ((v1 & 0x10) != 0)
  {
    v3 = *(_QWORD *)(a1 + 48);
    if (*(_QWORD *)(a1 + 88) < v3)
      *(_QWORD *)(a1 + 88) = v3;
    return *(_QWORD *)(a1 + 40);
  }
  else if ((v1 & 8) != 0)
  {
    return *(_QWORD *)(a1 + 16);
  }
  else
  {
    return 0;
  }
}

uint64_t QueuePool<4>::QueuePool(uint64_t a1, char *a2)
{
  NSObject *v4;

  *(_DWORD *)a1 = 0;
  v4 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *(_QWORD *)(a1 + 8) = dispatch_queue_create("QueuePoolLock", v4);
  std::string::basic_string[abi:nn180100]<0>((_QWORD *)(a1 + 16), a2);
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  return a1;
}

uint64_t QueuePool<4>::~QueuePool(uint64_t a1)
{
  uint64_t i;
  NSObject *v3;

  for (i = 40; i != 72; i += 8)
  {
    v3 = *(NSObject **)(a1 + i);
    if (v3)
      dispatch_release(v3);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 8));
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
  return a1;
}

void ___ZN9QueuePoolILi4EE7get_newEP21dispatch_queue_attr_s_block_invoke(uint64_t a1)
{
  int *v2;
  int v3;
  const std::string::value_type *v4;
  std::string::size_type v5;
  std::string *v6;
  std::string::size_type v7;
  std::string *p_p;
  std::string::size_type size;
  std::string *v10;
  std::string::size_type v11;
  const char *v12;
  NSObject *v13;
  int v14;
  const std::string::value_type *v15;
  std::string::size_type v16;
  std::string *v17;
  std::string::size_type v18;
  std::string *v19;
  std::string::size_type v20;
  std::string *v21;
  std::string::size_type v22;
  const char *v23;
  int v24;
  BOOL v25;
  int v26;
  int v27;
  std::string __p;
  std::string v29;
  std::string v30;
  __int128 v31;
  uint64_t v32;

  v2 = *(int **)(a1 + 40);
  if (!*(_QWORD *)&v2[2 * *v2 + 10])
  {
    std::string::basic_string[abi:nn180100]<0>(&v29, "-Pool-");
    v3 = *((char *)v2 + 39);
    if (v3 >= 0)
      v4 = (const std::string::value_type *)(v2 + 4);
    else
      v4 = (const std::string::value_type *)*((_QWORD *)v2 + 2);
    if (v3 >= 0)
      v5 = *((unsigned __int8 *)v2 + 39);
    else
      v5 = *((_QWORD *)v2 + 3);
    v6 = std::string::insert(&v29, 0, v4, v5);
    v7 = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, *v2);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
    v10 = std::string::append(&v30, (const std::string::value_type *)p_p, size);
    v11 = v10->__r_.__value_.__r.__words[2];
    v31 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v32 = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v30.__r_.__value_.__l.__data_);
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v29.__r_.__value_.__l.__data_);
    if (v32 >= 0)
      v12 = (const char *)&v31;
    else
      v12 = (const char *)v31;
    v13 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    *(_QWORD *)&v2[2 * *v2 + 10] = dispatch_queue_create(v12, v13);
    if (SHIBYTE(v32) < 0)
      operator delete((void *)v31);
  }
  std::string::basic_string[abi:nn180100]<0>(&v29, "-");
  v14 = *((char *)v2 + 39);
  if (v14 >= 0)
    v15 = (const std::string::value_type *)(v2 + 4);
  else
    v15 = (const std::string::value_type *)*((_QWORD *)v2 + 2);
  if (v14 >= 0)
    v16 = *((unsigned __int8 *)v2 + 39);
  else
    v16 = *((_QWORD *)v2 + 3);
  v17 = std::string::insert(&v29, 0, v15, v16);
  v18 = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v30.__r_.__value_.__r.__words[2] = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, *v2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v19 = &__p;
  else
    v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v20 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v20 = __p.__r_.__value_.__l.__size_;
  v21 = std::string::append(&v30, (const std::string::value_type *)v19, v20);
  v22 = v21->__r_.__value_.__r.__words[2];
  v31 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v32 = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v30.__r_.__value_.__l.__data_);
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v29.__r_.__value_.__l.__data_);
  if (v32 >= 0)
    v23 = (const char *)&v31;
  else
    v23 = (const char *)v31;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = dispatch_queue_create_with_target_V2(v23, *(dispatch_queue_attr_t *)(a1 + 48), *(dispatch_queue_t *)&v2[2 * *v2 + 10]);
  v24 = *v2 + 1;
  v25 = -v24 < 0;
  v26 = -v24 & 3;
  v27 = v24 & 3;
  if (!v25)
    v27 = -v26;
  *v2 = v27;
  if (SHIBYTE(v32) < 0)
    operator delete((void *)v31);
}

char *FastRegistration_getStatusDescription(int a1)
{
  return (&FastRegistration_statusDescription)[a1 + 8];
}

void CMatrix::CMatrix(CMatrix *this)
{
  *(_QWORD *)this = 0;
  bzero((char *)this + 8, 0xC8uLL);
}

void CMatrix::CMatrix(CMatrix *this, const CMatrix *a2)
{
  unsigned int v2;
  unsigned int v3;

  v2 = *(_DWORD *)a2;
  v3 = *((_DWORD *)a2 + 1);
  *(_DWORD *)this = *(_DWORD *)a2;
  *((_DWORD *)this + 1) = v3;
  memcpy((char *)this + 8, (char *)a2 + 8, 8 * v2 * (unint64_t)v3);
}

void CMatrix::CMatrix(CMatrix *this, unsigned int a2, unsigned int a3)
{
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  if (a2 > 5 || a3 >= 6)
    *(_QWORD *)this = 0;
  bzero((char *)this + 8, 0xC8uLL);
}

void CMatrix::CMatrix(CMatrix *this, unsigned int a2, unsigned int a3, double a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;

  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  if (a2 > 5 || a3 >= 6)
    *(_QWORD *)this = 0;
  bzero((char *)this + 8, 0xC8uLL);
  *((double *)this + 1) = a4;
  v12 = &a5;
  v8 = (*((_DWORD *)this + 1) * *(_DWORD *)this);
  if (v8 >= 2)
  {
    v9 = (uint64_t *)((char *)this + 16);
    v10 = v8 - 1;
    do
    {
      v11 = v12++;
      *v9++ = *v11;
      --v10;
    }
    while (v10);
  }
}

void CMatrix::CMatrix(CMatrix *this, unsigned int a2, unsigned int a3, const double *a4)
{
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  if (a2 > 5 || a3 >= 6)
    *(_QWORD *)this = 0;
  bzero((char *)this + 8, 0xC8uLL);
  memcpy((char *)this + 8, a4, 8 * *(unsigned int *)this * (unint64_t)*((unsigned int *)this + 1));
}

void CMatrix::diagonalMatrix(CMatrix *this@<X0>, double a2@<D0>, _DWORD *a3@<X8>, uint64_t a4, ...)
{
  unsigned int v5;
  unsigned int v7;
  unint64_t v8;
  BOOL v9;
  double *v10;
  _DWORD *v11;
  unint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;

  v5 = this;
  *a3 = (_DWORD)this;
  a3[1] = (_DWORD)this;
  if (this >= 6)
    *(_QWORD *)a3 = 0;
  bzero(a3 + 2, 0xC8uLL);
  LODWORD(v8) = *a3;
  v7 = a3[1];
  if (v7)
    v9 = (_DWORD)v8 == 0;
  else
    v9 = 1;
  if (v9)
    v10 = (double *)&CMatrixRow::operator[]const::zero;
  else
    v10 = (double *)(a3 + 2);
  *v10 = a2;
  v16 = &a4;
  if (v5 >= 2)
  {
    if (v8 >= v7)
      v8 = v7;
    else
      v8 = v8;
    v11 = a3 + 4;
    v12 = 1;
    v13 = v7;
    do
    {
      v14 = (uint64_t *)&v11[2 * v13];
      v15 = v16++;
      if (v12 >= v8)
        v14 = (uint64_t *)&CMatrixRow::operator[]const::zero;
      *v14 = *v15;
      ++v12;
      v13 += v7;
      v11 += 2;
    }
    while (v5 != v12);
  }
}

uint64_t CMatrix::operator[](unsigned int *a1, unsigned int a2)
{
  if (*a1 <= a2)
    return 0;
  else
    return a1[1];
}

void *CMatrixRow::operator[](uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return &CMatrixRow::operator[]const::zero;
  v3 = v2 + 8 * a2;
  if (*(_DWORD *)a1 > a2)
    return (void *)v3;
  else
    return &CMatrixRow::operator[]const::zero;
}

void CMatrix::identityMatrix(CMatrix *this@<X0>, unsigned int *a2@<X8>)
{
  int v2;
  int v4;
  unint64_t v5;
  unsigned int v6;
  unint64_t v7;
  _DWORD *v8;
  _QWORD *v9;

  v2 = (int)this;
  *a2 = this;
  a2[1] = this;
  if (this >= 6)
  {
    *(_QWORD *)a2 = 0;
    bzero(a2 + 2, 0xC8uLL);
  }
  else
  {
    bzero(a2 + 2, 0xC8uLL);
    if (!v2)
      return;
  }
  v4 = 0;
  v5 = 0;
  LODWORD(v7) = *a2;
  v6 = a2[1];
  if (*a2 >= v6)
    v7 = v6;
  else
    v7 = v7;
  v8 = a2 + 2;
  do
  {
    v9 = &v8[2 * v4];
    if (v5 >= v7)
      v9 = &CMatrixRow::operator[]const::zero;
    *v9 = 0x3FF0000000000000;
    ++v5;
    v4 += v6;
    v8 += 2;
  }
  while (v2 != v5);
}

uint64_t CMatrix::columnCount(CMatrix *this)
{
  return *((unsigned int *)this + 1);
}

unsigned int *CMatrix::operator=(unsigned int *a1, unsigned int *a2)
{
  unsigned int v3;
  unsigned int v4;

  if (a1 != a2)
  {
    v3 = *a2;
    v4 = a2[1];
    *a1 = *a2;
    a1[1] = v4;
    memcpy(a1 + 2, a2 + 2, 8 * v3 * (unint64_t)v4);
  }
  return a1;
}

void CMatrix::operator+(unsigned int *a1@<X0>, _DWORD *a2@<X1>, unsigned int *a3@<X8>)
{
  uint64_t v4;
  uint64_t v7;
  int v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  double *v17;

  v4 = *a1;
  if ((_DWORD)v4 == *a2 && (v7 = a1[1], (_DWORD)v7 == a2[1]))
  {
    *a3 = v4;
    a3[1] = v7;
    if (v4 > 5 || v7 >= 6)
      *(_QWORD *)a3 = 0;
    bzero(a3 + 2, 0xC8uLL);
    if ((_DWORD)v4)
    {
      v9 = 0;
      v10 = 0;
      v11 = 0;
      v12 = *a3;
      v13 = a3[1];
      do
      {
        if ((_DWORD)v7)
        {
          v14 = 0;
          v15 = (uint64_t)&a3[2 * v9 + 2];
          do
          {
            if (v14 >= v13 || v11 >= v12)
              v17 = (double *)&CMatrixRow::operator[]const::zero;
            else
              v17 = (double *)v15;
            *v17 = *(double *)&a1[2 * v10 + 2 + 2 * v14] + *(double *)&a2[2 * v10 + 2 + 2 * v14];
            ++v14;
            v15 += 8;
          }
          while (v7 != v14);
        }
        ++v11;
        v10 += v7;
        v9 += v13;
      }
      while (v11 != v4);
    }
  }
  else
  {
    *(_QWORD *)a3 = 0;
    bzero(a3 + 2, 0xC8uLL);
  }
}

void CMatrix::operator*(unsigned int *a1@<X0>, _DWORD *a2@<X1>, unsigned int *a3@<X8>)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  int v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t i;
  BOOL v15;
  double *v16;
  unsigned int v17;
  double v18;
  uint64_t v19;
  double *v20;
  double v21;

  v4 = a1[1];
  if ((_DWORD)v4 == *a2)
  {
    v7 = *a1;
    v8 = a2[1];
    *a3 = v7;
    a3[1] = v8;
    if (v7 > 5 || v8 >= 6)
      *(_QWORD *)a3 = 0;
    bzero(a3 + 2, 0xC8uLL);
    if ((_DWORD)v7)
    {
      v10 = 0;
      v11 = 0;
      v12 = *a3;
      v13 = a3[1];
      do
      {
        if ((_DWORD)v8)
        {
          for (i = 0; i != v8; ++i)
          {
            v15 = i >= v13 || v11 >= v12;
            v16 = (double *)&a3[2 * (v13 * v11) + 2 + 2 * i];
            if (v15)
              v16 = (double *)&CMatrixRow::operator[]const::zero;
            *v16 = 0.0;
            if ((_DWORD)v4)
            {
              v17 = 0;
              v18 = 0.0;
              v19 = v4;
              v20 = (double *)&a1[2 * v10 + 2];
              do
              {
                v21 = *v20++;
                v18 = v18 + v21 * *(double *)&a2[2 * i + 2 + 2 * v17];
                *v16 = v18;
                v17 += v8;
                --v19;
              }
              while (v19);
            }
          }
        }
        ++v11;
        v10 += v4;
      }
      while (v11 != v7);
    }
  }
  else
  {
    *(_QWORD *)a3 = 0;
    bzero(a3 + 2, 0xC8uLL);
  }
}

void CMatrix::transpose(CMatrix *this@<X0>, unsigned int *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  unint64_t i;
  BOOL v13;
  unsigned int *v14;

  v5 = *(unsigned int *)this;
  v4 = *((unsigned int *)this + 1);
  *a2 = v4;
  a2[1] = v5;
  if (v4 > 5 || v5 >= 6)
    *(_QWORD *)a2 = 0;
  bzero(a2 + 2, 0xC8uLL);
  if ((_DWORD)v5)
  {
    v7 = 0;
    v8 = 0;
    v9 = *a2;
    v10 = a2[1];
    do
    {
      if ((_DWORD)v4)
      {
        v11 = 0;
        for (i = 0; i != v4; ++i)
        {
          v13 = v8 >= v10 || i >= v9;
          v14 = &a2[2 * v8 + 2 + 2 * v11];
          if (v13)
            v14 = (unsigned int *)&CMatrixRow::operator[]const::zero;
          *(_QWORD *)v14 = *((_QWORD *)this + v7 + i + 1);
          v11 += v10;
        }
      }
      ++v8;
      v7 += v4;
    }
    while (v8 != v5);
  }
}

void CMatrix::inverse(CMatrix *this@<X0>, unsigned int *a2@<X8>)
{
  int v4;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  double *v20;
  unint64_t v21;
  uint64_t v22;
  double *v24;
  uint64_t v25[26];
  unsigned int v26[52];
  double v27[3];
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v4 = *((_DWORD *)this + 1);
  if (*(_DWORD *)this != 3 || v4 != 3)
  {
    if (*(_DWORD *)this != v4)
    {
      CMatrix::transpose(this, (unsigned int *)v27);
      CMatrix::operator*((unsigned int *)v27, this, v26);
      CMatrix::inverse(v25, (CMatrix *)v26);
      CMatrix::operator*((unsigned int *)v25, v27, a2);
      return;
    }
    goto LABEL_8;
  }
  v6 = *((double *)this + 1);
  v7 = *((double *)this + 2);
  v8 = *((double *)this + 3);
  v9 = *((double *)this + 4);
  v10 = *((double *)this + 5);
  v11 = *((double *)this + 6);
  v12 = *((double *)this + 7);
  v13 = *((double *)this + 8);
  v14 = *((double *)this + 9);
  v27[0] = v10 * v14 - v13 * v11;
  v27[1] = v13 * v8 - v7 * v14;
  v27[2] = v7 * v11 - v10 * v8;
  v28 = v12 * v11 - v9 * v14;
  v29 = v6 * v14 - v12 * v8;
  v30 = v9 * v8 - v6 * v11;
  v31 = v9 * v13 - v12 * v10;
  v32 = v12 * v7 - v6 * v13;
  v33 = v6 * v10 - v9 * v7;
  v15 = v7 * v28 + v6 * v27[0] + v8 * v31;
  if (fabs(v15) < 1.0e-10)
  {
LABEL_8:
    *(_QWORD *)a2 = 0;
    bzero(a2 + 2, 0xC8uLL);
    return;
  }
  *(_QWORD *)a2 = 0x300000003;
  bzero(a2 + 2, 0xC8uLL);
  v16 = 0;
  v17 = 0;
  v18 = *a2;
  v19 = a2[1];
  v20 = v27;
  do
  {
    v21 = 0;
    v22 = (uint64_t)&a2[2 * v16 + 2];
    do
    {
      if (v21 >= v19 || v17 >= v18)
        v24 = (double *)&CMatrixRow::operator[]const::zero;
      else
        v24 = (double *)v22;
      *v24 = v20[v21++] / v15;
      v22 += 8;
    }
    while (v21 != 3);
    ++v17;
    v20 += 3;
    v16 += v19;
  }
  while (v17 != 3);
}

uint64_t CMatrix::isNearIdentity(CMatrix *this, double a2)
{
  unint64_t v2;
  unsigned int v3;
  unint64_t v4;
  BOOL v5;
  uint64_t i;
  double v7;
  char v8;

  v2 = *(unsigned int *)this;
  if ((_DWORD)v2 == *((_DWORD *)this + 1))
  {
    if ((_DWORD)v2)
    {
      v3 = 0;
      v4 = 0;
      v5 = 0;
      while (2)
      {
        for (i = 0; i != v2; ++i)
        {
          if (v4 == i)
            v7 = *((double *)this + (v2 * v4) + v4 + 1) + -1.0;
          else
            v7 = *((double *)this + v3 + i + 1);
          if (fabs(v7) >= a2)
          {
            v8 = v5;
            return v8 & 1;
          }
        }
        ++v4;
        v3 += v2;
        v8 = 1;
        v5 = v4 >= v2;
        if (v4 != v2)
          continue;
        break;
      }
    }
    else
    {
      v8 = 1;
    }
  }
  else
  {
    v8 = 0;
  }
  return v8 & 1;
}

uint64_t mtlutl_ComputeThreadGroupParameters(uint64_t result, unsigned int a2, _DWORD *a3, _DWORD *a4, unsigned int a5, unsigned int a6)
{
  int v6;
  unsigned int v7;
  char v8;
  char v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  char v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;
  int v19;
  unsigned int i;
  unsigned int v24;

  if (((a5 | result | a2) & 1) != 0)
  {
    v6 = 1;
  }
  else
  {
    v6 = 1;
    v7 = result;
    do
    {
      v8 = a5;
      a5 >>= 1;
      result = v7 >> 1;
      v9 = a2;
      a2 >>= 1;
      v6 *= 2;
      if ((v8 & 2) != 0)
        break;
      if ((v7 & 2) != 0)
        break;
      v7 >>= 1;
    }
    while ((v9 & 2) == 0);
  }
  if (((a6 | result) & 1) != 0)
  {
    v10 = 1;
  }
  else
  {
    v10 = 1;
    v11 = a6;
    v12 = result;
    do
    {
      a6 = v11 >> 1;
      result = v12 >> 1;
      v10 *= 2;
      v13 = v11 | v12;
      v11 >>= 1;
      v12 >>= 1;
    }
    while ((v13 & 2) == 0);
  }
  if (a2 >= result)
    v14 = result;
  else
    v14 = a2;
  if (v14)
  {
    if (v14 + 1 > 2)
      v15 = v14 + 1;
    else
      v15 = 2;
    v16 = 1;
    v17 = 1;
    v18 = 1;
    do
    {
      if (!(a5 % v16))
      {
        v19 = 1;
        for (i = a6; ; i /= 7u)
        {
          while (1)
          {
            while (1)
            {
              while ((i & 1) == 0 && 2 * v16 * v19 <= result)
              {
                i >>= 1;
                v19 *= 2;
              }
              if (i != 3 * (i / 3) || 3 * v16 * v19 > result)
                break;
              v19 *= 3;
              i /= 3u;
            }
            if (i != 5 * (i / 5) || 5 * v16 * v19 > result)
              break;
            v19 *= 5;
            i /= 5u;
          }
          if (i % 7 || 7 * v16 * v19 > result)
            break;
          v19 *= 7;
        }
        v24 = v17 * v18;
        if (v19 * v16 >= v17 * v18)
          v18 = v16;
        if (v19 * v16 >= v24)
          v17 = v19;
      }
      ++v16;
    }
    while (v16 != v15);
  }
  else
  {
    v18 = 1;
    v17 = 1;
  }
  *a3 = v18 * v6;
  *a4 = v17 * v10;
  return result;
}

CIImage *CI::Perspective::gradDirImage(CI::Perspective *this, CIImage *a2)
{
  CIColorKernel *v3;
  double v4;
  double v5;
  double v6;
  double v7;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x1E0C80C00];
  v3 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_gradientDirection);
  -[CI::Perspective extent](this, "extent");
  v9[0] = this;
  return -[CIColorKernel applyWithExtent:arguments:](v3, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v9, 1), v4, v5, v6, v7);
}

CIImage *CI::Perspective::gradMagImage(CI::Perspective *this, CIImage *a2)
{
  CIColorKernel *v3;
  double v4;
  double v5;
  double v6;
  double v7;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x1E0C80C00];
  v3 = +[CIKernel kernelWithInternalRepresentation:](CIColorKernel, "kernelWithInternalRepresentation:", &CI::_gradientMagnitude);
  -[CI::Perspective extent](this, "extent");
  v9[0] = this;
  return -[CIColorKernel applyWithExtent:arguments:](v3, "applyWithExtent:arguments:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v9, 1), v4, v5, v6, v7);
}

BOOL CI::Perspective::CIImageToFile(CI::Perspective *this, CIImage *a2, NSString *a3, CGRect a4)
{
  double height;
  double width;
  double y;
  double x;
  unsigned __int8 v10;
  CIContext *v11;
  CGRect v13;

  height = a4.size.height;
  width = a4.size.width;
  y = a4.origin.y;
  x = a4.origin.x;
  if ((v10 & 1) == 0
  {
    CI::Perspective::CIImageToFile(CIImage *,NSString *,CGRect)::colorspace = (uint64_t)CGColorSpaceCreateDeviceRGB();
  }
  v13.origin.x = x;
  v13.origin.y = y;
  v13.size.width = width;
  v13.size.height = height;
  if (!CGRectIsNull(v13))
    this = (CI::Perspective *)-[CI::Perspective imageByCroppingToRect:](this, "imageByCroppingToRect:", x, y, width, height);
  v11 = +[CIContext context](CIContext, "context");
  return -[NSData writeToFile:atomically:](-[CIContext PNGRepresentationOfImage:format:colorSpace:options:](v11, "PNGRepresentationOfImage:format:colorSpace:options:", this, 2056, CI::Perspective::CIImageToFile(CIImage *,NSString *,CGRect)::colorspace, MEMORY[0x1E0C9AA70]), "writeToFile:atomically:", a2, 1);
}

void sub_1923B30B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double cikernel::_gradientMagnitude(float32x4_t a1)
{
  float32x2_t v1;
  double result;

  v1 = (float32x2_t)vmulq_f32(a1, a1).u64[0];
  v1.f32[0] = sqrtf(vaddv_f32(v1));
  *(_QWORD *)&result = vdupq_lane_s32((int32x2_t)v1, 0).u64[0];
  return result;
}

__n64 CI::Perspective::getRotation(CI::Perspective *this, float a2, float a3, float a4)
{
  __float2 v6;
  __float2 v7;
  float32x4_t v8;
  __float2 v9;
  int32x4_t v11;
  int8x16_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int32x4_t v16;
  int8x16_t v17;
  float32x4_t v19;
  float v27;
  __n64 result;
  float32x4_t v36;
  float32x4_t v37;

  v6 = __sincosf_stret(a2 * 0.5);
  v37 = vmulq_n_f32((float32x4_t)xmmword_192496870, v6.__sinval);
  v7 = __sincosf_stret(a3 * 0.5);
  v8 = vmulq_n_f32((float32x4_t)xmmword_192496880, v7.__sinval);
  v8.i32[3] = LODWORD(v7.__cosval);
  v36 = v8;
  v9 = __sincosf_stret(a4 * 0.5);
  _Q0 = vmulq_n_f32((float32x4_t)xmmword_192496890, v9.__sinval);
  _Q0.i32[3] = LODWORD(v9.__cosval);
  v11 = (int32x4_t)vnegq_f32(v36);
  v12 = (int8x16_t)vtrn2q_s32((int32x4_t)v36, vtrn1q_s32((int32x4_t)v36, v11));
  v13 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)v36, (int8x16_t)v11, 8uLL), *(float32x2_t *)v37.f32, 1), (float32x4_t)vextq_s8(v12, v12, 8uLL), v37.f32[0]);
  v14 = (float32x4_t)vrev64q_s32((int32x4_t)v36);
  v14.i32[0] = v11.i32[1];
  v14.i32[3] = v11.i32[2];
  v15 = vaddq_f32(vmlaq_laneq_f32(vmulq_n_f32(v36, v6.__cosval), v14, v37, 2), v13);
  v16 = (int32x4_t)vnegq_f32(_Q0);
  v17 = (int8x16_t)vtrn2q_s32((int32x4_t)_Q0, vtrn1q_s32((int32x4_t)_Q0, v16));
  _Q4 = vmlaq_n_f32(vmulq_lane_f32((float32x4_t)vextq_s8((int8x16_t)_Q0, (int8x16_t)v16, 8uLL), *(float32x2_t *)v15.f32, 1), (float32x4_t)vextq_s8(v17, v17, 8uLL), v15.f32[0]);
  v19 = (float32x4_t)vrev64q_s32((int32x4_t)_Q0);
  v19.i32[0] = v16.i32[1];
  v19.i32[3] = v16.i32[2];
  _Q3 = vaddq_f32(_Q4, vmlaq_laneq_f32(vmulq_laneq_f32(_Q0, v15, 3), v19, v15, 2));
  _Q4.i32[0] = _Q3.i32[1];
  _S5 = _Q3.i32[2];
  __asm { FMLS            S0, S5, V3.S[2] }
  _S7 = _Q3.i32[3];
  __asm { FMLA            S0, S7, V3.S[3] }
  v27 = vmlas_n_f32(-(float)(_Q3.f32[2] * _Q3.f32[3]), _Q3.f32[1], _Q3.f32[0]);
  __asm
  {
    FMLA            S6, S4, V3.S[1]
    FMLA            S6, S7, V3.S[3]
    FMLS            S6, S3, V3.S[0]
    FMLA            S18, S5, V3.S[1]
    FMLA            S7, S5, V3.S[2]
    FMLS            S7, S3, V3.S[0]
  }
  result.n64_f32[1] = v27 + v27;
  __asm { FMLS            S7, S4, V3.S[1] }
  return result;
}

uint64_t CI::Perspective::pointInBounds(float32x2_t *a1, float32x2_t *a2)
{
  uint32x2_t v2;

  v2 = (uint32x2_t)vand_s8((int8x8_t)vcgt_f32(vadd_f32(*a2, (float32x2_t)*(_OWORD *)&vextq_s8(*(int8x16_t *)a2->f32, *(int8x16_t *)a2->f32, 8uLL)), *a1), (int8x8_t)vcgt_f32(*a1, *a2));
  return vpmin_u32(v2, v2).u32[0] >> 31;
}

float32x2_t CI::Perspective::bbox(float32x2_t *a1)
{
  return vminnm_f32(vminnm_f32(vminnm_f32(*a1, a1[1]), a1[2]), a1[3]);
}

BOOL CI::Perspective::intersect(int32x2_t *a1, int32x2_t *a2, float32x2_t *a3)
{
  float32x2_t v3;
  float32x2_t v4;
  int v5;
  float32x2_t v6;
  float v13;
  double v14;
  float32x2_t v15;

  v3.i32[0] = (__int32)*a1;
  v3.i32[1] = HIDWORD(*(_QWORD *)&a2[1]);
  v4.i32[0] = (__int32)a1[1];
  v4.i32[1] = HIDWORD(*(unint64_t *)a2);
  v5 = (int)*a2;
  _D6.i32[1] = HIDWORD(*(_QWORD *)&a1[1]);
  v6 = vsub_f32(v3, v4);
  v4.i32[0] = (__int32)a2[1];
  v4.i32[1] = HIDWORD(*(unint64_t *)a1);
  _D16 = vsub_f32(_D6, v4);
  __asm { FMLA            S6, S16, V16.S[1] }
  if (_D6.f32[0] >= 0.0)
    v13 = _D6.f32[0];
  else
    v13 = -(float)((float)((float)-v6.f32[1] * v6.f32[0]) + (float)(_D16.f32[1] * _D16.f32[0]));
  v14 = v13;
  if (v14 >= 0.01)
  {
    v15 = vmla_f32(vmul_f32((float32x2_t)vzip2_s32(a2[1], a1[1]), vneg_f32((float32x2_t)vzip1_s32(*a2, *a1))), (float32x2_t)vzip2_s32(*a2, *a1), (float32x2_t)vzip1_s32(a2[1], a1[1]));
    *a3 = vdiv_f32(vmla_f32(vmul_f32((float32x2_t)vrev64_s32((int32x2_t)v15), vneg_f32(_D16)), v15, v6), (float32x2_t)vdup_lane_s32((int32x2_t)_D6, 0));
  }
  return v14 >= 0.01;
}

BOOL CI::Perspective::intersect(float *a1, _DWORD *a2, double a3, double a4, __n128 a5)
{
  float32x2_t v10;
  float v11;
  float v12;
  float v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  __int32 *v17;
  float32x2_t v18;
  float32x2_t v19;
  float v20;
  __n128 v22;

  __asm { FMOV            V3.2S, #1.0 }
  v10 = vdiv_f32(_D3, *(float32x2_t *)&a4);
  if (*(float *)&a4 == 0.0)
  {
    v14 = INFINITY;
    v13 = -INFINITY;
  }
  else
  {
    v11 = a5.n128_f32[2];
    if (*(float *)&a4 <= 0.0)
      v12 = a5.n128_f32[2];
    else
      v12 = a5.n128_f32[0];
    v13 = (float)(v12 - *(float *)&a3) * v10.f32[0];
    if (*(float *)&a4 <= 0.0)
      v11 = a5.n128_f32[0];
    v14 = (float)(v11 - *(float *)&a3) * v10.f32[0];
  }
  if (*((float *)&a4 + 1) == 0.0)
  {
    v19 = (float32x2_t)0x7F800000FF800000;
  }
  else
  {
    v15 = 3;
    if (*((float *)&a4 + 1) > 0.0)
      v16 = 1;
    else
      v16 = 3;
    v17 = (__int32 *)((unint64_t)&v22 | (4 * v16));
    if (*((float *)&a4 + 1) <= 0.0)
      v15 = 1;
    v22 = a5;
    v18.i32[0] = *v17;
    v18.i32[1] = *(_DWORD *)((unint64_t)&v22 | (4 * v15));
    v19 = vmul_lane_f32(vsub_f32(v18, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 1)), v10, 1);
  }
  if (v13 <= v19.f32[0])
    v20 = v19.f32[0];
  else
    v20 = v13;
  *a1 = v20;
  v19.i32[0] = v19.i32[1];
  if (v14 < v19.f32[1])
    v19.f32[0] = v14;
  *a2 = v19.i32[0];
  return v19.f32[0] >= *a1 && v19.f32[0] >= 0.0;
}

float CI::Perspective::keystoneV(double a1, double a2, double a3, double a4)
{
  float result;
  float v5;

  result = -atan2f(vmlas_n_f32((float)-(float)(*((float *)&a2 + 1) - *((float *)&a1 + 1))* vsub_f32(*(float32x2_t *)&a4, *(float32x2_t *)&a3).f32[0], *((float *)&a4 + 1) - *((float *)&a3 + 1), vsub_f32(*(float32x2_t *)&a2, *(float32x2_t *)&a1).f32[0]), (float)((float)(*((float *)&a2 + 1) - *((float *)&a1 + 1))* vmlas_n_f32((float)-*((float *)&a4 + 1) * *(float *)&a3, *((float *)&a3 + 1), *(float *)&a4))- (float)((float)(*((float *)&a4 + 1) - *((float *)&a3 + 1))* vmlas_n_f32((float)-*((float *)&a2 + 1) * *(float *)&a1, *((float *)&a1 + 1), *(float *)&a2)));
  if (result < -1.57079633)
  {
    v5 = result + 3.14159265;
    result = v5;
  }
  if (result > 1.57079633)
    return result + -3.14159265;
  return result;
}

float CI::Perspective::keystoneH(double a1, double a2, double a3, double a4)
{
  float v4;
  float v5;
  float result;
  float v7;

  v4 = vsub_f32(*(float32x2_t *)&a4, *(float32x2_t *)&a3).f32[0];
  v5 = vsub_f32(*(float32x2_t *)&a2, *(float32x2_t *)&a1).f32[0];
  result = -atan2f(vmlas_n_f32(-(float)(v5 * (float)(*((float *)&a4 + 1) - *((float *)&a3 + 1))), *((float *)&a2 + 1) - *((float *)&a1 + 1), v4), vmlas_n_f32(-(float)(v4* vmlas_n_f32(vmuls_lane_f32(-*(float *)&a1, *(float32x2_t *)&a2, 1), *((float *)&a1 + 1), *(float *)&a2)), vmlas_n_f32(vmuls_lane_f32(-*(float *)&a3, *(float32x2_t *)&a4, 1), *((float *)&a3 + 1), *(float *)&a4), v5));
  if (result < -1.57079633)
  {
    v7 = result + 3.14159265;
    result = v7;
  }
  if (result > 1.57079633)
    return result + -3.14159265;
  return result;
}

float CI::Perspective::horizonV(CI::Perspective *a1, double a2, double a3, double a4, double a5, float a6, float a7)
{
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  int32x4_t v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  float result;
  float v15;

  *(__n64 *)v7.f32 = CI::Perspective::getRotation(a1, a6, a7, 0.0);
  v10 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a2), v8, *(float32x2_t *)&a2, 1));
  v11 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a4), v8, *(float32x2_t *)&a4, 1));
  *(float32x2_t *)v10.i8 = vadd_f32(vdiv_f32(*(float32x2_t *)v10.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v10, 2)), vdiv_f32(*(float32x2_t *)v11.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v11, 2)));
  v12 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a3), v8, *(float32x2_t *)&a3, 1));
  v13 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a5), v8, *(float32x2_t *)&a5, 1));
  *(float32x2_t *)v8.f32 = vsub_f32(vmul_f32(*(float32x2_t *)v10.i8, (float32x2_t)0x3F0000003F000000), vmul_f32(vadd_f32(vdiv_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v12, 2)), vdiv_f32(*(float32x2_t *)v13.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2))), (float32x2_t)0x3F0000003F000000));
  result = atan2f(v8.f32[1], v8.f32[0]) + -1.57079633;
  if (result < -1.57079633)
  {
    v15 = result + 3.14159265;
    result = v15;
  }
  if (result > 1.57079633)
    return result + -3.14159265;
  return result;
}

float CI::Perspective::horizonH(CI::Perspective *a1, double a2, double a3, double a4, double a5, float a6, float a7)
{
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  int32x4_t v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  float result;
  float v15;

  *(__n64 *)v7.f32 = CI::Perspective::getRotation(a1, a6, a7, 0.0);
  v10 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a2), v8, *(float32x2_t *)&a2, 1));
  v11 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a4), v8, *(float32x2_t *)&a4, 1));
  *(float32x2_t *)v10.i8 = vadd_f32(vdiv_f32(*(float32x2_t *)v10.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v10, 2)), vdiv_f32(*(float32x2_t *)v11.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v11, 2)));
  v12 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a3), v8, *(float32x2_t *)&a3, 1));
  v13 = (int32x4_t)vaddq_f32(v9, vmlaq_lane_f32(vmulq_n_f32(v7, *(float *)&a5), v8, *(float32x2_t *)&a5, 1));
  *(float32x2_t *)v8.f32 = vsub_f32(vmul_f32(*(float32x2_t *)v10.i8, (float32x2_t)0x3F0000003F000000), vmul_f32(vadd_f32(vdiv_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v12, 2)), vdiv_f32(*(float32x2_t *)v13.i8, (float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v13, 2))), (float32x2_t)0x3F0000003F000000));
  result = atan2f(v8.f32[1], v8.f32[0]);
  if (result < -1.57079633)
  {
    v15 = result + 3.14159265;
    result = v15;
  }
  if (result > 1.57079633)
    return result + -3.14159265;
  return result;
}

uint64_t PixelBufferApplyPlaneBlock(CVPixelBufferRef pixelBuffer, uint64_t a2)
{
  uint64_t result;
  size_t PlaneCount;
  size_t i;
  void *BaseAddressOfPlane;
  size_t BytesPerRowOfPlane;
  size_t WidthOfPlane;
  size_t HeightOfPlane;
  void *BaseAddress;
  size_t BytesPerRow;
  size_t Width;
  size_t Height;

  result = 4294960635;
  if (pixelBuffer)
  {
    if (a2)
    {
      PlaneCount = CVPixelBufferGetPlaneCount(pixelBuffer);
      result = CVPixelBufferLockBaseAddress(pixelBuffer, 0);
      if (!(_DWORD)result)
      {
        if (PlaneCount)
        {
          if ((PlaneCount & 0xFFFFFFFFFFFFFFFELL) == 2)
          {
            for (i = 0; i != PlaneCount; ++i)
            {
              BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, i);
              BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, i);
              WidthOfPlane = CVPixelBufferGetWidthOfPlane(pixelBuffer, i);
              HeightOfPlane = CVPixelBufferGetHeightOfPlane(pixelBuffer, i);
              if (BaseAddressOfPlane && BytesPerRowOfPlane && WidthOfPlane)
              {
                if (HeightOfPlane)
                  (*(void (**)(uint64_t, void *, size_t, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddressOfPlane, i, WidthOfPlane, HeightOfPlane, BytesPerRowOfPlane);
              }
            }
          }
        }
        else
        {
          BaseAddress = CVPixelBufferGetBaseAddress(pixelBuffer);
          BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
          Width = CVPixelBufferGetWidth(pixelBuffer);
          Height = CVPixelBufferGetHeight(pixelBuffer);
          if (BaseAddress && BytesPerRow && Width && Height)
            (*(void (**)(uint64_t, void *, _QWORD, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddress, 0, Width, Height, BytesPerRow);
        }
        CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
        return 0;
      }
    }
  }
  return result;
}

uint64_t PixelBufferApplyOnePlaneBlock(CVPixelBufferRef pixelBuffer, size_t a2, uint64_t a3)
{
  uint64_t result;
  size_t PlaneCount;
  size_t v8;
  BOOL v9;
  BOOL v10;
  size_t v11;
  void *BaseAddressOfPlane;
  size_t BytesPerRowOfPlane;
  size_t WidthOfPlane;
  size_t HeightOfPlane;
  void *BaseAddress;
  size_t BytesPerRow;
  size_t Width;
  size_t Height;

  result = 4294960635;
  if (pixelBuffer && a3)
  {
    PlaneCount = CVPixelBufferGetPlaneCount(pixelBuffer);
    v8 = PlaneCount;
    v9 = a2 && PlaneCount == 0;
    v10 = v9;
    v11 = PlaneCount - 1;
    result = 4294960635;
    if (v11 >= a2 && !v10)
    {
      result = CVPixelBufferLockBaseAddress(pixelBuffer, 0);
      if (!(_DWORD)result)
      {
        if (v8)
        {
          if ((v8 & 0xFFFFFFFFFFFFFFFELL) == 2)
          {
            BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, a2);
            BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, a2);
            WidthOfPlane = CVPixelBufferGetWidthOfPlane(pixelBuffer, a2);
            HeightOfPlane = CVPixelBufferGetHeightOfPlane(pixelBuffer, a2);
            if (BaseAddressOfPlane)
            {
              if (BytesPerRowOfPlane && WidthOfPlane)
              {
                if (HeightOfPlane)
                  (*(void (**)(uint64_t, void *, size_t, size_t, size_t, size_t))(a3 + 16))(a3, BaseAddressOfPlane, a2, WidthOfPlane, HeightOfPlane, BytesPerRowOfPlane);
              }
            }
          }
        }
        else
        {
          BaseAddress = CVPixelBufferGetBaseAddress(pixelBuffer);
          BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
          Width = CVPixelBufferGetWidth(pixelBuffer);
          Height = CVPixelBufferGetHeight(pixelBuffer);
          if (BaseAddress && BytesPerRow && Width && Height)
            (*(void (**)(uint64_t, void *, _QWORD, size_t, size_t, size_t))(a3 + 16))(a3, BaseAddress, 0, Width, Height, BytesPerRow);
        }
        CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
        return 0;
      }
    }
  }
  return result;
}

uint64_t PixelBufferApplyPlaneReadOnlyBlock(__CVBuffer *a1, uint64_t a2)
{
  size_t PlaneCount;
  uint64_t v5;
  size_t i;
  void *BaseAddressOfPlane;
  size_t BytesPerRowOfPlane;
  size_t WidthOfPlane;
  size_t HeightOfPlane;
  void *BaseAddress;
  size_t BytesPerRow;
  size_t Width;
  size_t Height;

  PlaneCount = CVPixelBufferGetPlaneCount(a1);
  v5 = CVPixelBufferLockBaseAddress(a1, 1uLL);
  if (!(_DWORD)v5)
  {
    if (PlaneCount)
    {
      if ((PlaneCount & 0xFFFFFFFFFFFFFFFELL) == 2)
      {
        for (i = 0; i != PlaneCount; ++i)
        {
          BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(a1, i);
          BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a1, i);
          WidthOfPlane = CVPixelBufferGetWidthOfPlane(a1, i);
          HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, i);
          if (BaseAddressOfPlane && BytesPerRowOfPlane && WidthOfPlane && HeightOfPlane)
            (*(void (**)(uint64_t, void *, size_t, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddressOfPlane, i, WidthOfPlane, HeightOfPlane, BytesPerRowOfPlane);
        }
      }
    }
    else
    {
      BaseAddress = CVPixelBufferGetBaseAddress(a1);
      BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
      Width = CVPixelBufferGetWidth(a1);
      Height = CVPixelBufferGetHeight(a1);
      if (BaseAddress && BytesPerRow && Width && Height)
        (*(void (**)(uint64_t, void *, _QWORD, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddress, 0, Width, Height, BytesPerRow);
    }
    CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  }
  return v5;
}

uint64_t PixelBufferApplyOnePlaneReadOnlyBlock(__CVBuffer *a1, size_t a2, uint64_t a3)
{
  size_t PlaneCount;
  size_t v7;
  BOOL v8;
  char v9;
  size_t v10;
  uint64_t result;
  void *BaseAddressOfPlane;
  size_t BytesPerRowOfPlane;
  size_t WidthOfPlane;
  size_t HeightOfPlane;
  void *BaseAddress;
  size_t BytesPerRow;
  size_t Width;
  size_t Height;

  PlaneCount = CVPixelBufferGetPlaneCount(a1);
  v7 = PlaneCount;
  if (a2)
    v8 = PlaneCount == 0;
  else
    v8 = 0;
  v9 = v8;
  v10 = PlaneCount - 1;
  result = 4294960635;
  if (v10 >= a2 && (v9 & 1) == 0)
  {
    result = CVPixelBufferLockBaseAddress(a1, 1uLL);
    if (!(_DWORD)result)
    {
      if (v7)
      {
        if ((v7 & 0xFFFFFFFFFFFFFFFELL) == 2)
        {
          BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(a1, a2);
          BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a1, a2);
          WidthOfPlane = CVPixelBufferGetWidthOfPlane(a1, a2);
          HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, a2);
          if (BaseAddressOfPlane)
          {
            if (BytesPerRowOfPlane && WidthOfPlane)
            {
              if (HeightOfPlane)
                (*(void (**)(uint64_t, void *, size_t, size_t, size_t, size_t))(a3 + 16))(a3, BaseAddressOfPlane, a2, WidthOfPlane, HeightOfPlane, BytesPerRowOfPlane);
            }
          }
        }
      }
      else
      {
        BaseAddress = CVPixelBufferGetBaseAddress(a1);
        BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
        Width = CVPixelBufferGetWidth(a1);
        Height = CVPixelBufferGetHeight(a1);
        if (BaseAddress && BytesPerRow && Width && Height)
          (*(void (**)(uint64_t, void *, _QWORD, size_t, size_t, size_t))(a3 + 16))(a3, BaseAddress, 0, Width, Height, BytesPerRow);
      }
      CVPixelBufferUnlockBaseAddress(a1, 1uLL);
      return 0;
    }
  }
  return result;
}

uint64_t GetPixelBufferYCCMatrix(__CVBuffer *a1)
{
  uint64_t result;
  const void *v2;

  result = (uint64_t)CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E0CA8EE8], 0);
  if (result)
  {
    v2 = (const void *)result;
    if (CFEqual((CFTypeRef)result, (CFTypeRef)*MEMORY[0x1E0CA8F18]))
    {
      return 709;
    }
    else if (CFEqual(v2, (CFTypeRef)*MEMORY[0x1E0CA8F10]))
    {
      return 601;
    }
    else if (CFEqual(v2, (CFTypeRef)*MEMORY[0x1E0CA8F30]))
    {
      return 240;
    }
    else if (CFEqual(v2, (CFTypeRef)*MEMORY[0x1E0CA8F00]))
    {
      return 2020;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CGColorSpaceRef CVImageBufferCopyColorSpace(__CVBuffer *a1)
{
  signed int PixelFormatType;
  int v3;
  int v4;
  int v5;
  CGColorSpace *Attachment;
  CGColorSpaceRef ICCBased;
  const __CFData *v9;
  const __CFData *v10;
  size_t Length;
  CGDataProvider *v12;
  uint8x8_t v13;
  size_t v14;
  CFTypeRef v15;
  CFStringRef *v16;
  const __CFDictionary *Attachments;
  const __CFNumber *v18;
  CFTypeRef v19;
  CFTypeRef v20;
  CFTypeRef v21;
  UInt8 buffer[4];
  CFRange v23;

  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  v3 = 1;
  if (PixelFormatType > 1279340853)
  {
    if (PixelFormatType > 1717856626)
    {
      if (PixelFormatType == 1717856627 || PixelFormatType == 1751410032)
        goto LABEL_17;
      v4 = 1751411059;
    }
    else
    {
      if (PixelFormatType == 1279340854 || PixelFormatType == 1279342648)
        goto LABEL_17;
      v4 = 1717855600;
    }
  }
  else
  {
    if ((PixelFormatType - 1278226488) <= 0x30
      && ((1 << (PixelFormatType - 56)) & 0x1400000000001) != 0
      || (PixelFormatType - 1279340600) <= 0x30
      && ((1 << (PixelFormatType - 56)) & 0x1400000000001) != 0)
    {
      goto LABEL_17;
    }
    v4 = 1278226742;
  }
  if (PixelFormatType != v4)
    v3 = 0;
LABEL_17:
  if (PixelFormatType <= 1751410031)
  {
    if (PixelFormatType != 1717855600)
    {
      v5 = 1717856627;
      goto LABEL_22;
    }
    return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D948]);
  }
  if (PixelFormatType == 1751411059)
    return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D948]);
  v5 = 1751410032;
LABEL_22:
  if (PixelFormatType == v5)
    return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D948]);
  if (dyld_program_sdk_at_least())
  {
    Attachment = (CGColorSpace *)CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E0CA8CD8], 0);
    if (Attachment)
    {
      ICCBased = Attachment;
      CGColorSpaceRetain(Attachment);
      return ICCBased;
    }
    v9 = (const __CFData *)CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E0CA8E40], 0);
    if (v9)
    {
      v10 = v9;
      Length = CFDataGetLength(v9);
      v12 = CGDataProviderCreateWithData(0, v10, Length, 0);
      *(_DWORD *)buffer = 0;
      v23.location = 16;
      v23.length = 4;
      CFDataGetBytes(v10, v23, buffer);
      v13.i32[0] = *(_DWORD *)buffer;
      v14 = vmovn_s16((int16x8_t)vmovl_u8(v13)).u32[0] == 1497453127 ? 1 : 3;
      ICCBased = CGColorSpaceCreateICCBased(v14, 0, v12, 0);
      CFRelease(v12);
      if (ICCBased)
        return ICCBased;
    }
  }
  if (v3)
  {
    v15 = CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E0CA8E98], 0);
    if (v15)
    {
      if (CFEqual(v15, (CFTypeRef)*MEMORY[0x1E0CA8EB8]))
      {
        ICCBased = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D9F0]);
        if (ICCBased)
          return ICCBased;
      }
    }
    v16 = (CFStringRef *)MEMORY[0x1E0C9D978];
  }
  else
  {
    Attachments = CVBufferGetAttachments(a1, kCVAttachmentMode_ShouldPropagate);
    if (Attachments)
    {
      ICCBased = CVImageBufferCreateColorSpaceFromAttachments(Attachments);
      if (ICCBased)
        return ICCBased;
    }
    v18 = (const __CFNumber *)CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E0CA8DF8], 0);
    v19 = CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E0CA8EE8], 0);
    v20 = CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E0CA8D68], 0);
    v21 = CVBufferGetAttachment(a1, (CFStringRef)*MEMORY[0x1E0CA8E98], 0);
    ICCBased = CreateColorSpaceFromInfo(v20, v21, v19, v18);
    if (ICCBased)
      return ICCBased;
    v16 = (CFStringRef *)MEMORY[0x1E0C9DA10];
  }
  return CGColorSpaceCreateWithName(*v16);
}

CFDictionaryRef CreateColorAttributesForColorSpace()
{
  CGColorSpace *v0;
  int v1;
  CFDictionaryRef v2;
  void *v3;
  unsigned int v4;
  void *v5;
  float *v6;
  float v7;
  CFNumberRef v8;
  uint64_t v10;
  float *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  void *values[3];
  void *keys[4];

  keys[3] = *(void **)MEMORY[0x1E0C80C00];
  v18 = 0;
  v19 = &v18;
  v20 = 0x2000000000;
  v21 = 0;
  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = 0;
  v10 = 0;
  v11 = (float *)&v10;
  v12 = 0x2000000000;
  v13 = 0;
  v0 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D998]);
  v1 = CGColorConversionInfoIterateColorSpaceFunctionsWithCallbacks();
  CGColorSpaceRelease(v0);
  v2 = 0;
  if (v1)
  {
    memset(keys, 0, 24);
    memset(values, 0, sizeof(values));
    v3 = (void *)v19[3];
    if (v3)
    {
      keys[0] = *(void **)MEMORY[0x1E0CA8D68];
      values[0] = v3;
      v4 = 1;
    }
    else
    {
      v4 = 0;
    }
    v5 = (void *)v15[3];
    if (v5)
    {
      keys[v4] = (void *)*MEMORY[0x1E0CA8E98];
      values[v4++] = v5;
    }
    v6 = v11 + 6;
    v7 = v11[6];
    if (v7 == 0.0)
    {
      v2 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, v4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    }
    else
    {
      *v6 = roundf(v7 * 10000.0) / 10000.0;
      v8 = CFNumberCreate(0, kCFNumberFloatType, v6);
      keys[v4] = (void *)*MEMORY[0x1E0CA8DF8];
      values[v4] = v8;
      v2 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, v4 + 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v8)
        CFRelease(v8);
    }
  }
  _Block_object_dispose(&v10, 8);
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);
  return v2;
}

BOOL near_matrix(float *a1, float *a2)
{
  return vabdd_f64(*a1, *a2) < 0.0001
      && vabdd_f64(a1[1], a2[1]) < 0.0001
      && vabdd_f64(a1[2], a2[2]) < 0.0001
      && vabdd_f64(a1[3], a2[3]) < 0.0001
      && vabdd_f64(a1[4], a2[4]) < 0.0001
      && vabdd_f64(a1[5], a2[5]) < 0.0001
      && vabdd_f64(a1[6], a2[6]) < 0.0001
      && vabdd_f64(a1[7], a2[7]) < 0.0001
      && vabdd_f64(a1[8], a2[8]) < 0.0001
      && vabdd_f64(a1[9], a2[9]) < 0.0001
      && vabdd_f64(a1[10], a2[10]) < 0.0001
      && vabdd_f64(a1[11], a2[11]) < 0.0001;
}

uint64_t Projections_projectionRows_planar8UtoF(uint64_t a1, int a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  char v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v14;
  uint64_t v15;
  void (*v16)();
  void *v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v19 = a1;
  v20 = a2 >> 1;
  v21 = a3;
  v22 = a4;
  v23 = a5;
  v24 = a6;
  v26 = a1 + (a2 >> 1);
  v27 = a2 >> 1;
  v28 = a3;
  v29 = a4;
  v30 = a5;
  v31 = a6 + 4 * (a2 >> 1);
  v6 = 1;
  v7 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E0C80D50], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v8 = dispatch_queue_create("projectionRows_planar8UtoF", v7);
  v9 = MEMORY[0x1E0C809B0];
  v14 = MEMORY[0x1E0C809B0];
  v15 = 0x40000000;
  v16 = __Projections_projectionRows_planar8UtoF_block_invoke;
  v17 = &__block_descriptor_tmp_3;
  v18 = &v19;
  dispatch_async(v8, &v14);
  v14 = v9;
  v15 = 0x40000000;
  v16 = __Projections_projectionRows_planar8UtoF_block_invoke;
  v17 = &__block_descriptor_tmp_3;
  v18 = &v26;
  dispatch_async(v8, &v14);
  dispatch_barrier_sync(v8, &__block_literal_global_80);
  v10 = 0;
  do
  {
    v11 = *((unsigned int *)&v25 + 12 * v10);
    if ((_DWORD)v11)
      break;
    v12 = v6;
    v6 = 0;
    v10 = 1;
  }
  while ((v12 & 1) != 0);
  dispatch_release(v8);
  return v11;
}

uint64_t Projections_projectionCols_planar8UtoF(uint64_t a1, int a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  char v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)();
  void *v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v19 = a1;
  v20 = a2;
  v21 = a3 >> 1;
  v22 = a4;
  v23 = a5;
  v24 = a6;
  v26 = a1 + ((uint64_t)a3 >> 1) * a4;
  v27 = a2;
  v28 = a3 >> 1;
  v29 = a4;
  v30 = a5;
  v31 = a6 + 4 * (a3 >> 1);
  v6 = 1;
  v7 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E0C80D50], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v8 = dispatch_queue_create("projectionCols_planar8UtoF", v7);
  v9 = MEMORY[0x1E0C809B0];
  v14 = MEMORY[0x1E0C809B0];
  v15 = 0x40000000;
  v16 = __Projections_projectionCols_planar8UtoF_block_invoke;
  v17 = &__block_descriptor_tmp_4_0;
  v18 = &v19;
  dispatch_async(v8, &v14);
  v14 = v9;
  v15 = 0x40000000;
  v16 = __Projections_projectionCols_planar8UtoF_block_invoke;
  v17 = &__block_descriptor_tmp_4_0;
  v18 = &v26;
  dispatch_async(v8, &v14);
  dispatch_barrier_sync(v8, &__block_literal_global_6);
  v10 = 0;
  do
  {
    v11 = *((unsigned int *)&v25 + 12 * v10);
    if ((_DWORD)v11)
      break;
    v12 = v6;
    v6 = 0;
    v10 = 1;
  }
  while ((v12 & 1) != 0);
  dispatch_release(v8);
  return v11;
}

uint64_t Projections_projectionRowsCols_planar8UtoF()
{
  uint64_t v0;
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float *v7;
  float *v8;
  float *v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *StatusDescription;
  uint64_t v20;
  char *v21;
  char *v22;
  uint32x4_t __A;

  v0 = MEMORY[0x1E0C80A78]();
  v8 = v7;
  v9 = (float *)v4;
  v10 = v3;
  v11 = v2;
  v12 = v1;
  v13 = v0;
  STACK[0x6648] = *MEMORY[0x1E0C80C00];
  if (v2 & 1 | v1 & 0x1F || v3 & 0x1F | v0 & 0xF)
  {
    v15 = Projections_projectionCols_planar8UtoF(v0, v1, v2, v3, 1, v4);
    if ((v15 & 0x80000000) != 0)
    {
      v17 = v15;
      StatusDescription = Projections_getStatusDescription(v15);
      syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v17, StatusDescription, "Projections_status Projections_projectionRowsCols_planar8UtoF(const uint8_t *, int, int, size_t, float *, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/Projections_Core.c", 471);
      return v17;
    }
    else
    {
      v16 = Projections_projectionRows_planar8UtoF(v13, v12, v11, v10, 1, (uint64_t)v8);
      v14 = v16;
      if ((v16 & 0x80000000) != 0)
      {
        v22 = Projections_getStatusDescription(v16);
        syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v14, v22, "Projections_status Projections_projectionRowsCols_planar8UtoF(const uint8_t *, int, int, size_t, float *, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/Projections_Core.c", 472);
      }
    }
  }
  else if (PixelSumASM((uint8x16_t *)v0, v1, v2, v3, &STACK[0x3340], &__A, v5, v6, v20))
  {
    v14 = 0xFFFFFFFFLL;
    v21 = Projections_getStatusDescription(-1);
    syslog(3, "Projections error %d:%s in %s @ %s:%d\n", -1, v21, "Projections_status Projections_projectionRowsCols_planar8UtoF(const uint8_t *, int, int, size_t, float *, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/Projections_Core.c", 463);
  }
  else
  {
    vDSP_vflt32((const int *)&STACK[0x3340], 1, v9, 1, v11);
    vDSP_vflt32(__A.i32, 1, v8, 1, v12);
    return 0;
  }
  return v14;
}

uint64_t Projections_smoothProjection(uint64_t a1, int a2, int a3, uint64_t a4)
{
  int v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  float v10;
  float v11;

  v4 = -a3;
  if (-a3 < a2)
  {
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = v4 - a3;
    do
    {
      v9 = v8 + v5;
      if (v8 + (_DWORD)v5 < 0 || v5 >= a2)
      {
        if (v5 < a2)
        {
          v7 = (int)(float)(*(float *)(a1 + 4 * v5) + (float)v7);
          ++v6;
        }
        v11 = (float)v7;
        if (((v4 + v5) & 0x8000000000000000) == 0)
          *(float *)(a4 + 4 * (v5 - a3)) = v11 / (float)v6;
        if ((v9 & 0x80000000) == 0)
        {
          v7 = (int)(float)(v11 - *(float *)(a1 + 4 * v9));
          --v6;
        }
      }
      else
      {
        v10 = (float)(int)(float)(*(float *)(a1 + 4 * v5) + (float)v7);
        *(float *)(a4 - 4 * a3 + 4 * v5) = v10 / (float)(v6 + 1);
        v7 = (int)(float)(v10 - *(float *)(a1 + 4 * v9));
      }
      ++v5;
    }
    while (a3 + a2 != v5);
  }
  return 0;
}

uint64_t Projections_computeProjectionDerivative(const float *__B, int a2, float *a3)
{
  uint64_t v3;
  char *StatusDescription;
  vDSP_Length v5;
  float v6;
  float __C;

  if (a2 > 1)
  {
    if (a2 == 3)
    {
      v3 = 0;
      *a3 = __B[1] - *__B;
      a3[1] = -(float)(*__B - (float)(__B[2] * 0.5));
      a3[2] = __B[2] - __B[1];
    }
    else
    {
      v5 = (a2 - 2);
      if (a2 == 2)
      {
        v3 = 0;
        v6 = __B[1] - *__B;
        *a3 = v6;
        a3[1] = v6;
      }
      else
      {
        *a3 = __B[1] - *__B;
        a3[a2 - 1] = __B[a2 - 1] - __B[v5];
        __C = 0.5;
        vDSP_vsbsm(__B + 2, 1, __B, 1, &__C, a3 + 1, 1, v5);
        return 0;
      }
    }
  }
  else
  {
    v3 = 0xFFFFFFFFLL;
    StatusDescription = Projections_getStatusDescription(-1);
    syslog(3, "Projections error %d:%s in %s @ %s:%d\n", -1, StatusDescription, "Projections_status Projections_computeProjectionDerivative(const float *, int, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/Projections_Core.c", 528);
  }
  return v3;
}

char *Projections_getStatusDescription(int a1)
{
  return Projections_statusDescription[a1 + 4];
}

float32x2_t Projections_fastSqrtf(double a1)
{
  float32x2_t v1;
  int8x8_t v2;
  int8x8_t v3;
  float32x2_t v4;
  int8x8_t v5;

  *(float *)&a1 = *(float *)&a1 + 0.0;
  v1 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a1, 0);
  v2 = (int8x8_t)vceqz_f32(v1);
  v3 = (int8x8_t)vcgt_s32((int32x2_t)v1, vdup_n_s32(0x7F7FFFFFu));
  v4 = vrsqrte_f32(v1);
  v5 = vorr_s8(v3, v2);
  __asm { FMOV            V3.2S, #1.0 }
  return vmul_f32(*(float32x2_t *)&a1, (float32x2_t)vbsl_s8(v5, _D3, (int8x8_t)vmul_f32(v4, vrsqrts_f32(v4, vmul_n_f32(v4, *(float *)&a1)))));
}

BOOL Projections_isZero(float a1)
{
  return (LODWORD(a1) & 0x7FFFFFFF) == 0;
}

uint64_t Projections_normalizeMeanStdUsingTable(uint64_t a1, int a2, int a3, _QWORD *a4, uint64_t a5, float *a6, float *a7, double a8)
{
  float v13;
  float v14;
  float v15;
  float __C;
  float __B;

  v13 = (float)(a3 - a2 + 1);
  v14 = (float)(*(float *)(a4[1] + 4 * (a3 + 1)) - *(float *)(a4[1] + 4 * a2)) / v13;
  *(float *)&a8 = (float)(*(float *)(*a4 + 4 * (a3 + 1)) - *(float *)(*a4 + 4 * a2)) / v13;
  *a6 = *(float *)&a8;
  *(float *)&a8 = v14 - (float)(*(float *)&a8 * *(float *)&a8);
  LODWORD(v15) = Projections_fastSqrtf(a8).u32[0];
  *a7 = v15;
  if (a5)
  {
    if (Projections_isZero(v15))
    {
      memcpy((void *)(a5 + 4 * a2), (const void *)(a1 + 4 * a2), vcvts_n_u32_f32(v13, 2uLL));
    }
    else
    {
      __B = 1.0 / *a7;
      __C = -(float)(*a6 * __B);
      vDSP_vsmsa((const float *)(a1 + 4 * a2), 1, &__B, &__C, (float *)(a5 + 4 * a2), 1, (unint64_t)v13);
    }
  }
  return 0;
}

uint64_t Projections_computeMeanStdTable(float *a1, int a2, _QWORD *a3)
{
  _DWORD *v3;
  _DWORD *v4;
  float *v5;
  float *v6;
  uint64_t v7;
  float v8;

  v3 = (_DWORD *)*a3;
  v4 = (_DWORD *)a3[1];
  *(_DWORD *)*a3 = 0;
  *v4 = 0;
  if (a2 >= 1)
  {
    v5 = (float *)(v3 + 1);
    v6 = (float *)(v4 + 1);
    v7 = (a2 + 1) - 1;
    do
    {
      *v5 = *(v5 - 1) + *a1;
      ++v5;
      v8 = *a1++;
      *v6 = *(v6 - 1) + (float)(v8 * v8);
      ++v6;
      --v7;
    }
    while (v7);
  }
  return 0;
}

uint64_t Projections_computeShiftBruteForce(uint64_t a1, int a2, _QWORD *a3, uint64_t a4, int a5, _QWORD *a6, int a7, float *a8, float a9, float *a10, float *a11, float *a12)
{
  float *v12;
  float *v17;
  int v18;
  int v19;
  float *v20;
  float *v21;
  int v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float v32;
  uint64_t v33;
  char v34;
  int v35;
  int v36;
  uint64_t v37;
  char *v38;
  float v39;
  float v40;
  float *v41;
  char *StatusDescription;
  float *v45;
  float *v50;
  float v51[3];

  v12 = a8;
  v17 = a10;
  if (a2 <= a5)
    v18 = a5;
  else
    v18 = a2;
  v19 = 2 * v18;
  v50 = a8;
  if (!a8)
    v50 = (float *)malloc_type_malloc(4 * v19, 0x100004052888210uLL);
  v20 = a10;
  if (!a10)
    v20 = (float *)malloc_type_malloc(4 * v19, 0x100004052888210uLL);
  v21 = a12;
  *v20 = 3.4028e38;
  v22 = 1 - a2;
  v23 = *a11;
  v24 = 0.0;
  if (*a11 >= (float)(1 - a2))
  {
    v25 = (float)(a5 - 1);
    if (v23 <= v25)
    {
      v26 = v23 - (float)v22;
      v27 = v25 - v23;
      if (v26 > v27)
        v27 = v26;
      v24 = a9 / v27;
    }
  }
  if (v22 >= a5)
  {
    v36 = 0;
    v31 = 0;
    v32 = 3.4028e38;
  }
  else
  {
    v45 = v12;
    v28 = 0;
    v29 = (a5 + a2 - 1);
    do
    {
      v51[0] = 3.4028e38;
      v30 = Projections_computeCost(v22 + (int)v28, a1, a2, a3, a4, a5, a6, a7, *a11, v24, v51);
      v31 = v30;
      if ((v30 & 0x80000000) != 0)
      {
        StatusDescription = Projections_getStatusDescription(v30);
        syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v31, StatusDescription, "Projections_status Projections_computeShiftBruteForce(const float *, int, const Projections_meanStdTable *, const float *, int, const Projections_meanStdTable *, int, float, float *, float *, float *, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/Projections_Optimizer.c", 122);
        v12 = v45;
        v17 = a10;
        goto LABEL_36;
      }
      v50[v28] = (float)(v22 + v28);
      v20[v28++] = v51[0];
    }
    while (v29 != v28);
    v32 = *v20;
    if (v29 < 2)
    {
      v36 = 0;
      v12 = v45;
      v17 = a10;
    }
    else
    {
      v33 = 0;
      v34 = 0;
      v35 = 0;
      v36 = 0;
      v37 = v29 - 1;
      v38 = (char *)(v50 + 1);
      v39 = 3.4028e38;
      v12 = v45;
      v17 = a10;
      do
      {
        v40 = v20[v33 + 1];
        if (v32 > v40)
        {
          v36 = (int)*(float *)&v38[4 * v33];
          v32 = v20[v33 + 1];
        }
        if (v33 + 1 < a5 + a2 - 2 && v39 > v40)
        {
          v41 = &v20[v33];
          if (*v41 > v40 && v41[2] > v40)
          {
            v35 = (int)*(float *)&v38[4 * v33];
            v34 = 1;
            v39 = v20[v33 + 1];
          }
        }
        ++v33;
      }
      while (v37 != v33);
      if ((v34 & 1) != 0)
      {
        *a11 = (float)v35;
        *a12 = v39;
        goto LABEL_36;
      }
    }
    v21 = a12;
  }
  *a11 = (float)v36;
  *v21 = v32;
LABEL_36:
  if (!v12 && v50)
    free(v50);
  if (!v17)
    free(v20);
  return v31;
}

uint64_t Projections_computeCost(int a1, uint64_t a2, int a3, _QWORD *a4, uint64_t a5, int a6, _QWORD *a7, int a8, float a9, float a10, float *a11)
{
  uint64_t v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  unsigned int v22;
  double v23;
  uint64_t v24;
  double v25;
  uint64_t v26;
  char *StatusDescription;
  char *v29;
  float v31;
  uint64_t v32;
  float v33;
  float __C;

  v11 = 0;
  v12 = -a1 & (a1 >> 31);
  if (a3 - 1 >= a6 - 1 - a1)
    v13 = a6 - 1 - a1;
  else
    v13 = a3 - 1;
  if (a6 - 1 >= a3 - 1 + a1)
    v14 = a3 - 1 + a1;
  else
    v14 = a6 - 1;
  v15 = v13 - v12 + 1;
  if (v15 >= a8)
  {
    v22 = a1 & ~(a1 >> 31);
    __C = 0.0;
    vDSP_dotpr((const float *)(a2 + 4 * v12), 1, (const float *)(a5 + 4 * v22), 1, &__C, v15);
    __C = __C / (float)v15;
    *(float *)&v23 = __C;
    v33 = 0.0;
    v32 = 0;
    v31 = 0.0;
    v24 = Projections_normalizeMeanStdUsingTable(a2, v12, v13, a4, 0, &v33, (float *)&v32 + 1, v23);
    if ((v24 & 0x80000000) != 0)
    {
      v11 = v24;
      StatusDescription = Projections_getStatusDescription(v24);
      syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v11, StatusDescription, "Projections_status Projections_computeCost(int, float, float, const float *, int, const Projections_meanStdTable *, const float *, int, const Projections_meanStdTable *, int, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/Projections_Optimizer.c", 58);
    }
    else
    {
      v26 = Projections_normalizeMeanStdUsingTable(a5, v22, v14, a7, 0, (float *)&v32, &v31, v25);
      v11 = v26;
      if ((v26 & 0x80000000) != 0)
      {
        v29 = Projections_getStatusDescription(v26);
        syslog(3, "Projections error %d:%s in %s @ %s:%d\n", v11, v29, "Projections_status Projections_computeCost(int, float, float, const float *, int, const Projections_meanStdTable *, const float *, int, const Projections_meanStdTable *, int, float *)", "/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage/Framework/api/Burst/Projections/Projections_Optimizer.c", 59);
      }
      else
      {
        *a11 = (float)((float)((float)((float)(*((float *)&v32 + 1) * v31) - __C) + (float)(v33 * *(float *)&v32))
                     / (float)((float)(*((float *)&v32 + 1) * v31) + (float)(*((float *)&v32 + 1) * v31)))
             + (float)(a10 * vabds_f32(a9, (float)a1));
      }
    }
  }
  return v11;
}

uint64_t nextPointAction(uint64_t result, int a2, uint64_t a3)
{
  double v3;
  double v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;

  v3 = *(double *)(a3 + 8);
  v4 = *(double *)(result + 8);
  v5 = *(double *)a3 - *(double *)result;
  v6 = v3 - v4;
  if (*(double *)(result + 24) * v6 + v5 * *(double *)(result + 16) > 0.0
    && *(double *)(a3 + 24) * v6 + v5 * *(double *)(a3 + 16) > 0.0)
  {
    v7 = v4 * *(float *)(a3 + 88) + *(float *)(a3 + 84) * *(double *)result + *(float *)(a3 + 92);
    v8 = v3 * *(float *)(result + 36) + *(float *)(result + 32) * *(double *)a3 + *(float *)(result + 40);
    if ((float)(fabsf(v7) + fabsf(v8)) < *(float *)(result + 44))
    {
      v9 = (float)(v6 * v6) + (float)(v5 * v5);
      if (v9 < *(float *)(result + 48))
      {
        *(float *)(result + 48) = v9;
        *(_DWORD *)(result + 52) = a2;
      }
    }
  }
  return result;
}

float32x2_t regressionMeanAction(float32x2_t *a1, uint64_t a2, float64x2_t *a3)
{
  float32x2_t v3;
  float32x2_t *v4;
  _DWORD *v5;
  float32x2_t result;

  v3 = vcvt_f32_f64(*a3);
  v4 = a1;
  if (a1->f32[0] > v3.f32[0] || (v4 = a1 + 1, a1[1].f32[0] < v3.f32[0]))
    v4->i32[0] = v3.i32[0];
  v5 = (_DWORD *)a1 + 1;
  if (a1->f32[1] > v3.f32[1] || (v5 = (_DWORD *)&a1[1] + 1, a1[1].f32[1] < v3.f32[1]))
    *v5 = v3.i32[1];
  result = vadd_f32(a1[2], v3);
  a1[2] = result;
  ++a1[3].i32[0];
  return result;
}

float32x2_t regressionHorizontalAction(float32x2_t *a1, uint64_t a2, float64x2_t *a3)
{
  float32x2_t result;

  result = vsub_f32(vcvt_f32_f64(*a3), *a1);
  a1[1] = vmla_n_f32(a1[1], result, result.f32[0]);
  return result;
}

float32x2_t regressionVerticalAction(float32x2_t *a1, uint64_t a2, float64x2_t *a3)
{
  float32x2_t result;

  result = vsub_f32(vcvt_f32_f64(*a3), *a1);
  a1[1] = vmla_lane_f32(a1[1], (float32x2_t)vrev64_s32((int32x2_t)result), result, 1);
  return result;
}

uint64_t lineEquationThroughTwoPoints(float *a1, double a2, double a3, double a4, double a5)
{
  float v5;
  float v6;
  float v7;
  uint64_t v8;
  float v9;
  float v10;
  float v11;
  float v12;

  v5 = a4 - a2;
  v6 = a5 - a3;
  v7 = sqrtf((float)(v6 * v6) + (float)(v5 * v5));
  if (v7 == 0.0)
    return 43;
  v8 = 0;
  v9 = 1.0 / v7;
  v10 = v9 * v5;
  v11 = -(float)(v9 * v6);
  *a1 = v11;
  a1[1] = v10;
  v12 = a3 * v10 + v11 * a2;
  a1[2] = -v12;
  return v8;
}

void threadSearchAction(int *a1, uint64_t a2, int *a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;

  if (*((_BYTE *)a3 + 24) && !*((_BYTE *)a3 + 25))
  {
    v5 = 0;
    v20 = *a1;
    v6 = *((_QWORD *)a1 + 1);
    v7 = *((_QWORD *)a1 + 3);
    v19 = *((_QWORD *)a1 + 4);
    v21 = *((_QWORD *)a1 + 2);
    v22 = *(_QWORD *)(v7 + 32) + 96 * *a3;
    v8 = 1;
    do
    {
      v9 = 0;
      do
      {
        v10 = *(_DWORD *)(v6 + 8);
        if (v10 >= 2 * (int)v9)
        {
          v11 = v5 - v9;
          if (a3[2] >= 2 * (v5 - (int)v9))
          {
            if (*a1 == (_DWORD)a2 && v10 < v5 + 3)
              return;
            v13 = v21;
            v14 = v9;
            if ((_DWORD)v9)
            {
              while (1)
              {
                v15 = *(_DWORD *)(v13 + 72);
                if (v15 == -1)
                  break;
                v13 = *(_QWORD *)(v7 + 32) + 96 * v15;
                if (!--v14)
                  goto LABEL_17;
              }
            }
            else
            {
LABEL_17:
              v16 = v22;
              if (v11 < 1)
              {
LABEL_21:
                if (pointToPointScore(v13, v16) > 0.0)
                  +[CIRedEyeRepair3 insertIntoConnectionHopper:index1:drop1:index2:drop2:score:](CIRedEyeRepair3, "insertIntoConnectionHopper:index1:drop1:index2:drop2:score:", v19, v20, v9, a2, (v5 - v9));
              }
              else
              {
                v17 = 0;
                v16 = v22;
                while (1)
                {
                  v18 = *(_DWORD *)(v16 + 68);
                  if (v18 == -1)
                    break;
                  v16 = *(_QWORD *)(v7 + 32) + 96 * v18;
                  if (++v17 >= v11)
                    goto LABEL_21;
                }
              }
            }
          }
        }
        v9 = (v9 + 1);
      }
      while ((_DWORD)v9 != v8);
      ++v5;
      ++v8;
    }
    while (v5 != 11);
  }
}

float pointToPointScore(uint64_t a1, uint64_t a2)
{
  double v2;
  double v3;
  float v4;
  float v5;
  float result;
  float v7;
  float v8;

  v2 = *(double *)(a1 + 8);
  v3 = *(double *)(a2 + 8);
  v4 = *(double *)a2 - *(double *)a1;
  v5 = v3 - v2;
  result = -1.0;
  if (*(double *)(a1 + 24) * v5 + v4 * *(double *)(a1 + 16) > 0.0)
  {
    result = -2.0;
    if (*(double *)(a2 + 24) * v5 + v4 * *(double *)(a2 + 16) > 0.0)
    {
      v7 = v2 * *(float *)(a2 + 88) + *(float *)(a2 + 84) * *(double *)a1 + *(float *)(a2 + 92);
      v8 = v3 * *(float *)(a1 + 88) + *(float *)(a1 + 84) * *(double *)a2 + *(float *)(a1 + 92);
      return sqrtf((float)(v5 * v5) + (float)(v4 * v4)) + (float)(fabsf(v8) + fabsf(v7)) * 0.333;
    }
  }
  return result;
}

void computeLengthAndAngle(uint64_t a1, double *a2)
{
  float v3;
  float v4;
  float v5;
  double v6;
  double v7;

  v3 = *a2 - *(double *)a1;
  v4 = a2[1] - *(double *)(a1 + 8);
  *(float *)(a1 + 16) = sqrtf((float)(v4 * v4) + (float)(v3 * v3));
  v5 = atan2(v4, v3);
  v6 = v5;
  if (v5 < 0.0)
  {
    v7 = 6.28318531;
LABEL_5:
    v5 = v6 + v7;
    goto LABEL_6;
  }
  if (v6 >= 6.28318531)
  {
    v7 = -6.28318531;
    goto LABEL_5;
  }
LABEL_6:
  *(float *)(a1 + 20) = v5;
}

float bilinearFloat4LookupComponents(uint64_t a1, float *a2, float a3, float a4)
{
  float v4;
  float v5;
  int v6;
  int v7;
  signed int v8;
  int v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  float *v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  int v22;
  float *v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  float result;

  v4 = 0.0;
  v5 = 0.0;
  if (a3 >= 0.0)
  {
    v5 = a3;
    if ((float)(*(_DWORD *)(a1 + 8) - 1) < a3)
      v5 = (float)(*(_DWORD *)(a1 + 8) - 1);
  }
  v6 = *(_DWORD *)(a1 + 12);
  if (a4 >= 0.0)
  {
    v4 = a4;
    if ((float)(v6 - 1) < a4)
      v4 = (float)(v6 - 1);
  }
  v7 = vcvtms_s32_f32(v5);
  v8 = vcvtms_s32_f32(v4);
  if (*(_DWORD *)(a1 + 8) - 2 < v7)
    v7 = *(_DWORD *)(a1 + 8) - 2;
  v9 = v6 - 2;
  if (v9 >= v8)
    v9 = v8;
  v10 = v5 - (float)v7;
  v11 = v4 - (float)v9;
  v12 = *(int *)(a1 + 16);
  v13 = *(int *)(a1 + 28);
  v14 = (float *)(*(_QWORD *)a1 + 4 * v9 * (int)v12 + 4 * (int)v13 * v7);
  v16 = v14[2];
  v15 = v14[3];
  v17 = v14[(int)v13 + 2];
  v18 = v14[(int)v13 + 3];
  v19 = v14[v12];
  v20 = v14[(int)v12 + 1];
  v21 = v14[(int)v12 + 2];
  v22 = v12 + 3;
  v23 = &v14[(int)v13 + (int)v12];
  v24 = v23[2];
  v25 = *v14 + (float)((float)(v14[v13] - *v14) * v10);
  v26 = v25 + (float)((float)((float)(v19 + (float)((float)(*v23 - v19) * v10)) - v25) * v11);
  v27 = v14[1] + (float)((float)(v14[(int)v13 + 1] - v14[1]) * v10);
  v28 = v27 + (float)((float)((float)(v20 + (float)((float)(v23[1] - v20) * v10)) - v27) * v11);
  v29 = (float)(v28 * v28) + (float)(v26 * v26);
  v30 = 0.0;
  if (v29 != 0.0)
    v30 = 1.0 / sqrt(v29);
  v31 = v14[v22];
  v32 = v23[3];
  *a2 = v26 * v30;
  a2[1] = v28 * v30;
  a2[2] = (float)(v16 + (float)((float)(v17 - v16) * v10))
        + (float)((float)((float)(v21 + (float)((float)(v24 - v21) * v10))
                        - (float)(v16 + (float)((float)(v17 - v16) * v10)))
                * v11);
  v33 = (float)(v18 - v15);
  if (v33 >= -3.14159265)
  {
    if (v33 <= 3.14159265)
      goto LABEL_18;
    v34 = v18;
    v35 = -6.28318531;
  }
  else
  {
    v34 = v18;
    v35 = 6.28318531;
  }
  v18 = v34 + v35;
LABEL_18:
  v36 = (float)(v31 - v15);
  if (v36 >= -3.14159265)
  {
    if (v36 <= 3.14159265)
      goto LABEL_23;
    v37 = v31;
    v38 = -6.28318531;
  }
  else
  {
    v37 = v31;
    v38 = 6.28318531;
  }
  v31 = v37 + v38;
LABEL_23:
  v39 = (float)(v32 - v15);
  if (v39 < -3.14159265)
  {
    v40 = v32;
    v41 = 6.28318531;
LABEL_27:
    v32 = v40 + v41;
    goto LABEL_28;
  }
  if (v39 > 3.14159265)
  {
    v40 = v32;
    v41 = -6.28318531;
    goto LABEL_27;
  }
LABEL_28:
  result = (float)(v15 + (float)((float)(v18 - v15) * v10))
         + (float)((float)((float)(v31 + (float)((float)(v32 - v31) * v10))
                         - (float)(v15 + (float)((float)(v18 - v15) * v10)))
                 * v11);
  a2[3] = result;
  return result;
}

float checkpointScore(int a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4;
  double *v5;
  double v6;
  double v7;
  int v8;
  double *v9;
  double v10;
  double v11;
  int v12;
  double *v13;
  float v14;
  float v15;
  float v16;
  float v17;

  v4 = *(_QWORD *)(a4 + 8);
  v5 = (double *)(v4 + 48 * *(int *)(a2 + 24 * a1 + 16));
  v6 = *v5;
  v7 = v5[1];
  if (a1 >= 1)
    v8 = a1;
  else
    v8 = a3;
  v9 = (double *)(v4 + 48 * *(int *)(a2 + 24 * v8 - 8));
  v10 = *v9;
  v11 = v9[1];
  if (a1 + 1 < a3)
    v12 = a1 + 1;
  else
    v12 = 0;
  v13 = (double *)(v4 + 48 * *(int *)(a2 + 24 * v12 + 16));
  v14 = v6 - v10;
  v15 = v7 - v11;
  v16 = *v13 - v6;
  v17 = v13[1] - v7;
  return sqrtf(sqrtf((float)(v15 * v15) + (float)(v14 * v14)) * sqrtf((float)(v17 * v17) + (float)(v16 * v16)));
}

void histogramBitmap(unsigned __int8 **a1, uint64_t a2, _DWORD *a3, _DWORD *a4, int *a5)
{
  int v9;
  int v10;
  unsigned __int8 *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unsigned __int8 *v16;
  uint64_t v17;
  int v18;
  int v19;
  int i;
  uint64_t v21;
  int v22;
  int v23;
  _DWORD v24[256];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  bzero(v24, 0x400uLL);
  v9 = *((_DWORD *)a1 + 3);
  if (v9 >= 1)
  {
    v10 = 0;
    v11 = *a1;
    v12 = *((_DWORD *)a1 + 2);
    v13 = *((int *)a1 + 4);
    do
    {
      if (v12 >= 1)
      {
        v14 = *((int *)a1 + 7);
        v15 = v12;
        v16 = v11;
        do
        {
          ++v24[*v16];
          v16 += v14;
          --v15;
        }
        while (v15);
      }
      ++v10;
      v11 += v13;
    }
    while (v10 != v9);
  }
  v17 = 0;
  v18 = 0;
  do
  {
    v18 += v24[v17];
    if (v18 > 4)
      break;
    ++v17;
  }
  while (v17 != 256);
  v19 = 0;
  for (i = 255; i != -1; --i)
  {
    v19 += v24[i];
    if (v19 > 4)
      break;
  }
  v21 = 0;
  v22 = 0;
  v23 = (*((_DWORD *)a1 + 2) * v9 + 1) >> 1;
  do
  {
    v22 += v24[v21];
    if (v22 > v23)
      break;
    ++v21;
  }
  while (v21 != 256);
  *a3 = v17;
  *a4 = v21;
  *a5 = i;
}

void **computeBitmask(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6, float a7, double a8, float a9)
{
  int v13;
  int v14;
  float v15;
  void **inited;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned __int8 *v23;
  unsigned __int8 *v24;
  int v25;
  unsigned __int8 *v26;
  int v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  unsigned int v30;
  BOOL v31;
  BOOL v32;
  float v34;
  float v35;
  int v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  float *v41;
  int v42;
  int v43;
  uint64_t v44;
  int v45;
  int v46;
  _QWORD *v47;
  signed int v48;
  float v49;
  int v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  int v54;
  signed int v55;
  int v56;
  int v57;
  signed int v58;
  unsigned __int8 *v59;
  int v60;
  uint64_t v61;
  signed int v62;
  int v63;
  int v64;
  uint64_t i;
  int v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  int *v70;
  uint64_t v71;
  int v72;
  float v73;
  float v74;
  float v75;
  _DWORD *v77;
  int v78;
  unsigned int v79;
  unsigned int v80;
  int v81;
  void **v82;
  int v83;
  unsigned int v84;
  int v85;
  unsigned __int8 *v86;
  unsigned __int8 *v87;
  int v88;
  uint64_t v89;
  unsigned int v90;
  int v91;
  BOOL v92;
  BOOL v93;
  int v94;
  int v95;
  int v96;
  int v97;
  uint64_t *v98;
  uint64_t v99;
  float v100;
  unsigned int j;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  double v106;
  double v107;
  float v108;
  unsigned int v109;
  int v110;
  int v111;
  int v112;
  uint64_t v113;
  float v114;
  uint64_t v115;
  float v116;
  uint64_t v117;
  int v118;
  void **v120;
  const char *v121;
  float v123;
  float v124;
  uint64_t v125;
  int v126;
  uint64_t v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  float v133;
  int v134;
  int v135;
  uint64_t *v136;
  uint64_t *v137;
  float v138;
  uint64_t *v139;
  int v140;
  float v141;
  float v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  unsigned int v146;
  signed int v147;
  int v148;
  uint64_t v149;
  unsigned int v150;
  int v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  int v156;
  char v157;
  int v158;
  float v159;
  uint64_t v160;
  uint64_t *v161;
  uint64_t *v162;
  int v163;
  float v164;
  uint64_t *v165;
  float v166;
  BOOL v167;
  float v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  uint64_t *v178;
  uint64_t v179;
  uint64_t v180;
  double v181;
  double v182;
  float v183;
  __double2 v184;
  float v185;
  float v186;
  uint64_t v187;
  int v188;
  int v189;
  float v190;
  double v191;
  float v192;
  int v193;
  float v194;
  int v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  void **v199;
  int v200;
  int v201;
  int v202;
  float v203;
  int v204;
  float v206;
  int v207;
  uint64_t v208;
  double v209;
  double v210;
  float v211;
  __double2 v212;
  float cosval;
  float sinval;
  uint64_t v215;
  int v216;
  int v217;
  float v218;
  double v219;
  float v220;
  int v221;
  float v222;
  int v223;
  __int128 v224;
  __int128 v225;
  __int128 v226;
  __int128 v227;
  __int128 v228;
  __int128 v229;
  int v230;
  _OWORD *v231;
  int v232;
  unsigned int v233;
  uint64_t v234;
  int v235;
  uint64_t v236;
  int v237;
  int v239;
  int v240;
  _OWORD *v241;
  int v243;
  unsigned int v244;
  void **v246;
  int v247;
  int v248;
  int v249;
  int v250;
  int v251;
  uint64_t *v252;
  __int128 v253;
  __int128 v254;
  __int128 v255;
  __int128 v256;
  __int128 v257;
  __int128 v258;
  __int128 v259;
  __int128 v260;
  __int128 v261;
  __int128 v262;
  __int128 v263;
  __int128 v264;
  void *__dst[2];
  __int128 v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  _DWORD v271[11];
  _DWORD v272[25];
  _QWORD v273[15];

  v273[12] = *MEMORY[0x1E0C80C00];
  v257 = 0u;
  v258 = 0u;
  v255 = 0u;
  v256 = 0u;
  v253 = 0u;
  v254 = 0u;
  v14 = *(_DWORD *)(a1 + 8);
  v13 = *(_DWORD *)(a1 + 12);
  v15 = -1.0;
  if (a7 >= 0.0)
    v15 = (float)(a7 * a7) * 0.25 * 3.14159265;
  inited = (void **)initBitmask(v14, v13);
  if (!inited)
  {
    puts("computeBitmask: can not allocate bitmask bm");
    return inited;
  }
  v239 = v13;
  v246 = (void **)initBitmask(v14, v13);
  if (!v246)
  {
    puts("computeBitmask: can not allocate bitmask bm2");
    v82 = inited;
    goto LABEL_148;
  }
  v236 = a4;
  v269 = 0;
  v270 = 0;
  v268 = 0;
  *(_OWORD *)__dst = 0u;
  v266 = 0u;
  v267 = 0;
  v259 = 0u;
  v260 = 0u;
  v261 = 0u;
  v262 = 0u;
  v263 = 0u;
  v264 = 0u;
  v18 = a1;
  histogramBitmap((unsigned __int8 **)a1, v17, (_DWORD *)&v269 + 1, (_DWORD *)&v268 + 1, (int *)&v269);
  initBitmap((uint64_t)__dst, *(_DWORD *)(v18 + 8), *(_DWORD *)(v18 + 12), *(_DWORD *)(v18 + 28), 1, *(float *)(v18 + 36));
  memmove(__dst[0], *(const void **)v18, *(int *)(v18 + 24));
  applyMaxFilter8((uint64_t)__dst, 11);
  v19 = *(int *)(a1 + 16);
  v20 = *(int *)(a1 + 28);
  v252 = (uint64_t *)inited;
  v247 = v14;
  if (a6 != 2)
  {
    v83 = *(_DWORD *)(a1 + 12);
    if (v83 < 1)
    {
      v78 = 0;
      v81 = 0;
      v79 = 0;
      v80 = 0;
    }
    else
    {
      v84 = 0;
      v80 = 0;
      v79 = 0;
      v78 = 0;
      v85 = *(_DWORD *)(a1 + 8);
      v86 = (unsigned __int8 *)__dst[0];
      v87 = *(unsigned __int8 **)a1;
      v88 = v83 * v85;
      do
      {
        if (v85 >= 1)
        {
          v89 = 0;
          v90 = 0;
          v91 = (v84 - a3) * (v84 - a3);
          do
          {
            if (v87[v89])
              v92 = v86[v89] == v87[v89];
            else
              v92 = 0;
            v93 = v92 && (int)(v91 + (v90 - a2) * (v90 - a2)) < v88;
            if (v93)
              v88 = v91 + (v90 - a2) * (v90 - a2);
            if (v93)
              v78 = v87[v89];
            if (v93)
              v79 = v84;
            if (v93)
              v80 = v90;
            ++v90;
            v89 += v20;
          }
          while (v85 != v90);
        }
        ++v84;
        v87 += v19;
        v86 += v19;
      }
      while (v84 != v83);
      v81 = 0;
    }
    goto LABEL_111;
  }
  memset(v273, 0, 96);
  v272[0] = 0;
  v21 = *(int *)(a1 + 12);
  if ((int)v21 < 1)
    goto LABEL_146;
  v22 = 0;
  v23 = *(unsigned __int8 **)a1;
  v24 = (unsigned __int8 *)__dst[0];
  v25 = *(_DWORD *)(a1 + 8);
  v26 = *(unsigned __int8 **)a1;
  do
  {
    if (v25 >= 1)
    {
      v27 = 0;
      v28 = v24;
      v29 = v26;
      do
      {
        if (v22)
        {
          v30 = *v29;
          v31 = *v28 == v30 && v22 < (int)v21 - 1;
          v32 = !v31 || v27 == 0;
          if (!v32 && v27 < v25 - 1)
          {
            v34 = sqrtf((float)((v22 - a3) * (v22 - a3) + (v27 - a2) * (v27 - a2)));
            v35 = (float)v30 / fmaxf(v34, 1.0);
            v36 = v272[0];
            if (v272[0] < 1)
            {
              LODWORD(v37) = 0;
            }
            else
            {
              v37 = 0;
              v38 = v272[0];
              v39 = 3;
              while (*(float *)&v272[v39] >= v35)
              {
                ++v37;
                v39 += 6;
                if (v272[0] == v37)
                {
                  v37 = v272[0];
                  goto LABEL_34;
                }
              }
              if (v272[0] > (int)v37)
              {
                v40 = &v273[3 * v272[0]];
                do
                {
                  if (v38 <= 3)
                  {
                    *(_OWORD *)v40 = *(_OWORD *)(v40 - 3);
                    v40[2] = *(v40 - 1);
                  }
                  --v38;
                  v40 -= 3;
                }
                while (v38 > (uint64_t)v37);
              }
              v37 = v37;
LABEL_34:
              if (v37 > 3)
                goto LABEL_40;
              v36 = v272[0];
            }
            v41 = (float *)&v272[6 * v37];
            *((_DWORD *)v41 + 1) = v30;
            v41[2] = v34;
            v41[3] = v35;
            *((_DWORD *)v41 + 4) = v22;
            *((_DWORD *)v41 + 5) = v27;
            if (v36 < 4)
              v42 = v36 + 1;
            else
              v42 = 4;
            v272[0] = v42;
          }
        }
LABEL_40:
        ++v27;
        v29 += v20;
        v28 += v20;
      }
      while (v27 != v25);
    }
    ++v22;
    v26 += v19;
    v24 += v19;
  }
  while (v22 != (_DWORD)v21);
  v43 = v272[0];
  if (v272[0] < 1)
    goto LABEL_146;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v47 = v273;
  v48 = *(_DWORD *)(a1 + 8);
  v49 = -10000.0;
  v50 = -1;
  do
  {
    v51 = 0;
    v52 = *((_DWORD *)v47 + 4);
    v53 = *((int *)v47 + 3);
    v54 = v52;
    do
    {
      v55 = v52 + v51;
      v56 = (v53 - v51) & ~(((int)v53 - (int)v51) >> 31);
      if (v51 + v53 < v21)
        v57 = v51 + v53 + 1;
      else
        v57 = v21;
      if (v55 < v48)
        v58 = v55 + 1;
      else
        v58 = v48;
      if (v56 >= v57)
      {
        v60 = 255;
      }
      else
      {
        v59 = &v23[(int)v19 * (uint64_t)v56];
        v60 = 255;
        do
        {
          if (((v52 - v51) & ~((v52 - (int)v51) >> 31)) < v58)
          {
            v61 = (int)(v20 * (v54 & ~(v54 >> 31)));
            v62 = (v52 - v51) & ~((v52 - (int)v51) >> 31);
            do
            {
              if (v60 >= v59[v61])
                v60 = v59[v61];
              ++v62;
              v61 += v20;
            }
            while (v62 < v58);
          }
          ++v56;
          v59 += v19;
        }
        while (v56 < v57);
      }
      v271[v51++] = v60;
      --v54;
    }
    while (v51 != 11);
    v63 = -1;
    v64 = v271[0];
    for (i = 1; i != 11; ++i)
    {
      v66 = v271[i];
      v67 = v64 - v66;
      if (v67 > v63)
      {
        v63 = v67;
        v45 = i;
      }
      v64 = v66;
    }
    v68 = v45;
    if (v45 <= 10)
      v69 = 10;
    else
      v69 = v45;
    v70 = &v271[v45 + 1];
    v14 = v247;
    while (v69 != v68)
    {
      v71 = *(v70 - 1);
      if (v68 != 9)
      {
        ++v68;
        v72 = *v70++;
        if (20 * ((int)v71 - v72) >= (int)v71)
          continue;
      }
      goto LABEL_75;
    }
    v71 = v44;
LABEL_75:
    v73 = *((float *)v47 + 1);
    v74 = (float)*(int *)v47 / fmaxf((float)(int)v71, 1.0);
    *((_DWORD *)v47 + 5) = v71;
    v75 = v74 + v73 * -0.05;
    if (v49 < v75)
    {
      v50 = v46;
      v49 = v75;
    }
    ++v46;
    v47 += 3;
    v44 = v71;
  }
  while (v46 != v43);
  if (v49 == -10000.0 || v50 == -1)
    goto LABEL_146;
  v77 = &v272[6 * v50];
  v78 = v77[1];
  LODWORD(v269) = v78;
  v79 = v77[4];
  v80 = v77[5];
  v81 = v77[6];
LABEL_111:
  termBitmap(__dst);
  v94 = v269;
  v95 = HIDWORD(v268);
  if ((int)v269 > v78)
  {
    LODWORD(v269) = v78;
    v94 = v78;
    if (SHIDWORD(v268) >= v78)
    {
      v95 = v78 - 1;
      HIDWORD(v268) = v78 - 1;
      v94 = v78;
    }
  }
  v96 = (v95 + 2 * v94) / 3;
  if (v96 == v94)
    v97 = v94 - 1;
  else
    v97 = v96;
  v98 = v252;
  computeThresholdedBitmask((unsigned __int8 *)a1, v252, v97);
  if (v239 < 1)
    goto LABEL_143;
  v235 = v94;
  LODWORD(v234) = v81;
  v99 = 0;
  v100 = (float)(v239 * v239 + v14 * v14);
  v243 = -1;
  v244 = -1;
  do
  {
    if (v14 >= 1)
    {
      for (j = 0; j != v14; ++j)
      {
        if (bitValueFromBitmask((uint64_t)v252, j, v99))
        {
          v102 = (uint64_t)v246;
          if (!seedFill((uint64_t)v252, (uint64_t)v246, j, v99, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))bitIsSet))
          {
            puts("computeBitmask: seedFill failed");
            termBitmask((void **)v252);
            v82 = v246;
            goto LABEL_148;
          }
          v103 = bitmaskBoundingBitmapRect((uint64_t)v246);
          v105 = v104;
          bitmaskCentroidUsingBoundingRect((uint64_t)v246, v103, v104);
          closestSetBitInBitmaskUsingBoundingRect((uint64_t)v246, v103, v105, (int *)&v270 + 1, (int *)&v270, v106, v107);
          v108 = (float)(v270 - a3) * (float)(v270 - a3);
          if ((float)(v108 + (float)((float)(HIDWORD(v270) - a2) * (float)(HIDWORD(v270) - a2))) < v100)
          {
            if (HIDWORD(v270) == -1)
            {
              v121 = "computeBitmask: centroid closest bit search failed";
LABEL_145:
              puts(v121);
              goto LABEL_146;
            }
            v243 = HIDWORD(v270);
            v244 = v270;
            v100 = v108 + (float)((float)(HIDWORD(v270) - a2) * (float)(HIDWORD(v270) - a2));
            v102 = (uint64_t)v246;
          }
          bitmaskMinus((uint64_t)v252, v102);
          v14 = v247;
        }
      }
    }
    v99 = (v99 + 1);
  }
  while ((_DWORD)v99 != v239);
  v98 = v252;
  v109 = v235;
  if (v244 == -1)
  {
LABEL_143:
    puts("computeBitmask: connected pieces search failed");
    v120 = (void **)v98;
    goto LABEL_147;
  }
  v110 = *(unsigned __int8 *)(v236 + 24);
  v111 = -1;
  *(_DWORD *)a5 = -1;
  v112 = a6;
  if (v15 > 0.0 && a6 != -1 && !v110)
  {
    v113 = a1;
    if ((v235 & 0x80000000) == 0)
    {
      v114 = a9 * 0.055;
      v115 = (uint64_t)rintf(v114 * v114);
      v116 = a9 * 0.23;
      v117 = (uint64_t)rintf(v116 * v116);
      v118 = -1;
      while (1)
      {
        LODWORD(v268) = v109;
        if (!(v118 == -1
             ? seedFill(v113, (uint64_t)v252, v243, v244, (uint64_t)&v268, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold): incrementalSeedFill(v113, (uint64_t)v252, v243, v244, (uint64_t)&v268, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold)))break;
        if ((int)bitmaskArea((uint64_t)v252) >= (int)v115)
        {
          v146 = v109;
          v147 = v109 + 9;
          v249 = v146 + 8;
          v148 = -1;
          v149 = a1;
          while (1)
          {
            v150 = v146;
            LODWORD(v268) = v146;
            if (!(v148 == -1
                 ? seedFill(v149, (uint64_t)v252, v243, v244, (uint64_t)&v268, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold): incrementalSeedFill(v149, (uint64_t)v252, v243, v244, (uint64_t)&v268, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold)))goto LABEL_195;
            if ((int)bitmaskArea((uint64_t)v252) > (int)v117)
            {
              v152 = v150;
              v149 = a1;
LABEL_279:
              v200 = v152 & ~(v152 >> 31);
              if (v249 >= v200)
              {
                v201 = 0;
                v251 = 256;
                v202 = -1;
                v203 = -1000000.0;
                do
                {
                  LODWORD(v268) = --v147;
                  if (v202 == -1)
                    v204 = seedFill(v149, (uint64_t)v252, v243, v244, (uint64_t)&v268, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold);
                  else
                    v204 = incrementalSeedFill(v149, (uint64_t)v252, v243, v244, (uint64_t)&v268, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold);
                  if (!v204)
                    goto LABEL_312;
                  getBitmaskInfoWithSeedPoint((uint64_t)v252, (uint64_t *)a1, (uint64_t)&v259, v243, v244);
                  if ((int)v260 <= (int)v117 && (int)v260 >= (int)v115)
                  {
                    v206 = (float)(*((float *)&v260 + 2) + *((float *)&v260 + 3)) / 255.0;
                    v207 = v251;
                    if ((float)(*((float *)&v260 + 1) + v206) > v203)
                      v207 = v147;
                    v251 = v207;
                    if ((float)(*((float *)&v260 + 1) + v206) > v203)
                    {
                      v203 = *((float *)&v260 + 1) + v206;
                      v201 = v260;
                    }
                    v202 = v147;
                  }
                  v149 = a1;
                }
                while (v147 > v200);
                if (v202 != -1 && v201 <= (int)v117 && v201 >= (int)v115)
                {
                  LODWORD(v268) = v251;
                  if (!seedFill(a1, (uint64_t)v252, v243, v244, (uint64_t)&v268, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold))
                  {
LABEL_312:
                    v121 = "computeBitmask: seedFill failed";
                    goto LABEL_145;
                  }
                  getBitmaskInfoWithSeedPoint((uint64_t)v252, (uint64_t *)a1, (uint64_t)&v259, v243, v244);
                  HIDWORD(v262) = v78;
                  *(_QWORD *)&v263 = __PAIR64__(v80, v79);
                  if (a6 != 2)
                  {
                    v208 = 0;
                    v209 = sqrt((float)(int)v260 / 3.14159265);
                    v210 = v209 + v209;
                    v211 = 0.0;
                    do
                    {
                      v212 = __sincos_stret(v211);
                      cosval = v212.__cosval;
                      *(float *)&v272[v208] = cosval;
                      sinval = v212.__sinval;
                      *(float *)&v271[v208] = sinval;
                      v211 = v211 + 0.62832;
                      ++v208;
                    }
                    while (v208 != 10);
                    v215 = 0;
                    v216 = 0;
                    v217 = 0;
                    v218 = v210;
                    v219 = v218 * 0.5;
                    do
                    {
                      v220 = v219 * *(float *)&v272[v215];
                      v221 = v80 + (uint64_t)rintf(v220);
                      if (v221 >= 0)
                      {
                        v222 = v219 * *(float *)&v271[v215];
                        v223 = v79 + (uint64_t)rintf(v222);
                        if ((v223 & 0x80000000) == 0 && v221 < *(_DWORD *)(a1 + 8) && v223 < *(_DWORD *)(a1 + 12))
                        {
                          ++v217;
                          v216 += *(unsigned __int8 *)(*(_QWORD *)a1
                                                     + *(_DWORD *)(a1 + 16) * v223
                                                     + *(_DWORD *)(a1 + 28) * v221);
                        }
                      }
                      ++v215;
                    }
                    while (v215 != 10);
                    v234 = (uint64_t)rintf((float)v216 / (float)v217);
                  }
                  DWORD2(v263) = v234;
                  if (!BYTE8(v262))
                  {
                    v224 = v262;
                    *(_OWORD *)(a5 + 40) = v261;
                    *(_OWORD *)(a5 + 56) = v224;
                    v225 = v264;
                    *(_OWORD *)(a5 + 72) = v263;
                    *(_OWORD *)(a5 + 88) = v225;
                    v226 = v260;
                    *(_OWORD *)(a5 + 8) = v259;
                    *(_DWORD *)a5 = v251;
                    *(_OWORD *)(a5 + 24) = v226;
                    *(_DWORD *)(a5 + 104) = v243;
                    *(_DWORD *)(a5 + 108) = v244;
                    inited = (void **)v252;
                    spreadBitmask((uint64_t)v252, (uint64_t)v246, 0);
                    chokeBitmask((uint64_t)v246, (uint64_t)v252, 0);
                    v199 = v246;
                    goto LABEL_275;
                  }
                }
              }
              goto LABEL_146;
            }
            v152 = v150 - 8;
            v148 = v150;
            v146 = v150 - 8;
            v149 = a1;
            if (v150 <= 7)
              goto LABEL_279;
          }
        }
        v118 = v109;
        v31 = v109 > 7;
        v109 -= 8;
        v113 = a1;
        if (!v31)
          goto LABEL_196;
      }
LABEL_195:
      puts("computeBitmask: seedFill failed");
    }
LABEL_196:
    termBitmask((void **)v252);
    v82 = v246;
    goto LABEL_148;
  }
  v123 = 0.0;
  v124 = 0.0;
  v125 = a1;
  v126 = v243;
  if (a6 == -1)
    v124 = 2.0 / (float)*(int *)(v236 + 28);
  v127 = HIDWORD(v269);
  if (v235 < SHIDWORD(v269))
  {
    v128 = 0;
    v129 = 256;
    goto LABEL_206;
  }
  v130 = 0;
  v131 = 0;
  v132 = 0;
  v231 = (_OWORD *)(a5 + 8);
  v232 = 256;
  v133 = 0.0;
  v134 = v235;
  v233 = HIDWORD(v269);
  while (2)
  {
    v237 = v134;
    v240 = v132;
    v135 = v109 + v130;
    LODWORD(v268) = v109 + v130;
    v248 = v111;
    if (v111 == -1)
    {
      v136 = v252;
      v139 = (uint64_t *)v125;
      if (!seedFill(v125, (uint64_t)v252, v243, v244, (uint64_t)&v268, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold))
      {
LABEL_197:
        puts("computeBitmask: seedFill failed");
        v120 = (void **)v136;
        goto LABEL_147;
      }
      getBitmaskInfoWithSeedPoint((uint64_t)v252, v139, (uint64_t)&v259, v243, v244);
      v138 = 0.0;
    }
    else
    {
      v136 = v252;
      v137 = (uint64_t *)v125;
      if (!incrementalSeedFill(v125, (uint64_t)v252, v243, v244, (uint64_t)&v268, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold))goto LABEL_197;
      getBitmaskInfoWithSeedPoint((uint64_t)v252, v137, (uint64_t)&v259, v243, v244);
      v138 = breakoutScore((uint64_t)&v253, (uint64_t)&v259);
    }
    v140 = v131 | ((int)v260 < 1);
    v132 = v240;
    if (!(v131 & 1 | ((int)v260 < 1)))
      v132 = v135;
    v129 = v248;
    v109 = v235;
    if (a6 == 2)
    {
      v125 = a1;
      if ((_DWORD)v260 == 1 || BYTE8(v262))
        v141 = 0.0;
      else
        v141 = *((float *)&v260 + 1) * (float)(fminf(*((float *)&v260 + 2), 100.0) + *((float *)&v260 + 3));
      v127 = v233;
      if (v248 == -1)
        goto LABEL_179;
LABEL_178:
      if (v141 > v123)
        goto LABEL_179;
    }
    else
    {
      v125 = a1;
      if (a6 == -1)
      {
        v142 = 1.0 - (float)(v124 * (float)(int)v260);
        if (v142 < 0.0)
          v142 = 0.0;
        if (v142 > 1.0)
          v142 = 1.0;
        v141 = (float)((float)(v142 * v142) * *((float *)&v260 + 1))
             * (float)(*((float *)&v260 + 2) + *((float *)&v260 + 3));
        v127 = v233;
        if (v248 != -1)
          goto LABEL_178;
LABEL_179:
        *(_DWORD *)a5 = v135;
        v143 = v262;
        *(_OWORD *)(a5 + 40) = v261;
        *(_OWORD *)(a5 + 56) = v143;
        v144 = v264;
        *(_OWORD *)(a5 + 72) = v263;
        *(_OWORD *)(a5 + 88) = v144;
        v145 = v260;
        v232 = v135;
        v123 = v141;
        *v231 = v259;
        *(_OWORD *)(a5 + 24) = v145;
      }
      else
      {
        v127 = v233;
        if (v248 != -1 && (v138 > 1.0 || v138 > 0.44 && v133 * 30.0 < v138) && (float)v132 * 0.68 >= (float)v135)
        {
          *(_DWORD *)a5 = v248;
          v227 = v256;
          *(_OWORD *)(a5 + 40) = v255;
          *(_OWORD *)(a5 + 56) = v227;
          v228 = v258;
          *(_OWORD *)(a5 + 72) = v257;
          *(_OWORD *)(a5 + 88) = v228;
          v229 = v254;
          v230 = v248;
          *v231 = v253;
          *(_OWORD *)(a5 + 24) = v229;
          v112 = a6;
          v126 = v243;
          goto LABEL_218;
        }
      }
    }
    if (!BYTE8(v262))
    {
      v131 |= v140 ^ 1;
      v255 = v261;
      v256 = v262;
      v257 = v263;
      v258 = v264;
      v253 = v259;
      v254 = v260;
      v133 = v133 * 0.2 + v138 * 0.8;
      v111 = v237;
      v134 = v237 - 8;
      v130 -= 8;
      if (v235 + v130 < (int)v127)
      {
        v128 = 0;
        v112 = a6;
        goto LABEL_204;
      }
      continue;
    }
    break;
  }
  v128 = 0;
  v112 = a6;
  if (a6 == -1)
  {
LABEL_204:
    v126 = v243;
  }
  else
  {
    v126 = v243;
    if (a6 != 2)
    {
      if (v130)
      {
        if (v248 == -1)
          v129 = v235 + v130;
        *(_DWORD *)a5 = v129;
        v153 = v256;
        *(_OWORD *)(a5 + 40) = v255;
        *(_OWORD *)(a5 + 56) = v153;
        v154 = v258;
        *(_OWORD *)(a5 + 72) = v257;
        *(_OWORD *)(a5 + 88) = v154;
        v155 = v254;
        v128 = 1;
        *v231 = v253;
        *(_OWORD *)(a5 + 24) = v155;
        goto LABEL_206;
      }
LABEL_146:
      v120 = (void **)v252;
LABEL_147:
      termBitmask(v120);
      v82 = v246;
LABEL_148:
      termBitmask(v82);
      return 0;
    }
  }
  v129 = v232;
LABEL_206:
  if (v112 == 2 || v112 == -1)
  {
    if (v129 <= 247)
      v230 = v129 + 8;
    else
      v230 = 255;
    if (v129 <= 8)
      v156 = 8;
    else
      v156 = v129;
    v127 = (v156 - 8);
  }
  else if (v128)
  {
    v230 = v129;
  }
  else
  {
    v230 = v127 + 8;
  }
LABEL_218:
  v250 = v129;
  if (v230 < (int)v127)
  {
    v157 = 0;
    v158 = -1;
    goto LABEL_257;
  }
  v241 = (_OWORD *)(a5 + 8);
  v158 = -1;
  v159 = 0.0;
  while (2)
  {
    v160 = v127;
    LODWORD(v268) = v230;
    if (v158 == -1)
    {
      v161 = v252;
      v165 = (uint64_t *)v125;
      v163 = v243;
      if (!seedFill(v125, (uint64_t)v252, v243, v244, (uint64_t)&v268, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold))
      {
LABEL_253:
        puts("computeBitmask: seedFill failed");
        v120 = (void **)v161;
        goto LABEL_147;
      }
      getBitmaskInfoWithSeedPoint((uint64_t)v252, v165, (uint64_t)&v259, v243, v244);
      v164 = 0.0;
    }
    else
    {
      v161 = v252;
      v162 = (uint64_t *)v125;
      v163 = v243;
      if (!incrementalSeedFill(v125, (uint64_t)v252, v243, v244, (uint64_t)&v268, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold))goto LABEL_253;
      getBitmaskInfoWithSeedPoint((uint64_t)v252, v162, (uint64_t)&v259, v243, v244);
      v164 = breakoutScore((uint64_t)&v253, (uint64_t)&v259);
    }
    v126 = v163;
    v112 = a6;
    v127 = v160;
    if (a6 == 2)
    {
      v125 = a1;
      if ((_DWORD)v260 == 1 || BYTE8(v262))
        v166 = 0.0;
      else
        v166 = *((float *)&v260 + 1) * (float)(fminf(*((float *)&v260 + 2), 100.0) + *((float *)&v260 + 3));
      goto LABEL_247;
    }
    v125 = a1;
    if (a6 == -1)
    {
      v168 = 1.0 - (float)(v124 * (float)(int)v260);
      if (v168 < 0.0)
        v168 = 0.0;
      if (v168 > 1.0)
        v168 = 1.0;
      v166 = (float)(*((float *)&v260 + 2) + *((float *)&v260 + 3))
           * (float)(*((float *)&v260 + 1) * (float)(v168 * v168));
      if (v158 != -1)
      {
LABEL_247:
        if (v166 <= v123)
          goto LABEL_249;
      }
      *(_DWORD *)a5 = v230;
      v169 = v262;
      *(_OWORD *)(a5 + 40) = v261;
      *(_OWORD *)(a5 + 56) = v169;
      v170 = v264;
      *(_OWORD *)(a5 + 72) = v263;
      *(_OWORD *)(a5 + 88) = v170;
      v171 = v260;
      v250 = v230;
      v123 = v166;
      *v241 = v259;
      *(_OWORD *)(a5 + 24) = v171;
    }
    else if (v158 != -1)
    {
      v167 = *((float *)&v254 + 3) * 0.6 <= *((float *)&v260 + 3) && v164 <= 1.0;
      if (!v167 || v164 > 0.55 && v159 * 30.0 < v164)
        goto LABEL_256;
    }
LABEL_249:
    if (!BYTE8(v262))
    {
      v255 = v261;
      v256 = v262;
      v257 = v263;
      v258 = v264;
      v253 = v259;
      v254 = v260;
      v159 = v159 * 0.2 + v164 * 0.8;
      v158 = v230;
      v31 = v230-- <= (int)v160;
      if (v31)
      {
        v157 = 0;
        v158 = v160;
        goto LABEL_257;
      }
      continue;
    }
    break;
  }
  v157 = 0;
  if (a6 != -1 && a6 != 2)
  {
LABEL_256:
    v172 = v256;
    *(_OWORD *)(a5 + 40) = v255;
    *(_OWORD *)(a5 + 56) = v172;
    v173 = v258;
    *(_OWORD *)(a5 + 72) = v257;
    *(_OWORD *)(a5 + 88) = v173;
    v174 = v254;
    *v241 = v253;
    *(_OWORD *)(a5 + 24) = v174;
    v157 = 1;
    v250 = v158;
    *(_DWORD *)a5 = v158;
  }
LABEL_257:
  if (v112 != -1 && v112 != 2 && (v157 & 1) == 0)
  {
    *(_DWORD *)a5 = v158;
    v175 = v256;
    *(_OWORD *)(a5 + 40) = v255;
    *(_OWORD *)(a5 + 56) = v175;
    v176 = v258;
    *(_OWORD *)(a5 + 72) = v257;
    *(_OWORD *)(a5 + 88) = v176;
    v177 = v254;
    *(_OWORD *)(a5 + 8) = v253;
    v250 = v158;
    *(_OWORD *)(a5 + 24) = v177;
  }
  LODWORD(v268) = v250;
  v178 = (uint64_t *)v125;
  if (!seedFill(v125, (uint64_t)v252, v126, v244, (uint64_t)&v268, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold))
  {
    puts("computeBitmask: seedFill failed");
    goto LABEL_277;
  }
  getBitmaskInfoWithSeedPoint((uint64_t)v252, v178, (uint64_t)&v259, v126, v244);
  HIDWORD(v262) = v78;
  *(_QWORD *)&v263 = __PAIR64__(v80, v79);
  if (BYTE8(v262))
  {
LABEL_277:
    termBitmask((void **)v252);
    v82 = v246;
    goto LABEL_148;
  }
  LODWORD(v179) = v234;
  if (v112 != 2)
  {
    v180 = 0;
    v181 = sqrt((float)(int)v260 / 3.14159265);
    v182 = v181 + v181;
    v183 = 0.0;
    do
    {
      v184 = __sincos_stret(v183);
      v185 = v184.__cosval;
      *(float *)&v272[v180] = v185;
      v186 = v184.__sinval;
      *(float *)&v271[v180] = v186;
      v183 = v183 + 0.62832;
      ++v180;
    }
    while (v180 != 10);
    v187 = 0;
    v188 = 0;
    v189 = 0;
    v190 = v182;
    v191 = v190 * 0.5;
    do
    {
      v192 = v191 * *(float *)&v272[v187];
      v193 = v80 + (uint64_t)rintf(v192);
      if (v193 >= 0)
      {
        v194 = v191 * *(float *)&v271[v187];
        v195 = v79 + (uint64_t)rintf(v194);
        if ((v195 & 0x80000000) == 0 && v193 < *(_DWORD *)(a1 + 8) && v195 < *(_DWORD *)(a1 + 12))
        {
          ++v189;
          v188 += *(unsigned __int8 *)(*(_QWORD *)a1 + *(_DWORD *)(a1 + 16) * v195 + *(_DWORD *)(a1 + 28) * v193);
        }
      }
      ++v187;
    }
    while (v187 != 10);
    v179 = (uint64_t)rintf((float)v188 / (float)v189);
  }
  DWORD2(v263) = v179;
  v196 = v262;
  *(_OWORD *)(a5 + 40) = v261;
  *(_OWORD *)(a5 + 56) = v196;
  v197 = v263;
  *(_OWORD *)(a5 + 88) = v264;
  v198 = v260;
  *(_OWORD *)(a5 + 8) = v259;
  *(_OWORD *)(a5 + 24) = v198;
  *(_DWORD *)a5 = v250;
  *(_OWORD *)(a5 + 72) = v197;
  *(_DWORD *)(a5 + 104) = v126;
  *(_DWORD *)(a5 + 108) = v244;
  inited = (void **)v252;
  spreadBitmask((uint64_t)v252, (uint64_t)v246, 0);
  chokeBitmask((uint64_t)v246, (uint64_t)v252, 0);
  v199 = v246;
LABEL_275:
  termBitmask(v199);
  return inited;
}

uint64_t bitIsSet(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  return bitValueFromBitmask(a2, a3, a4);
}

BOOL aboveThreshold(_DWORD *a1, uint64_t a2, int a3, int a4)
{
  return *a1 < (int)*(unsigned __int8 *)(*(_QWORD *)a2 + *(_DWORD *)(a2 + 16) * a4 + *(_DWORD *)(a2 + 28) * a3);
}

float breakoutScore(uint64_t a1, uint64_t a2)
{
  int v2;
  float result;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  double v9;
  double v10;
  float v11;
  double v12;
  float v13;
  float v14;
  float v15;
  double v16;
  float v17;

  v2 = *(_DWORD *)(a1 + 16);
  result = 0.0;
  if (v2 < 6)
    return result;
  v4 = (float)*(int *)(a2 + 16) / (float)v2;
  v5 = *(float *)(a1 + 20);
  v6 = 0.01;
  if (v5 <= 0.0)
    v7 = 0.01;
  else
    v7 = *(float *)(a1 + 20);
  if ((float)(*(float *)(a1 + 24) + *(float *)(a1 + 28)) != 0.0)
    v6 = *(float *)(a1 + 24) + *(float *)(a1 + 28);
  v8 = 1.0;
  if (v4 <= 5.0)
  {
    v9 = v4;
    if (v4 > 3.0)
    {
      v10 = (v9 + -3.0) * 0.125 + 0.75;
LABEL_14:
      v8 = v10;
      goto LABEL_15;
    }
    if (v4 > 1.5)
    {
      v10 = (v9 + -1.5) * 0.3333333 + 0.25;
      goto LABEL_14;
    }
    v8 = 0.0;
    if (v9 > 1.1)
    {
      v10 = (v9 + -1.1) * 0.625;
      goto LABEL_14;
    }
  }
LABEL_15:
  v11 = *(float *)(a2 + 20);
  v12 = v5;
  v13 = 0.0;
  v14 = (float)(*(float *)(a2 + 24) + *(float *)(a2 + 28)) / v6;
  if (v12 >= 0.3 || v11 >= 0.3)
  {
    v15 = v11 / v7;
    v13 = 1.0;
    if (v15 >= 0.25)
    {
      v13 = 0.0;
      if (v15 < 0.5)
        v13 = (0.5 - v15) * 4.0;
    }
  }
  v16 = v14;
  v17 = 1.0;
  if (v14 >= 0.61)
  {
    if (v16 >= 0.8)
    {
      v17 = 0.0;
      if (v14 < 2.0)
        v17 = v14 * -0.5;
    }
    else
    {
      v17 = (0.8 - v16) * 5.26316;
    }
  }
  result = (float)(v8 + v13) + v17;
  if (result < 0.0)
    return 0.0;
  return result;
}

void **recomputeBitmask(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5)
{
  int v10;
  int v11;
  void **inited;
  void **v13;
  void **v14;
  void **v15;
  int v17;

  v11 = *(_DWORD *)(a1 + 8);
  v10 = *(_DWORD *)(a1 + 12);
  inited = (void **)initBitmask(v11, v10);
  if (!inited)
  {
    puts("recomputeBitmask: can not allocate bitmask bm");
    return inited;
  }
  v13 = (void **)initBitmask(v11, v10);
  if (!v13)
  {
    puts("recomputeBitmask: can not allocate bitmask bm2");
    v15 = inited;
LABEL_11:
    termBitmask(v15);
    return 0;
  }
  v14 = v13;
  v17 = a4;
  if (!seedFill(a1, (uint64_t)inited, a2, a3, (uint64_t)&v17, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))aboveThreshold))
  {
    puts("recomputeBitmask: seedFill failed");
LABEL_10:
    termBitmask(inited);
    v15 = v14;
    goto LABEL_11;
  }
  if (a5)
  {
    getBitmaskInfo((uint64_t)inited, (uint64_t *)a1, a5);
    if (*(_BYTE *)(a5 + 56))
      goto LABEL_10;
  }
  spreadBitmask((uint64_t)inited, (uint64_t)v14, 0);
  chokeBitmask((uint64_t)v14, (uint64_t)inited, 0);
  termBitmask(v14);
  return inited;
}

void **extractAlpha(uint64_t a1, uint64_t a2, _BYTE *a3, int *a4)
{
  int v7;
  int v8;
  size_t v9;
  uint64_t v10;
  void **result;
  void **v12;
  uint64_t v13;
  int v14;
  char *v15;
  size_t v16;
  size_t v17;
  int v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  size_t v24;
  size_t v25;
  uint64_t v26;
  size_t v27;
  size_t v28;
  size_t v29;
  size_t v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  size_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  size_t v46;
  size_t v47;
  size_t v48;
  size_t v49;
  uint64_t v50;
  size_t v51;
  size_t v52;
  int v53;
  int v54;
  int v55;
  int v56;
  float v57;
  float v58;
  float v59;
  int v60;
  int v61;
  int v62;
  int v63;
  unsigned __int8 *v64;
  int v65;
  unsigned int v66;
  unsigned __int8 *v67;
  unsigned int v68;
  int v69;
  int v70;
  int v71;
  char v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  _BYTE *v99;
  unsigned int v100;
  _BYTE *v101;
  size_t v102;
  char *v103;
  char *v104;
  uint64_t v105;
  uint64_t v106;
  char *v107;
  char *v108;
  int v109;
  char *v110;
  char *v111;
  uint64_t v112;
  int v113;
  unsigned int v114;
  int v115;
  char v116;
  char v117;
  int v118;
  int *v119;
  const void **v120;
  char *v121;
  uint64_t v122;
  size_t v123;
  size_t v124;
  uint64_t v125;
  size_t v126;
  size_t v127;
  size_t v128;
  uint64_t v129;
  size_t v130;
  size_t v131;
  size_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  size_t v137;
  char *v138;
  uint64_t v139;
  int v140;
  int v141;
  _BYTE *v142;
  int v143;
  int v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  _QWORD *v151;
  unsigned int v152;
  int v153;
  int v154;
  size_t v155;
  int v156;
  int v157;
  unsigned int v158;
  unsigned int v159;
  int v160;
  int v161;
  int v162;
  int v163;
  uint64_t v164;
  int v165;
  int v166;
  int v167;
  int v168;
  int v169;
  int v170;
  int v171;
  size_t v173;
  uint64_t v174;
  size_t v175;
  size_t v176;
  uint64_t v177;
  uint64_t v178;
  size_t v179;
  size_t v180;
  size_t v181;
  void **inited;
  uint64_t v183;
  uint64_t v184;
  char *v185;
  uint64_t v186;
  char *v187;
  char *v188;
  size_t v189;
  size_t v190;
  int v191;
  unsigned int v192;
  char *v193;

  if (!a2)
    return 0;
  v8 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 12);
  v9 = *(int *)(a1 + 16);
  v10 = *(int *)(a1 + 28);
  result = (void **)zmalloc(0x28uLL);
  if (result)
  {
    v12 = result;
    initBitmap((uint64_t)result, v8, v7, 1, 1, 100.0);
    bzero(*v12, *((int *)v12 + 6));
    inited = (void **)initBitmask(v8, v7);
    v140 = v8;
    v141 = v7 - 1;
    v119 = a4;
    v120 = (const void **)v12;
    v155 = v9;
    v139 = 2 * v10;
    v118 = v7;
    if (v7 >= 3)
    {
      v142 = a3;
      v13 = 0;
      v14 = 0;
      v15 = (char *)*v12;
      v150 = -(int)v9;
      v151 = (_QWORD *)a1;
      v149 = v150 - v10;
      v148 = (int)v10 - (int)v9;
      v147 = -v10;
      v146 = (int)v9 - (int)v10;
      v145 = (int)v10 + (int)v9;
      v143 = v7 - 2;
      v144 = v8 - 2;
      v137 = (size_t)*v12 + v10 + v9;
      v136 = (uint64_t)*v12 + 2 * v10;
      v134 = (uint64_t)*v12 + 2 * v10 + 2 * v9;
      v135 = (uint64_t)*v12 + v10;
      v16 = v10 + 2 * v9;
      v133 = (uint64_t)*v12 + v16;
      v132 = (size_t)*v12 + v9;
      v17 = v9 + 2 * v10;
      v130 = *(_QWORD *)a1 + v9 + v150;
      v131 = (size_t)*v12 + v17;
      v129 = *(_QWORD *)a1 + v10;
      v128 = *(_QWORD *)a1 + v10 + v9 + v148;
      v127 = *(_QWORD *)a1 + v9;
      v126 = *(_QWORD *)a1 + v17;
      v125 = *(_QWORD *)a1 + v16;
      v124 = *(_QWORD *)a1 + v10 + v9 + v145;
      v123 = *(_QWORD *)a1 + v10 + v9;
      v161 = 2 - v8;
      v18 = 1;
      v138 = v15;
      v121 = &v15[2 * v9];
      v122 = *(_QWORD *)a1 + 2 * v9;
      v164 = v10;
      while (v8 <= 2)
      {
        v97 = v18 + 1;
LABEL_108:
        v13 += v9;
        v18 = v97;
        if (v97 == v141)
          goto LABEL_112;
      }
      v156 = v14;
      v19 = v18 - 1;
      v163 = v18 + 1;
      v20 = 1;
      v190 = v123;
      v22 = v124;
      v21 = v125;
      v23 = v122;
      v24 = v126;
      v25 = v127;
      v27 = v128;
      v26 = v129;
      v28 = v130;
      v29 = v131;
      v30 = v132;
      v187 = v121;
      v186 = v133;
      v31 = v134;
      v185 = v138;
      v184 = v135;
      v183 = v136;
      v189 = v137;
      v169 = v18;
      v162 = v18 - 1;
      while (1)
      {
        v179 = v30;
        v180 = v29;
        v173 = v28;
        v168 = *(unsigned __int8 *)(v28 + v13);
        v174 = v26;
        v165 = *(unsigned __int8 *)(v26 + v13);
        v32 = v20;
        v33 = v19;
        v34 = v21;
        v35 = v23;
        v36 = v24;
        v170 = bitValueFromBitmask(a2, v20, v33);
        v175 = v27;
        v166 = *(unsigned __int8 *)(v27 + v13);
        v181 = v25;
        v167 = *(unsigned __int8 *)(v25 + v13);
        v37 = bitValueFromBitmask(a2, v32 - 1, v18);
        v38 = bitValueFromBitmask(a2, v32, v18);
        v176 = v36;
        v39 = *(unsigned __int8 *)(v36 + v13);
        v192 = v32 + 1;
        v40 = bitValueFromBitmask(a2, v32 + 1, v18);
        v177 = v35;
        v178 = v34;
        v41 = *(unsigned __int8 *)(v35 + v13);
        v42 = *(unsigned __int8 *)(v34 + v13);
        v43 = bitValueFromBitmask(a2, v32, v163);
        if (v38 != 1)
          break;
        v160 = v39;
        v158 = v32 - 1;
        v159 = v32;
        if (v37 + v170 + v40 + v43 == 4)
          break;
        v53 = *(unsigned __int8 *)(v22 + v13);
        v54 = v166 - (v168 + v41) + 2 * (v39 - v167) + v53;
        v55 = v41 - (v166 + v168) + v53 + 2 * (v42 - v165);
        v56 = v54 * v54 + v55 * v55;
        if (!v56)
        {
          v18 = v169;
          v19 = v162;
          goto LABEL_10;
        }
        v171 = *(unsigned __int8 *)(v22 + v13);
        v57 = 1.0 / sqrtf((float)v56);
        v58 = v57 * (float)v54;
        v59 = v57 * (float)v55;
        v60 = v32 + (uint64_t)rintf(v58 + v58);
        v61 = v169 + (uint64_t)rintf(v59 + v59);
        v62 = v32 - (uint64_t)rintf(v58 * 3.0);
        v63 = v169 - (uint64_t)rintf(v59 * 3.0);
        if (v60 <= 1)
          v60 = 1;
        if (v60 >= v144)
          v60 = v144;
        if (v61 <= 1)
          v61 = 1;
        if (v61 >= v143)
          v61 = v143;
        if (v62 <= 1)
          v62 = 1;
        if (v62 >= v144)
          v62 = v144;
        if (v63 <= 1)
          v63 = 1;
        if (v63 >= v143)
          v65 = v143;
        else
          v65 = v63;
        v64 = (unsigned __int8 *)(*v151 + v61 * (int)v155 + v60 * (int)v164);
        v66 = (v64[v149]
             + v64[v148]
             + 4 * *v64
             + v64[v146]
             + v64[v145]
             + 2 * (v64[v147] + v64[v150] + v64[v164] + v64[v155])
             + 8) >> 4;
        v67 = (unsigned __int8 *)(*v151 + v65 * (int)v155 + v62 * (int)v164);
        v68 = (v67[v149]
             + v67[v148]
             + 4 * *v67
             + v67[v146]
             + v67[v145]
             + 2 * (v67[v147] + v67[v150] + v67[v164] + v67[v155])
             + 8) >> 4;
        v154 = v42;
        v153 = v41;
        if (v156 <= 399)
        {
          *v142 = v159;
          v142[1] = v169;
          v142[2] = v60;
          v142[3] = v61;
          v142[4] = v62;
          v142[5] = v65;
          v142[6] = v66;
          v142[7] = v68;
          v142 += 8;
          ++v156;
        }
        v19 = v162;
        v49 = v180;
        v48 = v181;
        v52 = v179;
        if (v66 != v68)
        {
          v69 = (__int16)(16320 / (__int16)(v66 - v68));
          v70 = (*(unsigned __int8 *)(v190 + v13) - v68) * v69;
          v71 = (v70 + 32) >> 6;
          if (v71 >= 255)
            LOBYTE(v71) = -1;
          if (v70 >= -32)
            v72 = v71;
          else
            v72 = 0;
          *(_BYTE *)(v189 + v13) = v72;
          setBitInBitmask((uint64_t)inited, v159, v169, 1);
          v152 = v68;
          v73 = (v168 - v68) * v69;
          v74 = (v73 + 32) >> 6;
          if (v74 >= 255)
            v74 = 255;
          if (v73 >= -32)
            v75 = v74;
          else
            v75 = 0;
          if (bitValueFromBitmask((uint64_t)inited, v158, v162))
          {
            v185[v13] = (v75 + v185[v13] + 1) >> 1;
          }
          else
          {
            v185[v13] = v75;
            setBitInBitmask((uint64_t)inited, v158, v162, 1);
          }
          v76 = (v165 - v68) * v69;
          v77 = (v76 + 32) >> 6;
          if (v77 >= 255)
            v77 = 255;
          if (v76 >= -32)
            v78 = v77;
          else
            v78 = 0;
          if (bitValueFromBitmask((uint64_t)inited, v159, v162))
          {
            *(_BYTE *)(v184 + v13) = (v78 + *(unsigned __int8 *)(v184 + v13) + 1) >> 1;
          }
          else
          {
            *(_BYTE *)(v184 + v13) = v78;
            setBitInBitmask((uint64_t)inited, v159, v162, 1);
          }
          v79 = (v166 - v68) * v69;
          v80 = (v79 + 32) >> 6;
          if (v80 >= 255)
            v80 = 255;
          if (v79 >= -32)
            v81 = v80;
          else
            v81 = 0;
          if (bitValueFromBitmask((uint64_t)inited, v192, v162))
          {
            *(_BYTE *)(v183 + v13) = (v81 + *(unsigned __int8 *)(v183 + v13) + 1) >> 1;
          }
          else
          {
            *(_BYTE *)(v183 + v13) = v81;
            setBitInBitmask((uint64_t)inited, v192, v162, 1);
          }
          v82 = (v167 - v68) * v69;
          v83 = (v82 + 32) >> 6;
          if (v83 >= 255)
            v83 = 255;
          if (v82 >= -32)
            v84 = v83;
          else
            v84 = 0;
          if (bitValueFromBitmask((uint64_t)inited, v158, v169))
          {
            *(_BYTE *)(v179 + v13) = (v84 + *(unsigned __int8 *)(v179 + v13) + 1) >> 1;
          }
          else
          {
            *(_BYTE *)(v179 + v13) = v84;
            setBitInBitmask((uint64_t)inited, v158, v169, 1);
          }
          v85 = (v160 - v68) * v69;
          v86 = (v85 + 32) >> 6;
          if (v86 >= 255)
            v86 = 255;
          if (v85 >= -32)
            v87 = v86;
          else
            v87 = 0;
          if (bitValueFromBitmask((uint64_t)inited, v192, v169))
          {
            *(_BYTE *)(v180 + v13) = (v87 + *(unsigned __int8 *)(v180 + v13) + 1) >> 1;
          }
          else
          {
            *(_BYTE *)(v180 + v13) = v87;
            setBitInBitmask((uint64_t)inited, v192, v169, 1);
          }
          v88 = (v153 - v68) * v69;
          v89 = (v88 + 32) >> 6;
          if (v89 >= 255)
            v89 = 255;
          if (v88 >= -32)
            v90 = v89;
          else
            v90 = 0;
          if (bitValueFromBitmask((uint64_t)inited, v158, v163))
          {
            v187[v13] = (v90 + v187[v13] + 1) >> 1;
          }
          else
          {
            v187[v13] = v90;
            setBitInBitmask((uint64_t)inited, v158, v163, 1);
          }
          v91 = (v154 - v68) * v69;
          v92 = (v91 + 32) >> 6;
          if (v92 >= 255)
            v92 = 255;
          if (v91 >= -32)
            v93 = v92;
          else
            v93 = 0;
          if (bitValueFromBitmask((uint64_t)inited, v159, v163))
          {
            *(_BYTE *)(v186 + v13) = (v93 + *(unsigned __int8 *)(v186 + v13) + 1) >> 1;
          }
          else
          {
            *(_BYTE *)(v186 + v13) = v93;
            setBitInBitmask((uint64_t)inited, v159, v163, 1);
          }
          v10 = v164;
          v94 = (v171 - v152) * v69;
          v95 = (v94 + 32) >> 6;
          if (v95 >= 255)
            v95 = 255;
          if (v94 >= -32)
            v96 = v95;
          else
            v96 = 0;
          if (bitValueFromBitmask((uint64_t)inited, v192, v163))
          {
            *(_BYTE *)(v31 + v13) = (v96 + *(unsigned __int8 *)(v31 + v13) + 1) >> 1;
          }
          else
          {
            *(_BYTE *)(v31 + v13) = v96;
            setBitInBitmask((uint64_t)inited, v192, v163, 1);
          }
          v18 = v169;
          v19 = v162;
          v48 = v181;
          v45 = v177;
          v44 = v178;
          v47 = v175;
          v46 = v176;
          v51 = v173;
          v50 = v174;
          goto LABEL_12;
        }
        v18 = v169;
        v45 = v177;
        v44 = v178;
        v47 = v175;
        v46 = v176;
        v51 = v173;
        v50 = v174;
LABEL_11:
        v10 = v164;
LABEL_12:
        v28 = v51 + v10;
        v26 = v50 + v10;
        v27 = v47 + v10;
        v25 = v48 + v10;
        v24 = v46 + v10;
        v23 = v45 + v10;
        v21 = v44 + v10;
        v22 += v10;
        v189 += v10;
        v183 += v10;
        v184 += v10;
        v185 += v10;
        v31 += v10;
        v186 += v10;
        v187 += v10;
        v30 = v52 + v10;
        v29 = v49 + v10;
        v190 += v10;
        v20 = v192;
        if (v161 + v192 == 1)
        {
          v8 = v140;
          v9 = v155;
          v14 = v156;
          v97 = v163;
          goto LABEL_108;
        }
      }
      v18 = v169;
      v19 = v162;
LABEL_10:
      v45 = v177;
      v44 = v178;
      v47 = v175;
      v46 = v176;
      v49 = v180;
      v48 = v181;
      v51 = v173;
      v50 = v174;
      v52 = v179;
      goto LABEL_11;
    }
    v14 = 0;
LABEL_112:
    v157 = v14;
    if (v118 >= 1)
    {
      v98 = 0;
      v99 = *v120;
      do
      {
        if (v8 >= 1)
        {
          v100 = 0;
          v101 = v99;
          do
          {
            if (!bitValueFromBitmask((uint64_t)inited, v100, v98))
            {
              if (bitValueFromBitmask(a2, v100, v98))
              {
                *v101 = -1;
                setBitInBitmask((uint64_t)inited, v100, v98, 1);
              }
              else
              {
                *v101 = 0;
              }
            }
            ++v100;
            v101 += v10;
          }
          while (v8 != v100);
        }
        ++v98;
        v99 += v9;
      }
      while (v98 != v118);
    }
    termBitmask(inited);
    v188 = (char *)zmalloc(2 * v9);
    memmove(v188, *v120, v9);
    if (v118 >= 3)
    {
      v102 = v9;
      v103 = &v188[v9];
      v104 = (char *)*v120;
      v105 = (uint64_t)*v120 + 2 * v102;
      v106 = (uint64_t)*v120 + 2 * v102 + v10;
      v107 = (char *)*v120 + v10 + v102 + (int)v10 + (int)v102;
      v108 = (char *)*v120 + v10 + v102;
      v109 = 1;
      v110 = v188;
      do
      {
        v191 = v109;
        v111 = v110;
        v193 = &v104[v102];
        memmove(v103, &v104[v102], v102);
        if (v140 >= 3)
        {
          v112 = 0;
          v113 = v140 - 2;
          do
          {
            v114 = v111[v139 + v112]
                 + v111[v112]
                 + 4 * v103[v10 + v112]
                 + *(unsigned __int8 *)(v105 + v112)
                 + v107[v112]
                 + 2
                 * (v103[v112]
                  + v111[v10 + v112]
                  + v103[v139 + v112]
                  + *(unsigned __int8 *)(v106 + v112));
            v115 = (int)(5100 * ((v114 + 8) >> 4) - 650752) >> 12;
            if (v115 >= 127)
              LOBYTE(v115) = 127;
            v116 = v115 ^ 0x80;
            if (v114 >= 0x188)
              v117 = v116;
            else
              v117 = 0;
            v108[v112] = v117;
            v112 += v10;
            --v113;
          }
          while (v113);
        }
        v109 = v191 + 1;
        v102 = v155;
        v105 += v155;
        v106 += v155;
        v107 += v155;
        v108 += v155;
        v110 = v103;
        v103 = v111;
        v104 = v193;
      }
      while (v191 + 1 != v141);
    }
    zfree(v188);
    result = (void **)v120;
    *v119 = v157;
  }
  return result;
}

void featheredOutsize(uint64_t a1, _DWORD *a2, _DWORD *a3, float a4, float a5, float a6)
{
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  _BYTE *v15;
  char v16;
  int v17;
  int v18;
  _BYTE *v19;
  int v20;
  float v21;
  uint64_t v22;
  double v23;
  uint64_t v24;
  uint64_t v25;
  double v26;
  float v27;
  int v28;
  int v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  uint64_t v37;
  _BYTE *v38;
  unint64_t v39;
  int v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  int v51;
  _BYTE *v52;
  int v53;
  unsigned int v54;
  int v55;
  unsigned __int8 *v56;
  int v57;
  int v58;
  unsigned int v59;
  _BYTE *v60;
  int v61;
  int v62;
  int *v63;
  int v64;
  uint64_t v65;
  int *v66;
  int v67;
  int v68;
  _BYTE *v69;
  int v70;
  char *v71;
  int v72;
  uint64_t v73;
  _BYTE *v74;
  int v75;
  unsigned int v76;
  _BYTE *v77;
  int v78;
  int v79;
  int *v80;
  int v81;
  uint64_t v82;
  int *v83;
  int v84;
  int v85;
  int v86;
  int v87;
  _BYTE *v88;
  unsigned __int8 *v89;
  int v90;
  uint64_t v91;
  int v92;
  char v93;
  int v94;
  uint64_t v95;
  void *__dst[2];
  __int128 v97;
  uint64_t v98;
  _OWORD v99[12];
  uint64_t v100;
  _BYTE v101[200];
  uint64_t v102;

  v102 = *MEMORY[0x1E0C80C00];
  v98 = 0;
  *(_OWORD *)__dst = 0u;
  v97 = 0u;
  v7 = *(_DWORD *)(a1 + 12);
  if (v7 < 1)
  {
    v12 = 0;
    v21 = 0.0;
  }
  else
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = *(_DWORD *)(a1 + 8);
    v15 = *(_BYTE **)a1;
    v16 = 1;
    do
    {
      v17 = v13 + 1;
      if (v14 >= 1)
      {
        v18 = 0;
        v19 = v15;
        do
        {
          if (*v19)
          {
            v12 += *v19 | (*v19 << 8);
            if (v13 < v11)
              v11 = v13;
            if (v13 >= v9)
              v9 = v13 + 1;
            if (v18 < v10)
              v10 = v18;
            v20 = v18 + 1;
            if (v18 >= v8)
              v8 = v18 + 1;
            if ((v16 & 1) != 0)
              v11 = v13;
            else
              v20 = v18 + 1;
            if ((v16 & 1) != 0)
            {
              v10 = v18;
              v9 = v13 + 1;
              v8 = v18 + 1;
            }
            v18 = v20;
            v16 = 0;
          }
          else
          {
            ++v18;
          }
          v19 += *(int *)(a1 + 28);
        }
        while (v18 != v14);
      }
      v15 += *(int *)(a1 + 16);
      ++v13;
    }
    while (v17 != v7);
    v21 = (float)((v8 - v10) * (v9 - v11)) * 0.785398163;
  }
  v22 = (uint64_t)rintf((float)v12 / 65535.0);
  *a3 = (uint64_t)rintf(v21);
  *a2 = v22;
  if ((_DWORD)v22)
  {
    v23 = sqrt((float)(int)v22 / 3.14159265);
    *(float *)&v23 = v23 + v23;
    v95 = *(int *)(a1 + 16);
    v24 = (uint64_t)rintf(a5 * 255.0);
    v25 = (uint64_t)rintf(a6 * 4096.0);
    v100 = 0;
    v26 = *(float *)&v23 * 0.125;
    memset(&v99[10], 0, 32);
    if (v26 >= a4)
      v27 = a4;
    else
      v27 = v26;
    memset(v99, 0, 160);
    v28 = 1;
    v29 = 4;
    do
    {
      v30 = (float)(v29 + 1) * -0.5;
      v31 = (float)(v30 / v27) * 0.7071067;
      v32 = (erff(v31) + 1.0) * 0.5;
      v33 = (float)((float)(v30 + 1.0) / v27) * 0.7071067;
      v34 = (erff(v33) + 1.0) * 0.5;
      v35 = (float)((float)(v30 + 2.0) / v27) * 0.7071067;
      v36 = (erff(v35) + 1.0) * 0.5;
      ++v28;
      v29 += 2;
    }
    while ((float)((float)(v34 - v32) + v32) >= (float)((float)(v36 - v34) * 0.75));
    v37 = 0;
    v38 = &v101[4 * v28];
    v39 = (v28 + 1);
    v40 = v39;
    do
    {
      v41 = (float)((float)(v30 + 1.0) / v27) * 0.7071067;
      v42 = (erff(v41) + 1.0) * 0.5;
      v43 = (float)(v30 / v27) * 0.7071067;
      v44 = (erff(v43) + 1.0) * 0.5;
      v45 = v42 - v44;
      v46 = -0.0;
      if (!v37)
        v46 = v32;
      *(float *)&v38[v37] = v46 + v45;
      --v40;
      v37 -= 4;
      v30 = v30 + 1.0;
    }
    while (v40 > 0);
    v47 = 0;
    if (v39 <= 1)
      v48 = 1;
    else
      v48 = v39;
    v49 = 4 * v48;
    do
    {
      *(_DWORD *)((char *)v99 + v47) = llround(*(float *)&v101[v47] * 65536.0);
      v47 += 4;
    }
    while (v49 != v47);
    v50 = v29 & 0x7FFFFFFE;
    v51 = (v29 & 0x7FFFFFFE) - 1;
    initBitmap((uint64_t)__dst, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 28), *(_DWORD *)(a1 + 32), *(float *)(a1 + 36));
    memcpy(__dst[0], *(const void **)a1, *(int *)(a1 + 16) * (uint64_t)*(int *)(a1 + 12));
    v52 = zmalloc(SLODWORD(__dst[1]));
    if (v51 >= 0)
      v53 = v51;
    else
      v53 = v50;
    v54 = v53 >> 1;
    if (SHIDWORD(__dst[1]) >= 1)
    {
      v55 = 0;
      v56 = (unsigned __int8 *)__dst[0];
      do
      {
        v57 = (int)__dst[1];
        if (SLODWORD(__dst[1]) >= 1)
        {
          v58 = 0;
          v59 = v54 + 1;
          v60 = v52;
          do
          {
            v61 = v58 - v54;
            if (v50 < 3)
            {
              v62 = 0;
            }
            else
            {
              v62 = 0;
              v63 = (int *)v99 + v54;
              do
              {
                v64 = *v63--;
                v62 += v64 * v56[v61 & ~(v61 >> 31)];
                ++v61;
              }
              while (v61 < v58);
            }
            if (v61 <= (int)(v58 + v54))
            {
              v65 = v59 - v61;
              v66 = (int *)v99;
              do
              {
                if (v61 >= v57)
                  v67 = v57 - 1;
                else
                  v67 = v61;
                v68 = *v66++;
                v62 += v68 * v56[v67];
                ++v61;
                --v65;
              }
              while (v65);
            }
            *v60++ = (v62 + 0x8000) >> 16;
            ++v58;
            v57 = (int)__dst[1];
            ++v59;
          }
          while (v58 < SLODWORD(__dst[1]));
        }
        memcpy(v56, v52, v57);
        ++v55;
        v56 += (int)v97;
      }
      while (v55 < SHIDWORD(__dst[1]));
    }
    zfree(v52);
    v69 = zmalloc(SHIDWORD(__dst[1]));
    if (SLODWORD(__dst[1]) >= 1)
    {
      v70 = 0;
      v71 = (char *)__dst[0];
      v72 = HIDWORD(__dst[1]);
      do
      {
        if (v72 >= 1)
        {
          v73 = 0;
          v74 = v71;
          do
          {
            v69[v73] = *v74;
            v72 = HIDWORD(__dst[1]);
            v74 += (int)v97;
            ++v73;
          }
          while ((int)v73 < SHIDWORD(__dst[1]));
          if (SHIDWORD(__dst[1]) >= 1)
          {
            v75 = 0;
            v76 = v54 + 1;
            v77 = v71;
            do
            {
              v78 = v75 - v54;
              if (v50 < 3)
              {
                v79 = 0;
              }
              else
              {
                v79 = 0;
                v80 = (int *)v99 + v54;
                do
                {
                  v81 = *v80--;
                  v79 += v81 * v69[v78 & ~(v78 >> 31)];
                  ++v78;
                }
                while (v78 < v75);
              }
              if (v78 <= (int)(v75 + v54))
              {
                v82 = v76 - v78;
                v83 = (int *)v99;
                do
                {
                  if (v78 >= v72)
                    v84 = v72 - 1;
                  else
                    v84 = v78;
                  v85 = *v83++;
                  v79 += v85 * v69[v84];
                  ++v78;
                  --v82;
                }
                while (v82);
              }
              *v77 = (v79 + 0x8000) >> 16;
              ++v75;
              v72 = HIDWORD(__dst[1]);
              v77 += (int)v97;
              ++v76;
            }
            while (v75 < SHIDWORD(__dst[1]));
          }
        }
        ++v70;
        ++v71;
      }
      while (v70 < SLODWORD(__dst[1]));
    }
    zfree(v69);
    v86 = *(_DWORD *)(a1 + 12);
    if (v86 >= 1)
    {
      v87 = 0;
      v88 = *(_BYTE **)a1;
      v89 = (unsigned __int8 *)__dst[0];
      v90 = *(_DWORD *)(a1 + 8);
      do
      {
        if (v90 >= 1)
        {
          v91 = 0;
          do
          {
            v92 = (v89[v91] - (_DWORD)v24) * v25;
            if (v92 >= -526336)
            {
              v94 = (v92 + 2048) >> 12;
              if (v94 >= 127)
                LOBYTE(v94) = 127;
              v93 = v94 + 0x80;
            }
            else
            {
              v93 = 0;
            }
            v88[v91] = v93;
            v90 = *(_DWORD *)(a1 + 8);
            ++v91;
          }
          while ((int)v91 < v90);
          v86 = *(_DWORD *)(a1 + 12);
        }
        ++v87;
        v89 += v95;
        v88 += v95;
      }
      while (v87 < v86);
    }
    termBitmap(__dst);
  }
}

void computeRedChannel(unsigned __int8 **a1, unsigned __int8 **a2, uint64_t a3, int a4)
{
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  unsigned __int8 *v12;
  _BYTE *v13;
  uint64_t v14;
  unsigned __int8 *v15;
  _BYTE *v16;
  unsigned __int8 *v17;
  int v18;
  int v19;
  int v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int8 *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  int v44;
  __int16 v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  int v50;
  int v51;
  unsigned int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  __int16 v57;
  unsigned __int8 *v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  unsigned int v66;
  int v67;
  int v68;
  int v69;
  __int16 v70;
  int v71;
  unsigned int v72;
  unsigned int v73;
  int v74;
  int v75;
  int v76;
  unsigned int v77;
  int v78;
  int v79;
  int v80;
  unsigned __int8 *v81;
  unsigned __int8 *v82;
  __int16 v83;
  int v84;
  int v85;
  uint64_t v86;
  int v87;
  int v88;
  uint64_t v89;
  int v90;
  unsigned __int8 *v91;
  _BYTE *v92;
  unsigned __int8 *v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;

  v7 = *((_DWORD *)a1 + 3);
  v89 = *((int *)a1 + 4);
  v8 = *((int *)a1 + 7);
  v9 = *((_DWORD *)a2 + 4);
  v98 = *((int *)a2 + 7);
  v90 = *((_DWORD *)a1 + 2);
  initBitmap(a3, v90, v7, 1, 1, 100.0);
  bzero(*(void **)a3, *(int *)(a3 + 24));
  v87 = v7 - 1;
  v88 = v7;
  if (v7 >= 1)
  {
    v10 = 0;
    v11 = 0;
    v12 = *a2;
    v84 = -v9;
    v13 = *(_BYTE **)a3;
    v14 = (uint64_t)*a1;
    v96 = *(_QWORD *)a3 + v8;
    v97 = 2 * (int)v8;
    v15 = &(*a1)[v8];
    v16 = *(_BYTE **)a3;
    v17 = *a1;
    v86 = v8;
    v85 = v9;
    while (2)
    {
      if (v11 == v87)
        v18 = 0;
      else
        v18 = v9;
      v19 = v84;
      if (!v11)
        v19 = 0;
      v20 = v11 & 1;
      if ((v11 & 1) != 0)
        v19 = v18;
      v21 = &v12[v19];
      v22 = *v12;
      v23 = v12[1];
      v24 = *v21;
      v25 = v21[1];
      v95 = v10;
      v94 = v11;
      v92 = v16;
      v93 = v12;
      v91 = v17;
      if (v90 < 3)
      {
        v33 = *v12;
        v32 = v12[1];
        v31 = *v21;
        v30 = v21[1];
        v58 = v17;
        v29 = v12;
      }
      else
      {
        v26 = 0;
        v27 = v19;
        v28 = v10;
        v29 = v12;
        v30 = v25;
        v31 = v24;
        v32 = v12[1];
        v33 = *v12;
        do
        {
          v34 = *(unsigned __int8 *)(v14 + v28);
          v35 = ((9 * v22 + v31 + 3 * (v24 + v33) + 8) >> 4) - 128;
          v36 = ((9 * v23 + v30 + 3 * (v25 + v32) + 8) >> 4) - 128;
          v37 = v34 + ((int)(22970 * v36 + 0x2000) >> 14);
          v38 = v34 + ((int)(-11700 * v36 - 5638 * v35 + 0x2000) >> 14);
          v39 = v34 + ((int)(29032 * v35 + 0x2000) >> 14);
          if (v37 >= 255)
            v40 = 255;
          else
            v40 = v37;
          v41 = v40 & ~(v40 >> 31);
          if (v38 >= 255)
            v38 = 255;
          v42 = v38 & ~(v38 >> 31);
          if (v39 >= 255)
            v39 = 255;
          v43 = v39 & ~(v39 >> 31);
          switch(a4)
          {
            case 1:
              if (v42 > v43)
                v43 = v38 & ~(v38 >> 31);
              goto LABEL_29;
            case 2:
              if (v40 < 1)
              {
                LOBYTE(v41) = 0;
              }
              else
              {
                if (v42 > v43)
                  v43 = v38 & ~(v38 >> 31);
                v45 = (v41 - v43) & ~(unsigned __int16)((int)(v41 - v43) >> 31);
                v41 = (unsigned __int16)(v45 * v45)
                    / (unsigned __int16)(v40 & ~(unsigned __int16)(v40 >> 31));
LABEL_32:
                if (v41 >= 0xFF)
                  LOBYTE(v41) = -1;
              }
              break;
            case 3:
              v43 = v42 + ((v41 * v42 + 128) >> 8);
LABEL_29:
              v44 = v41 - v43;
              goto LABEL_30;
            case 4:
              v41 = ((unsigned __int16)(v41 & 0x3FF) << 6) / (unsigned __int16)(v42 + v43 + 1);
              goto LABEL_32;
            case 5:
              break;
            default:
              v44 = v41 - ((v42 + v43 + 1) >> 1);
LABEL_30:
              v41 = v44 & ~(v44 >> 31);
              break;
          }
          v13[v28] = v41;
          v46 = v15[v28];
          v33 = *v29;
          v32 = v29[1];
          v22 = v29[2];
          v23 = v29[3];
          v31 = v29[v27];
          v30 = v29[v27 + 1];
          v24 = v29[v27 + 2];
          v25 = v29[v27 + 3];
          v47 = ((9 * v33 + v24 + 3 * (v31 + v22) + 8) >> 4) - 128;
          v48 = ((9 * v32 + v25 + 3 * (v30 + v23) + 8) >> 4) - 128;
          v49 = v46 + ((int)(-11700 * v48 - 5638 * v47 + 0x2000) >> 14);
          v50 = v46 + ((int)(29032 * v47 + 0x2000) >> 14);
          if (v46 + ((int)(22970 * v48 + 0x2000) >> 14) >= 255)
            v51 = 255;
          else
            v51 = v46 + ((int)(22970 * v48 + 0x2000) >> 14);
          v52 = v51 & ~(v51 >> 31);
          if (v49 >= 255)
            v53 = 255;
          else
            v53 = v49;
          v54 = v53 & ~(v53 >> 31);
          if (v50 >= 255)
            v50 = 255;
          v55 = v50 & ~(v50 >> 31);
          switch(a4)
          {
            case 1:
              if (v54 <= v55)
                v54 = v50 & ~(v50 >> 31);
              goto LABEL_51;
            case 2:
              if (v51 < 1)
              {
                LOBYTE(v52) = 0;
              }
              else
              {
                if (v54 <= v55)
                  v54 = v50 & ~(v50 >> 31);
                v57 = (v52 - v54) & ~(unsigned __int16)((int)(v52 - v54) >> 31);
                v52 = (unsigned __int16)(v57 * v57)
                    / (unsigned __int16)(v51 & ~(unsigned __int16)(v51 >> 31));
LABEL_54:
                if (v52 >= 0xFF)
                  LOBYTE(v52) = -1;
              }
              break;
            case 3:
              v54 += (v52 * v54 + 128) >> 8;
LABEL_51:
              v56 = v52 - v54;
              goto LABEL_52;
            case 4:
              v52 = ((unsigned __int16)(v52 & 0x3FF) << 6) / (unsigned __int16)(v54 + v55 + 1);
              goto LABEL_54;
            case 5:
              break;
            default:
              v56 = v52 - ((v54 + v55 + 1) >> 1);
LABEL_52:
              v52 = v56 & ~(v56 >> 31);
              break;
          }
          *(_BYTE *)(v96 + v28) = v52;
          v29 += v98;
          v26 += 2;
          v28 += v97;
        }
        while (v26 < v90 - 2);
        v16 = &v13[v28];
        v21 = &v29[v27];
        v58 = (unsigned __int8 *)(v14 + v28);
      }
      v59 = *v58;
      v60 = ((9 * v22 + v31 + 3 * (v24 + v33) + 8) >> 4) - 128;
      v61 = ((9 * v23 + v30 + 3 * (v25 + v32) + 8) >> 4) - 128;
      v62 = v59 + ((int)(22970 * v61 + 0x2000) >> 14);
      v63 = v59 + ((int)(-11700 * v61 - 5638 * v60 + 0x2000) >> 14);
      v64 = v59 + ((int)(29032 * v60 + 0x2000) >> 14);
      if (v62 >= 255)
        v65 = 255;
      else
        v65 = v62;
      v66 = v65 & ~(v65 >> 31);
      if (v63 >= 255)
        v63 = 255;
      v67 = v63 & ~(v63 >> 31);
      if (v64 >= 255)
        v64 = 255;
      v68 = v64 & ~(v64 >> 31);
      switch(a4)
      {
        case 1:
          if (v67 > v68)
            v68 = v63 & ~(v63 >> 31);
          goto LABEL_78;
        case 2:
          if (v65 < 1)
          {
            LOBYTE(v66) = 0;
          }
          else
          {
            if (v67 > v68)
              v68 = v63 & ~(v63 >> 31);
            v70 = (v66 - v68) & ~(unsigned __int16)((int)(v66 - v68) >> 31);
            v66 = (unsigned __int16)(v70 * v70) / (unsigned __int16)(v65 & ~(unsigned __int16)(v65 >> 31));
LABEL_81:
            if (v66 >= 0xFF)
              LOBYTE(v66) = -1;
          }
          break;
        case 3:
          v68 = v67 + ((v66 * v67 + 128) >> 8);
LABEL_78:
          v69 = v66 - v68;
          goto LABEL_79;
        case 4:
          v66 = ((unsigned __int16)(v66 & 0x3FF) << 6) / (unsigned __int16)(v67 + v68 + 1);
          goto LABEL_81;
        case 5:
          break;
        default:
          v69 = v66 - ((v67 + v68 + 1) >> 1);
LABEL_79:
          v66 = v69 & ~(v69 >> 31);
          break;
      }
      *v16 = v66;
      v71 = v58[v86];
      v72 = ((9 * *v29 + *v21 + 3 * (*v21 + *v29) + 8) >> 4) - 128;
      v73 = ((9 * v29[1] + v21[1] + 3 * (v21[1] + v29[1]) + 8) >> 4) - 128;
      v74 = v71 + ((int)(-11700 * v73 - 5638 * v72 + 0x2000) >> 14);
      v75 = v71 + ((int)(29032 * v72 + 0x2000) >> 14);
      if (v71 + ((int)(22970 * v73 + 0x2000) >> 14) >= 255)
        v76 = 255;
      else
        v76 = v71 + ((int)(22970 * v73 + 0x2000) >> 14);
      v77 = v76 & ~(v76 >> 31);
      if (v74 >= 255)
        v78 = 255;
      else
        v78 = v74;
      v79 = v78 & ~(v78 >> 31);
      if (v75 >= 255)
        v75 = 255;
      v80 = v75 & ~(v75 >> 31);
      v9 = v85;
      v81 = v93;
      v82 = v91;
      switch(a4)
      {
        case 1:
          if (v79 <= v80)
            v79 = v80;
          goto LABEL_100;
        case 2:
          if (v76 < 1)
          {
            LOBYTE(v77) = 0;
          }
          else
          {
            if (v79 <= v80)
              v79 = v80;
            v83 = (v77 - v79) & ~(unsigned __int16)((int)(v77 - v79) >> 31);
            v77 = (unsigned __int16)(v83 * v83) / (unsigned __int16)(v76 & ~(unsigned __int16)(v76 >> 31));
LABEL_102:
            if (v77 >= 0xFF)
              LOBYTE(v77) = -1;
          }
LABEL_104:
          v16[v86] = v77;
          v12 = &v81[v20 * v9];
          v11 = v94 + 1;
          v17 = &v82[v89];
          v16 = &v92[v89];
          v10 = v95 + v89;
          if (v94 + 1 == v88)
            return;
          continue;
        case 3:
          v79 += (v77 * v79 + 128) >> 8;
LABEL_100:
          v77 = (v77 - v79) & ~((int)(v77 - v79) >> 31);
          goto LABEL_104;
        case 4:
          v77 = ((unsigned __int16)(v77 & 0x3FF) << 6) / (unsigned __int16)(v79 + v80 + 1);
          goto LABEL_102;
        case 5:
          goto LABEL_104;
        default:
          v77 = (v77 - ((v79 + v80 + 1) >> 1)) & ~((int)(v77 - ((v79 + v80 + 1) >> 1)) >> 31);
          v9 = v85;
          v81 = v93;
          v82 = v91;
          goto LABEL_104;
      }
    }
  }
}

float redEyeCancellation(_DWORD *a1, unsigned __int8 **a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6, _DWORD *a7)
{
  int v7;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unsigned __int8 *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unsigned __int8 *v21;
  int v22;
  unsigned __int8 *v23;
  int v24;
  int v25;
  int v26;
  unsigned __int8 *v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  unsigned int v45;
  int v46;
  int v47;
  uint64_t v48;
  int v49;
  unsigned __int8 *v50;
  int v51;
  int v52;
  int v53;
  int v54;
  unsigned int v55;
  unsigned int v56;
  int v57;
  int v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  int v63;
  unsigned int v64;
  unsigned int v65;
  int v66;
  int v67;
  int v68;
  unsigned int v69;
  _BYTE *v70;
  int v71;
  int v72;
  float v73;
  float result;
  _DWORD *v75;
  int v76;
  int v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  unsigned __int8 *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unsigned __int8 *v87;
  uint64_t v88;
  uint64_t v89;
  unsigned __int8 *v90;
  unsigned __int8 *v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  unsigned int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  int v108;
  int v109;
  char v110;

  v7 = a1[3];
  if (v7 < 1)
  {
    v73 = 0.0;
  }
  else
  {
    v75 = a7;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v92 = 0;
    v15 = *((int *)a2 + 4);
    v16 = a1[2];
    v89 = *a5;
    v17 = *a2;
    v18 = (int)a1[7];
    v77 = -(int)v15;
    v19 = (int)a1[4];
    v76 = v7 - 2;
    v97 = 2 * v18;
    v98 = *a3;
    v80 = 2 * v19;
    v96 = *a3 + v18;
    v94 = *a3 + v18 + v19;
    v95 = *a3 + v19;
    v20 = 0;
    v85 = *a4 + v18 + v19;
    v86 = *a4;
    v93 = *((int *)a2 + 7);
    v83 = *a4 + v18;
    v84 = *a4 + v19;
    v110 = 1;
    v21 = *a2;
    v87 = *a2;
    v88 = a6;
    v79 = a1[3];
    v78 = v15;
    do
    {
      if (v16 <= 0)
      {
        v72 = v92 + 2;
      }
      else
      {
        v109 = v12;
        if (v92 == v76)
          v22 = 0;
        else
          v22 = v15;
        v23 = &v21[v22];
        v24 = v23[1];
        v25 = *v23;
        if (v92)
          v26 = v77;
        else
          v26 = 0;
        v27 = &v21[v26];
        v28 = v27[1];
        v29 = *v27;
        v30 = v21[1];
        v107 = v24;
        v108 = v92 | 1;
        v90 = &v17[v26];
        v91 = &v17[v22];
        v31 = 1;
        v81 = v21;
        v32 = *v21;
        v82 = v9;
        v33 = v10;
        v105 = v24;
        v106 = v25;
        v103 = v25;
        v104 = v28;
        v102 = v29;
        v34 = v30;
        v35 = v32;
        do
        {
          v36 = *(unsigned __int8 *)(v98 + v33) | (*(unsigned __int8 *)(v98 + v33) << 8);
          v37 = *(unsigned __int8 *)(v96 + v33);
          v38 = v37 | (v37 << 8);
          v39 = *(unsigned __int8 *)(v95 + v33);
          v40 = v39 | (v39 << 8);
          v41 = *(unsigned __int8 *)(v94 + v33);
          v42 = v41 | (v41 << 8);
          if (v38 | v36 | v40 | v42)
          {
            v43 = v31 - 1;
            v44 = (v102 + 9 * v32 + 3 * (v29 + v35) + 8) >> 4;
            v45 = (v104 + 9 * v30 + 3 * (v28 + v34) + 8) >> 4;
            if (*(_BYTE *)(v98 + v33))
            {
              v46 = (int)(1505792 - 11700 * v45 - 5638 * (v44 - 128)) >> 14;
              if (v46 >= (int)(29032 * (v44 - 128) + 0x2000) >> 14)
                v46 = (int)(29032 * (v44 - 128) + 0x2000) >> 14;
              v47 = *(unsigned __int8 *)(v86 + v33)
                  + (((*(unsigned __int8 *)(a6
                                          + ((v46 + *(unsigned __int8 *)(v86 + v33)) & ~((v46 + *(unsigned __int8 *)(v86 + v33)) >> 31)))
                     - *(unsigned __int8 *)(v86 + v33))
                    * v36
                    + 0x8000) >> 16);
              *(_BYTE *)(v86 + v33) = v47 & ~(v47 >> 31);
              v45 += (int)(v36 * (128 - v45) + 0x8000) >> 16;
              v100 = v44 + ((int)(v36 * (128 - v44) + 0x8000) >> 16);
              v48 = (v36 + v14);
              if ((v110 & 1) != 0)
              {
                v13 = v92;
                v20 = v31 - 1;
                v109 = v92 | 1;
                v110 = 0;
                v11 = v31;
              }
              else
              {
                if (v92 < v13)
                  v13 = v92;
                v49 = v109;
                if (v92 >= v109)
                  v49 = v92 | 1;
                v109 = v49;
                v110 = 0;
                if (v43 < v20)
                  v20 = v31 - 1;
                if (v43 >= v11)
                  v11 = v31;
              }
            }
            else
            {
              v100 = v44;
              v48 = v14;
            }
            v50 = &v17[v9];
            v51 = v17[v9];
            v52 = v50[1];
            v53 = v50[2];
            v54 = v50[3];
            v101 = v90[v9 + 2];
            v102 = v90[v9];
            v55 = (9 * v51 + v101 + 3 * (v102 + v53) + 8) >> 4;
            v99 = v90[v9 + 3];
            v56 = (9 * v52 + v99 + 3 * (v90[v9 + 1] + v54) + 8) >> 4;
            v104 = v90[v9 + 1];
            if (v37)
            {
              v57 = (int)(1505792 - 11700 * v56 - 5638 * (v55 - 128)) >> 14;
              if (v57 >= (int)(29032 * (v55 - 128) + 0x2000) >> 14)
                v57 = (int)(29032 * (v55 - 128) + 0x2000) >> 14;
              a6 = v88;
              v58 = *(unsigned __int8 *)(v83 + v33)
                  + (((*(unsigned __int8 *)(v88
                                          + ((v57 + *(unsigned __int8 *)(v83 + v33)) & ~((v57 + *(unsigned __int8 *)(v83 + v33)) >> 31)))
                     - *(unsigned __int8 *)(v83 + v33))
                    * v38
                    + 0x8000) >> 16);
              *(_BYTE *)(v83 + v33) = v58 & ~(v58 >> 31);
              v55 += (int)((128 - v55) * v38 + 0x8000) >> 16;
              v56 += (int)((128 - v56) * v38 + 0x8000) >> 16;
              v14 = (v48 + v38);
              if ((v110 & 1) != 0)
              {
                v110 = 0;
                v11 = v31 + 1;
                v13 = v92;
                v20 = v31;
                v59 = v92 | 1;
              }
              else
              {
                v110 = 0;
                if (v92 < v13)
                  v13 = v92;
                v59 = v109;
                if (v92 >= v109)
                  v59 = v92 | 1;
                if (v31 < v20)
                  v20 = v31;
                if (v31 >= v11)
                  v11 = v31 + 1;
              }
            }
            else
            {
              v14 = v48;
              a6 = v88;
              v59 = v109;
            }
            v60 = (v103 + 9 * v53 + 3 * (v106 + v51) + 8) >> 4;
            v61 = (v105 + 9 * v54 + 3 * (v107 + v52) + 8) >> 4;
            if (v39)
            {
              v62 = (int)(1505792 - 11700 * v61 - 5638 * (v60 - 128)) >> 14;
              if (v62 >= (int)(29032 * (v60 - 128) + 0x2000) >> 14)
                v62 = (int)(29032 * (v60 - 128) + 0x2000) >> 14;
              v63 = *(unsigned __int8 *)(v84 + v33)
                  + (((*(unsigned __int8 *)(a6
                                          + ((v62 + *(unsigned __int8 *)(v84 + v33)) & ~((v62 + *(unsigned __int8 *)(v84 + v33)) >> 31)))
                     - *(unsigned __int8 *)(v84 + v33))
                    * v40
                    + 0x8000) >> 16);
              *(_BYTE *)(v84 + v33) = v63 & ~(v63 >> 31);
              v60 += (int)((128 - v60) * v40 + 0x8000) >> 16;
              v61 += (int)((128 - v61) * v40 + 0x8000) >> 16;
              v14 = (v14 + v40);
              if ((v110 & 1) != 0)
              {
                v13 = v92 | 1;
                v20 = v31 - 1;
                v109 = v92 + 2;
                v110 = 0;
                v11 = v31;
              }
              else
              {
                if (v108 < v13)
                  v13 = v92 | 1;
                if (v108 >= v59)
                  v59 = v92 + 2;
                v109 = v59;
                v110 = 0;
                if (v43 < v20)
                  v20 = v31 - 1;
                if (v43 >= v11)
                  v11 = v31;
              }
            }
            else
            {
              v109 = v59;
            }
            v17 = v87;
            v35 = v87[v9];
            v34 = v50[1];
            v32 = v50[2];
            v30 = v50[3];
            v103 = v91[v9];
            v105 = v91[v9 + 1];
            v106 = v91[v9 + 2];
            v64 = (9 * v35 + v106 + 3 * (v103 + v32) + 8) >> 4;
            v107 = v91[v9 + 3];
            v65 = (9 * v34 + v107 + 3 * (v105 + v30) + 8) >> 4;
            if (v41)
            {
              v66 = (int)(1505792 - 11700 * v65 - 5638 * (v64 - 128)) >> 14;
              if (v66 >= (int)(29032 * (v64 - 128) + 0x2000) >> 14)
                v66 = (int)(29032 * (v64 - 128) + 0x2000) >> 14;
              v67 = *(unsigned __int8 *)(v85 + v33)
                  + (((*(unsigned __int8 *)(a6
                                          + ((v66 + *(unsigned __int8 *)(v85 + v33)) & ~((v66 + *(unsigned __int8 *)(v85 + v33)) >> 31)))
                     - *(unsigned __int8 *)(v85 + v33))
                    * v42
                    + 0x8000) >> 16);
              *(_BYTE *)(v85 + v33) = v67 & ~(v67 >> 31);
              v64 += (int)((128 - v64) * v42 + 0x8000) >> 16;
              v65 += (int)((128 - v65) * v42 + 0x8000) >> 16;
              v14 = (v14 + v42);
              if ((v110 & 1) != 0)
              {
                v11 = v31 + 1;
                v13 = v92 | 1;
                v20 = v31;
                v109 = v92 + 2;
                v110 = 0;
              }
              else
              {
                v68 = v109;
                if (v108 < v13)
                  v13 = v92 | 1;
                if (v108 >= v109)
                  v68 = v92 + 2;
                v109 = v68;
                v110 = 0;
                if (v31 < v20)
                  v20 = v31;
                if (v31 >= v11)
                  v11 = v31 + 1;
              }
            }
            v28 = v99;
            v69 = (v100 + v55 + v60 + v64 + 2) >> 2;
            v70 = (_BYTE *)(v89 + v9);
            *v70 = v69;
            v70[1] = (v45 + v56 + v61 + v65 + 2) >> 2;
            v29 = v101;
          }
          v33 += v97;
          v71 = v31 + 1;
          v31 += 2;
          v9 += v93;
        }
        while (v71 < v16);
        v7 = v79;
        v9 = v82;
        v15 = v78;
        v12 = v109;
        v21 = v81;
        v72 = v92 + 2;
      }
      v21 += v15;
      v10 += v80;
      v9 += v15;
      v92 = v72;
    }
    while (v72 < v7);
    v73 = (float)((v11 - v20) * (v12 - v13)) * 0.785398163;
    a7 = v75;
  }
  result = rintf(v73);
  *a7 = (uint64_t)result;
  return result;
}

uint64_t whiteEyeCancellation(int *a1, uint64_t a2, float a3, uint64_t a4, uint64_t a5, unsigned __int8 **a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t *a11, uint64_t a12, uint64_t a13, int *a14, _DWORD *a15)
{
  int v17;
  int v18;
  int v19;
  unsigned __int8 *v20;
  int v21;
  unsigned __int8 *v22;
  unint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  double v28;
  float v29;
  double v30;
  float v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  double v37;
  _QWORD *inited;
  int v39;
  float v40;
  uint64_t v41;
  double v42;
  float v43;
  int v44;
  double v45;
  int v46;
  __double2 v47;
  uint64_t v48;
  float cosval;
  float sinval;
  int v51;
  int v52;
  int v53;
  int v54;
  float v55;
  float v56;
  int v57;
  uint64_t v58;
  int v59;
  int v60;
  float v61;
  float v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  signed int i;
  uint64_t result;
  unint64_t v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  double v76;
  float v77;
  double v78;
  float v79;
  int v80;
  int v81;
  unsigned int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  double v87;
  float v88;
  uint64_t v89;
  float v90;
  int v91;
  double v92;
  int v93;
  __double2 v94;
  uint64_t v95;
  float v96;
  float v97;
  int v98;
  int v99;
  double v100;
  int v101;
  int v102;
  double v103;
  int v104;
  double v105;
  _QWORD *v106;
  uint64_t v107;
  int v108;
  int v109;
  int v110;
  int v111;
  float v112;
  float v113;
  int v114;
  _BYTE *v115;
  int v116;
  uint64_t v117;
  int v118;
  uint64_t v119;
  float v120;
  int v121;
  int v122;
  unsigned __int8 *v123;
  uint64_t v124;
  char v125;
  float v126;
  float v127;
  int v128;
  uint64_t v129;
  int j;
  int v131;
  int v132;
  int v133;
  int v134;
  int v135;
  int v136;
  int v137;
  int v138;
  float v139;
  float v140;
  float v141;
  float v142;
  unsigned __int8 *v143;
  uint64_t v144;
  uint64_t v145;
  unsigned __int8 *v146;
  unsigned __int8 *v147;
  unsigned __int8 *v148;
  uint64_t v149;
  float v150;
  uint64_t v151;
  int v152;
  _BYTE *v153;
  unsigned int v154;
  unsigned int v155;
  __int16 v156;
  float v157;
  double v158;
  double v159;
  double v160;
  float v161;
  float v162;
  float v163;
  float v164;
  unsigned int v165;
  uint64_t v166;
  uint64_t v167;
  int v168;
  int v169;
  int v170;
  int v171;
  double v172;
  float v173;
  float v174;
  uint64_t v175;
  int v176;
  float v177;
  float v178;
  uint64_t v179;
  _BYTE *v180;
  int v181;
  float v182;
  unsigned int v183;
  float v184;
  float v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v190;
  uint64_t v191;
  int v192;
  double v193;
  float v194;
  uint64_t v195;
  float v196;
  int v197;
  int v198;
  uint64_t v199;
  int v200;
  int v201;
  int v202;
  uint64_t v203;
  int v204;
  int v205;
  uint64_t v206;
  int v207;
  int v208;
  uint64_t v209;
  int v210;
  uint64_t v211;
  int v212;
  int v213;
  int v215;

  v17 = a1[3];
  if (v17 < 1)
  {
    v18 = 0;
    if (!a9)
      return 0;
  }
  else
  {
    v18 = 0;
    v19 = 0;
    v20 = *a6;
    do
    {
      if (a1[2] >= 1)
      {
        v21 = a1[2];
        v22 = v20;
        do
        {
          v18 += *v22;
          v22 += a1[7];
          --v21;
        }
        while (v21);
      }
      ++v19;
      v20 += a1[4];
    }
    while (v19 != v17);
    if (!a9)
      return 0;
  }
  v198 = a1[2];
  v192 = a1[3];
  v199 = a1[7];
  v191 = a1[4];
  v186 = *(int *)(a12 + 28);
  v187 = *(int *)(a12 + 16);
  v203 = (uint64_t)rintf((float)v18 / 255.0);
  v23 = bitmaskBoundingBitmapRect(a9);
  v24 = v23;
  v26 = v25;
  v27 = HIDWORD(v23);
  bitmaskCentroid(a9);
  v29 = v28;
  v31 = v30;
  if (v24 >= (int)v27)
  {
    v32 = 0;
  }
  else
  {
    v32 = 0;
    v209 = (uint64_t)rintf(v29);
    v33 = -(uint64_t)rintf(v31);
    do
    {
      if ((int)v26 < SHIDWORD(v26))
      {
        v34 = v26;
        do
        {
          v35 = bitValueFromBitmask(a9, v34, v24);
          v36 = (v24 - v209) * (v24 - v209) + (v33 + v34) * (v33 + v34);
          if (v36 <= v32)
            v36 = v32;
          if (v35)
            v32 = v36;
          ++v34;
        }
        while (HIDWORD(v26) != v34);
      }
      ++v24;
    }
    while (v24 != (_DWORD)v27);
  }
  v37 = sqrt((float)v32);
  inited = initBitmask(a1[2], a1[3]);
  v39 = 0;
  v40 = v37 * 12.5663706;
  v41 = (uint64_t)rintf(v40);
  if ((int)v41 <= 6)
    LODWORD(v41) = 6;
  v210 = v41;
  v42 = 6.28318531 / (double)(int)v41;
  v43 = v37 * 2.5;
  v44 = -1;
  v45 = 0.0;
  v206 = (uint64_t)rintf(v43);
  v46 = v206;
  do
  {
    v47 = __sincos_stret(v42 * v45);
    if (v44 != -1)
    {
      v48 = (uint64_t)rintf((float)v44 * 1.5);
      if (v44 + 2 > (int)v48)
        LODWORD(v48) = v44 + 2;
      if ((int)v48 >= (int)v206)
        v46 = v206;
      else
        v46 = v48;
    }
    cosval = v47.__cosval;
    sinval = v47.__sinval;
    v51 = bilinearLookup((uint64_t)a1, v31, v29);
    if (v46 < 1)
    {
      v53 = -1;
      v52 = 0x10000;
    }
    else
    {
      v52 = 0x10000;
      v53 = -1;
      v54 = v46;
      v55 = v29;
      v56 = v31;
      do
      {
        if (!bilinearLookupTest((uint64_t)a1, v56, v55))
          break;
        v57 = bilinearLookup((uint64_t)a1, v56, v55);
        if (v57 < v52)
          v52 = v57;
        if (v57 > v53)
          v53 = v57;
        v56 = v56 + cosval;
        v55 = v55 + sinval;
        --v54;
      }
      while (v54);
    }
    if (v52 < v51)
    {
      v58 = 1717986919 * (v53 + 19 * v52 + 10);
      v59 = (v58 >> 35) + ((unint64_t)v58 >> 63);
      if (v59 == v52)
        v60 = v59 + 1;
      else
        v60 = v59;
      if (v46 < 1)
      {
        v44 = 0;
      }
      else
      {
        v44 = 0;
        v61 = v29;
        v62 = v31;
        while (bilinearLookupTest((uint64_t)a1, v62, v61))
        {
          v63 = bilinearLookup((uint64_t)a1, v62, v61);
          setBitInBitmask((uint64_t)inited, (uint64_t)rintf(v62), (uint64_t)rintf(v61), 1);
          if (v63 < v60)
            break;
          ++v44;
          v62 = v62 + cosval;
          v61 = v61 + sinval;
          if (v46 == v44)
          {
            v44 = v46;
            break;
          }
        }
      }
    }
    v45 = v45 + 1.0;
    ++v39;
  }
  while (v39 != v210);
  v64 = *((_DWORD *)inited + 3);
  if (v64 < 1)
  {
    v65 = 0;
    v68 = v203;
  }
  else
  {
    v65 = 0;
    v66 = 0;
    v67 = *((_DWORD *)inited + 2);
    v68 = v203;
    do
    {
      if (v67 >= 1)
      {
        for (i = 0; i < v67; ++i)
        {
          if (bitValueFromBitmask((uint64_t)inited, i, v66))
            ++v65;
          v67 = *((_DWORD *)inited + 2);
        }
        v64 = *((_DWORD *)inited + 3);
      }
      ++v66;
    }
    while (v66 < v64);
  }
  termBitmask((void **)inited);
  if (v65 - v68 > 2 * v68)
    return 0;
  v71 = bitmaskBoundingBitmapRect(a9);
  v72 = v71;
  v74 = v73;
  v75 = HIDWORD(v71);
  bitmaskCentroid(a9);
  v77 = v76;
  v79 = v78;
  if (v72 >= (int)v75)
  {
    v80 = 0;
  }
  else
  {
    v80 = 0;
    v211 = (uint64_t)rintf(v77);
    v81 = -(uint64_t)rintf(v79);
    do
    {
      if ((int)v74 < SHIDWORD(v74))
      {
        v82 = v74;
        do
        {
          v83 = bitValueFromBitmask(a9, v82, v72);
          v84 = (v72 - v211) * (v72 - v211) + (v81 + v82) * (v81 + v82);
          if (v84 <= v80)
            v84 = v80;
          if (v83)
            v80 = v84;
          ++v82;
        }
        while (HIDWORD(v74) != v82);
      }
      ++v72;
    }
    while (v72 != (_DWORD)v75);
  }
  v85 = 0;
  v86 = 0;
  v87 = sqrt((float)v80);
  v88 = v87 * 12.5663706;
  v89 = (uint64_t)rintf(v88);
  if ((int)v89 <= 6)
    LODWORD(v89) = 6;
  v200 = v89;
  v193 = 6.28318531 / (double)(int)v89;
  v90 = v87 * 2.5;
  v212 = *((_DWORD *)a11 + 4);
  v204 = *(_DWORD *)(a12 + 16);
  v207 = *((_DWORD *)a11 + 7);
  v202 = *(_DWORD *)(a12 + 28);
  v91 = -1;
  v92 = 0.0;
  v190 = (uint64_t)rintf(v90);
  v93 = v190;
  v196 = v77;
  v194 = v79;
  do
  {
    v94 = __sincos_stret(v193 * v92);
    if (v91 != -1)
    {
      v95 = (uint64_t)rintf((float)v91 * 1.5);
      if (v91 + 2 > (int)v95)
        LODWORD(v95) = v91 + 2;
      if ((int)v95 >= (int)v190)
        v93 = v190;
      else
        v93 = v95;
    }
    v96 = v94.__cosval;
    v97 = v94.__sinval;
    v98 = bilinearLookup((uint64_t)a1, v79, v77);
    if (v93 < 1)
    {
      v101 = 0x10000;
      v103 = 0.0;
      v99 = -1;
      v100 = 0.0;
    }
    else
    {
      v99 = -1;
      v100 = 0.0;
      v101 = 0x10000;
      v102 = v93;
      v103 = 0.0;
      do
      {
        if (!bilinearLookupTest((uint64_t)a1, v79, v77))
          break;
        v104 = bilinearLookup((uint64_t)a1, v79, v77);
        if (v104 < v101)
        {
          v103 = bilinearCbCrLookup(a2, v79 * 0.5, v77 * 0.5);
          v100 = v105;
          v101 = v104;
        }
        if (v104 > v99)
          v99 = v104;
        v79 = v79 + v96;
        v77 = v77 + v97;
        --v102;
      }
      while (v102);
    }
    v106 = a11;
    v77 = v196;
    v79 = v194;
    if (v101 < v98)
    {
      v107 = 1717986919 * (v99 + 19 * v101 + 10);
      v108 = (v107 >> 35) + ((unint64_t)v107 >> 63);
      if (v108 == v101)
        v109 = v108 + 1;
      else
        v109 = v108;
      if (v93 < 1)
      {
        v91 = 0;
      }
      else
      {
        v91 = 0;
        v110 = (int)v103;
        v111 = (int)v100;
        v112 = v196;
        v113 = v194;
        while (bilinearLookupTest((uint64_t)a1, v113, v112))
        {
          v114 = bilinearLookup((uint64_t)a1, v113, v112);
          *(_BYTE *)(*a11 + v212 * (uint64_t)(int)(uint64_t)rintf(v112) + v207 * (uint64_t)(int)(uint64_t)rintf(v113)) = v101;
          v115 = (_BYTE *)(*(_QWORD *)a12
                         + v204 * (uint64_t)(int)(uint64_t)rintf(v112 * 0.5)
                         + v202 * (uint64_t)(int)(uint64_t)rintf(v113 * 0.5));
          *v115 = v110;
          v115[1] = v111;
          if (v114 < v109)
            break;
          ++v91;
          v113 = v113 + v96;
          v112 = v112 + v97;
          if (v93 == v91)
          {
            v91 = v93;
            break;
          }
        }
      }
    }
    v86 += v101;
    v92 = v92 + 1.0;
    ++v85;
  }
  while (v85 != v200);
  if (a14)
    v116 = *a14;
  else
    v116 = (v86 / v200 + 1) >> 1;
  v197 = v116;
  v117 = v199;
  v118 = v192;
  v119 = a13;
  v120 = *(float *)(a13 + 20);
  srandom(0x4853467u);
  if (v192 < 1)
  {
    v139 = 0.0;
    v142 = NAN;
    v141 = NAN;
    v157 = 0.0;
    v144 = v191;
    v128 = v198;
    v150 = a3;
  }
  else
  {
    v215 = 0;
    v208 = 0;
    v205 = 0;
    v213 = 0;
    v121 = 0;
    v122 = 0;
    v195 = (uint64_t)rintf((float)(2.0 / v120) * 4096.0);
    v123 = *a6;
    v124 = *a11;
    v125 = 1;
    v126 = 0.0;
    v127 = 0.0;
    v128 = v198;
    do
    {
      v201 = v122 + 1;
      if (v128 >= 1)
      {
        v129 = 0;
        for (j = 0; j != v128; ++j)
        {
          v131 = v123[v129];
          if (v123[v129])
          {
            v132 = *(unsigned __int8 *)(v124 + v129);
            v133 = v132
                 + (((v197 - v132 + ((((random() >> 7) - 128) * (int)v195 + 2048) >> 12))
                   * v131
                   + 128) >> 8);
            *(_BYTE *)(v124 + v129) = v133 & ~(v133 >> 31);
            if ((v125 & 1) != 0)
            {
              v215 = j + 1;
              v213 = v122;
              v205 = j;
              v208 = v122 + 1;
            }
            else
            {
              v134 = v213;
              if (v122 < v213)
                v134 = v122;
              v213 = v134;
              v135 = v208;
              if (v122 >= v208)
                v135 = v122 + 1;
              v208 = v135;
              v136 = v205;
              if (j < v205)
                v136 = j;
              v205 = v136;
              v137 = v215;
              if (j >= v215)
                v137 = j + 1;
              v215 = v137;
            }
            v117 = v199;
            v128 = v198;
            v125 = 0;
            v121 += v131;
            v127 = v127 + (float)(v122 * v131);
            v126 = v126 + (float)(j * v131);
          }
          v129 += v117;
        }
      }
      v124 += v191;
      v123 += v191;
      ++v122;
    }
    while (v201 != v192);
    v138 = 0;
    v139 = (float)v121;
    v140 = 1.0 / (float)v121;
    v141 = v140 * v126;
    v142 = v140 * v127;
    v119 = a13;
    v143 = *a6;
    v144 = v191;
    v106 = a11;
    v145 = 2 * (int)v191;
    v146 = &(*a6)[v117];
    v147 = &(*a6)[v191];
    v148 = &(*a6)[(int)v117 + (int)v191];
    v149 = *(_QWORD *)a12 + 1;
    v118 = v192;
    v150 = a3;
    do
    {
      if (v128 >= 1)
      {
        v151 = 0;
        v152 = 0;
        v153 = (_BYTE *)v149;
        do
        {
          v154 = v146[v151] + v143[v151] + v147[v151] + v148[v151];
          if (v154 >= 2)
          {
            v155 = (v154 + 2) >> 2;
            v156 = *v153;
            *(v153 - 1) += (unsigned __int16)((128 - *(v153 - 1)) * v155 + 128) >> 8;
            *v153 = v156 + ((unsigned __int16)((128 - v156) * v155 + 128) >> 8);
          }
          v151 += 2 * (int)v117;
          v152 += 2;
          v153 += v186;
        }
        while (v152 < v128);
      }
      v138 += 2;
      v143 += v145;
      v146 += v145;
      v147 += v145;
      v148 += v145;
      v149 += v187;
    }
    while (v138 < v192);
    v157 = (float)((v215 - v205) * (v208 - v213)) * 0.785398163;
  }
  result = (uint64_t)rintf(v139 / 255.0);
  *a15 = (uint64_t)rintf(v157);
  v158 = sqrt((float)(int)result / 3.14159265);
  *(float *)&v158 = v158 + v158;
  v159 = *(float *)&v158;
  if (v150 == 0.0)
  {
    if (*(_BYTE *)(v119 + 24))
      v160 = v159 * 10.4;
    else
      v160 = (v159 + -4.1) * 10.75;
    v150 = v160;
  }
  if (*(float *)(a10 + 20) <= 0.7
    || *(_DWORD *)(a10 + 40) - *(_DWORD *)(a10 + 36) <= 2 * (*(_DWORD *)(a10 + 48) - *(_DWORD *)(a10 + 44)))
  {
    if (*(_BYTE *)(v119 + 24))
    {
      v161 = 0.5;
      if (v159 >= 4.7)
        v161 = 1.6 / (v159 + -1.5);
    }
    else
    {
      v161 = 0.1;
    }
    v162 = v150 * 0.0266667;
    v163 = v162 * 0.5;
    v164 = (float)(v162 * 0.5) * 4.0;
    v165 = vcvtps_s32_f32(v164);
    v166 = (uint64_t)rintf(v141);
    v167 = (uint64_t)rintf(v142);
    v168 = v165 + v167;
    v169 = (int)(v165 + v166) < v128 ? v165 + v166 + 1 : v128;
    v170 = (v167 - v165) & ~((int)(v167 - v165) >> 31);
    v171 = v168 < v118 ? v168 + 1 : v118;
    if (v170 < v171)
    {
      v172 = 1.0 - v161;
      v173 = v172 * v163;
      v174 = (float)v197 + (float)(250 - v197) * (v172 * 0.67 + 0.33);
      v175 = (uint64_t)rintf(v174);
      v176 = (v166 - v165) & ~((int)(v166 - v165) >> 31);
      v177 = v173 * v173;
      v178 = 1.0 / (float)(v164 - v173);
      v179 = *v106 + v170 * (int)v144;
      while (v176 >= v169)
      {
LABEL_167:
        ++v170;
        v179 += v144;
        if (v170 == v171)
          return result;
      }
      v180 = (_BYTE *)(v179 + v176 * (int)v117);
      v181 = v176;
      while (1)
      {
        v182 = (float)((float)((float)v170 - v142) * (float)((float)v170 - v142))
             + (float)((float)((float)v181 - v141) * (float)((float)v181 - v141));
        LOBYTE(v183) = v175;
        if (v182 < v177)
          goto LABEL_165;
        if (v182 < (float)(v164 * v164))
          break;
LABEL_166:
        ++v181;
        v180 += v117;
        if (v169 == v181)
          goto LABEL_167;
      }
      v184 = v178 * (float)(v164 - sqrtf(v182));
      v185 = (v184 * -2.0 + 3.0) * v184 * v184;
      v183 = *v180
           + ((((_DWORD)v175 - *v180)
             * (uint64_t)rintf((float)((float)(v184* (float)(v184* (float)(v184 * (float)(v184 * (float)(v184 * v184)))))+ (float)(v161* (float)(v185- (float)(v184* (float)(v184* (float)(v184* (float)(v184* (float)(v184 * v184))))))))* 4096.0)+ 2048) >> 12);
LABEL_165:
      *v180 = v183;
      goto LABEL_166;
    }
  }
  return result;
}

void **closestConnectedComponent(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int *a5, int *a6)
{
  int v10;
  int v11;
  _QWORD *inited;
  uint64_t v13;
  void **v14;
  void **v15;
  void **v16;
  uint64_t v17;
  float v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  double v25;
  double v26;
  float v27;
  float v28;
  float v29;
  unint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  void **v35;
  const char *v36;
  int *v38;
  int *v39;
  void **v40;
  uint64_t v41;

  v10 = *(_DWORD *)(a1 + 8);
  v11 = *(_DWORD *)(a1 + 12);
  inited = initBitmask(v10, v11);
  if (!inited)
  {
    puts("closestConnectedComponent: can not allocate bitmask bm");
    return 0;
  }
  v13 = (uint64_t)inited;
  v14 = (void **)initBitmask(v10, v11);
  if (!v14)
  {
    puts("closestConnectedComponent: can not allocate bitmask bm2");
LABEL_24:
    termBitmask((void **)v13);
    return v14;
  }
  v15 = (void **)initBitmask(v10, v11);
  if (!v15)
  {
    puts("closestConnectedComponent: can not allocate bitmask bm3");
    termBitmask((void **)v13);
    v35 = v14;
    goto LABEL_30;
  }
  v16 = v15;
  v39 = a5;
  v41 = 0;
  computeThresholdedBitmask((unsigned __int8 *)a1, (uint64_t *)v13, a2);
  memmove(*v16, *(const void **)v13, *(int *)(v13 + 12) * (uint64_t)*(int *)(v13 + 16));
  if (v11 < 1)
  {
LABEL_27:
    termBitmask((void **)v13);
    termBitmask(v14);
    v35 = v16;
    goto LABEL_30;
  }
  v38 = a6;
  v40 = v16;
  v17 = 0;
  v18 = (float)(v10 * v10 + v11 * v11);
  v19 = 0xFFFFFFFFLL;
  v20 = -1;
  while (v10 < 1)
  {
LABEL_15:
    v17 = (v17 + 1);
    if ((_DWORD)v17 == v11)
    {
      v16 = v40;
      if ((_DWORD)v19 != -1)
      {
        seedFill((uint64_t)v40, (uint64_t)v14, v20, v19, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))bitIsSet);
        v30 = bitmaskBoundingBitmapRect((uint64_t)v14);
        v32 = HIDWORD(v30) + v30;
        if (HIDWORD(v30) + (int)v30 < 0 != __OFADD__(HIDWORD(v30), (_DWORD)v30))
          ++v32;
        v33 = v32 >> 1;
        v34 = HIDWORD(v31) + v31;
        if (HIDWORD(v31) + (int)v31 < 0 != __OFADD__(HIDWORD(v31), (_DWORD)v31))
          ++v34;
        *v39 = v34 >> 1;
        *v38 = v33;
        termBitmask(v40);
        goto LABEL_24;
      }
      goto LABEL_27;
    }
  }
  v21 = 0;
  while (!bitValueFromBitmask(v13, v21, v17))
  {
LABEL_14:
    if (v10 == ++v21)
      goto LABEL_15;
  }
  if (!seedFill(v13, (uint64_t)v14, v21, v17, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))bitIsSet))
  {
    v36 = "closestConnectedComponent: seedFill failed";
    goto LABEL_29;
  }
  v22 = bitmaskBoundingBitmapRect((uint64_t)v14);
  v24 = v23;
  bitmaskCentroidUsingBoundingRect((uint64_t)v14, v22, v23);
  v27 = v25 + -(float)v10 * 0.5;
  v28 = v26 + -(float)v11 * 0.5;
  v29 = (float)(v28 * v28) + (float)(v27 * v27);
  if (v29 >= v18)
  {
LABEL_13:
    bitmaskMinus(v13, (uint64_t)v14);
    goto LABEL_14;
  }
  closestSetBitInBitmaskUsingBoundingRect((uint64_t)v14, v22, v24, (int *)&v41 + 1, (int *)&v41, v25, v26);
  v20 = HIDWORD(v41);
  if (HIDWORD(v41) != -1)
  {
    v19 = v41;
    v18 = v29;
    goto LABEL_13;
  }
  v36 = "closestConnectedComponent: centroid closest bit search failed";
LABEL_29:
  puts(v36);
  termBitmask((void **)v13);
  termBitmask(v14);
  v35 = v40;
LABEL_30:
  termBitmask(v35);
  return 0;
}

_QWORD *cornealReflectionBitmask(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *inited;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  double v12;
  double v13;
  double v14;
  uint64_t v15;
  unint64_t v16;
  float v17;
  int v18;
  int v19;
  float v20;
  float v21;
  uint64_t v22;
  int v23;
  float v24;
  float v25;
  float v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  int v32;
  int v33;
  double v34;
  float v35;
  uint64_t v36;
  float v37;
  uint64_t v38;
  double v39;
  float v40;
  float v41;
  int v42;
  double v43;
  int v44;
  __double2 v45;
  uint64_t v46;
  float cosval;
  float sinval;
  int v49;
  int v50;
  int v51;
  int v52;
  float v53;
  float v54;
  int v55;
  uint64_t v56;
  int v57;
  int v58;
  float v59;
  float v60;
  int v61;
  uint64_t v63;
  uint64_t v64;
  int v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  int v69;

  if (!a1 || a3 >= 1 && (float)a3 * 0.6 < (float)(int)bitmaskArea(a1))
    return 0;
  inited = initBitmask(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
  if (!inited)
  {
    puts("cornealReflectionBitmask: can not allocate bitmask bm2 intended for spread");
    return inited;
  }
  if (!a2)
  {
    spreadBitmask3(a1, (uint64_t)inited, 0);
    return inited;
  }
  v6 = bitmaskBoundingBitmapRect(a1);
  v8 = v7;
  v9 = *(int *)(a2 + 16);
  v10 = *(int *)(a2 + 28);
  bitmaskCentroid(a1);
  v66 = HIDWORD(v6);
  v67 = (uint64_t)inited;
  if ((int)v6 < SHIDWORD(v6))
  {
    v13 = v11;
    v14 = v12;
    v68 = 0;
    v15 = *(_QWORD *)a2 + (int)v9 * (uint64_t)(int)v6;
    v63 = (int)v10 * (uint64_t)(int)v8;
    v64 = v9;
    v16 = HIDWORD(v8);
    v17 = 0.0;
    v18 = 256;
    v19 = v6;
    v65 = v8;
    while ((int)v8 >= (int)v16)
    {
      v25 = v17;
LABEL_21:
      ++v19;
      LODWORD(v8) = v65;
      v15 += v64;
      v17 = v25;
      if (v19 == HIDWORD(v6))
      {
        v27 = 0;
        v29 = v68;
        v28 = HIDWORD(v68);
        do
        {
          if ((int)v8 < (int)v16)
          {
            v30 = v8;
            do
            {
              v31 = bitValueFromBitmask(a1, v30, v6);
              v32 = (v6 - HIDWORD(v68)) * (v6 - HIDWORD(v68)) + (v30 - v68) * (v30 - v68);
              if (v32 <= v27)
                v32 = v27;
              if (v31)
                v27 = v32;
              ++v30;
            }
            while ((_DWORD)v16 != v30);
          }
          LODWORD(v6) = v6 + 1;
          LODWORD(v8) = v65;
        }
        while ((_DWORD)v6 != (_DWORD)v66);
        goto LABEL_35;
      }
    }
    v20 = (float)v19 - v14;
    v21 = v20 * v20;
    v22 = v63;
    while (bitValueFromBitmask(a1, v8, v19))
    {
      v23 = *(unsigned __int8 *)(v15 + v22);
      if (v18 <= v23)
      {
        if (v18 != v23)
          break;
        v26 = (float)(int)v8 - v13;
        v25 = v21 + (float)(v26 * v26);
        if (v25 >= v17)
          break;
        v68 = __PAIR64__(v19, v8);
      }
      else
      {
        v24 = (float)(int)v8 - v13;
        v25 = v21 + (float)(v24 * v24);
        v68 = __PAIR64__(v19, v8);
        v18 = *(unsigned __int8 *)(v15 + v22);
      }
LABEL_18:
      LODWORD(v8) = v8 + 1;
      v22 += v10;
      v17 = v25;
      if ((_DWORD)v16 == (_DWORD)v8)
        goto LABEL_21;
    }
    v25 = v17;
    goto LABEL_18;
  }
  v29 = 0;
  v28 = 0;
  v27 = 0;
LABEL_35:
  v33 = 0;
  v34 = sqrt((float)v27);
  v35 = v34 * 12.5663706;
  v36 = (uint64_t)rintf(v35);
  if ((int)v36 <= 6)
    LODWORD(v36) = 6;
  v69 = v36;
  v37 = v34 * 2.5;
  v38 = (uint64_t)rintf(v37);
  v39 = 6.28318531 / (double)(int)v36;
  v40 = (float)v29;
  v41 = (float)v28;
  v42 = -1;
  v43 = 0.0;
  v44 = v38;
  do
  {
    v45 = __sincos_stret(v39 * v43);
    if (v42 != -1)
    {
      v46 = (uint64_t)rintf((float)v42 * 1.5);
      if (v42 + 2 > (int)v46)
        LODWORD(v46) = v42 + 2;
      if ((int)v46 >= (int)v38)
        v44 = v38;
      else
        v44 = v46;
    }
    cosval = v45.__cosval;
    sinval = v45.__sinval;
    v49 = bilinearLookup(a2, v40, v41);
    if (v44 < 1)
    {
      v51 = 256;
      v50 = -1;
    }
    else
    {
      v50 = -1;
      v51 = 256;
      v52 = v44;
      v53 = v41;
      v54 = v40;
      do
      {
        if (!bilinearLookupTest(a2, v54, v53))
          break;
        v55 = bilinearLookup(a2, v54, v53);
        if (v55 < v51)
          v51 = v55;
        if (v55 > v50)
          v50 = v55;
        v54 = v54 + cosval;
        v53 = v53 + sinval;
        --v52;
      }
      while (v52);
    }
    if (v50 > v49)
    {
      v56 = 1717986919 * (v51 + 19 * v50 + 10);
      v57 = (v56 >> 35) + ((unint64_t)v56 >> 63);
      if (v44 < 1)
      {
        v42 = 0;
      }
      else
      {
        v42 = 0;
        v58 = v57 - (v57 == v50);
        v59 = v41;
        v60 = v40;
        while (bilinearLookupTest(a2, v60, v59))
        {
          v61 = bilinearLookup(a2, v60, v59);
          setBitInBitmask(v67, (uint64_t)rintf(v60), (uint64_t)rintf(v59), 1);
          if (v61 > v58)
            break;
          ++v42;
          v60 = v60 + cosval;
          v59 = v59 + sinval;
          if (v44 == v42)
          {
            v42 = v44;
            break;
          }
        }
      }
    }
    v43 = v43 + 1.0;
    ++v33;
    inited = (_QWORD *)v67;
  }
  while (v33 != v69);
  spreadBitmask3(v67, a1, 0);
  chokeBitmask(a1, v67, 0);
  return inited;
}

void infillChannelWithBitmask(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  int v10;
  unint64_t v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  int v23;
  unint64_t v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  int v28;
  void **v29;
  void **v30;
  _DWORD *v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  void **inited;
  _QWORD *v36;
  unint64_t v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;

  v3 = bitmaskBoundingBitmapRect(a2);
  v5 = insetBitmapRect(v3, v4, 0xFFFFFFFFLL, -1);
  v7 = v6;
  v8 = zmalloc(0x10uLL);
  if (!v8)
  {
    puts("determineOutsidePath: unable to allocate path");
    return;
  }
  v9 = v8;
  *v8 = 0;
  v8[1] = 0;
  v34 = HIDWORD(v5);
  inited = (void **)initBitmask(*(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  *((_DWORD *)v9 + 2) = 0;
  if ((int)v5 >= SHIDWORD(v5))
    goto LABEL_32;
  v10 = 0;
  v11 = HIDWORD(v7);
  v32 = v5;
  v12 = v5;
  v36 = v9;
  v37 = HIDWORD(v7);
  v33 = v7;
  do
  {
    if ((int)v7 < (int)v11)
    {
      v38 = v12 - 1;
      v39 = v12 + 1;
      v13 = v7;
      while (1)
      {
        if (bitValueFromBitmask(a2, v13, v12))
        {
          v14 = v13 + 1;
        }
        else
        {
          v42 = bitValueFromBitmask(a2, v13 - 1, v38);
          v41 = bitValueFromBitmask(a2, v13, v38);
          v14 = v13 + 1;
          v40 = bitValueFromBitmask(a2, v13 + 1, v38);
          v15 = bitValueFromBitmask(a2, v13 - 1, v12);
          v16 = bitValueFromBitmask(a2, v13 + 1, v12);
          v17 = bitValueFromBitmask(a2, v13 - 1, v39);
          v18 = bitValueFromBitmask(a2, v13, v39);
          if (v41 + v42 + v40 + v15 + v16 + v17 + v18 + bitValueFromBitmask(a2, v13 + 1, v39))
          {
            ++*((_DWORD *)v36 + 2);
            setBitInBitmask((uint64_t)inited, v13, v12, 1);
            v10 = v41;
            if (v41 && v18)
            {
              ++*((_DWORD *)v36 + 2);
            }
            else if (v15)
            {
              LODWORD(v11) = v37;
              if (v16)
                ++*((_DWORD *)v36 + 2);
              goto LABEL_17;
            }
            LODWORD(v11) = v37;
          }
          else
          {
            LODWORD(v11) = v37;
            v10 = v41;
          }
        }
LABEL_17:
        v13 = v14;
        if (v14 == (_DWORD)v11)
        {
          v7 = v33;
          v19 = v12 + 1;
          goto LABEL_20;
        }
      }
    }
    v19 = v12 + 1;
LABEL_20:
    v12 = v19;
  }
  while (v19 != (_DWORD)v34);
  v9 = v36;
  if (!*((_DWORD *)v36 + 2))
  {
LABEL_32:
    puts("determineOutsidePath: no bits set");
    termBitmask(inited);
    zfree((void *)*v9);
    v29 = (void **)v9;
LABEL_33:
    zfree(v29);
    return;
  }
  v21 = insetBitmapRect(v32, v7, 0xFFFFFFFFLL, -1);
  v22 = HIDWORD(v21);
  if ((int)v21 >= SHIDWORD(v21))
  {
    v10 = 0;
    v25 = 0;
  }
  else
  {
    v23 = v20;
    v24 = HIDWORD(v20);
    while (v23 >= (int)v24)
    {
LABEL_29:
      v28 = v10;
      v10 = 0;
      if (v28)
      {
        v25 = 0;
        goto LABEL_37;
      }
      LODWORD(v21) = v21 + 1;
      v25 = 0;
      if ((int)v21 >= (int)v22)
        goto LABEL_37;
    }
    v25 = v23;
    while (1)
    {
      v26 = bitValueFromBitmask((uint64_t)inited, v25, v21);
      v27 = v25 + 1;
      if (v26)
        break;
      ++v25;
      if ((_DWORD)v24 == v27)
      {
        v10 = 0;
        goto LABEL_29;
      }
    }
    v10 = v21;
    if (!bitValueFromBitmask((uint64_t)inited, v27, v21))
    {
      puts("determineOutsidePath: isolated point");
      termBitmask(inited);
      v30 = (void **)v36;
      goto LABEL_43;
    }
  }
LABEL_37:
  v30 = (void **)v36;
  v31 = zmalloc(8 * *((int *)v36 + 2));
  *v36 = v31;
  if (!v31)
  {
    puts("determineOutsidePath: unable to allocate path body");
    termBitmask(inited);
LABEL_43:
    zfree(*v30);
    v29 = v30;
    goto LABEL_33;
  }
  if (*((int *)v36 + 2) > ((uint64_t)v31 - *v36) >> 3)
  {
    *v31 = v25;
    v31[1] = v10;
    __asm { BR              X8 }
  }
  puts("determineOutsidePath: overflow");
  zfree((void *)*v36);
  zfree(v36);
  termBitmask(inited);
}

void freeArcs(void **a1)
{
  zfree(*a1);
  zfree(a1[2]);
  zfree(a1);
}

int *computePupilAlphaMap(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5, _DWORD *a6)
{
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  void **v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  float v18;
  float v19;
  double v20;
  double v21;
  double v22;
  double v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  int v30;
  int v31;
  double v32;
  unsigned __int16 *v33;
  unsigned __int16 *v34;
  float v35;
  unsigned __int16 *v36;
  __double2 v37;
  uint64_t v38;
  float cosval;
  float sinval;
  float v41;
  float v42;
  unsigned __int16 *v43;
  _WORD *v44;
  int v45;
  unsigned __int16 *v46;
  int v47;
  uint64_t v48;
  unsigned __int16 v49;
  float v50;
  float v51;
  float v52;
  BOOL v53;
  float v56;
  double *v57;
  uint64_t v58;
  double v59;
  double v60;
  float v61;
  float v62;
  float v63;
  uint64_t v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  double v71;
  float v72;
  uint64_t v73;
  float v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  float v82;
  __double2 v83;
  float v84;
  float v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  float v89;
  float v90;
  __int16 v91;
  _WORD *v92;
  int v93;
  _WORD *v94;
  int v95;
  uint64_t v96;
  int v97;
  unsigned int v98;
  _WORD *v99;
  int *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  double v105;
  uint64_t v106;
  int *v107;
  int v108;
  int *v109;
  float v114;
  __double2 v115;
  _BOOL4 v116;
  float v117;
  float v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  int v123;
  uint64_t v124;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127;
  unsigned int v128;
  int v130;
  int v131;
  unsigned int v132;
  int *v133;
  uint64_t v134;
  int *v135;
  int *v136;
  int v137;
  float v138;
  float v139;
  float v140;
  int *v141;
  uint64_t v142;
  int *v143;
  __int128 v144;
  uint64_t v145;
  int *v146;
  int v147;
  uint64_t v148;
  int v149;
  int v150;
  char *v151;
  int v152;
  double *v153;
  float v154;
  float v155;
  float v156;
  float v157;
  float v158;
  double v159;
  float v160;
  float v161;
  float v162;
  double v163;
  float v164;
  double v165;
  float v166;
  double *v167;
  float v168;
  float v169;
  float v170;
  float v171;
  float v172;
  float v173;
  float v174;
  unsigned int v175;
  unsigned int v176;
  signed int v177;
  signed int v178;
  unsigned int v179;
  unsigned int v180;
  uint64_t v181;
  int *v182;
  int v183;
  int v184;
  int v185;
  int v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  float v190;
  float v191;
  long double v192;
  int v193;
  int v194;
  uint64_t v195;
  uint64_t v196;
  float v197;
  long double v198;
  int v199;
  float v200;
  int v201;
  int v202;
  int v203;
  float *v204;
  float *v205;
  float v206;
  float v207;
  float v208;
  float v209;
  float v210;
  int v211;
  int *v213;
  _DWORD *v214;
  _DWORD *v215;
  uint64_t v216;
  float *v217;
  float64x2_t v218;
  int v219;
  int v220;
  uint64_t v221;
  int *v222;
  float v223;
  int v224;
  uint64_t v225;
  float v226;
  float v227;
  int v228;
  uint64_t v229;
  int v230;
  unint64_t v231;
  uint64_t v232;
  uint64_t v233;
  int v234;
  float v235;
  uint64_t v236;
  float v237;
  uint64_t v238;
  int v239;
  int *v240;
  float v241;
  uint64_t v242;
  int v243;
  uint64_t v244;
  uint64_t v245;
  float v246;
  int v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  signed int v253;
  uint64_t v254;
  int v255;
  int v256;
  _OWORD v257[2];
  uint64_t v258;
  __int128 v259;
  __int128 v260;
  uint64_t v261;
  char *v262;
  int v263;
  uint64_t v264;
  uint64_t v265;
  float v266[640];
  uint64_t v267;

  v267 = *MEMORY[0x1E0C80C00];
  v263 = 0;
  v262 = 0;
  v261 = 0;
  v259 = 0u;
  v260 = 0u;
  v258 = 0;
  memset(v257, 0, sizeof(v257));
  v264 = 0;
  v265 = 0;
  histogramBitmap((unsigned __int8 **)a1, a2, v266, (_DWORD *)&v265 + 1, (int *)&v265);
  v10 = v265;
  v11 = HIDWORD(v265);
  v14 = closestConnectedComponent(a1, ((int)v265 + 2 * HIDWORD(v265)) / 3, v12, v13, (int *)&v264, (int *)&v264 + 1);
  if (!v14)
    return 0;
  v214 = a5;
  v215 = a6;
  termBitmask(v14);
  v15 = 0;
  LODWORD(v16) = 0;
  v239 = 0;
  v17 = (v11 + v10) >> 1;
  v216 = v264;
  v237 = (float)(int)v264;
  v18 = sqrt((float)a3 / 3.14159265);
  v235 = (float)SHIDWORD(v264);
  if (v17 >= 20)
    v17 = 20;
  v19 = (float)(v17 << 6);
  v20 = v18 * 0.5;
  v227 = 0.0;
  v21 = 1.0;
  v223 = 0.0;
  do
  {
    v243 = v16;
    if (v15 <= 4)
    {
      v223 = flt_192499D60[v15];
      v227 = flt_192499D74[v15];
    }
    v231 = v15;
    v22 = (float)(v227 + v237);
    v23 = (float)(v223 + v235);
    v24 = (float)(v227 + v237) - (float)(*(_DWORD *)(a1 + 8) - 1);
    v25 = v23 * v23 + v22 * v22;
    v26 = (float)(v24 * v24) + v23 * v23;
    if (v26 > v25)
      v25 = (float)(v24 * v24) + v23 * v23;
    v27 = (float)((float)(v223 + v235) - (float)(*(_DWORD *)(a1 + 12) - 1))
        * (float)((float)(v223 + v235) - (float)(*(_DWORD *)(a1 + 12) - 1));
    v28 = v27 + v22 * v22;
    if (v25 < v28)
      v25 = v27 + v22 * v22;
    v29 = v27 + (float)(v24 * v24);
    if (v29 <= v25)
      v29 = v25;
    if (*(_QWORD *)a1)
    {
      v239 = 0;
      v30 = 0;
      v217 = &v266[4 * (int)v16];
      v31 = vcvtpd_s64_f64(sqrt(v29));
      v32 = 0.0;
      do
      {
        v33 = (unsigned __int16 *)zmalloc(4 * v31);
        if (v33)
        {
          v34 = v33;
          v35 = v32 * 0.03125 * 6.28318531;
          v36 = &v33[v31];
          v37 = __sincos_stret(v35);
          if (v31 < 1)
          {
            *v36 = (*v34 - v34[1]) & ~(unsigned __int16)((*v34 - v34[1]) >> 31);
            v44 = v36 + 1;
            goto LABEL_40;
          }
          v38 = 0;
          cosval = v37.__cosval;
          sinval = v37.__sinval;
          v41 = v223 + v235;
          v42 = v227 + v237;
          do
          {
            v34[v38] = bilinearLookupAccurate(a1, v42, v41);
            v42 = v42 + cosval;
            v41 = v41 + sinval;
            ++v38;
          }
          while (v31 != (_DWORD)v38);
          v43 = v34 + 1;
          *v36 = (*v34 - v34[1]) & ~(unsigned __int16)((*v34 - v34[1]) >> 31);
          v44 = v36 + 1;
          if (v31 <= 2)
          {
            v21 = 1.0;
LABEL_40:
            *v44 = (*v34 - v34[1]) & ~(unsigned __int16)((*v34 - v34[1]) >> 31);
LABEL_41:
            zfree(v34);
            goto LABEL_42;
          }
          v265 = 0;
          v45 = v31 - 2;
          v21 = 1.0;
          do
          {
            v46 = v43;
            v47 = v43[1];
            ++v43;
            v46[v31] = (*(v46 - 1) - v47) & ~(unsigned __int16)((*(v46 - 1) - v47) >> 31);
            --v45;
          }
          while (v45);
          v48 = 0;
          v43[v31] = (*(v43 - 1) - *v43) & ~(unsigned __int16)((*(v43 - 1) - *v43) >> 31);
          v49 = v34[v31];
          LOWORD(v44) = *v44;
          while (1)
          {
            v50 = (float)v49;
            v49 = (unsigned __int16)v44;
            v51 = (float)(unsigned __int16)v44;
            LODWORD(v44) = v34[v31 + 2 + v48];
            v52 = (float)v44;
            v53 = v51 < v50 || v51 < v52;
            if (!v53 && v51 > v19 && (v50 != v51 || v51 != v52))
            {
              if (maximumPointWithSamples((float *)&v265 + 1, (float *)&v265, v50, v51, v52))
              {
                v56 = *((float *)&v265 + 1) + (float)(int)v48;
                if (v20 < v56)
                  break;
              }
            }
            if ((v31 - 1) - 1 == ++v48)
              goto LABEL_41;
          }
          zfree(v34);
          v57 = (double *)&v217[4 * v239];
          *v57 = (float)(v227 + v237) + (float)(v56 * cosval);
          v57[1] = (float)(v223 + v235) + (float)(v56 * sinval);
          ++v239;
        }
LABEL_42:
        v32 = v32 + v21;
        ++v30;
      }
      while (v30 != 32);
    }
    v16 = (v239 + v243);
    v15 = v231 + 1;
  }
  while (v231 != 4);
  if (!(_DWORD)v16)
    return 0;
  if ((int)v16 <= 0)
  {
    v65 = 0.0 / (float)(int)v16;
    v70 = sqrtf(0.0 / (float)(v16 - 1));
  }
  else
  {
    v58 = 0;
    v59 = v237;
    v60 = v235;
    v61 = 0.0;
    do
    {
      v62 = *(double *)&v266[v58] - v59;
      v63 = *(double *)&v266[v58 + 2] - v60;
      v61 = v61 + sqrtf((float)(v63 * v63) + (float)(v62 * v62));
      v58 += 4;
    }
    while (4 * (v239 + v243) != v58);
    v64 = 0;
    v65 = v61 / (float)(int)v16;
    v66 = 0.0;
    do
    {
      v67 = *(double *)&v266[v64] - v59;
      v68 = *(double *)&v266[v64 + 2] - v60;
      v69 = sqrtf((float)(v68 * v68) + (float)(v67 * v67)) - v65;
      v66 = v66 + (float)(v69 * v69);
      v64 += 4;
    }
    while (4 * v16 != v64);
    v70 = sqrtf(v66 / (float)(v16 - 1));
    if ((_DWORD)v16 == 1)
      v70 = 0.0;
  }
  v71 = v65;
  v72 = v65 * 6.28318531;
  v73 = (uint64_t)rintf(v72);
  v74 = v71 + v70 * 2.5;
  v75 = (uint64_t)rintf(v74);
  initBitmap((uint64_t)v257, v73, v75 + 1, 1, 2, 100.0);
  v228 = v75 + 1;
  initBitmap((uint64_t)&v259, v73, v75 + 1, 1, 2, 100.0);
  v251 = v73;
  if ((int)v73 >= 1)
  {
    v76 = 0;
    v77 = 0;
    v244 = (int)v260;
    v78 = v259;
    v220 = v75 - 1;
    v248 = SHIDWORD(v260);
    v232 = 2 * SHIDWORD(v260);
    v79 = 2 * (int)v260;
    v80 = 4 * (int)v260;
    v81 = v79;
    v224 = v75;
    do
    {
      v82 = (double)(int)v77 / (double)(int)v251 * 6.28318531;
      v83 = __sincos_stret(v82);
      if ((v75 & 0x80000000) != 0)
      {
        v99 = (_WORD *)(v78 + 2 * v77 * v248);
        v93 = (unsigned __int16)*v99;
        v94 = &v99[v244];
        *v99 = (v93 - *v94) & ~(unsigned __int16)((v93 - (unsigned __int16)*v94) >> 31);
      }
      else
      {
        v86 = *(_QWORD *)&v257[0];
        v87 = v76;
        v88 = v228;
        v254 = v87;
        v89 = v235;
        v90 = v237;
        do
        {
          v91 = bilinearLookupAccurate(a1, v90, v89);
          *(_WORD *)(v78 + v87) = v91;
          *(_WORD *)(v86 + v87) = v91;
          v84 = v83.__cosval;
          v90 = v90 + v84;
          v85 = v83.__sinval;
          v89 = v89 + v85;
          v87 += v79;
          --v88;
        }
        while (v88);
        v78 = v259;
        v92 = (_WORD *)(v259 + 2 * v77 * v248);
        v93 = (unsigned __int16)*v92;
        v94 = &v92[v244];
        *v92 = (v93 - *v94) & ~(unsigned __int16)((v93 - (unsigned __int16)*v94) >> 31);
        LODWORD(v75) = v224;
        if (v224 < 2)
        {
          v76 = v254;
        }
        else
        {
          v95 = v220;
          v96 = v78;
          v76 = v254;
          do
          {
            v97 = v93 - *(unsigned __int16 *)(v96 + v80);
            v93 = *(unsigned __int16 *)(v96 + v81);
            v98 = (2 * v97) & ~((2 * v97) >> 31);
            if (v98 >= 0xFFFF)
              LOWORD(v98) = -1;
            *(_WORD *)(v96 + v81) = v98;
            v96 += v79;
            --v95;
          }
          while (v95);
          v94 = (_WORD *)(v96 + v81);
        }
      }
      *v94 = (v93 - *v94) & ~(unsigned __int16)((v93 - (unsigned __int16)*v94) >> 31);
      ++v77;
      v76 += v232;
      v81 += v232;
      v80 += v232;
    }
    while (v77 != v251);
  }
  v100 = (int *)zmalloc(168 * (int)v251);
  if (!v100)
  {
    termBitmap((void **)v257);
    termBitmap((void **)&v259);
    return v100;
  }
  v266[0] = 0.0;
  HIDWORD(v265) = 0;
  v101 = DWORD2(v259);
  if (SDWORD2(v259) < 1)
  {
    v145 = 0;
  }
  else
  {
    v102 = 0;
    v103 = 0;
    v255 = 0;
    v104 = HIDWORD(v259);
    v105 = (double)SDWORD2(v259);
    v229 = 4 * (int)v260;
    v233 = (int)v260;
    v106 = 2 * SHIDWORD(v260);
    v107 = v100;
    v108 = 2 - HIDWORD(v259);
    v109 = v100 + 12;
    __asm { FMOV            V3.2D, #0.5 }
    v213 = v107;
    v221 = DWORD2(v259);
    v225 = v106;
    v219 = HIDWORD(v259);
    v252 = 2 * (int)v260;
    v218 = _Q3;
    do
    {
      *v107 = 0;
      v114 = (double)(int)v103 / v105 * 6.28318531;
      v115 = __sincos_stret(v114);
      if (v104 >= 3)
      {
        v240 = v109;
        v245 = v103;
        LOBYTE(v116) = 0;
        v117 = v115.__cosval;
        v118 = v115.__sinval;
        v119 = v259;
        v120 = v259 + 2 * v233;
        v121 = *(_QWORD *)&v257[0] + v229;
        v122 = v259 + v229;
        v123 = 1;
        v249 = v102;
        v124 = v252;
        do
        {
          v125 = *(unsigned __int16 *)(v120 + v102);
          v126 = *(unsigned __int16 *)(v122 + v102);
          v127 = *(unsigned __int16 *)(v121 + v102);
          if (v116)
          {
            if (v125 == v126)
            {
              LOBYTE(v116) = 1;
            }
            else
            {
              if (v125 > v126)
              {
                v266[0] = (float)(v255 + v123) * 0.5;
                hopperInsert(v107, (float)v125, v266[0], (float)(v237 + (float)(v117 * v266[0])), (float)(v235 + (float)(v118 * v266[0])), (float)v127 * 0.000061275);
                v124 = v252;
              }
              LOBYTE(v116) = 0;
            }
          }
          else
          {
            v128 = *(unsigned __int16 *)(v119 + v102);
            if (v125 > v128 && v125 > v126)
            {
              if (maximumPointWithSamples(v266, (float *)&v265 + 1, (float)v128, (float)v125, (float)v126))
              {
                v266[0] = v266[0] + (float)(v123 - 1);
                hopperInsert(v107, *((float *)&v265 + 1), v266[0], (float)(v237 + (float)(v117 * v266[0])), (float)(v235 + (float)(v118 * v266[0])), (float)v127 * 0.000061275);
              }
              LOBYTE(v116) = 0;
              v124 = v252;
            }
            else
            {
              v116 = v125 > v128 && v125 == v126;
              v130 = v255;
              if (v116)
                v130 = v123;
              v255 = v130;
            }
          }
          v102 += v124;
          ++v123;
        }
        while (v108 + v123 != 1);
        v131 = *v107;
        v106 = v225;
        v109 = v240;
        if (*v107 < 1)
        {
          v101 = v221;
          v103 = v245;
          v102 = v249;
          v104 = v219;
        }
        else
        {
          v132 = 0;
          v133 = v107 + 2;
          v101 = v221;
          v103 = v245;
          v102 = v249;
          v104 = v219;
          do
          {
            if (v131 >= 1)
            {
              v134 = 0;
              v135 = v240;
              v136 = v107 + 2;
              v137 = v131;
              do
              {
                if (v132 < v134)
                {
                  v138 = *((float *)v133 + 1);
                  v139 = *((float *)v136 + 1);
                  if (vabds_f32(v138, v139) < 2.6)
                  {
                    v140 = (float)(v138 + v139) * 0.5;
                    *((float *)v133 + 1) = v140;
                    *(float *)v133 = (float)(*(float *)v133 + *(float *)v136) * 0.5;
                    if (v140 <= *((float *)v136 + 1))
                      v141 = v136;
                    else
                      v141 = v133;
                    v133[2] = v141[2];
                    *((float64x2_t *)v133 + 1) = vmulq_f64(vaddq_f64(*((float64x2_t *)v133 + 1), *((float64x2_t *)v136 + 1)), v218);
                    v131 = v137 - 1;
                    if ((int)v134 + 1 < v137)
                    {
                      v142 = (v137 - 1);
                      v143 = v135;
                      do
                      {
                        v144 = *((_OWORD *)v143 + 1);
                        *(_OWORD *)(v143 - 10) = *(_OWORD *)v143;
                        *(_OWORD *)(v143 - 6) = v144;
                        *((_QWORD *)v143 - 1) = *((_QWORD *)v143 + 4);
                        v143 += 10;
                        --v142;
                      }
                      while (v134 != v142);
                    }
                    *v107 = v131;
                    v137 = v131;
                  }
                }
                ++v134;
                v136 += 10;
                v135 += 10;
              }
              while (v137 > (int)v134);
            }
            ++v132;
            v133 += 10;
          }
          while ((int)v132 < v131);
        }
      }
      ++v103;
      v107 += 42;
      v102 += v106;
      v109 += 42;
    }
    while (v103 != v101);
    LODWORD(v145) = 0;
    v100 = v213;
    v146 = v213;
    do
    {
      v147 = *v146;
      v146 += 42;
      v145 = (v147 + v145);
      LODWORD(v101) = v101 - 1;
    }
    while ((_DWORD)v101);
  }
  termBitmap((void **)v257);
  termBitmap((void **)&v259);
  v149 = computeOutlineByTracingSnake((uint64_t)v100, v251, v145, (uint64_t)&v262, (uint64_t)&v263, v148);
  zfree(v100);
  if (!v149)
    return 0;
  v150 = v263;
  v151 = v262;
  if (v263 < 1)
  {
    v158 = 0.0;
    v157 = 0.0;
    v156 = 0.0;
    v155 = 0.0;
    v154 = 0.0;
  }
  else
  {
    v152 = 0;
    v153 = (double *)(v262 + 8);
    v154 = 0.0;
    v155 = 0.0;
    v156 = 0.0;
    v157 = 0.0;
    v158 = 0.0;
    do
    {
      v159 = *(v153 - 1);
      if (v152)
      {
        if (v159 > v155)
          v160 = v159;
        else
          v160 = v155;
        if (v159 >= v157)
          v155 = v160;
        else
          v157 = v159;
        if (*v153 > v154)
          v161 = *v153;
        else
          v161 = v154;
        if (*v153 >= v156)
          v154 = v161;
        else
          v156 = *v153;
      }
      else
      {
        v157 = v159;
        v156 = *v153;
        v155 = v157;
        v154 = v156;
      }
      v158 = v158 + *((float *)v153 + 2);
      ++v152;
      v153 += 6;
    }
    while (v263 != v152);
  }
  v246 = v156;
  v241 = v157;
  v162 = (float)(1.0 / (float)v263) * v158;
  v163 = v162;
  if (v162 <= 4.0)
    v164 = v162;
  else
    v164 = 4.0;
  if (v162 > 3.0)
    v162 = 3.0;
  v165 = v163 * 0.5;
  if (v165 < v162)
    v162 = v165;
  v226 = v162;
  if (v263 >= 1)
  {
    v166 = -v162;
    v167 = (double *)v262;
    do
    {
      v168 = *v167;
      v169 = v167[1];
      v170 = v168 - v237;
      v171 = v169 - v235;
      v172 = (float)(v171 * v171) + (float)(v170 * v170);
      if (v172 > 0.0)
      {
        v173 = 1.0 / sqrt(v172);
        v170 = v170 * v173;
        v171 = v171 * v173;
      }
      v174 = *v167;
      *((float *)v167 + 6) = (float)(int)bilinearLookup(a1, v174, v169);
      *((float *)v167 + 9) = (float)(int)bilinearLookup(a1, v168 + (float)(v164 * v170), v169 + (float)(v164 * v171));
      *((float *)v167 + 8) = (float)(int)bilinearLookup(a1, v168 + (float)(v166 * v170), v169 + (float)(v166 * v171));
      v167 += 6;
      --v150;
    }
    while (v150);
  }
  v175 = vcvtms_s32_f32(v164 + v154);
  v176 = vcvtms_s32_f32(v164 + v155);
  v178 = *(_DWORD *)(a1 + 8);
  v177 = *(_DWORD *)(a1 + 12);
  if ((int)(v175 + 1) < v177)
    v179 = v175 + 1;
  else
    v179 = v177 - 1;
  v256 = v179;
  v180 = v178 - 1;
  if ((int)(v176 + 1) < v178)
    v180 = v176 + 1;
  v253 = v180;
  v250 = *(int *)(a1 + 16);
  v181 = *(int *)(a1 + 28);
  v182 = (int *)zmalloc(0x28uLL);
  v100 = v182;
  if (!v182)
  {
    zfree(v151);
    return v100;
  }
  initBitmap((uint64_t)v182, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), 1, 1, 100.0);
  if (!*(_QWORD *)v100)
  {
    zfree(v151);
    zfree(v100);
    return 0;
  }
  v183 = vcvtms_s32_f32(v246 - v164);
  v184 = v183 & ~(v183 >> 31);
  bzero(*(void **)v100, v100[6]);
  if (v184 < v256)
  {
    v185 = vcvtms_s32_f32(v241 - v164);
    v186 = v185 & ~(v185 >> 31);
    v242 = v100[4];
    v187 = *(_QWORD *)v100 + (int)v242 * (uint64_t)v184;
    v188 = *(_QWORD *)a1 + (int)v250 * (uint64_t)v184;
    v222 = v100;
    v189 = v100[7];
    v236 = (int)v189 * (uint64_t)v186;
    v238 = (int)v181 * (uint64_t)v186;
    v234 = v253 - v186;
    v247 = v186;
    v230 = v186 - v216;
    do
    {
      if (v253 > v247)
      {
        v190 = (float)(v184 - HIDWORD(v216));
        v191 = v190 * v190;
        v192 = v190;
        v193 = v230;
        v194 = v234;
        v196 = v236;
        v195 = v238;
        do
        {
          v197 = sqrtf(v191 + (float)((float)v193 * (float)v193));
          v198 = atan2(v192, (float)v193);
          LOBYTE(v199) = 0;
          v200 = v198 * (float)(int)v251 / 6.28318531;
          v201 = vcvtms_s32_f32(v200);
          v202 = (v251 & (v201 >> 31)) + v201;
          if (v202 + 1 == (_DWORD)v251)
            v203 = 0;
          else
            v203 = v202 + 1;
          v204 = (float *)&v262[48 * v202];
          v205 = (float *)&v262[48 * v203];
          v206 = v200 - (float)(int)floorf(v200);
          v207 = v204[4] + (float)((float)(v205[4] - v204[4]) * v206);
          if (v197 <= (float)(v164 + v207))
          {
            if (v197 >= (float)(v207 - v226))
            {
              v208 = v204[8];
              v209 = v204[9] + (float)((float)(v205[9] - v204[9]) * v206);
              v210 = v208 + (float)((float)(v205[8] - v208) * v206);
              if (v209 >= v210)
              {
                LOBYTE(v199) = 0x80;
              }
              else
              {
                LOBYTE(v208) = *(_BYTE *)(v188 + v195);
                v211 = 2 * (uint64_t)rintf((float)((float)((float)LODWORD(v208) - v209) * 255.0) / (float)(v210 - v209));
                if (v211 >= 255)
                  v211 = 255;
                v199 = v211 & ~(v211 >> 31);
              }
            }
            else
            {
              LOBYTE(v199) = -1;
            }
          }
          *(_BYTE *)(v187 + v196) = v199;
          v196 += v189;
          v195 += v181;
          ++v193;
          --v194;
        }
        while (v194);
      }
      ++v184;
      v188 += v250;
      v187 += v242;
    }
    while (v184 != v256);
    v151 = v262;
    v100 = v222;
  }
  zfree(v151);
  *v214 = v216;
  *v215 = HIDWORD(v216);
  return v100;
}

uint64_t computeOutlineByTracingSnake(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  int *v7;
  _QWORD *v8;
  _QWORD *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t result;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  _BYTE *v24;
  int v25;
  uint64_t v26;
  _BYTE *v27;
  float32x2_t *v28;
  float v29;
  float v30;
  int v31;
  int32x2_t *v32;
  int32x2_t v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  float32x2_t *v39;
  float v40;
  int v41;
  double *v42;
  float v43;
  float v44;
  float v45;
  float32x2_t *v46;
  float32x2_t *v47;
  char v48;
  float32x2_t *v49;
  float v50;
  float v51;
  float32x2_t *v52;
  float v53;
  float v54;
  int v55;
  float *v56;
  int v57;
  float v58;
  uint64_t v59;
  uint64_t v60;
  float v61;
  uint64_t v62;
  void *v63;
  int v64;
  int *v65;
  char *v66;
  int *v67;
  int v68;
  int *v69;
  int v70;
  char *v71;
  float32x2_t *v72;
  int v73;
  uint64_t v74;
  int v75;
  char *v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  float v80;
  float v81;
  int v82;
  int *v83;
  int v84;
  char *v85;
  int *v86;
  int v87;
  char *v88;
  int v89;
  float32x2_t *v90;
  float v91;
  __int32 v92;
  __int32 v93;
  __int32 v94;
  int v95;
  int *v96;
  int v97;
  int v98;
  char *v99;
  int v100;
  char *v101;
  int v102;
  int v103;
  int v104;
  char *v105;
  int v106;
  int *v107;
  int v108;
  int v109;
  int v110;
  BOOL v111;
  int v112;
  float v113;
  int v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  _OWORD *v118;
  int v119;
  float *v120;
  int v121;
  int v122;
  int *v123;
  uint64_t v124;
  uint64_t v125;
  int *v126;
  int v127;
  int *v128;
  uint64_t v129;
  char *v130;
  int v131;
  int v132;
  int v133;
  float32x2_t *v134;
  int v135;
  int v136;
  float v137;
  int v138;
  float v139;
  int v140;
  char *v141;
  char *v142;
  char *v143;
  size_t v144;
  uint64_t v145;
  int *v146;
  int *v147;
  int *v148;
  int *v149;
  int *v150;
  uint64_t v151;
  uint64_t v152;
  _QWORD *v153;
  int *v154;
  uint64_t v155;
  int v156;
  _BYTE *v157;
  _DWORD *v158;
  float *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  int v163;
  _BYTE *v164;
  int v165;
  int v166;
  int v167;
  _DWORD *v168;
  int v169;
  char *v170;
  uint64_t v171;
  int *v172;
  int v173;
  double *v174;
  __int32 v175;
  float32x2_t *v176;
  int *v177;
  int v178;
  uint64_t v179;
  char *v180;
  int *v181;
  int v182;
  _OWORD v183[2];
  int v184;
  __int128 v185;
  _OWORD v186[35];
  _OWORD v187[25];
  int v188;
  _BYTE v189[4];
  int v190;
  _BYTE v191[4804];

  v6 = MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5, a6);
  v154 = v7;
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v14 = v6;
  *(_QWORD *)&v191[4788] = *MEMORY[0x1E0C80C00];
  v185 = 0u;
  memset(v186, 0, 496);
  v184 = 0;
  memset(v183, 0, sizeof(v183));
  result = (uint64_t)zmalloc(48 * v10);
  if (!result)
    return result;
  v16 = (char *)result;
  v153 = v9;
  v17 = 0;
  v18 = v11;
  LODWORD(v19) = 0;
  v179 = v18;
  v180 = (char *)result;
  v164 = (_BYTE *)(v14 + 40);
  v161 = v14 + 24;
  v162 = v14;
  v20 = v13;
  v163 = v13;
  v155 = v13;
  while (1)
  {
    v173 = v13 - 1;
    if (v13 < 1)
      break;
    v21 = 0;
    v22 = v164;
    while (1)
    {
      v23 = *(unsigned int *)(v14 + 168 * v21);
      v24 = v22;
      if ((int)v23 >= 1)
        break;
LABEL_8:
      ++v21;
      v22 += 168;
      if (v21 == v20)
        goto LABEL_43;
    }
    while ((*v24 & 1) != 0)
    {
      v24 += 40;
      if (!--v23)
        goto LABEL_8;
    }
    v25 = 0;
    v26 = (uint64_t)(v24 - 32);
    v27 = &v189[16 * v17];
    *(_DWORD *)v27 = v19;
    v159 = (float *)(v27 + 12);
    v160 = v17 + 1;
    v27[8] = 0;
    v157 = v27 + 8;
    v158 = v27 + 4;
    v28 = (float32x2_t *)&v16[48 * (int)v19];
    v19 = (int)v19;
    v29 = -1.0;
    v30 = 0.0;
    v156 = v19;
    v31 = v21;
    while (1)
    {
      v32 = (int32x2_t *)&v16[48 * v19];
      *(_OWORD *)v32->i8 = *(_OWORD *)(v26 + 16);
      v33 = *(int32x2_t *)v26;
      v32[2] = vrev64_s32(*(int32x2_t *)v26);
      v32[3].i32[0] = *(_DWORD *)(v26 + 8);
      *(float *)&v32[3].i32[1] = v29;
      v32[5].i32[0] = v31;
      ++v19;
      *(_DWORD *)(v26 + 32) |= 1u;
      ++v25;
      v30 = *(float *)v33.i32 + v30;
      v34 = v31 + 1 == v13 ? 0 : v31 + 1;
      if (v34 == (_DWORD)v21)
        break;
      if (v34 + 1 == v13)
        v35 = 0;
      else
        v35 = v34 + 1;
      LODWORD(v183[0]) = 0;
      v36 = *(_DWORD *)(v14 + 168 * v34);
      if (v36 < 1)
        goto LABEL_39;
      v169 = v25;
      v171 = v19;
      v37 = 0;
      v38 = v35;
      v181 = (int *)(v14 + 168 * v35);
      v165 = v34;
      v167 = v34;
      v39 = (float32x2_t *)(v14 + 168 * v34 + 8);
      v174 = (double *)(v161 + 168 * v35);
      v176 = (float32x2_t *)&v164[168 * v35];
      do
      {
        if ((v39[4].i8[0] & 1) == 0)
        {
          v40 = energyFunction1((float32x2_t *)v26, v39);
          v41 = *v181;
          if (v38 == (_DWORD)v21)
          {
            if (v41 >= 1)
            {
              v42 = v174;
              v43 = v28[2].f32[0];
              do
              {
                if (*((float *)v42 - 3) == v43
                  && *v42 == *(double *)v28
                  && v42[1] == *(double *)&v28[1]
                  && *((float *)v42 - 4) == v28[2].f32[1])
                {
                  v44 = energyFunction1(v39, (float32x2_t *)v42 - 2);
                  v45 = energyFunction1((float32x2_t *)v26, (float32x2_t *)v42 - 2);
                  minEnergyHopperInsert((int *)v183, v37, (float)(v40 + v44) + v45);
                }
                v42 += 5;
                --v41;
              }
              while (v41);
            }
          }
          else if (v41 >= 1)
          {
            v46 = v176;
            v47 = v176;
            do
            {
              v48 = v47->i8[0];
              v47 += 5;
              if ((v48 & 1) == 0)
              {
                v49 = v46 - 4;
                v50 = energyFunction1(v39, v46 - 4);
                v51 = energyFunction1((float32x2_t *)v26, v49);
                minEnergyHopperInsert((int *)v183, v37, (float)(v40 + v50) + v51);
              }
              v46 = v47;
              --v41;
            }
            while (v41);
          }
        }
        ++v37;
        v39 += 5;
      }
      while (v37 != v36);
      v13 = v163;
      v16 = v180;
      v14 = v162;
      v19 = v171;
      v25 = v169;
      v31 = v167;
      if (!LODWORD(v183[0]))
      {
LABEL_39:
        *v158 = v25;
        *v159 = v30;
        goto LABEL_41;
      }
      v26 = v162 + 168 * v165 + 40 * SDWORD2(v183[0]) + 8;
      v29 = *((float *)v183 + 1);
    }
    *v158 = v25;
    *v159 = v30;
    *v157 = 1;
    v52 = (float32x2_t *)&v16[48 * v156];
    v53 = energyFunction2((float32x2_t *)v32, v28);
    v54 = energyFunction2(v28, v52 + 6);
    v52[3].f32[1] = (float)(v53 + v54) + energyFunction2((float32x2_t *)v32, v52 + 6);
LABEL_41:
    v17 = v160;
    v20 = v155;
    if (v160 == 300)
      goto LABEL_44;
  }
LABEL_43:
  if (!(_DWORD)v17)
    goto LABEL_131;
LABEL_44:
  v55 = 0;
  v56 = (float *)v191;
  v57 = -1;
  v58 = 0.0;
  do
  {
    if (*((_BYTE *)v56 - 4) && *v56 > v58)
    {
      v57 = v55;
      v58 = *v56;
    }
    v56 += 4;
    ++v55;
  }
  while ((_DWORD)v17 != v55);
  if (v57 != -1)
  {
    v59 = *(int *)&v189[16 * v57];
    if (v13 >= 1)
    {
      v60 = 48 * (int)v59 + 28;
      v61 = 0.0;
      v62 = *(int *)&v189[16 * v57];
      do
      {
        if (*(float *)&v16[v60] > v61)
          v61 = *(float *)&v16[v60];
        ++v62;
        v60 += 48;
      }
      while (v62 < v59 + v13);
      if (v61 > 1.5)
        goto LABEL_131;
    }
    if (*(_DWORD *)&v189[16 * v57 + 4] != v13)
      puts("incorrect number of points");
    v63 = zmalloc(48 * v13);
    memmove(v63, &v16[48 * (int)v59], 48 * v13);
    zfree(v16);
    *v153 = v63;
    *v154 = v13;
    return 1;
  }
  v64 = 0;
  v188 = 0;
  memset(v187, 0, sizeof(v187));
  LODWORD(v187[0]) = 0;
  v65 = (int *)v189;
  v178 = v17;
  do
  {
    v166 = v64 + 1;
    if (v64 + 1 < v17)
    {
      v66 = &v16[48 * *v65];
      v168 = v66 + 40;
      v170 = v66;
      v67 = v65;
      v68 = v64 + 1;
      v69 = v65;
      v172 = v65;
      do
      {
        v70 = v69[4];
        v69 += 4;
        v71 = &v66[48 * v65[1]];
        v72 = (float32x2_t *)&v16[48 * v70];
        v73 = v72[5].i32[0];
        v74 = *((int *)v71 - 2);
        if (v73 <= (int)v74 + 1)
        {
          v75 = v67[5];
          if (v72[6 * v75 - 1].i32[0] >= (int)v74)
          {
            v175 = v72[6 * v75 - 1].i32[0];
            v177 = v69;
            v182 = v72[5].i32[0];
            if (v75 < 1)
            {
              v80 = 1000000000.0;
            }
            else
            {
              v76 = v71 - 48;
              v77 = v73;
              v78 = ~(_DWORD)v74;
              v79 = v75 + v73;
              v80 = 1000000000.0;
              do
              {
                if (checkPointAddress((unint64_t)&v76[48 * v78 + 48 * (int)v77], (unint64_t)v180, v179)
                  && checkPointAddress((unint64_t)v72, (unint64_t)v180, v179))
                {
                  v81 = energyFunction2((float32x2_t *)&v76[48 * v78 + 48 * (int)v77], v72);
                  if (v81 < v80)
                  {
                    v182 = v77;
                    v80 = v81;
                  }
                }
                if (v77 > v74)
                  break;
                ++v77;
                v72 += 6;
              }
              while (v77 < v79);
            }
            snakeHopperInsert((int *)v187, v64, v68, v182, v175 - *v168 + 1, v80);
            v16 = v180;
            v69 = v177;
            LODWORD(v17) = v178;
            v66 = v170;
            v65 = v172;
          }
        }
        ++v68;
        v67 = v69;
      }
      while (v68 != (_DWORD)v17);
    }
    v65 += 4;
    ++v64;
  }
  while (v166 != (_DWORD)v17);
  v82 = 0;
  v83 = (int *)v189;
  do
  {
    v84 = 0;
    v85 = &v16[48 * *v83];
    v86 = &v190;
    do
    {
      v87 = v83[1];
      v88 = &v85[48 * v87];
      if (*((_DWORD *)v88 - 2) == v173)
      {
        v89 = *(v86 - 1);
        if (!*(_DWORD *)&v180[48 * v89 + 40])
        {
          v90 = (float32x2_t *)&v180[48 * v89];
          v91 = energyFunction2((float32x2_t *)v88 - 6, v90);
          v92 = v90[6 * *v86 - 1].i32[0];
          v93 = *((_DWORD *)v85 + 10);
          if (v92 >= v93)
            v94 = v93 + ~v92;
          else
            v94 = 0;
          snakeHopperInsert((int *)v187, v82, v84, 0, *v86 + v87 + v94, v91);
          LODWORD(v17) = v178;
        }
      }
      ++v84;
      v86 += 4;
    }
    while ((_DWORD)v17 != v84);
    ++v82;
    v83 += 4;
    v16 = v180;
  }
  while (v82 != (_DWORD)v17);
  v95 = v187[0];
  if (SLODWORD(v187[0]) < 1)
    goto LABEL_131;
  v96 = (int *)((unint64_t)v187 | 0xC);
  v97 = v187[0];
  do
  {
    if (v96[2] == v163)
    {
      v124 = *(v96 - 1);
      v125 = *v96;
      printf("winning snake = connection of snakes %d and %d\n", *(v96 - 1), *v96);
      v126 = (int *)&v189[16 * v124];
      v127 = *(_DWORD *)&v189[16 * v125];
      if (*(_DWORD *)&v180[48 * v127 + 40])
      {
        v127 = *v126;
        if (*(_DWORD *)&v180[48 * *v126 + 40])
          goto LABEL_130;
        v128 = v126;
        v126 = (int *)&v189[16 * v125];
      }
      else
      {
        v128 = (int *)&v189[16 * v125];
      }
      v129 = (uint64_t)&v180[48 * v127 + 48 * v128[1]];
      v130 = &v180[48 * *v126];
      v131 = *(_DWORD *)(v129 - 8);
      v132 = *((_DWORD *)v130 + 10);
      if (v131 <= v132 + 1)
      {
        v134 = (float32x2_t *)(v129 - 48);
        v135 = v131 - 1;
        v136 = -v132;
        v133 = -1000;
        v137 = 1000000000.0;
        do
        {
          v138 = v135 + 1;
          v139 = energyFunction2((float32x2_t *)&v130[48 * v136 + 48 * v135], v134);
          if (v139 < v137)
          {
            v133 = v135 + 1;
            v137 = v139;
          }
          v134 += 6;
          ++v135;
        }
        while (v136 + v138 != 1);
      }
      else
      {
        v133 = -1000;
      }
      v140 = v163;
      v141 = (char *)zmalloc(48 * v163);
      memmove(v141, &v180[48 * *v128], 48 * v133);
      v142 = &v141[48 * v133];
      v143 = &v180[48 * *v126];
      v144 = 48 * (v163 - v133);
LABEL_142:
      memmove(v142, v143, v144);
      zfree(v180);
      *v153 = v141;
      *v154 = v140;
      return 1;
    }
    v96 += 5;
    --v97;
  }
  while (v97);
  LODWORD(v185) = 0;
  v98 = 0;
  v99 = (char *)v187 + 4;
  do
  {
    v100 = 0;
    v101 = (char *)v187 + 4;
    do
    {
      if (v100 == v98)
        goto LABEL_121;
      v103 = *((_DWORD *)v99 + 1);
      v102 = *((_DWORD *)v99 + 2);
      v104 = *((_DWORD *)v101 + 1);
      if (v102 == v104)
      {
        v105 = v99;
        v104 = *((_DWORD *)v99 + 1);
        v103 = *((_DWORD *)v99 + 2);
        v102 = *((_DWORD *)v101 + 2);
      }
      else
      {
        v105 = v101;
        if (v103 != *((_DWORD *)v101 + 2))
          goto LABEL_121;
      }
      v106 = *((_DWORD *)v105 + 4);
      v107 = (int *)&v189[16 * v102];
      v108 = *(_DWORD *)&v180[48 * *(int *)&v189[16 * v103] - 8 + 48 * *(int *)&v189[16 * v103 + 4]];
      v109 = v107[1];
      v110 = *(_DWORD *)&v180[48 * *v107 + 40];
      if (v110)
        v111 = 0;
      else
        v111 = v108 == v173;
      v112 = v110 + ~v108;
      if (v111)
        v112 = 0;
      v113 = *(float *)v99 + *(float *)v101;
      v114 = v185;
      if ((int)v185 < 1)
      {
        LODWORD(v115) = 0;
LABEL_117:
        v119 = v112 + v106 + v109;
        v120 = (float *)&v186[-1] + 7 * v115;
        v120[1] = v113;
        *((_DWORD *)v120 + 2) = v104;
        *((_DWORD *)v120 + 3) = v103;
        *((_DWORD *)v120 + 4) = v102;
        *((_DWORD *)v120 + 7) = v119;
        if (v114 < 20)
          v121 = v114 + 1;
        else
          v121 = 20;
        LODWORD(v185) = v121;
        goto LABEL_121;
      }
      v115 = 0;
      v116 = (int)v185;
      v117 = 4;
      while (*(float *)((char *)&v186[-1] + v117) <= v113)
      {
        ++v115;
        v117 += 28;
        if (v185 == v115)
        {
          v115 = v185;
          goto LABEL_115;
        }
      }
      if ((int)v185 > (int)v115)
      {
        v118 = (__int128 *)((char *)&v185 + 28 * (int)v185 + 4);
        do
        {
          if (v116 <= 19)
          {
            *v118 = *(_OWORD *)((char *)v118 - 28);
            *(_OWORD *)((char *)v118 + 12) = *(v118 - 1);
          }
          --v116;
          v118 = (_OWORD *)((char *)v118 - 28);
        }
        while (v116 > (uint64_t)v115);
      }
      v115 = v115;
LABEL_115:
      if (v115 <= 0x13)
      {
        v114 = v185;
        goto LABEL_117;
      }
LABEL_121:
      ++v100;
      v101 += 20;
    }
    while (v100 != v95);
    ++v98;
    v99 += 20;
  }
  while (v98 != v95);
  v122 = v185;
  if ((int)v185 >= 1)
  {
    v123 = (int *)v186;
    while (v123[3] < v163)
    {
      v123 += 7;
      if (!--v122)
        goto LABEL_131;
    }
    v145 = *v123;
    v146 = (int *)&v189[16 * *(v123 - 2)];
    v147 = (int *)&v189[16 * *(v123 - 1)];
    v148 = (int *)&v189[16 * v145];
    if (!*(_DWORD *)&v180[48 * *v148 + 40])
    {
      v149 = (int *)&v189[16 * v145];
      v150 = v146;
      v148 = v147;
      goto LABEL_149;
    }
    if (!*(_DWORD *)&v180[48 * *v147 + 40])
    {
      v149 = v147;
      v150 = (int *)&v189[16 * v145];
      v148 = v146;
      goto LABEL_149;
    }
    v149 = v146;
    v150 = v147;
    if (!*(_DWORD *)&v180[48 * *v146 + 40])
    {
LABEL_149:
      v151 = *(int *)&v180[48 * *v150 + 40];
      v152 = *(int *)&v180[48 * *v148 + 40];
      v140 = v163;
      v141 = (char *)zmalloc(48 * v163);
      memmove(v141, &v180[48 * *v149], 48 * v151);
      memmove(&v141[48 * v151], &v180[48 * *v150], 48 * (v152 - v151));
      v142 = &v141[48 * (int)v152];
      v143 = &v180[48 * *v148];
      v144 = 48 * v148[1];
      goto LABEL_142;
    }
LABEL_130:
    puts("error - impossible connect arrangement");
  }
LABEL_131:
  zfree(v16);
  return 0;
}

uint64_t computeBorderForAlpha(uint64_t result, uint64_t a2, _BYTE *a3, int *a4)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  _BYTE *v20;
  _BYTE *v21;
  int v22;
  int v23;
  int v24;
  BOOL v25;
  BOOL v26;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  float v35;
  float v36;
  int v37;
  int v38;
  int v39;
  float v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  unsigned __int8 *v46;
  uint64_t v47;
  unsigned __int8 *v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v54;
  _BYTE *v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  uint64_t v69;

  v4 = *(_DWORD *)(a2 + 12);
  if (v4 < 3)
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    v6 = *(int *)(a2 + 16);
    v7 = *(int *)(result + 16);
    v8 = *(int *)(result + 28);
    v9 = *(_BYTE **)a2;
    v65 = (int)v8 - (int)v7;
    v66 = -(int)v7 - (int)v8;
    v62 = (int)v8 + (int)v7;
    v63 = v8;
    v10 = *(int *)(a2 + 28);
    v11 = *(_DWORD *)(a2 + 8);
    v12 = v6 + v10;
    v13 = v6 + v10 + (int)v10 - (int)v6;
    v67 = v4 - 2;
    v61 = v11 - 2;
    v14 = v6 + 2 * v10;
    v15 = 2 * v6;
    v64 = v7;
    v59 = v7 - v8;
    v60 = -v8;
    v16 = v10 + 2 * v6;
    v54 = v11;
    v17 = 2 - v11;
    v68 = 1;
    v69 = v6 + v10 + (int)v10 + (int)v6;
    v57 = v10;
    v58 = v6 + v10;
    v56 = 2 - v11;
    v18 = -v7;
    do
    {
      v55 = v9;
      if (v54 >= 3)
      {
        v19 = 1;
        v20 = v9;
        do
        {
          v21 = &v20[v10];
          if (v20[v12])
          {
            v22 = v20[v6];
            v23 = v20[v14];
            v24 = v20[v16];
            v25 = !*v21 || v22 == 0;
            v26 = v25 || v23 == 0;
            if (v26 || v24 == 0)
            {
              v28 = v20[v6 - (int)v6];
              v29 = v20[v13];
              v30 = v20[v15];
              v31 = v20[v69];
              v32 = v29 - (v28 + v30) + 2 * (v23 - v22) + v31;
              v33 = v30 - (v29 + v28) + v31 + 2 * (v24 - *v21);
              v34 = v32 * v32 + v33 * v33;
              if (v34)
              {
                if (v5 <= 399)
                {
                  v35 = 1.0 / sqrtf((float)v34);
                  v36 = v35 * (float)v33;
                  v37 = v67;
                  v38 = v68 - (uint64_t)rintf(v36 * 3.0);
                  if (v38 <= 1)
                    v38 = 1;
                  if (v38 >= v67)
                    v39 = v67;
                  else
                    v39 = v38;
                  v40 = v35 * (float)v32;
                  v41 = v19 - (uint64_t)rintf(v40 * 3.0);
                  if (v41 <= 1)
                    v41 = 1;
                  if (v41 >= v61)
                    v42 = v61;
                  else
                    v42 = v41;
                  v43 = v68 + (uint64_t)rintf(v36 + v36);
                  if (v43 <= 1)
                    v43 = 1;
                  if (v43 < v67)
                    v37 = v43;
                  v44 = v19 + (uint64_t)rintf(v40 + v40);
                  if (v44 <= 1)
                    v44 = 1;
                  if (v44 >= v61)
                    v45 = v61;
                  else
                    v45 = v44;
                  v46 = (unsigned __int8 *)(*(_QWORD *)result + v39 * (int)v64 + v42 * (int)v63);
                  v47 = v15;
                  v48 = (unsigned __int8 *)(*(_QWORD *)result + v37 * (int)v64 + v45 * (int)v63);
                  LODWORD(v46) = (v46[v66]
                                + 4 * *v46
                                + 2 * (v46[v60] + v46[v18] + v46[v63] + v46[v64])
                                + v46[v65]
                                + v46[v59]
                                + v46[v62]
                                + 8) >> 4;
                  v17 = v56;
                  v49 = v48[v65];
                  v50 = v48[v59];
                  v51 = v48[v62];
                  LODWORD(v48) = v48[v66] + 4 * *v48 + 2 * (v48[v60] + v48[v18] + v48[v63] + v48[v64]);
                  v52 = v49 + v50 + v51;
                  v15 = v47;
                  v10 = v57;
                  v12 = v58;
                  *a3 = v19;
                  a3[1] = v68;
                  a3[2] = v45;
                  a3[3] = v37;
                  a3[4] = v42;
                  a3[5] = v39;
                  a3[6] = ((_DWORD)v48 + v52 + 8) >> 4;
                  a3[7] = (_BYTE)v46;
                  a3 += 8;
                  ++v5;
                }
              }
            }
          }
          ++v19;
          v20 = v21;
        }
        while (v17 + v19 != 1);
      }
      v9 = &v55[v6];
      v25 = v68++ == v67;
    }
    while (!v25);
  }
  *a4 = v5;
  return result;
}

uint64_t buildTransferTable(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  int v6;
  int v7;
  char v8;

  v5 = 0;
  v6 = -((HIDWORD(a3) - a3) * result);
  v7 = -((240 - HIDWORD(a3)) * HIDWORD(result));
  do
  {
    v8 = a3;
    if (v5 >= (int)result)
    {
      if (v5 >= result >> 32)
      {
        if ((unint64_t)v5 >= 0xF0)
          v8 = v5;
        else
          v8 = (uint64_t)rintf((float)v7 / (float)(240 - HIDWORD(result))) + BYTE4(a3);
      }
      else
      {
        v8 = (uint64_t)rintf((float)v6 / (float)(HIDWORD(result) - result)) + a3;
      }
    }
    *(_BYTE *)(a5 + v5++) = v8;
    v6 += HIDWORD(a3) - a3;
    v7 += 240 - HIDWORD(a3);
  }
  while (v5 != 256);
  return result;
}

void examineAlpha(unsigned __int8 **a1, unsigned __int8 **a2, char **a3, _DWORD *a4, float *a5, float *a6, _DWORD *a7, float *a8)
{
  BOOL v10;
  int v12;
  int v13;
  int32x4_t v14;
  int v15;
  int v16;
  unsigned __int8 *v17;
  char *v18;
  int v19;
  unsigned __int8 *v20;
  int v21;
  int v22;
  unsigned __int8 *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  unsigned int v57;
  unsigned __int8 *v58;
  unsigned __int8 *v59;
  char *v60;
  int v61;
  unsigned int v62;
  unsigned int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  unsigned int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  unsigned int v74;
  unsigned int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  unsigned int v83;
  int v84;
  int v85;
  int v86;
  uint64_t v87;
  int32x4_t v88;
  float v89;
  int32x4_t v90;
  int32x4_t v91;
  float32x4_t v92;
  uint64_t v93;
  int v94;
  float32x4_t v95;
  int32x4_t v96;
  float v97;
  int32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float v101;
  uint64_t v102;
  int v103;
  int i;
  uint64_t v105;
  int v106;
  int v107;
  unint64_t v108;
  int v109;
  int v110;
  int v111;
  uint64_t v112;
  int v113;
  float v114;
  int v115;
  uint64_t v116;
  float v117;
  float v118;
  float v119;
  int v120;
  int v126;
  int v127;
  int v128;
  uint64_t v129;
  int v130;
  int v131;
  int v132;
  _OWORD v133[2];
  int v134;
  _OWORD v135[2];
  _DWORD v136[256];
  uint64_t v137;

  v137 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)a1 + 7) == 1 && (*((_DWORD *)a3 + 7) == 1 ? (v10 = *((_DWORD *)a2 + 7) == 2) : (v10 = 0), v10))
  {
    v12 = *((_DWORD *)a1 + 2);
    if (v12 == *((_DWORD *)a3 + 2)
      && (v130 = *((_DWORD *)a1 + 3), v130 == *((_DWORD *)a3 + 3))
      && (v129 = *((int *)a1 + 4), (_DWORD)v129 == *((_DWORD *)a3 + 4))
      && v12 == 2 * *((_DWORD *)a2 + 2)
      && v130 == 2 * *((_DWORD *)a2 + 3))
    {
      v13 = *((_DWORD *)a2 + 4);
      bzero(v136, 0x400uLL);
      v134 = 0;
      v14 = 0uLL;
      memset(v133, 0, sizeof(v133));
      memset(v135, 0, sizeof(v135));
      v15 = 0;
      if (v130 >= 1)
      {
        v16 = 0;
        v17 = *a2;
        v18 = *a3;
        v127 = v12;
        v128 = -v13;
        v19 = v12 - 2;
        v20 = *a1;
        v126 = v13;
        do
        {
          if (v16 == v130 - 1)
            v21 = 0;
          else
            v21 = v13;
          if (v16)
            v22 = v128;
          else
            v22 = 0;
          if ((v16 & 1) == 0)
            v21 = v22;
          v23 = &v17[v21];
          v24 = *v17;
          v25 = v17[1];
          v26 = *v23;
          v27 = v23[1];
          v131 = v16;
          v132 = v16 & 1;
          if (v12 < 3)
          {
            v32 = *v17;
            v31 = v17[1];
            v30 = *v23;
            v29 = v23[1];
            v58 = v20;
            v60 = v18;
            v59 = v17;
          }
          else
          {
            v28 = 0;
            v29 = v23[1];
            v30 = *v23;
            v31 = v17[1];
            v32 = *v17;
            do
            {
              v33 = v26 + v32;
              v32 = v24;
              v34 = v20[v28];
              v35 = (9 * v25 + v29 + 3 * (v27 + v31) + 8) >> 4;
              v36 = ((9 * v24 + v30 + 3 * v33 + 8) >> 4) - 128;
              v35 -= 128;
              v37 = v34 + ((int)(22970 * v35 + 0x2000) >> 14);
              v38 = v34 + ((int)(-11700 * v35 - 5638 * v36 + 0x2000) >> 14);
              v39 = v34 + ((int)(29032 * v36 + 0x2000) >> 14);
              if (v37 >= 255)
                v37 = 255;
              if (v38 >= 255)
                v38 = 255;
              if (v39 >= 255)
                v39 = 255;
              if (v18[v28] < 0)
              {
                v40 = v38 & ~(v38 >> 31);
                v41 = v39 & ~(v39 >> 31);
                if (v40 >= v41)
                {
                  v42 = (v37 & ~(v37 >> 31)) - v41;
                  if (v42 >= 1)
                  {
                    v43 = ((int)((v40 - v41) << 6) / (int)(v42 + v40 - v41) + 2) >> 2;
                    if (v43 >= 8)
                      v43 = 8;
                    ++*((_DWORD *)v133 + v43);
                  }
                }
                else
                {
                  ++LODWORD(v133[0]);
                }
                if (v41 < (int)v40)
                  v40 = v41;
                ++v136[v40];
                ++*((_DWORD *)v135 + (v40 >> 5));
                ++v15;
              }
              v44 = v20[v28 + 1];
              v31 = v17[v28 + 1];
              v24 = v17[v28 + 2];
              v25 = v17[v28 + 3];
              v30 = v23[v28];
              v29 = v23[v28 + 1];
              v26 = v23[v28 + 2];
              v27 = v23[v28 + 3];
              v45 = ((9 * v32 + v26 + 3 * (v30 + v24) + 8) >> 4) - 128;
              v46 = ((9 * v31 + v27 + 3 * (v29 + v25) + 8) >> 4) - 128;
              v47 = v44 + ((int)(22970 * v46 + 0x2000) >> 14);
              v48 = v44 + ((int)(-11700 * v46 - 5638 * v45 + 0x2000) >> 14);
              v49 = v44 + ((int)(29032 * v45 + 0x2000) >> 14);
              if (v47 >= 255)
                v50 = 255;
              else
                v50 = v47;
              if (v48 >= 255)
                v51 = 255;
              else
                v51 = v48;
              if (v49 >= 255)
                v52 = 255;
              else
                v52 = v49;
              if (v18[v28 + 1] < 0)
              {
                v53 = v51 & ~(v51 >> 31);
                v54 = v52 & ~(v52 >> 31);
                if (v53 >= v54)
                {
                  v55 = (v50 & ~(v50 >> 31)) - v54;
                  if (v55 >= 1)
                  {
                    v56 = (((v53 - v54) << 6) / (v55 + v53 - v54) + 2) >> 2;
                    if (v56 >= 8)
                      v56 = 8;
                    ++*((_DWORD *)v133 + v56);
                  }
                }
                else
                {
                  ++LODWORD(v133[0]);
                }
                if (v54 >= v53)
                  v57 = v53;
                else
                  v57 = v52 & ~(v52 >> 31);
                ++v136[v57];
                ++*((_DWORD *)v135 + (v57 >> 5));
                ++v15;
              }
              v28 += 2;
            }
            while ((int)v28 < v19);
            v23 += v28;
            v58 = &v20[v28];
            v59 = &v17[v28];
            v60 = &v18[v28];
          }
          v61 = *v58;
          v62 = (9 * v25 + v29 + 3 * (v27 + v31) + 8) >> 4;
          v63 = ((9 * v24 + v30 + 3 * (v26 + v32) + 8) >> 4) - 128;
          v62 -= 128;
          v64 = v61 + ((int)(22970 * v62 + 0x2000) >> 14);
          v65 = v61 + ((int)(-11700 * v62 - 5638 * v63 + 0x2000) >> 14);
          v66 = v61 + ((int)(29032 * v63 + 0x2000) >> 14);
          if (v64 >= 255)
            v64 = 255;
          if (v65 >= 255)
            v65 = 255;
          if (v66 >= 255)
            v67 = 255;
          else
            v67 = v66;
          if (*v60 < 0)
          {
            v69 = v65 & ~(v65 >> 31);
            v70 = v67 & ~(v67 >> 31);
            if (v69 >= v70)
            {
              v71 = (v64 & ~(v64 >> 31)) - v70;
              v13 = v126;
              v12 = v127;
              v68 = v131;
              if (v71 >= 1)
              {
                v72 = ((int)((v69 - v70) << 6) / (int)(v71 + v69 - v70) + 2) >> 2;
                if (v72 >= 8)
                  v72 = 8;
                ++*((_DWORD *)v133 + v72);
              }
            }
            else
            {
              ++LODWORD(v133[0]);
              v13 = v126;
              v12 = v127;
              v68 = v131;
            }
            if (v70 < (int)v69)
              v69 = v70;
            ++v136[v69];
            ++*((_DWORD *)v135 + (v69 >> 5));
            ++v15;
            v24 = *v59;
          }
          else
          {
            v13 = v126;
            v12 = v127;
            v68 = v131;
          }
          v73 = v58[1];
          v74 = ((9 * v24 + *v23 + 3 * (*v23 + v24) + 8) >> 4) - 128;
          v75 = ((9 * v59[1] + v23[1] + 3 * (v23[1] + v59[1]) + 8) >> 4) - 128;
          v76 = v73 + ((int)(22970 * v75 + 0x2000) >> 14);
          v77 = v73 + ((int)(-11700 * v75 - 5638 * v74 + 0x2000) >> 14);
          v78 = v73 + ((int)(29032 * v74 + 0x2000) >> 14);
          if (v76 >= 255)
            v79 = 255;
          else
            v79 = v76;
          if (v77 >= 255)
            v80 = 255;
          else
            v80 = v77;
          if (v78 >= 255)
            v81 = 255;
          else
            v81 = v78;
          if (v60[1] < 0)
          {
            v83 = v80 & ~(v80 >> 31);
            v84 = v81 & ~(v81 >> 31);
            v82 = v132;
            if (v83 >= v84)
            {
              v85 = (v79 & ~(v79 >> 31)) - v84;
              if (v85 >= 1)
              {
                v86 = ((int)((v83 - v84) << 6) / (int)(v85 + v83 - v84) + 2) >> 2;
                if (v86 >= 8)
                  v86 = 8;
                ++*((_DWORD *)v133 + v86);
              }
            }
            else
            {
              ++LODWORD(v133[0]);
            }
            if (v84 < (int)v83)
              v83 = v84;
            ++v136[v83];
            ++*((_DWORD *)v135 + (v83 >> 5));
            ++v15;
          }
          else
          {
            v82 = v132;
          }
          v17 += v82 * v13;
          v16 = v68 + 1;
          v20 += v129;
          v18 += v129;
        }
        while (v16 != v130);
      }
      v87 = 0;
      v88 = (int32x4_t)xmmword_19248E120;
      v89 = 0.0;
      v90.i64[0] = 0x400000004;
      v90.i64[1] = 0x400000004;
      do
      {
        v91 = (int32x4_t)v135[v87];
        v92 = vmulq_f32(vcvtq_f32_s32(v91), vcvtq_f32_s32(v88));
        v14 = vaddq_s32(v91, v14);
        v89 = (float)((float)((float)(v89 + v92.f32[0]) + v92.f32[1]) + v92.f32[2]) + v92.f32[3];
        v88 = vaddq_s32(v88, v90);
        ++v87;
      }
      while (v87 != 2);
      v93 = 0;
      v94 = vaddvq_s32(v14);
      *(float *)v14.i32 = v89 / (float)v94;
      v95 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.i8, 0);
      v96 = (int32x4_t)xmmword_19248E120;
      v97 = 0.0;
      v98.i64[0] = 0x400000004;
      v98.i64[1] = 0x400000004;
      do
      {
        v99 = vsubq_f32(vcvtq_f32_s32(v96), v95);
        v100 = vmulq_f32(vmulq_f32(v99, v99), vcvtq_f32_s32((int32x4_t)v135[v93]));
        v97 = (float)((float)((float)(v97 + v100.f32[0]) + v100.f32[1]) + v100.f32[2]) + v100.f32[3];
        v96 = vaddq_s32(v96, v98);
        ++v93;
      }
      while (v93 != 2);
      v101 = 0.0;
      if (v94 != 1)
        v101 = sqrtf(v97 / (float)(v94 - 1));
      v102 = 0;
      *a7 = v14.i32[0];
      *a8 = v101;
      do
      {
        if (v136[v102])
          break;
        ++v102;
      }
      while (v102 != 256);
      v103 = 0;
      for (i = 255; i != -1; --i)
      {
        v103 += v136[i];
        if (v103 > (5 * v15 + 50) / 100)
          break;
      }
      v105 = 0;
      v106 = 0;
      v107 = (v15 + 1) >> 1;
      do
      {
        v106 += v136[v105];
        if (v106 > v107)
          break;
        ++v105;
      }
      while (v105 != 256);
      v108 = 0;
      v109 = 0;
      v110 = 0;
      *a4 = v102;
      a4[1] = v105;
      a4[2] = i;
      do
      {
        if (v108 <= 0xC7)
        {
          v111 = v136[v108];
          v110 += v111 * v108;
          v109 += v111;
        }
        ++v108;
      }
      while (v108 != 256);
      v112 = 0;
      v113 = 0;
      a4[3] = (int)(float)((float)v110 / (float)v109);
      v114 = 0.0;
      do
      {
        v115 = *((_DWORD *)v133 + v112);
        v114 = v114 + (float)((float)v115 * (float)(int)v112);
        v113 += v115;
        ++v112;
      }
      while (v112 != 9);
      v116 = 0;
      v117 = v114 / (float)v113;
      v118 = 0.0;
      do
      {
        v118 = v118
             + (float)((float)((float)((float)(int)v116 - v117) * (float)((float)(int)v116 - v117))
                     * (float)*((int *)v133 + v116));
        ++v116;
      }
      while (v116 != 9);
      v119 = 0.0;
      v120 = v113 - 1;
      if (v120)
        v119 = sqrtf(v118 / (float)v120);
      *a5 = v117;
      *a6 = v119;
    }
    else
    {
      puts("examineAlpha: bitmaps don't match");
    }
  }
  else
  {
    puts("examineAlpha: bitmaps are the wrong number of samples per pixel");
  }
}

uint64_t redEyeDiscernment(uint64_t *a1, uint64_t a2, int *a3, uint64_t a4, float a5, float a6)
{
  uint64_t v12;
  unsigned int v13;
  int v14;
  int v15;
  char v16;
  unint64_t BitmapRect;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  char v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  char v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  _QWORD *inited;
  unint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  unsigned int i;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  float v56;
  float v57;
  float v58;
  float v59;
  int v60;
  int v61;
  uint64_t v62;
  int v63;
  int v64;
  int v65;
  double v66;
  double v67;
  double v68;
  double v69;
  unint64_t v70;
  uint64_t v71;
  float v72;
  double v73;
  double v76;
  double v77;
  double v78;
  double v79;
  BOOL v80;
  void **v81;
  double v82;
  int v83;
  int v84;
  double v85;
  double v86;
  double v87;
  BOOL v88;
  double v89;
  double v90;
  double v91;
  double v92;
  double v94;
  double v95;
  double v96;
  double v97;
  int v98;
  BOOL v99;
  BOOL v100;
  int v102;
  double v103;
  double v104;
  double v105;
  double v106;
  double v107;
  double v108;
  BOOL v109;
  double v110;
  double v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v118;
  double v119;
  double v120;
  double v121;
  double v122;
  uint64_t v123;
  uint64_t v124;
  float v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  uint64_t v132;
  unint64_t v133;
  int v134;
  double v135;
  int v136;
  int v137;
  int *v138;
  double v139;
  uint64_t v140;
  int v141;
  int v142;
  int v143;
  int v144;
  int v145;
  int v146;
  _QWORD *v147;
  int v148;
  int v149;
  int v150;
  int v151;
  int v152;
  int v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  _BYTE v157[8];
  _QWORD *v158;
  int v159;
  int v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  _OWORD v164[3];
  _OWORD v165[3];
  _OWORD v166[4];

  memset(v166, 0, 48);
  v12 = *a1;
  if (*a1)
  {
    v13 = a3[2];
    v14 = *a3;
    *(_OWORD *)((char *)&v166[1] + 8) = *(_OWORD *)(a2 + 36);
    v15 = *(_DWORD *)(a2 + 16);
    v16 = 1;
  }
  else
  {
    BitmapRect = makeBitmapRect(0, 0, 0, 0);
    v16 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    *((_QWORD *)&v166[1] + 1) = BitmapRect;
    *(_QWORD *)&v166[2] = v18;
  }
  memset(v165, 0, sizeof(v165));
  LOBYTE(v166[0]) = v16;
  *((_QWORD *)&v166[0] + 1) = v12;
  *(_QWORD *)&v166[1] = __PAIR64__(v14, v13);
  DWORD2(v166[2]) = v15;
  v19 = a1[1];
  v140 = a2;
  if (v19)
  {
    v20 = a3[6];
    v21 = a3[4];
    *(_OWORD *)((char *)&v165[1] + 8) = *(_OWORD *)(a2 + 132);
    v22 = *(_DWORD *)(a2 + 112);
    v23 = 1;
  }
  else
  {
    v24 = makeBitmapRect(0, 0, 0, 0);
    v23 = 0;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    *((_QWORD *)&v165[1] + 1) = v24;
    *(_QWORD *)&v165[2] = v25;
  }
  memset(v164, 0, sizeof(v164));
  LOBYTE(v165[0]) = v23;
  *((_QWORD *)&v165[0] + 1) = v19;
  *(_QWORD *)&v165[1] = __PAIR64__(v21, v20);
  DWORD2(v165[2]) = v22;
  v26 = a1[2];
  v138 = a3;
  if (v26)
  {
    v27 = a3[10];
    v28 = a3[8];
    *(_OWORD *)((char *)&v164[1] + 8) = *(_OWORD *)(v140 + 228);
    v29 = *(_DWORD *)(v140 + 208);
    v30 = 1;
  }
  else
  {
    v31 = v20;
    v32 = makeBitmapRect(0, 0, 0, 0);
    v20 = v31;
    v30 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    *((_QWORD *)&v164[1] + 1) = v32;
    *(_QWORD *)&v164[2] = v33;
  }
  LOBYTE(v164[0]) = v30;
  *((_QWORD *)&v164[0] + 1) = v26;
  *(_QWORD *)&v164[1] = __PAIR64__(v28, v27);
  DWORD2(v164[2]) = v29;
  if ((_DWORD)a4 == -1)
  {
    if (v12 && v19 && v26)
    {
      v155 = 0;
      v156 = 0;
      v154 = 0;
      v151 = 0;
      v148 = 0;
      v34 = v20;
      v35 = offsetBitmapRect(*((uint64_t *)&v164[1] + 1), *(uint64_t *)&v164[2], v27, v28);
      v37 = v36;
      v141 = v34;
      v38 = offsetBitmapRect(*((uint64_t *)&v165[1] + 1), *(uint64_t *)&v165[2], v34, v21);
      v39 = unionBitmapRects(v35, v37, v38);
      v41 = v40;
      v42 = HIDWORD(v40) - v40;
      inited = initBitmask(HIDWORD(v40) - (int)v40, HIDWORD(v39) - (int)v39);
      v134 = v41;
      v136 = v39;
      v44 = offsetBitmapRect(v39, v41, -(int)v41, -(int)v39);
      v132 = v45;
      v133 = v44;
      v145 = HIDWORD(v39) - v39;
      v147 = inited;
      if (HIDWORD(v39) - (int)v39 >= 1)
      {
        v46 = 0;
        v47 = v41 - v27;
        v48 = v41 - v141;
        v142 = v136 - v21;
        do
        {
          if (v42 >= 1)
          {
            for (i = 0; i != v42; ++i)
            {
              v50 = bitValueFromBitmask(v26, v47 + i, v136 - v28 + v46);
              v51 = bitValueFromBitmask(v19, v48 + i, v142 + v46) | v50;
              inited = v147;
              setBitInBitmask((uint64_t)v147, i, v46, v51);
            }
          }
          ++v46;
        }
        while (v46 != v145);
      }
      v130 = a5;
      v131 = a6;
      v157[0] = 1;
      memset(&v157[1], 0, 7);
      v158 = inited;
      v159 = v134;
      v160 = v136;
      v161 = v133;
      v162 = v132;
      v163 = bitmaskArea((uint64_t)inited);
      comparePlacedBitmasks((uint64_t)v164, (uint64_t)v165, (_DWORD *)&v156 + 1, &v156, (_DWORD *)&v155 + 1);
      v146 = HIDWORD(v155);
      v52 = v156 + HIDWORD(v156) + HIDWORD(v155);
      comparePlacedBitmasks((uint64_t)v164, (uint64_t)v166, &v155, (_DWORD *)&v154 + 1, &v154);
      v143 = HIDWORD(v154);
      v144 = v155;
      v137 = v154;
      comparePlacedBitmasks((uint64_t)v165, (uint64_t)v166, &v153, &v152, &v151);
      comparePlacedBitmasks((uint64_t)v166, (uint64_t)v157, &v150, &v149, &v148);
      v53 = *(_DWORD *)(v140 + 16);
      v54 = *(_DWORD *)(v140 + 112);
      v55 = *(_DWORD *)(v140 + 208);
      v56 = *(float *)(v140 + 20);
      v57 = *(float *)(v140 + 24);
      v58 = *(float *)(v140 + 116);
      v59 = *(float *)(v140 + 212);
      v60 = v138[2];
      v61 = *v138;
      v62 = v138[6];
      v63 = v138[4];
      v64 = v138[10];
      v65 = v138[8];
      v139 = *(double *)v140;
      v135 = *(double *)(v140 + 8);
      v67 = *(double *)(v140 + 96);
      v66 = *(double *)(v140 + 104);
      v69 = *(double *)(v140 + 192);
      v68 = *(double *)(v140 + 200);
      v70 = offsetBitmapRect(*(_QWORD *)(v140 + 132), *(_QWORD *)(v140 + 140), v62, v63);
      if (v56 <= v58)
        v72 = v58;
      else
        v72 = v56;
      if (v72 <= v59)
        v72 = v59;
      v73 = v72 * 0.5;
      if (v57 > 30.0 && v73 <= v56 || v57 > 90.0)
      {
        if (v52 >= 1)
        {
          v76 = (float)v146;
          v77 = (float)v52;
          v78 = v77 * 0.8;
          v79 = v77 * 1.25;
          v80 = v78 >= v76 || v79 <= v76;
          v81 = (void **)v147;
          if (!v80)
          {
            v82 = (float)SDWORD2(v166[2]);
            if (v82 * 0.6 < v76 && (v57 <= 100.0 || v82 * 10.0 >= v76))
            {
              a4 = v82 * 0.5 <= (float)v151;
LABEL_118:
              termBitmask(v81);
              return a4;
            }
          }
LABEL_114:
          a4 = 0;
          goto LABEL_118;
        }
        a4 = 0;
LABEL_89:
        v81 = (void **)v147;
        goto LABEL_118;
      }
      v83 = v64;
      v84 = v65;
      if (v52 < 1
        || ((v85 = (float)v146, v86 = (float)v52, v87 = v86 * 1.25, v86 * 0.8 < v85) ? (v88 = v87 <= v85) : (v88 = 1),
            v88))
      {
        if (SDWORD2(v165[2]) >= 1)
        {
          v89 = (float)(v143 + v144 + v137);
          v90 = (float)SDWORD2(v165[2]);
          v91 = v90 * 0.8;
          v92 = v90 * 1.25;
          if (v91 < v89 && v92 > v89)
            goto LABEL_88;
        }
        if (SDWORD2(v164[2]) >= 1 && SDWORD2(v165[2]) >= 1)
        {
          v94 = (float)v146;
          v95 = (float)SDWORD2(v164[2]);
          if (v95 * 0.8 < v94 && v95 * 1.25 > v94)
          {
            v96 = (float)v151;
            v97 = (float)SDWORD2(v165[2]);
            if (v97 * 0.8 < v96 && v97 * 1.25 > v96)
            {
              v98 = DWORD2(v166[2]);
              if (SDWORD2(v166[2]) >= SDWORD2(v164[2]))
                v98 = DWORD2(v164[2]);
              a4 = (float)v98 * 0.2 <= (float)v137;
              goto LABEL_89;
            }
          }
        }
        v102 = DWORD2(v166[2]);
        v81 = (void **)v147;
        if (SDWORD2(v166[2]) >= 1)
        {
          v103 = (float)v151;
          v104 = (float)SDWORD2(v166[2]);
          if (v104 * 0.8 < v103)
          {
            v105 = v68;
            if (DWORD2(v166[2]) >= 2 && v104 * 1.25 > v103)
            {
              v106 = v67;
              if (3 * DWORD2(v166[2]) > SDWORD2(v165[2]))
                goto LABEL_114;
              goto LABEL_104;
            }
LABEL_103:
            v106 = v67;
LABEL_104:
            v110 = v139 + (double)v60;
            v111 = v135 + (double)v61;
            v112 = sqrt((float)v55 / 3.14159265);
            v113 = sqrt((float)v54 / 3.14159265);
            v114 = v106 + (double)(int)v62 - v110;
            v115 = v66 + (double)v63 - v111;
            v116 = sqrtf((float)(v115 * v115) + (float)(v114 * v114));
            if (v116 <= v113 || v116 <= v112)
            {
              v118 = v58;
              v119 = v69 + (double)v83;
              v120 = v105 + (double)v84;
              v121 = v139 + (double)v60;
              v122 = v135 + (double)v61;
              v123 = v70;
              v124 = v71;
              if (!pointInsideBitmapRect(v70, v71, v121, v122)
                || !pointInsideBitmapRect(v123, v124, v119, v120)
                || SDWORD2(v165[2]) >= 4 * v102)
              {
                if (v53 > 3 * v55 && v53 > 2 * v54)
                  goto LABEL_114;
                if (v118 <= v59 || v54 <= v55)
                {
                  if (v57 <= 10.0
                    || (v126 = v110 - v130,
                        v127 = v111 - v131,
                        v128 = v119 - v130,
                        v129 = v120 - v131,
                        sqrtf((float)(v127 * v127) + (float)(v126 * v126)) * 3.0 >= sqrtf((float)(v129 * v129)+ (float)(v128 * v128))))
                  {
                    if (*(_BYTE *)(v140 + 248))
                      a4 = 1;
                    else
                      a4 = 2;
                    goto LABEL_118;
                  }
                  goto LABEL_114;
                }
              }
            }
            goto LABEL_117;
          }
        }
      }
      else
      {
        v102 = DWORD2(v166[2]);
        v107 = (float)SDWORD2(v166[2]);
        if (v86 * 0.1 > v107)
        {
LABEL_88:
          a4 = 1;
          goto LABEL_89;
        }
        v108 = (float)v148;
        v81 = (void **)v147;
        if (SDWORD2(v166[2]) >= 1 && v107 * 0.8 < v108 && v107 * 1.25 > v108)
        {
LABEL_117:
          a4 = 1;
          goto LABEL_118;
        }
        if (v107 * 0.6 < v86)
        {
          v109 = v86 * 0.8 >= v108 || v87 <= v108;
          v105 = v68;
          v106 = v67;
          if (!v109)
            goto LABEL_117;
          goto LABEL_104;
        }
      }
      v105 = v68;
      goto LABEL_103;
    }
    if (v12)
    {
      if (v19)
      {
        return *(_DWORD *)(v140 + 16) <= 2 * *(_DWORD *)(v140 + 112);
      }
      else if (v26)
      {
        return 2 * (*(_DWORD *)(v140 + 16) <= 3 * *(_DWORD *)(v140 + 208));
      }
      else
      {
        return 0;
      }
    }
    else
    {
      v99 = v26 == 0;
      if (!v19)
        v99 = 0;
      if (v99)
      {
        return 1;
      }
      else
      {
        v100 = v19 == 0;
        if (!v26)
          v100 = 0;
        if (v100)
        {
          return 2;
        }
        else if (v22 <= v29 || *(float *)(v140 + 116) <= *(float *)(v140 + 212))
        {
          return 2;
        }
        else
        {
          return 1;
        }
      }
    }
  }
  return a4;
}

uint64_t comparePlacedBitmasks(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t result;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  int v24;
  int v27;
  BOOL v28;
  int v29;
  int v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  int v37;
  int v38;
  int v39;
  int v40;

  v6 = a1;
  v7 = offsetBitmapRect(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(unsigned int *)(a1 + 16), *(_DWORD *)(a1 + 20));
  v9 = v8;
  v10 = offsetBitmapRect(*(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32), *(unsigned int *)(a2 + 16), *(_DWORD *)(a2 + 20));
  result = unionBitmapRects(v7, v9, v10);
  v38 = HIDWORD(result) - result;
  if (HIDWORD(result) - (int)result < 1)
  {
    v16 = 0;
    v40 = 0;
    v15 = 0;
  }
  else
  {
    v13 = 0;
    v14 = a2;
    v15 = 0;
    v40 = 0;
    v16 = 0;
    v17 = HIDWORD(v12) - v12;
    v36 = v12 - *(_DWORD *)(v6 + 16);
    v37 = HIDWORD(v12) - v12;
    v35 = result - *(_DWORD *)(v6 + 20);
    v18 = v14;
    v34 = v12 - *(_DWORD *)(v14 + 16);
    v33 = result - *(_DWORD *)(v14 + 20);
    do
    {
      v39 = v13;
      if (v17 >= 1)
      {
        v19 = v36;
        v20 = v35 + v13;
        v21 = v34;
        v22 = v33 + v13;
        do
        {
          v23 = v6;
          v24 = bitValueFromBitmask(*(_QWORD *)(v6 + 8), v19, v20);
          result = bitValueFromBitmask(*(_QWORD *)(v18 + 8), v21, v22);
          if (v24 == 1 && (_DWORD)result == 0)
          {
            ++v16;
          }
          else
          {
            if (v24 == 1 && (_DWORD)result == 1)
              v27 = v15 + 1;
            else
              v27 = v15;
            if (v24)
              v28 = 0;
            else
              v28 = (_DWORD)result == 1;
            v29 = v40;
            if (v28)
              v29 = v40 + 1;
            v40 = v29;
            if (!v28)
              v15 = v27;
          }
          v6 = v23;
          ++v21;
          ++v19;
          --v17;
        }
        while (v17);
      }
      v13 = v39 + 1;
      v17 = v37;
    }
    while (v39 + 1 != v38);
  }
  *a3 = v16;
  *a4 = v40;
  *a5 = v15;
  return result;
}

BOOL pointInsideBitmapRect(uint64_t a1, uint64_t a2, double a3, double a4)
{
  return a3 >= (float)(int)a2 && a3 <= (float)SHIDWORD(a2) && a4 >= (float)(int)a1 && a4 <= (float)SHIDWORD(a1);
}

unsigned __int8 **snapToPupil(unsigned __int8 **result, int a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  int v24;
  unsigned __int8 *v25;
  int v26;
  int v27;
  unsigned int v28;
  unsigned int v29;

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = *((int *)result + 7);
  v11 = *((_DWORD *)result + 3);
  v12 = *((int *)result + 4);
  v13 = (*result)[(int)v12 * a3 + (int)v10 * a2];
  v14 = -a2;
  v15 = -2;
  do
  {
    v16 = a2;
    v17 = a3;
    v18 = v13;
    if (v11 >= 1)
    {
      v19 = 0;
      v20 = *((_DWORD *)result + 2);
      v21 = *result;
      v23 = -a3;
      v22 = -v13;
      v18 = v13;
      v17 = a3;
      v16 = a2;
      do
      {
        if (v20 >= 1)
        {
          v24 = 0;
          v25 = v21;
          do
          {
            v26 = v23 * v23 + (v14 + v24) * (v14 + v24);
            v27 = *v25;
            v28 = (v26 + (1 << (v15 - 1))) >> v15;
            v29 = v26 << -(char)v15;
            if (v15 <= 0)
              v28 = v29;
            if ((int)(v28 - v27) < v22)
            {
              v16 = v24;
              v17 = v19;
              v18 = *v25;
              v22 = v28 - v27;
            }
            ++v24;
            v25 += v10;
          }
          while (v20 != v24);
        }
        ++v19;
        v21 += v12;
        ++v23;
      }
      while (v19 != v11);
    }
    if (v15 >= -1
      && sqrtf((float)((a3 - v9) * (a3 - v9) + (a2 - v8) * (a2 - v8))) * 4.0 < sqrtf((float)((a2 - v16) * (a2 - v16)
                                                                                           + (a3 - v17) * (a3 - v17))))
    {
      break;
    }
    ++v15;
    v7 = v18;
    v8 = v16;
    v9 = v17;
  }
  while (v15 != 7);
  *a4 = v8;
  *a5 = v9;
  *a6 = v7;
  return result;
}

_DWORD *computeSkinMask(_DWORD *result, unsigned __int8 **a2, uint64_t a3, uint64_t a4)
{
  int v4;
  BOOL v5;
  int v6;
  int v7;
  int v8;
  _BYTE *v9;
  unsigned __int8 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned __int8 *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  _BYTE *v23;
  unsigned __int8 *v24;
  int v25;
  int v26;
  int v27;
  int v28;

  v4 = result[3];
  v5 = __OFSUB__(v4, 1);
  v6 = v4 - 1;
  if (v6 < 0 == v5)
  {
    v7 = 0;
    v8 = *((_DWORD *)a2 + 4);
    v9 = *(_BYTE **)a3;
    v10 = *a2;
    v11 = *((int *)a2 + 7);
    v12 = (int)result[4];
    v13 = 2 * *(int *)(a3 + 28);
    do
    {
      if (v7 == v6)
        v14 = 0;
      else
        v14 = v8;
      if (v7)
        v15 = -v8;
      else
        v15 = 0;
      if ((v7 & 1) == 0)
        v14 = v15;
      v16 = &v10[v14];
      v17 = *v10;
      v18 = v10[1];
      v19 = *v16;
      v20 = v16[1];
      if ((int)result[2] < 3)
      {
        v28 = *v10;
        v27 = v10[1];
        v26 = *v16;
        v25 = v16[1];
        v24 = v10;
        v23 = v9;
      }
      else
      {
        v21 = 0;
        v22 = v14;
        v23 = v9;
        v24 = v10;
        v25 = v20;
        v26 = v19;
        v27 = v10[1];
        v28 = *v10;
        do
        {
          *v23 = *(_BYTE *)(a4
                          + ((16 * (v26 + 9 * v17 + 3 * (v19 + v28)) + 128) & 0x7FFFFF00)
                          + (unint64_t)((9 * v18 + v25 + 3 * (v20 + v27) + 8) >> 4));
          v28 = *v24;
          v27 = v24[1];
          v17 = v24[2];
          v18 = v24[3];
          v26 = v24[v22];
          v25 = v24[v22 + 1];
          v19 = v24[v22 + 2];
          v20 = v24[v22 + 3];
          v23[1] = *(_BYTE *)(a4
                            + ((16 * (3 * (v26 + v17) + 9 * v28 + v19) + 128) & 0x7FFFFF00)
                            + (unint64_t)((9 * v27 + v20 + 3 * (v25 + v18) + 8) >> 4));
          v24 += v11;
          v21 += 2;
          v23 += v13;
        }
        while (v21 < result[2] - 2);
        v16 = &v24[v22];
      }
      *v23 = *(_BYTE *)(a4
                      + ((16 * (v26 + 9 * v17 + 3 * (v19 + v28)) + 128) & 0x7FF00)
                      + (unint64_t)((9 * v18 + v25 + 3 * (v20 + v27) + 8) >> 4));
      v23[1] = *(_BYTE *)(a4
                        + ((16 * (9 * *v24 + *v16 + 3 * (*v16 + *v24)) + 128) & 0x7FF00)
                        + (unint64_t)((9 * v24[1] + v16[1] + 3 * (v16[1] + v24[1]) + 8) >> 4));
      v10 += (v7++ & 1) * v8;
      v9 += v12;
    }
    while (v7 < result[3]);
  }
  return result;
}

uint64_t examineBitmask(unsigned __int8 **a1, unsigned __int8 **a2, uint64_t a3, int *a4)
{
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  const char *v11;
  uint64_t v12;
  uint32x4_t v13;
  int v14;
  unsigned __int8 *v15;
  int v16;
  int v17;
  unsigned __int8 *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  unsigned __int8 *v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  unsigned int v46;
  unsigned int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  unsigned int v54;
  int v55;
  int v56;
  int v57;
  uint64_t v58;
  unsigned __int8 *v59;
  int v60;
  unsigned int v61;
  unsigned int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  unsigned int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  unsigned int v74;
  unsigned int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  unsigned int v83;
  int v84;
  int v85;
  int v86;
  uint64_t i;
  int v88;
  unsigned int v89;
  int v90;
  unsigned int v91;
  _OWORD *v92;
  uint64_t v93;
  unsigned int v94;
  unsigned int v95;
  int v96;
  int v97;
  uint64_t v98;
  int v99;
  _DWORD *v100;
  char *v101;
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  _DWORD *v107;
  int v108;
  uint64_t v109;
  int v110;
  int v111;
  int v112;
  int v113;
  uint64_t result;
  int v116;
  int v117;
  int v118;
  int v119;
  uint64_t v120;
  int v121;
  int v122;
  int v123;
  unsigned __int8 *v124;
  unsigned __int8 *v125;
  unsigned __int8 *v126;
  int v127;
  int v128;
  int v129;
  int v131;
  _DWORD v132[72];
  _OWORD v133[18];
  uint64_t v134;

  v134 = *MEMORY[0x1E0C80C00];
  v4 = *((_DWORD *)a1 + 2);
  v5 = *((_DWORD *)a1 + 3);
  v6 = *((int *)a1 + 4);
  v7 = *((_DWORD *)a1 + 7);
  v8 = *((_DWORD *)a2 + 7);
  v9 = *((_DWORD *)a2 + 4);
  *a4 = 0;
  if (v7 != 1 || v8 != 2)
  {
    v11 = "examineBitmask: bitmaps are the wrong number of samples per pixel";
LABEL_135:
    puts(v11);
    return 0xFFFFFFFFLL;
  }
  v12 = a3;
  if (v4 != *(_DWORD *)(a3 + 8)
    || v5 != *(_DWORD *)(a3 + 12)
    || v4 != 2 * *((_DWORD *)a2 + 2)
    || v5 != 2 * *((_DWORD *)a2 + 3))
  {
    v11 = "examineBitmask: bitmaps don't match";
    goto LABEL_135;
  }
  v13 = 0uLL;
  memset(v133, 0, sizeof(v133));
  if (v5 > 0)
  {
    v14 = 0;
    v15 = *a2;
    v117 = -v9;
    v118 = v5 - 1;
    v123 = v4 - 2;
    v126 = *a1;
    v116 = v5;
    v121 = v4;
    v120 = v6;
    v119 = v9;
    do
    {
      v16 = v117;
      if (v14 == v118)
        v17 = 0;
      else
        v17 = v9;
      if (!v14)
        v16 = 0;
      v131 = v14;
      v122 = v14 & 1;
      if ((v14 & 1) == 0)
        v17 = v16;
      v18 = &v15[v17];
      v19 = *v15;
      v20 = v15[1];
      v21 = *v18;
      v124 = v15;
      v125 = v18;
      v22 = v18[1];
      if (v4 < 3)
      {
        LODWORD(v58) = 0;
        v27 = *v15;
        v26 = v15[1];
        v25 = *v18;
        v24 = v18[1];
        v59 = v126;
      }
      else
      {
        v23 = 0;
        v24 = v22;
        v25 = v21;
        v26 = v15[1];
        v27 = *v15;
        do
        {
          v28 = v23;
          v29 = &v126[v23];
          v30 = v126[v23];
          v31 = ((9 * v27 + v21 + 3 * (v25 + v19) + 8) >> 4) - 128;
          v32 = ((9 * v26 + v22 + 3 * (v24 + v20) + 8) >> 4) - 128;
          v33 = v30 + ((int)(22970 * v32 + 0x2000) >> 14);
          v34 = v30 + ((int)(-11700 * v32 - 5638 * v31 + 0x2000) >> 14);
          v35 = v30 + ((int)(29032 * v31 + 0x2000) >> 14);
          if (v33 >= 255)
            v36 = 255;
          else
            v36 = v33;
          if (v34 >= 255)
            v37 = 255;
          else
            v37 = v34;
          if (v35 >= 255)
            v38 = 255;
          else
            v38 = v35;
          if (bitValueFromBitmask(v12, v28, v131))
          {
            v39 = v37 & ~(v37 >> 31);
            v40 = v38 & ~(v38 >> 31);
            if (v39 < v40 || (v41 = (v36 & ~(v36 >> 31)) - v40, v41 < 1))
            {
              v42 = 0;
            }
            else
            {
              v42 = ((int)((v39 - v40) << 6) / (int)(v41 + v39 - v40) + 2) >> 2;
              if (v42 >= 8)
                v42 = 8;
            }
            if (v40 < (int)v39)
              v39 = v38 & ~(v38 >> 31);
            ++*((_DWORD *)v133 + (int)(8 * v42 + (v39 >> 5)));
          }
          v43 = v29[1];
          v25 = v125[v28 + 2];
          v128 = v125[v28];
          v129 = v124[v28];
          v127 = v124[v28 + 2];
          v20 = v124[v28 + 1];
          v44 = v125[v28 + 1];
          v26 = v124[v28 + 3];
          v45 = v125[v28 + 3];
          v46 = ((9 * v129 + v25 + 3 * (v128 + v127) + 8) >> 4) - 128;
          v47 = ((9 * v20 + v45 + 3 * (v44 + v26) + 8) >> 4) - 128;
          v48 = v43 + ((int)(22970 * v47 + 0x2000) >> 14);
          v49 = v43 + ((int)(-11700 * v47 - 5638 * v46 + 0x2000) >> 14);
          v50 = v43 + ((int)(29032 * v46 + 0x2000) >> 14);
          if (v48 >= 255)
            v51 = 255;
          else
            v51 = v48;
          if (v49 >= 255)
            v52 = 255;
          else
            v52 = v49;
          if (v50 >= 255)
            v53 = 255;
          else
            v53 = v50;
          if (bitValueFromBitmask(a3, (int)v28 + 1, v131))
          {
            v54 = v52 & ~(v52 >> 31);
            v55 = v53 & ~(v53 >> 31);
            if (v54 < v55 || (v56 = (v51 & ~(v51 >> 31)) - v55, v56 < 1))
            {
              v57 = 0;
            }
            else
            {
              v57 = ((int)((v54 - v55) << 6) / (int)(v56 + v54 - v55) + 2) >> 2;
              if (v57 >= 8)
                v57 = 8;
            }
            if (v55 < (int)v54)
              v54 = v53 & ~(v53 >> 31);
            ++*((_DWORD *)v133 + (int)(8 * v57 + (v54 >> 5)));
          }
          v23 = v28 + 2;
          v12 = a3;
          v22 = v44;
          v21 = v128;
          v19 = v129;
          v24 = v45;
          v27 = v127;
        }
        while ((int)v28 + 2 < v123);
        v58 = v28 + 2;
        v125 += v58;
        v59 = &v126[v58];
        v15 = &v124[v58];
        v5 = v116;
      }
      v60 = *v59;
      v61 = ((9 * v27 + v21 + 3 * (v25 + v19) + 8) >> 4) - 128;
      v62 = ((9 * v26 + v22 + 3 * (v24 + v20) + 8) >> 4) - 128;
      v63 = v60 + ((int)(22970 * v62 + 0x2000) >> 14);
      v64 = v60 + ((int)(-11700 * v62 - 5638 * v61 + 0x2000) >> 14);
      v65 = v60 + ((int)(29032 * v61 + 0x2000) >> 14);
      if (v63 >= 255)
        v66 = 255;
      else
        v66 = v63;
      if (v64 >= 255)
        v67 = 255;
      else
        v67 = v64;
      if (v65 >= 255)
        v68 = 255;
      else
        v68 = v65;
      if (bitValueFromBitmask(v12, v58, v131))
      {
        v69 = v67 & ~(v67 >> 31);
        v70 = v68 & ~(v68 >> 31);
        if (v69 < v70 || (v71 = (v66 & ~(v66 >> 31)) - v70, v71 < 1))
        {
          v72 = 0;
        }
        else
        {
          v72 = ((int)((v69 - v70) << 6) / (int)(v71 + v69 - v70) + 2) >> 2;
          if (v72 >= 8)
            v72 = 8;
        }
        if (v70 < (int)v69)
          v69 = v68 & ~(v68 >> 31);
        ++*((_DWORD *)v133 + (int)(8 * v72 + (v69 >> 5)));
      }
      v73 = v59[1];
      v74 = ((9 * *v15 + *v125 + 3 * (*v125 + *v15) + 8) >> 4) - 128;
      v75 = ((9 * v15[1] + v125[1] + 3 * (v125[1] + v15[1]) + 8) >> 4) - 128;
      v76 = v73 + ((int)(22970 * v75 + 0x2000) >> 14);
      v77 = v73 + ((int)(-11700 * v75 - 5638 * v74 + 0x2000) >> 14);
      v78 = v73 + ((int)(29032 * v74 + 0x2000) >> 14);
      if (v76 >= 255)
        v79 = 255;
      else
        v79 = v76;
      if (v77 >= 255)
        v80 = 255;
      else
        v80 = v77;
      if (v78 >= 255)
        v81 = 255;
      else
        v81 = v78;
      v82 = bitValueFromBitmask(v12, v58 | 1, v131);
      v9 = v119;
      v13 = 0uLL;
      if (v82)
      {
        v83 = v80 & ~(v80 >> 31);
        v84 = v81 & ~(v81 >> 31);
        if (v83 < v84 || (v85 = (v79 & ~(v79 >> 31)) - v84, v85 < 1))
        {
          v86 = 0;
        }
        else
        {
          v86 = ((int)((v83 - v84) << 6) / (int)(v85 + v83 - v84) + 2) >> 2;
          if (v86 >= 8)
            v86 = 8;
        }
        if (v84 < (int)v83)
          v83 = v81 & ~(v81 >> 31);
        ++*((_DWORD *)v133 + (int)(8 * v86 + (v83 >> 5)));
      }
      v4 = v121;
      v15 = &v124[v122 * v119];
      v14 = v131 + 1;
      v126 += v120;
    }
    while (v131 + 1 != v5);
  }
  for (i = 0; i != 18; ++i)
    v13 = vmaxq_u32((uint32x4_t)v133[i], v13);
  v88 = vmaxvq_u32(v13);
  v89 = v88 - 1;
  if (v88 <= 1)
    return 0xFFFFFFFFLL;
  v90 = 0;
  v91 = v88 / 3u;
  v92 = v133;
  do
  {
    v93 = 0;
    do
    {
      v94 = *(_DWORD *)((char *)v92 + v93);
      if (v94 <= v91)
        v95 = 0;
      else
        v95 = (8 * v94 - 8) / v89 + 1;
      *(_DWORD *)((char *)v92 + v93) = v95;
      v93 += 4;
    }
    while ((_DWORD)v93 != 32);
    ++v90;
    v92 += 2;
  }
  while (v90 != 9);
  v96 = 0;
  v97 = 0;
  do
  {
    v98 = 0;
    v99 = v97;
    v100 = &v132[v97];
    v101 = (char *)v133 + 4 * v97;
    do
    {
      if ((_DWORD)v98)
        v102 = *(_DWORD *)&v101[4 * v98];
      else
        v102 = 0;
      v100[v98++] = v102;
    }
    while ((_DWORD)v98 != 8);
    ++v96;
    v97 = v99 + 8;
  }
  while (v96 != 9);
  v103 = 0;
  v104 = 0;
  v105 = 10;
  v106 = -1;
  v107 = v132;
  v108 = -1;
  do
  {
    v109 = 0;
    do
    {
      if (v104 >= v105)
        v110 = v105;
      else
        v110 = v104;
      if (v104 <= v108)
        v111 = v108;
      else
        v111 = v104;
      if ((int)v109 <= v106)
        v112 = v106;
      else
        v112 = v109;
      v113 = v109 + 1;
      if (v107[v109])
      {
        v105 = v110;
        v108 = v111;
        v106 = v112;
        ++v103;
      }
      ++v109;
    }
    while (v113 != 8);
    ++v104;
    v107 += 8;
  }
  while (v104 != 9);
  if (v103 && (v106 > 1 || v108 >= 2))
  {
    if (v108)
    {
      if (v106 == 1)
      {
        result = 1;
      }
      else if ((v105 - 1) > 1 || v108 <= 2)
      {
        if (v105 == 3 && v108 == 3)
        {
          result = 4;
        }
        else if (v108 >= 5)
        {
          result = 5;
        }
        else
        {
          result = 6;
        }
      }
      else
      {
        result = 2;
      }
    }
    else
    {
      result = 3;
    }
  }
  else
  {
    result = 0;
  }
  *a4 = v106;
  return result;
}

float f2AndPixelValueFromBorderPixelsAt(uint64_t a1, int a2, float *a3, float a4)
{
  int v4;
  float *v5;
  float v6;
  float v9;
  float v10;
  float v11;
  float v12;

  if (a2 < 1)
  {
LABEL_6:
    *a3 = *(float *)(a1 - 8);
    return (float)*(int *)(a1 - 4);
  }
  v4 = 0;
  v5 = (float *)(a1 + 8);
  while (1)
  {
    v6 = *(v5 - 2);
    if (v6 >= a4)
      break;
    ++v4;
    v5 += 3;
    if (a2 == v4)
    {
      a1 += 12 * (a2 - 1) + 12;
      goto LABEL_6;
    }
  }
  if (!v4)
  {
    *a3 = *(v5 - 1);
    return (float)*(int *)v5;
  }
  v9 = (float)(a4 - *(v5 - 5)) / (float)(v6 - *(v5 - 5));
  v10 = 0.0;
  if (v9 >= 0.0)
  {
    v10 = v9;
    if (v9 > 1.0)
      v10 = 1.0;
  }
  v11 = *(v5 - 1);
  v12 = *(v5 - 4);
  if (v11 != v12)
    v11 = v12 + (float)((float)(v11 - v12) * v10);
  *a3 = v11;
  return (float)*((int *)v5 - 3) + (float)((float)(*(_DWORD *)v5 - *((_DWORD *)v5 - 3)) * v10);
}

uint64_t crossingCompare(float *a1, float *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 > *a2;
}

uint64_t maximumPointWithSamples(float *a1, float *a2, float a3, float a4, float a5)
{
  double v5;
  double v6;
  float v7;
  float v8;
  float v9;

  v5 = a4;
  v6 = a5;
  v7 = (a3 + a4 * -2.0 + v6) * 0.5;
  if (v7 == 0.0)
    return 0;
  v8 = v5 + v5 + a3 * -1.5 + v6 * -0.5;
  v9 = (float)-v8 / (v7 + v7);
  if (v9 <= 0.0 || v9 >= 2.0)
    return 0;
  *a1 = v9;
  *a2 = (float)(a3 + (float)(v8 * v9)) + (float)((float)(v7 * v9) * v9);
  return 1;
}

int *hopperInsert(int *result, float a2, float a3, double a4, double a5, float a6)
{
  uint64_t v6;
  uint64_t v7;
  float *v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  float *v12;
  int v13;

  v6 = *result;
  if ((int)v6 < 1)
  {
    LODWORD(v7) = 0;
LABEL_13:
    v12 = (float *)&result[10 * v7];
    v12[2] = a2;
    v12[3] = a3;
    v12[4] = a6;
    *((double *)v12 + 3) = a4;
    *((double *)v12 + 4) = a5;
    v12[10] = 0.0;
    if (*result < 4)
      v13 = *result + 1;
    else
      v13 = 4;
    *result = v13;
    return result;
  }
  v7 = 0;
  v8 = (float *)(result + 2);
  while (*v8 >= a2)
  {
    ++v7;
    v8 += 10;
    if (v6 == v7)
    {
      LODWORD(v7) = *result;
      goto LABEL_12;
    }
  }
  if ((int)v6 > (int)v7)
  {
    v9 = (int)v6;
    v10 = (uint64_t)&result[10 * (int)v6 + 2];
    do
    {
      if (v9 <= 3)
      {
        v11 = *(_OWORD *)(v10 - 24);
        *(_OWORD *)v10 = *(_OWORD *)(v10 - 40);
        *(_OWORD *)(v10 + 16) = v11;
        *(_QWORD *)(v10 + 32) = *(_QWORD *)(v10 - 8);
      }
      --v9;
      v10 -= 40;
    }
    while (v9 > v7);
  }
LABEL_12:
  if (v7 <= 3)
    goto LABEL_13;
  return result;
}

float energyFunction2(float32x2_t *a1, float32x2_t *a2)
{
  float32x2_t v2;
  float32x2_t v3;
  float64x2_t v4;
  float64x2_t v5;

  v2 = a1[2];
  v3 = a2[2];
  v4 = vcvtq_f64_f32(vabd_f32(v2, v3));
  v5 = vcvtq_f64_f32(vadd_f32(v2, v3));
  __asm { FMOV            V3.2D, #0.5 }
  return vabds_f32(a1[3].f32[0], a2[3].f32[0]) + vaddv_f32(vcvt_f32_f64(vdivq_f64(v4, vmulq_f64(v5, _Q3))));
}

float energyFunction1(float32x2_t *a1, float32x2_t *a2)
{
  __asm { FMOV            V3.2D, #0.5 }
  return vabds_f32(a1[1].f32[0], a2[1].f32[0])
       + vaddv_f32(vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(vabd_f32(*a1, *a2)), vmulq_f64(vcvtq_f64_f32(vadd_f32(*a1, *a2)), _Q3))));
}

int *minEnergyHopperInsert(int *result, int a2, float a3)
{
  uint64_t v3;
  uint64_t v4;
  float *v5;
  float *v6;
  int v7;

  v3 = *result;
  if ((int)v3 < 1)
  {
    LODWORD(v4) = 0;
LABEL_13:
    v6 = (float *)&result[2 * v4];
    v6[1] = a3;
    *((_DWORD *)v6 + 2) = a2;
    if (*result < 4)
      v7 = *result + 1;
    else
      v7 = 4;
    *result = v7;
    return result;
  }
  v4 = 0;
  v5 = (float *)(result + 1);
  while (*v5 <= a3)
  {
    ++v4;
    v5 += 2;
    if (v3 == v4)
    {
      LODWORD(v4) = *result;
      goto LABEL_12;
    }
  }
  if ((int)v3 > (int)v4)
  {
    v3 = (int)v3;
    do
    {
      if (v3 <= 3)
        *(_QWORD *)&result[2 * v3 + 1] = *(_QWORD *)&result[2 * v3 - 1];
      --v3;
    }
    while (v3 > v4);
  }
LABEL_12:
  if (v4 <= 3)
    goto LABEL_13;
  return result;
}

BOOL checkPointAddress(unint64_t a1, unint64_t a2, uint64_t a3)
{
  return a1 >= a2 && a2 + 48 * a3 > a1;
}

int *snakeHopperInsert(int *result, int a2, int a3, int a4, int a5, float a6)
{
  uint64_t v6;
  uint64_t v7;
  float *v8;
  uint64_t v9;
  uint64_t v10;
  float *v11;
  int v12;

  v6 = *result;
  if ((int)v6 < 1)
  {
    LODWORD(v7) = 0;
LABEL_13:
    v11 = (float *)&result[5 * v7];
    v11[1] = a6;
    *((_DWORD *)v11 + 2) = a2;
    *((_DWORD *)v11 + 3) = a3;
    *((_DWORD *)v11 + 4) = a4;
    *((_DWORD *)v11 + 5) = a5;
    if (*result < 20)
      v12 = *result + 1;
    else
      v12 = 20;
    *result = v12;
    return result;
  }
  v7 = 0;
  v8 = (float *)(result + 1);
  while (*v8 <= a6)
  {
    ++v7;
    v8 += 5;
    if (v6 == v7)
    {
      LODWORD(v7) = *result;
      goto LABEL_12;
    }
  }
  if ((int)v6 > (int)v7)
  {
    v9 = (int)v6;
    v10 = (uint64_t)&result[5 * (int)v6 + 1];
    do
    {
      if (v9 <= 19)
      {
        *(_OWORD *)v10 = *(_OWORD *)(v10 - 20);
        *(_DWORD *)(v10 + 16) = *(_DWORD *)(v10 - 4);
      }
      --v9;
      v10 -= 20;
    }
    while (v9 > v7);
  }
LABEL_12:
  if (v7 <= 0x13)
    goto LABEL_13;
  return result;
}

uint64_t bitIsSet_0(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  return bitValueFromBitmask(a2, a3, a4);
}

BOOL seedFill(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  int v9;
  _QWORD *v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  int v26;
  BOOL v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  int v33;
  NSObject *v34;
  _BOOL8 result;
  int v36;
  uint64_t v37;
  int v38;
  unsigned __int16 v39;
  int v40;
  unsigned __int16 v41;

  v39 = 0;
  v38 = 0;
  if ((a3 & 0x80000000) == 0 && (a4 & 0x80000000) == 0 && *(_DWORD *)(a2 + 8) > a3)
  {
    v9 = *(_DWORD *)(a2 + 12);
    if (v9 > (int)a4)
    {
      bzero(*(void **)a2, *(int *)(a2 + 16) * (uint64_t)v9);
      v13 = allocSpanStack();
      if (v13)
      {
        v14 = (uint64_t)v13;
        v41 = 0;
        v40 = 0;
        spanSearch(a1, a2, a3, a4, &v40, a5, a6);
        v15 = HIWORD(v40);
        if (HIWORD(v40) <= v41)
        {
          v16 = (unsigned __int16)v40;
          v17 = v41 + 1;
          do
            setBitInBitmask(a2, v15++, v16, 1);
          while (v17 != v15);
        }
        pushSpan(v14, &v40);
        v37 = v14;
        while (1)
        {
LABEL_10:
          v19 = *(_QWORD *)(v14 + 8);
          v18 = *(_QWORD *)(v14 + 16);
          if (v18 == v19 + 16)
          {
            v20 = *(_QWORD *)(v19 + 8);
            if (!v20)
            {
              freeSpanStack((_QWORD **)v14);
              return 1;
            }
            *(_QWORD *)(v14 + 8) = v20;
            v18 = v20 + 316;
          }
          *(_QWORD *)(v14 + 16) = v18 - 6;
          v40 = *(_DWORD *)(v18 - 6);
          v41 = *(_WORD *)(v18 - 2);
          v36 = (unsigned __int16)v40;
          if ((_WORD)v40)
          {
            v21 = HIWORD(v40);
            v22 = v41;
            if (HIWORD(v40) <= v41)
            {
              v23 = (unsigned __int16)v40 - 1;
              do
              {
                if (!bitValueFromBitmask(a2, v21, v23) && a6(a5, a1, v21, v23))
                {
                  spanSearch(a1, a2, v21, v23, &v38, a5, a6);
                  v24 = HIWORD(v38);
                  v25 = v39;
                  if (HIWORD(v38) <= v39)
                  {
                    v26 = (unsigned __int16)v38;
                    do
                      setBitInBitmask(a2, v24++, v26, 1);
                    while (v25 + 1 != v24);
                  }
                  v14 = v37;
                  if (!pushSpan(v37, &v38))
                  {
LABEL_38:
                    puts("seedFill: can not push span onto stack");
                    freeSpanStack((_QWORD **)v14);
                    return 0;
                  }
                  LODWORD(v21) = v25 + 2;
                }
                v27 = (int)v21 < v22;
                v21 = (v21 + 1);
              }
              while (v27);
            }
          }
          if (*(_DWORD *)(a2 + 12) - 1 > v36)
          {
            v28 = HIWORD(v40);
            v29 = v41;
            if (HIWORD(v40) <= v41)
            {
              v30 = (v36 + 1);
              while (1)
              {
                if (!bitValueFromBitmask(a2, v28, v30) && a6(a5, a1, v28, v30))
                {
                  spanSearch(a1, a2, v28, v30, &v38, a5, a6);
                  v31 = HIWORD(v38);
                  v32 = v39;
                  if (HIWORD(v38) <= v39)
                  {
                    v33 = (unsigned __int16)v38;
                    do
                      setBitInBitmask(a2, v31++, v33, 1);
                    while (v32 + 1 != v31);
                  }
                  v14 = v37;
                  if (!pushSpan(v37, &v38))
                    goto LABEL_38;
                  LODWORD(v28) = v32 + 2;
                }
                v27 = (int)v28 < v29;
                v28 = (v28 + 1);
                if (!v27)
                  goto LABEL_10;
              }
            }
          }
        }
      }
      puts("seedFill: can not allocate span stack");
      return 0;
    }
  }
  v34 = ci_logger_render();
  result = os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    seedFill_cold_1(v34);
    return 0;
  }
  return result;
}

_QWORD *allocSpanStack()
{
  _QWORD *v0;
  _QWORD *v1;

  v0 = zmalloc(0x18uLL);
  if (v0)
  {
    v1 = zmalloc(0x140uLL);
    *v0 = v1;
    v0[1] = v1;
    if (v1)
    {
      *v1 = 0;
      v1[1] = 0;
      v0[2] = v1 + 2;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    puts("allocSpanStack: span stack could not be allocated");
  }
  return v0;
}

uint64_t spanSearch(uint64_t result, uint64_t a2, int a3, uint64_t a4, _WORD *a5, uint64_t a6, uint64_t (*a7)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  int v11;
  uint64_t v13;
  uint64_t v14;
  __int16 v15;
  BOOL v16;
  int v17;
  uint64_t v18;

  v11 = a3;
  v13 = result;
  *a5 = a4;
  LODWORD(v14) = a3;
  do
  {
    v15 = v14;
    v16 = __OFSUB__((_DWORD)v14, 1);
    v14 = (v14 - 1);
    if ((int)v14 < 0 != v16)
      break;
    result = bitValueFromBitmask(a2, v14, a4);
    if ((_DWORD)result == 1)
      break;
    result = a7(a6, v13, v14, a4);
  }
  while ((_DWORD)result);
  a5[1] = v15;
  do
  {
    v17 = v11;
    v18 = (v11 + 1);
    if ((int)v18 >= *(_DWORD *)(a2 + 8))
      break;
    result = bitValueFromBitmask(a2, v18, a4);
    if ((_DWORD)result == 1)
      break;
    result = a7(a6, v13, v18, a4);
    v11 = v17 + 1;
  }
  while ((_DWORD)result);
  a5[2] = v17;
  if ((unsigned __int16)a5[1] > (unsigned __int16)v17)
    return puts("spanSearch: empty span");
  return result;
}

uint64_t pushSpan(uint64_t a1, int *a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t result;
  uint64_t *v8;
  int v9;

  v5 = *(uint64_t **)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  if (v4 - (uint64_t)v5 - 16 >= 295)
  {
    v6 = *v5;
    if (!v6)
    {
      result = (uint64_t)zmalloc(0x140uLL);
      v8 = *(uint64_t **)(a1 + 8);
      *v8 = result;
      if (!result)
        return result;
      *(_QWORD *)result = 0;
      v6 = *v8;
      *(_QWORD *)(*v8 + 8) = v8;
    }
    v4 = v6 + 16;
    *(_QWORD *)(a1 + 8) = v6;
    *(_QWORD *)(a1 + 16) = v6 + 16;
  }
  v9 = *a2;
  *(_WORD *)(v4 + 4) = *((_WORD *)a2 + 2);
  *(_DWORD *)v4 = v9;
  *(_QWORD *)(a1 + 16) += 6;
  return 1;
}

void freeSpanStack(_QWORD **a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = *a1;
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      zfree(v2);
      v2 = v3;
    }
    while (v3);
  }
  zfree(a1);
}

uint64_t incrementalSeedFill(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  BOOL v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  int v50;
  unint64_t v52;
  int v53;
  unsigned int v54;
  uint64_t (*v55)(uint64_t, uint64_t, uint64_t, uint64_t);
  _QWORD *v56;
  uint64_t v57;
  int v58;
  unsigned __int16 v59;
  int v60;
  unsigned __int16 v61;

  v59 = 0;
  v58 = 0;
  v12 = allocSpanStack();
  if (!v12)
  {
    puts("seedFill: can not allocate span stack");
    return 0;
  }
  v56 = v12;
  v61 = 0;
  v60 = 0;
  v13 = bitmaskBoundingBitmapRectWithSeedPoint((uint64_t *)a2, a3, a4);
  v15 = insetBitmapRect(v13, v14, 0xFFFFFFFFLL, -1);
  v17 = v15 & ~((int)v15 >> 31);
  if (*(_DWORD *)(a2 + 12) >= SHIDWORD(v15))
    v18 = HIDWORD(v15);
  else
    v18 = *(_DWORD *)(a2 + 12);
  v55 = a6;
  v57 = a5;
  if ((int)v17 < v18)
  {
    v19 = *(_DWORD *)(a2 + 8);
    v20 = v16 & 0xFFFFFFFF00000000;
    if ((v16 & 0x80000000) == 0)
      v20 = v16;
    if (v19 >= SHIDWORD(v20))
      v21 = v20;
    else
      v21 = v20 | ((unint64_t)v19 << 32);
    v22 = HIDWORD(v21);
    v53 = v18;
    v52 = v21;
    do
    {
      if ((int)v21 >= (int)v22)
      {
        v34 = (v17 + 1);
      }
      else
      {
        v54 = v17 + 1;
        v23 = v21;
        do
        {
          v24 = *(_QWORD *)a2;
          v25 = *(int *)(a2 + 16);
          v26 = *(_QWORD *)a2 + (int)v25 * (uint64_t)(int)v17;
          if ((v23 & 0x80000000) == 0)
            v27 = v23;
          else
            v27 = v23 + 7;
          v28 = 1 << (v23 & 7);
          if ((v28 & *(_BYTE *)(v26 + (v27 >> 3))) == 0)
          {
            if ((int)v23 >= 1
              && ((*(unsigned __int8 *)(v26 + ((unint64_t)(v23 - 1) >> 3)) >> ((v23 - 1) & 7)) & 1) != 0)
            {
              goto LABEL_68;
            }
            if ((int)v23 < *(_DWORD *)(a2 + 8) - 1)
            {
              v29 = v23 + 8;
              if ((int)v23 >= -1)
                v29 = v23 + 1;
              if (((*(unsigned __int8 *)(v26 + (v29 >> 3)) >> ((v23 + 1) & 7)) & 1) != 0)
                goto LABEL_68;
            }
            if ((v30 = (uint64_t)v27 >> 3, (_DWORD)v17)
              && (v28 & *(_BYTE *)(v24 + v25 * ((int)v17 - 1) + v30)) != 0
              || (int)v17 < *(_DWORD *)(a2 + 12) - 1
              && (v28 & *(_BYTE *)(v24 + (int)v25 * (uint64_t)(int)v54 + v30)) != 0)
            {
LABEL_68:
              if (a6(a5, a1, v23, v17))
              {
                spanSearch(a1, a2, v23, v17, &v60, a5, a6);
                v31 = HIWORD(v60);
                if (HIWORD(v60) <= v61)
                {
                  v32 = (unsigned __int16)v60;
                  v33 = v61 + 1;
                  do
                    setBitInBitmask(a2, v31++, v32, 1);
                  while (v33 != v31);
                }
                pushSpan((uint64_t)v56, &v60);
                a6 = v55;
                a5 = v57;
              }
            }
          }
          v23 = (v23 + 1);
        }
        while ((_DWORD)v23 != (_DWORD)v22);
        v18 = v53;
        v34 = v54;
        v21 = v52;
      }
      v17 = v34;
    }
    while ((_DWORD)v34 != v18);
  }
  while (1)
  {
LABEL_37:
    v36 = v56[1];
    v35 = v56[2];
    if (v35 == v36 + 16)
    {
      v37 = *(_QWORD *)(v36 + 8);
      if (!v37)
      {
        freeSpanStack((_QWORD **)v56);
        return 1;
      }
      v56[1] = v37;
      v35 = v37 + 316;
    }
    v56[2] = v35 - 6;
    v60 = *(_DWORD *)(v35 - 6);
    v61 = *(_WORD *)(v35 - 2);
    v38 = (unsigned __int16)v60;
    if ((_WORD)v60)
    {
      v39 = HIWORD(v60);
      v40 = v61;
      if (HIWORD(v60) <= v61)
        break;
    }
LABEL_50:
    if (*(_DWORD *)(a2 + 12) - 1 > v38)
    {
      v45 = HIWORD(v60);
      v46 = v61;
      if (HIWORD(v60) <= v61)
      {
        v47 = (v38 + 1);
        while (1)
        {
          if (!bitValueFromBitmask(a2, v45, v47) && a6(a5, a1, v45, v47))
          {
            spanSearch(a1, a2, v45, v47, &v58, a5, a6);
            v48 = HIWORD(v58);
            v49 = v59;
            if (HIWORD(v58) <= v59)
            {
              v50 = (unsigned __int16)v58;
              do
                setBitInBitmask(a2, v48++, v50, 1);
              while (v49 + 1 != v48);
            }
            if (!pushSpan((uint64_t)v56, &v58))
              goto LABEL_63;
            LODWORD(v45) = v49 + 2;
            a5 = v57;
          }
          v44 = (int)v45 < v46;
          v45 = (v45 + 1);
          if (!v44)
            goto LABEL_37;
        }
      }
    }
  }
  while (1)
  {
    if (bitValueFromBitmask(a2, v39, v38 - 1) || !a6(a5, a1, v39, (v38 - 1)))
      goto LABEL_49;
    spanSearch(a1, a2, v39, (v38 - 1), &v58, a5, a6);
    v41 = HIWORD(v58);
    v42 = v59;
    if (HIWORD(v58) <= v59)
    {
      v43 = (unsigned __int16)v58;
      do
        setBitInBitmask(a2, v41++, v43, 1);
      while (v42 + 1 != v41);
    }
    if (!pushSpan((uint64_t)v56, &v58))
      break;
    LODWORD(v39) = v42 + 2;
    a6 = v55;
    a5 = v57;
LABEL_49:
    v44 = (int)v39 < v40;
    v39 = (v39 + 1);
    if (!v44)
      goto LABEL_50;
  }
LABEL_63:
  puts("seedFill: can not push span onto stack");
  freeSpanStack((_QWORD **)v56);
  return 0;
}

uint64_t SurfaceApplyPlaneReadOnlyBlock(__IOSurface *a1, uint64_t a2)
{
  size_t PlaneCount;
  uint64_t result;
  void *BaseAddress;
  size_t BytesPerRow;
  size_t Width;
  size_t Height;
  size_t v10;
  void *BaseAddressOfPlane;
  size_t BytesPerRowOfPlane;
  size_t WidthOfPlane;
  size_t HeightOfPlane;

  PlaneCount = IOSurfaceGetPlaneCount(a1);
  if (IOSurfaceGetCompressionTypeOfPlane())
  {
    x_log("Error: a compressed surface cannot be accessed via its base address.\n");
    return 3758097084;
  }
  if (PlaneCount <= 1)
  {
    result = IOSurfaceLock(a1, 1u, 0);
    if ((_DWORD)result)
      return result;
    BaseAddress = IOSurfaceGetBaseAddress(a1);
    BytesPerRow = IOSurfaceGetBytesPerRow(a1);
    Width = IOSurfaceGetWidth(a1);
    Height = IOSurfaceGetHeight(a1);
    if (BaseAddress && BytesPerRow && Width)
    {
      if (Height)
        (*(void (**)(uint64_t, void *, _QWORD, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddress, 0, Width, Height, BytesPerRow);
    }
    IOSurfaceUnlock(a1, 1u, 0);
    return 0;
  }
  if ((PlaneCount & 0xFFFFFFFFFFFFFFFELL) != 2)
    return 0;
  v10 = 0;
  while (1)
  {
    result = IOSurfaceLockPlane();
    if ((_DWORD)result)
      break;
    BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(a1, v10);
    BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(a1, v10);
    WidthOfPlane = IOSurfaceGetWidthOfPlane(a1, v10);
    HeightOfPlane = IOSurfaceGetHeightOfPlane(a1, v10);
    if (BaseAddressOfPlane && BytesPerRowOfPlane && WidthOfPlane && HeightOfPlane)
      (*(void (**)(uint64_t, void *, size_t, size_t, size_t, size_t))(a2 + 16))(a2, BaseAddressOfPlane, v10, WidthOfPlane, HeightOfPlane, BytesPerRowOfPlane);
    IOSurfaceUnlockPlane();
    if (PlaneCount == ++v10)
      return 0;
  }
  return result;
}

uint64_t SurfaceGetMemorySize(__IOSurface *a1)
{
  size_t PlaneCount;
  size_t v3;
  uint64_t v4;

  PlaneCount = IOSurfaceGetPlaneCount(a1);
  if (PlaneCount < 2)
    return IOSurfaceGetSizeOfPlane();
  v3 = PlaneCount;
  v4 = 0;
  do
  {
    v4 += IOSurfaceGetSizeOfPlane();
    --v3;
  }
  while (v3);
  return v4;
}

uint64_t CopyYCC444_to_Y_8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t i;
  _BYTE *v9;
  char *v10;
  uint64_t v11;
  char v12;

  if (a3)
  {
    for (i = 0; i != a3; ++i)
    {
      if (a2)
      {
        v9 = (_BYTE *)(a5 + a6 + (i + a7) * a8);
        v10 = (char *)(result + i * a4);
        v11 = a2;
        do
        {
          v12 = *v10;
          v10 += 4;
          *v9++ = v12;
          --v11;
        }
        while (v11);
      }
    }
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr_8(uint64_t result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  _BYTE *v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  int v18;
  int v19;

  if (a3 >= 2)
  {
    v8 = 0;
    v9 = a3 >> 1;
    v10 = a3 - 1;
    v11 = a5 + 2 * a6;
    v12 = a2 >> 1;
    if (a2 >> 1 <= 1)
      v12 = 1;
    v13 = (unsigned __int8 *)(result + 6);
    do
    {
      if (a2 >= 2)
      {
        v14 = (_BYTE *)(v11 + (v8 + a7) * a8);
        if (v10 <= 2 * v8)
          v15 = 0;
        else
          v15 = a4;
        v16 = v13;
        result = v12;
        do
        {
          v17 = &v16[v15];
          *v14 = (*(v16 - 5) + *(v16 - 1) + v16[v15 - 5] + v16[v15 - 1] + 2) >> 2;
          v18 = *(v16 - 4);
          v19 = *v16;
          v16 += 8;
          v14[1] = (v18 + v19 + *(v17 - 4) + *v17 + 2) >> 2;
          v14 += 2;
          --result;
        }
        while (result);
      }
      ++v8;
      v13 += 2 * a4;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr422_8(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  unsigned __int8 *v14;

  if (a3)
  {
    v8 = 0;
    v9 = a2 >> 1;
    if (a2 >> 1 <= 1)
      v9 = 1;
    v10 = (unsigned __int8 *)(result + 5);
    v11 = a8 * a7 + 2 * a6 + a5 + 1;
    do
    {
      v12 = v9;
      v13 = (_BYTE *)v11;
      v14 = v10;
      if (a2 >= 2)
      {
        do
        {
          *(v13 - 1) = (*(v14 - 4) + *v14 + 1) >> 1;
          *v13 = (*(v14 - 3) + v14[1] + 1) >> 1;
          v13 += 2;
          v14 += 8;
          --v12;
        }
        while (v12);
      }
      ++v8;
      v10 += a4;
      v11 += a8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr444_8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  _BYTE *v12;
  uint64_t i;
  char v14;

  if (a3)
  {
    v8 = 0;
    v9 = a8 * a7 + 2 * a6 + a5 + 1;
    v10 = (char *)(result + 2);
    do
    {
      v11 = v10;
      v12 = (_BYTE *)v9;
      for (i = a2; i; --i)
      {
        *(v12 - 1) = *(v11 - 1);
        v14 = *v11;
        v11 += 4;
        *v12 = v14;
        v12 += 2;
      }
      ++v8;
      v9 += a8;
      v10 += a4;
    }
    while (v8 != a3);
  }
  return result;
}

__int16 *CopyYCC444_to_Y_16(__int16 *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t i;
  _WORD *v9;
  uint64_t v10;
  __int16 *v11;
  __int16 v12;

  if (a3)
  {
    for (i = 0; i != a3; ++i)
    {
      if (a2)
      {
        v9 = (_WORD *)(a5 + 2 * a6 + (((i + a7) * a8) & 0xFFFFFFFFFFFFFFFELL));
        v10 = a2;
        v11 = result;
        do
        {
          v12 = *v11;
          v11 += 4;
          *v9++ = v12;
          --v10;
        }
        while (v10);
      }
      result = (__int16 *)((char *)result + a4);
    }
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr_16(uint64_t result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _WORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (a3 >= 2)
  {
    v8 = 0;
    v9 = a3 >> 1;
    v10 = result + a4;
    v11 = a3 - 1;
    v12 = a2 >> 1;
    v13 = 2 * a4;
    if (a2 >> 1 <= 1)
      v12 = 1;
    do
    {
      if (a2 >= 2)
      {
        v14 = (_WORD *)(a5 + 4 * a6 + (((v8 + a7) * a8) & 0xFFFFFFFFFFFFFFFELL));
        if (v11 <= 2 * v8)
          v15 = result;
        else
          v15 = v10;
        v16 = 10;
        v17 = v12;
        do
        {
          *v14 = (*(unsigned __int16 *)(result + v16 - 8)
                + *(unsigned __int16 *)(result + v16)
                + *(unsigned __int16 *)(v15 + v16 - 8)
                + *(unsigned __int16 *)(v15 + v16)
                + 2) >> 2;
          v14[1] = (*(unsigned __int16 *)(result + v16 - 6)
                  + *(unsigned __int16 *)(result + v16 + 2)
                  + *(unsigned __int16 *)(v15 + v16 - 6)
                  + *(unsigned __int16 *)(v15 + v16 + 2)
                  + 2) >> 2;
          v16 += 16;
          v14 += 2;
          --v17;
        }
        while (v17);
      }
      ++v8;
      result += v13;
      v10 += v13;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr422_16(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  uint64_t v14;
  _WORD *v15;

  if (a3)
  {
    v8 = 0;
    v9 = a5 + a8 * a7;
    v10 = a2 >> 1;
    if (a2 >> 1 <= 1)
      v10 = 1;
    v11 = (unsigned __int16 *)(result + 10);
    do
    {
      v12 = v11;
      v13 = 4 * a6;
      v14 = v10;
      if (a2 >= 2)
      {
        do
        {
          v15 = (_WORD *)(v9 + v13);
          *v15 = (*(v12 - 4) + *v12 + 1) >> 1;
          result = v12[1];
          v15[1] = (*(v12 - 3) + result + 1) >> 1;
          v13 += 4;
          v12 += 8;
          --v14;
        }
        while (v14);
      }
      ++v8;
      v9 += a8;
      v11 = (unsigned __int16 *)((char *)v11 + a4);
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr444_16(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  __int16 *v10;
  __int16 *v11;
  _WORD *v12;
  uint64_t i;
  __int16 v14;

  if (a3)
  {
    v8 = 0;
    v9 = a8 * a7 + 4 * a6 + a5 + 2;
    v10 = (__int16 *)(result + 4);
    do
    {
      v11 = v10;
      v12 = (_WORD *)v9;
      for (i = a2; i; --i)
      {
        *(v12 - 1) = *(v11 - 1);
        v14 = *v11;
        v11 += 4;
        *v12 = v14;
        v12 += 2;
      }
      ++v8;
      v9 += a8;
      v10 = (__int16 *)((char *)v10 + a4);
    }
    while (v8 != a3);
  }
  return result;
}

unsigned __int16 *CopyYCC444_to_Y_10packed(unsigned __int16 *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t i;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned int v12;
  uint64_t v13;

  if (a3)
  {
    for (i = 0; i != a3; ++i)
    {
      if (a2)
      {
        v9 = a2;
        v10 = a6;
        v11 = result;
        do
        {
          v12 = *v11;
          v11 += 4;
          v13 = llroundf((float)((float)v12 * 1023.0) / 65535.0);
          if (v13 >= 1023)
            v13 = 1023;
          *(_DWORD *)(a5 + (((i + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * (v10 / 3)) = ((v13 & ~(v13 >> 63)) << (10 * (v10 % 3))) | dword_192499E88[v10 % 3] & *(_DWORD *)(a5 + (((i + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL) + 4 * (v10 / 3));
          ++v10;
          --v9;
        }
        while (v9);
      }
      result = (unsigned __int16 *)((char *)result + a4);
    }
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr_10packed(uint64_t result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;

  if (a3 >= 2)
  {
    v8 = 0;
    v9 = a3 >> 1;
    v10 = result + a4;
    v11 = a3 - 1;
    v12 = a2 >> 1;
    v13 = 2 * a4;
    if (a2 >> 1 <= 1)
      v12 = 1;
    v14 = 2 * a6;
    do
    {
      if (a2 >= 2)
      {
        v15 = a5 + (((v8 + a7) * a8) & 0xFFFFFFFFFFFFFFFCLL);
        if (v11 <= 2 * v8)
          v16 = result;
        else
          v16 = v10;
        v17 = 10;
        v18 = v12;
        v19 = v14;
        do
        {
          v20 = llroundf((float)((float)(unsigned __int16)((*(unsigned __int16 *)(result + v17 - 8)+ *(unsigned __int16 *)(result + v17)+ *(unsigned __int16 *)(v16 + v17 - 8)+ *(unsigned __int16 *)(v16 + v17)+ 2) >> 2)* 1023.0)/ 65535.0);
          if (v20 >= 1023)
            v20 = 1023;
          v21 = *(unsigned __int16 *)(result + v17 - 6)
              + *(unsigned __int16 *)(result + v17 + 2)
              + *(unsigned __int16 *)(v16 + v17 - 6)
              + *(unsigned __int16 *)(v16 + v17 + 2);
          *(_DWORD *)(v15 + 4 * (v19 / 3)) = ((v20 & ~(v20 >> 63)) << (10 * (v19 % 3))) | dword_192499E88[v19 % 3] & *(_DWORD *)(v15 + 4 * (v19 / 3));
          v22 = llroundf((float)((float)(unsigned __int16)((v21 + 2) >> 2) * 1023.0) / 65535.0);
          if (v22 >= 1023)
            v22 = 1023;
          *(_DWORD *)(v15 + 4 * ((v19 + 1) / 3)) = ((v22 & ~(v22 >> 63)) << (10 * ((v19 + 1) % 3))) | dword_192499E88[(v19 + 1) % 3] & *(_DWORD *)(v15 + 4 * ((v19 + 1) / 3));
          v19 += 2;
          v17 += 16;
          --v18;
        }
        while (v18);
      }
      ++v8;
      result += v13;
      v10 += v13;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr422_10packed(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;

  if (a3)
  {
    v8 = 0;
    v9 = a5 + a8 * a7;
    v10 = a2 >> 1;
    if (a2 >> 1 <= 1)
      v10 = 1;
    v11 = (unsigned __int16 *)(result + 10);
    do
    {
      v12 = v11;
      v13 = v10;
      result = 2 * a6;
      if (a2 >= 2)
      {
        do
        {
          v14 = llroundf((float)((float)(unsigned __int16)((*(v12 - 4) + *v12 + 1) >> 1) * 1023.0) / 65535.0);
          if (v14 >= 1023)
            v14 = 1023;
          v15 = ((v14 & ~(v14 >> 63)) << (10 * (result % 3))) | dword_192499E88[result % 3] & *(_DWORD *)(v9 + 4 * (result / 3));
          v16 = llroundf((float)((float)(unsigned __int16)((*(v12 - 3) + v12[1] + 1) >> 1) * 1023.0) / 65535.0);
          *(_DWORD *)(v9 + 4 * (result / 3)) = v15;
          if (v16 >= 1023)
            v17 = 1023;
          else
            v17 = v16;
          *(_DWORD *)(v9 + 4 * ((result + 1) / 3)) = ((v17 & ~(v17 >> 63)) << (10 * ((result + 1) % 3))) | dword_192499E88[(result + 1) % 3] & *(_DWORD *)(v9 + 4 * ((result + 1) / 3));
          result += 2;
          v12 += 8;
          --v13;
        }
        while (v13);
      }
      ++v8;
      v9 += a8;
      v11 = (unsigned __int16 *)((char *)v11 + a4);
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr444_10packed(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, float a11)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _WORD *v14;
  uint64_t v15;
  _WORD *v16;
  uint64_t i;
  float v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  if (a3)
  {
    v11 = 0;
    v12 = a5 + a8 * a7;
    v13 = 2 * a6;
    v14 = (_WORD *)(result + 4);
    do
    {
      v15 = a2;
      v16 = v14;
      for (i = v13; v15; --v15)
      {
        LOWORD(a11) = *(v16 - 1);
        v18 = (float)((float)LODWORD(a11) * 1023.0) / 65535.0;
        v19 = llroundf(v18);
        if (v19 >= 1023)
          v19 = 1023;
        LOWORD(v18) = *v16;
        a11 = (float)((float)LODWORD(v18) * 1023.0) / 65535.0;
        v20 = llroundf(a11);
        *(_DWORD *)(v12 + 4 * (i / 3)) = ((v19 & ~(v19 >> 63)) << (10 * (i % 3))) | dword_192499E88[i % 3] & *(_DWORD *)(v12 + 4 * (i / 3));
        if (v20 >= 1023)
          v21 = 1023;
        else
          v21 = v20;
        result = ((v21 & ~(v21 >> 63)) << (10 * ((i + 1) % 3))) | dword_192499E88[(i + 1) % 3] & *(_DWORD *)(v12 + 4 * ((i + 1) / 3));
        *(_DWORD *)(v12 + 4 * ((i + 1) / 3)) = result;
        i += 2;
        v16 += 4;
      }
      ++v11;
      v12 += a8;
      v14 = (_WORD *)((char *)v14 + a4);
    }
    while (v11 != a3);
  }
  return result;
}

uint64_t CopyYCC444_to_Y_half(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t i;
  _WORD *v9;
  __int16 *v10;
  uint64_t v11;
  __int16 v12;

  if (a3)
  {
    for (i = 0; i != a3; ++i)
    {
      if (a2)
      {
        v9 = (_WORD *)(a5 + 2 * a6 + (((i + a7) * a8) & 0xFFFFFFFFFFFFFFFELL));
        v10 = (__int16 *)(result + ((i * a4) & 0xFFFFFFFFFFFFFFFELL));
        v11 = a2;
        do
        {
          v12 = *v10;
          v10 += 4;
          *v9++ = v12;
          --v11;
        }
        while (v11);
      }
    }
  }
  return result;
}

_WORD *CopyYCC444_to_CbCr_half(_WORD *result, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _WORD *v14;
  uint64_t v15;
  _WORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (a3 >= 2)
  {
    v8 = 0;
    v9 = 0;
    v10 = a3 >> 1;
    v11 = a3 - 1;
    v12 = a4 >> 1;
    v13 = a2 >> 1;
    if (a2 >> 1 <= 1)
      v13 = 1;
    v14 = result + 6;
    v15 = 2 * a4;
    do
    {
      if (a2 >= 2)
      {
        v16 = (_WORD *)((char *)v14 + (v8 & 0xFFFFFFFFFFFFFFFELL));
        result = (_WORD *)(a5 + 4 * a6 + (((v9 + a7) * a8) & 0xFFFFFFFFFFFFFFFELL));
        if (v11 <= 2 * v9)
          v17 = 0;
        else
          v17 = v12;
        v18 = v17;
        v19 = v13;
        do
        {
          _H1 = *(v16 - 5);
          _H2 = *(v16 - 1);
          __asm
          {
            FCVT            S2, H2
            FCVT            S1, H1
          }
          _S1 = _S1 + _S2;
          __asm { FCVT            H1, S1 }
          LOWORD(_S2) = v16[v18 - 5];
          __asm
          {
            FCVT            S2, H2
            FCVT            S1, H1
          }
          _S1 = _S1 + _S2;
          __asm { FCVT            H1, S1 }
          LOWORD(_S2) = v16[v18 - 1];
          __asm
          {
            FCVT            S1, H1
            FCVT            S2, H2
          }
          _S1 = _S1 + _S2;
          __asm
          {
            FCVT            H1, S1
            FCVT            S1, H1
          }
          _S1 = _S1 * 0.25;
          __asm { FCVT            H1, S1 }
          *result = LOWORD(_S1);
          LOWORD(_S1) = *(v16 - 4);
          LOWORD(_S2) = *v16;
          __asm
          {
            FCVT            S2, H2
            FCVT            S1, H1
          }
          _S1 = _S1 + _S2;
          __asm { FCVT            H1, S1 }
          LOWORD(_S2) = v16[v18 - 4];
          __asm
          {
            FCVT            S2, H2
            FCVT            S1, H1
          }
          _S1 = _S1 + _S2;
          __asm { FCVT            H1, S1 }
          LOWORD(_S2) = v16[v18];
          __asm
          {
            FCVT            S1, H1
            FCVT            S2, H2
          }
          _S1 = _S1 + _S2;
          __asm
          {
            FCVT            H1, S1
            FCVT            S1, H1
          }
          _S1 = _S1 * 0.25;
          __asm { FCVT            H1, S1 }
          result[1] = LOWORD(_S1);
          v16 += 8;
          result += 2;
          --v19;
        }
        while (v19);
      }
      ++v9;
      v8 += v15;
    }
    while (v9 != v10);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr422_half(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  _WORD *v13;
  __int16 *v14;

  if (a3)
  {
    v8 = 0;
    v9 = a2 >> 1;
    if (a2 >> 1 <= 1)
      v9 = 1;
    v10 = (__int16 *)(result + 10);
    v11 = a8 * a7 + 4 * a6 + a5 + 2;
    do
    {
      v12 = v9;
      v13 = (_WORD *)v11;
      v14 = v10;
      if (a2 >= 2)
      {
        do
        {
          _H1 = *(v14 - 4);
          _H2 = *v14;
          __asm
          {
            FCVT            S2, H2
            FCVT            S1, H1
          }
          _S1 = _S1 + _S2;
          __asm
          {
            FCVT            H1, S1
            FCVT            S1, H1
          }
          _S1 = _S1 * 0.5;
          __asm { FCVT            H1, S1 }
          *(v13 - 1) = LOWORD(_S1);
          LOWORD(_S1) = *(v14 - 3);
          LOWORD(_S2) = v14[1];
          __asm
          {
            FCVT            S2, H2
            FCVT            S1, H1
          }
          _S1 = _S1 + _S2;
          __asm
          {
            FCVT            H1, S1
            FCVT            S1, H1
          }
          _S1 = _S1 * 0.5;
          __asm { FCVT            H1, S1 }
          *v13 = LOWORD(_S1);
          v14 += 8;
          v13 += 2;
          --v12;
        }
        while (v12);
      }
      ++v8;
      v10 = (__int16 *)((char *)v10 + a4);
      v11 += a8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t CopyYCC444_to_CbCr444_half(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  _WORD *v10;
  _WORD *v11;
  _WORD *v12;
  uint64_t i;

  if (a3)
  {
    v8 = 0;
    v9 = a8 * a7 + 4 * a6 + a5 + 2;
    v10 = (_WORD *)(result + 4);
    do
    {
      v11 = v10;
      v12 = (_WORD *)v9;
      for (i = a2; i; --i)
      {
        *(v12 - 1) = *(v11 - 1);
        *v12 = *v11;
        v12 += 2;
        v11 += 4;
      }
      ++v8;
      v9 += a8;
      v10 = (_WORD *)((char *)v10 + a4);
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t ClearSurface(__IOSurface *a1)
{
  signed int PixelFormat;
  int v3;
  int v4;
  int v5;
  int v6;
  BOOL v7;
  int v8;
  _QWORD *v9;
  int v10;
  int v11;
  unsigned __int16 v12;
  int v13;
  void *v15;
  _QWORD v16[4];
  int v17;
  _QWORD v18[4];
  int v19;
  _QWORD v20[4];
  int v21;
  _QWORD v22[4];
  int v23;
  _QWORD v24[4];
  int v25;
  signed int v26;
  _QWORD v27[4];
  int v28;

  PixelFormat = IOSurfaceGetPixelFormat(a1);
  v3 = 0;
  if (PixelFormat <= 1937125935)
  {
    if (PixelFormat > 1882468911)
    {
      if (PixelFormat > 1885745713)
      {
        if (PixelFormat > 1936077359)
        {
          if (PixelFormat == 1936077360 || PixelFormat == 1936077362)
            goto LABEL_65;
          v5 = 1936077876;
          goto LABEL_34;
        }
        if (PixelFormat != 1885745714)
        {
          v10 = 1885746228;
LABEL_52:
          if (PixelFormat != v10)
            goto LABEL_84;
          goto LABEL_69;
        }
LABEL_70:
        v16[0] = MEMORY[0x1E0C809B0];
        v16[1] = 0x40000000;
        v16[2] = __ClearSurface_block_invoke_7;
        v16[3] = &__block_descriptor_tmp_10_0;
        v17 = v3;
        v9 = v16;
        return SurfaceApplyPlaneBlock(a1, (uint64_t)v9);
      }
      if (PixelFormat > 1882469427)
      {
        if (PixelFormat != 1882469428)
        {
          if (PixelFormat != 1885745712)
            goto LABEL_84;
          goto LABEL_70;
        }
      }
      else if (PixelFormat != 1882468912)
      {
        v10 = 1882468914;
        goto LABEL_52;
      }
LABEL_69:
      v3 = (PixelFormat != 1885746228) << 6;
      goto LABEL_70;
    }
    if (PixelFormat > 875704933)
    {
      if (PixelFormat > 875836517)
      {
        if (PixelFormat == 875836518)
        {
LABEL_79:
          v3 = 16 * (PixelFormat != 875836518);
          goto LABEL_80;
        }
        v13 = 875836534;
LABEL_78:
        if (PixelFormat != v13)
          goto LABEL_84;
        goto LABEL_79;
      }
      if (PixelFormat != 875704934)
      {
        v12 = 12918;
LABEL_60:
        v13 = v12 | 0x34320000;
        goto LABEL_78;
      }
    }
    else
    {
      if (PixelFormat <= 875704421)
      {
        if (PixelFormat != 846624102)
        {
          v6 = 846624121;
LABEL_23:
          if (PixelFormat == v6)
            goto LABEL_24;
LABEL_84:
          v15 = &__block_literal_global_12;
          return SurfaceApplyPlaneBlock(a1, (uint64_t)v15);
        }
LABEL_24:
        v7 = PixelFormat == 2037741171 || PixelFormat == 846624121;
        v24[0] = MEMORY[0x1E0C809B0];
        v24[1] = 0x40000000;
        v24[2] = __ClearSurface_block_invoke_2;
        v24[3] = &__block_descriptor_tmp_4_1;
        if (v7)
          v8 = 16;
        else
          v8 = 0;
        v25 = v8;
        v26 = PixelFormat;
        v9 = v24;
        return SurfaceApplyPlaneBlock(a1, (uint64_t)v9);
      }
      if (PixelFormat != 875704422)
      {
        v12 = 12406;
        goto LABEL_60;
      }
    }
LABEL_80:
    v27[0] = MEMORY[0x1E0C809B0];
    v27[1] = 0x40000000;
    v27[2] = __ClearSurface_block_invoke;
    v27[3] = &__block_descriptor_tmp_3_2;
    v28 = v3;
    v9 = v27;
    return SurfaceApplyPlaneBlock(a1, (uint64_t)v9);
  }
  if (PixelFormat <= 2016686639)
  {
    if (PixelFormat > 1952854577)
    {
      if (PixelFormat <= 1953903151)
      {
        if (PixelFormat == 1952854578)
        {
LABEL_49:
          v20[0] = MEMORY[0x1E0C809B0];
          v20[1] = 0x40000000;
          v20[2] = __ClearSurface_block_invoke_5;
          v20[3] = &__block_descriptor_tmp_8_1;
          v21 = v3;
          v9 = v20;
          return SurfaceApplyPlaneBlock(a1, (uint64_t)v9);
        }
        v4 = 1952855092;
      }
      else
      {
        if (PixelFormat == 1953903152 || PixelFormat == 1953903154)
          goto LABEL_48;
        v4 = 1953903668;
      }
      if (PixelFormat == v4)
      {
LABEL_48:
        v3 = (PixelFormat != 1952855092) << 8;
        goto LABEL_49;
      }
      goto LABEL_84;
    }
    if (PixelFormat > 1937126451)
    {
      if (PixelFormat != 1937126452)
      {
        if (PixelFormat == 1952854576)
          goto LABEL_49;
        goto LABEL_84;
      }
    }
    else if (PixelFormat != 1937125936)
    {
      v5 = 1937125938;
LABEL_34:
      if (PixelFormat != v5)
        goto LABEL_84;
    }
    v3 = (PixelFormat != 1936077876) << 12;
LABEL_65:
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 0x40000000;
    v18[2] = __ClearSurface_block_invoke_6;
    v18[3] = &__block_descriptor_tmp_9_1;
    v19 = v3;
    v9 = v18;
    return SurfaceApplyPlaneBlock(a1, (uint64_t)v9);
  }
  if (PixelFormat <= 2019963441)
  {
    if (PixelFormat > 2016687155)
    {
      if (PixelFormat != 2016687156)
      {
        if (PixelFormat != 2019963440)
          goto LABEL_84;
        goto LABEL_75;
      }
    }
    else if (PixelFormat != 2016686640)
    {
      v11 = 2016686642;
      goto LABEL_56;
    }
LABEL_74:
    v3 = (PixelFormat != 2019963956) << 6;
    goto LABEL_75;
  }
  if (PixelFormat <= 2033463351)
  {
    if (PixelFormat != 2019963442)
    {
      v11 = 2019963956;
LABEL_56:
      if (PixelFormat != v11)
        goto LABEL_84;
      goto LABEL_74;
    }
LABEL_75:
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 0x40000000;
    v22[2] = __ClearSurface_block_invoke_4;
    v22[3] = &__block_descriptor_tmp_7_1;
    v23 = v3;
    v9 = v22;
    return SurfaceApplyPlaneBlock(a1, (uint64_t)v9);
  }
  if (PixelFormat != 2033463352)
  {
    if (PixelFormat != 2037741158)
    {
      v6 = 2037741171;
      goto LABEL_23;
    }
    goto LABEL_24;
  }
  v15 = &__block_literal_global_6_0;
  return SurfaceApplyPlaneBlock(a1, (uint64_t)v15);
}

unint64_t CreateSurfaceMemorySize(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t result;
  int v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;

  v7 = equivalent_uncompressed_format(a4);
  result = 0;
  if (!a1 || !a2 || !(_DWORD)v7)
    return result;
  if (is_biplanar(v7))
  {
    v9 = equivalent_uncompressed_format(v7);
    if (v9 <= 1936077875)
    {
      if (v9 <= 1751528499)
      {
        v10 = a1;
        if (v9 == 875836518)
          goto LABEL_24;
        v11 = 875836534;
      }
      else
      {
        v10 = a1;
        if (v9 == 1751528500)
          goto LABEL_24;
        v10 = a1;
        if (v9 == 1882469428)
          goto LABEL_24;
        v11 = 1885746228;
      }
    }
    else if (v9 > 1953903667)
    {
      v10 = a1;
      if (v9 == 1953903668)
        goto LABEL_24;
      v10 = a1;
      if (v9 == 2016687156)
        goto LABEL_24;
      v11 = 2019963956;
    }
    else
    {
      v10 = a1;
      if (v9 == 1936077876)
        goto LABEL_24;
      v10 = a1;
      if (v9 == 1937126452)
        goto LABEL_24;
      v11 = 1952855092;
    }
    v10 = a1;
    if (v9 != v11)
      v10 = (unint64_t)(a1 + 1) >> 1;
LABEL_24:
    if (v9 <= 1936077359)
    {
      if (v9 <= 1751527983)
      {
        if (v9 == 875704422)
          goto LABEL_39;
        v14 = 875704438;
      }
      else
      {
        if (v9 == 1751527984 || v9 == 1882468912)
          goto LABEL_39;
        v14 = 1885745712;
      }
    }
    else if (v9 > 1953903151)
    {
      if (v9 == 1953903152 || v9 == 2019963440)
        goto LABEL_39;
      v14 = 2016686640;
    }
    else
    {
      if (v9 == 1936077360 || v9 == 1937125936)
        goto LABEL_39;
      v14 = 1952854576;
    }
    v15 = a2;
    if (v9 != v14)
    {
LABEL_40:
      v16 = format_for_plane(v7, 0);
      v17 = format_for_plane(v7, 1);
      v18 = min_bytes_per_row(v16, a1);
      v19 = min_bytes_per_row(v17, v10);
      v20 = 32;
      if (a3)
        v20 = a3;
      return (v20 - 1 + v18) / v20 * v20 * a2 + (v20 - 1 + v19) / v20 * v20 * v15;
    }
LABEL_39:
    v15 = (a2 + 1) >> 1;
    goto LABEL_40;
  }
  v12 = min_bytes_per_row(v7, a1);
  v13 = 32;
  if (a3)
    v13 = a3;
  return (v13 + v12 - 1) / v13 * v13 * a2;
}

uint64_t format_for_plane(uint64_t a1, int a2)
{
  uint64_t result;
  int v4;
  int v5;
  unsigned __int16 v6;
  int v7;
  unsigned __int16 v8;
  int v9;
  unsigned __int16 v10;
  int v11;
  unsigned __int16 v12;
  unsigned int v13;
  BOOL v14;
  unsigned int v15;

  if ((a1 & 0xFD000000) == 0x2D000000)
    return 0;
  result = 0;
  if ((int)a1 >> 24 == 38 || (int)a1 >> 24 == 124)
    return result;
  result = 826486888;
  if ((int)a1 > 1936077359)
  {
    if ((int)a1 <= 1953903151)
    {
      if ((int)a1 > 1937125937)
      {
        if ((int)a1 > 1952854575)
        {
          if ((_DWORD)a1 != 1952854576 && (_DWORD)a1 != 1952854578)
          {
            v4 = 1952855092;
            goto LABEL_38;
          }
          goto LABEL_71;
        }
        if ((_DWORD)a1 == 1937125938)
          goto LABEL_58;
        v10 = 13364;
        goto LABEL_56;
      }
      if ((int)a1 > 1936077875)
      {
        if ((_DWORD)a1 != 1936077876)
        {
          v10 = 12848;
LABEL_56:
          v7 = v10 | 0x73760000;
LABEL_57:
          if ((_DWORD)a1 == v7)
            goto LABEL_58;
          return a1;
        }
      }
      else if ((_DWORD)a1 != 1936077360)
      {
        v7 = 1936077362;
        goto LABEL_57;
      }
LABEL_58:
      v13 = 826487094;
      v15 = 843264310;
LABEL_72:
      v14 = a2 == 0;
LABEL_73:
      if (v14)
        return v13;
      else
        return v15;
    }
    if ((int)a1 <= 2016686641)
    {
      if ((int)a1 <= 1953903667)
      {
        if ((_DWORD)a1 != 1953903152)
        {
          v4 = 1953903154;
LABEL_38:
          if ((_DWORD)a1 != v4)
            return a1;
        }
LABEL_71:
        v13 = 826487090;
        v15 = 843264306;
        goto LABEL_72;
      }
      if ((_DWORD)a1 == 1953903668)
        goto LABEL_71;
      v12 = 12848;
    }
    else
    {
      if ((int)a1 > 2019963439)
      {
        if ((_DWORD)a1 == 2019963440 || (_DWORD)a1 == 2019963442)
          goto LABEL_70;
        v5 = 2019963956;
        goto LABEL_69;
      }
      if ((_DWORD)a1 == 2016686642)
        goto LABEL_70;
      v12 = 13364;
    }
    v5 = v12 | 0x78340000;
LABEL_69:
    if ((_DWORD)a1 != v5)
      return a1;
LABEL_70:
    v13 = 826487088;
    v15 = 843264304;
    goto LABEL_72;
  }
  if ((int)a1 <= 1751528499)
  {
    if ((int)a1 > 875836517)
    {
      if ((int)a1 > 1751527983)
      {
        if ((_DWORD)a1 != 1751527984 && (_DWORD)a1 != 1751527986)
          return a1;
        goto LABEL_78;
      }
      if ((_DWORD)a1 == 875836518)
      {
LABEL_53:
        v13 = 826486840;
        v14 = a2 == 0;
        v15 = 843264056;
        goto LABEL_73;
      }
      v9 = 875836534;
    }
    else
    {
      if ((int)a1 > 875704933)
      {
        if ((_DWORD)a1 == 875704934)
          goto LABEL_53;
        v6 = 12918;
      }
      else
      {
        if ((_DWORD)a1 == 875704422)
          goto LABEL_53;
        v6 = 12406;
      }
      v9 = v6 | 0x34320000;
    }
    if ((_DWORD)a1 != v9)
      return a1;
    goto LABEL_53;
  }
  if ((int)a1 <= 1885745711)
  {
    if ((int)a1 > 1882468913)
    {
      if ((_DWORD)a1 == 1882468914)
        goto LABEL_63;
      v8 = 13364;
      goto LABEL_61;
    }
    if ((_DWORD)a1 != 1751528500)
    {
      v8 = 12848;
LABEL_61:
      v11 = v8 | 0x70340000;
LABEL_62:
      if ((_DWORD)a1 != v11)
        return a1;
LABEL_63:
      if (a2)
        return 845361456;
      else
        return 828584240;
    }
LABEL_78:
    if (a2)
      return 843264104;
    else
      return 826486888;
  }
  if ((int)a1 <= 1885746227)
  {
    if ((_DWORD)a1 == 1885745712)
      goto LABEL_63;
    v11 = 1885745714;
    goto LABEL_62;
  }
  if ((_DWORD)a1 == 1885746228)
    goto LABEL_63;
  if ((_DWORD)a1 == 1919365990)
    return 826486886;
  if ((_DWORD)a1 != 1919365992)
    return a1;
  return result;
}

void SurfaceSetYCCMatrix(__IOSurface *a1, int a2)
{
  OSType PixelFormat;
  CFTypeRef *v5;

  if (a1)
  {
    PixelFormat = IOSurfaceGetPixelFormat(a1);
    if ((IOSurfaceGetPlaneCount(a1) == 2 || PixelFormat == 2033463352) && (a2 == 709 || a2 == 601))
    {
      if (a2 == 601)
        v5 = (CFTypeRef *)MEMORY[0x1E0CBC1F8];
      else
        v5 = (CFTypeRef *)MEMORY[0x1E0CBC200];
      IOSurfaceSetBulkAttachments2();
      IOSurfaceSetValue(a1, (CFStringRef)*MEMORY[0x1E0CBC1E8], *v5);
    }
  }
}

void setIntValue(__CFDictionary *a1, const void *a2, int a3)
{
  CFNumberRef v5;
  int valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

__IOSurface *CreateWrappedSurface(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  return CreateSurfaceWrapped(a1, a2, a3, a4, a6);
}

__IOSurface *CreateSurfaceWrapped(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  __IOSurface *v5;
  int v11;
  unint64_t v12;
  unint64_t v13;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v15;
  const void *v16;
  CFNumberRef v17;
  const void *v18;
  CFNumberRef v19;
  const void *v20;
  CFNumberRef v21;
  const void *v22;
  CFNumberRef v23;
  const void *v24;
  CFNumberRef v25;
  const void *v26;
  CFNumberRef v27;
  const void *v28;
  CFNumberRef v29;
  int v30;
  int v31;
  const void *v32;
  CFNumberRef v33;
  uint64_t valuePtr;

  v5 = 0;
  if (a1 && a2 && (_DWORD)a3)
  {
    if ((is_biplanar(a3) & 1) != 0)
      return 0;
    v11 = bytes_per_element(a3);
    v12 = min_bytes_per_row(a3, a1);
    v5 = 0;
    if (v11)
    {
      v13 = v12;
      if (v12)
      {
        if (v12 <= a4)
        {
          Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          if (!Mutable)
            return 0;
          v15 = Mutable;
          v16 = (const void *)*MEMORY[0x1E0CBBF68];
          valuePtr = a5;
          v17 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
          CFDictionarySetValue(v15, v16, v17);
          CFRelease(v17);
          v18 = (const void *)*MEMORY[0x1E0CBBEE0];
          valuePtr = v13 + (a2 - 1) * a4;
          v19 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
          CFDictionarySetValue(v15, v18, v19);
          CFRelease(v19);
          v20 = (const void *)*MEMORY[0x1E0CBBF08];
          valuePtr = (int)a4;
          v21 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
          CFDictionarySetValue(v15, v20, v21);
          CFRelease(v21);
          v22 = (const void *)*MEMORY[0x1E0CBC1E0];
          valuePtr = a1;
          v23 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
          CFDictionarySetValue(v15, v22, v23);
          CFRelease(v23);
          v24 = (const void *)*MEMORY[0x1E0CBC008];
          valuePtr = a2;
          v25 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
          CFDictionarySetValue(v15, v24, v25);
          CFRelease(v25);
          v26 = (const void *)*MEMORY[0x1E0CBC070];
          LODWORD(valuePtr) = a3;
          v27 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
          CFDictionarySetValue(v15, v26, v27);
          CFRelease(v27);
          v28 = (const void *)*MEMORY[0x1E0CBBF00];
          LODWORD(valuePtr) = v11;
          v29 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
          CFDictionarySetValue(v15, v28, v29);
          CFRelease(v29);
          if (((equivalent_uncompressed_format(a3) - 1919365990) & 0xFFFFFFFD) == 0)
            goto LABEL_22;
          v30 = 2;
          if ((int)a3 > 846624120)
          {
            if ((_DWORD)a3 != 846624121 && (_DWORD)a3 != 2037741158)
            {
              v31 = 2037741171;
LABEL_18:
              if ((_DWORD)a3 != v31)
                goto LABEL_22;
            }
          }
          else
          {
            if ((_DWORD)a3 != 828584240 && (_DWORD)a3 != 845361456)
            {
              v31 = 846624102;
              goto LABEL_18;
            }
            v30 = 3;
          }
          v32 = (const void *)*MEMORY[0x1E0CBBFC0];
          LODWORD(valuePtr) = v30;
          v33 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
          CFDictionarySetValue(v15, v32, v33);
          CFRelease(v33);
LABEL_22:
          v5 = IOSurfaceCreate(v15);
          if (CI_NAME_SURFACES())
            IOSurfaceSetValue(v5, (CFStringRef)*MEMORY[0x1E0CBC048], CFSTR("CoreImage"));
          CFRelease(v15);
        }
      }
    }
  }
  return v5;
}

uint64_t SurfaceSetVolatile(IOSurfaceRef buffer, unsigned int a2)
{
  int v4;
  uint32_t oldState;

  if (CI_TRASH_SURFACES_ON_SETVOLATILE_didCheck != -1)
    dispatch_once(&CI_TRASH_SURFACES_ON_SETVOLATILE_didCheck, &__block_literal_global_23_1);
  if (CI_TRASH_SURFACES_ON_SETVOLATILE_v)
    SurfaceApplyPlaneBlock(buffer, (uint64_t)&__block_literal_global_26_2);
  if (a2 >= 7)
    v4 = 7;
  else
    v4 = a2;
  oldState = 0;
  return IOSurfaceSetPurgeable(buffer, (v4 << 8) | 1, &oldState);
}

uint64_t SurfaceSetVolatileEmpty(IOSurfaceRef buffer)
{
  uint32_t oldState;

  if (CI_TRASH_SURFACES_ON_SETVOLATILE_didCheck != -1)
    dispatch_once(&CI_TRASH_SURFACES_ON_SETVOLATILE_didCheck, &__block_literal_global_23_1);
  if (CI_TRASH_SURFACES_ON_SETVOLATILE_v)
    SurfaceApplyPlaneBlock(buffer, (uint64_t)&__block_literal_global_26_2);
  oldState = 0;
  return IOSurfaceSetPurgeable(buffer, 2u, &oldState);
}

BOOL SurfaceSetNonVolatile(__IOSurface *a1)
{
  uint32_t oldState;

  oldState = 0;
  if (IOSurfaceSetPurgeable(a1, 0, &oldState))
    return 1;
  if (CI_TRASH_SURFACES_ON_SETVOLATILE_didCheck != -1)
    dispatch_once(&CI_TRASH_SURFACES_ON_SETVOLATILE_didCheck, &__block_literal_global_23_1);
  return !CI_TRASH_SURFACES_ON_SETVOLATILE_v && oldState != 2;
}

BOOL SurfaceIsVolatile(__IOSurface *a1)
{
  BOOL v1;
  uint32_t oldState;

  oldState = 0;
  if (IOSurfaceSetPurgeable(a1, 3u, &oldState))
    v1 = 1;
  else
    v1 = oldState == 0;
  return !v1;
}

BOOL SurfaceIsVolatileNonEmpty(__IOSurface *a1)
{
  uint32_t oldState;

  oldState = 0;
  return !IOSurfaceSetPurgeable(a1, 3u, &oldState) && oldState == 1;
}

BOOL SurfaceIsVolatileEmpty(__IOSurface *a1)
{
  uint32_t oldState;

  oldState = 0;
  return !IOSurfaceSetPurgeable(a1, 3u, &oldState) && oldState == 2;
}

BOOL SurfaceIsRowBytesAligned(__IOSurface *a1, unint64_t a2)
{
  size_t PlaneCount;
  unint64_t v5;
  unint64_t v6;
  size_t v7;

  PlaneCount = IOSurfaceGetPlaneCount(a1);
  if (PlaneCount <= 1)
    v5 = 1;
  else
    v5 = PlaneCount;
  v6 = 1;
  do
  {
    v7 = IOSurfaceGetBytesPerRowOfPlane(a1, v6 - 1) % a2;
    if (v6 >= v5)
      break;
    ++v6;
  }
  while (!v7);
  return v7 == 0;
}

CGColorSpaceRef CreateColorSpaceFromInfo(const void *a1, const void *a2, const void *a3, const __CFNumber *a4)
{
  const __CFData *v4;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  CFStringRef *v13;
  uint64_t *v15;
  __int16 *v16;
  double v17;
  double v18;
  const __CFString *v19;
  void *v21;
  uint64_t v22;
  CFDictionaryRef v23;
  unint64_t v24;
  const ColorSyncProfile *Profile;
  const ColorSyncProfile *v26;
  const ColorSyncProfile *MutableCopy;
  const __CFData *v28;
  const __CFData *v29;
  __CFData *v30;
  UInt8 *MutableBytePtr;
  UInt8 *v32;
  double v33;
  float64x2_t v34;
  float64x2_t v39;
  float64x2_t v40;
  double v41;
  float64x2_t v42;
  float64x2_t v43;
  float64x2_t v44;
  uint64_t valuePtr;
  UInt8 bytes[8];
  int v48;
  int8x16_t v49;
  unsigned int v50;
  _QWORD v51[2];
  __int128 v52;
  uint64_t v53;
  void *values[14];
  void *keys[2];
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;

  v4 = 0;
  v62 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0CA8D88]))
    {
      v9 = 1;
    }
    else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0CA8D78]))
    {
      v9 = 5;
    }
    else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0CA8DA0]))
    {
      v9 = 6;
    }
    else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0CA8D90]))
    {
      v9 = 22;
    }
    else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0CA8D80]))
    {
      v9 = 9;
    }
    else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0CA8D70]))
    {
      v9 = 11;
    }
    else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0CA8D98]))
    {
      v9 = 12;
    }
    else
    {
      v9 = 2;
    }
    if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CA8EB0]))
    {
      v10 = 1;
    }
    else if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CA8EC0]))
    {
      v10 = 7;
    }
    else if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CA8EA0]))
    {
      v10 = 14;
    }
    else if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CA8ED8]))
    {
      v10 = 0;
    }
    else if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CA8ED0]))
    {
      v10 = 17;
    }
    else if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CA8EB8]))
    {
      v10 = 20;
    }
    else if (CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0CA8EE0]))
    {
      v10 = 19;
    }
    else
    {
      v10 = 2;
    }
    if (a3)
    {
      if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0CA8F18]))
      {
        v11 = 1;
      }
      else if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0CA8F10]))
      {
        v11 = 6;
      }
      else if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0CA8F30]))
      {
        v11 = 7;
      }
      else if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0CA8EF0]))
      {
        v11 = 11;
      }
      else if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0CA8F28]))
      {
        v11 = 12;
      }
      else if (CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0CA8F00]))
      {
        v11 = 9;
      }
      else
      {
        v11 = 2;
      }
    }
    else
    {
      v11 = 2;
    }
    valuePtr = 0x3FF0000000000000;
    if (a4)
    {
      CFNumberGetValue(a4, kCFNumberDoubleType, &valuePtr);
      v12 = *(double *)&valuePtr;
    }
    else
    {
      v12 = 1.0;
    }
    if ((_DWORD)v9 == 12 && (_DWORD)v10 == 1)
    {
      v13 = (CFStringRef *)MEMORY[0x1E0C9D908];
      return CGColorSpaceCreateWithName(*v13);
    }
    if ((_DWORD)v9 == 1 && (_DWORD)v10 == 19)
    {
      v13 = (CFStringRef *)MEMORY[0x1E0C9DA10];
      return CGColorSpaceCreateWithName(*v13);
    }
    if ((_DWORD)v9 == 1 && (_DWORD)v10 == 20)
    {
      v13 = (CFStringRef *)MEMORY[0x1E0C9DA00];
      return CGColorSpaceCreateWithName(*v13);
    }
    v51[0] = 0;
    *(double *)&v51[1] = v12;
    v52 = xmmword_1924948F0;
    v53 = 0;
    if ((_DWORD)v9 == 1)
    {
      v15 = &CreateColorSpaceFromInfoValues_primaries_ITU_R709_2_Info;
    }
    else
    {
      v15 = &CreateColorSpaceFromInfoValues_primaries_EBU_3213_Info;
      switch((int)v9)
      {
        case 5:
          break;
        case 6:
          v15 = &CreateColorSpaceFromInfoValues_primaries_SMPTE_C_Info;
          break;
        case 7:
        case 8:
        case 10:
          goto LABEL_102;
        case 9:
          v15 = &CreateColorSpaceFromInfoValues_primaries_ITU_R_2020_Info;
          break;
        case 11:
          v15 = &CreateColorSpaceFromInfoValues_primaries_DCI_P3_Info;
          break;
        default:
          if ((_DWORD)v9 == 22)
          {
            v15 = &CreateColorSpaceFromInfoValues_primaries_GenericRGB_Info;
          }
          else
          {
LABEL_102:
            if ((_DWORD)v9 == 12)
              v15 = (uint64_t *)&CreateColorSpaceFromInfoValues_primaries_P3_D65_Info;
            else
              v15 = &CreateColorSpaceFromInfoValues_primaries_GenericRGB_Info;
          }
          break;
      }
    }
    if ((_DWORD)v10 == 1)
    {
      v16 = &CreateColorSpaceFromInfoValues_transferFunction_ITU_R2020_Info;
      v10 = 1;
    }
    else if (v10 <= 0xF && ((1 << v10) & 0xC080) != 0)
    {
      v16 = &CreateColorSpaceFromInfoValues_transferFunction_ITU_R2020_Info;
    }
    else
    {
      if ((_DWORD)v10 == 20)
        v16 = (__int16 *)&CreateColorSpaceFromInfoValues_transferFunction_Linear_Info;
      else
        v16 = (__int16 *)&CreateColorSpaceFromInfoValues_transferFunction_sRGB_Info;
      if ((v10 - 19) >= 2)
      {
        _ZF = (_DWORD)v10 == 0;
        if ((_DWORD)v10)
          v10 = v10;
        else
          v10 = 2;
        if (_ZF)
          v16 = (__int16 *)v51;
        else
          v16 = (__int16 *)&CreateColorSpaceFromInfoValues_transferFunction_GenericRGB_Info;
      }
    }
    v17 = *((double *)v16 + 1);
    _ZF = *v16 == 0;
    v59 = xmmword_1E2EC5CD8;
    v60 = *(_OWORD *)&off_1E2EC5CE8;
    if (_ZF)
      v18 = v17;
    else
      v18 = 1.0 / v17;
    v61 = xmmword_1E2EC5CF8;
    *(_OWORD *)keys = xmmword_1E2EC5C98;
    v56 = *(_OWORD *)&off_1E2EC5CA8;
    v57 = xmmword_1E2EC5CB8;
    v58 = *(_OWORD *)&off_1E2EC5CC8;
    values[0] = (void *)CFRetain(CFSTR("displayRGB"));
    if ((_DWORD)v9 == 1 && (_DWORD)v11 == 1 && (_DWORD)v10 == 1)
    {
      v19 = CFSTR("HDTV");
    }
    else if ((_DWORD)v11 == 6 && (_DWORD)v9 == 6 && (_DWORD)v10 == 1)
    {
      v19 = CFSTR("Composite NTSC");
    }
    else if ((_DWORD)v11 == 6 && (_DWORD)v9 == 5 && (_DWORD)v10 == 1)
    {
      v19 = CFSTR("Composite PAL");
    }
    else if ((_DWORD)v9 == 6 && (_DWORD)v11 == 7 && (_DWORD)v10 == 7)
    {
      v19 = CFSTR("HDTV Interim Color Implementation");
    }
    else if ((_DWORD)v9 == 11 && (_DWORD)v11 == 11 && (_DWORD)v10 == 14)
    {
      v19 = CFSTR("Digital Cinema P3");
    }
    else
    {
      if ((_DWORD)v9 != 12 || (_DWORD)v11 != 12 || (_DWORD)v10 != 14)
      {
        v21 = (void *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("QuickTime 'nclc' Video (%d,%d,%d)"), v9, v10, v11);
        goto LABEL_116;
      }
      v19 = CFSTR("D65 P3");
    }
    v21 = (void *)CFRetain(v19);
LABEL_116:
    values[1] = v21;
    *(double *)bytes = v18;
    v22 = 13;
    values[2] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(double *)bytes = v18;
    values[3] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(double *)bytes = v18;
    values[4] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(_QWORD *)bytes = v15[4];
    values[5] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(_QWORD *)bytes = v15[5];
    values[6] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(_QWORD *)bytes = *v15;
    values[7] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(_QWORD *)bytes = v15[1];
    values[8] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(_QWORD *)bytes = v15[2];
    values[9] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(_QWORD *)bytes = v15[3];
    values[10] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(_QWORD *)bytes = v15[6];
    values[11] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    *(_QWORD *)bytes = v15[7];
    values[12] = CFNumberCreate(0, kCFNumberDoubleType, bytes);
    values[13] = (void *)CFStringCreateWithCString(0, "Copyright 2007 Apple Inc.", 0);
    v23 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 14, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    do
    {
      CFRelease(values[v22]);
      v24 = v22-- + 1;
    }
    while (v24 > 1);
    if (!v23)
      return 0;
    Profile = (const ColorSyncProfile *)ColorSyncMakeProfile();
    if (Profile)
    {
      v26 = Profile;
      MutableCopy = ColorSyncProfileCreateMutableCopy(Profile);
      CFRelease(v26);
      if (MutableCopy)
      {
        v28 = ColorSyncProfileCopyHeader(MutableCopy);
        if (v28)
        {
          v29 = v28;
          v30 = CFDataCreateMutableCopy(0, 128, v28);
          CFRelease(v29);
          if (v30)
          {
            CFDataSetLength(v30, 128);
            MutableBytePtr = CFDataGetMutableBytePtr(v30);
            if (!MutableBytePtr)
            {
              v4 = 0;
              goto LABEL_133;
            }
            v32 = MutableBytePtr;
            if (*v16 == 3)
            {
              v33 = *((double *)v16 + 3);
              v34.f64[0] = *((double *)v16 + 4) + 1.0;
              __asm { FMOV            V3.2D, #1.0 }
              v39.f64[1] = _Q3.f64[1];
              v39.f64[0] = *((float64_t *)v16 + 4);
              v40.f64[0] = *((float64_t *)v16 + 1);
              v41 = *((double *)v16 + 2);
              v40.f64[1] = v34.f64[0];
              v34.f64[1] = v33;
              v42 = vdivq_f64(_Q3, v40);
              v43 = vdivq_f64(v39, v34);
              v44 = (float64x2_t)vdupq_n_s64(0x40DFFFC000000000uLL);
              __asm { FMOV            V4.2D, #0.5 }
              bytes[5] = 0;
              *(_WORD *)&bytes[6] = 0;
              v48 = 768;
              strcpy((char *)bytes, "para");
              v49 = vrev32q_s8((int8x16_t)vuzp1q_s32((int32x4_t)vcvtq_u64_f64(vmlaq_f64(_Q4, v44, v42)), (int32x4_t)vcvtq_u64_f64(vmlaq_f64(_Q4, v44, v43))));
              v50 = bswap32((v33 * v41 * 32767.0 + 0.5));
              v4 = CFDataCreateWithBytesNoCopy(0, bytes, 32, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
              if (!v4)
              {
LABEL_133:
                CFRelease(MutableCopy);
                CFRelease(v30);
                goto LABEL_131;
              }
              ColorSyncProfileSetTag(MutableCopy, CFSTR("rTRC"), v4);
              ColorSyncProfileSetTag(MutableCopy, CFSTR("gTRC"), v4);
              ColorSyncProfileSetTag(MutableCopy, CFSTR("bTRC"), v4);
              CFRelease(v4);
              *((_DWORD *)v32 + 2) = 0x4000000;
            }
            *((_QWORD *)v32 + 3) = 0x10001000407D5;
            *((_DWORD *)v32 + 8) = 65537;
            ColorSyncProfileSetHeader(MutableCopy, v30);
            v4 = CGColorSpaceCreateWithPlatformColorSpace(MutableCopy);
            goto LABEL_133;
          }
        }
        CFRelease(MutableCopy);
      }
    }
    v4 = 0;
LABEL_131:
    CFRelease(v23);
  }
  return v4;
}

CGColorSpaceRef CopySurfaceColorSpace(__IOSurface *a1)
{
  uint64_t PixelFormat;
  int v3;
  int v4;
  char v5;
  int v6;
  int v7;
  CGColorSpaceRef result;
  CFTypeRef v9;
  const void *v10;
  CGColorSpaceRef v11;
  CFStringRef *v12;

  PixelFormat = IOSurfaceGetPixelFormat(a1);
  v3 = PixelFormat;
  v4 = equivalent_uncompressed_format(PixelFormat);
  v5 = 0;
  if (v4 <= 1279340599)
  {
    if (((v4 - 1278226488) > 0x30 || ((1 << (v4 - 56)) & 0x1400000000001) == 0)
      && ((v4 - 1278226736) > 6 || ((1 << (v4 - 48)) & 0x45) == 0))
    {
LABEL_19:
      v5 = 1;
      goto LABEL_20;
    }
    goto LABEL_20;
  }
  if (v4 <= 1279342647)
  {
    if ((v4 - 1279340600) <= 0x30 && ((1 << (v4 - 56)) & 0x1400000000001) != 0)
      goto LABEL_20;
    v6 = 1279340854;
LABEL_18:
    if (v4 == v6)
      goto LABEL_20;
    goto LABEL_19;
  }
  if (v4 <= 1717856626)
  {
    if (v4 == 1279342648)
      goto LABEL_20;
    v6 = 1717855600;
    goto LABEL_18;
  }
  if (v4 != 1717856627 && v4 != 1751410032)
  {
    v6 = 1751411059;
    goto LABEL_18;
  }
LABEL_20:
  if (v3 <= 1751410031)
  {
    if (v3 != 1717855600)
    {
      v7 = 1717856627;
      goto LABEL_25;
    }
    return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D948]);
  }
  if (v3 == 1751411059)
    return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D948]);
  v7 = 1751410032;
LABEL_25:
  if (v3 == v7)
    return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D948]);
  v9 = IOSurfaceCopyValue(a1, (CFStringRef)*MEMORY[0x1E0CBBF90]);
  if (v9)
  {
    v10 = v9;
    v11 = CGColorSpaceCreateWithPropertyList(v9);
    CFRelease(v10);
    return v11;
  }
  if ((v5 & 1) == 0)
  {
    IOSurfaceGetBulkAttachments();
    v12 = (CFStringRef *)MEMORY[0x1E0C9D978];
    return CGColorSpaceCreateWithName(*v12);
  }
  if (IOSurfaceGetBulkAttachments()
    || (result = (CGColorSpaceRef)CVCreateColorSpaceFromIOSurfaceBulkAttachments()) == 0)
  {
    v12 = (CFStringRef *)MEMORY[0x1E0C9DA10];
    return CGColorSpaceCreateWithName(*v12);
  }
  return result;
}

CGImage *SurfaceWriteToFile(__IOSurface *a1, CGColorSpace *a2, char *a3)
{
  CGImage *result;
  CGImage *v5;
  _BOOL8 v6;

  result = SurfaceCreateCGImage(a1, a2, 1);
  if (result)
  {
    v5 = result;
    v6 = _writeCGImageToFile(result, a3);
    CGImageRelease(v5);
    return (CGImage *)v6;
  }
  return result;
}

BOOL _writeCGImageToFile(CGImage *a1, char *__s)
{
  size_t v4;
  CFURLRef v5;
  const __CFURL *v6;
  char *v7;
  char *v8;
  const __CFString *v9;
  const __CFString *v10;
  CGImageDestination *v11;
  CGImageDestination *v12;
  _BOOL8 v13;

  v4 = strlen(__s);
  v5 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)__s, v4, 0);
  if (!v5)
    return 0;
  v6 = v5;
  v7 = strstr(__s, ".jpg");
  v8 = strstr(__s, ".png");
  v9 = CFSTR("public.png");
  if (!v8)
    v9 = CFSTR("public.tiff");
  if (v7)
    v10 = CFSTR("public.jpeg");
  else
    v10 = v9;
  v11 = CGImageDestinationCreateWithURL(v6, v10, 1uLL, 0);
  if (v11)
  {
    v12 = v11;
    CGImageDestinationAddImage(v11, a1, 0);
    v13 = CGImageDestinationFinalize(v12);
    CFRelease(v12);
  }
  else
  {
    v13 = 0;
  }
  CFRelease(v6);
  return v13;
}

CGImage *SurfaceRegionWriteToFile(__IOSurface *a1, CGColorSpace *a2, char *a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  CGImage *result;
  CGImage *v13;
  CGImage *v14;
  _BOOL8 v15;
  CGRect v16;

  result = SurfaceCreateCGImage(a1, a2, 1);
  if (result)
  {
    v13 = result;
    v16.origin.x = a4;
    v16.origin.y = a5;
    v16.size.width = a6;
    v16.size.height = a7;
    v14 = CGImageCreateWithImageInRect(result, v16);
    v15 = _writeCGImageToFile(v14, a3);
    CGImageRelease(v14);
    CGImageRelease(v13);
    return (CGImage *)v15;
  }
  return result;
}

CGImage *SurfaceCroppedWriteToFile(__IOSurface *a1, CGColorSpace *a2, char *a3, CGFloat a4, CGFloat a5)
{
  return SurfaceRegionWriteToFile(a1, a2, a3, 0.0, 0.0, a4, a5);
}

BOOL SurfaceCroppedWriteRawToFile(__IOSurface *a1, char *__filename, double a3, double a4)
{
  FILE *v7;
  FILE *v8;
  size_t v9;
  unint64_t v10;
  unint64_t v11;
  size_t WidthOfPlane;
  size_t HeightOfPlane;
  size_t BytesPerRowOfPlane;
  size_t BytesPerElementOfPlane;
  unint64_t v16;
  unint64_t v17;
  int v18;
  _BOOL8 v19;
  char *BaseAddressOfPlane;
  char *v21;
  size_t v22;
  size_t Width;
  size_t Height;
  size_t BytesPerRow;
  size_t BytesPerElement;
  unint64_t v27;
  char *BaseAddress;
  char *v30;
  size_t v31;
  size_t PlaneCount;

  v7 = fopen(__filename, "wb");
  if (v7)
  {
    v8 = v7;
    PlaneCount = IOSurfaceGetPlaneCount(a1);
    if (PlaneCount)
    {
      v9 = 0;
      v10 = (unint64_t)a3;
      v11 = (unint64_t)a4;
      while (1)
      {
        WidthOfPlane = IOSurfaceGetWidthOfPlane(a1, v9);
        HeightOfPlane = IOSurfaceGetHeightOfPlane(a1, v9);
        BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(a1, v9);
        BytesPerElementOfPlane = IOSurfaceGetBytesPerElementOfPlane(a1, v9);
        v16 = WidthOfPlane >= v10 ? v10 : WidthOfPlane;
        v17 = HeightOfPlane >= v11 ? v11 : HeightOfPlane;
        v18 = IOSurfaceLockPlane();
        v19 = v18 == 0;
        if (v18)
          goto LABEL_26;
        BaseAddressOfPlane = (char *)IOSurfaceGetBaseAddressOfPlane(a1, v9);
        if (v17)
        {
          v21 = BaseAddressOfPlane;
          v22 = BytesPerElementOfPlane * v16;
          while (fwrite(v21, 1uLL, v22, v8) == v22)
          {
            v21 += BytesPerRowOfPlane;
            if (!--v17)
              goto LABEL_15;
          }
          IOSurfaceUnlockPlane();
          goto LABEL_25;
        }
LABEL_15:
        IOSurfaceUnlockPlane();
        ++v9;
        v11 = (unint64_t)a4;
        v10 = (unint64_t)a3;
        if (v9 == PlaneCount)
          goto LABEL_26;
      }
    }
    Width = IOSurfaceGetWidth(a1);
    Height = IOSurfaceGetHeight(a1);
    BytesPerRow = IOSurfaceGetBytesPerRow(a1);
    BytesPerElement = IOSurfaceGetBytesPerElement(a1);
    if (Width >= (unint64_t)a3)
      v27 = (unint64_t)a3;
    else
      v27 = Width;
    if (Height >= (unint64_t)a4)
      Height = (unint64_t)a4;
    if (!IOSurfaceLock(a1, 1u, 0))
    {
      BaseAddress = (char *)IOSurfaceGetBaseAddress(a1);
      if (!Height)
      {
LABEL_32:
        v19 = 1;
        IOSurfaceUnlock(a1, 1u, 0);
        goto LABEL_26;
      }
      v30 = BaseAddress;
      v31 = BytesPerElement * v27;
      while (fwrite(v30, 1uLL, v31, v8) == v31)
      {
        v30 += BytesPerRow;
        if (!--Height)
          goto LABEL_32;
      }
      IOSurfaceUnlock(a1, 1u, 0);
    }
LABEL_25:
    v19 = 0;
LABEL_26:
    fclose(v8);
    return v19;
  }
  return 0;
}

BOOL SurfaceCroppedWriteBmtlToFile(__IOSurface *a1, const char *a2, double a3, double a4)
{
  size_t Width;
  size_t Height;
  size_t BytesPerRow;
  signed int PixelFormat;
  unint64_t v12;
  unint64_t v13;
  signed int v15;
  _BOOL8 v16;
  int v17;
  FILE *v18;
  FILE *v19;
  void *BaseAddress;
  int v22;
  __int128 v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  signed int v29;

  if (IOSurfaceGetPlaneCount(a1))
    return 0;
  Width = IOSurfaceGetWidth(a1);
  Height = IOSurfaceGetHeight(a1);
  BytesPerRow = IOSurfaceGetBytesPerRow(a1);
  PixelFormat = IOSurfaceGetPixelFormat(a1);
  v12 = Width >= (unint64_t)a3 ? (unint64_t)a3 : Width;
  v13 = Height >= (unint64_t)a4 ? (unint64_t)a4 : Height;
  if (!v12 || v13 == 0)
    return 0;
  v15 = PixelFormat;
  v16 = 0;
  if (PixelFormat > 843264309)
  {
    if (PixelFormat <= 1380401728)
    {
      switch(PixelFormat)
      {
        case 843264310:
          v17 = 60;
          break;
        case 1111970369:
          v17 = 80;
          break;
        case 1278226488:
          v17 = 1;
          break;
        default:
          return v16;
      }
    }
    else if (PixelFormat > 1380411456)
    {
      if (PixelFormat == 1380411457)
      {
        v17 = 115;
      }
      else
      {
        if (PixelFormat != 1815491698)
          return v16;
        v17 = 110;
      }
    }
    else if (PixelFormat == 1380401729)
    {
      v17 = 70;
    }
    else
    {
      if (PixelFormat != 1380410945)
        return v16;
      v17 = 125;
    }
  }
  else if (PixelFormat <= 826487093)
  {
    switch(PixelFormat)
    {
      case 826486840:
        v17 = 10;
        break;
      case 826486886:
        v17 = 55;
        break;
      case 826486888:
        v17 = 25;
        break;
      default:
        return v16;
    }
  }
  else if (PixelFormat > 843264101)
  {
    if (PixelFormat == 843264102)
    {
      v17 = 105;
    }
    else
    {
      if (PixelFormat != 843264104)
        return v16;
      v17 = 65;
    }
  }
  else if (PixelFormat == 826487094)
  {
    v17 = 20;
  }
  else
  {
    if (PixelFormat != 843264056)
      return v16;
    v17 = 30;
  }
  v18 = fopen(a2, "wb");
  if (!v18)
    return 0;
  v19 = v18;
  v22 = 1280593218;
  v23 = xmmword_192499E70;
  v24 = v12;
  v25 = v13;
  v26 = 0x100000001;
  v27 = v17;
  v28 = BytesPerRow;
  v29 = v15;
  if (fwrite(&v22, 1uLL, 0x30uLL, v18) == 48 && !IOSurfaceLock(a1, 1u, 0))
  {
    BaseAddress = IOSurfaceGetBaseAddress(a1);
    if (BaseAddress)
      v16 = fwrite(BaseAddress, BytesPerRow, Height, v19) == Height;
    else
      v16 = 0;
    IOSurfaceUnlock(a1, 1u, 0);
  }
  else
  {
    v16 = 0;
  }
  fclose(v19);
  return v16;
}

CGImageRef SurfaceCreateCGImage(__IOSurface *a1, CGColorSpace *a2, int a3)
{
  signed int PixelFormat;
  size_t Width;
  size_t Height;
  CGImageRef v9;
  size_t v10;
  CFTypeRef v11;
  CFTypeRef v12;
  __CFData *v13;
  __CFData *v14;
  int HeightOfPlane;
  int v16;
  int v17;
  int v18;
  CFTypeRef v19;
  CGBitmapInfo v20;
  unint64_t BytesPerRow;
  CGDataProvider *v22;
  int v23;
  BOOL v24;
  int v25;
  int v26;
  size_t (__cdecl *v27)(void *, void *, off_t, size_t);
  int v28;
  __int16 *BaseAddressOfPlane;
  int v30;
  int v31;
  int v32;
  __int16 *v33;
  void *v34;
  float v35;
  int v36;
  int v37;
  size_t v38;
  __CFData *Mutable;
  const __CFData *v40;
  size_t v41;
  BOOL v42;
  int v43;
  int v44;
  __int128 *v45;
  unsigned __int16 v46;
  BOOL v47;
  int v48;
  int v49;
  __int128 v50;
  CGColorSpaceRef DeviceGray;
  int v53;
  int v54;
  int v55;
  int WidthOfPlane;
  UInt8 *MutableBytePtr;
  size_t v58;
  size_t BytesPerRowOfPlane;
  CGDataProviderDirectCallbacks callbacks;
  _QWORD v61[6];
  BOOL v62;

  PixelFormat = IOSurfaceGetPixelFormat(a1);
  Width = IOSurfaceGetWidth(a1);
  Height = IOSurfaceGetHeight(a1);
  v9 = 0;
  if (!Width)
    return v9;
  v10 = Height;
  if (!Height)
    return v9;
  v11 = IOSurfaceCopyValue(a1, CFSTR("IOSurfaceAlphaIsOpaque"));
  v12 = v11;
  if (v11)
    CFRelease(v11);
  if (IOSurfaceGetPlaneCount(a1) != 2)
  {
    v9 = 0;
    v19 = (CFTypeRef)*MEMORY[0x1E0C9AE50];
    if (PixelFormat > 1278226735)
    {
      if (PixelFormat > 1667838821)
      {
        if (PixelFormat <= 1919365991)
        {
          if (PixelFormat <= 1815361649)
          {
            if (PixelFormat != 1667838822)
            {
              if (PixelFormat != 1667838824)
              {
                if (PixelFormat != 1815162994)
                  return v9;
                *(_OWORD *)&callbacks.version = xmmword_1E2EC5F38;
                *(_OWORD *)&callbacks.releaseBytePointer = *(_OWORD *)algn_1E2EC5F48;
                callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)providerReleaseCFInfoCallback;
                if (v12 == v19)
                  v20 = 4357;
                else
                  v20 = 4355;
                BytesPerRow = 2 * IOSurfaceGetBytesPerRow(a1);
                CFRetain(a1);
                v22 = CGDataProviderCreateDirect(a1, BytesPerRow * v10, &callbacks);
                v23 = 0;
LABEL_157:
                v38 = 64;
                v41 = 16;
                if (a2)
                  goto LABEL_199;
                goto LABEL_194;
              }
              v23 = 0;
              v20 = 4352;
              goto LABEL_162;
            }
            v23 = 0;
            v20 = 8448;
            v38 = 96;
LABEL_172:
            v41 = 32;
            goto LABEL_179;
          }
          if (PixelFormat == 1815361650)
          {
            v23 = 0;
            v20 = 4096;
LABEL_162:
            v38 = 48;
LABEL_178:
            v41 = 16;
            goto LABEL_179;
          }
          if (PixelFormat != 1815491698)
          {
            if (PixelFormat != 1919365990)
              return v9;
            goto LABEL_87;
          }
          v23 = 0;
          v42 = v12 == v19;
          v43 = 4097;
          v44 = 4101;
LABEL_174:
          if (v42)
            v20 = v44;
          else
            v20 = v43;
          v38 = 64;
          goto LABEL_178;
        }
        if (PixelFormat <= 2033463351)
        {
          if (PixelFormat != 1919365992)
          {
            if (PixelFormat == 1999843442)
            {
              *(_OWORD *)&callbacks.version = xmmword_1E2EC5EE8;
              *(_OWORD *)&callbacks.releaseBytePointer = *(_OWORD *)algn_1E2EC5EF8;
              callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)providerReleaseCFInfoCallback;
              BytesPerRow = 2 * IOSurfaceGetBytesPerRow(a1);
            }
            else
            {
              if (PixelFormat != 1999908961)
                return v9;
              *(_OWORD *)&callbacks.version = xmmword_1E2EC5F10;
              *(_OWORD *)&callbacks.releaseBytePointer = unk_1E2EC5F20;
              callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)providerReleaseCFInfoCallback;
              BytesPerRow = IOSurfaceGetBytesPerRow(a1);
            }
            CFRetain(a1);
            v22 = CGDataProviderCreateDirect(a1, BytesPerRow * v10, &callbacks);
            v23 = 0;
            v20 = 4353;
            goto LABEL_157;
          }
LABEL_87:
          if (PixelFormat == 1919365992)
            v38 = 48;
          else
            v38 = 96;
          BytesPerRow = (v38 >> 3) * Width;
          Mutable = CFDataCreateMutable(0, BytesPerRow * v10);
          if (!Mutable)
            return 0;
          v40 = Mutable;
          if (PixelFormat == 1919365992)
            v41 = 16;
          else
            v41 = 32;
          if (PixelFormat == 1919365992)
            v20 = 4352;
          else
            v20 = 8448;
          CFDataSetLength(Mutable, BytesPerRow * v10);
          v61[0] = MEMORY[0x1E0C809B0];
          v61[1] = 0x40000000;
          v61[2] = __SurfaceCreateCGImage_block_invoke;
          v61[3] = &__block_descriptor_tmp_5;
          v62 = PixelFormat == 1919365992;
          v61[4] = v40;
          v61[5] = BytesPerRow / (v38 >> 3) * v10;
          SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v61);
          v22 = CGDataProviderCreateWithCFData(v40);
          CFRelease(v40);
          v23 = 0;
          if (a2)
            goto LABEL_199;
LABEL_194:
          a2 = CopySurfaceColorSpace(a1);
          if (!a2)
          {
            if (v23)
              DeviceGray = CGColorSpaceCreateDeviceGray();
            else
              DeviceGray = CGColorSpaceCreateDeviceRGB();
            a2 = DeviceGray;
          }
          goto LABEL_199;
        }
        if (PixelFormat != 2033463352)
        {
          if (PixelFormat == 2037741158)
          {
            v45 = &xmmword_1E2EC5D58;
          }
          else
          {
            if (PixelFormat != 2037741171)
              return v9;
            v45 = &xmmword_1E2EC5D08;
          }
          goto LABEL_190;
        }
        *(_OWORD *)&callbacks.version = xmmword_1E2EC5DA8;
        *(_OWORD *)&callbacks.releaseBytePointer = *(_OWORD *)algn_1E2EC5DB8;
        callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)providerReleaseCFInfoCallback;
        BytesPerRow = IOSurfaceGetBytesPerRow(a1);
        CFRetain(a1);
        v22 = CGDataProviderCreateDirect(a1, BytesPerRow * v10, &callbacks);
        v23 = 0;
        v20 = 3;
LABEL_192:
        v38 = 32;
        goto LABEL_193;
      }
      if (PixelFormat > 1279340647)
      {
        if (PixelFormat > 1380410944)
        {
          switch(PixelFormat)
          {
            case 1380410945:
              v23 = 0;
              if (v12 == v19)
                v20 = 8453;
              else
                v20 = 8449;
              v38 = 128;
              goto LABEL_172;
            case 1380411457:
              v23 = 0;
              v42 = v12 == v19;
              v43 = 4353;
              v44 = 4357;
              break;
            case 1664496754:
              v23 = 0;
              v42 = v12 == v19;
              v43 = 4098;
              v44 = 4102;
              break;
            default:
              return v9;
          }
          goto LABEL_174;
        }
        switch(PixelFormat)
        {
          case 1279340648:
            v47 = v12 == v19;
            v48 = 4353;
            v49 = 4357;
            break;
          case 1279340854:
            v47 = v12 == v19;
            v48 = 4097;
            v49 = 4101;
            break;
          case 1380401729:
            v23 = 0;
            if (v12 == v19)
              v20 = 5;
            else
              v20 = 1;
            goto LABEL_153;
          default:
            return v9;
        }
        if (v47)
          v20 = v49;
        else
          v20 = v48;
        v23 = 1;
        v38 = 32;
        goto LABEL_178;
      }
      if ((PixelFormat - 1278226736) > 6 || ((1 << (PixelFormat - 48)) & 0x45) == 0)
      {
        if (PixelFormat != 1279340600)
        {
          if (PixelFormat != 1279340646)
            return v9;
          if (v12 == v19)
            v20 = 8453;
          else
            v20 = 8449;
          v23 = 1;
          v38 = 64;
          goto LABEL_172;
        }
        if (v12 == v19)
          v20 = 5;
        else
          v20 = 1;
        v23 = 1;
        v38 = 16;
LABEL_154:
        v41 = 8;
        goto LABEL_179;
      }
      v23 = 1;
      v20 = 4096;
LABEL_112:
      v41 = 16;
      v38 = 16;
      goto LABEL_179;
    }
    if (PixelFormat > 843264303)
    {
      if (PixelFormat <= 1093677111)
      {
        if ((PixelFormat - 843264304) <= 6 && ((1 << (PixelFormat - 48)) & 0x45) != 0)
        {
          *(_OWORD *)&callbacks.version = xmmword_1E2EC5DF8;
          *(_OWORD *)&callbacks.releaseBytePointer = *(_OWORD *)algn_1E2EC5E08;
          callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)providerReleaseCFInfoCallback;
          BytesPerRow = 2 * IOSurfaceGetBytesPerRow(a1);
LABEL_69:
          CFRetain(a1);
          v22 = CGDataProviderCreateDirect(a1, BytesPerRow * v10, &callbacks);
          v23 = 0;
          v20 = 4101;
          goto LABEL_157;
        }
        if (PixelFormat == 846624102)
        {
          v45 = &xmmword_1E2EC5D80;
        }
        else
        {
          if (PixelFormat != 846624121)
            return v9;
          v45 = &xmmword_1E2EC5D30;
        }
        goto LABEL_190;
      }
      if (PixelFormat <= 1278226487)
      {
        switch(PixelFormat)
        {
          case 1093677112:
            *(_OWORD *)&callbacks.version = xmmword_1E2EC5F60;
            *(_OWORD *)&callbacks.releaseBytePointer = unk_1E2EC5F70;
            callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)providerReleaseCFInfoCallback;
            BytesPerRow = 4 * IOSurfaceGetBytesPerRow(a1);
            CFRetain(a1);
            v22 = CGDataProviderCreateDirect(a1, BytesPerRow * v10, &callbacks);
            v23 = 0;
            v20 = 1;
            goto LABEL_192;
          case 1094862674:
            v23 = 0;
            v24 = v12 == v19;
            v25 = 8193;
            v26 = 8197;
            break;
          case 1111970369:
            v23 = 0;
            v24 = v12 == v19;
            v25 = 8194;
            v26 = 8198;
            break;
          default:
            return v9;
        }
        goto LABEL_150;
      }
      switch(PixelFormat)
      {
        case 1278226488:
          v20 = 0;
          v23 = 1;
          v41 = 8;
          v38 = 8;
          break;
        case 1278226534:
          v23 = 1;
          v20 = 8448;
          v41 = 32;
          v38 = 32;
          break;
        case 1278226536:
          v23 = 1;
          v20 = 4352;
          goto LABEL_112;
        default:
          return v9;
      }
    }
    else
    {
      if (PixelFormat > 826487087)
      {
        if (PixelFormat <= 843264055)
        {
          if ((PixelFormat - 826487088) > 6 || ((1 << (PixelFormat - 48)) & 0x45) == 0)
            return v9;
          *(_OWORD *)&callbacks.version = xmmword_1E2EC5E98;
          *(_OWORD *)&callbacks.releaseBytePointer = *(_OWORD *)algn_1E2EC5EA8;
          callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)providerReleaseCFInfoCallback;
          BytesPerRow = 4 * IOSurfaceGetBytesPerRow(a1);
          goto LABEL_69;
        }
        if (PixelFormat != 843264056)
        {
          if (PixelFormat != 843264102)
          {
            if (PixelFormat != 843264104)
              return v9;
            *(_OWORD *)&callbacks.version = xmmword_1E2EC5E20;
            *(_OWORD *)&callbacks.releaseBytePointer = unk_1E2EC5E30;
            callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)providerReleaseCFInfoCallback;
            BytesPerRow = 2 * IOSurfaceGetBytesPerRow(a1);
LABEL_103:
            CFRetain(a1);
            v22 = CGDataProviderCreateDirect(a1, BytesPerRow * v10, &callbacks);
            v23 = 0;
            v20 = 4357;
            goto LABEL_157;
          }
          *(_OWORD *)&callbacks.version = xmmword_1E2EC5E48;
          *(_OWORD *)&callbacks.releaseBytePointer = *(_OWORD *)algn_1E2EC5E58;
          callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)providerReleaseCFInfoCallback;
          BytesPerRow = 2 * IOSurfaceGetBytesPerRow(a1);
          goto LABEL_166;
        }
        v45 = &xmmword_1E2EC5DD0;
LABEL_190:
        v50 = v45[1];
        *(_OWORD *)&callbacks.version = *v45;
        *(_OWORD *)&callbacks.releaseBytePointer = v50;
        callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)*((_QWORD *)v45 + 4);
        BytesPerRow = 2 * IOSurfaceGetBytesPerRow(a1);
        goto LABEL_191;
      }
      if (PixelFormat > 826486839)
      {
        if (PixelFormat == 826486840)
        {
          *(_OWORD *)&callbacks.version = xmmword_1E2EC5E70;
          *(_OWORD *)&callbacks.releaseBytePointer = unk_1E2EC5E80;
          callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)providerReleaseCFInfoCallback;
          BytesPerRow = 4 * IOSurfaceGetBytesPerRow(a1);
LABEL_191:
          CFRetain(a1);
          v22 = CGDataProviderCreateDirect(a1, BytesPerRow * v10, &callbacks);
          v23 = 0;
          v20 = 5;
          goto LABEL_192;
        }
        if (PixelFormat != 826486886)
        {
          if (PixelFormat != 826486888)
            return v9;
          v27 = (size_t (__cdecl *)(void *, void *, off_t, size_t))providerGetBytesAtPositionCallback_1C0h_surface;
          if (a3)
            v27 = (size_t (__cdecl *)(void *, void *, off_t, size_t))providerGetBytesAtPositionCallback_1C0h_surface_lut;
          memset(&callbacks, 0, 24);
          callbacks.getBytesAtPosition = v27;
          callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)providerReleaseCFInfoCallback;
          BytesPerRow = 4 * IOSurfaceGetBytesPerRow(a1);
          goto LABEL_103;
        }
        *(_OWORD *)&callbacks.version = xmmword_1E2EC5EC0;
        *(_OWORD *)&callbacks.releaseBytePointer = unk_1E2EC5ED0;
        callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)providerReleaseCFInfoCallback;
        BytesPerRow = 4 * IOSurfaceGetBytesPerRow(a1);
LABEL_166:
        CFRetain(a1);
        v22 = CGDataProviderCreateDirect(a1, BytesPerRow * v10, &callbacks);
        v23 = 0;
        v20 = 8453;
        v38 = 128;
        v41 = 32;
        if (a2)
          goto LABEL_199;
        goto LABEL_194;
      }
      if (PixelFormat != 24)
      {
        if (PixelFormat != 32)
          return v9;
        v23 = 0;
        v24 = v12 == v19;
        v25 = 2;
        v26 = 6;
LABEL_150:
        if (v24)
          v20 = v26;
        else
          v20 = v25;
LABEL_153:
        v38 = 32;
        goto LABEL_154;
      }
      v20 = 0;
      v23 = 0;
      v41 = 8;
      v38 = 24;
    }
LABEL_179:
    *(_OWORD *)&callbacks.version = xmmword_1E2EC5F88;
    *(_OWORD *)&callbacks.releaseBytePointer = *(_OWORD *)&off_1E2EC5F98;
    callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)providerReleaseCFInfoCallback;
    BytesPerRow = IOSurfaceGetBytesPerRow(a1);
    CFRetain(a1);
    v22 = CGDataProviderCreateDirect(a1, BytesPerRow * v10, &callbacks);
    if (a2)
      goto LABEL_199;
    goto LABEL_194;
  }
  v13 = CFDataCreateMutable(0, 3 * Width * v10);
  if (!v13)
    return 0;
  v14 = v13;
  CFDataSetLength(v13, 3 * Width * v10);
  MutableBytePtr = CFDataGetMutableBytePtr(v14);
  BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(a1, 0);
  v58 = IOSurfaceGetBytesPerRowOfPlane(a1, 1uLL);
  WidthOfPlane = IOSurfaceGetWidthOfPlane(a1, 1uLL);
  HeightOfPlane = IOSurfaceGetHeightOfPlane(a1, 1uLL);
  if ((PixelFormat & 0xFD000000) != 0x2D000000 && PixelFormat >> 24 != 124 && PixelFormat >> 24 != 38)
  {
    v16 = 709;
    v17 = 118;
    if (PixelFormat > 1937126451)
    {
      if (PixelFormat <= 2016686639)
      {
        if (PixelFormat > 1953903153)
        {
          if (PixelFormat == 1953903154)
            goto LABEL_47;
          v46 = 13364;
        }
        else
        {
          if (PixelFormat == 1937126452)
            goto LABEL_47;
          v46 = 12848;
        }
        v28 = v46 | 0x74760000;
      }
      else if (PixelFormat <= 2016687155)
      {
        if (PixelFormat == 2016686640)
          goto LABEL_47;
        v28 = 2016686642;
      }
      else
      {
        if (PixelFormat == 2016687156 || PixelFormat == 2033463352)
          goto LABEL_47;
        v28 = 2037741171;
      }
    }
    else if (PixelFormat <= 1882468911)
    {
      if (PixelFormat > 875704949)
      {
        if (PixelFormat == 875704950)
          goto LABEL_47;
        v28 = 875836534;
      }
      else
      {
        if (PixelFormat == 846624121)
          goto LABEL_47;
        v28 = 875704438;
      }
    }
    else if (PixelFormat <= 1882469427)
    {
      if (PixelFormat == 1882468912)
        goto LABEL_47;
      v28 = 1882468914;
    }
    else
    {
      if (PixelFormat == 1882469428 || PixelFormat == 1937125936)
        goto LABEL_47;
      v28 = 1937125938;
    }
    if (PixelFormat == v28)
      goto LABEL_47;
    goto LABEL_14;
  }
  v16 = 709;
  v17 = 118;
  if ((PixelFormat & 0xFFFFFFu) - 3700272 > 4 || ((1 << (PixelFormat - 48)) & 0x15) == 0)
  {
    v18 = PixelFormat & 0xFFFFFF | 0x20000000;
    if (((v18 - 544765488) > 4 || ((1 << (PixelFormat - 48)) & 0x15) == 0) && v18 != 544830835)
    {
LABEL_14:
      v16 = 601;
      v17 = 102;
    }
  }
LABEL_47:
  if (IOSurfaceLockPlane())
    goto LABEL_49;
  if (IOSurfaceLockPlane())
    goto LABEL_49;
  BaseAddressOfPlane = (__int16 *)IOSurfaceGetBaseAddressOfPlane(a1, 0);
  if (!BaseAddressOfPlane
    || (v30 = v17,
        v31 = v16,
        v32 = HeightOfPlane,
        v33 = BaseAddressOfPlane,
        v34 = IOSurfaceGetBaseAddressOfPlane(a1, 1uLL),
        v36 = v30,
        BytesPerRow = 3 * Width,
        !v34))
  {
LABEL_49:
    CFRelease(v14);
    return 0;
  }
  if (PixelFormat <= 1937125937)
  {
    if (PixelFormat <= 1885745711)
    {
      if (PixelFormat <= 1882468911)
      {
        switch(PixelFormat)
        {
          case 1751527984:
            Convert_420h_to_RGB(v31, Width, v10, WidthOfPlane, v32, 3 * Width, BytesPerRowOfPlane, v58, (uint64_t)MutableBytePtr, (uint64_t)v33, (uint64_t)v34);
            goto LABEL_265;
          case 1751527986:
            Convert_422h_to_RGB(v31, Width, v10, WidthOfPlane, 3 * Width, BytesPerRowOfPlane, v58, (uint64_t)MutableBytePtr, (uint64_t)v33, (uint64_t)v34);
            goto LABEL_265;
          case 1751528500:
            Convert_444h_to_RGB(v31, Width, v10, 3 * Width, BytesPerRowOfPlane, v58, (uint64_t)MutableBytePtr, v33, (uint64_t)v34);
            goto LABEL_265;
        }
        goto LABEL_261;
      }
      if (PixelFormat != 1882468912)
      {
        if (PixelFormat != 1882468914)
        {
          v55 = 1882469428;
LABEL_242:
          if (PixelFormat == v55)
          {
            Convert_444p_to_RGB(v36, v31, Width, v10, 3 * Width, BytesPerRowOfPlane, v58, (uint64_t)MutableBytePtr, (uint64_t)v33, (uint64_t)v34);
            goto LABEL_265;
          }
          goto LABEL_261;
        }
LABEL_258:
        Convert_422p_to_RGB(v36, v31, Width, v10, WidthOfPlane, 3 * Width, BytesPerRowOfPlane, v58, (uint64_t)MutableBytePtr, (uint64_t)v33, (uint64_t)v34);
        goto LABEL_265;
      }
    }
    else
    {
      if (PixelFormat > 1936077359)
      {
        if (PixelFormat > 1936077875)
        {
          if (PixelFormat != 1936077876)
          {
            v54 = 1937125936;
LABEL_250:
            if (PixelFormat != v54)
              goto LABEL_261;
            goto LABEL_251;
          }
LABEL_255:
          Convert_444x_to_RGB(v36, v31, Width, v10, 3 * Width, BytesPerRowOfPlane, v58, (uint64_t)MutableBytePtr, (unsigned __int16 *)v33, (uint64_t)v34);
          goto LABEL_265;
        }
        if (PixelFormat != 1936077360)
        {
          v53 = 1936077362;
          goto LABEL_246;
        }
LABEL_251:
        Convert_420x_to_RGB(v36, v31, Width, v10, WidthOfPlane, v32, 3 * Width, BytesPerRowOfPlane, v58, (uint64_t)MutableBytePtr, (uint64_t)v33, (uint64_t)v34);
        goto LABEL_265;
      }
      if (PixelFormat != 1885745712)
      {
        if (PixelFormat != 1885745714)
        {
          v55 = 1885746228;
          goto LABEL_242;
        }
        goto LABEL_258;
      }
    }
    Convert_420p_to_RGB(v36, v31, Width, v10, WidthOfPlane, v32, 3 * Width, BytesPerRowOfPlane, v58, (uint64_t)MutableBytePtr, (uint64_t)v33, (uint64_t)v34);
    goto LABEL_265;
  }
  if (PixelFormat > 1953903667)
  {
    if (PixelFormat > 2016687155)
    {
      if (PixelFormat > 2019963441)
      {
        if (PixelFormat != 2019963442)
        {
          v37 = 2019963956;
LABEL_254:
          if (PixelFormat == v37)
            goto LABEL_255;
          goto LABEL_261;
        }
LABEL_256:
        Convert_422x_to_RGB(v36, v31, Width, v10, WidthOfPlane, 3 * Width, BytesPerRowOfPlane, v58, (uint64_t)MutableBytePtr, (uint64_t)v33, (uint64_t)v34);
        goto LABEL_265;
      }
      if (PixelFormat != 2016687156)
      {
        v54 = 2019963440;
        goto LABEL_250;
      }
      goto LABEL_255;
    }
    if (PixelFormat == 1953903668)
      goto LABEL_255;
    if (PixelFormat != 2016686640)
    {
      v53 = 2016686642;
      goto LABEL_246;
    }
    goto LABEL_251;
  }
  if (PixelFormat <= 1952854577)
  {
    if (PixelFormat == 1937125938)
      goto LABEL_256;
    if (PixelFormat != 1937126452)
    {
      v54 = 1952854576;
      goto LABEL_250;
    }
    goto LABEL_255;
  }
  if (PixelFormat <= 1953903151)
  {
    if (PixelFormat != 1952854578)
    {
      v37 = 1952855092;
      goto LABEL_254;
    }
    goto LABEL_256;
  }
  if (PixelFormat == 1953903152)
    goto LABEL_251;
  v53 = 1953903154;
LABEL_246:
  if (PixelFormat == v53)
    goto LABEL_256;
LABEL_261:
  if ((PixelFormat & 0xFFFFFFEF) == 0x34323266)
  {
    Convert_422_to_RGB(v36, v31, Width, v10, WidthOfPlane, 3 * Width, BytesPerRowOfPlane, v58, v35, (uint64_t)MutableBytePtr, (uint64_t)v33, (uint64_t)v34);
  }
  else
  {
    if ((PixelFormat & 0xFFFFFFEF) != 0x34323066)
    {
      IOSurfaceUnlockPlane();
      IOSurfaceUnlockPlane();
      v22 = 0;
      goto LABEL_266;
    }
    Convert_420_to_RGB(v36, v31, Width, v10, WidthOfPlane, v32, 3 * Width, BytesPerRowOfPlane, v35, v58, (uint64_t)MutableBytePtr, (uint64_t)v33, (uint64_t)v34);
  }
LABEL_265:
  IOSurfaceUnlockPlane();
  IOSurfaceUnlockPlane();
  v22 = CGDataProviderCreateWithCFData(v14);
LABEL_266:
  CFRelease(v14);
  v20 = 0;
  v23 = 0;
  v38 = 24;
LABEL_193:
  v41 = 8;
  if (!a2)
    goto LABEL_194;
LABEL_199:
  if (v22)
  {
    v9 = CGImageCreate(Width, v10, v41, v38, BytesPerRow, a2, v20, v22, 0, 1, kCGRenderingIntentDefault);
    CGDataProviderRelease(v22);
  }
  else
  {
    v9 = 0;
  }
  CGColorSpaceRelease(a2);
  return v9;
}

void Convert_420h_to_RGB(int a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  int v14;
  int v16;
  int v17;
  int v18;
  int v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _BYTE *v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  unsigned int v36;
  float v39;
  float v42;
  unsigned int v45;
  float v49;
  float v52;
  int v57;
  uint64_t v60;
  __int16 v61[3];

  if (a3)
  {
    v13 = 0;
    v57 = a5 - 1;
    v14 = a4 - 1;
    do
    {
      if ((int)v13 >= 0)
        v16 = v13;
      else
        v16 = v13 + 1;
      v60 = v13;
      v17 = 2 * (v13 & 1) + (v16 >> 1) - 1;
      if (v57 >= v16 >> 1)
        v18 = v16 >> 1;
      else
        v18 = v57;
      if (v57 >= v17)
        v19 = v17;
      else
        v19 = v57;
      if (a2)
      {
        v20 = 0;
        v21 = 0;
        v22 = a11 + (v18 & ~(v18 >> 31)) * a8;
        v23 = a11 + (v19 & ~(v19 >> 31)) * a8;
        v24 = (_BYTE *)(a9 + v60 * a6);
        do
        {
          if ((int)v21 >= 0)
            v25 = v21;
          else
            v25 = v21 + 1;
          v26 = (v20 & 2) + (v25 >> 1) - 1;
          if (v14 >= v25 >> 1)
            v27 = v25 >> 1;
          else
            v27 = v14;
          v28 = v27 & ~(v27 >> 31);
          if (v14 >= v26)
            v29 = v26;
          else
            v29 = v14;
          v61[0] = *(_WORD *)(a10 + 2 * v21);
          _H0 = *(_WORD *)(v22 + 2 * (2 * v28));
          __asm { FCVT            S0, H0 }
          v36 = 2 * (v29 & ~(v29 >> 31));
          _H1 = *(_WORD *)(v22 + 2 * v36);
          __asm { FCVT            S1, H1 }
          v39 = (float)(_S1 * 3.0) + (float)(_S0 * 9.0);
          LOWORD(_S1) = *(_WORD *)(v23 + 2 * (2 * v28));
          __asm { FCVT            S1, H1 }
          _H2 = *(_WORD *)(v23 + 2 * v36);
          v42 = v39 + (float)(_S1 * 3.0);
          __asm { FCVT            S1, H2 }
          _S0 = (float)(v42 + _S1) * 0.0625;
          __asm { FCVT            H0, S0 }
          v61[1] = LOWORD(_S0);
          v45 = (2 * v28) | 1;
          LOWORD(_S0) = *(_WORD *)(v22 + 2 * v45);
          __asm { FCVT            S0, H0 }
          _H2 = *(_WORD *)(v22 + 2 * (v36 | 1));
          __asm { FCVT            S2, H2 }
          v49 = (float)(_S2 * 3.0) + (float)(_S0 * 9.0);
          LOWORD(_S2) = *(_WORD *)(v23 + 2 * v45);
          __asm { FCVT            S2, H2 }
          _H3 = *(_WORD *)(v23 + 2 * (v36 | 1));
          v52 = v49 + (float)(_S2 * 3.0);
          __asm { FCVT            S2, H3 }
          _S0 = (float)(v52 + _S2) * 0.0625;
          __asm { FCVT            H0, S0 }
          v61[2] = LOWORD(_S0);
          Convert_one_YCCh_to_RGB(a1, v24, v61);
          ++v21;
          v24 += 3;
          v20 += 2;
        }
        while (a2 != v21);
      }
      v13 = v60 + 1;
      a10 += a7;
    }
    while (v60 + 1 != a3);
  }
}

void Convert_422h_to_RGB(int a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v13;
  int v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  __int16 v42[3];

  if (a3)
  {
    v13 = 0;
    v15 = a4 - 1;
    do
    {
      if (a2)
      {
        v16 = 0;
        v17 = 0;
        v18 = a10 + v13 * a7;
        v19 = (_BYTE *)(a8 + v13 * a5);
        do
        {
          if ((int)v17 >= 0)
            v20 = v17;
          else
            v20 = v17 + 1;
          v21 = (v16 & 2) + (v20 >> 1) - 1;
          if (v15 >= v20 >> 1)
            v22 = v20 >> 1;
          else
            v22 = v15;
          v23 = v22 & ~(v22 >> 31);
          if (v15 >= v21)
            v24 = v21;
          else
            v24 = v15;
          v25 = v24 & ~(v24 >> 31);
          _H1 = *(_WORD *)(v18 + 2 * (2 * v23));
          v42[0] = *(_WORD *)(a9 + 2 * v17);
          __asm { FCVT            S0, H1 }
          _H1 = *(_WORD *)(v18 + 2 * (2 * v25));
          __asm { FCVT            S1, H1 }
          _S0 = (float)(_S1 + (float)(_S0 * 3.0)) * 0.25;
          __asm { FCVT            H0, S0 }
          v42[1] = LOWORD(_S0);
          LOWORD(_S0) = *(_WORD *)(v18 + 2 * ((2 * v23) | 1u));
          LOWORD(_S1) = *(_WORD *)(v18 + 2 * ((2 * v25) | 1u));
          __asm
          {
            FCVT            S0, H0
            FCVT            S1, H1
          }
          _S0 = (float)(_S1 + (float)(_S0 * 3.0)) * 0.25;
          __asm { FCVT            H0, S0 }
          v42[2] = LOWORD(_S0);
          Convert_one_YCCh_to_RGB(a1, v19, v42);
          ++v17;
          v19 += 3;
          v16 += 2;
        }
        while (a2 != v17);
      }
      ++v13;
      a9 += a6;
    }
    while (v13 != a3);
  }
}

void Convert_444h_to_RGB(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, __int16 *a8, uint64_t a9)
{
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  __int16 *v17;
  uint64_t v18;
  __int16 v19;
  __int16 v24;
  int v25;

  if (a3)
  {
    v13 = 0;
    v14 = a9 + 2;
    do
    {
      if (a2)
      {
        v15 = (_BYTE *)(a7 + v13 * a4);
        v16 = v14;
        v17 = a8;
        v18 = a2;
        do
        {
          v19 = *v17++;
          v24 = v19;
          v25 = *(_DWORD *)(v16 - 2);
          Convert_one_YCCh_to_RGB(a1, v15, &v24);
          v15 += 3;
          v16 += 4;
          --v18;
        }
        while (v18);
      }
      ++v13;
      a8 = (__int16 *)((char *)a8 + a5);
      v14 += a6;
    }
    while (v13 != a3);
  }
}

void Convert_420p_to_RGB(int a1, int a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BYTE *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  unint64_t v31;
  unsigned int v32;
  unsigned int v33;
  int v36;
  uint64_t v38;
  unsigned __int16 v39[3];

  if (a4)
  {
    v15 = 0;
    v36 = a6 - 1;
    v16 = a5 - 1;
    do
    {
      if ((int)v15 >= 0)
        v17 = v15;
      else
        v17 = v15 + 1;
      v38 = v15;
      v18 = 2 * (v15 & 1) + (v17 >> 1) - 1;
      if (v36 >= v17 >> 1)
        v19 = v17 >> 1;
      else
        v19 = v36;
      if (v36 >= v18)
        v20 = v18;
      else
        v20 = v36;
      if (a3)
      {
        v21 = 0;
        v22 = 0;
        v23 = a12 + (v19 & ~(v19 >> 31)) * a9;
        v24 = a12 + (v20 & ~(v20 >> 31)) * a9;
        v25 = (_BYTE *)(a10 + v38 * a7);
        do
        {
          if ((int)v22 >= 0)
            v26 = v22;
          else
            v26 = v22 + 1;
          v27 = (v21 & 2) + (v26 >> 1) - 1;
          if (v16 >= v26 >> 1)
            v28 = v26 >> 1;
          else
            v28 = v16;
          v29 = v28 & ~(v28 >> 31);
          if (v16 < v27)
            v27 = v16;
          v30 = v27 & ~(v27 >> 31);
          v31 = (2 * v29) / 3uLL;
          v32 = *(_DWORD *)(v23 + 4 * v31);
          v39[0] = (unsigned __int16)(*(_DWORD *)(a11 + v38 * a8 + 4 * ((int)v22 / 3)) >> (10
                                                                                           * (v22
                                                                                            - 3
                                                                                            * (((unint64_t)(1431655766 * (int)v22) >> 32)
                                                                                             + (1431655766 * (int)v22 < 0))))) << 6;
          v39[1] = ((((*(_DWORD *)(v24 + 4 * ((2 * v30) / 3uLL)) >> (10 * (2 * v30 % 3u))) & 0x3FF) << 6)
                  + 576 * ((v32 >> (10 * (2 * v29 % 3u))) & 0x3FF)
                  + 3
                  * ((((*(_DWORD *)(v24 + 4 * v31) >> (10 * (2 * v29 % 3u))) & 0x3FF) << 6)
                   + (((*(_DWORD *)(v23 + 4 * ((2 * v30) / 3uLL)) >> (10 * (2 * v30 % 3u))) & 0x3FF) << 6))) >> 4;
          v33 = (2 * v29) | 1;
          LODWORD(v31) = (2 * v30) | 1;
          v39[2] = ((((*(_DWORD *)(v24 + 4 * (v31 / 3uLL)) >> (10 * (v31 % 3))) & 0x3FF) << 6)
                  + 576 * ((*(_DWORD *)(v23 + 4 * (v33 / 3uLL)) >> (10 * (v33 % 3))) & 0x3FF)
                  + 3
                  * ((((*(_DWORD *)(v24 + 4 * (v33 / 3uLL)) >> (10 * (v33 % 3))) & 0x3FF) << 6)
                   + (((*(_DWORD *)(v23 + 4 * (v31 / 3uLL)) >> (10 * (v31 % 3))) & 0x3FFu) << 6))) >> 4;
          Convert_one_YCC_10bit_to_RGB(a1, a2, v25, v39);
          ++v22;
          v25 += 3;
          v21 += 2;
        }
        while (a3 != v22);
      }
      v15 = v38 + 1;
    }
    while (v38 + 1 != a4);
  }
}

void Convert_422p_to_RGB(int a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v28;
  unsigned __int16 v29[3];

  if (a4)
  {
    v28 = 0;
    v14 = a5 - 1;
    do
    {
      if (a3)
      {
        v15 = 0;
        v16 = 0;
        v17 = a11 + v28 * a8;
        v18 = (_BYTE *)(a9 + v28 * a6);
        do
        {
          if ((int)v16 >= 0)
            v19 = v16;
          else
            v19 = v16 + 1;
          v20 = (v15 & 2) + (v19 >> 1) - 1;
          if (v14 >= v19 >> 1)
            v21 = v19 >> 1;
          else
            v21 = v14;
          v22 = v21 & ~(v21 >> 31);
          if (v14 < v20)
            v20 = v14;
          v23 = v20 & ~(v20 >> 31);
          v29[0] = (unsigned __int16)(*(_DWORD *)(a10 + v28 * a7 + 4 * ((int)v16 / 3)) >> (10 * ((int)v16 % 3))) << 6;
          v29[1] = (192 * ((*(_DWORD *)(v17 + 4 * ((2 * v22) / 3uLL)) >> (10 * (2 * v22 % 3u))) & 0x3FF)
                  + (((*(_DWORD *)(v17 + 4 * ((2 * v23) / 3uLL)) >> (10 * (2 * v23 % 3u))) & 0x3FFu) << 6)) >> 2;
          v29[2] = (192 * ((*(_DWORD *)(v17 + 4 * (((2 * v22) | 1u) / 3uLL)) >> (10 * (((2 * v22) | 1u) % 3))) & 0x3FF)
                  + (((*(_DWORD *)(v17 + 4 * (((2 * v23) | 1u) / 3uLL)) >> (10 * (((2 * v23) | 1u) % 3))) & 0x3FFu) << 6)) >> 2;
          Convert_one_YCC_10bit_to_RGB(a1, a2, v18, v29);
          ++v16;
          v18 += 3;
          v15 += 2;
        }
        while (a3 != v16);
      }
      ++v28;
    }
    while (v28 != a4);
  }
}

void Convert_444p_to_RGB(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t i;
  int v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  unsigned __int16 v23[3];

  if (a4)
  {
    for (i = 0; i != a4; ++i)
    {
      if (a3)
      {
        v14 = 0;
        v15 = 0;
        v16 = a10 + i * a7;
        v17 = (_BYTE *)(a8 + i * a5);
        do
        {
          v23[0] = (unsigned __int16)(*(_DWORD *)(a9 + i * a6 + 4 * ((int)v15 / 3)) >> (10 * ((int)v15 % 3))) << 6;
          v23[1] = (unsigned __int16)(*(_DWORD *)(v16 + 4 * (v14 / 3)) >> (10 * (v14 % 3))) << 6;
          v23[2] = (unsigned __int16)(*(_DWORD *)(v16 + 4 * ((v14 + 1) / 3)) >> (10 * ((v14 + 1) % 3))) << 6;
          Convert_one_YCC_10bit_to_RGB(a1, a2, v17, v23);
          ++v15;
          v17 += 3;
          v14 += 2;
        }
        while (a3 != v15);
      }
    }
  }
}

void Convert_420x_to_RGB(int a1, int a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v15;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v35;
  uint64_t v38;
  unsigned __int16 v39[3];

  if (a4)
  {
    v15 = 0;
    v35 = a6 - 1;
    v17 = a5 - 1;
    do
    {
      if ((int)v15 >= 0)
        v18 = v15;
      else
        v18 = v15 + 1;
      v38 = v15;
      v19 = 2 * (v15 & 1) + (v18 >> 1) - 1;
      if (v35 >= v18 >> 1)
        v20 = v18 >> 1;
      else
        v20 = v35;
      if (v35 >= v19)
        v21 = v19;
      else
        v21 = v35;
      if (a3)
      {
        v22 = 0;
        v23 = 0;
        v24 = a12 + (v20 & ~(v20 >> 31)) * a9;
        v25 = a12 + (v21 & ~(v21 >> 31)) * a9;
        v26 = (_BYTE *)(a10 + v38 * a7);
        do
        {
          if ((int)v23 >= 0)
            v27 = v23;
          else
            v27 = v23 + 1;
          v28 = (v22 & 2) + (v27 >> 1) - 1;
          if (v17 >= v27 >> 1)
            v29 = v27 >> 1;
          else
            v29 = v17;
          v30 = v29 & ~(v29 >> 31);
          if (v17 >= v28)
            v31 = v28;
          else
            v31 = v17;
          v32 = v31 & ~(v31 >> 31);
          v33 = *(unsigned __int16 *)(v24 + 2 * (2 * v30));
          v39[0] = *(_WORD *)(a11 + 2 * v23);
          v39[1] = (9 * v33
                  + *(unsigned __int16 *)(v25 + 2 * (2 * v32))
                  + 3
                  * (*(unsigned __int16 *)(v25 + 2 * (2 * v30))
                   + *(unsigned __int16 *)(v24 + 2 * (2 * v32)))
                  + 8) >> 4;
          v39[2] = (9 * *(unsigned __int16 *)(v24 + 2 * ((2 * v30) | 1u))
                  + *(unsigned __int16 *)(v25 + 2 * ((2 * v32) | 1u))
                  + 3
                  * (*(unsigned __int16 *)(v25 + 2 * ((2 * v30) | 1u))
                   + *(unsigned __int16 *)(v24 + 2 * ((2 * v32) | 1u)))
                  + 8) >> 4;
          Convert_one_YCC_10bit_to_RGB(a1, a2, v26, v39);
          ++v23;
          v26 += 3;
          v22 += 2;
        }
        while (a3 != v23);
      }
      v15 = v38 + 1;
      a11 += a8;
    }
    while (v38 + 1 != a4);
  }
}

void Convert_422x_to_RGB(int a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v14;
  int v15;
  char v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned __int16 v31[3];

  if (a4)
  {
    v14 = 0;
    v15 = a5 - 1;
    do
    {
      if (a3)
      {
        v17 = 0;
        v18 = 0;
        v19 = a11 + v14 * a8;
        v20 = (_BYTE *)(a9 + v14 * a6);
        do
        {
          if ((int)v18 >= 0)
            v21 = v18;
          else
            v21 = v18 + 1;
          v22 = (v17 & 2) + (v21 >> 1) - 1;
          if (v15 >= v21 >> 1)
            v23 = v21 >> 1;
          else
            v23 = v15;
          v24 = v23 & ~(v23 >> 31);
          if (v15 >= v22)
            v25 = v22;
          else
            v25 = v15;
          v26 = v25 & ~(v25 >> 31);
          v31[0] = *(_WORD *)(a10 + 2 * v18);
          v31[1] = (*(unsigned __int16 *)(v19 + 2 * (2 * v26))
                  + 3 * *(unsigned __int16 *)(v19 + 2 * (2 * v24))
                  + 2) >> 2;
          v31[2] = (*(unsigned __int16 *)(v19 + 2 * ((2 * v26) | 1u))
                  + 3 * *(unsigned __int16 *)(v19 + 2 * ((2 * v24) | 1u))
                  + 2) >> 2;
          Convert_one_YCC_10bit_to_RGB(a1, a2, v20, v31);
          ++v18;
          v20 += 3;
          v17 += 2;
        }
        while (a3 != v18);
      }
      ++v14;
      a10 += a7;
    }
    while (v14 != a4);
  }
}

void Convert_444x_to_RGB(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int16 *a9, uint64_t a10)
{
  uint64_t v13;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  unsigned __int16 *v18;
  uint64_t v19;
  unsigned __int16 v20;
  unsigned __int16 v26;
  int v27;

  if (a4)
  {
    v13 = 0;
    v15 = a10 + 2;
    do
    {
      if (a3)
      {
        v16 = (_BYTE *)(a8 + v13 * a5);
        v17 = v15;
        v18 = a9;
        v19 = a3;
        do
        {
          v20 = *v18++;
          v26 = v20;
          v27 = *(_DWORD *)(v17 - 2);
          Convert_one_YCC_10bit_to_RGB(a1, a2, v16, &v26);
          v16 += 3;
          v17 += 4;
          --v19;
        }
        while (v19);
      }
      ++v13;
      a9 = (unsigned __int16 *)((char *)a9 + a6);
      v15 += a7;
    }
    while (v13 != a4);
  }
}

void Convert_420_to_RGB(int a1, int a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8, float a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v16;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _BYTE *v27;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  uint64_t v34;
  int v35;
  int v37;
  uint64_t v40;
  _BYTE v41[3];

  if (a4)
  {
    v16 = 0;
    v37 = a6 - 1;
    v18 = a5 - 1;
    do
    {
      if ((int)v16 >= 0)
        v19 = v16;
      else
        v19 = v16 + 1;
      v40 = v16;
      v20 = 2 * (v16 & 1) + (v19 >> 1) - 1;
      if (v37 >= v19 >> 1)
        v21 = v19 >> 1;
      else
        v21 = v37;
      if (v37 >= v20)
        v22 = v20;
      else
        v22 = v37;
      if (a3)
      {
        v23 = 0;
        v24 = 0;
        v25 = a13 + (v21 & ~(v21 >> 31)) * a10;
        v26 = a13 + (v22 & ~(v22 >> 31)) * a10;
        v27 = (_BYTE *)(a11 + v40 * a7);
        do
        {
          if ((int)v24 >= 0)
            v28 = v24;
          else
            v28 = v24 + 1;
          v29 = (v23 & 2) + (v28 >> 1) - 1;
          if (v18 >= v28 >> 1)
            v30 = v28 >> 1;
          else
            v30 = v18;
          v31 = v30 & ~(v30 >> 31);
          if (v18 >= v29)
            v32 = v29;
          else
            v32 = v18;
          v33 = v32 & ~(v32 >> 31);
          v34 = 2 * v31;
          v35 = *(unsigned __int8 *)(v25 + v34);
          v41[0] = *(_BYTE *)(a12 + v24);
          v41[1] = (9 * v35
                  + *(unsigned __int8 *)(v26 + 2 * v33)
                  + 3 * (*(unsigned __int8 *)(v26 + v34) + *(unsigned __int8 *)(v25 + 2 * v33))
                  + 8) >> 4;
          v41[2] = (9 * *(unsigned __int8 *)(v25 + (v34 | 1))
                  + *(unsigned __int8 *)(v26 + ((2 * v33) | 1))
                  + 3
                  * (*(unsigned __int8 *)(v26 + (v34 | 1)) + *(unsigned __int8 *)(v25 + ((2 * v33) | 1)))
                  + 8) >> 4;
          a9 = Convert_one_YCC_to_RGB(a1, a2, v27, v41, a9);
          ++v24;
          v27 += 3;
          v23 += 2;
        }
        while (a3 != v24);
      }
      v16 = v40 + 1;
      a12 += a8;
    }
    while (v40 + 1 != a4);
  }
}

void Convert_422_to_RGB(int a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v15;
  int v16;
  char v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE *v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  unsigned __int8 *v27;
  unsigned __int8 *v28;
  _BYTE v33[3];

  if (a4)
  {
    v15 = 0;
    v16 = a5 - 1;
    do
    {
      if (a3)
      {
        v18 = 0;
        v19 = 0;
        v20 = a12 + v15 * a8;
        v21 = (_BYTE *)(a10 + v15 * a6);
        do
        {
          if ((int)v19 >= 0)
            v22 = v19;
          else
            v22 = v19 + 1;
          v23 = (v18 & 2) + (v22 >> 1) - 1;
          if (v16 >= v22 >> 1)
            v24 = v22 >> 1;
          else
            v24 = v16;
          v25 = v24 & ~(v24 >> 31);
          if (v16 >= v23)
            v26 = v23;
          else
            v26 = v16;
          v33[0] = *(_BYTE *)(a11 + v19);
          v27 = (unsigned __int8 *)(v20 + 2 * v25);
          v28 = (unsigned __int8 *)(v20 + 2 * (v26 & ~(v26 >> 31)));
          v33[1] = (*v28 + 3 * *v27 + 2) >> 2;
          v33[2] = (v28[1] + 3 * v27[1] + 2) >> 2;
          a9 = Convert_one_YCC_to_RGB(a1, a2, v21, v33, a9);
          ++v19;
          v21 += 3;
          v18 += 2;
        }
        while (a3 != v19);
      }
      ++v15;
      a11 += a7;
    }
    while (v15 != a4);
  }
}

unint64_t providerGetBytesAtPositionCallback_YCbYCr_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_YCbYCr_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_YCbYCr_surface_cold_2();
  if ((a3 & 3) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFFCLL;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_YCbYCr_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_21_0;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFFCLL;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

void providerReleaseCFInfoCallback(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

unint64_t providerGetBytesAtPositionCallback_CbYCrY_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_CbYCrY_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_CbYCrY_surface_cold_2();
  if ((a3 & 3) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFFCLL;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_CbYCrY_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_22_0;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFFCLL;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_YCbYCrFull_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_YCbYCrFull_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_YCbYCrFull_surface_cold_2();
  if ((a3 & 3) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFFCLL;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_YCbYCrFull_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_23;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFFCLL;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_CbYCrYFull_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_CbYCrYFull_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_CbYCrYFull_surface_cold_2();
  if ((a3 & 3) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFFCLL;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_CbYCrYFull_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_24_0;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFFCLL;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_AYCbCr8_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_AYCbCr8_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_AYCbCr8_surface_cold_2();
  if ((a3 & 3) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFFCLL;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_AYCbCr8_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_25_0;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFFCLL;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_2C08_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_2C08_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_2C08_surface_cold_2();
  if ((a3 & 3) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFFCLL;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_2C08_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_26;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFFCLL;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_2C16_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_2C16_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_2C16_surface_cold_2();
  if ((a3 & 7) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFF8;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_2C16_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_27;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFF8;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_2C0h_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_2C0h_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_2C0h_surface_cold_2();
  if ((a3 & 7) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFF8;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_2C0h_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_28;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFF8;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_2C0f_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_2C0f_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_2C0f_surface_cold_2();
  if ((a3 & 0xF) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFF0;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_2C0f_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_29;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFF0;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_1C08_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_1C08_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_1C08_surface_cold_2();
  if ((a3 & 3) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFFCLL;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_1C08_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_30;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFFCLL;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_1C16_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_1C16_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_1C16_surface_cold_2();
  if ((a3 & 7) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFF8;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_1C16_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_31;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFF8;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_1C0h_surface_lut(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  uint64_t v8;
  float *v9;
  _QWORD v11[9];
  _QWORD v12[6];
  uint64_t v13;
  float *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;

  if (!a1)
    providerGetBytesAtPositionCallback_1C0h_surface_lut_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_1C0h_surface_lut_cold_2();
  if ((a3 & 7) != 0)
    return 0;
  v6 = a4 & 0xFFFFFFFFFFFFFFF8;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 0;
  v13 = 0;
  v14 = (float *)&v13;
  v15 = 0x2000000000;
  v16 = 1065353216;
  v8 = MEMORY[0x1E0C809B0];
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 0x40000000;
  v12[2] = __providerGetBytesAtPositionCallback_1C0h_surface_lut_block_invoke;
  v12[3] = &unk_1E2EC60D8;
  v12[4] = &v17;
  v12[5] = &v13;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v12);
  v9 = v14;
  if (*((float *)v18 + 6) >= v14[6])
  {
    *((_DWORD *)v18 + 6) = 0;
    v9[6] = 1.0;
  }
  v11[0] = v8;
  v11[1] = 0x40000000;
  v11[2] = __providerGetBytesAtPositionCallback_1C0h_surface_lut_block_invoke_2;
  v11[3] = &unk_1E2EC6100;
  v11[6] = a3;
  v11[7] = a2;
  v11[8] = v6;
  v11[4] = &v17;
  v11[5] = &v13;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v11);
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  return v6;
}

unint64_t providerGetBytesAtPositionCallback_1C0h_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_1C0h_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_1C0h_surface_cold_2();
  if ((a3 & 7) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFF8;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_1C0h_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_34;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFF8;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_1C0f_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_1C0f_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_1C0f_surface_cold_2();
  if ((a3 & 0xF) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFF0;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_1C0f_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_35;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFF0;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_w30r_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_w30r_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_w30r_surface_cold_2();
  if ((a3 & 7) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFF8;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_w30r_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_36;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFF8;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_w40a_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_w40a_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_w40a_surface_cold_2();
  if ((a3 & 7) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFF8;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_w40a_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_37;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFF8;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_l10r_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_l10r_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_l10r_surface_cold_2();
  if ((a3 & 7) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFF8;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_l10r_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_38;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFF8;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

unint64_t providerGetBytesAtPositionCallback_A008_surface(__IOSurface *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _QWORD v6[7];

  if (!a1)
    providerGetBytesAtPositionCallback_A008_surface_cold_1();
  if (!a2)
    providerGetBytesAtPositionCallback_A008_surface_cold_2();
  if ((a3 & 3) != 0)
    return 0;
  v4 = a4 & 0xFFFFFFFFFFFFFFFCLL;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __providerGetBytesAtPositionCallback_A008_surface_block_invoke;
  v6[3] = &__block_descriptor_tmp_39;
  v6[4] = a3;
  v6[5] = a2;
  v6[6] = a4 & 0xFFFFFFFFFFFFFFFCLL;
  SurfaceApplyPlaneReadOnlyBlock(a1, (uint64_t)v6);
  return v4;
}

void *providerGetBytePointerCallback(__IOSurface *a1)
{
  if (!a1)
    providerGetBytePointerCallback_cold_1();
  if (IOSurfaceLock(a1, 1u, 0))
    return 0;
  else
    return IOSurfaceGetBaseAddress(a1);
}

uint64_t providerReleaseBytePointerCallback(__IOSurface *a1)
{
  if (!a1)
    providerReleaseBytePointerCallback_cold_1();
  return IOSurfaceUnlock(a1, 1u, 0);
}

float Convert_one_YCCh_to_RGB(int a1, _BYTE *a2, __int16 *a3)
{
  float v13;
  float v14;
  float v15;
  float result;

  _H0 = *a3;
  __asm { FCVT            S1, H0 }
  _H0 = a3[1];
  __asm { FCVT            S2, H0 }
  _H0 = a3[2];
  __asm { FCVT            S3, H0 }
  if (a1 == 601)
  {
    v13 = _S1 + (float)(_S3 * 1.402);
    v14 = (float)(_S1 + (float)(_S2 * -0.34414)) + (float)(_S3 * -0.71414);
    v15 = 1.772;
  }
  else
  {
    v13 = _S1 + (float)(_S3 * 1.5748);
    v14 = (float)(_S1 + (float)(_S2 * -0.18732)) + (float)(_S3 * -0.46812);
    v15 = 1.8556;
  }
  *a2 = llroundf(fmaxf(fminf(v13 * 255.0, 255.0), 0.0));
  a2[1] = llroundf(fmaxf(fminf(v14 * 255.0, 255.0), 0.0));
  result = fmaxf(fminf((float)(_S1 + (float)(_S2 * v15)) * 255.0, 255.0), 0.0);
  a2[2] = llroundf(result);
  return result;
}

float Convert_one_YCC_10bit_to_RGB(int a1, int a2, _BYTE *a3, unsigned __int16 *a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float result;

  v4 = (float)(*a4 >> 6);
  v5 = (float)(a4[1] >> 6) + -512.0;
  v6 = (float)(a4[2] >> 6) + -512.0;
  if (a1 == 118)
    v4 = v4 + -64.0;
  v7 = 1.1678;
  v8 = 1.0;
  if (a1 == 102)
    v7 = 1.0;
  else
    v8 = 1.1417;
  v9 = (float)((float)(v8 * flt_19249A0F8[a2 == 601]) * v6) + (float)(v4 * v7);
  v10 = (float)((float)(v8 * flt_19249A100[a2 == 601]) * v5) + (float)(v4 * v7);
  v11 = (float)((float)(v8 * flt_19249A110[a2 == 601]) * v5) + (float)(v4 * v7);
  v12 = v9 * 0.249266862;
  v13 = (float)(v10 + (float)((float)(v8 * flt_19249A108[a2 == 601]) * v6)) * 0.249266862;
  v14 = v11 * 0.249266862;
  *a3 = llroundf(fmaxf(fminf(v12, 255.0), 0.0));
  a3[1] = llroundf(fmaxf(fminf(v13, 255.0), 0.0));
  result = fmaxf(fminf(v14, 255.0), 0.0);
  a3[2] = llroundf(result);
  return result;
}

float Convert_one_YCC_to_RGB(int a1, int a2, _BYTE *a3, _BYTE *a4, float a5)
{
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float result;

  LOBYTE(a5) = *a4;
  v5 = (float)LODWORD(a5);
  LOBYTE(a5) = a4[1];
  v6 = (float)LODWORD(a5);
  LOBYTE(a5) = a4[2];
  v7 = (float)LODWORD(a5);
  if (a2 != 601)
  {
    if (a1 == 102)
    {
      v8 = v6 + -128.0;
      v13 = v7 + -128.0;
      v10 = (float)((float)(v7 + -128.0) * 1.581) + v5;
      v11 = (float)(v5 + (float)(v8 * -0.18806)) + (float)(v13 * -0.46997);
      v12 = 1.8629;
      goto LABEL_6;
    }
    v15 = v5 + -16.0;
    v16 = v6 + -128.0;
    v19 = v7 + -128.0;
    v10 = (float)((float)(v7 + -128.0) * 1.7927) + (float)(v15 * 1.1644);
    v11 = (float)((float)(v16 * -0.21325) + (float)(v15 * 1.1644)) + (float)(v19 * -0.53291);
    v18 = 2.1124;
LABEL_9:
    v14 = (float)(v16 * v18) + (float)(v15 * 1.1644);
    goto LABEL_10;
  }
  if (a1 != 102)
  {
    v15 = v5 + -16.0;
    v16 = v6 + -128.0;
    v17 = v7 + -128.0;
    v10 = (float)((float)(v7 + -128.0) * 1.596) + (float)(v15 * 1.1644);
    v11 = (float)((float)(v16 * -0.39176) + (float)(v15 * 1.1644)) + (float)(v17 * -0.81297);
    v18 = 2.0172;
    goto LABEL_9;
  }
  v8 = v6 + -128.0;
  v9 = v7 + -128.0;
  v10 = (float)((float)(v7 + -128.0) * 1.4075) + v5;
  v11 = (float)(v5 + (float)(v8 * -0.34549)) + (float)(v9 * -0.71695);
  v12 = 1.779;
LABEL_6:
  v14 = (float)(v8 * v12) + v5;
LABEL_10:
  *a3 = llroundf(fmaxf(fminf(v10, 255.0), 0.0));
  a3[1] = llroundf(fmaxf(fminf(v11, 255.0), 0.0));
  result = fmaxf(fminf(v14, 255.0), 0.0);
  a3[2] = llroundf(result);
  return result;
}

_QWORD *__providerGetBytesAtPositionCallback_2C08_surface_block_invoke(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;

  if (result[6])
  {
    v2 = 0;
    v3 = result[5];
    v4 = (_BYTE *)(a2 + result[4] / 2);
    do
    {
      v5 = v3 + v2;
      *(_BYTE *)v5 = *v4;
      *(_BYTE *)(v5 + 1) = v4[1];
      *(_WORD *)(v5 + 2) = -256;
      v2 += 4;
      v4 += 2;
    }
    while (v2 < result[6]);
  }
  return result;
}

_QWORD *__providerGetBytesAtPositionCallback_2C16_surface_block_invoke(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _WORD *v5;
  uint64_t v6;

  v2 = result[6];
  if (v2)
  {
    v3 = 0;
    v4 = result[5];
    v5 = (_WORD *)(a2 + 2 * (result[4] / 4));
    do
    {
      v6 = v4 + v3;
      *(_WORD *)v6 = *v5;
      *(_WORD *)(v6 + 2) = v5[1];
      *(_DWORD *)(v6 + 4) = -65536;
      v3 += 8;
      v5 += 2;
    }
    while (v3 < v2);
  }
  return result;
}

__int16 __providerGetBytesAtPositionCallback_2C0h_surface_block_invoke@<H0>(_QWORD *a1@<X0>, uint64_t a2@<X1>)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _WORD *v5;
  uint64_t v6;
  __int16 result;

  v2 = a1[6];
  if (v2)
  {
    v3 = 0;
    v4 = a1[5];
    v5 = (_WORD *)(a2 + 2 * (a1[4] / 4));
    do
    {
      v6 = v4 + v3;
      *(_WORD *)v6 = *v5;
      result = v5[1];
      *(_WORD *)(v6 + 2) = result;
      *(_DWORD *)(v6 + 4) = 1006632960;
      v3 += 8;
      v5 += 2;
    }
    while (v3 < v2);
  }
  return result;
}

_QWORD *__providerGetBytesAtPositionCallback_2C0f_surface_block_invoke(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  uint64_t v6;

  v2 = result[6];
  if (v2)
  {
    v3 = 0;
    v4 = result[5];
    v5 = (_DWORD *)(a2 + 4 * (result[4] / 8));
    do
    {
      v6 = v4 + v3;
      *(_DWORD *)v6 = *v5;
      *(_DWORD *)(v6 + 4) = v5[1];
      *(_QWORD *)(v6 + 8) = 0x3F80000000000000;
      v3 += 16;
      v5 += 2;
    }
    while (v3 < v2);
  }
  return result;
}

_QWORD *__providerGetBytesAtPositionCallback_1C08_surface_block_invoke(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  char v6;

  if (result[6])
  {
    v2 = 0;
    v3 = result[5];
    v4 = (char *)(a2 + result[4] / 4);
    do
    {
      v5 = v3 + v2;
      v6 = *v4++;
      *(_BYTE *)v5 = v6;
      *(_WORD *)(v5 + 1) = 0;
      *(_BYTE *)(v5 + 3) = -1;
      v2 += 4;
    }
    while (v2 < result[6]);
  }
  return result;
}

_QWORD *__providerGetBytesAtPositionCallback_1C16_surface_block_invoke(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  __int16 *v5;
  __int16 v6;
  uint64_t v7;

  v2 = result[6];
  if (v2)
  {
    v3 = 0;
    v4 = result[5];
    v5 = (__int16 *)(a2 + 2 * (result[4] / 8));
    do
    {
      v6 = *v5++;
      v7 = v4 + v3;
      *(_WORD *)v7 = v6;
      *(_DWORD *)(v7 + 2) = 0;
      *(_WORD *)(v7 + 6) = -1;
      v3 += 8;
    }
    while (v3 < v2);
  }
  return result;
}

uint64_t __providerGetBytesAtPositionCallback_1C0h_surface_lut_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v14;
  uint64_t v15;

  if (a5)
  {
    v6 = 0;
    while (!a4)
    {
LABEL_13:
      ++v6;
      a2 += a6;
      if (v6 == a5)
        return result;
    }
    v7 = 0;
    while (1)
    {
      _H0 = *(_WORD *)(a2 + 2 * v7);
      __asm { FCVT            S0, H0 }
      v14 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
      if (v7 | v6)
      {
        if (*(float *)(v14 + 24) > _S0)
          *(float *)(v14 + 24) = _S0;
        v15 = *(_QWORD *)(*(_QWORD *)(result + 40) + 8);
        if (*(float *)(v15 + 24) >= _S0)
          goto LABEL_12;
      }
      else
      {
        *(float *)(v14 + 24) = _S0;
        v15 = *(_QWORD *)(*(_QWORD *)(result + 40) + 8);
      }
      *(float *)(v15 + 24) = _S0;
LABEL_12:
      if (a4 == ++v7)
        goto LABEL_13;
    }
  }
  return result;
}

_QWORD *__providerGetBytesAtPositionCallback_1C0h_surface_lut_block_invoke_2(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  __int16 *v5;
  __int16 v6;
  float v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;

  v2 = result[8];
  if (v2)
  {
    v3 = 0;
    v4 = result[7];
    v5 = (__int16 *)(a2 + 2 * (result[6] / 8));
    do
    {
      v6 = *v5++;
      _H1 = v6;
      __asm { FCVT            S1, H1 }
      v13 = *(float *)(*(_QWORD *)(result[4] + 8) + 24);
      v14 = llroundf((float)((float)(_S1 - v13) / (float)(*(float *)(*(_QWORD *)(result[5] + 8) + 24) - v13)) * 255.0);
      v15 = v14 & ~(v14 >> 63);
      if (v15 >= 0xFF)
        v15 = 255;
      v16 = (char *)&parulaColorMap + 8 * v15;
      v17 = v4 + v3;
      *(_DWORD *)v17 = *(_DWORD *)v16;
      *(_WORD *)(v17 + 4) = *((_WORD *)v16 + 2);
      *(_WORD *)(v17 + 6) = 15360;
      v3 += 8;
    }
    while (v3 < v2);
  }
  return result;
}

_QWORD *__providerGetBytesAtPositionCallback_1C0h_surface_block_invoke(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  __int16 *v5;
  __int16 v6;
  uint64_t v7;

  v2 = result[6];
  if (v2)
  {
    v3 = 0;
    v4 = result[5];
    v5 = (__int16 *)(a2 + 2 * (result[4] / 8));
    do
    {
      v6 = *v5++;
      v7 = v4 + v3;
      *(_WORD *)v7 = v6;
      *(_DWORD *)(v7 + 2) = 0;
      *(_WORD *)(v7 + 6) = 15360;
      v3 += 8;
    }
    while (v3 < v2);
  }
  return result;
}

float __providerGetBytesAtPositionCallback_1C0f_surface_block_invoke(_QWORD *a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  float *v5;
  float v6;
  float result;
  float *v8;

  v2 = a1[6];
  if (v2)
  {
    v3 = 0;
    v4 = a1[5];
    v5 = (float *)(a2 + 4 * (a1[4] / 16));
    do
    {
      v6 = *v5++;
      result = v6;
      v8 = (float *)(v4 + v3);
      *v8 = v6;
      v8[1] = 0.0;
      v8[2] = 0.0;
      v8[3] = 1.0;
      v3 += 16;
    }
    while (v3 < v2);
  }
  return result;
}

_QWORD *__providerGetBytesAtPositionCallback_w30r_surface_block_invoke(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  _WORD *v7;

  v2 = result[6];
  if (v2)
  {
    v3 = 0;
    v4 = result[5];
    v5 = (unsigned int *)(a2 + 4 * (result[4] / 8));
    do
    {
      v6 = *v5++;
      v7 = (_WORD *)(v4 + v3);
      _S1 = (float)((float)((v6 >> 20) & 0x3FF) + -384.0) / 510.0;
      __asm { FCVT            H1, S1 }
      *v7 = LOWORD(_S1);
      _S2 = (float)((float)((v6 >> 10) & 0x3FF) + -384.0) / 510.0;
      __asm { FCVT            H2, S2 }
      v7[1] = LOWORD(_S2);
      _S1 = (float)((float)(v6 & 0x3FF) + -384.0) / 510.0;
      __asm { FCVT            H1, S1 }
      v7[2] = LOWORD(_S1);
      v7[3] = 15360;
      v3 += 8;
    }
    while (v3 < v2);
  }
  return result;
}

_QWORD *__providerGetBytesAtPositionCallback_w40a_surface_block_invoke(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _WORD *v7;

  v2 = result[6];
  if (v2)
  {
    v3 = 0;
    v4 = result[5];
    v5 = a2 + ((result[4] + ((uint64_t)result[4] < 0 ? 7uLL : 0)) & 0xFFFFFFFFFFFFFFF8);
    do
    {
      v6 = *(_QWORD *)(v5 + v3);
      v7 = (_WORD *)(v4 + v3);
      _S2 = (float)((float)((v6 >> 38) & 0x3FF) + -384.0) / 510.0;
      __asm { FCVT            H2, S2 }
      *v7 = LOWORD(_S2);
      _S3 = (float)((float)(v6 >> 22) + -384.0) / 510.0;
      __asm { FCVT            H3, S3 }
      v7[1] = LOWORD(_S3);
      _S3 = (float)((float)((unsigned __int16)v6 >> 6) + -384.0) / 510.0;
      __asm { FCVT            H3, S3 }
      _S2 = (float)((float)(v6 >> 54) + -384.0) / 510.0;
      __asm
      {
        FCVT            H2, S2
        FCVT            S2, H2
      }
      v7[2] = LOWORD(_S3);
      _S2 = fminf(fmaxf(_S2, 0.0), 1.0);
      __asm { FCVT            H2, S2 }
      v7[3] = LOWORD(_S2);
      v3 += 8;
    }
    while (v3 < v2);
  }
  return result;
}

_QWORD *__providerGetBytesAtPositionCallback_l10r_surface_block_invoke(_QWORD *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  float32x4_t v7;

  v2 = result[6];
  if (v2)
  {
    v3 = 0;
    v4 = result[5];
    v5 = (unsigned int *)(a2 + 4 * (result[4] / 8));
    do
    {
      v6 = *v5++;
      *(float32x2_t *)v7.f32 = vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v6), (uint32x2_t)0xFFFFFFF6FFFFFFECLL), (int8x8_t)0x300000003));
      v7.f32[2] = (float)(v6 & 0x3FF);
      v7.i32[3] = v7.i32[0];
      *(float16x4_t *)(v4 + v3) = vcvt_f16_f32(vdivq_f32(v7, (float32x4_t)xmmword_19248E070));
      v3 += 8;
    }
    while (v3 < v2);
  }
  return result;
}

double InvertMatrix(double *a1, double *a2)
{
  double result;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;

  result = *a1;
  v3 = a1[1];
  v5 = a1[2];
  v4 = a1[3];
  v6 = a1[4];
  v7 = a1[5];
  v8 = a1[6];
  v9 = a1[7];
  v10 = a1[8];
  v11 = -(*a1 * v7);
  v12 = v5 * -(v8 * v6) + *a1 * v6 * v10 + v5 * v4 * v9 + -(v4 * v3) * v10 + v3 * v7 * v8 + v11 * v9;
  if (v12 != 0.0)
  {
    *a2 = (v6 * v10 - v9 * v7) / v12;
    a2[1] = (v9 * v5 - v3 * v10) / v12;
    a2[2] = (v3 * v7 - v6 * v5) / v12;
    a2[3] = (v10 * -v4 + v8 * v7) / v12;
    a2[4] = (v5 * -v8 + result * v10) / v12;
    a2[5] = (v11 + v4 * v5) / v12;
    a2[6] = (v4 * v9 - v8 * v6) / v12;
    a2[7] = (v9 * -result + v8 * v3) / v12;
    result = (result * v6 - v4 * v3) / v12;
    a2[8] = result;
  }
  return result;
}

double GetAdaptationMatrix(double *a1, double *a2, double *a3)
{
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v17;
  __int128 v18;
  uint64_t v19;
  double v20;
  __int128 v21;
  uint64_t v22;
  double v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v4 = a1[1];
  v5 = a1[2];
  v6 = v4 * 0.0;
  v7 = *a1 + v4 * 0.0 + v5 * 0.0;
  v8 = v4 + *a1 * 0.0 + v5 * 0.0;
  v9 = v5 + v6 + *a1 * 0.0;
  v10 = a2[1];
  v11 = a2[2];
  v12 = v10 * 0.0;
  v13 = *a2 + v10 * 0.0 + v11 * 0.0;
  v14 = v10 + *a2 * 0.0 + v11 * 0.0;
  v15 = v11 + v12 + *a2 * 0.0;
  v19 = 0;
  v22 = 0;
  v21 = 0u;
  v18 = 0u;
  v17 = v13 / v7;
  v20 = v14 / v8;
  v23 = v15 / v9;
  MatrixMatrix(GetAdaptationMatrix_identity_mtx, &v17, a3);
  return MatrixMatrix(a3, GetAdaptationMatrix_identity_mtx, a3);
}

void phosphors_to_rgbxyz_matrix(double *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  double v10;
  int64x2_t v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  double v34;
  double v35[4];

  v35[3] = *(double *)MEMORY[0x1E0C80C00];
  v10 = ((a4 - a6) * a3 - (a2 - a6) * a5 + (a2 - a4) * a7) * a9;
  if (v10 >= 0.0001 || v10 <= -0.0001)
  {
    v14 = ((a4 - a6) * a9 - (a8 - a6) * a5 + (a8 - a4) * a7) * a3 / v10;
    v15 = -(a5 * ((a2 - a6) * a9 - (a8 - a6) * a3 + (a8 - a2) * a7)) / v10;
    v16 = ((a2 - a4) * a9 - (a8 - a4) * a3 + (a8 - a2) * a5) * a7 / v10;
    v17 = v14 * a2 / a3;
    v18 = ((1.0 - a2) / a3 + -1.0) * v14;
    v19 = v15 * a4 / a5;
    v20 = ((1.0 - a4) / a5 + -1.0) * v15;
    v29 = ((1.0 - a6) / a7 + -1.0) * v16;
    v35[0] = a8 / a9;
    v35[1] = 1.0;
    v35[2] = (1.0 - a8 - a9) / a9;
    v34 = 0.0;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v21 = v16 * a6 / a7;
    GetAdaptationMatrix(v35, d50, (double *)&v30);
    v13 = v14 * *((double *)&v30 + 1) + v17 * *(double *)&v30 + v18 * *(double *)&v31;
    v22 = v14 * *(double *)&v32 + v17 * *((double *)&v31 + 1) + v18 * *((double *)&v32 + 1);
    v23 = v34;
    v24 = v14 * *((double *)&v33 + 1) + v17 * *(double *)&v33 + v18 * v34;
    v12 = v15 * *((double *)&v30 + 1) + v19 * *(double *)&v30 + v20 * *(double *)&v31;
    v25 = v15 * *(double *)&v32 + v19 * *((double *)&v31 + 1) + v20 * *((double *)&v32 + 1);
    v26 = v15 * *((double *)&v33 + 1) + v19 * *(double *)&v33 + v20 * v34;
    v27 = v16 * *(double *)&v32 + v21 * *((double *)&v31 + 1) + v29 * *((double *)&v32 + 1);
    v28 = v16 * *((double *)&v33 + 1) + v21 * *(double *)&v33;
    a1[2] = v16 * *((double *)&v30 + 1) + v21 * *(double *)&v30 + v29 * *(double *)&v31;
    a1[3] = v22;
    a1[4] = v25;
    a1[5] = v27;
    a1[6] = v24;
    a1[7] = v26;
    a1[8] = v28 + v29 * v23;
  }
  else
  {
    v11 = vdupq_n_s64(0x7FF8000000000000uLL);
    a1[8] = NAN;
    *((int64x2_t *)a1 + 2) = v11;
    *((int64x2_t *)a1 + 3) = v11;
    *((int64x2_t *)a1 + 1) = v11;
    v12 = NAN;
    v13 = NAN;
  }
  *a1 = v13;
  a1[1] = v12;
}

double tempTint_to_XYZ(uint64_t a1, double a2, double a3)
{
  double result;
  double v5;
  double v6;
  double v7;

  v6 = 0.0;
  v7 = 0.0;
  CI_TempTint_to_xy(&v7, &v6, a2, a3);
  result = v6;
  if (v6 >= 1.0e-20)
  {
    v5 = v7;
    *(double *)a1 = v7 / v6;
    *(_QWORD *)(a1 + 8) = 0x3FF0000000000000;
    result = (1.0 - v5) / result + -1.0;
    *(double *)(a1 + 16) = result;
  }
  return result;
}

double CI_TempTint_to_xy(double *a1, double *a2, double a3, double a4)
{
  uint64_t v4;
  double v5;
  double v6;
  uint64_t v7;
  double v8;
  double *v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double result;

  v4 = 0x20u;
  v5 = 1000000.0 / a3;
  do
  {
    v6 = *(double *)((char *)&kTempTable + v4);
    v7 = v4 + 32;
    if (v4 == 960)
      break;
    v4 += 32;
  }
  while (v5 >= v6);
  v8 = a4 * -0.000333333333;
  v9 = (double *)((char *)&kTempTable + v7);
  v10 = (v6 - v5) / (v6 - *(double *)((char *)&kTempTable + v7 - 64));
  v11 = *(v9 - 3) * (1.0 - v10) + *(v9 - 7) * v10;
  v12 = *(double *)((char *)&kTempTable + v7 - 40);
  v13 = (1.0 - v10) * *(v9 - 2) + *(v9 - 6) * v10;
  v14 = *(double *)((char *)&kTempTable + v7 - 8);
  v15 = sqrt(v12 * v12 + 1.0);
  v16 = sqrt(v14 * v14 + 1.0);
  v17 = (1.0 - v10) * (1.0 / v16) + 1.0 / v15 * v10;
  v18 = (1.0 - v10) * (v14 / v16) + v12 / v15 * v10;
  v19 = sqrt(v18 * v18 + v17 * v17);
  v20 = v11 + v17 / v19 * v8;
  v21 = v13 + v18 / v19 * v8;
  v22 = v20 * 1.5;
  v23 = v20 + v21 * -4.0 + 2.0;
  *a1 = v22 / v23;
  result = v21 / v23;
  *a2 = result;
  return result;
}

double tempTint_to_matrix(uint64_t a1, double a2, double a3)
{
  _OWORD v5[4];
  uint64_t v6;
  _OWORD v7[4];
  uint64_t v8;
  _OWORD v9[4];
  uint64_t v10;
  double v11[4];

  v11[3] = *(double *)MEMORY[0x1E0C80C00];
  memset(v11, 0, 24);
  tempTint_to_XYZ((uint64_t)v11, a2, a3);
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  GetAdaptationMatrix(v11, d50, (double *)v9);
  v8 = 0;
  memset(v7, 0, sizeof(v7));
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  phosphors_to_rgbxyz_matrix((double *)v7, 0.63, 0.34, 0.295, 0.605, 0.155, 0.077, 0.3127, 0.329);
  InvertMatrix((double *)v7, (double *)v5);
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0x3FF0000000000000;
  *(_QWORD *)a1 = 0x3FF0000000000000;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0x3FF0000000000000;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  MatrixMatrix((double *)a1, (double *)v7, (double *)a1);
  MatrixMatrix((double *)a1, (double *)v9, (double *)a1);
  return MatrixMatrix((double *)a1, (double *)v5, (double *)a1);
}

double CI_GenericRGBLinear_to_TempTint(float *a1, double *a2, double *a3)
{
  double v5;
  double v6;
  double v7;
  double result;
  double v9;
  double v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  double v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v5 = *a1;
  v6 = a1[1];
  v7 = a1[2];
  v15 = 0.0;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  phosphors_to_rgbxyz_matrix((double *)&v11, 0.63, 0.34, 0.295, 0.605, 0.155, 0.077, 0.3127, 0.329);
  result = *((double *)&v11 + 1) * v6 + v5 * *(double *)&v11 + v7 * *(double *)&v12;
  v9 = *(double *)&v13 * v6 + v5 * *((double *)&v12 + 1) + v7 * *((double *)&v13 + 1);
  v10 = *((double *)&v14 + 1) * v6 + v5 * *(double *)&v14 + v7 * v15;
  if (result >= 1.0e-20 || v9 >= 1.0e-20 || v10 >= 1.0e-20)
    return CI_xy_to_TempTint(a2, a3, result / (result + v9 + v10), v9 / (result + v9 + v10));
  *a3 = NAN;
  *a2 = NAN;
  return result;
}

double CI_xy_to_TempTint(double *a1, double *a2, double a3, double a4)
{
  double v4;
  double v5;
  double v6;
  double v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  uint64_t v19;
  double v20;
  double v21;
  double *v22;
  double v23;
  double v24;
  double v25;
  double result;

  v4 = 1.5 - a3 + a4 * 6.0;
  v5 = (a3 + a3) / v4;
  v6 = a4 * 3.0 / v4;
  v7 = 0.0;
  v8 = 0x100000000;
  v9 = 0x38u;
  v10 = 0.0;
  v11 = 0.0;
  do
  {
    v12 = v11;
    v13 = v10;
    v14 = v7;
    v15 = *(double *)((char *)&kTempTable + v9);
    v16 = sqrt(v15 * v15 + 1.0);
    v7 = 1.0 / v16;
    v10 = v15 / v16;
    v18 = *(double *)((char *)&kTempTable + v9 - 16);
    v17 = *(double *)((char *)&kTempTable + v9 - 8);
    v11 = (v6 - v17) * v7 - (v5 - v18) * v10;
    v8 -= 0x100000000;
    v19 = v9 + 32;
    if (v9 == 984)
      break;
    v9 += 32;
  }
  while (v11 > 0.0);
  if (v8)
  {
    v20 = 0.0;
    if (v11 <= 0.0)
      v20 = (v6 - v17) * v7 - (v5 - v18) * v10;
    v21 = -v20 / (v12 - v20);
  }
  else
  {
    v21 = 0.0;
  }
  v22 = (double *)((char *)&kTempTable + (-v8 >> 27));
  *a1 = 1000000.0 / ((1.0 - v21) * *(double *)((char *)&kTempTable + v19 - 56) + *v22 * v21);
  v23 = v14 * v21 + v7 * (1.0 - v21);
  v24 = v13 * v21 + v10 * (1.0 - v21);
  v25 = sqrt(v24 * v24 + v23 * v23);
  result = (v24 / v25 * (v6 - (v17 * (1.0 - v21) + v22[2] * v21))
          + (v5 - (v18 * (1.0 - v21) + v22[1] * v21)) * (v23 / v25))
         * -3000.0;
  *a2 = result;
  return result;
}

uint64_t wrapGLIsUsable()
{
  return 1;
}

uint64_t wrapGLIsAccelerated()
{
  return 1;
}

uint64_t wrapGetCurrentContext()
{
  return objc_msgSend(MEMORY[0x1E0CD0958], "currentContext");
}

uint64_t wrapSetCurrentContext(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0CD0958], "setCurrentContext:", a1);
}

uint64_t wrapGetContextAPI(void *a1)
{
  if (a1)
    return objc_msgSend(a1, "API");
  else
    return 0xFFFFFFFFLL;
}

uint64_t wrapGetFormatInfo(int a1, int a2)
{
  uint64_t result;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  unint64_t v8;
  uint64_t v9;

  result = 0x190600001906;
  switch(a2)
  {
    case 1:
      return 0x80E100001908;
    case 2:
      return 0x190800001908;
    case 3:
      return 0x19080000805BLL;
    case 4:
      v4 = a1 == 3;
      v5 = 0x190800001908;
      v6 = 0x19080000881ALL;
      goto LABEL_17;
    case 5:
      return 0x190800008814;
    case 6:
      v7 = a1 == 3;
      v8 = 0x80E100008C43;
      goto LABEL_39;
    case 7:
      v7 = a1 == 3;
      v9 = 35907;
      goto LABEL_38;
    case 8:
      return 0x93F2000093F2;
    case 9:
      return result;
    case 10:
      return 0x190900001909;
    case 11:
      return 0x190A0000190ALL;
    case 12:
      if (a1 == 3)
        return 0x190300008229;
      else
        return 0x190300001903;
    case 14:
      v6 = 0x19030000822DLL;
      v4 = a1 == 3;
      v5 = 0x190300001903;
LABEL_17:
      if (v4)
        return v6;
      else
        return v5;
    case 15:
      if (a1 == 3)
        return 0x19030000822ELL;
      else
        return 0x190300001903;
    case 16:
      if (a1 == 3)
        return 0x82270000822BLL;
      else
        return 0x822700008227;
    case 18:
      if (a1 == 3)
        return 0x82270000822FLL;
      else
        return 0x822700008227;
    case 19:
      if (a1 == 3)
        return 0x822700008230;
      else
        return 0x822700008227;
    case 24:
      return 0x8A1F00001907;
    case 25:
      return 0x8A1F00001907;
    case 26:
      return 0x93FB00001907;
    case 28:
      v7 = a1 == 3;
      v9 = 32857;
LABEL_38:
      v8 = v9 & 0xFFFF0000FFFFFFFFLL | 0x190800000000;
LABEL_39:
      if (v7)
        result = v8;
      else
        result = 0;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

void *wrapEAGLContextCreate(int a1, void *a2)
{
  id v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  v4 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  v5 = *MEMORY[0x1E0C9AE50];
  objc_msgSend(v4, "setObject:forKey:", *MEMORY[0x1E0C9AE50], *MEMORY[0x1E0CD0D20]);
  objc_msgSend(v4, "setObject:forKey:", v5, *MEMORY[0x1E0CD0D28]);
  objc_msgSend(v4, "setObject:forKey:", v5, *MEMORY[0x1E0CD0D38]);
  v6 = objc_msgSend(a2, "sharegroup");
  if (v6)
    objc_msgSend(v4, "setObject:forKey:", v6, *MEMORY[0x1E0CD0D30]);
  v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CD0958]), "initWithAPI:properties:", a1, v4);

  objc_msgSend(v7, "setDebugLabel:", CFSTR("CI Internal Context"));
  return v7;
}

void *wrapEAGLContextSetParameter(void *result, uint64_t a2, int a3)
{
  int v3;

  v3 = a3;
  if (result)
    return (void *)objc_msgSend(result, "setParameter:to:", a2, &v3);
  return result;
}

void *wrapEAGLContextSetBackgroundEnabled(void *result, int a2)
{
  int v2;

  if (result)
  {
    v2 = a2;
    return (void *)objc_msgSend(result, "setParameter:to:", 321, &v2);
  }
  return result;
}

void *wrapEAGLContextRetain(void *a1)
{
  id v2;

  if (a1)
    v2 = a1;
  return a1;
}

void wrapEAGLContextRelease(id a1)
{
  if (a1)

}

uint64_t wrapEAGLContextTexImageIOSurface(void *a1, GLenum a2, uint64_t a3, uint64_t a4, GLint a5, signed int a6, signed int a7, __IOSurface *a8, unsigned int a9)
{
  GLenum v10;
  unsigned int v13;
  unsigned int v14;
  uint64_t v17;
  size_t BytesPerRowOfPlane;
  size_t ElementWidthOfPlane;
  uint64_t v21;
  char *BaseAddressOfPlane;
  size_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  char *v29;
  void *v30;
  void *v31;
  id v32;
  GLenum v33;
  char *pixels;
  NSObject *v36;
  uint64_t v37;
  char *__src;
  GLenum v39;
  unsigned int v40;
  GLenum v41;
  size_t BytesPerElementOfPlane;
  GLenum v43;
  _QWORD v44[2];
  void (*v45)(uint64_t);
  void *v46;
  void *v47;

  if (!a1)
    return 0;
  v10 = a7;
  v13 = a4;
  v14 = a3;
  BYTE4(v37) = 0;
  LODWORD(v37) = a9;
  if ((objc_msgSend(a1, "texImageIOSurface:target:internalFormat:width:height:format:type:plane:invert:", a8, a2, a5, a3, a4, a6, a7, v37) & 1) == 0)
  {
    v41 = a2;
    BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(a8, a9);
    BytesPerElementOfPlane = IOSurfaceGetBytesPerElementOfPlane(a8, a9);
    ElementWidthOfPlane = IOSurfaceGetElementWidthOfPlane(a8, a9);
    if (IOSurfaceGetElementHeightOfPlane(a8, a9) == 1 && ElementWidthOfPlane - 3 >= 0xFFFFFFFFFFFFFFFELL)
    {
      v40 = v13;
      v21 = v14 % ElementWidthOfPlane ? v14 + 1 : v14;
      BaseAddressOfPlane = (char *)IOSurfaceGetBaseAddressOfPlane(a8, a9);
      if (BaseAddressOfPlane)
      {
        __src = BaseAddressOfPlane;
        v39 = a6;
        v23 = BytesPerElementOfPlane / ElementWidthOfPlane * v21;
        v24 = (v23 + 3) & 0xFFFFFFFFFFFFFFFCLL;
        if (BytesPerRowOfPlane == v24)
        {
          v25 = 0;
          goto LABEL_20;
        }
        v43 = v10;
        v26 = v40;
        v27 = (char *)malloc_type_malloc(v24 * v40, 0xE689878FuLL);
        if (v27)
        {
          v25 = v27;
          if (v40)
          {
            v28 = 0;
            v29 = __src;
            do
            {
              memcpy(&v25[v24 * v28++], v29, v23);
              v29 += BytesPerRowOfPlane;
              --v26;
            }
            while (v26);
          }
          v10 = v43;
LABEL_20:
          v30 = (void *)objc_msgSend(MEMORY[0x1E0CD0958], "currentContext");
          v31 = v30;
          if (v30)
            v32 = v30;
          v17 = objc_msgSend(MEMORY[0x1E0CD0958], "setCurrentContext:", a1);
          v44[0] = MEMORY[0x1E0C809B0];
          v44[1] = 3221225472;
          v45 = __wrapEAGLContextTexImageIOSurface_block_invoke;
          v46 = &__block_descriptor_40_e5_v8__0l;
          v47 = v31;
          if ((_DWORD)v17)
          {
            if (a5 == 35906)
              v33 = 35906;
            else
              v33 = v39;
            pixels = __src;
            if (v25)
              pixels = v25;
            glTexImage2D(v41, 0, a5, v14, v40, 0, v33, v10, pixels);
          }
          else
          {
            v36 = ci_logger_render();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            {
              wrapEAGLContextTexImageIOSurface_cold_1((uint64_t)a1, v36);
              if (!v25)
                goto LABEL_34;
              goto LABEL_33;
            }
          }
          if (!v25)
          {
LABEL_34:
            v45((uint64_t)v44);
            return v17;
          }
LABEL_33:
          free(v25);
          goto LABEL_34;
        }
      }
    }
    return 0;
  }
  return 1;
}

void sub_1923DC130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void (*a18)(char *))
{
  a18(&a16);
  _Unwind_Resume(a1);
}

void __wrapEAGLContextTexImageIOSurface_block_invoke(uint64_t a1)
{
  void *v2;

  objc_msgSend(MEMORY[0x1E0CD0958], "setCurrentContext:", *(_QWORD *)(a1 + 32));
  v2 = *(void **)(a1 + 32);
  if (v2)

}

uint64_t wrapIsA9_or_higher()
{
  if (wrapIsA9_or_higher_didCheck != -1)
    dispatch_once(&wrapIsA9_or_higher_didCheck, &__block_literal_global_83);
  return wrapIsA9_or_higher_is_A9_gpu;
}

uint64_t __wrapIsA9_or_higher_block_invoke()
{
  uint64_t result;
  void *v1;
  void *v2;
  void *v3;
  id v4;
  int v5;
  GLint params;
  _QWORD v7[2];
  void (*v8)(uint64_t);
  void *v9;
  void *v10;

  result = objc_msgSend(objc_alloc(MEMORY[0x1E0CD0958]), "initWithAPI:", 3);
  if (result)
  {
    v1 = (void *)result;
    v2 = (void *)objc_msgSend(MEMORY[0x1E0CD0958], "currentContext");
    v3 = v2;
    if (v2)
      v4 = v2;
    v5 = objc_msgSend(MEMORY[0x1E0CD0958], "setCurrentContext:", v1);
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v8 = __wrapIsA9_or_higher_block_invoke_2;
    v9 = &__block_descriptor_40_e5_v8__0l;
    v10 = v3;
    if (v5)
    {
      params = 0;
      glGetIntegerv(0xD33u, &params);
      wrapIsA9_or_higher_is_A9_gpu = params >= 0x4000;
    }

    return ((uint64_t (*)(_QWORD *))v8)(v7);
  }
  return result;
}

void sub_1923DC29C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);
  _Unwind_Resume(a1);
}

void __wrapIsA9_or_higher_block_invoke_2(uint64_t a1)
{
  void *v2;

  objc_msgSend(MEMORY[0x1E0CD0958], "setCurrentContext:", *(_QWORD *)(a1 + 32));
  v2 = *(void **)(a1 + 32);
  if (v2)

}

uint64_t wrapGetMacroContext@<X0>(void *a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;

  bzero(a2, 0x2C8uLL);
  result = objc_msgSend(a1, "getMacroContextPrivate");
  if (result)
  {
    a2[1] = result;
    a2[2] = _ActiveTexture;
    a2[3] = _AttachShader;
    a2[4] = _Begin;
    a2[5] = _BindAttribLocation;
    a2[6] = _BindBuffer;
    a2[7] = _BindFramebuffer;
    a2[8] = _BindRenderbuffer;
    a2[9] = _BindTexture;
    a2[10] = _BlendColor;
    a2[11] = _BlendEquationSeparate;
    a2[12] = _BlendFunc;
    a2[13] = _BlendFuncSeparate;
    a2[14] = _CheckFramebufferStatus;
    a2[15] = _ClearColor;
    a2[16] = _ClientWaitSync;
    a2[17] = _CompileShader;
    a2[18] = _CopyTexImage2D;
    a2[19] = _CopyTexSubImage2D;
    a2[20] = _CreateProgram;
    a2[21] = _CreateShader;
    a2[22] = _DeleteFramebuffers;
    a2[23] = _DeleteProgram;
    a2[24] = _DeleteRenderbuffers;
    a2[25] = _DeleteShader;
    a2[26] = _DeleteSync;
    a2[27] = _DeleteTextures;
    a2[28] = _DepthMask;
    a2[29] = _Disable;
    a2[30] = _DisableVertexAttribArray;
    a2[31] = _DrawArrays;
    a2[32] = _DrawBuffers;
    a2[33] = _Enable;
    a2[34] = _EnableVertexAttribArray;
    a2[35] = _End;
    a2[36] = _FenceSync;
    a2[37] = _Finish;
    a2[38] = _Flush;
    a2[39] = _FinishRenderAPPLE;
    a2[40] = _FlushRenderAPPLE;
    a2[41] = _FramebufferRenderbuffer;
    a2[42] = _FramebufferTexture2D;
    a2[43] = _GenFramebuffers;
    a2[44] = _GenRenderbuffers;
    a2[45] = _GenTextures;
    a2[46] = _GetBooleanv;
    a2[47] = _GetDoublev;
    a2[48] = _GetError;
    a2[49] = _GetFramebufferAttachmentParameteriv;
    a2[50] = _GetIntegerv;
    a2[51] = _GetProgramInfoLog;
    a2[52] = _GetProgramiv;
    a2[53] = _GetRenderbufferParameteriv;
    a2[54] = _GetShaderInfoLog;
    a2[55] = _GetShaderiv;
    a2[56] = _GetString;
    a2[57] = _GetTexImage;
    a2[58] = _GetTexLevelParameteriv;
    a2[59] = _GetUniformLocation;
    a2[60] = _GetVertexAttribPointerv;
    a2[61] = _GetVertexAttribiv;
    a2[62] = _InsertEventMarkerEXT;
    a2[63] = _IsEnabled;
    a2[64] = _IsFramebuffer;
    a2[65] = _IsTexture;
    a2[66] = _LinkProgram;
    a2[67] = _MultiTexCoord2f;
    a2[68] = _PixelStorei;
    a2[69] = _ReadPixels;
    a2[70] = _RenderbufferStorage;
    a2[71] = _Scissor;
    a2[72] = _ShaderSource;
    a2[73] = _TexImage2D;
    a2[74] = _TexParameterfv;
    a2[75] = _TexParameteri;
    a2[76] = _Uniform1f;
    a2[77] = _Uniform1i;
    a2[78] = _Uniform2f;
    a2[79] = _Uniform3f;
    a2[80] = _Uniform4f;
    a2[81] = _UniformMatrix2fv;
    a2[82] = _UniformMatrix3fv;
    a2[83] = _UniformMatrix4fv;
    a2[84] = _UseProgram;
    a2[85] = _ValidateProgram;
    a2[86] = _Vertex2f;
    a2[87] = _VertexAttribPointer;
    a2[88] = _Viewport;
    *(_BYTE *)a2 = 1;
  }
  return result;
}

uint64_t _ActiveTexture(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 2744))(*(_QWORD *)a1);
}

uint64_t _AttachShader(uint64_t a1, unsigned int a2, unsigned int a3)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a1 + 4792))(*(_QWORD *)a1, a2, a3);
}

uint64_t _BindAttribLocation(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 5048))(*(_QWORD *)a1, a2);
}

uint64_t _BindBuffer(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5144))(*(_QWORD *)a1);
}

uint64_t _BindFramebuffer(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5384))(*(_QWORD *)a1);
}

uint64_t _BindRenderbuffer(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5336))(*(_QWORD *)a1);
}

uint64_t _BindTexture(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 48))(*(_QWORD *)a1);
}

uint64_t _BlendColor(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 2704))(*(_QWORD *)a1);
}

uint64_t _BlendEquationSeparate(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 3672))(*(_QWORD *)a1);
}

uint64_t _BlendFunc(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 64))(*(_QWORD *)a1);
}

uint64_t _BlendFuncSeparate(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 2696))(*(_QWORD *)a1);
}

uint64_t _CheckFramebufferStatus(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5408))(*(_QWORD *)a1);
}

uint64_t _ClearColor(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 104))(*(_QWORD *)a1);
}

uint64_t _ClientWaitSync(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 6264))(*(_QWORD *)a1);
}

uint64_t _CompileShader(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 4776))(*(_QWORD *)a1, a2);
}

uint64_t _CopyTexImage2D(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 440))(*(_QWORD *)a1);
}

uint64_t _CopyTexSubImage2D(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 456))(*(_QWORD *)a1);
}

uint64_t _CreateProgram(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4784))(*(_QWORD *)a1);
}

uint64_t _CreateShader(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4760))(*(_QWORD *)a1);
}

uint64_t _DeleteFramebuffers(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5392))(*(_QWORD *)a1);
}

uint64_t _DeleteProgram(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 4736))(*(_QWORD *)a1, a2);
}

uint64_t _DeleteRenderbuffers(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5344))(*(_QWORD *)a1);
}

uint64_t _DeleteShader(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 4736))(*(_QWORD *)a1, a2);
}

uint64_t _DeleteSync(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 6256))(*(_QWORD *)a1);
}

uint64_t _DeleteTextures(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 480))(*(_QWORD *)a1);
}

uint64_t _DepthMask(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 496))(*(_QWORD *)a1);
}

uint64_t _Disable(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 512))(*(_QWORD *)a1);
}

uint64_t _DisableVertexAttribArray(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4112))(*(_QWORD *)a1);
}

uint64_t _DrawArrays(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 528))(*(_QWORD *)a1);
}

uint64_t _DrawBuffers(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5240))(*(_QWORD *)a1);
}

uint64_t _Enable(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 584))(*(_QWORD *)a1);
}

uint64_t _EnableVertexAttribArray(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4104))(*(_QWORD *)a1);
}

uint64_t _FenceSync(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 6240))(*(_QWORD *)a1);
}

uint64_t _Finish(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 720))(*(_QWORD *)a1);
}

uint64_t _Flush(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 728))(*(_QWORD *)a1);
}

uint64_t _FramebufferRenderbuffer(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5440))(*(_QWORD *)a1);
}

uint64_t _FramebufferTexture2D(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5424))(*(_QWORD *)a1);
}

uint64_t _GenFramebuffers(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5400))(*(_QWORD *)a1);
}

uint64_t _GenRenderbuffers(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5352))(*(_QWORD *)a1);
}

uint64_t _GenTextures(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 792))(*(_QWORD *)a1);
}

uint64_t _GetBooleanv(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 800))(*(_QWORD *)a1);
}

uint64_t _GetError(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 824))(*(_QWORD *)a1);
}

uint64_t _GetFramebufferAttachmentParameteriv(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5448))(*(_QWORD *)a1);
}

uint64_t _GetIntegerv(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 840))(*(_QWORD *)a1);
}

uint64_t _GetProgramInfoLog(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5288))(*(_QWORD *)a1);
}

uint64_t _GetProgramiv(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5272))(*(_QWORD *)a1);
}

uint64_t _GetRenderbufferParameteriv(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5368))(*(_QWORD *)a1);
}

uint64_t _GetShaderInfoLog(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5280))(*(_QWORD *)a1);
}

uint64_t _GetShaderiv(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5264))(*(_QWORD *)a1);
}

uint64_t _GetString(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 944))(*(_QWORD *)a1);
}

uint64_t _GetTexLevelParameteriv(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 1008))(*(_QWORD *)a1);
}

uint64_t _GetUniformLocation(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 5008))(*(_QWORD *)a1, a2);
}

uint64_t _GetVertexAttribPointerv(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4144))(*(_QWORD *)a1);
}

uint64_t _GetVertexAttribiv(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4136))(*(_QWORD *)a1);
}

uint64_t _InsertEventMarkerEXT(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 6536))(*(_QWORD *)a1);
}

uint64_t _IsEnabled(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 1152))(*(_QWORD *)a1);
}

uint64_t _IsFramebuffer(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5376))(*(_QWORD *)a1);
}

uint64_t _IsTexture(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 1168))(*(_QWORD *)a1);
}

uint64_t _LinkProgram(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 4800))(*(_QWORD *)a1, a2);
}

uint64_t _PixelStorei(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 1568))(*(_QWORD *)a1);
}

uint64_t _ReadPixels(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 1904))(*(_QWORD *)a1);
}

uint64_t _RenderbufferStorage(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 5360))(*(_QWORD *)a1);
}

uint64_t _Scissor(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 2016))(*(_QWORD *)a1);
}

uint64_t _ShaderSource(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 4768))(*(_QWORD *)a1, a2);
}

uint64_t _TexImage2D(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 2416))(*(_QWORD *)a1);
}

uint64_t _TexParameterfv(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 2432))(*(_QWORD *)a1);
}

uint64_t _TexParameteri(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 2440))(*(_QWORD *)a1);
}

uint64_t _Uniform1f(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4824))(*(_QWORD *)a1);
}

uint64_t _Uniform1i(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4856))(*(_QWORD *)a1);
}

uint64_t _Uniform2f(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4832))(*(_QWORD *)a1);
}

uint64_t _Uniform3f(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4840))(*(_QWORD *)a1);
}

uint64_t _Uniform4f(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4848))(*(_QWORD *)a1);
}

uint64_t _UniformMatrix2fv(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4952))(*(_QWORD *)a1);
}

uint64_t _UniformMatrix3fv(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4960))(*(_QWORD *)a1);
}

uint64_t _UniformMatrix4fv(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4968))(*(_QWORD *)a1);
}

uint64_t _UseProgram(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 4808))(*(_QWORD *)a1, a2);
}

uint64_t _ValidateProgram(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 4816))(*(_QWORD *)a1, a2);
}

uint64_t _VertexAttribPointer(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 4096))(*(_QWORD *)a1);
}

uint64_t _Viewport(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 2688))(*(_QWORD *)a1);
}

double CI::Bitmap::Bitmap(CI::Bitmap *this)
{
  unsigned int v1;
  double result;

  *(_QWORD *)this = &unk_1E2EBED30;
  *((_DWORD *)this + 2) = 1;
  *((_QWORD *)this + 2) = off_1E2EBBE98;
  do
    v1 = __ldaxr(&dword_1ECF872F0[53]);
  while (__stlxr(v1 + 1, &dword_1ECF872F0[53]));
  *(_QWORD *)this = &off_1E2EBE9F8;
  *((_QWORD *)this + 2) = &unk_1E2EBEA30;
  *((_BYTE *)this + 24) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_BYTE *)this + 56) = 0;
  result = 0.0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *(_OWORD *)((char *)this + 92) = 0u;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_WORD *)this + 68) = 0;
  return result;
}

CFDataRef CI::createCFData(uint64_t this)
{
  unsigned __int8 v2;
  unint64_t v3;
  const UInt8 *v4;
  const UInt8 *v5;
  const __CFAllocator *v6;
  CFDataRef v7;
  CFAllocatorContext v9;

  if (!CI_IOSURFACE_WRAPPING(2u))
  {
    {
      CI::createCFData(unsigned long)::page_size = getpagesize();
    }
    v3 = CI::createCFData(unsigned long)::page_size - 1 + this;
    if ((CI::createCFData(unsigned long)::page_size & (CI::createCFData(unsigned long)::page_size - 1)) != 0)
      this = v3 / CI::createCFData(unsigned long)::page_size * CI::createCFData(unsigned long)::page_size;
    else
      this = v3 & -CI::createCFData(unsigned long)::page_size;
  }
  v4 = (const UInt8 *)mmap(0, this, 3, 4098, 1140850688, 0);
  if (v4 == (const UInt8 *)-1)
    v5 = 0;
  else
    v5 = v4;
  v9.version = 0;
  memset(&v9.retain, 0, 32);
  *(_OWORD *)&v9.reallocate = unk_1E2EC61F0;
  v9.preferredSize = 0;
  v9.info = (void *)this;
  v6 = CFAllocatorCreate(0, &v9);
  v7 = CFDataCreateWithBytesNoCopy(0, v5, this, v6);
  CFRelease(v6);
  return v7;
}

uint64_t CI::Bitmap::Bitmap(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char a5, CGColorSpace *a6, uint64_t a7)
{
  unsigned int v9;
  const __CFData *CFData;

  *(_QWORD *)a1 = &unk_1E2EBED30;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = off_1E2EBBE98;
  do
    v9 = __ldaxr(&dword_1ECF872F0[53]);
  while (__stlxr(v9 + 1, &dword_1ECF872F0[53]));
  *(_QWORD *)a1 = &off_1E2EBE9F8;
  *(_QWORD *)(a1 + 16) = &unk_1E2EBEA30;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = a2;
  *(_QWORD *)(a1 + 88) = a3;
  *(_DWORD *)(a1 + 104) = a4;
  *(_BYTE *)(a1 + 24) = a5;
  *(_QWORD *)(a1 + 96) = a7;
  *(_QWORD *)(a1 + 112) = (int)CI::format_component_count(a4);
  *(_QWORD *)(a1 + 120) = (int)CI::format_bytes_per_pixel(*(_DWORD *)(a1 + 104));
  *(_QWORD *)(a1 + 128) = (int)CI::format_bits_per_component(*(_DWORD *)(a1 + 104));
  *(_BYTE *)(a1 + 137) = CI::format_is_half_float(*(_DWORD *)(a1 + 104));
  *(_BYTE *)(a1 + 136) = CI::format_is_float(*(_DWORD *)(a1 + 104));
  *(_QWORD *)(a1 + 32) = CGColorSpaceRetain(a6);
  CFData = CI::createCFData(*(_QWORD *)(a1 + 88) * *(_QWORD *)(a1 + 96));
  *(_QWORD *)(a1 + 40) = CFData;
  *(_BYTE *)(a1 + 56) = 1;
  *(_QWORD *)(a1 + 72) = CFDataGetBytePtr(CFData);
  *(_QWORD *)(a1 + 48) = 0;
  return a1;
}

uint64_t CI::Bitmap::Bitmap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, CGColorSpace *a7)
{
  unsigned int v10;
  CGColorSpaceRef v11;

  *(_QWORD *)a1 = &unk_1E2EBED30;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = off_1E2EBBE98;
  do
    v10 = __ldaxr(&dword_1ECF872F0[53]);
  while (__stlxr(v10 + 1, &dword_1ECF872F0[53]));
  *(_QWORD *)a1 = &off_1E2EBE9F8;
  *(_QWORD *)(a1 + 16) = &unk_1E2EBEA30;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = a3;
  *(_QWORD *)(a1 + 88) = a4;
  *(_QWORD *)(a1 + 96) = a5;
  *(_DWORD *)(a1 + 104) = a6;
  *(_QWORD *)(a1 + 112) = (int)CI::format_component_count(a6);
  *(_QWORD *)(a1 + 120) = (int)CI::format_bytes_per_pixel(*(_DWORD *)(a1 + 104));
  *(_QWORD *)(a1 + 128) = (int)CI::format_bits_per_component(*(_DWORD *)(a1 + 104));
  *(_BYTE *)(a1 + 137) = CI::format_is_half_float(*(_DWORD *)(a1 + 104));
  *(_BYTE *)(a1 + 136) = CI::format_is_float(*(_DWORD *)(a1 + 104));
  *(_BYTE *)(a1 + 24) = 1;
  v11 = CGColorSpaceRetain(a7);
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 72) = a2;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 32) = v11;
  return a1;
}

CI::Bitmap *CI::Bitmap::Bitmap(CI::Bitmap *this, CGImage *a2)
{
  unsigned int v3;

  *(_QWORD *)this = &unk_1E2EBED30;
  *((_DWORD *)this + 2) = 1;
  *((_QWORD *)this + 2) = off_1E2EBBE98;
  do
    v3 = __ldaxr(&dword_1ECF872F0[53]);
  while (__stlxr(v3 + 1, &dword_1ECF872F0[53]));
  *(_QWORD *)this = &off_1E2EBE9F8;
  *((_QWORD *)this + 2) = &unk_1E2EBEA30;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  CI::Bitmap::init(this, a2);
  return this;
}

const __CFData *CI::Bitmap::init(CI::Bitmap *this, CGImageRef image)
{
  CGImage *v4;
  int v5;
  CGImage *v6;
  CGColorSpace *ColorSpace;
  CGDataProvider *DataProvider;
  uint64_t v9;
  const __CFData *result;

  *((_QWORD *)this + 10) = CGImageGetWidth(image);
  *((_QWORD *)this + 11) = CGImageGetHeight(image);
  *((_QWORD *)this + 12) = CGImageGetBytesPerRow(image);
  v5 = CI::format_from_CGImage((uint64_t)image, v4);
  *((_DWORD *)this + 26) = v5;
  *((_QWORD *)this + 14) = (int)CI::format_component_count(v5);
  *((_QWORD *)this + 15) = (int)CI::format_bytes_per_pixel(*((_DWORD *)this + 26));
  *((_QWORD *)this + 16) = (int)CI::format_bits_per_component(*((_DWORD *)this + 26));
  *((_BYTE *)this + 137) = CI::format_is_half_float(*((_DWORD *)this + 26));
  *((_BYTE *)this + 136) = CI::format_is_float(*((_DWORD *)this + 26));
  *((_BYTE *)this + 24) = 1;
  CI::alpha_mode_from_CGImage((uint64_t)image, v6);
  ColorSpace = CGImageGetColorSpace(image);
  *((_QWORD *)this + 4) = CGColorSpaceRetain(ColorSpace);
  DataProvider = CGImageGetDataProvider(image);
  v9 = CGDataProviderRetainBytePtr();
  if (v9)
  {
    *((_QWORD *)this + 9) = v9;
    *((_QWORD *)this + 6) = CGDataProviderRetain(DataProvider);
  }
  else
  {
    result = CGDataProviderCopyData(DataProvider);
    if (!result)
      return result;
    *((_QWORD *)this + 5) = result;
    *((_QWORD *)this + 9) = CFDataGetBytePtr(result);
  }
  return (const __CFData *)1;
}

CFTypeRef CI::Bitmap::initWithIOSurface(uint64_t a1, IOSurfaceRef buffer, uint64_t a3, int a4, int a5)
{
  size_t v9;
  size_t WidthOfPlane;
  size_t HeightOfPlane;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  size_t v27;
  BOOL v28;
  size_t v29;
  int v30;
  int v31;
  char *v32;
  CFTypeRef result;

  v9 = a5;
  WidthOfPlane = IOSurfaceGetWidthOfPlane(buffer, a5);
  HeightOfPlane = IOSurfaceGetHeightOfPlane(buffer, v9);
  v13 = *(_DWORD *)a3;
  v12 = *(_DWORD *)(a3 + 4);
  v15 = *(_QWORD *)(a3 + 8);
  v14 = *(_QWORD *)(a3 + 16);
  v16 = 0x7FFFFFFFLL;
  if (v13 == 0x7FFFFFFF && v12 == 0x7FFFFFFF && v15 == 0 && v14 == 0)
  {
    HeightOfPlane = 0;
    WidthOfPlane = 0;
    v31 = 0x7FFFFFFF;
  }
  else if (v13 == -2147483647 && v12 == -2147483647 && v15 == 0xFFFFFFFFLL && v14 == 0xFFFFFFFFLL)
  {
    v16 = 0;
    v31 = 0;
  }
  else
  {
    v23 = v13 & ~(v13 >> 31);
    v24 = v13 + v15;
    if ((int)WidthOfPlane < v24)
      v24 = WidthOfPlane;
    v25 = v12 & ~(v12 >> 31);
    v26 = v12 + v14;
    if ((int)HeightOfPlane < v26)
      v26 = HeightOfPlane;
    v27 = v24 - v23;
    v28 = v26 < (int)v25;
    if (v26 >= (int)v25)
      v29 = v26 - (int)v25;
    else
      v29 = 0;
    if (v28)
    {
      v27 = 0;
      v25 = 0x7FFFFFFFLL;
      v30 = 0x7FFFFFFF;
    }
    else
    {
      v30 = v23;
    }
    if (v24 >= v23)
      HeightOfPlane = v29;
    else
      HeightOfPlane = 0;
    if (v24 >= v23)
      WidthOfPlane = v27;
    else
      WidthOfPlane = 0;
    if (v24 >= v23)
      v16 = v25;
    else
      v16 = 0x7FFFFFFFLL;
    if (v24 >= v23)
      v31 = v30;
    else
      v31 = 0x7FFFFFFF;
  }
  *(_QWORD *)(a1 + 80) = WidthOfPlane;
  *(_QWORD *)(a1 + 88) = HeightOfPlane;
  *(_DWORD *)(a1 + 104) = a4;
  *(_QWORD *)(a1 + 96) = IOSurfaceGetBytesPerRowOfPlane(buffer, v9);
  *(_QWORD *)(a1 + 112) = (int)CI::format_component_count(*(_DWORD *)(a1 + 104));
  *(_QWORD *)(a1 + 120) = (int)CI::format_bytes_per_pixel(*(_DWORD *)(a1 + 104));
  *(_QWORD *)(a1 + 128) = (int)CI::format_bits_per_component(*(_DWORD *)(a1 + 104));
  *(_BYTE *)(a1 + 137) = CI::format_is_half_float(*(_DWORD *)(a1 + 104));
  *(_BYTE *)(a1 + 136) = CI::format_is_float(*(_DWORD *)(a1 + 104));
  *(_QWORD *)(a1 + 32) = 0;
  v32 = (char *)IOSurfaceGetBaseAddressOfPlane(buffer, v9) + *(_QWORD *)(a1 + 96) * v16;
  *(_QWORD *)(a1 + 72) = &v32[(int)(CI::format_bytes_per_pixel(*(_DWORD *)(a1 + 104)) * v31)];
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 56) = 0;
  result = CFRetain(buffer);
  *(_QWORD *)(a1 + 64) = result;
  return result;
}

uint64_t CI::Bitmap::Bitmap(uint64_t a1, IOSurfaceRef buffer, uint64_t a3, int a4)
{
  unsigned int v8;
  NSObject *v9;

  *(_QWORD *)a1 = &unk_1E2EBED30;
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)(a1 + 16) = off_1E2EBBE98;
  do
    v8 = __ldaxr(&dword_1ECF872F0[53]);
  while (__stlxr(v8 + 1, &dword_1ECF872F0[53]));
  *(_QWORD *)a1 = &off_1E2EBE9F8;
  *(_QWORD *)(a1 + 16) = &unk_1E2EBEA30;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  if (IOSurfaceGetPlaneCount(buffer) < 2)
  {
    CI::Bitmap::initWithIOSurface(a1, buffer, a3, a4, 0);
  }
  else
  {
    v9 = ci_logger_render();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      CI::Bitmap::Bitmap(v9);
  }
  return a1;
}

CI::Bitmap *CI::Bitmap::Bitmap(CI::Bitmap *this, __IOSurface *a2, int a3)
{
  unsigned int v6;
  int v7;
  int v8;
  CI::Bitmap *v9;
  __IOSurface *v10;
  int v11;
  uint64_t v13;
  size_t WidthOfPlane;
  size_t HeightOfPlane;

  *(_QWORD *)this = &unk_1E2EBED30;
  *((_DWORD *)this + 2) = 1;
  *((_QWORD *)this + 2) = off_1E2EBBE98;
  do
    v6 = __ldaxr(&dword_1ECF872F0[53]);
  while (__stlxr(v6 + 1, &dword_1ECF872F0[53]));
  *(_QWORD *)this = &off_1E2EBE9F8;
  *((_QWORD *)this + 2) = &unk_1E2EBEA30;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  v7 = CI::format_from_IOSurface(a2, a2);
  if (CI::format_is_ycc_biplanar(v7))
  {
    v13 = 0;
    WidthOfPlane = IOSurfaceGetWidthOfPlane(a2, a3);
    HeightOfPlane = IOSurfaceGetHeightOfPlane(a2, a3);
    v8 = CI::format_of_plane(v7, a3);
    v9 = this;
    v10 = a2;
    v11 = a3;
  }
  else
  {
    v13 = 0;
    WidthOfPlane = IOSurfaceGetWidth(a2);
    HeightOfPlane = IOSurfaceGetHeight(a2);
    v9 = this;
    v10 = a2;
    v8 = v7;
    v11 = 0;
  }
  CI::Bitmap::initWithIOSurface((uint64_t)v9, v10, (uint64_t)&v13, v8, v11);
  return this;
}

void CI::Bitmap::~Bitmap(CI::Bitmap *this)
{
  CGColorSpace *v2;
  const void *v3;
  const void *v4;
  unsigned int v5;

  *(_QWORD *)this = &off_1E2EBE9F8;
  *((_QWORD *)this + 2) = &unk_1E2EBEA30;
  v2 = (CGColorSpace *)*((_QWORD *)this + 4);
  if (v2)
  {
    CGColorSpaceRelease(v2);
    *((_QWORD *)this + 4) = 0;
  }
  *((_QWORD *)this + 9) = 0;
  v3 = (const void *)*((_QWORD *)this + 5);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)this + 5) = 0;
  }
  if (*((_QWORD *)this + 6))
  {
    CGDataProviderReleaseBytePtr();
    CGDataProviderRelease(*((CGDataProviderRef *)this + 6));
    *((_QWORD *)this + 6) = 0;
  }
  v4 = (const void *)*((_QWORD *)this + 8);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 8) = 0;
  }
  *((_OWORD *)this + 5) = xmmword_19249AE50;
  *((_QWORD *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_WORD *)this + 68) = 0;
  *((_QWORD *)this + 2) = off_1E2EBBE98;
  do
    v5 = __ldaxr(&dword_1ECF872F0[53]);
  while (__stlxr(v5 - 1, &dword_1ECF872F0[53]));
}

{
  CI::Bitmap::~Bitmap(this);
  JUMPOUT(0x194025AACLL);
}

void `non-virtual thunk to'CI::Bitmap::~Bitmap(CI::Bitmap *this)
{
  CI::Bitmap::~Bitmap((CI::Bitmap *)((char *)this - 16));
}

{
  CI::Bitmap::~Bitmap((CI::Bitmap *)((char *)this - 16));
  JUMPOUT(0x194025AACLL);
}

CGImageRef CI::Bitmap::create_CGImage(CI::Bitmap *this)
{
  CGBitmapInfo v2;
  CGBitmapInfo v3;
  const __CFData *v4;
  CGDataProviderRef v5;
  CGDataProvider *v6;
  CGColorSpace *v7;
  CGColorSpace *DeviceRGB;
  size_t v9;
  size_t v10;
  size_t v11;
  int v12;
  CGImageRef v13;

  v2 = CI::format_CGBitmapInfo(*((_DWORD *)this + 26), *((unsigned __int8 *)this + 24));
  if (v2 == -1)
    return 0;
  v3 = v2;
  v4 = (const __CFData *)*((_QWORD *)this + 5);
  v5 = v4 ? CGDataProviderCreateWithCFData(v4) : (CGDataProviderRef)CGDataProviderCreateWithCopyOfData();
  v6 = v5;
  if (!v5)
    return 0;
  v7 = (CGColorSpace *)*((_QWORD *)this + 4);
  DeviceRGB = v7;
  if (!v7)
    DeviceRGB = CGColorSpaceCreateDeviceRGB();
  v9 = *((_QWORD *)this + 10);
  v10 = *((_QWORD *)this + 11);
  v11 = (int)CI::format_bits_per_component(*((_DWORD *)this + 26));
  v12 = CI::format_bits_per_pixel(*((_DWORD *)this + 26));
  v13 = CGImageCreate(v9, v10, v11, v12, *((_QWORD *)this + 12), DeviceRGB, v3, v6, 0, 1, kCGRenderingIntentDefault);
  CGDataProviderRelease(v6);
  if (!v7)
    CGColorSpaceRelease(DeviceRGB);
  return v13;
}

uint64_t CI::Bitmap::type(CI::Bitmap *this)
{
  return 55;
}

uint64_t `non-virtual thunk to'CI::Bitmap::type(CI::Bitmap *this)
{
  return 55;
}

uint64_t CI::InstanceCounted<(CI::Type)55>::type()
{
  return 55;
}

_QWORD *CI::InstanceCounted<(CI::Type)55>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBBE98;
  do
    v1 = __ldaxr(&dword_1ECF872F0[53]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[53]));
  return result;
}

void CI::InstanceCounted<(CI::Type)55>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBBE98;
  do
    v1 = __ldaxr(&dword_1ECF872F0[53]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[53]));
  JUMPOUT(0x194025AACLL);
}

int8x16_t *haarTransform32x32_NEON(int8x16_t *result, uint64_t a2, int32x4_t *a3)
{
  int v3;
  int32x4_t *v4;
  int8x16_t v5;
  int8x16_t v6;
  uint8x16_t v7;
  uint8x16_t v8;
  int16x8_t v9;
  int16x8_t v10;
  uint16x8_t v11;
  uint16x8_t v12;
  int16x8_t v13;
  int16x8_t v14;
  int16x8_t v15;
  int32x4_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int16x8_t v19;
  int16x8_t v20;
  int32x4_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t *v24;
  int v25;
  int16x8_t *v26;
  int v27;
  int16x8_t v28;
  int16x8_t v29;
  int16x8_t v30;
  int16x8_t v31;
  int16x8_t v32;
  int16x8_t v33;
  int16x8_t v34;
  int16x8_t v35;
  int16x8_t v36;
  int16x8_t v37;
  int16x8_t v38;
  int16x8_t v39;
  int16x8_t v40;
  int16x8_t v41;

  v3 = 32;
  v4 = a3;
  do
  {
    v5 = *result;
    v6 = result[1];
    result = (int8x16_t *)((char *)result + a2);
    v7 = (uint8x16_t)vuzp1q_s8(v5, v6);
    v8 = (uint8x16_t)vuzp2q_s8(v5, v6);
    v9 = (int16x8_t)vaddl_u8(*(uint8x8_t *)v7.i8, *(uint8x8_t *)v8.i8);
    v10 = (int16x8_t)vaddl_high_u8(v7, v8);
    v11 = vsubl_u8(*(uint8x8_t *)v7.i8, *(uint8x8_t *)v8.i8);
    v12 = vsubl_high_u8(v7, v8);
    v13 = vuzp1q_s16(v9, v10);
    v14 = vuzp2q_s16(v9, v10);
    v15 = vaddq_s16(v13, v14);
    v16 = (int32x4_t)vsubq_s16(v13, v14);
    v17 = vrev32q_s16(v15);
    v18 = vaddq_s16(v17, v15);
    v19 = vsubq_s16(v17, v15);
    v20 = vzip1q_s16(v18, v19);
    v21 = (int32x4_t)vzip2q_s16(v18, v19);
    v21.i32[2] = v21.i32[1];
    v21.i64[0] = __PAIR64__(v20.u32[3], v20.u32[1]);
    v22 = vzip1q_s32(v21, v16);
    v23 = vzip2q_s32(v21, v16);
    v21.i64[0] = v22.i64[0];
    v21.i64[1] = v11.i64[0];
    v11.i64[0] = v22.i64[1];
    v16.i64[0] = v23.i64[0];
    v16.i64[1] = v12.i64[0];
    v12.i64[0] = v23.i64[1];
    *v4 = v21;
    v4[1] = (int32x4_t)v11;
    v24 = v4 + 2;
    *v24 = v16;
    v24[1] = (int32x4_t)v12;
    v4 = v24 + 2;
    --v3;
  }
  while (v3);
  v25 = 4;
  do
  {
    v26 = (int16x8_t *)a3;
    v27 = 4;
    do
    {
      v28 = v26[4];
      v29 = v26[8];
      v30 = v26[12];
      v31 = v26[16];
      v32 = v26[20];
      v33 = v26[24];
      v34 = v26[28];
      v35 = vaddq_s16(*v26, v28);
      v36 = vaddq_s16(v29, v30);
      v37 = vaddq_s16(v31, v32);
      v38 = vaddq_s16(v33, v34);
      v39 = vsubq_s16(*v26, v28);
      v40 = vaddq_s16(v35, v36);
      v41 = vaddq_s16(v37, v38);
      *v26 = vaddq_s16(v40, v41);
      v26[4] = vsubq_s16(v40, v41);
      v26[8] = vsubq_s16(v35, v36);
      v26[12] = vsubq_s16(v37, v38);
      v26[16] = v39;
      v26[20] = vsubq_s16(v29, v30);
      v26[24] = vsubq_s16(v31, v32);
      v26[28] = vsubq_s16(v33, v34);
      ++v26;
      --v27;
    }
    while (v27);
    a3 += 32;
    --v25;
  }
  while (v25);
  return result;
}

uint64_t horzDiff32x32(int8x16_t *_X0, uint64_t a2, int a3)
{
  uint16x8_t v8;
  int8x16_t v9;
  int8x16_t v10;
  uint8x16_t v12;
  uint8x16_t v13;
  int64x2_t v14;

  __asm { PRFM            #0, [X0] }
  v8 = 0uLL;
  do
  {
    v9 = *_X0;
    v10 = _X0[1];
    _X0 = (int8x16_t *)((char *)_X0 + a2);
    __asm { PRFM            #0, [X0] }
    v12 = (uint8x16_t)vextq_s8(v10, v9, 0xFuLL);
    v13 = (uint8x16_t)vextq_s8(v9, v10, 0xFuLL);
    v8 = vabal_high_u8(vabal_u8(vabal_high_u8(vabal_u8(v8, *(uint8x8_t *)v9.i8, *(uint8x8_t *)v12.i8), (uint8x16_t)v9, v12), *(uint8x8_t *)v10.i8, *(uint8x8_t *)v13.i8), (uint8x16_t)v10, v13);
    --a3;
  }
  while (a3);
  v14 = (int64x2_t)vpaddlq_u32(vpaddlq_u16(v8));
  return vpaddq_s64(v14, v14).u32[0];
}

void sub_1923DD87C(uint64_t a1, uint64_t a2, signed int a3, uint64_t a4, int16x8_t *a5, int16x4_t *a6)
{
  uint64_t v6;
  int16x8_t v7;
  uint32x4_t v8;
  signed int v9;
  signed int v10;

  v6 = 4;
  do
  {
    v7 = *a5;
    v7.i64[0] = a5[1].i64[1];
    v8 = (uint32x4_t)vaddq_s32(vaddq_s32(vmull_s16(a6[2], a6[2]), vmull_s16(*(int16x4_t *)v7.i8, *(int16x4_t *)v7.i8)), vmull_high_s16(*(int16x8_t *)a6[2].i8, *(int16x8_t *)a6[2].i8));
    v9 = vmaxvq_u32((uint32x4_t)vaddq_s32(vaddq_s32(vmull_s16(*a6, *a6), vmull_high_s16(v7, v7)), vmull_high_s16(*(int16x8_t *)a6->i8, *(int16x8_t *)a6->i8)));
    if (a3 <= v9)
      a3 = v9;
    v10 = vmaxvq_u32(v8);
    if (a3 <= v10)
      a3 = v10;
    a5 += 4;
    a6 += 8;
    --v6;
  }
  while (v6);
}

uint64_t computeEdge1Squared16x16_NEON(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  signed int v6;
  uint64_t v7;
  unsigned int v8;

  sub_1923DD87C(a1, a2, 0, a4, (int16x8_t *)a1, (int16x4_t *)(a1 + 256));
  sub_1923DD87C(v4, v5, v6, v7, (int16x8_t *)(v4 + 512), (int16x4_t *)(v4 + 768));
  return v8;
}

void CI::Buffer::copy_to(CI::Buffer *this, unsigned __int8 *a2)
{
  const __CFData *v2;
  CFRange v4;

  v2 = (const __CFData *)*((_QWORD *)this + 3);
  if (v2)
  {
    v4.length = CFDataGetLength(*((CFDataRef *)this + 3));
    v4.location = 0;
    CFDataGetBytes(v2, v4, a2);
  }
}

CFStringRef CI::Buffer::description(CI::Buffer *this)
{
  uint64_t v1;
  CFIndex Length;

  v1 = *((_QWORD *)this + 3);
  if (v1)
    Length = CFDataGetLength(*((CFDataRef *)this + 3));
  else
    Length = 0;
  return CFStringCreateWithFormat(0, 0, CFSTR("<CI::Buffer %p>[%zu bytes]"), v1, Length);
}

uint64_t CI::Buffer::print(CI::Buffer *this, __sFILE *a2)
{
  const __CFData *v4;
  unint64_t Length;
  unint64_t v6;
  const UInt8 *BytePtr;
  uint64_t result;
  int v9;
  unint64_t v10;
  int64x2_t v11[5];

  v4 = (const __CFData *)*((_QWORD *)this + 3);
  if (v4)
  {
    Length = CFDataGetLength(v4);
    v6 = Length;
    if (Length > 0x20)
    {
      fprintf(a2, "[len:%zu ", Length);
      XXH64_reset(v11, 0);
      CI::XXHashHelper::add((CI::XXHashHelper *)v11, *((CFDataRef *)this + 3));
      v10 = XXH64_digest((uint64_t)v11);
      return fprintf(a2, "digest:%016llX]", v10);
    }
    v4 = (const __CFData *)*((_QWORD *)this + 3);
  }
  else
  {
    v6 = 0;
  }
  BytePtr = CFDataGetBytePtr(v4);
  for (result = fwrite("0x", 2uLL, 1uLL, a2); v6; --v6)
  {
    v9 = *BytePtr++;
    result = fprintf(a2, "%02X", v9);
  }
  return result;
}

void CI::Buffer::~Buffer(CI::Buffer *this)
{
  const void *v2;
  unsigned int v3;

  *(_QWORD *)this = &off_1E2EBEA58;
  *((_QWORD *)this + 2) = &unk_1E2EBEA90;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 2) = off_1E2EBBEC0;
  do
    v3 = __ldaxr(&dword_1ECF872F0[55]);
  while (__stlxr(v3 - 1, &dword_1ECF872F0[55]));
}

{
  const void *v2;
  unsigned int v3;

  *(_QWORD *)this = &off_1E2EBEA58;
  *((_QWORD *)this + 2) = &unk_1E2EBEA90;
  v2 = (const void *)*((_QWORD *)this + 3);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 2) = off_1E2EBBEC0;
  do
    v3 = __ldaxr(&dword_1ECF872F0[55]);
  while (__stlxr(v3 - 1, &dword_1ECF872F0[55]));
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::Buffer::type(CI::Buffer *this)
{
  return 57;
}

uint64_t `non-virtual thunk to'CI::Buffer::type(CI::Buffer *this)
{
  return 57;
}

void `non-virtual thunk to'CI::Buffer::~Buffer(CI::Buffer *this)
{
  const void *v2;
  unsigned int v3;

  *((_QWORD *)this - 2) = &off_1E2EBEA58;
  *(_QWORD *)this = &unk_1E2EBEA90;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)this = off_1E2EBBEC0;
  do
    v3 = __ldaxr(&dword_1ECF872F0[55]);
  while (__stlxr(v3 - 1, &dword_1ECF872F0[55]));
}

{
  CI::Buffer::~Buffer((CI::Buffer *)((char *)this - 16));
}

uint64_t CI::originating_process_is_in_background(CI *this)
{
  if (CI_FORCE_IS_BACKGROUND() == 89)
    return 1;
  if (CI_FORCE_IS_BACKGROUND() != 78)
    proc_pidoriginatorinfo();
  return 0;
}

float32x2_t *CI::Color::Color(float32x2_t *this, CGColorRef color)
{
  unsigned int v4;
  CGColorSpace *ColorSpace;
  CGColorSpaceModel Model;
  float64x2_t *Components;
  float32_t v8;
  uint64_t v9;
  float32_t v10;
  float32_t v11;

  *this = (float32x2_t)&unk_1E2EBED30;
  this[1].i32[0] = 1;
  this[2] = (float32x2_t)off_1E2EBBF10;
  do
    v4 = __ldaxr(&dword_1ECF873D0[1]);
  while (__stlxr(v4 + 1, &dword_1ECF873D0[1]));
  *this = (float32x2_t)&off_1E2EBE838;
  this[2] = (float32x2_t)&unk_1E2EBE880;
  this[3] = 0;
  this[4] = 0;
  this[5] = 0;
  if (color)
  {
    ColorSpace = CGColorGetColorSpace(color);
    Model = CGColorSpaceGetModel(ColorSpace);
    Components = (float64x2_t *)CGColorGetComponents(color);
    if (Model == kCGColorSpaceModelRGB)
    {
      this[3] = vcvt_f32_f64(*Components);
      v10 = Components[1].f64[0];
      this[4].f32[0] = v10;
      v9 = 3;
      goto LABEL_8;
    }
    if (Model == kCGColorSpaceModelMonochrome)
    {
      v8 = Components->f64[0];
      this[3].f32[1] = v8;
      this[4].f32[0] = v8;
      this[3].f32[0] = v8;
      v9 = 1;
LABEL_8:
      v11 = Components->f64[v9];
      this[4].f32[1] = v11;
      this[5] = (float32x2_t)CGColorSpaceRetain(ColorSpace);
    }
  }
  return this;
}

uint64_t CI::Color::Color(uint64_t this, float a2, float a3, float a4, float a5)
{
  unsigned int v5;

  *(_QWORD *)this = &unk_1E2EBED30;
  *(_DWORD *)(this + 8) = 1;
  *(_QWORD *)(this + 16) = off_1E2EBBF10;
  do
    v5 = __ldaxr(&dword_1ECF873D0[1]);
  while (__stlxr(v5 + 1, &dword_1ECF873D0[1]));
  *(_QWORD *)this = &off_1E2EBE838;
  *(_QWORD *)(this + 16) = &unk_1E2EBE880;
  *(float *)(this + 24) = a2;
  *(float *)(this + 28) = a3;
  *(float *)(this + 32) = a4;
  *(float *)(this + 36) = a5;
  *(_QWORD *)(this + 40) = 0;
  return this;
}

void CI::Color::~Color(CI::Color *this)
{
  unsigned int v2;

  *(_QWORD *)this = &off_1E2EBE838;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = &unk_1E2EBE880;
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 5));
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 2) = off_1E2EBBF10;
  do
    v2 = __ldaxr(&dword_1ECF873D0[1]);
  while (__stlxr(v2 - 1, &dword_1ECF873D0[1]));
}

{
  unsigned int v2;

  *(_QWORD *)this = &off_1E2EBE838;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = &unk_1E2EBE880;
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 5));
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 2) = off_1E2EBBF10;
  do
    v2 = __ldaxr(&dword_1ECF873D0[1]);
  while (__stlxr(v2 - 1, &dword_1ECF873D0[1]));
  JUMPOUT(0x194025AACLL);
}

void `non-virtual thunk to'CI::Color::~Color(CI::Color *this)
{
  unsigned int v2;

  *((_QWORD *)this - 2) = &off_1E2EBE838;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &unk_1E2EBE880;
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 3));
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = off_1E2EBBF10;
  do
    v2 = __ldaxr(&dword_1ECF873D0[1]);
  while (__stlxr(v2 - 1, &dword_1ECF873D0[1]));
}

{
  CI::Color::~Color((CI::Color *)((char *)this - 16));
}

void CI::Color::vector_in_workingspace(CI::Color *this, CGColorSpace **a2)
{
  float v4;
  CGColorSpace *v5;
  unsigned __int8 v6;
  _QWORD *v7;
  CI *v8;
  CI *v9;
  CI::Vector *v10;
  __n128 v11;
  int v12;
  float32x2_t v13;
  float v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = *(float32x2_t *)((char *)this + 24);
  v4 = *((float *)this + 9);
  v14 = *((float *)this + 8);
  if (!CI_NO_CM())
  {
    v7 = &unk_1EE281000;
    if ((v6 & 1) == 0)
    {
      v7 = (_QWORD *)&unk_1EE281000;
      if (v12)
      {
        CI::Color::vector_in_workingspace(CI::Context *)const::srgb_cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
        v7 = (_QWORD *)&unk_1EE281000;
      }
    }
    v8 = (CI *)v7[207];
    if (*((_QWORD *)this + 5))
      v9 = (CI *)*((_QWORD *)this + 5);
    else
      v9 = v8;
    CI::match_color(&v13, v9, a2[3], v5);
    CGColorSpaceRelease(v9);
  }
  v10 = (CI::Vector *)operator new();
  v11.n128_f32[0] = v4 * v13.f32[0];
  CI::Vector::Vector(v10, v11, v4 * v13.f32[1], v4 * v14, v4);
}

CFStringRef CI::Color::description(CI::Color *this)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("<CI::Color %p>[%g %g %g %g]"), this, *((float *)this + 6), *((float *)this + 7), *((float *)this + 8), *((float *)this + 9));
}

uint64_t CI::Color::print(CI::Color *this, __sFILE *a2)
{
  fprintf(a2, "[%g %g %g %g ", *((float *)this + 6), *((float *)this + 7), *((float *)this + 8), *((float *)this + 9));
  CI::fprintf_cs(a2, *((__sFILE **)this + 5), (CGColorSpace *)1);
  return fputc(93, a2);
}

uint64_t CI::Color::type(CI::Color *this)
{
  return 59;
}

BOOL CI::Color::isEmpty(CI::Color *this)
{
  return *((float *)this + 6) == 0.0
      && *((float *)this + 7) == 0.0
      && *((float *)this + 8) == 0.0
      && *((float *)this + 9) == 0.0;
}

BOOL CI::Color::isExtended(CI::Color *this)
{
  float v1;
  float v2;
  float v3;
  float v5;
  _BOOL4 v6;

  v1 = *((float *)this + 6);
  if (v1 < 0.0)
    return 1;
  v2 = *((float *)this + 7);
  if (v2 < 0.0)
    return 1;
  v3 = *((float *)this + 8);
  if (v3 < 0.0)
    return 1;
  v5 = *((float *)this + 9);
  v6 = v5 < 0.0;
  if (v1 > v5)
    v6 = 1;
  if (v2 > v5)
    v6 = 1;
  if (v3 > v5)
    v6 = 1;
  return v1 > 1.0 || v6;
}

uint64_t `non-virtual thunk to'CI::Color::type(CI::Color *this)
{
  return 59;
}

uint64_t CI::InstanceCounted<(CI::Type)59>::type()
{
  return 59;
}

_QWORD *CI::InstanceCounted<(CI::Type)59>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBBF10;
  do
    v1 = __ldaxr(&dword_1ECF873D0[1]);
  while (__stlxr(v1 - 1, &dword_1ECF873D0[1]));
  return result;
}

void CI::InstanceCounted<(CI::Type)59>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBBF10;
  do
    v1 = __ldaxr(&dword_1ECF873D0[1]);
  while (__stlxr(v1 - 1, &dword_1ECF873D0[1]));
  JUMPOUT(0x194025AACLL);
}

CI::GLTextureManager *CI::GLTextureManager::GLTextureManager(CI::GLTextureManager *this, CI::GLContext *a2)
{
  int v4;
  _QWORD *v5;
  int API;
  int v7;
  uint64_t v8;
  _QWORD v10[5];
  int v11;

  v4 = (*(uint64_t (**)(CI::GLContext *))(*(_QWORD *)a2 + 272))(a2);
  CI::TextureManager::TextureManager(this, v4);
  *(_QWORD *)this = &off_1E2EBCBC0;
  *((_QWORD *)this + 21) = a2;
  v5 = (_QWORD *)operator new();
  *v5 = v5;
  v5[1] = v5;
  v5[2] = 0;
  *((_QWORD *)this + 22) = v5;
  API = CIEAGLContextGetAPI(*(void **)(*((_QWORD *)this + 21) + 392));
  *((_QWORD *)this + 23) = CIEAGLContextCreate(API, *(void **)(*((_QWORD *)this + 21) + 392));
  if (CI_RECYCLE_OPENGL_TEXTURES() && CI_IOSURFACE_INTERMEDIATES())
  {
    v7 = (*(uint64_t (**)(CI::GLContext *))(*(_QWORD *)a2 + 272))(a2);
    v8 = *((_QWORD *)this + 13);
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 0x40000000;
    v10[2] = ___ZN2CI16GLTextureManagerC2EPNS_9GLContextE_block_invoke;
    v10[3] = &__block_descriptor_tmp_6;
    v10[4] = this;
    v11 = v7;
    AddReleaseSurfaceBlock(v8, (uint64_t)v10);
  }
  return this;
}

void ___ZN2CI16GLTextureManagerC2EPNS_9GLContextE_block_invoke(uint64_t a1, CFTypeRef a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeRef *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  const void *v18;
  uint64_t v19;
  NSObject *v20;
  os_signpost_id_t v21;
  NSObject *v22;
  uint8_t buf[16];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  void (*v55)(_QWORD);
  CFTypeRef *v56;
  char v57[8];
  os_signpost_id_t v58;
  uint8_t v59[4];
  uint64_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32);
  v5 = ci_signpost_log_render();
  v6 = *(unsigned int *)(a1 + 40);
  if ((unint64_t)((v6 << 32) - 1) <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v7 = v5;
    if (os_signpost_enabled(v5))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v7, OS_SIGNPOST_INTERVAL_BEGIN, v6 << 32, "release_surface_block", (const char *)&unk_192520C83, buf, 2u);
      v6 = *(unsigned int *)(a1 + 40);
    }
  }
  TimerBase::TimerBase((uint64_t)v57, v6, 0, (uint64_t)"release_surface_block", 32);
  v8 = *(_QWORD *)(v4 + 176);
  v9 = *(_QWORD *)(v8 + 8);
  while (v9 != v8)
  {
    v11 = v9 + 8;
    v9 = *(_QWORD *)(v9 + 8);
    v10 = *(CFTypeRef **)(v11 + 8);
    v56 = v10;
    if (!*((_BYTE *)v10 + 24) && *v10 == a2)
    {
      v53 = 0u;
      v54 = 0u;
      v51 = 0u;
      v52 = 0u;
      v49 = 0u;
      v50 = 0u;
      v47 = 0u;
      v48 = 0u;
      v45 = 0u;
      v46 = 0u;
      v43 = 0u;
      v44 = 0u;
      v41 = 0u;
      v42 = 0u;
      v39 = 0u;
      v40 = 0u;
      v37 = 0u;
      v38 = 0u;
      v35 = 0u;
      v36 = 0u;
      v33 = 0u;
      v34 = 0u;
      v31 = 0u;
      v32 = 0u;
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      v25 = 0u;
      v26 = 0u;
      *(_OWORD *)buf = 0u;
      v24 = 0u;
      GetMacroContext(*(void **)(v4 + 184), buf);
      if (!buf[0])
      {
        v12 = ci_logger_render();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          v13 = *(_QWORD *)(v4 + 184);
          *(_DWORD *)v59 = 134349056;
          v60 = v13;
          _os_log_error_impl(&dword_1921E4000, v12, OS_LOG_TYPE_ERROR, "Unable to get macro state for the GLContext: %{public}p.\n", v59, 0xCu);
        }
      }
      (*((void (**)(_QWORD, uint64_t, char *))&v36 + 1))(*(_QWORD *)&buf[8], 1, (char *)v56 + 8);
      CFRelease(*v56);
      *v56 = 0;
      std::list<CI::attached_surface_t *>::remove(*(_QWORD **)(v4 + 176), &v56);
      free(v56);
      v8 = *(_QWORD *)(v4 + 176);
    }
  }
  v14 = *(_QWORD *)(v4 + 136);
  v15 = *(_QWORD *)(v14 + 8);
  if (v15 != v14)
  {
    do
    {
      v16 = v15 + 8;
      v15 = *(_QWORD *)(v15 + 8);
      v56 = *(CFTypeRef **)(v16 + 8);
      if ((CFTypeRef)(*(uint64_t (**)(CFTypeRef *))*v56)(v56) == a2)
      {
        v53 = 0u;
        v54 = 0u;
        v51 = 0u;
        v52 = 0u;
        v49 = 0u;
        v50 = 0u;
        v47 = 0u;
        v48 = 0u;
        v45 = 0u;
        v46 = 0u;
        v43 = 0u;
        v44 = 0u;
        v41 = 0u;
        v42 = 0u;
        v39 = 0u;
        v40 = 0u;
        v37 = 0u;
        v38 = 0u;
        v35 = 0u;
        v36 = 0u;
        v33 = 0u;
        v34 = 0u;
        v31 = 0u;
        v32 = 0u;
        v29 = 0u;
        v30 = 0u;
        v27 = 0u;
        v28 = 0u;
        v25 = 0u;
        v26 = 0u;
        *(_OWORD *)buf = 0u;
        v24 = 0u;
        GetMacroContext(*(void **)(v4 + 184), buf);
        if (!buf[0])
        {
          v17 = ci_logger_render();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            v19 = *(_QWORD *)(v4 + 184);
            *(_DWORD *)v59 = 134349056;
            v60 = v19;
            _os_log_error_impl(&dword_1921E4000, v17, OS_LOG_TYPE_ERROR, "Unable to get macro state for the GLContext: %{public}p.\n", v59, 0xCu);
          }
        }
        *(_DWORD *)v59 = 0;
        *(_DWORD *)v59 = (*((uint64_t (**)(CFTypeRef *))*v56 + 3))(v56);
        v55(*(_QWORD *)&buf[8]);
        (*((void (**)(_QWORD, uint64_t, uint8_t *))&v36 + 1))(*(_QWORD *)&buf[8], 1, v59);
        std::list<CI::attached_surface_t *>::remove(*(_QWORD **)(v4 + 136), &v56);
        v18 = (const void *)(*(uint64_t (**)(CFTypeRef *))*v56)(v56);
        CFRelease(v18);
        if (v56)
          (*((void (**)(CFTypeRef *))*v56 + 6))(v56);
      }
    }
    while (v15 != *(_QWORD *)(v4 + 136));
  }
  v20 = ci_signpost_log_render();
  v21 = v58;
  if (v58 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v22 = v20;
    if (os_signpost_enabled(v20))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v22, OS_SIGNPOST_INTERVAL_END, v21, "release_surface_block", (const char *)&unk_192520C83, buf, 2u);
    }
  }
  TimerBase::~TimerBase((TimerBase *)v57);
}

uint64_t std::list<CI::attached_surface_t *>::remove(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v9[2];
  uint64_t v10;

  v9[0] = (uint64_t)v9;
  v9[1] = (uint64_t)v9;
  v10 = 0;
  v2 = (_QWORD *)a1[1];
  if (v2 == a1)
  {
    v7 = 0;
  }
  else
  {
    while (1)
    {
      v6 = (_QWORD *)v2[1];
      v5 = v2[2];
      if (v5 == *a2)
        break;
LABEL_8:
      v2 = v6;
      if (v6 == a1)
        goto LABEL_11;
    }
    while (v6 != a1)
    {
      if (v6[2] != v5)
      {
        std::list<CI::attached_surface_t *>::splice((uint64_t)v9, v9, (uint64_t)a1, v2, v6);
        v6 = (_QWORD *)v6[1];
        goto LABEL_8;
      }
      v6 = (_QWORD *)v6[1];
    }
    std::list<CI::attached_surface_t *>::splice((uint64_t)v9, v9, (uint64_t)a1, v2, a1);
LABEL_11:
    v7 = v10;
  }
  std::__list_imp<CI::attached_surface_t *>::clear(v9);
  return v7;
}

void CI::GLTextureManager::~GLTextureManager(CI::GLTextureManager *this)
{
  NSObject *v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD v8[5];
  uint64_t block;
  uint64_t v10;
  void *v11;
  void *v12;
  CI::GLTextureManager *v13;
  uint64_t v14;

  *(_QWORD *)this = &off_1E2EBCBC0;
  v2 = *((_QWORD *)this + 12);
  v3 = MEMORY[0x1E0C809B0];
  block = MEMORY[0x1E0C809B0];
  v10 = 0x40000000;
  v11 = ___ZN2CI16GLTextureManager19purge_intermediatesEm_block_invoke;
  v12 = &__block_descriptor_tmp_9_2;
  v13 = this;
  v14 = 0;
  dispatch_async(v2, &block);
  dispatch_sync(*((dispatch_queue_t *)this + 12), &__block_literal_global_84);
  CI::TextureManager::remove_all(this);
  if (CI_RECYCLE_OPENGL_TEXTURES() && CI_IOSURFACE_INTERMEDIATES())
    RemoveReleaseSurfaceBlock(*((_QWORD *)this + 13));
  v4 = *((_QWORD *)this + 13);
  block = v3;
  v10 = 0x40000000;
  v11 = ___ZN2CI16GLTextureManager23purge_attached_surfacesEm_block_invoke;
  v12 = &__block_descriptor_tmp_15_2;
  v13 = this;
  v14 = 0;
  dispatch_sync(v4, &block);
  v5 = *((_QWORD *)this + 22);
  if (v5)
  {
    std::__list_imp<CI::attached_surface_t *>::clear(*((_QWORD **)this + 22));
    MEMORY[0x194025AAC](v5, 0x1020C4062D53EE8);
  }
  v6 = *((_QWORD *)this + 23);
  v7 = *((_QWORD *)this + 13);
  v8[0] = v3;
  v8[1] = 0x40000000;
  v8[2] = ___ZN2CI16GLTextureManagerD2Ev_block_invoke_2;
  v8[3] = &__block_descriptor_tmp_3_3;
  v8[4] = v6;
  dispatch_async(v7, v8);
  CI::TextureManager::~TextureManager((dispatch_queue_t *)this);
}

{
  CI::GLTextureManager::~GLTextureManager(this);
  JUMPOUT(0x194025AACLL);
}

void ___ZN2CI16GLTextureManagerD2Ev_block_invoke_2(uint64_t a1)
{
  CIEAGLContextRelease(*(void **)(a1 + 32));
}

uint64_t CI::GLTextureManager::create_intermediate(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  BOOL v7;
  uint64_t v8;
  int API;
  int v15;
  NSObject *v16;
  _QWORD block[8];
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD v27[5];
  uint64_t v28;
  int v29;
  int v30;
  __int16 v31;
  __int128 v32;

  v32 = *(_OWORD *)(a5 + 8);
  if (*(_QWORD *)(a5 + 8))
    v7 = *(_QWORD *)(a5 + 16) == 0;
  else
    v7 = 1;
  if (v7)
    return 0;
  v30 = *a2;
  v31 = 0;
  if ((a2[1] & 2) != 0)
    LOBYTE(v31) = 1;
  v27[0] = 0;
  v27[1] = v27;
  v27[2] = 0x3802000000;
  v27[3] = __Block_byref_object_copy__21;
  v27[4] = __Block_byref_object_dispose__21;
  v28 = 0;
  v29 = 0;
  API = CIEAGLContextGetAPI(*(void **)(*(_QWORD *)(a1 + 168) + 392));
  v28 = CI::gl_format_info_for_format((uint64_t)&v30, API);
  v29 = v15;
  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = 0;
  v16 = *(NSObject **)(a1 + 104);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke;
  block[3] = &unk_1E2EC6250;
  block[6] = a1;
  block[7] = a3;
  v19 = v32;
  block[4] = &v23;
  block[5] = v27;
  v20 = a5;
  v21 = a6;
  v22 = a7;
  dispatch_sync(v16, block);
  v8 = v24[3];
  _Block_object_dispose(&v23, 8);
  _Block_object_dispose(v27, 8);
  return v8;
}

uint64_t __Block_byref_object_copy__21(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 40);
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = v2;
  return result;
}

uint64_t CI::gl_format_info_for_format(uint64_t a1, int a2)
{
  uint64_t result;
  int v4;
  int v5;
  int v6;

  result = 0;
  v4 = *(_DWORD *)a1;
  if (*(int *)a1 <= 2048)
  {
    if (v4 <= 532)
    {
      v5 = v4 - 257;
      v6 = 9;
      switch(v5)
      {
        case 0:
        case 1:
          return CIGLGetFormatInfo(a2, v6);
        case 2:
          v6 = 10;
          return CIGLGetFormatInfo(a2, v6);
        case 3:
          v6 = 11;
          return CIGLGetFormatInfo(a2, v6);
        case 4:
          v6 = 12;
          return CIGLGetFormatInfo(a2, v6);
        case 5:
          v6 = 16;
          return CIGLGetFormatInfo(a2, v6);
        case 6:
          v6 = 20;
          return CIGLGetFormatInfo(a2, v6);
        case 7:
        case 11:
          if (*(_BYTE *)(a1 + 4))
            v6 = 7;
          else
            v6 = 2;
          return CIGLGetFormatInfo(a2, v6);
        case 9:
        case 13:
          if (*(_BYTE *)(a1 + 4))
            v6 = 6;
          else
            v6 = 1;
          return CIGLGetFormatInfo(a2, v6);
        case 17:
          v6 = 26;
          return CIGLGetFormatInfo(a2, v6);
        case 19:
          v6 = 24;
          return CIGLGetFormatInfo(a2, v6);
        case 20:
          goto LABEL_27;
        default:
          return result;
      }
      return result;
    }
    if (v4 > 783)
    {
      switch(v4)
      {
        case 1793:
        case 1794:
        case 1795:
        case 1797:
          goto LABEL_32;
        case 1796:
        case 1798:
          goto LABEL_31;
        case 1799:
          v6 = 21;
          return CIGLGetFormatInfo(a2, v6);
        case 1800:
        case 1804:
          v6 = 3;
          return CIGLGetFormatInfo(a2, v6);
        case 1801:
        case 1802:
        case 1803:
          return result;
        default:
          if (v4 == 784)
          {
            v6 = 27;
          }
          else
          {
            if (v4 != 785)
              return result;
            v6 = 28;
          }
          break;
      }
      return CIGLGetFormatInfo(a2, v6);
    }
    if (v4 <= 772)
    {
      if (v4 != 533)
      {
        if (v4 != 771)
          return result;
        goto LABEL_32;
      }
LABEL_27:
      v6 = 25;
      return CIGLGetFormatInfo(a2, v6);
    }
    if (v4 != 773)
    {
      if (v4 != 774)
        return result;
LABEL_31:
      v6 = 17;
      return CIGLGetFormatInfo(a2, v6);
    }
    goto LABEL_32;
  }
  if (v4 <= 2304)
  {
    switch(v4)
    {
      case 2049:
      case 2050:
      case 2051:
      case 2053:
        v6 = 14;
        return CIGLGetFormatInfo(a2, v6);
      case 2052:
      case 2054:
        v6 = 18;
        return CIGLGetFormatInfo(a2, v6);
      case 2055:
        v6 = 22;
        return CIGLGetFormatInfo(a2, v6);
      case 2056:
      case 2060:
        v6 = 4;
        return CIGLGetFormatInfo(a2, v6);
      default:
        return result;
    }
  }
  else
  {
    if (v4 > 2566)
    {
      if (v4 <= 3332)
      {
        if (v4 == 2567)
        {
          v6 = 8;
          return CIGLGetFormatInfo(a2, v6);
        }
        if (v4 != 3331)
          return result;
        goto LABEL_32;
      }
      if (v4 != 3333)
      {
        if (v4 != 3334)
          return result;
        goto LABEL_31;
      }
LABEL_32:
      v6 = 13;
      return CIGLGetFormatInfo(a2, v6);
    }
    switch(v4)
    {
      case 2305:
      case 2306:
      case 2307:
      case 2309:
        v6 = 15;
        return CIGLGetFormatInfo(a2, v6);
      case 2308:
      case 2310:
        v6 = 19;
        return CIGLGetFormatInfo(a2, v6);
      case 2311:
        v6 = 23;
        return CIGLGetFormatInfo(a2, v6);
      case 2312:
      case 2316:
        v6 = 5;
        return CIGLGetFormatInfo(a2, v6);
      default:
        return result;
    }
  }
  return result;
}

void ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke(uint64_t a1)
{
  void **v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  void (*v11)(uint64_t, uint64_t, uint64_t);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float64x2_t *v16;
  __int128 v17;
  uint64_t *v18;
  uint64_t v19;
  uint64x2_t v20;
  int v21;
  float64x2_t v22;
  float64x2_t v23;
  int64x2_t v24;
  float64x2_t *v25;
  uint64_t v26;
  uint64_t v27;
  _BOOL8 v28;
  void *v29;
  uint64_t v30;
  void **v31;
  uint64_t v32;
  _DWORD *v33;
  GLint v34;
  signed int v35;
  signed int v36;
  uint64_t (***v37)(_QWORD);
  __IOSurface *v38;
  uint64_t *v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  uint64_t (***v46)(_QWORD);
  unint64_t v47;
  uint64_t (***v48)(_QWORD);
  const void *v49;
  uint64_t *v50;
  uint64_t v51;
  uint64x2_t v52;
  int v53;
  float64x2_t *v54;
  float64x2_t v55;
  float64x2_t v56;
  int64x2_t v57;
  float64x2_t *v58;
  int v59;
  _OWORD v60[4];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  void (*v89)(uint64_t, uint64_t);
  CGSize v90;

  v2 = *(void ***)(a1 + 48);
  v87 = 0u;
  v88 = 0u;
  v85 = 0u;
  v86 = 0u;
  v83 = 0u;
  v84 = 0u;
  v81 = 0u;
  v82 = 0u;
  v79 = 0u;
  v80 = 0u;
  v77 = 0u;
  v78 = 0u;
  v75 = 0u;
  v76 = 0u;
  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  memset(v60, 0, sizeof(v60));
  GetMacroContext(v2[23], v60);
  if (!LOBYTE(v60[0]))
  {
    v3 = ci_logger_render();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  v90.width = (double)*(unint64_t *)(a1 + 64);
  v90.height = (double)*(unint64_t *)(a1 + 72);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CI::TextureManager::_find_match_for_surface((CI::TextureManager *)v2, *(IOSurfaceRef *)(a1 + 56), v90);
  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(*(_QWORD *)(v4 + 8) + 24);
  if (v5)
  {
    v6 = v89;
    v7 = *((_QWORD *)&v60[0] + 1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    v6(v7, v8);
    v4 = *(_QWORD *)(a1 + 32);
    v9 = *(_QWORD *)(*(_QWORD *)(v4 + 8) + 24);
    v59 = 0;
    if (v9)
    {
      v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
      v4 = *(_QWORD *)(a1 + 32);
      if (v10)
      {
        v11 = (void (*)(uint64_t, uint64_t, uint64_t))*((_QWORD *)&v61 + 1);
        v12 = *((_QWORD *)&v60[0] + 1);
        v13 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v4 + 8) + 24) + 24))(*(_QWORD *)(*(_QWORD *)(v4 + 8) + 24));
        v11(v12, 3553, v13);
        ((void (*)(_QWORD, uint64_t, _QWORD, uint64_t, int *))v86)(*((_QWORD *)&v60[0] + 1), 3553, 0, 4099, &v59);
        (*((void (**)(_QWORD, uint64_t, _QWORD))&v61 + 1))(*((_QWORD *)&v60[0] + 1), 3553, 0);
        v4 = *(_QWORD *)(a1 + 32);
      }
    }
  }
  else
  {
    v59 = 0;
  }
  v14 = *(_QWORD *)(*(_QWORD *)(v4 + 8) + 24);
  if (v14
    && !*(_QWORD *)(v14 + 64)
    && CI_RECYCLE_OPENGL_TEXTURES()
    && v59 == *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40))
  {
    v50 = *(uint64_t **)(a1 + 80);
    v51 = *v50;
    v52 = *(uint64x2_t *)(v50 + 1);
    v53 = *v50;
    if (v53 == -2147483647)
    {
      if (HIDWORD(v51) == -2147483647 && *(_OWORD *)&v52 == __PAIR128__(0xFFFFFFFFLL, 0xFFFFFFFFLL))
      {
        v54 = (float64x2_t *)MEMORY[0x1E0C9D5E0];
        goto LABEL_38;
      }
    }
    else if (v53 == 0x7FFFFFFF && HIDWORD(v51) == 0x7FFFFFFF && *(_OWORD *)&v52 == 0)
    {
      v54 = (float64x2_t *)MEMORY[0x1E0C9D628];
LABEL_38:
      v56 = *v54;
      v55 = v54[1];
LABEL_40:
      v58 = *(float64x2_t **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      v58[2] = v56;
      v58[3] = v55;
      v42 = *(_QWORD *)(a1 + 88);
      v45 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 64);
      goto LABEL_22;
    }
    v57.i64[0] = (int)v51;
    v57.i64[1] = SHIDWORD(v51);
    v56 = vcvtq_f64_s64(v57);
    v55 = vcvtq_f64_u64(v52);
    goto LABEL_40;
  }
  v15 = operator new();
  *(_QWORD *)v15 = off_1E2EBAFD0;
  *(_QWORD *)(v15 + 8) = 0;
  *(_QWORD *)(v15 + 24) = 0;
  v16 = (float64x2_t *)MEMORY[0x1E0C9D628];
  v17 = *(_OWORD *)(MEMORY[0x1E0C9D628] + 16);
  *(_OWORD *)(v15 + 32) = *MEMORY[0x1E0C9D628];
  *(_OWORD *)(v15 + 48) = v17;
  *(_QWORD *)(v15 + 64) = 0;
  *(_WORD *)(v15 + 72) = 1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v15;
  v18 = *(uint64_t **)(a1 + 80);
  v19 = *v18;
  v20 = *(uint64x2_t *)(v18 + 1);
  v21 = *v18;
  if (v21 != -2147483647)
  {
    if (v21 == 0x7FFFFFFF && HIDWORD(v19) == 0x7FFFFFFF && *(_OWORD *)&v20 == 0)
      goto LABEL_19;
LABEL_20:
    v24.i64[0] = (int)v19;
    v24.i64[1] = SHIDWORD(v19);
    v23 = vcvtq_f64_s64(v24);
    v22 = vcvtq_f64_u64(v20);
    goto LABEL_21;
  }
  if (HIDWORD(v19) != -2147483647 || *(_OWORD *)&v20 != __PAIR128__(0xFFFFFFFFLL, 0xFFFFFFFFLL))
    goto LABEL_20;
  v16 = (float64x2_t *)MEMORY[0x1E0C9D5E0];
LABEL_19:
  v23 = *v16;
  v22 = v16[1];
LABEL_21:
  v25 = *(float64x2_t **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v25[2] = v23;
  v25[3] = v22;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 64) = *(_QWORD *)(a1 + 88);
  v26 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v27 = *(_QWORD *)(a1 + 56);
  v28 = CI_RECYCLE_OPENGL_TEXTURES() != 0;
  (*(void (**)(uint64_t, uint64_t, _BOOL8))(*(_QWORD *)v26 + 56))(v26, v27, v28);
  (*((void (**)(_QWORD, uint64_t, uint64_t))&v79 + 1))(*((_QWORD *)&v60[0] + 1), 1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 8);
  (*((void (**)(_QWORD, uint64_t, _QWORD))&v61 + 1))(*((_QWORD *)&v60[0] + 1), 3553, *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 8));
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 12) = 3553;
  v29 = v2[23];
  v30 = *(unsigned int *)(a1 + 64);
  v31 = v2;
  v32 = *(unsigned int *)(a1 + 72);
  v33 = *(_DWORD **)(*(_QWORD *)(a1 + 40) + 8);
  v34 = v33[10];
  v35 = v33[11];
  v36 = v33[12];
  v37 = *(uint64_t (****)(_QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v38 = (__IOSurface *)(**v37)(v37);
  ((void (*)(_QWORD, uint64_t))v85)(*((_QWORD *)&v60[0] + 1), 7936);
  CIEAGLContextTexImageIOSurface(v29, 0xDE1u, v30, v32, v34, v35, v36, v38, 0);
  v39 = (uint64_t *)v31[17];
  v40 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v41 = operator new(0x18uLL);
  v42 = 1;
  v43 = *(_QWORD *)(v40 + 24);
  v41[1] = v39;
  v41[2] = v43;
  v44 = *v39;
  *v41 = *v39;
  *(_QWORD *)(v44 + 8) = v41;
  *v39 = (uint64_t)v41;
  v45 = v39 + 2;
LABEL_22:
  *v45 += v42;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 72) = *(_BYTE *)(a1 + 96);
  v46 = *(uint64_t (****)(_QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v46 && (**v46)(v46) && *(_QWORD *)(a1 + 88) >= 2uLL)
  {
    v47 = 1;
    do
    {
      v48 = *(uint64_t (****)(_QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      v49 = (const void *)(**v48)(v48);
      RetainSurfaceFromCache(v49);
      ++v47;
    }
    while (v47 < *(_QWORD *)(a1 + 88));
  }
}

uint64_t CI::GLTextureManager::create_intermediate(_QWORD *a1, int *a2, uint64_t a3, CGFloat *a4, uint64_t a5, uint64_t a6, char a7)
{
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  CGFloat v17;
  BOOL v18;
  uint64_t v19;
  int API;
  int v21;
  NSObject *v22;
  uint64_t v23;
  _QWORD v25[11];
  __int128 v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  CGFloat *v30;
  uint64_t v31;
  char v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD v45[5];
  uint64_t v46;
  int v47;
  int v48;
  __int16 v49;
  __int128 v50;
  _BYTE v51[24];
  CGRect v52;
  CGRect v53;
  CGRect v54;
  CGRect v55;
  CGRect v56;

  v14 = *a4;
  v15 = a4[1];
  v16 = a4[2];
  v17 = a4[3];
  v52.origin.x = *a4;
  v52.origin.y = v15;
  v52.size.width = v16;
  v52.size.height = v17;
  if (CGRectIsNull(v52))
    return 0;
  v53.origin.x = v14;
  v53.origin.y = v15;
  v53.size.width = v16;
  v53.size.height = v17;
  if (!CGRectIsInfinite(v53))
  {
    v54.origin.x = v14;
    v54.origin.y = v15;
    v54.size.width = v16;
    v54.size.height = v17;
    v55 = CGRectInset(v54, 0.000001, 0.000001);
    v56 = CGRectIntegral(v55);
    *(_DWORD *)v51 = (int)v56.origin.x;
    *(_DWORD *)&v51[4] = (int)v56.origin.y;
    *(_QWORD *)&v51[8] = (unint64_t)v56.size.width;
    *(_QWORD *)&v51[16] = (unint64_t)v56.size.height;
    v50 = *(_OWORD *)&v51[8];
    if ((unint64_t)v56.size.width)
      v18 = (unint64_t)v56.size.height == 0;
    else
      v18 = 1;
    if (!v18)
      goto LABEL_10;
    return 0;
  }
  *(_OWORD *)v51 = IRectInfinite;
  *(_QWORD *)&v51[16] = 0xFFFFFFFFLL;
  v50 = *(_OWORD *)&v51[8];
LABEL_10:
  v48 = *a2;
  v49 = 0;
  if ((a2[1] & 2) != 0)
    LOBYTE(v49) = 1;
  v45[0] = 0;
  v45[1] = v45;
  v45[2] = 0x3802000000;
  v45[3] = __Block_byref_object_copy__21;
  v45[4] = __Block_byref_object_dispose__21;
  v46 = 0;
  v47 = 0;
  API = CIEAGLContextGetAPI(*(void **)(a1[21] + 392));
  v46 = CI::gl_format_info_for_format((uint64_t)&v48, API);
  v47 = v21;
  v41 = 0;
  v42 = &v41;
  v43 = 0x2000000000;
  v44 = 0;
  v37 = 0;
  v38 = &v37;
  v39 = 0x2000000000;
  v40 = 0;
  v33 = 0;
  v34 = &v33;
  v35 = 0x2000000000;
  v36 = 0;
  v22 = a1[13];
  v25[0] = MEMORY[0x1E0C809B0];
  v25[1] = 0x40000000;
  v25[2] = ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorENS_17NodeContentDigestERK6CGRectmmb_block_invoke;
  v25[3] = &unk_1E2EC6278;
  v25[8] = a1;
  v25[9] = a3;
  v25[10] = a2;
  v32 = a7;
  v25[4] = v45;
  v25[5] = &v37;
  v27 = *(_QWORD *)&v51[16];
  v26 = *(_OWORD *)v51;
  v28 = v50;
  v25[6] = &v33;
  v25[7] = &v41;
  v29 = a5;
  v30 = a4;
  v31 = a6;
  dispatch_sync(v22, v25);
  v23 = v38[3];
  if (v23)
    v19 = (*(uint64_t (**)(_QWORD *, int *, uint64_t, _QWORD, _BYTE *, uint64_t, _QWORD))(*a1 + 48))(a1, a2, v23, 0, v51, a6, *((unsigned __int8 *)v34 + 24));
  else
    v19 = v42[3];
  _Block_object_dispose(&v33, 8);
  _Block_object_dispose(&v37, 8);
  _Block_object_dispose(&v41, 8);
  _Block_object_dispose(v45, 8);
  return v19;
}

void ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorENS_17NodeContentDigestERK6CGRectmmb_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  CFStringRef v4;
  int v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  __int128 v10;
  _OWORD *v11;
  uint64_t v12;
  __int128 v13;
  void (*v14)(uint64_t, uint64_t, uint64_t);
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  __CFArray *theArray;
  uint64_t v26;
  uint64_t i;
  uint64_t v28;
  const void *v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  int v33;
  __int128 v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  _OWORD v42[4];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  void (*v71)(_QWORD, uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, unsigned int, _QWORD);

  v2 = *(_QWORD *)(a1 + 64);
  v69 = 0u;
  v70 = 0u;
  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  memset(v42, 0, sizeof(v42));
  GetMacroContext(*(void **)(v2 + 184), v42);
  if (!LOBYTE(v42[0]))
  {
    v3 = ci_logger_render();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  if (CI_IOSURFACE_INTERMEDIATES())
  {
    v4 = CFStringCreateWithFormat(0, 0, CFSTR("%llX(%04x,%04x,%04x)"), *(_QWORD *)(a1 + 72), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 44), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48));
    v5 = CI::PixelFormatType_from_format(**(_DWORD **)(a1 + 80));
    if (*(_BYTE *)(a1 + 152))
    {
      v40 = *(_OWORD *)(a1 + 88);
      v41 = *(_QWORD *)(a1 + 104);
      LODWORD(v38) = 0;
      v6 = *(_QWORD **)(v2 + 168);
      v7 = v6[47];
      *((_QWORD *)&v38 + 1) = 0;
      v39 = v7;
      v8 = (*(uint64_t (**)(_QWORD *))(*v6 + 272))(v6);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = GetValidSurfaceFromCache(&v40, v5, &v38, v8, 0, *(_DWORD *)(*(_QWORD *)(a1 + 80) + 12), (uint64_t)v4);
    }
    else
    {
      theArray = CFArrayCreateMutable(0, *(_QWORD *)(*(_QWORD *)(v2 + 136) + 16), 0);
      if (CI_RECYCLE_OPENGL_TEXTURES())
      {
        v26 = *(_QWORD *)(v2 + 136);
        for (i = *(_QWORD *)(v26 + 8); i != v26; i = *(_QWORD *)(i + 8))
        {
          v28 = *(_QWORD *)(i + 16);
          if (!(*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 16))(v28)
            && *(double *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 32))(v28) + 16) == (double)*(unint64_t *)(a1 + 112)
            && *(double *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 32))(v28) + 24) == (double)*(unint64_t *)(a1 + 120))
          {
            v29 = (const void *)(**(uint64_t (***)(uint64_t))v28)(v28);
            CFArrayAppendValue(theArray, v29);
          }
        }
      }
      v30 = *(_QWORD *)(a1 + 128);
      v36 = *(_OWORD *)(a1 + 88);
      v37 = *(_QWORD *)(a1 + 104);
      LODWORD(v34) = 0;
      v31 = *(_QWORD **)(v2 + 168);
      v32 = v31[47];
      *((_QWORD *)&v34 + 1) = 0;
      v35 = v32;
      v33 = (*(uint64_t (**)(_QWORD *))(*v31 + 272))(v31);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = GetSurfaceFromCache(&v36, v30, v30, v5, &v34, v33, 0, *(_DWORD *)(*(_QWORD *)(a1 + 80) + 12), (uint64_t)v4, *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24, theArray);
      CFRelease(theArray);
    }
    CFRelease(v4);
  }
  else if (!*(_BYTE *)(a1 + 152))
  {
    v9 = operator new();
    *(_QWORD *)v9 = off_1E2EBAFD0;
    *(_QWORD *)(v9 + 8) = 0;
    *(_QWORD *)(v9 + 24) = 0;
    v10 = *(_OWORD *)(MEMORY[0x1E0C9D628] + 16);
    *(_OWORD *)(v9 + 32) = *MEMORY[0x1E0C9D628];
    *(_OWORD *)(v9 + 48) = v10;
    *(_QWORD *)(v9 + 64) = 0;
    *(_WORD *)(v9 + 72) = 1;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = v9;
    v11 = *(_OWORD **)(a1 + 136);
    v12 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
    v13 = v11[1];
    *(_OWORD *)(v12 + 32) = *v11;
    *(_OWORD *)(v12 + 48) = v13;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) + 64) = *(_QWORD *)(a1 + 144);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) + 24) = 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) + 72) = 1;
    (*((void (**)(_QWORD, uint64_t, uint64_t))&v61 + 1))(*((_QWORD *)&v42[0] + 1), 1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) + 8);
    v14 = (void (*)(uint64_t, uint64_t, uint64_t))*((_QWORD *)&v43 + 1);
    v15 = *((_QWORD *)&v42[0] + 1);
    v16 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
    v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 24))(v16);
    v14(v15, 3553, v17);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) + 12) = 3553;
    v18 = *(unsigned int **)(*(_QWORD *)(a1 + 32) + 8);
    v19 = v18[10];
    if ((_DWORD)v19 == 35906)
    {
      v18[11] = 35906;
      v18 = *(unsigned int **)(*(_QWORD *)(a1 + 32) + 8);
      v19 = v18[10];
    }
    v71(*((_QWORD *)&v42[0] + 1), 3553, 0, v19, *(unsigned int *)(a1 + 112), *(unsigned int *)(a1 + 120), 0, v18[11], v18[12], 0);
    v20 = *(uint64_t **)(v2 + 136);
    v21 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
    v22 = operator new(0x18uLL);
    v23 = *(_QWORD *)(v21 + 24);
    v22[1] = v20;
    v22[2] = v23;
    v24 = *v20;
    *v22 = *v20;
    *(_QWORD *)(v24 + 8) = v22;
    *v20 = (uint64_t)v22;
    ++v20[2];
  }
}

uint64_t CI::GLTextureManager::wiredBytes(CI::GLTextureManager *this)
{
  NSObject *v1;
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v1 = *((_QWORD *)this + 13);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ___ZN2CI16GLTextureManager10wiredBytesEv_block_invoke;
  v4[3] = &unk_1E2EC62A0;
  v4[4] = &v5;
  v4[5] = this;
  dispatch_sync(v1, v4);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t ___ZN2CI16GLTextureManager10wiredBytesEv_block_invoke(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __IOSurface *v5;
  __IOSurface *v6;

  v1 = *(_QWORD *)(*(_QWORD *)(result + 40) + 136);
  v2 = *(_QWORD *)(v1 + 8);
  if (v2 != v1)
  {
    v3 = result;
    do
    {
      v4 = *(_QWORD *)(v2 + 16);
      v5 = (__IOSurface *)(**(uint64_t (***)(uint64_t))v4)(v4);
      result = SurfaceIsVolatileEmpty(v5);
      if ((result & 1) == 0)
      {
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
        if (!result)
        {
          v6 = (__IOSurface *)(**(uint64_t (***)(uint64_t))v4)(v4);
          result = SurfaceGetMemorySize(v6);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) += result;
        }
      }
      v2 = *(_QWORD *)(v2 + 8);
    }
    while (v2 != v1);
  }
  return result;
}

void CI::GLTextureManager::purge_intermediates(CI::GLTextureManager *this, uint64_t a2)
{
  NSObject *v2;
  _QWORD v3[6];

  v2 = *((_QWORD *)this + 12);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = ___ZN2CI16GLTextureManager19purge_intermediatesEm_block_invoke;
  v3[3] = &__block_descriptor_tmp_9_2;
  v3[4] = this;
  v3[5] = a2;
  dispatch_async(v2, v3);
}

void ___ZN2CI16GLTextureManager19purge_intermediatesEm_block_invoke(uint64_t a1)
{
  CI::TextureManager *v2;
  NSObject *v3;
  uint64_t v4;
  _QWORD v5[6];

  v2 = *(CI::TextureManager **)(a1 + 32);
  if (CI_RECYCLE_OPENGL_TEXTURES() && CI_IOSURFACE_INTERMEDIATES())
  {
    v3 = *((_QWORD *)v2 + 13);
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 0x40000000;
    v5[2] = ___ZN2CI16GLTextureManager19purge_intermediatesEm_block_invoke_2;
    v5[3] = &__block_descriptor_tmp_8_2;
    v4 = *(_QWORD *)(a1 + 40);
    v5[4] = v2;
    v5[5] = v4;
    dispatch_sync(v3, v5);
  }
  CI::TextureManager::purge_intermediates(v2);
}

uint64_t CI::GLTextureManager::_release_intermediate(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (!CI_RECYCLE_OPENGL_TEXTURES())
    return CI::TextureManager::_release_intermediate(a1, a2);
  result = CI_IOSURFACE_INTERMEDIATES();
  if (!(_DWORD)result)
    return CI::TextureManager::_release_intermediate(a1, a2);
  return result;
}

void CI::GLTextureManager::release_texture(CI::GLTextureManager *this, Texture a2)
{
  unsigned int var0;
  void *v3;
  CI::Context *v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD v13[13];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _QWORD block[5];
  unsigned int v34;
  Texture v35;

  var0 = a2.var0.var1.var0;
  v35 = a2;
  if (a2.var0.var1.var0)
  {
    v3 = *(void **)(*((_QWORD *)this + 21) + 416);
    v4 = (CI::Context *)CI_IOSURFACE_INTERMEDIATES();
    if ((_DWORD)v4)
    {
      v5 = CI::Context::render_completion_queue(v4);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = ___ZNK2CI16GLTextureManager15release_textureENS_7TextureE_block_invoke;
      block[3] = &__block_descriptor_tmp_10_1;
      block[4] = v3;
      v34 = var0;
      dispatch_async(v5, block);
    }
    else
    {
      v31 = 0u;
      v32 = 0u;
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      v25 = 0u;
      v26 = 0u;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v17 = 0u;
      v18 = 0u;
      v15 = 0u;
      v16 = 0u;
      v14 = 0u;
      memset(v13, 0, sizeof(v13));
      GetMacroContext(v3, v13);
      if (!LOBYTE(v13[0]))
      {
        v6 = ci_logger_render();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          CI::GLTextureManager::release_texture((uint64_t)v3, v6, v7, v8, v9, v10, v11, v12);
      }
      (*((void (**)(_QWORD, uint64_t, Texture *))&v14 + 1))(*((_QWORD *)&v13[0] + 1), 1, &v35);
    }
  }
}

uint64_t ___ZNK2CI16GLTextureManager15release_textureENS_7TextureE_block_invoke(uint64_t a1)
{
  NSObject *v2;
  _OWORD v4[13];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  void (*v24)(_QWORD, _QWORD);

  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  v5 = 0u;
  memset(v4, 0, sizeof(v4));
  GetMacroContext(*(void **)(a1 + 32), v4);
  if (!LOBYTE(v4[0]))
  {
    v2 = ci_logger_render();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  v24(*((_QWORD *)&v4[0] + 1), *(unsigned int *)(a1 + 40));
  return (*((uint64_t (**)(_QWORD, uint64_t, uint64_t))&v5 + 1))(*((_QWORD *)&v4[0] + 1), 1, a1 + 40);
}

uint64_t CI::GLTextureManager::upload_texture(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v15;
  int API;
  unint64_t v17;
  int v18;
  _DWORD *v19;
  unsigned int v21;
  unsigned int v22;
  _OWORD v23[4];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  void (*v52)(_QWORD, uint64_t, _QWORD, unint64_t, uint64_t, uint64_t, _QWORD, unint64_t, int, uint64_t);

  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  memset(v23, 0, sizeof(v23));
  GetMacroContext(*(void **)(*(_QWORD *)(a1 + 168) + 392), v23);
  if (!LOBYTE(v23[0]))
  {
    v15 = ci_logger_render();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      CI::GLTextureManager::upload_texture();
  }
  v22 = 0;
  ((void (*)(_QWORD, uint64_t, unsigned int *))v45)(*((_QWORD *)&v23[0] + 1), 32873, &v22);
  v21 = 0;
  (*((void (**)(_QWORD, uint64_t, unsigned int *))&v42 + 1))(*((_QWORD *)&v23[0] + 1), 1, &v21);
  (*((void (**)(_QWORD, uint64_t, _QWORD))&v24 + 1))(*((_QWORD *)&v23[0] + 1), 3553, v21);
  API = CIEAGLContextGetAPI(*(void **)(*(_QWORD *)(a1 + 168) + 392));
  v17 = CI::gl_format_info_for_format(a8, API);
  v52(*((_QWORD *)&v23[0] + 1), 3553, 0, v17, a5, a6, 0, HIDWORD(v17), v18, a4);
  (*((void (**)(_QWORD, uint64_t, _QWORD))&v24 + 1))(*((_QWORD *)&v23[0] + 1), 3553, v22);
  v19 = malloc_type_malloc(0x20uLL, 0x10C20408CADBB15uLL);
  *v19 = v21;
  v19[1] = 3553;
  v19[4] = a3;
  v19[5] = 1;
  *((_BYTE *)v19 + 24) = 0;
  CI::TextureManager::append_to_lru(a1, a2, (uint64_t)v19);
  return v21;
}

uint64_t CI::GLTextureManager::texture_for_CGImage(_QWORD **a1, CGImage *a2, uint64_t a3)
{
  unsigned int *v6;
  uint64_t v7;
  size_t Width;
  size_t Height;
  size_t BytesPerRow;
  size_t BitsPerPixel;
  CGDataProvider *DataProvider;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  size_t v17;
  unint64_t v18;
  const __CFData *v19;
  const __CFData *v20;
  const UInt8 *BytePtr;
  uint64_t v22;
  size_t v23;
  char *v24;
  uint64_t v25;
  char *__dst;
  const __CFData *v27;

  v6 = (unsigned int *)((uint64_t (*)(_QWORD **))(*a1)[1])(a1);
  if (!v6)
  {
    Width = CGImageGetWidth(a2);
    Height = CGImageGetHeight(a2);
    BytesPerRow = CGImageGetBytesPerRow(a2);
    BitsPerPixel = CGImageGetBitsPerPixel(a2);
    if (Width > (*(uint64_t (**)(_QWORD *))(*a1[21] + 440))(a1[21])
      || Height > (*(uint64_t (**)(_QWORD *))(*a1[21] + 440))(a1[21]))
    {
      x_log("Cannot handle a (%lu x %lu) sized texture with the given GLES context!\n", Width, Height);
      return 0;
    }
    DataProvider = CGImageGetDataProvider(a2);
    v14 = CGDataProviderRetainBytePtr();
    if (v14)
    {
      v16 = (char *)v14;
      v27 = 0;
    }
    else
    {
      v19 = CGDataProviderCopyData(DataProvider);
      if (!v19)
        return 0;
      v20 = v19;
      if (CFDataGetLength(v19) < 1 || (BytePtr = CFDataGetBytePtr(v20)) == 0)
      {
        v7 = 0;
LABEL_24:
        CFRelease(v20);
        return v7;
      }
      v16 = (char *)BytePtr;
      v27 = v20;
    }
    v17 = (BitsPerPixel >> 3) * Width;
    v18 = (v17 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    if (BytesPerRow == v18)
    {
      v7 = CI::GLTextureManager::upload_texture((uint64_t)a1, (uint64_t)a2, 1, (uint64_t)v16, Width, Height, v15, a3);
    }
    else
    {
      __dst = (char *)malloc_type_malloc(v18 * Height, 0x4F3E6C1FuLL);
      if (__dst)
      {
        v25 = a3;
        if (Height)
        {
          v23 = Height;
          v24 = __dst;
          do
          {
            memcpy(v24, v16, v17);
            v16 += BytesPerRow;
            v24 += v18;
            --v23;
          }
          while (v23);
        }
        v7 = CI::GLTextureManager::upload_texture((uint64_t)a1, (uint64_t)a2, 1, (uint64_t)__dst, Width, Height, v22, v25);
        free(__dst);
      }
      else
      {
        v7 = 0;
      }
    }
    v20 = v27;
    if (!v27)
    {
      CGDataProviderReleaseBytePtr();
      return v7;
    }
    goto LABEL_24;
  }
  return *v6;
}

uint64_t CI::GLTextureManager::find_attached_surface(CI::GLTextureManager *this, __IOSurface *a2, int a3, int a4, int a5)
{
  _QWORD *v6;
  _QWORD *i;
  uint64_t v8;
  uint64_t *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;

  v6 = (_QWORD *)*((_QWORD *)this + 22);
  for (i = (_QWORD *)v6[1]; ; i = (_QWORD *)i[1])
  {
    if (i == v6)
      return 0;
    v8 = i[2];
    v13 = v8;
    if (*(__IOSurface **)v8 == a2
      && *(unsigned __int8 *)(v8 + 12) == a3
      && *(_DWORD *)(v8 + 20) == a5
      && (!a3 || *(_DWORD *)(v8 + 16) == a4))
    {
      break;
    }
  }
  std::list<CI::attached_surface_t *>::remove(v6, &v13);
  v10 = (uint64_t *)*((_QWORD *)this + 22);
  v11 = operator new(0x18uLL);
  v11[2] = v13;
  v12 = *v10;
  *v11 = *v10;
  v11[1] = v10;
  *(_QWORD *)(v12 + 8) = v11;
  *v10 = (uint64_t)v11;
  ++v10[2];
  return v13;
}

uint64_t CI::GLMainProgram::GLMainProgram(uint64_t a1, const CI::Context *a2, uint64_t a3, const char *a4, const char *a5, uint64_t a6, uint64_t a7)
{
  unsigned int v9;
  int v10;
  int API;
  int v12;
  uint64_t v13;
  unint64_t v14;

  CI::MainProgram::MainProgram((int64x2_t *)a1, a4, a5, a6, a7)[6].i64[0] = (uint64_t)off_1E2EB7738;
  do
    v9 = __ldaxr(&dword_1ECF873D0[13]);
  while (__stlxr(v9 + 1, &dword_1ECF873D0[13]));
  *(_QWORD *)a1 = &off_1E2EB9D80;
  *(_QWORD *)(a1 + 96) = &unk_1E2EB9DE8;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 128) = CIEAGLContextRetain(*((void **)a2 + 49));
  *(_DWORD *)(a1 + 40) = (*(uint64_t (**)(const CI::Context *))(*(_QWORD *)a2 + 272))(a2);
  *(_DWORD *)(a1 + 136) = *((_DWORD *)a2 + 108);
  v10 = CI::MainProgram::vector_arguments_size((CI::MainProgram *)a1, a2);
  if ((*(uint64_t (**)(const CI::Context *))(*(_QWORD *)a2 + 480))(a2) < (unint64_t)v10)
  {
    API = CIEAGLContextGetAPI(*(void **)(a1 + 128));
    v12 = CI::MainProgram::vector_arguments_size((CI::MainProgram *)a1, a2);
    v13 = (*(uint64_t (**)(const CI::Context *))(*(_QWORD *)a2 + 480))(a2);
    x_log("Program exceeds GLES%d uniform size limit. (%d > %zu)\n", API, v12, v13);
  }
  *(_QWORD *)(a1 + 104) = (int)CI::MainProgram::num_arguments((CI::MainProgram *)a1);
  *(_QWORD *)(a1 + 112) = operator new[]();
  *(_QWORD *)(a1 + 120) = operator new[]();
  if (*(_QWORD *)(a1 + 104))
  {
    v14 = 0;
    do
    {
      *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4 * v14) = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)a1 + 40))(a1, v14);
      ++v14;
    }
    while (*(_QWORD *)(a1 + 104) > v14);
  }
  return a1;
}

void CI::GLMainProgram::~GLMainProgram(CI::GLMainProgram *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  _OWORD v6[11];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;

  *(_QWORD *)this = &off_1E2EB9D80;
  *((_QWORD *)this + 12) = &unk_1E2EB9DE8;
  if (*((_DWORD *)this + 35))
  {
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    v10 = 0u;
    v11 = 0u;
    v8 = 0u;
    v9 = 0u;
    v7 = 0u;
    memset(v6, 0, sizeof(v6));
    GetMacroContext(*((void **)this + 16), v6);
    if (!LOBYTE(v6[0]))
    {
      v2 = ci_logger_render();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
    }
    (*((void (**)(_QWORD, _QWORD))&v7 + 1))(*((_QWORD *)&v6[0] + 1), *((unsigned int *)this + 35));
  }
  CIEAGLContextRelease(*((void **)this + 16));
  v3 = *((_QWORD *)this + 14);
  if (v3)
    MEMORY[0x194025A94](v3, 0x1000C8052888210);
  v4 = *((_QWORD *)this + 15);
  if (v4)
    MEMORY[0x194025A94](v4, 0x1000C8052888210);
  *((_QWORD *)this + 12) = off_1E2EB7738;
  do
    v5 = __ldaxr(&dword_1ECF873D0[13]);
  while (__stlxr(v5 - 1, &dword_1ECF873D0[13]));
  CI::MainProgram::~MainProgram(this);
}

{
  CI::GLMainProgram::~GLMainProgram(this);
  JUMPOUT(0x194025AACLL);
}

void `non-virtual thunk to'CI::GLMainProgram::~GLMainProgram(CI::GLMainProgram *this)
{
  CI::GLMainProgram::~GLMainProgram((CI::GLMainProgram *)((char *)this - 96));
}

{
  CI::GLMainProgram::~GLMainProgram((CI::GLMainProgram *)((char *)this - 96));
  JUMPOUT(0x194025AACLL);
}

void CI::GLMainProgram::compile(uint64_t a1, int a2)
{
  NSObject *v4;
  os_signpost_id_t v5;
  NSObject *v6;
  std::chrono::steady_clock::time_point v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  os_signpost_id_t v13;
  NSObject *v14;
  NSObject *v15;
  os_signpost_id_t v16;
  NSObject *v17;
  unint64_t v18;
  uint64_t v19;
  NSObject *v20;
  os_signpost_id_t v21;
  NSObject *v22;
  uint8_t v23[8];
  os_signpost_id_t v24;
  uint8_t buf[16];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  void (*v57)(_QWORD, uint64_t);
  _BYTE v58[8];
  os_signpost_id_t v59;
  uint8_t v60[16];

  if (CI_VERBOSE_SIGNPOSTS())
  {
    v4 = ci_signpost_log_compile();
    v5 = a2 | ((unint64_t)*(unsigned int *)(a1 + 40) << 32);
    if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v6 = v4;
      if (os_signpost_enabled(v4))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v6, OS_SIGNPOST_INTERVAL_BEGIN, v5, "compile_gl", (const char *)&unk_192520C83, buf, 2u);
      }
    }
  }
  TimerBase::TimerBase((uint64_t)v58, *(unsigned int *)(a1 + 40), a2, (uint64_t)"compile_gl", 28);
  v7.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  *(_OWORD *)buf = 0u;
  v26 = 0u;
  GetMacroContext(*(void **)(a1 + 128), buf);
  if (!buf[0])
  {
    v8 = ci_logger_render();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  v9 = *(unsigned int *)(a1 + 136);
  v10 = CI::GLContext::compile_shader(*(unsigned int *)(a1 + 40), a2, *(void **)(a1 + 128), *(_QWORD *)(a1 + 56), 35632);
  v11 = ((uint64_t (*)(_QWORD))v35)(*(_QWORD *)&buf[8]);
  (*((void (**)(_QWORD, uint64_t, uint64_t))&v26 + 1))(*(_QWORD *)&buf[8], v11, v9);
  (*((void (**)(_QWORD, uint64_t, uint64_t))&v26 + 1))(*(_QWORD *)&buf[8], v11, v10);
  (*((void (**)(_QWORD, uint64_t, _QWORD, const char *))&v27 + 1))(*(_QWORD *)&buf[8], v11, 0, "position");
  (*((void (**)(_QWORD, uint64_t, uint64_t, const char *))&v27 + 1))(*(_QWORD *)&buf[8], v11, 1, "texcoord");
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v12 = ci_signpost_log_compile();
    v13 = a2 | ((unint64_t)*(unsigned int *)(a1 + 40) << 32);
    if (v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v14 = v12;
      if (os_signpost_enabled(v12))
      {
        *(_WORD *)v23 = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v14, OS_SIGNPOST_INTERVAL_BEGIN, v13, "link_shader", (const char *)&unk_192520C83, v23, 2u);
      }
    }
  }
  TimerBase::TimerBase((uint64_t)v23, *(unsigned int *)(a1 + 40), a2, (uint64_t)"link_shader", 0);
  v57(*(_QWORD *)&buf[8], v11);
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v15 = ci_signpost_log_compile();
    v16 = v24;
    if (v24 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v17 = v15;
      if (os_signpost_enabled(v15))
      {
        *(_WORD *)v60 = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v17, OS_SIGNPOST_INTERVAL_END, v16, "link_shader", (const char *)&unk_192520C83, v60, 2u);
      }
    }
  }
  TimerBase::~TimerBase((TimerBase *)v23);
  if (*(_QWORD *)(a1 + 104))
  {
    v18 = 0;
    do
    {
      v19 = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)a1 + 48))(a1, v18);
      *(_DWORD *)(*(_QWORD *)(a1 + 112) + 4 * v18++) = (*((uint64_t (**)(_QWORD, uint64_t, uint64_t))&v54 + 1))(*(_QWORD *)&buf[8], v11, v19);
    }
    while (*(_QWORD *)(a1 + 104) > v18);
  }
  *(_DWORD *)(a1 + 140) = v11;
  (*((void (**)(_QWORD, uint64_t))&v37 + 1))(*(_QWORD *)&buf[8], v10);
  *(double *)(a1 + 24) = (double)(std::chrono::steady_clock::now().__d_.__rep_ - v7.__d_.__rep_) / 1000000000.0;
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v20 = ci_signpost_log_compile();
    v21 = v59;
    if (v59 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v22 = v20;
      if (os_signpost_enabled(v20))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v22, OS_SIGNPOST_INTERVAL_END, v21, "compile_gl", (const char *)&unk_192520C83, buf, 2u);
      }
    }
  }
  TimerBase::~TimerBase((TimerBase *)v58);
}

uint64_t CI::GLContext::compile_shader(uint64_t a1, int a2, void *a3, uint64_t a4, uint64_t a5)
{
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  os_signpost_id_t v21;
  NSObject *v22;
  _OWORD v24[8];
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  void (*v49)(_QWORD, uint64_t, uint64_t, uint64_t *, _QWORD);
  _BYTE v50[8];
  os_signpost_id_t v51;
  uint64_t v52;

  v52 = a4;
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v10 = ci_signpost_log_render();
    if ((a2 | (unint64_t)(a1 << 32)) - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v11 = v10;
      if (os_signpost_enabled(v10))
      {
        LOWORD(v24[0]) = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v11, OS_SIGNPOST_INTERVAL_BEGIN, a2 | (unint64_t)(a1 << 32), "compile_shader", (const char *)&unk_192520C83, (uint8_t *)v24, 2u);
      }
    }
  }
  TimerBase::TimerBase((uint64_t)v50, a1, a2, (uint64_t)"compile_shader", 20);
  if (a4)
  {
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    memset(v24, 0, sizeof(v24));
    GetMacroContext(a3, v24);
    if (!LOBYTE(v24[0]))
    {
      v12 = ci_logger_render();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        CI::GLTextureManager::release_texture((uint64_t)a3, v12, v13, v14, v15, v16, v17, v18);
    }
    v19 = (*((uint64_t (**)(_QWORD, uint64_t))&v27 + 1))(*((_QWORD *)&v24[0] + 1), a5);
    v49(*((_QWORD *)&v24[0] + 1), v19, 1, &v52, 0);
    (*((void (**)(_QWORD, uint64_t))&v25 + 1))(*((_QWORD *)&v24[0] + 1), v19);
  }
  else
  {
    v19 = 0;
  }
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v20 = ci_signpost_log_render();
    v21 = v51;
    if (v51 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v22 = v20;
      if (os_signpost_enabled(v20))
      {
        LOWORD(v24[0]) = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v22, OS_SIGNPOST_INTERVAL_END, v21, "compile_shader", (const char *)&unk_192520C83, (uint8_t *)v24, 2u);
      }
    }
  }
  TimerBase::~TimerBase((TimerBase *)v50);
  return v19;
}

CI::GLContext *CI::GLContext::GLContext(CI::GLContext *this, const CI::GLContext *a2)
{
  unsigned int v4;
  void *v5;
  NSObject *v6;
  int API;
  void *v8;
  void *v9;
  int v10;
  _OWORD v12[19];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  *((_QWORD *)CI::Context::Context(this, a2) + 48) = off_1E2EB7B08;
  do
    v4 = __ldaxr(&dword_1ECF873D0[18]);
  while (__stlxr(v4 + 1, &dword_1ECF873D0[18]));
  *(_QWORD *)this = &off_1E2EC00F0;
  *((_QWORD *)this + 48) = &unk_1E2EC0370;
  *((_DWORD *)this + 102) = -1;
  *(_OWORD *)((char *)this + 888) = 0u;
  *((_DWORD *)this + 226) = *((_DWORD *)a2 + 226);
  *((_BYTE *)this + 909) = (*(uint64_t (**)(const CI::GLContext *))(*(_QWORD *)a2 + 552))(a2);
  v5 = (void *)*((_QWORD *)a2 + 49);
  if (v5)
  {
    *((_QWORD *)this + 50) = v5;
    CIEAGLContextRetain(v5);
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v13 = 0u;
    memset(v12, 0, sizeof(v12));
    GetMacroContext(*((void **)this + 50), v12);
    if (!LOBYTE(v12[0]))
    {
      v6 = ci_logger_render();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
    }
    ((void (*)(_QWORD))v13)(*((_QWORD *)&v12[0] + 1));
    API = CIEAGLContextGetAPI(v5);
    v8 = CIEAGLContextCreate(API, v5);
    *((_QWORD *)this + 49) = v8;
    *((_DWORD *)this + 102) = CIEAGLContextGetAPI(v8);
    *((_BYTE *)this + 760) = *((_BYTE *)a2 + 760);
    *((_DWORD *)this + 191) = *((_DWORD *)a2 + 191);
  }
  else
  {
    *((_QWORD *)this + 50) = 0;
    v9 = CIEAGLContextCreate(3, 0);
    *((_QWORD *)this + 49) = v9;
    if (!v9)
    {
      v9 = CIEAGLContextCreate(2, 0);
      *((_QWORD *)this + 49) = v9;
    }
    *((_DWORD *)this + 102) = CIEAGLContextGetAPI(v9);
    *((_DWORD *)this + 191) = 0;
    *((_BYTE *)this + 760) = 0;
  }
  CIEAGLContextSetBackgroundEnabled(*((void **)this + 49), 1);
  v10 = CIEAGLContextGetAPI(*((void **)this + 49));
  *((_QWORD *)this + 52) = CIEAGLContextCreate(v10, *((void **)this + 49));
  CI::GLContext::init(this);
  return this;
}

uint64_t CI::GLContext::init(CI::GLContext *this)
{
  CI::GLTextureManager *v2;
  NSObject *v3;
  __int128 v4;
  uint64_t v5;
  _OWORD v7[3];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;

  *((_DWORD *)this + 226) = 1;
  *((_BYTE *)this + 908) = 0;
  v2 = (CI::GLTextureManager *)operator new();
  *((_QWORD *)this + 53) = CI::GLTextureManager::GLTextureManager(v2, this);
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v8 = 0u;
  memset(v7, 0, sizeof(v7));
  GetMacroContext(*((void **)this + 49), v7);
  if (!LOBYTE(v7[0]))
  {
    v3 = ci_logger_render();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  *((_DWORD *)this + 207) = 0;
  *(_QWORD *)((char *)this + 820) = 0;
  *(_OWORD *)((char *)this + 804) = 0u;
  (*((void (**)(_QWORD, uint64_t))&v19 + 1))(*((_QWORD *)&v7[0] + 1), 2929);
  (*((void (**)(_QWORD, uint64_t))&v19 + 1))(*((_QWORD *)&v7[0] + 1), 3089);
  (*((void (**)(_QWORD, uint64_t))&v19 + 1))(*((_QWORD *)&v7[0] + 1), 3024);
  (*((void (**)(_QWORD, uint64_t))&v19 + 1))(*((_QWORD *)&v7[0] + 1), 2884);
  ((void (*)(_QWORD, _QWORD))v19)(*((_QWORD *)&v7[0] + 1), 0);
  ((void (*)(_QWORD, float, float, float, float))v10)(*((_QWORD *)&v7[0] + 1), 0.0, 0.0, 0.0, 1.0);
  ((void (*)(_QWORD, uint64_t, uint64_t))v11)(*((_QWORD *)&v7[0] + 1), 1, 771);
  *(_QWORD *)((char *)this + 500) = 0x800600000303;
  *(_OWORD *)((char *)this + 484) = xmmword_19249AF00;
  (*((void (**)(_QWORD, uint64_t))&v19 + 1))(*((_QWORD *)&v7[0] + 1), 3042);
  *((_BYTE *)this + 480) = 0;
  (*((void (**)(_QWORD, float, float, float, float))&v12 + 1))(*((_QWORD *)&v7[0] + 1), 0.0, 0.0, 0.0, 0.0);
  *((_BYTE *)this + 780) = 0;
  *((_QWORD *)this + 98) = 0;
  *((_DWORD *)this + 108) = 0;
  (*((void (**)(_QWORD, uint64_t, char *))&v26 + 1))(*((_QWORD *)&v7[0] + 1), 1, (char *)this + 752);
  (*((void (**)(_QWORD, uint64_t, _QWORD))&v8 + 1))(*((_QWORD *)&v7[0] + 1), 36160, *((unsigned int *)this + 188));
  ((void (*)(_QWORD, uint64_t, char *))v27)(*((_QWORD *)&v7[0] + 1), 1, (char *)this + 756);
  ((void (*)(_QWORD, uint64_t, _QWORD))v9)(*((_QWORD *)&v7[0] + 1), 36161, *((unsigned int *)this + 189));
  *((_DWORD *)this + 200) = 0;
  *((_QWORD *)this + 99) = 0;
  v4 = *(_OWORD *)(MEMORY[0x1E0C9D648] + 16);
  *(_OWORD *)((char *)this + 440) = *MEMORY[0x1E0C9D648];
  *(_OWORD *)((char *)this + 456) = v4;
  *((_DWORD *)this + 118) = *((_DWORD *)this + 188);
  *((_DWORD *)this + 119) = 0;
  v5 = (*(uint64_t (**)(CI::GLContext *))(*(_QWORD *)this + 272))(this);
  *((_DWORD *)this + 108) = CI::GLContext::compile_shader(v5, 0, *((void **)this + 49), (uint64_t)"// Copyright 2015 Apple Inc.\nattribute highp vec4 position;\n"
                                       "attribute highp vec4 texcoord;\n"
                                       "varying highp vec2 p0;\n"
                                       "uniform highp mat3 vertexTransform;\n"
                                       "void main()\n"
                                       "{\n"
                                       "  gl_Position = position;\n"
                                       "  p0 = (vec3(texcoord.xy,1.0) * vertexTransform).xy;\n"
                                       "}\n",
                              35633);
  CI::GLContext::update_limits((void **)this);
  return ((uint64_t (*)(_QWORD))v24)(*((_QWORD *)&v7[0] + 1));
}

uint64_t CI::GLContext::GLContext(uint64_t a1, void *a2, CGColorSpace *a3, CGColorSpace *a4, int a5, char a6, uint64_t a7, uint64_t a8, char a9, char a10)
{
  int v18;
  int v19;
  unsigned int v20;
  NSObject *v21;
  int API;
  void *v23;
  void *v24;
  int v25;
  _OWORD v27[19];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;

  if (dyld_program_sdk_at_least())
    v18 = 2056;
  else
    v18 = 264;
  if (a5)
    v19 = a5;
  else
    v19 = v18;
  CI::Context::Context(a1, a3, a4, v19, a6, a7, a8, 0, a9, 0);
  *(_QWORD *)(a1 + 384) = off_1E2EB7B08;
  do
    v20 = __ldaxr(&dword_1ECF873D0[18]);
  while (__stlxr(v20 + 1, &dword_1ECF873D0[18]));
  *(_QWORD *)a1 = &off_1E2EC00F0;
  *(_QWORD *)(a1 + 384) = &unk_1E2EC0370;
  *(_DWORD *)(a1 + 408) = -1;
  *(_OWORD *)(a1 + 888) = 0u;
  *(_BYTE *)(a1 + 909) = a10;
  if (a2)
  {
    *(_QWORD *)(a1 + 400) = a2;
    CIEAGLContextRetain(a2);
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v28 = 0u;
    memset(v27, 0, sizeof(v27));
    GetMacroContext(*(void **)(a1 + 400), v27);
    if (!LOBYTE(v27[0]))
    {
      v21 = ci_logger_render();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
    }
    ((void (*)(_QWORD))v28)(*((_QWORD *)&v27[0] + 1));
    API = CIEAGLContextGetAPI(a2);
    v23 = CIEAGLContextCreate(API, a2);
    *(_QWORD *)(a1 + 392) = v23;
    *(_DWORD *)(a1 + 408) = CIEAGLContextGetAPI(v23);
    *(_BYTE *)(a1 + 760) = 1;
  }
  else
  {
    *(_QWORD *)(a1 + 400) = 0;
    v24 = CIEAGLContextCreate(3, 0);
    *(_QWORD *)(a1 + 392) = v24;
    if (!v24)
    {
      v24 = CIEAGLContextCreate(2, 0);
      *(_QWORD *)(a1 + 392) = v24;
    }
    *(_DWORD *)(a1 + 408) = CIEAGLContextGetAPI(v24);
    *(_DWORD *)(a1 + 764) = 0;
    *(_BYTE *)(a1 + 760) = 0;
  }
  CIEAGLContextSetBackgroundEnabled(*(void **)(a1 + 392), 1);
  v25 = CIEAGLContextGetAPI(*(void **)(a1 + 392));
  *(_QWORD *)(a1 + 416) = CIEAGLContextCreate(v25, *(void **)(a1 + 392));
  CI::GLContext::init((CI::GLContext *)a1);
  return a1;
}

{
  return CI::GLContext::GLContext(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

void CI::GLContext::~GLContext(CI::GLContext *this)
{
  NSObject *v2;
  uint64_t v3;
  CI::Context *v4;
  uint64_t v5;
  NSObject *v6;
  unsigned int v7;
  _QWORD block[7];
  _QWORD v9[4];
  _QWORD v10[4];
  _QWORD v11[4];
  _QWORD v12[22];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;

  *(_QWORD *)this = &off_1E2EC00F0;
  *((_QWORD *)this + 48) = &unk_1E2EC0370;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v13 = 0u;
  memset(v12, 0, sizeof(v12));
  GetMacroContext(*((void **)this + 49), v12);
  if (!LOBYTE(v12[0]))
  {
    v2 = ci_logger_render();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  if (*((_DWORD *)this + 108))
  {
    (*((void (**)(_QWORD))&v14 + 1))(v12[1]);
    *((_DWORD *)this + 108) = 0;
  }
  if (*((_DWORD *)this + 222))
    (*((void (**)(_QWORD))&v13 + 1))(v12[1]);
  ((void (*)(_QWORD, uint64_t, char *))v14)(v12[1], 1, (char *)this + 756);
  ((void (*)(_QWORD, uint64_t, char *))v13)(v12[1], 1, (char *)this + 752);
  v3 = *((_QWORD *)this + 53);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 32))(v3);
  v4 = (CI::Context *)((uint64_t (*)(_QWORD))v21)(v12[1]);
  v11[0] = 0;
  v11[1] = v11;
  v11[2] = 0x2000000000;
  v5 = *((_QWORD *)this + 49);
  v11[3] = *((_QWORD *)this + 50);
  v10[0] = 0;
  v10[1] = v10;
  v10[2] = 0x2000000000;
  v10[3] = v5;
  v9[0] = 0;
  v9[1] = v9;
  v9[2] = 0x2000000000;
  v9[3] = *((_QWORD *)this + 52);
  v6 = CI::Context::render_completion_queue(v4);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI9GLContextD2Ev_block_invoke;
  block[3] = &unk_1E2EC6368;
  block[4] = v9;
  block[5] = v10;
  block[6] = v11;
  dispatch_async(v6, block);
  _Block_object_dispose(v9, 8);
  _Block_object_dispose(v10, 8);
  _Block_object_dispose(v11, 8);
  *((_QWORD *)this + 48) = off_1E2EB7B08;
  do
    v7 = __ldaxr(&dword_1ECF873D0[18]);
  while (__stlxr(v7 - 1, &dword_1ECF873D0[18]));
  CI::Context::~Context((CGColorSpaceRef *)this);
}

{
  CI::GLContext::~GLContext(this);
  JUMPOUT(0x194025AACLL);
}

void ___ZN2CI9GLContextD2Ev_block_invoke(_QWORD *a1)
{
  void *v2;

  CIEAGLContextRelease(*(void **)(*(_QWORD *)(a1[4] + 8) + 24));
  CIEAGLContextRelease(*(void **)(*(_QWORD *)(a1[5] + 8) + 24));
  v2 = *(void **)(*(_QWORD *)(a1[6] + 8) + 24);
  if (v2)
    CIEAGLContextRelease(v2);
}

void `non-virtual thunk to'CI::GLContext::~GLContext(CI::GLContext *this)
{
  CI::GLContext::~GLContext((CI::GLContext *)((char *)this - 384));
}

{
  CI::GLContext::~GLContext((CI::GLContext *)((char *)this - 384));
  JUMPOUT(0x194025AACLL);
}

char *CI::GLContext::update_limits(void **this)
{
  NSObject *v2;
  char *v3;
  char *v4;
  int v5;
  int v6;
  const char *v7;
  const char *v8;
  unsigned __int8 v9;
  char v10;
  const char *v11;
  char v12;
  char v13;
  char v14;
  const char *v15;
  char v16;
  char v17;
  char v18;
  const char *v19;
  char v20;
  char v21;
  char v22;
  const char *v23;
  char v24;
  char v25;
  char v26;
  const char *v27;
  char v28;
  char v29;
  char v30;
  const char *v31;
  char v32;
  char v33;
  char v34;
  char *result;
  const char *v36;
  char v37;
  _OWORD v38[25];
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;

  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v39 = 0u;
  memset(v38, 0, sizeof(v38));
  GetMacroContext(this[49], v38);
  if (!LOBYTE(v38[0]))
  {
    v2 = ci_logger_render();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  v3 = (char *)((uint64_t (*)(_QWORD, uint64_t))v42)(*((_QWORD *)&v38[0] + 1), 7939);
  v4 = (char *)((uint64_t (*)(_QWORD, uint64_t))v42)(*((_QWORD *)&v38[0] + 1), 35358);
  this[112] = (void *)((uint64_t (*)(_QWORD, uint64_t))v42)(*((_QWORD *)&v38[0] + 1), 7937);
  ((void (*)(_QWORD, uint64_t, void **))v39)(*((_QWORD *)&v38[0] + 1), 3379, this + 104);
  v5 = *((_DWORD *)this + 208);
  if (v5 >= (int)CI_MAX_TEXTURE_SIZE())
    v6 = CI_MAX_TEXTURE_SIZE();
  else
    v6 = *((_DWORD *)this + 208);
  *((_DWORD *)this + 208) = v6;
  ((void (*)(_QWORD, uint64_t, char *))v39)(*((_QWORD *)&v38[0] + 1), 3386, (char *)this + 836);
  ((void (*)(_QWORD, uint64_t, void **))v39)(*((_QWORD *)&v38[0] + 1), 34921, this + 105);
  this[109] = 0;
  ((void (*)(_QWORD, uint64_t, char *))v39)(*((_QWORD *)&v38[0] + 1), 36347, (char *)this + 844);
  ((void (*)(_QWORD, uint64_t, void **))v39)(*((_QWORD *)&v38[0] + 1), 36349, this + 106);
  ((void (*)(_QWORD, uint64_t, char *))v39)(*((_QWORD *)&v38[0] + 1), 36348, (char *)this + 852);
  ((void (*)(_QWORD, uint64_t, void **))v39)(*((_QWORD *)&v38[0] + 1), 35661, this + 107);
  ((void (*)(_QWORD, uint64_t, char *))v39)(*((_QWORD *)&v38[0] + 1), 34930, (char *)this + 860);
  ((void (*)(_QWORD, uint64_t, void **))v39)(*((_QWORD *)&v38[0] + 1), 34024, this + 108);
  if ((CI::search_extension_list(v3, "GL_APPLE_client_storage", v7) & 1) != 0)
    v9 = 1;
  else
    v9 = CI::search_extension_list(v4, "GL_APPLE_client_storage", v8);
  v10 = (_BYTE)this[110] & 0xFE | v9;
  *((_BYTE *)this + 880) = v10;
  if ((CI::search_extension_list(v3, "GL_APPLE_texture_ycbcr_basic_formats", v8) & 1) != 0
    || CI::search_extension_list(v4, "GL_APPLE_texture_ycbcr_basic_formats", v11))
  {
    v12 = 2;
  }
  else
  {
    v12 = 0;
  }
  v13 = v10 & 0xFD;
  v14 = v12 | v10 & 0xFD;
  *((_BYTE *)this + 880) = v12 | v13;
  if ((CI::search_extension_list(v3, "GL_APPLE_texture_ycbcr_extended_formats", v11) & 1) != 0
    || CI::search_extension_list(v4, "GL_APPLE_texture_ycbcr_extended_formats", v15))
  {
    v16 = 4;
  }
  else
  {
    v16 = 0;
  }
  v17 = v14 & 0xFB;
  v18 = v16 | v14 & 0xFB;
  *((_BYTE *)this + 880) = v16 | v17;
  if ((CI::search_extension_list(v3, "GL_EXT_color_buffer_half_float", v15) & 1) != 0
    || CI::search_extension_list(v4, "GL_EXT_color_buffer_half_float", v19))
  {
    v20 = 8;
  }
  else
  {
    v20 = 0;
  }
  v21 = v18 & 0xF7;
  v22 = v20 | v18 & 0xF7;
  *((_BYTE *)this + 880) = v20 | v21;
  if ((CI::search_extension_list(v3, "GL_EXT_shader_texture_lod", v19) & 1) != 0
    || CI::search_extension_list(v4, "GL_EXT_shader_texture_lod", v23))
  {
    v24 = 16;
  }
  else
  {
    v24 = 0;
  }
  v25 = v22 & 0xEF;
  v26 = v24 | v22 & 0xEF;
  *((_BYTE *)this + 880) = v24 | v25;
  if ((CI::search_extension_list(v3, "GL_OES_texture_half_float", v23) & 1) != 0
    || CI::search_extension_list(v4, "GL_OES_texture_half_float", v27))
  {
    v28 = 32;
  }
  else
  {
    v28 = 0;
  }
  v29 = v26 & 0xDF;
  v30 = v28 | v26 & 0xDF;
  *((_BYTE *)this + 880) = v28 | v29;
  if ((CI::search_extension_list(v3, "GL_OES_texture_float", v27) & 1) != 0
    || CI::search_extension_list(v4, "GL_OES_texture_float", v31))
  {
    v32 = 64;
  }
  else
  {
    v32 = 0;
  }
  v33 = v30 & 0xBF;
  v34 = v32 | v30 & 0xBF;
  *((_BYTE *)this + 880) = v32 | v33;
  result = CI::search_extension_list(v3, "GL_APPLE_texture_xr", v31);
  if ((result & 1) != 0
    || (result = CI::search_extension_list(v4, "GL_APPLE_texture_xr", v36), (_DWORD)result))
  {
    v37 = 0x80;
  }
  else
  {
    v37 = 0;
  }
  *((_BYTE *)this + 880) = v37 | v34 & 0x7F;
  return result;
}

const char *CI::GLContext::name(CI::GLContext *this)
{
  unsigned int v1;

  v1 = *((_DWORD *)this + 102) - 1;
  if (v1 > 2)
    return "opengl";
  else
    return off_1E2EC64A0[v1];
}

uint64_t CI::GLContext::setPriority(uint64_t result, int a2)
{
  int v2;

  if (a2 == 1)
  {
    v2 = 0;
  }
  else
  {
    if (a2 != -1)
      return result;
    v2 = 2;
  }
  *(_DWORD *)(result + 904) = v2;
  return result;
}

uint64_t CI::GLContext::priority(CI::GLContext *this)
{
  int v1;
  unsigned int v2;

  v1 = *((_DWORD *)this + 226);
  if (v1 == 2)
    v2 = -1;
  else
    v2 = 0;
  if (v1)
    return v2;
  else
    return 1;
}

uint64_t CI::GLContext::check_user_destination(CI::GLContext *this)
{
  NSObject *v2;
  uint64_t result;
  unsigned int v4;
  int v5;
  int v6;
  _OWORD v7[4];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t (*v36)(_QWORD);

  *((_BYTE *)this + 761) = 1;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  memset(v7, 0, sizeof(v7));
  GetMacroContext(*((void **)this + 50), v7);
  if (!LOBYTE(v7[0]))
  {
    v2 = ci_logger_render();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  ((void (*)(_QWORD))v23)(*((_QWORD *)&v7[0] + 1));
  v6 = 0;
  ((void (*)(_QWORD, uint64_t, int *))v29)(*((_QWORD *)&v7[0] + 1), 36006, &v6);
  *((_DWORD *)this + 191) = v6;
  result = v36(*((_QWORD *)&v7[0] + 1));
  if ((_DWORD)result
    && (result = ((uint64_t (*)(_QWORD, uint64_t))v11)(*((_QWORD *)&v7[0] + 1), 36160),
        (_DWORD)result == 36053))
  {
    v4 = 0;
    v5 = 0;
    if (v6)
    {
      (*((void (**)(_QWORD, uint64_t, uint64_t, uint64_t, int *))&v28 + 1))(*((_QWORD *)&v7[0] + 1), 36160, 36064, 36048, &v5);
      (*((void (**)(_QWORD, uint64_t, uint64_t, uint64_t, unsigned int *))&v28 + 1))(*((_QWORD *)&v7[0] + 1), 36160, 36064, 36049, &v4);
      if (v5 == 5890)
      {
        (*((void (**)(_QWORD, uint64_t, _QWORD))&v8 + 1))(*((_QWORD *)&v7[0] + 1), 3553, v4);
        ((void (*)(_QWORD, uint64_t, _QWORD, uint64_t, char *))v33)(*((_QWORD *)&v7[0] + 1), 3553, 0, 4099, (char *)this + 768);
        ((void (*)(_QWORD, uint64_t, _QWORD, uint64_t, char *))v33)(*((_QWORD *)&v7[0] + 1), 3553, 0, 4096, (char *)this + 772);
        ((void (*)(_QWORD, uint64_t, _QWORD, uint64_t, char *))v33)(*((_QWORD *)&v7[0] + 1), 3553, 0, 4097, (char *)this + 776);
      }
      else if (v5 == 36161)
      {
        (*((void (**)(_QWORD, uint64_t, uint64_t, char *))&v30 + 1))(*((_QWORD *)&v7[0] + 1), 36161, 36164, (char *)this + 768);
        (*((void (**)(_QWORD, uint64_t, uint64_t, char *))&v30 + 1))(*((_QWORD *)&v7[0] + 1), 36161, 36162, (char *)this + 772);
        (*((void (**)(_QWORD, uint64_t, uint64_t, char *))&v30 + 1))(*((_QWORD *)&v7[0] + 1), 36161, 36163, (char *)this + 776);
      }
    }
    result = ((uint64_t (*)(_QWORD, uint64_t, char *))v29)(*((_QWORD *)&v7[0] + 1), 3042, (char *)this + 804);
    if (*((_DWORD *)this + 201))
    {
      ((void (*)(_QWORD, uint64_t, char *))v29)(*((_QWORD *)&v7[0] + 1), 32969, (char *)this + 808);
      ((void (*)(_QWORD, uint64_t, char *))v29)(*((_QWORD *)&v7[0] + 1), 32968, (char *)this + 812);
      ((void (*)(_QWORD, uint64_t, char *))v29)(*((_QWORD *)&v7[0] + 1), 32777, (char *)this + 816);
      ((void (*)(_QWORD, uint64_t, char *))v29)(*((_QWORD *)&v7[0] + 1), 32971, (char *)this + 820);
      ((void (*)(_QWORD, uint64_t, char *))v29)(*((_QWORD *)&v7[0] + 1), 32970, (char *)this + 824);
      return ((uint64_t (*)(_QWORD, uint64_t, char *))v29)(*((_QWORD *)&v7[0] + 1), 34877, (char *)this + 828);
    }
  }
  else
  {
    *((_BYTE *)this + 761) = 0;
  }
  return result;
}

uint64_t CI::GLContext::flush_render(void **this)
{
  NSObject *v1;
  _OWORD v3[19];
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  v5 = 0u;
  v6 = 0u;
  v4 = 0u;
  memset(v3, 0, sizeof(v3));
  GetMacroContext(this[49], v3);
  if (!LOBYTE(v3[0]))
  {
    v1 = ci_logger_render();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  ((void (*)(_QWORD))v4)(*((_QWORD *)&v3[0] + 1));
  return 1;
}

uint64_t CI::GLContext::waitForCompletion(void **this)
{
  NSObject *v1;
  _OWORD v3[18];
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;

  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  v4 = 0u;
  v5 = 0u;
  memset(v3, 0, sizeof(v3));
  GetMacroContext(this[49], v3);
  if (!LOBYTE(v3[0]))
  {
    v1 = ci_logger_render();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  return (*((uint64_t (**)(_QWORD))&v4 + 1))(*((_QWORD *)&v3[0] + 1));
}

void CI::GLContext::finish_render(void **a1, uint64_t a2)
{
  NSObject *v4;
  os_signpost_id_t v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  os_signpost_id_t v9;
  NSObject *v10;
  _OWORD v11[19];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[8];
  os_signpost_id_t v26;

  v4 = ci_signpost_log_render();
  v5 = (*((uint64_t (**)(void **))*a1 + 34))(a1) << 32;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    LOWORD(v11[0]) = 0;
    _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v5, "finish_render", (const char *)&unk_192520C83, (uint8_t *)v11, 2u);
  }
  v6 = (*((uint64_t (**)(void **))*a1 + 34))(a1);
  TimerBase::TimerBase((uint64_t)v25, v6, 0, (uint64_t)"finish_render", 16);
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v12 = 0u;
  memset(v11, 0, sizeof(v11));
  GetMacroContext(a1[49], v11);
  if (!LOBYTE(v11[0]))
  {
    v7 = ci_logger_render();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  ((void (*)(_QWORD))v12)(*((_QWORD *)&v11[0] + 1));
  (*(void (**)(uint64_t))(a2 + 16))(a2);
  v8 = ci_signpost_log_render();
  v9 = v26;
  if (v26 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v10 = v8;
    if (os_signpost_enabled(v8))
    {
      LOWORD(v11[0]) = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v10, OS_SIGNPOST_INTERVAL_END, v9, "finish_render", (const char *)&unk_192520C83, (uint8_t *)v11, 2u);
    }
  }
  TimerBase::~TimerBase((TimerBase *)v25);
}

void CI::GLContext::after_render(CI::TextureManager **this)
{
  NSObject *v2;
  os_signpost_id_t v3;
  uint64_t v4;
  CI::TextureManager *v5;
  uint64_t v6;
  uint64_t v7;
  CI::TextureManager *v8;
  NSObject *v9;
  NSObject *v10;
  os_signpost_id_t v11;
  NSObject *v12;
  uint8_t v13[8];
  os_signpost_id_t v14;
  _QWORD block[6];

  v2 = ci_signpost_log_render();
  v3 = (*((uint64_t (**)(CI::TextureManager **))*this + 34))(this) << 32;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)v13 = 0;
    _os_signpost_emit_with_name_impl(&dword_1921E4000, v2, OS_SIGNPOST_INTERVAL_BEGIN, v3, "after_render", (const char *)&unk_192520C83, v13, 2u);
  }
  v4 = (*((uint64_t (**)(CI::TextureManager **))*this + 34))(this);
  TimerBase::TimerBase((uint64_t)v13, v4, 0, (uint64_t)"after_render", 8);
  CI::TextureManager::remove_all(this[53]);
  v5 = this[53];
  if (CI_RECYCLE_OPENGL_TEXTURES())
    v6 = CI_INTERMEDIATE_CACHE_SIZE();
  else
    v6 = 0;
  (*(void (**)(CI::TextureManager *, uint64_t))(*(_QWORD *)v5 + 64))(v5, v6);
  v7 = (int)CI_INPUT_CACHE_SIZE();
  v8 = this[53];
  v9 = *((_QWORD *)v8 + 13);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI16GLTextureManager23purge_attached_surfacesEm_block_invoke;
  block[3] = &__block_descriptor_tmp_15_2;
  block[4] = v8;
  block[5] = v7;
  dispatch_sync(v9, block);
  v10 = ci_signpost_log_render();
  v11 = v14;
  if (v14 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v12 = v10;
    if (os_signpost_enabled(v10))
    {
      LOWORD(block[0]) = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v12, OS_SIGNPOST_INTERVAL_END, v11, "after_render", (const char *)&unk_192520C83, (uint8_t *)block, 2u);
    }
  }
  TimerBase::~TimerBase((TimerBase *)v13);
}

uint64_t CI::GLContext::set_viewport(CI::GLContext *this, CGRect a2)
{
  double x;
  double y;
  double width;
  double height;
  uint64_t result;
  NSObject *v8;
  _OWORD v9[44];
  uint64_t (*v10)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  CGRect v11;

  v11 = CGRectIntegral(a2);
  x = v11.origin.x;
  y = v11.origin.y;
  width = v11.size.width;
  height = v11.size.height;
  result = CGRectEqualToRect(v11, *(CGRect *)((char *)this + 440));
  if ((result & 1) == 0)
  {
    memset(v9, 0, 512);
    GetMacroContext(*((void **)this + 49), v9);
    if (!LOBYTE(v9[0]))
    {
      v8 = ci_logger_render();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
    }
    *((double *)this + 55) = x;
    *((double *)this + 56) = y;
    *((double *)this + 57) = width;
    *((double *)this + 58) = height;
    return v10(*((_QWORD *)&v9[0] + 1), (int)x, (int)y, (int)width, (int)height);
  }
  return result;
}

uint64_t CI::GLContext::set_framebuffer(uint64_t this, uint64_t a2)
{
  uint64_t v3;
  NSObject *v4;
  _OWORD v5[3];
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;

  if (*(_DWORD *)(this + 472) != (_DWORD)a2)
  {
    v3 = this;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v11 = 0u;
    v12 = 0u;
    v9 = 0u;
    v10 = 0u;
    v7 = 0u;
    v8 = 0u;
    v6 = 0u;
    memset(v5, 0, sizeof(v5));
    GetMacroContext(*(void **)(this + 392), v5);
    if (!LOBYTE(v5[0]))
    {
      v4 = ci_logger_render();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
    }
    this = (*((uint64_t (**)(_QWORD, uint64_t, uint64_t))&v6 + 1))(*((_QWORD *)&v5[0] + 1), 36160, a2);
    *(_DWORD *)(v3 + 472) = a2;
  }
  return this;
}

uint64_t CI::GLContext::set_program(uint64_t this, uint64_t a2)
{
  uint64_t v3;
  NSObject *v4;
  _OWORD v5[42];
  uint64_t (*v6)(_QWORD, uint64_t);

  if (*(_DWORD *)(this + 476) != (_DWORD)a2)
  {
    v3 = this;
    memset(v5, 0, 512);
    GetMacroContext(*(void **)(this + 392), v5);
    if (!LOBYTE(v5[0]))
    {
      v4 = ci_logger_render();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
    }
    this = v6(*((_QWORD *)&v5[0] + 1), a2);
    *(_DWORD *)(v3 + 476) = a2;
  }
  return this;
}

uint64_t CI::GLContext::set_blend(uint64_t this, int a2)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  _OWORD v6[45];

  if (*(unsigned __int8 *)(this + 480) != a2)
  {
    v3 = this;
    memset(v6, 0, 512);
    GetMacroContext(*(void **)(this + 392), v6);
    if (!LOBYTE(v6[0]))
    {
      v4 = ci_logger_render();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
    }
    v5 = 232;
    if (a2)
      v5 = 264;
    this = (*(uint64_t (**)(_QWORD, uint64_t))((char *)v6 + v5))(*((_QWORD *)&v6[0] + 1), 3042);
    *(_BYTE *)(v3 + 480) = a2;
  }
  return this;
}

void CI::GLContext::set_blend(void **this, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v16;
  _OWORD v17[5];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;

  CI::GLContext::set_blend((uint64_t)this, a2);
  if (a2)
  {
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v18 = 0u;
    memset(v17, 0, sizeof(v17));
    GetMacroContext(this[49], v17);
    if (!LOBYTE(v17[0]))
    {
      v16 = ci_logger_render();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
    }
    if (*((_DWORD *)this + 121) != (_DWORD)a3
      || *((_DWORD *)this + 124) != (_DWORD)a4
      || *((_DWORD *)this + 122) != (_DWORD)a5
      || *((_DWORD *)this + 125) != (_DWORD)a6)
    {
      (*((void (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t))&v19 + 1))(*((_QWORD *)&v17[0] + 1), a3, a5, a4, a6);
      *((_DWORD *)this + 121) = a3;
      *((_DWORD *)this + 124) = a4;
      *((_DWORD *)this + 122) = a5;
      *((_DWORD *)this + 125) = a6;
    }
    if (*((_DWORD *)this + 123) != (_DWORD)a7 || *((_DWORD *)this + 126) != (_DWORD)a8)
    {
      (*((void (**)(_QWORD, uint64_t, uint64_t))&v18 + 1))(*((_QWORD *)&v17[0] + 1), a7, a8);
      *((_DWORD *)this + 123) = a7;
      *((_DWORD *)this + 126) = a8;
    }
  }
}

uint64_t CI::GLContext::max_input_image_size(CI::GLContext *this)
{
  return *((int *)this + 208);
}

uint64_t CI::GLContext::max_output_image_size(CI::GLContext *this)
{
  int v1;

  v1 = *((_DWORD *)this + 216);
  if (v1 >= *((_DWORD *)this + 209))
    return *((int *)this + 209);
  return v1;
}

uint64_t CI::GLContext::max_texture_image_units(CI::GLContext *this)
{
  return *((int *)this + 215);
}

uint64_t CI::GLContext::max_fragment_uniform_vectors(CI::GLContext *this)
{
  return *((int *)this + 212);
}

uint64_t CI::GLContext::max_fragment_uniform_size(CI::GLContext *this)
{
  return 16 * *((int *)this + 212);
}

unint64_t CI::GLContext::surface_rowbytes_alignment_for_input(uint64_t a1, int a2)
{
  unint64_t v3;

  if (is_gpu_A9_or_higher())
    v3 = 16;
  else
    v3 = 4;
  if (v3 < (int)CI::format_bytes_per_pixel(a2))
    return (int)CI::format_bytes_per_pixel(a2);
  return v3;
}

unint64_t CI::GLContext::surface_rowbytes_alignment_for_output(uint64_t a1, int a2)
{
  unint64_t v3;

  if (is_gpu_A9_or_higher())
    v3 = 16;
  else
    v3 = 4;
  if (v3 < (int)CI::format_bytes_per_pixel(a2))
    return (int)CI::format_bytes_per_pixel(a2);
  return v3;
}

uint64_t CI::GLContext::insert_event_marker(void **this, const char *a2)
{
  NSObject *v3;
  size_t v4;
  _OWORD v6[31];
  __int128 v7;

  v7 = 0u;
  memset(v6, 0, sizeof(v6));
  GetMacroContext(this[49], v6);
  if (!LOBYTE(v6[0]))
  {
    v3 = ci_logger_render();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  v4 = strlen(a2);
  return ((uint64_t (*)(_QWORD, size_t, const char *))v7)(*((_QWORD *)&v6[0] + 1), v4, a2);
}

void CI::GLContext::subdivideQuad(void **a1, int a2, double *a3, float *a4, float *a5)
{
  double v10;
  unsigned int v11;
  int v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  unsigned int v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  unsigned int v30;
  unsigned int v31;
  float v32;
  float v33;
  float v34;
  float v35;
  unsigned int v36;
  double v37;
  double v38;
  double v39;
  double v40;
  float v41;
  float v42;
  float v43;
  float v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  _DWORD v60[8];
  _DWORD v61[8];
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (CI::CI_SUBDIVIDE_QUADS(void)::didCheck != -1)
    dispatch_once(&CI::CI_SUBDIVIDE_QUADS(void)::didCheck, &__block_literal_global_64_0);
  if (*(double *)&CI::CI_SUBDIVIDE_QUADS(void)::v == 0.0)
    v10 = 256.0;
  else
    v10 = *(double *)&CI::CI_SUBDIVIDE_QUADS(void)::v;
  v11 = vcvtpd_u64_f64(a3[1] / v10);
  if (v11)
  {
    v12 = 0;
    v14 = a5[1];
    v13 = a5[2];
    v15 = a5[5];
    v17 = a4[1];
    v16 = a4[2];
    v18 = a4[5];
    v19 = vcvtpd_u64_f64(*a3 / v10);
    v20 = (float)((float)(v13 - *a5) / (float)v19);
    v21 = (float)((float)(v16 - *a4) / (float)v19);
    v22 = (float)((float)(v18 - v17) / (float)v11);
    v50 = v18;
    v48 = v15;
    v49 = v18 - v22;
    v46 = (float)((float)(v15 - v14) / (float)v11);
    v47 = v15 - v46;
    v45 = v22;
    v53 = v14;
    v54 = v17;
    v52 = v17 + v22;
    v51 = v14 + v46;
    v23 = *a4;
    v24 = *a5;
    v59 = v16;
    v57 = v13;
    v58 = v16 - v21;
    v56 = v13 - v20;
    v25 = 0.0;
    do
    {
      v27 = v53;
      v26 = v54;
      v28 = v51;
      v29 = v52;
      if (v12)
      {
        v30 = v12 + 1;
        v27 = v47;
        v28 = v48;
        v26 = v49;
        v29 = v50;
        if (v12 + 1 != v11)
        {
          v26 = v54 + v45 * v25;
          v29 = v54 + v45 * (double)v30;
          v27 = v53 + v46 * v25;
          v28 = v53 + v46 * (double)v30;
        }
      }
      v55 = v25;
      if (v19)
      {
        v31 = 0;
        v32 = v27;
        v33 = v28;
        v34 = v26;
        v35 = v29;
        do
        {
          if (v31)
          {
            v36 = v31 + 1;
            if (v31 + 1 == v19)
            {
              v37 = v56;
              v38 = v57;
              v39 = v58;
              v40 = v59;
            }
            else
            {
              v39 = v23 + v21 * (double)v31;
              v40 = v23 + v21 * (double)v36;
              v37 = v24 + v20 * (double)v31;
              v38 = v24 + v20 * (double)v36;
            }
          }
          else
          {
            v36 = 1;
            v37 = v24;
            v38 = v24 + v20;
            v40 = v23 + v21;
            v39 = v23;
          }
          v41 = v37;
          *(float *)v61 = v41;
          *(float *)&v61[1] = v32;
          v42 = v38;
          *(float *)&v61[2] = v42;
          *(float *)&v61[3] = v32;
          *(float *)&v61[4] = v41;
          *(float *)&v61[5] = v33;
          *(float *)&v61[6] = v42;
          *(float *)&v61[7] = v33;
          v43 = v39;
          *(float *)v60 = v43;
          *(float *)&v60[1] = v34;
          v44 = v40;
          *(float *)&v60[2] = v44;
          *(float *)&v60[3] = v34;
          *(float *)&v60[4] = v43;
          *(float *)&v60[5] = v35;
          *(float *)&v60[6] = v44;
          *(float *)&v60[7] = v35;
          CI::GLContext::quad(a1, a2, (uint64_t)v60, (uint64_t)v61);
          CI::GLContext::flush_render(a1);
          v31 = v36;
        }
        while (v36 != v19);
      }
      v25 = v55 + 1.0;
      ++v12;
    }
    while (v12 != v11);
  }
}

void CI::GLContext::quad(void **a1, int a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  os_signpost_id_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  os_signpost_id_t v14;
  NSObject *v15;
  uint64_t v16;
  uint8_t buf[16];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  void (*v49)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t);
  _BYTE v50[8];
  os_signpost_id_t v51;

  if (CI_VERBOSE_SIGNPOSTS())
  {
    v8 = ci_signpost_log_render();
    v9 = a2 | (unint64_t)((*((uint64_t (**)(void **))*a1 + 34))(a1) << 32);
    if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v8, OS_SIGNPOST_INTERVAL_BEGIN, v9, "quad", (const char *)&unk_192520C83, buf, 2u);
    }
  }
  v10 = (*((uint64_t (**)(void **))*a1 + 34))(a1);
  TimerBase::TimerBase((uint64_t)v50, v10, a2, (uint64_t)"quad", 12);
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  *(_OWORD *)buf = 0u;
  v18 = 0u;
  GetMacroContext(a1[49], buf);
  if (!buf[0])
  {
    v11 = ci_logger_render();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  v16 = 0;
  (*((void (**)(_QWORD, _QWORD, uint64_t, char *))&v47 + 1))(*(_QWORD *)&buf[8], 0, 34338, (char *)&v16 + 4);
  (*((void (**)(_QWORD, uint64_t, uint64_t, uint64_t *))&v47 + 1))(*(_QWORD *)&buf[8], 1, 34338, &v16);
  ((void (*)(_QWORD, uint64_t, _QWORD))v20)(*(_QWORD *)&buf[8], 34962, 0);
  v49(*(_QWORD *)&buf[8], 0, 2, 5126, 0, 0, a3);
  ((void (*)(_QWORD, _QWORD))v34)(*(_QWORD *)&buf[8], 0);
  v49(*(_QWORD *)&buf[8], 1, 2, 5126, 0, 0, a4);
  ((void (*)(_QWORD, uint64_t))v34)(*(_QWORD *)&buf[8], 1);
  if (!CI_NO_RENDER())
  {
    if (CI_LIMIT_RENDER())
      v12 = 0;
    else
      v12 = 5;
    (*((void (**)(_QWORD, uint64_t, _QWORD, uint64_t))&v32 + 1))(*(_QWORD *)&buf[8], v12, 0, 4);
  }
  if (!(_DWORD)v16)
    ((void (*)(_QWORD, uint64_t))v32)(*(_QWORD *)&buf[8], 1);
  if (!HIDWORD(v16))
    ((void (*)(_QWORD, _QWORD))v32)(*(_QWORD *)&buf[8], 0);
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v13 = ci_signpost_log_render();
    v14 = v51;
    if (v51 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v15 = v13;
      if (os_signpost_enabled(v13))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v15, OS_SIGNPOST_INTERVAL_END, v14, "quad", (const char *)&unk_192520C83, buf, 2u);
      }
    }
  }
  TimerBase::~TimerBase((TimerBase *)v50);
}

void CI::GLContext::quad(void **a1, int a2, int a3, double *a4, CMatrix *a5)
{
  double *v9;
  double v10;
  double v11;
  float v12;
  float v13;
  float v14;
  float v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  uint64_t v21;
  float v22;
  uint64_t v23;
  float v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  float v28;
  uint64_t v29;
  float v30;
  double v31;
  uint64_t v32;
  double v33;
  uint64_t v34;
  uint64_t v35;
  float v36;
  uint64_t v37;
  float v38;
  double v39;
  uint64_t v40;
  double v41;
  uint64_t v42;
  uint64_t v43;
  float v44;
  uint64_t v45;
  float v46;
  NSObject *v47;
  __n128 v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  double v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  double v58;
  uint64_t v59;
  double v60;
  unsigned int v61;
  char v62;
  _OWORD v63[14];
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  void (*v82)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD);
  unsigned int v83[52];
  unsigned int v84[54];
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93[4];
  float v94;
  float v95;
  float v96;
  float v97;
  uint64_t v98;

  v98 = *MEMORY[0x1E0C80C00];
  v9 = a4 + 2;
  v10 = *a4;
  v11 = a4[1];
  v12 = *a4 + a4[2];
  v93[0] = v12;
  v13 = v11;
  v93[1] = v13;
  v14 = v10;
  v93[2] = v14;
  v93[3] = v13;
  v94 = v12;
  v15 = v11 + a4[3];
  v95 = v15;
  v96 = v14;
  v97 = v15;
  if (a5)
  {
    CMatrix::CMatrix((CMatrix *)v63, a5);
    CMatrix::CMatrix((CMatrix *)v84, 1u, 4u, 0.0, v16, v17, 0, 0, 0x3FF0000000000000);
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v18;
    *(double *)CMatrixRow::operator[]((uint64_t)v83, 0) = v12;
    v19 = v13;
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v20;
    *(double *)CMatrixRow::operator[]((uint64_t)v83, 1u) = v19;
    CMatrix::operator*(v84, v63, v83);
    CMatrix::operator=(v84, v83);
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v21;
    v22 = *(double *)CMatrixRow::operator[]((uint64_t)v83, 0);
    v85 = v22;
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v23;
    v24 = *(double *)CMatrixRow::operator[]((uint64_t)v83, 1u);
    v86 = v24;
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v25;
    *(double *)CMatrixRow::operator[]((uint64_t)v83, 0) = v14;
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v26;
    *(double *)CMatrixRow::operator[]((uint64_t)v83, 1u) = v19;
    CMatrix::operator*(v84, v63, v83);
    CMatrix::operator=(v84, v83);
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v27;
    v28 = *(double *)CMatrixRow::operator[]((uint64_t)v83, 0);
    v87 = v28;
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v29;
    v30 = *(double *)CMatrixRow::operator[]((uint64_t)v83, 1u);
    v88 = v30;
    v31 = v94;
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v32;
    *(double *)CMatrixRow::operator[]((uint64_t)v83, 0) = v31;
    v33 = v95;
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v34;
    *(double *)CMatrixRow::operator[]((uint64_t)v83, 1u) = v33;
    CMatrix::operator*(v84, v63, v83);
    CMatrix::operator=(v84, v83);
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v35;
    v36 = *(double *)CMatrixRow::operator[]((uint64_t)v83, 0);
    v89 = v36;
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v37;
    v38 = *(double *)CMatrixRow::operator[]((uint64_t)v83, 1u);
    v90 = v38;
    v39 = v96;
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v40;
    *(double *)CMatrixRow::operator[]((uint64_t)v83, 0) = v39;
    v41 = v97;
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v42;
    *(double *)CMatrixRow::operator[]((uint64_t)v83, 1u) = v41;
    CMatrix::operator*(v84, v63, v83);
    CMatrix::operator=(v84, v83);
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v43;
    v44 = *(double *)CMatrixRow::operator[]((uint64_t)v83, 0);
    v91 = v44;
    *(_QWORD *)v83 = CMatrix::operator[](v84, 0);
    *(_QWORD *)&v83[2] = v45;
    v46 = *(double *)CMatrixRow::operator[]((uint64_t)v83, 1u);
  }
  else
  {
    v46 = 1.0;
    v85 = 1.0;
    if (a3)
      v46 = -1.0;
    v86 = -v46;
    v87 = -1.0;
    v88 = -v46;
    v89 = 1.0;
    v90 = v46;
    v91 = -1.0;
  }
  v92 = v46;
  if (CI::CI_SUBDIVIDE_QUADS(void)::didCheck != -1)
    dispatch_once(&CI::CI_SUBDIVIDE_QUADS(void)::didCheck, &__block_literal_global_64_0);
  if (*(double *)&CI::CI_SUBDIVIDE_QUADS(void)::v <= 0.0
    || *v9 <= *(double *)&CI::CI_SUBDIVIDE_QUADS(void)::v && a4[3] <= *(double *)&CI::CI_SUBDIVIDE_QUADS(void)::v)
  {
    CI::GLContext::quad(a1, a2, (uint64_t)&v85, (uint64_t)v93);
  }
  else if (a5)
  {
    v80 = 0u;
    v81 = 0u;
    v78 = 0u;
    v79 = 0u;
    v76 = 0u;
    v77 = 0u;
    v74 = 0u;
    v75 = 0u;
    v72 = 0u;
    v73 = 0u;
    v70 = 0u;
    v71 = 0u;
    v68 = 0u;
    v69 = 0u;
    v66 = 0u;
    v67 = 0u;
    v64 = 0u;
    v65 = 0u;
    memset(v63, 0, sizeof(v63));
    GetMacroContext(a1[49], v63);
    if (!LOBYTE(v63[0]))
    {
      v47 = ci_logger_render();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
    }
    v62 = 0;
    ((void (*)(_QWORD, uint64_t, char *))v73)(*((_QWORD *)&v63[0] + 1), 3089, &v62);
    ((void (*)(_QWORD, uint64_t, unsigned int *))v75)(*((_QWORD *)&v63[0] + 1), 3088, v83);
    if (v62)
      *(_OWORD *)v84 = *(_OWORD *)v83;
    else
      ((void (*)(_QWORD, uint64_t, unsigned int *))v75)(*((_QWORD *)&v63[0] + 1), 2978, v84);
    (*((void (**)(_QWORD, uint64_t))&v66 + 1))(*((_QWORD *)&v63[0] + 1), 3089);
    v49 = v84[0];
    v50 = v84[2];
    v51 = v84[1];
    v52 = v84[3];
    if (CI::CI_SUBDIVIDE_QUADS(void)::didCheck != -1)
    {
      v61 = v84[2];
      dispatch_once(&CI::CI_SUBDIVIDE_QUADS(void)::didCheck, &__block_literal_global_64_0);
      v50 = v61;
    }
    v53 = v50 + v49;
    v48.n128_u64[0] = CI::CI_SUBDIVIDE_QUADS(void)::v;
    if (*(double *)&CI::CI_SUBDIVIDE_QUADS(void)::v == 0.0)
      v54 = 256.0;
    else
      v54 = *(double *)&CI::CI_SUBDIVIDE_QUADS(void)::v;
    v55 = v84[0];
    if ((int)v84[0] < v53)
    {
      v56 = v52 + v51;
      do
      {
        v57 = v84[1];
        if ((int)v84[1] < v56)
        {
          v58 = (double)(v53 - (int)v55);
          if (v54 < v58)
            v58 = v54;
          v59 = (int)v58;
          do
          {
            v60 = (double)(v56 - (int)v57);
            if (v54 < v60)
              v60 = v54;
            v82(*((_QWORD *)&v63[0] + 1), v55, v57, v59, (int)v60);
            CI::GLContext::quad(a1, a2, (uint64_t)&v85, (uint64_t)v93);
            CI::GLContext::flush_render(a1);
            v57 = (int)(v54 + (double)(int)v57);
          }
          while (v56 > (int)v57);
        }
        v48.n128_f64[0] = v54 + (double)(int)v55;
        v55 = (int)v48.n128_f64[0];
      }
      while (v53 > (int)v55);
    }
    if (!v62)
      (*((void (**)(_QWORD, uint64_t, __n128))&v64 + 1))(*((_QWORD *)&v63[0] + 1), 3089, v48);
    ((void (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __n128))v82)(*((_QWORD *)&v63[0] + 1), v83[0], v83[1], v83[2], v83[3], v48);
  }
  else
  {
    CI::GLContext::subdivideQuad(a1, a2, v9, &v85, v93);
  }
}

uint64_t CI::GLContext::set_texture_destination(CI::GLContext *this, Texture a2, const CGSize *a3)
{
  *((_BYTE *)this + 762) = 0;
  *((_BYTE *)this + 780) = 1;
  *((_QWORD *)this + 98) = 0;
  *((CGSize *)this + 32) = *a3;
  *((_DWORD *)this + 132) = *((_DWORD *)this + 188);
  *((_DWORD *)this + 133) = a2.var0.var1.var0;
  *((_DWORD *)this + 135) = 5890;
  *((_DWORD *)this + 136) = a2.var0.var1.var1;
  return 1;
}

size_t CI::GLContext::set_surface_destination(uint64_t a1, __IOSurface *a2, double *a3, int *a4)
{
  void **v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  int API;
  uint64_t v13;
  signed int v14;
  const char *v15;
  const char *v16;
  size_t result;
  __IOSurface *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  unint64_t v24;
  int v25;
  int v26;
  int v27;
  __int16 v28;
  _OWORD v29[4];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t (*v58)(_QWORD, uint64_t, _QWORD, unint64_t, uint64_t, uint64_t, _QWORD, unint64_t, int, _QWORD);

  *(_BYTE *)(a1 + 762) = 0;
  *(_BYTE *)(a1 + 780) = 1;
  *(_QWORD *)(a1 + 784) = a2;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  memset(v29, 0, sizeof(v29));
  v8 = (void **)(a1 + 392);
  GetMacroContext(*(void **)(a1 + 392), v29);
  if (!LOBYTE(v29[0]))
  {
    v9 = ci_logger_render();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  (*((void (**)(_QWORD, uint64_t, uint64_t))&v48 + 1))(*((_QWORD *)&v29[0] + 1), 1, a1 + 792);
  (*((void (**)(_QWORD, uint64_t, _QWORD))&v30 + 1))(*((_QWORD *)&v29[0] + 1), 3553, *(unsigned int *)(a1 + 792));
  v10 = (unint64_t)*a3;
  v11 = (unint64_t)a3[1];
  API = CIEAGLContextGetAPI(*(void **)(a1 + 392));
  v13 = CI::gl_format_info_for_format((uint64_t)a4, API);
  v15 = "GLContext::set_surface_destination unsupported format %s!\n";
  if (!(_DWORD)v13 || !HIDWORD(v13) || !v14)
    goto LABEL_9;
  if ((CIEAGLContextTexImageIOSurface(*v8, 0xDE1u, v10, v11, v13, SHIDWORD(v13), v14, a2, 0) & 1) == 0)
  {
    v15 = "CIEAGLContextTexImageIOSurface failed for %s!\n";
LABEL_9:
    v16 = CI::name_for_format(*a4);
    x_log(v15, v16);
  }
  *(double *)(a1 + 512) = (double)(unint64_t)v10;
  *(double *)(a1 + 520) = (double)(unint64_t)v11;
  *(_DWORD *)(a1 + 528) = *(_DWORD *)(a1 + 752);
  *(_DWORD *)(a1 + 532) = *(_DWORD *)(a1 + 792);
  *(_QWORD *)(a1 + 540) = 0xDE100001702;
  result = IOSurfaceGetPlaneCount(a2);
  if (result == 2)
  {
    v19 = *a4;
    if (*a4 == 261 || v19 == 2053 || v19 == 1797)
    {
      v20 = CI::format_from_IOSurface(a2, v18);
      CI::format_is_ycc_biplanar(v20);
      if (*a4 == 1797)
        v21 = 1798;
      else
        v21 = 2054;
      if (*a4 == 261)
        v22 = 262;
      else
        v22 = v21;
      v27 = v22;
      v28 = 0;
      v23 = CIEAGLContextGetAPI(*(void **)(a1 + 392));
      v24 = CI::gl_format_info_for_format((uint64_t)&v27, v23);
      v26 = v25;
      (*((void (**)(_QWORD, uint64_t, uint64_t))&v48 + 1))(*((_QWORD *)&v29[0] + 1), 1, a1 + 796);
      (*((void (**)(_QWORD, uint64_t, _QWORD))&v30 + 1))(*((_QWORD *)&v29[0] + 1), 3553, *(unsigned int *)(a1 + 796));
      result = v58(*((_QWORD *)&v29[0] + 1), 3553, 0, v24, v10, v11, 0, HIDWORD(v24), v26, 0);
      *(_DWORD *)(a1 + 536) = *(_DWORD *)(a1 + 796);
    }
  }
  return result;
}

uint64_t CI::GLContext::set_bitmap_destination(uint64_t a1, uint64_t a2, double *a3, uint64_t a4)
{
  double v7;
  uint64_t v8;
  void **v9;
  NSObject *v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t result;
  int API;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD v21[7];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t (*v47)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD);

  *(_BYTE *)(a1 + 762) = 0;
  *(_BYTE *)(a1 + 780) = 0;
  v7 = a3[1];
  v8 = (int)*a3;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v22 = 0u;
  memset(v21, 0, sizeof(v21));
  v9 = (void **)(a1 + 392);
  GetMacroContext(*(void **)(a1 + 392), v21);
  if (!LOBYTE(v21[0]))
  {
    v10 = ci_logger_render();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  v11 = (int)v7;
  v12 = *(_DWORD *)(a1 + 864);
  if (v12 < (int)v8 || v12 < v11)
    return x_log("Destination buffer size too large (%d x %d); cannot be larger than %d x %d.\n",
             v8,
             (int)v7,
             *(_DWORD *)(a1 + 864),
             v12);
  v13 = *(_DWORD *)a4;
  switch(*(_DWORD *)a4)
  {
    case 0x803:
    case 0x805:
      goto LABEL_7;
    case 0x804:
    case 0x806:
      if ((*(_BYTE *)(a1 + 880) & 8) != 0)
      {
        v14 = 33327;
      }
      else
      {
        if (v13 == 2053)
        {
LABEL_7:
          if ((*(_BYTE *)(a1 + 880) & 8) != 0)
          {
            v14 = 33325;
            goto LABEL_28;
          }
        }
LABEL_14:
        if (CI::format_bytes_per_pixel(v13) == 1
          && CI::format_bits_per_component(*(_DWORD *)a4) == 8)
        {
          v14 = 33321;
        }
        else if (CI::format_bytes_per_pixel(*(_DWORD *)a4) == 2
               && CI::format_bits_per_component(*(_DWORD *)a4) == 8)
        {
          v14 = 33323;
        }
        else
        {
          API = CIEAGLContextGetAPI(*v9);
          v17 = CI::gl_format_info_for_format(a4, API);
          if (*(_BYTE *)(a4 + 4))
            v18 = 35907;
          else
            v18 = 32856;
          if (*(_DWORD *)a4 == 264)
            v14 = v18;
          else
            v14 = v17;
        }
      }
LABEL_28:
      v19 = 0;
      v20 = 0;
      CI::format_get_clear_color(*(unsigned int *)(a2 + 104), (_DWORD *)&v20 + 1, (int *)&v20, (_DWORD *)&v19 + 1, &v19);
      (*((void (**)(_QWORD, float, float, float, float))&v22 + 1))(*((_QWORD *)&v21[0] + 1), *((float *)&v20 + 1), *(float *)&v20, *((float *)&v19 + 1), *(float *)&v19);
      result = v47(*((_QWORD *)&v21[0] + 1), 36161, v14, v8, (int)v7);
      *(double *)(a1 + 512) = (double)(int)v8;
      *(double *)(a1 + 520) = (double)v11;
      *(_QWORD *)(a1 + 528) = *(_QWORD *)(a1 + 752);
      *(_DWORD *)(a1 + 540) = 36161;
      break;
    case 0x808:
      if ((*(_BYTE *)(a1 + 880) & 8) == 0)
        goto LABEL_14;
      v14 = 34842;
      goto LABEL_28;
    default:
      goto LABEL_14;
  }
  return result;
}

char *CI::search_extension_list(char *this, const char *a2, const char *a3)
{
  char *v4;

  if (this)
  {
    v4 = this;
    this = strstr(this, a2);
    if (this)
    {
      if (this <= v4 || *(this - 1) == 32)
        return (char *)((this[strlen(a2)] & 0xDF) == 0);
      else
        return 0;
    }
  }
  return this;
}

uint64_t CI::GLContext::unbind_render_target(uint64_t this)
{
  uint64_t v1;
  _QWORD *v2;
  NSObject *v3;
  _OWORD v4[13];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;

  v1 = this;
  if (*(_DWORD *)(this + 540) == 5890 && *(_DWORD *)(this + 792))
  {
    v2 = (_QWORD *)(this + 792);
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    v12 = 0u;
    v13 = 0u;
    v10 = 0u;
    v11 = 0u;
    v8 = 0u;
    v9 = 0u;
    v6 = 0u;
    v7 = 0u;
    v5 = 0u;
    memset(v4, 0, sizeof(v4));
    GetMacroContext(*(void **)(this + 392), v4);
    if (!LOBYTE(v4[0]))
    {
      v3 = ci_logger_render();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
    }
    this = (*((uint64_t (**)(_QWORD, uint64_t, uint64_t))&v5 + 1))(*((_QWORD *)&v4[0] + 1), 3, v1 + 792);
    *(_DWORD *)(v1 + 800) = 0;
    *v2 = 0;
  }
  if (*(_QWORD *)(v1 + 400))
  {
    if (*(_BYTE *)(v1 + 762))
      return CI::GLContext::set_framebuffer(v1, 0);
  }
  return this;
}

BOOL CI::GLContext::set_user_destination(CI::GLContext *this)
{
  int v1;
  uint64_t v3;
  int64x2_t v4;

  v1 = *((unsigned __int8 *)this + 760);
  if (*((_BYTE *)this + 760))
  {
    *((_BYTE *)this + 762) = 1;
    *((_BYTE *)this + 780) = 0;
    CI::GLContext::check_user_destination(this);
    v3 = *(_QWORD *)((char *)this + 772);
    v4.i64[0] = (int)v3;
    v4.i64[1] = SHIDWORD(v3);
    *((float64x2_t *)this + 32) = vcvtq_f64_s64(v4);
    *((_DWORD *)this + 132) = *((_DWORD *)this + 191);
    *((_DWORD *)this + 133) = -1;
    *((_DWORD *)this + 135) = 36161;
  }
  return v1 != 0;
}

uint64_t CI::GLContext::user_destination_format(CI::GLContext *this)
{
  int v1;

  if (!*((_BYTE *)this + 760))
    return 0;
  v1 = *((_DWORD *)this + 192);
  if (v1 <= 35445)
  {
    if (v1 == 34836)
      return 2312;
    if (v1 == 34842)
      return 2056;
  }
  else if ((v1 - 35446) < 2 || v1 == 37874 || v1 == 37881)
  {
    return 2567;
  }
  return 264;
}

BOOL CI::GLContext::is_user_destination_srgb(CI::GLContext *this)
{
  int v1;

  v1 = *((_DWORD *)this + 192);
  return v1 == 35447 || v1 == 37874 || v1 == 37881;
}

uint64_t CI::GLContext::insert_fence(void **this)
{
  NSObject *v1;
  _OWORD v3[18];
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;

  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  v4 = 0u;
  v5 = 0u;
  memset(v3, 0, sizeof(v3));
  GetMacroContext(this[49], v3);
  if (!LOBYTE(v3[0]))
  {
    v1 = ci_logger_render();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  return ((uint64_t (*)(_QWORD, uint64_t, _QWORD))v4)(*((_QWORD *)&v3[0] + 1), 37143, 0);
}

uint64_t CI::GLContext::bind_render_target(void **this)
{
  NSObject *v2;
  uint64_t result;
  _OWORD v4[16];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  v5 = 0u;
  v6 = 0u;
  memset(v4, 0, sizeof(v4));
  GetMacroContext(this[49], v4);
  if (!LOBYTE(v4[0]))
  {
    v2 = ci_logger_render();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  result = CI::GLContext::set_framebuffer((uint64_t)this, *((unsigned int *)this + 132));
  if ((*((_DWORD *)this + 133) & 0x80000000) == 0)
  {
    if (*((_DWORD *)this + 135) == 36161)
    {
      return (*((uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))&v9 + 1))(*((_QWORD *)&v4[0] + 1), 36160, 36064, 36161);
    }
    else
    {
      result = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, uint64_t))v10)(*((_QWORD *)&v4[0] + 1), 36160, 36064, 3553);
      if (*((_DWORD *)this + 199))
      {
        ((void (*)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))v10)(*((_QWORD *)&v4[0] + 1), 36160, 36065, 3553, *((unsigned int *)this + 134), 0);
        v21[0] = 0x8CE100008CE0;
        return ((uint64_t (*)(_QWORD, uint64_t, _QWORD *))v5)(*((_QWORD *)&v4[0] + 1), 2, v21);
      }
    }
  }
  return result;
}

void CI::GLContext::render_root_node(uint64_t a1, CI::TileTask *a2, CI::parentROI *this, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  CGFloat v11;
  CGFloat v12;
  CGFloat v13;
  NSObject *v14;
  os_signpost_id_t v15;
  const CI::ProgramNode *v16;
  uint64_t v17;
  uint64_t v18;
  CI::Context *v19;
  NSObject *v20;
  int v21;
  uint64_t v22;
  double v23;
  uint64_t v24;
  double v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  os_signpost_id_t v32;
  uint64_t v33;
  unsigned int *v34;
  NSObject *v35;
  os_signpost_id_t v36;
  NSObject *v37;
  uint64_t v38;
  NSObject *v39;
  size_t WidthOfPlane;
  size_t HeightOfPlane;
  __IOSurface *v42;
  int v43;
  int v44;
  uint64_t v45;
  int API;
  uint64_t v47;
  signed int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  float y;
  float x;
  float32x2_t v56;
  float64x2_t v62;
  int8x8_t v63;
  __int32 is_ycc_444;
  int is_ycc_422;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int32x2_t v69;
  float32x2_t v71;
  float *v73;
  double v74;
  double v75;
  uint64_t v76;
  uint64_t v77;
  float64_t *v78;
  float64x2_t v79;
  float v80;
  uint64_t inserted;
  CI::Context *v82;
  NSObject *v83;
  NSObject *v84;
  os_signpost_id_t v85;
  NSObject *v86;
  uint64_t v87;
  float64_t v88;
  _QWORD v89[8];
  uint64_t v90;
  uint64_t v91;
  uint8_t v92[8];
  uint64_t v93;
  int v94;
  unsigned int v95[38];
  _QWORD block[5];
  _BYTE v97[8];
  os_signpost_id_t v98;
  CGRect v99;
  _DWORD v100[4];
  float32x2_t v101;
  float v102;
  __int32 v103;
  _BYTE v104[32];
  uint8_t buf[32];
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  void (*v136)(_QWORD, uint64_t);
  void (*v137)(_QWORD, _QWORD, _QWORD);
  uint64_t v138;
  Texture v139;
  CGRect v140;
  CGRect v141;

  v138 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)this;
  v99.origin.x = CI::parentROI::roi(this);
  v99.origin.y = v11;
  v99.size.width = v12;
  v99.size.height = v13;
  if (!v10)
    return;
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v14 = ci_signpost_log_render();
    v15 = *(int *)(v10 + 36) | (unint64_t)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1) << 32);
    if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v14))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 256;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = CI::Context::programName((dispatch_queue_t *)v10, v16);
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v14, OS_SIGNPOST_INTERVAL_BEGIN, v15, "render_node", "%{public}.256s", buf, 0x12u);
    }
  }
  v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
  TimerBase::TimerBase((uint64_t)v97, v17, *(_DWORD *)(v10 + 36), (uint64_t)"render_node", 0);
  CI::TileTask::addROIForNode(a2, (CI::ProgramNode *)v10, &v99);
  if (!*(_BYTE *)(a1 + 760) || !*(_BYTE *)(a1 + 762) || *(_BYTE *)(a1 + 761))
  {
    v18 = *(_QWORD *)(v10 + 48);
    if ((*(int (**)(uint64_t))(*(_QWORD *)v18 + 16))(v18) >= 41
      && (*(int (**)(uint64_t))(*(_QWORD *)v18 + 16))(v18) <= 42)
    {
      if (*(_BYTE *)(a1 + 780) && *(_QWORD *)(a1 + 784))
      {
        CI::GLContext::flush_render((void **)a1);
        v139.var0.var1.var0 = *(_DWORD *)(a1 + 532);
        v139.var0.var1.var1 = *(_DWORD *)(a1 + 544);
        v19 = (CI::Context *)CI::Context::render_processor_node((CI::Context *)a1, a2, this, *(__IOSurface **)(a1 + 784), v139);
        v20 = CI::Context::render_completion_queue(v19);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = ___ZN2CI9GLContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke;
        block[3] = &unk_1E2EC6390;
        block[4] = a5;
        dispatch_async(v20, block);
      }
      goto LABEL_46;
    }
    CI::GLContext::bind_render_target((void **)a1);
    v140.size.width = *(CGFloat *)(a1 + 512);
    v140.size.height = *(CGFloat *)(a1 + 520);
    v140.origin.x = 0.0;
    v140.origin.y = 0.0;
    CI::GLContext::set_viewport((CI::GLContext *)a1, v140);
    if (*(_BYTE *)(a1 + 762) || *(_BYTE *)(a1 + 780))
    {
      if (*(_QWORD *)(a1 + 400))
      {
        CI::GLContext::set_blend((void **)a1, *(_DWORD *)(a1 + 804) != 0, *(unsigned int *)(a1 + 808), *(unsigned int *)(a1 + 820), *(unsigned int *)(a1 + 812), *(unsigned int *)(a1 + 824), *(unsigned int *)(a1 + 816), *(unsigned int *)(a1 + 828));
        goto LABEL_21;
      }
      v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 288))(a1);
      v22 = a1;
    }
    else
    {
      v22 = a1;
      v21 = 0;
    }
    CI::GLContext::set_blend(v22, v21);
LABEL_21:
    CMatrix::CMatrix((CMatrix *)v95, 4u, 4u);
    v23 = 2.0 / *(double *)(a1 + 512);
    *(_QWORD *)buf = CMatrix::operator[](v95, 0);
    *(_QWORD *)&buf[8] = v24;
    *(double *)CMatrixRow::operator[]((uint64_t)buf, 0) = v23;
    v25 = 2.0 / *(double *)(a1 + 520);
    *(_QWORD *)buf = CMatrix::operator[](v95, 1u);
    *(_QWORD *)&buf[8] = v26;
    *(double *)CMatrixRow::operator[]((uint64_t)buf, 1u) = v25;
    *(_QWORD *)buf = CMatrix::operator[](v95, 3u);
    *(_QWORD *)&buf[8] = v27;
    *(_QWORD *)CMatrixRow::operator[]((uint64_t)buf, 1u) = 0xBFF0000000000000;
    *(_QWORD *)v92 = CMatrix::operator[](v95, 3u);
    v93 = v28;
    *(_QWORD *)CMatrixRow::operator[]((uint64_t)v92, 0) = 0xBFF0000000000000;
    *(_QWORD *)buf = CMatrix::operator[](v95, 3u);
    *(_QWORD *)&buf[8] = v29;
    *(_QWORD *)CMatrixRow::operator[]((uint64_t)buf, 3u) = 0x3FF0000000000000;
    *(_QWORD *)v92 = CMatrix::operator[](v95, 3u);
    v93 = v30;
    *(_QWORD *)CMatrixRow::operator[]((uint64_t)v92, 2u) = 0x3FF0000000000000;
    if (CI_VERBOSE_SIGNPOSTS())
    {
      v31 = ci_signpost_log_render();
      v32 = *(int *)(v10 + 36) | (unint64_t)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1) << 32);
      if (v32 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v31))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v31, OS_SIGNPOST_INTERVAL_BEGIN, v32, "render_node_mainProgram", (const char *)&unk_192520C83, buf, 2u);
      }
    }
    v33 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
    TimerBase::TimerBase((uint64_t)buf, v33, *(_DWORD *)(v10 + 36), (uint64_t)"render_node_mainProgram", 0);
    v34 = (unsigned int *)CI::ProgramNode::mainProgram((dispatch_queue_t *)v10);
    if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)v34 + 16))(v34) != 71)
      v34 = 0;
    if (CI_VERBOSE_SIGNPOSTS())
    {
      v35 = ci_signpost_log_render();
      v36 = *(_QWORD *)&buf[8];
      if ((unint64_t)(*(_QWORD *)&buf[8] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v37 = v35;
        if (os_signpost_enabled(v35))
        {
          *(_WORD *)v92 = 0;
          _os_signpost_emit_with_name_impl(&dword_1921E4000, v37, OS_SIGNPOST_INTERVAL_END, v36, "render_node_mainProgram", (const char *)&unk_192520C83, v92, 2u);
        }
      }
    }
    TimerBase::~TimerBase((TimerBase *)buf);
    v38 = v34[35];
    if ((_DWORD)v38
      || ((*(void (**)(unsigned int *, _QWORD))(*(_QWORD *)v34 + 80))(v34, *(unsigned int *)(v10 + 36)),
          v38 = v34[35],
          (_DWORD)v38))
    {
      CI::GLContext::set_program(a1, v38);
      CI::GLContext::bind_arguments((void **)a1, (const CI::ProgramNode *)v10, &v99, a2);
      CI::GLContext::quad((void **)a1, *(_DWORD *)(v10 + 36), 0, &v99.origin.x, (CMatrix *)v95);
    }
    if (*(_DWORD *)(a1 + 796))
    {
      v87 = a5;
      v135 = 0u;
      v134 = 0u;
      v133 = 0u;
      v132 = 0u;
      v131 = 0u;
      v130 = 0u;
      v129 = 0u;
      v128 = 0u;
      v127 = 0u;
      v126 = 0u;
      v125 = 0u;
      v124 = 0u;
      v123 = 0u;
      v122 = 0u;
      v121 = 0u;
      v120 = 0u;
      v119 = 0u;
      v118 = 0u;
      v117 = 0u;
      v116 = 0u;
      v115 = 0u;
      v114 = 0u;
      v113 = 0u;
      v112 = 0u;
      v111 = 0u;
      v110 = 0u;
      v108 = 0u;
      v109 = 0u;
      v106 = 0u;
      v107 = 0u;
      memset(buf, 0, sizeof(buf));
      GetMacroContext(*(void **)(a1 + 392), buf);
      if (!buf[0])
      {
        v39 = ci_logger_render();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
          ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
      }
      WidthOfPlane = IOSurfaceGetWidthOfPlane(*(IOSurfaceRef *)(a1 + 784), 1uLL);
      HeightOfPlane = IOSurfaceGetHeightOfPlane(*(IOSurfaceRef *)(a1 + 784), 1uLL);
      v43 = CI::format_from_IOSurface(*(CI **)(a1 + 784), v42);
      v44 = CI::format_of_plane(v43, 1);
      v45 = *(unsigned int *)(a1 + 544);
      (*((void (**)(_QWORD, uint64_t, uint64_t))&v126 + 1))(*(_QWORD *)&buf[8], 1, a1 + 800);
      (*((void (**)(_QWORD, uint64_t, _QWORD))&v108 + 1))(*(_QWORD *)&buf[8], v45, *(unsigned int *)(a1 + 800));
      *(_DWORD *)v92 = v44;
      *(_WORD *)&v92[4] = 0;
      API = CIEAGLContextGetAPI(*(void **)(a1 + 392));
      v47 = CI::gl_format_info_for_format((uint64_t)v92, API);
      CIEAGLContextTexImageIOSurface(*(void **)(a1 + 392), v45, WidthOfPlane, HeightOfPlane, v47, SHIDWORD(v47), v48, *(__IOSurface **)(a1 + 784), 1u);
      CI::GLContext::set_framebuffer(a1, *(unsigned int *)(a1 + 528));
      v94 = 36064;
      ((void (*)(_QWORD, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))v125)(*(_QWORD *)&buf[8], 36160, 36064, v45, *(unsigned int *)(a1 + 800), 0);
      ((void (*)(_QWORD, uint64_t, int *))v120)(*(_QWORD *)&buf[8], 1, &v94);
      v141.size.width = (double)WidthOfPlane;
      v141.size.height = (double)HeightOfPlane;
      v141.origin.x = 0.0;
      v141.origin.y = 0.0;
      CI::GLContext::set_viewport((CI::GLContext *)a1, v141);
      CI::GLContext::set_blend(a1, 0);
      if (!*(_DWORD *)(a1 + 888))
      {
        v49 = ((uint64_t (*)(_QWORD))v114)(*(_QWORD *)&buf[8]);
        v50 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
        v51 = CI::GLContext::compile_shader(v50, *(_DWORD *)(v10 + 36), *(void **)(a1 + 392), (uint64_t)"attribute highp vec4 position;\n"
                         "attribute highp vec4 texcoord;\n"
                         "varying highp vec2 p0;\n"
                         "void main()\n"
                         "{\n"
                         "  gl_Position = position;\n"
                         "  p0 = texcoord.xy;\n"
                         "}\n",
                35633);
        (*(void (**)(_QWORD, uint64_t, uint64_t))&buf[24])(*(_QWORD *)&buf[8], v49, v51);
        v52 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
        v53 = CI::GLContext::compile_shader(v52, *(_DWORD *)(v10 + 36), *(void **)(a1 + 392), (uint64_t)"varying highp vec2 p0;\n"
                         "uniform sampler2D s0;\n"
                         "void main()\n"
                         "{\n"
                         "  gl_FragColor = texture2D(s0, p0);\n"
                         "}\n",
                35632);
        (*(void (**)(_QWORD, uint64_t, uint64_t))&buf[24])(*(_QWORD *)&buf[8], v49, v53);
        (*((void (**)(_QWORD, uint64_t, _QWORD, const char *))&v106 + 1))(*(_QWORD *)&buf[8], v49, 0, "position");
        (*((void (**)(_QWORD, uint64_t, uint64_t, const char *))&v106 + 1))(*(_QWORD *)&buf[8], v49, 1, "texcoord");
        v136(*(_QWORD *)&buf[8], v49);
        (*((void (**)(_QWORD, uint64_t))&v116 + 1))(*(_QWORD *)&buf[8], v51);
        (*((void (**)(_QWORD, uint64_t))&v116 + 1))(*(_QWORD *)&buf[8], v53);
        *(_DWORD *)(a1 + 888) = v49;
        *(_DWORD *)(a1 + 892) = (*((uint64_t (**)(_QWORD, uint64_t, const char *))&v133 + 1))(*(_QWORD *)&buf[8], v49, "s0");
      }
      (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 80))(a1, *(unsigned int *)(a1 + 796), v45, 1, 1, 0);
      CI::GLContext::set_program(a1, *(unsigned int *)(a1 + 888));
      v137(*(_QWORD *)&buf[8], *(unsigned int *)(a1 + 892), 0);
      y = v99.origin.y;
      x = v99.origin.x;
      *(float *)&v100[2] = x;
      *(float *)&v100[3] = y;
      v102 = x;
      v56 = vcvt_f32_f64(vaddq_f64((float64x2_t)v99.origin, (float64x2_t)v99.size));
      *(float *)&v100[1] = y;
      v100[0] = v56.i32[0];
      v101 = v56;
      v103 = v56.i32[1];
      __asm { FMOV            V1.2D, #0.5 }
      v62 = vcvtq_f64_f32(vrndp_f32(vcvt_f32_f64(vmulq_f64((float64x2_t)v99.size, _Q1))));
      v63 = (int8x8_t)vcvt_f32_f64(vdivq_f64((float64x2_t)v99.size, vaddq_f64(v62, v62)));
      is_ycc_444 = CI::format_is_ycc_444(v43);
      is_ycc_422 = CI::format_is_ycc_422(v43);
      v68 = 0;
      v69.i32[0] = is_ycc_444;
      v69.i32[1] = is_ycc_422 | is_ycc_444;
      __asm { FMOV            V9.2S, #1.0 }
      v71 = (float32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(v69, 0x1FuLL)), (int8x8_t)_D9, v63);
      __asm { FMOV            V11.2S, #-1.0 }
      do
      {
        v73 = (float *)&v100[v68];
        v74 = *(float *)&v100[v68];
        v75 = *(float *)&v100[v68 + 1];
        CMatrix::CMatrix((CMatrix *)v92, 1u, 4u, v74, v66, v67, *(_QWORD *)&v75, 0, 0x3FF0000000000000);
        CMatrix::operator*((unsigned int *)v92, v95, (unsigned int *)&v90);
        CMatrix::operator=((unsigned int *)v92, (unsigned int *)&v90);
        v90 = CMatrix::operator[]((unsigned int *)v92, 0);
        v91 = v76;
        v88 = *(double *)CMatrixRow::operator[]((uint64_t)&v90, 0);
        v90 = CMatrix::operator[]((unsigned int *)v92, 0);
        v91 = v77;
        v78 = (float64_t *)CMatrixRow::operator[]((uint64_t)&v90, 1u);
        v79.f64[0] = v88;
        v79.f64[1] = *v78;
        *(float32x2_t *)&v104[v68 * 4] = vmla_f32(_D11, v71, vadd_f32(vcvt_f32_f64(v79), _D9));
        *(float *)v79.f64 = v74 / *(double *)(a1 + 512);
        v80 = v75 / *(double *)(a1 + 520);
        *v73 = *(float *)v79.f64;
        v73[1] = v80;
        v68 += 2;
      }
      while (v68 != 8);
      CI::GLContext::quad((void **)a1, *(_DWORD *)(v10 + 36), (uint64_t)v104, (uint64_t)v100);
      a5 = v87;
    }
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2000000000;
    *(_QWORD *)&buf[24] = *(_QWORD *)(a1 + 416);
    inserted = CI::GLContext::insert_fence((void **)a1);
    CI::GLContext::finish_render((void **)a1, a4);
    if (a2)
      v82 = (CI::Context *)CI::Object::ref((uint64_t)a2);
    v83 = CI::Context::render_completion_queue(v82);
    v89[0] = MEMORY[0x1E0C809B0];
    v89[1] = 0x40000000;
    v89[2] = ___ZN2CI9GLContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke_39;
    v89[3] = &unk_1E2EC63B8;
    v89[6] = inserted;
    v89[7] = a2;
    v89[4] = a5;
    v89[5] = buf;
    dispatch_async(v83, v89);
    _Block_object_dispose(buf, 8);
  }
LABEL_46:
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v84 = ci_signpost_log_render();
    v85 = v98;
    if (v98 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v86 = v84;
      if (os_signpost_enabled(v84))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v86, OS_SIGNPOST_INTERVAL_END, v85, "render_node", (const char *)&unk_192520C83, buf, 2u);
      }
    }
  }
  TimerBase::~TimerBase((TimerBase *)v97);
}

uint64_t ___ZN2CI9GLContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void CI::GLContext::bind_arguments(void **this, const CI::ProgramNode *a2, const CGRect *a3, CI::TileTask *a4)
{
  NSObject *v6;
  os_signpost_id_t v7;
  uint64_t v8;
  NSObject *v9;
  dispatch_queue_t v10;
  Class v11;
  Class isa;
  Class v13;
  NSObject *v14;
  os_signpost_id_t v15;
  uint64_t v16;
  int *v17;
  NSObject *v18;
  os_signpost_id_t v19;
  NSObject *v20;
  unint64_t v21;
  CI::TextureSampler **v22;
  int v23;
  CI::TextureSampler *v24;
  uint64_t v25;
  CGFloat v26;
  CGFloat v27;
  CGFloat v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int v31;
  NSObject *v32;
  os_signpost_id_t v33;
  NSObject *v34;
  unsigned int v35;
  CGAffineTransform v38;
  CGRect v39;
  CGAffineTransform v40;
  uint8_t buf[16];
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  void (*v73)(_QWORD, float);
  void (*v74)(_QWORD, uint64_t, _QWORD);
  void (*v75)(_QWORD, float, float);
  void (*v76)(_QWORD, float, float, float);
  void (*v77)(_QWORD, float, float, float, float);
  void (*v78)(_QWORD);
  void (*v79)(_QWORD);
  void (*v80)(_QWORD);
  char v81[8];
  os_signpost_id_t v82;
  uint8_t v83[8];
  uint64_t v84;
  uint64_t (**v85)();
  _BYTE v86[132];

  *(_QWORD *)&v86[116] = *MEMORY[0x1E0C80C00];
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v6 = ci_signpost_log_render();
    v7 = *((int *)a2 + 9) | (unint64_t)((*((uint64_t (**)(void **))*this + 34))(this) << 32);
    if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v6, OS_SIGNPOST_INTERVAL_BEGIN, v7, "bind_arguments", (const char *)&unk_192520C83, buf, 2u);
    }
  }
  v8 = (*((uint64_t (**)(void **))*this + 34))(this);
  TimerBase::TimerBase((uint64_t)v81, v8, *((_DWORD *)a2 + 9), (uint64_t)"bind_arguments", 11);
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  *(_OWORD *)buf = 0u;
  v42 = 0u;
  GetMacroContext(this[49], buf);
  if (!buf[0])
  {
    v9 = ci_logger_render();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  v10 = CI::ProgramNode::mainProgram((dispatch_queue_t *)a2);
  if ((*((unsigned int (**)(dispatch_queue_t))v10->isa + 2))(v10) == 71)
  {
    isa = v10[13].isa;
    v11 = v10[14].isa;
    v13 = v10[15].isa;
    if (CI_VERBOSE_SIGNPOSTS())
    {
      v14 = ci_signpost_log_render();
      v15 = *((int *)a2 + 9) | (unint64_t)((*((uint64_t (**)(void **))*this + 34))(this) << 32);
      if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v14))
      {
        *(_WORD *)v83 = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v14, OS_SIGNPOST_INTERVAL_BEGIN, v15, "render_node_arguments", (const char *)&unk_192520C83, v83, 2u);
      }
    }
    v16 = (*((uint64_t (**)(void **))*this + 34))(this);
    TimerBase::TimerBase((uint64_t)v83, v16, *((_DWORD *)a2 + 9), (uint64_t)"render_node_arguments", 0);
    dispatch_sync(*((dispatch_queue_t *)a2 + 13), &__block_literal_global_70_1);
    v17 = (int *)*((_QWORD *)a2 + 16);
    if (CI_VERBOSE_SIGNPOSTS())
    {
      v18 = ci_signpost_log_render();
      v19 = v84;
      if ((unint64_t)(v84 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v20 = v18;
        if (os_signpost_enabled(v18))
        {
          LOWORD(v39.origin.x) = 0;
          _os_signpost_emit_with_name_impl(&dword_1921E4000, v20, OS_SIGNPOST_INTERVAL_END, v19, "render_node_arguments", (const char *)&unk_192520C83, (uint8_t *)&v39, 2u);
        }
      }
    }
    TimerBase::~TimerBase((TimerBase *)v83);
    if (v17 && isa == (Class)*v17 && isa)
    {
      v21 = 0;
      v35 = 0;
      while (2)
      {
        if (v21 > 9)
          v22 = (CI::TextureSampler **)(*((_QWORD *)v17 + 2) + 8 * (v21 - 10));
        else
          v22 = (CI::TextureSampler **)&v17[2 * v21 + 6];
        v23 = *((_DWORD *)v13 + v21);
        v24 = *v22;
        switch(v23)
        {
          case 1:
          case 2:
          case 3:
          case 4:
            if ((*(unsigned int (**)(CI::TextureSampler *))(*(_QWORD *)v24 + 16))(v24) == 60)
            {
              if (*((_DWORD *)v11 + v21) != -1)
              {
                CI::ProgramNode::roiKeys_of_child(a2, *a3, *((unsigned int *)v24 + 8), v83);
                CI::Context::bind_sampler(this, (uint64_t)v24, *(uint64_t *)v83, v35, v23, a4);
                v74(*(_QWORD *)&buf[8], *((unsigned int *)v11 + v21), v35);
                if (*(_QWORD *)v83)
                {
                  v84 = *(_QWORD *)v83;
                  operator delete(*(void **)v83);
                }
              }
              ++v35;
              goto LABEL_65;
            }
            break;
          case 5:
          case 12:
            if ((*(unsigned int (**)(CI::TextureSampler *))(*(_QWORD *)v24 + 16))(v24) == 58)
            {
              if (*((_DWORD *)v11 + v21) != -1)
                v73(*(_QWORD *)&buf[8], *((float *)v24 + 7));
              goto LABEL_65;
            }
            break;
          case 6:
          case 13:
            if ((*(unsigned int (**)(CI::TextureSampler *))(*(_QWORD *)v24 + 16))(v24) == 58)
            {
              if (*((_DWORD *)v11 + v21) != -1)
                v75(*(_QWORD *)&buf[8], *((float *)v24 + 7), *((float *)v24 + 8));
              goto LABEL_65;
            }
            break;
          case 7:
          case 14:
            if ((*(unsigned int (**)(CI::TextureSampler *))(*(_QWORD *)v24 + 16))(v24) == 58)
            {
              if (*((_DWORD *)v11 + v21) != -1)
                v76(*(_QWORD *)&buf[8], *((float *)v24 + 7), *((float *)v24 + 8), *((float *)v24 + 9));
              goto LABEL_65;
            }
            break;
          case 8:
          case 15:
          case 27:
            if ((*(unsigned int (**)(CI::TextureSampler *))(*(_QWORD *)v24 + 16))(v24) == 58)
            {
              if (*((_DWORD *)v11 + v21) != -1)
                v77(*(_QWORD *)&buf[8], *((float *)v24 + 7), *((float *)v24 + 8), *((float *)v24 + 9), *((float *)v24 + 10));
              goto LABEL_65;
            }
            break;
          case 9:
          case 16:
            if ((*(unsigned int (**)(CI::TextureSampler *))(*(_QWORD *)v24 + 16))(v24) == 58)
            {
              if (*((_DWORD *)v11 + v21) != -1)
                v78(*(_QWORD *)&buf[8]);
              goto LABEL_65;
            }
            break;
          case 10:
          case 17:
            if ((*(unsigned int (**)(CI::TextureSampler *))(*(_QWORD *)v24 + 16))(v24) == 58)
            {
              if (*((_DWORD *)v11 + v21) != -1)
                v79(*(_QWORD *)&buf[8]);
              goto LABEL_65;
            }
            break;
          case 11:
          case 18:
            if ((*(unsigned int (**)(CI::TextureSampler *))(*(_QWORD *)v24 + 16))(v24) == 58)
            {
              if (*((_DWORD *)v11 + v21) != -1)
                v80(*(_QWORD *)&buf[8]);
              goto LABEL_65;
            }
            break;
          case 19:
            if ((*(unsigned int (**)(CI::TextureSampler *))(*(_QWORD *)v24 + 16))(v24) == 58)
            {
              v25 = *((unsigned int *)v11 + v21);
              if ((_DWORD)v25 != -1)
                v74(*(_QWORD *)&buf[8], v25, (int)*((float *)v24 + 7));
              goto LABEL_65;
            }
            break;
          case 40:
            if ((*(unsigned int (**)(CI::TextureSampler *))(*(_QWORD *)v24 + 16))(v24) == 60)
            {
              if (*((_DWORD *)v11 + v21) != -1)
              {
                memset(&v39, 0, sizeof(v39));
                v39.origin.x = CI::Node::region_of_child(a2, *a3);
                v39.origin.y = v26;
                v39.size.width = v27;
                v39.size.height = v28;
                CI::TextureSampler::transform(v24, (const CI::Context *)this, &v39, (float64x2_t *)&v40);
                CI::Vector::Vector((CI::Vector *)v83, &v40);
                ((void (*)(_QWORD, _QWORD, uint64_t, _QWORD, _BYTE *))v79)(*(_QWORD *)&buf[8], *((unsigned int *)v11 + v21), 1, 0, v86);
                v85 = off_1E2EBBEE8;
                do
                  v29 = __ldaxr(dword_1ECF873D0);
                while (__stlxr(v29 - 1, dword_1ECF873D0));
              }
              goto LABEL_65;
            }
            break;
          case 41:
          case 42:
          case 43:
          case 46:
          case 47:
            goto LABEL_65;
          case 44:
            if ((*(unsigned int (**)(CI::TextureSampler *))(*(_QWORD *)v24 + 16))(v24) != 58)
              break;
            CI::Vector::affine(v24, (double *)v83);
            CI::Affine::inverse((CI::Affine *)v83, &v39.origin.x);
            CI::Affine::inverse((CI::Affine *)&v39, &v38.a);
            CI::Vector::Vector((CI::Vector *)v83, &v38);
            v30 = *((unsigned int *)v11 + v21);
            if ((_DWORD)v30 != -1)
              ((void (*)(_QWORD, uint64_t, uint64_t, _QWORD, _BYTE *))v79)(*(_QWORD *)&buf[8], v30, 1, 0, v86);
            v85 = off_1E2EBBEE8;
            do
              v31 = __ldaxr(dword_1ECF873D0);
            while (__stlxr(v31 - 1, dword_1ECF873D0));
LABEL_65:
            if ((Class)++v21 == isa)
              break;
            continue;
          default:
            x_log("Unhandled type: %d\n", *((_DWORD *)v13 + v21));
            goto LABEL_65;
        }
        break;
      }
    }
  }
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v32 = ci_signpost_log_render();
    v33 = v82;
    if (v82 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v34 = v32;
      if (os_signpost_enabled(v32))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v34, OS_SIGNPOST_INTERVAL_END, v33, "bind_arguments", (const char *)&unk_192520C83, buf, 2u);
      }
    }
  }
  TimerBase::~TimerBase((TimerBase *)v81);
}

uint64_t ___ZN2CI9GLContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke_39(_QWORD *a1)
{
  NSObject *v2;
  uint64_t v3;
  CI::Object *v4;
  _OWORD v6[8];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;

  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  memset(v6, 0, sizeof(v6));
  GetMacroContext(*(void **)(*(_QWORD *)(a1[5] + 8) + 24), v6);
  if (!LOBYTE(v6[0]))
  {
    v2 = ci_logger_render();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      ___ZN2CI9GLContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke_39_cold_1();
  }
  ((void (*)(_QWORD, _QWORD, _QWORD, uint64_t))v7)(*((_QWORD *)&v6[0] + 1), a1[6], 0, -1);
  ((void (*)(_QWORD, _QWORD))v12)(*((_QWORD *)&v6[0] + 1), a1[6]);
  v3 = a1[7];
  *(CFAbsoluteTime *)(v3 + 40) = CFAbsoluteTimeGetCurrent();
  v4 = (CI::Object *)a1[7];
  if (v4)
    CI::Object::unref(v4);
  return (*(uint64_t (**)(void))(a1[4] + 16))();
}

void CI::GLContext::render_intermediate_node(CI::GLContext *a1, CI::TileTask *a2, CI::parentROI *this, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  CGFloat v12;
  CGFloat v13;
  CGFloat v14;
  NSObject *v15;
  os_signpost_id_t v16;
  const CI::ProgramNode *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  os_signpost_id_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  os_signpost_id_t v27;
  NSObject *v28;
  __IOSurface *v29;
  void *v30;
  void (*v31)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD);
  uint64_t v32;
  uint64_t v33;
  double y;
  double x;
  CGFloat width;
  CGFloat height;
  CGFloat MidY;
  CGFloat v39;
  NSObject *v40;
  os_signpost_id_t v41;
  uint64_t v42;
  unsigned int *v43;
  NSObject *v44;
  os_signpost_id_t v45;
  NSObject *v46;
  uint64_t v47;
  NSObject *v48;
  os_signpost_id_t v49;
  uint64_t v50;
  CI::Context *inserted;
  NSObject *v52;
  NSObject *v53;
  os_signpost_id_t v54;
  NSObject *v55;
  NSObject *v56;
  os_signpost_id_t v57;
  NSObject *v58;
  _QWORD block[7];
  uint8_t v60[8];
  uint8_t *v61;
  uint64_t v62;
  uint64_t v63;
  CGAffineTransform v64;
  _BYTE v65[8];
  os_signpost_id_t v66;
  CGRect v67;
  uint8_t v68[4];
  _BYTE v69[12];
  uint8_t buf[32];
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  uint64_t v101;
  Texture v102;
  CGRect v103;
  CGRect v104;
  CGRect v105;
  CGRect v106;

  v101 = *MEMORY[0x1E0C80C00];
  v11 = *(_QWORD *)this;
  v67.origin.x = CI::parentROI::roi(this);
  v67.origin.y = v12;
  v67.size.width = v13;
  v67.size.height = v14;
  if (a4 && v11)
  {
    if (CI_VERBOSE_SIGNPOSTS())
    {
      v15 = ci_signpost_log_render();
      v16 = *(int *)(v11 + 36) | (unint64_t)((*(uint64_t (**)(CI::GLContext *))(*(_QWORD *)a1 + 272))(a1) << 32);
      if (v16 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v15))
      {
        *(_DWORD *)buf = 68289026;
        *(_DWORD *)&buf[4] = 256;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = CI::Context::programName((dispatch_queue_t *)v11, v17);
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v15, OS_SIGNPOST_INTERVAL_BEGIN, v16, "render_node", "%{public}.256s", buf, 0x12u);
      }
    }
    v18 = (*(uint64_t (**)(CI::GLContext *))(*(_QWORD *)a1 + 272))(a1);
    TimerBase::TimerBase((uint64_t)v65, v18, *(_DWORD *)(v11 + 36), (uint64_t)"render_node", 0);
    CI::TileTask::addROIForNode(a2, (CI::ProgramNode *)v11, &v67);
    v99 = 0u;
    v100 = 0u;
    v97 = 0u;
    v98 = 0u;
    v95 = 0u;
    v96 = 0u;
    v93 = 0u;
    v94 = 0u;
    v91 = 0u;
    v92 = 0u;
    v89 = 0u;
    v90 = 0u;
    v87 = 0u;
    v88 = 0u;
    v85 = 0u;
    v86 = 0u;
    v83 = 0u;
    v84 = 0u;
    v81 = 0u;
    v82 = 0u;
    v79 = 0u;
    v80 = 0u;
    v77 = 0u;
    v78 = 0u;
    v75 = 0u;
    v76 = 0u;
    v73 = 0u;
    v74 = 0u;
    v71 = 0u;
    v72 = 0u;
    memset(buf, 0, sizeof(buf));
    GetMacroContext(*((void **)a1 + 49), buf);
    if (!buf[0])
    {
      v19 = ci_logger_render();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
    }
    v20 = *(_QWORD *)(v11 + 48);
    if ((*(int (**)(uint64_t))(*(_QWORD *)v20 + 16))(v20) < 41
      || (*(int (**)(uint64_t))(*(_QWORD *)v20 + 16))(v20) > 42)
    {
      CI::GLContext::set_framebuffer((uint64_t)a1, *((unsigned int *)a1 + 188));
      v31 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))v90;
      v32 = *(_QWORD *)&buf[8];
      v33 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 24))(a4);
      v31(v32, 36160, 36064, 3553, v33, 0);
      x = v67.origin.x;
      y = v67.origin.y;
      width = v67.size.width;
      height = v67.size.height;
      if (*(_BYTE *)(v11 + 148))
      {
        v103 = *(CGRect *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 32))(a4);
        MidY = CGRectGetMidY(v103);
        v64.b = 0.0;
        v64.c = 0.0;
        v64.a = 1.0;
        *(_OWORD *)&v64.d = xmmword_192493540;
        v64.ty = MidY + MidY;
        v104.origin.x = x;
        v104.origin.y = y;
        v104.size.width = width;
        v104.size.height = height;
        v105 = CGRectApplyAffineTransform(v104, &v64);
        x = v105.origin.x;
        y = v105.origin.y;
        width = v105.size.width;
        height = v105.size.height;
      }
      v39 = x - *(double *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 32))(a4);
      v106.origin.y = y - *(double *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 32))(a4) + 8);
      v106.origin.x = v39;
      v106.size.width = width;
      v106.size.height = height;
      CI::GLContext::set_viewport(a1, v106);
      CI::GLContext::set_blend((uint64_t)a1, 0);
      if (CI_VERBOSE_SIGNPOSTS())
      {
        v40 = ci_signpost_log_render();
        v41 = *(int *)(v11 + 36) | (unint64_t)((*(uint64_t (**)(CI::GLContext *))(*(_QWORD *)a1 + 272))(a1) << 32);
        if (v41 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v40))
        {
          *(_WORD *)v68 = 0;
          _os_signpost_emit_with_name_impl(&dword_1921E4000, v40, OS_SIGNPOST_INTERVAL_BEGIN, v41, "render_node_mainProgram", (const char *)&unk_192520C83, v68, 2u);
        }
      }
      v42 = (*(uint64_t (**)(CI::GLContext *))(*(_QWORD *)a1 + 272))(a1);
      TimerBase::TimerBase((uint64_t)v68, v42, *(_DWORD *)(v11 + 36), (uint64_t)"render_node_mainProgram", 0);
      v43 = (unsigned int *)CI::ProgramNode::mainProgram((dispatch_queue_t *)v11);
      if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)v43 + 16))(v43) != 71)
        v43 = 0;
      if (CI_VERBOSE_SIGNPOSTS())
      {
        v44 = ci_signpost_log_render();
        v45 = *(_QWORD *)&v69[4];
        if ((unint64_t)(*(_QWORD *)&v69[4] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v46 = v44;
          if (os_signpost_enabled(v44))
          {
            *(_WORD *)v60 = 0;
            _os_signpost_emit_with_name_impl(&dword_1921E4000, v46, OS_SIGNPOST_INTERVAL_END, v45, "render_node_mainProgram", (const char *)&unk_192520C83, v60, 2u);
          }
        }
      }
      TimerBase::~TimerBase((TimerBase *)v68);
      v47 = v43[35];
      if ((_DWORD)v47
        || ((*(void (**)(unsigned int *, _QWORD))(*(_QWORD *)v43 + 80))(v43, *(unsigned int *)(v11 + 36)),
            v47 = v43[35],
            (_DWORD)v47))
      {
        CI::GLContext::set_program((uint64_t)a1, v47);
        CI::GLContext::bind_arguments((void **)a1, (const CI::ProgramNode *)v11, &v67, a2);
        CI::GLContext::quad((void **)a1, *(_DWORD *)(v11 + 36), *(unsigned __int8 *)(v11 + 148), &v67.origin.x, 0);
      }
    }
    else
    {
      v21 = *(_QWORD *)(v11 + 48);
      if (*(_BYTE *)(v21 + 153) && (*(int (**)(_QWORD))(*(_QWORD *)v21 + 40))(*(_QWORD *)(v11 + 48)) >= 1)
      {
        if (CI_VERBOSE_SIGNPOSTS())
        {
          v22 = ci_signpost_log_render();
          v23 = *(int *)(v21 + 36) | (unint64_t)((*(uint64_t (**)(CI::GLContext *))(*(_QWORD *)a1 + 272))(a1) << 32);
          if (v23 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v22))
          {
            v24 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
            *(_DWORD *)v68 = 138543362;
            *(_QWORD *)v69 = v24;
            _os_signpost_emit_with_name_impl(&dword_1921E4000, v22, OS_SIGNPOST_INTERVAL_BEGIN, v23, "processor_syncinputs", "%{public}@", v68, 0xCu);
          }
        }
        v25 = (*(uint64_t (**)(CI::GLContext *))(*(_QWORD *)a1 + 272))(a1);
        TimerBase::TimerBase((uint64_t)v68, v25, *(_DWORD *)(v21 + 36), (uint64_t)"processor_syncinputs", 0);
        CI::GLContext::flush_render((void **)a1);
        if (CI_VERBOSE_SIGNPOSTS())
        {
          v26 = ci_signpost_log_render();
          v27 = *(_QWORD *)&v69[4];
          if ((unint64_t)(*(_QWORD *)&v69[4] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
          {
            v28 = v26;
            if (os_signpost_enabled(v26))
            {
              *(_WORD *)v60 = 0;
              _os_signpost_emit_with_name_impl(&dword_1921E4000, v28, OS_SIGNPOST_INTERVAL_END, v27, "processor_syncinputs", (const char *)&unk_192520C83, v60, 2u);
            }
          }
        }
        TimerBase::~TimerBase((TimerBase *)v68);
      }
      v29 = (__IOSurface *)(**(uint64_t (***)(uint64_t))a4)(a4);
      v102.var0.var0 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 24))(a4);
      v102.var0.var2.var1 = v30;
      CI::Context::render_processor_node(a1, a2, this, v29, v102);
    }
    if (CI_VERBOSE_SIGNPOSTS())
    {
      v48 = ci_signpost_log_render();
      v49 = *(int *)(v11 + 36) | (unint64_t)((*(uint64_t (**)(CI::GLContext *))(*(_QWORD *)a1 + 272))(a1) << 32);
      if (v49 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v48))
      {
        *(_WORD *)v68 = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v48, OS_SIGNPOST_INTERVAL_BEGIN, v49, "after_render", (const char *)&unk_192520C83, v68, 2u);
      }
    }
    v50 = (*(uint64_t (**)(CI::GLContext *))(*(_QWORD *)a1 + 272))(a1);
    TimerBase::TimerBase((uint64_t)v68, v50, *(_DWORD *)(v11 + 36), (uint64_t)"after_render", 8);
    *(_QWORD *)v60 = 0;
    v61 = v60;
    v62 = 0x2000000000;
    v63 = *((_QWORD *)a1 + 52);
    inserted = (CI::Context *)CI::GLContext::insert_fence((void **)a1);
    v52 = CI::Context::render_completion_queue(inserted);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___ZN2CI9GLContext24render_intermediate_nodeEPNS_8TileTaskERKNS_9parentROIEPNS_14intermediate_tEbU13block_pointerFvvE_block_invoke;
    block[3] = &unk_1E2EC63E0;
    block[5] = v60;
    block[6] = inserted;
    block[4] = a6;
    dispatch_async(v52, block);
    _Block_object_dispose(v60, 8);
    if (CI_VERBOSE_SIGNPOSTS())
    {
      v53 = ci_signpost_log_render();
      v54 = *(_QWORD *)&v69[4];
      if ((unint64_t)(*(_QWORD *)&v69[4] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v55 = v53;
        if (os_signpost_enabled(v53))
        {
          *(_WORD *)v60 = 0;
          _os_signpost_emit_with_name_impl(&dword_1921E4000, v55, OS_SIGNPOST_INTERVAL_END, v54, "after_render", (const char *)&unk_192520C83, v60, 2u);
        }
      }
    }
    TimerBase::~TimerBase((TimerBase *)v68);
    if (CI_VERBOSE_SIGNPOSTS())
    {
      v56 = ci_signpost_log_render();
      v57 = v66;
      if (v66 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v58 = v56;
        if (os_signpost_enabled(v56))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl(&dword_1921E4000, v58, OS_SIGNPOST_INTERVAL_END, v57, "render_node", (const char *)&unk_192520C83, buf, 2u);
        }
      }
    }
    TimerBase::~TimerBase((TimerBase *)v65);
  }
}

uint64_t ___ZN2CI9GLContext24render_intermediate_nodeEPNS_8TileTaskERKNS_9parentROIEPNS_14intermediate_tEbU13block_pointerFvvE_block_invoke(_QWORD *a1)
{
  NSObject *v2;
  _OWORD v4[8];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;

  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  v5 = 0u;
  v6 = 0u;
  memset(v4, 0, sizeof(v4));
  GetMacroContext(*(void **)(*(_QWORD *)(a1[5] + 8) + 24), v4);
  if (!LOBYTE(v4[0]))
  {
    v2 = ci_logger_render();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      ___ZN2CI9GLContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke_39_cold_1();
  }
  ((void (*)(_QWORD, _QWORD, _QWORD, uint64_t))v5)(*((_QWORD *)&v4[0] + 1), a1[6], 0, -1);
  ((void (*)(_QWORD, _QWORD))v10)(*((_QWORD *)&v4[0] + 1), a1[6]);
  return (*(uint64_t (**)(void))(a1[4] + 16))();
}

uint64_t CI::GLContext::pre_render(CI::GLContext *this)
{
  int v2;
  CI *v3;

  v2 = *((_DWORD *)this + 226);
  v3 = (CI *)CI_FORCE_GPU_PRIORITY();
  if (v3 <= 0x4Bu)
  {
    if ((_BYTE)v3)
    {
      if (v3 == 72)
        v2 = 0;
      goto LABEL_11;
    }
    if (!CI::originating_process_is_in_background(v3))
      goto LABEL_11;
    x_log("Using low GPU priority for background rendering.\n");
LABEL_10:
    v2 = 2;
    goto LABEL_11;
  }
  if (v3 == 76)
    goto LABEL_10;
  if (v3 == 78)
    v2 = 1;
LABEL_11:
  CIEAGLContextSetParameter(*((void **)this + 49), 608, v2);
  return 1;
}

void CI::GLContext::readback_bitmap(uint64_t a1, _QWORD *a2, int *a3)
{
  NSObject *v6;
  os_signpost_id_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int API;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  BOOL v21;
  BOOL v22;
  NSObject *v24;
  os_signpost_id_t v25;
  NSObject *v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  os_signpost_id_t v37;
  unsigned int v38;
  uint8_t buf[32];
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  void (*v70)(_QWORD, uint64_t, unint64_t);
  void (*v71)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, uint64_t);
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v6 = ci_signpost_log_render();
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1) << 32;
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
  {
    v8 = a2[10];
    v9 = a2[11];
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = v8;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v9;
    _os_signpost_emit_with_name_impl(&dword_1921E4000, v6, OS_SIGNPOST_INTERVAL_BEGIN, v7, "readback_bitmap", "[%zu %zu]", buf, 0x16u);
  }
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
  TimerBase::TimerBase((uint64_t)&v36, v10, 0, (uint64_t)"readback_bitmap", 7);
  if (a2)
  {
    *(_DWORD *)buf = *a3;
    *(_WORD *)&buf[4] = 0;
    API = CIEAGLContextGetAPI(*(void **)(a1 + 392));
    v12 = CI::gl_format_info_for_format((uint64_t)buf, API);
    v14 = v13;
    v15 = *(void **)(a1 + 392);
    v16 = (int)*(double *)(a1 + 512);
    v17 = (int)*(double *)(a1 + 520);
    v18 = a2[9];
    v19 = a2[12];
    v20 = (int)CI::format_bytes_per_pixel(*a3);
    v21 = (int)v16 < 1 || (int)v17 < 1;
    v22 = v21 || v19 == 0;
    if (!v22 && (_DWORD)v20 != 0)
    {
      v68 = 0u;
      v69 = 0u;
      v66 = 0u;
      v67 = 0u;
      v64 = 0u;
      v65 = 0u;
      v62 = 0u;
      v63 = 0u;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v56 = 0u;
      v57 = 0u;
      v54 = 0u;
      v55 = 0u;
      v52 = 0u;
      v53 = 0u;
      v50 = 0u;
      v51 = 0u;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v44 = 0u;
      v45 = 0u;
      v42 = 0u;
      v43 = 0u;
      v40 = 0u;
      v41 = 0u;
      memset(buf, 0, sizeof(buf));
      GetMacroContext(v15, buf);
      if (!buf[0])
      {
        v27 = ci_logger_render();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          CI::GLTextureManager::release_texture((uint64_t)v15, v27, v28, v29, v30, v31, v32, v33);
      }
      v38 = 0;
      ((void (*)(_QWORD, uint64_t, unsigned int *))v63)(*(_QWORD *)&buf[8], 3333, &v38);
      v34 = v20 * v16;
      if (v20 * v16 == v19)
      {
        v71(*(_QWORD *)&buf[8], 0, 0, v16, v17, HIDWORD(v12), v14, v18);
      }
      else
      {
        if ((v18 & 1) != 0 || ((v34 + 1) & 0xFFFFFFFFFFFFFFFELL) != v19)
        {
          if ((v18 & 3) != 0 || ((v34 + 3) & 0xFFFFFFFFFFFFFFFCLL) != v19)
          {
            if ((v18 & 7) != 0 || ((v34 + 7) & 0xFFFFFFFFFFFFFFF8) != v19)
            {
              if ((int)CIEAGLContextGetAPI(v15) < 3 || v19 % v20)
              {
                v35 = 0;
                do
                {
                  v71(*(_QWORD *)&buf[8], 0, v35++, v16, 1, HIDWORD(v12), v14, v18);
                  v18 += v19;
                }
                while (v17 != v35);
              }
              else
              {
                v70(*(_QWORD *)&buf[8], 3330, (int)v19 / v20);
                v71(*(_QWORD *)&buf[8], 0, 0, v16, v17, HIDWORD(v12), v14, v18);
                v70(*(_QWORD *)&buf[8], 3330, 0);
              }
              goto LABEL_16;
            }
            v70(*(_QWORD *)&buf[8], 3333, 8uLL);
          }
          else
          {
            v70(*(_QWORD *)&buf[8], 3333, 4uLL);
          }
        }
        else
        {
          v70(*(_QWORD *)&buf[8], 3333, 2uLL);
        }
        v71(*(_QWORD *)&buf[8], 0, 0, v16, v17, HIDWORD(v12), v14, v18);
        v70(*(_QWORD *)&buf[8], 3333, v38);
      }
    }
  }
LABEL_16:
  v24 = ci_signpost_log_render();
  v25 = v37;
  if (v37 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v26 = v24;
    if (os_signpost_enabled(v24))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v26, OS_SIGNPOST_INTERVAL_END, v25, "readback_bitmap", (const char *)&unk_192520C83, buf, 2u);
    }
  }
  TimerBase::~TimerBase((TimerBase *)&v36);
}

uint64_t CI::GLContext::format_is_directly_supported_for_input(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  int API;
  _BOOL8 v8;
  uint64_t v9;

  if (CI::format_is_ycc_biplanar(a2))
  {
    v4 = CI::format_of_plane(a2, 0);
    v5 = CI::format_of_plane(a2, 1);
    LODWORD(v4) = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 424))(a1, v4);
    return v4 & (*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 424))(a1, v5);
  }
  API = CIEAGLContextGetAPI(*(void **)(a1 + 392));
  result = 0;
  v8 = API == 3;
  v9 = 1;
  if (a2 <= 784)
  {
    if (((a2 - 257) > 0x14 || ((1 << (a2 - 1)) & 0x1802BD) == 0) && (a2 - 532) >= 2)
    {
      if (a2 != 784)
        return result;
      return 0;
    }
    return v9;
  }
  if (a2 <= 2308)
  {
    if ((a2 - 2053) > 3 || a2 == 2055)
    {
      v9 = v8;
      if (a2 != 785)
      {
        if (a2 != 1800)
          return result;
        return CI_DISABLE_WORKAROUND() == 28765295;
      }
    }
    return v9;
  }
  if ((a2 - 2309) < 2)
    return v9;
  if (a2 == 2567)
    return *(char *)(a1 + 880) < 0;
  v9 = v8;
  if (a2 == 2312)
    return v9;
  return result;
}

BOOL CI::GLContext::format_is_directly_supported_for_output(uint64_t a1, int a2, int a3)
{
  int API;
  _BOOL8 result;
  uint64_t v8;

  API = CIEAGLContextGetAPI(*(void **)(a1 + 392));
  result = 0;
  v8 = 1;
  if (a2 > 1798)
  {
    if (a2 > 2308)
    {
      if ((a2 - 2309) > 3 || a2 == 2311)
      {
        if (a2 != 2567)
          return result;
        return a3 == 2 && *(char *)(a1 + 880) < 0;
      }
      return v8;
    }
    if ((a2 - 2053) <= 3 && a2 != 2055)
      return (*(unsigned __int8 *)(a1 + 880) >> 3) & 1;
    if (a2 != 1799)
      return result;
    return a3 != 1;
  }
  if (a2 <= 273)
  {
    if ((a2 - 261) < 2)
      return v8;
    if (a2 != 263)
    {
      if (a2 != 264)
        return result;
      return v8;
    }
    return a3 != 1;
  }
  if (a2 > 783)
  {
    if (a2 == 784)
      return 0;
    if (a2 != 785)
      return result;
    return API == 3;
  }
  if (a2 == 274 || a2 == 530)
    return (*(unsigned __int8 *)(a1 + 880) >> 2) & 1;
  return result;
}

uint64_t CI::GLContext::bind_cgimage(_QWORD ***a1, CGImage *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;

  if (!a2)
    return 0;
  v10 = CI::GLTextureManager::texture_for_CGImage(a1[53], a2, a3);
  return ((uint64_t (*)(_QWORD ***, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*a1)[10])(a1, v10, 3553, a4, a5, a6);
}

BOOL CI::GLContext::bind_surface(uint64_t a1, IOSurfaceRef buffer, int *a3, char a4, int a5, int a6, int a7, int a8)
{
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  int v21;
  __int16 v22;
  uint64_t block;
  uint64_t v24;
  _QWORD *(*v25)(uint64_t);
  void *v26;
  uint64_t v27;
  IOSurfaceRef v28;
  int *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  char v34;
  char v35;

  if (buffer)
  {
    if (a5)
      v14 = 9729;
    else
      v14 = 9728;
    if (a6)
      v15 = 33071;
    else
      v15 = 33069;
    if (IOSurfaceGetPlaneCount(buffer) == 2)
    {
      v16 = CI::format_of_plane(*a3, a8);
      v17 = *(_QWORD *)(a1 + 424);
      v21 = v16;
      v22 = 0;
      v18 = *(NSObject **)(v17 + 104);
      block = MEMORY[0x1E0C809B0];
      v24 = 0x40000000;
      v25 = ___ZN2CI16GLTextureManager16attach_IOSurfaceEP11__IOSurfacebiRKNS_17TextureDescriptorEiiib_block_invoke;
      v26 = &__block_descriptor_tmp_14_0;
      v27 = v17;
      v28 = buffer;
      v34 = 1;
      v29 = &v21;
    }
    else
    {
      v19 = *(_QWORD *)(a1 + 424);
      v18 = *(NSObject **)(v19 + 104);
      block = MEMORY[0x1E0C809B0];
      v24 = 0x40000000;
      v25 = ___ZN2CI16GLTextureManager16attach_IOSurfaceEP11__IOSurfacebiRKNS_17TextureDescriptorEiiib_block_invoke;
      v26 = &__block_descriptor_tmp_14_0;
      v27 = v19;
      v28 = buffer;
      v34 = 0;
      v29 = a3;
    }
    v30 = a8;
    v31 = a7;
    v35 = a4;
    v32 = v14;
    v33 = v15;
    dispatch_sync(v18, &block);
  }
  return buffer != 0;
}

uint64_t CI::GLContext::bind_texture(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6)
{
  BOOL v6;
  uint64_t v7;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  void (*v48)(_QWORD, uint64_t, uint64_t, uint64_t);

  if ((_DWORD)a2)
    v6 = a3 == 3553;
  else
    v6 = 0;
  v7 = v6;
  if (v6)
  {
    v46 = 0u;
    v47 = 0u;
    v44 = 0u;
    v45 = 0u;
    v42 = 0u;
    v43 = 0u;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    GetMacroContext(*(void **)(a1 + 392), &v16);
    if (!(_BYTE)v16)
    {
      v12 = ci_logger_render();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
    }
    ((void (*)(_QWORD, _QWORD))v17)(*((_QWORD *)&v16 + 1), (a6 + 33984));
    (*((void (**)(_QWORD, uint64_t, uint64_t))&v20 + 1))(*((_QWORD *)&v16 + 1), 3553, a2);
    if (a4)
      v13 = 9729;
    else
      v13 = 9728;
    if (a5)
      v14 = 33071;
    else
      v14 = 33069;
    v48(*((_QWORD *)&v16 + 1), 3553, 10240, v13);
    v48(*((_QWORD *)&v16 + 1), 3553, 10241, v13);
    v48(*((_QWORD *)&v16 + 1), 3553, 10242, v14);
    v48(*((_QWORD *)&v16 + 1), 3553, 10243, v14);
  }
  return v7;
}

uint64_t CI::GLContext::bind_intermediate(uint64_t a1, unint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, unint64_t, unint64_t))(*(_QWORD *)a1 + 80))(a1, a2, HIDWORD(a2));
}

uint64_t CI::GLContext::supported_compute_features(void **this)
{
  if (CIEAGLContextGetAPI(this[49]) == 3)
    return 36;
  else
    return 32;
}

BOOL CI::GLContext::supports_sRGB_texture_for_format(uint64_t a1, int a2)
{
  int v2;
  int API;

  switch(a2)
  {
    case 2567:
      v2 = 8;
      goto LABEL_7;
    case 266:
      v2 = 6;
      goto LABEL_7;
    case 264:
      v2 = 7;
LABEL_7:
      API = CIEAGLContextGetAPI(*(void **)(a1 + 392));
      return CIGLGetFormatInfo(API, v2) != 0;
  }
  return 0;
}

uint64_t CI::GLContext::blitSurface(void **a1, CI *a2, unsigned int *a3, uint64_t a4, unsigned int *a5, uint64_t a6)
{
  void **v12;
  __IOSurface *v13;
  NSObject *v14;
  uint64_t v15;
  int API;
  unint64_t v17;
  GLint v18;
  signed int v19;
  signed int v20;
  unint64_t v21;
  const char *v22;
  BOOL v23;
  const char *v24;
  size_t v25;
  void (*v26)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD);
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  _QWORD *v31;
  void *v32;
  size_t Width;
  size_t Height;
  CI::Context *inserted;
  NSObject *v36;
  void *v37;
  uint64_t v38;
  CI::Context *v39;
  NSObject *v40;
  uint64_t v42;
  unsigned int *v43;
  void *v44;
  _QWORD v45[6];
  _QWORD block[8];
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  _OWORD v50[3];
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;

  v78 = 0u;
  v79 = 0u;
  v76 = 0u;
  v77 = 0u;
  v74 = 0u;
  v75 = 0u;
  v72 = 0u;
  v73 = 0u;
  v70 = 0u;
  v71 = 0u;
  v68 = 0u;
  v69 = 0u;
  v66 = 0u;
  v67 = 0u;
  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v51 = 0u;
  memset(v50, 0, sizeof(v50));
  v12 = a1 + 49;
  GetMacroContext(a1[49], v50);
  if (!LOBYTE(v50[0]))
  {
    v14 = ci_logger_render();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  v15 = CI::format_from_IOSurface(a2, v13);
  if (!(*((unsigned int (**)(void **, uint64_t, uint64_t))*a1 + 54))(a1, v15, 1))
    return 0;
  API = CIEAGLContextGetAPI(*v12);
  v17 = CI::gl_format_info_for_format(a6, API);
  v18 = v17;
  v20 = v19;
  v21 = HIDWORD(v17);
  v22 = (const char *)((uint64_t (*)(_QWORD, uint64_t))v76)(*((_QWORD *)&v50[0] + 1), 7936);
  v23 = v20 == 5126 || v20 == 5131;
  if (v23 && (_DWORD)v21 == 6403)
  {
    v24 = "NVIDIA";
    v25 = 6;
    goto LABEL_15;
  }
  if (v20 == 5123 && (_DWORD)v21 == 6408)
  {
    v24 = "Intel";
    v25 = 5;
LABEL_15:
    if (strncmp(v22, v24, v25))
      goto LABEL_16;
    return 0;
  }
LABEL_16:
  v43 = a3;
  v49 = 0;
  v48 = 0;
  ((void (*)(_QWORD, uint64_t, uint64_t *))v73)(*((_QWORD *)&v50[0] + 1), 36006, &v49);
  ((void (*)(_QWORD, uint64_t, unsigned int *))v73)(*((_QWORD *)&v50[0] + 1), 32873, &v48);
  (*((void (**)(_QWORD, uint64_t, char *))&v70 + 1))(*((_QWORD *)&v50[0] + 1), 1, (char *)&v49 + 4);
  v47 = 0;
  v44 = a1[52];
  (*((void (**)(_QWORD, uint64_t, unsigned int *))&v69 + 1))(*((_QWORD *)&v50[0] + 1), 1, &v47);
  (*((void (**)(_QWORD, uint64_t, _QWORD))&v51 + 1))(*((_QWORD *)&v50[0] + 1), 36160, v47);
  v26 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))v69;
  v27 = *((_QWORD *)&v50[0] + 1);
  v28 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 24))(a4);
  v26(v27, 36160, 36064, 3553, v28, 0);
  v29 = ((uint64_t (*)(_QWORD, uint64_t))v55)(*((_QWORD *)&v50[0] + 1), 36160);
  v30 = MEMORY[0x1E0C809B0];
  v31 = (_QWORD *)&unk_192491000;
  if (v29 == 36053)
  {
    (*((void (**)(_QWORD, uint64_t, _QWORD))&v52 + 1))(*((_QWORD *)&v50[0] + 1), 3553, HIDWORD(v49));
    v32 = *v12;
    Width = IOSurfaceGetWidth(a2);
    Height = IOSurfaceGetHeight(a2);
    v42 = ((uint64_t (*)(_QWORD, uint64_t))v76)(*((_QWORD *)&v50[0] + 1), 7936);
    if (CIEAGLContextTexImageIOSurface(v32, 0xDE1u, Width, Height, v18, v21, v20, a2, 0))
    {
      (*((void (**)(_QWORD, uint64_t, _QWORD))&v52 + 1))(*((_QWORD *)&v50[0] + 1), 3553, HIDWORD(v49));
      (*((void (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, uint64_t))&v57 + 1))(*((_QWORD *)&v50[0] + 1), 3553, 0, *v43, v43[1], *a5, a5[1], a5[2], *((_QWORD *)a5 + 2), v42);
      inserted = (CI::Context *)CI::GLContext::insert_fence(a1);
      v36 = CI::Context::render_completion_queue(inserted);
      v30 = MEMORY[0x1E0C809B0];
      block[0] = MEMORY[0x1E0C809B0];
      v31 = &unk_192491000;
      block[1] = 0x40000000;
      block[2] = ___ZNK2CI9GLContext11blitSurfaceEP11__IOSurface5IRectPNS_14intermediate_tES3_RKNS_17TextureDescriptorE_block_invoke;
      block[3] = &__block_descriptor_tmp_46;
      block[4] = a1;
      v37 = v44;
      block[5] = v44;
      block[6] = inserted;
      block[7] = a4;
      dispatch_async(v36, block);
      v38 = 1;
    }
    else
    {
      v38 = 0;
      inserted = 0;
      v37 = v44;
      v30 = MEMORY[0x1E0C809B0];
      v31 = &unk_192491000;
    }
  }
  else
  {
    v38 = 0;
    inserted = 0;
    v37 = v44;
  }
  ((void (*)(_QWORD, uint64_t, unsigned int *))v59)(*((_QWORD *)&v50[0] + 1), 1, &v47);
  (*((void (**)(_QWORD, uint64_t, char *))&v61 + 1))(*((_QWORD *)&v50[0] + 1), 1, (char *)&v49 + 4);
  (*((void (**)(_QWORD, uint64_t, _QWORD))&v51 + 1))(*((_QWORD *)&v50[0] + 1), 36160, v49);
  v39 = (CI::Context *)(*((uint64_t (**)(_QWORD, uint64_t, _QWORD))&v52 + 1))(*((_QWORD *)&v50[0] + 1), 3553, v48);
  v40 = CI::Context::render_completion_queue(v39);
  v45[0] = v30;
  v45[1] = v31[423];
  v45[2] = ___ZNK2CI9GLContext11blitSurfaceEP11__IOSurface5IRectPNS_14intermediate_tES3_RKNS_17TextureDescriptorE_block_invoke_47;
  v45[3] = &__block_descriptor_tmp_48;
  v45[4] = v37;
  v45[5] = inserted;
  dispatch_async(v40, v45);
  return v38;
}

void ___ZNK2CI9GLContext11blitSurfaceEP11__IOSurface5IRectPNS_14intermediate_tES3_RKNS_17TextureDescriptorE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  _OWORD v5[8];
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;

  v2 = *(_QWORD *)(a1 + 32);
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  memset(v5, 0, sizeof(v5));
  GetMacroContext(*(void **)(a1 + 40), v5);
  if (!LOBYTE(v5[0]))
  {
    v3 = ci_logger_render();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  ((void (*)(_QWORD, _QWORD, _QWORD, uint64_t))v6)(*((_QWORD *)&v5[0] + 1), *(_QWORD *)(a1 + 48), 0, -1);
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 112))(v2);
  CI::TextureManager::complete_intermediate(v4, 52, *(_QWORD *)(a1 + 56));
}

uint64_t ___ZNK2CI9GLContext11blitSurfaceEP11__IOSurface5IRectPNS_14intermediate_tES3_RKNS_17TextureDescriptorE_block_invoke_47(uint64_t a1)
{
  NSObject *v2;
  _OWORD v4[13];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;

  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  v5 = 0u;
  memset(v4, 0, sizeof(v4));
  GetMacroContext(*(void **)(a1 + 32), v4);
  if (!LOBYTE(v4[0]))
  {
    v2 = ci_logger_render();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      ___ZN2CI16GLTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke_cold_1();
  }
  return ((uint64_t (*)(_QWORD, _QWORD))v5)(*((_QWORD *)&v4[0] + 1), *(_QWORD *)(a1 + 40));
}

uint64_t CI::GLMainProgram::type(CI::GLMainProgram *this)
{
  return 71;
}

const char *CI::MainProgram::get_type_name(CI::MainProgram *this)
{
  return "cikl";
}

uint64_t `non-virtual thunk to'CI::GLMainProgram::type(CI::GLMainProgram *this)
{
  return 71;
}

uint64_t CI::GLContext::type(CI::GLContext *this)
{
  return 76;
}

uint64_t CI::GLContext::bind_texture()
{
  return 0;
}

uint64_t CI::GLContext::texture_manager(CI::GLContext *this)
{
  return *((_QWORD *)this + 53);
}

uint64_t CI::GLContext::is_cpu(CI::GLContext *this)
{
  return 0;
}

const char *CI::GLContext::deviceName(CI::GLContext *this)
{
  if (*((_QWORD *)this + 112))
    return (const char *)*((_QWORD *)this + 112);
  else
    return "Unknown OpenGL Device";
}

uint64_t CI::Context::switch_dictionary(CI::Context *this)
{
  return 0;
}

uint64_t CI::GLContext::max_texture_size(CI::GLContext *this)
{
  return *((int *)this + 208);
}

uint64_t CI::GLContext::max_render_load_bytes(CI::GLContext *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 45);
  if (v1)
    return v1 << 20;
  else
    return 0x8000000;
}

uint64_t CI::GLContext::max_device_memory(CI::GLContext *this)
{
  return *((_QWORD *)this + 109);
}

uint64_t CI::GLContext::supportsDeferredCGImage(CI::GLContext *this)
{
  return *((unsigned __int8 *)this + 909);
}

BOOL CI::GLContext::supports_edge_mode(uint64_t a1, int a2)
{
  return a2 == 1;
}

uint64_t CI::GLContext::supports_sample_mode(uint64_t a1, int a2, int a3)
{
  if (a2 == 1)
    return CI::format_is_full_float(a3) ^ 1;
  else
    return 1;
}

double CI::GLContext::sampler_transform_for_extent@<D0>(const CGRect *a1@<X1>, double *a2@<X8>)
{
  double y;
  double v4;
  CGFloat v5;
  double v6;
  double v7;
  double result;

  y = a1->origin.y;
  v4 = 1.0 / a1->size.height;
  v5 = a1->origin.x * -0.0 - y * v4 + 0.0;
  v6 = 1.0 / a1->size.width;
  v7 = y * -0.0 - a1->origin.x * v6;
  *a2 = v6 + 0.0;
  a2[1] = v4 * 0.0 + 0.0;
  a2[2] = v6 * 0.0 + 0.0;
  a2[3] = v4 + 0.0;
  result = v7 + 0.0;
  a2[4] = result;
  a2[5] = v5;
  return result;
}

uint64_t CI::GLContext::createMainProgram(const CI::Context *a1, uint64_t a2, const char *a3, const char *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11;
  uint64_t v12;

  v11 = operator new();
  return CI::GLMainProgram::GLMainProgram(v11, a1, v12, a3, a4, a5, a6);
}

uint64_t `non-virtual thunk to'CI::GLContext::type(CI::GLContext *this)
{
  return 76;
}

void ___ZN2CIL18CI_SUBDIVIDE_QUADSEv_block_invoke()
{
  char *v0;
  uint64_t v1;

  v0 = getenv("CI_SUBDIVIDE_QUADS");
  if (v0)
    *(double *)&v1 = atof(v0);
  else
    v1 = CI::CI_SUBDIVIDE_QUADS(void)::v;
  CI::CI_SUBDIVIDE_QUADS(void)::v = v1;
}

uint64_t CI::InstanceCounted<(CI::Type)58>::type()
{
  return 58;
}

_QWORD *CI::InstanceCounted<(CI::Type)58>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBBEE8;
  do
    v1 = __ldaxr(dword_1ECF873D0);
  while (__stlxr(v1 - 1, dword_1ECF873D0));
  return result;
}

void CI::InstanceCounted<(CI::Type)58>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBBEE8;
  do
    v1 = __ldaxr(dword_1ECF873D0);
  while (__stlxr(v1 - 1, dword_1ECF873D0));
  JUMPOUT(0x194025AACLL);
}

uint64_t std::list<CI::attached_surface_t *>::splice(uint64_t result, uint64_t *a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  if (a4 != a5)
  {
    v5 = (_QWORD *)*a5;
    if (result != a3)
    {
      v6 = 1;
      if (v5 != a4)
      {
        v7 = a4;
        do
        {
          v7 = (_QWORD *)v7[1];
          ++v6;
        }
        while (v7 != v5);
      }
      *(_QWORD *)(a3 + 16) -= v6;
      *(_QWORD *)(result + 16) += v6;
    }
    v8 = *a4;
    *(_QWORD *)(v8 + 8) = v5[1];
    *(_QWORD *)v5[1] = v8;
    v9 = *a2;
    *(_QWORD *)(v9 + 8) = a4;
    *a4 = v9;
    *a2 = (uint64_t)v5;
    v5[1] = a2;
  }
  return result;
}

uint64_t CI::InstanceCounted<(CI::Type)71>::type()
{
  return 71;
}

_QWORD *CI::InstanceCounted<(CI::Type)71>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EB7738;
  do
    v1 = __ldaxr(&dword_1ECF873D0[13]);
  while (__stlxr(v1 - 1, &dword_1ECF873D0[13]));
  return result;
}

void CI::InstanceCounted<(CI::Type)71>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EB7738;
  do
    v1 = __ldaxr(&dword_1ECF873D0[13]);
  while (__stlxr(v1 - 1, &dword_1ECF873D0[13]));
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::InstanceCounted<(CI::Type)76>::type()
{
  return 76;
}

_QWORD *CI::InstanceCounted<(CI::Type)76>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EB7B08;
  do
    v1 = __ldaxr(&dword_1ECF873D0[18]);
  while (__stlxr(v1 - 1, &dword_1ECF873D0[18]));
  return result;
}

void CI::InstanceCounted<(CI::Type)76>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EB7B08;
  do
    v1 = __ldaxr(&dword_1ECF873D0[18]);
  while (__stlxr(v1 - 1, &dword_1ECF873D0[18]));
  JUMPOUT(0x194025AACLL);
}

void OUTLINED_FUNCTION_4_4(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

void ___ZN2CI19MetalTextureManagerC2EPNS_12MetalContextE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  _QWORD *v12;
  uint8_t buf[64];

  v4 = *(_QWORD *)(a1 + 32);
  v5 = ci_signpost_log_render();
  v6 = *(unsigned int *)(a1 + 40);
  if ((unint64_t)((v6 << 32) - 1) <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v7 = v5;
    if (os_signpost_enabled(v5))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v7, OS_SIGNPOST_INTERVAL_BEGIN, v6 << 32, "release_surface_block", (const char *)&unk_192520C83, buf, 2u);
      v6 = *(unsigned int *)(a1 + 40);
    }
  }
  TimerBase::TimerBase((uint64_t)buf, v6, 0, (uint64_t)"release_surface_block", 32);
  v8 = *(_QWORD *)(v4 + 136);
  v9 = *(_QWORD *)(v8 + 8);
  while (v9 != v8)
  {
    v10 = v9 + 8;
    v9 = *(_QWORD *)(v9 + 8);
    v12 = *(_QWORD **)(v10 + 8);
    if ((*(uint64_t (**)(_QWORD *))*v12)(v12) == a2)
    {
      (**(void (***)(uint64_t, _QWORD, _QWORD))v4)(v4, v12[1], v12[2]);
      std::list<CI::attached_surface_t *>::remove(*(_QWORD **)(v4 + 136), &v12);
      v11 = (const void *)(*(uint64_t (**)(_QWORD *))*v12)(v12);
      CFRelease(v11);
      if (v12)
        (*(void (**)(_QWORD *))(*v12 + 48))(v12);
    }
    v8 = *(_QWORD *)(v4 + 136);
  }
  _ZZZN2CI19MetalTextureManagerC1EPNS_12MetalContextEEUb_EN13SignpostTimerD1Ev((TimerBase *)buf);
}

void sub_1923E7680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _ZZZN2CI19MetalTextureManagerC1EPNS_12MetalContextEEUb_EN13SignpostTimerD1Ev((TimerBase *)va);
  _Unwind_Resume(a1);
}

void _ZZZN2CI19MetalTextureManagerC1EPNS_12MetalContextEEUb_EN13SignpostTimerD1Ev(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  v2 = ci_signpost_log_render();
  v3 = *((_QWORD *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "release_surface_block", (const char *)&unk_192520C83, v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1923E771C(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::MetalTextureManager::convert_to_sRGB(uint64_t a1, _QWORD *a2)
{
  void *v4;
  uint64_t result;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  v4 = (void *)(*(uint64_t (**)(_QWORD *))(*a2 + 24))(a2);
  v16 = 0;
  result = CIFormatFromCIMetalTextureFormat(objc_msgSend(v4, "pixelFormat"), &v16);
  if (!v16)
  {
    v6 = CIMetalFormatForFormat(result, 1);
    v7 = objc_msgSend(v4, "width");
    v8 = objc_msgSend(v4, "height");
    v9 = *(_QWORD *)(a1 + 168);
    v10 = *(_QWORD *)(v9 + 1920);
    v11 = (void *)objc_msgSend(*(id *)(v9 + 392), "device");
    v12 = (*(uint64_t (**)(_QWORD *))*a2)(a2);
    v13 = CIMetalTextureCreateFromPaddedIOSurface(v7, v8, v10, v11, v12, 0, v6, objc_msgSend(v4, "usage"));
    v14 = (*(uint64_t (**)(_QWORD *))(*a2 + 24))(a2);
    result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))a1)(a1, v14, v15);
    a2[1] = v13;
    a2[2] = 0;
  }
  return result;
}

uint64_t CI::MetalTextureManager::create_intermediate(uint64_t a1, unsigned __int8 *a2, CI *this, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t v13;
  int v14;
  int v15;
  signed int PixelFormat;
  int v17;
  BOOL v18;
  NSObject *v19;
  BOOL v20;
  int v21;
  uint64_t v22;
  _QWORD block[9];
  int v25;
  int v26;
  int v27;
  char v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  int64x2_t v33;

  v13 = CI::format_from_IOSurface(this, (__IOSurface *)a2);
  CI::Context::swizzler_for_output(*(_QWORD *)(a1 + 168), v13, 1, &v33);
  v14 = CIMetalFormatForFormat(v33.i32[0], (a2[4] >> 1) & 1);
  v15 = CIMetalFormatForFormat(v33.i32[1], (a2[4] >> 1) & 1);
  PixelFormat = IOSurfaceGetPixelFormat(this);
  v17 = PixelFormat >> 24;
  v29 = 0;
  v30 = &v29;
  v31 = 0x2020000000;
  v32 = 0;
  v18 = (PixelFormat & 0xFD000000) == 0x2D000000 || v17 == 38;
  v19 = *(NSObject **)(a1 + 104);
  v20 = v18 || v17 == 124;
  block[0] = MEMORY[0x1E0C809B0];
  if (v20)
    v21 = 16391;
  else
    v21 = 7;
  block[1] = 3221225472;
  block[2] = ___ZN2CI19MetalTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke;
  block[3] = &unk_1E2EC64E0;
  block[4] = &v29;
  block[5] = a1;
  block[6] = this;
  block[7] = a5;
  v25 = v14;
  v26 = v21;
  v27 = v15;
  block[8] = a6;
  v28 = a7;
  dispatch_sync(v19, block);
  v22 = v30[3];
  _Block_object_dispose(&v29, 8);
  return v22;
}

void ___ZN2CI19MetalTextureManager19create_intermediateERKNS_22IntermediateDescriptorEP11__IOSurfaceiRK5IRectmb_block_invoke(uint64_t a1)
{
  CI::TextureManager *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  void *v9;
  void *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64x2_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  _BOOL8 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t (***v27)(_QWORD);
  uint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t (***v36)(_QWORD);
  uint64_t v37;
  void *v38;
  uint64_t *v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64x2_t v46;
  int v47;
  float64x2_t *v48;
  float64x2_t v49;
  float64x2_t v50;
  int64x2_t v51;
  float64x2_t *v52;
  uint64_t v53;
  uint64_t (***v54)(_QWORD);
  unint64_t v55;
  uint64_t (***v56)(_QWORD);
  const void *v57;
  CGSize v58;
  CGPoint v59;
  int64x2_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _BOOL8 v64;
  uint64_t v65;
  const void *v66;
  uint64_t v67;
  const void *v68;
  uint64_t *v69;
  _QWORD *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  const void *v74;
  uint64_t v75;
  CGRect v76;
  Texture v77;
  CGSize v78;

  v2 = *(CI::TextureManager **)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 56);
  v78.width = (double)*(unint64_t *)(v3 + 8);
  v78.height = (double)*(unint64_t *)(v3 + 16);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CI::TextureManager::_find_match_for_surface(v2, *(IOSurfaceRef *)(a1 + 48), v78);
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    if (CI_RECYCLE_METAL_TEXTURES())
    {
      v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      v5 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
      if (CIMetalTextureGetFormat(v5) == *(_DWORD *)(a1 + 72))
      {
        v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
        if (!(*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6))
        {
LABEL_40:
          v73 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          v74 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v73 + 24))(v73);
          CFGetRetainCount(v74);
          objc_msgSend(*(id *)(*((_QWORD *)v2 + 21) + 392), "device");
          v75 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          objc_msgSend((id)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v75 + 24))(v75), "device");
          goto LABEL_14;
        }
        v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
        v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
        v10 = v9;
        v11 = *(uint64_t **)(a1 + 56);
        v12 = *v11;
        v13 = *(uint64x2_t *)(v11 + 1);
        v14 = *v11;
        if (v14 == -2147483647)
        {
          if (HIDWORD(v12) == -2147483647 && *(_OWORD *)&v13 == __PAIR128__(0xFFFFFFFFLL, 0xFFFFFFFFLL))
          {
            v15 = MEMORY[0x1E0C9D5E0];
            goto LABEL_33;
          }
        }
        else if (v14 == 0x7FFFFFFF && HIDWORD(v12) == 0x7FFFFFFF && *(_OWORD *)&v13 == 0)
        {
          v15 = MEMORY[0x1E0C9D628];
LABEL_33:
          v59 = *(CGPoint *)v15;
          v58 = *(CGSize *)(v15 + 16);
LABEL_35:
          v76.origin = v59;
          v76.size = v58;
          v77.var0.var0 = v8;
          v77.var0.var2.var1 = v10;
          CI::TextureManager::intermediate(v2, v77, 0, &v76, 0, 1);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v61;
          v62 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          v63 = *(_QWORD *)(a1 + 48);
          v64 = CI_RECYCLE_METAL_TEXTURES() != 0;
          (*(void (**)(uint64_t, uint64_t, _BOOL8))(*(_QWORD *)v62 + 56))(v62, v63, v64);
          v65 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          v66 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v65 + 24))(v65);
          if (v66)
            CFRetain(v66);
          v67 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          v68 = *(const void **)(*(_QWORD *)(v67 + 24) + 16);
          if (v68)
          {
            CFRetain(v68);
            v67 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          }
          v69 = (uint64_t *)*((_QWORD *)v2 + 17);
          v70 = operator new(0x18uLL);
          v71 = *(_QWORD *)(v67 + 24);
          v70[1] = v69;
          v70[2] = v71;
          v72 = *v69;
          *v70 = *v69;
          *(_QWORD *)(v72 + 8) = v70;
          *v69 = (uint64_t)v70;
          ++v69[2];
          goto LABEL_40;
        }
        v60.i64[0] = (int)v12;
        v60.i64[1] = SHIDWORD(v12);
        v59 = (CGPoint)vcvtq_f64_s64(v60);
        v58 = (CGSize)vcvtq_f64_u64(v13);
        goto LABEL_35;
      }
    }
  }
  v16 = operator new();
  *(_QWORD *)v16 = off_1E2EBAFD0;
  *(_QWORD *)(v16 + 8) = 0;
  *(_QWORD *)(v16 + 24) = 0;
  v17 = *(_OWORD *)(MEMORY[0x1E0C9D628] + 16);
  *(_OWORD *)(v16 + 32) = *MEMORY[0x1E0C9D628];
  *(_OWORD *)(v16 + 48) = v17;
  *(_QWORD *)(v16 + 64) = 0;
  *(_WORD *)(v16 + 72) = 1;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v16;
  v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v19 = *(_QWORD *)(a1 + 48);
  v20 = CI_RECYCLE_METAL_TEXTURES() != 0;
  (*(void (**)(uint64_t, uint64_t, _BOOL8))(*(_QWORD *)v18 + 56))(v18, v19, v20);
  v21 = *(_QWORD *)(a1 + 56);
  v22 = *(_QWORD *)(v21 + 8);
  v23 = *(_QWORD *)(v21 + 16);
  v24 = *((_QWORD *)v2 + 21);
  v25 = *(_QWORD *)(v24 + 1920);
  v26 = (void *)objc_msgSend(*(id *)(v24 + 392), "device");
  v27 = *(uint64_t (****)(_QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v28 = (**v27)(v27);
  v29 = CIMetalTextureCreateFromPaddedIOSurface(v22, v23, v25, v26, v28, 0, *(_DWORD *)(a1 + 72), *(_DWORD *)(a1 + 76));
  if (*(_DWORD *)(a1 + 80))
  {
    v30 = *(_QWORD *)(a1 + 56);
    v31 = *(_QWORD *)(v30 + 8) >> 1;
    v32 = *(_QWORD *)(v30 + 16) >> 1;
    v33 = *((_QWORD *)v2 + 21);
    v34 = *(_QWORD *)(v33 + 1920);
    v35 = (void *)objc_msgSend(*(id *)(v33 + 392), "device");
    v36 = *(uint64_t (****)(_QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v37 = (**v36)(v36);
    v38 = CIMetalTextureCreateFromPaddedIOSurface(v31, v32, v34, v35, v37, 1, *(_DWORD *)(a1 + 80), *(_DWORD *)(a1 + 76));
  }
  else
  {
    v38 = 0;
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 8) = v29;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 16) = v38;
  v39 = (uint64_t *)*((_QWORD *)v2 + 17);
  v40 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v41 = operator new(0x18uLL);
  v42 = *(_QWORD *)(v40 + 24);
  v41[1] = v39;
  v41[2] = v42;
  v43 = *v39;
  *v41 = *v39;
  *(_QWORD *)(v43 + 8) = v41;
  *v39 = (uint64_t)v41;
  ++v39[2];
LABEL_14:
  v44 = *(uint64_t **)(a1 + 56);
  v45 = *v44;
  v46 = *(uint64x2_t *)(v44 + 1);
  v47 = *v44;
  if (v47 == -2147483647)
  {
    if (HIDWORD(v45) == -2147483647 && *(_OWORD *)&v46 == __PAIR128__(0xFFFFFFFFLL, 0xFFFFFFFFLL))
    {
      v48 = (float64x2_t *)MEMORY[0x1E0C9D5E0];
      goto LABEL_22;
    }
LABEL_23:
    v51.i64[0] = (int)v45;
    v51.i64[1] = SHIDWORD(v45);
    v50 = vcvtq_f64_s64(v51);
    v49 = vcvtq_f64_u64(v46);
    goto LABEL_24;
  }
  if (v47 != 0x7FFFFFFF || HIDWORD(v45) != 0x7FFFFFFF || *(_OWORD *)&v46 != 0)
    goto LABEL_23;
  v48 = (float64x2_t *)MEMORY[0x1E0C9D628];
LABEL_22:
  v50 = *v48;
  v49 = v48[1];
LABEL_24:
  v52 = *(float64x2_t **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v52[2] = v50;
  v52[3] = v49;
  v53 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_QWORD *)(v53 + 64) += *(_QWORD *)(a1 + 64);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 72) = *(_BYTE *)(a1 + 84);
  v54 = *(uint64_t (****)(_QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v54 && (**v54)(v54) && *(_QWORD *)(a1 + 64) >= 2uLL)
  {
    v55 = 1;
    do
    {
      v56 = *(uint64_t (****)(_QWORD))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      v57 = (const void *)(**v56)(v56);
      RetainSurfaceFromCache(v57);
      ++v55;
    }
    while (v55 < *(_QWORD *)(a1 + 64));
  }
}

uint64_t CI::MetalTextureManager::create_intermediate(_QWORD *a1, uint64_t a2, uint64_t a3, CGFloat *a4, uint64_t a5, uint64_t a6, char a7)
{
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  CGFloat v17;
  unint64_t height;
  unint64_t width;
  uint64_t v21;
  int v22;
  int v23;
  int is_packed;
  int v25;
  int v28;
  BOOL v29;
  int v30;
  int v31;
  void *v32;
  const char *v33;
  char v34;
  void *v35;
  const char *v36;
  char v37;
  char v38;
  char v39;
  char v40;
  int v41;
  int v42;
  char v43;
  NSObject *v44;
  const char *v45;
  NSObject *v46;
  uint64_t v47;
  uint64_t v49;
  char v50;
  int v51;
  int v52;
  int v53;
  uint64_t v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD block[10];
  __int128 v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  CGFloat *v64;
  uint64_t v65;
  int v66;
  int v67;
  char v68;
  char v69;
  char v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  char v74;
  uint64_t v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t *v80;
  uint64_t v81;
  uint64_t v82;
  __int128 v83;
  unint64_t v84;
  uint8_t buf[16];
  uint64_t v86;
  CGRect v87;
  CGRect v88;
  CGRect v89;
  CGRect v90;
  CGRect v91;

  v86 = *MEMORY[0x1E0C80C00];
  v14 = *a4;
  v15 = a4[1];
  v16 = a4[2];
  v17 = a4[3];
  v87.origin.x = *a4;
  v87.origin.y = v15;
  v87.size.width = v16;
  v87.size.height = v17;
  if (CGRectIsNull(v87))
    return 0;
  v88.origin.x = v14;
  v88.origin.y = v15;
  v88.size.width = v16;
  v88.size.height = v17;
  if (CGRectIsInfinite(v88))
  {
    v83 = IRectInfinite;
    height = 0xFFFFFFFFLL;
    v84 = 0xFFFFFFFFLL;
    width = 0xFFFFFFFFLL;
  }
  else
  {
    v89.origin.x = v14;
    v89.origin.y = v15;
    v89.size.width = v16;
    v89.size.height = v17;
    v90 = CGRectInset(v89, 0.000001, 0.000001);
    v91 = CGRectIntegral(v90);
    width = (unint64_t)v91.size.width;
    height = (unint64_t)v91.size.height;
    LODWORD(v83) = (int)v91.origin.x;
    DWORD1(v83) = (int)v91.origin.y;
    *((_QWORD *)&v83 + 1) = (unint64_t)v91.size.width;
    v84 = (unint64_t)v91.size.height;
  }
  if (!width || height == 0)
    return 0;
  v22 = CIMetalFormatForFormat(*(_DWORD *)a2, (*(unsigned __int8 *)(a2 + 4) >> 1) & 1);
  v53 = v22;
  v56 = a5;
  v57 = a6;
  v55 = a7;
  v54 = a3;
  if (*(_BYTE *)(a2 + 6)
    || CI::MetalContext::use_imageblocks_for_format(a1[21], *(_DWORD *)a2)
    && CI_ENABLE_METAL_IMAGEBLOCKS() == 2)
  {
    v23 = 7;
  }
  else
  {
    v23 = 3;
  }
  v52 = v23;
  v79 = 0;
  v80 = &v79;
  v81 = 0x2020000000;
  v82 = 0;
  v75 = 0;
  v76 = &v75;
  v77 = 0x2020000000;
  v78 = 0;
  v71 = 0;
  v72 = &v71;
  v73 = 0x2020000000;
  v74 = 0;
  is_packed = CI::format_is_packed(*(_DWORD *)a2);
  v25 = is_packed;
  if (((height * width) & 0xFFFFFFFFFFFF0000) != 0 && width > 0xF && height > 0xF)
    v28 = 1;
  else
    v28 = is_packed;
  if (*(_BYTE *)(a2 + 7))
    v29 = 1;
  else
    v29 = (*(unsigned __int8 *)(a2 + 5) | *(unsigned __int8 *)(a2 + 6)) == 0;
  v30 = !v29;
  LODWORD(v49) = (*(uint64_t (**)(_QWORD))(*(_QWORD *)a1[21] + 168))(a1[21]);
  HIDWORD(v49) = v25;
  if ((CI_PRINT_TREE_dump_intermediates() & 1) != 0 || (CI_PRINT_TREE_dump_raw_intermediates() & 1) != 0)
    v31 = 1;
  else
    v31 = CI_PRINT_TREE_dump_bmtl_intermediates();
  v32 = (void *)objc_msgSend(*(id *)(a1[21] + 392), "device", v49);
  v34 = CIMetalDeviceSupportsFamilyApple7(v32, v33);
  v35 = (void *)objc_msgSend(*(id *)(a1[21] + 392), "device");
  v37 = CIMetalDeviceSupportsFamilyApple8(v35, v36);
  if (((v30 | v31 | v28 ^ 1) & 1) != 0)
  {
    v38 = 0;
    v39 = 0;
  }
  else
  {
    v40 = v37;
    v41 = CI_LOSSY_COMPRESSED_INTERMEDIATES();
    v42 = CI_LOSSLESS_COMPRESSED_INTERMEDIATES();
    if (v41)
      v43 = v40;
    else
      v43 = 0;
    v38 = v43 & v50;
    if (v42)
      v39 = v34;
    else
      v39 = 0;
  }
  if (v51)
  {
    if ((v39 & 1) == 0)
    {
      v44 = ci_logger_render();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
        v45 = CI::name_for_format(*(_DWORD *)a2);
        CI::MetalTextureManager::create_intermediate((uint64_t)v45, buf, v44);
      }
    }
  }
  v46 = a1[13];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN2CI19MetalTextureManager19create_intermediateERKNS_22IntermediateDescriptorENS_17NodeContentDigestERK6CGRectmmb_block_invoke;
  block[3] = &unk_1E2EC6508;
  block[8] = v54;
  block[9] = a2;
  v68 = v39;
  v69 = v38;
  v70 = v55;
  v59 = v83;
  v60 = v84;
  v61 = width;
  v62 = height;
  v63 = v56;
  block[4] = &v79;
  block[5] = &v71;
  block[6] = &v75;
  block[7] = a1;
  v64 = a4;
  v65 = v57;
  v66 = v53;
  v67 = v52;
  dispatch_sync(v46, block);
  v47 = v80[3];
  if (v47)
    v21 = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, _QWORD, __int128 *, uint64_t, _QWORD))(*a1 + 48))(a1, a2, v47, 0, &v83, v57, *((unsigned __int8 *)v72 + 24));
  else
    v21 = v76[3];
  _Block_object_dispose(&v71, 8);
  _Block_object_dispose(&v75, 8);
  _Block_object_dispose(&v79, 8);
  return v21;
}

void sub_1923E82DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  _Unwind_Resume(exception_object);
}

uint64_t CI::MetalContext::use_imageblocks_for_format(uint64_t a1, int a2)
{
  uint64_t result;

  result = CI_ENABLE_METAL_IMAGEBLOCKS();
  if ((_DWORD)result)
  {
    if (!*(_BYTE *)(a1 + 457))
      return 0;
    result = 0;
    if (a2 > 529)
    {
      if (a2 != 530 && a2 != 2066 && a2 != 534)
        return result;
      return CI_ENABLE_METAL_IMAGEBLOCKS() == 2;
    }
    if (a2 == 274 || a2 == 278)
      return CI_ENABLE_METAL_IMAGEBLOCKS() == 2;
  }
  return result;
}

void ___ZN2CI19MetalTextureManager19create_intermediateERKNS_22IntermediateDescriptorENS_17NodeContentDigestERK6CGRectmmb_block_invoke(uint64_t a1)
{
  uint64_t v2;
  CFStringRef v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  _OWORD *v9;
  uint64_t v10;
  __int128 v11;
  void *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  int v18;
  int v19;
  unsigned __int16 v20;
  unsigned __int16 v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  unsigned __int16 v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  int v32;
  __CFArray *Mutable;
  uint64_t v34;
  uint64_t i;
  uint64_t v36;
  const void *v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  int v42;
  __int128 v43;
  uint64_t v44;
  __int128 v45;
  uint64_t v46;
  __int128 v47;
  uint64_t v48;
  __int128 v49;
  uint64_t v50;

  v2 = *(_QWORD *)(a1 + 56);
  if (CI_IOSURFACE_INTERMEDIATES())
  {
    v3 = CFStringCreateWithFormat(0, 0, CFSTR("%llX(%04X)"), *(_QWORD *)(a1 + 64), *(unsigned int *)(a1 + 144));
    v4 = CI::PixelFormatType_from_format(**(_DWORD **)(a1 + 72));
    v5 = v4;
    if (!*(_BYTE *)(a1 + 152))
      goto LABEL_85;
    v6 = equivalent_uncompressed_format(v4);
    v5 = v6;
    if ((int)v6 <= 1647534391)
    {
      if ((int)v6 > 875836533)
      {
        if ((int)v6 <= 1278226735)
        {
          if ((int)v6 <= 1278226487)
          {
            if ((_DWORD)v6 != 875836534)
            {
              if ((_DWORD)v6 == 1111970369)
                v5 = 641877825;
              goto LABEL_85;
            }
            v23 = 641234482;
LABEL_80:
            v5 = (v23 + 2);
            goto LABEL_85;
          }
          if ((_DWORD)v6 == 1278226488)
          {
            v5 = 642527288;
            goto LABEL_85;
          }
          if ((_DWORD)v6 != 1278226536)
            goto LABEL_85;
          v22 = 642527288;
LABEL_73:
          v5 = (v22 + 48);
          goto LABEL_85;
        }
        if ((int)v6 > 1278226741)
        {
          if ((_DWORD)v6 == 1278226742)
          {
            v5 = 642527542;
          }
          else if ((_DWORD)v6 == 1380411457)
          {
            v5 = 642934849;
          }
        }
        else if ((_DWORD)v6 == 1278226736)
        {
          v5 = 642527536;
        }
        else if ((_DWORD)v6 == 1278226738)
        {
          v5 = 642527538;
        }
LABEL_85:
        if (!*(_BYTE *)(a1 + 153))
          goto LABEL_125;
        v25 = equivalent_uncompressed_format(v5);
        LODWORD(v5) = v25;
        if (v25 > 1380411456)
        {
          if (v25 > 1882469427)
          {
            if (v25 > 1885745713)
            {
              if (v25 != 1885745714)
              {
                if (v25 == 1885746228)
                  LODWORD(v5) = 762865204;
                goto LABEL_125;
              }
              v28 = 26162;
            }
            else
            {
              if (v25 != 1882469428)
              {
                if (v25 == 1885745712)
                  LODWORD(v5) = 762865200;
                goto LABEL_125;
              }
              v28 = 30260;
            }
            LODWORD(v5) = v28 | 0x2D780000;
          }
          else
          {
            if (v25 <= 1882468911)
            {
              if (v25 == 1380411457)
              {
                LODWORD(v5) = 760375361;
              }
              else if (v25 == 1751527984)
              {
                LODWORD(v5) = 761816624;
              }
              goto LABEL_125;
            }
            if (v25 == 1882468912)
            {
              LODWORD(v5) = 762869296;
              goto LABEL_125;
            }
            if (v25 == 1882468914)
            {
              v26 = 762865202;
LABEL_116:
              LODWORD(v5) = v26 | 0x1000;
              goto LABEL_125;
            }
          }
          goto LABEL_125;
        }
        if (v25 <= 875704437)
        {
          if (v25 == 843264056)
          {
            LODWORD(v5) = 758263864;
            goto LABEL_125;
          }
          if (v25 != 843264104)
          {
            if (v25 == 875704422)
              LODWORD(v5) = 758670896;
            goto LABEL_125;
          }
          v27 = 758263864;
        }
        else
        {
          if (v25 <= 1278226487)
          {
            if (v25 != 875704438)
            {
              if (v25 == 1111970369)
                LODWORD(v5) = 759318337;
              goto LABEL_125;
            }
            v26 = 758670896;
            goto LABEL_116;
          }
          if (v25 == 1278226488)
          {
            LODWORD(v5) = 759967800;
            goto LABEL_125;
          }
          if (v25 != 1278226536)
          {
LABEL_125:
            if (*(_BYTE *)(a1 + 154))
            {
              v49 = *(_OWORD *)(a1 + 80);
              v50 = *(_QWORD *)(a1 + 96);
              LODWORD(v47) = 0;
              v29 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 168) + 616))(*(_QWORD *)(v2 + 168));
              v30 = *(_QWORD **)(v2 + 168);
              v31 = v30[47];
              *((_QWORD *)&v47 + 1) = v29;
              v48 = v31;
              v32 = (*(uint64_t (**)(_QWORD *))(*v30 + 272))(v30);
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = GetValidSurfaceFromCache(&v49, v5, &v47, v32, 0, *(_DWORD *)(*(_QWORD *)(a1 + 72) + 12), (uint64_t)v3);
            }
            else
            {
              Mutable = CFArrayCreateMutable(0, *(_QWORD *)(*(_QWORD *)(v2 + 136) + 16), 0);
              if (CI_RECYCLE_METAL_TEXTURES())
              {
                v34 = *(_QWORD *)(v2 + 136);
                for (i = *(_QWORD *)(v34 + 8); i != v34; i = *(_QWORD *)(i + 8))
                {
                  v36 = *(_QWORD *)(i + 16);
                  if (!(*(uint64_t (**)(uint64_t))(*(_QWORD *)v36 + 16))(v36)
                    && *(double *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v36 + 32))(v36) + 16) == (double)*(unint64_t *)(a1 + 104)
                    && *(double *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)v36 + 32))(v36) + 24) == (double)*(unint64_t *)(a1 + 112))
                  {
                    v37 = (const void *)(**(uint64_t (***)(uint64_t))v36)(v36);
                    CFArrayAppendValue(Mutable, v37);
                  }
                }
              }
              v45 = *(_OWORD *)(a1 + 80);
              v46 = *(_QWORD *)(a1 + 96);
              v38 = *(_QWORD *)(a1 + 120);
              LODWORD(v43) = 0;
              v39 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 168) + 616))(*(_QWORD *)(v2 + 168));
              v40 = *(_QWORD **)(v2 + 168);
              v41 = v40[47];
              *((_QWORD *)&v43 + 1) = v39;
              v44 = v41;
              v42 = (*(uint64_t (**)(_QWORD *))(*v40 + 272))(v40);
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = GetSurfaceFromCache(&v45, v38, v38, v5, &v43, v42, 0, *(_DWORD *)(*(_QWORD *)(a1 + 72) + 12), (uint64_t)v3, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)+ 24, Mutable);
              CFRelease(Mutable);
            }
            CFRelease(v3);
            return;
          }
          v27 = 759967800;
        }
        LODWORD(v5) = v27 + 48;
        goto LABEL_125;
      }
      if ((int)v6 <= 875704437)
      {
        if ((_DWORD)v6 == 843264056)
        {
          v5 = 640823352;
          goto LABEL_85;
        }
        if ((_DWORD)v6 == 843264104)
        {
          v22 = 640823352;
          goto LABEL_73;
        }
        if ((_DWORD)v6 != 875704422)
          goto LABEL_85;
        v21 = 26160;
      }
      else
      {
        if ((int)v6 <= 875704949)
        {
          if ((_DWORD)v6 != 875704438)
          {
            if ((_DWORD)v6 != 875704934)
              goto LABEL_85;
            v19 = 641230384;
            goto LABEL_66;
          }
          v24 = 641230384;
LABEL_69:
          v5 = v24 | 0x1000u;
          goto LABEL_85;
        }
        if ((_DWORD)v6 != 875704950)
        {
          if ((_DWORD)v6 != 875836518)
            goto LABEL_85;
          v18 = 641230384;
          goto LABEL_53;
        }
        v21 = 30258;
      }
      v5 = v21 | 0x26380000u;
      goto LABEL_85;
    }
    if ((int)v6 <= 1885745713)
    {
      if ((int)v6 <= 1882468911)
      {
        switch((_DWORD)v6)
        {
          case 0x62336138:
            v5 = 643969848;
            break;
          case 0x68663230:
            v5 = 644376112;
            break;
          case 0x6C313072:
            v5 = 644624754;
            break;
        }
        goto LABEL_85;
      }
      if ((int)v6 > 1882469427)
      {
        if ((_DWORD)v6 == 1882469428)
        {
          v23 = 645428786;
          goto LABEL_80;
        }
        if ((_DWORD)v6 != 1885745712)
          goto LABEL_85;
        v20 = 26160;
      }
      else
      {
        if ((_DWORD)v6 == 1882468912)
        {
          v24 = 645424688;
          goto LABEL_69;
        }
        if ((_DWORD)v6 != 1882468914)
          goto LABEL_85;
        v20 = 30258;
      }
      v5 = v20 | 0x26780000u;
      goto LABEL_85;
    }
    if ((int)v6 > 2016687215)
    {
      if ((int)v6 > 2037741157)
      {
        if ((_DWORD)v6 == 2037741158)
        {
          v5 = 645494118;
        }
        else if ((_DWORD)v6 == 2037741171)
        {
          v5 = 645494131;
        }
      }
      else if ((_DWORD)v6 == 2016687216)
      {
        v5 = 640955504;
      }
      else if ((_DWORD)v6 == 2019964016)
      {
        v5 = 644232304;
      }
      goto LABEL_85;
    }
    if ((int)v6 > 1999843441)
    {
      if ((_DWORD)v6 == 1999843442)
      {
        v5 = 645346162;
      }
      else if ((_DWORD)v6 == 1999908961)
      {
        v5 = 645346401;
      }
      goto LABEL_85;
    }
    if ((_DWORD)v6 == 1885745714)
    {
      v19 = 645424688;
LABEL_66:
      v5 = v19 | 2u;
      goto LABEL_85;
    }
    if ((_DWORD)v6 != 1885746228)
      goto LABEL_85;
    v18 = 645424688;
LABEL_53:
    v5 = v18 | 4u;
    goto LABEL_85;
  }
  if (!*(_BYTE *)(a1 + 154))
  {
    v7 = operator new();
    *(_QWORD *)v7 = off_1E2EBAFD0;
    *(_QWORD *)(v7 + 8) = 0;
    *(_QWORD *)(v7 + 24) = 0;
    v8 = *(_OWORD *)(MEMORY[0x1E0C9D628] + 16);
    *(_OWORD *)(v7 + 32) = *MEMORY[0x1E0C9D628];
    *(_OWORD *)(v7 + 48) = v8;
    *(_QWORD *)(v7 + 64) = 0;
    *(_WORD *)(v7 + 72) = 1;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = v7;
    v9 = *(_OWORD **)(a1 + 128);
    v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    v11 = v9[1];
    *(_OWORD *)(v10 + 32) = *v9;
    *(_OWORD *)(v10 + 48) = v11;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) + 64) = *(_QWORD *)(a1 + 136);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) + 72) = 1;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) + 24) = 0;
    v12 = CIMetalTextureCreate(*(_QWORD *)(*(_QWORD *)(v2 + 168) + 1920), (void *)objc_msgSend(*(id *)(*(_QWORD *)(v2 + 168) + 392), "device"), *(_DWORD *)(a1 + 144), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 112), *(_DWORD *)(a1 + 148));
    v13 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    *(_QWORD *)(v13 + 8) = v12;
    *(_QWORD *)(v13 + 16) = 0;
    v14 = *(uint64_t **)(v2 + 136);
    v15 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
    v16 = operator new(0x18uLL);
    v16[2] = *(_QWORD *)(v15 + 24);
    v17 = *v14;
    *v16 = *v14;
    v16[1] = v14;
    *(_QWORD *)(v17 + 8) = v16;
    *v14 = (uint64_t)v16;
    ++v14[2];
  }
}

void sub_1923E8EE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__list_imp<CI::attached_surface_t *>::clear((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t CI::MetalTextureManager::remove_matching_texture(uint64_t a1, __int128 **a2)
{
  uint64_t result;
  __int128 *v5;
  __int128 *v6;
  NSObject *v7;
  _QWORD v8[5];
  _BYTE v9[40];
  __int128 v10;
  _OWORD v11[2];
  int v12;

  if ((isImageConversionServiceProcess() & 1) != 0
    || (isMobileSlideShowOrCamera() & 1) != 0
    || (result = isQuickLookSideCar(), (_DWORD)result))
  {
    memset(v11, 0, sizeof(v11));
    v12 = 1065353216;
    v6 = *a2;
    v5 = a2[1];
    while (v6 != v5)
    {
      v10 = *v6;
      std::__hash_table<void const*,std::hash<void const*>,std::equal_to<void const*>,std::allocator<void const*>>::__emplace_unique_key_args<void const*,void const* const&>((uint64_t)v11, &v10, &v10);
      ++v6;
    }
    v7 = *(NSObject **)(a1 + 104);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3321888768;
    v8[2] = ___ZN2CI19MetalTextureManager23remove_matching_textureERKNSt3__16vectorINS_7TextureENS1_9allocatorIS3_EEEE_block_invoke;
    v8[3] = &__block_descriptor_80_e8_40c83_ZTSNSt3__113unordered_setIPKvNS_4hashIS2_EENS_8equal_toIS2_EENS_9allocatorIS2_EEEE_e5_v8__0l;
    v8[4] = a1;
    std::unordered_set<void const*>::unordered_set((uint64_t)v9, (uint64_t)v11);
    dispatch_sync(v7, v8);
    std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)v9);
    return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)v11);
  }
  return result;
}

void sub_1923E8FEC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(v1 - 80);
  _Unwind_Resume(a1);
}

void ___ZN2CI19MetalTextureManager23remove_matching_textureERKNSt3__16vectorINS_7TextureENS1_9allocatorIS3_EEEE_block_invoke(uint64_t a1)
{
  CI::TextureManager *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  CI::Object *v5;
  CI::Object **v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  CI::Object **v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  BOOL v16;
  CI::Object **v17;
  CI::Object **v18;
  char *v19;
  CI::Object **v20;
  CI::Object **v21;

  v1 = *(CI::TextureManager **)(a1 + 32);
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v2 = (_QWORD *)*((_QWORD *)v1 + 14);
  if (v2 != (_QWORD *)((char *)v1 + 120))
  {
    v3 = (_QWORD *)(a1 + 40);
    do
    {
      v5 = (CI::Object *)v2[4];
      v4 = (_QWORD *)v2[5];
      if (CI::allowRemoval((_BOOL8)v4)
        && std::__hash_table<void const*,std::hash<void const*>,std::equal_to<void const*>,std::allocator<void const*>>::find<void const*>(v3, v4))
      {
        if (v20 >= v21)
        {
          v7 = ((char *)v20 - v19) >> 3;
          if ((unint64_t)(v7 + 1) >> 61)
            abort();
          v8 = ((char *)v21 - v19) >> 2;
          if (v8 <= v7 + 1)
            v8 = v7 + 1;
          if ((unint64_t)((char *)v21 - v19) >= 0x7FFFFFFFFFFFFFF8)
            v9 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v9 = v8;
          if (v9)
            v10 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>((uint64_t)&v21, v9);
          else
            v10 = 0;
          v11 = &v10[8 * v7];
          *(_QWORD *)v11 = v5;
          v6 = (CI::Object **)(v11 + 8);
          v12 = v20;
          if (v20 != (CI::Object **)v19)
          {
            do
            {
              v13 = (uint64_t)*--v12;
              *((_QWORD *)v11 - 1) = v13;
              v11 -= 8;
            }
            while (v12 != (CI::Object **)v19);
            v12 = (CI::Object **)v19;
          }
          v19 = v11;
          v21 = (CI::Object **)&v10[8 * v9];
          if (v12)
            operator delete(v12);
        }
        else
        {
          *v20 = v5;
          v6 = v20 + 1;
        }
        v20 = v6;
      }
      v14 = (_QWORD *)v2[1];
      if (v14)
      {
        do
        {
          v15 = v14;
          v14 = (_QWORD *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          v15 = (_QWORD *)v2[2];
          v16 = *v15 == (_QWORD)v2;
          v2 = v15;
        }
        while (!v16);
      }
      v2 = v15;
    }
    while (v15 != (_QWORD *)((char *)v1 + 120));
    v18 = (CI::Object **)v19;
    v17 = v20;
    if (v19 != (char *)v20)
    {
      do
        CI::TextureManager::remove_lru(v1, *v18++);
      while (v18 != v20);
      v17 = (CI::Object **)v19;
    }
    if (v17)
      operator delete(v17);
  }
}

void sub_1923E91AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL CI::allowRemoval(_BOOL8 result)
{
  uint64_t v1;
  int v2;
  int v3;

  if (result)
  {
    v1 = result;
    if (*(_BYTE *)(result + 24))
    {
      if ((isImageConversionServiceProcess() & 1) != 0)
        v2 = 1;
      else
        v2 = isMobileSlideShowOrCamera();
    }
    else
    {
      v2 = 0;
    }
    if (*(_DWORD *)(v1 + 16) == 1)
      v3 = isQuickLookSideCar();
    else
      v3 = 0;
    return (v3 | v2) != 0;
  }
  return result;
}

uint64_t __copy_helper_block_e8_40c83_ZTSNSt3__113unordered_setIPKvNS_4hashIS2_EENS_8equal_toIS2_EENS_9allocatorIS2_EEEE(uint64_t a1, uint64_t a2)
{
  return std::unordered_set<void const*>::unordered_set(a1 + 40, a2 + 40);
}

uint64_t __destroy_helper_block_e8_40c83_ZTSNSt3__113unordered_setIPKvNS_4hashIS2_EENS_8equal_toIS2_EENS_9allocatorIS2_EEEE(uint64_t a1)
{
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(a1 + 40);
}

uint64_t CI::MetalTextureManager::_release_intermediate(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (!CI_RECYCLE_METAL_TEXTURES())
    return CI::TextureManager::_release_intermediate(a1, a2);
  result = CI_IOSURFACE_INTERMEDIATES();
  if (!(_DWORD)result)
    return CI::TextureManager::_release_intermediate(a1, a2);
  return result;
}

void CI::MetalTextureManager::release_texture(CI::MetalTextureManager *this, Texture a2)
{
  if (a2.var0.var0)
    CFRelease(a2.var0.var2.var0);
}

uint64_t CI::MetalTextureManager::lookup_texture(CI::MetalTextureManager *this, void *a2)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD block[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 0;
  v2 = *((_QWORD *)this + 13);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN2CI19MetalTextureManager14lookup_textureEPv_block_invoke;
  block[3] = &unk_1E2EC6550;
  block[4] = &v6;
  block[5] = this;
  block[6] = a2;
  dispatch_sync(v2, block);
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

BOOL ___ZN2CI19MetalTextureManager14lookup_textureEPv_block_invoke(uint64_t a1)
{
  _BOOL8 result;
  uint64_t v3;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CI::TextureManager::_lookup_texture(*(CI::TextureManager **)(a1 + 40), *(void **)(a1 + 48));
  result = CI::allowRemoval(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  if (result)
  {
    v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    ++*(_DWORD *)(v3 + 20);
  }
  return result;
}

void *CI::MetalTextureManager::create_texture(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v16;
  void *v17;
  _QWORD *v18;

  v16 = CIMetalFormatForFormat(*(_DWORD *)a8, *(unsigned __int8 *)(a8 + 4));
  v17 = CIMetalTextureCreate(*(_QWORD *)(*(_QWORD *)(a1 + 168) + 1920), (void *)objc_msgSend(*(id *)(*(_QWORD *)(a1 + 168) + 392), "device"), v16, a5, a6, 1);
  CIMetalTextureSetBytes(v17, a4, a7);
  v18 = malloc_type_malloc(0x20uLL, 0x10C20408CADBB15uLL);
  *v18 = v17;
  v18[1] = 0;
  *((_DWORD *)v18 + 4) = a3;
  *((_DWORD *)v18 + 5) = 1;
  *((_BYTE *)v18 + 24) = *(_BYTE *)(a8 + 5);
  CI::TextureManager::append_to_lru(a1, a2, (uint64_t)v18);
  return v17;
}

void *CI::MetalTextureManager::create_texture(_QWORD *a1, IOSurfaceRef buffer, size_t planeIndex, int a4, uint64_t a5)
{
  IOSurfaceRef BaseAddressOfPlane;
  uint64_t v11;
  void *v12;
  unsigned int v13;
  _QWORD *v14;

  BaseAddressOfPlane = buffer;
  if (a4 == 3)
    BaseAddressOfPlane = (IOSurfaceRef)IOSurfaceGetBaseAddressOfPlane(buffer, planeIndex);
  v11 = (*(uint64_t (**)(_QWORD *, IOSurfaceRef))(*a1 + 8))(a1, BaseAddressOfPlane);
  if (v11)
    return *(void **)v11;
  v13 = CIMetalFormatForFormat(*(_DWORD *)a5, *(unsigned __int8 *)(a5 + 4));
  v12 = CIMetalTextureCreateFromIOSurface(*(_QWORD *)(a1[21] + 1920), (void *)objc_msgSend(*(id *)(a1[21] + 392), "device"), buffer, planeIndex, v13, 1);
  v14 = malloc_type_malloc(0x20uLL, 0x10C20408CADBB15uLL);
  *v14 = v12;
  v14[1] = 0;
  *((_DWORD *)v14 + 4) = a4;
  *((_DWORD *)v14 + 5) = 1;
  *((_BYTE *)v14 + 24) = *(_BYTE *)(a5 + 5);
  CI::TextureManager::append_to_lru((uint64_t)a1, (uint64_t)BaseAddressOfPlane, (uint64_t)v14);
  return v12;
}

void *CI::MetalTextureManager::texture_for_CGImage(_QWORD **a1, CGImage *a2, uint64_t a3)
{
  uint64_t v6;
  void *texture;
  size_t Width;
  size_t Height;
  size_t BytesPerRow;
  CGDataProvider *DataProvider;
  uint64_t v13;
  const __CFData *v14;
  const __CFData *v15;
  const UInt8 *BytePtr;

  v6 = ((uint64_t (*)(_QWORD **))(*a1)[1])(a1);
  if (v6)
    return *(void **)v6;
  Width = CGImageGetWidth(a2);
  Height = CGImageGetHeight(a2);
  BytesPerRow = CGImageGetBytesPerRow(a2);
  if (Width > (*(uint64_t (**)(_QWORD *))(*a1[21] + 440))(a1[21])
    || Height > (*(uint64_t (**)(_QWORD *))(*a1[21] + 440))(a1[21]))
  {
    x_log("Cannot handle a (%lu x %lu) sized texture with the given context!\n", Width, Height);
    return 0;
  }
  DataProvider = CGImageGetDataProvider(a2);
  v13 = CGDataProviderRetainBytePtr();
  if (v13)
  {
    texture = CI::MetalTextureManager::create_texture((uint64_t)a1, (uint64_t)a2, 1, v13, Width, Height, BytesPerRow, a3);
    CGDataProviderReleaseBytePtr();
    return texture;
  }
  v14 = CGDataProviderCopyData(DataProvider);
  if (!v14)
    return 0;
  v15 = v14;
  if (CFDataGetLength(v14) >= 1 && (BytePtr = CFDataGetBytePtr(v15)) != 0)
    texture = CI::MetalTextureManager::create_texture((uint64_t)a1, (uint64_t)a2, 1, (uint64_t)BytePtr, Width, Height, BytesPerRow, a3);
  else
    texture = 0;
  CFRelease(v15);
  return texture;
}

void *CI::MetalTextureManager::texture_for_IOSurface(_QWORD *a1, IOSurfaceRef buffer, size_t a3, int *a4)
{
  int v8;
  int v9;
  const char *v11;
  const char *v12;
  int v13;
  __int16 v14;

  if (IOSurfaceGetPlaneCount(buffer) != 2)
    return CI::MetalTextureManager::create_texture(a1, buffer, a3, 2, (uint64_t)a4);
  if (a3)
    v8 = 3;
  else
    v8 = 2;
  v9 = CI::format_of_plane(*a4, a3);
  if ((v9 - 1285) > 1)
  {
    if (!v9)
    {
      if (a3)
        v11 = "Y";
      else
        v11 = "CbCr";
      v12 = CI::name_for_format(*a4);
      x_log("Unexpected format requesting a texture for %s plane of format %s\n", v11, v12);
      v9 = 0;
    }
  }
  else if ((*(_BYTE *)(a1[21] + 456) & 1) == 0)
  {
    v9 = 784;
  }
  v13 = v9;
  v14 = 0;
  return CI::MetalTextureManager::create_texture(a1, buffer, a3, v8, (uint64_t)&v13);
}

uint64_t CI::MetalMainProgram::get_next_offset(int a1, unint64_t *a2)
{
  uint64_t result;
  int v4;
  unint64_t v5;
  unint64_t v6;

  result = 0xFFFFFFFFLL;
  v4 = a1 - 5;
  v5 = *a2;
  switch(v4)
  {
    case 0:
    case 8:
    case 14:
    case 18:
      v5 = (v5 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      v6 = v5 + 4;
      goto LABEL_14;
    case 1:
    case 9:
    case 10:
    case 15:
    case 19:
      v5 = (v5 + 7) & 0xFFFFFFFFFFFFFFF8;
      goto LABEL_5;
    case 2:
    case 3:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
      v5 = (v5 + 15) & 0xFFFFFFFFFFFFFFF0;
      goto LABEL_3;
    case 4:
      v5 = (v5 + 7) & 0xFFFFFFFFFFFFFFF8;
LABEL_3:
      v6 = v5 + 16;
      goto LABEL_14;
    case 5:
    case 35:
    case 37:
    case 38:
    case 39:
      v5 = (v5 + 15) & 0xFFFFFFFFFFFFFFF0;
      v6 = v5 + 48;
      goto LABEL_14;
    case 6:
    case 32:
    case 36:
    case 40:
      v5 = (v5 + 15) & 0xFFFFFFFFFFFFFFF0;
      v6 = v5 + 64;
      goto LABEL_14;
    case 7:
      v5 = (v5 + 1) & 0xFFFFFFFFFFFFFFFELL;
      v6 = v5 + 2;
      goto LABEL_14;
    case 11:
      v5 = (v5 + 3) & 0xFFFFFFFFFFFFFFFCLL;
LABEL_5:
      v6 = v5 + 8;
      goto LABEL_14;
    case 12:
      v5 = (v5 + 7) & 0xFFFFFFFFFFFFFFF8;
      v6 = v5 + 24;
      goto LABEL_14;
    case 13:
      v5 = (v5 + 7) & 0xFFFFFFFFFFFFFFF8;
      v6 = v5 + 32;
LABEL_14:
      *a2 = v6;
      goto LABEL_15;
    case 41:
    case 42:
LABEL_15:
      result = v5;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t CI::MetalMainProgram::MetalMainProgram(uint64_t a1, uint64_t a2, const char *a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unsigned int v14;
  NSObject *v15;
  dispatch_queue_t v16;
  CFTypeRef v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int next_offset;

  CI::MainProgram::MainProgram((int64x2_t *)a1, a3, a4, a5, a6)[6].i64[0] = (uint64_t)off_1E2EBBF60;
  do
    v14 = __ldaxr(&dword_1ECF873D0[9]);
  while (__stlxr(v14 + 1, &dword_1ECF873D0[9]));
  *(_QWORD *)a1 = &off_1E2EBCC28;
  *(_QWORD *)(a1 + 96) = &unk_1E2EBCC90;
  *(_QWORD *)(a1 + 112) = a7;
  *(_QWORD *)(a1 + 120) = 0;
  v15 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v16 = dispatch_queue_create("CI::KernelCompileQueue", v15);
  *(_QWORD *)(a1 + 148) = 0;
  *(_QWORD *)(a1 + 128) = v16;
  *(_BYTE *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 156) = 0;
  *(_QWORD *)(a1 + 161) = 0;
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 1952);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(a2 + 1920);
  *(_BYTE *)(a1 + 144) = CI::MetalContext::use_imageblocks_for_format(a2, *(_DWORD *)a10);
  *(_DWORD *)(a1 + 148) = CIMetalFormatForFormat(*(_DWORD *)a10, (*(unsigned __int8 *)(a10 + 4) >> 1) & 1);
  v17 = (CFTypeRef)objc_msgSend(*(id *)(a2 + 392), "device");
  if (v17)
    v17 = CFRetain(v17);
  *(_QWORD *)(a1 + 152) = v17;
  *(_DWORD *)(a1 + 40) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 272))(a2);
  if (*(_QWORD *)(a1 + 112))
  {
    *(_QWORD *)(a1 + 104) = a8;
  }
  else
  {
    *(_QWORD *)(a1 + 104) = 16;
    v18 = CI::MainProgram::num_arguments((CI::MainProgram *)a1);
    v19 = operator new();
    CI::SerialValArray<int>::SerialValArray(v19, v18);
    *(_QWORD *)(a1 + 112) = v19;
    if (v18 >= 1)
    {
      v20 = 0;
      do
      {
        v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, v20);
        next_offset = CI::MetalMainProgram::get_next_offset(v21, (unint64_t *)(a1 + 104));
        CI::SerialValArray<int>::append(*(void ***)(a1 + 112), next_offset);
        v20 = (v20 + 1);
      }
      while (v18 != (_DWORD)v20);
    }
  }
  return a1;
}

void sub_1923E9A9C(_Unwind_Exception *a1)
{
  CI::MainProgram *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int *v6;
  unsigned int v7;

  MEMORY[0x194025AAC](v2, 0x1010C40C0D7B093);
  *((_QWORD *)v1 + 12) = v3;
  v6 = (unsigned int *)(v4 + 268);
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  CI::MainProgram::~MainProgram(v1);
  _Unwind_Resume(a1);
}

void CI::MetalMainProgram::~MetalMainProgram(CI::MetalMainProgram *this)
{
  NSObject *v2;
  uint64_t v3;
  void *v4;
  const void *v5;
  unsigned int v6;
  _QWORD block[5];

  *(_QWORD *)this = &off_1E2EBCC28;
  *((_QWORD *)this + 12) = &unk_1E2EBCC90;
  v2 = *((_QWORD *)this + 16);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZN2CI16MetalMainProgramD2Ev_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = this;
  dispatch_sync(v2, block);
  dispatch_release(*((dispatch_object_t *)this + 16));
  v3 = *((_QWORD *)this + 14);
  if (v3)
  {
    v4 = *(void **)(v3 + 16);
    if (v4)
      free(v4);
    MEMORY[0x194025AAC](v3, 0x1010C40C0D7B093);
  }
  *((_QWORD *)this + 14) = 0;
  v5 = (const void *)*((_QWORD *)this + 19);
  if (v5)
    CFRelease(v5);
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 12) = off_1E2EBBF60;
  do
    v6 = __ldaxr(&dword_1ECF873D0[9]);
  while (__stlxr(v6 - 1, &dword_1ECF873D0[9]));
  CI::MainProgram::~MainProgram(this);
}

{
  CI::MetalMainProgram::~MetalMainProgram(this);
  JUMPOUT(0x194025AACLL);
}

void sub_1923E9BDC(_Unwind_Exception *a1)
{
  CI::MainProgram *v1;
  unsigned int v3;

  *((_QWORD *)v1 + 12) = off_1E2EBBF60;
  do
    v3 = __ldaxr(&dword_1ECF873D0[9]);
  while (__stlxr(v3 - 1, &dword_1ECF873D0[9]));
  CI::MainProgram::~MainProgram(v1);
  _Unwind_Resume(a1);
}

void ___ZN2CI16MetalMainProgramD2Ev_block_invoke(uint64_t a1)
{
  uint64_t v1;
  const void *v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(const void **)(v1 + 160);
  if (v2)
    CFRelease(v2);
  *(_QWORD *)(v1 + 160) = 0;
}

void `non-virtual thunk to'CI::MetalMainProgram::~MetalMainProgram(CI::MetalMainProgram *this)
{
  CI::MetalMainProgram::~MetalMainProgram((CI::MetalMainProgram *)((char *)this - 96));
}

{
  CI::MetalMainProgram::~MetalMainProgram((CI::MetalMainProgram *)((char *)this - 96));
  JUMPOUT(0x194025AACLL);
}

void CI::MetalMainProgram::compile(uint64_t a1, int a2)
{
  NSObject *v4;
  os_signpost_id_t v5;
  NSObject *v6;
  std::chrono::steady_clock::time_point v7;
  NSObject **v8;
  void *v9;
  NSObject **v10;
  uint64_t RenderPipelineState;
  uint8_t v12[64];

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 128));
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v4 = ci_signpost_log_compile();
    v5 = a2 | ((unint64_t)*(unsigned int *)(a1 + 40) << 32);
    if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v6 = v4;
      if (os_signpost_enabled(v4))
      {
        *(_WORD *)v12 = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v6, OS_SIGNPOST_INTERVAL_BEGIN, v5, "compile_metal", (const char *)&unk_192520C83, v12, 2u);
      }
    }
  }
  TimerBase::TimerBase((uint64_t)v12, *(unsigned int *)(a1 + 40), a2, (uint64_t)"compile_metal", 25);
  v7.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v8 = CI::find_in_archive(*(NSObject ***)(a1 + 120), *(_QWORD *)(a1 + 16), *(const char **)(a1 + 48));
  v10 = v8;
  if (*(_BYTE *)(a1 + 144))
  {
    if (v8)
      RenderPipelineState = CreateRenderPipelineState(*(void **)(a1 + 152), (uint64_t)v8, (uint64_t)v9, *(_DWORD *)(a1 + 148), 0);
    else
      RenderPipelineState = (uint64_t)CIMetalRenderPipelineStateCreateFromSource(*(_QWORD *)(a1 + 136), *(void **)(a1 + 152), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 148));
  }
  else if (v8)
  {
    RenderPipelineState = CreateComputePipelineState(*(void **)(a1 + 152), v8, v9, 0);
  }
  else
  {
    RenderPipelineState = (uint64_t)CIMetalComputePipelineStateCreateFromSource(*(_QWORD *)(a1 + 136), *(void **)(a1 + 152), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 16));
  }
  *(_QWORD *)(a1 + 160) = RenderPipelineState;
  *(_BYTE *)(a1 + 168) = v10 != 0;
  *(double *)(a1 + 24) = (double)(std::chrono::steady_clock::now().__d_.__rep_ - v7.__d_.__rep_) / 1000000000.0;
  CI::MetalMainProgram::compile(CI::NodeIndex)::SignpostTimer::~SignpostTimer((TimerBase *)v12);
}

void sub_1923E9E14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CI::MetalMainProgram::compile(CI::NodeIndex)::SignpostTimer::~SignpostTimer((TimerBase *)&a9);
  _Unwind_Resume(a1);
}

void CI::MetalMainProgram::compile(CI::NodeIndex)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  if (CI_VERBOSE_SIGNPOSTS())
  {
    v2 = ci_signpost_log_compile();
    v3 = *((_QWORD *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "compile_metal", (const char *)&unk_192520C83, v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1923E9EB8(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void CI::MetalMainProgram::compileAsync(uint64_t a1, int a2)
{
  NSObject *v2;
  _QWORD v3[5];
  int v4;

  v2 = *(NSObject **)(a1 + 128);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___ZN2CI16MetalMainProgram12compileAsyncENS_9NodeIndexE_block_invoke;
  v3[3] = &__block_descriptor_44_e5_v8__0l;
  v3[4] = a1;
  v4 = a2;
  dispatch_sync(v2, v3);
}

uint64_t ___ZN2CI16MetalMainProgram12compileAsyncENS_9NodeIndexE_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (!*(_QWORD *)(result + 160) && *(double *)(result + 24) == 0.0)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 80))(result, *(unsigned int *)(a1 + 40));
  return result;
}

uint64_t ___ZNK2CI16MetalMainProgram16getPipelineStateENS_9NodeIndexE_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (!*(_QWORD *)(result + 160) && *(double *)(result + 24) == 0.0)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 80))(result, *(unsigned int *)(a1 + 40));
  return result;
}

CI::MetalContext *CI::MetalContext::MetalContext(CI::MetalContext *this, const CI::MetalContext *a2)
{
  unsigned int v4;

  *((_QWORD *)CI::Context::Context(this, a2) + 48) = off_1E2EB7B30;
  do
    v4 = __ldaxr(&dword_1ECF873D0[19]);
  while (__stlxr(v4 + 1, &dword_1ECF873D0[19]));
  *(_QWORD *)this = &off_1E2EB9400;
  *((_QWORD *)this + 48) = &unk_1E2EB9680;
  *((_QWORD *)this + 49) = 0;
  *((_QWORD *)this + 223) = 0;
  *((_QWORD *)this + 228) = 0;
  *((_DWORD *)this + 462) = 0;
  *((_BYTE *)this + 1852) = 0;
  bzero((char *)this + 460, 0x301uLL);
  *(_OWORD *)((char *)this + 1928) = 0u;
  *(_OWORD *)((char *)this + 1944) = 0u;
  *(_OWORD *)((char *)this + 1912) = 0u;
  CI::MetalContext::init(this, *((CFTypeRef *)a2 + 49), *((const char **)a2 + 240));
  return this;
}

void sub_1923EA03C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  CI::Object *v5;
  unsigned int *v6;
  unsigned int v7;

  v5 = *(CI::Object **)(v1 + 1824);
  *(_QWORD *)(v1 + 1824) = 0;
  if (v5)
    CI::Object::unref(v5);
  *(_QWORD *)(v1 + 384) = v2;
  v6 = (unsigned int *)(v3 + 308);
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  CI::Context::~Context((CGColorSpaceRef *)v1);
  _Unwind_Resume(a1);
}

uint64_t CI::GLContext::MTLShadow(CI::GLContext *this)
{
  CI::MetalContext *v1;

  v1 = (CI::MetalContext *)*((_QWORD *)this + 44);
  if (!v1)
  {
    v1 = (CI::MetalContext *)operator new();
    CI::MetalContext::MetalContext(v1, this, "com.apple.CoreImage");
    *((_QWORD *)this + 44) = v1;
  }
  return CI::Object::ref((uint64_t)v1);
}

void sub_1923EA0D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10F1C4010D716A0);
  _Unwind_Resume(a1);
}

CI::MetalContext *CI::SWContext::MTLShadow(CI::SWContext *this)
{
  CI::MetalContext *v1;

  v1 = (CI::MetalContext *)*((_QWORD *)this + 44);
  if (!v1)
  {
    v1 = (CI::MetalContext *)operator new();
    CI::MetalContext::MetalContext(v1, this, "com.apple.CoreImage");
    *((_QWORD *)this + 44) = v1;
  }
  return v1;
}

void sub_1923EA154(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10F1C4010D716A0);
  _Unwind_Resume(a1);
}

uint64_t CI::Context::MTLShadow(CI::Context *this)
{
  return *((_QWORD *)this + 44);
}

CI::MetalContext *CI::MetalContext::MetalContext(CI::MetalContext *this, const CI::Context *a2, const char *a3)
{
  unsigned int v5;
  id v6;
  void *v7;

  *((_QWORD *)CI::Context::Context(this, a2) + 48) = off_1E2EB7B30;
  do
    v5 = __ldaxr(&dword_1ECF873D0[19]);
  while (__stlxr(v5 + 1, &dword_1ECF873D0[19]));
  *(_QWORD *)this = &off_1E2EB9400;
  *((_QWORD *)this + 48) = &unk_1E2EB9680;
  *((_QWORD *)this + 49) = 0;
  *((_QWORD *)this + 223) = 0;
  *((_QWORD *)this + 228) = 0;
  *((_DWORD *)this + 462) = 0;
  *((_BYTE *)this + 1852) = 0;
  bzero((char *)this + 460, 0x301uLL);
  *(_OWORD *)((char *)this + 1928) = 0u;
  *(_OWORD *)((char *)this + 1944) = 0u;
  *(_OWORD *)((char *)this + 1912) = 0u;
  v6 = CIMetalCopyDefaultDevice();
  v7 = CIMetalCommandQueueCreate((uint64_t)a3, v6);
  CI::MetalContext::init(this, v7, a3);
  if (v6)
    CFRelease(v6);
  if (v7)
    CFRelease(v7);
  return this;
}

void sub_1923EA26C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  CI::Object *v5;
  unsigned int *v6;
  unsigned int v7;

  v5 = *(CI::Object **)(v1 + 1824);
  *(_QWORD *)(v1 + 1824) = 0;
  if (v5)
    CI::Object::unref(v5);
  *(_QWORD *)(v1 + 384) = v2;
  v6 = (unsigned int *)(v3 + 308);
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  CI::Context::~Context((CGColorSpaceRef *)v1);
  _Unwind_Resume(a1);
}

uint64_t CI::MetalContext::SWShadow(CI::MetalContext *this)
{
  return CI::Object::ref(*((_QWORD *)this + 228));
}

uint64_t CI::MetalContext::binaryArchiveCache(CI::MetalContext *this)
{
  if (CI::MetalContext::binaryArchiveCache(void)::onceToken != -1)
    dispatch_once(&CI::MetalContext::binaryArchiveCache(void)::onceToken, &__block_literal_global_11_0);
  return CI::MetalContext::binaryArchiveCache(void)::cache;
}

void CI::MetalContext::add_archive(NSObject ***this, const __CFString *a2)
{
  void *v4;
  void *v5;
  NSObject *v6;
  int v7;
  NSObject **v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  __int128 *v14;
  char *v15;
  char *v16;
  void *__p;
  void *v18;
  uint64_t v19;
  uint8_t buf[8];
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (CI_USE_ARCHIVED_KERNELS())
  {
    if (CI::MetalContext::binaryArchiveCache(void)::onceToken != -1)
      dispatch_once(&CI::MetalContext::binaryArchiveCache(void)::onceToken, &__block_literal_global_11_0);
    v4 = (void *)CI::MetalContext::binaryArchiveCache(void)::cache;
    objc_sync_enter((id)CI::MetalContext::binaryArchiveCache(void)::cache);
    v5 = (void *)objc_msgSend(v4, "objectForKey:", a2);
    objc_sync_exit(v4);
    if (v5)
    {
      v6 = ci_logger_render();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        v7 = ((uint64_t (*)(NSObject ***))(*this)[34])(this);
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)&buf[4] = v7;
        LOWORD(v21) = 2114;
        *(_QWORD *)((char *)&v21 + 2) = a2;
        _os_log_impl(&dword_1921E4000, v6, OS_LOG_TYPE_INFO, "Context[%d] uses %{public}@ archive", buf, 0x12u);
      }
      v8 = this[244];
      if (v8)
      {
        CI::add_to_kernel_archive(v8, objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("air")), objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("bin")));
      }
      else
      {
        *(_QWORD *)buf = 0;
        v21 = 0uLL;
        v9 = objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("air"));
        v10 = objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("bin"));
        v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)&v21 + 8, 1uLL);
        v13 = &v11[16 * v12];
        *(_QWORD *)v11 = v9;
        *((_QWORD *)v11 + 1) = v10;
        v14 = (__int128 *)(v11 + 16);
        v16 = *(char **)buf;
        v15 = (char *)v21;
        if ((_QWORD)v21 != *(_QWORD *)buf)
        {
          do
          {
            *((_OWORD *)v11 - 1) = *((_OWORD *)v15 - 1);
            v11 -= 16;
            v15 -= 16;
          }
          while (v15 != v16);
          v15 = *(char **)buf;
        }
        *(_QWORD *)buf = v11;
        *(_QWORD *)&v21 = v14;
        *((_QWORD *)&v21 + 1) = v13;
        if (v15)
        {
          operator delete(v15);
          v11 = *(char **)buf;
        }
        *(_QWORD *)&v21 = v14;
        v18 = 0;
        v19 = 0;
        __p = 0;
        std::vector<std::pair<void const*,void const*>>::__init_with_size[abi:nn180100]<std::pair<void const*,void const*>*,std::pair<void const*,void const*>*>((char *)&__p, (__int128 *)v11, v14, ((char *)v14 - v11) >> 4);
        this[244] = (NSObject **)CI::new_kernel_archive((__int128 **)&__p);
        if (__p)
        {
          v18 = __p;
          operator delete(__p);
        }
        if (*(_QWORD *)buf)
        {
          *(_QWORD *)&v21 = *(_QWORD *)buf;
          operator delete(*(void **)buf);
        }
      }
    }
  }
}

void sub_1923EA530(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  if (__p)
    operator delete(__p);
  if (a13)
    operator delete(a13);
  _Unwind_Resume(exception_object);
}

void `non-virtual thunk to'CI::MetalContext::~MetalContext(CI::MetalContext *this)
{
  CI::MetalContext::~MetalContext((CI::MetalContext *)((char *)this - 384));
}

{
  CI::MetalContext::~MetalContext((CI::MetalContext *)((char *)this - 384));
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::MetalContext::queue(CI::MetalContext *this)
{
  return *((_QWORD *)this + 49);
}

void *CI::MetalContext::protectionOptions(CI::MetalContext *this)
{
  void *result;

  result = (void *)*((_QWORD *)this + 224);
  if (result)
    return (void *)objc_msgSend(result, "protectionOptions");
  result = (void *)*((_QWORD *)this + 226);
  if (result)
    return (void *)objc_msgSend(result, "protectionOptions");
  return result;
}

const char *CI::MetalContext::name(CI::MetalContext *this)
{
  return "metal";
}

const char *CI::MetalContext::deviceName(id *this)
{
  void *v1;

  v1 = (void *)objc_msgSend((id)objc_msgSend(this[49], "device"), "name");
  if (v1)
    return (const char *)objc_msgSend(v1, "UTF8String");
  else
    return "Unknown Metal Device";
}

uint64_t CI::MetalContext::setPriority(uint64_t a1, const char *a2)
{
  return CIMetalCommandQueueSetPriority(*(void **)(a1 + 392), a2);
}

uint64_t CI::MetalContext::priority(id *this)
{
  uint64_t v1;
  unsigned int v2;

  v1 = objc_msgSend(this[49], "getGPUPriority");
  if (v1 == 2)
    v2 = -1;
  else
    v2 = 0;
  if (v1)
    return v2;
  else
    return 1;
}

__CFDictionary *CI::MetalContext::switch_dictionary(CI::MetalContext *this)
{
  __CFDictionary *result;
  __CFDictionary *Mutable;
  _BOOL8 v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  result = (__CFDictionary *)*((_QWORD *)this + 239);
  if (!result)
  {
    Mutable = CFDictionaryCreateMutable(0, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    *((_QWORD *)this + 239) = Mutable;
    v4 = CIMetalDeviceSupportsMPS((void *)objc_msgSend(*((id *)this + 49), "device"));
    __CFDictionary::setValue(Mutable, (__CFDictionary *)CFSTR("kContextInfoSupportsMPS"), (const __CFString *)v4, v5);
    __CFDictionary::setValue(*((__CFDictionary **)this + 239), (__CFDictionary *)CFSTR("kContextInfoIsMetal"), (const __CFString *)1, v6);
    __CFDictionary::setValue(*((__CFDictionary **)this + 239), (__CFDictionary *)CFSTR("kContextInfoWorkingFormat"), (const __CFString *)*((unsigned int *)this + 8));
    v8 = (const void *)*((_QWORD *)this + 3);
    result = (__CFDictionary *)*((_QWORD *)this + 239);
    if (v8)
    {
      __CFDictionary::setValue(result, CFSTR("kContextInfoWorkingSpace"), v8, v7);
      return (__CFDictionary *)*((_QWORD *)this + 239);
    }
  }
  return result;
}

void CI::MetalContext::invalidate_switch_dictionary(CI::MetalContext *this)
{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 239);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 239) = 0;
  }
}

void CI::MetalContext::waitForCompletion(CI::MetalContext *this)
{
  void *v2;
  BOOL v3;
  uint64_t v4;

  v2 = (void *)*((_QWORD *)this + 224);
  if (v2)
    v3 = v2 == *((void **)this + 226);
  else
    v3 = 1;
  if (!v3)
  {
    CIMetalCommandBufferWaitUntilCompleted(v2);
    if (!*((_QWORD *)this + 226))
    {
      v4 = (*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)this + 112))(this);
      dispatch_group_wait(*(dispatch_group_t *)(v4 + 88), 0xFFFFFFFFFFFFFFFFLL);
    }
  }
}

void CI::MetalContext::after_render(CI::MetalContext *this)
{
  NSObject *v2;
  os_signpost_id_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7[64];

  v2 = ci_signpost_log_render();
  v3 = (*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)this + 272))(this) << 32;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)v7 = 0;
    _os_signpost_emit_with_name_impl(&dword_1921E4000, v2, OS_SIGNPOST_INTERVAL_BEGIN, v3, "after_render", (const char *)&unk_192520C83, v7, 2u);
  }
  v4 = (*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)this + 272))(this);
  TimerBase::TimerBase((uint64_t)v7, v4, 0, (uint64_t)"after_render", 8);
  *((_OWORD *)this + 112) = 0u;
  CI::TextureManager::remove_all(*((CI::TextureManager **)this + 227));
  v5 = *((_QWORD *)this + 227);
  if (CI_RECYCLE_METAL_TEXTURES())
    v6 = CI_INTERMEDIATE_CACHE_SIZE();
  else
    v6 = 0;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 64))(v5, v6);
  CI::MetalContext::after_render(void)::SignpostTimer::~SignpostTimer((TimerBase *)v7);
}

void sub_1923EA880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CI::MetalContext::after_render(void)::SignpostTimer::~SignpostTimer((TimerBase *)&a9);
  _Unwind_Resume(a1);
}

void CI::MetalContext::after_render(void)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  v2 = ci_signpost_log_render();
  v3 = *((_QWORD *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "after_render", (const char *)&unk_192520C83, v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1923EA91C(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::MetalContext::compute_quad(uint64_t a1, int a2, uint64_t a3, double *a4, void **a5, uint64_t a6, unint64_t a7, unsigned int a8, unint64_t a9, unsigned int a10)
{
  NSObject *v18;
  os_signpost_id_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  void *v23;
  uint64_t v24;
  _QWORD *v25;
  int v26;
  int v28;
  void *v29;
  uint64_t v30;
  double v31;
  double v32;
  uint64_t v33;
  uint64_t v34;
  BOOL v35;
  BOOL v36;
  unint64_t *p_block;
  unint64_t v38[3];
  uint8_t buf[56];
  uint64_t block;
  uint64_t v41;
  uint64_t (*v42)(uint64_t);
  void *v43;
  uint64_t v44;
  int v45;

  if (CI_VERBOSE_SIGNPOSTS())
  {
    v18 = ci_signpost_log_render();
    v19 = a2 | (unint64_t)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1) << 32);
    if (v19 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v18))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v18, OS_SIGNPOST_INTERVAL_BEGIN, v19, "compute_quad", (const char *)&unk_192520C83, buf, 2u);
    }
  }
  v20 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
  TimerBase::TimerBase((uint64_t)buf, v20, a2, (uint64_t)"compute_quad", 14);
  if (CI_NO_RENDER())
    goto LABEL_6;
  v22 = *(NSObject **)(a3 + 128);
  block = MEMORY[0x1E0C809B0];
  v41 = 3221225472;
  v42 = ___ZNK2CI16MetalMainProgram16getPipelineStateENS_9NodeIndexE_block_invoke;
  v43 = &__block_descriptor_44_e5_v8__0l;
  v44 = a3;
  v45 = a2;
  dispatch_sync(v22, &block);
  v23 = *(void **)(a3 + 160);
  if (!v23 || !*(_QWORD *)(a1 + 1784) || !*a5)
  {
LABEL_17:
    v21 = 0;
    goto LABEL_18;
  }
  v24 = *(_QWORD *)(a1 + 1744);
  if (v24)
  {
    v25 = (_QWORD *)(a1 + 1488);
    while (*(v25 - 32) && *v25)
    {
      ++v25;
      if (!--v24)
        goto LABEL_15;
    }
    goto LABEL_17;
  }
LABEL_15:
  if (*(_BYTE *)(a3 + 144))
  {
    v26 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
    CIMetalRenderToImageblocks(v26, a2, *(void **)(a1 + 1792), v23, *(_QWORD *)(a1 + 1784), *a4, a4[1], a6, a5, *(_QWORD *)(a1 + 1744), a1 + 1232, a1 + 1488, *(_QWORD *)(a3 + 48));
  }
  else
  {
    block = a9;
    v41 = HIDWORD(a9);
    v42 = (uint64_t (*)(uint64_t))a10;
    v28 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
    v29 = *(void **)(a1 + 1792);
    v30 = *(_QWORD *)(a1 + 1784);
    v31 = *a4;
    v32 = a4[1];
    v33 = *(_QWORD *)(a1 + 1744);
    v34 = *(_QWORD *)(a3 + 48);
    v38[0] = a7;
    v38[1] = HIDWORD(a7);
    if ((_DWORD)a9)
      v35 = HIDWORD(a9) == 0;
    else
      v35 = 1;
    v36 = v35 || a10 == 0;
    p_block = (unint64_t *)&block;
    if (v36)
      p_block = 0;
    v38[2] = a8;
    CIMetalRenderToTextures(v28, a2, v29, v23, v30, a6, (uint64_t)a5, v33, v31, v32, a1 + 1232, a1 + 1488, v34, v38, p_block);
  }
LABEL_6:
  v21 = 1;
LABEL_18:
  CI::MetalContext::compute_quad(CI::NodeIndex,CI::MetalMainProgram const*,CGSize const&,void const**,unsigned long,CI::Dimensions,CI::Dimensions)::SignpostTimer::~SignpostTimer((TimerBase *)buf);
  return v21;
}

void sub_1923EABCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  CI::MetalContext::compute_quad(CI::NodeIndex,CI::MetalMainProgram const*,CGSize const&,void const**,unsigned long,CI::Dimensions,CI::Dimensions)::SignpostTimer::~SignpostTimer((TimerBase *)va);
  _Unwind_Resume(a1);
}

void CI::MetalContext::compute_quad(CI::NodeIndex,CI::MetalMainProgram const*,CGSize const&,void const**,unsigned long,CI::Dimensions,CI::Dimensions)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  if (CI_VERBOSE_SIGNPOSTS())
  {
    v2 = ci_signpost_log_render();
    v3 = *((_QWORD *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "compute_quad", (const char *)&unk_192520C83, v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1923EAC78(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

BOOL CI::MetalContext::set_texture_destination(CI::MetalContext *this, Texture a2, const CGSize *a3)
{
  unint64_t var0;

  var0 = a2.var0.var0;
  if (a2.var0.var0)
  {
    *((_WORD *)this + 952) = 1;
    *(CGSize *)((char *)this + 1832) = *a3;
    *((_QWORD *)this + 233) = CFRetain(a2.var0.var2.var0);
  }
  return var0 != 0;
}

BOOL CI::MetalContext::set_texture_destination(uint64_t a1, void *aBlock, _OWORD *a3)
{
  if (aBlock)
  {
    *(_WORD *)(a1 + 1904) = 1;
    *(_OWORD *)(a1 + 1832) = *a3;
    *(_QWORD *)(a1 + 1888) = _Block_copy(aBlock);
  }
  return aBlock != 0;
}

size_t CI::MetalContext::set_surface_destination(uint64_t a1, __IOSurface *a2, uint64_t a3, int *a4)
{
  size_t result;
  unsigned int v9;
  __int16 v10;
  char v11;
  __IOSurface *v12;
  int v13;
  int v14;

  result = *a4;
  if ((_DWORD)result)
  {
    *(_WORD *)(a1 + 1904) = 257;
    v9 = CIMetalFormatForFormat(result, *((unsigned __int8 *)a4 + 4));
    v10 = 2;
    if (CI::MetalContext::use_imageblocks_for_format(a1, *a4))
    {
      if (CI_ENABLE_METAL_IMAGEBLOCKS() == 2)
        v10 = 4;
      else
        v10 = 2;
    }
    *(_OWORD *)(a1 + 1832) = *(_OWORD *)a3;
    v11 = 2 * *((_BYTE *)a4 + 4);
    *(_DWORD *)(a1 + 1848) = *a4;
    *(_BYTE *)(a1 + 1852) = v11;
    *(_QWORD *)(a1 + 1864) = CIMetalTextureCreateFromPaddedIOSurface((unint64_t)*(double *)a3, (unint64_t)*(double *)(a3 + 8), *(_QWORD *)(a1 + 1920), (void *)objc_msgSend(*(id *)(a1 + 392), "device"), (uint64_t)a2, 0, v9, v10);
    result = IOSurfaceGetPlaneCount(a2);
    if (result == 2)
    {
      v13 = CI::format_from_IOSurface(a2, v12);
      CI::format_is_ycc_biplanar(v13);
      v14 = CI::format_of_plane(v13, 1);
      result = CIMetalFormatForFormat(v14, 0);
      if ((_DWORD)result)
      {
        result = (size_t)CIMetalTextureCreateFromIOSurface(*(_QWORD *)(a1 + 1920), (void *)objc_msgSend(*(id *)(a1 + 392), "device"), a2, 1uLL, result, 2);
        *(_QWORD *)(a1 + 1872) = result;
      }
    }
  }
  return result;
}

unint64_t CI::MetalContext::set_bitmap_destination(uint64_t a1, CI::Bitmap *a2, double *a3, int *a4, unint64_t a5)
{
  unint64_t result;
  unsigned int v11;
  double v12;
  double v13;
  int v14;
  char v15;
  unsigned __int8 v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;

  result = *a4;
  if ((_DWORD)result)
  {
    *(_BYTE *)(a1 + 1904) = 0;
    v11 = CIMetalFormatForFormat(result, *((unsigned __int8 *)a4 + 4));
    v12 = a3[1];
    v13 = *a3 * (double)a5;
    v14 = 2;
    if (CI::MetalContext::use_imageblocks_for_format(a1, *a4))
    {
      if (CI_ENABLE_METAL_IMAGEBLOCKS() == 2)
        v14 = 4;
      else
        v14 = 2;
    }
    *(_OWORD *)(a1 + 1832) = *(_OWORD *)a3;
    v15 = 2 * *((_BYTE *)a4 + 4);
    *(_DWORD *)(a1 + 1848) = *a4;
    *(_BYTE *)(a1 + 1852) = v15;
    if ((v16 & 1) == 0
    {
      CI::MetalContext::set_bitmap_destination(CI::Bitmap *,CGSize const&,CI::TextureDescriptor const&,unsigned long)::page_size = getpagesize();
    }
    v17 = *((_QWORD *)a2 + 9);
    v18 = CI::Bitmap::length(a2);
    v19 = *((_QWORD *)a2 + 12);
    v20 = CI::MetalContext::set_bitmap_destination(CI::Bitmap *,CGSize const&,CI::TextureDescriptor const&,unsigned long)::page_size
        - 1;
    if ((CI::MetalContext::set_bitmap_destination(CI::Bitmap *,CGSize const&,CI::TextureDescriptor const&,unsigned long)::page_size & (CI::MetalContext::set_bitmap_destination(CI::Bitmap *,CGSize const&,CI::TextureDescriptor const&,unsigned long)::page_size - 1)) != 0)
    {
      if (v17
         % CI::MetalContext::set_bitmap_destination(CI::Bitmap *,CGSize const&,CI::TextureDescriptor const&,unsigned long)::page_size
        || v18
         % CI::MetalContext::set_bitmap_destination(CI::Bitmap *,CGSize const&,CI::TextureDescriptor const&,unsigned long)::page_size)
      {
        goto LABEL_16;
      }
    }
    else if ((v20 & v17) != 0 || (v20 & v18) != 0)
    {
      goto LABEL_16;
    }
    if ((v19 & 0x3F) == 0 && v18 >= v19 * (unint64_t)v12)
    {
      v21 = CIMetalBufferCreateAndWrapData(*(_QWORD *)(a1 + 1920), (void *)objc_msgSend(*(id *)(a1 + 392), "device"), v17, v18);
      *(_QWORD *)(a1 + 1856) = v21;
      result = (unint64_t)CIMetalTextureCreateFromBuffer(*(_QWORD *)(a1 + 1920), v21, v11, (unint64_t)v13, (unint64_t)v12, v19, v14);
LABEL_17:
      *(_QWORD *)(a1 + 1864) = result;
      return result;
    }
LABEL_16:
    result = (unint64_t)CIMetalTextureCreate(*(_QWORD *)(a1 + 1920), (void *)objc_msgSend(*(id *)(a1 + 392), "device"), v11, (unint64_t)v13, (unint64_t)v12, v14);
    goto LABEL_17;
  }
  return result;
}

CFIndex CI::Bitmap::length(CI::Bitmap *this)
{
  uint64_t v2;
  uint64_t v3;

  if (*((_QWORD *)this + 5))
    return CFDataGetLength(*((CFDataRef *)this + 5));
  v2 = *((_QWORD *)this + 10);
  v3 = (*((_QWORD *)this + 11) - 1) * *((_QWORD *)this + 12);
  return v3 + v2 * (int)CI::format_bytes_per_pixel(*((_DWORD *)this + 26));
}

double CI::MetalContext::unset_destination(CI::MetalContext *this)
{
  const void *v2;
  uint64_t v3;
  char v4;
  char v5;
  char *v6;
  const void *v7;
  _QWORD *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  double result;

  v2 = (const void *)*((_QWORD *)this + 226);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 226) = 0;
  }
  v3 = 0;
  v4 = 1;
  do
  {
    v5 = v4;
    v6 = (char *)this + 8 * v3;
    v7 = (const void *)*((_QWORD *)v6 + 233);
    if (v7)
    {
      v8 = v6 + 1864;
      CFRelease(v7);
      *v8 = 0;
    }
    v4 = 0;
    v3 = 1;
  }
  while ((v5 & 1) != 0);
  v9 = (const void *)*((_QWORD *)this + 232);
  if (v9)
  {
    CFRelease(v9);
    *((_QWORD *)this + 232) = 0;
  }
  v10 = (const void *)*((_QWORD *)this + 235);
  if (v10)
  {
    CFRelease(v10);
    *((_QWORD *)this + 235) = 0;
  }
  v11 = (const void *)*((_QWORD *)this + 236);
  if (v11)
    _Block_release(v11);
  *((_QWORD *)this + 237) = 0;
  result = 0.0;
  *(_OWORD *)((char *)this + 1864) = 0u;
  *(_OWORD *)((char *)this + 1880) = 0u;
  *(_OWORD *)((char *)this + 1832) = 0u;
  *(_OWORD *)((char *)this + 1848) = 0u;
  return result;
}

CFTypeRef CI::MetalContext::set_command_buffer(CFTypeRef this, CFTypeRef cf)
{
  uint64_t v2;

  if (cf)
  {
    v2 = (uint64_t)this;
    this = CFRetain(cf);
    *(_QWORD *)(v2 + 1808) = this;
  }
  return this;
}

uint64_t CI::MetalContext::render_node(CI::MetalContext *this, CI::TileTask *a2, const CI::parentROI *a3, const CGRect *a4, const void **a5, __IOSurface **a6, uint64_t a7)
{
  uint64_t v14;
  double v15;
  CGFloat v16;
  CGFloat v17;
  CGFloat v18;
  CGFloat v19;
  CGFloat v20;
  CGFloat v21;
  CGFloat v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  os_signpost_id_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  __IOSurface *v31;
  uint64_t v32;
  NSObject *v33;
  os_signpost_id_t v34;
  uint64_t v35;
  dispatch_queue_t v36;
  double v37;
  double v38;
  CGFloat height;
  CGFloat MidY;
  CGFloat v41;
  double v42;
  CGFloat v43;
  uint64_t v49;
  unsigned int v50;
  unint64_t v51;
  unsigned int v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v56;
  int v57;
  uint64_t v58;
  int v59;
  NSObject *isa;
  Class v61;
  const void *v62;
  CGAffineTransform v63;
  CGSize v64;
  CGRect v65;
  CGRect v66;
  __int128 buf;
  uint64_t (*v68)(uint64_t);
  void *v69;
  dispatch_queue_t v70;
  int v71;
  uint64_t v72;
  Texture v73;
  CGRect v74;
  CGRect v75;
  CGRect v76;
  CGRect v77;

  v72 = *MEMORY[0x1E0C80C00];
  v14 = *(_QWORD *)a3;
  v15 = CI::parentROI::roi(a3);
  v66.origin.x = v15;
  v66.origin.y = v16;
  v66.size.width = v17;
  v66.size.height = v18;
  if (!v14)
    return 0;
  v19 = v15;
  v20 = v16;
  v21 = v17;
  v22 = v18;
  bzero((char *)this + 1232, 0x100uLL);
  bzero((char *)this + 1488, 0x100uLL);
  *((_QWORD *)this + 218) = 0;
  v23 = *(_QWORD *)(v14 + 48);
  if ((*(int (**)(uint64_t))(*(_QWORD *)v23 + 16))(v23) >= 41
    && (*(int (**)(uint64_t))(*(_QWORD *)v23 + 16))(v23) <= 42)
  {
    v24 = *(_QWORD *)(v14 + 48);
    if (*(_BYTE *)(v24 + 153)
      && (*(int (**)(uint64_t))(*(_QWORD *)v24 + 40))(v24) >= 1
      && *((_QWORD *)this + 225))
    {
      if (CI_VERBOSE_SIGNPOSTS())
      {
        v25 = ci_signpost_log_render();
        v26 = *(int *)(v24 + 36) | (unint64_t)((*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)this + 272))(this) << 32);
        if (v26 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v25))
        {
          v27 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v24 + 24))(v24);
          LODWORD(buf) = 138543362;
          *(_QWORD *)((char *)&buf + 4) = v27;
          _os_signpost_emit_with_name_impl(&dword_1921E4000, v25, OS_SIGNPOST_INTERVAL_BEGIN, v26, "processor_syncinputs", "%{public}@", (uint8_t *)&buf, 0xCu);
        }
      }
      v28 = (*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)this + 272))(this);
      TimerBase::TimerBase((uint64_t)&buf, v28, *(_DWORD *)(v24 + 36), (uint64_t)"processor_syncinputs", 0);
      v29 = (void *)*((_QWORD *)this + 225);
      if (v29 == *((void **)this + 226))
      {
        CI::MetalContext::render_node(CI::TileTask *,CI::parentROI const&,CGRect const&,void const**,__IOSurface **,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)&buf);
        return 0;
      }
      CIMetalCommandBufferWaitUntilCompleted(v29);
      CI::MetalContext::render_node(CI::TileTask *,CI::parentROI const&,CGRect const&,void const**,__IOSurface **,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)&buf);
    }
    v30 = objc_msgSend((id)*a5, "iosurface");
    v31 = (__IOSurface *)v30;
    if (a6 && !v30)
      v31 = *a6;
    if (v31)
    {
      v73.var0.var0 = (unint64_t)*a5;
      v73.var0.var2.var1 = 0;
      return CI::Context::render_processor_node(this, a2, a3, v31, v73);
    }
    return 0;
  }
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v33 = ci_signpost_log_render();
    v34 = *(int *)(v14 + 36) | (unint64_t)((*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)this + 272))(this) << 32);
    if (v34 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v33))
    {
      LOWORD(buf) = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v33, OS_SIGNPOST_INTERVAL_BEGIN, v34, "render_node_mainProgram", (const char *)&unk_192520C83, (uint8_t *)&buf, 2u);
    }
  }
  v35 = (*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)this + 272))(this);
  TimerBase::TimerBase((uint64_t)&buf, v35, *(_DWORD *)(v14 + 36), (uint64_t)"render_node_mainProgram", 0);
  v36 = CI::ProgramNode::mainProgram((dispatch_queue_t *)v14);
  v38 = v37;
  if ((*((int (**)(dispatch_queue_t))v36->isa + 2))(v36) < 67
    || (*((int (**)(dispatch_queue_t))v36->isa + 2))(v36) >= 70)
  {
    CI::MetalContext::render_node(CI::TileTask *,CI::parentROI const&,CGRect const&,void const**,__IOSurface **,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)&buf);
    return 0;
  }
  CI::MetalContext::render_node(CI::TileTask *,CI::parentROI const&,CGRect const&,void const**,__IOSurface **,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)&buf);
  v74.origin.x = v19;
  v74.origin.y = v20;
  v74.size.width = v21;
  v74.size.height = v22;
  v75 = CGRectIntersection(v74, *a4);
  v65.size.width = v75.size.width;
  v65.size.height = v75.size.height;
  height = v75.size.height;
  v64 = (CGSize)vrndpq_f64(vdivq_f64((float64x2_t)v75.size, vcvtq_f64_u64(*(uint64x2_t *)&v36[10].isa)));
  if (*(_BYTE *)(v14 + 148))
  {
    MidY = CGRectGetMidY(*a4);
    v63.b = 0.0;
    v63.c = 0.0;
    v63.a = 1.0;
    *(_OWORD *)&v63.d = xmmword_192493540;
    v63.ty = MidY + MidY;
    v76.origin.x = v19;
    v76.origin.y = v20;
    v76.size.width = v21;
    v76.size.height = v22;
    v77 = CGRectApplyAffineTransform(v76, &v63);
    v75 = CGRectIntersection(v77, *a4);
    v65.size.width = v41;
    v65.size.height = -v42;
  }
  v43 = v75.origin.y - a4->origin.y;
  v65.origin.x = v75.origin.x - a4->origin.x;
  v65.origin.y = v43;
  CI::MetalContext::bind_arguments(this, (const CI::ProgramNode *)v14, &v66, &v65, (float64x2_t *)&v64, a2);
  if (CI_LIMIT_RENDER())
  {
    __asm { FMOV            V0.2D, #1.0 }
    v64 = _Q0;
  }
  v49 = *(_QWORD *)(v14 + 48);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v49 + 16))(v49) == 51)
  {
    v50 = *(_DWORD *)(v49 + 144);
    v51 = *(_QWORD *)(v49 + 148);
    v52 = *(_DWORD *)(v49 + 156);
    v53 = *(_QWORD *)(v49 + 136) & 0xFFFFFFFF00000000;
    v54 = *(_QWORD *)(v49 + 136);
  }
  else
  {
    v56 = *(_QWORD *)(v14 + 48);
    if (!v56)
      goto LABEL_36;
    while (1)
    {
      v57 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v56 + 16))(v56);
      v58 = *(_QWORD *)v56;
      if (v57 == 47)
        break;
      v56 = (*(uint64_t (**)(uint64_t, _QWORD))(v58 + 48))(v56, 0);
      if (!v56)
        goto LABEL_36;
    }
    if ((*(unsigned int (**)(uint64_t))(v58 + 408))(v56) == 58
      || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v56 + 408))(v56) == 56
      || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v56 + 408))(v56) == 59
      || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v56 + 408))(v56) == 57)
    {
      v59 = *(_DWORD *)(v14 + 36);
      isa = v36[16].isa;
      *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
      *((_QWORD *)&buf + 1) = 3221225472;
      v68 = ___ZNK2CI16MetalMainProgram16getPipelineStateENS_9NodeIndexE_block_invoke;
      v69 = &__block_descriptor_44_e5_v8__0l;
      v70 = v36;
      v71 = v59;
      dispatch_sync(isa, &buf);
      v61 = v36[20].isa;
      if ((-[objc_class threadExecutionWidth](v61, "threadExecutionWidth") & 0xF) == 0)
        -[objc_class threadExecutionWidth](v61, "threadExecutionWidth");
      v50 = 0;
      v51 = 0;
      v52 = 0;
      v53 = 0x1000000000;
      v54 = 16;
    }
    else
    {
LABEL_36:
      v54 = 0;
      v53 = 0;
      v50 = 0;
      v51 = 0;
      v52 = 0;
    }
  }
  v32 = CI::MetalContext::compute_quad((uint64_t)this, *(_DWORD *)(v14 + 36), (uint64_t)v36, &v64.width, (void **)a5, a7, v53 | v54, v50, v51, v52);
  CI::TileTask::incrementCompileWaitTimeForNode(a2, (const CI::ProgramNode *)v14, v38);
  CI::TileTask::setCompileTimeForNode(a2, (const CI::ProgramNode *)v14, *(double *)&v36[3].isa + *(double *)&v36[4].isa);
  v62 = (const void *)*((_QWORD *)this + 223);
  if (v62)
  {
    CFRelease(v62);
    *((_QWORD *)this + 223) = 0;
  }
  return v32;
}

void sub_1923EB770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  CI::MetalContext::render_node(CI::TileTask *,CI::parentROI const&,CGRect const&,void const**,__IOSurface **,unsigned long)::SignpostTimer::~SignpostTimer((TimerBase *)&a29);
  _Unwind_Resume(a1);
}

void CI::MetalContext::render_node(CI::TileTask *,CI::parentROI const&,CGRect const&,void const**,__IOSurface **,unsigned long)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  if (CI_VERBOSE_SIGNPOSTS())
  {
    v2 = ci_signpost_log_render();
    v3 = *((_QWORD *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "processor_syncinputs", (const char *)&unk_192520C83, v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  if (CI_VERBOSE_SIGNPOSTS())
  {
    v2 = ci_signpost_log_render();
    v3 = *((_QWORD *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "render_node_mainProgram", (const char *)&unk_192520C83, v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1923EB82C(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void sub_1923EB8D4(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void CI::MetalContext::bind_arguments(CI::MetalContext *this, const CI::ProgramNode *a2, const CGRect *a3, const CGRect *a4, float64x2_t *a5, CI::TileTask *a6)
{
  NSObject *v10;
  os_signpost_id_t v11;
  uint64_t v12;
  uint64x2_t *v13;
  void *v14;
  int v15;
  NSObject *v16;
  os_signpost_id_t v17;
  uint64_t v18;
  NSObject *v19;
  CGFloat y;
  NSObject *v21;
  unint64_t v22;
  int v23;
  int v24;
  unsigned int **v25;
  int *v26;
  int *v27;
  int v28;
  unsigned int *v29;
  CGFloat v30;
  CGFloat v31;
  float *v32;
  float32x2_t *v33;
  unsigned int v34;
  int32x2_t *v35;
  CGFloat v36;
  CGFloat v37;
  CGFloat v38;
  float *v39;
  unsigned int v40;
  CGFloat v41;
  CGFloat v42;
  CGFloat v43;
  float *v44;
  unsigned int v45;
  float *v46;
  unsigned int v47;
  uint64_t v48;
  float32x4_t *v49;
  uint64_t v50;
  CGAffineTransform v53;
  CGAffineTransform v54;
  CGAffineTransform v55;
  CGRect v56;
  __int128 v57;
  CGRect v58;
  double v59[3];
  _BYTE v60[56];
  CGRect buf;
  __int128 v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v10 = ci_signpost_log_render();
    v11 = *((int *)a2 + 9) | (unint64_t)((*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)this + 272))(this) << 32);
    if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v10))
    {
      LOWORD(buf.origin.x) = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v10, OS_SIGNPOST_INTERVAL_BEGIN, v11, "bind_arguments", (const char *)&unk_192520C83, (uint8_t *)&buf, 2u);
    }
  }
  v12 = (*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)this + 272))(this);
  TimerBase::TimerBase((uint64_t)v60, v12, *((_DWORD *)a2 + 9), (uint64_t)"bind_arguments", 11);
  v13 = (uint64x2_t *)CI::ProgramNode::mainProgram((dispatch_queue_t *)a2);
  if ((*(int (**)(uint64x2_t *))(v13->i64[0] + 16))(v13) >= 67
    && (*(int (**)(uint64x2_t *))(v13->i64[0] + 16))(v13) < 70)
  {
    v14 = CIMetalBufferCreate(*((_QWORD *)this + 240), (void *)objc_msgSend(*((id *)this + 49), "device"), (v13[6].i64[1] + 15) & 0xFFFFFFFFFFFFFFF0);
    *((_QWORD *)this + 223) = v14;
    if (v14)
    {
      v49 = (float32x4_t *)objc_msgSend(v14, "contents");
      if (v49)
      {
        *v49 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)a4->origin), (float64x2_t)a4->size);
        v15 = CI::MainProgram::num_arguments((CI::MainProgram *)v13);
        if (CI_VERBOSE_SIGNPOSTS())
        {
          v16 = ci_signpost_log_render();
          v17 = *((int *)a2 + 9) | (unint64_t)((*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)this + 272))(this) << 32);
          if (v17 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v16))
          {
            LOWORD(buf.origin.x) = 0;
            _os_signpost_emit_with_name_impl(&dword_1921E4000, v16, OS_SIGNPOST_INTERVAL_BEGIN, v17, "render_node_arguments", (const char *)&unk_192520C83, (uint8_t *)&buf, 2u);
          }
        }
        v18 = (*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)this + 272))(this);
        TimerBase::TimerBase((uint64_t)&buf, v18, *((_DWORD *)a2 + 9), (uint64_t)"render_node_arguments", 0);
        dispatch_sync(*((dispatch_queue_t *)a2 + 13), &__block_literal_global_50);
        v50 = *((_QWORD *)a2 + 16);
        if (CI_VERBOSE_SIGNPOSTS())
        {
          v19 = ci_signpost_log_render();
          y = buf.origin.y;
          if ((unint64_t)(*(_QWORD *)&buf.origin.y - 1) <= 0xFFFFFFFFFFFFFFFDLL)
          {
            v21 = v19;
            if (os_signpost_enabled(v19))
            {
              LOWORD(v58.origin.x) = 0;
              _os_signpost_emit_with_name_impl(&dword_1921E4000, v21, OS_SIGNPOST_INTERVAL_END, *(os_signpost_id_t *)&y, "render_node_arguments", (const char *)&unk_192520C83, (uint8_t *)&v58, 2u);
            }
          }
        }
        TimerBase::~TimerBase((TimerBase *)&buf);
        if (v50)
        {
          if (*(_DWORD *)v50 == v15)
          {
            *((_QWORD *)this + 218) = 0;
            if (v15 >= 1)
            {
              v22 = 0;
              v48 = v15;
              while (2)
              {
                v23 = (*(uint64_t (**)(uint64x2_t *, unint64_t))(v13->i64[0] + 40))(v13, v22);
                v24 = v23;
                if (v22 > 9)
                  v25 = (unsigned int **)(*(_QWORD *)(v50 + 16) + 8 * (v22 - 10));
                else
                  v25 = (unsigned int **)(v50 + 8 * v22 + 24);
                v26 = (int *)v13[7].i64[0];
                if (v26 && (uint64_t)v22 < *v26)
                {
                  if (v22 > 9)
                    v27 = (int *)(*((_QWORD *)v26 + 2) + 4 * (v22 - 10));
                  else
                    v27 = &v26[v22 + 6];
                  v28 = *v27;
                }
                else
                {
                  v28 = -1;
                }
                v29 = *v25;
                switch(v23)
                {
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                    if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)v29 + 16))(v29) == 60)
                    {
                      CI::ProgramNode::roiKeys_of_child(a2, *a3, v29[8], &buf);
                      if (CI::Context::bind_sampler(this, (uint64_t)v29, *(uint64_t *)&buf.origin.x, *((unsigned int *)this + 436), v24, a6))++*((_QWORD *)this + 218);
                      if (*(_QWORD *)&buf.origin.x)
                      {
                        buf.origin.y = buf.origin.x;
                        operator delete(*(void **)&buf.origin.x);
                      }
                      goto LABEL_71;
                    }
                    break;
                  case 5:
                  case 6:
                  case 7:
                  case 8:
                  case 9:
                  case 10:
                  case 11:
                    if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)v29 + 16))(v29) == 58)
                      goto LABEL_33;
                    break;
                  case 12:
                  case 13:
                  case 14:
                  case 15:
                  case 16:
                  case 17:
                  case 18:
                    if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)v29 + 16))(v29) == 58)
                    {
                      CI::Vector::copy_to((CI::Vector *)v29, (unsigned __int16 *)((char *)v49 + v28));
                      goto LABEL_71;
                    }
                    break;
                  case 19:
                  case 23:
                    if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)v29 + 16))(v29) == 58)
                    {
                      *(__int32 *)((char *)v49->i32 + v28) = (int)*((float *)v29 + 7);
                      goto LABEL_71;
                    }
                    break;
                  case 20:
                  case 24:
                    if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)v29 + 16))(v29) == 58)
                    {
                      *(int32x2_t *)((char *)v49->f32 + v28) = vcvt_s32_f32(*(float32x2_t *)(v29 + 7));
                      goto LABEL_71;
                    }
                    break;
                  case 21:
                  case 25:
                    if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)v29 + 16))(v29) == 58)
                    {
                      v35 = (int32x2_t *)((char *)v49 + v28);
                      *v35 = vcvt_s32_f32(*(float32x2_t *)(v29 + 7));
                      v35[1].i32[0] = (int)*((float *)v29 + 9);
                      goto LABEL_71;
                    }
                    break;
                  case 22:
                  case 26:
                    if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)v29 + 16))(v29) == 58)
                    {
                      *(int32x4_t *)((char *)v49 + v28) = vcvtq_s32_f32(*(float32x4_t *)(v29 + 7));
                      goto LABEL_71;
                    }
                    break;
                  case 27:
                    if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)v29 + 16))(v29) == 58)
                    {
LABEL_33:
                      CI::Vector::copy_to((float *)v29, (float *)((char *)v49->f32 + v28));
                      goto LABEL_71;
                    }
                    break;
                  case 28:
                  case 29:
                    if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)v29 + 16))(v29) == 57)
                    {
                      CI::Buffer::copy_to((CI::Buffer *)v29, (unsigned __int8 *)v49 + v28);
                      goto LABEL_71;
                    }
                    break;
                  case 37:
                  case 44:
                  case 45:
                    if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)v29 + 16))(v29) == 58)
                    {
                      CI::Vector::affine((CI::Vector *)v29, &v58.origin.x);
                      v30 = a3->origin.x - a4->origin.x;
                      v31 = a3->origin.y - a4->origin.y;
                      v56 = v58;
                      *(double *)&v57 = v59[0] + v58.origin.x * v30 + v58.size.width * v31;
                      *((double *)&v57 + 1) = v59[1] + v58.origin.y * v30 + v58.size.height * v31;
                      if (v24 == 37)
                      {
                        CI::Affine::inverse((CI::Affine *)&v56, &buf.origin.x);
                        v56 = buf;
                        v57 = v62;
                      }
                      *(CGPoint *)&v55.a = v56.origin;
                      *(CGSize *)&v55.c = v56.size;
                      *(_OWORD *)&v55.tx = v57;
                      v32 = (float *)CI::Vector::Vector((CI::Vector *)&buf, &v55);
                      v33 = (float32x2_t *)((char *)v49 + v28);
                      CI::Vector::copy_to(v32, (float *)v33);
                      if (v24 != 44)
                      {
                        v33[6] = vcvt_f32_f64(vcvtq_f64_u64(v13[5]));
                        v33[7] = vcvt_f32_f64(*a5);
                      }
                      *(_QWORD *)&buf.size.width = off_1E2EBBEE8;
                      do
                        v34 = __ldaxr(dword_1ECF873D0);
                      while (__stlxr(v34 - 1, dword_1ECF873D0));
                      goto LABEL_71;
                    }
                    break;
                  case 40:
                    if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)v29 + 16))(v29) == 60)
                    {
                      memset(&v58, 0, sizeof(v58));
                      v58.origin.x = CI::Node::region_of_child(a2, *a3);
                      v58.origin.y = v36;
                      v58.size.width = v37;
                      v58.size.height = v38;
                      CI::TextureSampler::transform((CI::TextureSampler *)v29, this, &v58, (float64x2_t *)&v54);
                      v39 = (float *)CI::Vector::Vector((CI::Vector *)&buf, &v54);
                      CI::Vector::copy_to(v39, (float *)((char *)v49->f32 + v28));
                      *(_QWORD *)&buf.size.width = off_1E2EBBEE8;
                      do
                        v40 = __ldaxr(dword_1ECF873D0);
                      while (__stlxr(v40 - 1, dword_1ECF873D0));
                      goto LABEL_71;
                    }
                    break;
                  case 41:
                    if ((*(unsigned int (**)(unsigned int *))(*(_QWORD *)v29 + 16))(v29) == 60)
                    {
                      memset(&v56, 0, sizeof(v56));
                      v56.origin.x = CI::Node::region_of_child(a2, *a3);
                      v56.origin.y = v41;
                      v56.size.width = v42;
                      v56.size.height = v43;
                      CI::TextureSampler::transform((CI::TextureSampler *)v29, this, &v56, (float64x2_t *)&v58);
                      *(CGPoint *)&v53.a = v58.origin;
                      *(CGSize *)&v53.c = v58.size;
                      *(_OWORD *)&v53.tx = *(_OWORD *)v59;
                      v44 = (float *)CI::Vector::Vector((CI::Vector *)&buf, &v53);
                      CI::Vector::copy_to(v44, (float *)((char *)v49->f32 + v28));
                      *(_QWORD *)&buf.size.width = off_1E2EBBEE8;
                      do
                        v45 = __ldaxr(dword_1ECF873D0);
                      while (__stlxr(v45 - 1, dword_1ECF873D0));
                      v46 = (float *)CI::Vector::Vector((CI::Vector *)&buf, *(CGRect *)(v29 + 22));
                      CI::Vector::copy_to(v46, (float *)((char *)v49[3].f32 + v28));
                      *(_QWORD *)&buf.size.width = off_1E2EBBEE8;
                      do
                        v47 = __ldaxr(dword_1ECF873D0);
                      while (__stlxr(v47 - 1, dword_1ECF873D0));
                      goto LABEL_71;
                    }
                    break;
                  case 42:
                  case 43:
                  case 46:
                  case 47:
                    goto LABEL_71;
                  default:
                    x_log("Unhandled type: %d\n", v23);
LABEL_71:
                    if (++v22 == v48)
                      break;
                    continue;
                }
                break;
              }
            }
          }
        }
      }
    }
  }
  CI::MetalContext::bind_arguments(CI::ProgramNode const*,CGRect const&,CGRect const&,CGSize const&,CI::TileTask *)::SignpostTimer::~SignpostTimer((TimerBase *)v60);
}

void sub_1923EC11C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
  uint64_t v46;
  unsigned int v48;

  *(_QWORD *)(v46 - 224) = off_1E2EBBEE8;
  do
    v48 = __ldaxr(dword_1ECF873D0);
  while (__stlxr(v48 - 1, dword_1ECF873D0));
  CI::MetalContext::bind_arguments(CI::ProgramNode const*,CGRect const&,CGRect const&,CGSize const&,CI::TileTask *)::SignpostTimer::~SignpostTimer((TimerBase *)&a46);
  _Unwind_Resume(a1);
}

void CI::MetalContext::render_root_node(uint64_t a1, CI::TileTask *a2, CI::parentROI *this, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  CGFloat v11;
  CGFloat v12;
  CGFloat v13;
  NSObject *v14;
  os_signpost_id_t v15;
  const CI::ProgramNode *v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL4 v19;
  int v20;
  uint64_t v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  CFTypeRef v25;
  BOOL v26;
  const char *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD v32[8];
  BOOL v33;
  _QWORD v34[5];
  CGRect v35;
  _QWORD v36[6];
  CGRect v37;
  uint8_t buf[4];
  int v39;
  __int16 v40;
  const char *v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)this;
  v37.origin.x = CI::parentROI::roi(this);
  v37.origin.y = v11;
  v37.size.width = v12;
  v37.size.height = v13;
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v14 = ci_signpost_log_render();
    v15 = *(int *)(v10 + 36) | (unint64_t)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1) << 32);
    if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v14))
    {
      *(_DWORD *)buf = 68289026;
      v39 = 256;
      v40 = 2082;
      v41 = CI::Context::programName((dispatch_queue_t *)v10, v16);
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v14, OS_SIGNPOST_INTERVAL_BEGIN, v15, "render_node", "%{public}.256s", buf, 0x12u);
    }
  }
  v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
  TimerBase::TimerBase((uint64_t)buf, v17, *(_DWORD *)(v10 + 36), (uint64_t)"render_node", 0);
  *(_QWORD *)(a1 + 1800) = *(_QWORD *)(a1 + 1792);
  v18 = *(_QWORD *)(v10 + 48);
  v19 = (*(int (**)(uint64_t))(*(_QWORD *)v18 + 16))(v18) >= 41
     && (*(int (**)(uint64_t))(*(_QWORD *)v18 + 16))(v18) < 43;
  v20 = CI_ENABLE_METAL_DEBUG();
  v21 = MEMORY[0x1E0C809B0];
  if (!v20
    || *(_QWORD *)(a1 + 1808)
    || (v31 = *(_QWORD *)(v10 + 48), (*(int (**)(uint64_t))(*(_QWORD *)v31 + 16))(v31) >= 41)
    && (*(int (**)(uint64_t))(*(_QWORD *)v31 + 16))(v31) < 43)
  {
    v22 = 0;
  }
  else
  {
    v36[0] = v21;
    v36[1] = 3221225472;
    v36[2] = ___ZN2CI12MetalContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke;
    v36[3] = &__block_descriptor_48_e11_v24__0Q8Q16l;
    v36[4] = a2;
    v36[5] = v10;
    v22 = v36;
  }
  v23 = *(void **)(a1 + 1808);
  if (!v23)
    v23 = CIMetalCommandBufferCreate(*(_QWORD *)(a1 + 1920), *(void **)(a1 + 392), !v19, v22);
  *(_QWORD *)(a1 + 1792) = v23;
  v24 = *(_QWORD *)(a1 + 1888);
  if (v24)
  {
    v25 = (CFTypeRef)(*(uint64_t (**)(void))(v24 + 16))();
    if (v25)
      v25 = CFRetain(v25);
    *(_QWORD *)(a1 + 1864) = v25;
  }
  v35.origin.x = 0.0;
  v35.origin.y = 0.0;
  v35.size = *(CGSize *)(a1 + 1832);
  *(_BYTE *)(a1 + 1896) = CI::MetalContext::render_node((CI::MetalContext *)a1, a2, this, &v35, (const void **)(a1 + 1864), 0, 2);
  if (*(_QWORD *)(a1 + 1880))
    objc_msgSend(*(id *)(a1 + 1792), "presentDrawable:");
  v26 = *(_QWORD *)(a1 + 1792) == *(_QWORD *)(a1 + 1808);
  v27 = CI::ProgramNode::program_name((CI::ProgramNode *)v10);
  CI::TileTask::addROIForNode(a2, (CI::ProgramNode *)v10, &v37);
  if (a2)
    CI::Object::ref((uint64_t)a2);
  if (*(_QWORD *)(a1 + 1808))
  {
    (*(void (**)(uint64_t))(a4 + 16))(a4);
  }
  else
  {
    v28 = *(void **)(a1 + 1792);
    v34[0] = v21;
    v34[1] = 3221225472;
    v34[2] = ___ZN2CI12MetalContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke_2;
    v34[3] = &unk_1E2EC49E8;
    v34[4] = a4;
    objc_msgSend(v28, "addScheduledHandler:", v34);
  }
  v29 = *(void **)(a1 + 1792);
  v32[0] = v21;
  v32[1] = 3221225472;
  v32[2] = ___ZN2CI12MetalContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke_3;
  v32[3] = &unk_1E2EC65B8;
  v33 = v26;
  v32[6] = v27;
  v32[7] = v10;
  v32[4] = a5;
  v32[5] = a2;
  CIMetalCommandBufferAddCompletionHandler(v29, (uint64_t)v32);
  if (!*(_BYTE *)(a1 + 1904) && !*(_QWORD *)(a1 + 1856))
    CIMetalCommandBufferSynchronizeTexture(*(_QWORD *)(a1 + 1792), *(_QWORD *)(a1 + 1864));
  v30 = *(_QWORD *)(a1 + 1792);
  if (v30 != *(_QWORD *)(a1 + 1808))
    CIMetalCommandBufferCommit(v30);
  CI::MetalContext::render_root_node(CI::TileTask *,CI::parentROI const&,void({block_pointer})(void),void({block_pointer})(void))::SignpostTimer::~SignpostTimer((TimerBase *)buf);
}

void sub_1923EC638(_Unwind_Exception *a1)
{
  uint64_t v1;

  CI::MetalContext::render_root_node(CI::TileTask *,CI::parentROI const&,void({block_pointer})(void),void({block_pointer})(void))::SignpostTimer::~SignpostTimer((TimerBase *)(v1 - 160));
  _Unwind_Resume(a1);
}

void ___ZN2CI12MetalContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CI::TileTask::incrementCyclesForNode(*(CI::TileTask **)(a1 + 32), *(const CI::ProgramNode **)(a1 + 40), a2);
  CI::TileTask::incrementNanoSecForNode(*(CI::TileTask **)(a1 + 32), *(const CI::ProgramNode **)(a1 + 40), a3);
}

uint64_t ___ZN2CI12MetalContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t ___ZN2CI12MetalContext16render_root_nodeEPNS_8TileTaskERKNS_9parentROIEU13block_pointerFvvES7__block_invoke_3(uint64_t a1, void *a2)
{
  CI::TileTask *v4;
  id v5;
  double v6;
  uint64_t v7;
  CI::Object *v8;

  if (objc_msgSend(a2, "status") == 5)
  {
    v4 = *(CI::TileTask **)(a1 + 40);
    v5 = (id)objc_msgSend(a2, "error");
  }
  else
  {
    if (!internalError(a2))
      goto LABEL_6;
    v4 = *(CI::TileTask **)(a1 + 40);
    v5 = internalError(a2);
  }
  CI::TileTask::setCommandBufferError(v4, v5);
LABEL_6:
  if ((CI_PRINT_TIME() & 0x100) != 0)
  {
    if (*(_BYTE *)(a1 + 64))
    {
      CIMetalCommandBufferGetGPUTime(a2);
      x_log("CI_PRINT_TIME [GPU] command buffer (%p) = %.1f ms\n");
    }
    else
    {
      CIMetalCommandBufferGetGPUTime(a2);
      x_log("CI_PRINT_TIME [GPU] root program (%s) = %.1f ms\n");
    }
  }
  CIMetalCommandBufferGetGPUTime(a2);
  CI::TileTask::incrementTimeForNode(*(CI::TileTask **)(a1 + 40), *(const CI::ProgramNode **)(a1 + 56), v6);
  v7 = *(_QWORD *)(a1 + 40);
  *(CFAbsoluteTime *)(v7 + 40) = CFAbsoluteTimeGetCurrent();
  v8 = *(CI::Object **)(a1 + 40);
  if (v8)
    CI::Object::unref(v8);
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void CI::MetalContext::render_root_node(CI::TileTask *,CI::parentROI const&,void({block_pointer})(void),void({block_pointer})(void))::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  if (CI_VERBOSE_SIGNPOSTS())
  {
    v2 = ci_signpost_log_render();
    v3 = *((_QWORD *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "render_node", (const char *)&unk_192520C83, v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1923EC844(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void CI::MetalContext::render_intermediate_node(CI::MetalContext *a1, CI::TileTask *a2, CI::parentROI *this, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  NSObject *v16;
  os_signpost_id_t v17;
  const CI::ProgramNode *v18;
  uint64_t v19;
  uint64_t v20;
  _BOOL4 v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  uint64_t v25;
  void *v26;
  void *v27;
  void *v28;
  const CGRect *v29;
  uint64_t v30;
  BOOL v31;
  const char *v32;
  _QWORD *v33;
  void **v34;
  char *v35;
  unint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  char *v46;
  char *v47;
  void *v48;
  uint64_t v49;
  const char *v50;
  _QWORD v51[10];
  BOOL v52;
  __IOSurface *v53;
  _QWORD v54[6];
  CGRect v55;
  void *v56[2];
  uint8_t buf[4];
  int v58;
  __int16 v59;
  const char *v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v12 = *(_QWORD *)this;
  v55.origin.x = CI::parentROI::roi(this);
  v55.origin.y = v13;
  v55.size.width = v14;
  v55.size.height = v15;
  if (CI_VERBOSE_SIGNPOSTS())
  {
    v16 = ci_signpost_log_render();
    v17 = *(int *)(v12 + 36) | (unint64_t)((*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)a1 + 272))(a1) << 32);
    if (v17 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v16))
    {
      *(_DWORD *)buf = 68289026;
      v58 = 256;
      v59 = 2082;
      v60 = CI::Context::programName((dispatch_queue_t *)v12, v18);
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v16, OS_SIGNPOST_INTERVAL_BEGIN, v17, "render_node", "%{public}.256s", buf, 0x12u);
    }
  }
  v19 = (*(uint64_t (**)(CI::MetalContext *))(*(_QWORD *)a1 + 272))(a1);
  TimerBase::TimerBase((uint64_t)buf, v19, *(_DWORD *)(v12 + 36), (uint64_t)"render_node", 0);
  if (a4)
  {
    *((_QWORD *)a1 + 225) = *((_QWORD *)a1 + 224);
    v20 = *(_QWORD *)(v12 + 48);
    v21 = (*(int (**)(uint64_t))(*(_QWORD *)v20 + 16))(v20) >= 41
       && (*(int (**)(uint64_t))(*(_QWORD *)v20 + 16))(v20) < 43;
    if (!CI_ENABLE_METAL_DEBUG()
      || *((_QWORD *)a1 + 226)
      || (v25 = *(_QWORD *)(v12 + 48), (*(int (**)(uint64_t))(*(_QWORD *)v25 + 16))(v25) >= 41)
      && (*(int (**)(uint64_t))(*(_QWORD *)v25 + 16))(v25) < 43)
    {
      v22 = 0;
    }
    else
    {
      v54[0] = MEMORY[0x1E0C809B0];
      v54[1] = 3221225472;
      v54[2] = ___ZN2CI12MetalContext24render_intermediate_nodeEPNS_8TileTaskERKNS_9parentROIEPNS_14intermediate_tEbU13block_pointerFvvE_block_invoke;
      v54[3] = &__block_descriptor_48_e11_v24__0Q8Q16l;
      v54[4] = a2;
      v54[5] = v12;
      v22 = v54;
    }
    v23 = (void *)*((_QWORD *)a1 + 226);
    if (a5)
    {
      if (v23)
        v24 = (void *)objc_msgSend(v23, "commandQueue");
      else
        v24 = (void *)*((_QWORD *)a1 + 49);
      v23 = CIMetalCommandBufferCreate(*((_QWORD *)a1 + 240), v24, !v21, v22);
    }
    else if (!v23)
    {
      v23 = CIMetalCommandBufferCreate(*((_QWORD *)a1 + 240), *((void **)a1 + 49), !v21, v22);
    }
    *((_QWORD *)a1 + 224) = v23;
    v26 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 24))(a4);
    v28 = v27;
    v53 = (__IOSurface *)(**(uint64_t (***)(uint64_t))a4)(a4);
    v56[0] = v26;
    v56[1] = v28;
    v29 = (const CGRect *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 32))(a4);
    if (v28)
      v30 = 2;
    else
      v30 = 1;
    CI::MetalContext::render_node(a1, a2, this, v29, (const void **)v56, &v53, v30);
    v31 = *((_QWORD *)a1 + 224) == *((_QWORD *)a1 + 226);
    v32 = CI::ProgramNode::program_name((CI::ProgramNode *)v12);
    CI::TileTask::addROIForNode(a2, (CI::ProgramNode *)v12, &v55);
    if (a2)
      CI::Object::ref((uint64_t)a2);
    v50 = v32;
    v33 = (_QWORD *)operator new();
    v34 = (void **)v33;
    *v33 = 0;
    v33[1] = 0;
    v33[2] = 0;
    if (*((_QWORD *)a1 + 218))
    {
      v35 = 0;
      v36 = 0;
      v37 = v33 + 2;
      do
      {
        v38 = *((_QWORD *)a1 + v36 + 154);
        if ((unint64_t)v35 >= *v37)
        {
          v39 = (v35 - (_BYTE *)*v34) >> 4;
          if ((unint64_t)(v39 + 1) >> 60)
            abort();
          v40 = *v37 - (_QWORD)*v34;
          v41 = v40 >> 3;
          if (v40 >> 3 <= (unint64_t)(v39 + 1))
            v41 = v39 + 1;
          if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF0)
            v42 = 0xFFFFFFFFFFFFFFFLL;
          else
            v42 = v41;
          if (v42)
            v43 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::Perspective::Line>>((uint64_t)(v34 + 2), v42);
          else
            v43 = 0;
          v44 = &v43[16 * v39];
          *(_QWORD *)v44 = v38;
          *((_QWORD *)v44 + 1) = 0;
          v46 = (char *)*v34;
          v45 = (char *)v34[1];
          v47 = v44;
          if (v45 != *v34)
          {
            do
            {
              *((_OWORD *)v47 - 1) = *((_OWORD *)v45 - 1);
              v47 -= 16;
              v45 -= 16;
            }
            while (v45 != v46);
            v45 = (char *)*v34;
          }
          v35 = v44 + 16;
          *v34 = v47;
          v34[1] = v44 + 16;
          v34[2] = &v43[16 * v42];
          if (v45)
            operator delete(v45);
        }
        else
        {
          *(_QWORD *)v35 = v38;
          *((_QWORD *)v35 + 1) = 0;
          v35 += 16;
        }
        v34[1] = v35;
        ++v36;
      }
      while (*((_QWORD *)a1 + 218) > v36);
    }
    v48 = (void *)*((_QWORD *)a1 + 224);
    v51[0] = MEMORY[0x1E0C809B0];
    v51[1] = 3221225472;
    v51[2] = ___ZN2CI12MetalContext24render_intermediate_nodeEPNS_8TileTaskERKNS_9parentROIEPNS_14intermediate_tEbU13block_pointerFvvE_block_invoke_2;
    v51[3] = &unk_1E2EC65E0;
    v52 = v31;
    v51[6] = a2;
    v51[7] = v50;
    v51[8] = v12;
    v51[9] = v34;
    v51[4] = a6;
    v51[5] = a1;
    CIMetalCommandBufferAddCompletionHandler(v48, (uint64_t)v51);
    v49 = *((_QWORD *)a1 + 224);
    if (v49 != *((_QWORD *)a1 + 226))
      CIMetalCommandBufferCommit(v49);
  }
  CI::MetalContext::render_intermediate_node(CI::TileTask *,CI::parentROI const&,CI::intermediate_t *,BOOL,void({block_pointer})(void))::SignpostTimer::~SignpostTimer((TimerBase *)buf);
}

void sub_1923ECCFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  CI::MetalContext::render_intermediate_node(CI::TileTask *,CI::parentROI const&,CI::intermediate_t *,BOOL,void({block_pointer})(void))::SignpostTimer::~SignpostTimer((TimerBase *)(v1 - 160));
  _Unwind_Resume(a1);
}

void ___ZN2CI12MetalContext24render_intermediate_nodeEPNS_8TileTaskERKNS_9parentROIEPNS_14intermediate_tEbU13block_pointerFvvE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CI::TileTask::incrementCyclesForNode(*(CI::TileTask **)(a1 + 32), *(const CI::ProgramNode **)(a1 + 40), a2);
  CI::TileTask::incrementNanoSecForNode(*(CI::TileTask **)(a1 + 32), *(const CI::ProgramNode **)(a1 + 40), a3);
}

uint64_t ___ZN2CI12MetalContext24render_intermediate_nodeEPNS_8TileTaskERKNS_9parentROIEPNS_14intermediate_tEbU13block_pointerFvvE_block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v4;
  CI::TileTask *v5;
  id v6;
  const char *v7;
  double v8;
  double v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  CI::Object *v13;

  v4 = *(_QWORD *)(a1 + 40);
  if (objc_msgSend(a2, "status") == 5)
  {
    v5 = *(CI::TileTask **)(a1 + 48);
    v6 = (id)objc_msgSend(a2, "error");
  }
  else
  {
    if (!internalError(a2))
      goto LABEL_6;
    v5 = *(CI::TileTask **)(a1 + 48);
    v6 = internalError(a2);
  }
  CI::TileTask::setCommandBufferError(v5, v6);
LABEL_6:
  if (!*(_BYTE *)(a1 + 80))
  {
    if ((CI_PRINT_TIME() & 0x100) != 0)
    {
      v7 = *(const char **)(a1 + 56);
      CIMetalCommandBufferGetGPUTime(a2);
      x_log("CI_PRINT_TIME [GPU] intermediate program (%s) = %.1f ms\n", v7, v8 * 1000.0);
    }
    CIMetalCommandBufferGetGPUTime(a2);
    CI::TileTask::incrementTimeForNode(*(CI::TileTask **)(a1 + 48), *(const CI::ProgramNode **)(a1 + 64), v9);
  }
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 112))(v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 80))(v10, *(_QWORD *)(a1 + 72));
  v11 = *(_QWORD *)(a1 + 72);
  if (v11)
  {
    v12 = *(void **)v11;
    if (*(_QWORD *)v11)
    {
      *(_QWORD *)(v11 + 8) = v12;
      operator delete(v12);
    }
    MEMORY[0x194025AAC](v11, 0x20C40960023A9);
  }
  v13 = *(CI::Object **)(a1 + 48);
  if (v13)
    CI::Object::unref(v13);
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void CI::MetalContext::render_intermediate_node(CI::TileTask *,CI::parentROI const&,CI::intermediate_t *,BOOL,void({block_pointer})(void))::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  if (CI_VERBOSE_SIGNPOSTS())
  {
    v2 = ci_signpost_log_render();
    v3 = *((_QWORD *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "render_node", (const char *)&unk_192520C83, v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1923ECF30(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

void CI::MetalContext::readback_bitmap(uint64_t a1, uint64_t *a2)
{
  NSObject *v4;
  os_signpost_id_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = ci_signpost_log_render();
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1) << 32;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    v6 = a2[10];
    v7 = a2[11];
    v10 = 134218240;
    v11 = v6;
    v12 = 2048;
    v13 = v7;
    _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v5, "readback_bitmap", "[%zu %zu]", (uint8_t *)&v10, 0x16u);
  }
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
  TimerBase::TimerBase((uint64_t)&v10, v8, 0, (uint64_t)"readback_bitmap", 7);
  v9 = *(void **)(a1 + 1792);
  if (v9 != *(void **)(a1 + 1808))
  {
    CIMetalCommandBufferWaitUntilCompleted(v9);
    if (a2)
    {
      if (!*(_QWORD *)(a1 + 1856) && *(_BYTE *)(a1 + 1896))
        CIMetalTextureGetBytes(*(void **)(a1 + 1864), a2[9], a2[12]);
    }
  }
  CI::MetalContext::readback_bitmap(CI::Bitmap *,CI::output_swizzle_info)::SignpostTimer::~SignpostTimer((TimerBase *)&v10);
}

void sub_1923ED094(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CI::MetalContext::readback_bitmap(CI::Bitmap *,CI::output_swizzle_info)::SignpostTimer::~SignpostTimer((TimerBase *)&a9);
  _Unwind_Resume(a1);
}

void CI::MetalContext::readback_bitmap(CI::Bitmap *,CI::output_swizzle_info)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  v2 = ci_signpost_log_render();
  v3 = *((_QWORD *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "readback_bitmap", (const char *)&unk_192520C83, v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1923ED138(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

BOOL CI::MetalContext::formatIsReadable(id *this, unsigned int a2)
{
  uint64_t v4;
  int v5;

  v4 = a2;
  if (a2 > 0x2FF || (v5 = *((unsigned __int8 *)this + a2 + 460), !*((_BYTE *)this + a2 + 460)))
  {
    objc_msgSend(this[49], "device");
    MTLPixelFormatGetInfoForDevice();
    v5 = 0;
    if (a2 <= 0x2FF)
      *((_BYTE *)this + v4 + 460) = 0;
  }
  return v5 == 114 || v5 == 119;
}

BOOL CI::MetalContext::formatIsWritable(id *this, unsigned int a2)
{
  uint64_t v4;
  int v5;

  v4 = a2;
  if (a2 > 0x2FF || (v5 = *((unsigned __int8 *)this + a2 + 460), !*((_BYTE *)this + a2 + 460)))
  {
    objc_msgSend(this[49], "device");
    MTLPixelFormatGetInfoForDevice();
    v5 = 0;
    if (a2 <= 0x2FF)
      *((_BYTE *)this + v4 + 460) = 0;
  }
  return v5 == 119;
}

uint64_t CI::MetalContext::format_is_directly_supported_for_input(id *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  unsigned int v7;
  unsigned int v8;

  if (CI::format_is_ycc_biplanar(a2))
  {
    v4 = CI::format_of_plane(a2, 0);
    v5 = CI::format_of_plane(a2, 1);
    LODWORD(v4) = (*((uint64_t (**)(id *, uint64_t))*a1 + 53))(a1, v4);
    return v4 & (*((unsigned int (**)(id *, uint64_t))*a1 + 53))(a1, v5);
  }
  result = 1;
  if (a2 > 1796)
  {
    if (a2 <= 2308)
    {
      if ((a2 - 1797) <= 3 && a2 != 1799)
        return result;
      v7 = a2 - 2053;
    }
    else
    {
      if (a2 > 2566)
      {
        if (a2 > 3078)
        {
          if (a2 != 3081 && a2 != 3079)
            return 0;
        }
        else if (a2 != 2567 && a2 != 2569)
        {
          return 0;
        }
        goto LABEL_28;
      }
      v7 = a2 - 2309;
    }
    if (v7 > 3 || v7 == 2)
      return 0;
    return result;
  }
  if (a2 > 531)
  {
    if ((a2 - 532) < 2)
      return result;
    if ((a2 - 784) >= 2 && (a2 - 1285) >= 2)
      return 0;
LABEL_28:
    v8 = CIMetalFormatForFormat(a2, 0);
    return CI::MetalContext::formatIsReadable(a1, v8);
  }
  if ((a2 - 257) > 0x14 || ((1 << (a2 - 1)) & 0x1802B1) == 0)
    return 0;
  return result;
}

uint64_t CI::MetalContext::format_is_directly_supported_for_output(id *a1, int a2)
{
  uint64_t result;
  int v4;
  unsigned int v5;

  result = 1;
  if (a2 <= 1553)
  {
    if (a2 <= 783)
    {
      if ((a2 - 261) > 0x11)
        goto LABEL_7;
      v4 = 1 << (a2 - 5);
      if ((v4 & 0x2B) != 0)
        return result;
      if ((v4 & 0x22000) == 0)
      {
LABEL_7:
        if (a2 != 530 && a2 != 534)
          return 0;
      }
      return CI::MetalContext::use_imageblocks_for_format((uint64_t)a1, a2);
    }
    if (a2 > 1041)
    {
      if ((a2 - 1285) >= 2)
      {
        if (a2 == 1042 || a2 == 1298)
          return CI::MetalContext::use_imageblocks_for_format((uint64_t)a1, a2);
        return 0;
      }
LABEL_35:
      v5 = CIMetalFormatForFormat(a2, 0);
      return CI::MetalContext::formatIsWritable(a1, v5);
    }
    if ((a2 - 784) < 2)
      goto LABEL_35;
    if (a2 == 786)
      return CI::MetalContext::use_imageblocks_for_format((uint64_t)a1, a2);
    return 0;
  }
  if (a2 > 2308)
  {
    if (a2 > 2566)
    {
      if (a2 > 3078)
      {
        if (a2 != 3081 && a2 != 3079)
          return 0;
      }
      else if (a2 != 2567 && a2 != 2569)
      {
        return 0;
      }
      goto LABEL_35;
    }
    if ((a2 - 2309) > 3 || a2 == 2311)
      return 0;
  }
  else if (((a2 - 1797) > 3 || a2 == 1799) && ((a2 - 2053) > 3 || a2 == 2055))
  {
    if (a2 == 1554)
      return CI::MetalContext::use_imageblocks_for_format((uint64_t)a1, a2);
    return 0;
  }
  return result;
}

uint64_t CI::MetalContext::bind_cgimage(_QWORD ***a1, CGImage *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void *v10;

  if (!a2)
    return 0;
  v10 = CI::MetalTextureManager::texture_for_CGImage(a1[227], a2, a3);
  return ((uint64_t (*)(_QWORD ***, void *, uint64_t, uint64_t, uint64_t))(*a1)[11])(a1, v10, a4, a5, a6);
}

uint64_t CI::MetalContext::bind_surface(_QWORD **a1, __IOSurface *a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  void *v12;

  if (!a2)
    return 0;
  v12 = CI::MetalTextureManager::texture_for_IOSurface(a1[227], a2, a8, a3);
  return ((uint64_t (*)(_QWORD **, void *, uint64_t, uint64_t, uint64_t))(*a1)[11])(a1, v12, a5, a6, a7);
}

uint64_t CI::MetalContext::bind_texture(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t result;
  uint64_t v7;

  if (!a2)
    return 0;
  result = 0;
  if (a3 <= 1 && a3 != -1)
  {
    result = 0;
    if (a4 <= 1 && a4 != -1)
    {
      v7 = a1 + 8 * a5;
      *(_QWORD *)(v7 + 1232) = a2;
      *(_QWORD *)(v7 + 1488) = *(_QWORD *)(a1 + 16 * a3 + 8 * a4 + 1752);
      return 1;
    }
  }
  return result;
}

uint64_t CI::MetalContext::bind_intermediate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, a4, a5, a6);
}

void CI::MetalContext::bind_arguments(CI::ProgramNode const*,CGRect const&,CGRect const&,CGSize const&,CI::TileTask *)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  if (CI_VERBOSE_SIGNPOSTS())
  {
    v2 = ci_signpost_log_render();
    v3 = *((_QWORD *)a1 + 1);
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v4 = v2;
      if (os_signpost_enabled(v2))
      {
        *(_WORD *)v5 = 0;
        _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "bind_arguments", (const char *)&unk_192520C83, v5, 2u);
      }
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1923ED754(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

BOOL CI::MetalContext::supports_sRGB_texture_for_format(id *this, int a2, int a3)
{
  int v3;
  unsigned int v5;

  v3 = a2 - 261;
  if ((a2 - 261) > 5 || ((0x2Bu >> v3) & 1) == 0)
    return 0;
  v5 = dword_19249AFC8[v3];
  if (a3 != 1)
  {
    if (a3 == 2 || a3 == 3 && CI::MetalContext::formatIsReadable(this, dword_19249AFC8[v3]))
      return CI::MetalContext::formatIsWritable(this, v5);
    return 0;
  }
  return CI::MetalContext::formatIsReadable(this, dword_19249AFC8[v3]);
}

BOOL CI::MetalContext::blitSurface(uint64_t a1, __IOSurface *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  double *v18;
  double v19;
  double v20;
  int v21;
  int v22;
  unint64_t v23;
  unint64_t v24;
  double *v25;
  double v26;
  double v27;
  double v28;
  double v29;
  uint64_t v30;
  _QWORD v32[6];

  v11 = CIMetalFormatForFormat(*(_DWORD *)a6, *(unsigned __int8 *)(a6 + 4));
  v12 = CIMetalTextureCreateFromIOSurface(*(_QWORD *)(a1 + 1920), (void *)objc_msgSend(*(id *)(a1 + 392), "device"), a2, 0, v11, 2);
  if (v12)
  {
    v13 = CIMetalCommandBufferCreate(*(_QWORD *)(a1 + 1920), *(void **)(a1 + 392), 0, 0);
    v14 = *(_DWORD *)a3;
    v15 = *(_DWORD *)(a3 + 4);
    v17 = *(_QWORD *)(a3 + 8);
    v16 = *(_QWORD *)(a3 + 16);
    if (*(_DWORD *)a3 == -2147483647)
    {
      if (v15 == -2147483647 && v17 == 0xFFFFFFFFLL && v16 == 0xFFFFFFFFLL)
      {
        v18 = (double *)MEMORY[0x1E0C9D5E0];
        goto LABEL_12;
      }
    }
    else if (v14 == 0x7FFFFFFF && v15 == 0x7FFFFFFF && !v17 && !v16)
    {
      v18 = (double *)MEMORY[0x1E0C9D628];
LABEL_12:
      v19 = *v18;
      v20 = v18[1];
      goto LABEL_14;
    }
    v19 = (double)v14;
    v20 = (double)v15;
LABEL_14:
    v21 = *(_DWORD *)a5;
    v22 = *(_DWORD *)(a5 + 4);
    v23 = *(_QWORD *)(a5 + 8);
    v24 = *(_QWORD *)(a5 + 16);
    if (*(_DWORD *)a5 == -2147483647)
    {
      if (v22 == -2147483647 && v23 == 0xFFFFFFFF && v24 == 0xFFFFFFFF)
      {
        v25 = (double *)MEMORY[0x1E0C9D5E0];
        goto LABEL_24;
      }
    }
    else if (v21 == 0x7FFFFFFF && v22 == 0x7FFFFFFF && !v23 && !v24)
    {
      v25 = (double *)MEMORY[0x1E0C9D628];
LABEL_24:
      v26 = *v25;
      v27 = v25[1];
      v28 = v25[2];
      v29 = v25[3];
LABEL_26:
      v30 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 24))(a4);
      CIMetalCommandBufferCopyTexture(v13, (uint64_t)v12, v30, v19, v20, v26, v27, v28, v29);
      CFRelease(v12);
      v32[0] = MEMORY[0x1E0C809B0];
      v32[1] = 3221225472;
      v32[2] = ___ZNK2CI12MetalContext11blitSurfaceEP11__IOSurface5IRectPNS_14intermediate_tES3_RKNS_17TextureDescriptorE_block_invoke;
      v32[3] = &__block_descriptor_48_e28_v16__0___MTLCommandBuffer__8l;
      v32[4] = a1;
      v32[5] = a4;
      CIMetalCommandBufferAddCompletionHandler(v13, (uint64_t)v32);
      CIMetalCommandBufferCommit(v13);
      return v12 != 0;
    }
    v26 = (double)v21;
    v27 = (double)v22;
    v28 = (double)v23;
    v29 = (double)v24;
    goto LABEL_26;
  }
  return v12 != 0;
}

void ___ZNK2CI12MetalContext11blitSurfaceEP11__IOSurface5IRectPNS_14intermediate_tES3_RKNS_17TextureDescriptorE_block_invoke(uint64_t a1)
{
  uint64_t v2;

  v2 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 112))(*(_QWORD *)(a1 + 32));
  CI::TextureManager::complete_intermediate(v2, 52, *(_QWORD *)(a1 + 40));
}

uint64_t CI::MetalMainProgram::type(CI::MetalMainProgram *this)
{
  return 67;
}

const char *CI::MetalMainProgram::get_type_name(CI::MetalMainProgram *this)
{
  if (*((_BYTE *)this + 168))
    return "cikl-from_archive";
  else
    return "cikl";
}

uint64_t `non-virtual thunk to'CI::MetalMainProgram::type(CI::MetalMainProgram *this)
{
  return 67;
}

uint64_t CI::MetalContext::type(CI::MetalContext *this)
{
  return 77;
}

uint64_t CI::MetalContext::bind_texture()
{
  return 0;
}

uint64_t CI::MetalContext::texture_manager(CI::MetalContext *this)
{
  return *((_QWORD *)this + 227);
}

uint64_t CI::MetalContext::setLossyIntermediates(uint64_t this, char a2)
{
  *(_BYTE *)(this + 1228) = a2;
  return this;
}

uint64_t CI::MetalContext::lossyIntermediates(CI::MetalContext *this)
{
  return *((unsigned __int8 *)this + 1228);
}

uint64_t CI::MetalContext::is_cpu(CI::MetalContext *this)
{
  return 0;
}

uint64_t CI::MetalContext::set_user_destination(CI::MetalContext *this)
{
  return 0;
}

uint64_t CI::MetalContext::destination_descriptor@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  *a2 = *(_QWORD *)(this + 1848);
  return this;
}

uint64_t CI::MetalContext::max_texture_size(CI::MetalContext *this)
{
  return *((_QWORD *)this + 50);
}

uint64_t CI::MetalContext::max_input_image_size(CI::MetalContext *this)
{
  return *((_QWORD *)this + 50);
}

uint64_t CI::MetalContext::max_output_image_size(CI::MetalContext *this)
{
  return *((_QWORD *)this + 50);
}

uint64_t CI::MetalContext::max_texture_image_units(CI::MetalContext *this)
{
  return *((_QWORD *)this + 51);
}

uint64_t CI::MetalContext::max_fragment_uniform_vectors(CI::MetalContext *this)
{
  return *((_QWORD *)this + 52);
}

uint64_t CI::MetalContext::max_fragment_uniform_size(CI::MetalContext *this)
{
  return *((_QWORD *)this + 52);
}

uint64_t CI::MetalContext::max_render_load_bytes(CI::MetalContext *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 45);
  if (v1)
    return v1 << 20;
  else
    return 0x8000000;
}

uint64_t CI::MetalContext::max_device_memory(CI::MetalContext *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 56);
  if (!result)
    return *((_QWORD *)this + 55);
  return result;
}

uint64_t CI::MetalContext::bitmap_destination_rowbytes_alignment()
{
  return 64;
}

uint64_t CI::MetalContext::surface_rowbytes_alignment_for_input(uint64_t a1)
{
  return *(_QWORD *)(a1 + 424);
}

uint64_t CI::MetalContext::surface_rowbytes_alignment_for_output(uint64_t a1)
{
  return *(_QWORD *)(a1 + 432);
}

uint64_t CI::MetalContext::supportsDeferredCGImage(CI::MetalContext *this)
{
  return 1;
}

BOOL CI::MetalContext::supports_edge_mode(uint64_t a1, unsigned int a2)
{
  return a2 < 2;
}

uint64_t CI::MetalContext::supports_sample_mode(uint64_t a1, int a2, int a3)
{
  if (a2 == 1)
    return CI::format_is_full_float(a3) ^ 1;
  else
    return 1;
}

uint64_t CI::MetalContext::supported_compute_features(CI::MetalContext *this)
{
  int v1;

  if (*((_BYTE *)this + 458))
    v1 = 15;
  else
    v1 = 7;
  return v1 | (16 * *((unsigned __int8 *)this + 459));
}

double CI::MetalContext::sampler_transform_for_extent@<D0>(const CGRect *a1@<X1>, double *a2@<X8>)
{
  double y;
  double v4;
  CGFloat v5;
  double v6;
  double v7;
  double result;

  y = a1->origin.y;
  v4 = 1.0 / a1->size.height;
  v5 = a1->origin.x * -0.0 - y * v4 + 0.0;
  v6 = 1.0 / a1->size.width;
  v7 = y * -0.0 - a1->origin.x * v6;
  *a2 = v6 + 0.0;
  a2[1] = v4 * 0.0 + 0.0;
  a2[2] = v6 * 0.0 + 0.0;
  a2[3] = v4 + 0.0;
  result = v7 + 0.0;
  a2[4] = result;
  a2[5] = v5;
  return result;
}

uint64_t CI::MetalContext::createMainProgram(uint64_t a1, uint64_t a2, const char *a3, const char *a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v17;

  v15 = operator new();
  LODWORD(v17) = a7;
  CI::MetalMainProgram::MetalMainProgram(v15, a1, a3, a4, a5, a6, 0, 0, v17, a8);
  return v15;
}

void sub_1923EDCB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x194025AAC](v1, 0x10F1C40F8089CA4);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'CI::MetalContext::type(CI::MetalContext *this)
{
  return 77;
}

char *std::vector<std::pair<void const*,void const*>>::__init_with_size[abi:nn180100]<std::pair<void const*,void const*>*,std::pair<void const*,void const*>*>(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  char *v6;
  _OWORD *v7;
  __int128 v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CI::Perspective::Line>::__vallocate[abi:nn180100](result, a4);
    v7 = (_OWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2++;
      *v7++ = v8;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

_QWORD *std::__hash_table<void const*,std::hash<void const*>,std::equal_to<void const*>,std::allocator<void const*>>::__emplace_unique_key_args<void const*,void const* const&>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = v8 & (v9 - 1);
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x18uLL);
  *i = 0;
  i[1] = v8;
  i[2] = *a3;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>(a1, v19);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *i = *v21;
LABEL_38:
    *v21 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v22 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9)
        v22 %= v9;
    }
    else
    {
      v22 &= v9 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1923EDF74(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<void const*,std::hash<void const*>,std::equal_to<void const*>,std::allocator<void const*>>::find<void const*>(_QWORD *a1, _QWORD *a2)
{
  int8x8_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = v5;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = v5 & (*(_QWORD *)&v2 - 1);
  }
  v8 = *(_QWORD **)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  result = (_QWORD *)*v8;
  if (*v8)
  {
    do
    {
      v10 = result[1];
      if (v5 == v10)
      {
        if (result[2] == *a2)
          return result;
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(_QWORD *)&v2)
            v10 %= *(_QWORD *)&v2;
        }
        else
        {
          v10 &= *(_QWORD *)&v2 - 1;
        }
        if (v10 != v7)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t std::unordered_set<void const*>::unordered_set(uint64_t a1, uint64_t a2)
{
  _QWORD *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(_QWORD **)(a2 + 16); i; i = (_QWORD *)*i)
    std::__hash_table<void const*,std::hash<void const*>,std::equal_to<void const*>,std::allocator<void const*>>::__emplace_unique_key_args<void const*,void const* const&>(a1, i + 2, i + 2);
  return a1;
}

void sub_1923EE0D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t CI::InstanceCounted<(CI::Type)67>::type()
{
  return 67;
}

_QWORD *CI::InstanceCounted<(CI::Type)67>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBBF60;
  do
    v1 = __ldaxr(&dword_1ECF873D0[9]);
  while (__stlxr(v1 - 1, &dword_1ECF873D0[9]));
  return result;
}

void CI::InstanceCounted<(CI::Type)67>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBBF60;
  do
    v1 = __ldaxr(&dword_1ECF873D0[9]);
  while (__stlxr(v1 - 1, &dword_1ECF873D0[9]));
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::InstanceCounted<(CI::Type)77>::type()
{
  return 77;
}

_QWORD *CI::InstanceCounted<(CI::Type)77>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EB7B30;
  do
    v1 = __ldaxr(&dword_1ECF873D0[19]);
  while (__stlxr(v1 - 1, &dword_1ECF873D0[19]));
  return result;
}

void CI::InstanceCounted<(CI::Type)77>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EB7B30;
  do
    v1 = __ldaxr(&dword_1ECF873D0[19]);
  while (__stlxr(v1 - 1, &dword_1ECF873D0[19]));
  JUMPOUT(0x194025AACLL);
}

const __CFString *CI::Context::AbortIfUnhandledError(const __CFString *this, const __CFString *a2)
{
  CFRange v2;

  if (this)
  {
    v2 = CFStringFind(this, CFSTR("Render failed because of failure to allocate intermediate."), 1uLL);
    this = (const __CFString *)v2.location;
    if (v2.length)
      abort();
  }
  return this;
}

void ___ZN2CI7Context23render_completion_queueEv_block_invoke_2()
{
  dispatch_sync((dispatch_queue_t)CI::Context::render_completion_queue(void)::sRenderCompletionQueue, &__block_literal_global_6_1);
}

CI::Context *CI::Context::Context(CI::Context *this, const CI::Context *a2)
{
  unsigned int v4;
  unsigned int v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;

  *((_DWORD *)this + 2) = 1;
  *(_QWORD *)this = off_1E2EBEF40;
  *((_DWORD *)this + 9) = 0;
  *((_BYTE *)this + 41) = 1;
  do
  {
    v4 = __ldaxr(&CI::gContextCounter);
    v5 = v4 + 1;
  }
  while (__stlxr(v5, &CI::gContextCounter));
  *((_DWORD *)this + 36) = v5;
  *((_QWORD *)this + 19) = 0;
  v6 = *MEMORY[0x1E0C9D628];
  v7 = *(_OWORD *)(MEMORY[0x1E0C9D628] + 16);
  *((_OWORD *)this + 10) = *MEMORY[0x1E0C9D628];
  *((_OWORD *)this + 11) = v7;
  *((_QWORD *)this + 24) = 0;
  *(_OWORD *)((char *)this + 216) = v7;
  *(_OWORD *)((char *)this + 200) = v6;
  *((_DWORD *)this + 58) = 1;
  *(_OWORD *)((char *)this + 252) = 0u;
  *(_OWORD *)((char *)this + 236) = 0u;
  *(_OWORD *)((char *)this + 268) = 0u;
  *(_OWORD *)((char *)this + 284) = 0u;
  *((_BYTE *)this + 300) = 1;
  *((_DWORD *)this + 86) = 0;
  v8 = *((_QWORD *)a2 + 45);
  *((_QWORD *)this + 44) = 0;
  *((_QWORD *)this + 45) = v8;
  *((_OWORD *)this + 23) = *((_OWORD *)a2 + 23);
  v9 = operator new();
  *((_QWORD *)this + 38) = CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::ObjectCache(v9, 0x400uLL);
  v10 = operator new();
  *((_QWORD *)this + 39) = CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::ObjectCache(v10, 0x20uLL);
  v11 = operator new();
  *((_QWORD *)this + 40) = CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::ObjectCache(v11, 0x20uLL);
  *((_QWORD *)this + 2) = CGColorSpaceRetain(*((CGColorSpaceRef *)a2 + 2));
  *((_QWORD *)this + 3) = CGColorSpaceRetain(*((CGColorSpaceRef *)a2 + 3));
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  *((_BYTE *)this + 40) = *((_BYTE *)a2 + 40);
  *((_WORD *)this + 21) = *((_WORD *)a2 + 21);
  *((_BYTE *)this + 44) = 0;
  *((_QWORD *)this + 6) = CGContextRetain(*((CGContextRef *)a2 + 6));
  *((_DWORD *)this + 14) = *((_DWORD *)a2 + 14);
  *((_BYTE *)this + 60) = *((_BYTE *)a2 + 60);
  v12 = *(_OWORD *)(MEMORY[0x1E0C9D5E0] + 16);
  *((_OWORD *)this + 4) = *MEMORY[0x1E0C9D5E0];
  *((_OWORD *)this + 5) = v12;
  v13 = MEMORY[0x1E0C9BAA8];
  v14 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
  *((_OWORD *)this + 6) = *MEMORY[0x1E0C9BAA8];
  *((_OWORD *)this + 7) = v14;
  *((_OWORD *)this + 8) = *(_OWORD *)(v13 + 32);
  *((_DWORD *)this + 58) = *((_DWORD *)a2 + 58);
  *((_QWORD *)this + 44) = 0;
  *((_QWORD *)this + 41) = 0;
  *((_QWORD *)this + 42) = 0;
  strlcpy((char *)this + 236, (const char *)a2 + 236, 0x40uLL);
  return this;
}

uint64_t CI::Context::defaultWorkingSpace(CI::Context *this)
{
  if (CI::Context::defaultWorkingSpace(void)::didCreate != -1)
    dispatch_once(&CI::Context::defaultWorkingSpace(void)::didCreate, &__block_literal_global_21);
  return CI::Context::defaultWorkingSpace(void)::space;
}

void CI::Context::clear_caches(CI::Context *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  void (*v8)(uint64_t);
  void *v9;
  uint64_t v10;

  v2 = *((_QWORD *)this + 39);
  v3 = MEMORY[0x1E0C809B0];
  v6 = MEMORY[0x1E0C809B0];
  v7 = 0x40000000;
  v8 = ___ZN2CI11ObjectCacheINS_4NodeEyLb0EE5clearEv_block_invoke;
  v9 = &__block_descriptor_tmp_60;
  v10 = v2;
  Queue::execute_async((dispatch_queue_t *)(v2 + 56), &v6);
  v4 = *((_QWORD *)this + 40);
  v6 = v3;
  v7 = 0x40000000;
  v8 = ___ZN2CI11ObjectCacheINS_4NodeEyLb0EE5clearEv_block_invoke;
  v9 = &__block_descriptor_tmp_60;
  v10 = v4;
  Queue::execute_async((dispatch_queue_t *)(v4 + 56), &v6);
  v5 = (*(uint64_t (**)(CI::Context *))(*(_QWORD *)this + 272))(this);
  RemoveCacheEntriesForContext(v5);
}

void CI::Context::setPriority(uint64_t a1, int a2)
{
  NSObject *v2;
  uint8_t v3[16];

  if (a2)
  {
    v2 = ci_logger_render();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)v3 = 0;
      _os_log_impl(&dword_1921E4000, v2, OS_LOG_TYPE_INFO, "Context does not support non-default priority", v3, 2u);
    }
  }
}

void CI::Context::recursive_render(char *a1, CI::TileTask *a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  CI::Node *v5;
  uint64_t v6;
  CGFloat v9;
  CGFloat v10;
  CGFloat v11;
  CI::TextureManager *v12;
  unsigned __int8 v13;
  unsigned int v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 *v19;
  int v20;
  NSObject *v21;
  _QWORD *v22;
  uint64_t v23;
  int v24;
  __int128 v25;
  _BYTE *v26;
  unint64_t v27;
  dispatch_group_t v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  _OWORD *v35;
  CI::Node *v36;
  CI::SerialRectArray *v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  uint64_t *v43;
  uint64_t *v44;
  uint64_t **v45;
  uint64_t **v46;
  CI::Node *v47;
  CI::SerialRectArray *v48;
  unsigned int v49;
  CI::SerialRectArray *v50;
  unsigned int v51;
  uint64_t **v52;
  unsigned int v53;
  uint64_t *v54;
  uint64_t **v55;
  BOOL v56;
  NSObject *v57;
  os_signpost_id_t v58;
  uint64_t v59;
  int v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _BOOL4 v68;
  NSObject *v69;
  uint64_t v70;
  unint64_t v71;
  int v72;
  unint64_t SurfaceCacheNonVolatileSizeForContext;
  NSObject *v74;
  os_signpost_id_t v75;
  uint64_t v76;
  int v77;
  unint64_t v78;
  uint64_t v79;
  NSObject *v80;
  os_signpost_id_t v81;
  NSObject *v82;
  NSObject *v83;
  os_signpost_id_t v84;
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  NSObject *v92;
  os_signpost_id_t v93;
  NSObject *v94;
  int v95;
  int v96;
  double *v97;
  double v98;
  double v99;
  double v100;
  double v101;
  const void *v102;
  _BOOL4 is_deep;
  uint64_t v104;
  dispatch_queue_t *v105;
  uint64_t v106;
  Class isa;
  const char *v108;
  uint64_t v109;
  NSObject *v110;
  os_signpost_id_t v111;
  uint64_t v112;
  uint64_t **v113;
  CI::SerialRectArray **v114;
  unsigned int v115;
  uint64_t *v116;
  uint64_t **v117;
  NSObject *v118;
  os_signpost_id_t v119;
  NSObject *v120;
  NSObject *v121;
  os_signpost_id_t v122;
  NSObject *v123;
  uint64_t v124;
  char *__s2;
  NSObject *v126;
  uint64_t v127;
  uint64_t v128;
  CI::Context *v129;
  CI::TileTask *v130;
  unsigned int v131;
  NSObject *object;
  uint64_t v135;
  CI::Node *v136;
  int v137;
  unsigned int v138;
  unint64_t v139;
  uint64_t v140;
  _OWORD *v141;
  uint64_t v142;
  uint8_t buf[8];
  uint8_t *v144;
  unint64_t v145;
  char *v146;
  uint64_t v147;
  int v148;
  _QWORD block[6];
  CI::Node *v150[2];
  int v151;
  unsigned int v152;
  uint64_t v153;
  uint64_t v154;
  int v155;
  uint64_t v156;
  _OWORD *v157;
  uint64_t *v158;
  _QWORD *v159[2];
  uint64_t **v160;
  uint64_t *v161;
  uint64_t v162;
  _QWORD v163[5];
  void *v164;
  _BYTE *v165;
  uint64_t v166;
  _QWORD v167[5];
  __int128 v168;
  CGRect rect;
  _BYTE __p[32];
  __int128 v171;
  const void *v172;
  uint64_t v173;
  double v174;
  double v175;
  double v176;
  double v177;
  int v178;
  int v179;
  int v180;
  int v181;
  int v182;
  uint64_t v183;
  CGRect v184;
  CGRect v185;

  v183 = *MEMORY[0x1E0C80C00];
  v5 = *(CI::Node **)a3;
  if (!*(_QWORD *)a3)
    return;
  v6 = a3;
  rect.origin.x = CI::Node::roi(*(CI::Node **)a3, *(_DWORD *)(a3 + 8));
  rect.origin.y = v9;
  rect.size.width = v10;
  rect.size.height = v11;
  v12 = (CI::TextureManager *)(*(uint64_t (**)(char *))(*(_QWORD *)a1 + 112))(a1);
  if ((v13 & 1) == 0
  {
    CI::TextureManager::intermediate(v12, 0);
    CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::emptyIntermediate = v124;
    __cxa_atexit((void (*)(void *))std::unique_ptr<CI::intermediate_t>::~unique_ptr[abi:nn180100], &CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::emptyIntermediate, &dword_1921E4000);
  }
  v168 = *(_OWORD *)((char *)v5 + 140);
  if (!(_DWORD)v168)
    LODWORD(v168) = *((_DWORD *)a1 + 8);
  v14 = *(_DWORD *)(v6 + 8);
  if (a4)
  {
    if (CGRectIsEmpty(rect))
    {
      v15 = CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::emptyIntermediate;
    }
    else
    {
      v16 = (_QWORD *)CI::Node::rois(v5);
      v17 = (uint64_t)(*(_QWORD *)(*v16 + 120 * (int)v14 + 40) - *(_QWORD *)(*v16 + 120 * (int)v14 + 32)) >> 4;
      v18 = (*(uint64_t (**)(CI::Node *))(*(_QWORD *)v5 + 384))(v5);
      v15 = (*(uint64_t (**)(CI::TextureManager *, __int128 *, uint64_t, CGRect *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12 + 40))(v12, &v168, v18, &rect, 1, 1 - 0x5555555555555555 * v17, 1);
      if (v15)
      {
        *(_QWORD *)__p = v5;
        *(_DWORD *)&__p[8] = v14;
        CI::TextureManager::add_intermediate_for_node((uint64_t)v12, __p, v15);
      }
    }
  }
  else
  {
    v15 = 0;
  }
  if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)v5 + 6) + 16))(*((_QWORD *)v5 + 6)) == 41)
  {
    v19 = (unsigned __int8 *)*((_QWORD *)v5 + 6);
    v20 = v19[153];
    if (v19[153])
      v20 = (*(int (**)(unsigned __int8 *))(*(_QWORD *)v19 + 40))(v19) > 0;
    a5 |= v20;
  }
  v21 = *((_QWORD *)a2 + 3);
  v167[0] = MEMORY[0x1E0C809B0];
  v167[1] = 0x40000000;
  v167[2] = ___ZN2CI7Context16recursive_renderEPNS_8TileTaskERKNS_6roiKeyEPNS_4NodeEb_block_invoke;
  v167[3] = &__block_descriptor_tmp_7_3;
  v126 = v21;
  v167[4] = v21;
  v22 = (_QWORD *)CI::Node::rois(v5);
  v166 = 0;
  v164 = 0;
  v165 = 0;
  if ((v14 & 0x80000000) != 0)
    return;
  v23 = *v22 + 120 * v14;
  v24 = *(_DWORD *)(v23 + 80);
  v25 = *(_OWORD *)(v23 + 16);
  *(_OWORD *)__p = *(_OWORD *)v23;
  *(_OWORD *)&__p[16] = v25;
  CI::SerialRectArray::recurseSubdivide((double *)__p, v24, &v164);
  v26 = v164;
  if (v165 == v164)
    goto LABEL_172;
  v140 = 0;
  __s2 = a1 + 236;
  v128 = v15;
  v129 = (CI::Context *)a1;
  v127 = v15;
  v135 = v6;
  v136 = v5;
  v142 = (uint64_t)v12;
  v130 = a2;
  v131 = v14;
  while (2)
  {
    v138 = 0;
    v27 = 0;
    do
    {
      v139 = v27;
      if (a4 || ((v165 - (_BYTE *)v164) >> 5) - 1 != v140)
      {
        v28 = dispatch_group_create();
      }
      else
      {
        dispatch_retain(*((dispatch_object_t *)a2 + 2));
        v28 = (dispatch_group_t)*((_QWORD *)a2 + 2);
      }
      v163[0] = MEMORY[0x1E0C809B0];
      v163[1] = 0x40000000;
      v163[2] = ___ZN2CI7Context16recursive_renderEPNS_8TileTaskERKNS_6roiKeyEPNS_4NodeEb_block_invoke_2;
      v163[3] = &__block_descriptor_tmp_8_3;
      object = v28;
      v163[4] = v28;
      v161 = 0;
      v162 = 0;
      v160 = &v161;
      v159[0] = 0;
      v159[1] = 0;
      v158 = (uint64_t *)v159;
      v29 = (*(uint64_t (**)(CI::Node *))(*(_QWORD *)v5 + 40))(v5);
      if (v29)
      {
        v30 = v29;
        v31 = 0;
        do
        {
          CI::ProgramNode::roiKeys_of_child(v5, *((CGRect *)v164 + v140), v31, __p);
          v156 = (uint64_t)(*(_QWORD *)&__p[8] - *(_QWORD *)__p) >> 4;
          std::__tree<char const*>::__emplace_unique_key_args<char const*,char const* const&>(&v158, (unint64_t *)&v156, &v156);
          v32 = v139;
          if ((uint64_t)(*(_QWORD *)&__p[8] - *(_QWORD *)__p) >> 4 > v139)
            v32 = (uint64_t)(*(_QWORD *)&__p[8] - *(_QWORD *)__p) >> 4;
          v139 = v32;
          if (*(_QWORD *)__p)
          {
            *(_QWORD *)&__p[8] = *(_QWORD *)__p;
            operator delete(*(void **)__p);
          }
          v31 = (v31 + 1);
        }
        while (v30 != (_DWORD)v31);
      }
      v137 = (*(uint64_t (**)(CI::Node *))(*(_QWORD *)v5 + 40))(v5);
      if (v137)
      {
        v33 = 0;
        do
        {
          v34 = *(_DWORD *)(v6 + 8);
          *(_QWORD *)__p = v5;
          *(_DWORD *)&__p[8] = v34;
          *(_DWORD *)&__p[12] = v140;
          *(_DWORD *)&__p[16] = v33;
          *(_DWORD *)&__p[20] = v138;
          *(_QWORD *)&__p[24] = 0;
          *(_QWORD *)&v171 = 0;
          DWORD2(v171) = 0;
          CI::ProgramNode::roiKeys_of_child(v5, *((CGRect *)v164 + v140), v33, &v156);
          v35 = (_OWORD *)v156;
          v141 = v157;
          if ((_OWORD *)v156 != v157)
          {
            do
            {
              *(_OWORD *)v150 = *v35;
              v36 = v150[0];
              v37 = (CI::SerialRectArray *)CI::Node::rois(v150[0]);
              CI::SerialRectArray::restore(v37, (int)v150[1], (const CI::parentROI *)__p);
              v38 = (_QWORD *)CI::Node::rois(v36);
              v39 = *v38 + 120 * SLODWORD(v150[1]);
              v40 = *(_QWORD *)(v39 + 32);
              v41 = *(_QWORD *)(v39 + 40);
              while (v40 != v41)
              {
                if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vceqq_s32(*(int32x4_t *)&__p[8], *(int32x4_t *)(v40 + 8))), 0xFuLL))) & 1) != 0&& *(_QWORD *)v40 == *(_QWORD *)__p)
                {
                  v42 = operator new(0x38uLL);
                  v43 = (uint64_t *)v42;
                  *((_OWORD *)v42 + 2) = *(_OWORD *)v150;
                  *((_DWORD *)v42 + 12) = v33;
                  v44 = v161;
                  v45 = &v161;
                  v46 = &v161;
                  if (v161)
                  {
                    v47 = (CI::Node *)*((_QWORD *)v42 + 4);
                    do
                    {
                      while (1)
                      {
                        v45 = (uint64_t **)v44;
                        v48 = (CI::SerialRectArray *)CI::Node::rois(v47);
                        v49 = CI::SerialRectArray::maxParentDistance(v48);
                        v50 = (CI::SerialRectArray *)CI::Node::rois((CI::Node *)v45[4]);
                        if (v49 >= CI::SerialRectArray::maxParentDistance(v50))
                          break;
                        v44 = *v45;
                        v46 = v45;
                        if (!*v45)
                          goto LABEL_44;
                      }
                      v44 = v45[1];
                    }
                    while (v44);
                    v46 = v45 + 1;
                  }
LABEL_44:
                  *v43 = 0;
                  v43[1] = 0;
                  v43[2] = (uint64_t)v45;
                  *v46 = v43;
                  if (*v160)
                  {
                    v160 = (uint64_t **)*v160;
                    v43 = *v46;
                  }
                  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v161, v43);
                  ++v162;
                  v12 = (CI::TextureManager *)v142;
                  CI::TextureManager::add_to_pending(v142, (uint64_t)v150);
                }
                v40 += 48;
              }
              ++v35;
            }
            while (v35 != v141);
            v35 = (_OWORD *)v156;
          }
          if (v35)
          {
            v157 = v35;
            operator delete(v35);
          }
          v33 = (v33 + 1);
          v6 = v135;
          v5 = v136;
        }
        while ((_DWORD)v33 != v137);
      }
      a2 = v130;
      v51 = v131;
      if (v128 || (v52 = v160, v160 == &v161))
      {
LABEL_65:
        if (CI_VERBOSE_SIGNPOSTS())
        {
          v57 = ci_signpost_log_render();
          v58 = *((int *)v5 + 9) | (unint64_t)((*(uint64_t (**)(CI::Context *))(*(_QWORD *)v129 + 272))(v129) << 32);
          if (v58 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v57))
          {
            *(_DWORD *)__p = 134218752;
            *(CGFloat *)&__p[4] = rect.origin.x;
            *(_WORD *)&__p[12] = 2048;
            *(CGFloat *)&__p[14] = rect.origin.y;
            *(_WORD *)&__p[22] = 2048;
            *(CGFloat *)&__p[24] = rect.size.width;
            LOWORD(v171) = 2048;
            *(CGFloat *)((char *)&v171 + 2) = rect.size.height;
            _os_signpost_emit_with_name_impl(&dword_1921E4000, v57, OS_SIGNPOST_INTERVAL_BEGIN, v58, "render_quad", "[%g %g %g %g]", __p, 0x2Au);
          }
        }
        v59 = (*(uint64_t (**)(CI::Context *))(*(_QWORD *)v129 + 272))(v129);
        TimerBase::TimerBase((uint64_t)&v156, v59, *((_DWORD *)v5 + 9), (uint64_t)"render_quad", 6);
        v150[0] = v5;
        v150[1] = (CI::Node *)__PAIR64__(v140, v131);
        v151 = -1;
        v152 = v138;
        v153 = 0;
        v154 = 0;
        v155 = 0;
        v185.origin.x = CI::parentROI::roi((CI::parentROI *)v150);
        if (CGRectIsEmpty(v185))
        {
          v60 = 1;
LABEL_162:
          if (CI_VERBOSE_SIGNPOSTS())
          {
            v121 = ci_signpost_log_render();
            v122 = (os_signpost_id_t)v157;
            if ((unint64_t)v157 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
            {
              v123 = v121;
              if (os_signpost_enabled(v121))
              {
                *(_WORD *)__p = 0;
                _os_signpost_emit_with_name_impl(&dword_1921E4000, v123, OS_SIGNPOST_INTERVAL_END, v122, "render_quad", (const char *)&unk_192520C83, __p, 2u);
              }
            }
          }
          TimerBase::~TimerBase((TimerBase *)&v156);
          goto LABEL_167;
        }
        CI::Object::ref((uint64_t)v129);
        if (a4)
        {
          if ((*(unsigned int (**)(CI::Node *))(*(_QWORD *)v5 + 16))(v5) == 52)
          {
            v61 = (_QWORD *)CI::Node::rois(v5);
            if ((int)CI::Node::rois_count(v5) >= 1)
            {
              v62 = 0;
              while (2)
              {
                v63 = *v61 + 120 * v62;
                v64 = *(_QWORD *)(v63 + 32);
                v65 = *(_QWORD *)(v63 + 40);
                while (v64 != v65)
                {
                  v66 = *(_QWORD *)(*(_QWORD *)v64 + 48);
                  if ((*(int (**)(uint64_t))(*(_QWORD *)v66 + 16))(v66) >= 41
                    && (*(int (**)(uint64_t))(*(_QWORD *)v66 + 16))(v66) < 43)
                  {
                    v68 = 1;
                    v5 = v136;
                    goto LABEL_86;
                  }
                  v64 += 48;
                }
                ++v62;
                v5 = v136;
                if (v62 < (int)CI::Node::rois_count(v136))
                  continue;
                break;
              }
            }
          }
          v67 = *((_QWORD *)v5 + 6);
          v68 = (*(int (**)(uint64_t))(*(_QWORD *)v67 + 16))(v67) >= 41
             && (*(int (**)(uint64_t))(*(_QWORD *)v67 + 16))(v67) < 43;
LABEL_86:
          v51 = v131;
          v69 = object;
          v70 = v127;
          if (!v127)
          {
            v71 = CI::Context::bytesLimit(v129);
            if (*((_QWORD *)v129 + 46))
            {
              v72 = (*(uint64_t (**)(CI::Context *))(*(_QWORD *)v129 + 272))(v129);
              SurfaceCacheNonVolatileSizeForContext = GetSurfaceCacheNonVolatileSizeForContext(v72);
            }
            else
            {
              SurfaceCacheNonVolatileSizeForContext = GetSurfaceCacheNonVolatileSize();
            }
            if (SurfaceCacheNonVolatileSizeForContext > v71)
            {
              if (CI_VERBOSE_SIGNPOSTS())
              {
                v74 = ci_signpost_log_render();
                v75 = *((int *)v5 + 9) | (unint64_t)((*(uint64_t (**)(CI::Context *))(*(_QWORD *)v129 + 272))(v129) << 32);
                if (v75 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v74))
                {
                  *(_WORD *)__p = 0;
                  _os_signpost_emit_with_name_impl(&dword_1921E4000, v74, OS_SIGNPOST_INTERVAL_BEGIN, v75, "wait_for_cache", (const char *)&unk_192520C83, __p, 2u);
                }
              }
              v76 = (*(uint64_t (**)(CI::Context *))(*(_QWORD *)v129 + 272))(v129);
              TimerBase::TimerBase((uint64_t)__p, v76, *((_DWORD *)v5 + 9), (uint64_t)"wait_for_cache", 19);
              (*(void (**)(CI::Context *))(*(_QWORD *)v129 + 56))(v129);
              v77 = (*(uint64_t (**)(CI::Context *))(*(_QWORD *)v129 + 272))(v129);
              v78 = GetSurfaceCacheNonVolatileSizeForContext(v77) - v71;
              do
              {
                if (!v78)
                  break;
                v79 = CI::TextureManager::releaseDeepIntermediate(v12);
                v78 -= v79;
              }
              while (v79);
              v51 = v131;
              if (CI_VERBOSE_SIGNPOSTS())
              {
                v80 = ci_signpost_log_render();
                v81 = *(_QWORD *)&__p[8];
                if ((unint64_t)(*(_QWORD *)&__p[8] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
                {
                  v82 = v80;
                  if (os_signpost_enabled(v80))
                  {
                    *(_WORD *)buf = 0;
                    _os_signpost_emit_with_name_impl(&dword_1921E4000, v82, OS_SIGNPOST_INTERVAL_END, v81, "wait_for_cache", (const char *)&unk_192520C83, buf, 2u);
                  }
                }
              }
              TimerBase::~TimerBase((TimerBase *)__p);
            }
            if (CI_VERBOSE_SIGNPOSTS())
            {
              v83 = ci_signpost_log_render();
              v84 = *((int *)v5 + 9) | (unint64_t)((*(uint64_t (**)(CI::Context *))(*(_QWORD *)v129 + 272))(v129) << 32);
              if (v84 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v83))
              {
                *(_WORD *)__p = 0;
                _os_signpost_emit_with_name_impl(&dword_1921E4000, v83, OS_SIGNPOST_INTERVAL_BEGIN, v84, "create_intermediate", (const char *)&unk_192520C83, __p, 2u);
              }
            }
            v85 = (*(uint64_t (**)(CI::Context *))(*(_QWORD *)v129 + 272))(v129);
            TimerBase::TimerBase((uint64_t)__p, v85, *((_DWORD *)v5 + 9), (uint64_t)"create_intermediate", 9);
            if (!CI::PixelFormatType_from_format(v168))
              CI::Context::recursive_render();
            if (CGRectIsEmpty(rect) || CGRectIsInfinite(rect))
              CI::Context::recursive_render(&rect.size.width, &rect.size.height);
            v86 = (_QWORD *)CI::Node::rois(v5);
            v87 = (uint64_t)(*(_QWORD *)(*v86 + 120 * v51 + 40) - *(_QWORD *)(*v86 + 120 * v51 + 32)) >> 4;
            v88 = (*(uint64_t (**)(CI::Node *))(*(_QWORD *)v5 + 384))(v5);
            if (v68)
              v89 = 1;
            else
              v89 = 64;
            v90 = (*(uint64_t (**)(CI::TextureManager *, __int128 *, uint64_t, CGRect *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v12 + 40))(v12, &v168, v88, &rect, v89, 1 - 0x5555555555555555 * v87, 0);
            *(_QWORD *)buf = v5;
            LODWORD(v144) = v51;
            v91 = v90;
            CI::TextureManager::add_intermediate_for_node((uint64_t)v12, buf, v90);
            if (CI_VERBOSE_SIGNPOSTS())
            {
              v92 = ci_signpost_log_render();
              v93 = *(_QWORD *)&__p[8];
              if ((unint64_t)(*(_QWORD *)&__p[8] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
              {
                v94 = v92;
                if (os_signpost_enabled(v92))
                {
                  *(_WORD *)buf = 0;
                  _os_signpost_emit_with_name_impl(&dword_1921E4000, v94, OS_SIGNPOST_INTERVAL_END, v93, "create_intermediate", (const char *)&unk_192520C83, buf, 2u);
                }
              }
            }
            TimerBase::~TimerBase((TimerBase *)__p);
            v69 = object;
            v70 = v91;
            if (!v91)
            {
              if (dyld_program_sdk_at_least())
              {
                a2 = v130;
                CI::TileTask::setTaskError(v130, CFSTR("Render failed because of failure to allocate intermediate."));
                v127 = 0;
                goto LABEL_144;
              }
              v70 = 0;
            }
          }
          v127 = v70;
          if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70))
          {
            dispatch_retain(v69);
            dispatch_group_enter(v69);
            a2 = v130;
            (*(void (**)(CI::Context *, CI::TileTask *, CI::Node **, uint64_t, _QWORD, _QWORD *))(*(_QWORD *)v129 + 48))(v129, v130, v150, v70, a5, v163);
            if ((CI_PRINT_TREE_dump_intermediates() & 1) == 0
              && (CI_PRINT_TREE_dump_raw_intermediates() & 1) == 0
              && !CI_PRINT_TREE_dump_bmtl_intermediates())
            {
              goto LABEL_144;
            }
            v95 = (*(uint64_t (**)(CI::Context *))(*(_QWORD *)v129 + 272))(v129);
            if (!CI_PRINT_TREE_context(v95, __s2)
              || *((_QWORD *)v129 + 19) != (int)CI_PRINT_TREE_frame() && CI_PRINT_TREE_frame())
            {
              goto LABEL_144;
            }
            v96 = *((_DWORD *)v5 + 9);
            v97 = (double *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v70 + 32))(v70);
            v98 = *v97;
            v99 = v97[1];
            v100 = v97[2];
            v101 = v97[3];
            v102 = (const void *)(**(uint64_t (***)(uint64_t))v70)(v70);
            RetainSurfaceFromCache(v102);
            RetainSurfaceFromCache(v102);
            if (CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::onceToken != -1)
              dispatch_once(&CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::onceToken, &__block_literal_global_43_0);
            is_deep = CI::format_is_deep(*((_DWORD *)v5 + 35));
            v104 = CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::sRGBLinear;
            v105 = (dispatch_queue_t *)v5;
            v106 = CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::sRGB;
            if (CI::ProgramNode::mainProgram(v105))
              isa = CI::ProgramNode::mainProgram(v105)[6].isa;
            else
              isa = 0;
            v12 = (CI::TextureManager *)v142;
            *(_QWORD *)buf = 0;
            v144 = buf;
            v145 = 0x2000000000;
            if (isa)
              v108 = (const char *)isa;
            else
              v108 = "intermediate";
            v146 = strdup(v108);
            dispatch_retain(object);
            if (CI::Context::render_completion_queue(void)::onceToken != -1)
              dispatch_once(&CI::Context::render_completion_queue(void)::onceToken, &__block_literal_global_86);
            if (is_deep)
              v109 = v104;
            else
              v109 = v106;
            *(_QWORD *)__p = MEMORY[0x1E0C809B0];
            *(_QWORD *)&__p[8] = 0x40000000;
            *(_QWORD *)&__p[16] = ___ZN2CIL26dump_intermediate_for_nodeEPKNS_11ProgramNodeEPKNS_14intermediate_tEP16dispatch_group_s_block_invoke_2;
            *(_QWORD *)&__p[24] = &unk_1E2EC6808;
            v178 = v96;
            v179 = (int)v98;
            v180 = (int)v99;
            v181 = (int)v100;
            v182 = (int)v101;
            v172 = v102;
            v173 = v109;
            v174 = v98;
            v175 = v99;
            v176 = v100;
            v177 = v101;
            v69 = object;
            *((_QWORD *)&v171 + 1) = object;
            *(_QWORD *)&v171 = buf;
            dispatch_async((dispatch_queue_t)CI::Context::render_completion_queue(void)::sRenderCompletionQueue, __p);
            _Block_object_dispose(buf, 8);
            v5 = v136;
            v51 = v131;
          }
          a2 = v130;
        }
        else
        {
          v69 = object;
          dispatch_retain(object);
          dispatch_group_enter(object);
          dispatch_retain(v126);
          dispatch_group_enter(v126);
          (*(void (**)(CI::Context *, CI::TileTask *, CI::Node **, _QWORD *, _QWORD *))(*(_QWORD *)v129 + 40))(v129, v130, v150, v167, v163);
        }
LABEL_144:
        dispatch_retain(v69);
        if (CI::Context::render_completion_queue(void)::onceToken != -1)
          dispatch_once(&CI::Context::render_completion_queue(void)::onceToken, &__block_literal_global_86);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = ___ZN2CI7Context16recursive_renderEPNS_8TileTaskERKNS_6roiKeyEPNS_4NodeEb_block_invoke_9;
        block[3] = &__block_descriptor_tmp_10_2;
        block[4] = v69;
        block[5] = v129;
        dispatch_async((dispatch_queue_t)CI::Context::render_completion_queue(void)::sRenderCompletionQueue, block);
        if (CI_VERBOSE_SIGNPOSTS())
        {
          v110 = ci_signpost_log_render();
          v111 = *((int *)v5 + 9) | (unint64_t)((*(uint64_t (**)(CI::Context *))(*(_QWORD *)v129 + 272))(v129) << 32);
          if (v111 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v110))
          {
            *(_WORD *)__p = 0;
            _os_signpost_emit_with_name_impl(&dword_1921E4000, v110, OS_SIGNPOST_INTERVAL_BEGIN, v111, "remove_parentROI", (const char *)&unk_192520C83, __p, 2u);
          }
        }
        v112 = (*(uint64_t (**)(CI::Context *))(*(_QWORD *)v129 + 272))(v129);
        TimerBase::TimerBase((uint64_t)__p, v112, *((_DWORD *)v5 + 9), (uint64_t)"remove_parentROI", 0);
        v113 = v160;
        if (v160 != &v161)
        {
          do
          {
            CI::TextureManager::remove_from_pending((uint64_t)v12, (uint64_t)(v113 + 4));
            v114 = (CI::SerialRectArray **)(*(uint64_t (**)(CI::Node *, _QWORD))(*(_QWORD *)v5 + 48))(v5, *((unsigned int *)v113 + 12));
            v115 = *((_DWORD *)v113 + 12);
            *(_QWORD *)buf = v5;
            v144 = (uint8_t *)__PAIR64__(v140, v51);
            v145 = __PAIR64__(v138, v115);
            v146 = 0;
            v147 = 0;
            v148 = 0;
            CI::Node::remove_parentROI(v114, (const CI::parentROI *)buf, (uint64_t)(v113 + 4), (uint64_t)v12, object);
            v116 = v113[1];
            if (v116)
            {
              do
              {
                v117 = (uint64_t **)v116;
                v116 = (uint64_t *)*v116;
              }
              while (v116);
            }
            else
            {
              do
              {
                v117 = (uint64_t **)v113[2];
                v56 = *v117 == (uint64_t *)v113;
                v113 = v117;
              }
              while (!v56);
            }
            v113 = v117;
          }
          while (v117 != &v161);
        }
        if (CI_VERBOSE_SIGNPOSTS())
        {
          v118 = ci_signpost_log_render();
          v119 = *(_QWORD *)&__p[8];
          if ((unint64_t)(*(_QWORD *)&__p[8] - 1) <= 0xFFFFFFFFFFFFFFFDLL)
          {
            v120 = v118;
            if (os_signpost_enabled(v118))
            {
              *(_WORD *)buf = 0;
              _os_signpost_emit_with_name_impl(&dword_1921E4000, v120, OS_SIGNPOST_INTERVAL_END, v119, "remove_parentROI", (const char *)&unk_192520C83, buf, 2u);
            }
          }
        }
        TimerBase::~TimerBase((TimerBase *)__p);
        dispatch_release(object);
        v60 = 0;
        ++v138;
        goto LABEL_162;
      }
      while (1)
      {
        v184.origin.x = CI::Node::roi((CI::Node *)v52[4], *((_DWORD *)v52 + 10));
        if (!CGRectIsEmpty(v184))
        {
          v53 = (*(uint64_t (**)(uint64_t *))(*v52[4] + 16))(v52[4]);
          if ((CI::is_image_type(v53) & 1) == 0
            && !CI::TextureManager::get_intermediate_for_node((uint64_t)v12, (uint64_t)(v52 + 4)))
          {
            CI::Context::recursive_render(v129, v130, v52 + 4, v5, a5);
            if (*((_QWORD *)v130 + 23))
              break;
          }
        }
        v54 = v52[1];
        if (v54)
        {
          do
          {
            v55 = (uint64_t **)v54;
            v54 = (uint64_t *)*v54;
          }
          while (v54);
        }
        else
        {
          do
          {
            v55 = (uint64_t **)v52[2];
            v56 = *v55 == (uint64_t *)v52;
            v52 = v55;
          }
          while (!v56);
        }
        v52 = v55;
        if (v55 == &v161)
          goto LABEL_65;
      }
      v60 = 1;
LABEL_167:
      std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)&v158, v159[0]);
      std::__tree<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey,CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::compareDepth,std::allocator<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey>>::destroy(v161);
      if (v60)
      {
        v26 = v164;
        goto LABEL_172;
      }
      v27 = v139 - 1;
    }
    while (v139 > 1);
    v26 = v164;
    if (++v140 < (unint64_t)((v165 - (_BYTE *)v164) >> 5))
      continue;
    break;
  }
LABEL_172:
  if (v26)
  {
    v165 = v26;
    operator delete(v26);
  }
}

uint64_t *std::unique_ptr<CI::intermediate_t>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
  return a1;
}

void ___ZN2CI7Context16recursive_renderEPNS_8TileTaskERKNS_6roiKeyEPNS_4NodeEb_block_invoke(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void ___ZN2CI7Context16recursive_renderEPNS_8TileTaskERKNS_6roiKeyEPNS_4NodeEb_block_invoke_2(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void CI::SerialRectArray::restore(CI::SerialRectArray *this, int a2, const CI::parentROI *a3)
{
  uint64_t v3;
  _DWORD *v4;
  _DWORD *v5;
  _DWORD *v6;
  _QWORD *v7;
  _DWORD *v8;
  uint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  _OWORD *v16;
  void **v17;
  __int128 v18;
  __int128 v19;
  _OWORD *v20;
  void **v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  char *v28;
  __int128 v29;
  __int128 v30;
  char *v31;
  char *v32;
  char *v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  v3 = *(_QWORD *)this + 120 * a2;
  v5 = *(_DWORD **)(v3 + 56);
  v3 += 56;
  v4 = v5;
  v8 = *(_DWORD **)(v3 + 8);
  v7 = (_QWORD *)(v3 + 8);
  v6 = v8;
  while (v4 != v6)
  {
    if (*(_QWORD *)v4 == *(_QWORD *)a3
      && *((_DWORD *)a3 + 4) == v4[4]
      && *((_DWORD *)a3 + 3) == v4[3]
      && *((_DWORD *)a3 + 2) == v4[2])
    {
      v12 = *(_QWORD *)this + 120 * a2;
      v15 = *(_QWORD *)(v12 + 48);
      v14 = (_QWORD *)(v12 + 48);
      v13 = v15;
      v17 = (void **)(v14 - 1);
      v16 = (_OWORD *)*(v14 - 1);
      if ((unint64_t)v16 >= v15)
      {
        v21 = (void **)(v14 - 2);
        v22 = *(v14 - 2);
        v23 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v16 - v22) >> 4);
        v24 = v23 + 1;
        if (v23 + 1 > 0x555555555555555)
          abort();
        v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - v22) >> 4);
        if (2 * v25 > v24)
          v24 = 2 * v25;
        if (v25 >= 0x2AAAAAAAAAAAAAALL)
          v26 = 0x555555555555555;
        else
          v26 = v24;
        if (v26)
          v27 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::parentROI>>((uint64_t)v14, v26);
        else
          v27 = 0;
        v28 = &v27[48 * v23];
        v29 = *(_OWORD *)v4;
        v30 = *((_OWORD *)v4 + 2);
        *((_OWORD *)v28 + 1) = *((_OWORD *)v4 + 1);
        *((_OWORD *)v28 + 2) = v30;
        *(_OWORD *)v28 = v29;
        v31 = (char *)*v17;
        v32 = (char *)*v21;
        v33 = v28;
        if (*v17 != *v21)
        {
          do
          {
            v34 = *((_OWORD *)v31 - 3);
            v35 = *((_OWORD *)v31 - 1);
            *((_OWORD *)v33 - 2) = *((_OWORD *)v31 - 2);
            *((_OWORD *)v33 - 1) = v35;
            *((_OWORD *)v33 - 3) = v34;
            v33 -= 48;
            v31 -= 48;
          }
          while (v31 != v32);
          v31 = (char *)*v21;
        }
        *v21 = v33;
        v20 = v28 + 48;
        *v17 = v28 + 48;
        *v14 = &v27[48 * v26];
        if (v31)
          operator delete(v31);
      }
      else
      {
        v18 = *(_OWORD *)v4;
        v19 = *((_OWORD *)v4 + 2);
        v16[1] = *((_OWORD *)v4 + 1);
        v16[2] = v19;
        *v16 = v18;
        v20 = v16 + 3;
      }
      *v17 = v20;
      v36 = *v7 - (_QWORD)(v4 + 12);
      if ((_DWORD *)*v7 != v4 + 12)
        memmove(v4, v4 + 12, *v7 - (_QWORD)(v4 + 12));
      v6 = (_DWORD *)((char *)v4 + v36);
      *v7 = (char *)v4 + v36;
    }
    else
    {
      v4 += 12;
    }
  }
}

uint64_t CI::Context::bytesLimit(CI::Context *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 46) << 20;
  if (!result)
  {
    if (CI_RENDER_MB_LIMIT())
      return CI_RENDER_MB_LIMIT() << 20;
    else
      return (*(uint64_t (**)(CI::Context *))(*(_QWORD *)this + 488))(this);
  }
  return result;
}

void ___ZN2CI7Context16recursive_renderEPNS_8TileTaskERKNS_6roiKeyEPNS_4NodeEb_block_invoke_9(uint64_t a1)
{
  CI::Object *v2;

  dispatch_group_wait(*(dispatch_group_t *)(a1 + 32), 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  v2 = *(CI::Object **)(a1 + 40);
  if (v2)
    CI::Object::unref(v2);
}

CI::TileTask *CI::Context::render(CI::Context *this, CI::ProgramNode *a2, const CGRect *a3)
{
  CI::TileTask *v6;
  CI::ProgramNode *v8;
  int v9;

  v6 = (CI::TileTask *)operator new();
  CI::TileTask::TileTask(v6, this, a2, a3);
  if (*((_DWORD *)this + 86) != 1 && (*(unsigned int (**)(CI::Context *))(*(_QWORD *)this + 336))(this))
  {
    v8 = a2;
    v9 = 0;
    CI::Context::recursive_render((char *)this, v6, (uint64_t)&v8, 0, 0);
  }
  return v6;
}

uint64_t CI::Context::render_processor_node(CI::Context *this, CI::TileTask *a2, const CI::parentROI *a3, __IOSurface *a4, Texture a5)
{
  void *var1;
  unint64_t var0;
  double v11;
  double v12;
  double v13;
  double v14;
  CI::ProgramNode *v15;
  uint64_t v16;
  CGFloat v17;
  CGFloat v18;
  CGFloat v19;
  CGFloat v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  char *v24;
  uint64_t v25;
  _OWORD *v26;
  _OWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  CGFloat v35;
  CGFloat v36;
  CGFloat v37;
  uint64_t intermediate_for_node;
  CI::TextureManager *v39;
  uint64_t v41;
  CI::TileTask *v42;
  __IOSurface *v43;
  unint64_t v44;
  void *v45;
  uint64_t v46;
  CGRect v47;
  CI::Node *v48[2];
  _OWORD *v49;
  _OWORD *v50;
  void *__p;
  void *v52;
  uint64_t v53;
  _QWORD v54[5];
  CGRect v55;

  var1 = a5.var0.var2.var1;
  var0 = a5.var0.var0;
  v11 = CI::parentROI::roi(a3);
  *(double *)v54 = v11;
  *(double *)&v54[1] = v12;
  *(double *)&v54[2] = v13;
  *(double *)&v54[3] = v14;
  v15 = *(CI::ProgramNode **)a3;
  if (!*(_QWORD *)a3)
    return 0;
  v16 = *((_QWORD *)v15 + 6);
  if (!v16)
    return 0;
  v17 = v11;
  v18 = v12;
  v19 = v13;
  v20 = v14;
  if ((*(int (**)(_QWORD))(*(_QWORD *)v16 + 16))(*((_QWORD *)v15 + 6)) < 41
    || (*(int (**)(uint64_t))(*(_QWORD *)v16 + 16))(v16) > 42)
  {
    return 0;
  }
  v42 = a2;
  v43 = a4;
  v44 = var0;
  v45 = var1;
  v41 = *((_QWORD *)v15 + 6);
  v21 = (*(uint64_t (**)(CI::Context *))(*(_QWORD *)this + 112))(this);
  v22 = (*(uint64_t (**)(CI::ProgramNode *))(*(_QWORD *)v15 + 40))(v15);
  __p = 0;
  v52 = 0;
  v53 = 0;
  if (v22)
  {
    v23 = v22;
    v46 = v22;
    std::vector<unsigned long>::__vallocate[abi:nn180100](&__p, v22);
    v24 = (char *)v52;
    bzero(v52, 8 * v23);
    v25 = 0;
    v52 = &v24[8 * v23];
    do
    {
      v55.origin.x = v17;
      v55.origin.y = v18;
      v55.size.width = v19;
      v55.size.height = v20;
      CI::ProgramNode::roiKeys_of_child(v15, v55, v25, &v49);
      v26 = v49;
      v27 = v50;
      if (v49 != v50)
      {
        do
        {
          *(_OWORD *)v48 = *v26;
          v28 = (_QWORD *)CI::Node::rois(v48[0]);
          v29 = *v28 + 120 * SLODWORD(v48[1]);
          v30 = *(_QWORD *)(v29 + 32);
          v31 = *(_QWORD *)(v29 + 40);
          while (v30 != v31)
          {
            if (*(_QWORD *)v30 == *(_QWORD *)a3
              && *((_DWORD *)a3 + 3) == *(_DWORD *)(v30 + 12)
              && *((_DWORD *)a3 + 2) == *(_DWORD *)(v30 + 8)
              && *((_DWORD *)a3 + 5) == *(_DWORD *)(v30 + 20))
            {
              memset(&v47, 0, sizeof(v47));
              v47.origin.x = CI::Node::roi(v48[0], (int)v48[1]);
              v47.origin.y = v35;
              v47.size.width = v36;
              v47.size.height = v37;
              intermediate_for_node = CI::TextureManager::get_intermediate_for_node(v21, (uint64_t)v48);
              if (!intermediate_for_node)
              {
                v39 = (CI::TextureManager *)(*(uint64_t (**)(CI::Context *))(*(_QWORD *)this + 112))(this);
                intermediate_for_node = CI::TextureManager::intermediate(v39, 0, &v47, 0, 0, 1);
              }
              *((_QWORD *)__p + v25) = intermediate_for_node;
            }
            v30 += 48;
          }
          ++v26;
        }
        while (v26 != v27);
        v26 = v49;
      }
      if (v26)
      {
        v50 = v26;
        operator delete(v26);
      }
      ++v25;
    }
    while (v25 != v46);
  }
  (*(void (**)(uint64_t, CI::TileTask *, CI::Context *, void **, __IOSurface *, unint64_t, void *, _QWORD *, _DWORD))(*(_QWORD *)v41 + 416))(v41, v42, this, &__p, v43, v44, v45, v54, *((_DWORD *)a3 + 5));
  if (__p)
  {
    v52 = __p;
    operator delete(__p);
  }
  return 1;
}

void CI::Context::endFrame(CI::Context *this)
{
  RegularizePriorityForContextEntries(*((_DWORD *)this + 36));
}

uint64_t CI::Context::blitSurface(CI::Context *this, __IOSurface *a2, IRect *a3, __IOSurface *a4, IRect *a5)
{
  OSType PixelFormat;
  uint64_t result;
  CI *v11;
  int v12;
  int v13;
  _QWORD v14[5];
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  int v19;

  PixelFormat = IOSurfaceGetPixelFormat(this);
  result = IOSurfaceGetPixelFormat((IOSurfaceRef)a3);
  if (PixelFormat == (_DWORD)result
    && *((_QWORD *)a2 + 1) == *((_QWORD *)a4 + 1)
    && *((_QWORD *)a2 + 2) == *((_QWORD *)a4 + 2))
  {
    v11 = (CI *)IOSurfaceGetPixelFormat(this);
    v12 = CI::format_from_PixelFormatType(v11);
    v13 = CI::format_bytes_per_pixel(v12);
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 0x40000000;
    v14[2] = ___ZN2CI7Context11blitSurfaceEP11__IOSurface5IRectS2_S3__block_invoke;
    v14[3] = &__block_descriptor_tmp_14_1;
    v14[4] = a3;
    v15 = *(_OWORD *)a4;
    v16 = *((_QWORD *)a4 + 2);
    v19 = v13;
    v17 = *(_OWORD *)a2;
    v18 = *((_QWORD *)a2 + 2);
    return SurfaceApplyPlaneBlock(this, (uint64_t)v14);
  }
  return result;
}

uint64_t ___ZN2CI7Context11blitSurfaceEP11__IOSurface5IRectS2_S3__block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __IOSurface *v6;
  _QWORD v8[4];
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  int v15;

  v6 = *(__IOSurface **)(a1 + 32);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = ___ZN2CI7Context11blitSurfaceEP11__IOSurface5IRectS2_S3__block_invoke_2;
  v8[3] = &__block_descriptor_tmp_12_2;
  v9 = *(_OWORD *)(a1 + 40);
  v15 = *(_DWORD *)(a1 + 88);
  v10 = *(_QWORD *)(a1 + 56);
  v11 = a2;
  v12 = *(_OWORD *)(a1 + 64);
  v13 = *(_QWORD *)(a1 + 80);
  v14 = a6;
  return SurfaceApplyPlaneReadOnlyBlock(v6, (uint64_t)v8);
}

CI::Context *CI::Context::assemble_leafTiles(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  double Current;
  IRect *v32;
  IRect *v33;
  int v34;
  BOOL v35;
  int v36;
  int v37;
  int v38;
  CI::Context *SurfaceFromCache;
  unint64_t v41;
  int v42;
  int v43;
  _DWORD v44[2];
  uint64_t v45;
  uint64_t v46;
  _DWORD v47[2];
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  __int128 v54;
  uint64_t v55;
  __int128 v56;
  uint64_t v57;
  char v58[9];

  v58[0] = 0;
  v56 = *(_OWORD *)a3;
  v57 = *(_QWORD *)(a3 + 16);
  v10 = (*(uint64_t (**)(_QWORD *))*a2)(a2);
  LODWORD(v54) = 0;
  v11 = (*(uint64_t (**)(_QWORD *))(*a1 + 616))(a1);
  v12 = a1[47];
  *((_QWORD *)&v54 + 1) = v11;
  v55 = v12;
  v13 = (*(uint64_t (**)(_QWORD *))(*a1 + 272))(a1);
  SurfaceFromCache = (CI::Context *)GetSurfaceFromCache(&v56, 1, 1, v10, &v54, v13, 0, -1, a4, (uint64_t)v58, 0);
  if (SurfaceFromCache)
    v14 = v58[0] == 0;
  else
    v14 = 1;
  if (!v14)
  {
    v16 = 0;
    v17 = (_QWORD *)a2[1];
    v18 = (_QWORD *)a2[2];
    while (1)
    {
      if (v17 == v18)
      {
        v20 = 0;
      }
      else
      {
        v19 = v17[1];
        if (*v17 == v19)
          v20 = 0;
        else
          v20 = 0xAAAAAAAAAAAAAAABLL * ((v19 - *v17) >> 3);
      }
      if (v16 >= v20)
        return SurfaceFromCache;
      v21 = 0;
      v41 = v16;
      while (1)
      {
        v22 = 0xAAAAAAAAAAAAAAABLL * (v18 - v17);
        if (v17 == v18)
          v22 = 0;
        if (v21 >= v22)
          break;
        v52 = 0;
        v53 = 0;
        v51 = 0;
        (*(void (**)(uint64_t *__return_ptr, _QWORD *, unint64_t, unint64_t))(*a2 + 16))(&v51, a2, v21, v16);
        v24 = v51;
        v23 = HIDWORD(v51);
        v26 = *(_DWORD *)a3;
        v25 = *(_DWORD *)(a3 + 4);
        v28 = *(_QWORD *)(a3 + 8);
        v27 = *(_QWORD *)(a3 + 16);
        if (v51 == 0x7FFFFFFF7FFFFFFFLL && !v52 && !v53 || v26 == 0x7FFFFFFF && v25 == 0x7FFFFFFF && !v28 && !v27)
          goto LABEL_51;
        if (v51 == 0x8000000180000001 && v52 == 0xFFFFFFFFLL && v53 == 0xFFFFFFFFLL)
        {
          v29 = *(_DWORD *)(a3 + 4);
          v30 = *(_DWORD *)a3;
          if (!v28)
            goto LABEL_51;
          goto LABEL_34;
        }
        if (v26 == -2147483647 && v25 == -2147483647 && v28 == 0xFFFFFFFFLL && v27 == 0xFFFFFFFFLL)
        {
          v27 = v53;
          v28 = v52;
          v29 = HIDWORD(v51);
          v30 = v51;
          if (!v52)
            goto LABEL_51;
LABEL_34:
          if (v27)
          {
            v42 = v29;
            v43 = v30;
            v50 = 0;
            Current = CFAbsoluteTimeGetCurrent();
            v32 = (IRect *)(*(uint64_t (**)(_QWORD *, unint64_t, unint64_t, uint64_t *))(*a2 + 8))(a2, v21, v16, &v50);
            *(double *)a6 = *(double *)a6 + CFAbsoluteTimeGetCurrent() - Current;
            *(_QWORD *)(a6 + 8) += v50;
            if (v32)
            {
              v47[0] = v43 - v26;
              v47[1] = v42 - v25;
              v48 = v28;
              v49 = v27;
              v44[0] = v43 - v24;
              v44[1] = v42 - v23;
              v45 = v28;
              v46 = v27;
              CI::Context::blitSurface(SurfaceFromCache, (__IOSurface *)v47, v32, (__IOSurface *)v44, v33);
              ReturnSurfaceToCache((uint64_t)v32);
            }
            v16 = v41;
          }
          goto LABEL_51;
        }
        if ((int)v51 <= v26)
          v30 = *(_DWORD *)a3;
        else
          v30 = v51;
        v34 = v51 + v52;
        if ((int)v51 + (int)v52 >= v26 + (int)v28)
          v34 = v26 + v28;
        v35 = __OFSUB__(v34, v30);
        v36 = v34 - v30;
        if (v36 < 0 == v35)
        {
          if (SHIDWORD(v51) <= v25)
            v29 = *(_DWORD *)(a3 + 4);
          else
            v29 = HIDWORD(v51);
          v37 = HIDWORD(v51) + v53;
          if (HIDWORD(v51) + (int)v53 >= v25 + (int)v27)
            v37 = v25 + v27;
          v35 = __OFSUB__(v37, v29);
          v38 = v37 - v29;
          if (v38 < 0 == v35)
          {
            v28 = v36;
            v27 = v38;
            if (v36)
              goto LABEL_34;
          }
        }
LABEL_51:
        ++v21;
        v17 = (_QWORD *)a2[1];
        v18 = (_QWORD *)a2[2];
      }
      ++v16;
    }
  }
  return SurfaceFromCache;
}

uint64_t CI::Context::bind_sampler(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, CI::TileTask *a6)
{
  CI::TextureManager *v12;
  CGImageRef *v13;
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  int v18;
  __IOSurface *v19;
  CGImageRef v20;
  CGImage *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  CGImageRef v26;
  CGImage *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  _BOOL8 v32;
  int v33;
  CGImageRef v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t intermediate_for_node;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  IOSurfaceRef v41;
  uint64_t v42;
  char v43;
  char v44;
  __IOSurface *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  CI::Context *v52;
  uint64_t v53;
  IOSurfaceRef v54;
  __IOSurface *empty_surface;
  CI *PixelFormat;
  __int128 v58;
  unint64_t v59;
  __int128 v60;
  unint64_t v61;
  IOSurfaceRef buffer;
  double v63;
  unint64_t v64;
  CGRect v65;
  CGRect v66;
  CGRect v67;
  CGRect v68;
  CGRect v69;
  CGRect v70;
  CGRect v71;
  CGRect v72;
  CGRect v73;
  CGRect v74;
  CGRect v75;
  CGRect v76;

  v12 = (CI::TextureManager *)(*(uint64_t (**)(_QWORD *))(*a1 + 112))(a1);
  v13 = *(CGImageRef **)(a2 + 24);
  v66.origin.x = CI::Node::roi(*(CI::Node **)a3, *(_DWORD *)(a3 + 8));
  x = v66.origin.x;
  y = v66.origin.y;
  width = v66.size.width;
  height = v66.size.height;
  v65 = v66;
  v63 = 0.0;
  v64 = 0;
  if (!CGRectIsEmpty(v66))
  {
    v18 = (*((uint64_t (**)(CGImageRef *))*v13 + 2))(v13);
    v19 = 0;
    switch(v18)
    {
      case ',':
        if (CI::CI_ASSEMBLE_INPUT_TILES(void)::didCheck != -1)
          dispatch_once(&CI::CI_ASSEMBLE_INPUT_TILES(void)::didCheck, &__block_literal_global_53_0);
        if (!CI::CI_ASSEMBLE_INPUT_TILES(void)::v)
          goto LABEL_34;
        v21 = v13[8];
        v20 = v13[9];
        if (v21 == v20)
        {
          v22 = 0;
        }
        else
        {
          v22 = 0xAAAAAAAAAAAAAAABLL * ((v20 - v21) >> 3);
          v24 = *(_QWORD *)v21;
          v23 = *((_QWORD *)v21 + 1);
          if (v24 != v23)
          {
            v25 = 0xAAAAAAAAAAAAAAABLL * ((v23 - v24) >> 3);
            goto LABEL_31;
          }
        }
        v25 = 0;
LABEL_31:
        if (v25 * v22 < 2)
        {
LABEL_34:
          v19 = (__IOSurface *)CI::ProviderNode::surfaceForROI((uint64_t)v13, a1, &v65.origin.x, (uint64_t)&v63);
          v43 = 0;
        }
        else
        {
          v67.origin.x = x;
          v67.origin.y = y;
          v67.size.width = width;
          v67.size.height = height;
          if (CGRectIsNull(v67))
          {
            v59 = 0;
            v58 = IRectNull;
          }
          else
          {
            v69.origin.x = x;
            v69.origin.y = y;
            v69.size.width = width;
            v69.size.height = height;
            if (CGRectIsInfinite(v69))
            {
              v58 = IRectInfinite;
              v59 = 0xFFFFFFFFLL;
            }
            else
            {
              v71.origin.x = x;
              v71.origin.y = y;
              v71.size.width = width;
              v71.size.height = height;
              v72 = CGRectInset(v71, 0.000001, 0.000001);
              v73 = CGRectIntegral(v72);
              LODWORD(v58) = (int)v73.origin.x;
              DWORD1(v58) = (int)v73.origin.y;
              *((_QWORD *)&v58 + 1) = (unint64_t)v73.size.width;
              v59 = (unint64_t)v73.size.height;
            }
          }
          v46 = (*((uint64_t (**)(CGImageRef *, _QWORD))*v13 + 55))(v13, a1[19]);
          v19 = CI::Context::assemble_leafTiles(a1, v13 + 7, (uint64_t)&v58, v46, v47, (uint64_t)&v63);
          v43 = 1;
        }
        v48 = CI::TextureManager::intermediate(v12, v19, &v65, 2uLL, 0, 1);
        CI::TextureManager::add_intermediate_for_node((uint64_t)v12, (_QWORD *)a3, v48);
        if (v19)
        {
          if (a5 == 3)
            v49 = 1;
          else
            v49 = *(unsigned int *)(a2 + 124);
          buffer = v13[6];
          BYTE5(buffer) = v43;
          v36 = (*(uint64_t (**)(_QWORD *, __IOSurface *, IOSurfaceRef *, _QWORD, _QWORD, uint64_t, uint64_t, BOOL, _QWORD, _QWORD, unint64_t))(*a1 + 72))(a1, v19, &buffer, *((unsigned __int8 *)v13 + 186), *(unsigned int *)(a2 + 120), v49, a4, a5 == 3, v58, *((_QWORD *)&v58 + 1), v59);
          goto LABEL_54;
        }
        return (uint64_t)v19;
      case '-':
      case '/':
      case '1':
      case '2':
      case '3':
        goto LABEL_65;
      case '.':
        v32 = a5 == 3;
        if (a5 == 3)
          v40 = 1;
        else
          v40 = *(unsigned int *)(a2 + 124);
        CI::SurfaceNode::surfaceForROI((uint64_t)v13, (uint64_t)a1, (uint64_t)&v63, &buffer, x, y, width, height);
        v19 = (__IOSurface *)(*(uint64_t (**)(_QWORD *, IOSurfaceRef, CGImageRef *, _QWORD, _QWORD, uint64_t, uint64_t, _BOOL8))(*a1 + 72))(a1, buffer, v13 + 6, *((unsigned __int8 *)v13 + 106), *(unsigned int *)(a2 + 120), v40, a4, v32);
        v41 = buffer;
        buffer = 0;
        if (!v41)
          goto LABEL_65;
        goto LABEL_64;
      case '0':
        v33 = (*((uint64_t (**)(CGImageRef *))*v13 + 53))(v13);
        v34 = *v13;
        if (v33)
        {
          v35 = (*((uint64_t (**)(CGImageRef *))v34 + 53))(v13);
          v36 = (*(uint64_t (**)(_QWORD *, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(*a1 + 80))(a1, v35, *((unsigned int *)v13 + 13), *(unsigned int *)(a2 + 120), *(unsigned int *)(a2 + 124), a4);
        }
        else
        {
          if (!(*((uint64_t (**)(CGImageRef *))v34 + 54))(v13))
          {
            v19 = 0;
            goto LABEL_65;
          }
          v42 = (*((uint64_t (**)(CGImageRef *))*v13 + 54))(v13);
          v36 = (*(uint64_t (**)(_QWORD *, uint64_t, _QWORD, _QWORD, uint64_t))(*a1 + 88))(a1, v42, *(unsigned int *)(a2 + 120), *(unsigned int *)(a2 + 124), a4);
        }
LABEL_54:
        v19 = (__IOSurface *)v36;
        goto LABEL_65;
      case '4':
        intermediate_for_node = CI::TextureManager::get_intermediate_for_node((uint64_t)v12, a3);
        if (((_BYTE)v13[18] & 4) != 0)
          (*(void (**)(CI::TextureManager *, uint64_t))(*(_QWORD *)v12 + 56))(v12, intermediate_for_node);
        v38 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)intermediate_for_node + 24))(intermediate_for_node);
        v36 = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(*a1 + 96))(a1, v38, v39, *(unsigned int *)(a2 + 120), *(unsigned int *)(a2 + 124), a4);
        goto LABEL_54;
      default:
        if (v18 != 29)
          goto LABEL_65;
        if (CI::CI_ASSEMBLE_INPUT_TILES(void)::didCheck != -1)
          dispatch_once(&CI::CI_ASSEMBLE_INPUT_TILES(void)::didCheck, &__block_literal_global_53_0);
        if (CI::CI_ASSEMBLE_INPUT_TILES(void)::v
          && ((v27 = v13[8], v26 = v13[9], v27 == v26)
            ? (v28 = 0, v31 = 0)
            : (v28 = 0xAAAAAAAAAAAAAAABLL * ((v26 - v27) >> 3),
               v30 = *(_QWORD *)v27,
               v29 = *((_QWORD *)v27 + 1),
               v30 != v29)
            ? (v31 = 0xAAAAAAAAAAAAAAABLL * ((v29 - v30) >> 3))
            : (v31 = 0),
              v31 * v28 >= 2))
        {
          v68.origin.x = x;
          v68.origin.y = y;
          v68.size.width = width;
          v68.size.height = height;
          if (CGRectIsNull(v68))
          {
            v61 = 0;
            v60 = IRectNull;
          }
          else
          {
            v70.origin.x = x;
            v70.origin.y = y;
            v70.size.width = width;
            v70.size.height = height;
            if (CGRectIsInfinite(v70))
            {
              v60 = IRectInfinite;
              v61 = 0xFFFFFFFFLL;
            }
            else
            {
              v74.origin.x = x;
              v74.origin.y = y;
              v74.size.width = width;
              v74.size.height = height;
              v75 = CGRectInset(v74, 0.000001, 0.000001);
              v76 = CGRectIntegral(v75);
              LODWORD(v60) = (int)v76.origin.x;
              DWORD1(v60) = (int)v76.origin.y;
              *((_QWORD *)&v60 + 1) = (unint64_t)v76.size.width;
              v61 = (unint64_t)v76.size.height;
            }
          }
          v50 = (*((uint64_t (**)(CGImageRef *, _QWORD))v13[7] + 3))(v13 + 7, 0);
          v52 = CI::Context::assemble_leafTiles(a1, v13 + 7, (uint64_t)&v60, v50, v51, (uint64_t)&v63);
          if (v52)
          {
            v45 = v52;
            CFRetain(v52);
            v44 = 1;
            goto LABEL_58;
          }
          v44 = 1;
        }
        else
        {
          v44 = 0;
        }
        CI::CGNode::surfaceForROI((uint64_t)v13, (uint64_t)a1, &v65.origin.x, (uint64_t)&v63, &buffer);
        v45 = buffer;
        if (!buffer)
          goto LABEL_60;
LABEL_58:
        if (IOSurfaceGetPlaneCount(v45) <= 1)
        {
          v53 = CI::TextureManager::intermediate(v12, v45, &v65, 2uLL, 0, 1);
          CI::TextureManager::add_intermediate_for_node((uint64_t)v12, (_QWORD *)a3, v53);
          buffer = v13[6];
          BYTE5(buffer) = v44;
          v19 = (__IOSurface *)(*(uint64_t (**)(_QWORD *, __IOSurface *, IOSurfaceRef *, _QWORD, _QWORD, _QWORD, uint64_t, _QWORD))(*a1 + 72))(a1, v45, &buffer, *((unsigned __int8 *)v13 + 153), *(unsigned int *)(a2 + 120), *(unsigned int *)(a2 + 124), a4, 0);
          goto LABEL_63;
        }
LABEL_60:
        CI::CGNode::cgImageForROI(v13, &v65, &buffer);
        v19 = (__IOSurface *)(*(uint64_t (**)(_QWORD *, IOSurfaceRef, CGImageRef *, _QWORD, _QWORD, uint64_t))(*a1 + 64))(a1, buffer, v13 + 6, *(unsigned int *)(a2 + 120), *(unsigned int *)(a2 + 124), a4);
        v54 = buffer;
        buffer = 0;
        if (v54)
          CFRelease(v54);
        if (!v45)
          goto LABEL_65;
LABEL_63:
        v41 = v45;
LABEL_64:
        CFRelease(v41);
LABEL_65:
        CI::TileTask::incrementFillTimeForNode(a6, (const CI::Node *)v13, v63);
        CI::TileTask::incrementFillPixelsForNode(a6, (const CI::Node *)v13, v64);
        if (CI_LIMIT_SAMPLERS())
          break;
        return (uint64_t)v19;
    }
  }
  empty_surface = CI::TextureManager::get_empty_surface(v12);
  PixelFormat = (CI *)IOSurfaceGetPixelFormat(empty_surface);
  LODWORD(buffer) = CI::format_from_PixelFormatType(PixelFormat);
  WORD2(buffer) = 0;
  return (*(uint64_t (**)(_QWORD *, __IOSurface *, IOSurfaceRef *, _QWORD, _QWORD, _QWORD, uint64_t, _QWORD))(*a1 + 72))(a1, empty_surface, &buffer, 0, *(unsigned int *)(a2 + 120), *(unsigned int *)(a2 + 124), a4, 0);
}

uint64_t CI::Context::kernel_argument_size(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t v4;

  result = 4;
  switch(a2)
  {
    case 2:
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 520))(a1, 10);
      break;
    case 3:
      v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 520))(a1, 10);
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 520))(a1, 6) + v4;
      break;
    case 5:
    case 13:
      return result;
    case 6:
    case 15:
      result = 8;
      break;
    case 7:
      result = 12;
      break;
    case 8:
    case 16:
    case 27:
    case 42:
    case 43:
    case 46:
    case 47:
      result = 16;
      break;
    case 9:
    case 18:
      result = 32;
      break;
    case 10:
    case 40:
    case 44:
      result = 48;
      break;
    case 11:
    case 41:
      result = 64;
      break;
    case 12:
      result = 2;
      break;
    case 14:
      result = 6;
      break;
    case 17:
      result = 24;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

BOOL CI::Context::format_is_supported_for_input(uint64_t a1, uint64_t a2)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = ___ZNK2CI7Context29format_is_supported_for_inputENS_11PixelFormatE_block_invoke;
  v3[3] = &__block_descriptor_tmp_16;
  v3[4] = a1;
  return CI::format_swizzle_for_input(a2, (uint64_t)v3) != 0;
}

uint64_t ___ZNK2CI7Context29format_is_supported_for_inputENS_11PixelFormatE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 424))(*(_QWORD *)(a1 + 32));
}

BOOL CI::Context::format_is_supported_for_output(uint64_t a1, uint64_t a2, int a3)
{
  int v6;
  _QWORD v8[5];
  int v9;
  int64x2_t v10[3];

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 576))(a1);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = ___ZNK2CI7Context30format_is_supported_for_outputENS_11PixelFormatENS_15DestinationTypeE_block_invoke;
  v8[3] = &__block_descriptor_tmp_17;
  v8[4] = a1;
  v9 = a3;
  CI::format_swizzle_for_output(a2, v6, (uint64_t)v8, v10);
  return v10[0].i32[0] != 0;
}

uint64_t ___ZNK2CI7Context30format_is_supported_for_outputENS_11PixelFormatENS_15DestinationTypeE_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 32) + 432))(*(_QWORD *)(a1 + 32), a2, *(unsigned int *)(a1 + 40));
}

uint64_t CI::Context::swizzler_for_input(uint64_t a1, uint64_t a2)
{
  _QWORD v3[5];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = ___ZNK2CI7Context18swizzler_for_inputENS_11PixelFormatE_block_invoke;
  v3[3] = &__block_descriptor_tmp_18_1;
  v3[4] = a1;
  return CI::format_swizzle_for_input(a2, (uint64_t)v3);
}

uint64_t ___ZNK2CI7Context18swizzler_for_inputENS_11PixelFormatE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 424))(*(_QWORD *)(a1 + 32));
}

void CI::Context::swizzler_for_output(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, int64x2_t *a4@<X8>)
{
  int v8;
  _QWORD v9[5];
  int v10;

  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 576))(a1);
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = ___ZNK2CI7Context19swizzler_for_outputENS_11PixelFormatENS_15DestinationTypeE_block_invoke;
  v9[3] = &__block_descriptor_tmp_19_0;
  v9[4] = a1;
  v10 = a3;
  CI::format_swizzle_for_output(a2, v8, (uint64_t)v9, a4);
}

uint64_t ___ZNK2CI7Context19swizzler_for_outputENS_11PixelFormatENS_15DestinationTypeE_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 32) + 432))(*(_QWORD *)(a1 + 32), a2, *(unsigned int *)(a1 + 40));
}

CGContext *CI::Context::set_cgcontext(CI::Context *this, CGContext *a2)
{
  CGContext *result;

  result = (CGContext *)*((_QWORD *)this + 6);
  if (result != a2)
  {
    CGContextRelease(result);
    result = CGContextRetain(a2);
    *((_QWORD *)this + 6) = result;
  }
  return result;
}

void CI::Context::cacheMainProgram(uint64_t a1, uint64_t a2, CI::Object *a3)
{
  CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::insert(*(_QWORD *)(a1 + 304), a2, a3, 1);
}

void CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::insert(uint64_t a1, uint64_t a2, CI::Object *this, int a4)
{
  _QWORD v8[7];
  int v9;

  if (this)
    CI::Object::ref((uint64_t)this);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = ___ZN2CI11ObjectCacheINS_11MainProgramENS_13ProgramDigestELb0EE6insertES2_PS1_j_block_invoke;
  v8[3] = &__block_descriptor_tmp_61;
  v8[4] = a1;
  v8[5] = a2;
  v8[6] = this;
  v9 = a4;
  Queue::execute_async((dispatch_queue_t *)(a1 + 56), v8);
}

uint64_t CI::Context::findCachedMainProgram(uint64_t a1, uint64_t a2)
{
  return CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::find(*(_QWORD *)(a1 + 304), a2);
}

uint64_t CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::find(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD block[7];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI11ObjectCacheINS_11MainProgramENS_13ProgramDigestELb0EE4findES2__block_invoke;
  block[3] = &unk_1E2EC68F0;
  block[5] = a1;
  block[6] = a2;
  block[4] = &v5;
  dispatch_sync(*(dispatch_queue_t *)(a1 + 56), block);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void CI::Context::updateColorSpace(CGColorSpaceRef *this, CGColorSpaceRef space)
{
  if (space)
  {
    if (this[2])
    {
      CGColorSpaceRetain(space);
      CGColorSpaceRelease(this[2]);
      this[2] = space;
    }
  }
}

void CI::Context::updateWorkingSpace(CGColorSpaceRef *this, CGColorSpaceRef space)
{
  if (space)
  {
    if (this[3])
    {
      CGColorSpaceRetain(space);
      CGColorSpaceRelease(this[3]);
      this[3] = space;
    }
  }
}

uint64_t CI::Context::defaultOutputRGBSpace(CI::Context *this)
{
  if (CI::Context::defaultOutputRGBSpace(void)::didCreate != -1)
    dispatch_once(&CI::Context::defaultOutputRGBSpace(void)::didCreate, &__block_literal_global_23_2);
  return CI::Context::defaultOutputRGBSpace(void)::space;
}

CGColorSpaceRef ___ZN2CI7Context21defaultOutputRGBSpaceEv_block_invoke()
{
  CGColorSpaceRef result;

  result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  CI::Context::defaultOutputRGBSpace(void)::space = (uint64_t)result;
  return result;
}

uint64_t CI::Context::defaultOutputGraySpace(CI::Context *this)
{
  if (CI::Context::defaultOutputGraySpace(void)::didCreate != -1)
    dispatch_once(&CI::Context::defaultOutputGraySpace(void)::didCreate, &__block_literal_global_25_1);
  return CI::Context::defaultOutputGraySpace(void)::space;
}

CGColorSpaceRef ___ZN2CI7Context22defaultOutputGraySpaceEv_block_invoke()
{
  CGColorSpaceRef result;

  result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
  CI::Context::defaultOutputGraySpace(void)::space = (uint64_t)result;
  return result;
}

uint64_t CI::Context::supported_compute_features(CI::Context *this)
{
  return 0;
}

void CI::SerialRectArray::recurseSubdivide(double *a1, int a2, void **a3)
{
  unint64_t v5;
  _OWORD *v6;
  __int128 v7;
  _OWORD *v8;
  float v9;
  float v10;
  double v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  __int128 *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  __int128 v21;
  char *v22;
  char *v23;
  __int128 v24;
  char *v25;
  char *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  double v31;
  double v32;

  if (a2 == 1)
  {
    v5 = (unint64_t)a3[2];
    v6 = a3[1];
    if ((unint64_t)v6 >= v5)
    {
      v16 = ((char *)v6 - (_BYTE *)*a3) >> 5;
      v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 59)
        abort();
      v18 = v5 - (_QWORD)*a3;
      if (v18 >> 4 > v17)
        v17 = v18 >> 4;
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0)
        v19 = 0x7FFFFFFFFFFFFFFLL;
      else
        v19 = v17;
      if (v19)
        v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<CI::SoftwareDAGDescriptor::ArgumentInfo>>((uint64_t)(a3 + 2), v19);
      else
        v20 = 0;
      v22 = &v20[32 * v16];
      v23 = &v20[32 * v19];
      v24 = *((_OWORD *)a1 + 1);
      *(_OWORD *)v22 = *(_OWORD *)a1;
      *((_OWORD *)v22 + 1) = v24;
      v8 = v22 + 32;
      v26 = (char *)*a3;
      v25 = (char *)a3[1];
      if (v25 != *a3)
      {
        do
        {
          v27 = *((_OWORD *)v25 - 1);
          *((_OWORD *)v22 - 2) = *((_OWORD *)v25 - 2);
          *((_OWORD *)v22 - 1) = v27;
          v22 -= 32;
          v25 -= 32;
        }
        while (v25 != v26);
        v25 = (char *)*a3;
      }
      *a3 = v22;
      a3[1] = v8;
      a3[2] = v23;
      if (v25)
        operator delete(v25);
    }
    else
    {
      v7 = *((_OWORD *)a1 + 1);
      *v6 = *(_OWORD *)a1;
      v6[1] = v7;
      v8 = v6 + 2;
    }
    a3[1] = v8;
  }
  else
  {
    v9 = a1[2];
    v10 = a1[3];
    if (v9 <= v10)
    {
      v21 = *(_OWORD *)a1;
      v29 = *((_OWORD *)a1 + 1);
      v30 = v21;
      v31 = a1[2];
      v32 = floor(v10 * 0.5 * 0.25) * 4.0;
      v28 = *(_OWORD *)a1;
      *((double *)&v28 + 1) = v32 + *((double *)&v28 + 1);
      *((double *)&v29 + 1) = v10 - v32;
      v14 = (a2 >> 1);
      CI::SerialRectArray::recurseSubdivide(&v28, v14, a3);
      v15 = &v30;
    }
    else
    {
      v11 = v9;
      v12 = *((_OWORD *)a1 + 1);
      v30 = *(_OWORD *)a1;
      v32 = *((double *)&v12 + 1);
      v31 = floor(v11 * 0.5 * 0.25) * 4.0;
      v13 = *((_OWORD *)a1 + 1);
      v28 = *(_OWORD *)a1;
      *((_QWORD *)&v29 + 1) = *((_QWORD *)&v13 + 1);
      *(double *)&v28 = v31 + *(double *)&v28;
      *(double *)&v29 = v11 - v31;
      v14 = (a2 >> 1);
      CI::SerialRectArray::recurseSubdivide(&v30, v14, a3);
      v15 = &v28;
    }
    CI::SerialRectArray::recurseSubdivide(v15, v14, a3);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<CI::parentROI>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(48 * a2);
}

uint64_t ___ZN2CIL26dump_intermediate_for_nodeEPKNS_11ProgramNodeEPKNS_14intermediate_tEP16dispatch_group_s_block_invoke()
{
  uint64_t result;

  CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::sRGB = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::sRGBLinear = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA00]);
  CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::dumpPngImages = CI_PRINT_TREE_dump_intermediates();
  CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::dumpRawImages = CI_PRINT_TREE_dump_raw_intermediates();
  result = CI_PRINT_TREE_dump_bmtl_intermediates();
  CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::dumpBmtlImages = result;
  return result;
}

void ___ZN2CIL26dump_intermediate_for_nodeEPKNS_11ProgramNodeEPKNS_14intermediate_tEP16dispatch_group_s_block_invoke_2(uint64_t a1)
{
  char *v2;
  pid_t v3;
  NSObject *v4;
  char *v5;
  pid_t v6;
  NSObject *v7;
  char *v8;
  pid_t v9;
  NSObject *v10;
  void *v11;
  uint8_t buf[4];
  char *v13;
  char __str[256];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  dispatch_group_wait(*(dispatch_group_t *)(a1 + 40), 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
  if (CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::dumpPngImages)
  {
    v2 = CI_TEMP_DIR();
    v3 = getpid();
    snprintf(__str, 0x100uLL, "%s/%d_intermediate_%d_%d_%d_%d_%d.png", v2, v3, *(_DWORD *)(a1 + 96), *(_DWORD *)(a1 + 100), *(_DWORD *)(a1 + 104), *(_DWORD *)(a1 + 108), *(_DWORD *)(a1 + 112));
    if (SurfaceCroppedWriteToFile(*(__IOSurface **)(a1 + 48), *(CGColorSpace **)(a1 + 56), __str, *(CGFloat *)(a1 + 80), *(CGFloat *)(a1 + 88)))
    {
      v4 = ci_logger_render();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v13 = __str;
        _os_log_impl(&dword_1921E4000, v4, OS_LOG_TYPE_DEFAULT, "Dumped intermediate to: %{public}s\n", buf, 0xCu);
      }
    }
  }
  if (CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::dumpRawImages)
  {
    v5 = CI_TEMP_DIR();
    v6 = getpid();
    snprintf(__str, 0x100uLL, "%s/%d_intermediate_%d_%d_%d_%d_%d.raw", v5, v6, *(_DWORD *)(a1 + 96), *(_DWORD *)(a1 + 100), *(_DWORD *)(a1 + 104), *(_DWORD *)(a1 + 108), *(_DWORD *)(a1 + 112));
    if (SurfaceCroppedWriteRawToFile(*(__IOSurface **)(a1 + 48), __str, *(double *)(a1 + 80), *(double *)(a1 + 88)))
    {
      v7 = ci_logger_render();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v13 = __str;
        _os_log_impl(&dword_1921E4000, v7, OS_LOG_TYPE_DEFAULT, "Dumped raw intermediate to: %{public}s\n", buf, 0xCu);
      }
    }
  }
  if (CI::dump_intermediate_for_node(CI::ProgramNode const*,CI::intermediate_t const*,dispatch_group_s *)::dumpBmtlImages)
  {
    v8 = CI_TEMP_DIR();
    v9 = getpid();
    snprintf(__str, 0x100uLL, "%s/%d_%s_%d_%d_%d_%d_%d.bmtl", v8, v9, *(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), *(_DWORD *)(a1 + 96), *(_DWORD *)(a1 + 100), *(_DWORD *)(a1 + 104), *(_DWORD *)(a1 + 108), *(_DWORD *)(a1 + 112));
    if (SurfaceCroppedWriteBmtlToFile(*(__IOSurface **)(a1 + 48), __str, *(double *)(a1 + 80), *(double *)(a1 + 88)))
    {
      v10 = ci_logger_render();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v13 = __str;
        _os_log_impl(&dword_1921E4000, v10, OS_LOG_TYPE_DEFAULT, "Dumped bmtl intermediate to: %{public}s\n", buf, 0xCu);
      }
    }
  }
  v11 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v11)
  {
    free(v11);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
  ReturnSurfaceToCache(*(_QWORD *)(a1 + 48));
  ReturnSurfaceToCache(*(_QWORD *)(a1 + 48));
}

uint64_t ___ZN2CIL23CI_ASSEMBLE_INPUT_TILESEv_block_invoke()
{
  char *v0;
  uint64_t result;

  v0 = getenv("CI_ASSEMBLE_INPUT_TILES");
  if (v0)
    result = atoi(v0);
  else
    result = CI::CI_ASSEMBLE_INPUT_TILES(void)::v;
  CI::CI_ASSEMBLE_INPUT_TILES(void)::v = result;
  return result;
}

uint64_t CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::ObjectCache(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  NSObject *v5;

  *(_QWORD *)a1 = a2;
  v4 = a1 + 16;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 1065353216;
  v5 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *(_QWORD *)(a1 + 56) = dispatch_queue_create("CI::ObjectCacheQ", v5);
  *(_QWORD *)(a1 + 64) = dispatch_group_create();
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>(v4, vcvtps_u32_f32((float)a2 / *(float *)(a1 + 48)));
  return a1;
}

uint64_t CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::~ObjectCache(uint64_t a1)
{
  NSObject **v2;
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI11ObjectCacheINS_11MainProgramENS_13ProgramDigestELb0EED2Ev_block_invoke;
  block[3] = &__block_descriptor_tmp_56;
  block[4] = a1;
  v2 = (NSObject **)(a1 + 56);
  dispatch_sync(*(dispatch_queue_t *)(a1 + 56), block);
  Queue::~Queue(v2);
  std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::~__hash_table(a1 + 16);
  return a1;
}

void ___ZN2CI11ObjectCacheINS_11MainProgramENS_13ProgramDigestELb0EED2Ev_block_invoke(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::clear(*(_QWORD *)(a1 + 32) + 16);
}

void std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry::~Entry((uint64_t)(v2 + 3));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry::~Entry(uint64_t a1)
{
  CI::Object *v2;
  _QWORD v4[5];

  if (*(_BYTE *)(a1 + 16))
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = ___ZN2CI11ObjectCacheINS_11MainProgramENS_13ProgramDigestELb0EE5EntryD2Ev_block_invoke;
    v4[3] = &__block_descriptor_tmp_57;
    v4[4] = a1;
    CI::Object::performDeferredRoot(v4);
  }
  else
  {
    v2 = *(CI::Object **)a1;
    if (*(_QWORD *)a1)
      CI::Object::unref(v2);
  }
  return a1;
}

void ___ZN2CI11ObjectCacheINS_11MainProgramENS_13ProgramDigestELb0EE5EntryD2Ev_block_invoke(uint64_t a1)
{
  CI::Object *v1;

  v1 = **(CI::Object ***)(a1 + 32);
  if (v1)
    CI::Object::unref(v1);
}

uint64_t std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

uint64_t CI::ObjectCache<CI::Node,unsigned long long,false>::~ObjectCache(uint64_t a1)
{
  NSObject **v2;
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN2CI11ObjectCacheINS_4NodeEyLb0EED2Ev_block_invoke;
  block[3] = &__block_descriptor_tmp_58;
  block[4] = a1;
  v2 = (NSObject **)(a1 + 56);
  dispatch_sync(*(dispatch_queue_t *)(a1 + 56), block);
  Queue::~Queue(v2);
  std::__hash_table<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>>>::~__hash_table(a1 + 16);
  return a1;
}

void ___ZN2CI11ObjectCacheINS_4NodeEyLb0EED2Ev_block_invoke(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>>>::clear(*(_QWORD *)(a1 + 32) + 16);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      CI::ObjectCache<CI::Node,unsigned long long,false>::Entry::~Entry((uint64_t)(v2 + 3));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t CI::ObjectCache<CI::Node,unsigned long long,false>::Entry::~Entry(uint64_t a1)
{
  CI::Object *v2;
  _QWORD v4[5];

  if (*(_BYTE *)(a1 + 16))
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = ___ZN2CI11ObjectCacheINS_4NodeEyLb0EE5EntryD2Ev_block_invoke;
    v4[3] = &__block_descriptor_tmp_59;
    v4[4] = a1;
    CI::Object::performDeferredRoot(v4);
  }
  else
  {
    v2 = *(CI::Object **)a1;
    if (*(_QWORD *)a1)
      CI::Object::unref(v2);
  }
  return a1;
}

void ___ZN2CI11ObjectCacheINS_4NodeEyLb0EE5EntryD2Ev_block_invoke(uint64_t a1)
{
  CI::Object *v1;

  v1 = **(CI::Object ***)(a1 + 32);
  if (v1)
    CI::Object::unref(v1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void ___ZN2CI11ObjectCacheINS_4NodeEyLb0EE5clearEv_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  std::__hash_table<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,CI::ObjectCache<CI::Node,unsigned long long,false>::Entry>>>::clear(v1 + 16);
  *(_QWORD *)(v1 + 8) = 0;
}

void std::__tree<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey,CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::compareDepth,std::allocator<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey,CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::compareDepth,std::allocator<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey>>::destroy(*a1);
    std::__tree<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey,CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::compareDepth,std::allocator<CI::Context::recursive_render(CI::TileTask *,CI::roiKey const&,CI::Node *,BOOL)::childKey>>::destroy(a1[1]);
    operator delete(a1);
  }
}

uint64_t CI::SerialRectArray::maxParentDistance(CI::SerialRectArray *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  unsigned int v16;
  unsigned int v17;

  v1 = *(_QWORD *)this;
  v2 = *((_QWORD *)this + 1);
  v3 = v2 - *(_QWORD *)this;
  if (v2 == *(_QWORD *)this)
    return 0;
  v4 = 0;
  result = 0;
  v6 = v3 / 120;
  if (v6 <= 1)
    v6 = 1;
  do
  {
    v7 = v1 + 120 * v4;
    v8 = *(_QWORD *)(v7 + 32);
    v9 = *(_QWORD *)(v7 + 40);
    if (v8 == v9)
    {
      v10 = 0;
    }
    else
    {
      v10 = 0;
      v11 = v8;
      do
      {
        if (v10 <= *(_DWORD *)(v11 + 40))
          v10 = *(_DWORD *)(v11 + 40);
        v11 += 48;
      }
      while (v11 != v9);
    }
    v12 = v1 + 120 * v4;
    v13 = *(_QWORD *)(v12 + 56);
    v14 = *(_QWORD *)(v12 + 64);
    for (i = v13; i != v14; i += 48)
    {
      if (v10 <= *(_DWORD *)(i + 40))
        v10 = *(_DWORD *)(i + 40);
    }
    if (result <= v10)
    {
      if (v8 == v9)
      {
        result = 0;
      }
      else
      {
        LODWORD(result) = 0;
        do
        {
          v16 = *(_DWORD *)(v8 + 40);
          if (result <= v16)
            result = v16;
          else
            result = result;
          v8 += 48;
        }
        while (v8 != v9);
      }
      while (v13 != v14)
      {
        v17 = *(_DWORD *)(v13 + 40);
        if (result <= v17)
          result = v17;
        else
          result = result;
        v13 += 48;
      }
    }
    ++v4;
  }
  while (v4 != v6);
  return result;
}

void ___ZN2CI11ObjectCacheINS_11MainProgramENS_13ProgramDigestELb0EE6insertES2_PS1_j_block_invoke(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  CI::Object *v5;
  CI::Object *v6;
  __int128 v7;
  _QWORD *v8;
  _QWORD *v9;

  v2 = (_QWORD *)a1[4];
  ++v2[1];
  v3 = a1 + 5;
  v4 = std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::find<unsigned long long>(v2 + 2, a1 + 5);
  if (v4)
  {
    v4[4] = v2[1];
    v5 = (CI::Object *)a1[6];
    if (v5)
      CI::Object::unref(v5);
  }
  else
  {
    if (v2[5] == *v2)
      CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::evict((uint64_t)v2);
    *(_QWORD *)&v7 = a1 + 6;
    *((_QWORD *)&v7 + 1) = v2 + 1;
    v8 = a1 + 7;
    v9 = v3;
    std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__emplace_unique_impl<std::piecewise_construct_t const&,std::tuple<CI::ProgramDigest const&>,std::tuple<CI::MainProgram* const&,unsigned long long &,unsigned int const&>>(v2 + 2, (uint64_t)&std::piecewise_construct, &v9, &v7);
    v6 = (CI::Object *)a1[6];
    if (v6)
      CI::Object::unref(v6);
  }
}

void CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::evict(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  _BYTE v3[24];

  v1 = *(_QWORD **)(a1 + 32);
  if (v1)
  {
    v2 = *(_QWORD **)(a1 + 32);
    do
    {
      if (v2[4] < v1[4])
        v1 = v2;
      v2 = (_QWORD *)*v2;
    }
    while (v2);
  }
  std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::remove((_QWORD *)(a1 + 16), v1, (uint64_t)v3);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,void *>>>>::reset[abi:nn180100]((uint64_t)v3, 0);
}

_QWORD *std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::remove@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  v6 = *(_QWORD **)(*result + 8 * v4);
  do
  {
    v7 = v6;
    v6 = (_QWORD *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2)
    goto LABEL_18;
  v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(_QWORD *)&v3)
      v8 %= *(_QWORD *)&v3;
  }
  else
  {
    v8 &= *(_QWORD *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2)
      goto LABEL_19;
    v9 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v3)
        v9 %= *(_QWORD *)&v3;
    }
    else
    {
      v9 &= *(_QWORD *)&v3 - 1;
    }
    if (v9 != v4)
LABEL_19:
      *(_QWORD *)(*result + 8 * v4) = 0;
  }
  v10 = *a2;
  if (*a2)
  {
    v11 = *(_QWORD *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v3)
        v11 %= *(_QWORD *)&v3;
    }
    else
    {
      v11 &= *(_QWORD *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(_QWORD *)(*result + 8 * v11) = v7;
      v10 = *a2;
    }
  }
  *v7 = v10;
  *a2 = 0;
  --result[3];
  *(_QWORD *)a3 = a2;
  *(_QWORD *)(a3 + 8) = result + 2;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,void *>>>>::reset[abi:nn180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry::~Entry((uint64_t)v2 + 24);
    operator delete(v2);
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__emplace_unique_impl<std::piecewise_construct_t const&,std::tuple<CI::ProgramDigest const&>,std::tuple<CI::MainProgram* const&,unsigned long long &,unsigned int const&>>(_QWORD *a1, uint64_t a2, _QWORD **a3, __int128 *a4)
{
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *inserted;
  char v11;
  _QWORD v13[2];
  char v14;
  __int128 v15;
  uint64_t v16;

  v7 = a1 + 2;
  v8 = operator new(0x30uLL);
  v13[0] = v8;
  v13[1] = v7;
  *v8 = 0;
  v8[1] = 0;
  v9 = *a3;
  v15 = *a4;
  v16 = *((_QWORD *)a4 + 2);
  std::pair<CI::ProgramDigest const,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>::pair[abi:nn180100]<CI::ProgramDigest const&,CI::MainProgram* const&,unsigned long long &,unsigned int const&>((uint64_t)(v8 + 2), v9, (uint64_t)&v15);
  v14 = 1;
  v8[1] = v8[2];
  inserted = std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__node_insert_unique(a1, v8);
  if ((v11 & 1) != 0)
    v13[0] = 0;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,void *>>>>::reset[abi:nn180100]((uint64_t)v13, 0);
  return inserted;
}

_QWORD *std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__node_insert_unique(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;

  v2 = a2;
  v5 = a2 + 2;
  v4 = a2[2];
  *(v5 - 1) = v4;
  v6 = std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__node_insert_unique_prepare[abi:nn180100]((uint64_t)a1, v4, v5);
  if (v6)
    return v6;
  std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__node_insert_unique_perform[abi:nn180100](a1, v2);
  return v2;
}

uint64_t std::pair<CI::ProgramDigest const,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>::pair[abi:nn180100]<CI::ProgramDigest const&,CI::MainProgram* const&,unsigned long long &,unsigned int const&>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;

  *(_QWORD *)a1 = *a2;
  v4 = **(_QWORD **)a3;
  v5 = **(_QWORD **)(a3 + 8);
  v6 = **(_DWORD **)(a3 + 16);
  if (v4)
    v4 = CI::Object::ref(v4);
  *(_QWORD *)(a1 + 8) = v4;
  *(_QWORD *)(a1 + 16) = v5;
  *(_BYTE *)(a1 + 24) = v6 > 0x40;
  return a1;
}

_QWORD *std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__node_insert_unique_prepare[abi:nn180100](uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  uint8x8_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *i;
  unint64_t v8;
  float v9;
  float v10;
  uint64_t v11;
  _BOOL8 v12;
  size_t v13;
  unint64_t v14;
  size_t v15;

  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    v4 = (uint8x8_t)vcnt_s8((int8x8_t)v3);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
      v5 = v3 <= a2 ? a2 % v3 : a2;
    else
      v5 = (v3 - 1) & a2;
    v6 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v5);
    if (v6)
    {
      for (i = (_QWORD *)*v6; i; i = (_QWORD *)*i)
      {
        v8 = i[1];
        if (v8 == a2)
        {
          if (i[2] == *a3)
            return i;
        }
        else
        {
          if (v4.u32[0] > 1uLL)
          {
            if (v8 >= v3)
              v8 %= v3;
          }
          else
          {
            v8 &= v3 - 1;
          }
          if (v8 != v5)
            break;
        }
      }
    }
  }
  v9 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v10 = *(float *)(a1 + 32);
  if (!v3 || (float)(v10 * (float)v3) < v9)
  {
    v11 = 2 * v3;
    v12 = v3 < 3 || (v3 & (v3 - 1)) != 0;
    v13 = v12 | v11;
    v14 = vcvtps_u32_f32(v9 / v10);
    if (v13 <= v14)
      v15 = v14;
    else
      v15 = v13;
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>(a1, v15);
  }
  return 0;
}

_QWORD *std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::__node_insert_unique_perform[abi:nn180100](_QWORD *result, _QWORD *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  _QWORD *v5;
  unint64_t v6;

  v2 = (int8x8_t)result[1];
  v3 = a2[1];
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    if (v3 >= *(_QWORD *)&v2)
      v3 %= *(_QWORD *)&v2;
  }
  else
  {
    v3 &= *(_QWORD *)&v2 - 1;
  }
  v5 = *(_QWORD **)(*result + 8 * v3);
  if (v5)
  {
    *a2 = *v5;
LABEL_13:
    *v5 = a2;
    goto LABEL_14;
  }
  *a2 = result[2];
  result[2] = a2;
  *(_QWORD *)(*result + 8 * v3) = result + 2;
  if (*a2)
  {
    v6 = *(_QWORD *)(*a2 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v6 >= *(_QWORD *)&v2)
        v6 %= *(_QWORD *)&v2;
    }
    else
    {
      v6 &= *(_QWORD *)&v2 - 1;
    }
    v5 = (_QWORD *)(*result + 8 * v6);
    goto LABEL_13;
  }
LABEL_14:
  ++result[3];
  return result;
}

uint64_t ___ZN2CI11ObjectCacheINS_11MainProgramENS_13ProgramDigestELb0EE4findES2__block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;

  v2 = a1[5];
  result = (uint64_t)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::find<unsigned long long>((_QWORD *)(v2 + 16), a1 + 6);
  if (result)
  {
    v4 = *(_QWORD *)(v2 + 8) + 1;
    *(_QWORD *)(v2 + 8) = v4;
    *(_QWORD *)(result + 32) = v4;
    result = *(_QWORD *)(result + 24);
    if (result)
      result = CI::Object::ref(result);
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  }
  return result;
}

void ___ZN2CI11ObjectCacheINS_11MainProgramENS_13ProgramDigestELb0EE5clearEv_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  std::__hash_table<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::__unordered_map_hasher<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::hash<CI::ProgramDigest>,std::equal_to<CI::ProgramDigest>,true>,std::__unordered_map_equal<CI::ProgramDigest,std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>,std::equal_to<CI::ProgramDigest>,std::hash<CI::ProgramDigest>,true>,std::allocator<std::__hash_value_type<CI::ProgramDigest,CI::ObjectCache<CI::MainProgram,CI::ProgramDigest,false>::Entry>>>::clear(v1 + 16);
  *(_QWORD *)(v1 + 8) = 0;
}

const char *CI::name_for_conversion(unsigned int a1)
{
  if (a1 > 0x34)
    return "unknown-conversion";
  else
    return off_1E2EC6A20[a1];
}

const __CFString *CI::cfname_for_conversion(unsigned int a1)
{
  if (a1 > 0x34)
    return CFSTR("unknown-conversion");
  else
    return (const __CFString *)*((_QWORD *)&off_1E2EC6BC8 + (int)a1);
}

uint64_t CI::conversion_is_alpha_one(unsigned int a1)
{
  return (a1 < 0x35) & (0x1FFFFFFFFFFE1EuLL >> a1);
}

void CI::convert_buffer_to_texture(uint64_t a1, __IOSurface *a2, uint64_t a3, uint64_t a4, int8x16_t *a5, __IOSurface *a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  __IOSurface *v16;
  uint64_t v17;
  CIMetalConverter *v18;
  void *v19;
  const char *v20;
  void *v21;
  const char *v22;
  uint64_t v23;
  void *v24;
  void *v25;
  unint64_t BaseAddress;
  unint64_t MemorySize;
  unsigned __int8 v28;
  uint64_t v29;
  unint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  NSObject *v35;
  void *v36;
  void *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  NSObject *v41;
  void *v42;
  uint64_t v43;
  size_t BytesPerRow;
  size_t Width;
  size_t Height;
  void *v47;
  void *v48;
  uint64_t v49;
  _QWORD v50[6];
  int8x16_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unsigned int v55;
  _QWORD v56[8];
  int v57;
  unsigned int v58;
  _QWORD v59[10];
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  __n128 (*v64)(uint64_t, uint64_t);
  uint64_t (*v65)();
  const char *v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  __n128 (*v72)(uint64_t, uint64_t);
  uint64_t (*v73)();
  const char *v74;
  __int128 v75;
  __int128 v76;
  _QWORD v77[5];
  _QWORD v78[3];
  uint8_t buf[4];
  const char *v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  if (CI_ENABLE_METAL_CONVERT())
  {
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) == 77)
    {
      v49 = a7;
      v17 = CI::MetalContext::device((id *)a1);
      if (v17)
      {
        if (*(_QWORD *)(a1 + 1792))
        {
          v47 = *(void **)(a1 + 1792);
          v48 = (void *)v17;
          v18 = [CIMetalConverter alloc];
          v19 = (void *)MEMORY[0x1E0CB3940];
          v20 = CI::name_for_conversion(a9);
          v21 = v19;
          v22 = v20;
          v23 = -[CIMetalConverter initWithDevice:kernelName:](v18, "initWithDevice:kernelName:", v48, objc_msgSend(v21, "stringWithUTF8String:"));
          if (v23)
          {
            v24 = (void *)v23;
            v25 = (void *)objc_msgSend(v48, "newBufferWithBytes:length:options:", a5[4].i64[1], CI::Bitmap::length((CI::Bitmap *)a5), 0);
            BaseAddress = (unint64_t)IOSurfaceGetBaseAddress(a6);
            MemorySize = SurfaceGetMemorySize(a6);
            if ((v28 & 1) == 0
            {
              CI::convert_metal(CI::MetalContext const*,CI::Bitmap const&,__IOSurface *,CI::Texture,CI::ConvertType)::sPageSize = getpagesize();
            }
            v29 = CI::convert_metal(CI::MetalContext const*,CI::Bitmap const&,__IOSurface *,CI::Texture,CI::ConvertType)::sPageSize
                - 1;
            if ((CI::convert_metal(CI::MetalContext const*,CI::Bitmap const&,__IOSurface *,CI::Texture,CI::ConvertType)::sPageSize & (CI::convert_metal(CI::MetalContext const*,CI::Bitmap const&,__IOSurface *,CI::Texture,CI::ConvertType)::sPageSize - 1)) != 0)
            {
              if (BaseAddress
                 % CI::convert_metal(CI::MetalContext const*,CI::Bitmap const&,__IOSurface *,CI::Texture,CI::ConvertType)::sPageSize)
              {
                goto LABEL_19;
              }
              v30 = MemorySize
                  % CI::convert_metal(CI::MetalContext const*,CI::Bitmap const&,__IOSurface *,CI::Texture,CI::ConvertType)::sPageSize;
            }
            else
            {
              if ((v29 & BaseAddress) != 0)
                goto LABEL_19;
              v30 = v29 & MemorySize;
            }
            if (!v30)
            {
              v36 = v24;
              v41 = ci_logger_performance();
              if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)buf = 136446210;
                v80 = v22;
                _os_log_impl(&dword_1921E4000, v41, OS_LOG_TYPE_INFO, "CI_CONVERSION: (Metal) %{public}s_buffer", buf, 0xCu);
              }
              IOSurfaceLock(a6, 2u, 0);
              v37 = v47;
              CFRetain(a6);
              v69 = MEMORY[0x1E0C809B0];
              v70 = 3221225472;
              v71 = (uint64_t)___ZN2CIL13convert_metalEPKNS_12MetalContextERKNS_6BitmapEP11__IOSurfaceNS_7TextureENS_11ConvertTypeE_block_invoke;
              v72 = (__n128 (*)(uint64_t, uint64_t))&__block_descriptor_40_e12_v24__0_v8Q16l;
              v73 = (uint64_t (*)())a6;
              v42 = (void *)objc_msgSend(v48, "newBufferWithBytesNoCopy:length:options:deallocator:", BaseAddress, MemorySize, 0, &v69);
              v43 = a5[6].i64[0];
              BytesPerRow = IOSurfaceGetBytesPerRow(a6);
              Width = IOSurfaceGetWidth(a6);
              Height = IOSurfaceGetHeight(a6);
              v78[0] = Width;
              v78[1] = Height;
              v78[2] = 0;
              objc_msgSend(v36, "encodeToCommandBuffer:sourceBuffer:sourceRowBytes:destinationBuffer:destinationRowBytes:destinationSize:", v47, v25, v43, v42, BytesPerRow, v78);

              IOSurfaceUnlock(a6, 2u, 0);
              goto LABEL_22;
            }
LABEL_19:
            v35 = ci_logger_performance();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136446210;
              v80 = v22;
              _os_log_impl(&dword_1921E4000, v35, OS_LOG_TYPE_INFO, "CI_CONVERSION: (Metal) %{public}s_texture", buf, 0xCu);
            }
            v36 = v24;
            v37 = v47;
            objc_msgSend(v24, "encodeToCommandBuffer:sourceBuffer:sourceRowBytes:destinationTexture:", v47, v25, a5[6].i64[0], v49);
LABEL_22:
            if (CI_KDEBUG())
            {
              v38 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
              v39 = MEMORY[0x1E0C809B0];
              v40 = v38;
              v61 = MEMORY[0x1E0C809B0];
              v62 = 3221225472;
              v63 = (uint64_t)___ZN2CIL13convert_metalEPKNS_12MetalContextERKNS_6BitmapEP11__IOSurfaceNS_7TextureENS_11ConvertTypeE_block_invoke_170;
              v64 = (__n128 (*)(uint64_t, uint64_t))&__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
              v65 = (uint64_t (*)())v38;
              objc_msgSend(v37, "addScheduledHandler:", &v61);
              v77[0] = v39;
              v77[1] = 3221225472;
              v77[2] = ___ZN2CIL13convert_metalEPKNS_12MetalContextERKNS_6BitmapEP11__IOSurfaceNS_7TextureENS_11ConvertTypeE_block_invoke_173;
              v77[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
              v77[4] = v40;
              objc_msgSend(v37, "addCompletedHandler:", v77);
            }

            return;
          }
        }
      }
    }
  }
  if (a2 && (v31 = CI::format_from_IOSurface(a2, v16), a6))
  {
    v32 = v31;
    if (IOSurfaceGetPlaneCount(a2) < 2)
    {
      v56[0] = MEMORY[0x1E0C809B0];
      v56[1] = 3221225472;
      v56[2] = ___ZN2CI25convert_buffer_to_textureEPNS_7ContextEP11__IOSurfacexxRKNS_6BitmapES3_NS_7TextureENS_11ConvertTypeE_block_invoke_3;
      v56[3] = &__block_descriptor_72_e21_v48__0_v8Q16Q24Q32Q40l;
      v56[4] = a2;
      v56[5] = a4;
      v56[6] = a3;
      v56[7] = a1;
      v57 = v32;
      v58 = a9;
      SurfaceApplyPlaneBlock(a6, (uint64_t)v56);
    }
    else
    {
      v69 = 0;
      v70 = (uint64_t)&v69;
      v71 = 0x5012000000;
      v72 = __Block_byref_object_copy__22;
      v73 = __Block_byref_object_dispose__22;
      v74 = "";
      v75 = 0u;
      v76 = 0u;
      v61 = 0;
      v62 = (uint64_t)&v61;
      v63 = 0x5012000000;
      v64 = __Block_byref_object_copy__22;
      v65 = __Block_byref_object_dispose__22;
      v66 = "";
      v67 = 0u;
      v68 = 0u;
      v59[0] = MEMORY[0x1E0C809B0];
      v59[1] = 3221225472;
      v59[2] = ___ZN2CI25convert_buffer_to_textureEPNS_7ContextEP11__IOSurfacexxRKNS_6BitmapES3_NS_7TextureENS_11ConvertTypeE_block_invoke;
      v59[3] = &unk_1E2EC6960;
      v59[4] = &v69;
      v59[5] = &v61;
      v59[6] = a2;
      v59[7] = a1;
      v59[8] = a3;
      v59[9] = a4;
      v60 = a9;
      SurfaceApplyPlaneBlock(a6, (uint64_t)v59);
      _Block_object_dispose(&v61, 8);
      _Block_object_dispose(&v69, 8);
    }
  }
  else
  {
    v33 = a5[4].i64[1];
    v34 = a5[6].i64[0];
    v50[0] = MEMORY[0x1E0C809B0];
    v50[1] = 3221225472;
    v50[2] = ___ZN2CI25convert_buffer_to_textureEPNS_7ContextEP11__IOSurfacexxRKNS_6BitmapES3_NS_7TextureENS_11ConvertTypeE_block_invoke_5;
    v50[3] = &__block_descriptor_92_e21_v48__0_v8Q16Q24Q32Q40l;
    v50[4] = a1;
    v50[5] = v33;
    v51 = vextq_s8(a5[5], a5[5], 8uLL);
    v52 = v34;
    v53 = a3;
    v54 = a4;
    v55 = a9;
    SurfaceApplyPlaneBlock(a6, (uint64_t)v50);
  }
}

void sub_1923F275C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  _Block_object_dispose(&a45, 8);
  _Block_object_dispose(&a55, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__22(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

uint64_t ___ZN2CI25convert_buffer_to_textureEPNS_7ContextEP11__IOSurfacexxRKNS_6BitmapES3_NS_7TextureENS_11ConvertTypeE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __IOSurface *v6;
  _QWORD v8[4];
  __int128 v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;

  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN2CI25convert_buffer_to_textureEPNS_7ContextEP11__IOSurfacexxRKNS_6BitmapES3_NS_7TextureENS_11ConvertTypeE_block_invoke_2;
  v8[3] = &unk_1E2EC6938;
  v9 = *(_OWORD *)(a1 + 32);
  v6 = *(__IOSurface **)(a1 + 48);
  v10 = *(_QWORD *)(a1 + 56);
  v11 = *(_OWORD *)(a1 + 64);
  v12 = a2;
  v13 = a5;
  v14 = a4;
  v15 = a6;
  v16 = *(_DWORD *)(a1 + 80);
  return SurfaceApplyPlaneReadOnlyBlock(v6, (uint64_t)v8);
}

void ___ZN2CI25convert_buffer_to_textureEPNS_7ContextEP11__IOSurfacexxRKNS_6BitmapES3_NS_7TextureENS_11ConvertTypeE_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  _OWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  __int128 v18;
  vImage_Buffer v19;
  _OWORD v20[2];
  vImage_Buffer v21;

  if (a3 == 1)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 48) = a2;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 56) = a5;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 64) = a4;
    v6 = *(_QWORD *)(a1 + 40);
  }
  else
  {
    if (a3)
      goto LABEL_6;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48) = a2;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 56) = a5;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 64) = a4;
    v6 = *(_QWORD *)(a1 + 32);
  }
  *(_QWORD *)(*(_QWORD *)(v6 + 8) + 72) = a6;
LABEL_6:
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v9 = *(_QWORD *)(v7 + 48);
  v8 = (_OWORD *)(v7 + 48);
  if (v9)
  {
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v12 = *(_QWORD *)(v10 + 48);
    v11 = (_OWORD *)(v10 + 48);
    if (v12)
    {
      v13 = v8[1];
      *(_OWORD *)&v21.data = *v8;
      *(_OWORD *)&v21.width = v13;
      v14 = v11[1];
      v20[0] = *v11;
      v20[1] = v14;
      v16 = *(_QWORD *)(a1 + 48);
      v15 = *(_QWORD *)(a1 + 56);
      v17 = *(_QWORD *)(a1 + 64);
      v18 = *(_OWORD *)(a1 + 88);
      *(_OWORD *)&v19.data = *(_OWORD *)(a1 + 72);
      *(_OWORD *)&v19.width = v18;
      CI::convert_cpu(v16, &v21, (uint64_t *)v20, v15, v17, &v19, *(_DWORD *)(a1 + 104));
    }
  }
}

void CI::convert_cpu(uint64_t a1, const vImage_Buffer *a2, uint64_t *a3, uint64_t a4, unint64_t a5, const vImage_Buffer *a6, unsigned int a7)
{
  NSObject *v13;
  NSObject *v14;
  os_signpost_id_t v15;
  uint64_t v16;
  Pixel_16U v17;
  char v18;
  vImagePixelCount v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  size_t v27;
  vImagePixelCount v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char v36;
  uint64_t v37;
  _WORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  signed int v42;
  signed int v43;
  signed int v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  __int16 v49;
  vImagePixelCount v57;
  unint64_t v58;
  size_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  size_t v67;
  vImagePixelCount v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  char v72;
  uint64_t v73;
  _WORD *v74;
  uint64_t v75;
  uint64_t v76;
  signed int v77;
  signed int v78;
  signed int v79;
  int v80;
  int v81;
  unsigned __int16 *v82;
  unsigned __int16 *v83;
  unsigned int v84;
  vImagePixelCount v88;
  unint64_t v89;
  size_t v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  size_t v95;
  vImagePixelCount v96;
  uint64_t v97;
  uint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unsigned __int16 *v102;
  unsigned __int16 *v103;
  vImagePixelCount v104;
  _WORD *v105;
  unsigned int v106;
  unsigned int v107;
  unsigned int v108;
  unsigned int v109;
  vImagePixelCount v113;
  vImagePixelCount v114;
  vImagePixelCount v115;
  vImagePixelCount v116;
  vImagePixelCount v117;
  _BYTE *v118;
  unint64_t v119;
  char *v120;
  uint64_t v121;
  char v122;
  _BYTE *v123;
  vImagePixelCount v124;
  unint64_t v125;
  char *v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  unint64_t v130;
  vImagePixelCount v131;
  unint64_t v132;
  unint64_t v133;
  uint64_t v134;
  uint64_t v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  char v139;
  uint64_t v140;
  _WORD *v141;
  char *v142;
  uint64_t v143;
  uint64_t v144;
  signed int v145;
  signed int v146;
  signed int v147;
  int v148;
  uint64_t v149;
  uint64_t v150;
  char v151;
  uint64_t v152;
  char v153;
  int v154;
  int v155;
  char v156;
  unint64_t v157;
  unint64_t v158;
  int v159;
  uint64_t v160;
  vImagePixelCount v164;
  unint64_t v165;
  unint64_t v166;
  uint64_t v167;
  uint64_t v168;
  unint64_t v169;
  uint64_t v170;
  size_t v171;
  vImagePixelCount v172;
  unint64_t v173;
  unint64_t v174;
  unint64_t v175;
  char v176;
  uint64_t v177;
  _WORD *v178;
  char *v179;
  uint64_t v180;
  signed int v181;
  signed int v182;
  signed int v183;
  int v184;
  int v185;
  uint64_t v186;
  uint64_t v187;
  int v188;
  int v189;
  uint64_t v190;
  unsigned int v191;
  vImagePixelCount v195;
  unint64_t v196;
  char *v197;
  size_t v198;
  unint64_t v199;
  uint64_t v200;
  uint64_t v201;
  unint64_t v202;
  uint64_t v203;
  size_t v204;
  vImagePixelCount v205;
  unint64_t v206;
  unint64_t v207;
  unint64_t v208;
  _WORD *v209;
  char *v210;
  uint64_t v211;
  uint64_t v212;
  vImagePixelCount v213;
  uint64_t v214;
  unsigned int v215;
  vImagePixelCount height;
  unint64_t v220;
  size_t rowBytes;
  unint64_t v222;
  uint64_t v223;
  char *data;
  size_t v225;
  vImagePixelCount width;
  unint64_t v227;
  char *v228;
  unint64_t v229;
  int *v230;
  vImagePixelCount v231;
  size_t v235;
  uint64_t v236;
  uint64_t v237;
  size_t v238;
  size_t v239;
  size_t v240;
  char *v241;
  uint16_t the_pixel[4];
  __int128 color;
  uint8_t buf[4];
  const char *v246;
  uint64_t v247;

  v247 = *MEMORY[0x1E0C80C00];
  v13 = ci_logger_performance();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446210;
    v246 = CI::name_for_conversion(a7);
    _os_log_impl(&dword_1921E4000, v13, OS_LOG_TYPE_INFO, "CI_CONVERSION: (CPU) %{public}s", buf, 0xCu);
  }
  v14 = ci_signpost_log_render();
  v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1) << 32;
  if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v14))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_1921E4000, v14, OS_SIGNPOST_INTERVAL_BEGIN, v15, "convert_cpu", (const char *)&unk_192520C83, buf, 2u);
  }
  v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1);
  TimerBase::TimerBase((uint64_t)buf, v16, 0, (uint64_t)"convert_cpu", 30);
  color = xmmword_19248E050;
  v17 = -1;
  v18 = 2;
  switch(a7)
  {
    case 1u:
      vImageConvert_RGB888toRGBA8888(a2, 0, 0xFFu, a6, 0, 0);
      break;
    case 2u:
      goto LABEL_154;
    case 3u:
      v17 = 15360;
LABEL_154:
      vImageConvert_RGB16UtoRGBA16U(a2, 0, v17, a6, 0, 0);
      break;
    case 4u:
      vImageConvert_RGBFFFtoRGBAFFFF(a2, 0, 1.0, a6, 0, 0);
      break;
    case 5u:
      a2->width *= 4;
      a6->width *= 4;
      vImageConvert_16Fto16U(a2, a6, 0);
      break;
    case 6u:
      a2->width *= 4;
      goto LABEL_159;
    case 7u:
      goto LABEL_183;
    case 8u:
      goto LABEL_185;
    case 9u:
      vImageConvert_RGB16UtoRGBA16U(a2, 0, 0xFFFFu, a6, 0, 0);
      a2 = a6;
LABEL_159:
      a6->width *= 4;
      vImageConvert_16Uto16F(a2, a6, 0);
      break;
    case 0xAu:
      height = a6->height;
      if (height)
      {
        v220 = 0;
        rowBytes = a2->rowBytes;
        v222 = a2->height - 1;
        v223 = (uint64_t)a2->data + 12 * a4;
        data = (char *)a6->data;
        width = a6->width;
        v225 = a6->rowBytes;
        do
        {
          if (width)
          {
            if (height - 1 >= v220)
              v227 = v220;
            else
              v227 = height - 1;
            v228 = &data[v227 * v225];
            v229 = v220 + a5;
            if (v222 < v220 + a5)
              v229 = v222;
            v230 = (int *)(v223 + v229 * rowBytes);
            v231 = width;
            do
            {
              _S1 = *v230;
              __asm { FCVT            H1, S1 }
              *(_WORD *)v228 = _S1;
              _S1 = v230[1];
              __asm { FCVT            H1, S1 }
              *((_WORD *)v228 + 1) = _S1;
              _S1 = v230[2];
              __asm { FCVT            H1, S1 }
              *((_WORD *)v228 + 2) = _S1;
              *((_WORD *)v228 + 3) = 15360;
              v230 += 3;
              v228 += 8;
              --v231;
            }
            while (v231);
          }
          ++v220;
        }
        while (v220 != height);
      }
      break;
    case 0xBu:
      vImageConvert_Planar8toPlanar16F(a2, a6, 0);
      break;
    case 0xCu:
      vImageConvert_Planar16FtoPlanar8(a2, a6, 0);
      break;
    case 0xDu:
      vImageConvert_Planar8toPlanarF(a2, a6, 1.0, 0.0, 0);
      break;
    case 0xEu:
      vImageConvert_PlanarFtoPlanar8(a2, a6, 1.0, 0.0, 0);
      break;
    case 0xFu:
      vImageConvert_Planar16FtoPlanarF(a2, a6, 0);
      break;
    case 0x10u:
      vImageConvert_PlanarFtoPlanar16F(a2, a6, 0);
      break;
    case 0x11u:
      a2->width *= 2;
      a6->width *= 2;
      vImageConvert_Planar8toPlanar16F(a2, a6, 0);
      break;
    case 0x12u:
      a2->width *= 2;
      a6->width *= 2;
      vImageConvert_Planar16FtoPlanar8(a2, a6, 0);
      break;
    case 0x13u:
      a2->width *= 2;
      a6->width *= 2;
      vImageConvert_Planar8toPlanarF(a2, a6, 1.0, 0.0, 0);
      break;
    case 0x14u:
      a2->width *= 2;
      a6->width *= 2;
      vImageConvert_PlanarFtoPlanar8(a2, a6, 1.0, 0.0, 0);
      break;
    case 0x15u:
      v18 = 1;
LABEL_183:
      a2->width <<= v18;
      a6->width <<= v18;
      vImageConvert_Planar16FtoPlanarF(a2, a6, 0);
      break;
    case 0x16u:
      v18 = 1;
LABEL_185:
      a2->width <<= v18;
      a6->width <<= v18;
      vImageConvert_PlanarFtoPlanar16F(a2, a6, 0);
      break;
    case 0x17u:
      vImageExtractChannel_ARGB16U(a2, a6, 0, 0);
      break;
    case 0x18u:
      vImageConvert_Planar16UtoARGB16U(a2, a2, a2, a2, a6, 0);
      *(_QWORD *)the_pixel = 0x3C00000000000000;
      vImageOverwriteChannelsWithPixel_ARGB16U(the_pixel, a6, a6, 7u, 0);
      break;
    case 0x19u:
      vImageExtractChannel_ARGBFFFF(a2, a6, 0, 0);
      break;
    case 0x1Au:
      vImageBufferFill_ARGBFFFF(a6, (const float *)&color, 0);
      vImageOverwriteChannels_ARGBFFFF(a2, a6, a6, 8u, 0);
      break;
    case 0x1Bu:
    case 0x1Cu:
      v113 = a6->height;
      if (v113)
      {
        v114 = 0;
        v115 = a6->width;
        do
        {
          if (v115)
          {
            v116 = 0;
            v117 = v113 - 1;
            if (v117 >= v114)
              v117 = v114;
            v118 = (char *)a6->data + v117 * a6->rowBytes;
            v119 = a2->height - 1;
            if (v119 >= v114 + a5)
              v119 = v114 + a5;
            v120 = (char *)a2->data + 2 * a4 + v119 * a2->rowBytes;
            if (a7 == 27)
              v121 = (uint64_t)(v120 + 1);
            else
              v121 = (uint64_t)a2->data + 2 * a4 + v119 * a2->rowBytes;
            if (a7 != 27)
              ++v120;
            do
            {
              v122 = *v120;
              v120 += 2;
              *v118 = v122;
              v118[1] = *(_BYTE *)(v121 + (((uint64_t)(v116 << 63) >> 63) & 0xFFFFFFFFFFFFFFFELL));
              if ((v116 & 1) != 0)
                v123 = (_BYTE *)v121;
              else
                v123 = (_BYTE *)(v121 + 2);
              v118[2] = *v123;
              v118[3] = -1;
              ++v116;
              v118 += 4;
              v115 = a6->width;
              v121 += 2;
            }
            while (v115 > v116);
            v113 = a6->height;
          }
          ++v114;
        }
        while (v113 > v114);
      }
      break;
    case 0x1Du:
    case 0x1Eu:
    case 0x23u:
    case 0x24u:
    case 0x29u:
    case 0x2Au:
      v19 = a6->height;
      if (v19)
      {
        v20 = 0;
        v239 = a2->rowBytes;
        v21 = a2->height - 1;
        v22 = *a3;
        v23 = a3[3];
        v24 = a3[1] - 1;
        v236 = (uint64_t)a6->data + 4;
        v25 = (uint64_t)a2->data + 2 * a5;
        v26 = a5;
        v28 = a6->width;
        v27 = a6->rowBytes;
        do
        {
          if (v20 >= v19 - 1)
            v29 = v19 - 1;
          else
            v29 = v20;
          if (v26 >= v21)
            v30 = v21;
          else
            v30 = v26;
          v31 = v20 + a5;
          if ((uint64_t)(v20 + a5) < 0 != __OFADD__(v20, a5))
            v32 = v31 + 1;
          else
            v32 = v20 + a5;
          v33 = v32 >> 1;
          v34 = 2 * (v31 & 1) + (v32 >> 1) - 1;
          if (v24 < v32 >> 1)
            v33 = v24;
          if (v24 >= v34)
            v35 = v34;
          else
            v35 = v24;
          if (v28)
          {
            v36 = 0;
            v37 = 0;
            v38 = (_WORD *)(v236 + v27 * v29);
            v39 = v25 + v239 * v30;
            v40 = v22 + v33 * v23;
            v41 = v22 + v35 * v23;
            v42 = *((_DWORD *)a3 + 4);
            do
            {
              v43 = v37 >> 1;
              v44 = (v36 & 2) + (v37 >> 1);
              if ((int)(v37 >> 1) >= v42)
                v43 = v42 - 1;
              v45 = v43 & ~(v43 >> 31);
              if (v44 <= v42)
                v46 = v44 - 1;
              else
                v46 = v42 - 1;
              v47 = (2 * v45) + a4;
              v48 = 2 * (2 * (v46 & ~(v46 >> 31)) + a4);
              v49 = 9 * (*(_WORD *)(v40 + 2 * v47) >> 6)
                  + (*(_WORD *)(v41 + v48) >> 6)
                  + 3 * ((*(_WORD *)(v41 + 2 * v47) >> 6) + (*(_WORD *)(v40 + v48) >> 6));
              LODWORD(v48) = (unsigned __int16)(9 * (*(_WORD *)(v40 + 2 * v47 + 2) >> 6)
                                              + (*(_WORD *)(v41 + v48 + 2) >> 6)
                                              + 3
                                              * ((*(_WORD *)(v41 + 2 * v47 + 2) >> 6) + (*(_WORD *)(v40 + v48 + 2) >> 6))
                                              + 8) >> 4;
              _D2 = (double)(*(unsigned __int16 *)(v39 + 2 * v37) >> 6) / 1023.0;
              __asm { FCVT            H2, D2 }
              _D3 = (double)((unsigned __int16)(v49 + 8) >> 4) / 1023.0;
              *(v38 - 2) = LOWORD(_D2);
              __asm { FCVT            H2, D3 }
              _D3 = (double)v48 / 1023.0;
              __asm { FCVT            H3, D3 }
              *(v38 - 1) = LOWORD(_D2);
              *v38 = LOWORD(_D3);
              v38[1] = 15360;
              ++v37;
              v36 += 2;
              v38 += 4;
            }
            while (v28 != v37);
          }
          ++v20;
          ++v26;
        }
        while (v20 != v19);
      }
      break;
    case 0x1Fu:
    case 0x20u:
    case 0x25u:
    case 0x26u:
    case 0x2Bu:
    case 0x2Cu:
      v57 = a6->height;
      if (v57)
      {
        v58 = 0;
        v59 = a2->rowBytes;
        v60 = a2->height - 1;
        v61 = *a3;
        v62 = a3[3];
        v63 = a3[1] - 1;
        v64 = (uint64_t)a6->data + 4;
        v65 = (uint64_t)a2->data + 2 * a4;
        v66 = a5;
        v68 = a6->width;
        v67 = a6->rowBytes;
        do
        {
          if (v58 >= v57 - 1)
            v69 = v57 - 1;
          else
            v69 = v58;
          if (v66 >= v60)
            v70 = v60;
          else
            v70 = v66;
          if (v63 >= v58 + a5)
            v71 = v58 + a5;
          else
            v71 = v63;
          if (v68)
          {
            v72 = 0;
            v73 = 0;
            v74 = (_WORD *)(v64 + v67 * v69);
            v75 = v65 + v59 * v70;
            v76 = v61 + v71 * v62;
            v77 = *((_DWORD *)a3 + 4);
            do
            {
              v78 = v73 >> 1;
              v79 = (v72 & 2) + (v73 >> 1);
              if ((int)(v73 >> 1) >= v77)
                v78 = v77 - 1;
              v80 = v78 & ~(v78 >> 31);
              if (v79 <= v77)
                v81 = v79 - 1;
              else
                v81 = v77 - 1;
              v82 = (unsigned __int16 *)(v76 + 2 * ((2 * v80) + a4));
              v83 = (unsigned __int16 *)(v76 + 2 * (2 * (v81 & ~(v81 >> 31)) + a4));
              v84 = 3 * (*v82 >> 6) + (*v83 >> 6) + 2;
              LODWORD(v82) = (3 * (v82[1] >> 6) + (v83[1] >> 6) + 2) >> 2;
              _D2 = (double)(*(unsigned __int16 *)(v75 + 2 * v73) >> 6) / 1023.0;
              __asm { FCVT            H2, D2 }
              _D3 = (double)(v84 >> 2) / 1023.0;
              *(v74 - 2) = LOWORD(_D2);
              __asm { FCVT            H2, D3 }
              _D3 = (double)v82 / 1023.0;
              __asm { FCVT            H3, D3 }
              *(v74 - 1) = LOWORD(_D2);
              *v74 = LOWORD(_D3);
              v74[1] = 15360;
              ++v73;
              v72 += 2;
              v74 += 4;
            }
            while (v68 != v73);
          }
          ++v58;
          ++v66;
        }
        while (v58 != v57);
      }
      break;
    case 0x21u:
    case 0x22u:
    case 0x27u:
    case 0x28u:
    case 0x2Du:
    case 0x2Eu:
      v88 = a6->height;
      if (v88)
      {
        v89 = 0;
        v90 = a2->rowBytes;
        v91 = a2->height - 1;
        v92 = a3[3];
        v93 = a3[1] - 1;
        v94 = (uint64_t)a2->data + 2 * a4;
        v96 = a6->width;
        v95 = a6->rowBytes;
        v97 = *a3 + 4 * a4 + 2;
        v98 = (uint64_t)a6->data + 4;
        do
        {
          if (a5 >= v93)
            v99 = v93;
          else
            v99 = a5;
          if (a5 >= v91)
            v100 = v91;
          else
            v100 = a5;
          if (v89 >= v88 - 1)
            v101 = v88 - 1;
          else
            v101 = v89;
          if (v96)
          {
            v102 = (unsigned __int16 *)(v97 + v92 * v99);
            v103 = (unsigned __int16 *)(v94 + v90 * v100);
            v104 = v96;
            v105 = (_WORD *)(v98 + v95 * v101);
            do
            {
              v106 = *v103++;
              v107 = v106 >> 6;
              v108 = *(v102 - 1) >> 6;
              v109 = *v102;
              v102 += 2;
              _D2 = (double)v107 / 1023.0;
              __asm { FCVT            H2, D2 }
              *(v105 - 2) = LOWORD(_D2);
              _D2 = (double)v108 / 1023.0;
              __asm { FCVT            H2, D2 }
              _D3 = (double)(v109 >> 6) / 1023.0;
              *(v105 - 1) = LOWORD(_D2);
              __asm { FCVT            H2, D3 }
              *v105 = LOWORD(_D2);
              v105[1] = 15360;
              v105 += 4;
              --v104;
            }
            while (v104);
          }
          ++v89;
          ++a5;
        }
        while (v89 != v88);
      }
      break;
    case 0x2Fu:
    case 0x30u:
      v124 = a6->height;
      if (v124)
      {
        v125 = 0;
        v126 = (char *)a2->data;
        v127 = a2->height - 1;
        v128 = *a3;
        v129 = a3[3];
        v130 = a3[1] - 1;
        v237 = (uint64_t)a6->data + 4;
        v240 = a2->rowBytes;
        v131 = a6->width;
        v235 = a6->rowBytes;
        do
        {
          if (v125 >= v124 - 1)
            v132 = v124 - 1;
          else
            v132 = v125;
          v133 = v125 + a5;
          if ((uint64_t)(v125 + a5) < 0 != __OFADD__(v125, a5))
            v134 = v133 + 1;
          else
            v134 = v125 + a5;
          v135 = v134 >> 1;
          if (v127 >= v133)
            v136 = v125 + a5;
          else
            v136 = v127;
          v137 = 2 * (v133 & 1) + (v134 >> 1) - 1;
          if (v130 < v134 >> 1)
            v135 = v130;
          if (v130 >= v137)
            v138 = v137;
          else
            v138 = v130;
          if (v131)
          {
            v139 = 0;
            v140 = 0;
            v141 = (_WORD *)(v237 + v235 * v132);
            v142 = &v126[v136 * v240];
            v143 = v128 + v135 * v129;
            v144 = v128 + v138 * v129;
            v145 = *((_DWORD *)a3 + 4);
            do
            {
              v146 = v140 >> 1;
              v147 = (v139 & 2) + (v140 >> 1);
              if ((int)(v140 >> 1) >= v145)
                v146 = v145 - 1;
              if (v147 <= v145)
                v148 = v147 - 1;
              else
                v148 = v145 - 1;
              v149 = 2 * (v146 & ~(v146 >> 31)) + a4;
              v150 = v149 / 3;
              v151 = 10 * (v149 % 3);
              v152 = 2 * (v148 & ~(v148 >> 31)) + a4;
              v153 = 10 * (v152 % 3);
              v154 = *(_DWORD *)(v143 + 4 * (v152 / 3)) >> v153;
              v155 = *(_DWORD *)(v144 + 4 * (v152 / 3)) >> v153;
              v156 = v149 + 1;
              v157 = (unsigned __int128)((v149 + 1) * (__int128)0x5555555555555556) >> 64;
              v158 = v157 + (v157 >> 63);
              ++v152;
              v159 = (v155 & 0x3FF) + 9 * ((*(_DWORD *)(v143 + 4 * v150) >> v151) & 0x3FF);
              v160 = v152 / 3;
              LODWORD(v160) = (((*(_DWORD *)(v144 + 4 * v160) >> (10 * (v152 - 3 * v160))) & 0x3FF)
                             + 9 * ((*(_DWORD *)(v143 + 4 * v158) >> (10 * (v156 - 3 * v158))) & 0x3FF)
                             + 3
                             * (((*(_DWORD *)(v144 + 4 * v158) >> (10 * (v156 - 3 * v158))) & 0x3FF)
                              + ((*(_DWORD *)(v143 + 4 * v160) >> (10 * (v152 - 3 * v160))) & 0x3FFu))
                             + 8) >> 4;
              _D2 = (double)((*(_DWORD *)&v142[4 * ((a4 + v140) / 3)] >> (10 * ((char)(a4 + v140) % 3))) & 0x3FF)
                  / 1023.0;
              __asm { FCVT            H2, D2 }
              _D3 = (double)((v159 + 3 * (((*(_DWORD *)(v144 + 4 * v150) >> v151) & 0x3FF) + (v154 & 0x3FFu)) + 8) >> 4)
                  / 1023.0;
              *(v141 - 2) = LOWORD(_D2);
              __asm { FCVT            H2, D3 }
              _D3 = (double)(int)v160 / 1023.0;
              __asm { FCVT            H3, D3 }
              *(v141 - 1) = LOWORD(_D2);
              *v141 = LOWORD(_D3);
              v141[1] = 15360;
              ++v140;
              v139 += 2;
              v141 += 4;
            }
            while (v131 != v140);
          }
          ++v125;
        }
        while (v125 != v124);
      }
      break;
    case 0x31u:
    case 0x32u:
      v164 = a6->height;
      if (v164)
      {
        v165 = 0;
        v238 = a2->rowBytes;
        v241 = (char *)a2->data;
        v166 = a2->height - 1;
        v167 = *a3;
        v168 = a3[3];
        v169 = a3[1] - 1;
        v170 = (uint64_t)a6->data + 4;
        v172 = a6->width;
        v171 = a6->rowBytes;
        do
        {
          if (v165 >= v164 - 1)
            v173 = v164 - 1;
          else
            v173 = v165;
          if (v166 >= v165 + a5)
            v174 = v165 + a5;
          else
            v174 = v166;
          if (v169 >= v165 + a5)
            v175 = v165 + a5;
          else
            v175 = v169;
          if (v172)
          {
            v176 = 0;
            v177 = 0;
            v178 = (_WORD *)(v170 + v171 * v173);
            v179 = &v241[v174 * v238];
            v180 = v167 + v175 * v168;
            v181 = *((_DWORD *)a3 + 4);
            do
            {
              v182 = v177 >> 1;
              v183 = (v176 & 2) + (v177 >> 1);
              if ((int)(v177 >> 1) >= v181)
                v182 = v181 - 1;
              v184 = v182 & ~(v182 >> 31);
              if (v183 <= v181)
                v185 = v183 - 1;
              else
                v185 = v181 - 1;
              v186 = (2 * v184) + a4;
              v187 = 2 * (v185 & ~(v185 >> 31)) + a4;
              v188 = 3 * ((*(_DWORD *)(v180 + 4 * ((v186 + 1) / 3)) >> (10 * ((v186 + 1) % 3))) & 0x3FF);
              v189 = ((*(_DWORD *)(v180 + 4 * (v187 / 3)) >> (10 * (v187 % 3))) & 0x3FF)
                   + 3 * ((*(_DWORD *)(v180 + 4 * (v186 / 3)) >> (10 * (v186 % 3))) & 0x3FF);
              LOBYTE(v186) = v187 + 1;
              v190 = (unsigned __int128)((v187 + 1) * (__int128)0x5555555555555556) >> 64;
              v191 = (((*(_DWORD *)(v180 + 4 * (v190 + ((unint64_t)v190 >> 63))) >> (10
                                                                                          * (v186
                                                                                           - 3 * (v190 + (v190 < 0))))) & 0x3FFu)
                    + v188
                    + 2) >> 2;
              _D2 = (double)((*(_DWORD *)&v179[4 * ((a4 + v177) / 3)] >> (10 * ((char)(a4 + v177) % 3))) & 0x3FF)
                  / 1023.0;
              __asm { FCVT            H2, D2 }
              _D3 = (double)((v189 + 2) >> 2) / 1023.0;
              *(v178 - 2) = LOWORD(_D2);
              __asm { FCVT            H2, D3 }
              _D3 = (double)v191 / 1023.0;
              __asm { FCVT            H3, D3 }
              *(v178 - 1) = LOWORD(_D2);
              *v178 = LOWORD(_D3);
              v178[1] = 15360;
              ++v177;
              v176 += 2;
              v178 += 4;
            }
            while (v172 != v177);
          }
          ++v165;
        }
        while (v165 != v164);
      }
      break;
    case 0x33u:
    case 0x34u:
      v195 = a6->height;
      if (v195)
      {
        v196 = 0;
        v197 = (char *)a2->data;
        v198 = a2->rowBytes;
        v199 = a2->height - 1;
        v200 = *a3;
        v201 = a3[3];
        v202 = a3[1] - 1;
        v203 = (uint64_t)a6->data + 4;
        v205 = a6->width;
        v204 = a6->rowBytes;
        do
        {
          if (v196 >= v195 - 1)
            v206 = v195 - 1;
          else
            v206 = v196;
          if (v199 >= v196 + a5)
            v207 = v196 + a5;
          else
            v207 = v199;
          if (v202 >= v196 + a5)
            v208 = v196 + a5;
          else
            v208 = v202;
          if (v205)
          {
            v209 = (_WORD *)(v203 + v204 * v206);
            v210 = &v197[v207 * v198];
            v211 = a4;
            v212 = 2 * a4;
            v213 = v205;
            v214 = v200 + v208 * v201;
            do
            {
              v215 = (*(_DWORD *)(v214 + 4 * ((v212 + 1) / 3)) >> (10 * ((char)(v212 + 1) % 3))) & 0x3FF;
              _D2 = (double)((*(_DWORD *)&v210[4 * (v211 / 3)] >> (10 * (v211 % 3))) & 0x3FF) / 1023.0;
              __asm { FCVT            H2, D2 }
              _D3 = (double)((*(_DWORD *)(v214 + 4 * (v212 / 3)) >> (10 * (v212 % 3))) & 0x3FF) / 1023.0;
              *(v209 - 2) = LOWORD(_D2);
              __asm { FCVT            H2, D3 }
              _D3 = (double)v215 / 1023.0;
              __asm { FCVT            H3, D3 }
              *(v209 - 1) = LOWORD(_D2);
              *v209 = LOWORD(_D3);
              v209[1] = 15360;
              v212 += 2;
              v209 += 4;
              ++v211;
              --v213;
            }
            while (v213);
          }
          ++v196;
        }
        while (v196 != v195);
      }
      break;
    default:
      break;
  }
  CI::convert_cpu(CI::Context *,vImage_Buffer,vImage_Buffer,long long,long long,vImage_Buffer,CI::ConvertType)::SignpostTimer::~SignpostTimer((TimerBase *)buf);
}

void sub_1923F3924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  CI::convert_cpu(CI::Context *,vImage_Buffer,vImage_Buffer,long long,long long,vImage_Buffer,CI::ConvertType)::SignpostTimer::~SignpostTimer((TimerBase *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2CI25convert_buffer_to_textureEPNS_7ContextEP11__IOSurfacexxRKNS_6BitmapES3_NS_7TextureENS_11ConvertTypeE_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __IOSurface *v6;
  _QWORD v8[4];
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v6 = *(__IOSurface **)(a1 + 32);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZN2CI25convert_buffer_to_textureEPNS_7ContextEP11__IOSurfacexxRKNS_6BitmapES3_NS_7TextureENS_11ConvertTypeE_block_invoke_4;
  v8[3] = &__block_descriptor_96_e22_v48__0r_v8Q16Q24Q32Q40l;
  v9 = *(_OWORD *)(a1 + 40);
  v10 = *(_QWORD *)(a1 + 56);
  v11 = a2;
  v12 = a5;
  v13 = a4;
  v14 = a6;
  v15 = *(_QWORD *)(a1 + 64);
  return SurfaceApplyPlaneReadOnlyBlock(v6, (uint64_t)v8);
}

void ___ZN2CI25convert_buffer_to_textureEPNS_7ContextEP11__IOSurfacexxRKNS_6BitmapES3_NS_7TextureENS_11ConvertTypeE_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, size_t a6)
{
  size_t v10;
  void *v11;
  vImagePixelCount v12;
  vImagePixelCount v13;
  uint64_t v14;
  __int128 v15;
  vImage_Buffer v16;
  _OWORD v17[2];
  vImage_Buffer v18;

  v10 = a2 + *(_QWORD *)(a1 + 32) * a6;
  v11 = (void *)(v10 + CI::format_bytes_for_width_of_plane(*(_DWORD *)(a1 + 88), *(_QWORD *)(a1 + 40), 0));
  v12 = a5 - *(_QWORD *)(a1 + 32);
  v13 = a4 - *(_QWORD *)(a1 + 40);
  memset(v17, 0, sizeof(v17));
  v14 = *(_QWORD *)(a1 + 48);
  v18.data = v11;
  v18.height = v12;
  v18.width = v13;
  v18.rowBytes = a6;
  v15 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&v16.data = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v16.width = v15;
  CI::convert_cpu(v14, &v18, (uint64_t *)v17, 0, 0, &v16, *(_DWORD *)(a1 + 92));
}

void ___ZN2CI25convert_buffer_to_textureEPNS_7ContextEP11__IOSurfacexxRKNS_6BitmapES3_NS_7TextureENS_11ConvertTypeE_block_invoke_5(uint64_t a1, void *a2, uint64_t a3, vImagePixelCount a4, vImagePixelCount a5, size_t a6)
{
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  unint64_t v9;
  vImage_Buffer v10;
  _OWORD v11[2];
  vImage_Buffer v12;

  memset(v11, 0, sizeof(v11));
  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&v12.data = *(_OWORD *)(a1 + 40);
  *(_OWORD *)&v12.width = v7;
  v8 = *(_QWORD *)(a1 + 72);
  v9 = *(_QWORD *)(a1 + 80);
  v10.data = a2;
  v10.height = a5;
  v10.width = a4;
  v10.rowBytes = a6;
  CI::convert_cpu(v6, &v12, (uint64_t *)v11, v8, v9, &v10, *(_DWORD *)(a1 + 88));
}

void ___ZN2CIL13convert_metalEPKNS_12MetalContextERKNS_6BitmapEP11__IOSurfaceNS_7TextureENS_11ConvertTypeE_block_invoke(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

void ___ZN2CIL13convert_metalEPKNS_12MetalContextERKNS_6BitmapEP11__IOSurfaceNS_7TextureENS_11ConvertTypeE_block_invoke_170(uint64_t a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  kdebug_trace();
  v2 = ci_signpost_log_render();
  v3 = *(_QWORD *)(a1 + 32);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v3, "convert_metal", (const char *)&unk_192520C83, v5, 2u);
    }
  }
}

void ___ZN2CIL13convert_metalEPKNS_12MetalContextERKNS_6BitmapEP11__IOSurfaceNS_7TextureENS_11ConvertTypeE_block_invoke_173(uint64_t a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  kdebug_trace();
  v2 = ci_signpost_log_render();
  v3 = *(_QWORD *)(a1 + 32);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "convert_metal", (const char *)&unk_192520C83, v5, 2u);
    }
  }
}

void CI::convert_cpu(CI::Context *,vImage_Buffer,vImage_Buffer,long long,long long,vImage_Buffer,CI::ConvertType)::SignpostTimer::~SignpostTimer(TimerBase *a1)
{
  NSObject *v2;
  os_signpost_id_t v3;
  NSObject *v4;
  uint8_t v5[16];

  v2 = ci_signpost_log_render();
  v3 = *((_QWORD *)a1 + 1);
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v4 = v2;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1921E4000, v4, OS_SIGNPOST_INTERVAL_END, v3, "convert_cpu", (const char *)&unk_192520C83, v5, 2u);
    }
  }
  TimerBase::~TimerBase(a1);
}

void sub_1923F3C70(_Unwind_Exception *a1)
{
  TimerBase *v1;

  TimerBase::~TimerBase(v1);
  _Unwind_Resume(a1);
}

const char *CI::name_for_format(int a1)
{
  const char *result;

  if (a1 <= 1792)
  {
    if (a1 <= 770)
    {
      switch(a1)
      {
        case 257:
          result = "A8";
          break;
        case 258:
          result = "I8";
          break;
        case 259:
          result = "L8";
          break;
        case 260:
          result = "LA8";
          break;
        case 261:
          result = "R8";
          break;
        case 262:
          result = "RG8";
          break;
        case 263:
          result = "RGB8";
          break;
        case 264:
          result = "RGBA8";
          break;
        case 265:
          result = "ARGB8";
          break;
        case 266:
          result = "BGRA8";
          break;
        case 267:
          result = "ABGR8";
          break;
        case 268:
          result = "RGBX8";
          break;
        case 269:
          result = "XRGB8";
          break;
        case 270:
          result = "BGRX8";
          break;
        case 271:
          result = "XBGR8";
          break;
        case 272:
        case 273:
          return "unknown-format";
        case 274:
          result = "YCC420f";
          break;
        case 275:
          result = "YCC444f";
          break;
        case 276:
          result = "CbYCrY8f";
          break;
        case 277:
          result = "YCbYCr8f";
          break;
        case 278:
          result = "YCC422f";
          break;
        default:
          switch(a1)
          {
            case 530:
              result = "YCC420v";
              break;
            case 531:
              result = "YCC444v";
              break;
            case 532:
              result = "CbYCrY8";
              break;
            case 533:
              result = "YCbYCr8";
              break;
            case 534:
              result = "YCC422v";
              break;
            case 535:
              result = "AYCbCr8";
              break;
            default:
              if (a1)
                return "unknown-format";
              result = "Nil";
              break;
          }
          break;
      }
    }
    else
    {
      if (a1 > 1042)
      {
        if (a1 > 1298)
        {
          if (a1 <= 1553)
          {
            if (a1 == 1299)
              return "YCC444f10Packed";
            if (a1 == 1302)
              return "YCC422f10Packed";
          }
          else
          {
            switch(a1)
            {
              case 1554:
                return "YCC420v10Packed";
              case 1555:
                return "YCC444v10Packed";
              case 1558:
                return "YCC422v10Packed";
            }
          }
        }
        else if (a1 <= 1284)
        {
          if (a1 == 1043)
            return "YCC444v10";
          if (a1 == 1046)
            return "YCC422v10";
        }
        else
        {
          switch(a1)
          {
            case 1285:
              return "R10p";
            case 1286:
              return "RG10p";
            case 1298:
              return "YCC420f10Packed";
          }
        }
        return "unknown-format";
      }
      switch(a1)
      {
        case 771:
          result = "L10";
          break;
        case 772:
        case 776:
        case 777:
        case 778:
        case 779:
        case 780:
        case 781:
        case 782:
        case 783:
        case 788:
        case 789:
          return "unknown-format";
        case 773:
          result = "R10";
          break;
        case 774:
          result = "RG10";
          break;
        case 775:
          result = "RGB10";
          break;
        case 784:
          result = "A2RGB10";
          break;
        case 785:
          result = "A2BGR10";
          break;
        case 786:
          result = "YCC420f10";
          break;
        case 787:
          result = "YCC444f10";
          break;
        case 790:
          result = "YCC422f10";
          break;
        default:
          if (a1 != 1042)
            return "unknown-format";
          result = "YCC420v10";
          break;
      }
    }
  }
  else
  {
    if (a1 > 2304)
    {
      if (a1 > 3080)
      {
        if (a1 <= 3349)
        {
          if (a1 > 3333)
          {
            switch(a1)
            {
              case 3334:
                return "RG12";
              case 3346:
                return "YCC420f12";
              case 3347:
                return "YCC444f12";
            }
          }
          else
          {
            switch(a1)
            {
              case 3081:
                return "ARGB10-WideLinear";
              case 3331:
                return "L12";
              case 3333:
                return "R12";
            }
          }
        }
        else if (a1 <= 3605)
        {
          switch(a1)
          {
            case 3350:
              return "YCC422f12";
            case 3602:
              return "YCC420v12";
            case 3603:
              return "YCC444v12";
          }
        }
        else if (a1 > 3858)
        {
          if (a1 == 3859)
            return "YCC444v16";
          if (a1 == 3862)
            return "YCC422v16";
        }
        else
        {
          if (a1 == 3606)
            return "YCC422v12";
          if (a1 == 3858)
            return "YCC420v16";
        }
      }
      else
      {
        if (a1 <= 2566)
        {
          switch(a1)
          {
            case 2305:
              result = "Af";
              break;
            case 2306:
              result = "If";
              break;
            case 2307:
              result = "Lf";
              break;
            case 2308:
              result = "LAf";
              break;
            case 2309:
              result = "Rf";
              break;
            case 2310:
              result = "RGf";
              break;
            case 2311:
              result = "RGBf";
              break;
            case 2312:
              result = "RGBAf";
              break;
            case 2313:
              result = "ARGBf";
              break;
            case 2316:
              result = "RGBXf";
              break;
            default:
              return "unknown-format";
          }
          return result;
        }
        if (a1 > 2823)
        {
          if (a1 == 2824)
            return "RGBA14";
          if (a1 == 3079)
            return "RGB10-WideLinear";
        }
        else
        {
          if (a1 == 2567)
            return "RGB10-WideGamut";
          if (a1 == 2569)
            return "ARGB10-WideGamut";
        }
      }
      return "unknown-format";
    }
    switch(a1)
    {
      case 1793:
        result = "A16";
        break;
      case 1794:
        result = "I16";
        break;
      case 1795:
        result = "L16";
        break;
      case 1796:
        result = "LA16";
        break;
      case 1797:
        result = "R16";
        break;
      case 1798:
        result = "RG16";
        break;
      case 1799:
        result = "RGB16";
        break;
      case 1800:
        result = "RGBA16";
        break;
      case 1801:
        result = "ARGB16";
        break;
      case 1802:
      case 1803:
      case 1805:
      case 1806:
      case 1807:
      case 1808:
      case 1809:
      case 1812:
      case 1813:
        return "unknown-format";
      case 1804:
        result = "RGBX16";
        break;
      case 1810:
        result = "YCC420f16";
        break;
      case 1811:
        result = "YCC444f16";
        break;
      case 1814:
        result = "YCC422f16";
        break;
      default:
        switch(a1)
        {
          case 2049:
            result = "Ah";
            break;
          case 2050:
            result = "Ih";
            break;
          case 2051:
            result = "Lh";
            break;
          case 2052:
            result = "LAh";
            break;
          case 2053:
            result = "Rh";
            break;
          case 2054:
            result = "RGh";
            break;
          case 2055:
            result = "RGBh";
            break;
          case 2056:
            result = "RGBAh";
            break;
          case 2060:
            result = "RGBXh";
            break;
          case 2066:
            result = "YCC420fh";
            break;
          case 2067:
            result = "YCC444fh";
            break;
          case 2070:
            result = "YCC422fh";
            break;
          default:
            return "unknown-format";
        }
        break;
    }
  }
  return result;
}

void CI::log_old_format(CI *this, const char *a2, const char *a3)
{
  NSObject *v5;
  int v6;
  CI *v7;
  __int16 v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v5 = ci_logger_api();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = 136446466;
    v7 = this;
    v8 = 2082;
    v9 = a2;
    _os_log_impl(&dword_1921E4000, v5, OS_LOG_TYPE_INFO, "%{public}s an old value for kPixelFormat%{public}s was used.", (uint8_t *)&v6, 0x16u);
  }
}

uint64_t CI::format_component_count(int a1)
{
  uint64_t result;
  char v3;
  unsigned int v4;

  result = 0;
  if (a1 <= 1792)
  {
    if (a1 > 770)
    {
      if (a1 <= 1041)
      {
        switch(a1)
        {
          case 771:
          case 773:
            return 1;
          case 774:
            return 2;
          case 775:
          case 784:
          case 785:
          case 786:
          case 787:
          case 790:
            return 3;
          default:
            return result;
        }
      }
      else
      {
        if (a1 <= 1297)
        {
          if ((a1 - 1042) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0)
            return 3;
          if (a1 != 1285)
          {
            if (a1 != 1286)
              return result;
            return 2;
          }
          return 1;
        }
        if ((a1 - 1554) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0
          || (a1 - 1298) < 2
          || a1 == 1302)
        {
          return 3;
        }
      }
    }
    else
    {
      switch(a1)
      {
        case 257:
        case 258:
        case 259:
        case 261:
          return 1;
        case 260:
        case 262:
          return 2;
        case 263:
        case 268:
        case 269:
        case 270:
        case 271:
        case 274:
        case 275:
        case 276:
        case 277:
        case 278:
          return 3;
        case 264:
        case 265:
        case 266:
        case 267:
          return 4;
        case 272:
        case 273:
          return result;
        default:
          if ((a1 - 530) < 5)
            return 3;
          if (a1 == 535)
            result = 4;
          else
            result = 0;
          break;
      }
    }
  }
  else if (a1 <= 2304)
  {
    switch(a1)
    {
      case 1793:
      case 1794:
      case 1795:
      case 1797:
        return 1;
      case 1796:
      case 1798:
        return 2;
      case 1799:
      case 1804:
      case 1810:
      case 1811:
      case 1814:
        return 3;
      case 1800:
      case 1801:
        return 4;
      case 1802:
      case 1803:
      case 1805:
      case 1806:
      case 1807:
      case 1808:
      case 1809:
      case 1812:
      case 1813:
        return result;
      default:
        switch(a1)
        {
          case 2049:
          case 2050:
          case 2051:
          case 2053:
            return 1;
          case 2052:
          case 2054:
            return 2;
          case 2055:
          case 2060:
          case 2066:
          case 2067:
          case 2070:
            return 3;
          case 2056:
            return 4;
          default:
            return result;
        }
    }
  }
  else if (a1 <= 3078)
  {
    if (a1 > 2566)
    {
      if (a1 == 2567)
        return 3;
      if (a1 == 2569 || a1 == 2824)
        return 4;
    }
    else
    {
      switch(a1)
      {
        case 2305:
        case 2306:
        case 2307:
        case 2309:
          return 1;
        case 2308:
        case 2310:
          return 2;
        case 2311:
        case 2316:
          return 3;
        case 2312:
        case 2313:
          return 4;
        default:
          return result;
      }
    }
  }
  else
  {
    if (a1 <= 3601)
    {
      v3 = a1 - 3;
      if ((a1 - 3331) > 0x13)
        goto LABEL_9;
      if (((1 << v3) & 0x98000) != 0)
        return 3;
      if (((1 << v3) & 5) == 0)
      {
        if (a1 != 3334)
        {
LABEL_9:
          if (a1 != 3079)
          {
            if (a1 != 3081)
              return result;
            return 4;
          }
          return 3;
        }
        return 2;
      }
      return 1;
    }
    if ((a1 - 3602) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0)
      return 3;
    v4 = a1 - 3858;
    if (v4 <= 4 && ((1 << v4) & 0x13) != 0)
      return 3;
  }
  return result;
}

uint64_t CI::format_destination_rowbytes_requirement(int a1)
{
  uint64_t v2;
  uint64_t v3;

  if ((a1 - 2049) <= 0x15 && ((1 << (a1 - 1)) & 0x2608FF) != 0)
    return 8;
  v2 = 16;
  if ((a1 & 0xFFFFFFFD) == 0x904)
    v2 = 8;
  if (((1 << (a1 - 4)) & 0x13D) != 0)
    v3 = v2;
  else
    v3 = 4;
  if ((a1 - 2308) <= 8)
    return v3;
  else
    return 4;
}

uint64_t CI::format_is_full_float(int a1)
{
  return ((a1 - 2305) < 0xC) & (0x9FFu >> (a1 - 1));
}

uint64_t CI::format_is_half_float(int a1)
{
  return ((a1 - 2049) < 0x16) & (0x2608FFu >> (a1 - 1));
}

uint64_t CI::format_bytes_per_pixel(int a1)
{
  return (CI::format_bits_per_pixel(a1) + 7) >> 3;
}

uint64_t CI::format_bits_per_component(int a1)
{
  uint64_t result;
  int v3;
  int v4;
  unsigned int v5;
  int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;

  result = 0;
  if (a1 <= 1792)
  {
    if (a1 > 770)
    {
      if (a1 <= 1041)
      {
        v11 = a1 - 771;
        if (v11 > 0x13)
          return result;
        v6 = 1 << v11;
        if ((v6 & 0x9E010) != 0)
          return 10;
        v7 = 13;
        goto LABEL_41;
      }
      if ((a1 - 1285) <= 0x11 && ((1 << (a1 - 5)) & 0x26003) != 0)
        return 10;
      if ((a1 - 1042) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0)
        return 10;
      v8 = a1 - 1554;
      if (v8 <= 4 && ((1 << v8) & 0x13) != 0)
        return 10;
    }
    else if ((a1 - 257) <= 0x15 && ((1 << (a1 - 1)) & 0x3E7FFF) != 0 || (a1 - 530) < 6)
    {
      return 8;
    }
  }
  else
  {
    if (a1 <= 2304)
    {
      if ((a1 - 1793) <= 0x15)
      {
        v4 = 1 << (a1 - 1);
        if ((v4 & 0x9FF) != 0 || (v4 & 0x260000) != 0)
          return 16;
      }
      v5 = a1 - 2049;
      if (v5 > 0x15)
        return result;
      v6 = 1 << v5;
      if ((_BYTE)v6)
        return 16;
      v7 = 2492416;
      goto LABEL_41;
    }
    if (a1 > 3078)
    {
      if (a1 <= 3601)
      {
        if ((a1 - 3331) > 0x13)
        {
LABEL_8:
          if (a1 != 3079 && a1 != 3081)
            return result;
          return 10;
        }
        v3 = 1 << (a1 - 3);
        if ((v3 & 0xD) == 0)
        {
          if ((v3 & 0x98000) == 0)
            goto LABEL_8;
          return 12;
        }
        return 16;
      }
      if ((a1 - 3602) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0)
        return 12;
      v12 = a1 - 3858;
      if (v12 > 4)
        return result;
      v6 = 1 << v12;
      v7 = 19;
LABEL_41:
      if ((v6 & v7) == 0)
        return result;
      return 16;
    }
    if (a1 > 2566)
    {
      if (a1 == 2567 || a1 == 2569)
        return 10;
      if (a1 != 2824)
        return result;
      return 16;
    }
    v9 = a1 - 2305;
    if (((1 << v9) & 0x9FF) != 0)
      v10 = 32;
    else
      v10 = 0;
    if (v9 <= 0xB)
      return v10;
    else
      return 0;
  }
  return result;
}

unint64_t CI::format_bytes_per_row(int a1, uint64_t a2)
{
  uint64_t v2;

  if (a1 == 1286)
  {
    v2 = 2 * a2 + 2;
    return (2 * (((unint64_t)v2 * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
  }
  if (a1 == 1285)
  {
    v2 = a2 + 2;
    return (2 * (((unint64_t)v2 * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
  }
  return ((unint64_t)CI::format_bits_per_pixel(a1) * a2 + 7) >> 3;
}

unint64_t CI::format_bytes_for_width_of_plane(int a1, uint64_t a2, int a3)
{
  int v5;

  v5 = a1;
  if (CI::format_is_ycc_biplanar(a1))
    v5 = CI::format_of_plane(v5, a3);
  return CI::format_bytes_per_row(v5, a2);
}

uint64_t CI::format_of_plane(int a1, int a2)
{
  uint64_t result;
  int v5;
  unsigned int v6;
  BOOL v7;
  unsigned int v8;

  result = CI::format_is_ycc_biplanar(a1);
  if (!(_DWORD)result)
    return result;
  if (a1 <= 1553)
  {
    if (a1 <= 785)
    {
      if ((a1 - 274) > 4 || ((1 << (a1 - 18)) & 0x13) == 0)
      {
        if ((a1 - 530) > 4)
          return 0;
        result = 0;
        if (((1 << (a1 - 18)) & 0x13) == 0)
          return result;
      }
      v7 = a2 == 0;
      v8 = 261;
LABEL_44:
      if (v7)
        return v8;
      else
        return v8 + 1;
    }
    if ((a1 - 786) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0
      || (a1 - 1042) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0)
    {
      goto LABEL_41;
    }
    if ((a1 - 1298) <= 4)
    {
      result = 0;
      if (((1 << (a1 - 18)) & 0x13) == 0)
        return result;
      goto LABEL_31;
    }
    return 0;
  }
  if (a1 > 3345)
  {
    if ((a1 - 3346) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0
      || (a1 - 3602) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0)
    {
LABEL_41:
      v7 = a2 == 0;
      v8 = 1797;
      goto LABEL_44;
    }
    if ((a1 - 3858) <= 4)
    {
      result = 0;
      if (((1 << (a1 - 18)) & 0x13) == 0)
        return result;
      goto LABEL_41;
    }
    return 0;
  }
  if ((a1 - 1554) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0)
  {
LABEL_31:
    v7 = a2 == 0;
    v8 = 1285;
    goto LABEL_44;
  }
  if ((a1 - 1810) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0)
    goto LABEL_41;
  if (a2)
    v5 = 2054;
  else
    v5 = 2053;
  if (((1 << (a1 - 18)) & 0x13) != 0)
    v6 = v5;
  else
    v6 = 0;
  if ((a1 - 2066) <= 4)
    return v6;
  else
    return 0;
}

uint64_t CI::format_is_r(int a1)
{
  unint64_t v1;

  HIDWORD(v1) = a1 - 261;
  LODWORD(v1) = a1 - 261;
  return ((v1 >> 8) < 0xD) & (0x11D5u >> ((unsigned __int16)(a1 - 261) >> 8));
}

uint64_t CI::format_is_rg(int a1)
{
  unint64_t v1;

  HIDWORD(v1) = a1 - 262;
  LODWORD(v1) = a1 - 262;
  return ((v1 >> 8) < 0xD) & (0x11D5u >> ((unsigned __int16)(a1 - 262) >> 8));
}

uint64_t CI::format_is_rgb(int a1)
{
  uint64_t result;
  unsigned int v3;
  int v4;
  int v5;
  unsigned int v6;

  result = 1;
  if (a1 > 2054)
  {
    if (a1 > 2566)
    {
      if (a1 <= 2823)
      {
        if (a1 != 2567 && a1 != 2569)
          return 0;
      }
      else if (a1 != 2824 && a1 != 3079 && a1 != 3081)
      {
        return 0;
      }
      return result;
    }
    if ((a1 - 2311) <= 5 && ((1 << (a1 - 7)) & 0x27) != 0)
      return result;
    v3 = a1 - 2055;
    if (v3 <= 5)
    {
      v4 = 1 << v3;
      v5 = 35;
      goto LABEL_13;
    }
    return 0;
  }
  if ((a1 - 263) < 9 || (a1 - 1799) <= 5 && ((1 << (a1 - 7)) & 0x27) != 0)
    return result;
  v6 = a1 - 775;
  if (v6 > 0xA)
    return 0;
  v4 = 1 << v6;
  v5 = 1537;
LABEL_13:
  if ((v4 & v5) == 0)
    return 0;
  return result;
}

uint64_t CI::format_only_alpha(int a1)
{
  unint64_t v1;

  HIDWORD(v1) = a1 - 257;
  LODWORD(v1) = a1 - 257;
  return ((v1 >> 8) < 9) & (0x1C1u >> ((unsigned __int16)(a1 - 257) >> 8));
}

uint64_t CI::format_has_x(int a1)
{
  uint64_t result;

  result = 1;
  if (a1 > 1803)
  {
    if (a1 <= 2315)
    {
      if (a1 != 1804 && a1 != 2060)
        return 0;
    }
    else if (a1 != 2316 && a1 != 2567 && a1 != 3079)
    {
      return 0;
    }
  }
  else if ((a1 - 268) >= 4 && a1 != 775)
  {
    return 0;
  }
  return result;
}

uint64_t CI::format_with_x_for_format(uint64_t result)
{
  int v1;

  if ((int)result > 783)
  {
    if ((int)result > 2055)
    {
      if ((_DWORD)result == 2056)
      {
        return 2060;
      }
      else if ((_DWORD)result == 2312)
      {
        return 2316;
      }
    }
    else if ((_DWORD)result == 784)
    {
      return 775;
    }
    else if ((_DWORD)result == 1800)
    {
      return 1804;
    }
  }
  else
  {
    v1 = result - 264;
    result = 270;
    switch(v1)
    {
      case 0:
        result = 268;
        break;
      case 1:
        result = 269;
        break;
      case 3:
        result = 271;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t CI::format_is_luminance(int a1)
{
  uint64_t result;

  result = 1;
  if (a1 > 2050)
  {
    if ((a1 - 2051) >= 2 && (a1 - 2307) >= 2 && a1 != 3331)
      return 0;
  }
  else if ((a1 - 259) >= 2 && (a1 - 1795) >= 2 && a1 != 771)
  {
    return 0;
  }
  return result;
}

uint64_t CI::format_is_ycc_420(int a1)
{
  unint64_t v1;

  HIDWORD(v1) = a1 - 274;
  LODWORD(v1) = a1 - 274;
  return ((v1 >> 8) < 0xF) & (0x70FFu >> ((unsigned __int16)(a1 - 274) >> 8));
}

uint64_t CI::format_is_ycc_444(int a1)
{
  unint64_t v1;

  HIDWORD(v1) = a1 - 275;
  LODWORD(v1) = a1 - 275;
  return ((v1 >> 8) < 0xF) & (0x70FFu >> ((unsigned __int16)(a1 - 275) >> 8));
}

uint64_t CI::format_is_ycc_full_range(int a1)
{
  uint64_t result;
  unsigned int v3;

  result = 1;
  if (a1 <= 1809)
  {
    if ((a1 - 274) < 5 || (a1 - 786) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0)
      return result;
    v3 = a1 - 1298;
    goto LABEL_8;
  }
  if (((a1 - 1810) > 4 || ((1 << (a1 - 18)) & 0x13) == 0)
    && ((a1 - 2066) > 4 || ((1 << (a1 - 18)) & 0x13) == 0))
  {
    v3 = a1 - 3346;
LABEL_8:
    if (v3 > 4 || ((1 << v3) & 0x13) == 0)
      return 0;
  }
  return result;
}

uint64_t CI::format_get_default_ycc_color_matrix(int a1)
{
  uint64_t result;
  unsigned int v3;

  result = CI::format_is_ycc(a1);
  if (a1 != 535 && !(_DWORD)result)
    return result;
  result = 601;
  if (a1 > 1297)
  {
    if (a1 > 2065)
    {
      if (((a1 - 3346) > 4 || ((1 << (a1 - 18)) & 0x13) == 0) && a1 != 2066)
        return 709;
      return result;
    }
    if ((a1 - 1298) <= 4 && ((1 << (a1 - 18)) & 0x13) != 0)
      return result;
    v3 = a1 - 1810;
  }
  else
  {
    if ((a1 - 274) < 5 || (a1 - 532) <= 3 && a1 != 534)
      return result;
    v3 = a1 - 786;
  }
  if (v3 > 4 || ((1 << v3) & 0x13) == 0)
    return 709;
  return result;
}

uint64_t CI::format_is_float(int a1)
{
  uint64_t result;
  unsigned int v3;

  result = 1;
  if ((a1 - 2049) > 0x15 || ((1 << (a1 - 1)) & 0x2608FF) == 0)
  {
    v3 = a1 - 2305;
    if (v3 > 0xB || ((1 << v3) & 0x9FF) == 0)
      return 0;
  }
  return result;
}

BOOL CI::format_is_extended(int a1)
{
  _BOOL8 result;

  result = 1;
  if (((a1 - 2049) > 0x15 || ((1 << (a1 - 1)) & 0x2608FF) == 0)
    && ((a1 - 2305) > 0xB || ((1 << (a1 - 1)) & 0x9FF) == 0))
  {
    return ((a1 - 2567) & 0xFFFFFDFD) == 0;
  }
  return result;
}

BOOL CI::format_is_deep(int a1)
{
  return CI::format_bits_per_component(a1) > 8;
}

uint64_t CI::format_is_packed(int a1)
{
  uint64_t result;
  unsigned int v3;

  result = 1;
  if ((a1 - 1285) > 0x11 || ((1 << (a1 - 5)) & 0x26003) == 0)
  {
    v3 = a1 - 1554;
    if (v3 > 4 || ((1 << v3) & 0x13) == 0)
      return 0;
  }
  return result;
}

uint64_t CI::format_get_clear_color(uint64_t result, _DWORD *a2, int *a3, _DWORD *a4, _DWORD *a5)
{
  int v5;

  *a5 = 0;
  *a4 = 0;
  *a3 = 0;
  *a2 = 0;
  if ((int)result > 531)
  {
    if ((_DWORD)result == 535)
    {
      *a2 = 1031831681;
      *a3 = 1056997505;
      *a4 = 1056997505;
      return result;
    }
    if ((_DWORD)result != 533)
    {
      if ((_DWORD)result == 532)
      {
        *a2 = 1056997505;
        v5 = 1031831681;
LABEL_12:
        *a3 = v5;
        return result;
      }
      return result;
    }
    *a2 = 1031831681;
LABEL_11:
    v5 = 1056997505;
    goto LABEL_12;
  }
  if ((_DWORD)result == 276)
  {
    *a2 = 1056997505;
    return result;
  }
  if ((_DWORD)result == 277)
    goto LABEL_11;
  return result;
}

uint64_t CI::format_is_not_supported_as_destination_on_gles(int a1)
{
  unsigned int v1;

  v1 = ((a1 - 2305) < 0xC) & (0x9FFu >> (a1 - 1));
  if ((a1 - 1285) < 2)
    LOBYTE(v1) = 1;
  if ((a1 & 0xFFFFFFFE) == 0x708)
    LOBYTE(v1) = 1;
  if (a1 == 263)
    LOBYTE(v1) = 1;
  if (a1 == 1799)
    LOBYTE(v1) = 1;
  if ((a1 & 0xFFFFFEFF) == 0x807)
    LOBYTE(v1) = 1;
  return v1 & 1;
}

uint64_t CI::format_is_supported_render_to_bitmap(int a1)
{
  uint64_t result;
  int v3;
  int v4;

  if ((CI::format_is_ycc_biplanar(a1) & 1) != 0)
    return 0;
  result = 1;
  if (a1 > 2048)
  {
    if (a1 <= 2566)
    {
      if ((a1 - 2305) <= 0xB && ((1 << (a1 - 1)) & 0x9FD) != 0)
        return result;
      if ((a1 - 2049) <= 0xB)
      {
        v3 = 1 << (a1 - 1);
        v4 = 2301;
LABEL_23:
        if ((v3 & v4) != 0)
          return result;
      }
    }
    else
    {
      if (a1 > 3080)
      {
        if (((a1 - 3331) > 3 || a1 == 3332) && a1 != 3081)
          return 0;
        return result;
      }
      if (a1 == 2567 || a1 == 2569 || a1 == 3079)
        return result;
    }
    return 0;
  }
  if (a1 > 770)
  {
    if ((a1 - 1793) <= 0xB && ((1 << (a1 - 1)) & 0x9FD) != 0)
      return result;
    if ((a1 - 771) <= 0xE)
    {
      v3 = 1 << (a1 - 3);
      v4 = 24605;
      goto LABEL_23;
    }
    return 0;
  }
  if (((a1 - 257) > 0xE || a1 == 258) && a1 != 535)
    return 0;
  return result;
}

uint64_t CI::input_format_for_conversion(int a1)
{
  if ((a1 - 1) > 0x33)
    return 0;
  else
    return dword_19249B690[a1 - 1];
}

uint64_t CI::output_format_for_conversion(int a1)
{
  if ((a1 - 1) > 0x33)
    return 0;
  else
    return dword_19249B760[a1 - 1];
}

uint64_t CI::format_swizzle_for_input(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v3;
  int v5;
  char v6;
  NSObject *v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;
  char v13;
  char v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;

  v2 = 0;
  v3 = 0;
  if (!(_DWORD)a1 || !a2)
    return v2 | v3;
  v5 = a1;
  if ((a1 - 532) >= 2 && (a1 - 276) > 1)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1) & 1) != 0)
    {
      v2 = 0;
      goto LABEL_7;
    }
  }
  else if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1) & 1) != 0)
  {
    v2 = 0x400000000;
LABEL_7:
    v3 = v5;
    return v2 | v3;
  }
  if (v5 <= 1792)
  {
    if (v5 > 534)
    {
      if (v5 > 1041)
      {
        if (v5 <= 1298)
        {
          if (v5 > 1045)
          {
            if (v5 == 1046)
            {
              v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
              {
                v2 = 0;
                return v2 | v3;
              }
            }
            else if (v5 == 1298)
            {
              v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
              {
                v2 = 0;
                return v2 | v3;
              }
            }
          }
          else if (v5 == 1042)
          {
            v3 = 2056;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
            {
              v2 = 0;
              return v2 | v3;
            }
          }
          else if (v5 == 1043)
          {
            v3 = 2056;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
            {
              v2 = 0;
              return v2 | v3;
            }
          }
        }
        else if (v5 <= 1553)
        {
          if (v5 == 1299)
          {
            v3 = 2056;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
            {
              v2 = 0;
              return v2 | v3;
            }
          }
          else if (v5 == 1302)
          {
            v3 = 2056;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
            {
              v2 = 0;
              return v2 | v3;
            }
          }
        }
        else
        {
          switch(v5)
          {
            case 1554:
              v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
              {
                v2 = 0;
                return v2 | v3;
              }
              break;
            case 1555:
              v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
              {
                v2 = 0;
                return v2 | v3;
              }
              break;
            case 1558:
              v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
              {
                v2 = 0;
                return v2 | v3;
              }
              break;
          }
        }
        goto LABEL_313;
      }
      switch(v5)
      {
        case 771:
          v3 = 773;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 773) & 1) != 0)
            goto LABEL_301;
          v3 = 1797;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1797) & 1) == 0)
            goto LABEL_228;
          v2 = 0x4E00000000;
          return v2 | v3;
        case 772:
        case 776:
        case 777:
        case 778:
        case 779:
        case 780:
        case 781:
        case 782:
        case 783:
        case 788:
        case 789:
          goto LABEL_313;
        case 773:
          v3 = 1797;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1797) & 1) == 0)
            goto LABEL_175;
          goto LABEL_178;
        case 774:
          v3 = 1798;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1798) & 1) == 0)
            goto LABEL_239;
LABEL_178:
          v2 = 0x4D00000000;
          return v2 | v3;
        case 775:
          v3 = 784;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 784) & 1) != 0)
          {
LABEL_269:
            v2 = 0xA00000000;
            return v2 | v3;
          }
          v3 = 785;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 785) & 1) != 0)
          {
LABEL_181:
            v2 = 0xB00000000;
            return v2 | v3;
          }
          v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0)
            goto LABEL_313;
          v2 = 0x3F00000000;
          return v2 | v3;
        case 784:
          v3 = 785;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 785) & 1) != 0)
            goto LABEL_186;
          v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0)
            goto LABEL_313;
          v2 = 0x4000000000;
          return v2 | v3;
        case 785:
          v3 = 784;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 784) & 1) != 0)
          {
LABEL_186:
            v2 = 0x100000000;
            return v2 | v3;
          }
          v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0)
            goto LABEL_313;
          v2 = 0x4100000000;
          return v2 | v3;
        case 786:
          v3 = 2056;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
            goto LABEL_313;
          v2 = 0;
          return v2 | v3;
        case 787:
          v3 = 2056;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
            goto LABEL_313;
          v2 = 0;
          return v2 | v3;
        case 790:
          v3 = 2056;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
            goto LABEL_313;
          v2 = 0;
          return v2 | v3;
        default:
          if (v5 != 535)
            goto LABEL_313;
          v3 = 265;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 265) & 1) != 0)
            goto LABEL_316;
LABEL_102:
          v3 = 266;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266) & 1) != 0)
          {
            v2 = 0x500000000;
            return v2 | v3;
          }
          v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0)
            goto LABEL_313;
LABEL_271:
          v2 = 0x600000000;
          break;
      }
    }
    else
    {
      switch(v5)
      {
        case 257:
          v3 = 261;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 261) & 1) == 0)
          {
            v3 = 259;
            v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 259);
LABEL_50:
            if ((v6 & 1) == 0)
              goto LABEL_313;
          }
LABEL_51:
          v2 = 0x1400000000;
          return v2 | v3;
        case 258:
          v3 = 261;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 261) & 1) == 0)
          {
            v3 = 259;
            v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 259);
LABEL_254:
            if ((v8 & 1) == 0)
              goto LABEL_313;
          }
LABEL_255:
          v2 = 0x800000000;
          return v2 | v3;
        case 259:
          v3 = 261;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 261) & 1) != 0)
            goto LABEL_301;
          v3 = 257;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 257) & 1) != 0)
          {
LABEL_258:
            v2 = 0x1A00000000;
            return v2 | v3;
          }
          v3 = 258;
          v9 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 258);
LABEL_300:
          if ((v9 & 1) != 0)
            goto LABEL_301;
          goto LABEL_313;
        case 260:
          v3 = 262;
          v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 262);
LABEL_199:
          if ((v10 & 1) == 0)
            goto LABEL_313;
LABEL_260:
          v2 = 0x900000000;
          return v2 | v3;
        case 261:
          v3 = 259;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 259) & 1) != 0)
            goto LABEL_304;
          v3 = 257;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 257) & 1) != 0)
          {
LABEL_263:
            v2 = 0x1700000000;
            return v2 | v3;
          }
          v3 = 258;
          v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 258);
LABEL_303:
          if ((v11 & 1) == 0)
            goto LABEL_313;
LABEL_304:
          v2 = 0x1600000000;
          return v2 | v3;
        case 262:
          v3 = 260;
          v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 260);
LABEL_205:
          if ((v12 & 1) == 0)
            goto LABEL_313;
LABEL_265:
          v2 = 0x1800000000;
          return v2 | v3;
        case 263:
          v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0)
            goto LABEL_313;
          v2 = 0;
          return v2 | v3;
        case 264:
          v3 = 266;
          v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266);
          goto LABEL_158;
        case 265:
          goto LABEL_102;
        case 266:
          v3 = 264;
          v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264);
LABEL_158:
          if ((v13 & 1) == 0)
            goto LABEL_313;
          goto LABEL_186;
        case 267:
          v3 = 266;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266) & 1) != 0)
          {
            v2 = 0x300000000;
            return v2 | v3;
          }
          v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0)
            goto LABEL_313;
          v2 = 0x200000000;
          return v2 | v3;
        case 268:
          v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) != 0)
            goto LABEL_269;
          v3 = 266;
          v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266);
          goto LABEL_169;
        case 269:
          v3 = 265;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 265) & 1) != 0)
            goto LABEL_269;
          v3 = 266;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266) & 1) != 0)
          {
            v2 = 0xD00000000;
            return v2 | v3;
          }
          v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0)
            goto LABEL_313;
          v2 = 0xE00000000;
          return v2 | v3;
        case 270:
          v3 = 266;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266) & 1) != 0)
            goto LABEL_269;
          v3 = 264;
          v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264);
LABEL_169:
          if ((v14 & 1) == 0)
            goto LABEL_313;
          goto LABEL_181;
        case 271:
          v3 = 267;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 267) & 1) != 0)
            goto LABEL_269;
          v3 = 266;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266) & 1) != 0)
          {
            v2 = 0xC00000000;
            return v2 | v3;
          }
          v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0)
            goto LABEL_313;
          v2 = 0xF00000000;
          return v2 | v3;
        case 272:
        case 273:
        case 274:
        case 275:
          goto LABEL_313;
        case 276:
          goto LABEL_98;
        case 277:
          goto LABEL_80;
        default:
          if (v5 != 532)
          {
            if (v5 != 533)
              goto LABEL_313;
LABEL_80:
            v3 = 264;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) != 0)
            {
              v2 = 0;
              return v2 | v3;
            }
            goto LABEL_313;
          }
LABEL_98:
          v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) == 0)
            goto LABEL_313;
          v2 = 0;
          break;
      }
    }
  }
  else
  {
    if (v5 > 2304)
    {
      if (v5 > 3080)
      {
        if (v5 <= 3349)
        {
          if (v5 > 3333)
          {
            switch(v5)
            {
              case 3334:
                v3 = 1798;
                if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1798) & 1) != 0)
                {
LABEL_316:
                  v2 = 0;
                  return v2 | v3;
                }
LABEL_239:
                v3 = 264;
                if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) != 0)
                {
LABEL_240:
                  v2 = 0x2300000000;
                  return v2 | v3;
                }
                break;
              case 3346:
                v3 = 2056;
                if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
                {
                  v2 = 0;
                  return v2 | v3;
                }
                break;
              case 3347:
                v3 = 2056;
                if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
                {
                  v2 = 0;
                  return v2 | v3;
                }
                break;
            }
          }
          else
          {
            switch(v5)
            {
              case 3081:
                if ((*(unsigned int (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1800))
                {
                  v15 = ci_logger_render();
                  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                    CI::format_swizzle_for_input();
                  goto LABEL_315;
                }
                break;
              case 3331:
                v3 = 3333;
                if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 3333) & 1) != 0
                  || (v3 = 1797, ((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1797) & 1) != 0))
                {
LABEL_301:
                  v2 = 0x1500000000;
                  return v2 | v3;
                }
LABEL_228:
                v3 = 262;
                if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 262) & 1) != 0)
                {
LABEL_229:
                  v2 = 0x1C00000000;
                  return v2 | v3;
                }
                break;
              case 3333:
                v3 = 1797;
                if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1797) & 1) != 0)
                  goto LABEL_316;
LABEL_175:
                v3 = 262;
                if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 262) & 1) != 0)
                {
LABEL_176:
                  v2 = 0x1B00000000;
                  return v2 | v3;
                }
                break;
            }
          }
        }
        else if (v5 <= 3605)
        {
          switch(v5)
          {
            case 3350:
              v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
              {
                v2 = 0;
                return v2 | v3;
              }
              break;
            case 3602:
              v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
              {
                v2 = 0;
                return v2 | v3;
              }
              break;
            case 3603:
              v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
              {
                v2 = 0;
                return v2 | v3;
              }
              break;
          }
        }
        else if (v5 > 3858)
        {
          if (v5 == 3859)
          {
            v3 = 2056;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
            {
              v2 = 0;
              return v2 | v3;
            }
          }
          else if (v5 == 3862)
          {
            v3 = 2056;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
            {
              v2 = 0;
              return v2 | v3;
            }
          }
        }
        else if (v5 == 3606)
        {
          v3 = 2056;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
          {
            v2 = 0;
            return v2 | v3;
          }
        }
        else if (v5 == 3858)
        {
          v3 = 2056;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
          {
            v2 = 0;
            return v2 | v3;
          }
        }
      }
      else
      {
        if (v5 <= 2566)
        {
          switch(v5)
          {
            case 2305:
              v3 = 2309;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2309) & 1) != 0)
                goto LABEL_51;
              v3 = 2307;
              v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2307);
              goto LABEL_50;
            case 2306:
              v3 = 2309;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2309) & 1) != 0)
                goto LABEL_255;
              v3 = 2307;
              v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2307);
              goto LABEL_254;
            case 2307:
              v3 = 2309;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2309) & 1) != 0)
                goto LABEL_301;
              v3 = 2305;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2305) & 1) != 0)
                goto LABEL_258;
              v3 = 2306;
              v9 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2306);
              goto LABEL_300;
            case 2308:
              v3 = 2310;
              v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2310);
              goto LABEL_199;
            case 2309:
              v3 = 2307;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2307) & 1) != 0)
                goto LABEL_304;
              v3 = 2305;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2305) & 1) != 0)
                goto LABEL_263;
              v3 = 2306;
              v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2306);
              goto LABEL_303;
            case 2310:
              v3 = 2308;
              v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2308);
              goto LABEL_205;
            case 2311:
              v3 = 2312;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2312) & 1) != 0)
              {
                v2 = 0;
                return v2 | v3;
              }
              v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
                goto LABEL_313;
              v2 = 0xA00000000;
              break;
            case 2312:
              v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
                goto LABEL_313;
              v2 = 0;
              return v2 | v3;
            case 2313:
              v3 = 2312;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2312) & 1) != 0)
                goto LABEL_271;
              v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
                goto LABEL_313;
              v2 = 0x600000000;
              return v2 | v3;
            case 2316:
              v3 = 2312;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2312) & 1) != 0)
                goto LABEL_269;
              v3 = 2056;
              if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
                goto LABEL_313;
              v2 = 0xA00000000;
              return v2 | v3;
            default:
              goto LABEL_313;
          }
          return v2 | v3;
        }
        if (v5 > 2823)
        {
          if (v5 == 2824)
          {
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1800))
            {
              v16 = ci_logger_render();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
                CI::format_swizzle_for_input();
              goto LABEL_315;
            }
          }
          else if (v5 == 3079)
          {
            v3 = 785;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 785) & 1) != 0)
            {
              v2 = 0x4900000000;
              return v2 | v3;
            }
            v3 = 784;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 784) & 1) != 0)
            {
              v2 = 0x4800000000;
              return v2 | v3;
            }
            v3 = 264;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) != 0)
            {
              v2 = 0x4700000000;
              return v2 | v3;
            }
          }
        }
        else if (v5 == 2567)
        {
          v3 = 785;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 785) & 1) != 0)
          {
            v2 = 0x4400000000;
            return v2 | v3;
          }
          v3 = 784;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 784) & 1) != 0)
          {
            v2 = 0x4300000000;
            return v2 | v3;
          }
          v3 = 264;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) != 0)
          {
            v2 = 0x4200000000;
            return v2 | v3;
          }
        }
        else if (v5 == 2569)
        {
          v3 = 1800;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1800) & 1) != 0)
          {
            v2 = 0x4C00000000;
            return v2 | v3;
          }
          v3 = 2056;
          if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
          {
            v2 = 0x4C00000000;
            return v2 | v3;
          }
        }
      }
LABEL_313:
      v18 = ci_logger_render();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        CI::format_swizzle_for_input(v5);
LABEL_315:
      v3 = 0;
      goto LABEL_316;
    }
    switch(v5)
    {
      case 1793:
        v3 = 1797;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1797) & 1) != 0)
          goto LABEL_51;
        v3 = 1795;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1795) & 1) != 0)
          goto LABEL_51;
        v3 = 262;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 262) & 1) != 0)
        {
          v2 = 0x1D00000000;
          return v2 | v3;
        }
        v3 = 260;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 260) & 1) == 0)
          goto LABEL_313;
        v2 = 0x2100000000;
        return v2 | v3;
      case 1794:
        v3 = 1797;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1797) & 1) != 0)
          goto LABEL_255;
        v3 = 1795;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1795) & 1) != 0)
          goto LABEL_255;
        v3 = 262;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 262) & 1) != 0)
        {
          v2 = 0x1E00000000;
          return v2 | v3;
        }
        v3 = 260;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 260) & 1) == 0)
          goto LABEL_313;
        v2 = 0x2200000000;
        return v2 | v3;
      case 1795:
        v3 = 1797;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1797) & 1) != 0)
          goto LABEL_301;
        v3 = 1793;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1793) & 1) != 0)
          goto LABEL_258;
        v3 = 1794;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1794) & 1) != 0)
          goto LABEL_301;
        v3 = 262;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 262) & 1) != 0)
          goto LABEL_229;
        v3 = 260;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 260) & 1) == 0)
          goto LABEL_313;
        v2 = 0x2000000000;
        return v2 | v3;
      case 1796:
        v3 = 1798;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1798) & 1) != 0)
          goto LABEL_260;
        v3 = 264;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) != 0)
        {
          v2 = 0x2400000000;
          return v2 | v3;
        }
        if (!(*(unsigned int (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266))
          goto LABEL_313;
        v17 = ci_logger_render();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          CI::format_swizzle_for_input();
        goto LABEL_315;
      case 1797:
        v3 = 1795;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1795) & 1) != 0)
          goto LABEL_304;
        v3 = 1793;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1793) & 1) != 0)
          goto LABEL_263;
        v3 = 1794;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1794) & 1) != 0)
          goto LABEL_304;
        v3 = 262;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 262) & 1) != 0)
          goto LABEL_176;
        v3 = 260;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 260) & 1) == 0)
          goto LABEL_313;
        v2 = 0x1F00000000;
        return v2 | v3;
      case 1798:
        v3 = 1796;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1796) & 1) != 0)
          goto LABEL_265;
        v3 = 264;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 264) & 1) != 0)
          goto LABEL_240;
        if (!(*(unsigned int (**)(uint64_t, uint64_t))(a2 + 16))(a2, 266))
          goto LABEL_313;
        v7 = ci_logger_render();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          CI::format_swizzle_for_input();
        goto LABEL_315;
      case 1799:
        v3 = 1800;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1800) & 1) != 0)
        {
          v2 = 0;
          return v2 | v3;
        }
        v3 = 2056;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
          goto LABEL_313;
        v2 = 0;
        break;
      case 1800:
        v3 = 2056;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
          goto LABEL_313;
        v2 = 0;
        return v2 | v3;
      case 1801:
        v3 = 1800;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1800) & 1) != 0)
          goto LABEL_271;
        v3 = 2056;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
          goto LABEL_313;
        v2 = 0x600000000;
        return v2 | v3;
      case 1802:
      case 1803:
      case 1805:
      case 1806:
      case 1807:
      case 1808:
      case 1809:
      case 1812:
      case 1813:
        goto LABEL_313;
      case 1804:
        v3 = 1800;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 1800) & 1) != 0)
          goto LABEL_269;
        v3 = 2056;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
          goto LABEL_313;
        v2 = 0xA00000000;
        return v2 | v3;
      case 1810:
        v3 = 2056;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
          goto LABEL_313;
        v2 = 0;
        return v2 | v3;
      case 1811:
        v3 = 2056;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
          goto LABEL_313;
        v2 = 0;
        return v2 | v3;
      case 1814:
        v3 = 2056;
        if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
          goto LABEL_313;
        v2 = 0;
        return v2 | v3;
      default:
        switch(v5)
        {
          case 2049:
            v3 = 2053;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2053) & 1) != 0)
              goto LABEL_51;
            v3 = 2051;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2051) & 1) != 0)
              goto LABEL_51;
            v3 = 2050;
            v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2050);
            goto LABEL_50;
          case 2050:
            v3 = 2053;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2053) & 1) != 0)
              goto LABEL_255;
            v3 = 2051;
            v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2051);
            goto LABEL_254;
          case 2051:
            v3 = 2053;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2053) & 1) != 0)
              goto LABEL_301;
            v3 = 2049;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2049) & 1) != 0)
              goto LABEL_258;
            v3 = 2050;
            v9 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2050);
            goto LABEL_300;
          case 2052:
            v3 = 2054;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2054) & 1) != 0)
              goto LABEL_260;
            v3 = 2310;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2310) & 1) == 0)
              goto LABEL_313;
            v2 = 0x900000000;
            return v2 | v3;
          case 2053:
            v3 = 2051;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2051) & 1) != 0)
              goto LABEL_304;
            v3 = 2049;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2049) & 1) != 0)
              goto LABEL_263;
            v3 = 2050;
            v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2050);
            goto LABEL_303;
          case 2054:
            v3 = 2052;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2052) & 1) != 0)
              goto LABEL_265;
            v3 = 2310;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2310) & 1) == 0)
              goto LABEL_313;
            v2 = 0;
            return v2 | v3;
          case 2055:
            v3 = 2056;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) == 0)
              goto LABEL_313;
            v2 = 0;
            return v2 | v3;
          case 2060:
            v3 = 2056;
            if (((*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 2056) & 1) != 0)
              goto LABEL_269;
            goto LABEL_313;
          default:
            goto LABEL_313;
        }
    }
  }
  return v2 | v3;
}

void CI::format_swizzle_for_output(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, int64x2_t *a4@<X8>)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  NSObject *v35;
  NSObject *v36;
  int64x2_t v37;
  int64x2_t v38;
  int v39;
  int v40;
  int64x2_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  NSObject *v52;

  if (!(_DWORD)a1 || !a3)
    goto LABEL_423;
  v7 = a1;
  if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, a1))
  {
    a4->i32[1] = 0;
    a4->i32[2] = 0;
    a4->i32[0] = v7;
LABEL_425:
    v34 = 1;
    goto LABEL_426;
  }
  if (v7 > 1792)
  {
    if (v7 <= 2304)
    {
      switch(v7)
      {
        case 1793:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797))
          {
            v8 = 1797;
            goto LABEL_395;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1795))
          {
            v43 = 1795;
            goto LABEL_353;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1794))
          {
            v8 = 1794;
            goto LABEL_395;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
          {
            a4->i64[0] = 262;
            v12 = 39;
            goto LABEL_396;
          }
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
            goto LABEL_421;
          a4->i64[0] = 264;
          v47 = 87;
          goto LABEL_408;
        case 1794:
          goto LABEL_423;
        case 1795:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797))
            goto LABEL_308;
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1794))
            goto LABEL_309;
          v9 = 1794;
          goto LABEL_356;
        case 1796:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
          {
            v9 = 1798;
            goto LABEL_356;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
          {
            a4->i64[0] = 264;
            v12 = 43;
            goto LABEL_396;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266))
          {
            a4->i64[0] = 266;
            v12 = 42;
            goto LABEL_396;
          }
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1800))
            goto LABEL_421;
          v45 = 1800;
          goto LABEL_407;
        case 1797:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1795))
          {
            v26 = 1795;
            goto LABEL_242;
          }
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1794))
            goto LABEL_299;
          v44 = 1794;
          break;
        case 1798:
          goto LABEL_229;
        case 1799:
          if ((a2 & 1) == 0 || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797))
            goto LABEL_421;
          v27 = 1797;
          goto LABEL_248;
        case 1800:
        case 1802:
        case 1803:
        case 1805:
        case 1806:
        case 1807:
        case 1808:
        case 1809:
        case 1812:
        case 1813:
          goto LABEL_421;
        case 1801:
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1800))
            goto LABEL_421;
          v28 = 1800;
          goto LABEL_274;
        case 1804:
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1800))
            goto LABEL_421;
          v29 = 1800;
          goto LABEL_251;
        case 1810:
          goto LABEL_66;
        case 1811:
          goto LABEL_100;
        case 1814:
          goto LABEL_95;
        default:
          switch(v7)
          {
            case 2049:
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053))
              {
                v8 = 2053;
                goto LABEL_395;
              }
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2051))
              {
                v43 = 2051;
                goto LABEL_353;
              }
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2050))
              {
                v8 = 2050;
                goto LABEL_395;
              }
              if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2056))
                goto LABEL_421;
              v51 = 2056;
              goto LABEL_415;
            case 2050:
              goto LABEL_423;
            case 2051:
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053))
              {
                v9 = 2053;
                goto LABEL_356;
              }
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2050))
              {
                v9 = 2050;
                goto LABEL_356;
              }
              if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2056))
                goto LABEL_421;
              v48 = 2056;
              goto LABEL_399;
            case 2052:
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2054))
              {
                v9 = 2054;
                goto LABEL_356;
              }
              if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2056))
                goto LABEL_421;
              v45 = 2056;
              goto LABEL_407;
            case 2053:
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2051))
              {
                v26 = 2051;
                goto LABEL_242;
              }
              if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2050))
              {
                v44 = 2050;
                goto LABEL_361;
              }
              if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2056))
                goto LABEL_421;
              v49 = 2056;
              goto LABEL_402;
            case 2054:
              if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2056))
                goto LABEL_421;
              v30 = 2056;
              goto LABEL_348;
            case 2055:
              if ((a2 & 1) == 0 || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053))
                goto LABEL_421;
              v27 = 2053;
              goto LABEL_248;
            case 2060:
              if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2056))
                goto LABEL_421;
              v29 = 2056;
              goto LABEL_251;
            case 2066:
              v39 = CI_ENABLE_WRITE_420();
              if ((~a2 & 0xD) == 0
                && v39
                && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053)
                && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2054))
              {
                v11 = 0x80600000805;
                goto LABEL_257;
              }
              CI_ENABLE_WRITE_420();
              if ((~a2 & 5) != 0
                || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053)
                || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2054))
              {
                goto LABEL_285;
              }
              v14 = 0x80600000805;
              goto LABEL_279;
            case 2067:
              if ((~a2 & 5) != 0
                || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053)
                || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2054))
              {
                goto LABEL_285;
              }
              v19 = 0x80600000805;
              goto LABEL_262;
            case 2070:
              v40 = CI_ENABLE_WRITE_420();
              if ((~a2 & 0xD) == 0
                && v40
                && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053)
                && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2054))
              {
                v16 = 0x80600000805;
                goto LABEL_268;
              }
              CI_ENABLE_WRITE_420();
              if ((~a2 & 5) == 0
                && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053)
                && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2054))
              {
                v20 = 0x80600000805;
                goto LABEL_284;
              }
LABEL_285:
              v42 = CI_ENABLE_WRITE_420();
              if ((~a2 & 0x24) != 0
                || !v42
                || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2053)
                || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2054))
              {
                goto LABEL_421;
              }
              v22 = 0x80600000805;
              break;
            default:
              goto LABEL_421;
          }
          goto LABEL_290;
      }
LABEL_361:
      a4->i64[0] = v44;
      v12 = 8;
      goto LABEL_396;
    }
    if (v7 <= 3080)
    {
      if (v7 <= 2566)
      {
        switch(v7)
        {
          case 2305:
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2309))
            {
              v8 = 2309;
              goto LABEL_395;
            }
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2307))
            {
              v43 = 2307;
              goto LABEL_353;
            }
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2306))
            {
              v8 = 2306;
              goto LABEL_395;
            }
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2312))
              goto LABEL_421;
            v51 = 2312;
            goto LABEL_415;
          case 2306:
            goto LABEL_423;
          case 2307:
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2309))
            {
              v9 = 2309;
              goto LABEL_356;
            }
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2306))
            {
              v9 = 2306;
              goto LABEL_356;
            }
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2312))
              goto LABEL_421;
            v48 = 2312;
            goto LABEL_399;
          case 2308:
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2310))
            {
              v9 = 2310;
              goto LABEL_356;
            }
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2312))
              goto LABEL_421;
            v45 = 2312;
            goto LABEL_407;
          case 2309:
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2307))
            {
              v26 = 2307;
              goto LABEL_242;
            }
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2306))
            {
              v44 = 2306;
              goto LABEL_361;
            }
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2312))
              goto LABEL_421;
            v49 = 2312;
            break;
          case 2310:
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2312))
              goto LABEL_421;
            v30 = 2312;
            goto LABEL_348;
          case 2311:
            if ((a2 & 1) == 0 || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2309))
              goto LABEL_421;
            v27 = 2309;
            goto LABEL_248;
          case 2313:
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2312))
              goto LABEL_421;
            v28 = 2312;
            goto LABEL_274;
          case 2316:
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 2312))
              goto LABEL_421;
            v29 = 2312;
            goto LABEL_251;
          default:
            goto LABEL_421;
        }
LABEL_402:
        a4->i64[0] = v49;
        v50 = 82;
        goto LABEL_416;
      }
      if (v7 > 2823)
      {
        if (v7 == 2824)
        {
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1800))
          {
            v36 = ci_logger_render();
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
              CI::format_swizzle_for_output();
            goto LABEL_423;
          }
        }
        else if (v7 == 3079)
        {
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 784))
          {
            a4->i64[0] = 784;
            v12 = 74;
            goto LABEL_396;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 785))
          {
            a4->i64[0] = 785;
            v12 = 75;
            goto LABEL_396;
          }
          if ((a2 & 2) != 0 && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
          {
            a4->i64[0] = 264;
            v12 = 51;
            goto LABEL_396;
          }
        }
      }
      else if (v7 == 2567)
      {
        if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 784))
        {
          a4->i64[0] = 784;
          v12 = 69;
          goto LABEL_396;
        }
        if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 785))
        {
          a4->i64[0] = 785;
          v12 = 70;
          goto LABEL_396;
        }
        if ((a2 & 2) != 0 && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
        {
          a4->i64[0] = 264;
          v12 = 50;
          goto LABEL_396;
        }
      }
      else if (v7 == 2569 && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1800))
      {
        a4->i64[0] = 1800;
        v12 = 52;
LABEL_396:
        a4->i32[2] = v12;
        goto LABEL_425;
      }
      goto LABEL_421;
    }
    if (v7 > 3349)
    {
      if (v7 > 3605)
      {
        if (v7 <= 3858)
        {
          if (v7 != 3606)
          {
            if (v7 != 3858)
              goto LABEL_421;
LABEL_66:
            v13 = CI_ENABLE_WRITE_420();
            if ((~a2 & 0xD) == 0
              && v13
              && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)
              && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
            {
              v11 = 0x70600000705;
LABEL_257:
              a4->i64[0] = v11;
              v12 = 56;
              goto LABEL_396;
            }
            CI_ENABLE_WRITE_420();
            if ((~a2 & 5) == 0
              && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)
              && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
            {
              v14 = 0x70600000705;
              goto LABEL_279;
            }
            goto LABEL_108;
          }
LABEL_95:
          v18 = CI_ENABLE_WRITE_420();
          if ((~a2 & 0xD) == 0
            && v18
            && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)
            && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
          {
            v16 = 0x70600000705;
            goto LABEL_268;
          }
          CI_ENABLE_WRITE_420();
          if ((~a2 & 5) == 0
            && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)
            && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
          {
            v20 = 0x70600000705;
            goto LABEL_284;
          }
LABEL_108:
          v21 = CI_ENABLE_WRITE_420();
          if ((~a2 & 0x24) != 0
            || !v21
            || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)
            || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
          {
            goto LABEL_421;
          }
          v22 = 0x70600000705;
LABEL_290:
          a4->i64[0] = v22;
          v12 = 60;
          goto LABEL_396;
        }
        if (v7 != 3859)
        {
          if (v7 != 3862)
            goto LABEL_421;
          goto LABEL_95;
        }
        goto LABEL_100;
      }
      if (v7 == 3350)
        goto LABEL_95;
      if (v7 == 3602)
        goto LABEL_66;
      if (v7 != 3603)
      {
LABEL_421:
        v52 = ci_logger_render();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          CI::format_swizzle_for_output(v7);
LABEL_423:
        a4->i64[0] = 0;
        goto LABEL_424;
      }
LABEL_100:
      if ((~a2 & 5) != 0
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797)
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
      {
        goto LABEL_108;
      }
      v19 = 0x70600000705;
LABEL_262:
      a4->i64[0] = v19;
      v12 = 55;
      goto LABEL_396;
    }
    if (v7 > 3333)
    {
      if (v7 != 3334)
      {
        if (v7 == 3346)
          goto LABEL_66;
        if (v7 != 3347)
          goto LABEL_421;
        goto LABEL_100;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
      {
        v33 = 1798;
        goto LABEL_271;
      }
LABEL_229:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
      {
        a4->i64[0] = 264;
        v12 = 41;
        goto LABEL_396;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266))
      {
        a4->i64[0] = 266;
        v12 = 40;
        goto LABEL_396;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1800))
        goto LABEL_421;
      v30 = 1800;
LABEL_348:
      a4->i64[0] = v30;
      v47 = 81;
    }
    else
    {
      if (v7 == 3081)
      {
        if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1800))
        {
          v35 = ci_logger_render();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            CI::format_swizzle_for_output();
          goto LABEL_423;
        }
        goto LABEL_421;
      }
      if (v7 == 3331)
      {
        if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 3333))
        {
          v9 = 3333;
        }
        else
        {
LABEL_307:
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797))
          {
LABEL_309:
            if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
            {
              a4->i64[0] = 262;
              v12 = 38;
              goto LABEL_396;
            }
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
              goto LABEL_421;
            a4->i64[0] = 264;
            v47 = 86;
            goto LABEL_408;
          }
LABEL_308:
          v9 = 1797;
        }
LABEL_356:
        a4->i64[0] = v9;
        v12 = 62;
        goto LABEL_396;
      }
      if (v7 != 3333)
        goto LABEL_421;
LABEL_193:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797))
      {
        v33 = 1797;
LABEL_271:
        a4->i64[0] = v33;
LABEL_424:
        a4->i32[2] = 0;
        goto LABEL_425;
      }
LABEL_299:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        a4->i64[0] = 262;
        v12 = 37;
        goto LABEL_396;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
        goto LABEL_421;
      a4->i64[0] = 264;
      v47 = 85;
    }
LABEL_408:
    a4->i32[2] = v47;
    v37 = (int64x2_t)xmmword_19249B960;
    goto LABEL_417;
  }
  if (v7 > 770)
  {
    if (v7 <= 1041)
    {
      switch(v7)
      {
        case 771:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 773))
          {
            v9 = 773;
            goto LABEL_356;
          }
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797))
            goto LABEL_307;
          a4->i64[0] = 1797;
          v12 = 80;
          goto LABEL_396;
        case 773:
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1797))
            goto LABEL_193;
          v32 = 1797;
          goto LABEL_197;
        case 774:
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1798))
            goto LABEL_229;
          v32 = 1798;
LABEL_197:
          a4->i64[0] = v32;
          v12 = 79;
          goto LABEL_396;
        case 775:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 784))
          {
            v29 = 784;
LABEL_251:
            a4->i64[0] = v29;
            v12 = 10;
            goto LABEL_396;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 785))
          {
            v46 = 785;
LABEL_331:
            a4->i64[0] = v46;
            v12 = 11;
            goto LABEL_396;
          }
          if ((a2 & 2) != 0 && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
          {
            a4->i64[0] = 264;
            v12 = 47;
            goto LABEL_396;
          }
          goto LABEL_421;
        case 784:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 785))
          {
            v31 = 785;
            goto LABEL_204;
          }
          if ((a2 & 2) == 0 || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
            goto LABEL_421;
          a4->i64[0] = 264;
          v12 = 49;
          goto LABEL_396;
        case 785:
          if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 784))
          {
            v31 = 784;
LABEL_204:
            a4->i64[0] = v31;
            v34 = 1;
            a4->i32[2] = 1;
            goto LABEL_426;
          }
          if ((a2 & 2) != 0 && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
          {
            a4->i64[0] = 264;
            v12 = 48;
            goto LABEL_396;
          }
          break;
        case 786:
          goto LABEL_66;
        case 787:
          goto LABEL_100;
        case 790:
          goto LABEL_95;
        default:
          goto LABEL_421;
      }
      goto LABEL_421;
    }
    if (v7 <= 1298)
    {
      if (v7 <= 1045)
      {
        if (v7 == 1042)
          goto LABEL_66;
        if (v7 != 1043)
          goto LABEL_421;
        goto LABEL_100;
      }
      if (v7 == 1046)
        goto LABEL_95;
      if (v7 != 1298)
        goto LABEL_421;
    }
    else
    {
      if (v7 <= 1553)
      {
        if (v7 != 1299)
        {
          if (v7 != 1302)
            goto LABEL_421;
          goto LABEL_77;
        }
LABEL_122:
        if ((~a2 & 5) != 0
          || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1285)
          || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1286))
        {
          v25 = CI_ENABLE_WRITE_420();
          if ((~a2 & 0x24) != 0
            || !v25
            || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1285)
            || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1286))
          {
            goto LABEL_421;
          }
          v22 = 0x50600000505;
          goto LABEL_290;
        }
        v19 = 0x50600000505;
        goto LABEL_262;
      }
      if (v7 != 1554)
      {
        if (v7 != 1555)
        {
          if (v7 != 1558)
            goto LABEL_421;
LABEL_77:
          v15 = CI_ENABLE_WRITE_420();
          if ((~a2 & 0xD) == 0
            && v15
            && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1285)
            && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1286))
          {
            v16 = 0x50600000505;
LABEL_268:
            a4->i64[0] = v16;
            v12 = 57;
            goto LABEL_396;
          }
          CI_ENABLE_WRITE_420();
          if ((~a2 & 5) != 0
            || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1285)
            || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1286))
          {
            goto LABEL_421;
          }
          v20 = 0x50600000505;
LABEL_284:
          a4->i64[0] = v20;
          a4->i32[2] = 54;
          v41 = (int64x2_t)xmmword_19249B960;
LABEL_427:
          a4[1] = v41;
          a4[2] = v41;
          return;
        }
        goto LABEL_122;
      }
    }
    v17 = CI_ENABLE_WRITE_420();
    if ((~a2 & 0xD) == 0
      && v17
      && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1285)
      && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1286))
    {
      v11 = 0x50600000505;
      goto LABEL_257;
    }
    CI_ENABLE_WRITE_420();
    if ((~a2 & 5) != 0
      || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1285)
      || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1286))
    {
      goto LABEL_421;
    }
    v14 = 0x50600000505;
LABEL_279:
    a4->i64[0] = v14;
    a4->i32[2] = 53;
    v34 = 2;
LABEL_426:
    v41 = vdupq_n_s64(v34);
    goto LABEL_427;
  }
  switch(v7)
  {
    case 257:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261))
      {
        v8 = 261;
LABEL_395:
        a4->i64[0] = v8;
        v12 = 7;
        goto LABEL_396;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 259))
      {
        v43 = 259;
LABEL_353:
        a4->i64[0] = v43;
        v12 = 26;
        goto LABEL_396;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 258))
      {
        v8 = 258;
        goto LABEL_395;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
        goto LABEL_421;
      v51 = 264;
LABEL_415:
      a4->i64[0] = v51;
      v50 = 84;
LABEL_416:
      a4->i32[2] = v50;
      v37 = (int64x2_t)xmmword_19249B980;
LABEL_417:
      v38 = vdupq_n_s64(1uLL);
LABEL_418:
      a4[1] = v37;
      a4[2] = v38;
      return;
    case 258:
      goto LABEL_423;
    case 259:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261))
      {
        v9 = 261;
        goto LABEL_356;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 258))
      {
        v9 = 258;
        goto LABEL_356;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
        goto LABEL_421;
      v48 = 264;
LABEL_399:
      a4->i64[0] = v48;
      v50 = 83;
      goto LABEL_416;
    case 260:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        v9 = 262;
        goto LABEL_356;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
        goto LABEL_421;
      v45 = 264;
LABEL_407:
      a4->i64[0] = v45;
      v47 = 88;
      goto LABEL_408;
    case 261:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 259))
      {
        v26 = 259;
LABEL_242:
        a4->i64[0] = v26;
        v12 = 21;
        goto LABEL_396;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 258))
      {
        v44 = 258;
        goto LABEL_361;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
      {
        v49 = 264;
        goto LABEL_402;
      }
      goto LABEL_421;
    case 262:
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
        goto LABEL_421;
      v30 = 264;
      goto LABEL_348;
    case 263:
      if ((a2 & 1) == 0 || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261))
        goto LABEL_421;
      v27 = 261;
LABEL_248:
      a4->i64[0] = v27;
      a4->i32[2] = 46;
      v37 = vdupq_n_s64(1uLL);
      v38 = (int64x2_t)xmmword_19249B970;
      goto LABEL_418;
    case 264:
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266))
        goto LABEL_421;
      v31 = 266;
      goto LABEL_204;
    case 265:
LABEL_272:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
      {
        v28 = 264;
LABEL_274:
        a4->i64[0] = v28;
        v12 = 3;
      }
      else
      {
        if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266))
          goto LABEL_421;
        a4->i64[0] = 266;
        v12 = 5;
      }
      goto LABEL_396;
    case 266:
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
        goto LABEL_421;
      v31 = 264;
      goto LABEL_204;
    case 267:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
      {
        a4->i64[0] = 264;
        v12 = 2;
        goto LABEL_396;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266))
        goto LABEL_421;
      a4->i64[0] = 266;
      v12 = 6;
      goto LABEL_396;
    case 268:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
      {
        v29 = 264;
        goto LABEL_251;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266))
        goto LABEL_421;
      v46 = 266;
      goto LABEL_331;
    case 269:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 265))
      {
        v29 = 265;
        goto LABEL_251;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
      {
        a4->i64[0] = 264;
        v12 = 17;
        goto LABEL_396;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266))
        goto LABEL_421;
      a4->i64[0] = 266;
      v12 = 19;
      goto LABEL_396;
    case 270:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266))
      {
        v29 = 266;
        goto LABEL_251;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
        goto LABEL_421;
      v46 = 264;
      goto LABEL_331;
    case 271:
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 267))
      {
        v29 = 267;
        goto LABEL_251;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 264))
      {
        a4->i64[0] = 264;
        v12 = 16;
        goto LABEL_396;
      }
      if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 266))
        goto LABEL_421;
      a4->i64[0] = 266;
      v12 = 18;
      goto LABEL_396;
    case 272:
    case 273:
    case 276:
    case 277:
      goto LABEL_421;
    case 274:
LABEL_44:
      v10 = CI_ENABLE_WRITE_420();
      if ((~a2 & 0xD) == 0
        && v10
        && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261)
        && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        v11 = 0x10600000105;
        goto LABEL_257;
      }
      CI_ENABLE_WRITE_420();
      if ((~a2 & 5) != 0
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261)
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        goto LABEL_134;
      }
      v14 = 0x10600000105;
      goto LABEL_279;
    case 275:
LABEL_113:
      if ((~a2 & 5) != 0
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261)
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        goto LABEL_134;
      }
      v19 = 0x10600000105;
      goto LABEL_262;
    case 278:
LABEL_117:
      v23 = CI_ENABLE_WRITE_420();
      if ((~a2 & 0xD) == 0
        && v23
        && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261)
        && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        v16 = 0x10600000105;
        goto LABEL_268;
      }
      CI_ENABLE_WRITE_420();
      if ((~a2 & 5) == 0
        && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261)
        && (*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        v20 = 0x10600000105;
        goto LABEL_284;
      }
LABEL_134:
      v24 = CI_ENABLE_WRITE_420();
      if ((~a2 & 0x24) != 0
        || !v24
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 261)
        || !(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 262))
      {
        goto LABEL_421;
      }
      v22 = 0x10600000105;
      goto LABEL_290;
    default:
      switch(v7)
      {
        case 530:
          goto LABEL_44;
        case 531:
          goto LABEL_113;
        case 534:
          goto LABEL_117;
        case 535:
          if (!(*(unsigned int (**)(uint64_t, uint64_t))(a3 + 16))(a3, 265))
            goto LABEL_272;
          v33 = 265;
          break;
        default:
          goto LABEL_421;
      }
      goto LABEL_271;
  }
}

uint64_t CI::format_CGBitmapInfo(int a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  int v5;
  int v6;
  int v7;

  if (a2)
    v2 = 1;
  else
    v2 = 3;
  if (a2)
    v3 = 2;
  else
    v3 = 4;
  if (a1 <= 1794)
  {
    if (a1 > 770)
    {
      switch(a1)
      {
        case 771:
          return 4096;
        case 775:
          return 204806;
        case 784:
          v6 = 204800;
          return v3 | v6;
        default:
          return 0xFFFFFFFFLL;
      }
    }
    else
    {
      v5 = a1 - 259;
      result = 0;
      switch(v5)
      {
        case 0:
        case 4:
          return result;
        case 1:
        case 5:
          result = v2;
          break;
        case 6:
          result = v3;
          break;
        case 7:
          result = v3 | 0x2000;
          break;
        case 8:
          result = v2 | 0x2000;
          break;
        case 9:
          result = 5;
          break;
        case 10:
          result = 6;
          break;
        case 11:
          result = 8198;
          break;
        case 12:
          result = 8197;
          break;
        default:
          return 0xFFFFFFFFLL;
      }
    }
  }
  else if (a1 > 2306)
  {
    switch(a1)
    {
      case 2307:
      case 2311:
        result = 8448;
        break;
      case 2308:
      case 2312:
        v7 = 8448;
LABEL_24:
        result = v2 | v7;
        break;
      case 2309:
      case 2310:
      case 2314:
      case 2315:
        return 0xFFFFFFFFLL;
      case 2313:
        v6 = 8448;
        return v3 | v6;
      case 2316:
        result = 8453;
        break;
      default:
        if (a1 == 3331)
          return 4096;
        return 0xFFFFFFFFLL;
    }
  }
  else
  {
    switch(a1)
    {
      case 1795:
      case 1799:
        return 4096;
      case 1796:
      case 1800:
        result = v2 | 0x1000;
        break;
      case 1797:
      case 1798:
      case 1802:
      case 1803:
        return 0xFFFFFFFFLL;
      case 1801:
        result = v3 | 0x1000;
        break;
      case 1804:
        result = 4101;
        break;
      default:
        switch(a1)
        {
          case 2051:
          case 2055:
            result = 4352;
            break;
          case 2052:
          case 2056:
            v7 = 4352;
            goto LABEL_24;
          case 2060:
            result = 4357;
            break;
          default:
            return 0xFFFFFFFFLL;
        }
        break;
    }
  }
  return result;
}

uint64_t CI::format_from_CVPixelBuffer(CI *this, __CVBuffer *a2)
{
  CI *PixelFormatType;
  uint64_t v4;

  PixelFormatType = (CI *)CVPixelBufferGetPixelFormatType(this);
  v4 = CI::format_from_PixelFormatType(PixelFormatType);
  if (CVBufferGetAttachment(this, (CFStringRef)*MEMORY[0x1E0CA8CA8], 0) == (CFTypeRef)*MEMORY[0x1E0C9AE50])
    return CI::format_with_x_for_format(v4);
  else
    return v4;
}

uint64_t CI::iosurface_destination_format_supported_p(CI *this)
{
  int v1;
  uint64_t result;
  int v3;
  unsigned int v4;
  unsigned __int16 v5;
  unsigned __int16 v6;

  v1 = equivalent_uncompressed_format((uint64_t)this);
  result = 1;
  if (v1 <= 1717855599)
  {
    if (v1 <= 875836517)
    {
      if (v1 <= 843264303)
      {
        if (v1 <= 826487087)
        {
          if (((v1 - 826486840) > 0x30 || ((1 << (v1 - 56)) & 0x1400000000001) == 0)
            && v1 != 24
            && v1 != 32)
          {
            return 0;
          }
        }
        else if ((v1 - 826487088) > 6 || ((1 << (v1 - 48)) & 0x45) == 0)
        {
          v4 = v1 - 843264056;
          if (v4 > 0x30 || ((1 << v4) & 0x1400000000001) == 0)
            return 0;
        }
        return result;
      }
      if (v1 <= 846624120)
      {
        if ((v1 - 843264304) <= 6 && ((1 << (v1 - 48)) & 0x45) != 0)
          return result;
        v3 = 846624102;
      }
      else
      {
        if (v1 <= 875704437)
        {
          if (v1 == 846624121)
            return result;
          v6 = 12390;
        }
        else
        {
          if (v1 == 875704438 || v1 == 875704934)
            return result;
          v6 = 12918;
        }
        v3 = v6 | 0x34320000;
      }
    }
    else if (v1 <= 1279340599)
    {
      if (v1 <= 1111970368)
      {
        if (v1 == 875836518 || v1 == 875836534)
          return result;
        v3 = 1094862674;
      }
      else
      {
        if ((v1 - 1278226488) <= 0x30 && ((1 << (v1 - 56)) & 0x1400000000001) != 0
          || (v1 - 1278226736) <= 6 && ((1 << (v1 - 48)) & 0x45) != 0)
        {
          return result;
        }
        v3 = 1111970369;
      }
    }
    else if (v1 <= 1380401728)
    {
      if ((v1 - 1279340600) <= 0x30 && ((1 << (v1 - 56)) & 0x1400000000001) != 0
        || v1 == 1279340854)
      {
        return result;
      }
      v3 = 1279342648;
    }
    else if (v1 > 1650943795)
    {
      if (v1 == 1650943796 || v1 == 1667838256)
        return result;
      v3 = 1667839024;
    }
    else
    {
      if (v1 == 1380401729 || v1 == 1380410945)
        return result;
      v3 = 1380411457;
    }
    goto LABEL_108;
  }
  if (v1 > 1936077875)
  {
    if (v1 > 1999843441)
    {
      if (v1 <= 2019963439)
      {
        if (v1 <= 2016686639)
        {
          if (v1 == 1999843442)
            return result;
          v3 = 1999908961;
        }
        else
        {
          if (v1 == 2016686640 || v1 == 2016686642)
            return result;
          v3 = 2016687156;
        }
      }
      else if (v1 > 2033463351)
      {
        if (v1 == 2033463352 || v1 == 2037741158)
          return result;
        v3 = 2037741171;
      }
      else
      {
        if (v1 == 2019963440 || v1 == 2019963442)
          return result;
        v3 = 2019963956;
      }
      goto LABEL_108;
    }
    if (v1 <= 1952854577)
    {
      if (v1 <= 1937125937)
      {
        if (v1 == 1936077876)
          return result;
        v3 = 1937125936;
        goto LABEL_108;
      }
      if (v1 == 1937125938 || v1 == 1937126452)
        return result;
      v5 = 12848;
LABEL_107:
      v3 = v5 | 0x74660000;
      goto LABEL_108;
    }
    if (v1 <= 1953903151)
    {
      if (v1 == 1952854578)
        return result;
      v5 = 13364;
      goto LABEL_107;
    }
    if (v1 == 1953903152 || v1 == 1953903154)
      return result;
    v3 = 1953903668;
LABEL_108:
    if (v1 == v3)
      return result;
    return 0;
  }
  if (v1 <= 1815361649)
  {
    if (v1 > 1751411058)
    {
      if (v1 <= 1751527985)
      {
        if (v1 == 1751411059)
          return result;
        v3 = 1751527984;
      }
      else
      {
        if (v1 == 1751527986 || v1 == 1751528500)
          return result;
        v3 = 1815162994;
      }
    }
    else if (v1 <= 1734505011)
    {
      if (v1 == 1717855600)
        return result;
      v3 = 1717856627;
    }
    else
    {
      if (v1 == 1734505012 || v1 == 1735549492)
        return result;
      v3 = 1751410032;
    }
    goto LABEL_108;
  }
  if (v1 <= 1885745711)
  {
    if (v1 <= 1882468911)
    {
      if (v1 == 1815361650)
        return result;
      v3 = 1815491698;
    }
    else
    {
      if (v1 == 1882468912 || v1 == 1882468914)
        return result;
      v3 = 1882469428;
    }
    goto LABEL_108;
  }
  if (v1 > 1919379251)
  {
    if (v1 == 1919379252 || v1 == 1936077360)
      return result;
    v3 = 1936077362;
    goto LABEL_108;
  }
  if (v1 != 1885745712 && v1 != 1885745714)
  {
    v3 = 1885746228;
    goto LABEL_108;
  }
  return result;
}

uint64_t CI::buffer_size_for_format(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (a3 - 1) * a4 + ((CI::format_bits_per_pixel(a1) + 7) >> 3) * a2;
}

uint64_t CI::FoslAdapter::FoslAdapter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  BOOL v11;

  v8 = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = a1 + 40;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = a1 + 64;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  do
  {
    v9 = a1 + v8;
    *(_QWORD *)(v9 + 88) = 0;
    *(_QWORD *)(v9 + 96) = 0;
    *(_QWORD *)(a1 + v8 + 80) = a1 + v8 + 88;
    v8 += 24;
  }
  while (v8 != 48);
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 128) = a1 + 136;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = a1 + 160;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = a1 + 184;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 200) = a4;
  *(_QWORD *)(a1 + 208) = a5;
  *(_QWORD *)(a1 + 216) = a6;
  *(_DWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 232) = a1 + 240;
  *(_DWORD *)(a1 + 256) = 0;
  v10 = (*(uint64_t (**)(void))(**(_QWORD **)a1 + 16))();
  v11 = 0;
  if (v10 == 76)
  {
    if (*(_BYTE *)(a3 + 136))
      v11 = 0;
    else
      v11 = *(_BYTE *)(a3 + 137) != 0;
  }
  *(_BYTE *)(a1 + 260) = v11;
  *(_QWORD *)(a1 + 24) = fosl_filter_createGraph();
  return a1;
}

uint64_t CI::FoslAdapter::getOrCreateImage(uint64_t a1, CI *this, uint64_t a3, int *a4, int a5)
{
  uint64_t **v9;
  uint64_t Image;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v15;
  unint64_t *v16;
  char __str[8];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a5 == 3)
    v9 = (uint64_t **)(a1 + 56);
  else
    v9 = (uint64_t **)(a1 + 32);
  v15 = CI::hash_image_node_id((uint64_t)this, (const CI::Node *)a4[8]);
  *(_QWORD *)__str = &v15;
  if (std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v9, &v15, (uint64_t)&std::piecewise_construct, (uint64_t **)__str)[5])
  {
    *(_QWORD *)__str = &v15;
    return std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v9, &v15, (uint64_t)&std::piecewise_construct, (uint64_t **)__str)[5];
  }
  else
  {
    CI::SerialValArray<int>::append(*(void ***)(a1 + 200), a5);
    CI::SerialObjectPtrArray::append(*(_QWORD *)(a1 + 216), (CI::Object *)a4);
    v11 = *(unsigned int *)(a1 + 20);
    *(_DWORD *)(a1 + 20) = v11 + 1;
    if (*(_BYTE *)(a1 + 260))
      v12 = snprintf(__str, 0x40uLL, "_samplers[%d]");
    else
      v12 = snprintf(__str, 0x40uLL, "_i%d");
    CI::SerialStringArray::append(*(CI::SerialStringArray **)(a1 + 208), __str, v12);
    if (a3)
      v13 = *(unsigned __int8 *)(a3 + 161);
    else
      v13 = 0;
    Image = fosl_filter_createImage(*(_QWORD *)(a1 + 24), v11, v13);
    v16 = &v15;
    std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v9, &v15, (uint64_t)&std::piecewise_construct, (uint64_t **)&v16)[5] = Image;
  }
  return Image;
}

uint64_t CI::FoslAdapter::getOrCreateFix(CI::FoslAdapter *this, IOSurfaceRef *a2)
{
  uint64_t **v4;
  uint64_t Uniform;
  uint64_t v6;
  int v7;
  unint64_t v8;
  CI::Vector *v9;
  __n64 v11;
  unint64_t v12;
  unint64_t *v13;
  char __str[8];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v12 = *((unsigned int *)a2 + 9);
  v4 = (uint64_t **)((char *)this + 128);
  *(_QWORD *)__str = &v12;
  if (std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)this + 16, &v12, (uint64_t)&std::piecewise_construct, (uint64_t **)__str)[5])
  {
    *(_QWORD *)__str = &v12;
    return std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v4, &v12, (uint64_t)&std::piecewise_construct, (uint64_t **)__str)[5];
  }
  else
  {
    v6 = *((unsigned int *)this + 4);
    *((_DWORD *)this + 4) = v6 + 1;
    CI::SerialValArray<int>::append(*((void ***)this + 25), 6);
    v7 = snprintf(__str, 0x40uLL, "_u%d", v6);
    CI::SerialStringArray::append(*((CI::SerialStringArray **)this + 26), __str, v7);
    CI::SurfaceNode::chroma_scale_fix(a2);
    v11.n64_u64[0] = v8;
    v9 = (CI::Vector *)operator new();
    CI::Vector::Vector(v9, v11, v11.n64_f32[1]);
    CI::SerialObjectPtrArray::append(*((_QWORD *)this + 27), v9);
    CI::Object::unref(v9);
    Uniform = fosl_filter_createUniform(*((_QWORD *)this + 3), v6, 1);
    v13 = &v12;
    std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v4, &v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v13)[5] = Uniform;
  }
  return Uniform;
}

uint64_t CI::FoslAdapter::getOrCreateFix(CI::FoslAdapter *this, CI::ProviderNode *a2)
{
  uint64_t **v4;
  uint64_t Uniform;
  uint64_t v6;
  int v7;
  unint64_t v8;
  CI::Vector *v9;
  __n64 v11;
  unint64_t v12;
  unint64_t *v13;
  char __str[8];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v12 = *((unsigned int *)a2 + 9);
  v4 = (uint64_t **)((char *)this + 128);
  *(_QWORD *)__str = &v12;
  if (std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)this + 16, &v12, (uint64_t)&std::piecewise_construct, (uint64_t **)__str)[5])
  {
    *(_QWORD *)__str = &v12;
    return std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v4, &v12, (uint64_t)&std::piecewise_construct, (uint64_t **)__str)[5];
  }
  else
  {
    v6 = *((unsigned int *)this + 4);
    *((_DWORD *)this + 4) = v6 + 1;
    CI::SerialValArray<int>::append(*((void ***)this + 25), 6);
    v7 = snprintf(__str, 0x40uLL, "_u%d", v6);
    CI::SerialStringArray::append(*((CI::SerialStringArray **)this + 26), __str, v7);
    CI::ProviderNode::chroma_scale_fix(a2);
    v11.n64_u64[0] = v8;
    v9 = (CI::Vector *)operator new();
    CI::Vector::Vector(v9, v11, v11.n64_f32[1]);
    CI::SerialObjectPtrArray::append(*((_QWORD *)this + 27), v9);
    CI::Object::unref(v9);
    Uniform = fosl_filter_createUniform(*((_QWORD *)this + 3), v6, 1);
    v13 = &v12;
    std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v4, &v12, (uint64_t)&std::piecewise_construct, (uint64_t **)&v13)[5] = Uniform;
  }
  return Uniform;
}

uint64_t CI::FoslAdapter::getOrCreateTransformUniform(CI::FoslAdapter *this, CI::Node *a2, CI::TextureSampler *a3)
{
  uint64_t **v5;
  uint64_t TransformMatrix;
  int v7;
  BOOL v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v13;
  unint64_t *v14;
  char __str[8];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v13 = CI::hash_image_node_id((uint64_t)a2, (const CI::Node *)*((int *)a3 + 8));
  v5 = (uint64_t **)((char *)this + 80);
  *(_QWORD *)__str = &v13;
  if (std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)this + 10, &v13, (uint64_t)&std::piecewise_construct, (uint64_t **)__str)[5])
  {
    *(_QWORD *)__str = &v13;
    return std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t **)this + 10, &v13, (uint64_t)&std::piecewise_construct, (uint64_t **)__str)[5];
  }
  else
  {
    if (*((_BYTE *)this + 260))
    {
      v7 = *((_DWORD *)this + 5);
      v8 = v7 != 0;
      v9 = v7 - 1;
      if (v8)
        v10 = v9;
      else
        v10 = 0;
    }
    else
    {
      v10 = *((unsigned int *)this + 4);
      *((_DWORD *)this + 4) = v10 + 1;
    }
    CI::SerialValArray<int>::append(*((void ***)this + 25), 40);
    if (*((_BYTE *)this + 260))
      v11 = snprintf(__str, 0x40uLL, "_transforms[%d]");
    else
      v11 = snprintf(__str, 0x40uLL, "_t%d");
    CI::SerialStringArray::append(*((CI::SerialStringArray **)this + 26), __str, v11);
    CI::SerialObjectPtrArray::append(*((_QWORD *)this + 27), a3);
    TransformMatrix = fosl_filter_createTransformMatrix(*((_QWORD *)this + 3), v10);
    v14 = &v13;
    std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v5, &v13, (uint64_t)&std::piecewise_construct, (uint64_t **)&v14)[5] = TransformMatrix;
  }
  return TransformMatrix;
}

uint64_t CI::FoslAdapter::createReadPixel(CI::FoslAdapter *this, CI::Node *a2, const CI::Kernel *a3, int a4)
{
  int v8;
  uint64_t v9;
  int v10;
  _BOOL4 v11;
  int v12;
  const char *v13;
  _BOOL4 v14;
  int v15;
  const char *v16;
  const char *v17;
  int v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  uint64_t SampleTransform;
  CI::TextureSampler *v23;
  uint64_t Image;
  uint64_t v25;
  uint64_t v26;
  uint64_t UsePosition;
  uint64_t Fix;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t TransformUniform;
  uint64_t Kernel;

  v8 = (*(uint64_t (**)(CI::Node *))(*(_QWORD *)a2 + 16))(a2);
  v9 = *(_QWORD *)a2;
  if (v8 != 46)
  {
    if ((*(unsigned int (**)(CI::Node *))(v9 + 16))(a2) != 44)
    {
      v11 = 0;
      v12 = 1;
      v10 = 1;
      goto LABEL_9;
    }
    v9 = *(_QWORD *)a2;
  }
  if ((*(int (**)(CI::Node *))(v9 + 208))(a2) < 1)
    v10 = 1;
  else
    v10 = (*(uint64_t (**)(CI::Node *))(*(_QWORD *)a2 + 208))(a2);
  v11 = (*(uint64_t (**)(CI::Node *))(*(_QWORD *)a2 + 304))(a2) == 1;
  v12 = (*(uint64_t (**)(CI::Node *))(*(_QWORD *)a2 + 408))(a2) ^ 1;
LABEL_9:
  v13 = "vec4 _read_pixel(sampler2D image, vec2 c, mat3 m){ return texture2D(image, (vec3(c, 1.0) * m).xy);}";
  if (a3)
  {
    v14 = *((_BYTE *)a3 + 161) != 0;
    if (*((_BYTE *)a3 + 161))
      v13 = "hvec4 _read_pixel(hsampler2D image, vec2 c, mat3 m){ return texture2D(image, (vec3(c, 1.0) * m).xy);}";
  }
  else
  {
    v14 = 0;
  }
  if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)this + 16))(*(_QWORD *)this) == 77)
    v15 = *(_BYTE *)(*(_QWORD *)this + 456) & 1;
  else
    v15 = 0;
  v16 = "vec4 _read_pixel_420(sampler2D Y, sampler2D cc, vec2 c, vec2 f, mat3 m){\n"
        " highp vec3 p = vec3(c, 1.0) * m;\n"
        " return vec4(texture2D(Y, p.xy).r, texture2D(cc, f*p.xy).rg, 1.0);}";
  if (v14)
    v17 = "hvec4 _read_pixel_420(hsampler2D Y, hsampler2D cc, vec2 c, vec2 f, mat3 m){\n"
          " highp vec3 p = vec3(c, 1.0) * m;\n"
          " return hvec4(texture2D(Y, p.xy).r, texture2D(cc, f*p.xy).rg, 1.0);}";
  else
    v17 = "vec4 _read_pixel_420(sampler2D Y, sampler2D cc, vec2 c, vec2 f, mat3 m){\n"
          " highp vec3 p = vec3(c, 1.0) * m;\n"
          " return vec4(texture2D(Y, p.xy).r, texture2D(cc, f*p.xy).rg, 1.0);}";
  v18 = v12 | v15;
  v19 = "vec4 _read_pixel_420_10p(sampler2D Y, sampler2D cc, vec2 c, vec2 f, mat3 m)\n"
        "  {\n"
        "     int cInt = int(c.x);\n"
        "     int cInt2 = int(c.x*0.5);\n"
        " \n"
        "     int lumaX = cInt/3;\n"
        "     highp vec3 pLuma = vec3(lumaX+0.5, c.y, 1.0) * m;\n"
        "     vec3 lumaGroup = texture2D(Y, pLuma.xy).rgb;\n"
        "     int lumaRem = cInt - lumaX*3;\n"
        "     float luma = (lumaRem==0) ? lumaGroup.z : (lumaRem==1) ? lumaGroup.y : lumaGroup.x;\n"
        " \n"
        "     int chromaX = (cInt2/3)*2;\n"
        "     highp vec3 pChromaMinus1 = vec3(2.0*(chromaX - 0.5), c.y, 1.0) * m;\n"
        "     highp vec3 pChroma1 = vec3(2.0*(chromaX + 0.5), c.y, 1.0) * m;\n"
        "     highp vec3 pChroma2 = vec3(2.0*(chromaX + 1.5), c.y, 1.0) * m;\n"
        "     highp vec3 pChroma3 = vec3(2.0*(chromaX + 2.5), c.y, 1.0) * m;\n"
        "     vec3 ccGroupMinus1 = texture2D(cc, pChromaMinus1.xy * f).rgb;\n"
        "     vec3 ccGroup1 = texture2D(cc, pChroma1.xy * f).rgb;\n"
        "     vec3 ccGroup2 = texture2D(cc, pChroma2.xy * f).rgb;\n"
        "     vec3 ccGroup3 = texture2D(cc, pChroma3.xy * f).rgb;\n"
        "     vec2 ccMinus1 = ccGroupMinus1.yx; \n"
        "     vec2 cc1 = ccGroup1.zy; \n"
        "     vec2 cc2 = vec2(ccGroup1.x, ccGroup2.z); \n"
        "     vec2 cc3 = ccGroup2.yx; \n"
        "     vec2 cc4 = ccGroup3.zy; \n"
        "     float mixer = (cInt & 1)*0.5; \n"
        "     int chromaRem = cInt - (cInt/6)*6;\n"
        "     vec2 chroma = vec2(0);\n"
        "     if (chromaRem == 0) {\n"
        "         chroma = mix(ccMinus1, cc1, 0.75);\n"
        "     } else if (chromaRem == 1) { \n"
        "         chroma = mix(cc1, cc2, 0.25);\n"
        "     } else if (chromaRem == 2) { \n"
        "         chroma = mix(cc1, cc2, 0.75);\n"
        "     } else if (chromaRem == 3) { \n"
        "         chroma = mix(cc2, cc3, 0.25);\n"
        "     } else if (chromaRem == 4) { \n"
        "         chroma = mix(cc2, cc3, 0.75);\n"
        "     } else if (chromaRem == 5) { \n"
        "         chroma = mix(cc3, cc4, 0.25);\n"
        "     }\n"
        "     return vec4(luma, chroma.xy, 1.0); \n"
        " }";
  if (v14)
  {
    v19 = "hvec4 _read_pixel_420_10p(hsampler2D Y, hsampler2D cc, vec2 c, vec2 f, mat3 m)  {\n"
          "     int cInt = int(c.x);\n"
          "     int cInt2 = int(c.x*0.5);\n"
          " \n"
          "     int lumaX = cInt/3;\n"
          "     highp vec3 pLuma = vec3(lumaX+0.5, c.y, 1.0) * m;\n"
          "     hvec3 lumaGroup = texture2D(Y, pLuma.xy).rgb;\n"
          "     int lumaRem = cInt - lumaX*3;\n"
          "     float luma = (lumaRem==0) ? lumaGroup.z : (lumaRem==1) ? lumaGroup.y : lumaGroup.x;\n"
          " \n"
          "     int chromaX = (cInt2/3)*2;\n"
          "     highp vec3 pChromaMinus1 = vec3(2.0*(chromaX - 0.5), c.y, 1.0) * m;\n"
          "     highp vec3 pChroma1 = vec3(2.0*(chromaX + 0.5), c.y, 1.0) * m;\n"
          "     highp vec3 pChroma2 = vec3(2.0*(chromaX + 1.5), c.y, 1.0) * m;\n"
          "     highp vec3 pChroma3 = vec3(2.0*(chromaX + 2.5), c.y, 1.0) * m;\n"
          "     hvec3 ccGroupMinus1 = texture2D(cc, pChromaMinus1.xy * f).rgb;\n"
          "     hvec3 ccGroup1 = texture2D(cc, pChroma1.xy * f).rgb;\n"
          "     hvec3 ccGroup2 = texture2D(cc, pChroma2.xy * f).rgb;\n"
          "     hvec3 ccGroup3 = texture2D(cc, pChroma3.xy * f).rgb;\n"
          "     hvec2 ccMinus1 = ccGroupMinus1.yx; \n"
          "     hvec2 cc1 = ccGroup1.zy; \n"
          "     hvec2 cc2 = hvec2(ccGroup1.x, ccGroup2.z); \n"
          "     hvec2 cc3 = ccGroup2.yx; \n"
          "     hvec2 cc4 = ccGroup3.zy; \n"
          "     float mixer = (cInt & 1)*0.5; \n"
          "     int chromaRem = cInt - (cInt/6)*6;\n"
          "     hvec2 chroma = vec2(0);\n"
          "     if (chromaRem == 0) {\n"
          "         chroma = mix(ccMinus1, cc1, 0.75);\n"
          "     } else if (chromaRem == 1) { \n"
          "         chroma = mix(cc1, cc2, 0.25);\n"
          "     } else if (chromaRem == 2) { \n"
          "         chroma = mix(cc1, cc2, 0.75);\n"
          "     } else if (chromaRem == 3) { \n"
          "         chroma = mix(cc2, cc3, 0.25);\n"
          "     } else if (chromaRem == 4) { \n"
          "         chroma = mix(cc2, cc3, 0.75);\n"
          "     } else if (chromaRem == 5) { \n"
          "         chroma = mix(cc3, cc4, 0.25);\n"
          "     }\n"
          "     return hvec4(luma, chroma.xy, 1.0); \n"
          " }";
    v16 = "hvec4 _read_pixel_420(hsampler2D Y, hsampler2D cc, vec2 c, vec2 f, mat3 m){\n"
          " highp vec3 p = vec3(c, 1.0) * m;\n"
          " return hvec4(texture2D(Y, p.xy).r, texture2D(cc, f*p.xy).rg, 1.0);}";
  }
  if (v18 == 1)
    v20 = v16;
  else
    v20 = v19;
  if (!v11)
    v20 = v17;
  if (v10 == 2)
    v21 = (uint64_t)v20;
  else
    v21 = (uint64_t)v13;
  SampleTransform = fosl_filter_createSampleTransform(*((_QWORD *)this + 3), v21);
  v23 = (CI::TextureSampler *)operator new();
  CI::TextureSampler::TextureSampler(v23, a2, a4);
  Image = CI::FoslAdapter::getOrCreateImage((uint64_t)this, a2, (uint64_t)a3, (int *)v23, 2);
  fosl_filter_addChild(*((_QWORD *)this + 3), SampleTransform, Image);
  if (v10 == 2)
  {
    v25 = CI::FoslAdapter::getOrCreateImage((uint64_t)this, a2, (uint64_t)a3, (int *)v23, 3);
    fosl_filter_addChild(*((_QWORD *)this + 3), SampleTransform, v25);
    v26 = *((_QWORD *)this + 3);
    UsePosition = fosl_filter_createUsePosition(v26);
    fosl_filter_addChild(v26, SampleTransform, UsePosition);
    if ((*(unsigned int (**)(CI::Node *))(*(_QWORD *)a2 + 16))(a2) == 46)
      Fix = CI::FoslAdapter::getOrCreateFix(this, (IOSurfaceRef *)a2);
    else
      Fix = CI::FoslAdapter::getOrCreateFix(this, a2);
    v30 = Fix;
    v31 = *((_QWORD *)this + 3);
  }
  else
  {
    v29 = *((_QWORD *)this + 3);
    v30 = fosl_filter_createUsePosition(v29);
    v31 = v29;
  }
  fosl_filter_addChild(v31, SampleTransform, v30);
  TransformUniform = CI::FoslAdapter::getOrCreateTransformUniform(this, a2, v23);
  fosl_filter_addChild(*((_QWORD *)this + 3), SampleTransform, TransformUniform);
  CI::Object::unref(v23);
  if ((*(unsigned int (**)(CI::Node *))(*(_QWORD *)a2 + 16))(a2) == 52 && (*((_BYTE *)a2 + 144) & 1) != 0)
  {
    Kernel = fosl_filter_createKernel(*((_QWORD *)this + 3), (uint64_t)"vec4 _ci_srgb_to_linear (vec4 s) { return _srgb_to_linear(s); }");
    fosl_filter_addChild(*((_QWORD *)this + 3), Kernel, SampleTransform);
    return Kernel;
  }
  return SampleTransform;
}

uint64_t CI::FoslAdapter::createReadTable(CI::FoslAdapter *this, CI::Node *a2, const CI::Kernel *a3, char *a4, int a5, char a6)
{
  int IndexOfString;
  CI::TextureSampler *v10;
  uint64_t Image;

  a4[a5] = a6 + 48;
  a4[a5 + 1] = 0;
  IndexOfString = CI::SerialStringArray::firstIndexOfString(*(CI::SerialStringArray **)(*((_QWORD *)this + 1) + 56), a4 + 1);
  v10 = (CI::TextureSampler *)operator new();
  CI::TextureSampler::TextureSampler(v10, a2, IndexOfString);
  Image = CI::FoslAdapter::getOrCreateImage((uint64_t)this, a2, (uint64_t)a3, (int *)v10, 4);
  CI::Object::unref(v10);
  return Image;
}

uint64_t CI::FoslAdapter::createGeneralKernel(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v10;
  uint64_t Kernel;
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int type;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  double **v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  double *v25;
  size_t v26;
  unint64_t v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  int v40;
  uint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  char v45;
  uint64_t Uniform;
  uint64_t v47;
  CI::Object **v48;
  int v49;
  CGRect *v50;
  CI::Object *v51;
  double v52;
  CI::Vector *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t Sampler;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  const char *v66;
  unsigned int v68;
  uint64_t **v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  uint64_t v76;
  unsigned __int8 v77;
  double v78;
  double v79;
  double v80;
  double v81;
  double v82;
  double v83;
  _BYTE v84[44];
  char __str[64];
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  v10 = a2[6];
  Kernel = fosl_filter_createKernel(a1[3], *(_QWORD *)(v10 + 32));
  if (*(_BYTE *)(v10 + 12))
    v12 = CI::KernelArguments::count((CI::KernelArguments *)(v10 + 144));
  else
    v12 = *(_DWORD *)(v10 + 20);
  v73 = Kernel;
  if (v12)
  {
    v13 = 0;
    v14 = 0;
    v69 = (uint64_t **)(a1 + 29);
    v70 = a5;
    v75 = a5 + 1;
    v15 = v12;
    v74 = v12;
    v71 = a3;
    v72 = a4;
    v76 = v10;
    while (1)
    {
      v16 = a2[6];
      if (*(_BYTE *)(v16 + 12))
      {
        type = CI::KernelArguments::get_type((CI::KernelArguments *)(v16 + 144), v13);
      }
      else
      {
        if ((uint64_t)v13 >= *(int *)(v16 + 20))
        {
          type = 0;
          goto LABEL_19;
        }
        type = *(_DWORD *)(*(_QWORD *)(v16 + 72) + 4 * v13);
      }
      if (type == 1)
      {
        v18 = a2[7];
        if (v13 > 9)
          v19 = (_QWORD *)(*(_QWORD *)(v18 + 16) + 8 * (v13 - 10));
        else
          v19 = (_QWORD *)(v18 + 8 * v13 + 24);
        v22 = CI::FoslAdapter::convertTree(a1, *v19, v10, a3, a4, v75, v14);
        fosl_filter_addChild(a1[3], Kernel, v22);
        v14 = (v14 + 1);
        goto LABEL_57;
      }
      if ((type & 0xFFFFFFFE) == 2)
      {
        v79 = 0.0;
        v80 = 0.0;
        v78 = 1.0;
        v81 = 1.0;
        v82 = 0.0;
        v83 = 0.0;
        v20 = a2[7];
        if (v13 > 9)
          v21 = (double **)(*(_QWORD *)(v20 + 16) + 8 * (v13 - 10));
        else
          v21 = (double **)(v20 + 8 * v13 + 24);
        v25 = *v21;
        v26 = CI::ProgramNode::child_depth((CI::ProgramNode *)a1[1], v14);
        if (v26 - 1 > v70)
        {
          v27 = ~v70 + v26;
          do
          {
            if ((*(unsigned int (**)(double *))(*(_QWORD *)v25 + 16))(v25) == 28)
            {
              v28 = v25[7];
              v29 = v25[8];
              v30 = v29 * v80 + v28 * v78;
              v31 = v29 * v81 + v28 * v79;
              v32 = v25[9];
              v33 = v25[10];
              v34 = v80 * v33 + v32 * v78;
              v35 = v81 * v33 + v32 * v79;
              v36 = v25[11];
              v37 = v25[12];
              v38 = v82 + v80 * v37 + v36 * v78;
              v39 = v81 * v37 + v36 * v79 + v83;
              v78 = v30;
              v79 = v31;
              v80 = v34;
              v81 = v35;
              v82 = v38;
              v83 = v39;
            }
            else
            {
              v40 = (*(uint64_t (**)(double *))(*(_QWORD *)v25 + 16))(v25);
              v41 = *(_QWORD *)v25;
              if (v40 == 45)
              {
                (*(void (**)(double *))(v41 + 408))(v25);
              }
              else if ((*(unsigned int (**)(double *))(v41 + 16))(v25) != 30
                     && (*(unsigned int (**)(double *))(*(_QWORD *)v25 + 16))(v25) == 47)
              {
                v42 = *((_DWORD *)a1 + 56);
                v43 = (*(uint64_t (**)(double *))(*(_QWORD *)v25 + 408))(v25);
                if (!v42)
                  *((_DWORD *)a1 + 56) = v43;
              }
            }
            v25 = (double *)(*(uint64_t (**)(double *, _QWORD))(*(_QWORD *)v25 + 48))(v25, 0);
            --v27;
          }
          while (v27);
        }
        v44 = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[1] + 48))(a1[1], v14);
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v44 + 16))(v44) == 52)
        {
          v77 = 0;
          v45 = *(_BYTE *)(v44 + 144);
          if ((v45 & 1) != 0)
          {
            v68 = *(_DWORD *)(v44 + 140);
            *(_QWORD *)v84 = *(_QWORD *)(v44 + 145);
            *(_DWORD *)&v84[7] = *(_DWORD *)(v44 + 152);
            if (CI_INTERMEDIATE_SRGB_TEXTURES()
              && (*(unsigned int (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)*a1 + 584))(*a1, v68, 1))
            {
              *(_DWORD *)(v44 + 140) = v68;
              *(_BYTE *)(v44 + 144) = v45 | 4;
              *(_QWORD *)(v44 + 145) = *(_QWORD *)v84;
              *(_DWORD *)(v44 + 152) = *(_DWORD *)&v84[7];
            }
            else
            {
              v77 = 1;
            }
          }
          std::__tree<BOOL>::__emplace_unique_key_args<BOOL,BOOL const&>(v69, &v77, &v77);
        }
        else
        {
          v84[0] = 0;
          std::__tree<BOOL>::__emplace_unique_key_args<BOOL,BOOL const&>(v69, v84, v84);
        }
        v50 = (CGRect *)(a2[8] + 32 * (int)v14);
        v51 = (CI::Object *)operator new();
        v52 = CI::Affine::inverse((CI::Affine *)&v78, (double *)v84);
        CI::TextureSampler::TextureSampler(v51, v44, v52);
        v53 = (CI::Vector *)operator new();
        CI::Vector::Vector(v53, *v50);
        v54 = *(unsigned __int8 *)(v76 + 161);
        v55 = *((unsigned int *)a1 + 5);
        *((_DWORD *)a1 + 5) = v55 + 1;
        Sampler = fosl_filter_createSampler(a1[3], v55, v54);
        Kernel = v73;
        fosl_filter_addChild(a1[3], v73, Sampler);
        v57 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a1 + 16))(*a1);
        if (v57 == 74)
        {
          CI::SerialValArray<int>::append((void **)a1[25], type);
          CI::SerialObjectPtrArray::append(a1[27], v51);
          v61 = snprintf(__str, 0x40uLL, "_s%d", v55);
          CI::SerialStringArray::append((CI::SerialStringArray *)a1[26], __str, v61);
          CI::SerialValArray<int>::append((void **)a1[25], 42);
          CI::SerialObjectPtrArray::append(a1[27], v51);
          v62 = snprintf(__str, 0x40uLL, "_s%d_transform0", v55);
          CI::SerialStringArray::append((CI::SerialStringArray *)a1[26], __str, v62);
          CI::SerialValArray<int>::append((void **)a1[25], 43);
          CI::SerialObjectPtrArray::append(a1[27], v51);
          v63 = snprintf(__str, 0x40uLL, "_s%d_transform1", v55);
          CI::SerialStringArray::append((CI::SerialStringArray *)a1[26], __str, v63);
          CI::SerialValArray<int>::append((void **)a1[25], 8);
          CI::SerialObjectPtrArray::append(a1[27], v53);
          v60 = snprintf(__str, 0x40uLL, "_s%d_extent");
        }
        else
        {
          if (v57 != 76)
          {
            a3 = v71;
            a4 = v72;
            if (v57 == 77)
            {
              CI::SerialValArray<int>::append((void **)a1[25], type);
              CI::SerialObjectPtrArray::append(a1[27], v51);
              CI::SerialValArray<int>::append((void **)a1[25], 41);
              CI::SerialObjectPtrArray::append(a1[27], v51);
            }
LABEL_55:
            CI::Object::unref(v51);
            CI::Object::unref(v53);
            v14 = (v14 + 1);
            v10 = v76;
LABEL_56:
            v15 = v74;
            goto LABEL_57;
          }
          CI::SerialValArray<int>::append((void **)a1[25], 2);
          CI::SerialObjectPtrArray::append(a1[27], v51);
          v58 = snprintf(__str, 0x40uLL, "_samplers[%d]", v55);
          CI::SerialStringArray::append((CI::SerialStringArray *)a1[26], __str, v58);
          CI::SerialValArray<int>::append((void **)a1[25], 40);
          CI::SerialObjectPtrArray::append(a1[27], v51);
          v59 = snprintf(__str, 0x40uLL, "_transforms[%d]", v55);
          CI::SerialStringArray::append((CI::SerialStringArray *)a1[26], __str, v59);
          CI::SerialValArray<int>::append((void **)a1[25], 8);
          CI::SerialObjectPtrArray::append(a1[27], v53);
          v60 = snprintf(__str, 0x40uLL, "_extents[%d]");
        }
        CI::SerialStringArray::append((CI::SerialStringArray *)a1[26], __str, v60);
        a3 = v71;
        a4 = v72;
        goto LABEL_55;
      }
LABEL_19:
      if (CI::KernelArguments::is_uniform(type))
      {
        v23 = *((unsigned int *)a1 + 4);
        *((_DWORD *)a1 + 4) = v23 + 1;
        if ((type - 5) > 0x16)
          v24 = 0;
        else
          v24 = dword_19249B990[type - 5];
        Uniform = fosl_filter_createUniform(a1[3], v23, v24);
        fosl_filter_addChild(a1[3], Kernel, Uniform);
        CI::SerialValArray<int>::append((void **)a1[25], type);
        v47 = a2[7];
        if (v13 > 9)
          v48 = (CI::Object **)(*(_QWORD *)(v47 + 16) + 8 * (v13 - 10));
        else
          v48 = (CI::Object **)(v47 + 8 * v13 + 24);
        CI::SerialObjectPtrArray::append(a1[27], *v48);
        if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)*a1 + 16))(*a1) != 77)
        {
          v49 = snprintf(__str, 0x40uLL, "_u%d", v23);
          CI::SerialStringArray::append((CI::SerialStringArray *)a1[26], __str, v49);
        }
        goto LABEL_56;
      }
LABEL_57:
      if (++v13 == v15)
        goto LABEL_60;
    }
  }
  LODWORD(v14) = 0;
LABEL_60:
  if (a1[31] > 1uLL)
  {
    std::__tree<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::DAGHelper::ImageArgInfo>>>::destroy((uint64_t)(a1 + 29), (_QWORD *)a1[30]);
    a1[29] = a1 + 30;
    a1[30] = 0;
    a1[31] = 0;
    if ((int)v14 >= 1)
    {
      v64 = 0;
      do
      {
        v65 = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)a1[1] + 48))(a1[1], v64);
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v65 + 16))(v65) == 52
          && (*(_BYTE *)(v65 + 144) & 5) == 1)
        {
          v66 = CI::name_for_format(*(_DWORD *)(v65 + 140));
          x_log("Cannot use sRGB texture binding with format %s for sampler %d in kernel '%s'.\n", v66, v64, *(const char **)(a2[6] + 24));
        }
        v64 = (v64 + 1);
      }
      while ((_DWORD)v14 != (_DWORD)v64);
    }
  }
  return v73;
}

uint64_t CI::FoslAdapter::convertTree(uint64_t **a1, CI::Node *a2, const CI::Kernel *a3, uint64_t a4, uint64_t a5, unsigned int a6, char a7)
{
  uint64_t IndexOfString;
  uint64_t *v14;
  uint64_t **v15;
  uint64_t **v16;
  uint64_t Pixel;
  uint64_t v18;
  uint64_t *v20;
  uint64_t GeneralKernel;
  uint64_t Cast;
  uint64_t v23;
  uint64_t *v24;
  uint64_t **v25;
  uint64_t WarpKernel;
  uint64_t *v27;
  uint64_t *v28[2];
  unint64_t *v29;

  *(_BYTE *)(a5 + a6) = a7 + 48;
  *(_BYTE *)(a5 + a6 + 1) = 0;
  IndexOfString = CI::SerialStringArray::firstIndexOfString((CI::SerialStringArray *)a1[1][7], (const char *)(a5 + 1));
  if ((_DWORD)IndexOfString != -1)
    a2 = (CI::Node *)(*(uint64_t (**)(uint64_t *, uint64_t))(*a1[1] + 48))(a1[1], IndexOfString);
  v14 = (uint64_t *)CI::hash_dag_node_id((unint64_t)a2, a4, (char *)a5);
  v15 = a1 + 19;
  v29 = (unint64_t *)v14;
  v28[0] = (uint64_t *)&v29;
  if (!std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(a1 + 19, (unint64_t *)&v29, (uint64_t)&std::piecewise_construct, v28)[5])
  {
    if ((_DWORD)IndexOfString != -1)
    {
      Pixel = CI::FoslAdapter::createReadPixel((CI::FoslAdapter *)a1, a2, a3, IndexOfString);
      v29 = (unint64_t *)v14;
      v28[0] = (uint64_t *)&v29;
      std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v15, (unint64_t *)&v29, (uint64_t)&std::piecewise_construct, v28)[5] = Pixel;
      v29 = (unint64_t *)v14;
      v28[0] = (uint64_t *)&v29;
      v16 = v15;
      return std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v16, (unint64_t *)&v29, (uint64_t)&std::piecewise_construct, v28)[5];
    }
    v28[0] = (uint64_t *)a2;
    if (a2)
      CI::Object::ref((uint64_t)a2);
    v20 = (uint64_t *)(*(uint64_t (**)(CI::Node *, uint64_t *))(*(_QWORD *)a2 + 320))(a2, *a1);
    v28[1] = v20;
    if (v20)
      a2 = (CI::Node *)v20;
    if ((*(unsigned int (**)(CI::Node *))(*(_QWORD *)a2 + 16))(a2) == 51)
    {
      GeneralKernel = CI::FoslAdapter::createGeneralKernel(a1, a2, a4, a5, a6);
    }
    else
    {
      if ((*(unsigned int (**)(CI::Node *))(*(_QWORD *)a2 + 16))(a2) != 49)
      {
        if ((*(unsigned int (**)(CI::Node *))(*(_QWORD *)a2 + 16))(a2) != 50)
        {
          x_log("Invalid DAG node type");
          v18 = 0;
          goto LABEL_24;
        }
        WarpKernel = CI::FoslAdapter::createWarpKernel((uint64_t)a1, a2, (uint64_t)a3, a4, (char *)a5, a6);
        v27 = v14;
        v29 = (unint64_t *)&v27;
        std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v15, (unint64_t *)&v27, (uint64_t)&std::piecewise_construct, (uint64_t **)&v29)[5] = WarpKernel;
        v27 = v14;
        v29 = (unint64_t *)&v27;
        v25 = v15;
        goto LABEL_22;
      }
      GeneralKernel = CI::FoslAdapter::createColorKernel((uint64_t)a1, a2, a4, (char *)a5, a6);
    }
    v27 = v14;
    v29 = (unint64_t *)&v27;
    std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(a1 + 19, (unint64_t *)&v27, (uint64_t)&std::piecewise_construct, (uint64_t **)&v29)[5] = GeneralKernel;
    Cast = CI::FoslAdapter::createCast((CI::FoslAdapter *)a1, a2, a3);
    if (Cast)
    {
      v18 = Cast;
      v23 = (uint64_t)a1[3];
      v27 = v14;
      v29 = (unint64_t *)&v27;
      v24 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v15, (unint64_t *)&v27, (uint64_t)&std::piecewise_construct, (uint64_t **)&v29);
      fosl_filter_addChild(v23, v18, v24[5]);
LABEL_24:
      CI::ConvertedNodeRAII::~ConvertedNodeRAII((CI::ConvertedNodeRAII *)v28);
      return v18;
    }
    v27 = v14;
    v29 = (unint64_t *)&v27;
    v25 = a1 + 19;
LABEL_22:
    v18 = std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v25, (unint64_t *)&v27, (uint64_t)&std::piecewise_construct, (uint64_t **)&v29)[5];
    goto LABEL_24;
  }
  v29 = (unint64_t *)v14;
  v28[0] = (uint64_t *)&v29;
  v16 = a1 + 19;
  return std::__tree<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,CI::ColorKernelOutputIdx>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v16, (unint64_t *)&v29, (uint64_t)&std::piecewise_construct, v28)[5];
}

uint64_t CI::FoslAdapter::createColorKernel(uint64_t a1, CI::ColorKernelNode *a2, uint64_t a3, char *a4, int a5)
{
  uint64_t v10;
  uint64_t Kernel;
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  CI::Node *argument;
  uint64_t Table;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  CI::Object *v23;
  int v24;
  uint64_t v25;
  uint64_t Uniform;
  unsigned int v28;
  uint64_t v29;
  CI::Kernel *v30;
  char __str[64];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v10 = *((_QWORD *)a2 + 6);
  Kernel = fosl_filter_createKernel(*(_QWORD *)(a1 + 24), *(_QWORD *)(v10 + 32));
  v30 = (CI::Kernel *)v10;
  if (*(_BYTE *)(v10 + 12))
  {
    v12 = CI::KernelArguments::count((CI::KernelArguments *)(v10 + 144));
    if (!v12)
      return Kernel;
  }
  else
  {
    v12 = *(_DWORD *)(v10 + 20);
    if (!v12)
      return Kernel;
  }
  v13 = 0;
  v14 = 0;
  v15 = (a5 + 1);
  v29 = a3;
  v28 = v15;
  do
  {
    v16 = CI::ColorKernelNode::kernel_argument_type(a2, v13);
    v17 = v16;
    if (v16 == 4 || v16 == 1)
    {
      argument = (CI::Node *)CI::ColorKernelNode::get_argument(a2, v13);
      if (v17 == 4)
        Table = CI::FoslAdapter::createReadTable((CI::FoslAdapter *)a1, argument, v30, a4, v15, v14);
      else
        Table = CI::FoslAdapter::convertTree(a1, argument, v30, a3, a4, v15, v14);
      fosl_filter_addChild(*(_QWORD *)(a1 + 24), Kernel, Table);
      v14 = (v14 + 1);
    }
    else if (CI::KernelArguments::is_uniform(v16))
    {
      v20 = a4;
      v21 = *(unsigned int *)(a1 + 16);
      *(_DWORD *)(a1 + 16) = v21 + 1;
      CI::SerialValArray<int>::append(*(void ***)(a1 + 200), v17);
      v22 = *(_QWORD *)(a1 + 216);
      v23 = (CI::Object *)CI::ColorKernelNode::get_argument(a2, v13);
      CI::SerialObjectPtrArray::append(v22, v23);
      v24 = snprintf(__str, 0x40uLL, "_u%d", v21);
      CI::SerialStringArray::append(*(CI::SerialStringArray **)(a1 + 208), __str, v24);
      if ((v17 - 5) > 0x16)
        v25 = 0;
      else
        v25 = dword_19249B990[v17 - 5];
      a4 = v20;
      Uniform = fosl_filter_createUniform(*(_QWORD *)(a1 + 24), v21, v25);
      fosl_filter_addChild(*(_QWORD *)(a1 + 24), Kernel, Uniform);
      a3 = v29;
      v15 = v28;
    }
    ++v13;
  }
  while (v12 != v13);
  return Kernel;
}

uint64_t CI::FoslAdapter::createWarpKernel(uint64_t a1, CI::ColorKernelNode *a2, uint64_t a3, uint64_t a4, char *a5, int a6)
{
  uint64_t CoordinateTransform;
  uint64_t v9;
  int v10;
  unsigned int i;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t Uniform;
  uint64_t v16;
  CI::Object *argument;
  int v18;
  uint64_t v19;
  uint64_t PositionUpdate;
  unint64_t v21;
  uint64_t v22;
  char __str[64];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  CoordinateTransform = fosl_filter_createCoordinateTransform(*(_QWORD *)(a1 + 24), *(_QWORD *)(*((_QWORD *)a2 + 6) + 32));
  v9 = *((_QWORD *)a2 + 6);
  if (*(_BYTE *)(v9 + 12))
  {
    v10 = CI::KernelArguments::count((CI::KernelArguments *)(v9 + 144));
    if (!v10)
      goto LABEL_12;
  }
  else
  {
    v10 = *(_DWORD *)(v9 + 20);
    if (!v10)
      goto LABEL_12;
  }
  for (i = 0; i != v10; ++i)
  {
    v12 = CI::ColorKernelNode::kernel_argument_type(a2, i);
    if (CI::KernelArguments::is_uniform(v12))
    {
      v13 = *(unsigned int *)(a1 + 16);
      *(_DWORD *)(a1 + 16) = v13 + 1;
      if ((v12 - 5) > 0x16)
        v14 = 0;
      else
        v14 = dword_19249B990[v12 - 5];
      Uniform = fosl_filter_createUniform(*(_QWORD *)(a1 + 24), v13, v14);
      CI::SerialValArray<int>::append(*(void ***)(a1 + 200), v12);
      v16 = *(_QWORD *)(a1 + 216);
      argument = (CI::Object *)CI::ColorKernelNode::get_argument(a2, i);
      CI::SerialObjectPtrArray::append(v16, argument);
      v18 = snprintf(__str, 0x40uLL, "_u%d", v13);
      CI::SerialStringArray::append(*(CI::SerialStringArray **)(a1 + 208), __str, v18);
      fosl_filter_addChild(*(_QWORD *)(a1 + 24), CoordinateTransform, Uniform);
    }
  }
LABEL_12:
  v19 = (*(uint64_t (**)(CI::ColorKernelNode *, _QWORD))(*(_QWORD *)a2 + 48))(a2, 0);
  PositionUpdate = fosl_filter_createPositionUpdate(*(_QWORD *)(a1 + 24));
  fosl_filter_setPositionUpdatePosition(PositionUpdate, CoordinateTransform);
  v21 = CI::hash_dag_node_id((unint64_t)a2, a4, a5);
  v22 = CI::FoslAdapter::convertTree(a1, v19, a3, v21, a5, (a6 + 1), 0);
  fosl_filter_setPositionUpdateContinuation(PositionUpdate, v22);
  return PositionUpdate;
}

uint64_t CI::FoslAdapter::createCast(CI::FoslAdapter *this, CI::Node *a2, const CI::Kernel *a3)
{
  uint64_t v6;
  int v7;
  const char *v8;

  if (a3)
  {
    if ((*(unsigned int (**)(CI::Node *))(*(_QWORD *)a2 + 16))(a2) == 49)
      v6 = *((_QWORD *)a2 + 6);
    else
      v6 = 0;
    if ((*(unsigned int (**)(CI::Node *))(*(_QWORD *)a2 + 16))(a2) == 51)
      v6 = *((_QWORD *)a2 + 6);
    v7 = *(_DWORD *)(v6 + 16);
    if (*((_BYTE *)a3 + 161))
    {
      if (v7 != 3)
      {
        v8 = "hvec4 _cast_vec4_to_hvec4(vec4 v) { return hvec4(v); }";
        return fosl_filter_createKernel(*((_QWORD *)this + 3), (uint64_t)v8);
      }
    }
    else if (v7 == 3)
    {
      v8 = "vec4 _cast_hvec4_to_vec4(hvec4 v) { return vec4(v); }";
      return fosl_filter_createKernel(*((_QWORD *)this + 3), (uint64_t)v8);
    }
  }
  return 0;
}

uint64_t CI::FoslAdapter::convertTree(CI::FoslAdapter *this, CI::Node *a2, char *a3, unsigned int a4, int a5)
{
  uint64_t v6;
  uint64_t Kernel;

  *((_DWORD *)this + 64) = a5;
  v6 = CI::FoslAdapter::convertTree((uint64_t **)this, a2, 0, 0, (uint64_t)a3, a4, 0);
  if ((*(_BYTE *)(*((_QWORD *)this + 1) + 144) & 1) != 0)
  {
    Kernel = fosl_filter_createKernel(*((_QWORD *)this + 3), (uint64_t)"vec4 _ci_linear_to_srgb (vec4 s) { return _linear_to_srgb(s); }");
    fosl_filter_addChild(*((_QWORD *)this + 3), Kernel, v6);
    return Kernel;
  }
  return v6;
}

void CI::FoslAdapter::addLibraryFunctions(CI::FoslAdapter *this, const char *a2)
{
  fosl_filter_addLibraryFunction(*((_QWORD *)this + 3), (uint64_t)a2);
}

uint64_t CI::FoslAdapter::constructShader(CI::FoslAdapter *this, const char *a2, uint64_t a3)
{
  _xlocale *v5;
  _xlocale *v6;
  uint64_t v7;
  CI::FoslAdapter *v8;
  uint64_t *v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t StringForGraph;
  _xlocale *v17;

  fosl_filter_assignRoot(*((_QWORD *)this + 3), a3);
  v5 = newlocale(16, 0, 0);
  v6 = uselocale(v5);
  fosl_filter_parseNodesInGraph(*((_QWORD *)this + 3));
  if (FOSL_DUMP_GRAPH())
    fosl_filter_dumpGraph(*((_QWORD *)this + 3));
  v7 = *((_QWORD *)this + 30);
  if (v7)
  {
    v8 = (CI::FoslAdapter *)((char *)this + 240);
    do
    {
      if (*(_BYTE *)(v7 + 25))
        v9 = (uint64_t *)v7;
      else
        v9 = (uint64_t *)(v7 + 8);
      if (*(_BYTE *)(v7 + 25))
        v8 = (CI::FoslAdapter *)v7;
      v7 = *v9;
    }
    while (*v9);
    if (v8 != (CI::FoslAdapter *)((char *)this + 240))
      fosl_filter_setSamplerNeedsSRGBToLinear(*((_QWORD *)this + 3));
  }
  v10 = *((_DWORD *)this + 56);
  if ((v10 - 1) <= 0x19)
  {
    fosl_filter_setSamplerSwizzleMask(*((_QWORD *)this + 3), (uint64_t)off_1E2EC6F68[v10 - 1]);
    v10 = *((_DWORD *)this + 56);
  }
  v11 = v10 - 27;
  if (v11 <= 9)
    fosl_filter_setSamplerSwizzleMacro(*((_QWORD *)this + 3), (uint64_t)off_1E2EC7038[v11]);
  fosl_filter_setMainEntryPointName(*((_QWORD *)this + 3), (uint64_t)a2);
  v12 = *((_QWORD *)this + 3);
  v13 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 16))(*(_QWORD *)this);
  switch(v13)
  {
    case 'M':
      v14 = v12;
      v15 = 2;
      goto LABEL_23;
    case 'L':
      v14 = v12;
      v15 = 0;
      goto LABEL_23;
    case 'J':
      v14 = v12;
      v15 = 1;
LABEL_23:
      fosl_filter_synthesizeMainInGraphOfType(v14, v15);
      goto LABEL_25;
  }
  fosl_filter_synthesizeMainInGraph(v12);
LABEL_25:
  if (FOSL_PRINT_GRAPH())
    fosl_filter_printGraph(*((_QWORD *)this + 3));
  StringForGraph = fosl_filter_getStringForGraph(*((_QWORD *)this + 3));
  v17 = uselocale(v6);
  freelocale(v17);
  return StringForGraph;
}

uint64_t **std::__tree<BOOL>::__emplace_unique_key_args<BOOL,BOOL const&>(uint64_t **a1, unsigned __int8 *a2, _BYTE *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unsigned int v7;
  uint64_t **v8;
  unsigned int v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((unsigned __int8 *)v5 + 25);
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x20uLL);
    *((_BYTE *)v10 + 25) = *a3;
    std::__tree<std::__value_type<std::string,CI::SWFunction>,std::__map_value_compare<std::string,std::__value_type<std::string,CI::SWFunction>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CI::SWFunction>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t (*fosl_filter_interface_version())(void)
{
  uint64_t (*result)(void);

  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  result = *(uint64_t (**)(void))foslFuncs;
  if (*(_QWORD *)foslFuncs)
    return (uint64_t (*)(void))result();
  return result;
}

uint64_t fosl_filter_kernelpool_getDiagnosticByIdx(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t, uint64_t))(foslFuncs + 80))(a1, a2);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_getAttributeKeyword(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t, uint64_t))(foslFuncs + 176))(a1, a2);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_getAttributeParameters(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t, uint64_t))(foslFuncs + 184))(a1, a2);
  else
    return 0;
}

uint64_t fosl_filter_kernelpool_hasAttributeParameters(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t, uint64_t))(foslFuncs + 192))(a1, a2);
  else
    return 0;
}

uint64_t fosl_filter_createGraph()
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(void))(foslFuncs + 200))();
  else
    return 0;
}

void fosl_filter_assignRoot(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t, uint64_t))(foslFuncs + 208))(a1, a2);
}

void fosl_filter_destroyGraph(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t))(foslFuncs + 216))(a1);
}

uint64_t fosl_filter_createKernel(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t, uint64_t))(foslFuncs + 224))(a1, a2);
  else
    return 0;
}

void fosl_filter_addLibraryFunction(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t, uint64_t))(foslFuncs + 232))(a1, a2);
}

void fosl_filter_addChild(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t, uint64_t, uint64_t))(foslFuncs + 240))(a1, a2, a3);
}

uint64_t fosl_filter_createSampler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(foslFuncs + 248))(a1, a2, a3);
  else
    return 0;
}

uint64_t fosl_filter_createImage(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(foslFuncs + 256))(a1, a2, a3);
  else
    return 0;
}

uint64_t fosl_filter_createUniform(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(foslFuncs + 264))(a1, a2, a3);
  else
    return 0;
}

uint64_t fosl_filter_createTransformMatrix(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t, uint64_t))(foslFuncs + 280))(a1, a2);
  else
    return 0;
}

uint64_t fosl_filter_createSampleTransform(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t, uint64_t))(foslFuncs + 288))(a1, a2);
  else
    return 0;
}

uint64_t fosl_filter_createUsePosition(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t))(foslFuncs + 296))(a1);
  else
    return 0;
}

uint64_t fosl_filter_createPositionUpdate(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t))(foslFuncs + 304))(a1);
  else
    return 0;
}

uint64_t fosl_filter_createCoordinateTransform(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t, uint64_t))(foslFuncs + 312))(a1, a2);
  else
    return 0;
}

void fosl_filter_setPositionUpdatePosition(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t, uint64_t))(foslFuncs + 320))(a1, a2);
}

void fosl_filter_setPositionUpdateContinuation(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t, uint64_t))(foslFuncs + 328))(a1, a2);
}

void fosl_filter_setSamplerNeedsSRGBToLinear(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t))(foslFuncs + 336))(a1);
}

void fosl_filter_setSamplerSwizzleMask(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t, uint64_t))(foslFuncs + 344))(a1, a2);
}

void fosl_filter_setSamplerSwizzleMacro(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t, uint64_t))(foslFuncs + 352))(a1, a2);
}

void fosl_filter_setMainEntryPointName(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t, uint64_t))(foslFuncs + 360))(a1, a2);
}

void fosl_filter_parseNodesInGraph(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t))(foslFuncs + 368))(a1);
}

void fosl_filter_synthesizeMainInGraph(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t))(foslFuncs + 376))(a1);
}

void fosl_filter_synthesizeMainInGraphOfType(uint64_t a1, uint64_t a2)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t, uint64_t))(foslFuncs + 384))(a1, a2);
}

void fosl_filter_dumpGraph(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t))(foslFuncs + 400))(a1);
}

void fosl_filter_printGraph(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    (*(void (**)(uint64_t))(foslFuncs + 408))(a1);
}

uint64_t fosl_filter_getStringForGraph(uint64_t a1)
{
  if (foslFunctions::initializeWrapperLibrary(void)::onceToken != -1)
    dispatch_once(&foslFunctions::initializeWrapperLibrary(void)::onceToken, &__block_literal_global_87);
  if (foslFuncs)
    return (*(uint64_t (**)(uint64_t))(foslFuncs + 416))(a1);
  else
    return 0;
}

uint64_t CI::AffineImage::alpha_one(CI::AffineImage *this)
{
  uint64_t result;
  double x;
  double y;
  double width;
  double height;
  Rectangle v8;
  CGRect v9;
  CGRect v10;

  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 128))(*((_QWORD *)this + 13));
  if (!(_DWORD)result)
    return result;
  v9.origin.x = (*(double (**)(CI::AffineImage *))(*(_QWORD *)this + 88))(this);
  x = v9.origin.x;
  y = v9.origin.y;
  width = v9.size.width;
  height = v9.size.height;
  if (CGRectIsInfinite(v9))
  {
    *(int64x2_t *)&v8.var0 = vdupq_n_s64(0xFFDFFFFFFFFFFFFFLL);
    *(int64x2_t *)&v8.var2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
    height = 1.79769313e308;
    width = 1.79769313e308;
    goto LABEL_11;
  }
  v10.origin.x = x;
  v10.origin.y = y;
  v10.size.width = width;
  v10.size.height = height;
  if (CGRectIsNull(v10))
  {
    *(int64x2_t *)&v8.var0 = vdupq_n_s64(0x7FF0000000000000uLL);
    *(_OWORD *)&v8.var2 = 0uLL;
  }
  else
  {
    v8.var0 = x;
    v8.var1 = y;
    v8.var2 = width;
    v8.var3 = height;
    if (x == -8.98846567e307 && y == -8.98846567e307)
    {
LABEL_11:
      if (width == 1.79769313e308 && height == 1.79769313e308)
        return 1;
    }
  }
  return (fabs(*((double *)this + 16)) < 0.0001 && fabs(*((double *)this + 17)) < 0.0001
       || fabs(*((double *)this + 15)) < 0.0001 && fabs(*((double *)this + 18)) < 0.0001)
      && Rectangle::isNearIntegral(&v8, 0.00001);
}

BOOL Rectangle::isNearIntegral(Rectangle *this, double a2)
{
  return vabdd_f64(this->var0, round(this->var0)) < a2
      && vabdd_f64(this->var1, round(this->var1)) < a2
      && vabdd_f64(this->var2, round(this->var2)) < a2
      && vabdd_f64(this->var3, round(this->var3)) < a2;
}

uint64_t CI::AffineImage::output_format(CI::AffineImage *this)
{
  uint64_t v2;
  double x;
  double y;
  double width;
  double height;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  BOOL v10;
  uint64_t v11;
  CGRect v13;
  CGRect v14;

  v2 = (*(uint64_t (**)(CI::AffineImage *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
  v13.origin.x = (*(double (**)(uint64_t))(*(_QWORD *)v2 + 88))(v2);
  x = v13.origin.x;
  y = v13.origin.y;
  width = v13.size.width;
  height = v13.size.height;
  if (!CGRectIsInfinite(v13))
  {
    v14.origin.x = x;
    v14.origin.y = y;
    v14.size.width = width;
    v14.size.height = height;
    v7 = !CGRectIsNull(v14) && x == -8.98846567e307;
    v8 = v7 && y == -8.98846567e307;
    v9 = v8 && width == 1.79769313e308;
    v10 = v9 && height == 1.79769313e308;
    if (!v10
      && (fabs(*((double *)this + 16)) >= 0.0001 || fabs(*((double *)this + 17)) >= 0.0001)
      && (fabs(*((double *)this + 15)) >= 0.0001 || fabs(*((double *)this + 18)) >= 0.0001))
    {
      return 0;
    }
  }
  v11 = (*(uint64_t (**)(CI::AffineImage *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 144))(v11);
}

CI::AffineNode *CI::AffineImage::render_graph_core(uint64_t a1, const CI::Affine *a2, CI::Object *this)
{
  CI::AffineNode *v5;
  unsigned int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  CI::AffineNode *v11;

  if (this)
    v5 = (CI::AffineNode *)CI::Object::ref((uint64_t)this);
  else
    v5 = 0;
  if ((*(unsigned int (**)(CI::AffineNode *))(*(_QWORD *)v5 + 16))(v5) == 35)
    return v5;
  if (a2)
    v7 = (*(uint64_t (**)(const CI::Affine *))(*(_QWORD *)a2 + 216))(a2);
  else
    v7 = 0;
  v8 = *(unsigned __int8 *)(a1 + 168);
  if (v8 == 110)
    v9 = 0;
  else
    v9 = v7;
  if (v8 == 121)
    v10 = 1;
  else
    v10 = v9;
  v11 = CI::AffineNode::append_to_tree_with_quality(v5, (float64x2_t *)(a1 + 120), a2, (CI::Context *)v10);
  CI::Object::unref(v5);
  return v11;
}

uint64_t CI::AffineImage::print_for_graphviz(uint64_t a1, FILE *__stream, uint64_t a3, int a4)
{
  int v7;

  fwrite("affine ", 7uLL, 1uLL, __stream);
  v7 = *(unsigned __int8 *)(a1 + 168);
  if (v7 == 110)
  {
    fwrite("loQ ", 4uLL, 1uLL, __stream);
    v7 = *(unsigned __int8 *)(a1 + 168);
  }
  if (v7 == 121)
    fwrite("hiQ ", 4uLL, 1uLL, __stream);
  if (a4)
    return fprintf(__stream, "[%g %g %g %g %g %g]");
  fprintf(__stream, "%c%g  %g  %g", 10, *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 152));
  return fprintf(__stream, "%c%g  %g  %g");
}

uint64_t CI::ImageWithChild::child_count(CI::ImageWithChild *this)
{
  return 1;
}

uint64_t CI::ImageWithChild::child(CI::ImageWithChild *this, int a2)
{
  if (a2)
    return 0;
  else
    return *((_QWORD *)this + 13);
}

uint64_t CI::AffineImage::shape_for_graphviz(CI::AffineImage *this)
{
  return 2;
}

uint64_t CI::AffineImage::color_for_graphviz(CI::AffineImage *this)
{
  if (*((_BYTE *)this + 168))
    return 5;
  else
    return 6;
}

void CI::AffineImage::roi_of_child(CI::AffineImage *this, CGRect a2)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  double v6[6];
  CGRect v7;

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  CI::Affine::inverse((CI::AffineImage *)((char *)this + 120), v6);
  v7.origin.x = x;
  v7.origin.y = y;
  v7.size.width = width;
  v7.size.height = height;
  CI::Affine::applyToRect((CI::Affine *)v6, v7);
}

void CI::AffineImage::extent_unclamped(CI::AffineImage *this)
{
  CI::Affine *v1;
  CGRect v2;

  v1 = (CI::AffineImage *)((char *)this + 120);
  if ((fabs(*((double *)this + 16)) >= 0.0001 || fabs(*((double *)this + 17)) >= 0.0001)
    && (fabs(*(double *)v1) >= 0.0001 || fabs(*((double *)this + 18)) >= 0.0001))
  {
    (*(void (**)(CI::AffineImage *))(*(_QWORD *)this + 88))(this);
  }
  else
  {
    v2.origin.x = (*(double (**)(_QWORD))(**((_QWORD **)this + 13) + 96))(*((_QWORD *)this + 13));
    CI::Affine::applyToRect(v1, v2);
  }
}

uint64_t CI::AffineImage::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  int __src;

  XXH64_update(a2, (char *)(a1 + 120), 0x30uLL);
  __src = *(char *)(a1 + 168);
  return XXH64_update(a2, (char *)&__src, 4uLL);
}

uint64_t CI::Image::max_dimension(CI::Image *this)
{
  return 0;
}

uint64_t CI::AffineImage::is_warp(CI::AffineImage *this)
{
  return 1;
}

uint64_t CI::AffineImage::print_for_graph_core(CI::AffineImage *this, __sFILE *a2)
{
  int v4;
  const char *v5;
  const char *v6;

  v4 = *((unsigned __int8 *)this + 168);
  v5 = "";
  if (v4 == 121)
    v5 = "hiQ ";
  if (v4 == 110)
    v6 = "loQ ";
  else
    v6 = v5;
  fprintf(a2, "affine %s", v6);
  return fprintf(a2, "[%g %g %g %g %g %g]", *((double *)this + 15), *((double *)this + 16), *((double *)this + 17), *((double *)this + 18), *((double *)this + 19), *((double *)this + 20));
}

uint64_t CI::ImageWithChild::properties(CI::ImageWithChild *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 200))(*((_QWORD *)this + 13));
}

uint64_t CI::ImageWithChild::avdepthdata(CI::ImageWithChild *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 208))(*((_QWORD *)this + 13));
}

uint64_t CI::ImageWithChild::avmatte(CI::ImageWithChild *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 216))(*((_QWORD *)this + 13));
}

uint64_t CI::ImageWithChild::ssmatte(CI::ImageWithChild *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 224))(*((_QWORD *)this + 13));
}

uint64_t CI::AffineImage::headroom(CI::AffineImage *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 232))(*((_QWORD *)this + 13));
}

uint64_t CI::AffineImage::colorspace(CI::AffineImage *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 240))(*((_QWORD *)this + 13));
}

uint64_t CI::ImageWithChild::is_empty_if_regions_of_children_are_empty(CI::ImageWithChild *this)
{
  return 1;
}

uint64_t `non-virtual thunk to'CI::AffineImage::type(CI::AffineImage *this)
{
  return 2;
}

void `non-virtual thunk to'CI::AffineImage::~AffineImage(CI::AffineImage *this)
{
  CI::ImageWithChild *v1;
  unsigned int v2;

  *(_QWORD *)this = off_1E2EBBAB0;
  v1 = (CI::AffineImage *)((char *)this - 112);
  do
    v2 = __ldaxr(dword_1ECF872F0);
  while (__stlxr(v2 - 1, dword_1ECF872F0));
  CI::ImageWithChild::~ImageWithChild(v1);
}

{
  CI::ImageWithChild *v1;
  unsigned int v2;

  *(_QWORD *)this = off_1E2EBBAB0;
  v1 = (CI::AffineImage *)((char *)this - 112);
  do
    v2 = __ldaxr(dword_1ECF872F0);
  while (__stlxr(v2 - 1, dword_1ECF872F0));
  CI::ImageWithChild::~ImageWithChild(v1);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::CGImage::CGImage(uint64_t a1, CGImage *a2, uint64_t a3, const void *a4, int a5, char a6, unsigned __int8 a7, char a8, float a9)
{
  unsigned int v18;
  NSObject *v19;
  CGImage *v20;
  CFTypeRef v21;
  int v22;
  int v23;
  CGImage *v24;
  float v25;
  int v26;
  size_t v27;
  int64x2_t v29[5];
  size_t __src;

  *(_QWORD *)(CI::Image::Image(a1) + 104) = off_1E2EBBC68;
  do
    v18 = __ldaxr(&dword_1ECF872F0[1]);
  while (__stlxr(v18 + 1, &dword_1ECF872F0[1]));
  *(_QWORD *)a1 = &off_1E2EBEDC8;
  *(_QWORD *)(a1 + 104) = &unk_1E2EBEF18;
  *(_DWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = a3;
  v19 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *(_QWORD *)(a1 + 160) = dispatch_queue_create("CI_CGNode_SurfaceCacheQueue", v19);
  *(_QWORD *)(a1 + 112) = CGImageRetain(a2);
  if (a4)
    v21 = CFRetain(a4);
  else
    v21 = 0;
  *(_QWORD *)(a1 + 136) = v21;
  *(_DWORD *)(a1 + 148) = a5;
  v22 = CI::alpha_mode_from_CGImage((uint64_t)a2, v20);
  if ((a7 & (v22 == 0)) != 0)
    v23 = 4;
  else
    v23 = v22;
  if ((a7 & (v23 == 2)) != 0)
    v23 = 6;
  *(_DWORD *)(a1 + 144) = v23;
  *(_BYTE *)(a1 + 152) = a6;
  *(_BYTE *)(a1 + 153) = a8;
  if (a9 == 0.0)
  {
    v29[0].i32[0] = 0;
    CGImageGetHeadroomInfo();
    a9 = v25;
    v26 = CI::format_from_CGImage(*(_QWORD *)(a1 + 112), v24);
    if (!CI::format_is_extended(v26) && !CI::format_is_float(v26))
      a9 = 1.0;
  }
  *(float *)(a1 + 120) = a9;
  XXH64_reset(v29, 0);
  LODWORD(__src) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  XXH64_update((uint64_t)v29, (char *)&__src, 4uLL);
  if (*(_QWORD *)(a1 + 128))
  {
    __src = *(_QWORD *)(a1 + 128);
    v27 = 8;
  }
  else
  {
    LODWORD(__src) = CGImageGetIdentifier();
    v27 = 4;
  }
  XXH64_update((uint64_t)v29, (char *)&__src, v27);
  __src = CGImageGetWidth(a2);
  XXH64_update((uint64_t)v29, (char *)&__src, 8uLL);
  __src = CGImageGetHeight(a2);
  XXH64_update((uint64_t)v29, (char *)&__src, 8uLL);
  LODWORD(__src) = CGImageGetBitmapInfo(a2);
  XXH64_update((uint64_t)v29, (char *)&__src, 4uLL);
  LODWORD(__src) = CGImageGetImageProvider() != 0;
  XXH64_update((uint64_t)v29, (char *)&__src, 4uLL);
  LODWORD(__src) = *(_DWORD *)(a1 + 144);
  XXH64_update((uint64_t)v29, (char *)&__src, 4uLL);
  LODWORD(__src) = *(_DWORD *)(a1 + 148);
  XXH64_update((uint64_t)v29, (char *)&__src, 4uLL);
  LODWORD(__src) = *(unsigned __int8 *)(a1 + 152);
  XXH64_update((uint64_t)v29, (char *)&__src, 4uLL);
  LODWORD(__src) = *(_DWORD *)(a1 + 120);
  XXH64_update((uint64_t)v29, (char *)&__src, 4uLL);
  *(_QWORD *)(a1 + 80) = XXH64_digest((uint64_t)v29);
  XXH64_reset(v29, 0);
  LODWORD(__src) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  XXH64_update((uint64_t)v29, (char *)&__src, 4uLL);
  __src = CGImageGetWidth(a2);
  XXH64_update((uint64_t)v29, (char *)&__src, 8uLL);
  __src = CGImageGetHeight(a2);
  XXH64_update((uint64_t)v29, (char *)&__src, 8uLL);
  LODWORD(__src) = CGImageGetBitmapInfo(a2);
  XXH64_update((uint64_t)v29, (char *)&__src, 4uLL);
  LODWORD(__src) = CGImageGetImageProvider() != 0;
  XXH64_update((uint64_t)v29, (char *)&__src, 4uLL);
  LODWORD(__src) = *(_DWORD *)(a1 + 144);
  XXH64_update((uint64_t)v29, (char *)&__src, 4uLL);
  LODWORD(__src) = *(_DWORD *)(a1 + 148);
  XXH64_update((uint64_t)v29, (char *)&__src, 4uLL);
  LODWORD(__src) = *(unsigned __int8 *)(a1 + 152);
  XXH64_update((uint64_t)v29, (char *)&__src, 4uLL);
  LODWORD(__src) = *(_DWORD *)(a1 + 120);
  XXH64_update((uint64_t)v29, (char *)&__src, 4uLL);
  *(_QWORD *)(a1 + 88) = XXH64_digest((uint64_t)v29);
  *(_WORD *)(a1 + 96) = 257;
  return a1;
}

void CI::CGImage::~CGImage(CI::CGImage *this)
{
  const void *v2;
  unsigned int v3;

  *(_QWORD *)this = &off_1E2EBEDC8;
  *((_QWORD *)this + 13) = &unk_1E2EBEF18;
  CGImageRelease(*((CGImageRef *)this + 14));
  *((_QWORD *)this + 14) = 0;
  v2 = (const void *)*((_QWORD *)this + 17);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 17) = 0;
  dispatch_release(*((dispatch_object_t *)this + 20));
  *((_QWORD *)this + 13) = off_1E2EBBC68;
  do
    v3 = __ldaxr(&dword_1ECF872F0[1]);
  while (__stlxr(v3 - 1, &dword_1ECF872F0[1]));
  CI::Image::~Image(this);
}

{
  CI::CGImage::~CGImage(this);
  JUMPOUT(0x194025AACLL);
}

void `non-virtual thunk to'CI::CGImage::~CGImage(CI::CGImage *this)
{
  CI::CGImage::~CGImage((CI::CGImage *)((char *)this - 104));
}

{
  CI::CGImage::~CGImage((CI::CGImage *)((char *)this - 104));
  JUMPOUT(0x194025AACLL);
}

BOOL CI::CGImage::tileable(CI::CGImage *this)
{
  return CGImageGetImageProvider() != 0;
}

uint64_t CI::CGImage::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  CGBitmapInfo __src;

  __src = CGImageGetBitmapInfo(*(CGImageRef *)(a1 + 112));
  XXH64_update(a2, (char *)&__src, 4uLL);
  __src = CGImageGetImageProvider() != 0;
  XXH64_update(a2, (char *)&__src, 4uLL);
  __src = *(_DWORD *)(a1 + 144);
  XXH64_update(a2, (char *)&__src, 4uLL);
  __src = *(_DWORD *)(a1 + 148);
  XXH64_update(a2, (char *)&__src, 4uLL);
  __src = *(unsigned __int8 *)(a1 + 152);
  XXH64_update(a2, (char *)&__src, 4uLL);
  __src = *(_DWORD *)(a1 + 120);
  return XXH64_update(a2, (char *)&__src, 4uLL);
}

uint64_t CI::CGImage::print_for_graph_core(CI::CGImage *this, __sFILE *a2)
{
  CGImage *v4;
  int v5;
  const char *v6;
  size_t Width;
  size_t Height;
  uint64_t result;
  const char *v10;
  int v11;
  const char *v12;

  fprintf(a2, "CGImageRef %p", *((const void **)this + 14));
  if (*((_QWORD *)this + 16))
  {
    fprintf(a2, " content:%016llX");
  }
  else
  {
    CGImageGetIdentifier();
    fprintf(a2, "(%d)");
  }
  v5 = CI::format_from_CGImage(*((_QWORD *)this + 14), v4);
  v6 = CI::name_for_format(v5);
  fprintf(a2, " %s", v6);
  Width = CGImageGetWidth(*((CGImageRef *)this + 14));
  Height = CGImageGetHeight(*((CGImageRef *)this + 14));
  result = fprintf(a2, " %ldx%ld", Width, Height);
  v10 = "alpha_one";
  switch(*((_DWORD *)this + 36))
  {
    case 0:
      goto LABEL_10;
    case 1:
      goto LABEL_9;
    case 2:
      v10 = "alpha_unpremul";
      goto LABEL_9;
    case 4:
      v10 = "alpha_premul-clear-edges";
      goto LABEL_9;
    case 6:
      v10 = "alpha_unpremul-clear-edges";
      goto LABEL_9;
    default:
      v10 = "alpha_unknown";
LABEL_9:
      result = fprintf(a2, " %s", v10);
LABEL_10:
      v11 = *((_DWORD *)this + 37);
      if (v11)
      {
        if (v11 == 1)
          v12 = "edge_clamp";
        else
          v12 = "edge_unknown";
        result = fprintf(a2, " %s", v12);
      }
      if (*((_BYTE *)this + 152))
        result = fwrite(" nearestsampling", 0x10uLL, 1uLL, a2);
      if (*((_BYTE *)this + 153))
        return fwrite(" cache", 6uLL, 1uLL, a2);
      return result;
  }
}

CI::Object *CI::CGImage::render_graph_core(uint64_t a1, CGImage *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  signed int v13;
  int v14;
  int v15;
  CI::Object *v16;
  uint64_t v17;
  CI::Object *v18;
  CI::Object *v19;
  CI::Object *v20;
  CI::Node *v21;
  CI::Object *v22;
  uint64_t v23;
  double v25;
  double v26;
  CGFloat v27;
  double v28;
  CGFloat v29;
  double v30;
  CGFloat v31;
  CGRect v32;
  CGRect v33;
  CGRect v34;

  v7 = CI::format_from_CGImage(*(_QWORD *)(a1 + 112), a2);
  if ((_DWORD)v7 == 1799)
  {
    if (CGImageGetImageProvider())
      v7 = 1800;
    else
      v7 = 1799;
  }
  if (*(_DWORD *)(a1 + 148) == 1)
    goto LABEL_7;
  if ((*(_DWORD *)(a1 + 144) | 2) == 6)
    goto LABEL_7;
  if ((*(unsigned int (**)(CGImage *))(*(_QWORD *)a2 + 16))(a2) != 74)
  {
    v25 = CI::Image::lookup_union_roi(a1, a4);
    v27 = v26;
    v29 = v28;
    v31 = v30;
    v33.origin.x = (*(double (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1);
    v34.origin.x = v25;
    v34.origin.y = v27;
    v34.size.width = v29;
    v34.size.height = v31;
    if (CGRectContainsRect(v33, v34))
    {
LABEL_7:
      v8 = 0;
LABEL_8:
      v9 = 1;
      goto LABEL_9;
    }
  }
  if (!(*(unsigned int (**)(CGImage *, _QWORD))(*(_QWORD *)a2 + 560))(a2, 0))
  {
    v8 = 1;
    goto LABEL_8;
  }
  v8 = CI::format_has_alpha(v7) ^ 1;
  v9 = v8;
LABEL_9:
  v10 = CI::Context::swizzler_for_input((uint64_t)a2, v7);
  v12 = v10;
  v13 = v11;
  if (v11)
    v14 = CI::input_format_for_conversion(v11);
  else
    v14 = v10;
  if (*(_BYTE *)(a1 + 152))
    v15 = 1;
  else
    v15 = (*(uint64_t (**)(CGImage *, uint64_t, uint64_t))(*(_QWORD *)a2 + 568))(a2, 1, v12) ^ 1;
  v16 = (CI::Object *)operator new();
  v17 = (*(uint64_t (**)(CGImage *))(*(_QWORD *)a2 + 272))(a2);
  v18 = (CI::Object *)CI::CGNode::CGNode((uint64_t)v16, v17, *(_DWORD *)(a1 + 100), *(CI **)(a1 + 112), *(_QWORD *)(a1 + 128), *(_QWORD *)(a1 + 160), v14, v9, v15, *(_BYTE *)(a1 + 153));
  v19 = CI::ConvertNode::append_to_tree(v18, v13);
  CI::Object::unref(v16);
  v20 = CI::SwizzleNode::append_to_tree(v19, SHIDWORD(v12), 1, 0);
  if (v19)
    CI::Object::unref(v19);
  if (*(unsigned __int8 *)(a1 + 152) != v15)
  {
    v21 = (CI::Node *)CI::SampleModeNode::append_to_tree((uint64_t)v20, 1);
    if (v20)
      CI::Object::unref(v20);
    v20 = (CI::Object *)CI::NoopNode::append_to_tree_and_unref(v21, (uint64_t)a2, 6);
  }
  if (*(_DWORD *)(a1 + 144) == 2)
  {
    v22 = CI::PremultiplyNode::append_to_tree(v20, (CI::Node *)1, 1);
    if (v20)
      CI::Object::unref(v20);
    if (v8)
      goto LABEL_25;
    return v22;
  }
  v22 = v20;
  if (!v8)
    return v22;
LABEL_25:
  v32.origin.x = (*(double (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1);
  v23 = CI::CropNode::append_to_tree(v22, (CI::Node *)1, v32);
  if (v22)
    CI::Object::unref(v22);
  return (CI::Object *)v23;
}

double CI::Image::lookup_union_roi(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  unint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  BOOL v9;
  _QWORD *v10;

  v4 = *(_QWORD **)(a2 + 8);
  v2 = (_QWORD *)(a2 + 8);
  v3 = v4;
  v5 = (_QWORD *)MEMORY[0x1E0C9D628];
  if (v4)
  {
    v6 = *(_QWORD *)(a1 + 80);
    v7 = v2;
    do
    {
      v8 = v3[4];
      v9 = v8 >= v6;
      if (v8 >= v6)
        v10 = v3;
      else
        v10 = v3 + 1;
      if (v9)
        v7 = v3;
      v3 = (_QWORD *)*v10;
    }
    while (*v10);
    if (v7 != v2 && v6 >= v7[4])
      v5 = v7 + 5;
  }
  return *(double *)v5;
}

void CI::CGImage::restore_resources(CI::CGImage *this, CGImage **a2)
{
  CGImage *v4;

  if ((*((unsigned int (**)(CGImage **))*a2 + 2))(a2) == 29)
  {
    v4 = (CGImage *)*((_QWORD *)this + 14);
    if (a2[13] != v4)
      CI::CGNode::set_image((uint64_t)a2, v4, *((_QWORD *)this + 16), *((NSObject **)this + 20));
  }
}

CIGVNode *CI::CGImage::node_for_graphviz(uint64_t a1, _QWORD *a2)
{
  CIGVNode *v3;

  v3 = CI::Image::node_for_graphviz((unsigned int *)a1, a2);
  if (CI_PRINT_TREE_dump_inputs())
    CIGVNodeAddImage(v3, *(const char **)(a1 + 112));
  return v3;
}

uint64_t CI::CGImage::print_for_graphviz(uint64_t a1, FILE *__stream)
{
  CGImage *v4;
  int v5;
  const char *v6;
  uint64_t result;
  const char *v8;
  int v9;
  const char *v10;

  fwrite("CGImageRef", 0xAuLL, 1uLL, __stream);
  if (*(_QWORD *)(a1 + 128))
  {
    fprintf(__stream, " content:%016llX");
  }
  else if (*(_QWORD *)(a1 + 112))
  {
    fprintf(__stream, " %p", *(const void **)(a1 + 112));
    CGImageGetIdentifier();
    fprintf(__stream, "(%d)");
  }
  v5 = CI::format_from_CGImage(*(_QWORD *)(a1 + 112), v4);
  v6 = CI::name_for_format(v5);
  result = fputs(v6, __stream);
  v8 = "alpha_one";
  switch(*(_DWORD *)(a1 + 144))
  {
    case 0:
      goto LABEL_11;
    case 1:
      goto LABEL_10;
    case 2:
      v8 = "alpha_unpremul";
      goto LABEL_10;
    case 4:
      v8 = "alpha_premul-clear-edges";
      goto LABEL_10;
    case 6:
      v8 = "alpha_unpremul-clear-edges";
      goto LABEL_10;
    default:
      v8 = "alpha_unknown";
LABEL_10:
      result = fprintf(__stream, " %s", v8);
LABEL_11:
      v9 = *(_DWORD *)(a1 + 148);
      if (v9)
      {
        if (v9 == 1)
          v10 = "edge_clamp";
        else
          v10 = "edge_unknown";
        result = fprintf(__stream, " %s", v10);
      }
      if (*(_BYTE *)(a1 + 152))
        result = fwrite(" nearestsampling", 0x10uLL, 1uLL, __stream);
      if (*(_BYTE *)(a1 + 153))
        return fwrite(" cache", 6uLL, 1uLL, __stream);
      return result;
  }
}

uint64_t CI::CGImage::type(CI::CGImage *this)
{
  return 3;
}

uint64_t CI::CGImage::child_count(CI::CGImage *this)
{
  return 0;
}

uint64_t CI::CGImage::child(CI::CGImage *this)
{
  return 0;
}

uint64_t CI::CGImage::shape_for_graphviz(CI::CGImage *this)
{
  return 0;
}

uint64_t CI::CGImage::color_for_graphviz(CI::CGImage *this)
{
  return 12;
}

_DWORD *CI::CGImage::extent(_DWORD *this)
{
  if (!this[37])
    return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)this + 96))(this);
  return this;
}

double CI::CGImage::extent_unclamped(CGImageRef *this)
{
  CGImageGetWidth(this[14]);
  CGImageGetHeight(this[14]);
  return 0.0;
}

size_t CI::CGImage::max_dimension(CGImageRef *this)
{
  size_t Width;
  size_t Height;
  CGImage *v4;

  Width = CGImageGetWidth(this[14]);
  Height = CGImageGetHeight(this[14]);
  v4 = this[14];
  if (Width <= Height)
    return CGImageGetHeight(v4);
  else
    return CGImageGetWidth(v4);
}

BOOL CI::CGImage::alpha_one(CI::CGImage *this)
{
  int v1;

  v1 = *((_DWORD *)this + 36);
  return v1 == 1 || v1 == -1;
}

uint64_t CI::CGImage::output_format(CI::CGImage *this, CGImage *a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 14);
  if (result)
    return CI::format_from_CGImage(result, a2);
  return result;
}

uint64_t CI::CGImage::properties(CI::CGImage *this)
{
  return *((_QWORD *)this + 17);
}

float CI::CGImage::headroom(CI::CGImage *this)
{
  return *((float *)this + 30);
}

CGColorSpaceRef CI::CGImage::colorspace(CGImageRef *this)
{
  return CGImageGetColorSpace(this[14]);
}

uint64_t CI::CGImage::baseColorspace(CI::CGImage *this)
{
  return (*(uint64_t (**)(CI::CGImage *))(*(_QWORD *)this + 240))(this);
}

uint64_t `non-virtual thunk to'CI::CGImage::type(CI::CGImage *this)
{
  return 3;
}

uint64_t CI::InstanceCounted<(CI::Type)3>::type()
{
  return 3;
}

_QWORD *CI::InstanceCounted<(CI::Type)3>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBBC68;
  do
    v1 = __ldaxr(&dword_1ECF872F0[1]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[1]));
  return result;
}

void CI::InstanceCounted<(CI::Type)3>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBBC68;
  do
    v1 = __ldaxr(&dword_1ECF872F0[1]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[1]));
  JUMPOUT(0x194025AACLL);
}

void CI::ClampImage::roi_of_child(CI::ClampImage *this, CGRect a2)
{
  CI::ClampNode::adjust_roi_for_clamp_rect(this, a2, *(CGRect *)((char *)this + 120));
}

CI::Node *CI::ClampImage::render_graph_core(uint64_t a1, uint64_t a2, CI::Object *this, uint64_t a4, int a5)
{
  CI::ClampNode *v8;
  CI::Node *v9;
  CI::Node *v10;

  if (this)
    v8 = (CI::ClampNode *)CI::Object::ref((uint64_t)this);
  else
    v8 = 0;
  if ((*(unsigned int (**)(CI::ClampNode *))(*(_QWORD *)v8 + 16))(v8) != 35)
  {
    v10 = (CI::Node *)CI::ClampNode::append_to_tree(v8, v9, *(CGRect *)(a1 + 120));
    CI::Object::unref(v8);
    if (a5 >= 2)
      return (CI::Node *)CI::NoopNode::append_to_tree_and_unref(v10, a2, 5);
    return v10;
  }
  return v8;
}

void CI::ClampImage::~ClampImage(CI::ClampImage *this)
{
  unsigned int v1;

  *((_QWORD *)this + 14) = off_1E2EBC000;
  do
    v1 = __ldaxr(&dword_1ECF872F0[5]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[5]));
  CI::ImageWithChild::~ImageWithChild(this);
}

{
  unsigned int v1;

  *((_QWORD *)this + 14) = off_1E2EBC000;
  do
    v1 = __ldaxr(&dword_1ECF872F0[5]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[5]));
  CI::ImageWithChild::~ImageWithChild(this);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::ClampImage::type(CI::ClampImage *this)
{
  return 7;
}

uint64_t CI::ClampImage::shape_for_graphviz(CI::ClampImage *this)
{
  return 2;
}

uint64_t CI::ClampImage::color_for_graphviz(CI::ClampImage *this)
{
  return 5;
}

double CI::ClampImage::extent(CI::ClampImage *this)
{
  return *MEMORY[0x1E0C9D5E0];
}

double CI::ClampImage::extent_unclamped(CI::ClampImage *this)
{
  return *((double *)this + 15);
}

uint64_t CI::ClampImage::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  return XXH64_update(a2, (char *)(a1 + 120), 0x20uLL);
}

uint64_t CI::ClampImage::alpha_one(CI::ClampImage *this)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  CGRect v5;

  v2 = (*(uint64_t (**)(CI::ClampImage *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
  v5.origin.x = (*(double (**)(uint64_t))(*(_QWORD *)v2 + 88))(v2);
  result = CGRectContainsRect(v5, *(CGRect *)((char *)this + 120));
  if ((_DWORD)result)
  {
    v4 = (*(uint64_t (**)(CI::ClampImage *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 128))(v4);
  }
  return result;
}

uint64_t CI::ClampImage::is_warp(CI::ClampImage *this)
{
  return 1;
}

uint64_t CI::ClampImage::output_format(CI::ClampImage *this)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  CGRect v5;

  v2 = (*(uint64_t (**)(CI::ClampImage *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
  v5.origin.x = (*(double (**)(uint64_t))(*(_QWORD *)v2 + 88))(v2);
  result = CGRectContainsRect(v5, *(CGRect *)((char *)this + 120));
  if ((_DWORD)result)
  {
    v4 = (*(uint64_t (**)(CI::ClampImage *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 144))(v4);
  }
  return result;
}

size_t CI::ClampImage::print_for_graph_core(CI::ClampImage *this, __sFILE *__stream)
{
  __sFILE *v4;

  fwrite("clampRect ", 0xAuLL, 1uLL, __stream);
  return CI::fprintf(__stream, v4, *(CGRect *)((char *)this + 120));
}

uint64_t CI::ClampImage::headroom(CI::ClampImage *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 232))(*((_QWORD *)this + 13));
}

uint64_t CI::ClampImage::colorspace(CI::ClampImage *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 240))(*((_QWORD *)this + 13));
}

uint64_t `non-virtual thunk to'CI::ClampImage::type(CI::ClampImage *this)
{
  return 7;
}

void `non-virtual thunk to'CI::ClampImage::~ClampImage(CI::ClampImage *this)
{
  CI::ImageWithChild *v1;
  unsigned int v2;

  *(_QWORD *)this = off_1E2EBC000;
  v1 = (CI::ClampImage *)((char *)this - 112);
  do
    v2 = __ldaxr(&dword_1ECF872F0[5]);
  while (__stlxr(v2 - 1, &dword_1ECF872F0[5]));
  CI::ImageWithChild::~ImageWithChild(v1);
}

{
  CI::ImageWithChild *v1;
  unsigned int v2;

  *(_QWORD *)this = off_1E2EBC000;
  v1 = (CI::ClampImage *)((char *)this - 112);
  do
    v2 = __ldaxr(&dword_1ECF872F0[5]);
  while (__stlxr(v2 - 1, &dword_1ECF872F0[5]));
  CI::ImageWithChild::~ImageWithChild(v1);
  JUMPOUT(0x194025AACLL);
}

CI::ClampToAlphaNode *CI::ClampToAlphaImage::render_graph_core(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CI::Node *v4;
  CI::ClampToAlphaNode *v5;
  CI::ClampToAlphaNode *v6;

  v4 = (CI::Node *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 184))(a1);
  if (!a3)
    return CI::ClampToAlphaNode::append_to_tree(0, v4);
  v5 = (CI::ClampToAlphaNode *)CI::Object::ref(a3);
  v6 = CI::ClampToAlphaNode::append_to_tree(v5, v4);
  if (v5)
    CI::Object::unref(v5);
  return v6;
}

void CI::ClampToAlphaImage::~ClampToAlphaImage(CI::ClampToAlphaImage *this)
{
  unsigned int v1;

  *((_QWORD *)this + 14) = off_1E2EBC0A0;
  do
    v1 = __ldaxr(&dword_1ECF872F0[6]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[6]));
  CI::ImageWithChild::~ImageWithChild(this);
}

{
  unsigned int v1;

  *((_QWORD *)this + 14) = off_1E2EBC0A0;
  do
    v1 = __ldaxr(&dword_1ECF872F0[6]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[6]));
  CI::ImageWithChild::~ImageWithChild(this);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::ClampToAlphaImage::type(CI::ClampToAlphaImage *this)
{
  return 8;
}

uint64_t CI::ClampToAlphaImage::shape_for_graphviz(CI::ClampToAlphaImage *this)
{
  return 2;
}

uint64_t CI::ClampToAlphaImage::color_for_graphviz(CI::ClampToAlphaImage *this)
{
  return 4;
}

uint64_t CI::ImageWithChild::extent_unclamped(CI::ImageWithChild *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 96))(*((_QWORD *)this + 13));
}

uint64_t CI::ImageWithChild::alpha_one(CI::ImageWithChild *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 128))(*((_QWORD *)this + 13));
}

uint64_t CI::ClampToAlphaImage::output_format(CI::ClampToAlphaImage *this)
{
  uint64_t v1;

  v1 = (*(uint64_t (**)(CI::ClampToAlphaImage *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 144))(v1);
}

size_t CI::ClampToAlphaImage::print_for_graph_core(CI::ClampToAlphaImage *this, __sFILE *__stream)
{
  return fwrite("clamp_to_alpha", 0xEuLL, 1uLL, __stream);
}

float CI::ClampToAlphaImage::headroom(CI::ClampToAlphaImage *this)
{
  return 1.0;
}

uint64_t CI::ClampToAlphaImage::colorspace(CI::ClampToAlphaImage *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 240))(*((_QWORD *)this + 13));
}

uint64_t `non-virtual thunk to'CI::ClampToAlphaImage::type(CI::ClampToAlphaImage *this)
{
  return 8;
}

void `non-virtual thunk to'CI::ClampToAlphaImage::~ClampToAlphaImage(CI::ClampToAlphaImage *this)
{
  CI::ImageWithChild *v1;
  unsigned int v2;

  *(_QWORD *)this = off_1E2EBC0A0;
  v1 = (CI::ClampToAlphaImage *)((char *)this - 112);
  do
    v2 = __ldaxr(&dword_1ECF872F0[6]);
  while (__stlxr(v2 - 1, &dword_1ECF872F0[6]));
  CI::ImageWithChild::~ImageWithChild(v1);
}

{
  CI::ImageWithChild *v1;
  unsigned int v2;

  *(_QWORD *)this = off_1E2EBC0A0;
  v1 = (CI::ClampToAlphaImage *)((char *)this - 112);
  do
    v2 = __ldaxr(&dword_1ECF872F0[6]);
  while (__stlxr(v2 - 1, &dword_1ECF872F0[6]));
  CI::ImageWithChild::~ImageWithChild(v1);
  JUMPOUT(0x194025AACLL);
}

CI::ColorMatrixImage *CI::ColorMatrixImage::ColorMatrixImage(CI::ColorMatrixImage *this, CI::Image *a2, double (*a3)[4])
{
  unsigned int v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;

  *((_QWORD *)CI::ImageWithChild::ImageWithChild(this, a2) + 14) = off_1E2EBBF38;
  do
    v6 = __ldaxr(&dword_1ECF872F0[3]);
  while (__stlxr(v6 + 1, &dword_1ECF872F0[3]));
  *(_QWORD *)this = &off_1E2EBCA40;
  *((_QWORD *)this + 14) = &unk_1E2EBCB98;
  v7 = *(_OWORD *)&(*a3)[0];
  *(_OWORD *)((char *)this + 136) = *(_OWORD *)&(*a3)[2];
  *(_OWORD *)((char *)this + 120) = v7;
  v8 = *(_OWORD *)&(*a3)[4];
  v9 = *(_OWORD *)&(*a3)[6];
  v10 = *(_OWORD *)&(*a3)[8];
  *(_OWORD *)((char *)this + 200) = *(_OWORD *)&(*a3)[10];
  *(_OWORD *)((char *)this + 184) = v10;
  *(_OWORD *)((char *)this + 168) = v9;
  *(_OWORD *)((char *)this + 152) = v8;
  v11 = *(_OWORD *)&(*a3)[12];
  v12 = *(_OWORD *)&(*a3)[14];
  v13 = *(_OWORD *)&(*a3)[16];
  *(_OWORD *)((char *)this + 264) = *(_OWORD *)&(*a3)[18];
  *(_OWORD *)((char *)this + 248) = v13;
  *(_OWORD *)((char *)this + 232) = v12;
  *(_OWORD *)((char *)this + 216) = v11;
  *((_QWORD *)this + 10) = CI::ColorMatrixImage::makeDigest(*((_QWORD *)a2 + 10), (char *)a3);
  *((_QWORD *)this + 11) = CI::ColorMatrixImage::makeDigest(*((_QWORD *)a2 + 11), (char *)a3);
  *((_BYTE *)this + 97) = 0;
  return this;
}

unint64_t CI::ColorMatrixImage::makeDigest(uint64_t a1, char *a2)
{
  int64x2_t v5[5];
  uint64_t __src;

  XXH64_reset(v5, 0);
  LODWORD(__src) = 5;
  XXH64_update((uint64_t)v5, (char *)&__src, 4uLL);
  __src = a1;
  XXH64_update((uint64_t)v5, (char *)&__src, 8uLL);
  if (a2)
    XXH64_update((uint64_t)v5, a2, 0xA0uLL);
  return XXH64_digest((uint64_t)v5);
}

float CI::ColorMatrixImage::headroom(CI::ColorMatrixImage *this)
{
  uint64_t v2;
  float v3;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  float v12;
  double v13;
  double v14;
  double v15;
  double v16;
  float v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  float v23;

  v2 = (*(uint64_t (**)(CI::ColorMatrixImage *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
  v3 = (*(float (**)(uint64_t))(*(_QWORD *)v2 + 232))(v2);
  if (v3 < 1.0)
    return 0.0;
  v5 = v3;
  v6 = *((double *)this + 15);
  v7 = *((double *)this + 16);
  v8 = *((double *)this + 17);
  v9 = *((double *)this + 18);
  v10 = *((double *)this + 31);
  v11 = *((double *)this + 32);
  v12 = v10 + v9 + v7 * v5 + v6 * v5 + v8 * v5;
  v13 = *((double *)this + 19);
  v14 = *((double *)this + 20);
  v15 = *((double *)this + 21);
  v16 = *((double *)this + 22);
  v17 = v11 + v16 + v14 * v5 + v13 * v5 + v15 * v5;
  v18 = *((double *)this + 23);
  v19 = *((double *)this + 24);
  v20 = *((double *)this + 25);
  v21 = *((double *)this + 26);
  v22 = *((double *)this + 33);
  *(float *)&v5 = v22 + v21 + v19 * v5 + v18 * v5 + v20 * v5;
  *(float *)&v6 = v10 + v9 + v7 * 0.0 + v6 * 0.0 + v8 * 0.0;
  *(float *)&v7 = v11 + v16 + v14 * 0.0 + v13 * 0.0 + v15 * 0.0;
  v23 = v22 + v21 + v19 * 0.0 + v18 * 0.0 + v20 * 0.0;
  return fmaxf(fmaxf(fmaxf(*(float *)&v6, *(float *)&v7), v23), fmaxf(fmaxf(fmaxf(v12, v17), *(float *)&v5), 1.0));
}

uint64_t CI::ColorMatrixImage::extent(CI::ColorMatrixImage *this, const double (*a2)[4])
{
  uint64_t result;

  result = CI::ColorMatrixNode::is_alpha_biased((CI::ColorMatrixImage *)((char *)this + 120), a2);
  if (!(_DWORD)result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 88))(*((_QWORD *)this + 13));
  return result;
}

uint64_t CI::ColorMatrixImage::alpha_one(CI::ColorMatrixImage *this, const double (*a2)[4])
{
  CI::ColorMatrixNode *v3;
  const double (*v4)[4];
  uint64_t result;

  v3 = (CI::ColorMatrixImage *)((char *)this + 120);
  if (CI::ColorMatrixNode::is_alpha_one((CI::ColorMatrixImage *)((char *)this + 120), a2))
    return 1;
  result = CI::ColorMatrixNode::is_alpha_preserving(v3, v4);
  if ((_DWORD)result)
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 128))(*((_QWORD *)this + 13));
  return result;
}

uint64_t CI::ColorMatrixImage::print_for_graph_core(CI::ColorMatrixImage *this, __sFILE *__stream)
{
  const double (*v4)[4];
  uint64_t v5;
  double *v6;
  const char **v7;
  const char *v8;
  uint64_t result;

  fwrite("color_matrix", 0xCuLL, 1uLL, __stream);
  if (CI::ColorMatrixNode::is_biased((CI::ColorMatrixImage *)((char *)this + 120), v4))
    v5 = 5;
  else
    v5 = 4;
  v6 = (double *)((char *)this + 144);
  v7 = (const char **)off_1E2EC7088;
  do
  {
    v8 = *v7++;
    result = fprintf(__stream, " %s=(%g %g %g %g)", v8, *(v6 - 3), *(v6 - 2), *(v6 - 1), *v6);
    v6 += 4;
    --v5;
  }
  while (v5);
  return result;
}

CI::ColorMatrixNode *CI::ColorMatrixImage::render_graph_core(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const double (*v5)[4];
  CI::ColorMatrixNode *v6;
  CI::ColorMatrixNode *v7;

  v5 = (const double (*)[4])(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 184))(a1);
  if (!a3)
    return CI::ColorMatrixNode::append_to_tree(0, (CI::Node *)(a1 + 120), v5);
  v6 = (CI::ColorMatrixNode *)CI::Object::ref(a3);
  v7 = CI::ColorMatrixNode::append_to_tree(v6, (CI::Node *)(a1 + 120), v5);
  if (v6)
    CI::Object::unref(v6);
  return v7;
}

uint64_t CI::ColorMatrixImage::print_for_graphviz(uint64_t a1, FILE *__stream, uint64_t a3, int a4)
{
  const double (*v7)[4];
  _BOOL4 is_biased;
  uint64_t v9;
  uint64_t v10;
  double *v11;
  const char **v12;
  const char *v13;
  uint64_t result;

  fwrite("color_matrix", 0xCuLL, 1uLL, __stream);
  is_biased = CI::ColorMatrixNode::is_biased((CI::ColorMatrixNode *)(a1 + 120), v7);
  if (a4)
    v9 = 32;
  else
    v9 = 10;
  if (is_biased)
    v10 = 5;
  else
    v10 = 4;
  v11 = (double *)(a1 + 144);
  v12 = (const char **)off_1E2EC7088;
  do
  {
    v13 = *v12++;
    result = fprintf(__stream, "%c%s=(%g %g %g %g)", v9, v13, *(v11 - 3), *(v11 - 2), *(v11 - 1), *v11);
    v11 += 4;
    --v10;
  }
  while (v10);
  return result;
}

void CI::ColorMatrixImage::~ColorMatrixImage(CI::ColorMatrixImage *this)
{
  unsigned int v1;

  *((_QWORD *)this + 14) = off_1E2EBBF38;
  do
    v1 = __ldaxr(&dword_1ECF872F0[3]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[3]));
  CI::ImageWithChild::~ImageWithChild(this);
}

{
  unsigned int v1;

  *((_QWORD *)this + 14) = off_1E2EBBF38;
  do
    v1 = __ldaxr(&dword_1ECF872F0[3]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[3]));
  CI::ImageWithChild::~ImageWithChild(this);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::ColorMatrixImage::type(CI::ColorMatrixImage *this)
{
  return 5;
}

uint64_t CI::ColorMatrixImage::shape_for_graphviz(CI::ColorMatrixImage *this)
{
  return 2;
}

uint64_t CI::ColorMatrixImage::color_for_graphviz(CI::ColorMatrixImage *this)
{
  return 4;
}

uint64_t CI::ColorMatrixImage::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  return XXH64_update(a2, (char *)(a1 + 120), 0xA0uLL);
}

uint64_t CI::ImageWithChild::colorspace(CI::ImageWithChild *this)
{
  return 0;
}

BOOL CI::ColorMatrixImage::is_empty_if_regions_of_children_are_empty(CI::ColorMatrixImage *this, const double (*a2)[4])
{
  return CI::ColorMatrixNode::is_alpha_preserving((CI::ColorMatrixImage *)((char *)this + 120), a2);
}

uint64_t `non-virtual thunk to'CI::ColorMatrixImage::type(CI::ColorMatrixImage *this)
{
  return 5;
}

void `non-virtual thunk to'CI::ColorMatrixImage::~ColorMatrixImage(CI::ColorMatrixImage *this)
{
  CI::ImageWithChild *v1;
  unsigned int v2;

  *(_QWORD *)this = off_1E2EBBF38;
  v1 = (CI::ColorMatrixImage *)((char *)this - 112);
  do
    v2 = __ldaxr(&dword_1ECF872F0[3]);
  while (__stlxr(v2 - 1, &dword_1ECF872F0[3]));
  CI::ImageWithChild::~ImageWithChild(v1);
}

{
  CI::ImageWithChild *v1;
  unsigned int v2;

  *(_QWORD *)this = off_1E2EBBF38;
  v1 = (CI::ColorMatrixImage *)((char *)this - 112);
  do
    v2 = __ldaxr(&dword_1ECF872F0[3]);
  while (__stlxr(v2 - 1, &dword_1ECF872F0[3]));
  CI::ImageWithChild::~ImageWithChild(v1);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::InstanceCounted<(CI::Type)5>::type()
{
  return 5;
}

_QWORD *CI::InstanceCounted<(CI::Type)5>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBBF38;
  do
    v1 = __ldaxr(&dword_1ECF872F0[3]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[3]));
  return result;
}

void CI::InstanceCounted<(CI::Type)5>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBBF38;
  do
    v1 = __ldaxr(&dword_1ECF872F0[3]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[3]));
  JUMPOUT(0x194025AACLL);
}

CI::ColorMatchImage *CI::ColorMatchImage::ColorMatchImage(CI::ColorMatchImage *this, CI::Image *a2, CGColorSpace *a3)
{
  unsigned int v6;

  *((_QWORD *)CI::ImageWithChild::ImageWithChild(this, a2) + 14) = off_1E2EBBDD0;
  do
    v6 = __ldaxr(&dword_1ECF872F0[2]);
  while (__stlxr(v6 + 1, &dword_1ECF872F0[2]));
  *(_QWORD *)this = &off_1E2EBB490;
  *((_BYTE *)this + 138) = 0;
  *((_DWORD *)this + 35) = 0;
  *((_QWORD *)this + 14) = &unk_1E2EBB5E8;
  *((_QWORD *)this + 15) = 0;
  *((_BYTE *)this + 136) = 1;
  *((_QWORD *)this + 16) = CGColorSpaceRetain(a3);
  *((_BYTE *)this + 137) = 0;
  *((_QWORD *)this + 10) = CI::ColorMatchImage::makeDigest(*((_QWORD *)a2 + 10), 0, a3, 0.0);
  *((_QWORD *)this + 11) = CI::ColorMatchImage::makeDigest(*((_QWORD *)a2 + 11), 0, a3, 0.0);
  return this;
}

unint64_t CI::ColorMatchImage::makeDigest(uint64_t a1, CGColorSpace *a2, CGColorSpace *a3, float a4)
{
  int64x2_t v9[5];
  uint64_t __src;

  XXH64_reset(v9, 0);
  LODWORD(__src) = 4;
  XXH64_update((uint64_t)v9, (char *)&__src, 4uLL);
  __src = a1;
  XXH64_update((uint64_t)v9, (char *)&__src, 8uLL);
  if (!a2)
  {
    LODWORD(__src) = 1;
    XXH64_update((uint64_t)v9, (char *)&__src, 4uLL);
    if (a3)
      goto LABEL_3;
LABEL_5:
    LODWORD(__src) = 1;
    XXH64_update((uint64_t)v9, (char *)&__src, 4uLL);
    goto LABEL_6;
  }
  CI::XXHashHelper::add((CI::XXHashHelper *)v9, a2);
  if (!a3)
    goto LABEL_5;
LABEL_3:
  CI::XXHashHelper::add((CI::XXHashHelper *)v9, a3);
LABEL_6:
  *(float *)&__src = a4;
  XXH64_update((uint64_t)v9, (char *)&__src, 4uLL);
  return XXH64_digest((uint64_t)v9);
}

CI::ColorMatchImage *CI::ColorMatchImage::ColorMatchImage(CI::ColorMatchImage *this, CI::Image *a2, CGColorSpace *a3, float a4)
{
  unsigned int v8;
  CGColorSpaceRef v9;
  BOOL v10;

  *((_QWORD *)CI::ImageWithChild::ImageWithChild(this, a2) + 14) = off_1E2EBBDD0;
  do
    v8 = __ldaxr(&dword_1ECF872F0[2]);
  while (__stlxr(v8 + 1, &dword_1ECF872F0[2]));
  *(_QWORD *)this = &off_1E2EBB490;
  *((_QWORD *)this + 14) = &unk_1E2EBB5E8;
  *((_BYTE *)this + 138) = 0;
  *((_DWORD *)this + 35) = 0;
  v9 = CGColorSpaceRetain(a3);
  *((_WORD *)this + 68) = 256;
  *((_QWORD *)this + 15) = v9;
  *((_QWORD *)this + 16) = 0;
  v10 = a4 != 0.0 && CGColorSpaceIsHDR(a3);
  *((_BYTE *)this + 138) = v10;
  *((float *)this + 35) = a4;
  *((_QWORD *)this + 10) = CI::ColorMatchImage::makeDigest(*((_QWORD *)a2 + 10), a3, 0, a4);
  *((_QWORD *)this + 11) = CI::ColorMatchImage::makeDigest(*((_QWORD *)a2 + 11), a3, 0, *((float *)this + 35));
  return this;
}

void `non-virtual thunk to'CI::ColorMatchImage::~ColorMatchImage(CI::ColorMatchImage *this)
{
  CI::ColorMatchImage::~ColorMatchImage((CI::ColorMatchImage *)((char *)this - 112));
}

{
  CI::ColorMatchImage::~ColorMatchImage((CI::ColorMatchImage *)((char *)this - 112));
  JUMPOUT(0x194025AACLL);
}

float CI::ColorMatchImage::headroom(CI::ColorMatchImage *this)
{
  float v2;
  CGColorSpace *v3;
  _BOOL4 v4;
  CGColorSpace *v5;
  _BOOL4 v6;
  int v7;

  if (*((_BYTE *)this + 138))
    return *((float *)this + 35);
  v2 = (*(float (**)(_QWORD))(**((_QWORD **)this + 13) + 232))(*((_QWORD *)this + 13));
  if (v2 <= 1.0)
  {
    v3 = (CGColorSpace *)*((_QWORD *)this + 15);
    if (v3)
      v4 = !CGColorSpaceIsPQBased(v3) && !CGColorSpaceIsHLGBased(*((CGColorSpaceRef *)this + 15));
    else
      v4 = 1;
    v5 = (CGColorSpace *)*((_QWORD *)this + 16);
    if (v5)
      v6 = !CGColorSpaceIsPQBased(v5) && !CGColorSpaceIsHLGBased(*((CGColorSpaceRef *)this + 16));
    else
      v6 = 1;
    if (*((_BYTE *)this + 137))
      v7 = v4;
    else
      v7 = 1;
    if (v7 == 1)
    {
      if (!*((_BYTE *)this + 136))
        v6 = 1;
      if (!v6)
        return 4.9261;
    }
    else
    {
      return 4.9261;
    }
  }
  return v2;
}

CGColorSpace *CI::ColorMatchImage::colorspace(CGColorSpace **this, CGColorSpace *a2)
{
  CGColorSpace *SDRCopy;
  CGColorSpace *v3;

  if (*((_BYTE *)this + 138))
  {
    SDRCopy = CI::ColorSpaceCreateSDRCopy(this[15], a2);
    v3 = SDRCopy;
    if (SDRCopy)
      CFAutorelease(SDRCopy);
  }
  else if (*((_BYTE *)this + 137))
  {
    if (*((_BYTE *)this + 136))
      return 0;
    else
      return this[15];
  }
  else
  {
    return this[16];
  }
  return v3;
}

uint64_t CI::ColorMatchImage::print_for_graph_core(__sFILE **this, __sFILE *__stream)
{
  uint64_t result;
  float v5;
  const char *v6;
  size_t v7;

  fwrite("colormatch", 0xAuLL, 1uLL, __stream);
  fputc(32, __stream);
  if (*((_BYTE *)this + 136))
    fwrite("workingspace", 0xCuLL, 1uLL, __stream);
  else
    CI::fprintf_cs(__stream, this[15], (CGColorSpace *)1);
  if (*((_BYTE *)this + 138))
  {
    result = fwrite("_tonemapped", 0xBuLL, 1uLL, __stream);
    v5 = *((float *)this + 35);
    if (v5 == 1.0)
    {
      v6 = "_to_sdr";
      v7 = 7;
      return fwrite(v6, v7, 1uLL, __stream);
    }
    if (v5 >= 1.0)
      return fprintf(__stream, "_to%.2f", v5);
  }
  else
  {
    fwrite("_to_", 4uLL, 1uLL, __stream);
    if (*((_BYTE *)this + 137))
    {
      v6 = "workingspace";
      v7 = 12;
      return fwrite(v6, v7, 1uLL, __stream);
    }
    return CI::fprintf_cs(__stream, this[16], (CGColorSpace *)1);
  }
  return result;
}

CI::Object *CI::ColorMatchImage::render_graph_core(uint64_t a1, CGColorSpace **a2, CI::Object *appended)
{
  unint64_t v6;
  CGColorSpace **v7;
  CGColorSpace *v8;
  CGColorSpace **v9;
  CGColorSpace *v10;
  BOOL v11;
  int v13;
  int v14;
  float v15;
  CMatrix *v16;
  double v17;
  CI::Object *v18;
  unsigned int *v19;
  float v20;
  unsigned __int8 v21;
  _BOOL4 v22;
  _BOOL4 v23;
  const void *Value;
  BOOL v25;
  CFStringRef *v26;
  CGColorSpace *v27;
  CGColorSpace *v28;
  BOOL v29;
  CI::Object *v31;
  CI::CurveNode *v32;
  CI::Object *v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  CI::SRGBNode *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  double v50;
  CI::ColorMatrixNode *v51;
  int v52;
  CMatrix *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  CI::Node *v63;
  _BOOL4 IsHDR;
  float v65;
  unsigned __int8 v66;
  _BOOL4 v67;
  int v68;
  const void *ConverterArray;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  CI::ColorMatrixNode *v79;
  double v80;
  CI::Object *v81;
  CI::PremultiplyNode *v82;
  CI::Object *v83;
  CFStringRef *v84;
  CI *v85;
  CGColorSpace *v86;
  char v87;
  CI::Object *v88;
  CI::CurveNode *v89;
  NSObject *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unsigned int v98;
  double v99[2];
  uint64_t v100;
  uint64_t v101;
  uint64_t (*v102)(uint64_t, uint64_t);
  void *v103;
  uint64_t *v104;
  double v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  double v122[26];
  uint64_t v123;
  uint64_t v124;
  uint64_t (*v125)(uint64_t);
  void *v126;
  uint64_t *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  uint64_t v139;
  __int128 v140;
  uint64_t v141;
  uint64_t v142;
  __int128 v143;
  uint64_t v144;
  uint64_t v145;
  __int128 v146;
  _QWORD v147[11];

  v147[9] = *MEMORY[0x1E0C80C00];
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 184))(a1);
  if (*(_BYTE *)(a1 + 136))
    v7 = a2 + 3;
  else
    v7 = (CGColorSpace **)(a1 + 120);
  v8 = *v7;
  if (*(_BYTE *)(a1 + 137))
    v9 = a2 + 3;
  else
    v9 = (CGColorSpace **)(a1 + 128);
  v10 = *v9;
  if (appended)
    appended = (CI::Object *)CI::Object::ref((uint64_t)appended);
  if (v8)
    v11 = v10 == 0;
  else
    v11 = 1;
  if (v11 || v8 == v10)
    return appended;
  v13 = *(_DWORD *)(a1 + 100);
  v14 = *(unsigned __int8 *)(a1 + 138);
  v15 = *(float *)(a1 + 140);
  CMatrix::CMatrix((CMatrix *)v122);
  v105 = 0.0;
  if (!CI::get_colorspace_gamma_and_matrix(v8, (CGColorSpace *)&v105, v122, v16))
  {
    if (CGColorSpaceGetModel(v8) == kCGColorSpaceModelMonochrome || CGColorSpaceGetModel(v8) == kCGColorSpaceModelRGB)
    {
      v20 = (*((float (**)(CGColorSpace **))*a2 + 19))(a2);
      if ((v21 & 1) == 0
      {
        CI::createConverterArrayFrom(CGColorSpace *,float,BOOL,float)::cache = (uint64_t)CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      }
      v22 = !CGColorSpaceIsHDR(v8);
      if (v20 == 2.0)
        v22 = 1;
      if (v14)
        v23 = 0;
      else
        v23 = v22;
      if (v23)
      {
        pthread_mutex_lock(&CI::createConverterArrayFrom(CGColorSpace *,float,BOOL,float)::mutex);
        Value = CFDictionaryGetValue((CFDictionaryRef)CI::createConverterArrayFrom(CGColorSpace *,float,BOOL,float)::cache, v8);
        pthread_mutex_unlock(&CI::createConverterArrayFrom(CGColorSpace *,float,BOOL,float)::mutex);
        if (Value)
        {
          CFRetain(Value);
LABEL_57:
          appended = CI::AppendConverterArray(a2, appended, v13, (CFArrayRef)Value, 0, (CI::Node *)v6);
          CFRelease(Value);
          goto LABEL_74;
        }
      }
      v98 = v6;
      if (CI::CI_EXTENDED_PCS(void)::didCheck != -1)
        dispatch_once(&CI::CI_EXTENDED_PCS(void)::didCheck, &__block_literal_global_88);
      if (CI::CI_EXTENDED_PCS(void)::v)
        v25 = v14 == 0;
      else
        v25 = 1;
      v26 = (CFStringRef *)MEMORY[0x1E0C9DA00];
      if (v25)
        v26 = (CFStringRef *)MEMORY[0x1E0C9D958];
      v27 = CGColorSpaceCreateWithName(*v26);
      Value = CI::createConverterArray(v8, v27, v28, v20, v15);
      if (Value)
        v29 = v23;
      else
        v29 = 0;
      if (v29)
      {
        pthread_mutex_lock(&CI::createConverterArrayFrom(CGColorSpace *,float,BOOL,float)::mutex);
        CFDictionaryAddValue((CFMutableDictionaryRef)CI::createConverterArrayFrom(CGColorSpace *,float,BOOL,float)::cache, v8, Value);
        pthread_mutex_unlock(&CI::createConverterArrayFrom(CGColorSpace *,float,BOOL,float)::mutex);
        CGColorSpaceRelease(v27);
        v6 = v98;
        goto LABEL_57;
      }
      CGColorSpaceRelease(v27);
      v6 = v98;
      if (Value)
        goto LABEL_57;
    }
    CI::snprintf_cs((CI *)&v123, (char *)0x100, v8, 0);
    v34 = ci_logger_render();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      CI::ColorMatchImage::render_graph_core((uint64_t)&v123, v34, v35, v36, v37, v38, v39, v40);
    goto LABEL_74;
  }
  v17 = v105;
  if (v105 == -1.0)
  {
    v18 = CI::PremultiplyNode::append_to_tree(appended, (CI::Node *)0xFFFFFFFFLL, v6);
    if (appended)
      CI::Object::unref(appended);
    if ((CI_INPUT_SRGB_TEXTURES() & 0xFFFFFFFD) != 0)
    {
      v139 = 0;
      *(_QWORD *)&v140 = &v139;
      *((_QWORD *)&v140 + 1) = 0x2000000000;
      v141 = 0;
      v141 = (*(uint64_t (**)(CI::Object *))(*(_QWORD *)v18 + 400))(v18);
      v19 = *(unsigned int **)(v140 + 24);
      if (!v19)
      {
        v100 = MEMORY[0x1E0C809B0];
        v101 = 0x40000000;
        v102 = ___ZN2CIL19AppendColorSpaceSrcEPNS_7ContextEPNS_4NodeENS_10ImageIndexEP12CGColorSpacebfb_block_invoke;
        v103 = &unk_1E2EC0C88;
        v104 = &v139;
        v123 = MEMORY[0x1E0C809B0];
        v124 = 0x40000000;
        v125 = ___ZN2CI4Node27traverse_preorder_stoppableEU13block_pointerFbPS0_E_block_invoke;
        v126 = &unk_1E2EC70B8;
        v127 = &v100;
        CI::GraphObject::traverse_preorder_stoppable((uint64_t)v18, 0, 0, 0, (uint64_t)&v123);
        v19 = *(unsigned int **)(v140 + 24);
        if (!v19)
          goto LABEL_62;
      }
      if ((v6 & (*((unsigned int (**)(CGColorSpace **, _QWORD, uint64_t))*a2 + 73))(a2, *v19, 3)) == 1)
      {
        *(_BYTE *)(*(_QWORD *)(v140 + 24) + 4) = 1;
      }
      else
      {
LABEL_62:
        v41 = CI::SRGBNode::append_to_tree(v18, (CI::Node *)0xFFFFFFFFLL, v6);
        CI::Object::unref(v18);
        v18 = v41;
      }
      _Block_object_dispose(&v139, 8);
      v33 = v18;
    }
    else
    {
      v33 = CI::SRGBNode::append_to_tree(v18, (CI::Node *)0xFFFFFFFFLL, v6);
      if (v18)
        CI::Object::unref(v18);
    }
    v32 = v33;
LABEL_65:
    appended = CI::PremultiplyNode::append_to_tree(v32, (CI::Node *)1, v6);
    if (v33)
      CI::Object::unref(v33);
    goto LABEL_67;
  }
  if (v105 != 0.0 && v105 != 1.0)
  {
    v31 = CI::PremultiplyNode::append_to_tree(appended, (CI::Node *)0xFFFFFFFFLL, v6);
    if (appended)
      CI::Object::unref(appended);
    v32 = CI::CurveNode::append_to_tree_and_unref(v31, (CI::Node *)v6, v17);
    v33 = v32;
    goto LABEL_65;
  }
LABEL_67:
  if (CMatrix::columnCount((CMatrix *)v122) == 1)
  {
    CMatrix::CMatrix((CMatrix *)&v123, (const CMatrix *)v122);
    v141 = 0;
    v144 = 0;
    memset(&v147[4], 0, 40);
    memset(v147, 0, 32);
    v146 = 0u;
    v143 = 0u;
    v140 = 0u;
    v139 = 0x3FF0000000000000;
    v142 = 0x3FF0000000000000;
    v145 = 0x3FF0000000000000;
    v147[4] = 0x3FF0000000000000;
  }
  else
  {
    if ((CMatrix::isNearIdentity((CMatrix *)v122, 0.0001) & 1) != 0)
      goto LABEL_74;
    CMatrix::CMatrix((CMatrix *)&v123, (const CMatrix *)v122);
    v120 = CMatrix::operator[]((unsigned int *)&v123, 0);
    v121 = v42;
    v139 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v120, 0);
    v118 = CMatrix::operator[]((unsigned int *)&v123, 1u);
    v119 = v43;
    *(_QWORD *)&v140 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v118, 0);
    v116 = CMatrix::operator[]((unsigned int *)&v123, 2u);
    v117 = v44;
    *((_QWORD *)&v140 + 1) = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v116, 0);
    v141 = 0;
    v114 = CMatrix::operator[]((unsigned int *)&v123, 0);
    v115 = v45;
    v142 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v114, 1u);
    v112 = CMatrix::operator[]((unsigned int *)&v123, 1u);
    v113 = v46;
    *(_QWORD *)&v143 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v112, 1u);
    v110 = CMatrix::operator[]((unsigned int *)&v123, 2u);
    v111 = v47;
    *((_QWORD *)&v143 + 1) = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v110, 1u);
    v144 = 0;
    v108 = CMatrix::operator[]((unsigned int *)&v123, 0);
    v109 = v48;
    v145 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v108, 2u);
    v106 = CMatrix::operator[]((unsigned int *)&v123, 1u);
    v107 = v49;
    *(_QWORD *)&v146 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v106, 2u);
    *(_QWORD *)&v99[0] = CMatrix::operator[]((unsigned int *)&v123, 2u);
    v99[1] = v50;
    *((_QWORD *)&v146 + 1) = *(_QWORD *)CMatrixRow::operator[]((uint64_t)v99, 2u);
    memset(v147, 0, 24);
    *(_OWORD *)&v147[3] = unk_19249BC78;
    memset(&v147[5], 0, 32);
  }
  v51 = CI::ColorMatrixNode::append_to_tree(appended, (CI::Node *)&v139, (const double (*)[4])v6);
  if (appended)
    CI::Object::unref(appended);
  appended = v51;
LABEL_74:
  v52 = *(_DWORD *)(a1 + 100);
  CMatrix::CMatrix((CMatrix *)v122);
  v99[0] = 0.0;
  if (!CI::get_colorspace_gamma_and_matrix(v10, (CGColorSpace *)v99, v122, v53))
  {
    if (CGColorSpaceGetModel(v10) == kCGColorSpaceModelMonochrome || CGColorSpaceGetModel(v10) == kCGColorSpaceModelRGB)
    {
      IsHDR = CGColorSpaceIsHDR(v10);
      v65 = (*((float (**)(CGColorSpace **))*a2 + 19))(a2);
      if ((v66 & 1) == 0
      {
        CI::createConverterArrayTo(CGColorSpace *,float)::cache = (uint64_t)CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      }
      v67 = !CGColorSpaceIsHDR(v10);
      v68 = v65 == 2.0 || v67;
      if (v68 == 1)
      {
        pthread_mutex_lock(&CI::createConverterArrayTo(CGColorSpace *,float)::mutex);
        ConverterArray = CFDictionaryGetValue((CFDictionaryRef)CI::createConverterArrayTo(CGColorSpace *,float)::cache, v10);
        pthread_mutex_unlock(&CI::createConverterArrayTo(CGColorSpace *,float)::mutex);
        if (ConverterArray)
        {
          CFRetain(ConverterArray);
LABEL_116:
          appended = CI::AppendConverterArray(a2, appended, v52, (CFArrayRef)ConverterArray, IsHDR, (CI::Node *)v6);
          CFRelease(ConverterArray);
          return appended;
        }
      }
      if (CI::CI_EXTENDED_PCS(void)::didCheck != -1)
        dispatch_once(&CI::CI_EXTENDED_PCS(void)::didCheck, &__block_literal_global_88);
      if (CI::CI_EXTENDED_PCS(void)::v)
        v84 = (CFStringRef *)MEMORY[0x1E0C9D958];
      else
        v84 = (CFStringRef *)MEMORY[0x1E0C9DA00];
      v85 = CGColorSpaceCreateWithName(*v84);
      ConverterArray = CI::createConverterArray(v85, v10, v86, v65, 0.0);
      if (ConverterArray)
        v87 = v68;
      else
        v87 = 0;
      if ((v87 & 1) != 0)
      {
        pthread_mutex_lock(&CI::createConverterArrayTo(CGColorSpace *,float)::mutex);
        CFDictionaryAddValue((CFMutableDictionaryRef)CI::createConverterArrayTo(CGColorSpace *,float)::cache, v10, ConverterArray);
        pthread_mutex_unlock(&CI::createConverterArrayTo(CGColorSpace *,float)::mutex);
        CGColorSpaceRelease(v85);
        goto LABEL_116;
      }
      CGColorSpaceRelease(v85);
      if (ConverterArray)
        goto LABEL_116;
    }
    CI::snprintf_cs((CI *)&v123, (char *)0x100, v10, 0);
    v90 = ci_logger_render();
    if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
      CI::ColorMatchImage::render_graph_core((uint64_t)&v123, v90, v91, v92, v93, v94, v95, v96);
    return appended;
  }
  if (CMatrix::columnCount((CMatrix *)v122) == 1)
  {
    v139 = CMatrix::operator[]((unsigned int *)v122, 0);
    *(_QWORD *)&v140 = v54;
    v123 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v139, 0);
    v100 = CMatrix::operator[]((unsigned int *)v122, 1u);
    v101 = v55;
    v124 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v100, 0);
    v120 = CMatrix::operator[]((unsigned int *)v122, 2u);
    v121 = v56;
    v125 = *(uint64_t (**)(uint64_t))CMatrixRow::operator[]((uint64_t)&v120, 0);
    v126 = 0;
    v118 = CMatrix::operator[]((unsigned int *)v122, 0);
    v119 = v57;
    v127 = *(uint64_t **)CMatrixRow::operator[]((uint64_t)&v118, 0);
    v116 = CMatrix::operator[]((unsigned int *)v122, 1u);
    v117 = v58;
    v128 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v116, 0);
    v114 = CMatrix::operator[]((unsigned int *)v122, 2u);
    v115 = v59;
    v129 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v114, 0);
    v130 = 0;
    v112 = CMatrix::operator[]((unsigned int *)v122, 0);
    v113 = v60;
    v131 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v112, 0);
    v110 = CMatrix::operator[]((unsigned int *)v122, 1u);
    v111 = v61;
    v132 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v110, 0);
    v108 = CMatrix::operator[]((unsigned int *)v122, 2u);
    v109 = v62;
    v133 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v108, 0);
    v134 = 0;
    v135 = xmmword_19249BC68;
    v136 = unk_19249BC78;
    v137 = 0u;
    v138 = 0u;
    v63 = (CI::Node *)&v123;
  }
  else
  {
    if ((CMatrix::isNearIdentity((CMatrix *)v122, 0.0001) & 1) != 0)
      goto LABEL_91;
    CMatrix::inverse((CMatrix *)v122, (unsigned int *)&v123);
    v100 = CMatrix::operator[]((unsigned int *)&v123, 0);
    v101 = v70;
    v139 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v100, 0);
    v120 = CMatrix::operator[]((unsigned int *)&v123, 1u);
    v121 = v71;
    *(_QWORD *)&v140 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v120, 0);
    v118 = CMatrix::operator[]((unsigned int *)&v123, 2u);
    v119 = v72;
    *((_QWORD *)&v140 + 1) = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v118, 0);
    v141 = 0;
    v116 = CMatrix::operator[]((unsigned int *)&v123, 0);
    v117 = v73;
    v142 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v116, 1u);
    v114 = CMatrix::operator[]((unsigned int *)&v123, 1u);
    v115 = v74;
    *(_QWORD *)&v143 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v114, 1u);
    v112 = CMatrix::operator[]((unsigned int *)&v123, 2u);
    v113 = v75;
    *((_QWORD *)&v143 + 1) = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v112, 1u);
    v144 = 0;
    v110 = CMatrix::operator[]((unsigned int *)&v123, 0);
    v111 = v76;
    v145 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v110, 2u);
    v108 = CMatrix::operator[]((unsigned int *)&v123, 1u);
    v109 = v77;
    *(_QWORD *)&v146 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v108, 2u);
    v106 = CMatrix::operator[]((unsigned int *)&v123, 2u);
    v107 = v78;
    *((_QWORD *)&v146 + 1) = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v106, 2u);
    memset(v147, 0, 24);
    *(_OWORD *)&v147[3] = unk_19249BC78;
    memset(&v147[5], 0, 32);
    v63 = (CI::Node *)&v139;
  }
  v79 = CI::ColorMatrixNode::append_to_tree(appended, v63, (const double (*)[4])v6);
  if (appended)
    CI::Object::unref(appended);
  appended = v79;
LABEL_91:
  v80 = v99[0];
  if (v99[0] == -1.0)
  {
    v81 = CI::PremultiplyNode::append_to_tree(appended, (CI::Node *)0xFFFFFFFFLL, v6);
    if (appended)
      CI::Object::unref(appended);
    v82 = CI::SRGBNode::append_to_tree(v81, (CI::Node *)1, v6);
    if (v81)
      CI::Object::unref(v81);
    appended = CI::PremultiplyNode::append_to_tree(v82, (CI::Node *)1, v6);
    if (v82)
    {
      v83 = v82;
LABEL_114:
      CI::Object::unref(v83);
    }
  }
  else if (v99[0] != 0.0 && v99[0] != 1.0)
  {
    v88 = CI::PremultiplyNode::append_to_tree(appended, (CI::Node *)0xFFFFFFFFLL, v6);
    if (appended)
      CI::Object::unref(appended);
    v89 = CI::CurveNode::append_to_tree_and_unref(v88, (CI::Node *)v6, 1.0 / v80);
    appended = CI::PremultiplyNode::append_to_tree(v89, (CI::Node *)1, v6);
    if (v89)
    {
      v83 = v89;
      goto LABEL_114;
    }
  }
  return appended;
}

void CI::match_color(float32x2_t *this, CI *a2, CGColorSpace *a3, CGColorSpace *a4)
{
  CMatrix *v7;
  int colorspace_gamma_and_matrix;
  CMatrix *v9;
  char v10;
  int v11;
  char v12;
  long double v13;
  float v14;
  float v15;
  double v16;
  double v17;
  float v18;
  long double v19;
  float32_t v20;
  NSObject *v21;
  double v22;
  double v23;
  double v24;
  long double v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  double v32;
  double v33;
  float32_t v34;
  float32_t v35;
  float32_t v36;
  _DWORD v37[52];
  uint64_t v38;
  uint64_t v39;
  double v40;
  double v41;
  double v42[26];
  double v43[26];
  float64x2_t v44;
  double v45[30];
  float64x2_t v46;
  double v47;
  uint64_t v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  if (a2 == a3 || !a2 || !a3)
    return;
  CMatrix::CMatrix((CMatrix *)v43);
  CMatrix::CMatrix((CMatrix *)v42);
  v40 = 1.0;
  v41 = 1.0;
  colorspace_gamma_and_matrix = CI::get_colorspace_gamma_and_matrix(a2, (CGColorSpace *)&v41, v43, v7);
  v10 = CI::get_colorspace_gamma_and_matrix(a3, (CGColorSpace *)&v40, v42, v9);
  if (colorspace_gamma_and_matrix && (v10 & 1) != 0)
  {
    CMatrix::inverse((CMatrix *)v42, (unsigned int *)&v44);
    CMatrix::operator*((unsigned int *)v43, &v44, (unsigned int *)&v46);
    v11 = CMatrix::isNearIdentity((CMatrix *)&v46, 0.001);
    v12 = v11;
    v13 = v41;
    if (v11 && v41 == v40)
      return;
    v15 = this->f32[0];
    v14 = this->f32[1];
    v16 = this->f32[0];
    v17 = v14;
    v18 = this[1].f32[0];
    v19 = v18;
    if (v41 == -1.0)
    {
      if (v16 >= 0.04045)
        v16 = pow(v16 * 0.947867299 + 0.0521327014, 2.4);
      else
        v16 = v16 * 0.0773993808;
      if (v17 >= 0.04045)
        v17 = pow(v17 * 0.947867299 + 0.0521327014, 2.4);
      else
        v17 = v17 * 0.0773993808;
      if (v19 < 0.04045)
      {
        v19 = v19 * 0.0773993808;
        goto LABEL_34;
      }
      v24 = v19 * 0.947867299 + 0.0521327014;
      v25 = 2.4;
    }
    else
    {
      if (v41 == 0.0 || v41 == 1.0)
        goto LABEL_34;
      v22 = pow(this->f32[0], v41);
      if (v15 >= 0.0)
        v16 = v22;
      else
        v16 = 0.0;
      v23 = pow(v14, v13);
      if (v14 >= 0.0)
        v17 = v23;
      else
        v17 = 0.0;
      if (v18 < 0.0)
      {
        v19 = 0.0;
LABEL_34:
        if ((v12 & 1) == 0)
        {
          CMatrix::transpose((CMatrix *)&v46, (unsigned int *)&v38);
          CMatrix::CMatrix((CMatrix *)v37, 3u, 1u, v16, v26, v27, *(_QWORD *)&v17, *(_QWORD *)&v19);
          CMatrix::operator*((unsigned int *)&v38, v37, (unsigned int *)&v44);
          v38 = CMatrix::operator[]((unsigned int *)&v44, 0);
          v39 = v28;
          v16 = *(double *)CMatrixRow::operator[]((uint64_t)&v38, 0);
          v38 = CMatrix::operator[]((unsigned int *)&v44, 1u);
          v39 = v29;
          v17 = *(double *)CMatrixRow::operator[]((uint64_t)&v38, 0);
          v38 = CMatrix::operator[]((unsigned int *)&v44, 2u);
          v39 = v30;
          v19 = *(double *)CMatrixRow::operator[]((uint64_t)&v38, 0);
        }
        v31 = v40;
        if (v40 == -1.0)
        {
          if (v16 >= 0.0031308)
            v32 = pow(v16, 0.4166667) * 1.055 + -0.055;
          else
            v32 = v16 * 12.92;
          if (v17 >= 0.0031308)
            v33 = pow(v17, 0.4166667) * 1.055 + -0.055;
          else
            v33 = v17 * 12.92;
          if (v19 >= 0.0031308)
            v19 = pow(v19, 0.4166667) * 1.055 + -0.055;
          else
            v19 = v19 * 12.92;
        }
        else if (v40 == 0.0 || v40 == 1.0)
        {
          v32 = v16;
          v33 = v17;
        }
        else
        {
          v33 = 0.0;
          v32 = 0.0;
          if (v16 >= 0.0)
            v32 = pow(v16, 1.0 / v40);
          if (v17 >= 0.0)
            v33 = pow(v17, 1.0 / v31);
          if (v19 >= 0.0)
            v19 = pow(v19, 1.0 / v31);
          else
            v19 = 0.0;
        }
        v34 = v32;
        v35 = v33;
        this->f32[0] = v34;
        this->f32[1] = v35;
        v36 = v19;
        this[1].f32[0] = v36;
        return;
      }
      v24 = v18;
      v25 = v13;
    }
    v19 = pow(v24, v25);
    goto LABEL_34;
  }
  v46 = vcvtq_f64_f32(*this);
  v47 = this[1].f32[0];
  v48 = 0x3FF0000000000000;
  v44 = 0u;
  *(_OWORD *)v45 = 0u;
  MEMORY[0x194024BA0](a3, 0);
  if (CGColorTransformConvertColorComponents())
  {
    *this = vcvt_f32_f64(v44);
    v20 = v45[0];
    this[1].f32[0] = v20;
    CGColorTransformRelease();
  }
  else
  {
    CGColorTransformRelease();
    CI::snprintf_cs((CI *)&v46, (char *)0x100, a2, 0);
    CI::snprintf_cs((CI *)&v44, (char *)0x100, a3, 0);
    v21 = ci_logger_render();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      CI::match_color((uint64_t)&v46, (uint64_t)&v44, v21);
  }
}

uint64_t CI::get_colorspace_gamma_and_matrix(CI *this, CGColorSpace *a2, double *a3, CMatrix *a4)
{
  uint64_t v7;
  uint64_t v8;
  int Type;
  unsigned __int8 v10;
  unsigned __int8 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  double v27;
  uint64_t v28;
  double v29;
  uint64_t v30;
  double v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  double v35;
  uint64_t v36;
  double *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  double v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  unsigned __int8 v64;
  unsigned __int8 v65;
  unsigned __int8 v66;
  _QWORD v68[2];
  _QWORD v69[2];
  _QWORD v70[2];
  _QWORD v71[2];
  _DWORD v72[52];
  _DWORD v73[52];
  _QWORD v74[26];
  double v75[34];
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  _BYTE v81[208];
  _BYTE v82[208];
  unsigned int v83[52];
  unsigned int v84[52];
  _BYTE v85[208];
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int v96[52];
  unsigned int v97[52];
  unsigned int v98[52];
  unsigned int v99[52];
  _OWORD v100[3];
  uint64_t v101;

  Type = CGColorSpaceGetType();
  if ((v10 & 1) == 0
  {
    CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::srgblin_cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA00]);
  }
  if ((v11 & 1) == 0
  {
    CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::srgbextlin_cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D958]);
  }
  CMatrix::CMatrix((CMatrix *)v85, 3u, 1u, 1.0, v7, v8, 0x3FF0000000000000, 0x3FF0000000000000);
  CMatrix::CMatrix((CMatrix *)v84, 3u, 1u, 0.222488, v12, v13, 0x3FE6F09FA54C5543, 0x3FAF07FFA8C22B89);
  CMatrix::identityMatrix((CMatrix *)3, v83);
  CMatrix::CMatrix((CMatrix *)v82, 3u, 3u, 0.436066, v14, v15, 0x3FCC7A7C9DE05037, 0x3F8C7FFDE7210BE9, 0x3FD8A63F9A49C2C2, 0x3FE6F09FA54C5543, 0x3FB8D9FFBB36A253, 0x3FC24FFC9795B35BLL, 0x3FAF07FFA8C22B89, 0x3FE6D9DFDAC68A93);
  if ((CI *)CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::srgblin_cs == this
    || (CI *)CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::srgbextlin_cs == this)
  {
    CMatrix::operator=((unsigned int *)a3, v83);
    *(_QWORD *)a2 = 0x3FF0000000000000;
  }
  else
  {
    v18 = 0;
    switch(Type)
    {
      case 0:
        goto LABEL_6;
      case 1:
        goto LABEL_17;
      case 3:
        v101 = 0;
        memset(v100, 0, sizeof(v100));
        CGColorSpaceGetCalibratedGrayData();
        *(_QWORD *)a2 = v101;
        CMatrix::operator=((unsigned int *)a3, v84);
        return 1;
      case 4:
        v18 = 1;
        CMatrix::CMatrix((CMatrix *)v81, 3u, 1u, 0.9642, v16, v17, 0x3FF0000000000000, 0x3FEA6594AF4F0D84);
        v80 = 0u;
        v79 = 0u;
        v78 = 0u;
        v77 = 0u;
        v76 = 0u;
        memset(&v75[26], 0, 64);
        CGColorSpaceGetCalibratedRGBData();
        *(_QWORD *)a2 = 0;
        CMatrix::CMatrix((CMatrix *)v75, 3u, 1u, v75[26], v20, v21, *(_QWORD *)&v75[27], 0);
        CMatrix::CMatrix((CMatrix *)v73, (const CMatrix *)v75);
        CMatrix::CMatrix((CMatrix *)v72, (const CMatrix *)v81);
        CMatrix::CMatrix((CMatrix *)v100, 3u, 3u, 0.8951, v22, v23, 0x3FD10CB295E9E1B1, 0xBFC4A8C154C985F0, 0xBFE801A36E2EB1C4, 0x3FFB6A7EF9DB22D1, 0x3FA2CA57A786C227, 0x3FA3EAB367A0F909, 0xBFB189374BC6A7F0, 0x3FF0793DD97F62B7);
        CMatrix::CMatrix((CMatrix *)v99, 3u, 3u, 0.986993, v24, v25, 0xBFC2D2AA5C5F7C67, 0x3FC479AAE6C8F755, 0x3FDBAAE297396D09, 0x3FE09667B5F1BEF5, 0x3FA93CAB81F969E4, 0xBF8177A7008A697BLL, 0x3FA480841EDE1199, 0x3FEEFDD872F33CA3);
        CMatrix::operator*((unsigned int *)v100, v73, v98);
        CMatrix::operator*((unsigned int *)v100, v72, v97);
        v86 = CMatrix::operator[](v97, 0);
        v87 = v26;
        v27 = *(double *)CMatrixRow::operator[]((uint64_t)&v86, 0);
        v74[0] = CMatrix::operator[](v98, 0);
        v74[1] = v28;
        v29 = v27 / *(double *)CMatrixRow::operator[]((uint64_t)v74, 0);
        v94 = CMatrix::operator[](v97, 1u);
        v95 = v30;
        v31 = *(double *)CMatrixRow::operator[]((uint64_t)&v94, 0);
        v92 = CMatrix::operator[](v98, 1u);
        v93 = v32;
        *(double *)&v33 = v31 / *(double *)CMatrixRow::operator[]((uint64_t)&v92, 0);
        v90 = CMatrix::operator[](v97, 2u);
        v91 = v34;
        v35 = *(double *)CMatrixRow::operator[]((uint64_t)&v90, 0);
        v88 = CMatrix::operator[](v98, 2u);
        v89 = v36;
        v37 = (double *)CMatrixRow::operator[]((uint64_t)&v88, 0);
        CMatrix::diagonalMatrix((CMatrix *)3, v29, v96, v33, v35 / *v37);
        CMatrix::operator*(v99, v96, (unsigned int *)&v86);
        CMatrix::operator*((unsigned int *)&v86, v100, (unsigned int *)v74);
        CMatrix::CMatrix((CMatrix *)v99, 3u, 1u, *((double *)&v76 + 1), v38, v39, v77);
        CMatrix::operator*((unsigned int *)v74, v99, (unsigned int *)v100);
        CMatrix::CMatrix((CMatrix *)v98, 3u, 1u, *(double *)&v78, v40, v41, *((_QWORD *)&v78 + 1), (_QWORD)v79);
        CMatrix::operator*((unsigned int *)v74, v98, v99);
        CMatrix::CMatrix((CMatrix *)v97, 3u, 1u, *((double *)&v79 + 1), v42, v43, v80);
        CMatrix::operator*((unsigned int *)v74, v97, v98);
        CMatrix::inverse((CMatrix *)v82, v97);
        v86 = CMatrix::operator[]((unsigned int *)v100, 0);
        v87 = v44;
        v45 = *(double *)CMatrixRow::operator[]((uint64_t)&v86, 0);
        v94 = CMatrix::operator[]((unsigned int *)v100, 1u);
        v95 = v46;
        v47 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v94, 0);
        v92 = CMatrix::operator[]((unsigned int *)v100, 2u);
        v93 = v48;
        v49 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v92, 0);
        v90 = CMatrix::operator[](v99, 0);
        v91 = v50;
        v51 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v90, 0);
        v88 = CMatrix::operator[](v99, 1u);
        v89 = v52;
        v53 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)&v88, 0);
        v71[0] = CMatrix::operator[](v99, 2u);
        v71[1] = v54;
        v55 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)v71, 0);
        v70[0] = CMatrix::operator[](v98, 0);
        v70[1] = v56;
        v57 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)v70, 0);
        v69[0] = CMatrix::operator[](v98, 1u);
        v69[1] = v58;
        v59 = *(_QWORD *)CMatrixRow::operator[]((uint64_t)v69, 0);
        v68[0] = CMatrix::operator[](v98, 2u);
        v68[1] = v60;
        v61 = CMatrixRow::operator[]((uint64_t)v68, 0);
        CMatrix::CMatrix((CMatrix *)v96, 3u, 3u, v45, v62, v63, v47, v49, v51, v53, v55, v57, v59, *v61);
        CMatrix::operator*(v96, v97, (unsigned int *)&v86);
        CMatrix::operator=((unsigned int *)a3, (unsigned int *)&v86);
        return v18;
      case 6:
        if ((v64 & 1) == 0
        {
          CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::srgb_cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
        }
        if ((v65 & 1) == 0
        {
          CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::esrgb_cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D960]);
        }
        if ((v66 & 1) == 0
        {
          CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::ggray_cs = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
        }
        if ((CI *)CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::srgb_cs == this
          || (CI *)CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::esrgb_cs == this)
        {
LABEL_17:
          v19 = v83;
        }
        else
        {
          if ((CI *)CI::get_colorspace_gamma_and_matrix(CGColorSpace *,double *,CMatrix *)::ggray_cs != this)
            return 0;
LABEL_6:
          v19 = v84;
        }
        CMatrix::operator=((unsigned int *)a3, v19);
        *(_QWORD *)a2 = 0xBFF0000000000000;
        break;
      default:
        return v18;
    }
  }
  return 1;
}

uint64_t CI::ColorMatchImage::print_for_graphviz(uint64_t a1, FILE *a2, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t result;
  float v8;
  const char *v9;
  size_t v10;

  v6 = 10;
  if (a4)
    v6 = 32;
  fprintf(a2, "colormatch%c", v6);
  if (*(_BYTE *)(a1 + 136))
    fwrite("workingspace", 0xCuLL, 1uLL, a2);
  else
    CI::fprintf_cs(a2, *(__sFILE **)(a1 + 120), 0);
  if (*(_BYTE *)(a1 + 138))
  {
    result = fwrite("_tonemapped", 0xBuLL, 1uLL, a2);
    v8 = *(float *)(a1 + 140);
    if (v8 == 1.0)
    {
      v9 = "_to_sdr";
      v10 = 7;
      return fwrite(v9, v10, 1uLL, a2);
    }
    if (v8 >= 1.0)
      return fprintf(a2, "_to%.2f", v8);
  }
  else
  {
    fwrite("_to_", 4uLL, 1uLL, a2);
    if (*(_BYTE *)(a1 + 137))
    {
      v9 = "workingspace";
      v10 = 12;
      return fwrite(v9, v10, 1uLL, a2);
    }
    return CI::fprintf_cs(a2, *(__sFILE **)(a1 + 128), 0);
  }
  return result;
}

float CI::TagColorSpaceImage::headroom(CI::TagColorSpaceImage *this)
{
  float v2;
  CGColorSpace *v3;
  float v4;

  v2 = (*(float (**)(_QWORD))(**((_QWORD **)this + 13) + 232))(*((_QWORD *)this + 13));
  if (v2 > 1.0)
    return v2;
  v3 = (CGColorSpace *)*((_QWORD *)this + 15);
  if (!v3)
    return v2;
  v4 = 4.9261;
  if (!CGColorSpaceIsPQBased(v3) && !CGColorSpaceIsHLGBased(*((CGColorSpaceRef *)this + 15)))
    return v2;
  return v4;
}

void CI::TagColorSpaceImage::~TagColorSpaceImage(CI::TagColorSpaceImage *this)
{
  unsigned int v2;

  *(_QWORD *)this = &off_1E2EBDD70;
  *((_QWORD *)this + 14) = &unk_1E2EBDEC8;
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 15));
  *((_QWORD *)this + 14) = off_1E2EBBA10;
  *((_QWORD *)this + 15) = 0;
  do
    v2 = __ldaxr(&dword_1ECF872F0[22]);
  while (__stlxr(v2 - 1, &dword_1ECF872F0[22]));
  CI::ImageWithChild::~ImageWithChild(this);
}

{
  unsigned int v2;

  *(_QWORD *)this = &off_1E2EBDD70;
  *((_QWORD *)this + 14) = &unk_1E2EBDEC8;
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 15));
  *((_QWORD *)this + 14) = off_1E2EBBA10;
  *((_QWORD *)this + 15) = 0;
  do
    v2 = __ldaxr(&dword_1ECF872F0[22]);
  while (__stlxr(v2 - 1, &dword_1ECF872F0[22]));
  CI::ImageWithChild::~ImageWithChild(this);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::TagColorSpaceImage::type(CI::TagColorSpaceImage *this)
{
  return 24;
}

uint64_t CI::TagColorSpaceImage::shape_for_graphviz(CI::TagColorSpaceImage *this)
{
  return 2;
}

uint64_t CI::TagColorSpaceImage::color_for_graphviz(CI::TagColorSpaceImage *this)
{
  return 4;
}

void CI::TagColorSpaceImage::add_args_to_hash(uint64_t a1, CI::XXHashHelper *this)
{
  CI::XXHashHelper::add(this, *(CGColorSpaceRef *)(a1 + 120));
}

uint64_t CI::TagColorSpaceImage::print_for_graph_core(__sFILE **this, __sFILE *__stream)
{
  fwrite("tagcolorspace ", 0xEuLL, 1uLL, __stream);
  return CI::fprintf_cs(__stream, this[15], (CGColorSpace *)1);
}

uint64_t CI::TagColorSpaceImage::print_for_graphviz(uint64_t a1, FILE *a2, uint64_t a3, int a4)
{
  uint64_t v6;

  v6 = 10;
  if (a4)
    v6 = 32;
  fprintf(a2, "tagcolorspace%c", v6);
  return CI::fprintf_cs(a2, *(__sFILE **)(a1 + 120), (CGColorSpace *)1);
}

uint64_t CI::TagColorSpaceImage::colorspace(CI::TagColorSpaceImage *this)
{
  return *((_QWORD *)this + 15);
}

uint64_t CI::TagColorSpaceImage::baseColorspace(CI::TagColorSpaceImage *this)
{
  return *((_QWORD *)this + 15);
}

uint64_t CI::TagColorSpaceImage::render_graph_core(int a1, int a2, CI::Object *this)
{
  if (this)
    return CI::Object::ref((uint64_t)this);
  else
    return 0;
}

uint64_t `non-virtual thunk to'CI::TagColorSpaceImage::type(CI::TagColorSpaceImage *this)
{
  return 24;
}

void `non-virtual thunk to'CI::TagColorSpaceImage::~TagColorSpaceImage(CI::TagColorSpaceImage *this)
{
  CI::ImageWithChild *v2;
  unsigned int v3;

  *((_QWORD *)this - 14) = &off_1E2EBDD70;
  v2 = (CI::TagColorSpaceImage *)((char *)this - 112);
  *(_QWORD *)this = &unk_1E2EBDEC8;
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 1));
  *(_QWORD *)this = off_1E2EBBA10;
  *((_QWORD *)this + 1) = 0;
  do
    v3 = __ldaxr(&dword_1ECF872F0[22]);
  while (__stlxr(v3 - 1, &dword_1ECF872F0[22]));
  CI::ImageWithChild::~ImageWithChild(v2);
}

{
  CI::TagColorSpaceImage::~TagColorSpaceImage((CI::TagColorSpaceImage *)((char *)this - 112));
}

uint64_t CI::ColorMatchImage::shape_for_graphviz(CI::ColorMatchImage *this)
{
  return 2;
}

uint64_t CI::ColorMatchImage::color_for_graphviz(CI::ColorMatchImage *this)
{
  return 4;
}

uint64_t CI::ColorMatchImage::add_args_to_hash(uint64_t a1, CI::XXHashHelper *this)
{
  int __src;
  int v6;

  CI::XXHashHelper::add(this, *(CGColorSpaceRef *)(a1 + 120));
  CI::XXHashHelper::add(this, *(CGColorSpaceRef *)(a1 + 128));
  __src = *(unsigned __int8 *)(a1 + 136);
  XXH64_update((uint64_t)this, (char *)&__src, 4uLL);
  v6 = *(unsigned __int8 *)(a1 + 137);
  return XXH64_update((uint64_t)this, (char *)&v6, 4uLL);
}

uint64_t CI::ColorMatchImage::baseColorspace(CI::ColorMatchImage *this)
{
  if (*((_BYTE *)this + 138))
    return 0;
  else
    return (*(uint64_t (**)(CI::ColorMatchImage *))(*(_QWORD *)this + 240))(this);
}

uint64_t `non-virtual thunk to'CI::ColorMatchImage::type(CI::ColorMatchImage *this)
{
  return 4;
}

uint64_t ___ZN2CIL19AppendColorSpaceSrcEPNS_7ContextEPNS_4NodeENS_10ImageIndexEP12CGColorSpacebfb_block_invoke(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2) == 1
    && ((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 248))(a2, 3) & 1) != 0)
  {
    return 0;
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 400))(a2);
  return 1;
}

CI::CurveNode *CI::CurveNode::append_to_tree_and_unref(CI::CurveNode *this, CI::Node *a2, double a3)
{
  CI::CurveNode *v4;

  v4 = CI::CurveNode::append_to_tree(this, a2, a3, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  if (this)
    CI::Object::unref(this);
  return v4;
}

CI::ClampToZeroToOneNode *CI::AppendConverterArray(_QWORD *a1, CI::Object *a2, int a3, CFArrayRef theArray, int a5, CI::Node *a6)
{
  const __CFArray *v7;
  CFIndex v9;
  const void *ValueAtIndex;
  char Properties;
  CFTypeID v12;
  int v13;
  uint64_t v14;
  float v15;
  __int128 v16;
  int v17;
  CI::Object *v18;
  CI::CurveNode *v19;
  double v20;
  CI::CurveNode *v21;
  CFTypeID v22;
  uint64_t v23;
  float32x4_t v24;
  float64x2_t *v25;
  uint64_t v26;
  uint64_t i;
  uint64_t j;
  CI::ColorMatrixNode *v29;
  CFTypeID v30;
  CI::Object *v31;
  uint64_t v32;
  uint64_t v33;
  CI::Vector *v34;
  __n128 v35;
  CI::Vector *v36;
  __n64 v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  char v45;
  void (***v46)(CI::ColorKernel *__hidden);
  NSObject *v47;
  CI::CurveNode *v48;
  CI::SRGBNode *v49;
  uint64_t v50;
  CI::SRGBNode *v51;
  uint64_t v52;
  uint64_t v53;
  BOOL v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  CFStringRef v58;
  uint64_t v59;
  uint64_t v60;
  __IOSurface *SurfaceFromCache;
  CI::Object *v62;
  _QWORD *v63;
  CI::Vector *v64;
  double v65;
  float v66;
  double v67;
  double v68;
  double v69;
  double v70;
  double v71;
  double v72;
  double v73;
  char v74;
  void (***v75)(CI::ColorKernel *__hidden);
  CI::SerialObjectPtrArray *v76;
  CGFloat v77;
  CGFloat v78;
  CGFloat v79;
  CGFloat v80;
  CI::Object *v81;
  CI::SerialObjectPtrArray *v82;
  double v83;
  double v84;
  double v85;
  double v86;
  double v87;
  double v88;
  double v89;
  CI::Object *v90;
  double v91;
  double v92;
  double v93;
  CI::Object *v94;
  double v95;
  double v96;
  double v97;
  CI::Object *v98;
  double v99;
  double v100;
  double v101;
  float v102;
  float v103;
  CI::ClampToZeroToOneNode *v104;
  CI::Object *v105;
  uint64_t v106;
  CI::Vector *v107;
  __n128 v108;
  CI::Vector *v109;
  __n64 v110;
  double v111;
  double v112;
  double v113;
  CI::SerialObjectPtrArray *v114;
  CI::Object *v115;
  uint64_t v116;
  uint64_t v117;
  CI::Vector *v118;
  __n64 v119;
  CI::Vector *v120;
  __n64 v121;
  CI::Vector *v122;
  __n128 v123;
  CI::Vector *v124;
  __n64 v125;
  CI::Vector *v126;
  __n64 v127;
  CI::Vector *v128;
  __n128 v129;
  CGFloat v130;
  double v131;
  CGFloat v132;
  double v133;
  CGFloat v134;
  double v135;
  CGFloat v136;
  char v137;
  CI::FillNode *v138;
  int v139;
  int v140;
  int v141;
  size_t v142;
  int v143;
  CI *v144;
  CI::Object *v145;
  uint64_t v146;
  unint64_t v147;
  uint64_t v148;
  CI::Vector *v149;
  __n64 v150;
  CI::Vector *v151;
  __n128 v152;
  CI::Object *v153;
  unint64_t v154;
  CFStringRef v155;
  uint64_t v156;
  uint64_t v157;
  __IOSurface *v158;
  CI::Object *v159;
  _QWORD *v160;
  CI::Vector *v161;
  double v162;
  float v163;
  double v164;
  double v165;
  double v166;
  CGFloat v167;
  CGFloat v168;
  CGFloat v169;
  CGFloat v170;
  CI::FillNode *v171;
  double v172;
  double v173;
  double v174;
  double v175;
  double v176;
  double v177;
  double v178;
  double v179;
  double v180;
  double v181;
  CI::Object *v182;
  NSObject *v183;
  BOOL v184;
  int v185;
  unint64_t v187;
  CI::Object *v188;
  uint64_t v189;
  CFStringRef v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  __IOSurface *v194;
  CI::Object *v195;
  _QWORD *v196;
  CI::Vector *v197;
  CI::Object *v198;
  double v199;
  __n128 v200;
  double v201;
  float v202;
  float v203;
  float v204;
  void (***v205)(CI::ColorKernel *__hidden);
  double v206;
  float v207;
  double v208;
  double v209;
  double v210;
  double v211;
  double v212;
  double v213;
  double v214;
  CI::ClampToZeroToOneNode *v215;
  CI *v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  CI::Object *v221;
  uint64_t v222;
  BOOL v223;
  char v224;
  unsigned int v227;
  const __CFArray *v229;
  _QWORD v230[6];
  int v231;
  __int128 v232;
  uint64_t v233;
  __int128 v234;
  uint64_t v235;
  _QWORD v236[5];
  __int128 v237;
  uint64_t v238;
  __int128 v239;
  uint64_t v240;
  _QWORD v241[6];
  __int128 v242;
  uint64_t v243;
  __int128 v244;
  uint64_t v245;
  _OWORD v246[3];
  float64x2_t v247;
  float64x2_t v248;
  float64x2_t v249;
  __int128 v250;
  uint64_t v251;
  uint64_t v252;
  __int128 v253;
  __int128 v254;
  uint8_t buf[16];
  __int128 v256;
  __int128 v257;
  uint64_t v258;

  v7 = theArray;
  v258 = *MEMORY[0x1E0C80C00];
  if (!CFArrayGetCount(theArray) || CFArrayGetCount(v7) < 1)
    return a2;
  v224 = 0;
  v9 = 0;
  v227 = a6;
  v229 = v7;
  while (2)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v7, v9);
    Properties = CGColorFunctionGetProperties();
    v12 = CFGetTypeID(ValueAtIndex);
    if (v12 == CGColorTRCGetTypeID())
    {
      memset(v246, 0, 36);
      CGColorTRCGetFunction();
      v13 = v246[0];
      v14 = *(_QWORD *)((char *)v246 + 4);
      v15 = *((float *)v246 + 3);
      v16 = v246[1];
      v17 = CGColorTRCGetGammaID();
      v18 = CI::PremultiplyNode::append_to_tree(a2, (CI::Node *)0xFFFFFFFFLL, (int)a6);
      if (a2)
        CI::Object::unref(a2);
      switch(v13)
      {
        case -1:
          v19 = CI::CurveNode::append_to_tree(v18, a6, *(float *)&v14, *((float *)&v14 + 1), v15, *(float *)&v16, *((float *)&v16 + 1), *((float *)&v16 + 2), 0.0);
          if (v18)
            CI::Object::unref(v18);
          v20 = *((float *)&v16 + 3);
          v21 = v19;
          goto LABEL_33;
        case 0:
          v20 = *(float *)&v14;
          v21 = v18;
LABEL_33:
          v48 = CI::CurveNode::append_to_tree_and_unref(v21, a6, v20);
          goto LABEL_69;
        case 1:
          v48 = CI::CurveNode::append_to_tree_and_unref(v18, a6, *(float *)&v14, *((float *)&v14 + 1), v15);
          goto LABEL_69;
        case 2:
          v48 = CI::CurveNode::append_to_tree_and_unref(v18, a6, *(float *)&v14, *((float *)&v14 + 1), v15, *(float *)&v16);
          goto LABEL_69;
        case 3:
          if (v17 == 1
            || (v172 = *((float *)&v14 + 1),
                v173 = v15,
                v174 = *(float *)&v16,
                v175 = *((float *)&v16 + 1),
                fabs(*(float *)&v14 + -2.4) < 0.00001)
            && fabs(v172 + -0.947867) < 0.00001
            && fabs(v173 + -0.0521327) < 0.00001
            && fabs(v174 + -0.0773994) < 0.00001
            && fabs(v175 + -0.04045) < 0.00001)
          {
            v49 = v18;
            v50 = 0xFFFFFFFFLL;
            goto LABEL_40;
          }
          v48 = CI::CurveNode::append_to_tree_and_unref(v18, a6, *(float *)&v14, v172, v173, v174, v175);
          goto LABEL_69;
        case 4:
          if (v17 == 4
            || (v176 = *((float *)&v14 + 1),
                v177 = v15,
                v178 = *(float *)&v16,
                v179 = *((float *)&v16 + 1),
                v180 = *((float *)&v16 + 2),
                v181 = *((float *)&v16 + 3),
                fabs(*(float *)&v14 + -0.4166667) < 0.00001)
            && fabs(v176 + -1.137119) < 0.00001
            && fabs(v177) < 0.00001
            && fabs(v178 + -12.92) < 0.00001
            && fabs(v179 + -0.0031308) < 0.00001
            && fabs(v180 + 0.055) < 0.00001
            && fabs(v181) < 0.00001)
          {
            v49 = v18;
            v50 = 1;
LABEL_40:
            v51 = CI::SRGBNode::append_to_tree(v49, (CI::Node *)v50, (int)a6);
          }
          else
          {
            v51 = CI::CurveNode::append_to_tree(v18, a6, *(float *)&v14, v176, v177, v178, v179, v180, v181);
          }
          v182 = v51;
          if (v18)
            CI::Object::unref(v18);
          v18 = v182;
          if ((Properties & 2) == 0)
            goto LABEL_131;
          goto LABEL_71;
        case 5:
          v52 = 4;
          if (*(_QWORD *)((char *)v246 + 4) != 4097)
            v52 = 1;
          v53 = 64;
          if (*(_QWORD *)((char *)v246 + 4) == 65552)
          {
            v54 = 1;
          }
          else
          {
            v53 = v52;
            v54 = *(_QWORD *)((char *)v246 + 4) == 4097;
          }
          if (v54)
            v55 = 1025;
          else
            v55 = *(_QWORD *)((char *)v246 + 4);
          if (*(_QWORD *)((char *)v246 + 4) < 2uLL)
          {
            v7 = v229;
          }
          else
          {
            v218 = *(_QWORD *)((char *)v246 + 12);
            v220 = v53;
            v56 = CI::calc_hash(*(CI **)((char *)v246 + 12), 4 * *(_QWORD *)((char *)v246 + 4));
            v57 = operator new();
            *(_QWORD *)v57 = 0;
            *(_OWORD *)(v57 + 24) = 0u;
            *(_OWORD *)(v57 + 40) = 0u;
            *(_OWORD *)(v57 + 56) = 0u;
            *(_OWORD *)(v57 + 72) = 0u;
            *(_OWORD *)(v57 + 88) = 0u;
            *(_QWORD *)(v57 + 16) = 0;
            *(_QWORD *)(v57 + 4) = 0x30000000ALL;
            CI::SerialObjectPtrArray::append(v57, v18);
            if (v18)
              CI::Object::unref(v18);
            buf[0] = 1;
            v222 = v56;
            v58 = CFStringCreateWithFormat(0, 0, CFSTR("cmlut %016llX"), v56);
            *(_QWORD *)&v244 = 0;
            *((_QWORD *)&v244 + 1) = v55;
            v245 = 1;
            LODWORD(v242) = 0;
            v59 = (*(uint64_t (**)(_QWORD *))(*a1 + 616))(a1);
            v60 = a1[47];
            *((_QWORD *)&v242 + 1) = v59;
            v243 = v60;
            SurfaceFromCache = (__IOSurface *)GetSurfaceFromCache(&v244, 1, 1, 1380411457, &v242, 0, 0, 1, (uint64_t)v58, (uint64_t)buf, 0);
            CFRelease(v58);
            if (buf[0])
            {
              v241[0] = MEMORY[0x1E0C809B0];
              v241[1] = 0x40000000;
              v241[2] = ___ZN2CIL20AppendConverterArrayEPNS_7ContextEPNS_4NodeENS_10ImageIndexEPK9__CFArrayNS_18ConverterDirectionEbb_block_invoke;
              v241[3] = &__block_descriptor_tmp_60_0;
              v241[4] = v218;
              v241[5] = v220;
              SurfaceApplyPlaneBlock(SurfaceFromCache, (uint64_t)v241);
            }
            v62 = (CI::Object *)operator new();
            v63 = (_QWORD *)CI::SurfaceNode::SurfaceNode((uint64_t)v62, a3, SurfaceFromCache, v222, 2056, 1, 1, 0, 1);
            *v63 = &off_1E2EBD1D8;
            v63[5] = &unk_1E2EBD390;
            CI::SerialObjectPtrArray::append(v57, v62);
            CI::Object::unref(v62);
            CFRelease(SurfaceFromCache);
            v64 = (CI::Vector *)operator new();
            v65 = ((double)v55 + -1.0) / (double)v55;
            *(float *)&v65 = v65;
            v66 = 0.5 / (double)v55;
            CI::Vector::Vector(v64, *(__n64 *)&v65, v66);
            CI::SerialObjectPtrArray::append(v57, v64);
            CI::Object::unref(v64);
            v67 = (*(double (**)(CI::Object *))(*(_QWORD *)v18 + 160))(v18);
            v69 = v68;
            v71 = v70;
            v73 = v72;
            v74 = (*(uint64_t (**)(CI::Object *))(*(_QWORD *)v18 + 264))(v18);
            v75 = &CI::_cmlut;
            v76 = (CI::SerialObjectPtrArray *)v57;
            v77 = v67;
            v78 = v69;
            v79 = v71;
            v80 = v73;
            a6 = (CI::Node *)v227;
LABEL_68:
            v48 = CI::ColorKernelNode::append_to_tree((CI::Kernel *)v75, v76, 0, (int)a6, v74, 0, v77, v78, v79, v80);
LABEL_69:
            v18 = v48;
LABEL_70:
            if ((Properties & 2) != 0)
            {
LABEL_71:
              v7 = v229;
              if (a5
                && (CGColorFunctionGetOutputRange(), fabsf(v102) < 1.0e-10)
                && (CGColorFunctionGetOutputRange(), fabs(v103 + -1.0) < 1.0e-10))
              {
                v104 = CI::ClampToZeroToOneNode::append_to_tree(v18, a6);
                if (v18)
                  CI::Object::unref(v18);
              }
              else
              {
                v104 = v18;
              }
            }
            else
            {
LABEL_131:
              v104 = v18;
              v7 = v229;
            }
            v18 = CI::PremultiplyNode::append_to_tree(v104, (CI::Node *)1, (int)a6);
            if (v104)
              CI::Object::unref(v104);
          }
          a2 = v18;
          break;
        case 6:
          v81 = (CI::Object *)operator new();
          CI::Vector::Vector((uint64_t)v81, *((float *)&v16 + 3));
          v82 = (CI::SerialObjectPtrArray *)operator new();
          CI::SerialObjectPtrArray::SerialObjectPtrArray(v82, v18, v81);
          if (v18)
            CI::Object::unref(v18);
          v83 = (*(double (**)(CI::Object *))(*(_QWORD *)v18 + 160))(v18);
          v85 = v84;
          v87 = v86;
          v89 = v88;
          v74 = (*(uint64_t (**)(CI::Object *))(*(_QWORD *)v18 + 264))(v18);
          v75 = &CI::_pq_eotf;
          goto LABEL_67;
        case 7:
          v90 = (CI::Object *)operator new();
          CI::Vector::Vector((uint64_t)v90, *((float *)&v16 + 3));
          v82 = (CI::SerialObjectPtrArray *)operator new();
          CI::SerialObjectPtrArray::SerialObjectPtrArray(v82, v18, v90);
          if (v18)
            CI::Object::unref(v18);
          v83 = (*(double (**)(CI::Object *))(*(_QWORD *)v18 + 160))(v18);
          v85 = v91;
          v87 = v92;
          v89 = v93;
          v74 = (*(uint64_t (**)(CI::Object *))(*(_QWORD *)v18 + 264))(v18);
          v75 = &CI::_pq_inv_eotf;
          goto LABEL_67;
        case 8:
          v94 = (CI::Object *)operator new();
          CI::Vector::Vector((uint64_t)v94, *((float *)&v16 + 1));
          v82 = (CI::SerialObjectPtrArray *)operator new();
          CI::SerialObjectPtrArray::SerialObjectPtrArray(v82, v18, v94);
          if (v18)
            CI::Object::unref(v18);
          CI::Object::unref(v94);
          v83 = (*(double (**)(CI::Object *))(*(_QWORD *)v18 + 160))(v18);
          v85 = v95;
          v87 = v96;
          v89 = v97;
          v74 = (*(uint64_t (**)(CI::Object *))(*(_QWORD *)v18 + 264))(v18);
          v75 = &CI::_hlg_inv_oetf;
          goto LABEL_67;
        case 9:
          v98 = (CI::Object *)operator new();
          CI::Vector::Vector((uint64_t)v98, *((float *)&v16 + 2));
          v82 = (CI::SerialObjectPtrArray *)operator new();
          CI::SerialObjectPtrArray::SerialObjectPtrArray(v82, v18, v98);
          if (v18)
            CI::Object::unref(v18);
          CI::Object::unref(v98);
          v83 = (*(double (**)(CI::Object *))(*(_QWORD *)v18 + 160))(v18);
          v85 = v99;
          v87 = v100;
          v89 = v101;
          v74 = (*(uint64_t (**)(CI::Object *))(*(_QWORD *)v18 + 264))(v18);
          v75 = &CI::_hlg_oetf;
LABEL_67:
          v76 = v82;
          v77 = v83;
          v78 = v85;
          v79 = v87;
          v80 = v89;
          goto LABEL_68;
        case 10:
          goto LABEL_70;
        default:
          v47 = ci_logger_render();
          if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
            goto LABEL_70;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v13;
          _os_log_error_impl(&dword_1921E4000, v47, OS_LOG_TYPE_ERROR, "Could not support CGColorTRCType type: %d", buf, 8u);
          if ((Properties & 2) == 0)
            goto LABEL_131;
          goto LABEL_71;
      }
      goto LABEL_135;
    }
    v22 = CFGetTypeID(ValueAtIndex);
    if (v22 == CGColorMatrixGetTypeID())
    {
      v256 = 0u;
      v257 = 0u;
      *(_OWORD *)buf = 0u;
      CGColorMatrixGetMatrix();
      v23 = 0;
      v253 = 0u;
      v254 = 0u;
      v250 = 0u;
      v251 = 0;
      v248 = 0u;
      v249 = 0u;
      v247 = 0u;
      memset(v246, 0, sizeof(v246));
      v252 = 0x3FF0000000000000;
      do
      {
        v24 = *(float32x4_t *)&buf[16 * v23];
        v25 = (float64x2_t *)&v246[2 * v23];
        *v25 = vcvtq_f64_f32(*(float32x2_t *)v24.f32);
        v25[1] = vcvt_hight_f64_f32(v24);
        ++v23;
      }
      while (v23 != 3);
      if ((vmaxv_u8((uint8x8_t)vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_f64((float64x2_t)v246[2]), (int32x4_t)vceqzq_f64(v247)), (int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_f64(v248), (int32x4_t)vceqzq_f64(v249)))))) & 1) == 0)
      {
        v26 = 2;
        for (i = 1; i != 3; ++i)
        {
          for (j = 0; j != 2; ++j)
            v246[v26 + j] = v246[j];
          v26 += 2;
        }
      }
      v29 = CI::ColorMatrixNode::append_to_tree(a2, (CI::Node *)v246, (const double (*)[4])a6);
      if (a2)
        CI::Object::unref(a2);
      a2 = v29;
      goto LABEL_135;
    }
    v30 = CFGetTypeID(ValueAtIndex);
    if (v30 != CGColorNxMTransformGetTypeID())
      goto LABEL_135;
    memset(v246, 0, 36);
    CGColorNxMTransformGetTransform();
    switch(LODWORD(v246[0]))
    {
      case 7:
        v31 = CI::PremultiplyNode::append_to_tree(a2, (CI::Node *)0xFFFFFFFFLL, (int)a6);
        if (a2)
          CI::Object::unref(a2);
        v32 = *(_QWORD *)((char *)&v246[1] + 12);
        v33 = operator new();
        *(_QWORD *)v33 = 0;
        *(_OWORD *)(v33 + 24) = 0u;
        *(_OWORD *)(v33 + 40) = 0u;
        *(_OWORD *)(v33 + 56) = 0u;
        *(_OWORD *)(v33 + 72) = 0u;
        *(_OWORD *)(v33 + 88) = 0u;
        *(_QWORD *)(v33 + 16) = 0;
        *(_QWORD *)(v33 + 4) = 0x30000000ALL;
        CI::SerialObjectPtrArray::append(v33, v31);
        if (v31)
          CI::Object::unref(v31);
        v34 = (CI::Vector *)operator new();
        v35.n128_u32[0] = *(_DWORD *)(v32 + 8);
        CI::Vector::Vector(v34, v35, *(float *)(v32 + 12), *(float *)(v32 + 16), *(float *)(v32 + 20));
        CI::SerialObjectPtrArray::append(v33, v34);
        CI::Object::unref(v34);
        v36 = (CI::Vector *)operator new();
        v37.n64_u32[0] = *(_DWORD *)v32;
        CI::Vector::Vector(v36, v37, *(float *)(v32 + 4));
        CI::SerialObjectPtrArray::append(v33, v36);
        CI::Object::unref(v36);
        v38 = (*(double (**)(CI::Object *))(*(_QWORD *)v31 + 160))(v31);
        v40 = v39;
        v42 = v41;
        v44 = v43;
        v45 = (*(uint64_t (**)(CI::Object *))(*(_QWORD *)v31 + 264))(v31);
        v46 = &CI::_hlg_lumscale;
        goto LABEL_82;
      case 8:
        v105 = CI::PremultiplyNode::append_to_tree(a2, (CI::Node *)0xFFFFFFFFLL, (int)a6);
        if (a2)
          CI::Object::unref(a2);
        v106 = *(_QWORD *)((char *)&v246[1] + 12);
        v33 = operator new();
        *(_QWORD *)v33 = 0;
        *(_OWORD *)(v33 + 24) = 0u;
        *(_OWORD *)(v33 + 40) = 0u;
        *(_OWORD *)(v33 + 56) = 0u;
        *(_OWORD *)(v33 + 72) = 0u;
        *(_OWORD *)(v33 + 88) = 0u;
        *(_QWORD *)(v33 + 16) = 0;
        *(_QWORD *)(v33 + 4) = 0x30000000ALL;
        CI::SerialObjectPtrArray::append(v33, v105);
        if (v105)
          CI::Object::unref(v105);
        v107 = (CI::Vector *)operator new();
        v108.n128_u32[0] = *(_DWORD *)(v106 + 8);
        CI::Vector::Vector(v107, v108, *(float *)(v106 + 12), *(float *)(v106 + 16), *(float *)(v106 + 20));
        CI::SerialObjectPtrArray::append(v33, v107);
        CI::Object::unref(v107);
        v109 = (CI::Vector *)operator new();
        v110.n64_u32[0] = *(_DWORD *)v106;
        CI::Vector::Vector(v109, v110, *(float *)(v106 + 4));
        CI::SerialObjectPtrArray::append(v33, v109);
        CI::Object::unref(v109);
        v38 = (*(double (**)(CI::Object *))(*(_QWORD *)v105 + 160))(v105);
        v40 = v111;
        v42 = v112;
        v44 = v113;
        v45 = (*(uint64_t (**)(CI::Object *))(*(_QWORD *)v105 + 264))(v105);
        v46 = &CI::_hlg_srmapping;
LABEL_82:
        v114 = (CI::SerialObjectPtrArray *)v33;
        goto LABEL_110;
      case 9:
        v115 = CI::PremultiplyNode::append_to_tree(a2, (CI::Node *)0xFFFFFFFFLL, (int)a6);
        if (a2)
          CI::Object::unref(a2);
        v116 = *(_QWORD *)((char *)&v246[1] + 12);
        v117 = operator new();
        *(_QWORD *)v117 = 0;
        *(_OWORD *)(v117 + 24) = 0u;
        *(_OWORD *)(v117 + 40) = 0u;
        *(_OWORD *)(v117 + 56) = 0u;
        *(_OWORD *)(v117 + 72) = 0u;
        *(_OWORD *)(v117 + 88) = 0u;
        *(_QWORD *)(v117 + 16) = 0;
        *(_QWORD *)(v117 + 4) = 0x70000000ALL;
        CI::SerialObjectPtrArray::append(v117, v115);
        if (v115)
          CI::Object::unref(v115);
        v118 = (CI::Vector *)operator new();
        v119.n64_u32[0] = *(_DWORD *)v116;
        CI::Vector::Vector(v118, v119, *(float *)(v116 + 4));
        CI::SerialObjectPtrArray::append(v117, v118);
        CI::Object::unref(v118);
        v120 = (CI::Vector *)operator new();
        v121.n64_u32[0] = *(_DWORD *)(v116 + 8);
        CI::Vector::Vector(v120, v121, *(float *)(v116 + 12), *(float *)(v116 + 16));
        CI::SerialObjectPtrArray::append(v117, v120);
        CI::Object::unref(v120);
        v122 = (CI::Vector *)operator new();
        v123.n128_u32[0] = *(_DWORD *)(v116 + 20);
        CI::Vector::Vector(v122, v123, *(float *)(v116 + 24), *(float *)(v116 + 48), *(float *)(v116 + 52));
        CI::SerialObjectPtrArray::append(v117, v122);
        CI::Object::unref(v122);
        v124 = (CI::Vector *)operator new();
        v125.n64_u32[0] = *(_DWORD *)(v116 + 32);
        CI::Vector::Vector(v124, v125, *(float *)(v116 + 28));
        CI::SerialObjectPtrArray::append(v117, v124);
        CI::Object::unref(v124);
        v126 = (CI::Vector *)operator new();
        v127.n64_u32[0] = *(_DWORD *)(v116 + 36);
        CI::Vector::Vector(v126, v127, *(float *)(v116 + 40));
        CI::SerialObjectPtrArray::append(v117, v126);
        CI::Object::unref(v126);
        v128 = (CI::Vector *)operator new();
        v129.n128_u32[0] = *(_DWORD *)(v116 + 56);
        CI::Vector::Vector(v128, v129, *(float *)(v116 + 60), *(float *)(v116 + 64), *(float *)(v116 + 68));
        CI::SerialObjectPtrArray::append(v117, v128);
        CI::Object::unref(v128);
        v130 = (*(double (**)(CI::Object *))(*(_QWORD *)v115 + 160))(v115);
        v132 = v131;
        v134 = v133;
        v136 = v135;
        v137 = (*(uint64_t (**)(CI::Object *))(*(_QWORD *)v115 + 264))(v115);
        v138 = CI::ColorKernelNode::append_to_tree((CI::Kernel *)&CI::_pq_tonemapping, (CI::SerialObjectPtrArray *)v117, 0, (int)a6, v137, 0, v130, v132, v134, v136);
        a2 = CI::PremultiplyNode::append_to_tree(v138, (CI::Node *)1, (int)a6);
        if (v138)
          CI::Object::unref(v138);
        v224 = 1;
        goto LABEL_113;
      case 0xB:
        v145 = CI::PremultiplyNode::append_to_tree(a2, (CI::Node *)0xFFFFFFFFLL, (int)a6);
        if (a2)
          CI::Object::unref(a2);
        v146 = *(_QWORD *)((char *)&v246[1] + 12);
        v147 = *(_QWORD *)(*(_QWORD *)((char *)&v246[1] + 12) + 28);
        v148 = operator new();
        *(_QWORD *)v148 = 0;
        *(_OWORD *)(v148 + 24) = 0u;
        *(_OWORD *)(v148 + 40) = 0u;
        *(_OWORD *)(v148 + 56) = 0u;
        *(_OWORD *)(v148 + 72) = 0u;
        *(_OWORD *)(v148 + 88) = 0u;
        *(_QWORD *)(v148 + 16) = 0;
        *(_QWORD *)(v148 + 4) = 0x50000000ALL;
        CI::SerialObjectPtrArray::append(v148, v145);
        if (v145)
          CI::Object::unref(v145);
        v149 = (CI::Vector *)operator new();
        v150.n64_u32[0] = *(_DWORD *)v146;
        CI::Vector::Vector(v149, v150, *(float *)(v146 + 4));
        CI::SerialObjectPtrArray::append(v148, v149);
        CI::Object::unref(v149);
        v151 = (CI::Vector *)operator new();
        v152.n128_u32[0] = *(_DWORD *)(v146 + 8);
        CI::Vector::Vector(v151, v152, *(float *)(v146 + 12), *(float *)(v146 + 16), *(float *)(v146 + 20));
        CI::SerialObjectPtrArray::append(v148, v151);
        CI::Object::unref(v151);
        v153 = (CI::Object *)operator new();
        CI::Vector::Vector((uint64_t)v153, *(float *)(v146 + 24));
        CI::SerialObjectPtrArray::append(v148, v153);
        CI::Object::unref(v153);
        buf[0] = 1;
        v154 = CI::calc_hash((CI *)(v146 + 36), 4 * v147);
        v155 = CFStringCreateWithFormat(0, 0, CFSTR("flexlut %016llX"), v154);
        *(_QWORD *)&v239 = 0;
        *((_QWORD *)&v239 + 1) = v147;
        v240 = 1;
        LODWORD(v237) = 0;
        v156 = (*(uint64_t (**)(_QWORD *))(*a1 + 616))(a1);
        v157 = a1[47];
        *((_QWORD *)&v237 + 1) = v156;
        v238 = v157;
        v158 = (__IOSurface *)GetSurfaceFromCache(&v239, 1, 1, 1380411457, &v237, 0, 0, 1, (uint64_t)v155, (uint64_t)buf, 0);
        CFRelease(v155);
        if (buf[0])
        {
          v236[0] = MEMORY[0x1E0C809B0];
          v236[1] = 0x40000000;
          v236[2] = ___ZN2CIL20AppendConverterArrayEPNS_7ContextEPNS_4NodeENS_10ImageIndexEPK9__CFArrayNS_18ConverterDirectionEbb_block_invoke_63;
          v236[3] = &__block_descriptor_tmp_64;
          v236[4] = v146;
          SurfaceApplyPlaneBlock(v158, (uint64_t)v236);
        }
        v159 = (CI::Object *)operator new();
        v160 = (_QWORD *)CI::SurfaceNode::SurfaceNode((uint64_t)v159, a3, v158, v154, 2056, 1, 1, 0, 1);
        *v160 = &off_1E2EBD1D8;
        v160[5] = &unk_1E2EBD390;
        CI::SerialObjectPtrArray::append(v148, v159);
        CI::Object::unref(v159);
        CFRelease(v158);
        v161 = (CI::Vector *)operator new();
        v162 = ((double)v147 + -1.0) / (double)v147;
        *(float *)&v162 = v162;
        v163 = 0.5 / (double)v147;
        CI::Vector::Vector(v161, *(__n64 *)&v162, v163);
        CI::SerialObjectPtrArray::append(v148, v161);
        CI::Object::unref(v161);
        v38 = (*(double (**)(CI::Object *))(*(_QWORD *)v145 + 160))(v145);
        v40 = v164;
        v42 = v165;
        v44 = v166;
        v45 = (*(uint64_t (**)(CI::Object *))(*(_QWORD *)v145 + 264))(v145);
        v46 = &CI::_flexLumaScaling;
        v114 = (CI::SerialObjectPtrArray *)v148;
LABEL_110:
        v167 = v38;
        v168 = v40;
        v169 = v42;
        v170 = v44;
        a6 = (CI::Node *)v227;
        goto LABEL_111;
      default:
        if ((v246[0] & 0xFFFFFFFB) == 1)
        {
          v139 = DWORD1(v246[1]);
          v140 = DWORD1(v246[0]);
          v141 = HIDWORD(v246[0]);
          if (HIDWORD(v246[0]) == 1)
            v142 = 2;
          else
            v142 = 8;
          if (SDWORD1(v246[0]) >= 1)
          {
            v143 = DWORD1(v246[0]);
            do
            {
              v142 *= SDWORD1(v246[1]);
              --v143;
            }
            while (v143);
          }
          if (!DWORD1(v246[1]))
            goto LABEL_170;
          v144 = *(CI **)((char *)&v246[1] + 12);
          v223 = HIDWORD(v246[0]) != 1;
          if (DWORD1(v246[1]) == 2 && DWORD1(v246[0]) == 3 && HIDWORD(v246[0]) == 3)
          {
            if (!memcmp(*(const void **)((char *)&v246[1] + 12), &unk_19249BB14, 0x40uLL))
            {
LABEL_170:
              a6 = (CI::Node *)v227;
LABEL_113:
              v7 = v229;
              goto LABEL_135;
            }
          }
          else
          {
            v184 = DWORD1(v246[1]) == 2 && DWORD1(v246[0]) == 1;
            v185 = v184;
            if (v184 && HIDWORD(v246[0]) == 3)
            {
              if (**(_QWORD **)((char *)&v246[1] + 12) == 0x3C00000000000000
                && *(_QWORD *)(*(_QWORD *)((char *)&v246[1] + 12) + 8) == 0x3C003C003C003C00)
              {
                goto LABEL_170;
              }
            }
            else
            {
              if (HIDWORD(v246[0]) != 1)
                v185 = 0;
              if (v185 == 1 && **(_DWORD **)((char *)&v246[1] + 12) == 1006632960)
                goto LABEL_170;
            }
          }
          v217 = v144;
          v187 = CI::calc_hash(v144, v142);
          v188 = CI::PremultiplyNode::append_to_tree(a2, (CI::Node *)0xFFFFFFFFLL, v227);
          if (a2)
            CI::Object::unref(a2);
          v189 = operator new();
          *(_QWORD *)v189 = 0;
          *(_OWORD *)(v189 + 24) = 0u;
          *(_OWORD *)(v189 + 40) = 0u;
          *(_OWORD *)(v189 + 56) = 0u;
          *(_OWORD *)(v189 + 72) = 0u;
          *(_OWORD *)(v189 + 88) = 0u;
          *(_QWORD *)(v189 + 16) = 0;
          *(_QWORD *)(v189 + 4) = 0x30000000ALL;
          CI::SerialObjectPtrArray::append(v189, v188);
          if (v188)
            CI::Object::unref(v188);
          v219 = v187;
          v221 = v188;
          buf[0] = 1;
          v190 = CFStringCreateWithFormat(0, 0, CFSTR("cm%zux%zulut %016llX"), *(_OWORD *)((char *)v246 + 4), v187);
          LODWORD(v191) = v139 * v139;
          if (v140 == 3)
            v191 = v191;
          else
            v191 = 1;
          *(_QWORD *)&v234 = 0;
          *((_QWORD *)&v234 + 1) = v139;
          v235 = v191;
          LODWORD(v232) = 0;
          v192 = (*(uint64_t (**)(_QWORD *))(*a1 + 616))(a1);
          v193 = a1[47];
          *((_QWORD *)&v232 + 1) = v192;
          v233 = v193;
          v194 = (__IOSurface *)GetSurfaceFromCache(&v234, 1, 1, 1380411457, &v232, 0, 0, 1, (uint64_t)v190, (uint64_t)buf, 0);
          CFRelease(v190);
          if (buf[0])
          {
            v230[0] = MEMORY[0x1E0C809B0];
            v230[1] = 0x40000000;
            v230[2] = ___ZN2CIL20AppendConverterArrayEPNS_7ContextEPNS_4NodeENS_10ImageIndexEPK9__CFArrayNS_18ConverterDirectionEbb_block_invoke_69;
            v230[3] = &__block_descriptor_tmp_70;
            v230[4] = v217;
            v230[5] = v139 << (2 * v223);
            v231 = v141;
            SurfaceApplyPlaneBlock(v194, (uint64_t)v230);
          }
          v195 = (CI::Object *)operator new();
          v196 = (_QWORD *)CI::SurfaceNode::SurfaceNode((uint64_t)v195, a3, v194, v219, 2056, 1, 1, 0, 1);
          *v196 = &off_1E2EBD1D8;
          v196[5] = &unk_1E2EBD390;
          CI::SerialObjectPtrArray::append(v189, v195);
          CI::Object::unref(v195);
          CFRelease(v194);
          v197 = (CI::Vector *)operator new();
          v198 = v197;
          v199 = (double)v139;
          v200.n128_u64[0] = -1.0;
          v201 = (double)v139 + -1.0;
          if (v140 == 3)
          {
            v200.n128_f32[0] = v201;
            v202 = 1.0 / v201;
            v203 = 1.0 / v199;
            v204 = 1.0 / (double)(v139 * v139);
            CI::Vector::Vector(v197, v200, v202, v203, v204);
            v205 = &CI::_cmcubeopaque;
          }
          else
          {
            v206 = v201 / v199;
            *(float *)&v206 = v201 / v199;
            v207 = 0.5 / v199;
            CI::Vector::Vector(v197, *(__n64 *)&v206, v207);
            v205 = &CI::_cm1x3lut;
          }
          a6 = (CI::Node *)v227;
          CI::SerialObjectPtrArray::append(v189, v198);
          CI::Object::unref(v198);
          v208 = (*(double (**)(CI::Object *))(*(_QWORD *)v221 + 160))(v221);
          v210 = v209;
          v212 = v211;
          v214 = v213;
          v45 = (*(uint64_t (**)(CI::Object *))(*(_QWORD *)v221 + 264))(v221);
          v46 = v205;
          v114 = (CI::SerialObjectPtrArray *)v189;
          v167 = v208;
          v168 = v210;
          v169 = v212;
          v170 = v214;
LABEL_111:
          v171 = CI::ColorKernelNode::append_to_tree((CI::Kernel *)v46, v114, 0, (int)a6, v45, 0, v167, v168, v169, v170);
          a2 = CI::PremultiplyNode::append_to_tree(v171, (CI::Node *)1, (int)a6);
          if (v171)
            CI::Object::unref(v171);
          goto LABEL_113;
        }
        v183 = ci_logger_render();
        if (os_log_type_enabled(v183, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v246[0];
          _os_log_error_impl(&dword_1921E4000, v183, OS_LOG_TYPE_ERROR, "Could not support CGColorNxMTransform format %d.", buf, 8u);
        }
LABEL_135:
        if (++v9 < CFArrayGetCount(v7))
          continue;
        if ((v224 & 1) == 0)
          return a2;
        v215 = CI::ClampToZeroToOneNode::append_to_tree(a2, a6);
        if (a2)
          CI::Object::unref(a2);
        return v215;
    }
  }
}

uint64_t ___ZN2CI4Node27traverse_preorder_stoppableEU13block_pointerFbPS0_E_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

__CFArray *CI::createConverterArray(CI *this, CGColorSpace *a2, CGColorSpace *a3, float a4, float a5)
{
  __CFArray *Mutable;
  uint64_t v10;
  __CFDictionary *v11;
  const __CFString *v12;
  __CFDictionary *v13;
  const __CFString *v14;
  const void *v15;
  const void *v16;
  float v17;
  const void *v18;
  int v19;
  const __CFString *v20;
  const void *v21;
  int v22;
  NSObject *v23;
  int v25;
  __CFDictionary *v27;
  __CFDictionary *v28;
  _QWORD v29[3];
  char v30;
  uint8_t buf[4];
  _BYTE *v32;
  __int16 v33;
  _BYTE *v34;
  _BYTE v35[256];
  _BYTE v36[256];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  CGColorSpaceGetNumberOfComponents(a2);
  CGColorSpaceGetNumberOfComponents(this);
  v10 = 0;
  v28 = (__CFDictionary *)*MEMORY[0x1E0C9D8C8];
  v27 = (__CFDictionary *)*MEMORY[0x1E0C9DA78];
  do
  {
    CFArrayRemoveAllValues(Mutable);
    v29[0] = 0;
    v29[1] = v29;
    v29[2] = 0x2000000000;
    v30 = 0;
    v11 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v13 = v11;
    if (v11)
      CFDictionarySetValue(v11, CFSTR("Client"), CFSTR("CoreImage"));
    if (a4 == 0.0)
    {
      v17 = 203.0;
    }
    else
    {
      __CFDictionary::setValue(v13, (__CFDictionary *)CFSTR("kCGHLGInvOETFOpticalScale"), v12, a4);
      __CFDictionary::setValue(v13, (__CFDictionary *)CFSTR("kCGHLGOETFOpticalScale"), v14, 1.0 / a4);
      __CFDictionary::setValue(v13, (__CFDictionary *)CFSTR("kCGHLGSkipOOTF"), (const __CFString *)1, v15);
      __CFDictionary::setValue(v13, (__CFDictionary *)CFSTR("kCGHLGSkipInvOOTF"), (const __CFString *)1, v16);
      v17 = 100.0;
    }
    __CFDictionary::setValue(v13, (__CFDictionary *)CFSTR("kCGHDRMediaReferenceWhite"), v12, v17);
    if (this)
    {
      v19 = CGColorSpaceContainsFlexGTCInfo();
      if (a5 >= 1.0)
      {
        if (v19)
        {
          __CFDictionary::setValue(v13, v28, (const __CFString *)1, v18);
          __CFDictionary::setValue(v13, v27, v20, a5);
        }
      }
    }
    __CFDictionary::setValue(v13, (__CFDictionary *)CFSTR("kCGPQEETF3DLut"), 0, v18);
    __CFDictionary::setValue(v13, (__CFDictionary *)CFSTR("kCGHLGSceneMapping3DLut"), 0, v21);
    v22 = CGColorConversionInfoIterateColorSpaceFunctionsWithCallbacksAndOptions();
    CFRelease(v13);
    if (v10 == 2 && (v22 & 1) == 0)
    {
      CI::snprintf_cs((CI *)v36, (char *)0x100, this, 0);
      CI::snprintf_cs((CI *)v35, (char *)0x100, a2, 0);
      v23 = ci_logger_render();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v32 = v36;
        v33 = 2082;
        v34 = v35;
        _os_log_error_impl(&dword_1921E4000, v23, OS_LOG_TYPE_ERROR, "Failed to create a ColorSync converter: from %{public}s to %{public}s", buf, 0x16u);
      }
    }
    _Block_object_dispose(v29, 8);
    if (v10++ == 2)
      v25 = 1;
    else
      v25 = v22;
  }
  while (v25 != 1);
  return Mutable;
}

void __CFDictionary::setValue(__CFDictionary *this, __CFDictionary *a2, const __CFString *a3, float a4)
{
  CFNumberRef v6;
  const void *v7;
  float valuePtr;

  valuePtr = a4;
  v6 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
  __CFDictionary::setValue(this, a2, v6, v7);
  if (v6)
    CFRelease(v6);
}

BOOL ___ZN2CIL20createConverterArrayEP12CGColorSpaceS1_ff_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;

  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  if (*(uint64_t *)(a2 + 28) >= 1)
  {
    v3 = 0;
    do
    {
      CGColorTRCGetFunction();
      ++v3;
    }
    while (*(_QWORD *)(a2 + 28) > v3);
  }
  if (*(uint64_t *)(a2 + 44) < 1)
  {
    v5 = 0;
  }
  else
  {
    v4 = 0;
    v5 = 0;
    do
    {
      CGColorNxMTransformGetTransform();
      ++v5;
      ++v4;
    }
    while (*(_QWORD *)(a2 + 44) > v4);
  }
  return v5 < 2 && v5 < 3;
}

uint64_t ___ZN2CIL20createConverterArrayEP12CGColorSpaceS1_ff_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  const void *v10;

  v6 = *a5;
  if (a4 < 2)
  {
LABEL_5:
    v10 = *(const void **)(*(_QWORD *)(a2 + 52) + 8 * v6);
    CGColorTRCGetFunction();
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v10);
    return 1;
  }
  else
  {
    v7 = a4 - 1;
    v8 = a5 + 1;
    while (1)
    {
      v9 = *v8++;
      if (v9 != v6)
        return 0;
      if (!--v7)
        goto LABEL_5;
    }
  }
}

uint64_t ___ZN2CIL20createConverterArrayEP12CGColorSpaceS1_ff_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), *(const void **)(*(_QWORD *)(a2 + 60) + 8 * a4));
  return 1;
}

uint64_t ___ZN2CIL20createConverterArrayEP12CGColorSpaceS1_ff_block_invoke_4()
{
  CGColorNxMTransformGetTransform();
  return 0;
}

CI::CurveNode *CI::CurveNode::append_to_tree_and_unref(CI::CurveNode *this, CI::Node *a2, double a3, double a4, double a5)
{
  double v6;
  CI::CurveNode *v7;

  if (a5 == 0.0)
    v6 = 0.0;
  else
    v6 = -a5 / a4;
  v7 = CI::CurveNode::append_to_tree(this, a2, a3, a4, a5, 0.0, v6, 0.0, 0.0);
  if (this)
    CI::Object::unref(this);
  return v7;
}

CI::CurveNode *CI::CurveNode::append_to_tree_and_unref(CI::CurveNode *this, CI::Node *a2, double a3, double a4, double a5, double a6)
{
  double v7;
  CI::CurveNode *v8;

  if (a5 == 0.0)
    v7 = 0.0;
  else
    v7 = -a5 / a4;
  v8 = CI::CurveNode::append_to_tree(this, a2, a3, a4, a5, 0.0, v7, a6, a6);
  if (this)
    CI::Object::unref(this);
  return v8;
}

CI::CurveNode *CI::CurveNode::append_to_tree_and_unref(CI::CurveNode *this, CI::Node *a2, double a3, double a4, double a5, double a6, double a7)
{
  CI::CurveNode *v8;

  v8 = CI::CurveNode::append_to_tree(this, a2, a3, a4, a5, a6, a7, 0.0, 0.0);
  if (this)
    CI::Object::unref(this);
  return v8;
}

unint64_t CI::calc_hash(CI *this, size_t a2)
{
  int64x2_t v5[5];

  XXH64_reset(v5, 0);
  if (this && a2)
    XXH64_update((uint64_t)v5, (char *)this, a2);
  return XXH64_digest((uint64_t)v5);
}

__int16 ___ZN2CIL20AppendConverterArrayEPNS_7ContextEPNS_4NodeENS_10ImageIndexEPK9__CFArrayNS_18ConverterDirectionEbb_block_invoke@<H0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>)
{
  uint64_t v7;
  int16x4_t v8;
  int16x4_t v9;
  int64x2_t v11;
  vImage_Buffer dest;
  vImage_Buffer src;
  __int16 v14;
  int v15;

  if (a4)
  {
    v7 = 0;
    v11 = vdupq_n_s64(1uLL);
    do
    {
      v15 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 4 * *(_QWORD *)(a1 + 40) * v7);
      v14 = 0;
      dest.rowBytes = 2;
      src.data = &v15;
      *(int64x2_t *)&src.height = v11;
      src.rowBytes = 4;
      dest.data = &v14;
      *(int64x2_t *)&dest.height = v11;
      vImageConvert_PlanarFtoPlanar16F(&src, &dest, 0);
      v8.i16[1] = 15360;
      v8.i32[1] = 1006648320;
      v8.i16[0] = v14;
      v9 = vzip1_s16(v8, v8);
      v9.i16[2] = v14;
      *(int16x4_t *)(a2 + 8 * v7++) = v9;
    }
    while (a4 != v7);
  }
  return v8.i16[0];
}

CI::SerialObjectPtrArray *CI::SerialObjectPtrArray::SerialObjectPtrArray(CI::SerialObjectPtrArray *this, CI::Object *a2, CI::Object *a3)
{
  _QWORD *v5;

  *(_QWORD *)this = 0;
  *((_OWORD *)this + 2) = 0u;
  v5 = (_QWORD *)((char *)this + 32);
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 12) = 0;
  *(_QWORD *)((char *)this + 4) = 0x20000000ALL;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = a2;
  if (a2)
    CI::Object::ref((uint64_t)a2);
  *v5 = a3;
  if (a3)
    CI::Object::ref((uint64_t)a3);
  *(_DWORD *)this = 2;
  return this;
}

__int16 ___ZN2CIL20AppendConverterArrayEPNS_7ContextEPNS_4NodeENS_10ImageIndexEPK9__CFArrayNS_18ConverterDirectionEbb_block_invoke_63@<H0>(uint64_t a1@<X0>, int16x4_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>)
{
  int *v4;
  int v5;
  __int16 result;
  int16x4_t v12;
  int16x4_t v13;

  if (a4)
  {
    v4 = (int *)(*(_QWORD *)(a1 + 32) + 36);
    do
    {
      v5 = *v4++;
      _S0 = v5;
      __asm { FCVT            H0, S0 }
      v12.i16[1] = 15360;
      v12.i32[1] = 1006648320;
      v12.i16[0] = result;
      v13 = vzip1_s16(v12, v12);
      v13.i16[2] = result;
      *a2++ = v13;
      --a4;
    }
    while (a4);
  }
  return result;
}

uint64_t ___ZN2CIL20AppendConverterArrayEPNS_7ContextEPNS_4NodeENS_10ImageIndexEPK9__CFArrayNS_18ConverterDirectionEbb_block_invoke_69(uint64_t result, int16x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  __int16 *v7;
  uint64_t v8;
  int v9;
  uint64_t i;
  int16x4_t *v11;
  __int16 *v12;
  uint64_t j;
  int16x4_t v14;
  int16x4_t v15;

  if (a5)
  {
    v6 = 0;
    v7 = *(__int16 **)(result + 32);
    v8 = *(_QWORD *)(result + 40);
    v9 = *(_DWORD *)(result + 48);
    do
    {
      if (v9 == 3)
      {
        if (v8)
        {
          for (i = 0; i != v8; ++i)
            a2->i16[i] = v7[i];
        }
      }
      else
      {
        v11 = a2;
        v12 = v7;
        for (j = a4; j; --j)
        {
          v14.i16[1] = 15360;
          v14.i32[1] = 1006648320;
          v14.i16[0] = *v12++;
          v15 = vzip1_s16(v14, v14);
          v15.i16[2] = v14.i16[0];
          *v11++ = v15;
        }
      }
      ++v6;
      v7 += v8;
      a2 = (int16x4_t *)((char *)a2 + a6);
    }
    while (v6 != a5);
  }
  return result;
}

void CI::CachedSurfaceNode::~CachedSurfaceNode(CI::CachedSurfaceNode *this)
{
  CI::SurfaceNode::~SurfaceNode(this);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::SurfaceNode::type(CI::SurfaceNode *this)
{
  return 46;
}

uint64_t CI::Node::print(CI::Node *this, __sFILE *a2)
{
  _OWORD v3[2];
  int v4;

  memset(v3, 0, sizeof(v3));
  v4 = 1065353216;
  CI::Node::print_graph((uint64_t)this, a2, (uint64_t)v3);
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)v3);
}

uint64_t CI::SurfaceNode::child_count(CI::SurfaceNode *this)
{
  return 0;
}

uint64_t CI::SurfaceNode::child(CI::SurfaceNode *this)
{
  return 0;
}

uint64_t CI::SurfaceNode::shape_for_graphviz(CI::SurfaceNode *this)
{
  return 0;
}

uint64_t CI::SurfaceNode::color_for_graphviz(CI::SurfaceNode *this)
{
  return 12;
}

uint64_t CI::Node::node_for_graphviz(uint64_t a1, uint64_t a2)
{
  _OWORD v3[4];

  memset(v3, 0, 57);
  return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *))(*(_QWORD *)a1 + 144))(a1, a2, v3);
}

uint64_t CI::SurfaceNode::imageIndex(CI::SurfaceNode *this)
{
  return *((unsigned int *)this + 27);
}

const char *CI::Node::short_name(CI::Node *this)
{
  unsigned int v1;

  v1 = (*(uint64_t (**)(CI::Node *))(*(_QWORD *)this + 16))(this);
  return CI::name_for_type(v1);
}

uint64_t CI::Node::print_for_graph_short(CI::Node *this, __sFILE *a2)
{
  const char *v3;

  v3 = (const char *)(*(uint64_t (**)(CI::Node *))(*(_QWORD *)this + 104))(this);
  return fputs(v3, a2);
}

uint64_t CI::Node::print_for_graphviz(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 120))(a1, a2, a3, 0);
}

_DWORD *CI::SurfaceNode::extent(_DWORD *this)
{
  if (!this[25])
    return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)this + 168))(this);
  return this;
}

double CI::SurfaceNode::extent_unclamped(CI::SurfaceNode *this)
{
  return 0.0;
}

uint64_t CI::Node::isMultiUse(CI::Node *this)
{
  return *((unsigned __int8 *)this + 32);
}

uint64_t CI::Node::setMultiUse(uint64_t this)
{
  *(_BYTE *)(this + 32) = 1;
  return this;
}

uint64_t CI::SurfaceNode::child_type_is_image(CI::SurfaceNode *this)
{
  return 0;
}

size_t CI::SurfaceNode::plane_count(IOSurfaceRef *this)
{
  if ((int)IOSurfaceGetPlaneCount(this[7]) < 2)
    return 1;
  else
    return IOSurfaceGetPlaneCount(this[7]);
}

uint64_t CI::Node::is_identity(CI::Node *this)
{
  return 0;
}

uint64_t CI::Node::is_warp(CI::Node *this)
{
  return 0;
}

uint64_t CI::Node::is_position_invariant(CI::Node *this)
{
  return (*(unsigned int (**)(CI::Node *))(*(_QWORD *)this + 232))(this) ^ 1;
}

uint64_t CI::Node::is_rgb_invariant(CI::Node *this)
{
  if (((*(uint64_t (**)(CI::Node *))(*(_QWORD *)this + 224))(this) & 1) != 0)
    return 1;
  else
    return (*(uint64_t (**)(CI::Node *))(*(_QWORD *)this + 232))(this);
}

uint64_t CI::SurfaceNode::may_be_extended_range(CI::SurfaceNode *this)
{
  return *((unsigned __int8 *)this + 105);
}

BOOL CI::SurfaceNode::alpha_one(CI::SurfaceNode *this)
{
  return *((_DWORD *)this + 24) == 1;
}

uint64_t CI::SurfaceNode::output_is_rg(CI **this, __IOSurface *a2)
{
  int v2;

  v2 = CI::format_from_IOSurface(this[7], a2);
  return CI::format_is_rg(v2);
}

uint64_t CI::SurfaceNode::output_is_r(CI **this, __IOSurface *a2)
{
  int v2;

  v2 = CI::format_from_IOSurface(this[7], a2);
  return CI::format_is_r(v2);
}

uint64_t CI::SurfaceNode::output_is_luma(CI **this, __IOSurface *a2)
{
  int v3;
  uint64_t result;

  v3 = CI::format_from_IOSurface(this[7], a2);
  result = CI::format_is_luminance(v3);
  if ((_DWORD)result)
    return (*((uint64_t (**)(CI **))*this + 33))(this);
  return result;
}

uint64_t CI::Node::is_color_general(CI::Node *this)
{
  return 0;
}

uint64_t CI::SurfaceNode::output_depth(CI **this, __IOSurface *a2)
{
  int v2;

  v2 = CI::format_from_IOSurface(this[7], a2);
  if (CI::format_is_deep(v2))
    return 1;
  else
    return 0xFFFFFFFFLL;
}

uint64_t CI::Node::output_format(CI::Node *this)
{
  return 0;
}

uint64_t CI::Node::convert_to_kernel_node(CI::Node *this, CI::Context *a2)
{
  return 0;
}

uint64_t CI::Node::code_complexity(CI::Node *this)
{
  return 1;
}

uint64_t CI::SurfaceNode::roiAlignment(CI::SurfaceNode *this)
{
  return 4;
}

uint64_t CI::Node::add_args_to_hash(CI::Node *this, CI::XXHashHelper *a2)
{
  return (*(uint64_t (**)(CI::Node *, CI::XXHashHelper *))(*(_QWORD *)this + 88))(this, a2);
}

uint64_t CI::Node::digest(CI::Node *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t CI::Node::add_to_kernel_hash(CI::Node *this, CI::XXHashHelper *a2)
{
  char __src;

  __src = (*(uint64_t (**)(CI::Node *))(*(_QWORD *)this + 16))(this);
  return XXH64_update((uint64_t)a2, &__src, 1uLL);
}

uint64_t CI::SurfaceNode::texture_bindable(CI::SurfaceNode *this)
{
  return (uint64_t)this + 48;
}

uint64_t CI::SurfaceNode::output_is_packed(CI **this, __IOSurface *a2)
{
  int v2;

  v2 = CI::format_from_IOSurface(this[7], a2);
  return CI::format_is_packed(v2);
}

uint64_t CI::SurfaceNode::alpha_mode(CI::SurfaceNode *this)
{
  return *((unsigned int *)this + 24);
}

uint64_t `non-virtual thunk to'CI::SurfaceNode::type(CI::SurfaceNode *this)
{
  return 46;
}

void `non-virtual thunk to'CI::CachedSurfaceNode::~CachedSurfaceNode(CI::CachedSurfaceNode *this)
{
  CI::SurfaceNode::~SurfaceNode((CI::CachedSurfaceNode *)((char *)this - 40));
}

{
  CI::SurfaceNode::~SurfaceNode((CI::CachedSurfaceNode *)((char *)this - 40));
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::Node::print_graph(uint64_t a1, FILE *a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD v8[9];
  int v9;
  _QWORD v10[6];
  uint64_t v11;
  float *v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t, uint64_t);
  uint64_t (*v15)(uint64_t);
  _BYTE v16[32];
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t, uint64_t);
  uint64_t (*v22)(uint64_t);
  _BYTE v23[32];
  int v24;
  _QWORD v25[5];
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *(*v29)(uint64_t, uint64_t);
  uint64_t (*v30)();
  _QWORD v31[130];

  v31[128] = *MEMORY[0x1E0C80C00];
  if (CI::print_graph_recursive<CI::Node,CI::NodeIndex,CI::Node::NodeStats>(__sFILE *,CI::Node const*,int,std::unordered_map<CI::NodeIndex,CI::Node::NodeStats> const&)::onceToken == -1)
  {
    if (a1)
    {
LABEL_3:
      v18 = 0;
      v19 = &v18;
      v20 = 0x5002000000;
      v21 = __Block_byref_object_copy__23;
      v22 = __Block_byref_object_dispose__23;
      memset(v23, 0, sizeof(v23));
      v24 = 1065353216;
      v11 = 0;
      v12 = (float *)&v11;
      v13 = 0x5002000000;
      v14 = __Block_byref_object_copy__74;
      v15 = __Block_byref_object_dispose__75;
      memset(v16, 0, sizeof(v16));
      v17 = 1065353216;
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>((uint64_t)v23, 0x80uLL);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>((uint64_t)(v12 + 10), vcvtps_u32_f32(128.0 / v12[18]));
      v6 = MEMORY[0x1E0C809B0];
      v10[0] = MEMORY[0x1E0C809B0];
      v10[1] = 0x40000000;
      v10[2] = ___ZN2CIL21print_graph_recursiveINS_4NodeENS_9NodeIndexENS1_9NodeStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke_76;
      v10[3] = &unk_1E2EC7208;
      v10[4] = &v18;
      v10[5] = &v11;
      v26 = MEMORY[0x1E0C809B0];
      v27 = 0x40000000;
      v28 = (uint64_t)___ZNK2CI4Node27traverse_preorder_stoppableEU13block_pointerFbPKS0_S2_iiE_block_invoke;
      v29 = (void *(*)(uint64_t, uint64_t))&unk_1E2EC7258;
      v30 = (uint64_t (*)())v10;
      CI::GraphObject::traverse_preorder_stoppable(a1, 0, 0, 0, (uint64_t)&v26);
      std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::clear(v19 + 5);
      v26 = 0;
      v27 = (uint64_t)&v26;
      v28 = 0x42802000000;
      v29 = __Block_byref_object_copy__79;
      v30 = __Block_byref_object_dispose__80;
      bzero(v31, 0x400uLL);
      v8[0] = v6;
      v8[1] = 0x40000000;
      v8[2] = ___ZN2CIL21print_graph_recursiveINS_4NodeENS_9NodeIndexENS1_9NodeStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke_81;
      v8[3] = &unk_1E2EC7230;
      v9 = 1;
      v8[4] = &v26;
      v8[5] = &v18;
      v8[6] = &v11;
      v8[7] = a2;
      v8[8] = a3;
      v25[0] = v6;
      v25[1] = 0x40000000;
      v25[2] = ___ZNK2CI4Node27traverse_preorder_stoppableEU13block_pointerFbPKS0_S2_iiE_block_invoke;
      v25[3] = &unk_1E2EC7258;
      v25[4] = v8;
      CI::GraphObject::traverse_preorder_stoppable(a1, 0, 0, 0, (uint64_t)v25);
      _Block_object_dispose(&v26, 8);
      _Block_object_dispose(&v11, 8);
      std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)v16);
      _Block_object_dispose(&v18, 8);
      return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table((uint64_t)v23);
    }
  }
  else
  {
    dispatch_once(&CI::print_graph_recursive<CI::Node,CI::NodeIndex,CI::Node::NodeStats>(__sFILE *,CI::Node const*,int,std::unordered_map<CI::NodeIndex,CI::Node::NodeStats> const&)::onceToken, &__block_literal_global_72_0);
    if (a1)
      goto LABEL_3;
  }
  return fprintf(a2, "%.*sNULL\n", 2, CI::print_graph_recursive<CI::Node,CI::NodeIndex,CI::Node::NodeStats>(__sFILE *,CI::Node const*,int,std::unordered_map<CI::NodeIndex,CI::Node::NodeStats> const&)::indent_str);
}

uint64_t __Block_byref_object_copy__23(uint64_t a1, uint64_t a2)
{
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__hash_table(a1 + 40, (uint64_t *)(a2 + 40));
}

uint64_t __Block_byref_object_dispose__23(uint64_t a1)
{
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(a1 + 40);
}

{
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(a1 + 40);
}

uint64_t __Block_byref_object_copy__74(uint64_t a1, uint64_t a2)
{
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::__hash_table(a1 + 40, (uint64_t *)(a2 + 40));
}

uint64_t __Block_byref_object_dispose__75(uint64_t a1)
{
  return std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::~__hash_table(a1 + 40);
}

BOOL ___ZN2CIL21print_graph_recursiveINS_4NodeENS_9NodeIndexENS1_9NodeStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke_76(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;

  v7 = a2;
  v3 = std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::find<CI::Image const*>((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), &v7);
  if (v3)
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v6 = *(_QWORD *)(v4 + 64);
    std::__hash_table<std::__hash_value_type<CI::Node const*,unsigned long>,std::__unordered_map_hasher<CI::Node const*,std::__hash_value_type<CI::Node const*,unsigned long>,std::hash<CI::Node const*>,std::equal_to<CI::Node const*>,true>,std::__unordered_map_equal<CI::Node const*,std::__hash_value_type<CI::Node const*,unsigned long>,std::equal_to<CI::Node const*>,std::hash<CI::Node const*>,true>,std::allocator<std::__hash_value_type<CI::Node const*,unsigned long>>>::__emplace_unique_key_args<CI::Node const*,CI::Node const*&,unsigned long>(v4 + 40, &v7, &v7, &v6);
  }
  else
  {
    std::__hash_table<CI::Node const*,std::hash<CI::Node const*>,std::equal_to<CI::Node const*>,std::allocator<CI::Node const*>>::__emplace_unique_key_args<CI::Node const*,CI::Node const* const&>(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40, &v7, &v7);
  }
  return v3 != 0;
}

void *__Block_byref_object_copy__79(uint64_t a1, uint64_t a2)
{
  return memcpy((void *)(a1 + 40), (const void *)(a2 + 40), 0x400uLL);
}

BOOL ___ZN2CIL21print_graph_recursiveINS_4NodeENS_9NodeIndexENS1_9NodeStatsEEEvP7__sFILEPKT_iRKNSt3__113unordered_mapIT0_T1_NS9_4hashISB_EENS9_8equal_toISB_EENS9_9allocatorINS9_4pairIKSB_SC_EEEEEE_block_invoke_81(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  unint64_t v9;
  int v10;
  BOOL v11;
  int v12;
  unint64_t v13;
  FILE *v14;
  const char *v15;
  size_t v16;
  _QWORD *v17;
  FILE *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t *v21;
  FILE *v22;
  _OWORD *v23;
  uint64_t v24;
  FILE *v25;
  uint64_t v26;
  _QWORD *v27;
  _OWORD v29[4];
  uint64_t v30;

  v30 = a2;
  fprintf(*(FILE **)(a1 + 56), "%.*s", 2 * *(_DWORD *)(a1 + 72), CI::print_graph_recursive<CI::Node,CI::NodeIndex,CI::Node::NodeStats>(__sFILE *,CI::Node const*,int,std::unordered_map<CI::NodeIndex,CI::Node::NodeStats> const&)::indent_str);
  if (a4 <= 0x3FF)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + a4 + 40) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  if (a4 >= 1)
  {
    v9 = 0;
    do
    {
      if (v9 <= 0x3FF
        && (v10 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + v9 + 40),
            v11 = v10 != 0,
            v12 = v10 - 1,
            v12 != 0 && v11))
      {
        v13 = v9 + 1;
        v14 = *(FILE **)(a1 + 56);
        if (v9 + 1 == a4 && v12 == a5)
        {
          fwrite("╰─", 6uLL, 1uLL, v14);
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + v9 + 40) = 0;
        }
        else
        {
          if (v13 == a4)
          {
            v15 = "├─";
            v16 = 6;
          }
          else
          {
            v15 = "│ ";
            v16 = 4;
          }
          fwrite(v15, v16, 1uLL, v14);
        }
      }
      else
      {
        fwrite("  ", 2uLL, 1uLL, *(FILE **)(a1 + 56));
        v13 = v9 + 1;
      }
      v9 = v13;
    }
    while (v13 != a4);
  }
  v17 = std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::find<CI::Image const*>((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), &v30);
  if (v17)
  {
    v18 = *(FILE **)(a1 + 56);
    v19 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40;
    *(_QWORD *)&v29[0] = &v30;
    v20 = std::__hash_table<std::__hash_value_type<CI::Node const*,unsigned long>,std::__unordered_map_hasher<CI::Node const*,std::__hash_value_type<CI::Node const*,unsigned long>,std::hash<CI::Node const*>,std::equal_to<CI::Node const*>,true>,std::__unordered_map_equal<CI::Node const*,std::__hash_value_type<CI::Node const*,unsigned long>,std::equal_to<CI::Node const*>,std::hash<CI::Node const*>,true>,std::allocator<std::__hash_value_type<CI::Node const*,unsigned long>>>::__emplace_unique_key_args<CI::Node const*,std::piecewise_construct_t const&,std::tuple<CI::Node const* const&>,std::tuple<>>(v19, &v30, (uint64_t)&std::piecewise_construct, (_QWORD **)v29);
    fprintf(v18, "<%ld>\n", v20[3]);
  }
  else
  {
    v21 = std::__hash_table<std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::__unordered_map_hasher<CI::ImageIndex,std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::hash<CI::ImageIndex>,std::equal_to<CI::ImageIndex>,true>,std::__unordered_map_equal<CI::ImageIndex,std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>,std::equal_to<CI::ImageIndex>,std::hash<CI::ImageIndex>,true>,std::allocator<std::__hash_value_type<CI::ImageIndex,CI::Image::ImageStats>>>::find<CI::ImageIndex>(*(_QWORD **)(a1 + 64), (unsigned int *)(v30 + 36));
    if (v21)
    {
      v22 = *(FILE **)(a1 + 56);
      v23 = v21 + 3;
      v24 = v30;
    }
    else
    {
      v24 = v30;
      v22 = *(FILE **)(a1 + 56);
      memset(v29, 0, sizeof(v29));
      v23 = v29;
    }
    CI::Node::print_for_graph(v24, v22, (uint64_t)v23);
    if (std::__hash_table<CI::Image const*,std::hash<CI::Image const*>,std::equal_to<CI::Image const*>,std::allocator<CI::Image const*>>::find<CI::Image const*>((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), &v30))
    {
      v25 = *(FILE **)(a1 + 56);
      v26 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40;
      *(_QWORD *)&v29[0] = &v30;
      v27 = std::__hash_table<std::__hash_value_type<CI::Node const*,unsigned long>,std::__unordered_map_hasher<CI::Node const*,std::__hash_value_type<CI::Node const*,unsigned long>,std::hash<CI::Node const*>,std::equal_to<CI::Node const*>,true>,std::__unordered_map_equal<CI::Node const*,std::__hash_value_type<CI::Node const*,unsigned long>,std::equal_to<CI::Node const*>,std::hash<CI::Node const*>,true>,std::allocator<std::__hash_value_type<CI::Node const*,unsigned long>>>::__emplace_unique_key_args<CI::Node const*,std::piecewise_construct_t const&,std::tuple<CI::Node const* const&>,std::tuple<>>(v26, &v30, (uint64_t)&std::piecewise_construct, (_QWORD **)v29);
      fprintf(v25, " <%ld>", v27[3]);
    }
    fputc(10, *(FILE **)(a1 + 56));
    std::__hash_table<CI::Node const*,std::hash<CI::Node const*>,std::equal_to<CI::Node const*>,std::allocator<CI::Node const*>>::__emplace_unique_key_args<CI::Node const*,CI::Node const* const&>(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40, &v30, &v30);
  }
  return v17 != 0;
}

uint64_t ___ZNK2CI4Node27traverse_preorder_stoppableEU13block_pointerFbPKS0_S2_iiE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

_QWORD *std::__hash_table<std::__hash_value_type<CI::Node const*,unsigned long>,std::__unordered_map_hasher<CI::Node const*,std::__hash_value_type<CI::Node const*,unsigned long>,std::hash<CI::Node const*>,std::equal_to<CI::Node const*>,true>,std::__unordered_map_equal<CI::Node const*,std::__hash_value_type<CI::Node const*,unsigned long>,std::equal_to<CI::Node const*>,std::hash<CI::Node const*>,true>,std::allocator<std::__hash_value_type<CI::Node const*,unsigned long>>>::__emplace_unique_key_args<CI::Node const*,CI::Node const*&,unsigned long>(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t *a4)
{
  unint64_t v4;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint8x8_t v12;
  _QWORD **v13;
  _QWORD *i;
  unint64_t v15;
  uint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;

  v8 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v9 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v8 >> 47) ^ v8);
  v10 = 0x9DDFEA08EB382D69 * (v9 ^ (v9 >> 47));
  v11 = *(_QWORD *)(a1 + 8);
  if (v11)
  {
    v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      v4 = 0x9DDFEA08EB382D69 * (v9 ^ (v9 >> 47));
      if (v10 >= v11)
        v4 = v10 % v11;
    }
    else
    {
      v4 = v10 & (v11 - 1);
    }
    v13 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v13)
    {
      for (i = *v13; i; i = (_QWORD *)*i)
      {
        v15 = i[1];
        if (v15 == v10)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v12.u32[0] > 1uLL)
          {
            if (v15 >= v11)
              v15 %= v11;
          }
          else
          {
            v15 &= v11 - 1;
          }
          if (v15 != v4)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v10;
  v16 = *a4;
  i[2] = *a3;
  i[3] = v16;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    v19 = 1;
    if (v11 >= 3)
      v19 = (v11 & (v11 - 1)) != 0;
    v20 = v19 | (2 * v11);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>(a1, v22);
    v11 = *(_QWORD *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
        v4 = v10 % v11;
      else
        v4 = v10;
    }
    else
    {
      v4 = (v11 - 1) & v10;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v24)
  {
    *i = *v24;
LABEL_38:
    *v24 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v23 + 8 * v4) = a1 + 16;
  if (*i)
  {
    v25 = *(_QWORD *)(*i + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v25 >= v11)
        v25 %= v11;
    }
    else
    {
      v25 &= v11 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

_QWORD *std::__hash_table<CI::Node const*,std::hash<CI::Node const*>,std::equal_to<CI::Node const*>,std::allocator<CI::Node const*>>::__emplace_unique_key_args<CI::Node const*,CI::Node const* const&>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = v8 & (v9 - 1);
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x18uLL);
  *i = 0;
  i[1] = v8;
  i[2] = *a3;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>(a1, v19);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *i = *v21;
LABEL_38:
    *v21 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v22 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9)
        v22 %= v9;
    }
    else
    {
      v22 &= v9 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

_QWORD *std::__hash_table<std::__hash_value_type<CI::Node const*,unsigned long>,std::__unordered_map_hasher<CI::Node const*,std::__hash_value_type<CI::Node const*,unsigned long>,std::hash<CI::Node const*>,std::equal_to<CI::Node const*>,true>,std::__unordered_map_equal<CI::Node const*,std::__hash_value_type<CI::Node const*,unsigned long>,std::equal_to<CI::Node const*>,std::hash<CI::Node const*>,true>,std::allocator<std::__hash_value_type<CI::Node const*,unsigned long>>>::__emplace_unique_key_args<CI::Node const*,std::piecewise_construct_t const&,std::tuple<CI::Node const* const&>,std::tuple<>>(uint64_t a1, _QWORD *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  _QWORD **v12;
  _QWORD *i;
  unint64_t v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10)
        v4 = v9 % v10;
    }
    else
    {
      v4 = v9 & (v10 - 1);
    }
    v12 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v12)
    {
      for (i = *v12; i; i = (_QWORD *)*i)
      {
        v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10)
              v14 %= v10;
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v4)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v9;
  i[2] = **a4;
  i[3] = 0;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v10 || (float)(v16 * (float)v10) < v15)
  {
    v17 = 1;
    if (v10 >= 3)
      v17 = (v10 & (v10 - 1)) != 0;
    v18 = v17 | (2 * v10);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}*,std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}*>>::__rehash<true>(a1, v20);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *i = *v22;
LABEL_38:
    *v22 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v21 + 8 * v4) = a1 + 16;
  if (*i)
  {
    v23 = *(_QWORD *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v23 >= v10)
        v23 %= v10;
    }
    else
    {
      v23 &= v10 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

double cikernel::_cmlut(uint64x2_t *a1, float32x4_t a2, double a3, double a4, double a5, int8x16_t a6, uint8x8_t a7, double a8, int8x16_t a9)
{
  float32x4_t v11;
  float32x4_t v12;
  double v13;
  double v14;
  double v15;
  int8x16_t v16;
  uint8x8_t v17;
  double v18;
  int8x16_t v19;
  double v20;
  double v21;
  double v22;
  int8x16_t v23;
  uint8x8_t v24;
  double v25;
  int8x16_t v26;
  float64x2_t v28;
  unsigned int v29;
  double v30;

  a2.i32[3] = 0;
  v11 = vmaxnmq_f32(a2, (float32x4_t)0);
  v11.i32[3] = 0;
  v12 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 1);
  v28 = (float64x2_t)vaddq_f32(v12, vmulq_n_f32(vminnmq_f32(v11, (float32x4_t)xmmword_192491FD0), *(float *)&a3));
  v13 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(LODWORD(v28.f64[0]) | 0x3F00000000000000), v28, *(double *)v12.i64, *(double *)a2.i64, a6, a7, a8, a9);
  v29 = LODWORD(v13);
  v20 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(HIDWORD(v28.f64[0]) | 0x3F00000000000000), v28, v14, v15, v16, v17, v18, v19);
  v30 = COERCE_DOUBLE(__PAIR64__(LODWORD(v20), v29));
  CI::BitmapSampler::read(a1, COERCE_DOUBLE(LODWORD(v28.f64[1]) | 0x3F00000000000000), v28, v21, v22, v23, v24, v25, v26);
  return v30;
}

void CI::f4_s_sr2d_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(uint64_t, __n128, double);
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  double *v17;
  __n128 *v18;
  __int128 v19;

  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(double (**)(uint64_t, __n128, double))(a1 + 24);
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *((_QWORD *)a2 + 8 * *(_QWORD *)(v10 + 32));
  v15 = *(_DWORD *)(v10 + 64);
  v16 = *(_QWORD *)(v10 + 56);
  if (*(_BYTE *)(a1 + 64))
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v17 = (double *)(a3 + 16 * v16);
  if (v15 != 5)
    v17 = (double *)((char *)a2 + 64 * v16);
  v18 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v18 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v19 = v11(v14, *v18, *v17);
  *(_OWORD *)(a3 + 16 * a7) = v19;
}

float32x4_t cikernel::_pq_eotf(float32x4_t a1, float a2)
{
  float32x4_t v2;
  int8x16_t v3;
  float32x4_t result;

  v2 = (float32x4_t)_simd_pow_f4((simd_float4)(*(_OWORD *)&a1 & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)), (simd_float4)vdupq_n_s64(0x3C4FCDAC3C4FCDACuLL));
  result = (float32x4_t)_simd_pow_f4((simd_float4)vdivq_f32(vmaxnmq_f32(vaddq_f32(v2, (float32x4_t)vdupq_n_s32(0xBF560000)), (float32x4_t)0), vaddq_f32(vmulq_f32(v2, (float32x4_t)vdupq_n_s32(0xC1958000)), (float32x4_t)vdupq_n_s32(0x4196D000u))), (simd_float4)vdupq_n_s64(0x40C8E06B40C8E06BuLL));
  v3.i64[0] = 0x8000000080000000;
  v3.i64[1] = 0x8000000080000000;
  __asm { FMOV            V2.4S, #1.0 }
  result.i64[0] = vmulq_f32(vmulq_n_f32((float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgtzq_f32(a1)), vorrq_s8(vandq_s8((int8x16_t)a1, v3), _Q2), (int8x16_t)0), a2), result).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

float32x4_t cikernel::_pq_inv_eotf(float32x4_t a1, float a2)
{
  float32x4_t v2;
  int8x16_t v8;
  float32x4_t result;
  int8x16_t v10;

  v2 = (float32x4_t)_simd_pow_f4((simd_float4)vmulq_n_f32((float32x4_t)(*(_OWORD *)&a1 & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)), a2), (simd_float4)vdupq_n_s64(0x3E2320003E232000uLL));
  __asm { FMOV            V2.4S, #1.0 }
  v10 = (int8x16_t)_Q2;
  result = (float32x4_t)_simd_pow_f4((simd_float4)vdivq_f32(vaddq_f32(vmulq_f32(v2, (float32x4_t)vdupq_n_s32(0x4196D000u)), (float32x4_t)vdupq_n_s32(0x3F560000u)), vaddq_f32(vmulq_f32(v2, (float32x4_t)vdupq_n_s32(0x41958000u)), _Q2)), (simd_float4)vdupq_n_s64(0x429DB000429DB000uLL));
  v8.i64[0] = 0x8000000080000000;
  v8.i64[1] = 0x8000000080000000;
  result.i64[0] = vmulq_f32((float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgtzq_f32(a1)), vorrq_s8(vandq_s8((int8x16_t)a1, v8), v10), (int8x16_t)0), result).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

int8x16_t cikernel::_hlg_inv_oetf(float32x4_t a1, float a2)
{
  float v2;
  float32x4_t v3;
  float32x4_t v4;
  int8x16_t result;

  v2 = a2 * 4.0;
  v3 = vmaxnmq_f32(vaddq_f32((float32x4_t)(*(_OWORD *)&a1 & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)), (float32x4_t)0), (float32x4_t)0);
  v4.i64[0] = 0xBF000000BF000000;
  v4.i64[1] = 0xBF000000BF000000;
  result = vbslq_s8((int8x16_t)vcltzq_f32(vaddq_f32(v3, v4)), (int8x16_t)vmulq_n_f32(vmulq_f32(v3, v3), v2), (int8x16_t)vmulq_n_f32(vaddq_f32((float32x4_t)_simd_exp_f4((simd_float4)vdivq_f32(vaddq_f32(v3, (float32x4_t)vdupq_n_s32(0xBF0F564F)), (float32x4_t)vdupq_n_s32(0x3E371FF0u))), (float32x4_t)vdupq_n_s32(0x3E91C020u)), a2));
  result.i64[0] = vbslq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vnegq_f32((float32x4_t)result), result).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

int8x16_t cikernel::_hlg_oetf(float32x4_t a1, float a2)
{
  float32x4_t v2;
  int8x16_t result;
  int8x16_t v10;

  v2 = vabsq_f32(vmulq_n_f32(a1, a2));
  __asm { FMOV            V1.4S, #3.0 }
  v10 = (int8x16_t)vsqrtq_f32(vmulq_f32(v2, _Q1));
  __asm { FMOV            V1.4S, #12.0 }
  result = vbslq_s8((int8x16_t)vcltzq_f32(vaddq_f32(v2, (float32x4_t)vdupq_n_s32(0xBDAAAAAB))), v10, (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)_simd_log_f4((simd_float4)vaddq_f32(vmulq_f32(vmaxnmq_f32(v2, (float32x4_t)vdupq_n_s32(0x3DAAAAABu)), _Q1), (float32x4_t)vdupq_n_s32(0xBE91C020))), (float32x4_t)vdupq_n_s32(0x3E371FF0u)), (float32x4_t)vdupq_n_s32(0x3F0F564Fu)));
  result.i64[0] = vbslq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vnegq_f32((float32x4_t)result), result).u64[0];
  result.i32[3] = a1.i32[3];
  return result;
}

__n128 cikernel::_hlg_lumscale(float32x4_t a1, float32x4_t a2, double a3)
{
  float32x4_t v3;
  int8x16_t v4;
  __n128 result;

  v3 = a1;
  v3.i32[3] = fmaxf(fmaxf(a1.f32[0], a1.f32[1]), a1.f32[2]);
  v4 = (int8x16_t)vmulq_f32(a2, v3);
  result.n128_u64[0] = vmulq_n_f32(a1, vmuls_lane_f32(powf(fmaxf(fabsf(vaddv_f32(vadd_f32(*(float32x2_t *)v4.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v4, v4, 8uLL)))), 0.0001), *(float *)&a3), *(float32x2_t *)&a3, 1)).u64[0];
  result.n128_u32[3] = a1.u32[3];
  return result;
}

void CI::f4_s_f4_f2(_QWORD *a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  double (*v11)(_QWORD *, __n128, __n128, double);
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  double *v18;
  __n128 *v19;
  __n128 *v20;
  __int128 v21;

  v10 = a1[6];
  v11 = (double (*)(_QWORD *, __n128, __n128, double))a1[3];
  v12 = *(_DWORD *)(v10 + 16);
  v13 = *(_QWORD *)(v10 + 8);
  v14 = *(_DWORD *)(v10 + 40);
  v15 = *(_QWORD *)(v10 + 32);
  v16 = *(_DWORD *)(v10 + 64);
  v17 = *(_QWORD *)(v10 + 56);
  if (*((_BYTE *)a1 + 64))
    a1 = CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v10 + 80)), a2);
  v18 = (double *)(a3 + 16 * v17);
  if (v16 != 5)
    v18 = (double *)((char *)a2 + 64 * v17);
  v19 = (__n128 *)(a3 + 16 * v15);
  if (v14 != 5)
    v19 = (__n128 *)((char *)a2 + 64 * v15);
  v20 = (__n128 *)(a3 + 16 * v13);
  if (v12 != 5)
    v20 = (__n128 *)((char *)a2 + 64 * v13);
  *(double *)&v21 = v11(a1, *v20, *v19, *v18);
  *(_OWORD *)(a3 + 16 * a7) = v21;
}

float32x4_t cikernel::_hlg_srmapping(float32x4_t a1, float32x4_t a2, float32x2_t a3)
{
  float32x4_t v3;
  int8x16_t v4;
  int32x2_t v5;
  float32x4_t result;
  int8x16_t v7;
  float v8;
  __int32 v10;

  v10 = a1.i32[3];
  v3 = vmulq_lane_f32(a1, a3, 1);
  v3.i32[3] = fmaxf(fmaxf(v3.f32[0], v3.f32[1]), v3.f32[2]);
  v4 = (int8x16_t)vmulq_f32(a2, v3);
  v5 = (int32x2_t)vadd_f32(*(float32x2_t *)v4.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v4, v4, 8uLL));
  result = (float32x4_t)_simd_pow_f4((simd_float4)v3, (simd_float4)vdupq_lane_s32((int32x2_t)a3, 0));
  v7 = (int8x16_t)vmulq_f32(a2, result);
  *(float32x2_t *)v7.i8 = vadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  *(float32x2_t *)v7.i8 = vadd_f32((float32x2_t)vzip1_s32(v5, *(int32x2_t *)v7.i8), (float32x2_t)vzip2_s32(v5, *(int32x2_t *)v7.i8));
  v8 = *(float *)v7.i32 / *(float *)&v7.i32[1];
  if (*(float *)&v7.i32[1] == 0.0)
    v8 = 1.0;
  result.i64[0] = vmulq_n_f32(result, v8).u64[0];
  result.i32[3] = v10;
  return result;
}

float32x4_t cikernel::_pq_tonemapping(float32x4_t result, double a2, float32x4_t a3, double a4, double a5, double a6, float32x4_t a7)
{
  float32x4_t v7;
  float v8;
  float v9;
  float v17;
  float v18;
  float32x4_t v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v26;
  float v28;
  float32x4_t v29;

  v7 = vmulq_f32(result, a7);
  v8 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0];
  if (v8 != 0.0)
  {
    v29 = result;
    v9 = *((float *)&a4 + 1);
    v28 = v8;
    v26 = *(float *)&a4;
    _S0 = powf(v8 / 10000.0, *(float *)&a2);
    _V3.S[1] = a3.u32[1];
    __asm { FMLA            S2, S0, V3.S[1] }
    v17 = pow(_S2 / (vmuls_lane_f32(_S0, a3, 2) + 1.0), *((float *)&a2 + 1));
    v18 = (float)(v17 - v9) / (float)(v26 - v9);
    if (v18 >= *(float *)&a6)
    {
      v20 = *(float *)&a5;
      v21 = vmuls_lane_f32(v18 - *(float *)&a6, *(float32x2_t *)&a6, 1);
      v18 = (1.0 - *(float *)&a6)
          * (float)(v21 + (float)((float)(v21 * (float)(v21 * -2.0)) + (float)((float)(v21 * v21) * v21)))
          + (1.0 - ((float)(v21 * (float)(v21 * 3.0)) - (v21 + v21) * v21 * v21)) * *(float *)&a6
          + ((float)(v21 * (float)(v21 * 3.0)) + v21 * -2.0 * v21 * v21) * *((float *)&a5 + 1);
      v19 = a3;
    }
    else
    {
      v19 = a3;
      v20 = *(float *)&a5;
    }
    v22 = v19.f32[1];
    v23 = v19.f32[2];
    if (v18 >= 0.0)
    {
      if (v18 >= 1.0)
        v20 = v18;
      else
        v20 = v18
            + (float)((float)((float)(1.0 - v18) * (float)((float)(1.0 - v18) * (float)(v20 * (float)(1.0 - v18))))
                    * (float)(1.0 - v18));
    }
    v24 = pow((float)(v9 + (float)(v20 * (float)(v26 - v9))), 1.0 / *((float *)&a2 + 1));
    result.f32[0] = pow((float)(fmaxf(v24 - a3.f32[0], 0.0) / (float)(v22 - (float)(v23 * v24))), 1.0 / *(float *)&a2);
    result.i64[0] = vmulq_n_f32(v29, (float)(result.f32[0] * 10000.0) / v28).u64[0];
    result.i32[3] = v29.i32[3];
  }
  return result;
}

void CI::f4_s_f2_f3_f4_f2_f2_f4(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(__n128, double, __n128, __n128, double, double, __n128);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  __n128 *v24;
  double *v25;
  double *v26;
  __n128 *v27;
  double *v28;
  __n128 *v29;
  __int128 v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  double (*v35)(__n128, double, __n128, __n128, double, double, __n128);
  int v36;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(__n128, double, __n128, __n128, double, double, __n128))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_QWORD *)(v9 + 56);
  v16 = *(_DWORD *)(v9 + 88);
  v17 = *(_QWORD *)(v9 + 80);
  v18 = *(_DWORD *)(v9 + 112);
  v19 = *(_QWORD *)(v9 + 104);
  v20 = *(_DWORD *)(v9 + 136);
  v21 = *(_QWORD *)(v9 + 128);
  v22 = *(_DWORD *)(v9 + 160);
  v23 = *(_QWORD *)(v9 + 152);
  if (*(_BYTE *)(a1 + 64))
  {
    v35 = *(double (**)(__n128, double, __n128, __n128, double, double, __n128))(a1 + 24);
    v33 = *(_DWORD *)(v9 + 16);
    v34 = *(_DWORD *)(v9 + 88);
    v36 = *(_DWORD *)(v9 + 40);
    v32 = *(_DWORD *)(v9 + 136);
    v31 = *(_QWORD *)(v9 + 80);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 176)), a2);
    v17 = v31;
    v20 = v32;
    v11 = v33;
    v16 = v34;
    v13 = v36;
    v10 = v35;
  }
  v24 = (__n128 *)(a3 + 16 * v23);
  if (v22 != 5)
    v24 = (__n128 *)((char *)a2 + 64 * v23);
  v25 = (double *)(a3 + 16 * v21);
  if (v20 != 5)
    v25 = (double *)((char *)a2 + 64 * v21);
  v26 = (double *)(a3 + 16 * v19);
  if (v18 != 5)
    v26 = (double *)((char *)a2 + 64 * v19);
  v27 = (__n128 *)(a3 + 16 * v17);
  if (v16 != 5)
    v27 = (__n128 *)((char *)a2 + 64 * v17);
  v28 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v28 = (double *)((char *)a2 + 64 * v14);
  v29 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v29 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v30 = v10(*v29, *v28, *((__n128 *)a2 + 4 * v15), *v27, *v26, *v25, *v24);
  *(_OWORD *)(a3 + 16 * a7) = v30;
}

__n128 cikernel::_flexLumaScaling(uint64x2_t *a1, float32x4_t a2, double a3, float32x4_t a4, double a5, int8x16_t a6, uint8x8_t a7, double a8, int8x16_t a9)
{
  float v9;
  float32x4_t v10;
  int8x16_t v11;
  float64x2_t v12;
  int8x16_t v13;
  double v14;
  float v15;
  float v16;
  __n128 result;

  v9 = *(float *)&a5;
  v10 = a2;
  v10.i32[3] = fmaxf(a2.f32[0], fmaxf(a2.f32[1], a2.f32[2]));
  v11 = (int8x16_t)vmulq_f32(a4, v10);
  v12 = (float64x2_t)vextq_s8(v11, v11, 8uLL);
  *(float32x2_t *)v11.i8 = vadd_f32(*(float32x2_t *)v11.i8, *(float32x2_t *)&v12.f64[0]);
  *(float *)v11.i32 = vaddv_f32(*(float32x2_t *)v11.i8);
  LODWORD(v12.f64[0]) = 1.0;
  v13.i64[0] = 0x8000000080000000;
  v13.i64[1] = 0x8000000080000000;
  *(_QWORD *)&v14 = vbslq_s8(v13, (int8x16_t)v12, v11).u64[0];
  LODWORD(a5) = 0;
  if (*(float *)v11.i32 == 0.0)
    *(float *)&v14 = 0.0;
  v15 = *(float *)&v14;
  LODWORD(v14) = 897988541;
  v16 = fmaxf(fabsf(*(float *)v11.i32), 0.000001);
  if (v16 > 1.0)
    v16 = 1.0;
  *(float *)v12.f64 = vmlas_n_f32(*(float *)&a6.i32[1], v16, *(float *)a6.i32);
  result.n128_f64[0] = CI::BitmapSampler::read(a1, COERCE_DOUBLE(LODWORD(v12.f64[0]) | 0x3F00000000000000), v12, v14, a5, a6, a7, a8, a9);
  result.n128_u64[0] = vmulq_n_f32(a2, (float)(v15 * result.n128_f32[0]) * v9).u64[0];
  result.n128_u32[3] = a2.u32[3];
  return result;
}

void CI::f4_s_f2_f4_f_sr2d_f2(uint64_t a1, const vec2 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  double (*v10)(uint64_t, __n128, double, __n128, float, double);
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  double *v21;
  __n128 *v22;
  double *v23;
  __n128 *v24;
  __int128 v25;
  uint64_t v26;
  int v27;
  int v28;

  v9 = *(_QWORD *)(a1 + 48);
  v10 = *(double (**)(uint64_t, __n128, double, __n128, float, double))(a1 + 24);
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(_QWORD *)(v9 + 8);
  v13 = *(_DWORD *)(v9 + 40);
  v14 = *(_QWORD *)(v9 + 32);
  v15 = *(_DWORD *)(v9 + 64);
  v16 = *(_QWORD *)(v9 + 56);
  v17 = *(_QWORD *)(v9 + 80);
  v18 = *((_QWORD *)a2 + 8 * *(_QWORD *)(v9 + 104));
  v19 = *(_DWORD *)(v9 + 136);
  v20 = *(_QWORD *)(v9 + 128);
  if (*(_BYTE *)(a1 + 64))
  {
    v27 = *(_DWORD *)(v9 + 64);
    v28 = *(_DWORD *)(v9 + 16);
    v26 = *(_QWORD *)(v9 + 8);
    CI::setDC((CI *)(a3 + 16 * *(_QWORD *)(v9 + 152)), a2);
    v15 = v27;
    v11 = v28;
    v12 = v26;
  }
  v21 = (double *)(a3 + 16 * v20);
  if (v19 != 5)
    v21 = (double *)((char *)a2 + 64 * v20);
  v22 = (__n128 *)(a3 + 16 * v16);
  if (v15 != 5)
    v22 = (__n128 *)((char *)a2 + 64 * v16);
  v23 = (double *)(a3 + 16 * v14);
  if (v13 != 5)
    v23 = (double *)((char *)a2 + 64 * v14);
  v24 = (__n128 *)(a3 + 16 * v12);
  if (v11 != 5)
    v24 = (__n128 *)((char *)a2 + 64 * v12);
  *(double *)&v25 = v10(v18, *v24, *v23, *v22, *((float *)a2 + 16 * v17), *v21);
  *(_OWORD *)(a3 + 16 * a7) = v25;
}

double cikernel::_cmcubeopaque(uint64x2_t *a1, float32x4_t a2, int8x16_t a3, double a4, double a5, int8x16_t a6, double a7, double a8, int8x16_t a9)
{
  float32x4_t v11;
  float32x4_t v12;
  float v13;
  float v14;
  float32_t v15;
  float32x2_t v16;
  double v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x4_t v20;
  float64x2_t v21;
  double v22;
  double v23;
  int8x16_t v24;
  uint8x8_t v25;
  double v26;
  int8x16_t v27;
  float32x4_t v28;
  double result;
  float32x2_t v30;
  float32x4_t v31;

  a2.i32[3] = 0;
  v11 = vmaxnmq_f32(a2, (float32x4_t)xmmword_19249BC90);
  v11.i32[3] = 0;
  v12 = vmulq_n_f32(vminnmq_f32(v11, (float32x4_t)xmmword_19249BCA0), *(float *)a3.i32);
  v13 = v12.f32[2];
  v14 = fmaxf(floorf(v12.f32[2]), 0.0);
  *(float32x2_t *)v12.f32 = vadd_f32(*(float32x2_t *)v12.f32, (float32x2_t)0x3F0000003F000000);
  *(double *)a6.i64 = *(float *)a3.i32 + 1.0;
  v15 = *(double *)a6.i64 * v14;
  v16.i32[0] = 0;
  LODWORD(v17) = 0;
  *((float32_t *)&v17 + 1) = v15;
  v18 = vadd_f32(*(float32x2_t *)v12.f32, *(float32x2_t *)&v17);
  *(double *)a2.i64 = *(double *)a6.i64 * fminf(v14 + 1.0, *(float *)a3.i32);
  a2.f32[0] = *(double *)a2.i64;
  v16.i32[1] = a2.i32[0];
  v19 = vadd_f32(*(float32x2_t *)v12.f32, v16);
  v30 = (float32x2_t)vextq_s8(a3, a3, 8uLL).u64[0];
  *(double *)v20.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v30, v18)), (float64x2_t)a3, *(double *)&v18, *(double *)a2.i64, a6, (uint8x8_t)v16, v17, a9);
  v31 = v20;
  *(double *)v28.i64 = CI::BitmapSampler::read(a1, COERCE_DOUBLE(vmul_f32(v30, v19)), v21, v22, v23, v24, v25, v26, v27);
  *(_QWORD *)&result = vmlaq_n_f32(vmulq_n_f32(v31, 1.0 - (float)(v13 - v14)), v28, v13 - v14).u64[0];
  return result;
}

__n128 cikernel::_cm1x3lut(uint64x2_t *a1, float32x4_t a2, float32x4_t a3, double a4, double a5, int8x16_t a6, uint8x8_t a7, double a8, int8x16_t a9)
{
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float64x2_t v12;
  __n128 result;
  unsigned __int32 v14;

  v14 = a2.u32[3];
  v9 = a2;
  v9.i32[3] = 0;
  v10 = vmaxnmq_f32(v9, (float32x4_t)0);
  v10.i32[3] = 0;
  v11 = vmulq_f32(a3, vminnmq_f32(v10, (float32x4_t)xmmword_192491FD0));
  *(int32x2_t *)a3.f32 = vdup_lane_s32(*(int32x2_t *)a3.f32, 1);
  v12 = (float64x2_t)vaddq_f32(a3, v11);
  result.n128_f64[0] = CI::BitmapSampler::read(a1, COERCE_DOUBLE(LODWORD(v12.f64[0]) | 0x3F00000000000000), v12, 0.00781250185, *(double *)v9.i64, a6, a7, a8, a9);
  result.n128_u32[3] = v14;
  return result;
}

uint64_t CI::InstanceCounted<(CI::Type)4>::type()
{
  return 4;
}

_QWORD *CI::InstanceCounted<(CI::Type)4>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBBDD0;
  do
    v1 = __ldaxr(&dword_1ECF872F0[2]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[2]));
  return result;
}

void CI::InstanceCounted<(CI::Type)4>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBBDD0;
  do
    v1 = __ldaxr(&dword_1ECF872F0[2]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[2]));
  JUMPOUT(0x194025AACLL);
}

CI::CropNode *CI::CropImage::render_graph_core(uint64_t a1, uint64_t a2, CI::CropNode *a3, uint64_t a4, int a5)
{
  double v9;
  double v10;
  double v11;
  double v12;
  _QWORD *v13;
  double *v14;
  _QWORD *v15;
  CGFloat v16;
  CGFloat v17;
  CGFloat v18;
  CGFloat v19;
  unint64_t v20;
  double *v21;
  unint64_t v22;
  BOOL v23;
  _QWORD *v24;
  CGFloat v25;
  CGFloat v26;
  CGFloat v27;
  CGFloat v28;
  _BOOL4 IsEmpty;
  _BOOL4 v30;
  CI::FillNode *v31;
  _BOOL4 v33;
  CGRect v34;
  CGRect v35;
  CGRect v36;

  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1);
  v15 = *(_QWORD **)(a4 + 8);
  v14 = (double *)(a4 + 8);
  v13 = v15;
  if (!v15)
    goto LABEL_13;
  v16 = v9;
  v17 = v10;
  v18 = v11;
  v19 = v12;
  v20 = *(_QWORD *)(a1 + 80);
  v21 = v14;
  do
  {
    v22 = v13[4];
    v23 = v22 >= v20;
    if (v22 >= v20)
      v24 = v13;
    else
      v24 = v13 + 1;
    if (v23)
      v21 = (double *)v13;
    v13 = (_QWORD *)*v24;
  }
  while (*v24);
  if (v21 == v14)
    goto LABEL_13;
  if (v20 < *((_QWORD *)v21 + 4))
    goto LABEL_13;
  v25 = v21[5];
  v26 = v21[6];
  v27 = v21[7];
  v28 = v21[8];
  v34.origin.x = v25;
  v34.origin.y = v26;
  v34.size.width = v27;
  v34.size.height = v28;
  IsEmpty = CGRectIsEmpty(v34);
  v35.origin.x = v16;
  v35.origin.y = v17;
  v35.size.width = v18;
  v35.size.height = v19;
  v36.origin.x = v25;
  v36.origin.y = v26;
  v36.size.width = v27;
  v36.size.height = v28;
  v30 = CGRectContainsRect(v35, v36);
  if (IsEmpty)
  {
LABEL_13:
    v31 = (CI::FillNode *)operator new();
    CI::FillNode::FillNode(v31);
  }
  else
  {
    v33 = v30;
    if (a3)
      a3 = (CI::CropNode *)CI::Object::ref((uint64_t)a3);
    if (v33 && !CI_GRAPH_FORCE_CROP())
    {
      return a3;
    }
    else
    {
      v31 = (CI::FillNode *)CI::CropNode::append_to_tree(a3, (CI::Node *)(a5 < 2), *(CGRect *)(a1 + 120));
      if (a3)
        CI::Object::unref(a3);
    }
  }
  return v31;
}

uint64_t CI::CropImage::type(CI::CropImage *this)
{
  return 6;
}

uint64_t CI::CropImage::shape_for_graphviz(CI::CropImage *this)
{
  return 2;
}

uint64_t CI::CropImage::color_for_graphviz(CI::CropImage *this)
{
  return 3;
}

double CI::CropImage::roi_of_child(CI::CropImage *this, CGRect a2)
{
  double result;

  *(_QWORD *)&result = (unint64_t)CGRectIntersection(a2, *(CGRect *)((char *)this + 120));
  return result;
}

uint64_t CI::CropImage::extent_unclamped(CI::CropImage *this)
{
  return (*(uint64_t (**)(CI::CropImage *))(*(_QWORD *)this + 88))(this);
}

uint64_t CI::CropImage::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  return XXH64_update(a2, (char *)(a1 + 120), 0x20uLL);
}

uint64_t CI::CropImage::alpha_one(CI::CropImage *this)
{
  CGFloat v2;
  CGFloat v3;
  CGFloat v4;
  CGFloat v5;
  CGRect v7;
  CGRect v8;
  CGRect v9;
  CGRect v10;

  v7.origin.x = (*(double (**)(_QWORD))(**((_QWORD **)this + 13) + 88))(*((_QWORD *)this + 13));
  if (!CGRectContainsRect(v7, *(CGRect *)((char *)this + 120)))
    return 0;
  v2 = *((double *)this + 15);
  v3 = *((double *)this + 16);
  v4 = *((double *)this + 17);
  v5 = *((double *)this + 18);
  v8.origin.x = v2;
  v8.origin.y = v3;
  v8.size.width = v4;
  v8.size.height = v5;
  v10 = CGRectIntegral(v8);
  v9.origin.x = v2;
  v9.origin.y = v3;
  v9.size.width = v4;
  v9.size.height = v5;
  if (CGRectEqualToRect(v9, v10))
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 128))(*((_QWORD *)this + 13));
  else
    return 0;
}

size_t CI::CropImage::print_for_graph_core(CI::CropImage *this, __sFILE *__stream)
{
  __sFILE *v4;

  fwrite("crop ", 5uLL, 1uLL, __stream);
  return CI::fprintf(__stream, v4, *(CGRect *)((char *)this + 120));
}

uint64_t CI::CropImage::headroom(CI::CropImage *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 232))(*((_QWORD *)this + 13));
}

uint64_t CI::CropImage::colorspace(CI::CropImage *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 240))(*((_QWORD *)this + 13));
}

uint64_t `non-virtual thunk to'CI::CropImage::type(CI::CropImage *this)
{
  return 6;
}

void `non-virtual thunk to'CI::CropImage::~CropImage(CI::CropImage *this)
{
  CI::ImageWithChild *v1;
  unsigned int v2;

  *(_QWORD *)this = off_1E2EBBF88;
  v1 = (CI::CropImage *)((char *)this - 112);
  do
    v2 = __ldaxr(&dword_1ECF872F0[4]);
  while (__stlxr(v2 - 1, &dword_1ECF872F0[4]));
  CI::ImageWithChild::~ImageWithChild(v1);
}

{
  CI::ImageWithChild *v1;
  unsigned int v2;

  *(_QWORD *)this = off_1E2EBBF88;
  v1 = (CI::CropImage *)((char *)this - 112);
  do
    v2 = __ldaxr(&dword_1ECF872F0[4]);
  while (__stlxr(v2 - 1, &dword_1ECF872F0[4]));
  CI::ImageWithChild::~ImageWithChild(v1);
  JUMPOUT(0x194025AACLL);
}

CI::FillImage *CI::FillImage::FillImage(CI::FillImage *this, CGColor *a2)
{
  unsigned int v4;
  CI::Color *v5;
  unint64_t v6;
  int64x2_t v8[5];
  int __src;

  *(_QWORD *)(CI::Image::Image((uint64_t)this) + 104) = off_1E2EBC0C8;
  do
    v4 = __ldaxr(&dword_1ECF872F0[7]);
  while (__stlxr(v4 + 1, &dword_1ECF872F0[7]));
  *(_QWORD *)this = &off_1E2EBFF78;
  *((_QWORD *)this + 13) = &unk_1E2EC00C8;
  v5 = (CI::Color *)operator new();
  *((_QWORD *)this + 14) = CI::Color::Color(v5, a2);
  XXH64_reset(v8, 0);
  __src = (*(uint64_t (**)(CI::FillImage *))(*(_QWORD *)this + 16))(this);
  XXH64_update((uint64_t)v8, (char *)&__src, 4uLL);
  CI::XXHashHelper::add((CI::XXHashHelper *)v8, a2);
  v6 = XXH64_digest((uint64_t)v8);
  *((_QWORD *)this + 10) = v6;
  *((_QWORD *)this + 11) = v6;
  *((_WORD *)this + 48) = 1;
  return this;
}

char *CI::XXHashHelper::add(CI::XXHashHelper *this, CGColorRef color)
{
  CGColorSpace *ColorSpace;
  size_t NumberOfComponents;
  char *result;
  int __src;

  if (color)
  {
    ColorSpace = CGColorGetColorSpace(color);
    CI::XXHashHelper::add(this, ColorSpace);
    NumberOfComponents = CGColorGetNumberOfComponents(color);
    result = (char *)CGColorGetComponents(color);
    if (result)
    {
      if (8 * NumberOfComponents)
        return (char *)XXH64_update((uint64_t)this, result, 8 * NumberOfComponents);
    }
  }
  else
  {
    __src = 0;
    return (char *)XXH64_update((uint64_t)this, (char *)&__src, 4uLL);
  }
  return result;
}

CI::FillImage *CI::FillImage::FillImage(CI::FillImage *this, float a2, float a3, float a4, float a5)
{
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int64x2_t v15[5];
  uint64_t __src;

  *(_QWORD *)(CI::Image::Image((uint64_t)this) + 104) = off_1E2EBC0C8;
  do
    v10 = __ldaxr(&dword_1ECF872F0[7]);
  while (__stlxr(v10 + 1, &dword_1ECF872F0[7]));
  *(_QWORD *)this = &off_1E2EBFF78;
  *((_QWORD *)this + 13) = &unk_1E2EC00C8;
  if (a2 == 0.0 && a3 == 0.0 && a4 == 0.0 && a5 == 0.0)
  {
    v11 = 0;
  }
  else
  {
    v12 = operator new();
    v11 = CI::Color::Color(v12, a2, a3, a4, a5);
  }
  *((_QWORD *)this + 14) = v11;
  XXH64_reset(v15, 0);
  LODWORD(__src) = (*(uint64_t (**)(CI::FillImage *))(*(_QWORD *)this + 16))(this);
  XXH64_update((uint64_t)v15, (char *)&__src, 4uLL);
  if (*((_QWORD *)this + 14))
  {
    __src = *((_QWORD *)this + 14);
    XXH64_update((uint64_t)v15, (char *)&__src, 8uLL);
  }
  v13 = XXH64_digest((uint64_t)v15);
  *((_QWORD *)this + 10) = v13;
  *((_QWORD *)this + 11) = v13;
  *((_WORD *)this + 48) = 1;
  return this;
}

void CI::FillImage::~FillImage(CI::FillImage *this)
{
  CI::Object *v2;
  unsigned int v3;

  *(_QWORD *)this = &off_1E2EBFF78;
  *((_QWORD *)this + 13) = &unk_1E2EC00C8;
  v2 = (CI::Object *)*((_QWORD *)this + 14);
  if (v2)
    CI::Object::unref(v2);
  *((_QWORD *)this + 13) = off_1E2EBC0C8;
  *((_QWORD *)this + 14) = 0;
  do
    v3 = __ldaxr(&dword_1ECF872F0[7]);
  while (__stlxr(v3 - 1, &dword_1ECF872F0[7]));
  CI::Image::~Image(this);
}

{
  CI::FillImage::~FillImage(this);
  JUMPOUT(0x194025AACLL);
}

void `non-virtual thunk to'CI::FillImage::~FillImage(CI::FillImage *this)
{
  CI::FillImage::~FillImage((CI::FillImage *)((char *)this - 104));
}

{
  CI::FillImage::~FillImage((CI::FillImage *)((char *)this - 104));
  JUMPOUT(0x194025AACLL);
}

size_t CI::FillImage::print_for_graph_core(CI::FillImage *this, __sFILE *__stream)
{
  uint64_t v4;

  fwrite("fill ", 5uLL, 1uLL, __stream);
  v4 = *((_QWORD *)this + 14);
  if (v4)
    return (*(uint64_t (**)(uint64_t, __sFILE *, _QWORD))(*(_QWORD *)v4 + 32))(v4, __stream, 0);
  else
    return fwrite("clear", 5uLL, 1uLL, __stream);
}

CI::Node *CI::FillImage::render_graph_core(uint64_t a1)
{
  uint64_t v2;
  CI::FillNode *v3;

  v2 = *(_QWORD *)(a1 + 112);
  v3 = (CI::FillNode *)operator new();
  if (v2)
    return CI::FillNode::FillNode(v3, *(CI::Color **)(a1 + 112));
  else
    return CI::FillNode::FillNode(v3);
}

uint64_t CI::FillImage::child_count(CI::FillImage *this)
{
  return 0;
}

uint64_t CI::FillImage::child(CI::FillImage *this)
{
  return 0;
}

uint64_t CI::FillImage::shape_for_graphviz(CI::FillImage *this)
{
  return 1;
}

uint64_t CI::FillImage::color_for_graphviz(CI::FillImage *this)
{
  return 4;
}

double CI::FillImage::extent_unclamped(CI::FillImage *this)
{
  return 0.0;
}

uint64_t CI::FillImage::add_args_to_hash(uint64_t result, CI::XXHashHelper *this)
{
  uint64_t v2;
  uint64_t v4;

  v2 = *(_QWORD *)(result + 112);
  if (v2)
  {
    v4 = result;
    CI::XXHashHelper::add(this, *(CGColorSpaceRef *)(v2 + 40));
    return XXH64_update((uint64_t)this, (char *)(*(_QWORD *)(v4 + 112) + 24), 0x10uLL);
  }
  return result;
}

BOOL CI::FillImage::alpha_one(CI::FillImage *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 14);
  return v1 && *(float *)(v1 + 36) == 1.0;
}

uint64_t CI::FillImage::properties(CI::FillImage *this)
{
  return 0;
}

float CI::FillImage::headroom(CI::FillImage *this)
{
  return 0.0;
}

uint64_t CI::FillImage::colorspace(CI::FillImage *this)
{
  return 0;
}

uint64_t `non-virtual thunk to'CI::FillImage::type(CI::FillImage *this)
{
  return 9;
}

uint64_t CI::InstanceCounted<(CI::Type)9>::type()
{
  return 9;
}

_QWORD *CI::InstanceCounted<(CI::Type)9>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBC0C8;
  do
    v1 = __ldaxr(&dword_1ECF872F0[7]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[7]));
  return result;
}

void CI::InstanceCounted<(CI::Type)9>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBC0C8;
  do
    v1 = __ldaxr(&dword_1ECF872F0[7]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[7]));
  JUMPOUT(0x194025AACLL);
}

CI::Object *CI::GammaImage::render_graph_core(double *a1, uint64_t a2, uint64_t a3)
{
  CI::Node *v5;
  CI::PremultiplyNode *v6;
  CI::Object *v7;
  CI::GammaNode *v8;
  CI::Object *v9;

  v5 = (CI::Node *)(*(uint64_t (**)(double *))(*(_QWORD *)a1 + 184))(a1);
  if (a3)
  {
    v6 = (CI::PremultiplyNode *)CI::Object::ref(a3);
    v7 = CI::PremultiplyNode::append_to_tree(v6, (CI::Node *)0xFFFFFFFFLL, (int)v5);
    if (v6)
      CI::Object::unref(v6);
  }
  else
  {
    v7 = CI::PremultiplyNode::append_to_tree(0, (CI::Node *)0xFFFFFFFFLL, (int)v5);
  }
  v8 = CI::GammaNode::append_to_tree(v7, v5, a1[15]);
  if (v7)
    CI::Object::unref(v7);
  v9 = CI::PremultiplyNode::append_to_tree(v8, (CI::Node *)1, (int)v5);
  if (v8)
    CI::Object::unref(v8);
  return v9;
}

float CI::GammaImage::headroom(CI::GammaImage *this)
{
  uint64_t v2;
  float v3;
  float result;

  v2 = (*(uint64_t (**)(CI::GammaImage *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
  v3 = (*(float (**)(uint64_t))(*(_QWORD *)v2 + 232))(v2);
  result = 0.0;
  if (v3 >= 1.0)
    return pow(v3, *((long double *)this + 15));
  return result;
}

void CI::GammaImage::~GammaImage(CI::GammaImage *this)
{
  unsigned int v1;

  *(_QWORD *)this = &off_1E2EB8428;
  *((_QWORD *)this + 14) = off_1E2EBB7E0;
  *((_QWORD *)this + 15) = 0;
  do
    v1 = __ldaxr(&dword_1ECF872F0[8]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[8]));
  CI::ImageWithChild::~ImageWithChild(this);
}

{
  unsigned int v1;

  *(_QWORD *)this = &off_1E2EB8428;
  *((_QWORD *)this + 14) = off_1E2EBB7E0;
  *((_QWORD *)this + 15) = 0;
  do
    v1 = __ldaxr(&dword_1ECF872F0[8]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[8]));
  CI::ImageWithChild::~ImageWithChild(this);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::GammaImage::type(CI::GammaImage *this)
{
  return 10;
}

uint64_t CI::GammaImage::shape_for_graphviz(CI::GammaImage *this)
{
  return 2;
}

uint64_t CI::GammaImage::color_for_graphviz(CI::GammaImage *this)
{
  return 4;
}

uint64_t CI::GammaImage::add_args_to_hash(uint64_t a1, uint64_t a2)
{
  uint64_t __src;

  __src = *(_QWORD *)(a1 + 120);
  return XXH64_update(a2, (char *)&__src, 8uLL);
}

uint64_t CI::GammaImage::print_for_graph_core(CI::GammaImage *this, __sFILE *a2)
{
  return fprintf(a2, "gamma %g", *((double *)this + 15));
}

uint64_t `non-virtual thunk to'CI::GammaImage::type(CI::GammaImage *this)
{
  return 10;
}

void `non-virtual thunk to'CI::GammaImage::~GammaImage(CI::GammaImage *this)
{
  CI::ImageWithChild *v1;
  unsigned int v2;

  *(_QWORD *)this = off_1E2EBB7E0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this - 14) = &off_1E2EB8428;
  v1 = (CI::GammaImage *)((char *)this - 112);
  do
    v2 = __ldaxr(&dword_1ECF872F0[8]);
  while (__stlxr(v2 - 1, &dword_1ECF872F0[8]));
  CI::ImageWithChild::~ImageWithChild(v1);
}

{
  CI::ImageWithChild *v1;
  unsigned int v2;

  *(_QWORD *)this = off_1E2EBB7E0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this - 14) = &off_1E2EB8428;
  v1 = (CI::GammaImage *)((char *)this - 112);
  do
    v2 = __ldaxr(&dword_1ECF872F0[8]);
  while (__stlxr(v2 - 1, &dword_1ECF872F0[8]));
  CI::ImageWithChild::~ImageWithChild(v1);
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::ColorKernelImage::ColorKernelImage(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, int a5, int a6, double a7, double a8, double a9, double a10, float a11)
{
  unsigned int v18;
  __int128 v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  int *v23;
  unint64_t v24;
  uint64_t v25;
  CI::XXHashHelper **v26;
  int *v27;
  unint64_t v28;
  uint64_t v29;
  CI::XXHashHelper **v30;
  uint64_t v31;
  BOOL v32;
  char v33;
  int64x2_t v35[5];
  __int128 v36;
  __int128 v37;
  int __src;

  *(double *)&v36 = a7;
  *((double *)&v36 + 1) = a8;
  *(double *)&v37 = a9;
  *((double *)&v37 + 1) = a10;
  *(_QWORD *)(CI::Image::Image(a1) + 104) = off_1E2EBB808;
  do
    v18 = __ldaxr(&dword_1ECF872F0[9]);
  while (__stlxr(v18 + 1, &dword_1ECF872F0[9]));
  *(_QWORD *)a1 = &off_1E2EBC8C0;
  *(_QWORD *)(a1 + 104) = &unk_1E2EBCA18;
  *(_QWORD *)(a1 + 112) = a2;
  *(_DWORD *)(a1 + 176) = 0;
  if (a2 && *(_BYTE *)(a2 + 12))
    CI::Object::ref(a2);
  *(_QWORD *)(a1 + 120) = a3;
  v19 = v37;
  *(_OWORD *)(a1 + 128) = v36;
  *(_OWORD *)(a1 + 144) = v19;
  *(_QWORD *)(a1 + 160) = _Block_copy(a4);
  *(_BYTE *)(a1 + 168) = a5;
  if (a6 && (CI::format_has_alpha(a6) & 1) == 0)
    *(_BYTE *)(a1 + 168) = 1;
  *(_DWORD *)(a1 + 172) = a6;
  *(float *)(a1 + 176) = a11;
  *(_DWORD *)(a1 + 72) = 0;
  v20 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (v20 >= 1)
  {
    v21 = 0;
    v22 = *(_DWORD *)(a1 + 72);
    do
    {
      if (v22 <= *(_DWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, v21) + 72) + 1)
        v22 = *(_DWORD *)((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, v21) + 72) + 1;
      else
        v22 = *(_DWORD *)(a1 + 72);
      *(_DWORD *)(a1 + 72) = v22;
      v21 = (v21 + 1);
    }
    while (v20 != (_DWORD)v21);
  }
  XXH64_reset(v35, 0);
  __src = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  XXH64_update((uint64_t)v35, (char *)&__src, 4uLL);
  (*(void (**)(uint64_t, int64x2_t *))(*(_QWORD *)a2 + 64))(a2, v35);
  v23 = *(int **)(a1 + 120);
  if (*v23 >= 1)
  {
    v24 = 0;
    v25 = 6;
    do
    {
      if (v24 > 9)
        v26 = (CI::XXHashHelper **)(*((_QWORD *)v23 + 2) + 8 * (v24 - 10));
      else
        v26 = (CI::XXHashHelper **)&v23[v25];
      CI::Kernel::add_argument_to_digest((CI::Kernel *)v35, *v26, 0);
      ++v24;
      v23 = *(int **)(a1 + 120);
      v25 += 2;
    }
    while ((uint64_t)v24 < *v23);
  }
  XXH64_update((uint64_t)v35, (char *)&v36, 0x20uLL);
  __src = a5;
  XXH64_update((uint64_t)v35, (char *)&__src, 4uLL);
  __src = a6;
  XXH64_update((uint64_t)v35, (char *)&__src, 4uLL);
  *(_QWORD *)(a1 + 80) = XXH64_digest((uint64_t)v35);
  XXH64_reset(v35, 0);
  __src = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  XXH64_update((uint64_t)v35, (char *)&__src, 4uLL);
  (*(void (**)(uint64_t, int64x2_t *))(*(_QWORD *)a2 + 64))(a2, v35);
  v27 = *(int **)(a1 + 120);
  if (*v27 >= 1)
  {
    v28 = 0;
    v29 = 6;
    do
    {
      if (v28 > 9)
        v30 = (CI::XXHashHelper **)(*((_QWORD *)v27 + 2) + 8 * (v28 - 10));
      else
        v30 = (CI::XXHashHelper **)&v27[v29];
      CI::Kernel::add_argument_to_digest((CI::Kernel *)v35, *v30, (const CI::Object *)1);
      ++v28;
      v27 = *(int **)(a1 + 120);
      v29 += 2;
    }
    while ((uint64_t)v28 < *v27);
  }
  XXH64_update((uint64_t)v35, (char *)&v36, 0x20uLL);
  __src = a5;
  XXH64_update((uint64_t)v35, (char *)&__src, 4uLL);
  __src = a6;
  XXH64_update((uint64_t)v35, (char *)&__src, 4uLL);
  *(_QWORD *)(a1 + 88) = XXH64_digest((uint64_t)v35);
  *(_BYTE *)(a1 + 96) = *(_QWORD *)(a2 + 48) != 0;
  if (v20 >= 1)
  {
    v31 = 0;
    do
    {
      if (*(_BYTE *)((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, v31) + 96))
        v32 = *(_BYTE *)(a1 + 96) == 0;
      else
        v32 = 1;
      v33 = !v32;
      *(_BYTE *)(a1 + 96) = v33;
      v31 = (v31 + 1);
    }
    while (v20 != (_DWORD)v31);
  }
  *(_BYTE *)(a1 + 97) = 0;
  return a1;
}

void CI::ColorKernelImage::~ColorKernelImage(CI::ColorKernelImage *this)
{
  CI::Object *v2;
  CI::SerialObjectPtrArray *v3;
  unsigned int v4;

  *(_QWORD *)this = &off_1E2EBC8C0;
  *((_QWORD *)this + 13) = &unk_1E2EBCA18;
  v2 = (CI::Object *)*((_QWORD *)this + 14);
  if (v2 && *((_BYTE *)v2 + 12))
    CI::Object::unref(v2);
  v3 = (CI::SerialObjectPtrArray *)*((_QWORD *)this + 15);
  if (v3)
  {
    CI::SerialObjectPtrArray::~SerialObjectPtrArray(v3);
    MEMORY[0x194025AAC]();
  }
  _Block_release(*((const void **)this + 20));
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 13) = off_1E2EBB808;
  do
    v4 = __ldaxr(&dword_1ECF872F0[9]);
  while (__stlxr(v4 - 1, &dword_1ECF872F0[9]));
  CI::Image::~Image(this);
}

{
  CI::ColorKernelImage::~ColorKernelImage(this);
  JUMPOUT(0x194025AACLL);
}

void `non-virtual thunk to'CI::ColorKernelImage::~ColorKernelImage(CI::ColorKernelImage *this)
{
  CI::ColorKernelImage::~ColorKernelImage((CI::ColorKernelImage *)((char *)this - 104));
}

{
  CI::ColorKernelImage::~ColorKernelImage((CI::ColorKernelImage *)((char *)this - 104));
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::ColorKernelImage::properties(CI::ColorKernelImage *this)
{
  uint64_t v1;
  unint64_t v3;
  uint64_t i;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;

  v1 = **((unsigned int **)this + 15);
  if ((int)v1 < 1)
    return 0;
  v3 = 0;
  for (i = 24; ; i += 8)
  {
    v5 = *((_QWORD *)this + 15);
    v6 = (_QWORD *)(v3 > 9 ? *(_QWORD *)(v5 + 16) + 8 * (v3 - 10) : v5 + i);
    v7 = *v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v6 + 16))(*v6);
    if (CI::is_any_TypeImage(v8))
      break;
    if (v1 == ++v3)
      return 0;
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 200))(v7);
}

uint64_t CI::ColorKernelImage::avdepthdata(CI::ColorKernelImage *this)
{
  uint64_t v1;
  unint64_t v3;
  uint64_t i;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;

  v1 = **((unsigned int **)this + 15);
  if ((int)v1 < 1)
    return 0;
  v3 = 0;
  for (i = 24; ; i += 8)
  {
    v5 = *((_QWORD *)this + 15);
    v6 = (_QWORD *)(v3 > 9 ? *(_QWORD *)(v5 + 16) + 8 * (v3 - 10) : v5 + i);
    v7 = *v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v6 + 16))(*v6);
    if (CI::is_any_TypeImage(v8))
      break;
    if (v1 == ++v3)
      return 0;
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 208))(v7);
}

uint64_t CI::ColorKernelImage::avmatte(CI::ColorKernelImage *this)
{
  uint64_t v1;
  unint64_t v3;
  uint64_t i;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;

  v1 = **((unsigned int **)this + 15);
  if ((int)v1 < 1)
    return 0;
  v3 = 0;
  for (i = 24; ; i += 8)
  {
    v5 = *((_QWORD *)this + 15);
    v6 = (_QWORD *)(v3 > 9 ? *(_QWORD *)(v5 + 16) + 8 * (v3 - 10) : v5 + i);
    v7 = *v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v6 + 16))(*v6);
    if (CI::is_any_TypeImage(v8))
      break;
    if (v1 == ++v3)
      return 0;
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 216))(v7);
}

uint64_t CI::ColorKernelImage::ssmatte(CI::ColorKernelImage *this)
{
  uint64_t v1;
  unint64_t v3;
  uint64_t i;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;

  v1 = **((unsigned int **)this + 15);
  if ((int)v1 < 1)
    return 0;
  v3 = 0;
  for (i = 24; ; i += 8)
  {
    v5 = *((_QWORD *)this + 15);
    v6 = (_QWORD *)(v3 > 9 ? *(_QWORD *)(v5 + 16) + 8 * (v3 - 10) : v5 + i);
    v7 = *v6;
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v6 + 16))(*v6);
    if (CI::is_any_TypeImage(v8))
      break;
    if (v1 == ++v3)
      return 0;
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 224))(v7);
}

uint64_t CI::ColorKernelImage::add_args_to_hash(uint64_t a1, CI::Kernel *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CI::XXHashHelper **v8;
  CI::XXHashHelper *v9;
  int v10;
  unsigned int __src;
  uint64_t v13;

  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 64))(*(_QWORD *)(a1 + 112));
  __src = **(_DWORD **)(a1 + 120);
  v4 = __src;
  XXH64_update((uint64_t)a2, (char *)&__src, 4uLL);
  if ((int)v4 >= 1)
  {
    v5 = 0;
    v6 = 24;
    do
    {
      v7 = *(_QWORD *)(a1 + 120);
      if (v5 > 9)
        v8 = (CI::XXHashHelper **)(*(_QWORD *)(v7 + 16) + 8 * (v5 - 10));
      else
        v8 = (CI::XXHashHelper **)(v7 + v6);
      v9 = *v8;
      v10 = (*(uint64_t (**)(CI::XXHashHelper *))(*(_QWORD *)*v8 + 16))(*v8);
      if (!CI::is_any_TypeImage(v10))
        CI::Kernel::add_argument_to_digest(a2, v9, 0);
      ++v5;
      v6 += 8;
    }
    while (v4 != v5);
  }
  v13 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 56))(*(_QWORD *)(a1 + 112));
  return XXH64_update((uint64_t)a2, (char *)&v13, 8uLL);
}

uint64_t CI::ColorKernelImage::render_graph_core(_DWORD *a1, CGColorSpace **a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  CI::SerialObjectPtrArray *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t **v17;
  unint64_t *v18;
  int v19;
  uint64_t v20;
  CI::Object *v21;
  CI::Object *v22;
  CI::Object *v23;
  int v24;
  CI::Object *v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  CI::Node *v30;
  NSObject *v32;
  int v33;

  v9 = (uint64_t)(a1 + 28);
  v10 = (_QWORD *)*((_QWORD *)a1 + 14);
  if (!(*(uint64_t (**)(_QWORD *))(*v10 + 72))(v10)
    || v10[4]
    || (*((unsigned int (**)(CGColorSpace **))*a2 + 2))(a2) == 77)
  {
    v33 = a5;
    v11 = **((unsigned int **)a1 + 15);
    v12 = (CI::SerialObjectPtrArray *)operator new();
    CI::SerialObjectPtrArray::SerialObjectPtrArray(v12, v11);
    if ((int)v11 >= 1)
    {
      v13 = 0;
      v14 = 0;
      v15 = 24;
      do
      {
        v16 = *((_QWORD *)a1 + 15);
        if (v13 > 9)
          v17 = (unint64_t **)(*(_QWORD *)(v16 + 16) + 8 * (v13 - 10));
        else
          v17 = (unint64_t **)(v16 + v15);
        v18 = *v17;
        v19 = (*(uint64_t (**)(unint64_t *))(**v17 + 16))(*v17);
        if (!CI::is_any_TypeImage(v19))
        {
          if ((*(unsigned int (**)(unint64_t *))(*v18 + 16))(v18) == 59)
          {
            CI::Color::vector_in_workingspace((CI::Color *)v18, a2);
            v23 = v22;
            CI::SerialObjectPtrArray::append((uint64_t)v12, v22);
            if (v23)
              CI::Object::unref(v23);
          }
          else
          {
            CI::SerialObjectPtrArray::append((uint64_t)v12, (CI::Object *)v18);
          }
          v20 = v14;
          goto LABEL_20;
        }
        v20 = (v14 + 1);
        if (CI::Image::roi_of_child_intersects_extent((uint64_t)a1, a4, v14))
        {
          v21 = (CI::Object *)CI::ImageToNodeMap::findAndRef(a3, v18[10]);
          CI::SerialObjectPtrArray::append((uint64_t)v12, v21);
          if (!v21)
            goto LABEL_20;
        }
        else
        {
          v21 = (CI::Object *)operator new();
          CI::FillNode::FillNode(v21);
          CI::SerialObjectPtrArray::append((uint64_t)v12, v21);
        }
        CI::Object::unref(v21);
LABEL_20:
        ++v13;
        v15 += 8;
        v14 = v20;
      }
      while (v11 != v13);
    }
    v24 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)a1 + 184))(a1);
    v25 = CI::ColorKernelNode::append_to_tree(*((CI::Kernel **)a1 + 14), v12, *((const void **)a1 + 20), v24, *((_BYTE *)a1 + 168), a1[43], *((CGFloat *)a1 + 16), *((CGFloat *)a1 + 17), *((CGFloat *)a1 + 18), *((CGFloat *)a1 + 19));
    if ((*(unsigned int (**)(_DWORD *))(*(_QWORD *)a1 + 40))(a1) >= 2
      && CI_FORCE_INSERT_NOOPS() == 89
      && (*(unsigned int (**)(CI::Object *))(*(_QWORD *)v25 + 16))(v25) != 49)
    {
      v26 = (uint64_t)v25;
      do
      {
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v26 + 16))(v26) == 50)
          break;
        v26 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v26 + 48))(v26, 0);
      }
      while ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v26 + 16))(v26) != 49);
    }
    v27 = a1[43];
    if (v27 && (v28 = CI::format_component_count(v27), (v28 - 1) <= 1))
    {
      if (v28 == 1)
        v29 = 22;
      else
        v29 = 25;
      v30 = CI::SwizzleNode::append_to_tree(v25, v29, 1, 1);
      if (v25)
        CI::Object::unref(v25);
    }
    else
    {
      v30 = v25;
    }
    if (v33 >= 2)
      return CI::NoopNode::append_to_tree_and_unref(v30, (uint64_t)a2, 5);
  }
  else
  {
    v32 = ci_logger_render();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      CI::ColorKernelImage::render_graph_core(v9, (uint64_t)a2, v32);
    v30 = (CI::Node *)operator new();
    CI::FillNode::FillNode(v30);
  }
  return (uint64_t)v30;
}

BOOL CI::Image::roi_of_child_intersects_extent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v5;
  CGFloat v6;
  double v7;
  CGFloat v8;
  double v9;
  CGFloat v10;
  double v11;
  CGFloat v12;
  uint64_t v13;
  CGFloat v14;
  CGFloat v15;
  CGFloat v16;
  CGRect v18;
  CGRect v19;
  CGRect v20;

  v5 = CI::Image::lookup_union_roi(a1, a2);
  v6 = (*(double (**)(uint64_t, uint64_t, double))(*(_QWORD *)a1 + 80))(a1, a3, v5);
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, a3);
  v20.origin.x = (*(double (**)(uint64_t))(*(_QWORD *)v13 + 88))(v13);
  v20.origin.y = v14;
  v20.size.width = v15;
  v20.size.height = v16;
  v18.origin.x = v6;
  v18.origin.y = v8;
  v18.size.width = v10;
  v18.size.height = v12;
  v19 = CGRectIntersection(v18, v20);
  return !CGRectIsEmpty(v19);
}

uint64_t CI::ColorKernelImage::print_for_graph_core(CI::ColorKernelImage *this, __sFILE *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  const char *name;
  int v13;
  uint64_t result;
  const char *v15;

  fprintf(a2, "colorkernel %s", *(const char **)(*((_QWORD *)this + 14) + 24));
  v4 = **((unsigned int **)this + 15);
  if ((int)v4 >= 1)
  {
    v5 = 0;
    v6 = 24;
    do
    {
      v7 = *((_QWORD *)this + 15);
      if (v5 > 9)
        v8 = (uint64_t *)(*(_QWORD *)(v7 + 16) + 8 * (v5 - 10));
      else
        v8 = (uint64_t *)(v7 + v6);
      v9 = *v8;
      if (v5)
        v10 = 44;
      else
        v10 = 40;
      fputc(v10, a2);
      v11 = *((_QWORD *)this + 14);
      if (*(_BYTE *)(v11 + 12))
      {
        name = (const char *)CI::KernelArguments::get_name((CI::KernelArguments *)(v11 + 144), v5);
      }
      else if ((uint64_t)v5 >= *(int *)(v11 + 20))
      {
        name = 0;
      }
      else
      {
        name = *(const char **)(*(_QWORD *)(v11 + 80) + 8 * v5);
      }
      fputs(name, a2);
      v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 16))(v9);
      if (!CI::is_any_TypeImage(v13))
      {
        fputc(61, a2);
        (*(void (**)(uint64_t, __sFILE *, _QWORD))(*(_QWORD *)v9 + 32))(v9, a2, 0);
      }
      ++v5;
      v6 += 8;
    }
    while (v4 != v5);
  }
  if ((_DWORD)v4)
    fputc(41, a2);
  result = *((unsigned int *)this + 43);
  if ((_DWORD)result)
  {
    v15 = CI::name_for_format(result);
    return fprintf(a2, " outputFormat=%s", v15);
  }
  return result;
}

uint64_t CI::ColorKernelImage::child_count(CI::ColorKernelImage *this)
{
  uint64_t v1;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  int v8;

  v1 = **((unsigned int **)this + 15);
  if ((int)v1 < 1)
    return 0;
  v3 = 0;
  LODWORD(v4) = 0;
  v5 = 24;
  do
  {
    v6 = *((_QWORD *)this + 15);
    if (v3 > 9)
      v7 = (_QWORD *)(*(_QWORD *)(v6 + 16) + 8 * (v3 - 10));
    else
      v7 = (_QWORD *)(v6 + v5);
    v8 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v7 + 16))(*v7);
    v4 = (v4 + CI::is_any_TypeImage(v8));
    ++v3;
    v5 += 8;
  }
  while (v1 != v3);
  return v4;
}

uint64_t CI::ColorKernelImage::alpha_one(CI::ColorKernelImage *this)
{
  uint64_t result;

  if (*((_BYTE *)this + 168))
    return 1;
  if (!*(_BYTE *)(*((_QWORD *)this + 14) + 162))
    return 0;
  result = (*(uint64_t (**)(CI::ColorKernelImage *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 128))(result);
  return result;
}

uint64_t CI::ColorKernelImage::child(CI::ColorKernelImage *this, int a2)
{
  uint64_t v2;
  unint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;

  v2 = **((unsigned int **)this + 15);
  if ((int)v2 >= 1)
  {
    v5 = 0;
    v6 = 0;
    v7 = 24;
    do
    {
      v8 = *((_QWORD *)this + 15);
      if (v5 > 9)
        v9 = (_QWORD *)(*(_QWORD *)(v8 + 16) + 8 * (v5 - 10));
      else
        v9 = (_QWORD *)(v8 + v7);
      v10 = *v9;
      v11 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v9 + 16))(*v9);
      if (CI::is_any_TypeImage(v11))
      {
        if (v6 == a2)
          return v10;
        ++v6;
      }
      ++v5;
      v7 += 8;
    }
    while (v2 != v5);
  }
  return 0;
}

uint64_t CI::ColorKernelImage::child(CI::ColorKernelImage *this, int a2, BOOL *a3)
{
  uint64_t v3;
  unint64_t v7;
  int v8;
  uint64_t i;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int type;
  BOOL v18;

  v3 = **((unsigned int **)this + 15);
  if ((int)v3 < 1)
    return 0;
  v7 = 0;
  v8 = 0;
  for (i = 24; ; i += 8)
  {
    v10 = *((_QWORD *)this + 15);
    if (v7 > 9)
      v11 = (_QWORD *)(*(_QWORD *)(v10 + 16) + 8 * (v7 - 10));
    else
      v11 = (_QWORD *)(v10 + i);
    v12 = *v11;
    v13 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v11 + 16))(*v11);
    if (!CI::is_any_TypeImage(v13))
      goto LABEL_9;
    if (v8 == a2)
      break;
    ++v8;
LABEL_9:
    if (v3 == ++v7)
      return 0;
  }
  v14 = *((_QWORD *)this + 14);
  if (*(_BYTE *)(v14 + 12))
    v15 = CI::KernelArguments::count((CI::KernelArguments *)(v14 + 144));
  else
    v15 = *(_DWORD *)(v14 + 20);
  if (v15 <= (int)v7)
  {
    v18 = 0;
  }
  else
  {
    v16 = *((_QWORD *)this + 14);
    if (*(_BYTE *)(v16 + 12))
    {
      type = CI::KernelArguments::get_type((CI::KernelArguments *)(v16 + 144), v7);
    }
    else if (*(_DWORD *)(v16 + 20) <= (int)v7)
    {
      type = 0;
    }
    else
    {
      type = *(_DWORD *)(*(_QWORD *)(v16 + 72) + 4 * v7);
    }
    v18 = type == 4;
  }
  *a3 = v18;
  return v12;
}

double CI::ColorKernelImage::roi_of_child(CI::ColorKernelImage *this, CGRect a2, uint64_t a3)
{
  double height;
  double width;
  double y;
  double x;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  double v12;
  uint64_t v13;
  char v15;

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  if ((a3 & 0x80000000) == 0 && **((_DWORD **)this + 15) > (int)a3)
  {
    v15 = 0;
    v9 = (*(uint64_t (**)(CI::ColorKernelImage *, uint64_t, char *))(*(_QWORD *)this + 320))(this, a3, &v15);
    if (v15)
    {
      v10 = v9;
      v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 16))(v9);
      if (!CI::is_raster_TypeImage(v11))
        return *MEMORY[0x1E0C9D5E0];
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 96))(v10);
      return v12;
    }
    v13 = *((_QWORD *)this + 20);
    if (v13)
      return (*(double (**)(uint64_t, uint64_t, double, double, double, double))(v13 + 16))(v13, a3, x, y, width, height);
  }
  return x;
}

uint64_t CI::ColorKernelImage::color_for_graphviz(CI::ColorKernelImage *this)
{
  if (*(_BYTE *)(*((_QWORD *)this + 14) + 165))
    return 4;
  else
    return 3;
}

uint64_t CI::ColorKernelImage::print_for_graphviz(uint64_t a1, FILE *a2, _QWORD *a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _DWORD *v13;
  uint64_t v14;
  const char *name;
  int v16;
  _QWORD *v17;
  const __CFDictionary *v18;
  uint64_t result;
  const char *v20;
  _QWORD v21[5];
  char v22;
  _DWORD *v23;

  if (a4)
    v7 = 32;
  else
    v7 = 10;
  fprintf(a2, "colorkernel %s", *(const char **)(*(_QWORD *)(a1 + 112) + 24));
  v8 = **(unsigned int **)(a1 + 120);
  if ((int)v8 >= 1)
  {
    v9 = 0;
    v10 = 24;
    do
    {
      v11 = *(_QWORD *)(a1 + 120);
      if (v9 > 9)
        v12 = (_QWORD *)(*(_QWORD *)(v11 + 16) + 8 * (v9 - 10));
      else
        v12 = (_QWORD *)(v11 + v10);
      v13 = (_DWORD *)*v12;
      if ((*(int (**)(_QWORD))(*(_QWORD *)*v12 + 16))(*v12) >= 1
        && (*(int (**)(_DWORD *))(*(_QWORD *)v13 + 16))(v13) <= 25
        && (*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) == 1)
      {
        goto LABEL_25;
      }
      v14 = *(_QWORD *)(a1 + 112);
      if (*(_BYTE *)(v14 + 12))
      {
        name = (const char *)CI::KernelArguments::get_name((CI::KernelArguments *)(v14 + 144), v9);
      }
      else if ((uint64_t)v9 >= *(int *)(v14 + 20))
      {
        name = 0;
      }
      else
      {
        name = *(const char **)(*(_QWORD *)(v14 + 80) + 8 * v9);
      }
      fprintf(a2, "%c%s", v7, name);
      if ((*(int (**)(_DWORD *))(*(_QWORD *)v13 + 16))(v13) < 1
        || (*(int (**)(_DWORD *))(*(_QWORD *)v13 + 16))(v13) > 25)
      {
        fputc(61, a2);
        (*(void (**)(_DWORD *, FILE *, _QWORD))(*(_QWORD *)v13 + 32))(v13, a2, 0);
      }
      else
      {
        if (CI_GRAPHVIZ_INTERNAL())
        {
          v16 = v13[25];
LABEL_24:
          fprintf(a2, "=(%d)", v16);
          goto LABEL_25;
        }
        v23 = v13;
        v17 = std::__hash_table<void const*,std::hash<void const*>,std::equal_to<void const*>,std::allocator<void const*>>::find<void const*>(a3, &v23);
        if (v17)
        {
          v16 = *((_DWORD *)v17 + 6);
          goto LABEL_24;
        }
      }
LABEL_25:
      ++v9;
      v10 += 8;
    }
    while (v8 != v9);
  }
  v18 = (const __CFDictionary *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 40))(*(_QWORD *)(a1 + 112));
  if (v18)
  {
    v21[0] = MEMORY[0x1E0C809B0];
    v21[1] = 0x40000000;
    v21[2] = ___ZNK2CI16ColorKernelImage18print_for_graphvizEP7__sFILERKNSt3__113unordered_mapIPKNS_11GraphObjectEjNS3_4hashIS7_EENS3_8equal_toIS7_EENS3_9allocatorINS3_4pairIKS7_jEEEEEEb_block_invoke;
    v21[3] = &__block_descriptor_tmp_10;
    v21[4] = a2;
    v22 = v7;
    __CFDictionary::for_each(v18, v21);
  }
  result = *(unsigned int *)(a1 + 172);
  if ((_DWORD)result)
  {
    v20 = CI::name_for_format(result);
    return fprintf(a2, "%coutputFormat=%s", v7, v20);
  }
  return result;
}

void __CFDictionary::for_each(const __CFDictionary *a1, void *a2)
{
  if (a1)
  {
    if (CFDictionaryGetCount(a1))
      CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)__CFDictionary::_dictionaryApplierFunction, a2);
  }
}

void ___ZNK2CI16ColorKernelImage18print_for_graphvizEP7__sFILERKNSt3__113unordered_mapIPKNS_11GraphObjectEjNS3_4hashIS7_EENS3_8equal_toIS7_EENS3_9allocatorINS3_4pairIKS7_jEEEEEEb_block_invoke(uint64_t a1, __CFObject *a2, __CFObject *a3)
{
  __sFILE *v6;
  __sFILE *v7;

  fputc(*(char *)(a1 + 40), *(FILE **)(a1 + 32));
  __CFObject::fprint(a2, *(FILE **)(a1 + 32), v6);
  fputc(61, *(FILE **)(a1 + 32));
  __CFObject::fprint(a3, *(FILE **)(a1 + 32), v7);
}

void __CFObject::fprint(__CFObject *this, FILE *a2, __sFILE *a3)
{
  CFTypeID v5;
  __sFILE *v6;
  CFTypeID v7;
  __sFILE *v8;
  CFTypeID v9;
  const __CFString *v10;
  const __CFString *v11;
  const char *CStringPtr;
  char buffer[1024];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (this)
  {
    v5 = CFGetTypeID(this);
    if (v5 == CFBooleanGetTypeID())
    {
      __CFBoolean::fprint((uint64_t)this, a2, v6);
    }
    else
    {
      v7 = CFGetTypeID(this);
      if (v7 == CFNumberGetTypeID())
      {
        __CFNumber::fprint(this, a2, v8);
      }
      else
      {
        v9 = CFGetTypeID(this);
        if (v9 == CFStringGetTypeID())
          v10 = (const __CFString *)CFRetain(this);
        else
          v10 = CFCopyDescription(this);
        v11 = v10;
        if (v10)
        {
          bzero(buffer, 0x400uLL);
          CStringPtr = CFStringGetCStringPtr(v11, 0x8000100u);
          if (!CStringPtr)
          {
            if (CFStringGetCString(v11, buffer, 1024, 0x8000100u))
              CStringPtr = buffer;
            else
              CStringPtr = 0;
          }
          fputs(CStringPtr, a2);
          CFRelease(v11);
        }
      }
    }
  }
}

uint64_t CI::ColorKernelImage::type(CI::ColorKernelImage *this)
{
  return 11;
}

uint64_t CI::ColorKernelImage::shape_for_graphviz(CI::ColorKernelImage *this)
{
  return 1;
}

double CI::ColorKernelImage::extent(CI::ColorKernelImage *this)
{
  return *((double *)this + 16);
}

void CI::ColorKernelImage::extent_unclamped(CI::ColorKernelImage *this)
{
  int v2;
  int v3;
  CGFloat y;
  CGFloat x;
  CGFloat height;
  CGFloat width;
  int i;
  int v9;
  uint64_t v10;
  uint64_t **v11;
  uint64_t *v12;
  _BOOL4 IsInfinite;
  uint64_t v14;
  CGFloat v15;
  CGFloat v16;
  CGFloat v17;
  CGFloat v18;
  CGRect v19;
  CGRect v20;
  CGRect v21;
  CGRect v22;
  CGRect v23;
  CGRect v24;
  CGRect v25;
  CGRect v26;
  CGRect v27;

  v2 = CI::Kernel::num_image_arguments(*((CI::Kernel **)this + 14));
  v3 = v2;
  if (v2 < 2)
  {
    if (!v2)
      return;
  }
  else
  {
    CGRectIsInfinite(*((CGRect *)this + 4));
  }
  if (CGRectIsInfinite(*((CGRect *)this + 4)) && *(_BYTE *)(*((_QWORD *)this + 14) + 165))
  {
    x = *MEMORY[0x1E0C9D628];
    y = *(double *)(MEMORY[0x1E0C9D628] + 8);
    width = *(double *)(MEMORY[0x1E0C9D628] + 16);
    height = *(double *)(MEMORY[0x1E0C9D628] + 24);
    if (v3 >= 1)
    {
      for (i = 0; i != v3; ++i)
      {
        v9 = CI::Kernel::index_of_nth_image_argument(*((CI::Kernel **)this + 14), i);
        v10 = *((_QWORD *)this + 15);
        if (v9 > 9)
          v11 = (uint64_t **)(*(_QWORD *)(v10 + 16) + 8 * (v9 - 10));
        else
          v11 = (uint64_t **)(v10 + 8 * v9 + 24);
        v12 = *v11;
        v19.origin.x = (*(double (**)(uint64_t *))(**v11 + 88))(*v11);
        IsInfinite = CGRectIsInfinite(v19);
        v14 = *v12;
        if (IsInfinite)
        {
          (*(void (**)(uint64_t *))(v14 + 96))(v12);
        }
        else
        {
          v20.origin.x = (*(double (**)(uint64_t *))(v14 + 88))(v12);
          *(CGRect *)&v15 = CGRectInset(v20, -1.0, -1.0);
        }
        v26.origin.x = v15;
        v26.origin.y = v16;
        v26.size.width = v17;
        v26.size.height = v18;
        v21.origin.x = x;
        v21.origin.y = y;
        v21.size.width = width;
        v21.size.height = height;
        v22 = CGRectUnion(v21, v26);
        x = v22.origin.x;
        y = v22.origin.y;
        width = v22.size.width;
        height = v22.size.height;
      }
    }
    v23.origin.x = x;
    v23.origin.y = y;
    v23.size.width = width;
    v23.size.height = height;
    if (!CGRectIsNull(v23))
    {
      v24.origin.x = x;
      v24.origin.y = y;
      v24.size.width = width;
      v24.size.height = height;
      if (!CGRectIsEmpty(v24))
      {
        v25.origin.x = x;
        v25.origin.y = y;
        v25.size.width = width;
        v25.size.height = height;
        if (!CGRectIsInfinite(v25))
        {
          v27.origin.x = x;
          v27.origin.y = y;
          v27.size.width = width;
          v27.size.height = height;
          CGRectIntersection(*((CGRect *)this + 4), v27);
        }
      }
    }
  }
}

uint64_t CI::ColorKernelImage::is_warp(CI::ColorKernelImage *this)
{
  return 0;
}

uint64_t CI::ColorKernelImage::output_format(CI::ColorKernelImage *this)
{
  return *((unsigned int *)this + 43);
}

float CI::ColorKernelImage::headroom(CI::ColorKernelImage *this)
{
  float result;
  uint64_t v2;

  result = *((float *)this + 44);
  if (result < 1.0)
  {
    if (*(_BYTE *)(*((_QWORD *)this + 14) + 164))
    {
      v2 = (*(uint64_t (**)(CI::ColorKernelImage *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 232))(v2);
    }
    else
    {
      return 0.0;
    }
  }
  return result;
}

uint64_t CI::ColorKernelImage::colorspace(CI::ColorKernelImage *this)
{
  uint64_t v1;

  if (!*(_BYTE *)(*((_QWORD *)this + 14) + 164))
    return 0;
  v1 = (*(uint64_t (**)(CI::ColorKernelImage *, _QWORD))(*(_QWORD *)this + 48))(this, 0);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 240))(v1);
}

uint64_t `non-virtual thunk to'CI::ColorKernelImage::type(CI::ColorKernelImage *this)
{
  return 11;
}

uint64_t CI::ImageToNodeMap::findAndRef(uint64_t a1, unint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  unint64_t v6;
  BOOL v7;
  _QWORD *v8;
  uint64_t v9;

  v4 = *(_QWORD **)(a1 + 8);
  v2 = (_QWORD *)(a1 + 8);
  v3 = v4;
  if (!v4)
    return 0;
  v5 = v2;
  do
  {
    v6 = v3[4];
    v7 = v6 >= a2;
    if (v6 >= a2)
      v8 = v3;
    else
      v8 = v3 + 1;
    if (v7)
      v5 = v3;
    v3 = (_QWORD *)*v8;
  }
  while (*v8);
  if (v5 != v2 && v5[4] <= a2 && (v9 = v5[5]) != 0)
    return CI::Object::ref(v9);
  else
    return 0;
}

uint64_t __CFDictionary::_dictionaryApplierFunction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t __CFBoolean::fprint(uint64_t this, FILE *__stream, __sFILE *a3)
{
  uint64_t v4;

  if (this)
  {
    v4 = this;
    if (*MEMORY[0x1E0C9AE50] == this)
      this = fwrite("true", 4uLL, 1uLL, __stream);
    if (*MEMORY[0x1E0C9AE40] == v4)
      return fwrite("false", 5uLL, 1uLL, __stream);
  }
  return this;
}

const __CFNumber *__CFNumber::fprint(const __CFNumber *this, FILE *a2, __sFILE *a3)
{
  const __CFNumber *v4;
  CFTypeID v5;
  uint64_t valuePtr;

  if (this)
  {
    v4 = this;
    v5 = CFGetTypeID(this);
    this = (const __CFNumber *)CFNumberGetTypeID();
    if ((const __CFNumber *)v5 == this)
    {
      valuePtr = 0;
      if (CFNumberIsFloatType(v4))
      {
        CFNumberGetValue(v4, kCFNumberDoubleType, &valuePtr);
        return (const __CFNumber *)fprintf(a2, "%g");
      }
      else
      {
        CFNumberGetValue(v4, kCFNumberLongLongType, &valuePtr);
        return (const __CFNumber *)fprintf(a2, "%lld");
      }
    }
  }
  return this;
}

uint64_t CI::InstanceCounted<(CI::Type)11>::type()
{
  return 11;
}

_QWORD *CI::InstanceCounted<(CI::Type)11>::~InstanceCounted(_QWORD *result)
{
  unsigned int v1;

  *result = off_1E2EBB808;
  do
    v1 = __ldaxr(&dword_1ECF872F0[9]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[9]));
  return result;
}

void CI::InstanceCounted<(CI::Type)11>::~InstanceCounted(_QWORD *a1)
{
  unsigned int v1;

  *a1 = off_1E2EBB808;
  do
    v1 = __ldaxr(&dword_1ECF872F0[9]);
  while (__stlxr(v1 - 1, &dword_1ECF872F0[9]));
  JUMPOUT(0x194025AACLL);
}

void `non-virtual thunk to'CI::GeneralKernelImage::~GeneralKernelImage(CI::GeneralKernelImage *this)
{
  CI::GeneralKernelImage::~GeneralKernelImage((CI::GeneralKernelImage *)((char *)this - 104));
}

{
  CI::GeneralKernelImage::~GeneralKernelImage((CI::GeneralKernelImage *)((char *)this - 104));
  JUMPOUT(0x194025AACLL);
}

uint64_t CI::GeneralKernelImage::add_args_to_hash(uint64_t a1, CI::Kernel *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CI::XXHashHelper **v8;
  CI::XXHashHelper *v9;
  int v10;
  unsigned int __src;
  uint64_t v13;

  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 64))(*(_QWORD *)(a1 + 112));
  __src = **(_DWORD **)(a1 + 120);
  v4 = __src;
  XXH64_update((uint64_t)a2, (char *)&__src, 4uLL);
  if ((int)v4 >= 1)
  {
    v5 = 0;
    v6 = 24;
    do
    {
      v7 = *(_QWORD *)(a1 + 120);
      if (v5 > 9)
        v8 = (CI::XXHashHelper **)(*(_QWORD *)(v7 + 16) + 8 * (v5 - 10));
      else
        v8 = (CI::XXHashHelper **)(v7 + v6);
      v9 = *v8;
      v10 = (*(uint64_t (**)(CI::XXHashHelper *))(*(_QWORD *)*v8 + 16))(*v8);
      if (!CI::is_any_TypeImage(v10))
        CI::Kernel::add_argument_to_digest(a2, v9, 0);
      ++v5;
      v6 += 8;
    }
    while (v4 != v5);
  }
  v13 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 112) + 56))(*(_QWORD *)(a1 + 112));
  return XXH64_update((uint64_t)a2, (char *)&v13, 8uLL);
}

double CI::GeneralKernelImage::roi_of_child(CI::GeneralKernelImage *this, CGRect a2, uint64_t a3)
{
  double height;
  double width;
  double y;
  double x;
  uint64_t v9;
  double v10;
  uint64_t v11;
  unsigned int v12;

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  if ((a3 & 0x80000000) == 0 && **((_DWORD **)this + 15) > (int)a3)
  {
    if (!CI::GeneralKernelImage::child_type_is_image(this, a3))
    {
      v11 = (*(uint64_t (**)(CI::GeneralKernelImage *, uint64_t))(*(_QWORD *)this + 48))(this, a3);
      v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 16))(v11);
      if (!CI::is_raster_TypeImage(v12))
        return *MEMORY[0x1E0C9D5E0];
      return (*(double (**)(uint64_t))(*(_QWORD *)v11 + 96))(v11);
    }
    v9 = *((_QWORD *)this + 23);
    if (v9)
    {
      (*(void (**)(uint64_t, uint64_t, double, double, double, double))(v9 + 16))(v9, a3, x, y, width, height);
      return v10;
    }
  }
  return x;
}

BOOL CI::GeneralKernelImage::child_type_is_image(CI::GeneralKernelImage *this, int a2)
{
  uint64_t v2;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unsigned int type;

  v2 = **((unsigned int **)this + 15);
  if ((int)v2 < 1)
    return 0;
  v5 = 0;
  v6 = 0;
  while (1)
  {
    v7 = *((_QWORD *)this + 14);
    if (*(_BYTE *)(v7 + 12))
    {
      type = CI::KernelArguments::get_type((CI::KernelArguments *)(v7 + 144), v5);
      goto LABEL_7;
    }
    if (v5 < *(int *)(v7 + 20))
      break;
LABEL_13:
    if (v2 == ++v5)
      return 0;
  }
  type = *(_DWORD *)(*(_QWORD *)(v7 + 72) + 4 * v5);
LABEL_7:
  if (type > 4 || ((1 << type) & 0x16) == 0)
    goto LABEL_13;
  if (v6 != a2)
  {
    ++v6;
    goto LABEL_13;
  }
  return type - 1 < 2;
}

void *CI::GeneralKernelImage::restore_resources(void **this, CI::Node *a2)
{
  void *result;

  result = (void *)(*(uint64_t (**)(CI::Node *))(*(_QWORD *)a2 + 16))(a2);
  if ((_DWORD)result == 51)
    return CI::GeneralKernelNode::set_roi_callback((uint64_t)a2, this[23]);
  return result;
}

void *CI::GeneralKernelNode::set_roi_callback(uint64_t a1, void *aBlock)
{
  const void *v4;
  void *result;

  v4 = *(const void **)(a1 + 120);
  if (v4)
    _Block_release(v4);
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 120) = result;
  return result;
}

uint64_t CI::GeneralKernelImage::print_for_graph_core(CI::GeneralKernelImage *this, __sFILE *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  const char *name;
  int v13;
  uint64_t result;
  const char *v15;

  fprintf(a2, "kernel %s", *(const char **)(*((_QWORD *)this + 14) + 24));
  v4 = **((unsigned int **)this + 15);
  if ((int)v4 >= 1)
  {
    v5 = 0;
    v6 = 24;
    do
    {
      v7 = *((_QWORD *)this + 15);
      if (v5 > 9)
        v8 = (uint64_t *)(*(_QWORD *)(v7 + 16) + 8 * (v5 - 10));
      else
        v8 = (uint64_t *)(v7 + v6);
      v9 = *v8;
      if (v5)
        v10 = 44;
      else
        v10 = 40;
      fputc(v10, a2);
      v11 = *((_QWORD *)this + 14);
      if (*(_BYTE *)(v11 + 12))
      {
        name = (const char *)CI::KernelArguments::get_name((CI::KernelArguments *)(v11 + 144), v5);
      }
      else if ((uint64_t)v5 >= *(int *)(v11 + 20))
      {
        name = 0;
      }
      else
      {
        name = *(const char **)(*(_QWORD *)(v11 + 80) + 8 * v5);
      }
      fputs(name, a2);
      v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 16))(v9);
      if (!CI::is_any_TypeImage(v13))
      {
        fputc(61, a2);
        (*(void (**)(uint64_t, __sFILE *, _QWORD))(*(_QWORD *)v9 + 32))(v9, a2, 0);
      }
      ++v5;
      v6 += 8;
    }
    while (v4 != v5);
  }
  if ((_DWORD)v4)
    fputc(41, a2);
  result = *((unsigned int *)this + 49);
  if ((_DWORD)result)
  {
    v15 = CI::name_for_format(result);
    return fprintf(a2, " outputFormat=%s", v15);
  }
  return result;
}

CI::Object *CI::GeneralKernelImage::render_graph_core(uint64_t a1, CGColorSpace **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  _QWORD *v7;
  CI::SerialObjectPtrArray *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int type;
  uint64_t v15;
  unint64_t **v16;
  unint64_t *v17;
  int v18;
  uint64_t v20;
  CI::Object *v21;
  CI::Object *v22;
  CI::Object *v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  CI::Object *v30;
  NSObject *v32;

  v6 = a1 + 112;
  v7 = *(_QWORD **)(a1 + 112);
  if ((*(uint64_t (**)(_QWORD *))(*v7 + 72))(v7)
    && !v7[4]
    && (*((unsigned int (**)(CGColorSpace **))*a2 + 2))(a2) != 77)
  {
    v32 = ci_logger_render();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      CI::ColorKernelImage::render_graph_core(v6, (uint64_t)a2, v32);
    v24 = operator new();
    CI::FillNode::FillNode((CI::FillNode *)v24);
    return (CI::Object *)v24;
  }
  v8 = (CI::SerialObjectPtrArray *)operator new();
  CI::SerialObjectPtrArray::SerialObjectPtrArray(v8, **(_DWORD **)(a1 + 120));
  v9 = **(unsigned int **)(a1 + 120);
  if ((int)v9 >= 1)
  {
    v10 = 0;
    v11 = 0;
    v12 = 24;
    do
    {
      v13 = *(_QWORD *)v6;
      if (*(_BYTE *)(*(_QWORD *)v6 + 12))
      {
        type = CI::KernelArguments::get_type((CI::KernelArguments *)(v13 + 144), v10);
      }
      else if ((uint64_t)v10 >= *(int *)(v13 + 20))
      {
        type = 0;
      }
      else
      {
        type = *(_DWORD *)(*(_QWORD *)(v13 + 72) + 4 * v10);
      }
      v15 = *(_QWORD *)(a1 + 120);
      if (v10 > 9)
        v16 = (unint64_t **)(*(_QWORD *)(v15 + 16) + 8 * (v10 - 10));
      else
        v16 = (unint64_t **)(v15 + v12);
      v17 = *v16;
      v18 = (*(uint64_t (**)(unint64_t *))(**v16 + 16))(*v16);
      if (type > 4 || ((1 << type) & 0x16) == 0)
      {
        if (v18 == 59)
        {
          CI::Color::vector_in_workingspace((CI::Color *)v17, a2);
          v23 = v22;
          CI::SerialObjectPtrArray::append((uint64_t)v8, v22);
          if (v23)
            CI::Object::unref(v23);
        }
        else
        {
          CI::SerialObjectPtrArray::append((uint64_t)v8, (CI::Object *)v17);
        }
        v20 = v11;
        goto LABEL_28;
      }
      v20 = (v11 + 1);
      if (CI::Image::roi_of_child_intersects_extent(a1, a4, v11))
      {
        v21 = (CI::Object *)CI::ImageToNodeMap::findAndRef(a3, v17[10]);
        CI::SerialObjectPtrArray::append((uint64_t)v8, v21);
        if (!v21)
          goto LABEL_28;
      }
      else
      {
        v21 = (CI::Object *)operator new();
        CI::FillNode::FillNode(v21);
        CI::SerialObjectPtrArray::append((uint64_t)v8, v21);
      }
      CI::Object::unref(v21);
LABEL_28:
      ++v10;
      v12 += 8;
      v11 = v20;
    }
    while (v9 != v10);
  }
  v24 = CI::GeneralKernelNode::append_to_tree(*(_QWORD *)(a1 + 112), (uint64_t)v8, a1 + 128, *(const void **)(a1 + 184), *(_BYTE *)(a1 + 192), *(_DWORD *)(a1 + 196), *(double *)(a1 + 152), *(double *)(a1 + 160), *(double *)(a1 + 168), *(double *)(a1 + 176));
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v24 + 16))(v24) == 51)
  {
    v25 = *(_DWORD *)(a1 + 208);
    *(_QWORD *)(v24 + 136) = *(_QWORD *)(a1 + 200);
    *(_DWORD *)(v24 + 144) = v25;
    v26 = *(_DWORD *)(a1 + 220);
    *(_QWORD *)(v24 + 148) = *(_QWORD *)(a1 + 212);
    *(_DWORD *)(v24 + 156) = v26;
  }
  v27 = *(_DWORD *)(a1 + 196);
  if (!v27)
    return (CI::Object *)v24;
  v28 = CI::format_component_count(v27);
  if ((v28 - 1) > 1)
    return (CI::Object *)v24;
  if (v28 == 1)
    v29 = 22;
  else
    v29 = 25;
  v30 = CI::SwizzleNode::append_to_tree((CI::Object *)v24, v29, 1, 1);
  CI::Object::unref((CI::Object *)v24);
  return v30;
}

uint64_t CI::GeneralKernelImage::properties(CI::GeneralKernelImage *this)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t i;
  uint64_t v5;
  int type;
  uint64_t v8;
  _QWORD *v9;

  v1 = **((unsigned int **)this + 15);
  if ((int)v1 < 1)
    return 0;
  v3 = 0;
  for (i = 24; ; i += 8)
  {
    v5 = *((_QWORD *)this + 14);
    if (*(_BYTE *)(v5 + 12))
    {
      type = CI::KernelArguments::get_type((CI::KernelArguments *)(v5 + 144), v3);
      goto LABEL_7;
    }
    if (v3 < *(int *)(v5 + 20))
      break;
LABEL_8:
    if (v1 == ++v3)
      return 0;
  }
  type = *(_DWORD *)(*(_QWORD *)(v5 + 72) + 4 * v3);
LABEL_7:
  if ((type - 3) < 0xFFFFFFFE)
    goto LABEL_8;
  v8 = *((_QWORD *)this + 15);
  if (v3 > 9)
    v9 = (_QWORD *)(*(_QWORD *)(v8 + 16) + 8 * (v3 - 10));
  else
    v9 = (_QWORD *)(v8 + i);
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v9 + 200))(*v9);
}

uint64_t CI::GeneralKernelImage::avdepthdata(CI::GeneralKernelImage *this)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t i;
  uint64_t v5;
  int type;
  uint64_t v8;
  _QWORD *v9;

  v1 = **((unsigned int **)this + 15);
  if ((int)v1 < 1)
    return 0;
  v3 = 0;
  for (i = 24; ; i += 8)
  {
    v5 = *((_QWORD *)this + 14);
    if (*(_BYTE *)(v5 + 12))
    {
      type = CI::KernelArguments::get_type((CI::KernelArguments *)(v5 + 144), v3);
      goto LABEL_7;
    }
    if (v3 < *(int *)(v5 + 20))
      break;
LABEL_8:
    if (v1 == ++v3)
      return 0;
  }
  type = *(_DWORD *)(*(_QWORD *)(v5 + 72) + 4 * v3);
LABEL_7:
  if ((type - 3) < 0xFFFFFFFE)
    goto LABEL_8;
  v8 = *((_QWORD *)this + 15);
  if (v3 > 9)
    v9 = (_QWORD *)(*(_QWORD *)(v8 + 16) + 8 * (v3 - 10));
  else
    v9 = (_QWORD *)(v8 + i);
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v9 + 208))(*v9);
}

