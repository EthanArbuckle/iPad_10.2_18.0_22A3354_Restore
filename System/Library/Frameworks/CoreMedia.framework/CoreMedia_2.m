_DWORD *_figApplyNormalizedCGRectToFigGeometryRect@<X0>(__int128 *a1@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>, double a5@<D2>, double a6@<D3>)
{
  __int128 v12;
  __int128 v13;
  double CGRect;
  double v15;
  double v16;
  double v17;
  __int128 v18;
  __int128 v19;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;

  v12 = a1[1];
  v21 = *a1;
  v22 = v12;
  v13 = a1[3];
  v23 = a1[2];
  v24 = v13;
  CGRect = FigGeometryRectGetCGRect((uint64_t)&v21);
  v18 = a1[1];
  v21 = *a1;
  v22 = v18;
  v19 = a1[3];
  v23 = a1[2];
  v24 = v19;
  return FigGeometryRectMakeFromCGRectAndReferenceUnits(&v21, a2, CGRect + v15 * a3, v16 + v17 * a4, a5 * v15, a6 * v17);
}

uint64_t FigGeometryMappingCreateInverseMapping(uint64_t a1, uint64_t *a2)
{
  CFTypeID v4;
  uint64_t Instance;
  uint64_t v6;
  const void *v7;
  const void *v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  __int128 v15;
  __int128 v16;
  uint64_t v18;

  if (!a1 || !a2)
    goto LABEL_17;
  v4 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFigGeometryMappingTypeOnce != -1)
    dispatch_once_f(&sRegisterFigGeometryMappingTypeOnce, 0, (dispatch_function_t)RegisterFigGeometryMappingType);
  if (v4 != sFigGeometryMappingID || *(_DWORD *)(a1 + 20) != 1)
  {
LABEL_17:
    v18 = 4294949966;
    return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
  }
  *a2 = 0;
  CFGetAllocator((CFTypeRef)a1);
  if (sRegisterFigGeometryMappingTypeOnce != -1)
    dispatch_once_f(&sRegisterFigGeometryMappingTypeOnce, 0, (dispatch_function_t)RegisterFigGeometryMappingType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v18 = 4294949965;
    return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
  }
  v6 = Instance;
  memcpy((void *)(Instance + 16), (const void *)(a1 + 16), 0x348uLL);
  v7 = *(const void **)(v6 + 128);
  if (v7)
    CFRetain(v7);
  v8 = *(const void **)(v6 + 136);
  if (v8)
    CFRetain(v8);
  *(_DWORD *)(v6 + 16) = 1835102313;
  *(_BYTE *)(v6 + 120) = 1;
  v9 = *(double *)(a1 + 24);
  v10 = 1.0 / v9;
  v11 = -*(double *)(a1 + 32) / v9;
  *(double *)(v6 + 24) = v10;
  *(double *)(v6 + 32) = v11;
  v12 = *(double *)(a1 + 40);
  v13 = 1.0 / v12;
  v14 = -*(double *)(a1 + 48) / v12;
  *(double *)(v6 + 40) = v13;
  *(double *)(v6 + 48) = v14;
  v15 = *(_OWORD *)(a1 + 88);
  *(_OWORD *)(v6 + 72) = *(_OWORD *)(a1 + 104);
  *(_OWORD *)(v6 + 56) = v15;
  v16 = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v6 + 104) = *(_OWORD *)(a1 + 72);
  *(_OWORD *)(v6 + 88) = v16;
  memcpy((void *)(v6 + 144), (const void *)(a1 + 496), 0x160uLL);
  memcpy((void *)(v6 + 496), (const void *)(a1 + 144), 0x160uLL);
  *(_DWORD *)(v6 + 848) = *(_DWORD *)(a1 + 852);
  *(_DWORD *)(v6 + 852) = *(_DWORD *)(a1 + 848);
  *a2 = v6;
  return 0;
}

uint64_t FigGeometryMappingCreateCEA608Mappings(uint64_t a1, uint64_t *a2, uint64_t a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66[4];
  CFTypeRef v67;
  CFTypeRef v68;
  CFTypeRef cf;
  __int128 v70[4];
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  _OWORD v75[4];
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  CFTypeRef v80;
  CFTypeRef v81;
  CFTypeRef v82;
  uint64_t v83;

  v82 = 0;
  v83 = a3;
  v80 = 0;
  v81 = 0;
  v78 = 0u;
  v79 = 0u;
  v76 = 0u;
  v77 = 0u;
  memset(v75, 0, sizeof(v75));
  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  memset(v70, 0, sizeof(v70));
  v68 = 0;
  cf = 0;
  v67 = 0;
  if (a4 && a5 && a6 && *((_DWORD *)a2 + 2) == 1886679840 && *((_DWORD *)a2 + 6) == 1886679840)
  {
    FigGeometryDimensionMake();
    v12 = v11;
    v14 = v13;
    FigGeometryDimensionMake();
    FigGeometryPointMake(v12, v14, v15, v16, v66);
    FigGeometryRectMake(v66[0], v66[1], v66[2], v66[3], *a2, a2[1], a2[2], a2[3], &v76);
    FigGeometryDimensionMake();
    v18 = v17;
    v20 = v19;
    FigGeometryDimensionMake();
    v22 = v21;
    v24 = v23;
    FigGeometryDimensionMake();
    v26 = v25;
    v28 = v27;
    FigGeometryDimensionMake();
    FigGeometryRectMake(v22, v24, v26, v28, v18, v20, v29, v30, v75);
    FigGeometryDimensionMake();
    v32 = v31;
    v34 = v33;
    FigGeometryDimensionMake();
    v36 = v35;
    v38 = v37;
    FigGeometryDimensionMake();
    v40 = v39;
    v42 = v41;
    FigGeometryDimensionMake();
    FigGeometryRectMake(v32, v34, v36, v38, v40, v42, v43, v44, &v71);
    FigGeometryDimensionMake();
    v46 = v45;
    v48 = v47;
    FigGeometryDimensionMake();
    v50 = v49;
    v52 = v51;
    FigGeometryDimensionMake();
    v54 = v53;
    v56 = v55;
    FigGeometryDimensionMake();
    FigGeometryMarginsMake(v46, v48, v50, v52, v54, v56, v57, v58, v70);
    v62 = v76;
    v63 = v77;
    v64 = v78;
    v65 = v79;
    v59 = FigGeometryCoordinateSpaceCreate(a1, (uint64_t)&v62, v70, (uint64_t)v75, (uint64_t)&v83, 1918989168, (uint64_t *)&cf);
    if ((_DWORD)v59)
      goto LABEL_26;
    v62 = v71;
    v63 = v72;
    v64 = v73;
    v65 = v74;
    v59 = FigGeometryCoordinateSpaceCreate(a1, (uint64_t)&v62, 0, 0, 0, 0, (uint64_t *)&v67);
    if ((_DWORD)v59
      || (v62 = v76,
          v63 = v77,
          v64 = v78,
          v65 = v79,
          v59 = FigGeometryCoordinateSpaceCreate(a1, (uint64_t)&v62, 0, 0, 0, 0, (uint64_t *)&v68),
          (_DWORD)v59)
      || (v59 = FigGeometryMappingCreate(a1, cf, 1, v68, 1, (uint64_t *)&v82), (_DWORD)v59)
      || (v59 = FigGeometryMappingCreate(a1, cf, 1, v67, 1, (uint64_t *)&v81), (_DWORD)v59))
    {
LABEL_26:
      v60 = v59;
    }
    else
    {
      v60 = FigGeometryMappingCreate(a1, v67, 1, v68, 1, (uint64_t *)&v80);
      if (!(_DWORD)v60)
      {
        *a4 = v82;
        *a5 = v81;
        v81 = 0;
        v82 = 0;
        *a6 = v80;
        v80 = 0;
        goto LABEL_13;
      }
    }
    FigSignalErrorAt(v60, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v60 = FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  }
LABEL_13:
  if (v82)
    CFRelease(v82);
  if (v81)
    CFRelease(v81);
  if (v80)
    CFRelease(v80);
  if (cf)
    CFRelease(cf);
  if (v68)
    CFRelease(v68);
  if (v67)
    CFRelease(v67);
  return v60;
}

uint64_t FigGeometryMappingConvertDimensionToDimension(double *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  double v5;
  double v6;
  double v7;
  double *v8;
  double *v9;

  v5 = 0.0;
  if (!a1)
  {
    FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
    return *(_QWORD *)&v5;
  }
  if ((BYTE4(a3) & 0x1D) == 1)
  {
    if (a5 == 1)
    {
      v8 = a1 + 3;
      v9 = a1 + 4;
    }
    else
    {
      v6 = 0.0;
      v7 = 0.0;
      if (a5 != 2)
        goto LABEL_11;
      v8 = a1 + 5;
      v9 = a1 + 6;
    }
    v6 = *v8;
    v7 = *v9;
LABEL_11:
    if (a4)
      v5 = v6 * *(double *)&a2;
    else
      v5 = v7 + *(double *)&a2 * v6;
    return *(_QWORD *)&v5;
  }
  if ((~HIDWORD(a3) & 0x11) == 0)
    v5 = *(double *)&a2;
  return *(_QWORD *)&v5;
}

uint64_t FigGeometryMappingConvertPointToPoint@<X0>(double *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;

  *(_OWORD *)a3 = kFigGeometryPointInvalid;
  *(_OWORD *)(a3 + 16) = unk_18EDDCA38;
  if (!a1)
    return FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  *(_QWORD *)a3 = FigGeometryMappingConvertDimensionToDimension(a1, *a2, a2[1], 0, 1);
  *(_QWORD *)(a3 + 8) = v6;
  result = FigGeometryMappingConvertDimensionToDimension(a1, a2[2], a2[3], 0, 2);
  *(_QWORD *)(a3 + 16) = result;
  *(_QWORD *)(a3 + 24) = v8;
  return result;
}

uint64_t FigGeometryMappingConvertSizeToSize@<X0>(double *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;

  *(_OWORD *)a3 = kFigGeometrySizeInvalid;
  *(_OWORD *)(a3 + 16) = unk_18EDDCA58;
  if (!a1)
    return FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  *(_QWORD *)a3 = FigGeometryMappingConvertDimensionToDimension(a1, *a2, a2[1], 1, 1);
  *(_QWORD *)(a3 + 8) = v6;
  result = FigGeometryMappingConvertDimensionToDimension(a1, a2[2], a2[3], 1, 2);
  *(_QWORD *)(a3 + 16) = result;
  *(_QWORD *)(a3 + 24) = v8;
  return result;
}

uint64_t FigGeometryMappingConvertVectorToVector@<X0>(double *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;

  *(_OWORD *)a3 = kFigGeometryVectorInvalid;
  *(_OWORD *)(a3 + 16) = unk_18EDDCA78;
  if (!a1)
    return FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  *(_QWORD *)a3 = FigGeometryMappingConvertDimensionToDimension(a1, *a2, a2[1], 1, 1);
  *(_QWORD *)(a3 + 8) = v6;
  result = FigGeometryMappingConvertDimensionToDimension(a1, a2[2], a2[3], 1, 2);
  *(_QWORD *)(a3 + 16) = result;
  *(_QWORD *)(a3 + 24) = v8;
  return result;
}

uint64_t FigGeometryMappingConvertRectToRect@<X0>(double *a1@<X0>, __int128 *a2@<X1>, _OWORD *a3@<X8>)
{
  __int128 v6;
  __int128 v7;
  __int128 v9;
  __int128 v10;

  *a3 = kFigGeometryRectInvalid;
  a3[1] = unk_18EDDCA98;
  a3[2] = xmmword_18EDDCAA8;
  a3[3] = unk_18EDDCAB8;
  if (!a1)
    return FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  v6 = a2[1];
  v9 = *a2;
  v10 = v6;
  FigGeometryMappingConvertPointToPoint(a1, (uint64_t *)&v9, (uint64_t)a3);
  v7 = a2[3];
  v9 = a2[2];
  v10 = v7;
  return FigGeometryMappingConvertSizeToSize(a1, (uint64_t *)&v9, (uint64_t)(a3 + 2));
}

void fgInit_Mapping(uint64_t a1)
{
  bzero((void *)(a1 + 16), 0x348uLL);
}

void fgFinalize_Mapping(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 128);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 128) = 0;
  }
  v3 = *(const void **)(a1 + 136);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 136) = 0;
  }
}

__CFString *fgCopyDesc_Mapping(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  __CFString *v4;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = Mutable;
  if (a1)
  {
    if (*(_DWORD *)(a1 + 20) == 1)
      CFStringAppendFormat(Mutable, 0, CFSTR("<FigGeometryMappingRef %p> srcSpace:%p srcPart:%d, destSpace: %p, destPart:%d"), a1, *(_QWORD *)(a1 + 128), *(unsigned int *)(a1 + 848), *(_QWORD *)(a1 + 136), *(unsigned int *)(a1 + 852));
    else
      CFStringAppendFormat(Mutable, 0, CFSTR("<FigGeometryMappingRef %p> [UNKNOWN MAPPING TYPE]"), a1);
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("<FigGeometryMappingRef %p>"), 0);
  }
  return v4;
}

CFDictionaryRef FigCaptionGeometryCopyCellBasedDimensionAsDictionary(const __CFAllocator *a1, double a2)
{
  const __CFAllocator *v3;
  CFDictionaryRef v4;
  uint64_t i;
  const void *v6;
  int v8;
  int v9;
  double valuePtr;
  void *values[3];
  void *keys[4];

  keys[3] = *(void **)MEMORY[0x1E0C80C00];
  valuePtr = a2;
  v9 = 1667591276;
  keys[0] = CFSTR("value");
  keys[1] = CFSTR("units");
  v8 = 0;
  keys[2] = CFSTR("flags");
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCGFloatType, &valuePtr);
  values[1] = CFNumberCreate(v3, kCFNumberSInt32Type, &v9);
  values[2] = CFNumberCreate(v3, kCFNumberSInt32Type, &v8);
  v4 = CFDictionaryCreate(a1, (const void **)keys, (const void **)values, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  for (i = 0; i != 3; ++i)
  {
    v6 = values[i];
    if (v6)
      CFRelease(v6);
  }
  return v4;
}

uint64_t FigCaptionGeometryGetCellBasedDimensionFromDictionary(const void *a1, double *a2)
{
  double v3;
  CFTypeID v5;
  uint64_t v6;
  _BOOL4 v7;
  _BOOL4 v8;
  int v10;
  double v11;

  v3 = 0.0;
  if (!a1 || (v5 = CFGetTypeID(a1), v5 != CFDictionaryGetTypeID()))
  {
    v6 = 4294950501;
    if (!a2)
      return v6;
    goto LABEL_11;
  }
  v11 = 0.0;
  v10 = 0;
  v6 = 4294950501;
  if (FigCFDictionaryGetCGFloatIfPresent((uint64_t)a1, CFSTR("value"), &v11))
  {
    v7 = FigCFDictionaryGetInt32IfPresent((uint64_t)a1, CFSTR("units"), &v10) != 0;
    v8 = v10 == 1667591276;
    if (v7 && v8)
      v6 = 0;
    else
      v6 = 4294950501;
    if (v7 && v8)
      v3 = v11;
    else
      v3 = 0.0;
  }
  if (a2)
LABEL_11:
    *a2 = v3;
  return v6;
}

CFDictionaryRef FigCaptionGeometryCopyCellBasedPointAsDictionary(const __CFAllocator *a1, double a2, double a3)
{
  CFDictionaryRef v5;
  CFDictionaryRef v6;
  CFDictionaryRef v7;
  CFDictionaryRef v8;
  CFDictionaryRef v9;
  void *values[2];
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  v5 = FigCaptionGeometryCopyCellBasedDimensionAsDictionary(a1, a2);
  v6 = FigCaptionGeometryCopyCellBasedDimensionAsDictionary(a1, a3);
  v7 = v6;
  if (v5 && v6)
  {
    keys[0] = CFSTR("x");
    keys[1] = CFSTR("y");
    values[0] = v5;
    values[1] = v6;
    v8 = CFDictionaryCreate(a1, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  else
  {
    v8 = 0;
    v9 = 0;
    if (!v5)
      goto LABEL_6;
  }
  CFRelease(v5);
  v9 = v8;
LABEL_6:
  if (v7)
    CFRelease(v7);
  return v9;
}

uint64_t FigCaptionGeometryGetCellBasedPointFromDictionary(const void *a1, _OWORD *a2)
{
  CFTypeID v4;
  BOOL v5;
  uint64_t result;
  CFTypeID v7;
  CFTypeID v8;
  CFTypeRef cf;
  void *value;
  __int128 v11;

  v11 = *MEMORY[0x1E0C9D538];
  cf = 0;
  value = 0;
  if (!a1
    || (v4 = CFGetTypeID(a1), v4 != CFDictionaryGetTypeID())
    || !CFDictionaryGetValueIfPresent((CFDictionaryRef)a1, CFSTR("x"), (const void **)&value)
    || (CFDictionaryGetValueIfPresent((CFDictionaryRef)a1, CFSTR("y"), &cf) ? (v5 = value == 0) : (v5 = 1),
        v5
     || (v7 = CFGetTypeID(value), v7 != CFDictionaryGetTypeID())
     || !cf
     || (v8 = CFGetTypeID(cf), v8 != CFDictionaryGetTypeID())))
  {
    result = 4294950501;
    if (!a2)
      return result;
    goto LABEL_10;
  }
  result = FigCaptionGeometryGetCellBasedDimensionFromDictionary(value, (double *)&v11);
  if (!(_DWORD)result)
  {
    result = FigCaptionGeometryGetCellBasedDimensionFromDictionary(cf, (double *)&v11 + 1);
    if (a2)
    {
      if (!(_DWORD)result)
LABEL_10:
        *a2 = v11;
    }
  }
  return result;
}

__CFDictionary *FigCaptionGeometryCopyCellBasedSizeAsDictionary(const __CFAllocator *a1, double a2, double a3)
{
  __CFDictionary *Mutable;
  CFDictionaryRef v7;
  CFDictionaryRef v8;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v7 = FigCaptionGeometryCopyCellBasedDimensionAsDictionary(a1, a2);
  v8 = FigCaptionGeometryCopyCellBasedDimensionAsDictionary(a1, a3);
  CFDictionaryAddValue(Mutable, CFSTR("width"), v7);
  CFDictionaryAddValue(Mutable, CFSTR("height"), v8);
  if (v7)
    CFRelease(v7);
  if (v8)
    CFRelease(v8);
  return Mutable;
}

uint64_t FigCaptionGeometryGetCellBasedSizeFromDictionary(const __CFDictionary *a1, _OWORD *a2)
{
  const void *Value;
  const void *v5;
  const void *v6;
  CFTypeID v7;
  CFTypeID v8;
  uint64_t result;
  uint64_t v10;
  __int128 v11;

  v11 = *MEMORY[0x1E0C9D820];
  if (!a1 || !a2)
  {
    v10 = 4294954516;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  Value = CFDictionaryGetValue(a1, CFSTR("width"));
  v5 = CFDictionaryGetValue(a1, CFSTR("height"));
  if (!Value
    || (v6 = v5, v7 = CFGetTypeID(Value), v7 != CFDictionaryGetTypeID())
    || !v6
    || (v8 = CFGetTypeID(v6), v8 != CFDictionaryGetTypeID()))
  {
    v10 = 4294950501;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  result = FigCaptionGeometryGetCellBasedDimensionFromDictionary(Value, (double *)&v11);
  if (!(_DWORD)result)
  {
    result = FigCaptionGeometryGetCellBasedDimensionFromDictionary(v6, (double *)&v11 + 1);
    if (!(_DWORD)result)
      *a2 = v11;
  }
  return result;
}

__CFArray *FigEndpointUtility_CopyMatchingStreamsFromEndpoint(uint64_t a1, unsigned int (*a2)(const void *, uint64_t, uint64_t), uint64_t a3, uint64_t a4)
{
  uint64_t CMBaseObject;
  void (*v8)(uint64_t, const __CFString *, _QWORD, CFArrayRef *);
  const __CFAllocator *v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex v12;
  __CFArray *Mutable;
  unsigned int v14;
  const CFArrayCallBacks *v15;
  const void *ValueAtIndex;
  const void *v17;
  CFArrayRef theArray;

  theArray = 0;
  if (!a1)
    return 0;
  CMBaseObject = FigEndpointGetCMBaseObject(a1);
  v8 = *(void (**)(uint64_t, const __CFString *, _QWORD, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                            + 8)
                                                                                + 48);
  if (!v8)
    return 0;
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8(CMBaseObject, CFSTR("Streams"), *MEMORY[0x1E0C9AE00], &theArray);
  if (!theArray)
    return 0;
  Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
    Mutable = 0;
  }
  else
  {
    v11 = Count;
    v12 = 0;
    Mutable = 0;
    v14 = 1;
    v15 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v12);
      if (ValueAtIndex)
      {
        v17 = ValueAtIndex;
        if (!a2 || a2(ValueAtIndex, a3, a4))
        {
          if (!Mutable)
            Mutable = CFArrayCreateMutable(v9, v11, v15);
          CFArrayAppendValue(Mutable, v17);
        }
      }
      v12 = v14;
    }
    while (v11 > v14++);
  }
  if (theArray)
    CFRelease(theArray);
  return Mutable;
}

uint64_t FigEndpointActivate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD);

  v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16)
                                                                           + 8);
  if (v6)
    return v6(a1, a2, a3, 0, 0);
  else
    return 4294954514;
}

uint64_t FigEndpointActivateSync(const void *a1, uint64_t a2, uint64_t a3, int a4)
{
  NSObject *v8;
  dispatch_time_t v9;
  uint64_t CMBaseObject;
  uint64_t (*v11)(uint64_t, const __CFString *, _QWORD, CFTypeRef *);
  CFTypeRef v12;
  const __CFAllocator *v13;
  CFMutableArrayRef Mutable;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t (*v17)(const void *, uint64_t, uint64_t, _QWORD, _QWORD *);
  const __CFNumber *ValueAtIndex;
  int v19;
  CFTypeRef cf;
  unsigned int valuePtr;

  v8 = dispatch_semaphore_create(0);
  if (a4)
    v9 = dispatch_time(0, 1000000 * a4);
  else
    v9 = -1;
  cf = 0;
  CMBaseObject = FigEndpointGetCMBaseObject(a1);
  v11 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                               + 8)
                                                                                   + 48);
  if (!v11)
  {
    Mutable = 0;
    goto LABEL_15;
  }
  valuePtr = v11(CMBaseObject, CFSTR("IsActivated"), *MEMORY[0x1E0C9AE00], &cf);
  if (valuePtr)
  {
    Mutable = 0;
    goto LABEL_17;
  }
  v12 = cf;
  if (cf != (CFTypeRef)*MEMORY[0x1E0C9AE50])
  {
    v13 = CFGetAllocator(a1);
    Mutable = CFArrayCreateMutable(v13, 0, MEMORY[0x1E0C9B378]);
    if (!Mutable || (v15 = malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL)) == 0)
    {
      FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
      goto LABEL_17;
    }
    v16 = v15;
    *v15 = v8;
    dispatch_retain(v8);
    v16[1] = CFRetain(Mutable);
    v17 = *(uint64_t (**)(const void *, uint64_t, uint64_t, _QWORD, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1)
                                                                                                 + 16)
                                                                                     + 8);
    if (v17)
    {
      valuePtr = v17(a1, a2, a3, endpointUtil_activationCallback, v16);
      if (valuePtr)
        goto LABEL_17;
      if (!dispatch_semaphore_wait(v8, v9))
      {
        if (CFArrayGetCount(Mutable) >= 1)
        {
          ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(Mutable, 0);
          CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr);
        }
LABEL_17:
        v12 = cf;
        if (!cf)
          goto LABEL_19;
        goto LABEL_18;
      }
      v19 = -16724;
LABEL_16:
      valuePtr = v19;
      goto LABEL_17;
    }
LABEL_15:
    v19 = -12782;
    goto LABEL_16;
  }
  Mutable = 0;
  if (cf)
LABEL_18:
    CFRelease(v12);
LABEL_19:
  if (Mutable)
    CFRelease(Mutable);
  if (v8)
    dispatch_release(v8);
  return valuePtr;
}

void endpointUtil_activationCallback(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  CFNumberRef v6;
  const void *v7;
  int valuePtr;

  valuePtr = a4;
  v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a5 + 8), v6);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)a5);
  if (*(_QWORD *)a5)
    dispatch_release(*(dispatch_object_t *)a5);
  v7 = *(const void **)(a5 + 8);
  if (v7)
    CFRelease(v7);
  free((void *)a5);
  if (v6)
    CFRelease(v6);
}

uint64_t FigEndpointDeactivate(uint64_t a1, uint64_t a2)
{
  uint64_t (*v4)(uint64_t, uint64_t, _QWORD, _QWORD);

  v4 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 16);
  if (v4)
    return v4(a1, a2, 0, 0);
  else
    return 4294954514;
}

uint64_t FigEndpointGetSupportedFeatures(uint64_t a1)
{
  uint64_t CMBaseObject;
  uint64_t (*v2)(uint64_t, const __CFString *, _QWORD, CFNumberRef *);
  int v3;
  CFNumberRef v4;
  BOOL v5;
  CFNumberRef number;
  uint64_t valuePtr;

  number = 0;
  valuePtr = 0;
  CMBaseObject = FigEndpointGetCMBaseObject(a1);
  v2 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, CFNumberRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                                + 8)
                                                                                    + 48);
  if (v2)
  {
    v3 = v2(CMBaseObject, CFSTR("SupportedFeatures"), 0, &number);
    v4 = number;
    if (v3)
      v5 = 1;
    else
      v5 = number == 0;
    if (!v5)
    {
      CFNumberGetValue(number, kCFNumberSInt64Type, &valuePtr);
      v4 = number;
    }
    if (v4)
      CFRelease(v4);
  }
  return valuePtr;
}

uint64_t FigEndpointUtility_CopyEndpointType(uint64_t result)
{
  uint64_t CMBaseObject;
  unsigned int (*v2)(uint64_t, const __CFString *, _QWORD, uint64_t *);
  uint64_t v3;

  v3 = 0;
  if (result)
  {
    CMBaseObject = FigEndpointGetCMBaseObject(result);
    v2 = *(unsigned int (**)(uint64_t, const __CFString *, _QWORD, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                                       + 48);
    if (v2)
    {
      if (v2(CMBaseObject, CFSTR("Type"), *MEMORY[0x1E0C9AE00], &v3))
        return 0;
      else
        return v3;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t FigEndpointUtility_CopyEndpointTransportType(uint64_t result)
{
  uint64_t CMBaseObject;
  unsigned int (*v2)(uint64_t, const __CFString *, _QWORD, uint64_t *);
  uint64_t v3;

  v3 = 0;
  if (result)
  {
    CMBaseObject = FigEndpointGetCMBaseObject(result);
    v2 = *(unsigned int (**)(uint64_t, const __CFString *, _QWORD, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                                       + 48);
    if (v2)
    {
      if (v2(CMBaseObject, CFSTR("TransportType"), *MEMORY[0x1E0C9AE00], &v3))
        return 0;
      else
        return v3;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void FigEndpointUtility_SetPropertyOnEndpointStreams(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v6;
  const __CFArray *v8;
  const void *ValueAtIndex;
  uint64_t CMBaseObject;
  void (*v11)(uint64_t, uint64_t, uint64_t);
  const __CFArray *v12;
  const void *v13;
  uint64_t v14;
  void (*v15)(uint64_t, uint64_t, uint64_t);
  const __CFArray *v16;
  const void *v17;
  uint64_t v18;
  void (*v19)(uint64_t, uint64_t, uint64_t);
  CFArrayRef theArray;

  if (a1 && a3 && a4)
  {
    v6 = a2;
    if ((a2 & 2) != 0)
    {
      theArray = 0;
      FigEndpointCopyStreamsForTypeAndSubType(a1, a2, (uint64_t)CFSTR("Audio"), 0, &theArray);
      v8 = theArray;
      if (theArray)
      {
        if (CFArrayGetCount(theArray) >= 1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v8, 0);
          CMBaseObject = FigEndpointStreamGetCMBaseObject(ValueAtIndex);
          v11 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                 + 56);
          if (v11)
            v11(CMBaseObject, a3, a4);
        }
        CFRelease(v8);
      }
    }
    if ((v6 & 8) != 0)
    {
      theArray = 0;
      FigEndpointCopyStreamsForTypeAndSubType(a1, a2, (uint64_t)CFSTR("BufferedAudio"), 0, &theArray);
      v12 = theArray;
      if (theArray)
      {
        if (CFArrayGetCount(theArray) >= 1)
        {
          v13 = CFArrayGetValueAtIndex(v12, 0);
          v14 = FigEndpointStreamGetCMBaseObject(v13);
          v15 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v14) + 8) + 56);
          if (v15)
            v15(v14, a3, a4);
        }
        CFRelease(v12);
      }
    }
    if ((v6 & 1) != 0)
    {
      theArray = 0;
      FigEndpointCopyStreamsForTypeAndSubType(a1, a2, (uint64_t)CFSTR("Screen"), 0, &theArray);
      v16 = theArray;
      if (theArray)
      {
        if (CFArrayGetCount(theArray) >= 1)
        {
          v17 = CFArrayGetValueAtIndex(v16, 0);
          v18 = FigEndpointStreamGetCMBaseObject(v17);
          v19 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v18) + 8) + 56);
          if (v19)
            v19(v18, a3, a4);
        }
        CFRelease(v16);
      }
    }
  }
}

uint64_t FigEndpointCopyStreamsForTypeAndSubType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __CFArray **a5)
{
  if (a1)
    *a5 = FigEndpointUtility_CopyMatchingStreamsFromEndpoint(a1, (unsigned int (*)(const void *, uint64_t, uint64_t))FigEndpointUtility_StreamPredicate_IsOfTypeAndSubType, a3, a4);
  else
    FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
  return 0;
}

BOOL FigEndpointUtility_EndpointPredicate_ContainsID(uint64_t a1, const __CFString *a2)
{
  uint64_t CMBaseObject;
  void (*v4)(uint64_t, const __CFString *, _QWORD, CFStringRef *);
  _BOOL8 v5;
  CFStringRef v6;
  CFRange v7;
  CFStringRef theString;

  theString = 0;
  if (!a1)
    return 0;
  CMBaseObject = FigEndpointGetCMBaseObject(a1);
  v4 = *(void (**)(uint64_t, const __CFString *, _QWORD, CFStringRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                             + 8)
                                                                                 + 48);
  if (!v4)
    return 0;
  v4(CMBaseObject, CFSTR("ID"), *MEMORY[0x1E0C9AE00], &theString);
  v5 = 0;
  v6 = theString;
  if (a2 && theString)
  {
    v7 = CFStringFind(theString, a2, 1uLL);
    v5 = v7.length > 0 && v7.location == 0;
    v6 = theString;
  }
  if (v6)
    CFRelease(v6);
  return v5;
}

uint64_t FigEndpointUtility_EndpointPredicate_EqualsAudioStreamID(uint64_t a1, const void *a2)
{
  const __CFAllocator *v3;
  uint64_t CMBaseObject;
  void (*v5)(uint64_t, const __CFString *, const __CFAllocator *, CFArrayRef *);
  CFIndex Count;
  __CFArray *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v10;
  uint64_t v11;
  void (*v12)(uint64_t, const __CFString *, const __CFAllocator *, CFTypeRef *);
  CFIndex v13;
  CFIndex v14;
  CFIndex v15;
  const void *v16;
  uint64_t v17;
  void (*v18)(uint64_t, const __CFString *, const __CFAllocator *, CFTypeRef *);
  uint64_t v19;
  CFTypeRef cf;
  CFArrayRef theArray;

  if (!a1)
    return 0;
  theArray = 0;
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  CMBaseObject = FigEndpointGetCMBaseObject(a1);
  v5 = *(void (**)(uint64_t, const __CFString *, const __CFAllocator *, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                                               + 48);
  if (v5 && (v5(CMBaseObject, CFSTR("Streams"), v3, &theArray), theArray))
  {
    Count = CFArrayGetCount(theArray);
    Mutable = CFArrayCreateMutable(v3, 0, MEMORY[0x1E0C9B378]);
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
        v10 = ValueAtIndex;
        cf = 0;
        if (ValueAtIndex)
        {
          v11 = FigEndpointStreamGetCMBaseObject(ValueAtIndex);
          v12 = *(void (**)(uint64_t, const __CFString *, const __CFAllocator *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(v11) + 8) + 48);
          if (v12)
            v12(v11, CFSTR("Type"), v3, &cf);
        }
        if (FigCFEqual(cf, CFSTR("Audio")) || FigCFEqual(cf, CFSTR("LowLatencyAudio")))
          CFArrayAppendValue(Mutable, v10);
        if (cf)
          CFRelease(cf);
      }
    }
    if (Mutable)
      goto LABEL_16;
  }
  else
  {
    Mutable = CFArrayCreateMutable(v3, 0, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
LABEL_16:
      v13 = CFArrayGetCount(Mutable);
      if (v13 < 1)
      {
LABEL_25:
        v19 = 0;
      }
      else
      {
        v14 = v13;
        v15 = 0;
        while (1)
        {
          cf = 0;
          v16 = CFArrayGetValueAtIndex(Mutable, v15);
          if (v16)
          {
            v17 = FigEndpointStreamGetCMBaseObject(v16);
            v18 = *(void (**)(uint64_t, const __CFString *, const __CFAllocator *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(v17) + 8) + 48);
            if (v18)
              v18(v17, CFSTR("ID"), v3, &cf);
          }
          if (FigCFEqual(cf, a2))
            break;
          if (cf)
            CFRelease(cf);
          if (v14 == ++v15)
            goto LABEL_25;
        }
        if (cf)
          CFRelease(cf);
        v19 = 1;
      }
      CFRelease(Mutable);
      goto LABEL_33;
    }
  }
  v19 = 0;
LABEL_33:
  if (theArray)
    CFRelease(theArray);
  return v19;
}

BOOL FigEndpointUtility_EndpointPredicate_IsPropertyTrue(uint64_t a1, uint64_t a2)
{
  uint64_t CMBaseObject;
  void (*v4)(uint64_t, uint64_t, _QWORD, CFTypeRef *);
  CFTypeRef v5;
  CFTypeRef v6;
  CFTypeRef cf;

  cf = 0;
  CMBaseObject = FigEndpointGetCMBaseObject(a1);
  v4 = *(void (**)(uint64_t, uint64_t, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                    + 48);
  if (v4)
  {
    v4(CMBaseObject, a2, *MEMORY[0x1E0C9AE00], &cf);
    v5 = cf;
    v6 = (CFTypeRef)*MEMORY[0x1E0C9AE50];
    if (cf)
      CFRelease(cf);
  }
  else
  {
    v5 = 0;
    v6 = (CFTypeRef)*MEMORY[0x1E0C9AE50];
  }
  return v5 == v6;
}

uint64_t FigEndpointCopyFirstStreamOfType(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  __CFArray *v5;
  const __CFArray *v6;
  const void *ValueAtIndex;

  if (!a1)
  {
    FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v5 = FigEndpointUtility_CopyMatchingStreamsFromEndpoint(a1, (unsigned int (*)(const void *, uint64_t, uint64_t))FigEndpointUtility_StreamPredicate_IsOfTypeAndSubType, a3, 0);
  if (v5)
  {
    v6 = v5;
    if (CFArrayGetCount(v5))
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v6, 0);
      if (ValueAtIndex)
        ValueAtIndex = CFRetain(ValueAtIndex);
      *a4 = ValueAtIndex;
    }
    CFRelease(v6);
    return 0;
  }
  return 4294950571;
}

uint64_t FigEndpointUtility_StreamPredicate_IsOfTypeAndSubType(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v6;
  uint64_t CMBaseObject;
  void (*v8)(uint64_t, const __CFString *, uint64_t, CFTypeRef *);
  CFTypeRef v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(uint64_t, const __CFString *, uint64_t, CFTypeRef *);
  CFTypeRef v14;
  CFTypeRef cf;
  CFTypeRef v17;

  if (!a1)
    return 0;
  v17 = 0;
  v6 = *MEMORY[0x1E0C9AE00];
  CMBaseObject = FigEndpointStreamGetCMBaseObject(a1);
  v8 = *(void (**)(uint64_t, const __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                            + 8)
                                                                                + 48);
  if (v8)
  {
    v8(CMBaseObject, CFSTR("Type"), v6, &v17);
    v9 = v17;
  }
  else
  {
    v9 = 0;
  }
  v10 = FigCFEqual(v9, a2);
  v11 = v10;
  if (a3 && (_DWORD)v10)
  {
    cf = 0;
    v12 = FigEndpointStreamGetCMBaseObject(a1);
    v13 = *(void (**)(uint64_t, const __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(v12)
                                                                                               + 8)
                                                                                   + 48);
    if (v13)
    {
      v13(v12, CFSTR("SubType"), v6, &cf);
      v14 = cf;
    }
    else
    {
      v14 = 0;
    }
    v11 = FigCFEqual(v14, a3);
    if (cf)
      CFRelease(cf);
  }
  if (v17)
    CFRelease(v17);
  return v11;
}

BOOL FigEndpointUtility_IsSubTypeThirdPartyTVFamily(const void *a1)
{
  return FigCFEqual(a1, CFSTR("EndpointSubType_ThirdPartyTV"))
      || FigCFEqual(a1, CFSTR("EndpointSubType_ThirdPartySetTopBox"))
      || FigCFEqual(a1, CFSTR("EndpointSubType_ThirdPartyTVStick")) != 0;
}

BOOL FigEndpointUtility_IsEndpointThirdPartyTVFamily(uint64_t a1)
{
  uint64_t CMBaseObject;
  void (*v2)(uint64_t, const __CFString *, _QWORD, CFTypeRef *);
  CFTypeRef v3;
  _BOOL8 IsSubTypeThirdPartyTVFamily;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
    return 0;
  CMBaseObject = FigEndpointGetCMBaseObject(a1);
  v2 = *(void (**)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                           + 8)
                                                                               + 48);
  if (v2)
  {
    v2(CMBaseObject, CFSTR("SubType"), *MEMORY[0x1E0C9AE00], &cf);
    v3 = cf;
  }
  else
  {
    v3 = 0;
  }
  IsSubTypeThirdPartyTVFamily = FigEndpointUtility_IsSubTypeThirdPartyTVFamily(v3);
  if (cf)
    CFRelease(cf);
  return IsSubTypeThirdPartyTVFamily;
}

const __CFArray *FigEndpointContainsStream(uint64_t a1, const void *a2)
{
  const __CFArray *v2;
  uint64_t CMBaseObject;
  void (*v5)(uint64_t, const __CFString *, _QWORD, CFArrayRef *);
  CFArrayRef theArray;
  CFRange v8;

  v2 = 0;
  theArray = 0;
  if (a1 && a2)
  {
    CMBaseObject = FigEndpointGetCMBaseObject(a1);
    v5 = *(void (**)(uint64_t, const __CFString *, _QWORD, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                              + 8)
                                                                                  + 48);
    if (v5)
    {
      v5(CMBaseObject, CFSTR("Streams"), *MEMORY[0x1E0C9AE00], &theArray);
      v2 = theArray;
      if (theArray)
      {
        v8.length = CFArrayGetCount(theArray);
        v8.location = 0;
        v2 = (const __CFArray *)CFArrayContainsValue(v2, v8, a2);
        if (theArray)
          CFRelease(theArray);
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t FigEndpointAcquireAndCopyStreamResource(char *a1, const void *a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *ClassID;
  __CFDictionary *Mutable;
  __CFDictionary *v9;
  uint64_t (*v10)(char *, const __CFString *, __CFDictionary *, uint64_t);

  v3 = 4294950576;
  if (a1 && a2 && a3)
  {
    ClassID = (_QWORD *)FigEndpointExtendedGetClassID();
    if (CMBaseObjectIsMemberOfClass(a1, ClassID))
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Mutable)
      {
        v9 = Mutable;
        CFDictionarySetValue(Mutable, CFSTR("endpointStreamType"), a2);
        v10 = *(uint64_t (**)(char *, const __CFString *, __CFDictionary *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 24)
                                                                                              + 128);
        if (v10)
          v3 = v10(a1, CFSTR("endpointStream"), v9, a3);
        else
          v3 = 4294954514;
        CFRelease(v9);
      }
      else
      {
        return 4294950575;
      }
    }
    else
    {
      return 4294950570;
    }
  }
  return v3;
}

uint64_t FigEndpointRelinquishStreamResource(char *a1, uint64_t a2)
{
  uint64_t result;
  _QWORD *ClassID;
  uint64_t (*v6)(char *, const __CFString *, uint64_t);

  result = 4294950576;
  if (a1 && a2)
  {
    ClassID = (_QWORD *)FigEndpointExtendedGetClassID();
    if (CMBaseObjectIsMemberOfClass(a1, ClassID))
    {
      v6 = *(uint64_t (**)(char *, const __CFString *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1)
                                                                                     + 24)
                                                                         + 136);
      if (v6)
        return v6(a1, CFSTR("endpointStream"), a2);
      else
        return 4294954514;
    }
    else
    {
      return 4294950570;
    }
  }
  return result;
}

uint64_t FigCFWeakReferenceTableAddValueAndGetKey(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  if (*(_BYTE *)(a1 + 36))
  {
    v11 = 4294955228;
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  if (!a3 || (*a3 = 0, !a2))
  {
    v11 = 4294955231;
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 40));
  v6 = malloc_type_calloc(1uLL, 0x18uLL, 0x1020040FBFA920DuLL);
  if (v6)
  {
    v7 = v6;
    v8 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = v8 + 1;
    *(_QWORD *)v6 = v8;
    if (*(_BYTE *)(a1 + 37))
    {
      v8 = v8;
      *(_QWORD *)v6 = v8;
    }
    *a3 = v8;
    FigCFWeakReferenceInit((id *)v6 + 1, (id)a2);
    v7[2] = -a2;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v7, v7);
    v9 = 0;
  }
  else
  {
    v9 = FigSignalErrorAt(4294955230, 0, 0, 0, 0, 0, 0);
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
  return v9;
}

uint64_t FigCFWeakReferenceTableAddValueAssociatedWithKey(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id *Value;
  id *v7;
  id *v8;
  id v9;
  const void *v10;
  uint64_t v11;
  void *v12;
  _QWORD *v13;
  uint64_t v15;
  _QWORD key[3];

  key[1] = 0;
  key[2] = 0;
  if (a3)
  {
    if (a1 && a2)
    {
      if (*(_BYTE *)(a1 + 36) == 1)
      {
        FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 40));
        key[0] = a3;
        Value = (id *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
        if (Value)
        {
          v7 = Value;
          v8 = Value + 1;
          v9 = FigCFWeakReferenceLoadAndRetain(Value + 1);
          if (v9)
          {
            v10 = v9;
            v11 = FigSignalErrorAt(4294955227, 0, 0, 0, 0, 0, 0);
            FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
            CFRelease(v10);
            return v11;
          }
          FigCFWeakReferenceStore(v8, (id)a2);
          v11 = 0;
          v7[2] = (id)-a2;
        }
        else
        {
          v12 = malloc_type_calloc(1uLL, 0x18uLL, 0x1020040FBFA920DuLL);
          if (v12)
          {
            v13 = v12;
            *(_QWORD *)v12 = a3;
            FigCFWeakReferenceInit((id *)v12 + 1, (id)a2);
            v13[2] = -a2;
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v13, v13);
            v11 = 0;
          }
          else
          {
            v11 = FigSignalErrorAt(4294955230, 0, 0, 0, 0, 0, 0);
          }
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
        return v11;
      }
      v15 = 4294955228;
    }
    else
    {
      v15 = 4294955231;
    }
  }
  else
  {
    v15 = 4294955231;
  }
  return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCFWeakReferenceTableRemoveValue(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD key[3];

  key[1] = 0;
  key[2] = 0;
  if (!a1 || !a2)
    return FigSignalErrorAt(4294955231, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 40));
  key[0] = a2;
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), key))
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 16), key);
    v4 = 0;
  }
  else
  {
    v4 = 4294955229;
  }
  figCFWeakReferenceTablePeriodicallyCleanUp(a1);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
  return v4;
}

void figCFWeakReferenceTablePeriodicallyCleanUp(uint64_t a1)
{
  int v1;
  const __CFArray *context;
  CFRange v4;

  context = 0;
  v1 = *(_DWORD *)(a1 + 32) + 1;
  *(_DWORD *)(a1 + 32) = v1;
  if (v1 == 100)
  {
    *(_DWORD *)(a1 + 32) = 0;
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)figCFWeakReferenceTableCleanup_ifValueIsNULLAppendToKeyValueEntriesToRemove, &context);
    if (context)
    {
      v4.length = CFArrayGetCount(context);
      v4.location = 0;
      CFArrayApplyFunction(context, v4, (CFArrayApplierFunction)figCFWeakReferenceTableCleanup_removeKeyValueEntries, *(void **)(a1 + 16));
      CFRelease(context);
    }
  }
}

id FigCFWeakReferenceTableCopyValue(uint64_t a1, void *a2)
{
  id v2;
  id *Value;
  _QWORD key[3];

  key[1] = 0;
  key[2] = 0;
  if (a1)
  {
    v2 = a2;
    if (a2)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 40));
      key[0] = v2;
      Value = (id *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), key);
      if (Value)
        v2 = FigCFWeakReferenceLoadAndRetain(Value + 1);
      else
        v2 = 0;
      figCFWeakReferenceTablePeriodicallyCleanUp(a1);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
    }
    else
    {
      FigSignalErrorAt(4294955231, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    FigSignalErrorAt(4294955231, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v2;
}

uint64_t FigCFWeakReferenceTableGetKey(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD context[2];
  uint64_t v7;

  v2 = 0;
  v7 = 0;
  if (a1 && a2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 40));
    context[0] = a2;
    context[1] = -a2;
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)figCFWeakReferenceTable_searchForDisguisedValue, context);
    v2 = v7;
    figCFWeakReferenceTablePeriodicallyCleanUp(a1);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
  }
  return v2;
}

void figCFWeakReferenceTable_searchForDisguisedValue(uint64_t a1, id *a2, id *a3)
{
  id v5;

  if (a2[2] == a3[1])
  {
    v5 = FigCFWeakReferenceLoadAndRetain(a2 + 1);
    if (v5 != *a3)
    {
      if (!v5)
        return;
      goto LABEL_4;
    }
    a3[2] = *a2;
    if (v5)
LABEL_4:
      CFRelease(v5);
  }
}

uint64_t FigCFWeakReferenceTableCopyValues(uint64_t a1, CFMutableDictionaryRef *a2)
{
  uint64_t Count;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v6;
  uint64_t v8;
  CFMutableDictionaryRef v9;
  uint64_t v10;

  v9 = 0;
  v10 = 0;
  if (!a1 || !a2)
    return FigSignalErrorAt(4294955231, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 40));
  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16));
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v6 = Mutable;
    if (Count >= 1)
    {
      v9 = Mutable;
      v10 = 0;
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)figCFWeakReferenceTableCopyCopiedEntriesApplier, &v9);
    }
    figCFWeakReferenceTablePeriodicallyCleanUp(a1);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
    *a2 = v6;
    return 0;
  }
  else
  {
    v8 = FigSignalErrorAt(4294955230, 0, 0, 0, 0, 0, 0);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
    return v8;
  }
}

void figCFWeakReferenceTableCopyCopiedEntriesApplier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5;
  const void *v6;
  CFNumberRef UInt64;

  v5 = FigCFWeakReferenceLoadAndRetain((id *)(a2 + 8));
  if (v5)
  {
    v6 = v5;
    UInt64 = FigCFNumberCreateUInt64((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(_QWORD *)a2);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)a3, UInt64, v6);
    if (UInt64)
      CFRelease(UInt64);
    CFRelease(v6);
  }
  ++*(_QWORD *)(a3 + 8);
}

uint64_t FigCFWeakReferenceTableApplyFunction(uint64_t a1, void (*a2)(_QWORD, CFTypeRef, uint64_t), uint64_t a3)
{
  CFIndex Count;
  uint64_t v7;
  CFTypeRef *v8;
  CFTypeRef *v9;
  CFTypeRef *v10;
  uint64_t v11;
  _QWORD v13[2];

  if (a1 && a2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 40));
    Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 16));
    if (Count)
    {
      v7 = Count;
      v8 = (CFTypeRef *)malloc_type_malloc(16 * Count, 0x10C004003E0BC0AuLL);
      if (v8)
      {
        v9 = v8;
        v13[0] = v8;
        v13[1] = 0;
        CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 16), (CFDictionaryApplierFunction)figCFWeakReferenceTableCopiedEntriesApplier, v13);
        figCFWeakReferenceTablePeriodicallyCleanUp(a1);
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
        if (v7 >= 1)
        {
          v10 = v9 + 1;
          do
          {
            if (*v10)
            {
              a2(*(v10 - 1), *v10, a3);
              CFRelease(*v10);
            }
            v10 += 2;
            --v7;
          }
          while (v7);
        }
        free(v9);
        return 0;
      }
      v11 = FigSignalErrorAt(4294955230, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      v11 = 0;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 40));
    return v11;
  }
  return FigSignalErrorAt(4294955231, 0, 0, 0, 0, 0, 0);
}

id figCFWeakReferenceTableCopiedEntriesApplier(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v5;
  id result;

  v5 = (_QWORD *)(*a3 + 16 * a3[1]);
  result = FigCFWeakReferenceLoadAndRetain((id *)(a2 + 8));
  *v5 = *(_QWORD *)a2;
  v5[1] = result;
  ++a3[1];
  return result;
}

uint64_t FigCFWeakReferenceTableGetTypeID()
{
  if (sRegisterFigCFWeakReferenceTableTypeOnce != -1)
    dispatch_once_f(&sRegisterFigCFWeakReferenceTableTypeOnce, 0, (dispatch_function_t)RegisterFigCFWeakReferenceTableType);
  return sFigCFWeakReferenceTableID;
}

uint64_t RegisterFigCFWeakReferenceTableType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigCFWeakReferenceTableID = result;
  return result;
}

uint64_t FigCFWeakReferenceTableCreate(const __CFAllocator *a1, char a2, uint64_t *a3)
{
  uint64_t Instance;
  uint64_t v7;
  pthread_mutex_t *v8;
  pid_t v9;
  unint64_t v10;
  CFMutableDictionaryRef Mutable;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (!a3)
  {
    v13 = 4294955231;
    return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
  }
  if (sRegisterFigCFWeakReferenceTableTypeOnce != -1)
    dispatch_once_f(&sRegisterFigCFWeakReferenceTableTypeOnce, 0, (dispatch_function_t)RegisterFigCFWeakReferenceTableType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v13 = 4294955230;
    return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
  }
  v7 = Instance;
  v8 = FigSimpleMutexCreateWithFlags(a1);
  *(_QWORD *)(v7 + 40) = v8;
  if (v8)
  {
    if ((a2 & 1) != 0)
      *(_BYTE *)(v7 + 36) = 1;
    if ((a2 & 2) != 0)
      *(_BYTE *)(v7 + 37) = 1;
    v9 = getpid();
    v10 = v9;
    if (*(_BYTE *)(v7 + 37))
      v10 = v9 % 0x10C6uLL;
    *(_QWORD *)(v7 + 24) = 1000000 * v10
                         + (int)(10000 * FigAtomicIncrement32((unsigned int *)&FigCFWeakReferenceTableCreate_sTableCount));
    *(_DWORD *)(v7 + 32) = 0;
    Mutable = CFDictionaryCreateMutable(a1, 0, &figCFWeakReferenceTableKeyCallbacks, &figCFWeakReferenceTableValueCallbacks);
    *(_QWORD *)(v7 + 16) = Mutable;
    if (Mutable)
    {
      *a3 = v7;
      return 0;
    }
    v14 = 4294955230;
  }
  else
  {
    v14 = 4294954510;
  }
  v15 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  CFRelease((CFTypeRef)v7);
  return v15;
}

void figCFWeakReferenceTableCleanup_ifValueIsNULLAppendToKeyValueEntriesToRemove(int a1, void *value, __CFArray **a3)
{
  __CFArray *Mutable;

  if (!*((_QWORD *)value + 1))
  {
    Mutable = *a3;
    if (*a3 || (Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0), (*a3 = Mutable) != 0))
      CFArrayAppendValue(Mutable, value);
    else
      FigSignalErrorAt(4294955230, 0, 0, 0, 0, 0, 0);
  }
}

void figCFWeakReferenceTableCleanup_removeKeyValueEntries(void *key, CFMutableDictionaryRef theDict)
{
  CFDictionaryRemoveValue(theDict, key);
}

double figCFWeakReferenceTableInit(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

const __CFAllocator *figCFWeakReferenceTableFinalize(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
    CFRelease(v2);
  return FigSimpleMutexDestroy(*(_QWORD *)(a1 + 40));
}

__CFString *figCFWeakReferenceTableCopyDesc(_BYTE *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  __CFString *v4;
  const char *v5;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = Mutable;
  if (a1[36])
    v5 = "Client provides keys ";
  else
    v5 = "";
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigCFWeakReferenceTable %s%p>"), v5, a1);
  return v4;
}

BOOL figCFWeakReferenceTableKeyEqual(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

uint64_t figCFWeakReferenceTableKeyHash(uint64_t a1)
{
  return *(_QWORD *)a1;
}

void figCFWeakReferenceTableValueDestroy(uint64_t a1, id *a2)
{
  FigCFWeakReferenceDestroy(a2 + 1);
  free(a2);
}

BOOL figCFWeakReferenceTableValueEqual(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a1 + 16) == *(_QWORD *)(a2 + 16);
}

pthread_mutex_t **FigReadWriteLockCreate(int a1)
{
  return FigReadWriteLockCreateWithFlags((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a1);
}

pthread_mutex_t **FigReadWriteLockCreateWithFlags(const __CFAllocator *a1, int a2)
{
  pthread_mutex_t **v4;
  pthread_mutex_t **v5;
  pthread_mutex_t *v6;
  pthread_mutex_t *v7;
  pthread_mutex_t *v8;
  pthread_mutex_t **v9;

  v4 = (pthread_mutex_t **)CFAllocatorAllocate(a1, 40, 0);
  v5 = v4;
  if (v4)
  {
    v4[4] = 0;
    *(_OWORD *)v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    v6 = FigSimpleMutexCreateWithFlags(a1);
    *v5 = v6;
    if (v6)
    {
      v7 = (pthread_mutex_t *)FigSemaphoreCreateWithFlags(a1, 0, 1);
      v5[1] = v7;
      if (v7)
      {
        *((_DWORD *)v5 + 4) = a2;
        if (a1)
          v8 = (pthread_mutex_t *)CFRetain(a1);
        else
          v8 = 0;
        v9 = 0;
        v5[4] = v8;
        goto LABEL_8;
      }
      FigSimpleMutexDestroy((uint64_t)*v5);
    }
    v9 = v5;
    v5 = 0;
LABEL_8:
    CFAllocatorDeallocate(a1, v9);
  }
  return v5;
}

const __CFAllocator *FigReadWriteLockDestroy(uint64_t *a1)
{
  uint64_t v2;
  const __CFAllocator *v3;

  if (!a1)
    return 0;
  v2 = (uint64_t)FigSimpleMutexDestroy(*a1);
  if (!(_DWORD)v2)
  {
    *a1 = 0;
    v2 = FigSemaphoreDestroy(a1[1]);
    if (!(_DWORD)v2)
    {
      v3 = (const __CFAllocator *)a1[4];
      a1[1] = 0;
      CFAllocatorDeallocate(v3, a1);
      if (!v3)
        return v3;
      CFRelease(v3);
      return 0;
    }
  }
  v3 = (const __CFAllocator *)v2;
  FigSignalErrorAt(v2, 0, 0, 0, 0, 0, 0);
  return v3;
}

uint64_t FigReadWriteLockLockForRead(uint64_t a1)
{
  uint64_t result;

  result = FigSimpleMutexLock(*(pthread_mutex_t **)a1);
  if (!(_DWORD)result)
  {
    while (*(_DWORD *)(a1 + 24) || *(_DWORD *)(a1 + 28))
    {
      FigSimpleMutexUnlock(*(pthread_mutex_t **)a1);
      FigSemaphoreWaitRelative(*(_QWORD *)(a1 + 8), -1);
      result = FigSimpleMutexLock(*(pthread_mutex_t **)a1);
      if ((_DWORD)result)
        return result;
      if (*(_DWORD *)(a1 + 28))
        FigSemaphoreSignal(*(_QWORD *)(a1 + 8));
    }
    ++*(_DWORD *)(a1 + 20);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)a1);
    return 0;
  }
  return result;
}

uint64_t FigReadWriteLockLockForWrite(uint64_t a1)
{
  uint64_t result;

  result = FigSimpleMutexLock(*(pthread_mutex_t **)a1);
  if (!(_DWORD)result)
  {
    if ((*(_BYTE *)(a1 + 16) & 1) != 0)
      ++*(_DWORD *)(a1 + 28);
    while (*(_DWORD *)(a1 + 24) || *(_DWORD *)(a1 + 20))
    {
      FigSimpleMutexUnlock(*(pthread_mutex_t **)a1);
      FigSemaphoreWaitRelative(*(_QWORD *)(a1 + 8), -1);
      result = FigSimpleMutexLock(*(pthread_mutex_t **)a1);
      if ((_DWORD)result)
        return result;
    }
    *(_DWORD *)(a1 + 24) = 1;
    if ((*(_BYTE *)(a1 + 16) & 1) != 0)
      --*(_DWORD *)(a1 + 28);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)a1);
    return 0;
  }
  return result;
}

uint64_t FigReadWriteLockUnlockForRead(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;

  v2 = FigSimpleMutexLock(*(pthread_mutex_t **)a1);
  if (!(_DWORD)v2)
  {
    v3 = *(_DWORD *)(a1 + 20);
    if (v3)
    {
      v4 = v3 - 1;
      *(_DWORD *)(a1 + 20) = v4;
      if (!v4)
        FigSemaphoreSignal(*(_QWORD *)(a1 + 8));
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)a1);
  }
  return v2;
}

uint64_t FigReadWriteLockUnlockForWrite(uint64_t a1)
{
  uint64_t v2;

  v2 = FigSimpleMutexLock(*(pthread_mutex_t **)a1);
  if (!(_DWORD)v2)
  {
    if (*(_DWORD *)(a1 + 24))
    {
      *(_DWORD *)(a1 + 24) = 0;
      FigSemaphoreSignal(*(_QWORD *)(a1 + 8));
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)a1);
  }
  return v2;
}

BOOL _FigIsCurrentDispatchQueue(NSObject *a1)
{
  return dispatch_get_current_queue() == a1;
}

BOOL _FigIsNotCurrentDispatchQueue(NSObject *a1)
{
  return dispatch_get_current_queue() != a1;
}

uint64_t FigConcurrentAccessDetectorCreate()
{
  return 0;
}

dispatch_queue_t FigReadWriteQueue_Create(const char *a1)
{
  NSObject *v2;

  v2 = dispatch_queue_attr_make_with_overcommit();
  return dispatch_queue_create(a1, v2);
}

uint64_t NeroTransportStartAcceptingConnections(uint64_t a1)
{
  uint64_t CMBaseObject;
  uint64_t (*v3)(uint64_t, const __CFString *, const __CFString *);
  uint64_t result;
  uint64_t v5;
  uint64_t (*v6)(uint64_t);

  CMBaseObject = NeroTransportConnectionGetCMBaseObject(*(_QWORD *)(a1 + 80));
  v3 = *(uint64_t (**)(uint64_t, const __CFString *, const __CFString *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                             + 8)
                                                                                 + 56);
  if (!v3)
    return 4294954514;
  result = v3(CMBaseObject, CFSTR("ConnectionMode"), CFSTR("Server"));
  if ((_DWORD)result)
    return result;
  v5 = *(_QWORD *)(a1 + 80);
  v6 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v5) + 16) + 16);
  if (v6)
    return v6(v5);
  else
    return 4294954514;
}

uint64_t NeroTransportStopAcceptingConnections(uint64_t a1)
{
  uint64_t v1;
  void (*v2)(uint64_t);

  v1 = *(_QWORD *)(a1 + 80);
  v2 = *(void (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v1) + 16) + 24);
  if (v2)
    v2(v1);
  return 0;
}

uint64_t NeroTransportConnectToReceiver(uint64_t a1, const void *a2)
{
  CFIndex AppIntegerValue;
  uint64_t CMBaseObject;
  uint64_t (*v6)(uint64_t, const __CFString *, const __CFString *);
  uint64_t result;
  CFTypeID v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, const __CFString *, const void *);
  uint64_t v11;
  uint64_t (*v12)(uint64_t);
  Boolean keyExistsAndHasValidFormat;

  keyExistsAndHasValidFormat = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("transport_reply_timeout"), CFSTR("com.apple.coremedia"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
    *(_QWORD *)(a1 + 64) = 1000000000 * AppIntegerValue;
  CMBaseObject = NeroTransportConnectionGetCMBaseObject(*(_QWORD *)(a1 + 80));
  v6 = *(uint64_t (**)(uint64_t, const __CFString *, const __CFString *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                             + 8)
                                                                                 + 56);
  if (v6)
  {
    result = v6(CMBaseObject, CFSTR("ConnectionMode"), CFSTR("Client"));
    if ((_DWORD)result)
      return result;
    if (a2)
    {
      v8 = CFGetTypeID(a2);
      if (v8 != FigCFIOKitObjectGetTypeID())
        return 4294955259;
      v9 = NeroTransportConnectionGetCMBaseObject(*(_QWORD *)(a1 + 80));
      v10 = *(uint64_t (**)(uint64_t, const __CFString *, const void *))(*(_QWORD *)(CMBaseObjectGetVTable(v9)
                                                                                            + 8)
                                                                                + 56);
      if (!v10)
        return 4294954514;
      result = v10(v9, CFSTR("Service"), a2);
      if ((_DWORD)result)
        return result;
    }
    v11 = *(_QWORD *)(a1 + 80);
    v12 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v11) + 16) + 16);
    if (v12)
      return v12(v11);
  }
  return 4294954514;
}

uint64_t NeroTransportDisconnectFromReceiver(uint64_t a1)
{
  uint64_t v1;
  void (*v2)(uint64_t);

  v1 = *(_QWORD *)(a1 + 80);
  v2 = *(void (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v1) + 16) + 24);
  if (v2)
    v2(v1);
  return 0;
}

uint64_t NeroTransportSetAsConnected(uint64_t a1)
{
  *(_BYTE *)(a1 + 72) = 1;
  return FigTransportConnectionUSBSetAsConnected(*(_QWORD *)(a1 + 80));
}

uint64_t NeroTransportIsConnected(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 72);
}

BOOL NeroTransportIsHiSpeed(uint64_t a1)
{
  uint64_t CMBaseObject;
  void (*v2)(uint64_t, const __CFString *, _QWORD, CFTypeRef *);
  CFTypeRef v3;
  CFTypeRef v4;
  CFTypeRef cf;

  cf = 0;
  CMBaseObject = NeroTransportConnectionGetCMBaseObject(*(_QWORD *)(a1 + 80));
  v2 = *(void (**)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                           + 8)
                                                                               + 48);
  if (v2)
  {
    v2(CMBaseObject, CFSTR("IsHiSpeed"), *MEMORY[0x1E0C9AE00], &cf);
    v3 = cf;
    v4 = (CFTypeRef)*MEMORY[0x1E0C9AE50];
    if (cf)
      CFRelease(cf);
  }
  else
  {
    v3 = 0;
    v4 = (CFTypeRef)*MEMORY[0x1E0C9AE50];
  }
  return v3 == v4;
}

uint64_t FigTransportGetLocalRootObject()
{
  return 0;
}

uint64_t FigTransportGetRemoteRootObject()
{
  return 1;
}

uint64_t NeroTransportRegisterObjectWithFlags(uint64_t a1, const void *a2, char a3, _QWORD *a4, NSObject *a5, const void *a6, const void *a7)
{
  _QWORD *v7;
  NSObject *v15;
  uint64_t v16;
  _QWORD v18[6];

  if (!a1)
    return 4294955265;
  if (a6)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    if (!*(_BYTE *)(a1 + 16))
    {
      if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), a2))
      {
        v16 = 4294955262;
LABEL_14:
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
        return v16;
      }
      v7 = malloc_type_calloc(1uLL, 0x20uLL, 0x10A004007F56D72uLL);
      *(_DWORD *)v7 = FigAtomicIncrement32((unsigned int *)&ft_createObjectRecord_sIdentifier);
      v7[1] = a5;
      dispatch_retain(a5);
      v7[2] = _Block_copy(a6);
      if (a7)
        v7[3] = _Block_copy(a7);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, v7);
      if (a4)
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), (const void *)*(unsigned int *)v7, a2);
      if ((a3 & 1) != 0 && *(_BYTE *)(a1 + 72))
      {
        CFRetain((CFTypeRef)a1);
        v15 = v7[1];
        v18[0] = MEMORY[0x1E0C809B0];
        v18[1] = 0x40000000;
        v18[2] = __NeroTransportRegisterObjectWithFlags_block_invoke;
        v18[3] = &__block_descriptor_tmp_48;
        v18[4] = v7;
        v18[5] = a1;
        dispatch_async(v15, v18);
      }
    }
    v16 = 0;
    if (a4)
      *a4 = *(unsigned int *)v7;
    goto LABEL_14;
  }
  return FigSignalErrorAt(4294955259, 0, 0, 0, 0, 0, 0);
}

uint64_t NeroTransportRegisterObject(uint64_t a1, const void *a2, NSObject *a3, const void *a4, const void *a5)
{
  return NeroTransportRegisterObjectWithFlags(a1, a2, 0, 0, a3, a4, a5);
}

uint64_t NeroTransportUnregisterObject(uint64_t a1, const void *a2)
{
  unsigned int *Value;
  unsigned int *v5;
  uint64_t v6;

  if (!a1)
    return 4294955265;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
  if (!*(_BYTE *)(a1 + 16))
  {
    Value = (unsigned int *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
    if (!Value)
    {
      v6 = 4294955263;
      goto LABEL_6;
    }
    v5 = Value;
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), a2);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 40), (const void *)*v5);
    ft_destroyObjectRecord((uint64_t)v5);
  }
  v6 = 0;
LABEL_6:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
  return v6;
}

void ft_destroyObjectRecord(uint64_t a1)
{
  if (a1)
  {
    dispatch_release(*(dispatch_object_t *)(a1 + 8));
    _Block_release(*(const void **)(a1 + 16));
    _Block_release(*(const void **)(a1 + 24));
    free((void *)a1);
  }
}

uint64_t NeroTransportCopyRegisteredObject(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  const void *Value;
  uint64_t v7;

  if (!a1)
    return 4294955265;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
  if (Value)
  {
    v7 = 0;
    *a3 = CFRetain(Value);
  }
  else
  {
    v7 = 4294955263;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
  return v7;
}

uint64_t NeroTransportSendAsyncMessage(uint64_t a1, uint64_t a2, int a3, CMBlockBufferRef theBuffer)
{
  uint64_t v8;
  void (*v9)(uint64_t, _DWORD *, CMBlockBufferRef, uint64_t);
  _DWORD v11[2];
  uint64_t v12;
  int v13;

  if (!a1)
    return 4294955265;
  if (!*(_BYTE *)(a1 + 72))
    return 4294955265;
  v11[0] = CMBlockBufferGetDataLength(theBuffer) + 20;
  v11[1] = 1634957678;
  v12 = a2;
  v13 = a3;
  v8 = *(_QWORD *)(a1 + 80);
  v9 = *(void (**)(uint64_t, _DWORD *, CMBlockBufferRef, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v8) + 16)
                                                                           + 32);
  if (v9)
    v9(v8, v11, theBuffer, 2);
  return 0;
}

uint64_t NeroTransportSendSyncMessageCreatingReply(uint64_t a1, uint64_t a2, int a3, OpaqueCMBlockBuffer *a4, _QWORD *a5)
{
  dispatch_semaphore_t v10;
  uint64_t v11;
  void (*v12)(uint64_t, _DWORD *, OpaqueCMBlockBuffer *, uint64_t);
  int64_t v13;
  dispatch_time_t v14;
  _QWORD *Value;
  uint64_t v16;
  CFTypeRef v17;
  _DWORD v19[2];
  uint64_t v20;
  int v21;
  dispatch_semaphore_t v22;

  v10 = dispatch_semaphore_create(0);
  if (a1 && *(_BYTE *)(a1 + 72))
  {
    v19[0] = CMBlockBufferGetDataLength(a4) + 28;
    v19[1] = 1937337955;
    v20 = a2;
    v21 = a3;
    v22 = v10;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 48));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), v10, 0);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 48));
    v11 = *(_QWORD *)(a1 + 80);
    v12 = *(void (**)(uint64_t, _DWORD *, OpaqueCMBlockBuffer *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v11)
                                                                                               + 16)
                                                                                   + 32);
    if (v12)
      v12(v11, v19, a4, 2);
    v13 = *(_QWORD *)(a1 + 64);
    if (v13)
      v14 = dispatch_time(0, v13);
    else
      v14 = -1;
    dispatch_semaphore_wait(v10, v14);
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 48));
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), v10);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 56), v10);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 48));
    if (Value)
    {
      v16 = *(unsigned int *)Value;
      if (a5 && !(_DWORD)v16)
      {
        v17 = (CFTypeRef)Value[1];
        if (v17)
          v17 = CFRetain(v17);
        v16 = 0;
        *a5 = v17;
      }
    }
    else
    {
      v16 = 4294955261;
    }
  }
  else
  {
    Value = 0;
    v16 = 4294955265;
  }
  if (v10)
    dispatch_release(v10);
  ft_destroyReplyRecord(Value);
  return v16;
}

void ft_destroyReplyRecord(_QWORD *a1)
{
  const void *v2;

  if (a1)
  {
    v2 = (const void *)a1[1];
    if (v2)
      CFRelease(v2);
    free(a1);
  }
}

uint64_t NeroTransportGetTypeID()
{
  if (NeroTransportGetTypeID_sRegisterNeroTransportTypeOnce != -1)
    dispatch_once(&NeroTransportGetTypeID_sRegisterNeroTransportTypeOnce, &__block_literal_global_39);
  return NeroTransportGetTypeID_sNeroTransportTypeID;
}

double neroTransport_Init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void neroTransport_Finalize(uint64_t *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  v2 = (const void *)a1[10];
  if (v2)
  {
    CFRelease(v2);
    a1[10] = 0;
  }
  FigSimpleMutexDestroy(a1[3]);
  FigSimpleMutexDestroy(a1[6]);
  v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
  v5 = (const void *)a1[7];
  if (v5)
  {
    CFRelease(v5);
    a1[7] = 0;
  }
  v6 = (const void *)a1[11];
  if (v6)
  {
    CFRelease(v6);
    a1[11] = 0;
  }
}

CFTypeRef neroTransport_CopyFormattingDesc()
{
  return CFRetain(CFSTR("[NeroTransport]"));
}

__CFString *neroTransport_CopyDebugDesc(const void *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  CFIndex v4;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("[NeroTransport %p retainCount:%d]"), a1, v4);
  return Mutable;
}

uint64_t NeroTransportCreate(uint64_t a1, const void *a2, uint64_t *a3)
{
  uint64_t Instance;
  pthread_mutex_t *v6;
  pthread_mutex_t *v7;
  const __CFAllocator *v8;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v10;
  CFMutableDictionaryRef v11;
  CFTypeRef v12;
  uint64_t CMBaseObject;
  unsigned int (*v14)(uint64_t, const __CFString *, const __CFAllocator *, CFTypeRef *);
  CFTypeID v15;
  CFNumberRef v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, const __CFString *, CFNumberRef);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t (*v23)(uint64_t, _QWORD, _QWORD *);
  _QWORD v25[5];
  int valuePtr;
  int v27;
  CFTypeRef cf;

  cf = 0;
  v27 = 1;
  if (!a3)
  {
    v20 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    Instance = 0;
    goto LABEL_30;
  }
  if (NeroTransportGetTypeID_sRegisterNeroTransportTypeOnce != -1)
    dispatch_once(&NeroTransportGetTypeID_sRegisterNeroTransportTypeOnce, &__block_literal_global_39);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v21 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    goto LABEL_21;
  }
  v6 = FigSimpleMutexCreate();
  *(_QWORD *)(Instance + 24) = v6;
  if (!v6)
    goto LABEL_36;
  v7 = FigSimpleMutexCreate();
  *(_QWORD *)(Instance + 48) = v7;
  if (!v7
    || (v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00],
        Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0),
        (*(_QWORD *)(Instance + 32) = Mutable) == 0)
    || (v10 = CFDictionaryCreateMutable(v8, 0, 0, 0), (*(_QWORD *)(Instance + 40) = v10) == 0)
    || (v11 = CFDictionaryCreateMutable(v8, 0, 0, 0), (*(_QWORD *)(Instance + 56) = v11) == 0))
  {
LABEL_36:
    v20 = 4294955266;
    goto LABEL_30;
  }
  *(_QWORD *)(Instance + 64) = 3000000000;
  if (!a2)
  {
    v21 = FigTransportConnectionUSBCreate((uint64_t)v8, (CFTypeRef *)(Instance + 80));
    if (!(_DWORD)v21)
    {
      v12 = *(CFTypeRef *)(Instance + 80);
      goto LABEL_12;
    }
LABEL_21:
    v20 = v21;
    goto LABEL_30;
  }
  v12 = CFRetain(a2);
  *(_QWORD *)(Instance + 80) = v12;
LABEL_12:
  CMBaseObject = NeroTransportConnectionGetCMBaseObject(v12);
  v14 = *(unsigned int (**)(uint64_t, const __CFString *, const __CFAllocator *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8) + 48);
  if (v14)
  {
    if (!v14(CMBaseObject, CFSTR("ReplyTimeout"), v8, &cf))
    {
      if (cf)
      {
        v15 = CFGetTypeID(cf);
        if (v15 == CFNumberGetTypeID())
        {
          valuePtr = 0;
          CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, &valuePtr);
          *(_QWORD *)(Instance + 64) = 1000000000 * valuePtr;
        }
      }
    }
  }
  v16 = CFNumberCreate(v8, kCFNumberSInt32Type, &v27);
  v17 = NeroTransportConnectionGetCMBaseObject(*(_QWORD *)(Instance + 80));
  v18 = *(uint64_t (**)(uint64_t, const __CFString *, CFNumberRef))(*(_QWORD *)(CMBaseObjectGetVTable(v17) + 8)
                                                                           + 56);
  if (v18)
  {
    v19 = v18(v17, CFSTR("Version"), v16);
    if ((_DWORD)v19)
    {
LABEL_19:
      v20 = v19;
      goto LABEL_28;
    }
    v22 = *(_QWORD *)(Instance + 80);
    v25[0] = MEMORY[0x1E0C809B0];
    v25[1] = 0x40000000;
    v25[2] = __NeroTransportCreate_block_invoke;
    v25[3] = &__block_descriptor_tmp_4_3;
    v25[4] = Instance;
    v23 = *(uint64_t (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable(v22) + 16) + 8);
    if (v23)
    {
      v19 = v23(v22, 0, v25);
      if (!(_DWORD)v19)
      {
        if (!a2)
          FigTransportConnectionXPCSetCurrentConnection(*(_QWORD *)(Instance + 80));
        v20 = 0;
        *a3 = Instance;
        Instance = 0;
        goto LABEL_28;
      }
      goto LABEL_19;
    }
  }
  v20 = 4294954514;
LABEL_28:
  if (v16)
    CFRelease(v16);
LABEL_30:
  if (cf)
    CFRelease(cf);
  if (Instance)
    CFRelease((CFTypeRef)Instance);
  return v20;
}

uint64_t NeroTransportCreateWithNTCXPCConnection(uint64_t a1, _QWORD *a2)
{
  CFTypeRef v3;
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __NeroTransportCreateWithNTCXPCConnection_block_invoke;
  block[3] = &__block_descriptor_tmp_5_3;
  block[4] = a1;
  if (NeroTransportCreateWithNTCXPCConnection_once != -1)
    dispatch_once(&NeroTransportCreateWithNTCXPCConnection_once, block);
  v3 = (CFTypeRef)NeroTransportCreateWithNTCXPCConnection_transport;
  if (NeroTransportCreateWithNTCXPCConnection_transport)
    v3 = CFRetain((CFTypeRef)NeroTransportCreateWithNTCXPCConnection_transport);
  *a2 = v3;
  return NeroTransportCreateWithNTCXPCConnection_err;
}

uint64_t NeroTransportInvalidate(uint64_t a1)
{
  uint64_t v2;
  void (*v3)(uint64_t, _QWORD, _QWORD);
  uint64_t CMBaseObject;
  uint64_t v5;
  void (*v6)(uint64_t);
  const void *v7;

  if (!*(_BYTE *)(a1 + 16))
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
    *(_BYTE *)(a1 + 16) = 1;
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 32), (CFDictionaryApplierFunction)ft_sendPendingMessagesObjectRecordApplier, 0);
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 32), (CFDictionaryApplierFunction)ft_destroyObjectRecordApplier, 0);
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 32));
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 40));
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 48));
    CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 56));
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 56), (CFDictionaryApplierFunction)ft_destroyReplyRecordApplier, 0);
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 56));
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 48));
    v2 = *(_QWORD *)(a1 + 80);
    v3 = *(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(v2) + 16) + 8);
    if (v3)
      v3(v2, 0, 0);
    *(_BYTE *)(a1 + 72) = 0;
    CMBaseObject = NeroTransportConnectionGetCMBaseObject(*(_QWORD *)(a1 + 80));
    if (CMBaseObject)
    {
      v5 = CMBaseObject;
      v6 = *(void (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8) + 24);
      if (v6)
        v6(v5);
    }
    v7 = *(const void **)(a1 + 80);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(a1 + 80) = 0;
    }
  }
  return 0;
}

void ft_sendPendingMessagesObjectRecordApplier(uint64_t a1, uint64_t a2)
{
  dispatch_sync(*(dispatch_queue_t *)(a2 + 8), &__block_literal_global_23);
}

void ft_destroyObjectRecordApplier(uint64_t a1, uint64_t a2)
{
  ft_destroyObjectRecord(a2);
}

void ft_destroyReplyRecordApplier(NSObject *a1, _QWORD *a2)
{
  if (a1)
    dispatch_semaphore_signal(a1);
  ft_destroyReplyRecord(a2);
}

void FigTransportSetSharedTransport(uint64_t a1)
{
  _QWORD block[5];

  if (FigTransportSetSharedTransport_sTransportQueueCreateOnce != -1)
    dispatch_once(&FigTransportSetSharedTransport_sTransportQueueCreateOnce, &__block_literal_global_7_2);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigTransportSetSharedTransport_block_invoke_2;
  block[3] = &__block_descriptor_tmp_9_4;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)sTransportQueue, block);
}

uint64_t FigTransportInitializeWithConnection(uint64_t a1)
{
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  FigTransportSetSharedTransport(0);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __FigTransportInitializeWithConnection_block_invoke;
  v4[3] = &unk_1E28E21C8;
  v4[4] = &v5;
  v4[5] = a1;
  dispatch_sync((dispatch_queue_t)sTransportQueue, v4);
  v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t FigTransportInitialize()
{
  return FigTransportInitializeWithConnection(0);
}

BOOL FigTransportIsHiSpeed()
{
  const void *v0;
  _BOOL8 IsHiSpeed;

  v0 = (const void *)ft_copySharedTransport();
  IsHiSpeed = NeroTransportIsHiSpeed((uint64_t)v0);
  if (v0)
    CFRelease(v0);
  return IsHiSpeed;
}

uint64_t ft_copySharedTransport()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __ft_copySharedTransport_block_invoke;
  block[3] = &unk_1E28E22B0;
  block[4] = &v3;
  dispatch_sync((dispatch_queue_t)sTransportQueue, block);
  v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t FigTransportCopyRegisteredObject(const void *a1, CFTypeRef *a2)
{
  const void *v4;
  uint64_t v5;

  v4 = (const void *)ft_copySharedTransport();
  v5 = NeroTransportCopyRegisteredObject((uint64_t)v4, a1, a2);
  if (v4)
    CFRelease(v4);
  return v5;
}

uint64_t FigTransportSendSyncMessageCreatingReply(uint64_t a1, int a2, OpaqueCMBlockBuffer *a3, _QWORD *a4)
{
  const void *v8;
  uint64_t v9;

  v8 = (const void *)ft_copySharedTransport();
  v9 = NeroTransportSendSyncMessageCreatingReply((uint64_t)v8, a1, a2, a3, a4);
  if (v8)
    CFRelease(v8);
  return v9;
}

void __ft_didReceiveAsyncPackage_block_invoke(uint64_t a1)
{
  _DWORD *Value;
  uint64_t v3;
  const void *v4;

  FigSimpleMutexLock(*(pthread_mutex_t **)(*(_QWORD *)(a1 + 32) + 24));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 32) + 32), *(const void **)(a1 + 40));
  if (Value && *Value == *(_DWORD *)(a1 + 64))
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16);
  else
    v3 = 0;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(*(_QWORD *)(a1 + 32) + 24));
  if (v3)
    (*(void (**)(uint64_t, _QWORD, _QWORD))(v3 + 16))(v3, *(unsigned int *)(a1 + 68), *(_QWORD *)(a1 + 56));
  v4 = *(const void **)(a1 + 56);
  if (v4)
    CFRelease(v4);
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

void __ft_didReceiveSyncPackage_block_invoke(uint64_t a1)
{
  _DWORD *Value;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  _QWORD v8[6];

  FigSimpleMutexLock(*(pthread_mutex_t **)(*(_QWORD *)(a1 + 32) + 24));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 32) + 32), *(const void **)(a1 + 40));
  if (Value && *Value == *(_DWORD *)(a1 + 72))
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 24);
  else
    v3 = 0;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(*(_QWORD *)(a1 + 32) + 24));
  if (v3)
  {
    v4 = *(unsigned int *)(a1 + 76);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = __ft_didReceiveSyncPackage_block_invoke_2;
    v8[3] = &__block_descriptor_tmp_19_0;
    v5 = *(_QWORD *)(a1 + 56);
    v6 = *(_QWORD *)(a1 + 64);
    v8[4] = *(_QWORD *)(a1 + 32);
    v8[5] = v6;
    (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD *))(v3 + 16))(v3, v4, v5, v8);
  }
  v7 = *(const void **)(a1 + 56);
  if (v7)
    CFRelease(v7);
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

_QWORD *__ft_didReceiveSyncPackage_block_invoke_2(_QWORD *result, int a2, CMBlockBufferRef theBuffer)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  void (*v8)(uint64_t, _DWORD *, CMBlockBufferRef, uint64_t);
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t);
  _DWORD v11[2];
  uint64_t v12;
  int v13;

  v3 = result[4];
  if (*(_BYTE *)(v3 + 72))
  {
    v6 = result[5];
    v11[0] = CMBlockBufferGetDataLength(theBuffer) + 20;
    v11[1] = 1919970425;
    v12 = v6;
    v13 = a2;
    v7 = *(_QWORD *)(v3 + 80);
    v8 = *(void (**)(uint64_t, _DWORD *, CMBlockBufferRef, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v7) + 16)
                                                                             + 32);
    if (v8)
      v8(v7, v11, theBuffer, 1);
    v9 = *(_QWORD *)(v3 + 80);
    result = (_QWORD *)CMBaseObjectGetVTable(v9);
    v10 = *(uint64_t (**)(uint64_t, uint64_t))(result[2] + 40);
    if (v10)
      return (_QWORD *)v10(v9, 1);
  }
  return result;
}

void ft_callAsyncHandlerForObjectRecordApplier(uint64_t a1, uint64_t a2, int *a3)
{
  int v5;
  const void *v6;
  _BYTE *v7;
  CFTypeRef v8;
  NSObject *v9;
  _QWORD block[8];
  int v11;

  v5 = *a3;
  v7 = (_BYTE *)*((_QWORD *)a3 + 1);
  v6 = (const void *)*((_QWORD *)a3 + 2);
  if (v6)
  {
    v8 = CFRetain(v6);
    if (!v7)
      return;
  }
  else
  {
    v8 = 0;
    if (!v7)
      return;
  }
  if (!v7[16])
  {
    CFRetain(v7);
    v9 = *(NSObject **)(a2 + 8);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __ft_callAsyncHandlerForObjectRecordApplier_block_invoke;
    block[3] = &__block_descriptor_tmp_21_3;
    block[4] = v7;
    block[5] = a1;
    v11 = v5;
    block[6] = a2;
    block[7] = v8;
    dispatch_async(v9, block);
  }
}

void __ft_callAsyncHandlerForObjectRecordApplier_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const void *v3;

  FigSimpleMutexLock(*(pthread_mutex_t **)(*(_QWORD *)(a1 + 32) + 24));
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 32) + 32), *(const void **)(a1 + 40)))
    v2 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16);
  else
    v2 = 0;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(*(_QWORD *)(a1 + 32) + 24));
  if (v2)
    (*(void (**)(uint64_t, _QWORD, _QWORD))(v2 + 16))(v2, *(unsigned int *)(a1 + 64), *(_QWORD *)(a1 + 56));
  v3 = *(const void **)(a1 + 56);
  if (v3)
    CFRelease(v3);
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

CFTypeRef __ft_copySharedTransport_block_invoke(uint64_t a1)
{
  CFTypeRef result;

  result = (CFTypeRef)sTransport;
  if (sTransport)
    result = CFRetain((CFTypeRef)sTransport);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t CMTimeSyncTimeOfDayClockGetTypeID()
{
  if (sRegisterFigTimeSyncTimeOfDayClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFigTimeSyncTimeOfDayClockTypeOnce, 0, (dispatch_function_t)RegisterFigTimeSyncTimeOfDayClockIDType);
  return sFigTimeSyncTimeOfDayClockID;
}

uint64_t RegisterFigTimeSyncTimeOfDayClockIDType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigTimeSyncTimeOfDayClockID = result;
  return result;
}

uint64_t CMTimeSyncTimeOfDayClockCreate(uint64_t a1, uint64_t *a2)
{
  uint64_t Instance;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  if (sTimeSyncFunctionsLoadedOnce_0 != -1)
  {
    dispatch_once_f(&sTimeSyncFunctionsLoadedOnce_0, 0, (dispatch_function_t)LoadTimeSyncFunctions_0);
    if (a2)
      goto LABEL_3;
LABEL_9:
    v5 = 4294951466;
    goto LABEL_10;
  }
  if (!a2)
    goto LABEL_9;
LABEL_3:
  if (sRegisterFigTimeSyncTimeOfDayClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFigTimeSyncTimeOfDayClockTypeOnce, 0, (dispatch_function_t)RegisterFigTimeSyncTimeOfDayClockIDType);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v4 = Instance;
    FigNTPClientCreate(*MEMORY[0x1E0C9AE00], (uint64_t *)(Instance + 32));
    goto LABEL_12;
  }
  v5 = 4294951465;
LABEL_10:
  result = FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)result)
    return result;
  v4 = 0;
LABEL_12:
  result = 0;
  *a2 = v4;
  return result;
}

void *LoadTimeSyncFunctions_0()
{
  unsigned int v0;
  void *v1;
  void *v2;
  void *result;

  v0 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigTimeSyncTimeOfDayClockTrace[1], CFSTR("ts_tod_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v0, 0, gFigTimeSyncTimeOfDayClockTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigTimeSyncTimeOfDayClockTrace[3], CFSTR("ts_tod_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &gFigTimeSyncTimeOfDayClockTrace[2]);
  v1 = dlopen("/System/Library/PrivateFrameworks/TimeSync.framework/TimeSync", 4);
  if (!v1)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  v2 = v1;
  sTimeSyncClockDispose_0 = (uint64_t (*)(void))dlsym(v1, "TimeSyncClockDispose");
  if (!sTimeSyncClockDispose_0)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncAddgPTPServices = (uint64_t)dlsym(v2, "TimeSyncAddgPTPServices");
  if (!sTimeSyncAddgPTPServices)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncgPTPManagerNotifyWhenAvailable = (uint64_t)dlsym(v2, "TimeSyncgPTPManagerNotifyWhenAvailable");
  if (!sTimeSyncgPTPManagerNotifyWhenAvailable)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  f7037e1403bc4fedb8e5d76c00b0b80a = (uint64_t)dlsym(v2, "TimeSyncAddCopresencePTPInstnce");
  if (!f7037e1403bc4fedb8e5d76c00b0b80a)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockCreateWithClockIdentifer_0 = (uint64_t)dlsym(v2, "TimeSyncClockCreateWithClockIdentifer");
  if (!sTimeSyncClockCreateWithClockIdentifer_0)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockGetClockTimeForHostTime = (uint64_t (*)(_QWORD, _QWORD))dlsym(v2, "TimeSyncClockGetClockTimeForHostTime");
  if (!sTimeSyncClockGetClockTimeForHostTime)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  sTimeSyncClockGetHostTimeForClockTime = (uint64_t (*)(_QWORD, _QWORD))dlsym(v2, "TimeSyncClockGetHostTimeForClockTime");
  if (!sTimeSyncClockGetHostTimeForClockTime)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  result = dlsym(v2, "TimeSyncClockCreateAudioClockDeviceUID");
  sTimeSyncClockCreateAudioClockDeviceUID = result;
  if (!result)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  return result;
}

uint64_t CMTimeSyncTimeOfDayClockGetClockTimeForHostTime(_QWORD *a1, uint64_t a2, CMTime *a3)
{
  CFTypeID v6;
  uint64_t v7;
  int64_t ClockTimeForHostTime;
  uint64_t result;
  CMTime v10;
  CMTime lhs;
  CMTime v12;
  CMTime v13;
  CMTime hostTime;
  CMTime v15;

  memset(&v15, 0, sizeof(v15));
  if (!a1)
    goto LABEL_12;
  v6 = CFGetTypeID(a1);
  if (sRegisterFigTimeSyncTimeOfDayClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFigTimeSyncTimeOfDayClockTypeOnce, 0, (dispatch_function_t)RegisterFigTimeSyncTimeOfDayClockIDType);
  if (v6 == sFigTimeSyncTimeOfDayClockID)
  {
    if ((*(_BYTE *)(a2 + 12) & 1) != 0)
    {
      if (a1[3])
      {
        hostTime = *(CMTime *)a2;
        v7 = CMClockConvertHostTimeToSystemUnits(&hostTime);
        ClockTimeForHostTime = sTimeSyncClockGetClockTimeForHostTime(a1[3], v7);
        CMTimeMake(&v15, ClockTimeForHostTime, 1000000000);
        if (!a3)
          return 0;
      }
      else
      {
        memset(&hostTime, 0, sizeof(hostTime));
        memset(&v13, 0, sizeof(v13));
        memset(&v12, 0, sizeof(v12));
        result = figTimeSyncTimeOfDayClock_GetTimeOfDayAnchorTime(a1[4], &v13, &hostTime);
        if ((_DWORD)result)
          return result;
        lhs = hostTime;
        v10 = *(CMTime *)a2;
        CMTimeSubtract(&v12, &lhs, &v10);
        lhs = v13;
        v10 = v12;
        CMTimeSubtract(&v15, &lhs, &v10);
        if (!a3)
          return 0;
      }
      result = 0;
      *a3 = v15;
      return result;
    }
  }
  else
  {
LABEL_12:
    FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t figTimeSyncTimeOfDayClock_GetTimeOfDayAnchorTime(uint64_t a1, CMTime *a2, CMTime *a3)
{
  uint64_t v5;
  uint64_t UpTime;
  int64_t v7;
  int64_t v8;
  CMTime v10;
  CMTime v11;
  __int128 v12;

  v12 = 0uLL;
  memset(&v11, 0, sizeof(v11));
  memset(&v10, 0, sizeof(v10));
  v5 = FigNTPGetTimeOfDay(a1, &v12);
  UpTime = FigGetUpTime();
  if (!(_DWORD)v5)
  {
    v7 = UpTime;
    CMTimeMake(&v11, (uint64_t)(((double)*((uint64_t *)&v12 + 1) / 1000000000.0 + (double)(uint64_t)v12) * 1000000.0), 1000000);
    v8 = FigHostTimeToNanoseconds(v7);
    CMTimeMake(&v10, v8, 1000000000);
    *a2 = v11;
    *a3 = v10;
  }
  return v5;
}

uint64_t CMTimeSyncTimeOfDayClockGetHostTimeForClockTime(_QWORD *a1, uint64_t a2, CMTime *a3)
{
  CFTypeID v6;
  uint64_t HostTimeForClockTime;
  uint64_t result;
  CMTime v9;
  CMTime lhs;
  CMTime v11;
  CMTime v12;
  CMTime time;
  CMTime v14;
  CMTime v15;

  memset(&v15, 0, sizeof(v15));
  if (!a1)
    goto LABEL_12;
  v6 = CFGetTypeID(a1);
  if (sRegisterFigTimeSyncTimeOfDayClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFigTimeSyncTimeOfDayClockTypeOnce, 0, (dispatch_function_t)RegisterFigTimeSyncTimeOfDayClockIDType);
  if (v6 == sFigTimeSyncTimeOfDayClockID)
  {
    if ((*(_BYTE *)(a2 + 12) & 1) != 0)
    {
      if (a1[3])
      {
        time = *(CMTime *)a2;
        CMTimeConvertScale(&v14, &time, 1000000000, kCMTimeRoundingMethod_RoundHalfAwayFromZero);
        HostTimeForClockTime = sTimeSyncClockGetHostTimeForClockTime(a1[3], v14.value);
        CMClockMakeHostTimeFromSystemUnits(&v15, HostTimeForClockTime);
        if (!a3)
          return 0;
      }
      else
      {
        memset(&time, 0, sizeof(time));
        memset(&v12, 0, sizeof(v12));
        memset(&v11, 0, sizeof(v11));
        result = figTimeSyncTimeOfDayClock_GetTimeOfDayAnchorTime(a1[4], &v12, &time);
        if ((_DWORD)result)
          return result;
        lhs = v12;
        v9 = *(CMTime *)a2;
        CMTimeSubtract(&v11, &lhs, &v9);
        lhs = time;
        v9 = v11;
        CMTimeSubtract(&v15, &lhs, &v9);
        if (!a3)
          return 0;
      }
      result = 0;
      *a3 = v15;
      return result;
    }
  }
  else
  {
LABEL_12:
    FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

BOOL CMTimeSyncTimeOfDayClockIsUsingTimeSync(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24) != 0;
}

uint64_t CMTimeSyncTimeOfDayClockCopyDeviceIdentifier(uint64_t a1, _QWORD *a2)
{
  if (!*(_QWORD *)(a1 + 24))
    return FigSignalErrorAt(4294951464, 0, 0, 0, 0, 0, 0);
  *a2 = sTimeSyncClockCreateAudioClockDeviceUID();
  return 0;
}

_QWORD *figTimeSyncTimeOfDayClock_Init(_QWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void figTimeSyncTimeOfDayClock_Finalize(uint64_t a1)
{
  const void *v2;

  if (*(_QWORD *)(a1 + 24))
  {
    sTimeSyncClockDispose_0();
    *(_QWORD *)(a1 + 24) = 0;
  }
  v2 = *(const void **)(a1 + 32);
  if (v2)
    CFRelease(v2);
}

CFStringRef figTimeSyncTimeOfDayClock_CopyFormattingDesc(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("CMTimeSyncTimeOfDayClock"));
}

CFStringRef figTimeSyncTimeOfDayClock_CopyDebugDesc(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v1, 0, CFSTR("CMTimeSyncTimeOfDayClock"));
}

CFArrayRef FigTextMarkupCreateARGBColorArrayFromCGColor(CGColor *a1)
{
  size_t NumberOfComponents;
  CGColorSpace *ColorSpace;
  const CGFloat *Components;

  NumberOfComponents = CGColorGetNumberOfComponents(a1);
  ColorSpace = CGColorGetColorSpace(a1);
  if (CGColorSpaceGetModel(ColorSpace) == kCGColorSpaceModelRGB
    && (Components = CGColorGetComponents(a1), NumberOfComponents == 4))
  {
    return createARGBColorArrayFromComponents(Components[3], *Components, Components[1], Components[2]);
  }
  else
  {
    return 0;
  }
}

CFArrayRef createARGBColorArrayFromComponents(double a1, double a2, double a3, double a4)
{
  const __CFAllocator *v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFArrayRef v9;
  double v11;
  double v12;
  double v13;
  double valuePtr;
  void *values[5];

  values[4] = *(void **)MEMORY[0x1E0C80C00];
  v13 = a2;
  valuePtr = a1;
  v11 = a4;
  v12 = a3;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCGFloatType, &valuePtr);
  v6 = CFNumberCreate(v4, kCFNumberCGFloatType, &v13);
  v7 = CFNumberCreate(v4, kCFNumberCGFloatType, &v12);
  v8 = CFNumberCreate(v4, kCFNumberCGFloatType, &v11);
  values[0] = v5;
  values[1] = v6;
  values[2] = v7;
  values[3] = v8;
  v9 = CFArrayCreate(v4, (const void **)values, 4, MEMORY[0x1E0C9B378]);
  CFRelease(v5);
  CFRelease(v6);
  CFRelease(v7);
  CFRelease(v8);
  return v9;
}

CFTypeRef FigTextMarkupCreateBlackARGBColorArray()
{
  if (FigTextMarkupCreateBlackARGBColorArray_sBlackOnce != -1)
    dispatch_once_f(&FigTextMarkupCreateBlackARGBColorArray_sBlackOnce, &FigTextMarkupCreateBlackARGBColorArray_sBlackColor, (dispatch_function_t)figTextMarkupCreateBlackARGBColorArrayAndStoreInContextPtr);
  return CFRetain((CFTypeRef)FigTextMarkupCreateBlackARGBColorArray_sBlackColor);
}

CFArrayRef figTextMarkupCreateBlackARGBColorArrayAndStoreInContextPtr(CFArrayRef *a1)
{
  CFArrayRef result;

  result = createARGBColorArrayFromComponents(1.0, 0.0, 0.0, 0.0);
  *a1 = result;
  return result;
}

CFTypeRef FigTextMarkupCreateWhiteARGBColorArray()
{
  if (FigTextMarkupCreateWhiteARGBColorArray_sWhiteOnce != -1)
    dispatch_once_f(&FigTextMarkupCreateWhiteARGBColorArray_sWhiteOnce, &FigTextMarkupCreateWhiteARGBColorArray_sWhiteColor, (dispatch_function_t)figTextMarkupCreateWhiteARGBColorArrayAndStoreInContextPtr);
  return CFRetain((CFTypeRef)FigTextMarkupCreateWhiteARGBColorArray_sWhiteColor);
}

CFArrayRef figTextMarkupCreateWhiteARGBColorArrayAndStoreInContextPtr(CFArrayRef *a1)
{
  CFArrayRef result;

  result = createARGBColorArrayFromComponents(1.0, 1.0, 1.0, 1.0);
  *a1 = result;
  return result;
}

CFTypeRef FigTextMarkupCreateClearARGBColorArray()
{
  if (FigTextMarkupCreateClearARGBColorArray_sClearOnce != -1)
    dispatch_once_f(&FigTextMarkupCreateClearARGBColorArray_sClearOnce, &FigTextMarkupCreateClearARGBColorArray_sClearColor, (dispatch_function_t)figTextMarkupCreateClearARGBColorArrayAndStoreInContextPtr);
  return CFRetain((CFTypeRef)FigTextMarkupCreateClearARGBColorArray_sClearColor);
}

CFArrayRef figTextMarkupCreateClearARGBColorArrayAndStoreInContextPtr(CFArrayRef *a1)
{
  CFArrayRef result;

  result = createARGBColorArrayFromComponents(0.0, 0.0, 0.0, 0.0);
  *a1 = result;
  return result;
}

CFDictionaryRef FigTextMarkupDimensionCopyAsSimplifiedDictionary(uint64_t a1, uint64_t a2, const __CFAllocator *a3)
{
  CFDictionaryRef v3;
  const __CFString *v5;
  CFTypeRef v6;
  const void *v7;
  CFTypeRef v8;
  CFIndex v9;
  uint64_t i;
  const void *v11;
  uint64_t valuePtr;
  uint64_t v14;
  void *values;
  CFTypeRef v16;
  CFTypeRef v17;
  void *keys[2];
  const __CFString *v19;
  uint64_t v20;

  v3 = 0;
  v20 = *MEMORY[0x1E0C80C00];
  valuePtr = a1;
  v14 = a2;
  *(_OWORD *)keys = xmmword_1E28E2948;
  v19 = CFSTR("isReversed");
  values = 0;
  v16 = 0;
  v17 = 0;
  if ((a2 & 0x100000000) == 0)
    goto LABEL_33;
  v3 = 0;
  if ((int)a2 > 1886920735)
  {
    if ((int)a2 <= 1986879863)
    {
      if ((_DWORD)a2 == 1886920736)
      {
        v5 = CFSTR("px");
      }
      else
      {
        if ((_DWORD)a2 != 1986535456)
          goto LABEL_33;
        v5 = CFSTR("vh");
      }
    }
    else
    {
      switch((_DWORD)a2)
      {
        case 0x766D6178:
          v5 = CFSTR("vmax");
          break;
        case 0x766D696E:
          v5 = CFSTR("vmin");
          break;
        case 0x76772020:
          v5 = CFSTR("vw");
          break;
        default:
          goto LABEL_33;
      }
    }
  }
  else if ((int)a2 <= 1701650463)
  {
    if ((_DWORD)a2 == 622862368)
    {
      v5 = CFSTR("%");
    }
    else
    {
      if ((_DWORD)a2 != 1667591276)
        goto LABEL_33;
      v5 = CFSTR("c");
    }
  }
  else
  {
    switch((_DWORD)a2)
    {
      case 0x656D2020:
        v5 = CFSTR("em");
        break;
      case 0x6C696E65:
        v5 = CFSTR("li");
        break;
      case 0x70747320:
        v5 = CFSTR("pt");
        break;
      default:
        goto LABEL_33;
    }
  }
  v6 = CFRetain(v5);
  if (v6)
  {
    v7 = v6;
    values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCGFloatType, &valuePtr);
    v16 = CFRetain(v7);
    if ((~HIDWORD(v14) & 0x21) != 0)
    {
      v9 = 2;
    }
    else
    {
      v8 = (CFTypeRef)*MEMORY[0x1E0C9AE50];
      if (*MEMORY[0x1E0C9AE50])
        v8 = CFRetain(v8);
      v17 = v8;
      v9 = 3;
    }
    v3 = CFDictionaryCreate(a3, (const void **)keys, (const void **)&values, v9, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFRelease(v7);
  }
  else
  {
    v3 = 0;
  }
LABEL_33:
  for (i = 0; i != 24; i += 8)
  {
    v11 = *(void **)((char *)&values + i);
    if (v11)
      CFRelease(v11);
  }
  return v3;
}

uint64_t FigTextMarkupDimensionMakeFromSimplifiedDictionary(const void *a1)
{
  uint64_t v1;
  CFTypeID v3;
  const void *Value;
  CFTypeID v5;
  Boolean v7;
  uint64_t v8;

  v1 = 0;
  if (a1)
  {
    v3 = CFGetTypeID(a1);
    if (v3 == CFDictionaryGetTypeID())
    {
      v8 = 0;
      if (FigCFDictionaryGetCGFloatIfPresent((uint64_t)a1, CFSTR("value"), &v8))
      {
        Value = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("units"));
        v7 = 0;
        FigCFDictionaryGetBooleanIfPresent((uint64_t)a1, CFSTR("isReversed"), &v7);
        if (Value)
        {
          v5 = CFGetTypeID(Value);
          if (v5 == CFStringGetTypeID()
            && (CFEqual(Value, CFSTR("%"))
             || CFEqual(Value, CFSTR("pt"))
             || CFEqual(Value, CFSTR("px"))
             || CFEqual(Value, CFSTR("c"))
             || CFEqual(Value, CFSTR("li"))
             || CFEqual(Value, CFSTR("vw"))
             || CFEqual(Value, CFSTR("vh"))
             || CFEqual(Value, CFSTR("vmin"))
             || CFEqual(Value, CFSTR("vmax"))
             || CFEqual(Value, CFSTR("em"))))
          {
            return v8;
          }
        }
      }
    }
  }
  return v1;
}

CFDictionaryRef FigTextMarkupSizeCopyAsSimplifiedDictionary(uint64_t *a1, const __CFAllocator *a2)
{
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  CFDictionaryRef v6;
  BOOL v7;
  CFDictionaryRef v8;
  CFDictionaryRef v10;
  const void *v11[2];
  void *keys[2];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = FigTextMarkupDimensionCopyAsSimplifiedDictionary(*a1, a1[1], a2);
  v5 = FigTextMarkupDimensionCopyAsSimplifiedDictionary(a1[2], a1[3], a2);
  v6 = v5;
  if (v4)
    v7 = v5 == 0;
  else
    v7 = 1;
  if (!v7)
  {
    *(_OWORD *)keys = xmmword_1E28E2960;
    v11[0] = v4;
    v11[1] = v5;
    v10 = CFDictionaryCreate(a2, (const void **)keys, v11, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    goto LABEL_10;
  }
  v10 = 0;
  v8 = 0;
  if (v4)
  {
LABEL_10:
    CFRelease(v4);
    v8 = v10;
    if (!v6)
      return v8;
    goto LABEL_8;
  }
  if (v5)
LABEL_8:
    CFRelease(v6);
  return v8;
}

uint64_t FigTextMarkupSizeMakeFromSimplifiedDictionary@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  const __CFDictionary *v3;
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeRef cf;
  void *value;

  *(_OWORD *)a2 = kFigGeometrySizeInvalid;
  *(_OWORD *)(a2 + 16) = unk_18EDDCA58;
  cf = 0;
  value = 0;
  if (result)
  {
    v3 = (const __CFDictionary *)result;
    v4 = CFGetTypeID((CFTypeRef)result);
    result = CFDictionaryGetTypeID();
    if (v4 == result)
    {
      result = CFDictionaryGetValueIfPresent(v3, CFSTR("width"), (const void **)&value);
      if ((_DWORD)result)
      {
        result = CFDictionaryGetValueIfPresent(v3, CFSTR("height"), &cf);
        if ((_DWORD)result)
        {
          result = (uint64_t)value;
          if (value)
          {
            v5 = CFGetTypeID(value);
            result = CFDictionaryGetTypeID();
            if (v5 == result)
            {
              result = (uint64_t)cf;
              if (cf)
              {
                v6 = CFGetTypeID(cf);
                result = CFDictionaryGetTypeID();
                if (v6 == result)
                {
                  v7 = FigTextMarkupDimensionMakeFromSimplifiedDictionary(value);
                  v9 = v8;
                  v10 = FigTextMarkupDimensionMakeFromSimplifiedDictionary(cf);
                  return FigGeometrySizeMake(v7, v9, v10, v11, (_QWORD *)a2);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

CFDictionaryRef FigTextMarkupAspectRatioCopyAsSimplifiedDictionary(uint64_t a1, const __CFAllocator *a2)
{
  const __CFAllocator *v3;
  CFDictionaryRef v4;
  uint64_t v5;
  char v6;
  char v7;
  const void *v8;
  uint64_t valuePtr;
  void *values[2];
  void *keys[2];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  valuePtr = a1;
  *(_OWORD *)keys = xmmword_1E28E2970;
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  values[1] = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  v4 = CFDictionaryCreate(a2, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v5 = 0;
  v6 = 1;
  do
  {
    v7 = v6;
    v8 = values[v5];
    if (v8)
      CFRelease(v8);
    v6 = 0;
    v5 = 1;
  }
  while ((v7 & 1) != 0);
  return v4;
}

unint64_t FigTextMarkupAspectRatioMakeFromSimplifiedDictionary(const void *a1)
{
  uint64_t v1;
  CFTypeID v3;
  unsigned int v5;
  unsigned int v6;

  v1 = 0;
  v5 = 1;
  v6 = 1;
  if (a1)
  {
    v3 = CFGetTypeID(a1);
    if (v3 == CFDictionaryGetTypeID()
      && FigCFDictionaryGetInt32IfPresent((uint64_t)a1, CFSTR("horizontal"), &v6)
      && FigCFDictionaryGetInt32IfPresent((uint64_t)a1, CFSTR("vertical"), &v5))
    {
      return FigGeometryAspectRatioMake(v6, v5);
    }
  }
  return v1;
}

uint64_t FigTextMarkupCreateTextMarkupFromRubyReserve(const void *a1, const __CFAllocator *a2, __CFDictionary **a3)
{
  CFTypeID v6;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v8;
  const void *RubyPosition;
  uint64_t Length;
  uint64_t v11;
  CFDictionaryRef v12;
  CFDictionaryRef v13;
  const __CFString *v14;
  uint64_t v16;
  uint64_t v17;

  if (!a1 || !a3 || (v6 = CFGetTypeID(a1), v6 != FigCaptionRubyReserveGetTypeID()))
  {
    v16 = 4294950506;
    return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
  }
  Mutable = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    v16 = 0xFFFFFFFFLL;
    return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
  }
  v8 = Mutable;
  RubyPosition = (const void *)FigCaptionRubyReserveGetRubyPosition((uint64_t)a1);
  Length = FigCaptionRubyReserveGetLength((uint64_t)a1);
  v12 = FigGeometryDimensionCopyAsDictionary(Length, v11, a2);
  if (v12)
  {
    v13 = v12;
    if (RubyPosition)
    {
      if (FigCFEqual(RubyPosition, CFSTR("RubyPositionBefore")))
      {
        v14 = CFSTR("CMRubyPosition_Before");
LABEL_15:
        CFDictionarySetValue(v8, CFSTR("CMRubyReservePosition"), v14);
        goto LABEL_16;
      }
      if (FigCFEqual(RubyPosition, CFSTR("RubyPositionAfter")))
      {
        v14 = CFSTR("CMRubyPosition_After");
        goto LABEL_15;
      }
      if (FigCFEqual(RubyPosition, CFSTR("RubyPositionOutside")))
      {
        v14 = CFSTR("CMRubyPosition_Outside");
        goto LABEL_15;
      }
      if (FigCFEqual(RubyPosition, CFSTR("RubyPositionBoth")))
      {
        v14 = CFSTR("CMRubyPosition_Both");
        goto LABEL_15;
      }
    }
LABEL_16:
    CFDictionarySetValue(v8, CFSTR("CMRubyReserveLength"), v13);
    *a3 = v8;
    CFRelease(v13);
    return 0;
  }
  v17 = FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
  CFRelease(v8);
  return v17;
}

uint64_t FigTextMarkupCreateRubyReserveFromTextMarkup(const void *a1, uint64_t a2, _QWORD *a3)
{
  CFTypeID v6;
  const void *Value;
  const void *v8;
  CFTypeID v9;
  const void *v10;
  const void *v11;
  CFTypeID v12;
  const void *v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;

  v16 = 0;
  if (!a1)
    return FigSignalErrorAt(4294950506, 0, 0, 0, 0, 0, 0);
  if (!a3)
    return FigSignalErrorAt(4294950506, 0, 0, 0, 0, 0, 0);
  v6 = CFGetTypeID(a1);
  if (v6 != CFDictionaryGetTypeID())
    return FigSignalErrorAt(4294950506, 0, 0, 0, 0, 0, 0);
  Value = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("CMRubyReservePosition"));
  if (!Value)
    return FigSignalErrorAt(4294950506, 0, 0, 0, 0, 0, 0);
  v8 = Value;
  v9 = CFGetTypeID(Value);
  if (v9 != CFStringGetTypeID())
    return FigSignalErrorAt(4294950506, 0, 0, 0, 0, 0, 0);
  v10 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("CMRubyReserveLength"));
  if (!v10)
    return FigSignalErrorAt(4294950506, 0, 0, 0, 0, 0, 0);
  v11 = v10;
  v12 = CFGetTypeID(v10);
  if (v12 != CFDictionaryGetTypeID())
    return FigSignalErrorAt(4294950506, 0, 0, 0, 0, 0, 0);
  v13 = FigGeometryDimensionMakeFromDictionary(v11);
  result = FigCaptionRubyReserveCreate(a2, v8, (uint64_t)v13, v14, &v16);
  *a3 = v16;
  return result;
}

uint64_t FigTextMarkupCreateTextMarkupFromTextEmphasis(const void *a1, const __CFAllocator *a2, __CFDictionary **a3)
{
  CFTypeID v6;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v8;
  int EmphasisStyle;
  CGColor *Color;
  const void *RubyPosition;
  const __CFString *v12;
  const __CFString *v13;
  int MarkingStyle;
  int PredefinedMark;
  int v16;
  char v17;
  const __CFString *v18;
  uint64_t CustomMark;
  __CFDictionary *v20;
  const __CFString *v21;
  uint64_t result;
  __CFString *v23;
  uint64_t v24;

  if (!a1 || !a3 || (v6 = CFGetTypeID(a1), v6 != FigCaptionTextEmphasisGetTypeID()))
  {
    v24 = 4294950506;
    return FigSignalErrorAt(v24, 0, 0, 0, 0, 0, 0);
  }
  Mutable = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    v24 = 0xFFFFFFFFLL;
    return FigSignalErrorAt(v24, 0, 0, 0, 0, 0, 0);
  }
  v8 = Mutable;
  EmphasisStyle = FigCaptionTextEmphasisGetEmphasisStyle((uint64_t)a1);
  Color = (CGColor *)FigCaptionTextEmphasisGetColor((uint64_t)a1);
  RubyPosition = (const void *)FigCaptionTextEmphasisGetRubyPosition((uint64_t)a1);
  v12 = CFSTR("None");
  switch(EmphasisStyle)
  {
    case 0:
      goto LABEL_7;
    case 1:
      v12 = CFSTR("Auto");
LABEL_7:
      v13 = CFSTR("CMTextEmphasisType");
      goto LABEL_13;
    case 2:
      CFDictionarySetValue(v8, CFSTR("CMTextEmphasisType"), CFSTR("Predefined"));
      MarkingStyle = FigCaptionTextEmphasisGetMarkingStyle((uint64_t)a1);
      PredefinedMark = FigCaptionTextEmphasisGetPredefinedMark((uint64_t)a1);
      v16 = PredefinedMark;
      if (MarkingStyle == 2)
      {
        v17 = 0;
        v18 = CFSTR("Stroked");
      }
      else if (MarkingStyle == 1)
      {
        v17 = 0;
        v18 = CFSTR("Filled");
      }
      else
      {
        v18 = 0;
        v17 = 1;
      }
      if ((PredefinedMark - 1) > 2)
      {
        v23 = 0;
        if ((v17 & 1) != 0)
          goto LABEL_36;
      }
      else
      {
        v23 = off_1E28E29E0[PredefinedMark - 1];
        if ((v17 & 1) != 0)
          goto LABEL_36;
      }
      CFDictionarySetValue(v8, CFSTR("CMTextEmphasisMarkingStyle"), v18);
LABEL_36:
      if (v16)
      {
        v13 = CFSTR("CMTextEmphasisMarkType");
        v20 = v8;
        v12 = v23;
LABEL_14:
        CFDictionarySetValue(v20, v13, v12);
      }
LABEL_15:
      if (Color)
      {
        Color = FigTextMarkupCreateARGBColorArrayFromCGColor(Color);
        if (Color)
          CFDictionarySetValue(v8, CFSTR("CMTextEmphasisColor"), Color);
      }
      if (FigCFEqual(RubyPosition, CFSTR("RubyPositionAfter")))
      {
        v21 = CFSTR("CMRubyPosition_After");
        if (!RubyPosition)
          goto LABEL_21;
        goto LABEL_20;
      }
      if (FigCFEqual(RubyPosition, CFSTR("RubyPositionOutside")))
        v21 = CFSTR("CMRubyPosition_Outside");
      else
        v21 = CFSTR("CMRubyPosition_Before");
      if (RubyPosition)
LABEL_20:
        CFDictionarySetValue(v8, CFSTR("CMTextEmphasisPosition"), v21);
LABEL_21:
      *a3 = v8;
      if (Color)
        CFRelease(Color);
      result = 0;
      break;
    case 3:
      CFDictionarySetValue(v8, CFSTR("CMTextEmphasisType"), CFSTR("Custom"));
      CustomMark = FigCaptionTextEmphasisGetCustomMark((uint64_t)a1);
      if (!CustomMark)
        goto LABEL_15;
      v12 = (const __CFString *)CustomMark;
      v13 = CFSTR("CMTextEmphasisCustomMark");
LABEL_13:
      v20 = v8;
      goto LABEL_14;
    default:
      goto LABEL_15;
  }
  return result;
}

uint64_t FigTextMarkupCreateTextMarkupFromAbstractPosition(const void *a1, const __CFAllocator *a2, CFMutableDictionaryRef *a3)
{
  CFTypeID v6;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v8;
  int HorizontalEdgeReference;
  int VerticalEdgeReference;
  uint64_t HorizontalEdgeOffset;
  uint64_t v12;
  uint64_t v13;
  uint64_t VerticalEdgeOffset;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFDictionaryRef v18;
  CFDictionaryRef v19;
  CFDictionaryRef v20;
  const __CFString *EdgeReferenceMarkupAttributeValue;
  const __CFString *v22;
  uint64_t v23;
  uint64_t v25;

  if (!a1 || !a3 || (v6 = CFGetTypeID(a1), v6 != FigCaptionPositionGetTypeID()))
  {
    v25 = 4294950506;
    return FigSignalErrorAt(v25, 0, 0, 0, 0, 0, 0);
  }
  Mutable = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    v25 = 0xFFFFFFFFLL;
    return FigSignalErrorAt(v25, 0, 0, 0, 0, 0, 0);
  }
  v8 = Mutable;
  HorizontalEdgeReference = FigCaptionPositionGetHorizontalEdgeReference((uint64_t)a1);
  VerticalEdgeReference = FigCaptionPositionGetVerticalEdgeReference((uint64_t)a1);
  HorizontalEdgeOffset = FigCaptionPositionGetHorizontalEdgeOffset((uint64_t)a1);
  v13 = v12;
  VerticalEdgeOffset = FigCaptionPositionGetVerticalEdgeOffset((uint64_t)a1);
  if ((v13 & 0x1D00000000) == 0x100000000)
  {
    v16 = VerticalEdgeOffset;
    v17 = v15;
    v18 = FigGeometryDimensionCopyAsDictionary(HorizontalEdgeOffset, v13, a2);
    if (!v18 || (v19 = FigGeometryDimensionCopyAsDictionary(v16, v17, a2)) == 0)
    {
      v23 = FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
      CFRelease(v8);
      v20 = 0;
      if (!v18)
        goto LABEL_20;
      goto LABEL_19;
    }
    v20 = v19;
  }
  else
  {
    v18 = 0;
    v20 = 0;
  }
  EdgeReferenceMarkupAttributeValue = ftmarkup_getEdgeReferenceMarkupAttributeValue(HorizontalEdgeReference);
  v22 = ftmarkup_getEdgeReferenceMarkupAttributeValue(VerticalEdgeReference);
  if (EdgeReferenceMarkupAttributeValue)
    CFDictionarySetValue(v8, CFSTR("CMHorizontalEdgeReference"), EdgeReferenceMarkupAttributeValue);
  if (v22)
    CFDictionarySetValue(v8, CFSTR("CMVerticalEdgeReference"), v22);
  if (v18)
    CFDictionarySetValue(v8, CFSTR("CMHorizontalEdgeOffset"), v18);
  if (v20)
    CFDictionarySetValue(v8, CFSTR("CMVerticalEdgeOffset"), v20);
  v23 = 0;
  *a3 = v8;
  if (!v18)
    goto LABEL_20;
LABEL_19:
  CFRelease(v18);
LABEL_20:
  if (v20)
    CFRelease(v20);
  return v23;
}

const __CFString *ftmarkup_getEdgeReferenceMarkupAttributeValue(int a1)
{
  if (a1 > 1701999214)
  {
    if (a1 > 1919510375)
    {
      if (a1 == 1919510376)
        return CFSTR("CMEdgeReference_Right");
      if (a1 == 1953460256)
        return CFSTR("CMEdgeReference_Top");
      goto LABEL_14;
    }
    if (a1 != 1701999215)
    {
      if (a1 == 1818584692)
        return CFSTR("CMEdgeReference_Left");
LABEL_14:
      FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  if (!a1)
    return 0;
  if (a1 != 1651471476)
  {
    if (a1 == 1667591796)
      return CFSTR("CMEdgeReference_Center");
    goto LABEL_14;
  }
  return CFSTR("CMEdgeReference_Bottom");
}

uint64_t FigTextMarkupCreateTextMarkupFromTextShadowList(const void *a1, const __CFAllocator *a2, __CFDictionary **a3)
{
  __CFDictionary **v3;
  CFTypeID v5;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v7;
  const __CFArray *TextShadowArray;
  const __CFArray *v9;
  CFIndex v10;
  __CFDictionary *v11;
  __CFArray *v12;
  void *Color;
  CFDictionaryRef v14;
  CFDictionaryRef v15;
  CFDictionaryRef v16;
  const void *ValueAtIndex;
  uint64_t v18;
  CFTypeID v19;
  __CFDictionary *v20;
  uint64_t HorizontalAxisOffset;
  uint64_t v22;
  uint64_t v23;
  uint64_t VerticalAxisOffset;
  uint64_t v25;
  uint64_t v26;
  uint64_t BlurRadius;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v32;
  __CFDictionary **v33;
  __CFDictionary *theDict;
  const __CFAllocator *v35;
  const __CFArray *v36;
  CFMutableArrayRef theArray;

  if (a1 && (v3 = a3) != 0 && (v5 = CFGetTypeID(a1), v5 == FigCaptionTextShadowListGetTypeID()))
  {
    Mutable = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v7 = Mutable;
      TextShadowArray = (const __CFArray *)FigCaptionTextShadowListGetTextShadowArray((uint64_t)a1);
      v9 = TextShadowArray;
      if (TextShadowArray)
      {
        if (CFArrayGetCount(TextShadowArray))
        {
          if (CFArrayGetCount(v9) < 1)
          {
            v11 = 0;
            v12 = 0;
            Color = 0;
            v14 = 0;
            v15 = 0;
            v16 = 0;
LABEL_35:
            v9 = 0;
            *v3 = v7;
            v7 = 0;
            if (v16)
LABEL_36:
              CFRelease(v16);
          }
          else
          {
            v33 = v3;
            theDict = v7;
            v10 = 0;
            v11 = 0;
            v12 = 0;
            Color = 0;
            v14 = 0;
            v15 = 0;
            v16 = 0;
            v35 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v36 = v9;
            while (1)
            {
              if (v11)
                CFRelease(v11);
              if (v16)
                CFRelease(v16);
              if (v15)
                CFRelease(v15);
              if (v14)
                CFRelease(v14);
              if (Color)
                CFRelease(Color);
              ValueAtIndex = CFArrayGetValueAtIndex(v9, v10);
              if (!ValueAtIndex
                || (v18 = (uint64_t)ValueAtIndex, v19 = CFGetTypeID(ValueAtIndex), v19 != FigCaptionTextShadowGetTypeID()))
              {
                v9 = (const __CFArray *)FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
                v7 = theDict;
                if (v12)
                  goto LABEL_46;
                goto LABEL_47;
              }
              theArray = v12;
              v20 = CFDictionaryCreateMutable(a2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              HorizontalAxisOffset = FigCaptionTextShadowGetHorizontalAxisOffset(v18);
              v23 = v22;
              VerticalAxisOffset = FigCaptionTextShadowGetVerticalAxisOffset(v18);
              v26 = v25;
              BlurRadius = FigCaptionTextShadowGetBlurRadius(v18);
              v29 = v28;
              Color = (void *)FigCaptionTextShadowGetColor(v18);
              v16 = FigGeometryDimensionCopyAsDictionary(HorizontalAxisOffset, v23, v35);
              v15 = FigGeometryDimensionCopyAsDictionary(VerticalAxisOffset, v26, v35);
              v30 = v29;
              v11 = v20;
              v14 = FigGeometryDimensionCopyAsDictionary(BlurRadius, v30, v35);
              if (v16)
                CFDictionarySetValue(v20, CFSTR("CMTextShadowHorizontalAxisOffset"), v16);
              if (v15)
                CFDictionarySetValue(v20, CFSTR("CMTextShadowVerticalAxisOffset"), v15);
              v12 = theArray;
              v9 = v36;
              if (v14)
                CFDictionarySetValue(v20, CFSTR("CMTextShadowBlurRadius"), v14);
              if (Color)
              {
                Color = FigTextMarkupCreateARGBColorArrayFromCGColor((CGColor *)Color);
                if (Color)
                  CFDictionarySetValue(v20, CFSTR("CMTextShadowColor"), Color);
              }
              if (!theArray)
              {
                v12 = CFArrayCreateMutable(a2, 0, MEMORY[0x1E0C9B378]);
                if (!v12)
                  break;
              }
              CFArrayAppendValue(v12, v20);
              if (++v10 >= CFArrayGetCount(v36))
              {
                v7 = theDict;
                CFDictionarySetValue(theDict, CFSTR("CMTextShadowList"), v12);
                v3 = v33;
                goto LABEL_35;
              }
            }
            v9 = (const __CFArray *)FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
            v7 = theDict;
            if (v16)
              goto LABEL_36;
          }
          if (v15)
            CFRelease(v15);
          if (v14)
            CFRelease(v14);
          if (Color)
            CFRelease(Color);
          if (v11)
            CFRelease(v11);
          if (v12)
LABEL_46:
            CFRelease(v12);
LABEL_47:
          if (!v7)
            return (uint64_t)v9;
        }
        else
        {
          v9 = 0;
        }
      }
      CFRelease(v7);
      return (uint64_t)v9;
    }
    v32 = 0xFFFFFFFFLL;
  }
  else
  {
    v32 = 4294950506;
  }
  return FigSignalErrorAt(v32, 0, 0, 0, 0, 0, 0);
}

BOOL FigTextMarkupMapGenericFontFamilyToMACaptionAppearanceFontStyle(const void *a1, _QWORD *a2)
{
  const __CFNumber *Value;
  const __CFNumber *v5;
  CFTypeID v6;
  _BOOL4 v7;
  uint64_t v8;
  int valuePtr;

  valuePtr = 0;
  FigThreadRunOnce(&gCreateGenericFontNameToMACaptionAppearanceFontStyleMappingDictOnce, figtextmarkup_setUpGenericFontNameToMACaptionAppearanceFontStyleMapping);
  if (!a1)
  {
    LODWORD(Value) = FigSignalErrorAt(4294967246, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)gGenericFontNameToMACaptionAppearanceFontStyleMappingDict, a1);
  if (!Value)
  {
LABEL_8:
    v8 = 0;
LABEL_9:
    v7 = 0;
    if (!a2)
      return !(_DWORD)Value && v7;
    goto LABEL_10;
  }
  v5 = Value;
  v6 = CFGetTypeID(Value);
  if (v6 != CFNumberGetTypeID())
  {
    v8 = 0;
    LODWORD(Value) = 0;
    goto LABEL_9;
  }
  CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr);
  LODWORD(Value) = 0;
  v7 = valuePtr >= 0;
  v8 = valuePtr & ~(valuePtr >> 31);
  if (a2)
LABEL_10:
    *a2 = v8;
  return !(_DWORD)Value && v7;
}

void figtextmarkup_setUpGenericFontNameToMACaptionAppearanceFontStyleMapping()
{
  uint64_t v0;
  _OWORD *v1;
  const __CFAllocator *v2;
  CFDictionaryRef v3;
  uint64_t v4;
  const void *v5;
  _OWORD v6[6];
  _OWORD valuePtr[3];
  void *keys[2];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v0 = 0;
  v14 = *MEMORY[0x1E0C80C00];
  v10 = xmmword_1E28E29A0;
  v11 = *(_OWORD *)&off_1E28E29B0;
  v12 = xmmword_1E28E29C0;
  v13 = *(_OWORD *)off_1E28E29D0;
  *(_OWORD *)keys = xmmword_1E28E2980;
  v9 = *(_OWORD *)&off_1E28E2990;
  valuePtr[0] = xmmword_18EDDE0BC;
  valuePtr[1] = unk_18EDDE0CC;
  valuePtr[2] = xmmword_18EDDE0DC;
  memset(v6, 0, sizeof(v6));
  v1 = valuePtr;
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  do
  {
    *(_QWORD *)((char *)v6 + v0) = CFNumberCreate(v2, kCFNumberSInt32Type, v1);
    v0 += 8;
    v1 = (_OWORD *)((char *)v1 + 4);
  }
  while (v0 != 96);
  v3 = CFDictionaryCreate(v2, (const void **)keys, (const void **)v6, 12, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v4 = 0;
  gGenericFontNameToMACaptionAppearanceFontStyleMappingDict = (uint64_t)v3;
  do
  {
    v5 = *(const void **)((char *)v6 + v4);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)((char *)v6 + v4) = 0;
    }
    v4 += 8;
  }
  while (v4 != 96);
}

uint64_t FigEndpointAggregateGetClassID()
{
  if (FigEndpointAggregateGetClassID_sRegisterFigEndpointAggregateBaseTypeOnce != -1)
    dispatch_once_f(&FigEndpointAggregateGetClassID_sRegisterFigEndpointAggregateBaseTypeOnce, &FigEndpointAggregateGetClassID_sFigEndpointAggregateClassID, (dispatch_function_t)FigEndpointAggregateGetClassIDCallback);
  return FigEndpointAggregateGetClassID_sFigEndpointAggregateClassID;
}

uint64_t FigEndpointAggregateGetClassIDCallback(_QWORD *a1)
{
  _QWORD *ClassID;

  ClassID = (_QWORD *)FigEndpointExtendedGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&FigEndpointAggregateGetClassIDCallback_sFigEndpointAggregateClassDesc, ClassID, 0, a1);
}

CFStringRef FigEndpointAggregateBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigEndpointAggregate %p]"), a1);
}

CFIndex FigPixelBufferOriginAppendPixelBufferToIPCMessageData(uint64_t a1, CVPixelBufferRef pixelBuffer, int a3, uint64_t a4, uint64_t a5, unint64_t a6, size_t *a7)
{
  uint64_t v11;
  IOSurfaceRef IOSurface;
  __IOSurface *v16;
  __CFString *v17;
  unint64_t v18;
  CFIndex appended;
  size_t v20;
  size_t v21;
  size_t v22;
  size_t v23;
  size_t v25;
  size_t extraRowsOnTop;
  __int128 extraColumnsOnRight;

  if (a5)
  {
    if (!pixelBuffer)
      goto LABEL_25;
    v11 = 4294951703;
    if (a6 >= 0x2C && a1)
    {
      IOSurface = CVPixelBufferGetIOSurface(pixelBuffer);
      if (IOSurface)
      {
        v16 = IOSurface;
        pixelBufferOrigin_registerPixelBuffer(a1, pixelBuffer);
        *(_QWORD *)a5 = *(_QWORD *)(a1 + 32);
        *(_DWORD *)(a5 + 8) = IOSurfaceGetID(v16);
        extraColumnsOnRight = 0uLL;
        v25 = 0;
        extraRowsOnTop = 0;
        CVPixelBufferGetExtendedPixels(pixelBuffer, (size_t *)&extraColumnsOnRight + 1, (size_t *)&extraColumnsOnRight, &extraRowsOnTop, &v25);
        *(_QWORD *)(a5 + 12) = *((_QWORD *)&extraColumnsOnRight + 1);
        *(_QWORD *)(a5 + 20) = extraColumnsOnRight;
        *(_QWORD *)(a5 + 28) = extraRowsOnTop;
        *(_QWORD *)(a5 + 36) = v25;
        extraColumnsOnRight = 0uLL;
        extraRowsOnTop = 0;
        pixelBufferSharing_copyPixelBufferAttachments(pixelBuffer, a3, (const __CFDictionary **)&extraColumnsOnRight + 1, (CFDictionaryRef *)&extraColumnsOnRight);
        v17 = (__CFString *)*((_QWORD *)&extraColumnsOnRight + 1);
        if (extraColumnsOnRight != 0)
        {
          v18 = a6 - 60;
          *(_QWORD *)(a5 + 44) = 0;
          appended = FigInMemorySerializerAppendCFDictionary(a5 + 60, a6 - 60, (uint64_t *)&extraRowsOnTop, v17, 0, a4, *(_QWORD *)(a1 + 40));
          v20 = extraRowsOnTop;
          if (!(_DWORD)appended)
          {
            *(_QWORD *)(a5 + 44) = extraRowsOnTop;
            *(_QWORD *)(a5 + 52) = 0;
            if (FigInMemorySerializerAppendCFDictionary(a5 + 60 + v20, v18 - v20, (uint64_t *)&extraRowsOnTop, (__CFString *)extraColumnsOnRight, 0, a4, *(_QWORD *)(a1 + 40)))
            {
              v21 = *(_QWORD *)(a5 + 52);
            }
            else
            {
              v21 = extraRowsOnTop;
              *(_QWORD *)(a5 + 52) = extraRowsOnTop;
            }
            v22 = *(_QWORD *)(a5 + 44) + v21;
            extraRowsOnTop = v22;
            if (v22)
            {
              v20 = v22 + 16;
              extraRowsOnTop = v22 + 16;
            }
            else
            {
              v20 = 0;
            }
          }
          if (*((_QWORD *)&extraColumnsOnRight + 1))
            CFRelease(*((CFTypeRef *)&extraColumnsOnRight + 1));
          if ((_QWORD)extraColumnsOnRight)
            CFRelease((CFTypeRef)extraColumnsOnRight);
          if ((_DWORD)appended)
          {
            pixelBufferOrigin_unregisterPixelBuffer(a1);
            return appended;
          }
          goto LABEL_26;
        }
LABEL_25:
        v20 = 0;
LABEL_26:
        if (!a7)
          return 0;
        goto LABEL_27;
      }
      v11 = 4294951700;
    }
LABEL_24:
    appended = FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
    if ((_DWORD)appended)
      return appended;
    goto LABEL_25;
  }
  if (!a7)
  {
    v11 = 4294951703;
    goto LABEL_24;
  }
  v20 = 0;
LABEL_27:
  appended = 0;
  v23 = v20 + 44;
  if (!pixelBuffer)
    v23 = 0;
  *a7 = v23;
  return appended;
}

uint64_t pixelBufferOrigin_registerPixelBuffer(uint64_t a1, __CVBuffer *a2)
{
  uint64_t BufferBacking;
  IOSurfaceRef IOSurface;
  _QWORD *v6;
  CFTypeRef v7;
  __CFNotificationCenter *LocalCenter;

  BufferBacking = CVPixelBufferGetBufferBacking();
  IOSurface = CVPixelBufferGetIOSurface(a2);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 24), (const void *)-BufferBacking))
  {
    v6 = malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
    v6[1] = FigCFWeakReferenceHolderCreateWithReferencedObject(BufferBacking);
    if (IOSurface)
      v7 = CFRetain(IOSurface);
    else
      v7 = 0;
    *v6 = v7;
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterAddObserver(LocalCenter, (const void *)a1, (CFNotificationCallback)pixelBufferOrigin_backingNotificationListener, (CFStringRef)*MEMORY[0x1E0CA8C50], (const void *)BufferBacking, (CFNotificationSuspensionBehavior)1028);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), (const void *)-BufferBacking, v6);
  }
  return FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
}

void pixelBufferOrigin_unregisterPixelBuffer(uint64_t a1)
{
  uint64_t BufferBacking;
  CFTypeRef *Value;
  __CFNotificationCenter *LocalCenter;

  BufferBacking = CVPixelBufferGetBufferBacking();
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  Value = (CFTypeRef *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), (const void *)-BufferBacking);
  if (Value)
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), (const void *)-BufferBacking);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterRemoveObserver(LocalCenter, (const void *)a1, (CFNotificationName)*MEMORY[0x1E0CA8C50], (const void *)BufferBacking);
  }
  else
  {
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  }
  pixelBufferOrigin_disposeBufferBackingEntry(Value);
}

void *FigPixelBufferOriginSetPixelBufferInXPCMessage(uint64_t a1, void *a2, const char *a3, CVPixelBufferRef pixelBuffer, int a5)
{
  __IOSurface *IOSurface;
  xpc_object_t v11;
  void *v12;
  xpc_object_t v13;
  __IOSurface *XPCObject;
  void *v15;
  void *v16;
  void *v17;
  int64_t value;
  size_t extraRowsOnTop;
  size_t extraColumnsOnRight;
  size_t extraColumnsOnLeft;

  if (!pixelBuffer)
  {
    v13 = 0;
    IOSurface = 0;
    v12 = 0;
    v17 = 0;
    goto LABEL_28;
  }
  if (!a1)
  {
    v17 = (void *)FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
    v13 = 0;
    IOSurface = 0;
LABEL_32:
    v12 = 0;
    goto LABEL_28;
  }
  IOSurface = CVPixelBufferGetIOSurface(pixelBuffer);
  if (!IOSurface)
  {
    v17 = (void *)FigSignalErrorAt(4294951700, 0, 0, 0, 0, 0, 0);
    v13 = 0;
    goto LABEL_32;
  }
  pixelBufferOrigin_registerPixelBuffer(a1, pixelBuffer);
  v11 = xpc_dictionary_create(0, 0, 0);
  v12 = v11;
  if (!v11)
  {
    v13 = 0;
    goto LABEL_34;
  }
  xpc_dictionary_set_uint64(v11, ".objectID", *(_QWORD *)(a1 + 32));
  v13 = xpc_dictionary_create(0, 0, 0);
  if (!v13 || (XPCObject = (__IOSurface *)IOSurfaceCreateXPCObject(IOSurface)) == 0)
  {
LABEL_34:
    v17 = (void *)FigSignalErrorAt(4294951705, 0, 0, 0, 0, 0, 0);
    IOSurface = 0;
    if (!(_DWORD)v17)
      goto LABEL_28;
LABEL_35:
    pixelBufferOrigin_unregisterPixelBuffer(a1);
    goto LABEL_28;
  }
  IOSurface = XPCObject;
  xpc_dictionary_set_value(v13, "IOSurface", XPCObject);
  extraColumnsOnRight = 0;
  extraColumnsOnLeft = 0;
  value = 0;
  extraRowsOnTop = 0;
  CVPixelBufferGetExtendedPixels(pixelBuffer, &extraColumnsOnLeft, &extraColumnsOnRight, &extraRowsOnTop, (size_t *)&value);
  if (extraColumnsOnLeft)
    xpc_dictionary_set_int64(v13, "ExtendedPixelsLeft", extraColumnsOnLeft);
  if (extraColumnsOnRight)
    xpc_dictionary_set_int64(v13, "ExtendedPixelsRight", extraColumnsOnRight);
  if (extraRowsOnTop)
    xpc_dictionary_set_int64(v13, "ExtendedPixelsTop", extraRowsOnTop);
  if (value)
    xpc_dictionary_set_int64(v13, "ExtendedPixelsBottom", value);
  extraColumnsOnRight = 0;
  extraColumnsOnLeft = 0;
  pixelBufferSharing_copyPixelBufferAttachments(pixelBuffer, a5, (const __CFDictionary **)&extraColumnsOnLeft, (CFDictionaryRef *)&extraColumnsOnRight);
  if ((uint64_t)FigCFDictionaryGetCount((CFDictionaryRef)extraColumnsOnLeft) >= 1)
  {
    v15 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    if (!v15)
    {
      v17 = (void *)FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
      goto LABEL_22;
    }
    v16 = v15;
    xpc_dictionary_set_value(v13, "PropagatedAttachments", v15);
    xpc_release(v16);
  }
  if ((uint64_t)FigCFDictionaryGetCount((CFDictionaryRef)extraColumnsOnRight) >= 1)
  {
    v17 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    if (!v17)
      goto LABEL_22;
    xpc_dictionary_set_value(v13, "NonPropagatedAttachments", v17);
    xpc_release(v17);
  }
  v17 = 0;
LABEL_22:
  if (extraColumnsOnLeft)
    CFRelease((CFTypeRef)extraColumnsOnLeft);
  if (extraColumnsOnRight)
    CFRelease((CFTypeRef)extraColumnsOnRight);
  if ((_DWORD)v17)
    goto LABEL_35;
  xpc_dictionary_set_value(v12, "PixelBufferComponents", v13);
  xpc_dictionary_set_value(a2, a3, v12);
LABEL_28:
  FigXPCRelease(IOSurface);
  FigXPCRelease(v12);
  FigXPCRelease(v13);
  return v17;
}

uint64_t FigPixelBufferOriginSetTaggedBufferGroupInXPCMessage(uint64_t a1, void *a2, const char *a3, uint64_t a4, int a5)
{
  xpc_object_t empty;
  uint64_t Count;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  xpc_object_t v12;
  uint64_t CVPixelBufferAtIndex;
  __CVBuffer *v14;
  uint64_t TagCollectionAtIndex;
  const void *v16;
  uint64_t v17;
  uint64_t v18;

  empty = xpc_array_create_empty();
  Count = FigTaggedBufferGroupGetCount(a4);
  if (Count < 1)
  {
LABEL_11:
    xpc_dictionary_set_value(a2, a3, empty);
    v18 = 0;
    v16 = 0;
    v12 = 0;
  }
  else
  {
    v9 = Count;
    v10 = 0;
    v11 = *MEMORY[0x1E0C9AE00];
    while (1)
    {
      v12 = xpc_dictionary_create(0, 0, 0);
      CVPixelBufferAtIndex = FigTaggedBufferGroupGetCVPixelBufferAtIndex(a4, v10);
      if (!CVPixelBufferAtIndex)
        break;
      v14 = (__CVBuffer *)CVPixelBufferAtIndex;
      TagCollectionAtIndex = FigTaggedBufferGroupGetTagCollectionAtIndex(a4, v10);
      v16 = (const void *)FigTagCollectionCopyAsData(TagCollectionAtIndex, v11);
      v17 = FigXPCMessageSetCFData(v12, "EntryTagCollection", v16);
      if ((_DWORD)v17
        || (v17 = (uint64_t)FigPixelBufferOriginSetPixelBufferInXPCMessage(a1, v12, "EntryPixelBuffer", v14, a5),
            (_DWORD)v17))
      {
        v18 = v17;
        goto LABEL_12;
      }
      xpc_array_append_value(empty, v12);
      if (v12)
        xpc_release(v12);
      if (v16)
        CFRelease(v16);
      if (v9 == ++v10)
        goto LABEL_11;
    }
    v18 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
    v16 = 0;
  }
LABEL_12:
  FigXPCRelease(empty);
  FigXPCRelease(v12);
  if (v16)
    CFRelease(v16);
  return v18;
}

uint64_t FigPixelBufferOriginBeginEstablishingPixelBufferRecipientByFillingInXPCMessage1(void *a1)
{
  uint64_t v2;
  xpc_object_t v3;
  xpc_object_t value;

  value = 0;
  if (EnsurePixelBufferOriginServerStarted_sPixelBufferOriginServerStartOnce != -1)
    dispatch_once(&EnsurePixelBufferOriginServerStarted_sPixelBufferOriginServerStartOnce, &__block_literal_global_40);
  v2 = EnsurePixelBufferOriginServerStarted_sPixelBufferOriginServerStartError;
  if (EnsurePixelBufferOriginServerStarted_sPixelBufferOriginServerStartError)
  {
    v3 = 0;
  }
  else
  {
    v2 = FigXPCServerCopyXPCEndpoint(gPixelBufferOriginServer, &value);
    v3 = value;
    if (!(_DWORD)v2)
    {
      xpc_dictionary_set_value(a1, "PixelBufferOriginEndpoint", value);
      v3 = value;
    }
  }
  FigXPCRelease(v3);
  return v2;
}

uint64_t FigPixelBufferOriginCompleteEstablishingPixelBufferRecipientUsingXPCMessage2(void *a1, _QWORD *a2)
{
  void *uint64;

  uint64 = (void *)xpc_dictionary_get_uint64(a1, ".objectID");
  return FigXPCServerRetainNeighborObjectFromID((uint64_t *)gPixelBufferOriginServer, uint64, a2);
}

uint64_t FigPixelBufferOriginGetObjectID(uint64_t a1, _QWORD *a2)
{
  if (!a1 || !a2)
    return FigSignalErrorAt(4294951706, 0, 0, 0, 0, 0, 0);
  *a2 = *(_QWORD *)(a1 + 32);
  return 0;
}

uint64_t FigPixelBufferOriginServerCopyPixelBufferOriginForObjectID(void *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;

  v5 = 0;
  if (a2)
  {
    *a2 = 0;
    if (a1)
    {
      if (gPixelBufferOriginServer)
      {
        result = FigXPCServerRetainNeighborObjectFromID((uint64_t *)gPixelBufferOriginServer, a1, &v5);
        *a2 = v5;
        return result;
      }
      v4 = 4294951704;
    }
    else
    {
      v4 = 4294951706;
    }
  }
  else
  {
    v4 = 4294951706;
  }
  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t FigPixelBufferRecipientCopyPixelBufferFromXPCMessage(uint64_t a1, xpc_object_t xdict, char *key, __CVBuffer **a4)
{
  xpc_object_t value;
  void *v7;
  xpc_object_t v8;
  xpc_object_t v9;
  __IOSurface *v10;
  IOSurfaceID ID;
  uint64_t v12;
  __CVBuffer *v13;
  uint64_t v14;
  uint64_t v15;
  CFTypeRef cf;
  CFDictionaryRef theAttachments;

  cf = 0;
  if (!a4)
    return FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
  if (!a1)
    goto LABEL_22;
  value = xpc_dictionary_get_value(xdict, key);
  if (!value)
  {
    v15 = 0;
    goto LABEL_19;
  }
  v7 = value;
  v8 = xpc_dictionary_get_value(value, "PixelBufferComponents");
  if (xpc_dictionary_get_uint64(v7, ".objectID") != *(_QWORD *)(a1 + 16)
    || (v9 = xpc_dictionary_get_value(v8, "IOSurface")) == 0)
  {
LABEL_22:
    v15 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  v10 = IOSurfaceLookupFromXPCObject(v9);
  ID = IOSurfaceGetID(v10);
  v12 = pixelBufferRecipient_createRecipientPixelBuffer(a1, ID, (uint64_t (*)(uint64_t, uint64_t, CFTypeRef *))pixelBufferRecipient_copyCVPixelBufferFromXPCComponents, (uint64_t)v8, &cf);
  if ((_DWORD)v12
    || (v13 = (__CVBuffer *)cf,
        theAttachments = 0,
        v12 = FigXPCMessageCopyCFDictionary(v8, "PropagatedAttachments", &theAttachments),
        (_DWORD)v12))
  {
    v15 = v12;
    if (!v10)
      goto LABEL_19;
    goto LABEL_18;
  }
  if (theAttachments)
  {
    CVBufferSetAttachments(v13, theAttachments, kCVAttachmentMode_ShouldPropagate);
    if (theAttachments)
    {
      CFRelease(theAttachments);
      theAttachments = 0;
    }
  }
  v14 = FigXPCMessageCopyCFDictionary(v8, "NonPropagatedAttachments", &theAttachments);
  v15 = v14;
  if ((_DWORD)v14 || !theAttachments)
  {
    if ((_DWORD)v14)
      goto LABEL_17;
  }
  else
  {
    CVBufferSetAttachments(v13, theAttachments, kCVAttachmentMode_ShouldNotPropagate);
    if (theAttachments)
      CFRelease(theAttachments);
  }
  v15 = 0;
  *a4 = v13;
  cf = 0;
LABEL_17:
  if (v10)
LABEL_18:
    CFRelease(v10);
LABEL_19:
  if (cf)
    CFRelease(cf);
  return v15;
}

uint64_t pixelBufferRecipient_createRecipientPixelBuffer(uint64_t a1, unsigned int a2, uint64_t (*a3)(uint64_t, uint64_t, CFTypeRef *), uint64_t a4, CFTypeRef *a5)
{
  unint64_t v9;
  uint64_t v10;
  const void *BufferBacking;
  uint64_t v12;
  CFTypeRef cf;

  cf = 0;
  v9 = a2;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
  if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), (const void *)v9))
  {
    v10 = CVPixelBufferCreateWithBufferBacking();
    if ((_DWORD)v10)
      goto LABEL_12;
LABEL_7:
    v12 = 0;
    *a5 = cf;
    cf = 0;
    goto LABEL_8;
  }
  v10 = a3(a1, a4, &cf);
  if (!(_DWORD)v10)
  {
    BufferBacking = (const void *)CVPixelBufferGetBufferBacking();
    if (BufferBacking)
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), (const void *)v9, BufferBacking);
      goto LABEL_7;
    }
    v10 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
  }
LABEL_12:
  v12 = v10;
LABEL_8:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
  if (cf)
    CFRelease(cf);
  return v12;
}

uint64_t pixelBufferRecipient_copyCVPixelBufferFromXPCComponents(uint64_t a1, void *a2, CVPixelBufferRef *a3)
{
  const __CFAllocator *v5;
  CFMutableDictionaryRef Mutable;
  int64_t int64;
  int64_t v8;
  int64_t v9;
  int64_t v10;
  xpc_object_t value;
  __IOSurface *v12;
  uint64_t v13;
  CVPixelBufferRef pixelBufferOut;

  pixelBufferOut = 0;
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
  int64 = xpc_dictionary_get_int64(a2, "ExtendedPixelsLeft");
  if (int64)
    FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E0CA8FB0], int64);
  v8 = xpc_dictionary_get_int64(a2, "ExtendedPixelsRight");
  if (v8)
    FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E0CA8FB8], v8);
  v9 = xpc_dictionary_get_int64(a2, "ExtendedPixelsTop");
  if (v9)
    FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E0CA8FC0], v9);
  v10 = xpc_dictionary_get_int64(a2, "ExtendedPixelsBottom");
  if (v10)
    FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E0CA8FA0], v10);
  value = xpc_dictionary_get_value(a2, "IOSurface");
  if (value)
  {
    v12 = IOSurfaceLookupFromXPCObject(value);
    if (v12)
    {
      v13 = CVPixelBufferCreateWithIOSurface(v5, v12, Mutable, &pixelBufferOut);
      if (!(_DWORD)v13)
      {
        *a3 = pixelBufferOut;
        pixelBufferOut = 0;
      }
    }
    else
    {
      v13 = FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    v13 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
    v12 = 0;
  }
  if (Mutable)
    CFRelease(Mutable);
  if (pixelBufferOut)
    CFRelease(pixelBufferOut);
  if (v12)
    CFRelease(v12);
  return v13;
}

uint64_t FigPixelBufferRecipientCopyPixelBufferFromIPCMessageData(uint64_t a1, uint64_t a2, uint64_t a3, __CVBuffer **a4)
{
  uint64_t v8;
  __CVBuffer *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  const __CFAllocator *v13;
  uint64_t v14;
  CFDictionaryRef v15;
  CFTypeRef v17;
  CFTypeRef cf;
  CFDictionaryRef theAttachments;

  v17 = 0;
  if (!a4 || !a1 || *(_QWORD *)a2 != *(_QWORD *)(a1 + 16))
    return FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
  v8 = pixelBufferRecipient_createRecipientPixelBuffer(a1, *(_DWORD *)(a2 + 8), (uint64_t (*)(uint64_t, uint64_t, CFTypeRef *))pixelBufferRecipient_copyCVPixelBufferFromSerializedPixelBufferDescription, a2, &v17);
  v9 = (__CVBuffer *)v17;
  if ((_DWORD)v8)
    goto LABEL_31;
  cf = 0;
  theAttachments = 0;
  if (a3 == 44 || !v17)
    goto LABEL_26;
  if ((unint64_t)(a3 - 44) <= 0xF
    || (v10 = *(_QWORD *)(a2 + 44), v11 = *(_QWORD *)(a2 + 52), v11 >= ~v10)
    || v11 + v10 > a3 - 60)
  {
    v12 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
    goto LABEL_21;
  }
  v12 = FigXPCRemoteClientCopyMemoryRecipient(*(_QWORD *)(a1 + 40), &cf);
  if ((_DWORD)v12)
  {
LABEL_21:
    v8 = v12;
    goto LABEL_26;
  }
  v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v14 = FigInMemoryDeserializerCopyCFDictionary((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2 + 60, *(_QWORD *)(a2 + 44), (uint64_t)cf, &theAttachments);
  v15 = theAttachments;
  if ((_DWORD)v14)
  {
    v8 = v14;
  }
  else
  {
    if (theAttachments)
    {
      CVBufferSetAttachments(v9, theAttachments, kCVAttachmentMode_ShouldPropagate);
      if (theAttachments)
      {
        CFRelease(theAttachments);
        theAttachments = 0;
      }
    }
    v8 = FigInMemoryDeserializerCopyCFDictionary(v13, a2 + 60 + *(_QWORD *)(a2 + 44), *(_QWORD *)(a2 + 52), (uint64_t)cf, &theAttachments);
    v15 = theAttachments;
    if (!(_DWORD)v8 && theAttachments)
    {
      CVBufferSetAttachments(v9, theAttachments, kCVAttachmentMode_ShouldNotPropagate);
      if (theAttachments)
      {
        CFRelease(theAttachments);
        v8 = 0;
        theAttachments = 0;
      }
      else
      {
        v8 = 0;
      }
      goto LABEL_26;
    }
  }
  if (v15)
    CFRelease(v15);
LABEL_26:
  if (cf)
    CFRelease(cf);
  if ((_DWORD)v8)
  {
LABEL_31:
    if (v9)
      CFRelease(v9);
    return v8;
  }
  *a4 = v9;
  return v8;
}

uint64_t pixelBufferRecipient_copyCVPixelBufferFromSerializedPixelBufferDescription(uint64_t a1, uint64_t a2, CVPixelBufferRef *a3)
{
  const __CFAllocator *v6;
  CFMutableDictionaryRef Mutable;
  uint64_t v8;
  xpc_object_t value;
  __IOSurface *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  xpc_object_t v17;
  xpc_object_t xdict;
  CVPixelBufferRef pixelBufferOut;

  xdict = 0;
  pixelBufferOut = 0;
  v17 = 0;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
  v8 = FigXPCCreateBasicMessage(0x696D7073u, 0, &xdict);
  if ((_DWORD)v8)
    goto LABEL_23;
  xpc_dictionary_set_int64(xdict, "IOSurfaceID", *(unsigned int *)(a2 + 8));
  v8 = FigXPCRemoteClientSendSyncMessageCreatingReply(*(_QWORD *)(a1 + 40), (uint64_t)xdict, &v17);
  if ((_DWORD)v8)
    goto LABEL_23;
  value = xpc_dictionary_get_value(v17, "IOSurface");
  if (!value)
  {
    v8 = FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
LABEL_23:
    v15 = v8;
    v10 = 0;
    goto LABEL_15;
  }
  v10 = IOSurfaceLookupFromXPCObject(value);
  if (v10)
  {
    v11 = *(_QWORD *)(a2 + 12);
    if (v11)
      FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E0CA8FB0], v11);
    v12 = *(_QWORD *)(a2 + 20);
    if (v12)
      FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E0CA8FB8], v12);
    v13 = *(_QWORD *)(a2 + 28);
    if (v13)
      FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E0CA8FC0], v13);
    v14 = *(_QWORD *)(a2 + 36);
    if (v14)
      FigCFDictionarySetInt64(Mutable, (const void *)*MEMORY[0x1E0CA8FA0], v14);
    v15 = CVPixelBufferCreateWithIOSurface(v6, v10, Mutable, &pixelBufferOut);
    if (!(_DWORD)v15)
    {
      *a3 = pixelBufferOut;
      pixelBufferOut = 0;
    }
  }
  else
  {
    v15 = FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
  }
LABEL_15:
  if (Mutable)
    CFRelease(Mutable);
  if (pixelBufferOut)
    CFRelease(pixelBufferOut);
  if (v10)
    CFRelease(v10);
  FigXPCRelease(xdict);
  FigXPCRelease(v17);
  return v15;
}

uint64_t FigPixelBufferRecipientCopyTaggedBufferGroupFromXPCMessage(uint64_t a1, xpc_object_t xdict, char *key, __CFArray *a4)
{
  __CFArray *Mutable;
  xpc_object_t v6;
  void *v7;
  int64_t count;
  const __CFAllocator *v9;
  const CFArrayCallBacks *v10;
  __CFArray *v11;
  size_t v12;
  xpc_object_t dictionary;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v18;
  CFTypeRef v19;
  CFTypeRef v20;
  void *value;
  CFTypeRef cf;

  Mutable = a4;
  value = 0;
  cf = 0;
  v19 = 0;
  v20 = 0;
  if (!a4)
  {
    v16 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
LABEL_38:
    v11 = 0;
    goto LABEL_19;
  }
  *(_QWORD *)a4 = 0;
  if (!a1)
  {
    v16 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
LABEL_37:
    Mutable = 0;
    goto LABEL_38;
  }
  v6 = xpc_dictionary_get_value(xdict, key);
  if (!v6)
  {
    v16 = 0;
    goto LABEL_37;
  }
  v7 = v6;
  v18 = Mutable;
  count = xpc_array_get_count(v6);
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v10 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], count, MEMORY[0x1E0C9B378]);
  v11 = CFArrayCreateMutable(v9, count, v10);
  if (count < 1)
  {
LABEL_17:
    v16 = FigTaggedBufferGroupCreate(v9, Mutable, v11, &v19);
    if (!(_DWORD)v16)
    {
      *v18 = v19;
      v19 = 0;
    }
  }
  else
  {
    v12 = 0;
    while (1)
    {
      dictionary = xpc_array_get_dictionary(v7, v12);
      if (!dictionary)
        break;
      v14 = dictionary;
      v15 = FigXPCMessageCopyCFData(dictionary, "EntryTagCollection", &cf);
      if ((_DWORD)v15)
        goto LABEL_33;
      v15 = FigTagCollectionCreateFromData(cf, v9, &value);
      if ((_DWORD)v15)
        goto LABEL_33;
      v15 = FigPixelBufferRecipientCopyPixelBufferFromXPCMessage(a1, v14, "EntryPixelBuffer", (__CVBuffer **)&v20);
      if ((_DWORD)v15)
        goto LABEL_33;
      CFArrayAppendValue(Mutable, value);
      CFArrayAppendValue(v11, v20);
      if (cf)
      {
        CFRelease(cf);
        cf = 0;
      }
      if (value)
      {
        CFRelease(value);
        value = 0;
      }
      if (v20)
      {
        CFRelease(v20);
        v20 = 0;
      }
      if (count == ++v12)
        goto LABEL_17;
    }
    v15 = FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
LABEL_33:
    v16 = v15;
  }
LABEL_19:
  if (cf)
    CFRelease(cf);
  if (value)
    CFRelease(value);
  if (v20)
    CFRelease(v20);
  if (Mutable)
    CFRelease(Mutable);
  if (v11)
    CFRelease(v11);
  if (v19)
    CFRelease(v19);
  return v16;
}

uint64_t FigPixelBufferRecipientFlushPixelBufferBackings(uint64_t a1)
{
  if (!a1 || !*(_QWORD *)(a1 + 32))
    return FigSignalErrorAt(4294951703, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
  FigCFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 32));
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
  return 0;
}

uint64_t FigPixelBufferRecipientCreateWithXPCMessage1AndUpdateXPCMessage2(void *a1, void *a2, uint64_t **a3)
{
  xpc_object_t value;
  uint64_t v6;
  const __CFAllocator *v7;
  __CFDictionary *Mutable;
  uint64_t v9;
  CFTypeRef v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *Instance;
  const void *uint64;
  CFTypeRef cf;
  CFTypeRef v17;
  xpc_object_t xdict;
  xpc_object_t v19;

  cf = 0;
  v17 = 0;
  value = xpc_dictionary_get_value(a1, "PixelBufferOriginEndpoint");
  if (!value || (v6 = (uint64_t)value, MEMORY[0x193FFCDCC]() != MEMORY[0x1E0C81308]))
  {
    v9 = FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
    v10 = 0;
    goto LABEL_16;
  }
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, CFSTR("xpcRemoteClientOption_DeathNoticeName"), CFSTR("ServerConnectionDied"));
  if (!FigXPCRemoteClientCreateWithXPCEndpoint((uint64_t)"FigPixelBufferOriginRemote", v6, (uint64_t)&PixelBufferRecipientRemoteClientCreateWithXPCEndpoint_sPixelBufferRecipientRemoteClientCallbacks, (uint64_t)Mutable, (uint64_t)&v17))
  {
    v9 = 0;
    if (!Mutable)
      goto LABEL_6;
    goto LABEL_5;
  }
  v9 = FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
  if (Mutable)
LABEL_5:
    CFRelease(Mutable);
LABEL_6:
  v10 = v17;
  if ((_DWORD)v9)
  {
LABEL_16:
    FigXPCRemoteClientDispose(v10);
    goto LABEL_17;
  }
  v11 = FigXPCRemoteClientCopyMemoryRecipient((uint64_t)v17, &cf);
  v10 = v17;
  if ((_DWORD)v11)
  {
    v9 = v11;
    goto LABEL_16;
  }
  xdict = 0;
  v19 = 0;
  v12 = FigXPCCreateBasicMessage(0x63726538u, 0, &v19);
  if ((_DWORD)v12
    || (v12 = FigXPCRemoteClientSendSyncMessageCreatingReply((uint64_t)v10, (uint64_t)v19, &xdict), (_DWORD)v12))
  {
    v9 = v12;
  }
  else
  {
    if (pixelBufferRecipient_GetTypeID_sRegisterPixelBufferRecipientTypeOnce != -1)
      dispatch_once(&pixelBufferRecipient_GetTypeID_sRegisterPixelBufferRecipientTypeOnce, &__block_literal_global_34_0);
    Instance = (uint64_t *)_CFRuntimeCreateInstance();
    if (!Instance)
    {
      v9 = FigSignalErrorAt(4294951702, 0, 0, 0, 0, 0, 0);
      goto LABEL_14;
    }
    Instance[3] = (uint64_t)FigSimpleMutexCreate();
    Instance[4] = (uint64_t)CFDictionaryCreateMutable(v7, 0, 0, MEMORY[0x1E0C9B3A0]);
    uint64 = (const void *)xpc_dictionary_get_uint64(xdict, ".objectID");
    Instance[2] = (uint64_t)uint64;
    Instance[5] = (uint64_t)v10;
    v9 = FigXPCRemoteClientAssociateObject((uint64_t)v10, (uint64_t)Instance, uint64);
    if (!(_DWORD)v9)
      goto LABEL_14;
    CFRelease(Instance);
  }
  Instance = 0;
LABEL_14:
  FigXPCRelease(v19);
  FigXPCRelease(xdict);
  if (!(_DWORD)v9)
  {
    v17 = 0;
    xpc_dictionary_set_uint64(a2, ".objectID", Instance[2]);
    *a3 = Instance;
    v10 = v17;
    goto LABEL_16;
  }
  FigXPCRemoteClientDispose(v17);
  if (Instance)
    CFRelease(Instance);
LABEL_17:
  if (cf)
    CFRelease(cf);
  return v9;
}

uint64_t pixelBufferOrigin_backingNotificationListener(int a1, uint64_t a2, CFTypeRef cf1, uint64_t a4)
{
  const __CFString *v6;
  uint64_t result;
  IOSurfaceRef *Value;
  uint64_t v9;
  IOSurfaceID ID;
  CFMutableDictionaryRef Mutable;
  __CFNotificationCenter *LocalCenter;
  __CFNotificationCenter *DefaultLocalCenter;

  v6 = (const __CFString *)*MEMORY[0x1E0CA8C50];
  result = CFEqual(cf1, (CFTypeRef)*MEMORY[0x1E0CA8C50]);
  if ((_DWORD)result)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a2 + 16));
    Value = (IOSurfaceRef *)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 24), (const void *)-a4);
    if (Value)
    {
      v9 = (uint64_t)Value;
      ID = IOSurfaceGetID(*Value);
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      FigCFDictionarySetInt64(Mutable, CFSTR("IOSurfaceID"), ID);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a2 + 24), (const void *)-a4);
      LocalCenter = CFNotificationCenterGetLocalCenter();
      CFNotificationCenterRemoveObserver(LocalCenter, (const void *)a2, v6, (const void *)a4);
      DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("ForgetBacking"), (const void *)a2, Mutable);
      if (Mutable)
        CFRelease(Mutable);
      pixelBufferOrigin_disposeOriginEntry((const void *)a2, v9);
    }
    return FigSimpleMutexUnlock(*(pthread_mutex_t **)(a2 + 16));
  }
  return result;
}

void pixelBufferOrigin_disposeBufferBackingEntry(CFTypeRef *a1)
{
  CFTypeRef v2;

  if (a1)
  {
    v2 = a1[1];
    if (v2)
      CFRelease(v2);
    if (*a1)
      CFRelease(*a1);
    free(a1);
  }
}

void pixelBufferOrigin_disposeOriginEntry(const void *a1, uint64_t a2)
{
  id *v4;
  id *v5;
  __CFNotificationCenter *LocalCenter;

  if (a2)
  {
    v4 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a2 + 8));
    if (v4)
    {
      v5 = v4;
      LocalCenter = CFNotificationCenterGetLocalCenter();
      CFNotificationCenterRemoveObserver(LocalCenter, a1, (CFNotificationName)*MEMORY[0x1E0CA8C50], v5);
      CFRelease(v5);
    }
    pixelBufferOrigin_disposeBufferBackingEntry((CFTypeRef *)a2);
  }
}

void pixelBufferSharing_copyPixelBufferAttachments(CVBufferRef buffer, int a2, const __CFDictionary **a3, CFDictionaryRef *a4)
{
  CFDictionaryRef *v4;
  const __CFDictionary **v5;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const void *v9;
  __CFDictionary *MutableCopy;
  CFDictionaryRef v11;
  uint64_t v12;
  const __CFAllocator *v13;
  const CFDictionaryKeyCallBacks *v14;
  const CFDictionaryValueCallBacks *v15;
  const __CFString *v16;
  CFTypeRef v17;
  const void *v18;
  CFMutableDictionaryRef Mutable;
  CVAttachmentMode attachmentMode;

  v4 = a4;
  v5 = a3;
  if (a2)
  {
    v7 = CVBufferCopyAttachments(buffer, kCVAttachmentMode_ShouldPropagate);
    v8 = v7;
    if (v7)
    {
      v9 = (const void *)*MEMORY[0x1E0CA8CD8];
      if (CFDictionaryGetValue(v7, (const void *)*MEMORY[0x1E0CA8CD8]))
      {
        MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v8);
        CFDictionaryRemoveValue(MutableCopy, v9);
        CFRelease(v8);
        v8 = MutableCopy;
      }
    }
    v11 = CVBufferCopyAttachments(buffer, kCVAttachmentMode_ShouldNotPropagate);
    if (!v5)
      goto LABEL_7;
LABEL_6:
    *v5 = v8;
    v8 = 0;
    goto LABEL_7;
  }
  v12 = 0;
  v11 = 0;
  v8 = 0;
  attachmentMode = kCVAttachmentMode_ShouldNotPropagate;
  v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v14 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v15 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  while (1)
  {
    v16 = gCVPixelBufferAttachmentKeysToAlwaysSerialize[v12];
    v17 = CVBufferCopyAttachment(buffer, v16, &attachmentMode);
    if (v17)
      break;
LABEL_26:
    if (++v12 == 4)
      goto LABEL_27;
  }
  v18 = v17;
  if (attachmentMode == kCVAttachmentMode_ShouldPropagate)
  {
    if (v8)
    {
      Mutable = v8;
    }
    else
    {
      Mutable = CFDictionaryCreateMutable(v13, 0, v14, v15);
      if (!Mutable)
      {
        FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
        v8 = v11;
        if (!v11)
          goto LABEL_33;
        goto LABEL_32;
      }
      v8 = Mutable;
    }
    goto LABEL_25;
  }
  if (v11)
  {
    Mutable = v11;
LABEL_25:
    FigCFDictionarySetValue(Mutable, v16, v18);
    CFRelease(v18);
    goto LABEL_26;
  }
  Mutable = CFDictionaryCreateMutable(v13, 0, v14, v15);
  if (Mutable)
  {
    v11 = Mutable;
    goto LABEL_25;
  }
  FigSignalErrorAt(4294951701, 0, 0, 0, 0, 0, 0);
  if (!v8)
    goto LABEL_33;
LABEL_32:
  CFRelease(v8);
LABEL_33:
  CFRelease(v18);
  v8 = 0;
  v11 = 0;
LABEL_27:
  v5 = a3;
  v4 = a4;
  if (a3)
    goto LABEL_6;
LABEL_7:
  if (v4)
  {
    *v4 = v11;
    v11 = 0;
  }
  if (v8)
    CFRelease(v8);
  if (v11)
    CFRelease(v11);
}

uint64_t pixelBufferOriginServer_handleRemoteMessageWithReply(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t OpCode;
  const __CFAllocator *v7;
  uint64_t Instance;
  uint64_t v9;
  pthread_mutex_t *v10;
  uint64_t v11;
  uint64_t v12;
  IOSurfaceID int64;
  __IOSurface *v14;
  __IOSurface *v15;
  xpc_object_t XPCObject;
  int v18;
  uint64_t value;

  v18 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v18);
  if ((_DWORD)OpCode)
    return OpCode;
  if (v18 != 1768779891)
  {
    if (v18 == 1668441400)
    {
      value = 0;
      v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (pixelBufferOrigin_GetTypeID_sRegisterPixelBufferOriginTypeOnce != -1)
        dispatch_once(&pixelBufferOrigin_GetTypeID_sRegisterPixelBufferOriginTypeOnce, &__block_literal_global_27_0);
      Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        v9 = Instance;
        v10 = FigSimpleMutexCreate();
        *(_QWORD *)(v9 + 16) = v10;
        if (v10)
        {
          *(_QWORD *)(v9 + 24) = CFDictionaryCreateMutable(v7, 0, 0, 0);
          goto LABEL_9;
        }
        v12 = FigSignalErrorAt(4294951705, 0, 0, 0, 0, 0, 0);
        CFRelease((CFTypeRef)v9);
      }
      else
      {
        v12 = FigSignalErrorAt(4294951705, 0, 0, 0, 0, 0, 0);
      }
      if ((_DWORD)v12)
        return v12;
      v9 = 0;
LABEL_9:
      v11 = FigXPCServerAssociateObjectWithConnection(a1, (const void *)v9, 0, 0, 0, &value);
      if ((_DWORD)v11)
      {
        v12 = v11;
      }
      else
      {
        v12 = FigXPCServerCopyMemoryOrigin(a1, (CFTypeRef *)(v9 + 40));
        if (!(_DWORD)v12)
        {
          xpc_dictionary_set_uint64(a3, ".objectID", value);
          *(_QWORD *)(v9 + 32) = value;
LABEL_12:
          CFRelease((CFTypeRef)v9);
          return v12;
        }
      }
      if (!v9)
        return v12;
      goto LABEL_12;
    }
    return FigSignalErrorAt(4294951138, 0, 0, 0, 0, 0, 0);
  }
  int64 = xpc_dictionary_get_int64(a2, "IOSurfaceID");
  v14 = IOSurfaceLookup(int64);
  if (v14)
  {
    v15 = v14;
    XPCObject = IOSurfaceCreateXPCObject(v14);
    if (XPCObject)
    {
      xpc_dictionary_set_value(a3, "IOSurface", XPCObject);
      v12 = 0;
    }
    else
    {
      v12 = FigSignalErrorAt(4294951704, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v15);
  }
  else
  {
    v12 = FigSignalErrorAt(4294951706, 0, 0, 0, 0, 0, 0);
    XPCObject = 0;
  }
  FigXPCRelease(XPCObject);
  return v12;
}

uint64_t pixelBufferOriginServer_handleRemoteMessageNoReply(uint64_t a1, void *a2)
{
  uint64_t result;
  int v3;

  v3 = 0;
  result = FigXPCMessageGetOpCode(a2, &v3);
  if (!(_DWORD)result)
    return FigSignalErrorAt(4294951138, 0, 0, 0, 0, 0, 0);
  return result;
}

double pixelBufferOrigin_Init(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void pixelBufferOrigin_Finalize(uint64_t a1)
{
  const void *v2;
  const void *v3;

  if (*(_QWORD *)(a1 + 24))
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 24), (CFDictionaryApplierFunction)pixelBufferOrigin_disposeEachOriginEntry, (void *)a1);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    v2 = *(const void **)(a1 + 24);
    if (v2)
    {
      CFRelease(v2);
      *(_QWORD *)(a1 + 24) = 0;
    }
  }
  FigSimpleMutexDestroy(*(_QWORD *)(a1 + 16));
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
}

__CFString *pixelBufferOrigin_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("FigPixelBufferOrigin %p ObjectID %016llx"), a1, *(_QWORD *)(a1 + 32));
  return Mutable;
}

void pixelBufferOrigin_disposeEachOriginEntry(uint64_t a1, uint64_t a2, const void *a3)
{
  pixelBufferOrigin_disposeOriginEntry(a3, a2);
}

uint64_t pixelBufferRecipient_NotificationFilter(uint64_t a1, CFTypeRef cf1, uint64_t a3, uint64_t a4)
{
  const void *v6;
  const void *v8;

  if (CFEqual(cf1, CFSTR("ForgetBacking")))
  {
    v8 = 0;
    if (FigCFDictionaryGetInt64IfPresent(a4, CFSTR("IOSurfaceID"), &v8))
    {
      v6 = v8;
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
      if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v6))
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), v6);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    }
  }
  return 1;
}

double pixelBufferRecipient_Init(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void pixelBufferRecipient_Finalize(uint64_t a1)
{
  pthread_mutex_t *v2;
  const void *v3;

  v2 = *(pthread_mutex_t **)(a1 + 24);
  if (v2)
  {
    FigSimpleMutexLock(v2);
    v3 = *(const void **)(a1 + 32);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 32) = 0;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
    FigSimpleMutexDestroy(*(_QWORD *)(a1 + 24));
    *(_QWORD *)(a1 + 24) = 0;
  }
  FigXPCRemoteClientDispose(*(CFTypeRef *)(a1 + 40));
}

__CFString *pixelBufferRecipient_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  CFIndex Count;

  Mutable = CFStringCreateMutable(0, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 24));
  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 32));
  CFStringAppendFormat(Mutable, 0, CFSTR("FigPixelBufferRecipient %p ObjectID %016llx %ld memory blocks"), a1, *(_QWORD *)(a1 + 16), Count);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 24));
  return Mutable;
}

uint64_t FigGeometryMarginsMake@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, _QWORD *a9@<X8>)
{
  *a9 = result;
  a9[1] = a2;
  a9[2] = a3;
  a9[3] = a4;
  a9[4] = a5;
  a9[5] = a6;
  a9[6] = a7;
  a9[7] = a8;
  return result;
}

BOOL FigGeometryMarginsEqualToMargins(uint64_t *a1, uint64_t *a2)
{
  _BOOL8 result;

  result = FigGeometryDimensionEqualToDimension(*a1, a1[1], *a2, a2[1]);
  if (result)
  {
    result = FigGeometryDimensionEqualToDimension(a1[2], a1[3], a2[2], a2[3]);
    if (result)
    {
      result = FigGeometryDimensionEqualToDimension(a1[4], a1[5], a2[4], a2[5]);
      if (result)
        return FigGeometryDimensionEqualToDimension(a1[6], a1[7], a2[6], a2[7]);
    }
  }
  return result;
}

unint64_t FigGeometryAspectRatioMake(unsigned int a1, uint64_t a2)
{
  BOOL v2;

  if ((_DWORD)a2)
    v2 = a1 == 0;
  else
    v2 = 1;
  if (v2)
    return 0;
  else
    return a1 | (unint64_t)(a2 << 32);
}

BOOL FigGeometryAspectRatioIsValid(uint64_t a1)
{
  return (int)a1 > 0 && SHIDWORD(a1) > 0;
}

uint64_t FigGeometryAspectRatioEqualToAspectRatio(uint64_t a1, uint64_t a2)
{
  _BOOL4 v4;
  BOOL v5;
  char v6;
  _BOOL4 v7;
  _BOOL4 v8;

  if (a1 == a2)
    return 1;
  v4 = (int)a1 < 1 || SHIDWORD(a1) < 1;
  v5 = (int)a2 < 1 || SHIDWORD(a2) < 1;
  v6 = v5;
  v7 = v5 && v4;
  if ((v6 & 1) != 0)
    v8 = v7;
  else
    v8 = (int)a1 * (uint64_t)SHIDWORD(a2) == (int)a2 * (uint64_t)SHIDWORD(a1);
  if (v4)
    return v7;
  else
    return v8;
}

uint64_t FigGeometryDimensionHash(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v5 = a1;
  v6 = a2;
  if ((a2 & 0x100000000) != 0)
  {
    if ((a2 & 0x1C00000000) != 0)
    {
      if ((a2 & 0x400000000) != 0)
        v2 = 11141290;
      else
        v2 = 13369548;
    }
    else
    {
      v2 = _CMTagCFHashBytes((uint64_t)&v5, 8);
    }
  }
  else
  {
    v2 = 0x1000000;
  }
  v3 = (_CMTagCFHashBytes((uint64_t)&v6 + 4, 4) + (v2 << 6) + (v2 >> 2) + 2654435769u) ^ v2;
  return (_CMTagCFHashBytes((uint64_t)&v6, 4) + (v3 << 6) + (v3 >> 2) + 2654435769u) ^ v3;
}

uint64_t FigGeometryPointHash(uint64_t *a1)
{
  unint64_t v2;

  v2 = FigGeometryDimensionHash(*a1, a1[1]) + 2654435769;
  return ((v2 << 6) + (v2 >> 2) + FigGeometryDimensionHash(a1[2], a1[3]) + 2654435769) ^ v2;
}

uint64_t FigGeometrySizeHash(uint64_t *a1)
{
  unint64_t v2;

  v2 = FigGeometryDimensionHash(*a1, a1[1]) + 2654435769;
  return ((v2 << 6) + (v2 >> 2) + FigGeometryDimensionHash(a1[2], a1[3]) + 2654435769) ^ v2;
}

uint64_t FigGeometryVectorHash(uint64_t *a1)
{
  unint64_t v2;

  v2 = FigGeometryDimensionHash(*a1, a1[1]) + 2654435769;
  return ((v2 << 6) + (v2 >> 2) + FigGeometryDimensionHash(a1[2], a1[3]) + 2654435769) ^ v2;
}

uint64_t FigGeometryRectHash(__int128 *a1)
{
  __int128 v2;
  unint64_t v3;
  __int128 v4;
  __int128 v6;
  __int128 v7;

  v2 = a1[1];
  v6 = *a1;
  v7 = v2;
  v3 = FigGeometryPointHash((uint64_t *)&v6) + 2654435769;
  v4 = a1[3];
  v6 = a1[2];
  v7 = v4;
  return ((v3 << 6) + (v3 >> 2) + FigGeometrySizeHash((uint64_t *)&v6) + 2654435769) ^ v3;
}

uint64_t FigGeometryMarginsHash(uint64_t *a1)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = FigGeometryDimensionHash(*a1, a1[1]) + 2654435769;
  v3 = ((v2 << 6) + (v2 >> 2) + FigGeometryDimensionHash(a1[2], a1[3]) + 2654435769) ^ v2;
  v4 = (FigGeometryDimensionHash(a1[4], a1[5]) + (v3 << 6) + (v3 >> 2) + 2654435769u) ^ v3;
  return (FigGeometryDimensionHash(a1[6], a1[7]) + (v4 << 6) + (v4 >> 2) + 2654435769u) ^ v4;
}

unint64_t FigGeometryAspectRatioHash(uint64_t a1)
{
  return ((a1 >> 32) + ((uint64_t)(int)a1 << 6) + ((unint64_t)(int)a1 >> 2) + 2654435769u) ^ (int)a1;
}

uint64_t FigGeometryCoordinateSpaceGetTypeID()
{
  if (sRegisterFigGeometryCoordinateSpaceTypeOnce != -1)
    dispatch_once_f(&sRegisterFigGeometryCoordinateSpaceTypeOnce, 0, (dispatch_function_t)RegisterFigGeometryCoordinateSpaceType);
  return sFigGeometryCoordinateSpaceID;
}

uint64_t RegisterFigGeometryCoordinateSpaceType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigGeometryCoordinateSpaceID = result;
  return result;
}

uint64_t FigGeometryCoordinateSpaceCreate(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5, int a6, uint64_t *a7)
{
  __int128 *v7;
  uint64_t Instance;
  const void *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  int v18;
  int v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  int v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  int v27;
  int v28;
  uint64_t v30;
  uint64_t v31;

  if ((*(_DWORD *)(a2 + 12) & 0x1D) == 1
    && (v7 = (__int128 *)a2, (*(_DWORD *)(a2 + 28) & 0x1D) == 1)
    && (*(_DWORD *)(a2 + 44) & 0x1D) == 1
    && (*(_DWORD *)(a2 + 60) & 0x1D) == 1
    && *(double *)(a2 + 32) != 0.0
    && *(double *)(a2 + 48) != 0.0
    && a7)
  {
    if (sRegisterFigGeometryCoordinateSpaceTypeOnce != -1)
      dispatch_once_f(&sRegisterFigGeometryCoordinateSpaceTypeOnce, 0, (dispatch_function_t)RegisterFigGeometryCoordinateSpaceType);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v14 = (const void *)Instance;
      v15 = *v7;
      v16 = v7[1];
      v17 = v7[2];
      *(_OWORD *)(Instance + 72) = v7[3];
      *(_OWORD *)(Instance + 56) = v17;
      *(_OWORD *)(Instance + 40) = v16;
      *(_OWORD *)(Instance + 24) = v15;
      v18 = *(_DWORD *)(Instance + 16);
      v19 = v18 | 1;
      *(_DWORD *)(Instance + 16) = v18 | 1;
      if (a3)
      {
        if ((*((_DWORD *)a3 + 3) & 0x1D) != 1
          || (*((_DWORD *)a3 + 11) & 0x1D) != 1
          || (*((_DWORD *)a3 + 7) & 0x1D) != 1
          || (*((_DWORD *)a3 + 15) & 0x1D) != 1)
        {
          goto LABEL_51;
        }
        v20 = *a3;
        v21 = a3[1];
        v22 = a3[2];
        *(_OWORD *)(Instance + 136) = a3[3];
        *(_OWORD *)(Instance + 120) = v22;
        *(_OWORD *)(Instance + 104) = v21;
        *(_OWORD *)(Instance + 88) = v20;
        v19 = v18 | 3;
        *(_DWORD *)(Instance + 16) = v18 | 3;
        if (a4)
          goto LABEL_17;
      }
      else
      {
        *(_OWORD *)(Instance + 88) = kFigGeometryMarginsZero;
        *(_OWORD *)(Instance + 104) = unk_18EDDE100;
        *(_OWORD *)(Instance + 120) = xmmword_18EDDE110;
        *(_OWORD *)(Instance + 136) = unk_18EDDE120;
        if (a4)
        {
LABEL_17:
          if ((*(_DWORD *)(a4 + 12) & 0x1D) != 1
            || (*(_DWORD *)(a4 + 28) & 0x1D) != 1
            || (*(_DWORD *)(a4 + 44) & 0x1D) != 1
            || (*(_DWORD *)(a4 + 60) & 0x1D) != 1
            || *(double *)(a4 + 32) == 0.0
            || *(double *)(a4 + 48) == 0.0)
          {
            goto LABEL_51;
          }
          v23 = 4;
          v7 = (__int128 *)a4;
LABEL_26:
          v24 = *v7;
          v25 = v7[1];
          v26 = v7[2];
          *(_OWORD *)(Instance + 264) = v7[3];
          *(_OWORD *)(Instance + 248) = v26;
          *(_OWORD *)(Instance + 232) = v25;
          *(_OWORD *)(Instance + 216) = v24;
          v27 = v19 | v23;
          *(_DWORD *)(Instance + 16) = v27;
          if (!a5)
          {
            *(_QWORD *)(Instance + 280) = 0;
LABEL_31:
            *(_DWORD *)(Instance + 288) = a6;
            if (a6 <= 1918989157)
            {
              if (a6 > 1651665254)
              {
                if (a6 == 1651665255 || a6 == 1667591796)
                  goto LABEL_49;
                v28 = 1818584692;
              }
              else
              {
                if (!a6)
                {
LABEL_50:
                  *a7 = Instance;
                  return 0;
                }
                if (a6 == 1651271014)
                  goto LABEL_49;
                v28 = 1651471476;
              }
            }
            else if (a6 <= 1920166265)
            {
              if (a6 == 1918989158 || a6 == 1918989168)
                goto LABEL_49;
              v28 = 1919510376;
            }
            else
            {
              if (a6 <= 1953460255)
              {
                if (a6 != 1920166266)
                {
                  v28 = 1953260902;
                  goto LABEL_48;
                }
LABEL_49:
                *(_DWORD *)(Instance + 16) = v27 | 0x10;
                goto LABEL_50;
              }
              if (a6 == 1953655143)
                goto LABEL_49;
              v28 = 1953460256;
            }
LABEL_48:
            if (a6 == v28)
              goto LABEL_49;
            goto LABEL_51;
          }
          if (*(_DWORD *)a5 && *(_DWORD *)(a5 + 4))
          {
            *(_QWORD *)(Instance + 280) = *(_QWORD *)a5;
            v27 |= 8u;
            *(_DWORD *)(Instance + 16) = v27;
            goto LABEL_31;
          }
LABEL_51:
          v30 = FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
          CFRelease(v14);
          return v30;
        }
      }
      v23 = 256;
      goto LABEL_26;
    }
    v31 = 4294949965;
  }
  else
  {
    v31 = 4294949966;
  }
  return FigSignalErrorAt(v31, 0, 0, 0, 0, 0, 0);
}

CFDictionaryRef FigGeometryCoordinateSpaceCopyAsDictionary(uint64_t a1, const __CFAllocator *a2)
{
  const __CFAllocator *v4;
  __int128 v5;
  __int128 v6;
  char v7;
  CFIndex v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  CFDictionaryRef v13;
  unint64_t v14;
  uint64_t v15;
  const void *v16;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  int valuePtr;
  void *values[2];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  void *keys[2];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  valuePtr = *(_DWORD *)(a1 + 16);
  keys[0] = CFSTR("flags");
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  keys[1] = CFSTR("bounds");
  v5 = *(_OWORD *)(a1 + 40);
  v18 = *(_OWORD *)(a1 + 24);
  v19 = v5;
  v6 = *(_OWORD *)(a1 + 72);
  v20 = *(_OWORD *)(a1 + 56);
  v21 = v6;
  values[1] = FigGeometryRectCopyAsDictionary(&v18, a2);
  v7 = valuePtr;
  if ((valuePtr & 4) != 0)
  {
    *(_QWORD *)&v29 = CFSTR("contentBounds");
    v9 = *(_OWORD *)(a1 + 232);
    v18 = *(_OWORD *)(a1 + 216);
    v19 = v9;
    v10 = *(_OWORD *)(a1 + 264);
    v20 = *(_OWORD *)(a1 + 248);
    v21 = v10;
    *(_QWORD *)&v24 = FigGeometryRectCopyAsDictionary(&v18, a2);
    v8 = 3;
    v7 = valuePtr;
    if ((valuePtr & 2) == 0)
      goto LABEL_6;
    goto LABEL_5;
  }
  v8 = 2;
  if ((valuePtr & 2) != 0)
  {
LABEL_5:
    keys[v8] = CFSTR("innerMargins");
    v11 = *(_OWORD *)(a1 + 104);
    v18 = *(_OWORD *)(a1 + 88);
    v19 = v11;
    v12 = *(_OWORD *)(a1 + 136);
    v20 = *(_OWORD *)(a1 + 120);
    v21 = v12;
    values[v8++] = FigGeometryMarginsCopyAsDictionary((uint64_t *)&v18, a2);
    v7 = valuePtr;
  }
LABEL_6:
  if ((v7 & 8) != 0)
  {
    keys[v8] = CFSTR("contentAspectRatio");
    values[v8++] = FigGeometryAspectRatioCopyAsDictionary(*(_QWORD *)(a1 + 280), a2);
    if ((valuePtr & 0x10) == 0)
      goto LABEL_9;
    goto LABEL_8;
  }
  if ((v7 & 0x10) != 0)
  {
LABEL_8:
    keys[v8] = CFSTR("contentGravity");
    LODWORD(v18) = *(_DWORD *)(a1 + 288);
    values[v8++] = CFNumberCreate(v4, kCFNumberSInt32Type, &v18);
  }
LABEL_9:
  v13 = CFDictionaryCreate(a2, (const void **)keys, (const void **)values, v8, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v14 = 0;
  v15 = 8 * v8;
  do
  {
    v16 = values[v14 / 8];
    if (v16)
      CFRelease(v16);
    v14 += 8;
  }
  while (v15 != v14);
  return v13;
}

CFDictionaryRef FigGeometryMarginsCopyAsDictionary(uint64_t *a1, const __CFAllocator *a2)
{
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  CFDictionaryRef v6;
  CFDictionaryRef v7;
  CFDictionaryRef v8;
  CFTypeID v9;
  CFTypeID v10;
  CFTypeID v11;
  CFTypeID v12;
  CFDictionaryRef v13;
  const void *v15[4];
  void *keys[2];
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v4 = FigGeometryDimensionCopyAsDictionary(*a1, a1[1], a2);
  v5 = FigGeometryDimensionCopyAsDictionary(a1[2], a1[3], a2);
  v6 = FigGeometryDimensionCopyAsDictionary(a1[4], a1[5], a2);
  v7 = FigGeometryDimensionCopyAsDictionary(a1[6], a1[7], a2);
  v8 = v7;
  *(_OWORD *)keys = xmmword_1E28E2CA0;
  v17 = *(_OWORD *)&off_1E28E2CB0;
  v15[0] = v4;
  v15[1] = v5;
  v15[2] = v6;
  v15[3] = v7;
  if (v4 && v6 && v5 && v7)
  {
    v9 = CFGetTypeID(v4);
    if (v9 == CFDictionaryGetTypeID()
      && (v10 = CFGetTypeID(v5), v10 == CFDictionaryGetTypeID())
      && (v11 = CFGetTypeID(v6), v11 == CFDictionaryGetTypeID())
      && (v12 = CFGetTypeID(v8), v12 == CFDictionaryGetTypeID()))
    {
      v13 = CFDictionaryCreate(a2, (const void **)keys, v15, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    }
    else
    {
      v13 = 0;
    }
    goto LABEL_10;
  }
  FigSignalErrorAt(4294949965, 0, 0, 0, 0, 0, 0);
  v13 = 0;
  if (v4)
LABEL_10:
    CFRelease(v4);
  if (v6)
    CFRelease(v6);
  if (v5)
    CFRelease(v5);
  if (v8)
    CFRelease(v8);
  return v13;
}

CFDictionaryRef FigGeometryAspectRatioCopyAsDictionary(uint64_t a1, const __CFAllocator *a2)
{
  const __CFAllocator *v3;
  CFDictionaryRef v4;
  uint64_t v5;
  char v6;
  char v7;
  const void *v8;
  uint64_t valuePtr;
  void *values[2];
  void *keys[2];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  valuePtr = a1;
  *(_OWORD *)keys = xmmword_1E28E2CC0;
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  values[0] = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  values[1] = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)&valuePtr + 4);
  v4 = CFDictionaryCreate(a2, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v5 = 0;
  v6 = 1;
  do
  {
    v7 = v6;
    v8 = values[v5];
    if (v8)
      CFRelease(v8);
    v6 = 0;
    v5 = 1;
  }
  while ((v7 & 1) != 0);
  return v4;
}

CFNumberRef FigGeometryCoordinateGravityTypeCopyAsCFType(int a1)
{
  int valuePtr;

  valuePtr = a1;
  return CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
}

const __CFDictionary *FigGeometryCoordinateSpaceMakeFromDictionary(const __CFDictionary *result, uint64_t a2)
{
  const __CFDictionary *v3;
  CFTypeID v4;
  int v5;
  int v6;
  int v7;
  int v8;
  __int128 *v9;
  _OWORD *v10;
  const void **v11;
  uint64_t v12;
  _OWORD v13[4];
  _OWORD v14[4];
  const void *v15;
  _OWORD v16[4];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  int v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *value;
  const __CFDictionary *v27;

  value = 0;
  v27 = 0;
  v24 = 0;
  v25 = 0;
  v22 = 0;
  v23 = 0;
  v21 = 0;
  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID(result);
    if (v4 != CFDictionaryGetTypeID()
      || !FigCFDictionaryGetInt32IfPresent((uint64_t)v3, CFSTR("flags"), &v21)
      || !CFDictionaryGetValueIfPresent(v3, CFSTR("bounds"), (const void **)&value))
    {
      return 0;
    }
    v17 = kFigGeometryRectZero;
    v18 = unk_18EDDC9E8;
    v19 = xmmword_18EDDC9F8;
    v20 = unk_18EDDCA08;
    memset(v16, 0, sizeof(v16));
    v15 = 0;
    memset(v14, 0, sizeof(v14));
    if ((v21 & 1) != 0 && CFDictionaryGetValueIfPresent(v3, CFSTR("bounds"), (const void **)&value))
      FigGeometryRectMakeFromDictionary(value, &v17);
    if ((v21 & 4) != 0 && CFDictionaryGetValueIfPresent(v3, CFSTR("contentBounds"), (const void **)&v25))
    {
      FigGeometryRectMakeFromDictionary(v25, v14);
      v5 = 0;
    }
    else
    {
      v5 = 1;
    }
    if ((v21 & 2) != 0 && CFDictionaryGetValueIfPresent(v3, CFSTR("innerMargins"), (const void **)&v24))
    {
      FigGeometryMarginsMakeFromDictionary((CFTypeID)v24, (uint64_t)v16);
      v6 = 0;
    }
    else
    {
      v6 = 1;
    }
    if ((v21 & 8) != 0 && CFDictionaryGetValueIfPresent(v3, CFSTR("contentAspectRatio"), (const void **)&v23))
    {
      v7 = 0;
      v15 = FigGeometryAspectRatioMakeFromDictionary(v23);
    }
    else
    {
      v7 = 1;
    }
    if ((v21 & 0x10) != 0 && CFDictionaryGetValueIfPresent(v3, CFSTR("contentGravity"), (const void **)&v22))
      v8 = FigGeometryCoordinateGravityTypeMakeFromCFType((const __CFNumber *)v22);
    else
      v8 = 0;
    if (v6)
      v9 = 0;
    else
      v9 = v16;
    if (v5)
      v10 = 0;
    else
      v10 = v14;
    if (v7)
      v11 = 0;
    else
      v11 = &v15;
    v13[0] = v17;
    v13[1] = v18;
    v13[2] = v19;
    v13[3] = v20;
    v12 = FigGeometryCoordinateSpaceCreate(a2, (uint64_t)v13, v9, (uint64_t)v10, (uint64_t)v11, v8, (uint64_t *)&v27);
    if (!(_DWORD)v12)
      return v27;
    FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
    result = v27;
    if (v27)
    {
      CFRelease(v27);
      return 0;
    }
  }
  return result;
}

CFTypeID FigGeometryMarginsMakeFromDictionary@<X0>(CFTypeID result@<X0>, uint64_t a2@<X8>)
{
  const __CFDictionary *v3;
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;
  CFTypeID v7;
  CFTypeID v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFTypeRef v19;
  CFTypeRef cf;
  CFTypeRef v21;
  void *value;

  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 44) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_DWORD *)(a2 + 12) = 1;
  *(_DWORD *)(a2 + 28) = 1;
  *(_DWORD *)(a2 + 44) = 1;
  *(_DWORD *)(a2 + 60) = 1;
  v21 = 0;
  value = 0;
  v19 = 0;
  cf = 0;
  if (result)
  {
    v3 = (const __CFDictionary *)result;
    v4 = CFGetTypeID((CFTypeRef)result);
    result = CFDictionaryGetTypeID();
    if (v4 == result)
    {
      result = CFDictionaryGetValueIfPresent(v3, CFSTR("left"), (const void **)&value);
      if ((_DWORD)result)
      {
        result = CFDictionaryGetValueIfPresent(v3, CFSTR("right"), &cf);
        if ((_DWORD)result)
        {
          result = CFDictionaryGetValueIfPresent(v3, CFSTR("top"), &v21);
          if ((_DWORD)result)
          {
            result = CFDictionaryGetValueIfPresent(v3, CFSTR("bottom"), &v19);
            if ((_DWORD)result)
            {
              result = (CFTypeID)value;
              if (value)
              {
                v5 = CFGetTypeID(value);
                result = CFDictionaryGetTypeID();
                if (v5 == result)
                {
                  result = (CFTypeID)cf;
                  if (cf)
                  {
                    v6 = CFGetTypeID(cf);
                    result = CFDictionaryGetTypeID();
                    if (v6 == result)
                    {
                      result = (CFTypeID)v21;
                      if (v21)
                      {
                        v7 = CFGetTypeID(v21);
                        result = CFDictionaryGetTypeID();
                        if (v7 == result)
                        {
                          result = (CFTypeID)v19;
                          if (v19)
                          {
                            v8 = CFGetTypeID(v19);
                            result = CFDictionaryGetTypeID();
                            if (v8 == result)
                            {
                              v9 = FigGeometryDimensionMakeFromDictionary(value);
                              v11 = v10;
                              v12 = FigGeometryDimensionMakeFromDictionary(cf);
                              v14 = v13;
                              v15 = FigGeometryDimensionMakeFromDictionary(v21);
                              v17 = v16;
                              result = (CFTypeID)FigGeometryDimensionMakeFromDictionary(v19);
                              *(_QWORD *)a2 = v9;
                              *(_QWORD *)(a2 + 8) = v11;
                              *(_QWORD *)(a2 + 16) = v12;
                              *(_QWORD *)(a2 + 24) = v14;
                              *(_QWORD *)(a2 + 32) = v15;
                              *(_QWORD *)(a2 + 40) = v17;
                              *(_QWORD *)(a2 + 48) = result;
                              *(_QWORD *)(a2 + 56) = v18;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

const void *FigGeometryAspectRatioMakeFromDictionary(const void *result)
{
  uint64_t v1;
  CFTypeID v2;
  BOOL v3;
  unsigned int v4;
  unsigned int v5;

  v4 = 1;
  v5 = 1;
  if (result)
  {
    v1 = (uint64_t)result;
    v2 = CFGetTypeID(result);
    if (v2 == CFDictionaryGetTypeID()
      && FigCFDictionaryGetInt32IfPresent(v1, CFSTR("horizontal"), &v5)
      && FigCFDictionaryGetInt32IfPresent(v1, CFSTR("vertical"), &v4))
    {
      if (v4)
        v3 = v5 == 0;
      else
        v3 = 1;
      if (v3)
        return 0;
      else
        return (const void *)(v5 | ((unint64_t)v4 << 32));
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const __CFNumber *FigGeometryCoordinateGravityTypeMakeFromCFType(const __CFNumber *result)
{
  const __CFNumber *v1;
  CFTypeID v2;
  unsigned int valuePtr;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFNumberGetTypeID())
    {
      valuePtr = 0;
      CFNumberGetValue(v1, kCFNumberSInt32Type, &valuePtr);
      return (const __CFNumber *)valuePtr;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFMutableStringRef FigGeometryMarginsCopyDescription(const __CFAllocator *a1, uint64_t a2)
{
  CFMutableStringRef Mutable;
  __CFString *v5;
  __CFString *v6;
  __CFString *v7;
  __CFString *v8;
  __CFString *v9;

  Mutable = CFStringCreateMutable(a1, 0);
  v5 = FigGeometryDimensionCopyDescription(a1, *(_QWORD *)a2, *(_QWORD *)(a2 + 8));
  v6 = FigGeometryDimensionCopyDescription(a1, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 40));
  v7 = FigGeometryDimensionCopyDescription(a1, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 24));
  v8 = FigGeometryDimensionCopyDescription(a1, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 56));
  v9 = v8;
  if (Mutable)
  {
LABEL_7:
    if (!v5)
      goto LABEL_9;
    goto LABEL_8;
  }
  if (!v5 || !v6 || !v7 || !v8)
  {
    CFStringAppendFormat(0, 0, CFSTR("{leftMargin:%@,topMargin:%@,rightMargin:%@,bottomMargin:%@}"), v5, v6, v7, v8);
    goto LABEL_7;
  }
LABEL_8:
  CFRelease(v5);
LABEL_9:
  if (v6)
    CFRelease(v6);
  if (v7)
    CFRelease(v7);
  if (v9)
    CFRelease(v9);
  return Mutable;
}

CFMutableStringRef FigGeometryAspectRatioCopyDescription(const __CFAllocator *a1, unint64_t a2)
{
  CFMutableStringRef Mutable;

  Mutable = CFStringCreateMutable(a1, 0);
  if (!Mutable)
    CFStringAppendFormat(0, 0, CFSTR("%d:%d"), a2, HIDWORD(a2));
  return Mutable;
}

CFStringRef FigGeometryCoordinateGravityTypeCopyDescription(const __CFAllocator *a1, int a2)
{
  const __CFString *v2;

  if (a2 <= 1918989157)
  {
    if (a2 > 1651665254)
    {
      switch(a2)
      {
        case 1651665255:
          v2 = CFSTR("bottomRight");
          return CFStringCreateCopy(a1, v2);
        case 1667591796:
          v2 = CFSTR("center");
          return CFStringCreateCopy(a1, v2);
        case 1818584692:
          v2 = CFSTR("left");
          return CFStringCreateCopy(a1, v2);
      }
    }
    else
    {
      switch(a2)
      {
        case 0:
          v2 = CFSTR("<unspecified>");
          return CFStringCreateCopy(a1, v2);
        case 1651271014:
          v2 = CFSTR("bottomLeft");
          return CFStringCreateCopy(a1, v2);
        case 1651471476:
          v2 = CFSTR("bottom");
          return CFStringCreateCopy(a1, v2);
      }
    }
  }
  else if (a2 <= 1920166265)
  {
    switch(a2)
    {
      case 1918989158:
        v2 = CFSTR("resizeAspectFill");
        return CFStringCreateCopy(a1, v2);
      case 1918989168:
        v2 = CFSTR("resizeAspect");
        return CFStringCreateCopy(a1, v2);
      case 1919510376:
        v2 = CFSTR("right");
        return CFStringCreateCopy(a1, v2);
    }
  }
  else if (a2 > 1953460255)
  {
    if (a2 == 1953460256)
    {
      v2 = CFSTR("top");
      return CFStringCreateCopy(a1, v2);
    }
    if (a2 == 1953655143)
    {
      v2 = CFSTR("topRight");
      return CFStringCreateCopy(a1, v2);
    }
  }
  else
  {
    if (a2 == 1920166266)
    {
      v2 = CFSTR("resize");
      return CFStringCreateCopy(a1, v2);
    }
    if (a2 == 1953260902)
    {
      v2 = CFSTR("topLeft");
      return CFStringCreateCopy(a1, v2);
    }
  }
  return 0;
}

double fgInit_CoordinateSpace(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 288) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t fgEqual_CoordinateSpace(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  int v7;
  int v8;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;

  if (a1 == a2)
    return 1;
  v34 = v2;
  v35 = v3;
  result = 0;
  if (a1 && a2)
  {
    v7 = *(_DWORD *)(a1 + 16);
    v8 = *(_DWORD *)(a2 + 16);
    if (v7 != v8 || (*(_DWORD *)(a1 + 16) & 0x10) == 0)
    {
      if (v7 != v8)
        return 0;
    }
    else if (*(_DWORD *)(a1 + 288) != *(_DWORD *)(a2 + 288))
    {
      return 0;
    }
    if ((v7 & 1) != 0)
    {
      v10 = *(_OWORD *)(a1 + 40);
      v30 = *(_OWORD *)(a1 + 24);
      v31 = v10;
      v11 = *(_OWORD *)(a1 + 72);
      v32 = *(_OWORD *)(a1 + 56);
      v33 = v11;
      v12 = *(_OWORD *)(a2 + 40);
      v26 = *(_OWORD *)(a2 + 24);
      v27 = v12;
      v13 = *(_OWORD *)(a2 + 72);
      v28 = *(_OWORD *)(a2 + 56);
      v29 = v13;
      result = FigGeometryRectEqualToRect((uint64_t)&v30, (uint64_t)&v26);
      if (!(_DWORD)result)
        return result;
      v7 = *(_DWORD *)(a1 + 16);
    }
    if ((v7 & 4) != 0)
    {
      v14 = *(_OWORD *)(a1 + 232);
      v30 = *(_OWORD *)(a1 + 216);
      v31 = v14;
      v15 = *(_OWORD *)(a1 + 264);
      v32 = *(_OWORD *)(a1 + 248);
      v33 = v15;
      v16 = *(_OWORD *)(a2 + 232);
      v26 = *(_OWORD *)(a2 + 216);
      v27 = v16;
      v17 = *(_OWORD *)(a2 + 264);
      v28 = *(_OWORD *)(a2 + 248);
      v29 = v17;
      result = FigGeometryRectEqualToRect((uint64_t)&v30, (uint64_t)&v26);
      if (!(_DWORD)result)
        return result;
      v7 = *(_DWORD *)(a1 + 16);
    }
    if ((v7 & 8) == 0
      || (result = FigGeometryAspectRatioEqualToAspectRatio(*(_QWORD *)(a1 + 280), *(_QWORD *)(a2 + 280)), (_DWORD)result))
    {
      if ((v7 & 2) != 0)
      {
        v18 = *(_OWORD *)(a1 + 104);
        v30 = *(_OWORD *)(a1 + 88);
        v31 = v18;
        v19 = *(_OWORD *)(a1 + 136);
        v32 = *(_OWORD *)(a1 + 120);
        v33 = v19;
        v20 = *(_OWORD *)(a2 + 104);
        v26 = *(_OWORD *)(a2 + 88);
        v27 = v20;
        v21 = *(_OWORD *)(a2 + 136);
        v28 = *(_OWORD *)(a2 + 120);
        v29 = v21;
        result = FigGeometryMarginsEqualToMargins((uint64_t *)&v30, (uint64_t *)&v26);
        if (!(_DWORD)result)
          return result;
        v7 = *(_DWORD *)(a1 + 16);
      }
      if ((v7 & 0x20) != 0)
      {
        v22 = *(_OWORD *)(a1 + 168);
        v30 = *(_OWORD *)(a1 + 152);
        v31 = v22;
        v23 = *(_OWORD *)(a1 + 200);
        v32 = *(_OWORD *)(a1 + 184);
        v33 = v23;
        v24 = *(_OWORD *)(a2 + 168);
        v26 = *(_OWORD *)(a2 + 152);
        v27 = v24;
        v25 = *(_OWORD *)(a2 + 200);
        v28 = *(_OWORD *)(a2 + 184);
        v29 = v25;
        return FigGeometryRectEqualToRect((uint64_t)&v30, (uint64_t)&v26);
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

uint64_t fgHash_CoordinateSpace(uint64_t a1)
{
  CFTypeID v2;
  unint64_t v3;
  unint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  unint64_t v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;

  if (!a1)
    return 0;
  v2 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFigGeometryCoordinateSpaceTypeOnce != -1)
    dispatch_once_f(&sRegisterFigGeometryCoordinateSpaceTypeOnce, 0, (dispatch_function_t)RegisterFigGeometryCoordinateSpaceType);
  if (v2 != sFigGeometryCoordinateSpaceID)
    return 0;
  v3 = *(unsigned int *)(a1 + 16);
  v4 = v3;
  if ((v3 & 1) != 0)
  {
    v5 = *(_OWORD *)(a1 + 40);
    v15 = *(_OWORD *)(a1 + 24);
    v16 = v5;
    v6 = *(_OWORD *)(a1 + 72);
    v17 = *(_OWORD *)(a1 + 56);
    v18 = v6;
    v4 = ((v3 << 6) + 2654435769u + (v3 >> 2) + FigGeometryRectHash(&v15)) ^ v3;
    if ((v3 & 2) == 0)
    {
LABEL_7:
      if ((v3 & 0x20) == 0)
        goto LABEL_8;
      goto LABEL_13;
    }
  }
  else if ((v3 & 2) == 0)
  {
    goto LABEL_7;
  }
  v7 = *(_OWORD *)(a1 + 104);
  v15 = *(_OWORD *)(a1 + 88);
  v16 = v7;
  v8 = *(_OWORD *)(a1 + 136);
  v17 = *(_OWORD *)(a1 + 120);
  v18 = v8;
  v4 ^= (v4 << 6) + 2654435769u + (v4 >> 2) + FigGeometryMarginsHash((uint64_t *)&v15);
  if ((v3 & 0x20) == 0)
  {
LABEL_8:
    if ((v3 & 4) == 0)
      goto LABEL_9;
    goto LABEL_14;
  }
LABEL_13:
  v9 = *(_OWORD *)(a1 + 168);
  v15 = *(_OWORD *)(a1 + 152);
  v16 = v9;
  v10 = *(_OWORD *)(a1 + 200);
  v17 = *(_OWORD *)(a1 + 184);
  v18 = v10;
  v4 ^= (v4 << 6) + 2654435769u + (v4 >> 2) + FigGeometryRectHash(&v15);
  if ((v3 & 4) == 0)
  {
LABEL_9:
    if ((v3 & 8) == 0)
      return v4;
    goto LABEL_15;
  }
LABEL_14:
  v11 = *(_OWORD *)(a1 + 232);
  v15 = *(_OWORD *)(a1 + 216);
  v16 = v11;
  v12 = *(_OWORD *)(a1 + 264);
  v17 = *(_OWORD *)(a1 + 248);
  v18 = v12;
  v4 ^= (v4 << 6) + 2654435769u + (v4 >> 2) + FigGeometryRectHash(&v15);
  if ((v3 & 8) != 0)
  {
LABEL_15:
    v13 = ((v4 << 6)
         + 2654435769u
         + (v4 >> 2)
         + (((*(uint64_t *)(a1 + 280) >> 32)
           + 2654435769
           + ((uint64_t)(int)*(_QWORD *)(a1 + 280) << 6)
           + ((unint64_t)(int)*(_QWORD *)(a1 + 280) >> 2)) ^ (int)*(_QWORD *)(a1 + 280))) ^ v4;
    return (*(unsigned int *)(a1 + 288) + 2654435769 + (v13 << 6) + (v13 >> 2)) ^ v13;
  }
  return v4;
}

__CFString *fgCopyDesc_CoordinateSpace(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  __CFString *v4;
  const __CFAllocator *v5;
  __int128 v6;
  __int128 v7;
  __CFString *v8;
  __int128 v10[4];

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = Mutable;
  if (a1)
  {
    v5 = CFGetAllocator((CFTypeRef)a1);
    v6 = *(_OWORD *)(a1 + 40);
    v10[0] = *(_OWORD *)(a1 + 24);
    v10[1] = v6;
    v7 = *(_OWORD *)(a1 + 72);
    v10[2] = *(_OWORD *)(a1 + 56);
    v10[3] = v7;
    v8 = FigGeometryRectCopyDescription(v5, v10);
    CFStringAppendFormat(v4, 0, CFSTR("<FigGeometryCoordinateSpaceRef %p> bounds:%@"), a1, v8);
    if (v8)
      CFRelease(v8);
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("<FigGeometryCoordinateSpaceRef %p>"), 0);
  }
  return v4;
}

uint64_t FigRPCCreateRemoteClient(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v8;
  _QWORD *v9;
  CFMutableDictionaryRef Mutable;
  uint64_t v11;
  const void *v13;
  NSObject *v14;
  mach_port_name_t v15;

  if (!a1)
  {
    v11 = FigSignalErrorAt(4294955066, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  v8 = malloc_type_calloc(1uLL, 0x38uLL, 0x10F00409625AC60uLL);
  v9 = v8;
  if (!v8)
  {
    v11 = FigSignalErrorAt(4294955065, 0, 0, 0, 0, 0, 0);
    goto LABEL_5;
  }
  v8[4] = a3;
  *v8 = a1;
  v8[1] = a2;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0);
  v9[6] = Mutable;
  if (!Mutable)
  {
    v11 = FigSignalErrorAt(4294955065, 0, 0, 0, 0, 0, 0);
    if (!(_DWORD)v11)
      goto LABEL_5;
    v13 = (const void *)v9[6];
    if (v13)
      CFRelease(v13);
    v14 = v9[5];
    if (v14)
      dispatch_release(v14);
    v15 = *((_DWORD *)v9 + 6);
    if (v15)
      FigMachPortReleaseSendRight_(v15, 0, 0, 0, 0);
    FigSimpleMutexDestroy(v9[2]);
    free(v9);
LABEL_16:
    v9 = 0;
    goto LABEL_5;
  }
  v9[5] = dispatch_queue_create("FigRPCServerConnectionQueue", 0);
  v11 = 0;
  v9[2] = FigSimpleMutexCreate();
LABEL_5:
  *a4 = v9;
  return v11;
}

uint64_t FigRPCCreateServerConnectionForObject(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  return figrpc_createServerConnectionForObjectCommon(a1, a2, a3, 0, 0, 0, a4);
}

uint64_t figrpc_createServerConnectionForObjectCommon(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6, _QWORD *a7)
{
  unsigned int *v9;
  uint64_t v10;
  unsigned int *v16;
  ipc_space_read_t *v17;
  mach_port_name_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  mach_port_name_t v23;
  uint64_t v24;
  mach_port_name_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  uint64_t v31;
  mach_port_name_t v32;
  NSObject *v33;
  _QWORD v35[7];
  _QWORD v36[5];
  _QWORD block[6];
  _QWORD v38[6];
  _QWORD handler[5];
  mach_port_name_t v40;
  mach_port_name_t v41;
  uint64_t v42;
  uint64_t v43;
  void (*v44)(uint64_t, uint64_t, dispatch_object_t);
  void *v45;
  uint64_t *v46;
  unsigned int *v47;
  uint64_t v48;
  int v49;
  mach_port_name_t v50;
  mach_port_name_t v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  mach_port_name_t name;
  mach_msg_type_number_t port_info_outCnt;
  integer_t port_info_out[3];

  v9 = 0;
  port_info_outCnt = 1;
  port_info_out[0] = 0;
  name = 0;
  v52 = 0;
  v53 = &v52;
  v54 = 0x2000000000;
  v55 = 0;
  v10 = 4294955066;
  if (!a1 || !a2 || !a3 || !a7 || a4 && ((v9 = 0, !a5) || a6 < 1))
  {
LABEL_31:
    v27 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    v18 = 0;
    v31 = 0;
    if ((_DWORD)v27)
      goto LABEL_32;
    goto LABEL_44;
  }
  v16 = (unsigned int *)malloc_type_calloc(1uLL, 0x50uLL, 0x10E00405D5CAF00uLL);
  v9 = v16;
  if (!v16)
  {
    v10 = 4294955065;
    goto LABEL_31;
  }
  *((_QWORD *)v16 + 7) = a2;
  v17 = (ipc_space_read_t *)MEMORY[0x1E0C83DA0];
  if (mach_port_allocate(*MEMORY[0x1E0C83DA0], 1u, &name)
    || mach_port_get_attributes(*v17, name, 1, port_info_out, &port_info_outCnt)
    || (port_info_out[0] += 10, MEMORY[0x193FFC1A8](*v17, name, 1, port_info_out, port_info_outCnt))
    || mach_port_insert_right(*v17, name, name, 0x14u))
  {
    v10 = 4294955062;
    goto LABEL_31;
  }
  v18 = name;
  v19 = dispatch_queue_create("RemoteClientNotifyQueue", 0);
  *((_QWORD *)v9 + 4) = v19;
  v20 = MEMORY[0x1E0C809B0];
  if (a4)
  {
    v42 = MEMORY[0x1E0C809B0];
    v43 = 0x40000000;
    v44 = __figrpc_createServerConnectionForObjectCommon_block_invoke;
    v45 = &unk_1E28E2D60;
    v47 = v9;
    v48 = a5;
    v49 = a6;
    v50 = name;
    v51 = v18;
    v46 = &v52;
    v21 = dispatch_mach_create();
    v53[3] = v21;
    *((_QWORD *)v9 + 3) = v21;
    v9[3] = name;
    dispatch_mach_connect();
    v22 = 0;
  }
  else
  {
    v22 = dispatch_source_create(MEMORY[0x1E0C80D98], name, 0, v19);
    v23 = name;
    v9[3] = name;
    *((_QWORD *)v9 + 2) = v22;
    handler[0] = v20;
    handler[1] = 0x40000000;
    handler[2] = __figrpc_createServerConnectionForObjectCommon_block_invoke_2;
    handler[3] = &__block_descriptor_tmp_7_6;
    v40 = v23;
    v41 = v18;
    handler[4] = v22;
    dispatch_source_set_cancel_handler(v22, handler);
    v38[0] = v20;
    v38[1] = 0x40000000;
    v38[2] = __figrpc_createServerConnectionForObjectCommon_block_invoke_3;
    v38[3] = &__block_descriptor_tmp_8_3;
    v38[4] = a1;
    v38[5] = v22;
    dispatch_source_set_event_handler(v22, v38);
    dispatch_resume(v22);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  v25 = (mach_port_name_t *)(a1 + 24);
  v24 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v24)
    goto LABEL_21;
  v26 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, unsigned int *, unsigned int *, unsigned int *))(a3 + 16))(a3, v24, name, v9 + 2, v9 + 12, v9 + 16);
  if ((_DWORD)v26 == -308 || (v27 = v26, (_DWORD)v26 == 268435459) || (_DWORD)v26 == -303)
  {
    FigMachPortReleaseSendRight_(*v25, 0, 0, 0, 0);
    *v25 = 0;
LABEL_21:
    v28 = bootstrap_look_up(*MEMORY[0x1E0C81720], *(const char **)a1, (mach_port_t *)(a1 + 24));
    if ((_DWORD)v28)
    {
      v27 = v28;
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
      goto LABEL_23;
    }
    FigRemote_LookUpServerTimeoutPort();
    v27 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, unsigned int *, unsigned int *, unsigned int *))(a3 + 16))(a3, *v25, name, v9 + 2, v9 + 12, v9 + 16);
    goto LABEL_27;
  }
  if (!*v25)
    goto LABEL_21;
LABEL_27:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  if ((_DWORD)v27)
  {
LABEL_23:
    if (v22)
    {
      dispatch_source_cancel(v22);
LABEL_39:
      v32 = v9[2];
      if (v32)
        FigMachPortReleaseSendRight_(v32, 0, 0, 0, 0);
      v33 = *((_QWORD *)v9 + 4);
      if (v33)
        dispatch_release(v33);
LABEL_43:
      free(v9);
      v9 = 0;
      v31 = v27;
      goto LABEL_44;
    }
LABEL_32:
    if (v53[3])
    {
      dispatch_mach_cancel();
    }
    else
    {
      if (name)
        FigMachPortReleaseReceiveRight_(name, 0, 0, 0, 0);
      if (v18)
        FigMachPortReleaseSendRight_(v18, 0, 0, 0, 0);
    }
    if (!v9)
      goto LABEL_43;
    goto LABEL_39;
  }
  v29 = dispatch_source_create(MEMORY[0x1E0C80DA0], v9[2], 1uLL, *(dispatch_queue_t *)(a1 + 40));
  *((_QWORD *)v9 + 5) = v29;
  v30 = *(NSObject **)(a1 + 40);
  block[0] = v20;
  block[1] = 0x40000000;
  block[2] = __figrpc_createServerConnectionForObjectCommon_block_invoke_4;
  block[3] = &__block_descriptor_tmp_9_5;
  block[4] = a1;
  block[5] = v9;
  dispatch_sync(v30, block);
  v36[0] = v20;
  v36[1] = 0x40000000;
  v36[2] = __figrpc_createServerConnectionForObjectCommon_block_invoke_5;
  v36[3] = &__block_descriptor_tmp_10_5;
  v36[4] = v29;
  dispatch_source_set_cancel_handler(v29, v36);
  v35[0] = v20;
  v35[1] = 0x40000000;
  v35[2] = __figrpc_createServerConnectionForObjectCommon_block_invoke_6;
  v35[3] = &__block_descriptor_tmp_12_4;
  v35[4] = a1;
  v35[5] = v9;
  v35[6] = v29;
  dispatch_source_set_event_handler(v29, v35);
  dispatch_resume(v29);
  v31 = 0;
LABEL_44:
  *a7 = v9;
  _Block_object_dispose(&v52, 8);
  return v31;
}

uint64_t FigRPCCreateServerConnectionForObjectUsingMachChannel(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, _QWORD *a6)
{
  return figrpc_createServerConnectionForObjectCommon(a1, a2, a5, 1, a3, a4, a6);
}

uint64_t FigRPCGetServerConnectionInfo(uint64_t a1, _DWORD *a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v5;

  if (!a1)
  {
    v5 = 4294955066;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  if (*(_BYTE *)(a1 + 72))
  {
    v5 = 4294955061;
    return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  }
  if (a2)
    *a2 = *(_DWORD *)(a1 + 8);
  if (a3)
    *a3 = *(_QWORD *)(a1 + 48);
  if (a4)
    *a4 = *(_QWORD *)(a1 + 64);
  return 0;
}

uint64_t FigRPCDisposeServerConnection(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  NSObject *v4;
  _QWORD v6[6];

  if (!a1)
    return FigSignalErrorAt(4294955066, 0, 0, 0, 0, 0, 0);
  if (a2)
  {
    v3 = *(NSObject **)(a1 + 40);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __FigRPCDisposeServerConnection_block_invoke;
    v6[3] = &__block_descriptor_tmp_50;
    v6[4] = a1;
    v6[5] = a2;
    dispatch_sync(v3, v6);
    v4 = *(NSObject **)(a2 + 16);
    if (v4)
      dispatch_source_cancel(v4);
    if (*(_QWORD *)(a2 + 24))
      dispatch_mach_cancel();
    dispatch_release(*(dispatch_object_t *)(a2 + 32));
    free((void *)a2);
  }
  return 0;
}

void FigRPCKillServerOnTimeout(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a2)
    a2 = *(_QWORD *)(a2 + 64);
  FigRemote_InterpretMachErrorForTimeout(a3, a2, a4, a5);
}

void __figrpc_createServerConnectionForObjectCommon_block_invoke(uint64_t a1, uint64_t a2, dispatch_object_t object)
{
  mach_msg_header_t *msg;
  NSObject *v6;

  switch(a2)
  {
    case 8:
      v6 = *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v6)
LABEL_8:
        dispatch_release(v6);
      break;
    case 7:
      FigMachPortReleaseReceiveRight_(*(_DWORD *)(a1 + 60), 0, 0, 0, 0);
      FigMachPortReleaseSendRight_(*(_DWORD *)(a1 + 64), 0, 0, 0, 0);
      break;
    case 2:
      dispatch_retain(object);
      if ((dispatch_mach_mig_demux() & 1) == 0)
      {
        msg = (mach_msg_header_t *)dispatch_mach_msg_get_msg();
        mach_msg_destroy(msg);
      }
      v6 = object;
      goto LABEL_8;
  }
}

void __figrpc_createServerConnectionForObjectCommon_block_invoke_2(uint64_t a1)
{
  FigMachPortReleaseReceiveRight_(*(_DWORD *)(a1 + 40), 0, 0, 0, 0);
  FigMachPortReleaseSendRight_(*(_DWORD *)(a1 + 44), 0, 0, 0, 0);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

uint64_t __figrpc_createServerConnectionForObjectCommon_block_invoke_3(uint64_t result)
{
  if (*(_QWORD *)(*(_QWORD *)(result + 32) + 32))
    return dispatch_mig_server();
  return result;
}

void __figrpc_createServerConnectionForObjectCommon_block_invoke_4(uint64_t a1)
{
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 32) + 48), (const void *)*(unsigned int *)(*(_QWORD *)(a1 + 40) + 8), *(const void **)(a1 + 40));
}

void __figrpc_createServerConnectionForObjectCommon_block_invoke_5(uint64_t a1)
{
  mach_port_name_t handle;

  handle = dispatch_source_get_handle(*(dispatch_source_t *)(a1 + 32));
  FigMachPortReleaseSendRight_(handle, 0, 0, 0, 0);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void __figrpc_createServerConnectionForObjectCommon_block_invoke_6(uint64_t a1)
{
  void *v2;
  NSObject *global_queue;
  uint64_t v4;
  _QWORD block[6];
  void *value;

  value = 0;
  if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 32) + 48), (const void *)*(unsigned int *)(*(_QWORD *)(a1 + 40) + 8), (const void **)&value))
  {
    v2 = value;
    *((_BYTE *)value + 72) = 1;
    global_queue = dispatch_get_global_queue(0, 0);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __figrpc_createServerConnectionForObjectCommon_block_invoke_7;
    block[3] = &__block_descriptor_tmp_11_3;
    v4 = *(_QWORD *)(a1 + 48);
    block[4] = v2;
    block[5] = v4;
    dispatch_async(global_queue, block);
    *((_QWORD *)value + 5) = 0;
  }
  else
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 48));
  }
}

void __figrpc_createServerConnectionForObjectCommon_block_invoke_7(uint64_t a1)
{
  __CFNotificationCenter *DefaultLocalCenter;

  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("rpcNotice_ServerConnectionDied"), *(const void **)(a1 + 32), 0);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
}

uint64_t CMHapticFormatDescriptionCreateFromBigEndianHapticDescriptionData(CFAllocatorRef alloc, unsigned int *a2, unint64_t a3, int a4, CMFormatDescriptionRef *formatDescriptionOut)
{
  CMFormatDescriptionRef *v5;
  signed int v6;
  unsigned int v9;
  unint64_t v10;
  __CFDictionary *Mutable;
  unsigned int *v12;
  const CFDictionaryKeyCallBacks *v13;
  const CFDictionaryValueCallBacks *v14;
  unsigned int v15;
  unsigned int v16;
  signed int v17;
  uint64_t v18;
  CFDictionaryRef v20;
  const __CFDictionary *v21;
  uint64_t v22;
  CFStringRef v24;
  CFDataRef v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  CFMutableDictionaryRef theDict;
  UInt8 bytes[4];

  if (!a2)
  {
    v27 = 4294954584;
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  if (a3 <= 0xF || (v5 = formatDescriptionOut) == 0)
  {
    v27 = 4294954584;
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  v6 = bswap32(*a2);
  if (v6 < 0x10 || v6 > a3)
  {
    v27 = 4294954582;
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  v9 = a2[1];
  v10 = v6 - 16;
  theDict = 0;
  if (v10 < 8)
  {
    v21 = 0;
    goto LABEL_34;
  }
  v28 = v9;
  Mutable = 0;
  v12 = a2 + 4;
  v13 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v14 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  do
  {
    v16 = *v12;
    v15 = v12[1];
    *(_DWORD *)bytes = v15;
    v17 = bswap32(v16);
    v18 = v17;
    if (v17 < 8 || v10 < v17)
    {
      v24 = 0;
      v25 = 0;
      v26 = 4294954582;
      goto LABEL_40;
    }
    if (v15 != 1701147238)
    {
      v24 = CFStringCreateWithBytes(alloc, bytes, 4, 0, 0);
      if (!v24)
      {
        v25 = 0;
LABEL_39:
        v26 = 4294954583;
LABEL_40:
        v5 = formatDescriptionOut;
        v9 = v28;
        goto LABEL_41;
      }
      v25 = CFDataCreate(alloc, (const UInt8 *)v12 + 8, v18 - 8);
      if (!v25)
        goto LABEL_39;
      Mutable = theDict;
      if (!theDict)
      {
        Mutable = CFDictionaryCreateMutable(alloc, 0, v13, v14);
        theDict = Mutable;
        if (!Mutable)
          goto LABEL_39;
      }
      CFDictionarySetValue(Mutable, v24, v25);
      CFRelease(v25);
      CFRelease(v24);
    }
    v12 = (unsigned int *)((char *)v12 + v18);
    v10 -= v18;
  }
  while (v10 > 7);
  if (!Mutable)
  {
    v21 = 0;
    v22 = 0;
    v24 = 0;
    v25 = 0;
    v5 = formatDescriptionOut;
    v9 = v28;
    goto LABEL_27;
  }
  v20 = CFDictionaryCreate(alloc, (const void **)&kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms, (const void **)&theDict, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v24 = 0;
  v9 = v28;
  if (v20)
  {
    v21 = v20;
    v22 = 0;
    v25 = 0;
    v5 = formatDescriptionOut;
    goto LABEL_27;
  }
  v26 = 4294954583;
  v25 = 0;
  v5 = formatDescriptionOut;
LABEL_41:
  v22 = FigSignalErrorAt(v26, 0, 0, 0, 0, 0, 0);
  v21 = 0;
LABEL_27:
  if (theDict)
    CFRelease(theDict);
  if (v25)
    CFRelease(v25);
  if (v24)
    CFRelease(v24);
  if (!(_DWORD)v22)
LABEL_34:
    v22 = CMFormatDescriptionCreate(alloc, 0x68617074u, bswap32(v9), v21, v5);
  if (v21)
    CFRelease(v21);
  return v22;
}

uint64_t CMHapticFormatDescriptionCreateFromBigEndianHapticDescriptionBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, uint64_t a3, CMFormatDescriptionRef *a4)
{
  OpaqueCMBlockBuffer *v5;
  size_t DataLength;
  uint64_t DataPointer;
  int v9;
  uint64_t v10;
  int v12[2];
  CMBlockBufferRef blockBufferOut;

  *(_QWORD *)v12 = 0;
  blockBufferOut = 0;
  if (theBuffer && a4)
  {
    v5 = theBuffer;
    DataLength = CMBlockBufferGetDataLength(theBuffer);
    if (!CMBlockBufferIsRangeContiguous(v5, 0, 0))
    {
      DataPointer = CMBlockBufferCreateContiguous(a1, v5, a1, 0, 0, 0, 0, &blockBufferOut);
      if ((_DWORD)DataPointer)
        goto LABEL_8;
      v5 = blockBufferOut;
    }
    DataPointer = CMBlockBufferGetDataPointer(v5, 0, 0, 0, (char **)v12);
    if (!(_DWORD)DataPointer)
      DataPointer = CMHapticFormatDescriptionCreateFromBigEndianHapticDescriptionData(a1, *(unsigned int **)v12, DataLength, v9, a4);
  }
  else
  {
    DataPointer = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
LABEL_8:
  v10 = DataPointer;
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v10;
}

uint64_t CMHapticFormatDescriptionCopyAsBigEndianHapticDescriptionBlockBuffer(const __CFAllocator *a1, CFTypeRef cf, uint64_t a3, CMBlockBufferRef *a4)
{
  CFTypeID v7;
  const __CFDictionary *Extensions;
  const __CFDictionary *Value;
  uint64_t v10;
  size_t DataLength;
  size_t v12;
  uint64_t DataPointer;
  uint64_t v14;
  uint64_t v16;
  CMBlockBufferRef destinationBuffer;
  unint64_t sourceBytes;
  unint64_t v19;
  _OWORD context[3];
  uint64_t v21;
  CMBlockBufferRef blockBufferOut;

  sourceBytes = 0;
  v19 = 0;
  destinationBuffer = 0;
  if (!cf)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (!a4)
  {
    v16 = 4294954584;
    goto LABEL_25;
  }
  v7 = CFGetTypeID(cf);
  if (v7 != CMFormatDescriptionGetTypeID() || CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)cf) != 1751216244)
  {
    v16 = 4294954581;
LABEL_25:
    v14 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    goto LABEL_26;
  }
  Extensions = CMFormatDescriptionGetExtensions((CMFormatDescriptionRef)cf);
  if (!Extensions)
  {
    Value = 0;
    v12 = 0;
    goto LABEL_13;
  }
  blockBufferOut = 0;
  Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("SampleDescriptionExtensionAtoms"));
  if (Value)
  {
    v21 = 0;
    memset(context, 0, sizeof(context));
    v10 = CMBlockBufferCreateEmpty(a1, 0, 0, &blockBufferOut);
    if (!(_DWORD)v10)
    {
      v10 = FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)context);
      if (!(_DWORD)v10)
      {
        CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)hapticBridgeAppendExtensionsFunc, context);
        Value = blockBufferOut;
        goto LABEL_10;
      }
    }
    v14 = v10;
    if (blockBufferOut)
      CFRelease(blockBufferOut);
LABEL_26:
    Value = 0;
    goto LABEL_31;
  }
LABEL_10:
  DataLength = CMBlockBufferGetDataLength(Value);
  if (DataLength >= 0x7FFFFFF0)
  {
    DataPointer = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
LABEL_30:
    v14 = DataPointer;
LABEL_31:
    if (destinationBuffer)
      CFRelease(destinationBuffer);
    goto LABEL_19;
  }
  v12 = DataLength;
LABEL_13:
  sourceBytes = _byteswap_uint64(__PAIR64__((int)v12 + 16, CMFormatDescriptionGetMediaSubType((CMFormatDescriptionRef)cf)));
  v19 = 0xFFFF000000000000;
  DataPointer = CMBlockBufferCreateWithMemoryBlock(a1, 0, (v12 + 16), a1, 0, 0, (v12 + 16), 1u, &destinationBuffer);
  if ((_DWORD)DataPointer)
    goto LABEL_30;
  DataPointer = CMBlockBufferReplaceDataBytes(&sourceBytes, destinationBuffer, 0, 0x10uLL);
  if ((_DWORD)DataPointer)
    goto LABEL_30;
  if (Value)
  {
    *(_QWORD *)&context[0] = 0;
    DataPointer = CMBlockBufferGetDataPointer(destinationBuffer, 0x10uLL, 0, 0, (char **)context);
    if ((_DWORD)DataPointer)
      goto LABEL_30;
    DataPointer = CMBlockBufferCopyDataBytes(Value, 0, v12, *(void **)&context[0]);
    if ((_DWORD)DataPointer)
      goto LABEL_30;
  }
  v14 = 0;
  *a4 = destinationBuffer;
  destinationBuffer = 0;
LABEL_19:
  if (Value)
    CFRelease(Value);
  return v14;
}

uint64_t hapticBridgeAppendExtensionsFunc(const __CFString *a1, const __CFData *a2, uint64_t a3)
{
  CFTypeID v6;
  CFTypeID v7;
  const UInt8 *BytePtr;
  CFIndex Length;
  unsigned int v11;

  v11 = 0;
  if (a1
    && (v6 = CFGetTypeID(a1), v6 == CFStringGetTypeID())
    && a2
    && (v7 = CFGetTypeID(a2), v7 == CFDataGetTypeID())
    && FigCFStringGetOSTypeValue(a1, (int *)&v11))
  {
    if (!FigAtomWriterBeginAtom(a3, v11, 0))
    {
      BytePtr = CFDataGetBytePtr(a2);
      Length = CFDataGetLength(a2);
      FigAtomWriterAppendData(a3, (uint64_t)BytePtr, Length);
    }
  }
  else
  {
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  return FigAtomWriterEndAtom(a3);
}

uint64_t FigRPCFetchNextPendingNotificationPackagedForMIG(uint64_t a1, _DWORD *a2, _QWORD *a3, char *a4, vm_address_t *a5, unsigned int *a6)
{
  NSObject *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  unsigned int Length;
  void *v19;
  const UInt8 *BytePtr;
  CFDataRef theData;
  _QWORD block[7];
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;

  v28 = 0;
  v29 = &v28;
  v30 = 0x2000000000;
  v31 = 0;
  v24 = 0;
  v25 = &v24;
  v26 = 0x2000000000;
  v27 = 0;
  if (a1 && a2 && a3 && a4 && a5 && a6)
  {
    v12 = *(NSObject **)(a1 + 104);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __FigRPCFetchNextPendingNotificationPackagedForMIG_block_invoke;
    block[3] = &unk_1E28E2E48;
    block[4] = &v28;
    block[5] = &v24;
    block[6] = a1;
    dispatch_sync(v12, block);
    v13 = v29[3];
    if (v13)
    {
      *a3 = *(_QWORD *)(a1 + 32);
      CFStringGetCString(*(CFStringRef *)(v13 + 8), a4, 512, 0);
      *a5 = 0;
      *a6 = 0;
      v14 = (_QWORD *)v29[3];
      v15 = v14[2];
      if (v15)
      {
        theData = 0;
        if (FigRemote_CreateBinaryPListData(v15, *MEMORY[0x1E0C9AE00], &theData))
        {
          v16 = 0;
        }
        else
        {
          v17 = *(const void **)(v29[3] + 16);
          if (v17)
          {
            CFRelease(v17);
            *(_QWORD *)(v29[3] + 16) = 0;
          }
          Length = CFDataGetLength(theData);
          *a6 = Length;
          v16 = vm_allocate(*MEMORY[0x1E0C83DA0], a5, Length, 1560281089);
          if (!(_DWORD)v16)
          {
            v19 = (void *)*a5;
            BytePtr = CFDataGetBytePtr(theData);
            memcpy(v19, BytePtr, *a6);
          }
          CFRelease(theData);
        }
        v14 = (_QWORD *)v29[3];
      }
      else
      {
        v16 = 0;
      }
      *a2 = *((_DWORD *)v25 + 6);
      figrpc_freeQueuedNotification(v14);
    }
    else
    {
      v16 = 4294955056;
    }
  }
  else
  {
    v16 = FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
  }
  _Block_object_dispose(&v24, 8);
  _Block_object_dispose(&v28, 8);
  return v16;
}

void figrpc_freeQueuedNotification(_QWORD *a1)
{
  const void *v2;
  const void *v3;

  v2 = (const void *)a1[1];
  if (v2)
  {
    CFRelease(v2);
    a1[1] = 0;
  }
  v3 = (const void *)a1[2];
  if (v3)
    CFRelease(v3);
  free(a1);
}

uint64_t FigRPCFetchNextPendingNotification(uint64_t a1, _DWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  NSObject *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD block[7];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;

  v21 = 0;
  v22 = &v21;
  v23 = 0x2000000000;
  v24 = 0;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 0;
  if (a1 && a2 && a3 && a4 && a5)
  {
    v10 = *(NSObject **)(a1 + 104);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __FigRPCFetchNextPendingNotification_block_invoke;
    block[3] = &unk_1E28E2E70;
    block[4] = &v21;
    block[5] = &v17;
    block[6] = a1;
    dispatch_sync(v10, block);
    v11 = v22;
    v12 = v22[3];
    if (v12)
    {
      *a3 = *(_QWORD *)(a1 + 32);
      *a4 = *(_QWORD *)(v12 + 8);
      *(_QWORD *)(v11[3] + 8) = 0;
      v13 = v22;
      *a5 = *(_QWORD *)(v22[3] + 16);
      *(_QWORD *)(v13[3] + 16) = 0;
      *a2 = *((_DWORD *)v18 + 6);
      figrpc_freeQueuedNotification((_QWORD *)v13[3]);
      v14 = 0;
    }
    else
    {
      v14 = 4294955056;
    }
  }
  else
  {
    v14 = FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
  }
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  return v14;
}

uint64_t FigRPCStartServerUsingMachChannel(const char *a1, uint64_t a2, int a3, uint64_t a4, mach_port_name_t a5, uint64_t a6, __int128 *a7, mach_port_name_t **a8)
{
  mach_port_name_t *v13;
  mach_port_name_t *v14;
  mach_port_name_t *v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  NSObject *initially_inactive;
  NSObject *v20;
  NSObject *v21;
  uint64_t v23;

  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigRPCServerTrace[1], CFSTR("RPCServerTrace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, gFigRPCServerTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)algn_1EE141FC8, CFSTR("RPCServerTrace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, &qword_1EE141FC0);
  if (a1 && a2 && a6 && a8)
  {
    v13 = (mach_port_name_t *)malloc_type_calloc(1uLL, 0x80uLL, 0x10F00407292CEEDuLL);
    if (v13)
    {
      v14 = v13;
      v15 = v13 + 2;
      if (bootstrap_check_in(*MEMORY[0x1E0C81720], a1, v13 + 2))
      {
        v16 = 4294955054;
      }
      else
      {
        *(_QWORD *)v14 = a1;
        *((_QWORD *)v14 + 7) = a2;
        *((_QWORD *)v14 + 9) = a6;
        *((_QWORD *)v14 + 8) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0);
        *((_QWORD *)v14 + 5) = a4;
        v14[12] = a5;
        *((_BYTE *)v14 + 88) = a3;
        if (a7)
        {
          v18 = *a7;
          *((_QWORD *)v14 + 15) = *((_QWORD *)a7 + 2);
          *(_OWORD *)(v14 + 26) = v18;
        }
        initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
        v20 = dispatch_queue_create(a1, initially_inactive);
        *((_QWORD *)v14 + 2) = v20;
        dispatch_set_qos_class_floor(v20, QOS_CLASS_DEFAULT, 0);
        dispatch_activate(*((dispatch_object_t *)v14 + 2));
        if (*((_QWORD *)v14 + 2))
        {
          if (a3)
          {
            if (figrpc_getCommonServerTimeoutQueue_once != -1)
              dispatch_once(&figrpc_getCommonServerTimeoutQueue_once, &__block_literal_global_19);
            *((_QWORD *)v14 + 12) = figrpc_createRPCTimeoutDetector(figrpc_getCommonServerTimeoutQueue_commonServerTimeoutQueue, (uint64_t)a1, (uint64_t)v14);
          }
          *((_QWORD *)v14 + 4) = dispatch_mach_create();
          *a8 = v14;
          dispatch_mach_connect();
          return 0;
        }
        v16 = 4294955053;
      }
      v17 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
      if (*((_QWORD *)v14 + 4))
      {
        dispatch_mach_cancel();
      }
      else
      {
        FigMachPortReleaseReceiveRight_(*v15, 0, 0, 0, 0);
        FigMachPortReleaseSendRight_(*v15, 0, 0, 0, 0);
      }
      v21 = *((_QWORD *)v14 + 2);
      if (v21)
        dispatch_release(v21);
      free(v14);
      return v17;
    }
    v23 = 4294955055;
  }
  else
  {
    v23 = 4294955056;
  }
  return FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
}

uint64_t figrpc_createRPCTimeoutDetector(NSObject *a1, uint64_t a2, uint64_t a3)
{
  uint64_t Instance;
  CFTypeRef v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  _QWORD v12[5];
  _QWORD handler[8];

  if (figRPCTimeoutDetector_GetTypeID_sRegisterFigRPCTimeoutDetectorTypeOnce != -1)
    dispatch_once(&figRPCTimeoutDetector_GetTypeID_sRegisterFigRPCTimeoutDetectorTypeOnce, &__block_literal_global_41);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, a1);
    v7 = FigCFWeakReferenceHolderCreateWithReferencedObject(Instance);
    *(_QWORD *)(Instance + 560) = a3;
    v8 = *(NSObject **)(Instance + 16);
    v9 = MEMORY[0x1E0C809B0];
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 0x40000000;
    handler[2] = __figrpc_createRPCTimeoutDetector_block_invoke;
    handler[3] = &__block_descriptor_tmp_13_3;
    handler[4] = v7;
    handler[5] = Instance;
    handler[6] = a3;
    handler[7] = a2;
    dispatch_source_set_event_handler(v8, handler);
    v10 = *(NSObject **)(Instance + 16);
    v12[0] = v9;
    v12[1] = 0x40000000;
    v12[2] = __figrpc_createRPCTimeoutDetector_block_invoke_2;
    v12[3] = &__block_descriptor_tmp_14_4;
    v12[4] = v7;
    dispatch_source_set_cancel_handler(v10, v12);
    dispatch_resume(*(dispatch_object_t *)(Instance + 16));
  }
  else
  {
    FigSignalErrorAt(4294955055, 0, 0, 0, 0, 0, 0);
  }
  return Instance;
}

void figRPCTimeoutDetector_setTimer(uint64_t a1, const char *a2, int a3)
{
  uint64_t TimeoutNanoseconds;
  unint64_t v7;
  uint64_t msg;
  NSObject *v9;
  dispatch_time_t v10;

  if (*(_QWORD *)(a1 + 16))
  {
    TimeoutNanoseconds = FigRPCServer_GetTimeoutNanoseconds();
    *(_DWORD *)(a1 + 540) = a3;
    *(_BYTE *)(a1 + 544) = 0;
    if (TimeoutNanoseconds)
    {
      v7 = FigRPCServer_PickRPCTimeoutForCurrentThread(TimeoutNanoseconds, 90000000000);
      msg = dispatch_mach_msg_get_msg();
      snprintf((char *)(a1 + 25), 0x200uLL, "(%s:msgh_id: %d) (timeout: %lld sec)", a2, *(_DWORD *)(msg + 20), v7 / 0x3B9ACA00);
      v9 = *(NSObject **)(a1 + 16);
      v10 = dispatch_time(0, v7);
      dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0x1DCD6500uLL);
      *(_BYTE *)(a1 + 24) = 1;
    }
  }
}

void figRPCTimeoutDetector_unsetTimer(uint64_t a1)
{
  _QWORD block[5];

  if (*(_BYTE *)(a1 + 24))
  {
    *(_BYTE *)(a1 + 24) = 0;
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 16), 0xFFFFFFFFFFFFFFFFLL, 0, 0x1DCD6500uLL);
    if (figrpc_getCommonServerTimeoutQueue_once != -1)
      dispatch_once(&figrpc_getCommonServerTimeoutQueue_once, &__block_literal_global_19);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __figRPCTimeoutDetector_unsetTimer_block_invoke;
    block[3] = &__block_descriptor_tmp_22_2;
    block[4] = a1;
    dispatch_sync((dispatch_queue_t)figrpc_getCommonServerTimeoutQueue_commonServerTimeoutQueue, block);
  }
}

uint64_t FigRPCStartServer(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, mach_port_name_t **a5)
{
  mach_port_name_t *v10;
  mach_port_name_t *v11;
  mach_port_name_t *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v22;
  _QWORD v23[7];
  _QWORD handler[5];

  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigRPCServerTrace[1], CFSTR("RPCServerTrace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, gFigRPCServerTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)algn_1EE141FC8, CFSTR("RPCServerTrace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, &qword_1EE141FC0);
  if (a1 && a2 && a3 && a4 && a5)
  {
    v10 = (mach_port_name_t *)malloc_type_calloc(1uLL, 0x80uLL, 0x10F00407292CEEDuLL);
    if (v10)
    {
      v11 = v10;
      v12 = v10 + 2;
      if (bootstrap_check_in(*MEMORY[0x1E0C81720], a1, v10 + 2))
      {
        v13 = 4294955054;
      }
      else
      {
        *(_QWORD *)v11 = a1;
        *((_QWORD *)v11 + 7) = a2;
        *((_QWORD *)v11 + 9) = a4;
        *((_QWORD *)v11 + 10) = a3;
        *((_QWORD *)v11 + 8) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0);
        v16 = dispatch_queue_create(a1, 0);
        *((_QWORD *)v11 + 2) = v16;
        if (v16)
        {
          v17 = dispatch_source_create(MEMORY[0x1E0C80D98], v11[2], 0, v16);
          *((_QWORD *)v11 + 3) = v17;
          if (v17)
          {
            v18 = MEMORY[0x1E0C809B0];
            handler[0] = MEMORY[0x1E0C809B0];
            handler[1] = 0x40000000;
            handler[2] = __FigRPCStartServer_block_invoke;
            handler[3] = &__block_descriptor_tmp_9_6;
            handler[4] = v11;
            dispatch_source_set_cancel_handler(v17, handler);
            v19 = *((_QWORD *)v11 + 3);
            v23[0] = v18;
            v23[1] = 0x40000000;
            v23[2] = __FigRPCStartServer_block_invoke_2;
            v23[3] = &__block_descriptor_tmp_10_6;
            v23[4] = v11;
            v23[5] = a2;
            v23[6] = a3;
            dispatch_source_set_event_handler(v19, v23);
            *a5 = v11;
            dispatch_resume(*((dispatch_object_t *)v11 + 3));
            return 0;
          }
        }
        v13 = 4294955053;
      }
      v14 = FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
      v15 = *((_QWORD *)v11 + 3);
      if (v15)
        dispatch_source_cancel(v15);
      else
        FigMachPortReleaseReceiveRight_(*v12, 0, 0, 0, 0);
      v20 = *((_QWORD *)v11 + 2);
      if (v20)
        dispatch_release(v20);
      if (*v12)
      {
        FigMachPortReleaseReceiveRight_(*v12, 0, 0, 0, 0);
        FigMachPortReleaseSendRight_(*v12, 0, 0, 0, 0);
      }
      free(v11);
      return v14;
    }
    v22 = 4294955055;
  }
  else
  {
    v22 = 4294955056;
  }
  return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
}

uint64_t FigRPCCreateClientConnection(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, mach_port_name_t a5, uint64_t a6, _QWORD *a7)
{
  return figrpc_createClientCommon(a1, a2, a3, a4, a5, a6, 0, a7);
}

uint64_t figrpc_createClientCommon(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, mach_port_name_t a5, uint64_t a6, int a7, _QWORD *a8)
{
  int v14;
  _DWORD *v16;
  _DWORD *v17;
  ipc_space_t *v18;
  mach_port_name_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v27;
  _QWORD v28[6];
  int v29;
  mach_port_name_t v30;
  _QWORD v31[5];
  mach_port_name_t v32;
  _QWORD v33[6];
  _QWORD handler[5];
  mach_port_name_t v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  void (*v39)(uint64_t, uint64_t);
  void *v40;
  uint64_t *v41;
  _DWORD *v42;
  mach_port_name_t v43;
  char v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  CFStringRef v49;
  mach_port_name_t name;

  name = 0;
  v49 = 0;
  if (a1 && a3 && a4 && a5 + 1 > 1 && a8)
  {
    v14 = a2;
    FigServer_CopyProcessName(a2, &v49);
    v16 = malloc_type_calloc(1uLL, 0x78uLL, 0x10A0040BCFFF8B3uLL);
    v17 = v16;
    if (v16)
    {
      *(_QWORD *)v16 = a1;
      v16[3] = a5;
      v16[4] = v14;
      *((_QWORD *)v16 + 3) = CFRetain(a3);
      *((_QWORD *)v17 + 4) = a4;
      *((_QWORD *)v17 + 5) = a6;
      v18 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
      if (!mach_port_allocate(*MEMORY[0x1E0C83DA0], 1u, &name))
      {
        v19 = name;
        v17[2] = name;
        if (!a7)
        {
          v20 = 0;
          goto LABEL_12;
        }
        if (!mach_port_insert_right(*v18, v19, v19, 0x14u))
        {
          v20 = 1;
LABEL_12:
          v21 = MEMORY[0x1E0C809B0];
          if (*(_QWORD *)(a1 + 32))
          {
            v45 = 0;
            v46 = &v45;
            v47 = 0x2000000000;
            v48 = 0;
            if (*(_BYTE *)(a1 + 88))
            {
              if (figrpc_getCommonServerTimeoutQueue_once != -1)
                dispatch_once(&figrpc_getCommonServerTimeoutQueue_once, &__block_literal_global_19);
              *((_QWORD *)v17 + 14) = figrpc_createRPCTimeoutDetector(figrpc_getCommonServerTimeoutQueue_commonServerTimeoutQueue, **(_QWORD **)v17, a1);
            }
            v37 = v21;
            v38 = 0x40000000;
            v39 = __figrpc_createClientCommon_block_invoke;
            v40 = &unk_1E28E3060;
            v43 = name;
            v44 = v20;
            v41 = &v45;
            v42 = v17;
            v22 = dispatch_mach_create();
            *((_QWORD *)v17 + 7) = v22;
            v46[3] = v22;
            dispatch_mach_connect();
            _Block_object_dispose(&v45, 8);
          }
          else
          {
            v23 = dispatch_source_create(MEMORY[0x1E0C80D98], v17[2], 0, *(dispatch_queue_t *)(a1 + 16));
            *((_QWORD *)v17 + 6) = v23;
            handler[0] = v21;
            handler[1] = 0x40000000;
            handler[2] = __figrpc_createClientCommon_block_invoke_2;
            handler[3] = &__block_descriptor_tmp_24_2;
            v35 = name;
            v36 = v20;
            handler[4] = v23;
            dispatch_source_set_cancel_handler(v23, handler);
            v33[0] = v21;
            v33[1] = 0x40000000;
            v33[2] = __figrpc_createClientCommon_block_invoke_3;
            v33[3] = &__block_descriptor_tmp_25_2;
            v33[4] = v23;
            v33[5] = a1;
            dispatch_source_set_event_handler(v23, v33);
            dispatch_resume(*((dispatch_object_t *)v17 + 6));
          }
          v24 = dispatch_source_create(MEMORY[0x1E0C80DA0], v17[3], 1uLL, *(dispatch_queue_t *)(a1 + 16));
          *((_QWORD *)v17 + 8) = v24;
          v31[0] = v21;
          v31[1] = 0x40000000;
          v31[2] = __figrpc_createClientCommon_block_invoke_4;
          v31[3] = &__block_descriptor_tmp_26_1;
          v32 = a5;
          v31[4] = v24;
          dispatch_source_set_cancel_handler(v24, v31);
          v28[0] = v21;
          v28[1] = 0x40000000;
          v28[2] = __figrpc_createClientCommon_block_invoke_5;
          v28[3] = &__block_descriptor_tmp_27_0;
          v29 = v14;
          v30 = name;
          v28[4] = a1;
          v28[5] = v24;
          dispatch_source_set_event_handler(v24, v28);
          dispatch_resume(v24);
          CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 64), (const void *)v17[2], v17);
          v25 = 0;
          goto LABEL_20;
        }
      }
      v27 = 4294955052;
    }
    else
    {
      v27 = 4294955055;
    }
    v25 = FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v25 = FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
    v17 = 0;
  }
  if ((_DWORD)v25)
  {
    if (a5 - 1 <= 0xFFFFFFFD)
      FigMachPortReleaseSendRight_(a5, 0, 0, 0, 0);
    if (v17 && *((_QWORD *)v17 + 7))
    {
      dispatch_mach_cancel();
    }
    else if (name - 1 <= 0xFFFFFFFD)
    {
      FigMachPortReleaseReceiveRight_(name, 0, 0, 0, 0);
    }
    free(v17);
    v17 = 0;
  }
LABEL_20:
  *a8 = v17;
  if (v49)
    CFRelease(v49);
  return v25;
}

uint64_t FigRPCCreateClientConnectionWithManualCommandPortSendRightInsertion(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, mach_port_name_t a5, uint64_t a6, _QWORD *a7)
{
  return figrpc_createClientCommon(a1, a2, a3, a4, a5, a6, 1, a7);
}

uint64_t FigRPCCreateClientConnectionWithNotifications(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, mach_port_name_t a5, uint64_t a6, uint64_t a7, _QWORD *a8)
{
  uint64_t v12;
  _QWORD *v13;
  dispatch_queue_t v14;
  __CFNotificationCenter *DefaultLocalCenter;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v19;
  _QWORD *v20;

  v20 = 0;
  if (!a1)
  {
    v16 = FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
    goto LABEL_11;
  }
  if (!a3)
    goto LABEL_13;
  if (!a4)
  {
    v19 = 4294955056;
    goto LABEL_17;
  }
  if (a5 && a7 && a8)
  {
    v12 = figrpc_createClientCommon(a1, a2, a3, a4, a5, a6, 0, &v20);
    if ((_DWORD)v12)
      goto LABEL_10;
    v13 = v20;
    v20[10] = 0;
    v13 += 10;
    v13[1] = v13;
    *(v13 - 1) = a7;
    v14 = dispatch_queue_create("FigRPCClientConnectionNotifications", 0);
    v20[13] = v14;
    if (v14)
    {
      DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      v12 = CMNotificationCenterAddListener(DefaultLocalCenter, v20, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))figrpc_reflectServedObjectNotificationToClient, 0, (unint64_t)a3);
      goto LABEL_10;
    }
    v19 = 4294955055;
  }
  else
  {
LABEL_13:
    v19 = 4294955056;
  }
LABEL_17:
  v12 = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
LABEL_10:
  v16 = v12;
  v17 = v20;
  if (!v20)
  {
LABEL_11:
    FigMachPortReleaseSendRight_(a5, 0, 0, 0, 0);
    v17 = v20;
  }
  *a8 = v17;
  return v16;
}

void figrpc_reflectServedObjectNotificationToClient(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, const void *a5)
{
  _QWORD *v8;
  _QWORD *v9;
  NSObject *v10;
  _QWORD block[7];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v8 = malloc_type_calloc(1uLL, 0x18uLL, 0xE00406B48E91AuLL);
  if (v8)
  {
    v9 = v8;
    v8[1] = a3;
    CFRetain(a3);
    if (a5)
      v9[2] = CFRetain(a5);
    v12 = 0;
    v13 = &v12;
    v14 = 0x2000000000;
    v15 = 0;
    v10 = *(NSObject **)(a2 + 104);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __figrpc_enqueueNotificationInternal_block_invoke;
    block[3] = &unk_1E28E3108;
    block[5] = v9;
    block[6] = a2;
    block[4] = &v12;
    dispatch_sync(v10, block);
    if (*((_BYTE *)v13 + 24))
      (*(void (**)(_QWORD, _QWORD))(a2 + 72))(*(unsigned int *)(a2 + 12), *(_QWORD *)(a2 + 32));
    _Block_object_dispose(&v12, 8);
  }
  else
  {
    FigSignalErrorAt(4294955055, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigRPCDisposeClientConnection(uint64_t a1, unsigned int *value)
{
  __CFNotificationCenter *DefaultLocalCenter;
  uint64_t v4;
  _QWORD *v5;
  void (*v6)(uint64_t);
  NSObject *v7;
  NSObject *v8;
  const void *v9;
  NSObject *v10;
  const void *v11;
  uint64_t v13;
  _QWORD block[5];

  if (a1)
  {
    if (!value)
      return 0;
    if (CFDictionaryContainsValue(*(CFDictionaryRef *)(a1 + 64), value))
    {
      if (*((_QWORD *)value + 9))
      {
        DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterRemoveListener(DefaultLocalCenter, value, (int)figrpc_reflectServedObjectNotificationToClient, 0, *((void **)value + 3));
        v4 = *((_QWORD *)value + 3);
        v5 = *(_QWORD **)(CMBaseObjectGetVTable(v4) + 8);
        if (*v5 >= 2uLL)
        {
          v6 = (void (*)(uint64_t))v5[8];
          if (v6)
            v6(v4);
        }
        v7 = *((_QWORD *)value + 13);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = __figrpc_cancelQueuedNotifications_block_invoke;
        block[3] = &__block_descriptor_tmp_30_0;
        block[4] = value;
        dispatch_sync(v7, block);
        dispatch_release(*((dispatch_object_t *)value + 13));
        *((_QWORD *)value + 13) = 0;
      }
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(_QWORD *)value + 64), (const void *)value[2]);
      v8 = *((_QWORD *)value + 6);
      if (v8)
        dispatch_source_cancel(v8);
      if (*((_QWORD *)value + 7))
        dispatch_mach_cancel();
      v9 = (const void *)*((_QWORD *)value + 3);
      if (v9)
        CFRelease(v9);
      v10 = *((_QWORD *)value + 8);
      if (v10)
        dispatch_source_cancel(v10);
      v11 = (const void *)*((_QWORD *)value + 14);
      if (v11)
        CFRelease(v11);
      *((_QWORD *)value + 14) = 0;
      *((_OWORD *)value + 5) = 0u;
      *((_OWORD *)value + 6) = 0u;
      *((_OWORD *)value + 3) = 0u;
      *((_OWORD *)value + 4) = 0u;
      *((_OWORD *)value + 1) = 0u;
      *((_OWORD *)value + 2) = 0u;
      *(_OWORD *)value = 0u;
      free(value);
      return 0;
    }
    v13 = 4294955051;
  }
  else
  {
    v13 = 4294955056;
  }
  return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
}

uint64_t FigRPCLookupClientConnection(uint64_t a1, void *key, _QWORD *a3)
{
  uint64_t v5;
  const void *Value;
  uint64_t v7;

  v5 = 4294955056;
  if (!a1 || !a3 || ((_DWORD)key + 1) < 2)
    goto LABEL_8;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), (const void *)key);
  if (!Value)
  {
    v5 = 4294955051;
LABEL_8:
    v7 = FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
    Value = 0;
    goto LABEL_6;
  }
  v7 = 0;
LABEL_6:
  *a3 = Value;
  return v7;
}

uint64_t FigRPCGetConnectionInfo(uint64_t a1, _DWORD *a2, _QWORD *a3, _QWORD *a4)
{
  CFTypeRef v5;

  if (!a1)
    return FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
  if (a2)
    *a2 = *(_DWORD *)(a1 + 8);
  if (a3)
    *a3 = *(_QWORD *)(a1 + 40);
  if (a4)
  {
    v5 = *(CFTypeRef *)(a1 + 24);
    if (v5)
      v5 = CFRetain(v5);
    *a4 = v5;
  }
  return 0;
}

uint64_t FigRPCRetainServedObjectOfConnection(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v3;
  uint64_t v4;
  _QWORD v6[8];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  if (a1 && a2 && a3)
  {
    v3 = *(NSObject **)(a1 + 16);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __FigRPCRetainServedObjectOfConnection_block_invoke;
    v6[3] = &unk_1E28E2EF8;
    v6[6] = a2;
    v6[7] = a3;
    v6[4] = &v7;
    v6[5] = a1;
    dispatch_sync(v3, v6);
    v4 = *((unsigned int *)v8 + 6);
  }
  else
  {
    v4 = FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
    *((_DWORD *)v8 + 6) = v4;
  }
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t FigRPCExecuteByServerSync(uint64_t a1, void *a2)
{
  if (!a1 || !a2)
    return FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
  dispatch_sync(*(dispatch_queue_t *)(a1 + 16), a2);
  return 0;
}

uint64_t FigRPCExecuteByServerAsync(uint64_t a1, void *a2)
{
  if (!a1 || !a2)
    return FigSignalErrorAt(4294955056, 0, 0, 0, 0, 0, 0);
  dispatch_async(*(dispatch_queue_t *)(a1 + 16), a2);
  return 0;
}

void __figrpc_createRPCTimeoutDetector_block_invoke(uint64_t a1)
{
  id *v2;
  uint64_t v3;
  void *context;
  uint64_t v5;
  pid_t v6;
  void (*v7)(void *, char *, uint64_t);
  uint64_t v8;
  const char *v9;
  pid_t v10;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v12;
  uint64_t v13;
  unsigned int v14;
  char *v15;
  os_log_type_t type;
  int v17[2];
  const char *v18;
  __int16 v19;
  char *v20;
  char v21;
  char buffer[128];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  _BYTE v47[19];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  _BYTE v53[29];
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v2 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 32));
  v3 = *(_QWORD *)(a1 + 40);
  context = dispatch_get_context(*(dispatch_object_t *)(v3 + 16));
  if (v2)
  {
    if (*(_BYTE *)(v3 + 544))
    {
      v7 = *(void (**)(void *, char *, uint64_t))(*(_QWORD *)(a1 + 48) + 120);
      if (v7)
      {
        v7(context, buffer, 256);
        strnlen((const char *)v2 + 25, 0x200uLL);
        __strncat_chk();
      }
      v8 = *((unsigned int *)v2 + 135);
      v9 = (char *)v2 + 25;
      FigRPCServer_TimeoutCrashReport(v8, v9);
      v10 = getpid();
      memset(v53, 0, sizeof(v53));
      v52 = 0u;
      v51 = 0u;
      v50 = 0u;
      v49 = 0u;
      v48 = 0u;
      *(_OWORD *)&v47[3] = 0u;
      memset(v47, 63, 3);
      v45 = 0u;
      v46 = 0u;
      v43 = 0u;
      v44 = 0u;
      v41 = 0u;
      v42 = 0u;
      v39 = 0u;
      v40 = 0u;
      v37 = 0u;
      v38 = 0u;
      v35 = 0u;
      v36 = 0u;
      v33 = 0u;
      v34 = 0u;
      v31 = 0u;
      v32 = 0u;
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      v25 = 0u;
      v26 = 0u;
      v23 = 0u;
      v24 = 0u;
      memset(buffer, 0, sizeof(buffer));
      proc_name(v10, v47, 0x80u);
      snprintf(buffer, 0x200uLL, "%s: Self-aborting on connection death timeout with reason: %s", v47, v9);
      v17[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FC0, 0, v17, &type);
      v12 = v17[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v14 = v12;
      else
        v14 = v12 & 0xFFFFFFFE;
      if (v14)
      {
        v17[1] = 136315394;
        v18 = "figrpc_selfAbortDueToTimeout";
        v19 = 2082;
        v20 = buffer;
        v15 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v12) = v17[0];
      }
      else
      {
        v15 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FC0, 0, 1, v15, v15 != &v21, v12, 0, v13);
      qword_1EE140448 = (uint64_t)buffer;
      abort();
    }
    v5 = *((unsigned int *)v2 + 135);
    v6 = getpid();
    memset(&buffer[3], 0, 125);
    memset(buffer, 63, 3);
    *(_QWORD *)v47 = 0;
    proc_name(v6, buffer, 0x80u);
    FigServer_CopyProcessName(v5, (CFStringRef *)v47);
    FigRPCServer_TimeoutCrashReport(v5, (const char *)v2 + 25);
    if (*(_QWORD *)v47)
      CFRelease(*(CFTypeRef *)v47);
    kill(v6, 9);
    CFRelease(v2);
  }
}

void __figrpc_createRPCTimeoutDetector_block_invoke_2(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

void figRPCTimeoutDetector_Init(uint64_t a1)
{
  bzero((void *)(a1 + 16), 0x228uLL);
}

void figRPCTimeoutDetector_Finalize(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;

  v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_source_cancel(v2);
    v3 = *(NSObject **)(a1 + 16);
    if (v3)
    {
      dispatch_release(v3);
      *(_QWORD *)(a1 + 16) = 0;
    }
  }
  *(_BYTE *)(a1 + 25) = 0;
}

dispatch_queue_t __figrpc_getCommonServerTimeoutQueue_block_invoke()
{
  dispatch_queue_t result;

  result = dispatch_queue_create("FigRPCServerCommonTimeoutQueue", 0);
  figrpc_getCommonServerTimeoutQueue_commonServerTimeoutQueue = (uint64_t)result;
  return result;
}

void __figRPCTimeoutDetector_unsetTimer_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  void (*v4)(void);

  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 25) = 0;
  v2 = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(v2 + 540) = 0;
  v3 = *(NSObject **)(v2 + 16);
  if (dispatch_get_context(v3))
  {
    v4 = *(void (**)(void))(*(_QWORD *)(v2 + 560) + 112);
    if (v4)
    {
      v4();
      v3 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 16);
    }
    dispatch_set_context(v3, 0);
  }
}

void __figrpc_createClientCommon_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  CFTypeRef v4;
  char v5;
  NSObject *v6;
  mach_msg_header_t *msg;

  switch(a2)
  {
    case 8:
      v6 = *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v6)
        dispatch_release(v6);
      break;
    case 7:
      FigMachPortReleaseReceiveRight_(*(_DWORD *)(a1 + 48), 0, 0, 0, 0);
      if (*(_BYTE *)(a1 + 52))
        FigMachPortReleaseSendRight_(*(_DWORD *)(a1 + 48), 0, 0, 0, 0);
      break;
    case 2:
      v3 = *(_QWORD *)(a1 + 40);
      if (*(_QWORD *)(v3 + 112) && (v4 = CFRetain(*(CFTypeRef *)(v3 + 112))) != 0)
      {
        figRPCTimeoutDetector_setTimer((uint64_t)v4, ***(const char ****)(a1 + 40), *(_DWORD *)(*(_QWORD *)(a1 + 40) + 16));
        v5 = dispatch_mach_mig_demux();
        figRPCTimeoutDetector_unsetTimer((uint64_t)v4);
        CFRelease(v4);
        if ((v5 & 1) == 0)
          goto LABEL_14;
      }
      else if ((dispatch_mach_mig_demux() & 1) == 0)
      {
LABEL_14:
        msg = (mach_msg_header_t *)dispatch_mach_msg_get_msg();
        mach_msg_destroy(msg);
      }
      break;
  }
}

void __figrpc_createClientCommon_block_invoke_2(uint64_t a1)
{
  FigMachPortReleaseReceiveRight_(*(_DWORD *)(a1 + 40), 0, 0, 0, 0);
  if (*(_BYTE *)(a1 + 44))
    FigMachPortReleaseSendRight_(*(_DWORD *)(a1 + 40), 0, 0, 0, 0);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

uint64_t __figrpc_createClientCommon_block_invoke_3()
{
  return dispatch_mig_server();
}

void __figrpc_createClientCommon_block_invoke_4(uint64_t a1)
{
  FigMachPortReleaseSendRight_(*(_DWORD *)(a1 + 40), 0, 0, 0, 0);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void __figrpc_createClientCommon_block_invoke_5(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  _DWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  const char *CStringPtrMaybeUsingPreallocatedBuffer;
  uint64_t (*v10)(uint64_t);
  void *v11;
  NSObject *v12;
  dispatch_time_t v13;
  CFTypeRef cf;
  _OWORD v15[8];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(const void **)(v2 + 96);
  if (!v3)
    goto LABEL_11;
  v4 = CFRetain(v3);
  if (!v4)
  {
    v2 = *(_QWORD *)(a1 + 32);
LABEL_11:
    (*(void (**)(_QWORD))(v2 + 72))(*(unsigned int *)(a1 + 52));
    goto LABEL_12;
  }
  v5 = (uint64_t)v4;
  v6 = *(unsigned int *)(a1 + 52);
  if (*((_QWORD *)v4 + 2))
  {
    v7 = *(unsigned int *)(a1 + 48);
    v8 = **(const char ***)(a1 + 32);
    v4[135] = v7;
    *((_BYTE *)v4 + 544) = 1;
    cf = 0;
    memset(v15, 0, sizeof(v15));
    FigServer_CopyProcessName(v7, (CFStringRef *)&cf);
    CStringPtrMaybeUsingPreallocatedBuffer = FigCFStringGetCStringPtrMaybeUsingPreallocatedBuffer((const char *)cf, (char *)v15, 128, 0x600u);
    snprintf((char *)(v5 + 25), 0x200uLL, "(%s:ConnectionDeath: %s PID:%d) ", v8, CStringPtrMaybeUsingPreallocatedBuffer, v7);
    if (cf)
      CFRelease(cf);
    v10 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v5 + 560) + 104);
    if (v10)
    {
      v11 = (void *)v10(v6);
      dispatch_set_context(*(dispatch_object_t *)(v5 + 16), v11);
    }
    v12 = *(NSObject **)(v5 + 16);
    v13 = dispatch_time(0, 30000000000);
    dispatch_source_set_timer(v12, v13, 0xFFFFFFFFFFFFFFFFLL, 0x1DCD6500uLL);
    *(_BYTE *)(v5 + 24) = 1;
    v6 = *(unsigned int *)(a1 + 52);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 72))(v6);
  figRPCTimeoutDetector_unsetTimer(v5);
  CFRelease((CFTypeRef)v5);
LABEL_12:
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
}

uint64_t __figrpc_enqueueNotificationInternal_block_invoke(uint64_t result)
{
  **(_QWORD **)(result + 40) = 0;
  **(_QWORD **)(*(_QWORD *)(result + 48) + 88) = *(_QWORD *)(result + 40);
  *(_QWORD *)(*(_QWORD *)(result + 48) + 88) = *(_QWORD *)(result + 40);
  if (!*(_BYTE *)(*(_QWORD *)(result + 48) + 96))
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
    *(_BYTE *)(*(_QWORD *)(result + 48) + 96) = 1;
  }
  return result;
}

uint64_t *__figrpc_cancelQueuedNotifications_block_invoke(uint64_t a1)
{
  uint64_t i;
  uint64_t *result;
  uint64_t v4;

  for (i = *(_QWORD *)(a1 + 32); ; i = *(_QWORD *)(a1 + 32))
  {
    result = *(uint64_t **)(i + 80);
    if (!result)
      break;
    v4 = *result;
    *(_QWORD *)(i + 80) = *result;
    if (!v4)
    {
      *(_QWORD *)(i + 88) = i + 80;
      *(_BYTE *)(i + 96) = 0;
    }
    figrpc_freeQueuedNotification(result);
  }
  return result;
}

CFIndex FigRemote_CreateVMBufferFromPropertyList(CFTypeRef a1, vm_address_t *a2, _DWORD *a3)
{
  CFIndex CFDataFromCFPropertyList;
  CFIndex v6;
  CFTypeRef cf;

  cf = 0;
  if (a1)
  {
    CFDataFromCFPropertyList = FigCreateCFDataFromCFPropertyList(a1, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFDataRef *)&cf);
    if ((_DWORD)CFDataFromCFPropertyList)
      goto LABEL_5;
    a1 = cf;
  }
  CFDataFromCFPropertyList = FigRemote_CreateVMBufferFromBinaryPListData((const __CFData *)a1, a2, a3);
LABEL_5:
  v6 = CFDataFromCFPropertyList;
  if (cf)
    CFRelease(cf);
  return v6;
}

uint64_t FigRemote_CreateVMBufferFromBinaryPListData(const __CFData *a1, vm_address_t *a2, _DWORD *a3)
{
  vm_size_t Length;
  size_t v7;
  uint64_t result;
  void *v9;
  const UInt8 *BytePtr;

  if (a1 && (Length = CFDataGetLength(a1)) != 0)
  {
    v7 = Length;
    result = vm_allocate(*MEMORY[0x1E0C83DA0], a2, Length, 1560281089);
    if ((_DWORD)result)
      return result;
    v9 = (void *)*a2;
    BytePtr = CFDataGetBytePtr(a1);
    memcpy(v9, BytePtr, v7);
  }
  else
  {
    LODWORD(v7) = 0;
    *a2 = 0;
  }
  result = 0;
  *a3 = v7;
  return result;
}

uint64_t FigRemote_CreateSerializableDictionaryForFormatDescription(const __CFAllocator *a1, CMFormatDescriptionRef desc, CFDictionaryRef *a3)
{
  CFIndex v3;
  signed int MediaType;
  uint64_t v7;
  const __CFString *v8;
  uint64_t v9;
  int v10;
  CFStringEncoding SystemEncoding;
  uint64_t v12;
  uint64_t DataPointer;
  CFDictionaryRef v14;
  void **p_values;
  char *dataPointerOut;
  size_t totalLengthOut;
  CMBlockBufferRef blockBufferOut;
  CMMediaType valuePtr;
  void *values;
  CFNumberRef v22;
  CFTypeRef v23;
  void *keys;
  const __CFString *v25;
  const __CFString *v26;
  uint64_t v27;

  v3 = (CFIndex)desc;
  v27 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  totalLengthOut = 0;
  blockBufferOut = 0;
  dataPointerOut = 0;
  keys = 0;
  v25 = 0;
  v26 = 0;
  values = 0;
  v22 = 0;
  v23 = 0;
  if (!desc)
  {
    v12 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v8 = 0;
    goto LABEL_47;
  }
  if (!a3)
  {
    v12 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v8 = 0;
    goto LABEL_61;
  }
  MediaType = CMFormatDescriptionGetMediaType(desc);
  if (MediaType <= 1935832171)
  {
    if (MediaType <= 1835365472)
    {
      if (MediaType != 1635088502)
      {
        if (MediaType == 1668047728)
        {
          v7 = CMClosedCaptionFormatDescriptionCopyAsBigEndianClosedCaptionDescriptionBlockBuffer(a1, (CMClosedCaptionFormatDescriptionRef)v3, 0, &blockBufferOut);
          goto LABEL_37;
        }
        if (MediaType == 1751216244)
        {
          v7 = CMHapticFormatDescriptionCopyAsBigEndianHapticDescriptionBlockBuffer(a1, (CFTypeRef)v3, 0, &blockBufferOut);
LABEL_37:
          v12 = v7;
          v8 = 0;
          goto LABEL_38;
        }
LABEL_36:
        v7 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
        goto LABEL_37;
      }
      goto LABEL_24;
    }
    if (MediaType == 1835365473)
    {
      v7 = CMMetadataFormatDescriptionCopyAsBigEndianMetadataDescriptionBlockBuffer(a1, (CMMetadataFormatDescriptionRef)v3, 0, &blockBufferOut);
      goto LABEL_37;
    }
    if (MediaType == 1885564004)
    {
      v7 = CMPointCloudFormatDescriptionCopyAsBigEndianPointCloudDescriptionBlockBuffer(a1, (CFTypeRef)v3, 0, &blockBufferOut);
      goto LABEL_37;
    }
    v10 = 1885954932;
LABEL_23:
    if (MediaType != v10)
      goto LABEL_36;
LABEL_24:
    if (CMFormatDescriptionGetExtension((CMFormatDescriptionRef)v3, CFSTR("VerbatimISOSampleEntry")))
      v8 = CFSTR("ISOFamily");
    else
      v8 = 0;
    SystemEncoding = CFStringGetSystemEncoding();
    v9 = CMVideoFormatDescriptionCopyAsBigEndianImageDescriptionBlockBuffer(a1, (CMVideoFormatDescriptionRef)v3, SystemEncoding, v8, &blockBufferOut);
    goto LABEL_28;
  }
  if (MediaType > 1952807027)
  {
    if (MediaType != 1952807028)
    {
      if (MediaType == 1953325924)
      {
        v7 = CMTimeCodeFormatDescriptionCopyAsBigEndianTimeCodeDescriptionBlockBuffer(a1, (CMTimeCodeFormatDescriptionRef)v3, 0, &blockBufferOut);
        goto LABEL_37;
      }
      v10 = 1986618469;
      goto LABEL_23;
    }
LABEL_30:
    v7 = CMTextFormatDescriptionCopyAsBigEndianTextDescriptionBlockBuffer(a1, (CMTextFormatDescriptionRef)v3, 0, &blockBufferOut);
    goto LABEL_37;
  }
  if (MediaType == 1935832172)
    goto LABEL_30;
  if (MediaType == 1935893870)
  {
    v7 = CMSceneFormatDescriptionCopyAsBigEndianSceneDescriptionBlockBuffer(a1, (CFTypeRef)v3, 0, &blockBufferOut);
    goto LABEL_37;
  }
  if (MediaType != 1936684398)
    goto LABEL_36;
  if (CMFormatDescriptionGetExtension((CMFormatDescriptionRef)v3, CFSTR("VerbatimISOSampleEntry")))
    v8 = CFSTR("ISOFamily");
  else
    v8 = 0;
  v9 = CMAudioFormatDescriptionCopyAsBigEndianSoundDescriptionBlockBuffer(a1, (CMAudioFormatDescriptionRef)v3, v8, &blockBufferOut);
LABEL_28:
  v12 = v9;
  if (v8)
    v8 = (const __CFString *)CFRetain(v8);
LABEL_38:
  if ((_DWORD)v12)
  {
LABEL_61:
    v3 = 0;
    goto LABEL_47;
  }
  DataPointer = CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, &totalLengthOut, &dataPointerOut);
  if ((_DWORD)DataPointer)
  {
LABEL_60:
    v12 = DataPointer;
    goto LABEL_61;
  }
  values = CFDataCreate(a1, (const UInt8 *)dataPointerOut, totalLengthOut);
  if (!values)
  {
    DataPointer = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    goto LABEL_60;
  }
  keys = CFSTR("FormatDescriptionData");
  valuePtr = CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)v3);
  v22 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  if (v22)
  {
    v25 = CFSTR("MediaType");
    if (v8)
    {
      v23 = CFRetain(v8);
      v26 = CFSTR("SampleDescriptionFlavor");
      v3 = 3;
    }
    else
    {
      v3 = 2;
    }
    v14 = CFDictionaryCreate(a1, (const void **)&keys, (const void **)&values, v3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v14)
    {
      v12 = 0;
      *a3 = v14;
    }
    else
    {
      v12 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    v12 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    v3 = 1;
  }
LABEL_47:
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  if (v8)
    CFRelease(v8);
  if (v3)
  {
    p_values = &values;
    do
    {
      if (*p_values)
        CFRelease(*p_values);
      ++p_values;
      --v3;
    }
    while (v3);
  }
  return v12;
}

uint64_t FigRemote_CreateFormatDescriptionFromSerializedDictionary(const __CFAllocator *a1, CFDictionaryRef theDict, CFTypeRef *a3)
{
  const __CFNumber *Value;
  const __CFData *v7;
  const __CFData *v8;
  const __CFString *v9;
  signed int v10;
  uint8_t *BytePtr;
  size_t Length;
  uint64_t v13;
  int v14;
  CFStringEncoding SystemEncoding;
  uint64_t v16;
  CFTypeRef cf;
  signed int valuePtr;

  valuePtr = 0;
  cf = 0;
  if (theDict)
  {
    if (a3)
    {
      Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("MediaType"));
      if (Value)
      {
        CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
        v7 = (const __CFData *)CFDictionaryGetValue(theDict, CFSTR("FormatDescriptionData"));
        if (!v7)
          return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
        v8 = v7;
        v9 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("SampleDescriptionFlavor"));
        v10 = valuePtr;
        BytePtr = (uint8_t *)CFDataGetBytePtr(v8);
        Length = CFDataGetLength(v8);
        if (v10 <= 1935832171)
        {
          if (v10 <= 1835365472)
          {
            if (v10 != 1635088502)
            {
              if (v10 == 1668047728)
              {
                v13 = CMClosedCaptionFormatDescriptionCreateFromBigEndianClosedCaptionDescriptionData(a1, BytePtr, Length, v9, (CMClosedCaptionFormatDescriptionRef *)&cf);
                goto LABEL_31;
              }
              if (v10 == 1751216244)
              {
                v13 = CMHapticFormatDescriptionCreateFromBigEndianHapticDescriptionData(a1, (unsigned int *)BytePtr, Length, (int)v9, (CMFormatDescriptionRef *)&cf);
                goto LABEL_31;
              }
              goto LABEL_30;
            }
            goto LABEL_23;
          }
          if (v10 == 1835365473)
          {
            v13 = CMMetadataFormatDescriptionCreateFromBigEndianMetadataDescriptionData(a1, BytePtr, Length, v9, (CMMetadataFormatDescriptionRef *)&cf);
            goto LABEL_31;
          }
          if (v10 == 1885564004)
          {
            v13 = CMPointCloudFormatDescriptionCreateFromBigEndianPointCloudDescriptionData(a1, (unsigned int *)BytePtr, Length, 0x70636C64u, (CMFormatDescriptionRef *)&cf);
            goto LABEL_31;
          }
          v14 = 1885954932;
LABEL_22:
          if (v10 != v14)
          {
LABEL_30:
            v13 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
LABEL_31:
            v16 = v13;
            if ((_DWORD)v13)
            {
              if (cf)
                CFRelease(cf);
            }
            else
            {
              *a3 = cf;
            }
            return v16;
          }
LABEL_23:
          SystemEncoding = CFStringGetSystemEncoding();
          v13 = CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionData(a1, BytePtr, Length, SystemEncoding, v9, (CMVideoFormatDescriptionRef *)&cf);
          goto LABEL_31;
        }
        if (v10 > 1952807027)
        {
          if (v10 != 1952807028)
          {
            if (v10 == 1953325924)
            {
              v13 = CMTimeCodeFormatDescriptionCreateFromBigEndianTimeCodeDescriptionData(a1, BytePtr, Length, v9, (CMTimeCodeFormatDescriptionRef *)&cf);
              goto LABEL_31;
            }
            v14 = 1986618469;
            goto LABEL_22;
          }
        }
        else if (v10 != 1935832172)
        {
          if (v10 == 1935893870)
          {
            v13 = CMSceneFormatDescriptionCreateFromBigEndianSceneDescriptionData(a1, (unsigned int *)BytePtr, Length, (int)v9, (CMFormatDescriptionRef *)&cf);
            goto LABEL_31;
          }
          if (v10 == 1936684398)
          {
            v13 = CMAudioFormatDescriptionCreateFromBigEndianSoundDescriptionData(a1, BytePtr, Length, v9, (CMAudioFormatDescriptionRef *)&cf);
            goto LABEL_31;
          }
          goto LABEL_30;
        }
        v13 = CMTextFormatDescriptionCreateFromBigEndianTextDescriptionData(a1, BytePtr, Length, v9, v10, (CMTextFormatDescriptionRef *)&cf);
        goto LABEL_31;
      }
    }
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigRemote_CreatePListFromFormatDescriptionCollection(const __CFAllocator *a1, CFTypeRef cf, CFArrayRef *a3)
{
  CFTypeID v6;
  CFIndex Count;
  const void **v8;
  const void **v9;
  const void **v10;
  CMFormatDescriptionRef *v11;
  CFDictionaryRef *v12;
  CFIndex v13;
  uint64_t SerializableDictionaryForFormatDescription;
  CFArrayRef v15;
  uint64_t v16;
  uint64_t i;
  const void *v18;
  CFArrayRef *v20;
  CFRange v21;

  if (!cf)
    goto LABEL_15;
  v6 = CFGetTypeID(cf);
  if (v6 == CFArrayGetTypeID())
  {
    v20 = a3;
    Count = CFArrayGetCount((CFArrayRef)cf);
    v8 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    v9 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    v21.location = 0;
    v21.length = Count;
    CFArrayGetValues((CFArrayRef)cf, v21, v8);
    v10 = 0;
    goto LABEL_6;
  }
  if (v6 != CFDictionaryGetTypeID())
  {
LABEL_15:
    v16 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v9 = 0;
    v8 = 0;
    v10 = 0;
    goto LABEL_22;
  }
  v20 = a3;
  Count = CFDictionaryGetCount((CFDictionaryRef)cf);
  v10 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
  v8 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
  v9 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
  CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, v10, v8);
LABEL_6:
  if (Count >= 1)
  {
    v11 = (CMFormatDescriptionRef *)v8;
    v12 = (CFDictionaryRef *)v9;
    v13 = Count;
    while (1)
    {
      SerializableDictionaryForFormatDescription = FigRemote_CreateSerializableDictionaryForFormatDescription(a1, *v11, v12);
      if ((_DWORD)SerializableDictionaryForFormatDescription)
        break;
      ++v12;
      ++v11;
      if (!--v13)
        goto LABEL_10;
    }
    v16 = SerializableDictionaryForFormatDescription;
    goto LABEL_17;
  }
LABEL_10:
  if (v6 == CFArrayGetTypeID())
  {
    v15 = CFArrayCreate(a1, v9, Count, MEMORY[0x1E0C9B378]);
LABEL_14:
    v16 = 0;
    *v20 = v15;
    goto LABEL_17;
  }
  if (v6 == CFDictionaryGetTypeID())
  {
    v15 = CFDictionaryCreate(a1, v10, v9, Count, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    goto LABEL_14;
  }
  v16 = 0;
LABEL_17:
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      v18 = v9[i];
      if (v18)
        CFRelease(v18);
    }
  }
LABEL_22:
  free(v10);
  free(v8);
  free(v9);
  return v16;
}

uint64_t FigRemote_CreateFormatDescriptionCollectionFromPList(const __CFAllocator *a1, CFTypeRef cf, CFArrayRef *a3)
{
  CFTypeID v6;
  CFIndex Count;
  const void **v8;
  const void **v9;
  const void **v10;
  CFDictionaryRef *v11;
  CFTypeRef *v12;
  CFIndex v13;
  uint64_t FormatDescriptionFromSerializedDictionary;
  CFArrayRef v15;
  uint64_t v16;
  uint64_t i;
  const void *v18;
  CFArrayRef *v20;
  CFRange v21;

  v6 = CFGetTypeID(cf);
  if (v6 == CFArrayGetTypeID())
  {
    v20 = a3;
    Count = CFArrayGetCount((CFArrayRef)cf);
    v8 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    v9 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    v21.location = 0;
    v21.length = Count;
    CFArrayGetValues((CFArrayRef)cf, v21, v8);
    v10 = 0;
  }
  else
  {
    if (v6 != CFDictionaryGetTypeID())
    {
      v16 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      v9 = 0;
      v8 = 0;
      v10 = 0;
      goto LABEL_21;
    }
    v20 = a3;
    Count = CFDictionaryGetCount((CFDictionaryRef)cf);
    v10 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    v8 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    v9 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    CFDictionaryGetKeysAndValues((CFDictionaryRef)cf, v10, v8);
  }
  if (Count >= 1)
  {
    v11 = (CFDictionaryRef *)v8;
    v12 = v9;
    v13 = Count;
    while (1)
    {
      FormatDescriptionFromSerializedDictionary = FigRemote_CreateFormatDescriptionFromSerializedDictionary(a1, *v11, v12);
      if ((_DWORD)FormatDescriptionFromSerializedDictionary)
        break;
      ++v12;
      ++v11;
      if (!--v13)
        goto LABEL_9;
    }
    v16 = FormatDescriptionFromSerializedDictionary;
    goto LABEL_16;
  }
LABEL_9:
  if (v6 == CFArrayGetTypeID())
  {
    v15 = CFArrayCreate(a1, v9, Count, MEMORY[0x1E0C9B378]);
LABEL_13:
    v16 = 0;
    *v20 = v15;
    goto LABEL_16;
  }
  if (v6 == CFDictionaryGetTypeID())
  {
    v15 = CFDictionaryCreate(a1, v10, v9, Count, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    goto LABEL_13;
  }
  v16 = 0;
LABEL_16:
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      v18 = v9[i];
      if (v18)
        CFRelease(v18);
    }
  }
LABEL_21:
  free(v10);
  free(v8);
  free(v9);
  return v16;
}

uint64_t FigServer_GetEnvironment()
{
  return gServerEnvironment;
}

const __CFString *FigServer_GetEnvironmentName()
{
  if (gServerEnvironment > 0xA)
    return CFSTR("Unknown");
  else
    return off_1E28E33A8[gServerEnvironment];
}

void FigServer_InitializeWithEnvironment(int a1)
{
  _QWORD block[4];
  int v2;

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigServer_InitializeWithEnvironment_block_invoke;
  block[3] = &__block_descriptor_tmp_52;
  v2 = a1;
  if (FigServer_InitializeWithEnvironment_once != -1)
    dispatch_once(&FigServer_InitializeWithEnvironment_once, block);
}

void FigServer_Initialize()
{
  FigServer_InitializeWithEnvironment(10);
}

void FigCommonMediaProcessInitialization(int a1)
{
  if (a1 == 10)
  {
    if (in_audio_mx_server_process() && _os_feature_enabled_impl())
    {
      FigServer_InitializeWithEnvironment(6);
      goto LABEL_12;
    }
    FigServer_InitializeWithEnvironment(10);
  }
  else
  {
    FigServer_InitializeWithEnvironment(a1);
    if (a1 == 6)
      goto LABEL_12;
  }
  if (feServer_SetupTERMSignalHandler_onceToken != -1)
    dispatch_once(&feServer_SetupTERMSignalHandler_onceToken, &__block_literal_global_40);
  if ((a1 & 0xFFFFFFFE) == 2)
    gFigServer_AllowProcName = 1;
LABEL_12:
  signal(30, (void (__cdecl *)(int))1);
  signal(31, (void (__cdecl *)(int))1);
  FigNote_OneTimeInitializationForMediaServerd();
  FigSysdiagnoseBlock_OneTimeInitializationForMediaserverd();
  FigKTraceInit();
}

uint64_t FigServer_SetAllowProcName(uint64_t result)
{
  gFigServer_AllowProcName = result;
  return result;
}

BOOL FigServer_IsServerProcess()
{
  if (checkFigRemotePrivTrace_onceToken != -1)
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_38);
  return gServerEnvironment != 0;
}

BOOL FigServer_ShouldLogFigErrorsAsErrorsInThisProcess()
{
  return gServerEnvironment != 0;
}

BOOL FigServer_IsMediaserverd()
{
  if (checkFigRemotePrivTrace_onceToken != -1)
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_38);
  return gServerEnvironment == 1;
}

BOOL FigServer_IsMediaparserd()
{
  if (checkFigRemotePrivTrace_onceToken != -1)
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_38);
  return gServerEnvironment == 3;
}

uint64_t FigRemote_ShouldConnectToMediaparserdForFileParsing()
{
  return 1;
}

uint64_t FigRemote_ShouldConnectToMediaparserdFile_OptIn()
{
  return 1;
}

BOOL FigServer_IsVideocodecd()
{
  if (checkFigRemotePrivTrace_onceToken != -1)
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_38);
  return gServerEnvironment == 4;
}

BOOL FigServer_IsVideoDecodeService()
{
  if (checkFigRemotePrivTrace_onceToken != -1)
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_38);
  return gServerEnvironment == 5;
}

BOOL FigServer_IsCameracaptured()
{
  if (checkFigRemotePrivTrace_onceToken != -1)
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_38);
  return gServerEnvironment == 7;
}

BOOL FigServer_IsMediaplaybackd()
{
  if (checkFigRemotePrivTrace_onceToken != -1)
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_38);
  return gServerEnvironment == 2;
}

uint64_t FigRemote_ShouldConnectToMediaplaybackd()
{
  return 1;
}

uint64_t FigRemote_ShouldConnectToAirplayd()
{
  return 1;
}

BOOL FigServer_IsAirplayd()
{
  if (checkFigRemotePrivTrace_onceToken != -1)
    dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_38);
  return gServerEnvironment == 8;
}

BOOL FigServer_IsWritableFileOpeningOrCreationPermittedForAuditToken(__int128 *a1, CFURLRef url)
{
  int v4;
  __int128 v5;
  void *v6;
  int v7;
  __int128 v8;
  _BOOL8 v9;
  const __CFURL *PathComponent;
  const __CFURL *v12;
  stat v13;
  __int128 v14;
  __int128 v15;
  UInt8 buffer[1024];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = CFURLStartAccessingSecurityScopedResource(url);
  if (checkFigRemotePrivTrace_onceToken == -1)
  {
    if (url)
      goto LABEL_3;
LABEL_23:
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  dispatch_once(&checkFigRemotePrivTrace_onceToken, &__block_literal_global_38);
  if (!url)
    goto LABEL_23;
LABEL_3:
  v5 = a1[1];
  v14 = *a1;
  v15 = v5;
  bzero(buffer, 0x400uLL);
  if (CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024))
  {
    *(_OWORD *)&v13.st_dev = v14;
    *(_OWORD *)&v13.st_uid = v15;
    if (!sandbox_check_by_audit_token())
    {
LABEL_11:
      v9 = 1;
      if (!v4)
        return v9;
      goto LABEL_15;
    }
  }
  bzero(buffer, 0x400uLL);
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024))
    goto LABEL_14;
  v6 = (void *)sandbox_extension_issue_file_to_self();
  if (!v6)
  {
    v6 = (void *)sandbox_extension_issue_file_to_self();
    if (!v6)
      goto LABEL_14;
  }
  memset(&v13, 0, sizeof(v13));
  *__error() = 0;
  if (!stat((const char *)buffer, &v13))
  {
    free(v6);
    goto LABEL_14;
  }
  v7 = *__error();
  free(v6);
  if (v7 != 2)
    goto LABEL_14;
  v8 = a1[1];
  v14 = *a1;
  v15 = v8;
  bzero(buffer, 0x400uLL);
  if (FigFileIsFileOnExternalStorageDevice(url))
    goto LABEL_11;
  PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x1E0C9AE00], url);
  if (!PathComponent)
  {
LABEL_14:
    v9 = 0;
    if (!v4)
      return v9;
LABEL_15:
    MEMORY[0x193FFB3BC](url);
    return v9;
  }
  v12 = PathComponent;
  if (CFURLGetFileSystemRepresentation(PathComponent, 1u, buffer, 1024))
  {
    *(_OWORD *)&v13.st_dev = v14;
    *(_OWORD *)&v13.st_uid = v15;
    v9 = sandbox_check_by_audit_token() == 0;
  }
  else
  {
    v9 = 0;
  }
  CFRelease(v12);
  if (v4)
    goto LABEL_15;
  return v9;
}

uint64_t FigServer_GetClientPIDFromAuditToken(_OWORD *a1)
{
  __int128 v1;
  audit_token_t atoken;
  pid_t pidp;

  pidp = 0;
  v1 = a1[1];
  *(_OWORD *)atoken.val = *a1;
  *(_OWORD *)&atoken.val[4] = v1;
  audit_token_to_au32(&atoken, 0, 0, 0, 0, 0, &pidp, 0, 0);
  return pidp;
}

uint64_t FigProcessInfoCreateWithDetails(uint64_t a1, int a2, const void *a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  id v9;
  _QWORD *Instance;
  const void *v11;
  uint64_t v12;
  uint64_t v14;

  if (a3)
  {
    if (FigProcessInfoCreateWithDetails_once != -1)
      dispatch_once(&FigProcessInfoCreateWithDetails_once, &__block_literal_global_42);
    if (getProcNameWeakTable_once != -1)
      dispatch_once(&getProcNameWeakTable_once, &__block_literal_global_48);
    v7 = getProcNameWeakTable_weakTable;
    FigSimpleMutexLock((pthread_mutex_t *)FigProcessInfoCreateWithDetails_mutex);
    v8 = a2;
    v9 = FigCFWeakReferenceTableCopyValue(v7, (void *)a2);
    if (v9)
    {
      Instance = v9;
      if (!FigCFEqual(a3, *((CFTypeRef *)v9 + 2)))
      {
        v11 = (const void *)Instance[2];
        Instance[2] = a3;
        CFRetain(a3);
        if (v11)
          CFRelease(v11);
      }
      FigSimpleMutexUnlock((pthread_mutex_t *)FigProcessInfoCreateWithDetails_mutex);
    }
    else
    {
      if (figProcessInfo_GetTypeID_sRegisterFigProcessInfoTypeOnce != -1)
        dispatch_once(&figProcessInfo_GetTypeID_sRegisterFigProcessInfoTypeOnce, &__block_literal_global_51);
      Instance = (_QWORD *)_CFRuntimeCreateInstance();
      if (!Instance)
      {
        v14 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
        if ((_DWORD)v14)
        {
          v12 = v14;
          FigSimpleMutexUnlock((pthread_mutex_t *)FigProcessInfoCreateWithDetails_mutex);
          return v12;
        }
      }
      Instance[2] = CFRetain(a3);
      v12 = FigCFWeakReferenceTableAddValueAssociatedWithKey(v7, (uint64_t)Instance, v8);
      FigSimpleMutexUnlock((pthread_mutex_t *)FigProcessInfoCreateWithDetails_mutex);
      if ((_DWORD)v12)
        goto LABEL_18;
    }
    v12 = 0;
    if (a4)
    {
      *a4 = Instance;
      return v12;
    }
LABEL_18:
    CFRelease(Instance);
    return v12;
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigServer_CopyProcessName(uint64_t a1, CFStringRef *a2)
{
  uint64_t v3;
  id v4;
  const void *v5;
  const void *v6;
  const __CFString *v7;
  _OWORD v9[2];
  char v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  if (!a2)
    return 0;
  v3 = a1;
  if (!(_DWORD)a1)
  {
    *a2 = (CFStringRef)CFRetain(CFSTR("<UNKNOWN>"));
    return v3;
  }
  if (getProcNameWeakTable_once != -1)
    dispatch_once(&getProcNameWeakTable_once, &__block_literal_global_48);
  v4 = FigCFWeakReferenceTableCopyValue(getProcNameWeakTable_weakTable, (void *)(int)v3);
  v5 = v4;
  if (v4)
  {
    v6 = (const void *)*((_QWORD *)v4 + 2);
    if (v6)
    {
      *a2 = (CFStringRef)CFRetain(v6);
      v3 = 1;
      goto LABEL_16;
    }
  }
  if (gFigServer_AllowProcName && proc_name(v3, v9, 0x21u) >= 1)
  {
    v7 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)v9, 0x8000100u);
    v3 = 1;
  }
  else
  {
    FigApplicationStateMonitorCopyProcessNameIfAvailable(v3, a2);
    if (*a2)
    {
      v3 = 0;
      if (!v5)
        return v3;
      goto LABEL_16;
    }
    v7 = (const __CFString *)CFRetain(CFSTR("<UNKNOWN>"));
    v3 = 0;
  }
  *a2 = v7;
  if (v5)
LABEL_16:
    CFRelease(v5);
  return v3;
}

void FigServer_RememberProcessInfoForAFewSeconds(CFTypeRef cf)
{
  dispatch_time_t v2;
  _QWORD block[5];

  if (cf)
  {
    if (FigServer_RememberProcessInfoForAFewSeconds_once != -1)
      dispatch_once(&FigServer_RememberProcessInfoForAFewSeconds_once, &__block_literal_global_34_1);
    CFRetain(cf);
    v2 = dispatch_time(0, 10000000000);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __FigServer_RememberProcessInfoForAFewSeconds_block_invoke_2;
    block[3] = &__block_descriptor_tmp_36_1;
    block[4] = cf;
    dispatch_after(v2, (dispatch_queue_t)FigServer_RememberProcessInfoForAFewSeconds_queue, block);
  }
}

uint64_t __getProcNameWeakTable_block_invoke()
{
  pid_t v0;
  const __CFAllocator *AllocatorForPermanentAllocations;
  uint64_t Instance;
  const __CFAllocator *v3;
  CFStringRef v4;
  uint64_t v5;
  _OWORD v7[2];
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v0 = getpid();
  v8 = 0;
  memset(v7, 0, sizeof(v7));
  AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  FigCFWeakReferenceTableCreate(AllocatorForPermanentAllocations, 1, &getProcNameWeakTable_weakTable);
  FigGetAllocatorForPermanentAllocations();
  if (figProcessInfo_GetTypeID_sRegisterFigProcessInfoTypeOnce != -1)
    dispatch_once(&figProcessInfo_GetTypeID_sRegisterFigProcessInfoTypeOnce, &__block_literal_global_51);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
    getProcNameWeakTable_currentProcessInfo = Instance;
  else
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  proc_name(v0, v7, 0x21u);
  v3 = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  v4 = CFStringCreateWithCString(v3, (const char *)v7, 0x8000100u);
  v5 = getProcNameWeakTable_currentProcessInfo;
  *(_QWORD *)(getProcNameWeakTable_currentProcessInfo + 16) = v4;
  return FigCFWeakReferenceTableAddValueAssociatedWithKey(getProcNameWeakTable_weakTable, v5, v0);
}

uint64_t figProcessInfo_Init(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  return result;
}

void figProcessInfo_Finalize(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

CFTypeRef figProcessInfo_CopyDebugDesc(uint64_t a1)
{
  CFTypeRef result;

  result = *(CFTypeRef *)(a1 + 16);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t FigTransportGetClassID()
{
  if (FigTransportGetClassID_sRegisterOnce != -1)
    dispatch_once_f(&FigTransportGetClassID_sRegisterOnce, &FigTransportGetClassID_sClassID, (dispatch_function_t)transport_getClassID);
  return FigTransportGetClassID_sClassID;
}

uint64_t transport_getClassID(_QWORD *a1)
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&transport_getClassID_sClassDesc, ClassID, 1, a1);
}

uint64_t FigTransportGetTypeID()
{
  if (FigTransportGetClassID_sRegisterOnce != -1)
    dispatch_once_f(&FigTransportGetClassID_sRegisterOnce, &FigTransportGetClassID_sClassID, (dispatch_function_t)transport_getClassID);
  return CMBaseClassGetCFTypeID((_QWORD *)FigTransportGetClassID_sClassID);
}

CFStringRef transport_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigTransport %p]"), a1);
}

uint64_t FigTimelineCoordinatorGetTypeID()
{
  if (FigTimelineCoordinatorGetTypeID_sRegisterFigTimelineCoordinatorTypeOnce != -1)
    dispatch_once_f(&FigTimelineCoordinatorGetTypeID_sRegisterFigTimelineCoordinatorTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinatorType);
  return sFigTimelineCoordinatorID;
}

uint64_t registerFigTimelineCoordinatorType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigTimelineCoordinatorID = result;
  return result;
}

uint64_t FigTimelineCoordinatorMakeHostTimeFromNetworkTimeDictionary(_QWORD *a1, CFDictionaryRef theDict, CMTime *a3)
{
  unsigned int UInt64;
  unint64_t v7;
  uint64_t HostTimeForClockTime;
  uint64_t v10;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v12;
  uint64_t v13;
  unsigned int v14;
  void **v15;
  os_log_type_t type;
  int v17;
  void *v18[2];
  uint64_t v19;
  int v20;
  const char *v21;
  __int16 v22;
  int v23;
  void *value[2];
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (theDict && a3)
  {
    value[0] = 0;
    v18[0] = 0;
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("Seconds"), (const void **)value)
      && CFDictionaryGetValueIfPresent(theDict, CFSTR("Subsecs"), (const void **)v18))
    {
      UInt64 = FigCFNumberGetUInt64((const __CFNumber *)value[0]);
      v7 = UInt64 | ((unint64_t)FigCFNumberGetUInt64((const __CFNumber *)v18[0]) << 32);
    }
    else
    {
      v10 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
      v7 = 0;
      if ((_DWORD)v10)
        return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    }
    v18[0] = 0;
    v18[1] = 0;
    v19 = 0;
    FigTimeOfDayTimeFromNTPTimestamp(v7, (uint64_t)v18);
    *(_OWORD *)value = *(_OWORD *)v18;
    v25 = v19;
    HostTimeForClockTime = CMTimeSyncTimeOfDayClockGetHostTimeForClockTime(a1, (uint64_t)value, a3);
    if ((_DWORD)HostTimeForClockTime)
    {
      v17 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 0, &v17, &type);
      v12 = v17;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v14 = v12;
      else
        v14 = v12 & 0xFFFFFFFE;
      if (v14)
      {
        v20 = 136315394;
        v21 = "FigTimelineCoordinatorMakeHostTimeFromNetworkTimeDictionary";
        v22 = 1024;
        v23 = HostTimeForClockTime;
        v15 = (void **)_os_log_send_and_compose_impl();
        LOBYTE(v12) = v17;
      }
      else
      {
        v15 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 0, 1, v15, v15 != value, v12, 0, v13);
    }
    return HostTimeForClockTime;
  }
  return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

uint64_t FigTimelineCoordinatorCopyNetworkTimeDictionaryForHostTime(_QWORD *a1, CMTime *a2, CFDictionaryRef *a3)
{
  uint64_t ClockTimeForHostTime;
  unint64_t v5;
  unsigned int v6;
  unint64_t v7;
  const __CFAllocator *v8;
  __CFDictionary *Mutable;
  CFNumberRef UInt32;
  CFNumberRef v11;
  CFNumberRef v12;
  BOOL v13;
  CFDictionaryRef Copy;
  uint64_t v16;
  uint64_t v17;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v20;
  uint64_t v21;
  unsigned int v22;
  CMTime *v23;
  os_log_type_t type;
  int v25;
  CMTime v26;
  int v27;
  const char *v28;
  __int16 v29;
  int v30;
  CMTime v31[5];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  memset(&v26, 0, sizeof(v26));
  if (a3)
  {
    v31[0] = *a2;
    ClockTimeForHostTime = CMTimeSyncTimeOfDayClockGetClockTimeForHostTime(a1, (uint64_t)v31, &v26);
    if ((_DWORD)ClockTimeForHostTime)
    {
      v17 = ClockTimeForHostTime;
      v25 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 0, &v25, &type);
      v20 = v25;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v22 = v20;
      else
        v22 = v20 & 0xFFFFFFFE;
      if (v22)
      {
        v27 = 136315394;
        v28 = "FigTimelineCoordinatorCopyNetworkTimeDictionaryForHostTime";
        v29 = 1024;
        v30 = v17;
        v23 = (CMTime *)_os_log_send_and_compose_impl();
        LOBYTE(v20) = v25;
      }
      else
      {
        v23 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 0, 1, v23, v23 != v31, v20, 0, v21);
      return v17;
    }
    v31[0] = v26;
    v5 = FigNTPTimestampFromTimeOfDayTime(v31);
    v6 = v5;
    v7 = HIDWORD(v5);
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    UInt32 = FigCFNumberCreateUInt32(v8, v6);
    v11 = FigCFNumberCreateUInt32(v8, v7);
    v12 = v11;
    if (Mutable)
      v13 = UInt32 == 0;
    else
      v13 = 1;
    if (v13 || v11 == 0)
    {
      v16 = FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
      if (!Mutable)
        goto LABEL_13;
    }
    else
    {
      CFDictionarySetValue(Mutable, CFSTR("Seconds"), UInt32);
      CFDictionarySetValue(Mutable, CFSTR("Subsecs"), v12);
      Copy = CFDictionaryCreateCopy(v8, Mutable);
      *a3 = Copy;
      if (Copy)
        v16 = 0;
      else
        v16 = FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(Mutable);
LABEL_13:
    if (UInt32)
      CFRelease(UInt32);
    if (v12)
      CFRelease(v12);
    if ((_DWORD)v16)
      return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    else
      return 0;
  }
  return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

uint64_t FigTimelineCoordinatorSuspensionGetTypeID()
{
  if (FigTimelineCoordinatorSuspensionGetTypeID_sRegisterFigTimelineCoordinatorSuspensionTypeOnce != -1)
    dispatch_once_f(&FigTimelineCoordinatorSuspensionGetTypeID_sRegisterFigTimelineCoordinatorSuspensionTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinatorSuspensionType);
  return sFigTimelineCoordinatorSuspensionID;
}

uint64_t registerFigTimelineCoordinatorSuspensionType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigTimelineCoordinatorSuspensionID = result;
  return result;
}

CFTypeRef FigTimelineCoordinatorSuspensionCopyReason(uint64_t a1, _QWORD *a2)
{
  CFTypeRef result;

  result = *(CFTypeRef *)(a1 + 16);
  if (result)
    result = CFRetain(result);
  *a2 = result;
  return result;
}

uint64_t FigTimelineCoordinatorSuspensionCreate(uint64_t a1, const void *a2, uint64_t *a3)
{
  uint64_t Instance;
  uint64_t v6;
  uint64_t v8;

  if (a3)
  {
    if (a2)
    {
      if (FigTimelineCoordinatorSuspensionGetTypeID_sRegisterFigTimelineCoordinatorSuspensionTypeOnce != -1)
        dispatch_once_f(&FigTimelineCoordinatorSuspensionGetTypeID_sRegisterFigTimelineCoordinatorSuspensionTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinatorSuspensionType);
      Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        v6 = Instance;
        *(_QWORD *)(Instance + 16) = CFRetain(a2);
        *a3 = v6;
        return 0;
      }
      v8 = 4294951586;
    }
    else
    {
      v8 = 4294951585;
    }
  }
  else
  {
    v8 = 4294951585;
  }
  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigTimelineCoordinatorTimelineStateGetTypeID()
{
  if (FigTimelineCoordinatorTimelineStateGetTypeID_sRegisterFigTimelineCoordinatorTimelineStateTypeOnce != -1)
    dispatch_once_f(&FigTimelineCoordinatorTimelineStateGetTypeID_sRegisterFigTimelineCoordinatorTimelineStateTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinatorTimelineStateType);
  return sFigTimelineCoordinatorTimelineStateID;
}

uint64_t registerFigTimelineCoordinatorTimelineStateType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigTimelineCoordinatorTimelineStateID = result;
  return result;
}

uint64_t FigTimelineCoordinationParticipantSnapshotGetTypeID()
{
  if (FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce != -1)
    dispatch_once_f(&FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinationParticipantSnapshotType);
  return sFigTimelineCoordinationParticipantSnapshotID;
}

uint64_t registerFigTimelineCoordinationParticipantSnapshotType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigTimelineCoordinationParticipantSnapshotID = result;
  return result;
}

uint64_t FigTimelineCoordinationParticipantSnapshotGetUUID(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

const void *FigTimelineCoordinationParticipantSnapshotIsReadyToSetNonZeroRate(uint64_t a1)
{
  uint64_t v2;
  const void *result;
  const void *v4;
  const void *v5;
  Boolean v6;

  v2 = *(_QWORD *)(a1 + 16);
  v6 = 0;
  FigCFDictionaryGetBooleanIfPresent(v2, CFSTR("ReadyToSetNonZeroRate"), &v6);
  if (!v6)
    return 0;
  result = participantState_timelineIdentifier(*(const __CFDictionary **)(a1 + 16));
  if (!result)
    return result;
  if (participantState_isSuspended(*(const __CFDictionary **)(a1 + 16)))
    return 0;
  v4 = *(const void **)(a1 + 24);
  v5 = participantState_timelineIdentifier(*(const __CFDictionary **)(a1 + 16));
  return (const void *)(FigCFEqual(v4, v5) != 0);
}

const void *participantState_timelineIdentifier(const __CFDictionary *a1)
{
  const void *result;
  const void *v2;
  CFTypeID v3;

  result = CFDictionaryGetValue(a1, CFSTR("CurrentIdentifier"));
  if (result)
  {
    v2 = result;
    v3 = CFGetTypeID(result);
    if (v3 == CFStringGetTypeID())
      return v2;
    else
      return 0;
  }
  return result;
}

const __CFArray *participantState_isSuspended(const __CFDictionary *a1)
{
  const __CFArray *result;
  const __CFArray *v2;
  CFTypeID v3;

  result = (const __CFArray *)CFDictionaryGetValue(a1, CFSTR("SuspensionReasons"));
  if (result)
  {
    v2 = result;
    v3 = CFGetTypeID(result);
    if (v3 == CFArrayGetTypeID())
      return (const __CFArray *)(CFArrayGetCount(v2) > 0);
    else
      return 0;
  }
  return result;
}

CFTypeRef FigTimelineCoordinationParticipantSnapshotCopySuspensionReasons(uint64_t a1)
{
  CFMutableArrayRef Mutable;
  const void *Value;
  CFTypeID v4;
  CFIndex v5;
  const void *ValueAtIndex;
  const void *v7;
  CFTypeID v8;
  CFRange v10;
  CFRange v11;

  Mutable = *(CFMutableArrayRef *)(a1 + 40);
  if (Mutable)
    return CFRetain(Mutable);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("SuspensionReasons"));
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (Value)
  {
    v4 = CFGetTypeID(Value);
    if (v4 == CFArrayGetTypeID())
    {
      if (CFArrayGetCount((CFArrayRef)Value) >= 1)
      {
        v5 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)Value, v5);
          if (ValueAtIndex)
          {
            v7 = ValueAtIndex;
            v8 = CFGetTypeID(ValueAtIndex);
            if (v8 == CFStringGetTypeID())
            {
              v10.length = CFArrayGetCount(Mutable);
              v10.location = 0;
              if (!CFArrayContainsValue(Mutable, v10, v7))
                CFArrayAppendValue(Mutable, v7);
            }
          }
          ++v5;
        }
        while (v5 < CFArrayGetCount((CFArrayRef)Value));
      }
      v11.length = CFArrayGetCount(Mutable);
      v11.location = 0;
      CFArraySortValues(Mutable, v11, (CFComparatorFunction)MEMORY[0x1E0C98F10], 0);
    }
  }
  *(_QWORD *)(a1 + 40) = Mutable;
  if (Mutable)
    return CFRetain(Mutable);
  else
    return 0;
}

uint64_t FigTimelineCoordinatorHandleUpdatedTimelineStateFromMedium(uint64_t a1, const void *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;

  if (a2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    v4 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = v4 + 1;
    v5 = malloc_type_malloc(0x18uLL, 0x1060040E60A0C5AuLL);
    *v5 = CFRetain((CFTypeRef)a1);
    v5[1] = CFRetain(a2);
    v5[2] = v4;
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v5, (dispatch_function_t)figTimelineCoordinator_applyRemoteTimelineStateOnQueue);
    v6 = 0;
  }
  else
  {
    v6 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  return v6;
}

void figTimelineCoordinator_applyRemoteTimelineStateOnQueue(uint64_t *a1)
{
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  CFTypeID v5;
  const __CFString *v6;
  const __CFString *v7;
  CFTypeID v8;
  CFTypeID v9;
  int v10;
  const __CFString *v11;
  const __CFString *v12;
  CFTypeID v13;
  uint64_t v14;
  CFUUIDRef v15;
  CFUUIDRef v16;
  int Internal;
  const void *StateLoggingIdentifier;
  CFTypeRef v19;
  uint64_t v20;
  uint64_t v21;
  const void *v22;
  int v23;
  const void *v24;
  char v25;
  char v26;
  float v27;
  __CFString *v28;
  NSObject *v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v32;
  CMTime *v33;
  __CFString *v34;
  NSObject *v35;
  unsigned int v36;
  uint64_t v37;
  unsigned int v38;
  CMTime *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  float v43;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v45;
  uint64_t v46;
  unsigned int v47;
  __CFString *v48;
  CMTime *v49;
  const __CFDictionary *v50;
  const void *v51;
  const void *v52;
  CMTime type;
  CMTime v54;
  char v55;
  int v56;
  unsigned int v57;
  void *value;
  Float64 seconds;
  uint64_t v60;
  CFTypeRef cf;
  CMTime v62;
  __CFString *v63;
  CMTime v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v3 = *a1;
  v2 = (const void *)a1[1];
  v4 = a1[2];
  v60 = 0;
  cf = 0;
  value = 0;
  seconds = 0.0;
  memset(&v64, 0, sizeof(v64));
  memset(&v62, 0, sizeof(v62));
  v56 = -1;
  v57 = 0;
  v55 = 0;
  if (!v2)
    goto LABEL_92;
  v5 = CFGetTypeID(v2);
  if (v5 != CFDictionaryGetTypeID())
    goto LABEL_92;
  v6 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v2, CFSTR("Identifier"));
  if (!v6)
    goto LABEL_92;
  v7 = v6;
  v8 = CFGetTypeID(v6);
  if (v8 != CFStringGetTypeID()
    || !FigCFDictionaryGetFloat32IfPresent((uint64_t)v2, CFSTR("Rate"), (char *)&v60 + 4)
    || !FigCFDictionaryGetDoubleIfPresent((uint64_t)v2, CFSTR("Time"), &seconds))
  {
    goto LABEL_92;
  }
  CMTimeMakeWithSeconds(&v64, seconds, 1000000);
  if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v2, CFSTR("NetworkTime"), (const void **)&value))
  {
    if (value)
    {
      v9 = CFGetTypeID(value);
      if (v9 == CFDictionaryGetTypeID())
      {
        if (FigTimelineCoordinatorMakeHostTimeFromNetworkTimeDictionary(*(_QWORD **)(v3 + 176), (CFDictionaryRef)value, &v62))goto LABEL_87;
      }
    }
  }
  if (FigCFDictionaryGetInt32IfPresent((uint64_t)v2, CFSTR("SeekPrecision"), &v57) && v57 >= 2)
    v57 = 0;
  FigCFDictionaryGetFloat32IfPresent((uint64_t)v2, CFSTR("PrerollRate"), &v60);
  FigCFDictionaryGetBooleanIfPresent((uint64_t)v2, CFSTR("IsAuthoritative"), (Boolean *)&v55);
  if (FigCFDictionaryGetInt32IfPresent((uint64_t)v2, CFSTR("LamportTimestamp"), &v56)
    && v55
    && CFStringCompare(v7, *(CFStringRef *)(v3 + 352), 0) == kCFCompareEqualTo)
  {
    v10 = v56;
    *(_DWORD *)(v3 + 456) = v56;
    FigCFDictionarySetInt32(*(void **)(v3 + 464), *(const void **)(v3 + 352), v10);
  }
  v11 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v2, CFSTR("OriginatorUUID"));
  if (!v11
    || (v12 = v11, v13 = CFGetTypeID(v11), v13 != CFStringGetTypeID())
    || (v14 = *MEMORY[0x1E0C9AE00], (v15 = CFUUIDCreateFromString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v12)) == 0))
  {
LABEL_92:
    FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    goto LABEL_87;
  }
  v16 = v15;
  v54 = v64;
  type = v62;
  Internal = figTimelineCoordinatorTimelineStateCreateInternal(*(float *)&v60, *((float *)&v60 + 1), v14, v7, (__int128 *)&v54.value, (__int128 *)&type.value, v57, v15, v4, v56, v55, 1, (uint64_t *)&cf);
  if (Internal)
  {
    v19 = 0;
  }
  else
  {
    StateLoggingIdentifier = FigTimelineStateDictionaryGetStateLoggingIdentifier((const __CFDictionary *)v2);
    v19 = cf;
    *((_QWORD *)cf + 14) = StateLoggingIdentifier;
    if (StateLoggingIdentifier)
    {
      CFRetain(StateLoggingIdentifier);
      v19 = cf;
    }
    cf = 0;
  }
  CFRelease(v16);
  if (cf)
    CFRelease(cf);
  if (!Internal && v19)
  {
    v20 = *a1;
    v21 = *(_QWORD *)(*a1 + 288);
    if (v21)
    {
      if (FigCFEqual(*(CFTypeRef *)(v21 + 88), *((CFTypeRef *)v19 + 11)))
      {
        v22 = *(const void **)(v20 + 288);
        if (v22)
        {
          CFRelease(v22);
          *(_QWORD *)(v20 + 288) = 0;
        }
      }
    }
    if (FigCFEqual(*(CFTypeRef *)(v20 + 352), *((CFTypeRef *)v19 + 11)))
    {
      LOBYTE(type.value) = 0;
      if (figTimelineCoordinator_newTimelineStateShouldOverrideExistingState(v20, *(_QWORD *)(v20 + 200), (uint64_t)v19))
      {
        v23 = *((_DWORD *)v19 + 25);
        *(_DWORD *)(v20 + 456) = v23;
        FigCFDictionarySetInt32(*(void **)(v20 + 464), *((const void **)v19 + 11), v23);
        v24 = *(const void **)(v20 + 208);
        if (v24)
        {
          CFRelease(v24);
          *(_QWORD *)(v20 + 208) = 0;
        }
        if (*(_QWORD *)(v20 + 224))
        {
          v25 = 0;
          v26 = 0;
          v27 = *((float *)v19 + 9);
        }
        else
        {
          memset(&v64, 0, sizeof(v64));
          CMTimeMake(&v64, 1, 10);
          v40 = *(_QWORD *)(v20 + 200);
          if (v40 && *(float *)(v40 + 36) != 0.0 && *((float *)v19 + 9) == 0.0 && *((_DWORD *)v19 + 24) == 1)
          {
            CMTimeMake(&v62, 5, 1);
            v64 = v62;
          }
          v41 = *(_QWORD *)(v20 + 192);
          v62 = v64;
          figTimelineCoordinator_timelinesMatch((uint64_t)v19, v41, &v62, &type);
          v26 = type.value;
          v27 = *((float *)v19 + 9);
          v25 = *(float *)(*(_QWORD *)(v20 + 192) + 36) == v27;
        }
        if (v27 == 0.0)
          v27 = *((float *)v19 + 8);
        v42 = *(_QWORD *)(v20 + 192);
        v43 = *(float *)(v42 + 36);
        if (v43 == 0.0)
          v43 = *(float *)(v42 + 32);
        figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(v20, (uint64_t)v19, 0, 1, 1, v26, v25, v43 == v27);
        if (!*(_BYTE *)(v20 + 280))
        {
          if (dword_1EE141FE8)
          {
            LODWORD(v54.value) = 0;
            LOBYTE(cf) = 0;
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, (int *)&v54, &cf);
            v45 = v54.value;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, (os_log_type_t)cf))
              v47 = v45;
            else
              v47 = v45 & 0xFFFFFFFE;
            if (v47)
            {
              v48 = (__CFString *)*((_QWORD *)v19 + 11);
              LODWORD(v62.value) = 136315650;
              *(CMTimeValue *)((char *)&v62.value + 4) = (CMTimeValue)"figTimelineCoordinator_applyRemoteTimelineStateOnQueueInternal";
              LOWORD(v62.flags) = 2112;
              *(_QWORD *)((char *)&v62.flags + 2) = v20;
              HIWORD(v62.epoch) = 2114;
              v63 = v48;
              v49 = (CMTime *)_os_log_send_and_compose_impl();
              LOBYTE(v45) = v54.value;
            }
            else
            {
              v49 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v49, v49 != &v64, v45, 0, v46);
          }
          *(_BYTE *)(v20 + 280) = 1;
        }
      }
      else if (dword_1EE141FE8)
      {
        v34 = FigCFCopyCompactDescription((const __CFSet *)v19);
        if (dword_1EE141FE8)
        {
          LODWORD(v54.value) = 0;
          LOBYTE(cf) = 0;
          v35 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, (int *)&v54, &cf);
          v36 = v54.value;
          if (os_log_type_enabled(v35, (os_log_type_t)cf))
            v38 = v36;
          else
            v38 = v36 & 0xFFFFFFFE;
          if (v38)
          {
            LODWORD(v62.value) = 136315650;
            *(CMTimeValue *)((char *)&v62.value + 4) = (CMTimeValue)"figTimelineCoordinator_applyRemoteTimelineStateOnQueueInternal";
            LOWORD(v62.flags) = 2112;
            *(_QWORD *)((char *)&v62.flags + 2) = v20;
            HIWORD(v62.epoch) = 2114;
            v63 = v34;
            v39 = (CMTime *)_os_log_send_and_compose_impl();
            LOBYTE(v36) = v54.value;
          }
          else
          {
            v39 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v39, v39 != &v64, v36, 0, v37);
        }
        if (v34)
          CFRelease(v34);
      }
    }
    else
    {
      if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(v20 + 216), *((const void **)v19 + 11)))
      {
        v28 = FigCFCopyCompactDescription((const __CFSet *)v19);
        if (dword_1EE141FE8)
        {
          LODWORD(v54.value) = 0;
          LOBYTE(type.value) = 0;
          v29 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, (int *)&v54, &type);
          v30 = v54.value;
          if (os_log_type_enabled(v29, type.value))
            v32 = v30;
          else
            v32 = v30 & 0xFFFFFFFE;
          if (v32)
          {
            LODWORD(v62.value) = 136315650;
            *(CMTimeValue *)((char *)&v62.value + 4) = (CMTimeValue)"figTimelineCoordinator_applyRemoteTimelineStateOnQueueInternal";
            LOWORD(v62.flags) = 2112;
            *(_QWORD *)((char *)&v62.flags + 2) = v20;
            HIWORD(v62.epoch) = 2114;
            v63 = v28;
            v33 = (CMTime *)_os_log_send_and_compose_impl();
            LOBYTE(v30) = v54.value;
          }
          else
          {
            v33 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v33, v33 != &v64, v30, 0, v31);
        }
        if (v28)
          CFRelease(v28);
      }
      v50 = *(const __CFDictionary **)(v20 + 216);
      v51 = CFDictionaryGetValue(v50, *((const void **)v19 + 11));
      if (!v51 || figTimelineCoordinator_newTimelineStateShouldOverrideExistingState(v20, (uint64_t)v51, (uint64_t)v19))
      {
        CFDictionarySetValue(v50, *((const void **)v19 + 11), v19);
        FigCFDictionarySetInt32(*(void **)(v20 + 464), *((const void **)v19 + 11), *((_DWORD *)v19 + 25));
      }
    }
    goto LABEL_86;
  }
  if (v19)
LABEL_86:
    CFRelease(v19);
LABEL_87:
  if (*a1)
    CFRelease((CFTypeRef)*a1);
  v52 = (const void *)a1[1];
  if (v52)
    CFRelease(v52);
  free(a1);
}

uint64_t FigTimelineCoordinatorHandleUpdatedParticipantStateFromMedium(dispatch_queue_t *a1, const void *a2)
{
  _QWORD *v4;
  CFTypeRef v5;

  if (!a2)
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  v4 = malloc_type_malloc(0x10uLL, 0x60040FAFB2B2FuLL);
  if (a1)
    v5 = CFRetain(a1);
  else
    v5 = 0;
  *v4 = v5;
  v4[1] = CFRetain(a2);
  dispatch_async_f(a1[11], v4, (dispatch_function_t)figTimelineCoordinator_handleUpdatedParticipantStateFromMediumOnQueue);
  return 0;
}

void figTimelineCoordinator_handleUpdatedParticipantStateFromMediumOnQueue(CFDictionaryRef *a1)
{
  const void **v2;
  CFDictionaryRef v3;
  CFTypeRef cf;
  char v5;

  v5 = 0;
  cf = 0;
  v2 = (const void **)*a1;
  if (!figTimelineCoordinatorParticipantCreateFromDictionary(*MEMORY[0x1E0C9AE00], a1[1], *((const void **)*a1 + 44), (uint64_t *)&cf))
  {
    figTimelineCoordinator_integrateParticipantStateOnQueue((uint64_t)v2, (uint64_t)cf, &v5);
    if (v5)
    {
      figTimelineCoordinator_postParticipantsDidChange(v2);
      figTimelineCoordinator_triggerTimelineChangesAfterParticipantChangeOnQueue((uint64_t)v2);
    }
  }
  v3 = a1[1];
  if (v3)
    CFRelease(v3);
  if (*a1)
    CFRelease(*a1);
  if (cf)
    CFRelease(cf);
  free(a1);
}

uint64_t FigTimelineCoordinatorHandleReplacementOfAllParticipantStatesFromMedium(dispatch_queue_t *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  CFTypeRef v6;

  v4 = malloc_type_malloc(0x10uLL, 0x60040FAFB2B2FuLL);
  if (!a2)
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  v5 = v4;
  if (a1)
    v6 = CFRetain(a1);
  else
    v6 = 0;
  *v5 = v6;
  v5[1] = CFRetain(a2);
  dispatch_async_f(a1[11], v5, (dispatch_function_t)figTimelineCoordinator_replaceParticipantStatesOnQueue);
  return 0;
}

void figTimelineCoordinator_replaceParticipantStatesOnQueue(uint64_t a1)
{
  void *v2;
  const __CFAllocator *v3;
  __CFArray *Mutable;
  const __CFArray *v5;
  const __CFArray *MutableCopy;
  CFIndex i;
  const __CFArray *Count;
  const __CFDictionary *ValueAtIndex;
  const void *v10;
  CFIndex FirstIndexOfValue;
  CFIndex v12;
  const void *v13;
  const void *v14;
  CFTypeRef cf;
  char v16;
  CFRange v17;

  v2 = *(void **)a1;
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v5 = FigCFDictionaryCopyArrayOfKeys(*((const void **)v2 + 41));
  MutableCopy = FigCFArrayCreateMutableCopy(v3, v5);
  for (i = 0; ; ++i)
  {
    Count = *(const __CFArray **)(a1 + 8);
    if (Count)
      Count = (const __CFArray *)CFArrayGetCount(Count);
    if (i >= (uint64_t)Count)
      break;
    v16 = 0;
    cf = 0;
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), i);
    if (!figTimelineCoordinatorParticipantCreateFromDictionary((int)v3, ValueAtIndex, *((const void **)v2 + 44), (uint64_t *)&cf))
    {
      v10 = (const void *)*((_QWORD *)cf + 4);
      figTimelineCoordinator_integrateParticipantStateOnQueue((uint64_t)v2, (uint64_t)cf, &v16);
      if (v16)
        CFArrayAppendValue(Mutable, v10);
      v17.length = CFArrayGetCount(MutableCopy);
      v17.location = 0;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(MutableCopy, v17, v10);
      if (FirstIndexOfValue != -1)
        CFArrayRemoveValueAtIndex(MutableCopy, FirstIndexOfValue);
      if (cf)
        CFRelease(cf);
    }
  }
  FigSimpleMutexLock(*((pthread_mutex_t **)v2 + 40));
  if (CFArrayGetCount(MutableCopy) >= 1)
  {
    v12 = 0;
    do
    {
      v13 = CFArrayGetValueAtIndex(MutableCopy, v12);
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)v2 + 41), v13);
      ++v12;
    }
    while (v12 < CFArrayGetCount(MutableCopy));
  }
  FigSimpleMutexUnlock(*((pthread_mutex_t **)v2 + 40));
  if (Mutable && CFArrayGetCount(Mutable) > 0 || MutableCopy && CFArrayGetCount(MutableCopy) >= 1)
  {
    figTimelineCoordinator_postParticipantsDidChange((const void **)v2);
    figTimelineCoordinator_triggerTimelineChangesAfterParticipantChangeOnQueue((uint64_t)v2);
  }
  if (Mutable)
    CFRelease(Mutable);
  if (v5)
    CFRelease(v5);
  if (MutableCopy)
    CFRelease(MutableCopy);
  v14 = *(const void **)(a1 + 8);
  if (v14)
    CFRelease(v14);
  if (*(_QWORD *)a1)
    CFRelease(*(CFTypeRef *)a1);
  free((void *)a1);
}

uint64_t FigTimelineCoordinatorCoordinateRateChange(uint64_t a1, _QWORD *a2, const void *a3, float a4)
{
  float *v8;
  CFTypeRef v9;
  CFTypeRef v10;
  uint64_t v11;

  v8 = (float *)malloc_type_malloc(0x20uLL, 0x106004058A0E50EuLL);
  if (a1)
    v9 = CFRetain((CFTypeRef)a1);
  else
    v9 = 0;
  *(_QWORD *)v8 = v9;
  if (a3)
    v10 = CFRetain(a3);
  else
    v10 = 0;
  *((_QWORD *)v8 + 2) = v10;
  v8[2] = a4;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  v11 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v11 + 1;
  *((_QWORD *)v8 + 3) = v11;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v8, (dispatch_function_t)figTimelineCoordinator_coordinateRateChangeOnQueue);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  if (a2)
    *a2 = v11;
  return 0;
}

void figTimelineCoordinator_coordinateRateChangeOnQueue(char *a1)
{
  uint64_t v2;
  char v3;
  uint64_t v4;
  float v5;
  float *v6;
  float v7;
  int v8;
  CMTimeEpoch epoch;
  uint64_t v10;
  char v11;
  float v12;
  _BOOL4 v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  const void *v17;
  const void *v18;
  uint64_t v19;
  int v20;
  char v21;
  const void *v22;
  __int128 v23;
  uint64_t v24;
  CMTime v25;
  CMTime v26;
  Boolean v27;
  CMTime v28;
  __int16 v29;
  CFTypeRef v30;

  v2 = *(_QWORD *)a1;
  v30 = 0;
  v29 = 0;
  memset(&v28, 0, sizeof(v28));
  v27 = 0;
  memset(&v26, 0, sizeof(v26));
  if (!*(_QWORD *)(v2 + 352))
    goto LABEL_45;
  FigCFDictionaryGetBooleanIfPresent(*((_QWORD *)a1 + 2), CFSTR("AlreadyPaused"), (Boolean *)&v29 + 1);
  if (HIBYTE(v29))
    FigCFDictionaryGetCMTimeIfPresent(*((_QWORD *)a1 + 2), CFSTR("StopTime"), &v26);
  FigCFDictionaryGetBooleanIfPresent(*((_QWORD *)a1 + 2), CFSTR("AlreadyPrepared"), (Boolean *)&v29);
  FigCFDictionaryGetBooleanIfPresent(*((_QWORD *)a1 + 2), CFSTR("SetRateImmediately"), &v27);
  v3 = v27 == 0;
  v4 = *(_QWORD *)(v2 + 192);
  v5 = *(float *)(v4 + 36);
  if (v5 == 0.0)
  {
    HIBYTE(v29) = 1;
    v6 = (float *)(a1 + 8);
    v7 = *((float *)a1 + 2);
    if (v7 != 0.0 && !(_BYTE)v29)
      LOBYTE(v29) = *(float *)(v4 + 32) == v7;
  }
  else
  {
    v6 = (float *)(a1 + 8);
    v7 = *((float *)a1 + 2);
  }
  v8 = *(unsigned __int8 *)(v2 + 304);
  if (!*(_BYTE *)(v2 + 304))
    v29 = 0;
  if ((v26.flags & 1) != 0)
  {
    *(_OWORD *)&v28.value = *(_OWORD *)&v26.value;
    epoch = v26.epoch;
LABEL_19:
    v28.epoch = epoch;
    goto LABEL_20;
  }
  if (!*(_QWORD *)(v4 + 88) || v5 != 0.0 && (*(_DWORD *)(v4 + 76) & 0x1D) != 1 || (*(_DWORD *)(v4 + 52) & 0x1D) != 1)
  {
    *(_OWORD *)&v28.value = *(_OWORD *)(v4 + 40);
    epoch = *(_QWORD *)(v4 + 56);
    goto LABEL_19;
  }
  figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)v4, (CMTime *)&kCMTimeInvalid, &v28);
  v7 = *v6;
LABEL_20:
  if (v7 == 0.0 || (v10 = *(_QWORD *)(v2 + 200)) != 0 && *(float *)(v10 + 36) != 0.0)
  {
    if (v7 == 0.0 && (v14 = *(_QWORD *)(v2 + 200)) != 0 && *(float *)(v14 + 36) != 0.0)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(v2 + 392));
      v15 = *(unsigned __int8 *)(v2 + 408);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v2 + 392));
      v13 = v15 == 0;
    }
    else
    {
      v13 = 0;
    }
    v11 = 1;
    v12 = v7;
    v7 = 0.0;
  }
  else
  {
    v11 = 1;
    v12 = 0.0;
    v13 = 0;
    if (!*(_BYTE *)(v2 + 360))
    {
      *(_BYTE *)(v2 + 360) = 1;
      v11 = 0;
    }
  }
  v16 = *MEMORY[0x1E0C9AE00];
  v18 = *(const void **)(v2 + 344);
  v17 = *(const void **)(v2 + 352);
  v19 = *((_QWORD *)a1 + 3);
  v25 = v28;
  v23 = *(_OWORD *)&kCMTimeInvalid.value;
  v24 = 0;
  if (!figTimelineCoordinatorTimelineStateCreateInternal(v7, v12, v16, v17, (__int128 *)&v25.value, &v23, v13, v18, v19, -1, 0, 0, (uint64_t *)&v30))
  {
    if (v12 == 0.0 && (v29 || *(float *)(*(_QWORD *)(v2 + 192) + 36) == 0.0))
    {
      v20 = v29 != 0;
      v21 = 1;
    }
    else
    {
      v21 = 0;
      v20 = 0;
    }
    if (v20 == *(_DWORD *)(v2 + 340))
    {
      if ((v11 & 1) != 0)
        goto LABEL_42;
    }
    else
    {
      *(_DWORD *)(v2 + 340) = v20;
    }
    figTimelineCoordinator_sendParticipantStateToGroupOnQueue(v2);
LABEL_42:
    if (CFArrayGetCount(*(CFArrayRef *)(v2 + 432)) <= 0)
      figTimelineCoordinator_postDidIssueSetRateCommandNotification((const void *)v2, 0, *v6);
    figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(v2, (uint64_t)v30, 1u, v3, 0, v8 != 0, v21, 1);
  }
LABEL_45:
  if (v30)
    CFRelease(v30);
  v22 = (const void *)*((_QWORD *)a1 + 2);
  if (v22)
    CFRelease(v22);
  CFRelease((CFTypeRef)v2);
  free(a1);
}

uint64_t FigTimelineCoordinatorCoordinateJumpToTime(uint64_t a1, __int128 *a2, _QWORD *a3, const void *a4)
{
  char *v8;
  CFTypeRef v9;
  CFTypeRef v10;
  __int128 v11;
  uint64_t v12;

  v8 = (char *)malloc_type_malloc(0x40uLL, 0x1060040C2398F4EuLL);
  if (a1)
    v9 = CFRetain((CFTypeRef)a1);
  else
    v9 = 0;
  *(_QWORD *)v8 = v9;
  if (a4)
    v10 = CFRetain(a4);
  else
    v10 = 0;
  *((_QWORD *)v8 + 4) = v10;
  v11 = *a2;
  *((_QWORD *)v8 + 3) = *((_QWORD *)a2 + 2);
  *(_OWORD *)(v8 + 8) = v11;
  v8[48] = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  v12 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v12 + 1;
  *((_QWORD *)v8 + 5) = v12;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v8, (dispatch_function_t)figTimelineCoordinator_coordinateTimeJumpDispatch);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  if (a3)
    *a3 = v12;
  return 0;
}

void figTimelineCoordinator_coordinateTimeJumpDispatch(char *a1)
{
  _BYTE *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  CMTime v8;

  v2 = *(_BYTE **)a1;
  if (!a1[48])
  {
    v4 = 0;
    goto LABEL_5;
  }
  v3 = *((_QWORD *)a1 + 7);
  if (v3)
  {
    v2[96] = 1;
    figTimelineCoordinator_startTimeoutForTimelineControlCommandOnQueue((uint64_t)v2);
    v4 = (_QWORD *)(v3 + 8);
    *(_QWORD *)v3 = CFRetain(v2);
    *(_BYTE *)(v3 + 20) = 1;
LABEL_5:
    v5 = *((_QWORD *)a1 + 4);
    v6 = *((_QWORD *)a1 + 5);
    v8 = *(CMTime *)(a1 + 8);
    figTimelineCoordinator_coordinateTimeJumpOnQueue((uint64_t)v2, &v8, 0, v5, v6, v4);
    goto LABEL_6;
  }
  FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
LABEL_6:
  v7 = (const void *)*((_QWORD *)a1 + 4);
  if (v7)
    CFRelease(v7);
  if (v2)
    CFRelease(v2);
  free(a1);
}

uint64_t FigTimelineCoordinatorCoordinateJumpToTime2(uint64_t a1, __int128 *a2, _QWORD *a3, const void *a4, _QWORD *a5, _QWORD *a6)
{
  char *v12;
  CFTypeRef v13;
  __int128 v14;
  _DWORD *v15;
  CFTypeRef v16;
  uint64_t v17;

  v12 = (char *)malloc_type_malloc(0x40uLL, 0x1060040C2398F4EuLL);
  if (a1)
    v13 = CFRetain((CFTypeRef)a1);
  else
    v13 = 0;
  *(_QWORD *)v12 = v13;
  v14 = *a2;
  *((_QWORD *)v12 + 3) = *((_QWORD *)a2 + 2);
  *(_OWORD *)(v12 + 8) = v14;
  if (a5 && a6)
  {
    v15 = malloc_type_malloc(0x20uLL, 0x10200405C7134C3uLL);
    v15[4] = *(_DWORD *)(a1 + 100);
    v12[48] = 1;
    *((_QWORD *)v12 + 4) = 0;
    *((_QWORD *)v12 + 7) = v15;
    *a5 = figTimelineCoordinator_timelineControlCommandCompletion;
    *a6 = v15;
  }
  else
  {
    v12[48] = 0;
    if (a4)
      v16 = CFRetain(a4);
    else
      v16 = 0;
    *((_QWORD *)v12 + 4) = v16;
    *((_QWORD *)v12 + 7) = 0;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  v17 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v17 + 1;
  *((_QWORD *)v12 + 5) = v17;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v12, (dispatch_function_t)figTimelineCoordinator_coordinateTimeJumpDispatch);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  if (a3)
    *a3 = v17;
  return 0;
}

void figTimelineCoordinator_timelineControlCommandCompletion(_QWORD *context, OpaqueCMTimebase *a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  if (context)
  {
    v6 = 0;
    v3 = *context;
    if (*context)
    {
      if (a2)
      {
        FigSimpleMutexLock(*(pthread_mutex_t **)(v3 + 16));
        v5 = *(_QWORD *)(v3 + 24);
        *(_QWORD *)(v3 + 24) = v5 + 1;
        figTimelineCoordinatorTimelineStateCreateFromTimebase(*MEMORY[0x1E0C9AE00], *(const void **)(context[1] + 88), a2, v5, &v6);
        context[3] = v6;
        dispatch_async_f(*(dispatch_queue_t *)(*context + 88), context, (dispatch_function_t)figTimelineCoordinator_timelineControlCommandCompletionOnQueue);
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(v3 + 16));
      }
      else
      {
        context[3] = 0;
        dispatch_async_f(*(dispatch_queue_t *)(v3 + 88), context, (dispatch_function_t)figTimelineCoordinator_timelineControlCommandCompletionOnQueue);
      }
    }
  }
}

uint64_t FigTimelineCoordinatorCopyParticipantSnapshotForUUID(uint64_t a1, const void *a2, _QWORD *a3)
{
  const void *Value;
  const void *v7;
  uint64_t v9;

  if (!a1 || !a2 || !a3)
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 320));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 328), a2);
  if (Value)
  {
    v7 = Value;
    CFRetain(Value);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 320));
    *a3 = v7;
    return 0;
  }
  else
  {
    v9 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 320));
    return v9;
  }
}

uint64_t FigTimelineCoordinatorCopyParticipantSnapshots(uint64_t a1, CFArrayRef *a2)
{
  CFArrayRef v4;

  if (!a1 || !a2)
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 320));
  v4 = FigCFDictionaryCopyArrayOfValues(*(const void **)(a1 + 328));
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 320));
  *a2 = v4;
  return 0;
}

uint64_t FigTimelineCoordinatorHandleRemovalOfParticipantStateFromMedium(dispatch_queue_t *a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;

  v4 = malloc_type_malloc(0x10uLL, 0x60040FAFB2B2FuLL);
  if (!a1 || !a2)
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  v5 = v4;
  *v4 = CFRetain(a1);
  v5[1] = CFRetain(a2);
  dispatch_async_f(a1[11], v5, (dispatch_function_t)figTimelineCoordinator_removeParticipantStateOnQueue);
  return 0;
}

void figTimelineCoordinator_removeParticipantStateOnQueue(CFTypeRef *a1)
{
  uint64_t v2;
  const __CFSet **Value;
  __CFString *v4;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v6;
  uint64_t v7;
  unsigned int v8;
  char *v9;
  CFTypeRef v10;
  os_log_type_t type;
  int v12[2];
  const char *v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  __CFString *v17;
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t)*a1;
  if (CFDictionaryContainsKey(*((CFDictionaryRef *)*a1 + 41), a1[1]))
  {
    if (dword_1EE141FE8)
    {
      Value = (const __CFSet **)CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 328), a1[1]);
      v4 = FigCFCopyCompactDescription(Value[2]);
      if (dword_1EE141FE8)
      {
        v12[0] = 0;
        type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, v12, &type);
        v6 = v12[0];
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
          v8 = v6;
        else
          v8 = v6 & 0xFFFFFFFE;
        if (v8)
        {
          v12[1] = 136315650;
          v13 = "figTimelineCoordinator_removeParticipantStateOnQueue";
          v14 = 2112;
          v15 = v2;
          v16 = 2114;
          v17 = v4;
          v9 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v6) = v12[0];
        }
        else
        {
          v9 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v9, v9 != &v18, v6, 0, v7);
      }
      if (v4)
        CFRelease(v4);
    }
    FigSimpleMutexLock(*(pthread_mutex_t **)(v2 + 320));
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v2 + 328), a1[1]);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v2 + 320));
    figTimelineCoordinator_postParticipantsDidChange((const void **)v2);
    figTimelineCoordinator_triggerTimelineChangesAfterParticipantChangeOnQueue(v2);
  }
  v10 = a1[1];
  if (v10)
    CFRelease(v10);
  if (*a1)
    CFRelease(*a1);
  free(a1);
}

uint64_t FigTimelineCoordinatorCopyActiveSuspensionReasons(uint64_t a1, const __CFArray **a2)
{
  CFMutableArrayRef Mutable;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  const void **ValueAtIndex;
  uint64_t v10;
  CFRange v12;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 416));
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v5 = Mutable;
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 424));
    if (Count >= 1)
    {
      v7 = Count;
      for (i = 0; i != v7; ++i)
      {
        ValueAtIndex = (const void **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 424), i);
        v12.length = CFArrayGetCount(v5);
        v12.location = 0;
        if (CFArrayGetFirstIndexOfValue(v5, v12, ValueAtIndex[2]) == -1)
          CFArrayAppendValue(v5, ValueAtIndex[2]);
      }
    }
    v10 = 0;
    if (a2)
      *a2 = v5;
  }
  else
  {
    v10 = FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 416));
  return v10;
}

BOOL FigTimelineCoordinatorIsSuspended(uint64_t a1)
{
  _BOOL8 v2;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 416));
  v2 = CFArrayGetCount(*(CFArrayRef *)(a1 + 424)) > 0;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 416));
  return v2;
}

uint64_t FigTimelineCoordinatorBeginSuspension(uint64_t a1, const void *a2)
{
  return FigTimelineCoordinatorBeginSuspensionProposingTime(a1, a2, (__int128 *)&kCMTimeInvalid.value);
}

uint64_t FigTimelineCoordinatorBeginSuspensionProposingTime(uint64_t a1, const void *a2, __int128 *a3)
{
  _QWORD *v6;
  CFTypeRef v7;
  __int128 v8;
  uint64_t v9;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 416));
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 424), a2);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 416));
  v6 = malloc_type_malloc(0x30uLL, 0x10200401705F15EuLL);
  *v6 = CFRetain((CFTypeRef)a1);
  if (a2)
    v7 = CFRetain(a2);
  else
    v7 = 0;
  v6[1] = v7;
  v8 = *a3;
  v6[4] = *((_QWORD *)a3 + 2);
  *((_OWORD *)v6 + 1) = v8;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  v9 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v9 + 1;
  v6[5] = v9;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v6, (dispatch_function_t)figTimelineCoordinator_beginSuspensionOnQueue);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  return figTimelineCoordinator_postSuspensionReasonsChangedNotification((const void *)a1);
}

void figTimelineCoordinator_beginSuspensionOnQueue(uint64_t *a1)
{
  const void *v2;
  uint64_t v3;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  CMTime *v9;
  CMTime *v10;
  char *v11;
  CMTime *v12;
  __int128 v13;
  int32_t v14;
  _QWORD *v15;
  float *v16;
  uint64_t v17;
  unsigned int v18;
  char v19;
  const void *v20;
  CFTypeRef v21;
  NSObject *v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  CMTime *v27;
  os_log_type_t type;
  int v29;
  CFTypeRef cf;
  CFTypeRef v31;
  CMTime time2;
  uint64_t v33;
  CMTime time1;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v3 = *a1;
  v2 = (const void *)a1[1];
  cf = 0;
  v31 = 0;
  if (dword_1EE141FE8)
  {
    v29 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, &v29, &type);
    v5 = v29;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v7 = v5;
    else
      v7 = v5 & 0xFFFFFFFE;
    if (v7)
    {
      v8 = *(_QWORD *)(a1[1] + 16);
      LODWORD(time2.value) = 136315650;
      *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"figTimelineCoordinator_beginSuspensionOnQueue";
      LOWORD(time2.flags) = 2112;
      *(_QWORD *)((char *)&time2.flags + 2) = v3;
      HIWORD(time2.epoch) = 2114;
      v33 = v8;
      v9 = (CMTime *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v29;
    }
    else
    {
      v9 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v9, v9 != &time1, v5, 0, v6);
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(v3 + 432), v2);
  if (!*(_QWORD *)(v3 + 200))
    goto LABEL_28;
  if (!figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue(v3, (const __CFArray **)&cf)
    && !figTimelineCoordinatorTimelineStateCopy(*MEMORY[0x1E0C9AE00], *(_QWORD *)(v3 + 200), &v31))
  {
    v10 = *(CMTime **)(v3 + 200);
    v11 = (char *)v31;
    *((_DWORD *)v31 + 8) = v10[1].flags;
    *((_DWORD *)v11 + 9) = 0;
    v12 = (CMTime *)(v11 + 40);
    if ((*((_DWORD *)a1 + 7) & 0x1D) == 1)
    {
      v13 = *((_OWORD *)a1 + 1);
      *((_QWORD *)v11 + 7) = a1[4];
      *(_OWORD *)&v12->value = v13;
    }
    else
    {
      figTimelineCoordinator_timelineTimeAtHostTime(v10, (CMTime *)&kCMTimeInvalid, &time1);
      *v12 = time1;
      v11 = (char *)v31;
    }
    time1 = *(CMTime *)(v11 + 40);
    *(_OWORD *)&time2.value = *(_OWORD *)&kCMTimeZero.value;
    time2.epoch = 0;
    v14 = CMTimeCompare(&time1, &time2);
    v15 = v31;
    if (v14 == -1)
    {
      *(_OWORD *)((char *)v31 + 40) = *(_OWORD *)&kCMTimeZero.value;
      v15[7] = 0;
    }
    *((_OWORD *)v15 + 4) = *(_OWORD *)&kCMTimeInvalid.value;
    v15[10] = 0;
    if ((figTimelineCoordinator_everyoneIsSuspended(v3)
       || figTimelineCoordinator_groupShouldWaitForAllSuspensions(v3, (CFArrayRef)cf))
      && !figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons(v3, (CFArrayRef)cf))
    {
      if (*(float *)(*(_QWORD *)(v3 + 200) + 36) != 0.0)
      {
        *(_BYTE *)(v3 + 360) = 1;
        v16 = (float *)v31;
        v17 = v3;
        v18 = 7;
        v19 = 0;
        goto LABEL_27;
      }
    }
    else
    {
      if ((!figTimelineCoordinator_everyoneIsSuspended(v3)
         || figTimelineCoordinator_groupShouldWaitForAllSuspensions(v3, (CFArrayRef)cf))
        && !figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons(v3, (CFArrayRef)cf))
      {
        v16 = *(float **)(v3 + 200);
        if (v16[9] == 0.0)
          goto LABEL_24;
        if ((*((_DWORD *)a1 + 7) & 0x1D) == 1)
        {
          v20 = *(const void **)(v3 + 208);
          v21 = v31;
          *(_QWORD *)(v3 + 208) = v31;
          if (v21)
            CFRetain(v21);
          if (v20)
            CFRelease(v20);
          if (dword_1EE141FE8)
          {
            v29 = 0;
            type = OS_LOG_TYPE_DEFAULT;
            v22 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, &v29, &type);
            v23 = v29;
            if (os_log_type_enabled(v22, type))
              v25 = v23;
            else
              v25 = v23 & 0xFFFFFFFE;
            if (v25)
            {
              v26 = *(_QWORD *)(v3 + 208);
              LODWORD(time2.value) = 136315650;
              *(CMTimeValue *)((char *)&time2.value + 4) = (CMTimeValue)"figTimelineCoordinator_beginSuspensionOnQueue";
              LOWORD(time2.flags) = 2112;
              *(_QWORD *)((char *)&time2.flags + 2) = v3;
              HIWORD(time2.epoch) = 2112;
              v33 = v26;
              v27 = (CMTime *)_os_log_send_and_compose_impl();
              LOBYTE(v23) = v29;
            }
            else
            {
              v27 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v27, v27 != &time1, v23, 0, v24);
          }
        }
      }
      v16 = *(float **)(v3 + 200);
      if (v16)
      {
LABEL_24:
        v17 = v3;
        v18 = 2;
        v19 = 1;
LABEL_27:
        figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(v17, (uint64_t)v16, v18, 1, v19, 1, 1, 1);
      }
    }
LABEL_28:
    figTimelineCoordinator_sendParticipantStateToGroupOnQueue(v3);
  }
  if (cf)
    CFRelease(cf);
  if (v31)
    CFRelease(v31);
  CFRelease((CFTypeRef)v3);
  if (v2)
    CFRelease(v2);
  free(a1);
}

uint64_t figTimelineCoordinator_postSuspensionReasonsChangedNotification(const void *a1)
{
  uint64_t active;
  __CFDictionary *Mutable;
  __CFDictionary *v4;
  __CFNotificationCenter *DefaultLocalCenter;
  uint64_t v6;
  void *value;

  value = 0;
  active = FigTimelineCoordinatorCopyActiveSuspensionReasons((uint64_t)a1, (const __CFArray **)&value);
  if (!(_DWORD)active)
  {
    if (figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons((uint64_t)a1, (CFArrayRef)value))
    {
      v6 = 0;
      goto LABEL_5;
    }
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v4 = Mutable;
      CFDictionarySetValue(Mutable, CFSTR("SuspensionReasons"), value);
      DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      v6 = CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("SuspensionReasonsChanged"), a1, v4);
      CFRelease(v4);
      goto LABEL_5;
    }
    active = FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
  }
  v6 = active;
LABEL_5:
  if (value)
    CFRelease(value);
  return v6;
}

uint64_t FigTimelineCoordinatorEndSuspensionReApplyingGroupStateOnlyIfNeeded(uint64_t a1, void *a2, char a3)
{
  uint64_t result;
  char *v6;
  CFTypeRef v7;
  uint64_t v8;
  void *values;

  values = a2;
  result = figTimelineCoordinator_removeSuspension(a1, a2);
  if (!(_DWORD)result)
  {
    v6 = (char *)malloc_type_malloc(0x40uLL, 0x1060040E14BA948uLL);
    if (a1)
      v7 = CFRetain((CFTypeRef)a1);
    else
      v7 = 0;
    *(_QWORD *)v6 = v7;
    *((_QWORD *)v6 + 1) = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
    *(_OWORD *)(v6 + 20) = *(_OWORD *)&kCMTimeInvalid.value;
    *(_QWORD *)(v6 + 36) = 0;
    *((_DWORD *)v6 + 11) = 2139095039;
    v6[16] = 0;
    v6[48] = a3;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    v8 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = v8 + 1;
    *((_QWORD *)v6 + 7) = v8;
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v6, (dispatch_function_t)figTimelineCoordinator_endSuspensionOnQueue);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    return figTimelineCoordinator_postSuspensionReasonsChangedNotification((const void *)a1);
  }
  return result;
}

uint64_t figTimelineCoordinator_removeSuspension(uint64_t a1, const void *a2)
{
  uint64_t v4;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 416));
  v4 = figTimelineCoordinatorRemoveSuspensionInternal(a1, a2);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 416));
  return v4;
}

void figTimelineCoordinator_endSuspensionOnQueue(char *a1)
{
  uint64_t v2;
  int *v3;
  __CFString *Mutable;
  CFIndex v5;
  char v6;
  const __CFArray *Count;
  CFStringRef *ValueAtIndex;
  const char *v9;
  const __CFArray *v10;
  CFIndex v11;
  CFIndex v12;
  CFIndex i;
  const void *v14;
  const __CFArray *v15;
  CFIndex FirstIndexOfValue;
  _OWORD *v17;
  int v18;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  const char *v20;
  uint64_t v21;
  unsigned int v22;
  Float64 Seconds;
  CMTime *v24;
  NSObject *v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t *v28;
  _BOOL8 v29;
  char v30;
  CFTypeRef v31;
  const void *v32;
  const void *v33;
  float v34;
  int v35;
  uint64_t v36;
  const void *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  char v42;
  char v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  const void *v47;
  CFTypeRef v48;
  uint64_t v49;
  os_log_type_t type;
  CFTypeRef cf;
  _BYTE v52[24];
  __CFString *v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  Float64 v57;
  CMTime time;
  uint64_t v59;
  CFRange v60;

  v59 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)a1;
  cf = 0;
  v3 = &ensureGlobalDeserializeRegister_err;
  if (dword_1EE141FE8)
  {
    Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    CFStringAppend(Mutable, CFSTR("["));
    v5 = 0;
    v6 = 0;
    while (1)
    {
      Count = (const __CFArray *)*((_QWORD *)a1 + 1);
      if (Count)
        Count = (const __CFArray *)CFArrayGetCount(Count);
      if (v5 >= (uint64_t)Count)
        break;
      ValueAtIndex = (CFStringRef *)CFArrayGetValueAtIndex(*((CFArrayRef *)a1 + 1), v5);
      if (CFStringCompare(CFSTR("PlayingInterstitial"), ValueAtIndex[2], 0) == kCFCompareEqualTo)
        v6 = 1;
      if (v5)
        v9 = ", ";
      else
        v9 = "";
      CFStringAppendFormat(Mutable, 0, CFSTR("%s'%@'"), v9, ValueAtIndex[2]);
      ++v5;
    }
    CFStringAppend(Mutable, CFSTR("]"));
    v3 = &ensureGlobalDeserializeRegister_err;
  }
  else
  {
    v6 = 0;
    Mutable = 0;
  }
  v10 = (const __CFArray *)*((_QWORD *)a1 + 1);
  if (v10)
  {
    v11 = CFArrayGetCount(*((CFArrayRef *)a1 + 1));
    if (v11 >= 1)
    {
      v12 = v11;
      for (i = 0; v12 != i; ++i)
      {
        v14 = CFArrayGetValueAtIndex(v10, i);
        v15 = *(const __CFArray **)(v2 + 432);
        v60.length = CFArrayGetCount(v15);
        v60.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v15, v60, v14);
        if (FirstIndexOfValue == -1)
        {
          if (FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0))
            break;
        }
        else
        {
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v2 + 432), FirstIndexOfValue);
        }
      }
    }
  }
  v17 = a1 + 20;
  v18 = v3[1018];
  if ((*((_DWORD *)a1 + 8) & 0x1D) == 1)
  {
    if (!v18)
      goto LABEL_43;
    LODWORD(v49) = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, (int *)&v49, &type);
    LODWORD(v20) = v49;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v22 = v20;
    else
      v22 = v20 & 0xFFFFFFFE;
    if (v22)
    {
      if (CFArrayGetCount(*(CFArrayRef *)(v2 + 432)) >= 1)
        v20 = "discarding proposed";
      else
        v20 = "proposing";
      *(_OWORD *)&time.value = *v17;
      time.epoch = *(_QWORD *)(a1 + 36);
      Seconds = CMTimeGetSeconds(&time);
      *(_DWORD *)v52 = 136316162;
      *(_QWORD *)&v52[4] = "figTimelineCoordinator_endSuspensionOnQueue";
      *(_WORD *)&v52[12] = 2112;
      *(_QWORD *)&v52[14] = v2;
      *(_WORD *)&v52[22] = 2114;
      v53 = Mutable;
      v54 = 2080;
      v55 = v20;
      v56 = 2048;
      v57 = Seconds;
      v24 = (CMTime *)_os_log_send_and_compose_impl();
      LOBYTE(v20) = v49;
    }
    else
    {
      v24 = 0;
    }
    v28 = (uint64_t *)qword_1EE141FE0;
    v29 = v24 != &time;
    v30 = (char)v20;
  }
  else
  {
    if (!v18)
      goto LABEL_43;
    LODWORD(v49) = 0;
    type = OS_LOG_TYPE_DEFAULT;
    v25 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, (int *)&v49, &type);
    v26 = v49;
    if (os_log_type_enabled(v25, type))
      v27 = v26;
    else
      v27 = v26 & 0xFFFFFFFE;
    if (v27)
    {
      *(_DWORD *)v52 = 136315650;
      *(_QWORD *)&v52[4] = "figTimelineCoordinator_endSuspensionOnQueue";
      *(_WORD *)&v52[12] = 2112;
      *(_QWORD *)&v52[14] = v2;
      *(_WORD *)&v52[22] = 2114;
      v53 = Mutable;
      v24 = (CMTime *)_os_log_send_and_compose_impl();
      LOBYTE(v26) = v49;
    }
    else
    {
      v24 = 0;
    }
    v28 = (uint64_t *)qword_1EE141FE0;
    v29 = v24 != &time;
    v30 = v26;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(v28, 1u, 1, v24, v29, v30, 0, v21);
LABEL_43:
  if (CFArrayGetCount(*(CFArrayRef *)(v2 + 432)) > 0
    || *(_BYTE *)(v2 + 440) && !FigCFDictionaryGetCount(*(CFDictionaryRef *)(v2 + 328)))
  {
    goto LABEL_44;
  }
  v33 = *(const void **)(v2 + 352);
  if (!v33)
    goto LABEL_44;
  v34 = *((float *)a1 + 11);
  v35 = *((_DWORD *)a1 + 8) & 0x1D;
  if (v34 == 3.4028e38 || v35 != 1)
  {
    if (v35 == 1)
    {
      if (!*(_QWORD *)(v2 + 200))
        figTimelineCoordinator_issueProposeTimelineForIdentifierOnQueue(v2);
      if (!v6 || figTimelineCoordinator_othersAreSuspended(v2) || !*(_QWORD *)(v2 + 200))
      {
        v44 = *((_QWORD *)a1 + 7);
        *(_OWORD *)&time.value = *v17;
        time.epoch = *(_QWORD *)(a1 + 36);
        figTimelineCoordinator_coordinateTimeJumpOnQueue(v2, &time, 1, 0, v44, 0);
LABEL_44:
        figTimelineCoordinator_sendParticipantStateToGroupOnQueue(v2);
        v31 = cf;
        goto LABEL_45;
      }
    }
    else if (!a1[48]
           && (*(_QWORD *)(v2 + 200) || !*(_BYTE *)(v2 + 281))
           && figTimelineCoordinator_othersAreSuspended(v2))
    {
      if (figTimelineCoordinator_othersAreSuspended(v2))
        *(_BYTE *)(v2 + 360) = 1;
      goto LABEL_44;
    }
  }
  else
  {
    v49 = 0;
    if (!*(_QWORD *)(v2 + 200) || !a1[16])
      goto LABEL_61;
    if (figTimelineCoordinator_othersAreSuspended(v2))
    {
      v33 = *(const void **)(v2 + 352);
      v34 = *((float *)a1 + 11);
LABEL_61:
      v36 = *MEMORY[0x1E0C9AE00];
      v37 = *(const void **)(v2 + 344);
      v38 = *((_QWORD *)a1 + 7);
      *(_OWORD *)&time.value = *v17;
      time.epoch = *(_QWORD *)(a1 + 36);
      memset(v52, 0, sizeof(v52));
      if (figTimelineCoordinatorTimelineStateCreateInternal(v34, 0.0, v36, v33, (__int128 *)&time.value, (__int128 *)v52, 0, v37, v38, -1, 0, 0, &v49))goto LABEL_47;
      *(_BYTE *)(v2 + 360) = 1;
      figTimelineCoordinator_sendParticipantStateToGroupOnQueue(v2);
      v39 = v49;
      v40 = v2;
      v41 = 8;
      v42 = 0;
      v43 = 1;
LABEL_78:
      figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(v40, v39, v41, 1, v42, 0, v43, 1);
      goto LABEL_44;
    }
  }
  v45 = *(_QWORD *)(v2 + 200);
  if (!v45)
  {
    if (*(_QWORD *)(v2 + 352))
      figTimelineCoordinator_issueProposeTimelineForIdentifierOnQueue(v2);
    goto LABEL_44;
  }
  v46 = figTimelineCoordinatorTimelineStateCopy(*MEMORY[0x1E0C9AE00], v45, &cf);
  v31 = cf;
  if (!v46)
  {
    *((_QWORD *)cf + 2) = *((_QWORD *)a1 + 7);
    FigSimpleMutexLock(*(pthread_mutex_t **)(v2 + 184));
    v47 = *(const void **)(v2 + 200);
    v48 = cf;
    *(_QWORD *)(v2 + 200) = cf;
    if (v48)
      CFRetain(v48);
    if (v47)
      CFRelease(v47);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v2 + 184));
    v39 = *(_QWORD *)(v2 + 200);
    if (!v39)
      goto LABEL_44;
    v40 = v2;
    v41 = 5;
    v42 = 1;
    v43 = 0;
    goto LABEL_78;
  }
LABEL_45:
  if (v31)
    CFRelease(v31);
LABEL_47:
  CFRelease((CFTypeRef)v2);
  v32 = (const void *)*((_QWORD *)a1 + 1);
  if (v32)
    CFRelease(v32);
  if (Mutable)
    CFRelease(Mutable);
  free(a1);
}

uint64_t FigTimelineCoordinatorEndSuspensionProposingNewTime(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t result;
  char *v6;
  CFTypeRef v7;
  uint64_t v8;
  uint64_t v9;
  void *values;

  values = a2;
  result = figTimelineCoordinator_removeSuspension(a1, a2);
  if (!(_DWORD)result)
  {
    v6 = (char *)malloc_type_malloc(0x40uLL, 0x1060040E14BA948uLL);
    if (a1)
      v7 = CFRetain((CFTypeRef)a1);
    else
      v7 = 0;
    *(_QWORD *)v6 = v7;
    *((_QWORD *)v6 + 1) = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
    v8 = *(_QWORD *)(a3 + 16);
    *(_OWORD *)(v6 + 20) = *(_OWORD *)a3;
    *(_QWORD *)(v6 + 36) = v8;
    *((_DWORD *)v6 + 11) = 2139095039;
    v6[16] = 0;
    v6[48] = 1;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    v9 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = v9 + 1;
    *((_QWORD *)v6 + 7) = v9;
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v6, (dispatch_function_t)figTimelineCoordinator_endSuspensionOnQueue);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    return figTimelineCoordinator_postSuspensionReasonsChangedNotification((const void *)a1);
  }
  return result;
}

uint64_t FigTimelineCoordinatorEndSuspensionWeaklyIfNeededProposingNewRateAndTime(uint64_t a1, const void **a2, uint64_t a3, float a4)
{
  const __CFDictionary *Value;
  const void *v9;
  uint64_t result;
  BOOL v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  void *values;

  values = a2;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 392));
  Value = (const __CFDictionary *)FigCFDictionaryGetValue(*(const __CFDictionary **)(a1 + 400), a2[2]);
  v9 = FigCFDictionaryGetValue(Value, CFSTR("ShouldWait"));
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 392));
  result = figTimelineCoordinator_removeSuspension(a1, a2);
  if (!(_DWORD)result)
  {
    v11 = v9 != (const void *)*MEMORY[0x1E0C9AE50];
    v12 = (char *)malloc_type_malloc(0x40uLL, 0x1060040E14BA948uLL);
    *(_QWORD *)v12 = CFRetain((CFTypeRef)a1);
    *((_QWORD *)v12 + 1) = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
    v13 = *(_QWORD *)(a3 + 16);
    *(_OWORD *)(v12 + 20) = *(_OWORD *)a3;
    *(_QWORD *)(v12 + 36) = v13;
    *((float *)v12 + 11) = a4;
    v12[16] = v11;
    v12[48] = 1;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    v14 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = v14 + 1;
    *((_QWORD *)v12 + 7) = v14;
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v12, (dispatch_function_t)figTimelineCoordinator_endSuspensionOnQueue);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    return figTimelineCoordinator_postSuspensionReasonsChangedNotification((const void *)a1);
  }
  return result;
}

uint64_t FigTimelineCoordinatorEndSuspension(uint64_t a1, void *a2)
{
  return FigTimelineCoordinatorEndSuspensionProposingNewTime(a1, a2, (uint64_t)&kCMTimeInvalid);
}

uint64_t FigTimelineCoordinatorEndSuspensionsProposingNewTime(uint64_t a1, CFArrayRef theArray, uint64_t a3)
{
  uint64_t result;
  char *v7;
  CFTypeRef v8;
  uint64_t v9;
  uint64_t v10;

  if (!theArray || CFArrayGetCount(theArray) < 1)
    return 0;
  result = figTimelineCoordinator_removeSuspensions(a1, theArray);
  if (!(_DWORD)result)
  {
    v7 = (char *)malloc_type_malloc(0x40uLL, 0x1060040E14BA948uLL);
    if (a1)
      v8 = CFRetain((CFTypeRef)a1);
    else
      v8 = 0;
    *(_QWORD *)v7 = v8;
    *((_QWORD *)v7 + 1) = CFRetain(theArray);
    v9 = *(_QWORD *)(a3 + 16);
    *(_OWORD *)(v7 + 20) = *(_OWORD *)a3;
    *(_QWORD *)(v7 + 36) = v9;
    *((_DWORD *)v7 + 11) = 2139095039;
    v7[16] = 0;
    v7[48] = 1;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    v10 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = v10 + 1;
    *((_QWORD *)v7 + 7) = v10;
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v7, (dispatch_function_t)figTimelineCoordinator_endSuspensionOnQueue);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    return figTimelineCoordinator_postSuspensionReasonsChangedNotification((const void *)a1);
  }
  return result;
}

uint64_t figTimelineCoordinator_removeSuspensions(uint64_t a1, const __CFArray *a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  const void *ValueAtIndex;
  uint64_t v8;
  uint64_t v9;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 416));
  if (a2 && (Count = CFArrayGetCount(a2), Count >= 1))
  {
    v5 = Count;
    v6 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a2, v6);
      v8 = figTimelineCoordinatorRemoveSuspensionInternal(a1, ValueAtIndex);
      if ((_DWORD)v8)
        break;
      if (v5 == ++v6)
        goto LABEL_6;
    }
    v9 = v8;
  }
  else
  {
LABEL_6:
    v9 = 0;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 416));
  return v9;
}

uint64_t FigTimelineCoordinatorEndSuspensions(uint64_t a1, CFArrayRef theArray)
{
  uint64_t result;
  char *v5;
  CFTypeRef v6;
  uint64_t v7;

  if (!theArray || CFArrayGetCount(theArray) < 1)
    return 0;
  result = figTimelineCoordinator_removeSuspensions(a1, theArray);
  if (!(_DWORD)result)
  {
    v5 = (char *)malloc_type_malloc(0x40uLL, 0x1060040E14BA948uLL);
    if (a1)
      v6 = CFRetain((CFTypeRef)a1);
    else
      v6 = 0;
    *(_QWORD *)v5 = v6;
    *((_QWORD *)v5 + 1) = CFRetain(theArray);
    *(_OWORD *)(v5 + 20) = *(_OWORD *)&kCMTimeInvalid.value;
    *(_QWORD *)(v5 + 36) = 0;
    *((_DWORD *)v5 + 11) = 2139095039;
    v5[16] = 0;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    v7 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = v7 + 1;
    *((_QWORD *)v5 + 7) = v7;
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v5, (dispatch_function_t)figTimelineCoordinator_endSuspensionOnQueue);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    return figTimelineCoordinator_postSuspensionReasonsChangedNotification((const void *)a1);
  }
  return result;
}

uint64_t FigTimelineCoordinatorGetExpectedGroupTimeForIdentifier(uint64_t a1, const void *a2, CMTime *a3)
{
  const void *Value;
  CMTime *v7;
  uint64_t v8;
  CFIndex v9;
  CFIndex Count;
  const __CFDictionary **ValueAtIndex;
  const void *v12;
  uint64_t v13;
  CMTime v15;
  CFArrayRef theArray;

  theArray = 0;
  if (!a1)
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  if (a2 && a3)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 184));
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 216), a2);
    if (Value)
      v7 = (CMTime *)CFRetain(Value);
    else
      v7 = 0;
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 184));
    v8 = FigTimelineCoordinatorCopyParticipantSnapshots(a1, &theArray);
    if ((_DWORD)v8)
    {
      v13 = v8;
      if (!v7)
        goto LABEL_21;
    }
    else
    {
      v9 = 0;
      while (1)
      {
        Count = (CFIndex)theArray;
        if (theArray)
          Count = CFArrayGetCount(theArray);
        if (v9 >= Count)
          break;
        ValueAtIndex = (const __CFDictionary **)CFArrayGetValueAtIndex(theArray, v9);
        v12 = participantState_timelineIdentifier(ValueAtIndex[2]);
        ++v9;
        if (FigCFEqual(a2, v12))
        {
          if (v7
            && v7[3].epoch
            && (*(float *)&v7[1].flags == 0.0 || (HIDWORD(v7[3].value) & 0x1D) == 1)
            && (HIDWORD(v7[2].value) & 0x1D) == 1)
          {
            figTimelineCoordinator_timelineTimeAtHostTime(v7, (CMTime *)&kCMTimeInvalid, &v15);
            v13 = 0;
            *a3 = v15;
            goto LABEL_20;
          }
          break;
        }
      }
      v13 = 0;
      *(_OWORD *)&a3->value = *(_OWORD *)&kCMTimeInvalid.value;
      a3->epoch = 0;
      if (!v7)
        goto LABEL_21;
    }
LABEL_20:
    CFRelease(v7);
  }
  else
  {
    v13 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
LABEL_21:
  if (theArray)
    CFRelease(theArray);
  return v13;
}

uint64_t FigTimelineCoordinatorGetExpectedTimeAtHostTime(uint64_t a1, CMTime *a2, CMTime *a3)
{
  CMTime *v6;
  CMTime v8;
  CMTime v9;

  memset(&v9, 0, sizeof(v9));
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 184));
  v6 = *(CMTime **)(a1 + 200);
  if (v6)
  {
    CFRetain(*(CFTypeRef *)(a1 + 200));
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 184));
    v8 = *a2;
    figTimelineCoordinator_timelineTimeAtHostTime(v6, &v8, &v9);
    if (!a3)
      goto LABEL_4;
    goto LABEL_3;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 184));
  if (a3)
LABEL_3:
    *a3 = v9;
LABEL_4:
  if (v6)
    CFRelease(v6);
  return 0;
}

CMTime *figTimelineCoordinator_timelineTimeAtHostTime@<X0>(CMTime *result@<X0>, CMTime *a2@<X1>, CMTime *a3@<X8>)
{
  CMTime *v4;
  float v5;
  CMTimeEpoch *p_epoch;
  OpaqueCMClock *HostTimeClock;
  CMTime v8;
  CMTime lhs;
  CMTime time;
  CMTime rhs;
  CMTime v12;

  *(_OWORD *)&a3->value = *(_OWORD *)&kCMTimeInvalid.value;
  a3->epoch = 0;
  if (result[3].epoch)
  {
    v4 = result;
    v5 = *(float *)&result[1].flags;
    if ((v5 == 0.0 || (HIDWORD(result[3].value) & 0x1D) == 1) && (HIDWORD(result[2].value) & 0x1D) == 1)
    {
      *(_OWORD *)&a3->value = *(_OWORD *)&result[1].epoch;
      a3->epoch = *(_QWORD *)&result[2].timescale;
      if (v5 != 0.0)
      {
        p_epoch = &result[1].epoch;
        memset(&v12, 0, sizeof(v12));
        if ((a2->flags & 0x1D) == 1)
        {
          v12 = *a2;
        }
        else
        {
          HostTimeClock = CMClockGetHostTimeClock();
          CMClockGetTime(&v12, HostTimeClock);
        }
        lhs = v12;
        v8 = *(CMTime *)((char *)v4 + 64);
        CMTimeSubtract(&time, &lhs, &v8);
        CMTimeMultiplyByFloat64(&rhs, &time, *(float *)&v4[1].flags);
        *(_OWORD *)&lhs.value = *(_OWORD *)p_epoch;
        lhs.epoch = *(_QWORD *)&v4[2].timescale;
        return CMTimeAdd(a3, &lhs, &rhs);
      }
    }
  }
  return result;
}

uint64_t FigTimelineCoordinatorResetGroupTimelineExpectations(uint64_t a1)
{
  const void *v2;
  const void *v3;

  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 216));
  v2 = *(const void **)(a1 + 200);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 200) = 0;
  }
  v3 = *(const void **)(a1 + 208);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 208) = 0;
  }
  *(_BYTE *)(a1 + 281) = 1;
  return 0;
}

uint64_t FigTimelineCoordinatorSetWeakMediumAndCallbacks(dispatch_queue_t *a1, uint64_t a2, _QWORD *a3)
{
  char *v6;
  CFTypeRef v7;
  __int128 v8;
  __int128 v9;

  if (*a3 || !a3[4] || !a3[2] || !a3[3])
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  v6 = (char *)malloc_type_malloc(0x38uLL, 0x10A004042A389E2uLL);
  if (a1)
    v7 = CFRetain(a1);
  else
    v7 = 0;
  *(_QWORD *)v6 = v7;
  v8 = *(_OWORD *)a3;
  v9 = *((_OWORD *)a3 + 1);
  *((_QWORD *)v6 + 5) = a3[4];
  *(_OWORD *)(v6 + 24) = v9;
  *(_OWORD *)(v6 + 8) = v8;
  *((_QWORD *)v6 + 6) = FigCFWeakReferenceHolderCreateWithReferencedObject(a2);
  dispatch_async_f(a1[11], v6, (dispatch_function_t)figTimelineCoordinator_setMediumCallbacksOnQueue);
  return 0;
}

void figTimelineCoordinator_setMediumCallbacksOnQueue(char *a1)
{
  uint64_t v2;
  __int128 v3;
  __int128 v4;
  const void *v5;
  const void *v6;
  const void *v7;

  v2 = *(_QWORD *)a1;
  v3 = *(_OWORD *)(a1 + 8);
  v4 = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(v2 + 152) = *((_QWORD *)a1 + 5);
  *(_OWORD *)(v2 + 136) = v4;
  *(_OWORD *)(v2 + 120) = v3;
  v5 = *(const void **)(v2 + 160);
  v6 = (const void *)*((_QWORD *)a1 + 6);
  *(_QWORD *)(v2 + 160) = v6;
  if (v6)
    CFRetain(v6);
  if (v5)
    CFRelease(v5);
  figTimelineCoordinator_resetGroupExpectationsOnQueue(v2);
  CFRelease((CFTypeRef)v2);
  v7 = (const void *)*((_QWORD *)a1 + 6);
  if (v7)
    CFRelease(v7);
  free(a1);
}

uint64_t FigTimelineCoordinatorHandleAssignmentOfUUIDToLocalParticipantByMedium(dispatch_queue_t *a1, const void *a2)
{
  _QWORD *v4;
  CFTypeRef v5;
  CFTypeRef v6;

  v4 = malloc_type_malloc(0x10uLL, 0x60040FAFB2B2FuLL);
  if (a1)
    v5 = CFRetain(a1);
  else
    v5 = 0;
  *v4 = v5;
  if (a2)
    v6 = CFRetain(a2);
  else
    v6 = 0;
  v4[1] = v6;
  dispatch_async_f(a1[11], v4, (dispatch_function_t)figTimelineCoordinator_handleNewParticipantUUIDFromMediumOnQueue);
  return 0;
}

void figTimelineCoordinator_handleNewParticipantUUIDFromMediumOnQueue(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  int v5;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v7;
  uint64_t v8;
  unsigned int v9;
  _BYTE *v10;
  const void *v11;
  const void *v12;
  int v13;
  int v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  _BYTE *v19;
  const void *v20;
  os_log_type_t type;
  int v22;
  int v23;
  const char *v24;
  __int16 v25;
  int v26;
  _BYTE v27[128];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = *a1;
  v2 = a1[1];
  if (*(_QWORD *)(*a1 + 344))
  {
    if (!v2)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(v3 + 168));
      v4 = *(const void **)(v3 + 176);
      if (v4)
      {
        CFRelease(v4);
        *(_QWORD *)(v3 + 176) = 0;
      }
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v3 + 168));
    }
  }
  else if (v2)
  {
    if (!*(_QWORD *)(v3 + 176))
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(v3 + 504));
      v5 = figTimelineCoordinator_setNetworkToHostTimeOffset(v3);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v3 + 504));
      if (v5 || !*(_QWORD *)(v3 + 176))
      {
        v22 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 0, &v22, &type);
        v7 = v22;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
          v9 = v7;
        else
          v9 = v7 & 0xFFFFFFFE;
        if (v9)
        {
          v23 = 136315394;
          v24 = "figTimelineCoordinator_handleNewParticipantUUIDFromMediumOnQueue";
          v25 = 1024;
          v26 = v5;
          v10 = (_BYTE *)_os_log_send_and_compose_impl();
          LOBYTE(v7) = v22;
        }
        else
        {
          v10 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 0, 1, v10, v10 != v27, v7, 0, v8);
      }
    }
  }
  v11 = *(const void **)(v3 + 344);
  v12 = (const void *)a1[1];
  *(_QWORD *)(v3 + 344) = v12;
  if (v12)
    CFRetain(v12);
  if (v11)
    CFRelease(v11);
  v13 = figTimelineCoordinator_resetGroupExpectationsOnQueue(v3);
  if (v13)
  {
    v14 = v13;
    v22 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    v15 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 0, &v22, &type);
    v16 = v22;
    if (os_log_type_enabled(v15, type))
      v18 = v16;
    else
      v18 = v16 & 0xFFFFFFFE;
    if (v18)
    {
      v23 = 136315394;
      v24 = "figTimelineCoordinator_handleNewParticipantUUIDFromMediumOnQueue";
      v25 = 1024;
      v26 = v14;
      v19 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v16) = v22;
    }
    else
    {
      v19 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 0, 1, v19, v19 != v27, v16, 0, v17);
  }
  CFRelease((CFTypeRef)v3);
  v20 = (const void *)a1[1];
  if (v20)
    CFRelease(v20);
  free(a1);
}

uint64_t FigTimelineCoordinatorDisconnectFromMedium()
{
  return 0;
}

uint64_t FigTimelineCoordinatorReapplyGroupStateViaTimelineControl(dispatch_queue_t *a1)
{
  _BYTE *v2;
  CFTypeRef v3;

  v2 = malloc_type_malloc(0x10uLL, 0x10200405F07FB98uLL);
  if (a1)
    v3 = CFRetain(a1);
  else
    v3 = 0;
  *(_QWORD *)v2 = v3;
  v2[8] = 1;
  dispatch_async_f(a1[11], v2, (dispatch_function_t)figTimelineCoordinator_reapplyExpectedTimelineDispatch);
  return 0;
}

void figTimelineCoordinator_reapplyExpectedTimelineDispatch(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)a1;
  figTimelineCoordinator_reapplyExpectedTimelineOnQueue(*(_QWORD *)a1, *(unsigned __int8 *)(a1 + 8), 2u);
  if (v2)
    CFRelease(v2);
  free((void *)a1);
}

uint64_t FigTimelineCoordinatorHandleTransitionToNewTimelineFromTimelineControl(uint64_t a1, const void *a2, OpaqueCMTimebase *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFTypeRef v9;
  _QWORD *v10;
  int v11;
  CFTypeRef v12;
  CFTypeRef v13;
  uint64_t v14;
  CFTypeRef cf;

  cf = 0;
  if (!a2)
  {
    v10 = malloc_type_malloc(0x18uLL, 0x1020040A95220FAuLL);
    v11 = 0;
    if (!a1)
    {
      v12 = 0;
      goto LABEL_8;
    }
LABEL_7:
    v12 = CFRetain((CFTypeRef)a1);
LABEL_8:
    *v10 = v12;
    v9 = cf;
    if (cf)
      v13 = CFRetain(cf);
    else
      v13 = 0;
    v10[1] = v13;
    *((_BYTE *)v10 + 16) = 0;
    dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v10, (dispatch_function_t)figTimelineCoordinator_switchToProposedTimelineWithNewIdentifierOnQueue);
    v8 = 0;
    v14 = 0;
    if (!v11)
      goto LABEL_13;
    goto LABEL_12;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
  v6 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v6 + 1;
  v7 = figTimelineCoordinatorTimelineStateCreateFromTimebase(*MEMORY[0x1E0C9AE00], a2, a3, v6, &cf);
  if (!(_DWORD)v7)
  {
    v10 = malloc_type_malloc(0x18uLL, 0x1020040A95220FAuLL);
    v11 = 1;
    goto LABEL_7;
  }
  v8 = v7;
  v9 = cf;
LABEL_12:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  v14 = v8;
LABEL_13:
  if (v9)
    CFRelease(v9);
  return v14;
}

uint64_t figTimelineCoordinatorTimelineStateCreateFromTimebase(uint64_t a1, const void *a2, CMTimebaseRef timebase, uint64_t a4, _QWORD *a5)
{
  float Rate;
  OpaqueCMClock *HostTimeClock;
  CMClockRef v12;
  uint64_t Internal;
  CMTime v15;
  CMTime time;
  CMTime v17;
  CMTime v18;
  CFTypeRef v19;

  v19 = 0;
  memset(&v18, 0, sizeof(v18));
  memset(&v17, 0, sizeof(v17));
  Rate = 0.0;
  if (a2)
  {
    if (timebase)
    {
      Rate = CMTimebaseGetRate(timebase);
      if (CMTimebaseGetEffectiveRate(timebase) == 0.0)
      {
        CMTimebaseGetTime(&v18, timebase);
      }
      else
      {
        HostTimeClock = CMClockGetHostTimeClock();
        CMClockGetTime(&v17, HostTimeClock);
        v12 = CMClockGetHostTimeClock();
        time = v17;
        CMSyncConvertTime(&v18, &time, v12, timebase);
      }
    }
    else
    {
      *(_OWORD *)&v18.value = *(_OWORD *)&kCMTimeZero.value;
      v18.epoch = 0;
      memset(&v17, 0, sizeof(v17));
    }
  }
  time = v18;
  v15 = v17;
  Internal = figTimelineCoordinatorTimelineStateCreateInternal(0.0, Rate, a1, a2, (__int128 *)&time.value, (__int128 *)&v15.value, 0, 0, a4, -1, 0, 1, (uint64_t *)&v19);
  if ((_DWORD)Internal)
  {
    if (v19)
      CFRelease(v19);
  }
  else
  {
    *a5 = v19;
  }
  return Internal;
}

void figTimelineCoordinator_switchToProposedTimelineWithNewIdentifierOnQueue(uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  _QWORD *v3;
  char v4;
  const __CFString *v5;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v7;
  uint64_t v8;
  unsigned int v9;
  const __CFString **v10;
  const void *v11;
  const void *v12;
  const void *v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  const __CFString **v18;
  const __CFArray *MutableCopy;
  const __CFArray *v20;
  CFIndex v21;
  CFIndex Count;
  const __CFDictionary **ValueAtIndex;
  const void *v24;
  BOOL v25;
  NSObject *v26;
  int v27;
  uint64_t v28;
  unsigned int v29;
  const __CFString *StateLoggingIdentifier;
  const __CFString **v31;
  CFIndex v32;
  CFIndex i;
  const __CFString *v34;
  NSObject *v35;
  int v36;
  uint64_t v37;
  unsigned int v38;
  const __CFString **v39;
  const void *v40;
  const void *v41;
  const void *Value;
  const void *v43;
  float v44;
  float v45;
  BOOL v46;
  char v47;
  int v48;
  BOOL v49;
  char v50;
  char v51;
  uint64_t v52;
  char v53;
  char v54;
  const __CFArray *v55;
  const __CFArray *v56;
  CFIndex v57;
  const __CFDictionary **v58;
  const __CFString *v59;
  int v60;
  CFIndex v61;
  NSObject *v62;
  int v63;
  uint64_t v64;
  unsigned int v65;
  const __CFString **v66;
  const void *v67;
  const void *v68;
  const void *v69;
  const void *v70;
  const void *v71;
  const void *v72;
  CFMutableArrayRef Mutable;
  const void *v74;
  const __CFArray *cf;
  uint64_t *v76;
  const __CFString *v77;
  const __CFString *v78;
  char v79;
  char v80;
  uint64_t v81;
  int v82;
  char v83;
  CMTime v84;
  CFTypeRef v85;
  char v86;
  os_log_type_t type;
  int v88;
  int v89;
  const char *v90;
  __int16 v91;
  uint64_t v92;
  __int16 v93;
  const __CFString *v94;
  __int16 v95;
  const void *v96;
  const __CFString *context;
  uint64_t v98;
  uint64_t v99;

  v1 = a1;
  v99 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3 = (_QWORD *)a1[1];
  v86 = 0;
  v4 = *(_BYTE *)(v2 + 360);
  v85 = 0;
  v79 = v4;
  if (v3)
    v5 = (const __CFString *)v3[11];
  else
    v5 = 0;
  if (dword_1EE141FE8)
  {
    v88 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, &v88, &type);
    v7 = v88;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v9 = v7;
    else
      v9 = v7 & 0xFFFFFFFE;
    if (v9)
    {
      v89 = 136315650;
      v90 = "figTimelineCoordinator_switchToProposedTimelineWithNewIdentifierOnQueue";
      v91 = 2112;
      v92 = v2;
      v93 = 2114;
      v94 = v5;
      v10 = (const __CFString **)_os_log_send_and_compose_impl();
      LOBYTE(v7) = v88;
    }
    else
    {
      v10 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v10, v10 != &context, v7, 0, v8);
  }
  v82 = FigCFEqual(v5, *(CFTypeRef *)(v2 + 352));
  v11 = *(const void **)(v2 + 296);
  *(_QWORD *)(v2 + 296) = v3;
  if (v3)
    CFRetain(v3);
  if (v11)
    CFRelease(v11);
  *(_QWORD *)(v2 + 336) = 0;
  *(_BYTE *)(v2 + 360) = 0;
  v12 = *(const void **)(v2 + 368);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(v2 + 368) = 0;
  }
  v13 = *(const void **)(v2 + 352);
  if (v13)
  {
    CFRelease(v13);
    *(_QWORD *)(v2 + 352) = 0;
  }
  v81 = (uint64_t)v3;
  figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue(v2, (const __CFArray **)&v85);
  if (figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons(v2, (CFArrayRef)v85))
  {
    if (dword_1EE141FE8)
    {
      v88 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v14 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, &v88, &type);
      v15 = v88;
      if (os_log_type_enabled(v14, type))
        v17 = v15;
      else
        v17 = v15 & 0xFFFFFFFE;
      if (v17)
      {
        v89 = 136315394;
        v90 = "figTimelineCoordinator_switchToProposedTimelineWithNewIdentifierOnQueue";
        v91 = 2112;
        v92 = v2;
        v18 = (const __CFString **)_os_log_send_and_compose_impl();
        LOBYTE(v15) = v88;
      }
      else
      {
        v18 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v18, v18 != &context, v15, 0, v16);
    }
  }
  else
  {
    v76 = v1;
    v77 = v5;
    cf = FigCFDictionaryCopyArrayOfKeys(*(const void **)(v2 + 216));
    MutableCopy = FigCFArrayCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], cf);
    v20 = FigCFDictionaryCopyArrayOfValues(*(const void **)(v2 + 328));
    figTimelineCoordinator_removeValueFromArray(MutableCopy, *(const void **)(v2 + 352));
    v21 = 0;
    do
    {
      if (v20)
        Count = CFArrayGetCount(v20);
      else
        Count = 0;
      if (v21 >= Count)
        break;
      ValueAtIndex = (const __CFDictionary **)CFArrayGetValueAtIndex(v20, v21);
      v24 = participantState_timelineIdentifier(ValueAtIndex[2]);
      if (figTimelineCoordinator_removeValueFromArray(MutableCopy, v24))
        v25 = dword_1EE141FE8 == 0;
      else
        v25 = 1;
      if (!v25)
      {
        v88 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        v26 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, &v88, &type);
        v27 = v88;
        if (os_log_type_enabled(v26, type))
          v29 = v27;
        else
          v29 = v27 & 0xFFFFFFFE;
        if (v29)
        {
          StateLoggingIdentifier = (const __CFString *)FigParticipantStateDictionaryGetStateLoggingIdentifier(ValueAtIndex[2]);
          v89 = 136315906;
          v90 = "figTimelineCoordinator_removeUnusedExpectations";
          v91 = 2112;
          v92 = v2;
          v93 = 2112;
          v94 = StateLoggingIdentifier;
          v95 = 2112;
          v96 = v24;
          v31 = (const __CFString **)_os_log_send_and_compose_impl();
          LOBYTE(v27) = v88;
        }
        else
        {
          v31 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v31, v31 != &context, v27, 0, v28);
      }
      if (!MutableCopy)
        break;
      ++v21;
    }
    while (CFArrayGetCount(MutableCopy));
    v32 = 0;
    if (!MutableCopy)
      goto LABEL_47;
LABEL_46:
    for (i = CFArrayGetCount(MutableCopy); v32 < i; i = 0)
    {
      v34 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v32);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v2 + 216), v34);
      if (dword_1EE141FE8)
      {
        v88 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        v35 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, &v88, &type);
        v36 = v88;
        if (os_log_type_enabled(v35, type))
          v38 = v36;
        else
          v38 = v36 & 0xFFFFFFFE;
        if (v38)
        {
          v89 = 136315650;
          v90 = "figTimelineCoordinator_removeUnusedExpectations";
          v91 = 2112;
          v92 = v2;
          v93 = 2112;
          v94 = v34;
          v39 = (const __CFString **)_os_log_send_and_compose_impl();
          LOBYTE(v36) = v88;
        }
        else
        {
          v39 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v39, v39 != &context, v36, 0, v37);
      }
      ++v32;
      if (MutableCopy)
        goto LABEL_46;
LABEL_47:
      ;
    }
    if (cf)
      CFRelease(cf);
    if (MutableCopy)
      CFRelease(MutableCopy);
    v1 = v76;
    v5 = v77;
    if (v20)
      CFRelease(v20);
  }
  v40 = *(const void **)(v2 + 352);
  *(_QWORD *)(v2 + 352) = v5;
  if (v5)
    CFRetain(v5);
  v41 = (const void *)v81;
  if (v40)
    CFRelease(v40);
  if (!v5 || (Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v2 + 216), v5)) == 0)
  {
    if (!v82)
    {
      *(_BYTE *)(v2 + 280) = *(_BYTE *)(v2 + 281) != 0;
      LODWORD(context) = 0;
      if (v5)
      {
        v55 = FigCFDictionaryCopyArrayOfValues(*(const void **)(v2 + 328));
        if (v55)
        {
          v56 = v55;
          if (CFArrayGetCount(v55) < 1)
          {
LABEL_91:
            CFRelease(v56);
          }
          else
          {
            v57 = 0;
            while (1)
            {
              v58 = (const __CFDictionary **)CFArrayGetValueAtIndex(v56, v57);
              v59 = (const __CFString *)participantState_timelineIdentifier(v58[2]);
              if (v59)
              {
                if (CFStringCompare(v5, v59, 0) == kCFCompareEqualTo)
                  break;
              }
              if (++v57 >= CFArrayGetCount(v56))
                goto LABEL_91;
            }
            CFRelease(v56);
            if (CFDictionaryContainsKey(*(CFDictionaryRef *)(v2 + 464), v5))
              FigCFDictionaryGetInt32IfPresent(*(_QWORD *)(v2 + 464), v5, &context);
          }
        }
      }
      v60 = (int)context;
      *(_DWORD *)(v2 + 456) = (_DWORD)context;
      if (v81 && *(float *)(v81 + 32) != 0.0)
      {
        *(_DWORD *)(v2 + 456) = v60 + 1;
        FigCFDictionarySetInt32(*(void **)(v2 + 464), v5, v60 + 1);
      }
    }
    v51 = 1;
    *(_BYTE *)(v2 + 304) = 1;
    v86 = 1;
    if (v81)
    {
      v43 = 0;
      if (*(float *)(v81 + 32) != 0.0)
      {
        v47 = 0;
        v53 = 0;
        v54 = 1;
        v50 = 1;
        v52 = v81;
        v46 = 1;
        v49 = 1;
        if (*(float *)(v81 + 36) != 0.0)
          goto LABEL_98;
        goto LABEL_83;
      }
      v53 = 0;
      v52 = v81;
    }
    else
    {
      v43 = 0;
      v52 = 0;
      v53 = 0;
    }
    v46 = 1;
    v49 = 1;
    goto LABEL_98;
  }
  v43 = Value;
  *((_QWORD *)Value + 2) = *(_QWORD *)(v81 + 16);
  v44 = *((float *)Value + 9);
  v45 = *(float *)(v81 + 36);
  if (v44 == 0.0)
    v44 = *((float *)Value + 8);
  if (v45 == 0.0)
    v45 = *(float *)(v81 + 32);
  v46 = v45 == v44;
  v47 = 1;
  *(_BYTE *)(v2 + 280) = 1;
  v48 = *((_DWORD *)Value + 25);
  *(_DWORD *)(v2 + 456) = v48;
  FigCFDictionarySetInt32(*(void **)(v2 + 464), *((const void **)Value + 11), v48);
  CMTimeMake(&v84, 1, 10);
  v49 = figTimelineCoordinator_timelinesMatch(v81, (uint64_t)v43, &v84, &v86);
  v50 = 0;
  v51 = 0;
  *(_BYTE *)(v2 + 304) = v49;
  v52 = (uint64_t)v43;
  v53 = 1;
  v54 = v79;
  if (v82)
  {
LABEL_83:
    *(_BYTE *)(v2 + 360) = v54;
    v51 = v50;
    v53 = v47;
  }
LABEL_98:
  if (*((_BYTE *)v1 + 16))
    *(_DWORD *)(v2 + 340) = 1;
  if (v52)
  {
    v80 = v49;
    v83 = v46;
    v61 = CFArrayGetCount(*(CFArrayRef *)(v2 + 432));
    if (v61 >= 1 && dword_1EE141FE8)
    {
      v78 = v5;
      v88 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v62 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, &v88, &type);
      v63 = v88;
      if (os_log_type_enabled(v62, type))
        v65 = v63;
      else
        v65 = v63 & 0xFFFFFFFE;
      if (v65)
      {
        v89 = 136315394;
        v90 = "figTimelineCoordinator_switchToProposedTimelineWithNewIdentifierOnQueue";
        v91 = 2112;
        v92 = v2;
        v66 = (const __CFString **)_os_log_send_and_compose_impl();
        LOBYTE(v63) = v88;
      }
      else
      {
        v66 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v66, v66 != &context, v63, 0, v64);
      v5 = v78;
      v41 = (const void *)v81;
    }
    FigSimpleMutexLock(*(pthread_mutex_t **)(v2 + 184));
    v70 = *(const void **)(v2 + 192);
    *(_QWORD *)(v2 + 192) = v41;
    if (v41)
      CFRetain(v41);
    if (v70)
      CFRelease(v70);
    v71 = *(const void **)(v2 + 200);
    *(_QWORD *)(v2 + 200) = v43;
    if ((v51 & 1) == 0)
      CFRetain(v43);
    if (v71)
      CFRelease(v71);
    v72 = *(const void **)(v2 + 208);
    if (v72)
    {
      CFRelease(v72);
      *(_QWORD *)(v2 + 208) = 0;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v2 + 184));
    if (v61 <= 0)
      figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(v2, v52, 6u, 1, v53, v86, v80, v83);
  }
  else
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(v2 + 184));
    v67 = *(const void **)(v2 + 200);
    if (v67)
    {
      CFRelease(v67);
      *(_QWORD *)(v2 + 200) = 0;
    }
    v68 = *(const void **)(v2 + 192);
    if (v68)
    {
      CFRelease(v68);
      *(_QWORD *)(v2 + 192) = 0;
    }
    v69 = *(const void **)(v2 + 208);
    if (v69)
    {
      CFRelease(v69);
      *(_QWORD *)(v2 + 208) = 0;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v2 + 184));
  }
  if (!v82)
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    context = v5;
    v98 = 0;
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(v2 + 328), (CFDictionaryApplierFunction)figTimelineCoordinator_updateParticipantsWithNewLocalIdentifierApply, &context);
    if ((_BYTE)v98)
      figTimelineCoordinator_postParticipantsDidChange((const void **)v2);
    if (Mutable)
      CFRelease(Mutable);
    figTimelineCoordinator_sendParticipantStateToGroupOnQueue(v2);
  }
  if (*v1)
    CFRelease((CFTypeRef)*v1);
  v74 = (const void *)v1[1];
  if (v74)
    CFRelease(v74);
  if (v85)
    CFRelease(v85);
  free(v1);
}

uint64_t FigTimelineCoordinatorHandleTransitionToNewTimelineFromTimelineControlProposingTimeAndPrerollRate(uint64_t a1, const void *a2, uint64_t a3, char a4, float a5)
{
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  _QWORD *v14;
  CFTypeRef v15;
  CFTypeRef v16;
  __int128 v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  CFTypeRef cf;

  cf = 0;
  if (a2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
    v10 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = v10 + 1;
    v11 = *MEMORY[0x1E0C9AE00];
    v12 = *(const void **)(a1 + 344);
    v20 = *(_OWORD *)a3;
    v21 = *(_QWORD *)(a3 + 16);
    v18 = *(_OWORD *)&kCMTimeInvalid.value;
    v19 = 0;
    v13 = figTimelineCoordinatorTimelineStateCreateInternal(a5, 0.0, v11, a2, &v20, &v18, 0, v12, v10, -1, 0, 1, (uint64_t *)&cf);
    v14 = malloc_type_malloc(0x18uLL, 0x1020040A95220FAuLL);
LABEL_4:
    v15 = CFRetain((CFTypeRef)a1);
    goto LABEL_5;
  }
  v14 = malloc_type_malloc(0x18uLL, 0x1020040A95220FAuLL);
  v13 = 0;
  if (a1)
    goto LABEL_4;
  v15 = 0;
LABEL_5:
  *v14 = v15;
  v16 = cf;
  if (cf)
    v16 = CFRetain(cf);
  v14[1] = v16;
  *((_BYTE *)v14 + 16) = a4;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v14, (dispatch_function_t)figTimelineCoordinator_switchToProposedTimelineWithNewIdentifierOnQueue);
  if (a2)
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  if (cf)
    CFRelease(cf);
  return v13;
}

uint64_t figTimelineCoordinatorTimelineStateCreateInternal(float a1, float a2, uint64_t a3, const void *a4, __int128 *a5, __int128 *a6, int a7, const void *a8, uint64_t a9, int a10, char a11, char a12, uint64_t *a13)
{
  uint64_t Instance;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  CFTypeRef v26;
  CFTypeRef v27;
  uint64_t v29;

  if (!a13)
    goto LABEL_19;
  if (!a4)
    goto LABEL_9;
  if (a2 != 0.0)
  {
    if (!a12 || (*((_DWORD *)a6 + 3) & 0x1D) == 1 && (*((_DWORD *)a5 + 3) & 0x1D) == 1)
      goto LABEL_9;
LABEL_19:
    v29 = 4294951585;
    return FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
  }
  if ((*((_BYTE *)a6 + 12) & 1) != 0)
  {
    *a6 = *(_OWORD *)&kCMTimeInvalid.value;
    *((_QWORD *)a6 + 2) = 0;
  }
LABEL_9:
  if (FigTimelineCoordinatorTimelineStateGetTypeID_sRegisterFigTimelineCoordinatorTimelineStateTypeOnce != -1)
    dispatch_once_f(&FigTimelineCoordinatorTimelineStateGetTypeID_sRegisterFigTimelineCoordinatorTimelineStateTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinatorTimelineStateType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v29 = 4294951586;
    return FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
  }
  v23 = Instance;
  *(float *)(Instance + 32) = a1;
  *(float *)(Instance + 36) = a2;
  v24 = *a5;
  *(_QWORD *)(Instance + 56) = *((_QWORD *)a5 + 2);
  *(_OWORD *)(Instance + 40) = v24;
  v25 = *a6;
  *(_QWORD *)(Instance + 80) = *((_QWORD *)a6 + 2);
  *(_OWORD *)(Instance + 64) = v25;
  if (a4)
    v26 = CFRetain(a4);
  else
    v26 = 0;
  *(_QWORD *)(v23 + 88) = v26;
  if (a8)
    v27 = CFRetain(a8);
  else
    v27 = 0;
  *(_QWORD *)(v23 + 16) = a9;
  *(_QWORD *)(v23 + 24) = v27;
  *(_DWORD *)(v23 + 96) = a7;
  *(_DWORD *)(v23 + 100) = a10;
  *(_BYTE *)(v23 + 104) = a11;
  *a13 = v23;
  return 0;
}

uint64_t FigTimelineCoordinatorExpectTransitionToNewTimelineFromTimelineControl()
{
  return 0;
}

uint64_t FigTimelineCoordinatorSetReadinessHintFromTimelineControl(dispatch_queue_t *a1, int a2)
{
  _DWORD *v4;
  CFTypeRef v5;

  v4 = malloc_type_malloc(0x10uLL, 0x10200403A5D3213uLL);
  if (a1)
    v5 = CFRetain(a1);
  else
    v5 = 0;
  *(_QWORD *)v4 = v5;
  v4[2] = a2;
  dispatch_async_f(a1[11], v4, (dispatch_function_t)figTimelineCoordinator_setReadinessHintFromTimelineControlOnQueue);
  return 0;
}

void figTimelineCoordinator_setReadinessHintFromTimelineControlOnQueue(_DWORD *a1)
{
  _DWORD *v2;
  int v3;

  v2 = *(_DWORD **)a1;
  v3 = a1[2];
  if (v2[84] != v3)
    v2[84] = v3;
  CFRelease(v2);
  free(a1);
}

uint64_t FigTimelineCoordinatorSetProperty(uint64_t a1, CFTypeRef cf1, const __CFArray *a3)
{
  CFMutableDictionaryRef Mutable;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v11;
  CFTypeID v12;
  const void *Value;
  const void *v14;
  CFTypeID v15;
  const void *v16;
  _BYTE *v17;
  uint64_t v18;
  CFTypeID v19;
  BOOL v20;

  if (a1 && cf1)
  {
    if (FigCFEqual(cf1, CFSTR("SuspensionWaitingPolicies")))
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      Count = CFArrayGetCount(a3);
      if (Count < 1)
      {
LABEL_11:
        FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 392));
        v16 = *(const void **)(a1 + 400);
        *(_QWORD *)(a1 + 400) = Mutable;
        if (Mutable)
          CFRetain(Mutable);
        if (v16)
          CFRelease(v16);
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 392));
        v17 = malloc_type_malloc(0x10uLL, 0x10200405F07FB98uLL);
        *(_QWORD *)v17 = CFRetain((CFTypeRef)a1);
        v17[8] = 0;
        dispatch_async_f(*(dispatch_queue_t *)(a1 + 88), v17, (dispatch_function_t)figTimelineCoordinator_reapplyExpectedTimelineDispatch);
        v18 = 0;
        if (!Mutable)
          return v18;
      }
      else
      {
        v8 = Count;
        v9 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a3, v9);
          if (!ValueAtIndex)
            break;
          v11 = ValueAtIndex;
          v12 = CFGetTypeID(ValueAtIndex);
          if (v12 != CFDictionaryGetTypeID())
            break;
          Value = CFDictionaryGetValue(v11, CFSTR("SuspensionReason"));
          if (!Value)
            break;
          v14 = Value;
          v15 = CFGetTypeID(Value);
          if (v15 != CFStringGetTypeID())
            break;
          CFDictionarySetValue(Mutable, v14, v11);
          if (v8 == ++v9)
            goto LABEL_11;
        }
        v18 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
        if (!Mutable)
          return v18;
      }
      CFRelease(Mutable);
      return v18;
    }
    if (!FigCFEqual(cf1, CFSTR("PauseSnapsToMediaTimeOfOriginator")))
    {
      if (!FigCFEqual(cf1, CFSTR("InternalSuspensionReasons")))
        return 4294954512;
      FigCFArrayAppendArray(*(__CFArray **)(a1 + 448), a3);
      return 0;
    }
    if (a3)
    {
      v19 = CFGetTypeID(a3);
      if (v19 == CFBooleanGetTypeID())
      {
        v20 = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
        FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 392));
        *(_BYTE *)(a1 + 408) = v20;
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 392));
        return 0;
      }
    }
  }
  return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

uint64_t FigTimelineCoordinatorCopyProperty(uint64_t a1, CFTypeRef cf1, uint64_t a3, CFArrayRef *a4)
{
  pthread_mutex_t *v7;
  uint64_t v8;
  int v9;
  CFArrayRef *v10;
  uint64_t v11;
  const __CFAllocator *v13;
  CMTime v14;

  if (a1 && cf1 && a4)
  {
    if (FigCFEqual(cf1, CFSTR("SuspensionWaitingPolicies")))
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 392));
      *a4 = FigCFDictionaryCopyArrayOfValues(*(const void **)(a1 + 400));
      v7 = *(pthread_mutex_t **)(a1 + 392);
    }
    else
    {
      if (FigCFEqual(cf1, CFSTR("PauseSnapsToMediaTimeOfOriginator")))
      {
        FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 392));
        v9 = *(unsigned __int8 *)(a1 + 408);
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 392));
        v8 = 0;
        v10 = (CFArrayRef *)MEMORY[0x1E0C9AE50];
        if (!v9)
          v10 = (CFArrayRef *)MEMORY[0x1E0C9AE40];
        *a4 = *v10;
        return v8;
      }
      if (FigCFEqual(cf1, CFSTR("PreferredAudioClockDeviceUID")))
      {
        FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 168));
        v11 = *(_QWORD *)(a1 + 176);
        if (v11)
          v8 = CMTimeSyncTimeOfDayClockCopyDeviceIdentifier(v11, a4);
        else
          v8 = 4294954513;
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
        return v8;
      }
      if (!FigCFEqual(cf1, CFSTR("NetworkToHostTimeOffset")))
        return 4294954512;
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 504));
      if ((*(_BYTE *)(a1 + 488) & 1) == 0)
        figTimelineCoordinator_setNetworkToHostTimeOffset(a1);
      v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v14 = *(CMTime *)(a1 + 476);
      *a4 = CMTimeCopyAsDictionary(&v14, v13);
      v7 = *(pthread_mutex_t **)(a1 + 504);
    }
    FigSimpleMutexUnlock(v7);
    return 0;
  }
  return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

uint64_t figTimelineCoordinator_setNetworkToHostTimeOffset(uint64_t a1)
{
  _QWORD *v2;
  uint64_t *v3;
  CFAllocatorRef v4;
  uint64_t HostTimeForClockTime;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int value;
  uint64_t v9;
  unsigned int v10;
  CMTime *v11;
  CMTime rhs;
  os_log_type_t type;
  CMTime v14;
  CMTime lhs;
  CMTime v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  memset(&v14, 0, sizeof(v14));
  v3 = (uint64_t *)(a1 + 176);
  v2 = *(_QWORD **)(a1 + 176);
  if (!v2)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 168));
    v4 = CFGetAllocator((CFTypeRef)a1);
    HostTimeForClockTime = CMTimeSyncTimeOfDayClockCreate((uint64_t)v4, v3);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
    if ((_DWORD)HostTimeForClockTime)
      return HostTimeForClockTime;
    v2 = (_QWORD *)*v3;
  }
  *(_OWORD *)&v16.value = *(_OWORD *)&kCMTimeZero.value;
  v16.epoch = 0;
  HostTimeForClockTime = CMTimeSyncTimeOfDayClockGetHostTimeForClockTime(v2, (uint64_t)&v16, &v14);
  if ((_DWORD)HostTimeForClockTime)
  {
    LODWORD(rhs.value) = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 0, (int *)&rhs, &type);
    value = rhs.value;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v10 = value;
    else
      v10 = value & 0xFFFFFFFE;
    if (v10)
    {
      LODWORD(lhs.value) = 136315394;
      *(CMTimeValue *)((char *)&lhs.value + 4) = (CMTimeValue)"figTimelineCoordinator_setNetworkToHostTimeOffset";
      LOWORD(lhs.flags) = 1024;
      *(CMTimeFlags *)((char *)&lhs.flags + 2) = HostTimeForClockTime;
      v11 = (CMTime *)_os_log_send_and_compose_impl();
      LOBYTE(value) = rhs.value;
    }
    else
    {
      v11 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 0, 1, v11, v11 != &v16, value, 0, v9);
  }
  else
  {
    lhs = v14;
    *(_OWORD *)&rhs.value = *(_OWORD *)&kCMTimeZero.value;
    rhs.epoch = 0;
    CMTimeSubtract(&v16, &lhs, &rhs);
    *(CMTime *)(a1 + 476) = v16;
  }
  return HostTimeForClockTime;
}

uint64_t FigTimelineCoordinatorCreate(const __CFAllocator *a1, uint64_t a2, _QWORD *a3, NSObject *a4, uint64_t a5, uint64_t *a6)
{
  unsigned int v11;
  uint64_t Instance;
  uint64_t v13;
  uint64_t v14;
  CFMutableDictionaryRef Mutable;
  pthread_mutex_t *v16;
  const __CFAllocator *v17;
  CFMutableDictionaryRef v18;
  pthread_mutex_t *v19;
  CFMutableArrayRef v20;
  CFMutableArrayRef v21;
  CFMutableArrayRef v22;
  pthread_mutex_t *v23;
  pthread_mutex_t *v24;
  pthread_mutex_t *v25;
  pthread_mutex_t *v26;
  pthread_mutex_t *v27;
  CFMutableDictionaryRef v28;
  void *v29;
  const dispatch_source_type_s *v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  void *v34;
  __int128 v35;
  __int128 v36;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  char *v42;
  os_log_type_t type;
  int v46[2];
  const char *v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  int v51;
  char v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v11 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigTimelineCoordinatorTrace[1], CFSTR("timelinecoordinator_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v11, 0, gFigTimelineCoordinatorTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1EE141FE8, CFSTR("timelinecoordinator_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1EE141FE0);
  if (FigTimelineCoordinatorGetTypeID_sRegisterFigTimelineCoordinatorTypeOnce != -1)
    dispatch_once_f(&FigTimelineCoordinatorGetTypeID_sRegisterFigTimelineCoordinatorTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinatorType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v13 = Instance;
  if (*a3 || !a3[1] || !a3[4] || !a3[2])
  {
    v14 = 4294951585;
    goto LABEL_36;
  }
  v14 = 4294951585;
  if (!a3[3] || !a2 || !a4)
    goto LABEL_36;
  *(_BYTE *)(v13 + 104) = 1;
  FigCFDictionaryGetBooleanIfPresent(a5, CFSTR("OnlySendFullyDefinedCommands"), (Boolean *)(v13 + 104));
  FigCFDictionaryGetBooleanIfPresent(a5, CFSTR("SkipEndSuspensionCommandsWhenAlone"), (Boolean *)(v13 + 440));
  FigCFDictionaryGetBooleanIfPresent(a5, CFSTR("IsInterstitialTimelineCoordinator"), (Boolean *)(v13 + 472));
  Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(v13 + 216) = Mutable;
  if (!Mutable)
    goto LABEL_34;
  v16 = FigSimpleMutexCreate();
  *(_QWORD *)(v13 + 184) = v16;
  if (!v16)
    goto LABEL_34;
  v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v18 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(v13 + 328) = v18;
  if (!v18)
    goto LABEL_34;
  v19 = FigSimpleMutexCreate();
  *(_QWORD *)(v13 + 320) = v19;
  if (!v19)
    goto LABEL_34;
  v20 = CFArrayCreateMutable(v17, 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(v13 + 424) = v20;
  if (!v20)
    goto LABEL_34;
  v21 = CFArrayCreateMutable(v17, 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(v13 + 432) = v21;
  if (!v21)
    goto LABEL_34;
  v22 = CFArrayCreateMutable(v17, 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(v13 + 448) = v22;
  if (!v22)
    goto LABEL_34;
  v23 = FigSimpleMutexCreate();
  *(_QWORD *)(v13 + 416) = v23;
  if (!v23)
    goto LABEL_34;
  v24 = FigSimpleMutexCreate();
  *(_QWORD *)(v13 + 16) = v24;
  if (!v24)
    goto LABEL_34;
  v25 = FigSimpleMutexCreate();
  *(_QWORD *)(v13 + 392) = v25;
  if (!v25)
    goto LABEL_34;
  v26 = FigSimpleMutexCreate();
  *(_QWORD *)(v13 + 168) = v26;
  if (!v26
    || (v27 = FigSimpleMutexCreate(), (*(_QWORD *)(v13 + 504) = v27) == 0)
    || (*(_QWORD *)(v13 + 24) = 1,
        *(_DWORD *)(v13 + 456) = 0,
        v28 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]),
        (*(_QWORD *)(v13 + 464) = v28) == 0))
  {
LABEL_34:
    v14 = 4294951586;
LABEL_36:
    FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    CFRelease((CFTypeRef)v13);
    return 0;
  }
  *(_BYTE *)(v13 + 281) = 0;
  v29 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject(v13);
  v30 = (const dispatch_source_type_s *)MEMORY[0x1E0C80DD0];
  v31 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, a4);
  *(_QWORD *)(v13 + 376) = v31;
  dispatch_source_set_timer(v31, 0xFFFFFFFFFFFFFFFFLL, 0, 0);
  dispatch_set_context(*(dispatch_object_t *)(v13 + 376), v29);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v13 + 376), (dispatch_function_t)figTimelineCoordinator_didFireAdvanceToNextCommandSource);
  dispatch_source_set_cancel_handler_f(*(dispatch_source_t *)(v13 + 376), (dispatch_function_t)figTimelineCoordinator_cancelAdvanceToNextCommandSource);
  dispatch_resume(*(dispatch_object_t *)(v13 + 376));
  v32 = dispatch_source_create(v30, 0, 0, a4);
  *(_QWORD *)(v13 + 112) = v32;
  dispatch_source_set_timer(v32, 0xFFFFFFFFFFFFFFFFLL, 0, 0);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v13 + 112), (dispatch_function_t)figTimelineCoordinator_handleMissedControlCallbackCompletionOnQueue);
  dispatch_source_set_cancel_handler_f(*(dispatch_source_t *)(v13 + 112), (dispatch_function_t)figTimelineCoordinator_cancelTimelineControlCommandCompletionTimer);
  v33 = *(NSObject **)(v13 + 112);
  v34 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject(v13);
  dispatch_set_context(v33, v34);
  dispatch_resume(*(dispatch_object_t *)(v13 + 112));
  v35 = *(_OWORD *)a3;
  v36 = *((_OWORD *)a3 + 2);
  *(_OWORD *)(v13 + 48) = *((_OWORD *)a3 + 1);
  *(_OWORD *)(v13 + 64) = v36;
  *(_OWORD *)(v13 + 32) = v35;
  *(_QWORD *)(v13 + 88) = a4;
  dispatch_retain(a4);
  *(_QWORD *)(v13 + 80) = FigCFWeakReferenceHolderCreateWithReferencedObject(a2);
  if (dword_1EE141FE8)
  {
    v46[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, v46, &type);
    v38 = v46[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v40 = v38;
    else
      v40 = v38 & 0xFFFFFFFE;
    if (v40)
    {
      v41 = *(unsigned __int8 *)(v13 + 472);
      v46[1] = 136315650;
      v47 = "FigTimelineCoordinatorCreate";
      v48 = 2048;
      v49 = v13;
      v50 = 1024;
      v51 = v41;
      v42 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v38) = v46[0];
    }
    else
    {
      v42 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v42, v42 != &v52, v38, 0, v39);
  }
  *a6 = v13;
  return 0;
}

void figTimelineCoordinator_didFireAdvanceToNextCommandSource(id *a1)
{
  id *v1;
  id *v2;
  int v3;
  uint64_t v4;
  CFArrayRef theArray;

  v1 = FigCFWeakReferenceHolderCopyReferencedObject(a1);
  if (v1)
  {
    v2 = v1;
    *((_BYTE *)v1 + 361) = 1;
    if (v1[28])
    {
      figTimelineCoordinator_issueAppropriateCommandsToMatchInProgressTimelineOnQueue((uint64_t)v1);
    }
    else if (!figTimelineCoordinator_anyParticipantIsSuspendedWithOnlyReasonsThatTriggerWaiting((uint64_t)v1))
    {
      theArray = 0;
      figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue((uint64_t)v2, &theArray);
      if (!theArray)
        goto LABEL_14;
      v3 = CFArrayGetCount(theArray) < 1
         ? 0
         : figTimelineCoordinator_groupShouldWaitForAllSuspensions((uint64_t)v2, theArray);
      if (theArray)
        CFRelease(theArray);
      if (!v3)
      {
LABEL_14:
        v4 = (uint64_t)v2[25];
        if (v4)
          figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue((uint64_t)v2, v4, 4u, 1, 1, 1, 1, 1);
      }
    }
    CFRelease(v2);
  }
}

void figTimelineCoordinator_cancelAdvanceToNextCommandSource(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void figTimelineCoordinator_handleMissedControlCallbackCompletionOnQueue(id *a1)
{
  id *v1;
  uint64_t v2;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v4;
  uint64_t v5;
  unsigned int v6;
  char *v7;
  os_log_type_t type;
  int v9[2];
  const char *v10;
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v1 = FigCFWeakReferenceHolderCopyReferencedObject(a1);
  if (v1)
  {
    v2 = (uint64_t)v1;
    figTimelineCoordinator_suspendTimelineControlCommandCompletionTimer((uint64_t)v1);
    ++*(_DWORD *)(v2 + 100);
    *(_BYTE *)(v2 + 96) = 0;
    v9[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 0, v9, &type);
    v4 = v9[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v6 = v4;
    else
      v6 = v4 & 0xFFFFFFFE;
    if (v6)
    {
      v9[1] = 136315138;
      v10 = "figTimelineCoordinator_handleMissedControlCallbackCompletionOnQueue";
      v7 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v4) = v9[0];
    }
    else
    {
      v7 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 0, 1, v7, v7 != &v11, v4, 0, v5);
    figTimelineCoordinator_issueAppropriateCommandsToMatchInProgressTimelineOnQueue(v2);
    figTimelineCoordinator_triggerTimelineChangesAfterParticipantChangeOnQueue(v2);
    CFRelease((CFTypeRef)v2);
  }
}

void figTimelineCoordinator_cancelTimelineControlCommandCompletionTimer(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

const void *FigTimelineStateDictionaryGetStateLoggingIdentifier(const __CFDictionary *a1)
{
  const void *Value;
  const void *v2;
  CFTypeID v3;

  if (!a1)
    return 0;
  Value = CFDictionaryGetValue(a1, CFSTR("DebugInfo"));
  if (!Value)
    return 0;
  v2 = Value;
  v3 = CFGetTypeID(Value);
  if (v3 != CFStringGetTypeID())
    return 0;
  return v2;
}

const void *FigParticipantStateDictionaryGetStateLoggingIdentifier(const __CFDictionary *a1)
{
  const void *Value;
  const void *v2;
  CFTypeID v3;

  if (!a1)
    return 0;
  Value = CFDictionaryGetValue(a1, CFSTR("DebugInfo"));
  if (!Value)
    return 0;
  v2 = Value;
  v3 = CFGetTypeID(Value);
  if (v3 != CFStringGetTypeID())
    return 0;
  return v2;
}

uint64_t FigXPCMessageSetTimelineCoordinatorSuspension(void *a1, const char *a2, uint64_t a3)
{
  if (a3)
    return FigXPCMessageSetCFString(a1, a2, *(CFTypeRef *)(a3 + 16));
  else
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyTimelineCoordinatorSuspension(void *a1, const char *a2, uint64_t *a3)
{
  uint64_t v4;
  CFTypeRef v5;
  uint64_t v6;
  CFTypeRef cf;

  cf = 0;
  if (a3)
  {
    v4 = FigXPCMessageCopyCFString(a1, a2, &cf);
    v5 = cf;
    if ((_DWORD)v4)
    {
      v6 = v4;
      if (!cf)
        return v6;
    }
    else
    {
      v6 = FigTimelineCoordinatorSuspensionCreate(*MEMORY[0x1E0C9AE00], cf, a3);
      v5 = cf;
      if (!cf)
        return v6;
    }
    CFRelease(v5);
    return v6;
  }
  return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetTimelineCoordinatorParticipantSnapshot(void *a1, const char *a2, uint64_t a3)
{
  xpc_object_t XPCDictionaryFromParticipantSnapshot;
  uint64_t v6;

  if (a3)
  {
    XPCDictionaryFromParticipantSnapshot = createXPCDictionaryFromParticipantSnapshot(a3);
    xpc_dictionary_set_value(a1, a2, XPCDictionaryFromParticipantSnapshot);
    v6 = 0;
  }
  else
  {
    v6 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    XPCDictionaryFromParticipantSnapshot = 0;
  }
  FigXPCRelease(XPCDictionaryFromParticipantSnapshot);
  return v6;
}

xpc_object_t createXPCDictionaryFromParticipantSnapshot(uint64_t a1)
{
  xpc_object_t v2;
  void *v3;
  void *v4;

  v2 = xpc_dictionary_create(0, 0, 0);
  if (*(_QWORD *)(a1 + 24))
  {
    v3 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    xpc_dictionary_set_value(v2, "LocalTimeline", v3);
    FigXPCRelease(v3);
  }
  v4 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  xpc_dictionary_set_value(v2, "SourceState", v4);
  FigXPCRelease(v4);
  return v2;
}

uint64_t FigXPCMessageCopyTimelineCoordinatorParticipantSnapshot(void *a1, const char *a2, uint64_t *a3)
{
  xpc_object_t value;

  if (!a3)
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  value = xpc_dictionary_get_value(a1, a2);
  return figTimelineCoordinatorParticipantCreateFromXPCDictionary(value, a3);
}

uint64_t figTimelineCoordinatorParticipantCreateFromXPCDictionary(void *a1, uint64_t *a2)
{
  const void *value;
  const __CFDictionary *v5;
  uint64_t v6;

  value = xpc_dictionary_get_value(a1, "LocalTimeline");
  v5 = (const __CFDictionary *)xpc_dictionary_get_value(a1, "SourceState");
  if (value)
    value = (const void *)_CFXPCCreateCFObjectFromXPCObject();
  if (v5)
    v5 = (const __CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
  v6 = figTimelineCoordinatorParticipantCreateFromDictionary(*MEMORY[0x1E0C9AE00], v5, value, a2);
  if (value)
    CFRelease(value);
  if (v5)
    CFRelease(v5);
  return v6;
}

uint64_t FigXPCMessageSetTimelineCoordinatorParticipantSnapshots(void *a1, const char *a2, const __CFArray *a3)
{
  xpc_object_t v6;
  CFIndex v7;
  const void *ValueAtIndex;
  uint64_t v9;
  CFTypeID v10;
  xpc_object_t XPCDictionaryFromParticipantSnapshot;
  uint64_t v12;

  if (a3)
  {
    v6 = xpc_array_create(0, 0);
    if (CFArrayGetCount(a3) < 1)
    {
LABEL_9:
      xpc_dictionary_set_value(a1, a2, v6);
      v12 = 0;
    }
    else
    {
      v7 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a3, v7);
        if (!ValueAtIndex)
          break;
        v9 = (uint64_t)ValueAtIndex;
        v10 = CFGetTypeID(ValueAtIndex);
        if (FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce != -1)
          dispatch_once_f(&FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinationParticipantSnapshotType);
        if (v10 != sFigTimelineCoordinationParticipantSnapshotID)
          break;
        XPCDictionaryFromParticipantSnapshot = createXPCDictionaryFromParticipantSnapshot(v9);
        xpc_array_append_value(v6, XPCDictionaryFromParticipantSnapshot);
        xpc_release(XPCDictionaryFromParticipantSnapshot);
        if (++v7 >= CFArrayGetCount(a3))
          goto LABEL_9;
      }
      v12 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    v12 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    v6 = 0;
  }
  FigXPCRelease(v6);
  return v12;
}

uint64_t FigXPCMessageCopyTimelineCoordinatorParticipantSnapshots(void *a1, const char *a2, __CFArray **a3)
{
  xpc_object_t array;
  void *v5;
  __CFArray *Mutable;
  size_t v7;
  xpc_object_t dictionary;
  uint64_t v9;
  uint64_t v10;
  void *value;

  if (!a3)
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  array = xpc_dictionary_get_array(a1, a2);
  if (!array)
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  v5 = array;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (xpc_array_get_count(v5))
  {
    v7 = 0;
    while (1)
    {
      value = 0;
      dictionary = xpc_array_get_dictionary(v5, v7);
      if (!dictionary)
        break;
      v9 = figTimelineCoordinatorParticipantCreateFromXPCDictionary(dictionary, (uint64_t *)&value);
      if ((_DWORD)v9)
        goto LABEL_13;
      CFArrayAppendValue(Mutable, value);
      if (value)
        CFRelease(value);
      if (++v7 >= xpc_array_get_count(v5))
        goto LABEL_10;
    }
    v9 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
LABEL_13:
    v10 = v9;
    if (Mutable)
      CFRelease(Mutable);
  }
  else
  {
LABEL_10:
    v10 = 0;
    *a3 = Mutable;
  }
  return v10;
}

double FigTimelineCoordinator_Init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[30] = 0u;
  a1[31] = 0u;
  a1[28] = 0u;
  a1[29] = 0u;
  a1[26] = 0u;
  a1[27] = 0u;
  a1[24] = 0u;
  a1[25] = 0u;
  a1[22] = 0u;
  a1[23] = 0u;
  a1[20] = 0u;
  a1[21] = 0u;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

const __CFAllocator *FigTimelineCoordinator_Finalize(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  NSObject *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  NSObject *v13;
  NSObject *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const __CFAllocator *result;

  v2 = *(const void **)(a1 + 296);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 296) = 0;
  }
  v3 = *(const void **)(a1 + 200);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 200) = 0;
  }
  v4 = *(const void **)(a1 + 192);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 192) = 0;
  }
  v5 = *(const void **)(a1 + 216);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 216) = 0;
  }
  FigSimpleMutexDestroy(*(_QWORD *)(a1 + 184));
  *(_QWORD *)(a1 + 184) = 0;
  v6 = *(NSObject **)(a1 + 88);
  if (v6)
    dispatch_release(v6);
  v7 = *(const void **)(a1 + 328);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(a1 + 328) = 0;
  }
  FigSimpleMutexDestroy(*(_QWORD *)(a1 + 320));
  *(_QWORD *)(a1 + 320) = 0;
  v8 = *(const void **)(a1 + 272);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 272) = 0;
  }
  v9 = *(const void **)(a1 + 288);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 288) = 0;
  }
  v10 = *(const void **)(a1 + 344);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 344) = 0;
  }
  v11 = *(const void **)(a1 + 352);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 352) = 0;
  }
  v12 = *(const void **)(a1 + 368);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(a1 + 368) = 0;
  }
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 376));
  v13 = *(NSObject **)(a1 + 376);
  if (v13)
  {
    dispatch_release(v13);
    *(_QWORD *)(a1 + 376) = 0;
  }
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 112));
  v14 = *(NSObject **)(a1 + 112);
  if (v14)
  {
    dispatch_release(v14);
    *(_QWORD *)(a1 + 112) = 0;
  }
  v15 = *(const void **)(a1 + 80);
  if (v15)
  {
    CFRelease(v15);
    *(_QWORD *)(a1 + 80) = 0;
  }
  v16 = *(const void **)(a1 + 160);
  if (v16)
  {
    CFRelease(v16);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v17 = *(const void **)(a1 + 176);
  if (v17)
  {
    CFRelease(v17);
    *(_QWORD *)(a1 + 176) = 0;
  }
  v18 = *(const void **)(a1 + 224);
  if (v18)
  {
    CFRelease(v18);
    *(_QWORD *)(a1 + 224) = 0;
  }
  v19 = *(const void **)(a1 + 464);
  if (v19)
  {
    CFRelease(v19);
    *(_QWORD *)(a1 + 464) = 0;
  }
  v20 = *(const void **)(a1 + 424);
  if (v20)
  {
    CFRelease(v20);
    *(_QWORD *)(a1 + 424) = 0;
  }
  v21 = *(const void **)(a1 + 432);
  if (v21)
  {
    CFRelease(v21);
    *(_QWORD *)(a1 + 432) = 0;
  }
  v22 = *(const void **)(a1 + 448);
  if (v22)
  {
    CFRelease(v22);
    *(_QWORD *)(a1 + 448) = 0;
  }
  FigSimpleMutexDestroy(*(_QWORD *)(a1 + 416));
  *(_QWORD *)(a1 + 416) = 0;
  v23 = *(const void **)(a1 + 400);
  if (v23)
  {
    CFRelease(v23);
    *(_QWORD *)(a1 + 400) = 0;
  }
  FigSimpleMutexDestroy(*(_QWORD *)(a1 + 392));
  *(_QWORD *)(a1 + 392) = 0;
  FigSimpleMutexDestroy(*(_QWORD *)(a1 + 168));
  *(_QWORD *)(a1 + 168) = 0;
  FigSimpleMutexDestroy(*(_QWORD *)(a1 + 16));
  *(_QWORD *)(a1 + 16) = 0;
  result = FigSimpleMutexDestroy(*(_QWORD *)(a1 + 504));
  *(_QWORD *)(a1 + 504) = 0;
  return result;
}

__CFString *FigTimelineCoordinator_CopyDescription(unsigned __int8 *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigTimelineCoordinator %p, Type %d>"), a1, a1[472]);
  return Mutable;
}

uint64_t FigTimelineCoordinatorSuspension_Init(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  return result;
}

void FigTimelineCoordinatorSuspension_Finalize(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

__CFString *FigTimelineCoordinatorSuspension_CopyDescription(_QWORD *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigTimelineCoordinatorSuspension %p, Reason %@>"), a1, a1[2]);
  return Mutable;
}

double FigTimelineCoordinatorTimelineState_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 112) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void FigTimelineCoordinatorTimelineState_Finalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  v2 = (const void *)a1[11];
  if (v2)
  {
    CFRelease(v2);
    a1[11] = 0;
  }
  v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  v4 = (const void *)a1[14];
  if (v4)
  {
    CFRelease(v4);
    a1[14] = 0;
  }
}

__CFString *FigTimelineCoordinatorTimelineState_CopyFormattingDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  __CFString *v4;
  const __CFUUID *v5;
  CFStringRef v6;
  __CFString *OriginatorLoggingIdentifier;
  Float64 Seconds;
  OpaqueCMClock *HostTimeClock;
  Float64 v10;
  Float64 v11;
  const char *v12;
  CMTime rhs;
  CMTime lhs;
  CMTime v16;
  CMTime time;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = Mutable;
  if (*(_QWORD *)(a1 + 112))
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("[%@] "), *(_QWORD *)(a1 + 112));
  }
  else
  {
    v5 = *(const __CFUUID **)(a1 + 24);
    if (v5)
    {
      v6 = CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v5);
      OriginatorLoggingIdentifier = figTimelineCoordinator_createOriginatorLoggingIdentifier(v6);
      CFStringAppendFormat(v4, 0, CFSTR("[%@] "), OriginatorLoggingIdentifier);
      if (v6)
        CFRelease(v6);
      if (OriginatorLoggingIdentifier)
        CFRelease(OriginatorLoggingIdentifier);
    }
  }
  CFStringAppendFormat(v4, 0, CFSTR("pr: %g r:%g"), *(float *)(a1 + 32), *(float *)(a1 + 36));
  if ((*(_BYTE *)(a1 + 52) & 1) != 0)
  {
    time = *(CMTime *)(a1 + 40);
    Seconds = CMTimeGetSeconds(&time);
    CFStringAppendFormat(v4, 0, CFSTR(" t:%.3f"), *(_QWORD *)&Seconds);
  }
  else
  {
    CFStringAppend(v4, CFSTR(" t:<INV>"));
  }
  if ((*(_BYTE *)(a1 + 76) & 1) != 0)
  {
    memset(&time, 0, sizeof(time));
    HostTimeClock = CMClockGetHostTimeClock();
    CMClockGetTime(&time, HostTimeClock);
    lhs = *(CMTime *)(a1 + 64);
    rhs = time;
    CMTimeSubtract(&v16, &lhs, &rhs);
    v10 = CMTimeGetSeconds(&v16);
    lhs = *(CMTime *)(a1 + 64);
    v11 = CMTimeGetSeconds(&lhs);
    CFStringAppendFormat(v4, 0, CFSTR(" ht:<NOW>%+.3f (%.3f)"), *(_QWORD *)&v10, *(_QWORD *)&v11);
  }
  else
  {
    CFStringAppend(v4, CFSTR(" ht:<INV>"));
  }
  v12 = "<A>";
  if (!*(_DWORD *)(a1 + 96))
    v12 = "<E>";
  CFStringAppendFormat(v4, 0, CFSTR(" sp:%s id: [%@]"), v12, *(_QWORD *)(a1 + 88));
  return v4;
}

CFStringRef FigTimelineCoordinatorTimelineState_CopyDebugDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<FigTimelineCoordinatorTimelineState %p - %@>"), a1, a1);
}

__CFString *figTimelineCoordinator_createOriginatorLoggingIdentifier(const void *a1)
{
  __CFString *Mutable;
  CFHashCode v3;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v3 = CFHash(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("%c%c%c%c"), (v3 % 0x1A) + 65, (v3 / 0x1A) - 26 * ((v3 / 0x1A * (unsigned __int128)0x9D89D89D89D89D9uLL) >> 64) + 65, (v3 / 0x2A4) - 26 * ((v3 / 0x2A4 * (unsigned __int128)0x9D89D89D89D89D9uLL) >> 64) + 65, (v3 / 0x44A8)- 26 * ((v3 / 0x44A8 * (unsigned __int128)0x9D89D89D89D89D9uLL) >> 64)+ 65);
  return Mutable;
}

double FigTimelineCoordinationParticipantSnapshot_Init(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void FigTimelineCoordinationParticipantSnapshot_Finalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  v2 = (const void *)a1[3];
  if (v2)
  {
    CFRelease(v2);
    a1[3] = 0;
  }
  v3 = (const void *)a1[2];
  if (v3)
  {
    CFRelease(v3);
    a1[2] = 0;
  }
  v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
  v5 = (const void *)a1[5];
  if (v5)
  {
    CFRelease(v5);
    a1[5] = 0;
  }
}

BOOL FigTimelineCoordinationParticipantSnapshot_Equal(int a1, CFTypeRef cf)
{
  CFTypeID v2;

  if (!cf)
    return 0;
  v2 = CFGetTypeID(cf);
  if (FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce != -1)
    dispatch_once_f(&FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinationParticipantSnapshotType);
  return v2 == sFigTimelineCoordinationParticipantSnapshotID;
}

CFHashCode FigTimelineCoordinationParticipantSnapshot_Hash(uint64_t a1)
{
  CFTypeRef v2;
  CFHashCode v3;
  CFHashCode v4;
  unsigned int v5;

  v2 = FigTimelineCoordinationParticipantSnapshotCopySuspensionReasons(a1);
  v3 = CFHash(v2);
  v4 = CFHash(*(CFTypeRef *)(a1 + 32));
  v5 = FigTimelineCoordinationParticipantSnapshotIsReadyToSetNonZeroRate(a1);
  if (v2)
    CFRelease(v2);
  return v4 | v3 | v5;
}

__CFString *FigTimelineCoordinationParticipantSnapshot_CopyDescription(const void *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigTimelineCoordinationParticipantSnapshot %p>"), a1);
  return Mutable;
}

BOOL figTimelineCoordinator_newTimelineStateShouldOverrideExistingState(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7;
  int v8;
  uint64_t v9;

  if (!a2)
    return 1;
  if (*(_BYTE *)(a3 + 104) || FigCFEqual(*(CFTypeRef *)(a1 + 272), *(CFTypeRef *)(a3 + 88)))
    return 1;
  v7 = *(_DWORD *)(a2 + 100);
  v8 = *(_DWORD *)(a3 + 100);
  if (v7 > v8)
    return 0;
  if (v7 < v8)
    return 1;
  v9 = figTimelineCoordinator_compareUUIDs(*(const __CFUUID **)(a2 + 24), *(const __CFUUID **)(a3 + 24));
  if (v9 == 1)
    return 0;
  if (v9)
    return 1;
  return FigCFEqual(*(CFTypeRef *)(a3 + 24), *(CFTypeRef *)(a1 + 344)) != 0;
}

BOOL figTimelineCoordinator_timelinesMatch(uint64_t a1, uint64_t a2, CMTime *a3, _BYTE *a4)
{
  _BOOL8 result;
  uint64_t v9;
  _BOOL4 IsWithinTolerance;
  float v11;
  float v12;
  CMTime v14;
  CMTime v15;
  CMTime v16;
  CMTime v17;
  CMTime v18;

  result = 0;
  memset(&v18, 0, sizeof(v18));
  memset(&v17, 0, sizeof(v17));
  if (a1 && a2)
  {
    if (!FigCFEqual(*(CFTypeRef *)(a1 + 88), *(CFTypeRef *)(a2 + 88)))
    {
      if (a4)
      {
        result = 0;
        *a4 = 0;
        return result;
      }
      return 0;
    }
    v9 = *(_QWORD *)(a1 + 88);
    if (v9)
      LOBYTE(v9) = (*(float *)(a1 + 36) == 0.0 || (*(_DWORD *)(a1 + 76) & 0x1D) == 1)
                && (*(_DWORD *)(a1 + 52) & 0x1D) == 1;
    if (*(_QWORD *)(a2 + 88) && (*(float *)(a2 + 36) == 0.0 || (*(_DWORD *)(a2 + 76) & 0x1D) == 1))
      LOBYTE(v9) = v9 ^ ((*(_DWORD *)(a2 + 52) & 0x1D) == 1);
    if ((v9 & 1) != 0)
      return 0;
    figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)a1, (CMTime *)&kCMTimeInvalid, &v18);
    figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)a2, (CMTime *)&kCMTimeInvalid, &v17);
    v16 = v18;
    v15 = v17;
    v14 = *a3;
    IsWithinTolerance = CMTimeDifferenceIsWithinTolerance(&v16, &v15, &v14);
    if (a4)
      *a4 = IsWithinTolerance;
    v11 = *(float *)(a1 + 36);
    v12 = *(float *)(a2 + 36);
    if (v11 == 0.0 && v11 == v12 && *(float *)(a1 + 32) != *(float *)(a2 + 32))
      return 0;
    return v11 == v12 && IsWithinTolerance;
  }
  return result;
}

void figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(uint64_t a1, uint64_t a2, unsigned int a3, char a4, char a5, char a6, char a7, char a8)
{
  CFIndex Count;
  BOOL v14;
  BOOL v15;
  uint64_t v16;
  BOOL v17;
  CFDictionaryRef v18;
  BOOL v19;
  uint64_t v20;
  BOOL IsWithinTolerance;
  const void *v22;
  const void *v23;
  __CFString *v24;
  const char *v25;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v27;
  uint64_t v28;
  unsigned int v29;
  const char *v30;
  const char *v31;
  const char *v32;
  const char *v33;
  const char *v34;
  double Seconds;
  char *v36;
  const char *v37;
  const char *v38;
  const char *v39;
  const char *v40;
  int v41;
  int v42;
  const char *v43;
  int v44;
  const char *v45;
  int v46;
  BOOL v47;
  const char *v48;
  const char *v49;
  const char *v51;
  BOOL v52;
  const char *v53;
  os_log_type_t type;
  int v57;
  CMTime rhs;
  CMTime lhs;
  CMTime v60;
  CMTime v61;
  CMTime time;
  __CFString *v63;
  __int16 v64;
  const char *v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  const char *v69;
  __int16 v70;
  const char *v71;
  __int16 v72;
  const char *v73;
  __int16 v74;
  const char *v75;
  __int16 v76;
  double v77;
  __int16 v78;
  const char *v79;
  __int16 v80;
  const char *v81;
  __int16 v82;
  const char *v83;
  __int16 v84;
  const char *v85;
  __int16 v86;
  const char *v87;
  char v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  if (a3)
    v52 = 0;
  else
    v52 = FigCFEqual(*(CFTypeRef *)(a1 + 272), *(CFTypeRef *)(a1 + 352)) == 0;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 432));
  v14 = Count > 0 && a3 == 1;
  v15 = a3 != 1 && Count > 0;
  v19 = a3 == 1
     && ((v16 = *(_QWORD *)(a1 + 200)) == 0 ? (v17 = 0) : (v17 = *(float *)(v16 + 36) != 0.0),
         (v18 = FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 328)), v17)
      || !v18
      || CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) >= 1)
     && *(_BYTE *)(a1 + 104) == 0;
  v20 = *(_QWORD *)(a1 + 200);
  if (v20 && *(float *)(v20 + 36) == 0.0)
  {
    figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)v20, (CMTime *)&kCMTimeInvalid, &v61);
    CMTimeMake(&v60, 1, 10);
    time = *(CMTime *)(a2 + 40);
    IsWithinTolerance = CMTimeDifferenceIsWithinTolerance(&v61, &time, &v60);
  }
  else
  {
    IsWithinTolerance = 0;
  }
  if ((*(float *)(a2 + 32) == 0.0 || *(float *)(a2 + 36) != 0.0) && *(_BYTE *)(a1 + 360))
  {
    *(_BYTE *)(a1 + 360) = 0;
    v22 = *(const void **)(a1 + 368);
    if (v22)
    {
      CFRelease(v22);
      *(_QWORD *)(a1 + 368) = 0;
    }
    figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
  }
  v23 = *(const void **)(a1 + 224);
  *(_QWORD *)(a1 + 224) = a2;
  CFRetain((CFTypeRef)a2);
  if (v23)
    CFRelease(v23);
  *(_BYTE *)(a1 + 261) = a5;
  *(_BYTE *)(a1 + 263) = IsWithinTolerance;
  *(_BYTE *)(a1 + 257) = a7;
  *(_BYTE *)(a1 + 256) = a6;
  figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)a2, (CMTime *)&kCMTimeInvalid, &lhs);
  figTimelineCoordinator_timelineTimeAtHostTime(*(CMTime **)(a1 + 192), (CMTime *)&kCMTimeInvalid, &rhs);
  CMTimeSubtract(&time, &lhs, &rhs);
  *(CMTime *)(a1 + 232) = time;
  *(_BYTE *)(a1 + 258) = a8;
  *(_BYTE *)(a1 + 262) = v52;
  *(_BYTE *)(a1 + 265) = v19;
  *(_BYTE *)(a1 + 259) = v14;
  *(_BYTE *)(a1 + 260) = v15;
  *(_BYTE *)(a1 + 264) = a4;
  *(_DWORD *)(a1 + 268) = a3;
  if (dword_1EE141FE8)
  {
    v24 = FigCFCopyCompactDescription((const __CFSet *)a2);
    if (a3 > 7)
      v25 = "Unknown";
    else
      v25 = off_1E28E3788[a3];
    if (dword_1EE141FE8)
    {
      v57 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, &v57, &type);
      v27 = v57;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v29 = v27;
      else
        v29 = v27 & 0xFFFFFFFE;
      if (v29)
      {
        if (*(_BYTE *)(a1 + 261))
          v30 = "Yes";
        else
          v30 = "No";
        if (*(_BYTE *)(a1 + 263))
          v31 = "Match";
        else
          v31 = "Mismatch";
        if (*(_BYTE *)(a1 + 258))
          v32 = "No";
        else
          v32 = "Yes";
        if (*(_BYTE *)(a1 + 257))
          v33 = "No";
        else
          v33 = "Yes";
        if (*(_BYTE *)(a1 + 256))
          v34 = "No";
        else
          v34 = "Yes";
        if (*(_BYTE *)(a1 + 256))
        {
          Seconds = NAN;
        }
        else
        {
          time = *(CMTime *)(a1 + 232);
          v53 = v33;
          v51 = v25;
          v37 = v31;
          v38 = v32;
          v39 = v34;
          Seconds = CMTimeGetSeconds(&time);
          v34 = v39;
          v32 = v38;
          v31 = v37;
          v25 = v51;
          v33 = v53;
        }
        v40 = "Politely";
        v41 = *(unsigned __int8 *)(a1 + 259);
        v42 = *(unsigned __int8 *)(a1 + 260);
        v43 = " Group";
        v44 = *(unsigned __int8 *)(a1 + 262);
        if (!*(_BYTE *)(a1 + 264))
          v40 = "Asap";
        *(CMTimeValue *)((char *)&time.value + 4) = (CMTimeValue)"figTimelineCoordinator_transitionToNewExpectedTimelineI"
                                                                 "ssuingCommandsWhenAppropriateOnQueue";
        LOWORD(time.flags) = 2112;
        v45 = "";
        LODWORD(time.value) = 136318722;
        if (!v41)
          v43 = "";
        v46 = v42 | v41;
        *(_QWORD *)((char *)&time.flags + 2) = a1;
        v47 = v42 == 0;
        HIWORD(time.epoch) = 2114;
        v48 = " Local";
        v63 = v24;
        if (v47)
          v48 = "";
        v64 = 2082;
        v65 = v25;
        if (!v46)
          v45 = " No";
        v66 = 2082;
        if (v44)
          v49 = "Yes";
        else
          v49 = "No";
        v67 = v30;
        v68 = 2082;
        v69 = v31;
        v70 = 2082;
        v71 = v32;
        v72 = 2082;
        v73 = v33;
        v74 = 2082;
        v75 = v34;
        v76 = 2048;
        v77 = Seconds;
        v78 = 2082;
        v79 = v40;
        v80 = 2082;
        v81 = v43;
        v82 = 2082;
        v83 = v48;
        v84 = 2082;
        v85 = v45;
        v86 = 2082;
        v87 = v49;
        v36 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v27) = v57;
      }
      else
      {
        v36 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v36, v36 != &v88, v27, 0, v28);
    }
    if (v24)
      CFRelease(v24);
  }
  figTimelineCoordinator_issueAppropriateCommandsToMatchInProgressTimelineOnQueue(a1);
}

uint64_t figTimelineCoordinator_compareUUIDs(const __CFUUID *a1, const __CFUUID *a2)
{
  CFUUIDBytes v4;
  CFUUIDBytes uu1;

  uu1 = CFUUIDGetUUIDBytes(a1);
  v4 = CFUUIDGetUUIDBytes(a2);
  return uuid_compare(&uu1.byte0, &v4.byte0);
}

BOOL CMTimeDifferenceIsWithinTolerance(CMTime *a1, CMTime *a2, CMTime *a3)
{
  CMTime v5;
  CMTime lhs;
  CMTime time;
  CMTime time1;

  lhs = *a1;
  v5 = *a2;
  CMTimeSubtract(&time, &lhs, &v5);
  CMTimeAbsoluteValue(&time1, &time);
  lhs = *a3;
  return CMTimeCompare(&time1, &lhs) < 1;
}

void figTimelineCoordinator_sendParticipantStateToGroupOnQueue(uint64_t a1)
{
  id *v2;
  const __CFAllocator *v3;
  __CFDictionary *Mutable;
  CFStringRef v5;
  _BOOL4 v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  __CFString *StateLoggingIdentifier;
  __CFString *v12;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v14;
  uint64_t v15;
  unsigned int v16;
  char *v17;
  os_log_type_t type;
  int v19;
  CFArrayRef theArray;
  int v21;
  const char *v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  __CFString *v26;
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  theArray = 0;
  if (!*(_QWORD *)(a1 + 344))
    return;
  if (!*(_QWORD *)(a1 + 160)
    || figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue(a1, &theArray)
    || figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons(a1, theArray))
  {
    Mutable = 0;
    StateLoggingIdentifier = 0;
    v2 = 0;
  }
  else
  {
    v2 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 160));
    if (v2)
    {
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v5 = CFUUIDCreateString(v3, *(CFUUIDRef *)(a1 + 344));
      CFDictionarySetValue(Mutable, CFSTR("UUID"), v5);
      FigCFDictionarySetInt32(Mutable, CFSTR("ProtocolVersion"), 0);
      if (*(_QWORD *)(a1 + 352))
      {
        v6 = CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) > 0 || (*(_DWORD *)(a1 + 340) & 1) == 0;
        CFDictionarySetValue(Mutable, CFSTR("CurrentIdentifier"), *(const void **)(a1 + 352));
        v7 = (const void *)*MEMORY[0x1E0C9AE50];
        v8 = (const void *)*MEMORY[0x1E0C9AE40];
        if (v6)
          v9 = (const void *)*MEMORY[0x1E0C9AE40];
        else
          v9 = (const void *)*MEMORY[0x1E0C9AE50];
        CFDictionarySetValue(Mutable, CFSTR("ReadyToSetNonZeroRate"), v9);
        if (*(_BYTE *)(a1 + 360))
          v10 = v7;
        else
          v10 = v8;
        CFDictionarySetValue(Mutable, CFSTR("CoordinatingStart"), v10);
      }
      if (theArray && CFArrayGetCount(theArray) >= 1)
        CFDictionarySetValue(Mutable, CFSTR("SuspensionReasons"), theArray);
      if (FigDebugIsInternalBuild())
      {
        StateLoggingIdentifier = figTimelineCoordinator_createStateLoggingIdentifier((uint64_t)CFSTR("Pa/"), v5, *(unsigned int *)(a1 + 384));
        FigCFDictionarySetValue(Mutable, CFSTR("DebugInfo"), StateLoggingIdentifier);
      }
      else
      {
        StateLoggingIdentifier = 0;
      }
      if (dword_1EE141FE8)
      {
        v12 = FigCFCopyCompactDescription(Mutable);
        if (dword_1EE141FE8)
        {
          v19 = 0;
          type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, &v19, &type);
          v14 = v19;
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
            v16 = v14;
          else
            v16 = v14 & 0xFFFFFFFE;
          if (v16)
          {
            v21 = 136315650;
            v22 = "figTimelineCoordinator_sendParticipantStateToGroupOnQueue";
            v23 = 2112;
            v24 = a1;
            v25 = 2114;
            v26 = v12;
            v17 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v14) = v19;
          }
          else
          {
            v17 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v17, v17 != &v27, v14, 0, v15);
        }
        if (v12)
          CFRelease(v12);
      }
      (*(void (**)(id *, __CFDictionary *))(a1 + 144))(v2, Mutable);
      ++*(_DWORD *)(a1 + 384);
      goto LABEL_35;
    }
    FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    Mutable = 0;
    StateLoggingIdentifier = 0;
  }
  v5 = 0;
LABEL_35:
  if (theArray)
    CFRelease(theArray);
  if (v2)
    CFRelease(v2);
  if (v5)
    CFRelease(v5);
  if (StateLoggingIdentifier)
    CFRelease(StateLoggingIdentifier);
  if (Mutable)
    CFRelease(Mutable);
}

void figTimelineCoordinator_issueAppropriateCommandsToMatchInProgressTimelineOnQueue(uint64_t a1)
{
  CFDictionaryRef Count;
  uint64_t v3;
  _BOOL4 v4;
  int v5;
  uint64_t v6;
  float v7;
  float v8;
  int v9;
  char *v10;
  const void *v11;
  CFTypeRef v12;
  _DWORD *v13;
  CFTypeRef v14;
  const void *v15;
  double v16;
  double v17;
  const void *v18;
  const __CFAllocator *v19;
  CFAbsoluteTime Current;
  NSObject *v21;
  dispatch_time_t v22;
  __CFString *v23;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int value;
  uint64_t v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  int v30;
  CMTime *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  float v38;
  int v39;
  const void *v40;
  const void *v41;
  const void *v42;
  const void *v43;
  const void *v44;
  const void *v45;
  _QWORD *v46;
  id *v47;
  int v48;
  OpaqueCMClock *HostTimeClock;
  const __CFUUID *v50;
  CFStringRef v51;
  uint64_t v52;
  id *v53;
  int v54;
  uint64_t v55;
  const __CFUUID *v56;
  uint64_t v57;
  _QWORD *v58;
  id *v59;
  id *v60;
  int v61;
  uint64_t v62;
  const __CFUUID *v63;
  CFStringRef v64;
  uint64_t v65;
  _QWORD *v66;
  id *v67;
  id *v68;
  uint64_t v69;
  int v70;
  const __CFUUID *v71;
  CFStringRef v72;
  const void *v73;
  char *v74;
  int32_t v75;
  void (*v76)(id *, uint64_t, uint64_t, CMTime *, CMTime *, CFStringRef, _QWORD, uint64_t, float, _QWORD *, void (*)(_QWORD *, OpaqueCMTimebase *));
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  float v80;
  uint64_t v81;
  _BOOL4 v82;
  _BOOL8 v83;
  float v84;
  float v85;
  OpaqueCMClock *v86;
  CFTypeRef v87;
  void (*v88)(id *, uint64_t, uint64_t, CMTime *, _BOOL8, BOOL, CFStringRef, uint64_t, float, CMTime *, _QWORD *, void (*)(_QWORD *, OpaqueCMTimebase *));
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  _BOOL4 v94;
  float v95;
  float v96;
  CFTypeRef v97;
  uint64_t v98;
  CFTypeRef v99;
  float v100;
  uint64_t v101;
  BOOL v102;
  CMTime *v103;
  const void *v104;
  CFStringRef v105;
  char v106;
  CMTime *p_time2;
  int32_t v108;
  const void *v109;
  CFStringRef v110;
  char *v111;
  const void *v112;
  CFTypeRef v113;
  CMTime *p_time1;
  int v115;
  int v116;
  CFTypeRef cf;
  CMTime v118;
  CMTime time2;
  CMTime type;
  CMTime v121;
  CMTime time1;
  int v123;
  __int16 v124;
  int v125;
  __int16 v126;
  int v127;
  __int16 v128;
  int v129;
  __int16 v130;
  __CFString *v131;
  CMTime theArray[5];
  uint64_t v133;

  v133 = *MEMORY[0x1E0C80C00];
  Count = FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 328));
  cf = 0;
  v3 = *(_QWORD *)(a1 + 224);
  if (v3)
  {
    v4 = Count
      || *(_BYTE *)(a1 + 104)
      || *(float *)(v3 + 36) != 0.0
      && *(_QWORD *)(v3 + 88)
      && (*(_DWORD *)(v3 + 76) & 0x1D) == 1
      && (*(_DWORD *)(v3 + 52) & 0x1D) == 1;
    v5 = 1718185504;
    if (!*(_BYTE *)(a1 + 360) || *(_BYTE *)(a1 + 259) || figTimelineCoordinator_everyoneIsSuspended(a1))
    {
      if (CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) >= 1 && !*(_BYTE *)(a1 + 259))
        goto LABEL_71;
      if (!*(_BYTE *)(a1 + 256))
      {
        v9 = 1786080624;
        if (v4 && *(float *)(*(_QWORD *)(a1 + 224) + 36) != 0.0)
          v9 = 1918989413;
        goto LABEL_66;
      }
      v6 = *(_QWORD *)(a1 + 224);
      v7 = *(float *)(v6 + 36);
      if (*(_BYTE *)(a1 + 257))
      {
        if (v7 != 0.0)
          goto LABEL_71;
        v8 = *(float *)(v6 + 32);
        if (v8 != 0.0 && (*(_BYTE *)(a1 + 340) & 1) == 0)
        {
          v9 = 1886545264;
          goto LABEL_66;
        }
        if (v8 != 0.0 || (*(_BYTE *)(a1 + 340) & 1) == 0)
          goto LABEL_71;
      }
      else if (v7 != 0.0)
      {
        v9 = 1918989413;
        if ((*(_BYTE *)(v6 + 76) & 1) == 0 && *(_BYTE *)(a1 + 104))
        {
          if (figTimelineCoordinatorTimelineStateCopy(*MEMORY[0x1E0C9AE00], v6, &cf))
            goto LABEL_239;
          v10 = (char *)cf;
          figTimelineCoordinator_pickHostTimeForCoordinatedStart(a1, theArray);
          *(CMTime *)(v10 + 64) = theArray[0];
          v11 = *(const void **)(a1 + 224);
          v12 = cf;
          *(_QWORD *)(a1 + 224) = cf;
          if (v12)
            CFRetain(v12);
          if (v11)
            CFRelease(v11);
        }
        goto LABEL_66;
      }
      v9 = 1885435251;
LABEL_66:
      if (v9 == 1718185504)
      {
        v5 = 1718185504;
      }
      else
      {
        v5 = v9;
        if (*(_BYTE *)(a1 + 96))
        {
          v5 = 2002872692;
          if (*(_DWORD *)(a1 + 268) == 1)
          {
            *(_WORD *)(a1 + 256) = 257;
            *(_BYTE *)(a1 + 258) = 1;
          }
        }
      }
LABEL_71:
      if (dword_1EE141FE8)
      {
        v23 = FigCFCopyCompactDescription(*(const __CFSet **)(a1 + 224));
        if (dword_1EE141FE8)
        {
          LODWORD(v121.value) = 0;
          LOBYTE(type.value) = 0;
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, (int *)&v121, &type);
          value = v121.value;
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type.value))
            v27 = value;
          else
            v27 = value & 0xFFFFFFFE;
          if (v27)
          {
            v28 = HIBYTE(v5);
            v29 = MEMORY[0x1E0C80978];
            if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * HIBYTE(v5) + 60) & 0x40000) == 0)
              v28 = 46;
            v116 = v28;
            if (BYTE2(v5) > 0x7Fu)
              v30 = __maskrune(BYTE2(v5), 0x40000uLL);
            else
              v30 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * BYTE2(v5) + 60) & 0x40000;
            if (v30)
              v32 = BYTE2(v5);
            else
              v32 = 46;
            if (BYTE1(v5) > 0x7Fu)
              v33 = __maskrune(BYTE1(v5), 0x40000uLL);
            else
              v33 = *(_DWORD *)(v29 + 4 * BYTE1(v5) + 60) & 0x40000;
            if (v33)
              v34 = BYTE1(v5);
            else
              v34 = 46;
            if (v5 > 0x7Fu)
              v35 = __maskrune(v5, 0x40000uLL);
            else
              v35 = *(_DWORD *)(v29 + 4 * v5 + 60) & 0x40000;
            *(CMTimeValue *)((char *)&time1.value + 4) = (CMTimeValue)"figTimelineCoordinator_issueAppropriateCommandsToM"
                                                                      "atchInProgressTimelineOnQueue";
            LODWORD(time1.value) = 136316674;
            if (v35)
              v36 = v5;
            else
              v36 = 46;
            LOWORD(time1.flags) = 2112;
            *(_QWORD *)((char *)&time1.flags + 2) = a1;
            HIWORD(time1.epoch) = 1024;
            v123 = v116;
            v124 = 1024;
            v125 = v32;
            v126 = 1024;
            v127 = v34;
            v128 = 1024;
            v129 = v36;
            v130 = 2114;
            v131 = v23;
            v115 = 56;
            p_time1 = &time1;
            v31 = (CMTime *)_os_log_send_and_compose_impl();
            LOBYTE(value) = v121.value;
          }
          else
          {
            v31 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v31, v31 != theArray, value, 0, v26);
        }
        if (v23)
          CFRelease(v23);
      }
      v37 = *(_QWORD *)(a1 + 224);
      if (*(_QWORD *)(v37 + 88))
      {
        v38 = *(float *)(v37 + 36);
        if ((v38 == 0.0 || (*(_DWORD *)(v37 + 76) & 0x1D) == 1)
          && (*(_DWORD *)(v37 + 52) & 0x1D) == 1
          && v37 != *(_QWORD *)(a1 + 200)
          && !*(_BYTE *)(a1 + 259))
        {
          v39 = *(unsigned __int8 *)(a1 + 261);
          if (v38 == 0.0 || (*(_DWORD *)(v37 + 76) & 0x1D) == 1)
          {
            FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 184));
            v40 = *(const void **)(a1 + 200);
            v41 = *(const void **)(a1 + 224);
            *(_QWORD *)(a1 + 200) = v41;
            if (v41)
              CFRetain(v41);
            if (v40)
              CFRelease(v40);
            v42 = *(const void **)(a1 + 208);
            if (v42)
            {
              CFRelease(v42);
              *(_QWORD *)(a1 + 208) = 0;
            }
            FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 184));
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 216), *(const void **)(*(_QWORD *)(a1 + 224) + 88), *(const void **)(a1 + 224));
            if (!v39)
              figTimelineCoordinator_sendExpectedTimelineStateToGroupOnQueue(a1);
          }
          *(_BYTE *)(a1 + 261) = 1;
        }
      }
      if (!*(_BYTE *)(a1 + 260))
      {
        v43 = *(const void **)(a1 + 192);
        v44 = *(const void **)(a1 + 224);
        *(_QWORD *)(a1 + 192) = v44;
        if (v44)
          CFRetain(v44);
        if (v43)
          CFRelease(v43);
      }
      *(_DWORD *)(a1 + 336) = 0;
      v45 = *(const void **)(a1 + 208);
      if (v45)
      {
        CFRelease(v45);
        *(_QWORD *)(a1 + 208) = 0;
      }
      if (v5 > 1885435250)
      {
        if (v5 == 1885435251)
        {
          v57 = *(_QWORD *)(a1 + 368);
          v58 = malloc_type_malloc(0x20uLL, 0x10200405C7134C3uLL);
          v59 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 80));
          if (v59)
          {
            v60 = v59;
            v61 = *(_DWORD *)(a1 + 100);
            v62 = *(_QWORD *)(a1 + 224);
            if (*(_BYTE *)(a1 + 262) && (v63 = *(const __CFUUID **)(v62 + 24)) != 0)
            {
              v64 = CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v63);
              v62 = *(_QWORD *)(a1 + 224);
            }
            else
            {
              v64 = 0;
            }
            v95 = *(float *)(v62 + 32);
            if (v95 == 0.0)
              v96 = 0.0;
            else
              v96 = *(float *)(v62 + 32);
            if (*(_DWORD *)(a1 + 340))
            {
              *(_DWORD *)(a1 + 340) = 0;
              figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
            }
            figTimelineCoordinator_startTimeoutForTimelineControlCommandOnQueue(a1);
            v97 = *(CFTypeRef *)(a1 + 224);
            if (v97)
              v97 = CFRetain(v97);
            v58[1] = v97;
            *v58 = CFRetain((CFTypeRef)a1);
            *((_DWORD *)v58 + 4) = v61;
            *((_BYTE *)v58 + 20) = v95 != 0.0;
            *(_BYTE *)(a1 + 96) = 1;
            if (v95 == 0.0)
              v98 = 0;
            else
              v98 = v57;
            (*(void (**)(id *, _QWORD, _QWORD, BOOL, CFStringRef, uint64_t, _QWORD, _QWORD *, float, void (*)(_QWORD *, OpaqueCMTimebase *), int))(a1 + 56))(v60, *(_QWORD *)(*(_QWORD *)(a1 + 224) + 88), *(_QWORD *)(*(_QWORD *)(a1 + 224) + 16), v95 != 0.0, v64, v98, *(unsigned int *)(a1 + 268), v58, v96, figTimelineCoordinator_timelineControlCommandCompletion, v115);
            if (v64)
            {
              if (!*(_BYTE *)(a1 + 258))
                figTimelineCoordinator_postDidIssueSetRateCommandNotification((const void *)a1, v64, v96);
              CFRelease(v64);
            }
            CFRelease(v60);
            v58 = 0;
          }
          else
          {
            FigSignalErrorAt(4294951581, 0, 0, 0, 0, 0, 0);
          }
          free(v58);
          *(_BYTE *)(a1 + 304) = 0;
          *(_WORD *)(a1 + 257) = 257;
          goto LABEL_239;
        }
        if (v5 == 1886545264)
        {
          v65 = *(_QWORD *)(a1 + 368);
          v66 = malloc_type_malloc(0x20uLL, 0x10200405C7134C3uLL);
          v67 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 80));
          if (v67)
          {
            v68 = v67;
            v69 = *(_QWORD *)(a1 + 224);
            if (*(float *)(v69 + 32) != 0.0)
            {
              v70 = *(_DWORD *)(a1 + 100);
              if (*(_BYTE *)(a1 + 262) && (v71 = *(const __CFUUID **)(v69 + 24)) != 0)
                v72 = CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v71);
              else
                v72 = 0;
              if (*(_DWORD *)(a1 + 340))
              {
                *(_DWORD *)(a1 + 340) = 0;
                figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
              }
              figTimelineCoordinator_startTimeoutForTimelineControlCommandOnQueue(a1);
              v99 = *(CFTypeRef *)(a1 + 224);
              if (v99)
                v99 = CFRetain(v99);
              v66[1] = v99;
              *v66 = CFRetain((CFTypeRef)a1);
              *((_DWORD *)v66 + 4) = v70;
              *((_BYTE *)v66 + 20) = 1;
              *(_BYTE *)(a1 + 96) = 1;
              (*(void (**)(id *, _QWORD, _QWORD, CFStringRef, uint64_t, _QWORD, _QWORD *, void (*)(_QWORD *, OpaqueCMTimebase *), float, CMTime *, int))(a1 + 64))(v68, *(_QWORD *)(*(_QWORD *)(a1 + 224) + 88), *(_QWORD *)(*(_QWORD *)(a1 + 224) + 16), v72, v65, *(unsigned int *)(a1 + 268), v66, figTimelineCoordinator_timelineControlCommandCompletion, *(float *)(*(_QWORD *)(a1 + 224) + 32), p_time1, v115);
              if (v72)
              {
                if (!*(_BYTE *)(a1 + 258))
                  figTimelineCoordinator_postDidIssueSetRateCommandNotification((const void *)a1, v72, *(float *)(*(_QWORD *)(a1 + 224) + 32));
                CFRelease(v72);
              }
              v66 = 0;
            }
            CFRelease(v68);
          }
          else
          {
            FigSignalErrorAt(4294951581, 0, 0, 0, 0, 0, 0);
          }
          free(v66);
          *(_BYTE *)(a1 + 304) = 0;
          goto LABEL_238;
        }
        if (v5 != 1918989413)
          goto LABEL_239;
        v46 = malloc_type_malloc(0x20uLL, 0x10200405C7134C3uLL);
        v47 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 80));
        memset(theArray, 0, 24);
        memset(&time1, 0, sizeof(time1));
        v48 = *(_DWORD *)(a1 + 100);
        memset(&v121, 0, sizeof(v121));
        HostTimeClock = CMClockGetHostTimeClock();
        CMClockGetTime(&v121, HostTimeClock);
        if (v47)
        {
          if (*(_BYTE *)(a1 + 262) && (v50 = *(const __CFUUID **)(*(_QWORD *)(a1 + 224) + 24)) != 0)
            v51 = CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v50);
          else
            v51 = 0;
          if (*(_DWORD *)(a1 + 340))
          {
            *(_DWORD *)(a1 + 340) = 0;
            figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
          }
          figTimelineCoordinator_startTimeoutForTimelineControlCommandOnQueue(a1);
          v74 = *(char **)(a1 + 224);
          if ((v74[52] & 1) == 0 || (v74[76] & 1) == 0)
            goto LABEL_158;
          theArray[0] = *(CMTime *)(v74 + 40);
          time1 = *(CMTime *)(v74 + 64);
          type = *(CMTime *)(v74 + 64);
          time2 = v121;
          v75 = CMTimeCompare(&type, &time2);
          v74 = *(char **)(a1 + 224);
          if (v75 < 0)
          {
            time1 = v121;
            type = v121;
            figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)v74, &type, theArray);
            v74 = *(char **)(a1 + 224);
          }
          if (v74)
LABEL_158:
            v74 = (char *)CFRetain(v74);
          v46[1] = v74;
          *v46 = CFRetain((CFTypeRef)a1);
          *((_DWORD *)v46 + 4) = v48;
          *((_BYTE *)v46 + 20) = 0;
          *(_BYTE *)(a1 + 96) = 1;
          v76 = *(void (**)(id *, uint64_t, uint64_t, CMTime *, CMTime *, CFStringRef, _QWORD, uint64_t, float, _QWORD *, void (*)(_QWORD *, OpaqueCMTimebase *)))(a1 + 40);
          v77 = *(_QWORD *)(a1 + 352);
          v78 = *(_QWORD *)(a1 + 224);
          v79 = *(_QWORD *)(v78 + 16);
          v80 = *(float *)(v78 + 36);
          v81 = *(unsigned int *)(a1 + 268);
          type = theArray[0];
          time2 = time1;
          v76(v47, v77, v79, &type, &time2, v51, 0, v81, v80, v46, figTimelineCoordinator_timelineControlCommandCompletion);
          if (!v51)
            goto LABEL_236;
          if (*(_BYTE *)(a1 + 256))
          {
            v82 = 0;
          }
          else
          {
            time2 = *(CMTime *)(a1 + 232);
            CMTimeAbsoluteValue(&type, &time2);
            CMTimeMake(&time2, 1, 1);
            v82 = CMTimeCompare(&type, &time2) >= 0;
          }
          v100 = *(float *)(*(_QWORD *)(a1 + 224) + 36);
          v102 = v100 != 0.0
              && (v101 = *(_QWORD *)(a1 + 192), *(float *)(v101 + 36) == 0.0)
              && v100 == *(float *)(v101 + 32);
          if (!*(_BYTE *)(a1 + 258) && v82)
          {
            v118 = theArray[0];
            v103 = &v118;
            v104 = (const void *)a1;
            v105 = v51;
LABEL_217:
            figTimelineCoordinator_postDidIssueSetRateAndTimeCommandNotification(v104, v105, v103, v100);
LABEL_235:
            CFRelease(v51);
LABEL_236:
            CFRelease(v47);
            v46 = 0;
LABEL_237:
            free(v46);
            *(_BYTE *)(a1 + 304) = 0;
            *(_WORD *)(a1 + 256) = 257;
LABEL_238:
            *(_BYTE *)(a1 + 258) = 1;
            goto LABEL_239;
          }
          if (*(_BYTE *)(a1 + 258))
          {
            v106 = !v82 || v102;
            if ((v106 & 1) != 0)
              goto LABEL_235;
            v118 = theArray[0];
            p_time2 = &v118;
LABEL_229:
            figTimelineCoordinator_postDidIssueSetTimeCommandNotification((const void *)a1, v51, p_time2);
            goto LABEL_235;
          }
          v109 = (const void *)a1;
          v110 = v51;
LABEL_234:
          figTimelineCoordinator_postDidIssueSetRateCommandNotification(v109, v110, v100);
          goto LABEL_235;
        }
LABEL_249:
        FigSignalErrorAt(4294951581, 0, 0, 0, 0, 0, 0);
        goto LABEL_237;
      }
      if (v5 == 1718185504)
      {
        v73 = *(const void **)(a1 + 224);
        if (v73)
        {
          CFRelease(v73);
          *(_QWORD *)(a1 + 224) = 0;
        }
        goto LABEL_239;
      }
      v52 = *(_QWORD *)(a1 + 368);
      v46 = malloc_type_malloc(0x20uLL, 0x10200405C7134C3uLL);
      v53 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 80));
      if (!v53)
        goto LABEL_249;
      v47 = v53;
      v54 = *(_DWORD *)(a1 + 100);
      v55 = *(_QWORD *)(a1 + 224);
      if (*(_BYTE *)(a1 + 262) && (v56 = *(const __CFUUID **)(v55 + 24)) != 0)
      {
        v51 = CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v56);
        v55 = *(_QWORD *)(a1 + 224);
      }
      else
      {
        v51 = 0;
      }
      v83 = *(_BYTE *)(a1 + 265) == 0;
      v84 = *(float *)(v55 + 32);
      if (v84 == 0.0)
        v85 = 0.0;
      else
        v85 = *(float *)(v55 + 32);
      if (*(_DWORD *)(a1 + 340))
      {
        *(_DWORD *)(a1 + 340) = 0;
        figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
        v55 = *(_QWORD *)(a1 + 224);
      }
      theArray[0] = *(CMTime *)(v55 + 40);
      if (*(float *)(v55 + 36) != 0.0 && (*(_BYTE *)(v55 + 76) & 1) != 0)
      {
        v86 = CMClockGetHostTimeClock();
        CMClockGetTime(&v121, v86);
        figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)v55, &v121, &time1);
        theArray[0] = time1;
      }
      figTimelineCoordinator_startTimeoutForTimelineControlCommandOnQueue(a1);
      v87 = *(CFTypeRef *)(a1 + 224);
      if (v87)
        v87 = CFRetain(v87);
      v46[1] = v87;
      *v46 = CFRetain((CFTypeRef)a1);
      *((_DWORD *)v46 + 4) = v54;
      *((_BYTE *)v46 + 20) = v84 != 0.0;
      *(_BYTE *)(a1 + 96) = 1;
      v88 = *(void (**)(id *, uint64_t, uint64_t, CMTime *, _BOOL8, BOOL, CFStringRef, uint64_t, float, CMTime *, _QWORD *, void (*)(_QWORD *, OpaqueCMTimebase *)))(a1 + 48);
      v89 = *(_QWORD *)(a1 + 224);
      v90 = *(_QWORD *)(v89 + 88);
      v91 = *(_QWORD *)(v89 + 16);
      if (v84 == 0.0)
        v92 = 0;
      else
        v92 = v52;
      v93 = *(_DWORD *)(a1 + 268);
      time1 = theArray[0];
      LODWORD(p_time1) = v93;
      v88(v47, v90, v91, &time1, v83, v84 != 0.0, v51, v92, v85, p_time1, v46, figTimelineCoordinator_timelineControlCommandCompletion);
      if (!v51)
        goto LABEL_236;
      if (*(_BYTE *)(a1 + 256))
      {
        if (*(_BYTE *)(a1 + 258))
        {
          v94 = 0;
          goto LABEL_226;
        }
      }
      else
      {
        type = *(CMTime *)(a1 + 232);
        CMTimeAbsoluteValue(&time1, &type);
        CMTimeMake(&type, 1, 1);
        v108 = CMTimeCompare(&time1, &type);
        if (*(_BYTE *)(a1 + 258))
        {
          v94 = v108 >= 0;
LABEL_226:
          if (!*(_BYTE *)(a1 + 257) && !v94)
            goto LABEL_235;
          time2 = theArray[0];
          p_time2 = &time2;
          goto LABEL_229;
        }
        if ((v108 & 0x80000000) == 0)
        {
          time2 = theArray[0];
          v103 = &time2;
          v104 = (const void *)a1;
          v105 = v51;
          v100 = v85;
          goto LABEL_217;
        }
      }
      v109 = (const void *)a1;
      v110 = v51;
      v100 = v85;
      goto LABEL_234;
    }
    if (*(_BYTE *)(a1 + 256))
    {
      if (v4)
      {
        if (!*(_BYTE *)(a1 + 257))
        {
          v9 = 1885435251;
          goto LABEL_48;
        }
        if (figTimelineCoordinator_timelineControlMustPrepareForCoordinatedStart(a1))
        {
          v9 = 1886545264;
LABEL_48:
          theArray[0].value = 0;
          figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue(a1, (const __CFArray **)theArray);
          if ((!theArray[0].value
             || CFArrayGetCount((CFArrayRef)theArray[0].value) != 1
             || !figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons(a1, (CFArrayRef)theArray[0].value))&& (!*(_QWORD *)(a1 + 368) || *(_BYTE *)(a1 + 361)))
          {
            if (FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 328)))
              v16 = 5.0;
            else
              v16 = 10.0;
            if (v16 + -1.0 <= v16 * 0.5)
              v17 = v16 * 0.5;
            else
              v17 = v16 + -1.0;
            v18 = *(const void **)(a1 + 368);
            if (v18)
            {
              CFRelease(v18);
              *(_QWORD *)(a1 + 368) = 0;
            }
            v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            Current = CFAbsoluteTimeGetCurrent();
            *(_QWORD *)(a1 + 368) = CFDateCreate(v19, v17 + Current);
            v21 = *(NSObject **)(a1 + 376);
            v22 = dispatch_time(0, (uint64_t)(v16 * 1000000000.0));
            dispatch_source_set_timer(v21, v22, 0xFFFFFFFFFFFFFFFFLL, 0x5F5E100uLL);
          }
          if (theArray[0].value)
            CFRelease((CFTypeRef)theArray[0].value);
LABEL_64:
          if (CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) >= 1)
            v9 = 1718185504;
          goto LABEL_66;
        }
        v9 = 1718185504;
        if (!figTimelineCoordinator_isReadyToPickAnchorTimeForInProgressOnQueue(a1))
          goto LABEL_48;
        if (figTimelineCoordinatorTimelineStateCopy(*MEMORY[0x1E0C9AE00], *(_QWORD *)(a1 + 224), &cf))
        {
LABEL_239:
          if (cf)
            CFRelease(cf);
          return;
        }
        v111 = (char *)cf;
        *((_DWORD *)cf + 9) = *(_DWORD *)(*(_QWORD *)(a1 + 224) + 32);
        figTimelineCoordinator_pickHostTimeForCoordinatedStart(a1, theArray);
        *(CMTime *)(v111 + 64) = theArray[0];
        v112 = *(const void **)(a1 + 224);
        v113 = cf;
        *(_QWORD *)(a1 + 224) = cf;
        if (v113)
          CFRetain(v113);
        if (v112)
          CFRelease(v112);
        *(_BYTE *)(a1 + 257) = 0;
        *(_BYTE *)(a1 + 261) = 0;
      }
      else
      {
        if (figTimelineCoordinatorTimelineStateCopy(*MEMORY[0x1E0C9AE00], *(_QWORD *)(a1 + 224), &cf))
          goto LABEL_239;
        v13 = *(_DWORD **)(a1 + 224);
        v14 = cf;
        *((_DWORD *)cf + 9) = v13[8];
        *(_QWORD *)(a1 + 224) = v14;
        CFRetain(v14);
        CFRelease(v13);
        *(_BYTE *)(a1 + 261) = 0;
        *(_BYTE *)(a1 + 257) = 0;
      }
      *(_BYTE *)(a1 + 360) = 0;
      v15 = *(const void **)(a1 + 368);
      if (v15)
      {
        CFRelease(v15);
        *(_QWORD *)(a1 + 368) = 0;
      }
      v9 = 1918989413;
      figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
      dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 376), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x5F5E100uLL);
      goto LABEL_64;
    }
    v9 = 1786080624;
    *(_BYTE *)(a1 + 263) = 1;
    goto LABEL_48;
  }
}

uint64_t figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue(uint64_t a1, const __CFArray **a2)
{
  CFMutableArrayRef Mutable;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  const void **ValueAtIndex;
  CFRange v11;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    return FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
  v5 = Mutable;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 432));
  if (Count >= 1)
  {
    v7 = Count;
    for (i = 0; i != v7; ++i)
    {
      ValueAtIndex = (const void **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 432), i);
      v11.length = CFArrayGetCount(v5);
      v11.location = 0;
      if (CFArrayGetFirstIndexOfValue(v5, v11, ValueAtIndex[2]) == -1)
        CFArrayAppendValue(v5, ValueAtIndex[2]);
    }
  }
  if (a2)
    *a2 = v5;
  return 0;
}

uint64_t figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons(uint64_t a1, CFArrayRef theArray)
{
  CFIndex v4;
  CFIndex v5;
  const void *ValueAtIndex;

  v4 = 0;
  while (1)
  {
    v5 = theArray ? CFArrayGetCount(theArray) : 0;
    if (v4 >= v5)
      break;
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, v4++);
    if (FigCFArrayContainsValue(*(const __CFArray **)(a1 + 448), ValueAtIndex))
      return 1;
  }
  return 0;
}

__CFString *figTimelineCoordinator_createStateLoggingIdentifier(uint64_t a1, const void *a2, uint64_t a3)
{
  __CFString *Mutable;
  __CFString *OriginatorLoggingIdentifier;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  OriginatorLoggingIdentifier = figTimelineCoordinator_createOriginatorLoggingIdentifier(a2);
  CFStringAppendFormat(Mutable, 0, CFSTR("%@%@-%d"), a1, OriginatorLoggingIdentifier, a3);
  if (OriginatorLoggingIdentifier)
    CFRelease(OriginatorLoggingIdentifier);
  return Mutable;
}

BOOL figTimelineCoordinator_everyoneIsSuspended(uint64_t a1)
{
  return CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) >= 1
      && figTimelineCoordinator_othersAreSuspended(a1) != 0;
}

uint64_t figTimelineCoordinatorTimelineStateCopy(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  float v4;
  float v5;
  int v6;
  uint64_t v7;
  const void *v8;
  uint64_t v9;
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  CFTypeRef v15;

  v15 = 0;
  if (!a3)
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  v4 = *(float *)(a2 + 32);
  v5 = *(float *)(a2 + 36);
  v6 = *(_DWORD *)(a2 + 96);
  v7 = *(_QWORD *)(a2 + 16);
  v13 = *(_OWORD *)(a2 + 40);
  v14 = *(_QWORD *)(a2 + 56);
  v11 = *(_OWORD *)(a2 + 64);
  v8 = *(const void **)(a2 + 88);
  v12 = *(_QWORD *)(a2 + 80);
  v9 = figTimelineCoordinatorTimelineStateCreateInternal(v4, v5, a1, v8, &v13, &v11, v6, 0, v7, -1, 0, 0, (uint64_t *)&v15);
  if ((_DWORD)v9)
  {
    if (v15)
      CFRelease(v15);
  }
  else
  {
    *a3 = v15;
  }
  return v9;
}

BOOL figTimelineCoordinator_timelineControlMustPrepareForCoordinatedStart(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 340) & 1) != 0 || figTimelineCoordinator_havePassedReadinessDeadline(a1))
    return 0;
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) < 1)
    return 1;
  return *(_BYTE *)(a1 + 259) != 0;
}

uint64_t figTimelineCoordinator_isReadyToPickAnchorTimeForInProgressOnQueue(uint64_t a1)
{
  CFDictionaryRef Count;
  CFDictionaryRef v3;
  uint64_t result;

  Count = FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 328));
  if (!*(_BYTE *)(a1 + 264))
    return 1;
  v3 = Count;
  if (figTimelineCoordinator_anyParticipantIsSuspendedWithOnlyReasonsThatTriggerWaiting(a1)
    || !figTimelineCoordinator_havePassedReadinessDeadline(a1))
  {
    if (!v3)
      return 0;
LABEL_4:
    if (*(_BYTE *)(a1 + 263))
      return figTimelineCoordinator_isReadyToPickAnchorTimeOnQueue(a1);
    return 0;
  }
  result = figTimelineCoordinator_isResponsibleForPickingAnchorTimeDuringCoordinatedStart(a1);
  if (!(_DWORD)result && v3)
    goto LABEL_4;
  return result;
}

CMTime *figTimelineCoordinator_pickHostTimeForCoordinatedStart@<X0>(uint64_t a1@<X0>, CMTime *a2@<X8>)
{
  OpaqueCMClock *v4;
  CMTime *p_lhs;
  CMTime *v6;
  OpaqueCMClock *HostTimeClock;
  CMTime v9;
  CMTime lhs;
  CMTime v11;
  CMTime v12;

  if (FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 328)) && !*(_BYTE *)(a1 + 259))
  {
    HostTimeClock = CMClockGetHostTimeClock();
    CMClockGetTime(&lhs, HostTimeClock);
    CMTimeMake(&v9, 1, 1);
    p_lhs = &lhs;
    v6 = &v9;
  }
  else
  {
    v4 = CMClockGetHostTimeClock();
    CMClockGetTime(&v12, v4);
    CMTimeMake(&v11, 1, 10);
    p_lhs = &v12;
    v6 = &v11;
  }
  return CMTimeAdd(a2, p_lhs, v6);
}

uint64_t figTimelineCoordinator_othersAreSuspended(uint64_t a1)
{
  const __CFArray *v1;
  CFIndex v2;
  CFIndex v3;
  const __CFDictionary **ValueAtIndex;
  uint64_t v5;

  v1 = FigCFDictionaryCopyArrayOfValues(*(const void **)(a1 + 328));
  v2 = 0;
  while (1)
  {
    v3 = v1 ? CFArrayGetCount(v1) : 0;
    if (v2 >= v3)
      break;
    ValueAtIndex = (const __CFDictionary **)CFArrayGetValueAtIndex(v1, v2++);
    if (!participantState_isSuspended(ValueAtIndex[2]))
    {
      v5 = 0;
      if (!v1)
        return v5;
      goto LABEL_10;
    }
  }
  v5 = 1;
  if (!v1)
    return v5;
LABEL_10:
  CFRelease(v1);
  return v5;
}

BOOL figTimelineCoordinator_havePassedReadinessDeadline(uint64_t a1)
{
  const __CFAllocator *v2;
  CFAbsoluteTime Current;
  const __CFDate *v4;
  const __CFDate *v5;
  const __CFDate *v6;
  _BOOL8 v7;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Current = CFAbsoluteTimeGetCurrent();
  v4 = CFDateCreate(v2, Current);
  v5 = v4;
  v6 = *(const __CFDate **)(a1 + 368);
  if (!v6)
  {
    v7 = 0;
    if (!v4)
      return v7;
    goto LABEL_3;
  }
  v7 = CFDateGetTimeIntervalSinceDate(v4, v6) > 0.0;
  if (v5)
LABEL_3:
    CFRelease(v5);
  return v7;
}

uint64_t figTimelineCoordinator_anyParticipantIsSuspendedWithOnlyReasonsThatTriggerWaiting(uint64_t a1)
{
  const __CFArray *v2;
  CFIndex v3;
  CFIndex i;
  const void *ValueAtIndex;
  const void *Value;
  const __CFArray *v7;
  const __CFArray *v8;
  uint64_t v9;

  v2 = FigCFDictionaryCopyArrayOfKeys(*(const void **)(a1 + 328));
  v3 = 0;
  if (!v2)
    goto LABEL_3;
LABEL_2:
  for (i = CFArrayGetCount(v2); ; i = 0)
  {
    if (v3 >= i)
    {
      v8 = 0;
      v9 = 0;
      if (!v2)
        goto LABEL_13;
      goto LABEL_12;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(v2, v3);
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 328), ValueAtIndex);
    v7 = (const __CFArray *)FigTimelineCoordinationParticipantSnapshotCopySuspensionReasons((uint64_t)Value);
    if (!v7)
      goto LABEL_9;
    v8 = v7;
    if (CFArrayGetCount(v7) >= 1)
    {
      if (figTimelineCoordinator_groupShouldWaitForAllSuspensions(a1, v8))
        break;
    }
    CFRelease(v8);
LABEL_9:
    ++v3;
    if (v2)
      goto LABEL_2;
LABEL_3:
    ;
  }
  v9 = 1;
  if (v2)
LABEL_12:
    CFRelease(v2);
LABEL_13:
  if (v8)
    CFRelease(v8);
  return v9;
}

uint64_t figTimelineCoordinator_isResponsibleForPickingAnchorTimeDuringCoordinatedStart(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFArray *Mutable;
  const __CFArray *v4;
  const __CFArray *v5;
  CFIndex v6;
  const void *ValueAtIndex;
  uint64_t v8;
  CFIndex v9;
  CFIndex Count;
  const __CFUUID *v11;
  CFStringRef v12;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v14;
  uint64_t v15;
  unsigned int v16;
  Boolean *v17;
  uint64_t v18;
  os_log_type_t type;
  int v21[2];
  const char *v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  CFStringRef v26;
  Boolean v27[128];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 360))
    return 0;
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v4 = FigCFDictionaryCopyArrayOfValues(*(const void **)(a1 + 328));
  if (v4)
  {
    v5 = v4;
    if (CFArrayGetCount(v4) >= 1)
    {
      v6 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v5, v6);
        v8 = *((_QWORD *)ValueAtIndex + 2);
        v27[0] = 0;
        FigCFDictionaryGetBooleanIfPresent(v8, CFSTR("CoordinatingStart"), v27);
        if (v27[0])
          CFArrayAppendValue(Mutable, *((const void **)ValueAtIndex + 4));
        ++v6;
      }
      while (v6 < CFArrayGetCount(v5));
    }
    CFRelease(v5);
  }
  v9 = 0;
  do
  {
    if (Mutable)
      Count = CFArrayGetCount(Mutable);
    else
      Count = 0;
    if (v9 >= Count)
    {
      v18 = 1;
      if (!Mutable)
        return v18;
      goto LABEL_23;
    }
    v11 = (const __CFUUID *)CFArrayGetValueAtIndex(Mutable, v9++);
  }
  while (figTimelineCoordinator_compareUUIDs(v11, *(const __CFUUID **)(a1 + 344)) != 1);
  v12 = CFUUIDCreateString(v2, v11);
  if (dword_1EE141FE8)
  {
    v21[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, v21, &type);
    v14 = v21[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v16 = v14;
    else
      v16 = v14 & 0xFFFFFFFE;
    if (v16)
    {
      v21[1] = 136315650;
      v22 = "figTimelineCoordinator_isResponsibleForPickingAnchorTimeDuringCoordinatedStart";
      v23 = 2112;
      v24 = a1;
      v25 = 2112;
      v26 = v12;
      v17 = (Boolean *)_os_log_send_and_compose_impl();
      LOBYTE(v14) = v21[0];
    }
    else
    {
      v17 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v17, v17 != v27, v14, 0, v15);
  }
  if (v12)
    CFRelease(v12);
  v18 = 0;
  if (Mutable)
LABEL_23:
    CFRelease(Mutable);
  return v18;
}

uint64_t figTimelineCoordinator_isReadyToPickAnchorTimeOnQueue(uint64_t a1)
{
  const __CFArray *v2;
  const __CFArray *v3;
  CFIndex v4;
  int v5;
  int *v6;
  const void *ValueAtIndex;
  const __CFDictionary **Value;
  const __CFArray *v9;
  const __CFSet *v10;
  __CFString *v11;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v13;
  uint64_t v14;
  unsigned int v15;
  const void *StateLoggingIdentifier;
  char *v17;
  uint64_t v18;
  CFIndex Count;
  CFTypeRef cf;
  os_log_type_t type;
  int v23[2];
  const char *v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  __CFString *v28;
  __int16 v29;
  const void *v30;
  char v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  cf = 0;
  if (!figTimelineCoordinator_isResponsibleForPickingAnchorTimeDuringCoordinatedStart(a1))
    return 0;
  v2 = FigCFDictionaryCopyArrayOfKeys(*(const void **)(a1 + 328));
  if (v2)
  {
    v3 = v2;
    if (CFArrayGetCount(v2) < 1)
    {
      v5 = 0;
    }
    else
    {
      v4 = 0;
      v5 = 0;
      v6 = &ensureGlobalDeserializeRegister_err;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v3, v4);
        Value = (const __CFDictionary **)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 328), ValueAtIndex);
        if (FigTimelineCoordinationParticipantSnapshotIsReadyToSetNonZeroRate((uint64_t)Value))
        {
          ++v5;
        }
        else
        {
          v9 = (const __CFArray *)FigTimelineCoordinationParticipantSnapshotCopySuspensionReasons((uint64_t)Value);
          if (v9)
          {
            v10 = v9;
            if (CFArrayGetCount(v9) >= 1)
            {
              if (figTimelineCoordinator_groupShouldWaitForAllSuspensions(a1, v10))
              {
                if (v6[1018])
                {
                  v11 = FigCFCopyCompactDescription(v10);
                  if (v6[1018])
                  {
                    v23[0] = 0;
                    type = OS_LOG_TYPE_DEFAULT;
                    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, v23, &type);
                    v13 = v23[0];
                    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
                      v15 = v13;
                    else
                      v15 = v13 & 0xFFFFFFFE;
                    if (v15)
                    {
                      StateLoggingIdentifier = FigParticipantStateDictionaryGetStateLoggingIdentifier(Value[2]);
                      v23[1] = 136315906;
                      v24 = "figTimelineCoordinator_areAllOtherParticipantsReady";
                      v25 = 2112;
                      v26 = a1;
                      v27 = 2114;
                      v28 = v11;
                      v29 = 2114;
                      v30 = StateLoggingIdentifier;
                      v17 = (char *)_os_log_send_and_compose_impl();
                      LOBYTE(v13) = v23[0];
                    }
                    else
                    {
                      v17 = 0;
                    }
                    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v17, v17 != &v31, v13, 0, v14);
                    v6 = &ensureGlobalDeserializeRegister_err;
                  }
                  if (v11)
                    CFRelease(v11);
                }
              }
              else
              {
                ++v5;
              }
            }
            CFRelease(v10);
          }
        }
        ++v4;
      }
      while (v4 < CFArrayGetCount(v3));
    }
    Count = CFArrayGetCount(v3);
    CFRelease(v3);
    if (Count != v5)
      goto LABEL_31;
  }
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) >= 1
    && ((figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue(a1, (const __CFArray **)&cf),
         figTimelineCoordinator_groupShouldWaitForAllSuspensions(a1, (CFArrayRef)cf))
     || figTimelineCoordinator_suspensionReasonsContainInternalSuspensionReasons(a1, (CFArrayRef)cf)))
  {
LABEL_31:
    v18 = 0;
  }
  else
  {
    v18 = 1;
  }
  if (cf)
    CFRelease(cf);
  return v18;
}

uint64_t figTimelineCoordinator_groupShouldWaitForAllSuspensions(uint64_t a1, CFArrayRef theArray)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  const void *v7;
  const void *ValueAtIndex;
  const __CFDictionary *Value;
  CFDictionaryRef v10;
  uint64_t v11;
  int v13;

  if (!theArray)
    return 0;
  Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    v5 = Count;
    v6 = 0;
    v7 = (const void *)*MEMORY[0x1E0C9AE50];
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v6);
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 392));
      Value = (const __CFDictionary *)FigCFDictionaryGetValue(*(const __CFDictionary **)(a1 + 400), ValueAtIndex);
      if (FigCFDictionaryGetValue(Value, CFSTR("ShouldWait")) != v7)
        break;
      v13 = 0;
      if (FigCFDictionaryGetInt32IfPresent((uint64_t)Value, CFSTR("ParticipantLimit"), &v13))
      {
        v10 = FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 328));
        v11 = v13;
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 392));
        if ((uint64_t)v10 >= v11)
          return 0;
      }
      else
      {
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 392));
      }
      if (v5 == ++v6)
        return 1;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 392));
  }
  return 0;
}

uint64_t figTimelineCoordinator_sendExpectedTimelineStateToGroupOnQueue(uint64_t a1)
{
  uint64_t v1;
  id *v3;
  id *v4;
  id *v5;
  const void *v6;
  uint64_t v7;
  int v8;
  NSObject *v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  __CFString *v14;
  CMTime *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  const __CFAllocator *v19;
  CFMutableDictionaryRef Mutable;
  CFStringRef v21;
  _QWORD *v22;
  uint64_t v23;
  OpaqueCMClock *HostTimeClock;
  _QWORD *v25;
  double v26;
  double Seconds;
  __CFString *StateLoggingIdentifier;
  uint64_t v29;
  __CFString *v30;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int value;
  uint64_t v33;
  unsigned int v34;
  CMTime *v35;
  const void *v36;
  const void *v37;
  _QWORD *v38;
  CFTypeRef v39;
  const void *v40;
  const void *v41;
  NSObject *v42;
  unsigned int v43;
  uint64_t v44;
  unsigned int v45;
  __CFString *v46;
  CMTime *v47;
  const void *v48;
  const void *v49;
  int v50;
  CMTime time2;
  CMTime type;
  CMTime v53;
  CFTypeRef cf;
  CMTime v55;
  __CFString *v56;
  CMTime time;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 200);
  if (!v1
    || !*(_QWORD *)(v1 + 88)
    || *(float *)(v1 + 36) != 0.0 && (*(_DWORD *)(v1 + 76) & 0x1D) != 1
    || (*(_DWORD *)(v1 + 52) & 0x1D) != 1
    || !*(_QWORD *)(a1 + 352))
  {
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  }
  v3 = *(id **)(a1 + 160);
  if (!v3)
    return 0;
  v4 = FigCFWeakReferenceHolderCopyReferencedObject(v3);
  if (!v4)
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  v5 = v4;
  v6 = *(const void **)(a1 + 344);
  if (v6)
  {
    if (*(_BYTE *)(a1 + 280))
    {
      v7 = *(_QWORD *)(a1 + 200);
      if (!*(_QWORD *)(v7 + 24))
      {
        *(_QWORD *)(v7 + 24) = v6;
        CFRetain(v6);
        v7 = *(_QWORD *)(a1 + 200);
      }
      v50 = 0;
      if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 464), *(const void **)(v7 + 88)))
      {
        FigCFDictionaryGetInt32IfPresent(*(_QWORD *)(a1 + 464), *(const void **)(*(_QWORD *)(a1 + 200) + 88), &v50);
        v8 = v50;
      }
      else
      {
        v8 = 0;
      }
      v16 = v8 + 1;
      *(_DWORD *)(a1 + 456) = v8 + 1;
      v17 = *(_QWORD *)(a1 + 200);
      *(_DWORD *)(v17 + 100) = v16;
      FigCFDictionarySetInt32(*(void **)(a1 + 464), *(const void **)(v17 + 88), v16);
      v18 = *(_QWORD *)(a1 + 200);
      cf = 0;
      if (!v18)
      {
        v29 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
        Mutable = 0;
        if ((_DWORD)v29)
        {
LABEL_72:
          CFRelease(v5);
          if (Mutable)
            CFRelease(Mutable);
          return v29;
        }
LABEL_44:
        if (dword_1EE141FE8)
        {
          v30 = FigCFCopyCompactDescription(Mutable);
          if (dword_1EE141FE8)
          {
            LODWORD(v53.value) = 0;
            LOBYTE(type.value) = 0;
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, (int *)&v53, &type);
            value = v53.value;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type.value))
              v34 = value;
            else
              v34 = value & 0xFFFFFFFE;
            if (v34)
            {
              LODWORD(v55.value) = 136315650;
              *(CMTimeValue *)((char *)&v55.value + 4) = (CMTimeValue)"figTimelineCoordinator_sendExpectedTimelineStateToGroupOnQueue";
              LOWORD(v55.flags) = 2112;
              *(_QWORD *)((char *)&v55.flags + 2) = a1;
              HIWORD(v55.epoch) = 2114;
              v56 = v30;
              v35 = (CMTime *)_os_log_send_and_compose_impl();
              LOBYTE(value) = v53.value;
            }
            else
            {
              v35 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v35, v35 != &time, value, 0, v33);
          }
          if (v30)
            CFRelease(v30);
        }
        *(_BYTE *)(a1 + 281) = 0;
        (*(void (**)(id *, CFMutableDictionaryRef))(a1 + 136))(v5, Mutable);
        goto LABEL_72;
      }
      v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionarySetValue(Mutable, CFSTR("Identifier"), *(const void **)(v18 + 88));
      v21 = CFUUIDCreateString(v19, *(CFUUIDRef *)(v18 + 24));
      CFDictionarySetValue(Mutable, CFSTR("OriginatorUUID"), v21);
      FigCFDictionarySetFloat32(Mutable, CFSTR("Rate"), *(float *)(v18 + 36));
      FigCFDictionarySetInt32(Mutable, CFSTR("LamportTimestamp"), *(_DWORD *)(v18 + 100));
      if (*(float *)(v18 + 36) == 0.0)
      {
        FigCFDictionarySetInt32(Mutable, CFSTR("SeekPrecision"), *(_DWORD *)(v18 + 96));
        FigCFDictionarySetInt32(Mutable, CFSTR("PrerollRate"), (int)*(float *)(v18 + 32));
        time = *(CMTime *)(v18 + 40);
        Seconds = CMTimeGetSeconds(&time);
        FigCFDictionarySetDouble(Mutable, CFSTR("Time"), Seconds);
      }
      else
      {
        time = *(CMTime *)(v18 + 40);
        v55 = *(CMTime *)(v18 + 64);
        memset(&v53, 0, sizeof(v53));
        v22 = *(_QWORD **)(a1 + 176);
        type = *(CMTime *)(v18 + 64);
        v23 = FigTimelineCoordinatorCopyNetworkTimeDictionaryForHostTime(v22, &type, (CFDictionaryRef *)&cf);
        if ((_DWORD)v23)
          goto LABEL_88;
        HostTimeClock = CMClockGetHostTimeClock();
        CMClockGetTime(&v53, HostTimeClock);
        type = v55;
        time2 = v53;
        if (CMTimeCompare(&type, &time2) < 0)
        {
          v55 = v53;
          type = v53;
          figTimelineCoordinator_timelineTimeAtHostTime((CMTime *)v18, &type, &time);
          if (cf)
          {
            CFRelease(cf);
            cf = 0;
          }
          v25 = *(_QWORD **)(a1 + 176);
          type = v55;
          v23 = FigTimelineCoordinatorCopyNetworkTimeDictionaryForHostTime(v25, &type, (CFDictionaryRef *)&cf);
          if ((_DWORD)v23)
          {
LABEL_88:
            v29 = FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
            if (Mutable)
            {
              CFRelease(Mutable);
              Mutable = 0;
            }
            StateLoggingIdentifier = 0;
LABEL_37:
            if (cf)
              CFRelease(cf);
            if (StateLoggingIdentifier)
              CFRelease(StateLoggingIdentifier);
            if (v21)
              CFRelease(v21);
            if ((_DWORD)v29)
              goto LABEL_72;
            goto LABEL_44;
          }
        }
        type = time;
        v26 = CMTimeGetSeconds(&type);
        FigCFDictionarySetDouble(Mutable, CFSTR("Time"), v26);
        CFDictionarySetValue(Mutable, CFSTR("NetworkTime"), cf);
      }
      if (FigDebugIsInternalBuild())
      {
        StateLoggingIdentifier = figTimelineCoordinator_createStateLoggingIdentifier((uint64_t)CFSTR("T/"), v21, *(unsigned int *)(a1 + 384));
        FigCFDictionarySetValue(Mutable, CFSTR("DebugInfo"), StateLoggingIdentifier);
      }
      else
      {
        StateLoggingIdentifier = 0;
      }
      v29 = 0;
      ++*(_DWORD *)(a1 + 384);
      goto LABEL_37;
    }
    if (FigCFEqual(*(CFTypeRef *)(a1 + 352), *(CFTypeRef *)(a1 + 272)))
    {
      if (dword_1EE141FE8)
      {
        LODWORD(v53.value) = 0;
        LOBYTE(type.value) = 0;
        v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, (int *)&v53, &type);
        v11 = v53.value;
        if (os_log_type_enabled(v10, type.value))
          v13 = v11;
        else
          v13 = v11 & 0xFFFFFFFE;
        if (v13)
        {
          v14 = *(__CFString **)(a1 + 352);
          LODWORD(v55.value) = 136315650;
          *(CMTimeValue *)((char *)&v55.value + 4) = (CMTimeValue)"figTimelineCoordinator_sendExpectedTimelineStateToGroupOnQueue";
          LOWORD(v55.flags) = 2112;
          *(_QWORD *)((char *)&v55.flags + 2) = a1;
          HIWORD(v55.epoch) = 2114;
          v56 = v14;
          v15 = (CMTime *)_os_log_send_and_compose_impl();
          LOBYTE(v11) = v53.value;
        }
        else
        {
          v15 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v15, v15 != &time, v11, 0, v12);
      }
      v48 = *(const void **)(a1 + 288);
      v49 = *(const void **)(a1 + 200);
      *(_QWORD *)(a1 + 288) = v49;
      if (v49)
        CFRetain(v49);
      if (v48)
        CFRelease(v48);
    }
    else
    {
      v36 = *(const void **)(a1 + 272);
      v37 = *(const void **)(a1 + 352);
      *(_QWORD *)(a1 + 272) = v37;
      if (v37)
        CFRetain(v37);
      if (v36)
        CFRelease(v36);
      v38 = malloc_type_malloc(0x10uLL, 0x60040FAFB2B2FuLL);
      *v38 = CFRetain((CFTypeRef)a1);
      v39 = *(CFTypeRef *)(a1 + 352);
      if (v39)
        v39 = CFRetain(v39);
      v38[1] = v39;
      v40 = *(const void **)(a1 + 288);
      v41 = *(const void **)(a1 + 200);
      *(_QWORD *)(a1 + 288) = v41;
      if (v41)
        CFRetain(v41);
      if (v40)
        CFRelease(v40);
      if (dword_1EE141FE8)
      {
        LODWORD(v53.value) = 0;
        LOBYTE(type.value) = 0;
        v42 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, (int *)&v53, &type);
        v43 = v53.value;
        if (os_log_type_enabled(v42, type.value))
          v45 = v43;
        else
          v45 = v43 & 0xFFFFFFFE;
        if (v45)
        {
          v46 = *(__CFString **)(a1 + 352);
          LODWORD(v55.value) = 136315650;
          *(CMTimeValue *)((char *)&v55.value + 4) = (CMTimeValue)"figTimelineCoordinator_sendExpectedTimelineStateToGroupOnQueue";
          LOWORD(v55.flags) = 2112;
          *(_QWORD *)((char *)&v55.flags + 2) = a1;
          HIWORD(v55.epoch) = 2114;
          v56 = v46;
          v47 = (CMTime *)_os_log_send_and_compose_impl();
          LOBYTE(v43) = v53.value;
        }
        else
        {
          v47 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v47, v47 != &time, v43, 0, v44);
      }
      (*(void (**)(id *, _QWORD, _QWORD *, void (*)(void *)))(a1 + 152))(v5, *(_QWORD *)(a1 + 352), v38, figTimelineCoordinator_reloadCompleteCallback);
    }
  }
  CFRelease(v5);
  return 0;
}

void figTimelineCoordinator_reloadCompleteCallback(void *context)
{
  dispatch_async_f(*(dispatch_queue_t *)(*(_QWORD *)context + 88), context, (dispatch_function_t)figTimelineCoordinator_fetchCompleteCallbackOnQueue);
}

void figTimelineCoordinator_fetchCompleteCallbackOnQueue(CFTypeRef *a1)
{
  CFTypeRef v2;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  const char *v8;
  _BYTE *v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  _BYTE *v15;
  const void *v16;
  const void *v17;
  uint64_t v18;
  CFTypeRef v19;
  const void *v20;
  os_log_type_t type;
  int v22;
  int v23;
  const char *v24;
  __int16 v25;
  CFTypeRef v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  const char *v30;
  _BYTE v31[128];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  if (FigCFEqual(a1[1], *((CFTypeRef *)*a1 + 44)))
  {
    if (dword_1EE141FE8)
    {
      v22 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, &v22, &type);
      v4 = v22;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v6 = v4;
      else
        v6 = v4 & 0xFFFFFFFE;
      if (v6)
      {
        v7 = *((_QWORD *)v2 + 44);
        if (*((_QWORD *)v2 + 36))
          v8 = "Did NOT";
        else
          v8 = "Did";
        v23 = 136315906;
        v24 = "figTimelineCoordinator_fetchCompleteCallbackOnQueue";
        v25 = 2112;
        v26 = v2;
        v27 = 2114;
        v28 = v7;
        v29 = 2082;
        v30 = v8;
        v9 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v4) = v22;
      }
      else
      {
        v9 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v9, v9 != v31, v4, 0, v5);
    }
    *((_BYTE *)v2 + 280) = 1;
    v16 = (const void *)*((_QWORD *)v2 + 34);
    if (v16)
    {
      CFRelease(v16);
      *((_QWORD *)v2 + 34) = 0;
    }
  }
  else if (dword_1EE141FE8)
  {
    v22 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, &v22, &type);
    v11 = v22;
    if (os_log_type_enabled(v10, type))
      v13 = v11;
    else
      v13 = v11 & 0xFFFFFFFE;
    if (v13)
    {
      v14 = *((_QWORD *)v2 + 44);
      v23 = 136315650;
      v24 = "figTimelineCoordinator_fetchCompleteCallbackOnQueue";
      v25 = 2112;
      v26 = v2;
      v27 = 2114;
      v28 = v14;
      v15 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v11) = v22;
    }
    else
    {
      v15 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v15, v15 != v31, v11, 0, v12);
  }
  if (FigCFEqual(a1[1], *((CFTypeRef *)v2 + 34)))
  {
    v17 = (const void *)*((_QWORD *)v2 + 34);
    if (v17)
    {
      CFRelease(v17);
      *((_QWORD *)v2 + 34) = 0;
    }
  }
  v18 = *((_QWORD *)v2 + 36);
  if (v18)
  {
    if (v18 == *((_QWORD *)v2 + 25))
    {
      if (FigCFEqual(a1[1], *(CFTypeRef *)(v18 + 88)))
      {
        figTimelineCoordinator_sendExpectedTimelineStateToGroupOnQueue(v2);
        v20 = (const void *)*((_QWORD *)v2 + 36);
        if (v20)
        {
          CFRelease(v20);
          *((_QWORD *)v2 + 36) = 0;
        }
      }
    }
  }
  v19 = a1[1];
  if (v19)
    CFRelease(v19);
  CFRelease(v2);
  free(a1);
}

void figTimelineCoordinator_startTimeoutForTimelineControlCommandOnQueue(uint64_t a1)
{
  NSObject *v1;
  dispatch_time_t v2;

  v1 = *(NSObject **)(a1 + 112);
  if (v1)
  {
    v2 = dispatch_time(0, 60000000000);
    dispatch_source_set_timer(v1, v2, 0xFFFFFFFFFFFFFFFFLL, 0x5F5E100uLL);
  }
  else
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
}

void figTimelineCoordinator_postDidIssueSetRateAndTimeCommandNotification(const void *a1, const void *a2, CMTime *a3, float a4)
{
  int DidIssueCommandNotificationPayload;
  void *v8;
  CMTime v9;
  CFTypeRef cf;

  cf = 0;
  DidIssueCommandNotificationPayload = figTimelineCoordinator_createDidIssueCommandNotificationPayload(CFSTR("SetRateAndTime"), a2, (__CFDictionary **)&cf);
  v8 = (void *)cf;
  if (!DidIssueCommandNotificationPayload && !FigCFDictionarySetFloat32((void *)cf, CFSTR("Rate"), a4))
  {
    v9 = *a3;
    if (!FigCFDictionarySetCMTime(v8, CFSTR("Time"), &v9))
      figTimelineCoordinator_postDidIssueCommandNotification(a1, v8);
  }
  if (v8)
    CFRelease(v8);
}

void figTimelineCoordinator_postDidIssueSetRateCommandNotification(const void *a1, const void *a2, float a3)
{
  int DidIssueCommandNotificationPayload;
  CFTypeRef v6;
  CFTypeRef cf;

  cf = 0;
  DidIssueCommandNotificationPayload = figTimelineCoordinator_createDidIssueCommandNotificationPayload(CFSTR("SetRate"), a2, (__CFDictionary **)&cf);
  v6 = cf;
  if (!DidIssueCommandNotificationPayload && !FigCFDictionarySetFloat32((void *)cf, CFSTR("Rate"), a3))
    figTimelineCoordinator_postDidIssueCommandNotification(a1, v6);
  if (v6)
    CFRelease(v6);
}

void figTimelineCoordinator_postDidIssueSetTimeCommandNotification(const void *a1, const void *a2, CMTime *a3)
{
  int DidIssueCommandNotificationPayload;
  CFTypeRef v6;
  CMTime v7;
  CFTypeRef cf;

  cf = 0;
  DidIssueCommandNotificationPayload = figTimelineCoordinator_createDidIssueCommandNotificationPayload(CFSTR("SetTime"), a2, (__CFDictionary **)&cf);
  v6 = cf;
  if (!DidIssueCommandNotificationPayload)
  {
    v7 = *a3;
    if (!FigCFDictionarySetCMTime((void *)cf, CFSTR("Time"), &v7))
      figTimelineCoordinator_postDidIssueCommandNotification(a1, v6);
  }
  if (v6)
    CFRelease(v6);
}

uint64_t figTimelineCoordinator_createDidIssueCommandNotificationPayload(const void *a1, const void *a2, __CFDictionary **a3)
{
  __CFDictionary *Mutable;
  __CFDictionary *v7;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
  v7 = Mutable;
  CFDictionarySetValue(Mutable, CFSTR("Command"), a1);
  if (a2)
    CFDictionarySetValue(v7, CFSTR("ParticipantUUID"), a2);
  *a3 = v7;
  return 0;
}

uint64_t figTimelineCoordinator_postDidIssueCommandNotification(const void *a1, const void *a2)
{
  __CFNotificationCenter *DefaultLocalCenter;
  uint64_t result;

  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  result = CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("DidIssueCommandToTimelineControl"), a1, a2);
  if ((_DWORD)result)
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  return result;
}

uint64_t figTimelineCoordinatorParticipantCreateFromDictionary(int a1, CFDictionaryRef theDict, const void *a3, uint64_t *a4)
{
  const __CFString *Value;
  const __CFString *v8;
  CFTypeID v9;
  uint64_t Instance;
  uint64_t v11;
  CFTypeRef v12;
  uint64_t v13;

  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("UUID"));
  v8 = Value;
  if (Value)
  {
    v9 = CFGetTypeID(Value);
    if (v9 == CFStringGetTypeID())
      v8 = (const __CFString *)CFUUIDCreateFromString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v8);
    else
      v8 = 0;
  }
  if (!a4 || !theDict)
  {
    v13 = FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    if (!v8)
      return v13;
    goto LABEL_15;
  }
  if (v8)
  {
    if (FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce != -1)
      dispatch_once_f(&FigTimelineCoordinationParticipantSnapshotGetTypeID_sRegisterFigTimelineCoordinationParticipantSnapshotTypeOnce, 0, (dispatch_function_t)registerFigTimelineCoordinationParticipantSnapshotType);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v11 = Instance;
      *(_QWORD *)(Instance + 16) = CFRetain(theDict);
      if (a3)
        v12 = CFRetain(a3);
      else
        v12 = 0;
      *(_QWORD *)(v11 + 24) = v12;
      v13 = 0;
      *(_QWORD *)(v11 + 32) = CFRetain(v8);
      *a4 = v11;
    }
    else
    {
      v13 = FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
    }
LABEL_15:
    CFRelease(v8);
    return v13;
  }
  return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
}

void figTimelineCoordinator_integrateParticipantStateOnQueue(uint64_t a1, uint64_t a2, char *a3)
{
  const void *v3;
  uint64_t v7;
  CFTypeRef *Value;
  uint64_t v9;
  char *v10;
  int v11;
  CFTypeRef v12;
  CFTypeRef v13;
  int v14;
  unsigned int v15;
  _BOOL4 v16;
  BOOL v17;
  BOOL v18;
  char v19;
  __CFString *v20;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  const char *v25;
  const char *v26;
  __int128 *v27;
  NSObject *v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int v31;
  __int128 *v32;
  int v33;
  _BOOL4 IsSuspended;
  uint64_t v35;
  NSObject *v36;
  unsigned int v37;
  uint64_t v38;
  unsigned int v39;
  const char *v40;
  const char *v41;
  __int128 *v42;
  pthread_mutex_t *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  float v47;
  float v48;
  const void *v49;
  const void *v50;
  const void *v51;
  char *v52;
  _BOOL4 v53;
  os_log_type_t v54;
  os_log_type_t type[4];
  uint64_t v56;
  CFTypeRef cf;
  _BYTE v58[24];
  const char *v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  __CFString *v63;
  __int128 v64;
  uint64_t v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v3 = *(const void **)(a2 + 32);
  cf = 0;
  if (!v3)
  {
    FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
    return;
  }
  if (FigCFEqual(*(CFTypeRef *)(a1 + 344), v3))
  {
    v7 = *(_QWORD *)(a2 + 16);
    LOBYTE(v64) = 0;
    FigCFDictionaryGetBooleanIfPresent(v7, CFSTR("CoordinatingStart"), (Boolean *)&v64);
    if ((_BYTE)v64)
      *(_BYTE *)(a1 + 360) = 1;
    goto LABEL_64;
  }
  Value = (CFTypeRef *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 328), v3);
  v9 = (uint64_t)Value;
  if (Value)
  {
    v10 = a3;
    v11 = FigCFEqual(Value[4], *(CFTypeRef *)(a2 + 32));
    v12 = FigTimelineCoordinationParticipantSnapshotCopySuspensionReasons(v9);
    v13 = FigTimelineCoordinationParticipantSnapshotCopySuspensionReasons(a2);
    v14 = FigCFEqual(v12, v13);
    v15 = FigTimelineCoordinationParticipantSnapshotIsReadyToSetNonZeroRate(v9);
    v16 = v15 == FigTimelineCoordinationParticipantSnapshotIsReadyToSetNonZeroRate(a2);
    v53 = v14 != 0;
    if (v14)
      v17 = v16;
    else
      v17 = 0;
    if (v11)
      v18 = v17;
    else
      v18 = 0;
    if (v12)
      CFRelease(v12);
    if (v13)
      CFRelease(v13);
    a3 = v10;
    if (v18)
    {
      v19 = 0;
      goto LABEL_35;
    }
  }
  else
  {
    v16 = 0;
    v53 = 0;
  }
  if (dword_1EE141FE8)
  {
    v20 = FigCFCopyCompactDescription(*(const __CFSet **)(a2 + 16));
    if (dword_1EE141FE8)
    {
      v52 = a3;
      LODWORD(v56) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, (int *)&v56, type);
      v22 = v56;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0]))
        v24 = v22;
      else
        v24 = v22 & 0xFFFFFFFE;
      if (v24)
      {
        v25 = " [Suspensions]";
        *(_QWORD *)&v58[4] = "figTimelineCoordinator_integrateParticipantStateOnQueue";
        v26 = "";
        *(_DWORD *)v58 = 136316162;
        if (v53)
          v25 = "";
        *(_WORD *)&v58[12] = 2112;
        *(_QWORD *)&v58[14] = a1;
        v59 = v25;
        *(_WORD *)&v58[22] = 2082;
        if (!v16)
          v26 = " [Readiness]";
        v60 = 2082;
        v61 = v26;
        v62 = 2114;
        v63 = v20;
        v27 = (__int128 *)_os_log_send_and_compose_impl();
        LOBYTE(v22) = v56;
      }
      else
      {
        v27 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v27, v27 != &v64, v22, 0, v23);
      a3 = v52;
    }
    if (v20)
      CFRelease(v20);
  }
  v19 = 1;
  if (v9)
  {
LABEL_35:
    if (participantState_isSuspended(*(const __CFDictionary **)(v9 + 16)))
      goto LABEL_43;
  }
  if (participantState_isSuspended(*(const __CFDictionary **)(a2 + 16)))
  {
    if (dword_1EE141FE8)
    {
      LODWORD(v56) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      v28 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, (int *)&v56, type);
      v29 = v56;
      if (os_log_type_enabled(v28, type[0]))
        v31 = v29;
      else
        v31 = v29 & 0xFFFFFFFE;
      if (v31)
      {
        *(_DWORD *)v58 = 136315394;
        *(_QWORD *)&v58[4] = "figTimelineCoordinator_integrateParticipantStateOnQueue";
        *(_WORD *)&v58[12] = 2112;
        *(_QWORD *)&v58[14] = a1;
        v32 = (__int128 *)_os_log_send_and_compose_impl();
        LOBYTE(v29) = v56;
      }
      else
      {
        v32 = 0;
      }
      v33 = 1;
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v32, v32 != &v64, v29, 0, v30);
    }
    else
    {
      v33 = 1;
    }
    goto LABEL_47;
  }
LABEL_43:
  v33 = 0;
LABEL_47:
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 320));
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 328), v3, (const void *)a2);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 320));
  figTimelineCoordinator_copyActiveSuspensionReasonsOnQueue(a1, (const __CFArray **)&cf);
  IsSuspended = figTimelineCoordinator_everyoneIsSuspended(a1);
  if (v33)
  {
    if (IsSuspended)
    {
      if (*(_QWORD *)(a1 + 208))
      {
        v35 = *(_QWORD *)(a1 + 200);
        if (!v35 || *(float *)(v35 + 36) != 0.0)
        {
          v56 = 0;
          if (dword_1EE141FE8)
          {
            *(_DWORD *)type = 0;
            v54 = OS_LOG_TYPE_DEFAULT;
            v36 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141FE0, 1, (int *)type, &v54);
            v37 = *(_DWORD *)type;
            if (os_log_type_enabled(v36, v54))
              v39 = v37;
            else
              v39 = v37 & 0xFFFFFFFE;
            if (v39)
            {
              v40 = *(const char **)(a1 + 200);
              v41 = *(const char **)(a1 + 208);
              *(_DWORD *)v58 = 136315906;
              *(_QWORD *)&v58[4] = "figTimelineCoordinator_integrateParticipantStateOnQueue";
              *(_WORD *)&v58[12] = 2112;
              *(_QWORD *)&v58[14] = a1;
              *(_WORD *)&v58[22] = 2112;
              v59 = v40;
              v60 = 2112;
              v61 = v41;
              v42 = (__int128 *)_os_log_send_and_compose_impl();
              LOBYTE(v37) = type[0];
            }
            else
            {
              v42 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141FE0, 1u, 1, v42, v42 != &v64, v37, 0, v38);
          }
          FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 16));
          v43 = *(pthread_mutex_t **)(a1 + 16);
          v44 = *(_QWORD *)(a1 + 24);
          *(_QWORD *)(a1 + 24) = v44 + 1;
          FigSimpleMutexUnlock(v43);
          v45 = *MEMORY[0x1E0C9AE00];
          v46 = *(_QWORD *)(a1 + 208);
          v47 = *(float *)(v46 + 32);
          v48 = *(float *)(v46 + 36);
          v50 = *(const void **)(a1 + 344);
          v49 = *(const void **)(a1 + 352);
          v64 = *(_OWORD *)(v46 + 40);
          v65 = *(_QWORD *)(v46 + 56);
          memset(v58, 0, sizeof(v58));
          if (figTimelineCoordinatorTimelineStateCreateInternal(v47, v48, v45, v49, &v64, (__int128 *)v58, 0, v50, v44, -1, 0, 0, &v56))goto LABEL_64;
          *(_BYTE *)(a1 + 360) = 1;
          figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(a1, v56, 7u, 1, 0, 1, 1, 1);
          v51 = *(const void **)(a1 + 208);
          if (v51)
          {
            CFRelease(v51);
            *(_QWORD *)(a1 + 208) = 0;
          }
        }
      }
    }
  }
  *a3 = v19;
LABEL_64:
  if (cf)
    CFRelease(cf);
}

void figTimelineCoordinator_postParticipantsDidChange(const void **a1)
{
  CFArrayRef v2;
  __CFDictionary *Mutable;
  __CFDictionary *v4;
  __CFNotificationCenter *DefaultLocalCenter;

  v2 = FigCFDictionaryCopyArrayOfKeys(a1[41]);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v4 = Mutable;
  if (Mutable)
  {
    if (v2)
      CFDictionarySetValue(Mutable, CFSTR("ParticipantUUIDs"), v2);
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("ParticipantsDidChange"), a1, v4);
    if (v2)
      goto LABEL_5;
  }
  else
  {
    FigSignalErrorAt(4294951586, 0, 0, 0, 0, 0, 0);
    if (v2)
LABEL_5:
      CFRelease(v2);
  }
  if (v4)
    CFRelease(v4);
}

uint64_t figTimelineCoordinator_triggerTimelineChangesAfterParticipantChangeOnQueue(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (!*(_BYTE *)(result + 96))
  {
    v1 = result;
    result = figTimelineCoordinator_isReadyToPickAnchorTimeOnQueue(result);
    if ((_DWORD)result)
    {
      v2 = *(_QWORD *)(v1 + 200);
      if (v2)
        return figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(v1, v2, 3, 1, 1, 1, 1, 1);
    }
  }
  return result;
}

void figTimelineCoordinator_reapplyExpectedTimelineOnQueue(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 200);
  if (v4)
    figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(a1, v4, a3, 1, 1, a2 == 0, a2 == 0, 1);
}

void figTimelineCoordinator_coordinateTimeJumpOnQueue(uint64_t a1, CMTime *a2, int a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  int Float32IfPresent;
  char v13;
  uint64_t v14;
  float v15;
  int v16;
  int v18;
  float v19;
  _DWORD *v20;
  float v21;
  uint64_t v22;
  const void *v23;
  const void *v24;
  CFTypeRef v25;
  __int128 v26;
  uint64_t v27;
  CMTime v28;
  char v29;
  CFTypeRef cf;
  float v31;
  Boolean v32;

  v32 = 0;
  v31 = 0.0;
  cf = 0;
  v29 = 0;
  if (!*(_QWORD *)(a1 + 352))
    goto LABEL_33;
  FigCFDictionaryGetBooleanIfPresent(a4, CFSTR("AlreadyCompletedJump"), (Boolean *)&v29);
  FigCFDictionaryGetBooleanIfPresent(a4, CFSTR("ResumeImmediately"), &v32);
  Float32IfPresent = FigCFDictionaryGetFloat32IfPresent(a4, CFSTR("AlreadyPreparedForRate"), &v31);
  v13 = v32 == 0;
  if (a3 && (v14 = *(_QWORD *)(a1 + 200)) != 0)
  {
    v15 = *(float *)(v14 + 36);
    v16 = 1;
  }
  else
  {
    v14 = *(_QWORD *)(a1 + 192);
    if (!v14)
    {
      v16 = 0;
      v15 = 0.0;
      goto LABEL_10;
    }
    v16 = 0;
    v15 = *(float *)(v14 + 36);
  }
  if (v15 == 0.0)
    v15 = *(float *)(v14 + 32);
LABEL_10:
  v18 = v15 == v31 && Float32IfPresent != 0;
  if (!*(_BYTE *)(a1 + 304))
  {
    v18 = 0;
    v29 = 0;
    v16 = 1;
  }
  v19 = 0.0;
  if (v15 == 0.0 || CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) > 0)
  {
    v18 = 0;
LABEL_21:
    if (v18 == *(_DWORD *)(a1 + 340))
      goto LABEL_25;
    v20 = (_DWORD *)(a1 + 340);
    v21 = v15;
    v15 = v19;
    goto LABEL_23;
  }
  if (*(_BYTE *)(a1 + 360))
  {
    v19 = v15;
    v15 = 0.0;
    goto LABEL_21;
  }
  *(_BYTE *)(a1 + 360) = 1;
  v21 = 0.0;
  if (v18 == *(_DWORD *)(a1 + 340))
    goto LABEL_24;
  v20 = (_DWORD *)(a1 + 340);
LABEL_23:
  *v20 = v18;
LABEL_24:
  v19 = v15;
  figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
  v15 = v21;
LABEL_25:
  v22 = *MEMORY[0x1E0C9AE00];
  v24 = *(const void **)(a1 + 344);
  v23 = *(const void **)(a1 + 352);
  v28 = *a2;
  v26 = *(_OWORD *)&kCMTimeInvalid.value;
  v27 = 0;
  if (!figTimelineCoordinatorTimelineStateCreateInternal(v19, v15, v22, v23, (__int128 *)&v28.value, &v26, 0, v24, a5, -1, 0, 0, (uint64_t *)&cf))
  {
    if (a6)
    {
      v25 = cf;
      if (cf)
        v25 = CFRetain(cf);
      *a6 = v25;
    }
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 432)) <= 0)
    {
      v28 = *a2;
      figTimelineCoordinator_postDidIssueSetTimeCommandNotification((const void *)a1, 0, &v28);
    }
    figTimelineCoordinator_transitionToNewExpectedTimelineIssuingCommandsWhenAppropriateOnQueue(a1, (uint64_t)cf, 1u, v13, 0, v29, v16 == 0, 1);
  }
LABEL_33:
  if (cf)
    CFRelease(cf);
}

void figTimelineCoordinator_timelineControlCommandCompletionOnQueue(uint64_t a1)
{
  uint64_t v2;
  int v3;
  const void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  OpaqueCMClock *HostTimeClock;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  const void *v19;
  int v20;
  int v21;
  const void *v22;
  const void *v23;
  CMTime v24;
  CMTime time2;
  CMTime time1;

  v2 = *(_QWORD *)a1;
  figTimelineCoordinator_suspendTimelineControlCommandCompletionTimer(*(_QWORD *)a1);
  *(_BYTE *)(*(_QWORD *)a1 + 96) = 0;
  v3 = *(_DWORD *)(a1 + 16);
  if (v3 != *(_DWORD *)(v2 + 100))
  {
    v4 = *(const void **)(a1 + 24);
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(a1 + 24) = 0;
    }
    v3 = *(_DWORD *)(v2 + 100);
  }
  *(_DWORD *)(v2 + 100) = v3 + 1;
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(v2 + 224);
  if (v5 != v6)
  {
    if (v5 && v6 && FigCFEqual(*(CFTypeRef *)(v6 + 88), *(CFTypeRef *)(v5 + 88)))
    {
      v7 = *(_QWORD *)(v6 + 88);
      if (v7)
        LOBYTE(v7) = (*(float *)(v6 + 36) == 0.0 || (*(_DWORD *)(v6 + 76) & 0x1D) == 1)
                  && (*(_DWORD *)(v6 + 52) & 0x1D) == 1;
      if (*(_QWORD *)(v5 + 88) && (*(float *)(v5 + 36) == 0.0 || (*(_DWORD *)(v5 + 76) & 0x1D) == 1))
        LOBYTE(v7) = v7 ^ ((*(_DWORD *)(v5 + 52) & 0x1D) == 1);
      if ((v7 & 1) == 0)
      {
        time1 = *(CMTime *)(v6 + 40);
        time2 = *(CMTime *)(v5 + 40);
        if (!CMTimeCompare(&time1, &time2)
          && *(_DWORD *)(v6 + 100) - *(_DWORD *)(v5 + 100) == 1
          && *(float *)(v6 + 36) == *(float *)(v5 + 32)
          && (*(_BYTE *)(v6 + 76) & 1) != 0)
        {
          *(_WORD *)(v2 + 256) = 0;
          *(_BYTE *)(v2 + 258) = 0;
        }
      }
    }
LABEL_51:
    figTimelineCoordinator_issueAppropriateCommandsToMatchInProgressTimelineOnQueue(v2);
    figTimelineCoordinator_triggerTimelineChangesAfterParticipantChangeOnQueue(v2);
    goto LABEL_52;
  }
  v8 = *(const void **)(v2 + 296);
  v9 = *(const void **)(a1 + 24);
  *(_QWORD *)(v2 + 296) = v9;
  if (v9)
    CFRetain(v9);
  if (v8)
    CFRelease(v8);
  v10 = *(_QWORD *)(v2 + 296);
  if (v10)
  {
    v11 = *(_QWORD *)(a1 + 8);
    if (*(_QWORD *)(v11 + 88)
      && (*(float *)(v11 + 36) == 0.0 || (*(_DWORD *)(v11 + 76) & 0x1D) == 1)
      && (*(_DWORD *)(v11 + 52) & 0x1D) == 1)
    {
      CMTimeMake(&v24, 5, 1);
      if (!figTimelineCoordinator_timelinesMatch(v10, v11, &v24, 0))
      {
        memset(&time1, 0, sizeof(time1));
        HostTimeClock = CMClockGetHostTimeClock();
        CMClockGetTime(&time1, HostTimeClock);
      }
    }
    v13 = *(_QWORD *)(v2 + 224);
    if (!*(_QWORD *)(v13 + 88)
      || *(float *)(v13 + 36) != 0.0 && (*(_DWORD *)(v13 + 76) & 0x1D) != 1
      || (*(_DWORD *)(v13 + 52) & 0x1D) != 1)
    {
      v14 = *(_QWORD *)(v2 + 296);
      *(_DWORD *)(v13 + 36) = *(_DWORD *)(v14 + 36);
      v15 = *(_OWORD *)(v14 + 40);
      *(_QWORD *)(v13 + 56) = *(_QWORD *)(v14 + 56);
      *(_OWORD *)(v13 + 40) = v15;
      v16 = *(_QWORD *)(v2 + 224);
      v17 = *(_QWORD *)(v2 + 296);
      v18 = *(_OWORD *)(v17 + 64);
      *(_QWORD *)(v16 + 80) = *(_QWORD *)(v17 + 80);
      *(_OWORD *)(v16 + 64) = v18;
    }
    *(_BYTE *)(v2 + 304) = 1;
  }
  else if (!*(_BYTE *)(v2 + 104))
  {
    v19 = *(const void **)(v2 + 224);
    if (v19)
    {
      CFRelease(v19);
      *(_QWORD *)(v2 + 224) = 0;
    }
  }
  if (!*(_BYTE *)(a1 + 20))
    goto LABEL_51;
  v20 = *(_DWORD *)(v2 + 336);
  if ((v20 & 2) != 0)
    v21 = 2;
  else
    v21 = 1;
  if (v21 != *(_DWORD *)(v2 + 340))
  {
    *(_DWORD *)(v2 + 340) = v21;
    figTimelineCoordinator_sendParticipantStateToGroupOnQueue(v2);
  }
  if ((v20 & 2) == 0)
    goto LABEL_51;
LABEL_52:
  v22 = *(const void **)(a1 + 24);
  if (v22)
    CFRelease(v22);
  v23 = *(const void **)(a1 + 8);
  if (v23)
    CFRelease(v23);
  if (*(_QWORD *)a1)
    CFRelease(*(CFTypeRef *)a1);
  free((void *)a1);
}

void figTimelineCoordinator_suspendTimelineControlCommandCompletionTimer(uint64_t a1)
{
  NSObject *v1;

  v1 = *(NSObject **)(a1 + 112);
  if (v1)
    dispatch_source_set_timer(v1, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x5F5E100uLL);
  else
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t figTimelineCoordinatorRemoveSuspensionInternal(uint64_t a1, const void *a2)
{
  const __CFArray *v4;
  CFIndex FirstIndexOfValue;
  CFRange v7;

  v4 = *(const __CFArray **)(a1 + 424);
  v7.length = CFArrayGetCount(v4);
  v7.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v4, v7, a2);
  if (FirstIndexOfValue == -1)
    return FigSignalErrorAt(4294951585, 0, 0, 0, 0, 0, 0);
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 424), FirstIndexOfValue);
  return 0;
}

void figTimelineCoordinator_issueProposeTimelineForIdentifierOnQueue(uint64_t a1)
{
  id *v2;
  id *v3;
  void (*v4)(id *, _QWORD);

  v2 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 80));
  v3 = v2;
  v4 = *(void (**)(id *, _QWORD))(a1 + 72);
  if (v4)
  {
    if (v2)
    {
      v4(v2, *(_QWORD *)(a1 + 352));
LABEL_4:
      CFRelease(v3);
      return;
    }
    FigSignalErrorAt(4294951581, 0, 0, 0, 0, 0, 0);
  }
  else if (v2)
  {
    goto LABEL_4;
  }
}

uint64_t figTimelineCoordinator_resetGroupExpectationsOnQueue(uint64_t a1)
{
  const void *v2;
  uint64_t v3;
  uint64_t result;
  const void *v5;
  CFTypeRef v6;
  CFTypeRef cf;

  *(_BYTE *)(a1 + 280) = 0;
  v2 = *(const void **)(a1 + 272);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 272) = 0;
  }
  if (FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 328)))
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 320));
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 328));
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 320));
    figTimelineCoordinator_postParticipantsDidChange((const void **)a1);
  }
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 216));
  figTimelineCoordinator_sendParticipantStateToGroupOnQueue(a1);
  v3 = *(_QWORD *)(a1 + 200);
  if (!v3)
    return 0;
  if (*(_QWORD *)(v3 + 24))
  {
    cf = 0;
    result = figTimelineCoordinatorTimelineStateCopy(*MEMORY[0x1E0C9AE00], v3, &cf);
    if ((_DWORD)result)
      return result;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 184));
    v5 = *(const void **)(a1 + 200);
    v6 = cf;
    *(_QWORD *)(a1 + 200) = cf;
    if (v6)
      CFRetain(v6);
    if (v5)
      CFRelease(v5);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 184));
    if (cf)
      CFRelease(cf);
    v3 = *(_QWORD *)(a1 + 200);
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 216), *(const void **)(v3 + 88), (const void *)v3);
  return figTimelineCoordinator_sendExpectedTimelineStateToGroupOnQueue(a1);
}

uint64_t figTimelineCoordinator_removeValueFromArray(CFArrayRef theArray, const void *a2)
{
  uint64_t result;
  CFIndex FirstIndexOfValue;
  CFRange v6;

  result = 0;
  if (theArray && a2)
  {
    v6.length = CFArrayGetCount(theArray);
    v6.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(theArray, v6, a2);
    if (FirstIndexOfValue == -1)
    {
      return 0;
    }
    else
    {
      CFArrayRemoveValueAtIndex(theArray, FirstIndexOfValue);
      return 1;
    }
  }
  return result;
}

void figTimelineCoordinator_updateParticipantsWithNewLocalIdentifierApply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *v5;
  const void *v6;
  uint64_t v7;
  _BOOL4 v8;
  const void *v9;
  Boolean v10;

  v5 = *(const void **)a3;
  v6 = participantState_timelineIdentifier(*(const __CFDictionary **)(a2 + 16));
  if (!FigCFEqual(v5, *(CFTypeRef *)(a2 + 24)))
  {
    v7 = *(_QWORD *)(a2 + 16);
    v10 = 0;
    FigCFDictionaryGetBooleanIfPresent(v7, CFSTR("ReadyToSetNonZeroRate"), &v10);
    if (v10)
    {
      if (FigCFEqual(v5, v6))
        v8 = 1;
      else
        v8 = FigCFEqual(*(CFTypeRef *)(a2 + 24), v6) != 0;
    }
    else
    {
      v8 = 0;
    }
    v9 = *(const void **)(a2 + 24);
    *(_QWORD *)(a2 + 24) = v5;
    if (v5)
      CFRetain(v5);
    if (v9)
      CFRelease(v9);
    if (v8)
      *(_BYTE *)(a3 + 8) = 1;
  }
}

uint64_t FigBBMessageCreate(const __CFAllocator *a1, CMBlockBufferRef *a2)
{
  uint64_t v4;
  __CFData *Mutable;
  CMBlockBufferRef blockBufferOut;

  blockBufferOut = 0;
  v4 = CMBlockBufferCreateEmpty(a1, 0, 0, &blockBufferOut);
  if ((_DWORD)v4)
  {
    Mutable = blockBufferOut;
    if (!blockBufferOut)
      return v4;
    goto LABEL_3;
  }
  Mutable = CFDataCreateMutable(a1, 0);
  CFDataSetLength(Mutable, 456);
  *(_DWORD *)CFDataGetBytePtr(Mutable) = 8;
  CMSetAttachment(blockBufferOut, CFSTR("MessageLayout"), Mutable, 0);
  *a2 = blockBufferOut;
  blockBufferOut = 0;
  if (Mutable)
LABEL_3:
    CFRelease(Mutable);
  return v4;
}

uint64_t FigBBMessageSetInt64(const void *a1, int a2, uint64_t a3)
{
  const __CFData *v5;
  uint64_t v6;
  uint64_t result;

  v5 = (const __CFData *)CMGetAttachment(a1, CFSTR("MessageLayout"), 0);
  if (!v5)
    return 4294950414;
  v6 = AcquireLayoutEntry(v5, a2);
  result = 0;
  *(_DWORD *)v6 = a2;
  *(_QWORD *)(v6 + 32) = a3;
  *(_QWORD *)(v6 + 40) = 8;
  *(_QWORD *)(v6 + 8) = bbmsg_CopyInt64;
  return result;
}

uint64_t AcquireLayoutEntry(const __CFData *a1, int a2)
{
  UInt8 *BytePtr;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  BytePtr = (UInt8 *)CFDataGetBytePtr(a1);
  v5 = *((_DWORD *)BytePtr + 1);
  if (v5 < 1)
  {
LABEL_5:
    if (v5 == *(_DWORD *)BytePtr)
    {
      v8 = v5 + 4;
      CFDataSetLength(a1, 56 * v5 + 232);
      BytePtr = (UInt8 *)CFDataGetBytePtr(a1);
      *(_DWORD *)BytePtr = v8;
      v5 = *((_DWORD *)BytePtr + 1);
    }
    v6 = (uint64_t)&BytePtr[56 * v5 + 8];
    *((_DWORD *)BytePtr + 1) = v5 + 1;
  }
  else
  {
    v6 = (uint64_t)(BytePtr + 8);
    v7 = *((unsigned int *)BytePtr + 1);
    while (*(_DWORD *)v6 != a2)
    {
      v6 += 56;
      if (!--v7)
        goto LABEL_5;
    }
  }
  *(_QWORD *)(v6 + 48) = 0;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_OWORD *)(v6 + 32) = 0u;
  *(_OWORD *)v6 = 0u;
  return v6;
}

_QWORD *bbmsg_CopyInt64(_QWORD *result, uint64_t a2, uint64_t a3)
{
  if (a2 == 8)
    *result = *(_QWORD *)(a3 + 32);
  return result;
}

uint64_t FigBBMessageSetFloat32(const void *a1, int a2, float a3)
{
  const __CFData *v5;
  uint64_t v6;
  uint64_t result;

  v5 = (const __CFData *)CMGetAttachment(a1, CFSTR("MessageLayout"), 0);
  if (!v5)
    return 4294950414;
  v6 = AcquireLayoutEntry(v5, a2);
  result = 0;
  *(_DWORD *)v6 = a2;
  *(_QWORD *)(v6 + 40) = 4;
  *(float *)(v6 + 32) = a3;
  *(_QWORD *)(v6 + 8) = bbmsg_CopyFloat32;
  return result;
}

_DWORD *bbmsg_CopyFloat32(_DWORD *result, uint64_t a2, uint64_t a3)
{
  if (a2 == 4)
    *result = *(_DWORD *)(a3 + 32);
  return result;
}

uint64_t FigBBMessageSetDataPtr(const void *a1, int a2, uint64_t a3, uint64_t a4)
{
  const __CFData *v7;
  uint64_t v8;
  uint64_t result;

  v7 = (const __CFData *)CMGetAttachment(a1, CFSTR("MessageLayout"), 0);
  if (!v7)
    return 4294950414;
  v8 = AcquireLayoutEntry(v7, a2);
  result = 0;
  *(_DWORD *)v8 = a2;
  *(_QWORD *)(v8 + 24) = a3;
  *(_QWORD *)(v8 + 40) = a4;
  return result;
}

uint64_t FigBBMessageSetCString(const void *a1, int a2, uint64_t a3)
{
  const __CFData *v5;
  uint64_t v6;
  uint64_t result;

  v5 = (const __CFData *)CMGetAttachment(a1, CFSTR("MessageLayout"), 0);
  if (!v5)
    return 4294950414;
  v6 = AcquireLayoutEntry(v5, a2);
  result = 0;
  *(_DWORD *)v6 = a2;
  *(_QWORD *)(v6 + 16) = DL_CStringSizer;
  *(_QWORD *)(v6 + 24) = a3;
  return result;
}

const char *DL_CStringSizer(uint64_t a1)
{
  const char *result;

  result = *(const char **)(a1 + 24);
  if (result)
    return (const char *)(strlen(result) + 1);
  return result;
}

uint64_t FigBBMessageSetCFData(const void *a1, int a2, uint64_t a3)
{
  const __CFData *v5;
  uint64_t v6;
  uint64_t result;

  v5 = (const __CFData *)CMGetAttachment(a1, CFSTR("MessageLayout"), 0);
  if (!v5)
    return 4294950414;
  v6 = AcquireLayoutEntry(v5, a2);
  result = 0;
  *(_DWORD *)v6 = a2;
  *(_QWORD *)(v6 + 16) = DL_CFDataSizer;
  *(_QWORD *)(v6 + 24) = a3;
  *(_QWORD *)(v6 + 8) = DL_CFDataCopier;
  return result;
}

CFIndex DL_CFDataSizer(uint64_t a1)
{
  const __CFData *v1;
  CFTypeID v2;

  v1 = *(const __CFData **)(a1 + 24);
  if (v1 && (v2 = CFGetTypeID(*(CFTypeRef *)(a1 + 24)), v2 == CFDataGetTypeID()))
    return CFDataGetLength(v1);
  else
    return 0;
}

void *DL_CFDataCopier(void *a1, size_t a2, uint64_t a3)
{
  const __CFData *v5;
  unint64_t Length;
  void *result;
  const void *v8;
  CFTypeID v9;
  size_t v10;

  v5 = *(const __CFData **)(a3 + 24);
  Length = CFDataGetLength(v5);
  result = (void *)CFDataGetBytePtr(v5);
  if (v5)
  {
    v8 = result;
    v9 = CFGetTypeID(v5);
    result = (void *)CFDataGetTypeID();
    if ((void *)v9 == result)
    {
      if (Length >= a2)
        v10 = a2;
      else
        v10 = Length;
      return memcpy(a1, v8, v10);
    }
  }
  return result;
}

uint64_t FigBBMessageSetCFString(const void *a1, int a2, uint64_t a3)
{
  const __CFData *v5;
  uint64_t v6;
  uint64_t result;

  v5 = (const __CFData *)CMGetAttachment(a1, CFSTR("MessageLayout"), 0);
  if (!v5)
    return 4294950414;
  v6 = AcquireLayoutEntry(v5, a2);
  result = 0;
  *(_DWORD *)v6 = a2;
  *(_QWORD *)(v6 + 16) = DL_CFStringSizer;
  *(_QWORD *)(v6 + 24) = a3;
  *(_QWORD *)(v6 + 8) = DL_CFStringCopier;
  return result;
}

CFIndex DL_CFStringSizer(uint64_t a1)
{
  const __CFString *v1;
  CFTypeID v2;
  CFIndex Length;

  v1 = *(const __CFString **)(a1 + 24);
  if (!v1)
    return 0;
  v2 = CFGetTypeID(*(CFTypeRef *)(a1 + 24));
  if (v2 != CFStringGetTypeID())
    return 0;
  Length = CFStringGetLength(v1);
  return CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
}

CFTypeID DL_CFStringCopier(CFTypeID result, CFIndex a2, uint64_t a3)
{
  const __CFString *v3;
  char *v5;
  CFTypeID v6;

  v3 = *(const __CFString **)(a3 + 24);
  if (v3)
  {
    v5 = (char *)result;
    v6 = CFGetTypeID(*(CFTypeRef *)(a3 + 24));
    result = CFStringGetTypeID();
    if (v6 == result)
      return CFStringGetCString(v3, v5, a2, 0x8000100u);
  }
  return result;
}

uint64_t FigBBMessageSetCFDictionary(const void *a1, int a2, uint64_t a3)
{
  const __CFData *v5;
  uint64_t v6;
  uint64_t result;

  v5 = (const __CFData *)CMGetAttachment(a1, CFSTR("MessageLayout"), 0);
  if (!v5)
    return 4294950414;
  v6 = AcquireLayoutEntry(v5, a2);
  result = 0;
  *(_DWORD *)v6 = a2;
  *(_QWORD *)(v6 + 16) = DL_CFDictSizer;
  *(_QWORD *)(v6 + 24) = a3;
  *(_QWORD *)(v6 + 8) = DL_CFDictCopier;
  return result;
}

CFIndex DL_CFDictSizer(uint64_t a1)
{
  const void *v1;
  CFTypeID v3;
  const __CFData *v4;
  CFErrorRef v5;
  CFIndex result;
  CFErrorRef error;

  v1 = *(const void **)(a1 + 24);
  error = 0;
  if (!v1)
    return 0;
  v3 = CFGetTypeID(v1);
  if (v3 != CFDictionaryGetTypeID())
    return 0;
  v4 = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v1, kCFPropertyListBinaryFormat_v1_0, 0, &error);
  v5 = error;
  if (!error)
  {
    if (!v4)
      return 0;
    result = CFDataGetLength(v4);
    if (result)
    {
      *(_QWORD *)(a1 + 48) = v4;
      return result;
    }
    v5 = v4;
  }
  CFRelease(v5);
  return 0;
}

void DL_CFDictCopier(void *a1, size_t a2, uint64_t a3)
{
  const __CFData *v6;
  unint64_t Length;
  const UInt8 *BytePtr;
  const UInt8 *v9;
  CFTypeID v10;
  size_t v11;

  v6 = *(const __CFData **)(a3 + 48);
  Length = CFDataGetLength(v6);
  BytePtr = CFDataGetBytePtr(v6);
  if (v6)
  {
    v9 = BytePtr;
    v10 = CFGetTypeID(v6);
    if (v10 == CFDataGetTypeID())
    {
      if (Length >= a2)
        v11 = a2;
      else
        v11 = Length;
      memcpy(a1, v9, v11);
    }
    CFRelease(v6);
    *(_QWORD *)(a3 + 48) = 0;
  }
}

uint64_t FigBBMessageSetCFArray(const void *a1, int a2, uint64_t a3)
{
  const __CFData *v5;
  uint64_t v6;
  uint64_t result;

  v5 = (const __CFData *)CMGetAttachment(a1, CFSTR("MessageLayout"), 0);
  if (!v5)
    return 4294950414;
  v6 = AcquireLayoutEntry(v5, a2);
  result = 0;
  *(_DWORD *)v6 = a2;
  *(_QWORD *)(v6 + 16) = DL_CFArraySizer;
  *(_QWORD *)(v6 + 24) = a3;
  *(_QWORD *)(v6 + 8) = DL_CFArrayCopier;
  return result;
}

CFIndex DL_CFArraySizer(uint64_t a1)
{
  const void *v1;
  CFTypeID v3;
  const __CFData *v4;
  CFErrorRef v5;
  CFIndex result;
  CFErrorRef error;

  v1 = *(const void **)(a1 + 24);
  error = 0;
  if (!v1)
    return 0;
  v3 = CFGetTypeID(v1);
  if (v3 != CFArrayGetTypeID())
    return 0;
  v4 = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v1, kCFPropertyListBinaryFormat_v1_0, 0, &error);
  v5 = error;
  if (!error)
  {
    if (!v4)
      return 0;
    result = CFDataGetLength(v4);
    if (result)
    {
      *(_QWORD *)(a1 + 48) = v4;
      return result;
    }
    v5 = v4;
  }
  CFRelease(v5);
  return 0;
}

void DL_CFArrayCopier(void *a1, size_t a2, uint64_t a3)
{
  const __CFData *v6;
  unint64_t Length;
  const UInt8 *BytePtr;
  const UInt8 *v9;
  CFTypeID v10;
  size_t v11;

  v6 = *(const __CFData **)(a3 + 48);
  Length = CFDataGetLength(v6);
  BytePtr = CFDataGetBytePtr(v6);
  if (v6)
  {
    v9 = BytePtr;
    v10 = CFGetTypeID(v6);
    if (v10 == CFDataGetTypeID())
    {
      if (Length >= a2)
        v11 = a2;
      else
        v11 = Length;
      memcpy(a1, v9, v11);
    }
    CFRelease(v6);
    *(_QWORD *)(a3 + 48) = 0;
  }
}

uint64_t FigBBMessageSetBlockBuffer(const void *a1, int a2, uint64_t a3)
{
  const __CFData *v5;
  uint64_t v6;
  uint64_t result;

  v5 = (const __CFData *)CMGetAttachment(a1, CFSTR("MessageLayout"), 0);
  if (!v5)
    return 4294950414;
  v6 = AcquireLayoutEntry(v5, a2);
  result = 0;
  *(_DWORD *)v6 = a2;
  *(_QWORD *)(v6 + 16) = DL_BlockBufferSizer;
  *(_QWORD *)(v6 + 24) = a3;
  *(_QWORD *)(v6 + 8) = DL_BlockBufferCopier;
  return result;
}

size_t DL_BlockBufferSizer(uint64_t a1)
{
  OpaqueCMBlockBuffer *v1;
  CFTypeID v2;

  v1 = *(OpaqueCMBlockBuffer **)(a1 + 24);
  if (v1 && (v2 = CFGetTypeID(*(CFTypeRef *)(a1 + 24)), v2 == CMBlockBufferGetTypeID()))
    return CMBlockBufferGetDataLength(v1);
  else
    return 0;
}

CFTypeID DL_BlockBufferCopier(CFTypeID result, size_t a2, uint64_t a3)
{
  OpaqueCMBlockBuffer *v3;
  void *v5;
  CFTypeID v6;

  v3 = *(OpaqueCMBlockBuffer **)(a3 + 24);
  if (v3)
  {
    v5 = (void *)result;
    v6 = CFGetTypeID(*(CFTypeRef *)(a3 + 24));
    result = CMBlockBufferGetTypeID();
    if (v6 == result)
      return CMBlockBufferCopyDataBytes(v3, 0, a2, v5);
  }
  return result;
}

uint64_t FigBBMessageCommit(void *a1)
{
  const __CFData *v2;
  const UInt8 *BytePtr;

  v2 = (const __CFData *)CMGetAttachment(a1, CFSTR("MessageLayout"), 0);
  if (!v2)
    return 4294950414;
  BytePtr = CFDataGetBytePtr(v2);
  if (!BytePtr)
    return 4294950414;
  ProcessDataLayoutEntries((OpaqueCMBlockBuffer *)a1, *((_DWORD *)BytePtr + 1), (uint64_t)(BytePtr + 8), 0);
  CMRemoveAttachment(a1, CFSTR("MessageLayout"));
  return 0;
}

char *ProcessDataLayoutEntries(OpaqueCMBlockBuffer *a1, int a2, uint64_t a3, size_t a4)
{
  uint64_t (*v8)(uint64_t);
  size_t v9;
  char *result;
  uint64_t v11;
  char *v12;
  uint64_t (*v13)(char *, size_t, uint64_t);
  const void *v14;
  unsigned int v15;
  char *dataPointerOut;

  if (!a2)
    return (char *)CMBlockBufferAppendMemoryBlock(a1, 0, a4, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, a4, 1u);
  v8 = *(uint64_t (**)(uint64_t))(a3 + 16);
  if (v8)
    v9 = v8(a3);
  else
    v9 = *(_QWORD *)(a3 + 40);
  v11 = (int)v9 + 8;
  if (!v9)
    v11 = 0;
  result = (char *)ProcessDataLayoutEntries(a1, (a2 - 1), a3 + 56, v11 + a4);
  if (v9)
  {
    dataPointerOut = 0;
    CMBlockBufferGetDataPointer(a1, a4, 0, 0, &dataPointerOut);
    v12 = dataPointerOut;
    result = dataPointerOut + 8;
    v13 = *(uint64_t (**)(char *, size_t, uint64_t))(a3 + 8);
    if (v13)
    {
      result = (char *)v13(result, v9, a3);
    }
    else
    {
      v14 = *(const void **)(a3 + 24);
      if (v14)
        result = (char *)memcpy(result, v14, v9);
    }
    v15 = bswap32(*(_DWORD *)a3);
    *(_DWORD *)v12 = bswap32(v9 + 8);
    *((_DWORD *)v12 + 1) = v15;
  }
  return result;
}

uint64_t FigBBMessageGetInt64(OpaqueCMBlockBuffer *a1, int a2, _DWORD *a3)
{
  char *v4;
  uint64_t result;
  size_t v6;
  int v7;

  v7 = 0;
  v6 = 0;
  v4 = AccessDataForTag(a1, a2, &v6, &v7);
  result = 0;
  if (v4 && v6 == 8)
    result = *(_QWORD *)v4;
  if (a3)
    *a3 = v7;
  return result;
}

char *AccessDataForTag(OpaqueCMBlockBuffer *a1, int a2, size_t *a3, _DWORD *a4)
{
  int DataPointer;
  char *v8;
  char *v10;
  size_t lengthAtOffsetOut;
  size_t v12;
  size_t offset;

  v12 = 0;
  offset = 0;
  v10 = 0;
  lengthAtOffsetOut = 0;
  DataPointer = LocateParameterTag(a1, a2, &offset, &v12);
  if (DataPointer || (DataPointer = CMBlockBufferGetDataPointer(a1, offset, &lengthAtOffsetOut, 0, &v10)) != 0)
  {
LABEL_10:
    v8 = 0;
    if (!a4)
      return v8;
    goto LABEL_7;
  }
  if (lengthAtOffsetOut < v12)
  {
    DataPointer = 0;
    goto LABEL_10;
  }
  v8 = v10;
  DataPointer = 0;
  if (a3)
    *a3 = v12;
  if (a4)
LABEL_7:
    *a4 = DataPointer;
  return v8;
}

char *FigBBMessageGetFloat32(OpaqueCMBlockBuffer *a1, int a2, _DWORD *a3)
{
  char *result;
  size_t v5;
  int v6;

  v6 = 0;
  v5 = 0;
  result = AccessDataForTag(a1, a2, &v5, &v6);
  if (a3)
    *a3 = v6;
  return result;
}

char *FigBBMessageGetCString(OpaqueCMBlockBuffer *a1, int a2, int *a3)
{
  char *result;
  int v5;
  size_t v6;
  int v7;

  v7 = 0;
  v6 = 0;
  result = AccessDataForTag(a1, a2, &v6, &v7);
  v5 = v7;
  if (!v7)
  {
    if (result[v6])
      v5 = -16884;
    else
      v5 = 0;
  }
  if (a3)
    *a3 = v5;
  return result;
}

uint64_t FigBBMessageCopyCFData(OpaqueCMBlockBuffer *a1, int a2, CFDataRef *a3)
{
  uint64_t result;
  unint64_t v6;
  size_t v7;

  v6 = 0;
  v7 = 0;
  result = LocateParameterTag(a1, a2, &v7, &v6);
  if (!(_DWORD)result)
    return FigCreateCFDataWithBlockBufferNoCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a1, v7, v6, a3);
  return result;
}

uint64_t LocateParameterTag(OpaqueCMBlockBuffer *a1, int a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  _OWORD v10[7];

  memset(v10, 0, sizeof(v10));
  v8 = 0;
  v9 = 0;
  result = FigAtomStreamInitWithBBuf(a1, 0, 0, (uint64_t)v10);
  if (!(_DWORD)result)
  {
    if (FigAtomStreamPositionAtFirstAtomWithType((uint64_t)v10, a2))
      return 4294950413;
    if (a3)
    {
      result = FigAtomStreamGetCurrentAtomDataGlobalOffset((uint64_t)v10, 0, &v8);
      if ((_DWORD)result)
        return result;
      *a3 = v8;
    }
    if (a4)
    {
      result = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v10, 0, &v9);
      if (!(_DWORD)result)
        *a4 = v9;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t FigBBMessageCopyBlockBuffer(OpaqueCMBlockBuffer *a1, int a2, CMBlockBufferRef *a3)
{
  uint64_t result;
  size_t v6;
  size_t v7;

  v6 = 0;
  v7 = 0;
  result = LocateParameterTag(a1, a2, &v7, &v6);
  if (!(_DWORD)result)
    return CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, v7, v6, 0, a3);
  return result;
}

uint64_t FigBBMessageCopyCFString(OpaqueCMBlockBuffer *a1, int a2, CFStringRef *a3)
{
  char *v4;
  CFStringRef v5;
  unsigned int v7;

  v7 = 0;
  v4 = AccessDataForTag(a1, a2, 0, &v7);
  if (!v4)
    return 4294950415;
  v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v4, 0x8000100u);
  if (!v5)
    return 4294950415;
  *a3 = v5;
  return v7;
}

uint64_t FigBBMessageCopyCFDictionary(OpaqueCMBlockBuffer *a1, int a2, _QWORD *a3)
{
  uint64_t v4;
  CFPropertyListRef v5;
  uint64_t v6;
  CFDataRef data;

  data = 0;
  v4 = FigBBMessageCopyCFData(a1, a2, &data);
  if ((_DWORD)v4)
  {
    v6 = v4;
  }
  else
  {
    v5 = CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], data, 0, 0, 0);
    if (v5)
    {
      v6 = 0;
      *a3 = v5;
    }
    else
    {
      v6 = 4294950415;
    }
  }
  if (data)
    CFRelease(data);
  return v6;
}

uint64_t FigBBMessageCopyCFArray(OpaqueCMBlockBuffer *a1, int a2, _QWORD *a3)
{
  uint64_t v4;
  CFPropertyListRef v5;
  uint64_t v6;
  CFDataRef data;

  data = 0;
  v4 = FigBBMessageCopyCFData(a1, a2, &data);
  if ((_DWORD)v4)
  {
    v6 = v4;
  }
  else
  {
    v5 = CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], data, 0, 0, 0);
    if (v5)
    {
      v6 = 0;
      *a3 = v5;
    }
    else
    {
      v6 = 4294950415;
    }
  }
  if (data)
    CFRelease(data);
  return v6;
}

uint64_t FigCaptionGroupGetTypeID()
{
  FigThreadRunOnce(&sRegisterFigCaptionGroupTypeOnce, (void (*)(void))RegisterFigCaptionGroupType);
  return sFigCaptionGroupID;
}

uint64_t RegisterFigCaptionGroupType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigCaptionGroupID = result;
  return result;
}

uint64_t FigCaptionGroupCreate(const __CFAllocator *a1, CFArrayRef theArray, CMTime *a3, CMTime *a4, uint64_t *a5)
{
  CFIndex Count;
  unint64_t v9;
  CMTime *v10;
  CMTime *v11;
  CFIndex v12;
  uint64_t Instance;
  uint64_t v14;
  void *v15;
  void *v16;
  uint64_t result;
  size_t v18;
  CMTime time2;
  CMTime time1;

  if (!theArray || !a5)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  Count = CFArrayGetCount(theArray);
  v9 = Count;
  if (Count < 1)
  {
LABEL_10:
    FigThreadRunOnce(&sRegisterFigCaptionGroupTypeOnce, (void (*)(void))RegisterFigCaptionGroupType);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v14 = Instance;
      *(_QWORD *)(Instance + 16) = CFArrayCreateCopy(a1, theArray);
      if (v9)
      {
        if (v9 <= 0xAAAAAAAAAAAAAAALL && 24 * v9)
        {
          *(_QWORD *)(v14 + 24) = malloc_type_malloc(24 * v9, 0xD1AAB5CuLL);
          v15 = malloc_type_malloc(24 * v9, 0xD1AAB5CuLL);
          v16 = *(void **)(v14 + 24);
        }
        else
        {
          v16 = 0;
          v15 = 0;
          *(_QWORD *)(v14 + 24) = 0;
        }
        *(_QWORD *)(v14 + 32) = v15;
        if (v9 <= 0xAAAAAAAAAAAAAAALL)
          v18 = 24 * v9;
        else
          v18 = 0;
        memcpy(v16, a3, v18);
        memcpy(*(void **)(v14 + 32), a4, v18);
      }
      result = 0;
      *a5 = v14;
    }
    else
    {
      FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      return 0;
    }
  }
  else
  {
    v11 = a3;
    v10 = a4;
    v12 = Count;
    while ((v11->flags & 0x1D) == 1)
    {
      time1 = *v11;
      *(_OWORD *)&time2.value = *(_OWORD *)&kCMTimeZero.value;
      time2.epoch = 0;
      if (CMTimeCompare(&time1, &time2) < 0)
        break;
      if ((v10->flags & 0x1D) != 1)
        break;
      time1 = *v10;
      *(_OWORD *)&time2.value = *(_OWORD *)&kCMTimeZero.value;
      time2.epoch = 0;
      if (CMTimeCompare(&time1, &time2) < 0)
        break;
      ++v10;
      ++v11;
      if (!--v12)
        goto LABEL_10;
    }
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigCaptionGroupCreateEmpty(const __CFAllocator *a1, uint64_t *a2)
{
  const __CFArray *v4;
  uint64_t v5;

  v4 = CFArrayCreate(a1, 0, 0, MEMORY[0x1E0C9B378]);
  v5 = FigCaptionGroupCreate(a1, v4, (CMTime *)&kCMTimeZero, (CMTime *)&kCMTimeZero, a2);
  if (v4)
    CFRelease(v4);
  return v5;
}

CFIndex FigCaptionGroupGetSliceCount(uint64_t a1)
{
  if (a1)
    return CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
  FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  return 0;
}

const void *FigCaptionGroupGetCaptionData(uint64_t a1, CFIndex a2)
{
  if (a1)
    return CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), a2);
  FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  return 0;
}

CFIndex FigCaptionGroupGetDurationBeforeSlice@<X0>(uint64_t a1@<X0>, CFIndex a2@<X1>, uint64_t a3@<X8>)
{
  CFIndex result;
  uint64_t v7;

  *(_OWORD *)a3 = *(_OWORD *)&kCMTimeInvalid.value;
  *(_QWORD *)(a3 + 16) = 0;
  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  result = CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
  if (result <= a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v7 = *(_QWORD *)(a1 + 24) + 24 * a2;
  *(_OWORD *)a3 = *(_OWORD *)v7;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)(v7 + 16);
  return result;
}

CFIndex FigCaptionGroupGetDurationAfterSlice@<X0>(uint64_t a1@<X0>, CFIndex a2@<X1>, uint64_t a3@<X8>)
{
  CFIndex result;
  uint64_t v7;

  *(_OWORD *)a3 = *(_OWORD *)&kCMTimeInvalid.value;
  *(_QWORD *)(a3 + 16) = 0;
  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  result = CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
  if (result <= a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v7 = *(_QWORD *)(a1 + 32) + 24 * a2;
  *(_OWORD *)a3 = *(_OWORD *)v7;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)(v7 + 16);
  return result;
}

_QWORD *CaptionGroupInit(_QWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void CaptionGroupFinalize(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
    CFRelease(v2);
  free(*(void **)(a1 + 24));
  free(*(void **)(a1 + 32));
}

CFStringRef CaptionGroupCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionGroup %p]"), a1);
}

__CFString *CaptionGroupCopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  CFIndex Count;
  CFIndex v4;
  CFStringRef v5;
  const void *ValueAtIndex;
  Float64 Seconds;
  Float64 v8;
  CMTime v10;
  CMTime time;

  Mutable = CFStringCreateMutable(0, 0);
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 16));
  CFStringAppendFormat(Mutable, 0, CFSTR("FigCaptionGroup (number of captions = %ld)\n"), Count);
  if (Count)
  {
    v4 = 0;
    v5 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), v4);
      if (v5)
        CFRelease(v5);
      v5 = CFCopyDescription(ValueAtIndex);
      FigCaptionGroupGetDurationBeforeSlice(a1, v4, (uint64_t)&time);
      Seconds = CMTimeGetSeconds(&time);
      FigCaptionGroupGetDurationAfterSlice(a1, v4, (uint64_t)&v10);
      v8 = CMTimeGetSeconds(&v10);
      CFStringAppendFormat(Mutable, 0, CFSTR("BeforeSlice<%4.2f> AfterSlice<%4.2f> %@\n"), *(_QWORD *)&Seconds, *(_QWORD *)&v8, v5);
      ++v4;
    }
    while (Count != v4);
    if (v5)
      CFRelease(v5);
  }
  return Mutable;
}

uint64_t FigEndpointAudioSinkGetClassID()
{
  if (FigEndpointAudioSinkGetClassID_sRegisterOnce != -1)
    dispatch_once(&FigEndpointAudioSinkGetClassID_sRegisterOnce, &__block_literal_global_43);
  return FigEndpointAudioSinkGetClassID_sClassID;
}

CFStringRef Sink_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigEndpointAudioSink %p]"), a1);
}

uint64_t FigEndpointAudioSinkGetTypeID()
{
  if (FigEndpointAudioSinkGetClassID_sRegisterOnce != -1)
    dispatch_once(&FigEndpointAudioSinkGetClassID_sRegisterOnce, &__block_literal_global_43);
  return CMBaseClassGetCFTypeID((_QWORD *)FigEndpointAudioSinkGetClassID_sClassID);
}

uint64_t FigRemote_GetServerTimeoutToken()
{
  return getpid();
}

uint64_t FigRemote_GetServerPid()
{
  return gServerPid;
}

uint64_t FigRemote_SetServerPid(uint64_t result)
{
  gServerPid = result;
  return result;
}

uint64_t FigRemote_GetRPCTimeoutListenerPort()
{
  return dword_1ECDA8A40;
}

uint64_t FigRemote_LookUpServerTimeoutPort()
{
  if (gServerRPCTimeoutListener != -1)
    dispatch_once(&gServerRPCTimeoutListener, &__block_literal_global_44);
  FigSimpleMutexLock((pthread_mutex_t *)qword_1ECDA8A38);
  FigMachPortReleaseSendRight_(dword_1ECDA8A40, 0, 0, 0, 0);
  dword_1ECDA8A40 = 0;
  bootstrap_look_up(*MEMORY[0x1E0C81720], "com.apple.coremedia.admin", (mach_port_t *)&dword_1ECDA8A40);
  return FigSimpleMutexUnlock((pthread_mutex_t *)qword_1ECDA8A38);
}

uint64_t FigRPCServer_SetTimeoutNanoseconds(uint64_t result)
{
  gFigServerSideRPCTimeoutNanoseconds = result;
  return result;
}

uint64_t FigRPCServer_GetTimeoutNanoseconds()
{
  return gFigServerSideRPCTimeoutNanoseconds;
}

uint64_t FigRPCServer_PickRPCTimeoutForCurrentThread(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v4;
  unint64_t v5;
  int v6;
  _opaque_pthread_t *Current;
  int v9;
  CFTypeRef v10;
  uint64_t v11;
  CFTypeRef cf;

  v2 = a1;
  cf = 0;
  if (a1 && a2)
  {
    HIDWORD(v5) = qos_class_self() - 9;
    LODWORD(v5) = HIDWORD(v5);
    v4 = v5 >> 2;
    if (v4 <= 6)
    {
      v6 = 1 << v4;
      if ((v6 & 0xD) != 0)
      {
        v2 += a2;
        return v2;
      }
      if ((v6 & 0x50) != 0)
        return v2;
    }
    if (FigServer_IsServerProcess())
    {
      Current = FigThreadGetCurrent();
      v9 = FigThreadCopyProperty(Current, CFSTR("com.apple.fig.ThreadPropKey_MachThreadPriority"), *MEMORY[0x1E0C9AE00], &cf);
      v10 = cf;
      if (!v9)
      {
        if ((int)FigCFNumberGetSInt32((const __CFNumber *)cf) >= 32)
          v11 = 0;
        else
          v11 = a2;
        v2 += v11;
        v10 = cf;
      }
      if (v10)
        CFRelease(v10);
    }
  }
  return v2;
}

uint64_t fpServer_CreateRPCTimeoutThread()
{
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigRPCTimeoutServerTrace[1], CFSTR("rpctimeoutserver_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, gFigRPCTimeoutServerTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)algn_1ECDA8498, CFSTR("rpctimeoutserver_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 0, 0, &qword_1ECDA8490);
  if (fpServer_CreateRPCTimeoutThread_sFigRPCTimeoutServer != -1)
    dispatch_once(&fpServer_CreateRPCTimeoutThread_sFigRPCTimeoutServer, &__block_literal_global_8_0);
  return 0;
}

void FigRPCServer_TimeoutCrashReport(uint64_t a1, const char *a2)
{
  uint64_t v4;
  pid_t v5;
  const __CFString *v6;
  const __CFString *v7;
  CFTypeID v8;
  int v9;
  int v10;
  const char *v11;
  const char *v12;
  CFStringRef v13;
  NSObject *global_queue;
  NSObject *v15;
  dispatch_time_t v16;
  _QWORD handler[5];
  int v18;
  _BYTE buffer[3];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _BYTE v26[29];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v4 = getpid();
  memset(v26, 0, sizeof(v26));
  v25 = 0u;
  v24 = 0u;
  v23 = 0u;
  v22 = 0u;
  v21 = 0u;
  v20 = 0u;
  memset(buffer, 63, sizeof(buffer));
  v5 = getpid();
  proc_name(v5, buffer, 0x80u);
  if (in_audio_mx_server_process())
    LogACQEvents();
  v6 = (const __CFString *)CFPreferencesCopyValue(CFSTR("rpc_timeout_method"), CFSTR("com.apple.coremedia"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B230]);
  if (!v6)
  {
    v9 = 1;
    v10 = 1;
    goto LABEL_13;
  }
  v7 = v6;
  v8 = CFGetTypeID(v6);
  if (v8 != CFStringGetTypeID())
  {
    v9 = 1;
    v10 = 1;
    goto LABEL_12;
  }
  if (CFStringCompare(v7, CFSTR("SimulateCrash"), 1uLL) == kCFCompareEqualTo)
  {
    v9 = 0;
    goto LABEL_11;
  }
  v9 = 1;
  if (CFStringCompare(v7, CFSTR("Stackshot"), 1uLL) == kCFCompareEqualTo)
  {
LABEL_11:
    v10 = 0;
    goto LABEL_12;
  }
  v10 = 1;
  CFStringCompare(v7, CFSTR("Tailspin"), 1uLL);
  v9 = 1;
LABEL_12:
  CFRelease(v7);
LABEL_13:
  v11 = "<unspecified>";
  if (a2)
    v11 = a2;
  v12 = " stackshot taken";
  if (!v9)
    v12 = "";
  v13 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%s: RPCTimeout terminating %d for %d (%@) with reason '%s'%s"), buffer, v4, a1, 0, v11, v12);
  global_queue = dispatch_get_global_queue(2, 0);
  v15 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, global_queue);
  if (v13)
    CFRetain(v13);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 0x40000000;
  handler[2] = __FigRPCServer_TimeoutCrashReport_block_invoke;
  handler[3] = &__block_descriptor_tmp_26_2;
  v18 = v4;
  handler[4] = v13;
  dispatch_source_set_event_handler(v15, handler);
  v16 = dispatch_time(0, 10000000000);
  dispatch_source_set_timer(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_resume(v15);
  if (v10)
    FigUserTailspinWithMessage();
  if (v9)
  {
    FigUserStackshotWithMessage();
    if (!v13)
      return;
  }
  else
  {
    FigUserFaultWithMessage(3189297646, (uint64_t)v13);
    if (!v13)
      return;
  }
  CFRelease(v13);
}

uint64_t FigRPCTimeoutServer_KillAndForceCrashReport(uint64_t a1, uint64_t a2, const char *a3, _OWORD *a4)
{
  pid_t v7;
  pid_t v8;
  __int128 v10;
  uint64_t ClientPIDFromAuditToken;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v13;
  uint64_t v14;
  unsigned int v15;
  _OWORD *v16;
  os_log_type_t type;
  int v18[2];
  const char *v19;
  __int16 v20;
  pid_t v21;
  _OWORD v22[8];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v7 = getpid();
  v8 = getpid();
  if (gFigServerSideRPCTimeoutNanoseconds)
  {
    if (a2 && v8 != a2)
      return 4294950775;
    v10 = a4[1];
    v22[0] = *a4;
    v22[1] = v10;
    ClientPIDFromAuditToken = FigServer_GetClientPIDFromAuditToken(v22);
    FigRPCServer_TimeoutCrashReport(ClientPIDFromAuditToken, a3);
    v18[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA8490, 0, v18, &type);
    v13 = v18[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v15 = v13;
    else
      v15 = v13 & 0xFFFFFFFE;
    if (v15)
    {
      v18[1] = 136315394;
      v19 = "FigRPCTimeoutServer_KillAndForceCrashReport";
      v20 = 1024;
      v21 = v7;
      v16 = (_OWORD *)_os_log_send_and_compose_impl();
      LOBYTE(v13) = v18[0];
    }
    else
    {
      v16 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA8490, 0, 1, v16, v16 != v22, v13, 0, v14);
    kill(v7, 9);
  }
  return 0;
}

uint64_t FigRPCTimeout_KillAndForceCrashReport(mach_port_name_t a1, unsigned int a2, char *a3)
{
  return FigRPCTimeoutRemote_KillAndForceCrashReport(a1, a2, a3);
}

uint64_t FigRPCTimeoutServer_ResetFigNotePreset(uint64_t a1, uint64_t a2, int a3)
{
  if (a2 && a3)
    MEMORY[0x193FFCA84](*MEMORY[0x1E0C83DA0]);
  return 0;
}

uint64_t FigRPCTimeoutServer_SetFigNotePreferences(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned int a5, uint64_t a6, unsigned int a7)
{
  unsigned int *v11;

  v11 = (unsigned int *)MEMORY[0x1E0C83DA0];
  if (a2 && a3)
    MEMORY[0x193FFCA84](*MEMORY[0x1E0C83DA0]);
  if (a4 && a5)
    MEMORY[0x193FFCA84](*v11, a4, a5);
  if (a6 && a7)
    MEMORY[0x193FFCA84](*v11, a6, a7);
  return 0;
}

void FigRemote_InterpretMachErrorForTimeout(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD block[7];

  if (sSetupRPCTimeoutOnce != -1)
    dispatch_once(&sSetupRPCTimeoutOnce, &__block_literal_global_28_0);
  if (a1 == 268451843 || a1 == 268435460)
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __FigRemote_InterpretMachErrorForTimeout_block_invoke_2;
    block[3] = &__block_descriptor_tmp_30_2;
    block[4] = a2;
    block[5] = a3;
    block[6] = a4;
    dispatch_sync((dispatch_queue_t)sServerKillingQueue, block);
  }
  else if (!a1)
  {
    if (a2)
      sSuccessfulMessageServerToken = a2;
    if (FigAtomicCompareAndSwap32(0, 1u, (unsigned int *)&sMessageSentSuccessfully))
      gFigRemoteCommonTimeout = sTimeoutValueFromPreference;
  }
}

uint64_t FigRemote_HandleServerTimeout_WithExtraInfo(uint64_t a1, uint64_t a2, const __CFString *a3)
{
  size_t v5;
  char __s[512];
  char __dst[512];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  __strlcpy_chk();
  if (a3)
  {
    __strlcat_chk();
    v5 = strlen(__s);
    CFStringGetCString(a3, &__s[v5], 511 - v5, 0);
    __strlcat_chk();
  }
  if (!dword_1ECDA8A40)
    return 4294950776;
  memcpy(__dst, "fig rpc timeout -- ", sizeof(__dst));
  strlen(__dst);
  __strncat_chk();
  return FigRPCTimeoutRemote_KillAndForceCrashReport(dword_1ECDA8A40, a1, __dst);
}

uint64_t FigRemote_CreateSerializedAtomDataForFormatDescriptions(const __CFArray *a1, uint64_t *a2, vm_size_t a3, vm_size_t *a4)
{
  uint64_t v8;
  char v9;
  vm_map_t *v10;
  char v11;
  vm_size_t v12;
  uint64_t SerializedDataForFormatDescriptionArray;
  uint64_t v15;
  vm_size_t size;

  v15 = 0;
  size = 0;
  if (!a1 || !a2 || !a4)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v8 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if ((_DWORD)v8)
    return v8;
  v9 = 1;
  v10 = (vm_map_t *)MEMORY[0x1E0C83DA0];
  while (1)
  {
    v11 = v9;
    if (a3)
    {
      size = a3;
      v12 = a3;
    }
    else
    {
      v8 = fdescAtom_createSerializedDataForFormatDescriptionArray(a1, 0, 0, &size);
      if ((_DWORD)v8)
        return v8;
      v12 = size;
      if (!size)
      {
        SerializedDataForFormatDescriptionArray = 0;
        goto LABEL_18;
      }
    }
    SerializedDataForFormatDescriptionArray = vm_allocate(*v10, (vm_address_t *)&v15, v12, 1543503873);
    if (!(_DWORD)SerializedDataForFormatDescriptionArray)
    {
      SerializedDataForFormatDescriptionArray = fdescAtom_createSerializedDataForFormatDescriptionArray(a1, v15, size, 0);
      if (!(_DWORD)SerializedDataForFormatDescriptionArray)
        break;
    }
    v12 = size;
    if (v15 && size)
    {
      MEMORY[0x193FFCA84](*v10);
      v12 = 0;
      v15 = 0;
      size = 0;
    }
    if (!a3 || (_DWORD)SerializedDataForFormatDescriptionArray != -12572)
      goto LABEL_22;
    SerializedDataForFormatDescriptionArray = 4294954724;
LABEL_18:
    v9 = 0;
    a3 = 0;
    if ((v11 & 1) == 0)
      goto LABEL_22;
  }
  v12 = size;
LABEL_22:
  *a4 = v12;
  *a2 = v15;
  return SerializedDataForFormatDescriptionArray;
}

void sbufAtom_InitializeKnownKeys()
{
  void *v0;
  void *v1;
  void *v2;
  const __CFAllocator *v3;
  const void *v4;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  __CFDictionary *v9;
  const void *ValueAtIndex;
  void *values[71];
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const __CFString *v25;
  const __CFString *v26;
  const __CFString *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const __CFString *v37;
  const __CFString *v38;
  const __CFString *v39;
  const __CFString *v40;
  const __CFString *v41;
  const __CFString *v42;
  const __CFString *v43;
  const __CFString *v44;
  const __CFString *v45;
  const __CFString *v46;
  const __CFString *v47;
  const __CFString *v48;
  const __CFString *v49;
  const __CFString *v50;
  const __CFString *v51;
  const __CFString *v52;
  const __CFString *v53;
  const __CFString *v54;
  const __CFString *v55;
  const __CFString *v56;
  const __CFString *v57;
  const __CFString *v58;
  const __CFString *v59;
  const __CFString *v60;
  const __CFString *v61;
  const __CFString *v62;
  const __CFString *v63;
  const __CFString *v64;
  const __CFString *v65;
  const __CFString *v66;
  const __CFString *v67;
  const __CFString *v68;
  const __CFString *v69;
  const __CFString *v70;
  const __CFString *v71;
  const __CFString *v72;
  const __CFString *v73;
  const __CFString *v74;
  const __CFString *v75;
  const __CFString *v76;
  const __CFString *v77;
  const __CFString *v78;
  const __CFString *v79;
  const __CFString *v80;
  const __CFString *v81;
  const __CFString *v82;
  const __CFString *v83;
  const __CFString *v84;
  const __CFString *v85;
  const __CFString *v86;
  const __CFString *v87;
  const __CFString *v88;
  const __CFString *v89;
  const __CFString *v90;
  const __CFString *v91;
  const __CFString *v92;
  const __CFString *v93;
  const __CFString *v94;
  const __CFString *v95;
  const __CFString *v96;
  const __CFString *v97;
  const __CFString *v98;
  const __CFString *v99;
  const __CFString *v100;
  const __CFString *v101;
  const __CFString *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  const __CFString *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  const __CFString *v112;
  const __CFString *v113;
  const __CFString *v114;
  const __CFString *v115;
  const __CFString *v116;
  const __CFString *v117;
  const __CFString *v118;
  const __CFString *v119;
  const __CFString *v120;
  const __CFString *v121;
  const __CFString *v122;
  const __CFString *v123;
  const __CFString *v124;
  const __CFString *v125;
  const __CFString *v126;
  const __CFString *v127;
  const __CFString *v128;
  const __CFString *v129;
  const __CFString *v130;
  const __CFString *v131;
  const __CFString *v132;
  uint64_t v133;
  const __CFString *v134;
  const __CFString *v135;
  const __CFString *v136;
  const __CFString *v137;
  const __CFString *v138;
  const __CFString *v139;
  const __CFString *v140;
  const __CFString *v141;
  const __CFString *v142;
  const __CFString *v143;
  const __CFString *v144;
  const __CFString *v145;
  const __CFString *v146;
  const __CFString *v147;
  const __CFString *v148;
  const __CFString *v149;
  const __CFString *v150;
  const __CFString *v151;
  uint64_t v152;
  uint64_t v153;
  const __CFString *v154;
  uint64_t v155;
  uint64_t v156;
  const __CFString *v157;
  const __CFString *v158;
  const __CFString *v159;
  const __CFString *v160;
  const __CFString *v161;
  const __CFString *v162;
  const __CFString *v163;
  const __CFString *v164;
  const __CFString *v165;
  const __CFString *v166;
  const __CFString *v167;
  const __CFString *v168;
  const __CFString *v169;
  const __CFString *v170;
  const __CFString *v171;
  const __CFString *v172;
  const __CFString *v173;
  const __CFString *v174;
  const __CFString *v175;
  const __CFString *v176;
  const __CFString *v177;
  const __CFString *v178;
  const __CFString *v179;
  const __CFString *v180;
  const __CFString *v181;
  const __CFString *v182;
  const __CFString *v183;
  const __CFString *v184;
  const __CFString *v185;
  const __CFString *v186;
  const __CFString *v187;
  const __CFString *v188;
  const __CFString *v189;
  const __CFString *v190;
  const __CFString *v191;
  const __CFString *v192;
  const __CFString *v193;
  const __CFString *v194;
  const __CFString *v195;
  const __CFString *v196;
  const __CFString *v197;
  const __CFString *v198;
  const __CFString *v199;
  const __CFString *v200;
  const __CFString *v201;
  const __CFString *v202;
  const __CFString *v203;
  const __CFString *v204;
  const __CFString *v205;
  const __CFString *v206;
  const __CFString *v207;
  const __CFString *v208;
  const __CFString *v209;
  const __CFString *v210;
  const __CFString *v211;
  const __CFString *v212;
  const __CFString *v213;
  const __CFString *v214;
  const __CFString *v215;
  const __CFString *v216;
  const __CFString *v217;
  const __CFString *v218;
  const __CFString *v219;
  const __CFString *v220;
  const __CFString *v221;
  const __CFString *v222;
  const __CFString *v223;
  const __CFString *v224;
  const __CFString *v225;
  const __CFString *v226;
  const __CFString *v227;
  const __CFString *v228;
  const __CFString *v229;
  const __CFString *v230;
  const __CFString *v231;
  const __CFString *v232;
  const __CFString *v233;
  const __CFString *v234;
  const __CFString *v235;
  const __CFString *v236;
  const __CFString *v237;
  const __CFString *v238;
  const __CFString *v239;
  const __CFString *v240;
  const __CFString *v241;
  const __CFString *v242;
  const __CFString *v243;
  const __CFString *v244;
  const __CFString *v245;
  const __CFString *v246;
  const __CFString *v247;
  const __CFString *v248;
  const __CFString *v249;
  const __CFString *v250;
  const __CFString *v251;
  const __CFString *v252;
  const __CFString *v253;
  const __CFString *v254;
  const __CFString *v255;
  const __CFString *v256;
  const __CFString *v257;
  const __CFString *v258;
  const __CFString *v259;
  const __CFString *v260;
  const __CFString *v261;
  const __CFString *v262;
  const __CFString *v263;
  const __CFString *v264;
  const __CFString *v265;
  const __CFString *v266;
  const __CFString *v267;
  const __CFString *v268;
  const __CFString *v269;
  const __CFString *v270;
  const __CFString *v271;
  const __CFString *v272;
  const __CFString *v273;
  const __CFString *v274;
  const __CFString *v275;
  const __CFString *v276;
  const __CFString *v277;
  const __CFString *v278;
  const __CFString *v279;
  const __CFString *v280;
  const __CFString *v281;
  const __CFString *v282;
  const __CFString *v283;
  const __CFString *v284;
  const __CFString *v285;
  const __CFString *v286;
  const __CFString *v287;
  const __CFString *v288;
  const __CFString *v289;
  const __CFString *v290;
  const __CFString *v291;
  const __CFString *v292;
  uint64_t v293;

  v293 = *MEMORY[0x1E0C80C00];
  values[0] = CFSTR("NotSync");
  values[1] = CFSTR("PartialSync");
  values[2] = CFSTR("HasRedundantCoding");
  values[3] = CFSTR("IsDependedOnByOthers");
  values[4] = CFSTR("DependsOnOthers");
  values[5] = CFSTR("EarlierDisplayTimesAllowed");
  values[6] = CFSTR("DisplayImmediately");
  values[7] = CFSTR("DoNotDisplay");
  values[8] = CFSTR("BytesOfClearDataCount");
  values[9] = CFSTR("CryptorIV");
  values[10] = CFSTR("ResetDecoderBeforeDecoding");
  values[11] = CFSTR("DrainAfterDecoding");
  values[12] = CFSTR("PostNotificationWhenConsumed");
  values[13] = CFSTR("ResumeOutput");
  values[14] = CFSTR("TrimDurationAtStart");
  values[15] = CFSTR("TrimDurationAtEnd");
  values[16] = CFSTR("SpeedMultiplier");
  values[17] = CFSTR("Reverse");
  values[18] = CFSTR("FillDiscontinuitiesWithSilence");
  values[19] = CFSTR("EmptyMedia");
  values[20] = CFSTR("PermanentEmptyMedia");
  values[21] = CFSTR("DisplayEmptyMediaImmediately");
  values[22] = CFSTR("EndsPreviousSampleDuration");
  values[23] = CFSTR("SampleReferenceURL");
  values[24] = CFSTR("SampleReferenceByteOffset");
  values[25] = CFSTR("GradualDecoderRefresh");
  values[26] = CFSTR("SourceRect");
  values[27] = CFSTR("DestRect");
  values[28] = CFSTR("VirtualDisplaySizeForDestRect");
  values[29] = CFSTR("SymmetricTransform");
  values[30] = CFSTR("LoudnessInfo");
  values[31] = CFSTR("TransitionID");
  values[32] = CFSTR("StartPresentationTimesStamp");
  values[33] = CFSTR("EndPresentationTimesStamp");
  values[34] = CFSTR("EditBoundary");
  values[35] = CFSTR("EmptyMediaBeforeBeginning");
  values[36] = CFSTR("ClientTimingInfo");
  values[37] = CFSTR("ReferenceWasRefreshed");
  values[38] = CFSTR("EncoderRetryCount");
  values[39] = CFSTR("RequireAcknowledgementToken");
  values[40] = CFSTR("value");
  values[41] = CFSTR("timescale");
  values[42] = CFSTR("epoch");
  values[43] = CFSTR("flags");
  values[44] = CFSTR("X");
  values[45] = CFSTR("Y");
  values[46] = CFSTR("Width");
  values[47] = CFSTR("Height");
  values[48] = CFSTR("com.apple.fig.format_description.original_compression_settings");
  values[49] = CFSTR("SampleDescriptionExtensionAtoms");
  values[50] = CFSTR("VerbatimSampleDescription");
  values[51] = CFSTR("VerbatimISOSampleEntry");
  values[52] = CFSTR("FormatName");
  values[53] = CFSTR("Depth");
  v0 = (void *)*MEMORY[0x1E0CA8D60];
  values[54] = *(void **)MEMORY[0x1E0CA8D50];
  values[55] = v0;
  v1 = (void *)*MEMORY[0x1E0CA8D48];
  values[56] = *(void **)MEMORY[0x1E0CA8D40];
  values[57] = v1;
  values[58] = *(void **)MEMORY[0x1E0CA8D58];
  values[59] = CFSTR("HeightAsRational");
  values[60] = CFSTR("HorizontalOffsetAsRational");
  values[61] = CFSTR("VerticalOffsetAsRational");
  v2 = (void *)*MEMORY[0x1E0CA8DD0];
  values[62] = *(void **)MEMORY[0x1E0CA8DC8];
  values[63] = v2;
  values[64] = *(void **)MEMORY[0x1E0CA8DF0];
  values[65] = *(void **)MEMORY[0x1E0CA8DE8];
  values[66] = *(void **)MEMORY[0x1E0CA8DD8];
  values[67] = *(void **)MEMORY[0x1E0CA8DE0];
  values[68] = *(void **)MEMORY[0x1E0CA8E68];
  values[69] = *(void **)MEMORY[0x1E0CA8E60];
  values[70] = *(void **)MEMORY[0x1E0CA8E70];
  v12 = *MEMORY[0x1E0CA8D68];
  v13 = *MEMORY[0x1E0CA8D88];
  v14 = *MEMORY[0x1E0CA8D78];
  v15 = *MEMORY[0x1E0CA8DA0];
  v16 = *MEMORY[0x1E0CA8E98];
  v17 = *MEMORY[0x1E0CA8EB0];
  v18 = *MEMORY[0x1E0CA8EC0];
  v19 = *MEMORY[0x1E0CA8ED8];
  v20 = *MEMORY[0x1E0CA8DF8];
  v21 = *MEMORY[0x1E0CA8EE8];
  v22 = *MEMORY[0x1E0CA8F18];
  v23 = *MEMORY[0x1E0CA8F10];
  v24 = *MEMORY[0x1E0CA8F30];
  v25 = CFSTR("FullRangeVideo");
  v26 = CFSTR("CVImageBufferICCProfile");
  v27 = CFSTR("CVBytesPerRow");
  v28 = *MEMORY[0x1E0CA8CE8];
  v29 = *MEMORY[0x1E0CA8CE0];
  v30 = *MEMORY[0x1E0CA8D10];
  v31 = *MEMORY[0x1E0CA8D00];
  v32 = *MEMORY[0x1E0CA8D20];
  v33 = *MEMORY[0x1E0CA8D18];
  v34 = *MEMORY[0x1E0CA8CF8];
  v35 = *MEMORY[0x1E0CA8CF0];
  v36 = *MEMORY[0x1E0CA8D08];
  v37 = CFSTR("TemporalQuality");
  v38 = CFSTR("SpatialQuality");
  v39 = CFSTR("Version");
  v40 = CFSTR("RevisionLevel");
  v41 = CFSTR("Vendor");
  v42 = CFSTR("CommonEncryptionProtected");
  v43 = CFSTR("CommonEncryptionTrackEncryptionBox");
  v44 = CFSTR("CommonEncryptionOriginalFormat");
  v45 = CFSTR("FieldsPerSample");
  v46 = CFSTR("avcC");
  v47 = CFSTR("d263");
  v48 = CFSTR("uuid");
  v49 = CFSTR("UUID");
  v50 = CFSTR("sinf");
  v51 = CFSTR("pinf");
  v52 = CFSTR("CryptorSubsampleAuxiliaryData");
  v53 = CFSTR("hvcC");
  v54 = CFSTR("MetadataKeyTable");
  v55 = CFSTR("MetadataKeyNamespace");
  v56 = CFSTR("MetadataKeyValue");
  v57 = CFSTR("MetadataKeyLocalID");
  v58 = CFSTR("MetadataKeyDataTypeNameSpace");
  v59 = CFSTR("MetadataKeyDataType");
  v60 = CFSTR("MetadataKeyConformingDataTypes");
  v61 = CFSTR("MetadataPrimaryLocalIDs");
  v62 = CFSTR("MetadataLocalIDDependencyLists");
  v63 = CFSTR("BitsPerComponent");
  v64 = CFSTR("MetadataKeyStructuralDependency");
  v65 = CFSTR("StructuralDependencyIsInvalidFlag");
  v66 = CFSTR("MetadataKeySetupData");
  v67 = CFSTR("DisplayFlags");
  v68 = CFSTR("BackgroundColor");
  v69 = CFSTR("Red");
  v70 = CFSTR("Green");
  v71 = CFSTR("Blue");
  v72 = CFSTR("Alpha");
  v73 = CFSTR("DefaultTextBox");
  v74 = CFSTR("Top");
  v75 = CFSTR("Left");
  v76 = CFSTR("Bottom");
  v77 = CFSTR("Right");
  v78 = CFSTR("DefaultStyle");
  v79 = CFSTR("StartChar");
  v80 = CFSTR("Font");
  v81 = CFSTR("FontFace");
  v82 = CFSTR("ForegroundColor");
  v83 = CFSTR("FontSize");
  v84 = CFSTR("HorizontalJustification");
  v86 = CFSTR("EndChar");
  v87 = CFSTR("FontTable");
  v88 = CFSTR("TextJustification");
  v89 = CFSTR("Height");
  v85 = CFSTR("VerticalJustification");
  v90 = CFSTR("Ascent");
  v91 = CFSTR("DefaultFontName");
  v92 = CFSTR("HorizontalJustification");
  v93 = CFSTR("VerticalJustification");
  v94 = CFSTR("TimeCode_SourceReferenceName");
  v95 = CFSTR("TimeCode_SourceReferenceName_Value");
  v96 = CFSTR("TimeCode_SourceReferenceName_LangCode");
  v97 = CFSTR("Linear");
  v98 = CFSTR("SMPTE_ST_428_1");
  v99 = CFSTR("SMPTE_ST_2084_PQ");
  v100 = CFSTR("ITU_R_2100_HLG");
  v101 = CFSTR("IEC_sRGB");
  v102 = CFSTR("AlphaChannelIsOpaque");
  v103 = *MEMORY[0x1E0CA8CD8];
  v104 = *MEMORY[0x1E0CA8E40];
  v105 = v12;
  v106 = v16;
  v107 = v21;
  v108 = CFSTR("ColorInfoGuessedBy");
  v109 = *MEMORY[0x1E0CA8C58];
  v110 = *MEMORY[0x1E0CA8C78];
  v111 = *MEMORY[0x1E0CA8C70];
  v112 = CFSTR("SceneReferredExtendedLinear");
  v113 = CFSTR("SourceTrackID");
  v114 = CFSTR("CameraIntrinsicMatrix");
  v115 = CFSTR("DroppedFrameReason");
  v116 = CFSTR("DroppedFrameReasonInfo");
  v117 = CFSTR("StillImageLensStabilizationInfo");
  v118 = CFSTR("HEVCSyncSampleNALUnitType");
  v119 = CFSTR("AmbientViewingEnvironment");
  v120 = CFSTR("auxi");
  v121 = CFSTR("ccst");
  v122 = CFSTR("slmC");
  v123 = CFSTR("IsGradualDecoderRefreshAuthoritative");
  v124 = CFSTR("EndOfSiriTTSUtterance");
  v125 = CFSTR("FECGroupID");
  v126 = CFSTR("FECLastFrameInGroup");
  v127 = CFSTR("FECLevelOfProtection");
  v128 = CFSTR("QualityMetrics");
  v129 = CFSTR("EncodedFrameAvgQP");
  v130 = CFSTR("PadByteCount");
  v131 = CFSTR("VRAWidth");
  v132 = CFSTR("VRAHeight");
  v133 = *MEMORY[0x1E0CA8D28];
  v134 = CFSTR("dvvC");
  v135 = CFSTR("disc");
  v136 = CFSTR("TierFlag");
  v137 = CFSTR("ProfileCompatibilityFlags");
  v138 = CFSTR("ProfileSpace");
  v139 = CFSTR("TemporalLevel");
  v140 = CFSTR("ConstraintIndicatorFlags");
  v141 = CFSTR("LevelIndex");
  v142 = CFSTR("ProfileIndex");
  v143 = CFSTR("HEVCTemporalLevelInfo");
  v144 = CFSTR("HEVCTemporalSubLayerAccess");
  v145 = CFSTR("HEVCStepwiseTemporalSubLayerAccess");
  v146 = CFSTR("HEVCSyncSampleNALUnitType");
  v147 = CFSTR("AudioIndependentSampleDecoderRefreshCount");
  v148 = CFSTR("LayerSelector");
  v149 = CFSTR("OperatingPointSelector");
  v150 = CFSTR("IncompleteSample");
  v151 = CFSTR("av1C");
  v152 = *MEMORY[0x1E0CA8E58];
  v153 = *MEMORY[0x1E0CA8DA8];
  v154 = CFSTR("HDR10PlusPerFrameData");
  v155 = *MEMORY[0x1E0CA8E00];
  v156 = *MEMORY[0x1E0CA8DC0];
  v157 = CFSTR("RequestNonReferenceFrame");
  v158 = CFSTR("CryptKeyParsedIndex");
  v159 = CFSTR("MediaParsedIndex");
  v160 = CFSTR("PartMediaParsedIndex");
  v161 = CFSTR("FigAlternates");
  v162 = CFSTR("AudioGroups");
  v163 = CFSTR("VideoGroups");
  v164 = CFSTR("SubtitleGroups");
  v165 = CFSTR("ClosedCaptionGroups");
  v166 = CFSTR("PersistentID");
  v167 = CFSTR("GroupID");
  v168 = CFSTR("MultivariantPlaylistVariables");
  v169 = CFSTR("MediaSelectionArray");
  v170 = CFSTR("SteeringServerURI");
  v171 = CFSTR("InitPathwayID");
  v172 = CFSTR("DateEntryArray");
  v173 = CFSTR("PlaylistActiveDurationSecs");
  v174 = CFSTR("TargetDuration");
  v175 = CFSTR("PartTargetDuration");
  v176 = CFSTR("HoldBackDuration");
  v177 = CFSTR("PartHoldBackDuration");
  v178 = CFSTR("SkipDeltaBoundary");
  v179 = CFSTR("PlaylistType");
  v180 = CFSTR("HasEndTag");
  v181 = CFSTR("HasMediaSequence");
  v182 = CFSTR("HasOnlyIFrames");
  v183 = CFSTR("HasStartTime");
  v184 = CFSTR("StartTimeIsPrecise");
  v185 = CFSTR("SpecifiesIndependentSegments");
  v186 = CFSTR("HasIndependentParts");
  v187 = CFSTR("HasDiscontinuitySequence");
  v188 = CFSTR("HasPartTag");
  v189 = CFSTR("SupportsBlockingReload");
  v190 = CFSTR("CanSkipDATERANGES");
  v191 = CFSTR("VersionNum");
  v192 = CFSTR("StartTimeValue");
  v193 = CFSTR("DateStampCount");
  v194 = CFSTR("AvgSegmentDuration");
  v195 = CFSTR("MaxSegmentDuration");
  v196 = CFSTR("ParseDate");
  v197 = CFSTR("ParsedURL");
  v198 = CFSTR("MapEntryURL");
  v199 = CFSTR("PartialEntries");
  v200 = CFSTR("MediaSequence");
  v201 = CFSTR("DiscontinuityDomain");
  v202 = CFSTR("StartOffset");
  v203 = CFSTR("BytesToRead");
  v204 = CFSTR("TimeInSeconds");
  v205 = CFSTR("BitRate");
  v206 = CFSTR("IV");
  v207 = CFSTR("DateStamp");
  v208 = CFSTR("ImputedDate");
  v209 = CFSTR("Type");
  v210 = CFSTR("MarkedIndependent");
  v211 = CFSTR("IsDiscontinuity");
  v212 = CFSTR("MarkedAsGap");
  v213 = CFSTR("Fragment");
  v214 = CFSTR("FragmentsExpired");
  v215 = CFSTR("MediaParsedIndexForMap");
  v216 = CFSTR("KeySystem");
  v217 = CFSTR("EncryptionMethod");
  v218 = CFSTR("CryptKeyURL");
  v219 = CFSTR("SupportedProtocolVersions");
  v220 = CFSTR("PrefetchKey");
  v221 = CFSTR("CryptKeyParsed");
  v222 = CFSTR("SessionDataIdentifier");
  v223 = CFSTR("PlistURL");
  v224 = CFSTR("SessionDataValue");
  v225 = CFSTR("SessionDataLanguage");
  v226 = CFSTR("SessionDataFormat");
  v227 = CFSTR("RenditionURL");
  v228 = CFSTR("LastMediaSequenceNumber");
  v229 = CFSTR("LastIndependentMediaSequenceNumber");
  v230 = CFSTR("LastPart");
  v231 = CFSTR("LastIndependentPart");
  v232 = CFSTR("GapAtLive");
  v233 = CFSTR("ReadInCurrent");
  v234 = CFSTR("TaggedRangeMetadata");
  v235 = CFSTR("TaggedRangeID");
  v236 = CFSTR("TaggedRangeClass");
  v237 = CFSTR("TaggedRangeLine");
  v238 = CFSTR("TaggedRangeCue");
  v239 = CFSTR("StartDate");
  v240 = CFSTR("EndDate");
  v241 = CFSTR("EndOnNext");
  v242 = CFSTR("EndOnNextSet");
  v243 = CFSTR("scte35cmd");
  v244 = CFSTR("scte35in");
  v245 = CFSTR("scte35out");
  v246 = CFSTR("Duration");
  v247 = CFSTR("PlannedDuration");
  v248 = CFSTR("TagsFirstFoundDateDict");
  v249 = CFSTR("DiscoveryTimestamp");
  v250 = CFSTR("ModificationTimestamp");
  v251 = CFSTR("PreloadHint");
  v252 = CFSTR("PreloadMapHint");
  v253 = CFSTR("MediaFileEntries");
  v254 = CFSTR("MapFileEntries");
  v255 = CFSTR("CryptKeyEntries");
  v256 = CFSTR("SessionDataEntries");
  v257 = CFSTR("RenditionReportEntries");
  v258 = CFSTR("DateEntries");
  v259 = CFSTR("ReadInCurrentMediaEntriesArray");
  v260 = CFSTR("ReadInCurrentCryptKeyEntriesArray");
  v261 = CFSTR("TransportStreamEncryptionInitData");
  v262 = CFSTR("FrameChecksum");
  v263 = CFSTR("CalculateYUVChecksum");
  v264 = CFSTR("ExtraInLoopChromaFilter");
  v265 = CFSTR("ActiveVideoResolution");
  v266 = CFSTR("HasLeftStereoEyeView");
  v267 = CFSTR("HasRightStereoEyeView");
  v268 = CFSTR("ViewPackingKind");
  v269 = CFSTR("SCStreamUpdateFrameStatus");
  v270 = CFSTR("SCStreamUpdateFrameDisplayTime");
  v271 = CFSTR("SCStreamUpdateFrameDisplayResolution");
  v272 = CFSTR("SCStreamUpdateFrameContentRect");
  v273 = CFSTR("SCStreamUpdateFrameContentRectX");
  v274 = CFSTR("SCStreamUpdateFrameContentRectY");
  v275 = CFSTR("SCStreamUpdateFrameContentRectWidth");
  v276 = CFSTR("SCStreamUpdateFrameContentRectHeight");
  v277 = CFSTR("SCStreamUpdateFrameBoundingRect");
  v278 = CFSTR("SCStreamUpdateFrameContentScale");
  v279 = CFSTR("SCStreamUpdateFrameIOSurface");
  v280 = CFSTR("SCStreamUpdateStreamID");
  v281 = CFSTR("SCStreamUpdateCompositeMode");
  v282 = CFSTR("SCStreamUpdateFrameDirtyRect");
  v283 = CFSTR("SCStreamUpdateFrameDirtyRectY");
  v284 = CFSTR("SCStreamUpdateFrameDirtyRectX");
  v285 = CFSTR("SCStreamUpdateFrameDirtyRectHeight");
  v286 = CFSTR("SCStreamUpdateFrameDirtyRectWidth");
  v287 = CFSTR("SCStreamUpdateFrameScreenRect");
  v288 = CFSTR("SCStreamUpdateFrameNormalizedNewsroomFrameROI");
  v289 = CFSTR("SCStreamUpdateFramePresenterOverlayContentRect");
  v290 = CFSTR("SCStreamMetricCaptureLatencyTime");
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v291 = CFSTR("SCStreamMetricCaptureLatencyTimeAudio");
  v292 = CFSTR("SCStreamMetricCaptureTimeMicrophone");
  v4 = 0;
  sKnownSBufKeysDictionary = (uint64_t)CFDictionaryCreateMutable(v3, 352, MEMORY[0x1E0C9B390], 0);
  do
  {
    CFDictionaryAddValue((CFMutableDictionaryRef)sKnownSBufKeysDictionary, values[(_QWORD)v4], v4);
    v4 = (char *)v4 + 1;
  }
  while (v4 != (const void *)352);
  sKnownSBufKeysArray = (uint64_t)CFArrayCreate(v3, (const void **)values, 352, MEMORY[0x1E0C9B378]);
  if (MEMORY[0x1E0D054A0])
  {
    v5 = (const __CFArray *)FigCaptureCopySerializableKeys();
    sKnownCaptureKeysArray = (uint64_t)v5;
    if (v5)
    {
      Count = CFArrayGetCount(v5);
      if (Count)
      {
        v7 = Count;
        for (i = 0; i != v7; ++i)
        {
          v9 = (__CFDictionary *)sKnownSBufKeysDictionary;
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)sKnownCaptureKeysArray, i);
          CFDictionaryAddValue(v9, ValueAtIndex, (const void *)(i + 0x7FFF));
        }
      }
    }
  }
}

uint64_t fdescAtom_createSerializedDataForFormatDescriptionArray(const __CFArray *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  CFIndex Count;
  uint64_t result;
  CFIndex v10;
  const opaqueCMFormatDescription *ValueAtIndex;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  int v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  int v20;

  Count = CFArrayGetCount(a1);
  v18 = 0u;
  v19 = 0u;
  v20 = 0;
  *(_QWORD *)&v17 = a2;
  *((_QWORD *)&v17 + 1) = a3;
  result = FigNEAtomWriterBeginAtom((uint64_t)&v17, 1718776441);
  if (!(_DWORD)result)
  {
    if (Count < 1)
    {
LABEL_8:
      result = FigNEAtomWriterEndAtom((uint64_t)&v17);
      if (a4 && !(_DWORD)result)
      {
        v12 = *((_QWORD *)&v19 + 1);
        if (*((_QWORD *)&v19 + 1) == 8)
          v12 = 0;
        *a4 = v12;
      }
    }
    else
    {
      v10 = 0;
      while (1)
      {
        v16 = 0;
        v14 = 0u;
        v15 = 0u;
        v13 = 0u;
        ValueAtIndex = (const opaqueCMFormatDescription *)CFArrayGetValueAtIndex(a1, v10);
        v15 = 0uLL;
        v16 = 0;
        v13 = v17;
        *(_QWORD *)&v14 = &v17;
        *((_QWORD *)&v14 + 1) = *((_QWORD *)&v19 + 1) + *((_QWORD *)&v18 + 1);
        result = FigNEAtomWriterBeginAtom((uint64_t)&v13, 1717859171);
        if ((_DWORD)result)
          break;
        result = (uint64_t)sbufAtom_appendFormatDescriptionAtomGuts(ValueAtIndex, (uint64_t *)&v13);
        if ((_DWORD)result)
          break;
        result = FigNEAtomWriterEndAtom((uint64_t)&v13);
        if ((_DWORD)result)
          break;
        if (Count == ++v10)
          goto LABEL_8;
      }
    }
  }
  return result;
}

uint64_t FigRemote_CreateFormatDescriptionArrayFromSerializedAtomData(uint64_t a1, unint64_t a2, __CFArray **a3)
{
  __CFArray **v3;
  uint64_t v6;
  const __CFAllocator *v7;
  __CFArray *Mutable;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  __CFArray **v17;
  uint64_t v18;
  void *value;

  v3 = a3;
  v18 = 0;
  value = 0;
  if (!a3 || !a1 || !a2)
  {
    v14 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    Mutable = 0;
    goto LABEL_22;
  }
  v6 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if ((_DWORD)v6)
  {
    v14 = v6;
    Mutable = 0;
  }
  else
  {
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    if (!Mutable)
    {
      v16 = 4294954510;
LABEL_32:
      v14 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
LABEL_22:
      if (!(_DWORD)v14)
        goto LABEL_19;
      goto LABEL_23;
    }
    v9 = figReadNEAtomHeader(a1, 0, a2, (_DWORD *)&v18 + 1, &v18);
    if (!(_DWORD)v9)
    {
      if (HIDWORD(v18) == 1718776441)
      {
        v10 = v18;
        if (v18 <= a2)
        {
          if (v18 < 9)
          {
            v14 = 0;
            goto LABEL_19;
          }
          v17 = v3;
          v11 = 8;
          while (1)
          {
            v12 = figReadNEAtomHeader(a1, v11, v10, (_DWORD *)&v18 + 1, &v18);
            if ((_DWORD)v12)
            {
LABEL_20:
              v14 = v12;
              v3 = v17;
              goto LABEL_23;
            }
            if (HIDWORD(v18) != 1717859171)
              break;
            v13 = v18;
            v12 = sbufAtom_copyFormatDescriptionFromAtom(v7, a1 + 8 + v11, v18 - 8, (CFTypeRef *)&value);
            if ((_DWORD)v12)
              goto LABEL_20;
            CFArrayAppendValue(Mutable, value);
            if (value)
            {
              CFRelease(value);
              value = 0;
            }
            v11 += v13;
            if (v11 >= v10)
            {
              v14 = 0;
              v3 = v17;
              goto LABEL_19;
            }
          }
          v14 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
          v3 = v17;
          goto LABEL_22;
        }
      }
      v16 = 4294954516;
      goto LABEL_32;
    }
    v14 = v9;
  }
LABEL_23:
  if (value)
  {
    CFRelease(value);
    value = 0;
  }
  if (Mutable)
  {
    CFRelease(Mutable);
    Mutable = 0;
  }
LABEL_19:
  *v3 = Mutable;
  return v14;
}

uint64_t figReadNEAtomHeader(uint64_t a1, uint64_t a2, unint64_t a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t result;
  uint64_t v6;
  unint64_t v7;

  if (a2 + 8 > a3)
    return 4294954405;
  v6 = a1 + a2;
  v7 = *(unsigned int *)(a1 + a2);
  if (v7 <= 7 || a3 - a2 < v7)
    return FigSignalErrorAt(4294954402, 0, 0, 0, 0, 0, 0);
  result = 0;
  *a4 = *(_DWORD *)(v6 + 4);
  *a5 = v7;
  return result;
}

uint64_t sbufAtom_copyFormatDescriptionFromAtom(const __CFAllocator *a1, uint64_t a2, unint64_t a3, CFTypeRef *a4)
{
  CMFormatDescriptionRef *v4;
  unint64_t v7;
  uint64_t v8;
  uint64_t NEAtomHeader;
  uint64_t v10;
  __int128 v11;
  CMMediaType v12;
  FourCharCode v13;
  const __CFDictionary *v14;
  const __CFAllocator *v15;
  uint64_t v16;
  int v18;
  const AudioChannelLayout *v20;
  size_t v21;
  void *magicCookie;
  uint32_t frameQuanta;
  uint64_t magicCookieSize;
  int32_t height[2];
  uint64_t v26;
  FourCharCode mediaSubType[2];
  CMTime frameDuration;
  _QWORD v30[5];
  AudioStreamBasicDescription asbd;
  __CFDictionary *v32;

  v4 = (CMFormatDescriptionRef *)a4;
  v32 = 0;
  memset(&asbd, 0, sizeof(asbd));
  memset(v30, 0, 32);
  if (!a3)
  {
    v13 = 0;
    v12 = 0;
LABEL_62:
    v14 = v32;
    v15 = a1;
    goto LABEL_63;
  }
  v20 = 0;
  v7 = 0;
  frameQuanta = 0;
  magicCookieSize = 0;
  *(_QWORD *)height = 0;
  v26 = 0;
  *(_QWORD *)mediaSubType = 0;
  v21 = 0;
  magicCookie = 0;
  v8 = a2 + 8;
  do
  {
    NEAtomHeader = figReadNEAtomHeader(a2, v7, a3, (_DWORD *)v30 + 1, v30);
    if ((_DWORD)NEAtomHeader)
      goto LABEL_64;
    if (SHIDWORD(v30[0]) <= 1717859697)
    {
      if (SHIDWORD(v30[0]) <= 1668244578)
      {
        if (HIDWORD(v30[0]) == 1634951780)
        {
          if (LODWORD(v30[0]) != 48)
          {
LABEL_80:
            NEAtomHeader = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
            goto LABEL_64;
          }
          v11 = *(_OWORD *)(v8 + v7 + 16);
          *(_OWORD *)&asbd.mSampleRate = *(_OWORD *)(v8 + v7);
          *(_OWORD *)&asbd.mBytesPerPacket = v11;
          *(_QWORD *)&asbd.mBitsPerChannel = *(_QWORD *)(v8 + v7 + 32);
          v10 = 48;
        }
        else
        {
          if (HIDWORD(v30[0]) != 1667788396)
            goto LABEL_44;
          v10 = LODWORD(v30[0]);
          if (LODWORD(v30[0]) <= 8)
            goto LABEL_80;
          v20 = (const AudioChannelLayout *)(v8 + v7);
          v21 = LODWORD(v30[0]) - 8;
        }
      }
      else
      {
        switch(HIDWORD(v30[0]))
        {
          case 0x636F6463:
            if (LODWORD(v30[0]) != 12)
              goto LABEL_80;
            HIDWORD(v26) = *(_DWORD *)(v8 + v7);
            goto LABEL_39;
          case 0x63756B69:
            v10 = LODWORD(v30[0]);
            if (LODWORD(v30[0]) <= 8)
              goto LABEL_80;
            magicCookieSize = LODWORD(v30[0]) - 8;
            magicCookie = (void *)(v8 + v7);
            break;
          case 0x6578746E:
            v10 = LODWORD(v30[0]);
            if (LODWORD(v30[0]) <= 8)
              goto LABEL_80;
            NEAtomHeader = sbufAtom_copyDictionaryFromAtom(a1, v8 + v7, LODWORD(v30[0]) - 8, &v32);
            if ((_DWORD)NEAtomHeader)
              goto LABEL_64;
            break;
          default:
            goto LABEL_44;
        }
      }
    }
    else if (SHIDWORD(v30[0]) > 1903518061)
    {
      if (HIDWORD(v30[0]) == 1903518062)
      {
        if (LODWORD(v30[0]) != 12)
          goto LABEL_80;
        frameQuanta = *(_DWORD *)(v8 + v7);
        goto LABEL_39;
      }
      if (HIDWORD(v30[0]) == 1952671335)
      {
        if (LODWORD(v30[0]) != 12)
          goto LABEL_80;
        height[0] = *(_DWORD *)(v8 + v7);
        goto LABEL_39;
      }
      if (HIDWORD(v30[0]) != 1986292077)
        goto LABEL_44;
      if (LODWORD(v30[0]) != 16)
        goto LABEL_80;
      height[1] = *(_DWORD *)(a2 + v7 + 12);
      LODWORD(v26) = *(_DWORD *)(a2 + v7 + 8);
      v10 = 16;
    }
    else
    {
      if (HIDWORD(v30[0]) != 1717859698)
      {
        if (HIDWORD(v30[0]) == 1835297121)
        {
          if (LODWORD(v30[0]) != 12)
            goto LABEL_80;
          mediaSubType[1] = *(_DWORD *)(v8 + v7);
          goto LABEL_39;
        }
        if (HIDWORD(v30[0]) == 1836283234)
        {
          if (LODWORD(v30[0]) != 12)
            goto LABEL_80;
          mediaSubType[0] = *(_DWORD *)(v8 + v7);
LABEL_39:
          v10 = 12;
          goto LABEL_40;
        }
LABEL_44:
        v10 = LODWORD(v30[0]);
        goto LABEL_40;
      }
      if (LODWORD(v30[0]) != 32)
        goto LABEL_80;
      *(CMTime *)&v30[1] = *(CMTime *)(v8 + v7);
      v10 = 32;
    }
LABEL_40:
    v7 += v10;
  }
  while (v7 < a3);
  v12 = mediaSubType[1];
  if ((int)mediaSubType[1] > 1935832171)
  {
    if ((int)mediaSubType[1] > 1952606065)
    {
      v13 = mediaSubType[0];
      if ((int)mediaSubType[1] <= 1953325923)
      {
        v4 = (CMFormatDescriptionRef *)a4;
        if (mediaSubType[1] != 1952606066)
          goto LABEL_62;
        NEAtomHeader = FigTaggedBufferGroupFormatDescriptionCreate(a1, mediaSubType[0], a4);
        goto LABEL_64;
      }
      v4 = (CMFormatDescriptionRef *)a4;
      if (mediaSubType[1] == 1953325924)
      {
        frameDuration = *(CMTime *)&v30[1];
        NEAtomHeader = CMTimeCodeFormatDescriptionCreate(a1, mediaSubType[0], &frameDuration, frameQuanta, height[0], v32, (CMTimeCodeFormatDescriptionRef *)a4);
        goto LABEL_64;
      }
      v18 = 1986618469;
LABEL_73:
      if (mediaSubType[1] != v18)
        goto LABEL_62;
      goto LABEL_74;
    }
    v13 = mediaSubType[0];
    if ((int)mediaSubType[1] <= 1935962988)
    {
      v4 = (CMFormatDescriptionRef *)a4;
      goto LABEL_62;
    }
    v4 = (CMFormatDescriptionRef *)a4;
    if (mediaSubType[1] == 1936684398)
    {
      NEAtomHeader = CMAudioFormatDescriptionCreate(a1, &asbd, v21, v20, magicCookieSize, magicCookie, v32, (CMAudioFormatDescriptionRef *)a4);
      goto LABEL_64;
    }
    goto LABEL_62;
  }
  if ((int)mediaSubType[1] > 1835365472)
  {
    v13 = mediaSubType[0];
    if ((int)mediaSubType[1] <= 1885564003)
    {
      v4 = (CMFormatDescriptionRef *)a4;
      if (mediaSubType[1] != 1835365473)
        goto LABEL_62;
      NEAtomHeader = FigMetadataFormatDescriptionCreateWithExtensions(a1, mediaSubType[0], v32, (CMFormatDescriptionRef *)a4);
      goto LABEL_64;
    }
    v4 = (CMFormatDescriptionRef *)a4;
    if (mediaSubType[1] != 1885564004)
    {
      v18 = 1885954932;
      goto LABEL_73;
    }
    v14 = v32;
    v15 = a1;
    v12 = 1885564004;
LABEL_63:
    NEAtomHeader = CMFormatDescriptionCreate(v15, v12, v13, v14, v4);
    goto LABEL_64;
  }
  v13 = mediaSubType[0];
  if ((int)mediaSubType[1] <= 1668310897)
  {
    v4 = (CMFormatDescriptionRef *)a4;
    if (mediaSubType[1] != 1635088502)
    {
      if (mediaSubType[1] != 1668047728)
        goto LABEL_62;
      v14 = v32;
      v15 = a1;
      v12 = 1668047728;
      goto LABEL_63;
    }
LABEL_74:
    NEAtomHeader = CMVideoFormatDescriptionCreate(a1, HIDWORD(v26), v26, height[1], v32, v4);
    goto LABEL_64;
  }
  v4 = (CMFormatDescriptionRef *)a4;
  if (mediaSubType[1] != 1668310898)
    goto LABEL_62;
  NEAtomHeader = FigCaptionGroupFormatDescriptionCreate(a1, mediaSubType[0], a4);
LABEL_64:
  v16 = NEAtomHeader;
  if (v32)
    CFRelease(v32);
  return v16;
}

uint64_t FigRemote_CreateSerializedAtomDataBlockBufferForFormatDescription(const __CFAllocator *a1, uint64_t a2, CMBlockBufferRef *a3)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  size_t v9;
  const __CFAllocator *GlobalCFAllocatorFigMalloc;
  uint64_t v11;
  _QWORD v13[5];
  void *v14;
  size_t v15;
  size_t v16;

  v16 = 0;
  v14 = 0;
  if (!a2 || !a3)
  {
    v6 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  v6 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if ((_DWORD)v6)
  {
LABEL_9:
    v11 = v6;
    v8 = 0;
    goto LABEL_7;
  }
  v15 = 0;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 0x40000000;
  v13[2] = __FigRemote_CreateSerializedAtomDataBlockBufferForFormatDescription_block_invoke;
  v13[3] = &__block_descriptor_tmp_55;
  v13[4] = a2;
  v7 = sbufAtom_createSerializedDataUsingSerializer(0x400uLL, &v14, &v16, &v15, (uint64_t)v13);
  v8 = v14;
  if ((_DWORD)v7)
  {
    v11 = v7;
  }
  else
  {
    v9 = v16;
    GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    v11 = CMBlockBufferCreateWithMemoryBlock(a1, v8, v9, GlobalCFAllocatorFigMalloc, 0, 0, v15, 0, a3);
    if (!(_DWORD)v11)
      v8 = 0;
  }
LABEL_7:
  free(v8);
  return v11;
}

uint64_t sbufAtom_createSerializedDataUsingSerializer(size_t a1, _QWORD *a2, size_t *a3, _QWORD *a4, uint64_t a5)
{
  char v10;
  char v11;
  size_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  size_t v17;
  uint64_t v19;
  size_t size;

  v19 = 0;
  size = 0;
  v10 = 1;
  while (1)
  {
    v11 = v10;
    if (a1)
    {
      size = a1;
      v12 = a1;
    }
    else
    {
      v13 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, size_t *))(a5 + 16))(a5, 0, 0, &size);
      if ((_DWORD)v13)
        return v13;
      v12 = size;
      if (!size)
      {
        v16 = 0;
        goto LABEL_11;
      }
    }
    v14 = malloc_type_malloc(v12, 0xF2ACB13uLL);
    if (!v14)
      return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    v15 = v14;
    v16 = (*(uint64_t (**)(uint64_t, void *, size_t, uint64_t *))(a5 + 16))(a5, v14, size, &v19);
    if (!(_DWORD)v16)
    {
      v17 = size;
      goto LABEL_15;
    }
    free(v15);
    size = 0;
    if (!a1 || (_DWORD)v16 != -12572)
      return v16;
    v16 = 4294954724;
LABEL_11:
    v10 = 0;
    a1 = 0;
    if ((v11 & 1) == 0)
    {
      v17 = 0;
      v15 = 0;
LABEL_15:
      *a2 = v15;
      *a3 = v17;
      *a4 = v19;
      return v16;
    }
  }
}

uint64_t FigRemote_CreateFormatDescriptionFromSerializedAtomDataBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, size_t a3, _QWORD *a4)
{
  size_t DataLength;
  uint64_t v9;
  uint64_t v10;
  CFTypeRef v11;
  size_t v13;
  char *dataPointerOut;
  uint64_t v15;
  CFTypeRef cf;

  v15 = 0;
  cf = 0;
  if (!a4)
    goto LABEL_14;
  if (!theBuffer)
    goto LABEL_14;
  if (!CMBlockBufferGetDataLength(theBuffer))
    goto LABEL_14;
  DataLength = CMBlockBufferGetDataLength(theBuffer);
  if (!CMBlockBufferIsRangeContiguous(theBuffer, 0, DataLength))
    goto LABEL_14;
  v13 = 0;
  dataPointerOut = 0;
  CMBlockBufferGetDataPointer(theBuffer, a3, &v13, 0, &dataPointerOut);
  v9 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if ((_DWORD)v9)
    goto LABEL_15;
  v9 = figReadNEAtomHeader((uint64_t)dataPointerOut, 0, v13, (_DWORD *)&v15 + 1, &v15);
  if ((_DWORD)v9)
    goto LABEL_15;
  if (HIDWORD(v15) != 1717859171 || v13 < v15)
  {
LABEL_14:
    v9 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
LABEL_15:
    v10 = v9;
    goto LABEL_12;
  }
  v10 = sbufAtom_copyFormatDescriptionFromAtom(a1, (uint64_t)(dataPointerOut + 8), v15 - 8, &cf);
  v11 = cf;
  if ((_DWORD)v10 && cf)
  {
    CFRelease(cf);
LABEL_12:
    v11 = 0;
  }
  *a4 = v11;
  return v10;
}

uint64_t FigRemote_CopyReplacementAttachmentsForSampleBuffer(const void *a1, CFArrayRef theArray, __CFDictionary **a3, __CFDictionary **a4)
{
  __CFDictionary *v8;
  __CFDictionary *v9;
  CFIndex v10;
  const __CFString *ValueAtIndex;
  __CFDictionary *v12;
  uint64_t v13;
  CMAttachmentMode attachmentModeOut;

  attachmentModeOut = 1;
  if (theArray && CFArrayGetCount(theArray) >= 1)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v10);
      if (CMGetAttachment(a1, ValueAtIndex, &attachmentModeOut))
        break;
LABEL_15:
      if (CFArrayGetCount(theArray) <= ++v10)
        goto LABEL_18;
    }
    if (attachmentModeOut)
    {
      if (attachmentModeOut != 1)
        goto LABEL_20;
      if (v8)
      {
        v12 = v8;
LABEL_14:
        CFDictionaryRemoveValue(v12, ValueAtIndex);
        goto LABEL_15;
      }
      v12 = figRemote_copyMutableDictionaryOfAttachments(a1, 1u);
      v8 = v12;
    }
    else
    {
      if (v9)
      {
        v12 = v9;
        goto LABEL_14;
      }
      v12 = figRemote_copyMutableDictionaryOfAttachments(a1, 0);
      v9 = v12;
    }
    if (!v12)
    {
LABEL_20:
      v13 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      if (v8)
        CFRelease(v8);
      if (v9)
        CFRelease(v9);
      return v13;
    }
    goto LABEL_14;
  }
  v8 = 0;
  v9 = 0;
LABEL_18:
  v13 = 0;
  *a3 = v8;
  *a4 = v9;
  return v13;
}

CFMutableDictionaryRef figRemote_copyMutableDictionaryOfAttachments(CMAttachmentBearerRef target, CMAttachmentMode attachmentMode)
{
  const __CFAllocator *v2;
  const __CFDictionary *v3;
  CFMutableDictionaryRef MutableCopy;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v3 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], target, attachmentMode);
  MutableCopy = FigCFDictionaryCreateMutableCopy(v2, v3);
  if (v3)
    CFRelease(v3);
  return MutableCopy;
}

uint64_t FigRemote_CreateSerializedAtomDataForSampleBufferWithOptions(opaqueCMSampleBuffer *a1, char a2, const __CFDictionary *a3, const __CFDictionary *a4, mach_port_t *a5, vm_address_t *a6, uint64_t a7, _QWORD *a8, const opaqueCMFormatDescription **a9, uint64_t *a10)
{
  IOSurfaceRef *p_buffer;
  uint64_t result;
  mach_port_t MachPort;
  IOSurfaceRef buffer;

  buffer = 0;
  if (a5)
    p_buffer = &buffer;
  else
    p_buffer = 0;
  result = FigRemote_CreateSerializedAtomDataAndSurfaceForSampleBufferWithOptions(0, a1, a2, a3, a4, p_buffer, a6, a7, a8, a9, a10);
  if (a5 && !(_DWORD)result)
  {
    result = (uint64_t)buffer;
    if (buffer)
    {
      MachPort = IOSurfaceCreateMachPort(buffer);
      *a5 = MachPort;
      if (MachPort)
        return 0;
      else
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      *a5 = 0;
    }
  }
  return result;
}

uint64_t FigRemote_CreateSerializedAtomDataAndSurfaceForSampleBufferWithOptions(const __CFAllocator *a1, opaqueCMSampleBuffer *a2, char a3, const __CFDictionary *a4, const __CFDictionary *a5, _QWORD *a6, vm_address_t *a7, uint64_t a8, _QWORD *a9, const opaqueCMFormatDescription **a10, uint64_t *a11)
{
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t *v19;
  CFTypeRef *v20;
  CFTypeRef *p_cf;
  char v22;
  char v23;
  uint64_t v24;
  vm_address_t v25;
  uint64_t SerializedDataAndSurfaceForSampleBuffer;
  uint64_t v27;
  const opaqueCMFormatDescription *v28;
  CFTypeRef v29;
  const void *v30;
  CFTypeRef v31;
  uint64_t v32;
  _QWORD *v34;
  CFTypeRef *v36;
  CFTypeRef *v37;
  uint64_t *v38;
  const opaqueCMFormatDescription *otherFormatDescription;
  CFTypeRef cf;
  CFTypeRef v43;
  uint64_t v44;
  vm_address_t address;
  uint64_t v46;

  address = 0;
  v46 = 0;
  v44 = 0;
  if (!a2 || !a7 || !a9)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (a10)
    otherFormatDescription = *a10;
  else
    otherFormatDescription = 0;
  if (a11)
    v16 = *a11;
  else
    v16 = 0;
  v17 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if ((_DWORD)v17)
    return v17;
  v18 = 4 * (a3 & 3);
  v34 = a6;
  if (a6)
    v19 = &v44;
  else
    v19 = 0;
  v20 = &v43;
  if (!a10)
    v20 = 0;
  v37 = v20;
  v38 = v19;
  p_cf = &cf;
  if (!a11)
    p_cf = 0;
  v36 = p_cf;
  v22 = 1;
  while (1)
  {
    v23 = v22;
    if (a8)
    {
      v46 = a8;
      v24 = a8;
    }
    else
    {
      v17 = sbufAtom_createSerializedDataAndSurfaceForSampleBuffer(a2, v18, a4, 0, a5, 0, 0, 0, &v46, otherFormatDescription, v16, 0, 0, 0);
      if ((_DWORD)v17)
        return v17;
      v24 = v46;
      if (!v46)
      {
        v27 = 0;
        goto LABEL_56;
      }
    }
    if (a1)
      break;
    v32 = vm_allocate(*MEMORY[0x1E0C83DA0], &address, v24, 1543503873);
    v25 = address;
    if ((_DWORD)v32)
    {
      v27 = v32;
      if (!address || !v46)
        goto LABEL_53;
LABEL_51:
      MEMORY[0x193FFCA84](*MEMORY[0x1E0C83DA0], v25);
      goto LABEL_52;
    }
LABEL_25:
    v43 = 0;
    cf = 0;
    SerializedDataAndSurfaceForSampleBuffer = sbufAtom_createSerializedDataAndSurfaceForSampleBuffer(a2, v18, a4, 0, a5, v38, v25, v46, 0, otherFormatDescription, v16, 0, v37, v36);
    v27 = SerializedDataAndSurfaceForSampleBuffer;
    if (a10 && !(_DWORD)SerializedDataAndSurfaceForSampleBuffer)
    {
      v28 = *a10;
      v29 = v43;
      *a10 = (const opaqueCMFormatDescription *)v43;
      if (v29)
        CFRetain(v29);
      if (v28)
        CFRelease(v28);
    }
    if (a11 && !(_DWORD)v27)
    {
      v30 = (const void *)*a11;
      v31 = cf;
      *a11 = (uint64_t)cf;
      if (v31)
        CFRetain(v31);
      if (v30)
        CFRelease(v30);
    }
    if (v43)
      CFRelease(v43);
    if (cf)
      CFRelease(cf);
    if (!(_DWORD)v27 && gGMFigKTraceEnabled == 1)
    {
      kdebug_trace();
      v27 = 0;
      goto LABEL_61;
    }
    if (!(_DWORD)v27)
      goto LABEL_61;
    v25 = address;
    if (!address || !v46)
      goto LABEL_53;
    if (!a1)
      goto LABEL_51;
    CFAllocatorDeallocate(a1, (void *)address);
LABEL_52:
    address = 0;
    v46 = 0;
LABEL_53:
    if (!a8 || (_DWORD)v27 != -12572)
      goto LABEL_61;
    v27 = 4294954724;
LABEL_56:
    v22 = 0;
    a8 = 0;
    if ((v23 & 1) == 0)
      goto LABEL_61;
  }
  v25 = (vm_address_t)CFAllocatorAllocate(a1, v24, 0);
  address = v25;
  if (v25)
    goto LABEL_25;
  v27 = 4294954510;
LABEL_61:
  *a9 = v46;
  *a7 = address;
  if (v34)
    *v34 = v44;
  return v27;
}

uint64_t FigRemote_CreateSerializedAtomDataForSampleBuffer(opaqueCMSampleBuffer *a1, const __CFDictionary *a2, const __CFDictionary *a3, mach_port_t *a4, vm_address_t *a5, uint64_t a6, _QWORD *a7, const opaqueCMFormatDescription **a8, uint64_t *a9)
{
  return FigRemote_CreateSerializedAtomDataForSampleBufferWithOptions(a1, 0, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t sbufAtom_createSerializedDataAndSurfaceForSampleBuffer(opaqueCMSampleBuffer *a1, unsigned int a2, const __CFDictionary *a3, const __CFDictionary *a4, const __CFDictionary *a5, _QWORD *a6, uint64_t a7, uint64_t a8, _QWORD *a9, CMFormatDescriptionRef otherFormatDescription, uint64_t a11, int a12, _QWORD *a13, _QWORD *a14)
{
  CVImageBufferRef ImageBuffer;
  uint64_t TaggedBufferGroup;
  OpaqueCMBlockBuffer *v21;
  CFTypeRef v22;
  CMBlockBufferRef DataBuffer;
  OpaqueCMBlockBuffer *v24;
  uint64_t CFDataFromCaptionGroup;
  uint64_t CaptionGroup;
  uint64_t SampleTimingInfoArray;
  uint64_t appended;
  CMSampleTimingInfo *v29;
  CMSampleTimingInfo *v30;
  CMSampleTimingInfo *v31;
  uint64_t v32;
  IOSurfaceRef IOSurface;
  const opaqueCMFormatDescription *v34;
  const __CFDictionary *v35;
  uint64_t v36;
  uint64_t v37;
  const __CFDictionary *v38;
  const __CFDictionary *v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  _BOOL4 v43;
  uint64_t Decryptor;
  const void *v45;
  _QWORD *v46;
  uint64_t (*v47)(const void *, CMSampleTimingInfo *);
  _QWORD *v48;
  uint64_t (*v49)(const void *, CMSampleTimingInfo *);
  const void *value;
  const UInt8 *BytePtr;
  size_t Length;
  size_t v53;
  const __CFDictionary *v54;
  const __CFDictionary *v55;
  const opaqueCMFormatDescription *v56;
  const __CFDictionary *v57;
  const __CFDictionary *v58;
  CFArrayRef SampleAttachmentsArray;
  const __CFArray *v60;
  CFIndex Count;
  CFIndex v62;
  CFIndex v63;
  const __CFDictionary *ValueAtIndex;
  uint64_t v65;
  CFTypeRef v66;
  CFTypeRef v67;
  size_t v68;
  size_t DataLength;
  OpaqueCMBlockBuffer *v71;
  uint64_t Contiguous;
  const opaqueCMFormatDescription *desc;
  CMItemCount v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  int v81;
  CFTypeRef v82;
  CFTypeRef cf;
  CMSampleTimingInfo v84;
  CMItemCount timingArrayEntriesNeededOut[2];

  v82 = 0;
  cf = 0;
  desc = CMSampleBufferGetFormatDescription(a1);
  ImageBuffer = CMSampleBufferGetImageBuffer(a1);
  TaggedBufferGroup = FigSampleBufferGetTaggedBufferGroup((uint64_t)a1);
  v21 = 0;
  v22 = 0;
  if (!((unint64_t)ImageBuffer | TaggedBufferGroup))
  {
    DataBuffer = CMSampleBufferGetDataBuffer(a1);
    if (DataBuffer)
    {
      v24 = DataBuffer;
      v22 = CMGetAttachment(DataBuffer, CFSTR("CVDataBuffer"), 0);
      if (v22)
        v21 = 0;
      else
        v21 = v24;
    }
    else
    {
      v21 = 0;
      v22 = 0;
    }
  }
  v81 = 0;
  v79 = 0u;
  v80 = 0u;
  v78 = 0u;
  if (CMFormatDescriptionGetMediaType(desc) == 1668310898)
  {
    CFDataFromCaptionGroup = FigCaptionSerializerCreate(*MEMORY[0x1E0C9AE00], (void ***)&cf);
    if ((_DWORD)CFDataFromCaptionGroup)
      goto LABEL_126;
    CaptionGroup = FigSampleBufferGetCaptionGroup((uint64_t)a1);
    CFDataFromCaptionGroup = FigCaptionSerializerCreateCFDataFromCaptionGroup((uint64_t)cf, CaptionGroup, (CFMutableDataRef *)&v82);
    if ((_DWORD)CFDataFromCaptionGroup)
      goto LABEL_126;
  }
  v81 = 0;
  v79 = 0u;
  v80 = 0u;
  *(_QWORD *)&v78 = a7;
  *((_QWORD *)&v78 + 1) = a8;
  CFDataFromCaptionGroup = FigNEAtomWriterBeginAtom((uint64_t)&v78, 1935832422);
  if ((_DWORD)CFDataFromCaptionGroup)
    goto LABEL_126;
  memset(&v84, 0, 24);
  CMSampleBufferGetOutputPresentationTimeStamp(&v84.duration, a1);
  if ((v84.duration.flags & 1) != 0)
  {
    CFDataFromCaptionGroup = sbufAtom_appendAtomWithMemoryBlock(&v84, 0x18uLL, 1869640819, (uint64_t *)&v78);
    if ((_DWORD)CFDataFromCaptionGroup)
      goto LABEL_126;
  }
  memset(&v84, 0, sizeof(v84));
  timingArrayEntriesNeededOut[0] = 0;
  SampleTimingInfoArray = CMSampleBufferGetSampleTimingInfoArray(a1, 0, 0, timingArrayEntriesNeededOut);
  if ((_DWORD)SampleTimingInfoArray == -12736)
    goto LABEL_27;
  appended = SampleTimingInfoArray;
  v29 = 0;
  if (!timingArrayEntriesNeededOut[0] || !(_QWORD)v78)
    goto LABEL_18;
  if (timingArrayEntriesNeededOut[0] == 1)
  {
    v29 = &v84;
    appended = CMSampleBufferGetSampleTimingInfoArray(a1, 1, &v84, timingArrayEntriesNeededOut);
LABEL_18:
    v30 = 0;
    if ((_DWORD)appended)
    {
LABEL_19:
      free(v30);
      goto LABEL_127;
    }
    goto LABEL_25;
  }
  if (timingArrayEntriesNeededOut[0] > 0x38E38E38E38E38EuLL
    || (v31 = (CMSampleTimingInfo *)malloc_type_malloc(72 * timingArrayEntriesNeededOut[0], 0xD1AAB5CuLL)) == 0)
  {
    appended = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    v30 = 0;
    goto LABEL_26;
  }
  v30 = v31;
  v32 = CMSampleBufferGetSampleTimingInfoArray(a1, timingArrayEntriesNeededOut[0], v31, timingArrayEntriesNeededOut);
  if ((_DWORD)v32)
  {
    appended = v32;
    goto LABEL_19;
  }
  v29 = v30;
LABEL_25:
  appended = sbufAtom_appendAtomWithMemoryBlock(v29, 72 * timingArrayEntriesNeededOut[0], 1937008993, (uint64_t *)&v78);
LABEL_26:
  free(v30);
  if ((_DWORD)appended)
    goto LABEL_127;
LABEL_27:
  if (ImageBuffer)
  {
    if (!a6 || (IOSurface = CVPixelBufferGetIOSurface(ImageBuffer), (*a6 = IOSurface) != 0))
    {
      v34 = desc;
      if (a5)
      {
        v35 = a5;
        v36 = 1767994484;
        goto LABEL_37;
      }
      v38 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], ImageBuffer, 1u);
      if (!v38)
        goto LABEL_52;
      v39 = v38;
      v40 = 1767994484;
      goto LABEL_51;
    }
    goto LABEL_154;
  }
  if (v22)
  {
    v34 = desc;
    if (!a6 || (v37 = CVDataBufferGetIOSurface(), (*a6 = v37) != 0))
    {
      LOBYTE(v84.duration.value) = CFBooleanGetValue((CFBooleanRef)*MEMORY[0x1E0C9AE50]);
      sbufAtom_appendAtomWithMemoryBlock(&v84, 1uLL, 1768911716, (uint64_t *)&v78);
      if (a5)
      {
        v35 = a5;
        v36 = 1684108404;
LABEL_37:
        CFDataFromCaptionGroup = sbufAtom_appendDictionaryAtom(v35, 1, v36, &v78);
        if ((_DWORD)CFDataFromCaptionGroup)
          goto LABEL_126;
LABEL_52:
        v43 = ((unint64_t)ImageBuffer | TaggedBufferGroup) == 0;
        if (!v34)
          v43 = 0;
        if (v43 && (!otherFormatDescription || !CMFormatDescriptionEqual(v34, otherFormatDescription)))
        {
          memset(&v84.presentationTimeStamp.timescale, 0, 20);
          *(_OWORD *)&v84.duration.value = v78;
          v84.duration.epoch = (CMTimeEpoch)&v78;
          v84.presentationTimeStamp.value = *((_QWORD *)&v80 + 1) + *((_QWORD *)&v79 + 1);
          CFDataFromCaptionGroup = FigNEAtomWriterBeginAtom((uint64_t)&v84, 1717859171);
          if ((_DWORD)CFDataFromCaptionGroup)
            goto LABEL_126;
          CFDataFromCaptionGroup = (uint64_t)sbufAtom_appendFormatDescriptionAtomGuts(v34, &v84.duration.value);
          if ((_DWORD)CFDataFromCaptionGroup)
            goto LABEL_126;
          CFDataFromCaptionGroup = FigNEAtomWriterEndAtom((uint64_t)&v84);
          if ((_DWORD)CFDataFromCaptionGroup)
            goto LABEL_126;
        }
        Decryptor = FigSampleBufferGetDecryptor((uint64_t)a1);
        v45 = (const void *)Decryptor;
        if (!(a11 | Decryptor) || FigCFEqual((CFTypeRef)Decryptor, (CFTypeRef)a11))
        {
LABEL_92:
          if (a3)
          {
            CFDataFromCaptionGroup = sbufAtom_appendDictionaryAtom(a3, 1, 1935766644, &v78);
            if ((_DWORD)CFDataFromCaptionGroup)
              goto LABEL_126;
          }
          else
          {
            v54 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 1u);
            if (v54)
            {
              v55 = v54;
              appended = sbufAtom_appendDictionaryAtom(v54, 1, 1935766644, &v78);
              CFRelease(v55);
              if ((_DWORD)appended)
                goto LABEL_127;
            }
          }
          if (a4)
          {
            CFDataFromCaptionGroup = sbufAtom_appendDictionaryAtom(a4, 1, 1935766578, &v78);
            v56 = desc;
            if ((_DWORD)CFDataFromCaptionGroup)
              goto LABEL_126;
          }
          else
          {
            v57 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0);
            v56 = desc;
            if (v57)
            {
              v58 = v57;
              appended = sbufAtom_appendDictionaryAtom(v57, 1, 1935766578, &v78);
              CFRelease(v58);
              if ((_DWORD)appended)
                goto LABEL_127;
            }
          }
          SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(a1, 0);
          if (!SampleAttachmentsArray)
            goto LABEL_158;
          v60 = SampleAttachmentsArray;
          memset(&v84.presentationTimeStamp.timescale, 0, 20);
          *(_OWORD *)&v84.duration.value = v78;
          v84.duration.epoch = (CMTimeEpoch)&v78;
          v84.presentationTimeStamp.value = *((_QWORD *)&v80 + 1) + *((_QWORD *)&v79 + 1);
          CFDataFromCaptionGroup = FigNEAtomWriterBeginAtom((uint64_t)&v84, 1935766137);
          if (!(_DWORD)CFDataFromCaptionGroup)
          {
            Count = CFArrayGetCount(v60);
            if (Count >= 1)
            {
              v62 = Count;
              v63 = 0;
              do
              {
                ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v60, v63);
                CFDataFromCaptionGroup = sbufAtom_appendDictionaryAtom(ValueAtIndex, a2 & 2 ^ 3, 1684628340, &v84);
                if ((_DWORD)CFDataFromCaptionGroup)
                  goto LABEL_126;
              }
              while (v62 != ++v63);
            }
            CFDataFromCaptionGroup = FigNEAtomWriterEndAtom((uint64_t)&v84);
            if (!(_DWORD)CFDataFromCaptionGroup)
            {
LABEL_158:
              CFDataFromCaptionGroup = FigNEAtomWriterEndAtom((uint64_t)&v78);
              if (!(_DWORD)CFDataFromCaptionGroup)
              {
                if (a9)
                {
                  v65 = *((_QWORD *)&v80 + 1);
                  if (*((_QWORD *)&v80 + 1) == 8)
                    v65 = 0;
                  *a9 = v65;
                }
                if (a13)
                {
                  if (v56)
                    v66 = CFRetain(v56);
                  else
                    v66 = 0;
                  *a13 = v66;
                }
                if (a14)
                {
                  if (v45)
                    v67 = CFRetain(v45);
                  else
                    v67 = 0;
                  appended = 0;
                  *a14 = v67;
                }
                else
                {
                  appended = 0;
                }
                goto LABEL_127;
              }
            }
          }
LABEL_126:
          appended = CFDataFromCaptionGroup;
          goto LABEL_127;
        }
        if ((a2 & 4) == 0)
        {
          v84.duration.value = 0;
          if (!v45)
          {
            v53 = 0;
LABEL_90:
            appended = sbufAtom_appendAtomWithMemoryBlock(&v84, v53, 1668310371, (uint64_t *)&v78);
            goto LABEL_91;
          }
          v46 = *(_QWORD **)(CMBaseObjectGetVTable((uint64_t)v45) + 16);
          if (*v46 < 4uLL
            || (v47 = (uint64_t (*)(const void *, CMSampleTimingInfo *))v46[13]) == 0
            || (appended = v47(v45, &v84), (_DWORD)appended == -12782))
          {
            if (!a12)
            {
LABEL_70:
              appended = 0;
              goto LABEL_91;
            }
            if (!(_QWORD)v78)
            {
LABEL_89:
              v53 = 8;
              goto LABEL_90;
            }
            appended = FigCPECryptorServerGetIDForCryptorByAssociatingWithClientPID(v45, a12, &v84);
            if ((_DWORD)appended == -17575)
              goto LABEL_70;
          }
          if ((_DWORD)appended)
            goto LABEL_91;
          goto LABEL_89;
        }
        v84.duration.value = 0;
        if (v45)
        {
          v48 = *(_QWORD **)(CMBaseObjectGetVTable((uint64_t)v45) + 16);
          if (*v48 < 8uLL || (v49 = (uint64_t (*)(const void *, CMSampleTimingInfo *))v48[33]) == 0)
          {
            appended = 4294954514;
            goto LABEL_91;
          }
          appended = v49(v45, &v84);
          value = (const void *)v84.duration.value;
          if ((_DWORD)appended)
            goto LABEL_83;
          BytePtr = CFDataGetBytePtr((CFDataRef)v84.duration.value);
          Length = CFDataGetLength((CFDataRef)v84.duration.value);
        }
        else
        {
          Length = 0;
          BytePtr = 0;
        }
        appended = sbufAtom_appendAtomWithMemoryBlock(BytePtr, Length, 1935897200, (uint64_t *)&v78);
        value = (const void *)v84.duration.value;
LABEL_83:
        if (value)
          CFRelease(value);
LABEL_91:
        if ((_DWORD)appended)
          goto LABEL_127;
        goto LABEL_92;
      }
      v38 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v22, 1u);
      if (!v38)
        goto LABEL_52;
      v39 = v38;
      v40 = 1684108404;
LABEL_51:
      appended = sbufAtom_appendDictionaryAtom(v38, 1, v40, &v78);
      CFRelease(v39);
      if ((_DWORD)appended)
        goto LABEL_127;
      goto LABEL_52;
    }
LABEL_154:
    CFDataFromCaptionGroup = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_126;
  }
  if ((a2 & 1) != 0 || !v21)
  {
    if (v82)
    {
      CFDataFromCaptionGroup = sbufAtom_appendDataAtom((const __CFData *)v82, 1667330151, (uint64_t *)&v78);
      v34 = desc;
      if ((_DWORD)CFDataFromCaptionGroup)
        goto LABEL_126;
      goto LABEL_52;
    }
    v34 = desc;
    if (TaggedBufferGroup)
    {
      CFDataFromCaptionGroup = sbufAtom_appendTagCollection(TaggedBufferGroup, a2, &v78);
      if ((_DWORD)CFDataFromCaptionGroup)
        goto LABEL_126;
      goto LABEL_52;
    }
    v84.duration.value = 0;
    CFDataFromCaptionGroup = sbufAtom_appendNumSamples(a1, (uint64_t *)&v78);
    if ((_DWORD)CFDataFromCaptionGroup)
      goto LABEL_126;
    CFDataFromCaptionGroup = sbufAtom_appendSampleSizes(a1, 0, (uint64_t *)&v78, &v84.duration.value);
    if ((_DWORD)CFDataFromCaptionGroup)
      goto LABEL_126;
    if (CMSampleBufferGetNumSamples(a1) < 1
      || CMFormatDescriptionGetMediaType(desc) != 1936684398
      || v84.duration.value)
    {
      goto LABEL_52;
    }
LABEL_146:
    CFDataFromCaptionGroup = sbufAtom_appendPacketDescriptions(a1, (uint64_t *)&v78);
    if ((_DWORD)CFDataFromCaptionGroup)
      goto LABEL_126;
    goto LABEL_52;
  }
  v77 = 0;
  v41 = (*((_QWORD *)&v80 + 1) + 127) & 0xFFFFFFFFFFFFFF80;
  v42 = v41 - 8 - *((_QWORD *)&v80 + 1);
  if (v41 - 8 != *((_QWORD *)&v80 + 1))
  {
    if (v41 - 8 > *((_QWORD *)&v80 + 1))
      v68 = v42 >= 8 ? v41 - 8 - *((_QWORD *)&v80 + 1) : v42 + 128;
    else
      v68 = *((_QWORD *)&v80 + 1) - v41 + 136;
    CFDataFromCaptionGroup = sbufAtom_appendAtomWithMemoryBlock(0, v68, 1718773093, (uint64_t *)&v78);
    if ((_DWORD)CFDataFromCaptionGroup)
      goto LABEL_126;
  }
  v84.duration.value = 0;
  timingArrayEntriesNeededOut[0] = 0;
  DataLength = CMBlockBufferGetDataLength(v21);
  if (!(_QWORD)v78)
    goto LABEL_138;
  if (CMBlockBufferIsRangeContiguous(v21, 0, DataLength))
  {
    v71 = v21;
  }
  else
  {
    Contiguous = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v21, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, DataLength, 1u, (CMBlockBufferRef *)&v84);
    if ((_DWORD)Contiguous)
      goto LABEL_139;
    v71 = (OpaqueCMBlockBuffer *)v84.duration.value;
  }
  Contiguous = CMBlockBufferGetDataPointer(v71, 0, 0, 0, (char **)timingArrayEntriesNeededOut);
  if (!(_DWORD)Contiguous)
LABEL_138:
    Contiguous = sbufAtom_appendAtomWithMemoryBlock((const void *)timingArrayEntriesNeededOut[0], DataLength, 1935958388, (uint64_t *)&v78);
LABEL_139:
  appended = Contiguous;
  v34 = desc;
  if (v84.duration.value)
    CFRelease((CFTypeRef)v84.duration.value);
  if (!(_DWORD)appended)
  {
    CFDataFromCaptionGroup = sbufAtom_appendNumSamples(a1, (uint64_t *)&v78);
    if ((_DWORD)CFDataFromCaptionGroup)
      goto LABEL_126;
    CFDataFromCaptionGroup = sbufAtom_appendSampleSizes(a1, (a2 >> 3) & 1, (uint64_t *)&v78, &v77);
    if ((_DWORD)CFDataFromCaptionGroup)
      goto LABEL_126;
    if (CMFormatDescriptionGetMediaType(desc) != 1936684398 || v77)
      goto LABEL_52;
    goto LABEL_146;
  }
LABEL_127:
  if (cf)
    CFRelease(cf);
  if (v82)
    CFRelease(v82);
  return appended;
}

uint64_t FigRemote_CreateSerializedAtomDataAndSurfaceForSampleBuffer(const __CFAllocator *a1, opaqueCMSampleBuffer *a2, const __CFDictionary *a3, const __CFDictionary *a4, _QWORD *a5, vm_address_t *a6, uint64_t a7, _QWORD *a8, const opaqueCMFormatDescription **a9, uint64_t *a10)
{
  return FigRemote_CreateSerializedAtomDataAndSurfaceForSampleBufferWithOptions(a1, a2, 0, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t FigRemote_CreateSerializedAtomDataBlockBufferForSampleBuffer(const __CFAllocator *a1, const __CFAllocator *a2, opaqueCMSampleBuffer *a3, uint64_t a4, CMBlockBufferRef *a5, const opaqueCMFormatDescription **a6, uint64_t *a7)
{
  return FigRemote_CreateSerializedAtomDataBlockBufferWithFlagsForSampleBuffer(a1, a2, a3, a4, 0, a5, a6, a7);
}

uint64_t FigRemote_CreateSerializedAtomDataBlockBufferWithFlagsForSampleBuffer(const __CFAllocator *a1, const __CFAllocator *a2, opaqueCMSampleBuffer *a3, uint64_t a4, char a5, CMBlockBufferRef *a6, const opaqueCMFormatDescription **a7, uint64_t *a8)
{
  uint64_t v15;
  uint64_t v16;
  void *v17;
  unsigned int v18;
  CFTypeRef *p_cf;
  CFTypeRef *v20;
  char v21;
  char v22;
  CFIndex v23;
  uint64_t v24;
  size_t v25;
  const __CFAllocator *v26;
  uint64_t v27;
  uint64_t v28;
  const opaqueCMFormatDescription *v29;
  CFTypeRef v30;
  const void *v31;
  CFTypeRef v32;
  const __CFAllocator *v34;
  CMBlockBufferRef *blockBufferOut;
  CFTypeRef *v36;
  CFTypeRef *v37;
  const opaqueCMFormatDescription *otherFormatDescription;
  CFTypeRef v40;
  CFTypeRef cf;
  size_t v42;
  uint64_t v43;

  v42 = 0;
  v43 = 0;
  if (!a3)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (!a7)
  {
    otherFormatDescription = 0;
    if (a8)
      goto LABEL_4;
LABEL_6:
    v15 = 0;
    goto LABEL_7;
  }
  otherFormatDescription = *a7;
  if (!a8)
    goto LABEL_6;
LABEL_4:
  v15 = *a8;
LABEL_7:
  v16 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if ((_DWORD)v16)
    return v16;
  v34 = a1;
  blockBufferOut = a6;
  v17 = 0;
  v18 = 2 * (a5 & 1);
  if (a7)
    p_cf = &cf;
  else
    p_cf = 0;
  v20 = &v40;
  if (!a8)
    v20 = 0;
  v36 = v20;
  v37 = p_cf;
  v21 = 1;
  do
  {
    v22 = v21;
    if (a4)
    {
      v43 = a4;
      v23 = a4;
    }
    else
    {
      v24 = sbufAtom_createSerializedDataAndSurfaceForSampleBuffer(a3, v18, 0, 0, 0, 0, 0, 0, &v43, otherFormatDescription, v15, 0, 0, 0);
      if ((_DWORD)v24)
        goto LABEL_43;
      v23 = v43;
      if (!v43)
        goto LABEL_40;
    }
    v17 = CFAllocatorAllocate(a2, v23, 0);
    v25 = v43;
    if (!v17)
      break;
    v26 = a2;
    v40 = 0;
    cf = 0;
    v27 = sbufAtom_createSerializedDataAndSurfaceForSampleBuffer(a3, v18, 0, 0, 0, 0, (uint64_t)v17, v43, &v42, otherFormatDescription, v15, 0, v37, v36);
    v28 = v27;
    if (a7 && !(_DWORD)v27)
    {
      v29 = *a7;
      v30 = cf;
      *a7 = (const opaqueCMFormatDescription *)cf;
      if (v30)
        CFRetain(v30);
      if (v29)
        CFRelease(v29);
    }
    if (a8 && !(_DWORD)v28)
    {
      v31 = (const void *)*a8;
      v32 = v40;
      *a8 = (uint64_t)v40;
      if (v32)
        CFRetain(v32);
      if (v31)
        CFRelease(v31);
    }
    if (cf)
      CFRelease(cf);
    a2 = v26;
    if (v40)
      CFRelease(v40);
    v25 = v43;
    if (!(_DWORD)v28)
      break;
    if (v43)
    {
      CFAllocatorDeallocate(v26, v17);
      v17 = 0;
      v43 = 0;
    }
    if (!a4 || (_DWORD)v28 != -12572)
      goto LABEL_44;
LABEL_40:
    v21 = 0;
    a4 = 0;
    v25 = 0;
  }
  while ((v22 & 1) != 0);
  v24 = CMBlockBufferCreateWithMemoryBlock(v34, v17, v25, a2, 0, 0, v42, 0, blockBufferOut);
  v28 = 0;
  if (!(_DWORD)v24)
    return v28;
LABEL_43:
  v28 = v24;
LABEL_44:
  if (v17)
    CFAllocatorDeallocate(a2, v17);
  return v28;
}

uint64_t FigRemote_CreateSampleBufferFromSerializedAtomData(mach_port_t a1, void *a2, size_t dataLength, const opaqueCMFormatDescription **a4, CFTypeRef *a5, __CFArray *a6)
{
  uint64_t v12;
  __IOSurface *v13;
  __IOSurface *v14;
  uint64_t SampleBufferFromSerializedAtomBlockBufferAndSurface;
  CMBlockBufferRef theBuffer;
  CMBlockBufferCustomBlockSource customBlockSource;

  HIDWORD(customBlockSource.AllocateBlock) = 0;
  customBlockSource.refCon = 0;
  theBuffer = 0;
  *(_QWORD *)&customBlockSource.version = 0;
  customBlockSource.FreeBlock = (void (__cdecl *)(void *, void *, size_t))_bbufBlockSourceFree;
  v12 = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, dataLength, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], &customBlockSource, 0, dataLength, 0, &theBuffer);
  if (!(_DWORD)v12)
  {
    if (a1)
    {
      v13 = IOSurfaceLookupFromMachPort(a1);
      if (v13)
      {
        v14 = v13;
        SampleBufferFromSerializedAtomBlockBufferAndSurface = FigRemote_CreateSampleBufferFromSerializedAtomBlockBufferAndSurface(v13, theBuffer, a4, a5, a6);
        CFRelease(v14);
        goto LABEL_7;
      }
      v12 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      v12 = FigRemote_CreateSampleBufferFromSerializedAtomBlockBufferAndSurface(0, theBuffer, a4, a5, a6);
    }
  }
  SampleBufferFromSerializedAtomBlockBufferAndSurface = v12;
LABEL_7:
  if (theBuffer)
    CFRelease(theBuffer);
  else
    MEMORY[0x193FFCA84](*MEMORY[0x1E0C83DA0], a2, dataLength);
  return SampleBufferFromSerializedAtomBlockBufferAndSurface;
}

void _bbufBlockSourceFree(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x193FFCA84);
}

uint64_t FigRemote_CreateSampleBufferFromSerializedAtomBlockBufferAndSurface(__IOSurface *a1, CMBlockBufferRef theBuffer, const opaqueCMFormatDescription **a3, CFTypeRef *a4, __CFArray *a5)
{
  uint64_t result;
  const __CFAllocator *v11;
  CMBlockBufferRef blockBufferOut;
  size_t totalLengthOut;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  size_t v17;
  size_t v18;
  char v19;

  v19 = 0;
  v17 = 0;
  v18 = 0;
  lengthAtOffsetOut = 0;
  dataPointerOut = 0;
  totalLengthOut = 0;
  result = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut);
  if (!(_DWORD)result)
  {
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    result = sbufAtom_createSampleBufferFromSerializedAtomDataAndSurface((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a1, (uint64_t)dataPointerOut, lengthAtOffsetOut, 0, a3, a4, &v19, &v18, (uint64_t *)&v17, a5);
    if (!(_DWORD)result && v19 != 0)
    {
      blockBufferOut = 0;
      result = CMBlockBufferCreateWithBufferReference(v11, theBuffer, v18, v17, 0, &blockBufferOut);
      if (!(_DWORD)result)
      {
        CMSampleBufferSetDataBuffer(*(CMSampleBufferRef *)a5, blockBufferOut);
        if (blockBufferOut)
          CFRelease(blockBufferOut);
        return CMSampleBufferSetDataReady(*(CMSampleBufferRef *)a5);
      }
    }
  }
  return result;
}

uint64_t sbufAtom_createSampleBufferFromSerializedAtomDataAndSurface(const __CFAllocator *a1, __IOSurface *a2, uint64_t a3, unint64_t a4, char a5, const opaqueCMFormatDescription **a6, CFTypeRef *a7, _BYTE *a8, _QWORD *a9, uint64_t *a10, __CFArray *a11)
{
  __CFArray *v11;
  uint64_t v12;
  uint64_t NEAtomHeader;
  unint64_t v19;
  const __CFArray *v20;
  CFTypeRef v21;
  const __CFAllocator *v22;
  unint64_t v23;
  uint64_t v24;
  void **v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t Count;
  uint64_t v29;
  __CFArray *Mutable;
  CFIndex v31;
  const void *ValueAtIndex;
  uint64_t v33;
  uint64_t CaptionGroupFromCFData;
  CMTimeValue value;
  uint64_t v36;
  __CFDictionary **p_theAttachments;
  CFDataRef v38;
  _QWORD *v39;
  uint64_t (*v40)(CFTypeRef, CFDataRef, char *);
  uint64_t v41;
  uint64_t v42;
  CFDataRef v43;
  const void *v44;
  const size_t *v45;
  uint64_t (*v46)(const __CFAllocator *, CFDataRef, CFTypeRef *);
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  const opaqueCMFormatDescription *FormatDescription;
  const __CFAllocator *v51;
  __CFDictionary *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  Boolean v56;
  uint64_t v57;
  __int128 v58;
  CMSampleBufferRef v59;
  const __CFDictionary *v60;
  const __CFDictionary *v61;
  const __CFArray *v62;
  const __CFArray *SampleAttachmentsArray;
  CFIndex v64;
  CFIndex v65;
  CFIndex v66;
  const __CFDictionary *v67;
  const __CFDictionary *v68;
  CFTypeID v69;
  void *v70;
  const void **v71;
  const void **v72;
  CFAllocatorRef v73;
  char v74;
  const void *v75;
  const void *v76;
  __int128 v78;
  uint64_t v79;
  CMItemCount v80;
  const size_t *sampleSizeArray;
  uint64_t v82;
  const size_t *v83;
  CMItemCount v84;
  AudioStreamPacketDescription *packetDescriptions;
  const void **v86;
  const void **v87;
  _BYTE *v88;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  CMSampleTimingInfo *sampleTiming;
  CMSampleTimingInfo *sampleTiminga;
  int v95;
  CFTypeRef v96;
  CFTypeRef v97;
  CFTypeRef v98;
  size_t *v99;
  const opaqueCMFormatDescription *v100;
  const opaqueCMFormatDescription *v101;
  CFTypeRef cf;
  CFAllocatorRef allocatora;
  uint64_t v105;
  const __CFArray *v106;
  CFTypeRef v107[4];
  CFTypeRef v108;
  CFDictionaryRef theAttachments;
  CFDictionaryRef v110;
  CFTypeRef v111;
  CFTypeRef v112[3];
  CVPixelBufferRef v113;
  char v114;
  __CVBuffer *v115;
  CVPixelBufferRef pixelBufferOut;
  CMVideoFormatDescriptionRef formatDescriptionOut;
  CMSampleBufferRef sampleBufferOut;
  char v119;
  CFTypeRef v120;
  CMTime outputPresentationTimeStamp;
  void *v122;
  __int128 *v123;
  __int128 v124;
  uint64_t epoch;
  void *v126;

  v11 = a11;
  formatDescriptionOut = 0;
  sampleBufferOut = 0;
  v115 = 0;
  pixelBufferOut = 0;
  v114 = 0;
  v113 = 0;
  memset((char *)&v112[1] + 4, 0, 12);
  v111 = 0;
  v112[0] = 0;
  theAttachments = 0;
  v110 = 0;
  v108 = 0;
  memset(v107, 0, sizeof(v107));
  if (!a11)
  {
    CaptionGroupFromCFData = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v21 = 0;
    v96 = 0;
    v20 = 0;
LABEL_275:
    v99 = 0;
    goto LABEL_219;
  }
  v12 = a3;
  if (!a3 || !a4)
    goto LABEL_272;
  if (!a6)
  {
    v100 = 0;
    if (a7)
      goto LABEL_6;
LABEL_8:
    cf = 0;
    goto LABEL_9;
  }
  v100 = *a6;
  if (!a7)
    goto LABEL_8;
LABEL_6:
  cf = *a7;
LABEL_9:
  NEAtomHeader = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if ((_DWORD)NEAtomHeader
    || (NEAtomHeader = figReadNEAtomHeader(v12, 0, a4, (_DWORD *)v107 + 1, v107), (_DWORD)NEAtomHeader))
  {
LABEL_273:
    CaptionGroupFromCFData = NEAtomHeader;
    v21 = 0;
    v96 = 0;
    v20 = 0;
LABEL_274:
    v11 = 0;
    goto LABEL_275;
  }
  if (HIDWORD(v107[0]) != 1935832422 || (v88 = a8, v19 = LODWORD(v107[0]), LODWORD(v107[0]) > a4))
  {
LABEL_272:
    NEAtomHeader = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_273;
  }
  v86 = (const void **)a6;
  v87 = a7;
  if (LODWORD(v107[0]) >= 9)
  {
    v91 = 0;
    v92 = 0;
    v84 = 0;
    packetDescriptions = 0;
    v99 = 0;
    v83 = 0;
    v90 = 0;
    sampleTiming = 0;
    v95 = 0;
    v20 = 0;
    v96 = 0;
    v21 = 0;
    v105 = v12 + 8;
    v22 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v23 = 8;
    while (1)
    {
      v24 = figReadNEAtomHeader(v12, v23, v19, (_DWORD *)v107 + 1, v107);
      if ((_DWORD)v24)
        goto LABEL_270;
      v11 = (__CFArray *)v12;
      v25 = (void **)(v105 + v23);
      v26 = LODWORD(v107[0]) - 8;
      if (SHIDWORD(v107[0]) > 1885631330)
      {
        if (SHIDWORD(v107[0]) <= 1935897199)
        {
          if (SHIDWORD(v107[0]) <= 1935766577)
          {
            if (HIDWORD(v107[0]) == 1885631331)
            {
              if (!HIDWORD(v112[1]) || ((16 * HIDWORD(v112[1])) | 8uLL) > LODWORD(v107[0]))
              {
LABEL_269:
                v24 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
                goto LABEL_270;
              }
              packetDescriptions = (AudioStreamPacketDescription *)(v105 + v23);
            }
            else if (HIDWORD(v107[0]) == 1935766137)
            {
              v24 = sbufAtom_copyArrayFromAtom(a1, v105 + v23, LODWORD(v107[0]) - 8, (CFMutableArrayRef *)&v108);
              if ((_DWORD)v24)
                goto LABEL_270;
            }
            goto LABEL_104;
          }
          if (HIDWORD(v107[0]) == 1935766578)
          {
            p_theAttachments = (__CFDictionary **)&v111;
          }
          else
          {
            if (HIDWORD(v107[0]) != 1935766644)
              goto LABEL_104;
            p_theAttachments = (__CFDictionary **)v112;
          }
LABEL_103:
          v24 = sbufAtom_copyDictionaryFromAtom(a1, v105 + v23, LODWORD(v107[0]) - 8, p_theAttachments);
          if ((_DWORD)v24)
            goto LABEL_270;
          goto LABEL_104;
        }
        if (SHIDWORD(v107[0]) > 1936943481)
        {
          switch(HIDWORD(v107[0]))
          {
            case 0x7373697A:
              if (LODWORD(v107[0]) <= 0xB)
                goto LABEL_269;
              if (v99)
                free(v99);
              v90 = v26 >> 2;
              if (v26 > 3)
              {
                v45 = (const size_t *)malloc_type_malloc(8 * (v26 >> 2), 0xD1AAB5CuLL);
                if (!v45)
                {
LABEL_282:
                  CaptionGroupFromCFData = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
                  goto LABEL_274;
                }
                v47 = 0;
                v48 = v26 >> 2;
                if (v90 <= 1)
                  v48 = 1;
                do
                {
                  v45[v47] = *((unsigned int *)v25 + v47);
                  ++v47;
                }
                while (v48 != v47);
              }
              else
              {
                v45 = (const size_t *)malloc_type_malloc(0, 0x2CFEBD2BuLL);
                if (!v45)
                  goto LABEL_282;
              }
              v83 = v45;
              v99 = (size_t *)v45;
              break;
            case 0x73746961:
              if (LODWORD(v107[0]) <= 0x4F)
                goto LABEL_269;
              v84 = v26 / 0x48;
              sampleTiming = (CMSampleTimingInfo *)(v105 + v23);
              break;
            case 0x74636F6C:
              outputPresentationTimeStamp.value = 0;
              *(_QWORD *)&v124 = 0;
              v27 = sbufAtom_copyArrayFromAtom(a1, v105 + v23, LODWORD(v107[0]) - 8, (CFMutableArrayRef *)&v124);
              if ((_DWORD)v27)
              {
                CaptionGroupFromCFData = v27;
                Mutable = 0;
              }
              else
              {
                if ((_QWORD)v124 && (Count = CFArrayGetCount((CFArrayRef)v124), Count >= 1))
                {
                  v29 = Count;
                  Mutable = CFArrayCreateMutable(v22, Count, MEMORY[0x1E0C9B378]);
                  if (Mutable)
                  {
                    v97 = v21;
                    v31 = 0;
                    while (1)
                    {
                      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v124, v31);
                      if (!ValueAtIndex)
                        break;
                      v33 = FigTagCollectionCreateFromData(ValueAtIndex, v22, &outputPresentationTimeStamp);
                      if ((_DWORD)v33)
                      {
                        CaptionGroupFromCFData = v33;
                        goto LABEL_40;
                      }
                      CFArrayAppendValue(Mutable, (const void *)outputPresentationTimeStamp.value);
                      if (outputPresentationTimeStamp.value)
                      {
                        CFRelease((CFTypeRef)outputPresentationTimeStamp.value);
                        outputPresentationTimeStamp.value = 0;
                      }
                      if (v29 == ++v31)
                      {
                        CaptionGroupFromCFData = 0;
                        v20 = Mutable;
                        Mutable = 0;
LABEL_40:
                        v21 = v97;
                        goto LABEL_128;
                      }
                    }
                    v49 = 4294954516;
                    v21 = v97;
                  }
                  else
                  {
                    v49 = 4294954510;
                  }
                }
                else
                {
                  Mutable = 0;
                  v49 = 4294954516;
                }
                CaptionGroupFromCFData = FigSignalErrorAt(v49, 0, 0, 0, 0, 0, 0);
              }
LABEL_128:
              if (outputPresentationTimeStamp.value)
                CFRelease((CFTypeRef)outputPresentationTimeStamp.value);
              if (Mutable)
                CFRelease(Mutable);
              v44 = (const void *)v124;
              if (!(_QWORD)v124)
              {
LABEL_85:
                if ((_DWORD)CaptionGroupFromCFData)
                  goto LABEL_271;
                break;
              }
LABEL_84:
              CFRelease(v44);
              goto LABEL_85;
          }
LABEL_104:
          v12 = (uint64_t)v11;
          goto LABEL_105;
        }
        if (HIDWORD(v107[0]) != 1935897200)
        {
          if (HIDWORD(v107[0]) == 1935958388)
          {
            v95 = 1;
            if (!HIDWORD(v112[1]))
              HIDWORD(v112[1]) = 1;
            v91 = v105 + v23;
            v92 = LODWORD(v107[0]) - 8;
          }
          goto LABEL_104;
        }
      }
      else
      {
        if (SHIDWORD(v107[0]) <= 1767994483)
        {
          if (SHIDWORD(v107[0]) <= 1684108403)
          {
            if (HIDWORD(v107[0]) != 1667330151)
            {
              if (HIDWORD(v107[0]) == 1668310371)
              {
                value = 0;
                outputPresentationTimeStamp.value = 0;
                if (LODWORD(v107[0]) != 8)
                {
                  if (LODWORD(v107[0]) != 16)
                  {
                    CaptionGroupFromCFData = 4294966630;
                    goto LABEL_271;
                  }
                  v36 = FigCPECopyCryptorForSerializationToken(*v25, &outputPresentationTimeStamp);
                  value = outputPresentationTimeStamp.value;
                  if ((_DWORD)v36)
                  {
                    CaptionGroupFromCFData = v36;
                    if (outputPresentationTimeStamp.value)
                      CFRelease((CFTypeRef)outputPresentationTimeStamp.value);
                    goto LABEL_271;
                  }
                }
                cf = (CFTypeRef)value;
                v21 = (CFTypeRef)value;
              }
              goto LABEL_104;
            }
            outputPresentationTimeStamp.value = 0;
            *(_QWORD *)&v124 = 0;
            v42 = FigCaptionSerializerCreate((uint64_t)v22, (void ***)&v124);
            if ((_DWORD)v42)
            {
              CaptionGroupFromCFData = v42;
              v43 = 0;
            }
            else
            {
              v43 = CFDataCreate(a1, (const UInt8 *)v25, v26);
              CaptionGroupFromCFData = FigCaptionSerializerCreateCaptionGroupFromCFData((void **)v124, v43, (CFTypeRef *)&outputPresentationTimeStamp);
              if (!(_DWORD)CaptionGroupFromCFData)
              {
                v96 = (CFTypeRef)outputPresentationTimeStamp.value;
                outputPresentationTimeStamp.value = 0;
              }
            }
            if ((_QWORD)v124)
              CFRelease((CFTypeRef)v124);
            if (v43)
              CFRelease(v43);
            v44 = (const void *)outputPresentationTimeStamp.value;
            if (!outputPresentationTimeStamp.value)
              goto LABEL_85;
            goto LABEL_84;
          }
          if (HIDWORD(v107[0]) != 1684108404)
          {
            if (HIDWORD(v107[0]) == 1717859171)
            {
              v24 = sbufAtom_copyFormatDescriptionFromAtom(a1, v105 + v23, LODWORD(v107[0]) - 8, (CFTypeRef *)&formatDescriptionOut);
              if ((_DWORD)v24)
                goto LABEL_270;
              v100 = formatDescriptionOut;
            }
            goto LABEL_104;
          }
          p_theAttachments = &theAttachments;
          goto LABEL_103;
        }
        if (SHIDWORD(v107[0]) <= 1818456687)
        {
          if (HIDWORD(v107[0]) == 1767994484)
          {
            p_theAttachments = &v110;
            goto LABEL_103;
          }
          if (HIDWORD(v107[0]) != 1768911716)
            goto LABEL_104;
          if (LODWORD(v107[0]) != 9)
            goto LABEL_269;
LABEL_93:
          __memcpy_chk();
          goto LABEL_104;
        }
        if (HIDWORD(v107[0]) != 1818456688)
        {
          if (HIDWORD(v107[0]) == 1853058416)
          {
            if (LODWORD(v107[0]) != 12)
              goto LABEL_269;
          }
          else
          {
            if (HIDWORD(v107[0]) != 1869640819)
              goto LABEL_104;
            if (LODWORD(v107[0]) != 32)
              goto LABEL_269;
          }
          goto LABEL_93;
        }
      }
      v120 = 0;
      v119 = 0;
      if (LODWORD(v107[0]) == 8)
      {
        v21 = 0;
        v38 = 0;
      }
      else
      {
        v38 = CFDataCreate(v22, (const UInt8 *)v25, v26);
        if (!cf)
          goto LABEL_108;
        v39 = *(_QWORD **)(CMBaseObjectGetVTable((uint64_t)cf) + 16);
        if (*v39 < 8uLL || (v40 = (uint64_t (*)(CFTypeRef, CFDataRef, char *))v39[34]) == 0)
        {
          CaptionGroupFromCFData = 4294954514;
          if (!v38)
            goto LABEL_115;
          goto LABEL_114;
        }
        v41 = v40(cf, v38, &v119);
        if ((_DWORD)v41)
          goto LABEL_139;
        if (v119 == 1)
        {
          v21 = CFRetain(cf);
        }
        else
        {
LABEL_108:
          *(_QWORD *)&v124 = 0;
          *((_QWORD *)&v124 + 1) = &v124;
          epoch = 0x2000000000;
          v46 = (uint64_t (*)(const __CFAllocator *, CFDataRef, CFTypeRef *))getFigCPECryptorCreateCryptorFromSerializedRecipeSymbolLoc_ptr;
          v126 = getFigCPECryptorCreateCryptorFromSerializedRecipeSymbolLoc_ptr;
          if (!getFigCPECryptorCreateCryptorFromSerializedRecipeSymbolLoc_ptr)
          {
            outputPresentationTimeStamp.value = MEMORY[0x1E0C809B0];
            *(_QWORD *)&outputPresentationTimeStamp.timescale = 0x40000000;
            outputPresentationTimeStamp.epoch = (CMTimeEpoch)__getFigCPECryptorCreateCryptorFromSerializedRecipeSymbolLoc_block_invoke;
            v122 = &unk_1E28E3B00;
            v123 = &v124;
            __getFigCPECryptorCreateCryptorFromSerializedRecipeSymbolLoc_block_invoke((uint64_t)&outputPresentationTimeStamp);
            v46 = *(uint64_t (**)(const __CFAllocator *, CFDataRef, CFTypeRef *))(*((_QWORD *)&v124 + 1) + 24);
          }
          _Block_object_dispose(&v124, 8);
          if (!v46)
          {
            sbufAtom_createSampleBufferFromSerializedAtomDataAndSurface_cold_1();
            goto LABEL_281;
          }
          v41 = v46(a1, v38, &v120);
          if ((_DWORD)v41)
          {
LABEL_139:
            CaptionGroupFromCFData = v41;
            if (!v38)
              goto LABEL_115;
LABEL_114:
            CFRelease(v38);
            goto LABEL_115;
          }
          v21 = v120;
        }
      }
      CaptionGroupFromCFData = 0;
      v120 = 0;
      if (v38)
        goto LABEL_114;
LABEL_115:
      if (v120)
        CFRelease(v120);
      if ((_DWORD)CaptionGroupFromCFData)
        goto LABEL_271;
      v12 = (uint64_t)v11;
      cf = v21;
LABEL_105:
      v23 += LODWORD(v107[0]);
      if (v23 >= v19)
        goto LABEL_142;
    }
  }
  v21 = 0;
  v96 = 0;
  v20 = 0;
  v95 = 0;
  v83 = 0;
  v84 = 0;
  v92 = 0;
  sampleTiming = 0;
  v90 = 0;
  v91 = 0;
  v99 = 0;
  packetDescriptions = 0;
LABEL_142:
  if (!a2)
  {
    FormatDescription = v100;
    v51 = a1;
    goto LABEL_163;
  }
  FormatDescription = v100;
  v51 = a1;
  if (!v114)
  {
    if (IOSurfaceGetProhibitUseCount())
    {
      v52 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionarySetValue(v52, (const void *)*MEMORY[0x1E0CA8F90], (const void *)*MEMORY[0x1E0C9AE50]);
      CaptionGroupFromCFData = CVPixelBufferCreateWithIOSurface(a1, a2, v52, &pixelBufferOut);
      if (v52)
        CFRelease(v52);
    }
    else
    {
      CaptionGroupFromCFData = CVPixelBufferCreateWithIOSurface(a1, a2, 0, &pixelBufferOut);
    }
    if ((_DWORD)CaptionGroupFromCFData)
      goto LABEL_271;
    if (v110)
      CVBufferSetAttachments(pixelBufferOut, v110, kCVAttachmentMode_ShouldPropagate);
    if (v100 && CMVideoFormatDescriptionMatchesImageBuffer(v100, pixelBufferOut))
      goto LABEL_163;
    if (formatDescriptionOut)
    {
      CFRelease(formatDescriptionOut);
      formatDescriptionOut = 0;
    }
    v24 = CMVideoFormatDescriptionCreateForImageBuffer(a1, pixelBufferOut, &formatDescriptionOut);
    if (!(_DWORD)v24)
    {
      FormatDescription = formatDescriptionOut;
      goto LABEL_163;
    }
LABEL_270:
    CaptionGroupFromCFData = v24;
    goto LABEL_271;
  }
  v24 = CVDataBufferCreateWithIOSurface();
  if ((_DWORD)v24)
    goto LABEL_270;
  if (theAttachments)
    CVBufferSetAttachments(v115, theAttachments, kCVAttachmentMode_ShouldPropagate);
  if (!v100)
  {
    CaptionGroupFromCFData = 0;
LABEL_271:
    v11 = 0;
    goto LABEL_219;
  }
LABEL_163:
  if (v20 && (v53 = CFArrayGetCount(v20), v53 >= 1))
  {
    v54 = v53;
    v11 = CFArrayCreateMutable(v51, v53, MEMORY[0x1E0C9B378]);
    if (!v11 || (CVPixelBufferCreate(v51, 0x10uLL, 0x10uLL, 0x20u, 0, &v113), !v113))
    {
      v79 = 4294954510;
      goto LABEL_278;
    }
    do
    {
      CFArrayAppendValue(v11, v113);
      --v54;
    }
    while (v54);
    if (v113)
    {
      CFRelease(v113);
      v113 = 0;
    }
    v55 = FigTaggedBufferGroupCreate(v51, v20, v11, &v112[2]);
    if ((_DWORD)v55)
      goto LABEL_279;
    if (!FormatDescription)
    {
      if (formatDescriptionOut)
      {
        CFRelease(formatDescriptionOut);
        formatDescriptionOut = 0;
      }
      v55 = FigTaggedBufferGroupFormatDescriptionCreate(v51, 1952606066, (CFTypeRef *)&formatDescriptionOut);
      if ((_DWORD)v55)
        goto LABEL_279;
      FormatDescription = formatDescriptionOut;
    }
  }
  else
  {
    v11 = 0;
  }
  if (pixelBufferOut && v112[2])
  {
LABEL_254:
    v79 = 4294954516;
LABEL_278:
    v55 = FigSignalErrorAt(v79, 0, 0, 0, 0, 0, 0);
    goto LABEL_279;
  }
  v56 = (a5 & 1) == 0;
  if (pixelBufferOut)
  {
    v57 = CMSampleBufferCreateForImageBuffer(v51, pixelBufferOut, v56, 0, 0, FormatDescription, sampleTiming, &sampleBufferOut);
    goto LABEL_185;
  }
  if (v112[2])
  {
    outputPresentationTimeStamp = sampleTiming->presentationTimeStamp;
    v58 = *(_OWORD *)&sampleTiming->duration.value;
    epoch = sampleTiming->duration.epoch;
    v124 = v58;
    v57 = FigSampleBufferCreateForTaggedBufferGroup(v51, v112[2], (__int128 *)&outputPresentationTimeStamp.value, (uint64_t)&v124, &sampleBufferOut);
    goto LABEL_185;
  }
  if (v115)
  {
    v57 = CMSampleBufferCreateReadyForCVDataBuffer(v51, v115, FormatDescription, (uint64_t)sampleTiming, &sampleBufferOut);
    goto LABEL_185;
  }
  if (v96)
  {
    if (!sampleTiming)
    {
LABEL_281:
      v79 = 4294954565;
      goto LABEL_278;
    }
    outputPresentationTimeStamp = sampleTiming->presentationTimeStamp;
    v78 = *(_OWORD *)&sampleTiming->duration.value;
    epoch = sampleTiming->duration.epoch;
    v124 = v78;
    v55 = FigSampleBufferCreateForCaptionGroup(v51, v96, (__int128 *)&outputPresentationTimeStamp.value, (uint64_t)&v124, &sampleBufferOut);
    if ((_DWORD)v55)
    {
LABEL_279:
      CaptionGroupFromCFData = v55;
      goto LABEL_219;
    }
    FormatDescription = CMSampleBufferGetFormatDescription(sampleBufferOut);
    if (FormatDescription)
      goto LABEL_186;
    goto LABEL_254;
  }
  if (packetDescriptions && v84 >= 1)
  {
    outputPresentationTimeStamp = sampleTiming->presentationTimeStamp;
    v57 = CMAudioSampleBufferCreateWithPacketDescriptions(v51, 0, (a5 & 1 | v95) == 0, 0, 0, FormatDescription, HIDWORD(v112[1]), &outputPresentationTimeStamp, packetDescriptions, &sampleBufferOut);
  }
  else
  {
    if (HIDWORD(v112[1]))
      v80 = v90;
    else
      v80 = 0;
    sampleSizeArray = v83;
    if (!HIDWORD(v112[1]))
      sampleSizeArray = 0;
    v57 = CMSampleBufferCreate(v51, 0, v56, 0, 0, FormatDescription, HIDWORD(v112[1]), v84, sampleTiming, v80, sampleSizeArray, &sampleBufferOut);
  }
LABEL_185:
  CaptionGroupFromCFData = v57;
  if ((_DWORD)v57)
    goto LABEL_219;
LABEL_186:
  sampleTiminga = (CMSampleTimingInfo *)v11;
  v101 = FormatDescription;
  allocatora = (CFAllocatorRef)v12;
  v106 = v20;
  v98 = v21;
  FigSampleBufferSetDecryptor((uint64_t)sampleBufferOut, cf);
  if ((BYTE4(v107[2]) & 1) != 0)
  {
    outputPresentationTimeStamp = *(CMTime *)&v107[1];
    CMSampleBufferSetOutputPresentationTimeStamp(sampleBufferOut, &outputPresentationTimeStamp);
  }
  v59 = sampleBufferOut;
  v60 = (const __CFDictionary *)v111;
  v61 = (const __CFDictionary *)v112[0];
  v62 = (const __CFArray *)v108;
  if (v108)
  {
    SampleAttachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sampleBufferOut, 1u);
    v64 = CFArrayGetCount(v62);
    if (SampleAttachmentsArray)
      v65 = CFArrayGetCount(SampleAttachmentsArray);
    else
      v65 = 0;
    if (v64 != v65)
      goto LABEL_267;
    if (v64 >= 1)
    {
      v66 = 0;
      while (1)
      {
        v67 = (const __CFDictionary *)CFArrayGetValueAtIndex(v62, v66);
        if (!v67)
          break;
        v68 = v67;
        v69 = CFGetTypeID(v67);
        if (v69 != CFDictionaryGetTypeID())
          break;
        v70 = (void *)CFArrayGetValueAtIndex(SampleAttachmentsArray, v66);
        CFDictionaryApplyFunction(v68, (CFDictionaryApplierFunction)CopyEntry, v70);
        if (v64 == ++v66)
          goto LABEL_198;
      }
LABEL_267:
      v82 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      v21 = v98;
      v72 = v86;
      v71 = v87;
      v73 = allocatora;
      v74 = v95;
      if ((_DWORD)v82)
      {
        CaptionGroupFromCFData = v82;
        v20 = v106;
        v11 = (__CFArray *)sampleTiminga;
        goto LABEL_219;
      }
      goto LABEL_202;
    }
  }
LABEL_198:
  v21 = v98;
  v72 = v86;
  v71 = v87;
  v73 = allocatora;
  v74 = v95;
  if (v61)
    CMSetAttachments(v59, v61, 1u);
  if (v60)
    CMSetAttachments(v59, v60, 0);
LABEL_202:
  v20 = v106;
  if (v88)
    *v88 = v74;
  if (a9)
    *a9 = v91 - (_QWORD)v73;
  if (a10)
    *a10 = v92;
  *(_QWORD *)a11 = sampleBufferOut;
  sampleBufferOut = 0;
  v11 = (__CFArray *)sampleTiminga;
  if (v72)
  {
    v75 = *v72;
    *v72 = v101;
    if (v101)
      CFRetain(v101);
    if (v75)
      CFRelease(v75);
  }
  if (v71)
  {
    v76 = *v71;
    *v71 = cf;
    if (cf)
      CFRetain(cf);
    if (v76)
      CFRelease(v76);
  }
  CaptionGroupFromCFData = 0;
LABEL_219:
  if (sampleBufferOut)
    CFRelease(sampleBufferOut);
  if (v108)
    CFRelease(v108);
  if (pixelBufferOut)
    CFRelease(pixelBufferOut);
  if (v115)
    CFRelease(v115);
  if (v96)
    CFRelease(v96);
  if (v113)
    CFRelease(v113);
  if (v112[2])
    CFRelease(v112[2]);
  if (v20)
    CFRelease(v20);
  if (v11)
    CFRelease(v11);
  if (v112[0])
    CFRelease(v112[0]);
  if (v111)
    CFRelease(v111);
  if (v110)
    CFRelease(v110);
  if (theAttachments)
    CFRelease(theAttachments);
  if (formatDescriptionOut)
    CFRelease(formatDescriptionOut);
  if (v21)
    CFRelease(v21);
  free(v99);
  return CaptionGroupFromCFData;
}

uint64_t FigRemote_CreateSampleBufferFromSerializedAtomBlockBufferAndSurfaceArray(const __CFArray *a1, CMBlockBufferRef theBuffer, const opaqueCMFormatDescription **a3, CFTypeRef *a4, CMSampleBufferRef *a5)
{
  uint64_t DataPointer;
  const __CFAllocator *v11;
  char *v12;
  size_t v13;
  CFIndex Count;
  CFIndex v15;
  uint64_t v16;
  __CFArray *Mutable;
  __CFArray *v18;
  uint64_t TaggedBufferGroup;
  uint64_t v20;
  CFIndex i;
  __IOSurface *ValueAtIndex;
  uint64_t v23;
  CFTypeRef v24;
  uint64_t v25;
  uint64_t v27;
  size_t totalLengthOut;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  size_t v31;
  size_t v32;
  char v33;
  CMTime v34;
  CMTime v35;
  opaqueCMSampleBuffer *v36;
  CFTypeRef v37;
  CVPixelBufferRef pixelBufferOut;
  opaqueCMSampleBuffer *v39;

  v33 = 0;
  v31 = 0;
  v32 = 0;
  lengthAtOffsetOut = 0;
  dataPointerOut = 0;
  totalLengthOut = 0;
  DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut);
  if ((_DWORD)DataPointer)
    return DataPointer;
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v13 = lengthAtOffsetOut;
  v12 = dataPointerOut;
  pixelBufferOut = 0;
  v39 = 0;
  v36 = 0;
  v37 = 0;
  if (!a1 || (Count = CFArrayGetCount(a1), Count <= 0))
  {
    v16 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  v15 = Count;
  v16 = sbufAtom_createSampleBufferFromSerializedAtomDataAndSurface(v11, 0, (uint64_t)v12, v13, 0, a3, a4, &v33, &v32, (uint64_t *)&v31, (__CFArray *)&v36);
  if ((_DWORD)v16)
  {
LABEL_19:
    v25 = v16;
    v18 = 0;
    Mutable = 0;
    goto LABEL_20;
  }
  Mutable = CFArrayCreateMutable(v11, v15, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    v25 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    v18 = 0;
    goto LABEL_20;
  }
  v18 = CFArrayCreateMutable(v11, v15, MEMORY[0x1E0C9B378]);
  if (!v18)
  {
    v27 = 4294954510;
    goto LABEL_45;
  }
  TaggedBufferGroup = FigSampleBufferGetTaggedBufferGroup((uint64_t)v36);
  if (!TaggedBufferGroup)
  {
    v27 = 4294954516;
LABEL_45:
    ValueAtIndex = 0;
LABEL_40:
    v23 = FigSignalErrorAt(v27, (uint64_t)ValueAtIndex, 0, 0, 0, 0, 0);
LABEL_41:
    v25 = v23;
    goto LABEL_20;
  }
  v20 = TaggedBufferGroup;
  for (i = 0; i != v15; ++i)
  {
    ValueAtIndex = (__IOSurface *)CFArrayGetValueAtIndex(a1, i);
    if (!ValueAtIndex)
    {
LABEL_38:
      v27 = 4294954516;
      goto LABEL_40;
    }
    CVPixelBufferCreateWithIOSurface(v11, ValueAtIndex, 0, &pixelBufferOut);
    ValueAtIndex = pixelBufferOut;
    if (!pixelBufferOut)
    {
      v27 = 4294954510;
      goto LABEL_40;
    }
    CFArrayAppendValue(Mutable, pixelBufferOut);
    ValueAtIndex = (__IOSurface *)FigTaggedBufferGroupGetTagCollectionAtIndex(v20, i);
    if (!ValueAtIndex)
      goto LABEL_38;
    CFArrayAppendValue(v18, ValueAtIndex);
    if (pixelBufferOut)
    {
      CFRelease(pixelBufferOut);
      pixelBufferOut = 0;
    }
  }
  v23 = FigTaggedBufferGroupCreate(v11, v18, Mutable, &v37);
  if ((_DWORD)v23)
    goto LABEL_41;
  v24 = v37;
  CMSampleBufferGetPresentationTimeStamp(&v35, v36);
  CMSampleBufferGetDuration(&v34, v36);
  v25 = FigSampleBufferCreateForTaggedBufferGroup(v11, v24, (__int128 *)&v35.value, (uint64_t)&v34, &v39);
  if (!(_DWORD)v25)
  {
    *a5 = v39;
    v39 = 0;
  }
LABEL_20:
  if (v36)
    CFRelease(v36);
  if (pixelBufferOut)
    CFRelease(pixelBufferOut);
  if (v37)
    CFRelease(v37);
  if (v18)
    CFRelease(v18);
  if (Mutable)
    CFRelease(Mutable);
  if (!(_DWORD)v25 && v33)
  {
    v35.value = 0;
    DataPointer = CMBlockBufferCreateWithBufferReference(v11, theBuffer, v32, v31, 0, (CMBlockBufferRef *)&v35);
    if (!(_DWORD)DataPointer)
    {
      CMSampleBufferSetDataBuffer(*a5, (CMBlockBufferRef)v35.value);
      if (v35.value)
        CFRelease((CFTypeRef)v35.value);
      return CMSampleBufferSetDataReady(*a5);
    }
    return DataPointer;
  }
  return v25;
}

uint64_t FigRemote_CreateSampleBufferFromSerializedAtomDataBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, size_t a3, const opaqueCMFormatDescription **a4, CFTypeRef *a5, __CFArray *a6)
{
  uint64_t DataPointer;
  uint64_t v13;
  CMBlockBufferRef blockBufferOut;
  size_t lengthAtOffsetOut;
  size_t v17;
  uint64_t v18;
  char v19;
  char *dataPointerOut;

  dataPointerOut = 0;
  v19 = 0;
  v17 = 0;
  v18 = 0;
  blockBufferOut = 0;
  lengthAtOffsetOut = 0;
  if (!CMBlockBufferIsRangeContiguous(theBuffer, 0, 0))
    return 4294954516;
  DataPointer = CMBlockBufferGetDataPointer(theBuffer, a3, &lengthAtOffsetOut, 0, &dataPointerOut);
  if ((_DWORD)DataPointer)
    goto LABEL_8;
  v13 = sbufAtom_createSampleBufferFromSerializedAtomDataAndSurface(a1, 0, (uint64_t)dataPointerOut, lengthAtOffsetOut, 0, a4, a5, &v19, &v18, (uint64_t *)&v17, a6);
  if (!(_DWORD)v13 && v19)
  {
    DataPointer = CMBlockBufferCreateWithBufferReference(a1, theBuffer, v18 + a3, v17, 0, &blockBufferOut);
    if (!(_DWORD)DataPointer)
    {
      DataPointer = CMSampleBufferSetDataBuffer(*(CMSampleBufferRef *)a6, blockBufferOut);
      if (!(_DWORD)DataPointer)
        DataPointer = CMSampleBufferSetDataReady(*(CMSampleBufferRef *)a6);
    }
LABEL_8:
    v13 = DataPointer;
  }
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v13;
}

uint64_t FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptionsForPID(opaqueCMSampleBuffer *a1, const __CFDictionary *a2, const __CFDictionary *a3, unsigned int a4, uint64_t a5, uint64_t a6, _QWORD *a7, const opaqueCMFormatDescription *a8, _QWORD *a9, int a10)
{
  int v10;
  uint64_t result;
  unsigned int v20;

  if ((a4 & 1) != 0)
    v10 = 5;
  else
    v10 = 1;
  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  result = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (!(_DWORD)result)
  {
    v20 = v10 & 0xFFFFFFF7 | (8 * ((a4 >> 1) & 1));
    if (!a7
      || (result = sbufAtom_createSerializedDataAndSurfaceForSampleBuffer(a1, v20, a2, a3, 0, 0, 0, 0, a7, a8, 0, a10, 0, 0), !(_DWORD)result))
    {
      result = 0;
      if (a5)
      {
        if (a6)
          return sbufAtom_createSerializedDataAndSurfaceForSampleBuffer(a1, v20, a2, a3, 0, 0, a5, a6, 0, a8, 0, a10, a9, 0);
      }
    }
  }
  return result;
}

uint64_t FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptions(opaqueCMSampleBuffer *a1, unsigned int a2, uint64_t a3, uint64_t a4, _QWORD *a5, const opaqueCMFormatDescription *a6, _QWORD *a7)
{
  return FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptionsForPID(a1, 0, 0, a2, a3, a4, a5, a6, a7, 0);
}

uint64_t FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBuffer(opaqueCMSampleBuffer *a1, uint64_t a2, uint64_t a3, _QWORD *a4, const opaqueCMFormatDescription *a5, _QWORD *a6)
{
  return FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptionsForPID(a1, 0, 0, 0, a2, a3, a4, a5, a6, 0);
}

uint64_t FigRemote_CreateSampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor(const __CFAllocator *a1, uint64_t a2, unint64_t a3, int a4, OpaqueCMBlockBuffer *a5, const opaqueCMFormatDescription **a6, CFTypeRef *a7, CMSampleBufferRef *a8)
{
  uint64_t SampleBufferFromSerializedAtomDataAndSurface;
  const opaqueCMFormatDescription *FormatDescription;
  uint64_t SampleSizeArray;
  uint64_t v14;
  size_t DataLength;
  CMSampleBufferRef sbuf;

  sbuf = 0;
  SampleBufferFromSerializedAtomDataAndSurface = sbufAtom_createSampleBufferFromSerializedAtomDataAndSurface(a1, 0, a2, a3, 1, a6, a7, 0, 0, 0, (__CFArray *)&sbuf);
  if ((_DWORD)SampleBufferFromSerializedAtomDataAndSurface)
    goto LABEL_16;
  if (!a5)
    goto LABEL_10;
  SampleBufferFromSerializedAtomDataAndSurface = CMSampleBufferSetDataBuffer(sbuf, a5);
  if ((_DWORD)SampleBufferFromSerializedAtomDataAndSurface)
  {
LABEL_16:
    SampleSizeArray = SampleBufferFromSerializedAtomDataAndSurface;
    goto LABEL_17;
  }
  FormatDescription = CMSampleBufferGetFormatDescription(sbuf);
  SampleSizeArray = (uint64_t)FormatDescription;
  if (!FormatDescription)
  {
LABEL_11:
    if (!a4)
    {
LABEL_14:
      *a8 = sbuf;
      return SampleSizeArray;
    }
    v14 = CMSampleBufferSetDataReady(sbuf);
    goto LABEL_13;
  }
  if (CMFormatDescriptionGetMediaType(FormatDescription) != 1986618469
    && CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)SampleSizeArray) != 1635088502
    && CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)SampleSizeArray) != 1885954932)
  {
LABEL_10:
    SampleSizeArray = 0;
    goto LABEL_11;
  }
  SampleSizeArray = CMSampleBufferGetSampleSizeArray(sbuf, 0, 0, 0);
  if ((_DWORD)SampleSizeArray != -12735)
    goto LABEL_11;
  DataLength = CMBlockBufferGetDataLength(a5);
  v14 = CMSampleBufferSetDataReadyWithNewSize((uint64_t)sbuf, 1, &DataLength);
LABEL_13:
  SampleSizeArray = v14;
  if (!(_DWORD)v14)
    goto LABEL_14;
LABEL_17:
  if (sbuf)
    CFRelease(sbuf);
  return SampleSizeArray;
}

uint64_t FigRemote_CreateSampleBufferFromSerializedAtomDataWithDataBuffer(const __CFAllocator *a1, uint64_t a2, unint64_t a3, int a4, OpaqueCMBlockBuffer *a5, const opaqueCMFormatDescription **a6, CMSampleBufferRef *a7)
{
  return FigRemote_CreateSampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor(a1, a2, a3, a4, a5, a6, 0, a7);
}

uint64_t FigRemote_CreateSerializedAtomDataForPixelBuffer(void *a1, mach_port_t *a2, vm_address_t *a3, vm_size_t a4, vm_size_t *a5)
{
  uint64_t result;
  mach_port_t MachPort;
  mach_port_t v8;
  IOSurfaceRef buffer;

  buffer = 0;
  result = FigRemote_CreateSerializedAtomDataAndSurfaceForPixelBuffer(a1, (CFTypeRef *)&buffer, a3, a4, a5);
  if (!(_DWORD)result)
  {
    result = (uint64_t)buffer;
    if (buffer)
    {
      MachPort = IOSurfaceCreateMachPort(buffer);
      if (MachPort)
      {
        v8 = MachPort;
        if (a2)
        {
          result = 0;
          *a2 = v8;
        }
        else
        {
          FigMachPortReleaseSendRight_(MachPort, 0, 0, 0, 0);
          return 0;
        }
      }
      else
      {
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  return result;
}

uint64_t FigRemote_CreateSerializedAtomDataAndSurfaceForPixelBuffer(void *a1, CFTypeRef *a2, vm_address_t *a3, vm_size_t a4, vm_size_t *a5)
{
  CFTypeID v10;
  uint64_t v11;
  char v12;
  vm_map_t *v13;
  vm_size_t v14;
  vm_size_t v15;
  vm_size_t v16;
  uint64_t SerializedDataForPixelBuffer;
  vm_size_t size;
  vm_address_t address;
  CFTypeRef cf;

  address = 0;
  cf = 0;
  size = 0;
  if (!a1 || (v10 = CFGetTypeID(a1), v10 != CVPixelBufferGetTypeID()) || !a3 || !a5)
  {
    v11 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_22;
  }
  v11 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if ((_DWORD)v11)
  {
LABEL_22:
    SerializedDataForPixelBuffer = v11;
    goto LABEL_26;
  }
  *a5 = 0;
  v12 = 1;
  v13 = (vm_map_t *)MEMORY[0x1E0C83DA0];
  do
  {
    v14 = a4;
    if (a4)
    {
      size = a4;
      v15 = a4;
    }
    else
    {
      v11 = sbufAtom_createSerializedDataForPixelBuffer(a1, 0, 1, 0, 0, &size);
      if ((_DWORD)v11)
        goto LABEL_22;
      v15 = size;
      if (!size)
      {
        v16 = 0;
        goto LABEL_13;
      }
    }
    v11 = vm_allocate(*v13, &address, v15, 1543503873);
    if ((_DWORD)v11)
      goto LABEL_22;
    v16 = size;
LABEL_13:
    SerializedDataForPixelBuffer = sbufAtom_createSerializedDataForPixelBuffer(a1, (IOSurfaceRef *)&cf, 1, address, v16, 0);
    if (!(_DWORD)SerializedDataForPixelBuffer)
      break;
    if (address && size)
    {
      MEMORY[0x193FFCA84](*v13);
      size = 0;
      address = 0;
    }
    if ((_DWORD)SerializedDataForPixelBuffer != -12572 || (v12 & 1) == 0)
      break;
    v12 = 0;
    a4 = 0;
  }
  while (v14);
  if (a2)
  {
    *a2 = cf;
    cf = 0;
  }
  *a3 = address;
  *a5 = size;
  size = 0;
LABEL_26:
  if (cf)
    CFRelease(cf);
  if (address && size)
    MEMORY[0x193FFCA84](*MEMORY[0x1E0C83DA0]);
  return SerializedDataForPixelBuffer;
}

uint64_t sbufAtom_createSerializedDataForPixelBuffer(void *a1, IOSurfaceRef *a2, int a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  uint64_t appended;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  uint64_t v13;
  IOSurfaceRef IOSurface;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  size_t DataSize;
  void *BaseAddress;
  uint64_t v20;
  uint64_t v21;
  int Width;
  OSType PixelFormatType;
  uint64_t v25[2];
  __int128 v26;
  __int128 v27;
  int v28;

  v28 = 0;
  v27 = 0u;
  v26 = 0u;
  v25[0] = a4;
  v25[1] = a5;
  appended = FigNEAtomWriterBeginAtom((uint64_t)v25, 1885500774);
  if ((_DWORD)appended)
    return appended;
  v11 = CMCopyDictionaryOfAttachments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 1u);
  if (!v11
    || (v12 = v11, v13 = sbufAtom_appendDictionaryAtom(v11, 1, 1767994484, v25), CFRelease(v12), !(_DWORD)v13))
  {
    if (!a3)
      goto LABEL_8;
    IOSurface = CVPixelBufferGetIOSurface((CVPixelBufferRef)a1);
    if (a2)
      *a2 = IOSurface;
    if (!IOSurface)
    {
LABEL_8:
      PixelFormatType = CVPixelBufferGetPixelFormatType((CVPixelBufferRef)a1);
      appended = sbufAtom_appendAtomWithMemoryBlock(&PixelFormatType, 4uLL, 1885762157, v25);
      if ((_DWORD)appended)
        return appended;
      Width = CVPixelBufferGetWidth((CVPixelBufferRef)a1);
      appended = sbufAtom_appendAtomWithMemoryBlock(&Width, 4uLL, 1886873956, v25);
      if ((_DWORD)appended)
        return appended;
      Width = CVPixelBufferGetHeight((CVPixelBufferRef)a1);
      appended = sbufAtom_appendAtomWithMemoryBlock(&Width, 4uLL, 1885889897, v25);
      if ((_DWORD)appended)
        return appended;
      Width = CVPixelBufferGetBytesPerRow((CVPixelBufferRef)a1);
      appended = sbufAtom_appendAtomWithMemoryBlock(&Width, 4uLL, 1885499506, v25);
      if ((_DWORD)appended)
        return appended;
      Width = CVPixelBufferGetPlaneCount((CVPixelBufferRef)a1);
      appended = sbufAtom_appendAtomWithMemoryBlock(&Width, 4uLL, 1886415971, v25);
      if ((_DWORD)appended)
        return appended;
      v15 = (*((_QWORD *)&v27 + 1) + 127) & 0xFFFFFFFFFFFFFF80;
      v16 = v15 - 8 - *((_QWORD *)&v27 + 1);
      if (v15 - 8 != *((_QWORD *)&v27 + 1))
      {
        if (v15 - 8 > *((_QWORD *)&v27 + 1))
          v17 = v16 >= 8 ? v15 - 8 - *((_QWORD *)&v27 + 1) : v16 + 128;
        else
          v17 = *((_QWORD *)&v27 + 1) - v15 + 136;
        appended = sbufAtom_appendAtomWithMemoryBlock(0, v17, 1718773093, v25);
        if ((_DWORD)appended)
          return appended;
      }
      CVPixelBufferLockBaseAddress((CVPixelBufferRef)a1, 0);
      DataSize = CVPixelBufferGetDataSize((CVPixelBufferRef)a1);
      BaseAddress = CVPixelBufferGetBaseAddress((CVPixelBufferRef)a1);
      v13 = sbufAtom_appendAtomWithMemoryBlock(BaseAddress, DataSize, 1885626740, v25);
      CVPixelBufferUnlockBaseAddress((CVPixelBufferRef)a1, 0);
      if ((_DWORD)v13)
        return v13;
    }
    v20 = FigNEAtomWriterEndAtom((uint64_t)v25);
    v13 = v20;
    if (a6 && !(_DWORD)v20)
    {
      v21 = *((_QWORD *)&v27 + 1);
      if (*((_QWORD *)&v27 + 1) == 8)
        v21 = 0;
      *a6 = v21;
    }
  }
  return v13;
}

uint64_t FigRemote_CreateSerializedAtomDataBlockBufferForPixelBuffer(const __CFAllocator *a1, CFTypeRef cf, CMBlockBufferRef *a3)
{
  CFTypeID v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  size_t v10;
  const __CFAllocator *GlobalCFAllocatorFigMalloc;
  uint64_t v12;
  _QWORD v14[5];
  void *v15;
  size_t v16;
  size_t v17;

  v17 = 0;
  v15 = 0;
  if (!cf || (v6 = CFGetTypeID(cf), v6 != CVPixelBufferGetTypeID()) || !a3)
  {
    v7 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
  v7 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if ((_DWORD)v7)
  {
LABEL_10:
    v12 = v7;
    v9 = 0;
    goto LABEL_8;
  }
  v16 = 0;
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 0x40000000;
  v14[2] = __FigRemote_CreateSerializedAtomDataBlockBufferForPixelBuffer_block_invoke;
  v14[3] = &__block_descriptor_tmp_1_3;
  v14[4] = cf;
  v8 = sbufAtom_createSerializedDataUsingSerializer(0x19000uLL, &v15, &v17, &v16, (uint64_t)v14);
  v9 = v15;
  if ((_DWORD)v8)
  {
    v12 = v8;
  }
  else
  {
    v10 = v17;
    GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    v12 = CMBlockBufferCreateWithMemoryBlock(a1, v9, v10, GlobalCFAllocatorFigMalloc, 0, 0, v16, 0, a3);
    if (!(_DWORD)v12)
      v9 = 0;
  }
LABEL_8:
  free(v9);
  return v12;
}

uint64_t FigRemote_CreatePixelBufferFromSerializedAtomData(mach_port_t a1, void *a2, size_t a3, CVPixelBufferRef *a4)
{
  __IOSurface *v7;
  uint64_t PixelBufferFromSerializedAtomDataAndSurface;
  OpaqueCMBlockBuffer *v9;
  uint64_t v10;
  CMBlockBufferCustomBlockSource customBlockSource;
  CMBlockBufferRef blockBufferOut;

  blockBufferOut = 0;
  HIDWORD(customBlockSource.AllocateBlock) = 0;
  customBlockSource.refCon = 0;
  *(_QWORD *)&customBlockSource.version = 0;
  customBlockSource.FreeBlock = (void (__cdecl *)(void *, void *, size_t))_bbufBlockSourceFree;
  if (a1)
  {
    v7 = IOSurfaceLookupFromMachPort(a1);
    if (!v7)
    {
      v10 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      goto LABEL_11;
    }
    if (a3)
      goto LABEL_4;
LABEL_7:
    v9 = 0;
    goto LABEL_8;
  }
  v7 = 0;
  if (!a3)
    goto LABEL_7;
LABEL_4:
  PixelBufferFromSerializedAtomDataAndSurface = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, a3, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], &customBlockSource, 0, a3, 0, &blockBufferOut);
  if ((_DWORD)PixelBufferFromSerializedAtomDataAndSurface)
    goto LABEL_9;
  v9 = blockBufferOut;
LABEL_8:
  PixelBufferFromSerializedAtomDataAndSurface = FigRemote_CreatePixelBufferFromSerializedAtomDataAndSurface(v7, v9, a4);
LABEL_9:
  v10 = PixelBufferFromSerializedAtomDataAndSurface;
  if (v7)
    CFRelease(v7);
LABEL_11:
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v10;
}

uint64_t FigRemote_CreatePixelBufferFromSerializedAtomDataAndSurface(__IOSurface *a1, OpaqueCMBlockBuffer *a2, CVPixelBufferRef *a3)
{
  uint64_t DataPointer;
  uint64_t DataLength;
  size_t v8;
  const __CFAllocator *v9;
  uint64_t v10;
  const __CFDictionary *v11;
  BOOL v12;
  char *v13;
  size_t v14;
  size_t v15;
  OSType v16;
  size_t v17;
  size_t v18;
  uint64_t v19;
  size_t totalLengthOut;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  CFDictionaryRef theAttachments;
  unsigned int v25;
  size_t bytesPerRow;
  OSType pixelFormatType[2];
  unint64_t v28;
  uint64_t v29;
  char v30;
  size_t planeBytesPerRow[4];
  size_t planeHeight[4];
  size_t planeWidth[4];
  void *planeBaseAddress[2];
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v30 = 0;
  v28 = 0;
  v29 = 0;
  bytesPerRow = 0;
  *(_QWORD *)pixelFormatType = 0;
  v25 = 0;
  dataPointerOut = 0;
  theAttachments = 0;
  totalLengthOut = 0;
  lengthAtOffsetOut = 0;
  if (!a3)
  {
    v19 = 4294954516;
    goto LABEL_23;
  }
  DataPointer = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if ((_DWORD)DataPointer)
    goto LABEL_24;
  if (a2)
  {
    DataLength = CMBlockBufferGetDataLength(a2);
    if (DataLength)
    {
      DataPointer = CMBlockBufferGetDataPointer(a2, 0, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut);
      if ((_DWORD)DataPointer)
        goto LABEL_24;
      v8 = lengthAtOffsetOut;
      DataLength = (uint64_t)dataPointerOut;
    }
    else
    {
      v8 = 0;
    }
  }
  else
  {
    v8 = 0;
    DataLength = 0;
  }
  DataPointer = sbufAtom_createPixelBufferAttachmentsFromSerializedAtomData(DataLength, v8, &v30, &v29, (uint64_t *)&v28, pixelFormatType, (_DWORD *)&bytesPerRow + 1, &pixelFormatType[1], &bytesPerRow, &v25, (CFTypeRef *)&theAttachments);
  if ((_DWORD)DataPointer)
    goto LABEL_24;
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (!a1)
  {
    if (v30)
    {
      v13 = &dataPointerOut[v29];
      if (a2)
        a2 = (OpaqueCMBlockBuffer *)CFRetain(a2);
      v14 = v25;
      if (v25 < 2)
      {
        v19 = CVPixelBufferCreateWithBytes(v9, pixelFormatType[0], HIDWORD(bytesPerRow), pixelFormatType[1], v13, bytesPerRow, (CVPixelBufferReleaseBytesCallback)_pixelbufferreleasecallback, a2, 0, a3);
LABEL_28:
        if (!(_DWORD)v19)
        {
          v11 = theAttachments;
          if (!theAttachments)
            return 0;
          goto LABEL_30;
        }
        goto LABEL_23;
      }
      *(_OWORD *)planeBaseAddress = 0u;
      v35 = 0u;
      v15 = v28;
      v17 = pixelFormatType[0];
      v16 = pixelFormatType[1];
      v18 = HIDWORD(bytesPerRow);
      DataPointer = figReconstructPixelBufferPlaneInfo((uint64_t)v13, v28, v25, pixelFormatType[1], pixelFormatType[0], HIDWORD(bytesPerRow), (uint64_t)planeBaseAddress, (uint64_t)planeWidth, (uint64_t)planeHeight, (uint64_t)planeBytesPerRow);
      if (!(_DWORD)DataPointer)
      {
        v19 = CVPixelBufferCreateWithPlanarBytes(v9, v17, v18, v16, v13, v15, v14, planeBaseAddress, planeWidth, planeHeight, planeBytesPerRow, (CVPixelBufferReleasePlanarBytesCallback)_pixelbufferreleaseplanarcallback, a2, 0, a3);
        goto LABEL_28;
      }
LABEL_24:
      v10 = DataPointer;
      v11 = theAttachments;
      goto LABEL_25;
    }
    v19 = 4294954516;
LABEL_23:
    DataPointer = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
    goto LABEL_24;
  }
  v10 = CVPixelBufferCreateWithIOSurface((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0, a3);
  v11 = theAttachments;
  if ((_DWORD)v10)
    v12 = 1;
  else
    v12 = theAttachments == 0;
  if (v12)
  {
LABEL_25:
    if (!v11)
      return v10;
    goto LABEL_31;
  }
LABEL_30:
  CVBufferSetAttachments(*a3, v11, kCVAttachmentMode_ShouldPropagate);
  v10 = 0;
LABEL_31:
  CFRelease(v11);
  return v10;
}

uint64_t sbufAtom_createPixelBufferAttachmentsFromSerializedAtomData(uint64_t a1, unint64_t a2, _BYTE *a3, _QWORD *a4, uint64_t *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9, _DWORD *a10, CFTypeRef *a11)
{
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  _DWORD *v25;
  const __CFAllocator *v28;
  _BYTE *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  CFTypeRef cf;

  v33 = 0;
  cf = 0;
  v32 = 0;
  v31 = 0;
  v30 = 0;
  if (a2)
  {
    v29 = a3;
    v16 = figReadNEAtomHeader(a1, 0, a2, (_DWORD *)&v30 + 1, &v30);
    if (!(_DWORD)v16)
    {
      if (HIDWORD(v30) == 1885500774)
      {
        v17 = v30;
        if (v30 <= a2)
        {
          a3 = v29;
          if (v30 >= 9)
          {
            v25 = a7;
            v18 = 0;
            v19 = 0;
            v28 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v20 = 8;
            while (1)
            {
              v16 = figReadNEAtomHeader(a1, v20, v17, (_DWORD *)&v30 + 1, &v30);
              if ((_DWORD)v16)
                goto LABEL_39;
              v21 = v30;
              if (SHIDWORD(v30) <= 1885762156)
              {
                if (HIDWORD(v30) == 1767994484)
                {
                  v16 = sbufAtom_copyDictionaryFromAtom(v28, a1 + 8 + v20, v30 - 8, (__CFDictionary **)&cf);
                  if ((_DWORD)v16)
                    goto LABEL_39;
                  goto LABEL_31;
                }
                if (HIDWORD(v30) != 1885499506)
                {
                  if (HIDWORD(v30) == 1885626740)
                  {
                    v19 = a1 + 8 + v20;
                    v18 = v30 - 8;
                  }
                  goto LABEL_31;
                }
                if ((_DWORD)v30 != 12)
                  goto LABEL_38;
                goto LABEL_30;
              }
              if (SHIDWORD(v30) > 1886415970)
              {
                if (HIDWORD(v30) == 1886415971)
                {
                  if ((_DWORD)v30 != 12)
                    goto LABEL_38;
                  goto LABEL_30;
                }
                if (HIDWORD(v30) == 1886873956)
                {
                  if ((_DWORD)v30 != 12)
                    goto LABEL_38;
                  goto LABEL_30;
                }
              }
              else
              {
                if (HIDWORD(v30) == 1885762157)
                {
                  if ((_DWORD)v30 != 12)
                    goto LABEL_38;
                  goto LABEL_30;
                }
                if (HIDWORD(v30) == 1885889897)
                {
                  if ((_DWORD)v30 != 12)
                    goto LABEL_38;
LABEL_30:
                  __memcpy_chk();
                }
              }
LABEL_31:
              v20 += v21;
              if (v20 >= v17)
              {
                a7 = v25;
                a3 = v29;
                if (v19 && v18)
                {
                  *v29 = 1;
                  *a4 = v19 - a1;
                  *a5 = v18;
                  goto LABEL_36;
                }
                goto LABEL_35;
              }
            }
          }
          goto LABEL_35;
        }
      }
LABEL_38:
      v16 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
LABEL_39:
    v22 = v16;
    if (cf)
      CFRelease(cf);
    return v22;
  }
LABEL_35:
  *a3 = 0;
LABEL_36:
  v22 = 0;
  v23 = HIDWORD(v32);
  *a6 = v33;
  *a7 = v23;
  *a8 = HIDWORD(v33);
  *a9 = v32;
  *a10 = v31;
  *a11 = cf;
  return v22;
}

uint64_t figReconstructPixelBufferPlaneInfo(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t DescriptionWithPixelFormatType;
  const __CFDictionary *v13;
  uint64_t result;
  const __CFArray *Value;
  const __CFArray *v16;
  CFTypeID v17;
  CFIndex v18;
  unsigned int *i;
  const __CFDictionary *ValueAtIndex;
  const void *v21;
  const void *v22;
  const __CFArray *v23;
  unint64_t v24;
  CFTypeID v25;
  BOOL v26;
  CFTypeID v27;
  signed int v28;
  unint64_t v29;
  void *v30;
  void *key;
  int v37;
  int valuePtr;
  _BYTE v39[36];

  *(_QWORD *)&v39[28] = *MEMORY[0x1E0C80C00];
  DescriptionWithPixelFormatType = CVPixelFormatDescriptionGetDescriptionWithPixelFormatType();
  if (a3 > 4)
    return 4294954516;
  v13 = (const __CFDictionary *)DescriptionWithPixelFormatType;
  result = 4294954516;
  if (8 * a3 > a2 || !v13)
    return result;
  Value = (const __CFArray *)CFDictionaryGetValue(v13, (const void *)*MEMORY[0x1E0CA91B0]);
  if (!Value)
    return 4294954516;
  v16 = Value;
  v17 = CFGetTypeID(Value);
  if (v17 != CFArrayGetTypeID() || CFArrayGetCount(v16) < a3)
    return 4294954516;
  __memcpy_chk();
  if (a3)
  {
    v18 = 0;
    key = (void *)*MEMORY[0x1E0CA91A0];
    v30 = (void *)*MEMORY[0x1E0CA91B8];
    for (i = (unsigned int *)v39; ; i += 2)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v16, v18);
      v37 = 1;
      valuePtr = 1;
      v21 = CFDictionaryGetValue(ValueAtIndex, key);
      v22 = CFDictionaryGetValue(ValueAtIndex, v30);
      if (v21)
      {
        v23 = v16;
        v24 = a3;
        v25 = CFGetTypeID(v21);
        v26 = v25 == CFNumberGetTypeID();
        a3 = v24;
        v16 = v23;
        if (v26)
          CFNumberGetValue((CFNumberRef)v21, kCFNumberIntType, &valuePtr);
      }
      if (v22)
      {
        v27 = CFGetTypeID(v22);
        if (v27 == CFNumberGetTypeID())
          CFNumberGetValue((CFNumberRef)v22, kCFNumberIntType, &v37);
      }
      v28 = bswap32(*(i - 1));
      if (v28 + 4 > a2)
        break;
      *(_QWORD *)(a7 + 8 * v18) = a1 + v28;
      *(_QWORD *)(a10 + 8 * v18) = bswap32(*i);
      *(_QWORD *)(a8 + 8 * v18) = a5 / valuePtr;
      v29 = a6 / v37;
      *(_QWORD *)(a9 + 8 * v18) = v29;
      if (v28 + *(_QWORD *)(a10 + 8 * v18) * v29 > a2)
        break;
      if (a3 == ++v18)
        return 0;
    }
    return 4294954516;
  }
  return 0;
}

void _pixelbufferreleaseplanarcallback(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void _pixelbufferreleasecallback(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t FigRemote_CreatePixelBufferFromSerializedAtomDataBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, size_t a3, CVPixelBufferRef *a4)
{
  size_t v8;
  unint64_t v9;
  uint64_t DataPointer;
  size_t v11;
  size_t v12;
  size_t v13;
  OSType v14;
  size_t v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v20;
  size_t v21;
  CMBlockBufferRef blockBufferOut;
  unsigned int v23;
  size_t bytesPerRow;
  OSType pixelFormatType[2];
  size_t dataLength;
  uint64_t v27;
  char v28;
  char *dataPointerOut;
  size_t planeBytesPerRow[4];
  size_t planeHeight[4];
  size_t planeWidth[4];
  void *planeBaseAddress[2];
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  dataPointerOut = 0;
  v8 = CMBlockBufferGetDataLength(theBuffer);
  v28 = 0;
  dataLength = 0;
  v27 = 0;
  bytesPerRow = 0;
  *(_QWORD *)pixelFormatType = 0;
  v23 = 0;
  v21 = 0;
  blockBufferOut = 0;
  if (!a4)
    goto LABEL_12;
  v9 = v8;
  if (!CMBlockBufferIsRangeContiguous(theBuffer, 0, v8))
  {
    v18 = 4294954516;
    goto LABEL_19;
  }
  DataPointer = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if ((_DWORD)DataPointer)
    goto LABEL_14;
  DataPointer = CMBlockBufferGetDataPointer(theBuffer, a3, 0, 0, &dataPointerOut);
  if ((_DWORD)DataPointer)
    goto LABEL_14;
  DataPointer = sbufAtom_createPixelBufferAttachmentsFromSerializedAtomData((uint64_t)dataPointerOut, v9, &v28, &v27, (uint64_t *)&dataLength, pixelFormatType, (_DWORD *)&bytesPerRow + 1, &pixelFormatType[1], &bytesPerRow, &v23, (CFTypeRef *)&v21);
  if ((_DWORD)DataPointer)
    goto LABEL_14;
  if (!v28)
  {
LABEL_12:
    v17 = 4294954516;
    goto LABEL_13;
  }
  v20 = 0;
  v11 = v27 + a3;
  v12 = dataLength;
  DataPointer = CMBlockBufferCreateWithBufferReference(a1, theBuffer, v11, dataLength, 0, &blockBufferOut);
  if ((_DWORD)DataPointer)
    goto LABEL_14;
  DataPointer = CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &v20);
  if ((_DWORD)DataPointer)
    goto LABEL_14;
  v13 = v23;
  if (v23 < 2)
  {
    v17 = CVPixelBufferCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], pixelFormatType[0], HIDWORD(bytesPerRow), pixelFormatType[1], v20, bytesPerRow, (CVPixelBufferReleaseBytesCallback)_pixelbufferreleasebbufcallback, blockBufferOut, 0, a4);
  }
  else
  {
    *(_OWORD *)planeBaseAddress = 0u;
    v34 = 0u;
    v15 = pixelFormatType[0];
    v14 = pixelFormatType[1];
    v16 = HIDWORD(bytesPerRow);
    DataPointer = figReconstructPixelBufferPlaneInfo((uint64_t)v20, v12, v23, pixelFormatType[1], pixelFormatType[0], HIDWORD(bytesPerRow), (uint64_t)planeBaseAddress, (uint64_t)planeWidth, (uint64_t)planeHeight, (uint64_t)planeBytesPerRow);
    if ((_DWORD)DataPointer)
    {
LABEL_14:
      v18 = DataPointer;
      goto LABEL_19;
    }
    v17 = CVPixelBufferCreateWithPlanarBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v15, v16, v14, v20, v12, v13, planeBaseAddress, planeWidth, planeHeight, planeBytesPerRow, (CVPixelBufferReleasePlanarBytesCallback)_pixelbufferreleaseplanarbbufcallback, blockBufferOut, 0, a4);
  }
  if ((_DWORD)v17)
  {
LABEL_13:
    DataPointer = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  blockBufferOut = 0;
  if (!v21)
    return 0;
  CVBufferSetAttachments(*a4, (CFDictionaryRef)v21, kCVAttachmentMode_ShouldPropagate);
  v18 = 0;
LABEL_19:
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  if (v21)
    CFRelease((CFTypeRef)v21);
  return v18;
}

void _pixelbufferreleaseplanarbbufcallback(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void _pixelbufferreleasebbufcallback(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t FigRemote_CreateSerializedAtomDataBlockBufferForKeyValuePair(const __CFAllocator *a1, uint64_t a2, uint64_t a3, CMBlockBufferRef *a4)
{
  uint64_t v6;
  void *v7;
  size_t v8;
  const __CFAllocator *GlobalCFAllocatorFigMalloc;
  uint64_t v10;
  _QWORD v12[6];
  void *v13;
  size_t v14;
  size_t v15;

  v15 = 0;
  v13 = 0;
  if (a2 && a3 && a4)
  {
    v14 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 0x40000000;
    v12[2] = __FigRemote_CreateSerializedAtomDataBlockBufferForKeyValuePair_block_invoke;
    v12[3] = &__block_descriptor_tmp_2_4;
    v12[4] = a2;
    v12[5] = a3;
    v6 = sbufAtom_createSerializedDataUsingSerializer(0x80uLL, &v13, &v15, &v14, (uint64_t)v12);
    v7 = v13;
    if ((_DWORD)v6)
    {
      v10 = v6;
    }
    else
    {
      v8 = v15;
      GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
      v10 = CMBlockBufferCreateWithMemoryBlock(a1, v7, v8, GlobalCFAllocatorFigMalloc, 0, 0, v14, 0, a4);
      if (!(_DWORD)v10)
        v7 = 0;
    }
  }
  else
  {
    v10 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v7 = 0;
  }
  free(v7);
  return v10;
}

uint64_t FigRemote_CreateKeyValuePairFromSerializedAtomDataBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, _QWORD *a3, _QWORD *a4)
{
  size_t DataLength;
  uint64_t result;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  uint64_t v12;

  v12 = 0;
  if (!a3)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (!a4)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (!theBuffer)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (!CMBlockBufferGetDataLength(theBuffer))
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  DataLength = CMBlockBufferGetDataLength(theBuffer);
  if (!CMBlockBufferIsRangeContiguous(theBuffer, 0, DataLength))
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  lengthAtOffsetOut = 0;
  dataPointerOut = 0;
  CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
  result = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (!(_DWORD)result)
  {
    result = figReadNEAtomHeader((uint64_t)dataPointerOut, 0, lengthAtOffsetOut, (_DWORD *)&v12 + 1, &v12);
    if (!(_DWORD)result)
    {
      if (HIDWORD(v12) == 1801812342 && lengthAtOffsetOut >= v12)
        return sbufAtom_copyKeyValuePairFromAtom(a1, (uint64_t)(dataPointerOut + 8), v12 - 8, a3, a4);
      else
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

uint64_t sbufAtom_copyKeyValuePairFromAtom(const __CFAllocator *a1, uint64_t a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v8;
  const void *ValueAtIndex;
  uint64_t v10;
  uint64_t NEAtomHeader;
  unint64_t v12;
  UInt8 *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t *v18;
  const __CFArray *v19;
  unsigned __int16 v20;
  CFTypeRef v21;
  _QWORD *v23;
  _QWORD *v24;
  CFTypeRef cf;
  int v26[2];

  cf = 0;
  if (!a4)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (!a5)
  {
    v16 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_32;
  }
  if (!a3)
  {
    v21 = 0;
    ValueAtIndex = 0;
LABEL_26:
    v16 = 0;
    *a4 = ValueAtIndex;
    *a5 = v21;
    return v16;
  }
  v23 = a4;
  v24 = a5;
  v8 = 0;
  ValueAtIndex = 0;
  v10 = a2 + 8;
  *(_QWORD *)v26 = 0;
  while (1)
  {
    NEAtomHeader = figReadNEAtomHeader(a2, v8, a3, &v26[1], v26);
    if ((_DWORD)NEAtomHeader)
      break;
    v12 = v8 + v26[0];
    if (v12 > a3)
    {
      NEAtomHeader = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      break;
    }
    v13 = (UInt8 *)(v10 + v8);
    v14 = v26[0] - 8;
    if (ValueAtIndex)
    {
      v15 = sbufAtom_copyCFTypeFromAtom(a1, v26[1], v13, v14, (CFMutableArrayRef *)&cf);
    }
    else
    {
      if (v26[1] == 1768192107)
      {
        if (v26[0] != 10)
        {
          v16 = 4294954516;
          goto LABEL_32;
        }
        v17 = *(unsigned __int16 *)v13;
        v18 = &sKnownCaptureKeysArray;
        if (v17 <= 0x7FFE)
          v18 = &sKnownSBufKeysArray;
        v19 = (const __CFArray *)*v18;
        if (!*v18 || (v17 <= 0x7FFE ? (v20 = *(_WORD *)v13) : (v20 = v17 - 0x7FFF), CFArrayGetCount(v19) <= v20))
        {
          v16 = 4294954513;
          goto LABEL_32;
        }
        ValueAtIndex = CFArrayGetValueAtIndex(v19, v20);
        CFRetain(ValueAtIndex);
        goto LABEL_10;
      }
      if (v26[1] == 1937011307)
      {
        ValueAtIndex = CFStringCreateWithBytes(a1, (const UInt8 *)(v10 + v8), v14, 0x8000100u, 0);
        goto LABEL_10;
      }
      v15 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    }
    v16 = v15;
    if ((_DWORD)v15)
      goto LABEL_30;
LABEL_10:
    v8 = v12;
    if (v12 >= a3)
    {
      a5 = v24;
      v21 = cf;
      a4 = v23;
      goto LABEL_26;
    }
  }
  v16 = NEAtomHeader;
LABEL_30:
  if (ValueAtIndex)
    CFRelease(ValueAtIndex);
LABEL_32:
  if (cf)
    CFRelease(cf);
  return v16;
}

uint64_t FigRemote_CreateSerializedAtomDataBlockBufferForCFType(const __CFAllocator *a1, uint64_t a2, CMBlockBufferRef *a3)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  size_t v9;
  const __CFAllocator *GlobalCFAllocatorFigMalloc;
  uint64_t v11;
  _QWORD v13[5];
  void *v14;
  size_t v15;
  size_t v16;

  v16 = 0;
  v14 = 0;
  if (!a2 || !a3)
  {
    v6 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  v6 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if ((_DWORD)v6)
  {
LABEL_9:
    v11 = v6;
    v8 = 0;
    goto LABEL_7;
  }
  v15 = 0;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 0x40000000;
  v13[2] = __FigRemote_CreateSerializedAtomDataBlockBufferForCFType_block_invoke;
  v13[3] = &__block_descriptor_tmp_3_5;
  v13[4] = a2;
  v7 = sbufAtom_createSerializedDataUsingSerializer(0x80uLL, &v14, &v16, &v15, (uint64_t)v13);
  v8 = v14;
  if ((_DWORD)v7)
  {
    v11 = v7;
  }
  else
  {
    v9 = v16;
    GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    v11 = CMBlockBufferCreateWithMemoryBlock(a1, v8, v9, GlobalCFAllocatorFigMalloc, 0, 0, v15, 0, a3);
    if (!(_DWORD)v11)
      v8 = 0;
  }
LABEL_7:
  free(v8);
  return v11;
}

uint64_t FigRemote_CreateSerializedAtomDataBlockBufferWithFlagsForCFType(const __CFAllocator *a1, uint64_t a2, int a3, CMBlockBufferRef *a4)
{
  uint64_t v8;
  uint64_t v9;
  void *v10;
  size_t v11;
  const __CFAllocator *GlobalCFAllocatorFigMalloc;
  uint64_t v13;
  _QWORD v15[5];
  int v16;
  void *v17;
  size_t dataLength;
  size_t v19;

  v19 = 0;
  v17 = 0;
  if (!a2 || !a4)
  {
    v8 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  v8 = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if ((_DWORD)v8)
  {
LABEL_9:
    v13 = v8;
    v10 = 0;
    goto LABEL_7;
  }
  dataLength = 0;
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 0x40000000;
  v15[2] = __FigRemote_CreateSerializedAtomDataBlockBufferWithFlagsForCFType_block_invoke;
  v15[3] = &__block_descriptor_tmp_4_4;
  v15[4] = a2;
  v16 = a3;
  v9 = sbufAtom_createSerializedDataUsingSerializer(0x80uLL, &v17, &v19, &dataLength, (uint64_t)v15);
  v10 = v17;
  if ((_DWORD)v9)
  {
    v13 = v9;
  }
  else
  {
    v11 = v19;
    GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
    v13 = CMBlockBufferCreateWithMemoryBlock(a1, v10, v11, GlobalCFAllocatorFigMalloc, 0, 0, dataLength, 0, a4);
    if (!(_DWORD)v13)
      v10 = 0;
  }
LABEL_7:
  free(v10);
  return v13;
}

CFIndex sbufAtom_createSerializedDataWithFlagsForCFType(__CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  CFIndex appended;
  CFIndex v8;
  uint64_t v11;
  CFTypeID v12;
  uint64_t v14[2];
  __int128 v15;
  __int128 v16;
  int v17;

  v17 = 0;
  v16 = 0u;
  v15 = 0u;
  v14[0] = a3;
  v14[1] = a4;
  appended = sbufAtom_appendCFTypeAtom(a1, a2, v14);
  v8 = appended;
  if ((_DWORD)appended != -12572 && a5 != 0 && (_DWORD)appended == 0)
  {
    v11 = *((_QWORD *)&v16 + 1);
    *a5 = *((_QWORD *)&v16 + 1);
    if (v11 == 8)
    {
      if (!a1 || (v12 = CFGetTypeID(a1), v12 != CFNullGetTypeID()))
        *a5 = 0;
    }
  }
  return v8;
}

uint64_t FigRemote_CreateCFTypeFromSerializedAtomDataBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, size_t a3, CFMutableArrayRef *a4)
{
  size_t DataLength;
  uint64_t result;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  int v12[2];

  *(_QWORD *)v12 = 0;
  if (!a4)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (!theBuffer)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (!CMBlockBufferGetDataLength(theBuffer))
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  DataLength = CMBlockBufferGetDataLength(theBuffer);
  if (!CMBlockBufferIsRangeContiguous(theBuffer, 0, DataLength))
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  lengthAtOffsetOut = 0;
  dataPointerOut = 0;
  CMBlockBufferGetDataPointer(theBuffer, a3, &lengthAtOffsetOut, 0, &dataPointerOut);
  result = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (!(_DWORD)result)
  {
    result = figReadNEAtomHeader((uint64_t)dataPointerOut, 0, lengthAtOffsetOut, &v12[1], v12);
    if (!(_DWORD)result)
    {
      if (lengthAtOffsetOut < v12[0])
        return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      else
        return sbufAtom_copyCFTypeFromAtom(a1, v12[1], (UInt8 *)dataPointerOut + 8, v12[0] - 8, a4);
    }
  }
  return result;
}

uint64_t sbufAtom_copyCFTypeFromAtom(CFAllocatorRef alloc, int a2, UInt8 *bytes, unint64_t numBytes, CFMutableArrayRef *a5)
{
  CFIndex CFPropertyListFromData;
  CFNumberType v8;
  __CFArray *v9;
  const __CFString *v11;
  const __CFString *v12;
  CFTypeRef *v13;
  const __CFData *v14;
  const __CFData *v15;
  UInt8 *BytePtr;
  CFIndex Length;
  CGColorSpaceRef v18;
  uint64_t v19;
  CFPropertyListRef plist[2];

  plist[1] = *(CFPropertyListRef *)MEMORY[0x1E0C80C00];
  if (a2 <= 1685349749)
  {
    if (a2 > 1668051570)
    {
      if (a2 == 1668051571)
      {
        plist[0] = 0;
        if (a5)
        {
          v14 = CFDataCreate(alloc, bytes, numBytes);
          if (v14)
          {
            v15 = v14;
            BytePtr = (UInt8 *)CFDataGetBytePtr(v14);
            Length = CFDataGetLength(v15);
            CFPropertyListFromData = FigCreateCFPropertyListFromData(BytePtr, Length, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], plist);
            if (!(_DWORD)CFPropertyListFromData)
            {
              v18 = (CGColorSpaceRef)plist[0];
              if (plist[0])
                v18 = CGColorSpaceCreateWithPropertyList(plist[0]);
              *a5 = v18;
            }
            CFRelease(v15);
            if (plist[0])
              CFRelease(plist[0]);
          }
          else
          {
            CFPropertyListFromData = 0;
            *a5 = 0;
          }
          return CFPropertyListFromData;
        }
        return 4294954516;
      }
      if (a2 != 1684108406)
      {
        if (a2 == 1684628340)
          return sbufAtom_copyDictionaryFromAtom(alloc, bytes, numBytes, a5);
        goto LABEL_50;
      }
      if (a5)
      {
        v9 = CFDataCreate(alloc, bytes, numBytes);
        goto LABEL_47;
      }
      return 4294954516;
    }
    if (a2 == 1634886009)
      return sbufAtom_copyArrayFromAtom(alloc, (uint64_t)bytes, numBytes, a5);
    if (a2 != 1651862646)
      goto LABEL_50;
    CFPropertyListFromData = 4294954516;
    if (numBytes != 1 || !a5)
      return CFPropertyListFromData;
    v13 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
    if (!*bytes)
      v13 = (CFTypeRef *)MEMORY[0x1E0C9AE40];
LABEL_44:
    v9 = (__CFArray *)CFRetain(*v13);
    goto LABEL_47;
  }
  if (a2 <= 1853189227)
  {
    if (a2 != 1685349750)
    {
      if (a2 == 1717859171)
        return sbufAtom_copyFormatDescriptionFromAtom(alloc, bytes, numBytes, a5);
      if (a2 == 1852662390)
      {
        CFPropertyListFromData = 4294954516;
        if (!numBytes || !a5)
          return CFPropertyListFromData;
        if (numBytes >= 0xA)
          return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
        v8 = (unint64_t)*bytes;
        if ((v8 - 18) <= 0xFFFFFFEE)
          return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
        __memcpy_chk();
        v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v8, plist);
        goto LABEL_47;
      }
      goto LABEL_50;
    }
    CFPropertyListFromData = 4294954516;
    if (numBytes != 8 || !a5)
      return CFPropertyListFromData;
    v9 = CFDateCreate(alloc, *(CFAbsoluteTime *)bytes);
LABEL_47:
    CFPropertyListFromData = 0;
    *a5 = v9;
    return CFPropertyListFromData;
  }
  switch(a2)
  {
    case 1853189228:
      v13 = (CFTypeRef *)MEMORY[0x1E0C9B0D0];
      goto LABEL_44;
    case 1937011318:
      if (a5)
      {
        v9 = (__CFArray *)CFStringCreateWithBytes(alloc, bytes, numBytes, 0x8000100u, 0);
        goto LABEL_47;
      }
      return 4294954516;
    case 1970433142:
      if (a5)
      {
        v11 = CFStringCreateWithBytes(alloc, bytes, numBytes, 0x8000100u, 0);
        if (v11)
        {
          v12 = v11;
          *a5 = CFURLCreateWithString(alloc, v11, 0);
          CFRelease(v12);
          return 0;
        }
        v19 = 4294954510;
        return FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
      }
      return 4294954516;
  }
LABEL_50:
  v19 = 4294954516;
  return FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
}

uint64_t FigRemote_GetKnownNeroKeysForLightningAdapters()
{
  FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (FigRemote_GetKnownNeroKeysForLightningAdapters_onceToken != -1)
    dispatch_once(&FigRemote_GetKnownNeroKeysForLightningAdapters_onceToken, &__block_literal_global_45);
  return FigRemote_GetKnownNeroKeysForLightningAdapters_neroKeys;
}

uint64_t FigRemote_GetAllKnownSerializationKeys()
{
  FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  return sKnownSBufKeysArray;
}

CFIndex FigRemote_WriteSerializedAtomDataForCFType(__CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  CFIndex result;

  if (!a1)
    return 4294954516;
  result = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if (!(_DWORD)result)
    return sbufAtom_createSerializedDataWithFlagsForCFType(a1, a2, a3, a4, a5);
  return result;
}

uint64_t FigRemote_CreateCFTypeFromSerializedAtomData(const __CFAllocator *a1, uint64_t a2, unint64_t a3, CFTypeRef *a4)
{
  uint64_t v4;
  uint64_t NEAtomHeader;
  CFTypeRef cf;
  int v12[2];

  cf = 0;
  v4 = 4294954516;
  if (!a2 || !a4)
    return v4;
  NEAtomHeader = FigThreadRunOnce(&sKnownSBufKeysInit, sbufAtom_InitializeKnownKeys);
  if ((_DWORD)NEAtomHeader)
    return NEAtomHeader;
  *(_QWORD *)v12 = 0;
  NEAtomHeader = figReadNEAtomHeader(a2, 0, a3, &v12[1], v12);
  if ((_DWORD)NEAtomHeader)
    return NEAtomHeader;
  if (v12[0] <= a3)
  {
    v4 = sbufAtom_copyCFTypeFromAtom(a1, v12[1], (UInt8 *)(a2 + 8), a3 - 8, (CFMutableArrayRef *)&cf);
    if ((_DWORD)v4)
    {
      if (cf)
        CFRelease(cf);
    }
    else
    {
      *a4 = cf;
    }
    return v4;
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigNEAtomWriterBeginAtom(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  if (!*(_BYTE *)(a1 + 48))
  {
    if (*(_QWORD *)a1)
    {
      v2 = *(_QWORD *)(a1 + 24);
      if ((unint64_t)(v2 + 8) > *(_QWORD *)(a1 + 8))
        return 4294954724;
      *(_QWORD *)(*(_QWORD *)a1 + v2) = a2 << 32;
    }
    v3 = 0;
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a1 + 24) + 8;
    *(_QWORD *)(a1 + 40) = 8;
    *(_BYTE *)(a1 + 48) = 1;
    return v3;
  }
  return FigSignalErrorAt(4294954725, 0, 0, 0, 0, 0, 0);
}

const __CFDictionary *sbufAtom_appendFormatDescriptionAtomGuts(const opaqueCMFormatDescription *a1, uint64_t *a2)
{
  const __CFDictionary *result;
  FourCharCode *p_MediaSubType;
  size_t v6;
  uint64_t v7;
  const AudioStreamBasicDescription *StreamBasicDescription;
  const AudioChannelLayout *ChannelLayout;
  FourCharCode *MagicCookie;
  int v11;
  CMTime v12;
  uint32_t FrameQuanta;
  uint64_t v14;
  size_t v15;
  size_t sizeOut;
  FourCharCode MediaSubType;
  CMVideoDimensions Dimensions;
  signed int MediaType;

  Dimensions = 0;
  MediaSubType = 0;
  v15 = 0;
  sizeOut = 0;
  v14 = 0;
  FrameQuanta = 0;
  memset(&v12, 0, sizeof(v12));
  MediaType = CMFormatDescriptionGetMediaType(a1);
  result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock(&MediaType, 4uLL, 1835297121, a2);
  if (!(_DWORD)result)
  {
    if (MediaType <= 1935832171)
    {
      if (MediaType <= 1835365472)
      {
        if (MediaType <= 1668310897)
        {
          if (MediaType != 1635088502)
            goto LABEL_15;
          goto LABEL_27;
        }
        if (MediaType == 1668310898)
        {
          HIDWORD(v14) = CMFormatDescriptionGetMediaSubType(a1);
          p_MediaSubType = (FourCharCode *)&v14 + 1;
          v6 = 4;
          v7 = 1667330151;
          goto LABEL_34;
        }
        goto LABEL_15;
      }
      if (MediaType <= 1885564004)
        goto LABEL_15;
      v11 = 1885954932;
LABEL_26:
      if (MediaType == v11)
      {
LABEL_27:
        Dimensions = CMVideoFormatDescriptionGetDimensions(a1);
        MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
        result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock(&Dimensions, 8uLL, 1986292077, a2);
        if ((_DWORD)result)
          return result;
        p_MediaSubType = &MediaSubType;
        v6 = 4;
        v7 = 1668244579;
        goto LABEL_34;
      }
LABEL_15:
      HIDWORD(v14) = CMFormatDescriptionGetMediaSubType(a1);
      p_MediaSubType = (FourCharCode *)&v14 + 1;
      v6 = 4;
      v7 = 1836283234;
      goto LABEL_34;
    }
    if (MediaType > 1952606065)
    {
      if (MediaType <= 1953325923)
        goto LABEL_15;
      if (MediaType != 1953325924)
      {
        v11 = 1986618469;
        goto LABEL_26;
      }
      HIDWORD(v14) = CMFormatDescriptionGetMediaSubType(a1);
      LODWORD(v14) = CMTimeCodeFormatDescriptionGetTimeCodeFlags(a1);
      FrameQuanta = CMTimeCodeFormatDescriptionGetFrameQuanta(a1);
      CMTimeCodeFormatDescriptionGetFrameDuration(&v12, a1);
      result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock((char *)&v14 + 4, 4uLL, 1836283234, a2);
      if (!(_DWORD)result)
      {
        result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock(&v14, 4uLL, 1952671335, a2);
        if (!(_DWORD)result)
        {
          result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock(&FrameQuanta, 4uLL, 1903518062, a2);
          if (!(_DWORD)result)
          {
            p_MediaSubType = (FourCharCode *)&v12;
            v6 = 24;
            v7 = 1717859698;
            goto LABEL_34;
          }
        }
      }
    }
    else
    {
      if (MediaType != 1936684398)
        goto LABEL_15;
      StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(a1);
      ChannelLayout = CMAudioFormatDescriptionGetChannelLayout(a1, &sizeOut);
      MagicCookie = (FourCharCode *)CMAudioFormatDescriptionGetMagicCookie(a1, &v15);
      result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock(StreamBasicDescription, 0x28uLL, 1634951780, a2);
      if (!(_DWORD)result)
      {
        if (!ChannelLayout
          || !sizeOut
          || (result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock(ChannelLayout, sizeOut, 1667788396, a2), !(_DWORD)result))
        {
          if (!MagicCookie || (v6 = v15) == 0)
          {
LABEL_35:
            result = CMFormatDescriptionGetExtensions(a1);
            if (result)
              return (const __CFDictionary *)sbufAtom_appendDictionaryAtom(result, 1, 1702392942, a2);
            return result;
          }
          p_MediaSubType = MagicCookie;
          v7 = 1668639593;
LABEL_34:
          result = (const __CFDictionary *)sbufAtom_appendAtomWithMemoryBlock(p_MediaSubType, v6, v7, a2);
          if ((_DWORD)result)
            return result;
          goto LABEL_35;
        }
      }
    }
  }
  return result;
}

uint64_t FigNEAtomWriterEndAtom(uint64_t a1)
{
  unint64_t v2;
  uint64_t result;
  uint64_t v4;

  if (*(_BYTE *)(a1 + 48))
  {
    v2 = *(_QWORD *)(a1 + 40);
    if (HIDWORD(v2))
    {
      result = FigSignalErrorAt(4294954724, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      if (*(_QWORD *)a1)
      {
        *(_DWORD *)(*(_QWORD *)a1 + *(_QWORD *)(a1 + 24)) = v2;
        v2 = *(_QWORD *)(a1 + 40);
      }
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        *(_QWORD *)(v4 + 40) += v2;
        v2 = *(_QWORD *)(a1 + 40);
      }
      result = 0;
      *(_QWORD *)(a1 + 24) += v2;
    }
  }
  else
  {
    result = 0;
  }
  *(_BYTE *)(a1 + 48) = 0;
  return result;
}

uint64_t sbufAtom_appendAtomWithMemoryBlock(const void *a1, size_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  int64x2_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;

  v6 = a4[1];
  v9.i64[0] = *a4;
  v9.i64[1] = v6;
  v7 = a4[5] + a4[3];
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v10 = a4;
  v11 = v7;
  result = FigNEAtomWriterBeginAtom((uint64_t)&v9, a3);
  if (!(_DWORD)result)
  {
    result = FigNEAtomWriterAppendData(&v9, a1, a2);
    if (!(_DWORD)result)
      return FigNEAtomWriterEndAtom((uint64_t)&v9);
  }
  return result;
}

uint64_t sbufAtom_appendDictionaryAtom(const __CFDictionary *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  CFIndex Count;
  uint64_t v9;
  uint64_t v10;
  const void **v11;
  __CFString **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t appended;
  const void **v18;
  uint64_t v19;
  const __CFString *v20;
  CFTypeID v21;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  int v26;

  v26 = 0;
  v24 = 0u;
  v25 = 0u;
  v23 = 0u;
  Count = CFDictionaryGetCount(a1);
  v9 = Count;
  if ((a2 & 2) != 0 || Count >= 1)
  {
    v25 = 0uLL;
    v26 = 0;
    v13 = a4[1];
    *(_QWORD *)&v23 = *a4;
    *((_QWORD *)&v23 + 1) = v13;
    v14 = a4[5] + a4[3];
    *(_QWORD *)&v24 = a4;
    *((_QWORD *)&v24 + 1) = v14;
    v15 = FigNEAtomWriterBeginAtom((uint64_t)&v23, a3);
    if ((_DWORD)v15)
    {
      v10 = v15;
      goto LABEL_4;
    }
    if (v9 < 1)
    {
      v11 = 0;
      v12 = 0;
LABEL_19:
      appended = FigNEAtomWriterEndAtom((uint64_t)&v23);
      goto LABEL_20;
    }
    if ((unint64_t)v9 >> 61)
    {
      v11 = 0;
      v12 = 0;
    }
    else
    {
      v11 = (const void **)malloc_type_malloc(8 * v9, 0xD1AAB5CuLL);
      v18 = (const void **)malloc_type_malloc(8 * v9, 0xD1AAB5CuLL);
      v12 = (__CFString **)v18;
      if (v11 && v18)
      {
        CFDictionaryGetKeysAndValues(a1, v11, v18);
        v19 = 0;
        while (1)
        {
          v20 = (const __CFString *)v11[v19];
          if (!v20)
            break;
          v21 = CFGetTypeID(v11[v19]);
          if (v21 != CFStringGetTypeID())
            break;
          appended = sbufAtom_appendKeyValuePairAtom(v20, a2, v12[v19], (uint64_t *)&v23);
          if ((_DWORD)appended)
            goto LABEL_20;
          if (v9 == ++v19)
            goto LABEL_19;
        }
        v16 = 4294954516;
        goto LABEL_10;
      }
    }
    v16 = 4294954510;
LABEL_10:
    appended = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
LABEL_20:
    v10 = appended;
    goto LABEL_21;
  }
  v10 = 0;
LABEL_4:
  v11 = 0;
  v12 = 0;
LABEL_21:
  free(v11);
  free(v12);
  return v10;
}

uint64_t FigNEAtomWriterAppendData(int64x2_t *a1, const void *a2, size_t __n)
{
  unint64_t v5;
  uint64_t v6;
  uint64_t result;

  if (!a1[3].i8[0])
    return FigSignalErrorAt(4294954726, 0, 0, 0, 0, 0, 0);
  if (!__n)
    return 0;
  v5 = a1->u64[1];
  if (v5)
  {
    v6 = a1[2].i64[0];
    if (v6 + __n > v5)
      return 4294954724;
    if (a2)
      memcpy((void *)(a1->i64[0] + v6), a2, __n);
  }
  result = 0;
  a1[2] = vaddq_s64(a1[2], vdupq_n_s64(__n));
  return result;
}

uint64_t sbufAtom_appendKeyValuePairAtom(const __CFString *a1, uint64_t a2, __CFString *a3, uint64_t *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  const void *v10;
  uint64_t v11[6];
  int v12;
  __int16 v13;

  v7 = a4[1];
  v11[0] = *a4;
  v11[1] = v7;
  v8 = a4[5] + a4[3];
  v10 = 0;
  v11[4] = 0;
  v11[5] = 0;
  v12 = 0;
  v11[2] = (uint64_t)a4;
  v11[3] = v8;
  result = FigNEAtomWriterBeginAtom((uint64_t)v11, 1801812342);
  if (!(_DWORD)result)
  {
    if ((a2 & 1) != 0
      && CFDictionaryGetValueIfPresent((CFDictionaryRef)sKnownSBufKeysDictionary, a1, &v10)
      && v10 != (const void *)-1)
    {
      v13 = (__int16)v10;
      result = sbufAtom_appendAtomWithMemoryBlock(&v13, 2uLL, 1768192107, v11);
      if ((_DWORD)result)
        return result;
    }
    else
    {
      result = sbufAtom_appendStringAtom(a1, 1937011307, v11);
      if ((_DWORD)result)
        return result;
    }
    result = sbufAtom_appendCFTypeAtom(a3, a2, v11);
    if (!(_DWORD)result)
      return FigNEAtomWriterEndAtom((uint64_t)v11);
  }
  return result;
}

uint64_t sbufAtom_appendStringAtom(const __CFString *a1, uint64_t a2, uint64_t *a3)
{
  CFIndex Length;
  void *v7;
  uint64_t v8;
  uint64_t appended;
  CFIndex maxBufLen;
  CFRange v12;
  CFRange v13;

  maxBufLen = 0;
  if (a1)
  {
    Length = CFStringGetLength(a1);
    v12.location = 0;
    v12.length = Length;
    CFStringGetBytes(a1, v12, 0x8000100u, 0x3Fu, 0, 0, 0, &maxBufLen);
    if (*a3)
    {
      v7 = malloc_type_malloc(maxBufLen, 0x3378FC8EuLL);
      if (!v7)
      {
        appended = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
        goto LABEL_9;
      }
      v13.location = 0;
      v13.length = Length;
      if (CFStringGetBytes(a1, v13, 0x8000100u, 0x3Fu, 0, (UInt8 *)v7, maxBufLen, &maxBufLen) != Length)
      {
        v8 = 4294954724;
LABEL_10:
        free(v7);
        return v8;
      }
    }
    else
    {
      v7 = 0;
    }
    appended = sbufAtom_appendAtomWithMemoryBlock(v7, maxBufLen, a2, a3);
LABEL_9:
    v8 = appended;
    goto LABEL_10;
  }
  return 0;
}

CFIndex sbufAtom_appendCFTypeAtom(__CFString *a1, uint64_t a2, uint64_t *a3)
{
  CFTypeID v6;
  CFIndex result;
  uint64_t v8;
  uint64_t v9;
  CFNumberType Type;
  size_t ByteSize;
  char v12;
  int64x2_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  char valuePtr[8];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v6 = CFGetTypeID(a1);
  if (v6 == CFArrayGetTypeID())
    return sbufAtom_appendArrayAtom((const __CFArray *)a1, a2, 1634886009, a3);
  if (v6 == CFDictionaryGetTypeID())
    return sbufAtom_appendDictionaryAtom(a1, a2, 1684628340, a3);
  if (v6 == CFNumberGetTypeID())
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v8 = a3[1];
    v13.i64[0] = *a3;
    v13.i64[1] = v8;
    v9 = a3[5] + a3[3];
    v14 = a3;
    v15 = v9;
    result = FigNEAtomWriterBeginAtom((uint64_t)&v13, 1852662390);
    if (!(_DWORD)result)
    {
      Type = CFNumberGetType((CFNumberRef)a1);
      ByteSize = CFNumberGetByteSize((CFNumberRef)a1);
      if (*a3)
        CFNumberGetValue((CFNumberRef)a1, Type, valuePtr);
      v12 = Type;
      result = FigNEAtomWriterAppendData(&v13, &v12, 1uLL);
      if (!(_DWORD)result)
      {
        result = FigNEAtomWriterAppendData(&v13, valuePtr, ByteSize);
        if (!(_DWORD)result)
          return FigNEAtomWriterEndAtom((uint64_t)&v13);
      }
    }
  }
  else if (v6 == CFBooleanGetTypeID())
  {
    v13.i8[0] = CFBooleanGetValue((CFBooleanRef)a1);
    return sbufAtom_appendAtomWithMemoryBlock(&v13, 1uLL, 1651862646, a3);
  }
  else if (v6 == CFStringGetTypeID())
  {
    return sbufAtom_appendStringAtom(a1, 1937011318, a3);
  }
  else if (v6 == CFDataGetTypeID())
  {
    return sbufAtom_appendDataAtom((const __CFData *)a1, 1684108406, a3);
  }
  else if (v6 == CFDateGetTypeID())
  {
    return sbufAtom_appendDateAtom((uint64_t)a1, a3);
  }
  else if (v6 == CGColorSpaceGetTypeID())
  {
    return sbufAtom_appendColorSpaceAtom((CGColorSpace *)a1, a3);
  }
  else if (v6 == CFURLGetTypeID())
  {
    return sbufAtom_appendURLAtom((const __CFURL *)a1, a3);
  }
  else if (v6 == CMFormatDescriptionGetTypeID())
  {
    return sbufAtom_appendFormatDescriptionAtom((uint64_t)a1, a3);
  }
  else if (v6 == CFNullGetTypeID())
  {
    return sbufAtom_appendAtomWithMemoryBlock(0, 0, 1853189228, a3);
  }
  else
  {
    return 4294954516;
  }
  return result;
}

uint64_t sbufAtom_appendArrayAtom(const __CFArray *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  CFIndex Count;
  CFIndex v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  CFIndex v13;
  const void *ValueAtIndex;
  _QWORD v15[6];
  int v16;

  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return 0;
  v9 = Count;
  v15[4] = 0;
  v15[5] = 0;
  v16 = 0;
  v10 = a4[1];
  v15[0] = *a4;
  v15[1] = v10;
  v11 = a4[5] + a4[3];
  v15[2] = a4;
  v15[3] = v11;
  result = FigNEAtomWriterBeginAtom((uint64_t)v15, a3);
  if (!(_DWORD)result)
  {
    v13 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v13);
      result = sbufAtom_appendCFTypeAtom(ValueAtIndex, a2, v15);
      if ((_DWORD)result)
        break;
      if (v9 == ++v13)
        return FigNEAtomWriterEndAtom((uint64_t)v15);
    }
  }
  return result;
}

uint64_t sbufAtom_appendDataAtom(const __CFData *a1, uint64_t a2, uint64_t *a3)
{
  CFIndex Length;
  size_t v7;
  const UInt8 *BytePtr;
  void *v9;
  void *v10;
  uint64_t appended;
  UInt8 *v12;
  CFRange v14;

  Length = CFDataGetLength(a1);
  if (Length >= 1)
  {
    v7 = Length;
    if (*a3)
    {
      BytePtr = CFDataGetBytePtr(a1);
      if (!BytePtr)
      {
        v12 = (UInt8 *)malloc_type_malloc(v7, 0x50EC236uLL);
        if (!v12)
        {
          appended = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
          v10 = 0;
          goto LABEL_11;
        }
        v9 = v12;
        v14.location = 0;
        v14.length = v7;
        CFDataGetBytes(a1, v14, v12);
        v10 = v9;
        goto LABEL_10;
      }
      v9 = (void *)BytePtr;
    }
    else
    {
      v9 = 0;
    }
    v10 = 0;
LABEL_10:
    appended = sbufAtom_appendAtomWithMemoryBlock(v9, v7, a2, a3);
    goto LABEL_11;
  }
  v10 = 0;
  appended = 0;
LABEL_11:
  free(v10);
  return appended;
}

uint64_t sbufAtom_appendDateAtom(uint64_t a1, uint64_t *a2)
{
  double v4;

  v4 = MEMORY[0x193FFAC60]();
  return sbufAtom_appendAtomWithMemoryBlock(&v4, 8uLL, 1685349750, a2);
}

CFIndex sbufAtom_appendColorSpaceAtom(CGColorSpace *a1, uint64_t *a2)
{
  CFPropertyListRef v3;
  CFIndex CFDataFromCFPropertyList;
  BOOL v5;
  CFTypeRef cf;

  cf = 0;
  v3 = CGColorSpaceCopyPropertyList(a1);
  CFDataFromCFPropertyList = FigCreateCFDataFromCFPropertyList(v3, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFDataRef *)&cf);
  if ((_DWORD)CFDataFromCFPropertyList)
    v5 = 1;
  else
    v5 = cf == 0;
  if (!v5)
    CFDataFromCFPropertyList = sbufAtom_appendDataAtom((const __CFData *)cf, 1668051571, a2);
  if (v3)
    CFRelease(v3);
  if (cf)
    CFRelease(cf);
  return CFDataFromCFPropertyList;
}

uint64_t sbufAtom_appendURLAtom(const __CFURL *a1, uint64_t *a2)
{
  const __CFURL *v3;
  const __CFURL *v4;
  const __CFString *v5;
  uint64_t appended;
  uint64_t v7;

  v3 = CFURLCopyAbsoluteURL(a1);
  if (!v3)
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  v4 = v3;
  v5 = CFURLGetString(v3);
  if (v5)
    appended = sbufAtom_appendStringAtom(v5, 1970433142, a2);
  else
    appended = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v7 = appended;
  CFRelease(v4);
  return v7;
}

uint64_t sbufAtom_appendFormatDescriptionAtom(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  _QWORD v6[6];
  int v7;

  v6[4] = 0;
  v6[5] = 0;
  v7 = 0;
  v3 = a2[1];
  v6[0] = *a2;
  v6[1] = v3;
  v4 = a2[5] + a2[3];
  v6[2] = a2;
  v6[3] = v4;
  result = FigNEAtomWriterBeginAtom((uint64_t)v6, 1717859171);
  if (!(_DWORD)result)
  {
    result = sbufAtom_appendFormatDescriptionAtomGuts(a1, v6);
    if (!(_DWORD)result)
      return FigNEAtomWriterEndAtom((uint64_t)v6);
  }
  return result;
}

uint64_t sbufAtom_copyDictionaryFromAtom(const __CFAllocator *a1, uint64_t a2, unint64_t a3, __CFDictionary **a4)
{
  CFIndex v8;
  unint64_t v9;
  uint64_t v10;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  const void *v17;
  BOOL v18;
  uint64_t v20;
  uint64_t v22;
  CFTypeRef cf;
  const void *v24;
  uint64_t v25;

  if (!a4)
  {
    v22 = 4294954516;
    return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
  }
  v25 = 0;
  v8 = 0;
  if (a3)
  {
    v9 = 0;
    while (1)
    {
      v10 = figReadNEAtomHeader(a2, v9, a3, (_DWORD *)&v25 + 1, &v25);
      if ((_DWORD)v10)
        return v10;
      if (HIDWORD(v25) != 1801812342)
        break;
      ++v8;
      v9 += v25;
      if (v9 >= a3)
        goto LABEL_7;
    }
    v22 = 4294954516;
    return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
  }
LABEL_7:
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v8, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    v22 = 4294954510;
    return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
  }
  v12 = Mutable;
  if (v8 && a3)
  {
    v13 = 0;
    while (1)
    {
      cf = 0;
      v24 = 0;
      v14 = figReadNEAtomHeader(a2, v13, a3, (_DWORD *)&v25 + 1, &v25);
      if ((_DWORD)v14)
        break;
      v15 = v25;
      v16 = sbufAtom_copyKeyValuePairFromAtom(a1, a2 + 8 + v13, v25 - 8, &v24, &cf);
      v17 = v24;
      if (v24)
        v18 = cf == 0;
      else
        v18 = 1;
      if (!v18 && v16 == 0)
      {
        CFDictionaryAddValue(v12, v24, cf);
        v17 = v24;
      }
      if (v17)
        CFRelease(v17);
      if (cf)
        CFRelease(cf);
      v13 += v15;
      if (v13 >= a3)
        goto LABEL_26;
    }
    v20 = v14;
    CFRelease(v12);
  }
  else
  {
LABEL_26:
    v20 = 0;
    *a4 = v12;
  }
  return v20;
}

CMItemCount sbufAtom_appendNumSamples(opaqueCMSampleBuffer *a1, uint64_t *a2)
{
  CMItemCount result;
  int v4;

  result = CMSampleBufferGetNumSamples(a1);
  v4 = result;
  if ((_DWORD)result)
    return sbufAtom_appendAtomWithMemoryBlock(&v4, 4uLL, 1853058416, a2);
  return result;
}

uint64_t sbufAtom_appendSampleSizes(opaqueCMSampleBuffer *a1, int a2, uint64_t *a3, CMItemCount *a4)
{
  uint64_t SampleSizeArray;
  OpaqueCMBlockBuffer *DataBuffer;
  CMItemCount NumSamples;
  size_t *v11;
  uint64_t appended;
  void *v13;
  const opaqueCMFormatDescription *FormatDescription;
  CMMediaType MediaType;
  char v16;
  unint64_t v17;
  size_t *v18;
  uint64_t v19;
  size_t *v21;
  uint64_t v22;
  size_t v23;
  malloc_type_id_t v24;
  void *v25;
  uint64_t v26;
  size_t DataLength;
  CMItemCount sizeArrayEntriesNeededOut;

  DataLength = 0;
  sizeArrayEntriesNeededOut = 0;
  SampleSizeArray = CMSampleBufferGetSampleSizeArray(a1, 0, 0, &sizeArrayEntriesNeededOut);
  if ((_DWORD)SampleSizeArray != -12735)
  {
    if ((_DWORD)SampleSizeArray)
    {
LABEL_31:
      appended = FigSignalErrorAt(SampleSizeArray, 0, 0, 0, 0, 0, 0);
      goto LABEL_26;
    }
    v16 = 1;
LABEL_14:
    v17 = sizeArrayEntriesNeededOut;
    if (a4)
      *a4 = sizeArrayEntriesNeededOut;
    if (!v17 || !*a3)
    {
      v11 = 0;
      v13 = 0;
      goto LABEL_24;
    }
    if (v17 == 1)
    {
      if ((v16 & 1) != 0)
      {
        v18 = &DataLength;
        v19 = CMSampleBufferGetSampleSizeArray(a1, 1, &DataLength, &sizeArrayEntriesNeededOut);
        v11 = 0;
        if ((_DWORD)v19)
        {
          appended = v19;
          goto LABEL_22;
        }
      }
      else
      {
        v11 = 0;
        v18 = &DataLength;
      }
LABEL_36:
      if (sizeArrayEntriesNeededOut)
      {
        if ((unint64_t)sizeArrayEntriesNeededOut >> 62)
        {
LABEL_38:
          v22 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
          goto LABEL_39;
        }
        v23 = 4 * sizeArrayEntriesNeededOut;
        v24 = 219851612;
      }
      else
      {
        v23 = 0;
        v24 = 754892075;
      }
      v25 = malloc_type_malloc(v23, v24);
      v13 = v25;
      if (!v25)
        goto LABEL_38;
      v17 = sizeArrayEntriesNeededOut;
      if (sizeArrayEntriesNeededOut >= 1)
      {
        v26 = 0;
        do
        {
          *((_DWORD *)v25 + v26) = v18[v26];
          ++v26;
        }
        while (v17 != v26);
      }
LABEL_24:
      appended = sbufAtom_appendAtomWithMemoryBlock(v13, 4 * v17, 1936943482, a3);
      goto LABEL_28;
    }
    if (!(v17 >> 61))
    {
      v21 = (size_t *)malloc_type_malloc(8 * v17, 0xD1AAB5CuLL);
      if (v21)
      {
        v11 = v21;
        v22 = CMSampleBufferGetSampleSizeArray(a1, sizeArrayEntriesNeededOut, v21, &sizeArrayEntriesNeededOut);
        if ((_DWORD)v22)
        {
LABEL_39:
          appended = v22;
          goto LABEL_27;
        }
        v18 = v11;
        goto LABEL_36;
      }
    }
    SampleSizeArray = 4294954510;
    goto LABEL_31;
  }
  if (!a2)
  {
LABEL_25:
    appended = 0;
LABEL_26:
    v11 = 0;
LABEL_27:
    v13 = 0;
    goto LABEL_28;
  }
  DataBuffer = CMSampleBufferGetDataBuffer(a1);
  NumSamples = CMSampleBufferGetNumSamples(a1);
  v11 = 0;
  appended = 0;
  if (!DataBuffer)
  {
LABEL_22:
    v13 = 0;
    goto LABEL_28;
  }
  v13 = 0;
  if (NumSamples == 1)
  {
    FormatDescription = CMSampleBufferGetFormatDescription(a1);
    if (FormatDescription)
    {
      MediaType = CMFormatDescriptionGetMediaType(FormatDescription);
      if (MediaType == 1635088502 || MediaType == 1986618469 || MediaType == 1885954932)
      {
        DataLength = CMBlockBufferGetDataLength(DataBuffer);
        sizeArrayEntriesNeededOut = 1;
        if (sbufAtom_appendSampleSizes_sSBufAtomAppendSampleSizes_MissingSampleSizeForVideo_InitOnce != -1)
          dispatch_once_f(&sbufAtom_appendSampleSizes_sSBufAtomAppendSampleSizes_MissingSampleSizeForVideo_InitOnce, 0, (dispatch_function_t)sbufAtomAppendSampleSizes_MissingSampleSizes_LogOnce);
        v16 = 0;
        goto LABEL_14;
      }
    }
    goto LABEL_25;
  }
LABEL_28:
  free(v11);
  free(v13);
  return appended;
}

uint64_t sbufAtom_appendPacketDescriptions(opaqueCMSampleBuffer *a1, uint64_t *a2)
{
  uint64_t result;
  CMItemCount NumSamples;
  size_t v6;
  AudioStreamPacketDescription *packetDescriptionsPointerOut;

  v6 = 0;
  packetDescriptionsPointerOut = 0;
  result = CMSampleBufferGetAudioStreamPacketDescriptionsPtr(a1, (const AudioStreamPacketDescription **)&packetDescriptionsPointerOut, &v6);
  if (!(_DWORD)result && v6)
  {
    NumSamples = CMSampleBufferGetNumSamples(a1);
    if (NumSamples == v6 >> 4)
      return sbufAtom_appendAtomWithMemoryBlock(packetDescriptionsPointerOut, v6, 1885631331, a2);
    else
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t sbufAtom_appendTagCollection(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  CFIndex Count;
  CFIndex v7;
  uint64_t v8;
  CFMutableArrayRef Mutable;
  __CFArray *v10;
  uint64_t v11;
  uint64_t TagCollectionAtIndex;
  const void *v13;
  const void *v14;
  uint64_t appended;
  uint64_t v16;
  uint64_t v18;

  Count = FigTaggedBufferGroupGetCount();
  if (Count <= 0)
  {
    v18 = 4294954516;
    return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
  }
  v7 = Count;
  v8 = *MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    v18 = 4294954510;
    return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
  }
  v10 = Mutable;
  v11 = 0;
  while (1)
  {
    TagCollectionAtIndex = FigTaggedBufferGroupGetTagCollectionAtIndex(a1, v11);
    if (!TagCollectionAtIndex)
      break;
    v13 = (const void *)FigTagCollectionCopyAsData(TagCollectionAtIndex, v8);
    if (!v13)
      break;
    v14 = v13;
    CFArrayAppendValue(v10, v13);
    CFRelease(v14);
    if (v7 == ++v11)
    {
      appended = sbufAtom_appendArrayAtom(v10, a2, 1952673644, a3);
      goto LABEL_8;
    }
  }
  appended = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
LABEL_8:
  v16 = appended;
  CFRelease(v10);
  return v16;
}

void sbufAtomAppendSampleSizes_MissingSampleSizes_LogOnce()
{
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    sbufAtomAppendSampleSizes_MissingSampleSizes_LogOnce_cold_1();
  FigLogBacktrace();
}

uint64_t sbufAtom_copyArrayFromAtom(const __CFAllocator *a1, uint64_t a2, unint64_t a3, CFMutableArrayRef *a4)
{
  CFIndex v8;
  unint64_t v9;
  uint64_t NEAtomHeader;
  CFMutableArrayRef Mutable;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int v17[2];

  if (!a4)
    return 4294954516;
  if (a3)
  {
    v8 = 0;
    v9 = 0;
    *(_QWORD *)v17 = 0;
    do
    {
      NEAtomHeader = figReadNEAtomHeader(a2, v9, a3, &v17[1], v17);
      if ((_DWORD)NEAtomHeader)
        return NEAtomHeader;
      ++v8;
      v9 += v17[0];
    }
    while (v9 < a3);
    Mutable = CFArrayCreateMutable(a1, v8, MEMORY[0x1E0C9B378]);
    v12 = 0;
    while (1)
    {
      v13 = figReadNEAtomHeader(a2, v12, a3, &v17[1], v17);
      if ((_DWORD)v13)
        break;
      v14 = v12 + v17[0];
      if (v14 > a3)
      {
        v13 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
        break;
      }
      v13 = sbufAtom_copyCFTypeFromAtom(a1, v17[1], (UInt8 *)(a2 + 8 + v12), v17[0] - 8);
      if ((_DWORD)v13)
        break;
      v12 = v14;
      if (v14 >= a3)
        goto LABEL_13;
    }
    v15 = v13;
    if (Mutable)
      CFRelease(Mutable);
  }
  else
  {
    Mutable = 0;
LABEL_13:
    v15 = 0;
    *a4 = Mutable;
  }
  return v15;
}

void *__getFigCPECryptorCreateCryptorFromSerializedRecipeSymbolLoc_block_invoke(uint64_t a1)
{
  void *v2;
  void *result;
  void *v4;

  if (MediaToolboxLibraryCore_frameworkLibrary_1)
  {
    v2 = (void *)MediaToolboxLibraryCore_frameworkLibrary_1;
  }
  else
  {
    MediaToolboxLibraryCore_frameworkLibrary_1 = _sl_dlopen();
    v2 = (void *)MediaToolboxLibraryCore_frameworkLibrary_1;
    if (!MediaToolboxLibraryCore_frameworkLibrary_1)
    {
      v4 = (void *)abort_report_np();
      free(v4);
    }
  }
  result = dlsym(v2, "FigCPECryptorCreateCryptorFromSerializedRecipe");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  getFigCPECryptorCreateCryptorFromSerializedRecipeSymbolLoc_ptr = *(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)
                                                                                + 24);
  return result;
}

void CopyEntry(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

uint64_t FigVirtualCaptureCardGetClassID()
{
  FigThreadRunOnce(&FigVirtualCaptureCardGetClassID_sRegisterFigVirtualCaptureCardBaseTypeOnce, (void (*)(void))RegisterFigVirtualCaptureCardBaseType);
  return sFigVirtualCaptureCardClassID;
}

uint64_t RegisterFigVirtualCaptureCardBaseType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigVirtualCaptureCardClassDesc, ClassID, 1, &sFigVirtualCaptureCardClassID);
}

uint64_t FigVirtualCaptureCardGetTypeID()
{
  FigThreadRunOnce(&FigVirtualCaptureCardGetClassID_sRegisterFigVirtualCaptureCardBaseTypeOnce, (void (*)(void))RegisterFigVirtualCaptureCardBaseType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigVirtualCaptureCardClassID);
}

CFStringRef FigVirtualCaptureCardCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigVirtualCaptureCard %p]"), a1);
}

uint64_t FigTaggedBufferGroupFormatDescriptionRegister()
{
  return FigThreadRunOnce(&sFigTaggedBufferGroupFormatDescriptionRegisterOnce, (void (*)(void))FigTaggedBufferGroupFormatDescriptionRegisterOnce);
}

uint64_t FigTaggedBufferGroupFormatDescriptionRegisterOnce()
{
  int v1;
  uint64_t v2;
  BOOL (*v3)(uint64_t, uint64_t);
  __CFString *(*v4)(const void *);
  void (*v5)(uint64_t);

  v1 = 0;
  v2 = 16;
  v4 = figTaggedBufferGroupFormatDescriptionCopyDebugDesc;
  v5 = figTaggedBufferGroupFormatDescriptionFinalize;
  v3 = figTaggedBufferGroupFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x74626772u, (__int128 *)&v1);
}

uint64_t FigTaggedBufferGroupFormatDescriptionCreate(const __CFAllocator *a1, int a2, CFTypeRef *a3)
{
  uint64_t v6;
  CFTypeRef cf;

  cf = 0;
  if (!a3)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  FigThreadRunOnce(&sFigTaggedBufferGroupFormatDescriptionRegisterOnce, (void (*)(void))FigTaggedBufferGroupFormatDescriptionRegisterOnce);
  v6 = FigDerivedFormatDescriptionCreate(a1, (void *)0x74626772, a2, 0, (uint64_t *)&cf);
  if ((_DWORD)v6)
  {
    if (cf)
      CFRelease(cf);
  }
  else
  {
    *(_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf) = a2;
    *a3 = cf;
  }
  return v6;
}

OSStatus CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroup(CFAllocatorRef allocator, CMTaggedBufferGroupRef taggedBufferGroup, CMTaggedBufferGroupFormatDescriptionRef *formatDescriptionOut)
{
  OSStatus v6;
  uint64_t DerivedStorage;
  CFMutableArrayRef Mutable;
  __CFArray *v9;
  CMItemCount v10;
  CMTagCollectionRef TagCollectionAtIndex;
  OSStatus v12;
  CFTypeRef cf;

  cf = 0;
  if (!formatDescriptionOut)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  FigThreadRunOnce(&sFigTaggedBufferGroupFormatDescriptionRegisterOnce, (void (*)(void))FigTaggedBufferGroupFormatDescriptionRegisterOnce);
  v6 = FigDerivedFormatDescriptionCreate(allocator, (void *)0x74626772, 1952606066, 0, (uint64_t *)&cf);
  if (!v6)
  {
    DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf);
    *(_DWORD *)DerivedStorage = 1952606066;
    Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      v9 = Mutable;
      if (CMTaggedBufferGroupGetCount(taggedBufferGroup) >= 1)
      {
        v10 = 0;
        do
        {
          TagCollectionAtIndex = CMTaggedBufferGroupGetTagCollectionAtIndex(taggedBufferGroup, v10);
          CFArrayAppendValue(v9, TagCollectionAtIndex);
          ++v10;
        }
        while (v10 < CMTaggedBufferGroupGetCount(taggedBufferGroup));
      }
      *(_QWORD *)(DerivedStorage + 8) = CFRetain(v9);
      *formatDescriptionOut = (CMTaggedBufferGroupFormatDescriptionRef)cf;
      cf = 0;
      CFRelease(v9);
      v12 = 0;
      goto LABEL_8;
    }
    v6 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  v12 = v6;
LABEL_8:
  if (cf)
    CFRelease(cf);
  return v12;
}

Boolean CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup(CMTaggedBufferGroupFormatDescriptionRef desc, CMTaggedBufferGroupRef taggedBufferGroup)
{
  CMTaggedBufferGroupFormatDescriptionRef v2;
  CFMutableArrayRef Mutable;
  __CFArray *v5;
  CMItemCount v6;
  CMTagCollectionRef TagCollectionAtIndex;
  uint64_t DerivedStorage;
  uint64_t v9;

  v2 = desc;
  if (!desc)
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return v2;
  }
  if (!taggedBufferGroup)
  {
    v9 = 4294954586;
LABEL_11:
    FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
    LOBYTE(v2) = 0;
    return v2;
  }
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    v9 = 4294954510;
    goto LABEL_11;
  }
  v5 = Mutable;
  if (CMTaggedBufferGroupGetCount(taggedBufferGroup) >= 1)
  {
    v6 = 0;
    do
    {
      TagCollectionAtIndex = CMTaggedBufferGroupGetTagCollectionAtIndex(taggedBufferGroup, v6);
      CFArrayAppendValue(v5, TagCollectionAtIndex);
      ++v6;
    }
    while (v6 < CMTaggedBufferGroupGetCount(taggedBufferGroup));
  }
  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)v2);
  LOBYTE(v2) = *(_DWORD *)DerivedStorage == 1952606066
            && compareTagCollections(v5, *(const __CFArray **)(DerivedStorage + 8)) != 0;
  CFRelease(v5);
  return v2;
}

uint64_t compareTagCollections(CFArrayRef theArray, const __CFArray *a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  CFIndex v7;
  const void *ValueAtIndex;
  CFIndex v9;
  CFIndex v10;
  const void *v11;
  CFIndex v12;

  if (theArray)
  {
    Count = CFArrayGetCount(theArray);
    if (a2)
    {
LABEL_3:
      v5 = CFArrayGetCount(a2);
      goto LABEL_6;
    }
  }
  else
  {
    Count = 0;
    if (a2)
      goto LABEL_3;
  }
  v5 = 0;
LABEL_6:
  if (Count != v5)
    return 0;
  for (i = 0; ; ++i)
  {
    v7 = theArray ? CFArrayGetCount(theArray) : 0;
    if (i >= v7)
      break;
    ValueAtIndex = FigCFArrayGetValueAtIndex(theArray, i);
    v9 = 0;
    if (a2)
    {
LABEL_13:
      v10 = CFArrayGetCount(a2);
      goto LABEL_15;
    }
    while (1)
    {
      v10 = 0;
LABEL_15:
      if (v9 >= v10)
        break;
      v11 = FigCFArrayGetValueAtIndex(a2, v9);
      if (CFEqual(ValueAtIndex, v11))
        break;
      ++v9;
      if (a2)
        goto LABEL_13;
    }
    if (a2)
      v12 = CFArrayGetCount(a2);
    else
      v12 = 0;
    if (v12 == v9)
      return 0;
  }
  return 1;
}

void figTaggedBufferGroupFormatDescriptionFinalize(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(FigDerivedFormatDescriptionGetDerivedStorage(a1) + 8);
  if (v1)
    CFRelease(v1);
}

__CFString *figTaggedBufferGroupFormatDescriptionCopyDebugDesc(const void *a1)
{
  _DWORD *DerivedStorage;
  const __CFAllocator *v3;
  __CFString *Mutable;

  DerivedStorage = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  v3 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v3, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("\t\tsubType: '%c%c%c%c'"), HIBYTE(*DerivedStorage), BYTE2(*DerivedStorage), BYTE1(*DerivedStorage), *DerivedStorage);
  return Mutable;
}

BOOL figTaggedBufferGroupFormatDescriptionEqual(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t v4;

  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage(a1);
  v4 = FigDerivedFormatDescriptionGetDerivedStorage(a2);
  return *(_DWORD *)DerivedStorage == *(_DWORD *)v4
      && compareTagCollections(*(CFArrayRef *)(DerivedStorage + 8), *(const __CFArray **)(v4 + 8));
}

uint64_t FigEndpointRemoteControlSessionStartServer()
{
  CFMutableDictionaryRef Mutable;
  uint64_t v1;
  _OWORD v3[3];

  v3[0] = xmmword_1E28E3BA0;
  memset(&v3[1], 0, 32);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetInt32(Mutable, CFSTR("xpcServerOption_SelfTerminationTimeout"), 30);
  v1 = FigXPCServerStart((uint64_t)"com.apple.coremedia.endpointremotecontrolsession.xpc", (uint64_t)v3, (uint64_t)Mutable, &gEndpointRemoteControlSessionServer);
  if (Mutable)
    CFRelease(Mutable);
  return v1;
}

uint64_t HandleEndpointRemoteControlSessionRemoteMessage(_xpc_connection_s *a1, void *a2)
{
  uint64_t OpCode;
  uint64_t uint64;
  uint64_t v6;
  CFTypeID v7;
  CFTypeRef v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t (*v11)(CFTypeRef, void (*)(uint64_t, const void *, const void *, uint64_t), uint64_t);
  void (*v12)(uint64_t, const void *, const void *, uint64_t);
  CFTypeRef v13;
  uint64_t v14;
  uint64_t (*v15)(CFTypeRef);
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  CFTypeRef v22;
  uint64_t (*v23)(CFTypeRef, CFTypeRef, void (*)(int, const void *, uint64_t), _QWORD *);
  uint64_t v25;
  int v26;
  CFTypeRef cf;

  v26 = 0;
  v25 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v26);
  if ((_DWORD)OpCode)
    return OpCode;
  uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  cf = 0;
  v6 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, &v25);
  if (!(_DWORD)v6)
  {
    if (cf)
    {
      v7 = CFGetTypeID(cf);
      if (v7 == FigEndpointRemoteControlSessionGetTypeID())
      {
        v8 = cf;
        goto LABEL_6;
      }
    }
    v6 = FigSignalErrorAt(4294949866, 0, 0, 0, 0, 0, 0);
  }
  v9 = v6;
  if (cf)
    CFRelease(cf);
  if (!(_DWORD)v9)
  {
    v8 = 0;
LABEL_6:
    v9 = 4294949866;
    if (v26 <= 1936614508)
    {
      switch(v26)
      {
        case 1667593832:
          v11 = *(uint64_t (**)(CFTypeRef, void (*)(uint64_t, const void *, const void *, uint64_t), uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v8) + 16) + 16);
          if (v11)
          {
            v13 = v8;
            v12 = 0;
            v14 = 0;
            goto LABEL_19;
          }
          break;
        case 1685024621:
          v16 = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
          goto LABEL_29;
        case 1936029288:
          v10 = v25;
          *(_QWORD *)(v10 + 24) = xpc_dictionary_get_uint64(a2, ".objectID");
          FigXPCRelease(*(xpc_object_t *)(v10 + 32));
          *(_QWORD *)(v10 + 32) = FigXPCRetain(a1);
          v11 = *(uint64_t (**)(CFTypeRef, void (*)(uint64_t, const void *, const void *, uint64_t), uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v8) + 16) + 16);
          if (v11)
          {
            v12 = HandleEventCallback_0;
            v13 = v8;
            v14 = v10;
LABEL_19:
            v16 = v11(v13, v12, v14);
LABEL_29:
            v9 = v16;
            goto LABEL_35;
          }
          break;
        default:
          goto LABEL_35;
      }
LABEL_30:
      v9 = 4294954514;
LABEL_35:
      if (v8)
        CFRelease(v8);
      return v9;
    }
    if (v26 != 1936614509)
    {
      if (v26 == 1937011316)
      {
        v15 = *(uint64_t (**)(CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v8) + 16) + 32);
        if (!v15)
          goto LABEL_30;
      }
      else
      {
        if (v26 != 1953653870)
          goto LABEL_35;
        v15 = *(uint64_t (**)(CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v8) + 16) + 24);
        if (!v15)
          goto LABEL_30;
      }
      v16 = v15(v8);
      goto LABEL_29;
    }
    cf = 0;
    v17 = FigXPCMessageCopyCFData(a2, "Params", &cf);
    if ((_DWORD)v17)
      goto LABEL_26;
    v18 = xpc_dictionary_get_uint64(a2, "CompletionID");
    if (v18)
    {
      v19 = v18;
      v20 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
      if (v20)
      {
        v21 = v20;
        *v20 = v19;
        v20[1] = xpc_dictionary_get_uint64(a2, ".objectID");
        v21[2] = FigXPCRetain(a1);
        v22 = cf;
        v23 = *(uint64_t (**)(CFTypeRef, CFTypeRef, void (*)(int, const void *, uint64_t), _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v8) + 16) + 8);
        if (v23)
        {
          v17 = v23(v8, v22, SendMessageCompletionCallback, v21);
LABEL_26:
          v9 = v17;
          goto LABEL_33;
        }
        v9 = 4294954514;
      }
      else
      {
        v9 = 4294949865;
        FigSignalErrorAt(4294949865, 0, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      v9 = 4294949865;
    }
LABEL_33:
    if (cf)
      CFRelease(cf);
    goto LABEL_35;
  }
  return v9;
}

uint64_t FigXPCEndpointRemoteControlSessionServerAssociateNeighborFigEndpointRemoteControlSession(_xpc_connection_s *a1, const void *a2, _QWORD *a3)
{
  uint64_t SessionEventHandlerState;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v10;

  v10 = 0;
  SessionEventHandlerState = CreateSessionEventHandlerState(a2, (uint64_t *)&v10);
  v7 = v10;
  if ((_DWORD)SessionEventHandlerState)
  {
    v8 = SessionEventHandlerState;
    goto LABEL_3;
  }
  v8 = FigXPCServerAssociateObjectWithNeighborProcess(gEndpointRemoteControlSessionServer, a1, a2, (uint64_t)v10, (uint64_t)DisposeSessionEventHandlerState_0, 0, a3);
  if ((_DWORD)v8)
LABEL_3:
    DisposeSessionEventHandlerState_0(v7);
  return v8;
}

uint64_t CreateSessionEventHandlerState(const void *a1, uint64_t *a2)
{
  uint64_t Instance;
  uint64_t v5;
  uint64_t result;

  if (sRegisterFigEndpointRemoteControlSessionEventHandlerStateTypeOnce != -1)
    dispatch_once_f(&sRegisterFigEndpointRemoteControlSessionEventHandlerStateTypeOnce, 0, (dispatch_function_t)RegisterFigEndpointRemoteControlSessionEventHandlerStateType);
  Instance = _CFRuntimeCreateInstance();
  v5 = Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = a1;
    if (a1)
      CFRetain(a1);
    result = 0;
  }
  else
  {
    result = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  *a2 = v5;
  return result;
}

void DisposeSessionEventHandlerState_0(_QWORD *cf)
{
  uint64_t v2;
  void (*v3)(uint64_t, _QWORD, _QWORD);

  if (cf)
  {
    v2 = cf[2];
    if (v2)
    {
      v3 = *(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(cf[2]) + 16) + 16);
      if (v3)
        v3(v2, 0, 0);
    }
    CFRelease(cf);
  }
}

uint64_t FigXPCEndpointRemoteControlSessionServerAssociateCopiedNeighborRemoteControlSession(_xpc_connection_s *a1, const void *a2, _QWORD *a3)
{
  uint64_t SessionEventHandlerState;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v10;

  v10 = 0;
  SessionEventHandlerState = CreateSessionEventHandlerState(a2, (uint64_t *)&v10);
  v7 = v10;
  if ((_DWORD)SessionEventHandlerState)
  {
    v8 = SessionEventHandlerState;
    goto LABEL_3;
  }
  v8 = FigXPCServerAssociateCopiedObjectWithNeighborProcess(gEndpointRemoteControlSessionServer, a1, a2, (uint64_t)v10, (uint64_t)DisposeSessionEventHandlerState_0, 0, a3);
  if ((_DWORD)v8)
LABEL_3:
    DisposeSessionEventHandlerState_0(v7);
  return v8;
}

void SendMessageCompletionCallback(int a1, const void *a2, uint64_t a3)
{
  xpc_object_t xdict;

  xdict = 0;
  if (a3 && !FigXPCCreateBasicMessage(0x63616C62u, *(_QWORD *)(a3 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(_QWORD *)a3);
    xpc_dictionary_set_int64(xdict, "ResponseStatus", a1);
    FigXPCMessageSetCFObject(xdict, "ResponseParams", a2);
    xpc_connection_send_message(*(xpc_connection_t *)(a3 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a3);
  FigXPCRelease(xdict);
}

void HandleEventCallback_0(uint64_t a1, const void *a2, const void *a3, uint64_t a4)
{
  int v7;
  xpc_object_t v8;
  xpc_object_t message;

  message = 0;
  if (a4)
  {
    v7 = FigXPCCreateBasicMessage(0x65686362u, *(_QWORD *)(a4 + 24), &message);
    v8 = message;
    if (!v7)
    {
      FigXPCMessageSetCFString(message, "EventType", a2);
      FigXPCMessageSetCFData(message, "EventPayload", a3);
      xpc_connection_send_message(*(xpc_connection_t *)(a4 + 32), message);
      v8 = message;
    }
  }
  else
  {
    v8 = 0;
  }
  FigXPCRelease(v8);
}

uint64_t RegisterFigEndpointRemoteControlSessionEventHandlerStateType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigEndpointRemoteControlSessionEventHandlerStateID = result;
  return result;
}

_QWORD *figEndpointRemoteControlSessionEventHandlerStateInit(_QWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void figEndpointRemoteControlSessionEventHandlerStateFinalize(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
    CFRelease(v2);
  FigXPCRelease(*(xpc_object_t *)(a1 + 32));
  *(_QWORD *)(a1 + 32) = 0;
}

const __CFString *figEndpointRemoteControlSessionEventHandlerStateCopyFormattingDesc()
{
  return CFSTR("[FigEndpointRemoteControlSessionEventHandlerState]");
}

__CFString *figEndpointRemoteControlSessionEventHandlerStateCopyDebugDesc(_QWORD *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigEndpointRemoteControlSessionEventHandlerState %p> for objectID %16llx"), a1, a1[3]);
  return Mutable;
}

void *FigCopyCommonMemoryPool()
{
  void *v0;
  __CFDictionary *Mutable;

  if (sFigCommonMemoryPool != -1)
    dispatch_once_f(&sFigCommonMemoryPool, 0, (dispatch_function_t)fig_initializeCommonMemoryPoolManagement);
  FigSimpleMutexLock((pthread_mutex_t *)qword_1ECDA8A90);
  v0 = FigCFWeakReferenceLoadAndRetain(&qword_1ECDA8A98);
  if (!v0)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(Mutable, CFSTR("FigMemoryPool_LoggingName"), CFSTR("CommonMemoryPool"));
    v0 = CMMemoryPoolCreate(Mutable);
    if (Mutable)
      CFRelease(Mutable);
    FigCFWeakReferenceStore(&qword_1ECDA8A98, v0);
  }
  FigSimpleMutexUnlock((pthread_mutex_t *)qword_1ECDA8A90);
  return v0;
}

pthread_mutex_t *fig_initializeCommonMemoryPoolManagement()
{
  pthread_mutex_t *result;

  result = FigSimpleMutexCreate();
  qword_1ECDA8A90 = (uint64_t)result;
  return result;
}

void FigCommonMemoryPoolReleaseAndClear(const void **a1)
{
  const void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      CFRelease(v2);
      *a1 = 0;
    }
  }
}

uint64_t FigCustomURLHandlerServerEnsure()
{
  if (FigCustomURLHandlerServerEnsure_sFigCustomURLHandlerServerOnce != -1)
    dispatch_once(&FigCustomURLHandlerServerEnsure_sFigCustomURLHandlerServerOnce, &__block_literal_global_46);
  return FigCustomURLHandlerServerEnsure_sFigCustomURLHandlerStartError;
}

uint64_t FigCustomURLHandlerServerCopyXPCEndpoint(_QWORD *a1)
{
  return FigXPCServerCopyXPCEndpoint(gFigCustomURLHandlerServer, a1);
}

uint64_t FigCustomURLHandlerConfirmNeighborProcessByPID(int a1)
{
  return FigXPCServerConfirmNeighborProcessByPID(gFigCustomURLHandlerServer, a1);
}

uint64_t FigCustomURLHandlerServerAssociateObjectByPID(int a1, const void *a2, _QWORD *a3)
{
  return FigCustomURLHandlerServerAssociateObjectAndContentKeySessionByPID(a1, a2, 0, a3);
}

uint64_t FigCustomURLHandlerServerAssociateObjectAndContentKeySessionByPID(int a1, const void *a2, const void *a3, _QWORD *a4)
{
  _QWORD *v8;
  CFTypeRef v9;
  const void *v10;
  uint64_t v11;
  uint64_t v13;

  v13 = 0;
  v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
  v8[1] = FigOSTransactionCreate("FigCustomURLHandler", 0, 0, 0);
  if (a3)
  {
    v9 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)a3);
    if (!v9)
      return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    a3 = v9;
    v10 = (const void *)v8[2];
    v8[2] = v9;
    CFRetain(v9);
    if (v10)
      CFRelease(v10);
  }
  v11 = FigXPCServerAssociateObjectWithNeighborProcessByPID(gFigCustomURLHandlerServer, a1, a2, (uint64_t)v8, (uint64_t)figCustomURLHandlerServer_disposeCompanion, 0, &v13);
  if (!(_DWORD)v11)
    *a4 = v13;
  if (a3)
    CFRelease(a3);
  return v11;
}

void figCustomURLHandlerServer_disposeCompanion(const void **a1)
{
  const void *v2;
  void *v3;
  const void *v4;

  v2 = *a1;
  if (v2)
  {
    CFRelease(v2);
    *a1 = 0;
  }
  v3 = (void *)a1[1];
  if (v3)
  {
    os_release(v3);
    a1[1] = 0;
  }
  v4 = a1[2];
  if (v4)
    CFRelease(v4);
  free(a1);
}

uint64_t figCustomURLHandlerServer_handleRemoteMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t OpCode;
  uint64_t uint64;
  CFTypeID v8;
  CFTypeRef v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t MutableCopy;
  CFAllocatorRef *v13;
  uint64_t v14;
  id *v15;
  id *v16;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  CFTypeRef *v21;
  void *v22;
  uint64_t CryptorID;
  uint64_t v24;
  uint64_t v25;
  const void *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  const __CFAllocator *v30;
  const UInt8 *v31;
  UInt8 *v32;
  CFDataRef v33;
  CFDataRef v34;
  uint64_t (*v35)(CFTypeRef, const void *, uint64_t, uint64_t, uint64_t, void (*)(uint64_t, uint64_t, const __CFDictionary *, OpaqueCMBlockBuffer *, unsigned int, __CFError *, const void *), intptr_t (*)(const __CFData *, char, int), CFDataRef);
  uint64_t v36;
  uint64_t *v38;
  CFTypeRef cf;
  int v40;
  os_log_type_t type[8];
  CFTypeRef v42;
  _BYTE v43[12];
  __int16 v44;
  int v45;
  CFTypeRef v46[18];

  v46[16] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  v40 = 0;
  v38 = 0;
  cf = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v40);
  if ((_DWORD)OpCode)
    goto LABEL_61;
  uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  OpCode = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, &v38);
  if ((_DWORD)OpCode)
    goto LABEL_61;
  if (!cf || (v8 = CFGetTypeID(cf), v8 != FigCustomURLHandlerGetTypeID()))
  {
    OpCode = FigSignalErrorAt(4294949926, 0, 0, 0, 0, 0, 0);
LABEL_61:
    v24 = OpCode;
    goto LABEL_57;
  }
  if (!*v38)
  {
    OpCode = FigCustomURLHandlerServerRequestingClientCreate(a1, uint64, v38);
    if ((_DWORD)OpCode)
      goto LABEL_61;
  }
  if (v40 == 1667778642)
  {
    v10 = v38;
    v9 = cf;
    v11 = xpc_dictionary_get_uint64(a2, "CustomURLHandler_RequestID");
    *(_QWORD *)type = 0;
    v42 = 0;
    MutableCopy = FigXPCMessageCopyCFDictionary(a2, "CustomURLHandler_RequestInfo", &v42);
    v13 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    if (!(_DWORD)MutableCopy)
    {
      if (v42)
      {
        v14 = *MEMORY[0x1E0C9AE00];
        MutableCopy = FigCustomURLRequestInfoCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (CFDictionaryRef)v42, (CFTypeRef *)type);
        if (!(_DWORD)MutableCopy)
        {
          v15 = (id *)v10[2];
          if (v15)
            v16 = FigCFWeakReferenceHolderCopyReferencedObject(v15);
          else
            v16 = 0;
          v22 = *(void **)type;
          v46[0] = 0;
          *(_QWORD *)v43 = 0;
          CryptorID = FigCustomURLRequestInfoGetCryptorID(*(uint64_t *)type, v43);
          if ((_DWORD)CryptorID == -17360)
          {
            v24 = 0;
          }
          else
          {
            v24 = CryptorID;
            if (!(_DWORD)CryptorID)
            {
              v25 = FigCPECryptorRemoteRetainCopiedCryptor(v14, *(const void **)v43, v46);
              if ((_DWORD)v25
                || (v25 = FigCustomURLRequestInfoSetCryptor((__CFDictionary *)v22, (void *)v46[0]), (_DWORD)v25))
              {
                v24 = v25;
              }
              else
              {
                v24 = FigCustomURLRequestInfoSetCryptorID(v22, 0);
                if (!(_DWORD)v24)
                  goto LABEL_26;
              }
              FigSignalErrorAt(v24, 0, 0, 0, 0, 0, 0);
            }
          }
LABEL_26:
          if (v46[0])
            CFRelease(v46[0]);
          if (!(_DWORD)v24)
          {
            v24 = FigCustomURLRequestInfoDeserializeNSSecureCodingTypes(*(const __CFDictionary **)type);
            if (!(_DWORD)v24)
            {
              v26 = *(const void **)type;
              *(_QWORD *)type = 0;
              if (!v16)
                goto LABEL_32;
              goto LABEL_31;
            }
          }
          v26 = 0;
          if (v16)
LABEL_31:
            CFRelease(v16);
LABEL_32:
          if (v42)
            CFRelease(v42);
          if (*(_QWORD *)type)
            CFRelease(*(CFTypeRef *)type);
          if ((_DWORD)v24 == -17378)
          {
            v27 = 0;
LABEL_53:
            xpc_dictionary_set_BOOL(a3, "CustomURLHandler_CanHandleResult", v27 != 0);
LABEL_54:
            v24 = 0;
            goto LABEL_55;
          }
          if ((_DWORD)v24)
            goto LABEL_55;
          v28 = *v10;
          if (!*v10)
            goto LABEL_54;
          v29 = gFigCustomURLHandlerServerCallbackQueue;
          if (handlerServerShimCompletionRec_getCFAllocator_sOnceToken != -1)
            dispatch_once_f(&handlerServerShimCompletionRec_getCFAllocator_sOnceToken, &handlerServerShimCompletionRec_getCFAllocator_sAllocator, (dispatch_function_t)handlerServerShimCompletionRec_initializeCFAllocatorOnce);
          v30 = (const __CFAllocator *)handlerServerShimCompletionRec_getCFAllocator_sAllocator;
          if (!handlerServerShimCompletionRec_getCFAllocator_sAllocator)
          {
            v24 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
            if ((_DWORD)v24)
              goto LABEL_55;
          }
          v31 = (const UInt8 *)malloc_type_calloc(1uLL, 0x10uLL, 0x102004075F474C6uLL);
          if (v31)
          {
            v32 = (UInt8 *)v31;
            v33 = CFDataCreateWithBytesNoCopy(*v13, v31, 16, v30);
            if (v33)
            {
              v34 = v33;
              *(_QWORD *)v32 = dispatch_semaphore_create(0);
              v32[8] = 0;
              *((_DWORD *)v32 + 3) = 0;
              v35 = *(uint64_t (**)(CFTypeRef, const void *, uint64_t, uint64_t, uint64_t, void (*)(uint64_t, uint64_t, const __CFDictionary *, OpaqueCMBlockBuffer *, unsigned int, __CFError *, const void *), intptr_t (*)(const __CFData *, char, int), CFDataRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v9) + 16) + 32);
              if (v35)
              {
                v36 = v35(v9, v26, v11, v28, v29, figCustomURLHandlerServer_shimDataCallback, figCustomURLHandlerServer_handleRequestShimCompletionHandler, v34);
                if ((_DWORD)v36)
                {
                  v24 = v36;
                  v27 = 0;
                }
                else
                {
                  dispatch_semaphore_wait(*(dispatch_semaphore_t *)v32, 0xFFFFFFFFFFFFFFFFLL);
                  v27 = v32[8];
                  v24 = *((unsigned int *)v32 + 3);
                }
              }
              else
              {
                v27 = 0;
                v24 = 4294954514;
              }
              CFRelease(v34);
              if (!(_DWORD)v24)
                goto LABEL_53;
              goto LABEL_55;
            }
            free(v32);
          }
          v24 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
          v27 = 0;
          if (!(_DWORD)v24)
            goto LABEL_53;
LABEL_55:
          if (v26)
            CFRelease(v26);
          goto LABEL_57;
        }
      }
      else
      {
        MutableCopy = FigSignalErrorAt(4294949926, 0, 0, 0, 0, 0, 0);
      }
    }
    v24 = MutableCopy;
    v26 = 0;
    goto LABEL_32;
  }
  if (dword_1ECDA84B8)
  {
    LODWORD(v42) = 0;
    type[0] = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84B0, 1, (int *)&v42, type);
    v18 = v42;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0]))
      v20 = v18;
    else
      v20 = v18 & 0xFFFFFFFE;
    if (v20)
    {
      *(_DWORD *)v43 = 136315394;
      *(_QWORD *)&v43[4] = "figCustomURLHandlerServer_handleRemoteMessage";
      v44 = 1024;
      v45 = v40;
      v21 = (CFTypeRef *)_os_log_send_and_compose_impl();
      LOBYTE(v18) = (_BYTE)v42;
    }
    else
    {
      v21 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84B0, 1u, 1, v21, v21 != v46, v18, 0, v19);
  }
  v24 = 0;
LABEL_57:
  if (cf)
    CFRelease(cf);
  return v24;
}

uint64_t figCustomURLHandlerServer_handleRemoteMessageNoReply(_xpc_connection_s *a1, void *a2)
{
  uint64_t OpCode;
  uint64_t uint64;
  CFTypeID v6;
  CFTypeRef v7;
  uint64_t v8;
  uint64_t (*v9)(CFTypeRef, uint64_t);
  uint64_t v10;
  uint64_t *v12;
  CFTypeRef cf;
  int v14;

  v14 = 0;
  v12 = 0;
  cf = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v14);
  if ((_DWORD)OpCode)
    goto LABEL_12;
  uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  OpCode = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, &v12);
  if ((_DWORD)OpCode)
    goto LABEL_12;
  if (!cf || (v6 = CFGetTypeID(cf), v6 != FigCustomURLHandlerGetTypeID()))
  {
    OpCode = FigSignalErrorAt(4294949926, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  if (!*v12)
  {
    OpCode = FigCustomURLHandlerServerRequestingClientCreate(a1, uint64, v12);
    if ((_DWORD)OpCode)
      goto LABEL_12;
  }
  if (v14 == 1667777641)
  {
    OpCode = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
    goto LABEL_12;
  }
  if (v14 == 1667777362)
  {
    v7 = cf;
    v8 = xpc_dictionary_get_uint64(a2, "CustomURLHandler_RequestID");
    v9 = *(uint64_t (**)(CFTypeRef, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v7) + 16) + 40);
    if (v9)
    {
      OpCode = v9(v7, v8);
LABEL_12:
      v10 = OpCode;
      goto LABEL_15;
    }
    v10 = 4294954514;
  }
  else
  {
    v10 = 0;
  }
LABEL_15:
  if (cf)
    CFRelease(cf);
  return v10;
}

uint64_t FigCustomURLHandlerServerRequestingClientCreate(void *a1, uint64_t a2, uint64_t *a3)
{
  const __CFAllocator *v6;
  uint64_t Instance;
  uint64_t v8;

  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (FigCustomURLHandlerServerRequestingClientGetTypeID_sFigCustomURLHandlerServerRequestingClientRegisterOnce != -1)
    dispatch_once(&FigCustomURLHandlerServerRequestingClientGetTypeID_sFigCustomURLHandlerServerRequestingClientRegisterOnce, &__block_literal_global_20);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  v8 = Instance;
  *(_QWORD *)(Instance + 16) = FigXPCRetain(a1);
  *(_QWORD *)(v8 + 24) = a2;
  *(_QWORD *)(v8 + 32) = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *a3 = v8;
  return 0;
}

double figCustomURLHandlerServerRequestingClient_init(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void figCustomURLHandlerServerRequestingClient_finalize(_QWORD *a1)
{
  void *v2;
  const void *v3;
  const void *v4;

  v2 = (void *)a1[2];
  if (v2)
  {
    a1[2] = 0;
    xpc_release(v2);
  }
  v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  v4 = (const void *)a1[5];
  if (v4)
  {
    CFRelease(v4);
    a1[5] = 0;
  }
}

void figCustomURLHandlerServer_shimDataCallback(uint64_t a1, uint64_t a2, const __CFDictionary *a3, OpaqueCMBlockBuffer *a4, unsigned int a5, __CFError *a6, const void *a7)
{
  const __CFAllocator *v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFTypeRef v16;
  int v17;
  int NSSecureCodingTypesSerializable;
  Boolean v19;
  xpc_object_t xdict;
  uint64_t valuePtr;
  CFTypeRef v22;
  CFTypeRef v23;
  CFTypeRef cf;

  xdict = 0;
  valuePtr = a2;
  v19 = 0;
  if (FigXPCCreateBasicMessage(0x63684443u, *(_QWORD *)(a1 + 24), &xdict))
    goto LABEL_34;
  v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v14 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
  if (!v14)
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_34:
    FigXPCRelease(xdict);
    return;
  }
  v15 = v14;
  xpc_dictionary_set_uint64(xdict, "CustomURLHandler_RequestID", valuePtr);
  FigCFDictionaryGetBooleanIfPresent(*(_QWORD *)(a1 + 32), v15, &v19);
  if (v19)
  {
    v16 = 0;
    goto LABEL_21;
  }
  v23 = 0;
  cf = 0;
  v22 = 0;
  v17 = FigCustomURLResponseInfoCopyRequestInfo(a3, &cf);
  if (v17
    || (v17 = FigCustomURLRequestInfoCreateMutableCopy(v13, (CFDictionaryRef)cf, &v23)) != 0
    || (v17 = FigCustomURLRequestInfoSetCryptor((__CFDictionary *)v23, 0)) != 0
    || (v17 = FigCustomURLResponseInfoCreateMutable(v13, v23, &v22)) != 0
    || (v17 = FigCustomURLResponseInfoSetAllValuesFromResponseInfo((void *)v22, a3)) != 0)
  {
    NSSecureCodingTypesSerializable = v17;
    goto LABEL_32;
  }
  NSSecureCodingTypesSerializable = FigCustomURLResponseInfoMakeNSSecureCodingTypesSerializable((void *)v22);
  if (NSSecureCodingTypesSerializable)
  {
LABEL_32:
    v16 = 0;
    goto LABEL_12;
  }
  v16 = v22;
  v22 = 0;
LABEL_12:
  if (cf)
    CFRelease(cf);
  if (v23)
    CFRelease(v23);
  if (v22)
    CFRelease(v22);
  if (NSSecureCodingTypesSerializable
    || FigXPCMessageSetCFDictionary(xdict, "CustomURLHandler_ResponseInfo", v16))
  {
    goto LABEL_27;
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v15, (const void *)*MEMORY[0x1E0C9AE50]);
LABEL_21:
  if ((a5 & 3) != 0)
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), v15);
  if (!FigXPCMessageSetBlockBuffer(xdict, "CustomURLHandler_BlockBuffer", a4))
  {
    xpc_dictionary_set_uint64(xdict, "CustomURLHandler_CallbackFlags", a5);
    if (!FigXPCMessageSetCFError(xdict, "CustomURLHandler_Error", a6)
      && !FigXPCMessageSetCFDictionary(xdict, "CustomURLHandler_FinalReport", a7))
    {
      xpc_connection_send_message(*(xpc_connection_t *)(a1 + 16), xdict);
    }
  }
LABEL_27:
  FigXPCRelease(xdict);
  if (v16)
    CFRelease(v16);
  CFRelease(v15);
}

intptr_t figCustomURLHandlerServer_handleRequestShimCompletionHandler(const __CFData *a1, char a2, int a3)
{
  const UInt8 *BytePtr;

  BytePtr = CFDataGetBytePtr(a1);
  *((_BYTE *)BytePtr + 8) = a2;
  *((_DWORD *)BytePtr + 3) = a3;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)BytePtr);
}

uint64_t handlerServerShimCompletionRec_initializeCFAllocatorOnce(_QWORD *a1)
{
  uint64_t result;
  CFTypeRef v3;

  v3 = 0;
  result = FigCreateCFAllocatorFigMallocWithDeallocCallback((void (__cdecl *)(void *, void *))handlerServerShimCompletionRec_dealloc, &v3);
  if (!(_DWORD)result)
    *a1 = v3;
  return result;
}

void handlerServerShimCompletionRec_dealloc(NSObject **a1)
{
  NSObject *v2;

  v2 = *a1;
  if (v2)
    dispatch_release(v2);
  free(a1);
}

uint64_t FigEndpointExtendedGetClassID()
{
  if (FigEndpointExtendedGetClassID_sRegisterFigEndpointExtendedBaseTypeOnce != -1)
    dispatch_once_f(&FigEndpointExtendedGetClassID_sRegisterFigEndpointExtendedBaseTypeOnce, &FigEndpointExtendedGetClassID_sFigEndpointExtendedClassID, (dispatch_function_t)FigEndpointExtendedGetClassIDCallback);
  return FigEndpointExtendedGetClassID_sFigEndpointExtendedClassID;
}

uint64_t FigEndpointExtendedGetClassIDCallback(_QWORD *a1)
{
  _QWORD *ClassID;

  ClassID = (_QWORD *)FigEndpointGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&FigEndpointExtendedGetClassIDCallback_sFigEndpointExtendedClassDesc, ClassID, 0, a1);
}

CFStringRef FigEndpointExtendedBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigEndpointExtended %p]"), a1);
}

uint64_t FigCaptionSerializerGetTypeID()
{
  FigThreadRunOnce(&sRegisterFigCaptionSerializerTypeOnce, (void (*)(void))RegisterFigCaptionSerializerType);
  return sFigCaptionSerializerID;
}

uint64_t RegisterFigCaptionSerializerType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigCaptionSerializerID = result;
  return result;
}

uint64_t FigCaptionSerializerCreate(uint64_t a1, void ***a2)
{
  uint64_t Instance;
  void **v4;
  CFMutableDictionaryRef Mutable;
  uint64_t v6;
  uint64_t v7;

  if (a2)
  {
    FigThreadRunOnce(&sRegisterFigCaptionSerializerTypeOnce, (void (*)(void))RegisterFigCaptionSerializerType);
    Instance = _CFRuntimeCreateInstance();
    if (!Instance)
    {
      FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      return 0;
    }
    v4 = (void **)Instance;
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v4[2] = Mutable;
    if (Mutable)
    {
      v6 = FigCFDictionarySetInt32(Mutable, CFSTR("FigCaptionSerializerVersion"), 1);
      if (!(_DWORD)v6)
      {
        v7 = FigCFDictionarySetInt32(v4[2], CFSTR("FigCaptionSerializerFormat"), 1);
        if (!(_DWORD)v7)
        {
          *a2 = v4;
          return v7;
        }
LABEL_12:
        CFRelease(v4);
        return v7;
      }
    }
    else
    {
      v6 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    }
    v7 = v6;
    goto LABEL_12;
  }
  return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionSerializerCopyProperty(uint64_t a1, CFTypeRef cf1, uint64_t a3, _QWORD *a4)
{
  const void *Value;
  const void *v8;

  if (!a1
    || !cf1
    || !a4
    || !CFEqual(cf1, CFSTR("FigCaptionSerializerVersion")) && !CFEqual(cf1, CFSTR("FigCaptionSerializerFormat")))
  {
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  }
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), cf1);
  v8 = Value;
  if (Value)
    CFRetain(Value);
  *a4 = v8;
  return 0;
}

uint64_t FigCaptionSerializerSetProperty(uint64_t a1, CFTypeRef cf1, const void *a3)
{
  if (!a1
    || !cf1
    || !a3
    || !CFEqual(cf1, CFSTR("FigCaptionSerializerVersion")) && !CFEqual(cf1, CFSTR("FigCaptionSerializerFormat")))
  {
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), cf1, a3);
  return 0;
}

uint64_t FigCaptionSerializerCreateCFDataFromCaptionGroup(uint64_t a1, uint64_t a2, CFMutableDataRef *a3)
{
  const __CFAllocator *v6;
  CFMutableArrayRef Mutable;
  CFIndex SliceCount;
  uint64_t v9;
  CFIndex v10;
  CFIndex v11;
  CFMutableArrayRef v12;
  const CFArrayCallBacks *v13;
  uint64_t appended;
  const void *CaptionData;
  uint64_t v16;
  uint64_t v17;
  CFPropertyListFormat v18;
  CFDataRef Data;
  CFStringRef v20;
  uint64_t Code;
  CFMutableDataRef v22;
  CFMutableDataRef v23;
  uint64_t WritableWithCFMutableData;
  uint64_t v25;
  uint64_t v26;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFMutableDataRef *v30;
  CFTypeRef cf;
  CFNumberRef v32;
  CFNumberRef v33;
  uint64_t v34;
  CFNumberRef number[2];
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  CFErrorRef error[2];
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  CFTypeRef valuePtr[2];

  cf = 0;
  if (!a1)
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  if (!a2 || !a3)
  {
    Code = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    Mutable = 0;
    goto LABEL_66;
  }
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    v16 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_80:
    Code = v16;
    goto LABEL_66;
  }
  v30 = a3;
  SliceCount = FigCaptionGroupGetSliceCount(a2);
  if (!SliceCount)
  {
    v12 = 0;
LABEL_20:
    error[0] = 0;
    number[0] = 0;
    LODWORD(valuePtr[0]) = 0;
    v17 = FigCaptionSerializerCopyProperty(a1, CFSTR("FigCaptionSerializerFormat"), v9, number);
    if ((_DWORD)v17)
    {
      Code = v17;
      Data = 0;
    }
    else
    {
      CFNumberGetValue(number[0], kCFNumberSInt32Type, valuePtr);
      if (LODWORD(valuePtr[0]) == 2)
        v18 = kCFPropertyListBinaryFormat_v1_0;
      else
        v18 = kCFPropertyListXMLFormat_v1_0;
      Data = CFPropertyListCreateData(v6, Mutable, v18, 0, error);
      if (Data)
      {
        if (!error[0])
        {
          Code = 0;
          goto LABEL_33;
        }
        v20 = CFErrorCopyFailureReason(error[0]);
        Code = CFErrorGetCode(error[0]);
        if (v20)
          CFRelease(v20);
      }
      else
      {
        Code = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
      }
    }
    if (error[0])
      CFRelease(error[0]);
    if (Data)
    {
      CFRelease(Data);
      Data = 0;
    }
LABEL_33:
    if (number[0])
      CFRelease(number[0]);
    if ((_DWORD)Code)
      goto LABEL_59;
    valuePtr[0] = 0;
    v42 = 0;
    v40 = 0u;
    v41 = 0u;
    *(_OWORD *)error = 0u;
    v38 = 0;
    v36 = 0u;
    v37 = 0u;
    *(_OWORD *)number = 0u;
    v33 = 0;
    v34 = 0;
    v32 = 0;
    if (Data)
    {
      v22 = CFDataCreateMutable(v6, 0);
      v23 = v22;
      if (!v22)
      {
        Code = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
        goto LABEL_51;
      }
      WritableWithCFMutableData = FigByteStreamCreateWritableWithCFMutableData(v22, 0, (uint64_t)v6, valuePtr);
      if ((_DWORD)WritableWithCFMutableData)
        goto LABEL_74;
      WritableWithCFMutableData = FigAtomWriterInitWithByteStream((uint64_t)valuePtr[0], (uint64_t)error);
      if ((_DWORD)WritableWithCFMutableData)
        goto LABEL_74;
      WritableWithCFMutableData = FigAtomWriterBeginAtom((uint64_t)error, 0x66637367u, 0);
      if ((_DWORD)WritableWithCFMutableData)
        goto LABEL_74;
      WritableWithCFMutableData = FigAtomWriterInitWithParent((uint64_t)error, (uint64_t)number);
      if ((_DWORD)WritableWithCFMutableData)
        goto LABEL_74;
      WritableWithCFMutableData = FigCaptionSerializerCopyProperty(a1, CFSTR("FigCaptionSerializerVersion"), v25, &v33);
      if ((_DWORD)WritableWithCFMutableData)
        goto LABEL_74;
      WritableWithCFMutableData = FigCaptionSerializerCopyProperty(a1, CFSTR("FigCaptionSerializerFormat"), v26, &v32);
      if ((_DWORD)WritableWithCFMutableData)
        goto LABEL_74;
      CFNumberGetValue(v33, kCFNumberSInt32Type, &v34);
      CFNumberGetValue(v32, kCFNumberSInt32Type, (char *)&v34 + 4);
      WritableWithCFMutableData = FigAtomWriterBeginAtom((uint64_t)number, 0x66637369u, 0);
      if ((_DWORD)WritableWithCFMutableData
        || (WritableWithCFMutableData = FigAtomWriterAppendData((uint64_t)number, (uint64_t)&v34, 8),
            (_DWORD)WritableWithCFMutableData)
        || (WritableWithCFMutableData = FigAtomWriterEndAtom((uint64_t)number), (_DWORD)WritableWithCFMutableData)
        || (WritableWithCFMutableData = FigAtomWriterBeginAtom((uint64_t)number, 0x66637364u, 0),
            (_DWORD)WritableWithCFMutableData)
        || (BytePtr = CFDataGetBytePtr(Data),
            Length = CFDataGetLength(Data),
            WritableWithCFMutableData = FigAtomWriterAppendData((uint64_t)number, (uint64_t)BytePtr, Length),
            (_DWORD)WritableWithCFMutableData)
        || (WritableWithCFMutableData = FigAtomWriterEndAtom((uint64_t)number), (_DWORD)WritableWithCFMutableData))
      {
LABEL_74:
        Code = WritableWithCFMutableData;
      }
      else
      {
        Code = FigAtomWriterEndAtom((uint64_t)error);
        if (!(_DWORD)Code)
        {
LABEL_51:
          if (v32)
            CFRelease(v32);
          if (v33)
            CFRelease(v33);
          if (valuePtr[0])
            CFRelease(valuePtr[0]);
          if ((_DWORD)Code)
          {
LABEL_60:
            if (Data)
              CFRelease(Data);
            if (v23)
              CFRelease(v23);
            if (!v12)
              goto LABEL_66;
            goto LABEL_65;
          }
          *v30 = v23;
LABEL_59:
          v23 = 0;
          goto LABEL_60;
        }
      }
      CFRelease(v23);
    }
    else
    {
      Code = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    }
    v23 = 0;
    goto LABEL_51;
  }
  v10 = SliceCount;
  v11 = 0;
  v12 = 0;
  v13 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  while (1)
  {
    if (v12)
      CFRelease(v12);
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
    v12 = CFArrayCreateMutable(v6, 0, v13);
    if (v12)
    {
      FigCaptionGroupGetDurationBeforeSlice(a2, v11, (uint64_t)error);
      *(_OWORD *)number = *(_OWORD *)error;
      *(_QWORD *)&v36 = v40;
      appended = FigCFArrayAppendCMTime(v12, (CMTime *)number);
      if ((_DWORD)appended
        || (FigCaptionGroupGetDurationAfterSlice(a2, v11, (uint64_t)number),
            *(_OWORD *)error = *(_OWORD *)number,
            *(_QWORD *)&v40 = v36,
            appended = FigCFArrayAppendCMTime(v12, (CMTime *)number),
            (_DWORD)appended))
      {
        Code = appended;
        goto LABEL_65;
      }
    }
    else
    {
      v16 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
      if ((_DWORD)v16)
        goto LABEL_80;
    }
    CaptionData = FigCaptionGroupGetCaptionData(a2, v11);
    if (!CaptionData)
      break;
    fcs_copyCaptionDataAsDictionary(CaptionData, (__CFDictionary **)&cf);
    CFDictionarySetValue((CFMutableDictionaryRef)cf, CFSTR("Durations"), v12);
    CFArrayAppendValue(Mutable, cf);
    if (v10 == ++v11)
      goto LABEL_20;
  }
  Code = 0;
  if (!v12)
    goto LABEL_66;
LABEL_65:
  CFRelease(v12);
LABEL_66:
  if (cf)
    CFRelease(cf);
  if (Mutable)
    CFRelease(Mutable);
  return Code;
}

uint64_t fcs_copyCaptionDataAsDictionary(const void *a1, __CFDictionary **a2)
{
  __CFDictionary **v2;
  uint64_t v3;
  uint64_t v4;
  CFMutableDictionaryRef Mutable;
  uint64_t CMBaseObject;
  uint64_t (*v7)(uint64_t, const __CFString *, const __CFAllocator *, CFArrayRef *);
  uint64_t v8;
  CFIndex Count;
  uint64_t (*v10)(uint64_t);
  const __CFString *v11;
  CFMutableDictionaryRef v12;
  CFMutableArrayRef v13;
  uint64_t v14;
  CFMutableDictionaryRef v15;
  const __CFDictionary *v16;
  const __CFDictionary *v17;
  CFIndex v18;
  CFMutableArrayRef v19;
  const __CFAllocator *v20;
  const void *ValueAtIndex;
  CFMutableArrayRef v22;
  uint64_t v23;
  uint64_t (*v24)(uint64_t, uint64_t, const void *, const __CFAllocator *, CFTypeRef *, uint64_t *);
  uint64_t v25;
  CFTypeID v26;
  CFIndex KeyFrameCount;
  CFIndex v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  CFMutableDictionaryRef v32;
  CFMutableDictionaryRef v33;
  CFMutableDictionaryRef v34;
  __CFDictionary *v35;
  uint64_t (*v36)(uint64_t);
  const __CFString *v37;
  __CFDictionary **v39;
  __CFDictionary *theDict;
  CFIndex v41;
  uint64_t v42;
  CFMutableArrayRef v43;
  CFIndex Length;
  const __CFAllocator *allocator;
  void *value;
  double v47;
  CFTypeRef cf;
  uint64_t v49;
  uint64_t v50;
  CFArrayRef theArray;
  CFMutableDictionaryRef v52;
  CFTypeRef v53;

  value = 0;
  if (!a1)
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  v2 = a2;
  if (!a2)
  {
    v4 = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    goto LABEL_97;
  }
  v3 = (uint64_t)a1;
  v4 = fcs_copyCaptionPropertiesAsDictionary(a1, (__CFArray *)&value);
  if ((_DWORD)v4)
  {
LABEL_97:
    v14 = v4;
    Mutable = 0;
    goto LABEL_87;
  }
  v52 = 0;
  v53 = 0;
  v50 = 0;
  theArray = 0;
  cf = 0;
  v49 = 0;
  v47 = 0.0;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    v14 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    v43 = 0;
    v12 = 0;
    v13 = 0;
    v15 = 0;
    goto LABEL_65;
  }
  CMBaseObject = FigCaptionDataGetCMBaseObject(v3);
  v7 = *(uint64_t (**)(uint64_t, const __CFString *, const __CFAllocator *, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                                                  + 48);
  if (!v7)
  {
    v43 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 4294954514;
    goto LABEL_11;
  }
  v8 = v7(CMBaseObject, CFSTR("StylePropertyKeysInUse"), allocator, &theArray);
  if ((_DWORD)v8)
  {
LABEL_102:
    v14 = v8;
    v43 = 0;
    v12 = 0;
    v13 = 0;
    goto LABEL_11;
  }
  Count = CFArrayGetCount(theArray);
  v10 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v3) + 16) + 8);
  if (v10)
  {
    v11 = (const __CFString *)v10(v3);
    if (!v11)
    {
      v43 = 0;
      v12 = 0;
      v13 = 0;
      v14 = 0;
LABEL_11:
      v15 = Mutable;
      Mutable = 0;
      goto LABEL_65;
    }
  }
  else
  {
    v11 = &stru_1E28E82E0;
  }
  FigThreadRunOnce(&fcs_getCaptionInfoToPListableMappingDictionary_sInitializeCaptionPropertyToPListableMappingOnce, fcs_initializeCaptionPropertyToPListableMappingDictionary);
  v16 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)sCaptionInfoToPListableMappingDictionary, CFSTR("StyleProperty"));
  if (!v16)
  {
    v8 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    goto LABEL_102;
  }
  v17 = v16;
  Length = CFStringGetLength(v11);
  if (!Count)
  {
    v43 = 0;
    v12 = 0;
    v13 = 0;
    v15 = 0;
    v14 = 0;
    goto LABEL_65;
  }
  v39 = v2;
  v18 = 0;
  v19 = 0;
  v12 = 0;
  v13 = 0;
  v42 = v3;
  v20 = allocator;
  theDict = Mutable;
  while (1)
  {
    v41 = v18;
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, v18);
    if (v19)
      CFRelease(v19);
    v22 = CFArrayCreateMutable(v20, 0, MEMORY[0x1E0C9B378]);
    if (!v22)
    {
      v14 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
      v43 = 0;
      v15 = Mutable;
LABEL_59:
      Mutable = 0;
      goto LABEL_60;
    }
    v43 = v22;
    if (Length)
      break;
LABEL_54:
    Mutable = theDict;
    v19 = v43;
    CFDictionarySetValue(theDict, ValueAtIndex, v43);
    v18 = v41 + 1;
    if (v41 + 1 == Count)
    {
      v15 = 0;
      v14 = 0;
LABEL_60:
      v2 = v39;
      goto LABEL_65;
    }
  }
  v23 = 0;
  while (1)
  {
    if (v53)
    {
      CFRelease(v53);
      v53 = 0;
    }
    v24 = *(uint64_t (**)(uint64_t, uint64_t, const void *, const __CFAllocator *, CFTypeRef *, uint64_t *))(*(_QWORD *)(CMBaseObjectGetVTable(v3) + 16) + 24);
    if (!v24)
    {
      v14 = 4294954514;
LABEL_58:
      v15 = theDict;
      goto LABEL_59;
    }
    v25 = v24(v3, v23, ValueAtIndex, v20, &v53, &v49);
    if ((_DWORD)v25)
      goto LABEL_94;
    if (!v53)
      goto LABEL_53;
    if (v12)
      CFRelease(v12);
    if (v13)
      CFRelease(v13);
    v12 = CFDictionaryCreateMutable(v20, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!v12)
    {
      v14 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
      v13 = 0;
      goto LABEL_58;
    }
    v13 = CFArrayCreateMutable(v20, 0, MEMORY[0x1E0C9B378]);
    if (!v13)
    {
      v25 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_94:
      v14 = v25;
      goto LABEL_58;
    }
    if (!v53 || (v26 = CFGetTypeID(v53), v26 != FigCaptionDynamicStyleGetTypeID()))
    {
      KeyFrameCount = 1;
LABEL_37:
      v28 = 0;
      while (1)
      {
        if (v52)
        {
          CFRelease(v52);
          v52 = 0;
        }
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
        v47 = 0.0;
        if (CFEqual(ValueAtIndex, CFSTR("Ruby")))
        {
          v29 = fcs_copyCaptionDataAsDictionary(v53, &v52);
          if ((_DWORD)v29)
            goto LABEL_61;
        }
        else
        {
          v29 = FigCaptionDynamicStyleCopyKeyFrameValueAtIndex((CFIndex)v53, v28, &v47, &cf);
          if ((_DWORD)v29
            || (v29 = fcs_copyCaptionStyleAsDictionary(ValueAtIndex, (uint64_t)cf, v17, &v52), (_DWORD)v29))
          {
LABEL_61:
            v14 = v29;
            goto LABEL_64;
          }
        }
        v29 = FigCFDictionarySetDouble(v52, CFSTR("RelativeTime"), v47);
        if ((_DWORD)v29)
          goto LABEL_61;
        CFArrayAppendValue(v13, v52);
        if (KeyFrameCount == ++v28)
          goto LABEL_49;
      }
    }
    KeyFrameCount = FigCaptionDynamicStyleGetKeyFrameCount((CFIndex)v53);
    if (KeyFrameCount)
      goto LABEL_37;
LABEL_49:
    v31 = v49;
    v30 = v50;
    v32 = CFDictionaryCreateMutable(allocator, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!v32)
      goto LABEL_63;
    v33 = v32;
    if (FigCFDictionarySetCFIndex(v32, CFSTR("RangeLocation"), v31)
      || FigCFDictionarySetCFIndex(v33, CFSTR("RangeLength"), v30))
    {
      break;
    }
    CFDictionarySetValue(v12, CFSTR("PropertyRange"), v33);
    CFDictionarySetValue(v12, CFSTR("DynamicStyleValue"), v13);
    CFArrayAppendValue(v43, v12);
    CFRelease(v33);
    v3 = v42;
    v20 = allocator;
LABEL_53:
    v23 += v50;
    if (v23 == Length)
      goto LABEL_54;
  }
  CFRelease(v33);
LABEL_63:
  v14 = 0;
LABEL_64:
  v15 = theDict;
  Mutable = 0;
  v2 = v39;
  v3 = v42;
LABEL_65:
  if (v53)
    CFRelease(v53);
  if (cf)
    CFRelease(cf);
  if (theArray)
    CFRelease(theArray);
  if (v13)
    CFRelease(v13);
  if (v12)
    CFRelease(v12);
  if (v43)
    CFRelease(v43);
  if (v52)
    CFRelease(v52);
  if (v15)
    CFRelease(v15);
  if (!(_DWORD)v14)
  {
    v34 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v34)
    {
      v35 = v34;
      v36 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v3) + 16) + 8);
      if (v36)
        v37 = (const __CFString *)v36(v3);
      else
        v37 = &stru_1E28E82E0;
      CFDictionarySetValue(v35, CFSTR("Text"), v37);
      CFDictionarySetValue(v35, CFSTR("Properties"), value);
      CFDictionarySetValue(v35, CFSTR("StyleProperties"), Mutable);
      v14 = 0;
      *v2 = v35;
    }
    else
    {
      v14 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    }
  }
LABEL_87:
  if (value)
    CFRelease(value);
  if (Mutable)
    CFRelease(Mutable);
  return v14;
}

uint64_t FigCaptionSerializerCreateCaptionGroupFromCFData(void **a1, const void *a2, CFTypeRef *a3)
{
  void **v3;
  const __CFAllocator *v5;
  uint64_t v6;
  CFDataRef v7;
  uint64_t CurrentAtomTypeAndDataLength;
  UInt8 *v9;
  UInt8 *v10;
  uint64_t Atom;
  uint64_t Code;
  CFPropertyListRef v13;
  CFStringRef v14;
  __CFArray *Mutable;
  __CFData *v16;
  __CFData *v17;
  CFTypeID TypeID;
  const __CFAllocator *v19;
  CFIndex Count;
  CFIndex v21;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v23;
  uint64_t v24;
  const void *Value;
  CMTime *MutableBytePtr;
  CMTime *v27;
  uint64_t v29;
  CFTypeRef *v30;
  const __CFAllocator *v31;
  CFErrorRef error;
  CFTypeRef v33;
  CFTypeRef v34;
  size_t size;
  int v36;
  CFTypeRef cf;
  _OWORD v38[7];
  _OWORD v39[7];
  CMTime bytes;
  CMTime v41;
  uint64_t v42;

  v3 = a1;
  v42 = *MEMORY[0x1E0C80C00];
  v33 = 0;
  v34 = 0;
  error = 0;
  if (!a1)
  {
    Code = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
LABEL_77:
    Mutable = 0;
    v16 = 0;
    v17 = 0;
    v13 = 0;
LABEL_84:
    v14 = 0;
    goto LABEL_48;
  }
  if (!a2 || !a3)
  {
    Code = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    v3 = 0;
    goto LABEL_77;
  }
  memset(v39, 0, sizeof(v39));
  memset(v38, 0, sizeof(v38));
  cf = 0;
  v36 = 0;
  size = 0;
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v6 = FigByteStreamCreateWithCFData(a2, 0, *MEMORY[0x1E0C9AE00], &cf);
  if ((_DWORD)v6
    || (v6 = FigAtomStreamInitWithByteStream((uint64_t)cf, 0, 0, (uint64_t)v39), (_DWORD)v6)
    || (v6 = FigAtomStreamInitWithParent((uint64_t)v39, 0, (uint64_t)v38), (_DWORD)v6))
  {
    Code = v6;
    v3 = 0;
  }
  else
  {
    v7 = 0;
    do
    {
      CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v38, &v36, &size);
      if ((_DWORD)CurrentAtomTypeAndDataLength)
        goto LABEL_69;
      v9 = (UInt8 *)malloc_type_malloc(size, 0x6D42286BuLL);
      if (!v9)
        goto LABEL_67;
      v10 = v9;
      CurrentAtomTypeAndDataLength = FigAtomStreamReadCurrentAtomData((uint64_t)v38, 0, size, (uint64_t)v9);
      if ((_DWORD)CurrentAtomTypeAndDataLength)
        goto LABEL_69;
      if (v36 == 1717793636)
      {
        if (v7)
          CFRelease(v7);
        v7 = CFDataCreate(v5, v10, size);
        if (!v7)
        {
LABEL_67:
          v29 = 4294949616;
LABEL_68:
          CurrentAtomTypeAndDataLength = FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
LABEL_69:
          Code = CurrentAtomTypeAndDataLength;
          v3 = 0;
          goto LABEL_25;
        }
      }
      else if (v36 == 1717793641)
      {
        if (size != 8)
        {
          v29 = 4294949615;
          goto LABEL_68;
        }
        CurrentAtomTypeAndDataLength = FigCFDictionarySetInt32(v3[2], CFSTR("FigCaptionSerializerVersion"), *v10);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_69;
        CurrentAtomTypeAndDataLength = FigCFDictionarySetInt32(v3[2], CFSTR("FigCaptionSerializerFormat"), v10[4]);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          goto LABEL_69;
      }
      free(v10);
      Atom = FigAtomStreamAdvanceToNextAtom(v38);
    }
    while (!(_DWORD)Atom);
    Code = Atom;
    if ((_DWORD)Atom == -12890)
      Code = 0;
    v3 = (void **)v7;
  }
  v7 = 0;
LABEL_25:
  if (cf)
    CFRelease(cf);
  if (v7)
    CFRelease(v7);
  if ((_DWORD)Code)
    goto LABEL_77;
  v13 = CFPropertyListCreateWithData(v5, (CFDataRef)v3, 0, 0, &error);
  if (!v13)
  {
    Code = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_80:
    Mutable = 0;
LABEL_82:
    v16 = 0;
LABEL_83:
    v17 = 0;
    goto LABEL_84;
  }
  if (error)
  {
    v14 = CFErrorCopyFailureReason(error);
    Code = CFErrorGetCode(error);
    Mutable = 0;
    v16 = 0;
    v17 = 0;
    goto LABEL_48;
  }
  TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(v13))
  {
    FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    Code = 0;
    goto LABEL_80;
  }
  v19 = v5;
  Count = CFArrayGetCount((CFArrayRef)v13);
  Mutable = CFArrayCreateMutable(v19, 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    Code = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    goto LABEL_82;
  }
  v16 = CFDataCreateMutable(v19, 0);
  if (!v16)
  {
    Code = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    goto LABEL_83;
  }
  v31 = v19;
  v17 = CFDataCreateMutable(v19, 0);
  if (!v17)
  {
    Code = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
    goto LABEL_84;
  }
  v30 = a3;
  if (Count)
  {
    v21 = 0;
    while (1)
    {
      if (v33)
      {
        CFRelease(v33);
        v33 = 0;
      }
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v13, v21);
      if (!ValueAtIndex)
      {
        Code = 0;
        goto LABEL_72;
      }
      v23 = ValueAtIndex;
      v24 = fcs_deserializeAndCreateFigCaptionData(ValueAtIndex, &v33);
      if ((_DWORD)v24)
        break;
      Value = CFDictionaryGetValue(v23, CFSTR("Durations"));
      if (FigCFArrayGetCMTimeAtIndex(Value, 0, &bytes))
        FigCFArrayGetCMTimeAtIndex(Value, 1, &v41);
      CFArrayAppendValue(Mutable, v33);
      CFDataAppendBytes(v16, (const UInt8 *)&bytes, 24);
      CFDataAppendBytes(v17, (const UInt8 *)&v41, 24);
      if (Count == ++v21)
        goto LABEL_46;
    }
    Code = v24;
  }
  else
  {
LABEL_46:
    MutableBytePtr = (CMTime *)CFDataGetMutableBytePtr(v16);
    v27 = (CMTime *)CFDataGetMutableBytePtr(v17);
    Code = FigCaptionGroupCreate(v31, Mutable, MutableBytePtr, v27, (uint64_t *)&v34);
    if (!(_DWORD)Code)
    {
      v14 = 0;
      *v30 = v34;
      v34 = 0;
      goto LABEL_48;
    }
  }
LABEL_72:
  v14 = 0;
LABEL_48:
  if (error)
    CFRelease(error);
  if (v14)
    CFRelease(v14);
  if (v3)
    CFRelease(v3);
  if (Mutable)
    CFRelease(Mutable);
  if (v16)
    CFRelease(v16);
  if (v17)
    CFRelease(v17);
  if (v34)
    CFRelease(v34);
  if (v33)
    CFRelease(v33);
  if (v13)
    CFRelease(v13);
  return Code;
}

uint64_t fcs_deserializeAndCreateFigCaptionData(const void *a1, CFTypeRef *a2)
{
  uint64_t v4;
  CFTypeID v5;
  const void *Value;
  const void *v7;
  CFTypeRef v8;
  uint64_t (*v9)(CFTypeRef, const void *);
  const __CFDictionary *v10;
  uint64_t v11;
  const __CFDictionary *v12;
  uint64_t v14;
  _QWORD context[2];
  CFTypeRef cf;

  cf = 0;
  if (a1)
  {
    if (!a2)
      goto LABEL_18;
    v4 = FigCaptionDataCreateMutable((const __CFAllocator *)*MEMORY[0x1E0C9AE00], &cf);
    if ((_DWORD)v4)
    {
LABEL_20:
      v11 = v4;
      goto LABEL_14;
    }
    v5 = CFGetTypeID(a1);
    if (v5 == CFDictionaryGetTypeID())
    {
      Value = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("Text"));
      if (Value)
      {
        v7 = Value;
        v8 = cf;
        v9 = *(uint64_t (**)(CFTypeRef, const void *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)cf) + 16)
                                                               + 16);
        if (!v9)
        {
          v11 = 4294954514;
          goto LABEL_14;
        }
        v4 = v9(v8, v7);
        if ((_DWORD)v4)
          goto LABEL_20;
        context[0] = 0;
        context[1] = cf;
        v10 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("Properties"));
        if (v10)
        {
          CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)fcs_deserializeCaptionPropertyApplier, context);
          v11 = LODWORD(context[0]);
          if (LODWORD(context[0]))
            goto LABEL_14;
          v12 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("StyleProperties"));
          if (v12)
          {
            CFDictionaryApplyFunction(v12, (CFDictionaryApplierFunction)fcs_deserializeCaptionStyleApplier, context);
            v11 = LODWORD(context[0]);
            if (!LODWORD(context[0]))
            {
              *a2 = cf;
              return v11;
            }
LABEL_14:
            if (cf)
              CFRelease(cf);
            return v11;
          }
        }
      }
      v14 = 4294954513;
    }
    else
    {
LABEL_18:
      v14 = 4294949615;
    }
    v4 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_20;
  }
  return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCaptionSerializerInit(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  return result;
}

void FigCaptionSerializerFinalize(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 16);
  if (v1)
    CFRelease(v1);
}

CFStringRef FigCaptionSerializerCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionSerializer %p]"), a1);
}

__CFString *FigCaptionSerializerCopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  const void *Value;
  const void *v4;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("FigCaptionSerializerVersion"));
  v4 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("FigCaptionSerializerFormat"));
  CFStringAppendFormat(Mutable, 0, CFSTR("FigCaptionSerializer (version=%@, format=%@)\n"), Value, v4);
  return Mutable;
}

uint64_t fcs_copyCaptionPropertiesAsDictionary(const void *a1, __CFArray *a2)
{
  __CFArray *Mutable;
  const __CFAllocator *v4;
  CFTypeID v5;
  uint64_t (*v6)(const void *, const __CFString *, const __CFAllocator *, CFArrayRef *);
  uint64_t v7;
  uint64_t (*v8)(const void *, const __CFString *, const __CFAllocator *, CFArrayRef *);
  const __CFString *v9;
  const __CFDictionary *Value;
  const __CFDictionary *v11;
  CFIndex v12;
  const void *ValueAtIndex;
  uint64_t (*v14)(const void *, const void *, const __CFAllocator *, CFTypeRef *);
  uint64_t v15;
  CFTypeID v16;
  CFIndex KeyFrameCount;
  CFIndex v18;
  CFTypeID v19;
  uint64_t TypeID;
  CFTypeRef v21;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  CFIndex Count;
  __CFDictionary *theDict;
  double v28;
  CFArrayRef theArray;
  CFTypeRef v30;
  CFTypeRef v31;
  CFTypeRef cf;

  v31 = 0;
  cf = 0;
  theArray = 0;
  v30 = 0;
  v28 = 0.0;
  if (!a1)
  {
    v24 = 4294949615;
    goto LABEL_68;
  }
  Mutable = a2;
  if (a2)
  {
    v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (theDict)
    {
      v5 = CFGetTypeID(a1);
      if (v5 == FigCaptionDataGetTypeID())
      {
        v6 = *(uint64_t (**)(const void *, const __CFString *, const __CFAllocator *, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 8) + 48);
        if (v6)
          v7 = v6(a1, CFSTR("CaptionPropertyKeysInUse"), v4, &theArray);
        else
          v7 = 4294954514;
        v9 = CFSTR("CaptionProperty");
      }
      else
      {
        v8 = *(uint64_t (**)(const void *, const __CFString *, const __CFAllocator *, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 8) + 48);
        if (v8)
          v7 = v8(a1, CFSTR("CMCaptionRegionPropertyKeysInUse"), v4, &theArray);
        else
          v7 = 4294954514;
        v9 = CFSTR("RegionProperty");
      }
      FigThreadRunOnce(&fcs_getCaptionInfoToPListableMappingDictionary_sInitializeCaptionPropertyToPListableMappingOnce, fcs_initializeCaptionPropertyToPListableMappingDictionary);
      Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)sCaptionInfoToPListableMappingDictionary, v9);
      if ((_DWORD)v7)
        goto LABEL_69;
      v11 = Value;
      if (Value)
      {
        v25 = Mutable;
        Count = CFArrayGetCount(theArray);
        if (!Count)
        {
LABEL_50:
          v7 = 0;
          Mutable = 0;
          *v25 = theDict;
          goto LABEL_52;
        }
        v12 = 0;
        while (1)
        {
          if (cf)
          {
            CFRelease(cf);
            cf = 0;
          }
          Mutable = CFArrayCreateMutable(v4, 0, MEMORY[0x1E0C9B378]);
          if (!Mutable)
            break;
          ValueAtIndex = CFArrayGetValueAtIndex(theArray, v12);
          v14 = *(uint64_t (**)(const void *, const void *, const __CFAllocator *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 8) + 48);
          if (!v14)
          {
            v7 = 4294954514;
            goto LABEL_52;
          }
          v15 = v14(a1, ValueAtIndex, v4, &cf);
          if ((_DWORD)v15)
            goto LABEL_65;
          v28 = 0.0;
          if (CFEqual(ValueAtIndex, CFSTR("Region")) || CFEqual(ValueAtIndex, CFSTR("CMCaptionRegionContainerRegion")))
          {
            if (v31)
            {
              CFRelease(v31);
              v31 = 0;
            }
            v15 = fcs_copyCaptionPropertiesAsDictionary(cf, &v31);
            if ((_DWORD)v15)
              goto LABEL_65;
            CFArrayAppendValue(Mutable, v31);
          }
          else
          {
            if (!cf || (v16 = CFGetTypeID(cf), v16 != FigCaptionDynamicStyleGetTypeID()))
            {
              KeyFrameCount = 1;
LABEL_35:
              v18 = 0;
              while (2)
              {
                if (v31)
                {
                  CFRelease(v31);
                  v31 = 0;
                }
                if (v30)
                {
                  CFRelease(v30);
                  v30 = 0;
                }
                if (cf)
                {
                  v19 = CFGetTypeID(cf);
                  TypeID = FigCaptionDynamicStyleGetTypeID();
                  v21 = cf;
                  if (v19 == TypeID)
                  {
                    v15 = FigCaptionDynamicStyleCopyKeyFrameValueAtIndex((CFIndex)cf, v18, &v28, &v30);
                    if ((_DWORD)v15)
                      goto LABEL_65;
                    v21 = v30;
                    goto LABEL_46;
                  }
                }
                else
                {
                  v21 = 0;
                }
                v28 = -1.0;
LABEL_46:
                v15 = fcs_copyCaptionStyleAsDictionary(ValueAtIndex, (uint64_t)v21, v11, (CFMutableDictionaryRef *)&v31);
                if ((_DWORD)v15)
                  goto LABEL_65;
                v15 = FigCFDictionarySetDouble((void *)v31, CFSTR("RelativeTime"), v28);
                if ((_DWORD)v15)
                  goto LABEL_65;
                CFArrayAppendValue(Mutable, v31);
                if (KeyFrameCount == ++v18)
                  goto LABEL_28;
                continue;
              }
            }
            KeyFrameCount = FigCaptionDynamicStyleGetKeyFrameCount((CFIndex)cf);
            if (KeyFrameCount)
              goto LABEL_35;
          }
LABEL_28:
          CFDictionarySetValue(theDict, ValueAtIndex, Mutable);
          CFRelease(Mutable);
          if (++v12 == Count)
            goto LABEL_50;
        }
        v23 = 4294949616;
        goto LABEL_64;
      }
    }
    v24 = 4294949616;
LABEL_68:
    v7 = FigSignalErrorAt(v24, 0, 0, 0, 0, 0, 0);
LABEL_69:
    Mutable = 0;
    goto LABEL_52;
  }
  v23 = 4294949615;
LABEL_64:
  v15 = FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
LABEL_65:
  v7 = v15;
LABEL_52:
  if (theArray)
    CFRelease(theArray);
  if (v30)
    CFRelease(v30);
  if (Mutable)
    CFRelease(Mutable);
  if (v31)
    CFRelease(v31);
  if (cf)
    CFRelease(cf);
  return v7;
}

uint64_t fcs_copyCaptionStyleAsDictionary(const void *a1, uint64_t a2, const __CFDictionary *a3, CFMutableDictionaryRef *a4)
{
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v9;
  uint64_t (*Value)(CFMutableDictionaryRef, const __CFString *, uint64_t);
  uint64_t v11;
  uint64_t v13;

  if (a1 && a2 && a3 && a4)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v9 = Mutable;
      Value = (uint64_t (*)(CFMutableDictionaryRef, const __CFString *, uint64_t))CFDictionaryGetValue(a3, a1);
      if (Value)
      {
        v11 = Value(v9, CFSTR("PropertyValue"), a2);
        if (!(_DWORD)v11)
        {
          *a4 = v9;
          return v11;
        }
      }
      else
      {
        v11 = FigSignalErrorAt(4294954513, 0, 0, 0, 0, 0, 0);
      }
      CFRelease(v9);
      return v11;
    }
    v13 = 4294949616;
  }
  else
  {
    v13 = 4294949615;
  }
  return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
}

void fcs_initializeCaptionPropertyToPListableMappingDictionary()
{
  const __CFAllocator *v0;
  __CFDictionary *Mutable;
  CFMutableDictionaryRef v2;
  __CFDictionary *v3;
  CFMutableDictionaryRef v4;
  __CFDictionary *v5;
  CFMutableDictionaryRef v6;
  __CFDictionary *v7;

  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v2 = CFDictionaryCreateMutable(v0, 0, MEMORY[0x1E0C9B390], 0);
    if (v2)
    {
      v3 = v2;
      v4 = CFDictionaryCreateMutable(v0, 0, MEMORY[0x1E0C9B390], 0);
      if (v4)
      {
        v5 = v4;
        v6 = CFDictionaryCreateMutable(v0, 0, MEMORY[0x1E0C9B390], 0);
        if (v6)
        {
          v7 = v6;
          CFDictionaryAddValue(v3, CFSTR("Animation"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, CFSTR("TextAlign"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, CFSTR("MultiRowAlign"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, CFSTR("RubyAlign"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, CFSTR("RubyPosition"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionIdentifier"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionShowbackground"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionWritingMode"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionDisplayAlign"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionPadding"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionAnimation"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, CFSTR("FontWeight"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, CFSTR("FontStyle"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, CFSTR("TextCombine"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, CFSTR("TextShear"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, CFSTR("EdgeStyle"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, CFSTR("LineHeight"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, CFSTR("LinePadding"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, CFSTR("SourceInformation"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionCellResolution"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionPosition"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionWidth"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionHeight"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionDisplayAspectRatio"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionActiveArea"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionAnchor"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, CFSTR("FontSize"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, CFSTR("LineHeight"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionStereoDisparity"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionZIndex"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionOpacity"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, CFSTR("Decoration"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionLuminanceGain"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, CFSTR("FillLineGap"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, CFSTR("Hidden"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionClipOverflow"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionInvisible"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionForcedDisplay"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionHidden"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionExplicitRegion"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, CFSTR("Hidden"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, CFSTR("Invisible"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, CFSTR("ForcedDisplay"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, CFSTR("PreventLineWrapping"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v7, CFSTR("WritingDirection"), fcs_setDictionaryFromPropertyCFType);
          CFDictionaryAddValue(v3, CFSTR("BackgroundColor"), fcs_setDictionaryFromPropertyColor);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionBackgroundColor"), fcs_setDictionaryFromPropertyColor);
          CFDictionaryAddValue(v7, CFSTR("TextColor"), fcs_setDictionaryFromPropertyColor);
          CFDictionaryAddValue(v7, CFSTR("BackgroundColor"), fcs_setDictionaryFromPropertyColor);
          CFDictionaryAddValue(v7, CFSTR("FontFamily"), fcs_setDictionaryFromPropertyFontFamily);
          CFDictionaryAddValue(v7, CFSTR("TextOutline"), fcs_setDictionaryFromPropertyTextOutline);
          CFDictionaryAddValue(v7, CFSTR("TextEmphasis"), fcs_setDictionaryFromPropertyTextEmphasis);
          CFDictionaryAddValue(v7, CFSTR("TextShadow"), fcs_setDictionaryFromPropertyTextShadow);
          CFDictionaryAddValue(v3, CFSTR("RubyReserve"), fcs_setDictionaryFromPropertyRubyReserve);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionAbstractPosition"), fcs_setDictionaryFromPropertyCaptionPosition);
          CFDictionaryAddValue(Mutable, CFSTR("CaptionProperty"), v3);
          CFDictionaryAddValue(Mutable, CFSTR("RegionProperty"), v5);
          CFDictionaryAddValue(Mutable, CFSTR("StyleProperty"), v7);
          CFRelease(v3);
          v3 = v5;
          v5 = v7;
        }
        CFRelease(v3);
        v3 = v5;
      }
      CFRelease(v3);
    }
  }
  sCaptionInfoToPListableMappingDictionary = (uint64_t)Mutable;
}

uint64_t fcs_setDictionaryFromPropertyCFType(__CFDictionary *a1, const void *a2, const void *a3)
{
  if (!a1 || !a2 || !a3)
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  CFDictionarySetValue(a1, a2, a3);
  return 0;
}

uint64_t fcs_setDictionaryFromPropertyColor(__CFDictionary *a1, const void *a2, void *cf)
{
  CFTypeID v6;
  CFMutableArrayRef v7;
  CFMutableArrayRef v8;

  if (!a1)
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  if (!a2)
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  if (!cf)
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  v6 = CFGetTypeID(cf);
  if (v6 != CGColorGetTypeID())
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  v7 = FigCopyCGColorSRGBAsArray(cf);
  if (v7)
  {
    v8 = v7;
    CFDictionarySetValue(a1, a2, v7);
    CFRelease(v8);
  }
  return 0;
}

uint64_t fcs_setDictionaryFromPropertyFontFamily(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  const __CFAllocator *v6;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  const CFDictionaryKeyCallBacks *v11;
  const CFDictionaryValueCallBacks *v12;
  uint64_t v13;
  CFMutableDictionaryRef v14;
  CFMutableDictionaryRef v15;
  uint64_t v16;
  __CFDictionary *v18;
  int v19;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  if (!a2 || !a3)
  {
    v16 = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    Mutable = 0;
    goto LABEL_13;
  }
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
LABEL_18:
    v13 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_19:
    v16 = v13;
    goto LABEL_13;
  }
  v18 = a1;
  Count = FigCaptionFontFamilyNameListGetCount(a3);
  if (Count)
  {
    v9 = Count;
    v10 = 0;
    v11 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v12 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    do
    {
      v19 = 0;
      if (cf)
      {
        CFRelease(cf);
        cf = 0;
      }
      v13 = FigCaptionFontFamilyNameListCopyFamilyKindAndNameAtIndex(a3, v10, &v19, &cf);
      if ((_DWORD)v13)
        goto LABEL_19;
      v14 = CFDictionaryCreateMutable(v6, 0, v11, v12);
      if (!v14)
        goto LABEL_18;
      v15 = v14;
      FigCFDictionarySetInt32(v14, CFSTR("FontFamilyKind"), v19);
      FigCFDictionarySetValue(v15, CFSTR("FontFamilyName"), cf);
      CFArrayAppendValue(Mutable, v15);
      CFRelease(v15);
    }
    while (v9 != ++v10);
  }
  CFDictionarySetValue(v18, a2, Mutable);
  v16 = 0;
LABEL_13:
  if (cf)
    CFRelease(cf);
  if (Mutable)
    CFRelease(Mutable);
  return v16;
}

uint64_t fcs_setDictionaryFromPropertyTextOutline(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  const __CFAllocator *v6;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v8;
  void *Color;
  CFMutableArrayRef v10;
  CFMutableArrayRef v11;
  uint64_t Thickness;
  uint64_t v13;
  CFDictionaryRef v14;
  CFDictionaryRef v15;
  uint64_t v17;

  if (!a1 || !a2 || !a3)
  {
    v17 = 4294949615;
    return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
  }
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    v17 = 4294949616;
    return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
  }
  v8 = Mutable;
  Color = (void *)FigCaptionTextOutlineGetColor(a3);
  v10 = FigCopyCGColorSRGBAsArray(Color);
  if (v10)
  {
    v11 = v10;
    Thickness = FigCaptionTextOutlineGetThickness(a3);
    v14 = FigGeometryDimensionCopyAsDictionary(Thickness, v13, v6);
    if (v14)
    {
      v15 = v14;
      CFDictionarySetValue(v8, CFSTR("TextOutlineColor"), v11);
      CFDictionarySetValue(v8, CFSTR("TextOutlineThickness"), v15);
      CFDictionarySetValue(a1, a2, v8);
      CFRelease(v15);
    }
    CFRelease(v11);
  }
  CFRelease(v8);
  return 0;
}

uint64_t fcs_setDictionaryFromPropertyTextEmphasis(__CFDictionary *a1, const void *a2, CFTypeRef cf)
{
  CFTypeID v6;
  const __CFAllocator *v7;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v9;
  unsigned int EmphasisStyle;
  unsigned int v11;
  CFNumberRef UInt32;
  const void *CustomMark;
  CFNumberRef v14;
  CFNumberRef v15;
  uint64_t v16;
  unsigned int MarkingStyle;
  unsigned int PredefinedMark;
  void *Color;
  CFMutableArrayRef v20;
  const void *RubyPosition;
  uint64_t v23;

  if (a1 && a2 && cf)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == FigCaptionTextEmphasisGetTypeID())
    {
      v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Mutable)
      {
        v9 = Mutable;
        EmphasisStyle = FigCaptionTextEmphasisGetEmphasisStyle((uint64_t)cf);
        if (EmphasisStyle > 3)
        {
          v16 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_33:
          CFRelease(v9);
          return v16;
        }
        v11 = EmphasisStyle;
        UInt32 = FigCFNumberCreateUInt32(v7, EmphasisStyle);
        CFDictionarySetValue(v9, CFSTR("TextEmphasisStyle"), UInt32);
        if (v11 == 2)
        {
          MarkingStyle = FigCaptionTextEmphasisGetMarkingStyle((uint64_t)cf);
          PredefinedMark = FigCaptionTextEmphasisGetPredefinedMark((uint64_t)cf);
          v14 = FigCFNumberCreateUInt32(v7, MarkingStyle);
          v15 = FigCFNumberCreateUInt32(v7, PredefinedMark);
          if (v14)
            CFDictionarySetValue(v9, CFSTR("TextEmphasisCustomMarkingStyle"), v14);
          if (v15)
            CFDictionarySetValue(v9, CFSTR("TextEmphasisPredefinedMark"), v15);
        }
        else
        {
          if (v11 == 3)
          {
            CustomMark = (const void *)FigCaptionTextEmphasisGetCustomMark((uint64_t)cf);
            if (CustomMark)
              CFDictionarySetValue(v9, CFSTR("TextEmphasisCustomMark"), CustomMark);
          }
          v14 = 0;
          v15 = 0;
        }
        Color = (void *)FigCaptionTextEmphasisGetColor((uint64_t)cf);
        if (Color)
        {
          v20 = FigCopyCGColorSRGBAsArray(Color);
          if (!v20)
          {
LABEL_24:
            if (UInt32)
              CFRelease(UInt32);
            if (v14)
              CFRelease(v14);
            if (v15)
              CFRelease(v15);
            if (v20)
              CFRelease(v20);
            v16 = 0;
            goto LABEL_33;
          }
          CFDictionarySetValue(v9, CFSTR("TextEmphasisColor"), v20);
        }
        else
        {
          v20 = 0;
        }
        RubyPosition = (const void *)FigCaptionTextEmphasisGetRubyPosition((uint64_t)cf);
        if (RubyPosition)
          CFDictionarySetValue(v9, CFSTR("TextEmphasisRubyPosition"), RubyPosition);
        CFDictionarySetValue(a1, a2, v9);
        goto LABEL_24;
      }
    }
    v23 = 4294949616;
  }
  else
  {
    v23 = 4294949615;
  }
  return FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
}

uint64_t fcs_setDictionaryFromPropertyTextShadow(__CFDictionary *a1, const void *a2, CFTypeRef cf)
{
  CFTypeID v6;
  const __CFAllocator *v7;
  const __CFArray *TextShadowArray;
  CFMutableDictionaryRef v9;
  __CFArray *v10;
  CFDictionaryRef v11;
  CFDictionaryRef v12;
  CFDictionaryRef v13;
  CFMutableArrayRef v14;
  CFIndex v15;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v18;
  CFTypeID v19;
  CFMutableDictionaryRef Mutable;
  __CFArray *v21;
  uint64_t HorizontalAxisOffset;
  uint64_t v23;
  uint64_t v24;
  uint64_t VerticalAxisOffset;
  uint64_t v26;
  uint64_t v27;
  uint64_t BlurRadius;
  uint64_t v29;
  uint64_t v30;
  void *Color;
  __CFArray *v32;
  uint64_t v33;
  uint64_t v35;
  __CFDictionary *v36;
  const void *v37;
  __CFDictionary *theDict;
  const __CFArray *v39;
  CFIndex v40;

  if (!a1 || !a2 || !cf || (v6 = CFGetTypeID(cf), v6 != FigCaptionTextShadowListGetTypeID()))
  {
    v35 = 4294949615;
    return FigSignalErrorAt(v35, 0, 0, 0, 0, 0, 0);
  }
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!theDict)
  {
    v35 = 4294949616;
    return FigSignalErrorAt(v35, 0, 0, 0, 0, 0, 0);
  }
  v36 = a1;
  v37 = a2;
  TextShadowArray = (const __CFArray *)FigCaptionTextShadowListGetTextShadowArray((uint64_t)cf);
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v39 = TextShadowArray;
  if (!TextShadowArray)
    goto LABEL_8;
LABEL_7:
  for (i = CFArrayGetCount(TextShadowArray); v15 < i; i = 0)
  {
    if (v11)
      CFRelease(v11);
    if (v12)
      CFRelease(v12);
    if (v13)
      CFRelease(v13);
    if (v14)
      CFRelease(v14);
    ValueAtIndex = CFArrayGetValueAtIndex(TextShadowArray, v15);
    if (!ValueAtIndex
      || (v18 = (uint64_t)ValueAtIndex, v19 = CFGetTypeID(ValueAtIndex), v19 != FigCaptionTextShadowGetTypeID()))
    {
      v33 = FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
      if (!v9)
        goto LABEL_48;
LABEL_47:
      CFRelease(v9);
      goto LABEL_48;
    }
    Mutable = CFDictionaryCreateMutable(v7, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!Mutable)
    {
      v33 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
      goto LABEL_48;
    }
    v40 = v15;
    v9 = Mutable;
    v21 = v10;
    HorizontalAxisOffset = FigCaptionTextShadowGetHorizontalAxisOffset(v18);
    v24 = v23;
    VerticalAxisOffset = FigCaptionTextShadowGetVerticalAxisOffset(v18);
    v27 = v26;
    BlurRadius = FigCaptionTextShadowGetBlurRadius(v18);
    v30 = v29;
    v11 = FigGeometryDimensionCopyAsDictionary(HorizontalAxisOffset, v24, v7);
    v12 = FigGeometryDimensionCopyAsDictionary(VerticalAxisOffset, v27, v7);
    v13 = FigGeometryDimensionCopyAsDictionary(BlurRadius, v30, v7);
    if (v11)
      CFDictionarySetValue(v9, CFSTR("TextShadowHorizontalAxisOffset"), v11);
    if (v12)
      CFDictionarySetValue(v9, CFSTR("TextShadowVerticalAxisOffset"), v12);
    v10 = v21;
    TextShadowArray = v39;
    if (v13)
      CFDictionarySetValue(v9, CFSTR("TextShadowBlurRadius"), v13);
    Color = (void *)FigCaptionTextShadowGetColor(v18);
    if (Color)
    {
      v14 = FigCopyCGColorSRGBAsArray(Color);
      if (!v14)
        goto LABEL_38;
      CFDictionarySetValue(v9, CFSTR("TextShadowColor"), v14);
      if (v21)
      {
LABEL_30:
        v32 = v21;
        goto LABEL_33;
      }
    }
    else
    {
      v14 = 0;
      if (v21)
        goto LABEL_30;
    }
    v32 = CFArrayCreateMutable(v7, 0, MEMORY[0x1E0C9B378]);
    if (!v32)
    {
      v33 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
      if (!v11)
        goto LABEL_40;
LABEL_39:
      CFRelease(v11);
      goto LABEL_40;
    }
LABEL_33:
    CFArrayAppendValue(v32, v9);
    v15 = v40 + 1;
    v10 = v32;
    if (v39)
      goto LABEL_7;
LABEL_8:
    ;
  }
  if (v10)
    CFDictionarySetValue(theDict, CFSTR("TextShadowList"), v10);
  CFDictionarySetValue(v36, v37, theDict);
LABEL_38:
  v33 = 0;
  if (v11)
    goto LABEL_39;
LABEL_40:
  if (v12)
    CFRelease(v12);
  if (v13)
    CFRelease(v13);
  if (v14)
    CFRelease(v14);
  if (v9)
    goto LABEL_47;
LABEL_48:
  if (v10)
    CFRelease(v10);
  return v33;
}

uint64_t fcs_setDictionaryFromPropertyRubyReserve(__CFDictionary *a1, const void *a2, CFTypeRef cf)
{
  CFTypeID v6;
  const __CFAllocator *v7;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v9;
  const void *RubyPosition;
  uint64_t Length;
  uint64_t v12;
  CFDictionaryRef v13;
  CFDictionaryRef v14;
  uint64_t v15;
  uint64_t v17;

  if (!a1 || !a2 || !cf)
  {
    v17 = 4294949615;
    return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
  }
  v6 = CFGetTypeID(cf);
  if (v6 != FigCaptionRubyReserveGetTypeID()
    || (v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00],
        (Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0])) == 0))
  {
    v17 = 4294949616;
    return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
  }
  v9 = Mutable;
  RubyPosition = (const void *)FigCaptionRubyReserveGetRubyPosition((uint64_t)cf);
  Length = FigCaptionRubyReserveGetLength((uint64_t)cf);
  v13 = FigGeometryDimensionCopyAsDictionary(Length, v12, v7);
  if (v13)
  {
    v14 = v13;
    if (RubyPosition)
      CFDictionarySetValue(v9, CFSTR("RubyReserveRubyPosition"), RubyPosition);
    CFDictionarySetValue(v9, CFSTR("RubyReserveLength"), v14);
    CFDictionarySetValue(a1, a2, v9);
    CFRelease(v14);
    v15 = 0;
  }
  else
  {
    v15 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
  }
  CFRelease(v9);
  return v15;
}

uint64_t fcs_setDictionaryFromPropertyCaptionPosition(__CFDictionary *a1, const void *a2, CFTypeRef cf)
{
  CFTypeID v6;
  const __CFAllocator *v7;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v9;
  int HorizontalEdgeReference;
  int VerticalEdgeReference;
  uint64_t HorizontalEdgeOffset;
  uint64_t v13;
  uint64_t v14;
  uint64_t VerticalEdgeOffset;
  uint64_t v16;
  const __CFString *v17;
  char v18;
  const __CFString *v19;
  const __CFString *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFDictionaryRef v24;
  CFDictionaryRef v25;
  uint64_t v26;
  CFDictionaryRef v27;
  uint64_t v29;
  char v30;

  if (a1 && a2 && cf)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == FigCaptionRubyReserveGetTypeID())
    {
      v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Mutable)
      {
        v9 = Mutable;
        HorizontalEdgeReference = FigCaptionPositionGetHorizontalEdgeReference((uint64_t)cf);
        VerticalEdgeReference = FigCaptionPositionGetVerticalEdgeReference((uint64_t)cf);
        HorizontalEdgeOffset = FigCaptionPositionGetHorizontalEdgeOffset((uint64_t)cf);
        v14 = v13;
        VerticalEdgeOffset = FigCaptionPositionGetVerticalEdgeOffset((uint64_t)cf);
        if (HorizontalEdgeReference <= 1818584691)
        {
          if (HorizontalEdgeReference == 1651471476)
          {
            v30 = 0;
            v17 = CFSTR("Bottom");
            goto LABEL_18;
          }
          if (HorizontalEdgeReference == 1667591796)
          {
            v30 = 0;
            v17 = CFSTR("Center");
            goto LABEL_18;
          }
        }
        else
        {
          switch(HorizontalEdgeReference)
          {
            case 1818584692:
              v30 = 0;
              v17 = CFSTR("Left");
              goto LABEL_18;
            case 1919510376:
              v30 = 0;
              v17 = CFSTR("Right");
              goto LABEL_18;
            case 1953460256:
              v30 = 0;
              v17 = CFSTR("Top");
              goto LABEL_18;
          }
        }
        v17 = 0;
        v30 = 1;
LABEL_18:
        if (VerticalEdgeReference <= 1818584691)
        {
          if (VerticalEdgeReference == 1651471476)
          {
            v18 = 0;
            v19 = CFSTR("Bottom");
            goto LABEL_30;
          }
          if (VerticalEdgeReference == 1667591796)
          {
            v18 = 0;
            v19 = CFSTR("Center");
            goto LABEL_30;
          }
        }
        else
        {
          switch(VerticalEdgeReference)
          {
            case 1818584692:
              v18 = 0;
              v19 = CFSTR("Left");
              goto LABEL_30;
            case 1919510376:
              v18 = 0;
              v19 = CFSTR("Right");
              goto LABEL_30;
            case 1953460256:
              v18 = 0;
              v19 = CFSTR("Top");
              goto LABEL_30;
          }
        }
        v19 = 0;
        v18 = 1;
LABEL_30:
        if ((v14 & 0x1D00000000) == 0x100000000)
        {
          v20 = v17;
          v21 = VerticalEdgeOffset;
          v22 = HorizontalEdgeOffset;
          v23 = v16;
          v24 = FigGeometryDimensionCopyAsDictionary(v22, v14, v7);
          v16 = v23;
          v25 = v24;
          VerticalEdgeOffset = v21;
          v17 = v20;
          if (!v25)
          {
            v26 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_49:
            CFRelease(v9);
            return v26;
          }
        }
        else
        {
          v25 = 0;
        }
        if ((v16 & 0x1D00000000) == 0x100000000)
        {
          v27 = FigGeometryDimensionCopyAsDictionary(VerticalEdgeOffset, v16, v7);
          if (!v27)
          {
            v26 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_45:
            if (v25)
              CFRelease(v25);
            if (v27)
              CFRelease(v27);
            goto LABEL_49;
          }
        }
        else
        {
          v27 = 0;
        }
        if ((v30 & 1) != 0)
        {
          if ((v18 & 1) != 0)
            goto LABEL_40;
        }
        else
        {
          CFDictionarySetValue(v9, CFSTR("HorizontalEdge"), v17);
          if ((v18 & 1) != 0)
          {
LABEL_40:
            if (!v25)
            {
LABEL_42:
              if (v27)
                CFDictionarySetValue(v9, CFSTR("VerticalOffset"), v27);
              CFDictionarySetValue(a1, a2, v9);
              v26 = 0;
              goto LABEL_45;
            }
LABEL_41:
            CFDictionarySetValue(v9, CFSTR("HorizontalOffset"), v25);
            goto LABEL_42;
          }
        }
        CFDictionarySetValue(v9, CFSTR("VerticalEdge"), v19);
        if (!v25)
          goto LABEL_42;
        goto LABEL_41;
      }
    }
    v29 = 4294949616;
  }
  else
  {
    v29 = 4294949615;
  }
  return FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
}

void fcs_deserializeCaptionPropertyApplier(const void *a1, CFArrayRef theArray, uint64_t a3)
{
  const __CFDictionary *ValueAtIndex;
  int v7;
  uint64_t v8;
  const void *Value;
  uint64_t CMBaseObject;
  uint64_t (*v11)(uint64_t, const void *, const void *);
  const __CFDictionary *v12;
  uint64_t v13;
  CFTypeRef cf;
  double v15;

  cf = 0;
  v15 = 0.0;
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, 0);
  if (!CFEqual(a1, CFSTR("Region")) && !CFEqual(a1, CFSTR("CMCaptionRegionContainerRegion")))
  {
    if (FigCFDictionaryGetDoubleIfPresent((uint64_t)ValueAtIndex, CFSTR("RelativeTime"), &v15))
    {
      if (v15 < 0.0)
      {
        Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("PropertyValue"));
        v8 = *(_QWORD *)(a3 + 8);
LABEL_5:
        CMBaseObject = FigCaptionDataGetCMBaseObject(v8);
        v11 = *(uint64_t (**)(uint64_t, const void *, const void *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                        + 8)
                                                                            + 56);
        if (v11)
          v7 = v11(CMBaseObject, a1, Value);
        else
          v7 = -12782;
        goto LABEL_8;
      }
      FigThreadRunOnce(&fcs_getPListableToCaptionInfoMappingDictionary_sInitializePListableToCaptionPropertyMappingOnce, fcs_initializePListableToCaptionPropertyMappingDictionary);
      v12 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)sPListableToCaptionInfoMappingDictionary, CFSTR("CaptionProperty"));
      if (v12)
      {
        v7 = fcs_createDynamicStyleFromPListable(a1, theArray, v12, &cf);
        if (!v7)
          goto LABEL_4;
        goto LABEL_8;
      }
      v13 = 4294949616;
    }
    else
    {
      v13 = 4294954513;
    }
    v7 = FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  v7 = fcs_deserializeAndSetRegionProperty(ValueAtIndex, &cf);
  if (!v7)
  {
LABEL_4:
    v8 = *(_QWORD *)(a3 + 8);
    Value = cf;
    goto LABEL_5;
  }
LABEL_8:
  *(_DWORD *)a3 = v7;
  if (cf)
    CFRelease(cf);
}

void fcs_deserializeCaptionStyleApplier(const __CFString *a1, CFArrayRef theArray, int *a3)
{
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const __CFDictionary *ValueAtIndex;
  const void *Value;
  uint64_t v11;
  CFTypeID v12;
  uint64_t v13;
  uint64_t v14;
  const __CFArray *v15;
  const void *v16;
  int v17;
  uint64_t v18;
  CFTypeRef v19;
  uint64_t (*v20)(uint64_t, const __CFString *, CFTypeRef, uint64_t, uint64_t);
  uint64_t v21;
  const __CFString *v22;
  const __CFDictionary *v23;
  uint64_t v24;
  CFTypeRef v25;
  int *v26;
  CFTypeRef v27;
  CFTypeRef cf;
  uint64_t v29;
  uint64_t v30;

  v27 = 0;
  cf = 0;
  Count = CFArrayGetCount(theArray);
  if (!Count)
  {
    *a3 = 0;
    return;
  }
  v7 = Count;
  v26 = a3;
  v8 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v8);
    Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("PropertyRange"));
    v29 = 0;
    v30 = 0;
    if (Value && (v11 = (uint64_t)Value, v12 = CFGetTypeID(Value), v12 == CFDictionaryGetTypeID()))
    {
      if (FigCFDictionaryGetCFIndexIfPresent(v11, CFSTR("RangeLocation"), &v29))
        FigCFDictionaryGetCFIndexIfPresent(v11, CFSTR("RangeLength"), &v30);
    }
    else
    {
      FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    }
    v14 = v29;
    v13 = v30;
    v15 = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex, CFSTR("DynamicStyleValue"));
    if (!CFEqual(a1, CFSTR("Ruby")))
      break;
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
    v16 = CFArrayGetValueAtIndex(v15, 0);
    v17 = fcs_deserializeAndCreateFigCaptionData(v16, &cf);
    if (v17)
      goto LABEL_25;
    v18 = *((_QWORD *)v26 + 1);
    v19 = cf;
    v20 = *(uint64_t (**)(uint64_t, const __CFString *, CFTypeRef, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v18) + 16)
                                                                                             + 32);
    if (!v20)
    {
LABEL_24:
      v17 = -12782;
      goto LABEL_25;
    }
    v21 = v18;
    v22 = CFSTR("Ruby");
LABEL_19:
    v17 = v20(v21, v22, v19, v14, v13);
    if (v17)
      goto LABEL_25;
    if (v7 == ++v8)
    {
      v17 = 0;
      goto LABEL_25;
    }
  }
  if (v27)
  {
    CFRelease(v27);
    v27 = 0;
  }
  FigThreadRunOnce(&fcs_getPListableToCaptionInfoMappingDictionary_sInitializePListableToCaptionPropertyMappingOnce, fcs_initializePListableToCaptionPropertyMappingDictionary);
  v23 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)sPListableToCaptionInfoMappingDictionary, CFSTR("StyleProperty"));
  if (v23)
  {
    v17 = fcs_createDynamicStyleFromPListable(a1, v15, v23, &v27);
    if (v17)
      goto LABEL_25;
    v19 = v27;
    v24 = *((_QWORD *)v26 + 1);
    v20 = *(uint64_t (**)(uint64_t, const __CFString *, CFTypeRef, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v24) + 16)
                                                                                             + 32);
    if (!v20)
      goto LABEL_24;
    v21 = v24;
    v22 = a1;
    goto LABEL_19;
  }
  v17 = FigSignalErrorAt(4294949616, 0, 0, 0, 0, 0, 0);
LABEL_25:
  v25 = cf;
  *v26 = v17;
  if (v25)
    CFRelease(v25);
  if (v27)
    CFRelease(v27);
}

uint64_t fcs_deserializeAndSetRegionProperty(const __CFDictionary *a1, CFTypeRef *a2)
{
  uint64_t v4;
  CFTypeRef v5;
  _QWORD context[2];
  CFTypeRef cf;

  cf = 0;
  if (!a1 || !a2)
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  v4 = FigCaptionRegionCreateMutable((const __CFAllocator *)*MEMORY[0x1E0C9AE00], &cf);
  v5 = cf;
  if ((_DWORD)v4
    || (context[0] = 0,
        context[1] = cf,
        CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)fcs_deserializeRegionPropertyApplier, context),
        v4 = LODWORD(context[0]),
        v5 = cf,
        LODWORD(context[0])))
  {
    if (v5)
      CFRelease(v5);
  }
  else
  {
    *a2 = cf;
  }
  return v4;
}

uint64_t fcs_createDynamicStyleFromPListable(const void *a1, CFArrayRef theArray, const __CFDictionary *a3, _QWORD *a4)
{
  CFIndex Count;
  uint64_t (*Value)(const void *, CFTypeRef *, double);
  uint64_t (*v10)(const void *, CFTypeRef *, double);
  CFIndex v11;
  const __CFDictionary *ValueAtIndex;
  const void *v13;
  uint64_t v14;
  CFTypeRef v15;
  uint64_t v16;
  uint64_t v17;
  double v19;
  CFTypeRef cf;

  v19 = 0.0;
  cf = 0;
  if (!a1 || !theArray || !a3 || !a4)
  {
    v16 = 4294949615;
LABEL_14:
    v14 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
LABEL_15:
    v17 = v14;
    if (cf)
      CFRelease(cf);
    return v17;
  }
  Count = CFArrayGetCount(theArray);
  Value = (uint64_t (*)(const void *, CFTypeRef *, double))CFDictionaryGetValue(a3, a1);
  if (!Value)
  {
LABEL_13:
    v16 = 4294954513;
    goto LABEL_14;
  }
  if (Count)
  {
    v10 = Value;
    v11 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v11);
      if (!FigCFDictionaryGetDoubleIfPresent((uint64_t)ValueAtIndex, CFSTR("RelativeTime"), &v19))
        goto LABEL_13;
      v13 = CFDictionaryGetValue(ValueAtIndex, CFSTR("PropertyValue"));
      if (!v13)
        goto LABEL_13;
      v14 = v10(v13, &cf, v19);
      if ((_DWORD)v14)
        goto LABEL_15;
      if (Count == ++v11)
      {
        v15 = cf;
        goto LABEL_18;
      }
    }
  }
  v15 = 0;
LABEL_18:
  v17 = 0;
  *a4 = v15;
  return v17;
}

void fcs_deserializeRegionPropertyApplier(const void *a1, const __CFArray *a2, uint64_t a3)
{
  const __CFDictionary *Value;
  const __CFDictionary *v7;
  const __CFDictionary *ValueAtIndex;
  int v9;
  uint64_t v10;
  CFTypeRef v11;
  uint64_t CMBaseObject;
  uint64_t (*v13)(uint64_t, const void *, CFTypeRef);
  uint64_t v14;
  CFTypeRef v15;
  CFTypeRef cf;
  double v17;

  cf = 0;
  v17 = 0.0;
  v15 = 0;
  FigThreadRunOnce(&fcs_getPListableToCaptionInfoMappingDictionary_sInitializePListableToCaptionPropertyMappingOnce, fcs_initializePListableToCaptionPropertyMappingDictionary);
  Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)sPListableToCaptionInfoMappingDictionary, CFSTR("RegionProperty"));
  if (!Value)
  {
    v14 = 4294949616;
    goto LABEL_20;
  }
  v7 = Value;
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a2, 0);
  if (!CFEqual(a1, CFSTR("CMCaptionRegionContainerRegion")))
  {
    if (FigCFDictionaryGetDoubleIfPresent((uint64_t)ValueAtIndex, CFSTR("RelativeTime"), &v17))
    {
      if (v17 >= 0.0)
      {
        v9 = fcs_createDynamicStyleFromPListable(a1, a2, v7, &v15);
        if (v9)
          goto LABEL_13;
        v10 = *(_QWORD *)(a3 + 8);
        v11 = v15;
      }
      else
      {
        v11 = CFDictionaryGetValue(ValueAtIndex, CFSTR("PropertyValue"));
        v10 = *(_QWORD *)(a3 + 8);
      }
      goto LABEL_10;
    }
    v14 = 4294954513;
LABEL_20:
    v9 = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_13;
  }
  v9 = fcs_deserializeAndSetRegionProperty(ValueAtIndex, &cf);
  if (v9)
    goto LABEL_13;
  v10 = *(_QWORD *)(a3 + 8);
  v11 = cf;
LABEL_10:
  CMBaseObject = FigCaptionRegionGetCMBaseObject(v10);
  v13 = *(uint64_t (**)(uint64_t, const void *, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                   + 56);
  if (v13)
    v9 = v13(CMBaseObject, a1, v11);
  else
    v9 = -12782;
LABEL_13:
  *(_DWORD *)a3 = v9;
  if (cf)
    CFRelease(cf);
  if (v15)
    CFRelease(v15);
}

void fcs_initializePListableToCaptionPropertyMappingDictionary()
{
  const __CFAllocator *v0;
  __CFDictionary *Mutable;
  CFMutableDictionaryRef v2;
  __CFDictionary *v3;
  CFMutableDictionaryRef v4;
  __CFDictionary *v5;
  CFMutableDictionaryRef v6;
  __CFDictionary *v7;

  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v2 = CFDictionaryCreateMutable(v0, 0, MEMORY[0x1E0C9B390], 0);
    if (v2)
    {
      v3 = v2;
      v4 = CFDictionaryCreateMutable(v0, 0, MEMORY[0x1E0C9B390], 0);
      if (v4)
      {
        v5 = v4;
        v6 = CFDictionaryCreateMutable(v0, 0, MEMORY[0x1E0C9B390], 0);
        if (v6)
        {
          v7 = v6;
          CFDictionaryAddValue(v3, CFSTR("Animation"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, CFSTR("TextAlign"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, CFSTR("MultiRowAlign"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, CFSTR("RubyAlign"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, CFSTR("RubyPosition"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionIdentifier"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionShowbackground"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionWritingMode"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionDisplayAlign"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionPadding"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionAnimation"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, CFSTR("FontWeight"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, CFSTR("FontStyle"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, CFSTR("Ruby"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, CFSTR("TextCombine"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, CFSTR("TextShear"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, CFSTR("EdgeStyle"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, CFSTR("LineHeight"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, CFSTR("LinePadding"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, CFSTR("SourceInformation"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionCellResolution"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionPosition"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionWidth"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionHeight"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionDisplayAspectRatio"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionActiveArea"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionAnchor"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, CFSTR("FontSize"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, CFSTR("LineHeight"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionStereoDisparity"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionZIndex"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionOpacity"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, CFSTR("Decoration"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionLuminanceGain"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, CFSTR("FillLineGap"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, CFSTR("Hidden"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionClipOverflow"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionInvisible"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionForcedDisplay"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionHidden"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionExplicitRegion"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, CFSTR("Hidden"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, CFSTR("Invisible"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, CFSTR("ForcedDisplay"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, CFSTR("PreventLineWrapping"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v7, CFSTR("WritingDirection"), fcs_createDynamicStyleFromPListCFType);
          CFDictionaryAddValue(v3, CFSTR("BackgroundColor"), fcs_createDynamicStyleFromPListColor);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionBackgroundColor"), fcs_createDynamicStyleFromPListColor);
          CFDictionaryAddValue(v7, CFSTR("TextColor"), fcs_createDynamicStyleFromPListColor);
          CFDictionaryAddValue(v7, CFSTR("BackgroundColor"), fcs_createDynamicStyleFromPListColor);
          CFDictionaryAddValue(v7, CFSTR("FontFamily"), fcs_createDynamicStyleFromPListFontFamily);
          CFDictionaryAddValue(v7, CFSTR("TextOutline"), fcs_createDynamicStyleFromPListTextOutline);
          CFDictionaryAddValue(v7, CFSTR("TextEmphasis"), fcs_createDynamicStyleFromPListTextEmphasis);
          CFDictionaryAddValue(v7, CFSTR("TextShadow"), fcs_createDynamicStyleFromPListTextShadow);
          CFDictionaryAddValue(v3, CFSTR("RubyReserve"), fcs_createDynamicStyleFromPListRubyReserve);
          CFDictionaryAddValue(v5, CFSTR("CMCaptionRegionAbstractPosition"), fcs_createDynamicStyleFromPListAbstractPosition);
          CFDictionaryAddValue(Mutable, CFSTR("CaptionProperty"), v3);
          CFDictionaryAddValue(Mutable, CFSTR("RegionProperty"), v5);
          CFDictionaryAddValue(Mutable, CFSTR("StyleProperty"), v7);
          CFRelease(v3);
          v3 = v5;
          v5 = v7;
        }
        CFRelease(v3);
        v3 = v5;
      }
      CFRelease(v3);
    }
  }
  sPListableToCaptionInfoMappingDictionary = (uint64_t)Mutable;
}

uint64_t fcs_createDynamicStyleFromPListCFType(const void *a1, uint64_t *a2, double a3)
{
  if (!a1 || !a2)
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  if (*a2)
    return FigCaptionDynamicStyleAddKeyFrameValue(*a2, a1, a3);
  return FigCaptionDynamicStyleCreateMutable((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a1, a2);
}

uint64_t fcs_createDynamicStyleFromPListColor(const void *a1, uint64_t *a2, double a3)
{
  CGColorRef CGColorSRGBFromArray;
  uint64_t Mutable;
  uint64_t v7;

  if (a1 && a2)
  {
    CGColorSRGBFromArray = FigCreateCGColorSRGBFromArray(a1);
    if (CGColorSRGBFromArray)
    {
      if (*a2)
        Mutable = FigCaptionDynamicStyleAddKeyFrameValue(*a2, CGColorSRGBFromArray, a3);
      else
        Mutable = FigCaptionDynamicStyleCreateMutable((const __CFAllocator *)*MEMORY[0x1E0C9AE00], CGColorSRGBFromArray, a2);
      v7 = Mutable;
    }
    else
    {
      v7 = 0;
    }
  }
  else
  {
    v7 = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    CGColorSRGBFromArray = 0;
  }
  CGColorRelease(CGColorSRGBFromArray);
  return v7;
}

uint64_t fcs_createDynamicStyleFromPListFontFamily(const __CFArray *a1, uint64_t *a2, double a3)
{
  const __CFAllocator *v6;
  uint64_t Mutable;
  CFIndex Count;
  CFIndex v9;
  CFIndex v10;
  const __CFDictionary *ValueAtIndex;
  const void *Value;
  uint64_t v13;
  unsigned int v15;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
    return FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  if (a2)
  {
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = FigCaptionFontFamilyNameListCreateMutable((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (uint64_t *)&cf);
    if (!(_DWORD)Mutable)
    {
      Count = CFArrayGetCount(a1);
      if (Count)
      {
        v9 = Count;
        v10 = 0;
        while (1)
        {
          v15 = 0;
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, v10);
          if (!FigCFDictionaryGetInt32IfPresent((uint64_t)ValueAtIndex, CFSTR("FontFamilyKind"), &v15))
            break;
          Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("FontFamilyName"));
          if (!Value)
            break;
          Mutable = FigCaptionFontFamilyNameListAppend((uint64_t)cf, v15, Value);
          if ((_DWORD)Mutable)
            goto LABEL_13;
          if (v9 == ++v10)
            goto LABEL_10;
        }
        v13 = 0;
        goto LABEL_14;
      }
LABEL_10:
      if (*a2)
        Mutable = FigCaptionDynamicStyleAddKeyFrameValue(*a2, cf, a3);
      else
        Mutable = FigCaptionDynamicStyleCreateMutable(v6, cf, a2);
    }
  }
  else
  {
    Mutable = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  }
LABEL_13:
  v13 = Mutable;
LABEL_14:
  if (cf)
    CFRelease(cf);
  return v13;
}

uint64_t fcs_createDynamicStyleFromPListTextOutline(CFDictionaryRef theDict, uint64_t *a2, double a3)
{
  const __CFDictionary *CGColorSRGBFromArray;
  const void *Value;
  const void *v7;
  const void *v8;
  const __CFAllocator *v9;
  uint64_t v10;
  uint64_t Mutable;
  uint64_t v12;
  CFTypeRef cf;

  CGColorSRGBFromArray = theDict;
  cf = 0;
  if (!theDict)
  {
    Mutable = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
LABEL_8:
    v12 = Mutable;
    goto LABEL_9;
  }
  if (a2)
  {
    Value = CFDictionaryGetValue(theDict, CFSTR("TextOutlineColor"));
    v7 = CFDictionaryGetValue(CGColorSRGBFromArray, CFSTR("TextOutlineThickness"));
    CGColorSRGBFromArray = FigCreateCGColorSRGBFromArray(Value);
    if (CGColorSRGBFromArray)
    {
      v8 = FigGeometryDimensionMakeFromDictionary(v7);
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = FigCaptionTextOutlineCreate(*MEMORY[0x1E0C9AE00], (uint64_t)v8, v10, CGColorSRGBFromArray, &cf);
      if (!(_DWORD)Mutable)
      {
        if (*a2)
          Mutable = FigCaptionDynamicStyleAddKeyFrameValue(*a2, cf, a3);
        else
          Mutable = FigCaptionDynamicStyleCreateMutable(v9, cf, a2);
      }
      goto LABEL_8;
    }
    v12 = 0;
  }
  else
  {
    v12 = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    CGColorSRGBFromArray = 0;
  }
LABEL_9:
  CGColorRelease(CGColorSRGBFromArray);
  if (cf)
    CFRelease(cf);
  return v12;
}

uint64_t fcs_createDynamicStyleFromPListTextEmphasis(CFDictionaryRef theDict, uint64_t *a2, double a3)
{
  const __CFDictionary *CGColorSRGBFromArray;
  const __CFNumber *Value;
  int v7;
  const void *v8;
  int v9;
  int v10;
  const __CFNumber *v11;
  const __CFNumber *v12;
  const void *v13;
  const void *v14;
  uint64_t v15;
  const __CFAllocator *v16;
  uint64_t Mutable;
  int v19;
  int v20;
  int valuePtr;
  CFTypeRef cf;

  CGColorSRGBFromArray = theDict;
  cf = 0;
  if (!theDict)
  {
    Mutable = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
LABEL_16:
    v15 = Mutable;
    goto LABEL_17;
  }
  if (a2)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("TextEmphasisStyle"));
    valuePtr = 0;
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
    v7 = valuePtr;
    if (valuePtr == 2)
    {
      v11 = (const __CFNumber *)CFDictionaryGetValue(CGColorSRGBFromArray, CFSTR("TextEmphasisCustomMarkingStyle"));
      v12 = (const __CFNumber *)CFDictionaryGetValue(CGColorSRGBFromArray, CFSTR("TextEmphasisPredefinedMark"));
      v20 = 0;
      CFNumberGetValue(v11, kCFNumberSInt32Type, &v20);
      v9 = v20;
      v19 = 0;
      CFNumberGetValue(v12, kCFNumberSInt32Type, &v19);
      v8 = 0;
      v10 = v19;
    }
    else if (valuePtr == 3)
    {
      v8 = CFDictionaryGetValue(CGColorSRGBFromArray, CFSTR("TextEmphasisCustomMark"));
      v9 = 0;
      v10 = 0;
    }
    else
    {
      v9 = 0;
      v10 = 0;
      v8 = 0;
    }
    v13 = CFDictionaryGetValue(CGColorSRGBFromArray, CFSTR("TextEmphasisColor"));
    v14 = CFDictionaryGetValue(CGColorSRGBFromArray, CFSTR("TextEmphasisRubyPosition"));
    if (v13)
    {
      CGColorSRGBFromArray = FigCreateCGColorSRGBFromArray(v13);
      if (!CGColorSRGBFromArray)
      {
        v15 = 0;
        goto LABEL_17;
      }
    }
    else
    {
      CGColorSRGBFromArray = 0;
    }
    v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = FigCaptionTextEmphasisCreate(*MEMORY[0x1E0C9AE00], v7, v9, v10, v8, CGColorSRGBFromArray, v14, &cf);
    if (!(_DWORD)Mutable)
    {
      if (*a2)
        Mutable = FigCaptionDynamicStyleAddKeyFrameValue(*a2, cf, a3);
      else
        Mutable = FigCaptionDynamicStyleCreateMutable(v16, cf, a2);
    }
    goto LABEL_16;
  }
  v15 = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  CGColorSRGBFromArray = 0;
LABEL_17:
  CGColorRelease(CGColorSRGBFromArray);
  if (cf)
    CFRelease(cf);
  return v15;
}

uint64_t fcs_createDynamicStyleFromPListTextShadow(const void *a1, uint64_t *a2, double a3)
{
  const __CFArray *Value;
  const __CFArray *v6;
  void *CGColorSRGBFromArray;
  CFIndex v8;
  const __CFArray *Mutable;
  void *ValueAtIndex;
  CFTypeID v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const __CFAllocator *v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  const __CFArray *v19;
  const void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  uint64_t v26;
  const __CFAllocator *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v31;
  uint64_t *v32;
  CFAllocatorRef v34;
  __CFArray *theArray;
  CFTypeRef v36;
  CFTypeRef v37;

  v36 = 0;
  v37 = 0;
  if (!a1 || !a2)
  {
    v29 = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
    Mutable = 0;
LABEL_45:
    CGColorSRGBFromArray = 0;
    goto LABEL_31;
  }
  v34 = CFGetAllocator(a1);
  Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("TextShadowList"));
  v32 = a2;
  if (Value)
  {
    v6 = Value;
    if (CFArrayGetCount(Value) >= 1)
    {
      CGColorSRGBFromArray = 0;
      v8 = 0;
      Mutable = 0;
      while (1)
      {
        if (v36)
        {
          CFRelease(v36);
          v36 = 0;
        }
        if (CGColorSRGBFromArray)
          CFRelease(CGColorSRGBFromArray);
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(v6, v8);
        CGColorSRGBFromArray = ValueAtIndex;
        if (!ValueAtIndex)
        {
          v28 = FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
          goto LABEL_30;
        }
        v11 = CFGetTypeID(ValueAtIndex);
        if (v11 != CFDictionaryGetTypeID())
        {
          v31 = 0xFFFFFFFFLL;
          goto LABEL_44;
        }
        v12 = CFDictionaryGetValue((CFDictionaryRef)CGColorSRGBFromArray, CFSTR("TextShadowHorizontalAxisOffset"));
        v13 = CFDictionaryGetValue((CFDictionaryRef)CGColorSRGBFromArray, CFSTR("TextShadowVerticalAxisOffset"));
        v14 = CFDictionaryGetValue((CFDictionaryRef)CGColorSRGBFromArray, CFSTR("TextShadowBlurRadius"));
        CGColorSRGBFromArray = (void *)CFDictionaryGetValue((CFDictionaryRef)CGColorSRGBFromArray, CFSTR("TextShadowColor"));
        if (!Mutable)
        {
          v15 = CFGetAllocator(a1);
          Mutable = CFArrayCreateMutable(v15, 0, MEMORY[0x1E0C9B378]);
          if (!Mutable)
            break;
        }
        theArray = Mutable;
        v17 = 0x100000000;
        v16 = 0;
        if (v12)
        {
          v16 = FigGeometryDimensionMakeFromDictionary(v12);
          v17 = v18;
        }
        v19 = v6;
        v21 = 0x100000000;
        v20 = 0;
        if (v13)
        {
          v20 = FigGeometryDimensionMakeFromDictionary(v13);
          v21 = v22;
        }
        v23 = 0x100000000;
        v24 = 0;
        if (v14)
        {
          v24 = FigGeometryDimensionMakeFromDictionary(v14);
          v23 = v25;
        }
        if (CGColorSRGBFromArray)
        {
          CGColorSRGBFromArray = FigCreateCGColorSRGBFromArray(CGColorSRGBFromArray);
          if (!CGColorSRGBFromArray)
          {
            v29 = 0;
            goto LABEL_42;
          }
        }
        v26 = FigCaptionTextShadowCreate((uint64_t)v34, (uint64_t)v16, v17, (uint64_t)v20, v21, (uint64_t)v24, v23, (CGColor *)CGColorSRGBFromArray, &v36);
        if ((_DWORD)v26)
        {
          v29 = v26;
LABEL_42:
          Mutable = theArray;
          goto LABEL_31;
        }
        Mutable = theArray;
        CFArrayAppendValue(theArray, v36);
        ++v8;
        v6 = v19;
        if (v8 >= CFArrayGetCount(v19))
          goto LABEL_26;
      }
      v31 = 4294949616;
LABEL_44:
      v29 = FigSignalErrorAt(v31, 0, 0, 0, 0, 0, 0);
      goto LABEL_45;
    }
  }
  Mutable = 0;
  CGColorSRGBFromArray = 0;
LABEL_26:
  v27 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v28 = FigCaptionTextShadowListCreate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], Mutable, (uint64_t *)&v37);
  if (!(_DWORD)v28)
  {
    if (*v32)
      v28 = FigCaptionDynamicStyleAddKeyFrameValue(*v32, v37, a3);
    else
      v28 = FigCaptionDynamicStyleCreateMutable(v27, v37, v32);
  }
LABEL_30:
  v29 = v28;
LABEL_31:
  CGColorRelease((CGColorRef)CGColorSRGBFromArray);
  if (v36)
    CFRelease(v36);
  if (Mutable)
    CFRelease(Mutable);
  if (v37)
    CFRelease(v37);
  return v29;
}

uint64_t fcs_createDynamicStyleFromPListRubyReserve(const __CFDictionary *a1, uint64_t *a2, double a3)
{
  const void *Value;
  const void *v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  const __CFAllocator *v11;
  uint64_t Mutable;
  uint64_t v13;
  CFTypeRef cf;

  cf = 0;
  if (a1 && a2)
  {
    Value = CFDictionaryGetValue(a1, CFSTR("RubyReserveRubyPosition"));
    v7 = CFDictionaryGetValue(a1, CFSTR("RubyReserveLength"));
    if (v7)
    {
      v8 = FigGeometryDimensionMakeFromDictionary(v7);
      v10 = v9;
    }
    else
    {
      v8 = 0;
      v10 = 0;
    }
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = FigCaptionRubyReserveCreate(*MEMORY[0x1E0C9AE00], Value, (uint64_t)v8, v10, &cf);
    if (!(_DWORD)Mutable)
    {
      if (*a2)
        Mutable = FigCaptionDynamicStyleAddKeyFrameValue(*a2, cf, a3);
      else
        Mutable = FigCaptionDynamicStyleCreateMutable(v11, cf, a2);
    }
  }
  else
  {
    Mutable = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  }
  v13 = Mutable;
  if (cf)
    CFRelease(cf);
  return v13;
}

uint64_t fcs_createDynamicStyleFromPListAbstractPosition(const __CFDictionary *a1, uint64_t *a2, double a3)
{
  const void *Value;
  const void *v7;
  const void *v8;
  const void *v9;
  int CaptionPositionEdgeReferenceForEdgeReferenceSerializedValue;
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  uint64_t v16;
  const __CFAllocator *v17;
  uint64_t Mutable;
  uint64_t v19;
  CFTypeRef cf;

  cf = 0;
  if (a1 && a2)
  {
    Value = CFDictionaryGetValue(a1, CFSTR("HorizontalEdge"));
    v7 = CFDictionaryGetValue(a1, CFSTR("VerticalEdge"));
    v8 = CFDictionaryGetValue(a1, CFSTR("HorizontalOffset"));
    v9 = CFDictionaryGetValue(a1, CFSTR("VerticalOffset"));
    if (Value)
      CaptionPositionEdgeReferenceForEdgeReferenceSerializedValue = fcs_getCaptionPositionEdgeReferenceForEdgeReferenceSerializedValue(Value);
    else
      CaptionPositionEdgeReferenceForEdgeReferenceSerializedValue = 0;
    v11 = 0;
    v12 = 0;
    if (v7)
      LODWORD(v7) = fcs_getCaptionPositionEdgeReferenceForEdgeReferenceSerializedValue(v7);
    v13 = 0;
    v14 = 0;
    if (v8)
    {
      v14 = FigGeometryDimensionMakeFromDictionary(v8);
      v13 = v15;
    }
    if (v9)
    {
      v11 = FigGeometryDimensionMakeFromDictionary(v9);
      v12 = v16;
    }
    v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = FigCaptionPositionCreate(*MEMORY[0x1E0C9AE00], CaptionPositionEdgeReferenceForEdgeReferenceSerializedValue, (uint64_t)v14, v13, (int)v7, (uint64_t)v11, v12, (uint64_t *)&cf);
    if (!(_DWORD)Mutable)
    {
      if (*a2)
        Mutable = FigCaptionDynamicStyleAddKeyFrameValue(*a2, cf, a3);
      else
        Mutable = FigCaptionDynamicStyleCreateMutable(v17, cf, a2);
    }
  }
  else
  {
    Mutable = FigSignalErrorAt(4294949615, 0, 0, 0, 0, 0, 0);
  }
  v19 = Mutable;
  if (cf)
    CFRelease(cf);
  return v19;
}

uint64_t fcs_getCaptionPositionEdgeReferenceForEdgeReferenceSerializedValue(const void *a1)
{
  if (CFEqual(a1, CFSTR("Bottom")))
    return 1651471476;
  if (CFEqual(a1, CFSTR("Center")))
    return 1667591796;
  if (CFEqual(a1, CFSTR("Left")))
    return 1818584692;
  if (CFEqual(a1, CFSTR("Right")))
    return 1919510376;
  if (CFEqual(a1, CFSTR("Top")))
    return 1953460256;
  return 0;
}

uint64_t FigCPECryptorStartServer()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigCPECryptorStartServer_block_invoke;
  block[3] = &unk_1E28E4018;
  block[4] = &v3;
  if (FigCPECryptorStartServer_sFigCPECryptorServerSetupOnce != -1)
    dispatch_once(&FigCPECryptorStartServer_sFigCPECryptorServerSetupOnce, block);
  v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t cryptorServer_HandleRemoteSyncMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t OpCode;
  uint64_t v7;
  uint64_t v8;
  CFTypeRef v9;
  uint64_t (*v10)(CFTypeRef, _BYTE *);
  uint64_t (*v11)(CFTypeRef, CFTypeRef *);
  uint64_t (*v12)(CFTypeRef, os_log_type_t *);
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  CFTypeRef v17;
  _QWORD *v18;
  uint64_t (*v19)(uint64_t, CFTypeRef, _QWORD, _BYTE *);
  uint64_t v20;
  uint64_t v21;
  CFTypeRef v22;
  uint64_t (*v23)(uint64_t, __CFString *, CFTypeRef);
  __CFString **v24;
  uint64_t v25;
  CFTypeID v26;
  CFTypeRef v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t (*v30)(CFTypeRef, uint64_t);
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  unsigned int v34;
  uint64_t v35;
  unsigned int v36;
  CFTypeRef *v37;
  uint64_t uint64;
  uint64_t v39;
  CFTypeRef v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t (*v43)(uint64_t, uint64_t, CFTypeRef, uint64_t);
  uint64_t v44;
  int64_t int64;
  int64_t v46;
  _QWORD *v47;
  uint64_t (*v48)(CFTypeRef, int64_t, int64_t, CFTypeRef *, _BYTE *);
  CFTypeRef v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t (*v55)(uint64_t, uint64_t, uint64_t, CFTypeRef *);
  uint64_t v56;
  CFTypeRef v57;
  uint64_t v58;
  uint64_t UInt32;
  uint64_t v60;
  CFTypeRef v61;
  _QWORD *v62;
  uint64_t (*v63)(uint64_t, CFTypeRef, uint64_t, _QWORD, _BYTE *);
  uint64_t v64;
  CFTypeRef v65;
  uint64_t v66;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v68;
  uint64_t v69;
  unsigned int v70;
  CFTypeRef *v71;
  uint64_t v72;
  uint64_t v73;
  CFTypeRef v74;
  _QWORD *v75;
  uint64_t (*v76)(uint64_t, uint64_t, CFTypeRef);
  CFTypeRef v77;
  uint64_t v78;
  CFTypeRef v79;
  uint64_t (*v80)(CFTypeRef);
  uint64_t v82;
  int v83;
  os_log_type_t v84;
  CFTypeRef v85;
  os_log_type_t type[4];
  _BYTE value[12];
  __int16 v88;
  uint64_t v89;
  CFTypeRef cf[17];

  cf[16] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  v83 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v83);
  if ((_DWORD)OpCode)
    return OpCode;
  v7 = 4294951138;
  if (v83 > 1768125048)
  {
    if (v83 > 1936418168)
    {
      if (v83 > 1936941411)
      {
        if (v83 != 1936941412)
        {
          if (v83 != 1952543603)
            return v7;
          cf[0] = 0;
          LOBYTE(v85) = 0;
          *(_QWORD *)value = 0;
          v44 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, cf);
          if (!(_DWORD)v44)
          {
            int64 = xpc_dictionary_get_int64(a2, "ExpectedState");
            v46 = xpc_dictionary_get_int64(a2, "NewState");
            v9 = cf[0];
            v47 = *(_QWORD **)(CMBaseObjectGetVTable((uint64_t)cf[0]) + 16);
            if (*v47 >= 6uLL)
            {
              v48 = (uint64_t (*)(CFTypeRef, int64_t, int64_t, CFTypeRef *, _BYTE *))v47[20];
              if (v48)
              {
                v7 = v48(v9, int64, v46, &v85, value);
                if ((_DWORD)v7)
                  goto LABEL_68;
                xpc_dictionary_set_BOOL(a3, "WasSetOutFlag", (_BYTE)v85 != 0);
                v13 = *(_QWORD *)value;
                v14 = "KeyRequestIDOut";
                goto LABEL_66;
              }
            }
            goto LABEL_67;
          }
          v7 = v44;
          v9 = cf[0];
LABEL_68:
          if (v9)
          {
            v49 = v9;
LABEL_151:
            CFRelease(v49);
            return v7;
          }
          return v7;
        }
        cf[0] = 0;
        *(_QWORD *)value = 0;
        v20 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, (CFTypeRef *)value);
        if ((_DWORD)v20)
          goto LABEL_119;
        v20 = FigXPCMessageCopyCFData(a2, "SubsampleAuxiliaryData", cf);
        if ((_DWORD)v20)
          goto LABEL_119;
        v21 = *(_QWORD *)value;
        v22 = cf[0];
        v23 = *(uint64_t (**)(uint64_t, __CFString *, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable(*(uint64_t *)value)
                                                                                     + 8)
                                                                         + 56);
        if (v23)
        {
          v24 = &kFigCPEBasicAESCryptorProperty_SubsampleAuxiliaryData;
          goto LABEL_118;
        }
      }
      else
      {
        if (v83 == 1936418169)
        {
          cf[0] = 0;
          *(_QWORD *)value = 0;
          v85 = 0;
          v15 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, &v85);
          if ((_DWORD)v15)
            goto LABEL_102;
          v15 = FigXPCMessageCopyCFData(a2, "KeyRequestResponse", value);
          if ((_DWORD)v15)
            goto LABEL_102;
          v15 = FigXPCMessageCopyCFDictionary(a2, "KeyResponseOptionsDictionary", cf);
          if ((_DWORD)v15)
            goto LABEL_102;
          v72 = (uint64_t)v85;
          v73 = *(_QWORD *)value;
          v74 = cf[0];
          v75 = *(_QWORD **)(CMBaseObjectGetVTable((uint64_t)v85) + 16);
          if (*v75 >= 4uLL)
          {
            v76 = (uint64_t (*)(uint64_t, uint64_t, CFTypeRef))v75[12];
            if (v76)
            {
              v15 = v76(v72, v73, v74);
              goto LABEL_102;
            }
          }
LABEL_103:
          v7 = 4294954514;
LABEL_104:
          if (cf[0])
            CFRelease(cf[0]);
          if (*(_QWORD *)value)
            CFRelease(*(CFTypeRef *)value);
          v49 = v85;
          if (v85)
            goto LABEL_151;
          return v7;
        }
        if (v83 != 1936421490)
          return v7;
        cf[0] = 0;
        *(_QWORD *)value = 0;
        v20 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, (CFTypeRef *)value);
        if ((_DWORD)v20)
          goto LABEL_119;
        v20 = FigXPCMessageCopyCFError(a2, "KeyRequestError", (const __CFDictionary **)cf);
        if ((_DWORD)v20)
          goto LABEL_119;
        v21 = *(_QWORD *)value;
        v22 = cf[0];
        v23 = *(uint64_t (**)(uint64_t, __CFString *, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable(*(uint64_t *)value)
                                                                                     + 8)
                                                                         + 56);
        if (v23)
        {
          v24 = kFigCPECryptorProperty_KeyRequestError;
LABEL_118:
          v20 = v23(v21, *v24, v22);
          goto LABEL_119;
        }
      }
    }
    else
    {
      if (v83 <= 1936092531)
      {
        if (v83 != 1768125049)
        {
          if (v83 != 1853058420)
            return v7;
          cf[0] = 0;
          *(_QWORD *)value = 0;
          LODWORD(v85) = 0;
          *(_DWORD *)type = 0;
          v8 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, cf);
          v9 = cf[0];
          if (!(_DWORD)v8)
          {
            v10 = *(uint64_t (**)(CFTypeRef, _BYTE *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)cf[0]) + 16)
                                                               + 8);
            if (!v10)
              goto LABEL_67;
            v8 = v10(v9, value);
            if (!(_DWORD)v8)
            {
              v11 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v9)
                                                                                 + 16)
                                                                     + 16);
              if (v11)
              {
                v8 = v11(v9, &v85);
                if (!(_DWORD)v8)
                {
                  v12 = *(uint64_t (**)(CFTypeRef, os_log_type_t *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v9)
                                                                                         + 16)
                                                                             + 280);
                  if (v12)
                  {
                    v7 = v12(v9, type);
                    if ((_DWORD)v7)
                      goto LABEL_68;
                    xpc_dictionary_set_uint64(a3, "NativeSession", *(uint64_t *)value);
                    xpc_dictionary_set_uint64(a3, "ExternalProtectionMethods", v85);
                    v13 = *(int *)type;
                    v14 = "CryptorType";
LABEL_66:
                    xpc_dictionary_set_uint64(a3, v14, v13);
                    goto LABEL_68;
                  }
                  goto LABEL_67;
                }
                goto LABEL_154;
              }
LABEL_67:
              v7 = 4294954514;
              goto LABEL_68;
            }
          }
LABEL_154:
          v7 = v8;
          goto LABEL_68;
        }
        v85 = 0;
        v66 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, &v85);
        if ((_DWORD)v66)
        {
          v7 = v66;
          v65 = v85;
          if (!v85)
            return v7;
        }
        else
        {
          if (dword_1EE142008)
          {
            *(_DWORD *)type = 0;
            v84 = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142000, 1, (int *)type, &v84);
            v68 = *(_DWORD *)type;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, v84))
              v70 = v68;
            else
              v70 = v68 & 0xFFFFFFFE;
            if (v70)
            {
              *(_DWORD *)value = 136315394;
              *(_QWORD *)&value[4] = "cryptorServer_Invalidate";
              v88 = 2048;
              v89 = (uint64_t)v85;
              v71 = (CFTypeRef *)_os_log_send_and_compose_impl();
              LOBYTE(v68) = type[0];
            }
            else
            {
              v71 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142000, 1u, 1, v71, v71 != cf, v68, 0, v69);
          }
          v65 = v85;
          if (!v85)
            return 4294954516;
          v80 = *(uint64_t (**)(CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v85) + 8) + 24);
          if (v80)
            v7 = v80(v65);
          else
            v7 = 4294954514;
        }
LABEL_150:
        v49 = v65;
        goto LABEL_151;
      }
      if (v83 != 1936092532)
      {
        if (v83 != 1936417136)
          return v7;
        cf[0] = 0;
        *(_QWORD *)value = 0;
        v85 = 0;
        v15 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, &v85);
        if ((_DWORD)v15)
          goto LABEL_102;
        uint64 = xpc_dictionary_get_uint64(a2, "SessionID");
        v15 = FigXPCMessageCopyCFData(a2, "KeyRequestResponse", cf);
        if ((_DWORD)v15)
          goto LABEL_102;
        v15 = FigXPCMessageCopyCFDictionary(a2, "KeyResponseOptionsDictionary", value);
        if ((_DWORD)v15)
          goto LABEL_102;
        v39 = (uint64_t)v85;
        v40 = cf[0];
        v41 = *(_QWORD *)value;
        v42 = *(_QWORD **)(CMBaseObjectGetVTable((uint64_t)v85) + 16);
        if (*v42 >= 8uLL)
        {
          v43 = (uint64_t (*)(uint64_t, uint64_t, CFTypeRef, uint64_t))v42[28];
          if (v43)
          {
            v15 = v43(v39, uint64, v40, v41);
LABEL_102:
            v7 = v15;
            goto LABEL_104;
          }
        }
        goto LABEL_103;
      }
      cf[0] = 0;
      *(_QWORD *)value = 0;
      v20 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, (CFTypeRef *)value);
      if ((_DWORD)v20)
        goto LABEL_119;
      v20 = FigXPCMessageCopyFormatDescription(a2, "FormatDescription", cf);
      if ((_DWORD)v20)
        goto LABEL_119;
      v21 = *(_QWORD *)value;
      v22 = cf[0];
      v23 = *(uint64_t (**)(uint64_t, __CFString *, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable(*(uint64_t *)value)
                                                                                   + 8)
                                                                       + 56);
      if (v23)
      {
        v24 = kFigCPEBasicAESCryptorProperty_VideoFormatDescription;
        goto LABEL_118;
      }
    }
LABEL_120:
    v7 = 4294954514;
LABEL_121:
    v77 = cf[0];
    if (!cf[0])
      goto LABEL_123;
    goto LABEL_122;
  }
  if (v83 > 1667981679)
  {
    if (v83 <= 1668310629)
    {
      if (v83 != 1667981680)
      {
        if (v83 != 1667982713)
          return v7;
        cf[0] = 0;
        *(_QWORD *)value = 0;
        v85 = 0;
        v15 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, &v85);
        if ((_DWORD)v15)
          goto LABEL_102;
        v15 = FigXPCMessageCopyCFDictionary(a2, "KeyRequestData", cf);
        if ((_DWORD)v15)
          goto LABEL_102;
        v16 = (uint64_t)v85;
        v17 = cf[0];
        v18 = *(_QWORD **)(CMBaseObjectGetVTable((uint64_t)v85) + 16);
        if (*v18 >= 4uLL)
        {
          v19 = (uint64_t (*)(uint64_t, CFTypeRef, _QWORD, _BYTE *))v18[11];
          if (v19)
          {
            v15 = v19(v16, v17, *MEMORY[0x1E0C9AE00], value);
            if (!(_DWORD)v15)
              v15 = FigXPCMessageSetCFData(a3, "SPCBytes", *(CFTypeRef *)value);
            goto LABEL_102;
          }
        }
        goto LABEL_103;
      }
      cf[0] = 0;
      *(_QWORD *)value = 0;
      v85 = 0;
      v50 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, (CFTypeRef *)value);
      if ((_DWORD)v50
        || (v51 = xpc_dictionary_get_uint64(a2, "SessionID"),
            v50 = FigXPCMessageCopyCFData(a2, "ReceiverContext", &v85),
            (_DWORD)v50))
      {
        v7 = v50;
      }
      else
      {
        v52 = *(_QWORD *)value;
        v53 = (uint64_t)v85;
        v54 = *(_QWORD **)(CMBaseObjectGetVTable(*(uint64_t *)value) + 16);
        if (*v54 >= 8uLL && (v55 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, CFTypeRef *))v54[27]) != 0)
        {
          v56 = v55(v52, v51, v53, cf);
          v57 = cf[0];
          if (!(_DWORD)v56)
          {
            v7 = FigXPCMessageSetCFData(a3, "KeyRequestResponse", cf[0]);
            v57 = cf[0];
            if (!cf[0])
              goto LABEL_130;
            goto LABEL_76;
          }
          v7 = v56;
          if (cf[0])
LABEL_76:
            CFRelease(v57);
        }
        else
        {
          v7 = 4294954514;
        }
      }
LABEL_130:
      v77 = v85;
      if (!v85)
      {
LABEL_123:
        v49 = *(CFTypeRef *)value;
        if (!*(_QWORD *)value)
          return v7;
        goto LABEL_151;
      }
LABEL_122:
      CFRelease(v77);
      goto LABEL_123;
    }
    if (v83 != 1668310630)
    {
      if (v83 != 1684632432)
        return v7;
      v31 = xpc_dictionary_get_uint64(a2, ".objectID");
      if (!v31)
        return 4294949726;
      v32 = v31;
      if (dword_1EE142008)
      {
        LODWORD(v85) = 0;
        type[0] = OS_LOG_TYPE_DEFAULT;
        v33 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142000, 1, (int *)&v85, type);
        v34 = v85;
        if (os_log_type_enabled(v33, type[0]))
          v36 = v34;
        else
          v36 = v34 & 0xFFFFFFFE;
        if (v36)
        {
          *(_DWORD *)value = 136315138;
          *(_QWORD *)&value[4] = "cryptorServer_Dispose";
          v37 = (CFTypeRef *)_os_log_send_and_compose_impl();
          LOBYTE(v34) = (_BYTE)v85;
        }
        else
        {
          v37 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142000, 1u, 1, v37, v37 != cf, v34, 0, v35);
      }
      return FigXPCServerDisassociateObjectWithConnection(a1, v32);
    }
    cf[0] = 0;
    *(_QWORD *)value = 0;
    v85 = 0;
    v58 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, &v85);
    if (!(_DWORD)v58)
    {
      v58 = FigXPCMessageCopyCFString(a2, ".PropertyName", cf);
      if (!(_DWORD)v58)
      {
        if (cf[0])
        {
          UInt32 = FigXPCMessageGetUInt32(a2, "Format");
          v60 = (uint64_t)v85;
          v61 = cf[0];
          v62 = *(_QWORD **)(CMBaseObjectGetVTable((uint64_t)v85) + 16);
          if (*v62 < 6uLL
            || (v63 = (uint64_t (*)(uint64_t, CFTypeRef, uint64_t, _QWORD, _BYTE *))v62[19]) == 0)
          {
            v7 = 4294954514;
LABEL_133:
            if (v85)
              CFRelease(v85);
            if (*(_QWORD *)value)
              CFRelease(*(CFTypeRef *)value);
            v49 = cf[0];
            if (cf[0])
              goto LABEL_151;
            return v7;
          }
          v58 = v63(v60, v61, UInt32, *MEMORY[0x1E0C9AE00], value);
          if (!(_DWORD)v58)
            v58 = FigXPCMessageSetCFObject(a3, ".Value", *(CFTypeRef *)value);
        }
        else
        {
          v58 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
        }
      }
    }
    v7 = v58;
    goto LABEL_133;
  }
  if (v83 != 778268793)
  {
    if (v83 == 779314548)
    {
      cf[0] = 0;
      v64 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, cf);
      v65 = cf[0];
      if (!(_DWORD)v64)
        v64 = FigXPCHandleStdSetPropertyMessage((uint64_t)cf[0], a2);
      v7 = v64;
      if (!v65)
        return v7;
      goto LABEL_150;
    }
    if (v83 != 1634431587)
      return v7;
    cf[0] = 0;
    *(_QWORD *)value = 0;
    v20 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, cf);
    if ((_DWORD)v20)
      goto LABEL_119;
    v25 = xpc_dictionary_get_uint64(a2, "FromCryptorID");
    v20 = FigXPCServerLookupAndRetainAssociatedObject(a1, v25, value, 0);
    if ((_DWORD)v20)
      goto LABEL_119;
    if (*(_QWORD *)value)
    {
      v26 = CFGetTypeID(*(CFTypeRef *)value);
      if (v26 == FigCPECryptorGetTypeID())
      {
        v27 = cf[0];
        v28 = *(_QWORD *)value;
        v29 = *(_QWORD **)(CMBaseObjectGetVTable((uint64_t)cf[0]) + 16);
        if (*v29 >= 6uLL)
        {
          v30 = (uint64_t (*)(CFTypeRef, uint64_t))v29[22];
          if (v30)
          {
            v20 = v30(v27, v28);
LABEL_119:
            v7 = v20;
            goto LABEL_121;
          }
        }
        goto LABEL_120;
      }
      v82 = 4294949726;
    }
    else
    {
      v82 = 4294951144;
    }
    v20 = FigSignalErrorAt(v82, 0, 0, 0, 0, 0, 0);
    goto LABEL_119;
  }
  cf[0] = 0;
  v78 = cryptorServer_CopyCryptorByObjectIDForConnection(a1, a2, cf);
  v79 = cf[0];
  if (!(_DWORD)v78)
    v78 = FigXPCHandleStdCopyPropertyMessage((uint64_t)cf[0], a2, a3);
  v7 = v78;
  if (v79)
  {
    v49 = v79;
    goto LABEL_151;
  }
  return v7;
}

uint64_t cryptorServer_HandleRemoteAsyncMessage(_xpc_connection_s *a1, void *a2)
{
  return cryptorServer_HandleRemoteSyncMessage(a1, a2, 0);
}

uint64_t cryptorServer_NoteEnqueueDecisionFunction(const void *a1)
{
  uint64_t result;

  if (CFEqual(a1, CFSTR("264E32A6-4322-4670-8D0F-96A237DA6D06")))
    return 3;
  if (CFEqual(a1, CFSTR("KeyResponseErrorOccurred")))
    return 3;
  result = CFEqual(a1, CFSTR("KeyRequestErrorOccurred"));
  if ((_DWORD)result)
    return 3;
  return result;
}

uint64_t FigCPECryptorServerGetIDForCryptorByAssociatingWithClientPID(const void *a1, int a2, _QWORD *a3)
{
  if (a1 && a2 && a3)
    return FigXPCServerAssociateCopiedObjectWithNeighborProcessByPID(gFigCPECryptorServer, a2, a1, 0, 0, (uint64_t)cryptorServer_NotificationFilter, a3);
  else
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
}

BOOL cryptorServer_NotificationFilter(int a1, int a2, CFTypeRef cf1)
{
  return FigCFEqual(cf1, CFSTR("264E32A6-4322-4670-8D0F-96A237DA6D06"))
      || FigCFEqual(cf1, CFSTR("KeyResponseErrorOccurred"))
      || FigCFEqual(cf1, CFSTR("KeyRequestErrorOccurred")) != 0;
}

uint64_t FigCPECryptorServerGetIDForCryptorByAssociatingWithClientConnection(const void *a1, _xpc_connection_s *a2, _QWORD *a3)
{
  if (!gFigCPECryptorServer)
    return 4294949721;
  if (a1 && a2 && a3)
    return FigXPCServerAssociateCopiedObjectWithNeighborProcess(gFigCPECryptorServer, a2, a1, 0, 0, (uint64_t)cryptorServer_NotificationFilter, a3);
  return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCPECryptorServerDisassociateCryptorWithClientPID(uint64_t a1, int a2)
{
  if (a1 && a2)
    return FigXPCServerDisassociateObjectWithNeighborClientPID(gFigCPECryptorServer, a2, a1);
  else
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCPECryptorServerDisassociateCryptorWithClientConnection(uint64_t a1, _xpc_connection_s *a2)
{
  if (a1 && a2)
    return FigXPCServerDisassociateObjectWithNeighborClientConnection(gFigCPECryptorServer, a2, a1);
  else
    return FigSignalErrorAt(4294949726, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCPECryptorServerCopyCryptorForID(void *a1, _QWORD *a2)
{
  if (gFigCPECryptorServer)
    return FigXPCServerRetainNeighborObjectFromID((uint64_t *)gFigCPECryptorServer, a1, a2);
  else
    return FigSignalErrorAt(4294949721, 0, 0, 0, 0, 0, 0);
}

BOOL FigCPECryptorServerExistsInProcess()
{
  return gFigCPECryptorServer != 0;
}

uint64_t cryptorServer_CopyCryptorByObjectIDForConnection(_xpc_connection_s *a1, xpc_object_t xdict, CFTypeRef *a3)
{
  uint64_t uint64;
  uint64_t v6;
  CFTypeID v7;
  uint64_t v8;
  uint64_t v10;
  CFTypeRef cf;

  cf = 0;
  uint64 = xpc_dictionary_get_uint64(xdict, ".objectID");
  if (!uint64)
    return 4294949726;
  v6 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, 0);
  if (!(_DWORD)v6)
  {
    if (cf)
    {
      v7 = CFGetTypeID(cf);
      if (v7 == FigCPECryptorGetTypeID())
      {
        v8 = 0;
        *a3 = CFRetain(cf);
        goto LABEL_6;
      }
      v10 = 4294949726;
    }
    else
    {
      v10 = 4294951144;
    }
    v6 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  v8 = v6;
LABEL_6:
  if (cf)
    CFRelease(cf);
  return v8;
}

void fsbxpc_sandboxClientReset(int a1)
{
  _QWORD block[4];
  int v2;

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __fsbxpc_sandboxClientReset_block_invoke;
  block[3] = &__block_descriptor_tmp_58;
  v2 = a1;
  dispatch_async((dispatch_queue_t)gFigSandboxRemoteXPCClient, block);
}

void __fsbxpc_sandboxClientReset_block_invoke(uint64_t a1)
{
  int v1;
  uint64_t *v2;
  uint64_t *v3;
  CFMutableDictionaryRef *v4;

  v1 = *(_DWORD *)(a1 + 32);
  v2 = &qword_1ECDA8AF0;
  if (v1 != 2)
    v2 = 0;
  if (v1 == 1)
    v3 = &qword_1ECDA8AD8;
  else
    v3 = v2;
  if (byte_1ECDA8B08)
    v4 = (CFMutableDictionaryRef *)&qword_1ECDA8AD8;
  else
    v4 = (CFMutableDictionaryRef *)v3;
  if (v4)
  {
    CFDictionaryRemoveAllValues(*v4);
    CFDictionaryRemoveAllValues(v4[1]);
    CFSetRemoveAllValues(v4[2]);
  }
}

uint64_t FigSandboxRegisterURLWithProcess(const __CFURL *a1, unsigned int a2, int a3)
{
  return FigSandboxRegisterURLWithProcessAndCopyRegistration(a1, a2, a3, 0);
}

uint64_t FigSandboxRegisterURLWithProcessAndCopyRegistration(const __CFURL *a1, unsigned int a2, int a3, uint64_t a4)
{
  uint64_t result;

  if (FigFileIsFileOnExternalStorageDevice(a1))
    return fsbxpc_sandboxRegisterURLWithProcessCommon(a1, 1, 0, a2, a3, a4);
  result = fsbxpc_sandboxRegisterURLWithProcessCommon(a1, 1, 1, a2, a3, a4);
  if ((_DWORD)result)
    return fsbxpc_sandboxRegisterURLWithProcessCommon(a1, 1, 0, a2, a3, a4);
  return result;
}

uint64_t fsbxpc_sandboxRegisterURLWithProcessCommon(CFURLRef anURL, int a2, int a3, unsigned int a4, int a5, uint64_t a6)
{
  const __CFURL *v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFURL *v14;
  const __CFAllocator *v15;
  const __CFString *v16;
  const __CFURL *v17;
  const __CFURL *v18;
  const __CFURL *PathComponent;
  CFStringRef v20;
  BOOL v21;
  uint64_t v22;
  int v24;
  uint64_t v25;
  _QWORD block[7];
  unsigned int v27;
  int v28;
  BOOL v29;
  char v30;
  char v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  int v35;

  v32 = 0;
  v33 = &v32;
  v34 = 0x2000000000;
  v35 = 0;
  if (anURL && a4 <= 1)
  {
    v11 = anURL;
    if (fsbxpc_sandboxClientOneTimeInitialization_static_init != -1)
      dispatch_once(&fsbxpc_sandboxClientOneTimeInitialization_static_init, &__block_literal_global_47);
    v12 = CFURLCopyScheme(v11);
    v13 = v12;
    if (v12)
    {
      if (CFStringCompare(v12, CFSTR("file"), 1uLL))
      {
LABEL_22:
        CFRelease(v13);
        goto LABEL_23;
      }
      v14 = 0;
    }
    else
    {
      v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v16 = CFURLGetString(v11);
      v11 = CFURLCreateWithFileSystemPath(v15, v16, kCFURLPOSIXPathStyle, a2 == 0);
      v14 = v11;
      if (!v11)
      {
        v24 = FigSignalErrorAt(4294949791, 0, 0, 0, 0, 0, 0);
        *((_DWORD *)v33 + 6) = v24;
        goto LABEL_23;
      }
    }
    v25 = a6;
    v17 = CFURLCopyAbsoluteURL(v11);
    v18 = v17;
    if (a2 && a3)
    {
      PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v17);
      v20 = CFURLCopyFileSystemPath(PathComponent, kCFURLPOSIXPathStyle);
      v21 = 1;
    }
    else
    {
      v21 = a2 == 0;
      v20 = CFURLCopyFileSystemPath(v17, kCFURLPOSIXPathStyle);
      PathComponent = 0;
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __fsbxpc_sandboxRegisterURLWithProcessCommon_block_invoke;
    block[3] = &unk_1E28E4060;
    block[4] = &v32;
    block[5] = v20;
    v29 = v21;
    v27 = a4;
    v28 = a5;
    v30 = a2;
    v31 = a3;
    block[6] = v25;
    dispatch_sync((dispatch_queue_t)gFigSandboxRemoteXPCClient, block);
    if (v14)
      CFRelease(v14);
    if (v18)
      CFRelease(v18);
    if (PathComponent)
      CFRelease(PathComponent);
    if (v20)
      CFRelease(v20);
    if (v13)
      goto LABEL_22;
  }
LABEL_23:
  v22 = *((unsigned int *)v33 + 6);
  _Block_object_dispose(&v32, 8);
  return v22;
}

uint64_t FigSandboxRegisterDirectoryURLWithProcess(const __CFURL *a1, unsigned int a2, int a3)
{
  return fsbxpc_sandboxRegisterURLWithProcessCommon(a1, 0, 0, a2, a3, 0);
}

uint64_t FigSandboxRegisterDirectoryURLWithProcessAndCopyRegistration(const __CFURL *a1, unsigned int a2, int a3, uint64_t a4)
{
  return fsbxpc_sandboxRegisterURLWithProcessCommon(a1, 0, 0, a2, a3, a4);
}

uint64_t FigSandboxRegisterURLAndCopyRegistration(const __CFURL *a1, unsigned int a2, uint64_t a3)
{
  return FigSandboxRegisterURLWithProcessAndCopyRegistration(a1, a2, 2, a3);
}

uint64_t FigSandboxRegisterURL(const __CFURL *a1, unsigned int a2)
{
  return FigSandboxRegisterURLWithProcessAndCopyRegistration(a1, a2, 2, 0);
}

uint64_t FigSandboxRegisterDirectoryURLAndCopyRegistration(const __CFURL *a1, unsigned int a2, uint64_t a3)
{
  return fsbxpc_sandboxRegisterURLWithProcessCommon(a1, 0, 0, a2, 2, a3);
}

uint64_t FigSandboxRegisterDirectoryURL(const __CFURL *a1, unsigned int a2)
{
  return fsbxpc_sandboxRegisterURLWithProcessCommon(a1, 0, 0, a2, 2, 0);
}

uint64_t FigSandboxAssertionGetTypeID()
{
  if (sRegisterFigSandboxAssertionTypeOnce != -1)
    dispatch_once_f(&sRegisterFigSandboxAssertionTypeOnce, 0, (dispatch_function_t)RegisterFigSandboxAssertionType);
  return sFigSandboxAssertionID;
}

uint64_t RegisterFigSandboxAssertionType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigSandboxAssertionID = result;
  return result;
}

uint64_t FigSandboxAssertionCreateForPID(int a1, uint64_t a2, uint64_t *a3)
{
  uint64_t Instance;
  uint64_t v7;
  uint64_t result;

  if (sRegisterFigSandboxAssertionTypeOnce != -1)
    dispatch_once_f(&sRegisterFigSandboxAssertionTypeOnce, 0, (dispatch_function_t)RegisterFigSandboxAssertionType);
  Instance = _CFRuntimeCreateInstance();
  v7 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 16) = a1;
    *(_QWORD *)(Instance + 24) = a2;
    FigSandboxServerXPC_AddAssertionForPID(a1, a2);
    result = 0;
  }
  else
  {
    result = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  *a3 = v7;
  return result;
}

void __fsbxpc_sandboxRegisterURLWithProcessCommon_block_invoke(uint64_t a1)
{
  const __CFString *v2;
  Boolean v3;
  _BOOL4 v4;
  int v5;
  int v6;
  _QWORD *v7;
  const __CFAllocator *v8;
  CFURLRef v9;
  CFURLRef v10;
  uint64_t *v11;
  uint64_t *v12;
  __CFDictionary **v13;
  __CFDictionary *v14;
  id *v15;
  id *v16;
  char *v17;
  int v18;
  uint64_t v19;
  const __CFString *v20;
  char *v21;
  const __CFString *PathComponent;
  const __CFString *v23;
  char *CStringPtrAndBufferToFree;
  const char *v25;
  size_t v26;
  uint64_t *v27;
  uint64_t v28;
  CFTypeRef v29;
  const void *v30;
  CFTypeRef v31;
  uint64_t *v32;
  uint64_t v33;
  const __CFString *v34;
  const __CFURL *cf;
  const __CFURL *url;
  _QWORD *v37;
  void *value;
  CFTypeRef v39;
  void *v40;
  char v41[1024];
  char buffer[1024];
  char v43[1024];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v2 = *(const __CFString **)(a1 + 40);
  v3 = *(_BYTE *)(a1 + 64);
  if (*(_BYTE *)(a1 + 65))
    v4 = *(_BYTE *)(a1 + 66) != 0;
  else
    v4 = 0;
  v6 = *(_DWORD *)(a1 + 56);
  v5 = *(_DWORD *)(a1 + 60);
  v7 = *(_QWORD **)(a1 + 48);
  value = 0;
  v39 = 0;
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v9 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v2, kCFURLPOSIXPathStyle, v3);
  if (!v9)
  {
    v18 = FigSignalErrorAt(4294949790, 0, 0, 0, 0, 0, 0);
    v17 = 0;
    goto LABEL_72;
  }
  v10 = v9;
  v37 = v7;
  v11 = &qword_1ECDA8AF0;
  if (v5 != 2)
    v11 = 0;
  if (v5 == 1)
    v12 = &qword_1ECDA8AD8;
  else
    v12 = v11;
  if (byte_1ECDA8B08)
    v13 = (__CFDictionary **)&qword_1ECDA8AD8;
  else
    v13 = (__CFDictionary **)v12;
  if (!v13)
    goto LABEL_26;
  if (v6)
    ++v13;
  v14 = *v13;
  if (!*v13)
    goto LABEL_26;
  if (CFDictionaryGetValueIfPresent(v14, v2, (const void **)&value))
  {
    v15 = FigCFWeakReferenceHolderCopyReferencedObject((id *)value);
    if (v15)
    {
      v16 = v15;
      if (v37)
      {
        v17 = 0;
        v18 = 0;
        *v37 = v15;
      }
      else
      {
        if (byte_1ECDA8B08)
          v27 = &qword_1ECDA8AD8;
        else
          v27 = v12;
        if (v27)
          CFSetSetValue((CFMutableSetRef)v27[2], v15);
        CFRelease(v16);
        v17 = 0;
        v18 = 0;
      }
      goto LABEL_28;
    }
    CFDictionaryRemoveValue(v14, v2);
  }
  if (CFStringGetFileSystemRepresentation(v2, buffer, 1024) != 1)
  {
LABEL_26:
    v19 = 4294949791;
    goto LABEL_27;
  }
  if (v4 && access(buffer, 4))
  {
    v17 = 0;
    v18 = -17509;
LABEL_28:
    CFRelease(v10);
    goto LABEL_72;
  }
  if (!FigFileIsFileOnExternalStorageDevice(v10))
  {
    if (fsbxpc_open(buffer, 0, (uint64_t)v41))
      goto LABEL_57;
    goto LABEL_56;
  }
  bzero(v43, 0x400uLL);
  v40 = 0;
  url = CFURLCopyAbsoluteURL(v10);
  cf = CFURLCreateCopyDeletingLastPathComponent(v8, url);
  v20 = CFURLCopyFileSystemPath(cf, kCFURLPOSIXPathStyle);
  if (CFStringGetFileSystemRepresentation(v20, v43, 1024) != 1)
  {
    v21 = 0;
    goto LABEL_46;
  }
  v21 = (char *)fsbxpc_open(v43, 1074790400, (uint64_t)v41);
  if (!v21)
  {
LABEL_46:
    v23 = 0;
    goto LABEL_47;
  }
  v34 = v20;
  PathComponent = CFURLCopyLastPathComponent(url);
  v23 = PathComponent;
  if (PathComponent)
  {
    CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree(PathComponent, 0x8000100u, (char **)&v40);
    if (CStringPtrAndBufferToFree)
    {
      v25 = CStringPtrAndBufferToFree;
      *(_WORD *)&v21[strlen(v21)] = 47;
      v26 = strlen(v25);
      strncat(v21, v25, v26);
    }
  }
  v20 = v34;
LABEL_47:
  if (url)
    CFRelease(url);
  if (cf)
    CFRelease(cf);
  if (v20)
    CFRelease(v20);
  if (v23)
    CFRelease(v23);
  free(v40);
  if (!v21)
  {
LABEL_56:
    if (realpath_DARWIN_EXTSN(buffer, v41))
      goto LABEL_57;
    v19 = 4294949788;
LABEL_27:
    v18 = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
    v17 = 0;
    goto LABEL_28;
  }
LABEL_57:
  v17 = (char *)sandbox_extension_issue_file();
  if (!v17)
  {
    v33 = 4294949789;
    goto LABEL_79;
  }
  v28 = FigSandboxRegistrationRemoteCreate(v5, v17, v2, v14, gFigSandboxRemoteXPCClient, &v39);
  if ((_DWORD)v28)
  {
    v18 = v28;
    FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
    goto LABEL_28;
  }
  if (!v39 || (v29 = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)v39)) == 0)
  {
    v33 = 4294949790;
LABEL_79:
    v18 = FigSignalErrorAt(v33, 0, 0, 0, 0, 0, 0);
    goto LABEL_28;
  }
  v30 = v29;
  CFDictionarySetValue(v14, v2, v29);
  v31 = v39;
  if (v37)
  {
    *v37 = v39;
  }
  else
  {
    if (byte_1ECDA8B08)
      v32 = &qword_1ECDA8AD8;
    else
      v32 = v12;
    if (v32)
    {
      CFSetSetValue((CFMutableSetRef)v32[2], v39);
      v31 = v39;
    }
    if (!v31)
      goto LABEL_71;
    CFRelease(v31);
  }
  v39 = 0;
LABEL_71:
  CFRelease(v10);
  CFRelease(v30);
  v18 = 0;
LABEL_72:
  if (v39)
    CFRelease(v39);
  if (v17)
    free(v17);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v18;
}

uint64_t __fsbxpc_sandboxClientOneTimeInitialization_block_invoke()
{
  const __CFAllocator *v0;
  const CFDictionaryKeyCallBacks *v1;
  const CFDictionaryValueCallBacks *v2;
  uint64_t result;
  char v4;

  gFigSandboxRemoteXPCClient = (uint64_t)dispatch_queue_create("FigSandboxRemoteClientQueue", 0);
  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v1 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v2 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  qword_1ECDA8AE0 = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  qword_1ECDA8AD8 = (uint64_t)CFDictionaryCreateMutable(v0, 0, v1, v2);
  qword_1ECDA8AE8 = (uint64_t)CFSetCreateMutable(v0, 0, MEMORY[0x1E0C9B3B0]);
  result = FigRemote_ShouldConnectToMediaplaybackd();
  if ((_DWORD)result)
  {
    qword_1ECDA8AF8 = (uint64_t)CFDictionaryCreateMutable(v0, 0, v1, v2);
    qword_1ECDA8AF0 = (uint64_t)CFDictionaryCreateMutable(v0, 0, v1, v2);
    result = (uint64_t)CFSetCreateMutable(v0, 0, MEMORY[0x1E0C9B3B0]);
    v4 = 0;
    qword_1ECDA8B00 = result;
  }
  else
  {
    v4 = 1;
  }
  byte_1ECDA8B08 = v4;
  return result;
}

uint64_t fsbxpc_open(const char *a1, int a2, uint64_t a3)
{
  int v4;
  int v5;

  v4 = open(a1, a2);
  if (v4 == -1)
    return 0;
  v5 = v4;
  if (fcntl(v4, 50, a3) == -1)
    a3 = 0;
  close(v5);
  return a3;
}

uint64_t figSandboxAssertionInit(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  return result;
}

void figSandboxAssertionFinalize(uint64_t a1)
{
  FigSandboxServerXPC_RemoveAssertionForPID(*(_DWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
}

const __CFString *figSandboxAssertionCopyFormattingDesc()
{
  return CFSTR("[FigSandboxAssertion]");
}

__CFString *figSandboxAssertionCopyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigSandboxAssertion %p pid: %d server: %s>"), a1, *(unsigned int *)(a1 + 16), *(_QWORD *)(a1 + 24));
  return Mutable;
}

uint64_t CM8021ASClockGetTypeID()
{
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  return sFig8021ASClockID;
}

uint64_t RegisterFig8021ASClockIDType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFig8021ASClockID = result;
  return result;
}

uint64_t _CM8021ASClock_ExchangeTimeSyncFunctions(uint64_t a1)
{
  uint64_t v1;

  v1 = qword_1EE141BD8;
  qword_1EE141BD8 = a1;
  return v1;
}

uint64_t CM8021ASClockCreate(const __CFAllocator *a1, uint64_t *a2)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v5;
  uint64_t v6;
  unsigned int v7;
  _BYTE *v8;
  uint64_t Instance;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFUUIDRef v13;
  pthread_mutex_t *v14;
  pthread_mutex_t *v15;
  pthread_mutex_t **v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v24;
  CFMutableSetRef v25;
  CFMutableDictionaryRef v26;
  NSObject *v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  const char *v31;
  uint64_t v32;
  _BYTE *v33;
  NSObject *v34;
  int v35;
  uint64_t v36;
  unsigned int v37;
  _BYTE *v38;
  os_log_type_t type;
  int v41;
  int v42;
  const char *v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  uint64_t v49;
  _BYTE v50[128];
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (sTimeSyncFunctionsLoadedOnce_1 != -1)
    dispatch_once_f(&sTimeSyncFunctionsLoadedOnce_1, 0, (dispatch_function_t)LoadTimeSyncFunctions_1);
  if (dword_1EE142028)
  {
    v41 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v41, &type);
    v5 = v41;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v7 = v5;
    else
      v7 = v5 & 0xFFFFFFFE;
    if (v7)
    {
      v42 = 136315138;
      v43 = "CM8021ASClockCreate";
      v8 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = v41;
    }
    else
    {
      v8 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v8, v8 != v50, v5, 0, v6);
  }
  if (a2)
  {
    if (CM8021ASClockEnsureTimeSyncServices())
    {
      Instance = 0;
LABEL_14:
      v10 = 4294951236;
      goto LABEL_17;
    }
    if (sRegisterFig8021ASClockTypeOnce != -1)
      dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v13 = CFUUIDCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
      *(_QWORD *)(Instance + 112) = v13;
      if (v13)
      {
        v14 = FigSimpleMutexCreate();
        *(_QWORD *)(Instance + 64) = v14;
        if (!v14
          || (*(_BYTE *)(Instance + 96) = 0, v15 = FigSimpleMutexCreate(), (*(_QWORD *)(Instance + 32) = v15) == 0))
        {
          v12 = 4294951231;
          goto LABEL_19;
        }
        *(_QWORD *)(Instance + 24) = FigCFWeakReferenceHolderCreateWithReferencedObject(Instance);
        v16 = FigReadWriteLockCreate(0);
        *(_QWORD *)(Instance + 16) = v16;
        v18 = (*(uint64_t (**)(pthread_mutex_t **, uint64_t))(qword_1EE141BD8 + 88))(v16, v17);
        if (v18 == **(_QWORD **)qword_1EE141BD8)
          goto LABEL_14;
        v20 = (*(uint64_t (**)(uint64_t, uint64_t))(qword_1EE141BD8 + 32))(v18, v19);
        *(_QWORD *)(Instance + 48) = v20;
        if (!v20)
          goto LABEL_14;
        FigSimpleMutexLock(*(pthread_mutex_t **)(Instance + 32));
        (*(void (**)(_QWORD, void (*)(uint64_t, id *), _QWORD))(qword_1EE141BD8 + 104))(*(_QWORD *)(Instance + 48), fig8021ASClock_GrandmasterDidChange, *(_QWORD *)(Instance + 24));
        (*(void (**)(_QWORD, _QWORD, _QWORD))(qword_1EE141BD8 + 96))(*(_QWORD *)(Instance + 48), fig8021ASClock_LockStateDidChange, *(_QWORD *)(Instance + 24));
        v21 = (*(uint64_t (**)(_QWORD))(qword_1EE141BD8 + 72))(*(_QWORD *)(Instance + 48));
        *(_DWORD *)(Instance + 40) = v21;
        if (v21 == 2)
          v22 = (*(uint64_t (**)(_QWORD))(qword_1EE141BD8 + 80))(*(_QWORD *)(Instance + 48));
        else
          v22 = **(_QWORD **)(qword_1EE141BD8 + 8);
        *(_QWORD *)(Instance + 56) = v22;
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(Instance + 32));
        Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        *(_QWORD *)(Instance + 72) = Mutable;
        if (Mutable)
        {
          v24 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], &sFig8021ASClockPortsDictionaryValueCallBacks);
          *(_QWORD *)(Instance + 80) = v24;
          if (v24)
          {
            v25 = CFSetCreateMutable(a1, 0, MEMORY[0x1E0C9B3B0]);
            *(_QWORD *)(Instance + 88) = v25;
            if (v25)
            {
              v26 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              *(_QWORD *)(Instance + 104) = v26;
              if (v26)
              {
                if (!dword_1EE142028)
                {
LABEL_53:
                  v12 = 0;
                  *a2 = Instance;
                  return v12;
                }
                v41 = 0;
                type = OS_LOG_TYPE_DEFAULT;
                v27 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v41, &type);
                v28 = v41;
                if (os_log_type_enabled(v27, type))
                  v30 = v28;
                else
                  v30 = v28 & 0xFFFFFFFE;
                if (v30)
                {
                  v31 = "not locked";
                  v32 = *(_QWORD *)(Instance + 56);
                  if (*(_DWORD *)(Instance + 40) == 2)
                    v31 = "locked";
                  v42 = 136315906;
                  v43 = "CM8021ASClockCreate";
                  v44 = 2048;
                  v45 = Instance;
                  v46 = 2080;
                  v47 = v31;
                  v48 = 2048;
                  v49 = v32;
                  v33 = (_BYTE *)_os_log_send_and_compose_impl();
                  LOBYTE(v28) = v41;
                }
                else
                {
                  v33 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v33, v33 != v50, v28, 0, v29);
LABEL_45:
                if (dword_1EE142028)
                {
                  v41 = 0;
                  type = OS_LOG_TYPE_DEFAULT;
                  v34 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v41, &type);
                  v35 = v41;
                  if (os_log_type_enabled(v34, type))
                    v37 = v35;
                  else
                    v37 = v35 & 0xFFFFFFFE;
                  if (v37)
                  {
                    v42 = 136315394;
                    v43 = "CM8021ASClockCreate";
                    v44 = 2048;
                    v45 = Instance;
                    v38 = (_BYTE *)_os_log_send_and_compose_impl();
                    LOBYTE(v35) = v41;
                  }
                  else
                  {
                    v38 = 0;
                  }
                  fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v38, v38 != v50, v35, 0, v36);
                }
                goto LABEL_53;
              }
            }
          }
        }
      }
      v12 = 4294954549;
      goto LABEL_19;
    }
  }
  else
  {
    Instance = 0;
  }
  v10 = 4294951233;
LABEL_17:
  v11 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  if (!(_DWORD)v11)
    goto LABEL_45;
  v12 = v11;
  if (Instance)
LABEL_19:
    CFRelease((CFTypeRef)Instance);
  return v12;
}

void *LoadTimeSyncFunctions_1()
{
  unsigned int v0;
  void *v1;
  void *v2;
  void *result;

  v0 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFig8021ASClockTrace[1], CFSTR("8021as_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v0, 0, gFig8021ASClockTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1EE142028, CFSTR("8021as_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1EE142020);
  qword_1EE141BB8 = (uint64_t)timesyncLogMeanIntervalApplier_doesTimeDomainConformToSyncInterval;
  qword_1EE141BD8 = (uint64_t)&gFTable;
  v1 = dlopen("/System/Library/PrivateFrameworks/TimeSync.framework/TimeSync", 4);
  if (!v1)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  v2 = v1;
  gFTable = (uint64_t)dlsym(v1, "TSNullClockIdentifier");
  if (!gFTable)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141AD0 = (uint64_t)dlsym(v2, "TSNullgPTPClockIdentity");
  if (!qword_1EE141AD0)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141AD8 = (uint64_t)dlsym(v2, "TimeSyncAddgPTPServicesSync");
  if (!qword_1EE141AD8)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141AE0 = (uint64_t)dlsym(v2, "TimeSyncRemovegPTPServices");
  if (!qword_1EE141AE0)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141AE8 = (uint64_t)dlsym(v2, "TimeSyncClockCreateWithClockIdentifer");
  if (!qword_1EE141AE8)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141AF0 = (uint64_t)dlsym(v2, "TimeSyncClockDispose");
  if (!qword_1EE141AF0)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141AF8 = (uint64_t)dlsym(v2, "TimeSyncClockGetHostTimeAndGrandmasterIdentityForClockTime");
  if (!qword_1EE141AF8)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B00 = (uint64_t)dlsym(v2, "TimeSyncClockGetClockTimeAndGrandmasterIdentityForHostTime");
  if (!qword_1EE141B00)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B08 = (uint64_t)dlsym(v2, "TimeSyncClockGetClockRate");
  if (!qword_1EE141B08)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B10 = (uint64_t)dlsym(v2, "TimeSyncClockGetLockState");
  if (!qword_1EE141B10)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B18 = (uint64_t)dlsym(v2, "TimeSyncClockGetgPTPGrandmasterIdentity");
  if (!qword_1EE141B18)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B20 = (uint64_t)dlsym(v2, "TimeSyncSystemDomainClockIdentifier");
  if (!qword_1EE141B20)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B28 = (uint64_t)dlsym(v2, "TimeSyncClockSetLockStateChangeCallback");
  if (!qword_1EE141B28)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B30 = (uint64_t)dlsym(v2, "TimeSyncClockSetgPTPGrandmasterChangeCallback");
  if (!qword_1EE141B30)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B38 = (uint64_t)dlsym(v2, "TimeSyncClockAddUDPv4EndToEndPort");
  if (!qword_1EE141B38)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B40 = (uint64_t)dlsym(v2, "TimeSyncClockAddUDPv4EndToEndPortAndGetIdentity");
  if (!qword_1EE141B40)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B48 = (uint64_t)dlsym(v2, "TimeSyncClockRemoveUDPv4EndToEndPort");
  if (!qword_1EE141B48)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B50 = (uint64_t)dlsym(v2, "TimeSyncClockAddUDPv6EndToEndPort");
  if (!qword_1EE141B50)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B58 = (uint64_t)dlsym(v2, "TimeSyncClockAddUDPv6EndToEndPortAndGetIdentity");
  if (!qword_1EE141B58)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B60 = (uint64_t)dlsym(v2, "TimeSyncClockRemoveUDPv6EndToEndPort");
  if (!qword_1EE141B60)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B68 = (uint64_t)dlsym(v2, "TimeSyncClockAddAWDLPort");
  if (!qword_1EE141B68)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B70 = (uint64_t)dlsym(v2, "TimeSyncClockRemoveAWDLPort");
  if (!qword_1EE141B70)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B78 = (uint64_t)dlsym(v2, "TimeSyncClockOverridePortReceiveMatching");
  if (!qword_1EE141B78)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B80 = (uint64_t)dlsym(v2, "TimeSyncClockRestorePortReceiveMatching");
  if (!qword_1EE141B80)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B88 = (uint64_t)dlsym(v2, "TimeSyncPortCreateFromClock");
  if (!qword_1EE141B88)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B90 = (uint64_t)dlsym(v2, "TimeSyncPortDispose");
  if (!qword_1EE141B90)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141B98 = (uint64_t)dlsym(v2, "TimeSyncPortEnable");
  if (!qword_1EE141B98)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141BA0 = (uint64_t)dlsym(v2, "TimeSyncPortDisable");
  if (!qword_1EE141BA0)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141BC0 = (uint64_t)dlsym(v2, "TimeSyncPortSetRemoteSyncMessageIntervals");
  if (!qword_1EE141BC0)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141BA8 = (uint64_t)dlsym(v2, "TimeSyncClockGetClockRateAnchorsAndGrandmasterIdentity");
  if (!qword_1EE141BA8)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141BB0 = (uint64_t)dlsym(v2, "TimeSyncClockSetAllPortRemoteSyncMessageIntervals");
  if (!qword_1EE141BB0)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  qword_1EE141BC8 = (uint64_t)dlsym(v2, "TimeSyncGetClockMetricsWithSize");
  if (!qword_1EE141BC8)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  result = dlsym(v2, "TimeSyncGetPortMetricsWithSize");
  qword_1EE141BD0 = (uint64_t)result;
  if (!result)
    return (void *)FigSignalErrorAt(4294966630, 0, 0, 0, 0, 0, 0);
  return result;
}

uint64_t CM8021ASClockEnsureTimeSyncServices()
{
  int v0;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v2;
  uint64_t v3;
  unsigned int v4;
  char *v5;
  os_log_type_t type;
  int v8[2];
  const char *v9;
  __int16 v10;
  int v11;
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (sTimeSyncFunctionsLoadedOnce_1 != -1)
    dispatch_once_f(&sTimeSyncFunctionsLoadedOnce_1, 0, (dispatch_function_t)LoadTimeSyncFunctions_1);
  v0 = 0;
  while (((*(uint64_t (**)(uint64_t))(qword_1EE141BD8 + 16))(1000) & 1) == 0)
  {
    if (dword_1EE142028)
    {
      v8[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, v8, &type);
      v2 = v8[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v4 = v2;
      else
        v4 = v2 & 0xFFFFFFFE;
      if (v4)
      {
        v8[1] = 136315394;
        v9 = "CM8021ASClockEnsureTimeSyncServices";
        v10 = 1024;
        v11 = v0;
        v5 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v2) = v8[0];
      }
      else
      {
        v5 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v5, v5 != &v12, v2, 0, v3);
    }
    if (++v0 == 9)
      return 4294951236;
  }
  return 0;
}

void fig8021ASClock_GrandmasterDidChange(uint64_t a1, id *a2)
{
  id *v2;
  uint64_t *v3;
  NSObject *global_queue;
  CFNotificationCenterRef DefaultLocalCenter;
  _QWORD block[5];

  v2 = FigCFWeakReferenceHolderCopyReferencedObject(a2);
  v3 = (uint64_t *)v2;
  if (v2)
  {
    FigReadWriteLockLockForRead((uint64_t)v2[2]);
    global_queue = dispatch_get_global_queue(0, 0);
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    FigDispatchAsyncPostNotification(global_queue, DefaultLocalCenter, CFSTR("CM8021ASClockGrandmasterDidChange"), v3, 0, 0);
    FigReadWriteLockUnlockForRead(v3[2]);
  }
  else
  {
    global_queue = dispatch_get_global_queue(0, 0);
  }
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __fig8021ASClock_GrandmasterDidChange_block_invoke;
  block[3] = &__block_descriptor_tmp_96;
  block[4] = v3;
  dispatch_async(global_queue, block);
}

void fig8021ASClock_LockStateDidChange(id a1, id *a2, int a3)
{
  id *v5;
  id *v6;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v8;
  uint64_t v9;
  unsigned int v10;
  _BYTE *v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  const char *v20;
  _BYTE *v21;
  NSObject *global_queue;
  CFNotificationCenterRef DefaultLocalCenter;
  NSObject *v24;
  _QWORD block[5];
  os_log_type_t type;
  int v27;
  int v28;
  const char *v29;
  __int16 v30;
  id *v31;
  __int16 v32;
  id v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  uint64_t v37;
  _BYTE v38[128];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v5 = FigCFWeakReferenceHolderCopyReferencedObject(a2);
  v6 = v5;
  if (v5)
  {
    if (v5[6] == a1)
    {
      if (dword_1EE142028)
      {
        v27 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v27, &type);
        v8 = v27;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
          v10 = v8;
        else
          v10 = v8 & 0xFFFFFFFE;
        if (v10)
        {
          v28 = 136315650;
          v29 = "fig8021ASClock_LockStateDidChange";
          v30 = 2048;
          v31 = v6;
          v32 = 1024;
          LODWORD(v33) = a3;
          v11 = (_BYTE *)_os_log_send_and_compose_impl();
          LOBYTE(v8) = v27;
        }
        else
        {
          v11 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v11, v11 != v38, v8, 0, v9);
      }
      FigSimpleMutexLock((pthread_mutex_t *)v6[4]);
      v12 = v6[7];
      v13 = (*(uint64_t (**)(id))(qword_1EE141BD8 + 80))(v6[6]);
      *((_DWORD *)v6 + 10) = a3;
      v14 = v13;
      if (a3 != 2)
        v14 = **(_QWORD **)(qword_1EE141BD8 + 8);
      v6[7] = (id)v14;
      FigSimpleMutexUnlock((pthread_mutex_t *)v6[4]);
      if (dword_1EE142028)
      {
        v27 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        v15 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v27, &type);
        v16 = v27;
        if (os_log_type_enabled(v15, type))
          v18 = v16;
        else
          v18 = v16 & 0xFFFFFFFE;
        if (v18)
        {
          v19 = *((_DWORD *)v6 + 10);
          v20 = "not locked";
          v29 = "fig8021ASClock_LockStateDidChange";
          v28 = 136316162;
          v30 = 2048;
          if (v19 == 2)
            v20 = "locked";
          v31 = v6;
          v32 = 2048;
          v33 = v12;
          v34 = 2080;
          v35 = v20;
          v36 = 2048;
          v37 = v13;
          v21 = (_BYTE *)_os_log_send_and_compose_impl();
          LOBYTE(v16) = v27;
        }
        else
        {
          v21 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v21, v21 != v38, v16, 0, v17);
      }
      if (a3 != 1)
      {
        FigReadWriteLockLockForRead((uint64_t)v6[2]);
        global_queue = dispatch_get_global_queue(0, 0);
        DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        FigDispatchAsyncPostNotification(global_queue, DefaultLocalCenter, CFSTR("CM8021ASClockLockStateDidChange"), v6, 0, 0);
        FigReadWriteLockUnlockForRead((uint64_t)v6[2]);
      }
    }
    else
    {
      FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    }
  }
  v24 = dispatch_get_global_queue(0, 0);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __fig8021ASClock_LockStateDidChange_block_invoke;
  block[3] = &__block_descriptor_tmp_97;
  block[4] = v6;
  dispatch_async(v24, block);
}

uint64_t CM8021ASClockAddIPv4Port(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v6;

  if (!a1)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  v6 = CFGetTypeID(a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v6 != sFig8021ASClockID)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)a3 == 2130706433)
    return 0;
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(qword_1EE141BD8 + 112))(a1[6], a2, a3);
}

uint64_t CM8021ASClockAddIPv4PortAndGetIdentity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5)
{
  CFTypeID v10;
  uint64_t v11;
  uint64_t v12;
  UInt8 bytes[4];

  *(_DWORD *)bytes = a3;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  v10 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v10 != sFig8021ASClockID)
  {
    v12 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
LABEL_8:
    v11 = v12;
    goto LABEL_9;
  }
  if ((_DWORD)a3 != 2130706433)
  {
    v12 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, unsigned __int16 *))(qword_1EE141BD8 + 120))(*(_QWORD *)(a1 + 48), a2, a3, a4, a5);
    if (!(_DWORD)v12)
      v12 = fig8021ASClock_addPortNumberForAddress(a1, bytes, 2, *a5);
    goto LABEL_8;
  }
  v11 = 0;
LABEL_9:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  return v11;
}

uint64_t fig8021ASClock_addPortNumberForAddress(uint64_t a1, UInt8 *bytes, int a3, uint64_t a4)
{
  uint64_t v6;
  CFNumberRef UInt16;
  const void *v8;
  uint64_t v9;
  void *key;

  key = 0;
  v6 = fig8021ASClock_copyCFTypeRepresentationOfAddress(bytes, a3, (CFDataRef *)&key);
  if ((_DWORD)v6)
  {
    v9 = v6;
    UInt16 = 0;
    v8 = 0;
  }
  else
  {
    UInt16 = FigCFNumberCreateUInt16((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a4);
    if (UInt16)
    {
      v8 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t))(qword_1EE141BD8 + 192))(*(_QWORD *)(a1 + 48), a4);
      if (v8)
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), key, UInt16);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 80), UInt16, v8);
        v9 = 0;
      }
      else
      {
        v9 = FigSignalErrorAt(4294954549, 0, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      v8 = 0;
      v9 = 4294954549;
    }
  }
  if (key)
    CFRelease(key);
  if (UInt16)
    CFRelease(UInt16);
  if ((_DWORD)v9 && v8)
    (*(void (**)(const void *))(qword_1EE141BD8 + 200))(v8);
  return v9;
}

uint64_t CM8021ASClockRemoveIPv4Port(uint64_t a1, uint64_t a2, int a3)
{
  CFTypeID v6;
  uint64_t v7;
  uint64_t v8;
  UInt8 bytes[4];

  *(_DWORD *)bytes = a3;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  v6 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v6 != sFig8021ASClockID)
  {
    v8 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
LABEL_9:
    v7 = v8;
    goto LABEL_10;
  }
  if (a3 != 2130706433)
  {
    v8 = fig8021ASClock_addPortMetricsToMetricsDictForAddress(a1, bytes, 2);
    if (!(_DWORD)v8)
    {
      v8 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(qword_1EE141BD8 + 128))(*(_QWORD *)(a1 + 48), a2, *(unsigned int *)bytes);
      if (!(_DWORD)v8)
        v8 = fig8021ASClock_clearPortStateForAddress((CFDictionaryRef *)a1, bytes, 2);
    }
    goto LABEL_9;
  }
  v7 = 0;
LABEL_10:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  return v7;
}

uint64_t fig8021ASClock_addPortMetricsToMetricsDictForAddress(uint64_t a1, UInt8 *bytes, int a3)
{
  uint64_t v4;
  const __CFNumber *Value;
  const __CFNumber *v6;
  uint64_t UInt16;
  uint64_t v8;
  CFTypeRef cf;
  void *key;

  cf = 0;
  key = 0;
  v4 = fig8021ASClock_copyCFTypeRepresentationOfAddress(bytes, a3, (CFDataRef *)&key);
  if ((_DWORD)v4)
  {
    v8 = v4;
  }
  else
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), key);
    if (Value)
    {
      v6 = Value;
      UInt16 = FigCFNumberGetUInt16(Value);
      v8 = fig8021ASClock_copyPortMetricsForPortIfValid(a1, UInt16, &cf);
      if (!(_DWORD)v8)
        FigCFDictionarySetValue(*(void **)(a1 + 104), v6, cf);
    }
    else
    {
      v8 = 0;
    }
  }
  if (key)
    CFRelease(key);
  if (cf)
    CFRelease(cf);
  return v8;
}

uint64_t fig8021ASClock_clearPortStateForAddress(CFDictionaryRef *a1, UInt8 *bytes, int a3)
{
  uint64_t v4;
  const void *Value;
  const void *v6;
  void *key;

  key = 0;
  v4 = fig8021ASClock_copyCFTypeRepresentationOfAddress(bytes, a3, (CFDataRef *)&key);
  if (!(_DWORD)v4)
  {
    Value = CFDictionaryGetValue(a1[9], key);
    if (Value)
    {
      v6 = Value;
      CFSetRemoveValue(a1[11], Value);
      CFDictionaryRemoveValue(a1[10], v6);
      CFDictionaryRemoveValue(a1[9], key);
    }
  }
  if (key)
    CFRelease(key);
  return v4;
}

uint64_t CM8021ASClockAddIPv6Port(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeID v6;
  uint64_t v9;
  uint64_t v10;

  v9 = a3;
  v10 = a4;
  if (!a1)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  v6 = CFGetTypeID(a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v6 != sFig8021ASClockID)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  if (v9 == *MEMORY[0x1E0C83938] && v10 == *(_QWORD *)(MEMORY[0x1E0C83938] + 8))
    return 0;
  else
    return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t *))(qword_1EE141BD8 + 136))(a1[6], a2, &v9);
}

uint64_t CM8021ASClockAddIPv6PortAndGetIdentity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int16 *a6)
{
  CFTypeID v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;

  v15 = a3;
  v16 = a4;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  v10 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v10 == sFig8021ASClockID)
  {
    if (v15 == *MEMORY[0x1E0C83938] && v16 == *(_QWORD *)(MEMORY[0x1E0C83938] + 8))
    {
      v13 = 0;
      goto LABEL_12;
    }
    v12 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t *, uint64_t, unsigned __int16 *))(qword_1EE141BD8 + 144))(*(_QWORD *)(a1 + 48), a2, &v15, a5, a6);
    if (!(_DWORD)v12)
      v12 = fig8021ASClock_addPortNumberForAddress(a1, (UInt8 *)&v15, 30, *a6);
  }
  else
  {
    v12 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
  v13 = v12;
LABEL_12:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  return v13;
}

uint64_t CM8021ASClockRemoveIPv6Port(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeID v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;

  v11 = a3;
  v12 = a4;
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  v6 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v6 == sFig8021ASClockID)
  {
    if (v11 == *MEMORY[0x1E0C83938] && v12 == *(_QWORD *)(MEMORY[0x1E0C83938] + 8))
    {
      v9 = 0;
      goto LABEL_13;
    }
    v8 = fig8021ASClock_addPortMetricsToMetricsDictForAddress(a1, (UInt8 *)&v11, 30);
    if (!(_DWORD)v8)
    {
      v8 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t *))(qword_1EE141BD8 + 152))(*(_QWORD *)(a1 + 48), a2, &v11);
      if (!(_DWORD)v8)
        v8 = fig8021ASClock_clearPortStateForAddress((CFDictionaryRef *)a1, (UInt8 *)&v11, 30);
    }
  }
  else
  {
    v8 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
  v9 = v8;
LABEL_13:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  return v9;
}

uint64_t CM8021ASClockAddAWDLPort(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v6;

  if (!a1)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  v6 = CFGetTypeID(a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v6 != sFig8021ASClockID)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  (*(void (**)(_QWORD, uint64_t, uint64_t))(qword_1EE141BD8 + 160))(a1[6], a2, a3);
  return 0;
}

uint64_t CM8021ASClockRemoveAWDLPort(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v6;

  if (!a1)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  v6 = CFGetTypeID(a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v6 != sFig8021ASClockID)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  (*(void (**)(_QWORD, uint64_t, uint64_t))(qword_1EE141BD8 + 168))(a1[6], a2, a3);
  return 0;
}

uint64_t CM8021ASClockOverridePortReceiveMatching(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeID v8;

  if (!a1)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  v8 = CFGetTypeID(a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v8 == sFig8021ASClockID)
    return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(qword_1EE141BD8 + 176))(a1[6], a2, a3, a4);
  else
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
}

uint64_t CM8021ASClockRestorePortReceiveMatching(_QWORD *a1, uint64_t a2)
{
  CFTypeID v4;

  if (!a1)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  v4 = CFGetTypeID(a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v4 == sFig8021ASClockID)
    return (*(uint64_t (**)(_QWORD, uint64_t))(qword_1EE141BD8 + 184))(a1[6], a2);
  else
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
}

uint64_t CM8021ASClockEnablePort(uint64_t a1, int a2)
{
  CFNumberRef UInt16;
  CFTypeID v4;
  const void *Value;
  const void *v6;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v8;
  uint64_t v9;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  os_log_type_t type;
  int v15[2];
  const char *v16;
  char v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  UInt16 = FigCFNumberCreateUInt16((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  v4 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v4 == sFig8021ASClockID)
  {
    if (!UInt16)
    {
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
      return 4294954549;
    }
    if (CFSetContainsValue(*(CFSetRef *)(a1 + 88), UInt16))
    {
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), UInt16);
      if (Value)
      {
        v6 = Value;
        if (dword_1EE142028)
        {
          v15[0] = 0;
          type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, v15, &type);
          v8 = v15[0];
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
            v10 = v8;
          else
            v10 = v8 & 0xFFFFFFFE;
          if (v10)
          {
            v15[1] = 136315138;
            v16 = "CM8021ASClockEnablePort";
            v11 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v8) = v15[0];
          }
          else
          {
            v11 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v11, v11 != &v17, v8, 0, v9);
        }
        v12 = (*(uint64_t (**)(const void *))(qword_1EE141BD8 + 208))(v6);
        if (!(_DWORD)v12)
          CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 88), UInt16);
      }
      else
      {
        v12 = FigSignalErrorAt(4294954549, 0, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      v12 = 0;
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  }
  else
  {
    v12 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
    if (!UInt16)
      return v12;
  }
  CFRelease(UInt16);
  return v12;
}

uint64_t CM8021ASClockDisablePort(uint64_t a1, int a2)
{
  CFNumberRef UInt16;
  CFTypeID v4;
  const void *Value;
  const void *v6;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v8;
  uint64_t v9;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  os_log_type_t type;
  int v15[2];
  const char *v16;
  char v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  UInt16 = FigCFNumberCreateUInt16((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  v4 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v4 == sFig8021ASClockID)
  {
    if (!UInt16)
    {
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
      return 4294954549;
    }
    if (CFSetContainsValue(*(CFSetRef *)(a1 + 88), UInt16))
    {
      v12 = 0;
    }
    else
    {
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), UInt16);
      if (Value)
      {
        v6 = Value;
        CFSetAddValue(*(CFMutableSetRef *)(a1 + 88), UInt16);
        if (dword_1EE142028)
        {
          v15[0] = 0;
          type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, v15, &type);
          v8 = v15[0];
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
            v10 = v8;
          else
            v10 = v8 & 0xFFFFFFFE;
          if (v10)
          {
            v15[1] = 136315138;
            v16 = "CM8021ASClockDisablePort";
            v11 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v8) = v15[0];
          }
          else
          {
            v11 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v11, v11 != &v17, v8, 0, v9);
        }
        v12 = (*(uint64_t (**)(const void *))(qword_1EE141BD8 + 216))(v6);
        if ((_DWORD)v12)
          CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 88), UInt16);
      }
      else
      {
        v12 = FigSignalErrorAt(4294954549, 0, 0, 0, 0, 0, 0);
      }
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  }
  else
  {
    v12 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
    if (!UInt16)
      return v12;
  }
  CFRelease(UInt16);
  return v12;
}

uint64_t CM8021ASClockSetAllPortRemoteSyncMessageIntervals(uint64_t a1, CMTime *a2)
{
  long double Seconds;
  double v5;
  double v6;
  CFTypeID v7;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v9;
  uint64_t v10;
  unsigned int v11;
  CMTime *v12;
  os_log_type_t type;
  int v15;
  CMTime time2;
  int v17;
  const char *v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  CMTime time;
  void *v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  time = *a2;
  Seconds = CMTimeGetSeconds(&time);
  v5 = log10(Seconds);
  if (!a1)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  v6 = v5;
  v7 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v7 != sFig8021ASClockID)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  if ((a2->flags & 0x1D) != 1)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  CMTimeMakeWithSeconds(&time2, 0.125, 1000);
  time = *a2;
  if (CMTimeCompare(&time, &time2) < 0)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  if (dword_1EE142028)
  {
    v15 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v15, &type);
    v9 = v15;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v11 = v9;
    else
      v11 = v9 & 0xFFFFFFFE;
    if (v11)
    {
      v17 = 136315650;
      v18 = "CM8021ASClockSetAllPortRemoteSyncMessageIntervals";
      v19 = 2048;
      v20 = a1;
      v21 = 1024;
      v22 = (int)(v6 / 0.301029996);
      v12 = (CMTime *)_os_log_send_and_compose_impl();
      LOBYTE(v9) = v15;
    }
    else
    {
      v12 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v12, v12 != &time, v9, 0, v10);
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  if (!*(_BYTE *)(a1 + 96))
  {
    if (timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStarted_onceToken != -1)
      dispatch_once(&timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStarted_onceToken, &__block_literal_global_99);
    dispatch_async_f((dispatch_queue_t)gLogMeanIntervalApplier, 0, (dispatch_function_t)timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStartedInternal);
    *(_BYTE *)(a1 + 96) = 1;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
  time.value = MEMORY[0x1E0C809B0];
  *(_QWORD *)&time.timescale = 0x40000000;
  time.epoch = (CMTimeEpoch)__timesyncLogMeanIntervalApplier_setIntervalAndApplyIfDifferent_block_invoke;
  v24 = &__block_descriptor_tmp_110;
  v25 = (int)(v6 / 0.301029996);
  dispatch_async((dispatch_queue_t)gLogMeanIntervalApplier, &time);
  return 0;
}

uint64_t CM8021ASClockSetPortRemoteSyncMessageIntervals(uint64_t a1, int a2, CMTime *a3)
{
  long double Seconds;
  double v7;
  CFNumberRef UInt16;
  CFTypeID v9;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v11;
  uint64_t v12;
  unsigned int v13;
  CMTime *v14;
  const void *Value;
  const void *v16;
  NSObject *v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  CMTime *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  os_log_type_t type;
  int v27;
  CMTime time2;
  int v29;
  const char *v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  CMTime time;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  time = *a3;
  Seconds = CMTimeGetSeconds(&time);
  v7 = log10(Seconds);
  UInt16 = FigCFNumberCreateUInt16((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 64));
  v9 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v9 != sFig8021ASClockID)
  {
    v23 = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
    if (!UInt16)
      return v23;
    goto LABEL_27;
  }
  if (!UInt16)
  {
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
    return 4294954549;
  }
  if ((a3->flags & 0x1D) != 1
    || (CMTimeMakeWithSeconds(&time2, 0.125, 1000), time = *a3, CMTimeCompare(&time, &time2) < 0))
  {
    v25 = 4294954550;
  }
  else
  {
    if (dword_1EE142028)
    {
      v27 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v27, &type);
      v11 = v27;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v13 = v11;
      else
        v13 = v11 & 0xFFFFFFFE;
      if (v13)
      {
        v29 = 136315906;
        v30 = "CM8021ASClockSetPortRemoteSyncMessageIntervals";
        v31 = 2048;
        v32 = a1;
        v33 = 1024;
        v34 = a2;
        v35 = 1024;
        v36 = (int)(v7 / 0.301029996);
        v14 = (CMTime *)_os_log_send_and_compose_impl();
        LOBYTE(v11) = v27;
      }
      else
      {
        v14 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v14, v14 != &time, v11, 0, v12);
    }
    if (*(_BYTE *)(a1 + 96))
    {
      v25 = 4294954540;
    }
    else
    {
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), UInt16);
      if (Value)
      {
        v16 = Value;
        if (dword_1EE142028)
        {
          v27 = 0;
          type = OS_LOG_TYPE_DEFAULT;
          v17 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v27, &type);
          v18 = v27;
          if (os_log_type_enabled(v17, type))
            v20 = v18;
          else
            v20 = v18 & 0xFFFFFFFE;
          if (v20)
          {
            v29 = 136315138;
            v30 = "CM8021ASClockSetPortRemoteSyncMessageIntervals";
            v21 = (CMTime *)_os_log_send_and_compose_impl();
            LOBYTE(v18) = v27;
          }
          else
          {
            v21 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v21, v21 != &time, v18, 0, v19);
        }
        v22 = (*(uint64_t (**)(const void *, _QWORD))(qword_1EE141BD8 + 248))(v16, (int)(v7 / 0.301029996));
        goto LABEL_26;
      }
      v25 = 4294954549;
    }
  }
  v22 = FigSignalErrorAt(v25, 0, 0, 0, 0, 0, 0);
LABEL_26:
  v23 = v22;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 64));
LABEL_27:
  CFRelease(UInt16);
  return v23;
}

void CM8021ASClockGetClockTimeForHostTime(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X2>, CMTime *a4@<X8>)
{
  CFTypeID v8;
  uint64_t (*v9)(uint64_t, uint64_t, uint64_t *);
  uint64_t v10;
  uint64_t v11;
  int64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v16;
  uint64_t v17;
  unsigned int v18;
  Float64 Seconds;
  Float64 v20;
  CMTime *v21;
  os_log_type_t type;
  int v23;
  uint64_t v24;
  int v25;
  const char *v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  Float64 v30;
  __int16 v31;
  Float64 v32;
  __int16 v33;
  uint64_t v34;
  CMTime hostTime;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v24 = **(_QWORD **)(qword_1EE141BD8 + 8);
  *(_OWORD *)&a4->value = *(_OWORD *)&kCMTimeInvalid.value;
  a4->epoch = 0;
  if (!a1)
    goto LABEL_19;
  v8 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v8 == sFig8021ASClockID && (*(_BYTE *)(a2 + 12) & 1) != 0)
  {
    v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(qword_1EE141BD8 + 56);
    v10 = *(_QWORD *)(a1 + 48);
    hostTime = *(CMTime *)a2;
    v11 = CMClockConvertHostTimeToSystemUnits(&hostTime);
    v12 = v9(v10, v11, &v24);
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
    v13 = v24;
    v14 = *(_QWORD *)(a1 + 56);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
    if (v13 == v14 && v12 != -1)
    {
      CMTimeMake(a4, v12, 1000000000);
      if (a3)
        *a3 = v24;
    }
    if (dword_1EE142028 >= 2)
    {
      v23 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v23, &type);
      v16 = v23;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v18 = v16;
      else
        v18 = v16 & 0xFFFFFFFE;
      if (v18)
      {
        hostTime = *(CMTime *)a2;
        Seconds = CMTimeGetSeconds(&hostTime);
        hostTime = *a4;
        v20 = CMTimeGetSeconds(&hostTime);
        v25 = 136316162;
        v26 = "CM8021ASClockGetClockTimeForHostTime";
        v27 = 2048;
        v28 = a1;
        v29 = 2048;
        v30 = Seconds;
        v31 = 2048;
        v32 = v20;
        v33 = 2048;
        v34 = v24;
        v21 = (CMTime *)_os_log_send_and_compose_impl();
        LOBYTE(v16) = v23;
      }
      else
      {
        v21 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v21, v21 != &hostTime, v16, 0, v17);
    }
  }
  else
  {
LABEL_19:
    FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t CM8021ASClockGetHostTimeForClockTime@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X2>, CMTime *a4@<X8>)
{
  CFTypeID v8;
  uint64_t (*v9)(uint64_t, unint64_t, uint64_t *);
  uint64_t v10;
  Float64 Seconds;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  CMTime v16;
  uint64_t v17;

  v17 = **(_QWORD **)(qword_1EE141BD8 + 8);
  *(_OWORD *)&a4->value = *(_OWORD *)&kCMTimeInvalid.value;
  a4->epoch = 0;
  if (!a1)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  v8 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v8 != sFig8021ASClockID || (*(_BYTE *)(a2 + 12) & 1) == 0)
    return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
  v9 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t *))(qword_1EE141BD8 + 48);
  v10 = *(_QWORD *)(a1 + 48);
  v16 = *(CMTime *)a2;
  Seconds = CMTimeGetSeconds(&v16);
  v12 = v9(v10, (unint64_t)(Seconds * 1000000000.0), &v17);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
  v13 = v17;
  v14 = *(_QWORD *)(a1 + 56);
  result = FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
  if (v13 == v14 && v12 != -1)
  {
    result = (uint64_t)CMClockMakeHostTimeFromSystemUnits(a4, v12);
    if (a3)
      *a3 = v17;
  }
  return result;
}

CFStringRef CM8021ASClockCopySystemClockIdentifier()
{
  uint64_t v0;

  if (sTimeSyncFunctionsLoadedOnce_1 != -1)
    dispatch_once_f(&sTimeSyncFunctionsLoadedOnce_1, 0, (dispatch_function_t)LoadTimeSyncFunctions_1);
  v0 = (*(uint64_t (**)(void))(qword_1EE141BD8 + 88))();
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("ATSAC:%016llx"), v0);
}

BOOL CM8021ASClockIsLocked(uint64_t a1)
{
  return *(_DWORD *)(a1 + 40) == 2;
}

uint64_t CM8021ASClockCopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, _QWORD *a4)
{
  CFTypeID v8;
  uint64_t v9;
  __CFString *v10;
  __CFString *v11;
  uint64_t v12;
  uint64_t (*v13)(_QWORD, _QWORD *, _BYTE *, __int128 *, _QWORD *, uint64_t *);
  uint64_t v14;
  unsigned int (*v15)(_QWORD, __int128 *, uint64_t, _QWORD);
  uint64_t v16;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  _QWORD *v21;
  const __CFAllocator *v22;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v24;
  CFNumberRef UInt64;
  CFNumberRef v26;
  CFNumberRef v27;
  CFStringRef v28;
  CFDictionaryRef Copy;
  CFDictionaryRef v30;
  NSObject *v31;
  unsigned int v32;
  uint64_t v33;
  unsigned int v34;
  _QWORD *v35;
  __CFDictionary *v36;
  CFNumberRef UInt16;
  CFNumberRef v38;
  const __CFDictionary *v39;
  CFDictionaryRef v40;
  CFDictionaryRef v41;
  uint64_t v43;
  const __CFNumber *v44;
  CFNumberRef v45;
  CFNumberRef value;
  CFNumberRef cf;
  uint64_t v48;
  _QWORD context[5];
  os_log_type_t type;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  _BYTE v54[12];
  __int16 v55;
  uint64_t v56;
  __int16 v57;
  uint64_t v58;
  __int16 v59;
  uint64_t v60;
  __int16 v61;
  uint64_t v62;
  _QWORD v63[19];

  v63[16] = *MEMORY[0x1E0C80C00];
  if (!a1)
    goto LABEL_60;
  v8 = CFGetTypeID((CFTypeRef)a1);
  if (sRegisterFig8021ASClockTypeOnce != -1)
    dispatch_once_f(&sRegisterFig8021ASClockTypeOnce, 0, (dispatch_function_t)RegisterFig8021ASClockIDType);
  if (v8 != sFig8021ASClockID)
  {
LABEL_60:
    FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v9 = 4294951233;
  if (!a2 || !a4)
    return v9;
  if (!CFEqual(a2, CFSTR("CM8021ASClockDiagnosticString")))
  {
    if (!CFEqual(a2, CFSTR("CM8021ASClockMetrics")))
      return 4294951232;
    v15 = *(unsigned int (**)(_QWORD, __int128 *, uint64_t, _QWORD))(qword_1EE141BD8 + 256);
    if (!v15)
      goto LABEL_16;
    v53 = 0;
    v51 = 0u;
    v52 = 0u;
    if (v15(*(_QWORD *)(a1 + 48), &v51, 40, 0))
    {
      v16 = 4294951233;
LABEL_15:
      v9 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
      goto LABEL_16;
    }
    if (dword_1EE142028)
    {
      LODWORD(v48) = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, (int *)&v48, &type);
      v18 = v48;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v20 = v18;
      else
        v20 = v18 & 0xFFFFFFFE;
      if (v20)
      {
        *(_DWORD *)v54 = 136316162;
        *(_QWORD *)&v54[4] = "fig8021ASClock_copyClockMetricsForClock";
        v55 = 2048;
        v56 = v53;
        v57 = 2048;
        v58 = *((_QWORD *)&v51 + 1);
        v59 = 2048;
        v60 = v52;
        v61 = 2048;
        v62 = *((_QWORD *)&v52 + 1);
        v21 = (_QWORD *)_os_log_send_and_compose_impl();
        LOBYTE(v18) = v48;
      }
      else
      {
        v21 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v21, v21 != v63, v18, 0, v19);
    }
    v22 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!Mutable)
    {
      v16 = 4294951231;
      goto LABEL_15;
    }
    v24 = Mutable;
    value = FigCFNumberCreateUInt64(v22, v53);
    if (!value)
    {
      v9 = FigSignalErrorAt(4294951233, 0, 0, 0, 0, 0, 0);
      goto LABEL_71;
    }
    cf = FigCFNumberCreateUInt64(v22, *((uint64_t *)&v51 + 1));
    if (cf)
    {
      UInt64 = FigCFNumberCreateUInt64(v22, v52);
      if (UInt64 && (v26 = FigCFNumberCreateUInt64(v22, *((uint64_t *)&v52 + 1))) != 0)
      {
        v27 = v26;
        v28 = CFUUIDCreateString(v22, *(CFUUIDRef *)(a1 + 112));
        v45 = v27;
        if (v28)
        {
          CFDictionarySetValue(v24, CFSTR("CoreAudioReanchors"), value);
          CFDictionarySetValue(v24, CFSTR("GMChangesCount"), cf);
          CFDictionarySetValue(v24, CFSTR("TimeToChangeGM"), UInt64);
          CFDictionarySetValue(v24, CFSTR("TimeToLock"), v27);
          CFDictionarySetValue(v24, CFSTR("ClockUUID"), v28);
          Copy = CFDictionaryCreateCopy(v22, v24);
          if (Copy)
          {
            v30 = Copy;
            if (dword_1EE142028 >= 2)
            {
              v44 = UInt64;
              LODWORD(v48) = 0;
              type = OS_LOG_TYPE_DEFAULT;
              v31 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, (int *)&v48, &type);
              v32 = v48;
              if (os_log_type_enabled(v31, type))
                v34 = v32;
              else
                v34 = v32 & 0xFFFFFFFE;
              if (v34)
              {
                *(_DWORD *)v54 = 136315394;
                *(_QWORD *)&v54[4] = "fig8021ASClock_copyClockMetricsForClock";
                v55 = 2112;
                v56 = (uint64_t)v30;
                v35 = (_QWORD *)_os_log_send_and_compose_impl();
                LOBYTE(v32) = v48;
              }
              else
              {
                v35 = 0;
              }
              fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v35, v35 != v63, v32, 0, v33);
              UInt64 = v44;
            }
            v36 = (__CFDictionary *)CFRetain(v30);
            CFRelease(v24);
            CFRelease(v30);
            CFRelease(value);
            v9 = 0;
            goto LABEL_45;
          }
          v43 = 4294951231;
LABEL_68:
          v9 = FigSignalErrorAt(v43, 0, 0, 0, 0, 0, 0);
          CFRelease(v24);
          CFRelease(value);
          v36 = 0;
          v24 = 0;
          if (!cf)
          {
LABEL_46:
            if (UInt64)
              CFRelease(UInt64);
            if (v45)
              CFRelease(v45);
            if (v28)
              CFRelease(v28);
            if ((_DWORD)v9 || !v24)
            {
              if (!v24)
              {
LABEL_16:
                if ((_DWORD)v9)
                  return v9;
                goto LABEL_56;
              }
            }
            else
            {
              UInt16 = FigCFNumberCreateUInt16(v22, 0);
              if (UInt16)
              {
                v38 = UInt16;
                CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), UInt16, v24);
                v39 = *(const __CFDictionary **)(a1 + 72);
                context[0] = MEMORY[0x1E0C809B0];
                context[1] = 0x40000000;
                context[2] = __fig8021ASClock_getMetricsForClockAndAllPorts_block_invoke;
                context[3] = &__block_descriptor_tmp_122;
                context[4] = a1;
                FigCFDictionaryApplyBlock(v39, context);
                CFRelease(v24);
                CFRelease(v38);
LABEL_56:
                v40 = CFDictionaryCreateCopy(a3, *(CFDictionaryRef *)(a1 + 104));
                if (!v40)
                  return FigSignalErrorAt(4294951231, 0, 0, 0, 0, 0, 0);
                v41 = v40;
                CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 104));
                *a4 = CFRetain(v41);
                CFRelease(v41);
                return 0;
              }
              v9 = 0;
            }
LABEL_71:
            CFRelease(v24);
            goto LABEL_16;
          }
LABEL_45:
          CFRelease(cf);
          v24 = v36;
          goto LABEL_46;
        }
      }
      else
      {
        v28 = 0;
        v45 = 0;
      }
    }
    else
    {
      v28 = 0;
      v45 = 0;
      UInt64 = 0;
    }
    v43 = 4294951233;
    goto LABEL_68;
  }
  v63[0] = 0;
  *(_QWORD *)v54 = 0;
  *(_QWORD *)&v51 = 0;
  v48 = -1;
  context[0] = 0;
  v10 = CFStringCreateMutable(a3, 0);
  if (!v10)
    return 4294951231;
  v11 = v10;
  CFStringAppendFormat(v10, 0, CFSTR("CM8021ASClock diags: %p\n"), a1);
  CFStringAppendFormat(v11, 0, CFSTR("CM8021ASClock diags:    timeSyncClock: %p\n"), *(_QWORD *)(a1 + 48));
  v12 = (*(uint64_t (**)(void))(qword_1EE141BD8 + 88))();
  CFStringAppendFormat(v11, 0, CFSTR("CM8021ASClock diags:    ATSAC: %016llx\n"), v12);
  v13 = *(uint64_t (**)(_QWORD, _QWORD *, _BYTE *, __int128 *, _QWORD *, uint64_t *))(qword_1EE141BD8 + 224);
  if (v13)
  {
    v14 = v13(*(_QWORD *)(a1 + 48), v63, v54, &v51, context, &v48);
    CFStringAppendFormat(v11, 0, CFSTR("CM8021ASClock diags:     RateAndIdentity: err: %u; numerator: %llu; denominator: %llu; machAnchor: %llu; domainAnchor: %llu; gm: %llu\n"),
      v14,
      v63[0],
      *(_QWORD *)v54,
      (_QWORD)v51,
      context[0],
      v48);
  }
  else
  {
    CFStringAppend(v11, CFSTR("CM8021ASClock diags      err: gFTable.functions->pTimeSyncClockGetClockRateAnchorsAndGrandmasterIdentity is NULL\n"));
  }
  v9 = 0;
  *a4 = v11;
  return v9;
}

double fig8021ASClock_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 112) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

const __CFAllocator *fig8021ASClock_Finalize(uint64_t a1)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v3;
  uint64_t v4;
  unsigned int v5;
  char *v6;
  uint64_t v7;
  pthread_mutex_t *v8;
  pthread_mutex_t *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  pthread_mutex_t *v16;
  const __CFAllocator *result;
  os_log_type_t type;
  int v19[2];
  const char *v20;
  __int16 v21;
  uint64_t v22;
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (dword_1EE142028)
  {
    v19[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, v19, &type);
    v3 = v19[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v5 = v3;
    else
      v5 = v3 & 0xFFFFFFFE;
    if (v5)
    {
      v19[1] = 136315394;
      v20 = "fig8021ASClock_Finalize";
      v21 = 2048;
      v22 = a1;
      v6 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v3) = v19[0];
    }
    else
    {
      v6 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v6, v6 != &v23, v3, 0, v4);
  }
  v7 = *(_QWORD *)(a1 + 48);
  if (v7)
  {
    (*(void (**)(uint64_t, _QWORD, _QWORD))(qword_1EE141BD8 + 104))(v7, 0, 0);
    (*(void (**)(_QWORD, _QWORD, _QWORD))(qword_1EE141BD8 + 96))(*(_QWORD *)(a1 + 48), 0, 0);
    (*(void (**)(_QWORD))(qword_1EE141BD8 + 40))(*(_QWORD *)(a1 + 48));
  }
  v8 = *(pthread_mutex_t **)(a1 + 64);
  if (v8)
    FigSimpleMutexLock(v8);
  if (*(_BYTE *)(a1 + 96))
  {
    dispatch_async((dispatch_queue_t)gLogMeanIntervalApplier, &__block_literal_global_48);
    *(_BYTE *)(a1 + 96) = 0;
  }
  v9 = *(pthread_mutex_t **)(a1 + 64);
  if (v9)
    FigSimpleMutexUnlock(v9);
  v10 = *(const void **)(a1 + 24);
  if (v10)
    CFRelease(v10);
  FigSimpleMutexDestroy(*(_QWORD *)(a1 + 64));
  v11 = *(const void **)(a1 + 72);
  if (v11)
    CFRelease(v11);
  v12 = *(const void **)(a1 + 80);
  if (v12)
    CFRelease(v12);
  v13 = *(const void **)(a1 + 88);
  if (v13)
    CFRelease(v13);
  v14 = *(const void **)(a1 + 104);
  if (v14)
    CFRelease(v14);
  v15 = *(const void **)(a1 + 112);
  if (v15)
    CFRelease(v15);
  v16 = *(pthread_mutex_t **)(a1 + 32);
  if (v16)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0;
    FigSimpleMutexUnlock(v16);
  }
  result = *(const __CFAllocator **)(a1 + 16);
  if (result)
  {
    result = FigReadWriteLockDestroy((uint64_t *)result);
    *(_QWORD *)(a1 + 16) = 0;
  }
  if (v16)
    return FigSimpleMutexDestroy((uint64_t)v16);
  return result;
}

void __timesyncLogMeanIntervalApplier_unregisterClientAndDisposeClockIfNecessary_block_invoke()
{
  int v0;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v2;
  uint64_t v3;
  unsigned int v4;
  _BYTE *v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  _BYTE *v10;
  os_log_type_t type;
  int v12;
  int v13;
  const char *v14;
  __int16 v15;
  uint64_t v16;
  _BYTE v17[128];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v0 = --dword_1EE141BF8;
  if (dword_1EE142028 >= 2)
  {
    v12 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v12, &type);
    v2 = v12;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v4 = v2;
    else
      v4 = v2 & 0xFFFFFFFE;
    if (v4)
    {
      v13 = 136315394;
      v14 = "timesyncLogMeanIntervalApplier_unregisterClientAndDisposeClockIfNecessary_block_invoke";
      v15 = 1024;
      LODWORD(v16) = dword_1EE141BF8;
      v5 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v2) = v12;
    }
    else
    {
      v5 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v5, v5 != v17, v2, 0, v3);
    v0 = dword_1EE141BF8;
  }
  if (v0 <= 0)
  {
    if (qword_1EE141C00)
    {
      (*(void (**)(uint64_t, _QWORD, _QWORD))(qword_1EE141BD8 + 96))(qword_1EE141C00, 0, 0);
      if (dword_1EE142028)
      {
        v12 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        v6 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v12, &type);
        v7 = v12;
        if (os_log_type_enabled(v6, type))
          v9 = v7;
        else
          v9 = v7 & 0xFFFFFFFE;
        if (v9)
        {
          v13 = 136315394;
          v14 = "timesyncLogMeanIntervalApplier_unregisterClientAndDisposeClockIfNecessary_block_invoke";
          v15 = 2048;
          v16 = qword_1EE141C00;
          v10 = (_BYTE *)_os_log_send_and_compose_impl();
          LOBYTE(v7) = v12;
        }
        else
        {
          v10 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v10, v10 != v17, v7, 0, v8);
      }
      (*(void (**)(uint64_t))(qword_1EE141BD8 + 40))(qword_1EE141C00);
      qword_1EE141C00 = 0;
      v0 = dword_1EE141BF8;
    }
    if (v0 < 0)
      dword_1EE141BF8 = 0;
  }
}

CFStringRef fig8021ASClock_CopyDesc(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const __CFAllocator *v4;
  uint64_t v5;
  const char *v6;
  CFStringRef v7;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
  v2 = *(_QWORD *)(a1 + 56);
  v3 = **(_QWORD **)(qword_1EE141BD8 + 8);
  v4 = CFGetAllocator((CFTypeRef)a1);
  if (v2 == v3)
  {
    v5 = 0;
    v6 = "not locked";
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 56);
    v6 = "locked";
  }
  v7 = CFStringCreateWithFormat(v4, 0, CFSTR("CM8021ASClock %s, GM=0x%016llx)"), v6, v5);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
  return v7;
}

uint64_t timesyncLogMeanIntervalApplier_doesTimeDomainConformToSyncInterval(uint64_t a1, int a2)
{
  io_object_t v2;
  io_object_t v3;
  unsigned __int8 v4;
  const __CFAllocator *v5;
  const __CFNumber *CFProperty;
  const __CFNumber *v7;
  const __CFNumber *v8;
  const __CFNumber *v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v15;
  uint64_t v16;
  unsigned int v17;
  const char *v18;
  _BYTE *v19;
  NSObject *v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  _BYTE *v24;
  NSObject *v25;
  unsigned int v26;
  _BYTE *v27;
  NSObject *v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  _BYTE *v32;
  os_log_type_t type;
  int v36;
  os_log_type_t v37;
  int valuePtr;
  io_iterator_t iterator;
  int v40;
  const char *v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  _BYTE v45[10];
  __int16 v46;
  int v47;
  _BYTE v48[128];
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  iterator = 0;
  MEMORY[0x193FFB7DC](a1, "IOService", &iterator);
  if (iterator)
  {
    v2 = IOIteratorNext(iterator);
    if (v2)
    {
      v3 = v2;
      v4 = 1;
      v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      while (1)
      {
        if (!IOObjectConformsTo(v3, "IOTimeSyncUnicastUDPv4EtEPort")
          && !IOObjectConformsTo(v3, "IOTimeSyncUnicastUDPv6EtEPort"))
        {
          goto LABEL_60;
        }
        valuePtr = 0;
        CFProperty = (const __CFNumber *)IORegistryEntryCreateCFProperty(v3, CFSTR("PortRole"), v5, 0);
        if (CFProperty)
          break;
        FigSignalErrorAt(4294954540, 0, 0, 0, 0, 0, 0);
        v4 = 0;
LABEL_61:
        v3 = IOIteratorNext(iterator);
        if (!v3)
          goto LABEL_65;
      }
      v7 = CFProperty;
      CFNumberGetValue(CFProperty, kCFNumberIntType, &valuePtr);
      if ((valuePtr - 1) > 1)
      {
        if (valuePtr == 3 || !valuePtr)
        {
          if (dword_1EE142028)
          {
            v36 = 0;
            v37 = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v36, &v37);
            v15 = v36;
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, v37))
              v17 = v15;
            else
              v17 = v15 & 0xFFFFFFFE;
            if (v17)
            {
              v18 = "disabled";
              if (valuePtr == 3)
                v18 = "master";
              v40 = 136315650;
              v41 = "timesyncLogMeanIntervalApplier_doesTimeDomainConformToSyncInterval";
              v42 = 2048;
              v43 = qword_1EE141C00;
              v44 = 2080;
              *(_QWORD *)v45 = v18;
              v19 = (_BYTE *)_os_log_send_and_compose_impl();
              LOBYTE(v15) = v36;
            }
            else
            {
              v19 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v19, v19 != v48, v15, 0, v16);
          }
          goto LABEL_59;
        }
      }
      else
      {
        v8 = (const __CFNumber *)IORegistryEntryCreateCFProperty(v3, CFSTR("RemoteSyncLogMeanInterval"), v5, 0);
        if (v8)
        {
          v9 = v8;
          v37 = OS_LOG_TYPE_DEFAULT;
          CFNumberGetValue(v8, kCFNumberCharType, &v37);
          if (v37 == a2)
          {
            if (dword_1EE142028)
            {
              v36 = 0;
              type = OS_LOG_TYPE_DEFAULT;
              v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v36, &type);
              v11 = v36;
              if (os_log_type_enabled(v10, type))
                v13 = v11;
              else
                v13 = v11 & 0xFFFFFFFE;
              if (v13)
              {
                v40 = 136316162;
                v41 = "timesyncLogMeanIntervalApplier_doesTimeDomainConformToSyncInterval";
                v42 = 2048;
                v43 = qword_1EE141C00;
                v44 = 1024;
                *(_DWORD *)v45 = v3;
                *(_WORD *)&v45[4] = 1024;
                *(_DWORD *)&v45[6] = valuePtr;
                v46 = 1024;
                v47 = a2;
LABEL_41:
                v27 = (_BYTE *)_os_log_send_and_compose_impl();
                LOBYTE(v11) = v36;
LABEL_51:
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v27, v27 != v48, v11, 0, v12);
                goto LABEL_58;
              }
              goto LABEL_50;
            }
          }
          else
          {
            if ((char)v37 > a2 || (char)v37 <= OS_LOG_TYPE_DEBUG)
            {
              if (dword_1EE142028)
              {
                v36 = 0;
                type = OS_LOG_TYPE_DEFAULT;
                v28 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v36, &type);
                v29 = v36;
                if (os_log_type_enabled(v28, type))
                  v31 = v29;
                else
                  v31 = v29 & 0xFFFFFFFE;
                if (v31)
                {
                  v40 = 136315906;
                  v41 = "timesyncLogMeanIntervalApplier_doesTimeDomainConformToSyncInterval";
                  v42 = 2048;
                  v43 = qword_1EE141C00;
                  v44 = 1024;
                  *(_DWORD *)v45 = (char)v37;
                  *(_WORD *)&v45[4] = 1024;
                  *(_DWORD *)&v45[6] = a2;
                  v32 = (_BYTE *)_os_log_send_and_compose_impl();
                  LOBYTE(v29) = v36;
                }
                else
                {
                  v32 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v32, v32 != v48, v29, 0, v30);
              }
              v4 = 0;
              goto LABEL_58;
            }
            if (dword_1EE142028)
            {
              v36 = 0;
              type = OS_LOG_TYPE_DEFAULT;
              v25 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v36, &type);
              v11 = v36;
              if (os_log_type_enabled(v25, type))
                v26 = v11;
              else
                v26 = v11 & 0xFFFFFFFE;
              if (v26)
              {
                v40 = 136316162;
                v41 = "timesyncLogMeanIntervalApplier_doesTimeDomainConformToSyncInterval";
                v42 = 2048;
                v43 = qword_1EE141C00;
                v44 = 1024;
                *(_DWORD *)v45 = v3;
                *(_WORD *)&v45[4] = 1024;
                *(_DWORD *)&v45[6] = valuePtr;
                v46 = 1024;
                v47 = 3;
                goto LABEL_41;
              }
LABEL_50:
              v27 = 0;
              goto LABEL_51;
            }
          }
LABEL_58:
          CFRelease(v9);
          goto LABEL_59;
        }
        if (dword_1EE142028)
        {
          v36 = 0;
          v37 = OS_LOG_TYPE_DEFAULT;
          v20 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v36, &v37);
          v21 = v36;
          if (os_log_type_enabled(v20, v37))
            v23 = v21;
          else
            v23 = v21 & 0xFFFFFFFE;
          if (v23)
          {
            v40 = 136316162;
            v41 = "timesyncLogMeanIntervalApplier_doesTimeDomainConformToSyncInterval";
            v42 = 2048;
            v43 = qword_1EE141C00;
            v44 = 1024;
            *(_DWORD *)v45 = v3;
            *(_WORD *)&v45[4] = 1024;
            *(_DWORD *)&v45[6] = valuePtr;
            v46 = 1024;
            v47 = a2;
            v24 = (_BYTE *)_os_log_send_and_compose_impl();
            LOBYTE(v21) = v36;
          }
          else
          {
            v24 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v24, v24 != v48, v21, 0, v22);
        }
      }
      v4 = 0;
LABEL_59:
      CFRelease(v7);
LABEL_60:
      IOObjectRelease(v3);
      goto LABEL_61;
    }
    v4 = 1;
LABEL_65:
    IOObjectRelease(iterator);
  }
  else
  {
    FigSignalErrorAt(4294954540, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v4;
}

uint64_t fig8021ASClock_portsDictionaryValueReleaseCallback(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(qword_1EE141BD8 + 200))(a2);
}

uint64_t fig8021ASClock_copyCFTypeRepresentationOfAddress(UInt8 *bytes, int a2, CFDataRef *a3)
{
  uint64_t result;
  CFDataRef UInt32;
  CFDataRef v7;

  result = 4294954550;
  if (bytes && a3)
  {
    if (a2 == 30)
    {
      UInt32 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, 16);
      if (!UInt32)
        return 4294954549;
    }
    else
    {
      if (a2 != 2)
      {
        v7 = 0;
        result = 4294954550;
        goto LABEL_10;
      }
      UInt32 = FigCFNumberCreateUInt32((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(_DWORD *)bytes);
      if (!UInt32)
        return 4294954549;
    }
    v7 = UInt32;
    result = 0;
LABEL_10:
    *a3 = v7;
  }
  return result;
}

uint64_t fig8021ASClock_copyPortMetricsForPortIfValid(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  const __CFAllocator *v6;
  CFNumberRef UInt16;
  CFNumberRef v8;
  uint64_t v9;
  uint64_t v10;
  CFNumberRef v11;
  int64x2_t v12;
  int64x2_t v13;
  int64x2_t v14;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v16;
  uint64_t v17;
  unsigned int v18;
  _BYTE *v19;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v21;
  CFNumberRef UInt64;
  CFNumberRef v23;
  CFNumberRef v24;
  CFNumberRef v25;
  CFNumberRef v26;
  CFStringRef v27;
  CFStringRef v28;
  CFNumberRef v29;
  CFDictionaryRef Copy;
  CFDictionaryRef v31;
  NSObject *v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  _BYTE *v36;
  CFNumberRef v37;
  CFNumberRef v38;
  uint64_t v40;
  CFTypeRef *v41;
  CFStringRef v42;
  CFNumberRef v43;
  CFNumberRef v44;
  CFNumberRef v45;
  CFNumberRef v46;
  CFNumberRef value;
  CFNumberRef cf;
  os_log_type_t type;
  int v50;
  int64x2_t v51[9];
  int v52;
  const char *v53;
  __int16 v54;
  CFDictionaryRef v55;
  __int16 v56;
  uint64_t v57;
  __int16 v58;
  uint64_t v59;
  __int16 v60;
  uint64_t v61;
  __int16 v62;
  uint64_t v63;
  __int16 v64;
  uint64_t v65;
  __int16 v66;
  uint64_t v67;
  __int16 v68;
  uint64_t v69;
  __int16 v70;
  int v71;
  __int16 v72;
  uint64_t v73;
  __int16 v74;
  uint64_t v75;
  _BYTE v76[128];
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(qword_1EE141BD8 + 264))
    return 4294951233;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  UInt16 = FigCFNumberCreateUInt16((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2);
  if (UInt16)
  {
    v8 = UInt16;
    memset(v51, 0, 138);
    if ((*(unsigned int (**)(_QWORD, uint64_t, int64x2_t *, uint64_t, _QWORD))(qword_1EE141BD8 + 264))(*(_QWORD *)(a1 + 48), a2, v51, 138, 0))
    {
      v9 = 4294951233;
LABEL_5:
      v10 = FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
LABEL_6:
      v11 = v8;
LABEL_58:
      CFRelease(v11);
      return v10;
    }
    v12.i64[1] = *(uint64_t *)((char *)&v51[6].i64[1] + 2);
    v13.i64[0] = *(uint64_t *)((char *)v51[6].i64 + 2);
    v13.i64[1] = *(uint64_t *)((char *)&v51[7].i64[1] + 2);
    v12.i64[0] = *(uint64_t *)((char *)v51[7].i64 + 2);
    v14.i64[0] = *(uint64_t *)((char *)&v51[5].i64[1] + 2);
    v14.i64[1] = *(uint64_t *)((char *)&v51[0].i64[1] + 2);
    if ((vmaxv_u8((uint8x8_t)vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64(v12), (int32x4_t)vceqzq_s64(v13)), (int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64(v14), (int32x4_t)vceqzq_s64(*(int64x2_t *)((char *)&v51[1] + 2))))))) & 1) == 0&& !*(uint64_t *)((char *)v51[8].i64 + 2)&& !*(uint64_t *)((char *)v51[0].i64 + 2))
    {
      v10 = 0;
      goto LABEL_6;
    }
    if (dword_1EE142028)
    {
      v50 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v50, &type);
      v16 = v50;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v18 = v16;
      else
        v18 = v16 & 0xFFFFFFFE;
      if (v18)
      {
        v52 = 136317954;
        v53 = "fig8021ASClock_copyPortMetricsForPortIfValid";
        v54 = 2048;
        v55 = *(CFDictionaryRef *)((char *)&v51[6].i64[1] + 2);
        v56 = 2048;
        v57 = *(uint64_t *)((char *)v51[7].i64 + 2);
        v58 = 2048;
        v59 = *(uint64_t *)((char *)v51[6].i64 + 2);
        v60 = 2048;
        v61 = *(uint64_t *)((char *)&v51[7].i64[1] + 2);
        v62 = 2048;
        v63 = *(uint64_t *)((char *)&v51[5].i64[1] + 2);
        v64 = 2048;
        v65 = *(uint64_t *)((char *)&v51[0].i64[1] + 2);
        v66 = 2048;
        v67 = *(uint64_t *)((char *)v51[1].i64 + 2);
        v68 = 2048;
        v69 = *(uint64_t *)((char *)&v51[1].i64[1] + 2);
        v70 = 1024;
        v71 = v51[0].u16[0];
        v72 = 2048;
        v73 = *(uint64_t *)((char *)v51[8].i64 + 2);
        v74 = 2048;
        v75 = *(uint64_t *)((char *)v51[0].i64 + 2);
        v19 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v16) = v50;
      }
      else
      {
        v19 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v19, v19 != v76, v16, 0, v17);
    }
    Mutable = CFDictionaryCreateMutable(v6, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!Mutable)
    {
      v9 = 4294951231;
      goto LABEL_5;
    }
    v21 = Mutable;
    value = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)&v51[6].i64[1] + 2));
    if (!value)
    {
      v10 = FigSignalErrorAt(4294951233, 0, 0, 0, 0, 0, 0);
      CFRelease(v21);
      goto LABEL_6;
    }
    cf = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)v51[7].i64 + 2));
    if (!cf)
    {
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v29 = 0;
      v37 = 0;
      v38 = 0;
      v46 = 0;
      v42 = 0;
      UInt64 = 0;
LABEL_69:
      v40 = 4294951233;
      goto LABEL_77;
    }
    UInt64 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)v51[6].i64 + 2));
    if (UInt64)
    {
      v23 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)&v51[7].i64[1] + 2));
      if (v23)
      {
        v24 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)&v51[5].i64[1] + 2));
        if (v24)
        {
          v41 = a3;
          v25 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)&v51[0].i64[1] + 2));
          if (v25)
          {
            v43 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)v51[1].i64 + 2));
            if (v43)
            {
              v45 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)&v51[1].i64[1] + 2));
              if (!v45)
              {
                v37 = 0;
                v38 = 0;
                v46 = 0;
                v42 = 0;
                v40 = 4294951233;
                v29 = v43;
                goto LABEL_77;
              }
              v44 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)v51[8].i64 + 2));
              if (!v44)
              {
                v38 = 0;
                v46 = 0;
                v42 = 0;
                v40 = 4294951233;
                v29 = v43;
                v37 = v45;
                goto LABEL_77;
              }
              v26 = FigCFNumberCreateUInt64(v6, *(uint64_t *)((char *)v51[0].i64 + 2));
              if (v26)
              {
                v46 = v26;
                v27 = CFUUIDCreateString(v6, *(CFUUIDRef *)(a1 + 112));
                if (v27)
                {
                  v28 = v27;
                  CFDictionarySetValue(v21, CFSTR("DiscardedDelayLimitExceededPercentage"), value);
                  CFDictionarySetValue(v21, CFSTR("DiscardedOutOfBoundsPercentage"), cf);
                  CFDictionarySetValue(v21, CFSTR("DiscardedPpmLimitPercentage"), UInt64);
                  CFDictionarySetValue(v21, CFSTR("DiscardedTimestampsOutOfOrderPercentage"), v23);
                  CFDictionarySetValue(v21, CFSTR("DroppedPercentage"), v24);
                  CFDictionarySetValue(v21, CFSTR("FilterResetsDroppedLimit"), v25);
                  v29 = v43;
                  CFDictionarySetValue(v21, CFSTR("FilterResetsOutOfBounds"), v43);
                  CFDictionarySetValue(v21, CFSTR("MeanDelayTime"), v45);
                  CFDictionarySetValue(v21, CFSTR("SuccessfulPercentage"), v44);
                  CFDictionarySetValue(v21, CFSTR("SyncTimeouts"), v46);
                  v42 = v28;
                  CFDictionarySetValue(v21, CFSTR("ClockUUID"), v28);
                  Copy = CFDictionaryCreateCopy(v6, v21);
                  if (Copy)
                  {
                    v31 = Copy;
                    if (dword_1EE142028 >= 2)
                    {
                      v50 = 0;
                      type = OS_LOG_TYPE_DEFAULT;
                      v32 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v50, &type);
                      v33 = v50;
                      if (os_log_type_enabled(v32, type))
                        v35 = v33;
                      else
                        v35 = v33 & 0xFFFFFFFE;
                      if (v35)
                      {
                        v52 = 136315394;
                        v53 = "fig8021ASClock_copyPortMetricsForPortIfValid";
                        v54 = 2112;
                        v55 = v31;
                        v36 = (_BYTE *)_os_log_send_and_compose_impl();
                        LOBYTE(v33) = v50;
                      }
                      else
                      {
                        v36 = 0;
                      }
                      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v36, v36 != v76, v33, 0, v34);
                      v29 = v43;
                    }
                    *v41 = CFRetain(v31);
                    CFRelease(v21);
                    CFRelease(v31);
                    CFRelease(value);
                    v10 = 0;
                    v38 = v44;
                    v37 = v45;
                    goto LABEL_40;
                  }
                  v40 = 4294951231;
                  goto LABEL_76;
                }
              }
              else
              {
                v46 = 0;
              }
              v42 = 0;
              v40 = 4294951233;
              v29 = v43;
LABEL_76:
              v38 = v44;
              v37 = v45;
LABEL_77:
              v10 = FigSignalErrorAt(v40, 0, 0, 0, 0, 0, 0);
              CFRelease(v21);
              CFRelease(value);
              if (!cf)
              {
LABEL_41:
                if (UInt64)
                  CFRelease(UInt64);
                if (v23)
                  CFRelease(v23);
                if (v24)
                  CFRelease(v24);
                if (v25)
                  CFRelease(v25);
                if (v29)
                  CFRelease(v29);
                if (v37)
                  CFRelease(v37);
                if (v38)
                  CFRelease(v38);
                if (v46)
                  CFRelease(v46);
                CFRelease(v8);
                v11 = (CFNumberRef)v42;
                if (!v42)
                  return v10;
                goto LABEL_58;
              }
LABEL_40:
              CFRelease(cf);
              goto LABEL_41;
            }
          }
          goto LABEL_68;
        }
LABEL_67:
        v25 = 0;
LABEL_68:
        v29 = 0;
        v37 = 0;
        v38 = 0;
        v46 = 0;
        v42 = 0;
        goto LABEL_69;
      }
    }
    else
    {
      v23 = 0;
    }
    v24 = 0;
    goto LABEL_67;
  }
  return FigSignalErrorAt(4294951233, 0, 0, 0, 0, 0, 0);
}

void __timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStarted_block_invoke()
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v1;
  uint64_t v2;
  unsigned int v3;
  char *v4;
  os_log_type_t type;
  int v6[2];
  const char *v7;
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  gLogMeanIntervalApplier = (uint64_t)FigDispatchQueueCreateWithPriority("com.apple.coremedia.8021as.gLogMeanIntervalApplier.applierQueue", 0, 0x27u);
  if (gLogMeanIntervalApplier)
  {
    byte_1EE141BF0 = -3;
    *(_QWORD *)&dword_1EE141BF4 = 0xFFFFFFFFLL;
    word_1EE141C08 = 0;
    if (dword_1EE142028)
    {
      v6[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, v6, &type);
      v1 = v6[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v3 = v1;
      else
        v3 = v1 & 0xFFFFFFFE;
      if (v3)
      {
        v6[1] = 136315138;
        v7 = "timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStarted_block_invoke";
        v4 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v1) = v6[0];
      }
      else
      {
        v4 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v4, v4 != &v8, v1, 0, v2);
    }
  }
}

void timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStartedInternal(uint64_t a1, uint64_t a2)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v3;
  uint64_t v4;
  unsigned int v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  _BYTE *v14;
  os_log_type_t type;
  int v16;
  int v17;
  const char *v18;
  __int16 v19;
  uint64_t v20;
  _BYTE v21[128];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  ++dword_1EE141BF8;
  if (dword_1EE142028 >= 2)
  {
    v16 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v16, &type);
    v3 = v16;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v5 = v3;
    else
      v5 = v3 & 0xFFFFFFFE;
    if (v5)
    {
      v17 = 136315394;
      v18 = "timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStartedInternal";
      v19 = 1024;
      LODWORD(v20) = dword_1EE141BF8;
      v6 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v3) = v16;
    }
    else
    {
      v6 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v6, v6 != v21, v3, 0, v4);
  }
  if (!qword_1EE141C00)
  {
    v7 = (*(uint64_t (**)(uint64_t, uint64_t))(qword_1EE141BD8 + 88))(a1, a2);
    if (v7 == **(_QWORD **)qword_1EE141BD8
      || (v9 = (*(uint64_t (**)(uint64_t, uint64_t))(qword_1EE141BD8 + 32))(v7, v8), (qword_1EE141C00 = v9) == 0))
    {
      FigSignalErrorAt(4294951236, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      (*(void (**)(uint64_t, _QWORD, uint64_t))(qword_1EE141BD8 + 96))(v9, timesyncLogMeanIntervalApplier_lockStateChangedCallback, v9);
      byte_1EE141BF0 = -3;
      dword_1EE141BF4 = -1;
      if (dword_1EE142028)
      {
        v16 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        v10 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, &v16, &type);
        v11 = v16;
        if (os_log_type_enabled(v10, type))
          v13 = v11;
        else
          v13 = v11 & 0xFFFFFFFE;
        if (v13)
        {
          v17 = 136315394;
          v18 = "timesyncLogMeanIntervalApplier_registerClientAndEnsureClockStartedInternal";
          v19 = 2048;
          v20 = qword_1EE141C00;
          v14 = (_BYTE *)_os_log_send_and_compose_impl();
          LOBYTE(v11) = v16;
        }
        else
        {
          v14 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v14, v14 != v21, v11, 0, v12);
      }
    }
  }
}

void timesyncLogMeanIntervalApplier_lockStateChangedCallback(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD block[6];
  int v4;

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __timesyncLogMeanIntervalApplier_lockStateChangedCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_101;
  block[4] = a2;
  block[5] = a1;
  v4 = a3;
  dispatch_async((dispatch_queue_t)gLogMeanIntervalApplier, block);
}

void __timesyncLogMeanIntervalApplier_lockStateChangedCallback_block_invoke(uint64_t a1)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  char *v8;
  os_log_type_t type;
  int v10[2];
  const char *v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (qword_1EE141C00 && *(_QWORD *)(a1 + 32) == qword_1EE141C00)
  {
    if (dword_1EE142028)
    {
      v10[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, v10, &type);
      v3 = v10[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v5 = v3;
      else
        v5 = v3 & 0xFFFFFFFE;
      if (v5)
      {
        v6 = *(_QWORD *)(a1 + 40);
        v7 = *(_DWORD *)(a1 + 48);
        v10[1] = 136315906;
        v11 = "timesyncLogMeanIntervalApplier_lockStateChangedCallback_block_invoke";
        v12 = 2048;
        v13 = v6;
        v14 = 1024;
        v15 = v7;
        v16 = 1024;
        v17 = dword_1EE141BF4;
        v8 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v3) = v10[0];
      }
      else
      {
        v8 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v8, v8 != &v18, v3, 0, v4);
    }
    if (dword_1EE141BF4 != *(_DWORD *)(a1 + 48))
    {
      dword_1EE141BF4 = *(_DWORD *)(a1 + 48);
      timesyncLogMeanIntervalApplier_restartIntervalApplierInternal();
    }
  }
}

void timesyncLogMeanIntervalApplier_restartIntervalApplierInternal()
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v1;
  uint64_t v2;
  unsigned int v3;
  char *v4;
  os_log_type_t type;
  int v6[2];
  const char *v7;
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (word_1EE141C08 <= 0)
  {
    if (dword_1EE142028 >= 2)
    {
      v6[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, v6, &type);
      v1 = v6[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v3 = v1;
      else
        v3 = v1 & 0xFFFFFFFE;
      if (v3)
      {
        v6[1] = 136315138;
        v7 = "timesyncLogMeanIntervalApplier_restartIntervalApplierInternal";
        v4 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v1) = v6[0];
      }
      else
      {
        v4 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v4, v4 != &v8, v1, 0, v2);
    }
    dispatch_async_f((dispatch_queue_t)gLogMeanIntervalApplier, 0, (dispatch_function_t)timesyncLogMeanIntervalApplier_applyIntervalInternal);
  }
  word_1EE141C08 = 100;
}

void timesyncLogMeanIntervalApplier_applyIntervalInternal()
{
  uint64_t *v0;
  char v1;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  io_iterator_t v3;
  uint64_t v4;
  unsigned int v5;
  const char *v6;
  _BYTE *v7;
  mach_port_t v8;
  const __CFDictionary *v9;
  uint64_t MatchingService;
  uint64_t v11;
  const __CFAllocator *v12;
  CFTypeRef CFProperty;
  int v14;
  uint64_t v15;
  uint64_t v16;
  CFTypeRef v17;
  CFTypeRef v18;
  NSObject *v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  _BYTE *v23;
  int v24;
  int v25;
  NSObject *v26;
  unsigned int v27;
  uint64_t v28;
  unsigned int v29;
  _BYTE *v30;
  NSObject *v31;
  unsigned int v32;
  uint64_t v33;
  unsigned int v34;
  _BYTE *v35;
  __int16 v36;
  dispatch_time_t v37;
  BOOL v38;
  NSObject *v39;
  io_iterator_t v40;
  uint64_t v41;
  unsigned int v42;
  _BYTE *v43;
  unsigned int v44;
  os_log_type_t v45;
  os_log_type_t type[4];
  io_iterator_t iterator;
  int v48;
  const char *v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  unsigned int v57;
  __int16 v58;
  int v59;
  _BYTE v60[128];
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v0 = &qword_1EE142000;
  if (!qword_1EE141C00)
    goto LABEL_73;
  v1 = byte_1EE141BF0;
  if (dword_1EE141BF4 != 2)
    v1 = -3;
  v44 = v1;
  if (dword_1EE142028)
  {
    iterator = 0;
    type[0] = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, (int *)&iterator, type);
    v3 = iterator;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0]))
      v5 = v3;
    else
      v5 = v3 & 0xFFFFFFFE;
    if (v5)
    {
      v6 = "not locked";
      if (dword_1EE141BF4 == 2)
        v6 = "locked";
      v48 = 136316418;
      v49 = "timesyncLogMeanIntervalApplier_applyIntervalInternal";
      v50 = 2048;
      v51 = qword_1EE141C00;
      v52 = 2080;
      v53 = v6;
      v54 = 1024;
      v55 = dword_1EE141BF4;
      v56 = 1024;
      v57 = v44;
      v58 = 1024;
      v59 = word_1EE141C08;
      v7 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v3) = iterator;
    }
    else
    {
      v7 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v7, v7 != v60, v3, 0, v4);
  }
  v8 = dword_1EE141C0C;
  if (!dword_1EE141C0C)
  {
    (*(void (**)(uint64_t, _QWORD))(qword_1EE141BD8 + 232))(qword_1EE141C00, v44);
    if (MEMORY[0x193FFB770](*MEMORY[0x1E0C83DA0], &dword_1EE141C0C))
      goto LABEL_73;
    v8 = dword_1EE141C0C;
  }
  v9 = IOServiceMatching("IOTimeSyncgPTPManager");
  MatchingService = IOServiceGetMatchingService(v8, v9);
  if ((_DWORD)MatchingService)
  {
    v11 = MatchingService;
    iterator = 0;
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    CFProperty = IORegistryEntryCreateCFProperty(MatchingService, CFSTR("SystemDomainIdentifier"), (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    MEMORY[0x193FFB7DC](v11, "IOService", &iterator);
    v14 = 0;
    if (iterator && CFProperty)
    {
      v15 = IOIteratorNext(iterator);
      if ((_DWORD)v15)
      {
        v16 = v15;
        v14 = 0;
        while (!IOObjectConformsTo(v16, "IOTimeSyncDomain"))
        {
LABEL_56:
          IOObjectRelease(v16);
          v16 = IOIteratorNext(iterator);
          if (!(_DWORD)v16)
            goto LABEL_62;
        }
        v17 = IORegistryEntryCreateCFProperty(v16, CFSTR("ClockIdentifier"), v12, 0);
        if (FigCFEqual(v17, CFProperty))
        {
          v18 = IORegistryEntryCreateCFProperty(v16, CFSTR("GrandmasterID"), v12, 0);
          if (FigCFEqual(CFProperty, v18) && dword_1EE141BF4 == 2)
          {
            if (*((_DWORD *)v0 + 10))
            {
              *(_DWORD *)type = 0;
              v45 = OS_LOG_TYPE_DEFAULT;
              v19 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, (int *)type, &v45);
              v20 = *(_DWORD *)type;
              if (os_log_type_enabled(v19, v45))
                v22 = v20;
              else
                v22 = v20 & 0xFFFFFFFE;
              if (v22)
              {
                v48 = 136315394;
                v49 = "timesyncLogMeanIntervalApplier_applyIntervalInternal";
                v50 = 2048;
                v51 = qword_1EE141C00;
                v23 = (_BYTE *)_os_log_send_and_compose_impl();
                LOBYTE(v20) = type[0];
              }
              else
              {
                v23 = 0;
              }
              v14 = 1;
              fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v23, v23 != v60, v20, 0, v21);
              v0 = &qword_1EE142000;
              if (!v18)
                goto LABEL_54;
            }
            else
            {
              v14 = 1;
              if (!v18)
                goto LABEL_54;
            }
          }
          else
          {
            v24 = (*(uint64_t (**)(uint64_t, _QWORD))(qword_1EE141BD8 + 240))(v16, v44);
            v25 = *((_DWORD *)v0 + 10);
            if (v24)
            {
              v14 = v24;
              if (v25)
              {
                *(_DWORD *)type = 0;
                v45 = OS_LOG_TYPE_DEFAULT;
                v26 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, (int *)type, &v45);
                v27 = *(_DWORD *)type;
                if (os_log_type_enabled(v26, v45))
                  v29 = v27;
                else
                  v29 = v27 & 0xFFFFFFFE;
                if (v29)
                {
                  v48 = 136315394;
                  v49 = "timesyncLogMeanIntervalApplier_applyIntervalInternal";
                  v50 = 2048;
                  v51 = qword_1EE141C00;
                  v30 = (_BYTE *)_os_log_send_and_compose_impl();
                  LOBYTE(v27) = type[0];
                }
                else
                {
                  v30 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v30, v30 != v60, v27, 0, v28);
                v0 = &qword_1EE142000;
              }
              if (!v18)
                goto LABEL_54;
            }
            else
            {
              if (v25)
              {
                *(_DWORD *)type = 0;
                v45 = OS_LOG_TYPE_DEFAULT;
                v31 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, (int *)type, &v45);
                v32 = *(_DWORD *)type;
                if (os_log_type_enabled(v31, v45))
                  v34 = v32;
                else
                  v34 = v32 & 0xFFFFFFFE;
                if (v34)
                {
                  v48 = 136315650;
                  v49 = "timesyncLogMeanIntervalApplier_applyIntervalInternal";
                  v50 = 2048;
                  v51 = qword_1EE141C00;
                  v52 = 1024;
                  LODWORD(v53) = v44;
                  v35 = (_BYTE *)_os_log_send_and_compose_impl();
                  LOBYTE(v32) = type[0];
                }
                else
                {
                  v35 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v35, v35 != v60, v32, 0, v33);
                v0 = &qword_1EE142000;
              }
              (*(void (**)(uint64_t, _QWORD))(qword_1EE141BD8 + 232))(qword_1EE141C00, v44);
              v14 = 0;
              if (!v18)
                goto LABEL_54;
            }
          }
          CFRelease(v18);
        }
LABEL_54:
        if (v17)
          CFRelease(v17);
        goto LABEL_56;
      }
      v14 = 0;
    }
    else
    {
LABEL_62:
      if (!CFProperty)
        goto LABEL_67;
    }
    CFRelease(CFProperty);
LABEL_67:
    if (iterator)
      IOObjectRelease(iterator);
    IOObjectRelease(v11);
    goto LABEL_70;
  }
  v14 = 0;
LABEL_70:
  v36 = --word_1EE141C08;
  if (v14 || v36 < 1)
    goto LABEL_74;
  v37 = dispatch_time(0, 1000000000);
  dispatch_after_f(v37, (dispatch_queue_t)gLogMeanIntervalApplier, 0, (dispatch_function_t)timesyncLogMeanIntervalApplier_applyIntervalInternal);
LABEL_73:
  v14 = 0;
LABEL_74:
  if (v14 || (qword_1EE141C00 ? (v38 = word_1EE141C08 <= 0) : (v38 = 1), v38))
  {
    if (*((_DWORD *)v0 + 10) >= 2u)
    {
      iterator = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      v39 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, (int *)&iterator, type);
      v40 = iterator;
      if (os_log_type_enabled(v39, type[0]))
        v42 = v40;
      else
        v42 = v40 & 0xFFFFFFFE;
      if (v42)
      {
        v48 = 136315138;
        v49 = "timesyncLogMeanIntervalApplier_applyIntervalInternal";
        v43 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v40) = iterator;
      }
      else
      {
        v43 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v43, v43 != v60, v40, 0, v41);
    }
    word_1EE141C08 = 0;
    if (dword_1EE141C0C)
    {
      IOObjectRelease(dword_1EE141C0C);
      dword_1EE141C0C = 0;
    }
  }
}

void __timesyncLogMeanIntervalApplier_setIntervalAndApplyIfDifferent_block_invoke(uint64_t a1)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v3;
  uint64_t v4;
  unsigned int v5;
  int v6;
  char *v7;
  os_log_type_t type;
  int v9[2];
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  char v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (qword_1EE141C00)
  {
    if (dword_1EE142028)
    {
      v9[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142020, 1, v9, &type);
      v3 = v9[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v5 = v3;
      else
        v5 = v3 & 0xFFFFFFFE;
      if (v5)
      {
        v6 = *(char *)(a1 + 32);
        v9[1] = 136315650;
        v10 = "timesyncLogMeanIntervalApplier_setIntervalAndApplyIfDifferent_block_invoke";
        v11 = 1024;
        v12 = v6;
        v13 = 1024;
        v14 = byte_1EE141BF0;
        v7 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v3) = v9[0];
      }
      else
      {
        v7 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142020, 1u, 1, v7, v7 != &v15, v3, 0, v4);
    }
    if (byte_1EE141BF0 != *(_BYTE *)(a1 + 32))
    {
      byte_1EE141BF0 = *(_BYTE *)(a1 + 32);
      timesyncLogMeanIntervalApplier_restartIntervalApplierInternal();
    }
  }
}

void __fig8021ASClock_getMetricsForClockAndAllPorts_block_invoke(uint64_t a1, uint64_t a2, const __CFNumber *a3)
{
  uint64_t v5;
  uint64_t UInt16;
  void *v7;
  CFTypeRef v8;
  CFTypeRef v9;

  v9 = 0;
  v5 = *(_QWORD *)(a1 + 32);
  UInt16 = FigCFNumberGetUInt16(a3);
  fig8021ASClock_copyPortMetricsForPortIfValid(v5, UInt16, &v9);
  v7 = *(void **)(*(_QWORD *)(a1 + 32) + 104);
  v8 = v9;
  FigCFDictionarySetValue(v7, a3, v9);
  if (v8)
    CFRelease(v8);
}

uint64_t FigTransportDiscoveryGetTypeID()
{
  if (FigTransportDiscoveryGetTypeID_sFigTransportDiscoveryInitOnce != -1)
    dispatch_once(&FigTransportDiscoveryGetTypeID_sFigTransportDiscoveryInitOnce, &__block_literal_global_49);
  return FigTransportDiscoveryGetTypeID_sFigTransportDiscoveryTypeID;
}

uint64_t FigTransportDiscoveryGetSharedDiscovery()
{
  if (FigTransportDiscoveryGetSharedDiscovery_sCreateSharedDiscoveryOnce != -1)
    dispatch_once(&FigTransportDiscoveryGetSharedDiscovery_sCreateSharedDiscoveryOnce, &__block_literal_global_7_3);
  return FigTransportDiscoveryGetSharedDiscovery_sSharedDiscovery;
}

_QWORD *FigTransportDiscoveryAddEventHandler(_QWORD *a1, NSObject *a2, const void *a3)
{
  _QWORD *v6;
  NSObject *v7;
  _QWORD v9[6];

  v6 = malloc_type_calloc(1uLL, 0x18uLL, 0x10A0040FC6C5850uLL);
  if (!a2)
    a2 = MEMORY[0x1E0C80D38];
  *(_DWORD *)v6 = FigAtomicIncrement32((unsigned int *)&ftd_MakeHandler_sIdentifier);
  v6[1] = a2;
  dispatch_retain(a2);
  v6[2] = _Block_copy(a3);
  CFRetain(a1);
  v7 = a1[2];
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __FigTransportDiscoveryAddEventHandler_block_invoke;
  v9[3] = &__block_descriptor_tmp_9_7;
  v9[4] = a1;
  v9[5] = v6;
  dispatch_async(v7, v9);
  return v6;
}

uint64_t ftd_PostEvent(const void *a1, int *a2, int a3, uint64_t a4)
{
  __CFDictionary *Mutable;
  __CFDictionary *v9;
  uint64_t Length;
  CFRange v11;
  CFStringRef v12;
  CFStringRef v13;
  int v14;
  NSObject *v15;
  _QWORD block[7];
  int v18;
  int v19;
  CFIndex usedBufLen;
  UInt8 buffer[16];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  *(_OWORD *)buffer = 0u;
  v22 = 0u;
  usedBufLen = 0;
  if (a4)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!Mutable)
      return 4294955254;
    v9 = Mutable;
    CFDictionarySetValue(Mutable, CFSTR("deviceID"), *(const void **)(a4 + 32));
    CFDictionarySetValue(v9, CFSTR("deviceRef"), *(const void **)(a4 + 16));
    usedBufLen = 0;
    Length = CFStringGetLength(*(CFStringRef *)(a4 + 32));
    if (Length >= 8)
      v11.length = 8;
    else
      v11.length = Length;
    v11.location = 0;
    CFStringGetBytes(*(CFStringRef *)(a4 + 32), v11, 0x8000100u, 0, 0, buffer, 128, &usedBufLen);
    buffer[usedBufLen] = 0;
    v12 = CFStringCreateWithCString(0, (const char *)buffer, 0x8000100u);
    if (v12)
    {
      v13 = v12;
      CFDictionarySetValue(v9, CFSTR("deviceName"), v12);
      CFRelease(v13);
    }
  }
  else
  {
    v9 = 0;
  }
  CFRetain(a1);
  v14 = *a2;
  v15 = *((_QWORD *)a2 + 1);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __ftd_PostEvent_block_invoke;
  block[3] = &__block_descriptor_tmp_33_1;
  block[4] = a1;
  block[5] = a2;
  v18 = v14;
  v19 = a3;
  block[6] = v9;
  dispatch_async(v15, block);
  return 0;
}

void FigTransportDiscoveryRemoveEventHandler(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  _QWORD v3[6];

  v2 = *(NSObject **)(a1 + 16);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __FigTransportDiscoveryRemoveEventHandler_block_invoke;
  v3[3] = &__block_descriptor_tmp_10_8;
  v3[4] = a1;
  v3[5] = a2;
  dispatch_sync(v2, v3);
}

void ftd_FreeHandler(void *a1)
{
  if (a1)
  {
    *(_DWORD *)a1 = 0;
    dispatch_release(*((dispatch_object_t *)a1 + 1));
    _Block_release(*((const void **)a1 + 2));
    free(a1);
  }
}

void FigTransportDiscoveryStart(_QWORD *a1)
{
  NSObject *v2;
  _QWORD block[5];

  CFRetain(a1);
  v2 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigTransportDiscoveryStart_block_invoke;
  block[3] = &__block_descriptor_tmp_11_4;
  block[4] = a1;
  dispatch_async(v2, block);
}

void FigTransportDiscoveryStop(_QWORD *a1)
{
  NSObject *v2;
  _QWORD block[5];

  CFRetain(a1);
  v2 = a1[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigTransportDiscoveryStop_block_invoke;
  block[3] = &__block_descriptor_tmp_12_7;
  block[4] = a1;
  dispatch_async(v2, block);
}

void ftd_Stop(uint64_t a1)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v3;
  uint64_t v4;
  unsigned int v5;
  char *v6;
  int v7;
  BOOL v8;
  _QWORD *v9;
  io_object_t v10;
  IONotificationPort *v11;
  os_log_type_t type;
  int v13[2];
  const char *v14;
  char v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v13[0] = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v13, &type);
  v3 = v13[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v5 = v3;
  else
    v5 = v3 & 0xFFFFFFFE;
  if (v5)
  {
    v13[1] = 136315138;
    v14 = "ftd_Stop";
    v6 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v3) = v13[0];
  }
  else
  {
    v6 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v6, v6 != &v15, v3, 0, v4);
  v7 = *(_DWORD *)(a1 + 24);
  v8 = __OFSUB__(v7--, 1);
  *(_DWORD *)(a1 + 24) = v7;
  if ((v7 < 0) ^ v8 | (v7 == 0))
  {
    while (1)
    {
      v9 = *(_QWORD **)(a1 + 56);
      if (!v9)
        break;
      *(_QWORD *)(a1 + 56) = *v9;
      ftd_FreeDevice(v9);
    }
    v10 = *(_DWORD *)(a1 + 48);
    if (v10)
    {
      IOObjectRelease(v10);
      *(_DWORD *)(a1 + 48) = 0;
      CFRelease((CFTypeRef)a1);
    }
    v11 = *(IONotificationPort **)(a1 + 40);
    if (v11)
    {
      IONotificationPortDestroy(v11);
      *(_QWORD *)(a1 + 40) = 0;
    }
    ftd_PostEventOnAllHandlers((CFArrayRef *)a1, 3, 0);
  }
}

double ftd_Init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void ftd_Finalize(uint64_t a1)
{
  NSObject *v2;
  CFIndex v3;
  void *ValueAtIndex;
  const void *v5;

  v2 = *(NSObject **)(a1 + 16);
  if (v2)
    dispatch_release(v2);
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 32)) >= 1)
  {
    v3 = 0;
    do
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), v3);
      ftd_FreeHandler(ValueAtIndex);
      ++v3;
    }
    while (CFArrayGetCount(*(CFArrayRef *)(a1 + 32)) > v3);
  }
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 32));
  v5 = *(const void **)(a1 + 32);
  if (v5)
    CFRelease(v5);
}

void CFDictionarySetInt64(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  uint64_t *p_valuePtr;
  CFNumberType v6;
  CFNumberRef v7;
  CFNumberRef v8;
  int v9;
  __int16 v10;
  char v11;
  uint64_t valuePtr;

  valuePtr = a3;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  if (a3 == (char)a3)
  {
    v11 = a3;
    p_valuePtr = (uint64_t *)&v11;
    v6 = kCFNumberSInt8Type;
  }
  else
  {
    p_valuePtr = &valuePtr;
    v6 = kCFNumberSInt64Type;
  }
  v7 = CFNumberCreate(0, v6, p_valuePtr);
  if (v7)
  {
    v8 = v7;
    CFDictionarySetValue(a1, a2, v7);
    CFRelease(v8);
  }
}

uint64_t ftd_Attached(uint64_t a1, io_iterator_t iterator)
{
  uint64_t result;
  io_registry_entry_t v5;
  const __CFNumber *CFProperty;
  _QWORD *v8;
  io_object_t *v9;
  const void *v10;
  CFTypeID v11;
  int valuePtr;
  io_registry_entry_t parent;

  result = IOIteratorNext(iterator);
  if ((_DWORD)result)
  {
    v5 = result;
    while (1)
    {
      valuePtr = 0;
      CFProperty = (const __CFNumber *)IORegistryEntryCreateCFProperty(v5, CFSTR("idProduct"), 0, 0);
      CFNumberGetValue(CFProperty, kCFNumberIntType, &valuePtr);
      if (CFProperty)
        CFRelease(CFProperty);
      if ((valuePtr & 0xFFF0u) - 4752 > 0x20 || ((1 << ((valuePtr & 0xF0u) + 112)) & 0x100010001) == 0)
        goto LABEL_16;
      parent = 0;
      if (IORegistryEntryGetParentEntry(v5, "IOService", &parent))
        break;
      v8 = malloc_type_calloc(1uLL, 0x28uLL, 0x1060040EFD7669EuLL);
      v9 = (io_object_t *)v8;
      if (!v8)
        goto LABEL_19;
      if (FigCFIOKitObjectCreate(v8 + 2, v5))
        goto LABEL_19;
      *((_QWORD *)v9 + 4) = IORegistryEntryCreateCFProperty(parent, CFSTR("kUSBSerialNumberString"), 0, 0);
      IOObjectRelease(parent);
      v10 = (const void *)*((_QWORD *)v9 + 4);
      if (!v10)
        goto LABEL_19;
      v11 = CFGetTypeID(v10);
      if (v11 != CFStringGetTypeID()
        || IOServiceAddInterestNotification(*(IONotificationPortRef *)(a1 + 40), v5, "IOGeneralInterest", (IOServiceInterestCallback)ftd_Detached, v9, v9 + 6))
      {
        goto LABEL_19;
      }
      CFRetain((CFTypeRef)a1);
      *(_QWORD *)v9 = *(_QWORD *)(a1 + 56);
      *((_QWORD *)v9 + 1) = a1;
      *(_QWORD *)(a1 + 56) = v9;
      ftd_FreeDevice(0);
      ftd_PostEventOnAllHandlers((CFArrayRef *)a1, 1, (uint64_t)v9);
LABEL_16:
      IOObjectRelease(v5);
      result = IOIteratorNext(iterator);
      v5 = result;
      if (!(_DWORD)result)
        return result;
    }
    v9 = 0;
LABEL_19:
    ftd_FreeDevice(v9);
    goto LABEL_16;
  }
  return result;
}

CFIndex ftd_PostEventOnAllHandlers(CFArrayRef *a1, int a2, uint64_t a3)
{
  CFIndex result;
  CFIndex i;
  int *ValueAtIndex;

  result = CFArrayGetCount(a1[4]);
  if (result >= 1)
  {
    for (i = 0; i < result; ++i)
    {
      ValueAtIndex = (int *)CFArrayGetValueAtIndex(a1[4], i);
      result = ftd_PostEvent(a1, ValueAtIndex, a2, a3);
      if ((_DWORD)result)
        break;
      result = CFArrayGetCount(a1[4]);
    }
  }
  return result;
}

void ftd_Detached(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v4;
  _QWORD *v5;

  if (a3 == -536870896)
  {
    v4 = (_QWORD *)(*(_QWORD *)(a1 + 8) + 56);
    while (1)
    {
      v5 = v4;
      v4 = (_QWORD *)*v4;
      if (!v4)
        break;
      if (v4 == (_QWORD *)a1)
      {
        *v5 = *(_QWORD *)a1;
        ftd_PostEventOnAllHandlers(*(CFArrayRef **)(a1 + 8), 2, a1);
        ftd_FreeDevice((_QWORD *)a1);
        return;
      }
    }
  }
}

void ftd_FreeDevice(_QWORD *a1)
{
  const void *v2;
  io_object_t v3;
  const void *v4;
  const void *v5;

  if (a1)
  {
    v2 = (const void *)a1[4];
    if (v2)
    {
      CFRelease(v2);
      a1[4] = 0;
    }
    v3 = *((_DWORD *)a1 + 6);
    if (v3)
    {
      IOObjectRelease(v3);
      *((_DWORD *)a1 + 6) = 0;
    }
    v4 = (const void *)a1[2];
    if (v4)
    {
      CFRelease(v4);
      a1[2] = 0;
    }
    v5 = (const void *)a1[1];
    if (v5)
      CFRelease(v5);
    free(a1);
  }
}

uint64_t FigTransportCreateBBufFromPointer(const __CFAllocator *a1, uint64_t a2, CMBlockBufferRef *a3)
{
  uint64_t v4;

  v4 = a2;
  return FigCreateBlockBufferCopyingMemoryBlock(a1, &v4, 8uLL, a3);
}

uint64_t FigTransportCreateCFNumberFromRemoteObjectRef(uint64_t a1, uint64_t a2, CFNumberRef *a3)
{
  CFNumberRef v4;
  CFNumberRef v5;
  uint64_t result;
  uint64_t valuePtr;

  valuePtr = a2;
  v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
  if (!v4)
    return 4294955266;
  v5 = v4;
  result = 0;
  *a3 = v5;
  return result;
}

uint64_t FigTransportGetRemoteObjectRefFromCFNumber(const void *a1, void *a2)
{
  CFTypeID v4;
  uint64_t v5;

  if (!a1)
    return 4294955259;
  v4 = CFGetTypeID(a1);
  v5 = 4294955259;
  if (v4 == CFNumberGetTypeID())
  {
    if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt64Type, a2))
      return 0;
    else
      return 4294955259;
  }
  return v5;
}

uint64_t FigTransportCreateCFNumberFromLocalObjectRef(uint64_t a1, uint64_t a2, CFNumberRef *a3)
{
  CFNumberRef v4;
  CFNumberRef v5;
  uint64_t result;
  uint64_t valuePtr;

  valuePtr = a2;
  v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
  if (!v4)
    return 4294955266;
  v5 = v4;
  result = 0;
  *a3 = v5;
  return result;
}

uint64_t FigTransportGetLocalObjectRefFromCFNumber(const void *a1, _QWORD *a2)
{
  CFTypeID v4;
  uint64_t result;
  uint64_t valuePtr;

  valuePtr = 0;
  if (!a1)
    return 4294955259;
  v4 = CFGetTypeID(a1);
  if (v4 != CFNumberGetTypeID() || !CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt64Type, &valuePtr))
    return 4294955259;
  result = 0;
  *a2 = valuePtr;
  return result;
}

uint64_t FigTransportCreateBBufFromRemoteObjectRef(const __CFAllocator *a1, uint64_t a2, CMBlockBufferRef *a3)
{
  uint64_t v4;

  v4 = a2;
  return FigCreateBlockBufferCopyingMemoryBlock(a1, &v4, 8uLL, a3);
}

uint64_t FigTransportGetRemoteObjectRefFromBBuf(OpaqueCMBlockBuffer *a1, void *destination)
{
  return CMBlockBufferCopyDataBytes(a1, 0, 8uLL, destination);
}

uint64_t FigJSONObjectCreateWithData(uint64_t a1, unsigned int a2, CFTypeRef *a3)
{
  uint64_t v3;
  Class Class;
  Class v8;
  SEL v9;
  const char *v10;
  uint64_t v11;
  void *v12;
  id v13;
  CFIndex Code;
  CFErrorRef err;

  err = 0;
  v3 = 4294949992;
  if (a1 && a3)
  {
    Class = objc_getClass("NSJSONSerialization");
    if (Class && (v8 = Class, (v9 = sel_registerName("JSONObjectWithData:options:error:")) != 0))
    {
      v10 = v9;
      v11 = a2;
      v12 = (void *)MEMORY[0x193FFC34C]();
      v13 = objc_msgSend(v8, v10, a1, v11, &err);
      if (v13)
      {
        v3 = 0;
        *a3 = CFRetain(v13);
      }
      else
      {
        v3 = 4294949991;
        if (err)
        {
          Code = CFErrorGetCode(err);
          if (Code == (int)Code)
            v3 = Code;
          else
            v3 = 4294949991;
        }
      }
      if (v12)
        objc_autoreleasePoolPop(v12);
    }
    else
    {
      return 4294949991;
    }
  }
  return v3;
}

id FigIsValidJSONObject(uint64_t a1)
{
  Class Class;
  Class v3;
  SEL v4;
  const char *v5;
  void *v6;
  id v7;

  Class = objc_getClass("NSJSONSerialization");
  if (!Class)
    return 0;
  v3 = Class;
  v4 = sel_registerName("isValidJSONObject:");
  if (!v4)
    return 0;
  v5 = v4;
  v6 = (void *)MEMORY[0x193FFC34C]();
  v7 = objc_msgSend(v3, v5, a1);
  if (v6)
    objc_autoreleasePoolPop(v6);
  return v7;
}

uint64_t FigCFDataCreateWithJSONObject(uint64_t a1, unsigned int a2, CFTypeRef *a3)
{
  uint64_t v3;
  Class Class;
  Class v8;
  SEL v9;
  const char *v10;
  void *v11;
  id v12;
  CFIndex Code;
  CFErrorRef err;

  err = 0;
  v3 = 4294949992;
  if (a1 && a3)
  {
    Class = objc_getClass("NSJSONSerialization");
    if (Class && (v8 = Class, (v9 = sel_registerName("dataWithJSONObject:options:error:")) != 0))
    {
      v10 = v9;
      v11 = (void *)MEMORY[0x193FFC34C]();
      v12 = objc_msgSend(v8, v10, a1, a2, &err);
      if (v12)
      {
        v3 = 0;
        *a3 = CFRetain(v12);
      }
      else
      {
        v3 = 4294949991;
        if (err)
        {
          Code = CFErrorGetCode(err);
          if (Code == (int)Code)
            v3 = Code;
          else
            v3 = 4294949991;
        }
      }
      if (v11)
        objc_autoreleasePoolPop(v11);
    }
    else
    {
      return 4294949991;
    }
  }
  return v3;
}

uint64_t FigEndpointStreamGetClassID()
{
  if (FigEndpointStreamGetClassID_sRegisterFigEndpointStreamBaseTypeOnce != -1)
    dispatch_once_f(&FigEndpointStreamGetClassID_sRegisterFigEndpointStreamBaseTypeOnce, &FigEndpointStreamGetClassID_sFigEndpointStreamClassID, (dispatch_function_t)stream_getClassID_0);
  return FigEndpointStreamGetClassID_sFigEndpointStreamClassID;
}

uint64_t stream_getClassID_0(_QWORD *a1)
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&stream_getClassID_sFigEndpointStreamClassDesc, ClassID, 1, a1);
}

uint64_t FigEndpointStreamGetTypeID()
{
  if (FigEndpointStreamGetClassID_sRegisterFigEndpointStreamBaseTypeOnce != -1)
    dispatch_once_f(&FigEndpointStreamGetClassID_sRegisterFigEndpointStreamBaseTypeOnce, &FigEndpointStreamGetClassID_sFigEndpointStreamClassID, (dispatch_function_t)stream_getClassID_0);
  return CMBaseClassGetCFTypeID((_QWORD *)FigEndpointStreamGetClassID_sFigEndpointStreamClassID);
}

CFStringRef stream_copyFormattingDesc_0(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigEndpointStream %p]"), a1);
}

uint64_t FigCPEFairPlayCryptorGetClassID()
{
  FigThreadRunOnce(&FigCPEFairPlayCryptorGetClassID_sRegisterFigFairPlayCPECryptorTypeOnce, (void (*)(void))RegisterFigFairPlayCPECryptorType);
  return sFigCPEFairPlayCryptorClassID;
}

uint64_t RegisterFigFairPlayCPECryptorType()
{
  _QWORD *ClassID;

  ClassID = (_QWORD *)FigCPECryptorGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigCPEFairPlayCryptorClassDesc, ClassID, 0, &sFigCPEFairPlayCryptorClassID);
}

CFTypeRef FigCPEFairPlayCryptorCopyFormattingDesc()
{
  return CFRetain(CFSTR("[FigCPEFPCryptor]"));
}

uint64_t FigByteStreamCreateWithIOSurface(IOSurfaceRef buffer, size_t a2, char a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  return _createByteStreamWithIOSurface(a5, buffer, a2, 0, a3, a4, a6);
}

uint64_t _createByteStreamWithIOSurface(uint64_t a1, IOSurfaceRef buffer, size_t a3, int a4, char a5, uint64_t a6, CFTypeRef *a7)
{
  IOSurfaceLockOptions v7;
  char v11;
  _QWORD *ClassID;
  uint64_t v15;
  uint64_t DerivedStorage;
  __IOSurface *v17;
  uint64_t v18;
  CFTypeRef cf;

  cf = 0;
  v7 = a4 == 0;
  if (a6)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  if (!buffer)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  v11 = a4;
  if (IOSurfaceGetAllocSize(buffer) < a3)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  if (IOSurfaceLock(buffer, v7, 0))
    return 4294954422;
  ClassID = (_QWORD *)CMByteStreamGetClassID();
  v15 = CMDerivedObjectCreate(a1, (uint64_t)&kFigIOSurfaceByteStreamVTable, ClassID, &cf);
  if ((_DWORD)v15)
  {
    v18 = v15;
    IOSurfaceUnlock(buffer, v7, 0);
    if (cf)
      CFRelease(cf);
  }
  else
  {
    DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
    v17 = (__IOSurface *)CFRetain(buffer);
    *(_QWORD *)DerivedStorage = v17;
    *(_QWORD *)(DerivedStorage + 8) = a3;
    if ((a5 & 1) != 0)
    {
      *(_QWORD *)(DerivedStorage + 8) = IOSurfaceGetAllocSize(buffer);
      v17 = *(__IOSurface **)DerivedStorage;
    }
    *(_BYTE *)(DerivedStorage + 16) = v11;
    IOSurfaceIncrementUseCount(v17);
    v18 = 0;
    *a7 = cf;
  }
  return v18;
}

uint64_t FigByteStreamCreateWritableWithIOSurface(IOSurfaceRef buffer, size_t a2, char a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  return _createByteStreamWithIOSurface(a5, buffer, a2, 1, a3, a4, a6);
}

BOOL FigIOSurfaceByteStreamEqual(uint64_t a1, uint64_t a2)
{
  _QWORD *DerivedStorage;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  return *DerivedStorage == *(_QWORD *)CMBaseObjectGetDerivedStorage(a2);
}

void FigIOSurfaceByteStreamFinalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v2;
  const void *v3;
  const void *v4;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_QWORD *)DerivedStorage)
  {
    IOSurfaceUnlock(*(IOSurfaceRef *)DerivedStorage, *(_BYTE *)(DerivedStorage + 16) == 0, 0);
    IOSurfaceDecrementUseCount(*(IOSurfaceRef *)DerivedStorage);
    if (*(_QWORD *)DerivedStorage)
      CFRelease(*(CFTypeRef *)DerivedStorage);
  }
  v2 = *(const void **)(DerivedStorage + 24);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(DerivedStorage + 32);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(DerivedStorage + 40);
  if (v4)
    CFRelease(v4);
}

uint64_t FigIOSurfaceByteStreamCopyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t DerivedStorage;
  void *SInt64;
  void *v8;
  uint64_t result;
  const void *v10;
  const void **v11;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, CFSTR("FBS_EntireLength")) || CFEqual(a2, CFSTR("FBS_AvailableLength")))
  {
    SInt64 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(_QWORD *)(DerivedStorage + 8));
LABEL_4:
    v8 = SInt64;
LABEL_5:
    result = 0;
    *a4 = v8;
    return result;
  }
  if (CFEqual(a2, CFSTR("FBS_EntireLengthAvailableOnDemand")))
  {
    v10 = (const void *)*MEMORY[0x1E0C9AE50];
LABEL_8:
    SInt64 = (void *)CFRetain(v10);
    goto LABEL_4;
  }
  if (CFEqual(a2, CFSTR("FBS_URL")))
  {
    v10 = *(const void **)(DerivedStorage + 24);
    if (v10)
      goto LABEL_8;
    return 4294954512;
  }
  if (CFEqual(a2, CFSTR("FBS_FileType")))
  {
    v10 = *(const void **)(DerivedStorage + 40);
    if (v10)
      goto LABEL_8;
    return 4294954512;
  }
  if (CFEqual(a2, CFSTR("FBS_MIMEType")))
  {
    v10 = *(const void **)(DerivedStorage + 32);
    if (v10)
      goto LABEL_8;
    return 4294954512;
  }
  if (CFEqual(a2, CFSTR("FBS_ReadSupported")))
  {
    v11 = (const void **)MEMORY[0x1E0C9AE50];
    goto LABEL_23;
  }
  if (CFEqual(a2, CFSTR("FBS_WriteSupported")))
  {
    v11 = (const void **)MEMORY[0x1E0C9AE50];
    if (!*(_BYTE *)(DerivedStorage + 16))
      v11 = (const void **)MEMORY[0x1E0C9AE40];
LABEL_23:
    v10 = *v11;
    if (!*v11)
    {
      v8 = 0;
      goto LABEL_5;
    }
    goto LABEL_8;
  }
  return FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
}

uint64_t FigIOSurfaceByteStreamSetProperty(const void *a1, const void *a2, const __CFString *a3)
{
  _QWORD *DerivedStorage;
  CFTypeID v7;
  const void *v8;
  CFTypeID v9;
  CFTypeID v10;
  const void *v11;
  const __CFAllocator *v12;
  uint64_t v14;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (CFEqual(a2, CFSTR("FBS_URL")))
  {
    if (a3)
    {
      v7 = CFGetTypeID(a3);
      if (v7 == CFURLGetTypeID())
      {
        v8 = (const void *)DerivedStorage[3];
        DerivedStorage[3] = a3;
        goto LABEL_9;
      }
      goto LABEL_25;
    }
    v8 = (const void *)DerivedStorage[3];
    DerivedStorage[3] = 0;
    if (!v8)
      return 0;
LABEL_21:
    CFRelease(v8);
    return 0;
  }
  if (CFEqual(a2, CFSTR("FBS_FileType")))
  {
    if (a3)
    {
      v9 = CFGetTypeID(a3);
      if (v9 == CFNumberGetTypeID())
      {
        v8 = (const void *)DerivedStorage[5];
        DerivedStorage[5] = a3;
LABEL_9:
        CFRetain(a3);
        if (!v8)
          return 0;
        goto LABEL_21;
      }
      goto LABEL_25;
    }
    v8 = (const void *)DerivedStorage[5];
    DerivedStorage[5] = 0;
    if (!v8)
      return 0;
    goto LABEL_21;
  }
  if (CFEqual(a2, CFSTR("FBS_MIMEType")))
  {
    if (!a3 || (v10 = CFGetTypeID(a3), v10 == CFStringGetTypeID()))
    {
      v11 = (const void *)DerivedStorage[4];
      if (v11)
      {
        CFRelease(v11);
        DerivedStorage[4] = 0;
      }
      if (a3)
      {
        v12 = CFGetAllocator(a1);
        DerivedStorage[4] = CFStringCreateCopy(v12, a3);
      }
      return 0;
    }
LABEL_25:
    v14 = 4294954424;
    return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  }
  v14 = 4294954512;
  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

uint64_t FigIOSurfaceByteStreamRead(uint64_t a1, size_t a2, uint64_t a3, void *a4, size_t *a5)
{
  uint64_t CMBaseObject;
  uint64_t DerivedStorage;
  uint64_t v11;
  BOOL v12;
  size_t v13;
  char *BaseAddress;
  uint64_t result;

  CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(CMBaseObject);
  if (a2)
  {
    if (a3 < 0)
    {
      result = FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
      a2 = 0;
      if (!a5)
        return result;
      goto LABEL_9;
    }
    v11 = *(_QWORD *)(DerivedStorage + 8);
    v12 = v11 <= a3;
    v13 = v11 - a3;
    if (v12)
      return 4294954423;
    if (v13 < a2)
      a2 = v13;
    if (a2)
    {
      BaseAddress = (char *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)DerivedStorage);
      memcpy(a4, &BaseAddress[a3], a2);
    }
  }
  result = 0;
  if (!a5)
    return result;
LABEL_9:
  if (!(_DWORD)result)
    *a5 = a2;
  return result;
}

uint64_t FigIOSurfaceByteStreamWrite(uint64_t a1, size_t a2, uint64_t a3, const void *a4, size_t *a5)
{
  uint64_t CMBaseObject;
  uint64_t DerivedStorage;
  uint64_t v11;
  size_t AllocSize;
  char *BaseAddress;
  uint64_t result;
  size_t v15;
  uint64_t v16;

  CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(CMBaseObject);
  if (!*(_BYTE *)(DerivedStorage + 16))
  {
    v16 = 4294954419;
    goto LABEL_17;
  }
  if (!a4 || a3 < 0)
  {
    v16 = 4294954424;
LABEL_17:
    result = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    goto LABEL_11;
  }
  if (a2)
  {
    v11 = DerivedStorage;
    AllocSize = IOSurfaceGetAllocSize(*(IOSurfaceRef *)DerivedStorage);
    if (((AllocSize - a3) & ~((uint64_t)(AllocSize - a3) >> 63)) < a2)
      a2 = (AllocSize - a3) & ~((uint64_t)(AllocSize - a3) >> 63);
    if (!a2)
      return 4294954423;
    BaseAddress = (char *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)v11);
    memcpy(&BaseAddress[a3], a4, a2);
    result = 0;
    v15 = *(_QWORD *)(v11 + 8);
    if (v15 <= a2 + a3)
      v15 = a2 + a3;
    *(_QWORD *)(v11 + 8) = v15;
  }
  else
  {
    result = 0;
  }
LABEL_11:
  if (a5)
  {
    if (!(_DWORD)result)
      *a5 = a2;
  }
  return result;
}

uint64_t FigIOSurfaceByteStreamGetAvailableLengthAtOffset(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t CMBaseObject;
  uint64_t DerivedStorage;

  CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(CMBaseObject);
  if (!a3)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  *a3 = (*(_QWORD *)(DerivedStorage + 8) - a2) & ~((*(_QWORD *)(DerivedStorage + 8) - a2) >> 63);
  return 0;
}

uint64_t FigIOSurfaceByteStreamReadAndCreateBlockBuffer(const void *a1, size_t a2, uint64_t a3, CMBlockBufferRef *a4, size_t *a5)
{
  const __CFAllocator *v10;

  v10 = CFGetAllocator(a1);
  return CMCreateContiguousBlockBufferFromStream((uint64_t)a1, v10, a2, a3, a4, a5);
}

uint64_t FigHALAudioPluginGetClassID()
{
  if (FigHALAudioPluginGetClassID_sRegisterFigHALAudioPluginClassOnce != -1)
    dispatch_once(&FigHALAudioPluginGetClassID_sRegisterFigHALAudioPluginClassOnce, &__block_literal_global_50);
  return FigHALAudioPluginGetClassID_sFigHALAudioPluginClassID;
}

uint64_t FigCaptionPositionGetTypeID()
{
  FigThreadRunOnce(&sRegisterFigCaptionPositionTypeOnce, (void (*)(void))RegisterFigCaptionPositionType);
  return sFigCaptionPositionID;
}

uint64_t RegisterFigCaptionPositionType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigCaptionPositionID = result;
  return result;
}

uint64_t FigCaptionPositionGetHorizontalEdgeReference(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 16);
  FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  return 1701999215;
}

uint64_t FigCaptionPositionGetHorizontalEdgeOffset(uint64_t a1)
{
  uint64_t *v1;

  if (a1)
  {
    v1 = (uint64_t *)(a1 + 24);
  }
  else
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v1 = &kFigGeometryDimensionInvalid;
  }
  return *v1;
}

uint64_t FigCaptionPositionGetVerticalEdgeReference(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 20);
  FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  return 1701999215;
}

uint64_t FigCaptionPositionGetVerticalEdgeOffset(uint64_t a1)
{
  uint64_t *v1;

  if (a1)
  {
    v1 = (uint64_t *)(a1 + 40);
  }
  else
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v1 = &kFigGeometryDimensionInvalid;
  }
  return *v1;
}

uint64_t FigCaptionPositionGetEffectiveHorizontalEdgeReference(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 56);
  FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  return 1701999215;
}

uint64_t FigCaptionPositionGetEffectiveHorizontalEdgeOffset(uint64_t a1)
{
  uint64_t *v1;

  if (a1)
  {
    v1 = (uint64_t *)(a1 + 64);
  }
  else
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v1 = &kFigGeometryDimensionInvalid;
  }
  return *v1;
}

uint64_t FigCaptionPositionGetEffectiveVerticalEdgeReference(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 60);
  FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  return 1701999215;
}

uint64_t FigCaptionPositionGetEffectiveVerticalEdgeOffset(uint64_t a1)
{
  uint64_t *v1;

  if (a1)
  {
    v1 = (uint64_t *)(a1 + 80);
  }
  else
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v1 = &kFigGeometryDimensionInvalid;
  }
  return *v1;
}

uint64_t FigCaptionAbstractPositionEqualToAbstractPosition(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  char v6;

  if (a1 == a2)
    return 1;
  v4 = 0;
  if (!a1 || !a2)
    return v4;
  if (a3)
    v6 = a3;
  else
    v6 = 27;
  if ((v6 & 1) != 0)
  {
    v4 = *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16);
    if ((v6 & 2) != 0)
    {
LABEL_9:
      if (*(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20))
        v4 = v4;
      else
        v4 = 0;
    }
  }
  else
  {
    v4 = 1;
    if ((v6 & 2) != 0)
      goto LABEL_9;
  }
  if ((v6 & 8) == 0)
  {
    if ((v6 & 0x10) == 0)
      return v4;
    goto LABEL_22;
  }
  if (FigGeometryDimensionEqualToDimension(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32)))
  {
    v4 = v4;
  }
  else
  {
    v4 = 0;
  }
  if ((v6 & 0x10) != 0)
  {
LABEL_22:
    if (FigGeometryDimensionEqualToDimension(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a2 + 40), *(_QWORD *)(a2 + 48)))
    {
      return v4;
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t FigCaptionPositionCreate(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  uint64_t Instance;
  uint64_t v16;
  _OWORD *v17;
  _OWORD *v18;
  int v19;
  int v20;
  _OWORD *v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;

  if (a8)
  {
    FigThreadRunOnce(&sRegisterFigCaptionPositionTypeOnce, (void (*)(void))RegisterFigCaptionPositionType);
    Instance = _CFRuntimeCreateInstance();
    if (!Instance)
    {
      FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      return 0;
    }
    v16 = Instance;
    *(_QWORD *)(Instance + 24) = a3;
    *(_QWORD *)(Instance + 32) = a4;
    v17 = (_OWORD *)(Instance + 24);
    *(_QWORD *)(Instance + 40) = a6;
    v18 = (_OWORD *)(Instance + 40);
    *(_DWORD *)(Instance + 16) = a2;
    *(_DWORD *)(Instance + 20) = a5;
    *(_QWORD *)(Instance + 48) = a7;
    *(_OWORD *)(Instance + 64) = *(_OWORD *)(Instance + 24);
    *(_DWORD *)(Instance + 56) = a2;
    *(_DWORD *)(Instance + 60) = a5;
    *(_OWORD *)(Instance + 80) = *(_OWORD *)(Instance + 40);
    v19 = a2 != 0;
    if (a2)
      v20 = 2;
    else
      v20 = 1;
    if ((a4 & 0x1D00000000) == 0x100000000)
      v19 = v20;
    if (a5)
      ++v19;
    if ((a7 & 0x1D00000000) == 0x100000000)
      ++v19;
    *(_BYTE *)(Instance + 96) = v19;
    v21 = (_OWORD *)(Instance + 64);
    switch(v19)
    {
      case 0:
        goto LABEL_106;
      case 1:
        if (a2)
        {
          v22 = 1919510376;
          if (a2 == 1919510376 || (v22 = 1818584692, a2 == 1818584692))
          {
            *(_DWORD *)(Instance + 56) = v22;
LABEL_17:
            v23 = 1667591796;
LABEL_18:
            *(_DWORD *)(Instance + 60) = v23;
            goto LABEL_106;
          }
        }
        else if (a5 > 1667591795)
        {
          v23 = 1667591796;
          if (a5 == 1667591796)
          {
            *(_DWORD *)(Instance + 56) = 1667591796;
            goto LABEL_18;
          }
          if (a5 == 1953460256)
          {
            *(_DWORD *)(Instance + 56) = 1667591796;
            v23 = 1953460256;
            goto LABEL_18;
          }
        }
        else
        {
          if (!a5)
          {
            *v21 = *v17;
            goto LABEL_17;
          }
          if (a5 == 1651471476)
          {
            *(_DWORD *)(Instance + 56) = 1667591796;
            v23 = 1651471476;
            goto LABEL_18;
          }
        }
        goto LABEL_106;
      case 2:
        FigGeometryDimensionMake();
        v27 = v26;
        v29 = v28;
        FigGeometryDimensionMake();
        v31 = v30;
        v33 = v32;
        FigGeometryDimensionMake();
        *(_QWORD *)(v16 + 56) = 0x746F70206C656674;
        v36 = *(_DWORD *)(v16 + 16);
        if (v36 <= 1818584691)
        {
          if (!v36)
          {
            v43 = *(_DWORD *)(v16 + 20);
            if (v43 > 1667591795)
              goto LABEL_59;
            if (v43)
            {
              v47 = 1651471476;
              goto LABEL_61;
            }
            goto LABEL_51;
          }
          if (v36 != 1667591796)
            goto LABEL_106;
          v37 = *(_DWORD *)(v16 + 20);
          if (v37 > 1667591795)
          {
            if (v37 == 1667591796)
              goto LABEL_99;
            if (v37 == 1953460256)
            {
              *(_QWORD *)(v16 + 64) = v31;
              *(_QWORD *)(v16 + 72) = v33;
              goto LABEL_72;
            }
            goto LABEL_106;
          }
          if (!v37)
          {
            *(_QWORD *)(v16 + 64) = v31;
            *(_QWORD *)(v16 + 72) = v33;
            goto LABEL_103;
          }
          if (v37 != 1651471476)
            goto LABEL_106;
          *(_QWORD *)(v16 + 64) = v31;
          *(_QWORD *)(v16 + 72) = v33;
          goto LABEL_97;
        }
        if (v36 != 1919510376)
        {
          if (v36 != 1818584692)
            goto LABEL_106;
          v45 = *(_DWORD *)(v16 + 20);
          if (v45 <= 1667591795)
          {
            if (!v45)
              goto LABEL_75;
            if (v45 == 1651471476)
            {
              *(_QWORD *)(v16 + 64) = v27;
              *(_QWORD *)(v16 + 72) = v29;
              goto LABEL_97;
            }
            goto LABEL_106;
          }
          if (v45 == 1667591796)
          {
            *(_QWORD *)(v16 + 64) = v27;
            *(_QWORD *)(v16 + 72) = v29;
            goto LABEL_105;
          }
          if (v45 != 1953460256)
            goto LABEL_106;
          *(_QWORD *)(v16 + 64) = v27;
          *(_QWORD *)(v16 + 72) = v29;
          goto LABEL_72;
        }
        v48 = *(_DWORD *)(v16 + 20);
        if (v48 > 1667591795)
        {
          if (v48 == 1667591796)
            goto LABEL_99;
          if (v48 == 1953460256)
          {
            *(_QWORD *)(v16 + 64) = v34;
            *(_QWORD *)(v16 + 72) = v35;
            goto LABEL_72;
          }
        }
        else
        {
          if (!v48)
            goto LABEL_78;
          if (v48 == 1651471476)
            goto LABEL_96;
        }
        goto LABEL_106;
      case 3:
        FigGeometryDimensionMake();
        v27 = v38;
        v29 = v39;
        FigGeometryDimensionMake();
        v31 = v40;
        v33 = v41;
        FigGeometryDimensionMake();
        *(_QWORD *)(v16 + 56) = 0x746F70206C656674;
        v42 = *(_DWORD *)(v16 + 16);
        if ((*(_DWORD *)(v16 + 36) & 0x1D) == 1)
        {
          if (v42 == 1919510376)
          {
            v49 = *(_DWORD *)(v16 + 20);
            if (v49 == 1651471476)
            {
              *(_DWORD *)(v16 + 56) = 1919510376;
LABEL_96:
              *(_QWORD *)(v16 + 64) = v34;
              *(_QWORD *)(v16 + 72) = v35;
              goto LABEL_97;
            }
            if (v49 != 1667591796)
            {
              if (v49 != 1953460256)
                goto LABEL_106;
              *(_DWORD *)(v16 + 56) = 1919510376;
              goto LABEL_71;
            }
            *(_DWORD *)(v16 + 56) = 1919510376;
LABEL_99:
            *(_QWORD *)(v16 + 64) = v31;
            *(_QWORD *)(v16 + 72) = v33;
          }
          else
          {
            if (v42 != 1818584692)
              goto LABEL_106;
            v43 = *(_DWORD *)(v16 + 20);
            if (v43 == 1651471476)
            {
              *v21 = *v17;
LABEL_97:
              *(_QWORD *)(v16 + 80) = v34;
              *(_QWORD *)(v16 + 88) = v35;
              goto LABEL_106;
            }
LABEL_59:
            if (v43 != 1667591796)
            {
              v47 = 1953460256;
LABEL_61:
              if (v43 != v47)
                goto LABEL_106;
LABEL_71:
              *v21 = *v17;
LABEL_72:
              *(_QWORD *)(v16 + 80) = v27;
              *(_QWORD *)(v16 + 88) = v29;
              goto LABEL_106;
            }
            *v21 = *v17;
          }
LABEL_105:
          *(_QWORD *)(v16 + 80) = v31;
          *(_QWORD *)(v16 + 88) = v33;
LABEL_106:
          v25 = 0;
          *a8 = v16;
          return v25;
        }
        switch(v42)
        {
          case 1667591796:
            v46 = *(_DWORD *)(v16 + 20);
            if (v46 == 1651471476)
            {
              *(_QWORD *)(v16 + 64) = v27;
              *(_QWORD *)(v16 + 72) = v29;
              goto LABEL_101;
            }
            break;
          case 1919510376:
            v50 = *(_DWORD *)(v16 + 20);
            if (v50 != 1651471476)
            {
              if (v50 != 1953460256)
                goto LABEL_106;
LABEL_78:
              *(_QWORD *)(v16 + 64) = v34;
              *(_QWORD *)(v16 + 72) = v35;
              goto LABEL_103;
            }
            goto LABEL_91;
          case 1818584692:
            v46 = *(_DWORD *)(v16 + 20);
            if (v46 == 1651471476)
            {
LABEL_91:
              *(_QWORD *)(v16 + 64) = v34;
              *(_QWORD *)(v16 + 72) = v35;
LABEL_101:
              *(_DWORD *)(v16 + 60) = 1651471476;
LABEL_103:
              *(_OWORD *)((char *)v17 + 56) = *v18;
              goto LABEL_106;
            }
            break;
          default:
            goto LABEL_106;
        }
        if (v46 != 1953460256)
          goto LABEL_106;
LABEL_75:
        *(_QWORD *)(v16 + 64) = v27;
        *(_QWORD *)(v16 + 72) = v29;
        goto LABEL_103;
      case 4:
        *(_QWORD *)(Instance + 56) = 0x746F70206C656674;
        if (a2 == 1919510376)
        {
          if (a5 == 1953460256)
            goto LABEL_51;
          v44 = 1651471476;
        }
        else
        {
          if (a2 != 1818584692)
            goto LABEL_106;
          if (a5 == 1651471476)
            goto LABEL_51;
          v44 = 1953460256;
        }
        if (a5 != v44)
          goto LABEL_106;
LABEL_51:
        *v21 = *v17;
        goto LABEL_103;
      default:
        v24 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
        if (!(_DWORD)v24)
          goto LABEL_106;
        v25 = v24;
        CFRelease((CFTypeRef)v16);
        return v25;
    }
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

double fcpos_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 96) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

BOOL fcpos_Equal(_BOOL8 result, uint64_t a2)
{
  uint64_t v3;
  CFTypeID v4;
  CFTypeID v5;

  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID((CFTypeRef)result);
    FigThreadRunOnce(&sRegisterFigCaptionPositionTypeOnce, (void (*)(void))RegisterFigCaptionPositionType);
    result = 0;
    if (a2)
    {
      if (v4 == sFigCaptionPositionID)
      {
        v5 = CFGetTypeID((CFTypeRef)a2);
        FigThreadRunOnce(&sRegisterFigCaptionPositionTypeOnce, (void (*)(void))RegisterFigCaptionPositionType);
        if (v5 == sFigCaptionPositionID
          && *(_DWORD *)(v3 + 16) == *(_DWORD *)(a2 + 16)
          && *(_DWORD *)(v3 + 20) == *(_DWORD *)(a2 + 20))
        {
          result = FigGeometryDimensionEqualToDimension(*(_QWORD *)(v3 + 24), *(_QWORD *)(v3 + 32), *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32));
          if (result)
            return FigGeometryDimensionEqualToDimension(*(_QWORD *)(v3 + 40), *(_QWORD *)(v3 + 48), *(_QWORD *)(a2 + 40), *(_QWORD *)(a2 + 48));
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

const void *fcpos_Hash(const void *result)
{
  const void *v1;
  CFTypeID v2;
  uint64_t v3;
  uint64_t v4;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    FigThreadRunOnce(&sRegisterFigCaptionPositionTypeOnce, (void (*)(void))RegisterFigCaptionPositionType);
    if (v2 == sFigCaptionPositionID)
    {
      v3 = (*((_DWORD *)v1 + 5) ^ *((_DWORD *)v1 + 4));
      v4 = FigGeometryDimensionHash(*((_QWORD *)v1 + 3), *((_QWORD *)v1 + 4));
      return (const void *)(v4 ^ FigGeometryDimensionHash(*((_QWORD *)v1 + 5), *((_QWORD *)v1 + 6)) ^ v3);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFStringRef fcpos_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionPosition %p]"), a1);
}

CFStringRef fcpos_CopyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  CFStringRef v3;
  CFStringRef v4;
  __CFString *v5;
  __CFString *v6;
  const __CFString *v7;
  const __CFString *v8;
  CFStringRef v9;

  v2 = CFGetAllocator((CFTypeRef)a1);
  v3 = fcpos_CopyEdgeReferenceDescription(v2, *(_DWORD *)(a1 + 16));
  v4 = fcpos_CopyEdgeReferenceDescription(v2, *(_DWORD *)(a1 + 20));
  if ((*(_DWORD *)(a1 + 36) & 0x1D) == 1)
    v5 = FigGeometryDimensionCopyDescription(v2, *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
  else
    v5 = 0;
  if ((*(_DWORD *)(a1 + 52) & 0x1D) == 1)
    v6 = FigGeometryDimensionCopyDescription(v2, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  else
    v6 = 0;
  v7 = CFSTR("N/A");
  if (v5)
    v8 = v5;
  else
    v8 = CFSTR("N/A");
  if (v6)
    v7 = v6;
  v9 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionPosition %p] < horizontal:(%@, %@) vertical:(%@, %@) >"), a1, v3, v8, v4, v7);
  if (v6)
    CFRelease(v6);
  if (v5)
    CFRelease(v5);
  if (v4)
    CFRelease(v4);
  if (v3)
    CFRelease(v3);
  return v9;
}

CFStringRef fcpos_CopyEdgeReferenceDescription(const __CFAllocator *a1, signed int a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v5;
  char v6;
  uint64_t v7;
  uint64_t v8;

  if (a2 <= 1701999214)
  {
    switch(a2)
    {
      case 0:
        return (CFStringRef)CFRetain(CFSTR("<N/A>"));
      case 1651471476:
        return (CFStringRef)CFRetain(CFSTR("bottom"));
      case 1667591796:
        return (CFStringRef)CFRetain(CFSTR("center"));
    }
    goto LABEL_17;
  }
  if (a2 > 1919510375)
  {
    if (a2 == 1919510376)
      return (CFStringRef)CFRetain(CFSTR("right"));
    if (a2 == 1953460256)
      return (CFStringRef)CFRetain(CFSTR("top"));
    goto LABEL_17;
  }
  if (a2 == 1701999215)
    return (CFStringRef)CFRetain(CFSTR("<error>"));
  if (a2 != 1818584692)
  {
LABEL_17:
    v7 = v2;
    v8 = v3;
    v5 = bswap32(a2);
    v6 = 0;
    return CFStringCreateWithFormat(a1, 0, CFSTR("unknown(%.4s)"), &v5);
  }
  return (CFStringRef)CFRetain(CFSTR("left"));
}

uint64_t remoteXPCEndpointPlaybackSessionClient_EnsureClientEstablished()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __remoteXPCEndpointPlaybackSessionClient_EnsureClientEstablished_block_invoke;
  block[3] = &unk_1E28E4918;
  block[4] = &v3;
  if (remoteXPCEndpointPlaybackSessionClient_EnsureClientEstablished_sFigEndpointPlaybackSessionRemoteClientSetupOnce != -1)
    dispatch_once(&remoteXPCEndpointPlaybackSessionClient_EnsureClientEstablished_sFigEndpointPlaybackSessionRemoteClientSetupOnce, block);
  v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t FigEndpointPlaybackSessionXPCRemoteCreateWithObjectID(const void *a1, _QWORD *a2)
{
  uint64_t result;
  const __CFAllocator *v5;
  _QWORD *ClassID;
  _QWORD *DerivedStorage;
  CFMutableDictionaryRef v8;
  dispatch_queue_t v9;
  CFDictionaryValueCallBacks v10;
  uint64_t v11;

  if (!a1 || !a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  result = remoteXPCEndpointPlaybackSessionClient_EnsureClientEstablished();
  if (!(_DWORD)result)
  {
    v11 = 0;
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    ClassID = (_QWORD *)FigEndpointPlaybackSessionGetClassID();
    result = CMDerivedObjectCreate((uint64_t)v5, (uint64_t)&kFigEndpointPlaybackSessionRemoteXPC_EndpointPlaybackSessionVTable, ClassID, &v11);
    if (!(_DWORD)result)
    {
      DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(v11);
      DerivedStorage[1] = a1;
      DerivedStorage[7] = 1;
      v10.version = 0;
      v10.retain = (CFDictionaryRetainCallBack)remoteXPCEndpointPlaybackSession_cloneCompletionCallback;
      v10.release = (CFDictionaryReleaseCallBack)remoteXPCEndpointPlaybackSession_freeCompletionCallback;
      v10.copyDescription = 0;
      v10.equal = 0;
      v8 = CFDictionaryCreateMutable(v5, 0, 0, &v10);
      DerivedStorage[3] = v8;
      if (v8
        && (v9 = dispatch_queue_create("com.apple.coremedia.endpointplaybacksession.callbacks", 0),
            (DerivedStorage[2] = v9) != 0))
      {
        FigXPCRemoteClientAssociateObject(gFigEndpointPlaybackSessionRemoteClient, v11, a1);
        result = 0;
      }
      else
      {
        result = FigSignalErrorAt(4294950555, 0, 0, 0, 0, 0, 0);
      }
    }
    *a2 = v11;
  }
  return result;
}

void remoteXPCEndpointPlaybackSessionClient_DeadConnectionCallback(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *v3;
  const __CFDictionary *v4;
  const void *v5;
  _QWORD block[6];
  int context;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  *(_BYTE *)(CMBaseObjectGetDerivedStorage(a1) + 1) = 1;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  context = -16722;
  v3 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigEndpointPlaybackSessionRemoteXPC_runAllCallbacks_block_invoke;
  block[3] = &unk_1E28E4940;
  block[4] = &v8;
  block[5] = DerivedStorage;
  dispatch_sync(v3, block);
  v4 = (const __CFDictionary *)v9[3];
  if (v4)
  {
    CFDictionaryApplyFunction(v4, (CFDictionaryApplierFunction)FigEndpointPlaybackSessionRemoteXPC_runOneCallback, &context);
    v5 = (const void *)v9[3];
    if (v5)
      CFRelease(v5);
  }
  _Block_object_dispose(&v8, 8);
}

uint64_t remoteXPCEndpointPlaybackSessionClient_HandleClientMessage(uint64_t a1, void *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t uint64;
  int64_t OSStatus;
  NSObject *v8;
  uint64_t v9;
  uint64_t DerivedStorage;
  NSObject *v11;
  uint64_t v12;
  const char *v13;
  int64_t v14;
  __CFDictionary *v15;
  int v16;
  __CFDictionary *v17;
  CFTypeRef cf;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t block;
  uint64_t v26;
  void (*v27)(uint64_t);
  void *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;

  v16 = 0;
  result = FigXPCMessageGetOpCode(a2, &v16);
  if (!(_DWORD)result)
  {
    if (v16 == 1701340002)
    {
      DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
      v11 = *(NSObject **)(DerivedStorage + 16);
      block = MEMORY[0x1E0C809B0];
      v26 = 0x40000000;
      v27 = __remoteXPCEndpointPlaybackSessionClient_eventHandlerCallback_block_invoke;
      v28 = &__block_descriptor_tmp_5_4;
      v29 = (uint64_t *)DerivedStorage;
      v30 = (uint64_t)a2;
      v31 = a1;
      dispatch_sync(v11, &block);
      return 0;
    }
    if (v16 != 1667329122)
      return 4294966630;
    v19 = 0;
    v20 = &v19;
    v21 = 0x3000000000;
    v23 = 0;
    v24 = 0;
    v22 = 0;
    v5 = CMBaseObjectGetDerivedStorage(a1);
    uint64 = xpc_dictionary_get_uint64(a2, "CompletionID");
    OSStatus = FigXPCMessageGetOSStatus(a2, "CompletionStatus");
    v8 = *(NSObject **)(v5 + 16);
    block = MEMORY[0x1E0C809B0];
    v26 = 0x40000000;
    v27 = __remoteXPCEndpointPlaybackSessionClient_handleCompletionCallback_block_invoke;
    v28 = &unk_1E28E4968;
    v30 = v5;
    v31 = uint64;
    v29 = &v19;
    dispatch_sync(v8, &block);
    v9 = v20[3];
    if (v9 > 1886545248)
    {
      if (v9 <= 1936028776)
      {
        if (v9 == 1886545249)
        {
          cf = 0;
          v14 = FigXPCMessageGetOSStatus(a2, "ResponseStatus");
          FigXPCMessageCopyCFObject(a2, "ResponseParams", (__CFDictionary **)&cf);
          ((void (*)(int64_t, CFTypeRef, uint64_t))v20[5])(v14, cf, v20[4]);
LABEL_27:
          v15 = (__CFDictionary *)cf;
          if (cf)
LABEL_28:
            CFRelease(v15);
LABEL_29:
          _Block_object_dispose(&v19, 8);
          return 0;
        }
        if (v9 != 1919971689)
        {
          if (v9 != 1936024673)
            goto LABEL_29;
          goto LABEL_24;
        }
        goto LABEL_20;
      }
      if (v9 == 1936028777)
      {
LABEL_24:
        cf = 0;
        v13 = "SeekResponseInfo";
LABEL_25:
        FigXPCMessageCopyCFDictionary(a2, v13, &cf);
        ((void (*)(CFTypeRef, int64_t, uint64_t))v20[5])(cf, OSStatus, v20[4]);
        goto LABEL_27;
      }
      if (v9 == 1936875892)
      {
LABEL_20:
        ((void (*)(int64_t, uint64_t))v20[5])(OSStatus, v20[4]);
        goto LABEL_29;
      }
      v12 = 1937010544;
LABEL_19:
      if (v9 != v12)
        goto LABEL_29;
      goto LABEL_20;
    }
    if (v9 <= 1735422065)
    {
      if (v9 != 1635018857)
      {
        if (v9 != 1735421033)
          goto LABEL_29;
        cf = 0;
        v13 = "PlaybackInfo";
        goto LABEL_25;
      }
      v17 = 0;
      cf = 0;
      FigXPCMessageCopyCFData(a2, "PicData", &cf);
      FigXPCMessageCopyCFString(a2, "PlayerGUID", &v17);
      ((void (*)(CFTypeRef, __CFDictionary *, int64_t, uint64_t))v20[5])(cf, v17, OSStatus, v20[4]);
      if (cf)
        CFRelease(cf);
    }
    else
    {
      if (v9 != 1735422066)
      {
        if (v9 == 1768976745)
          goto LABEL_20;
        v12 = 1886151033;
        goto LABEL_19;
      }
      v17 = 0;
      cf = 0;
      FigXPCMessageCopyCFString(a2, "PropertyKey", &cf);
      FigXPCMessageCopyCFObject(a2, "PropertyValue", &v17);
      ((void (*)(CFTypeRef, __CFDictionary *, int64_t, uint64_t))v20[5])(cf, v17, OSStatus, v20[4]);
      if (cf)
      {
        CFRelease(cf);
        cf = 0;
      }
    }
    v15 = v17;
    if (!v17)
      goto LABEL_29;
    goto LABEL_28;
  }
  return result;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_runOneCallback(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t result;

  v3 = *(_QWORD *)a2;
  if (*(uint64_t *)a2 <= 1886545248)
  {
    if (v3 <= 1735422065)
    {
      if (v3 != 1635018857)
      {
        v4 = 1735421033;
LABEL_19:
        if (v3 != v4)
          return result;
        return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a2 + 16))(0, *a3, *(_QWORD *)(a2 + 8));
      }
    }
    else if (v3 != 1735422066)
    {
      v5 = v3 == 1768976745;
      v6 = 1886151033;
      goto LABEL_11;
    }
    return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(a2 + 16))(0, 0, *a3, *(_QWORD *)(a2 + 8));
  }
  if (v3 > 1936028776)
  {
    if (v3 == 1936028777)
      return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a2 + 16))(0, *a3, *(_QWORD *)(a2 + 8));
    v5 = v3 == 1936875892;
    v6 = 1937010544;
LABEL_11:
    if (v5 || v3 == v6)
      return (*(uint64_t (**)(_QWORD, _QWORD))(a2 + 16))(*a3, *(_QWORD *)(a2 + 8));
    return result;
  }
  if (v3 != 1886545249)
  {
    if (v3 != 1919971689)
    {
      v4 = 1936024673;
      goto LABEL_19;
    }
    return (*(uint64_t (**)(_QWORD, _QWORD))(a2 + 16))(*a3, *(_QWORD *)(a2 + 8));
  }
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a2 + 16))(*a3, 0, *(_QWORD *)(a2 + 8));
}

void __remoteXPCEndpointPlaybackSessionClient_handleCompletionCallback_block_invoke(uint64_t a1)
{
  const __CFDictionary *v2;
  _QWORD *Value;
  uint64_t v4;
  __int128 v5;

  v2 = *(const __CFDictionary **)(*(_QWORD *)(a1 + 40) + 24);
  if (v2)
  {
    Value = CFDictionaryGetValue(v2, *(const void **)(a1 + 48));
    if (Value)
    {
      v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v5 = *(_OWORD *)Value;
      *(_QWORD *)(v4 + 40) = Value[2];
      *(_OWORD *)(v4 + 24) = v5;
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 40) + 24), *(const void **)(a1 + 48));
  }
}

void __remoteXPCEndpointPlaybackSessionClient_eventHandlerCallback_block_invoke(uint64_t a1)
{
  CFTypeRef cf;

  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40))
  {
    cf = 0;
    FigXPCMessageCopyCFDictionary(*(void **)(a1 + 40), "EventInfo", &cf);
    (*(void (**)(_QWORD, CFTypeRef, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 40))(*(_QWORD *)(a1 + 48), cf, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48));
    if (cf)
      CFRelease(cf);
  }
}

__n128 remoteXPCEndpointPlaybackSession_cloneCompletionCallback(const __CFAllocator *a1, __n128 *a2)
{
  __n128 *v3;
  unint64_t v4;
  __n128 result;

  v3 = (__n128 *)CFAllocatorAllocate(a1, 24, 0);
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *v3 = *a2;
  v3[1].n128_u64[0] = v4;
  return result;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_Invalidate(uint64_t a1)
{
  uint64_t ObjectID;
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v6;
  void *v7;

  v6 = 0;
  v7 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v6);
  if ((_DWORD)ObjectID)
  {
    v4 = ObjectID;
    v3 = 0;
  }
  else
  {
    v2 = FigXPCCreateBasicMessage(0x696E766Cu, v6, &v7);
    v3 = v7;
    if ((_DWORD)v2)
    {
      v4 = v2;
    }
    else
    {
      v4 = FigXPCRemoteClientSendSyncMessage(gFigEndpointPlaybackSessionRemoteClient, (uint64_t)v7);
      v3 = v7;
    }
  }
  FigXPCRelease(v3);
  return v4;
}

void FigEndpointPlaybackSessionRemoteXPC_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  uint64_t v4;
  const void *v5;
  const void *v6;
  NSObject *v7;
  const void *v8;
  xpc_object_t v9;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v3 = CMBaseObjectGetDerivedStorage(a1);
  v4 = v3;
  v9 = 0;
  if (!*(_BYTE *)v3)
  {
    v5 = *(const void **)(v3 + 8);
    *(_BYTE *)v3 = 1;
    FigXPCRemoteClientDisassociateObject(gFigEndpointPlaybackSessionRemoteClient, v5);
    if (!*(_BYTE *)(v4 + 1) && !FigXPCCreateBasicMessage(0x646F6F6Du, (uint64_t)v5, &v9))
      FigXPCRemoteClientSendSyncMessage(gFigEndpointPlaybackSessionRemoteClient, (uint64_t)v9);
  }
  v6 = *(const void **)(v4 + 24);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(v4 + 24) = 0;
  }
  FigXPCRelease(v9);
  v7 = *(NSObject **)(DerivedStorage + 16);
  if (v7)
    dispatch_release(v7);
  v8 = *(const void **)(DerivedStorage + 48);
  if (v8)
    CFRelease(v8);
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t ObjectID;
  uint64_t v7;
  CFTypeRef cf;
  uint64_t v10;

  cf = 0;
  v10 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v10);
  if (!(_DWORD)ObjectID)
    ObjectID = FigXPCSendStdCopyPropertyMessage(gFigEndpointPlaybackSessionRemoteClient, v10, a2, &cf);
  v7 = ObjectID;
  if (a4)
  {
    *a4 = cf;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  return v7;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t ObjectID;
  uint64_t v6;
  uint64_t v8;

  v8 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v8);
  if (!(_DWORD)ObjectID)
    ObjectID = FigXPCSendStdSetPropertyMessage(gFigEndpointPlaybackSessionRemoteClient, v8, a2, a3);
  v6 = ObjectID;
  FigXPCRemoteClientKillServerOnTimeout(gFigEndpointPlaybackSessionRemoteClient, ObjectID, "FigEndpointPlaybackSessionRemoteXPC_SetProperty", a2);
  return v6;
}

uint64_t remoteXPCEndpointPlaybackSession_GetObjectID(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)DerivedStorage)
  {
    v5 = 4294954511;
  }
  else
  {
    if (!*(_BYTE *)(DerivedStorage + 1))
    {
      *a2 = *(_QWORD *)(DerivedStorage + 8);
      return 0;
    }
    v5 = 4294950574;
  }
  return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_AuthorizeItem(uint64_t a1, const void *a2, const void *a3, void (*a4)(_QWORD, _QWORD, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t ObjectID;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v14;
  int v15[2];

  v14 = 0;
  *(_QWORD *)v15 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v14);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x61746869u, v14, v15), (_DWORD)ObjectID))
  {
    v12 = ObjectID;
    if (a4)
      a4(0, 0, ObjectID, a5);
    v11 = 0;
  }
  else
  {
    FigXPCMessageSetCFData(*(void **)v15, "PicRequest", a2);
    FigXPCMessageSetCFString(*(void **)v15, "ItemUUID", a3);
    if (a4)
    {
      v11 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v11[1] = a5;
      v11[2] = a4;
      *v11 = 1635018857;
    }
    else
    {
      v11 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v15, (uint64_t)v11);
    v12 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v15);
  free(v11);
  return v12;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_Play(uint64_t a1, const void *a2, void (*a3)(uint64_t, uint64_t), uint64_t a4)
{
  uint64_t ObjectID;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v12;
  int v13[2];

  v12 = 0;
  *(_QWORD *)v13 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v12);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x706C6179u, v12, v13), (_DWORD)ObjectID))
  {
    v10 = ObjectID;
    if (a3)
      a3(ObjectID, a4);
    v9 = 0;
  }
  else
  {
    FigXPCMessageSetCFDictionary(*(void **)v13, "Params", a2);
    remoteXPCEndpointPlaybackSession_generateSandboxTokenForFilePath(*(void **)v13, (const __CFDictionary *)a2);
    if (a3)
    {
      v9 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v9[1] = a4;
      v9[2] = a3;
      *v9 = 1886151033;
    }
    else
    {
      v9 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v13, (uint64_t)v9);
    v10 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v13);
  free(v9);
  return v10;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_InsertPlayQueueItem(uint64_t a1, const void *a2, const void *a3, void (*a4)(uint64_t, uint64_t), uint64_t a5)
{
  uint64_t ObjectID;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v14;
  int v15[2];

  v14 = 0;
  *(_QWORD *)v15 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v14);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x69707169u, v14, v15), (_DWORD)ObjectID))
  {
    v12 = ObjectID;
    if (a4)
      a4(ObjectID, a5);
    v11 = 0;
  }
  else
  {
    FigXPCMessageSetCFDictionary(*(void **)v15, "Item", a2);
    FigXPCMessageSetCFDictionary(*(void **)v15, "AfterItem", a3);
    remoteXPCEndpointPlaybackSession_generateSandboxTokenForFilePath(*(void **)v15, (const __CFDictionary *)a2);
    if (a4)
    {
      v11 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v11[1] = a5;
      v11[2] = a4;
      *v11 = 1768976745;
    }
    else
    {
      v11 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v15, (uint64_t)v11);
    v12 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v15);
  free(v11);
  return v12;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_RemovePlayQueueItem(uint64_t a1, const void *a2, void (*a3)(uint64_t, uint64_t), uint64_t a4)
{
  uint64_t ObjectID;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v12;
  int v13[2];

  v12 = 0;
  *(_QWORD *)v13 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v12);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x72707169u, v12, v13), (_DWORD)ObjectID))
  {
    v10 = ObjectID;
    if (a3)
      a3(ObjectID, a4);
    v9 = 0;
  }
  else
  {
    FigXPCMessageSetCFDictionary(*(void **)v13, "Item", a2);
    if (a3)
    {
      v9 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v9[1] = a4;
      v9[2] = a3;
      *v9 = 1919971689;
    }
    else
    {
      v9 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v13, (uint64_t)v9);
    v10 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v13);
  free(v9);
  return v10;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_Stop(uint64_t a1, void (*a2)(uint64_t, uint64_t), uint64_t a3)
{
  uint64_t ObjectID;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  void *v11;

  v10 = 0;
  v11 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v10);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x73746F70u, v10, &v11), (_DWORD)ObjectID))
  {
    v8 = ObjectID;
    if (a2)
      a2(ObjectID, a3);
    v7 = 0;
  }
  else
  {
    if (a2)
    {
      v7 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v7[1] = a3;
      v7[2] = a2;
      *v7 = 1937010544;
    }
    else
    {
      v7 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, v11, (uint64_t)v7);
    v8 = 0;
  }
  FigXPCRelease(v11);
  free(v7);
  return v8;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_GetPlaybackInfo(uint64_t a1, void (*a2)(_QWORD, uint64_t, uint64_t), uint64_t a3)
{
  uint64_t ObjectID;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  void *v11;

  v10 = 0;
  v11 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v10);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x67706C69u, v10, &v11), (_DWORD)ObjectID))
  {
    v8 = ObjectID;
    if (a2)
      a2(0, ObjectID, a3);
    v7 = 0;
  }
  else
  {
    if (a2)
    {
      v7 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v7[1] = a3;
      v7[2] = a2;
      *v7 = 1735421033;
    }
    else
    {
      v7 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, v11, (uint64_t)v7);
    v8 = 0;
  }
  FigXPCRelease(v11);
  free(v7);
  return v8;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_SeekToTime(uint64_t a1, __int128 *a2, const void *a3, void (*a4)(_QWORD, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t ObjectID;
  _QWORD *v11;
  uint64_t v12;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  int v17[2];

  v16 = 0;
  *(_QWORD *)v17 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v16);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x73657469u, v16, v17), (_DWORD)ObjectID))
  {
    v12 = ObjectID;
    if (a4)
      a4(0, ObjectID, a5);
    v11 = 0;
  }
  else
  {
    v14 = *a2;
    v15 = *((_QWORD *)a2 + 2);
    FigXPCMessageSetCMTime(*(void **)v17, "Time", &v14);
    FigXPCMessageSetCFDictionary(*(void **)v17, "Options", a3);
    if (a4)
    {
      v11 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v11[1] = a5;
      v11[2] = a4;
      *v11 = 1936028777;
    }
    else
    {
      v11 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v17, (uint64_t)v11);
    v12 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v17);
  free(v11);
  return v12;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_SeekToDate(uint64_t a1, const void *a2, const void *a3, void (*a4)(_QWORD, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t ObjectID;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v14;
  int v15[2];

  v14 = 0;
  *(_QWORD *)v15 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v14);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x73656461u, v14, v15), (_DWORD)ObjectID))
  {
    v12 = ObjectID;
    if (a4)
      a4(0, ObjectID, a5);
    v11 = 0;
  }
  else
  {
    FigXPCMessageSetCFDate(*(void **)v15, "Date", a2);
    FigXPCMessageSetCFDictionary(*(void **)v15, "Options", a3);
    if (a4)
    {
      v11 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v11[1] = a5;
      v11[2] = a4;
      *v11 = 1936024673;
    }
    else
    {
      v11 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v15, (uint64_t)v11);
    v12 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v15);
  free(v11);
  return v12;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_SetRate(uint64_t a1, const void *a2, void (*a3)(uint64_t, uint64_t), uint64_t a4, float a5)
{
  uint64_t ObjectID;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v14;
  xpc_object_t xdict;

  v14 = 0;
  xdict = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v14);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x73726174u, v14, &xdict), (_DWORD)ObjectID))
  {
    v12 = ObjectID;
    if (a3)
      a3(ObjectID, a4);
    v11 = 0;
  }
  else
  {
    xpc_dictionary_set_double(xdict, "Rate", a5);
    FigXPCMessageSetCFDictionary(xdict, "Params", a2);
    if (a3)
    {
      v11 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v11[1] = a4;
      v11[2] = a3;
      *v11 = 1936875892;
    }
    else
    {
      v11 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, xdict, (uint64_t)v11);
    v12 = 0;
  }
  FigXPCRelease(xdict);
  free(v11);
  return v12;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_GetProxiedProperty(uint64_t a1, const void *a2, const void *a3, void (*a4)(_QWORD, _QWORD, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t ObjectID;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v14;
  int v15[2];

  v14 = 0;
  *(_QWORD *)v15 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v14);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x67707072u, v14, v15), (_DWORD)ObjectID))
  {
    v12 = ObjectID;
    if (a4)
      a4(0, 0, ObjectID, a5);
    v11 = 0;
  }
  else
  {
    FigXPCMessageSetCFString(*(void **)v15, "PropertyKey", a2);
    FigXPCMessageSetCFDictionary(*(void **)v15, "Params", a3);
    if (a4)
    {
      v11 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v11[1] = a5;
      v11[2] = a4;
      *v11 = 1735422066;
    }
    else
    {
      v11 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v15, (uint64_t)v11);
    v12 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v15);
  free(v11);
  return v12;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_SetProxiedProperty(uint64_t a1, const void *a2, const void *a3, const void *a4)
{
  uint64_t ObjectID;
  uint64_t v8;
  void *v9;
  uint64_t v11;
  int v12[2];

  v11 = 0;
  *(_QWORD *)v12 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v11);
  if ((_DWORD)ObjectID)
  {
    v8 = ObjectID;
    v9 = 0;
  }
  else
  {
    v8 = FigXPCCreateBasicMessage(0x73707072u, v11, v12);
    v9 = *(void **)v12;
    if (!(_DWORD)v8)
    {
      FigXPCMessageSetCFString(*(void **)v12, "PropertyKey", a2);
      FigXPCMessageSetCFDictionary(*(void **)v12, "Params", a3);
      FigXPCMessageSetCFObject(*(void **)v12, "PropertyValue", a4);
      v8 = FigXPCRemoteClientSendSyncMessage(gFigEndpointPlaybackSessionRemoteClient, *(uint64_t *)v12);
      v9 = *(void **)v12;
    }
  }
  FigXPCRelease(v9);
  return v8;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_PerformRemoteAction(uint64_t a1, const void *a2, const void *a3, void (*a4)(uint64_t, _QWORD, uint64_t), uint64_t a5)
{
  uint64_t ObjectID;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v14;
  int v15[2];

  v14 = 0;
  *(_QWORD *)v15 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v14);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x70726561u, v14, v15), (_DWORD)ObjectID))
  {
    v12 = ObjectID;
    if (a4)
      a4(ObjectID, 0, a5);
    v11 = 0;
  }
  else
  {
    FigXPCMessageSetCFString(*(void **)v15, "Type", a2);
    FigXPCMessageSetCFObject(*(void **)v15, "Params", a3);
    if (a4)
    {
      v11 = malloc_type_malloc(0x18uLL, 0x1080040D2F62047uLL);
      v11[1] = a5;
      v11[2] = a4;
      *v11 = 1886545249;
    }
    else
    {
      v11 = 0;
    }
    FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v15, (uint64_t)v11);
    v12 = 0;
  }
  FigXPCRelease(*(xpc_object_t *)v15);
  free(v11);
  return v12;
}

uint64_t FigEndpointPlaybackSessionRemoteXPC_SetEventHandler(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t ObjectID;
  unsigned int v9;
  uint64_t DerivedStorage;
  NSObject *v11;
  uint64_t v12;
  _QWORD v14[8];
  uint64_t v15;
  xpc_object_t v16;

  v16 = 0;
  v15 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v15);
  if (!(_DWORD)ObjectID)
  {
    if (a2)
      v9 = 1936029288;
    else
      v9 = 1667593832;
    ObjectID = FigXPCCreateBasicMessage(v9, v15, &v16);
    if (!(_DWORD)ObjectID)
    {
      DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
      v11 = *(NSObject **)(DerivedStorage + 16);
      v14[0] = MEMORY[0x1E0C809B0];
      v14[1] = 0x40000000;
      v14[2] = __FigEndpointPlaybackSessionRemoteXPC_SetEventHandler_block_invoke;
      v14[3] = &__block_descriptor_tmp_10_9;
      v14[4] = DerivedStorage;
      v14[5] = a2;
      v14[6] = a3;
      v14[7] = a4;
      dispatch_sync(v11, v14);
      ObjectID = FigXPCRemoteClientSendSyncMessage(gFigEndpointPlaybackSessionRemoteClient, (uint64_t)v16);
    }
  }
  v12 = ObjectID;
  FigXPCRelease(v16);
  return v12;
}

void FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  unsigned int v14;
  _QWORD v15[7];
  _QWORD block[8];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v7 = DerivedStorage;
  v21 = 0;
  v22 = &v21;
  v23 = 0x2000000000;
  v24 = 0;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 0;
  v8 = MEMORY[0x1E0C809B0];
  if (a3)
  {
    v9 = *(NSObject **)(DerivedStorage + 16);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback_block_invoke;
    block[3] = &unk_1E28E4AA8;
    block[4] = &v21;
    block[5] = a1;
    block[6] = v7;
    block[7] = a3;
    dispatch_sync(v9, block);
    xpc_dictionary_set_uint64(a2, "CompletionID", v22[3]);
  }
  v10 = FigXPCRemoteClientSendSyncMessage(gFigEndpointPlaybackSessionRemoteClient, (uint64_t)a2);
  v11 = v10;
  if (a3)
  {
    if ((_DWORD)v10)
    {
      v12 = *(NSObject **)(v7 + 16);
      v15[0] = v8;
      v15[1] = 0x40000000;
      v15[2] = __FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback_block_invoke_2;
      v15[3] = &unk_1E28E4AD0;
      v15[4] = &v21;
      v15[5] = &v17;
      v15[6] = v7;
      dispatch_sync(v12, v15);
      if (*((_BYTE *)v18 + 24))
      {
        v14 = v11;
        FigEndpointPlaybackSessionRemoteXPC_runOneCallback(v13, a3, &v14);
      }
    }
  }
  FigXPCRemoteClientKillServerOnTimeout(gFigEndpointPlaybackSessionRemoteClient, v11, "FigEndpointPlaybackSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback", 0);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
}

void remoteXPCEndpointPlaybackSession_generateSandboxTokenForFilePath(void *a1, const __CFDictionary *a2)
{
  const __CFString *Value;
  int v5;
  int v6;
  int v7;
  const char *v8;
  char *v9;
  char v10[1024];
  char buffer[1024];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  bzero(buffer, 0x400uLL);
  bzero(v10, 0x400uLL);
  Value = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("movPkgPath"));
  if (Value || (Value = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("path"))) != 0)
  {
    if (CFStringGetCString(Value, buffer, 1024, 0x8000100u))
    {
      if ((v5 = open(buffer, 0), v5 != -1) && (v6 = v5, v7 = fcntl(v5, 50, v10), close(v6), v7 != -1)
        || realpath_DARWIN_EXTSN(buffer, v10)
        || !*__error())
      {
        v8 = (const char *)sandbox_extension_issue_file();
        if (v8)
        {
          v9 = (char *)v8;
          xpc_dictionary_set_string(a1, "SExtToken", v8);
          free(v9);
        }
      }
    }
  }
}

void *FigHALPluginDriverGetInterface()
{
  return &gAudioServerPlugInDriverInterface;
}

uint64_t figHALDriver_QueryInterface(uint64_t a1, CFUUIDBytes a2, _QWORD *a3)
{
  CFUUIDRef v5;
  CFUUIDRef v6;
  CFUUIDRef v7;
  CFUUIDRef v8;
  uint64_t v9;
  uint64_t v11;

  if (!a3)
  {
    v11 = 1852797029;
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  v5 = CFUUIDCreateFromUUIDBytes(0, a2);
  if (!v5)
  {
    v11 = 4294950406;
    return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
  }
  v6 = v5;
  v7 = CFUUIDGetConstantUUIDWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE30], 0, 0, 0, 0, 0, 0, 0, 0, 0xC0u, 0, 0, 0, 0, 0, 0, 0x46u);
  if (CFEqual(v6, v7)
    || (v8 = CFUUIDGetConstantUUIDWithBytes(0, 0xEEu, 0xA5u, 0x77u, 0x3Du, 0xCCu, 0x43u, 0x49u, 0xF1u, 0x8Eu, 0, 0x8Fu, 0x96u, 0xE7u, 0xD2u, 0x3Bu, 0x17u), CFEqual(v6, v8)))
  {
    FigAtomicIncrement32((unsigned int *)(a1 + 8));
    v9 = 0;
    *a3 = a1;
  }
  else
  {
    v9 = 2147483652;
  }
  CFRelease(v6);
  return v9;
}

uint64_t figHALDriver_AddRef(uint64_t a1)
{
  return FigAtomicIncrement32((unsigned int *)(a1 + 8));
}

uint64_t figHALDriver_Release(uint64_t a1)
{
  return FigAtomicDecrement32((unsigned int *)(a1 + 8));
}

uint64_t figHALDriver_Initialize(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t (*v4)(uint64_t, uint64_t);

  v3 = *(_QWORD *)(a1 + 20);
  v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v3) + 24) + 8);
  if (v4)
    return v4(v3, a2);
  else
    return 4294954514;
}

uint64_t figHALDriver_CreateDevice()
{
  return 1970171760;
}

uint64_t figHALDriver_DestroyDevice()
{
  return 1970171760;
}

uint64_t figHALDriver_AddDeviceClient()
{
  return 0;
}

uint64_t figHALDriver_RemoveDeviceClient()
{
  return 0;
}

uint64_t figHALDriver_PerformDeviceConfigurationChange(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  CFTypeRef v7;
  uint64_t (*v8)(CFTypeRef, uint64_t, uint64_t);
  uint64_t v9;
  CFTypeRef cf;

  cf = 0;
  v6 = driver_CopyDeviceForID(a1, a2, &cf);
  v7 = cf;
  if (!(_DWORD)v6)
  {
    v8 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)cf) + 24)
                                                               + 16);
    if (!v8)
    {
      v9 = 4294954514;
      if (!v7)
        return v9;
      goto LABEL_5;
    }
    v6 = v8(v7, a3, a4);
  }
  v9 = v6;
  if (v7)
LABEL_5:
    CFRelease(v7);
  return v9;
}

uint64_t figHALDriver_AbortDeviceConfigurationChange(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  CFTypeRef v7;
  uint64_t (*v8)(CFTypeRef, uint64_t, uint64_t);
  uint64_t v9;
  CFTypeRef cf;

  cf = 0;
  v6 = driver_CopyDeviceForID(a1, a2, &cf);
  v7 = cf;
  if (!(_DWORD)v6)
  {
    v8 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)cf) + 24)
                                                               + 24);
    if (!v8)
    {
      v9 = 4294954514;
      if (!v7)
        return v9;
      goto LABEL_5;
    }
    v6 = v8(v7, a3, a4);
  }
  v9 = v6;
  if (v7)
LABEL_5:
    CFRelease(v7);
  return v9;
}

uint64_t figHALDriver_HasProperty(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  int v5;
  const void *v6;
  uint64_t (*v7)(const void *, uint64_t);
  uint64_t v8;
  const void *v10;

  v10 = 0;
  v5 = driver_CopyObjectForID(a1, a2, &v10);
  v6 = v10;
  if (v5
    || (v7 = *(uint64_t (**)(const void *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16)
                                                             + 16)) == 0)
  {
    v8 = 0;
    if (!v6)
      return v8;
    goto LABEL_4;
  }
  v8 = v7(v6, a4);
  if (v6)
LABEL_4:
    CFRelease(v6);
  return v8;
}

uint64_t figHALDriver_IsPropertySettable(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t v7;
  const void *v8;
  uint64_t v9;
  unsigned int (*v10)(const void *, uint64_t);
  uint64_t (*v11)(const void *, uint64_t);
  char v12;
  const void *v14;

  v14 = 0;
  v7 = driver_CopyObjectForID(a1, a2, &v14);
  v8 = v14;
  if ((_DWORD)v7)
  {
    v9 = v7;
    if (!v14)
      return v9;
    goto LABEL_9;
  }
  v9 = 2003332927;
  v10 = *(unsigned int (**)(const void *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v14) + 16)
                                                             + 16);
  if (v10 && v10(v8, a4))
  {
    v11 = *(uint64_t (**)(const void *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v8) + 16) + 24);
    if (v11)
      v12 = v11(v8, a4);
    else
      v12 = 0;
    v9 = 0;
    *a5 = v12;
  }
  if (v8)
LABEL_9:
    CFRelease(v8);
  return v9;
}

uint64_t figHALDriver_GetPropertyDataSize(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7)
{
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  unsigned int (*v14)(const void *, uint64_t);
  uint64_t (*v15)(const void *, uint64_t, uint64_t, uint64_t);
  int v16;
  const void *v18;

  v18 = 0;
  v11 = driver_CopyObjectForID(a1, a2, &v18);
  v12 = v18;
  if ((_DWORD)v11)
  {
    v13 = v11;
    if (!v18)
      return v13;
    goto LABEL_9;
  }
  v13 = 2003332927;
  v14 = *(unsigned int (**)(const void *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v18) + 16)
                                                             + 16);
  if (v14 && v14(v12, a4))
  {
    v15 = *(uint64_t (**)(const void *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v12)
                                                                                        + 16)
                                                                            + 32);
    if (v15)
      v16 = v15(v12, a4, a5, a6);
    else
      v16 = 0;
    v13 = 0;
    *a7 = v16;
  }
  if (v12)
LABEL_9:
    CFRelease(v12);
  return v13;
}

uint64_t figHALDriver_GetPropertyData(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v14;
  const void *v15;
  uint64_t v16;
  unsigned int (*v17)(const void *, uint64_t);
  uint64_t (*v18)(const void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  const void *v20;

  v20 = 0;
  v14 = driver_CopyObjectForID(a1, a2, &v20);
  v15 = v20;
  if ((_DWORD)v14)
  {
LABEL_6:
    v16 = v14;
    goto LABEL_7;
  }
  v16 = 2003332927;
  v17 = *(unsigned int (**)(const void *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v20) + 16)
                                                             + 16);
  if (v17 && v17(v15, a4))
  {
    v18 = *(uint64_t (**)(const void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v15) + 16) + 40);
    if (!v18)
    {
      v16 = 4294954514;
      if (!v15)
        return v16;
      goto LABEL_8;
    }
    v14 = v18(v15, a4, a5, a6, a7, a8, a9);
    goto LABEL_6;
  }
LABEL_7:
  if (v15)
LABEL_8:
    CFRelease(v15);
  return v16;
}

uint64_t figHALDriver_SetPropertyData(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  unsigned int (*v16)(const void *, uint64_t);
  uint64_t (*v17)(const void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  const void *v19;

  v19 = 0;
  v13 = driver_CopyObjectForID(a1, a2, &v19);
  v14 = v19;
  if ((_DWORD)v13)
  {
LABEL_6:
    v15 = v13;
    goto LABEL_7;
  }
  v15 = 2003332927;
  v16 = *(unsigned int (**)(const void *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v19) + 16)
                                                             + 16);
  if (v16 && v16(v14, a4))
  {
    v17 = *(uint64_t (**)(const void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v14) + 16)
                                                                                              + 48);
    if (!v17)
    {
      v15 = 4294954514;
      if (!v14)
        return v15;
      goto LABEL_8;
    }
    v13 = v17(v14, a4, a5, a6, a7, a8);
    goto LABEL_6;
  }
LABEL_7:
  if (v14)
LABEL_8:
    CFRelease(v14);
  return v15;
}

uint64_t figHALDriver_StartIO(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  CFTypeRef v3;
  uint64_t (*v4)(CFTypeRef);
  uint64_t v5;
  CFTypeRef cf;

  cf = 0;
  v2 = driver_CopyDeviceForID(a1, a2, &cf);
  v3 = cf;
  if (!(_DWORD)v2)
  {
    v4 = *(uint64_t (**)(CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)cf) + 24) + 32);
    if (!v4)
    {
      v5 = 4294954514;
      if (!v3)
        return v5;
      goto LABEL_5;
    }
    v2 = v4(v3);
  }
  v5 = v2;
  if (v3)
LABEL_5:
    CFRelease(v3);
  return v5;
}

uint64_t figHALDriver_StopIO(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  CFTypeRef v3;
  uint64_t (*v4)(CFTypeRef);
  uint64_t v5;
  CFTypeRef cf;

  cf = 0;
  v2 = driver_CopyDeviceForID(a1, a2, &cf);
  v3 = cf;
  if (!(_DWORD)v2)
  {
    v4 = *(uint64_t (**)(CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)cf) + 24) + 40);
    if (!v4)
    {
      v5 = 4294954514;
      if (!v3)
        return v5;
      goto LABEL_5;
    }
    v2 = v4(v3);
  }
  v5 = v2;
  if (v3)
LABEL_5:
    CFRelease(v3);
  return v5;
}

uint64_t figHALDriver_GetZeroTimeStamp(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  CFTypeRef v10;
  uint64_t (*v11)(CFTypeRef, uint64_t, uint64_t, uint64_t);
  uint64_t v12;
  CFTypeRef cf;

  cf = 0;
  v9 = driver_CopyDeviceForID(a1, a2, &cf);
  v10 = cf;
  if (!(_DWORD)v9)
  {
    v11 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)cf)
                                                                                     + 24)
                                                                         + 48);
    if (!v11)
    {
      v12 = 4294954514;
      if (!v10)
        return v12;
      goto LABEL_5;
    }
    v9 = v11(v10, a4, a5, a6);
  }
  v12 = v9;
  if (v10)
LABEL_5:
    CFRelease(v10);
  return v12;
}

uint64_t figHALDriver_WillDoIOOperation(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  CFTypeRef v10;
  uint64_t (*v11)(CFTypeRef, uint64_t, uint64_t, uint64_t);
  uint64_t v12;
  CFTypeRef cf;

  cf = 0;
  v9 = driver_CopyDeviceForID(a1, a2, &cf);
  v10 = cf;
  if (!(_DWORD)v9)
  {
    v11 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)cf)
                                                                                     + 24)
                                                                         + 56);
    if (!v11)
    {
      v12 = 4294954514;
      if (!v10)
        return v12;
      goto LABEL_5;
    }
    v9 = v11(v10, a4, a5, a6);
  }
  v12 = v9;
  if (v10)
LABEL_5:
    CFRelease(v10);
  return v12;
}

uint64_t figHALDriver_BeginIOOperation(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  CFTypeRef v10;
  uint64_t (*v11)(CFTypeRef, uint64_t, uint64_t, uint64_t);
  uint64_t v12;
  CFTypeRef cf;

  cf = 0;
  v9 = driver_CopyDeviceForID(a1, a2, &cf);
  v10 = cf;
  if (!(_DWORD)v9)
  {
    v11 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)cf)
                                                                                     + 24)
                                                                         + 64);
    if (!v11)
    {
      v12 = 4294954514;
      if (!v10)
        return v12;
      goto LABEL_5;
    }
    v9 = v11(v10, a4, a5, a6);
  }
  v12 = v9;
  if (v10)
LABEL_5:
    CFRelease(v10);
  return v12;
}

uint64_t figHALDriver_DoIOOperation(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  unsigned int v13;
  uint64_t v14;
  uint64_t ClassID;
  CFTypeRef v16;
  uint64_t (*v17)(CFTypeRef, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  CFTypeRef cf;

  cf = 0;
  v13 = driver_CopyObjectForID(a1, a3, &cf);
  if (v13 == 560947818)
    v14 = 561214578;
  else
    v14 = v13;
  if ((_DWORD)v14)
  {
    v16 = cf;
  }
  else
  {
    ClassID = FigHALAudioStreamGetClassID();
    v16 = cf;
    if (ClassID == CMBaseObjectGetClassID((uint64_t)cf))
      goto LABEL_6;
    v14 = FigSignalErrorAt(561214578, 0, 0, 0, 0, 0, 0);
  }
  if (v16)
    CFRelease(v16);
  if ((_DWORD)v14)
    return v14;
  v16 = 0;
LABEL_6:
  v17 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v16) + 32)
                                                                                         + 8);
  if (v17)
  {
    v14 = v17(v16, a5, a6, a7, a8, a9);
    if (!v16)
      return v14;
    goto LABEL_10;
  }
  v14 = 4294954514;
  if (v16)
LABEL_10:
    CFRelease(v16);
  return v14;
}

uint64_t figHALDriver_EndIOOperation(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  CFTypeRef v10;
  uint64_t (*v11)(CFTypeRef, uint64_t, uint64_t, uint64_t);
  uint64_t v12;
  CFTypeRef cf;

  cf = 0;
  v9 = driver_CopyDeviceForID(a1, a2, &cf);
  v10 = cf;
  if (!(_DWORD)v9)
  {
    v11 = *(uint64_t (**)(CFTypeRef, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)cf)
                                                                                     + 24)
                                                                         + 72);
    if (!v11)
    {
      v12 = 4294954514;
      if (!v10)
        return v12;
      goto LABEL_5;
    }
    v9 = v11(v10, a4, a5, a6);
  }
  v12 = v9;
  if (v10)
LABEL_5:
    CFRelease(v10);
  return v12;
}

uint64_t driver_CopyDeviceForID(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t ClassID;
  CFTypeRef v7;
  CFTypeRef cf;

  cf = 0;
  v4 = driver_CopyObjectForID(a1, a2, &cf);
  if (v4 == 560947818)
    v5 = 560227702;
  else
    v5 = v4;
  if ((_DWORD)v5)
  {
    v7 = cf;
  }
  else
  {
    ClassID = FigHALAudioDeviceGetClassID();
    v7 = cf;
    if (ClassID == CMBaseObjectGetClassID((uint64_t)cf))
    {
      v5 = 0;
      *a3 = v7;
      return v5;
    }
    v5 = FigSignalErrorAt(560227702, 0, 0, 0, 0, 0, 0);
  }
  if (v7)
    CFRelease(v7);
  return v5;
}

uint64_t driver_CopyObjectForID(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  id v4;
  id v5;
  uint64_t result;

  if (!a2)
    return FigSignalErrorAt(4294950405, 0, 0, 0, 0, 0, 0);
  v4 = FigHALAudioObjectMapperCopyObjectForID(*(uint64_t **)(a1 + 12), a2);
  if (!v4)
    return 560947818;
  v5 = v4;
  result = 0;
  *a3 = v5;
  return result;
}

CFArrayRef FigCopyProcessNamesForGatheringDiagnosticsWithCoreMediaDiagnosticExtension()
{
  _OWORD v1[3];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1[0] = xmmword_1E28E4B18;
  v1[1] = *(_OWORD *)&off_1E28E4B28;
  v1[2] = xmmword_1E28E4B38;
  return CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)v1, 6, MEMORY[0x1E0C9B378]);
}

uint64_t FigEndpointStreamAudioFormatDescriptionGetTypeID()
{
  if (FigEndpointStreamAudioFormatDescriptionGetTypeID_sOnce != -1)
    dispatch_once_f(&FigEndpointStreamAudioFormatDescriptionGetTypeID_sOnce, &FigEndpointStreamAudioFormatDescriptionGetTypeID_sTypeID, (dispatch_function_t)_FigEndpointStreamAudioFormatDescriptionRegisterClass);
  return FigEndpointStreamAudioFormatDescriptionGetTypeID_sTypeID;
}

uint64_t _FigEndpointStreamAudioFormatDescriptionRegisterClass(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

uint64_t FigEndpointStreamAudioFormatDescriptionCreate(uint64_t a1, __int128 *a2, int a3, uint64_t *a4)
{
  uint64_t Instance;
  __int128 v8;
  __int128 v9;
  uint64_t v11;

  if (a2)
  {
    if (a4)
    {
      if (FigEndpointStreamAudioFormatDescriptionGetTypeID_sOnce != -1)
        dispatch_once_f(&FigEndpointStreamAudioFormatDescriptionGetTypeID_sOnce, &FigEndpointStreamAudioFormatDescriptionGetTypeID_sTypeID, (dispatch_function_t)_FigEndpointStreamAudioFormatDescriptionRegisterClass);
      Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        v8 = *a2;
        v9 = a2[1];
        *(_QWORD *)(Instance + 48) = *((_QWORD *)a2 + 4);
        *(_OWORD *)(Instance + 16) = v8;
        *(_OWORD *)(Instance + 32) = v9;
        *(_DWORD *)(Instance + 56) = a3;
        *a4 = Instance;
        return 0;
      }
      v11 = 4294954510;
    }
    else
    {
      v11 = 4294954516;
    }
  }
  else
  {
    v11 = 4294954516;
  }
  return FigSignalErrorAt(v11, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointStreamAudioFormatDescriptionGetASBD(uint64_t a1)
{
  if (a1)
    return a1 + 16;
  else
    return 0;
}

uint64_t FigEndpointStreamAudioFormatDescriptionGetChannelLayoutTag(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 56);
  else
    return 4294901760;
}

uint64_t FigEndpointStreamAudioFormatDescriptionCreateWithCMFormatDescription(uint64_t a1, CMFormatDescriptionRef desc, uint64_t *a3)
{
  const AudioChannelLayout *ChannelLayout;
  int v7;
  int v9;
  int v10;
  size_t sizeOut;
  const AudioChannelLayout *v12;
  AudioFormatListItem *StreamBasicDescription;

  v12 = 0;
  StreamBasicDescription = 0;
  sizeOut = 0;
  v10 = -65536;
  v9 = 4;
  if (!desc || CMFormatDescriptionGetMediaType(desc) != 1936684398 || !a3)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  CMAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout(desc, (const AudioFormatListItem **)&StreamBasicDescription, &sizeOut, &v12);
  if (StreamBasicDescription)
  {
    ChannelLayout = v12;
  }
  else
  {
    StreamBasicDescription = (AudioFormatListItem *)CMAudioFormatDescriptionGetStreamBasicDescription(desc);
    ChannelLayout = CMAudioFormatDescriptionGetChannelLayout(desc, &sizeOut);
    v12 = ChannelLayout;
  }
  if (AudioToolbox_AudioFormatGetProperty(1668116596, sizeOut, (uint64_t)ChannelLayout, (uint64_t)&v9, (uint64_t)&v10))
  {
    v7 = -65536;
    v10 = -65536;
  }
  else
  {
    v7 = v10;
  }
  return FigEndpointStreamAudioFormatDescriptionCreate(a1, (__int128 *)StreamBasicDescription, v7, a3);
}

BOOL _FigEndpointStreamAudioFormatDescriptionIsEqual(uint64_t a1, uint64_t a2)
{
  return !memcmp((const void *)(a1 + 16), (const void *)(a2 + 16), 0x24uLL)
      && *(_DWORD *)(a1 + 56) == *(_DWORD *)(a2 + 56);
}

CFStringRef _FigEndpointStreamAudioFormatDescriptionCopyDebugDesc(uint64_t a1)
{
  unsigned int v1;

  v1 = *(_DWORD *)(a1 + 24);
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<FigEndpointStreamAudioFormatDescription %p> {\n\tmSampleRate: %f\n\tmFormatID: '%c%c%c%c'\n\tmFormatFlags: 0x%x\n\tmBytesPerPacket: %u\n\tmFramesPerPacket: %u\n\tmBytesPerFrame: %u\n\tmChannelsPerFrame: %u\n\tmBitsPerChannel: %u\n\tmChannelLayoutTag: 0x%08x\n}"), a1, *(_QWORD *)(a1 + 16), HIBYTE(v1), BYTE2(v1), BYTE1(v1), v1, *(unsigned int *)(a1 + 28), *(unsigned int *)(a1 + 32), *(unsigned int *)(a1 + 36), *(unsigned int *)(a1 + 40), *(unsigned int *)(a1 + 44), *(unsigned int *)(a1 + 48), *(unsigned int *)(a1 + 56));
}

uint64_t FigEndpointRemoteControlSessionXPCRemotePing()
{
  uint64_t v0;
  uint64_t v1;
  void *v2;
  uint64_t v3;
  void *v5;

  v5 = 0;
  v0 = remoteXPCEndpointRemoteControlSessionClient_EnsureClientEstablished();
  if ((_DWORD)v0)
  {
    v3 = v0;
    v2 = 0;
  }
  else
  {
    v1 = FigXPCCreateBasicMessage(0x2E706E67u, 0, &v5);
    v2 = v5;
    if ((_DWORD)v1)
    {
      v3 = v1;
    }
    else
    {
      v3 = FigXPCRemoteClientSendSyncMessage(gFigEndpointRemoteControlSessionRemoteClient, (uint64_t)v5);
      v2 = v5;
    }
  }
  FigXPCRelease(v2);
  return v3;
}

uint64_t remoteXPCEndpointRemoteControlSessionClient_EnsureClientEstablished()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __remoteXPCEndpointRemoteControlSessionClient_EnsureClientEstablished_block_invoke;
  block[3] = &unk_1E28E4BF8;
  block[4] = &v3;
  if (remoteXPCEndpointRemoteControlSessionClient_EnsureClientEstablished_sFigEndpointRemoteControlSessionRemoteClientSetupOnce != -1)
    dispatch_once(&remoteXPCEndpointRemoteControlSessionClient_EnsureClientEstablished_sFigEndpointRemoteControlSessionRemoteClientSetupOnce, block);
  v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t FigEndpointRemoteControlSessionXPCRemoteCreateWithObjectID(const void *a1, _QWORD *a2)
{
  uint64_t result;

  if (!a1 || !a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  result = remoteXPCEndpointRemoteControlSessionClient_EnsureClientEstablished();
  if (!(_DWORD)result)
    return remoteXPCEndpointRemoteControlSession_CreateInternal(a1, a2);
  return result;
}

uint64_t remoteXPCEndpointRemoteControlSession_CreateInternal(const void *a1, _QWORD *a2)
{
  const __CFAllocator *v4;
  _QWORD *ClassID;
  uint64_t result;
  _QWORD *DerivedStorage;
  CFMutableDictionaryRef v8;
  dispatch_queue_t v9;
  CFDictionaryValueCallBacks v10;
  uint64_t v11;

  v11 = 0;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  ClassID = (_QWORD *)FigEndpointRemoteControlSessionGetClassID();
  result = CMDerivedObjectCreate((uint64_t)v4, (uint64_t)&kFigEndpointRemoteControlSessionRemoteXPC_EndpointRemoteControlSessionVTable, ClassID, &v11);
  if (!(_DWORD)result)
  {
    DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(v11);
    DerivedStorage[1] = a1;
    DerivedStorage[6] = 1;
    v10.version = 0;
    v10.retain = (CFDictionaryRetainCallBack)remoteXPCEndpointRemoteControlSession_cloneCompletionCallback;
    v10.release = (CFDictionaryReleaseCallBack)remoteXPCEndpointRemoteControlSession_freeCompletionCallback;
    v10.copyDescription = 0;
    v10.equal = 0;
    v8 = CFDictionaryCreateMutable(v4, 0, 0, &v10);
    DerivedStorage[3] = v8;
    if (v8
      && (v9 = dispatch_queue_create("com.apple.coremedia.endpointremotecontrolsession.callbacks", 0),
          (DerivedStorage[2] = v9) != 0))
    {
      FigXPCRemoteClientAssociateObject(gFigEndpointRemoteControlSessionRemoteClient, v11, a1);
      result = 0;
    }
    else
    {
      result = FigSignalErrorAt(4294949865, 0, 0, 0, 0, 0, 0);
    }
  }
  *a2 = v11;
  return result;
}

void remoteXPCEndpointRemoteControlSessionClient_DeadConnectionCallback(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *v3;
  uint64_t v4;
  const __CFDictionary *v5;
  const void *v6;
  uint64_t v7;
  NSObject *v8;
  void (*v9)(uint64_t, const __CFString *, _QWORD);
  uint64_t *v10;
  const void *v11;
  uint64_t block;
  uint64_t v13;
  void *v14;
  void *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t context;
  uint64_t *p_context;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;

  *(_BYTE *)(CMBaseObjectGetDerivedStorage(a1) + 1) = 1;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = 0;
  LODWORD(context) = -16722;
  v3 = *(NSObject **)(DerivedStorage + 16);
  v4 = MEMORY[0x1E0C809B0];
  block = MEMORY[0x1E0C809B0];
  v13 = 0x40000000;
  v14 = __FigEndpointRemoteControlSessionRemoteXPC_runAllCallbacks_block_invoke;
  v15 = &unk_1E28E4C20;
  v16 = &v23;
  v17 = (uint64_t *)DerivedStorage;
  dispatch_sync(v3, &block);
  v5 = (const __CFDictionary *)v24[3];
  if (v5)
  {
    CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)FigEndpointRemoteControlSessionRemoteXPC_runOneCallback, &context);
    v6 = (const void *)v24[3];
    if (v6)
      CFRelease(v6);
  }
  _Block_object_dispose(&v23, 8);
  v7 = CMBaseObjectGetDerivedStorage(a1);
  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = 0;
  context = 0;
  p_context = &context;
  v21 = 0x2000000000;
  v22 = 0;
  v8 = *(NSObject **)(v7 + 16);
  block = v4;
  v13 = 0x40000000;
  v14 = __FigEndpointRemoteControlSessionRemoteXPC_postInvalidated_block_invoke;
  v15 = &unk_1E28E4C48;
  v17 = &v23;
  v18 = v7;
  v16 = &context;
  dispatch_sync(v8, &block);
  v9 = (void (*)(uint64_t, const __CFString *, _QWORD))v24[3];
  v10 = p_context;
  if (v9 && p_context[3])
  {
    v9(a1, CFSTR("Invalidated"), 0);
    v10 = p_context;
  }
  v11 = (const void *)v10[3];
  if (v11)
    CFRelease(v11);
  _Block_object_dispose(&context, 8);
  _Block_object_dispose(&v23, 8);
}

uint64_t remoteXPCEndpointRemoteControlSessionClient_HandleClientMessage(uint64_t a1, void *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t uint64;
  NSObject *v7;
  int64_t int64;
  uint64_t DerivedStorage;
  NSObject *v10;
  const void *v11;
  int v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t block;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t *v23;
  __CFDictionary **v24;
  uint64_t v25;
  __CFDictionary *v26;
  __CFDictionary **v27;
  uint64_t v28;
  uint64_t v29;
  CFTypeRef v30;
  CFTypeRef v31;

  v12 = 0;
  result = FigXPCMessageGetOpCode(a2, &v12);
  if (!(_DWORD)result)
  {
    if (v12 == 1701340002)
    {
      DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
      v30 = 0;
      v31 = 0;
      v13 = 0;
      v14 = &v13;
      v15 = 0x2000000000;
      v16 = 0;
      v26 = 0;
      v27 = &v26;
      v28 = 0x2000000000;
      v29 = 0;
      v10 = *(NSObject **)(DerivedStorage + 16);
      block = MEMORY[0x1E0C809B0];
      v20 = 0x40000000;
      v21 = __remoteXPCEndpointRemoteControlSessionClient_eventHandlerCallback_block_invoke;
      v22 = &unk_1E28E4C98;
      v24 = &v26;
      v25 = DerivedStorage;
      v23 = &v13;
      dispatch_sync(v10, &block);
      if (v27[3])
      {
        FigXPCMessageCopyCFString(a2, "EventType", &v31);
        FigXPCMessageCopyCFData(a2, "EventPayload", &v30);
        if (v14[3])
          ((void (*)(uint64_t, CFTypeRef, CFTypeRef))v27[3])(a1, v31, v30);
      }
      v11 = (const void *)v14[3];
      if (v11)
        CFRelease(v11);
      if (v31)
        CFRelease(v31);
      if (v30)
        CFRelease(v30);
      _Block_object_dispose(&v26, 8);
      goto LABEL_17;
    }
    if (v12 == 1667329122)
    {
      v13 = 0;
      v14 = &v13;
      v15 = 0x3000000000;
      v17 = 0;
      v18 = 0;
      v16 = 0;
      v5 = CMBaseObjectGetDerivedStorage(a1);
      uint64 = xpc_dictionary_get_uint64(a2, "CompletionID");
      v7 = *(NSObject **)(v5 + 16);
      block = MEMORY[0x1E0C809B0];
      v20 = 0x40000000;
      v21 = __remoteXPCEndpointRemoteControlSessionClient_handleCompletionCallback_block_invoke;
      v22 = &unk_1E28E4C70;
      v24 = (__CFDictionary **)v5;
      v25 = uint64;
      v23 = &v13;
      dispatch_sync(v7, &block);
      if (v14[3] == 1936614509)
      {
        v26 = 0;
        int64 = xpc_dictionary_get_int64(a2, "ResponseStatus");
        FigXPCMessageCopyCFObject(a2, "ResponseParams", &v26);
        ((void (*)(int64_t, __CFDictionary *, uint64_t))v14[5])(int64, v26, v14[4]);
        if (v26)
          CFRelease(v26);
      }
LABEL_17:
      _Block_object_dispose(&v13, 8);
      return 0;
    }
    return 4294951138;
  }
  return result;
}

uint64_t FigEndpointRemoteControlSessionRemoteXPC_runOneCallback(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t result;

  if (*(_QWORD *)a2 == 1936614509)
    return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a2 + 16))(*a3, 0, *(_QWORD *)(a2 + 8));
  return result;
}

void __remoteXPCEndpointRemoteControlSessionClient_handleCompletionCallback_block_invoke(uint64_t a1)
{
  const __CFDictionary *v2;
  _QWORD *Value;
  uint64_t v4;
  __int128 v5;

  v2 = *(const __CFDictionary **)(*(_QWORD *)(a1 + 40) + 24);
  if (v2)
  {
    Value = CFDictionaryGetValue(v2, *(const void **)(a1 + 48));
    if (Value)
    {
      v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v5 = *(_OWORD *)Value;
      *(_QWORD *)(v4 + 40) = Value[2];
      *(_OWORD *)(v4 + 24) = v5;
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 40) + 24), *(const void **)(a1 + 48));
  }
}

_QWORD *__remoteXPCEndpointRemoteControlSessionClient_eventHandlerCallback_block_invoke(_QWORD *result)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = result[6];
  if (*(_QWORD *)(v1 + 32))
  {
    v2 = result;
    result = FigCFWeakReferenceLoadAndRetain((id *)(v1 + 40));
    *(_QWORD *)(*(_QWORD *)(v2[4] + 8) + 24) = result;
    *(_QWORD *)(*(_QWORD *)(v2[5] + 8) + 24) = *(_QWORD *)(v2[6] + 32);
  }
  return result;
}

__n128 remoteXPCEndpointRemoteControlSession_cloneCompletionCallback(const __CFAllocator *a1, __n128 *a2)
{
  __n128 *v3;
  unint64_t v4;
  __n128 result;

  v3 = (__n128 *)CFAllocatorAllocate(a1, 24, 0);
  v4 = a2[1].n128_u64[0];
  result = *a2;
  *v3 = *a2;
  v3[1].n128_u64[0] = v4;
  return result;
}

void FigEndpointRemoteControlSessionRemoteXPC_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  uint64_t v4;
  const void *v5;
  const void *v6;
  NSObject *v7;
  xpc_object_t v8;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v3 = CMBaseObjectGetDerivedStorage(a1);
  v4 = v3;
  v8 = 0;
  if (!*(_BYTE *)v3)
  {
    v5 = *(const void **)(v3 + 8);
    *(_BYTE *)v3 = 1;
    FigXPCRemoteClientDisassociateObject(gFigEndpointRemoteControlSessionRemoteClient, v5);
    if (!*(_BYTE *)(v4 + 1) && !FigXPCCreateBasicMessage(0x646F6F6Du, (uint64_t)v5, &v8))
      FigXPCRemoteClientSendSyncMessage(gFigEndpointRemoteControlSessionRemoteClient, (uint64_t)v8);
  }
  v6 = *(const void **)(v4 + 24);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(v4 + 24) = 0;
  }
  FigXPCRelease(v8);
  v7 = *(NSObject **)(DerivedStorage + 16);
  if (v7)
    dispatch_release(v7);
}

uint64_t FigEndpointRemoteControlSessionRemoteXPC_SendMessage(uint64_t a1, const void *a2, void (*a3)(uint64_t, _QWORD, uint64_t), uint64_t a4)
{
  void *v8;
  uint64_t DerivedStorage;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(uint64_t, _QWORD, uint64_t);
  uint64_t v18;
  int v19[2];
  _QWORD v20[7];
  _QWORD block[8];
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;

  v18 = 0;
  *(_QWORD *)v19 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  if (a2
    && !remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v18)
    && !FigXPCCreateBasicMessage(0x736E646Du, v18, v19))
  {
    FigXPCMessageSetCFData(*(void **)v19, "Params", a2);
  }
  if (a3)
  {
    v16 = a4;
    v17 = a3;
    v15 = 1936614509;
  }
  v8 = *(void **)v19;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v26 = 0;
  v27 = &v26;
  v28 = 0x2000000000;
  v29 = 0;
  v22 = 0;
  v23 = &v22;
  v24 = 0x2000000000;
  v25 = 0;
  v10 = *(NSObject **)(DerivedStorage + 16);
  v11 = MEMORY[0x1E0C809B0];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigEndpointRemoteControlSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback_block_invoke;
  block[3] = &unk_1E28E4D60;
  block[4] = &v26;
  block[5] = a1;
  block[6] = DerivedStorage;
  block[7] = &v15;
  dispatch_sync(v10, block);
  if (v8)
  {
    xpc_dictionary_set_uint64(v8, "CompletionID", v27[3]);
    v12 = FigXPCRemoteClientSendSyncMessage(gFigEndpointRemoteControlSessionRemoteClient, (uint64_t)v8);
    if (!(_DWORD)v12)
      goto LABEL_13;
  }
  else
  {
    v12 = 4294949866;
  }
  v13 = *(NSObject **)(DerivedStorage + 16);
  v20[0] = v11;
  v20[1] = 0x40000000;
  v20[2] = __FigEndpointRemoteControlSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback_block_invoke_2;
  v20[3] = &unk_1E28E4D88;
  v20[5] = &v22;
  v20[6] = DerivedStorage;
  v20[4] = &v26;
  dispatch_sync(v13, v20);
  if (*((_BYTE *)v23 + 24) && v15 == 1936614509)
    v17(v12, 0, v16);
LABEL_13:
  FigXPCRemoteClientKillServerOnTimeout(gFigEndpointRemoteControlSessionRemoteClient, v12, "FigEndpointRemoteControlSessionRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback", 0);
  _Block_object_dispose(&v22, 8);
  _Block_object_dispose(&v26, 8);
  FigXPCRelease(*(xpc_object_t *)v19);
  return v12;
}

uint64_t FigEndpointRemoteControlSessionRemoteXPC_SetEventHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t ObjectID;
  unsigned int v7;
  uint64_t DerivedStorage;
  NSObject *v9;
  uint64_t v10;
  _QWORD block[7];
  uint64_t v13;
  xpc_object_t v14;

  v13 = 0;
  v14 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v13);
  if (!(_DWORD)ObjectID)
  {
    if (a2)
      v7 = 1936029288;
    else
      v7 = 1667593832;
    ObjectID = FigXPCCreateBasicMessage(v7, v13, &v14);
    if (!(_DWORD)ObjectID)
    {
      DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
      v9 = *(NSObject **)(DerivedStorage + 16);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __FigEndpointRemoteControlSessionRemoteXPC_SetEventHandler_block_invoke;
      block[3] = &__block_descriptor_tmp_10_10;
      block[4] = DerivedStorage;
      block[5] = a2;
      block[6] = a3;
      dispatch_sync(v9, block);
      ObjectID = FigXPCRemoteClientSendSyncMessage(gFigEndpointRemoteControlSessionRemoteClient, (uint64_t)v14);
    }
  }
  v10 = ObjectID;
  FigXPCRelease(v14);
  return v10;
}

uint64_t FigEndpointRemoteControlSessionRemoteXPC_TeardownSession(uint64_t a1)
{
  uint64_t ObjectID;
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v6;
  void *v7;

  v6 = 0;
  v7 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v6);
  if ((_DWORD)ObjectID)
  {
    v4 = ObjectID;
    v3 = 0;
  }
  else
  {
    v2 = FigXPCCreateBasicMessage(0x7472646Eu, v6, &v7);
    v3 = v7;
    if ((_DWORD)v2)
    {
      v4 = v2;
    }
    else
    {
      v4 = FigXPCRemoteClientSendSyncMessage(gFigEndpointRemoteControlSessionRemoteClient, (uint64_t)v7);
      v3 = v7;
    }
  }
  FigXPCRelease(v3);
  return v4;
}

uint64_t FigEndpointRemoteControlSessionRemoteXPC_Start(uint64_t a1)
{
  uint64_t ObjectID;
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v6;
  void *v7;

  v6 = 0;
  v7 = 0;
  ObjectID = remoteXPCEndpointPlaybackSession_GetObjectID(a1, &v6);
  if ((_DWORD)ObjectID)
  {
    v4 = ObjectID;
    v3 = 0;
  }
  else
  {
    v2 = FigXPCCreateBasicMessage(0x73747274u, v6, &v7);
    v3 = v7;
    if ((_DWORD)v2)
    {
      v4 = v2;
    }
    else
    {
      v4 = FigXPCRemoteClientSendSyncMessage(gFigEndpointRemoteControlSessionRemoteClient, (uint64_t)v7);
      v3 = v7;
    }
  }
  FigXPCRelease(v3);
  return v4;
}

uint64_t FigTransportConnectionTCPCreate(uint64_t a1, CFTypeRef *a2)
{
  _QWORD *ClassID;
  uint64_t v5;
  uint64_t DerivedStorage;
  dispatch_queue_t v7;
  dispatch_queue_t v8;
  __CFDictionary *Mutable;
  OpaqueCMMemoryPool *v10;
  CFAllocatorRef Allocator;
  CFTypeRef cf;

  cf = 0;
  if (a2)
  {
    ClassID = (_QWORD *)NeroTransportConnectionGetClassID();
    v5 = CMDerivedObjectCreate(a1, (uint64_t)&kFigTransportConnectionUSBVTable_0, ClassID, &cf);
    if (!(_DWORD)v5)
    {
      DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
      *(_QWORD *)(DerivedStorage + 88) = -1;
      *(_DWORD *)(DerivedStorage + 96) = -1;
      *(_DWORD *)(DerivedStorage + 104) = -1;
      v7 = FigDispatchQueueCreateWithPriority("FigTransportConnectionTCP", 0, 0x1Cu);
      *(_QWORD *)(DerivedStorage + 8) = v7;
      if (v7)
      {
        v8 = FigDispatchQueueCreateWithPriority("FigTransportConnectionTCP.data", 0, 0x1Cu);
        *(_QWORD *)(DerivedStorage + 16) = v8;
        if (v8)
        {
          Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          CFDictionarySetValue(Mutable, CFSTR("FigMemoryPool_LoggingName"), CFSTR("TransportConnectionTCP"));
          v10 = CMMemoryPoolCreate(Mutable);
          *(_QWORD *)(DerivedStorage + 72) = v10;
          if (Mutable)
          {
            CFRelease(Mutable);
            v10 = *(OpaqueCMMemoryPool **)(DerivedStorage + 72);
          }
          if (v10)
          {
            Allocator = CMMemoryPoolGetAllocator(v10);
            *(_QWORD *)(DerivedStorage + 80) = Allocator;
            if (Allocator)
              CFRetain(Allocator);
            v5 = 0;
            *(_DWORD *)(DerivedStorage + 40) = 29888;
            *a2 = cf;
            return v5;
          }
        }
      }
      v5 = 4294955245;
    }
    if (cf)
      CFRelease(cf);
    return v5;
  }
  return FigSignalErrorAt(4294955246, 0, 0, 0, 0, 0, 0);
}

uint64_t tcp_Invalidate(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v2;
  NSObject *v3;
  const void *v4;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!*(_BYTE *)DerivedStorage)
  {
    v2 = DerivedStorage;
    *(_BYTE *)DerivedStorage = 1;
    v3 = *(NSObject **)(DerivedStorage + 64);
    if (v3)
    {
      dispatch_release(v3);
      *(_QWORD *)(v2 + 64) = 0;
    }
    v4 = *(const void **)(v2 + 56);
    if (v4)
    {
      _Block_release(v4);
      *(_QWORD *)(v2 + 56) = 0;
    }
  }
  return 0;
}

void tcp_Finalize(uint64_t a1)
{
  _QWORD *DerivedStorage;
  NSObject *v3;
  NSObject *v4;
  const void *v5;
  const void *v6;
  NSObject *v7;
  const void *v8;
  const void *v9;
  const void *v10;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  tcp_Invalidate(a1);
  tcp_CleanupFileDescriptors(a1);
  v3 = DerivedStorage[1];
  if (v3)
  {
    dispatch_release(v3);
    DerivedStorage[1] = 0;
  }
  v4 = DerivedStorage[2];
  if (v4)
  {
    dispatch_release(v4);
    DerivedStorage[2] = 0;
  }
  v5 = (const void *)DerivedStorage[3];
  if (v5)
  {
    CFRelease(v5);
    DerivedStorage[3] = 0;
  }
  v6 = (const void *)DerivedStorage[4];
  if (v6)
  {
    CFRelease(v6);
    DerivedStorage[4] = 0;
  }
  v7 = DerivedStorage[8];
  if (v7)
  {
    dispatch_release(v7);
    DerivedStorage[8] = 0;
  }
  v8 = (const void *)DerivedStorage[7];
  if (v8)
  {
    _Block_release(v8);
    DerivedStorage[7] = 0;
  }
  v9 = (const void *)DerivedStorage[9];
  if (v9)
  {
    CFRelease(v9);
    DerivedStorage[9] = 0;
  }
  v10 = (const void *)DerivedStorage[10];
  if (v10)
  {
    CFRelease(v10);
    DerivedStorage[10] = 0;
  }
}

__CFString *tcp_CopyDebugDescription(uint64_t a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigTransportConnectionUSB %p>"), a1);
  return Mutable;
}

uint64_t tcp_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  _BYTE *DerivedStorage;
  _QWORD *v7;
  const void *v8;
  uint64_t v9;

  DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage)
    return 4294955241;
  v7 = DerivedStorage;
  if (CFEqual(a2, CFSTR("ConnectionMode")))
  {
    v8 = (const void *)v7[3];
    if (!v8)
      goto LABEL_8;
    goto LABEL_7;
  }
  if (CFEqual(a2, CFSTR("IPAddress")))
  {
    v8 = (const void *)v7[4];
    if (v8)
LABEL_7:
      v8 = CFRetain(v8);
  }
  else
  {
    if (!CFEqual(a2, CFSTR("Version")))
      return 4294954512;
    v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, (char *)v7 + 44);
  }
LABEL_8:
  v9 = 0;
  *a4 = v8;
  return v9;
}

uint64_t tcp_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  _BYTE *DerivedStorage;
  _QWORD *v6;
  uint64_t v7;
  CFTypeID v9;

  DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage)
    return 4294955241;
  v6 = DerivedStorage;
  if (CFEqual(a2, CFSTR("ConnectionMode")))
  {
    v7 = v6[3];
    v6[3] = a3;
    if (!a3)
      goto LABEL_5;
    goto LABEL_4;
  }
  if (CFEqual(a2, CFSTR("IPAddress")))
  {
    v7 = v6[4];
    v6[4] = a3;
    if (!a3)
    {
LABEL_5:
      if (v7)
      {
        CFRelease((CFTypeRef)v7);
        return 0;
      }
      return v7;
    }
LABEL_4:
    CFRetain(a3);
    goto LABEL_5;
  }
  if (CFEqual(a2, CFSTR("Port")))
  {
    CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, v6 + 5);
    return 0;
  }
  if (!CFEqual(a2, CFSTR("Version")))
    return 4294954512;
  if (!a3)
    return 4294954516;
  v9 = CFGetTypeID(a3);
  v7 = 4294954516;
  if (v9 == CFNumberGetTypeID())
  {
    if (CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, (char *)v6 + 44))
      return 0;
    else
      return 4294954516;
  }
  return v7;
}

uint64_t tcp_CleanupFileDescriptors(uint64_t a1)
{
  _DWORD *DerivedStorage;
  int v2;
  int v3;
  int v4;
  uint64_t result;

  DerivedStorage = (_DWORD *)CMBaseObjectGetDerivedStorage(a1);
  v2 = DerivedStorage[22];
  if ((v2 & 0x80000000) == 0)
  {
    close(v2);
    DerivedStorage[22] = -1;
  }
  v3 = DerivedStorage[23];
  if ((v3 & 0x80000000) == 0)
  {
    close(v3);
    DerivedStorage[23] = -1;
  }
  v4 = DerivedStorage[24];
  if ((v4 & 0x80000000) == 0)
  {
    close(v4);
    DerivedStorage[24] = -1;
  }
  result = DerivedStorage[26];
  if ((result & 0x80000000) == 0)
  {
    result = close(result);
    DerivedStorage[26] = -1;
  }
  return result;
}

uint64_t tcp_SetEventHandler(uint64_t a1, NSObject *a2, const void *a3)
{
  uint64_t DerivedStorage;
  uint64_t v6;
  NSObject *v7;
  const void *v8;
  void *v9;
  uint64_t result;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)DerivedStorage)
    return 4294955241;
  v6 = DerivedStorage;
  v7 = *(NSObject **)(DerivedStorage + 64);
  if (v7)
  {
    dispatch_release(v7);
    *(_QWORD *)(v6 + 64) = 0;
  }
  if (a2)
  {
    *(_QWORD *)(v6 + 64) = a2;
    dispatch_retain(a2);
  }
  else
  {
    *(_QWORD *)(v6 + 64) = FigDispatchQueueCreateWithPriority("FigTransportConnectionEvent", 0, 0x1Cu);
  }
  v8 = *(const void **)(v6 + 56);
  if (v8)
  {
    _Block_release(v8);
    *(_QWORD *)(v6 + 56) = 0;
  }
  if (!a3)
    return 0;
  v9 = _Block_copy(a3);
  result = 0;
  *(_QWORD *)(v6 + 56) = v9;
  return result;
}

uint64_t tcp_Start(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *v3;
  uint64_t v4;
  _QWORD block[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)DerivedStorage)
  {
    v4 = 4294955241;
    *((_DWORD *)v8 + 6) = -12055;
  }
  else
  {
    v3 = *(NSObject **)(DerivedStorage + 8);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __tcp_Start_block_invoke;
    block[3] = &unk_1E28E4E88;
    block[4] = &v7;
    block[5] = DerivedStorage;
    block[6] = a1;
    dispatch_sync(v3, block);
    v4 = *((unsigned int *)v8 + 6);
  }
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t tcp_Stop(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *v3;
  _QWORD v5[6];

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)DerivedStorage)
    return 4294955241;
  v3 = *(NSObject **)(DerivedStorage + 8);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __tcp_Stop_block_invoke;
  v5[3] = &__block_descriptor_tmp_23_2;
  v5[4] = DerivedStorage;
  v5[5] = a1;
  dispatch_sync(v3, v5);
  return 0;
}

uint64_t tcp_EnqueuePackageWithPriority(const void *a1, unsigned int *a2, OpaqueCMBlockBuffer *a3, int a4)
{
  uint64_t DerivedStorage;
  uint64_t v9;
  size_t DataLength;
  size_t v11;
  uint64_t v12;
  _QWORD *v14;
  NSObject *v15;
  uint64_t v16;
  _QWORD block[7];
  int v18;
  CMBlockBufferRef blockBufferOut;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v9 = *a2;
  DataLength = CMBlockBufferGetDataLength(a3);
  if (*(_BYTE *)DerivedStorage)
  {
    v12 = 4294955241;
    goto LABEL_11;
  }
  if (a2[1] == 1885957735)
    goto LABEL_15;
  if (!*(_BYTE *)(DerivedStorage + 121))
  {
    v16 = 4294955244;
    goto LABEL_18;
  }
  if ((a4 - 3) <= 0xFFFFFFFD || (v11 = v9 - DataLength, v11 <= 7))
  {
LABEL_15:
    v16 = 4294955246;
LABEL_18:
    v12 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    goto LABEL_11;
  }
  blockBufferOut = 0;
  if (CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v11, (CFAllocatorRef)*MEMORY[0x1E0C9AE10], 0, 0, v11, 1u, &blockBufferOut)|| CMBlockBufferReplaceDataBytes(a2, blockBufferOut, 0, v11)|| a3 && CMBlockBufferAppendBufferReference(blockBufferOut, a3, 0, 0, 0))
  {
    if (blockBufferOut)
      CFRelease(blockBufferOut);
    v12 = 4294955245;
  }
  else
  {
    v14 = malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
    v14[1] = blockBufferOut;
    CFRetain(a1);
    v15 = *(NSObject **)(DerivedStorage + 16);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __tcp_EnqueuePackageWithPriority_block_invoke;
    block[3] = &__block_descriptor_tmp_25_3;
    block[4] = v14;
    block[5] = DerivedStorage;
    v18 = a4;
    block[6] = a1;
    dispatch_async(v15, block);
    v12 = 0;
  }
LABEL_11:
  tcp_destroyPackageRecord(0);
  return v12;
}

uint64_t tcp_FlushPendingPackagesWithPriority(uint64_t a1, int a2)
{
  if (*(_BYTE *)CMBaseObjectGetDerivedStorage(a1))
    return 4294955241;
  tcp_sendDataToSocket(a1, a2);
  return 0;
}

uint64_t tcp_clientThreadMain(const void *a1)
{
  uint64_t DerivedStorage;
  uint64_t v4;
  uint64_t v5;
  int v6;
  const __CFString *v7;
  char *CStringPtrAndBufferToFree;
  in_addr_t v9;
  int v10;
  int v11;
  int v12;
  void *v13;
  addrinfo *v14;
  addrinfo v15;
  sockaddr v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!*(_BYTE *)(DerivedStorage + 120))
  {
    v4 = DerivedStorage;
    do
    {
      v5 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
      v6 = socket(2, 1, 6);
      *(_DWORD *)(v5 + 88) = v6;
      if ((v6 & 0x80000000) == 0)
      {
        *(_DWORD *)&v16.sa_data[10] = 0;
        *(_QWORD *)&v16.sa_data[2] = 0;
        *(_WORD *)&v16.sa_len = 528;
        *(_WORD *)v16.sa_data = bswap32(*(unsigned __int16 *)(v5 + 40)) >> 16;
        v7 = *(const __CFString **)(v5 + 32);
        if (v7)
        {
          v13 = 0;
          CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree(v7, 0x600u, (char **)&v13);
          v9 = inet_addr(CStringPtrAndBufferToFree);
          if (v9 == -1)
          {
            v14 = 0;
            memset(&v15, 0, sizeof(v15));
            *(_QWORD *)&v15.ai_family = 0x100000002;
            if (getaddrinfo(CStringPtrAndBufferToFree, 0, &v15, &v14) || !v14)
            {
              v10 = -1;
            }
            else
            {
              v10 = *(_DWORD *)&v14->ai_addr->sa_data[2];
              freeaddrinfo(v14);
            }
          }
          else
          {
            v10 = v9;
          }
          *(_DWORD *)&v16.sa_data[2] = v10;
          free(v13);
          v6 = *(_DWORD *)(v5 + 88);
        }
        if (!connect(v6, &v16, 0x10u))
        {
          *(_DWORD *)(v5 + 96) = *(_DWORD *)(v5 + 88);
          *(_DWORD *)(v5 + 88) = -1;
          tcp_sendAndReceiveData(a1);
        }
      }
      v11 = *(_DWORD *)(v5 + 96);
      if ((v11 & 0x80000000) == 0)
      {
        close(v11);
        *(_DWORD *)(v5 + 96) = -1;
      }
      v12 = *(_DWORD *)(v5 + 88);
      if ((v12 & 0x80000000) == 0)
      {
        close(v12);
        *(_DWORD *)(v5 + 88) = -1;
      }
      sleep(5u);
    }
    while (!*(_BYTE *)(v4 + 120));
  }
  return 0;
}

void tcp_sendAndReceiveData(const void *a1)
{
  uint64_t DerivedStorage;
  NSObject *v3;
  uint64_t v4;
  pollfd *v5;
  NSObject *v6;
  __int16 v7;
  uint64_t v8;
  NSObject *v9;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  _QWORD v15[6];
  _QWORD v16[5];
  _QWORD block[6];
  _QWORD v18[7];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  char v26;
  _QWORD v27[10];

  v27[8] = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  CFRetain(a1);
  v3 = *(NSObject **)(DerivedStorage + 16);
  v4 = MEMORY[0x1E0C809B0];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __tcp_sendAndReceiveData_block_invoke;
  block[3] = &__block_descriptor_tmp_14_5;
  block[4] = DerivedStorage;
  block[5] = a1;
  dispatch_async(v3, block);
  v5 = (pollfd *)(DerivedStorage + 96);
  if (!fcntl(*(_DWORD *)(DerivedStorage + 96), 4, 4) && !fcntl(*(_DWORD *)(DerivedStorage + 104), 4, 4))
  {
    *(_WORD *)(DerivedStorage + 100) = 5;
    *(_WORD *)(DerivedStorage + 108) = 1;
    while (!*(_BYTE *)(DerivedStorage + 120))
    {
      if (poll(v5, 2u, -1) < 0)
        break;
      if ((*(_WORD *)(DerivedStorage + 110) & 0x19) != 0)
      {
        while ((int)read(*(_DWORD *)(DerivedStorage + 104), v27, 0x40uLL) > 0)
          ;
        if (*(_BYTE *)(DerivedStorage + 120))
          break;
      }
      v7 = *(_WORD *)(DerivedStorage + 102);
      if ((v7 & 0x18) != 0)
        break;
      if ((v7 & 1) != 0)
      {
        v8 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
        v23 = 0;
        v24 = &v23;
        v25 = 0x2000000000;
        v26 = 1;
        do
        {
          v19 = 0;
          v20 = &v19;
          v21 = 0x2000000000;
          v22 = 0;
          v9 = *(NSObject **)(v8 + 16);
          v18[0] = v4;
          v18[1] = 0x40000000;
          v18[2] = __tcp_readDataFromSocket_block_invoke;
          v18[3] = &unk_1E28E4F50;
          v18[5] = &v19;
          v18[6] = a1;
          v18[4] = &v23;
          dispatch_sync(v9, v18);
          v10 = (const void *)v20[3];
          if (v10)
          {
            v11 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
            if (*(_QWORD *)(v11 + 56))
            {
              v12 = v11;
              CFRetain(v10);
              CFRetain(a1);
              v13 = *(NSObject **)(v12 + 64);
              v27[0] = v4;
              v27[1] = 0x40000000;
              v27[2] = __tcp_didReceivePackage_block_invoke;
              v27[3] = &__block_descriptor_tmp_19_2;
              v27[4] = v12;
              v27[5] = v10;
              v27[6] = a1;
              dispatch_async(v13, v27);
            }
            CFRelease((CFTypeRef)v20[3]);
          }
          _Block_object_dispose(&v19, 8);
        }
        while (*((_BYTE *)v24 + 24));
        _Block_object_dispose(&v23, 8);
        v7 = *(_WORD *)(DerivedStorage + 102);
        v5 = (pollfd *)(DerivedStorage + 96);
      }
      if ((v7 & 4) != 0)
        tcp_sendDataToSocket((uint64_t)a1, 0);
      v14 = *(NSObject **)(DerivedStorage + 16);
      v16[0] = v4;
      v16[1] = 0x40000000;
      v16[2] = __tcp_sendAndReceiveData_block_invoke_3;
      v16[3] = &__block_descriptor_tmp_15_2;
      v16[4] = DerivedStorage;
      dispatch_sync(v14, v16);
    }
  }
  CFRetain(a1);
  v6 = *(NSObject **)(DerivedStorage + 16);
  v15[0] = v4;
  v15[1] = 0x40000000;
  v15[2] = __tcp_sendAndReceiveData_block_invoke_4;
  v15[3] = &__block_descriptor_tmp_17_1;
  v15[4] = DerivedStorage;
  v15[5] = a1;
  dispatch_async(v6, v15);
}

void __tcp_sendAndReceiveData_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[4];
  __int128 v6;

  v2 = 0;
  v3 = *(_QWORD *)(a1 + 32);
  do
  {
    *(_QWORD *)(v3 + v2 + 152) = 0;
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + v2 + 160) = *(_QWORD *)(a1 + 32) + v2 + 152;
    v3 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(v3 + v2 + 168) = 0;
    v2 += 24;
  }
  while (v2 != 48);
  *(_QWORD *)(v3 + 200) = 0;
  *(_DWORD *)(v3 + 208) = 0;
  *(_QWORD *)(v3 + 216) = 0;
  v4 = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v4 + 121) = 1;
  if (*(_QWORD *)(v4 + 56))
  {
    CFRetain(*(CFTypeRef *)(a1 + 40));
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 0x40000000;
    v5[2] = __tcp_sendAndReceiveData_block_invoke_2;
    v5[3] = &__block_descriptor_tmp_13_4;
    v6 = *(_OWORD *)(a1 + 32);
    dispatch_async(*(dispatch_queue_t *)(v6 + 64), v5);
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void __tcp_sendAndReceiveData_block_invoke_2(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 56) + 16))();
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void tcp_sendDataToSocket(uint64_t a1, int a2)
{
  uint64_t DerivedStorage;
  NSObject *v5;
  _QWORD block[6];
  int v7;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v5 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __tcp_sendDataToSocket_block_invoke;
  block[3] = &__block_descriptor_tmp_20_2;
  block[4] = DerivedStorage;
  block[5] = a1;
  v7 = a2;
  dispatch_sync(v5, block);
}

uint64_t __tcp_sendAndReceiveData_block_invoke_3(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  v1 = 0;
  v2 = *(_QWORD *)(result + 32);
  *(_WORD *)(v2 + 100) = 1;
  *(_WORD *)(v2 + 108) = 1;
  while (!*(_QWORD *)(v2 + 152 + v1))
  {
    v1 += 24;
    if (v1 == 48)
      return result;
  }
  *(_WORD *)(v2 + 100) = 5;
  return result;
}

void __tcp_sendAndReceiveData_block_invoke_4(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  uint64_t i;
  uint64_t v5;
  CFTypeRef *v6;
  CFTypeRef *v7;
  CFTypeRef *v8;
  CFTypeRef v9;
  _QWORD v10[4];
  __int128 v11;

  v2 = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v2 + 121) = 0;
  if (*(_QWORD *)(v2 + 56))
  {
    CFRetain(*(CFTypeRef *)(a1 + 40));
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 0x40000000;
    v10[2] = __tcp_sendAndReceiveData_block_invoke_5;
    v10[3] = &__block_descriptor_tmp_16_2;
    v11 = *(_OWORD *)(a1 + 32);
    dispatch_async(*(dispatch_queue_t *)(v11 + 64), v10);
    v2 = *(_QWORD *)(a1 + 32);
  }
  v3 = *(const void **)(v2 + 216);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 216) = 0;
    v2 = *(_QWORD *)(a1 + 32);
  }
  *(_DWORD *)(v2 + 208) = 0;
  *(_QWORD *)(v2 + 200) = 0;
  for (i = 1; i != 3; ++i)
  {
    while (1)
    {
      v5 = v2 + 24 * i;
      v8 = *(CFTypeRef **)(v5 + 128);
      v6 = (CFTypeRef *)(v5 + 128);
      v7 = v8;
      if (!v8)
        break;
      v9 = *v7;
      *v6 = *v7;
      if (!v9)
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24 * i + 136) = *(_QWORD *)(a1 + 32) + 24 * i + 128;
      CFRelease(v7[1]);
      free(v7);
      v2 = *(_QWORD *)(a1 + 32);
    }
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void __tcp_sendAndReceiveData_block_invoke_5(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 56) + 16))();
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void tcp_destroyPackageRecord(CFTypeRef *a1)
{
  if (a1)
  {
    CFRelease(a1[1]);
    free(a1);
  }
}

uint64_t __tcp_readDataFromSocket_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  size_t v5;
  uint64_t v6;
  char *v7;
  size_t v8;
  CMBlockBufferRef *v9;
  char v10;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;

  v2 = *(_QWORD *)(a1[5] + 8);
  result = CMBaseObjectGetDerivedStorage(a1[6]);
  v4 = result;
  v5 = *(_QWORD *)(result + 200);
  if (v5 <= 3)
  {
    v6 = result + 208;
    while (1)
    {
      v7 = (char *)(v6 + v5);
      v8 = 4 - v5;
      result = read(*(_DWORD *)(v4 + 96), (void *)(v6 + v5), 4 - v5);
      if (result < 1)
        break;
      v5 = *(_QWORD *)(v4 + 200) + result;
      *(_QWORD *)(v4 + 200) = v5;
      if (v5 >= 4)
        goto LABEL_7;
    }
LABEL_15:
    v10 = 0;
    goto LABEL_16;
  }
  v8 = 0;
  v7 = 0;
LABEL_7:
  lengthAtOffsetOut = v8;
  dataPointerOut = v7;
  v9 = (CMBlockBufferRef *)(v4 + 216);
  if (*(_QWORD *)(v4 + 216))
    goto LABEL_8;
  result = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, *(unsigned int *)(v4 + 208), *(CFAllocatorRef *)(v4 + 80), 0, 0, *(unsigned int *)(v4 + 208), 1u, (CMBlockBufferRef *)(v4 + 216));
  if ((_DWORD)result)
    goto LABEL_15;
  result = CMBlockBufferReplaceDataBytes((const void *)(v4 + 208), *v9, 0, 4uLL);
  if ((_DWORD)result)
    goto LABEL_15;
  v5 = *(_QWORD *)(v4 + 200);
LABEL_8:
  while (v5 < *(unsigned int *)(v4 + 208))
  {
    result = CMBlockBufferGetDataPointer(*v9, v5, &lengthAtOffsetOut, 0, &dataPointerOut);
    if ((_DWORD)result)
      goto LABEL_15;
    result = read(*(_DWORD *)(v4 + 96), dataPointerOut, lengthAtOffsetOut);
    if (result < 1)
      goto LABEL_15;
    v5 = *(_QWORD *)(v4 + 200) + result;
    *(_QWORD *)(v4 + 200) = v5;
  }
  *(_QWORD *)(v2 + 24) = *(_QWORD *)(v4 + 216);
  *(_QWORD *)(v4 + 216) = 0;
  *(_DWORD *)(v4 + 208) = 0;
  *(_QWORD *)(v4 + 200) = 0;
  v10 = 1;
LABEL_16:
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = v10;
  return result;
}

void __tcp_didReceivePackage_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 56) + 16))();
  CFRelease(*(CFTypeRef *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 48));
}

void __tcp_sendDataToSocket_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;
  size_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  CMBlockBufferRef *v12;
  unint64_t v13;
  size_t DataLength;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CMBlockBufferRef *v21;
  size_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v2 = *(_QWORD *)(a1 + 32);
  for (i = 152; i != 200; i += 24)
  {
    v4 = *(_QWORD *)(v2 + i + 16);
    if (v4)
    {
      v5 = *(_QWORD *)(v2 + i);
      v6 = tcp_sendPackageToSocket(*(_QWORD *)(a1 + 40), *(CMBlockBufferRef *)(v5 + 8), v4);
      v7 = *(_QWORD *)(a1 + 32) + i;
      v8 = *(_QWORD *)(v7 + 16) + v6;
      *(_QWORD *)(v7 + 16) = v8;
      if (v8 < CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(v5 + 8)))
        return;
      v9 = *(_QWORD *)(a1 + 32);
      v10 = **(_QWORD **)(v9 + i);
      *(_QWORD *)(v9 + i) = v10;
      if (!v10)
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + i + 8) = *(_QWORD *)(a1 + 32) + i;
      tcp_destroyPackageRecord((CFTypeRef *)v5);
      v2 = *(_QWORD *)(a1 + 32);
      *(_QWORD *)(v2 + i + 16) = 0;
    }
  }
  v11 = *(_DWORD *)(a1 + 48);
  if (v11)
  {
    v12 = *(CMBlockBufferRef **)(v2 + 24 * v11 + 128);
    if (!v12)
      return;
    while (1)
    {
      v13 = tcp_sendPackageToSocket(*(_QWORD *)(a1 + 40), v12[1], 0);
      DataLength = CMBlockBufferGetDataLength(v12[1]);
      v15 = *(_QWORD *)(a1 + 32);
      v16 = *(_DWORD *)(a1 + 48);
      if (v13 < DataLength)
        break;
      v17 = v15 + 24 * v16;
      v18 = **(_QWORD **)(v17 + 128);
      *(_QWORD *)(v17 + 128) = v18;
      if (!v18)
      {
        v19 = *(_QWORD *)(a1 + 32) + 24 * v16;
        *(_QWORD *)(v19 + 136) = v19 + 128;
      }
      CFRelease(v12[1]);
      free(v12);
      v12 = *(CMBlockBufferRef **)(*(_QWORD *)(a1 + 32) + 24 * *(int *)(a1 + 48) + 128);
      if (!v12)
        return;
    }
    v26 = v15 + 24 * v16;
  }
  else
  {
    v20 = 1;
    while (1)
    {
      while (1)
      {
        v21 = *(CMBlockBufferRef **)(v2 + 24 * v20 + 128);
        if (v21)
          break;
        if (++v20 == 3)
          return;
      }
      v13 = tcp_sendPackageToSocket(*(_QWORD *)(a1 + 40), v21[1], 0);
      v22 = CMBlockBufferGetDataLength(v21[1]);
      v23 = *(_QWORD *)(a1 + 32);
      if (v13 < v22)
        break;
      v24 = v23 + 24 * v20;
      v25 = **(_QWORD **)(v24 + 128);
      *(_QWORD *)(v24 + 128) = v25;
      if (!v25)
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24 * v20 + 136) = *(_QWORD *)(a1 + 32) + 24 * v20 + 128;
      CFRelease(v21[1]);
      free(v21);
      v2 = *(_QWORD *)(a1 + 32);
    }
    v26 = v23 + 24 * v20;
  }
  *(_QWORD *)(v26 + 144) = v13;
}

uint64_t tcp_sendPackageToSocket(uint64_t a1, CMBlockBufferRef theBuffer, size_t a3)
{
  size_t DataLength;
  uint64_t v7;
  char *v8;
  size_t v9;
  uint64_t DerivedStorage;
  size_t v11;
  size_t v12;
  ssize_t v13;
  char *v15;
  size_t lengthAtOffsetOut;

  DataLength = CMBlockBufferGetDataLength(theBuffer);
  v7 = 0;
  while (a3 < DataLength)
  {
    v15 = 0;
    lengthAtOffsetOut = 0;
    if (CMBlockBufferGetDataPointer(theBuffer, a3, &lengthAtOffsetOut, 0, &v15))
      break;
    v8 = v15;
    v9 = lengthAtOffsetOut;
    DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
    v11 = 0;
    do
    {
      v12 = v11;
      if (v9 <= v11)
        break;
      v13 = write(*(_DWORD *)(DerivedStorage + 96), &v8[v11], v9 - v11);
      v11 = v13 + v12;
    }
    while (v13 > 0);
    v7 += v12;
    if (v12 != lengthAtOffsetOut)
      break;
    a3 += v12;
  }
  return v7;
}

uint64_t tcp_serverThreadMain(const void *a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  uint64_t v4;
  int v5;
  const __CFString *v6;
  char *CStringPtrAndBufferToFree;
  int v8;
  int v9;
  socklen_t v11[2];
  int v12;
  sockaddr v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!*(_BYTE *)(DerivedStorage + 120))
  {
    v3 = DerivedStorage;
    do
    {
      v4 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
      v5 = socket(2, 1, 6);
      *(_DWORD *)(v4 + 88) = v5;
      if ((v5 & 0x80000000) == 0)
      {
        v12 = 1;
        if (!setsockopt(v5, 0xFFFF, 4, &v12, 4u))
        {
          *(_DWORD *)&v13.sa_data[10] = 0;
          *(_QWORD *)&v13.sa_data[2] = 0;
          *(_WORD *)&v13.sa_len = 528;
          *(_WORD *)v13.sa_data = bswap32(*(unsigned __int16 *)(v4 + 40)) >> 16;
          v6 = *(const __CFString **)(v4 + 32);
          if (v6)
          {
            *(_QWORD *)v11 = 0;
            CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree(v6, 0x600u, (char **)v11);
            *(_DWORD *)&v13.sa_data[2] = inet_addr(CStringPtrAndBufferToFree);
            free(*(void **)v11);
          }
          if (!bind(*(_DWORD *)(v4 + 88), &v13, 0x10u) && !listen(*(_DWORD *)(v4 + 88), 5))
          {
            v11[0] = 16;
            *(_DWORD *)(v4 + 96) = accept(*(_DWORD *)(v4 + 88), &v13, v11);
            tcp_sendAndReceiveData(a1);
          }
        }
      }
      v8 = *(_DWORD *)(v4 + 96);
      if ((v8 & 0x80000000) == 0)
      {
        close(v8);
        *(_DWORD *)(v4 + 96) = -1;
      }
      v9 = *(_DWORD *)(v4 + 88);
      if ((v9 & 0x80000000) == 0)
      {
        close(v9);
        *(_DWORD *)(v4 + 88) = -1;
      }
    }
    while (!*(_BYTE *)(v3 + 120));
  }
  return 0;
}

dispatch_queue_t FigDispatchQueueCreateWithPriority(const char *a1, NSObject *a2, unsigned int a3)
{
  int v6;

  if (FigGetQualityOfServiceClassForFigThreadPriority(a3))
  {
    if (a2 != MEMORY[0x1E0C80D50])
      goto LABEL_17;
    goto LABEL_16;
  }
  if (a3 - 41 < 2)
  {
    if (figDispatch_shouldUseWorkloopForFigThreadPriority_onceToken != -1)
      dispatch_once_f(&figDispatch_shouldUseWorkloopForFigThreadPriority_onceToken, &figDispatch_shouldUseWorkloopForFigThreadPriority_shouldUseWorkloopForAssetQueues, (dispatch_function_t)figDispatch_shouldUseWorkloopQueuesForAssetPrioritiesOnce);
    v6 = figDispatch_shouldUseWorkloopForFigThreadPriority_shouldUseWorkloopForAssetQueues;
  }
  else if (a3 == 4)
  {
    v6 = 1;
  }
  else
  {
    v6 = a3 == 44 && FigServer_IsServerProcess();
  }
  if (a2 == MEMORY[0x1E0C80D50])
  {
LABEL_16:
    FigDebugIsInternalBuild();
    goto LABEL_17;
  }
  if (v6)
    return FigDispatchQueueCreateTargetingWorkloopWithPriority(a1, a2, a3);
LABEL_17:
  if (a3 == 39)
    return FigDispatchQueueCreateStandardDispatchQueue(a1, a2, 9, QOS_CLASS_BACKGROUND);
  else
    return FigDispatchQueueCreateTargetingPThreadRootQueueWithPriority(a1, a2, a3);
}

uint64_t FigGetQualityOfServiceClassForFigThreadPriority(int a1)
{
  uint64_t result;

  result = 0;
  if (a1 <= 30)
  {
    if (a1 != 8)
    {
      if (a1 == 25)
        return 9;
      if (a1 != 30)
        return result;
      return 25;
    }
    return 17;
  }
  switch(a1)
  {
    case 46:
      return 25;
    case 38:
      return 33;
    case 31:
      return 17;
  }
  return result;
}

dispatch_queue_t FigDispatchQueueCreateTargetingWorkloopWithPriority(const char *a1, NSObject *a2, unsigned int a3)
{
  NSObject *WorkloopWithPriority;
  NSObject *v7;
  dispatch_queue_t v8;
  char __str[16];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  *(_OWORD *)__str = 0u;
  v11 = 0u;
  if (a1)
    snprintf(__str, 0x100uLL, "%s.workloop(%d)");
  else
    snprintf(__str, 0x100uLL, "com.apple.coremedia.unknown.workloop(%d)");
  WorkloopWithPriority = FigDispatchCreateWorkloopWithPriority(__str, a3);
  if (!WorkloopWithPriority)
    return 0;
  v7 = WorkloopWithPriority;
  v8 = dispatch_queue_create_with_target_V2(a1, a2, WorkloopWithPriority);
  if (gGMFigKTraceEnabled == 1)
  {
    FigThreadGetMachThreadPriorityValue(a3);
    kdebug_trace();
  }
  dispatch_release(v7);
  return v8;
}

NSObject *FigDispatchQueueCreateTargetingPThreadRootQueueWithPriority(const char *a1, NSObject *a2, unsigned int a3)
{
  NSObject *RootQueueWithPriority;
  NSObject *v7;

  RootQueueWithPriority = figDispatch_getRootQueueWithPriority(a3);
  v7 = dispatch_queue_create(a1, a2);
  if (gGMFigKTraceEnabled == 1)
  {
    FigThreadGetMachThreadPriorityValue(a3);
    kdebug_trace();
  }
  if (v7 && RootQueueWithPriority)
    dispatch_set_target_queue(v7, RootQueueWithPriority);
  return v7;
}

NSObject *FigDispatchQueueCreateStandardDispatchQueue(const char *a1, dispatch_queue_attr_t attr, int a3, dispatch_qos_class_t a4)
{
  NSObject *initially_inactive;
  NSObject *v8;

  initially_inactive = dispatch_queue_attr_make_initially_inactive(attr);
  v8 = dispatch_queue_create(a1, initially_inactive);
  if (v8)
  {
    if (a3)
      dispatch_set_qos_class_fallback();
    if (a4)
      dispatch_set_qos_class_floor(v8, a4, 0);
    dispatch_activate(v8);
    if (gGMFigKTraceEnabled == 1)
      kdebug_trace();
  }
  else
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  return v8;
}

dispatch_queue_t FigDispatchQueueCreateWithPriorityAndClientPID(const char *a1, NSObject *a2, uint64_t a3, uint64_t a4)
{
  dispatch_qos_class_t QualityOfServiceClassForFigThreadPriority;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;

  QualityOfServiceClassForFigThreadPriority = FigGetQualityOfServiceClassForFigThreadPriority(a3);
  v9 = dispatch_queue_attr_make_with_qos_class(a2, QualityOfServiceClassForFigThreadPriority, 0);
  if (!(_DWORD)a4)
    return FigDispatchQueueCreateWithPriority(a1, v9, a3);
  v10 = dispatch_queue_create(a1, v9);
  if (v10)
  {
    v11 = figDispatch_copyRootQueueWithPriorityAndClientPID(a3, a4);
    if (v11)
    {
      v12 = v11;
      dispatch_set_target_queue(v10, v11);
      dispatch_release(v12);
    }
  }
  return v10;
}

NSObject *figDispatch_copyRootQueueWithPriorityAndClientPID(uint64_t a1, uint64_t a2)
{
  __CFString *v4;
  id *Value;
  id *v6;
  NSObject *RootQueueWithMachPriority;
  id *v8;
  id *v9;
  unsigned int QualityOfServiceClassForFigThreadPriority;
  int MachThreadPriorityValue;
  char __str[64];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (figDispatch_copyRootQueueWithPriorityAndClientPID_initQueuesDictOnce != -1)
    dispatch_once(&figDispatch_copyRootQueueWithPriorityAndClientPID_initQueuesDictOnce, &__block_literal_global_51);
  v4 = (__CFString *)CFStringCreateWithFormat(0, 0, CFSTR("%d_%02d"), a2, a1);
  FigSimpleMutexLock((pthread_mutex_t *)sFigDispatchQueuesForPID_1);
  Value = (id *)CFDictionaryGetValue((CFDictionaryRef)sFigDispatchQueuesForPID_0, v4);
  if (Value)
  {
    v6 = Value;
    RootQueueWithMachPriority = FigCFWeakReferenceLoadAndRetain(Value);
    if (RootQueueWithMachPriority)
      goto LABEL_11;
    FigCFWeakReferenceStore(v6, 0);
    CFDictionaryRemoveValue((CFMutableDictionaryRef)sFigDispatchQueuesForPID_0, v4);
    free(v6);
  }
  v8 = (id *)malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
  if (v8)
  {
    v9 = v8;
    QualityOfServiceClassForFigThreadPriority = FigGetQualityOfServiceClassForFigThreadPriority(a1);
    MachThreadPriorityValue = FigThreadGetMachThreadPriorityValue(a1);
    snprintf(__str, 0x40uLL, "com.apple.coremedia.rootQueueForPID.%d_%02d", a2, a1);
    RootQueueWithMachPriority = figDispatch_createRootQueueWithMachPriority((uint64_t)__str, MachThreadPriorityValue, QualityOfServiceClassForFigThreadPriority);
    if (RootQueueWithMachPriority)
    {
      CFRetain(v4);
      dispatch_queue_set_specific(RootQueueWithMachPriority, &figDispatch_copyRootQueueWithPriorityAndClientPID_sFigDispatchRootQueueContextKey, v4, (dispatch_function_t)figDispatch_rootQueueDestructor);
      FigCFWeakReferenceStore(v9, RootQueueWithMachPriority);
      CFDictionarySetValue((CFMutableDictionaryRef)sFigDispatchQueuesForPID_0, v4, v9);
    }
    else
    {
      free(v9);
    }
  }
  else
  {
    RootQueueWithMachPriority = 0;
  }
LABEL_11:
  FigSimpleMutexUnlock((pthread_mutex_t *)sFigDispatchQueuesForPID_1);
  CFRelease(v4);
  return RootQueueWithMachPriority;
}

uint64_t figDispatch_getRootQueueWithPriority(unsigned int a1)
{
  uint64_t v2;
  dispatch_once_t *v3;
  _QWORD block[4];
  unsigned int v6;

  v2 = a1;
  v3 = &sRootQueuesIndexedByFigThreadPriority[2 * a1];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __figDispatch_getRootQueueWithPriority_block_invoke;
  block[3] = &__block_descriptor_tmp_17_2;
  v6 = a1;
  if (*v3 != -1)
    dispatch_once(v3, block);
  return sRootQueuesIndexedByFigThreadPriority[2 * v2 + 1];
}

NSObject *FigDispatchCreateWorkloopWithPriority(const char *a1, unsigned int a2)
{
  NSObject *inactive;

  inactive = dispatch_workloop_create_inactive(a1);
  FigThreadGetMachThreadPriorityValue(a2);
  dispatch_workloop_set_scheduler_priority();
  dispatch_activate(inactive);
  return inactive;
}

uint64_t FigDispatchQueueSetPriorityAndClientPID(NSObject *a1, uint64_t a2, uint64_t a3)
{
  NSObject *v4;
  NSObject *v5;
  NSObject *RootQueueWithPriority;
  uint64_t v8;

  if (a1)
  {
    if ((_DWORD)a3)
    {
      v4 = figDispatch_copyRootQueueWithPriorityAndClientPID(a2, a3);
      if (v4)
      {
        v5 = v4;
        dispatch_set_target_queue(a1, v4);
        dispatch_release(v5);
        return 0;
      }
      v8 = 4294954510;
    }
    else
    {
      RootQueueWithPriority = figDispatch_getRootQueueWithPriority(a2);
      if (RootQueueWithPriority)
      {
        dispatch_set_target_queue(a1, RootQueueWithPriority);
        return 0;
      }
      v8 = 4294954510;
    }
  }
  else
  {
    v8 = 4294954516;
  }
  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

void FigDispatchOnceInitWithinObject(_QWORD *a1)
{
  *a1 = 0;
  FigMemoryBarrier();
}

void FigDeferCFRelease(void *context)
{
  if (context)
  {
    if (FigDeferCFRelease_deferredReleaseQueueOnce != -1)
      dispatch_once_f(&FigDeferCFRelease_deferredReleaseQueueOnce, &FigDeferCFRelease_deferredReleaseQueue, (dispatch_function_t)figDispatch_initDeferredReleaseQueue);
    dispatch_async_f((dispatch_queue_t)FigDeferCFRelease_deferredReleaseQueue, context, (dispatch_function_t)figDispatch_releaseResourceOnQueue);
  }
}

uint64_t figDispatch_initDeferredReleaseQueue(dispatch_queue_t *a1)
{
  dispatch_queue_t v2;

  v2 = dispatch_queue_create("com.apple.coremedia.dispatchUtil.serialReleaseQueue", 0);
  *a1 = v2;
  return FigWatchdogMonitorDispatchQueue((uint64_t)v2);
}

uint64_t FigDispatchSyncCopyPropertyImplementation(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD context[6];
  unsigned int v8;

  v8 = 0;
  if (!a1 || !a2 || !a3 || !a4 || !a6)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  context[0] = &v8;
  context[1] = a3;
  context[2] = a4;
  context[3] = a2;
  context[4] = a6;
  context[5] = a5;
  dispatch_sync_f(a1, context, (dispatch_function_t)figPropertyCopyCallback);
  return v8;
}

uint64_t figPropertyCopyCallback(uint64_t a1)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(a1 + 24))(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32));
  **(_DWORD **)a1 = result;
  return result;
}

uint64_t FigDispatchAsyncSetPropertyImplementation(NSObject *a1, uint64_t a2, const void *a3, const void *a4, const void *a5)
{
  _QWORD *v10;
  _QWORD *v11;
  CFTypeRef v12;
  uint64_t v14;

  if (!a4 || !a1 || !a2 || !a3)
  {
    v14 = 4294954516;
    return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  }
  v10 = malloc_type_malloc(0x30uLL, 0xF20408A8E6B83uLL);
  if (!v10)
  {
    v14 = 4294954510;
    return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  }
  v11 = v10;
  v10[1] = CFRetain(a3);
  v11[2] = CFRetain(a4);
  if (a5)
    v12 = CFRetain(a5);
  else
    v12 = 0;
  v11[3] = a2;
  v11[4] = v12;
  dispatch_async_f(a1, v11, (dispatch_function_t)figPropertySetCallback);
  return 0;
}

void figPropertySetCallback(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  (*(void (**)(_QWORD, _QWORD, _QWORD))(a1 + 24))(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 32));
  v2 = *(const void **)(a1 + 8);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 16);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 32);
  if (v4)
    CFRelease(v4);
  free((void *)a1);
}

dispatch_block_t FigDispatchCreateDispatchSourceBlock(dispatch_block_t block)
{
  return dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, block);
}

intptr_t FigDispatchAsyncAndWaitWithTimeout_f(NSObject *a1, uint64_t a2, uint64_t a3, dispatch_time_t a4)
{
  dispatch_block_t v6;
  intptr_t v7;
  _QWORD v9[6];

  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __FigDispatchAsyncAndWaitWithTimeout_f_block_invoke;
  v9[3] = &__block_descriptor_tmp_65;
  v9[4] = a3;
  v9[5] = a2;
  v6 = dispatch_block_create(DISPATCH_BLOCK_NO_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, v9);
  dispatch_async(a1, v6);
  v7 = dispatch_block_wait(v6, a4);
  _Block_release(v6);
  return v7;
}

uint64_t FigOSTransactionCreateWithProcessName(const char *a1, const char *a2, uint64_t a3, const __CFURL *a4, uint64_t a5)
{
  time_t v10;
  time_t v11;
  const __CFString *v12;
  CFStringRef v13;
  CFStringRef v14;
  const __CFString *v15;
  uint64_t v16;
  CFTypeRef v17;
  CFStringRef theString;
  unsigned int v20;
  char *v21;
  CFTypeRef cf;
  char buffer[16];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  char v31[3];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  _BYTE v62[29];
  _OWORD v63[8];
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v21 = 0;
  cf = 0;
  memset(v63, 0, sizeof(v63));
  v61 = 0u;
  memset(v62, 0, sizeof(v62));
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v48 = 0u;
  v47 = 0u;
  v46 = 0u;
  v45 = 0u;
  v44 = 0u;
  v43 = 0u;
  v42 = 0u;
  v41 = 0u;
  v40 = 0u;
  v39 = 0u;
  v38 = 0u;
  v37 = 0u;
  v36 = 0u;
  v35 = 0u;
  v34 = 0u;
  v33 = 0u;
  v32 = 0u;
  qmemcpy(v31, "n/a", sizeof(v31));
  v10 = time(0);
  v20 = 0;
  theString = 0;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  *(_OWORD *)buffer = 0u;
  v24 = 0u;
  if (!a1)
  {
    FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v16 = 0;
    goto LABEL_26;
  }
  v11 = v10;
  if ((int)a3 >= 1 && !a5)
  {
    FigServer_CopyProcessName(a3, (CFStringRef *)&cf);
    FigCFStringGetCStringPtrMaybeUsingPreallocatedBuffer((const char *)cf, (char *)v63, 128, 0x600u);
LABEL_6:
    FigApplicationStateMonitorGetHostPIDIfAvailable(a3, (int *)&v20);
    if ((int)v20 >= 1)
    {
      FigServer_CopyProcessName(v20, &theString);
      if (theString)
        CFStringGetCString(theString, buffer, 128, 0x600u);
    }
    goto LABEL_9;
  }
  if ((int)a3 >= 1)
    goto LABEL_6;
LABEL_9:
  if (a4)
  {
    if (FigIsItOKToLogURLs())
    {
      v12 = CFURLGetString(a4);
      if (v12)
        CFStringGetCString(v12, v31, 512, 0x8000100u);
    }
    else
    {
      v13 = CFURLCopyScheme(a4);
      if (v13)
      {
        v14 = v13;
        v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@://<redacted>"), v13);
        CFStringGetCString(v15, v31, 512, 0x8000100u);
        if (v15)
          CFRelease(v15);
        CFRelease(v14);
      }
    }
  }
  if (!v20 || v20 == (_DWORD)a3)
    asprintf(&v21, "%ld %s %s %d:%s %s");
  else
    asprintf(&v21, "%ld %s %s %d->%d:%s->%s %s ", v11, a1);
  v16 = os_transaction_create();
  if (v16)
  {
    if (sFigOSTransactions != -1)
      dispatch_once(&sFigOSTransactions, &__block_literal_global_23_0);
    v17 = FigCFWeakReferenceHolderCreateWithReferencedObject(v16);
    FigSimpleMutexLock((pthread_mutex_t *)qword_1ECDA8B28);
    figPruneOSTransactionArrayWhilePerformingOperation(0);
    CFArrayAppendValue((CFMutableArrayRef)qword_1ECDA8B20, v17);
    FigSimpleMutexUnlock((pthread_mutex_t *)qword_1ECDA8B28);
    FigPerformanceMonitorUpdateOSTransactionData(v17, a1, a2, a3);
    if (v17)
      CFRelease(v17);
  }
  else
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
LABEL_26:
  free(v21);
  if (cf)
    CFRelease(cf);
  if (theString)
    CFRelease(theString);
  return v16;
}

void figPruneOSTransactionArrayWhilePerformingOperation(uint64_t a1)
{
  CFIndex Count;
  CFIndex v3;
  CFIndex v4;
  id *ValueAtIndex;
  id *v6;
  id *v7;

  Count = CFArrayGetCount((CFArrayRef)qword_1ECDA8B20);
  if (Count >= 1)
  {
    v3 = Count;
    v4 = 0;
    do
    {
      ValueAtIndex = (id *)CFArrayGetValueAtIndex((CFArrayRef)qword_1ECDA8B20, v4);
      v6 = FigCFWeakReferenceHolderCopyReferencedObject(ValueAtIndex);
      if (v6)
      {
        v7 = v6;
        if (a1)
          (*(void (**)(uint64_t, id *))(a1 + 16))(a1, v6);
        ++v4;
        os_release(v7);
      }
      else
      {
        CFArrayRemoveValueAtIndex((CFMutableArrayRef)qword_1ECDA8B20, v4);
        --v3;
      }
    }
    while (v4 < v3);
  }
}

uint64_t FigOSTransactionCreate(const char *a1, const char *a2, uint64_t a3, const __CFURL *a4)
{
  return FigOSTransactionCreateWithProcessName(a1, a2, a3, a4, 0);
}

CFMutableArrayRef FigOSTransactionCopyDescriptions(const __CFAllocator *a1)
{
  CFMutableArrayRef Mutable;
  _QWORD v4[6];

  Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  if (sFigOSTransactions != -1)
    dispatch_once(&sFigOSTransactions, &__block_literal_global_23_0);
  FigSimpleMutexLock((pthread_mutex_t *)qword_1ECDA8B28);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __FigOSTransactionCopyDescriptions_block_invoke;
  v4[3] = &__block_descriptor_tmp_9_9;
  v4[4] = a1;
  v4[5] = Mutable;
  figPruneOSTransactionArrayWhilePerformingOperation((uint64_t)v4);
  FigSimpleMutexUnlock((pthread_mutex_t *)qword_1ECDA8B28);
  return Mutable;
}

uint64_t FigDispatchQueueHolderGetTypeID()
{
  if (FigDispatchQueueHolderGetTypeID_sRegisterFigDispatchQueueHolderTypeOnce != -1)
    dispatch_once_f(&FigDispatchQueueHolderGetTypeID_sRegisterFigDispatchQueueHolderTypeOnce, 0, (dispatch_function_t)registerFigDispatchQueueHolderType);
  return sFigDispatchQueueHolderID;
}

uint64_t registerFigDispatchQueueHolderType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigDispatchQueueHolderID = result;
  return result;
}

uint64_t FigDispatchQueueHolderGetDispatchQueue(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t FigDispatchQueueHolderCreateWithDispatchQueue(uint64_t a1, NSObject *a2, uint64_t *a3)
{
  uint64_t Instance;
  uint64_t v6;
  uint64_t v8;

  if (a2)
  {
    if (a3)
    {
      if (FigDispatchQueueHolderGetTypeID_sRegisterFigDispatchQueueHolderTypeOnce != -1)
        dispatch_once_f(&FigDispatchQueueHolderGetTypeID_sRegisterFigDispatchQueueHolderTypeOnce, 0, (dispatch_function_t)registerFigDispatchQueueHolderType);
      Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        v6 = Instance;
        *(_QWORD *)(Instance + 16) = a2;
        dispatch_retain(a2);
        *a3 = v6;
        return 0;
      }
      v8 = 4294954510;
    }
    else
    {
      v8 = 4294954516;
    }
  }
  else
  {
    v8 = 4294954516;
  }
  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

_BYTE *figDispatch_shouldUseWorkloopQueuesForAssetPrioritiesOnce(_BYTE *result)
{
  *result = 0;
  return result;
}

pthread_mutex_t *__figDispatch_copyRootQueueWithPriorityAndClientPID_block_invoke()
{
  const __CFAllocator *AllocatorForPermanentAllocations;
  pthread_mutex_t *result;

  sFigDispatchQueuesForPID_0 = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], 0);
  AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  result = FigSimpleMutexCreateWithFlags(AllocatorForPermanentAllocations);
  sFigDispatchQueuesForPID_1 = (uint64_t)result;
  return result;
}

uint64_t figDispatch_createRootQueueWithMachPriority(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t global_queue;
  uint64_t v6;
  sched_param v8;
  pthread_attr_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  memset(&v9, 0, sizeof(v9));
  v8 = 0;
  if (pthread_attr_init(&v9))
    return 0;
  if (a3)
  {
    global_queue = (uint64_t)dispatch_get_global_queue(a3, 0);
  }
  else
  {
    pthread_attr_setschedpolicy(&v9, 4);
    if (pthread_attr_getschedparam(&v9, &v8) || (v8.sched_priority = a2, pthread_attr_setschedparam(&v9, &v8)))
    {
      v6 = 0;
      goto LABEL_8;
    }
    global_queue = dispatch_pthread_root_queue_create();
  }
  v6 = global_queue;
LABEL_8:
  pthread_attr_destroy(&v9);
  return v6;
}

uint64_t __figDispatch_copyRootQueueWithPriorityAndClientPID_block_invoke_2(uint64_t a1)
{
  _opaque_pthread_t *v2;
  thread_act_t v3;
  _opaque_pthread_t *v4;
  uint64_t result;
  __uint64_t v6;

  v2 = pthread_self();
  v3 = pthread_mach_thread_np(v2);
  figSetMachThreadPriority(v3, *(_DWORD *)(a1 + 32));
  v4 = pthread_self();
  v6 = 0;
  result = pthread_threadid_np(v4, &v6);
  if (!(_DWORD)result)
    return proc_pidbind();
  return result;
}

void figDispatch_rootQueueDestructor(const void *a1)
{
  id *Value;
  id *v3;
  id v4;

  FigSimpleMutexLock((pthread_mutex_t *)sFigDispatchQueuesForPID_1);
  Value = (id *)CFDictionaryGetValue((CFDictionaryRef)sFigDispatchQueuesForPID_0, a1);
  if (Value)
  {
    v3 = Value;
    v4 = FigCFWeakReferenceLoadAndRetain(Value);
    if (v4)
    {
      CFRelease(v4);
    }
    else
    {
      FigCFWeakReferenceStore(v3, 0);
      CFDictionaryRemoveValue((CFMutableDictionaryRef)sFigDispatchQueuesForPID_0, a1);
      free(v3);
    }
  }
  FigSimpleMutexUnlock((pthread_mutex_t *)sFigDispatchQueuesForPID_1);
  CFRelease(a1);
}

void __figDispatch_getRootQueueWithPriority_block_invoke(uint64_t a1)
{
  unsigned int v2;
  int v3;
  unsigned int v4;
  int v5;
  int QualityOfServiceClassForFigThreadPriority;
  int MachThreadPriorityValue;
  uint64_t v8;
  dispatch_once_t *v9;
  char __str[8];
  uint64_t v11;
  uint64_t (*v12)(uint64_t);
  void *v13;
  int v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v3 = *(_DWORD *)(a1 + 32);
  v2 = v3;
  if ((v3 - 45) >= 4)
  {
    QualityOfServiceClassForFigThreadPriority = FigGetQualityOfServiceClassForFigThreadPriority(v3);
    MachThreadPriorityValue = FigThreadGetMachThreadPriorityValue(v2);
    v8 = MachThreadPriorityValue;
    v9 = &sRootQueuesIndexedByMachPriority[2 * MachThreadPriorityValue];
    *(_QWORD *)__str = MEMORY[0x1E0C809B0];
    v11 = 0x40000000;
    v12 = __figDispatch_getSharedPerMachPriorityRootQueueWithPriority_block_invoke;
    v13 = &__block_descriptor_tmp_20_3;
    v14 = MachThreadPriorityValue;
    v15 = QualityOfServiceClassForFigThreadPriority;
    if (*v9 != -1)
      dispatch_once(v9, __str);
    sRootQueuesIndexedByFigThreadPriority[2 * *(unsigned int *)(a1 + 32) + 1] = sRootQueuesIndexedByMachPriority[2 * v8 + 1];
  }
  else
  {
    v4 = FigGetQualityOfServiceClassForFigThreadPriority(v3);
    v5 = FigThreadGetMachThreadPriorityValue(v2);
    snprintf(__str, 0x40uLL, "com.apple.coremedia.rootQueue.fP-%02d.mP-%02d", *(_DWORD *)(a1 + 32), v5);
    sRootQueuesIndexedByFigThreadPriority[2 * *(unsigned int *)(a1 + 32) + 1] = figDispatch_createRootQueueWithMachPriority((uint64_t)__str, v5, v4);
  }
}

uint64_t __figDispatch_getRootQueueWithPriority_block_invoke_2(uint64_t a1)
{
  _opaque_pthread_t *v2;
  thread_act_t v3;

  v2 = pthread_self();
  v3 = pthread_mach_thread_np(v2);
  return figSetMachThreadPriority(v3, *(_DWORD *)(a1 + 32));
}

uint64_t __figDispatch_getSharedPerMachPriorityRootQueueWithPriority_block_invoke(uint64_t a1)
{
  uint64_t result;
  char __str[64];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 0x40uLL, "com.apple.coremedia.sharedRootQueue.%02d", *(_DWORD *)(a1 + 32));
  result = figDispatch_createRootQueueWithMachPriority((uint64_t)__str, *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36));
  sRootQueuesIndexedByMachPriority[2 * *(int *)(a1 + 32) + 1] = result;
  return result;
}

uint64_t __figDispatch_getSharedPerMachPriorityRootQueueWithPriority_block_invoke_2(uint64_t a1)
{
  _opaque_pthread_t *v2;
  thread_act_t v3;

  v2 = pthread_self();
  v3 = pthread_mach_thread_np(v2);
  return figSetMachThreadPriority(v3, *(_DWORD *)(a1 + 32));
}

pthread_mutex_t *figOSTransactionsInitializer_block_invoke()
{
  const __CFAllocator *AllocatorForPermanentAllocations;
  pthread_mutex_t *result;

  qword_1ECDA8B20 = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  result = FigSimpleMutexCreateWithFlags(AllocatorForPermanentAllocations);
  qword_1ECDA8B28 = (uint64_t)result;
  return result;
}

uint64_t FigDispatchQueueHolder_Init(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  return result;
}

void FigDispatchQueueHolder_Finalize(uint64_t a1)
{
  NSObject *v2;

  v2 = *(NSObject **)(a1 + 16);
  if (v2)
  {
    dispatch_release(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

__CFString *FigDispatchQueueHolder_CopyDescription(_QWORD *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  NSObject *v4;
  const char *label;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = a1[2];
  label = dispatch_queue_get_label(v4);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigDispatchQueueHolder %p> %p (%s)"), a1, v4, label);
  return Mutable;
}

uint64_t FigProcessStateMonitorRemoteResetPurgeEvents()
{
  unint64_t v0;
  _BYTE *v1;
  _BYTE *v2;

  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  gLastPurgeEvent = 0;
  if (objc_msgSend((id)gRemotesSupportingPurge, "count"))
  {
    v0 = 0;
    do
    {
      v1 = (_BYTE *)objc_msgSend((id)gRemotesSupportingPurge, "pointerAtIndex:", v0);
      if (v1)
      {
        v2 = v1;
        CFRetain(v1);
        if (v2[24] == 1 || *((_QWORD *)v2 + 10))
          objc_msgSend((id)gRemotesSupportingPurge, "replacePointerAtIndex:withPointer:", v0, 0);
        CFRelease(v2);
      }
      ++v0;
    }
    while (v0 < objc_msgSend((id)gRemotesSupportingPurge, "count"));
  }
  objc_msgSend((id)gRemotesSupportingPurge, "compact");
  return FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
}

uint64_t FigProcessStateMonitorGetServerPurgeState(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  int v9;
  unsigned int DataPointer;
  uint64_t v11;
  unsigned int v12;
  void *v13;
  uint64_t v14;
  xpc_object_t v16;
  void *v17;
  char *dataPointerOut;

  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  v2 = gLastPurgeEvent;
  FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
  if (!a1)
    return FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
  if (gEnrollEligibleRemotesInPurge != 1)
    return 0;
  v3 = remoteFigProcessStateMonitor_EnsureInternalStateSetup();
  if ((_DWORD)v3)
    return v3;
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  if (objc_msgSend((id)gRemotesSupportingPurge, "count"))
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    while (1)
    {
      v7 = (unsigned __int8 *)objc_msgSend((id)gRemotesSupportingPurge, "pointerAtIndex:", v4);
      if (v7)
        break;
LABEL_21:
      if (++v4 >= (unint64_t)objc_msgSend((id)gRemotesSupportingPurge, "count"))
        goto LABEL_30;
    }
    v8 = v7;
    CFRetain(v7);
    v9 = v8[24];
    if (v9 == 1)
    {
      objc_msgSend((id)gRemotesSupportingPurge, "replacePointerAtIndex:withPointer:", v4, 0);
LABEL_20:
      CFRelease(v8);
      goto LABEL_21;
    }
    v17 = 0;
    dataPointerOut = 0;
    v16 = 0;
    if (v9)
    {
      v14 = 4294947859;
    }
    else
    {
      DataPointer = CMBlockBufferGetDataPointer(*((CMBlockBufferRef *)v8 + 8), 0, 0, 0, &dataPointerOut);
      if (DataPointer)
      {
LABEL_26:
        v12 = DataPointer;
        v13 = 0;
        goto LABEL_27;
      }
      if ((dataPointerOut & 0xF) == 0)
      {
        v11 = *(_QWORD *)dataPointerOut;
        if (*(uint64_t *)dataPointerOut > 0)
        {
          v13 = 0;
          v12 = 0;
LABEL_15:
          FigXPCRelease(v13);
          FigXPCRelease(v16);
          if (v12)
            v6 = v12;
          else
            v6 = v6;
          if (v11 > v5)
            v5 = v11;
          goto LABEL_20;
        }
        v12 = FigXPCCreateBasicMessage(0x646F7063u, *((_QWORD *)v8 + 5), &v17);
        v13 = v17;
        if (!v12)
        {
          FigXPCRemoteClientSendSyncMessageCreatingReply(*((_QWORD *)v8 + 2), (uint64_t)v17, &v16);
          v13 = v17;
          v11 = *(_QWORD *)dataPointerOut;
          goto LABEL_15;
        }
LABEL_27:
        v11 = 0;
        goto LABEL_15;
      }
      v14 = 4294947862;
    }
    DataPointer = FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
    goto LABEL_26;
  }
  v6 = 0;
  v5 = 0;
LABEL_30:
  if (v2 <= v5)
  {
    figProcessStateMonitor_updateLastPurgeEventIfNecessary(v5);
    v2 = v5;
  }
  objc_msgSend((id)gRemotesSupportingPurge, "compact");
  *a1 = v2;
  FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
  return v6;
}

uint64_t remoteFigProcessStateMonitor_EnsureInternalStateSetup()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v6 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __remoteFigProcessStateMonitor_EnsureInternalStateSetup_block_invoke;
  block[3] = &unk_1E28D9708;
  block[4] = &v3;
  if (remoteFigProcessStateMonitor_EnsureInternalStateSetup_gFigProcessStateMonitorRemoteSetupOnce != -1)
    dispatch_once(&remoteFigProcessStateMonitor_EnsureInternalStateSetup_gFigProcessStateMonitorRemoteSetupOnce, block);
  v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t figProcessStateMonitor_updateLastPurgeEventIfNecessary(uint64_t a1)
{
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  if (gLastPurgeEvent < a1)
    gLastPurgeEvent = a1;
  return FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
}

uint64_t FigProcessStateMonitorMayPurgeClientObjects(const void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  int v7;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v9;
  uint64_t v10;
  unsigned int v11;
  _BYTE *v12;
  const __CFArray *v13;
  CFIndex FirstIndexOfValue;
  uint64_t v15;
  NSObject *v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;
  int *v24;
  uint64_t v25;
  os_log_type_t type;
  int v27;
  int v28[2];
  int v29;
  const char *v30;
  __int16 v31;
  const void *v32;
  __int16 v33;
  const void *v34;
  _BYTE v35[128];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v2 = remoteFigProcessStateMonitor_EnsureInternalStateSetup();
  if ((_DWORD)v2)
    return v2;
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  if (objc_msgSend((id)gRemotesSupportingPurge, "count"))
  {
    v3 = 0;
    v4 = 0;
    while (1)
    {
      v5 = (unsigned __int8 *)objc_msgSend((id)gRemotesSupportingPurge, "pointerAtIndex:", v3);
      if (v5)
        break;
LABEL_32:
      if (++v3 >= (unint64_t)objc_msgSend((id)gRemotesSupportingPurge, "count", v24, v25))
        goto LABEL_41;
    }
    v6 = v5;
    CFRetain(v5);
    v7 = v6[24];
    if (v7 == 1)
    {
      objc_msgSend((id)gRemotesSupportingPurge, "replacePointerAtIndex:withPointer:", v3, 0);
      goto LABEL_30;
    }
    *(_QWORD *)v28 = 0;
    if (a1)
    {
      if (v7)
      {
        v22 = 4294947859;
      }
      else
      {
        if (dword_1ECDA84D8 >= 2)
        {
          v27 = 0;
          type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, &v27, &type);
          v9 = v27;
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
            v11 = v9;
          else
            v11 = v9 & 0xFFFFFFFE;
          if (v11)
          {
            v29 = 136315650;
            v30 = "figProcessStateMonitorRemote_mayPurge";
            v31 = 2114;
            v32 = v6;
            v33 = 2114;
            v34 = a1;
            LODWORD(v25) = 32;
            v24 = &v29;
            v12 = (_BYTE *)_os_log_send_and_compose_impl();
            LOBYTE(v9) = v27;
          }
          else
          {
            v12 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v12, v12 != v35, v9, 0, v10);
        }
        if (FigCFArrayContainsValue(*((const __CFArray **)v6 + 9), a1))
        {
          v13 = (const __CFArray *)*((_QWORD *)v6 + 9);
          FirstIndexOfValue = FigCFArrayGetFirstIndexOfValue(v13, a1);
          CFArrayRemoveValueAtIndex(v13, FirstIndexOfValue);
          v15 = FigXPCCreateBasicMessage(0x6D70636Fu, *((_QWORD *)v6 + 5), v28);
          if ((_DWORD)v15
            || (v15 = FigXPCMessageSetCFString(*(void **)v28, "ProcessStateMonitorAssertion", a1), (_DWORD)v15)
            || (v15 = FigXPCRemoteClientSendAsyncMessage(*((_QWORD *)v6 + 2), *(void **)v28), (_DWORD)v15))
          {
            v21 = v15;
            FigXPCRelease(*(xpc_object_t *)v28);
            goto LABEL_31;
          }
          v6[89] = CFArrayGetCount(*((CFArrayRef *)v6 + 9)) == 0;
          if (dword_1ECDA84D8)
          {
            v27 = 0;
            type = OS_LOG_TYPE_DEFAULT;
            v16 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, &v27, &type);
            v17 = v27;
            if (os_log_type_enabled(v16, type))
              v19 = v17;
            else
              v19 = v17 & 0xFFFFFFFE;
            if (v19)
            {
              v29 = 136315650;
              v30 = "figProcessStateMonitorRemote_mayPurge";
              v31 = 2114;
              v32 = a1;
              v33 = 2114;
              v34 = v6;
              LODWORD(v25) = 32;
              v24 = &v29;
              v20 = (_BYTE *)_os_log_send_and_compose_impl();
              LOBYTE(v17) = v27;
            }
            else
            {
              v20 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v20, v20 != v35, v17, 0, v18);
          }
          FigXPCRelease(*(xpc_object_t *)v28);
LABEL_30:
          v21 = v4;
LABEL_31:
          CFRelease(v6);
          v4 = v21;
          goto LABEL_32;
        }
        v22 = 4294947863;
      }
    }
    else
    {
      v22 = 4294947866;
    }
    v21 = FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
    FigXPCRelease(*(xpc_object_t *)v28);
    if ((_DWORD)v21)
      goto LABEL_31;
    goto LABEL_30;
  }
  v4 = 0;
LABEL_41:
  objc_msgSend((id)gRemotesSupportingPurge, "compact");
  FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
  return v4;
}

uint64_t FigProcessStateMonitorMustNotPurgeClientObjects(const void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  int v7;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v9;
  uint64_t v10;
  unsigned int v11;
  _BYTE *v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  int *v22;
  uint64_t v23;
  os_log_type_t type;
  int v25;
  int v26[2];
  int v27;
  const char *v28;
  __int16 v29;
  const void *v30;
  __int16 v31;
  const void *v32;
  _BYTE v33[128];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v2 = remoteFigProcessStateMonitor_EnsureInternalStateSetup();
  if ((_DWORD)v2)
    return v2;
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  if (objc_msgSend((id)gRemotesSupportingPurge, "count"))
  {
    v3 = 0;
    v4 = 0;
    while (1)
    {
      v5 = (unsigned __int8 *)objc_msgSend((id)gRemotesSupportingPurge, "pointerAtIndex:", v3);
      if (v5)
        break;
LABEL_31:
      if (++v3 >= (unint64_t)objc_msgSend((id)gRemotesSupportingPurge, "count", v22, v23))
        goto LABEL_39;
    }
    v6 = v5;
    CFRetain(v5);
    v7 = v6[24];
    if (v7 == 1)
    {
      objc_msgSend((id)gRemotesSupportingPurge, "replacePointerAtIndex:withPointer:", v3, 0);
      goto LABEL_29;
    }
    *(_QWORD *)v26 = 0;
    if (a1)
    {
      if (!v7)
      {
        if (dword_1ECDA84D8 >= 2)
        {
          v25 = 0;
          type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, &v25, &type);
          v9 = v25;
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
            v11 = v9;
          else
            v11 = v9 & 0xFFFFFFFE;
          if (v11)
          {
            v27 = 136315650;
            v28 = "figProcessStateMonitorRemote_mustNotPurge";
            v29 = 2114;
            v30 = v6;
            v31 = 2114;
            v32 = a1;
            LODWORD(v23) = 32;
            v22 = &v27;
            v12 = (_BYTE *)_os_log_send_and_compose_impl();
            LOBYTE(v9) = v25;
          }
          else
          {
            v12 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v12, v12 != v33, v9, 0, v10);
        }
        v13 = FigXPCCreateBasicMessage(0x6D6E706Fu, *((_QWORD *)v6 + 5), v26);
        if ((_DWORD)v13
          || (v13 = FigXPCMessageSetCFString(*(void **)v26, "ProcessStateMonitorAssertion", a1), (_DWORD)v13)
          || (v13 = FigXPCRemoteClientSendSyncMessage(*((_QWORD *)v6 + 2), *(uint64_t *)v26), (_DWORD)v13))
        {
          v19 = v13;
          FigXPCRelease(*(xpc_object_t *)v26);
          goto LABEL_30;
        }
        CFArrayAppendValue(*((CFMutableArrayRef *)v6 + 9), a1);
        v6[89] = 0;
        if (dword_1ECDA84D8)
        {
          v25 = 0;
          type = OS_LOG_TYPE_DEFAULT;
          v14 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, &v25, &type);
          v15 = v25;
          if (os_log_type_enabled(v14, type))
            v17 = v15;
          else
            v17 = v15 & 0xFFFFFFFE;
          if (v17)
          {
            v27 = 136315650;
            v28 = "figProcessStateMonitorRemote_mustNotPurge";
            v29 = 2114;
            v30 = a1;
            v31 = 2114;
            v32 = v6;
            LODWORD(v23) = 32;
            v22 = &v27;
            v18 = (_BYTE *)_os_log_send_and_compose_impl();
            LOBYTE(v15) = v25;
          }
          else
          {
            v18 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v18, v18 != v33, v15, 0, v16);
        }
        FigXPCRelease(*(xpc_object_t *)v26);
LABEL_29:
        v19 = v4;
LABEL_30:
        CFRelease(v6);
        v4 = v19;
        goto LABEL_31;
      }
      v20 = 4294947859;
    }
    else
    {
      v20 = 4294947866;
    }
    v19 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
    FigXPCRelease(*(xpc_object_t *)v26);
    if ((_DWORD)v19)
      goto LABEL_30;
    goto LABEL_29;
  }
  v4 = 0;
LABEL_39:
  objc_msgSend((id)gRemotesSupportingPurge, "compact");
  FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
  return v4;
}

uint64_t FigProcessStateMonitorEnrollEligibleConnectionsInPurge()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  const void *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  const void *v7;
  unsigned int BlockBuffer;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  _BYTE *v13;
  unsigned int v14;
  NSObject *v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  _BYTE *v19;
  int *v21;
  uint64_t v22;
  os_log_type_t type;
  os_log_type_t v24[4];
  void *v25;
  int v26;
  const char *v27;
  __int16 v28;
  uint64_t v29;
  _BYTE v30[128];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v0 = remoteFigProcessStateMonitor_EnsureInternalStateSetup();
  if ((_DWORD)v0)
    return v0;
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  gEnrollEligibleRemotesInPurge = 1;
  v1 = 0;
  if (objc_msgSend((id)gRemotesSupportingPurge, "count"))
  {
    v2 = 0;
    while (1)
    {
      v3 = (const void *)objc_msgSend((id)gRemotesSupportingPurge, "pointerAtIndex:", v2);
      if (v3)
        break;
LABEL_31:
      if (++v2 >= (unint64_t)objc_msgSend((id)gRemotesSupportingPurge, "count", v21, v22))
        goto LABEL_36;
    }
    v4 = (uint64_t)v3;
    CFRetain(v3);
    if (*(_BYTE *)(v4 + 24) == 1)
    {
      objc_msgSend((id)gRemotesSupportingPurge, "replacePointerAtIndex:withPointer:", v2, 0);
LABEL_30:
      CFRelease((CFTypeRef)v4);
      goto LABEL_31;
    }
    if (*(_BYTE *)(v4 + 88))
      goto LABEL_30;
    v25 = 0;
    v5 = FigCopyCommonMemoryPool();
    v7 = v5;
    if (!*(_BYTE *)(v4 + 88))
    {
      if (*(_BYTE *)(v4 + 24))
      {
        BlockBuffer = FigSignalErrorAt(4294947859, 0, 0, 0, 0, 0, 0);
      }
      else if ((*(_QWORD *)(v4 + 64)
              || (BlockBuffer = FigMemoryPoolCreateBlockBuffer((uint64_t)v5, 8uLL, (CMBlockBufferRef *)(v4 + 64), v6)) == 0)&& (*(_QWORD *)(v4 + 56)|| (BlockBuffer = FigXPCRemoteClientCopyMemoryOrigin(*(_QWORD *)(v4 + 16), (CFTypeRef *)(v4 + 56))) == 0))
      {
        BlockBuffer = FigXPCCreateBasicMessage(0x65697075u, *(_QWORD *)(v4 + 40), &v25);
        if (!BlockBuffer)
        {
          BlockBuffer = FigMemoryOriginSetBlockBufferInXPCMessage(*(_QWORD *)(v4 + 56), v25, "ProcessStateMonitorShmem", *(OpaqueCMBlockBuffer **)(v4 + 64));
          if (!BlockBuffer)
          {
            BlockBuffer = FigXPCRemoteClientSendSyncMessage(*(_QWORD *)(v4 + 16), (uint64_t)v25);
            if (!BlockBuffer)
            {
              *(_WORD *)(v4 + 88) = 257;
              if (dword_1ECDA84D8)
              {
                *(_DWORD *)v24 = 0;
                type = OS_LOG_TYPE_DEFAULT;
                os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, (int *)v24, &type);
                v10 = *(_DWORD *)v24;
                if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
                  v12 = v10;
                else
                  v12 = v10 & 0xFFFFFFFE;
                if (v12)
                {
                  v26 = 136315394;
                  v27 = "figProcessStateMonitorRemote_enrollInPurge";
                  v28 = 2114;
                  v29 = v4;
                  LODWORD(v22) = 22;
                  v21 = &v26;
                  v13 = (_BYTE *)_os_log_send_and_compose_impl();
                  LOBYTE(v10) = v24[0];
                }
                else
                {
                  v13 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v13, v13 != v30, v10, 0, v11);
              }
              goto LABEL_25;
            }
          }
        }
      }
      v14 = BlockBuffer;
      if (!v7)
      {
LABEL_27:
        FigXPCRelease(v25);
        if (v14)
          v1 = v14;
        else
          v1 = v1;
        goto LABEL_30;
      }
LABEL_26:
      CFRelease(v7);
      goto LABEL_27;
    }
LABEL_25:
    v14 = 0;
    if (!v7)
      goto LABEL_27;
    goto LABEL_26;
  }
LABEL_36:
  objc_msgSend((id)gRemotesSupportingPurge, "compact");
  if (dword_1ECDA84D8)
  {
    LODWORD(v25) = 0;
    v24[0] = OS_LOG_TYPE_DEFAULT;
    v15 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, (int *)&v25, v24);
    v16 = v25;
    if (os_log_type_enabled(v15, v24[0]))
      v18 = v16;
    else
      v18 = v16 & 0xFFFFFFFE;
    if (v18)
    {
      v26 = 136315394;
      v27 = "FigProcessStateMonitorEnrollEligibleConnectionsInPurge";
      v28 = 2112;
      v29 = gRemotesSupportingPurge;
      v19 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v16) = (_BYTE)v25;
    }
    else
    {
      v19 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v19, v19 != v30, v16, 0, v17);
  }
  FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
  return v1;
}

uint64_t FigProcessStateMonitorCopyRemoteStateMonitor(void *a1, int a2, int a3, uint64_t *a4)
{
  unint64_t v8;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  const char *v13;
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 *v17;
  const void *uint64;
  NSObject *v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  _BYTE *v23;
  NSObject *v24;
  unsigned int v25;
  uint64_t v26;
  unsigned int v27;
  _BYTE *v28;
  NSObject *v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  _BYTE *v33;
  const __CFAllocator *v34;
  CFMutableDictionaryRef Mutable;
  uint64_t v36;
  CFTypeRef v37;
  uint64_t Instance;
  CFTypeRef v39;
  xpc_object_t v40;
  CFMutableSetRef v41;
  uint64_t ServerPID;
  uint64_t started;
  uint64_t v44;
  NSObject *v45;
  int v46;
  uint64_t v47;
  unsigned int v48;
  _BYTE *v49;
  CFMutableArrayRef v50;
  uint64_t v51;
  NSObject *v52;
  unsigned int v53;
  uint64_t v54;
  unsigned int v55;
  uint64_t v56;
  _BYTE *v57;
  xpc_object_t xdict;
  os_log_type_t type[8];
  CFTypeRef cf;
  os_log_type_t v62;
  int v63;
  int v64;
  const char *v65;
  __int16 v66;
  _BYTE v67[14];
  _BYTE v68[128];
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  v8 = 0x1ECDA8000uLL;
  if ((in_audio_mx_server_process() & 1) != 0)
  {
    v44 = 0;
    goto LABEL_88;
  }
  if (!a2 || !a4)
  {
    v15 = FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
LABEL_98:
    v44 = v15;
    goto LABEL_88;
  }
  if (dword_1ECDA84D8 >= 2)
  {
    LODWORD(cf) = 0;
    type[0] = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, (int *)&cf, type);
    v10 = cf;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0]))
      v12 = v10;
    else
      v12 = v10 & 0xFFFFFFFE;
    if (v12)
    {
      v13 = "is";
      v65 = "FigProcessStateMonitorCopyRemoteStateMonitor";
      v64 = 136315650;
      if (!a3)
        v13 = "is not";
      v66 = 1024;
      *(_DWORD *)v67 = a2;
      *(_WORD *)&v67[4] = 2080;
      *(_QWORD *)&v67[6] = v13;
      v14 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v10) = (_BYTE)cf;
    }
    else
    {
      v14 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v14, v14 != v68, v10, 0, v11);
  }
  v15 = remoteFigProcessStateMonitor_EnsureInternalStateSetup();
  if ((_DWORD)v15)
    goto LABEL_98;
  v15 = FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  if ((_DWORD)v15)
    goto LABEL_98;
  v16 = a2;
  v17 = (unsigned __int8 *)FigCFWeakReferenceTableCopyValue(gStateMonitorPerPID, (void *)a2);
  if (v17)
  {
    uint64 = v17;
    if (v17[89] != a3)
    {
      v17[89] = 1;
      objc_msgSend((id)gRemotesSupportingPurge, "addPointer:", v17);
    }
    if (dword_1ECDA84D8 >= 2)
    {
      LODWORD(cf) = 0;
      type[0] = OS_LOG_TYPE_DEFAULT;
      v19 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, (int *)&cf, type);
      v20 = cf;
      if (os_log_type_enabled(v19, type[0]))
        v22 = v20;
      else
        v22 = v20 & 0xFFFFFFFE;
      if (v22)
      {
        v64 = 136315650;
        v65 = "FigProcessStateMonitorCopyRemoteStateMonitor";
        v66 = 2114;
        *(_QWORD *)v67 = uint64;
        *(_WORD *)&v67[8] = 1024;
        *(_DWORD *)&v67[10] = a2;
        v23 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v20) = (_BYTE)cf;
      }
      else
      {
        v23 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v23, v23 != v68, v20, 0, v21);
    }
LABEL_82:
    if (!remoteFigProcessStateMonitor_EnsureInternalStateSetup()
      && gEnrollEligibleRemotesInPurge
      && !FigServer_IsServerProcess())
    {
      FigProcessStateMonitorEnrollEligibleConnectionsInPurge();
    }
    v44 = 0;
    *a4 = (uint64_t)uint64;
    goto LABEL_87;
  }
  if (!a1)
  {
    v44 = FigSignalErrorAt(4294947864, 0, 0, 0, 0, 0, 0);
LABEL_87:
    FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
    goto LABEL_88;
  }
  if (dword_1ECDA84D8 <= 1)
  {
    *(_QWORD *)type = 0;
    cf = 0;
    xdict = 0;
  }
  else
  {
    LODWORD(cf) = 0;
    type[0] = OS_LOG_TYPE_DEFAULT;
    v24 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, (int *)&cf, type);
    v25 = cf;
    if (os_log_type_enabled(v24, type[0]))
      v27 = v25;
    else
      v27 = v25 & 0xFFFFFFFE;
    if (v27)
    {
      v64 = 136315650;
      v65 = "FigProcessStateMonitorCopyRemoteStateMonitor";
      v66 = 2048;
      *(_QWORD *)v67 = a1;
      *(_WORD *)&v67[8] = 1024;
      *(_DWORD *)&v67[10] = a2;
      v28 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v25) = (_BYTE)cf;
    }
    else
    {
      v28 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v28, v28 != v68, v25, 0, v26);
    *(_QWORD *)type = 0;
    cf = 0;
    xdict = 0;
    if (dword_1ECDA84D8 >= 2)
    {
      v63 = 0;
      v62 = OS_LOG_TYPE_DEFAULT;
      v29 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, &v63, &v62);
      v30 = v63;
      if (os_log_type_enabled(v29, v62))
        v32 = v30;
      else
        v32 = v30 & 0xFFFFFFFE;
      if (v32)
      {
        v64 = 136315650;
        v65 = "figProcessStateMonitorRemote_establishInitialConnection";
        v66 = 2048;
        *(_QWORD *)v67 = a1;
        *(_WORD *)&v67[8] = 1024;
        *(_DWORD *)&v67[10] = a2;
        v33 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v30) = v63;
      }
      else
      {
        v33 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v33, v33 != v68, v30, 0, v31);
    }
  }
  v34 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetValue(Mutable, CFSTR("xpcRemoteClientOption_DoNotMonitorConnection"), (const void *)*MEMORY[0x1E0C9AE50]);
  v36 = FigXPCRemoteClientCreateWithXPCEndpoint((uint64_t)"monitorRemote", (uint64_t)a1, (uint64_t)&figProcessStateMonitorRemote_establishInitialConnection_sFigProcessStateMonitorRemoteClientCallbacks, (uint64_t)Mutable, (uint64_t)&cf);
  if ((_DWORD)v36
    || (v36 = FigXPCCreateBasicMessage(0x63726574u, 0, type), (_DWORD)v36)
    || (v36 = FigXPCRemoteClientSendSyncMessageCreatingReply((uint64_t)cf, *(uint64_t *)type, &xdict), (_DWORD)v36))
  {
    v44 = v36;
LABEL_103:
    uint64 = 0;
    goto LABEL_71;
  }
  uint64 = (const void *)xpc_dictionary_get_uint64(xdict, ".objectID");
  if (!uint64)
  {
    v44 = FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
    goto LABEL_71;
  }
  v37 = cf;
  if (figProcessStateMonitorRemote_GetTypeID_sRegisterFigProcessStateMonitorRemoteTypeOnce != -1)
    dispatch_once(&figProcessStateMonitorRemote_GetTypeID_sRegisterFigProcessStateMonitorRemoteTypeOnce, &__block_literal_global_52);
  Instance = _CFRuntimeCreateInstance();
  if (v37)
    v39 = CFRetain(v37);
  else
    v39 = 0;
  *(_QWORD *)(Instance + 16) = v39;
  v40 = FigXPCRetain(a1);
  *(_BYTE *)(Instance + 24) = 0;
  *(_QWORD *)(Instance + 32) = v40;
  *(_QWORD *)(Instance + 40) = uint64;
  *(_QWORD *)(Instance + 80) = 0;
  *(_BYTE *)(Instance + 88) = 0;
  v41 = CFSetCreateMutable(v34, 0, 0);
  *(_QWORD *)(Instance + 96) = v41;
  if (!v41)
  {
    v44 = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
    CFRelease((CFTypeRef)Instance);
    uint64 = 0;
    if ((_DWORD)v44)
    {
      Instance = 0;
      v8 = 0x1ECDA8000;
      goto LABEL_72;
    }
    Instance = 0;
    goto LABEL_68;
  }
  *(_BYTE *)(Instance + 104) = 0;
  ServerPID = FigXPCRemoteClientGetServerPID((uint64_t)v37, (_DWORD *)(Instance + 48));
  if ((_DWORD)ServerPID
    || (ServerPID = FigXPCRemoteClientAssociateObject((uint64_t)v37, Instance, uint64), (_DWORD)ServerPID))
  {
    v44 = ServerPID;
    v8 = 0x1ECDA8000;
LABEL_102:
    CFRelease((CFTypeRef)Instance);
    goto LABEL_103;
  }
  if (FigServer_IsServerProcess())
    started = FigStartMonitoringMediaServicesProcessDeathWithCallback((void *)Instance, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))figProcessStateMonitorRemote_propagateMediaServicesDeathNotificationCallback);
  else
    started = FigStartMonitoringMediaServicesProcessDeath((void *)Instance);
  v44 = started;
  v8 = 0x1ECDA8000uLL;
  if ((_DWORD)started)
    goto LABEL_102;
  if (dword_1ECDA84D8)
  {
    v63 = 0;
    v62 = OS_LOG_TYPE_DEFAULT;
    v45 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, &v63, &v62);
    v46 = v63;
    if (os_log_type_enabled(v45, v62))
      v48 = v46;
    else
      v48 = v46 & 0xFFFFFFFE;
    if (v48)
    {
      v64 = 136315394;
      v65 = "figProcessStateMonitor_createRemoteFromObjectID";
      v66 = 2114;
      *(_QWORD *)v67 = Instance;
      v49 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v46) = v63;
    }
    else
    {
      v49 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v49, v49 != v68, v46, 0, v47);
LABEL_68:
    v8 = 0x1ECDA8000uLL;
  }
  v50 = CFArrayCreateMutable(v34, 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)(Instance + 72) = v50;
  if (!v50)
  {
    v44 = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
    uint64 = 0;
    goto LABEL_72;
  }
  v44 = 0;
  uint64 = (const void *)Instance;
LABEL_71:
  Instance = 0;
LABEL_72:
  FigXPCRelease(*(xpc_object_t *)type);
  FigXPCRelease(xdict);
  if (cf)
    CFRelease(cf);
  if (Instance)
    CFRelease((CFTypeRef)Instance);
  if (Mutable)
    CFRelease(Mutable);
  if (!(_DWORD)v44)
  {
    v51 = FigCFWeakReferenceTableAddValueAssociatedWithKey(gStateMonitorPerPID, (uint64_t)uint64, v16);
    if (!(_DWORD)v51)
    {
      if (a3)
        objc_msgSend((id)gRemotesSupportingPurge, "addPointer:", uint64);
      goto LABEL_82;
    }
    v44 = v51;
  }
  FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
  if (uint64)
    CFRelease(uint64);
LABEL_88:
  if (*(_DWORD *)(v8 + 1240))
  {
    LODWORD(cf) = 0;
    type[0] = OS_LOG_TYPE_DEFAULT;
    v52 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, (int *)&cf, type);
    v53 = cf;
    if (os_log_type_enabled(v52, type[0]))
      v55 = v53;
    else
      v55 = v53 & 0xFFFFFFFE;
    if (v55)
    {
      v56 = *a4;
      v64 = 136315650;
      v65 = "FigProcessStateMonitorCopyRemoteStateMonitor";
      v66 = 2114;
      *(_QWORD *)v67 = v56;
      *(_WORD *)&v67[8] = 1024;
      *(_DWORD *)&v67[10] = v44;
      v57 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v53) = (_BYTE)cf;
    }
    else
    {
      v57 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v57, v57 != v68, v53, 0, v54);
  }
  return v44;
}

uint64_t FigProcessStateMonitorRemoteAssociateObject(uint64_t a1, const void *a2)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v5;
  uint64_t v6;
  unsigned int v7;
  char *v8;
  os_log_type_t type;
  int v11[2];
  const char *v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  const void *v16;
  char v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
    return FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  if (*(const void **)(a1 + 40) != a2)
  {
    *(_BYTE *)(a1 + 104) = 1;
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 96), a2);
    if (dword_1ECDA84D8 >= 2)
    {
      v11[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, v11, &type);
      v5 = v11[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v7 = v5;
      else
        v7 = v5 & 0xFFFFFFFE;
      if (v7)
      {
        v11[1] = 136315650;
        v12 = "FigProcessStateMonitorRemoteAssociateObject";
        v13 = 2114;
        v14 = a1;
        v15 = 2048;
        v16 = a2;
        v8 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v5) = v11[0];
      }
      else
      {
        v8 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v8, v8 != &v17, v5, 0, v6);
    }
  }
  FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
  return 0;
}

uint64_t FigProcessStateMonitorRemoteDisassociateObject(uint64_t a1, const void *a2)
{
  const __CFSet *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v13;
  uint64_t v14;
  unsigned int v15;
  char *v16;
  os_log_type_t type;
  int v19[2];
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  const void *v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
    return FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  if (*(const void **)(a1 + 40) != a2)
  {
    v4 = *(const __CFSet **)(a1 + 96);
    if (!v4)
    {
      CFGetRetainCount((CFTypeRef)a1);
      FigUserCrashWithMessage("monitor->associatedObjects == NULL! Monitor = %p; RC = %zu; serverObjectID = %llu; targetObjectID = %llu",
        v5,
        v6,
        v7,
        v8,
        v9,
        v10,
        v11,
        a1);
    }
    if (CFSetContainsValue(v4, a2))
    {
      CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 96), a2);
      if (dword_1ECDA84D8 >= 2)
      {
        v19[0] = 0;
        type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, v19, &type);
        v13 = v19[0];
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
          v15 = v13;
        else
          v15 = v13 & 0xFFFFFFFE;
        if (v15)
        {
          v19[1] = 136315650;
          v20 = "FigProcessStateMonitorRemoteDisassociateObject";
          v21 = 2114;
          v22 = a1;
          v23 = 2048;
          v24 = a2;
          v16 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v13) = v19[0];
        }
        else
        {
          v16 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v16, v16 != &v25, v13, 0, v14);
      }
    }
  }
  return FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
}

void figProcessStateMonitorRemote_deadConnectionCallback(uint64_t a1)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v3;
  uint64_t v4;
  unsigned int v5;
  char *v6;
  os_log_type_t type;
  int v8[2];
  const char *v9;
  __int16 v10;
  uint64_t v11;
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(a1 + 24) = 1;
  if (dword_1ECDA84D8)
  {
    v8[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, v8, &type);
    v3 = v8[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v5 = v3;
    else
      v5 = v3 & 0xFFFFFFFE;
    if (v5)
    {
      v8[1] = 136315394;
      v9 = "figProcessStateMonitorRemote_deadConnectionCallback";
      v10 = 2114;
      v11 = a1;
      v6 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v3) = v8[0];
    }
    else
    {
      v6 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v6, v6 != &v12, v3, 0, v4);
  }
}

void figProcessStateMonitorRemote_serverPurgeCallback(uint64_t a1, uint64_t a2)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  const void *v8;
  _BYTE *v9;
  const void *uint64;
  const void *v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  _BYTE *v16;
  char *dataPointerOut;
  os_log_type_t v18;
  int v19;
  os_log_type_t type[8];
  CFTypeRef cf;
  int v22;
  const char *v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  const void *v27;
  __int16 v28;
  uint64_t v29;
  _BYTE v30[128];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  dataPointerOut = 0;
  if (CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(a1 + 64), 0, 0, 0, &dataPointerOut))
    return;
  if ((dataPointerOut & 0xF) != 0)
  {
    FigSignalErrorAt(4294947862, 0, 0, 0, 0, 0, 0);
    return;
  }
  if (dword_1ECDA84D8)
  {
    LODWORD(cf) = 0;
    type[0] = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, (int *)&cf, type);
    v5 = cf;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type[0]))
      v7 = v5;
    else
      v7 = v5 & 0xFFFFFFFE;
    if (v7)
    {
      v8 = *(const void **)dataPointerOut;
      v22 = 136315906;
      v23 = "figProcessStateMonitorRemote_serverPurgeCallback";
      v24 = 2114;
      v25 = a1;
      v26 = 2048;
      v27 = v8;
      v28 = 2048;
      v29 = a2;
      v9 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v5) = (_BYTE)cf;
    }
    else
    {
      v9 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v9, v9 != v30, v5, 0, v6);
  }
  *(_QWORD *)(a1 + 80) = a2;
  *(_BYTE *)(a1 + 88) = 0;
  figProcessStateMonitor_updateLastPurgeEventIfNecessary(a2);
  *(_QWORD *)type = 0;
  cf = 0;
  if (!FigXPCCreateBasicMessage(0x63726574u, 0, &cf)
    && !FigXPCRemoteClientSendSyncMessageCreatingReply(*(_QWORD *)(a1 + 16), (uint64_t)cf, (xpc_object_t *)type))
  {
    uint64 = (const void *)xpc_dictionary_get_uint64(*(xpc_object_t *)type, ".objectID");
    if (uint64)
    {
      v11 = *(const void **)(a1 + 40);
      *(_QWORD *)(a1 + 40) = uint64;
      if (!FigXPCRemoteClientAssociateObject(*(_QWORD *)(a1 + 16), a1, uint64)
        && !FigXPCRemoteClientDisassociateObject(*(_QWORD *)(a1 + 16), v11))
      {
        FigProcessStateMonitorEnrollEligibleConnectionsInPurge();
      }
      goto LABEL_17;
    }
    FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
  }
  v11 = 0;
LABEL_17:
  if (dword_1ECDA84D8)
  {
    v19 = 0;
    v18 = OS_LOG_TYPE_DEFAULT;
    v12 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, &v19, &v18);
    v13 = v19;
    if (os_log_type_enabled(v12, v18))
      v15 = v13;
    else
      v15 = v13 & 0xFFFFFFFE;
    if (v15)
    {
      v22 = 136315650;
      v23 = "figProcessStateMonitorRemote_refreshObjectAfterPurge";
      v24 = 2112;
      v25 = a1;
      v26 = 2048;
      v27 = v11;
      v16 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v13) = v19;
    }
    else
    {
      v16 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v16, v16 != v30, v13, 0, v14);
  }
  if (cf)
    CFRelease(cf);
  if (*(_QWORD *)type)
    CFRelease(*(CFTypeRef *)type);
}

uint64_t figProcessStateMonitorRemote_propagateMediaServicesDeathNotificationCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v8;
  uint64_t v9;
  unsigned int v10;
  char *v11;
  os_log_type_t type;
  int v14[2];
  const char *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  FigReentrantMutexLock((pthread_mutex_t *)gStateMonitorMutex);
  FigStopMonitoringMediaServicesProcessDeath((const void *)a2);
  if (!*(_BYTE *)(a2 + 104) || CFSetGetCount(*(CFSetRef *)(a2 + 96)) >= 1)
  {
    if (dword_1ECDA84D8 >= 2)
    {
      v14[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, v14, &type);
      v8 = v14[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v10 = v8;
      else
        v10 = v8 & 0xFFFFFFFE;
      if (v10)
      {
        v14[1] = 136315650;
        v15 = "figProcessStateMonitorRemote_propagateMediaServicesDeathNotificationCallback";
        v16 = 2112;
        v17 = a2;
        v18 = 2112;
        v19 = a5;
        v11 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v8) = v14[0];
      }
      else
      {
        v11 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v11, v11 != &v20, v8, 0, v9);
    }
    FigProcessStateMonitorInformRemotesOfIndirectDependencyDeath(a5);
  }
  return FigReentrantMutexUnlock((pthread_mutex_t *)gStateMonitorMutex);
}

double figProcessStateMonitorRemote_Init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void figProcessStateMonitorRemote_Finalize(uint64_t a1)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v3;
  uint64_t v4;
  unsigned int v5;
  char *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  os_log_type_t type;
  int v13;
  void *v14;
  int v15;
  const char *v16;
  __int16 v17;
  uint64_t v18;
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  if (dword_1ECDA84D8)
  {
    v13 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1ECDA84D0, 1, &v13, &type);
    v3 = v13;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v5 = v3;
    else
      v5 = v3 & 0xFFFFFFFE;
    if (v5)
    {
      v15 = 136315394;
      v16 = "figProcessStateMonitorRemote_Finalize";
      v17 = 2114;
      v18 = a1;
      v6 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v3) = v13;
    }
    else
    {
      v6 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1ECDA84D0, 1u, 1, v6, v6 != &v19, v3, 0, v4);
  }
  FigStopMonitoringMediaServicesProcessDeath((const void *)a1);
  FigXPCRemoteClientDisassociateObject(*(_QWORD *)(a1 + 16), *(const void **)(a1 + 40));
  if (!*(_BYTE *)(a1 + 24) && !FigXPCCreateBasicMessage(0x64697370u, *(_QWORD *)(a1 + 40), &v14))
    FigXPCRemoteClientSendAsyncMessage(*(_QWORD *)(a1 + 16), v14);
  v7 = *(const void **)(a1 + 16);
  if (v7)
    CFRelease(v7);
  FigXPCRelease(*(xpc_object_t *)(a1 + 32));
  v8 = *(const void **)(a1 + 72);
  if (v8)
    CFRelease(v8);
  v9 = *(const void **)(a1 + 56);
  if (v9)
    CFRelease(v9);
  v10 = *(const void **)(a1 + 64);
  if (v10)
    CFRelease(v10);
  v11 = *(const void **)(a1 + 96);
  if (v11)
    CFRelease(v11);
  FigXPCRelease(v14);
}

__CFString *figProcessStateMonitorRemote_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  __CFString *v3;
  const char *v4;
  const char *v5;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = Mutable;
  v4 = "YES";
  if (*(_BYTE *)(a1 + 24))
    v5 = "YES";
  else
    v5 = "NO";
  if (!*(_BYTE *)(a1 + 88))
    v4 = "NO";
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigProcessStateMonitorRemoteRef %p %@ %d OID: %016llx, serverDied: %s, enrolledInPurge: %s, lastPurgeID: %lld>"), a1, *(_QWORD *)(a1 + 16), *(unsigned int *)(a1 + 48), *(_QWORD *)(a1 + 40), v5, v4, *(_QWORD *)(a1 + 80));
  return v3;
}

uint64_t FigEndpointManagerGetClassID()
{
  if (FigEndpointManagerGetClassID_sRegisterFigEndpointManagerBaseTypeOnce != -1)
    dispatch_once_f(&FigEndpointManagerGetClassID_sRegisterFigEndpointManagerBaseTypeOnce, &FigEndpointManagerGetClassID_sFigEndpointManagerClassID, (dispatch_function_t)manager_getClassID);
  return FigEndpointManagerGetClassID_sFigEndpointManagerClassID;
}

uint64_t manager_getClassID(_QWORD *a1)
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&manager_getClassID_sFigEndpointManagerClassDesc, ClassID, 1, a1);
}

uint64_t FigEndpointManagerGetTypeID()
{
  if (FigEndpointManagerGetClassID_sRegisterFigEndpointManagerBaseTypeOnce != -1)
    dispatch_once_f(&FigEndpointManagerGetClassID_sRegisterFigEndpointManagerBaseTypeOnce, &FigEndpointManagerGetClassID_sFigEndpointManagerClassID, (dispatch_function_t)manager_getClassID);
  return CMBaseClassGetCFTypeID((_QWORD *)FigEndpointManagerGetClassID_sFigEndpointManagerClassID);
}

uint64_t FigEndpointManagerGetSupportedFeatures(CFTypeRef cf1, int a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t v7;
  int v8;
  _BOOL4 v9;

  result = 4294950586;
  if (cf1 && a3)
  {
    if (CFEqual(cf1, CFSTR("AirPlay")))
    {
      result = 0;
      v7 = 63;
      if (!a2)
        v7 = 31;
    }
    else if (CFEqual(cf1, CFSTR("CarPlay")) || CFEqual(cf1, CFSTR("Nero/Stevenote")))
    {
      result = 0;
      v7 = 3;
    }
    else
    {
      v8 = CFEqual(cf1, CFSTR("SidePlay"));
      v9 = v8 != 0;
      if (v8)
        result = 0;
      else
        result = 4294950583;
      v7 = 8 * v9;
    }
    *a3 = v7;
  }
  return result;
}

uint64_t FigEndpointManagerGetSupportedDiscoveryFeatures(CFTypeRef cf1, uint64_t *a2)
{
  uint64_t result;
  int v5;
  BOOL v6;
  uint64_t v7;

  result = 4294950586;
  if (cf1 && a2)
  {
    v5 = CFEqual(cf1, CFSTR("AirPlay"));
    result = 0;
    v6 = v5 == 0;
    v7 = 7;
    if (v6)
      v7 = 5;
    *a2 = v7;
  }
  return result;
}

CFStringRef manager_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigEndpointManager %p]"), a1);
}

uint64_t NeroTransportConnectionGetClassID()
{
  if (NeroTransportConnectionGetClassID_sRegisterFigTransportConnectionBaseTypeOnce != -1)
    dispatch_once(&NeroTransportConnectionGetClassID_sRegisterFigTransportConnectionBaseTypeOnce, &__block_literal_global_53);
  return NeroTransportConnectionGetClassID_sFigTransportConnectionClassID;
}

CFStringRef FigTransportConnectionBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigTransportConnection %p]"), a1);
}

uint64_t NeroTransportConnectionGetTypeID()
{
  if (NeroTransportConnectionGetClassID_sRegisterFigTransportConnectionBaseTypeOnce != -1)
    dispatch_once(&NeroTransportConnectionGetClassID_sRegisterFigTransportConnectionBaseTypeOnce, &__block_literal_global_53);
  return CMBaseClassGetCFTypeID((_QWORD *)NeroTransportConnectionGetClassID_sFigTransportConnectionClassID);
}

uint64_t CMSceneFormatDescriptionCreateFromBigEndianSceneDescriptionData(CFAllocatorRef alloc, unsigned int *a2, unint64_t a3, int a4, CMFormatDescriptionRef *formatDescriptionOut)
{
  CMFormatDescriptionRef *v5;
  signed int v6;
  unsigned int v9;
  unint64_t v10;
  __CFDictionary *Mutable;
  unsigned int *v12;
  const CFDictionaryKeyCallBacks *v13;
  const CFDictionaryValueCallBacks *v14;
  unsigned int v15;
  unsigned int v16;
  signed int v17;
  uint64_t v18;
  CFDictionaryRef v20;
  const __CFDictionary *v21;
  uint64_t v22;
  CFStringRef v24;
  CFDataRef v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  CFMutableDictionaryRef theDict;
  UInt8 bytes[4];

  if (!a2)
  {
    v27 = 4294954584;
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  if (a3 <= 0xF || (v5 = formatDescriptionOut) == 0)
  {
    v27 = 4294954584;
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  v6 = bswap32(*a2);
  if (v6 < 0x10 || v6 > a3)
  {
    v27 = 4294954582;
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  v9 = a2[1];
  v10 = v6 - 16;
  theDict = 0;
  if (v10 < 8)
  {
    v21 = 0;
    goto LABEL_34;
  }
  v28 = v9;
  Mutable = 0;
  v12 = a2 + 4;
  v13 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v14 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  do
  {
    v16 = *v12;
    v15 = v12[1];
    *(_DWORD *)bytes = v15;
    v17 = bswap32(v16);
    v18 = v17;
    if (v17 < 8 || v10 < v17)
    {
      v24 = 0;
      v25 = 0;
      v26 = 4294954582;
      goto LABEL_40;
    }
    if (v15 != 1701147238)
    {
      v24 = CFStringCreateWithBytes(alloc, bytes, 4, 0, 0);
      if (!v24)
      {
        v25 = 0;
LABEL_39:
        v26 = 4294954583;
LABEL_40:
        v5 = formatDescriptionOut;
        v9 = v28;
        goto LABEL_41;
      }
      v25 = CFDataCreate(alloc, (const UInt8 *)v12 + 8, v18 - 8);
      if (!v25)
        goto LABEL_39;
      Mutable = theDict;
      if (!theDict)
      {
        Mutable = CFDictionaryCreateMutable(alloc, 0, v13, v14);
        theDict = Mutable;
        if (!Mutable)
          goto LABEL_39;
      }
      CFDictionarySetValue(Mutable, v24, v25);
      CFRelease(v25);
      CFRelease(v24);
    }
    v12 = (unsigned int *)((char *)v12 + v18);
    v10 -= v18;
  }
  while (v10 > 7);
  if (!Mutable)
  {
    v21 = 0;
    v22 = 0;
    v24 = 0;
    v25 = 0;
    v5 = formatDescriptionOut;
    v9 = v28;
    goto LABEL_27;
  }
  v20 = CFDictionaryCreate(alloc, (const void **)&kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms, (const void **)&theDict, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v24 = 0;
  v9 = v28;
  if (v20)
  {
    v21 = v20;
    v22 = 0;
    v25 = 0;
    v5 = formatDescriptionOut;
    goto LABEL_27;
  }
  v26 = 4294954583;
  v25 = 0;
  v5 = formatDescriptionOut;
LABEL_41:
  v22 = FigSignalErrorAt(v26, 0, 0, 0, 0, 0, 0);
  v21 = 0;
LABEL_27:
  if (theDict)
    CFRelease(theDict);
  if (v25)
    CFRelease(v25);
  if (v24)
    CFRelease(v24);
  if (!(_DWORD)v22)
LABEL_34:
    v22 = CMFormatDescriptionCreate(alloc, 0x7363656Eu, bswap32(v9), v21, v5);
  if (v21)
    CFRelease(v21);
  return v22;
}

uint64_t CMSceneFormatDescriptionCreateFromBigEndianSceneDescriptionBlockBuffer(const __CFAllocator *a1, CMBlockBufferRef theBuffer, uint64_t a3, CMFormatDescriptionRef *a4)
{
  OpaqueCMBlockBuffer *v5;
  size_t DataLength;
  uint64_t DataPointer;
  int v9;
  uint64_t v10;
  int v12[2];
  CMBlockBufferRef blockBufferOut;

  *(_QWORD *)v12 = 0;
  blockBufferOut = 0;
  if (theBuffer && a4)
  {
    v5 = theBuffer;
    DataLength = CMBlockBufferGetDataLength(theBuffer);
    if (!CMBlockBufferIsRangeContiguous(v5, 0, 0))
    {
      DataPointer = CMBlockBufferCreateContiguous(a1, v5, a1, 0, 0, 0, 0, &blockBufferOut);
      if ((_DWORD)DataPointer)
        goto LABEL_8;
      v5 = blockBufferOut;
    }
    DataPointer = CMBlockBufferGetDataPointer(v5, 0, 0, 0, (char **)v12);
    if (!(_DWORD)DataPointer)
      DataPointer = CMSceneFormatDescriptionCreateFromBigEndianSceneDescriptionData(a1, *(unsigned int **)v12, DataLength, v9, a4);
  }
  else
  {
    DataPointer = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
LABEL_8:
  v10 = DataPointer;
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v10;
}

uint64_t CMSceneFormatDescriptionCopyAsBigEndianSceneDescriptionBlockBuffer(const __CFAllocator *a1, CFTypeRef cf, uint64_t a3, CMBlockBufferRef *a4)
{
  CFTypeID v7;
  const __CFDictionary *Extensions;
  const __CFDictionary *Value;
  uint64_t v10;
  size_t DataLength;
  size_t v12;
  uint64_t DataPointer;
  uint64_t v14;
  uint64_t v16;
  CMBlockBufferRef destinationBuffer;
  unint64_t sourceBytes;
  unint64_t v19;
  _OWORD context[3];
  uint64_t v21;
  CMBlockBufferRef blockBufferOut;

  sourceBytes = 0;
  v19 = 0;
  destinationBuffer = 0;
  if (!cf)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (!a4)
  {
    v16 = 4294954584;
    goto LABEL_25;
  }
  v7 = CFGetTypeID(cf);
  if (v7 != CMFormatDescriptionGetTypeID() || CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)cf) != 1935893870)
  {
    v16 = 4294954581;
LABEL_25:
    v14 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    goto LABEL_26;
  }
  Extensions = CMFormatDescriptionGetExtensions((CMFormatDescriptionRef)cf);
  if (!Extensions)
  {
    Value = 0;
    v12 = 0;
    goto LABEL_13;
  }
  blockBufferOut = 0;
  Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("SampleDescriptionExtensionAtoms"));
  if (Value)
  {
    v21 = 0;
    memset(context, 0, sizeof(context));
    v10 = CMBlockBufferCreateEmpty(a1, 0, 0, &blockBufferOut);
    if (!(_DWORD)v10)
    {
      v10 = FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)context);
      if (!(_DWORD)v10)
      {
        CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)sceneBridgeAppendExtensionsFunc, context);
        Value = blockBufferOut;
        goto LABEL_10;
      }
    }
    v14 = v10;
    if (blockBufferOut)
      CFRelease(blockBufferOut);
LABEL_26:
    Value = 0;
    goto LABEL_31;
  }
LABEL_10:
  DataLength = CMBlockBufferGetDataLength(Value);
  if (DataLength >= 0x7FFFFFF0)
  {
    DataPointer = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
LABEL_30:
    v14 = DataPointer;
LABEL_31:
    if (destinationBuffer)
      CFRelease(destinationBuffer);
    goto LABEL_19;
  }
  v12 = DataLength;
LABEL_13:
  sourceBytes = _byteswap_uint64(__PAIR64__((int)v12 + 16, CMFormatDescriptionGetMediaSubType((CMFormatDescriptionRef)cf)));
  v19 = 0xFFFF000000000000;
  DataPointer = CMBlockBufferCreateWithMemoryBlock(a1, 0, (v12 + 16), a1, 0, 0, (v12 + 16), 1u, &destinationBuffer);
  if ((_DWORD)DataPointer)
    goto LABEL_30;
  DataPointer = CMBlockBufferReplaceDataBytes(&sourceBytes, destinationBuffer, 0, 0x10uLL);
  if ((_DWORD)DataPointer)
    goto LABEL_30;
  if (Value)
  {
    *(_QWORD *)&context[0] = 0;
    DataPointer = CMBlockBufferGetDataPointer(destinationBuffer, 0x10uLL, 0, 0, (char **)context);
    if ((_DWORD)DataPointer)
      goto LABEL_30;
    DataPointer = CMBlockBufferCopyDataBytes(Value, 0, v12, *(void **)&context[0]);
    if ((_DWORD)DataPointer)
      goto LABEL_30;
  }
  v14 = 0;
  *a4 = destinationBuffer;
  destinationBuffer = 0;
LABEL_19:
  if (Value)
    CFRelease(Value);
  return v14;
}

uint64_t sceneBridgeAppendExtensionsFunc(const __CFString *a1, const __CFData *a2, uint64_t a3)
{
  CFTypeID v6;
  CFTypeID v7;
  const UInt8 *BytePtr;
  CFIndex Length;
  unsigned int v11;

  v11 = 0;
  if (a1
    && (v6 = CFGetTypeID(a1), v6 == CFStringGetTypeID())
    && a2
    && (v7 = CFGetTypeID(a2), v7 == CFDataGetTypeID())
    && FigCFStringGetOSTypeValue(a1, (int *)&v11))
  {
    if (!FigAtomWriterBeginAtom(a3, v11, 0))
    {
      BytePtr = CFDataGetBytePtr(a2);
      Length = CFDataGetLength(a2);
      FigAtomWriterAppendData(a3, (uint64_t)BytePtr, Length);
    }
  }
  else
  {
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  return FigAtomWriterEndAtom(a3);
}

uint64_t FigBridgeGetCommonEncryptionScheme(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v4;
  int v5;
  int v6;
  int v7;
  unint64_t v9;
  uint64_t v10;
  int v11;

  result = 0;
  if (a1)
  {
    if (a2)
    {
      v11 = 1935894637;
      v9 = 0;
      v10 = 0;
      figBridge_GetSinfChildDataWithPath(a1, a2, &v11, 1, &v10, &v9);
      v5 = v4;
      result = 0;
      if (!v5 && v9 >= 0xC)
      {
        v6 = *(_DWORD *)(v10 + 4);
        v7 = *(_DWORD *)(v10 + 8);
        if (v6 == 1668179299 && v7 == 256)
        {
          return 1667591779;
        }
        else
        {
          result = 1667392306;
          if (v6 != 845374051 || v7 != 256)
          {
            if (v7 == 256 && v6 == 1935893091)
              return 1667392371;
            else
              return 0;
          }
        }
      }
    }
  }
  return result;
}

void figBridge_GetSinfChildDataWithPath(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, _QWORD *a5, _QWORD *a6)
{
  int v11;
  uint64_t v12;
  uint64_t v13;
  _OWORD v14[7];

  memset(v14, 0, sizeof(v14));
  if (a1)
  {
    if (a3)
    {
      if (!FigAtomStreamInitWithMemoryBlock(a1, a2, 0, 1, (uint64_t)v14))
      {
        FigAtomStreamPositionViaAtomPath((uint64_t)v14, a4, a3);
        if (!v11)
        {
          v12 = 0;
          v13 = 0;
          if (!FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v14, 0, &v12)
            && !FigAtomStreamGetCurrentAtomDataGlobalOffset((uint64_t)v14, 0, &v13))
          {
            if (a5)
              *a5 = a1 + v13;
            if (a6)
              *a6 = v12;
          }
        }
      }
    }
  }
}

uint64_t FigBridgeGetOriginalFormatFromSinf(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v4;
  int v5;
  uint64_t v6;
  unsigned int *v7;
  int v8;

  result = 0;
  if (a1)
  {
    if (a2)
    {
      v8 = 1718775137;
      v6 = 0;
      v7 = 0;
      figBridge_GetSinfChildDataWithPath(a1, a2, &v8, 1, &v7, &v6);
      v5 = v4;
      result = 0;
      if (!v5 && v6 == 4)
        return bswap32(*v7);
    }
  }
  return result;
}

uint64_t FigBridgeExtractCommonEncryptionTrackEncryptionExtension(const __CFAllocator *a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t a6)
{
  int v10;
  uint64_t result;
  CFDataRef v13;
  unint64_t v14;
  const UInt8 *v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v15 = 0;
  v16[0] = 0x74656E6373636869;
  v14 = 0;
  figBridge_GetSinfChildDataWithPath(a5, a6, v16, 2, &v15, &v14);
  if (v10)
    return 0;
  if (!v15 || v14 < 0x18)
    return 0;
  if (a2)
    *(_QWORD *)(a2 + 8 * *a4) = CFRetain(CFSTR("CommonEncryptionTrackEncryptionBox"));
  if (a3 && (v13 = CFDataCreate(a1, v15, v14), (*(_QWORD *)(a3 + 8 * *a4) = v13) == 0))
    result = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  else
    result = 0;
  ++*a4;
  return result;
}

uint64_t FigTransportConnectionUSBCreate(uint64_t a1, CFTypeRef *a2)
{
  _QWORD *ClassID;
  uint64_t v5;
  _QWORD *DerivedStorage;
  dispatch_queue_t v7;
  dispatch_queue_t v8;
  pthread_mutex_t *v9;
  pthread_mutex_t *v10;
  __CFDictionary *Mutable;
  OpaqueCMMemoryPool *v12;
  CFAllocatorRef Allocator;
  CFTypeRef cf;

  cf = 0;
  if (!a2)
    return FigSignalErrorAt(4294955246, 0, 0, 0, 0, 0, 0);
  ClassID = (_QWORD *)NeroTransportConnectionGetClassID();
  v5 = CMDerivedObjectCreate(a1, (uint64_t)&kFigTransportConnectionUSBVTable_1, ClassID, &cf);
  if (!(_DWORD)v5)
  {
    DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
    v7 = FigDispatchQueueCreateWithPriority("FigTransportConnection", 0, 0x1Cu);
    DerivedStorage[1] = v7;
    if (!v7)
      goto LABEL_16;
    v8 = FigDispatchQueueCreateWithPriority("FigTransportConnection.data", 0, 0x1Cu);
    DerivedStorage[2] = v8;
    if (!v8)
      goto LABEL_16;
    v9 = FigSimpleMutexCreate();
    DerivedStorage[26] = v9;
    if (!v9)
      goto LABEL_16;
    v10 = FigSimpleMutexCreate();
    DerivedStorage[20] = v10;
    if (!v10)
      goto LABEL_16;
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(Mutable, CFSTR("FigMemoryPool_LoggingName"), CFSTR("TransportConnectionUSB"));
    v12 = CMMemoryPoolCreate(Mutable);
    DerivedStorage[14] = v12;
    if (Mutable)
    {
      CFRelease(Mutable);
      v12 = (OpaqueCMMemoryPool *)DerivedStorage[14];
    }
    if (v12)
    {
      Allocator = CMMemoryPoolGetAllocator(v12);
      DerivedStorage[15] = Allocator;
      if (Allocator)
        CFRetain(Allocator);
      DerivedStorage[4] = CFRetain(CFSTR("Nero"));
      *a2 = cf;
      cf = 0;
      FigAtomicIncrement32((unsigned int *)&sInstanceCount);
      v5 = 0;
    }
    else
    {
LABEL_16:
      v5 = 4294955245;
    }
  }
  if (cf)
    CFRelease(cf);
  return v5;
}

void *FigTransportConnectionUSBCopyEventHandler(uint64_t a1)
{
  void *result;

  result = *(void **)(CMBaseObjectGetDerivedStorage(a1) + 96);
  if (result)
    return _Block_copy(result);
  return result;
}

uint64_t FigTransportConnectionUSBSetAsConnected(uint64_t a1)
{
  uint64_t result;

  result = CMBaseObjectGetDerivedStorage(a1);
  *(_BYTE *)(result + 25) = 1;
  return result;
}

uint64_t usb_Invalidate(uint64_t a1)
{
  _BYTE *DerivedStorage;

  DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage(a1);
  if (!*DerivedStorage)
  {
    *DerivedStorage = 1;
    usb_stopMessageSendingAndReceivingThreads(a1);
  }
  return 0;
}

uint64_t usb_Finalize(uint64_t a1)
{
  _QWORD *DerivedStorage;
  NSObject *v3;
  NSObject *v4;
  const void *v5;
  const void *v6;
  NSObject *v7;
  const void *v8;
  const void *v9;
  const void *v10;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  usb_Invalidate(a1);
  v3 = DerivedStorage[1];
  if (v3)
  {
    dispatch_release(v3);
    DerivedStorage[1] = 0;
  }
  v4 = DerivedStorage[2];
  if (v4)
  {
    dispatch_release(v4);
    DerivedStorage[2] = 0;
  }
  v5 = (const void *)DerivedStorage[9];
  if (v5)
  {
    CFRelease(v5);
    DerivedStorage[9] = 0;
  }
  v6 = (const void *)DerivedStorage[12];
  if (v6)
  {
    _Block_release(v6);
    DerivedStorage[12] = 0;
  }
  v7 = DerivedStorage[13];
  if (v7)
  {
    dispatch_release(v7);
    DerivedStorage[13] = 0;
  }
  v8 = (const void *)DerivedStorage[14];
  if (v8)
  {
    CFRelease(v8);
    DerivedStorage[14] = 0;
  }
  v9 = (const void *)DerivedStorage[15];
  if (v9)
  {
    CFRelease(v9);
    DerivedStorage[15] = 0;
  }
  v10 = (const void *)DerivedStorage[4];
  if (v10)
  {
    CFRelease(v10);
    DerivedStorage[4] = 0;
  }
  FigSimpleMutexDestroy(DerivedStorage[26]);
  FigSimpleMutexDestroy(DerivedStorage[20]);
  return FigAtomicDecrement32((unsigned int *)&sInstanceCount);
}

__CFString *usb_CopyDebugDescription(uint64_t a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigTransportConnectionUSB %p>"), a1);
  return Mutable;
}

uint64_t usb_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  _BYTE *DerivedStorage;
  _QWORD *v7;
  const void *v8;
  const void **v9;
  uint64_t v10;

  DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage)
    return 4294955241;
  v7 = DerivedStorage;
  if (CFEqual(a2, CFSTR("ConnectionMode")))
  {
    v8 = (const void *)v7[9];
    if (!v8)
      goto LABEL_13;
    goto LABEL_12;
  }
  if (CFEqual(a2, CFSTR("Service")))
  {
    v8 = (const void *)v7[10];
    if (!v8)
      goto LABEL_13;
    goto LABEL_12;
  }
  if (CFEqual(a2, CFSTR("IsHiSpeed")))
  {
    v9 = (const void **)MEMORY[0x1E0C9AE50];
    if (v7[31] != 512)
      v9 = (const void **)MEMORY[0x1E0C9AE40];
    v8 = *v9;
LABEL_12:
    v8 = CFRetain(v8);
    goto LABEL_13;
  }
  if (CFEqual(a2, CFSTR("Version")))
  {
    v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, (char *)v7 + 28);
    goto LABEL_13;
  }
  if (!CFEqual(a2, CFSTR("USBInterfaceName")))
    return 4294954512;
  v8 = (const void *)v7[4];
  if (v8)
    goto LABEL_12;
LABEL_13:
  v10 = 0;
  *a4 = v8;
  return v10;
}

uint64_t usb_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  _BYTE *DerivedStorage;
  _QWORD *v6;
  uint64_t v7;
  CFTypeID v9;

  DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage)
    return 4294955241;
  v6 = DerivedStorage;
  if (CFEqual(a2, CFSTR("ConnectionMode")))
  {
    v7 = v6[9];
    v6[9] = a3;
    if (!a3)
      goto LABEL_5;
    goto LABEL_4;
  }
  if (CFEqual(a2, CFSTR("Service")))
  {
    v7 = v6[10];
    v6[10] = a3;
    if (!a3)
    {
LABEL_5:
      if (v7)
      {
        CFRelease((CFTypeRef)v7);
        return 0;
      }
      return v7;
    }
LABEL_4:
    CFRetain(a3);
    goto LABEL_5;
  }
  if (!CFEqual(a2, CFSTR("Version")))
  {
    if (!CFEqual(a2, CFSTR("USBInterfaceName")))
      return 4294954512;
    v7 = v6[4];
    v6[4] = a3;
    if (!a3)
      goto LABEL_5;
    goto LABEL_4;
  }
  if (!a3)
    return 4294954516;
  v9 = CFGetTypeID(a3);
  v7 = 4294954516;
  if (v9 == CFNumberGetTypeID())
  {
    if (CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, (char *)v6 + 28))
      return 0;
    else
      return 4294954516;
  }
  return v7;
}

_opaque_pthread_t *usb_stopMessageSendingAndReceivingThreads(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v2;
  _QWORD *v3;
  _opaque_pthread_t *result;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v2 = DerivedStorage;
  *(_BYTE *)(DerivedStorage + 24) = 1;
  v3 = (_QWORD *)(DerivedStorage + 192);
  if (*(_QWORD *)(DerivedStorage + 192))
  {
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(DerivedStorage + 200));
    FigThreadJoin(*(pthread_t *)(v2 + 192), 0);
    dispatch_sync(*(dispatch_queue_t *)(v2 + 16), &__block_literal_global_54);
    dispatch_release(*(dispatch_object_t *)(v2 + 200));
    *v3 = 0;
    v3[1] = 0;
  }
  result = *(_opaque_pthread_t **)(v2 + 128);
  if (result)
  {
    if (*(_QWORD *)(v2 + 136))
    {
      CFRunLoopStop(*(CFRunLoopRef *)(v2 + 136));
      result = *(_opaque_pthread_t **)(v2 + 128);
    }
    result = (_opaque_pthread_t *)FigThreadJoin(result, 0);
    *(_QWORD *)(v2 + 128) = 0;
  }
  return result;
}

uint64_t usb_SetEventHandler(uint64_t a1, NSObject *a2, unint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t v6;
  NSObject *v7;
  const void *v8;
  void *v9;
  uint64_t result;
  _QWORD block[5];

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)DerivedStorage)
    return 4294955241;
  v6 = DerivedStorage;
  v7 = *(NSObject **)(DerivedStorage + 104);
  if ((unint64_t)a2 | a3)
  {
    if (v7)
    {
      dispatch_release(v7);
      *(_QWORD *)(v6 + 104) = 0;
    }
    if (a2)
    {
      *(_QWORD *)(v6 + 104) = a2;
      dispatch_retain(a2);
    }
    else
    {
      *(_QWORD *)(v6 + 104) = FigDispatchQueueCreateWithPriority("FigTransportConnectionEvent", 0, 0x1Cu);
    }
    v8 = *(const void **)(v6 + 96);
    if (v8)
    {
      _Block_release(v8);
      *(_QWORD *)(v6 + 96) = 0;
    }
    if (a3)
    {
      v9 = _Block_copy((const void *)a3);
      result = 0;
      *(_QWORD *)(v6 + 96) = v9;
      return result;
    }
  }
  else
  {
    if (!v7)
      return 4294955240;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __usb_SetEventHandler_block_invoke;
    block[3] = &__block_descriptor_tmp_16_4;
    block[4] = v6;
    dispatch_sync(v7, block);
  }
  return 0;
}

uint64_t usb_Start(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  BOOL v4;
  NSObject *v5;
  uint64_t v7;
  _QWORD block[7];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)DerivedStorage)
  {
    v7 = 4294955241;
    *((_DWORD *)v10 + 6) = -12055;
  }
  else
  {
    v3 = DerivedStorage;
    if (CFEqual(*(CFTypeRef *)(DerivedStorage + 72), CFSTR("Server")))
      v4 = sInstanceCount == 1;
    else
      v4 = 1;
    if (v4)
    {
      v5 = *(NSObject **)(v3 + 8);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __usb_Start_block_invoke;
      block[3] = &unk_1E28E5530;
      block[4] = &v9;
      block[5] = v3;
      block[6] = a1;
      dispatch_sync(v5, block);
      v7 = *((unsigned int *)v10 + 6);
    }
    else
    {
      v7 = FigSignalErrorAt(4294955246, 0, 0, 0, 0, 0, 0);
      *((_DWORD *)v10 + 6) = v7;
    }
  }
  _Block_object_dispose(&v9, 8);
  return v7;
}

uint64_t usb_Stop(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *v3;
  _QWORD v5[6];

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)DerivedStorage)
    return 4294955241;
  v3 = *(NSObject **)(DerivedStorage + 8);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __usb_Stop_block_invoke;
  v5[3] = &__block_descriptor_tmp_44;
  v5[4] = DerivedStorage;
  v5[5] = a1;
  dispatch_sync(v3, v5);
  return 0;
}

uint64_t usb_EnqueuePackageWithPriority(const void *a1, unsigned int *a2, OpaqueCMBlockBuffer *a3, int a4)
{
  _BYTE *DerivedStorage;
  size_t v9;
  OSStatus appended;
  CMBlockBufferRef v11;
  BOOL v12;
  OpaqueCMBlockBuffer *v13;
  OpaqueCMBlockBuffer *v14;
  NSObject *v15;
  uint64_t v17;
  CMBlockBufferRef destinationBuffer[7];
  int v19;

  DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (*DerivedStorage)
    return 4294955241;
  if (a2[1] == 1885957735)
    goto LABEL_21;
  if (!DerivedStorage[25])
  {
    v17 = 4294955244;
    return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
  }
  if ((a4 - 3) <= 0xFFFFFFFD)
  {
LABEL_21:
    v17 = 4294955246;
    return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
  }
  destinationBuffer[0] = 0;
  if (*a2 <= 7)
  {
    FigSignalErrorAt(4294955242, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v9 = *a2 - CMBlockBufferGetDataLength(a3);
  appended = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v9, (CFAllocatorRef)*MEMORY[0x1E0C9AE10], 0, 0, v9, 1u, destinationBuffer);
  v11 = destinationBuffer[0];
  if (!appended)
  {
    appended = CMBlockBufferReplaceDataBytes(a2, destinationBuffer[0], 0, v9);
    v11 = destinationBuffer[0];
    if (a3)
    {
      if (!appended)
      {
        appended = CMBlockBufferAppendBufferReference(destinationBuffer[0], a3, 0, 0, 0);
        v11 = destinationBuffer[0];
      }
    }
  }
  if (appended)
    v12 = v11 == 0;
  else
    v12 = 1;
  if (!v12)
    goto LABEL_18;
  if (v11)
  {
    v13 = (OpaqueCMBlockBuffer *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
    if (!*(_BYTE *)v13)
    {
      v14 = v13;
      CFRetain(v11);
      CFRetain(a1);
      v15 = *((_QWORD *)v14 + 2);
      destinationBuffer[0] = (CMBlockBufferRef)MEMORY[0x1E0C809B0];
      destinationBuffer[1] = (CMBlockBufferRef)0x40000000;
      destinationBuffer[2] = (CMBlockBufferRef)__usb_enqueuePackageWithPriority_block_invoke;
      destinationBuffer[3] = (CMBlockBufferRef)&__block_descriptor_tmp_45_0;
      v19 = a4;
      destinationBuffer[4] = v14;
      destinationBuffer[5] = v11;
      destinationBuffer[6] = (CMBlockBufferRef)a1;
      dispatch_async(v15, destinationBuffer);
    }
LABEL_18:
    CFRelease(v11);
  }
  return 0;
}

uint64_t usb_FlushPendingPackagesWithPriority(const void *a1, int a2)
{
  if (*(_BYTE *)CMBaseObjectGetDerivedStorage((uint64_t)a1))
    return 4294955241;
  usb_sendDataViaUSB(a1, a2);
  return 0;
}

uint64_t usb_messageSendingThreadMain(const void *a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!*(_BYTE *)(DerivedStorage + 24))
  {
    v3 = DerivedStorage;
    do
    {
      dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v3 + 200), 0xFFFFFFFFFFFFFFFFLL);
      usb_sendDataViaUSB(a1, 0);
    }
    while (!*(_BYTE *)(v3 + 24));
  }
  return 0;
}

uint64_t usb_clientThreadMain(const void *a1)
{
  uint64_t DerivedStorage;
  CFRunLoopRef Current;
  uint64_t v4;
  io_service_t IOKitObject;
  const __CFUUID *v6;
  const __CFUUID *v7;
  IOCFPlugInInterface **v8;
  HRESULT (__cdecl *QueryInterface)(void *, REFIID, LPVOID *);
  const __CFUUID *v10;
  CFUUIDBytes v11;
  uint64_t v12;
  unsigned __int8 v14;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  _QWORD v19[5];
  _QWORD aBlock[6];
  unsigned __int16 v21;
  char v22;
  __int16 v23;
  __int16 v24;
  uint64_t v25;
  IOCFPlugInInterface **theInterface;
  SInt32 theScore;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  theScore = 0;
  v25 = 0;
  theInterface = 0;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  v21 = 0;
  Current = CFRunLoopGetCurrent();
  *(_QWORD *)(DerivedStorage + 136) = Current;
  if (!Current)
    goto LABEL_7;
  *(_QWORD *)(DerivedStorage + 288) = a1;
  *(_QWORD *)(DerivedStorage + 296) = 0;
  *(_QWORD *)(DerivedStorage + 304) = malloc_type_malloc(0x10000uLL, 0x293CFF78uLL);
  v4 = *(_QWORD *)(DerivedStorage + 80);
  if (!v4)
    goto LABEL_7;
  IOKitObject = FigCFIOKitObjectGetIOKitObject(v4);
  v6 = CFUUIDGetConstantUUIDWithBytes(0, 0x2Du, 0x97u, 0x86u, 0xC6u, 0x9Eu, 0xF3u, 0x11u, 0xD4u, 0xADu, 0x51u, 0, 0xAu, 0x27u, 5u, 0x28u, 0x61u);
  v7 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
  if (IOCreatePlugInInterfaceForService(IOKitObject, v6, v7, &theInterface, &theScore))
    goto LABEL_7;
  v8 = theInterface;
  *(_QWORD *)(DerivedStorage + 256) = theInterface;
  QueryInterface = (*v8)->QueryInterface;
  v10 = CFUUIDGetConstantUUIDWithBytes(0, 0x8Fu, 0xDBu, 0x84u, 0x55u, 0x74u, 0xA6u, 0x11u, 0xD6u, 0x97u, 0xB1u, 0, 0x30u, 0x65u, 0xD3u, 0x60u, 0x8Eu);
  v11 = CFUUIDGetUUIDBytes(v10);
  if (((unsigned int (*)(IOCFPlugInInterface **, _QWORD, _QWORD, uint64_t *))QueryInterface)(v8, *(_QWORD *)&v11.byte0, *(_QWORD *)&v11.byte8, &v25))
  {
    goto LABEL_7;
  }
  v12 = v25;
  *(_QWORD *)(DerivedStorage + 264) = v25;
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v12 + 64))(v12))
    goto LABEL_7;
  *(_BYTE *)(DerivedStorage + 272) = 1;
  if ((*(unsigned int (**)(uint64_t, char *))(*(_QWORD *)v25 + 152))(v25, (char *)&v24 + 1))
    goto LABEL_7;
  if (HIBYTE(v24))
  {
    v14 = 1;
    while (!(*(unsigned int (**)(uint64_t, _QWORD, __int16 *, char *, __int16 *, unsigned __int16 *, char *))(*(_QWORD *)v25 + 208))(v25, v14, &v24, (char *)&v23 + 1, &v23, &v21, &v22)&& !(*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)v25 + 360))(v25, v14))
    {
      if (v23 == 2 && v24 == 1)
      {
        if (!*(_BYTE *)(DerivedStorage + 273))
          *(_BYTE *)(DerivedStorage + 273) = v14;
      }
      else if (v23 == 2 && !(_BYTE)v24 && !*(_BYTE *)(DerivedStorage + 274))
      {
        *(_BYTE *)(DerivedStorage + 274) = v14;
        *(_QWORD *)(DerivedStorage + 248) = v21;
      }
      if (HIBYTE(v24) < ++v14)
        goto LABEL_24;
    }
    goto LABEL_7;
  }
LABEL_24:
  if (!*(_BYTE *)(DerivedStorage + 273))
    goto LABEL_7;
  if (!*(_BYTE *)(DerivedStorage + 274))
    goto LABEL_7;
  v16 = MEMORY[0x1E0C809B0];
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 0x40000000;
  aBlock[2] = __usb_clientThreadSetup_block_invoke;
  aBlock[3] = &__block_descriptor_tmp_28;
  aBlock[4] = v25;
  aBlock[5] = DerivedStorage;
  *(_QWORD *)(DerivedStorage + 232) = _Block_copy(aBlock);
  v19[0] = v16;
  v19[1] = 0x40000000;
  v19[2] = __usb_clientThreadSetup_block_invoke_2;
  v19[3] = &__block_descriptor_tmp_30_3;
  v19[4] = DerivedStorage;
  *(_QWORD *)(DerivedStorage + 240) = _Block_copy(v19);
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v25 + 32))(v25, DerivedStorage + 280)
    || (CFRunLoopAddSource(*(CFRunLoopRef *)(DerivedStorage + 136), *(CFRunLoopSourceRef *)(DerivedStorage + 280), (CFRunLoopMode)*MEMORY[0x1E0C9B280]), (*(unsigned int (**)(void))(*(_QWORD *)(DerivedStorage + 232) + 16))()))
  {
LABEL_7:
    usb_clientThreadTearDown((uint64_t)a1);
    goto LABEL_8;
  }
  v17 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v18 = malloc_type_malloc(0x10uLL, 0xF9F4F746uLL);
  v18[2] = 1;
  *(_QWORD *)v18 = 0x70696E6700000010;
  v18[3] = *(_DWORD *)(v17 + 28);
  if (!(*(unsigned int (**)(_QWORD, _QWORD))(**(_QWORD **)(v17 + 264) + 224))(*(_QWORD *)(v17 + 264), *(unsigned __int8 *)(v17 + 274))&& !(*(unsigned int (**)(_QWORD, _QWORD, _DWORD *, uint64_t, void (__cdecl *)(void *), _DWORD *))(**(_QWORD **)(v17 + 264) + 272))(*(_QWORD *)(v17 + 264), *(unsigned __int8 *)(v17 + 274), v18, 16, usb_pingAsyncCallback, v18))
  {
    v18 = 0;
  }
  free(v18);
LABEL_8:
  CFRunLoopRun();
  usb_setDisconnected(a1);
  usb_clientThreadTearDown((uint64_t)a1);
  return 0;
}

void usb_sendDataViaUSB(const void *a1, int a2)
{
  uint64_t DerivedStorage;
  OpaqueCMBlockBuffer *v5;
  CFTypeRef *v6;
  unint64_t v7;
  NSObject *v8;
  OpaqueCMBlockBuffer *v9;
  const void *v10;
  unint64_t v11;
  _QWORD v12[6];
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  char *dataPointerOut;
  size_t lengthAtOffsetOut;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 208));
  dataPointerOut = 0;
  lengthAtOffsetOut = 0;
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  v6 = (CFTypeRef *)(DerivedStorage + 216);
  v5 = *(OpaqueCMBlockBuffer **)(DerivedStorage + 216);
  if (v5)
  {
    CMBlockBufferGetDataPointer(v5, *(_QWORD *)(DerivedStorage + 224), &lengthAtOffsetOut, 0, &dataPointerOut);
    v7 = usb_sendMemoryBlockViaUSB(a1);
    *(_QWORD *)(DerivedStorage + 224) += v7;
    if (v7 != lengthAtOffsetOut)
      goto LABEL_17;
    if (!(v7 % *(_QWORD *)(DerivedStorage + 248)))
    {
      v14 = 0;
      (*(void (**)(void))(*(_QWORD *)(DerivedStorage + 240) + 16))();
    }
    if (*v6)
    {
      CFRelease(*v6);
      *v6 = 0;
    }
    *(_QWORD *)(DerivedStorage + 224) = 0;
  }
  v8 = *(NSObject **)(DerivedStorage + 16);
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 0x40000000;
  v12[2] = __usb_sendDataViaUSB_block_invoke;
  v12[3] = &unk_1E28E5558;
  v13 = a2;
  v12[4] = &v15;
  v12[5] = DerivedStorage;
  dispatch_sync(v8, v12);
  v9 = (OpaqueCMBlockBuffer *)v16[3];
  if (v9)
  {
    CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9, *(CFAllocatorRef *)(DerivedStorage + 120), 0, 0, 0, 0, (CMBlockBufferRef *)(DerivedStorage + 216));
    v10 = (const void *)v16[3];
    if (v10)
    {
      CFRelease(v10);
      v16[3] = 0;
    }
    CMBlockBufferGetDataPointer((CMBlockBufferRef)*v6, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
    v11 = usb_sendMemoryBlockViaUSB(a1);
    if (v11 == lengthAtOffsetOut)
    {
      if (!(v11 % *(_QWORD *)(DerivedStorage + 248)))
      {
        v14 = 0;
        (*(void (**)(void))(*(_QWORD *)(DerivedStorage + 240) + 16))();
      }
      v11 = (unint64_t)*v6;
      if (*v6)
      {
        CFRelease((CFTypeRef)v11);
        v11 = 0;
        *v6 = 0;
      }
    }
    *(_QWORD *)(DerivedStorage + 224) = v11;
  }
LABEL_17:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 208));
  _Block_object_dispose(&v15, 8);
}

uint64_t usb_sendMemoryBlockViaUSB(const void *a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  NSObject *v4;
  _QWORD v6[5];
  uint64_t v7;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v7 = 0;
  if (!*(_BYTE *)DerivedStorage)
  {
    v3 = DerivedStorage;
    if (*(_BYTE *)(DerivedStorage + 25))
    {
      if ((*(unsigned int (**)(void))(*(_QWORD *)(DerivedStorage + 240) + 16))() == -536870186)
      {
        CFRetain(a1);
        v4 = *(NSObject **)(v3 + 8);
        v6[0] = MEMORY[0x1E0C809B0];
        v6[1] = 0x40000000;
        v6[2] = __usb_sendMemoryBlockViaUSB_block_invoke;
        v6[3] = &__block_descriptor_tmp_24_3;
        v6[4] = a1;
        dispatch_async(v4, v6);
      }
    }
  }
  return v7;
}

void __usb_sendDataViaUSB_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  OpaqueCMBlockBuffer *v4;
  uint64_t v5;
  OpaqueCMBlockBuffer *v6;
  const void *v7;

  v2 = *(unsigned int *)(a1 + 48);
  if ((v2 - 1) >= 2)
  {
    v3 = 56;
    while (1)
    {
      v4 = *(OpaqueCMBlockBuffer **)(*(_QWORD *)(a1 + 40) + v3);
      if (v4)
      {
        v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
        v6 = *(OpaqueCMBlockBuffer **)(v5 + 24);
        if (!v6)
        {
          *(_QWORD *)(v5 + 24) = v4;
          goto LABEL_9;
        }
        CMBlockBufferAppendBufferReference(v6, v4, 0, 0, 0);
        v7 = *(const void **)(*(_QWORD *)(a1 + 40) + v3);
        if (v7)
        {
          CFRelease(v7);
LABEL_9:
          *(_QWORD *)(*(_QWORD *)(a1 + 40) + v3) = 0;
        }
      }
      v3 += 8;
      if (v3 == 72)
        return;
    }
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v2 + 48);
  *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v2 + 48) = 0;
}

void __usb_sendMemoryBlockViaUSB_block_invoke(uint64_t a1)
{
  usb_setDisconnected(*(const void **)(a1 + 32));
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

uint64_t usb_setDisconnected(const void *a1)
{
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v4;
  uint64_t v5;
  unsigned int v6;
  char *v7;
  NSObject *v8;
  _QWORD block[6];
  os_log_type_t type;
  int v12[2];
  const char *v13;
  char v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v12[0] = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v12, &type);
  v4 = v12[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v6 = v4;
  else
    v6 = v4 & 0xFFFFFFFE;
  if (v6)
  {
    v12[1] = 136315138;
    v13 = "usb_setDisconnected";
    v7 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v12[0];
  }
  else
  {
    v7 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != &v14, v4, 0, v5);
  *(_BYTE *)(DerivedStorage + 25) = 0;
  if (!*(_BYTE *)DerivedStorage)
  {
    CFRetain(a1);
    v8 = *(NSObject **)(DerivedStorage + 104);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __usb_setDisconnected_block_invoke;
    block[3] = &__block_descriptor_tmp_25_4;
    block[4] = DerivedStorage;
    block[5] = a1;
    dispatch_async(v8, block);
  }
  return usb_connectionReset(a1);
}

void __usb_setDisconnected_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)v2)
  {
    v3 = *(_QWORD *)(v2 + 96);
    if (v3)
      (*(void (**)(uint64_t, uint64_t, _QWORD))(v3 + 16))(v3, 2, 0);
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

uint64_t usb_connectionReset(const void *a1)
{
  uint64_t DerivedStorage;
  NSObject *v3;
  const void *v4;
  _QWORD v6[6];

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  usb_resetMessageReceiptState((uint64_t)a1);
  CFRetain(a1);
  v3 = *(NSObject **)(DerivedStorage + 16);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __usb_connectionReset_block_invoke;
  v6[3] = &__block_descriptor_tmp_26_3;
  v6[4] = DerivedStorage;
  v6[5] = a1;
  dispatch_async(v3, v6);
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 208));
  v4 = *(const void **)(DerivedStorage + 216);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(DerivedStorage + 216) = 0;
  }
  *(_QWORD *)(DerivedStorage + 224) = 0;
  return FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 208));
}

uint64_t usb_resetMessageReceiptState(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v2;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 160));
  v2 = *(const void **)(DerivedStorage + 184);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(DerivedStorage + 184) = 0;
  }
  *(_DWORD *)(DerivedStorage + 176) = 0;
  *(_QWORD *)(DerivedStorage + 168) = 0;
  return FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 160));
}

void __usb_connectionReset_block_invoke(uint64_t a1)
{
  uint64_t i;
  const void *v3;

  for (i = 56; i != 72; i += 8)
  {
    v3 = *(const void **)(*(_QWORD *)(a1 + 32) + i);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + i) = 0;
    }
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void usb_clientThreadTearDown(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v2;
  __CFRunLoopSource *v3;
  const void *v4;
  uint64_t v5;
  IOCFPlugInInterface **v6;
  const void *v7;
  const void *v8;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v2 = DerivedStorage;
  if (*(_BYTE *)(DerivedStorage + 273))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(DerivedStorage + 264) + 224))(*(_QWORD *)(DerivedStorage + 264));
    *(_BYTE *)(v2 + 273) = 0;
  }
  if (*(_BYTE *)(v2 + 274))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 264) + 224))(*(_QWORD *)(v2 + 264));
    *(_BYTE *)(v2 + 274) = 0;
  }
  v3 = *(__CFRunLoopSource **)(v2 + 280);
  if (v3)
  {
    CFRunLoopRemoveSource(*(CFRunLoopRef *)(v2 + 136), v3, (CFRunLoopMode)*MEMORY[0x1E0C9B280]);
    v4 = *(const void **)(v2 + 280);
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(v2 + 280) = 0;
    }
  }
  if (*(_BYTE *)(v2 + 272))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v2 + 264) + 72))(*(_QWORD *)(v2 + 264));
    *(_BYTE *)(v2 + 272) = 0;
  }
  v5 = *(_QWORD *)(v2 + 264);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    *(_QWORD *)(v2 + 264) = 0;
  }
  v6 = *(IOCFPlugInInterface ***)(v2 + 256);
  if (v6)
  {
    IODestroyPlugInInterface(v6);
    *(_QWORD *)(v2 + 256) = 0;
  }
  *(_QWORD *)(v2 + 136) = 0;
  free(*(void **)(v2 + 304));
  *(_QWORD *)(v2 + 304) = 0;
  v7 = *(const void **)(v2 + 232);
  if (v7)
  {
    _Block_release(v7);
    *(_QWORD *)(v2 + 232) = 0;
  }
  v8 = *(const void **)(v2 + 240);
  if (v8)
  {
    _Block_release(v8);
    *(_QWORD *)(v2 + 240) = 0;
  }
}

uint64_t __usb_clientThreadSetup_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t, uint64_t (*)(uint64_t *, int, size_t)))(**(_QWORD **)(a1 + 32) + 264))(*(_QWORD *)(a1 + 32), *(unsigned __int8 *)(*(_QWORD *)(a1 + 40) + 273), *(_QWORD *)(a2 + 16), 0x10000, usb_readCompleted);
}

uint64_t usb_readCompleted(uint64_t *a1, int a2, size_t a3)
{
  const void *v6;
  uint64_t DerivedStorage;
  uint64_t v8;
  char *v9;
  OpaqueCMBlockBuffer *v10;
  unsigned int *v11;
  CMBlockBufferRef *v12;
  size_t v13;
  size_t v14;
  size_t v15;
  size_t v16;
  uint64_t v17;
  size_t DataLength;
  size_t v19;
  char *v20;
  uint64_t v21;
  size_t v22;
  NSObject *v23;
  CMBlockBufferRef v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t result;
  const __CFAllocator *structureAllocator;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  char *v31;
  CMBlockBufferRef v32;
  uint64_t block;
  uint64_t v34;
  void (*v35)(uint64_t);
  void *v36;
  uint64_t v37;
  OpaqueCMBlockBuffer *v38;
  const void *v39;

  v6 = (const void *)*a1;
  DerivedStorage = CMBaseObjectGetDerivedStorage(*a1);
  v8 = DerivedStorage;
  v9 = (char *)a1[2];
  lengthAtOffsetOut = 0;
  dataPointerOut = 0;
  if (a2)
  {
    usb_resetMessageReceiptState((uint64_t)v6);
    LODWORD(v10) = 0;
    goto LABEL_49;
  }
  v11 = (unsigned int *)(DerivedStorage + 176);
  v12 = (CMBlockBufferRef *)(DerivedStorage + 184);
  structureAllocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  while (1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(v8 + 160));
    v13 = *(_QWORD *)(v8 + 168);
    if (v13 <= 3)
      break;
LABEL_10:
    if (!*v12)
    {
      LODWORD(v10) = 1;
      if (CMBlockBufferCreateWithMemoryBlock(structureAllocator, 0, *(unsigned int *)(v8 + 176), *(CFAllocatorRef *)(v8 + 120), 0, 0, *(unsigned int *)(v8 + 176), 1u, (CMBlockBufferRef *)(v8 + 184))|| CMBlockBufferReplaceDataBytes((const void *)(v8 + 176), *v12, 0, 4uLL))
      {
        goto LABEL_49;
      }
      v13 = *(_QWORD *)(v8 + 168);
    }
    v15 = *v11;
    if (v13 < v15)
    {
      if (!a3 || CMBlockBufferGetDataPointer(*v12, v13, &lengthAtOffsetOut, 0, &dataPointerOut))
        goto LABEL_48;
      if (lengthAtOffsetOut >= a3)
        v16 = a3;
      else
        v16 = lengthAtOffsetOut;
      lengthAtOffsetOut = v16;
      memcpy(dataPointerOut, v9, v16);
      v9 += lengthAtOffsetOut;
      a3 -= lengthAtOffsetOut;
      v13 = *(_QWORD *)(v8 + 168) + lengthAtOffsetOut;
      *(_QWORD *)(v8 + 168) = v13;
      v15 = *(unsigned int *)(v8 + 176);
    }
    if (v13 == v15)
    {
      v10 = *(OpaqueCMBlockBuffer **)(v8 + 184);
      *(_QWORD *)(v8 + 184) = 0;
      *(_DWORD *)(v8 + 176) = 0;
      *(_QWORD *)(v8 + 168) = 0;
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v8 + 160));
      v17 = CMBaseObjectGetDerivedStorage((uint64_t)v6);
      v31 = 0;
      if (CMBlockBufferGetDataLength(v10) >= 8)
      {
        DataLength = CMBlockBufferGetDataLength(v10);
        if (CMBlockBufferIsRangeContiguous(v10, 0, DataLength))
        {
          if (!CMBlockBufferGetDataPointer(v10, 0, 0, 0, &v31))
          {
            v19 = CMBlockBufferGetDataLength(v10);
            v20 = v31;
            if (v19 == *(_DWORD *)v31)
            {
              if (*((_DWORD *)v31 + 1) != 1885957735)
              {
                if (!*(_BYTE *)v17)
                {
                  CFRetain(v10);
                  CFRetain(v6);
                  v23 = *(NSObject **)(v17 + 104);
                  block = MEMORY[0x1E0C809B0];
                  v34 = 0x40000000;
                  v35 = __usb_didReceivePackage_block_invoke;
                  v36 = &__block_descriptor_tmp_31;
                  v37 = v17;
                  v38 = v10;
                  v39 = v6;
                  dispatch_async(v23, &block);
                }
                goto LABEL_25;
              }
              v21 = CMBaseObjectGetDerivedStorage((uint64_t)v6);
              v22 = CMBlockBufferGetDataLength(v10);
              v32 = 0;
              if (v22 >= 0xD)
              {
                if (CMBlockBufferCreateWithBufferReference(structureAllocator, v10, 0xCuLL, v22 - 12, 0, &v32))
                {
LABEL_46:
                  if (v32)
                    CFRelease(v32);
                  goto LABEL_25;
                }
                if (*((_DWORD *)v20 + 2))
                  usb_deviceSendStartupPing((uint64_t)v6);
              }
              if (*(_BYTE *)(v21 + 40))
                usb_setDisconnected(v6);
              else
                *(_BYTE *)(v21 + 40) = 1;
              v24 = v32;
              v25 = CMBaseObjectGetDerivedStorage((uint64_t)v6);
              usb_connectionReset(v6);
              *(_BYTE *)(v25 + 25) = 1;
              if (!*(_BYTE *)v25)
              {
                if (v24)
                  CFRetain(v24);
                CFRetain(v6);
                v26 = *(NSObject **)(v25 + 104);
                block = MEMORY[0x1E0C809B0];
                v34 = 0x40000000;
                v35 = __usb_setConnected_block_invoke;
                v36 = &__block_descriptor_tmp_32_0;
                v37 = v25;
                v38 = v24;
                v39 = v6;
                dispatch_async(v26, &block);
              }
              goto LABEL_46;
            }
          }
        }
      }
LABEL_25:
      if (v10)
      {
        CFRelease(v10);
        LODWORD(v10) = 0;
      }
      if (!a3)
        goto LABEL_49;
    }
    else
    {
      LODWORD(v10) = 1;
      if (!a3)
        goto LABEL_49;
    }
  }
  if (4 - v13 >= a3)
    v14 = a3;
  else
    v14 = 4 - v13;
  lengthAtOffsetOut = v14;
  dataPointerOut = (char *)v11 + v13;
  memcpy((char *)v11 + v13, v9, v14);
  v13 = *(_QWORD *)(v8 + 168) + v14;
  *(_QWORD *)(v8 + 168) = v13;
  if (v13 >= 4)
  {
    v9 += v14;
    a3 -= v14;
    goto LABEL_10;
  }
LABEL_48:
  LODWORD(v10) = 1;
LABEL_49:
  result = *(_QWORD *)(v8 + 232);
  if (result)
    result = (*(uint64_t (**)(uint64_t, uint64_t *))(result + 16))(result, a1);
  if ((_DWORD)v10)
    return FigSimpleMutexUnlock(*(pthread_mutex_t **)(v8 + 160));
  return result;
}

uint64_t __usb_clientThreadSetup_block_invoke_2(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, _QWORD *a5)
{
  uint64_t result;
  uint64_t v8;
  char v9;

  if (!a3)
    a3 = &v9;
  result = (*(uint64_t (**)(_QWORD, _QWORD, char *))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 264) + 256))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 264), *(unsigned __int8 *)(*(_QWORD *)(a1 + 32) + 274), a3);
  if ((_DWORD)result)
    v8 = 0;
  else
    v8 = a4;
  *a5 = v8;
  return result;
}

void __usb_didReceivePackage_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)v2)
  {
    v3 = *(_QWORD *)(v2 + 96);
    if (v3)
      (*(void (**)(uint64_t, _QWORD, _QWORD))(v3 + 16))(v3, 0, *(_QWORD *)(a1 + 40));
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 48));
}

uint64_t usb_deviceSendStartupPing(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  result = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(DerivedStorage + 296) + 192))(*(_QWORD *)(DerivedStorage + 296), *(_QWORD *)(DerivedStorage + 312));
  if (!(_DWORD)result)
  {
    v3 = *(_QWORD *)(DerivedStorage + 392);
    v4 = usb_deviceSendStartupPing_pingHeader;
    *(_DWORD *)(v3 + 8) = dword_1EE140420;
    *(_QWORD *)v3 = v4;
    *(_DWORD *)(*(_QWORD *)(DerivedStorage + 392) + 12) = *(_DWORD *)(DerivedStorage + 28);
    return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t, void (__cdecl *)(void *), _QWORD))(**(_QWORD **)(DerivedStorage + 296) + 176))(*(_QWORD *)(DerivedStorage + 296), *(_QWORD *)(DerivedStorage + 312), *(_QWORD *)(DerivedStorage + 384), 16, usb_pingAsyncCallback, 0);
  }
  return result;
}

void __usb_setConnected_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)v2)
  {
    v3 = *(_QWORD *)(v2 + 96);
    if (v3)
      (*(void (**)(uint64_t, uint64_t, _QWORD))(v3 + 16))(v3, 1, *(_QWORD *)(a1 + 40));
  }
  v4 = *(const void **)(a1 + 40);
  if (v4)
    CFRelease(v4);
  CFRelease(*(CFTypeRef *)(a1 + 48));
}

uint64_t usb_serverThreadMain(void *a1)
{
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v4;
  uint64_t v5;
  unsigned int v6;
  _BYTE *v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  _BYTE *v13;
  CFRunLoopRef Current;
  CFMutableDictionaryRef v15;
  __CFDictionary *v16;
  __CFDictionary *Mutable;
  __CFDictionary *v18;
  IONotificationPort *v19;
  __CFRunLoopSource *RunLoopSource;
  io_iterator_t *v21;
  kern_return_t v22;
  os_log_type_t type;
  int v25;
  int v26;
  const char *v27;
  _BYTE v28[128];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v25 = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v25, &type);
  v4 = v25;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v6 = v4;
  else
    v6 = v4 & 0xFFFFFFFE;
  if (v6)
  {
    v26 = 136315138;
    v27 = "usb_serverThreadMain";
    v7 = (_BYTE *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v25;
  }
  else
  {
    v7 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != v28, v4, 0, v5);
  v8 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v25 = 0;
  type = OS_LOG_TYPE_DEFAULT;
  v9 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v25, &type);
  v10 = v25;
  if (os_log_type_enabled(v9, type))
    v12 = v10;
  else
    v12 = v10 & 0xFFFFFFFE;
  if (v12)
  {
    v26 = 136315138;
    v27 = "usb_serverThreadSetup";
    v13 = (_BYTE *)_os_log_send_and_compose_impl();
    LOBYTE(v10) = v25;
  }
  else
  {
    v13 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v13, v13 != v28, v10, 0, v11);
  Current = CFRunLoopGetCurrent();
  *(_QWORD *)(v8 + 136) = Current;
  if (!Current)
    goto LABEL_25;
  v15 = IOServiceMatching("IOUSBDeviceInterface");
  if (!v15)
    goto LABEL_25;
  v16 = v15;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    goto LABEL_24;
  v18 = Mutable;
  CFDictionarySetValue(Mutable, CFSTR("USBDeviceFunction"), *(const void **)(v8 + 32));
  CFDictionarySetValue(v16, CFSTR("IOPropertyMatch"), v18);
  CFRelease(v18);
  v19 = IONotificationPortCreate(*MEMORY[0x1E0CBBAA8]);
  *(_QWORD *)(v8 + 256) = v19;
  if (!v19 || (RunLoopSource = IONotificationPortGetRunLoopSource(v19), (*(_QWORD *)(v8 + 264) = RunLoopSource) == 0))
  {
LABEL_24:
    CFRelease(v16);
LABEL_25:
    v22 = -12051;
    goto LABEL_19;
  }
  CFRunLoopAddSource(*(CFRunLoopRef *)(v8 + 136), RunLoopSource, (CFRunLoopMode)*MEMORY[0x1E0C9B280]);
  v21 = (io_iterator_t *)(v8 + 272);
  v22 = IOServiceAddMatchingNotification(*(IONotificationPortRef *)(v8 + 256), "IOServiceFirstMatch", v16, (IOServiceMatchingCallback)usb_handleDeviceAttached, a1, (io_iterator_t *)(v8 + 272));
  if (v22)
  {
LABEL_19:
    usb_serverThreadTearDown(a1);
    goto LABEL_21;
  }
  usb_handleDeviceAttached(a1, *v21);
LABEL_21:
  *(_DWORD *)(DerivedStorage + 152) = v22;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(DerivedStorage + 144));
  if (!v22)
  {
    CFRunLoopRun();
    usb_setDisconnected(a1);
    usb_serverThreadTearDown(a1);
  }
  return 0;
}

void usb_serverThreadTearDown(const void *a1)
{
  uint64_t DerivedStorage;
  io_object_t v3;
  __CFRunLoopSource *v4;
  IONotificationPort *v5;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  usb_deviceTearDown(a1);
  v3 = *(_DWORD *)(DerivedStorage + 272);
  if (v3)
  {
    IOObjectRelease(v3);
    *(_DWORD *)(DerivedStorage + 272) = 0;
  }
  v4 = *(__CFRunLoopSource **)(DerivedStorage + 264);
  if (v4)
    CFRunLoopRemoveSource(*(CFRunLoopRef *)(DerivedStorage + 136), v4, (CFRunLoopMode)*MEMORY[0x1E0C9B280]);
  v5 = *(IONotificationPort **)(DerivedStorage + 256);
  if (v5)
  {
    IONotificationPortDestroy(v5);
    *(_QWORD *)(DerivedStorage + 256) = 0;
  }
  *(_QWORD *)(DerivedStorage + 136) = 0;
}

uint64_t usb_handleDeviceAttached(void *a1, io_iterator_t a2)
{
  uint64_t DerivedStorage;
  uint64_t result;
  io_object_t v6;
  uint64_t v7;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v9;
  uint64_t v10;
  unsigned int v11;
  _BYTE *v12;
  const __CFUUID *v13;
  const __CFUUID *v14;
  IOCFPlugInInterface **v15;
  HRESULT (__cdecl *QueryInterface)(void *, REFIID, LPVOID *);
  const __CFUUID *v17;
  CFUUIDBytes v18;
  uint64_t v19;
  NSObject *v20;
  unsigned int v21;
  uint64_t v22;
  _BYTE *v24;
  int v25;
  uint64_t v26;
  os_log_type_t type;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  SInt32 theScore;
  IOCFPlugInInterface **theInterface;
  int v33;
  const char *v34;
  _BYTE v35[128];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  result = IOIteratorNext(a2);
  if ((_DWORD)result)
  {
    v6 = result;
    v26 = *MEMORY[0x1E0C9B280];
    while (*(_DWORD *)(DerivedStorage + 280))
    {
LABEL_33:
      result = IOIteratorNext(a2);
      v6 = result;
      if (!(_DWORD)result)
        return result;
    }
    v7 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    theInterface = 0;
    theScore = 0;
    v29 = 0;
    v30 = 0;
    v28 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, (int *)&v28, &type);
    v9 = v28;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v11 = v9;
    else
      v11 = v9 & 0xFFFFFFFE;
    if (v11)
    {
      v33 = 136315138;
      v34 = "usb_deviceSetup";
      v12 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v9) = v28;
    }
    else
    {
      v12 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v12, v12 != v35, v9, 0, v10);
    if (!IOServiceAddInterestNotification(*(IONotificationPortRef *)(v7 + 256), v6, "IOGeneralInterest", (IOServiceInterestCallback)usb_generalInterestNotification, a1, (io_object_t *)(v7 + 276)))
    {
      v13 = CFUUIDGetConstantUUIDWithBytes(0, 0x9Eu, 0x72u, 0x21u, 0x7Eu, 0x8Au, 0x60u, 0x11u, 0xDBu, 0xBFu, 0x57u, 0, 0xDu, 0x93u, 0x6Du, 6u, 0xD2u);
      v14 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
      if (!IOCreatePlugInInterfaceForService(v6, v13, v14, &theInterface, &theScore))
      {
        v15 = theInterface;
        if (theInterface)
        {
          *(_QWORD *)(v7 + 288) = theInterface;
          QueryInterface = (*v15)->QueryInterface;
          v17 = CFUUIDGetConstantUUIDWithBytes(0, 0xEAu, 0x33u, 0xBAu, 0x4Fu, 0x8Au, 0x60u, 0x11u, 0xDBu, 0x84u, 0xDBu, 0, 0xDu, 0x93u, 0x6Du, 6u, 0xD2u);
          v18 = CFUUIDGetUUIDBytes(v17);
          if (!((unsigned int (*)(IOCFPlugInInterface **, _QWORD, _QWORD, uint64_t *))QueryInterface)(v15, *(_QWORD *)&v18.byte0, *(_QWORD *)&v18.byte8, &v30))
          {
            v19 = v30;
            if (v30)
            {
              *(_QWORD *)(v7 + 296) = v30;
              if (!(*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)v19 + 32))(v19, 0))
              {
                *(_BYTE *)(v7 + 304) = 1;
                (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v30 + 80))(v30, *(_QWORD *)(v7 + 32));
                if (!(*(unsigned int (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v30 + 88))(v30, 255, 0)&& !(*(unsigned int (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v30 + 96))(v30, 42, 0)&& !(*(unsigned int (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v30 + 104))(v30, 255, 0)&& !(*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)v30 + 128))(v30, 2, 1, 0xFFFFFFFFLL, 10, 0, 0, v7 + 312)&& !(*(unsigned int (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)v30 + 128))(v30,
                        2,
                        0,
                        0xFFFFFFFFLL,
                        10,
                        0,
                        0,
                        v7 + 320)
                  && !(*(unsigned int (**)(uint64_t, _QWORD, _QWORD, void *))(*(_QWORD *)v30 + 72))(v30, usb_deviceHandleInterfaceMessage, 0, a1)&& !(*(unsigned int (**)(uint64_t, uint64_t (*)(), _QWORD, _QWORD, void *, void *, _QWORD, uint64_t))(*(_QWORD *)v30 + 64))(v30, usb_deviceHandleSetupAction, 0, 0, a1, a1, *(_QWORD *)(v7 + 136), v26)&& !(*(unsigned int (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v30 + 48))(v30, *(_QWORD *)(v7 + 136), v26))
                {
                  v28 = 0;
                  type = OS_LOG_TYPE_DEFAULT;
                  v20 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, (int *)&v28, &type);
                  v21 = v28;
                  if (os_log_type_enabled(v20, type) ? v21 : v21 & 0xFFFFFFFE)
                  {
                    v33 = 136315138;
                    v34 = "usb_deviceSetup";
                    v24 = (_BYTE *)_os_log_send_and_compose_impl();
                    LOBYTE(v21) = v28;
                  }
                  else
                  {
                    v24 = 0;
                  }
                  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v24, v24 != v35, v21, 0, v22);
                  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v30 + 136))(v30))
                  {
                    IOObjectRetain(v6);
                    *(_DWORD *)(v7 + 280) = v6;
                    v25 = (*(uint64_t (**)(uint64_t, char *, uint64_t *))(*(_QWORD *)v30 + 288))(v30, (char *)&v29 + 4, &v29);
                    if (!v25 && HIDWORD(v29))
                    {
                      usb_deviceActivate(a1);
                      goto LABEL_32;
                    }
                    if (!v25)
                      goto LABEL_32;
                  }
                }
              }
            }
          }
        }
      }
    }
    usb_deviceTearDown(a1);
LABEL_32:
    IOObjectRelease(v6);
    goto LABEL_33;
  }
  return result;
}

uint64_t usb_generalInterestNotification(const void *a1, uint64_t a2, int a3)
{
  uint64_t result;

  result = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (a3 == -536870896)
    return usb_deviceTearDown(a1);
  return result;
}

void usb_deviceHandleInterfaceMessage(uint64_t a1, int a2, uint64_t a3, const void *a4)
{
  if (a2 == -469794543)
  {
    usb_deviceDeactivate(a4);
  }
  else if (a2 == -469794544)
  {
    usb_deviceActivate(a4);
  }
}

uint64_t usb_deviceHandleSetupAction()
{
  return 0;
}

void usb_deviceActivate(const void *a1)
{
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  char v11;
  uint64_t v12;
  uint64_t BytePtr;
  uint64_t v14;
  uint64_t v15;
  char i;
  char v17;
  _QWORD v18[5];
  _QWORD aBlock[5];
  os_log_type_t type;
  uint64_t v21;
  int v22;
  const char *v23;
  char v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v21 = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, (int *)&v21, &type);
  v4 = v21;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v6 = v4;
  else
    v6 = v4 & 0xFFFFFFFE;
  if (v6)
  {
    v22 = 136315138;
    v23 = "usb_deviceActivate";
    v7 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v21;
  }
  else
  {
    v7 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != &v24, v4, 0, v5);
  if (!(*(unsigned int (**)(_QWORD, _QWORD, char *))(**(_QWORD **)(DerivedStorage + 296) + 200))(*(_QWORD *)(DerivedStorage + 296), *(_QWORD *)(DerivedStorage + 320), (char *)&v21 + 4))
  {
    v8 = MEMORY[0x1E0C809B0];
    *(_QWORD *)(DerivedStorage + 248) = SHIDWORD(v21);
    aBlock[0] = v8;
    aBlock[1] = 0x40000000;
    aBlock[2] = __usb_deviceActivate_block_invoke;
    aBlock[3] = &__block_descriptor_tmp_42;
    aBlock[4] = DerivedStorage;
    *(_QWORD *)(DerivedStorage + 232) = _Block_copy(aBlock);
    v18[0] = v8;
    v18[1] = 0x40000000;
    v18[2] = __usb_deviceActivate_block_invoke_2;
    v18[3] = &__block_descriptor_tmp_43;
    v18[4] = DerivedStorage;
    v9 = 0;
    *(_QWORD *)(DerivedStorage + 240) = _Block_copy(v18);
    v10 = 1;
    while (1)
    {
      v11 = v10;
      v12 = DerivedStorage + 24 * v9;
      *(_QWORD *)(v12 + 328) = a1;
      if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(DerivedStorage + 296) + 208))(*(_QWORD *)(DerivedStorage + 296), 0x10000, v12 + 336))
      {
        break;
      }
      BytePtr = IOUSBDeviceDataGetBytePtr();
      v10 = 0;
      *(_QWORD *)(DerivedStorage + 24 * v9 + 344) = BytePtr;
      v9 = 1;
      if ((v11 & 1) == 0)
      {
        if (!(*(unsigned int (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(DerivedStorage + 296) + 208))(*(_QWORD *)(DerivedStorage + 296), 0x10000, DerivedStorage + 384))
        {
          v14 = IOUSBDeviceDataGetBytePtr();
          v15 = 0;
          *(_QWORD *)(DerivedStorage + 392) = v14;
          for (i = 1; ; i = 0)
          {
            v17 = i;
            if ((*(unsigned int (**)(_QWORD, uint64_t))(*(_QWORD *)(DerivedStorage + 232) + 16))(*(_QWORD *)(DerivedStorage + 232), DerivedStorage + 24 * v15 + 328))
            {
              break;
            }
            v15 = 1;
            if ((v17 & 1) == 0)
            {
              *(_BYTE *)(DerivedStorage + 305) = 1;
              usb_deviceSendStartupPing((uint64_t)a1);
              return;
            }
          }
        }
        break;
      }
    }
  }
  usb_deviceDeactivate(a1);
}

uint64_t usb_deviceTearDown(const void *a1)
{
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v4;
  uint64_t v5;
  unsigned int v6;
  char *v7;
  io_object_t v8;
  uint64_t v9;
  IOCFPlugInInterface **v10;
  uint64_t result;
  os_log_type_t type;
  int v13[2];
  const char *v14;
  char v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v13[0] = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v13, &type);
  v4 = v13[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v6 = v4;
  else
    v6 = v4 & 0xFFFFFFFE;
  if (v6)
  {
    v13[1] = 136315138;
    v14 = "usb_deviceTearDown";
    v7 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v13[0];
  }
  else
  {
    v7 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != &v15, v4, 0, v5);
  usb_deviceDeactivate(a1);
  v8 = *(_DWORD *)(DerivedStorage + 276);
  if (v8)
  {
    IOObjectRelease(v8);
    *(_DWORD *)(DerivedStorage + 276) = 0;
  }
  if (*(_QWORD *)(DerivedStorage + 312))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(DerivedStorage + 296) + 192))(*(_QWORD *)(DerivedStorage + 296));
    *(_QWORD *)(DerivedStorage + 312) = 0;
  }
  if (*(_QWORD *)(DerivedStorage + 320))
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(DerivedStorage + 296) + 192))(*(_QWORD *)(DerivedStorage + 296));
    *(_QWORD *)(DerivedStorage + 320) = 0;
  }
  if (*(_BYTE *)(DerivedStorage + 304))
  {
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(DerivedStorage + 296) + 40))(*(_QWORD *)(DerivedStorage + 296), 0);
    *(_BYTE *)(DerivedStorage + 304) = 0;
  }
  v9 = *(_QWORD *)(DerivedStorage + 296);
  if (v9)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
    *(_QWORD *)(DerivedStorage + 296) = 0;
  }
  v10 = *(IOCFPlugInInterface ***)(DerivedStorage + 288);
  if (v10)
  {
    IODestroyPlugInInterface(v10);
    *(_QWORD *)(DerivedStorage + 288) = 0;
  }
  result = *(unsigned int *)(DerivedStorage + 280);
  if ((_DWORD)result)
  {
    result = IOObjectRelease(result);
    *(_DWORD *)(DerivedStorage + 280) = 0;
  }
  return result;
}

void usb_deviceDeactivate(const void *a1)
{
  uint64_t DerivedStorage;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v4;
  uint64_t v5;
  unsigned int v6;
  char *v7;
  char v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  const void *v12;
  _QWORD *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  os_log_type_t type;
  int v18[2];
  const char *v19;
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v18[0] = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v18, &type);
  v4 = v18[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v6 = v4;
  else
    v6 = v4 & 0xFFFFFFFE;
  if (v6)
  {
    v18[1] = 136315138;
    v19 = "usb_deviceDeactivate";
    v7 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v4) = v18[0];
  }
  else
  {
    v7 = 0;
  }
  v8 = 1;
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v7, v7 != &v20, v4, 0, v5);
  usb_setDisconnected(a1);
  v9 = 0;
  do
  {
    v10 = v8;
    v11 = DerivedStorage + 24 * v9;
    v12 = *(const void **)(v11 + 336);
    if (v12)
    {
      v13 = (_QWORD *)(v11 + 336);
      CFRelease(v12);
      *v13 = 0;
    }
    v8 = 0;
    v9 = 1;
  }
  while ((v10 & 1) != 0);
  v14 = *(const void **)(DerivedStorage + 232);
  if (v14)
  {
    _Block_release(v14);
    *(_QWORD *)(DerivedStorage + 232) = 0;
  }
  v15 = *(const void **)(DerivedStorage + 240);
  if (v15)
  {
    _Block_release(v15);
    *(_QWORD *)(DerivedStorage + 240) = 0;
  }
  v16 = *(const void **)(DerivedStorage + 384);
  if (v16)
  {
    CFRelease(v16);
    *(_QWORD *)(DerivedStorage + 384) = 0;
  }
  if (*(_BYTE *)(DerivedStorage + 305))
    *(_BYTE *)(DerivedStorage + 305) = 0;
}

uint64_t __usb_deviceActivate_block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t, uint64_t (*)(uint64_t *, int, size_t)))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 296) + 160))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 296), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 320), *(_QWORD *)(a2 + 8), 0x10000, usb_readCompleted);
}

uint64_t __usb_deviceActivate_block_invoke_2(uint64_t a1, int a2, char *__src, unint64_t a4, _QWORD *a5)
{
  unint64_t v7;
  uint64_t v9;
  size_t v10;
  uint64_t result;
  size_t v13;

  if (a4)
  {
    v7 = a4;
    v9 = 0;
    while (1)
    {
      v10 = v7 >= 0x10000 ? 0x10000 : v7;
      memcpy(*(void **)(*(_QWORD *)(a1 + 32) + 392), __src, v10);
      v13 = v10;
      result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, size_t *))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 296)
                                                                           + 168))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 296), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 312), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 384), &v13);
      if ((_DWORD)result)
        break;
      v9 += v13;
      v7 -= v13;
      __src += v13;
      if (v13 < v10 || v7 == 0)
      {
        result = 0;
        break;
      }
    }
  }
  else
  {
    v13 = 0;
    result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, size_t *))(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 296)
                                                                         + 168))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 296), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 312), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 384), &v13);
    v9 = 0;
  }
  *a5 = v9;
  return result;
}

void __usb_enqueuePackageWithPriority_block_invoke(uint64_t a1)
{
  OpaqueCMBlockBuffer *v2;
  uint64_t v3;
  OpaqueCMBlockBuffer *v4;
  OpaqueCMBlockBuffer **v5;
  OpaqueCMBlockBuffer *v6;

  v2 = *(OpaqueCMBlockBuffer **)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 32) + 8 * *(int *)(a1 + 56);
  v6 = *(OpaqueCMBlockBuffer **)(v3 + 48);
  v5 = (OpaqueCMBlockBuffer **)(v3 + 48);
  v4 = v6;
  if (v6)
  {
    CMBlockBufferAppendBufferReference(v4, v2, 0, 0, 0);
    CFRelease(*(CFTypeRef *)(a1 + 40));
  }
  else
  {
    *v5 = v2;
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(_QWORD *)(a1 + 32) + 200));
  CFRelease(*(CFTypeRef *)(a1 + 48));
}

uint64_t FigXPCCreateBasicMessage(unsigned int a1, uint64_t a2, _QWORD *a3)
{
  xpc_object_t v6;
  void *v7;
  uint64_t result;

  if (a1)
  {
    v6 = xpc_dictionary_create(0, 0, 0);
    v7 = v6;
    if (v6)
    {
      xpc_dictionary_set_uint64(v6, ".Operation", a1);
      if (a2)
        xpc_dictionary_set_uint64(v7, ".objectID", a2);
      result = 0;
    }
    else
    {
      result = FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    result = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    v7 = 0;
  }
  *a3 = v7;
  return result;
}

uint64_t FigXPCMessageGetOpCode(void *a1, _DWORD *a2)
{
  int uint64;
  uint64_t result;

  uint64 = xpc_dictionary_get_uint64(a1, ".Operation");
  if (!uint64)
    return 4294951145;
  result = 0;
  *a2 = uint64;
  return result;
}

uint64_t FigXPCSendStdCopyPropertyMessage(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  uint64_t v7;
  void *v8;
  uint64_t v9;
  xpc_object_t v11;
  int v12[2];
  CFTypeRef cf;

  *(_QWORD *)v12 = 0;
  cf = 0;
  v11 = 0;
  v7 = FigXPCCreateBasicMessage(0x2E637079u, a2, v12);
  if (!(_DWORD)v7)
  {
    v8 = *(void **)v12;
    v7 = FigXPCMessageSetCFString(*(void **)v12, ".PropertyName", a3);
    if (!(_DWORD)v7)
    {
      v7 = FigXPCRemoteClientSendSyncMessageCreatingReply(a1, (uint64_t)v8, &v11);
      if (!(_DWORD)v7)
        v7 = FigXPCMessageCopyCFObject(v11, ".Value", (__CFDictionary **)&cf);
    }
  }
  v9 = v7;
  if (a4)
  {
    *a4 = cf;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  FigXPCRelease(v11);
  FigXPCRelease(*(xpc_object_t *)v12);
  return v9;
}

uint64_t FigXPCRemoteClientSendSyncMessageCreatingReply(uint64_t a1, uint64_t a2, xpc_object_t *a3)
{
  uint64_t v4;
  xpc_object_t v5;
  BOOL v6;
  xpc_object_t object;

  object = 0;
  if (!a1 || !a2)
  {
    v4 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    if (!a3)
      return v4;
    goto LABEL_12;
  }
  v4 = FigXPCConnectionSendSyncMessageCreatingReply(*(_QWORD *)(a1 + 24), a2, &object);
  v5 = object;
  if ((_DWORD)v4)
    v6 = 1;
  else
    v6 = a3 == 0;
  if (v6 && object != 0)
  {
    object = 0;
    xpc_release(v5);
  }
  if (a3)
LABEL_12:
    *a3 = object;
  return v4;
}

uint64_t FigXPCSendStdSetPropertyMessage(uint64_t a1, uint64_t a2, const void *a3, const void *a4)
{
  uint64_t v7;
  void *v8;
  uint64_t v9;
  int v11[2];

  *(_QWORD *)v11 = 0;
  v7 = FigXPCCreateBasicMessage(0x2E736574u, a2, v11);
  v8 = *(void **)v11;
  if (!(_DWORD)v7)
  {
    v7 = FigXPCMessageSetCFString(*(void **)v11, ".PropertyName", a3);
    if (!(_DWORD)v7)
    {
      v7 = FigXPCMessageSetCFObject(v8, ".Value", a4);
      if (!(_DWORD)v7)
        v7 = FigXPCRemoteClientSendSyncMessageCreatingReply(a1, (uint64_t)v8, 0);
    }
  }
  v9 = v7;
  FigXPCRelease(v8);
  return v9;
}

uint64_t FigXPCRemoteClientSendSyncMessage(uint64_t a1, uint64_t a2)
{
  return FigXPCRemoteClientSendSyncMessageCreatingReply(a1, a2, 0);
}

uint64_t FigXPCHandleStdCopyPropertyMessage(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5;
  CFTypeRef v6;
  uint64_t (*v7)(uint64_t, CFTypeRef, _QWORD, CFTypeRef *);
  uint64_t v8;
  CFTypeRef v9;
  uint64_t v10;
  CFTypeRef cf;
  CFTypeRef v13;

  cf = 0;
  v13 = 0;
  v5 = FigXPCMessageCopyCFString(a2, ".PropertyName", &v13);
  if ((_DWORD)v5)
    goto LABEL_12;
  v6 = v13;
  if (!v13)
  {
    v5 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
LABEL_12:
    v10 = v5;
    goto LABEL_8;
  }
  v7 = *(uint64_t (**)(uint64_t, CFTypeRef, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 8)
                                                                         + 48);
  if (v7)
  {
    v8 = v7(a1, v6, *MEMORY[0x1E0C9AE00], &cf);
    v9 = cf;
    if (!(_DWORD)v8)
    {
      v10 = FigXPCMessageSetCFObject(a3, ".Value", cf);
      v9 = cf;
      if (!cf)
        goto LABEL_8;
      goto LABEL_6;
    }
    v10 = v8;
    if (cf)
LABEL_6:
      CFRelease(v9);
  }
  else
  {
    v10 = 4294954514;
  }
LABEL_8:
  if (v13)
    CFRelease(v13);
  return v10;
}

uint64_t FigXPCHandleStdSetPropertyMessage(uint64_t a1, void *a2)
{
  uint64_t v4;
  CFTypeRef v5;
  CFTypeRef v6;
  uint64_t (*v7)(uint64_t, CFTypeRef, CFTypeRef);
  uint64_t v8;
  CFTypeRef cf;
  CFTypeRef v11;

  cf = 0;
  v11 = 0;
  v4 = FigXPCMessageCopyCFString(a2, ".PropertyName", &v11);
  if ((_DWORD)v4)
    goto LABEL_6;
  if (!v11)
  {
    v4 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
    goto LABEL_6;
  }
  v4 = FigXPCMessageCopyCFObject(a2, ".Value", (__CFDictionary **)&cf);
  if ((_DWORD)v4)
  {
LABEL_6:
    v8 = v4;
    goto LABEL_8;
  }
  v6 = cf;
  v5 = v11;
  v7 = *(uint64_t (**)(uint64_t, CFTypeRef, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 8) + 56);
  if (v7)
  {
    v4 = v7(a1, v5, v6);
    goto LABEL_6;
  }
  v8 = 4294954514;
LABEL_8:
  if (cf)
    CFRelease(cf);
  if (v11)
    CFRelease(v11);
  return v8;
}

uint64_t FigXPCConnectionSendSyncMessageWithNoTimeoutCreatingReply(uint64_t a1, xpc_object_t xdict, _QWORD *a3)
{
  uint64_t uint64;
  uint64_t v8;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 80))
    {
      v8 = 4294951142;
      return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
    }
    if (xdict)
    {
      uint64 = xpc_dictionary_get_uint64(xdict, ".Operation");
      if (uint64)
      {
        xpc_dictionary_set_uint64(xdict, ".Operation", uint64 | 0x200000000);
        return FigXPCConnectionSendSyncMessageCreatingReply(a1, xdict, a3);
      }
    }
  }
  v8 = 4294951145;
  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCConnectionSendSyncMessageCreatingReply(uint64_t a1, void *a2, _QWORD *a3)
{
  unint64_t v6;
  int64_t v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  int64_t UpTimeNanoseconds;
  xpc_object_t v12;
  uint64_t v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  char __dst[8];
  uint64_t v19;
  uint64_t v20;

  v20 = 0;
  v6 = FigAtomicIncrement64(&FigXPCConnectionSendSyncMessageCreatingReply_sAbortActionID);
  if (!a1)
    goto LABEL_22;
  if (*(_DWORD *)(a1 + 80))
  {
    v16 = 4294951142;
    goto LABEL_24;
  }
  if (!a2)
  {
LABEL_22:
    v16 = 4294951145;
LABEL_24:
    v13 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    v12 = 0;
    goto LABEL_25;
  }
  v7 = v6;
  if (!*(_BYTE *)(a1 + 84))
  {
    xpc_dictionary_get_uint64(a2, ".Operation");
    if (gGMFigKTraceEnabled == 1)
    {
      v8 = *(_QWORD *)(a1 + 16);
      v9 = *(_QWORD *)(v8 + 16);
      if (v9)
      {
        v10 = strlen(*(const char **)(v8 + 16));
        strncpy(__dst, (const char *)(v10 + v9 - 8), 8uLL);
      }
      kdebug_trace();
    }
    UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    xpc_dictionary_set_int64(a2, ".Date", UpTimeNanoseconds);
  }
  *(_QWORD *)__dst = v7;
  v19 = a1;
  xpc_dictionary_set_int64(a2, ".AbortActionID", v7);
  FigThreadRegisterAbortAction((uint64_t (*)())figXPC_forwardThreadAbortForSyncMessage, (_opaque_pthread_t *)__dst, &v20);
  v12 = xpc_connection_send_message_with_reply_sync(*(xpc_connection_t *)(a1 + 40), a2);
  v13 = figXPCConnection_processServerReply(a1, v12);
  if (v20)
    FigThreadUnregisterAbortAction(v20);
  if (a3)
    v14 = (_DWORD)v13 == 0;
  else
    v14 = 0;
  v15 = !v14;
  if (!v12 || !v15)
  {
LABEL_25:
    if (a3)
      goto LABEL_26;
    return v13;
  }
  xpc_release(v12);
  if (a3)
  {
    v12 = 0;
LABEL_26:
    *a3 = v12;
  }
  return v13;
}

void figXPC_forwardThreadAbortForSyncMessage(int64_t *a1)
{
  id *v2;
  id *v3;
  int v4;
  xpc_object_t v5;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  char *v11;
  os_log_type_t type;
  int v13;
  xpc_object_t xdict;
  int v15;
  const char *v16;
  __int16 v17;
  uint64_t v18;
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  xdict = 0;
  v2 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1[1] + 24));
  if (v2)
  {
    v3 = v2;
    if (v2[4])
    {
      v4 = FigXPCCreateBasicMessage(0x2E737470u, 0, &xdict);
      v5 = xdict;
      if (!v4)
      {
        xpc_dictionary_set_int64(xdict, ".AbortActionID", *a1);
        FigXPCConnectionSendAsyncMessage((uint64_t)v3[4], v5);
      }
    }
    else
    {
      v13 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, &v13, &type);
      v7 = v13;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v9 = v7;
      else
        v9 = v7 & 0xFFFFFFFE;
      if (v9)
      {
        v10 = *((_QWORD *)v3[2] + 2);
        v15 = 136315394;
        v16 = "figXPC_forwardThreadAbortForSyncMessage";
        v17 = 2080;
        v18 = v10;
        v11 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v7) = v13;
      }
      else
      {
        v11 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v11, v11 != &v19, v7, 0, v8);
      v5 = 0;
    }
    FigXPCRelease(v5);
    CFRelease(v3);
  }
  else
  {
    FigXPCRelease(0);
  }
}

int64_t figXPCConnection_processServerReply(uint64_t a1, void *a2)
{
  int v4;
  uint64_t v5;
  uint64_t uint64;
  xpc_object_t value;
  void *v9;
  int v10;
  const void *v11;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t *v16;
  os_log_type_t type;
  int v18[2];
  const char *v19;
  __int16 v20;
  int v21;
  uint64_t v22[17];

  v22[16] = *MEMORY[0x1E0C80C00];
  if (MEMORY[0x193FFCDCC](a2) != MEMORY[0x1E0C812F8])
    return FigSignalErrorAt(4294951141, 0, 0, 0, 0, 0, 0);
  if (!*(_BYTE *)(a1 + 84))
  {
    if (gGMFigKTraceEnabled == 1)
    {
      xpc_connection_get_pid(*(xpc_connection_t *)(a1 + 40));
      kdebug_trace();
    }
    if (FigAtomicCompareAndSwap32(0, 1u, (unsigned int *)(a1 + 92)))
    {
      v4 = *(_DWORD *)(a1 + 88);
      *(_BYTE *)(a1 + 84) = 1;
      FigXPCConnectionGetServerPID(a1, (pid_t *)(a1 + 88));
      if (v4)
      {
        v5 = *(_QWORD *)(a1 + 16);
        if ((*(_QWORD *)(v5 + 120) & 1) != 0)
          goto LABEL_11;
      }
      else
      {
        uint64 = xpc_dictionary_get_uint64(a2, ".ServerCapabilities");
        v5 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(v5 + 120) = uint64;
        if ((uint64 & 1) != 0)
        {
LABEL_11:
          *(_BYTE *)(v5 + 105) = 1;
          goto LABEL_12;
        }
      }
      if (*(_BYTE *)(a1 + 85))
        goto LABEL_11;
      if (!*(_BYTE *)(v5 + 105))
      {
        value = xpc_dictionary_get_value(a2, ".ProcessStateMonitorEndpoint");
        if (value && (v9 = value, MEMORY[0x193FFCDCC]() == MEMORY[0x1E0C81308]))
        {
          v22[0] = 0;
          v10 = FigProcessStateMonitorCopyRemoteStateMonitor(v9, *(_DWORD *)(a1 + 88), *(_DWORD *)(*(_QWORD *)(a1 + 16) + 120) & 2, v22);
          if (!v10)
          {
            FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 96));
            v11 = *(const void **)(a1 + 104);
            if (v11)
              CFRelease(v11);
            *(_QWORD *)(a1 + 104) = v22[0];
            FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 96));
          }
          if (!v10)
            goto LABEL_12;
        }
        else
        {
          v10 = FigSignalErrorAt(4294951137, 0, 0, 0, 0, 0, 0);
          if (!v10)
            goto LABEL_12;
        }
        v18[0] = 0;
        type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v18, &type);
        v13 = v18[0];
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
          v15 = v13;
        else
          v15 = v13 & 0xFFFFFFFE;
        if (v15)
        {
          v18[1] = 136315394;
          v19 = "figXPCConnection_handleServerLaunchOrRelaunch";
          v20 = 1024;
          v21 = v10;
          v16 = (uint64_t *)_os_log_send_and_compose_impl();
          LOBYTE(v13) = v18[0];
        }
        else
        {
          v16 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v16, v16 != v22, v13, 0, v14);
        FigAtomicCompareAndSwap32(1, 0, (unsigned int *)(a1 + 92));
      }
    }
  }
LABEL_12:
  if (!*(_QWORD *)(a1 + 64))
    *(_QWORD *)(a1 + 64) = xpc_dictionary_get_int64(a2, ".Token");
  return xpc_dictionary_get_int64(a2, ".ErrorReturn");
}

uint64_t FigXPCConnectionSendSyncMessage(uint64_t a1, void *a2)
{
  return FigXPCConnectionSendSyncMessageCreatingReply(a1, a2, 0);
}

uint64_t FigXPCConnectionSendAsyncMessage(uint64_t a1, xpc_object_t xdict)
{
  uint64_t uint64;
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  int64_t UpTimeNanoseconds;
  uint64_t v10;
  char __dst[8];

  if (!a1)
    goto LABEL_12;
  if (*(_DWORD *)(a1 + 80))
  {
    v10 = 4294951142;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  if (!xdict || (uint64 = xpc_dictionary_get_uint64(xdict, ".Operation")) == 0)
  {
LABEL_12:
    v10 = 4294951145;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  xpc_dictionary_set_uint64(xdict, ".Operation", uint64 | 0x100000000);
  if (!*(_BYTE *)(a1 + 84))
  {
    if (gGMFigKTraceEnabled == 1)
    {
      v5 = *(_QWORD *)(a1 + 16);
      v6 = *(_QWORD *)(v5 + 16);
      if (v6)
      {
        v7 = strlen(*(const char **)(v5 + 16));
        strncpy(__dst, (const char *)(v7 + v6 - 8), 8uLL);
      }
      kdebug_trace();
    }
    UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    xpc_dictionary_set_int64(xdict, ".Date", UpTimeNanoseconds);
  }
  xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), xdict);
  return 0;
}

uint64_t FigXPCConnectionSendAsyncMessageWithReplyHandler(uint64_t a1, xpc_object_t xdict, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  int64_t UpTimeNanoseconds;
  _xpc_connection_s *v10;
  NSObject *v11;
  uint64_t v13;
  _QWORD handler[6];
  char __dst[8];

  if (!a1)
    goto LABEL_12;
  if (*(_DWORD *)(a1 + 80))
  {
    v13 = 4294951142;
    return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
  }
  if (!xdict || !a3)
  {
LABEL_12:
    v13 = 4294951145;
    return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
  }
  if (!*(_BYTE *)(a1 + 84))
  {
    xpc_dictionary_get_uint64(xdict, ".Operation");
    if (gGMFigKTraceEnabled == 1)
    {
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_QWORD *)(v6 + 16);
      if (v7)
      {
        v8 = strlen(*(const char **)(v6 + 16));
        strncpy(__dst, (const char *)(v8 + v7 - 8), 8uLL);
      }
      kdebug_trace();
    }
    UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    xpc_dictionary_set_int64(xdict, ".Date", UpTimeNanoseconds);
  }
  v10 = *(_xpc_connection_s **)(a1 + 40);
  v11 = *(NSObject **)(a1 + 72);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 0x40000000;
  handler[2] = __FigXPCConnectionSendAsyncMessageWithReplyHandler_block_invoke;
  handler[3] = &unk_1E28E5830;
  handler[4] = a3;
  handler[5] = a1;
  xpc_connection_send_message_with_reply(v10, xdict, v11, handler);
  return 0;
}

uint64_t FigXPCConnectionSendAsyncMessageWithNoTimeoutWithReplyHandler(uint64_t a1, xpc_object_t xdict, uint64_t a3)
{
  uint64_t uint64;
  uint64_t v8;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 80))
    {
      v8 = 4294951142;
      return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
    }
    if (xdict)
    {
      if (a3)
      {
        uint64 = xpc_dictionary_get_uint64(xdict, ".Operation");
        if (uint64)
        {
          xpc_dictionary_set_uint64(xdict, ".Operation", uint64 | 0x200000000);
          return FigXPCConnectionSendAsyncMessageWithReplyHandler(a1, xdict, a3);
        }
      }
    }
  }
  v8 = 4294951145;
  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCConnectionSetCustomServerTimeoutPerConnection(uint64_t a1, int64_t a2)
{
  uint64_t v4;
  xpc_object_t v5;
  uint64_t v6;
  xpc_object_t xdict;

  xdict = 0;
  v4 = FigXPCCreateBasicMessage(0x2E746F21u, 0, &xdict);
  v5 = xdict;
  if (!(_DWORD)v4)
  {
    xpc_dictionary_set_int64(xdict, ".SelfTerminationTimeout", a2);
    v4 = FigXPCConnectionSendAsyncMessage(a1, v5);
  }
  v6 = v4;
  FigXPCRelease(v5);
  return v6;
}

uint64_t FigXPCConnectionAssociateObject(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t result;
  uint64_t v7;

  if (!a1)
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  result = FigCFWeakReferenceTableAddValueAssociatedWithKey(*(_QWORD *)(a1 + 32), a2, (uint64_t)a3);
  if (!(_DWORD)result)
  {
    result = FigCFWeakReferenceTableAddValueAssociatedWithKey(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 112), a2, (uint64_t)a3);
    if (!(_DWORD)result)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 96));
      v7 = *(_QWORD *)(a1 + 104);
      if (v7)
        FigProcessStateMonitorRemoteAssociateObject(v7, a3);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 96));
      return 0;
    }
  }
  return result;
}

uint64_t FigXPCConnectionDisassociateObject(uint64_t a1, const void *a2)
{
  uint64_t result;
  uint64_t v5;

  if (!a1)
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  if (!a2)
    return 0;
  result = FigCFWeakReferenceTableRemoveValue(*(_QWORD *)(a1 + 32), (uint64_t)a2);
  if (!(_DWORD)result)
  {
    result = FigCFWeakReferenceTableRemoveValue(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 112), (uint64_t)a2);
    if (!(_DWORD)result)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 96));
      v5 = *(_QWORD *)(a1 + 104);
      if (v5)
        FigProcessStateMonitorRemoteDisassociateObject(v5, a2);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 96));
      return 0;
    }
  }
  return result;
}

uint64_t FigXPConnectionLookupAndRetainAssociatedObject(uint64_t a1, void *a2, _QWORD *a3)
{
  id v4;
  uint64_t v6;

  if (a1)
  {
    v4 = FigCFWeakReferenceTableCopyValue(*(_QWORD *)(a1 + 32), a2);
    *a3 = v4;
    if (v4)
      return 0;
    v6 = 4294951144;
  }
  else
  {
    v6 = 4294951145;
  }
  return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCConnectionRetainCopiedObject(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  CFTypeRef v7;
  uint64_t v8;
  xpc_object_t v9;
  xpc_object_t xdict;
  unint64_t v12;
  CFTypeRef cf;
  uint64_t v14;

  v12 = 0;
  cf = 0;
  v14 = 0;
  if (a1)
  {
    v12 = a2 & 0xFFFFFFFFFFFFFF00;
    v6 = FigCFWeakReferenceTableApplyFunction(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 112), (void (*)(_QWORD, CFTypeRef, uint64_t))figXPC_RetainCopiedObjectApplierFunction, (uint64_t)&v12);
    if ((_DWORD)v6)
      goto LABEL_8;
    v7 = cf;
    if (!cf || v14 == a2)
      goto LABEL_7;
    xdict = 0;
    v8 = FigXPCCreateBasicMessage(0x2E6E6370u, a2, &xdict);
    if (!(_DWORD)v8)
    {
      v9 = xdict;
      v6 = FigXPCConnectionSendAsyncMessage(a1, xdict);
      FigXPCRelease(v9);
      v7 = cf;
LABEL_7:
      *a3 = v7;
      cf = 0;
      goto LABEL_8;
    }
  }
  else
  {
    v8 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  }
  v6 = v8;
LABEL_8:
  if (cf)
    CFRelease(cf);
  return v6;
}

uint64_t figXPC_RetainCopiedObjectApplierFunction(uint64_t result, CFTypeRef cf, _QWORD *a3)
{
  uint64_t v4;

  if (!a3[1])
  {
    v4 = result;
    if (*a3 == (result & 0xFFFFFFFFFFFFFF00))
    {
      result = (uint64_t)CFRetain(cf);
      a3[1] = result;
      a3[2] = v4;
    }
  }
  return result;
}

uint64_t FigXPCConnectionSendStdCopyPropertyMessage(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v11;
  int v12[2];
  CFTypeRef cf;

  *(_QWORD *)v12 = 0;
  cf = 0;
  v11 = 0;
  v7 = FigXPCCreateBasicMessage(0x2E637079u, a2, v12);
  if (!(_DWORD)v7)
  {
    v8 = *(void **)v12;
    v7 = FigXPCMessageSetCFString(*(void **)v12, ".PropertyName", a3);
    if (!(_DWORD)v7)
    {
      v7 = FigXPCConnectionSendSyncMessageCreatingReply(a1, v8, &v11);
      if (!(_DWORD)v7)
        v7 = FigXPCMessageCopyCFObject(v11, ".Value", (__CFDictionary **)&cf);
    }
  }
  v9 = v7;
  if (a4)
  {
    *a4 = cf;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  FigXPCRelease(v11);
  FigXPCRelease(*(xpc_object_t *)v12);
  return v9;
}

uint64_t FigXPCConnectionSendStdSetPropertyMessage(uint64_t a1, uint64_t a2, const void *a3, const void *a4)
{
  uint64_t v7;
  void *v8;
  uint64_t v9;
  int v11[2];

  *(_QWORD *)v11 = 0;
  v7 = FigXPCCreateBasicMessage(0x2E736574u, a2, v11);
  v8 = *(void **)v11;
  if (!(_DWORD)v7)
  {
    v7 = FigXPCMessageSetCFString(*(void **)v11, ".PropertyName", a3);
    if (!(_DWORD)v7)
    {
      v7 = FigXPCMessageSetCFObject(v8, ".Value", a4);
      if (!(_DWORD)v7)
        v7 = FigXPCConnectionSendSyncMessageCreatingReply(a1, v8, 0);
    }
  }
  v9 = v7;
  FigXPCRelease(v8);
  return v9;
}

uint64_t FigXPCConnectionGetServerPID(uint64_t a1, pid_t *a2)
{
  pid_t pid;

  pid = xpc_connection_get_pid(*(xpc_connection_t *)(a1 + 40));
  *a2 = pid;
  if (pid)
    return 0;
  else
    return FigSignalErrorAt(4294951137, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCConnectionCopyMemoryOriginForConnectedProcess(uint64_t a1, CFTypeRef *a2)
{
  const void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v9;
  void *v10;

  v9 = 0;
  v10 = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(*(_QWORD *)(a1 + 16) + 128));
  v4 = *(const void **)(*(_QWORD *)(a1 + 16) + 136);
  if (v4)
  {
    v5 = 0;
  }
  else
  {
    v6 = FigXPCCreateBasicMessage(0x2E6F7267u, 0, &v10);
    v5 = v10;
    if ((_DWORD)v6
      || (v6 = FigMemoryOriginBeginEstablishingMemoryRecipientByFillingInXPCMessage1(v10), (_DWORD)v6)
      || (v6 = FigXPCConnectionSendSyncMessageCreatingReply(a1, v5, &v9), (_DWORD)v6)
      || (v6 = FigMemoryOriginCompleteEstablishingMemoryRecipientUsingXPCMessage2(v9, (_QWORD *)(*(_QWORD *)(a1 + 16) + 136)), (_DWORD)v6))
    {
      v7 = v6;
      goto LABEL_9;
    }
    v4 = *(const void **)(*(_QWORD *)(a1 + 16) + 136);
  }
  v7 = 0;
  *a2 = CFRetain(v4);
LABEL_9:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(*(_QWORD *)(a1 + 16) + 128));
  FigXPCRelease(v5);
  FigXPCRelease(v9);
  return v7;
}

uint64_t FigXPCConnectionCopyMemoryRecipientForConnectedProcess(uint64_t a1, CFTypeRef *a2)
{
  const void *v4;
  void *v5;
  uint64_t updated;
  void *v7;
  uint64_t v8;
  void *v10;
  xpc_object_t v11;
  void *v12;

  v11 = 0;
  v12 = 0;
  v10 = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(*(_QWORD *)(a1 + 16) + 128));
  v4 = *(const void **)(*(_QWORD *)(a1 + 16) + 144);
  if (v4)
  {
    v5 = 0;
  }
  else
  {
    updated = FigXPCCreateBasicMessage(0x2E727031u, 0, &v12);
    v5 = v12;
    if ((_DWORD)updated
      || (updated = FigXPCConnectionSendSyncMessageCreatingReply(a1, v12, &v11), (_DWORD)updated)
      || (updated = FigXPCCreateBasicMessage(0x2E727032u, 0, &v10), (_DWORD)updated)
      || (v7 = v10,
          updated = FigMemoryRecipientCreateWithXPCMessage1AndUpdateXPCMessage2(v11, v10, *(const char **)(*(_QWORD *)(a1 + 16) + 16), (uint64_t **)(*(_QWORD *)(a1 + 16) + 144)), (_DWORD)updated)|| (updated = FigXPCConnectionSendSyncMessageCreatingReply(a1, v7, 0), (_DWORD)updated))
    {
      v8 = updated;
      goto LABEL_10;
    }
    v4 = *(const void **)(*(_QWORD *)(a1 + 16) + 144);
  }
  v8 = 0;
  *a2 = CFRetain(v4);
LABEL_10:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(*(_QWORD *)(a1 + 16) + 128));
  FigXPCRelease(v5);
  FigXPCRelease(v11);
  FigXPCRelease(v10);
  return v8;
}

uint64_t FigXPCConnectionCreateAssociatedEventLink(_DWORD *a1, uint64_t a2, unsigned int a3, int a4, CFTypeRef *a5)
{
  uint64_t v9;
  uint64_t v10;
  xpc_object_t v11;
  int v12;
  CFTypeRef v13;
  uint64_t v14;
  uint64_t v16;
  void *v17;
  xpc_object_t xdict;
  CFTypeRef v19;
  CFTypeRef cf;
  CFTypeRef v21;

  cf = 0;
  v21 = 0;
  xdict = 0;
  v19 = 0;
  v17 = 0;
  if (!a1)
  {
    v16 = 4294951145;
LABEL_20:
    v9 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
LABEL_21:
    v14 = v9;
    v11 = 0;
    goto LABEL_9;
  }
  if (a1[20])
  {
    v16 = 4294951142;
    goto LABEL_20;
  }
  v9 = FigXPCConnectionCopyMemoryOriginForConnectedProcess((uint64_t)a1, &v21);
  if ((_DWORD)v9)
    goto LABEL_21;
  v9 = FigXPCConnectionCopyMemoryRecipientForConnectedProcess((uint64_t)a1, &cf);
  if ((_DWORD)v9)
    goto LABEL_21;
  v10 = FigXPCCreateBasicMessage(0x2E656C73u, 0, &xdict);
  v11 = xdict;
  if ((_DWORD)v10
    || (xpc_dictionary_set_uint64(xdict, "ServerEventLinkFigThreadPriority", a3),
        xpc_dictionary_set_int64(v11, "ServerEventLinkMachThreadPriority", a4),
        v10 = FigXPCConnectionSendSyncMessageCreatingReply((uint64_t)a1, v11, &v17),
        (_DWORD)v10))
  {
    v14 = v10;
  }
  else
  {
    v12 = CFGetAllocator(a1);
    v13 = v21;
    v14 = FigOSEventLinkRemoteCreateFromXPCObject(v12, v17, v21, cf, (uint64_t *)&v19);
    if ((_DWORD)v14)
      goto LABEL_10;
    *a5 = v19;
    v19 = 0;
  }
LABEL_9:
  v13 = v21;
LABEL_10:
  FigXPCRelease(v11);
  FigXPCRelease(v17);
  if (v13)
    CFRelease(v13);
  if (cf)
    CFRelease(cf);
  if (v19)
    CFRelease(v19);
  return v14;
}

uint64_t FigXPCServerCreateAssociatedEventLinkForConnection(_xpc_connection_s *a1, int a2, const void *a3, const void *a4, uint64_t a5, unsigned int a6, int a7, CFTypeRef *a8)
{
  _xpc_connection_s *v8;
  uint64_t v15;
  xpc_object_t v16;
  uint64_t v17;
  xpc_object_t xdict;
  CFTypeRef cf;

  v8 = a1;
  xdict = 0;
  cf = 0;
  if (a1)
  {
    v15 = FigXPCCreateBasicMessage(0x2E656C63u, 0, &xdict);
    v16 = xdict;
    if ((_DWORD)v15)
    {
      v17 = v15;
      v8 = 0;
    }
    else
    {
      xpc_dictionary_set_uint64(xdict, "ServerEventLinkFigThreadPriority", a6);
      xpc_dictionary_set_int64(v16, "ServerEventLinkMachThreadPriority", a7);
      v8 = (_xpc_connection_s *)xpc_connection_send_message_with_reply_sync(v8, v16);
      if (v8)
      {
        v17 = FigOSEventLinkRemoteCreateFromXPCObject(a2, v8, a3, a4, (uint64_t *)&cf);
        if (!(_DWORD)v17)
        {
          *a8 = cf;
          cf = 0;
        }
      }
      else
      {
        v17 = FigSignalErrorAt(4294951137, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  else
  {
    v17 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    v16 = 0;
  }
  FigXPCRelease(v16);
  FigXPCRelease(v8);
  if (cf)
    CFRelease(cf);
  return v17;
}

uint64_t FigXPCRemoteClientSendSyncMessageWithNoTimeoutCreatingReply(uint64_t a1, void *a2, _QWORD *a3)
{
  if (a1 && a2)
    return FigXPCConnectionSendSyncMessageWithNoTimeoutCreatingReply(*(_QWORD *)(a1 + 24), a2, a3);
  else
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCRemoteClientSendAsyncMessage(uint64_t a1, void *a2)
{
  if (a1 && a2)
    return FigXPCConnectionSendAsyncMessage(*(_QWORD *)(a1 + 24), a2);
  else
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCRemoteClientSendAsyncMessageWithReplyHandler(uint64_t a1, void *a2, uint64_t a3)
{
  if (a1 && a2 && a3)
    return FigXPCConnectionSendAsyncMessageWithReplyHandler(*(_QWORD *)(a1 + 24), a2, a3);
  else
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCRemoteClientSendAsyncMessageWithNoTimeoutWithReplyHandler(uint64_t a1, void *a2, uint64_t a3)
{
  if (a1 && a2 && a3)
    return FigXPCConnectionSendAsyncMessageWithNoTimeoutWithReplyHandler(*(_QWORD *)(a1 + 24), a2, a3);
  else
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCRemoteClientDisassociateObject(uint64_t a1, const void *a2)
{
  if (!a1)
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  if (a2)
    return FigXPCConnectionDisassociateObject(*(_QWORD *)(a1 + 24), a2);
  return 0;
}

uint64_t FigXPCRemoteClientAssociateObject(uint64_t a1, uint64_t a2, const void *a3)
{
  if (a1)
    return FigXPCConnectionAssociateObject(*(_QWORD *)(a1 + 24), a2, a3);
  else
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCRemoteClientLookupAndRetainAssociatedObject(uint64_t a1, void *a2, _QWORD *a3)
{
  if (a1)
    return FigXPConnectionLookupAndRetainAssociatedObject(*(_QWORD *)(a1 + 24), a2, a3);
  else
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCRemoteClientRetainCopiedObject(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  if (a1)
    return FigXPCConnectionRetainCopiedObject(*(_QWORD *)(a1 + 24), a2, a3);
  else
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCRemoteClientCreate(uint64_t a1, uint64_t a2, CFDictionaryRef theDict, _QWORD *a4)
{
  uint64_t v8;
  _QWORD v10[6];

  if (theDict)
    v8 = 2
       * (CFDictionaryGetValue(theDict, CFSTR("xpcRemoteClientOption_PrivilegedConnection")) == (const void *)*MEMORY[0x1E0C9AE50]);
  else
    v8 = 0;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = __FigXPCRemoteClientCreate_block_invoke;
  v10[3] = &__block_descriptor_tmp_62;
  v10[4] = a1;
  v10[5] = v8;
  return FigXPCRemoteClientCreateWithConnectionCreatingBlock(a1, a2, theDict, 0, a4, (uint64_t)v10);
}

uint64_t FigXPCRemoteClientCreateWithConnectionCreatingBlock(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, _QWORD *a5, uint64_t a6)
{
  const __CFAllocator *v12;
  uint64_t Instance;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const __CFDictionary *v18;
  const __CFString *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  BOOL v24;
  __CFNotificationCenter *DefaultLocalCenter;
  CFTypeRef cf;

  cf = 0;
  if (figXPC_RemoteClientOneTimeInitialization_sInitFigXPCRemoteClientOnce != -1)
    dispatch_once(&figXPC_RemoteClientOneTimeInitialization_sInitFigXPCRemoteClientOnce, &__block_literal_global_73_0);
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (figXPCRemoteClient_GetTypeID_sRegisterFigXPCRemoteClientTypeOnce != -1)
    dispatch_once(&figXPCRemoteClient_GetTypeID_sRegisterFigXPCRemoteClientTypeOnce, &__block_literal_global_77);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v14 = (_QWORD *)Instance;
    if ((unint64_t)(*(_QWORD *)a2 - 1) > 3)
    {
      v20 = 4294951145;
    }
    else
    {
      if (figXPCClientConnectionInfo_GetTypeID_sRegisterFigXPCClientConnectionInfoTypeOnce != -1)
        dispatch_once(&figXPCClientConnectionInfo_GetTypeID_sRegisterFigXPCClientConnectionInfoTypeOnce, &__block_literal_global_82);
      v15 = _CFRuntimeCreateInstance();
      if (v15)
      {
        v16 = v15;
        v17 = FigCFWeakReferenceTableCreate(v12, 1, (uint64_t *)(v15 + 112));
        if ((_DWORD)v17)
        {
          v22 = v17;
          goto LABEL_32;
        }
        if (a3)
        {
          v18 = (const __CFDictionary *)CFRetain(a3);
          v19 = CFSTR("SomeServerDiedSomewhere");
          *(_QWORD *)(v16 + 96) = CFSTR("SomeServerDiedSomewhere");
          *(_QWORD *)(v16 + 88) = v18;
          *(_QWORD *)(v16 + 16) = a1;
          if (v18)
          {
            CFDictionaryGetValueIfPresent(v18, CFSTR("xpcRemoteClientOption_DeathNoticeName"), (const void **)(v16 + 96));
            FigCFDictionaryGetBooleanIfPresent(*(_QWORD *)(v16 + 88), CFSTR("xpcRemoteClientOption_FilterHandlesNotificationsForUnknownObjects"), (Boolean *)(v16 + 104));
            FigCFDictionaryGetBooleanIfPresent(*(_QWORD *)(v16 + 88), CFSTR("xpcRemoteClientOption_DoNotMonitorConnection"), (Boolean *)(v16 + 105));
            v19 = *(const __CFString **)(v16 + 96);
            if (!v19)
            {
LABEL_20:
              *(_QWORD *)(v16 + 128) = FigSimpleMutexCreate();
              *(_QWORD *)(v16 + 24) = *(_QWORD *)a2;
              *(_OWORD *)(v16 + 32) = *(_OWORD *)(a2 + 8);
              *(_OWORD *)(v16 + 48) = *(_OWORD *)(a2 + 24);
              v23 = *(_QWORD *)a2;
              v24 = *(_QWORD *)a2 == 2;
              if (*(_QWORD *)a2 >= 2uLL)
              {
                *(_QWORD *)(v16 + 64) = *(_QWORD *)(a2 + 40);
                if (!v24)
                {
                  *(_QWORD *)(v16 + 72) = *(_QWORD *)(a2 + 48);
                  if (v23 >= 4)
                    *(_QWORD *)(v16 + 80) = *(_QWORD *)(a2 + 56);
                }
              }
LABEL_24:
              v14[2] = v16;
              v22 = figXPCCreateXPCConnectionInternal((uint64_t)v14, v16, a4, (uint64_t *)&cf, a6);
              v16 = (uint64_t)cf;
              if (!(_DWORD)v22)
              {
                v14[3] = cf;
                DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
                FigNotificationCenterAddWeakListener(DefaultLocalCenter, v14, (CFNotificationCallback)figXPCRemoteClient_PrimaryConnectionNotificationCallback, 0, v14[3], 0, 0);
                *a5 = v14;
                return v22;
              }
              if (!cf)
              {
LABEL_33:
                CFRelease(v14);
                return v22;
              }
LABEL_32:
              CFRelease((CFTypeRef)v16);
              goto LABEL_33;
            }
          }
        }
        else
        {
          *(_QWORD *)(v16 + 16) = a1;
          v19 = CFSTR("SomeServerDiedSomewhere");
          *(_QWORD *)(v16 + 88) = 0;
          *(_QWORD *)(v16 + 96) = CFSTR("SomeServerDiedSomewhere");
        }
        CFRetain(v19);
        goto LABEL_20;
      }
      v20 = 4294951146;
    }
    v21 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
    v16 = 0;
    if ((_DWORD)v21)
    {
      v22 = v21;
      goto LABEL_33;
    }
    goto LABEL_24;
  }
  return FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCRemoteClientCreateWithXPCService(uint64_t a1, uint64_t a2, const void *a3, _QWORD *a4)
{
  _QWORD v5[5];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __FigXPCRemoteClientCreateWithXPCService_block_invoke;
  v5[3] = &__block_descriptor_tmp_63;
  v5[4] = a1;
  return FigXPCRemoteClientCreateWithConnectionCreatingBlock(a1, a2, a3, 0x400000000, a4, (uint64_t)v5);
}

uint64_t FigXPCRemoteClientCreateWithXPCEndpoint(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD v6[5];

  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __FigXPCRemoteClientCreateWithXPCEndpoint_block_invoke;
  v6[3] = &__block_descriptor_tmp_64;
  v6[4] = a2;
  return FigXPCRemoteClientCreateWithConnectionCreatingBlock(a1, a3, a4, 0x400000000, a5, v6);
}

void FigXPCRemoteClientDispose(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t FigXPCRemoteClientGetServerPID(uint64_t a1, _DWORD *a2)
{
  if (!a1)
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  *a2 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 88);
  return 0;
}

uint64_t FigXPCRemoteClientCopyMemoryOrigin(uint64_t a1, CFTypeRef *a2)
{
  return FigXPCConnectionCopyMemoryOriginForConnectedProcess(*(_QWORD *)(a1 + 24), a2);
}

uint64_t FigXPCRemoteClientCopyMemoryRecipient(uint64_t a1, CFTypeRef *a2)
{
  return FigXPCConnectionCopyMemoryRecipientForConnectedProcess(*(_QWORD *)(a1 + 24), a2);
}

uint64_t FigXPCRemoteClientCopyPrimaryConnection(uint64_t a1, CFTypeRef *a2)
{
  _DWORD *v2;
  uint64_t v4;

  if (a1)
  {
    v2 = *(_DWORD **)(a1 + 24);
    if (v2 && !v2[20])
    {
      *a2 = CFRetain(v2);
      return 0;
    }
    v4 = 4294951142;
  }
  else
  {
    v4 = 4294951145;
  }
  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCRemoteClientCreateSecondaryConnection(uint64_t a1, unsigned int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[5];
  CFTypeRef v9;

  v9 = 0;
  v5 = *(_QWORD *)(a1 + 16);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __FigXPCRemoteClientCreateSecondaryConnection_block_invoke;
  v8[3] = &__block_descriptor_tmp_65;
  v8[4] = a1;
  v6 = figXPCCreateXPCConnectionInternal(a1, v5, a2 | 0x600000000, (uint64_t *)&v9, (uint64_t)v8);
  if ((_DWORD)v6)
  {
    if (v9)
      CFRelease(v9);
  }
  else
  {
    *a4 = v9;
  }
  return v6;
}

uint64_t figXPCCreateXPCConnectionInternal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v10;
  const __CFAllocator *v11;
  uint64_t Instance;
  uint64_t v13;
  CFTypeRef v14;
  pthread_mutex_t *v15;
  uint64_t v16;
  NSObject *SerialDispatchQueueWithPriority;
  _xpc_connection_s *v18;
  _xpc_connection_s *v19;
  _QWORD *v20;
  void *v21;
  _BOOL4 IsServerProcess;
  uint64_t v23;
  pid_t v24;
  xpc_object_t v25;
  uint64_t v26;
  uint64_t v28;
  _QWORD handler[5];
  unsigned int v30;
  int v31;
  char *v32;
  char *v33;
  char *v34;
  xpc_object_t v35;
  xpc_object_t xdict;
  _OWORD buffer[8];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v33 = 0;
  v34 = 0;
  v32 = 0;
  v30 = -1;
  v31 = 0;
  v10 = *(_QWORD *)(a2 + 88);
  if (v10)
    FigCFDictionaryGetInt32IfPresent(v10, CFSTR("xpcRemoteClientOption_QueuePriority"), &v30);
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (figXPCConnection_GetTypeID_sRegisterFigXPCConnectionTypeOnce != -1)
    dispatch_once(&figXPCConnection_GetTypeID_sRegisterFigXPCConnectionTypeOnce, &__block_literal_global_94);
  Instance = _CFRuntimeCreateInstance();
  v13 = Instance;
  if (!a1)
  {
    v26 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    if (!v13)
      goto LABEL_26;
    goto LABEL_34;
  }
  if (!Instance)
  {
    v26 = FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
    goto LABEL_26;
  }
  *(_QWORD *)(Instance + 16) = CFRetain((CFTypeRef)a2);
  *(_BYTE *)(v13 + 86) = (a3 & 0x400000000) != 0;
  v14 = FigCFWeakReferenceHolderCreateWithReferencedObject(a1);
  *(_QWORD *)(v13 + 24) = v14;
  if (!v14)
    goto LABEL_27;
  v15 = FigSimpleMutexCreate();
  *(_QWORD *)(v13 + 96) = v15;
  if (!v15)
    goto LABEL_27;
  v16 = FigCFWeakReferenceTableCreate(v11, 1, (uint64_t *)(v13 + 32));
  if ((_DWORD)v16)
  {
LABEL_33:
    v26 = v16;
LABEL_34:
    CFRelease((CFTypeRef)v13);
    goto LABEL_26;
  }
  if ((a3 & 0x200000000) != 0)
  {
    *(_BYTE *)(v13 + 85) = 1;
    asprintf(&v34, "%s.secondary.%p.notifications", *(const char **)(a2 + 16), (const void *)v13);
    asprintf(&v33, "%s.secondary.%p.connection", *(const char **)(a2 + 16), (const void *)v13);
    asprintf(&v32, "%s.secondary.%p.clientMessages");
  }
  else
  {
    asprintf(&v34, "%s.notifications", *(const char **)(a2 + 16));
    asprintf(&v33, "%s.connections", *(const char **)(a2 + 16));
    asprintf(&v32, "%s.clientMessages");
  }
  *(_QWORD *)(v13 + 56) = figXPC_CreateSerialDispatchQueueWithPriority(v34, v30);
  SerialDispatchQueueWithPriority = figXPC_CreateSerialDispatchQueueWithPriority(v33, v30);
  *(_QWORD *)(v13 + 48) = SerialDispatchQueueWithPriority;
  v18 = (_xpc_connection_s *)(*(uint64_t (**)(uint64_t, NSObject *))(a5 + 16))(a5, SerialDispatchQueueWithPriority);
  if (!v18)
  {
    v28 = 4294951143;
    goto LABEL_32;
  }
  v19 = v18;
  *(_QWORD *)(v13 + 40) = v18;
  xpc_connection_set_target_queue(v18, *(dispatch_queue_t *)(v13 + 48));
  v20 = *(_QWORD **)(v13 + 16);
  if (v20[6] || v20[3] >= 2uLL && v20[8])
    *(_QWORD *)(v13 + 72) = figXPC_CreateSerialDispatchQueueWithPriority(v32, v30);
  v21 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject(v13);
  if (!v21)
  {
LABEL_27:
    v28 = 4294951146;
LABEL_32:
    v16 = FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
    goto LABEL_33;
  }
  xpc_connection_set_context(v19, v21);
  xpc_connection_set_finalizer_f(v19, (xpc_finalizer_t)figXPC_ServerConnectionFinalizer);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 0x40000000;
  handler[2] = __figXPCCreateXPCConnectionInternal_block_invoke;
  handler[3] = &__block_descriptor_tmp_91;
  handler[4] = v19;
  xpc_connection_set_event_handler(v19, handler);
  if (FigCFDictionaryGetInt32IfPresent(*(_QWORD *)(*(_QWORD *)(v13 + 16) + 88), CFSTR("xpcRemoteClientOption_UserID"), &v31))xpc_connection_set_target_uid();
  xpc_connection_activate(*(xpc_connection_t *)(v13 + 40));
  v35 = 0;
  xdict = 0;
  memset(buffer, 0, sizeof(buffer));
  IsServerProcess = FigServer_IsServerProcess();
  v23 = FigXPCCreateBasicMessage(0x2E706E67u, 0, &xdict);
  if ((_DWORD)v23)
  {
    v26 = v23;
    v25 = xdict;
  }
  else
  {
    v24 = getpid();
    proc_name(v24, buffer, 0x80u);
    v25 = xdict;
    xpc_dictionary_set_string(xdict, ".ProcessName", (const char *)buffer);
    xpc_dictionary_set_BOOL(v25, ".IsDaemon", IsServerProcess);
    v26 = FigXPCConnectionSendSyncMessageCreatingReply(v13, v25, &v35);
    if (!(_DWORD)v26)
      *(_QWORD *)(v13 + 64) = xpc_dictionary_get_int64(v35, ".Token");
  }
  FigXPCRelease(v25);
  FigXPCRelease(v35);
  if ((_DWORD)v26)
    goto LABEL_34;
  *a4 = v13;
LABEL_26:
  free(v34);
  free(v33);
  free(v32);
  return v26;
}

BOOL FigXPCIsObjectIDLocallyServed(uint64_t a1, uint64_t a2)
{
  if (a1)
    return (a2 & 0xFFFFFF0000000000) == *(_QWORD *)(a1 + 8);
  FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t FigXPCServerCopyMemoryOrigin(_xpc_connection_s *a1, CFTypeRef *a2)
{
  id *context;
  _QWORD *v4;
  _QWORD *v5;
  CFTypeID v6;
  const void *v7;
  uint64_t v8;
  uint64_t v10;

  context = (id *)xpc_connection_get_context(a1);
  v4 = FigCFWeakReferenceLoadAndRetain(context + 2);
  if (v4)
  {
    v5 = v4;
    v6 = CFGetTypeID(v4);
    if (figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce != -1)
      dispatch_once(&figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce, &__block_literal_global_112);
    if (v6 == figXPCPerProcessInfo_GetTypeID_sPerProcessInfoTypeID)
    {
      v7 = (const void *)v5[8];
      if (v7)
      {
        v8 = 0;
        *a2 = CFRetain(v7);
LABEL_7:
        CFRelease(v5);
        return v8;
      }
      v10 = 4294951137;
    }
    else
    {
      v10 = 4294951142;
    }
    v8 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCServerCopyMemoryRecipient(_xpc_connection_s *a1, CFTypeRef *a2)
{
  id *context;
  _QWORD *v4;
  _QWORD *v5;
  CFTypeID v6;
  const void *v7;
  uint64_t v8;
  uint64_t v10;

  context = (id *)xpc_connection_get_context(a1);
  v4 = FigCFWeakReferenceLoadAndRetain(context + 2);
  if (v4)
  {
    v5 = v4;
    v6 = CFGetTypeID(v4);
    if (figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce != -1)
      dispatch_once(&figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce, &__block_literal_global_112);
    if (v6 == figXPCPerProcessInfo_GetTypeID_sPerProcessInfoTypeID)
    {
      v7 = (const void *)v5[9];
      if (v7)
      {
        v8 = 0;
        *a2 = CFRetain(v7);
LABEL_7:
        CFRelease(v5);
        return v8;
      }
      v10 = 4294951137;
    }
    else
    {
      v10 = 4294951142;
    }
    v8 = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCServerDisassociateObjectWithConnection(_xpc_connection_s *a1, uint64_t a2)
{
  id *context;
  id v4;
  const void *v5;
  CFTypeID v6;
  uint64_t v7;

  context = (id *)xpc_connection_get_context(a1);
  v4 = FigCFWeakReferenceLoadAndRetain(context + 2);
  if (!v4)
    return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
  v5 = v4;
  v6 = CFGetTypeID(v4);
  if (figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce != -1)
    dispatch_once(&figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce, &__block_literal_global_112);
  if (v6 == figXPCPerProcessInfo_GetTypeID_sPerProcessInfoTypeID)
  {
    figXPCServer_DisassociateObjectWithPerProcessInfo((uint64_t)v5, a2);
    v7 = 0;
  }
  else
  {
    v7 = FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
  }
  CFRelease(v5);
  return v7;
}

uint64_t figXPCServer_DisassociateObjectWithPerProcessInfo(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  _QWORD *ValueAtIndex;
  _QWORD *v8;

  if (result)
  {
    v3 = result;
    FigSimpleMutexLock(*(pthread_mutex_t **)(result + 80));
    Count = CFArrayGetCount(*(CFArrayRef *)(v3 + 88));
    if (Count >= 1)
    {
      v5 = Count;
      v6 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 88), v6);
        if (ValueAtIndex[3] == a2)
          break;
        if (v5 == ++v6)
          return FigSimpleMutexUnlock(*(pthread_mutex_t **)(v3 + 80));
      }
      v8 = ValueAtIndex;
      figXPC_ForgetNotificationsForServedObject(*(_QWORD *)(v3 + 112), ValueAtIndex);
      FigCFWeakReferenceTableRemoveValue(*(_QWORD *)(v3 + 48), v8[3]);
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v3 + 88), v6);
    }
    return FigSimpleMutexUnlock(*(pthread_mutex_t **)(v3 + 80));
  }
  return result;
}

uint64_t FigXPCServerAssociateObjectWithConnectionWithFlags(_xpc_connection_s *a1, const void *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t *a7)
{
  id *context;
  pthread_mutex_t **v15;
  pthread_mutex_t **v16;
  uint64_t v17;

  context = (id *)xpc_connection_get_context(a1);
  v15 = (pthread_mutex_t **)FigCFWeakReferenceLoadAndRetain(context + 2);
  if (!v15)
    return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
  v16 = v15;
  FigSimpleMutexLock(v15[10]);
  v17 = figXPC_RegisterServedObject((uint64_t)v16, a1, a2, a3, a4, a5, a6, a7);
  FigSimpleMutexUnlock(v16[10]);
  CFRelease(v16);
  return v17;
}

uint64_t figXPC_RegisterServedObject(uint64_t a1, void *a2, const void *a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t *a8)
{
  unint64_t v16;
  uint64_t result;

  if (!a1 || !a3)
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  v16 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) | ((unint64_t)FigAtomicIncrement32((unsigned int *)(*(_QWORD *)(a1 + 56) + 20)) << 8) | 1;
  result = figXPC_RegisterServedObjectWithID(a1, a2, a3, a4, a5, a6, a7, v16);
  if (!(_DWORD)result)
    *a8 = v16;
  return result;
}

uint64_t FigXPCServerAssociateObjectWithConnection(_xpc_connection_s *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t *a6)
{
  return FigXPCServerAssociateObjectWithConnectionWithFlags(a1, a2, 0, a3, a4, a5, a6);
}

uint64_t FigXPCServerAssociateCopiedObjectWithConnection(_xpc_connection_s *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t *a6)
{
  id *context;
  pthread_mutex_t **v13;
  pthread_mutex_t **v14;
  uint64_t v15;

  context = (id *)xpc_connection_get_context(a1);
  v13 = (pthread_mutex_t **)FigCFWeakReferenceLoadAndRetain(context + 2);
  if (!v13)
    return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
  v14 = v13;
  FigSimpleMutexLock(v13[10]);
  v15 = figXPC_RegisterCopiedObject((uint64_t)v14, a1, a2, a3, a4, a5, a6);
  FigSimpleMutexUnlock(v14[10]);
  CFRelease(v14);
  return v15;
}

uint64_t figXPC_RegisterCopiedObject(uint64_t a1, void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t *a7)
{
  CFIndex Count;
  unint64_t v13;
  unsigned __int8 v14;
  int v15;
  CFIndex i;
  _QWORD *ValueAtIndex;
  uint64_t v18;
  __int16 v19;
  uint64_t result;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 88));
  v13 = 0;
  v14 = 2;
  while (2)
  {
    if (Count >= 1)
    {
      v15 = 0;
      for (i = 0; i != Count; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), i);
        if ((const void *)ValueAtIndex[2] == a3 && (void *)ValueAtIndex[7] == a2)
        {
          v18 = ValueAtIndex[3];
          v13 = v18 & 0xFFFFFFFFFFFFFF00;
          v19 = v14;
          if (v14 == v18)
          {
            ++v14;
            if (((v19 + 1) & 0x100) != 0)
              return FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
            v15 = 1;
          }
        }
      }
      if (v15)
        continue;
    }
    break;
  }
  if (!v13)
    return figXPC_RegisterServedObject(a1, a2, a3, 0, a4, a5, a6, a7);
  result = figXPC_RegisterServedObjectWithID(a1, a2, a3, 0, a4, a5, a6, v13 | v14);
  *a7 = v13 | v14;
  return result;
}

uint64_t FigXPCServerFindUniqueObjectIDForObjectAssociatedWithConnection(_xpc_connection_s *a1, uint64_t a2, _QWORD *a3)
{
  id *context;
  pthread_mutex_t **v7;
  pthread_mutex_t **v8;
  CFIndex Count;
  CFIndex v10;
  uint64_t v11;
  CFIndex i;
  _QWORD *ValueAtIndex;
  uint64_t v14;

  context = (id *)xpc_connection_get_context(a1);
  v7 = (pthread_mutex_t **)FigCFWeakReferenceLoadAndRetain(context + 2);
  if (!v7)
    return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
  v8 = v7;
  FigSimpleMutexLock(v7[10]);
  Count = CFArrayGetCount((CFArrayRef)v8[11]);
  if (Count < 1)
    goto LABEL_11;
  v10 = Count;
  v11 = 0;
  for (i = 0; i != v10; ++i)
  {
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v8[11], i);
    if (ValueAtIndex[2] == a2 && (_xpc_connection_s *)ValueAtIndex[7] == a1)
    {
      if (v11)
        goto LABEL_11;
      v11 = ValueAtIndex[3];
    }
  }
  if (v11)
  {
    v14 = 0;
    *a3 = v11;
  }
  else
  {
LABEL_11:
    v14 = FigSignalErrorAt(4294948085, 0, 0, 0, 0, 0, 0);
  }
  FigSimpleMutexUnlock(v8[10]);
  CFRelease(v8);
  return v14;
}

uint64_t FigXPCServerLookupAndRetainAssociatedObject(_xpc_connection_s *a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  return _figXPCServerLookupAndRetainAssociatedObject(a1, a2, 0, a3, a4);
}

uint64_t _figXPCServerLookupAndRetainAssociatedObject(_xpc_connection_s *a1, uint64_t a2, int a3, _QWORD *a4, _QWORD *a5)
{
  id *context;
  pthread_mutex_t **v10;
  pthread_mutex_t **v11;
  CFIndex Count;
  CFIndex v13;
  CFIndex v14;
  _QWORD *ValueAtIndex;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v19;
  CFTypeRef v20;
  const void *v21;

  context = (id *)xpc_connection_get_context(a1);
  v10 = (pthread_mutex_t **)FigCFWeakReferenceLoadAndRetain(context + 2);
  if (v10)
  {
    v11 = v10;
    FigSimpleMutexLock(v10[10]);
    Count = CFArrayGetCount((CFArrayRef)v11[11]);
    if (Count < 1)
    {
LABEL_6:
      FigSimpleMutexUnlock(v11[10]);
    }
    else
    {
      v13 = Count;
      v14 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v11[11], v14);
        if (ValueAtIndex[3] == a2)
          break;
        if (v13 == ++v14)
          goto LABEL_6;
      }
      v19 = CFRetain(ValueAtIndex);
      FigSimpleMutexUnlock(v11[10]);
      if (v19)
      {
        v20 = (CFTypeRef)v19[2];
        if (v20)
          v20 = CFRetain(v20);
        *a4 = v20;
        if (a5)
        {
          if (a3)
          {
            v21 = (const void *)v19[4];
            if (v21)
              CFRetain(v21);
          }
          *a5 = v19[4];
        }
        CFRelease(v19);
        v17 = 0;
        goto LABEL_11;
      }
    }
    FigSimpleMutexLock(v11[10]);
    if ((a2 & 0xFFFFFFFFFFFFFF00) >= ((unint64_t)v11[12] & 0xFFFFFFFFFFFFFF00))
      v16 = 4294951144;
    else
      v16 = 4294948086;
    FigSimpleMutexUnlock(v11[10]);
    v17 = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
LABEL_11:
    CFRelease(v11);
    return v17;
  }
  return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCServerLookupAndRetainAssociatedObjectAndCFTypeRefcon(_xpc_connection_s *a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    return _figXPCServerLookupAndRetainAssociatedObject(a1, a2, 1, a3, a4);
  else
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCServerRetainNeighborObjectFromID(uint64_t *a1, void *a2, _QWORD *a3)
{
  uint64_t v4;
  id v6;

  v4 = 4294951145;
  if (a1 && a3)
  {
    v6 = FigCFWeakReferenceTableCopyValue(*a1, a2);
    *a3 = v6;
    if (v6)
      return 0;
    v4 = 4294951144;
  }
  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCServerRetainNeighborObjectFromIDWithProcessID(uint64_t a1, int a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  id v11;
  uint64_t v13;
  uint64_t *v14;

  if (a1 && a4)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
    v14 = 0;
    v8 = figXPC_CopyInfoForProcess(a1, a2, &v14);
    if ((_DWORD)v8)
    {
      v9 = v8;
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
      return v9;
    }
    v10 = v14;
    v11 = FigCFWeakReferenceTableCopyValue(v14[6], a3);
    CFRelease(v10);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    if (v11)
    {
      v9 = 0;
      *a4 = v11;
      return v9;
    }
    v13 = 4294951144;
  }
  else
  {
    v13 = 4294951145;
  }
  return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
}

uint64_t figXPC_CopyInfoForProcess(uint64_t a1, int a2, _QWORD *a3)
{
  uintptr_t v6;
  const void *Value;
  _QWORD *v8;
  const __CFAllocator *v9;
  uint64_t Instance;
  NSObject *v11;
  pthread_mutex_t *v12;
  CFMutableArrayRef v13;
  CFTypeRef v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *CStringPtrMaybeUsingPreallocatedBuffer;
  pthread_mutex_t *v20;
  CFMutableArrayRef Mutable;
  dispatch_queue_t v22;
  uint64_t v23;
  char *v24;
  NSObject *v25;
  char *v26;
  char *v28;
  CFTypeRef cf;
  char *label[5];
  __int128 handler;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v6 = a2;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 104), (const void *)a2);
  if (Value)
  {
    v8 = CFRetain(Value);
    if (v8)
      goto LABEL_26;
  }
  v28 = 0;
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce != -1)
    dispatch_once(&figXPCPerProcessInfo_GetTypeID_sRegisterPerProcessInfoTypeOnce, &__block_literal_global_112);
  Instance = _CFRuntimeCreateInstance();
  v8 = (_QWORD *)Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 16) = a2;
    asprintf(&v28, "%s(%d)-messages", *(const char **)(a1 + 88), a2);
    v11 = FigDispatchQueueCreateWithPriority(v28, 0, *(_DWORD *)(a1 + 120));
    v8[3] = v11;
    FigThreadMakeDispatchQueueAbortable(v11);
    v12 = FigSimpleMutexCreate();
    v8[10] = v12;
    if (v12 && (v13 = CFArrayCreateMutable(v9, 0, MEMORY[0x1E0C9B378]), (v8[11] = v13) != 0))
    {
      if (*(_BYTE *)(a1 + 124))
      {
        v14 = *(CFTypeRef *)a1;
        if (*(_QWORD *)a1)
          v14 = CFRetain(v14);
        v8[6] = v14;
      }
      else
      {
        FigCFWeakReferenceTableCreate(v9, 1, v8 + 6);
      }
      v8[7] = a1;
      *((_DWORD *)v8 + 42) = 0;
      v8[20] = CFDictionaryCreateMutable(v9, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v15 = *(const char **)(v8[7] + 88);
      v16 = *((unsigned int *)v8 + 4);
      cf = 0;
      label[0] = 0;
      v37 = 0u;
      v38 = 0u;
      v36 = 0u;
      v34 = 0u;
      v35 = 0u;
      v32 = 0u;
      v33 = 0u;
      handler = 0u;
      if (figXPCEnqueuedNotifications_GetTypeID_sRegisterEnqueuedNotificationsTypeOnce != -1)
        dispatch_once(&figXPCEnqueuedNotifications_GetTypeID_sRegisterEnqueuedNotificationsTypeOnce, &__block_literal_global_123);
      v17 = _CFRuntimeCreateInstance();
      if (v17)
      {
        v18 = v17;
        FigServer_CopyProcessName(v16, (CFStringRef *)&cf);
        CStringPtrMaybeUsingPreallocatedBuffer = FigCFStringGetCStringPtrMaybeUsingPreallocatedBuffer((const char *)cf, (char *)&handler, 128, 0x600u);
        asprintf(label, "%s(%s-%d)-drainNotifications", v15, CStringPtrMaybeUsingPreallocatedBuffer, v16);
        snprintf((char *)(v18 + 16), 0x80uLL, "%s-%d", v15, v16);
        v20 = FigSimpleMutexCreate();
        *(_QWORD *)(v18 + 152) = v20;
        if (v20
          && (Mutable = CFArrayCreateMutable(v9, 0, 0), (*(_QWORD *)(v18 + 160) = Mutable) != 0)
          && (v22 = dispatch_queue_create(label[0], 0), (*(_QWORD *)(v18 + 144) = v22) != 0))
        {
          v23 = 0;
          *(_QWORD *)(v18 + 168) = 0;
          v8[14] = v18;
        }
        else
        {
          v23 = FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
          CFRelease((CFTypeRef)v18);
        }
      }
      else
      {
        v23 = FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
      }
      if (cf)
        CFRelease(cf);
      free(label[0]);
      if (!(_DWORD)v23)
      {
        v24 = v28;
        goto LABEL_24;
      }
    }
    else
    {
      v23 = FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
    }
    free(v28);
    CFRelease(v8);
    v8 = 0;
    if ((_DWORD)v23)
      return v23;
    goto LABEL_25;
  }
  v23 = FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
  v24 = 0;
LABEL_24:
  free(v24);
  if (!(_DWORD)v23)
  {
LABEL_25:
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), (const void *)v6, v8);
    v25 = dispatch_source_create(MEMORY[0x1E0C80DB0], v6, 0x80000000uLL, (dispatch_queue_t)gCommonServerTimeoutQueue);
    v26 = (char *)MEMORY[0x1E0C809B0];
    *(_QWORD *)&handler = MEMORY[0x1E0C809B0];
    *((_QWORD *)&handler + 1) = 0x40000000;
    *(_QWORD *)&v32 = __figXPC_StartListeningForClientProcessDeath_block_invoke;
    *((_QWORD *)&v32 + 1) = &__block_descriptor_tmp_124;
    *(_QWORD *)&v33 = a1;
    DWORD2(v33) = a2;
    dispatch_source_set_event_handler(v25, &handler);
    label[0] = v26;
    label[1] = (char *)0x40000000;
    label[2] = (char *)__figXPC_StartListeningForClientProcessDeath_block_invoke_2;
    label[3] = (char *)&__block_descriptor_tmp_125;
    label[4] = (char *)v25;
    dispatch_source_set_cancel_handler(v25, label);
    v8[13] = v25;
    dispatch_resume(v25);
LABEL_26:
    v23 = 0;
    *a3 = v8;
  }
  return v23;
}

uint64_t FigXPCServerRetainNeighborObjectFromIDWithConnection(uint64_t a1, xpc_connection_t connection, void *a3, _QWORD *a4)
{
  pid_t pid;

  pid = xpc_connection_get_pid(connection);
  return FigXPCServerRetainNeighborObjectFromIDWithProcessID(a1, pid, a3, a4);
}

uint64_t FigXPCServerAssociateObjectWithNeighborProcess(uint64_t a1, xpc_connection_t connection, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  pid_t pid;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  unint64_t v19;

  v19 = 0;
  if (!a1 || !a7)
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  pid = xpc_connection_get_pid(connection);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
  v18 = 0;
  v14 = figXPC_CopyInfoForProcess(a1, pid, &v18);
  if ((_DWORD)v14)
  {
    v15 = v14;
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
  }
  else
  {
    v16 = v18;
    FigSimpleMutexLock(*(pthread_mutex_t **)(v18 + 80));
    v15 = figXPC_RegisterServedObject(v16, *(void **)(v16 + 32), a3, 0, a4, a5, a6, &v19);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v16 + 80));
    CFRelease((CFTypeRef)v16);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    if (!(_DWORD)v15)
      *a7 = v19;
  }
  return v15;
}

uint64_t FigXPCServerAssociateObjectWithNeighborProcessByPID(uint64_t a1, int a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  unint64_t v19;

  v19 = 0;
  if (!a1 || !a7)
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
  v18 = 0;
  v14 = figXPC_CopyInfoForProcess(a1, a2, &v18);
  if ((_DWORD)v14)
  {
    v15 = v14;
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
  }
  else
  {
    v16 = v18;
    FigSimpleMutexLock(*(pthread_mutex_t **)(v18 + 80));
    v15 = figXPC_RegisterServedObject(v16, *(void **)(v16 + 32), a3, 0, a4, a5, a6, &v19);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v16 + 80));
    CFRelease((CFTypeRef)v16);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    if (!(_DWORD)v15)
      *a7 = v19;
  }
  return v15;
}

uint64_t FigXPCServerDisassociateObjectWithNeighborClientPID(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  CFTypeRef v7;
  CFTypeRef cf;

  if (!a1)
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
  cf = 0;
  v6 = figXPC_CopyInfoForProcess(a1, a2, &cf);
  v7 = cf;
  if (!(_DWORD)v6)
    figXPCServer_DisassociateObjectWithPerProcessInfo((uint64_t)cf, a3);
  if (v7)
    CFRelease(v7);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
  return v6;
}

uint64_t FigXPCServerDisassociateObjectWithNeighborClientConnection(uint64_t a1, xpc_connection_t connection, uint64_t a3)
{
  pid_t pid;

  pid = xpc_connection_get_pid(connection);
  return FigXPCServerDisassociateObjectWithNeighborClientPID(a1, pid, a3);
}

uint64_t FigXPCServerAssociateCopiedObjectWithNeighborProcess(uint64_t a1, xpc_connection_t connection, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  pid_t pid;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  unint64_t v19;

  v19 = 0;
  if (!a3 || !a1 || !a7)
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  pid = xpc_connection_get_pid(connection);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
  v18 = 0;
  v14 = figXPC_CopyInfoForProcess(a1, pid, &v18);
  if ((_DWORD)v14)
  {
    v15 = v14;
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
  }
  else
  {
    v16 = v18;
    FigSimpleMutexLock(*(pthread_mutex_t **)(v18 + 80));
    v15 = figXPC_RegisterCopiedObject(v16, *(void **)(v16 + 32), a3, a4, a5, a6, &v19);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v16 + 80));
    CFRelease((CFTypeRef)v16);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    if (!(_DWORD)v15)
      *a7 = v19;
  }
  return v15;
}

uint64_t FigXPCServerAssociateCopiedObjectWithNeighborProcessByPID(uint64_t a1, int a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  unint64_t v19;

  v19 = 0;
  if (!a1 || !a7)
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
  v18 = 0;
  v14 = figXPC_CopyInfoForProcess(a1, a2, &v18);
  if ((_DWORD)v14)
  {
    v15 = v14;
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
  }
  else
  {
    v16 = v18;
    FigSimpleMutexLock(*(pthread_mutex_t **)(v18 + 80));
    v15 = figXPC_RegisterCopiedObject(v16, *(void **)(v16 + 32), a3, a4, a5, a6, &v19);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v16 + 80));
    CFRelease((CFTypeRef)v16);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
    if (!(_DWORD)v15)
      *a7 = v19;
  }
  return v15;
}

uint64_t FigXPCServerConfirmNeighborProcessByPID(uint64_t a1, int a2)
{
  _QWORD *Value;
  uint64_t v5;

  if (!a1)
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 104), (const void *)a2);
  if (Value && Value[4])
    v5 = 0;
  else
    v5 = FigSignalErrorAt(4294951139, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
  return v5;
}

uint64_t FigXPCServerSetConnectionRefcon(_xpc_connection_s *a1, uint64_t a2, uint64_t a3)
{
  void *context;
  CFTypeRef v6;
  const void *v7;
  uint64_t v8;

  context = xpc_connection_get_context(a1);
  if (!context)
    return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
  v6 = CFRetain(context);
  if (!v6)
    return FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
  v7 = v6;
  if (a2)
  {
    if (!a3 || *((_QWORD *)v6 + 22))
    {
      v8 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      v8 = 0;
      *((_QWORD *)v6 + 22) = a2;
      *((_QWORD *)v6 + 23) = a3;
    }
  }
  else
  {
    v8 = 0;
  }
  CFRelease(v7);
  return v8;
}

uint64_t FigXPCServerSelfTerminateDueToError(uint64_t result, int a2)
{
  char *v2;

  if (result)
  {
    if (*(_BYTE *)(result + 136))
      FigXPCServerSelfTerminateDueToError_cold_1(&v2, result, a2);
  }
  return result;
}

uint64_t FigXPCServerGetConnectionRefcon(_xpc_connection_s *a1)
{
  void *context;
  _QWORD *v2;
  uint64_t v3;

  context = xpc_connection_get_context(a1);
  if (context && (v2 = CFRetain(context)) != 0)
  {
    v3 = v2[22];
    CFRelease(v2);
  }
  else
  {
    FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v3;
}

xpc_object_t FigXPCServerCopyPrimaryConnection(_xpc_connection_s *a1)
{
  void *context;
  id *v2;
  id *v3;
  xpc_object_t *v4;
  xpc_object_t *v5;
  xpc_object_t v6;

  context = xpc_connection_get_context(a1);
  if (context && (v2 = (id *)CFRetain(context)) != 0)
  {
    v3 = v2;
    v4 = (xpc_object_t *)FigCFWeakReferenceLoadAndRetain(v2 + 2);
    if (v4)
    {
      v5 = v4;
      v6 = FigXPCRetain(v4[4]);
      CFRelease(v3);
      CFRelease(v5);
      return v6;
    }
    CFRelease(v3);
  }
  else
  {
    FigSignalErrorAt(4294951142, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigXPCServerStart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  _QWORD v5[5];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __FigXPCServerStart_block_invoke;
  v5[3] = &__block_descriptor_tmp_67;
  v5[4] = a1;
  return FigXPCServerStartWithListenerCreatingBlock(a1, a2, a3, a4, (uint64_t)v5);
}

uint64_t FigXPCServerStartWithListenerCreatingBlock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  void *v10;
  uint64_t v11;
  pthread_mutex_t *v12;
  const __CFAllocator *v13;
  CFMutableDictionaryRef Mutable;
  dispatch_queue_t v15;
  unint64_t TimeoutNanoseconds;
  _xpc_connection_s *v17;
  uint64_t v19;
  _QWORD handler[5];
  Boolean v21;
  __int16 v22;
  __int16 v23;
  int v24;

  v24 = 44;
  v23 = 0;
  v22 = 0;
  v21 = 0;
  if (figXPC_ServerOneTimeInitialization_sInitFigXPCServerOnce != -1)
    dispatch_once(&figXPC_ServerOneTimeInitialization_sInitFigXPCServerOnce, &__block_literal_global_129);
  *a4 = 0;
  if (!a2 || (unint64_t)(*(_QWORD *)a2 - 1) >= 3 || !*(_QWORD *)(a2 + 8) && !*(_QWORD *)(a2 + 16))
  {
    v19 = 4294951145;
    return FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
  }
  v10 = malloc_type_calloc(1uLL, 0x90uLL, 0x10F004066051988uLL);
  if (!v10
    || (v11 = (uint64_t)v10, v12 = FigSimpleMutexCreate(), (*(_QWORD *)(v11 + 112) = v12) == 0)
    || (v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00],
        Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]),
        (*(_QWORD *)(v11 + 104) = Mutable) == 0))
  {
    v19 = 4294951146;
    return FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
  }
  FigCFWeakReferenceTableCreate(v13, 1, (uint64_t *)v11);
  FigCFDictionaryGetInt32IfPresent(a3, CFSTR("xpcServerOption_QueuePriority"), &v24);
  FigCFDictionaryGetBooleanIfPresent(a3, CFSTR("xpcServerOption_SiloObjectIDs"), (Boolean *)&v23 + 1);
  FigCFDictionaryGetBooleanIfPresent(a3, CFSTR("xpcServerOption_ForwardClientSideAbortActions"), (Boolean *)&v23);
  FigCFDictionaryGetBooleanIfPresent(a3, CFSTR("xpcServerOption_StartInactive"), (Boolean *)&v22 + 1);
  FigCFDictionaryGetBooleanIfPresent(a3, CFSTR("xpcServerOption_SelfTerminateOnError"), (Boolean *)&v22);
  FigCFDictionaryGetBooleanIfPresent(a3, CFSTR("xpcServerOption_OptOutOfPurge"), &v21);
  *(_QWORD *)(v11 + 40) = *(_QWORD *)a2;
  *(_OWORD *)(v11 + 48) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(v11 + 64) = *(_OWORD *)(a2 + 24);
  if (*(_QWORD *)a2 >= 3uLL)
    *(_QWORD *)(v11 + 80) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(v11 + 88) = a1;
  *(_QWORD *)(v11 + 24) = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 16))(a5, gCommonServerListenerQueue);
  *(_DWORD *)(v11 + 120) = v24;
  *(_BYTE *)(v11 + 124) = HIBYTE(v23) == 0;
  *(_BYTE *)(v11 + 125) = v23;
  *(_BYTE *)(v11 + 136) = v22;
  *(_BYTE *)(v11 + 137) = v21;
  v15 = FigDispatchQueueCreateWithPriority("com.apple.coremedia.terminateSecondaryConnectionsQueue", 0, 0);
  *(_QWORD *)(v11 + 128) = v15;
  if (!v15)
    return FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
  figXPC_RegisterNewServer(v11);
  if (!FigCFDictionaryGetInt32IfPresent(a3, CFSTR("xpcServerOption_SelfTerminationTimeout"), (void *)(v11 + 96)))
  {
    TimeoutNanoseconds = FigRPCServer_GetTimeoutNanoseconds();
    *(_DWORD *)(v11 + 96) = TimeoutNanoseconds / 0x3B9ACA00;
    if ((TimeoutNanoseconds / 0x3B9ACA00))
      *(_DWORD *)(v11 + 100) = 90;
  }
  v17 = *(_xpc_connection_s **)(v11 + 24);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 0x40000000;
  handler[2] = __FigXPCServerStartWithListenerCreatingBlock_block_invoke;
  handler[3] = &__block_descriptor_tmp_127;
  handler[4] = v11;
  xpc_connection_set_event_handler(v17, handler);
  *a4 = v11;
  if (!HIBYTE(v22))
    xpc_connection_activate(*(xpc_connection_t *)(v11 + 24));
  return 0;
}

uint64_t FigXPCServerStartWithNewXPCEndpoint(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5;

  v5 = FigXPCServerStartWithListenerCreatingBlock(a1, a2, a3, a4, (uint64_t)&__block_literal_global_55);
  if (!(_DWORD)v5)
    *(_QWORD *)(*a4 + 32) = xpc_endpoint_create(*(xpc_connection_t *)(*a4 + 24));
  return v5;
}

uint64_t FigXPCServerCopyXPCEndpoint(uint64_t a1, _QWORD *a2)
{
  if (!a1 || !a2)
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  *a2 = *(_QWORD *)(a1 + 32);
  FigXPCRetain(*(xpc_object_t *)(a1 + 32));
  return 0;
}

uint64_t FigXPCServerStartWithClientXPCConnection(_xpc_connection_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  char *v10;
  pthread_mutex_t *v11;
  const __CFAllocator *v12;
  CFMutableDictionaryRef Mutable;
  __int128 v14;
  __int128 v15;
  dispatch_queue_t v16;
  uint64_t result;
  __int16 v18;
  __int16 v19;
  int v20;

  v20 = 44;
  v19 = 0;
  v18 = 0;
  if (figXPC_ServerOneTimeInitialization_sInitFigXPCServerOnce != -1)
  {
    dispatch_once(&figXPC_ServerOneTimeInitialization_sInitFigXPCServerOnce, &__block_literal_global_129);
    if (a3)
      goto LABEL_3;
LABEL_14:
    result = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    v10 = 0;
    goto LABEL_11;
  }
  if (!a3)
    goto LABEL_14;
LABEL_3:
  if ((unint64_t)(*(_QWORD *)a3 - 3) <= 0xFFFFFFFFFFFFFFFDLL || !*(_QWORD *)(a3 + 8) && !*(_QWORD *)(a3 + 16))
    goto LABEL_14;
  v10 = (char *)malloc_type_calloc(1uLL, 0x90uLL, 0x10F004066051988uLL);
  if (!v10)
    goto LABEL_12;
  v11 = FigSimpleMutexCreate();
  *((_QWORD *)v10 + 14) = v11;
  if (!v11)
    goto LABEL_12;
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
  *((_QWORD *)v10 + 13) = Mutable;
  if (!Mutable)
    goto LABEL_12;
  FigCFWeakReferenceTableCreate(v12, 1, (uint64_t *)v10);
  FigCFDictionaryGetInt32IfPresent(a4, CFSTR("xpcServerOption_QueuePriority"), &v20);
  FigCFDictionaryGetBooleanIfPresent(a4, CFSTR("xpcServerOption_SiloObjectIDs"), (Boolean *)&v19 + 1);
  FigCFDictionaryGetBooleanIfPresent(a4, CFSTR("xpcServerOption_ForwardClientSideAbortActions"), (Boolean *)&v19);
  FigCFDictionaryGetBooleanIfPresent(a4, CFSTR("xpcServerOption_SelfTerminateOnError"), (Boolean *)&v18 + 1);
  FigCFDictionaryGetBooleanIfPresent(a4, CFSTR("xpcServerOption_OptOutOfPurge"), (Boolean *)&v18);
  v15 = *(_OWORD *)(a3 + 16);
  v14 = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(v10 + 40) = *(_OWORD *)a3;
  *(_OWORD *)(v10 + 56) = v15;
  *(_OWORD *)(v10 + 72) = v14;
  *((_QWORD *)v10 + 11) = a2;
  *((_QWORD *)v10 + 3) = 0;
  *((_DWORD *)v10 + 30) = v20;
  v10[124] = HIBYTE(v19) == 0;
  v10[125] = v19;
  v10[136] = HIBYTE(v18);
  v10[137] = v18;
  v16 = FigDispatchQueueCreateWithPriority("com.apple.coremedia.terminateSecondaryConnectionsQueue", 0, 0);
  *((_QWORD *)v10 + 16) = v16;
  if (v16)
  {
    figXPC_RegisterNewServer((uint64_t)v10);
    FigSimpleMutexLock(*((pthread_mutex_t **)v10 + 14));
    figXPC_HandleNewClientConnection((uint64_t)v10, a1);
    FigSimpleMutexUnlock(*((pthread_mutex_t **)v10 + 14));
    result = 0;
  }
  else
  {
LABEL_12:
    result = FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
  }
LABEL_11:
  *a5 = v10;
  return result;
}

void figXPC_RegisterNewServer(uint64_t a1)
{
  _QWORD block[5];

  if (figXPC_ServerRegistryOneTimeInitialization_sInitServerRegistryOnce != -1)
    dispatch_once(&figXPC_ServerRegistryOneTimeInitialization_sInitServerRegistryOnce, &__block_literal_global_135);
  *(_BYTE *)(a1 + 16) = FigAtomicIncrement32((unsigned int *)&gNextServerNumber);
  *(_QWORD *)(a1 + 8) = ((unint64_t)*(unsigned __int8 *)(a1 + 16) << 40) | ((uint64_t)getpid() << 48);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __figXPC_RegisterNewServer_block_invoke;
  block[3] = &__block_descriptor_tmp_133;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)gServerRegistry_0, block);
}

void figXPC_HandleNewClientConnection(uint64_t a1, xpc_connection_t connection)
{
  uint64_t pid;
  char *v5;
  unsigned int (*v6)(xpc_connection_t);
  uint64_t v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex i;
  _QWORD *ValueAtIndex;
  _QWORD v12[7];
  CFTypeRef cf;
  uint64_t v14;
  void *v15;

  cf = 0;
  v14 = 0;
  pid = xpc_connection_get_pid(connection);
  v5 = &gHasProcessInitialized;
  if (gHasProcessInitialized)
    v5 = &isFirstTime;
  *v5 = 1;
  v6 = *(unsigned int (**)(xpc_connection_t))(a1 + 64);
  if (v6 && !v6(connection))
  {
    xpc_connection_cancel(connection);
  }
  else
  {
    if (!figXPC_CopyInfoForProcess(a1, pid, &v14))
    {
      FigServer_CopyProcessName(pid, (CFStringRef *)&cf);
      v7 = v14;
      if (*(_QWORD *)(v14 + 32))
      {
        xpc_connection_cancel(connection);
      }
      else
      {
        v15 = 0;
        *(_QWORD *)(v14 + 32) = connection;
        xpc_retain(connection);
        xpc_connection_set_target_queue(connection, *(dispatch_queue_t *)(v7 + 24));
        FigSimpleMutexLock(*(pthread_mutex_t **)(v7 + 80));
        Count = CFArrayGetCount(*(CFArrayRef *)(v7 + 88));
        if (Count >= 1)
        {
          v9 = Count;
          for (i = 0; i != v9; ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v7 + 88), i);
            ValueAtIndex[7] = xpc_retain(connection);
          }
        }
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(v7 + 80));
        figXPC_CreateNewConnectionInfo(v7, *(NSObject **)(v7 + 24), (uint64_t *)&v15);
        xpc_connection_set_context(connection, v15);
        xpc_connection_set_finalizer_f(connection, (xpc_finalizer_t)figXPC_ConnectionInfoFinalizer);
        v12[0] = MEMORY[0x1E0C809B0];
        v12[1] = 0x40000000;
        v12[2] = __figXPC_HandleNewClientConnection_block_invoke;
        v12[3] = &__block_descriptor_tmp_137;
        v12[4] = a1;
        v12[5] = v7;
        v12[6] = connection;
        xpc_connection_set_event_handler(connection, v12);
        xpc_connection_resume(connection);
      }
      goto LABEL_12;
    }
    v7 = v14;
    if (v14)
LABEL_12:
      CFRelease((CFTypeRef)v7);
  }
  if (cf)
    CFRelease(cf);
}

void FigXPCServerActivate(uint64_t a1)
{
  if (a1)
    xpc_connection_activate(*(xpc_connection_t *)(a1 + 24));
}

uint64_t FigXPCPurgeObjectsForPIDWithReportingBlock(int a1, uint64_t a2)
{
  unint64_t UpTimeNanoseconds;
  _QWORD block[5];
  int v7;
  int v8;
  unint64_t v9;

  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigXPCPurgeObjectsForPIDWithReportingBlock_block_invoke;
  block[3] = &__block_descriptor_tmp_71;
  block[4] = a2;
  v7 = a1;
  v8 = 0;
  v9 = UpTimeNanoseconds;
  dispatch_sync((dispatch_queue_t)gServerRegistry_0, block);
  return 0;
}

void figXPC_PurgeObjectsForPIDArrayApplier(uint64_t a1, _QWORD *a2)
{
  int v4;
  CFTypeRef v5;
  CFIndex Count;
  xpc_object_t v7;
  unint64_t v8;
  uint64_t *ValueAtIndex;
  int64_t v10;
  int v11;
  xpc_object_t v12;
  CFTypeRef cf;
  xpc_object_t xdict;

  cf = 0;
  if (*(_BYTE *)(a1 + 137))
  {
    v4 = 0;
    goto LABEL_17;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
  v4 = figXPC_CopyInfoForProcess(a1, *((_DWORD *)a2 + 2), &cf);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
  if (v4)
  {
LABEL_17:
    v7 = 0;
    goto LABEL_11;
  }
  v5 = cf;
  FigSimpleMutexLock(*((pthread_mutex_t **)cf + 10));
  Count = CFArrayGetCount(*((CFArrayRef *)v5 + 11));
  v7 = xpc_array_create(0, 0);
  if (Count >= 1)
  {
    v8 = Count + 1;
    do
    {
      ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(*((CFArrayRef *)v5 + 11), v8 - 2);
      figXPC_ForgetNotificationsForServedObject(*((_QWORD *)v5 + 14), ValueAtIndex);
      FigCFWeakReferenceTableRemoveValue(*((_QWORD *)v5 + 6), ValueAtIndex[3]);
      xpc_array_set_uint64(v7, 0xFFFFFFFFFFFFFFFFLL, ValueAtIndex[3]);
      CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)v5 + 11), v8 - 2);
      --v8;
    }
    while (v8 > 1);
  }
  if (*((_QWORD *)v5 + 4))
  {
    v10 = a2[2];
    xdict = 0;
    v11 = FigXPCCreateBasicMessage(0x2E706721u, 0, &xdict);
    v12 = xdict;
    if (!v11)
    {
      xpc_dictionary_set_value(xdict, ".ObjectIDs", v7);
      xpc_dictionary_set_int64(v12, ".PurgeIdentifier", v10);
      xpc_connection_send_notification();
    }
    FigXPCRelease(v12);
  }
  *((_QWORD *)v5 + 12) = *(_QWORD *)(*((_QWORD *)v5 + 7) + 8) | ((unint64_t)FigAtomicIncrement32((unsigned int *)(*((_QWORD *)v5 + 7) + 20)) << 8) | 1;
  FigSimpleMutexUnlock(*((pthread_mutex_t **)v5 + 10));
  v4 = 0;
LABEL_11:
  if (*a2)
    (*(void (**)(_QWORD, _QWORD, xpc_object_t, _QWORD, BOOL))(*a2 + 16))(*a2, *(_QWORD *)(a1 + 88), v7, a2[2], v4 != 0);
  if (cf)
    CFRelease(cf);
  FigXPCRelease(v7);
}

void figXPCRemoteClient_PrimaryConnectionNotificationCallback(int a1, const void *a2, CFTypeRef cf1, uint64_t a4, const void *a5)
{
  __CFNotificationCenter *DefaultLocalCenter;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v10;
  __CFNotificationCenter *v11;
  uint64_t v12;

  v12 = 0;
  if (CFEqual(cf1, CFSTR("xpcConnectionNotification_ServerDied")))
  {
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("xpcRemoteClientNotification_ServerDied"), a2, a5);
  }
  else if (CFEqual(cf1, CFSTR("xpcConnectionNotification_ServerStatePurged")))
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v10 = Mutable;
      FigCFDictionaryGetInt64IfPresent((uint64_t)a5, CFSTR("xpcConnectionNotificationServerStatePurgedPayloadKey_PurgeIdentifier"), &v12);
      FigCFDictionarySetInt64(v10, CFSTR("xpcRemoteClientNotificationServerStatePurgedPayloadKey_PurgeIdentifier"), v12);
      v11 = CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterPostNotification(v11, CFSTR("xpcRemoteClientNotification_ServerStatePurged"), a2, v10);
      CFRelease(v10);
    }
  }
}

_QWORD *figXPCRemoteClient_Init(_QWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void figXPCRemoteClient_Finalize(uint64_t a1)
{
  __CFNotificationCenter *DefaultLocalCenter;
  const void *v3;
  const void *v4;

  if (*(_QWORD *)(a1 + 24))
  {
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, (const void *)a1, (uint64_t)figXPCRemoteClient_PrimaryConnectionNotificationCallback, 0, *(const void **)(a1 + 24));
    v3 = *(const void **)(a1 + 24);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 24) = 0;
    }
  }
  v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

double figXPCClientConnectionInfo_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 144) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void figXPCClientConnectionInfo_Finalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  v2 = (const void *)a1[11];
  if (v2)
  {
    CFRelease(v2);
    a1[11] = 0;
  }
  v3 = (const void *)a1[14];
  if (v3)
  {
    CFRelease(v3);
    a1[14] = 0;
  }
  v4 = (const void *)a1[12];
  if (v4)
  {
    CFRelease(v4);
    a1[12] = 0;
  }
  FigSimpleMutexDestroy(a1[16]);
  v5 = (const void *)a1[17];
  if (v5)
  {
    CFRelease(v5);
    a1[17] = 0;
  }
  v6 = (const void *)a1[18];
  if (v6)
  {
    CFRelease(v6);
    a1[18] = 0;
  }
}

__CFString *figXPCClientConnectionInfo_CopyDebugDesc(_QWORD *a1)
{
  __CFString *Mutable;
  uint64_t v3;
  CFIndex v4;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = a1[2];
  v4 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigXPCClientConnectionInfo %p %s> RC %d"), a1, v3, v4);
  return Mutable;
}

NSObject *figXPC_CreateSerialDispatchQueueWithPriority(const char *a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0)
    return FigDispatchQueueCreateStandardDispatchQueue(a1, 0, 0, QOS_CLASS_UNSPECIFIED);
  else
    return FigDispatchQueueCreateWithPriority(a1, 0, a2);
}

void __figXPCCreateXPCConnectionInternal_block_invoke(uint64_t a1, void *a2)
{
  void *v2;
  uint64_t v4;
  id *context;
  id *v6;
  uint64_t v7;
  int uint64;
  xpc_object_t reply;
  const __CFAllocator *v10;
  CFStringRef v11;
  __CFDictionary *Mutable;
  CMMemoryPoolRef v13;
  int int64;
  unsigned int v15;
  CFMutableDictionaryRef v16;
  void *v17;
  uint64_t v18;
  const void *v19;
  const void *v20;
  uint64_t v21;
  NSObject *v22;
  void *v23;
  id v24;
  id v25;
  uint64_t v26;
  xpc_object_t v27;
  _xpc_connection_s *remote_connection;
  id *v29;
  id *v30;
  id v31;
  uint64_t v32;
  NSObject *v33;
  int64_t v34;
  CFMutableDictionaryRef v35;
  __CFNotificationCenter *DefaultLocalCenter;
  _QWORD *v37;
  void *v38;
  _QWORD *v39;
  BOOL v40;
  NSObject *v41;
  uint64_t v42;
  uint64_t v43;
  id v44;
  uint64_t v45;
  __CFDictionary *block;
  uint64_t v47;
  void *v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  CFTypeRef v52;
  CFTypeRef v53;
  xpc_object_t value;
  CFTypeRef v55;
  void *v56;

  v2 = a2;
  v4 = MEMORY[0x193FFCDCC](a2);
  context = (id *)xpc_connection_get_context(*(xpc_connection_t *)(a1 + 32));
  v6 = FigCFWeakReferenceHolderCopyReferencedObject(context);
  if (v6)
  {
    v7 = (uint64_t)v6;
    if (v4 == MEMORY[0x1E0C81310])
    {
      if (v2 == (void *)MEMORY[0x1E0C81260])
      {
        v17 = (void *)xpc_connection_copy_invalidation_reason();
        xpc_dictionary_get_string(MEMORY[0x1E0C81260], (const char *)*MEMORY[0x1E0C81270]);
        *(_DWORD *)(v7 + 80) = 1;
        free(v17);
      }
      v56 = 0;
      *(_QWORD *)(v7 + 64) = 0;
      if (*(_BYTE *)(v7 + 86))
        *(_DWORD *)(v7 + 80) = 1;
      *(_BYTE *)(v7 + 84) = 0;
      FigAtomicCompareAndSwap32(1, 0, (unsigned int *)(v7 + 92));
      FigSimpleMutexLock(*(pthread_mutex_t **)(*(_QWORD *)(v7 + 16) + 128));
      v18 = *(_QWORD *)(v7 + 16);
      v19 = *(const void **)(v18 + 136);
      if (v19)
      {
        CFRelease(v19);
        v18 = *(_QWORD *)(v7 + 16);
        *(_QWORD *)(v18 + 136) = 0;
      }
      v20 = *(const void **)(v18 + 144);
      if (v20)
      {
        CFRelease(v20);
        v18 = *(_QWORD *)(v7 + 16);
        *(_QWORD *)(v18 + 144) = 0;
      }
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v18 + 128));
      FigCFWeakReferenceTableCopyValues(*(_QWORD *)(v7 + 32), (CFMutableDictionaryRef *)&v56);
      CFRetain((CFTypeRef)v7);
      if (v56)
      {
        CFRetain(v56);
        v21 = (uint64_t)v56;
      }
      else
      {
        v21 = 0;
      }
      v22 = gCommonRemoteClientCleanupQueue;
      block = (__CFDictionary *)MEMORY[0x1E0C809B0];
      v47 = 0x40000000;
      v48 = __figXPCConnection_HandleConnectionDemise_block_invoke;
      v49 = &__block_descriptor_tmp_99;
      v50 = v21;
      v51 = v7;
    }
    else
    {
      if (v4 != MEMORY[0x1E0C812F8])
        goto LABEL_42;
      uint64 = xpc_dictionary_get_uint64(v2, ".Operation");
      if (uint64 <= 778989427)
      {
        if (uint64 != 778264932)
        {
          if (uint64 == 778398819)
          {
            block = 0;
            v55 = 0;
            v56 = 0;
            value = 0;
            reply = xpc_dictionary_create_reply(v2);
            if (*(_QWORD *)(*(_QWORD *)(v7 + 16) + 24) <= 3uLL)
            {
              FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
            }
            else
            {
              if (!v2)
              {
                FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
                goto LABEL_91;
              }
              if (!FigXPCConnectionCopyMemoryOriginForConnectedProcess(v7, &v55))
              {
                if (!FigXPCConnectionCopyMemoryRecipientForConnectedProcess(v7, (CFTypeRef *)&v56))
                {
                  v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
                  v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%s.%d.eventlink"), *(_QWORD *)(*(_QWORD *)(v7 + 16) + 16), *(unsigned int *)(v7 + 88));
                  Mutable = CFDictionaryCreateMutable(v10, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                  CFDictionarySetValue(Mutable, CFSTR("FigMemoryPool_LoggingName"), v11);
                  v13 = CMMemoryPoolCreate(Mutable);
                  if (Mutable)
                    CFRelease(Mutable);
                  int64 = xpc_dictionary_get_int64(v2, "ServerEventLinkMachThreadPriority");
                  v15 = xpc_dictionary_get_uint64(v2, "ServerEventLinkFigThreadPriority");
                  v2 = v56;
                  if (!FigOSEventLinkServerCreate((int)v10, v15, int64, v11, 0, v13, v55, v56, &block)
                    && !FigOSEventLinkServerSetAssociatedFigXPCServerXPCConnection((uint64_t)block, *(void **)(v7 + 40))&& !FigOSEventLinkServerCopyRemoteCreationInfoXPCObject((uint64_t)block, &value))
                  {
                    xpc_dictionary_set_value(reply, "RemoteEventLinkCreationInfo", value);
                    (*(void (**)(__CFDictionary *, _QWORD))(*(_QWORD *)(v7 + 16) + 80))(block, 0);
                  }
                  xpc_connection_send_message(*(xpc_connection_t *)(v7 + 40), reply);
                  if (v13)
                    CFRelease(v13);
                  if (v2)
                    goto LABEL_20;
                  goto LABEL_21;
                }
                v2 = v56;
LABEL_91:
                xpc_connection_send_message(*(xpc_connection_t *)(v7 + 40), reply);
                v11 = 0;
                if (v2)
LABEL_20:
                  CFRelease(v2);
LABEL_21:
                if (v55)
                  CFRelease(v55);
                if (v11)
                  CFRelease(v11);
                FigXPCRelease(value);
                FigXPCRelease(reply);
                v16 = block;
                if (!block)
                  goto LABEL_42;
                goto LABEL_41;
              }
            }
            v2 = 0;
            goto LABEL_91;
          }
          goto LABEL_67;
        }
        v56 = 0;
        v27 = xpc_dictionary_create_reply(v2);
        remote_connection = xpc_dictionary_get_remote_connection(v2);
        v29 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(v7 + 24));
        v30 = v29;
        if (v29)
        {
          v31 = v29[2];
          block = (__CFDictionary *)MEMORY[0x1E0C809B0];
          v47 = 0x40000000;
          v48 = __figXPCConnection_handleCreateAdminConnectionReplyMessageFromServer_block_invoke;
          v49 = &__block_descriptor_tmp_102;
          v50 = (uint64_t)v2;
          if (!figXPCCreateXPCConnectionInternal(v29, v31, 0x600000000, &v56, &block))
          {
            v30[4] = v56;
            v56 = 0;
          }
          if (!remote_connection)
            goto LABEL_57;
        }
        else
        {
          FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
          if (!remote_connection)
          {
LABEL_57:
            if (v30)
              CFRelease(v30);
            if (v56)
              CFRelease(v56);
            FigXPCRelease(v27);
            goto LABEL_42;
          }
        }
        if (v27)
          xpc_connection_send_message(remote_connection, v27);
        goto LABEL_57;
      }
      if (uint64 == 779118369)
      {
        v32 = *(_QWORD *)(v7 + 16);
        if (*(_QWORD *)(v32 + 24) >= 3uLL && *(_QWORD *)(v32 + 72))
        {
          CFRetain((CFTypeRef)v7);
          FigXPCRetain(v2);
          v33 = *(NSObject **)(v7 + 56);
          block = (__CFDictionary *)MEMORY[0x1E0C809B0];
          v47 = 0x40000000;
          v48 = __figXPCConnection_CallObjectPurgedCallback_block_invoke;
          v49 = &__block_descriptor_tmp_105;
          v50 = (uint64_t)v2;
          v51 = v7;
          dispatch_async(v33, &block);
        }
        v34 = xpc_dictionary_get_int64(v2, ".PurgeIdentifier");
        v35 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        FigCFDictionarySetInt64(v35, CFSTR("xpcConnectionNotificationServerStatePurgedPayloadKey_PurgeIdentifier"), v34);
        DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("xpcConnectionNotification_ServerStatePurged"), (const void *)v7, v35);
        if (!v35)
          goto LABEL_42;
        v16 = v35;
        goto LABEL_41;
      }
      if (uint64 != 778989428)
      {
LABEL_67:
        v37 = *(_QWORD **)(v7 + 16);
        if (!v37[6] && (v37[3] < 2uLL || !v37[8]))
          goto LABEL_42;
        v38 = (void *)xpc_dictionary_get_uint64(v2, ".objectID");
        v39 = *(_QWORD **)(v7 + 16);
        if (v39[6])
          v40 = v38 == 0;
        else
          v40 = 1;
        if (v40)
        {
          if (v39[3] < 2uLL || !v39[8])
            goto LABEL_42;
          xpc_retain(v2);
          v41 = *(NSObject **)(v7 + 72);
          block = (__CFDictionary *)MEMORY[0x1E0C809B0];
          v47 = 0x40000000;
          v48 = __figXPCConnection_CallClientMessageHandlers_block_invoke_2;
          v49 = &__block_descriptor_tmp_109;
          v50 = v7;
          v51 = (uint64_t)v2;
        }
        else
        {
          v44 = figXPCConnection_copyObjectForID(v7, v38);
          if (!v44)
            goto LABEL_42;
          v45 = (uint64_t)v44;
          xpc_retain(v2);
          v41 = *(NSObject **)(v7 + 72);
          block = (__CFDictionary *)MEMORY[0x1E0C809B0];
          v47 = 0x40000000;
          v48 = __figXPCConnection_CallClientMessageHandlers_block_invoke;
          v49 = &__block_descriptor_tmp_108;
          v50 = v7;
          v51 = v45;
          v52 = v2;
        }
        dispatch_async(v41, &block);
LABEL_42:
        CFRelease((CFTypeRef)v7);
        return;
      }
      v56 = 0;
      FigXPCMessageCopyCFString(v2, ".NotificationName", &v56);
      if (!v56)
        goto LABEL_42;
      v23 = (void *)xpc_dictionary_get_uint64(v2, ".objectID");
      v24 = figXPCConnection_copyObjectForID(v7, v23);
      if (v24)
      {
        v25 = v24;
        if (v56)
          CFRetain(v56);
        FigXPCRetain(v2);
        v26 = *(_QWORD *)(*(_QWORD *)(v7 + 16) + 40);
        v22 = *(NSObject **)(v7 + 56);
        block = (__CFDictionary *)MEMORY[0x1E0C809B0];
        v47 = 0x40000000;
        v48 = __figXPCConnection_HandleNotificationMessage_block_invoke;
        v49 = &__block_descriptor_tmp_100;
        v50 = (uint64_t)v2;
        v51 = v26;
        v52 = v25;
        v53 = v56;
      }
      else
      {
        v42 = *(_QWORD *)(v7 + 16);
        if (!*(_BYTE *)(v42 + 104) || (v43 = *(_QWORD *)(v42 + 40)) == 0)
        {
LABEL_40:
          v16 = (CFMutableDictionaryRef)v56;
          if (!v56)
            goto LABEL_42;
LABEL_41:
          CFRelease(v16);
          goto LABEL_42;
        }
        if (v56)
          CFRetain(v56);
        FigXPCRetain(v2);
        v22 = *(NSObject **)(v7 + 56);
        block = (__CFDictionary *)MEMORY[0x1E0C809B0];
        v47 = 0x40000000;
        v48 = __figXPCConnection_HandleNotificationMessage_block_invoke_2;
        v49 = &__block_descriptor_tmp_101_0;
        v50 = (uint64_t)v2;
        v51 = v43;
        v52 = v56;
      }
    }
    dispatch_async(v22, &block);
    goto LABEL_40;
  }
}

double figXPCConnection_Init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void figXPCConnection_Finalize(_QWORD *a1)
{
  _xpc_connection_s *v2;
  void *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;

  v2 = (_xpc_connection_s *)a1[5];
  if (v2)
  {
    xpc_connection_cancel(v2);
    v3 = (void *)a1[5];
    if (v3)
    {
      a1[5] = 0;
      xpc_release(v3);
    }
  }
  v4 = a1[9];
  if (v4)
  {
    dispatch_release(v4);
    a1[9] = 0;
  }
  v5 = a1[7];
  if (v5)
  {
    dispatch_release(v5);
    a1[7] = 0;
  }
  v6 = a1[6];
  if (v6)
  {
    dispatch_release(v6);
    a1[6] = 0;
  }
  v7 = (const void *)a1[4];
  if (v7)
  {
    CFRelease(v7);
    a1[4] = 0;
  }
  v8 = (const void *)a1[2];
  if (v8)
  {
    CFRelease(v8);
    a1[2] = 0;
  }
  v9 = (const void *)a1[3];
  if (v9)
  {
    CFRelease(v9);
    a1[3] = 0;
  }
  FigSimpleMutexDestroy(a1[12]);
  a1[12] = 0;
  v10 = (const void *)a1[13];
  if (v10)
  {
    CFRelease(v10);
    a1[13] = 0;
  }
}

__CFString *figXPCConnection_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  uint64_t v3;
  CFIndex v4;
  const char *v5;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16);
  v4 = CFGetRetainCount((CFTypeRef)a1);
  if (*(_DWORD *)(a1 + 80))
    v5 = " INVALID";
  else
    v5 = "";
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigXPCConnection %p %s> RC %d%s"), a1, v3, v4, v5);
  return Mutable;
}

uint64_t figXPCConnection_DeadConnectionObjectApplierFunction(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v5;
  void (*v6)(const void *);
  int v7;
  uint64_t v8;
  CFMutableDictionaryRef Mutable;
  _BOOL4 IsServerProcess;
  const void **v11;
  __CFNotificationCenter *DefaultLocalCenter;
  __CFNotificationCenter *v13;

  v5 = *(_QWORD *)(a3 + 16);
  v6 = *(void (**)(const void *))(v5 + 32);
  if (v6)
  {
    v6(a2);
    v5 = *(_QWORD *)(a3 + 16);
  }
  v7 = *(_DWORD *)(a3 + 88);
  v8 = *(_QWORD *)(v5 + 120);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetInt32(Mutable, CFSTR("PID"), v7);
  FigCFDictionarySetInt64(Mutable, CFSTR("ServerCapabilities"), v8);
  IsServerProcess = FigServer_IsServerProcess();
  v11 = (const void **)MEMORY[0x1E0C9AE50];
  if (!IsServerProcess)
    v11 = (const void **)MEMORY[0x1E0C9AE40];
  FigCFDictionarySetValue(Mutable, CFSTR("IsIndirectConnection"), *v11);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("MediaServicesProcessDeath"), a2, Mutable);
  if (Mutable)
    CFRelease(Mutable);
  v13 = CMNotificationCenterGetDefaultLocalCenter();
  return CMNotificationCenterPostNotification(v13, *(const __CFString **)(*(_QWORD *)(a3 + 16) + 96), a2, 0);
}

id figXPCConnection_copyObjectForID(uint64_t a1, void *a2)
{
  id result;

  result = FigCFWeakReferenceTableCopyValue(*(_QWORD *)(a1 + 32), a2);
  if (!result)
    return FigCFWeakReferenceTableCopyValue(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 112), a2);
  return result;
}

xpc_connection_t __figXPCConnection_handleCreateAdminConnectionReplyMessageFromServer_block_invoke(uint64_t a1)
{
  _xpc_endpoint_s *value;
  _xpc_endpoint_s *v2;
  xpc_connection_t result;

  value = (_xpc_endpoint_s *)xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 32), ".SecondaryEndpoint");
  if (!value
    || (v2 = value, MEMORY[0x193FFCDCC]() != MEMORY[0x1E0C81308])
    || (result = xpc_connection_create_from_endpoint(v2)) == 0)
  {
    FigSignalErrorAt(4294951137, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

double figXPCPerProcessInfo_Init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[9] = 0u;
  a1[10] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void figXPCPerProcessInfo_Finalize(uint64_t a1)
{
  const __CFArray *v2;
  CFIndex Count;
  CFIndex v4;
  CFIndex i;
  uint64_t *ValueAtIndex;
  const void *v7;
  _xpc_connection_s *v8;
  void *v9;
  NSObject *v10;
  const __CFArray *v11;
  CFIndex v12;
  CFIndex v13;
  CFIndex v14;
  uint64_t v15;
  _xpc_connection_s *v16;
  _xpc_connection_s *v17;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  char *v24;
  const void *v25;
  void *v26;
  void *v27;
  NSObject *v28;
  const void *v29;
  NSObject *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  os_log_type_t type;
  int v36[2];
  const char *v37;
  __int16 v38;
  _xpc_connection_s *v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  int v43;
  char v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v2 = *(const __CFArray **)(a1 + 88);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 48))
    {
      Count = CFArrayGetCount(v2);
      if (Count >= 1)
      {
        v4 = Count;
        for (i = 0; i != v4; ++i)
        {
          ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 88), i);
          figXPC_ForgetNotificationsForServedObject(*(_QWORD *)(a1 + 112), ValueAtIndex);
          FigCFWeakReferenceTableRemoveValue(*(_QWORD *)(a1 + 48), ValueAtIndex[3]);
        }
      }
    }
    v7 = *(const void **)(a1 + 88);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(a1 + 88) = 0;
    }
  }
  FigSimpleMutexDestroy(*(_QWORD *)(a1 + 80));
  *(_QWORD *)(a1 + 80) = 0;
  v8 = *(_xpc_connection_s **)(a1 + 32);
  if (v8)
  {
    xpc_connection_cancel(v8);
    v9 = *(void **)(a1 + 32);
    if (v9)
    {
      *(_QWORD *)(a1 + 32) = 0;
      xpc_release(v9);
    }
  }
  v10 = *(NSObject **)(a1 + 24);
  if (v10)
  {
    dispatch_release(v10);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v11 = *(const __CFArray **)(a1 + 144);
  if (v11)
  {
    v12 = CFArrayGetCount(v11);
    if (v12 >= 1)
    {
      v13 = v12;
      v14 = 0;
      v15 = MEMORY[0x1E0C812E0];
      do
      {
        v16 = (_xpc_connection_s *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 144), v14);
        v17 = v16;
        if (v16 && MEMORY[0x193FFCDCC](v16) == v15)
        {
          xpc_connection_cancel(v17);
          xpc_release(v17);
        }
        else
        {
          v36[0] = 0;
          type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v36, &type);
          v19 = v36[0];
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
            v21 = v19;
          else
            v21 = v19 & 0xFFFFFFFE;
          if (v21)
          {
            v22 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 88);
            v23 = *(_DWORD *)(a1 + 16);
            v36[1] = 136315906;
            v37 = "figXPCPerProcessInfo_DisposeSecondaryConnections";
            v38 = 2048;
            v39 = v17;
            v40 = 2082;
            v41 = v22;
            v42 = 1024;
            v43 = v23;
            v24 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v19) = v36[0];
          }
          else
          {
            v24 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v24, v24 != &v44, v19, 0, v20);
        }
        ++v14;
      }
      while (v13 != v14);
    }
    v25 = *(const void **)(a1 + 144);
    if (v25)
    {
      CFRelease(v25);
      *(_QWORD *)(a1 + 144) = 0;
    }
  }
  v26 = *(void **)(a1 + 136);
  if (v26)
  {
    *(_QWORD *)(a1 + 136) = 0;
    xpc_release(v26);
  }
  v27 = *(void **)(a1 + 128);
  if (v27)
  {
    *(_QWORD *)(a1 + 128) = 0;
    xpc_release(v27);
  }
  v28 = *(NSObject **)(a1 + 120);
  if (v28)
  {
    dispatch_release(v28);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v29 = *(const void **)(a1 + 48);
  if (v29)
  {
    CFRelease(v29);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v30 = *(NSObject **)(a1 + 104);
  if (v30)
  {
    dispatch_source_cancel(v30);
    *(_QWORD *)(a1 + 104) = 0;
  }
  v31 = *(const void **)(a1 + 112);
  if (v31)
  {
    CFRelease(v31);
    *(_QWORD *)(a1 + 112) = 0;
  }
  v32 = *(const void **)(a1 + 64);
  if (v32)
  {
    CFRelease(v32);
    *(_QWORD *)(a1 + 64) = 0;
  }
  v33 = *(const void **)(a1 + 72);
  if (v33)
  {
    CFRelease(v33);
    *(_QWORD *)(a1 + 72) = 0;
  }
  v34 = *(const void **)(a1 + 160);
  if (v34)
  {
    CFRelease(v34);
    *(_QWORD *)(a1 + 160) = 0;
  }
}

uint64_t figXPC_ForgetNotificationsForServedObject(uint64_t a1, CFTypeRef a2)
{
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  CFTypeRef *ValueAtIndex;
  CFTypeRef *v9;
  CFTypeRef v10;
  CFTypeRef v11;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 152));
  v4 = *(const __CFArray **)(a1 + 160);
  if (v4)
  {
    Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      v6 = Count;
      v7 = 0;
      do
      {
        ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 160), v7);
        if (*ValueAtIndex == a2)
        {
          v9 = ValueAtIndex;
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 160), v7);
          v10 = v9[1];
          if (v10)
            CFRelease(v10);
          v11 = v9[2];
          if (v11)
            CFRelease(v11);
          if (*v9)
            CFRelease(*v9);
          free(v9);
          --v6;
        }
        else
        {
          ++v7;
        }
      }
      while (v7 < v6);
    }
  }
  return FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 152));
}

uint64_t figXPC_RegisterServedObjectWithID(uint64_t a1, void *a2, const void *a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Instance;
  uint64_t v17;
  uint64_t v18;
  __CFNotificationCenter *DefaultLocalCenter;
  char v20;

  if (figXPCServedObject_GetTypeID_sRegisterServedObjectTypeOnce != -1)
    dispatch_once(&figXPCServedObject_GetTypeID_sRegisterServedObjectTypeOnce, &__block_literal_global_115);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return FigSignalErrorAt(4294951146, 0, 0, 0, 0, 0, 0);
  v17 = Instance;
  *(_QWORD *)(Instance + 16) = CFRetain(a3);
  *(_QWORD *)(v17 + 40) = a6;
  *(_QWORD *)(v17 + 48) = a7;
  *(_QWORD *)(v17 + 32) = a5;
  *(_QWORD *)(v17 + 56) = FigXPCRetain(a2);
  *(_QWORD *)(v17 + 24) = a8;
  v18 = FigCFWeakReferenceTableAddValueAssociatedWithKey(*(_QWORD *)(a1 + 48), (uint64_t)a3, a8);
  if (!(_DWORD)v18)
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 88), (const void *)v17);
    FigCFWeakReferenceStore((id *)(v17 + 64), (id)a1);
    if ((a4 & 1) != 0)
    {
      v20 = 0;
    }
    else
    {
      DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      FigNotificationCenterAddWeakListener(DefaultLocalCenter, (void *)v17, (CFNotificationCallback)figXPCServedObject_NotificationCallback, 0, (unint64_t)a3, 0, 0);
      v20 = 1;
    }
    *(_BYTE *)(v17 + 72) = v20;
  }
  CFRelease((CFTypeRef)v17);
  return v18;
}

void figXPCServedObject_NotificationCallback(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, const void *a5)
{
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  int v12;

  if (*(_QWORD *)(a2 + 56))
  {
    v8 = (uint64_t *)FigCFWeakReferenceLoadAndRetain((id *)(a2 + 64));
    if (v8)
    {
      v9 = v8;
      v10 = v8[14];
      FigSimpleMutexLock(*(pthread_mutex_t **)(v10 + 152));
      v11 = *(_DWORD *)(v10 + 172);
      if ((v11 - 1) < 2)
      {
        figXPC_EnqueueNotification((uint64_t)v9, v10, (CFTypeRef)a2, a3, a5);
        goto LABEL_9;
      }
      if (v11 == 3)
      {
        v12 = *(_DWORD *)(v10 + 168);
      }
      else
      {
        if (v11)
        {
LABEL_9:
          FigSimpleMutexUnlock(*(pthread_mutex_t **)(v10 + 152));
LABEL_12:
          CFRelease(v9);
          return;
        }
        v12 = *(_DWORD *)(v10 + 168);
        if (v12 >= 100)
        {
          *(_DWORD *)(v10 + 172) = 1;
          figXPC_EnqueueNotification((uint64_t)v9, v10, (CFTypeRef)a2, a3, a5);
          figXPC_SendNotificationCheckpoint((const void *)v10, *(_xpc_connection_s **)(a2 + 56));
          goto LABEL_9;
        }
      }
      *(_DWORD *)(v10 + 168) = v12 + 1;
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v10 + 152));
      figXPC_SendOneNotification((_QWORD *)a2, a3, a5);
      goto LABEL_12;
    }
  }
}

double figXPCServedObject_Init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void figXPCServedObject_Finalize(uint64_t a1)
{
  void (*v2)(void);
  const void *v3;
  __CFNotificationCenter *DefaultLocalCenter;
  void *v5;

  if (*(_QWORD *)(a1 + 32))
  {
    v2 = *(void (**)(void))(a1 + 40);
    if (v2)
    {
      v2();
      *(_QWORD *)(a1 + 32) = 0;
    }
  }
  v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    if (!*(_BYTE *)(a1 + 72)
      || (DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter(),
          FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, (const void *)a1, (uint64_t)figXPCServedObject_NotificationCallback, 0, *(const void **)(a1 + 16)), (v3 = *(const void **)(a1 + 16)) != 0))
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 16) = 0;
    }
  }
  FigCFWeakReferenceDestroy((id *)(a1 + 64));
  v5 = *(void **)(a1 + 56);
  if (v5)
  {
    *(_QWORD *)(a1 + 56) = 0;
    xpc_release(v5);
  }
}

void figXPC_EnqueueNotification(uint64_t a1, uint64_t a2, CFTypeRef a3, const void *a4, const void *a5)
{
  uint64_t v9;
  uint64_t (*v10)(const void *);
  int v11;
  CFIndex Count;
  CFIndex v13;
  CFIndex v14;
  CFTypeRef *ValueAtIndex;
  CFIndex v16;
  CFIndex v17;
  CFIndex v18;
  CFTypeRef *v19;
  CFTypeRef *v20;
  _QWORD *v21;
  _QWORD *v22;
  CFTypeRef v23;
  CFTypeRef v24;

  v9 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(v9 + 40) < 2uLL)
    goto LABEL_17;
  v10 = *(uint64_t (**)(const void *))(v9 + 72);
  if (!v10)
    goto LABEL_17;
  v11 = v10(a4);
  if (v11 == 3)
    return;
  if (v11 != 2)
  {
    if (v11 == 1)
    {
      Count = CFArrayGetCount(*(CFArrayRef *)(a2 + 160));
      if (Count >= 1)
      {
        v13 = Count;
        v14 = 0;
        do
        {
          ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 160), v14);
          if (*ValueAtIndex == a3)
          {
            if (CFEqual(a4, ValueAtIndex[1]))
              return;
          }
        }
        while (v13 != ++v14);
      }
    }
LABEL_17:
    v21 = malloc_type_malloc(0x18uLL, 0xE00406B48E91AuLL);
    if (v21)
    {
      v22 = v21;
      *v21 = CFRetain(a3);
      v22[1] = CFRetain(a4);
      if (a5)
        v23 = CFRetain(a5);
      else
        v23 = 0;
      v22[2] = v23;
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 160), v22);
    }
    return;
  }
  v16 = CFArrayGetCount(*(CFArrayRef *)(a2 + 160));
  if (v16 < 1)
    goto LABEL_17;
  v17 = v16;
  v18 = 0;
  while (1)
  {
    v19 = (CFTypeRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 160), v18);
    if (*v19 == a3)
    {
      v20 = v19;
      if (CFEqual(a4, v19[1]))
        break;
    }
    if (v17 == ++v18)
      goto LABEL_17;
  }
  v24 = v20[2];
  v20[2] = a5;
  if (a5)
    CFRetain(a5);
  if (v24)
    CFRelease(v24);
}

void figXPC_SendNotificationCheckpoint(const void *a1, _xpc_connection_s *a2)
{
  _QWORD v4[6];

  CFRetain(a1);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __figXPC_SendNotificationCheckpoint_block_invoke;
  v4[3] = &__block_descriptor_tmp_117;
  v4[4] = a1;
  v4[5] = a2;
  xpc_connection_send_barrier(a2, v4);
}

void figXPC_SendOneNotification(_QWORD *a1, const void *a2, const void *a3)
{
  int v6;
  void *v7;
  uint64_t (*v8)(_QWORD, _QWORD, const void *, const void *, const void **, void *);
  int v9;
  CFTypeRef v10;
  const void *v11;
  int v12[2];

  *(_QWORD *)v12 = 0;
  v6 = FigXPCCreateBasicMessage(0x2E6E6F74u, a1[3], v12);
  v7 = *(void **)v12;
  if (v6)
    goto LABEL_14;
  FigXPCMessageSetCFString(*(void **)v12, ".NotificationName", a2);
  v8 = (uint64_t (*)(_QWORD, _QWORD, const void *, const void *, const void **, void *))a1[6];
  if (!v8)
  {
    if (a3)
    {
LABEL_7:
      v10 = CFRetain(a3);
LABEL_8:
      if (v10)
      {
LABEL_9:
        if (!FigXPCMessageSetCFDictionary(v7, ".payload", v10))
          xpc_connection_send_notification();
        CFRelease(v10);
        v7 = *(void **)v12;
        goto LABEL_14;
      }
    }
LABEL_13:
    xpc_connection_send_notification();
    goto LABEL_14;
  }
  v11 = 0;
  v9 = v8(a1[4], a1[2], a2, a3, &v11, v7);
  v10 = 0;
  switch(v9)
  {
    case 0:
      if (!a3)
        goto LABEL_13;
      goto LABEL_7;
    case 2:
      goto LABEL_8;
    case 4:
      v10 = v11;
      if (!v11)
        goto LABEL_13;
      goto LABEL_9;
    default:
      break;
  }
LABEL_14:
  FigXPCRelease(v7);
}

double figXPCEnqueuedNotifications_Init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[9] = 0u;
  a1[10] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void figXPCEnqueuedNotifications_Finalize(_QWORD *a1)
{
  const void *v2;
  NSObject *v3;

  FigSimpleMutexDestroy(a1[19]);
  v2 = (const void *)a1[20];
  if (v2)
  {
    CFRelease(v2);
    a1[20] = 0;
  }
  v3 = a1[18];
  if (v3)
    dispatch_release(v3);
}

void figXPC_ForgetProcessInfo(uint64_t a1, int a2)
{
  const void *v3;
  _QWORD *Value;
  _QWORD *v5;
  uint64_t v6;
  pthread_mutex_t *v7;
  const __CFArray *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex i;
  CFTypeRef *ValueAtIndex;
  CFTypeRef v13;
  CFTypeRef v14;
  _QWORD block[5];

  v3 = (const void *)a2;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 104), (const void *)a2);
  if (Value)
  {
    v5 = Value;
    CFRetain(Value);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 104), v3);
    v6 = v5[14];
    FigSimpleMutexLock(*(pthread_mutex_t **)(v6 + 152));
    *(_DWORD *)(v6 + 172) = 3;
    v7 = *(pthread_mutex_t **)(v6 + 152);
    v8 = *(const __CFArray **)(v6 + 160);
    *(_QWORD *)(v6 + 160) = 0;
    FigSimpleMutexUnlock(v7);
    if (v8)
    {
      Count = CFArrayGetCount(v8);
      if (Count >= 1)
      {
        v10 = Count;
        for (i = 0; i != v10; ++i)
        {
          ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex(v8, i);
          if (*ValueAtIndex)
            CFRelease(*ValueAtIndex);
          v13 = ValueAtIndex[1];
          if (v13)
            CFRelease(v13);
          v14 = ValueAtIndex[2];
          if (v14)
            CFRelease(v14);
          free(ValueAtIndex);
        }
      }
      CFRelease(v8);
    }
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __figXPC_ForgetProcessInfo_block_invoke;
    block[3] = &__block_descriptor_tmp_126;
    block[4] = v5;
    dispatch_async((dispatch_queue_t)gCommonServerProcessCleanupQueue, block);
  }
  else
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 104), v3);
  }
}

void figXPC_HandleMessage(uint64_t a1, uint64_t a2, _xpc_connection_s *a3, xpc_object_t xdict)
{
  uint64_t uint64;
  void *context;
  CFTypeRef v10;
  int v11;
  xpc_object_t v12;
  xpc_object_t v13;
  _xpc_connection_s *remote_connection;
  xpc_object_t reply;
  void *v16;
  int updated;
  uint64_t v18;
  const char *string;
  const char *v20;
  uint64_t v21;
  CFStringRef v22;
  id v23;
  int v24;
  int64_t v25;
  CFNumberRef v26;
  NSObject **v27;
  void (*v28)(_xpc_connection_s *, xpc_object_t);
  int v29;
  xpc_object_t *v30;
  int v31;
  const __CFAllocator *v32;
  CFStringRef v33;
  __CFDictionary *Mutable;
  CMMemoryPoolRef v35;
  int int64;
  unsigned int v37;
  int v38;
  BOOL v39;
  int v40;
  xpc_object_t v41;
  uint64_t TimeoutNanoseconds;
  uint64_t v43;
  uint64_t v44;
  int64_t v45;
  uint64_t v46;
  NSObject *v47;
  dispatch_time_t v48;
  int64_t v49;
  CFNumberRef SInt64;
  _xpc_connection_s *v51;
  _xpc_connection_s *v52;
  CFTypeRef cf;
  xpc_object_t value;
  CFTypeRef v55;
  xpc_object_t xdicta[6];
  CFTypeRef v57;
  CFTypeRef *v58;
  uint64_t v59;
  char v60;

  uint64 = xpc_dictionary_get_uint64(xdict, ".Operation");
  context = xpc_connection_get_context(a3);
  if (context)
    v10 = CFRetain(context);
  else
    v10 = 0;
  xdicta[0] = 0;
  if (*(_BYTE *)(a1 + 125) && FigAtomicCompareAndSwap32(0, 1u, (unsigned int *)(a2 + 40)))
  {
    figXPCServer_EstablishSecondaryConnectionManagement((xpc_endpoint_t)a1, a2);
    v11 = FigXPCCreateBasicMessage(0x2E636164u, 0, xdicta);
    v12 = xdicta[0];
    if (!v11)
    {
      xpc_dictionary_set_value(xdicta[0], ".SecondaryEndpoint", *(xpc_object_t *)(a2 + 136));
      v13 = xpc_connection_send_message_with_reply_sync(a3, v12);
      goto LABEL_8;
    }
  }
  else
  {
    v12 = 0;
  }
  v13 = 0;
LABEL_8:
  FigXPCRelease(v13);
  FigXPCRelease(v12);
  if ((uint64 & 0x100000000) == 0)
  {
    remote_connection = xpc_dictionary_get_remote_connection(xdict);
    reply = xpc_dictionary_create_reply(xdict);
    if (!reply)
    {
      FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
      goto LABEL_81;
    }
    v16 = reply;
    if ((int)uint64 <= 779120230)
    {
      if ((_DWORD)uint64 != 775056996)
      {
        if ((_DWORD)uint64 != 778398835)
        {
          if ((_DWORD)uint64 == 779055719)
          {
            updated = FigMemoryRecipientCreateWithXPCMessage1AndUpdateXPCMessage2(xdict, reply, *(const char **)(a1 + 88), (uint64_t **)(a2 + 72));
LABEL_72:
            v24 = updated;
            goto LABEL_73;
          }
          goto LABEL_84;
        }
        v55 = 0;
        xdicta[0] = 0;
        v57 = 0;
        cf = 0;
        value = 0;
        v51 = remote_connection;
        if (*(_QWORD *)(a1 + 40) > 2uLL && *(_QWORD *)(a1 + 80) && a3)
        {
          v31 = FigXPCServerCopyMemoryOrigin(a3, &v55);
          if (!v31)
          {
            v31 = FigXPCServerCopyMemoryRecipient(a3, &v57);
            if (!v31)
            {
              FigServer_CopyProcessName(*(unsigned int *)(a2 + 16), (CFStringRef *)&cf);
              v32 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
              v33 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%s.%d.%@.eventlink"), *(_QWORD *)(*(_QWORD *)(a2 + 56) + 88), *(unsigned int *)(a2 + 16), cf);
              Mutable = CFDictionaryCreateMutable(v32, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              CFDictionarySetValue(Mutable, CFSTR("FigMemoryPool_LoggingName"), v33);
              v35 = CMMemoryPoolCreate(Mutable);
              if (Mutable)
                CFRelease(Mutable);
              int64 = xpc_dictionary_get_int64(xdict, "ServerEventLinkMachThreadPriority");
              v37 = xpc_dictionary_get_uint64(xdict, "ServerEventLinkFigThreadPriority");
              v38 = FigOSEventLinkServerCreate((int)v32, v37, int64, v33, 0, v35, v55, v57, xdicta);
              if (!v38)
              {
                v38 = FigOSEventLinkServerSetAssociatedFigXPCServerXPCConnection((uint64_t)xdicta[0], a3);
                if (!v38)
                {
                  v38 = FigOSEventLinkServerCopyRemoteCreationInfoXPCObject((uint64_t)xdicta[0], &value);
                  if (!v38)
                  {
                    xpc_dictionary_set_value(v16, "RemoteEventLinkCreationInfo", value);
                    v38 = (*(uint64_t (**)(xpc_object_t, _QWORD))(a1 + 80))(xdicta[0], 0);
                  }
                }
              }
              v24 = v38;
              goto LABEL_58;
            }
          }
        }
        else
        {
          v31 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
        }
        v24 = v31;
        v35 = 0;
        v33 = 0;
LABEL_58:
        if (cf)
          CFRelease(cf);
        if (v35)
          CFRelease(v35);
        if (v57)
          CFRelease(v57);
        remote_connection = v51;
        if (v55)
          CFRelease(v55);
        if (v33)
          CFRelease(v33);
        FigXPCRelease(value);
        if (xdicta[0])
          CFRelease(xdicta[0]);
        goto LABEL_73;
      }
      v29 = *(_DWORD *)(a2 + 16);
      xdicta[0] = 0;
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 112));
      v24 = figXPC_CopyInfoForProcess(a1, v29, xdicta);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 112));
      v30 = (xpc_object_t *)xdicta[0];
      if (v24)
      {
        if (!xdicta[0])
          goto LABEL_45;
      }
      else
      {
        figXPCServer_EstablishSecondaryConnectionManagement((xpc_endpoint_t)a1, (uint64_t)xdicta[0]);
        xpc_dictionary_set_value(v16, ".SecondaryEndpoint", v30[17]);
      }
      CFRelease(v30);
LABEL_45:
      FigXPCRelease(0);
LABEL_73:
      v39 = 0;
LABEL_74:
      xdicta[0] = 0;
      if ((gCommonServerCapabilities & 1) != 0
        || !FigAtomicCompareAndSwap32(0, 1u, (unsigned int *)(a2 + 44)))
      {
        v41 = 0;
      }
      else
      {
        v40 = FigProcessStateMonitorServerEnsureStartedAndCopyEndpoint(xdicta);
        v41 = xdicta[0];
        if (!v40)
        {
          xpc_dictionary_set_value(v16, ".ProcessStateMonitorEndpoint", xdicta[0]);
          v41 = xdicta[0];
        }
      }
      FigXPCRelease(v41);
      if (!v39)
      {
        xpc_dictionary_set_int64(v16, ".ErrorReturn", v24);
        xpc_connection_send_message(remote_connection, v16);
      }
      xpc_release(v16);
      goto LABEL_81;
    }
    if ((_DWORD)uint64 == 779251762)
    {
      updated = FigMemoryOriginCompleteEstablishingMemoryRecipientUsingXPCMessage2(xdict, (_QWORD *)(a2 + 64));
      goto LABEL_72;
    }
    if ((_DWORD)uint64 == 779251761)
    {
      updated = FigMemoryOriginBeginEstablishingMemoryRecipientByFillingInXPCMessage1(reply);
      goto LABEL_72;
    }
    if ((_DWORD)uint64 != 779120231)
    {
LABEL_84:
      TimeoutNanoseconds = FigRPCServer_GetTimeoutNanoseconds();
      if (*((_QWORD *)v10 + 28))
      {
        v43 = *((_QWORD *)v10 + 29);
        v44 = *((_QWORD *)v10 + 28);
      }
      else
      {
        v44 = TimeoutNanoseconds;
        v43 = 0;
      }
      v45 = xpc_dictionary_get_int64(xdict, ".SelfTerminationTimeout");
      if (1000000000 * v45)
      {
        v44 = 1000000000 * v45;
        v46 = 0;
      }
      else
      {
        v46 = v43;
      }
      if (v44 && v46)
        v44 = FigRPCServer_PickRPCTimeoutForCurrentThread(v44, v46);
      xpc_dictionary_set_int64(v16, ".Token", *((_QWORD *)v10 + 25));
      if (v44)
      {
        xpc_dictionary_set_int64(v16, ".ErrorReturn", -16156);
        xpc_retain(v16);
        *((_QWORD *)v10 + 27) = xpc_retain(xdict);
        dispatch_set_context(*((dispatch_object_t *)v10 + 24), v16);
        v47 = *((_QWORD *)v10 + 24);
        v48 = dispatch_time(0, v44);
        dispatch_source_set_timer(v47, v48, 0xFFFFFFFFFFFFFFFFLL, 0x1DCD6500uLL);
        *((_BYTE *)v10 + 208) = 1;
      }
      v49 = xpc_dictionary_get_int64(xdict, ".AbortActionID");
      if (v49)
      {
        v52 = remote_connection;
        if (*(_BYTE *)(a1 + 125))
        {
          SInt64 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v49);
          os_unfair_lock_lock((os_unfair_lock_t)(a2 + 168));
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 160), SInt64, v10);
          os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 168));
        }
        else
        {
          SInt64 = 0;
        }
        v24 = (*(uint64_t (**)(_xpc_connection_s *, xpc_object_t, void *))(a1 + 48))(a3, xdict, v16);
        if (*(_BYTE *)(a1 + 125))
        {
          os_unfair_lock_lock((os_unfair_lock_t)(a2 + 168));
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a2 + 160), SInt64);
          os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 168));
        }
        if (SInt64)
          CFRelease(SInt64);
        remote_connection = v52;
      }
      else
      {
        v24 = (*(uint64_t (**)(_xpc_connection_s *, xpc_object_t, void *))(a1 + 48))(a3, xdict, v16);
      }
      v57 = 0;
      v58 = &v57;
      v59 = 0x2000000000;
      v60 = 0;
      if (*((_BYTE *)v10 + 208))
      {
        *((_BYTE *)v10 + 208) = 0;
        dispatch_source_set_timer(*((dispatch_source_t *)v10 + 24), 0xFFFFFFFFFFFFFFFFLL, 0, 0x1DCD6500uLL);
        xdicta[0] = (xpc_object_t)MEMORY[0x1E0C809B0];
        xdicta[1] = (xpc_object_t)0x40000000;
        xdicta[2] = __figXPC_UnsetTimeoutTimer_block_invoke;
        xdicta[3] = &unk_1E28E60F8;
        xdicta[4] = &v57;
        xdicta[5] = (xpc_object_t)v10;
        dispatch_sync((dispatch_queue_t)gCommonServerTimeoutQueue, xdicta);
        v39 = *((_BYTE *)v58 + 24) != 0;
      }
      else
      {
        v39 = 0;
      }
      _Block_object_dispose(&v57, 8);
      if ((uint64 & 0x200000000) != 0)
        v39 = 0;
      goto LABEL_74;
    }
    string = xpc_dictionary_get_string(xdict, ".ProcessName");
    if (string)
    {
      v20 = string;
      v21 = *MEMORY[0x1E0C9AE00];
      v22 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], string, 0x8000100u);
      if (v22)
      {
        if (xpc_dictionary_get_BOOL(xdict, ".IsDaemon"))
          FigApplicationStateMonitorAddPIDToIgnore(*((_DWORD *)v10 + 40));
        FigProcessInfoCreateWithDetails(v21, *((_DWORD *)v10 + 40), v22, (_QWORD *)v10 + 3);
        v23 = FigCFWeakReferenceLoadAndRetain((id *)v10 + 2);
        if (v23)
        {
          strncpy((char *)xdicta, v20, 8uLL);
          *((xpc_object_t *)v10 + 21) = xdicta[0];
        }
        goto LABEL_29;
      }
    }
    else
    {
      v22 = 0;
    }
    v23 = 0;
LABEL_29:
    xpc_dictionary_set_uint64(v16, ".ServerCapabilities", gCommonServerCapabilities);
    xpc_dictionary_set_int64(v16, ".Token", *((_QWORD *)v10 + 25));
    if (v23)
      CFRelease(v23);
    if (v22)
      CFRelease(v22);
    v24 = 0;
    goto LABEL_73;
  }
  if ((_DWORD)uint64 != 779382561)
  {
    if ((_DWORD)uint64 == 779318384)
    {
      v25 = xpc_dictionary_get_int64(xdict, ".AbortActionID");
      if (v25)
      {
        v26 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v25);
        os_unfair_lock_lock((os_unfair_lock_t)(a2 + 168));
        v27 = (NSObject **)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 160), v26);
        if (v27)
          FigThreadAbortQueue(v27[30]);
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 168));
        if (v26)
          CFRelease(v26);
      }
    }
    else if ((_DWORD)uint64 == 778986352)
    {
      v18 = xpc_dictionary_get_uint64(xdict, ".objectID");
      FigXPCServerDisassociateObjectWithConnection(a3, v18);
    }
    else
    {
      v28 = *(void (**)(_xpc_connection_s *, xpc_object_t))(a1 + 56);
      if (v28)
        v28(a3, xdict);
    }
LABEL_81:
    if (!v10)
      return;
    goto LABEL_82;
  }
  *((_QWORD *)v10 + 28) = 1000000000 * xpc_dictionary_get_int64(xdict, ".SelfTerminationTimeout");
  *((_QWORD *)v10 + 29) = 0;
LABEL_82:
  CFRelease(v10);
}

void figXPC_CreateNewConnectionInfo(uint64_t a1, NSObject *a2, uint64_t *a3)
{
  uint64_t Instance;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  NSObject *v11;
  uint64_t v12;
  _QWORD handler[5];

  if (!a2)
  {
    v12 = 4294951145;
LABEL_12:
    FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
    return;
  }
  if (figXPCConnectionInfo_GetTypeID_sRegisterConnectionInfoTypeOnce != -1)
    dispatch_once(&figXPCConnectionInfo_GetTypeID_sRegisterConnectionInfoTypeOnce, &__block_literal_global_141);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v12 = 4294951146;
    goto LABEL_12;
  }
  v7 = Instance;
  FigCFWeakReferenceStore((id *)(Instance + 16), (id)a1);
  *(_DWORD *)(v7 + 160) = *(_DWORD *)(a1 + 16);
  *(_QWORD *)(v7 + 240) = a2;
  dispatch_retain(a2);
  strncpy((char *)(v7 + 32), *(const char **)(*(_QWORD *)(a1 + 56) + 88), 0x7FuLL);
  *(_QWORD *)(v7 + 192) = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, (dispatch_queue_t)gCommonServerTimeoutQueue);
  *(_QWORD *)(v7 + 200) = FigRemote_GetServerTimeoutToken();
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(_DWORD *)(v8 + 96);
  if (v9)
    *(_QWORD *)(v7 + 224) = 1000000000 * v9;
  v10 = *(_DWORD *)(v8 + 100);
  if (v10)
    *(_QWORD *)(v7 + 232) = 1000000000 * v10;
  v11 = *(NSObject **)(v7 + 192);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 0x40000000;
  handler[2] = __figXPC_CreateNewConnectionInfo_block_invoke;
  handler[3] = &__block_descriptor_tmp_138;
  handler[4] = v7;
  dispatch_source_set_event_handler(v11, handler);
  dispatch_resume(*(dispatch_object_t *)(v7 + 192));
  *a3 = v7;
}

void figXPC_ConnectionInfoFinalizer(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

double figXPCConnectionInfo_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 240) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void figXPCConnectionInfo_Finalize(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  const void *v5;

  FigCFWeakReferenceDestroy((id *)(a1 + 16));
  if (*(_QWORD *)(a1 + 176))
  {
    (*(void (**)(void))(a1 + 184))();
    *(_QWORD *)(a1 + 176) = 0;
    *(_QWORD *)(a1 + 184) = 0;
  }
  v2 = *(NSObject **)(a1 + 192);
  if (v2)
  {
    dispatch_source_cancel(v2);
    v3 = *(NSObject **)(a1 + 192);
    if (v3)
    {
      dispatch_release(v3);
      *(_QWORD *)(a1 + 192) = 0;
    }
  }
  v4 = *(NSObject **)(a1 + 240);
  if (v4)
    dispatch_release(v4);
  v5 = *(const void **)(a1 + 24);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 24) = 0;
  }
}

uint64_t OpCodeChar(unsigned int a1, unsigned int a2)
{
  uint64_t v4;
  unsigned int v5;
  char __str[5];
  unsigned int v9;

  v9 = a1;
  v4 = MEMORY[0x1E0C80978];
  if (a1 > 0x7Fu)
  {
    if (!__maskrune(a1, 0x40000uLL))
      goto LABEL_17;
  }
  else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * a1 + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  if (((a1 >> 8) & 0x80) != 0)
  {
    if (!__maskrune(BYTE1(a1), 0x40000uLL))
      goto LABEL_17;
  }
  else if ((*(_DWORD *)(v4 + 4 * BYTE1(a1) + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  if ((a1 & 0x800000) != 0)
  {
    if (!__maskrune(BYTE2(a1), 0x40000uLL))
      goto LABEL_17;
  }
  else if ((*(_DWORD *)(v4 + 4 * BYTE2(a1) + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  v5 = HIBYTE(a1);
  if ((a1 & 0x80000000) != 0)
  {
    if (__maskrune(v5, 0x40000uLL))
      return (char)*((_BYTE *)&v9 + a2);
LABEL_17:
    snprintf(__str, 5uLL, "%4d", a1);
    return __str[-a2 + 3];
  }
  if ((*(_DWORD *)(v4 + 4 * v5 + 60) & 0x40000) == 0)
    goto LABEL_17;
  return (char)*((_BYTE *)&v9 + a2);
}

xpc_endpoint_t figXPCServer_EstablishSecondaryConnectionManagement(xpc_endpoint_t result, uint64_t a2)
{
  xpc_endpoint_t v3;
  _xpc_connection_s *v4;
  _xpc_connection_s *v5;
  _QWORD v6[6];

  if (!*(_QWORD *)(a2 + 128))
  {
    v3 = result;
    v4 = xpc_connection_create(0, (dispatch_queue_t)gCommonServerListenerQueue);
    *(_QWORD *)(a2 + 128) = v4;
    xpc_connection_set_context(v4, (void *)a2);
    *(_QWORD *)(a2 + 144) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
    v5 = *(_xpc_connection_s **)(a2 + 128);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __figXPCServer_EstablishSecondaryConnectionManagement_block_invoke;
    v6[3] = &__block_descriptor_tmp_144;
    v6[4] = v3;
    v6[5] = a2;
    xpc_connection_set_event_handler(v5, v6);
    xpc_connection_activate(*(xpc_connection_t *)(a2 + 128));
    result = xpc_endpoint_create(*(xpc_connection_t *)(a2 + 128));
    *(_QWORD *)(a2 + 136) = result;
  }
  return result;
}

xpc_object_t FigXPCRetain(xpc_object_t object)
{
  if (object)
    return xpc_retain(object);
  return object;
}

void FigXPCRelease(xpc_object_t object)
{
  if (object)
    xpc_release(object);
}

uint64_t FigXPCMessageSetCFObject(void *a1, const char *a2, CFTypeRef cf)
{
  CFTypeID v6;
  void *v8;
  void *v9;
  uint64_t v10;

  if (!cf)
    return 0;
  if (a1 && a2)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == CFDictionaryGetTypeID())
      return FigXPCMessageSetCFDictionary(a1, a2, cf);
    v8 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    if (v8)
    {
      v9 = v8;
      xpc_dictionary_set_value(a1, a2, v8);
      xpc_release(v9);
      return 0;
    }
    v10 = 4294950015;
  }
  else
  {
    v10 = 4294950016;
  }
  return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFDictionary(void *a1, const char *a2, CFTypeRef cf)
{
  CFTypeID v6;
  __CFDictionary *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v12;

  if (!cf)
    return 0;
  if (a1 && a2)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == CFDictionaryGetTypeID())
    {
      v7 = figXPCCopySanitizedCFDictionary(cf);
      v8 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      if (v8)
      {
        v9 = v8;
        xpc_dictionary_set_value(a1, a2, v8);
        xpc_release(v9);
        v10 = 0;
        if (!v7)
          return v10;
      }
      else
      {
        v10 = FigSignalErrorAt(4294950015, 0, 0, 0, 0, 0, 0);
        if (!v7)
          return v10;
      }
      CFRelease(v7);
      return v10;
    }
    v12 = 4294950013;
  }
  else
  {
    v12 = 4294950016;
  }
  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFURL(void *a1, const char *a2, CFTypeRef cf)
{
  CFTypeID v5;
  void *v6;
  void *v7;
  uint64_t v9;

  if (!cf)
    return 0;
  if (a1 && a2)
  {
    v5 = CFGetTypeID(cf);
    if (v5 == CFURLGetTypeID())
    {
      v6 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      if (v6)
      {
        v7 = v6;
        xpc_dictionary_set_value(a1, a2, v6);
        xpc_release(v7);
        return 0;
      }
      v9 = 4294950015;
    }
    else
    {
      v9 = 4294950013;
    }
  }
  else
  {
    v9 = 4294950016;
  }
  return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
}

__CFDictionary *figXPCCopySanitizedCFDictionary(const void *a1)
{
  const void *v2;
  CFTypeID v3;
  const void *v5[3];

  v5[2] = *(const void **)MEMORY[0x1E0C80C00];
  v2 = (const void *)*MEMORY[0x1E0CA8F88];
  v5[0] = *(const void **)MEMORY[0x1E0CA9008];
  v5[1] = v2;
  v3 = CFGetTypeID(a1);
  if (v3 == CFDictionaryGetTypeID())
    return FigCFDictionaryCreateCopyRemovingKeys((CFDictionaryRef)a1, v5, 2);
  else
    return 0;
}

uint64_t FigXPCMessageSetCFString(void *a1, const char *a2, CFTypeRef cf)
{
  CFTypeID v5;
  void *v6;
  void *v7;
  uint64_t v9;

  if (!cf)
    return 0;
  if (a1 && a2)
  {
    v5 = CFGetTypeID(cf);
    if (v5 == CFStringGetTypeID())
    {
      v6 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      if (v6)
      {
        v7 = v6;
        xpc_dictionary_set_value(a1, a2, v6);
        xpc_release(v7);
        return 0;
      }
      v9 = 4294950015;
    }
    else
    {
      v9 = 4294950013;
    }
  }
  else
  {
    v9 = 4294950016;
  }
  return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFNumber(void *a1, const char *a2, CFTypeRef cf)
{
  CFTypeID v6;
  uint64_t v8;

  if (!cf)
    return 0;
  if (a1)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == CFNumberGetTypeID())
      return FigXPCMessageSetCFObject(a1, a2, cf);
    v8 = 4294950013;
  }
  else
  {
    v8 = 4294950016;
  }
  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFBoolean(void *a1, const char *a2, CFTypeRef cf)
{
  CFTypeID v6;
  uint64_t v8;

  if (!cf)
    return 0;
  if (a1)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == CFBooleanGetTypeID())
      return FigXPCMessageSetCFObject(a1, a2, cf);
    v8 = 4294950013;
  }
  else
  {
    v8 = 4294950016;
  }
  return FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFArray(void *a1, const char *a2, CFTypeRef cf)
{
  CFTypeID v5;
  void *v6;
  void *v7;
  uint64_t v9;

  if (!cf)
    return 0;
  if (a1 && a2)
  {
    v5 = CFGetTypeID(cf);
    if (v5 == CFArrayGetTypeID())
    {
      v6 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      if (v6)
      {
        v7 = v6;
        xpc_dictionary_set_value(a1, a2, v6);
        xpc_release(v7);
        return 0;
      }
      v9 = 4294950015;
    }
    else
    {
      v9 = 4294950013;
    }
  }
  else
  {
    v9 = 4294950016;
  }
  return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFDate(void *a1, const char *a2, CFTypeRef cf)
{
  CFTypeID v6;
  double v7;
  uint64_t v9;

  if (!cf)
    return 0;
  if (a1 && a2)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == CFDateGetTypeID())
    {
      v7 = MEMORY[0x193FFAC60](cf);
      xpc_dictionary_set_double(a1, a2, v7);
      return 0;
    }
    v9 = 4294950013;
  }
  else
  {
    v9 = 4294950016;
  }
  return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFData(void *a1, const char *a2, CFTypeRef cf)
{
  CFTypeID v6;
  void *v7;
  uint64_t v9;
  int v10;
  char __dst[8];

  if (!cf)
    return 0;
  v10 = 0;
  if (!a1 || !a2)
  {
    v9 = 4294950016;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  v6 = CFGetTypeID(cf);
  if (v6 != CFDataGetTypeID())
  {
    v9 = 4294950013;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  v7 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  xpc_dictionary_set_value(a1, a2, v7);
  xpc_release(v7);
  FigXPCMessageGetOpCode(a1, &v10);
  if (gGMFigKTraceEnabled == 1)
  {
    strncpy(__dst, a2, 8uLL);
    CFDataGetLength((CFDataRef)cf);
    kdebug_trace();
  }
  return 0;
}

uint64_t FigXPCMessageSetAndConsumeVMData(xpc_object_t xdict, char *key, void *bytes, size_t size)
{
  uint64_t v7;
  NSObject *v9;
  NSObject *v10;
  xpc_object_t v11;
  uint64_t v12;

  v7 = 4294950016;
  if (!xdict || !key)
    goto LABEL_12;
  if (!size)
  {
    xpc_dictionary_set_data(xdict, key, bytes, 0);
    return 0;
  }
  if (bytes)
  {
    v9 = dispatch_data_create(bytes, size, 0, (dispatch_block_t)*MEMORY[0x1E0C80CF8]);
    if (v9)
    {
      v10 = v9;
      v11 = xpc_data_create_with_dispatch_data(v9);
      dispatch_release(v10);
      if (v11)
      {
        xpc_dictionary_set_value(xdict, key, v11);
        xpc_release(v11);
        return 0;
      }
      v7 = 4294950014;
      return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
    }
    v7 = 4294950014;
LABEL_12:
    v12 = FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
    if (bytes)
    {
      if (size)
        MEMORY[0x193FFCA84](*MEMORY[0x1E0C83DA0], bytes, size);
    }
    return v12;
  }
  return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetCFError(void *a1, const char *a2, __CFError *a3)
{
  __CFDictionary *v5;
  uint64_t v6;

  if (!a3)
    return 0;
  if (a1 && a2)
  {
    v5 = FigCFCopyCFErrorAsPropertyList(a3);
    v6 = FigXPCMessageSetCFDictionary(a1, a2, v5);
    if (v5)
      CFRelease(v5);
    return v6;
  }
  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFError(void *a1, const char *a2, const __CFDictionary **a3)
{
  uint64_t v4;
  CFTypeRef v5;
  const __CFDictionary *v6;
  CFTypeRef cf;

  cf = 0;
  if (!a1 || !a2)
  {
    v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    if (a3)
      *a3 = 0;
    return v4;
  }
  if (a3)
  {
    v4 = FigXPCMessageCopyCFDictionary(a1, a2, &cf);
    v5 = cf;
    if ((_DWORD)v4)
    {
      v6 = 0;
    }
    else
    {
      v6 = FigCFErrorCreateFromPropertyList((const __CFDictionary *)cf);
      v5 = cf;
    }
    *a3 = v6;
    if (v5)
      CFRelease(v5);
    return v4;
  }
  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFDictionary(void *a1, const char *a2, _QWORD *a3)
{
  uint64_t v4;
  CFTypeRef v5;
  CFTypeID v6;
  CFTypeRef cf;

  cf = 0;
  if (!a1 || !a2)
  {
    v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    v5 = 0;
    if (!a3)
      return v4;
    goto LABEL_9;
  }
  if (a3)
  {
    v4 = FigXPCMessageCopyCFObject(a1, a2, (__CFDictionary **)&cf);
    v5 = cf;
    if (!(_DWORD)v4)
    {
      if (!cf)
      {
        v4 = 0;
        goto LABEL_9;
      }
      v6 = CFGetTypeID(cf);
      if (v6 == CFDictionaryGetTypeID())
      {
        v4 = 0;
        v5 = cf;
LABEL_9:
        *a3 = v5;
        return v4;
      }
      v4 = FigSignalErrorAt(4294950013, 0, 0, 0, 0, 0, 0);
      v5 = cf;
    }
    if ((_DWORD)v4)
    {
      if (v5)
      {
        CFRelease(v5);
        v5 = 0;
      }
    }
    goto LABEL_9;
  }
  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFObject(void *a1, const char *a2, __CFDictionary **a3)
{
  uint64_t result;
  __CFDictionary *v5;
  __CFDictionary *v6;
  CFTypeID v7;
  __CFDictionary *v8;

  if (a1 && a2)
  {
    if (a3)
    {
      result = (uint64_t)xpc_dictionary_get_value(a1, a2);
      if (result)
      {
        v5 = (__CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
        v6 = v5;
        if (v5)
        {
          v7 = CFGetTypeID(v5);
          if (v7 == CFDictionaryGetTypeID())
          {
            v8 = figXPCCopySanitizedCFDictionary(v6);
            CFRelease(v6);
            result = 0;
            v6 = v8;
          }
          else
          {
            result = 0;
          }
        }
        else
        {
          result = FigSignalErrorAt(4294950015, 0, 0, 0, 0, 0, 0);
        }
      }
      else
      {
        v6 = 0;
      }
      goto LABEL_9;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    v6 = 0;
    if (a3)
LABEL_9:
      *a3 = v6;
  }
  return result;
}

uint64_t FigXPCMessageCopyCFString(void *a1, const char *a2, _QWORD *a3)
{
  uint64_t v4;
  CFTypeRef v5;
  CFTypeID v6;
  CFTypeRef cf;

  cf = 0;
  if (!a1 || !a2)
  {
    v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    v5 = 0;
    if (!a3)
      return v4;
    goto LABEL_9;
  }
  if (a3)
  {
    v4 = FigXPCMessageCopyCFObject(a1, a2, (__CFDictionary **)&cf);
    v5 = cf;
    if (!(_DWORD)v4)
    {
      if (!cf)
      {
        v4 = 0;
        goto LABEL_9;
      }
      v6 = CFGetTypeID(cf);
      if (v6 == CFStringGetTypeID())
      {
        v4 = 0;
        v5 = cf;
LABEL_9:
        *a3 = v5;
        return v4;
      }
      v4 = FigSignalErrorAt(4294950013, 0, 0, 0, 0, 0, 0);
      v5 = cf;
    }
    if ((_DWORD)v4)
    {
      if (v5)
      {
        CFRelease(v5);
        v5 = 0;
      }
    }
    goto LABEL_9;
  }
  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFNumber(void *a1, const char *a2, _QWORD *a3)
{
  uint64_t v4;
  CFTypeRef v5;
  CFTypeID v6;
  CFTypeRef cf;

  cf = 0;
  if (!a1 || !a2)
  {
    v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    v5 = 0;
    if (!a3)
      return v4;
    goto LABEL_9;
  }
  if (a3)
  {
    v4 = FigXPCMessageCopyCFObject(a1, a2, (__CFDictionary **)&cf);
    v5 = cf;
    if (!(_DWORD)v4)
    {
      if (!cf)
      {
        v4 = 0;
        goto LABEL_9;
      }
      v6 = CFGetTypeID(cf);
      if (v6 == CFNumberGetTypeID())
      {
        v4 = 0;
        v5 = cf;
LABEL_9:
        *a3 = v5;
        return v4;
      }
      v4 = FigSignalErrorAt(4294950013, 0, 0, 0, 0, 0, 0);
      v5 = cf;
    }
    if ((_DWORD)v4)
    {
      if (v5)
      {
        CFRelease(v5);
        v5 = 0;
      }
    }
    goto LABEL_9;
  }
  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFBoolean(void *a1, const char *a2, _QWORD *a3)
{
  uint64_t v4;
  CFTypeRef v5;
  CFTypeID v6;
  CFTypeRef cf;

  cf = 0;
  if (!a1 || !a2)
  {
    v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    v5 = 0;
    if (!a3)
      return v4;
    goto LABEL_9;
  }
  if (a3)
  {
    v4 = FigXPCMessageCopyCFObject(a1, a2, (__CFDictionary **)&cf);
    v5 = cf;
    if (!(_DWORD)v4)
    {
      if (!cf)
      {
        v4 = 0;
        goto LABEL_9;
      }
      v6 = CFGetTypeID(cf);
      if (v6 == CFBooleanGetTypeID())
      {
        v4 = 0;
        v5 = cf;
LABEL_9:
        *a3 = v5;
        return v4;
      }
      v4 = FigSignalErrorAt(4294950013, 0, 0, 0, 0, 0, 0);
      v5 = cf;
    }
    if ((_DWORD)v4)
    {
      if (v5)
      {
        CFRelease(v5);
        v5 = 0;
      }
    }
    goto LABEL_9;
  }
  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFArray(void *a1, const char *a2, _QWORD *a3)
{
  uint64_t v4;
  CFTypeRef v5;
  CFTypeID v6;
  CFTypeRef cf;

  cf = 0;
  if (!a1 || !a2)
  {
    v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    v5 = 0;
    if (!a3)
      return v4;
    goto LABEL_9;
  }
  if (a3)
  {
    v4 = FigXPCMessageCopyCFObject(a1, a2, (__CFDictionary **)&cf);
    v5 = cf;
    if (!(_DWORD)v4)
    {
      if (!cf)
      {
        v4 = 0;
        goto LABEL_9;
      }
      v6 = CFGetTypeID(cf);
      if (v6 == CFArrayGetTypeID())
      {
        v4 = 0;
        v5 = cf;
LABEL_9:
        *a3 = v5;
        return v4;
      }
      v4 = FigSignalErrorAt(4294950013, 0, 0, 0, 0, 0, 0);
      v5 = cf;
    }
    if ((_DWORD)v4)
    {
      if (v5)
      {
        CFRelease(v5);
        v5 = 0;
      }
    }
    goto LABEL_9;
  }
  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFDate(void *a1, const char *a2, CFDateRef *a3)
{
  double v4;
  CFDateRef v5;
  CFDateRef v6;
  uint64_t result;

  if (a1 && a2)
  {
    if (a3)
    {
      v4 = xpc_dictionary_get_double(a1, a2);
      v5 = CFDateCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v4);
      if (v5)
      {
        v6 = v5;
        result = 0;
      }
      else
      {
        result = FigSignalErrorAt(4294950014, 0, 0, 0, 0, 0, 0);
        v6 = 0;
      }
      goto LABEL_6;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    v6 = 0;
    if (a3)
LABEL_6:
      *a3 = v6;
  }
  return result;
}

uint64_t FigXPCMessageCopyCFData(void *a1, const char *a2, _QWORD *a3)
{
  uint64_t v4;
  CFTypeRef v5;
  CFTypeID v6;
  CFTypeRef cf;

  cf = 0;
  if (!a1 || !a2)
  {
    v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    v5 = 0;
    if (!a3)
      return v4;
    goto LABEL_9;
  }
  if (a3)
  {
    v4 = FigXPCMessageCopyCFObject(a1, a2, (__CFDictionary **)&cf);
    v5 = cf;
    if (!(_DWORD)v4)
    {
      if (!cf)
      {
        v4 = 0;
        goto LABEL_9;
      }
      v6 = CFGetTypeID(cf);
      if (v6 == CFDataGetTypeID())
      {
        v4 = 0;
        v5 = cf;
LABEL_9:
        *a3 = v5;
        return v4;
      }
      v4 = FigSignalErrorAt(4294950013, 0, 0, 0, 0, 0, 0);
      v5 = cf;
    }
    if ((_DWORD)v4)
    {
      if (v5)
      {
        CFRelease(v5);
        v5 = 0;
      }
    }
    goto LABEL_9;
  }
  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyCFURL(void *a1, const char *a2, _QWORD *a3)
{
  uint64_t v4;
  CFTypeRef v5;
  CFTypeID v6;
  CFTypeRef cf;

  cf = 0;
  if (!a1 || !a2)
  {
    v4 = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    v5 = 0;
    if (!a3)
      return v4;
    goto LABEL_9;
  }
  if (a3)
  {
    v4 = FigXPCMessageCopyCFObject(a1, a2, (__CFDictionary **)&cf);
    v5 = cf;
    if (!(_DWORD)v4)
    {
      if (!cf)
      {
        v4 = 0;
        goto LABEL_9;
      }
      v6 = CFGetTypeID(cf);
      if (v6 == CFURLGetTypeID())
      {
        v4 = 0;
        v5 = cf;
LABEL_9:
        *a3 = v5;
        return v4;
      }
      v4 = FigSignalErrorAt(4294950013, 0, 0, 0, 0, 0, 0);
      v5 = cf;
    }
    if ((_DWORD)v4)
    {
      if (v5)
      {
        CFRelease(v5);
        v5 = 0;
      }
    }
    goto LABEL_9;
  }
  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCreateBlockBufferDataWithSize(const __CFAllocator *a1, xpc_object_t xdict, char *key, size_t a4, CMBlockBufferRef *a5)
{
  uint64_t result;
  size_t v10;
  CMBlockBufferCustomBlockSource customBlockSource;
  CMBlockBufferRef blockBufferOut;
  size_t length;

  blockBufferOut = 0;
  HIDWORD(customBlockSource.AllocateBlock) = 0;
  *(_QWORD *)&customBlockSource.version = 0;
  customBlockSource.refCon = xdict;
  customBlockSource.FreeBlock = (void (__cdecl *)(void *, void *, size_t))BBufUtilXPCObjectReleaser;
  if (xdict && key)
  {
    if (a5)
    {
      length = 0;
      result = (uint64_t)xpc_dictionary_get_data(xdict, key, &length);
      if (result)
      {
        v10 = length;
        if (a4 && length > a4)
        {
          length = a4;
          v10 = a4;
        }
        result = CMBlockBufferCreateWithMemoryBlock(a1, (void *)result, v10, 0, &customBlockSource, 0, v10, 0, &blockBufferOut);
        if (!(_DWORD)result)
        {
          xpc_retain(xdict);
          result = 0;
        }
      }
      goto LABEL_10;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    if (a5)
LABEL_10:
      *a5 = blockBufferOut;
  }
  return result;
}

uint64_t FigXPCMessageCreateBlockBufferData(const __CFAllocator *a1, void *a2, char *a3, CMBlockBufferRef *a4)
{
  return FigXPCMessageCreateBlockBufferDataWithSize(a1, a2, a3, 0, a4);
}

uint64_t FigXPCMessageSetBlockBuffer(void *a1, char *a2, CMBlockBufferRef theBuffer)
{
  vm_map_t *v3;
  uint64_t DataPointer;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  int v13;
  CMBlockBufferRef blockBufferOut;
  char *dataPointerOut;
  size_t lengthAtOffsetOut;
  vm_address_t address;
  size_t totalLengthOut;
  char __dst[8];

  address = 0;
  totalLengthOut = 0;
  dataPointerOut = 0;
  lengthAtOffsetOut = 0;
  blockBufferOut = 0;
  v13 = 0;
  v3 = (vm_map_t *)MEMORY[0x1E0C83DA0];
  if (!theBuffer)
  {
LABEL_17:
    v10 = 0;
    goto LABEL_18;
  }
  if (!a1 || !a2)
  {
    v12 = 4294950016;
LABEL_25:
    DataPointer = FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
    goto LABEL_26;
  }
  DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut);
  if ((_DWORD)DataPointer)
    goto LABEL_26;
  v8 = totalLengthOut;
  if (!totalLengthOut)
  {
    v12 = 4294954590;
    goto LABEL_25;
  }
  if (totalLengthOut >= *MEMORY[0x1E0C85AD8])
  {
    DataPointer = vm_allocate(*v3, &address, totalLengthOut, 1543503873);
    if (!(_DWORD)DataPointer)
    {
      DataPointer = CMBlockBufferCopyDataBytes(theBuffer, 0, totalLengthOut, (void *)address);
      if (!(_DWORD)DataPointer)
      {
        v9 = FigXPCMessageSetAndConsumeVMData(a1, a2, (void *)address, totalLengthOut);
        address = 0;
        if ((_DWORD)v9)
        {
          v10 = v9;
          goto LABEL_20;
        }
        goto LABEL_15;
      }
    }
  }
  else
  {
    if (lengthAtOffsetOut == totalLengthOut)
    {
LABEL_11:
      xpc_dictionary_set_data(a1, a2, dataPointerOut, v8);
LABEL_15:
      FigXPCMessageGetOpCode(a1, &v13);
      if (gGMFigKTraceEnabled == 1)
      {
        strncpy(__dst, a2, 8uLL);
        kdebug_trace();
      }
      goto LABEL_17;
    }
    DataPointer = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theBuffer, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, totalLengthOut, 0, &blockBufferOut);
    if (!(_DWORD)DataPointer)
    {
      DataPointer = CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &dataPointerOut);
      if (!(_DWORD)DataPointer)
      {
        v8 = totalLengthOut;
        goto LABEL_11;
      }
    }
  }
LABEL_26:
  v10 = DataPointer;
LABEL_18:
  if (address)
    MEMORY[0x193FFCA84](*v3, address, totalLengthOut);
LABEL_20:
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v10;
}

uint64_t FigXPCMessageSetCMTime(void *a1, const char *a2, const void *a3)
{
  if (!a1 || !a2)
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  xpc_dictionary_set_data(a1, a2, a3, 0x18uLL);
  return 0;
}

uint64_t FigXPCMessageGetCMTime(void *a1, const char *a2, uint64_t a3)
{
  _QWORD *data;
  _QWORD *v5;
  uint64_t result;
  __int128 v7;
  uint64_t v8;
  size_t length;

  length = 0;
  v7 = *(_OWORD *)&kCMTimeInvalid.value;
  v8 = 0;
  if (a1 && a2)
  {
    if (a3)
    {
      data = xpc_dictionary_get_data(a1, a2, &length);
      if (data)
      {
        if (length == 24)
        {
          v5 = data;
          result = 0;
          v7 = *(_OWORD *)v5;
          v8 = v5[2];
        }
        else
        {
          result = FigSignalErrorAt(4294950012, 0, 0, 0, 0, 0, 0);
        }
      }
      else
      {
        result = 4294950011;
      }
      goto LABEL_7;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    if (a3)
    {
LABEL_7:
      *(_OWORD *)a3 = v7;
      *(_QWORD *)(a3 + 16) = v8;
    }
  }
  return result;
}

uint64_t FigXPCArraySetCMTime(void *a1, uint64_t a2, const void *a3)
{
  if (!a1 || a2 != -1 || (xpc_array_get_count(a1) & 0x80000000) != 0)
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  xpc_array_set_data(a1, 0xFFFFFFFFFFFFFFFFLL, a3, 0x18uLL);
  return 0;
}

uint64_t FigXPCArrayAppendCMTime(void *a1, __int128 *a2)
{
  __int128 v3;
  uint64_t v4;

  v3 = *a2;
  v4 = *((_QWORD *)a2 + 2);
  return FigXPCArraySetCMTime(a1, -1, &v3);
}

uint64_t FigXPCArrayGetCMTime(void *a1, int64_t a2, uint64_t a3)
{
  _QWORD *data;
  _QWORD *v7;
  uint64_t result;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  size_t length;

  length = 0;
  v10 = *(_OWORD *)&kCMTimeInvalid.value;
  v11 = 0;
  if (!a1 || a2 < 0)
  {
    result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    if (a3)
      goto LABEL_8;
  }
  else
  {
    if (a3)
    {
      if (a2 >= (int)xpc_array_get_count(a1))
      {
        v9 = 4294950016;
      }
      else
      {
        data = xpc_array_get_data(a1, a2, &length);
        if (!data)
        {
          result = 4294950013;
          goto LABEL_8;
        }
        if (length == 24)
        {
          v7 = data;
          result = 0;
          v10 = *(_OWORD *)v7;
          v11 = v7[2];
LABEL_8:
          *(_OWORD *)a3 = v10;
          *(_QWORD *)(a3 + 16) = v11;
          return result;
        }
        v9 = 4294950012;
      }
      result = FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
      goto LABEL_8;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigXPCMessageSetCMTimeRange(void *a1, const char *a2, const void *a3)
{
  if (!a1 || !a2)
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  xpc_dictionary_set_data(a1, a2, a3, 0x30uLL);
  return 0;
}

uint64_t FigXPCMessageGetCMTimeRange(void *a1, const char *a2, CMTimeRange *a3)
{
  CMTimeRange *data;
  CMTimeRange *v5;
  uint64_t result;
  CMTimeRange v7;
  size_t length;

  length = 0;
  v7 = kCMTimeRangeInvalid;
  if (a1 && a2)
  {
    if (a3)
    {
      data = (CMTimeRange *)xpc_dictionary_get_data(a1, a2, &length);
      if (data)
      {
        if (length == 48)
        {
          v5 = data;
          result = 0;
          v7 = *v5;
        }
        else
        {
          result = FigSignalErrorAt(4294950012, 0, 0, 0, 0, 0, 0);
        }
      }
      else
      {
        result = 4294950011;
      }
      goto LABEL_7;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    if (a3)
LABEL_7:
      *a3 = v7;
  }
  return result;
}

uint64_t FigXPCMessageSetCMTimeMapping(void *a1, const char *a2, const void *a3)
{
  if (!a1 || !a2)
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  xpc_dictionary_set_data(a1, a2, a3, 0x60uLL);
  return 0;
}

uint64_t FigXPCMessageGetCMTimeMapping(void *a1, const char *a2, CMTimeMapping *a3)
{
  CMTimeMapping *data;
  CMTimeMapping *v5;
  uint64_t result;
  CMTimeMapping v7;
  size_t length;

  length = 0;
  v7 = kCMTimeMappingInvalid;
  if (a1 && a2)
  {
    if (a3)
    {
      data = (CMTimeMapping *)xpc_dictionary_get_data(a1, a2, &length);
      if (data)
      {
        if (length == 96)
        {
          v5 = data;
          result = 0;
          v7 = *v5;
        }
        else
        {
          result = FigSignalErrorAt(4294950012, 0, 0, 0, 0, 0, 0);
        }
      }
      else
      {
        result = 4294950011;
      }
      goto LABEL_7;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    if (a3)
LABEL_7:
      *a3 = v7;
  }
  return result;
}

void FigXPCMessageSetOSStatus(void *a1, const char *a2, int a3)
{
  if (a1 && a2)
    xpc_dictionary_set_int64(a1, a2, a3);
  else
    FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

int64_t FigXPCMessageGetOSStatus(void *a1, const char *a2)
{
  int64_t result;
  uint64_t v3;

  if (a1)
  {
    if (a2)
    {
      result = xpc_dictionary_get_int64(a1, a2);
      if (result == (int)result)
        return result;
      v3 = 4294950013;
    }
    else
    {
      v3 = 4294950016;
    }
  }
  else
  {
    v3 = 4294950016;
  }
  return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
}

void FigXPCMessageSetInt32(void *a1, const char *a2, int a3)
{
  if (a1 && a2)
    xpc_dictionary_set_int64(a1, a2, a3);
  else
    FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

int64_t FigXPCMessageGetInt32(void *a1, const char *a2)
{
  int64_t result;
  uint64_t v3;

  if (a1)
  {
    if (a2)
    {
      result = xpc_dictionary_get_int64(a1, a2);
      if (result == (int)result)
        return result;
      v3 = 4294950013;
    }
    else
    {
      v3 = 4294950016;
    }
  }
  else
  {
    v3 = 4294950016;
  }
  FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  return 0;
}

void FigXPCMessageSetUInt32(void *a1, const char *a2, uint64_t value)
{
  if (a1 && a2)
    xpc_dictionary_set_uint64(a1, a2, value);
  else
    FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageGetUInt32(void *a1, const char *a2)
{
  uint64_t result;
  uint64_t v3;

  if (a1)
  {
    if (a2)
    {
      result = xpc_dictionary_get_uint64(a1, a2);
      if (!HIDWORD(result))
        return result;
      v3 = 4294950013;
    }
    else
    {
      v3 = 4294950016;
    }
  }
  else
  {
    v3 = 4294950016;
  }
  FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t FigXPCMessageSetFormatDescriptionArray(void *a1, const char *a2, const __CFArray *a3)
{
  uint64_t result;
  const void *v6;
  vm_size_t v7;

  v6 = 0;
  v7 = 0;
  if (!a3)
    return 0;
  if (!a1 || !a2)
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  result = FigRemote_CreateSerializedAtomDataForFormatDescriptions(a3, (uint64_t *)&v6, *MEMORY[0x1E0C85AD8], &v7);
  if (!(_DWORD)result)
  {
    xpc_dictionary_set_data(a1, a2, v6, v7);
    MEMORY[0x193FFCA84](*MEMORY[0x1E0C83DA0], v6, v7);
    return 0;
  }
  return result;
}

uint64_t FigXPCMessageCopyFormatDescriptionArray(void *a1, const char *a2, __CFArray **a3)
{
  uint64_t result;
  __CFArray *v5;
  size_t v6;
  __CFArray *v7;

  v6 = 0;
  v7 = 0;
  if (a1 && a2)
  {
    if (a3)
    {
      result = (uint64_t)xpc_dictionary_get_data(a1, a2, &v6);
      if (result)
      {
        result = FigRemote_CreateFormatDescriptionArrayFromSerializedAtomData(result, v6, &v7);
        v5 = v7;
      }
      else
      {
        v5 = 0;
      }
      goto LABEL_7;
    }
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    result = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    v5 = 0;
    if (a3)
LABEL_7:
      *a3 = v5;
  }
  return result;
}

uint64_t FigXPCMessageSetFormatDescription(void *a1, char *a2, uint64_t a3)
{
  uint64_t SerializedAtomDataBlockBufferForFormatDescription;
  CFTypeRef v6;
  uint64_t v7;
  CFTypeRef cf;

  cf = 0;
  if (!a3)
    return 0;
  if (a1 && a2)
  {
    SerializedAtomDataBlockBufferForFormatDescription = FigRemote_CreateSerializedAtomDataBlockBufferForFormatDescription((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3, (CMBlockBufferRef *)&cf);
    v6 = cf;
    if ((_DWORD)SerializedAtomDataBlockBufferForFormatDescription)
    {
      v7 = SerializedAtomDataBlockBufferForFormatDescription;
      if (!cf)
        return v7;
    }
    else
    {
      v7 = FigXPCMessageSetBlockBuffer(a1, a2, (CMBlockBufferRef)cf);
      v6 = cf;
      if (!cf)
        return v7;
    }
    CFRelease(v6);
    return v7;
  }
  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyFormatDescription2(const __CFAllocator *a1, void *a2, char *a3, _QWORD *a4)
{
  uint64_t BlockBufferDataWithSize;
  uint64_t v7;
  CFTypeRef v8;
  uint64_t v10;
  CFTypeRef cf;

  v10 = 0;
  cf = 0;
  if (!a2 || !a3)
  {
    BlockBufferDataWithSize = FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    if (a4)
      *a4 = 0;
    return BlockBufferDataWithSize;
  }
  if (a4)
  {
    BlockBufferDataWithSize = FigXPCMessageCreateBlockBufferDataWithSize(a1, a2, a3, 0, (CMBlockBufferRef *)&cf);
    v7 = 0;
    v8 = cf;
    if (!(_DWORD)BlockBufferDataWithSize && cf)
    {
      BlockBufferDataWithSize = FigRemote_CreateFormatDescriptionFromSerializedAtomDataBlockBuffer(a1, (CMBlockBufferRef)cf, 0, &v10);
      v7 = v10;
      v8 = cf;
    }
    *a4 = v7;
    if (v8)
      CFRelease(v8);
    return BlockBufferDataWithSize;
  }
  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyFormatDescription(void *a1, char *a2, _QWORD *a3)
{
  return FigXPCMessageCopyFormatDescription2((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a1, a2, a3);
}

BOOL FigXPCConnectionHasEntitlement(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  _BOOL8 v4;

  if (!a1 || !a2)
  {
    FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v2 = xpc_connection_copy_entitlement_value();
  if (!v2)
    return 0;
  v3 = (void *)v2;
  v4 = MEMORY[0x193FFCDCC]() == MEMORY[0x1E0C812D0] && xpc_BOOL_get_value(v3);
  xpc_release(v3);
  return v4;
}

xpc_object_t FigXPCArrayGetCount(xpc_object_t xarray)
{
  if (xarray)
    return (xpc_object_t)xpc_array_get_count(xarray);
  return xarray;
}

uint64_t FigXPCMessageSetBlockBufferUsingMemoryOrigin(void *a1, const char *a2, CMBlockBufferRef theBuffer, uint64_t a4, uint64_t *a5)
{
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  vm_address_t DataLength;
  void *v15;
  uint64_t v16;
  char *dataPointerOut;
  int v18;
  CMBlockBufferRef theBuffera;

  theBuffera = 0;
  if (theBuffer)
  {
    v10 = *a5;
    if (!CMBlockBufferGetDataLength(theBuffer))
      return 0;
    if (FigMemoryOriginIsBlockBufferSendable(a4, theBuffer))
      return FigMemoryOriginSetBlockBufferInXPCMessage(a4, a1, a2, theBuffer);
    v18 = 0;
    DataLength = CMBlockBufferGetDataLength(theBuffer);
    dataPointerOut = 0;
    if (!v10)
    {
      v15 = FigCopyCommonMemoryPool();
      if (!v15)
      {
        v16 = FigSignalErrorAt(4294950014, 0, 0, 0, 0, 0, 0);
LABEL_14:
        v12 = v16;
        if (theBuffera)
          CFRelease(theBuffera);
        return v12;
      }
      v10 = (uint64_t)v15;
      *a5 = (uint64_t)v15;
    }
    v16 = (uint64_t)FigMemoryPoolCreateBlockBuffer(v10, DataLength, &theBuffera, v13);
    if (!(_DWORD)v16)
    {
      CMBlockBufferGetDataPointer(theBuffera, 0, 0, 0, &dataPointerOut);
      v16 = CMBlockBufferCopyDataBytes(theBuffer, 0, DataLength, dataPointerOut);
      if (!(_DWORD)v16)
      {
        FigXPCMessageGetOpCode(a1, &v18);
        if (gGMFigKTraceEnabled == 1)
          kdebug_trace();
        v16 = FigMemoryOriginSetBlockBufferInXPCMessage(a4, a1, a2, theBuffera);
      }
    }
    goto LABEL_14;
  }
  return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageCopyBlockBufferUsingMemoryRecipient(const __CFAllocator *a1, xpc_object_t xdict, char *key, uint64_t a4, CMBlockBufferRef *a5)
{
  if (xdict && key && a4 && a5)
    return FigMemoryRecipientCopyBlockBufferFromXPCMessage(a1, a4, xdict, key, a5);
  else
    return FigSignalErrorAt(4294950016, 0, 0, 0, 0, 0, 0);
}

OpaqueCMBlockBuffer *FigXPCMessageAddDataBufferFromCMSampleBuffer(void *a1, CMSampleBufferRef sbuf, uint64_t a3, uint64_t *a4)
{
  OpaqueCMBlockBuffer *result;
  OpaqueCMBlockBuffer *v9;

  if (!sbuf || CMSampleBufferDataIsReady(sbuf) != 1)
    return (OpaqueCMBlockBuffer *)FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  result = CMSampleBufferGetDataBuffer(sbuf);
  if (result)
  {
    v9 = result;
    if (CMBlockBufferGetDataLength(result) > 0x3000)
      return (OpaqueCMBlockBuffer *)FigXPCMessageSetBlockBufferUsingMemoryOrigin(a1, "SampleData-PooledBBuf", v9, a3, a4);
    else
      return (OpaqueCMBlockBuffer *)FigXPCMessageSetBlockBuffer(a1, "SampleData-Inline", v9);
  }
  return result;
}

uint64_t FigXPCMessageAddCMSampleBufferForPID(void *a1, CMSampleBufferRef sbuf, const __CFArray *a3, unsigned int a4, uint64_t a5, const opaqueCMFormatDescription **a6, uint64_t *a7, int a8)
{
  const opaqueCMFormatDescription *v8;
  uint64_t v9;
  char v17;
  uint64_t CopyWithNoData;
  void *v19;
  unsigned int v20;
  uint64_t v21;
  size_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  OpaqueCMBlockBuffer *v26;
  const opaqueCMFormatDescription *v27;
  CFTypeRef v28;
  uint64_t v29;
  uint64_t v31;
  CFTypeRef v33;
  CFTypeRef v34;
  CFTypeRef v35;
  char *dataPointerOut;
  CMBlockBufferRef theBuffer;
  size_t size;
  CFTypeRef cf;

  v33 = 0;
  v8 = *a6;
  size = 0;
  cf = 0;
  v9 = *a7;
  dataPointerOut = 0;
  theBuffer = 0;
  v34 = 0;
  v35 = 0;
  if (!sbuf)
  {
    v31 = 4294951145;
LABEL_44:
    CopyWithNoData = FigSignalErrorAt(v31, 0, 0, 0, 0, 0, 0);
    goto LABEL_45;
  }
  v17 = a4;
  if (CMSampleBufferDataIsReady(sbuf))
  {
    v35 = CFRetain(sbuf);
  }
  else
  {
    if ((a4 & 1) == 0 || (v17 & 2) == 0)
    {
      v31 = 4294951145;
      goto LABEL_44;
    }
    CopyWithNoData = FigSampleBufferCreateCopyWithNoData((const __CFAllocator *)*MEMORY[0x1E0C9AE00], sbuf, (CMSampleBufferRef *)&v35);
    if ((_DWORD)CopyWithNoData)
      goto LABEL_45;
  }
  if (!v9)
  {
    v19 = FigCopyCommonMemoryPool();
    if (!v19)
    {
LABEL_42:
      v31 = 4294951146;
      goto LABEL_44;
    }
    v9 = (uint64_t)v19;
    *a7 = (uint64_t)v19;
  }
  CopyWithNoData = FigRemote_CopyReplacementAttachmentsForSampleBuffer(v35, a3, (__CFDictionary **)&v34, (__CFDictionary **)&v33);
  if ((_DWORD)CopyWithNoData)
    goto LABEL_45;
  v20 = (a4 >> 2) & 1;
  CopyWithNoData = FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptionsForPID((opaqueCMSampleBuffer *)v35, (const __CFDictionary *)v34, (const __CFDictionary *)v33, v20, 0, 0, &size, v8, 0, a8);
  if ((_DWORD)CopyWithNoData)
    goto LABEL_45;
  v22 = size;
  if (size <= 0x3000)
  {
    v23 = (char *)malloc_type_calloc(1uLL, size, 0x17D1D8E2uLL);
    dataPointerOut = v23;
    if (v23)
    {
      v24 = v23;
      v25 = FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptionsForPID((opaqueCMSampleBuffer *)v35, (const __CFDictionary *)v34, (const __CFDictionary *)v33, v20, (uint64_t)v23, size, 0, v8, &cf, a8);
      if ((_DWORD)v25)
      {
        v29 = v25;
LABEL_29:
        free(v24);
        goto LABEL_30;
      }
      xpc_dictionary_set_data(a1, "SerializedMetadata-Inline", v24, size);
      if ((v17 & 2) != 0)
        goto LABEL_22;
LABEL_21:
      v26 = FigXPCMessageAddDataBufferFromCMSampleBuffer(a1, (CMSampleBufferRef)v35, a5, a7);
      if ((_DWORD)v26)
      {
        v29 = (uint64_t)v26;
LABEL_27:
        if (v22 > 0x3000)
          goto LABEL_30;
        v24 = dataPointerOut;
        goto LABEL_29;
      }
LABEL_22:
      v27 = *a6;
      v28 = cf;
      *a6 = (const opaqueCMFormatDescription *)cf;
      if (v28)
        CFRetain(v28);
      if (v27)
        CFRelease(v27);
      v29 = 0;
      goto LABEL_27;
    }
    goto LABEL_42;
  }
  CopyWithNoData = (uint64_t)FigMemoryPoolCreateBlockBuffer(v9, size, &theBuffer, v21);
  if (!(_DWORD)CopyWithNoData)
  {
    CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
    CopyWithNoData = FigRemote_WriteSerializedAtomDataForSampleBufferExcludingDataBufferWithOptionsForPID((opaqueCMSampleBuffer *)v35, (const __CFDictionary *)v34, (const __CFDictionary *)v33, v20, (uint64_t)dataPointerOut, size, 0, v8, &cf, a8);
    if (!(_DWORD)CopyWithNoData)
    {
      CopyWithNoData = FigMemoryOriginSetBlockBufferInXPCMessage(a5, a1, "SerializedMetadata-PooledBBuf", theBuffer);
      if (!(_DWORD)CopyWithNoData)
      {
        if ((v17 & 2) != 0)
          goto LABEL_22;
        goto LABEL_21;
      }
    }
  }
LABEL_45:
  v29 = CopyWithNoData;
LABEL_30:
  if (v34)
    CFRelease(v34);
  if (v33)
    CFRelease(v33);
  if (theBuffer)
    CFRelease(theBuffer);
  if (cf)
    CFRelease(cf);
  if (v35)
    CFRelease(v35);
  return v29;
}

uint64_t FigXPCMessageAddCMSampleBuffer(void *a1, opaqueCMSampleBuffer *a2, unsigned int a3, uint64_t a4, const opaqueCMFormatDescription **a5, uint64_t *a6)
{
  return FigXPCMessageAddCMSampleBufferForPID(a1, a2, 0, a3, a4, a5, a6, 0);
}

uint64_t FigXPCMessageCopyDataBufferFromCMSampleBufferMessage(const __CFAllocator *a1, void *a2, uint64_t a3, CMBlockBufferRef *a4)
{
  uint64_t result;
  CMBlockBufferRef v7;
  CMBlockBufferRef v8;

  v8 = 0;
  if (!a4)
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  result = FigXPCMessageCopyBlockBufferUsingMemoryRecipient(a1, a2, "SampleData-PooledBBuf", a3, &v8);
  if (!(_DWORD)result)
  {
    v7 = v8;
    if (!v8)
    {
      result = FigXPCMessageCreateBlockBufferDataWithSize((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2, "SampleData-Inline", 0, &v8);
      if ((_DWORD)result)
        return result;
      v7 = v8;
    }
    result = 0;
    *a4 = v7;
  }
  return result;
}

uint64_t FigXPCMessageCopyCMSampleBufferWithLastCryptor(const __CFAllocator *a1, xpc_object_t xdict, uint64_t a3, char a4, const opaqueCMFormatDescription **a5, CFTypeRef *a6, CMSampleBufferRef *a7)
{
  uint64_t SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor;
  uint64_t v15;
  CFTypeRef cf;
  size_t length;
  char *dataPointerOut;
  CMBlockBufferRef theBuffer;

  dataPointerOut = 0;
  theBuffer = 0;
  cf = 0;
  length = 0;
  SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor = FigMemoryRecipientCopyBlockBufferFromXPCMessage(a1, a3, xdict, "SerializedMetadata-PooledBBuf", &theBuffer);
  if (!(_DWORD)SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor)
  {
    if (theBuffer)
    {
      CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
      length = CMBlockBufferGetDataLength(theBuffer);
    }
    else
    {
      dataPointerOut = (char *)xpc_dictionary_get_data(xdict, "SerializedMetadata-Inline", &length);
    }
    SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor = FigXPCMessageCopyDataBufferFromCMSampleBufferMessage(a1, xdict, a3, (CMBlockBufferRef *)&cf);
    if (!(_DWORD)SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor)
      SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor = FigRemote_CreateSampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor(a1, (uint64_t)dataPointerOut, length, (a4 & 1) == 0, (OpaqueCMBlockBuffer *)cf, a5, a6, a7);
  }
  v15 = SampleBufferFromSerializedAtomDataWithDataBufferAndLastCryptor;
  if (theBuffer)
    CFRelease(theBuffer);
  if (cf)
    CFRelease(cf);
  return v15;
}

uint64_t FigXPCMessageCopyCMSampleBuffer(const __CFAllocator *a1, void *a2, uint64_t a3, char a4, const opaqueCMFormatDescription **a5, CMSampleBufferRef *a6)
{
  return FigXPCMessageCopyCMSampleBufferWithLastCryptor(a1, a2, a3, a4, a5, 0, a6);
}

uint64_t FigMetricEventTimelineGetClassID()
{
  if (sRegisterFigMetricEventTimelineClassIDOnce != -1)
    dispatch_once_f(&sRegisterFigMetricEventTimelineClassIDOnce, 0, (dispatch_function_t)RegisterFigMetricEventTimelineType);
  return sFigMetricEventTimelineClassID;
}

uint64_t RegisterFigMetricEventTimelineType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigMetricEventTimelineClassDesc, ClassID, 1, &sFigMetricEventTimelineClassID);
}

uint64_t FigMetricEventTimelineGetTypeID()
{
  if (sRegisterFigMetricEventTimelineClassIDOnce != -1)
    dispatch_once_f(&sRegisterFigMetricEventTimelineClassIDOnce, 0, (dispatch_function_t)RegisterFigMetricEventTimelineType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigMetricEventTimelineClassID);
}

uint64_t FigMetricEventTimelineCreate(uint64_t a1, uint64_t a2, uint64_t *a3, const void *a4, const void *a5, CFTypeRef *a6)
{
  uint64_t v12;
  _QWORD *DerivedStorage;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  malloc_zone_t *MallocZoneForMedia;
  void *v20;
  CFTypeRef v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  malloc_zone_t *v26;
  void *v27;
  CFTypeRef v28;
  const __CFAllocator *AllocatorForMedia;
  CFMutableDictionaryRef Mutable;
  dispatch_queue_t v31;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v33;
  uint64_t v34;
  unsigned int v35;
  char *v36;
  uint64_t v37;
  os_log_type_t type;
  int v40;
  CFTypeRef cf;
  int v42;
  const char *v43;
  __int16 v44;
  CFTypeRef v45;
  char v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  cf = 0;
  if (a6)
  {
    if (sRegisterFigMetricEventTimelineClassIDOnce != -1)
      dispatch_once_f(&sRegisterFigMetricEventTimelineClassIDOnce, 0, (dispatch_function_t)RegisterFigMetricEventTimelineType);
    v12 = CMDerivedObjectCreate(a1, (uint64_t)&kigMetricEventTimeline_VTable, (_QWORD *)sFigMetricEventTimelineClassID, &cf);
    if (!(_DWORD)v12)
    {
      DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      if (a2 < 1)
      {
        v18 = 0;
      }
      else
      {
        v14 = 0;
        v15 = a3;
        v16 = a2;
        do
        {
          v17 = *v15++;
          v14 += v17;
          --v16;
        }
        while (v16);
        v18 = 8 * v14;
      }
      MallocZoneForMedia = (malloc_zone_t *)FigGetMallocZoneForMedia();
      v20 = malloc_type_zone_calloc(MallocZoneForMedia, 1uLL, v18, 0x10040436913F5uLL);
      DerivedStorage[5] = v20;
      if (v20)
      {
        v21 = a4 ? CFRetain(a4) : 0;
        DerivedStorage[8] = v21;
        if (a2 < 1)
        {
          v22 = 0;
        }
        else
        {
          v22 = 0;
          v23 = (_QWORD *)DerivedStorage[5];
          v24 = a2;
          do
          {
            *v23++ = v22;
            v25 = *a3++;
            v22 += v25;
            --v24;
          }
          while (v24);
        }
        v26 = (malloc_zone_t *)FigGetMallocZoneForMedia();
        v27 = malloc_type_zone_calloc(v26, 1uLL, 8 * v22, 0x80040B8603338uLL);
        DerivedStorage[6] = v27;
        if (v27)
        {
          DerivedStorage[2] = v22;
          DerivedStorage[3] = a2;
          v28 = a5 ? CFRetain(a5) : 0;
          DerivedStorage[4] = v28;
          AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
          Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          DerivedStorage[1] = Mutable;
          if (Mutable)
          {
            v31 = dispatch_queue_create("com.apple.coremedia.figmetriceventtimeline", 0);
            *DerivedStorage = v31;
            if (v31)
            {
              if (dword_1EE142048)
              {
                v40 = 0;
                type = OS_LOG_TYPE_DEFAULT;
                os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE142040, 1, &v40, &type);
                v33 = v40;
                if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
                  v35 = v33;
                else
                  v35 = v33 & 0xFFFFFFFE;
                if (v35)
                {
                  v42 = 136315394;
                  v43 = "FigMetricEventTimelineCreate";
                  v44 = 2048;
                  v45 = cf;
                  v36 = (char *)_os_log_send_and_compose_impl();
                  LOBYTE(v33) = v40;
                }
                else
                {
                  v36 = 0;
                }
                fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE142040, 1u, 1, v36, v36 != &v46, v33, 0, v34);
              }
              v37 = 0;
              *a6 = cf;
              return v37;
            }
          }
        }
      }
      v12 = FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
    }
    v37 = v12;
    if (cf)
      CFRelease(cf);
    return v37;
  }
  return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
}

CFStringRef met_copyFormattingDesc(uint64_t a1)
{
  const __CFAllocator *AllocatorForMedia;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  return CFStringCreateWithFormat(AllocatorForMedia, 0, CFSTR("[FigMetricEventTimeline %p]"), a1);
}

uint64_t met_invalidate(void *a1)
{
  dispatch_queue_t *DerivedStorage;

  DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  dispatch_sync_f(*DerivedStorage, a1, (dispatch_function_t)met_invalidateOnQueue);
  return 0;
}

void met_finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v3;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v3 = *(const void **)(DerivedStorage + 32);
  if (v3)
    CFRelease(v3);
  met_invalidateOnQueue(a1);
  if (*(_QWORD *)DerivedStorage)
    dispatch_release(*(dispatch_object_t *)DerivedStorage);
}

CFStringRef met_copyDebugDesc(uint64_t a1)
{
  const __CFAllocator *AllocatorForMedia;

  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  return CFStringCreateWithFormat(AllocatorForMedia, 0, CFSTR("[FigMetricEventTimeline %p]"), a1);
}

uint64_t met_setProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  dispatch_queue_t *DerivedStorage;
  uint64_t v6;
  _QWORD v8[3];
  uint64_t v9;

  DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage(a1);
  v6 = 4294954516;
  if (a2 && a3)
  {
    v8[0] = DerivedStorage;
    v8[1] = a2;
    v8[2] = a3;
    v9 = 0;
    dispatch_sync_f(*DerivedStorage, v8, (dispatch_function_t)met_setPropertyOnQueue);
    return v9;
  }
  return v6;
}

void met_invalidateOnQueue(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v3;
  const void *v4;
  uint64_t v5;
  uint64_t i;
  const void *v7;
  malloc_zone_t *MallocZoneForMedia;
  malloc_zone_t *v9;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!*(_BYTE *)(CMBaseObjectGetDerivedStorage(a1) + 56))
  {
    *(_BYTE *)(DerivedStorage + 56) = 1;
    v3 = *(const void **)(DerivedStorage + 8);
    if (v3)
      CFRelease(v3);
    v4 = *(const void **)(DerivedStorage + 64);
    if (v4)
      CFRelease(v4);
    v5 = *(_QWORD *)(DerivedStorage + 16);
    if (v5 >= 1)
    {
      for (i = 0; i < v5; ++i)
      {
        v7 = *(const void **)(*(_QWORD *)(DerivedStorage + 48) + 8 * i);
        if (v7)
        {
          CFRelease(v7);
          v5 = *(_QWORD *)(DerivedStorage + 16);
        }
      }
    }
    MallocZoneForMedia = (malloc_zone_t *)FigGetMallocZoneForMedia();
    malloc_zone_free(MallocZoneForMedia, *(void **)(DerivedStorage + 48));
    v9 = (malloc_zone_t *)FigGetMallocZoneForMedia();
    malloc_zone_free(v9, *(void **)(DerivedStorage + 40));
  }
}

void met_setPropertyOnQueue(uint64_t a1)
{
  const void *v2;
  const void *v3;

  *(_DWORD *)(a1 + 24) = 0;
  if (FigCFEqual(*(CFTypeRef *)(a1 + 8), CFSTR("MetricEventTimelineProperty_Timebase")))
  {
    v2 = *(const void **)(*(_QWORD *)a1 + 32);
    v3 = *(const void **)(a1 + 16);
    *(_QWORD *)(*(_QWORD *)a1 + 32) = v3;
    if (!v3)
      goto LABEL_4;
    goto LABEL_3;
  }
  if (!FigCFEqual(*(CFTypeRef *)(a1 + 8), CFSTR("MetricEventTimelineProperty_SessionID")))
  {
    *(_DWORD *)(a1 + 24) = -12787;
    return;
  }
  v2 = *(const void **)(*(_QWORD *)a1 + 64);
  v3 = *(const void **)(a1 + 16);
  *(_QWORD *)(*(_QWORD *)a1 + 64) = v3;
  if (v3)
LABEL_3:
    CFRetain(v3);
LABEL_4:
  if (v2)
    CFRelease(v2);
}

uint64_t met_registerSubscriber(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  dispatch_queue_t *DerivedStorage;
  _QWORD context[4];
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage(a1);
  v13 = 0;
  v12 = 0u;
  v11 = 0u;
  if (!a1 || !a2 || !a3 || !a4)
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  context[0] = a1;
  context[1] = a2;
  context[2] = a3;
  context[3] = a4;
  dispatch_sync_f(*DerivedStorage, context, (dispatch_function_t)met_registerSubscriberDispatch);
  return v13;
}

uint64_t met_subscribeByEventID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  dispatch_queue_t *DerivedStorage;
  _QWORD context[2];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage(a1);
  v12 = 0;
  v11 = 0u;
  v10 = 0u;
  v9 = 0u;
  if (!a1 || !a2)
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  context[0] = a1;
  context[1] = a2;
  *(_QWORD *)&v10 = a3;
  dispatch_sync_f(*DerivedStorage, context, (dispatch_function_t)met_subscribeByEventIDOnQueue);
  return v12;
}

uint64_t met_subscribeByClassID(uint64_t a1, uint64_t a2, char a3)
{
  dispatch_queue_t *DerivedStorage;
  _QWORD context[2];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage(a1);
  v12 = 0;
  v11 = 0u;
  v10 = 0u;
  v9 = 0u;
  if (!a1 || !a2)
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  context[0] = a1;
  context[1] = a2;
  BYTE8(v10) = a3;
  dispatch_sync_f(*DerivedStorage, context, (dispatch_function_t)met_subscribeByClassIDOnQueue);
  return v12;
}

uint64_t met_subscribetoAllEvents(uint64_t a1, uint64_t a2)
{
  dispatch_queue_t *DerivedStorage;
  _QWORD context[2];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  DerivedStorage = (dispatch_queue_t *)CMBaseObjectGetDerivedStorage(a1);
  v10 = 0;
  v9 = 0u;
  v8 = 0u;
  v7 = 0u;
  if (!a1 || !a2)
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  context[0] = a1;
  context[1] = a2;
  dispatch_sync_f(*DerivedStorage, context, (dispatch_function_t)met_subscribeToAllEventsOnQueue);
  return v10;
}

uint64_t met_publishEvent_0(const void *a1, const void *a2, const void *a3)
{
  uint64_t DerivedStorage;
  dispatch_queue_t *v7;
  uint64_t (*v8)(const void *);
  uint64_t v9;
  const void *v10;
  char v11;
  unsigned int (*v12)(const void *);
  uint64_t (*v13)(const void *);
  uint64_t v14;
  void (*v15)(const void *, uint64_t);
  void (*v16)(__int128 *__return_ptr, const void *);
  uint64_t (*v17)(const void *);
  uint64_t (*v18)(const void *);
  pthread_mutex_t **v19;
  void (*v20)(const void *, CMTime *);
  void (*v21)(const void *);
  malloc_zone_t *MallocZoneForMedia;
  _QWORD *v23;
  _QWORD *v24;
  CMTime v26;
  CMTime v27;
  __int128 v28;
  uint64_t v29;
  CMTime v30;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!a1 || !a2 || !a3)
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  v7 = (dispatch_queue_t *)DerivedStorage;
  v8 = *(uint64_t (**)(const void *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a3) + 16) + 40);
  if (v8 && (v9 = v8(a3)) != 0)
  {
    v10 = (const void *)v9;
    v11 = 0;
  }
  else
  {
    v12 = *(unsigned int (**)(const void *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a3) + 16) + 16);
    if (v12 && v12(a3))
    {
      v13 = *(uint64_t (**)(const void *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 16) + 48);
      v14 = v13 ? v13(a1) : 0;
      v15 = *(void (**)(const void *, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a3) + 16) + 48);
      if (v15)
        v15(a3, v14);
    }
    v10 = 0;
    v11 = 1;
  }
  v16 = *(void (**)(__int128 *__return_ptr, const void *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a3) + 16)
                                                                    + 56);
  if (v16)
  {
    v16(&v28, a3);
  }
  else
  {
    v28 = *(_OWORD *)&kCMTimeInvalid.value;
    v29 = 0;
  }
  if ((BYTE12(v28) & 1) == 0)
  {
    v17 = *(uint64_t (**)(const void *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 16) + 56);
    if (v17)
    {
      if (v17(a1))
      {
        memset(&v27, 0, sizeof(v27));
        v18 = *(uint64_t (**)(const void *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 16) + 56);
        v19 = v18 ? (pthread_mutex_t **)v18(a1) : 0;
        CMTimebaseGetTimeClampedAboveAnchorTime(v19, 0, &v27);
        v26 = v27;
        v20 = *(void (**)(const void *, CMTime *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a3) + 16) + 64);
        if (v20)
        {
          v30 = v26;
          v20(a3, &v30);
        }
      }
    }
  }
  v21 = *(void (**)(const void *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a3) + 16) + 8);
  if (v21)
    v21(a3);
  if ((v11 & 1) == 0)
    CFRelease(v10);
  MallocZoneForMedia = (malloc_zone_t *)FigGetMallocZoneForMedia();
  v23 = malloc_type_zone_calloc(MallocZoneForMedia, 1uLL, 0x48uLL, 0x10E0040608237F2uLL);
  if (!v23)
    return FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
  v24 = v23;
  *v23 = CFRetain(a1);
  v24[6] = CFRetain(a2);
  v24[7] = CFRetain(a3);
  dispatch_async_f(*v7, v24, (dispatch_function_t)met_publishEventDispatch);
  return 0;
}

uint64_t met_getSessionID(uint64_t a1)
{
  _QWORD v2[2];
  uint64_t v3;
  uint64_t v4;

  v3 = 0;
  v4 = 0;
  v2[0] = CMBaseObjectGetDerivedStorage(a1);
  v2[1] = 0;
  dispatch_sync_f(*(dispatch_queue_t *)v2[0], v2, (dispatch_function_t)met_getSessionIDOnQueue);
  return v3;
}

uint64_t met_getTimebase(uint64_t a1)
{
  _QWORD v2[2];
  uint64_t v3;
  uint64_t v4;

  v3 = 0;
  v4 = 0;
  v2[0] = CMBaseObjectGetDerivedStorage(a1);
  v2[1] = 0;
  dispatch_sync_f(*(dispatch_queue_t *)v2[0], v2, (dispatch_function_t)met_getTimebaseOnQueue);
  return v3;
}

uint64_t met_registerSubscriberDispatch(uint64_t a1)
{
  const void *v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t DerivedStorage;
  uint64_t Instance;
  _QWORD *v7;
  CFTypeRef v8;
  uint64_t result;
  __int128 v10;

  v2 = *(const void **)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  v4 = *(NSObject **)(a1 + 24);
  DerivedStorage = CMBaseObjectGetDerivedStorage(*(_QWORD *)a1);
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(DerivedStorage + 8), v2))
  {
    FigGetAllocatorForMedia();
    v10 = xmmword_1E28E6260;
    if (metSubscriberCallbackData_getTypeID_once != -1)
      dispatch_once_f(&metSubscriberCallbackData_getTypeID_once, &v10, (dispatch_function_t)metutil_registerClass_0);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v7 = (_QWORD *)Instance;
      if (v2)
        v8 = CFRetain(v2);
      else
        v8 = 0;
      v7[2] = v8;
      v7[3] = v3;
      v7[4] = v4;
      if (v4)
        dispatch_retain(v4);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(DerivedStorage + 8), v2, v7);
      CFRelease(v7);
    }
    else
    {
      result = FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
      if ((_DWORD)result)
        goto LABEL_12;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(DerivedStorage + 8), v2, 0);
    }
  }
  result = 0;
LABEL_12:
  *(_DWORD *)(a1 + 64) = result;
  return result;
}

void metSubscriberCallbackData_finalize(uint64_t a1)
{
  const void *v2;
  NSObject *v3;

  v2 = *(const void **)(a1 + 16);
  if (v2)
    CFRelease(v2);
  v3 = *(NSObject **)(a1 + 32);
  if (v3)
    dispatch_release(v3);
}

uint64_t metutil_registerClass_0(uint64_t a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  **(_QWORD **)(a1 + 8) = result;
  return result;
}

uint64_t met_subscribeByEventIDOnQueue(uint64_t a1)
{
  uint64_t result;

  result = met_addSubscriberForEventID(*(_QWORD *)a1, *(_QWORD *)(a1 + 32), *(const void **)(a1 + 8));
  *(_DWORD *)(a1 + 64) = result;
  return result;
}

uint64_t met_addSubscriberForEventID(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t DerivedStorage;
  const void *Value;
  uint64_t v7;
  const void *v8;
  __CFSet *v9;
  const __CFAllocator *AllocatorForMedia;
  uint64_t v12;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 8), a3);
  if (Value
    && (v7 = *(_QWORD *)(*(_QWORD *)(DerivedStorage + 40) + 8 * (a2 >> 56)) + (a2 & 0xFFFFFFFFFFFFFFLL),
        v7 < *(_QWORD *)(DerivedStorage + 16)))
  {
    v8 = Value;
    v9 = *(__CFSet **)(*(_QWORD *)(DerivedStorage + 48) + 8 * v7);
    if (v9
      || (AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia(),
          *(_QWORD *)(*(_QWORD *)(DerivedStorage + 48) + 8 * v7) = CFSetCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B3B0]), (v9 = *(__CFSet **)(*(_QWORD *)(DerivedStorage + 48) + 8 * v7)) != 0))
    {
      CFSetSetValue(v9, v8);
      return 0;
    }
    v12 = 4294947845;
  }
  else
  {
    v12 = 4294947844;
  }
  return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
}

uint64_t met_subscribeByClassIDOnQueue(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  uint64_t DerivedStorage;
  const void *Value;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  uint64_t v10;
  BOOL v11;
  const CFSetCallBacks *v12;
  __CFSet *v13;
  const __CFAllocator *AllocatorForMedia;
  uint64_t result;
  uint64_t v16;

  v2 = *(char *)(a1 + 40);
  v3 = *(const void **)(a1 + 8);
  DerivedStorage = CMBaseObjectGetDerivedStorage(*(_QWORD *)a1);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 8), v3);
  if (!Value
    || (v6 = *(_QWORD *)(DerivedStorage + 40),
        v7 = *(_QWORD *)(v6 + 8 * v2),
        v8 = *(_QWORD *)(DerivedStorage + 16),
        v7 >= v8)
    || (v9 = Value, v2 + 1 < *(_QWORD *)(DerivedStorage + 24))
    && (v10 = *(_QWORD *)(v6 + 8 * (v2 + 1)), v11 = v10 <= v8, v8 = v10, !v11))
  {
    v16 = 4294947844;
LABEL_14:
    result = FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  if (v7 < v8)
  {
    v12 = (const CFSetCallBacks *)MEMORY[0x1E0C9B3B0];
    while (1)
    {
      v13 = *(__CFSet **)(*(_QWORD *)(DerivedStorage + 48) + 8 * v7);
      if (!v13)
      {
        AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
        *(_QWORD *)(*(_QWORD *)(DerivedStorage + 48) + 8 * v7) = CFSetCreateMutable(AllocatorForMedia, 0, v12);
        v13 = *(__CFSet **)(*(_QWORD *)(DerivedStorage + 48) + 8 * v7);
        if (!v13)
          break;
      }
      CFSetSetValue(v13, v9);
      if (v8 == ++v7)
        goto LABEL_11;
    }
    v16 = 4294947845;
    goto LABEL_14;
  }
LABEL_11:
  result = 0;
LABEL_12:
  *(_DWORD *)(a1 + 64) = result;
  return result;
}

uint64_t met_subscribeToAllEventsOnQueue(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  uint64_t DerivedStorage;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;

  v2 = *(_QWORD *)a1;
  v3 = *(const void **)(a1 + 8);
  DerivedStorage = CMBaseObjectGetDerivedStorage(*(_QWORD *)a1);
  if (*(uint64_t *)(DerivedStorage + 16) < 1)
  {
LABEL_5:
    result = 0;
  }
  else
  {
    v5 = DerivedStorage;
    v6 = 0;
    while (1)
    {
      result = met_addSubscriberForEventID(v2, v6, v3);
      if ((_DWORD)result)
        break;
      if (*(_QWORD *)(v5 + 16) <= ++v6)
        goto LABEL_5;
    }
  }
  *(_DWORD *)(a1 + 64) = result;
  return result;
}

void met_publishEventDispatch(uint64_t a1)
{
  uint64_t v1;
  const void *v2;
  const void *v3;
  const void *v4;
  uint64_t (*v5)(const void *);
  uint64_t v6;
  _QWORD *DerivedStorage;
  uint64_t v8;
  uint64_t v9;
  const __CFSet *v10;
  CFIndex Count;
  malloc_zone_t *MallocZoneForMedia;
  const void **v13;
  const void **v14;
  uint64_t v15;
  _QWORD *v16;
  const void *v17;
  CFTypeRef v18;
  uint64_t v19;
  NSObject *v20;
  BOOL v21;
  malloc_zone_t *v22;
  _QWORD *v23;
  _QWORD *v24;
  CFTypeRef v25;
  CFTypeRef v26;
  CFTypeRef v27;
  malloc_zone_t *v28;
  const void *v29;
  const void *v30;
  malloc_zone_t *v31;
  uint64_t v32;
  uint64_t v33;

  v1 = a1;
  v2 = *(const void **)a1;
  v3 = *(const void **)(a1 + 48);
  v4 = *(const void **)(a1 + 56);
  v5 = *(uint64_t (**)(const void *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v4) + 16) + 24);
  if (v5)
    v6 = v5(v4);
  else
    v6 = -12782;
  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)v2);
  v8 = *(_QWORD *)(DerivedStorage[5] + 8 * (v6 >> 56)) + (v6 & 0xFFFFFFFFFFFFFFLL);
  if (v8 >= DerivedStorage[2])
  {
    v32 = 4294947845;
LABEL_46:
    FigSignalErrorAt(v32, 0, 0, 0, 0, 0, 0);
    goto LABEL_47;
  }
  v9 = DerivedStorage[6];
  v10 = *(const __CFSet **)(v9 + 8 * v8);
  if (v10)
  {
    Count = CFSetGetCount(*(CFSetRef *)(v9 + 8 * v8));
    MallocZoneForMedia = (malloc_zone_t *)FigGetMallocZoneForMedia();
    v13 = (const void **)malloc_type_zone_calloc(MallocZoneForMedia, 1uLL, 8 * Count, 0xC0040B8AA526DuLL);
    if (v13)
    {
      v14 = v13;
      CFSetGetValues(v10, v13);
      if (Count < 1)
        goto LABEL_37;
      v33 = v1;
      v15 = 0;
      while (1)
      {
        v16 = v14[v15];
        v17 = (const void *)v16[2];
        if (v17)
          v18 = CFRetain(v17);
        else
          v18 = 0;
        v19 = v16[3];
        v20 = v16[4];
        if (v20)
          dispatch_retain(v20);
        if (v18)
        {
          if (v20)
            v21 = *(_QWORD *)(v19 + 8) == 0;
          else
            v21 = 1;
          if (v21
            || (v22 = (malloc_zone_t *)FigGetMallocZoneForMedia(),
                (v23 = malloc_type_zone_calloc(v22, 1uLL, 0x28uLL, 0xE0040BA15B581uLL)) == 0))
          {
            FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
          }
          else
          {
            v24 = v23;
            v23[1] = CFRetain(v18);
            v24[4] = v19;
            if (v2)
              v25 = CFRetain(v2);
            else
              v25 = 0;
            *v24 = v25;
            if (v3)
              v26 = CFRetain(v3);
            else
              v26 = 0;
            v24[2] = v26;
            if (v4)
              v27 = CFRetain(v4);
            else
              v27 = 0;
            v24[3] = v27;
            dispatch_async_f(v20, v24, (dispatch_function_t)met_issueSubscriberCallbackOnCallbackQueue);
          }
          CFRelease(v18);
          if (!v20)
            goto LABEL_32;
        }
        else
        {
          FigSignalErrorAt(4294947845, 0, 0, 0, 0, 0, 0);
          if (!v20)
            goto LABEL_32;
        }
        dispatch_release(v20);
LABEL_32:
        if (Count == ++v15)
        {
          v1 = v33;
          goto LABEL_37;
        }
      }
    }
    v32 = 4294954305;
    goto LABEL_46;
  }
LABEL_47:
  v14 = 0;
LABEL_37:
  v28 = (malloc_zone_t *)FigGetMallocZoneForMedia();
  malloc_zone_free(v28, v14);
  if (*(_QWORD *)v1)
    CFRelease(*(CFTypeRef *)v1);
  v29 = *(const void **)(v1 + 48);
  if (v29)
    CFRelease(v29);
  v30 = *(const void **)(v1 + 56);
  if (v30)
    CFRelease(v30);
  v31 = (malloc_zone_t *)FigGetMallocZoneForMedia();
  malloc_zone_free(v31, (void *)v1);
}

void met_issueSubscriberCallbackOnCallbackQueue(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  malloc_zone_t *MallocZoneForMedia;

  (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(a1[4] + 8))(a1[1], *a1, a1[2], a1[3]);
  v2 = (const void *)a1[1];
  if (v2)
    CFRelease(v2);
  if (*a1)
    CFRelease((CFTypeRef)*a1);
  v3 = (const void *)a1[2];
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[3];
  if (v4)
    CFRelease(v4);
  MallocZoneForMedia = (malloc_zone_t *)FigGetMallocZoneForMedia();
  malloc_zone_free(MallocZoneForMedia, a1);
}

_QWORD *met_getSessionIDOnQueue(_QWORD *result)
{
  result[2] = *(_QWORD *)(*result + 64);
  return result;
}

_QWORD *met_getTimebaseOnQueue(_QWORD *result)
{
  result[2] = *(_QWORD *)(*result + 32);
  return result;
}

uint64_t FigEndpointCopyActiveEndpointOfType(const void *a1, _QWORD *a2)
{
  uint64_t SharedXPCClient;
  uint64_t v5;
  xpc_object_t v6;
  uint64_t v8;
  xpc_object_t v9;
  int v10[2];
  uint64_t v11;

  *(_QWORD *)v10 = 0;
  v11 = 0;
  v8 = 0;
  v9 = 0;
  if (remoteXPCFigEndpoint_initializeLogging_initLoggingOnce == -1)
  {
    if (!a1)
    {
LABEL_13:
      SharedXPCClient = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
LABEL_14:
      v5 = SharedXPCClient;
      v6 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    dispatch_once(&remoteXPCFigEndpoint_initializeLogging_initLoggingOnce, &__block_literal_global_56);
    if (!a1)
      goto LABEL_13;
  }
  if (!a2)
    goto LABEL_13;
  *a2 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(0, &v8);
  if ((_DWORD)SharedXPCClient)
    goto LABEL_14;
  if (ensureActiveEndpointNotificationsRegistered_initNotifyOnce != -1)
    dispatch_once(&ensureActiveEndpointNotificationsRegistered_initNotifyOnce, &__block_literal_global_13_0);
  SharedXPCClient = FigXPCCreateBasicMessage(0x61637476u, 0, v10);
  if ((_DWORD)SharedXPCClient)
    goto LABEL_14;
  SharedXPCClient = FigXPCMessageSetCFString(*(void **)v10, "EndpointType", a1);
  if ((_DWORD)SharedXPCClient)
    goto LABEL_14;
  v5 = FigXPCRemoteClientSendSyncMessageCreatingReply(v8, *(uint64_t *)v10, &v9);
  v6 = v9;
  if (!(_DWORD)v5)
  {
    v5 = (uint64_t)FigEndpointXPCRemoteRetainCopiedEndpointFromReply(v9, &v11, a2);
    v6 = v9;
  }
LABEL_11:
  FigXPCRelease(v6);
  FigXPCRelease(*(xpc_object_t *)v10);
  return v5;
}

uint64_t remoteXPCFigEndpoint_getSharedXPCClient(unint64_t a1, _QWORD *a2)
{
  char *v4;
  int *v5;
  __CFDictionary *Mutable;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v8;
  uint64_t v9;
  unsigned int v10;
  const char *v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  NSObject *v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  const char *v20;
  int v21;
  _BYTE *v22;
  os_log_type_t type;
  int v25;
  int v26;
  const char *v27;
  __int16 v28;
  unint64_t v29;
  __int16 v30;
  const char *v31;
  _BYTE v32[128];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (a1 > 1)
    return 4294950576;
  os_unfair_lock_lock((os_unfair_lock_t)&remoteXPCFigEndpoint_getSharedXPCClient_lock);
  v4 = (char *)&remoteXPCFigEndpoint_getSharedXPCClient_sSourceInfo[2 * a1];
  v5 = (int *)(v4 + 8);
  if (*((_DWORD *)v4 + 2) || (v13 = *(_QWORD *)v4) == 0)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(Mutable, CFSTR("xpcRemoteClientOption_DeathNoticeName"), CFSTR("Endpoint_ServerConnectionDied"));
    CFDictionarySetValue(Mutable, CFSTR("xpcRemoteClientOption_PrivilegedConnection"), (const void *)*MEMORY[0x1E0C9AE50]);
    v25 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v25, &type);
    v8 = v25;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v10 = v8;
    else
      v10 = v8 & 0xFFFFFFFE;
    if (v10)
    {
      v11 = FigEndpointXPCServerNameForSource(a1);
      v26 = 136315650;
      v27 = "remoteXPCFigEndpoint_getSharedXPCClient";
      v28 = 2048;
      v29 = a1;
      v30 = 2080;
      v31 = v11;
      v12 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v8) = v25;
    }
    else
    {
      v12 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v12, v12 != v32, v8, 0, v9);
    v15 = FigEndpointXPCServerNameForSource(a1);
    *v5 = FigXPCRemoteClientCreate((uint64_t)v15, (uint64_t)&remoteXPCFigEndpoint_getSharedXPCClient_clientCallbacks, Mutable, &remoteXPCFigEndpoint_getSharedXPCClient_sSourceInfo[2 * a1]);
    v25 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    v16 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v25, &type);
    v17 = v25;
    if (os_log_type_enabled(v16, type))
      v19 = v17;
    else
      v19 = v17 & 0xFFFFFFFE;
    if (v19)
    {
      v20 = FigEndpointXPCServerNameForSource(a1);
      v21 = *v5;
      v26 = 136315650;
      v27 = "remoteXPCFigEndpoint_getSharedXPCClient";
      v28 = 2080;
      v29 = (unint64_t)v20;
      v30 = 1024;
      LODWORD(v31) = v21;
      v22 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v17) = v25;
    }
    else
    {
      v22 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v22, v22 != v32, v17, 0, v18);
    if (Mutable)
      CFRelease(Mutable);
    v13 = *(_QWORD *)v4;
    v14 = *v5;
    if (!v13)
    {
      FigSignalErrorAt(*v5, 0, 0, 0, 0, 0, 0);
      goto LABEL_22;
    }
  }
  else
  {
    v14 = 0;
  }
  *a2 = v13;
LABEL_22:
  os_unfair_lock_unlock((os_unfair_lock_t)&remoteXPCFigEndpoint_getSharedXPCClient_lock);
  return v14;
}

void *FigEndpointXPCRemoteRetainCopiedEndpointFromReply(void *result, _QWORD *a2, _QWORD *a3)
{
  void *v5;
  const void *uint64;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (result)
  {
    if (!a3)
      return (void *)FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v5 = result;
    uint64 = (const void *)xpc_dictionary_get_uint64(result, "EndpointObjectID");
    if (!uint64)
    {
      *a3 = 0;
      if (!a2)
        return 0;
      goto LABEL_11;
    }
    v7 = xpc_dictionary_get_uint64(v5, "EndpointXPCSource");
    if (FigEndpointXPCSourceNeedsSubEndpoint(v7))
    {
      v8 = xpc_dictionary_get_uint64(v5, "SubEndpointObjectID");
      v9 = xpc_dictionary_get_uint64(v5, "SubEndpointXPCSource");
    }
    else
    {
      v8 = 0;
      v9 = 0;
    }
    result = (void *)remoteXPCEndpoint_retainCopiedEndpointForSource(uint64, v7, v8, v9, a3);
    if (a2 && !(_DWORD)result)
    {
LABEL_11:
      result = 0;
      *a2 = uint64;
    }
  }
  return result;
}

uint64_t FigEndpointCopyActiveCarPlayEndpoint(_QWORD *a1)
{
  return FigEndpointCopyActiveEndpointOfType(CFSTR("EndpointType_Car"), a1);
}

uint64_t FigEndpointIsCarPlayActive(BOOL *a1)
{
  uint64_t SharedXPCClient;
  uint64_t v3;
  xpc_object_t v4;
  uint64_t v6;
  xpc_object_t xdict;
  xpc_object_t v8;

  xdict = 0;
  v8 = 0;
  v6 = 0;
  if (remoteXPCFigEndpoint_initializeLogging_initLoggingOnce != -1)
  {
    dispatch_once(&remoteXPCFigEndpoint_initializeLogging_initLoggingOnce, &__block_literal_global_56);
    if (a1)
      goto LABEL_3;
LABEL_11:
    SharedXPCClient = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
LABEL_12:
    v3 = SharedXPCClient;
    v4 = 0;
    goto LABEL_9;
  }
  if (!a1)
    goto LABEL_11;
LABEL_3:
  *a1 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(0, &v6);
  if ((_DWORD)SharedXPCClient)
    goto LABEL_12;
  if (ensureActiveEndpointNotificationsRegistered_initNotifyOnce != -1)
    dispatch_once(&ensureActiveEndpointNotificationsRegistered_initNotifyOnce, &__block_literal_global_13_0);
  SharedXPCClient = FigXPCCreateBasicMessage(0x61766C62u, 0, &v8);
  if ((_DWORD)SharedXPCClient)
    goto LABEL_12;
  v3 = FigXPCRemoteClientSendSyncMessageCreatingReply(v6, (uint64_t)v8, &xdict);
  v4 = xdict;
  if (!(_DWORD)v3)
  {
    *a1 = xpc_dictionary_get_BOOL(xdict, ".Value");
    v4 = xdict;
  }
LABEL_9:
  FigXPCRelease(v4);
  FigXPCRelease(v8);
  return v3;
}

uint64_t FigEndpointXPCRemoteEnableActiveCarPlayEndpoint()
{
  return 4294950570;
}

uint64_t FigEndpointXPCRemoteGetObjectID(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
  if (!a2)
  {
    v7 = 0;
    v6 = 4294950576;
    goto LABEL_9;
  }
  if (a1 && (_UNKNOWN *)CMBaseObjectGetVTable(a1) == &kFigEndpointRemoteXPC_EndpointAggregateVTable)
  {
    if (*(_BYTE *)(DerivedStorage + 40))
    {
      v5 = 4294950573;
    }
    else
    {
      if (!*(_BYTE *)(DerivedStorage + 41))
      {
        v6 = 0;
        v7 = *(_QWORD *)DerivedStorage;
        goto LABEL_9;
      }
      v5 = 4294950574;
    }
  }
  else
  {
    v5 = 4294954516;
  }
  v6 = FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
  v7 = 0;
LABEL_9:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
  *a2 = v7;
  return v6;
}

BOOL FigEndpointIsXPCRemote(uint64_t a1)
{
  return a1 && (_UNKNOWN *)CMBaseObjectGetVTable(a1) == &kFigEndpointRemoteXPC_EndpointAggregateVTable;
}

uint64_t FigEndpointXPCRemotePing()
{
  unint64_t v0;
  uint64_t SharedXPCClient;
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v6;
  void *v7;

  v6 = 0;
  v7 = 0;
  if (remoteXPCFigEndpoint_initializeLogging_initLoggingOnce != -1)
    dispatch_once(&remoteXPCFigEndpoint_initializeLogging_initLoggingOnce, &__block_literal_global_56);
  v0 = FigIsAirplaydEnabled() != 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(v0, &v6);
  if ((_DWORD)SharedXPCClient)
  {
    v4 = SharedXPCClient;
    v3 = 0;
  }
  else
  {
    v2 = FigXPCCreateBasicMessage(0x2E706E67u, 0, &v7);
    v3 = v7;
    if ((_DWORD)v2)
    {
      v4 = v2;
    }
    else
    {
      v4 = FigXPCRemoteClientSendSyncMessage(v6, (uint64_t)v7);
      v3 = v7;
    }
  }
  FigXPCRelease(v3);
  return v4;
}

uint64_t FigEndpointXPCRemoteRetainCopiedEndpoint(const void *a1, _QWORD *a2)
{
  if (remoteXPCFigEndpoint_initializeLogging_initLoggingOnce != -1)
    dispatch_once(&remoteXPCFigEndpoint_initializeLogging_initLoggingOnce, &__block_literal_global_56);
  return remoteXPCEndpoint_retainCopiedEndpointForSource(a1, 0, 0, 0, a2);
}

uint64_t remoteXPCEndpoint_retainCopiedEndpointForSource(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  unint64_t Base;
  uint64_t SharedXPCClient;
  uint64_t v12;
  const void *version;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  const void *v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int v21;
  const __CFAllocator *v22;
  _QWORD *v23;
  uint64_t DerivedStorage;
  pthread_mutex_t *v25;
  CFMutableDictionaryRef v26;
  dispatch_queue_t v27;
  CFMutableDictionaryRef Mutable;
  CFMutableArrayRef v29;
  uint64_t v31;
  CFIndex v32;
  CFDictionaryValueCallBacks cf;
  CFTypeRef v34;
  CFTypeRef v35;

  v31 = 0;
  v32 = 0;
  if (remoteXPCFigEndpoint_initializeLogging_initLoggingOnce == -1)
  {
    if (!a1)
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    dispatch_once(&remoteXPCFigEndpoint_initializeLogging_initLoggingOnce, &__block_literal_global_56);
    if (!a1)
      return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  if (a5)
  {
    if ((a2 & 0x1000) == 0)
    {
      Base = FigEndpointXPCSourceGetBase(a2);
      SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(Base, &v31);
      if ((_DWORD)SharedXPCClient)
        return SharedXPCClient;
      v12 = FigXPCRemoteClientRetainCopiedObject(v31, (uint64_t)a1, &v32);
      version = (const void *)v32;
      if (!(_DWORD)v12)
      {
        if (v32)
        {
          v14 = 0;
LABEL_44:
          *a5 = version;
          return v14;
        }
        v34 = 0;
        v35 = 0;
        memset(&cf, 0, sizeof(cf));
        v19 = FigEndpointXPCSourceGetBase(a2);
        v20 = remoteXPCFigEndpoint_getSharedXPCClient(v19, &v34);
        if (!(_DWORD)v20)
        {
          v21 = (a2 >> 13) & 1;
          v22 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v23 = (_QWORD *)(v21 ? FigEndpointAggregateGetClassID() : FigEndpointExtendedGetClassID());
          v20 = CMDerivedObjectCreate((uint64_t)v22, (uint64_t)&kFigEndpointRemoteXPC_EndpointAggregateVTable, v23, &v35);
          if (!(_DWORD)v20)
          {
            DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)v35);
            *(_QWORD *)DerivedStorage = a1;
            *(_QWORD *)(DerivedStorage + 96) = 1;
            *(_QWORD *)(DerivedStorage + 8) = FigEndpointXPCSourceGetBase(a2);
            *(_BYTE *)(DerivedStorage + 16) = (a2 & 0x2000) != 0;
            if (!v21 || (v20 = FigEndpointRPCCacheCreate((_QWORD *)(DerivedStorage + 48), 1), !(_DWORD)v20))
            {
              cf.version = 0;
              cf.retain = (CFDictionaryRetainCallBack)remoteXPCEndpoint_cloneCompletionCallback;
              cf.copyDescription = 0;
              cf.equal = 0;
              cf.release = (CFDictionaryReleaseCallBack)remoteXPCEndpoint_freeCompletionCallback;
              v25 = FigSimpleMutexCreate();
              *(_QWORD *)(DerivedStorage + 32) = v25;
              if (!v25)
              {
                v14 = 4294950575;
LABEL_51:
                if (v35)
                  CFRelease(v35);
                goto LABEL_43;
              }
              v26 = CFDictionaryCreateMutable(v22, 0, 0, &cf);
              *(_QWORD *)(DerivedStorage + 88) = v26;
              if (v26)
              {
                v27 = dispatch_queue_create("com.apple.coremedia.remoteendpoint.notification", 0);
                *(_QWORD *)(DerivedStorage + 24) = v27;
                if (v27)
                {
                  Mutable = CFDictionaryCreateMutable(v22, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                  *(_QWORD *)(DerivedStorage + 56) = Mutable;
                  if (Mutable)
                  {
                    v29 = CFArrayCreateMutable(v22, 0, MEMORY[0x1E0C9B378]);
                    *(_QWORD *)(DerivedStorage + 80) = v29;
                    if (v29)
                    {
                      FigXPCRemoteClientAssociateObject((uint64_t)v34, (uint64_t)v35, a1);
                      v14 = 0;
                      v32 = (CFIndex)v35;
LABEL_43:
                      version = (const void *)v32;
                      goto LABEL_44;
                    }
                  }
                }
              }
              v20 = FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
            }
          }
        }
        v14 = v20;
        goto LABEL_51;
      }
      v14 = v12;
LABEL_55:
      if (version)
        CFRelease(version);
      return v14;
    }
    cf.version = 0;
    v34 = 0;
    v35 = 0;
    if (remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_initDemuxMutexOnce != -1)
      dispatch_once(&remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_initDemuxMutexOnce, &__block_literal_global_20_0);
    FigSimpleMutexLock((pthread_mutex_t *)remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxMutex);
    v15 = FigEndpointXPCSourceGetBase(a2);
    v16 = remoteXPCEndpoint_retainCopiedEndpointForSource(a1, v15, 0, 0, &v35);
    if (!(_DWORD)v16)
    {
      v17 = FigEndpointXPCSourceGetBase(a4);
      v16 = remoteXPCEndpoint_retainCopiedEndpointForSource(a3, v17, 0, 0, &v34);
      if (!(_DWORD)v16)
      {
        if (FigEndpointIsXPCDemux(remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxEndpoint)
          && FigEndpointXPCDemuxEndpointsMatch(remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxEndpoint, (uint64_t)v35, (uint64_t)v34))
        {
          cf.version = (CFIndex)CFRetain((CFTypeRef)remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxEndpoint);
LABEL_21:
          v14 = 0;
          version = (const void *)cf.version;
          v32 = cf.version;
          cf.version = 0;
          goto LABEL_22;
        }
        v16 = FigEndpointXPCDemuxCreate(v35, v34, (CFTypeRef *)&cf);
        if (!(_DWORD)v16)
        {
          v18 = (const void *)remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxEndpoint;
          remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxEndpoint = cf.version;
          if (cf.version)
            CFRetain((CFTypeRef)cf.version);
          if (v18)
            CFRelease(v18);
          goto LABEL_21;
        }
      }
    }
    v14 = v16;
    version = 0;
LABEL_22:
    FigSimpleMutexUnlock((pthread_mutex_t *)remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxMutex);
    if (cf.version)
      CFRelease((CFTypeRef)cf.version);
    if (v35)
      CFRelease(v35);
    if (v34)
      CFRelease(v34);
    if (!(_DWORD)v14)
      goto LABEL_44;
    goto LABEL_55;
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointXPCRemoteObtainObjectIDForOtherProcess(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t DerivedStorage;
  uint64_t v7;
  uint64_t SharedXPCClient;
  uint64_t v9;
  uint64_t v11;
  xpc_object_t v12;
  xpc_object_t xdict;
  uint64_t v14;

  xdict = 0;
  v14 = 0;
  v12 = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v11 = 0;
  if (!a1 || !a2 || !a3)
  {
    SharedXPCClient = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
LABEL_13:
    v9 = SharedXPCClient;
    goto LABEL_11;
  }
  v7 = DerivedStorage;
  if (remoteXPCFigEndpoint_initializeLogging_initLoggingOnce != -1)
    dispatch_once(&remoteXPCFigEndpoint_initializeLogging_initLoggingOnce, &__block_literal_global_56);
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(v7 + 8), &v11);
  if ((_DWORD)SharedXPCClient)
    goto LABEL_13;
  SharedXPCClient = FigEndpointXPCRemoteGetObjectID(a1, &v14);
  if ((_DWORD)SharedXPCClient)
    goto LABEL_13;
  SharedXPCClient = FigXPCCreateBasicMessage(0x63656670u, v14, &xdict);
  if ((_DWORD)SharedXPCClient)
    goto LABEL_13;
  xpc_dictionary_set_int64(xdict, "OtherProcessPID", a2);
  v9 = FigXPCRemoteClientSendSyncMessageCreatingReply(v11, (uint64_t)xdict, &v12);
  if (!(_DWORD)v9)
    *a3 = xpc_dictionary_get_uint64(v12, ".objectID");
LABEL_11:
  FigXPCRelease(xdict);
  FigXPCRelease(v12);
  return v9;
}

uint64_t FigEndpointXPCRemoteGetSource(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  *a2 = *(_QWORD *)(DerivedStorage + 8);
  return 0;
}

void *FigEndpointXPCRemoteRetainCopiedEndpointFromArray(void *a1, size_t a2, _QWORD *a3, _QWORD *a4)
{
  xpc_object_t value;

  if (!a4)
    return (void *)FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  value = xpc_array_get_value(a1, a2);
  return FigEndpointXPCRemoteRetainCopiedEndpointFromReply(value, a3, a4);
}

uint64_t FigEndpointXPCRemoteRetainCopiedEndpointsFromArrayToCFArray(void *a1, __CFArray **a2)
{
  xpc_object_t Count;
  __CFArray *Mutable;
  size_t v6;
  xpc_object_t v7;
  void *v8;
  void *v9;
  void *value;

  if (!a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (a1)
  {
    Count = FigXPCArrayGetCount(a1);
    Mutable = CFArrayCreateMutable(0, (CFIndex)Count, MEMORY[0x1E0C9B378]);
    if (Count)
    {
      v6 = 0;
      while (1)
      {
        value = 0;
        v7 = xpc_array_get_value(a1, v6);
        v8 = FigEndpointXPCRemoteRetainCopiedEndpointFromReply(v7, 0, &value);
        if ((_DWORD)v8)
          break;
        CFArrayAppendValue(Mutable, value);
        if (value)
          CFRelease(value);
        if (Count == (xpc_object_t)++v6)
          goto LABEL_9;
      }
      v9 = v8;
      if (Mutable)
        CFRelease(Mutable);
    }
    else
    {
LABEL_9:
      v9 = 0;
      *a2 = Mutable;
    }
  }
  else
  {
    v9 = 0;
    *a2 = 0;
  }
  return (uint64_t)v9;
}

void remoteXPCEndpointClient_DeadConnectionCallback(const void *a1)
{
  uint64_t DerivedStorage;
  const __CFAllocator *v3;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v5;
  id *v6;
  id *v7;
  CFMutableDictionaryRef v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFDictionaryRef Copy;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  CFNotificationCenterRef DefaultLocalCenter;
  _QWORD block[6];
  int v18;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return;
  v5 = Mutable;
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
  *(_WORD *)(DerivedStorage + 40) = 257;
  FigCFDictionarySetInt64(v5, CFSTR("ActivationSeed"), *(_QWORD *)(DerivedStorage + 64));
  FigCFDictionarySetInt64(v5, CFSTR("Features"), *(_QWORD *)(DerivedStorage + 72));
  if (!*(_QWORD *)(DerivedStorage + 72))
  {
    v8 = 0;
    v7 = 0;
    goto LABEL_7;
  }
  v6 = *(id **)(DerivedStorage + 184);
  if (!v6)
  {
    v7 = 0;
    goto LABEL_9;
  }
  v7 = FigCFWeakReferenceHolderCopyReferencedObject(v6);
  if (v7)
  {
LABEL_9:
    v9 = *(_QWORD *)(DerivedStorage + 160);
    v10 = *(_QWORD *)(DerivedStorage + 64);
    v8 = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    FigCFDictionarySetInt64(v8, CFSTR("Status"), -16722);
    FigCFDictionarySetValue(v8, CFSTR("FailureType"), CFSTR("FailureType_Disconnected"));
    goto LABEL_10;
  }
  v8 = 0;
LABEL_7:
  v9 = 0;
  v10 = 0;
LABEL_10:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
  v11 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)(v11 + 32));
  Copy = CFDictionaryCreateCopy(v3, *(CFDictionaryRef *)(v11 + 88));
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(v11 + 88));
  v13 = *(_QWORD *)(v11 + 64);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v11 + 32));
  v14 = *(NSObject **)(v11 + 24);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigEndpointRemoteXPC_runAllCallbacks_block_invoke;
  block[3] = &__block_descriptor_tmp_6_11;
  block[4] = Copy;
  block[5] = v13;
  v18 = -16722;
  dispatch_async(v14, block);
  if (v9)
    remoteXPCEndpointClient_callDelegateHandleFailed(a1, 0, v10, 0, v9, (uint64_t)v7, v8);
  v15 = *(NSObject **)(DerivedStorage + 24);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  FigDispatchAsyncPostNotification(v15, DefaultLocalCenter, CFSTR("Endpoint_Dissociated"), a1, v5, 0);
  if (v8)
    CFRelease(v8);
  CFRelease(v5);
  if (v7)
    CFRelease(v7);
}

uint64_t remoteXPCEndpointClient_NotificationFilter(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary *a4)
{
  uint64_t DerivedStorage;
  const void *Value;
  const void **v8;
  const __CFString *v9;
  uint64_t v10;
  __CFString **v11;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, CFSTR("Endpoint_ConnectedStateChanged")))
  {
    if (a4)
      Value = CFDictionaryGetValue(a4, CFSTR("ConnectedState"));
    else
      Value = 0;
    v9 = CFSTR("IsConnected");
    v10 = DerivedStorage;
    goto LABEL_12;
  }
  if (CFEqual(a2, CFSTR("Endpoint_EndpointActivated")))
  {
    v8 = (const void **)MEMORY[0x1E0C9AE50];
  }
  else
  {
    if (!CFEqual(a2, CFSTR("Endpoint_EndpointDeactivated")))
    {
      if (CFEqual(a2, CFSTR("Endpoint_StreamsChanged")))
      {
        remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("Streams"), 0);
        remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("AirPlayVodkaVersion"), 0);
        remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("AirPlayFromCloud"), 0);
        v11 = kFigEndpointProperty_SupportedFeatures;
      }
      else if (CFEqual(a2, CFSTR("Endpoint_EndpointDescriptionChanged")))
      {
        remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("AirPlayVodkaVersion"), 0);
        remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("AirPlayFromCloud"), 0);
        remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("AuthorizationType"), 0);
        remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("ID"), 0);
        remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("MACAddress"), 0);
        remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("Model"), 0);
        remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("Name"), 0);
        remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("SubType"), 0);
        remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("SupportedFeatures"), 0);
        remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("SystemFlags"), 0);
        v11 = kFigEndpointProperty_TransportType;
      }
      else
      {
        if (CFEqual(a2, CFSTR("EndpointAdded")) || CFEqual(a2, CFSTR("EndpointRemoved")))
        {
          remoteXPCFigEndpoint_clearAggregateSubEndpointsDependentCache(DerivedStorage);
          return 0;
        }
        if (CFEqual(a2, CFSTR("Endpoint_VolumeControlTypeDidChange")))
        {
          v11 = kFigEndpointProperty_VolumeControlType;
        }
        else if (CFEqual(a2, CFSTR("Endpoint_VolumeControlSupportedDidChange")))
        {
          v11 = kFigEndpointProperty_VolumeControlSupported;
        }
        else
        {
          if (!CFEqual(a2, CFSTR("Endpoint_VolumeDidChange")))
            return 0;
          remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("Volume"), 0);
          v11 = kFigEndpointProperty_VolumeDB;
        }
      }
      goto LABEL_11;
    }
    v8 = (const void **)MEMORY[0x1E0C9AE40];
  }
  remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("IsActivated"), *v8);
  remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("IsPerAppDisplay"), 0);
  remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("PrimaryUsage"), 0);
  remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("Streams"), 0);
  v11 = kFigEndpointProperty_Volume;
LABEL_11:
  v9 = *v11;
  v10 = DerivedStorage;
  Value = 0;
LABEL_12:
  remoteXPCFigEndpoint_setCachedProperty(v10, v9, Value);
  return 0;
}

uint64_t remoteXPCEndpointClient_HandleClientMessage(const void *a1, void *a2)
{
  uint64_t OpCode;
  uint64_t DerivedStorage;
  const void *uint64;
  int int64;
  uint64_t v8;
  uint64_t v9;
  _OWORD *Value;
  _OWORD *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  id *v17;
  id *v18;
  uint64_t v19;
  uint64_t v20;
  id *v21;
  id *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  __int128 v26;
  const __CFDictionary *v27;
  const void *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v35;
  int v36;
  uint64_t block;
  uint64_t v38;
  void (*v39)(uint64_t);
  void *v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  _BYTE v44[24];
  __int128 v45;
  uint64_t v46;
  int v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  const __CFDictionary *v55;
  const void *v56[3];

  v36 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v36);
  if ((_DWORD)OpCode)
    return OpCode;
  if (v36 != 1920230499)
  {
    if (v36 != 1919116387)
    {
      if (v36 != 1667329122)
        return 4294966630;
      DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
      v52 = 0;
      v50 = 0u;
      v51 = 0u;
      v48 = 0u;
      v49 = 0u;
      *(_QWORD *)&v53 = 0;
      uint64 = (const void *)xpc_dictionary_get_uint64(a2, "CompletionID");
      int64 = xpc_dictionary_get_int64(a2, "CompletionStatus");
      v8 = xpc_dictionary_get_uint64(a2, "ActivationSeed");
      v9 = xpc_dictionary_get_uint64(a2, "ActivationFeatures");
      FigXPCMessageCopyCFDictionary(a2, "SendCommandResponse", &v53);
      FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 88), uint64);
      if (Value)
      {
        v11 = Value;
        v49 = Value[1];
        v50 = Value[2];
        v51 = Value[3];
        v52 = *((_QWORD *)Value + 8);
        v48 = *Value;
        remoteXPCEndpointClient_retainCompletionCallbackEntryFields((uint64_t)&v48);
        if (*((_QWORD *)v11 + 1) && *((_BYTE *)v11 + 40) && !int64)
        {
          *(_QWORD *)(DerivedStorage + 64) = v8;
          *(_QWORD *)(DerivedStorage + 72) = v9;
        }
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(DerivedStorage + 88), uint64);
        v12 = v48;
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
        if (v12)
        {
          if ((_QWORD)v50)
            remoteXPCFigEndpoint_clearAggregateSubEndpointsDependentCache(DerivedStorage);
          if ((_QWORD)v53)
            CFRetain((CFTypeRef)v53);
          remoteXPCEndpointClient_retainCompletionCallbackEntryFields((uint64_t)&v48);
          v13 = *(NSObject **)(DerivedStorage + 24);
          block = MEMORY[0x1E0C809B0];
          v38 = 0x40000000;
          v39 = __remoteXPCEndpointClient_handleCompletionCallback_block_invoke;
          v40 = &__block_descriptor_tmp_8_7;
          v43 = v50;
          *(_OWORD *)v44 = v51;
          v42 = v49;
          v41 = v48;
          *(_QWORD *)&v44[16] = v52;
          *(_QWORD *)&v45 = v8;
          *((_QWORD *)&v45 + 1) = v9;
          v46 = v53;
          v47 = int64;
          dispatch_async(v13, &block);
          v14 = 0;
          goto LABEL_16;
        }
      }
      else
      {
        FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
      }
      v14 = FigSignalErrorAt(4294950571, 0, 0, 0, 0, 0, 0);
LABEL_16:
      if ((_QWORD)v53)
        CFRelease((CFTypeRef)v53);
      remoteXPCEndpointClient_releaseCompletionCallbackEntryFields((uint64_t)&v48);
      return v14;
    }
    v19 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    v55 = 0;
    v56[0] = 0;
    *(_QWORD *)&v48 = 0;
    *((_QWORD *)&v48 + 1) = &v48;
    v49 = 0x2000000000uLL;
    v20 = xpc_dictionary_get_uint64(a2, "ActivationSeed");
    FigXPCMessageCopyCFString(a2, "CommChannelUUID", v56);
    FigXPCMessageCopyCFString(a2, "DelegateFunctionType", &v55);
    FigSimpleMutexLock(*(pthread_mutex_t **)(v19 + 32));
    v21 = *(id **)(v19 + 136);
    if (v21)
    {
      v22 = FigCFWeakReferenceHolderCopyReferencedObject(v21);
      if (!v22)
      {
        v25 = 0;
        v14 = 4294949690;
        goto LABEL_33;
      }
      v14 = 0;
    }
    else
    {
      v14 = 0;
      v22 = 0;
    }
    v25 = 1;
LABEL_33:
    v26 = *(_OWORD *)(v19 + 120);
    v53 = *(_OWORD *)(v19 + 104);
    v54 = v26;
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v19 + 32));
    if (v25)
    {
      CFRetain(a1);
      FigXPCRetain(a2);
      if (v22)
        CFRetain(v22);
      if (v56[0])
        CFRetain(v56[0]);
      if (v55)
      {
        CFRetain(v55);
        v27 = v55;
      }
      else
      {
        v27 = 0;
      }
      v32 = *(NSObject **)(v19 + 24);
      v38 = 0x40000000;
      *(_OWORD *)&v44[8] = v53;
      v45 = v54;
      block = MEMORY[0x1E0C809B0];
      v39 = __remoteXPCEndpointClient_handleRemoteControlDelegateCallback_block_invoke;
      v40 = &unk_1E28E63B0;
      *(_QWORD *)&v41 = &v48;
      *((_QWORD *)&v41 + 1) = v27;
      *(_QWORD *)&v42 = a2;
      *((_QWORD *)&v42 + 1) = a1;
      *(_QWORD *)&v43 = v20;
      *((const void **)&v43 + 1) = v56[0];
      *(_QWORD *)v44 = v22;
      dispatch_async(v32, &block);
    }
    if (v56[0])
      CFRelease(v56[0]);
    if (v22)
      CFRelease(v22);
    if (v55)
      CFRelease(v55);
    _Block_object_dispose(&v48, 8);
    return v14;
  }
  v15 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  *(_QWORD *)&v53 = 0;
  v55 = 0;
  v56[0] = 0;
  v16 = xpc_dictionary_get_uint64(a2, "ActivationSeed");
  FigXPCMessageCopyCFString(a2, "DelegateFunctionType", &v53);
  FigSimpleMutexLock(*(pthread_mutex_t **)(v15 + 32));
  v17 = *(id **)(v15 + 184);
  if (v17)
  {
    v18 = FigCFWeakReferenceHolderCopyReferencedObject(v17);
    if (v18)
      v14 = 0;
    else
      v14 = 4294949690;
  }
  else
  {
    v14 = 0;
    v18 = 0;
  }
  v24 = *(_QWORD *)(v15 + 152);
  v23 = *(_QWORD *)(v15 + 160);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v15 + 32));
  FigEndpointXPCRemoteRetainCopiedEndpointFromReply(a2, 0, v56);
  if (CFStringCompare((CFStringRef)v53, CFSTR("hrar"), 0))
  {
    if (CFStringCompare((CFStringRef)v53, CFSTR("hrtf"), 0))
    {
      v14 = 4294950570;
    }
    else
    {
      FigXPCMessageCopyCFDictionary(a2, "FailureInfo", &v55);
      v14 = remoteXPCEndpointClient_callDelegateHandleFailed(a1, (CFMutableDictionaryRef)v14, v16, v56[0], v23, (uint64_t)v18, v55);
      if (v55)
        CFRelease(v55);
    }
  }
  else
  {
    v28 = v56[0];
    v29 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    *(_QWORD *)&v48 = 0;
    v30 = malloc_type_calloc(1uLL, 8uLL, 0x80040B8603338uLL);
    *v30 = FigXPCRetain(a2);
    if (!(_DWORD)v14)
    {
      if (v24)
      {
        FigXPCMessageCopyCFString(a2, "AuthorizationType", &v48);
        CFRetain(a1);
        if (v28)
          CFRetain(v28);
        if ((_QWORD)v48)
        {
          CFRetain((CFTypeRef)v48);
          v31 = v48;
        }
        else
        {
          v31 = 0;
        }
        v33 = *(NSObject **)(v29 + 24);
        block = MEMORY[0x1E0C809B0];
        v38 = 0x40000000;
        v39 = __remoteXPCEndpointClient_callDelegateHandleAuthRequired_block_invoke;
        v40 = &__block_descriptor_tmp_10_12;
        *(_QWORD *)&v41 = v24;
        *((_QWORD *)&v41 + 1) = a1;
        *(_QWORD *)&v42 = v28;
        *((_QWORD *)&v42 + 1) = v16;
        *(_QWORD *)&v43 = v18;
        *((_QWORD *)&v43 + 1) = v31;
        *(_QWORD *)v44 = v30;
        dispatch_async(v33, &block);
        if ((_QWORD)v48)
          CFRelease((CFTypeRef)v48);
        v14 = 0;
        goto LABEL_61;
      }
      v14 = 4294949690;
    }
    CFRetain(a1);
    v35 = *(NSObject **)(v29 + 24);
    block = MEMORY[0x1E0C809B0];
    v38 = 0x40000000;
    v39 = __remoteXPCEndpointClient_callDelegateHandleAuthRequired_block_invoke_2;
    v40 = &__block_descriptor_tmp_11_5;
    *(_QWORD *)&v41 = a1;
    *((_QWORD *)&v41 + 1) = v30;
    dispatch_async(v35, &block);
  }
LABEL_61:
  if (v56[0])
    CFRelease(v56[0]);
  if (v18)
    CFRelease(v18);
  if ((_QWORD)v53)
    CFRelease((CFTypeRef)v53);
  return v14;
}

uint64_t remoteXPCEndpointClient_callDelegateHandleFailed(const void *a1, CFMutableDictionaryRef a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, const __CFDictionary *a7)
{
  uint64_t DerivedStorage;
  uint64_t v15;
  CFMutableDictionaryRef MutableCopy;
  NSObject *v17;
  _QWORD v19[10];

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if ((_DWORD)a2)
    return (uint64_t)a2;
  if (!a5)
    return 4294949690;
  v15 = DerivedStorage;
  if (a4 && a7)
  {
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a7);
    FigCFDictionarySetValue(MutableCopy, CFSTR("SubEndpoint"), a4);
    CFRetain(a1);
    a7 = MutableCopy;
LABEL_7:
    CFRetain(a4);
    a2 = MutableCopy;
    goto LABEL_8;
  }
  CFRetain(a1);
  MutableCopy = 0;
  a2 = 0;
  if (a4)
    goto LABEL_7;
LABEL_8:
  if (a7)
    CFRetain(a7);
  v17 = *(NSObject **)(v15 + 24);
  v19[0] = MEMORY[0x1E0C809B0];
  v19[1] = 0x40000000;
  v19[2] = __remoteXPCEndpointClient_callDelegateHandleFailed_block_invoke;
  v19[3] = &__block_descriptor_tmp_7_9;
  v19[4] = a5;
  v19[5] = a1;
  v19[6] = a3;
  v19[7] = a7;
  v19[8] = a6;
  v19[9] = a4;
  dispatch_async(v17, v19);
  if (a2)
  {
    CFRelease(a2);
    return 0;
  }
  return (uint64_t)a2;
}

char **remoteXPCEndpointClient_runCallback(char **result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  char **v7;
  char *v8;
  char *v9;
  _QWORD *ClassID;
  char *v11;
  _QWORD *v12;
  char *v13;

  v7 = result;
  v8 = result[1];
  if (v8)
    return (char **)((uint64_t (*)(char *, uint64_t, uint64_t, uint64_t, char *))v8)(*result, a3, a2, a5, result[8]);
  if (result[2])
  {
    v9 = *result;
    if (!*result
      || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v9, ClassID)))
    {
      v9 = 0;
    }
    return (char **)((uint64_t (*)(char *, uint64_t, uint64_t, char *))v7[2])(v9, a5, a4, v7[8]);
  }
  else if (result[3])
  {
    v11 = *result;
    if (!*result
      || (v12 = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(v11, v12)))
    {
      v11 = 0;
    }
    return (char **)((uint64_t (*)(char *, char *, uint64_t, char *))v7[3])(v11, v7[6], a5, v7[8]);
  }
  else
  {
    v13 = result[4];
    if (v13)
      return (char **)((uint64_t (*)(char *, char *, uint64_t, uint64_t, uint64_t, char *))v13)(*result, result[7], a3, a2, a5, result[8]);
  }
  return result;
}

void __remoteXPCEndpointClient_callDelegateHandleFailed_block_invoke(uint64_t a1)
{
  const void *v2;
  const void *v3;

  (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
  CFRelease(*(CFTypeRef *)(a1 + 40));
  v2 = *(const void **)(a1 + 72);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 56);
  if (v3)
    CFRelease(v3);
}

uint64_t remoteXPCFigEndpoint_setCachedProperty(uint64_t a1, const void *a2, const void *a3)
{
  __CFDictionary *v6;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 32));
  v6 = *(__CFDictionary **)(a1 + 56);
  if (a3)
    CFDictionarySetValue(v6, a2, a3);
  else
    CFDictionaryRemoveValue(v6, a2);
  return FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 32));
}

uint64_t remoteXPCFigEndpoint_clearAggregateSubEndpointsDependentCache(uint64_t a1)
{
  remoteXPCFigEndpoint_setCachedProperty(a1, CFSTR("Endpoints"), 0);
  remoteXPCFigEndpoint_setCachedProperty(a1, CFSTR("AirPlayVodkaVersion"), 0);
  remoteXPCFigEndpoint_setCachedProperty(a1, CFSTR("AirPlayFromCloud"), 0);
  remoteXPCFigEndpoint_setCachedProperty(a1, CFSTR("Streams"), 0);
  remoteXPCFigEndpoint_setCachedProperty(a1, CFSTR("Volume"), 0);
  remoteXPCFigEndpoint_setCachedProperty(a1, CFSTR("VolumeDB"), 0);
  remoteXPCFigEndpoint_setCachedProperty(a1, CFSTR("VolumeControlSupported"), 0);
  return remoteXPCFigEndpoint_setCachedProperty(a1, CFSTR("VolumeControlType"), 0);
}

CFTypeRef remoteXPCEndpointClient_retainCompletionCallbackEntryFields(uint64_t a1)
{
  const void *v2;
  CFTypeRef result;

  v2 = *(const void **)(a1 + 48);
  if (v2)
    CFRetain(v2);
  if (*(_QWORD *)a1)
    CFRetain(*(CFTypeRef *)a1);
  result = *(CFTypeRef *)(a1 + 56);
  if (result)
    return CFRetain(result);
  return result;
}

void __remoteXPCEndpointClient_handleCompletionCallback_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const void *v3;

  v2 = a1 + 32;
  remoteXPCEndpointClient_runCallback((char **)(a1 + 32), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 120), *(unsigned int *)(a1 + 128));
  v3 = *(const void **)(a1 + 120);
  if (v3)
    CFRelease(v3);
  remoteXPCEndpointClient_releaseCompletionCallbackEntryFields(v2);
}

void remoteXPCEndpointClient_releaseCompletionCallbackEntryFields(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 48);
  if (v2)
    CFRelease(v2);
  if (*(_QWORD *)a1)
    CFRelease(*(CFTypeRef *)a1);
  v3 = *(const void **)(a1 + 56);
  if (v3)
    CFRelease(v3);
}

void __remoteXPCEndpointClient_handleRemoteControlDelegateCallback_block_invoke(uint64_t a1)
{
  void (*v2)(_QWORD, _QWORD, _QWORD, _QWORD);
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  if (CFStringCompare(*(CFStringRef *)(a1 + 40), CFSTR("hrcd"), 0))
  {
    if (CFStringCompare(*(CFStringRef *)(a1 + 40), CFSTR("hrcc"), 0) == kCFCompareEqualTo)
    {
      v2 = *(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(a1 + 112);
      if (v2)
        v2(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80));
    }
  }
  else if (*(_QWORD *)(a1 + 104))
  {
    FigXPCMessageCopyCFData(*(void **)(a1 + 48), "Data", (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 104))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), *(_QWORD *)(a1 + 80));
  }
  CFRelease(*(CFTypeRef *)(a1 + 56));
  FigXPCRelease(*(xpc_object_t *)(a1 + 48));
  v3 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 80);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(a1 + 72);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 40);
  if (v6)
    CFRelease(v6);
}

void __remoteXPCEndpointClient_callDelegateHandleAuthRequired_block_invoke(uint64_t a1)
{
  const void *v2;
  const void *v3;

  (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, void (*)(uint64_t, const void *, int, xpc_object_t *), _QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), remoteXPCEndpointClient_handleAuthCompletionCallback, *(_QWORD *)(a1 + 80));
  CFRelease(*(CFTypeRef *)(a1 + 40));
  v2 = *(const void **)(a1 + 48);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 72);
  if (v3)
    CFRelease(v3);
}

void remoteXPCEndpointClient_handleAuthCompletionCallback(uint64_t a1, const void *a2, int a3, xpc_object_t *a4)
{
  xpc_connection_t remote_connection;
  _xpc_connection_s *v8;
  xpc_object_t reply;

  if (*a4 && (remote_connection = xpc_dictionary_get_remote_connection(*a4)) != 0)
  {
    v8 = remote_connection;
    reply = xpc_dictionary_create_reply(*a4);
    xpc_dictionary_set_int64(reply, "AuthorizationResult", a3);
    FigXPCMessageSetCFString(reply, "AuthorizationString", a2);
    xpc_connection_send_message(v8, reply);
  }
  else
  {
    reply = 0;
  }
  FigXPCRelease(reply);
  FigXPCRelease(*a4);
  free(a4);
}

void __remoteXPCEndpointClient_callDelegateHandleAuthRequired_block_invoke_2(uint64_t a1)
{
  remoteXPCEndpointClient_handleAuthCompletionCallback(a1, 0, -16728, *(xpc_object_t **)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

uint64_t __ensureActiveEndpointNotificationsRegistered_block_invoke()
{
  ensureActiveEndpointNotificationsRegistered_notifyQueue = (uint64_t)dispatch_queue_create("com.apple.coremedia.remoteendpoint.notify-active", 0);
  return notify_register_dispatch("com.apple.coremedia.active-endpoint-changed", (int *)&ensureActiveEndpointNotificationsRegistered_notifyToken, (dispatch_queue_t)ensureActiveEndpointNotificationsRegistered_notifyQueue, &__block_literal_global_18_0);
}

uint64_t __ensureActiveEndpointNotificationsRegistered_block_invoke_2()
{
  __CFNotificationCenter *DefaultLocalCenter;

  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  return CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("Endpoint_ActiveCarPlayEndpointChanged"), CFSTR("Endpoint_ActiveCarPlayEndpointChanged"), 0);
}

void __remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_block_invoke()
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v1;
  uint64_t v2;
  unsigned int v3;
  char *v4;
  os_log_type_t type;
  int v6[2];
  const char *v7;
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxMutex = (uint64_t)FigSimpleMutexCreate();
  if (!remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_sCachedDemuxMutex)
  {
    v6[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v6, &type);
    v1 = v6[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v3 = v1;
    else
      v3 = v1 & 0xFFFFFFFE;
    if (v3)
    {
      v6[1] = 136315138;
      v7 = "remoteXPCEndpoint_retainCarPlayDemuxEndpointForSource_block_invoke";
      v4 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v1) = v6[0];
    }
    else
    {
      v4 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v4, v4 != &v8, v1, 0, v2);
  }
}

_QWORD *remoteXPCEndpoint_cloneCompletionCallback(const __CFAllocator *a1, uint64_t a2)
{
  _QWORD *v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;

  v3 = CFAllocatorAllocate(a1, 72, 0);
  *(_OWORD *)v3 = *(_OWORD *)a2;
  v5 = *(_OWORD *)(a2 + 32);
  v4 = *(_OWORD *)(a2 + 48);
  v6 = *(_OWORD *)(a2 + 16);
  v3[8] = *(_QWORD *)(a2 + 64);
  *((_OWORD *)v3 + 2) = v5;
  *((_OWORD *)v3 + 3) = v4;
  *((_OWORD *)v3 + 1) = v6;
  remoteXPCEndpointClient_retainCompletionCallbackEntryFields((uint64_t)v3);
  return v3;
}

void remoteXPCEndpoint_freeCompletionCallback(const __CFAllocator *a1, void *a2)
{
  remoteXPCEndpointClient_releaseCompletionCallbackEntryFields((uint64_t)a2);
  CFAllocatorDeallocate(a1, a2);
}

const __CFAllocator *FigEndpointRemoteXPC_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  const void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  int v8;
  uint64_t v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  NSObject *v15;
  uint64_t v17;
  void *v18;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v3 = CMBaseObjectGetDerivedStorage(a1);
  v17 = 0;
  v18 = 0;
  v4 = *(const void **)v3;
  if (*(_BYTE *)(v3 + 40)
    || (v5 = v3, remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(v3 + 8), &v17))
    || (v6 = v17, FigXPCRemoteClientDisassociateObject(v17, v4), *(_BYTE *)(v5 + 41)))
  {
    v7 = 0;
  }
  else
  {
    v8 = FigXPCCreateBasicMessage(0x646F6F6Du, (uint64_t)v4, &v18);
    v7 = v18;
    if (!v8)
    {
      v9 = FigXPCRemoteClientSendSyncMessage(v6, (uint64_t)v18);
      FigXPCRemoteClientKillServerOnTimeout(v6, v9, "FigEndpointRemoteXPC_teardown", 0);
      v7 = v18;
    }
  }
  FigXPCRelease(v7);
  v10 = *(const void **)(DerivedStorage + 88);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(DerivedStorage + 88) = 0;
  }
  v11 = *(const void **)(DerivedStorage + 56);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(DerivedStorage + 56) = 0;
  }
  v12 = *(const void **)(DerivedStorage + 80);
  if (v12)
  {
    CFRelease(v12);
    *(_QWORD *)(DerivedStorage + 80) = 0;
  }
  v13 = *(const void **)(DerivedStorage + 136);
  if (v13)
  {
    CFRelease(v13);
    *(_QWORD *)(DerivedStorage + 136) = 0;
  }
  v14 = *(const void **)(DerivedStorage + 184);
  if (v14)
  {
    CFRelease(v14);
    *(_QWORD *)(DerivedStorage + 184) = 0;
  }
  FigEndpointRPCCacheDispose(*(_QWORD **)(DerivedStorage + 48));
  v15 = *(NSObject **)(DerivedStorage + 24);
  if (v15)
    dispatch_release(v15);
  return FigSimpleMutexDestroy(*(_QWORD *)(DerivedStorage + 32));
}

CFStringRef FigEndpointRemoteXPC_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<FigEndpointRemote %p>{ dissociated : %d, serverDied : %d, objectID : %llu, source : %llu }"), a1, *(unsigned __int8 *)(DerivedStorage + 40), *(unsigned __int8 *)(DerivedStorage + 41), *(_QWORD *)DerivedStorage, *(_QWORD *)(DerivedStorage + 8));
}

uint64_t FigEndpointRemoteXPC_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, _QWORD *a4)
{
  uint64_t DerivedStorage;
  int v9;
  uint64_t SharedXPCClient;
  const __CFArray *v11;
  __CFArray *Mutable;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFTypeID v16;
  CFTypeRef v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t ObjectID;
  xpc_object_t v21;
  xpc_object_t v22;
  CFTypeID v23;
  CFIndex Count;
  CFIndex v25;
  CFIndex i;
  const __CFNumber *ValueAtIndex;
  BOOL v28;
  CFTypeRef v29;
  CFTypeRef v30;
  uint64_t v32;
  CFTypeRef v33;
  CFTypeRef cf;
  const void *valuePtr;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __CFArray *v39;
  xpc_object_t xdict;
  void *value;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  valuePtr = 0;
  v36 = 0;
  v33 = 0;
  cf = 0;
  v32 = 0;
  if (FigCFEqual(a2, CFSTR("Name")) || FigCFEqual(a2, CFSTR("Type")))
  {
    if (remoteXPCFigEndpoint_copyCachedProperty(a1, a2, &cf))
    {
LABEL_10:
      v11 = 0;
      Mutable = 0;
      v13 = 0;
      goto LABEL_87;
    }
    v9 = 0;
  }
  else
  {
    v9 = 1;
  }
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v32);
  if ((_DWORD)SharedXPCClient)
    goto LABEL_100;
  SharedXPCClient = FigEndpointXPCRemoteGetObjectID(a1, &v36);
  if ((_DWORD)SharedXPCClient)
    goto LABEL_100;
  if (v9 && remoteXPCFigEndpoint_copyCachedProperty(a1, a2, &cf))
    goto LABEL_10;
  if (!a2)
  {
    v11 = 0;
    Mutable = 0;
    v13 = 4294954516;
    goto LABEL_87;
  }
  if (CFEqual(CFSTR("Streams"), a2))
  {
    SharedXPCClient = FigEndpointStreamXPCRemotePing();
    if (!(_DWORD)SharedXPCClient)
      goto LABEL_17;
LABEL_100:
    v13 = SharedXPCClient;
    goto LABEL_101;
  }
  if (CFEqual(CFSTR("Messenger"), a2))
  {
    SharedXPCClient = FigEndpointMessengerXPCRemotePing();
    if ((_DWORD)SharedXPCClient)
      goto LABEL_100;
  }
LABEL_17:
  if (CFEqual(CFSTR("Messenger"), a2))
  {
    v14 = v32;
    xdict = 0;
    value = 0;
    v39 = 0;
    v15 = FigXPCCreateBasicMessage(0x636D7367u, v36, &xdict);
    if ((_DWORD)v15
      || (v15 = FigXPCRemoteClientSendSyncMessageCreatingReply(v14, (uint64_t)xdict, (xpc_object_t *)&v39), (_DWORD)v15))
    {
      v13 = v15;
    }
    else
    {
      v13 = FigXPCMessageCopyCFObject(v39, ".Value", (__CFDictionary **)&value);
      if ((_DWORD)v13)
      {
        if (value)
          CFRelease(value);
      }
      else
      {
        cf = value;
        value = 0;
      }
    }
    FigXPCRelease(v39);
    FigXPCRelease(xdict);
    if (!cf)
      goto LABEL_41;
    v16 = CFGetTypeID(cf);
    if (v16 != CFNumberGetTypeID())
      goto LABEL_41;
    if (!CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt64Type, &valuePtr)
      || (cf = 0, v13 = FigEndpointMessengerXPCRemoteCreateWithObjectID(valuePtr, &v33), !(_DWORD)v13))
    {
      if (cf)
        CFRelease(cf);
      v17 = v33;
      v33 = 0;
      cf = v17;
      goto LABEL_41;
    }
LABEL_101:
    v11 = 0;
    Mutable = 0;
    goto LABEL_87;
  }
  if (CFEqual(CFSTR("Endpoints"), a2))
  {
    xdict = 0;
    value = 0;
    v38 = 0;
    v39 = 0;
    v37 = 0;
    v18 = CMBaseObjectGetDerivedStorage(a1);
    if (*(_BYTE *)(v18 + 16))
    {
      v19 = v18;
      ObjectID = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(v18 + 8), &v37);
      if (!(_DWORD)ObjectID)
      {
        ObjectID = FigEndpointXPCRemoteGetObjectID(a1, &v38);
        if (!(_DWORD)ObjectID)
        {
          ObjectID = FigXPCCreateBasicMessage(0x63707365u, v38, &value);
          if (!(_DWORD)ObjectID)
          {
            ObjectID = FigXPCRemoteClientSendSyncMessageCreatingReply(v37, (uint64_t)value, &xdict);
            if (!(_DWORD)ObjectID)
            {
              v21 = xpc_dictionary_get_value(xdict, "AddedSubEndpoints");
              v22 = xpc_dictionary_get_value(xdict, "SubtractedSubEndpoints");
              FigSimpleMutexLock(*(pthread_mutex_t **)(v19 + 32));
              v13 = (uint64_t)FigEndpointRPCCacheApplyObjectDeltas(*(_QWORD *)(v19 + 48), v21, v22);
              if (!(_DWORD)v13)
                v13 = FigEndpointRPCCacheCopyAvailableObjects(*(_QWORD *)(v19 + 48), &v39);
              FigSimpleMutexUnlock(*(pthread_mutex_t **)(v19 + 32));
              cf = v39;
              v39 = 0;
LABEL_38:
              FigXPCRelease(xdict);
              FigXPCRelease(value);
              if ((_DWORD)v13)
                goto LABEL_101;
              goto LABEL_41;
            }
          }
        }
      }
    }
    else
    {
      ObjectID = FigSignalErrorAt(4294954509, 0, 0, 0, 0, 0, 0);
    }
    v13 = ObjectID;
    goto LABEL_38;
  }
  v13 = FigXPCSendStdCopyPropertyMessage(v32, v36, a2, &cf);
  if ((_DWORD)v13)
    goto LABEL_101;
LABEL_41:
  v11 = 0;
  if (CFEqual(CFSTR("Streams"), a2) && cf)
  {
    v23 = CFGetTypeID(cf);
    if (v23 == CFArrayGetTypeID())
    {
      v11 = (const __CFArray *)cf;
      cf = 0;
      Mutable = CFArrayCreateMutable(a3, 0, MEMORY[0x1E0C9B378]);
      if (!Mutable)
        goto LABEL_87;
      Count = CFArrayGetCount(v11);
      if (Count >= 1)
      {
        v25 = Count;
        for (i = 0; i != v25; ++i)
        {
          xdict = 0;
          value = 0;
          ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v11, i);
          if (CFNumberGetValue(ValueAtIndex, kCFNumberSInt64Type, &xdict))
          {
            v13 = FigEndpointStreamXPCRemoteRetainCopiedEndpointStream(xdict, &value);
            if ((_DWORD)v13)
              goto LABEL_87;
            CFArrayAppendValue(Mutable, value);
            CFRelease(value);
          }
        }
      }
      cf = CFRetain(Mutable);
    }
    else
    {
      v11 = 0;
      Mutable = 0;
    }
  }
  else
  {
    Mutable = 0;
  }
  if (FigCFEqual(a2, CFSTR("AirPlayFromCloud"))
    || FigCFEqual(a2, CFSTR("AirPlayVodkaVersion"))
    || FigCFEqual(a2, CFSTR("AuthorizationType"))
    || FigCFEqual(a2, CFSTR("AutoconnectEnabled"))
    || FigCFEqual(a2, CFSTR("ID"))
    || FigCFEqual(a2, CFSTR("IsLocalDevice"))
    || FigCFEqual(a2, CFSTR("IsPerAppDisplay"))
    || FigCFEqual(a2, CFSTR("IsRemoteControlOnly"))
    || FigCFEqual(a2, CFSTR("MACAddress"))
    || FigCFEqual(a2, CFSTR("Model"))
    || FigCFEqual(a2, CFSTR("Name"))
    || FigCFEqual(a2, CFSTR("PrimaryUsage"))
    || FigCFEqual(a2, CFSTR("Streams"))
    || FigCFEqual(a2, CFSTR("Endpoints"))
    || FigCFEqual(a2, CFSTR("SubType"))
    || FigCFEqual(a2, CFSTR("SupportedFeatures"))
    || FigCFEqual(a2, CFSTR("SystemFlags"))
    || FigCFEqual(a2, CFSTR("TransportType"))
    || FigCFEqual(a2, CFSTR("Type"))
    || FigCFEqual(a2, CFSTR("Volume"))
    || FigCFEqual(a2, CFSTR("VolumeDB"))
    || FigCFEqual(a2, CFSTR("VolumeControlSupported"))
    || FigCFEqual(a2, CFSTR("VolumeControlType")))
  {
    if (cf && !FigCFEqual(a2, CFSTR("ID")))
      FigCFEqual(a2, CFSTR("Name"));
    if ((_DWORD)v13)
      v28 = 0;
    else
      v28 = cf == 0;
    if (v28)
      v29 = (CFTypeRef)*MEMORY[0x1E0C9B0D0];
    else
      v29 = cf;
    remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, a2, v29);
  }
LABEL_87:
  if (a4)
  {
    v30 = cf;
    if (cf)
      v30 = CFRetain(cf);
    *a4 = v30;
  }
  if (Mutable)
    CFRelease(Mutable);
  if (v11)
    CFRelease(v11);
  if (cf)
    CFRelease(cf);
  if (v33)
    CFRelease(v33);
  FigXPCRemoteClientKillServerOnTimeout(v32, v13, "FigEndpointRemoteXPC_CopyProperty", a2);
  return v13;
}

uint64_t FigEndpointRemoteXPC_SetProperty(uint64_t a1, const __CFString *a2, const void *a3)
{
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t ObjectID;
  uint64_t v9;
  uint64_t v10;
  const __CFString *v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;

  v15 = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v14 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v14);
  if ((_DWORD)SharedXPCClient)
  {
    v12 = SharedXPCClient;
    v9 = v14;
    goto LABEL_15;
  }
  ObjectID = FigEndpointXPCRemoteGetObjectID(a1, &v15);
  v9 = v14;
  if ((_DWORD)ObjectID || (ObjectID = FigXPCSendStdSetPropertyMessage(v14, v15, a2, a3), (_DWORD)ObjectID))
  {
    v12 = ObjectID;
    goto LABEL_15;
  }
  if (FigCFEqual(a2, CFSTR("AutoconnectEnabled")))
  {
    v10 = DerivedStorage;
    v11 = a2;
  }
  else
  {
    if (!FigCFEqual(a2, CFSTR("Volume"))
      && !FigCFEqual(a2, CFSTR("VolumeDB"))
      && !FigCFEqual(a2, CFSTR("IsMuted"))
      && !FigCFEqual(a2, CFSTR("IsMutedByUser"))
      && !FigCFEqual(a2, CFSTR("IsMutedProgrammatically"))
      && !FigCFEqual(a2, CFSTR("MasterVolume")))
    {
      goto LABEL_14;
    }
    remoteXPCFigEndpoint_setCachedProperty(DerivedStorage, CFSTR("Volume"), 0);
    v10 = DerivedStorage;
    v11 = CFSTR("VolumeDB");
  }
  remoteXPCFigEndpoint_setCachedProperty(v10, v11, 0);
LABEL_14:
  v12 = 0;
LABEL_15:
  FigXPCRemoteClientKillServerOnTimeout(v9, v12, "FigEndpointRemoteXPC_SetProperty", a2);
  return v12;
}

uint64_t remoteXPCFigEndpoint_copyCachedProperty(uint64_t a1, const void *a2, _QWORD *a3)
{
  uint64_t DerivedStorage;
  const void *Value;
  const void *v7;
  uint64_t result;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 56), a2);
  v7 = Value;
  if (Value)
  {
    CFRetain(Value);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
    if (v7 == (const void *)*MEMORY[0x1E0C9B0D0])
    {
      CFRelease(v7);
      v7 = 0;
    }
    result = 1;
  }
  else
  {
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
    result = 0;
  }
  *a3 = v7;
  return result;
}

uint64_t FigEndpointRemoteXPC_ActivateWithCompletionCallback(const void *a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage;
  uint64_t ObjectID;
  uint64_t v12;
  NSObject *v14;
  _QWORD block[7];
  int v16;
  xpc_object_t xdict;
  uint64_t v18;

  v18 = 0;
  xdict = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  ObjectID = FigEndpointXPCRemoteGetObjectID((uint64_t)a1, &v18);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x61637674u, v18, &xdict), (_DWORD)ObjectID))
  {
    v12 = ObjectID;
    if (a4)
    {
      if (a1)
        CFRetain(a1);
      v14 = *(NSObject **)(DerivedStorage + 24);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __FigEndpointRemoteXPC_ActivateWithCompletionCallback_block_invoke;
      block[3] = &__block_descriptor_tmp_24_4;
      block[4] = a4;
      block[5] = a1;
      v16 = v12;
      block[6] = a5;
      dispatch_async(v14, block);
    }
  }
  else
  {
    FigXPCMessageSetCFDictionary(xdict, "ActivateOptions", a3);
    xpc_dictionary_set_uint64(xdict, "ActivationFeatures", a2);
    v12 = FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback((uint64_t)a1, xdict, a4, 1, 0, 0, 0, 0, 0, a5);
  }
  FigXPCRelease(xdict);
  return v12;
}

uint64_t FigEndpointRemoteXPC_DeactivateWithCompletionCallback(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage;
  uint64_t ObjectID;
  uint64_t v10;
  NSObject *v12;
  _QWORD block[8];
  int v14;
  void *v15;
  uint64_t v16;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v15 = 0;
  v16 = 0;
  ObjectID = FigEndpointXPCRemoteGetObjectID((uint64_t)a1, &v16);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x64617674u, v16, &v15), (_DWORD)ObjectID))
  {
    v10 = ObjectID;
    if (a3)
    {
      if (a1)
        CFRetain(a1);
      v12 = *(NSObject **)(DerivedStorage + 24);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __FigEndpointRemoteXPC_DeactivateWithCompletionCallback_block_invoke;
      block[3] = &__block_descriptor_tmp_26_4;
      block[4] = a3;
      block[5] = a1;
      v14 = v10;
      block[6] = 0;
      block[7] = a4;
      dispatch_async(v12, block);
    }
  }
  else
  {
    FigXPCMessageSetCFDictionary(v15, "DeactivateOptions", a2);
    FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
    *(_QWORD *)(DerivedStorage + 72) = 0;
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
    v10 = FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback((uint64_t)a1, v15, a3, 0, 0, 0, 0, 0, 0, a4);
  }
  FigXPCRelease(v15);
  return v10;
}

uint64_t FigEndpointRemoteXPC_Dissociate(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t v4;
  uint64_t v6;
  xpc_object_t v7;
  uint64_t v8;

  v7 = 0;
  v8 = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v6 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v6);
  if ((_DWORD)SharedXPCClient
    || (SharedXPCClient = FigEndpointXPCRemoteGetObjectID(a1, &v8), (_DWORD)SharedXPCClient)
    || (SharedXPCClient = FigXPCCreateBasicMessage(0x64736F63u, v8, &v7), (_DWORD)SharedXPCClient))
  {
    v4 = SharedXPCClient;
  }
  else
  {
    v4 = FigXPCRemoteClientSendSyncMessage(v6, (uint64_t)v7);
    if (!(_DWORD)v4)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
      *(_BYTE *)(DerivedStorage + 40) = 1;
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
    }
  }
  FigXPCRelease(v7);
  return v4;
}

uint64_t FigEndpointRemoteXPC_SetDelegateRouting(uint64_t a1, __int128 *a2)
{
  uint64_t DerivedStorage;
  const void *v5;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;
  uint64_t SharedXPCClient;
  unsigned int v10;
  uint64_t v11;
  uint64_t v13;
  xpc_object_t v14;
  uint64_t v15;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v14 = 0;
  v15 = 0;
  v13 = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
  v5 = *(const void **)(DerivedStorage + 184);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(DerivedStorage + 184) = 0;
  }
  v6 = (_OWORD *)(DerivedStorage + 144);
  if (a2)
  {
    v7 = *a2;
    v8 = a2[1];
    *(_QWORD *)(DerivedStorage + 176) = *((_QWORD *)a2 + 4);
    *v6 = v7;
    *(_OWORD *)(DerivedStorage + 160) = v8;
    *(_QWORD *)(DerivedStorage + 184) = FigCFWeakReferenceHolderCreateWithReferencedObject(*(_QWORD *)a2);
  }
  else
  {
    *(_QWORD *)(DerivedStorage + 176) = 0;
    *v6 = 0u;
    *(_OWORD *)(DerivedStorage + 160) = 0u;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v13);
  if (!(_DWORD)SharedXPCClient)
  {
    SharedXPCClient = FigEndpointXPCRemoteGetObjectID(a1, &v15);
    if (!(_DWORD)SharedXPCClient)
    {
      if (a2)
        v10 = 1935962740;
      else
        v10 = 1667527284;
      SharedXPCClient = FigXPCCreateBasicMessage(v10, v15, &v14);
      if (!(_DWORD)SharedXPCClient)
        SharedXPCClient = FigXPCRemoteClientSendSyncMessage(v13, (uint64_t)v14);
    }
  }
  v11 = SharedXPCClient;
  FigXPCRelease(v14);
  FigXPCRemoteClientKillServerOnTimeout(v13, v11, "FigEndpointRemoteXPC_SetDelegateRouting", 0);
  return v11;
}

uint64_t FigEndpointRemoteXPC_SetDelegateRemoteControl(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  const void *v5;
  _OWORD *v6;
  __int128 v7;
  uint64_t SharedXPCClient;
  unsigned int v9;
  uint64_t v10;
  uint64_t v12;
  xpc_object_t v13;
  uint64_t v14;

  v13 = 0;
  v14 = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v12 = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
  v5 = *(const void **)(DerivedStorage + 136);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(DerivedStorage + 136) = 0;
  }
  v6 = (_OWORD *)(DerivedStorage + 104);
  if (a2)
  {
    v7 = *(_OWORD *)(a2 + 16);
    *v6 = *(_OWORD *)a2;
    *(_OWORD *)(DerivedStorage + 120) = v7;
    *(_QWORD *)(DerivedStorage + 136) = FigCFWeakReferenceHolderCreateWithReferencedObject(*(_QWORD *)a2);
  }
  else
  {
    *v6 = 0u;
    *(_OWORD *)(DerivedStorage + 120) = 0u;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v12);
  if (!(_DWORD)SharedXPCClient)
  {
    SharedXPCClient = FigEndpointXPCRemoteGetObjectID(a1, &v14);
    if (!(_DWORD)SharedXPCClient)
    {
      if (a2)
        v9 = 1935962723;
      else
        v9 = 1667527267;
      SharedXPCClient = FigXPCCreateBasicMessage(v9, v14, &v13);
      if (!(_DWORD)SharedXPCClient)
        SharedXPCClient = FigXPCRemoteClientSendSyncMessage(v12, (uint64_t)v13);
    }
  }
  v10 = SharedXPCClient;
  FigXPCRelease(v13);
  FigXPCRemoteClientKillServerOnTimeout(v12, v10, "FigEndpointRemoteXPC_SetDelegateRemoteControl", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_CreatePlaybackSession(uint64_t a1, CFTypeRef *a2)
{
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  const void *uint64;
  uint64_t v7;
  uint64_t v9;
  CFTypeRef cf;
  xpc_object_t xdict;
  xpc_object_t v12;
  uint64_t v13;

  v12 = 0;
  v13 = 0;
  cf = 0;
  xdict = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v9 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v9);
  if ((_DWORD)SharedXPCClient
    || (SharedXPCClient = FigEndpointXPCRemoteGetObjectID(a1, &v13), (_DWORD)SharedXPCClient)
    || (SharedXPCClient = FigXPCCreateBasicMessage(0x63706273u, v13, &v12), (_DWORD)SharedXPCClient)
    || (SharedXPCClient = FigXPCRemoteClientSendSyncMessageCreatingReply(v9, (uint64_t)v12, &xdict),
        (_DWORD)SharedXPCClient))
  {
    v7 = SharedXPCClient;
  }
  else
  {
    uint64 = (const void *)xpc_dictionary_get_uint64(xdict, "PlaybackSessionID");
    v7 = FigEndpointPlaybackSessionXPCRemoteCreateWithObjectID(uint64, &cf);
    if (!(_DWORD)v7)
    {
      *a2 = cf;
      cf = 0;
    }
  }
  FigXPCRelease(v12);
  FigXPCRelease(xdict);
  if (cf)
    CFRelease(cf);
  FigXPCRemoteClientKillServerOnTimeout(v9, v7, "FigEndpointRemoteXPC_CreatePlaybackSession", 0);
  return v7;
}

uint64_t FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(uint64_t a1, void *a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t DerivedStorage;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  const void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t SharedXPCClient;
  uint64_t v27;
  char v28;
  NSObject *v29;
  _QWORD v31[4];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  __int128 value;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v19 = DerivedStorage;
  v44 = 0;
  v42 = 0u;
  v43 = 0u;
  value = 0u;
  v41 = 0u;
  v39 = 0;
  v20 = a8 | a5 | a3 | a7;
  v21 = v20 != 0;
  if (v20)
  {
    *(_QWORD *)&v41 = a7;
    *((_QWORD *)&v41 + 1) = a5;
    *(_QWORD *)&value = a1;
    *((_QWORD *)&value + 1) = a3;
    BYTE8(v42) = a4;
    *(_QWORD *)&v42 = a8;
    *(_QWORD *)&v43 = a6;
    *((_QWORD *)&v43 + 1) = a9;
    v44 = a10;
    FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
    v22 = CMBaseObjectGetDerivedStorage(a1);
    v23 = *(const void **)(v22 + 96);
    v24 = 1;
    if ((unint64_t)v23 + 1 > 1)
      v24 = (uint64_t)v23 + 1;
    *(_QWORD *)(v22 + 96) = v24;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v19 + 88), v23, &value);
    v25 = *(_QWORD *)(v19 + 64);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v19 + 32));
    xpc_dictionary_set_uint64(a2, "CompletionID", (uint64_t)v23);
  }
  else
  {
    v23 = 0;
    v25 = 0;
  }
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(v19 + 8), &v39);
  if (!(_DWORD)SharedXPCClient)
    SharedXPCClient = FigXPCRemoteClientSendSyncMessage(v39, (uint64_t)a2);
  v27 = SharedXPCClient;
  v28 = !v21;
  if (!(_DWORD)SharedXPCClient)
    v28 = 1;
  if ((v28 & 1) == 0)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(v19 + 32));
    if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(v19 + 88), v23, 0))
    {
      remoteXPCEndpointClient_retainCompletionCallbackEntryFields((uint64_t)&value);
      v29 = *(NSObject **)(v19 + 24);
      v31[0] = MEMORY[0x1E0C809B0];
      v31[1] = 0x40000000;
      v31[2] = __FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback_block_invoke;
      v31[3] = &__block_descriptor_tmp_25_5;
      v34 = v42;
      v35 = v43;
      v32 = value;
      v33 = v41;
      v36 = v44;
      v37 = v25;
      v38 = v27;
      dispatch_async(v29, v31);
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v19 + 88), v23);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v19 + 32));
  }
  FigXPCRemoteClientKillServerOnTimeout(v39, v27, "FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback", 0);
  return v27;
}

uint64_t FigEndpointRemoteXPC_RequestCarUI(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v6;
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t FigEndpoint;
  uint64_t v10;
  uint64_t v12;
  int v13[2];
  uint64_t v14;

  *(_QWORD *)v13 = 0;
  v14 = 0;
  v6 = ((uint64_t (*)(void))FigEndpointExtendedGetFigEndpoint)();
  DerivedStorage = CMBaseObjectGetDerivedStorage(v6);
  v12 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v12);
  if (!(_DWORD)SharedXPCClient)
  {
    FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
    SharedXPCClient = FigEndpointXPCRemoteGetObjectID(FigEndpoint, &v14);
    if (!(_DWORD)SharedXPCClient)
    {
      SharedXPCClient = FigXPCCreateBasicMessage(0x63617220u, v14, v13);
      if (!(_DWORD)SharedXPCClient)
      {
        if (a2)
          FigXPCMessageSetCFString(*(void **)v13, "UUID", a2);
        if (a3)
          FigXPCMessageSetCFURL(*(void **)v13, "URL", a3);
        SharedXPCClient = FigXPCRemoteClientSendSyncMessage(v12, *(uint64_t *)v13);
      }
    }
  }
  v10 = SharedXPCClient;
  FigXPCRelease(*(xpc_object_t *)v13);
  FigXPCRemoteClientKillServerOnTimeout(v12, v10, "FigEndpointRemoteXPC_RequestCarUI", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_BorrowScreen(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v13;
  int v14[2];
  uint64_t v15;

  *(_QWORD *)v14 = 0;
  v15 = 0;
  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v13 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v13);
  if ((_DWORD)SharedXPCClient
    || (v9 = FigEndpointExtendedGetFigEndpoint(a1),
        SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v15),
        (_DWORD)SharedXPCClient))
  {
    v10 = SharedXPCClient;
    v11 = 0;
  }
  else
  {
    v10 = FigXPCCreateBasicMessage(0x62732020u, v15, v14);
    v11 = *(void **)v14;
    if (!(_DWORD)v10)
    {
      FigXPCMessageSetCFString(*(void **)v14, "Client", a2);
      FigXPCMessageSetCFString(*(void **)v14, "Reason", a3);
      v10 = FigXPCRemoteClientSendSyncMessage(v13, *(uint64_t *)v14);
      v11 = *(void **)v14;
    }
  }
  FigXPCRelease(v11);
  FigXPCRemoteClientKillServerOnTimeout(v13, v10, "FigEndpointRemoteXPC_BorrowScreen", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_UnborrowScreen(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v13;
  int v14[2];
  uint64_t v15;

  *(_QWORD *)v14 = 0;
  v15 = 0;
  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v13 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v13);
  if ((_DWORD)SharedXPCClient
    || (v9 = FigEndpointExtendedGetFigEndpoint(a1),
        SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v15),
        (_DWORD)SharedXPCClient))
  {
    v10 = SharedXPCClient;
    v11 = 0;
  }
  else
  {
    v10 = FigXPCCreateBasicMessage(0x756E6273u, v15, v14);
    v11 = *(void **)v14;
    if (!(_DWORD)v10)
    {
      FigXPCMessageSetCFString(*(void **)v14, "Client", a2);
      FigXPCMessageSetCFString(*(void **)v14, "Reason", a3);
      v10 = FigXPCRemoteClientSendSyncMessage(v13, *(uint64_t *)v14);
      v11 = *(void **)v14;
    }
  }
  FigXPCRelease(v11);
  FigXPCRemoteClientKillServerOnTimeout(v13, v10, "FigEndpointRemoteXPC_UnborrowScreen", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_TakeScreen(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v13;
  int v14[2];
  uint64_t v15;

  *(_QWORD *)v14 = 0;
  v15 = 0;
  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v13 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v13);
  if ((_DWORD)SharedXPCClient
    || (v9 = FigEndpointExtendedGetFigEndpoint(a1),
        SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v15),
        (_DWORD)SharedXPCClient))
  {
    v10 = SharedXPCClient;
    v11 = 0;
  }
  else
  {
    v10 = FigXPCCreateBasicMessage(0x74732020u, v15, v14);
    v11 = *(void **)v14;
    if (!(_DWORD)v10)
    {
      FigXPCMessageSetCFString(*(void **)v14, "Client", a2);
      FigXPCMessageSetCFString(*(void **)v14, "Reason", a3);
      v10 = FigXPCRemoteClientSendSyncMessage(v13, *(uint64_t *)v14);
      v11 = *(void **)v14;
    }
  }
  FigXPCRelease(v11);
  FigXPCRemoteClientKillServerOnTimeout(v13, v10, "FigEndpointRemoteXPC_TakeScreen", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_DisableBluetoothConnectivityToDevice(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v13;
  uint64_t v14;
  int v15[2];

  v14 = 0;
  *(_QWORD *)v15 = 0;
  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v13 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v13);
  if ((_DWORD)SharedXPCClient
    || (v9 = FigEndpointExtendedGetFigEndpoint(a1),
        SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v14),
        (_DWORD)SharedXPCClient))
  {
    v10 = SharedXPCClient;
    v11 = 0;
  }
  else
  {
    v10 = FigXPCCreateBasicMessage(0x64627464u, v14, v15);
    v11 = *(void **)v15;
    if (!(_DWORD)v10)
    {
      FigXPCMessageSetCFString(*(void **)v15, "DeviceAddress", a2);
      FigXPCMessageSetCFDictionary(*(void **)v15, "DisableBluetoothOptions", a3);
      v10 = FigXPCRemoteClientSendSyncMessage(v13, *(uint64_t *)v15);
      v11 = *(void **)v15;
    }
  }
  FigXPCRelease(v11);
  FigXPCRemoteClientKillServerOnTimeout(v13, v10, "FigEndpointRemoteXPC_DisableBluetoothConnectivityToDevice", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_DuckAudio(uint64_t a1, const void *a2)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v11;
  uint64_t v12;
  int v13[2];

  v12 = 0;
  *(_QWORD *)v13 = 0;
  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v11 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v11);
  if ((_DWORD)SharedXPCClient
    || (v7 = FigEndpointExtendedGetFigEndpoint(a1),
        SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v7, &v12),
        (_DWORD)SharedXPCClient))
  {
    v8 = SharedXPCClient;
    v9 = 0;
  }
  else
  {
    v8 = FigXPCCreateBasicMessage(0x64756361u, v12, v13);
    v9 = *(void **)v13;
    if (!(_DWORD)v8)
    {
      FigXPCMessageSetCFDictionary(*(void **)v13, "Params", a2);
      v8 = FigXPCRemoteClientSendSyncMessage(v11, *(uint64_t *)v13);
      v9 = *(void **)v13;
    }
  }
  FigXPCRelease(v9);
  FigXPCRemoteClientKillServerOnTimeout(v11, v8, "FigEndpointRemoteXPC_DuckAudio", 0);
  return v8;
}

uint64_t FigEndpointRemoteXPC_SetHIDInputMode(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v13;
  int v14[2];
  uint64_t v15;

  *(_QWORD *)v14 = 0;
  v15 = 0;
  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v13 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v13);
  if ((_DWORD)SharedXPCClient
    || (v9 = FigEndpointExtendedGetFigEndpoint(a1),
        SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v15),
        (_DWORD)SharedXPCClient))
  {
    v10 = SharedXPCClient;
    v11 = 0;
  }
  else
  {
    v10 = FigXPCCreateBasicMessage(0x73686D20u, v15, v14);
    v11 = *(void **)v14;
    if (!(_DWORD)v10)
    {
      FigXPCMessageSetCFString(*(void **)v14, "HIDUUID", a2);
      FigXPCMessageSetCFNumber(*(void **)v14, "HIDInputMode", a3);
      v10 = FigXPCRemoteClientSendSyncMessage(v13, *(uint64_t *)v14);
      v11 = *(void **)v14;
    }
  }
  FigXPCRelease(v11);
  FigXPCRemoteClientKillServerOnTimeout(v13, v10, "FigEndpointRemoteXPC_SetHIDInputMode", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_CopyHIDInputMode(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t v10;
  uint64_t v11;
  xpc_object_t v12;
  uint64_t v14;
  xpc_object_t v15;
  int v16[2];
  uint64_t v17;

  *(_QWORD *)v16 = 0;
  v17 = 0;
  v15 = 0;
  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v14 = 0;
  if (a4)
  {
    SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v14);
    if ((_DWORD)SharedXPCClient
      || (v10 = FigEndpointExtendedGetFigEndpoint(a1),
          SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v10, &v17),
          (_DWORD)SharedXPCClient)
      || (SharedXPCClient = FigXPCCreateBasicMessage(0x63686D20u, v17, v16), (_DWORD)SharedXPCClient)
      || (SharedXPCClient = FigXPCMessageSetCFString(*(void **)v16, "HIDUUID", a2), (_DWORD)SharedXPCClient))
    {
      v11 = SharedXPCClient;
      v12 = 0;
    }
    else
    {
      v11 = FigXPCRemoteClientSendSyncMessageCreatingReply(v14, *(uint64_t *)v16, &v15);
      v12 = v15;
      if (!(_DWORD)v11)
      {
        v11 = FigXPCMessageCopyCFNumber(v15, "HIDInputMode", a4);
        v12 = v15;
      }
    }
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  FigXPCRelease(v12);
  FigXPCRelease(*(xpc_object_t *)v16);
  FigXPCRemoteClientKillServerOnTimeout(v14, v11, "FigEndpointRemoteXPC_CopyHIDInputMode", 0);
  return v11;
}

uint64_t FigEndpointRemoteXPC_SendCommand(const void *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t ObjectID;
  uint64_t v13;
  NSObject *v15;
  _QWORD block[7];
  int v17;
  int v18[2];
  uint64_t v19;

  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v19 = 0;
  *(_QWORD *)v18 = 0;
  ObjectID = FigEndpointXPCRemoteGetObjectID(FigEndpoint, &v19);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x636D6D64u, v19, v18), (_DWORD)ObjectID))
  {
    v13 = ObjectID;
    if (a4)
    {
      if (a1)
        CFRetain(a1);
      v15 = *(NSObject **)(DerivedStorage + 24);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __FigEndpointRemoteXPC_SendCommand_block_invoke;
      block[3] = &__block_descriptor_tmp_27_2;
      block[4] = a4;
      block[5] = a1;
      v17 = v13;
      block[6] = a5;
      dispatch_async(v15, block);
    }
  }
  else
  {
    FigXPCMessageSetCFString(*(void **)v18, "Command", a2);
    FigXPCMessageSetCFDictionary(*(void **)v18, "Params", a3);
    v13 = FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(FigEndpoint, *(void **)v18, 0, 0, 0, 0, a4, 0, 0, a5);
  }
  FigXPCRelease(*(xpc_object_t *)v18);
  return v13;
}

uint64_t FigEndpointRemoteXPC_CreateRemoteControlSession(uint64_t a1, const void *a2, _QWORD *a3)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t v9;
  const void *uint64;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  xpc_object_t xdict;
  int v17[2];

  xdict = 0;
  *(_QWORD *)v17 = 0;
  v14 = 0;
  v15 = 0;
  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v13 = 0;
  SharedXPCClient = FigEndpointRemoteControlSessionXPCRemotePing();
  if ((_DWORD)SharedXPCClient
    || (SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v13),
        (_DWORD)SharedXPCClient)
    || (v9 = FigEndpointExtendedGetFigEndpoint(a1),
        SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v15),
        (_DWORD)SharedXPCClient)
    || (SharedXPCClient = FigXPCCreateBasicMessage(0x63726373u, v15, v17), (_DWORD)SharedXPCClient)
    || (FigXPCMessageSetCFDictionary(*(void **)v17, "Params", a2),
        SharedXPCClient = FigXPCRemoteClientSendSyncMessageCreatingReply(v13, *(uint64_t *)v17, &xdict),
        (_DWORD)SharedXPCClient))
  {
    v11 = SharedXPCClient;
  }
  else
  {
    uint64 = (const void *)xpc_dictionary_get_uint64(xdict, "RemoteControlSessionID");
    v11 = FigEndpointRemoteControlSessionXPCRemoteCreateWithObjectID(uint64, &v14);
    if (!(_DWORD)v11)
      *a3 = v14;
  }
  FigXPCRelease(xdict);
  FigXPCRelease(*(xpc_object_t *)v17);
  FigXPCRemoteClientKillServerOnTimeout(v13, v11, "FigEndpointRemoteXPC_CreateRemoteControlSession", 0);
  return v11;
}

uint64_t FigEndpointRemoteXPC_CreateCommChannel(uint64_t a1, const void *a2, _QWORD *a3)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v13;
  xpc_object_t v14;
  int v15[2];
  void *value;
  uint64_t v17;

  value = 0;
  v17 = 0;
  v14 = 0;
  *(_QWORD *)v15 = 0;
  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v13 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v13);
  if ((_DWORD)SharedXPCClient
    || (v9 = FigEndpointExtendedGetFigEndpoint(a1),
        SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v17),
        (_DWORD)SharedXPCClient)
    || (SharedXPCClient = FigXPCCreateBasicMessage(0x63726363u, v17, v15), (_DWORD)SharedXPCClient)
    || (FigXPCMessageSetCFDictionary(*(void **)v15, "Params", a2),
        SharedXPCClient = FigXPCRemoteClientSendSyncMessageCreatingReply(v13, *(uint64_t *)v15, &v14),
        (_DWORD)SharedXPCClient)
    || (SharedXPCClient = FigXPCMessageCopyCFString(v14, "CommChannelUUID", &value), (_DWORD)SharedXPCClient))
  {
    v11 = SharedXPCClient;
  }
  else
  {
    v10 = value;
    if (value)
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
      CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 80), value);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
      v10 = value;
    }
    v11 = 0;
    *a3 = v10;
  }
  FigXPCRelease(*(xpc_object_t *)v15);
  FigXPCRelease(v14);
  FigXPCRemoteClientKillServerOnTimeout(v13, v11, "FigEndpointRemoteXPC_CreateCommChannel", 0);
  return v11;
}

uint64_t FigEndpointRemoteXPC_SendData(const void *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t ObjectID;
  uint64_t v13;
  NSObject *v15;
  _QWORD block[8];
  int v17;
  void *v18;
  uint64_t v19;

  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v18 = 0;
  v19 = 0;
  if (a2 && a3)
  {
    ObjectID = FigEndpointXPCRemoteGetObjectID(FigEndpoint, &v19);
    if (!(_DWORD)ObjectID)
    {
      ObjectID = FigXPCCreateBasicMessage(0x64617461u, v19, &v18);
      if (!(_DWORD)ObjectID)
      {
        FigXPCMessageSetCFString(v18, "CommChannelUUID", a2);
        FigXPCMessageSetCFData(v18, "Data", a3);
        v13 = FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(FigEndpoint, v18, 0, 0, a4, (uint64_t)a2, 0, 0, 0, a5);
        goto LABEL_6;
      }
    }
  }
  else
  {
    ObjectID = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
  }
  v13 = ObjectID;
  if (a4 && (_DWORD)ObjectID)
  {
    if (a1)
      CFRetain(a1);
    if (a2)
      CFRetain(a2);
    v15 = *(NSObject **)(DerivedStorage + 24);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __FigEndpointRemoteXPC_SendData_block_invoke;
    block[3] = &__block_descriptor_tmp_28_0;
    block[4] = a4;
    block[5] = a1;
    v17 = v13;
    block[6] = a2;
    block[7] = a5;
    dispatch_async(v15, block);
  }
LABEL_6:
  FigXPCRelease(v18);
  return v13;
}

uint64_t FigEndpointRemoteXPC_CloseCommChannel(uint64_t a1, const void *a2)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t v6;
  uint64_t SharedXPCClient;
  uint64_t v8;
  const __CFArray *v9;
  CFIndex FirstIndexOfValue;
  uint64_t v11;
  uint64_t v13;
  xpc_object_t v14;
  uint64_t v15;
  CFRange v16;

  v14 = 0;
  v15 = 0;
  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v13 = 0;
  if (!a2)
  {
    SharedXPCClient = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
LABEL_11:
    v11 = SharedXPCClient;
    goto LABEL_9;
  }
  v6 = DerivedStorage;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v13);
  if ((_DWORD)SharedXPCClient)
    goto LABEL_11;
  v8 = FigEndpointExtendedGetFigEndpoint(a1);
  SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v8, &v15);
  if ((_DWORD)SharedXPCClient)
    goto LABEL_11;
  SharedXPCClient = FigXPCCreateBasicMessage(0x636C6363u, v15, &v14);
  if ((_DWORD)SharedXPCClient)
    goto LABEL_11;
  SharedXPCClient = FigXPCRemoteClientSendSyncMessage(v13, (uint64_t)v14);
  if ((_DWORD)SharedXPCClient)
    goto LABEL_11;
  FigSimpleMutexLock(*(pthread_mutex_t **)(v6 + 32));
  v9 = *(const __CFArray **)(v6 + 80);
  v16.length = CFArrayGetCount(v9);
  v16.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v9, v16, a2);
  if (FirstIndexOfValue != -1)
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v6 + 80), FirstIndexOfValue);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v6 + 32));
  v11 = 0;
LABEL_9:
  FigXPCRelease(v14);
  FigXPCRemoteClientKillServerOnTimeout(v13, v11, "FigEndpointRemoteXPC_CloseCommChannel", 0);
  return v11;
}

uint64_t FigEndpointRemoteXPC_RequestScreenViewArea(uint64_t a1, const void *a2, int64_t a3)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t v9;
  uint64_t v10;
  xpc_object_t v11;
  uint64_t v13;
  uint64_t v14;
  xpc_object_t v15;
  xpc_object_t xdict;

  v15 = 0;
  xdict = 0;
  v14 = 0;
  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v13 = 0;
  SharedXPCClient = FigEndpointRemoteControlSessionXPCRemotePing();
  if ((_DWORD)SharedXPCClient
    || (SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v13),
        (_DWORD)SharedXPCClient)
    || (v9 = FigEndpointExtendedGetFigEndpoint(a1),
        SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v14),
        (_DWORD)SharedXPCClient)
    || (SharedXPCClient = FigXPCCreateBasicMessage(0x72737661u, v14, &xdict), (_DWORD)SharedXPCClient))
  {
    v10 = SharedXPCClient;
    v11 = 0;
  }
  else
  {
    FigXPCMessageSetCFString(xdict, "UUID", a2);
    xpc_dictionary_set_int64(xdict, "Index", a3);
    v10 = FigXPCRemoteClientSendSyncMessageCreatingReply(v13, (uint64_t)xdict, &v15);
    v11 = v15;
  }
  FigXPCRelease(v11);
  FigXPCRelease(xdict);
  FigXPCRemoteClientKillServerOnTimeout(v13, v10, "FigEndpointRemoteXPC_RequestScreenViewArea", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_CopyCurrentScreenViewArea(uint64_t a1, const void *a2, _QWORD *a3)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t v9;
  uint64_t v10;
  xpc_object_t v11;
  uint64_t v13;
  uint64_t v14;
  xpc_object_t v15;
  int v16[2];

  v15 = 0;
  *(_QWORD *)v16 = 0;
  v14 = 0;
  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v13 = 0;
  SharedXPCClient = FigEndpointRemoteControlSessionXPCRemotePing();
  if ((_DWORD)SharedXPCClient
    || (SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v13),
        (_DWORD)SharedXPCClient)
    || (v9 = FigEndpointExtendedGetFigEndpoint(a1),
        SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v14),
        (_DWORD)SharedXPCClient)
    || (SharedXPCClient = FigXPCCreateBasicMessage(0x63737661u, v14, v16), (_DWORD)SharedXPCClient))
  {
    v10 = SharedXPCClient;
    v11 = 0;
  }
  else
  {
    FigXPCMessageSetCFString(*(void **)v16, "UUID", a2);
    v10 = FigXPCRemoteClientSendSyncMessageCreatingReply(v13, *(uint64_t *)v16, &v15);
    v11 = v15;
    if (!(_DWORD)v10)
    {
      v10 = FigXPCMessageCopyCFDictionary(v15, "ViewArea", a3);
      v11 = v15;
    }
  }
  FigXPCRelease(v11);
  FigXPCRelease(*(xpc_object_t *)v16);
  FigXPCRemoteClientKillServerOnTimeout(v13, v10, "FigEndpointRemoteXPC_CopyCurrentScreenViewArea", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_AcquireAndCopyResource(uint64_t a1, const void *a2, const void *a3, _QWORD *a4)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t v11;
  uint64_t uint64;
  const void *v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  xpc_object_t xdict;
  int v19[2];

  xdict = 0;
  *(_QWORD *)v19 = 0;
  v17 = 0;
  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v16 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v16);
  if (!(_DWORD)SharedXPCClient)
  {
    v11 = FigEndpointExtendedGetFigEndpoint(a1);
    SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v11, &v17);
    if (!(_DWORD)SharedXPCClient)
    {
      SharedXPCClient = FigXPCCreateBasicMessage(0x61727363u, v17, v19);
      if (!(_DWORD)SharedXPCClient)
      {
        SharedXPCClient = FigXPCMessageSetCFString(*(void **)v19, "ResourceType", a2);
        if (!(_DWORD)SharedXPCClient)
        {
          SharedXPCClient = FigXPCMessageSetCFDictionary(*(void **)v19, "ResourceOptions", a3);
          if (!(_DWORD)SharedXPCClient)
          {
            SharedXPCClient = FigXPCRemoteClientSendSyncMessageCreatingReply(v16, *(uint64_t *)v19, &xdict);
            if (!(_DWORD)SharedXPCClient)
            {
              uint64 = xpc_dictionary_get_uint64(xdict, "ResourceID");
              if (!uint64)
              {
                v14 = 4294950567;
                goto LABEL_12;
              }
              v13 = (const void *)uint64;
              if (!FigCFEqual(a2, CFSTR("endpointStream")))
              {
                v14 = 4294950570;
                goto LABEL_12;
              }
              SharedXPCClient = FigEndpointStreamXPCRemoteRetainCopiedEndpointStream(v13, a4);
            }
          }
        }
      }
    }
  }
  v14 = SharedXPCClient;
LABEL_12:
  FigXPCRelease(*(xpc_object_t *)v19);
  FigXPCRelease(xdict);
  FigXPCRemoteClientKillServerOnTimeout(v16, v14, "FigEndpointRemoteXPC_AcquireAndCopyResource", 0);
  return v14;
}

uint64_t FigEndpointRemoteXPC_RelinquishResource(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t FigEndpoint;
  uint64_t DerivedStorage;
  uint64_t SharedXPCClient;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t value;
  uint64_t v14;
  xpc_object_t xdict;

  v14 = 0;
  xdict = 0;
  value = 0;
  FigEndpoint = FigEndpointExtendedGetFigEndpoint(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(FigEndpoint);
  v12 = 0;
  SharedXPCClient = remoteXPCFigEndpoint_getSharedXPCClient(*(_QWORD *)(DerivedStorage + 8), &v12);
  if (!(_DWORD)SharedXPCClient)
  {
    v9 = FigEndpointExtendedGetFigEndpoint(a1);
    SharedXPCClient = FigEndpointXPCRemoteGetObjectID(v9, &v14);
    if (!(_DWORD)SharedXPCClient)
    {
      SharedXPCClient = FigXPCCreateBasicMessage(0x72727363u, v14, &xdict);
      if (!(_DWORD)SharedXPCClient)
      {
        SharedXPCClient = FigXPCMessageSetCFString(xdict, "ResourceType", a2);
        if (!(_DWORD)SharedXPCClient)
        {
          if (!FigCFEqual(a2, CFSTR("endpointStream")))
          {
            v10 = 4294950570;
            goto LABEL_10;
          }
          SharedXPCClient = FigEndpointStreamXPCRemoteGetObjectID(a3, &value);
          if (!(_DWORD)SharedXPCClient)
          {
            xpc_dictionary_set_uint64(xdict, "ResourceID", value);
            SharedXPCClient = FigXPCRemoteClientSendSyncMessage(v12, (uint64_t)xdict);
          }
        }
      }
    }
  }
  v10 = SharedXPCClient;
LABEL_10:
  FigXPCRelease(xdict);
  FigXPCRemoteClientKillServerOnTimeout(v12, v10, "FigEndpointRemoteXPC_RelinquishResource", 0);
  return v10;
}

uint64_t FigEndpointRemoteXPC_EndpointAggregateAddEndpointWithCompletionCallback(const void *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  return FigEndpointRemoteXPC_EndpointAggregateOperationWithCompletionCallback(a1, a2, 0x61656165u, a3, a4, a5);
}

uint64_t FigEndpointRemoteXPC_EndpointAggregateRemoveEndpointWithCompletionCallback(const void *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  return FigEndpointRemoteXPC_EndpointAggregateOperationWithCompletionCallback(a1, a2, 0x61657265u, a3, a4, a5);
}

uint64_t FigEndpointRemoteXPC_EndpointAggregateOperationWithCompletionCallback(const void *a1, const void *a2, unsigned int a3, const void *a4, uint64_t a5, uint64_t a6)
{
  uint64_t DerivedStorage;
  uint64_t ObjectID;
  uint64_t v14;
  uint64_t v16;
  NSObject *v17;
  _QWORD block[9];
  int v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v21 = 0;
  v22 = 0;
  v20 = 0;
  ObjectID = FigEndpointXPCRemoteGetObjectID((uint64_t)a1, &v22);
  if ((_DWORD)ObjectID
    || (ObjectID = FigXPCCreateBasicMessage(a3, v22, &v20), (_DWORD)ObjectID)
    || (ObjectID = FigEndpointXPCRemoteGetObjectID((uint64_t)a2, &v21), (_DWORD)ObjectID))
  {
    v14 = ObjectID;
    if (a5)
    {
      if (a1)
        CFRetain(a1);
      if (a2)
        CFRetain(a2);
      FigSimpleMutexLock(*(pthread_mutex_t **)(DerivedStorage + 32));
      v16 = *(_QWORD *)(DerivedStorage + 64);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(DerivedStorage + 32));
      v17 = *(NSObject **)(DerivedStorage + 24);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __FigEndpointRemoteXPC_EndpointAggregateOperationWithCompletionCallback_block_invoke;
      block[3] = &__block_descriptor_tmp_29_2;
      block[4] = a5;
      block[5] = a1;
      block[6] = a2;
      block[7] = v16;
      v19 = v14;
      block[8] = a6;
      dispatch_async(v17, block);
    }
  }
  else
  {
    FigXPCMessageSetCFDictionary(v20, "AggregateOptions", a4);
    xpc_dictionary_set_uint64(v20, "SubEndpointObjectID", v21);
    v14 = FigEndpointRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback((uint64_t)a1, v20, 0, 0, 0, 0, 0, a5, (uint64_t)a2, a6);
    if (!(_DWORD)v14)
      remoteXPCFigEndpoint_clearAggregateSubEndpointsDependentCache(DerivedStorage);
  }
  FigXPCRelease(v20);
  return v14;
}

uint64_t FigEndpointAudioSourceGetClassID()
{
  if (FigEndpointAudioSourceGetClassID_sRegisterOnce != -1)
    dispatch_once_f(&FigEndpointAudioSourceGetClassID_sRegisterOnce, &FigEndpointAudioSourceGetClassID_sClassID, (dispatch_function_t)source_getClassID);
  return FigEndpointAudioSourceGetClassID_sClassID;
}

uint64_t source_getClassID(_QWORD *a1)
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&source_getClassID_sClassDesc, ClassID, 1, a1);
}

uint64_t FigEndpointAudioSourceGetTypeID()
{
  if (FigEndpointAudioSourceGetClassID_sRegisterOnce != -1)
    dispatch_once_f(&FigEndpointAudioSourceGetClassID_sRegisterOnce, &FigEndpointAudioSourceGetClassID_sClassID, (dispatch_function_t)source_getClassID);
  return CMBaseClassGetCFTypeID((_QWORD *)FigEndpointAudioSourceGetClassID_sClassID);
}

CFStringRef source_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigEndpointAudioSource %p]"), a1);
}

uint64_t FigEndpointStartServerEx(const char *a1)
{
  CFMutableDictionaryRef Mutable;
  uint64_t v3;
  _OWORD v5[3];

  v5[0] = xmmword_1E28E6890;
  v5[1] = *(_OWORD *)&off_1E28E68A0;
  v5[2] = xmmword_1E28E68B0;
  if (a1)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    FigCFDictionarySetInt32(Mutable, CFSTR("xpcServerOption_SelfTerminationTimeout"), 30);
    v3 = FigXPCServerStart((uint64_t)a1, (uint64_t)v5, (uint64_t)Mutable, &gEndpointServer);
    if ((_DWORD)v3
      || (gServerSource = strcmp(a1, "com.apple.airplay.endpoint.xpc") == 0, GetActiveEndpointQueue_onceToken == -1))
    {
      if (!Mutable)
        return v3;
    }
    else
    {
      dispatch_once(&GetActiveEndpointQueue_onceToken, &__block_literal_global_62_1);
      if (!Mutable)
        return v3;
    }
    CFRelease(Mutable);
    return v3;
  }
  return FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
}

uint64_t HandleEndpointRemoteMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t OpCode;
  uint64_t v7;
  uint64_t v8;
  uint64_t CMBaseObject;
  uint64_t (*v10)(uint64_t, const __CFString *, _QWORD, CFTypeRef *);
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t uint64;
  uint64_t v15;
  CFTypeRef v16;
  uint64_t PlaybackSessionMessage;
  const void *v18;
  char *v19;
  int v20;
  CFTypeRef v21;
  uint64_t (*v22)(CFTypeRef);
  uint64_t v24;
  CFTypeRef v25;
  int v26;
  CFTypeRef v27;
  CFTypeRef cf;
  uint64_t block;
  uint64_t v30;
  void *v31;
  void *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v26 = 0;
  v24 = 0;
  v25 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v26);
  if ((_DWORD)OpCode)
    return OpCode;
  if (v26 == 1635150946)
  {
    v34 = 0;
    v35 = &v34;
    v36 = 0x2000000000;
    LOBYTE(v37) = 0;
    if (GetActiveEndpointQueue_onceToken != -1)
      dispatch_once(&GetActiveEndpointQueue_onceToken, &__block_literal_global_62_1);
    block = MEMORY[0x1E0C809B0];
    v30 = 0x40000000;
    v31 = __HandleEndpointIsActiveEndpointAvailableMessage_block_invoke;
    v32 = &unk_1E28E68F0;
    v33 = &v34;
    dispatch_sync((dispatch_queue_t)gActiveEndpointQueue, &block);
    xpc_dictionary_set_BOOL(a3, ".Value", *((_BYTE *)v35 + 24) != 0);
    _Block_object_dispose(&v34, 8);
    v13 = 0;
LABEL_52:
    v16 = v25;
    if (!v25)
      return v13;
    goto LABEL_115;
  }
  if (v26 == 1633907830)
  {
    v27 = 0;
    cf = 0;
    v34 = 0;
    v35 = &v34;
    v36 = 0x2000000000;
    v37 = 0;
    v7 = FigXPCMessageCopyCFString(a2, "EndpointType", &cf);
    if (!(_DWORD)v7)
    {
      if (GetActiveEndpointQueue_onceToken != -1)
        dispatch_once(&GetActiveEndpointQueue_onceToken, &__block_literal_global_62_1);
      block = MEMORY[0x1E0C809B0];
      v30 = 0x40000000;
      v31 = __HandleEndpointCopyActiveEndpointMessage_block_invoke;
      v32 = &unk_1E28E68C8;
      v33 = &v34;
      dispatch_sync((dispatch_queue_t)gActiveEndpointQueue, &block);
      v8 = v35[3];
      if (!v8)
      {
        v12 = 0;
LABEL_32:
        v7 = FigEndpointXPCServerWriteNeighborEndpointToReply(a1, v12, a3, 0);
        goto LABEL_33;
      }
      CMBaseObject = FigEndpointGetCMBaseObject(v8);
      v10 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                                       + 48);
      if (!v10)
      {
        v13 = 4294954514;
        goto LABEL_45;
      }
      v7 = v10(CMBaseObject, CFSTR("Type"), *MEMORY[0x1E0C9AE00], &v27);
      if (!(_DWORD)v7)
      {
        v11 = FigCFEqual(cf, v27);
        v12 = (void *)v35[3];
        if (!v11 && v12)
        {
          CFRelease((CFTypeRef)v35[3]);
          v12 = 0;
          v35[3] = 0;
        }
        goto LABEL_32;
      }
    }
LABEL_33:
    v13 = v7;
LABEL_45:
    v18 = (const void *)v35[3];
    if (v18)
      CFRelease(v18);
    if (cf)
      CFRelease(cf);
    if (v27)
      CFRelease(v27);
    _Block_object_dispose(&v34, 8);
    goto LABEL_52;
  }
  uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  v15 = LookupEndpointByObjectIDForConnection(a1, uint64, &v25, &v24);
  if ((_DWORD)v15)
    goto LABEL_101;
  v13 = 4294950586;
  if (v26 <= 1668313956)
  {
    if (v26 <= 1667527266)
    {
      if (v26 > 1634038372)
      {
        if (v26 > 1651712031)
        {
          if (v26 == 1651712032)
          {
            v16 = v25;
            PlaybackSessionMessage = HandleEndpointBorrowScreenMessage((char *)v25, a2);
          }
          else
          {
            if (v26 != 1667330592)
              goto LABEL_52;
            v16 = v25;
            PlaybackSessionMessage = HandleEndpointRequestCarUIMessage((char *)v25, a2);
          }
          goto LABEL_114;
        }
        if (v26 != 1634038373)
        {
          if (v26 != 1634890595)
            goto LABEL_52;
          v16 = v25;
          PlaybackSessionMessage = HandleEndpointAcquireAndCopyResourceMessage((char *)v25, a1, a2, a3);
          goto LABEL_114;
        }
        v16 = v25;
        v19 = (char *)v25;
        v20 = 0;
      }
      else
      {
        if (v26 <= 1633908339)
        {
          if (v26 == 778268793)
          {
            v16 = v25;
            PlaybackSessionMessage = HandleEndpointCopyPropertyMessage((uint64_t)v25, a1, a2, a3);
          }
          else
          {
            if (v26 != 779314548)
              goto LABEL_52;
            v16 = v25;
            PlaybackSessionMessage = FigXPCHandleStdSetPropertyMessage((uint64_t)v25, a2);
          }
          goto LABEL_114;
        }
        if (v26 == 1633908340)
        {
          v16 = v25;
          PlaybackSessionMessage = HandleEndpointActivateMessage((uint64_t)v25, a1, a2);
          goto LABEL_114;
        }
        if (v26 != 1634034021)
          goto LABEL_52;
        v16 = v25;
        v19 = (char *)v25;
        v20 = 1;
      }
      PlaybackSessionMessage = HandleEndpointAddRemoveEndpointMessage(v19, v20, a1, a2);
      goto LABEL_114;
    }
    if (v26 > 1668047714)
    {
      if (v26 > 1668117350)
      {
        if (v26 == 1668117351)
        {
          v16 = v25;
          PlaybackSessionMessage = HandleEndpointCopyMessengerMessage((uint64_t)v25, a1, a3);
        }
        else
        {
          if (v26 != 1668309619)
            goto LABEL_52;
          v16 = v25;
          PlaybackSessionMessage = HandleEndpointCreatePlaybackSessionMessage((uint64_t)v25, a1, a3);
        }
      }
      else if (v26 == 1668047715)
      {
        v16 = v25;
        PlaybackSessionMessage = HandleEndpointCloseCommChannelMessage((uint64_t)v25, a2);
      }
      else
      {
        if (v26 != 1668115812)
          goto LABEL_52;
        v16 = v25;
        PlaybackSessionMessage = HandleEndpointSendCommandMessage((char *)v25, a1, a2);
      }
    }
    else if (v26 > 1667589743)
    {
      if (v26 == 1667589744)
      {
        v16 = v25;
        PlaybackSessionMessage = HandleEndpointCopyEndpointForAnotherProcess(v25, a2, a3);
      }
      else
      {
        if (v26 != 1667788064)
          goto LABEL_52;
        v16 = v25;
        PlaybackSessionMessage = HandleEndpointCopyHIDInputMessage((char *)v25, a2, a3);
      }
    }
    else if (v26 == 1667527267)
    {
      v16 = v25;
      PlaybackSessionMessage = HandleEndpointClearDelegateRemoteControlMessage((uint64_t)v25, v24);
    }
    else
    {
      if (v26 != 1667527284)
        goto LABEL_52;
      v16 = v25;
      PlaybackSessionMessage = HandleEndpointClearDelegateRoutingMessage((uint64_t)v25, v24);
    }
  }
  else if (v26 <= 1685286754)
  {
    if (v26 > 1684108384)
    {
      if (v26 <= 1684173923)
      {
        if (v26 == 1684108385)
        {
          v16 = v25;
          PlaybackSessionMessage = HandleEndpointSendDataMessage((uint64_t)v25, a1, a2);
        }
        else
        {
          if (v26 != 1684108916)
            goto LABEL_52;
          v16 = v25;
          PlaybackSessionMessage = HandleEndpointDeactivateMessage((uint64_t)v25, a1, a2);
        }
        goto LABEL_114;
      }
      if (v26 == 1684173924)
      {
        v16 = v25;
        PlaybackSessionMessage = HandleEndpointDisableBluetoothConnectivityToDevice((char *)v25, a2);
        goto LABEL_114;
      }
      if (v26 != 1685024621)
        goto LABEL_52;
      v15 = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
LABEL_101:
      v13 = v15;
      goto LABEL_52;
    }
    if (v26 > 1668440946)
    {
      if (v26 == 1668440947)
      {
        v16 = v25;
        PlaybackSessionMessage = HandleEndpointCreateRemoteControlSessionMessage((char *)v25, a1, a2, a3);
      }
      else
      {
        if (v26 != 1668511329)
          goto LABEL_52;
        v16 = v25;
        PlaybackSessionMessage = HandleEndpointCopyCurrentScreenViewAreaMessage((char *)v25, a2, a3);
      }
    }
    else if (v26 == 1668313957)
    {
      v16 = v25;
      PlaybackSessionMessage = HandleEndpointCopySubEndpointsMessage((uint64_t)v25, a1, a3, v24);
    }
    else
    {
      if (v26 != 1668440931)
        goto LABEL_52;
      v16 = v25;
      PlaybackSessionMessage = HandleEndpointCreateCommChannelMessage((uint64_t)v25, a2, a3);
    }
  }
  else
  {
    if (v26 > 1935962722)
    {
      if (v26 <= 1936223519)
      {
        if (v26 == 1935962723)
        {
          v16 = v25;
          PlaybackSessionMessage = HandleEndpointSetDelegateRemoteControlMessage((uint64_t)v25, a1, uint64, v24);
        }
        else
        {
          if (v26 != 1935962740)
            goto LABEL_52;
          v16 = v25;
          PlaybackSessionMessage = HandleEndpointSetDelegateRoutingMessage((uint64_t)v25, a1, uint64, v24);
        }
      }
      else
      {
        switch(v26)
        {
          case 1936223520:
            v16 = v25;
            PlaybackSessionMessage = HandleEndpointSetHIDInputMessage((char *)v25, a2);
            break;
          case 1953701920:
            v16 = v25;
            PlaybackSessionMessage = HandleEndpointTakeScreenMessage((char *)v25, a2);
            break;
          case 1970168435:
            v16 = v25;
            PlaybackSessionMessage = HandleEndpointUnborrowScreenMessage((char *)v25, a2);
            break;
          default:
            goto LABEL_52;
        }
      }
      goto LABEL_114;
    }
    if (v26 <= 1920103266)
    {
      if (v26 != 1685286755)
      {
        if (v26 != 1685414753)
          goto LABEL_52;
        v16 = v25;
        PlaybackSessionMessage = HandleEndpointDuckAudio((char *)v25, a2);
        goto LABEL_114;
      }
      v21 = v25;
      v22 = *(uint64_t (**)(CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v25) + 16) + 32);
      if (!v22)
      {
        v13 = 4294954514;
        goto LABEL_52;
      }
      v15 = v22(v21);
      goto LABEL_101;
    }
    if (v26 == 1920103267)
    {
      v16 = v25;
      PlaybackSessionMessage = HandleEndpointRelinquishResourceMessage((char *)v25, a2);
    }
    else
    {
      if (v26 != 1920169569)
        goto LABEL_52;
      v16 = v25;
      PlaybackSessionMessage = HandleEndpointRequestScreenViewAreaMessage((char *)v25, a2);
    }
  }
LABEL_114:
  v13 = PlaybackSessionMessage;
  if (v16)
LABEL_115:
    CFRelease(v16);
  return v13;
}

uint64_t HandleNoReplyEndpointMessage(_xpc_connection_s *a1, void *a2)
{
  uint64_t OpCode;
  uint64_t uint64;
  unsigned int v6;
  uint64_t v7;
  CFTypeRef cf;
  int v10;

  v10 = 0;
  cf = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v10);
  if ((_DWORD)OpCode)
    return OpCode;
  uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  v6 = LookupEndpointByObjectIDForConnection(a1, uint64, &cf, 0);
  if (v6)
    v7 = v6;
  else
    v7 = 4294950586;
  if (cf)
    CFRelease(cf);
  return v7;
}

uint64_t FigEndpointStartServer()
{
  if (FigIsAirplaydEnabled())
    return FigEndpointStartServerEx("com.apple.mediaexperience.endpoint.xpc");
  else
    return FigEndpointStartServerEx("com.apple.coremedia.endpoint.xpc");
}

const char *FigEndpointXPCServerNameForSource(uint64_t a1)
{
  if (a1 == 1)
    return "com.apple.airplay.endpoint.xpc";
  if (a1)
    return 0;
  if (FigIsAirplaydEnabled())
    return "com.apple.mediaexperience.endpoint.xpc";
  return "com.apple.coremedia.endpoint.xpc";
}

void FigEndpointServerSetActiveEndpoint(CFTypeRef cf)
{
  _QWORD v2[5];
  char v3;

  if (cf)
    CFRetain(cf);
  if (GetActiveEndpointQueue_onceToken != -1)
    dispatch_once(&GetActiveEndpointQueue_onceToken, &__block_literal_global_62_1);
  v2[0] = MEMORY[0x1E0C809B0];
  v2[1] = 0x40000000;
  v2[2] = __FigEndpointServerSetActiveEndpointAndForceNotify_block_invoke;
  v2[3] = &__block_descriptor_tmp_65_0;
  v2[4] = cf;
  v3 = 0;
  dispatch_async((dispatch_queue_t)gActiveEndpointQueue, v2);
}

uint64_t FigXPCEndpointServerAssociateNeighborFigEndpointWithRegistration(_xpc_connection_s *a1, CFTypeRef cf, _QWORD *a3)
{
  CFTypeID v6;

  if (cf && (v6 = CFGetTypeID(cf), v6 == FigEndpointGetTypeID()))
    return FigXPCServerAssociateCopiedObjectWithNeighborProcess(gEndpointServer, a1, cf, 0, 0, 0, a3);
  else
    return FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCEndpointServerRetainEndpointForID(void *a1, _QWORD *a2)
{
  return FigXPCServerRetainNeighborObjectFromID((uint64_t *)gEndpointServer, a1, a2);
}

uint64_t FigEndpointXPCServerWriteNeighborEndpointToReply(_xpc_connection_s *a1, void *cf, void *a3, uint64_t *a4)
{
  CFTypeID v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t value;
  uint64_t v13;
  uint64_t v14;

  v13 = 0;
  v14 = 0;
  v11 = 0;
  value = 0;
  if (!cf)
  {
    v10 = 0;
    goto LABEL_6;
  }
  v8 = CFGetTypeID(cf);
  if (v8 != FigEndpointGetTypeID())
    return FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
  result = figEndpointXPC_getNeighborObjectIDAndSource(a1, cf, &v14, (uint64_t *)&value, &v13, &v11);
  if (!(_DWORD)result)
  {
    v10 = v14;
LABEL_6:
    xpc_dictionary_set_uint64(a3, "EndpointObjectID", v10);
    xpc_dictionary_set_uint64(a3, "EndpointXPCSource", value);
    if ((value & 0x1000) != 0)
    {
      xpc_dictionary_set_uint64(a3, "SubEndpointObjectID", v13);
      xpc_dictionary_set_uint64(a3, "SubEndpointXPCSource", v11);
    }
    result = 0;
    if (a4)
      *a4 = v14;
  }
  return result;
}

uint64_t figEndpointXPC_getNeighborObjectIDAndSource(_xpc_connection_s *a1, void *a2, _QWORD *a3, uint64_t *a4, _QWORD *a5, _QWORD *a6)
{
  CFTypeID v12;
  uint64_t ObjectIDForSource;
  uint64_t v14;
  _QWORD *ClassID;
  uint64_t CMBaseObject;
  void (*v17)(uint64_t, const __CFString *, _QWORD, CFTypeRef *);
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFTypeRef cf;

  v23 = 0;
  cf = 0;
  v21 = 0;
  v22 = 0;
  v20 = 0;
  if (!a2 || (v12 = CFGetTypeID(a2), v12 != FigEndpointGetTypeID()) || !a3 || !a4)
  {
    ObjectIDForSource = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
    goto LABEL_23;
  }
  if (!FigEndpointIsXPCRemote((uint64_t)a2))
  {
    v14 = gServerSource;
    v21 = gServerSource;
    ClassID = (_QWORD *)FigEndpointAggregateGetClassID();
    if (CMBaseObjectIsMemberOfClass((char *)a2, ClassID))
    {
      v14 |= 0x2000uLL;
      v21 = v14;
    }
    CMBaseObject = FigEndpointGetCMBaseObject(a2);
    v17 = *(void (**)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                              + 8)
                                                                                  + 48);
    if (!v17
      || (v17(CMBaseObject, CFSTR("CarPlaySubEndpoint"), *MEMORY[0x1E0C9AE00], &cf), !cf)
      || (v14 |= 0x1000uLL,
          v21 = v14,
          ObjectIDForSource = figEndpointXPC_getNeighborObjectIDAndSource(a1, cf, &v22, &v20, 0, 0),
          !(_DWORD)ObjectIDForSource))
    {
      ObjectIDForSource = figEndpointXPC_getObjectIDForSource(a1, a2, v14, &v23);
      if (!(_DWORD)ObjectIDForSource)
        goto LABEL_15;
    }
LABEL_23:
    v18 = ObjectIDForSource;
    goto LABEL_19;
  }
  ObjectIDForSource = FigEndpointXPCRemoteGetSource((uint64_t)a2, &v21);
  if ((_DWORD)ObjectIDForSource)
    goto LABEL_23;
  ObjectIDForSource = figEndpointXPC_getObjectIDForSource(a1, a2, v21, &v23);
  if ((_DWORD)ObjectIDForSource)
    goto LABEL_23;
  v14 = v21;
LABEL_15:
  *a3 = v23;
  *a4 = v14;
  if (a5)
    *a5 = v22;
  v18 = 0;
  if (a6)
    *a6 = v20;
LABEL_19:
  if (cf)
    CFRelease(cf);
  return v18;
}

uint64_t FigEndpointXPCSourceNeedsSubEndpoint(unsigned int a1)
{
  return (a1 >> 12) & 1;
}

uint64_t FigEndpointXPCServerAppendNeighborEndpointToArray(_xpc_connection_s *a1, void *cf, void *a3, uint64_t *a4)
{
  CFTypeID v8;
  xpc_object_t empty;
  uint64_t v10;

  if (cf && (v8 = CFGetTypeID(cf), v8 == FigEndpointGetTypeID()))
  {
    empty = xpc_dictionary_create_empty();
    v10 = FigEndpointXPCServerWriteNeighborEndpointToReply(a1, cf, empty, a4);
    if (!(_DWORD)v10)
      xpc_array_set_value(a3, 0xFFFFFFFFFFFFFFFFLL, empty);
  }
  else
  {
    v10 = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
    empty = 0;
  }
  FigXPCRelease(empty);
  return v10;
}

unint64_t FigEndpointXPCSourceGetBase(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFFFCFFFLL;
}

uint64_t LookupEndpointByObjectIDForConnection(_xpc_connection_s *a1, uint64_t a2, CFTypeRef *a3, _QWORD *a4)
{
  uint64_t v5;
  CFTypeID v6;
  uint64_t v7;
  CFTypeRef cf;

  cf = 0;
  v5 = FigXPCServerLookupAndRetainAssociatedObject(a1, a2, &cf, a4);
  if (!(_DWORD)v5)
  {
    if (cf)
    {
      v6 = CFGetTypeID(cf);
      if (v6 == FigEndpointGetTypeID())
      {
        v7 = 0;
        *a3 = cf;
        return v7;
      }
    }
    v5 = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
  }
  v7 = v5;
  if (cf)
    CFRelease(cf);
  return v7;
}

uint64_t HandleEndpointCopyPropertyMessage(uint64_t a1, _xpc_connection_s *a2, void *a3, void *a4)
{
  uint64_t v7;
  CFTypeRef v8;
  uint64_t (*v9)(uint64_t, CFTypeRef, _QWORD, CFArrayRef *);
  const __CFAllocator *v10;
  int v11;
  CFArrayRef v12;
  CFIndex Count;
  CFArrayRef v14;
  uint64_t v15;
  const __CFArray *Mutable;
  CFIndex v17;
  const void *ValueAtIndex;
  uint64_t v19;
  CFNumberRef v20;
  CFNumberRef v21;
  uint64_t v22;
  uint64_t valuePtr;
  CFArrayRef theArray;
  CFTypeRef cf1;

  theArray = 0;
  cf1 = 0;
  v7 = FigXPCMessageCopyCFString(a3, ".PropertyName", &cf1);
  if (!(_DWORD)v7)
  {
    v8 = cf1;
    if (cf1)
    {
      v9 = *(uint64_t (**)(uint64_t, CFTypeRef, _QWORD, CFArrayRef *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 8)
                                                                              + 48);
      if (!v9)
      {
        v22 = 4294954514;
        goto LABEL_21;
      }
      v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v7 = v9(a1, v8, *MEMORY[0x1E0C9AE00], &theArray);
      if (!(_DWORD)v7)
      {
        v11 = CFEqual(cf1, CFSTR("Streams"));
        v12 = theArray;
        if (v11)
        {
          Count = CFArrayGetCount(theArray);
          v14 = theArray;
          if (theArray)
          {
            v15 = Count;
            Mutable = CFArrayCreateMutable(v10, 0, MEMORY[0x1E0C9B378]);
            theArray = Mutable;
            if (!Mutable)
            {
              v22 = 4294950585;
LABEL_20:
              CFRelease(v14);
              goto LABEL_21;
            }
            if (v15 >= 1)
            {
              v17 = 0;
              while (1)
              {
                valuePtr = 0;
                ValueAtIndex = CFArrayGetValueAtIndex(v14, v17);
                v19 = FigXPCEndpointStreamServerAssociateCopiedNeighborFigEndpointStream(a2, ValueAtIndex, &valuePtr);
                if ((_DWORD)v19)
                  break;
                v20 = CFNumberCreate(v10, kCFNumberSInt64Type, &valuePtr);
                if (!v20)
                {
                  v22 = 4294950585;
                  if (v14)
                    goto LABEL_20;
                  goto LABEL_21;
                }
                v21 = v20;
                CFArrayAppendValue(theArray, v20);
                CFRelease(v21);
                if (v15 == ++v17)
                {
                  v12 = theArray;
                  goto LABEL_18;
                }
              }
LABEL_19:
              v22 = v19;
              if (!v14)
                goto LABEL_21;
              goto LABEL_20;
            }
            v12 = Mutable;
          }
          else
          {
            v12 = 0;
          }
        }
        else
        {
          v14 = 0;
        }
LABEL_18:
        v19 = FigXPCMessageSetCFObject(a4, ".Value", v12);
        goto LABEL_19;
      }
    }
    else
    {
      v7 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
    }
  }
  v22 = v7;
LABEL_21:
  if (theArray)
    CFRelease(theArray);
  if (cf1)
    CFRelease(cf1);
  return v22;
}

uint64_t HandleEndpointSetDelegateRemoteControlMessage(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t DelegateCallbackParameters;
  CFTypeRef v7;
  const void *v8;
  uint64_t (*v9)(uint64_t, __int128 *);
  uint64_t v10;
  __int128 v12;
  __int128 v13;
  CFTypeRef cf;

  cf = 0;
  v12 = 0u;
  v13 = 0u;
  if (!a4)
    return 4294954513;
  DelegateCallbackParameters = CreateDelegateCallbackParameters(a3, a2, (uint64_t *)&cf);
  v7 = cf;
  if ((_DWORD)DelegateCallbackParameters)
    goto LABEL_9;
  v8 = *(const void **)(a4 + 16);
  *(_QWORD *)(a4 + 16) = cf;
  if (v7)
    CFRetain(v7);
  if (v8)
    CFRelease(v8);
  v12 = *(unint64_t *)(a4 + 16);
  *(_QWORD *)&v13 = SendDidReceiveDataFromCommChannelCallback;
  *((_QWORD *)&v13 + 1) = SendDidCloseCommChannelCallback;
  v9 = *(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 56);
  if (v9)
  {
    DelegateCallbackParameters = v9(a1, &v12);
LABEL_9:
    v10 = DelegateCallbackParameters;
    if (!v7)
      return v10;
    goto LABEL_12;
  }
  v10 = 4294954514;
  if (v7)
LABEL_12:
    CFRelease(v7);
  return v10;
}

uint64_t HandleEndpointClearDelegateRemoteControlMessage(uint64_t a1, uint64_t a2)
{
  const void *v4;
  uint64_t (*v5)(uint64_t, _QWORD);

  if (!a2)
    return 4294954513;
  v4 = *(const void **)(a2 + 16);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a2 + 16) = 0;
  }
  v5 = *(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 56);
  if (v5)
    return v5(a1, 0);
  else
    return 4294954514;
}

uint64_t HandleEndpointSetDelegateRoutingMessage(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t DelegateCallbackParameters;
  CFTypeRef v7;
  const void *v8;
  uint64_t (*v9)(uint64_t, __int128 *);
  uint64_t v10;
  CFTypeRef cf;
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  v15 = 0;
  v13 = 0u;
  v14 = 0u;
  cf = 0;
  if (!a4)
    return 4294954513;
  DelegateCallbackParameters = CreateDelegateCallbackParameters(a3, a2, (uint64_t *)&cf);
  v7 = cf;
  if ((_DWORD)DelegateCallbackParameters)
    goto LABEL_9;
  v8 = *(const void **)(a4 + 8);
  *(_QWORD *)(a4 + 8) = cf;
  if (v7)
    CFRetain(v7);
  if (v8)
    CFRelease(v8);
  *(_QWORD *)&v13 = *(_QWORD *)(a4 + 8);
  *((_QWORD *)&v13 + 1) = SendHandleAuthRequiredCallback;
  *(_QWORD *)&v14 = SendHandleFailedCallback;
  v9 = *(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 48);
  if (v9)
  {
    DelegateCallbackParameters = v9(a1, &v13);
LABEL_9:
    v10 = DelegateCallbackParameters;
    if (!v7)
      return v10;
    goto LABEL_12;
  }
  v10 = 4294954514;
  if (v7)
LABEL_12:
    CFRelease(v7);
  return v10;
}

uint64_t HandleEndpointClearDelegateRoutingMessage(uint64_t a1, uint64_t a2)
{
  const void *v4;
  uint64_t (*v5)(uint64_t, _QWORD);

  if (!a2)
    return 4294954513;
  v4 = *(const void **)(a2 + 8);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a2 + 8) = 0;
  }
  v5 = *(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 48);
  if (v5)
    return v5(a1, 0);
  else
    return 4294954514;
}

uint64_t HandleEndpointRequestCarUIMessage(char *a1, void *a2)
{
  _QWORD *ClassID;
  uint64_t v5;
  uint64_t v6;
  CFTypeRef v7;
  uint64_t (*v8)(char *, uint64_t, CFTypeRef);
  uint64_t v9;
  uint64_t v11;
  CFTypeRef cf;

  v11 = 0;
  cf = 0;
  if (!a1
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  v5 = FigXPCMessageCopyCFString(a2, "UUID", &v11);
  if ((_DWORD)v5)
    goto LABEL_8;
  v5 = FigXPCMessageCopyCFURL(a2, "URL", &cf);
  if ((_DWORD)v5)
    goto LABEL_8;
  v6 = v11;
  v7 = cf;
  v8 = *(uint64_t (**)(char *, uint64_t, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 24) + 8);
  if (v8)
  {
    v5 = v8(a1, v6, v7);
LABEL_8:
    v9 = v5;
    goto LABEL_9;
  }
  v9 = 4294954514;
LABEL_9:
  if (cf)
    CFRelease(cf);
  return v9;
}

uint64_t HandleEndpointBorrowScreenMessage(char *a1, void *a2)
{
  _QWORD *ClassID;
  uint64_t v5;
  CFTypeRef v6;
  CFTypeRef v7;
  uint64_t (*v8)(char *, CFTypeRef, CFTypeRef);
  uint64_t v9;
  CFTypeRef v11;
  CFTypeRef cf;

  v11 = 0;
  cf = 0;
  if (!a1
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  v5 = FigXPCMessageCopyCFString(a2, "Client", &cf);
  if ((_DWORD)v5)
    goto LABEL_8;
  v5 = FigXPCMessageCopyCFString(a2, "Reason", &v11);
  if ((_DWORD)v5)
    goto LABEL_8;
  v7 = v11;
  v6 = cf;
  v8 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 24)
                                                              + 16);
  if (v8)
  {
    v5 = v8(a1, v6, v7);
LABEL_8:
    v9 = v5;
    goto LABEL_9;
  }
  v9 = 4294954514;
LABEL_9:
  if (cf)
    CFRelease(cf);
  if (v11)
    CFRelease(v11);
  return v9;
}

uint64_t HandleEndpointUnborrowScreenMessage(char *a1, void *a2)
{
  _QWORD *ClassID;
  uint64_t v5;
  CFTypeRef v6;
  CFTypeRef v7;
  uint64_t (*v8)(char *, CFTypeRef, CFTypeRef);
  uint64_t v9;
  CFTypeRef v11;
  CFTypeRef cf;

  v11 = 0;
  cf = 0;
  if (!a1
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  v5 = FigXPCMessageCopyCFString(a2, "Client", &cf);
  if ((_DWORD)v5)
    goto LABEL_8;
  v5 = FigXPCMessageCopyCFString(a2, "Reason", &v11);
  if ((_DWORD)v5)
    goto LABEL_8;
  v7 = v11;
  v6 = cf;
  v8 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 24)
                                                              + 24);
  if (v8)
  {
    v5 = v8(a1, v6, v7);
LABEL_8:
    v9 = v5;
    goto LABEL_9;
  }
  v9 = 4294954514;
LABEL_9:
  if (cf)
    CFRelease(cf);
  if (v11)
    CFRelease(v11);
  return v9;
}

uint64_t HandleEndpointTakeScreenMessage(char *a1, void *a2)
{
  _QWORD *ClassID;
  uint64_t v5;
  CFTypeRef v6;
  CFTypeRef v7;
  uint64_t (*v8)(char *, CFTypeRef, CFTypeRef);
  uint64_t v9;
  CFTypeRef v11;
  CFTypeRef cf;

  v11 = 0;
  cf = 0;
  if (!a1
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  v5 = FigXPCMessageCopyCFString(a2, "Client", &cf);
  if ((_DWORD)v5)
    goto LABEL_8;
  v5 = FigXPCMessageCopyCFString(a2, "Reason", &v11);
  if ((_DWORD)v5)
    goto LABEL_8;
  v7 = v11;
  v6 = cf;
  v8 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 24)
                                                              + 32);
  if (v8)
  {
    v5 = v8(a1, v6, v7);
LABEL_8:
    v9 = v5;
    goto LABEL_9;
  }
  v9 = 4294954514;
LABEL_9:
  if (cf)
    CFRelease(cf);
  if (v11)
    CFRelease(v11);
  return v9;
}

uint64_t HandleEndpointCopyHIDInputMessage(char *a1, void *a2, void *a3)
{
  _QWORD *ClassID;
  uint64_t v7;
  CFTypeRef v8;
  uint64_t (*v9)(char *, CFTypeRef, _QWORD, CFTypeRef *);
  uint64_t v10;
  CFTypeRef v12;
  CFTypeRef cf;

  v12 = 0;
  cf = 0;
  if (!a1
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    v7 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  v7 = FigXPCMessageCopyCFString(a2, "HIDUUID", &cf);
  if ((_DWORD)v7)
  {
LABEL_8:
    v10 = v7;
    goto LABEL_9;
  }
  v8 = cf;
  v9 = *(uint64_t (**)(char *, CFTypeRef, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1)
                                                                                    + 24)
                                                                        + 64);
  if (v9)
  {
    v7 = v9(a1, v8, *MEMORY[0x1E0C9AE00], &v12);
    if (!(_DWORD)v7)
      v7 = FigXPCMessageSetCFNumber(a3, "HIDInputMode", v12);
    goto LABEL_8;
  }
  v10 = 4294954514;
LABEL_9:
  if (cf)
    CFRelease(cf);
  if (v12)
    CFRelease(v12);
  return v10;
}

uint64_t HandleEndpointDisableBluetoothConnectivityToDevice(char *a1, void *a2)
{
  _QWORD *ClassID;
  uint64_t v5;
  CFTypeRef v6;
  CFTypeRef v7;
  uint64_t (*v8)(char *, CFTypeRef, CFTypeRef);
  uint64_t v9;
  CFTypeRef v11;
  CFTypeRef cf;

  v11 = 0;
  cf = 0;
  if (!a1
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  v5 = FigXPCMessageCopyCFString(a2, "DeviceAddress", &cf);
  if ((_DWORD)v5)
    goto LABEL_8;
  v5 = FigXPCMessageCopyCFDictionary(a2, "DisableBluetoothOptions", &v11);
  if ((_DWORD)v5)
    goto LABEL_8;
  v7 = v11;
  v6 = cf;
  v8 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 24)
                                                              + 40);
  if (v8)
  {
    v5 = v8(a1, v6, v7);
LABEL_8:
    v9 = v5;
    goto LABEL_9;
  }
  v9 = 4294954514;
LABEL_9:
  if (cf)
    CFRelease(cf);
  if (v11)
    CFRelease(v11);
  return v9;
}

uint64_t HandleEndpointDuckAudio(char *a1, void *a2)
{
  _QWORD *ClassID;
  uint64_t v5;
  CFTypeRef v6;
  uint64_t (*v7)(char *, CFTypeRef);
  uint64_t v8;
  CFTypeRef cf;

  cf = 0;
  if (!a1
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  v5 = FigXPCMessageCopyCFDictionary(a2, "Params", &cf);
  if ((_DWORD)v5)
  {
LABEL_7:
    v8 = v5;
    goto LABEL_8;
  }
  v6 = cf;
  v7 = *(uint64_t (**)(char *, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 24) + 48);
  if (v7)
  {
    v5 = v7(a1, v6);
    goto LABEL_7;
  }
  v8 = 4294954514;
LABEL_8:
  if (cf)
    CFRelease(cf);
  return v8;
}

uint64_t HandleEndpointSetHIDInputMessage(char *a1, void *a2)
{
  _QWORD *ClassID;
  uint64_t v5;
  CFTypeRef v6;
  CFTypeRef v7;
  uint64_t (*v8)(char *, CFTypeRef, CFTypeRef);
  uint64_t v9;
  CFTypeRef v11;
  CFTypeRef cf;

  v11 = 0;
  cf = 0;
  if (!a1
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_8;
  }
  v5 = FigXPCMessageCopyCFString(a2, "HIDUUID", &cf);
  if ((_DWORD)v5)
    goto LABEL_8;
  v5 = FigXPCMessageCopyCFNumber(a2, "HIDInputMode", &v11);
  if ((_DWORD)v5)
    goto LABEL_8;
  v7 = v11;
  v6 = cf;
  v8 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 24)
                                                              + 56);
  if (v8)
  {
    v5 = v8(a1, v6, v7);
LABEL_8:
    v9 = v5;
    goto LABEL_9;
  }
  v9 = 4294954514;
LABEL_9:
  if (cf)
    CFRelease(cf);
  if (v11)
    CFRelease(v11);
  return v9;
}

uint64_t HandleEndpointSendCommandMessage(char *a1, xpc_connection_t connection, void *a3)
{
  pid_t pid;
  pid_t v7;
  _QWORD *ClassID;
  uint64_t v9;
  xpc_object_t *CompletionCallbackParametersFromMessageAndConnection_1;
  uint64_t v11;
  CFMutableDictionaryRef MutableCopy;
  uint64_t CMBaseObject;
  uint64_t (*v14)(uint64_t, const __CFString *, uint64_t, CFTypeRef *);
  uint64_t v15;
  CFTypeRef v16;
  uint64_t (*v17)(char *, CFTypeRef, CFMutableDictionaryRef, void (*)(uint64_t, int, const void *, uint64_t), xpc_object_t *);
  void (*v18)(uint64_t, int, const void *, uint64_t);
  uint64_t v19;
  CFTypeRef cf1;
  CFTypeRef v22;
  CFTypeRef cf;

  v22 = 0;
  cf = 0;
  pid = xpc_connection_get_pid(connection);
  cf1 = 0;
  if (!a1
    || (v7 = pid,
        ClassID = (_QWORD *)FigEndpointExtendedGetClassID(),
        !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    v9 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
LABEL_16:
    v19 = v9;
    MutableCopy = 0;
LABEL_17:
    CompletionCallbackParametersFromMessageAndConnection_1 = 0;
    goto LABEL_20;
  }
  v9 = FigXPCMessageCopyCFString(a3, "Command", &cf);
  if ((_DWORD)v9)
    goto LABEL_16;
  v9 = FigXPCMessageCopyCFDictionary(a3, "Params", &v22);
  if ((_DWORD)v9)
    goto LABEL_16;
  CompletionCallbackParametersFromMessageAndConnection_1 = (xpc_object_t *)CreateCompletionCallbackParametersFromMessageAndConnection_1(a3, connection);
  v11 = *MEMORY[0x1E0C9AE00];
  MutableCopy = FigCFDictionaryCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (CFDictionaryRef)v22);
  if (MutableCopy)
  {
    CMBaseObject = FigEndpointGetCMBaseObject(a1);
    v14 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                                  + 8)
                                                                                      + 48);
    if (!v14)
    {
LABEL_19:
      v19 = 4294954514;
      goto LABEL_20;
    }
    v15 = v14(CMBaseObject, CFSTR("Type"), v11, &cf1);
    if (!(_DWORD)v15)
    {
      if (FigCFEqual(cf1, CFSTR("EndpointType_Car"))
        || (v15 = FigCFDictionarySetInt64(MutableCopy, CFSTR("clientPID"), v7), !(_DWORD)v15))
      {
        v16 = cf;
        v17 = *(uint64_t (**)(char *, CFTypeRef, CFMutableDictionaryRef, void (*)(uint64_t, int, const void *, uint64_t), xpc_object_t *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 24) + 72);
        if (v17)
        {
          if (CompletionCallbackParametersFromMessageAndConnection_1)
            v18 = SendCommandCompletionCallback;
          else
            v18 = 0;
          v19 = v17(a1, v16, MutableCopy, v18, CompletionCallbackParametersFromMessageAndConnection_1);
          goto LABEL_17;
        }
        CompletionCallbackParametersFromMessageAndConnection_1 = 0;
        goto LABEL_19;
      }
    }
    v19 = v15;
  }
  else
  {
    v19 = 4294954510;
  }
LABEL_20:
  DestroyCompletionCallbackParameters(CompletionCallbackParametersFromMessageAndConnection_1);
  if (cf)
    CFRelease(cf);
  if (v22)
    CFRelease(v22);
  if (cf1)
    CFRelease(cf1);
  if (MutableCopy)
    CFRelease(MutableCopy);
  return v19;
}

uint64_t HandleEndpointCreateRemoteControlSessionMessage(char *a1, _xpc_connection_s *a2, void *a3, void *a4)
{
  _QWORD *ClassID;
  uint64_t v9;
  CFTypeRef v10;
  uint64_t (*v11)(char *, CFTypeRef, CFTypeRef *);
  uint64_t v13;
  uint64_t value;
  CFTypeRef cf;
  CFTypeRef v17;

  cf = 0;
  v17 = 0;
  if (!a1
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    v9 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_12;
  }
  v9 = FigXPCMessageCopyCFDictionary(a3, "Params", &cf);
  if ((_DWORD)v9)
    goto LABEL_12;
  v10 = cf;
  v11 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 24)
                                                                 + 80);
  if (!v11)
  {
    v13 = 4294954514;
    goto LABEL_13;
  }
  v9 = v11(a1, v10, &v17);
  if ((_DWORD)v9 || v17 == 0)
  {
LABEL_12:
    v13 = v9;
    goto LABEL_13;
  }
  value = 0;
  v13 = FigXPCEndpointRemoteControlSessionServerAssociateCopiedNeighborRemoteControlSession(a2, v17, &value);
  if (!(_DWORD)v13)
    xpc_dictionary_set_uint64(a4, "RemoteControlSessionID", value);
LABEL_13:
  if (cf)
    CFRelease(cf);
  if (v17)
    CFRelease(v17);
  return v13;
}

uint64_t HandleEndpointCreateCommChannelMessage(uint64_t a1, void *a2, void *a3)
{
  CFTypeRef v5;
  uint64_t (*v6)(uint64_t, CFTypeRef, CFTypeRef *);
  uint64_t v7;
  CFTypeRef cf;
  CFTypeRef v10;

  cf = 0;
  v10 = 0;
  FigXPCMessageCopyCFDictionary(a2, "Params", &cf);
  v5 = cf;
  v6 = *(uint64_t (**)(uint64_t, CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 24) + 88);
  if (v6)
  {
    v7 = v6(a1, v5, &v10);
    if (!(_DWORD)v7)
      FigXPCMessageSetCFString(a3, "CommChannelUUID", v10);
  }
  else
  {
    v7 = 4294954514;
  }
  if (cf)
    CFRelease(cf);
  if (v10)
    CFRelease(v10);
  return v7;
}

uint64_t HandleEndpointSendDataMessage(uint64_t a1, void *a2, void *a3)
{
  uint64_t v6;
  _QWORD *CompletionCallbackParametersFromMessageAndConnection_1;
  CFTypeRef v8;
  CFTypeRef v9;
  uint64_t (*v10)(uint64_t, CFTypeRef, CFTypeRef, void (*)(uint64_t, const void *, int, uint64_t), _QWORD *);
  void (*v11)(uint64_t, const void *, int, uint64_t);
  uint64_t v12;
  CFTypeRef v14;
  CFTypeRef cf;

  v14 = 0;
  cf = 0;
  v6 = FigXPCMessageCopyCFString(a3, "CommChannelUUID", &cf);
  if ((_DWORD)v6 || (v6 = FigXPCMessageCopyCFData(a3, "Data", &v14), (_DWORD)v6))
  {
LABEL_8:
    v12 = v6;
    goto LABEL_10;
  }
  CompletionCallbackParametersFromMessageAndConnection_1 = CreateCompletionCallbackParametersFromMessageAndConnection_1(a3, a2);
  v9 = v14;
  v8 = cf;
  v10 = *(uint64_t (**)(uint64_t, CFTypeRef, CFTypeRef, void (*)(uint64_t, const void *, int, uint64_t), _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 24) + 96);
  if (v10)
  {
    if (CompletionCallbackParametersFromMessageAndConnection_1)
      v11 = SendDataCompletionCallback;
    else
      v11 = 0;
    v6 = v10(a1, v8, v9, v11, CompletionCallbackParametersFromMessageAndConnection_1);
    goto LABEL_8;
  }
  v12 = 4294954514;
LABEL_10:
  if (cf)
    CFRelease(cf);
  if (v14)
    CFRelease(v14);
  return v12;
}

uint64_t HandleEndpointCloseCommChannelMessage(uint64_t a1, void *a2)
{
  uint64_t v3;
  CFTypeRef v4;
  uint64_t (*v5)(uint64_t, CFTypeRef);
  uint64_t v6;
  CFTypeRef cf;

  cf = 0;
  v3 = FigXPCMessageCopyCFString(a2, "CommChannelUUID", &cf);
  if ((_DWORD)v3)
    goto LABEL_4;
  v4 = cf;
  v5 = *(uint64_t (**)(uint64_t, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 24) + 104);
  if (v5)
  {
    v3 = v5(a1, v4);
LABEL_4:
    v6 = v3;
    goto LABEL_6;
  }
  v6 = 4294954514;
LABEL_6:
  if (cf)
    CFRelease(cf);
  return v6;
}

uint64_t HandleEndpointRequestScreenViewAreaMessage(char *a1, void *a2)
{
  _QWORD *ClassID;
  uint64_t v5;
  int64_t int64;
  CFTypeRef v7;
  uint64_t (*v8)(char *, CFTypeRef, int64_t);
  uint64_t v9;
  CFTypeRef cf;

  cf = 0;
  if (!a1
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    v5 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  v5 = FigXPCMessageCopyCFString(a2, "UUID", &cf);
  if ((_DWORD)v5)
  {
LABEL_7:
    v9 = v5;
    goto LABEL_8;
  }
  int64 = xpc_dictionary_get_int64(a2, "Index");
  v7 = cf;
  v8 = *(uint64_t (**)(char *, CFTypeRef, int64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 24)
                                                            + 112);
  if (v8)
  {
    v5 = v8(a1, v7, int64);
    goto LABEL_7;
  }
  v9 = 4294954514;
LABEL_8:
  if (cf)
    CFRelease(cf);
  return v9;
}

uint64_t HandleEndpointCopyCurrentScreenViewAreaMessage(char *a1, void *a2, void *a3)
{
  _QWORD *ClassID;
  uint64_t v7;
  CFTypeRef v8;
  uint64_t (*v9)(char *, CFTypeRef, CFTypeRef *);
  uint64_t v10;
  CFTypeRef v11;
  uint64_t v12;
  CFTypeRef cf;
  CFTypeRef v15;

  cf = 0;
  v15 = 0;
  if (!a1
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    v7 = FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  v7 = FigXPCMessageCopyCFString(a2, "UUID", &v15);
  if ((_DWORD)v7)
  {
LABEL_9:
    v12 = v7;
    goto LABEL_10;
  }
  v8 = v15;
  v9 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 24)
                                                                + 120);
  if (v9)
  {
    v10 = v9(a1, v8, &cf);
    v11 = cf;
    if (!(_DWORD)v10)
    {
      v12 = FigXPCMessageSetCFDictionary(a3, "ViewArea", cf);
      v11 = cf;
      if (!cf)
        goto LABEL_10;
      goto LABEL_7;
    }
    v12 = v10;
    if (cf)
LABEL_7:
      CFRelease(v11);
  }
  else
  {
    v12 = 4294954514;
  }
LABEL_10:
  if (v15)
    CFRelease(v15);
  return v12;
}

uint64_t HandleEndpointActivateMessage(uint64_t a1, void *a2, void *a3)
{
  uint64_t v6;
  uint64_t uint64;
  uint64_t v8;
  _QWORD *CompletionCallbackParametersFromMessageAndConnection_1;
  CFTypeRef v10;
  uint64_t (*v11)(uint64_t, uint64_t, CFTypeRef, _QWORD, _QWORD *);
  void (*v12)(uint64_t, uint64_t, uint64_t, int, uint64_t);
  uint64_t v13;
  CFTypeRef cf;

  cf = 0;
  v6 = FigXPCMessageCopyCFDictionary(a3, "ActivateOptions", &cf);
  if ((_DWORD)v6)
  {
LABEL_8:
    v13 = v6;
    goto LABEL_10;
  }
  uint64 = xpc_dictionary_get_uint64(a3, "ActivationFeatures");
  if (uint64)
  {
    v8 = uint64;
    CompletionCallbackParametersFromMessageAndConnection_1 = CreateCompletionCallbackParametersFromMessageAndConnection_1(a3, a2);
    v10 = cf;
    v11 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef, _QWORD, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable(a1)
                                                                                               + 16)
                                                                                   + 8);
    if (v11)
    {
      if (CompletionCallbackParametersFromMessageAndConnection_1)
        v12 = ActivationCompletionCallback;
      else
        v12 = 0;
      v6 = v11(a1, v8, v10, v12, CompletionCallbackParametersFromMessageAndConnection_1);
      goto LABEL_8;
    }
    v13 = 4294954514;
  }
  else
  {
    v13 = 4294950576;
  }
LABEL_10:
  if (cf)
    CFRelease(cf);
  return v13;
}

uint64_t HandleEndpointDeactivateMessage(uint64_t a1, void *a2, void *a3)
{
  uint64_t v6;
  _QWORD *CompletionCallbackParametersFromMessageAndConnection_1;
  void (*v8)(uint64_t, _QWORD);
  CFTypeRef v9;
  uint64_t (*v10)(uint64_t, CFTypeRef, void (*)(uint64_t, uint64_t, uint64_t, int, uint64_t), _QWORD *);
  void (*v11)(uint64_t, uint64_t, uint64_t, int, uint64_t);
  uint64_t v12;
  CFTypeRef cf;

  cf = 0;
  v6 = FigXPCMessageCopyCFDictionary(a3, "DeactivateOptions", &cf);
  if ((_DWORD)v6)
  {
LABEL_9:
    v12 = v6;
    goto LABEL_11;
  }
  CompletionCallbackParametersFromMessageAndConnection_1 = CreateCompletionCallbackParametersFromMessageAndConnection_1(a3, a2);
  v8 = *(void (**)(uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 48);
  if (v8)
    v8(a1, 0);
  v9 = cf;
  v10 = *(uint64_t (**)(uint64_t, CFTypeRef, void (*)(uint64_t, uint64_t, uint64_t, int, uint64_t), _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 16);
  if (v10)
  {
    if (CompletionCallbackParametersFromMessageAndConnection_1)
      v11 = ActivationCompletionCallback;
    else
      v11 = 0;
    v6 = v10(a1, v9, v11, CompletionCallbackParametersFromMessageAndConnection_1);
    goto LABEL_9;
  }
  v12 = 4294954514;
LABEL_11:
  if (cf)
    CFRelease(cf);
  return v12;
}

uint64_t HandleEndpointCreatePlaybackSessionMessage(uint64_t a1, _xpc_connection_s *a2, void *a3)
{
  uint64_t (*v6)(uint64_t, CFTypeRef *);
  uint64_t v7;
  CFTypeRef v8;
  BOOL v9;
  uint64_t v10;
  uint64_t value;
  CFTypeRef cf;

  cf = 0;
  v6 = *(uint64_t (**)(uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 72);
  if (!v6)
    return 4294954514;
  v7 = v6(a1, &cf);
  v8 = cf;
  if ((_DWORD)v7)
    v9 = 1;
  else
    v9 = cf == 0;
  if (!v9)
  {
    value = 0;
    v10 = FigXPCEndpointPlaybackSessionServerAssociateCopiedNeighborFigEndpointPlaybackSession(a2, cf, &value);
    xpc_dictionary_set_uint64(a3, "PlaybackSessionID", value);
    v8 = cf;
    if (!cf)
      return v10;
    goto LABEL_10;
  }
  v10 = v7;
  if (cf)
LABEL_10:
    CFRelease(v8);
  return v10;
}

uint64_t HandleEndpointAcquireAndCopyResourceMessage(char *a1, _xpc_connection_s *a2, void *a3, void *a4)
{
  uint64_t v8;
  _QWORD *ClassID;
  uint64_t v10;
  CFTypeRef v11;
  CFTypeRef v12;
  uint64_t (*v13)(uint64_t, CFTypeRef, CFTypeRef, CFTypeRef *);
  uint64_t v14;
  _QWORD *v15;
  CFTypeRef v16;
  CFTypeRef v17;
  void (*v18)(char *, CFTypeRef, CFTypeRef);
  uint64_t value;
  CFTypeRef v21;
  CFTypeRef v22;
  CFTypeRef cf;

  v22 = 0;
  cf = 0;
  value = 0;
  v21 = 0;
  v8 = FigXPCMessageCopyCFString(a3, "ResourceType", &cf);
  if ((_DWORD)v8)
    goto LABEL_26;
  v8 = FigXPCMessageCopyCFDictionary(a3, "ResourceOptions", &v22);
  if ((_DWORD)v8)
    goto LABEL_26;
  if (!a1
    || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(),
        v10 = (uint64_t)a1,
        !CMBaseObjectIsMemberOfClass(a1, ClassID)))
  {
    v10 = 0;
  }
  v12 = v22;
  v11 = cf;
  v13 = *(uint64_t (**)(uint64_t, CFTypeRef, CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(v10)
                                                                                         + 24)
                                                                             + 128);
  if (!v13)
  {
    v14 = 4294954514;
    goto LABEL_13;
  }
  v8 = v13(v10, v11, v12, &v21);
  if ((_DWORD)v8)
  {
LABEL_26:
    v14 = v8;
  }
  else if (FigCFEqual(cf, CFSTR("endpointStream")))
  {
    v14 = FigXPCEndpointStreamServerAssociateCopiedNeighborFigEndpointStream(a2, v21, &value);
    if (!(_DWORD)v14)
    {
      xpc_dictionary_set_uint64(a4, "ResourceID", value);
      goto LABEL_19;
    }
  }
  else
  {
    v14 = 4294950570;
  }
LABEL_13:
  if (v21)
  {
    if (!a1 || (v15 = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, v15)))
      a1 = 0;
    v16 = cf;
    v17 = v21;
    v18 = *(void (**)(char *, CFTypeRef, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 24)
                                                              + 136);
    if (v18)
      v18(a1, v16, v17);
  }
LABEL_19:
  if (cf)
    CFRelease(cf);
  if (v22)
    CFRelease(v22);
  if (v21)
    CFRelease(v21);
  return v14;
}

uint64_t HandleEndpointRelinquishResourceMessage(char *a1, void *a2)
{
  uint64_t v4;
  uint64_t uint64;
  void *v6;
  _QWORD *ClassID;
  CFTypeRef v8;
  CFTypeRef v9;
  uint64_t (*v10)(char *, CFTypeRef, CFTypeRef);
  uint64_t v11;
  CFTypeRef v13;
  CFTypeRef cf;

  v13 = 0;
  cf = 0;
  v4 = FigXPCMessageCopyCFString(a2, "ResourceType", &cf);
  if ((_DWORD)v4)
    goto LABEL_10;
  uint64 = xpc_dictionary_get_uint64(a2, "ResourceID");
  if (uint64)
  {
    v6 = (void *)uint64;
    if (FigCFEqual(cf, CFSTR("endpointStream")))
    {
      v4 = FigXPCEndpointStreamServerRetainEndpointStreamForID(v6, &v13);
      if ((_DWORD)v4)
      {
LABEL_10:
        v11 = v4;
        goto LABEL_13;
      }
      if (!a1
        || (ClassID = (_QWORD *)FigEndpointExtendedGetClassID(), !CMBaseObjectIsMemberOfClass(a1, ClassID)))
      {
        a1 = 0;
      }
      v9 = v13;
      v8 = cf;
      v10 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 24)
                                                                   + 136);
      if (v10)
      {
        v4 = v10(a1, v8, v9);
        goto LABEL_10;
      }
      v11 = 4294954514;
    }
    else
    {
      v11 = 4294950570;
    }
  }
  else
  {
    v11 = 4294950576;
  }
LABEL_13:
  if (cf)
    CFRelease(cf);
  if (v13)
    CFRelease(v13);
  return v11;
}

uint64_t HandleEndpointCopyMessengerMessage(uint64_t a1, _xpc_connection_s *a2, void *a3)
{
  const __CFAllocator *v6;
  CFStringRef v7;
  uint64_t (*v8)(uint64_t, CFStringRef, const __CFAllocator *, CFTypeRef *);
  uint64_t v9;
  CFTypeRef v10;
  uint64_t v11;
  CFNumberRef v12;
  uint64_t v13;
  uint64_t v15;
  CFTypeRef cf;

  cf = 0;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], "Messenger", 0x8000100u);
  v8 = *(uint64_t (**)(uint64_t, CFStringRef, const __CFAllocator *, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 8)
                                                                                          + 48);
  if (!v8)
  {
    v10 = 0;
    v13 = 4294954514;
    if (!v7)
      goto LABEL_12;
LABEL_11:
    CFRelease(v7);
    goto LABEL_12;
  }
  v9 = v8(a1, v7, v6, &cf);
  if (!(_DWORD)v9)
  {
    v10 = cf;
    cf = 0;
    if (v10)
    {
      v15 = 0;
      v11 = FigXPCEndpointMessengerServerAssociateNeighborFigEndpointMessenger(a2, v10, &v15);
      if ((_DWORD)v11)
        goto LABEL_10;
      v12 = CFNumberCreate(v6, kCFNumberSInt64Type, &v15);
      cf = v12;
    }
    else
    {
      v12 = 0;
    }
    v11 = FigXPCMessageSetCFObject(a3, ".Value", v12);
LABEL_10:
    v13 = v11;
    if (!v7)
      goto LABEL_12;
    goto LABEL_11;
  }
  v13 = v9;
  v10 = 0;
  if (v7)
    goto LABEL_11;
LABEL_12:
  if (v10)
    CFRelease(v10);
  if (cf)
    CFRelease(cf);
  return v13;
}

uint64_t HandleEndpointCopySubEndpointsMessage(uint64_t a1, _xpc_connection_s *a2, void *a3, uint64_t a4)
{
  uint64_t CMBaseObject;
  uint64_t (*v8)(uint64_t, const __CFString *, _QWORD, CFTypeRef *);
  uint64_t v9;
  uint64_t v10;
  xpc_object_t v12;
  xpc_object_t value;
  CFTypeRef cf;

  value = 0;
  cf = 0;
  v12 = 0;
  if (a4)
  {
    CMBaseObject = FigEndpointGetCMBaseObject(a1);
    v8 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                                + 8)
                                                                                    + 48);
    if (v8)
    {
      v9 = v8(CMBaseObject, CFSTR("Endpoints"), *MEMORY[0x1E0C9AE00], &cf);
      if ((_DWORD)v9
        || (v9 = FigEndpointRPCCacheComputeCacheDeltas(*(_QWORD *)(a4 + 24), a2, (CFArrayRef)cf, &value, &v12),
            (_DWORD)v9))
      {
        v10 = v9;
      }
      else
      {
        if (value)
          xpc_dictionary_set_value(a3, "AddedSubEndpoints", value);
        if (v12)
          xpc_dictionary_set_value(a3, "SubtractedSubEndpoints", v12);
        v10 = 0;
      }
    }
    else
    {
      v10 = 4294954514;
    }
  }
  else
  {
    v10 = 4294954513;
  }
  FigXPCRelease(value);
  FigXPCRelease(v12);
  if (cf)
    CFRelease(cf);
  return v10;
}

uint64_t HandleEndpointAddRemoveEndpointMessage(char *a1, int a2, _xpc_connection_s *a3, void *a4)
{
  _QWORD *ClassID;
  uint64_t v9;
  uint64_t uint64;
  _QWORD *CompletionCallbackParametersFromMessageAndConnection_1;
  CFTypeRef v12;
  CFTypeRef v13;
  uint64_t v14;
  uint64_t (*v15)(char *, CFTypeRef, CFTypeRef, void (*)(uint64_t, uint64_t, uint64_t, uint64_t, int, uint64_t), _QWORD *);
  void (*v16)(uint64_t, uint64_t, uint64_t, uint64_t, int, uint64_t);
  uint64_t v17;
  CFTypeRef v19;
  CFTypeRef cf;

  v19 = 0;
  cf = 0;
  if (!a1)
    return 4294950576;
  ClassID = (_QWORD *)FigEndpointAggregateGetClassID();
  if (!CMBaseObjectIsMemberOfClass(a1, ClassID))
  {
    v17 = 4294950576;
    goto LABEL_16;
  }
  v9 = FigXPCMessageCopyCFDictionary(a4, "AggregateOptions", &cf);
  if (!(_DWORD)v9)
  {
    uint64 = xpc_dictionary_get_uint64(a4, "SubEndpointObjectID");
    v9 = LookupEndpointByObjectIDForConnection(a3, uint64, &v19, 0);
    if (!(_DWORD)v9)
    {
      CompletionCallbackParametersFromMessageAndConnection_1 = CreateCompletionCallbackParametersFromMessageAndConnection_1(a4, a3);
      v12 = v19;
      v13 = cf;
      v14 = *(_QWORD *)(CMBaseObjectGetVTable((uint64_t)a1) + 32);
      if (a2)
      {
        v15 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef, void (*)(uint64_t, uint64_t, uint64_t, uint64_t, int, uint64_t), _QWORD *))(v14 + 8);
        if (v15)
        {
LABEL_7:
          if (CompletionCallbackParametersFromMessageAndConnection_1)
            v16 = AggregateEndpointAddRemoveEndpointCallback;
          else
            v16 = 0;
          v9 = v15(a1, v12, v13, v16, CompletionCallbackParametersFromMessageAndConnection_1);
          goto LABEL_11;
        }
      }
      else
      {
        v15 = *(uint64_t (**)(char *, CFTypeRef, CFTypeRef, void (*)(uint64_t, uint64_t, uint64_t, uint64_t, int, uint64_t), _QWORD *))(v14 + 16);
        if (v15)
          goto LABEL_7;
      }
      v17 = 4294954514;
      goto LABEL_16;
    }
  }
LABEL_11:
  v17 = v9;
LABEL_16:
  if (cf)
    CFRelease(cf);
  if (v19)
    CFRelease(v19);
  return v17;
}

uint64_t HandleEndpointCopyEndpointForAnotherProcess(const void *a1, xpc_object_t xdict, void *a3)
{
  int int64;
  _QWORD *EndpointRefCon;
  uint64_t v7;
  uint64_t value;

  value = 0;
  int64 = xpc_dictionary_get_int64(xdict, "OtherProcessPID");
  if (!int64)
  {
    v7 = FigSignalErrorAt(4294950576, 0, 0, 0, 0, 0, 0);
    goto LABEL_4;
  }
  EndpointRefCon = CreateEndpointRefCon(a1);
  v7 = FigXPCServerAssociateCopiedObjectWithNeighborProcessByPID(gEndpointServer, int64, a1, (uint64_t)EndpointRefCon, (uint64_t)DisposeEndpointRefCon, 0, &value);
  if (!(_DWORD)v7)
  {
    xpc_dictionary_set_uint64(a3, ".objectID", value);
LABEL_4:
    EndpointRefCon = 0;
  }
  DisposeEndpointRefCon((uint64_t)EndpointRefCon);
  return v7;
}

uint64_t CreateDelegateCallbackParameters(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t Instance;
  uint64_t v7;

  if (delegateCallbackParameters_GetTypeID_sRegisterDelegateCallbackParametersTypeOnce != -1)
    dispatch_once(&delegateCallbackParameters_GetTypeID_sRegisterDelegateCallbackParametersTypeOnce, &__block_literal_global_57);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
  v7 = Instance;
  *(_QWORD *)(Instance + 16) = a1;
  *(_QWORD *)(Instance + 24) = FigXPCRetain(a2);
  *a3 = v7;
  return 0;
}

void SendDidReceiveDataFromCommChannelCallback(uint64_t a1, uint64_t a2, const void *a3, const void *a4, uint64_t a5)
{
  int v9;
  xpc_object_t v10;
  xpc_object_t xdict;

  xdict = 0;
  if (a5)
  {
    v9 = FigXPCCreateBasicMessage(0x72636463u, *(_QWORD *)(a5 + 16), &xdict);
    v10 = xdict;
    if (!v9)
    {
      FigXPCMessageSetCFString(xdict, "CommChannelUUID", a3);
      xpc_dictionary_set_uint64(xdict, "ActivationSeed", a2);
      FigXPCMessageSetCFString(xdict, "DelegateFunctionType", CFSTR("hrcd"));
      FigXPCMessageSetCFData(xdict, "Data", a4);
      xpc_connection_send_message(*(xpc_connection_t *)(a5 + 24), xdict);
      v10 = xdict;
    }
  }
  else
  {
    v10 = 0;
  }
  FigXPCRelease(v10);
}

void SendDidCloseCommChannelCallback(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  int v7;
  xpc_object_t v8;
  xpc_object_t xdict;

  xdict = 0;
  if (a4)
  {
    v7 = FigXPCCreateBasicMessage(0x72636463u, *(_QWORD *)(a4 + 16), &xdict);
    v8 = xdict;
    if (!v7)
    {
      FigXPCMessageSetCFString(xdict, "CommChannelUUID", a3);
      xpc_dictionary_set_uint64(xdict, "ActivationSeed", a2);
      FigXPCMessageSetCFString(xdict, "DelegateFunctionType", CFSTR("hrcc"));
      xpc_connection_send_message(*(xpc_connection_t *)(a4 + 24), xdict);
      v8 = xdict;
    }
  }
  else
  {
    v8 = 0;
  }
  FigXPCRelease(v8);
}

void delegateCallbackParameters_Finalize(uint64_t a1)
{
  void *v1;

  *(_QWORD *)(a1 + 16) = 0;
  v1 = *(void **)(a1 + 24);
  if (v1)
  {
    *(_QWORD *)(a1 + 24) = 0;
    xpc_release(v1);
  }
}

__CFString *delegateCallbackParameters_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("DelegateCallbackParameters %p objectID %llx connection %p"), a1, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  return Mutable;
}

void SendHandleAuthRequiredCallback(const void *a1, void *a2, uint64_t a3, uint64_t a4, const void *a5, void (*a6)(const void *, _QWORD, uint64_t, uint64_t), uint64_t a7)
{
  _xpc_connection_s *v14;
  _QWORD handler[8];
  xpc_object_t xdict;

  xdict = 0;
  if (!a4
    || FigXPCCreateBasicMessage(0x72746463u, *(_QWORD *)(a4 + 16), &xdict)
    || a2
    && FigEndpointXPCServerWriteNeighborEndpointToReply(*(_xpc_connection_s **)(a4 + 24), a2, xdict, 0))
  {
    if (a6)
      a6(a1, 0, 4294950568, a7);
  }
  else
  {
    xpc_dictionary_set_uint64(xdict, "ActivationSeed", a3);
    FigXPCMessageSetCFString(xdict, "AuthorizationType", a5);
    FigXPCMessageSetCFString(xdict, "DelegateFunctionType", CFSTR("hrar"));
    CFRetain(a1);
    if (a5)
      CFRetain(a5);
    v14 = *(_xpc_connection_s **)(a4 + 24);
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 0x40000000;
    handler[2] = __SendHandleAuthRequiredCallback_block_invoke;
    handler[3] = &__block_descriptor_tmp_60;
    handler[4] = a6;
    handler[5] = a1;
    handler[6] = a7;
    handler[7] = a5;
    xpc_connection_send_message_with_reply(v14, xdict, 0, handler);
  }
  FigXPCRelease(xdict);
}

void SendHandleFailedCallback(uint64_t a1, uint64_t a2, const __CFDictionary *a3, uint64_t a4)
{
  int v7;
  xpc_object_t v8;
  _xpc_connection_s *v9;
  void *Value;
  __CFDictionary *CopyRemovingKeys;
  int v12;
  int v13;
  xpc_object_t xdict;
  const void *v15[2];

  v15[1] = *(const void **)MEMORY[0x1E0C80C00];
  xdict = 0;
  if (a4)
  {
    v7 = FigXPCCreateBasicMessage(0x72746463u, *(_QWORD *)(a4 + 16), &xdict);
    v8 = xdict;
    if (!v7)
    {
      v9 = *(_xpc_connection_s **)(a4 + 24);
      v15[0] = CFSTR("SubEndpoint");
      if (CFDictionaryContainsKey(a3, CFSTR("SubEndpoint")))
      {
        Value = (void *)CFDictionaryGetValue(a3, CFSTR("SubEndpoint"));
        CopyRemovingKeys = FigCFDictionaryCreateCopyRemovingKeys(a3, v15, 1);
        v12 = FigEndpointXPCServerWriteNeighborEndpointToReply(v9, Value, v8, 0);
        if (!v12)
          v12 = FigXPCMessageSetCFDictionary(v8, "FailureInfo", CopyRemovingKeys);
        v13 = v12;
        if (CopyRemovingKeys)
          CFRelease(CopyRemovingKeys);
      }
      else
      {
        v13 = FigXPCMessageSetCFDictionary(v8, "FailureInfo", a3);
      }
      v8 = xdict;
      if (!v13)
      {
        xpc_dictionary_set_uint64(xdict, "ActivationSeed", a2);
        FigXPCMessageSetCFString(xdict, "DelegateFunctionType", CFSTR("hrtf"));
        xpc_connection_send_message(*(xpc_connection_t *)(a4 + 24), xdict);
        v8 = xdict;
      }
    }
  }
  else
  {
    v8 = 0;
  }
  FigXPCRelease(v8);
}

_QWORD *CreateCompletionCallbackParametersFromMessageAndConnection_1(void *a1, void *a2)
{
  uint64_t uint64;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;

  uint64 = xpc_dictionary_get_uint64(a1, "CompletionID");
  if (!uint64)
    return 0;
  v5 = uint64;
  v6 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
  v7 = v6;
  if (v6)
  {
    *v6 = v5;
    v6[1] = xpc_dictionary_get_uint64(a1, ".objectID");
    v7[2] = FigXPCRetain(a2);
  }
  else
  {
    FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
  }
  return v7;
}

void SendCommandCompletionCallback(uint64_t a1, int a2, const void *a3, uint64_t a4)
{
  xpc_object_t xdict;

  xdict = 0;
  if (a4 && !FigXPCCreateBasicMessage(0x63616C62u, *(_QWORD *)(a4 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(_QWORD *)a4);
    FigXPCMessageSetCFDictionary(xdict, "SendCommandResponse", a3);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a2);
    xpc_connection_send_message(*(xpc_connection_t *)(a4 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a4);
  FigXPCRelease(xdict);
}

void SendDataCompletionCallback(uint64_t a1, const void *a2, int a3, uint64_t a4)
{
  xpc_object_t xdict;

  xdict = 0;
  if (a4 && !FigXPCCreateBasicMessage(0x63616C62u, *(_QWORD *)(a4 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(_QWORD *)a4);
    FigXPCMessageSetCFString(xdict, "CommChannelUUID", a2);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a3);
    xpc_connection_send_message(*(xpc_connection_t *)(a4 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a4);
  FigXPCRelease(xdict);
}

void ActivationCompletionCallback(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  xpc_object_t xdict;

  xdict = 0;
  if (a5 && !FigXPCCreateBasicMessage(0x63616C62u, *(_QWORD *)(a5 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "ActivationFeatures", a2);
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(_QWORD *)a5);
    xpc_dictionary_set_uint64(xdict, "ActivationSeed", a3);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a4);
    xpc_connection_send_message(*(xpc_connection_t *)(a5 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a5);
  FigXPCRelease(xdict);
}

void AggregateEndpointAddRemoveEndpointCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  xpc_object_t xdict;

  xdict = 0;
  if (a6 && !FigXPCCreateBasicMessage(0x63616C62u, *(_QWORD *)(a6 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "ActivationFeatures", a3);
    xpc_dictionary_set_uint64(xdict, "ActivationSeed", a4);
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(_QWORD *)a6);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a5);
    xpc_connection_send_message(*(xpc_connection_t *)(a6 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a6);
  FigXPCRelease(xdict);
}

_QWORD *CreateEndpointRefCon(const void *a1)
{
  _QWORD *v2;
  CFTypeRef v3;
  void *v5;

  v5 = 0;
  if (FigEndpointRPCCacheCreate(&v5, 1))
  {
    v2 = 0;
  }
  else
  {
    v2 = malloc_type_calloc(1uLL, 0x20uLL, 0x20040DC1BFBCFuLL);
    if (v2)
    {
      if (a1)
        v3 = CFRetain(a1);
      else
        v3 = 0;
      *v2 = v3;
      v2[3] = v5;
      v5 = 0;
    }
    else
    {
      FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
    }
  }
  FigEndpointRPCCacheDispose(v5);
  return v2;
}

void DisposeEndpointRefCon(uint64_t a1)
{
  uint64_t v2;
  void (*v3)(uint64_t, _QWORD);
  const void *v4;
  uint64_t v5;
  void (*v6)(uint64_t, _QWORD);
  const void *v7;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 16))
    {
      v2 = *(_QWORD *)a1;
      v3 = *(void (**)(uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(*(_QWORD *)a1) + 16) + 56);
      if (v3)
        v3(v2, 0);
      v4 = *(const void **)(a1 + 16);
      if (v4)
      {
        CFRelease(v4);
        *(_QWORD *)(a1 + 16) = 0;
      }
    }
    if (*(_QWORD *)(a1 + 8))
    {
      v5 = *(_QWORD *)a1;
      v6 = *(void (**)(uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(*(_QWORD *)a1) + 16) + 48);
      if (v6)
        v6(v5, 0);
      v7 = *(const void **)(a1 + 8);
      if (v7)
      {
        CFRelease(v7);
        *(_QWORD *)(a1 + 8) = 0;
      }
    }
    if (*(_QWORD *)a1)
    {
      CFRelease(*(CFTypeRef *)a1);
      *(_QWORD *)a1 = 0;
    }
    FigEndpointRPCCacheDispose(*(_QWORD **)(a1 + 24));
    free((void *)a1);
  }
}

uint64_t figEndpointXPC_getObjectIDForSource(xpc_connection_t connection, const void *a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *EndpointRefCon;
  uint64_t v8;
  uint64_t v9;
  pid_t pid;
  uint64_t v11;
  uint64_t v13;

  v13 = 0;
  if ((a3 & 0xFFFFFFFFFFFFCFFFLL) != gServerSource)
  {
    pid = xpc_connection_get_pid(connection);
    v11 = FigEndpointXPCRemoteObtainObjectIDForOtherProcess((uint64_t)a2, pid, &v13);
    if ((_DWORD)v11)
    {
      v9 = v11;
      EndpointRefCon = 0;
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  EndpointRefCon = CreateEndpointRefCon(a2);
  v8 = FigXPCServerAssociateCopiedObjectWithNeighborProcess(gEndpointServer, connection, a2, (uint64_t)EndpointRefCon, (uint64_t)DisposeEndpointRefCon, 0, &v13);
  if (!(_DWORD)v8)
  {
LABEL_5:
    v9 = 0;
    EndpointRefCon = 0;
    *a4 = v13;
    goto LABEL_6;
  }
  v9 = v8;
LABEL_6:
  DisposeEndpointRefCon((uint64_t)EndpointRefCon);
  return v9;
}

uint64_t FigNetworkHistoryObserverGetClassID()
{
  FigThreadRunOnce(&FigNetworkHistoryObserverGetClassID_sRegisterFigNetworkHistoryObserverTypeOnce, (void (*)(void))RegisterFigNetworkHistoryObserverType);
  return sFigNetworkHistoryObserverClassID;
}

uint64_t RegisterFigNetworkHistoryObserverType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigNetworkHistoryObserverClassDesc, ClassID, 1, &sFigNetworkHistoryObserverClassID);
}

uint64_t FigNetworkHistoryObserverGetCFTypeID()
{
  FigThreadRunOnce(&FigNetworkHistoryObserverGetClassID_sRegisterFigNetworkHistoryObserverTypeOnce, (void (*)(void))RegisterFigNetworkHistoryObserverType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigNetworkHistoryObserverClassID);
}

uint64_t FigNetworkHistoryObserverCreate(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  uint64_t v12;
  uint64_t DerivedStorage;
  CFTypeRef v14;
  uint64_t v15;
  CFMutableSetRef Mutable;
  CFTypeRef v17;
  unint64_t *v18;
  void (*v19)(CFTypeRef, const __CFString *, uint64_t, uint64_t);
  pthread_mutex_t *v20;
  dispatch_queue_t v21;
  dispatch_queue_t v22;
  dispatch_source_t v23;
  void *v24;
  _BOOL4 v25;
  __CFNotificationCenter *DefaultLocalCenter;
  __CFNotificationCenter *v27;
  uint64_t v29;
  CFTypeRef cf;

  cf = 0;
  if (a6)
  {
    if (a5 && a2 && a4)
    {
      FigThreadRunOnce(&FigNetworkHistoryObserverGetClassID_sRegisterFigNetworkHistoryObserverTypeOnce, (void (*)(void))RegisterFigNetworkHistoryObserverType);
      v12 = CMDerivedObjectCreate(a1, (uint64_t)&kFigNetworkHistoryObserverVTable, (_QWORD *)sFigNetworkHistoryObserverClassID, &cf);
      if (!cf)
        goto LABEL_21;
      DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
      *(_QWORD *)(DerivedStorage + 48) = a5;
      *(_QWORD *)(DerivedStorage + 32) = a3;
      v14 = FigCFWeakReferenceHolderCreateWithReferencedObject(a4);
      *(_QWORD *)(DerivedStorage + 40) = v14;
      if (!v14)
        goto LABEL_21;
      v15 = *MEMORY[0x1E0C9AE00];
      Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &kFigNetworkHistoryCondition_CompletionCallbackEntrySetCallbacks);
      *(_QWORD *)(DerivedStorage + 72) = Mutable;
      if (!Mutable)
        goto LABEL_21;
      v17 = CFRetain(a2);
      *(_QWORD *)(DerivedStorage + 64) = v17;
      v18 = (unint64_t *)(DerivedStorage + 56);
      v19 = *(void (**)(CFTypeRef, const __CFString *, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v17)
                                                                                               + 8)
                                                                                   + 48);
      if (v19)
        v19(v17, CFSTR("NetworkPredictorProperty_History"), v15, DerivedStorage + 56);
      if (*v18)
      {
        v20 = FigSimpleMutexCreate();
        *(_QWORD *)DerivedStorage = v20;
        if (v20)
        {
          v21 = FigDispatchQueueCreateWithPriority("com.apple.coremedia.networkhisotryobserver.timer", 0, 0);
          *(_QWORD *)(DerivedStorage + 16) = v21;
          if (v21)
          {
            v22 = FigDispatchQueueCreateWithPriority("com.apple.coremedia.networkhisotryobserver.callback", 0, 0);
            *(_QWORD *)(DerivedStorage + 24) = v22;
            if (v22)
            {
              v23 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(DerivedStorage + 16));
              *(_QWORD *)(DerivedStorage + 8) = v23;
              if (v23)
              {
                v24 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)cf);
                if (v24)
                {
                  dispatch_set_context(*(dispatch_object_t *)(DerivedStorage + 8), v24);
                  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(DerivedStorage + 8), (dispatch_function_t)fnho_callbacktimerProc);
                  dispatch_set_finalizer_f(*(dispatch_object_t *)(DerivedStorage + 8), (dispatch_function_t)FigCFRelease_0);
                  dispatch_resume(*(dispatch_object_t *)(DerivedStorage + 8));
                  v25 = FigNetworkHistoryAreAnyRequestsActive(*(_QWORD *)(DerivedStorage + 56));
                  *(_BYTE *)(DerivedStorage + 81) = v25;
                  if (v25)
                  {
                    fnho_ensureTimerIsScheduled((uint64_t)cf);
                  }
                  else
                  {
                    *(_BYTE *)(DerivedStorage + 80) = 1;
                    fnho_ensureTimerIsPaused((uint64_t)cf);
                  }
                  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
                  FigNotificationCenterAddWeakListener(DefaultLocalCenter, (void *)cf, (CFNotificationCallback)fnho_networkHistoryBecameActiveHandler, CFSTR("NetworkHistoryNotification_NetworkBecameActive"), *v18, 0, 0);
                  v27 = CMNotificationCenterGetDefaultLocalCenter();
                  FigNotificationCenterAddWeakListener(v27, (void *)cf, (CFNotificationCallback)fnho_networkHistoryBecameInactiveHandler, CFSTR("NetworkHistoryNotification_NetworkBecameInactive"), *v18, 0, 0);
                  *a6 = cf;
                  return v12;
                }
                v29 = 4294951335;
LABEL_23:
                v12 = FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
                if (cf)
                  CFRelease(cf);
                return v12;
              }
            }
          }
        }
LABEL_21:
        v29 = 4294951335;
        goto LABEL_23;
      }
    }
    v29 = 4294951336;
    goto LABEL_23;
  }
  return FigSignalErrorAt(4294951336, 0, 0, 0, 0, 0, 0);
}

void fnho_callbacktimerProc(id *a1)
{
  id *v1;
  id *v2;
  uint64_t DerivedStorage;

  v1 = FigCFWeakReferenceHolderCopyReferencedObject(a1);
  if (v1)
  {
    v2 = v1;
    DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)v1);
    FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
    CFSetApplyFunction(*(CFSetRef *)(DerivedStorage + 72), (CFSetApplierFunction)fnho_conditionApplier, v2);
    if (!*(_BYTE *)(DerivedStorage + 81))
      fnho_ensureTimerIsPaused((uint64_t)v2);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
    CFRelease(v2);
  }
}

void FigCFRelease_0(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void fnho_ensureTimerIsScheduled(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v2;
  NSObject *v3;
  dispatch_time_t v4;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!*(_BYTE *)(DerivedStorage + 80))
  {
    v2 = DerivedStorage;
    *(_BYTE *)(DerivedStorage + 80) = 1;
    v3 = *(NSObject **)(DerivedStorage + 8);
    v4 = dispatch_time(0, *(_QWORD *)(DerivedStorage + 32));
    dispatch_source_set_timer(v3, v4, *(_QWORD *)(v2 + 32), 0xEE6B280uLL);
  }
}

void fnho_ensureTimerIsPaused(uint64_t a1)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)(DerivedStorage + 80))
  {
    *(_BYTE *)(DerivedStorage + 80) = 0;
    dispatch_source_set_timer(*(dispatch_source_t *)(DerivedStorage + 8), 0xFFFFFFFFFFFFFFFFLL, 0, 0);
  }
}

pthread_mutex_t **fnho_networkHistoryBecameActiveHandler(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t **result;
  pthread_mutex_t **v4;

  result = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a2);
  if (a2)
  {
    v4 = result;
    FigSimpleMutexLock(*result);
    fnho_ensureTimerIsScheduled(a2);
    *((_BYTE *)v4 + 81) = 1;
    return (pthread_mutex_t **)FigSimpleMutexUnlock(*v4);
  }
  return result;
}

pthread_mutex_t **fnho_networkHistoryBecameInactiveHandler(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t **result;
  pthread_mutex_t **v4;

  result = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a2);
  if (a2)
  {
    v4 = result;
    FigSimpleMutexLock(*result);
    *((_BYTE *)v4 + 81) = 0;
    return (pthread_mutex_t **)FigSimpleMutexUnlock(*v4);
  }
  return result;
}

uint64_t FigNetworkHistoryObserverAddCondition(uint64_t a1, __int128 *a2, _QWORD *a3)
{
  uint64_t DerivedStorage;
  uint64_t v6;
  const __CFAllocator *v7;
  _OWORD *v8;
  const void *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v22;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (a3)
  {
    v6 = DerivedStorage;
    v7 = CFGetAllocator(*(CFTypeRef *)(DerivedStorage + 72));
    v8 = CFAllocatorAllocate(v7, 240, 0);
    if (v8)
    {
      v9 = v8;
      v10 = *a2;
      v11 = a2[2];
      v8[1] = a2[1];
      v8[2] = v11;
      *v8 = v10;
      v12 = a2[3];
      v13 = a2[4];
      v14 = a2[6];
      v8[5] = a2[5];
      v8[6] = v14;
      v8[3] = v12;
      v8[4] = v13;
      v15 = a2[7];
      v16 = a2[8];
      v17 = a2[10];
      v8[9] = a2[9];
      v8[10] = v17;
      v8[7] = v15;
      v8[8] = v16;
      v18 = a2[11];
      v19 = a2[12];
      v20 = a2[14];
      v8[13] = a2[13];
      v8[14] = v20;
      v8[11] = v18;
      v8[12] = v19;
      FigSimpleMutexLock(*(pthread_mutex_t **)v6);
      CFSetSetValue(*(CFMutableSetRef *)(v6 + 72), v9);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)v6);
      *a3 = v9;
      return 0;
    }
    v22 = 4294951335;
  }
  else
  {
    v22 = 4294951336;
  }
  return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
}

uint64_t FigNetworkHistoryObserverRemoveCondition(uint64_t a1, const void *a2)
{
  pthread_mutex_t **DerivedStorage;
  pthread_mutex_t **v4;

  DerivedStorage = (pthread_mutex_t **)CMBaseObjectGetDerivedStorage(a1);
  if (a2)
  {
    v4 = DerivedStorage;
    FigSimpleMutexLock(*DerivedStorage);
    CFSetRemoveValue((CFMutableSetRef)v4[9], a2);
    FigSimpleMutexUnlock(*v4);
  }
  return 0;
}

BOOL FigNetworkHistoryObserverTestCondition(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage;
  _BOOL8 v5;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  if (CFSetContainsValue(*(CFSetRef *)(DerivedStorage + 72), a2))
    v5 = fnho_testCondition(a1, (uint64_t)a2, 0);
  else
    v5 = 0;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return v5;
}

BOOL fnho_testCondition(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  unint64_t UpTimeNanoseconds;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  unsigned int (*v14)(uint64_t, unint64_t, _OWORD *, __int128 *);
  CFNumberRef v15;
  CFNumberRef v16;
  int v17;
  _BOOL8 v18;
  CFTypeRef v19;
  uint64_t valuePtr;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  _OWORD v42[14];

  valuePtr = 0;
  v41 = 0;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v36 = 0u;
  v5 = *(_QWORD *)(CMBaseObjectGetDerivedStorage(a1) + 64);
  UpTimeNanoseconds = FigGetUpTimeNanoseconds();
  v7 = *(_OWORD *)(a2 + 192);
  v32 = *(_OWORD *)(a2 + 176);
  v33 = v7;
  v8 = *(_OWORD *)(a2 + 224);
  v34 = *(_OWORD *)(a2 + 208);
  v35 = v8;
  v9 = *(_OWORD *)(a2 + 128);
  v28 = *(_OWORD *)(a2 + 112);
  v29 = v9;
  v10 = *(_OWORD *)(a2 + 160);
  v30 = *(_OWORD *)(a2 + 144);
  v31 = v10;
  v11 = *(_OWORD *)(a2 + 64);
  v24 = *(_OWORD *)(a2 + 48);
  v25 = v11;
  v12 = *(_OWORD *)(a2 + 96);
  v26 = *(_OWORD *)(a2 + 80);
  v27 = v12;
  v13 = *(_OWORD *)(a2 + 32);
  v22 = *(_OWORD *)(a2 + 16);
  v23 = v13;
  v14 = *(unsigned int (**)(uint64_t, unint64_t, _OWORD *, __int128 *))(*(_QWORD *)(CMBaseObjectGetVTable(v5) + 16)
                                                                                       + 8);
  if (!v14)
    goto LABEL_8;
  v42[10] = v32;
  v42[11] = v33;
  v42[12] = v34;
  v42[13] = v35;
  v42[6] = v28;
  v42[7] = v29;
  v42[8] = v30;
  v42[9] = v31;
  v42[2] = v24;
  v42[3] = v25;
  v42[4] = v26;
  v42[5] = v27;
  v42[0] = v22;
  v42[1] = v23;
  if (v14(v5, UpTimeNanoseconds, v42, &v36)
    || (valuePtr = (uint64_t)(*((double *)&v37 + 1) * (double)(uint64_t)v36),
        (v15 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr)) == 0))
  {
LABEL_8:
    v18 = 0;
    if (!a3)
      return v18;
    v16 = 0;
    v19 = 0;
    goto LABEL_14;
  }
  v16 = v15;
  v17 = *(_DWORD *)(a2 + 8);
  if (v17 != 6)
  {
    if (v17 == 5)
    {
      *(_QWORD *)&v42[0] = 0;
      CFNumberGetValue(*(CFNumberRef *)a2, kCFNumberSInt64Type, v42);
      v18 = valuePtr >= *(_QWORD *)&v42[0];
      if (!a3)
        goto LABEL_15;
    }
    else
    {
      FigSignalErrorAt(4294951336, 0, 0, 0, 0, 0, 0);
      v18 = 0;
      if (!a3)
        goto LABEL_15;
    }
    goto LABEL_13;
  }
  *(_QWORD *)&v42[0] = 0;
  CFNumberGetValue(*(CFNumberRef *)a2, kCFNumberSInt64Type, v42);
  v18 = valuePtr <= *(_QWORD *)&v42[0];
  if (a3)
  {
LABEL_13:
    v19 = CFRetain(v16);
LABEL_14:
    *a3 = v19;
  }
LABEL_15:
  if (v16)
    CFRelease(v16);
  return v18;
}

CFStringRef FigNetworkHistoryObserverCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigNetworkHistoryObserver <%p>]"), a1);
}

const __CFAllocator *fnho_finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  dispatch_source_cancel(*(dispatch_source_t *)(DerivedStorage + 8));
  v2 = *(NSObject **)(DerivedStorage + 8);
  if (v2)
    dispatch_release(v2);
  v3 = *(NSObject **)(DerivedStorage + 16);
  if (v3)
    dispatch_release(v3);
  v4 = *(NSObject **)(DerivedStorage + 24);
  if (v4)
    dispatch_release(v4);
  v5 = *(const void **)(DerivedStorage + 72);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(DerivedStorage + 40);
  if (v6)
    CFRelease(v6);
  v7 = *(const void **)(DerivedStorage + 56);
  if (v7)
    CFRelease(v7);
  v8 = *(const void **)(DerivedStorage + 64);
  if (v8)
    CFRelease(v8);
  return FigSimpleMutexDestroy(*(_QWORD *)DerivedStorage);
}

CFStringRef fnho_copyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage;
  CFIndex Count;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigSimpleMutexLock(*(pthread_mutex_t **)DerivedStorage);
  Count = CFSetGetCount(*(CFSetRef *)(DerivedStorage + 72));
  FigSimpleMutexUnlock(*(pthread_mutex_t **)DerivedStorage);
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigNetworkHistoryObserver <%p> timeInterval=%lld total condition=%ld]"), a1, *(_QWORD *)(DerivedStorage + 32), Count);
}

CFTypeRef *fnho_networkConditionRetainCallback(uint64_t a1, CFTypeRef *a2)
{
  if (a2 && *a2)
    CFRetain(*a2);
  return a2;
}

void fnho_networkConditionReleaseCallback(CFAllocatorRef allocator, CFTypeRef *ptr)
{
  if (*ptr)
    CFRelease(*ptr);
  CFAllocatorDeallocate(allocator, ptr);
}

void fnho_conditionApplier(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  CFTypeRef v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  CFTypeRef v10;
  CFTypeRef v11;
  CFTypeRef cf;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a2);
  cf = 0;
  if (fnho_testCondition((uint64_t)a2, a1, &cf))
  {
    v5 = *(_QWORD *)(DerivedStorage + 48);
    v6 = cf;
    v7 = CMBaseObjectGetDerivedStorage((uint64_t)a2);
    v8 = malloc_type_calloc(1uLL, 0x20uLL, 0x10E0040018299E6uLL);
    if (v8)
    {
      v9 = v8;
      *v8 = v5;
      if (a2)
        v10 = CFRetain(a2);
      else
        v10 = 0;
      v9[1] = v10;
      v9[2] = a1;
      if (v6)
        v11 = CFRetain(v6);
      else
        v11 = 0;
      v9[3] = v11;
      dispatch_async_f(*(dispatch_queue_t *)(v7 + 24), v9, (dispatch_function_t)fnho_dispatchObserverConditionFn);
    }
  }
  if (cf)
    CFRelease(cf);
}

void fnho_dispatchObserverConditionFn(_QWORD *a1)
{
  uint64_t DerivedStorage;
  const void *v3;
  const void *v4;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1[1]);
  ((void (*)(_QWORD, _QWORD, _QWORD, _QWORD))*a1)(a1[1], *(_QWORD *)(DerivedStorage + 40), a1[2], a1[3]);
  v3 = (const void *)a1[1];
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[3];
  if (v4)
    CFRelease(v4);
  free(a1);
}

uint64_t FigMetricEventTimelineClientServerXPC_SerializeEvent(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t (*v5)(uint64_t);
  int v6;
  uint64_t (*v7)(uint64_t);
  int64_t v8;
  void (*v9)(uint64_t, void *);

  if (!a3)
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  v5 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(a3) + 16) + 72);
  if (v5)
    v6 = v5(a3);
  else
    v6 = 0;
  v7 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(a3) + 16) + 24);
  if (v7)
    v8 = v7(a3);
  else
    v8 = -12782;
  xpc_dictionary_set_int64(a1, "EventID", v8);
  xpc_dictionary_set_BOOL(a1, "MockEvent", v6 != 0);
  if (!v6)
  {
    v9 = *(void (**)(uint64_t, void *))(*(_QWORD *)(CMBaseObjectGetVTable(a3) + 16) + 80);
    if (v9)
      v9(a3, a1);
  }
  return 0;
}

uint64_t FigMetricEventTimelineClientServerXPC_DeserializeAndCopyEvent(void *a1, CFTypeRef *a2)
{
  int64_t int64;
  uint64_t AllocatorForMedia;
  uint64_t v6;
  uint64_t v7;
  CFTypeRef cf;

  cf = 0;
  if (a2)
  {
    int64 = xpc_dictionary_get_int64(a1, "EventID");
    if (xpc_dictionary_get_BOOL(a1, "MockEvent"))
    {
      AllocatorForMedia = FigGetAllocatorForMedia();
      v6 = FigMetricMockEventForTestCreate(AllocatorForMedia, int64, &cf);
      if ((_DWORD)v6)
        goto LABEL_4;
    }
    else
    {
      v6 = FigMetricEventDeserializeEvent(a1, &cf);
      if ((_DWORD)v6)
      {
LABEL_4:
        v7 = v6;
        if (cf)
          CFRelease(cf);
        return v7;
      }
    }
    v7 = 0;
    *a2 = cf;
    return v7;
  }
  return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
}

pthread_mutex_t *FigNotificationCenterSupportInitOnce()
{
  pthread_mutex_t *result;

  sFigNotificationCenterLocks_0 = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0);
  result = FigSimpleMutexCreate();
  sFigNotificationCenterLocks_1 = (uint64_t)result;
  return result;
}

uint64_t FigNotificationCenterSupportWillPostNotification(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  const void *Value;
  BOOL v6;

  result = FigSimpleMutexLock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
  if (!(_DWORD)result)
  {
    Value = CFDictionaryGetValue((CFDictionaryRef)sFigNotificationCenterLocks_0, (const void *)-a3);
    result = FigSimpleMutexUnlock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
    if ((_DWORD)result)
      v6 = 1;
    else
      v6 = Value == 0;
    if (!v6)
      return FigReadWriteLockLockForRead((uint64_t)Value);
  }
  return result;
}

uint64_t FigNotificationCenterSupportDidPostNotification(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const void *Value;
  BOOL v5;

  if (!FigSimpleMutexLock((pthread_mutex_t *)sFigNotificationCenterLocks_1))
  {
    Value = CFDictionaryGetValue((CFDictionaryRef)sFigNotificationCenterLocks_0, (const void *)-a3);
    if (FigSimpleMutexUnlock((pthread_mutex_t *)sFigNotificationCenterLocks_1))
      v5 = 1;
    else
      v5 = Value == 0;
    if (!v5)
      FigReadWriteLockUnlockForRead((uint64_t)Value);
  }
  return 0;
}

uint64_t CMNotificationCenterRegisterForBarrierSupport(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t **v3;
  pthread_mutex_t **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v3 = FigReadWriteLockCreate(0);
  if (!v3)
    return FigSignalErrorAt(4294954570, 0, 0, 0, 0, 0, 0);
  v4 = v3;
  v5 = FigSimpleMutexLock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
  if ((_DWORD)v5)
    return v5;
  v6 = -a2;
  if (!CFDictionaryContainsKey((CFDictionaryRef)sFigNotificationCenterLocks_0, (const void *)v6))
  {
    CFDictionarySetValue((CFMutableDictionaryRef)sFigNotificationCenterLocks_0, (const void *)v6, v4);
    return FigSimpleMutexUnlock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
  }
  v7 = FigSignalErrorAt(4294954572, 0, 0, 0, 0, 0, 0);
  FigReadWriteLockDestroy((uint64_t *)v4);
  if (!(_DWORD)v7)
    return FigSimpleMutexUnlock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
  FigSimpleMutexUnlock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
  return v7;
}

uint64_t CMNotificationCenterUnregisterForBarrierSupport(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t *Value;
  uint64_t *v6;
  unsigned int v7;
  unsigned int v8;

  result = FigSimpleMutexLock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
  if (!(_DWORD)result)
  {
    v4 = -a2;
    Value = (uint64_t *)CFDictionaryGetValue((CFDictionaryRef)sFigNotificationCenterLocks_0, (const void *)v4);
    if (Value)
    {
      v6 = Value;
      CFDictionaryRemoveValue((CFMutableDictionaryRef)sFigNotificationCenterLocks_0, (const void *)v4);
      v7 = FigReadWriteLockDestroy(v6);
    }
    else
    {
      v7 = FigSignalErrorAt(4294954572, 0, 0, 0, 0, 0, 0);
    }
    v8 = v7;
    LODWORD(result) = FigSimpleMutexUnlock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
    if (v8)
      return v8;
    else
      return result;
  }
  return result;
}

uint64_t CMNotificationCenterBarrier(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  const void *Value;

  result = FigSimpleMutexLock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
  if (!(_DWORD)result)
  {
    Value = CFDictionaryGetValue((CFDictionaryRef)sFigNotificationCenterLocks_0, (const void *)-a2);
    result = FigSimpleMutexUnlock((pthread_mutex_t *)sFigNotificationCenterLocks_1);
    if (!(_DWORD)result)
    {
      if (Value)
      {
        result = FigReadWriteLockLockForWrite((uint64_t)Value);
        if (!(_DWORD)result)
          return FigReadWriteLockUnlockForWrite((uint64_t)Value);
      }
      else
      {
        return FigSignalErrorAt(4294954572, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  return result;
}

uint64_t FigNotificationCenterAddListeners(__CFNotificationCenter *a1, const void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v10;
  const __CFString ***i;
  uint64_t v12;
  uint64_t v13;

  if (!a4)
    return 0;
  v10 = 0;
  for (i = (const __CFString ***)(a3 + 8); ; i += 2)
  {
    v12 = CMNotificationCenterAddListener(a1, a2, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))*(i - 1), **i, (unint64_t)a5);
    if ((_DWORD)v12)
      break;
    if (a4 == ++v10)
      return 0;
  }
  v13 = v12;
  FigNotificationCenterRemoveListeners(a1, a2, a3, v10, a5);
  return v13;
}

uint64_t FigNotificationCenterRemoveListeners(__CFNotificationCenter *a1, const void *a2, uint64_t a3, uint64_t a4, void *object)
{
  uint64_t v6;
  uint64_t v9;
  CFNotificationName **v10;
  unsigned int v11;
  BOOL v12;

  if (!a4)
    return 0;
  v6 = a4;
  LODWORD(v9) = 0;
  v10 = (CFNotificationName **)(a3 + 8);
  do
  {
    v11 = CMNotificationCenterRemoveListener(a1, a2, (int)*(v10 - 1), **v10, object);
    if ((_DWORD)v9)
      v12 = 1;
    else
      v12 = v11 == 0;
    if (v12)
      v9 = v9;
    else
      v9 = v11;
    v10 += 2;
    --v6;
  }
  while (v6);
  return v9;
}

uint64_t FigPowerLogRegisterEvent(const void *a1, const __CFDictionary *a2, int a3)
{
  id v6;
  uint64_t v7;
  CFMutableDictionaryRef MutableCopy;
  CFMutableDictionaryRef v9;
  uint64_t v10;
  _QWORD v12[5];
  _QWORD v13[6];
  int v14;

  v6 = objc_alloc_init(MEMORY[0x1E0CB34A8]);
  v7 = 0;
  if (a1 && a2)
  {
    if (openFrameworkPredicate != -1)
      dispatch_once_f(&openFrameworkPredicate, 0, (dispatch_function_t)figPowerLogOpenFramework);
    v7 = 0;
    if (figPLShouldLogRegisteredEvent && figPLLogRegisteredEvent)
    {
      if (figPLShouldLogRegisteredEvent(28, a1)
        && (MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a2)) != 0)
      {
        v9 = MutableCopy;
        FigCFDictionarySetInt32(MutableCopy, CFSTR("clientPID"), a3);
        v10 = MEMORY[0x1E0C809B0];
        v13[0] = MEMORY[0x1E0C809B0];
        v13[1] = 3221225472;
        v13[2] = __FigPowerLogRegisterEvent_block_invoke;
        v13[3] = &__block_descriptor_52_e5_v8__0l;
        v14 = a3;
        v13[4] = v9;
        v13[5] = a1;
        CFRetain(v9);
        CFRetain(a1);
        if (FigPowerLogRegisterEvent_sCreatePowerLogQueueOnce != -1)
          dispatch_once(&FigPowerLogRegisterEvent_sCreatePowerLogQueueOnce, &__block_literal_global_58);
        v12[0] = v10;
        v12[1] = 3221225472;
        v12[2] = __FigPowerLogRegisterEvent_block_invoke_3;
        v12[3] = &unk_1E28E6C00;
        v12[4] = v13;
        dispatch_async((dispatch_queue_t)sPowerLogProcessingQueue, v12);
        CFRelease(v9);
        v7 = 1;
      }
      else
      {
        v7 = 0;
      }
    }
  }
  objc_msgSend(v6, "drain");
  return v7;
}

void figPowerLogOpenFramework()
{
  void *v0;
  const void *v1;
  BOOL v2;
  uint64_t v3;
  void *v4;
  void *v5;

  v0 = (void *)MGCopyAnswer();
  if (v0)
  {
    v1 = v0;
    v2 = 1;
    if (objc_msgSend(v0, "rangeOfString:options:", CFSTR("AudioAccessory"), 1) != 0x7FFFFFFFFFFFFFFFLL)
      v2 = v3 != objc_msgSend(CFSTR("AudioAccessory"), "length");
    isPowerLogEnabled = v2;
    CFRelease(v1);
  }
  if (isPowerLogEnabled)
  {
    v4 = dlopen("/System/Library/PrivateFrameworks/PowerLog.framework/PowerLog", 4);
    if (v4)
    {
      v5 = v4;
      figPLShouldLogRegisteredEvent = dlsym(v4, "PLShouldLogRegisteredEvent");
      figPLLogRegisteredEvent = dlsym(v5, "PLLogRegisteredEvent");
      figPLLogTimeSensitiveRegisteredEvent = dlsym(v5, "PLLogTimeSensitiveRegisteredEvent");
    }
  }
}

uint64_t FigPlaybackLogPowerEvent(unsigned int a1, unsigned int a2, CFDictionaryRef theDict)
{
  uint64_t v3;
  __CFString *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  const void *v11;
  CFMutableDictionaryRef MutableCopy;
  CFMutableDictionaryRef v13;
  CFTypeID v14;
  uint64_t v16;
  unsigned int v17;

  v3 = 0;
  v17 = 0;
  if (a1 <= 1 && theDict && a2 <= 8)
  {
    v6 = off_1E28E6C20[a2];
    if (a1 == 1)
    {
      v7 = (void *)MEMORY[0x193FFC34C]();
      v16 = 0;
      FigCFDictionaryGetInt32IfPresent((uint64_t)theDict, CFSTR("processID"), &v17);
      v8 = (void *)objc_msgSend(MEMORY[0x1E0D87D60], "handleForIdentifier:error:", objc_msgSend(MEMORY[0x1E0D87D78], "identifierWithPid:", v17, 0), &v16);
      if (v8)
      {
        v9 = v8;
        v10 = (void *)objc_msgSend(v8, "identity");
        v11 = (const void *)objc_msgSend(v10, "embeddedApplicationIdentifier");
        if (!v11)
        {
          v11 = (const void *)objc_msgSend(v10, "xpcServiceIdentifier");
          if (!v11)
            v11 = (const void *)objc_msgSend((id)objc_msgSend(v9, "bundle"), "identifier");
        }
      }
      else
      {
        v11 = 0;
      }
      objc_autoreleasePoolPop(v7);
    }
    else
    {
      v11 = 0;
    }
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, theDict);
    if (MutableCopy)
    {
      v13 = MutableCopy;
      if (v11)
      {
        v14 = CFGetTypeID(v11);
        if (v14 == CFStringGetTypeID())
          FigCFDictionarySetValue(v13, CFSTR("BundleID"), v11);
      }
      FigCFDictionarySetInt32(v13, CFSTR("Category"), a2);
      if (openFrameworkPredicate != -1)
        dispatch_once_f(&openFrameworkPredicate, 0, (dispatch_function_t)figPowerLogOpenFramework);
      if (figPLLogTimeSensitiveRegisteredEvent)
      {
        figPLLogTimeSensitiveRegisteredEvent(28, v6, v13, 0);
        v3 = 1;
      }
      else
      {
        v3 = 0;
      }
      CFRelease(v13);
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t FigCFWeakReferenceHolderGetTypeID()
{
  if (FigCFWeakReferenceHolderGetTypeID_once != -1)
    dispatch_once_f(&FigCFWeakReferenceHolderGetTypeID_once, 0, (dispatch_function_t)registerFigCFWeakReferenceHolder);
  return sFigCFWeakReferenceHolderID;
}

uint64_t registerFigCFWeakReferenceHolder()
{
  uint64_t result;

  sFigCFWeakReferenceHolderUseCache = 1;
  sFigCFWeakReferenceHolderDictionaryMutex = (uint64_t)FigSimpleMutexCreate();
  sFigCFWeakReferenceHolderDictionary = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0);
  result = _CFRuntimeRegisterClass();
  sFigCFWeakReferenceHolderID = result;
  return result;
}

CFTypeRef FigCFWeakReferenceHolderCreateWithReferencedObject(uint64_t a1)
{
  CFTypeRef v2;
  uint64_t Instance;
  uint64_t v4;
  CFTypeRef cf;
  const void *v7;
  const void *v8;

  if (FigCFWeakReferenceHolderGetTypeID_once != -1)
    dispatch_once_f(&FigCFWeakReferenceHolderGetTypeID_once, 0, (dispatch_function_t)registerFigCFWeakReferenceHolder);
  cf = 0;
  v7 = 0;
  if (!a1)
    return 0;
  if (sFigCFWeakReferenceHolderUseCache == 1
    && FigSimpleMutexTryLock((pthread_mutex_t *)sFigCFWeakReferenceHolderDictionaryMutex))
  {
    FigCFWeakReferenceHolderCopyCachedInstance(a1, (uint64_t *)&v7, (uint64_t *)&cf);
    FigSimpleMutexUnlock((pthread_mutex_t *)sFigCFWeakReferenceHolderDictionaryMutex);
    CFRelease((CFTypeRef)a1);
    if (cf)
      CFRelease(cf);
  }
  v2 = v7;
  if (!v7)
  {
    Instance = _CFRuntimeCreateInstance();
    v4 = Instance;
    if (Instance)
      FigCFWeakReferenceInit((id *)(Instance + 24), (id)a1);
    if (sFigCFWeakReferenceHolderUseCache == 1
      && FigSimpleMutexTryLock((pthread_mutex_t *)sFigCFWeakReferenceHolderDictionaryMutex))
    {
      v8 = 0;
      FigCFWeakReferenceHolderCopyCachedInstance(a1, (uint64_t *)&v8, (uint64_t *)&cf);
      v2 = v8;
      if (!v8)
      {
        CFDictionarySetValue((CFMutableDictionaryRef)sFigCFWeakReferenceHolderDictionary, (const void *)-a1, (const void *)-v4);
        *(_QWORD *)(v4 + 16) = -a1;
        v2 = CFRetain((CFTypeRef)v4);
      }
      FigSimpleMutexUnlock((pthread_mutex_t *)sFigCFWeakReferenceHolderDictionaryMutex);
      CFRelease((CFTypeRef)a1);
      if (cf)
        CFRelease(cf);
      CFRelease((CFTypeRef)v4);
    }
    else
    {
      return (CFTypeRef)v4;
    }
  }
  return v2;
}

void FigCFWeakReferenceHolderCopyCachedInstance(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = -a1;
  CFDictionaryGetValue((CFDictionaryRef)sFigCFWeakReferenceHolderDictionary, (const void *)-a1);
  CFRetain((CFTypeRef)a1);
  v7 = _CFTryRetain();
  v8 = v7;
  if (v7)
  {
    if (FigCFWeakReferenceLoadAndRetain((id *)(v7 + 24)) == (id)a1)
    {
      CFRelease((CFTypeRef)a1);
      v9 = v8;
      v8 = 0;
      goto LABEL_6;
    }
    CFDictionaryRemoveValue((CFMutableDictionaryRef)sFigCFWeakReferenceHolderDictionary, (const void *)v6);
  }
  v9 = 0;
LABEL_6:
  *a2 = v9;
  *a3 = v8;
}

id *FigCFWeakReferenceHolderCopyReferencedObject(id *result)
{
  if (result)
    return (id *)FigCFWeakReferenceLoadAndRetain(result + 3);
  return result;
}

uint64_t FigCFWeakReferenceHolderInit(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  return result;
}

void FigCFWeakReferenceHolderFinalize(uint64_t a1)
{
  if (sFigCFWeakReferenceHolderUseCache == 1 && *(_QWORD *)(a1 + 16))
  {
    FigSimpleMutexLock((pthread_mutex_t *)sFigCFWeakReferenceHolderDictionaryMutex);
    if (!((char *)CFDictionaryGetValue((CFDictionaryRef)sFigCFWeakReferenceHolderDictionary, *(const void **)(a1 + 16))
         + a1))
      CFDictionaryRemoveValue((CFMutableDictionaryRef)sFigCFWeakReferenceHolderDictionary, *(const void **)(a1 + 16));
    FigSimpleMutexUnlock((pthread_mutex_t *)sFigCFWeakReferenceHolderDictionaryMutex);
  }
  FigCFWeakReferenceDestroy((id *)(a1 + 24));
}

CFStringRef FigCFWeakReferenceHolderCopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("FigCFWeakReferenceHolder <%p> -> <%p>"), a1, *(_QWORD *)(a1 + 24));
}

uint64_t FigEndpointRPCCacheCreate(_QWORD *a1, int a2)
{
  char *v4;
  char *v5;
  uint64_t v6;

  v4 = (char *)malloc_type_calloc(1uLL, 0x20uLL, 0x102004039A5F366uLL);
  if (v4)
  {
    v5 = v4;
    *(_DWORD *)v4 = a2;
    *(_OWORD *)(v4 + 8) = xmmword_18EDDE3B0;
    v6 = 0;
    *((_QWORD *)v4 + 3) = malloc_type_calloc(0x20uLL, 0x10uLL, 0x10C004028F705ECuLL);
    *a1 = v5;
  }
  else
  {
    v6 = FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
  }
  FigEndpointRPCCacheDispose(0);
  return v6;
}

void FigEndpointRPCCacheDispose(_QWORD *a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;

  if (a1)
  {
    v2 = (char *)a1[3];
    if (v2)
    {
      v3 = a1[1];
      if (v3 >= 1)
      {
        v4 = 0;
        for (i = 0; i < v3; ++i)
        {
          if (*(_QWORD *)&v2[v4])
          {
            CFRelease(*(CFTypeRef *)&v2[v4]);
            v2 = (char *)a1[3];
            *(_QWORD *)&v2[v4] = 0;
            v3 = a1[1];
          }
          v4 += 16;
        }
      }
      a1[3] = 0;
      free(v2);
    }
    free(a1);
  }
}

uint64_t FigEndpointRPCCacheRemoveAllEndpoints(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const void *v6;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = 0;
    v5 = *(_QWORD *)(a1 + 24);
    do
    {
      v6 = *(const void **)(v5 + v3);
      if (v6)
      {
        CFRelease(v6);
        v5 = *(_QWORD *)(a1 + 24);
        *(_QWORD *)(v5 + v3) = 0;
        v2 = *(_QWORD *)(a1 + 8);
      }
      *(_QWORD *)(v5 + v3 + 8) = 0;
      ++v4;
      v3 += 16;
    }
    while (v4 < v2);
  }
  *(_QWORD *)(a1 + 8) = 0;
  return 0;
}

uint64_t FigEndpointRPCCacheComputeCacheDeltas(uint64_t a1, _xpc_connection_s *a2, CFArrayRef theArray, _QWORD *a4, _QWORD *a5)
{
  const __CFArray *MutableCopy;
  uint64_t v10;
  xpc_object_t v11;
  uint64_t v12;
  uint64_t v13;
  const void **v14;
  CFIndex FirstIndexOfValue;
  CFIndex Count;
  uint64_t v17;
  xpc_object_t v18;
  CFIndex v19;
  void *ValueAtIndex;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v24;
  uint64_t v25;
  CFRange v26;

  MutableCopy = FigCFArrayCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], theArray);
  v10 = *(_QWORD *)(a1 + 8);
  if (v10 < 1)
  {
    v11 = 0;
  }
  else
  {
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = *(_QWORD *)(a1 + 24);
      v14 = (const void **)(v13 + 16 * v12);
      v26.length = CFArrayGetCount(MutableCopy);
      v26.location = 0;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(MutableCopy, v26, *v14);
      if (FirstIndexOfValue == -1)
      {
        if (a5)
        {
          if (!v11)
            v11 = xpc_array_create(0, 0);
          xpc_array_set_uint64(v11, 0xFFFFFFFFFFFFFFFFLL, *(_QWORD *)(v13 + 16 * v12 + 8));
        }
        if (*v14)
        {
          CFRelease(*v14);
          *v14 = 0;
        }
        --v10;
        *(_OWORD *)(*(_QWORD *)(a1 + 24) + 16 * v12) = *(_OWORD *)(*(_QWORD *)(a1 + 24) + 16 * v10);
        --*(_QWORD *)(a1 + 8);
      }
      else
      {
        CFArrayRemoveValueAtIndex(MutableCopy, FirstIndexOfValue);
        ++v12;
      }
    }
    while (v12 < v10);
  }
  Count = CFArrayGetCount(MutableCopy);
  if (!Count)
  {
    v18 = 0;
    if (!a4)
    {
LABEL_26:
      v22 = 0;
      if (a5)
      {
        *a5 = v11;
        v11 = 0;
      }
      goto LABEL_28;
    }
LABEL_25:
    *a4 = v18;
    v18 = 0;
    goto LABEL_26;
  }
  v17 = Count;
  v18 = xpc_array_create(0, 0);
  if (v17 < 1)
  {
LABEL_24:
    if (!a4)
      goto LABEL_26;
    goto LABEL_25;
  }
  v24 = a4;
  v19 = 0;
  while (1)
  {
    v25 = 0;
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(MutableCopy, v19);
    v21 = *(_DWORD *)a1 == 1
        ? FigEndpointXPCServerAppendNeighborEndpointToArray(a2, ValueAtIndex, v18, (uint64_t *)&v25)
        : FigSignalErrorAt(4294950056, 0, 0, 0, 0, 0, 0);
    v22 = v21;
    if ((_DWORD)v21)
      break;
    figEndpointRPCCacheAddObject(a1, ValueAtIndex, v25);
    if (v17 == ++v19)
    {
      a4 = v24;
      goto LABEL_24;
    }
  }
LABEL_28:
  if (MutableCopy)
    CFRelease(MutableCopy);
  FigXPCRelease(v18);
  FigXPCRelease(v11);
  return v22;
}

_QWORD *figEndpointRPCCacheAddObject(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *result;
  CFTypeRef v9;

  v6 = *(_QWORD *)(a1 + 8);
  if (v6 == *(_QWORD *)(a1 + 16))
  {
    v7 = v6 + 16;
    result = malloc_type_realloc(*(void **)(a1 + 24), 16 * (v6 + 16), 0x264AB722uLL);
    *(_QWORD *)(a1 + 16) = v7;
    *(_QWORD *)(a1 + 24) = result;
    v6 = *(_QWORD *)(a1 + 8);
  }
  else
  {
    result = *(_QWORD **)(a1 + 24);
  }
  result[2 * v6 + 1] = a3;
  if (a2)
  {
    v9 = CFRetain(a2);
    result = *(_QWORD **)(a1 + 24);
    v6 = *(_QWORD *)(a1 + 8);
  }
  else
  {
    v9 = 0;
  }
  result[2 * v6] = v9;
  *(_QWORD *)(a1 + 8) = v6 + 1;
  return result;
}

void *FigEndpointRPCCacheApplyObjectDeltas(uint64_t a1, xpc_object_t xarray, xpc_object_t a3)
{
  size_t v6;
  size_t v7;
  size_t v8;
  void *v9;
  void *v10;
  size_t count;
  size_t v12;
  size_t i;
  uint64_t uint64;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  uint64_t v21;
  CFTypeRef cf;

  v21 = 0;
  cf = 0;
  if (xarray && (v6 = xpc_array_get_count(xarray)) != 0)
  {
    v7 = v6;
    v8 = 0;
    while (1)
    {
      v9 = *(_DWORD *)a1 == 1
         ? FigEndpointXPCRemoteRetainCopiedEndpointFromArray(xarray, v8, &v21, &cf)
         : (void *)FigSignalErrorAt(4294950056, 0, 0, 0, 0, 0, 0);
      v10 = v9;
      if ((_DWORD)v9)
        break;
      figEndpointRPCCacheAddObject(a1, cf, v21);
      if (cf)
      {
        CFRelease(cf);
        cf = 0;
      }
      if (v7 == ++v8)
        goto LABEL_11;
    }
  }
  else
  {
LABEL_11:
    if (a3)
    {
      count = xpc_array_get_count(a3);
      if (count)
      {
        v12 = count;
        for (i = 0; i != v12; ++i)
        {
          uint64 = xpc_array_get_uint64(a3, i);
          v21 = uint64;
          v15 = *(_QWORD *)(a1 + 8);
          if (v15 >= 1)
          {
            v16 = 0;
            v17 = *(_QWORD *)(a1 + 24);
            v18 = *(_QWORD *)(a1 + 8);
            while (*(_QWORD *)(v17 + v16 + 8) != uint64)
            {
              v16 += 16;
              if (!--v18)
                goto LABEL_22;
            }
            v19 = *(const void **)(v17 + v16);
            if (v19)
            {
              CFRelease(v19);
              v17 = *(_QWORD *)(a1 + 24);
              *(_QWORD *)(v17 + v16) = 0;
              v15 = *(_QWORD *)(a1 + 8);
            }
            *(_OWORD *)(v17 + v16) = *(_OWORD *)(v17 + 16 * v15 - 16);
            --*(_QWORD *)(a1 + 8);
          }
LABEL_22:
          ;
        }
      }
    }
    v10 = 0;
  }
  if (cf)
    CFRelease(cf);
  return v10;
}

uint64_t FigEndpointRPCCacheCopyAvailableObjects(uint64_t a1, __CFArray **a2)
{
  __CFArray *Mutable;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    if (*(uint64_t *)(a1 + 8) >= 1)
    {
      v5 = 0;
      v6 = 0;
      do
      {
        CFArrayAppendValue(Mutable, *(const void **)(*(_QWORD *)(a1 + 24) + v5));
        ++v6;
        v5 += 16;
      }
      while (v6 < *(_QWORD *)(a1 + 8));
    }
    result = 0;
  }
  else
  {
    result = FigSignalErrorAt(4294950585, 0, 0, 0, 0, 0, 0);
  }
  *a2 = Mutable;
  return result;
}

uint64_t FigForcefullyPurgeObjectsAndGenerateReportForPID(int a1, CFTypeRef *a2, CFTypeRef *a3, _QWORD *a4)
{
  return FigControlCommandsRemoteClientPurgeObjectsAndGenerateReportForPID(a1, 1, a2, a3, a4);
}

uint64_t FigControlCommandsRemoteClientPurgeObjectsAndGenerateReportForPID(int a1, int a2, CFTypeRef *a3, CFTypeRef *a4, _QWORD *a5)
{
  uint64_t v10;
  uint64_t v11;
  xpc_object_t v13;
  xpc_object_t xdict;
  CFTypeRef cf;
  uint64_t v16;
  CFTypeRef v17;

  v16 = 0;
  v17 = 0;
  xdict = 0;
  cf = 0;
  v13 = 0;
  if (a1 <= 0)
  {
    v11 = FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
    goto LABEL_22;
  }
  if (gFigControlCommandsRemoteClientSetupOnce != -1)
    dispatch_once(&gFigControlCommandsRemoteClientSetupOnce, &__block_literal_global_59);
  v10 = remoteClient_EnsureClientEstablished_err;
  if (!remoteClient_EnsureClientEstablished_err)
  {
    v11 = FigXPCCreateBasicMessage(0x70677270u, 0, &xdict);
    if (!(_DWORD)v11)
    {
      xpc_dictionary_set_int64(xdict, "Pid", a1);
      xpc_dictionary_set_BOOL(xdict, "ForcePurge", a2 != 0);
      v11 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigControlCommandsRemoteClient, (uint64_t)xdict, &v13);
      if (!(_DWORD)v11)
      {
        v11 = FigXPCMessageCopyCFBoolean(v13, "CouldNotPurgeAllObjects", &v17);
        if (!(_DWORD)v11)
        {
          v11 = FigXPCMessageCopyCFBoolean(v13, "PurgeProhibited", &v16);
          if (!(_DWORD)v11)
          {
            v11 = FigXPCMessageCopyCFString(v13, "Stats", &cf);
            if (!(_DWORD)v11)
            {
              if (a3)
              {
                *a3 = cf;
                cf = 0;
              }
              if (a4)
              {
                *a4 = v17;
                v17 = 0;
              }
              v10 = 0;
              if (a5)
              {
                *a5 = v16;
                v16 = 0;
              }
              goto LABEL_16;
            }
          }
        }
      }
    }
LABEL_22:
    v10 = v11;
  }
LABEL_16:
  if (cf)
    CFRelease(cf);
  if (v17)
    CFRelease(v17);
  FigXPCRelease(xdict);
  FigXPCRelease(v13);
  return v10;
}

uint64_t FigPurgeObjectsAndGenerateReportForPID(int a1, CFTypeRef *a2, CFTypeRef *a3, _QWORD *a4)
{
  return FigControlCommandsRemoteClientPurgeObjectsAndGenerateReportForPID(a1, 0, a2, a3, a4);
}

uint64_t CMStartAirPlayLoopback()
{
  uint64_t v0;
  uint64_t v1;
  void *v2;
  void *v4;

  v4 = 0;
  if (gFigControlCommandsRemoteClientSetupOnce != -1)
    dispatch_once(&gFigControlCommandsRemoteClientSetupOnce, &__block_literal_global_59);
  v0 = remoteClient_EnsureClientEstablished_err;
  if (remoteClient_EnsureClientEstablished_err)
  {
    v2 = 0;
  }
  else
  {
    v1 = FigXPCCreateBasicMessage(0x6C6F6F70u, 0, &v4);
    v2 = v4;
    if ((_DWORD)v1)
    {
      v0 = v1;
    }
    else
    {
      v0 = FigXPCRemoteClientSendAsyncMessage(gFigControlCommandsRemoteClient, v4);
      v2 = v4;
    }
  }
  FigXPCRelease(v2);
  return v0;
}

uint64_t FigRPCTimeoutRemote_KillAndForceCrashReport(mach_port_name_t a1, uint64_t a2, char *src)
{
  int v4;
  mach_msg_size_t v5;
  mach_port_t reply_port;
  uint64_t v7;
  uint64_t v8;
  mach_port_name_t rcv_name[4];
  __int128 v11;
  __int128 v12;
  _OWORD v13[32];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v12 = 0u;
  memset(v13, 0, 464);
  *(_OWORD *)rcv_name = 0u;
  v11 = 0u;
  *((_QWORD *)&v11 + 1) = *MEMORY[0x1E0C804E8];
  *(_QWORD *)&v12 = a2;
  if (MEMORY[0x1E0C84128])
    v4 = mig_strncpy_zerofill((char *)v13, src, 512);
  else
    v4 = mig_strncpy((char *)v13, src, 512);
  DWORD2(v12) = 0;
  HIDWORD(v12) = v4;
  v5 = ((v4 + 3) & 0xFFFFFFFC) + 48;
  reply_port = mig_get_reply_port();
  rcv_name[2] = a1;
  rcv_name[3] = reply_port;
  rcv_name[0] = 5395;
  *(_QWORD *)&v11 = 0x275C00000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)rcv_name);
    reply_port = rcv_name[3];
  }
  v7 = mach_msg((mach_msg_header_t *)rcv_name, 3, v5, 0x2Cu, reply_port, 0, 0);
  v8 = v7;
  if ((v7 - 268435458) <= 0xE && ((1 << (v7 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(rcv_name[3]);
    return v8;
  }
  if ((_DWORD)v7)
  {
    mig_dealloc_reply_port(rcv_name[3]);
    return v8;
  }
  if (DWORD1(v11) == 71)
  {
    v8 = 4294966988;
LABEL_20:
    mach_msg_destroy((mach_msg_header_t *)rcv_name);
    return v8;
  }
  if (DWORD1(v11) != 10176)
  {
    v8 = 4294966995;
    goto LABEL_20;
  }
  v8 = 4294966996;
  if ((rcv_name[0] & 0x80000000) != 0)
    goto LABEL_20;
  if (rcv_name[1] != 36)
    goto LABEL_20;
  if (rcv_name[2])
    goto LABEL_20;
  v8 = v12;
  if ((_DWORD)v12)
    goto LABEL_20;
  return v8;
}

uint64_t (*FigRPCTimeout_server_routine(uint64_t a1))()
{
  int v1;

  v1 = *(_DWORD *)(a1 + 20);
  if ((v1 - 10079) >= 0xFFFFFFFD)
    return FigRPCTimeoutServer_FigRPCTimeout_subsystem[5 * (v1 - 10076) + 5];
  else
    return 0;
}

_DWORD *_XKillAndForceCrashReport(_DWORD *result, uint64_t a2)
{
  _DWORD *v3;
  uint64_t v4;
  unsigned int v5;
  BOOL v6;
  unsigned int v7;
  BOOL v8;
  int v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  _OWORD v14[2];

  if ((*result & 0x80000000) == 0
    && (v3 = result, v4 = result[1], v4 >= 0x30)
    && v4 <= 0x230
    && ((v5 = result[11], v5 <= 0x200) ? (v6 = (int)v4 - 48 >= v5) : (v6 = 0),
        (v7 = ((v5 + 3) & 0xFFFFFFFC) + 48, v6) ? (v8 = (_DWORD)v4 == v7) : (v8 = 0),
        v8 && (result = memchr(result + 12, 0, v4 - 48)) != 0))
  {
    v10 = (char *)v3 + ((v4 + 3) & 0x1FFFFFFFCLL);
    if (!*(_DWORD *)v10 && *((_DWORD *)v10 + 1) > 0x1Fu)
    {
      v11 = v3[3];
      v12 = *((_QWORD *)v3 + 4);
      v13 = *(_OWORD *)(v10 + 36);
      v14[0] = *(_OWORD *)(v10 + 20);
      v14[1] = v13;
      result = (_DWORD *)FigRPCTimeoutServer_KillAndForceCrashReport(v11, v12, (const char *)v3 + 48, v14);
      *(_DWORD *)(a2 + 32) = (_DWORD)result;
      goto LABEL_13;
    }
    v9 = -309;
  }
  else
  {
    v9 = -304;
  }
  *(_DWORD *)(a2 + 32) = v9;
LABEL_13:
  *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
  return result;
}

uint64_t _XSetFigNotePreferences(uint64_t result, uint64_t a2)
{
  int v3;
  unsigned int v4;
  unsigned int v5;
  int v6;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 3 || *(_DWORD *)(result + 4) != 96)
  {
    v6 = -304;
LABEL_12:
    *(_DWORD *)(a2 + 32) = v6;
    goto LABEL_13;
  }
  if (*(_BYTE *)(result + 39) != 1
    || *(_BYTE *)(result + 55) != 1
    || *(_BYTE *)(result + 71) != 1
    || (v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 84))
    || (v4 = *(_DWORD *)(result + 56), v4 != *(_DWORD *)(result + 88))
    || (v5 = *(_DWORD *)(result + 72), v5 != *(_DWORD *)(result + 92)))
  {
    v6 = -300;
    goto LABEL_12;
  }
  result = FigRPCTimeoutServer_SetFigNotePreferences(*(unsigned int *)(result + 12), *(_QWORD *)(result + 28), v3, *(_QWORD *)(result + 44), v4, *(_QWORD *)(result + 60), v5);
  *(_DWORD *)(a2 + 32) = result;
LABEL_13:
  *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
  return result;
}

uint64_t _XResetFigNotePreset(uint64_t result, uint64_t a2)
{
  int v3;
  int v4;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    v4 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v4;
    goto LABEL_9;
  }
  if (*(_BYTE *)(result + 39) != 1 || (v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 52)))
  {
    v4 = -300;
    goto LABEL_8;
  }
  result = FigRPCTimeoutServer_ResetFigNotePreset(*(unsigned int *)(result + 12), *(_QWORD *)(result + 28), v3);
  *(_DWORD *)(a2 + 32) = result;
LABEL_9:
  *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
  return result;
}

uint64_t FigRPCTimeout_server(_DWORD *a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  void (*v5)(void);
  uint64_t result;

  v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  v4 = a1[5];
  if ((v4 - 10079) >= 0xFFFFFFFD
    && (v5 = (void (*)(void))FigRPCTimeoutServer_FigRPCTimeout_subsystem[5 * (v4 - 10076) + 5]) != 0)
  {
    v5();
    return 1;
  }
  else
  {
    result = 0;
    *(_QWORD *)(a2 + 24) = *MEMORY[0x1E0C804E8];
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

uint64_t sntp_shortstamp_ntoh(unsigned int a1)
{
  return __rev16(a1);
}

unint64_t sntp_timestamp_hton(unint64_t a1)
{
  return __rev32(a1);
}

uint64_t sntp_timestamp_to_datestamp(uint64_t result)
{
  return result;
}

unint64_t sntp_timestamp_from_datestamp(unsigned int a1, uint64_t a2)
{
  return a2 & 0xFFFFFFFF00000000 | a1;
}

uint64_t sntp_datestamp_subsecs_to_nsec(unint64_t a1)
{
  uint64_t v1;

  v1 = (a1 * (unsigned __int128)0x3B9ACA00uLL) >> 64;
  if (1000000000 * a1 < 0x8000000000000000)
    return v1;
  else
    return (v1 + 1);
}

uint64_t sntp_datestamp_from_timespec(uint64_t a1)
{
  __udivti3();
  return a1;
}

double sntp_datestamp_to_double(uint64_t a1, unint64_t a2)
{
  return (double)a2 * 5.42101086e-20 + (double)a1;
}

double sntp_datestamp_from_double(double a1)
{
  return a1 - (double)(uint64_t)a1;
}

uint64_t sntp_calc_offset(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unsigned __int128 v14;

  v2 = sntp_timestamp_to_datestamp(*(_QWORD *)(a1 + 4));
  v4 = v3;
  v5 = -v2;
  v6 = sntp_timestamp_to_datestamp(*(_QWORD *)(a1 + 12));
  v8 = v7;
  v9 = sntp_timestamp_to_datestamp(*(_QWORD *)(a1 + 20));
  v11 = v10;
  v12 = sntp_timestamp_to_datestamp(*(_QWORD *)(a1 + 28));
  v14 = __PAIR128__(v5 - (v4 != 0) + __CFADD__(-v4, v8) + v6 + (unint64_t)__CFADD__(v8 - v4, v11) + v9, v8 - v4 + v11)- v13;
  return (__CFADD__((_QWORD)v14, (unint64_t)(*((_QWORD *)&v14 + 1) - v12) >> 63) + *((_QWORD *)&v14 + 1) - v12) >> 1;
}

uint64_t sntp_calc_delay(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;

  v2 = sntp_timestamp_to_datestamp(*(_QWORD *)(a1 + 4));
  v4 = v3;
  v5 = -v2;
  v6 = sntp_timestamp_to_datestamp(*(_QWORD *)(a1 + 12));
  v8 = v7;
  v9 = sntp_timestamp_to_datestamp(*(_QWORD *)(a1 + 20));
  v11 = v10;
  v12 = -v9;
  v13 = sntp_timestamp_to_datestamp(*(_QWORD *)(a1 + 28));
  return v13
       + ((__PAIR128__(v5 - (v4 != 0) + (unint64_t)__CFADD__(-v4, v8) + v6, v8 - v4) - v11 + __PAIR128__(v12, v14)) >> 64);
}

unint64_t sntp_clock_select(unint64_t a1, unsigned int a2)
{
  unint64_t v2;
  unsigned int v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t result;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  _DWORD *v26;
  unint64_t v27;
  unint64_t v28;
  BOOL v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unsigned int v36;
  unint64_t v37;

  if (!a2)
    return 0;
  v2 = a1;
  v3 = 0;
  v4 = a1 + 80 * a2;
  v5 = a1;
  do
  {
    if (!*(_DWORD *)v5 && *(_BYTE *)(v5 + 37))
      ++v3;
    v5 += 80;
  }
  while (v5 < v4);
  result = 0;
  v7 = 0;
  v8 = 0;
  v31 = v3 >> 1;
  do
  {
    if (!*(_DWORD *)v2 && *(_BYTE *)(v2 + 37))
    {
      v32 = v8;
      v33 = v7;
      v34 = result;
      v9 = sntp_calc_delay(v2);
      v10 = (_DWORD *)(v2 + 80);
      v37 = v11;
      if (v2 + 80 >= v4)
      {
        v36 = 1;
        v35 = v2;
      }
      else
      {
        v36 = 1;
        v35 = v2;
        do
        {
          if (!*v10)
          {
            v12 = sntp_calc_offset(v2);
            v14 = v13;
            v15 = sntp_calc_offset((uint64_t)v10);
            v17 = v16;
            v18 = sntp_calc_delay(v2);
            v20 = v19;
            v21 = sntp_calc_delay((uint64_t)v10);
            if ((__int128)(__PAIR128__(v18, v20) + __PAIR128__(v12, v14)) >= (__int128)(__PAIR128__(v15, v17)
                                                                                       - __PAIR128__(v21, v22))
              && (__int128)(__PAIR128__(v21, v22) + __PAIR128__(v15, v17)) >= (__int128)(__PAIR128__(v12, v14)
                                                                                       - __PAIR128__(v18, v20)))
            {
              ++v36;
              v23 = sntp_calc_delay((uint64_t)v10);
              v25 = v37;
              v26 = (_DWORD *)v35;
              if ((__int128)__PAIR128__(v23, v24) < (__int128)__PAIR128__(v9, v37))
                v26 = v10;
              v35 = (unint64_t)v26;
              if ((__int128)__PAIR128__(v23, v24) < (__int128)__PAIR128__(v9, v37))
              {
                v9 = v23;
                v25 = v24;
              }
              v37 = v25;
            }
          }
          v10 += 20;
        }
        while ((unint64_t)v10 < v4);
      }
      v8 = v32;
      v7 = v33;
      v27 = v37;
      result = v34;
      v28 = v35;
      v29 = (__int128)__PAIR128__(v9, v37) < (__int128)__PAIR128__(v32, v33) || v34 == 0;
      if (v29)
        v30 = v9;
      else
        v30 = v32;
      if (!v29)
      {
        v27 = v33;
        v28 = v34;
      }
      if (v36 > v31)
      {
        v7 = v27;
        v8 = v30;
        result = v28;
      }
    }
    v2 += 80;
  }
  while (v2 < v4);
  return result;
}

unint64_t sntp_packet_ntoh@<X0>(__int128 *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t result;
  __int128 v5;
  uint64_t v6;

  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  v5 = *a1;
  v6 = *((_QWORD *)a1 + 2);
  sntp_header_ntoh((int *)&v5, a2);
  *(_QWORD *)(a2 + 24) = sntp_timestamp_hton(*((_QWORD *)a1 + 3));
  *(_QWORD *)(a2 + 32) = sntp_timestamp_hton(*((_QWORD *)a1 + 4));
  result = sntp_timestamp_hton(*((_QWORD *)a1 + 5));
  *(_QWORD *)(a2 + 40) = result;
  return result;
}

unint64_t sntp_header_ntoh@<X0>(int *a1@<X0>, uint64_t a2@<X8>)
{
  unsigned int v4;
  int v5;
  int v6;
  unsigned int v7;
  unint64_t result;

  v5 = *a1;
  v4 = a1[1];
  *(_DWORD *)a2 = v5;
  *(_DWORD *)(a2 + 4) = sntp_shortstamp_ntoh(v4);
  v6 = sntp_shortstamp_ntoh(a1[2]);
  v7 = bswap32(a1[3]);
  *(_DWORD *)(a2 + 8) = v6;
  *(_DWORD *)(a2 + 12) = v7;
  result = sntp_timestamp_hton(*((_QWORD *)a1 + 2));
  *(_QWORD *)(a2 + 16) = result;
  return result;
}

__n128 sntp_client_exchange@<Q0>(int a1@<W0>, timeval *a2@<X3>, uint64_t (*a3)(void)@<X4>, uint64_t a4@<X8>)
{
  __n128 result;
  int v9;
  __int128 v10;
  _OWORD v11[3];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _OWORD v15[2];
  __int128 v16;
  fd_set v17;
  _OWORD v18[3];
  __int128 v19;
  __int128 v20;

  v19 = 0u;
  v20 = 0u;
  memset(v18, 0, sizeof(v18));
  memset(&v17, 0, sizeof(v17));
  if (__darwin_check_fd_set_overflow(a1, &v17, 0))
    *(__int32_t *)((char *)v17.fds_bits + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << a1;
  v16 = 0u;
  memset(v15, 0, sizeof(v15));
  LOBYTE(v15[0]) = 35;
  if (a3)
  {
    *(_QWORD *)((char *)v18 + 4) = a3();
    *((_QWORD *)&v16 + 1) = sntp_timestamp_hton(*(unint64_t *)((char *)v18 + 4));
  }
  if (send(a1, v15, 0x30uLL, 0) != 48)
  {
    v9 = 5;
LABEL_17:
    LODWORD(v18[0]) = v9;
    v10 = v19;
    *(_OWORD *)(a4 + 32) = v18[2];
    *(_OWORD *)(a4 + 48) = v10;
    *(_OWORD *)(a4 + 64) = v20;
    result = (__n128)v18[1];
    *(_OWORD *)a4 = v18[0];
    *(__n128 *)(a4 + 16) = result;
    return result;
  }
  if (a2 && (a2->tv_sec || a2->tv_usec) && select(a1 + 1, &v17, 0, &v17, a2) != 1)
  {
    v9 = 6;
    goto LABEL_17;
  }
  v13 = 0u;
  v14 = 0u;
  v12 = 0u;
  if (recv(a1, &v12, 0x30uLL, 0) != 48)
  {
    v9 = 7;
    goto LABEL_17;
  }
  if (a3)
    *(_QWORD *)((char *)&v18[1] + 12) = a3();
  v11[0] = v12;
  v11[1] = v13;
  v11[2] = v14;
  sntp_client_process_response((unsigned __int8 *)v11, (unint64_t *)((char *)v18 + 4), (_OWORD *)((char *)&v18[1] + 12), a4);
  return result;
}

unint64_t sntp_client_process_response@<X0>(unsigned __int8 *a1@<X0>, unint64_t *a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v8;
  unint64_t v9;
  __int128 v10;
  unint64_t result;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  __int128 v16[3];
  _OWORD v17[3];

  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  if (a2)
  {
    v8 = *a2;
    *(_QWORD *)(a4 + 4) = *a2;
    v9 = HIDWORD(v8);
    if (!a3)
      goto LABEL_4;
    goto LABEL_3;
  }
  LODWORD(v9) = 0;
  LODWORD(v8) = 0;
  if (a3)
LABEL_3:
    *(_QWORD *)(a4 + 28) = *a3;
LABEL_4:
  v10 = *((_OWORD *)a1 + 1);
  v16[0] = *(_OWORD *)a1;
  v16[1] = v10;
  v16[2] = *((_OWORD *)a1 + 2);
  result = sntp_packet_ntoh(v16, (uint64_t)v17);
  v12 = v17[1];
  *(_OWORD *)a1 = v17[0];
  *((_OWORD *)a1 + 1) = v12;
  *((_OWORD *)a1 + 2) = v17[2];
  *(_OWORD *)(a4 + 36) = *(_OWORD *)a1;
  *(_QWORD *)(a4 + 52) = *((_QWORD *)a1 + 2);
  v13 = *((_QWORD *)a1 + 4);
  v14 = *((_QWORD *)a1 + 5);
  *(_QWORD *)(a4 + 12) = v13;
  *(_QWORD *)(a4 + 20) = v14;
  if (*a1 <= 0xBFu)
  {
    if (a1[1])
    {
      if (__ROR8__(v14, 32) >= __ROR8__(v13, 32))
      {
        if (a2)
        {
          if (*((_DWORD *)a1 + 6) != (_DWORD)v8 || *((_DWORD *)a1 + 7) != (_DWORD)v9)
          {
            v15 = 10;
            goto LABEL_19;
          }
          if (a3)
          {
            result = sntp_calc_delay(a4);
            if ((result & 0x8000000000000000) != 0)
            {
              v15 = 11;
              goto LABEL_19;
            }
          }
        }
        v15 = 0;
      }
      else
      {
        v15 = 12;
      }
    }
    else
    {
      v15 = 8;
    }
  }
  else
  {
    v15 = 9;
  }
LABEL_19:
  *(_DWORD *)a4 = v15;
  return result;
}

void figObjectDependencyDeathDefaultCallback_cold_1()
{
  void *v0;

  v0 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void soft_FigAudioSessionTriggerAVAudioSessionReset(pid_t)"), CFSTR("FigMediaServicesProcessDeathMonitoringFigOnly.m"), 80, CFSTR("%s"), dlerror());
  __break(1u);
}

void __getFigAudioSessionTriggerAVAudioSessionResetSymbolLoc_block_invoke_cold_1(_QWORD *a1)
{
  void *v2;

  v2 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *MediaToolboxLibrary(void)"), CFSTR("FigMediaServicesProcessDeathMonitoringFigOnly.m"), 79, CFSTR("%s"), *a1);
  __break(1u);
}

void fpm_timerCallback_cold_1()
{
  uint64_t v0;
  void *v1;

  v1 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef getkRTCReportingUserInfoClientName(void)");
  objc_msgSend(v1, "handleFailureInFunction:file:lineNumber:description:", v0, CFSTR("FigPerformanceMonitor.m"), 93, CFSTR("%s"), OUTLINED_FUNCTION_0());
  __break(1u);
}

void fpm_timerCallback_cold_2()
{
  uint64_t v0;
  void *v1;

  v1 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef getkRTCReportingSessionInfoClientType(void)");
  objc_msgSend(v1, "handleFailureInFunction:file:lineNumber:description:", v0, CFSTR("FigPerformanceMonitor.m"), 84, CFSTR("%s"), OUTLINED_FUNCTION_0());
  __break(1u);
}

void fpm_timerCallback_cold_3()
{
  uint64_t v0;
  void *v1;

  v1 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef getkRTCReportingSessionInfoSessionID(void)");
  objc_msgSend(v1, "handleFailureInFunction:file:lineNumber:description:", v0, CFSTR("FigPerformanceMonitor.m"), 87, CFSTR("%s"), OUTLINED_FUNCTION_0());
  __break(1u);
}

void fpm_timerCallback_cold_4()
{
  uint64_t v0;
  void *v1;

  v1 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef getkRTCReportingSessionInfoContainsRealtimeEvents(void)");
  objc_msgSend(v1, "handleFailureInFunction:file:lineNumber:description:", v0, CFSTR("FigPerformanceMonitor.m"), 90, CFSTR("%s"), OUTLINED_FUNCTION_0());
  __break(1u);
}

void RTCReportingLibrary_cold_1(_QWORD *a1)
{
  void *v2;

  v2 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *RTCReportingLibrary(void)"), CFSTR("FigPerformanceMonitor.m"), 81, CFSTR("%s"), *a1);
  __break(1u);
}

void __getRTCReportingClass_block_invoke_cold_1()
{
  void *v0;

  v0 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getRTCReportingClass(void)_block_invoke"), CFSTR("FigPerformanceMonitor.m"), 82, CFSTR("Unable to find class %s"), "RTCReporting");
  __break(1u);
}

void FigAV1Bridge_CopyITU_T_T35MetadataDolbyVisionRPURawByteSequence_cold_1()
{
  OUTLINED_FUNCTION_0_0();
  __break(1u);
}

void CMAudioClockCreate_cold_1()
{
  void *v0;

  v0 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "OSStatus soft_FigAudioSessionClockCreateForSharedAudioSession(CFAllocatorRef, CMAudioClockTimingPreference, CMClockRef *)"), CFSTR("CMAudioClock.m"), 49, CFSTR("%s"), dlerror());
  __break(1u);
}

void CMAudioClockCreateForAudioSession_cold_1()
{
  void *v0;

  v0 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "OSStatus soft_FigAudioSessionClockCreateForAVAudioSession(CFAllocatorRef, AVAudioSession *, CMAudioClockTimingPreference, CMClockRef *)"), CFSTR("CMAudioClock.m"), 52, CFSTR("%s"), dlerror());
  __break(1u);
}

void MediaToolboxLibrary_cold_1(_QWORD *a1)
{
  void *v2;

  v2 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *MediaToolboxLibrary(void)"), CFSTR("CMAudioClock.m"), 48, CFSTR("%s"), *a1);
  __break(1u);
}

void FigUserFaultWithMessage_cold_1(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  __int16 v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v2 = 134218242;
  v3 = a2;
  v4 = 2112;
  v5 = a1;
  _os_log_fault_impl(&dword_18EC8D000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "0x%llx - %@", (uint8_t *)&v2, 0x16u);
}

void fig_log_internal_cold_1(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_error_impl(&dword_18EC8D000, log, OS_LOG_TYPE_ERROR, "Trying to write to ring buffer while owning ringConfigurationLock for writing. Dropping log.", v1, 2u);
}

void fig_log_internal_cold_2(uint64_t *a1, NSObject *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3 = 134218240;
  v4 = v2;
  v5 = 2048;
  v6 = qword_1EE13FDC8;
  _os_log_error_impl(&dword_18EC8D000, a2, OS_LOG_TYPE_ERROR, "Log size (%ld) too long for ring buffer size %zu. Dropping it.", (uint8_t *)&v3, 0x16u);
}

void fig_post_a_symptom_guts_cold_1(uint64_t a1, NSObject *a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v2 = 136315138;
  v3 = a1;
  _os_log_error_impl(&dword_18EC8D000, a2, OS_LOG_TYPE_ERROR, "%s", (uint8_t *)&v2, 0xCu);
}

void sbufAtom_createSampleBufferFromSerializedAtomDataAndSurface_cold_1()
{
  dlerror();
  abort_report_np();
  sbufAtomAppendSampleSizes_MissingSampleSizes_LogOnce_cold_1();
}

void sbufAtomAppendSampleSizes_MissingSampleSizes_LogOnce_cold_1()
{
  uint8_t v0[16];

  *(_WORD *)v0 = 0;
  _os_log_fault_impl(&dword_18EC8D000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Detected and patched single-sample video CMSampleBuffer with data buffer but no sample size entry. Video CMSampleBuffers must be created with at least one sampleSizeArray entry.", v0, 2u);
}

void FigXPCServerSelfTerminateDueToError_cold_1(char **a1, uint64_t a2, int a3)
{
  const char *v4;

  *a1 = 0;
  asprintf(a1, "****** Self-terminating due to fatal error %d on server %s", a3, *(const char **)(a2 + 88));
  v4 = *a1;
  getpid();
  FigRPCServer_TimeoutCrashReport(0, v4);
  abort();
}

uint64_t APFSCaptureCreatePreallocFile()
{
  return MEMORY[0x1E0CF1878]();
}

uint64_t APFSCaptureDeletePreallocFile()
{
  return MEMORY[0x1E0CF1880]();
}

uint64_t APFSCaptureExtendPreallocSizeForFile()
{
  return MEMORY[0x1E0CF1888]();
}

uint64_t APFSCaptureFinishCaptureForFile()
{
  return MEMORY[0x1E0CF1890]();
}

uint64_t APFSCaptureStartCaptureInFile()
{
  return MEMORY[0x1E0CF1898]();
}

uint64_t AnalyticsSendEvent()
{
  return MEMORY[0x1E0D15420]();
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x1E0D15428]();
}

OSStatus AudioDeviceGetCurrentTime(AudioObjectID inDevice, AudioTimeStamp *outTime)
{
  return MEMORY[0x1E0C97578](*(_QWORD *)&inDevice, outTime);
}

OSStatus AudioObjectAddPropertyListener(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress, AudioObjectPropertyListenerProc inListener, void *inClientData)
{
  return MEMORY[0x1E0C975C0](*(_QWORD *)&inObjectID, inAddress, inListener, inClientData);
}

OSStatus AudioObjectGetPropertyData(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress, UInt32 inQualifierDataSize, const void *inQualifierData, UInt32 *ioDataSize, void *outData)
{
  return MEMORY[0x1E0C975D0](*(_QWORD *)&inObjectID, inAddress, *(_QWORD *)&inQualifierDataSize, inQualifierData, ioDataSize, outData);
}

OSStatus AudioObjectGetPropertyDataSize(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress, UInt32 inQualifierDataSize, const void *inQualifierData, UInt32 *outDataSize)
{
  return MEMORY[0x1E0C975D8](*(_QWORD *)&inObjectID, inAddress, *(_QWORD *)&inQualifierDataSize, inQualifierData, outDataSize);
}

Boolean AudioObjectHasProperty(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress)
{
  return MEMORY[0x1E0C975E0](*(_QWORD *)&inObjectID, inAddress);
}

OSStatus AudioObjectRemovePropertyListener(AudioObjectID inObjectID, const AudioObjectPropertyAddress *inAddress, AudioObjectPropertyListenerProc inListener, void *inClientData)
{
  return MEMORY[0x1E0C975F0](*(_QWORD *)&inObjectID, inAddress, inListener, inClientData);
}

int CC_MD5_Final(unsigned __int8 *md, CC_MD5_CTX *c)
{
  return MEMORY[0x1E0C80310](md, c);
}

int CC_MD5_Init(CC_MD5_CTX *c)
{
  return MEMORY[0x1E0C80318](c);
}

int CC_MD5_Update(CC_MD5_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1E0C80320](c, data, *(_QWORD *)&len);
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x1E0C80328](data, *(_QWORD *)&len, md);
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return MEMORY[0x1E0C80330](md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return MEMORY[0x1E0C80338](c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1E0C80340](c, data, *(_QWORD *)&len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C97C58]();
  return result;
}

void *__cdecl CFAllocatorAllocate(CFAllocatorRef allocator, CFIndex size, CFOptionFlags hint)
{
  return (void *)MEMORY[0x1E0C97C98](allocator, size, hint);
}

CFAllocatorRef CFAllocatorCreate(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  return (CFAllocatorRef)MEMORY[0x1E0C97CA8](allocator, context);
}

void CFAllocatorDeallocate(CFAllocatorRef allocator, void *ptr)
{
  MEMORY[0x1E0C97CB0](allocator, ptr);
}

void CFAllocatorGetContext(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  MEMORY[0x1E0C97CB8](allocator, context);
}

CFAllocatorRef CFAllocatorGetDefault(void)
{
  return (CFAllocatorRef)MEMORY[0x1E0C97CC0]();
}

CFTypeID CFAllocatorGetTypeID(void)
{
  return MEMORY[0x1E0C97CD0]();
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
  MEMORY[0x1E0C97CE8](theArray, otherArray, otherRange.location, otherRange.length);
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x1E0C97CF8](theArray, value);
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
  MEMORY[0x1E0C97D00](theArray, range.location, range.length, applier, context);
}

CFIndex CFArrayBSearchValues(CFArrayRef theArray, CFRange range, const void *value, CFComparatorFunction comparator, void *context)
{
  return MEMORY[0x1E0C97D08](theArray, range.location, range.length, value, comparator, context);
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1E0C97D10](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1E0C97D20](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x1E0C97D30](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D38](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D50](allocator, capacity, theArray);
}

void CFArrayExchangeValuesAtIndices(CFMutableArrayRef theArray, CFIndex idx1, CFIndex idx2)
{
  MEMORY[0x1E0C97D58](theArray, idx1, idx2);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1E0C97D60](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1E0C97D78](theArray, range.location, range.length, value);
}

CFIndex CFArrayGetLastIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x1E0C97D80](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1E0C97D90]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1E0C97D98](theArray, idx);
}

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
  MEMORY[0x1E0C97DA8](theArray, range.location, range.length, values);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  MEMORY[0x1E0C97DB0](theArray, idx, value);
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
  MEMORY[0x1E0C97DB8](theArray);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x1E0C97DC0](theArray, idx);
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
  MEMORY[0x1E0C97DE0](theArray, range.location, range.length, comparator, context);
}

CFMutableAttributedStringRef CFAttributedStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableAttributedStringRef)MEMORY[0x1E0C97E00](alloc, maxLength);
}

CFTypeRef CFAttributedStringGetAttributeAndLongestEffectiveRange(CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange inRange, CFRange *longestEffectiveRange)
{
  return (CFTypeRef)MEMORY[0x1E0C97E28](aStr, loc, attrName, inRange.location, inRange.length, longestEffectiveRange);
}

CFDictionaryRef CFAttributedStringGetAttributes(CFAttributedStringRef aStr, CFIndex loc, CFRange *effectiveRange)
{
  return (CFDictionaryRef)MEMORY[0x1E0C97E30](aStr, loc, effectiveRange);
}

CFIndex CFAttributedStringGetLength(CFAttributedStringRef aStr)
{
  return MEMORY[0x1E0C97E48](aStr);
}

CFStringRef CFAttributedStringGetString(CFAttributedStringRef aStr)
{
  return (CFStringRef)MEMORY[0x1E0C97E50](aStr);
}

void CFAttributedStringRemoveAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName)
{
  MEMORY[0x1E0C97E60](aStr, range.location, range.length, attrName);
}

void CFAttributedStringReplaceString(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef replacement)
{
  MEMORY[0x1E0C97E70](aStr, range.location, range.length, replacement);
}

void CFAttributedStringSetAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName, CFTypeRef value)
{
  MEMORY[0x1E0C97E78](aStr, range.location, range.length, attrName, value);
}

void CFBagAddValue(CFMutableBagRef theBag, const void *value)
{
  MEMORY[0x1E0C97E98](theBag, value);
}

CFMutableBagRef CFBagCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFBagCallBacks *callBacks)
{
  return (CFMutableBagRef)MEMORY[0x1E0C97EB8](allocator, capacity, callBacks);
}

CFIndex CFBagGetCountOfValue(CFBagRef theBag, const void *value)
{
  return MEMORY[0x1E0C97ED0](theBag, value);
}

void CFBagRemoveValue(CFMutableBagRef theBag, const void *value)
{
  MEMORY[0x1E0C97EF8](theBag, value);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1E0C97FC8]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1E0C97FE0](BOOLean);
}

CFURLRef CFBundleCopyBundleURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1E0C98000](bundle);
}

CFURLRef CFBundleCopyExecutableURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1E0C98020](bundle);
}

CFArrayRef CFBundleCopyLocalizationsForPreferences(CFArrayRef locArray, CFArrayRef prefArray)
{
  return (CFArrayRef)MEMORY[0x1E0C98040](locArray, prefArray);
}

CFURLRef CFBundleCopyResourceURL(CFBundleRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  return (CFURLRef)MEMORY[0x1E0C98080](bundle, resourceName, resourceType, subDirName);
}

CFURLRef CFBundleCopyResourcesDirectoryURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1E0C980B0](bundle);
}

CFArrayRef CFBundleCreateBundlesFromDirectory(CFAllocatorRef allocator, CFURLRef directoryURL, CFStringRef bundleType)
{
  return (CFArrayRef)MEMORY[0x1E0C980E0](allocator, directoryURL, bundleType);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1E0C980E8](bundleID);
}

void *__cdecl CFBundleGetFunctionPointerForName(CFBundleRef bundle, CFStringRef functionName)
{
  return (void *)MEMORY[0x1E0C98108](bundle, functionName);
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x1E0C98150]();
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1E0C98180](bundle, key);
}

Boolean CFBundleIsExecutableLoaded(CFBundleRef bundle)
{
  return MEMORY[0x1E0C98190](bundle);
}

Boolean CFCalendarComposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime *at, const char *componentDesc, ...)
{
  return MEMORY[0x1E0C98228](calendar, at, componentDesc);
}

CFTimeZoneRef CFCalendarCopyTimeZone(CFCalendarRef calendar)
{
  return (CFTimeZoneRef)MEMORY[0x1E0C98238](calendar);
}

CFCalendarRef CFCalendarCreateWithIdentifier(CFAllocatorRef allocator, CFCalendarIdentifier identifier)
{
  return (CFCalendarRef)MEMORY[0x1E0C98240](allocator, identifier);
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, componentDesc);
  v3 = va_arg(va, _QWORD);
  return MEMORY[0x1E0C98248](calendar, v3, at);
}

void CFCalendarSetTimeZone(CFCalendarRef calendar, CFTimeZoneRef tz)
{
  MEMORY[0x1E0C98298](calendar, tz);
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  return (CFCharacterSetRef)MEMORY[0x1E0C982F0](theSetIdentifier);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1E0C98350](cf);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
  MEMORY[0x1E0C98390](theData, bytes, length);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1E0C983A0](allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return (CFDataRef)MEMORY[0x1E0C983B0](allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x1E0C983B8](allocator, capacity);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  return (CFMutableDataRef)MEMORY[0x1E0C983C0](allocator, capacity, theData);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1E0C983C8](allocator, bytes, length, bytesDeallocator);
}

void CFDataDeleteBytes(CFMutableDataRef theData, CFRange range)
{
  MEMORY[0x1E0C983D0](theData, range.location, range.length);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1E0C983E0](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
  MEMORY[0x1E0C983F0](theData, range.location, range.length, buffer);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1E0C983F8](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x1E0C98408](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1E0C98418]();
}

void CFDataIncreaseLength(CFMutableDataRef theData, CFIndex extraLength)
{
  MEMORY[0x1E0C98420](theData, extraLength);
}

void CFDataReplaceBytes(CFMutableDataRef theData, CFRange range, const UInt8 *newBytes, CFIndex newLength)
{
  MEMORY[0x1E0C98428](theData, range.location, range.length, newBytes, newLength);
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
  MEMORY[0x1E0C98430](theData, length);
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)MEMORY[0x1E0C98448](allocator, at);
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return (CFDateFormatterRef)MEMORY[0x1E0C98460](allocator, locale, dateStyle, timeStyle);
}

CFStringRef CFDateFormatterCreateStringWithDate(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFDateRef date)
{
  return (CFStringRef)MEMORY[0x1E0C98490](allocator, formatter, date);
}

Boolean CFDateFormatterGetAbsoluteTimeFromString(CFDateFormatterRef formatter, CFStringRef string, CFRange *rangep, CFAbsoluteTime *atp)
{
  return MEMORY[0x1E0C98498](formatter, string, rangep, atp);
}

void CFDateFormatterSetFormat(CFDateFormatterRef formatter, CFStringRef formatString)
{
  MEMORY[0x1E0C984C0](formatter, formatString);
}

void CFDateFormatterSetProperty(CFDateFormatterRef formatter, CFStringRef key, CFTypeRef value)
{
  MEMORY[0x1E0C984C8](formatter, key, value);
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C984D8](theDate);
  return result;
}

CFTimeInterval CFDateGetTimeIntervalSinceDate(CFDateRef theDate, CFDateRef otherDate)
{
  CFTimeInterval result;

  MEMORY[0x1E0C984E0](theDate, otherDate);
  return result;
}

CFTypeID CFDateGetTypeID(void)
{
  return MEMORY[0x1E0C984E8]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98500](theDict, key, value);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98508](theDict, applier, context);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1E0C98518](theDict, key);
}

Boolean CFDictionaryContainsValue(CFDictionaryRef theDict, const void *value)
{
  return MEMORY[0x1E0C98520](theDict, value);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98530](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98538](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98550](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98558](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1E0C98570](theDict);
}

CFIndex CFDictionaryGetCountOfKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1E0C98578](theDict, key);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  MEMORY[0x1E0C985A0](theDict, keys, values);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1E0C985A8]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1E0C985B8](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1E0C985C8](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  MEMORY[0x1E0C985D8](theDict);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x1E0C985E8](theDict, key);
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C985F8](theDict, key, value);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98610](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1E0C98620](cf1, cf2);
}

CFStringRef CFErrorCopyFailureReason(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1E0C98638](err);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98648](err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x1E0C98650](allocator, domain, code, userInfo);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x1E0C98660](err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return (CFErrorDomain)MEMORY[0x1E0C98670](err);
}

CFTypeID CFErrorGetTypeID(void)
{
  return MEMORY[0x1E0C98678]();
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x1E0C98718](cf);
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  return MEMORY[0x1E0C98720](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1E0C98738](cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1E0C98758](cf);
}

uint64_t CFHashBytes()
{
  return MEMORY[0x1E0C98760]();
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return (CFLocaleRef)MEMORY[0x1E0C98770]();
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return (CFLocaleRef)MEMORY[0x1E0C98798](allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes(CFAllocatorRef allocator, LangCode lcode, RegionCode rcode)
{
  return (CFLocaleIdentifier)MEMORY[0x1E0C987A8](allocator, lcode, rcode);
}

uint64_t CFLog()
{
  return MEMORY[0x1E0C98808]();
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  MEMORY[0x1E0C988B0](center, observer, callBack, name, object, suspensionBehavior);
}

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988D0]();
}

CFTypeID CFNotificationCenterGetTypeID(void)
{
  return MEMORY[0x1E0C988D8]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
  MEMORY[0x1E0C988E0](center, name, object, userInfo, deliverImmediately);
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
  MEMORY[0x1E0C98900](center, observer, name, object);
}

CFTypeID CFNullGetTypeID(void)
{
  return MEMORY[0x1E0C98908]();
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  return MEMORY[0x1E0C98910](number, otherNumber, context);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1E0C98928](allocator, theType, valuePtr);
}

CFNumberFormatterRef CFNumberFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFNumberFormatterStyle style)
{
  return (CFNumberFormatterRef)MEMORY[0x1E0C98938](allocator, locale, style);
}

Boolean CFNumberFormatterGetValueFromString(CFNumberFormatterRef formatter, CFStringRef string, CFRange *rangep, CFNumberType numberType, void *valuePtr)
{
  return MEMORY[0x1E0C98978](formatter, string, rangep, numberType, valuePtr);
}

CFIndex CFNumberGetByteSize(CFNumberRef number)
{
  return MEMORY[0x1E0C98990](number);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return MEMORY[0x1E0C989A8](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1E0C989B8]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1E0C989C0](number, theType, valuePtr);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A40](key, applicationID);
}

CFArrayRef CFPreferencesCopyKeyList(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFArrayRef)MEMORY[0x1E0C98A50](applicationID, userName, hostName);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98A60](key, applicationID, userName, hostName);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1E0C98A70](key, applicationID, keyExistsAndHasValidFormat);
}

CFIndex CFPreferencesGetAppIntegerValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1E0C98A78](key, applicationID, keyExistsAndHasValidFormat);
}

void CFPreferencesSetValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  MEMORY[0x1E0C98A90](key, value, applicationID, userName, hostName);
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return MEMORY[0x1E0C98A98](applicationID, userName, hostName);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1E0C98AA0](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateDeepCopy(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFOptionFlags mutabilityOption)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AB0](allocator, propertyList, mutabilityOption);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AD0](allocator, data, options, format, error);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1E0C98AE0](allocator, stream, streamLength, options, format, error);
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x1E0C98B48](alloc, fileURL);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1E0C98B80](stream);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98BD0](cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98BF8](rl, source, mode);
}

void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98C00](rl, timer, mode);
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return (CFRunLoopRef)MEMORY[0x1E0C98C30]();
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98C90](rl, source, mode);
}

void CFRunLoopRun(void)
{
  MEMORY[0x1E0C98CA8]();
}

CFRunLoopRunResult CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
{
  return MEMORY[0x1E0C98CB0](mode, returnAfterSourceHandled, seconds);
}

void CFRunLoopStop(CFRunLoopRef rl)
{
  MEMORY[0x1E0C98D00](rl);
}

CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context)
{
  return (CFRunLoopTimerRef)MEMORY[0x1E0C98D08](allocator, flags, order, callout, context, fireDate, interval);
}

CFTimeInterval CFRunLoopTimerGetInterval(CFRunLoopTimerRef timer)
{
  CFTimeInterval result;

  MEMORY[0x1E0C98D28](timer);
  return result;
}

void CFRunLoopTimerInvalidate(CFRunLoopTimerRef timer)
{
  MEMORY[0x1E0C98D48](timer);
}

Boolean CFRunLoopTimerIsValid(CFRunLoopTimerRef timer)
{
  return MEMORY[0x1E0C98D50](timer);
}

void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef timer, CFAbsoluteTime fireDate)
{
  MEMORY[0x1E0C98D58](timer, fireDate);
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
  MEMORY[0x1E0C98D68](rl);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98D70](theSet, value);
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
  MEMORY[0x1E0C98D78](theSet, applier, context);
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1E0C98D80](theSet, value);
}

CFSetRef CFSetCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFSetCallBacks *callBacks)
{
  return (CFSetRef)MEMORY[0x1E0C98D88](allocator, values, numValues, callBacks);
}

CFSetRef CFSetCreateCopy(CFAllocatorRef allocator, CFSetRef theSet)
{
  return (CFSetRef)MEMORY[0x1E0C98D90](allocator, theSet);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1E0C98D98](allocator, capacity, callBacks);
}

CFMutableSetRef CFSetCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFSetRef theSet)
{
  return (CFMutableSetRef)MEMORY[0x1E0C98DA0](allocator, capacity, theSet);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1E0C98DA8](theSet);
}

CFTypeID CFSetGetTypeID(void)
{
  return MEMORY[0x1E0C98DB8]();
}

const void *__cdecl CFSetGetValue(CFSetRef theSet, const void *value)
{
  return (const void *)MEMORY[0x1E0C98DC0](theSet, value);
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
  MEMORY[0x1E0C98DD0](theSet, values);
}

void CFSetRemoveAllValues(CFMutableSetRef theSet)
{
  MEMORY[0x1E0C98DD8](theSet);
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98DE0](theSet, value);
}

void CFSetSetValue(CFMutableSetRef theSet, const void *value)
{
  MEMORY[0x1E0C98DF0](theSet, value);
}

void CFShow(CFTypeRef obj)
{
  MEMORY[0x1E0C98DF8](obj);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
  MEMORY[0x1E0C98ED8](theString, appendedString);
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
  MEMORY[0x1E0C98EE0](theString, cStr, *(_QWORD *)&encoding);
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  MEMORY[0x1E0C98EF0](theString, formatOptions, format);
}

void CFStringAppendFormatAndArguments(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  MEMORY[0x1E0C98EF8](theString, formatOptions, format, arguments);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F10](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C98F18](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions);
}

CFStringEncoding CFStringConvertNSStringEncodingToEncoding(unint64_t encoding)
{
  return MEMORY[0x1E0C98F48](encoding);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1E0C98F78](alloc, theString);
}

CFDataRef CFStringCreateExternalRepresentation(CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  return (CFDataRef)MEMORY[0x1E0C98F80](alloc, theString, *(_QWORD *)&encoding, lossByte);
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98F88](alloc, data, *(_QWORD *)&encoding);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F90](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1E0C98F98](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1E0C98FB8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1E0C98FC8](alloc, bytes, numBytes, *(_QWORD *)&encoding, isExternalRepresentation, contentsDeallocator);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98FD0](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1E0C98FE0](alloc, cStr, *(_QWORD *)&encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1E0C99018](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x1E0C99020](alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithPascalString(CFAllocatorRef alloc, ConstStr255Param pStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C99028](alloc, pStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1E0C99030](alloc, str, range.location, range.length);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3;
  CFIndex v4;
  CFRange result;

  v3 = MEMORY[0x1E0C99050](theString, stringToFind, compareOptions);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1E0C99058](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

Boolean CFStringFindCharacterFromSet(CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1E0C99060](theString, theSet, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1E0C99068](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1E0C99080](theString, range.location, range.length, *(_QWORD *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99098](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1E0C990A0](theString, *(_QWORD *)&encoding);
}

double CFStringGetDoubleValue(CFStringRef str)
{
  double result;

  MEMORY[0x1E0C990D0](str);
  return result;
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C990E0](string, buffer, maxBufLen);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x1E0C990F0](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1E0C99100](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99118](length, *(_QWORD *)&encoding);
}

Boolean CFStringGetPascalString(CFStringRef theString, StringPtr buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1E0C99148](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return MEMORY[0x1E0C99168]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1E0C99170]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1E0C99180](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x1E0C99190](theString, suffix);
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
  MEMORY[0x1E0C991B8](str, idx, insertedStr);
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  MEMORY[0x1E0C991D0](theString, locale);
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  return (CFTimeZoneRef)MEMORY[0x1E0C99280]();
}

CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(CFAllocatorRef allocator, CFTimeInterval ti)
{
  return (CFTimeZoneRef)MEMORY[0x1E0C99290](allocator, ti);
}

Boolean CFURLCanBeDecomposed(CFURLRef anURL)
{
  return MEMORY[0x1E0C992B0](anURL);
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1E0C992C8](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1E0C992D8](anURL, pathStyle);
}

CFStringRef CFURLCopyHostName(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C992F0](anURL);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1E0C992F8](url);
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C99318](anURL);
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1E0C99320](url);
}

Boolean CFURLCopyResourcePropertyForKey(CFURLRef url, CFStringRef key, void *propertyValueTypeRefPtr, CFErrorRef *error)
{
  return MEMORY[0x1E0C99338](url, key, propertyValueTypeRefPtr, error);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C99348](anURL);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99380](allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateCopyAppendingPathExtension(CFAllocatorRef allocator, CFURLRef url, CFStringRef extension)
{
  return (CFURLRef)MEMORY[0x1E0C99388](allocator, url, extension);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1E0C99390](allocator, url);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C993C8](allocator, buffer, bufLen, isDirectory);
}

CFStringRef CFURLCreateStringByAddingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveUnescaped, CFStringRef legalURLCharactersToBeEscaped, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C993F8](allocator, originalString, charactersToLeaveUnescaped, legalURLCharactersToBeEscaped, *(_QWORD *)&encoding);
}

CFStringRef CFURLCreateStringByReplacingPercentEscapesUsingEncoding(CFAllocatorRef allocator, CFStringRef origString, CFStringRef charsToLeaveEscaped, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C99408](allocator, origString, charsToLeaveEscaped, *(_QWORD *)&encoding);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99420](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1E0C99448](allocator, URLString, baseURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1E0C99490](url, resolveAgainstBase, buffer, maxBufLen);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1E0C994A0](anURL);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x1E0C994B8]();
}

Boolean CFURLHasDirectoryPath(CFURLRef anURL)
{
  return MEMORY[0x1E0C994C0](anURL);
}

Boolean CFURLStartAccessingSecurityScopedResource(CFURLRef url)
{
  return MEMORY[0x1E0C994F0](url);
}

void CFURLStopAccessingSecurityScopedResource(CFURLRef url)
{
  MEMORY[0x1E0C994F8](url);
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x1E0C99518](alloc);
}

CFUUIDRef CFUUIDCreateFromString(CFAllocatorRef alloc, CFStringRef uuidStr)
{
  return (CFUUIDRef)MEMORY[0x1E0C99520](alloc, uuidStr);
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x1E0C99530](alloc, *(_QWORD *)&bytes.byte0, *(_QWORD *)&bytes.byte8);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x1E0C99538](alloc, uuid);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)MEMORY[0x1E0C99558](alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  uint64_t v1;
  uint64_t v2;
  CFUUIDBytes result;

  v1 = MEMORY[0x1E0C99568](uuid);
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

CGColorRef CGColorCreate(CGColorSpaceRef space, const CGFloat *components)
{
  return (CGColorRef)MEMORY[0x1E0C9BC78](space, components);
}

BOOL CGColorEqualToColor(CGColorRef color1, CGColorRef color2)
{
  return MEMORY[0x1E0C9BCD8](color1, color2);
}

CGColorSpaceRef CGColorGetColorSpace(CGColorRef color)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BD00](color);
}

const CGFloat *__cdecl CGColorGetComponents(CGColorRef color)
{
  return (const CGFloat *)MEMORY[0x1E0C9BD08](color);
}

size_t CGColorGetNumberOfComponents(CGColorRef color)
{
  return MEMORY[0x1E0C9BD20](color);
}

CFTypeID CGColorGetTypeID(void)
{
  return MEMORY[0x1E0C9BD38]();
}

void CGColorRelease(CGColorRef color)
{
  MEMORY[0x1E0C9BD60](color);
}

CGColorRef CGColorRetain(CGColorRef color)
{
  return (CGColorRef)MEMORY[0x1E0C9BD68](color);
}

CFPropertyListRef CGColorSpaceCopyPropertyList(CGColorSpaceRef space)
{
  return (CFPropertyListRef)MEMORY[0x1E0C9BDC0](space);
}

CGColorSpaceRef CGColorSpaceCreateWithName(CFStringRef name)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE50](name);
}

CGColorSpaceRef CGColorSpaceCreateWithPropertyList(CFPropertyListRef plist)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE60](plist);
}

CGColorSpaceModel CGColorSpaceGetModel(CGColorSpaceRef space)
{
  return MEMORY[0x1E0C9BEC8](space);
}

CFTypeID CGColorSpaceGetTypeID(void)
{
  return MEMORY[0x1E0C9BEF8]();
}

void CGColorSpaceRelease(CGColorSpaceRef space)
{
  MEMORY[0x1E0C9BF30](space);
}

CFDictionaryRef CGPointCreateDictionaryRepresentation(CGPoint point)
{
  return (CFDictionaryRef)MEMORY[0x1E0C9D528]((__n128)point, *(__n128 *)&point.y);
}

BOOL CGPointMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGPoint *point)
{
  return MEMORY[0x1E0C9D530](dict, point);
}

CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect a1)
{
  return (CFDictionaryRef)MEMORY[0x1E0C9D560]((__n128)a1.origin, *(__n128 *)&a1.origin.y, (__n128)a1.size, *(__n128 *)&a1.size.height);
}

CGFloat CGRectGetHeight(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D580]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D588]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMaxY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5A0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5C0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMinY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5C8]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetWidth(CGRect rect)
{
  CGFloat result;

  MEMORY[0x1E0C9D5D0]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

BOOL CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect)
{
  return MEMORY[0x1E0C9D620](dict, rect);
}

CGRect CGRectOffset(CGRect rect, CGFloat dx, CGFloat dy)
{
  double v3;
  double v4;
  double v5;
  double v6;
  CGRect result;

  MEMORY[0x1E0C9D630]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, dx, dy);
  result.size.height = v6;
  result.size.width = v5;
  result.origin.y = v4;
  result.origin.x = v3;
  return result;
}

CFDictionaryRef CGSizeCreateDictionaryRepresentation(CGSize size)
{
  return (CFDictionaryRef)MEMORY[0x1E0C9D808]((__n128)size, *(__n128 *)&size.height);
}

BOOL CGSizeMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGSize *size)
{
  return MEMORY[0x1E0C9D818](dict, size);
}

CFTypeRef CVBufferCopyAttachment(CVBufferRef buffer, CFStringRef key, CVAttachmentMode *attachmentMode)
{
  return (CFTypeRef)MEMORY[0x1E0CA8900](buffer, key, attachmentMode);
}

CFDictionaryRef CVBufferCopyAttachments(CVBufferRef buffer, CVAttachmentMode attachmentMode)
{
  return (CFDictionaryRef)MEMORY[0x1E0CA8908](buffer, *(_QWORD *)&attachmentMode);
}

CFTypeRef CVBufferGetAttachment(CVBufferRef buffer, CFStringRef key, CVAttachmentMode *attachmentMode)
{
  return (CFTypeRef)MEMORY[0x1E0CA8910](buffer, key, attachmentMode);
}

void CVBufferRemoveAllAttachments(CVBufferRef buffer)
{
  MEMORY[0x1E0CA8938](buffer);
}

void CVBufferRemoveAttachment(CVBufferRef buffer, CFStringRef key)
{
  MEMORY[0x1E0CA8940](buffer, key);
}

void CVBufferSetAttachment(CVBufferRef buffer, CFStringRef key, CFTypeRef value, CVAttachmentMode attachmentMode)
{
  MEMORY[0x1E0CA8950](buffer, key, value, *(_QWORD *)&attachmentMode);
}

void CVBufferSetAttachments(CVBufferRef buffer, CFDictionaryRef theAttachments, CVAttachmentMode attachmentMode)
{
  MEMORY[0x1E0CA8958](buffer, theAttachments, *(_QWORD *)&attachmentMode);
}

int CVColorPrimariesGetIntegerCodePointForString(CFStringRef colorPrimariesString)
{
  return MEMORY[0x1E0CA8960](colorPrimariesString);
}

CFStringRef CVColorPrimariesGetStringForIntegerCodePoint(int colorPrimariesCodePoint)
{
  return (CFStringRef)MEMORY[0x1E0CA8968](*(_QWORD *)&colorPrimariesCodePoint);
}

uint64_t CVDataBufferCreateWithIOSurface()
{
  return MEMORY[0x1E0CA8978]();
}

uint64_t CVDataBufferGetDataSize()
{
  return MEMORY[0x1E0CA8988]();
}

uint64_t CVDataBufferGetIOSurface()
{
  return MEMORY[0x1E0CA8990]();
}

uint64_t CVDataBufferGetPixelFormatType()
{
  return MEMORY[0x1E0CA8998]();
}

uint64_t CVDataBufferGetTypeID()
{
  return MEMORY[0x1E0CA89A0]();
}

CGSize CVImageBufferGetEncodedSize(CVImageBufferRef imageBuffer)
{
  double v1;
  double v2;
  CGSize result;

  MEMORY[0x1E0CA89F0](imageBuffer);
  result.height = v2;
  result.width = v1;
  return result;
}

CVReturn CVPixelBufferCreate(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1E0CA8A98](allocator, width, height, *(_QWORD *)&pixelFormatType, pixelBufferAttributes, pixelBufferOut);
}

uint64_t CVPixelBufferCreateWithBufferBacking()
{
  return MEMORY[0x1E0CA8AB0]();
}

CVReturn CVPixelBufferCreateWithBytes(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, void *baseAddress, size_t bytesPerRow, CVPixelBufferReleaseBytesCallback releaseCallback, void *releaseRefCon, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1E0CA8AB8](allocator, width, height, *(_QWORD *)&pixelFormatType, baseAddress, bytesPerRow, releaseCallback, releaseRefCon);
}

CVReturn CVPixelBufferCreateWithIOSurface(CFAllocatorRef allocator, IOSurfaceRef surface, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1E0CA8AC0](allocator, surface, pixelBufferAttributes, pixelBufferOut);
}

CVReturn CVPixelBufferCreateWithPlanarBytes(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, void *dataPtr, size_t dataSize, size_t numberOfPlanes, void **planeBaseAddress, size_t *planeWidth, size_t *planeHeight, size_t *planeBytesPerRow, CVPixelBufferReleasePlanarBytesCallback releaseCallback, void *releaseRefCon, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1E0CA8AC8](allocator, width, height, *(_QWORD *)&pixelFormatType, dataPtr, dataSize, numberOfPlanes, planeBaseAddress);
}

void *__cdecl CVPixelBufferGetBaseAddress(CVPixelBufferRef pixelBuffer)
{
  return (void *)MEMORY[0x1E0CA8AE0](pixelBuffer);
}

uint64_t CVPixelBufferGetBufferBacking()
{
  return MEMORY[0x1E0CA8AF0]();
}

size_t CVPixelBufferGetBytesPerRow(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8AF8](pixelBuffer);
}

size_t CVPixelBufferGetDataSize(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B08](pixelBuffer);
}

void CVPixelBufferGetExtendedPixels(CVPixelBufferRef pixelBuffer, size_t *extraColumnsOnLeft, size_t *extraColumnsOnRight, size_t *extraRowsOnTop, size_t *extraRowsOnBottom)
{
  MEMORY[0x1E0CA8B10](pixelBuffer, extraColumnsOnLeft, extraColumnsOnRight, extraRowsOnTop, extraRowsOnBottom);
}

size_t CVPixelBufferGetHeight(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B20](pixelBuffer);
}

IOSurfaceRef CVPixelBufferGetIOSurface(CVPixelBufferRef pixelBuffer)
{
  return (IOSurfaceRef)MEMORY[0x1E0CA8B30](pixelBuffer);
}

OSType CVPixelBufferGetPixelFormatType(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B38](pixelBuffer);
}

size_t CVPixelBufferGetPlaneCount(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B40](pixelBuffer);
}

CFTypeID CVPixelBufferGetTypeID(void)
{
  return MEMORY[0x1E0CA8B48]();
}

size_t CVPixelBufferGetWidth(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B50](pixelBuffer);
}

CVReturn CVPixelBufferLockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags lockFlags)
{
  return MEMORY[0x1E0CA8B70](pixelBuffer, lockFlags);
}

CVReturn CVPixelBufferUnlockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags unlockFlags)
{
  return MEMORY[0x1E0CA8C00](pixelBuffer, unlockFlags);
}

uint64_t CVPixelFormatDescriptionGetDescriptionWithPixelFormatType()
{
  return MEMORY[0x1E0CA8C10]();
}

int CVTransferFunctionGetIntegerCodePointForString(CFStringRef transferFunctionString)
{
  return MEMORY[0x1E0CA8C30](transferFunctionString);
}

CFStringRef CVTransferFunctionGetStringForIntegerCodePoint(int transferFunctionCodePoint)
{
  return (CFStringRef)MEMORY[0x1E0CA8C38](*(_QWORD *)&transferFunctionCodePoint);
}

int CVYCbCrMatrixGetIntegerCodePointForString(CFStringRef yCbCrMatrixString)
{
  return MEMORY[0x1E0CA8C40](yCbCrMatrixString);
}

CFStringRef CVYCbCrMatrixGetStringForIntegerCodePoint(int yCbCrMatrixCodePoint)
{
  return (CFStringRef)MEMORY[0x1E0CA8C48](*(_QWORD *)&yCbCrMatrixCodePoint);
}

DNSServiceErrorType DNSServiceGetAddrInfo(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, DNSServiceProtocol protocol, const char *hostname, DNSServiceGetAddrInfoReply callBack, void *context)
{
  return MEMORY[0x1E0C80458](sdRef, *(_QWORD *)&flags, *(_QWORD *)&interfaceIndex, *(_QWORD *)&protocol, hostname, callBack, context);
}

void DNSServiceRefDeallocate(DNSServiceRef sdRef)
{
  MEMORY[0x1E0C80490](sdRef);
}

DNSServiceErrorType DNSServiceSetDispatchQueue(DNSServiceRef service, dispatch_queue_t queue)
{
  return MEMORY[0x1E0C804C8](service, queue);
}

uint64_t FigCaptureCopySerializableKeys()
{
  return MEMORY[0x1E0D054A0]();
}

kern_return_t IOCreatePlugInInterfaceForService(io_service_t service, CFUUIDRef pluginType, CFUUIDRef interfaceType, IOCFPlugInInterface ***theInterface, SInt32 *theScore)
{
  return MEMORY[0x1E0CBAE08](*(_QWORD *)&service, pluginType, interfaceType, theInterface, theScore);
}

kern_return_t IODestroyPlugInInterface(IOCFPlugInInterface **interface)
{
  return MEMORY[0x1E0CBAE40](interface);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return MEMORY[0x1E0CBB668](*(_QWORD *)&iterator);
}

kern_return_t IOMainPort(mach_port_t bootstrapPort, mach_port_t *mainPort)
{
  return MEMORY[0x1E0CBB680](*(_QWORD *)&bootstrapPort, mainPort);
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return (IONotificationPortRef)MEMORY[0x1E0CBB698](*(_QWORD *)&mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
  MEMORY[0x1E0CBB6A0](notify);
}

CFRunLoopSourceRef IONotificationPortGetRunLoopSource(IONotificationPortRef notify)
{
  return (CFRunLoopSourceRef)MEMORY[0x1E0CBB6B0](notify);
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
  MEMORY[0x1E0CBB6B8](notify, queue);
}

BOOLean_t IOObjectConformsTo(io_object_t object, const io_name_t className)
{
  return MEMORY[0x1E0CBB6C8](*(_QWORD *)&object, className);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x1E0CBB6F0](*(_QWORD *)&object);
}

kern_return_t IOObjectRetain(io_object_t object)
{
  return MEMORY[0x1E0CBB6F8](*(_QWORD *)&object);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x1E0CBB900](*(_QWORD *)&entry, key, allocator, *(_QWORD *)&options);
}

kern_return_t IORegistryEntryGetChildIterator(io_registry_entry_t entry, const io_name_t plane, io_iterator_t *iterator)
{
  return MEMORY[0x1E0CBB920](*(_QWORD *)&entry, plane, iterator);
}

kern_return_t IORegistryEntryGetParentEntry(io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t *parent)
{
  return MEMORY[0x1E0CBB958](*(_QWORD *)&entry, plane, parent);
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return MEMORY[0x1E0CBB9C0](notifyPort, *(_QWORD *)&service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  return MEMORY[0x1E0CBB9C8](notifyPort, notificationType, matching, callback, refCon, notification);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x1E0CBB9E0](*(_QWORD *)&mainPort, matching);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0CBBA00](name);
}

mach_port_t IOSurfaceCreateMachPort(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBB00](buffer);
}

xpc_object_t IOSurfaceCreateXPCObject(IOSurfaceRef aSurface)
{
  return (xpc_object_t)MEMORY[0x1E0CBBB10](aSurface);
}

void IOSurfaceDecrementUseCount(IOSurfaceRef buffer)
{
  MEMORY[0x1E0CBBB18](buffer);
}

size_t IOSurfaceGetAllocSize(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBB38](buffer);
}

void *__cdecl IOSurfaceGetBaseAddress(IOSurfaceRef buffer)
{
  return (void *)MEMORY[0x1E0CBBB40](buffer);
}

IOSurfaceID IOSurfaceGetID(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBC48](buffer);
}

uint64_t IOSurfaceGetProhibitUseCount()
{
  return MEMORY[0x1E0CBBC78]();
}

void IOSurfaceIncrementUseCount(IOSurfaceRef buffer)
{
  MEMORY[0x1E0CBBD00](buffer);
}

kern_return_t IOSurfaceLock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1E0CBBD28](buffer, *(_QWORD *)&options, seed);
}

IOSurfaceRef IOSurfaceLookup(IOSurfaceID csid)
{
  return (IOSurfaceRef)MEMORY[0x1E0CBBD38](*(_QWORD *)&csid);
}

IOSurfaceRef IOSurfaceLookupFromMachPort(mach_port_t port)
{
  return (IOSurfaceRef)MEMORY[0x1E0CBBD40](*(_QWORD *)&port);
}

IOSurfaceRef IOSurfaceLookupFromXPCObject(xpc_object_t xobj)
{
  return (IOSurfaceRef)MEMORY[0x1E0CBBD48](xobj);
}

kern_return_t IOSurfaceUnlock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1E0CBBE88](buffer, *(_QWORD *)&options, seed);
}

uint64_t IOUSBDeviceDataGetBytePtr()
{
  return MEMORY[0x1E0CBBA18]();
}

uint64_t LogACQEvents()
{
  return MEMORY[0x1E0CFF6D8]();
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x1E0DE2B20]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x1E0DE2B50]();
}

uint64_t MGGetProductType()
{
  return MEMORY[0x1E0DE2B68]();
}

uint64_t MGGetSInt32Answer()
{
  return MEMORY[0x1E0DE2B70]();
}

uint64_t MGGetStringAnswer()
{
  return MEMORY[0x1E0DE2B80]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1E0CB28A0](aClassName);
}

uint64_t NSErrorToOSStatus()
{
  return MEMORY[0x1E0D1B1F0]();
}

CFDataRef SecCertificateCopyData(SecCertificateRef certificate)
{
  return (CFDataRef)MEMORY[0x1E0CD5F60](certificate);
}

CFTypeID SecCertificateGetTypeID(void)
{
  return MEMORY[0x1E0CD6050]();
}

OSStatus SecCodeCopyPath(SecStaticCodeRef staticCode, SecCSFlags flags, CFURLRef *path)
{
  return MEMORY[0x1E0CD61E8](staticCode, *(_QWORD *)&flags, path);
}

OSStatus SecCodeCopySigningInformation(SecStaticCodeRef code, SecCSFlags flags, CFDictionaryRef *information)
{
  return MEMORY[0x1E0CD61F0](code, *(_QWORD *)&flags, information);
}

OSStatus SecRequirementCreateWithStringAndErrors(CFStringRef text, SecCSFlags flags, CFErrorRef *errors, SecRequirementRef *requirement)
{
  return MEMORY[0x1E0CD65B0](text, *(_QWORD *)&flags, errors, requirement);
}

OSStatus SecStaticCodeCheckValidityWithErrors(SecStaticCodeRef staticCode, SecCSFlags flags, SecRequirementRef requirement, CFErrorRef *errors)
{
  return MEMORY[0x1E0CD65C8](staticCode, *(_QWORD *)&flags, requirement, errors);
}

OSStatus SecStaticCodeCreateWithPath(CFURLRef path, SecCSFlags flags, SecStaticCodeRef *staticCode)
{
  return MEMORY[0x1E0CD65D0](path, *(_QWORD *)&flags, staticCode);
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x1E0CD65F0](task, entitlement, error);
}

uint64_t WriteStackshotReportWithPID()
{
  return MEMORY[0x1E0D1BD40]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1E0C80928](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
  MEMORY[0x1E0C80940](a1, a2, *(_QWORD *)&a3);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x1E0C80948](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x1E0C80958](aBlock);
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1E0C9A498]();
}

uint64_t _CFRuntimeGetClassWithTypeID()
{
  return MEMORY[0x1E0C9A4A0]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1E0C9A4B0]();
}

uint64_t _CFTryRetain()
{
  return MEMORY[0x1E0C9A5A8]();
}

uint64_t _CFURLIsFileURL()
{
  return MEMORY[0x1E0C9A710]();
}

uint64_t _CFXPCCreateCFObjectFromXPCObject()
{
  return MEMORY[0x1E0C9A800]();
}

uint64_t _CFXPCCreateXPCObjectFromCFObject()
{
  return MEMORY[0x1E0C9A818]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

int __darwin_check_fd_set_overflow(int a1, const void *a2, int a3)
{
  return MEMORY[0x1E0C80AA0](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x1E0C80AC0]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1E0C80B50](*(_QWORD *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1E0C80B68]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x1E0C80C40]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1E0C80C48]();
}

uint64_t __strncat_chk()
{
  return MEMORY[0x1E0C80C50]();
}

uint64_t __strncpy_chk()
{
  return MEMORY[0x1E0C80C58]();
}

uint64_t __udivti3()
{
  return MEMORY[0x1E0C80C80]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1E0C81010]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81038](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81040](dso, log, type, format, buf, *(_QWORD *)&size);
}

uint64_t _os_log_send_and_compose_impl()
{
  return MEMORY[0x1E0C81068]();
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C810D0](dso, log, type, spid, name, format, buf, *(_QWORD *)&size);
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1E0DA88F0]();
}

void abort(void)
{
  MEMORY[0x1E0C813A8]();
}

uint64_t abort_report_np()
{
  return MEMORY[0x1E0C813B0]();
}

int accept(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1E0C813C8](*(_QWORD *)&a1, a2, a3);
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1E0C813D0](a1, *(_QWORD *)&a2);
}

uint32_t arc4random(void)
{
  return MEMORY[0x1E0C81570]();
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x1E0C81588](*(_QWORD *)&__upper_bound);
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1E0C81608](a1, a2);
}

uint64_t audiomxd_enabled()
{
  return MEMORY[0x1E0CFFC60]();
}

void audit_token_to_au32(audit_token_t *atoken, uid_t *auidp, uid_t *euidp, gid_t *egidp, uid_t *ruidp, gid_t *rgidp, pid_t *pidp, au_asid_t *asidp, au_tid_t *tidp)
{
  MEMORY[0x1E0DE40C8](atoken, auidp, euidp, egidp, ruidp, rgidp, pidp, asidp);
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1E0C816B8](a1, *(_QWORD *)&a2);
}

char **__cdecl backtrace_symbols(void *const *a1, int a2)
{
  return (char **)MEMORY[0x1E0C816C8](a1, *(_QWORD *)&a2);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x1E0C816F0](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

kern_return_t bootstrap_check_in(mach_port_t bp, const name_t service_name, mach_port_t *sp)
{
  return MEMORY[0x1E0C816F8](*(_QWORD *)&bp, service_name, sp);
}

kern_return_t bootstrap_look_up(mach_port_t bp, const name_t service_name, mach_port_t *sp)
{
  return MEMORY[0x1E0C81708](*(_QWORD *)&bp, service_name, sp);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return MEMORY[0x1E0C82668](*(_QWORD *)&__clock_id, __tp);
}

int close(int a1)
{
  return MEMORY[0x1E0C82688](*(_QWORD *)&a1);
}

size_t confstr(int a1, char *a2, size_t a3)
{
  return MEMORY[0x1E0C826D0](*(_QWORD *)&a1, a2, a3);
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x1E0C826D8](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

char *__cdecl ctime(const time_t *a1)
{
  return (char *)MEMORY[0x1E0C82B80](a1);
}

int deflate(z_streamp strm, int flush)
{
  return MEMORY[0x1E0DE92C0](strm, *(_QWORD *)&flush);
}

int deflateEnd(z_streamp strm)
{
  return MEMORY[0x1E0DE92D0](strm);
}

int deflateInit2_(z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)
{
  return MEMORY[0x1E0DE92D8](strm, *(_QWORD *)&level, *(_QWORD *)&method, *(_QWORD *)&windowBits, *(_QWORD *)&memLevel, *(_QWORD *)&strategy, version, *(_QWORD *)&stream_size);
}

int deflateInit_(z_streamp strm, int level, const char *version, int stream_size)
{
  return MEMORY[0x1E0DE92E0](strm, *(_QWORD *)&level, version, *(_QWORD *)&stream_size);
}

void dispatch_activate(dispatch_object_t object)
{
  MEMORY[0x1E0C82BC0](object);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82BC8](when, queue, block);
}

void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x1E0C82BD0](when, queue, context, work);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  MEMORY[0x1E0C82BE8](queue);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x1E0C82C18](queue, context, work);
}

void dispatch_barrier_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C30](queue, block);
}

void dispatch_barrier_async_and_wait_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x1E0C82C38](queue, context, work);
}

void dispatch_barrier_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x1E0C82C40](queue, context, work);
}

void dispatch_barrier_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x1E0C82C50](queue, context, work);
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1E0C82C60](flags, block);
}

intptr_t dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82C98](block, timeout);
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return (dispatch_data_t)MEMORY[0x1E0C82CB0](buffer, size, queue, destructor);
}

void *__cdecl dispatch_get_context(dispatch_object_t object)
{
  return (void *)MEMORY[0x1E0C82CF0](object);
}

dispatch_queue_t dispatch_get_current_queue(void)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82CF8]();
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1E0C82D00](identifier, flags);
}

void *__cdecl dispatch_get_specific(const void *key)
{
  return (void *)MEMORY[0x1E0C82D08](key);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1E0C82D20]();
}

void dispatch_group_enter(dispatch_group_t group)
{
  MEMORY[0x1E0C82D28](group);
}

void dispatch_group_leave(dispatch_group_t group)
{
  MEMORY[0x1E0C82D30](group);
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82D48](group, timeout);
}

uint64_t dispatch_mach_cancel()
{
  return MEMORY[0x1E0C82DB8]();
}

uint64_t dispatch_mach_connect()
{
  return MEMORY[0x1E0C82DC0]();
}

uint64_t dispatch_mach_create()
{
  return MEMORY[0x1E0C82DC8]();
}

uint64_t dispatch_mach_mig_demux()
{
  return MEMORY[0x1E0C82DD8]();
}

uint64_t dispatch_mach_msg_get_msg()
{
  return MEMORY[0x1E0C82DE8]();
}

uint64_t dispatch_mig_server()
{
  return MEMORY[0x1E0C82DF8]();
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
  MEMORY[0x1E0C82E10](predicate, context, function);
}

uint64_t dispatch_pthread_root_queue_create()
{
  return MEMORY[0x1E0C82E18]();
}

dispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t attr)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E20](attr);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E28](attr, frequency);
}

uint64_t dispatch_queue_attr_make_with_overcommit()
{
  return MEMORY[0x1E0C82E30]();
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E38](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E50](label, attr, target);
}

const char *__cdecl dispatch_queue_get_label(dispatch_queue_t queue)
{
  return (const char *)MEMORY[0x1E0C82E58](queue);
}

void *__cdecl dispatch_queue_get_specific(dispatch_queue_t queue, const void *key)
{
  return (void *)MEMORY[0x1E0C82E68](queue, key);
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
  MEMORY[0x1E0C82E80](queue, key, context, destructor);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x1E0C82E98](object);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA0](object);
}

void dispatch_retain(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA8](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1E0C82EB8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1E0C82EC8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82ED8](dsema, timeout);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
  MEMORY[0x1E0C82EE0](object, context);
}

void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer)
{
  MEMORY[0x1E0C82EE8](object, finalizer);
}

uint64_t dispatch_set_qos_class_fallback()
{
  return MEMORY[0x1E0C82EF8]();
}

void dispatch_set_qos_class_floor(dispatch_object_t object, dispatch_qos_class_t qos_class, int relative_priority)
{
  MEMORY[0x1E0C82F00](object, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
  MEMORY[0x1E0C82F08](object, queue);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x1E0C82F10](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1E0C82F20](type, handle, mask, queue);
}

uintptr_t dispatch_source_get_handle(dispatch_source_t source)
{
  return MEMORY[0x1E0C82F30](source);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F48](source, handler);
}

void dispatch_source_set_cancel_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
  MEMORY[0x1E0C82F50](source, handler);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F58](source, handler);
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
  MEMORY[0x1E0C82F60](source, handler);
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  MEMORY[0x1E0C82F78](source, start, interval, leeway);
}

intptr_t dispatch_source_testcancel(dispatch_source_t source)
{
  return MEMORY[0x1E0C82F80](source);
}

void dispatch_suspend(dispatch_object_t object)
{
  MEMORY[0x1E0C82F88](object);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82F90](queue, block);
}

void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  MEMORY[0x1E0C82FA0](queue, context, work);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

dispatch_workloop_t dispatch_workloop_create_inactive(const char *label)
{
  return (dispatch_workloop_t)MEMORY[0x1E0C82FE0](label);
}

uint64_t dispatch_workloop_set_scheduler_priority()
{
  return MEMORY[0x1E0C83010]();
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x1E0C83028](a1, a2);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1E0C83038]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1E0C83040](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1E0C83050](__handle, __symbol);
}

void exit(int a1)
{
  MEMORY[0x1E0C83278](*(_QWORD *)&a1);
}

long double exp(long double __x)
{
  long double result;

  MEMORY[0x1E0C83280](__x);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x1E0C832F8](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1E0C83300](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

int feof(FILE *a1)
{
  return MEMORY[0x1E0C83340](a1);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1E0C83370](a1);
}

int fileno(FILE *a1)
{
  return MEMORY[0x1E0C833B0](a1);
}

int flock(int a1, int a2)
{
  return MEMORY[0x1E0C83400](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

long double fmod(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C83440](__x, __y);
  return result;
}

const char *__cdecl fmtcheck(const char *a1, const char *a2)
{
  return (const char *)MEMORY[0x1E0C83450](a1, a2);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1E0C83460](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83478](a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C834A0](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

void freeaddrinfo(addrinfo *a1)
{
  MEMORY[0x1E0C834C0](a1);
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  return MEMORY[0x1E0C83528](a1, a2, a3, *(_QWORD *)&a4);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1E0C83560](*(_QWORD *)&a1, a2);
}

int fsync(int a1)
{
  return MEMORY[0x1E0C83578](*(_QWORD *)&a1);
}

uint64_t ftell(FILE *a1)
{
  return MEMORY[0x1E0C83580](a1);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x1E0C83590](*(_QWORD *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C835E0](__ptr, __size, __nitems, __stream);
}

int getaddrinfo(const char *a1, const char *a2, const addrinfo *a3, addrinfo **a4)
{
  return MEMORY[0x1E0C835F8](a1, a2, a3, a4);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x1E0C83610](a1, a2, a3, a4, *(_QWORD *)&a5);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1E0C83660](a1);
}

int getiopolicy_np(int a1, int a2)
{
  return MEMORY[0x1E0C836D0](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

pid_t getpid(void)
{
  return MEMORY[0x1E0C83760]();
}

int getpwuid_r(uid_t a1, passwd *a2, char *a3, size_t a4, passwd **a5)
{
  return MEMORY[0x1E0C837A8](*(_QWORD *)&a1, a2, a3, a4, a5);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x1E0C83820](a1, a2);
}

uid_t getuid(void)
{
  return MEMORY[0x1E0C83828]();
}

uint64_t in_audio_mx_server_process()
{
  return MEMORY[0x1E0CFFCA8]();
}

in_addr_t inet_addr(const char *a1)
{
  return MEMORY[0x1E0C83950](a1);
}

int inflate(z_streamp strm, int flush)
{
  return MEMORY[0x1E0DE93A0](strm, *(_QWORD *)&flush);
}

int inflateEnd(z_streamp strm)
{
  return MEMORY[0x1E0DE93B8](strm);
}

int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
{
  return MEMORY[0x1E0DE93C8](strm, *(_QWORD *)&windowBits, version, *(_QWORD *)&stream_size);
}

int inflateInit_(z_streamp strm, const char *version, int stream_size)
{
  return MEMORY[0x1E0DE93D0](strm, version, *(_QWORD *)&stream_size);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1E0C83A20]();
}

int kill(pid_t a1, int a2)
{
  return MEMORY[0x1E0C83A48](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

int listen(int a1, int a2)
{
  return MEMORY[0x1E0C83B80](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x1E0C83BA8](a1);
}

long double log10(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BC0](__x);
  return result;
}

long double log2(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BE8](__x);
  return result;
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C83C40](a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1E0C83C50]();
}

uint64_t mach_continuous_time(void)
{
  return MEMORY[0x1E0C83C70]();
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return MEMORY[0x1E0C83CB0](msg, *(_QWORD *)&option, *(_QWORD *)&send_size, *(_QWORD *)&rcv_size, *(_QWORD *)&rcv_name, *(_QWORD *)&timeout, *(_QWORD *)&notify);
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
  MEMORY[0x1E0C83CC0](a1);
}

kern_return_t mach_port_allocate(ipc_space_t task, mach_port_right_t right, mach_port_name_t *name)
{
  return MEMORY[0x1E0C83CE0](*(_QWORD *)&task, *(_QWORD *)&right, name);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1E0C83CF8](*(_QWORD *)&task, *(_QWORD *)&name);
}

kern_return_t mach_port_get_attributes(ipc_space_read_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info_out, mach_msg_type_number_t *port_info_outCnt)
{
  return MEMORY[0x1E0C83D20](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&flavor, port_info_out, port_info_outCnt);
}

kern_return_t mach_port_insert_right(ipc_space_t task, mach_port_name_t name, mach_port_t poly, mach_msg_type_name_t polyPoly)
{
  return MEMORY[0x1E0C83D48](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&poly, *(_QWORD *)&polyPoly);
}

kern_return_t mach_port_mod_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return MEMORY[0x1E0C83D58](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&right, *(_QWORD *)&delta);
}

kern_return_t mach_port_set_attributes(ipc_space_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info, mach_msg_type_number_t port_infoCnt)
{
  return MEMORY[0x1E0C83D78](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&flavor, port_info, *(_QWORD *)&port_infoCnt);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1E0C83DB8](info);
}

malloc_zone_t *__cdecl malloc_create_zone(vm_size_t start_size, unsigned int flags)
{
  return (malloc_zone_t *)MEMORY[0x1E0C83E78](start_size, *(_QWORD *)&flags);
}

malloc_zone_t *malloc_default_zone(void)
{
  return (malloc_zone_t *)MEMORY[0x1E0C83E88]();
}

const char *__cdecl malloc_get_zone_name(malloc_zone_t *zone)
{
  return (const char *)MEMORY[0x1E0C83EA8](zone);
}

void malloc_set_zone_name(malloc_zone_t *zone, const char *name)
{
  MEMORY[0x1E0C83ED8](zone, name);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF8](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F10](ptr, size, type_id);
}

void *__cdecl malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F20](zone, count, size, type_id);
}

void *__cdecl malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F40](zone, ptr, size, type_id);
}

void malloc_zone_free(malloc_zone_t *zone, void *ptr)
{
  MEMORY[0x1E0C83F70](zone, ptr);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1E0C84070](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

void mig_dealloc_reply_port(mach_port_t reply_port)
{
  MEMORY[0x1E0C840E8](*(_QWORD *)&reply_port);
}

mach_port_t mig_get_reply_port(void)
{
  return MEMORY[0x1E0C84100]();
}

void mig_put_reply_port(mach_port_t reply_port)
{
  MEMORY[0x1E0C84110](*(_QWORD *)&reply_port);
}

int mig_strncpy(char *dest, const char *src, int len)
{
  return MEMORY[0x1E0C84120](dest, src, *(_QWORD *)&len);
}

int mig_strncpy_zerofill(char *dest, const char *src, int len)
{
  return MEMORY[0x1E0C84128](dest, src, *(_QWORD *)&len);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1E0C84160](a1, a2);
}

char *__cdecl mkdtemp(char *a1)
{
  return (char *)MEMORY[0x1E0C84170](a1);
}

int mkstemp(char *a1)
{
  return MEMORY[0x1E0C841A0](a1);
}

int mkstemps(char *a1, int a2)
{
  return MEMORY[0x1E0C841B0](a1, *(_QWORD *)&a2);
}

long double modf(long double __x, long double *__y)
{
  long double result;

  MEMORY[0x1E0C841E0](__y, __x);
  return result;
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1E0C84220](a1, a2);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1E0C843D8](*(_QWORD *)&token);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x1E0C843F8](name);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1E0C84408](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1E0DE7BA8](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1E0DE7BB8]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7BD0](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x1E0DE7BD8](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x1E0DE7BE0]();
}

void objc_copyWeak(id *to, id *from)
{
  MEMORY[0x1E0DE7C38](to, from);
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x1E0DE7C60](location);
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x1E0DE7C90](obj);
}

id objc_getAssociatedObject(id object, const void *key)
{
  return (id)MEMORY[0x1E0DE7CA8](object, key);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1E0DE7CB0](name);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1E0DE7CE0](location, val);
}

id objc_loadWeak(id *location)
{
  return (id)MEMORY[0x1E0DE7D00](location);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1E0DE7D08](location);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D20](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D30](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1E0DE7D38]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1E0DE7D40]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1E0DE7D48]();
}

void objc_release(id a1)
{
  MEMORY[0x1E0DE7D78](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1E0DE7E50](a1);
}

void objc_setAssociatedObject(id object, const void *key, id value, void *policy)
{
  MEMORY[0x1E0DE7F40](object, key, value, policy);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1E0DE7FB8](location, obj);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1E0C84480](a1, *(_QWORD *)&a2);
}

uint64_t os_eventlink_activate()
{
  return MEMORY[0x1E0C84698]();
}

uint64_t os_eventlink_associate()
{
  return MEMORY[0x1E0C846A0]();
}

uint64_t os_eventlink_cancel()
{
  return MEMORY[0x1E0C846A8]();
}

uint64_t os_eventlink_create()
{
  return MEMORY[0x1E0C846B0]();
}

uint64_t os_eventlink_create_with_port()
{
  return MEMORY[0x1E0C846B8]();
}

uint64_t os_eventlink_extract_remote_port()
{
  return MEMORY[0x1E0C846C0]();
}

uint64_t os_eventlink_signal()
{
  return MEMORY[0x1E0C846C8]();
}

uint64_t os_eventlink_signal_and_wait()
{
  return MEMORY[0x1E0C846D0]();
}

uint64_t os_eventlink_wait()
{
  return MEMORY[0x1E0C846E0]();
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1E0C84728](subsystem, category);
}

uint64_t os_log_pack_compose()
{
  return MEMORY[0x1E0C84738]();
}

uint64_t os_log_pack_send()
{
  return MEMORY[0x1E0C84740]();
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1E0C84780](oslog, type);
}

uint64_t os_log_with_args()
{
  return MEMORY[0x1E0C84790]();
}

void os_release(void *object)
{
  MEMORY[0x1E0C84910](object);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1E0C84920](log);
}

os_signpost_id_t os_signpost_id_generate(os_log_t log)
{
  return MEMORY[0x1E0C84928](log);
}

uint64_t os_state_add_handler()
{
  return MEMORY[0x1E0C84940]();
}

uint64_t os_transaction_copy_description()
{
  return MEMORY[0x1E0C84968]();
}

uint64_t os_transaction_create()
{
  return MEMORY[0x1E0C84970]();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C84998](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C849B0](lock);
}

uint64_t os_variant_has_internal_diagnostics()
{
  return MEMORY[0x1E0C849F8]();
}

int pipe(int a1[2])
{
  return MEMORY[0x1E0C84B10](a1);
}

int poll(pollfd *a1, nfds_t a2, int a3)
{
  return MEMORY[0x1E0C84B20](a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

long double pow(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C84BB8](__x, __y);
  return result;
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1E0C84BC8](*(_QWORD *)&__fd, __buf, __nbyte, a4);
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1E0C84BD0](a1);
}

int proc_name(int pid, void *buffer, uint32_t buffersize)
{
  return MEMORY[0x1E0C84C20](*(_QWORD *)&pid, buffer, *(_QWORD *)&buffersize);
}

int proc_pid_rusage(int pid, int flavor, rusage_info_t *buffer)
{
  return MEMORY[0x1E0C84C28](*(_QWORD *)&pid, *(_QWORD *)&flavor, buffer);
}

uint64_t proc_pidbind()
{
  return MEMORY[0x1E0C84C30]();
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return MEMORY[0x1E0C84C40](*(_QWORD *)&pid, *(_QWORD *)&flavor, arg, buffer, *(_QWORD *)&buffersize);
}

uint64_t proc_pidoriginatorinfo()
{
  return MEMORY[0x1E0C84C48]();
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x1E0C84CB0](a1);
}

int pthread_attr_getschedparam(const pthread_attr_t *a1, sched_param *a2)
{
  return MEMORY[0x1E0C84CB8](a1, a2);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x1E0C84CC8](a1);
}

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority)
{
  return MEMORY[0x1E0C84CD0](__attr, *(_QWORD *)&__qos_class, *(_QWORD *)&__relative_priority);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1E0C84CD8](a1, *(_QWORD *)&a2);
}

int pthread_attr_setschedparam(pthread_attr_t *a1, const sched_param *a2)
{
  return MEMORY[0x1E0C84CE8](a1, a2);
}

int pthread_attr_setschedpolicy(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1E0C84CF0](a1, *(_QWORD *)&a2);
}

int pthread_attr_setstacksize(pthread_attr_t *a1, size_t a2)
{
  return MEMORY[0x1E0C84D00](a1, a2);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return MEMORY[0x1E0C84D18](a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return MEMORY[0x1E0C84D20](a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return MEMORY[0x1E0C84D28](a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return MEMORY[0x1E0C84D30](a1);
}

int pthread_cond_timedwait(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return MEMORY[0x1E0C84D38](a1, a2, a3);
}

int pthread_cond_timedwait_relative_np(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return MEMORY[0x1E0C84D40](a1, a2, a3);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return MEMORY[0x1E0C84D48](a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1E0C84D50](a1, a2, a3, a4);
}

void pthread_exit(void *a1)
{
  MEMORY[0x1E0C84D88](a1);
}

int pthread_get_qos_class_np(pthread_t __pthread, qos_class_t *__qos_class, int *__relative_priority)
{
  return MEMORY[0x1E0C84D98](__pthread, __qos_class, __relative_priority);
}

void *__cdecl pthread_getspecific(pthread_key_t a1)
{
  return (void *)MEMORY[0x1E0C84DC0](a1);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x1E0C84DD8](a1, a2);
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return MEMORY[0x1E0C84DE0](a1, a2);
}

int pthread_kill(pthread_t a1, int a2)
{
  return MEMORY[0x1E0C84DF8](a1, *(_QWORD *)&a2);
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return MEMORY[0x1E0C84E00](a1);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E18](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1E0C84E20](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E28](a1);
}

int pthread_mutex_trylock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E30](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E38](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1E0C84E40](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1E0C84E48](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x1E0C84E60](a1, *(_QWORD *)&a2);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x1E0C84E68](a1, a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1E0C84ED8]();
}

int pthread_setname_np(const char *a1)
{
  return MEMORY[0x1E0C84F08](a1);
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x1E0C84F18](a1, a2);
}

int pthread_threadid_np(pthread_t a1, __uint64_t *a2)
{
  return MEMORY[0x1E0C84F38](a1, a2);
}

int puts(const char *a1)
{
  return MEMORY[0x1E0C84F60](a1);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1E0C84F68](*(_QWORD *)&__fd, __buf, __nbyte, a4);
}

ssize_t pwritev(int a1, const iovec *a2, int a3, off_t a4)
{
  return MEMORY[0x1E0C84F70](*(_QWORD *)&a1, a2, *(_QWORD *)&a3, a4);
}

qos_class_t qos_class_self(void)
{
  return MEMORY[0x1E0C84F80]();
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x1E0C84F88](__base, __nel, __width, __compar);
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1E0C85000](*(_QWORD *)&a1, a2, a3);
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return MEMORY[0x1E0C85018](a1, a2, a3);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1E0C85040](a1, a2);
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return MEMORY[0x1E0C85060](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

int removefile(const char *path, removefile_state_t state, removefile_flags_t flags)
{
  return MEMORY[0x1E0C850C0](path, state, *(_QWORD *)&flags);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  MEMORY[0x1E0C85100](__from, __to, __ec);
}

uint64_t sandbox_check_by_audit_token()
{
  return MEMORY[0x1E0C85180]();
}

uint64_t sandbox_container_path_for_pid()
{
  return MEMORY[0x1E0C85190]();
}

uint64_t sandbox_extension_consume()
{
  return MEMORY[0x1E0C851A0]();
}

uint64_t sandbox_extension_issue_file()
{
  return MEMORY[0x1E0C851A8]();
}

uint64_t sandbox_extension_issue_file_to_self()
{
  return MEMORY[0x1E0C851C0]();
}

uint64_t sandbox_extension_release()
{
  return MEMORY[0x1E0C851F8]();
}

int sched_yield(void)
{
  return MEMORY[0x1E0C85270]();
}

SEL sel_registerName(const char *str)
{
  return (SEL)MEMORY[0x1E0DE80E8](str);
}

int select(int a1, fd_set *a2, fd_set *a3, fd_set *a4, timeval *a5)
{
  return MEMORY[0x1E0C85280](*(_QWORD *)&a1, a2, a3, a4, a5);
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return MEMORY[0x1E0C852F8](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

int setenv(const char *__name, const char *__value, int __overwrite)
{
  return MEMORY[0x1E0C85328](__name, __value, *(_QWORD *)&__overwrite);
}

int setiopolicy_np(int a1, int a2, int a3)
{
  return MEMORY[0x1E0C85340](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return MEMORY[0x1E0C85388](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3, a4, *(_QWORD *)&a5);
}

int setvbuf(FILE *a1, char *a2, int a3, size_t a4)
{
  return MEMORY[0x1E0C85398](a1, a2, *(_QWORD *)&a3, a4);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return (void (__cdecl *)(int))MEMORY[0x1E0C853F0](*(_QWORD *)&a1, a2);
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x1E0C85438](*(_QWORD *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1E0C85440](__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return MEMORY[0x1E0C85450](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C854D8](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1E0C85540](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1E0C85548](*(_QWORD *)&__errnum);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return MEMORY[0x1E0C85558](a1, a2, a3, a4);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1E0C85570](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x1E0C85590](a1, a2, a3);
}

char *__cdecl strncat(char *__s1, const char *__s2, size_t __n)
{
  return (char *)MEMORY[0x1E0C855A0](__s1, __s2, __n);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1E0C855A8](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1E0C855B0](__dst, __src, __n);
}

char *__cdecl strndup(const char *__s1, size_t __n)
{
  return (char *)MEMORY[0x1E0C855B8](__s1, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x1E0C855C0](__s1, __n);
}

char *__cdecl strptime(const char *a1, const char *a2, tm *a3)
{
  return (char *)MEMORY[0x1E0C855D8](a1, a2, a3);
}

int symlink(const char *a1, const char *a2)
{
  return MEMORY[0x1E0C85718](a1, a2);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1E0C85798](a1, *(_QWORD *)&a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1E0C857A0](a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
  MEMORY[0x1E0C857D0](*(_QWORD *)&a1, a2);
}

kern_return_t thread_info(thread_inspect_t target_act, thread_flavor_t flavor, thread_info_t thread_info_out, mach_msg_type_number_t *thread_info_outCnt)
{
  return MEMORY[0x1E0C858F8](*(_QWORD *)&target_act, *(_QWORD *)&flavor, thread_info_out, thread_info_outCnt);
}

kern_return_t thread_policy_get(thread_inspect_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t *policy_infoCnt, BOOLean_t *get_default)
{
  return MEMORY[0x1E0C85900](*(_QWORD *)&thread, *(_QWORD *)&flavor, policy_info, policy_infoCnt, get_default);
}

kern_return_t thread_policy_set(thread_act_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t policy_infoCnt)
{
  return MEMORY[0x1E0C85908](*(_QWORD *)&thread, *(_QWORD *)&flavor, policy_info, *(_QWORD *)&policy_infoCnt);
}

time_t time(time_t *a1)
{
  return MEMORY[0x1E0C85950](a1);
}

int unlink(const char *a1)
{
  return MEMORY[0x1E0C859B8](a1);
}

int unsetenv(const char *a1)
{
  return MEMORY[0x1E0C859D0](a1);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x1E0C859E0](*(_QWORD *)&a1);
}

void uuid_clear(uuid_t uu)
{
  MEMORY[0x1E0C85A00](uu);
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return MEMORY[0x1E0C85A08](uu1, uu2);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
  MEMORY[0x1E0C85A10](dst, src);
}

void uuid_unparse_lower(const uuid_t uu, uuid_string_t out)
{
  MEMORY[0x1E0C85A48](uu, out);
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return MEMORY[0x1E0C85A80](*(_QWORD *)&target_task, address, size, *(_QWORD *)&flags);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x1E0C85A98](*(_QWORD *)&target_task, address, size);
}

uint64_t voucher_adopt()
{
  return MEMORY[0x1E0C85B10]();
}

uint64_t voucher_copy()
{
  return MEMORY[0x1E0C85B18]();
}

BOOLean_t voucher_mach_msg_set(mach_msg_header_t *msg)
{
  return MEMORY[0x1E0C85B60](msg);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1E0C85B98](__str, __size, __format, a4);
}

uint64_t wd_endpoint_activate()
{
  return MEMORY[0x1E0DC8A28]();
}

uint64_t wd_endpoint_add_queue()
{
  return MEMORY[0x1E0DC8A30]();
}

uint64_t wd_endpoint_register()
{
  return MEMORY[0x1E0DC8A38]();
}

uint64_t wd_endpoint_set_alive_func()
{
  return MEMORY[0x1E0DC8A40]();
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1E0C85D40](*(_QWORD *)&__fd, __buf, __nbyte);
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
  MEMORY[0x1E0C85DE0](xarray, value);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return (xpc_object_t)MEMORY[0x1E0C85E00](objects, count);
}

xpc_object_t xpc_array_create_empty(void)
{
  return (xpc_object_t)MEMORY[0x1E0C85E10]();
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return MEMORY[0x1E0C85E30](xarray);
}

const void *__cdecl xpc_array_get_data(xpc_object_t xarray, size_t index, size_t *length)
{
  return (const void *)MEMORY[0x1E0C85E40](xarray, index, length);
}

xpc_object_t xpc_array_get_dictionary(xpc_object_t xarray, size_t index)
{
  return (xpc_object_t)MEMORY[0x1E0C85E50](xarray, index);
}

int64_t xpc_array_get_int64(xpc_object_t xarray, size_t index)
{
  return MEMORY[0x1E0C85E60](xarray, index);
}

uint64_t xpc_array_get_uint64(xpc_object_t xarray, size_t index)
{
  return MEMORY[0x1E0C85E78](xarray, index);
}

xpc_object_t xpc_array_get_value(xpc_object_t xarray, size_t index)
{
  return (xpc_object_t)MEMORY[0x1E0C85E90](xarray, index);
}

void xpc_array_set_data(xpc_object_t xarray, size_t index, const void *bytes, size_t length)
{
  MEMORY[0x1E0C85EA8](xarray, index, bytes, length);
}

void xpc_array_set_int64(xpc_object_t xarray, size_t index, int64_t value)
{
  MEMORY[0x1E0C85EC0](xarray, index, value);
}

void xpc_array_set_uint64(xpc_object_t xarray, size_t index, uint64_t value)
{
  MEMORY[0x1E0C85ED8](xarray, index, value);
}

void xpc_array_set_value(xpc_object_t xarray, size_t index, xpc_object_t value)
{
  MEMORY[0x1E0C85EE8](xarray, index, value);
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return MEMORY[0x1E0C85F00](xBOOL);
}

void xpc_connection_activate(xpc_connection_t connection)
{
  MEMORY[0x1E0C85F50](connection);
}

void xpc_connection_cancel(xpc_connection_t connection)
{
  MEMORY[0x1E0C85F68](connection);
}

uint64_t xpc_connection_copy_entitlement_value()
{
  return MEMORY[0x1E0C85F78]();
}

uint64_t xpc_connection_copy_invalidation_reason()
{
  return MEMORY[0x1E0C85F80]();
}

xpc_connection_t xpc_connection_create(const char *name, dispatch_queue_t targetq)
{
  return (xpc_connection_t)MEMORY[0x1E0C85F90](name, targetq);
}

xpc_connection_t xpc_connection_create_from_endpoint(xpc_endpoint_t endpoint)
{
  return (xpc_connection_t)MEMORY[0x1E0C85FA0](endpoint);
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x1E0C85FB0](name, targetq, flags);
}

uint64_t xpc_connection_get_audit_token()
{
  return MEMORY[0x1E0C85FD0]();
}

void *__cdecl xpc_connection_get_context(xpc_connection_t connection)
{
  return (void *)MEMORY[0x1E0C85FE0](connection);
}

pid_t xpc_connection_get_pid(xpc_connection_t connection)
{
  return MEMORY[0x1E0C86008](connection);
}

void xpc_connection_resume(xpc_connection_t connection)
{
  MEMORY[0x1E0C86018](connection);
}

void xpc_connection_send_barrier(xpc_connection_t connection, dispatch_block_t barrier)
{
  MEMORY[0x1E0C86020](connection, barrier);
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
  MEMORY[0x1E0C86030](connection, message);
}

void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
  MEMORY[0x1E0C86038](connection, message, replyq, handler);
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x1E0C86048](connection, message);
}

uint64_t xpc_connection_send_notification()
{
  return MEMORY[0x1E0C86058]();
}

void xpc_connection_set_context(xpc_connection_t connection, void *context)
{
  MEMORY[0x1E0C86070](connection, context);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
  MEMORY[0x1E0C86080](connection, handler);
}

void xpc_connection_set_finalizer_f(xpc_connection_t connection, xpc_finalizer_t finalizer)
{
  MEMORY[0x1E0C86088](connection, finalizer);
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
  MEMORY[0x1E0C860C8](connection, targetq);
}

uint64_t xpc_connection_set_target_uid()
{
  return MEMORY[0x1E0C860D0]();
}

xpc_object_t xpc_data_create(const void *bytes, size_t length)
{
  return (xpc_object_t)MEMORY[0x1E0C86178](bytes, length);
}

xpc_object_t xpc_data_create_with_dispatch_data(dispatch_data_t ddata)
{
  return (xpc_object_t)MEMORY[0x1E0C86188](ddata);
}

size_t xpc_data_get_bytes(xpc_object_t xdata, void *buffer, size_t off, size_t length)
{
  return MEMORY[0x1E0C86190](xdata, buffer, off, length);
}

uint64_t xpc_dictionary_copy_mach_send()
{
  return MEMORY[0x1E0C86200]();
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1E0C86208](keys, values, count);
}

xpc_object_t xpc_dictionary_create_empty(void)
{
  return (xpc_object_t)MEMORY[0x1E0C86218]();
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return (xpc_object_t)MEMORY[0x1E0C86228](original);
}

xpc_object_t xpc_dictionary_get_array(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1E0C86248](xdict, key);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C86260](xdict, key);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return (const void *)MEMORY[0x1E0C86278](xdict, key, length);
}

double xpc_dictionary_get_double(xpc_object_t xdict, const char *key)
{
  double result;

  MEMORY[0x1E0C86298](xdict, key);
  return result;
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C862A0](xdict, key);
}

xpc_connection_t xpc_dictionary_get_remote_connection(xpc_object_t xdict)
{
  return (xpc_connection_t)MEMORY[0x1E0C862B0](xdict);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return (const char *)MEMORY[0x1E0C862C8](xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C862D0](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1E0C862E0](xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
  MEMORY[0x1E0C86310](xdict, key, value);
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
  MEMORY[0x1E0C86330](xdict, key, bytes, length);
}

void xpc_dictionary_set_double(xpc_object_t xdict, const char *key, double value)
{
  MEMORY[0x1E0C86348](xdict, key, value);
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
  MEMORY[0x1E0C86360](xdict, key, value);
}

uint64_t xpc_dictionary_set_mach_send()
{
  return MEMORY[0x1E0C86378]();
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
  MEMORY[0x1E0C86390](xdict, key, string);
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
  MEMORY[0x1E0C86398](xdict, key, value);
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
  MEMORY[0x1E0C863B8](xdict, key, value);
}

xpc_endpoint_t xpc_endpoint_create(xpc_connection_t connection)
{
  return (xpc_endpoint_t)MEMORY[0x1E0C863F0](connection);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1E0C86520](object);
}

void xpc_release(xpc_object_t object)
{
  MEMORY[0x1E0C86658](object);
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x1E0C86660](object);
}

xpc_object_t xpc_shmem_create(void *region, size_t length)
{
  return (xpc_object_t)MEMORY[0x1E0C866F0](region, length);
}

size_t xpc_shmem_map(xpc_object_t xshmem, void **region)
{
  return MEMORY[0x1E0C86700](xshmem, region);
}

