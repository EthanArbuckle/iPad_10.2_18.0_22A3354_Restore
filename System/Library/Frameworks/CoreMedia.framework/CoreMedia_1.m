void appendToSummaryChannelLayout(CFMutableDataRef theData, _DWORD *a2)
{
  _DWORD *v2;
  int v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  UInt8 *MutableBytePtr;
  _DWORD *v10;
  const UInt8 *v11;
  int v12;
  int v13;
  uint64_t v14;
  _DWORD *v15;
  _DWORD *v16;
  float *v17;
  float *v18;
  float *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  size_t size;

  v2 = a2;
  v4 = *a2;
  if (*a2 && !a2[2])
  {
    LODWORD(size) = 0;
    if (v4 == 0x10000)
    {
      v20 = (uint64_t)(a2 + 1);
      v21 = 1668116578;
    }
    else
    {
      v21 = 1668116588;
      v20 = (uint64_t)a2;
    }
    if (AudioToolbox_AudioFormatGetPropertyInfo(v21, 4, v20, (uint64_t)&size))
      return;
    if (!(_DWORD)size)
      return;
    v22 = malloc_type_calloc(1uLL, size, 0x1D2382F5uLL);
    if (!v22)
      return;
    v5 = v22;
    if (*v2 == 0x10000)
    {
      v23 = (uint64_t)(v2 + 1);
      v24 = 1668116578;
    }
    else
    {
      v24 = 1668116588;
      v23 = (uint64_t)v2;
    }
    if (AudioToolbox_AudioFormatGetProperty(v24, 4, v23, (uint64_t)&size, (uint64_t)v5))
    {
LABEL_23:
      free(v5);
      return;
    }
  }
  else
  {
    v5 = 0;
  }
  if (v5)
    v2 = v5;
  v6 = v2[2];
  if ((_DWORD)v6)
  {
    v7 = 0;
    v8 = 0;
    MutableBytePtr = 0;
    do
    {
      if (!MutableBytePtr)
      {
        MutableBytePtr = CFDataGetMutableBytePtr(theData);
        v8 = *((unsigned int *)MutableBytePtr + 2);
      }
      v10 = &v2[5 * v7];
      v13 = v10[3];
      v11 = (const UInt8 *)(v10 + 3);
      v12 = v13;
      if (v13)
      {
        if (v8)
        {
          v14 = 0;
          v15 = &v2[5 * v7];
          v16 = v15 + 4;
          v17 = (float *)(v15 + 5);
          v18 = (float *)(v15 + 6);
          v19 = (float *)(v15 + 7);
          while (v12 != *(_DWORD *)&MutableBytePtr[v14 + 12]
               || v12 == 100
               && (*v16 != *(_DWORD *)&MutableBytePtr[v14 + 16]
                || *v17 != *(float *)&MutableBytePtr[v14 + 20]
                || *v18 != *(float *)&MutableBytePtr[v14 + 24]
                || *v19 != *(float *)&MutableBytePtr[v14 + 28]))
          {
            v14 += 20;
            if (20 * v8 == v14)
              goto LABEL_20;
          }
        }
        else
        {
LABEL_20:
          *(_DWORD *)MutableBytePtr = 0;
          ++*((_DWORD *)MutableBytePtr + 2);
          CFDataAppendBytes(theData, v11, 20);
          MutableBytePtr = 0;
        }
      }
      ++v7;
    }
    while (v7 != v6);
  }
  if (v5)
    goto LABEL_23;
}

uint64_t cleanUpSummaryAndGetChannelLayoutSize(__CFData *a1)
{
  UInt8 *MutableBytePtr;
  CFIndex Length;
  unint64_t v5;
  int *v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  unint64_t i;
  UInt8 *v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  int v17;
  int v18;
  BOOL v19;
  int v20;
  int v21;
  __int128 v22;
  int v23;

  v20 = 0;
  MutableBytePtr = CFDataGetMutableBytePtr(a1);
  Length = CFDataGetLength(a1);
  if (*(_DWORD *)MutableBytePtr)
    goto LABEL_2;
  v5 = *((unsigned int *)MutableBytePtr + 2);
  if (!(_DWORD)v5)
    goto LABEL_2;
  if (*((_DWORD *)MutableBytePtr + 3) == 42)
    goto LABEL_11;
  v6 = (int *)(MutableBytePtr + 32);
  v7 = 1;
  do
  {
    v8 = v7;
    if (v5 == v7)
      break;
    v9 = *v6;
    v6 += 5;
    ++v7;
  }
  while (v9 != 42);
  if (v8 < v5)
  {
LABEL_11:
    if ((_DWORD)v5 == 1)
      goto LABEL_14;
LABEL_2:
    if (v20)
      *(_DWORD *)MutableBytePtr = v20;
    return Length;
  }
  if (v5 < 2)
    goto LABEL_2;
LABEL_14:
  v21 = 4;
  if (!AudioToolbox_AudioFormatGetProperty(1668116596, Length, (uint64_t)MutableBytePtr, (uint64_t)&v21, (uint64_t)&v20))goto LABEL_2;
  v10 = *((_DWORD *)MutableBytePtr + 2);
  if (v10)
  {
    v11 = (v10 - 1);
    if ((_DWORD)v11)
    {
      for (i = 0; i != v11; ++i)
      {
        v13 = &MutableBytePtr[20 * i + 12];
        v14 = (uint64_t)&MutableBytePtr[20 * v11 + 12];
        v15 = v11 - 1;
        do
        {
          if (*(_DWORD *)v14 < *(_DWORD *)v13)
          {
            v22 = *(_OWORD *)v13;
            v16 = v22;
            v23 = *(_DWORD *)&MutableBytePtr[20 * i + 28];
            v17 = v23;
            v18 = *(_DWORD *)(v14 + 16);
            *(_OWORD *)v13 = *(_OWORD *)v14;
            *(_DWORD *)&MutableBytePtr[20 * i + 28] = v18;
            *(_OWORD *)v14 = v16;
            *(_DWORD *)(v14 + 16) = v17;
          }
          v19 = i >= v15--;
          v14 -= 20;
        }
        while (!v19);
      }
    }
  }
  if (!AudioToolbox_AudioFormatGetProperty(1668116596, Length, (uint64_t)MutableBytePtr, (uint64_t)&v21, (uint64_t)&v20))goto LABEL_2;
  return Length;
}

uint64_t getAudioChannelCountFromLayout(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v4;
  unsigned int v5;

  result = 0;
  v5 = 0;
  if (a1 && (unint64_t)(a2 - 0x100000000) >= 0xFFFFFFFF0000000CLL)
  {
    v4 = 4;
    if (AudioToolbox_AudioFormatGetProperty(1852008557, a2, a1, (uint64_t)&v4, (uint64_t)&v5))
      return 0;
    else
      return v5;
  }
  return result;
}

Boolean CMAudioFormatDescriptionEqual(CMAudioFormatDescriptionRef formatDescription, CMAudioFormatDescriptionRef otherFormatDescription, CMAudioFormatDescriptionMask equalityMask, CMAudioFormatDescriptionMask *equalityMaskOut)
{
  char v6;
  CMAudioFormatDescriptionMask v8;
  const AudioFormatListItem *DerivedStorage;
  const AudioFormatListItem *v10;
  const AudioFormatListItem *FormatList;
  const AudioFormatListItem *v12;
  const AudioFormatListItem *v13;
  unint64_t v14;
  unint64_t v15;
  Boolean v16;
  size_t v18;
  unint64_t v19;
  size_t v20;
  Float64 mSampleRate;
  Float64 v22;
  _OWORD *v23;
  size_t v24;
  _DWORD *v25;
  const __CFDictionary *Extensions;
  const __CFDictionary *v27;
  size_t v28;
  _DWORD *v29;
  _DWORD *v30;
  size_t v31;
  _OWORD *v32;
  int v33;
  _DWORD *v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  _OWORD *v38;
  _OWORD v39[2];
  _OWORD v40[2];
  size_t v41;
  size_t sizeOut;
  int v43;
  int v44;
  _QWORD v45[3];

  v45[2] = *MEMORY[0x1E0C80C00];
  memset(v40, 0, sizeof(v40));
  memset(v39, 0, sizeof(v39));
  if (formatDescription
    && otherFormatDescription
    && (v6 = equalityMask, CMFormatDescriptionGetMediaType(formatDescription) == 1936684398)
    && CMFormatDescriptionGetMediaType(otherFormatDescription) == 1936684398)
  {
    v8 = v6 & 0xF;
    if (formatDescription != otherFormatDescription)
    {
      v41 = 0;
      sizeOut = 0;
      DerivedStorage = (const AudioFormatListItem *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)formatDescription);
      v10 = (const AudioFormatListItem *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)otherFormatDescription);
      if ((v6 & 5) != 0)
      {
        FormatList = CMAudioFormatDescriptionGetFormatList(formatDescription, &sizeOut);
        v12 = CMAudioFormatDescriptionGetFormatList(otherFormatDescription, &v41);
        v13 = v12;
        if (FormatList && sizeOut >= 0x30)
        {
          if ((unsigned __int16)FormatList->mChannelLayoutTag)
          {
            LODWORD(v40[0]) = FormatList->mChannelLayoutTag;
            v14 = (unint64_t)v40;
            v15 = 12;
          }
          else
          {
            v15 = *(_QWORD *)&DerivedStorage[1].mASBD.mFormatID;
            v14 = *(_QWORD *)&DerivedStorage[1].mASBD.mBytesPerPacket;
          }
        }
        else
        {
          v15 = *(_QWORD *)&DerivedStorage[1].mASBD.mFormatID;
          v14 = *(_QWORD *)&DerivedStorage[1].mASBD.mBytesPerPacket;
          FormatList = DerivedStorage;
        }
        if (v12 && v41 >= 0x30)
        {
          if ((unsigned __int16)v12->mChannelLayoutTag)
          {
            LODWORD(v39[0]) = v12->mChannelLayoutTag;
            v19 = (unint64_t)v39;
            v18 = 12;
            if ((v6 & 1) != 0)
            {
LABEL_47:
              v28 = v18;
              v37 = v15;
              v38 = (_OWORD *)v19;
              v29 = (_DWORD *)v14;
              if (!memcmp(FormatList, v13, 0x24uLL))
              {
                v16 = 1;
                v14 = (unint64_t)v29;
                v15 = v37;
                v19 = (unint64_t)v38;
                v18 = v28;
              }
              else
              {
                if (!equalityMaskOut)
                  return 0;
                v14 = (unint64_t)v29;
                v18 = v28;
                v16 = 0;
                v8 = v6 & 0xE;
                v15 = v37;
                v19 = (unint64_t)v38;
              }
LABEL_26:
              if ((v6 & 2) == 0)
                goto LABEL_36;
              v20 = *(_QWORD *)&DerivedStorage->mChannelLayoutTag;
              if (v20 == *(_QWORD *)&v10->mChannelLayoutTag
                && (mSampleRate = DerivedStorage[1].mASBD.mSampleRate,
                    v22 = v10[1].mASBD.mSampleRate,
                    (*(_QWORD *)&mSampleRate != 0) ^ (*(_QWORD *)&v22 == 0)))
              {
                if (!v20 || mSampleRate == 0.0)
                {
LABEL_36:
                  if ((v6 & 4) == 0)
                    goto LABEL_42;
                  goto LABEL_37;
                }
                v23 = (_OWORD *)v19;
                v24 = v18;
                v25 = (_DWORD *)v14;
                if (!memcmp(*(const void **)&mSampleRate, *(const void **)&v22, v20))
                {
                  v14 = (unint64_t)v25;
                  v18 = v24;
                  v19 = (unint64_t)v23;
                  if ((v6 & 4) == 0)
                    goto LABEL_42;
LABEL_37:
                  v43 = 4;
                  v44 = 0;
                  if ((v18 == 0) != (v15 == 0))
                    goto LABEL_40;
                  if (v15 | v18)
                  {
                    if ((v19 == 0) != (v14 == 0))
                      goto LABEL_40;
                    if (v19 | v14)
                    {
                      if (v15 != v18
                        || !v19
                        || !v14
                        || (v30 = (_DWORD *)v14,
                            v31 = v18,
                            v32 = (_OWORD *)v19,
                            v33 = memcmp((const void *)v14, (const void *)v19, v18),
                            v19 = (unint64_t)v32,
                            v18 = v31,
                            v14 = (unint64_t)v30,
                            v33))
                      {
                        v34 = (_DWORD *)v19;
                        v35 = v18;
                        v36 = v14;
                        if (!isValidAudioChannelLayoutAndSize((_DWORD *)v14, v15)
                          || !isValidAudioChannelLayoutAndSize(v34, v35))
                        {
                          FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
                          goto LABEL_40;
                        }
                        v45[0] = v36;
                        v45[1] = v34;
                        if (AudioToolbox_AudioFormatGetProperty(1667786097, 16, (uint64_t)v45, (uint64_t)&v43, (uint64_t)&v44)|| !(_BYTE)v44)
                        {
LABEL_40:
                          if (equalityMaskOut)
                          {
                            v16 = 0;
                            v8 &= ~4u;
                            goto LABEL_42;
                          }
                          return 0;
                        }
                      }
                    }
                  }
LABEL_42:
                  if ((v6 & 8) != 0)
                  {
                    Extensions = CMFormatDescriptionGetExtensions(formatDescription);
                    v27 = CMFormatDescriptionGetExtensions(otherFormatDescription);
                    if (!FigFormatDescriptionExtensionsDictionariesEqualIgnoringKeys(Extensions, v27, 0, 0))
                    {
                      v16 = 0;
                      if (equalityMaskOut)
                        v8 &= ~8u;
                    }
                  }
                  goto LABEL_12;
                }
                if (!equalityMaskOut)
                  return 0;
                v14 = (unint64_t)v25;
                v18 = v24;
                v19 = (unint64_t)v23;
              }
              else if (!equalityMaskOut)
              {
                return 0;
              }
              v16 = 0;
              v8 &= ~2u;
              goto LABEL_36;
            }
          }
          else
          {
            v18 = *(_QWORD *)&v10[1].mASBD.mFormatID;
            v19 = *(_QWORD *)&v10[1].mASBD.mBytesPerPacket;
            if ((v6 & 1) != 0)
              goto LABEL_47;
          }
        }
        else
        {
          v18 = *(_QWORD *)&v10[1].mASBD.mFormatID;
          v19 = *(_QWORD *)&v10[1].mASBD.mBytesPerPacket;
          v13 = v10;
          if ((v6 & 1) != 0)
            goto LABEL_47;
        }
      }
      else
      {
        v18 = 0;
        v15 = 0;
        v19 = 0;
        v14 = 0;
      }
      v16 = 1;
      goto LABEL_26;
    }
    v16 = 1;
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    v16 = 0;
    v8 = 0;
  }
LABEL_12:
  if (equalityMaskOut)
    *equalityMaskOut = v8;
  return v16;
}

uint64_t CMAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout(const opaqueCMFormatDescription *a1, const AudioFormatListItem **a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v8;
  const AudioFormatListItem *RichestDecodableFormat;
  const AudioFormatListItem *v10;
  uint64_t DerivedStorage;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  UInt32 mChannelsPerFrame;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;

  if (a1 && CMFormatDescriptionGetMediaType(a1) == 1936684398)
  {
    if (a2 || (v8 = 4294954586, a3) && a4)
    {
      RichestDecodableFormat = CMAudioFormatDescriptionGetRichestDecodableFormat(a1);
      if (RichestDecodableFormat)
      {
        v10 = RichestDecodableFormat;
        if (a4)
        {
          DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
          v13 = (uint64_t *)(DerivedStorage + 64);
          v12 = *(_QWORD *)(DerivedStorage + 64);
          if (!v12
            || (v15 = (uint64_t *)(DerivedStorage + 56), (v14 = *(_QWORD *)(DerivedStorage + 56)) == 0)
            || (mChannelsPerFrame = v10->mASBD.mChannelsPerFrame,
                mChannelsPerFrame != getAudioChannelCountFromLayout(v12, v14)))
          {
            result = figAudioFormatDescriptionEnsureRichestDecodableLayout(a1);
            if ((_DWORD)result)
              return result;
            v13 = (uint64_t *)(DerivedStorage + 104);
            v15 = (uint64_t *)(DerivedStorage + 96);
          }
          v18 = *v13;
          v19 = *v15;
        }
        else
        {
          v18 = 0;
          v19 = 0;
        }
        if (!v18)
          v19 = 0;
        if (!a4)
          goto LABEL_23;
        goto LABEL_22;
      }
      v8 = 4294954578;
    }
  }
  else
  {
    v8 = 4294954586;
  }
  result = FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)result)
    return result;
  v19 = 0;
  v18 = 0;
  v10 = 0;
  if (a4)
LABEL_22:
    *a4 = v18;
LABEL_23:
  if (a3)
    *a3 = v19;
  result = 0;
  if (a2)
    *a2 = v10;
  return result;
}

uint64_t CMAudioFormatDescriptionGetMostCompatibleFormatAndChannelLayout(const opaqueCMFormatDescription *a1, const AudioFormatListItem **a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v8;
  const AudioFormatListItem *MostCompatibleFormat;
  const AudioFormatListItem *v10;
  uint64_t DerivedStorage;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  UInt32 mChannelsPerFrame;
  uint64_t result;
  uint64_t v19;

  if (a1 && CMFormatDescriptionGetMediaType(a1) == 1936684398)
  {
    if (a2 || (v8 = 4294954586, a3) && a4)
    {
      MostCompatibleFormat = CMAudioFormatDescriptionGetMostCompatibleFormat(a1);
      if (MostCompatibleFormat)
      {
        v10 = MostCompatibleFormat;
        if (!a4)
        {
          v13 = 0;
          v19 = 0;
          goto LABEL_22;
        }
        DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
        v12 = (_QWORD *)DerivedStorage;
        v13 = *(_QWORD *)(DerivedStorage + 120);
        if (!v13)
        {
          v14 = *(_QWORD *)(DerivedStorage + 64);
          if (v14)
          {
            v16 = v12 + 7;
            v15 = v12[7];
            if (v15)
            {
              mChannelsPerFrame = v10->mASBD.mChannelsPerFrame;
              if (mChannelsPerFrame == getAudioChannelCountFromLayout(v14, v15))
              {
                v13 = v12[8];
LABEL_21:
                v19 = *v16;
LABEL_22:
                if (!v13)
                  v19 = 0;
                if (!a4)
                  goto LABEL_26;
                goto LABEL_25;
              }
            }
          }
          result = figAudioFormatDescriptionEnsureMostCompatibleLayout(a1);
          if ((_DWORD)result)
            return result;
          v13 = v12[15];
        }
        v16 = v12 + 14;
        goto LABEL_21;
      }
      v8 = 4294954578;
    }
  }
  else
  {
    v8 = 4294954586;
  }
  result = FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)result)
    return result;
  v19 = 0;
  v13 = 0;
  v10 = 0;
  if (!a4)
    goto LABEL_26;
LABEL_25:
  *a4 = v13;
LABEL_26:
  if (a3)
    *a3 = v19;
  result = 0;
  if (a2)
    *a2 = v10;
  return result;
}

const AudioFormatListItem *FigAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout(const opaqueCMFormatDescription *a1, _QWORD *a2, _QWORD *a3)
{
  const AudioFormatListItem *result;
  const AudioFormatListItem *v6;

  v6 = 0;
  if (!CMAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout(a1, &v6, a2, a3))
    return v6;
  if (a2)
    *a2 = 0;
  result = 0;
  if (a3)
    *a3 = 0;
  return result;
}

const AudioFormatListItem *FigAudioFormatDescriptionGetMostCompatibleFormatAndChannelLayout(const opaqueCMFormatDescription *a1, _QWORD *a2, _QWORD *a3)
{
  const AudioFormatListItem *result;
  const AudioFormatListItem *v6;

  v6 = 0;
  if (!CMAudioFormatDescriptionGetMostCompatibleFormatAndChannelLayout(a1, &v6, a2, a3))
    return v6;
  if (a2)
    *a2 = 0;
  result = 0;
  if (a3)
    *a3 = 0;
  return result;
}

uint64_t CMAudioFormatDescriptionCreateCopyWithNewChannelLayout(const opaqueCMFormatDescription *a1, unint64_t a2, AudioChannelLayout *a3, CMAudioFormatDescriptionRef *a4)
{
  uint64_t DerivedStorage;
  const __CFDictionary *Extensions;
  __CFDictionary *v10;
  const __CFDictionary *Value;
  const __CFDictionary *v12;
  BOOL v13;
  const __CFAllocator *v14;
  __CFDictionary *MutableCopy;
  const __CFAllocator *v16;
  const __CFAllocator *v17;
  uint64_t v18;
  __int16 v20;
  CMAudioFormatDescriptionRef formatDescriptionOut;

  formatDescriptionOut = 0;
  if (!a1)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  if (CMFormatDescriptionGetMediaType(a1) == 1936684398 && a3 && a2 > 0xB && a4)
  {
    DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
    Extensions = CMFormatDescriptionGetExtensions(a1);
    v10 = Extensions;
    if (Extensions
      && ((Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("SampleDescriptionExtensionAtoms")),
           (v12 = Value) == 0)
        ? (v13 = 1)
        : (v13 = CFDictionaryGetValue(Value, CFSTR("chnl")) == 0),
          v14 = CFGetAllocator(a1),
          v10 = CFDictionaryCreateMutableCopy(v14, 0, v10),
          CFDictionaryRemoveValue(v10, CFSTR("VerbatimISOSampleEntry")),
          CFDictionaryRemoveValue(v10, CFSTR("VerbatimSampleDescription")),
          !v13))
    {
      v16 = CFGetAllocator(v12);
      MutableCopy = CFDictionaryCreateMutableCopy(v16, 0, v12);
      CFDictionaryRemoveValue(v10, CFSTR("SampleDescriptionExtensionAtoms"));
      CFDictionaryRemoveValue(MutableCopy, CFSTR("chnl"));
      if ((uint64_t)FigCFDictionaryGetCount(MutableCopy) >= 1)
        CFDictionarySetValue(v10, CFSTR("SampleDescriptionExtensionAtoms"), MutableCopy);
    }
    else
    {
      MutableCopy = 0;
    }
    v20 = 0;
    evaluateLayoutAgainstFormatList(*(_QWORD *)(DerivedStorage + 88), *(_QWORD *)(DerivedStorage + 80), a3, a2, 0, 0, (_BYTE *)&v20 + 1, &v20, 0);
    if (v20 | HIBYTE(v20))
    {
      v17 = CFGetAllocator(a1);
      v18 = CMAudioFormatDescriptionCreate(v17, (const AudioStreamBasicDescription *)DerivedStorage, a2, a3, *(_QWORD *)(DerivedStorage + 40), *(const void **)(DerivedStorage + 48), v10, &formatDescriptionOut);
      if (!(_DWORD)v18)
      {
        *a4 = formatDescriptionOut;
        formatDescriptionOut = 0;
      }
      if (!MutableCopy)
        goto LABEL_19;
    }
    else
    {
      v18 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
      if (!MutableCopy)
      {
LABEL_19:
        if (v10)
          CFRelease(v10);
        goto LABEL_21;
      }
    }
    CFRelease(MutableCopy);
    goto LABEL_19;
  }
  v18 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
LABEL_21:
  if (formatDescriptionOut)
    CFRelease(formatDescriptionOut);
  return v18;
}

uint64_t FigAudioFormatDescriptionGetCreationChannelLayoutSignificance(uint64_t result)
{
  if (result)
  {
    result = FigDerivedFormatDescriptionGetDerivedStorage(result);
    if (result)
      return *(unsigned int *)(result + 72);
  }
  return result;
}

uint64_t FigAudioFormatDescriptionEmploysDependentPackets(uint64_t result)
{
  const opaqueCMFormatDescription *v1;
  signed int MediaSubType;
  int v3;

  if (!result)
    return result;
  v1 = (const opaqueCMFormatDescription *)result;
  if (CMFormatDescriptionGetMediaType((CMFormatDescriptionRef)result) != 1936684398)
    return 0;
  MediaSubType = CMFormatDescriptionGetMediaSubType(v1);
  result = 1;
  if (MediaSubType <= 1886745440)
  {
    if (MediaSubType > 1667330146)
    {
      if (MediaSubType == 1667330147)
        return result;
      v3 = 1668641633;
    }
    else
    {
      if (MediaSubType == 1633889588)
        return result;
      v3 = 1634754915;
    }
LABEL_15:
    if (MediaSubType == v3)
      return result;
    return 0;
  }
  if (MediaSubType <= 1903522656)
  {
    if (MediaSubType == 1886745441)
      return result;
    v3 = 1902211171;
    goto LABEL_15;
  }
  if (MediaSubType != 1903522657 && MediaSubType != 1970495843)
  {
    v3 = 2054517601;
    goto LABEL_15;
  }
  return result;
}

const opaqueCMFormatDescription *FigAudioFormatDescriptionUsesAudibleDRM(const opaqueCMFormatDescription *result)
{
  const opaqueCMFormatDescription *v1;

  if (result)
  {
    v1 = result;
    if (CMFormatDescriptionGetMediaType(result) == 1936684398)
      return (const opaqueCMFormatDescription *)(CMFormatDescriptionGetMediaSubType(v1) == 1633771875);
    else
      return 0;
  }
  return result;
}

_OWORD *FigAudioFormatDescriptionAudibleContentIsAuthorized(const opaqueCMFormatDescription *a1, int a2)
{
  _OWORD *result;
  __int128 v5;
  __int128 v6;
  BOOL v7;
  int v8;
  size_t sizeOut;
  _OWORD v10[2];
  uint64_t v11;
  const void *MagicCookie;
  int v13;
  int v14;
  int v15;

  result = FigAudioFormatDescriptionUsesAudibleDRM(a1);
  if ((_DWORD)result)
  {
    v15 = 0;
    sizeOut = 0;
    result = CMAudioFormatDescriptionGetStreamBasicDescription(a1);
    if (result)
    {
      v5 = *result;
      v6 = result[1];
      v11 = *((_QWORD *)result + 4);
      v10[0] = v5;
      v10[1] = v6;
      MagicCookie = CMAudioFormatDescriptionGetMagicCookie(a1, &sizeOut);
      if (HIDWORD(sizeOut))
      {
        return 0;
      }
      else
      {
        v13 = sizeOut;
        v14 = a2;
        v8 = 4;
        if (AudioToolbox_AudioFormatGetProperty(1633776744, 56, (uint64_t)v10, (uint64_t)&v8, (uint64_t)&v15))v7 = 1;
        else
          v7 = v15 == 0;
        return (_OWORD *)!v7;
      }
    }
  }
  return result;
}

__CFString *CMAudioFormatDescriptionCopyRichestDecodableFormatCompactDebugDescription(const void *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  CFTypeRef v4;
  CFTypeRef v5;
  const void *v6;
  uint64_t v8;
  uint64_t v9;
  const AudioFormatListItem *v10;
  int v11;
  const void *v12;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v9 = 0;
  v10 = 0;
  v8 = 0;
  if (CMAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout((const opaqueCMFormatDescription *)a1, &v10, &v9, &v8))
  {
    v4 = CFRetain(CFSTR("(null)"));
    v5 = CFRetain(CFSTR("(null)"));
  }
  else
  {
    v12 = 0;
    v11 = 8;
    AudioToolbox_AudioFormatGetProperty(1718509933, 40, (uint64_t)v10, (uint64_t)&v11, (uint64_t)&v12);
    v4 = v12;
    if (!v12)
      v4 = CFRetain(CFSTR("(null)"));
    v5 = aclCopyDebugDesc(v8, v9);
  }
  v6 = v5;
  CFStringAppendFormat(Mutable, 0, CFSTR("%@, %@"), v4, v5);
  if (v6)
    CFRelease(v6);
  if (v4)
    CFRelease(v4);
  return Mutable;
}

CFTypeRef aclCopyDebugDesc(uint64_t a1, uint64_t a2)
{
  CFTypeRef result;
  int v5;
  const void *v6;

  v6 = 0;
  v5 = 8;
  AudioToolbox_AudioFormatGetProperty(1819242093, a2, a1, (uint64_t)&v5, (uint64_t)&v6);
  result = v6;
  if (!v6)
  {
    if (a1 && a2)
      return 0;
    else
      return CFRetain(CFSTR("(null)"));
  }
  return result;
}

uint64_t FigCreateAudioCodecStringFromFormatDescription(const opaqueCMFormatDescription *a1, int a2, __CFString **a3)
{
  _BOOL8 v6;
  const AudioStreamBasicDescription *StreamBasicDescription;
  const AudioStreamBasicDescription *v8;
  int v9;
  __int128 v10;
  __int128 v11;
  uint64_t Property;
  __CFString *v13;
  uint64_t v14;
  _OWORD v16[2];
  uint64_t v17;
  const void *MagicCookie;
  uint64_t v19;
  uint64_t v20;
  CMBlockBufferRef blockBufferOut;
  size_t sizeOut;
  int v23;
  __CFString *v24;

  v24 = 0;
  v23 = 8;
  blockBufferOut = 0;
  sizeOut = 0;
  if (!a3)
  {
    Property = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  v6 = a2 == 1751937824;
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(a1);
  if (StreamBasicDescription)
  {
    v8 = StreamBasicDescription;
    if (a2 == 1751937824)
      v9 = 1836069990;
    else
      v9 = a2;
    v19 = 0;
    v20 = 0;
    v10 = *(_OWORD *)&StreamBasicDescription->mSampleRate;
    v11 = *(_OWORD *)&StreamBasicDescription->mBytesPerPacket;
    v17 = *(_QWORD *)&StreamBasicDescription->mBitsPerChannel;
    v16[0] = v10;
    v16[1] = v11;
    MagicCookie = CMAudioFormatDescriptionGetMagicCookie(a1, &sizeOut);
    LODWORD(v19) = sizeOut;
    LODWORD(v20) = v9;
    Property = AudioToolbox_AudioFormatGetProperty(1668309350, 64, (uint64_t)v16, (uint64_t)&v23, (uint64_t)&v24);
    v13 = v24;
    if (v9 != 1836069990 || v24)
    {
LABEL_11:
      *a3 = v13;
      v24 = 0;
      goto LABEL_12;
    }
    v14 = CMAudioFormatDescriptionCopyAsBigEndianSoundDescriptionBlockBuffer((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, CFSTR("ISOFamily"), &blockBufferOut);
    if (!(_DWORD)v14)
    {
      Property = FigMP4BridgeCreateRFC6381CodecString(blockBufferOut, 1936684398, v8->mFormatID, v6, &v24);
      if ((_DWORD)Property)
        goto LABEL_12;
      v13 = v24;
      goto LABEL_11;
    }
    Property = v14;
  }
  else
  {
    Property = 0;
  }
LABEL_12:
  if (blockBufferOut)
    CFRelease(blockBufferOut);
LABEL_14:
  if (v24)
    CFRelease(v24);
  return Property;
}

uint64_t FigAudioFormatDescriptionCopySceneInformation(const opaqueCMFormatDescription *a1, uint64_t a2, _QWORD *a3)
{
  const AudioStreamBasicDescription *StreamBasicDescription;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  int v10;
  size_t sizeOut;
  _OWORD v12[2];
  uint64_t v13;
  const void *MagicCookie;
  uint64_t v15;
  uint64_t v16;

  v16 = 0;
  if (!a1 || !a3)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(a1);
  if (StreamBasicDescription)
  {
    v15 = 0;
    sizeOut = 0;
    v10 = 8;
    v6 = *(_QWORD *)&StreamBasicDescription->mBitsPerChannel;
    v7 = *(_OWORD *)&StreamBasicDescription->mBytesPerPacket;
    v12[0] = *(_OWORD *)&StreamBasicDescription->mSampleRate;
    v12[1] = v7;
    v13 = v6;
    MagicCookie = CMAudioFormatDescriptionGetMagicCookie(a1, &sizeOut);
    LODWORD(v15) = sizeOut;
    AudioToolbox_AudioFormatGetProperty(1936286825, 56, (uint64_t)v12, (uint64_t)&v10, (uint64_t)&v16);
    v8 = v16;
  }
  else
  {
    v8 = 0;
  }
  *a3 = v8;
  return 0;
}

uint64_t FigAudioFormatDescriptionCopyCompatibleCompositionPresets(const opaqueCMFormatDescription *a1, const __CFAllocator *a2, CFMutableArrayRef *a3)
{
  uint64_t v5;
  const __CFArray *ArrayValue;
  const __CFDictionary *ValueAtIndex;
  const __CFArray *v8;
  const __CFArray *v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex v12;
  CFMutableArrayRef Mutable;
  const __CFDictionary *v14;
  const __CFDictionary *DictionaryValue;
  const __CFArray *v16;
  CFMutableDictionaryRef v17;
  CFMutableDictionaryRef v18;
  uint64_t v19;
  uint64_t v20;
  CFMutableArrayRef *v22;
  CFTypeRef cf;

  cf = 0;
  v5 = FigAudioFormatDescriptionCopySceneInformation(a1, (uint64_t)a2, &cf);
  if ((_DWORD)v5)
  {
LABEL_23:
    v20 = v5;
  }
  else
  {
    v22 = a3;
    if (cf)
    {
      ArrayValue = (const __CFArray *)FigCFDictionaryGetArrayValue((const __CFDictionary *)cf, CFSTR("SceneCompositions"));
      ValueAtIndex = (const __CFDictionary *)FigCFArrayGetValueAtIndex(ArrayValue, 0);
      v8 = (const __CFArray *)FigCFDictionaryGetArrayValue(ValueAtIndex, CFSTR("PresetDescriptions"));
      if (v8)
      {
        v9 = v8;
        Count = CFArrayGetCount(v8);
        if (Count >= 1)
        {
          v11 = Count;
          v12 = 0;
          Mutable = 0;
          while (1)
          {
            v14 = (const __CFDictionary *)FigCFArrayGetValueAtIndex(v9, v12);
            DictionaryValue = (const __CFDictionary *)FigCFDictionaryGetDictionaryValue(v14, CFSTR("PresetDescription"));
            v16 = (const __CFArray *)FigCFDictionaryGetArrayValue(DictionaryValue, CFSTR("AudioCharacteristics"));
            if (FigCFArrayContainsValue(v16, CFSTR("CompatibleSelection")))
            {
              if (!Mutable)
              {
                Mutable = CFArrayCreateMutable(a2, 0, MEMORY[0x1E0C9B378]);
                if (!Mutable)
                {
                  v5 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
                  goto LABEL_23;
                }
              }
              v17 = CFDictionaryCreateMutable(a2, 2, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
              if (!v17)
              {
                v20 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
LABEL_21:
                CFRelease(Mutable);
                goto LABEL_16;
              }
              v18 = v17;
              FigCFDictionarySetValue(v17, CFSTR("CompatibleCompositionPresetKey_Description"), DictionaryValue);
              v19 = FigCFDictionarySetCFIndex(v18, CFSTR("CompatibleCompositionPresetKey_Index"), v12);
              if ((_DWORD)v19)
              {
                v20 = v19;
                CFRelease(v18);
                goto LABEL_21;
              }
              CFArrayAppendValue(Mutable, v18);
              CFRelease(v18);
            }
            if (v11 == ++v12)
              goto LABEL_15;
          }
        }
      }
    }
    Mutable = 0;
LABEL_15:
    v20 = 0;
    *v22 = Mutable;
  }
LABEL_16:
  if (cf)
    CFRelease(cf);
  return v20;
}

const __CFDictionary *FigAudioFormatDescriptionGetCinematicAudioEffectEligibility(const opaqueCMFormatDescription *a1)
{
  const __CFDictionary *result;
  const __CFArray *v3;
  CFTypeID v4;
  CFTypeID v5;
  uint64_t v6;
  CFDictionaryRef theDict;

  if (!a1 || CMFormatDescriptionGetMediaType(a1) != 1936684398)
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    goto LABEL_13;
  }
  result = CMFormatDescriptionGetExtensions(a1);
  if (result)
  {
    theDict = 0;
    LODWORD(result) = FigCFDictionaryGetValueIfPresent(result, CFSTR("SampleDescriptionExtensionAtoms"), (const void **)&theDict);
    if ((_DWORD)result)
    {
      result = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("ngst"));
      if (result)
      {
        v3 = result;
        v4 = CFGetTypeID(result);
        if (v4 == CFArrayGetTypeID())
        {
          v6 = 0;
          FigCFArrayApplyFunction(v3, (void (__cdecl *)(const void *, void *))fafd_checkNgstExtensionDataApplier, &v6);
          if (HIDWORD(v6))
            LOBYTE(result) = 0;
          else
            LOBYTE(result) = v6;
          return (const __CFDictionary *)result;
        }
        v5 = CFGetTypeID(v3);
        if (v5 == CFDataGetTypeID())
        {
          LOBYTE(result) = fafd_checkNgstExtensionData(v3);
          return (const __CFDictionary *)result;
        }
LABEL_13:
        LOBYTE(result) = 0;
      }
    }
  }
  return (const __CFDictionary *)result;
}

const __CFData *fafd_checkNgstExtensionDataApplier(const __CFData *cf, uint64_t a2)
{
  const __CFData *v3;
  CFTypeID v4;

  if (!*(_DWORD *)(a2 + 4) && !*(_BYTE *)a2)
  {
    v3 = cf;
    if (cf && (v4 = CFGetTypeID(cf), v4 == CFDataGetTypeID()))
    {
      cf = (const __CFData *)fafd_checkNgstExtensionData(v3);
      *(_BYTE *)a2 = (_BYTE)cf;
    }
    else
    {
      return (const __CFData *)FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    }
  }
  return cf;
}

uint64_t fafd_checkNgstExtensionData(const __CFData *a1)
{
  CFTypeID v2;
  uint64_t v4;
  int v5;
  CFRange v6;

  v5 = 0;
  v4 = 0;
  if (a1 && (v2 = CFGetTypeID(a1), v2 == CFDataGetTypeID()) && CFDataGetLength(a1) == 12)
  {
    v6.location = 0;
    v6.length = 12;
    CFDataGetBytes(a1, v6, (UInt8 *)&v4);
    if ((_DWORD)v4 == 1634625891)
      return HIBYTE(v5) & 1;
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

__CFString *figAudioFormatDescriptionCopyDebugDesc(const void *a1)
{
  _QWORD *DerivedStorage;
  const __CFAllocator *v3;
  __CFString *Mutable;
  __CFString *v5;
  CFStringRef v6;
  const UInt8 *v7;
  CFIndex v8;
  BOOL v9;
  const __CFAllocator *v10;
  CFDataRef v11;
  CFDataRef v12;
  CFTypeRef v13;
  uint64_t v14;
  unint64_t v15;
  const __CFAllocator *v16;
  __CFString *v17;
  uint64_t v18;
  unint64_t v19;
  __CFString *v20;
  __CFString *v22;

  DerivedStorage = (_QWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  v3 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v3, 0);
  v5 = asbdCopyDebugDesc(a1, (uint64_t)DerivedStorage);
  v6 = 0;
  v8 = DerivedStorage[5];
  v7 = (const UInt8 *)DerivedStorage[6];
  if (v7)
    v9 = v8 == 0;
  else
    v9 = 1;
  if (!v9)
  {
    v10 = CFGetAllocator(a1);
    v11 = CFDataCreate(v10, v7, v8);
    if (v11)
    {
      v12 = v11;
      v6 = CFCopyDescription(v11);
      CFRelease(v12);
    }
    else
    {
      v6 = 0;
    }
  }
  v13 = aclCopyDebugDesc(DerivedStorage[8], DerivedStorage[7]);
  v14 = DerivedStorage[11];
  if (v14 && (v15 = DerivedStorage[10], v15 >= 0x30))
  {
    v22 = Mutable;
    v16 = CFGetAllocator(a1);
    v17 = CFStringCreateMutable(v16, 0);
    v18 = 0;
    v19 = v15 / 0x30;
    do
    {
      v20 = asbdCopyDebugDesc(a1, v14);
      if (v18)
        CFStringAppend(v17, CFSTR("\n"));
      CFStringAppendFormat(v17, 0, CFSTR("\n\t\t\tIndex: %d \n\t\t\tChannelLayoutTag: 0x%x \n\t\t\tASBD: {%@\t}"), v18, *(unsigned int *)(v14 + 40), v20);
      if (v20)
        CFRelease(v20);
      ++v18;
      v14 += 48;
    }
    while (v19 != v18);
    Mutable = v22;
  }
  else
  {
    v17 = (__CFString *)CFRetain(CFSTR("(null)"));
  }
  CFStringAppendFormat(Mutable, 0, CFSTR("\t\tASBD: {%@\t} \n\t\tcookie: {%@} \n\t\tACL: {%@}\n\t\tFormatList Array: {%@}"), v5, v6, v13, v17);
  if (v5)
    CFRelease(v5);
  if (v6)
    CFRelease(v6);
  if (v13)
    CFRelease(v13);
  if (v17)
    CFRelease(v17);
  return Mutable;
}

uint64_t figAudioFormatDescriptionEqual(const opaqueCMFormatDescription *a1, const opaqueCMFormatDescription *a2, unint64_t a3, unint64_t a4)
{
  uint64_t result;
  const __CFDictionary *Extensions;
  const __CFDictionary *v10;

  result = CMAudioFormatDescriptionEqual(a1, a2, 7u, 0);
  if ((_DWORD)result)
  {
    Extensions = CMFormatDescriptionGetExtensions(a1);
    v10 = CMFormatDescriptionGetExtensions(a2);
    return FigFormatDescriptionExtensionsDictionariesEqualIgnoringKeys(Extensions, v10, a3, a4);
  }
  return result;
}

__CFString *asbdCopyDebugDesc(const void *a1, uint64_t a2)
{
  const __CFAllocator *v3;
  __CFString *Mutable;

  v3 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v3, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("\n\t\t\tmSampleRate: %f \n\t\t\tmFormatID: '%c%c%c%c' \n\t\t\tmFormatFlags: 0x%x \n\t\t\tmBytesPerPacket: %u \n\t\t\tmFramesPerPacket: %u \n\t\t\tmBytesPerFrame: %u \n\t\t\tmChannelsPerFrame: %u \n\t\t\tmBitsPerChannel: %u "), *(_QWORD *)a2, HIBYTE(*(_DWORD *)(a2 + 8)), BYTE2(*(_DWORD *)(a2 + 8)), BYTE1(*(_DWORD *)(a2 + 8)), *(_DWORD *)(a2 + 8), *(unsigned int *)(a2 + 12), *(unsigned int *)(a2 + 16), *(unsigned int *)(a2 + 20), *(unsigned int *)(a2 + 24), *(unsigned int *)(a2 + 28), *(unsigned int *)(a2 + 32));
  return Mutable;
}

uint64_t getChannelLayoutTagFromLayout(_DWORD *a1, unint64_t a2)
{
  int Property;
  uint64_t result;
  int v5;
  unsigned int v6;

  v5 = 4;
  v6 = -65536;
  if (HIDWORD(a2))
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 4294901760;
  }
  else
  {
    Property = AudioToolbox_AudioFormatGetProperty(1668116596, a2, (uint64_t)a1, (uint64_t)&v5, (uint64_t)&v6);
    result = v6;
    if (!Property && v6 == 6553601)
    {
      if (*a1)
      {
        return 6553601;
      }
      else
      {
        result = 6553601;
        if (a1[2] == 1)
        {
          if (a1[3] == 3)
            return 4294901760;
          else
            return 6553601;
        }
      }
    }
  }
  return result;
}

BOOL isValidAudioChannelLayoutAndSize(_DWORD *a1, unint64_t a2)
{
  if (!a1 || a2 < 4)
    return 0;
  if (!*a1)
    return a2 >= 0xC && 20 * (unint64_t)a1[2] + 12 <= a2;
  return *a1 != 0x10000 || a2 >= 8;
}

uint64_t FigAudioDeviceClock_RemoteCreateCommon(uint64_t a1, const void *a2, unsigned int a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t BasicRemoteAudioDeviceClock;
  CFTypeRef v9;
  uint64_t v11;

  v11 = 0;
  if (gAudioDeviceClockRemoteClientSetupOnce != -1)
    dispatch_once(&gAudioDeviceClockRemoteClientSetupOnce, &__block_literal_global_20);
  v7 = remoteDeviceClock_OneTimeInitialization_err;
  if (remoteDeviceClock_OneTimeInitialization_err)
    return v7;
  if (a4)
  {
    BasicRemoteAudioDeviceClock = CreateBasicRemoteAudioDeviceClock((CFTypeRef *)&v11);
    v9 = (CFTypeRef)v11;
    if ((_DWORD)BasicRemoteAudioDeviceClock)
    {
      v7 = BasicRemoteAudioDeviceClock;
    }
    else
    {
      v7 = AcquireServerClockObject(v11, a2, a3);
      if (!(_DWORD)v7)
      {
        FigDerivedClockGetDerivedStorage((uint64_t)v9);
        *a4 = v9;
        return v7;
      }
    }
    if (v9)
      CFRelease(v9);
    return v7;
  }
  return FigSignalErrorAt(4294954551, 0, 0, 0, 0, 0, 0);
}

uint64_t CreateBasicRemoteAudioDeviceClock(CFTypeRef *a1)
{
  uint64_t v2;
  CMClockRef HostTimeClock;
  uint64_t TimeCallback;
  uint64_t DerivedStorage;
  dispatch_queue_t v6;
  uint64_t v7;
  CMTime v9;
  CFTypeRef cf;

  cf = 0;
  v2 = *MEMORY[0x1E0C9AE00];
  HostTimeClock = CMClockGetHostTimeClock();
  CMTimeMake(&v9, 1, 10);
  TimeCallback = FigDerivedClockCreateWithGetTimeCallback(v2, gFigAudioDeviceRemoteClockCallbacks, HostTimeClock, (__int128 *)&v9.value, 1, (uint64_t *)&cf);
  if ((_DWORD)TimeCallback)
  {
    v7 = TimeCallback;
  }
  else
  {
    DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)cf);
    v6 = dispatch_queue_create("com.apple.coremedia.audioclock.reconnect", 0);
    *(_QWORD *)(DerivedStorage + 16) = v6;
    if (v6)
    {
      v7 = 0;
      *a1 = cf;
      return v7;
    }
    v7 = 4294954549;
  }
  if (cf)
    CFRelease(cf);
  return v7;
}

uint64_t AcquireServerClockObject(uint64_t a1, const void *a2, unsigned int a3)
{
  _QWORD *DerivedStorage;
  uint64_t v7;
  const void *uint64;
  uint64_t v9;
  xpc_object_t v11;
  xpc_object_t xdict;

  DerivedStorage = (_QWORD *)FigDerivedClockGetDerivedStorage(a1);
  v11 = 0;
  xdict = 0;
  v7 = FigXPCCreateBasicMessage(0x63726538u, 0, &xdict);
  if ((_DWORD)v7
    || (xpc_dictionary_set_int64(xdict, "DeviceID", a3),
        v7 = FigXPCMessageSetCFString(xdict, "DeviceUID", a2),
        (_DWORD)v7)
    || (v7 = FigXPCRemoteClientSendSyncMessageCreatingReply(gAudioDeviceClockRemoteClient, (uint64_t)xdict, &v11),
        (_DWORD)v7))
  {
    v9 = v7;
  }
  else
  {
    uint64 = (const void *)xpc_dictionary_get_uint64(v11, ".objectID");
    v9 = FigXPCRemoteClientAssociateObject(gAudioDeviceClockRemoteClient, a1, uint64);
    if (!(_DWORD)v9)
      *DerivedStorage = uint64;
  }
  FigXPCRelease(xdict);
  FigXPCRelease(v11);
  FigXPCRemoteClientKillServerOnTimeout(gAudioDeviceClockRemoteClient, v9, "AcquireServerClockObject", 0);
  return v9;
}

uint64_t FigAudioDeviceClockXPCRemotePing()
{
  uint64_t v0;
  uint64_t v1;
  void *v2;
  void *v4;

  v4 = 0;
  if (gAudioDeviceClockRemoteClientSetupOnce != -1)
    dispatch_once(&gAudioDeviceClockRemoteClientSetupOnce, &__block_literal_global_20);
  v0 = remoteDeviceClock_OneTimeInitialization_err;
  if (remoteDeviceClock_OneTimeInitialization_err)
  {
    v2 = 0;
  }
  else
  {
    v1 = FigXPCCreateBasicMessage(0x2E706E67u, 0, &v4);
    v2 = v4;
    if ((_DWORD)v1)
    {
      v0 = v1;
    }
    else
    {
      v0 = FigXPCRemoteClientSendSyncMessage(gAudioDeviceClockRemoteClient, (uint64_t)v4);
      v2 = v4;
    }
  }
  FigXPCRelease(v2);
  return v0;
}

uint64_t FigAudioDeviceClockXPCRemoteRetainCopiedClock(const void *a1, CFTypeRef *a2)
{
  uint64_t v4;
  CFTypeRef v5;
  uint64_t v6;
  uint64_t v8;
  CFTypeRef cf;

  cf = 0;
  if (a1 && a2)
  {
    if (gAudioDeviceClockRemoteClientSetupOnce != -1)
      dispatch_once(&gAudioDeviceClockRemoteClientSetupOnce, &__block_literal_global_20);
    v4 = remoteDeviceClock_OneTimeInitialization_err;
    if (remoteDeviceClock_OneTimeInitialization_err)
      return v4;
    v4 = FigXPCRemoteClientRetainCopiedObject(gAudioDeviceClockRemoteClient, (uint64_t)a1, &cf);
    v5 = cf;
    if (!(_DWORD)v4)
    {
      if (cf)
      {
        FigAudioDeviceClockXPCRemoteGetObjectID((OpaqueCMClock *)cf, &v8);
LABEL_10:
        v4 = 0;
        *a2 = cf;
        return v4;
      }
      v6 = FigAudioDeviceClockXPCRemoteCreateWithObjectID(a1, &cf);
      if (!(_DWORD)v6)
        goto LABEL_10;
      v4 = v6;
      v5 = cf;
    }
    if (v5)
      CFRelease(v5);
    return v4;
  }
  return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
}

uint64_t FigAudioDeviceClockXPCRemoteCreateWithObjectID(const void *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t BasicRemoteAudioDeviceClock;
  CFTypeRef v6;
  uint64_t v8;

  v8 = 0;
  if (a1 && a2)
  {
    if (gAudioDeviceClockRemoteClientSetupOnce != -1)
      dispatch_once(&gAudioDeviceClockRemoteClientSetupOnce, &__block_literal_global_20);
    v4 = remoteDeviceClock_OneTimeInitialization_err;
    if (remoteDeviceClock_OneTimeInitialization_err)
      return v4;
    BasicRemoteAudioDeviceClock = CreateBasicRemoteAudioDeviceClock((CFTypeRef *)&v8);
    v6 = (CFTypeRef)v8;
    if ((_DWORD)BasicRemoteAudioDeviceClock)
    {
      v4 = BasicRemoteAudioDeviceClock;
    }
    else
    {
      v4 = FigXPCRemoteClientAssociateObject(gAudioDeviceClockRemoteClient, v8, a1);
      if (!(_DWORD)v4)
      {
        *(_QWORD *)FigDerivedClockGetDerivedStorage((uint64_t)v6) = a1;
        *a2 = v6;
        return v4;
      }
    }
    if (v6)
      CFRelease(v6);
    return v4;
  }
  return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
}

uint64_t FigAudioDeviceClockXPCRemoteGetObjectID(OpaqueCMClock *a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  _QWORD *v5;

  DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)a1);
  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v5 = (_QWORD *)DerivedStorage;
  if (CMClockGetHostTimeClock() == a1
    || !FigDerivedClockVerifyCallbacksMatch((_BOOL8)a1, (uint64_t)gFigAudioDeviceRemoteClockCallbacks))
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  *a2 = *v5;
  return 0;
}

uint64_t FigAudioDeviceClockRemoteCreateForServerObject(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v5;
  const void *v6;
  int v7;

  v7 = 0;
  v5 = 0;
  v6 = 0;
  result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, int *, const void **, uint64_t *))(a2 + 16))(a2, 0, 0, &v7, &v6, &v5);
  if (!(_DWORD)result)
    return FigAudioDeviceClockXPCRemoteCreateWithObjectID(v6, a3);
  return result;
}

uint64_t FigAudioDeviceClock_GetServerClockToken(OpaqueCMClock *a1, _QWORD *a2)
{
  _QWORD *DerivedStorage;

  DerivedStorage = (_QWORD *)FigDerivedClockGetDerivedStorage((uint64_t)a1);
  if (CMClockGetHostTimeClock() == a1
    || !FigDerivedClockVerifyCallbacksMatch((_BOOL8)a1, (uint64_t)gFigAudioDeviceRemoteClockCallbacks))
  {
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  *a2 = *DerivedStorage;
  return 0;
}

uint64_t remoteDeviceClock_DeadConnectionCallback(uint64_t a1)
{
  uint64_t result;

  result = FigDerivedClockGetDerivedStorage(a1);
  *(_BYTE *)(result + 8) = 1;
  return result;
}

CFStringRef remoteDeviceClock_CopyDebugDesc(const void *a1)
{
  _QWORD *DerivedStorage;
  const __CFAllocator *v3;
  const char *v4;
  BOOL v6;
  unsigned int v7;
  uint64_t v8;

  v8 = 0;
  v7 = 0;
  DerivedStorage = (_QWORD *)FigDerivedClockGetDerivedStorage((uint64_t)a1);
  v6 = 0;
  remoteDeviceClock_GetAudioDevice((uint64_t)a1, &v8, &v7, &v6);
  v3 = CFGetAllocator(a1);
  v4 = "true";
  if (!v6)
    v4 = "false";
  return CFStringCreateWithFormat(v3, 0, CFSTR("RemoteAudioDeviceClockXPC(objectID=%lld deviceUID='%@', deviceID=%d, trackDefaultDevice=%s)"), *DerivedStorage, v8, v7, v4);
}

void remoteDeviceClock_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *v2;
  void *v3;
  int v4;
  uint64_t v5;
  void *v6;

  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  v6 = 0;
  v2 = *(NSObject **)(DerivedStorage + 16);
  if (v2)
  {
    dispatch_release(v2);
    *(_QWORD *)(DerivedStorage + 16) = 0;
  }
  v3 = *(void **)DerivedStorage;
  if (*(_QWORD *)DerivedStorage)
  {
    FigXPCRemoteClientDisassociateObject(gAudioDeviceClockRemoteClient, v3);
    if (*(_BYTE *)(DerivedStorage + 8))
    {
      v3 = 0;
    }
    else
    {
      v4 = FigXPCCreateBasicMessage(0x646F6F6Du, *(_QWORD *)DerivedStorage, &v6);
      v3 = v6;
      if (!v4)
      {
        v5 = FigXPCRemoteClientSendSyncMessage(gAudioDeviceClockRemoteClient, (uint64_t)v6);
        FigXPCRemoteClientKillServerOnTimeout(gAudioDeviceClockRemoteClient, v5, "remoteDeviceClock_Finalize", 0);
        v3 = v6;
      }
    }
  }
  FigXPCRelease(v3);
}

BOOL remoteDeviceClock_MightDrift(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  _BOOL8 result;
  __int16 v7;
  uint64_t v8;

  v8 = 0;
  v7 = 0;
  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  v5 = FigDerivedClockGetDerivedStorage(a2);
  result = 1;
  if (DerivedStorage && v5)
    return remoteDeviceClock_GetAudioDevice(a1, 0, (_DWORD *)&v8 + 1, (BOOL *)&v7 + 1)
        || remoteDeviceClock_GetAudioDevice(a2, 0, &v8, (BOOL *)&v7)
        || HIDWORD(v8) != (_DWORD)v8
        || HIBYTE(v7) != v7;
  return result;
}

double remoteDeviceClock_GetRate(const void *a1)
{
  uint64_t *DerivedStorage;
  double v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;
  xpc_object_t xdict;
  xpc_object_t v9;

  DerivedStorage = (uint64_t *)FigDerivedClockGetDerivedStorage((uint64_t)a1);
  xdict = 0;
  v9 = 0;
  v3 = 0.0;
  if (DerivedStorage)
  {
    v4 = DerivedStorage;
    if (!FigXPCCreateBasicMessage(0x67726174u, *DerivedStorage, &v9))
    {
      v5 = FigXPCRemoteClientSendSyncMessageCreatingReply(gAudioDeviceClockRemoteClient, (uint64_t)v9, &xdict);
      v6 = v5;
      FigXPCRemoteClientKillServerOnTimeout(gAudioDeviceClockRemoteClient, v5, "remoteDeviceClock_GetRate", 0);
      if (v6 == -16152)
        goto LABEL_8;
      if (!v6)
      {
        v3 = xpc_dictionary_get_double(xdict, "Rate");
        goto LABEL_9;
      }
      if (v6 == -16155 || *((_BYTE *)v4 + 8))
      {
LABEL_8:
        MaybeReacquireServerClockObject(a1);
        v3 = 1.0;
      }
    }
  }
LABEL_9:
  FigXPCRelease(v9);
  FigXPCRelease(xdict);
  return v3;
}

uint64_t remoteDeviceClock_GetAnchorTime(const void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *DerivedStorage;
  uint64_t *v7;
  uint64_t CMTime;
  uint64_t int64;
  unsigned int v10;
  xpc_object_t xdict;
  xpc_object_t v13;

  DerivedStorage = (uint64_t *)FigDerivedClockGetDerivedStorage((uint64_t)a1);
  xdict = 0;
  v13 = 0;
  if (!DerivedStorage)
    goto LABEL_14;
  v7 = DerivedStorage;
  CMTime = FigXPCCreateBasicMessage(0x67616E6Bu, *DerivedStorage, &v13);
  if ((_DWORD)CMTime)
  {
LABEL_16:
    int64 = CMTime;
    goto LABEL_15;
  }
  int64 = FigXPCRemoteClientSendSyncMessageCreatingReply(gAudioDeviceClockRemoteClient, (uint64_t)v13, &xdict);
  FigXPCRemoteClientKillServerOnTimeout(gAudioDeviceClockRemoteClient, int64, "remoteDeviceClock_GetAnchorTime", 0);
  if ((_DWORD)int64 == -16152)
  {
LABEL_13:
    MaybeReacquireServerClockObject(a1);
LABEL_14:
    int64 = 4294954550;
    goto LABEL_15;
  }
  if ((_DWORD)int64)
  {
    if ((_DWORD)int64 != -16155 && !*((_BYTE *)v7 + 8))
      goto LABEL_15;
    goto LABEL_13;
  }
  int64 = xpc_dictionary_get_int64(xdict, "LoadStatus");
  if (a2)
  {
    CMTime = FigXPCMessageGetCMTime(xdict, "ClockTime", a2);
    if ((_DWORD)CMTime)
      goto LABEL_16;
  }
  if (a3)
  {
    v10 = FigXPCMessageGetCMTime(xdict, "RefClockTime", a3);
    if (v10)
      int64 = v10;
    else
      int64 = int64;
  }
LABEL_15:
  FigXPCRelease(v13);
  FigXPCRelease(xdict);
  return int64;
}

uint64_t remoteDeviceClock_GetAudioDevice(uint64_t a1, _QWORD *a2, _DWORD *a3, BOOL *a4)
{
  uint64_t DerivedStorage;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  xpc_object_t xdict;
  xpc_object_t v14;

  DerivedStorage = FigDerivedClockGetDerivedStorage(a1);
  xdict = 0;
  v14 = 0;
  if (DerivedStorage)
  {
    v9 = (uint64_t *)DerivedStorage;
    if (!FigDerivedClockVerifyCallbacksMatch(a1, (uint64_t)gFigAudioDeviceRemoteClockCallbacks))
      return FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    v10 = FigXPCCreateBasicMessage(0x67646576u, *v9, &v14);
    if ((_DWORD)v10)
    {
LABEL_14:
      v11 = v10;
      goto LABEL_12;
    }
    v11 = FigXPCRemoteClientSendSyncMessageCreatingReply(gAudioDeviceClockRemoteClient, (uint64_t)v14, &xdict);
    FigXPCRemoteClientKillServerOnTimeout(gAudioDeviceClockRemoteClient, v11, "remoteDeviceClock_GetAudioDevice", 0);
    if (!(_DWORD)v11)
    {
      if (!a2 || (v10 = FigXPCMessageCopyCFString(xdict, "DeviceUID", a2), !(_DWORD)v10))
      {
        if (a3)
          *a3 = xpc_dictionary_get_int64(xdict, "DeviceID");
        v11 = 0;
        if (a4)
          *a4 = xpc_dictionary_get_BOOL(xdict, "TrackDefaultDevice");
        goto LABEL_12;
      }
      goto LABEL_14;
    }
  }
  else
  {
    v11 = 4294954550;
  }
LABEL_12:
  FigXPCRelease(v14);
  FigXPCRelease(xdict);
  return v11;
}

void MaybeReacquireServerClockObject(const void *a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  NSObject *v4;
  _QWORD v5[6];

  DerivedStorage = FigDerivedClockGetDerivedStorage((uint64_t)a1);
  if (FigAtomicCompareAndSwap32(0, 1u, (unsigned int *)(DerivedStorage + 12)))
  {
    v3 = FigDerivedClockGetDerivedStorage((uint64_t)a1);
    if (*(_QWORD *)v3)
    {
      FigXPCRemoteClientDisassociateObject(gAudioDeviceClockRemoteClient, *(const void **)v3);
      *(_QWORD *)v3 = 0;
    }
    CFRetain(a1);
    v4 = *(NSObject **)(v3 + 16);
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 0x40000000;
    v5[2] = __ReacquireServerClockObject_block_invoke;
    v5[3] = &__block_descriptor_tmp_7_2;
    v5[4] = v3;
    v5[5] = a1;
    dispatch_async(v4, v5);
  }
}

uint64_t FigCustomURLRequestInfoMakeNSSecureCodingTypesSerializable(const __CFDictionary *a1)
{
  return figCustomURLMessageMakeNSSecureCodingTypesSerializable(a1, (const void ***)&sRequestInfoKeysRequiringNSSecureCodingSerialization, (const void ***)&sRequestInfoKeysToSerializeTo);
}

uint64_t figCustomURLMessageMakeNSSecureCodingTypesSerializable(const __CFDictionary *a1, const void ***a2, const void ***a3)
{
  void *v6;
  const void *v7;
  const void *v8;
  const void *Value;
  const void *v10;
  void *v11;
  const void *v12;
  uint64_t v13;

  v6 = (void *)MEMORY[0x193FFC34C]();
  if (!a1)
    goto LABEL_9;
  v7 = **a2;
  v8 = **a3;
  Value = CFDictionaryGetValue(a1, v7);
  if (Value)
  {
    v10 = Value;
    if (CFDictionaryContainsKey(a1, v8))
    {
LABEL_7:
      CFDictionaryRemoveValue(a1, v7);
      goto LABEL_8;
    }
    if (objc_msgSend((id)objc_opt_class(), "conformsToProtocol:", &unk_1EE145318))
    {
      v11 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB36F8]), "initRequiringSecureCoding:", 1);
      objc_msgSend(v11, "encodeObject:forKey:", v10, *MEMORY[0x1E0CB2CD0]);
      v12 = (const void *)objc_msgSend(v11, "encodedData");

      if (v12)
      {
        CFDictionarySetValue(a1, v8, v12);
        goto LABEL_7;
      }
    }
LABEL_9:
    v13 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
LABEL_8:
  v13 = 0;
LABEL_10:
  objc_autoreleasePoolPop(v6);
  return v13;
}

uint64_t FigCustomURLRequestInfoDeserializeNSSecureCodingTypes(const __CFDictionary *a1)
{
  return figCustomURLMessageDeserializeNSSecureCodingTypes(a1, (const void ***)&sRequestInfoKeysToSerializeTo, (const void ***)&sRequestInfoKeysRequiringNSSecureCodingSerialization, (NSString **)sRequestInfoClassesForDeserializion);
}

uint64_t figCustomURLMessageDeserializeNSSecureCodingTypes(const __CFDictionary *a1, const void ***a2, const void ***a3, NSString **a4)
{
  void *v8;
  const void *v9;
  const void *v10;
  Class v11;
  const void *Value;
  const void *v13;
  void *v14;
  const void *v15;
  uint64_t v16;

  v8 = (void *)MEMORY[0x193FFC34C]();
  if (!a1)
    goto LABEL_8;
  v9 = **a2;
  v10 = **a3;
  v11 = NSClassFromString(*a4);
  Value = CFDictionaryGetValue(a1, v9);
  if (!Value)
    goto LABEL_7;
  v13 = Value;
  if (CFDictionaryContainsKey(a1, v10))
    goto LABEL_7;
  if (!-[objc_class conformsToProtocol:](v11, "conformsToProtocol:", &unk_1EE145318)
    || (v14 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3710]), "initForReadingFromData:error:", v13, 0),
        v15 = (const void *)objc_msgSend(v14, "decodeObjectOfClass:forKey:", v11, *MEMORY[0x1E0CB2CD0]),
        v14,
        !v15))
  {
LABEL_8:
    v16 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  CFDictionarySetValue(a1, v10, v15);
LABEL_7:
  v16 = 0;
LABEL_9:
  objc_autoreleasePoolPop(v8);
  return v16;
}

uint64_t FigCustomURLResponseInfoMakeNSSecureCodingTypesSerializable(void *a1)
{
  void *v2;
  CFAllocatorRef v3;
  const __CFAllocator *v4;
  uint64_t NSSecureCodingTypesSerializable;
  uint64_t v6;
  CFTypeRef cf;
  CFDictionaryRef theDict;

  v2 = (void *)MEMORY[0x193FFC34C]();
  cf = 0;
  theDict = 0;
  v3 = CFGetAllocator(a1);
  if (a1)
  {
    v4 = v3;
    NSSecureCodingTypesSerializable = FigCustomURLResponseInfoCopyRequestInfo((const __CFDictionary *)a1, (const void **)&theDict);
    if (!(_DWORD)NSSecureCodingTypesSerializable)
    {
      if (!CFDictionaryContainsKey(theDict, *sRequestInfoKeysRequiringNSSecureCodingSerialization)
        || (NSSecureCodingTypesSerializable = FigCustomURLRequestInfoCreateMutableCopy(v4, theDict, &cf),
            !(_DWORD)NSSecureCodingTypesSerializable)
        && (NSSecureCodingTypesSerializable = figCustomURLMessageMakeNSSecureCodingTypesSerializable((const __CFDictionary *)cf, (const void ***)&sRequestInfoKeysRequiringNSSecureCodingSerialization, (const void ***)&sRequestInfoKeysToSerializeTo), !(_DWORD)NSSecureCodingTypesSerializable)&& (NSSecureCodingTypesSerializable = FigCustomURLResponseInfoSetRequestInfo((__CFDictionary *)a1, (void *)cf), !(_DWORD)NSSecureCodingTypesSerializable))
      {
        NSSecureCodingTypesSerializable = figCustomURLMessageMakeNSSecureCodingTypesSerializable((const __CFDictionary *)a1, (const void ***)&sResponseInfoKeysRequiringNSSecureCodingSerialization, (const void ***)&sResponseInfoKeysToSerializeTo);
      }
    }
  }
  else
  {
    NSSecureCodingTypesSerializable = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  v6 = NSSecureCodingTypesSerializable;
  if (theDict)
    CFRelease(theDict);
  if (cf)
    CFRelease(cf);
  objc_autoreleasePoolPop(v2);
  return v6;
}

uint64_t FigCustomURLResponseInfoDeserializeNSSecureCodingTypes(void *a1)
{
  void *v2;
  CFAllocatorRef v3;
  const __CFAllocator *v4;
  uint64_t v5;
  uint64_t v6;
  CFTypeRef cf;
  CFDictionaryRef theDict;

  v2 = (void *)MEMORY[0x193FFC34C]();
  cf = 0;
  theDict = 0;
  v3 = CFGetAllocator(a1);
  if (a1)
  {
    v4 = v3;
    v5 = FigCustomURLResponseInfoCopyRequestInfo((const __CFDictionary *)a1, (const void **)&theDict);
    if (!(_DWORD)v5)
    {
      if (!CFDictionaryContainsKey(theDict, *sRequestInfoKeysToSerializeTo)
        || (v5 = FigCustomURLRequestInfoCreateMutableCopy(v4, theDict, &cf), !(_DWORD)v5)
        && (v5 = figCustomURLMessageDeserializeNSSecureCodingTypes((const __CFDictionary *)cf, (const void ***)&sRequestInfoKeysToSerializeTo, (const void ***)&sRequestInfoKeysRequiringNSSecureCodingSerialization, (NSString **)sRequestInfoClassesForDeserializion), !(_DWORD)v5)&& (v5 = FigCustomURLResponseInfoSetRequestInfo((__CFDictionary *)a1, (void *)cf), !(_DWORD)v5))
      {
        v5 = figCustomURLMessageDeserializeNSSecureCodingTypes((const __CFDictionary *)a1, (const void ***)&sResponseInfoKeysToSerializeTo, (const void ***)&sResponseInfoKeysRequiringNSSecureCodingSerialization, (NSString **)sResponseInfoClassesForDeserializion);
      }
    }
  }
  else
  {
    v5 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  v6 = v5;
  if (theDict)
    CFRelease(theDict);
  if (cf)
    CFRelease(cf);
  objc_autoreleasePoolPop(v2);
  return v6;
}

uint64_t FigCustomURLRequestInfoSetNSURLAuthenticationChallenge(__CFDictionary *a1, void *value)
{
  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (value)
    CFDictionarySetValue(a1, CFSTR("RequestInfoNSURLAuthenticationChallenge"), value);
  else
    CFDictionaryRemoveValue(a1, CFSTR("RequestInfoNSURLAuthenticationChallenge"));
  CFDictionaryRemoveValue(a1, CFSTR("RequestInfoSerializedNSURLAuthenticationChallenge"));
  return 0;
}

uint64_t FigCustomURLRequestInfoCopyNSURLAuthenticationChallenge(const __CFDictionary *a1, const void **value)
{
  uint64_t v3;

  if (!a1 || !value)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (CFDictionaryGetValueIfPresent(a1, CFSTR("RequestInfoNSURLAuthenticationChallenge"), value))
    v3 = 0;
  else
    v3 = 4294949936;
  if (*value)
    CFRetain(*value);
  return v3;
}

uint64_t FigCustomURLResponseInfoSetNSURLCredential(__CFDictionary *a1, void *value)
{
  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (value)
    CFDictionarySetValue(a1, CFSTR("ResponseInfoNSURLCredential"), value);
  else
    CFDictionaryRemoveValue(a1, CFSTR("ResponseInfoNSURLCredential"));
  CFDictionaryRemoveValue(a1, CFSTR("ResponseInfoSerializedNSURLCredential"));
  return 0;
}

uint64_t FigCustomURLResponseInfoCopyNSURLCredential(const __CFDictionary *a1, const void **value)
{
  uint64_t v3;

  if (!a1 || !value)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (CFDictionaryGetValueIfPresent(a1, CFSTR("ResponseInfoNSURLCredential"), value))
    v3 = 0;
  else
    v3 = 4294949936;
  if (*value)
    CFRetain(*value);
  return v3;
}

uint64_t FigCustomURLResponseInfoSetNSURLSessionAuthChallengeDisposition(void *a1, uint64_t a2)
{
  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  FigCFDictionarySetCFIndex(a1, CFSTR("ResponseInfoNSURLSessionAuthChallengeDispositionKey"), a2);
  return 0;
}

uint64_t FigCustomURLResponseInfoGetNSURLSessionAuthChallengeDisposition(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v4;

  v4 = 0;
  if (!a1 || !a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (!FigCFDictionaryGetCFIndexIfPresent(a1, CFSTR("ResponseInfoNSURLSessionAuthChallengeDispositionKey"), &v4))return 4294949936;
  result = 0;
  *a2 = v4;
  return result;
}

uint64_t FigHALAudioConfigChangeCreateRecord(int a1, uint64_t *a2, _QWORD *a3)
{
  char *v6;
  uint64_t v7;

  v6 = (char *)malloc_type_calloc(1uLL, 0x38uLL, 0x100004021716A34uLL);
  if (!v6)
    return FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
  *(_DWORD *)v6 = a1;
  if (a2)
  {
    v7 = *a2;
    *((_DWORD *)v6 + 3) = *((_DWORD *)a2 + 2);
    *(_QWORD *)(v6 + 4) = v7;
  }
  *a3 = v6;
  return 0;
}

uint64_t FigHALAudioConfigChangeCloneRecord(int a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;

  FigHALAudioConfigChangeCreateRecord(a1, 0, a3);
  v5 = *a3;
  v6 = *(_QWORD *)(a2 + 48);
  v8 = *(_OWORD *)(a2 + 16);
  v7 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)v5 = *(_OWORD *)a2;
  *(_OWORD *)(v5 + 16) = v8;
  *(_OWORD *)(v5 + 32) = v7;
  *(_QWORD *)(v5 + 48) = v6;
  return 0;
}

void FigHALAudioConfigChangeSendRequest(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  _QWORD v8[7];
  int v9;

  if (GetHostCallbackQueue_sInitCallbackQueueOnce != -1)
    dispatch_once(&GetHostCallbackQueue_sInitCallbackQueueOnce, &__block_literal_global_21);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __FigHALAudioConfigChangeSendRequest_block_invoke;
  v8[3] = &__block_descriptor_tmp_24;
  v9 = a2;
  v8[4] = a1;
  v8[5] = a3;
  v8[6] = a4;
  dispatch_async((dispatch_queue_t)GetHostCallbackQueue_sCallbackQueue, v8);
}

void FigHALAudioConfigChangeSendRequestWithCustomChangeRecord(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  _QWORD v8[7];
  int v9;

  if (GetHostCallbackQueue_sInitCallbackQueueOnce != -1)
    dispatch_once(&GetHostCallbackQueue_sInitCallbackQueueOnce, &__block_literal_global_21);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __FigHALAudioConfigChangeSendRequestWithCustomChangeRecord_block_invoke;
  v8[3] = &__block_descriptor_tmp_1_1;
  v9 = a2;
  v8[4] = a1;
  v8[5] = a3;
  v8[6] = a4;
  dispatch_async((dispatch_queue_t)GetHostCallbackQueue_sCallbackQueue, v8);
}

void FigHALAudioPropertySendOneChange(uint64_t (**a1)(_QWORD, uint64_t, uint64_t, _DWORD *), uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v11;
  _BOOL4 v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  _BYTE *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  NSObject *v42;
  int v43;
  uint64_t v44;
  unsigned int v45;
  _BYTE *v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  uint64_t (**v54)(_QWORD, uint64_t, uint64_t, _DWORD *);
  os_log_type_t type;
  int v56;
  _DWORD v57[3];
  int v58;
  const char *v59;
  __int16 v60;
  int v61;
  __int16 v62;
  int v63;
  __int16 v64;
  int v65;
  __int16 v66;
  int v67;
  __int16 v68;
  int v69;
  __int16 v70;
  int v71;
  __int16 v72;
  int v73;
  __int16 v74;
  int v75;
  __int16 v76;
  int v77;
  __int16 v78;
  int v79;
  __int16 v80;
  int v81;
  __int16 v82;
  int v83;
  _BYTE v84[128];
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  v57[0] = a3;
  v57[1] = a4;
  v57[2] = a5;
  v56 = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v56, &type);
  v11 = v56;
  v12 = os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type);
  v14 = v11 & 0xFFFFFFFE;
  if (v12)
    v14 = v11;
  if (v14)
  {
    v15 = MEMORY[0x1E0C80978];
    if ((a3 & 0x80000000) != 0)
      v16 = __maskrune(HIBYTE(a3), 0x40000uLL);
    else
      v16 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * HIBYTE(a3) + 60) & 0x40000;
    if (v16)
      v18 = HIBYTE(a3);
    else
      v18 = 46;
    v53 = v18;
    if (BYTE2(a3) > 0x7Fu)
      v19 = __maskrune(BYTE2(a3), 0x40000uLL);
    else
      v19 = *(_DWORD *)(v15 + 4 * BYTE2(a3) + 60) & 0x40000;
    if (v19)
      v20 = BYTE2(a3);
    else
      v20 = 46;
    v52 = v20;
    if (BYTE1(a3) > 0x7Fu)
      v21 = __maskrune(BYTE1(a3), 0x40000uLL);
    else
      v21 = *(_DWORD *)(v15 + 4 * BYTE1(a3) + 60) & 0x40000;
    if (v21)
      v22 = BYTE1(a3);
    else
      v22 = 46;
    v51 = v22;
    if (a3 > 0x7Fu)
      v23 = __maskrune(a3, 0x40000uLL);
    else
      v23 = *(_DWORD *)(v15 + 4 * a3 + 60) & 0x40000;
    if (v23)
      v24 = a3;
    else
      v24 = 46;
    v50 = v24;
    if ((a4 & 0x80000000) != 0)
      v25 = __maskrune(HIBYTE(a4), 0x40000uLL);
    else
      v25 = *(_DWORD *)(v15 + 4 * HIBYTE(a4) + 60) & 0x40000;
    if (v25)
      v26 = HIBYTE(a4);
    else
      v26 = 46;
    v49 = v26;
    if (BYTE2(a4) > 0x7Fu)
      v27 = __maskrune(BYTE2(a4), 0x40000uLL);
    else
      v27 = *(_DWORD *)(v15 + 4 * BYTE2(a4) + 60) & 0x40000;
    if (v27)
      v28 = BYTE2(a4);
    else
      v28 = 46;
    v48 = v28;
    if (BYTE1(a4) > 0x7Fu)
      v29 = __maskrune(BYTE1(a4), 0x40000uLL);
    else
      v29 = *(_DWORD *)(v15 + 4 * BYTE1(a4) + 60) & 0x40000;
    if (v29)
      v30 = BYTE1(a4);
    else
      v30 = 46;
    v47 = v30;
    v54 = a1;
    if (a4 > 0x7Fu)
      v31 = __maskrune(a4, 0x40000uLL);
    else
      v31 = *(_DWORD *)(v15 + 4 * a4 + 60) & 0x40000;
    if (v31)
      v32 = a4;
    else
      v32 = 46;
    if ((a5 & 0x80000000) != 0)
      v33 = __maskrune(HIBYTE(a5), 0x40000uLL);
    else
      v33 = *(_DWORD *)(v15 + 4 * HIBYTE(a5) + 60) & 0x40000;
    if (v33)
      v34 = HIBYTE(a5);
    else
      v34 = 46;
    if (BYTE2(a5) > 0x7Fu)
      v35 = __maskrune(BYTE2(a5), 0x40000uLL);
    else
      v35 = *(_DWORD *)(v15 + 4 * BYTE2(a5) + 60) & 0x40000;
    if (v35)
      v36 = BYTE2(a5);
    else
      v36 = 46;
    if (BYTE1(a5) > 0x7Fu)
      v37 = __maskrune(BYTE1(a5), 0x40000uLL);
    else
      v37 = *(_DWORD *)(v15 + 4 * BYTE1(a5) + 60) & 0x40000;
    if (v37)
      v38 = BYTE1(a5);
    else
      v38 = 46;
    if (a5 > 0x7Fu)
      v39 = __maskrune(a5, 0x40000uLL);
    else
      v39 = *(_DWORD *)(v15 + 4 * a5 + 60) & 0x40000;
    v58 = 136318210;
    if (v39)
      v40 = a5;
    else
      v40 = 46;
    v59 = "FigHALAudioPropertySendOneChange";
    v60 = 1024;
    v61 = v53;
    v62 = 1024;
    v63 = v52;
    v64 = 1024;
    v65 = v51;
    v66 = 1024;
    v67 = v50;
    v68 = 1024;
    v69 = v49;
    v70 = 1024;
    v71 = v48;
    v72 = 1024;
    v73 = v47;
    v74 = 1024;
    v75 = v32;
    v76 = 1024;
    v77 = v34;
    v78 = 1024;
    v79 = v36;
    v80 = 1024;
    v81 = v38;
    v82 = 1024;
    v83 = v40;
    v17 = (_BYTE *)_os_log_send_and_compose_impl();
    LOBYTE(v11) = v56;
    a2 = a2;
    a1 = v54;
  }
  else
  {
    v17 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v17, v17 != v84, v11, 0, v13);
  v41 = (*a1)(a1, a2, 1, v57);
  v56 = 0;
  type = OS_LOG_TYPE_DEFAULT;
  v42 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v56, &type);
  v43 = v56;
  if (os_log_type_enabled(v42, type))
    v45 = v43;
  else
    v45 = v43 & 0xFFFFFFFE;
  if (v45)
  {
    v58 = 136316162;
    v59 = "FigHALAudioPropertySendOneChange";
    v60 = 1024;
    v61 = v41;
    v62 = 1024;
    v63 = a3;
    v64 = 1024;
    v65 = a4;
    v66 = 1024;
    v67 = a5;
    v46 = (_BYTE *)_os_log_send_and_compose_impl();
    LOBYTE(v43) = v56;
  }
  else
  {
    v46 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v46, v46 != v84, v43, 0, v44);
}

void FigHALAudioPropertySendChanges(uint64_t (**a1)(_QWORD, uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v9;
  uint64_t v10;
  unsigned int v11;
  _BYTE *v12;
  int v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  _BYTE *v18;
  os_log_type_t type;
  int v20;
  int v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  _BYTE v29[128];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v20 = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v20, &type);
  v9 = v20;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v11 = v9;
  else
    v11 = v9 & 0xFFFFFFFE;
  if (v11)
  {
    v21 = 136315650;
    v22 = "FigHALAudioPropertySendChanges";
    v23 = 1024;
    v24 = a2;
    v25 = 1024;
    v26 = a3;
    v12 = (_BYTE *)_os_log_send_and_compose_impl();
    LOBYTE(v9) = v20;
  }
  else
  {
    v12 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v12, v12 != v29, v9, 0, v10);
  v13 = (*a1)(a1, a2, a3, a4);
  v20 = 0;
  type = OS_LOG_TYPE_DEFAULT;
  v14 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v20, &type);
  v15 = v20;
  if (os_log_type_enabled(v14, type))
    v17 = v15;
  else
    v17 = v15 & 0xFFFFFFFE;
  if (v17)
  {
    v21 = 136315906;
    v22 = "FigHALAudioPropertySendChanges";
    v23 = 1024;
    v24 = v13;
    v25 = 1024;
    v26 = a2;
    v27 = 1024;
    v28 = a3;
    v18 = (_BYTE *)_os_log_send_and_compose_impl();
    LOBYTE(v15) = v20;
  }
  else
  {
    v18 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v18, v18 != v29, v15, 0, v16);
}

void FigHALAudioPropertySendOneChangeAsync(uint64_t a1, int a2, int a3, int a4, int a5)
{
  _QWORD block[5];
  int v11;
  int v12;
  int v13;
  int v14;

  if (GetHostCallbackQueue_sInitCallbackQueueOnce != -1)
    dispatch_once(&GetHostCallbackQueue_sInitCallbackQueueOnce, &__block_literal_global_21);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigHALAudioPropertySendOneChangeAsync_block_invoke;
  block[3] = &__block_descriptor_tmp_2_0;
  block[4] = a1;
  v11 = a2;
  v12 = a3;
  v13 = a4;
  v14 = a5;
  dispatch_async((dispatch_queue_t)GetHostCallbackQueue_sCallbackQueue, block);
}

void ids_didReceivePackage(const void *a1, const void *a2)
{
  _BYTE *DerivedStorage;
  _BYTE *v5;
  NSObject *v6;
  _QWORD block[7];

  if (a1 && a2)
  {
    DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
    if (!*DerivedStorage)
    {
      v5 = DerivedStorage;
      CFRetain(a2);
      CFRetain(a1);
      v6 = *((_QWORD *)v5 + 6);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __ids_didReceivePackage_block_invoke;
      block[3] = &__block_descriptor_56_e5_v8__0l;
      block[4] = v5;
      block[5] = a2;
      block[6] = a1;
      dispatch_async(v6, block);
    }
  }
}

uint64_t FigTransportConnectionIDSCreate(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4;
  _QWORD *ClassID;
  uint64_t DerivedStorage;
  void *v7;
  void *v8;
  unint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  NSObject *v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  _BYTE *v17;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v19;
  uint64_t v20;
  unsigned int v21;
  _BYTE *v22;
  __objc2_class *v23;
  id v24;
  uint64_t v25;
  dispatch_queue_t v26;
  dispatch_queue_t v27;
  dispatch_semaphore_t v28;
  dispatch_semaphore_t v29;
  __CFDictionary *Mutable;
  OpaqueCMMemoryPool *v31;
  CFAllocatorRef Allocator;
  os_log_type_t type;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  CFTypeRef cf;
  int v43;
  const char *v44;
  _BYTE v45[128];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  cf = 0;
  if (a2)
  {
    if (FigTransportConnectionIDSCreate_onceToken != -1)
      dispatch_once(&FigTransportConnectionIDSCreate_onceToken, &__block_literal_global_22);
    v4 = 0;
    if (!ids_IDSOpenSocketOptionTransportKey)
      goto LABEL_13;
    if (!ids_IDSOpenSocketOptionPriorityKey)
      goto LABEL_13;
    if (!ids_IDSOpenSocketOptionScopeKey)
      goto LABEL_13;
    if (!ids_IDSLinkPreferenceOptionPacketsPerSecondKey)
      goto LABEL_13;
    if (!ids_IDSLinkPreferenceOptionInputBytesPerSecondKey)
      goto LABEL_13;
    if (!ids_IDSLinkPreferenceOptionOutputBytesPerSecondKey)
      goto LABEL_13;
    if (!ids_IDSDeviceConnectionClass)
      goto LABEL_13;
    if (!ids_IDSServiceClass)
      goto LABEL_13;
    ClassID = (_QWORD *)NeroTransportConnectionGetClassID();
    v4 = CMDerivedObjectCreate(a1, (uint64_t)&kFigTransportConnectionUSBVTable, ClassID, &cf);
    if ((_DWORD)v4)
      goto LABEL_13;
    DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
    v7 = (void *)objc_msgSend(objc_alloc((Class)ids_IDSServiceClass), "initWithService:", CFSTR("com.apple.private.alloy.fignero"));
    v8 = (void *)objc_msgSend(v7, "devices");
    if (objc_msgSend(v8, "count"))
    {
      v9 = 0;
      do
      {
        if (objc_msgSend((id)objc_msgSend(v8, "objectAtIndexedSubscript:", v9), "isDefaultPairedDevice"))
          *(_QWORD *)(DerivedStorage + 160) = objc_msgSend(v8, "objectAtIndexedSubscript:", v9);
        ++v9;
      }
      while (objc_msgSend(v8, "count") > v9);
    }
    v10 = objc_msgSend(*(id *)(DerivedStorage + 160), "deviceType");
    v11 = *(void **)(DerivedStorage + 160);
    if (v10 == 6)
    {
      if (v11)
      {
        objc_msgSend(v11, "operatingSystemVersion");
        if (v39 > 10)
          goto LABEL_28;
        v11 = *(void **)(DerivedStorage + 160);
      }
      else
      {
        v39 = 0;
        v40 = 0;
        v41 = 0;
      }
    }
    if (objc_msgSend(v11, "deviceType") != 2)
      goto LABEL_36;
    v12 = *(void **)(DerivedStorage + 160);
    if (!v12)
    {
      v36 = 0;
      v37 = 0;
      v38 = 0;
      goto LABEL_36;
    }
    objc_msgSend(v12, "operatingSystemVersion");
    if (v36 < 18)
    {
LABEL_36:
      v35 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v35, &type);
      v19 = v35;
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v21 = v19;
      else
        v21 = v19 & 0xFFFFFFFE;
      if (v21)
      {
        v43 = 136315138;
        v44 = "FigTransportConnectionIDSCreate";
        v22 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v19) = v35;
      }
      else
      {
        v22 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v22, v22 != v45, v19, 0, v20);
      v23 = NeroMessageCenterSocket;
LABEL_45:
      v24 = [v23 alloc];
      v25 = objc_msgSend(v24, "initWithIDSSerivce:connection:", v7, cf);
      *(_QWORD *)(DerivedStorage + 72) = v25;
      if (v25)
      {
        v26 = FigDispatchQueueCreateWithPriority("FigTransportConnectionIDS", 0, 0x1Cu);
        *(_QWORD *)(DerivedStorage + 8) = v26;
        if (v26)
        {
          v27 = FigDispatchQueueCreateWithPriority("FigTransportConnectionIDS.data", 0, 0x1Cu);
          *(_QWORD *)(DerivedStorage + 16) = v27;
          if (v27)
          {
            v28 = dispatch_semaphore_create(0);
            *(_QWORD *)(DerivedStorage + 144) = v28;
            if (v28)
            {
              v29 = dispatch_semaphore_create(0);
              *(_QWORD *)(DerivedStorage + 152) = v29;
              if (v29)
              {
                Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                CFDictionarySetValue(Mutable, CFSTR("FigMemoryPool_LoggingName"), CFSTR("TransportConnectionIDS"));
                v31 = CMMemoryPoolCreate(Mutable);
                *(_QWORD *)(DerivedStorage + 56) = v31;
                if (Mutable)
                {
                  CFRelease(Mutable);
                  v31 = *(OpaqueCMMemoryPool **)(DerivedStorage + 56);
                }
                if (v31)
                {
                  Allocator = CMMemoryPoolGetAllocator(v31);
                  *(_QWORD *)(DerivedStorage + 64) = Allocator;
                  if (Allocator)
                    CFRetain(Allocator);
                  v4 = 0;
                  *a2 = cf;
                  return v4;
                }
              }
            }
          }
        }
      }
      v4 = 4294955245;
LABEL_13:
      if (cf)
        CFRelease(cf);
      return v4;
    }
LABEL_28:
    if (FigGetCFPreferenceBooleanWithDefault(CFSTR("EnableNeroIDSService"), CFSTR("com.apple.coremedia"), 0)|| _os_feature_enabled_impl())
    {
      v35 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v13 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v35, &type);
      v14 = v35;
      if (os_log_type_enabled(v13, type))
        v16 = v14;
      else
        v16 = v14 & 0xFFFFFFFE;
      if (v16)
      {
        v43 = 136315138;
        v44 = "FigTransportConnectionIDSCreate";
        v17 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v14) = v35;
      }
      else
      {
        v17 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v17, v17 != v45, v14, 0, v15);
      v23 = NeroMessageCenterService;
      goto LABEL_45;
    }
    goto LABEL_36;
  }
  return FigSignalErrorAt(4294955246, 0, 0, 0, 0, 0, 0);
}

void __ids_didReceivePackage_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)v2)
  {
    v3 = *(_QWORD *)(v2 + 40);
    if (v3)
      (*(void (**)(uint64_t, _QWORD, _QWORD))(v3 + 16))(v3, 0, *(_QWORD *)(a1 + 40));
  }
  CFRelease(*(CFTypeRef *)(a1 + 48));
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

uint64_t ids_Invalidate(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v2;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  *(_BYTE *)DerivedStorage = 1;
  v2 = *(const void **)(DerivedStorage + 72);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(DerivedStorage + 72) = 0;
  }
  return 0;
}

void ids_Finalize(uint64_t a1)
{
  _QWORD *DerivedStorage;
  NSObject *v3;
  NSObject *v4;
  const void *v5;
  NSObject *v6;
  NSObject *v7;
  const void *v8;
  const void *v9;
  NSObject *v10;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  ids_Invalidate(a1);
  v3 = DerivedStorage[1];
  if (v3)
  {
    dispatch_release(v3);
    DerivedStorage[1] = 0;
  }
  v4 = DerivedStorage[2];
  if (v4)
  {
    dispatch_release(v4);
    DerivedStorage[2] = 0;
  }
  v5 = (const void *)DerivedStorage[5];
  if (v5)
  {
    _Block_release(v5);
    DerivedStorage[5] = 0;
  }
  v6 = DerivedStorage[18];
  if (v6)
  {
    dispatch_release(v6);
    DerivedStorage[18] = 0;
  }
  v7 = DerivedStorage[19];
  if (v7)
  {
    dispatch_release(v7);
    DerivedStorage[19] = 0;
  }
  v8 = (const void *)DerivedStorage[7];
  if (v8)
  {
    CFRelease(v8);
    DerivedStorage[7] = 0;
  }
  v9 = (const void *)DerivedStorage[8];
  if (v9)
  {
    CFRelease(v9);
    DerivedStorage[8] = 0;
  }
  v10 = DerivedStorage[6];
  if (v10)
  {
    dispatch_release(v10);
    DerivedStorage[6] = 0;
  }
}

__CFString *ids_CopyDebugDescription(uint64_t a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigTransportConnectionIDS %p>"), a1);
  return Mutable;
}

uint64_t ids_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  _BYTE *DerivedStorage;
  _BYTE *v7;
  const void *v8;
  void *v9;
  const __CFAllocator *v10;
  int *p_valuePtr;
  void *v12;
  uint64_t result;
  int valuePtr;

  DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage)
    return 4294955241;
  v7 = DerivedStorage;
  if (!CFEqual(a2, CFSTR("ConnectionMode")))
  {
    if (CFEqual(a2, CFSTR("Version")))
    {
      v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      p_valuePtr = (int *)(v7 + 32);
    }
    else
    {
      if (!CFEqual(a2, CFSTR("ReplyTimeout")))
        return 4294954512;
      valuePtr = 6;
      v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      p_valuePtr = &valuePtr;
    }
    v9 = CFNumberCreate(v10, kCFNumberSInt32Type, p_valuePtr);
    goto LABEL_11;
  }
  v8 = (const void *)*((_QWORD *)v7 + 3);
  if (v8)
  {
    v9 = (void *)CFRetain(v8);
LABEL_11:
    v12 = v9;
    goto LABEL_12;
  }
  v12 = 0;
LABEL_12:
  result = 0;
  *a4 = v12;
  return result;
}

uint64_t ids_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  _BYTE *DerivedStorage;
  _BYTE *v6;
  uint64_t v7;
  CFTypeID v8;

  DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage)
    return 4294955241;
  v6 = DerivedStorage;
  if (CFEqual(a2, CFSTR("ConnectionMode")))
  {
    v7 = *((_QWORD *)v6 + 3);
    *((_QWORD *)v6 + 3) = a3;
    if (a3)
      CFRetain(a3);
    if (v7)
    {
      CFRelease((CFTypeRef)v7);
      return 0;
    }
  }
  else if (CFEqual(a2, CFSTR("Version")))
  {
    if (a3)
    {
      v8 = CFGetTypeID(a3);
      v7 = 4294954516;
      if (v8 == CFNumberGetTypeID())
      {
        if (CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, v6 + 32))
          return 0;
        else
          return 4294954516;
      }
    }
    else
    {
      return 4294954516;
    }
  }
  else
  {
    return 4294954512;
  }
  return v7;
}

uint64_t ids_SetEventHandler(uint64_t a1, NSObject *a2, unint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t v6;
  NSObject *v7;
  const void *v8;
  void *v9;
  uint64_t result;
  _QWORD block[5];

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)DerivedStorage)
    return 4294955241;
  v6 = DerivedStorage;
  v7 = *(NSObject **)(DerivedStorage + 48);
  if ((unint64_t)a2 | a3)
  {
    if (v7)
    {
      dispatch_release(v7);
      *(_QWORD *)(v6 + 48) = 0;
    }
    if (a2)
    {
      *(_QWORD *)(v6 + 48) = a2;
      dispatch_retain(a2);
    }
    else
    {
      *(_QWORD *)(v6 + 48) = FigDispatchQueueCreateWithPriority("FigTransportConnectionEvent", 0, 0x1Cu);
    }
    v8 = *(const void **)(v6 + 40);
    if (v8)
    {
      _Block_release(v8);
      *(_QWORD *)(v6 + 40) = 0;
    }
    if (a3)
    {
      v9 = _Block_copy((const void *)a3);
      result = 0;
      *(_QWORD *)(v6 + 40) = v9;
      return result;
    }
  }
  else
  {
    if (!v7)
      return 4294955240;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __ids_SetEventHandler_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = v6;
    dispatch_sync(v7, block);
  }
  return 0;
}

uint64_t ids_Start(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  int v4;
  const __CFDictionary *v5;
  uint64_t result;
  void *values;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)DerivedStorage)
    return 4294955241;
  v3 = DerivedStorage;
  objc_msgSend(*(id *)(DerivedStorage + 72), "activateConnection");
  v4 = *(_DWORD *)(v3 + 36);
  if (!v4)
  {
    if (*(_QWORD *)(v3 + 80))
      return 4294955243;
    *(_BYTE *)(v3 + 88) = 0;
    values = CFSTR("FigTransportConnectionIDS.mainThread");
    v5 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&kFigThreadCreateKey_Identifier, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    FigThreadCreate((uint64_t)ids_threadMain, a1, 0x1Cu, 1, v5, (pthread_t *)(v3 + 80));
    if (v5)
      CFRelease(v5);
    v4 = *(_DWORD *)(v3 + 36);
  }
  result = 0;
  *(_DWORD *)(v3 + 36) = v4 + 1;
  return result;
}

uint64_t ids_Stop(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v2;
  NSObject *v3;
  _QWORD block[5];

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)DerivedStorage)
    return 4294955241;
  v2 = DerivedStorage;
  v3 = *(NSObject **)(DerivedStorage + 8);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __ids_Stop_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = v2;
  dispatch_sync(v3, block);
  objc_msgSend(*(id *)(v2 + 72), "deactivateConnection");
  return 0;
}

uint64_t ids_EnqueuePackageWithPriority(const void *a1, unsigned int *a2, OpaqueCMBlockBuffer *a3, int a4)
{
  uint64_t DerivedStorage;
  uint64_t v9;
  size_t DataLength;
  size_t v11;
  size_t v12;
  size_t v13;
  char *v14;
  size_t v15;
  size_t v16;
  _QWORD *v17;
  _QWORD *v18;
  NSObject *v19;
  uint64_t v21;
  int v22;
  _QWORD block[7];
  int v24;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v9 = *a2;
  DataLength = CMBlockBufferGetDataLength(a3);
  if (*(_BYTE *)DerivedStorage)
    return 4294955241;
  if (a2[1] == 1885957735)
    goto LABEL_17;
  if (!*(_BYTE *)(DerivedStorage + 89))
  {
    v21 = 4294955244;
    return FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
  }
  if ((a4 - 3) <= 0xFFFFFFFD || (v11 = v9 - DataLength, v9 - DataLength <= 7))
  {
LABEL_17:
    v21 = 4294955246;
    return FigSignalErrorAt(v21, 0, 0, 0, 0, 0, 0);
  }
  v22 = a4;
  v12 = CMBlockBufferGetDataLength(a3);
  v13 = v12 + v11;
  v14 = (char *)malloc_type_malloc(v12 + v11, 0xDE31DCB9uLL);
  lengthAtOffsetOut = 0;
  dataPointerOut = 0;
  memcpy(v14, a2, v11);
  if (v12)
  {
    v15 = 0;
    while (1)
    {
      lengthAtOffsetOut = -1;
      dataPointerOut = 0;
      if (CMBlockBufferGetDataPointer(a3, v15, &lengthAtOffsetOut, 0, &dataPointerOut))
        break;
      v16 = lengthAtOffsetOut;
      if (v13 < lengthAtOffsetOut + v15 + v11)
        break;
      memcpy(&v14[v15 + v11], dataPointerOut, lengthAtOffsetOut);
      v15 += v16;
      if (v15 >= v12)
        goto LABEL_11;
    }
  }
  else
  {
LABEL_11:
    v17 = malloc_type_calloc(1uLL, 0x18uLL, 0x10A00404E934A1DuLL);
    if (v17)
    {
      v18 = v17;
      v17[1] = v14;
      v17[2] = v13;
      CFRetain(a1);
      v19 = *(NSObject **)(DerivedStorage + 16);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __ids_EnqueuePackageWithPriority_block_invoke;
      block[3] = &__block_descriptor_60_e5_v8__0l;
      block[4] = v18;
      block[5] = DerivedStorage;
      v24 = v22;
      block[6] = a1;
      dispatch_async(v19, block);
      return 0;
    }
  }
  if (v14)
    CFRelease(v14);
  return 4294955245;
}

uint64_t ids_FlushPendingPackagesWithPriority(uint64_t a1, int a2)
{
  _BYTE *DerivedStorage;
  _BYTE *v5;
  NSObject *v6;
  dispatch_time_t v7;

  DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage(a1);
  if (*DerivedStorage)
    return 4294955241;
  v5 = DerivedStorage;
  while (!v5[88])
  {
    v6 = *((_QWORD *)v5 + 19);
    v7 = dispatch_time(0, 15000000);
    if (dispatch_semaphore_wait(v6, v7))
      break;
    ids_sendData(a1, a2);
  }
  return 0;
}

uint64_t ids_threadMain(const void *a1)
{
  uint64_t DerivedStorage;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  NSObject *v7;
  void *v8;
  NSObject *v9;
  NSObject *v10;
  dispatch_time_t v11;
  _QWORD v13[6];
  _QWORD block[6];

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (!*(_BYTE *)(DerivedStorage + 88))
  {
    v3 = DerivedStorage;
    v4 = MEMORY[0x1E0C809B0];
    do
    {
      if (!objc_msgSend(*(id *)(v3 + 72), "isActive"))
        break;
      v5 = (void *)MEMORY[0x193FFC34C]();
      v6 = CMBaseObjectGetDerivedStorage((uint64_t)a1);
      CFRetain(a1);
      v7 = *(NSObject **)(v6 + 16);
      block[0] = v4;
      block[1] = 3221225472;
      block[2] = __ids_sendPackagesMain_block_invoke;
      block[3] = &__block_descriptor_48_e5_v8__0l;
      block[4] = v6;
      block[5] = a1;
      dispatch_async(v7, block);
      while (!*(_BYTE *)(v6 + 88) && objc_msgSend(*(id *)(v6 + 72), "isActive"))
      {
        v8 = (void *)MEMORY[0x193FFC34C]();
        dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v6 + 152), 0xFFFFFFFFFFFFFFFFLL);
        ids_sendData((uint64_t)a1, 0);
        objc_autoreleasePoolPop(v8);
      }
      CFRetain(a1);
      v9 = *(NSObject **)(v6 + 16);
      v13[0] = v4;
      v13[1] = 3221225472;
      v13[2] = __ids_sendPackagesMain_block_invoke_3;
      v13[3] = &__block_descriptor_48_e5_v8__0l;
      v13[4] = v6;
      v13[5] = a1;
      dispatch_async(v9, v13);
      v10 = *(NSObject **)(v3 + 144);
      v11 = dispatch_time(0, 5000000000);
      dispatch_semaphore_wait(v10, v11);
      objc_autoreleasePoolPop(v5);
    }
    while (!*(_BYTE *)(v3 + 88));
  }
  return 0;
}

void __ids_sendPackagesMain_block_invoke(uint64_t a1)
{
  uint64_t i;
  _BYTE *v3;
  _QWORD v4[4];
  __int128 v5;

  for (i = 0; i != 32; i += 16)
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + i + 112) = 0;
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + i + 120) = *(_QWORD *)(a1 + 32) + i + 112;
  }
  v3 = *(_BYTE **)(a1 + 32);
  v3[89] = 1;
  if (!*v3)
  {
    CFRetain(*(CFTypeRef *)(a1 + 40));
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 3221225472;
    v4[2] = __ids_sendPackagesMain_block_invoke_2;
    v4[3] = &__block_descriptor_48_e5_v8__0l;
    v5 = *(_OWORD *)(a1 + 32);
    dispatch_async(*(dispatch_queue_t *)(v5 + 48), v4);
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void __ids_sendPackagesMain_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)v2)
  {
    v3 = *(_QWORD *)(v2 + 40);
    if (v3)
      (*(void (**)(uint64_t, uint64_t, _QWORD))(v3 + 16))(v3, 1, 0);
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void ids_sendData(uint64_t a1, int a2)
{
  uint64_t DerivedStorage;
  NSObject *v4;
  _QWORD v5[5];
  int v6;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v4 = *(NSObject **)(DerivedStorage + 16);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __ids_sendData_block_invoke;
  v5[3] = &__block_descriptor_44_e5_v8__0l;
  v6 = a2;
  v5[4] = DerivedStorage;
  dispatch_sync(v4, v5);
}

void __ids_sendPackagesMain_block_invoke_3(uint64_t a1)
{
  _BYTE *v2;
  uint64_t i;
  _BYTE *v4;
  void **v5;
  void **v6;
  void **v7;
  void *v8;
  _QWORD v9[4];
  __int128 v10;

  v2 = *(_BYTE **)(a1 + 32);
  v2[89] = 0;
  if (!*v2)
  {
    CFRetain(*(CFTypeRef *)(a1 + 40));
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = __ids_sendPackagesMain_block_invoke_4;
    v9[3] = &__block_descriptor_48_e5_v8__0l;
    v10 = *(_OWORD *)(a1 + 32);
    dispatch_async(*(dispatch_queue_t *)(v10 + 48), v9);
    v2 = *(_BYTE **)(a1 + 32);
  }
  for (i = 1; i != 3; ++i)
  {
    while (1)
    {
      v4 = &v2[16 * i];
      v7 = (void **)*((_QWORD *)v4 + 12);
      v5 = (void **)(v4 + 96);
      v6 = v7;
      if (!v7)
        break;
      v8 = *v6;
      *v5 = *v6;
      if (!v8)
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * i + 104) = *(_QWORD *)(a1 + 32) + 16 * i + 96;
      free(v6[1]);
      free(v6);
      v2 = *(_BYTE **)(a1 + 32);
    }
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void __ids_sendPackagesMain_block_invoke_4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)v2)
  {
    v3 = *(_QWORD *)(v2 + 40);
    if (v3)
      (*(void (**)(uint64_t, uint64_t, _QWORD))(v3 + 16))(v3, 2, 0);
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

void __ids_sendData_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;

  v2 = *(int *)(a1 + 40);
  if ((_DWORD)v2)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = *(_QWORD **)(v3 + 16 * v2 + 96);
    if (v4 && objc_msgSend(*(id *)(v3 + 72), "sendMemoryBlock:withLength:", v4[1], v4[2]))
    {
      v5 = *(int *)(a1 + 40);
      v6 = *(_QWORD *)(a1 + 32) + 16 * v5;
      v7 = **(_QWORD **)(v6 + 96);
      *(_QWORD *)(v6 + 96) = v7;
      if (!v7)
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * v5 + 104) = *(_QWORD *)(a1 + 32) + 16 * v5 + 96;
      free(v4);
    }
  }
  else
  {
    for (i = 112; i != 144; i += 16)
    {
      v9 = *(_QWORD *)(a1 + 32);
      v10 = *(_QWORD **)(v9 + i);
      if (v10 && objc_msgSend(*(id *)(v9 + 72), "sendMemoryBlock:withLength:", v10[1], v10[2]))
      {
        v11 = *(_QWORD *)(a1 + 32);
        v12 = **(_QWORD **)(v11 + i);
        *(_QWORD *)(v11 + i) = v12;
        if (!v12)
          *(_QWORD *)(*(_QWORD *)(a1 + 32) + i + 8) = *(_QWORD *)(a1 + 32) + i;
        free(v10);
      }
    }
  }
}

uint64_t FigIsHDRAllowedOnDevice()
{
  if (FigIsHDRAllowedOnDevice_onceTokenIsHDRAllowedOnDevice != -1)
    dispatch_once(&FigIsHDRAllowedOnDevice_onceTokenIsHDRAllowedOnDevice, &__block_literal_global_23);
  return FigIsHDRAllowedOnDevice_sIsHDRAllowedOnDevice;
}

BOOL FigIsDeviceCapableOfGeneratingStatisticsForHDR()
{
  if (FigIsDeviceCapableOfGeneratingStatisticsForHDR_onceTokenDeviceCapableOfGeneratingStatisticsForHDR != -1)
    dispatch_once(&FigIsDeviceCapableOfGeneratingStatisticsForHDR_onceTokenDeviceCapableOfGeneratingStatisticsForHDR, &__block_literal_global_3);
  return (FigIsDeviceCapableOfGeneratingStatisticsForHDR_sDeviceCapableOfGeneratingStatisticsForHDR & 1) == 0;
}

OSStatus CMAudioFormatDescriptionCreateFromBigEndianSoundDescriptionData(CFAllocatorRef allocator, const uint8_t *soundDescriptionData, size_t size, CMSoundDescriptionFlavor flavor, CMAudioFormatDescriptionRef *formatDescriptionOut)
{
  OSStatus BlockBufferCopyingMemoryBlock;
  OSStatus v9;
  CFTypeRef cf;

  cf = 0;
  BlockBufferCopyingMemoryBlock = FigCreateBlockBufferCopyingMemoryBlock(allocator, soundDescriptionData, size, (CMBlockBufferRef *)&cf);
  if (!BlockBufferCopyingMemoryBlock)
    BlockBufferCopyingMemoryBlock = FigAudioFormatDescriptionCreateFromBigEndianSoundDescriptionBlockBufferWithReporter(allocator, (CMBlockBufferRef)cf, flavor, formatDescriptionOut, 0);
  v9 = BlockBufferCopyingMemoryBlock;
  if (cf)
    CFRelease(cf);
  return v9;
}

OSStatus CMAudioFormatDescriptionCreateFromBigEndianSoundDescriptionBlockBuffer(CFAllocatorRef allocator, CMBlockBufferRef soundDescriptionBlockBuffer, CMSoundDescriptionFlavor flavor, CMAudioFormatDescriptionRef *formatDescriptionOut)
{
  return FigAudioFormatDescriptionCreateFromBigEndianSoundDescriptionBlockBufferWithReporter(allocator, soundDescriptionBlockBuffer, flavor, formatDescriptionOut, 0);
}

uint64_t FigAudioFormatDescriptionCreateFromBigEndianSoundDescriptionBlockBufferWithReporter(const __CFAllocator *a1, CMBlockBufferRef theSourceBuffer, CFTypeRef cf1, CMAudioFormatDescriptionRef *a4, uint64_t a5)
{
  CFTypeRef v7;
  __int128 v10;
  uint64_t v11;
  int v12;
  int v13;
  const char *v14;
  size_t v15;
  const char *v16;
  int IsBlockBufferISOv1;
  int v18;
  signed int v19;
  size_t DataLength;
  int CFPreferenceNumberWithDefault;
  char v22;
  int64_t v23;
  uint64_t Empty;
  unsigned int v25;
  CFTypeRef *v26;
  uint64_t CurrentAtomTypeAndDataLength;
  char v28;
  size_t v29;
  int v30;
  CFTypeRef *v31;
  __CFData *Mutable;
  const __CFData *v33;
  UInt8 *BytePtr;
  uint64_t CurrentAtomUUIDType;
  const UInt8 *v36;
  int v37;
  uint64_t ESDSAtomAndData;
  CMBlockBufferRef *v39;
  int v40;
  uint64_t CurrentAtomData;
  CFTypeRef *v42;
  OpaqueCMBlockBuffer *v43;
  uint64_t v44;
  CFTypeRef *v45;
  int v46;
  size_t v47;
  const char *v48;
  int v49;
  CMBlockBufferRef *v50;
  int Atom;
  CFTypeRef *v52;
  int v53;
  uint64_t BBuf;
  int v55;
  size_t v56;
  uint64_t v57;
  CFTypeRef *v58;
  const void **v59;
  const void **v60;
  CFIndex v61;
  size_t v62;
  size_t v63;
  int *v64;
  _DWORD *v65;
  int v66;
  CFStringRef v67;
  uint64_t v68;
  int *v69;
  size_t v70;
  int v71;
  CFIndex v72;
  size_t v73;
  _DWORD *v74;
  CFArrayRef v75;
  CFDictionaryRef v76;
  CFDictionaryRef v77;
  CFTypeRef *v78;
  uint64_t v79;
  CFTypeRef *v80;
  uint64_t v81;
  CFTypeRef *v82;
  int v83;
  int v84;
  OpaqueCMBlockBuffer *v85;
  char *v86;
  char *v87;
  size_t v88;
  int v89;
  OpaqueCMBlockBuffer *v90;
  int v91;
  unsigned int v92;
  unsigned int v93;
  char *v94;
  const void *v95;
  uint64_t v96;
  const char *v97;
  uint64_t MagicCookieBBufFromAMRBBuf;
  int v99;
  unsigned int v100;
  int v101;
  uint64_t DataPointer;
  int v103;
  uint64_t Property;
  const void *v105;
  uint64_t v106;
  const char *v107;
  int v108;
  AudioChannelLayout *v109;
  _DWORD *v110;
  const __CFDictionary *v111;
  uint64_t v113;
  char *v114;
  AudioFormatID v115;
  UInt32 v116;
  uint64_t v117;
  size_t v118;
  size_t v119;
  unint64_t v120;
  uint64_t v121;
  uint64_t PropertyInfo;
  int8x8_t v123;
  unsigned int mNumberChannelDescriptions;
  uint64_t v125;
  uint64_t v126;
  AudioChannelLayout *mCoordinates;
  uint64_t v128;
  uint64_t v129;
  const __CFAllocator *v130;
  uint64_t v131;
  unsigned int v132;
  char *v133;
  __int128 v134;
  __int128 v135;
  const __CFAllocator *v136;
  size_t v137;
  OpaqueCMBlockBuffer *v138;
  size_t v139;
  __CFString **v140;
  __CFString *v141;
  CFIndex v142;
  CFIndex v143;
  int OriginalFormatFromSinf;
  char *v145;
  size_t v146;
  UInt32 mChannelLayoutTag_low;
  AudioChannelBitmap mChannelBitmap;
  BOOL v149;
  int v150;
  unsigned int v151;
  unsigned int v152;
  int v153;
  const AudioChannelLayout *p_layout;
  int v155;
  __int128 v156;
  __int128 v157;
  int v158;
  int v159;
  int v160;
  const char *v161;
  uint64_t v162;
  int v163;
  char *v164;
  unsigned int v165;
  char *v166;
  uint64_t v167;
  OpaqueCMBlockBuffer *theBuffer;
  OpaqueCMBlockBuffer *theBuffera;
  const __CFAllocator *v170;
  const __CFAllocator *v171;
  CMAudioFormatDescriptionRef *v172;
  CFTypeRef *v173;
  BOOL v174;
  CFTypeRef *v175;
  unsigned int v176;
  const void **v177;
  __CFData *cf;
  const __CFAllocator *allocator;
  CFAllocatorRef allocatora;
  unsigned int v181;
  void *v182;
  CMAudioFormatDescriptionRef formatDescriptionOut;
  int v184;
  AudioStreamBasicDescription asbd;
  __int128 v186;
  AudioChannelLayout layout;
  _OWORD v188[2];
  __int128 v189;
  uint64_t v190;
  unsigned int v191;
  unint64_t v192[6];
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  _QWORD v209[15];
  int v210;
  unsigned __int16 v211;
  char *v212[4];
  uint64_t v213;
  size_t lengthAtOffsetOut;
  char *v215;
  CMBlockBufferRef blockBufferOut;
  size_t size;
  _OWORD destination[2];
  __int128 v219;
  __int128 v220;
  __int128 v221;
  __int128 v222;
  __int128 v223;
  CFTypeRef dataPointerOut[2];
  __int128 v225;
  __int128 v226;
  __int128 v227;
  uint64_t v228;

  v7 = cf1;
  v228 = *MEMORY[0x1E0C80C00];
  v10 = 0uLL;
  v208 = 0u;
  memset(v209, 0, 112);
  v206 = 0u;
  v207 = 0u;
  v204 = 0u;
  v205 = 0u;
  v202 = 0u;
  v203 = 0u;
  v200 = 0u;
  v201 = 0u;
  v198 = 0u;
  v199 = 0u;
  v196 = 0u;
  v197 = 0u;
  v194 = 0u;
  v195 = 0u;
  v193 = 0u;
  memset(v192, 0, sizeof(v192));
  v191 = 0;
  v190 = 0;
  v189 = 0u;
  memset(v188, 0, sizeof(v188));
  memset(&layout, 0, sizeof(layout));
  v186 = 0uLL;
  v182 = 0;
  formatDescriptionOut = 0;
  v181 = 0;
  if (cf1)
  {
    if (CFEqual(cf1, CFSTR("ISOFamily")))
    {
      LODWORD(v7) = 1;
LABEL_8:
      v10 = 0uLL;
      LODWORD(v192[0]) = (_DWORD)v7;
      goto LABEL_9;
    }
    if (CFEqual(v7, CFSTR("QuickTimeMovieV2")))
    {
      LODWORD(v7) = 4;
      goto LABEL_8;
    }
    if (CFEqual(v7, CFSTR("3GPFamily")))
    {
      LODWORD(v7) = 3;
      goto LABEL_8;
    }
    LOBYTE(v7) = 0;
    v10 = 0uLL;
  }
LABEL_9:
  *(_QWORD *)&asbd.mBitsPerChannel = 0;
  *(_OWORD *)&asbd.mSampleRate = v10;
  *(_OWORD *)&asbd.mBytesPerPacket = v10;
  v184 = 0;
  LOWORD(destination[0]) = -1;
  v11 = CMBlockBufferCopyDataBytes(theSourceBuffer, 0x10uLL, 2uLL, destination);
  if ((_DWORD)v11)
  {
LABEL_739:
    Empty = v11;
    goto LABEL_504;
  }
  v12 = bswap32(LOWORD(destination[0]));
  v13 = v12 >> 16;
  LOWORD(destination[0]) = HIWORD(v12);
  if ((v7 & 1) != 0 && v13 > 1)
  {
    v14 = "Version >= 2 in ISO sound description";
    goto LABEL_13;
  }
  switch(v13)
  {
    case 0:
      v18 = 1;
      v15 = 36;
      goto LABEL_32;
    case 2:
      v18 = 4;
      v15 = 72;
      goto LABEL_32;
    case 1:
      IsBlockBufferISOv1 = figSoundBridge_IsBlockBufferISOv1(theSourceBuffer, 1);
      if ((v7 & 1) == 0 && IsBlockBufferISOv1)
      {
        v14 = "ISO V1 in movie file";
        goto LABEL_13;
      }
      if (IsBlockBufferISOv1)
        v15 = 36;
      else
        v15 = 52;
      if (IsBlockBufferISOv1)
        v18 = 2;
      else
        v18 = 3;
      LOWORD(v13) = destination[0];
LABEL_32:
      LOWORD(v192[1]) = v13;
      HIDWORD(v192[1]) = v18;
      v192[2] = v15;
      goto LABEL_33;
  }
  v14 = "Version >= 3 in sound description";
LABEL_13:
  figSoundBridge_ReportParsingFailureMessage(a5, (uint64_t)v14);
  v11 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)v11)
    goto LABEL_739;
  v15 = v192[2];
  if (v192[2] >= 0x49)
  {
    v16 = "Offset to extension atoms is out of bounds";
    goto LABEL_39;
  }
LABEL_33:
  v11 = CMBlockBufferCopyDataBytes(theSourceBuffer, 0, v15, &v192[3]);
  if ((_DWORD)v11)
    goto LABEL_739;
  if (SLOWORD(v192[1]) >= 2)
  {
    v19 = bswap32(HIDWORD(v193));
    if ((uint64_t)v192[2] >= v19)
    {
      if ((uint64_t)v192[2] > v19)
      {
        v16 = "Sound description V2 size is less than expected";
        goto LABEL_39;
      }
    }
    else
    {
      v192[2] = v19;
    }
  }
  HIDWORD(v192[0]) = bswap32(HIDWORD(v192[3]));
  *(_QWORD *)&v208 = a5;
  if (LODWORD(v192[3]))
    goto LABEL_44;
  DataLength = CMBlockBufferGetDataLength(theSourceBuffer);
  if (!HIDWORD(DataLength))
  {
    LODWORD(v192[3]) = bswap32(DataLength);
    goto LABEL_44;
  }
  v16 = "Sound description V0 size is out of bounds";
LABEL_39:
  figSoundBridge_ReportParsingFailureMessage(v208, (uint64_t)v16);
  v11 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)v11)
    goto LABEL_739;
LABEL_44:
  v172 = a4;
  CFPreferenceNumberWithDefault = figSoundBridge_AllowZeroSizeTerminatorAtom_value;
  if (figSoundBridge_AllowZeroSizeTerminatorAtom_value == -1)
  {
    CFPreferenceNumberWithDefault = FigGetCFPreferenceNumberWithDefault(CFSTR("zero_size_terminator_atom"), CFSTR("com.apple.coremedia"), 1);
    figSoundBridge_AllowZeroSizeTerminatorAtom_value = CFPreferenceNumberWithDefault;
  }
  v22 = CFPreferenceNumberWithDefault != 0;
  if (!(LOWORD(v192[1]) | v192[0] & 1))
    goto LABEL_276;
  v23 = CMBlockBufferGetDataLength(theSourceBuffer);
  if (v23 < (uint64_t)v192[2])
  {
    v161 = "Offset to extension atoms is greater than length of sound description";
    v162 = a5;
LABEL_738:
    figSoundBridge_ReportParsingFailureMessage(v162, (uint64_t)v161);
    v11 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_739;
  }
  if (v23 == v192[2])
    goto LABEL_276;
  v11 = FigAtomStreamInitWithBBuf(theSourceBuffer, v192[2], v22, (uint64_t)v209);
  if ((_DWORD)v11)
    goto LABEL_739;
  theBuffer = theSourceBuffer;
  v170 = a1;
  v167 = a5;
  if (LOWORD(v192[1]))
  {
    if ((v192[0] & 1) == 0)
    {
      v174 = (HIDWORD(v192[1]) - 1) < 2;
      LOBYTE(v165) = 1;
LABEL_56:
      allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      LODWORD(lengthAtOffsetOut) = 0;
      size = 0;
      v210 = 0;
      CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v209, &lengthAtOffsetOut, &size);
      if ((_DWORD)CurrentAtomTypeAndDataLength)
      {
        Empty = CurrentAtomTypeAndDataLength;
        v25 = 0;
        cf = 0;
        v26 = 0;
        goto LABEL_218;
      }
      v26 = 0;
      v176 = 0;
      v25 = 0;
      v28 = v165;
      while (1)
      {
        v29 = size;
        if ((size & 0x8000000000000000) != 0)
        {
          figSoundBridge_ReportParsingFailureMessage(v208, (uint64_t)"Sound description extension data has incorrect length");
          ESDSAtomAndData = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_717:
          Empty = ESDSAtomAndData;
          goto LABEL_217;
        }
        v30 = lengthAtOffsetOut;
        if ((_DWORD)lengthAtOffsetOut)
          break;
LABEL_172:
        Atom = FigAtomStreamAdvanceToNextAtom(v209);
        if (Atom)
        {
          if (Atom != -12890)
            figSoundBridge_ReportParsingFailureMessage(v208, (uint64_t)"Sound description has extra bytes that can't be parsed as an extension");
          Empty = 0;
LABEL_217:
          cf = 0;
          goto LABEL_218;
        }
        LODWORD(lengthAtOffsetOut) = 0;
        size = 0;
        v210 = 0;
        ESDSAtomAndData = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v209, &lengthAtOffsetOut, &size);
        if ((_DWORD)ESDSAtomAndData)
          goto LABEL_717;
      }
      if ((_DWORD)lengthAtOffsetOut == 1936289382)
      {
        if ((_QWORD)v202)
        {
LABEL_62:
          if (v25 == v176)
          {
            v31 = (CFTypeRef *)malloc_type_realloc(v26, 24 * (int)(v176 + 16), 0x1060040D0FAAE32uLL);
            if (!v31)
            {
              Empty = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              cf = 0;
              v26 = 0;
              v25 = v176;
              goto LABEL_218;
            }
            v176 += 16;
            v26 = v31;
          }
          Mutable = CFDataCreateMutable(allocator, 0);
          v33 = Mutable;
          cf = Mutable;
          if ((_DWORD)lengthAtOffsetOut == 1970628964)
          {
            CFDataSetLength(Mutable, v29 + 16);
            BytePtr = (UInt8 *)CFDataGetBytePtr(v33);
            CurrentAtomUUIDType = FigAtomStreamGetCurrentAtomUUIDType((uint64_t)v209, BytePtr);
            if ((_DWORD)CurrentAtomUUIDType)
            {
              Empty = CurrentAtomUUIDType;
              goto LABEL_218;
            }
            v36 = BytePtr + 16;
          }
          else
          {
            CFDataSetLength(Mutable, v29);
            v36 = CFDataGetBytePtr(v33);
          }
          CurrentAtomData = FigAtomStreamReadCurrentAtomData((uint64_t)v209, 0, v29, (uint64_t)v36);
          if ((_DWORD)CurrentAtomData)
          {
            Empty = CurrentAtomData;
            goto LABEL_218;
          }
          if (cf)
          {
            v42 = &v26[3 * (int)v25];
            *(_DWORD *)v42 = lengthAtOffsetOut;
            v42[1] = cf;
            *((_DWORD *)v42 + 4) = 0;
            ++v25;
          }
          goto LABEL_172;
        }
        v39 = (CMBlockBufferRef *)&v202;
        goto LABEL_80;
      }
      if ((v28 & 1) != 0)
      {
        if (v174)
        {
          v37 = 1;
LABEL_83:
          if (v30 > 1684425824)
          {
            if (v30 <= 1885564226)
            {
              if (v30 == 1684425825 || v30 == 1702061171)
                goto LABEL_172;
              v40 = 1718773093;
            }
            else if (v30 > 1936875891)
            {
              if (v30 == 1936875892)
                goto LABEL_172;
              v40 = 2002876005;
            }
            else
            {
              if (v30 == 1885564227)
                goto LABEL_172;
              v40 = 1935764850;
            }
          }
          else if (v30 <= 1667785069)
          {
            if (!v30 || v30 == 1633972845)
              goto LABEL_172;
            v40 = 1634492771;
          }
          else if (v30 > 1684106609)
          {
            if (v30 == 1684106610)
              goto LABEL_172;
            v40 = 1684366131;
          }
          else
          {
            if (v30 == 1667785070)
              goto LABEL_172;
            v40 = 1684103987;
          }
          if (v30 == v40 || !v37)
            goto LABEL_172;
          goto LABEL_62;
        }
        if ((_DWORD)lengthAtOffsetOut != 1667785070)
        {
          if ((_DWORD)lengthAtOffsetOut != 2002876005)
          {
            if (figSoundBridge_GetDecodeFormatIDForUnknownExtensionType(lengthAtOffsetOut, (uint64_t)v192, &v210))
            {
              v52 = v26;
              v53 = v210;
              LODWORD(v204) = v210;
              if (!*((_QWORD *)&v203 + 1))
              {
                BBuf = FigAtomStreamReadCurrentAtomAndCreateBBuf((uint64_t)v209, (CMBlockBufferRef *)&v203 + 1);
                if ((_DWORD)BBuf)
                  goto LABEL_760;
              }
              BBuf = figSoundBridge_TransformToCanonicalMagicCookieBBuf(v170, v53, (uint64_t)v192, (CMBlockBufferRef *)&v203 + 1);
              if ((_DWORD)BBuf)
                goto LABEL_760;
              v37 = 0;
              v26 = v52;
              v28 = v165;
              goto LABEL_82;
            }
            goto LABEL_81;
          }
          v43 = (OpaqueCMBlockBuffer *)*((_QWORD *)&v201 + 1);
          if (*((_QWORD *)&v201 + 1))
            goto LABEL_108;
          v44 = FigAtomStreamReadCurrentAtomDataAndCreateBBuf((uint64_t)v209, 0, 0, (CMBlockBufferRef *)&v201 + 1);
          if ((_DWORD)v44)
          {
            Empty = v44;
            if ((_DWORD)v44 != -12891)
              goto LABEL_217;
          }
          v43 = (OpaqueCMBlockBuffer *)*((_QWORD *)&v201 + 1);
          if (*((_QWORD *)&v201 + 1))
          {
LABEL_108:
            v45 = v26;
            v222 = 0u;
            v223 = 0u;
            v220 = 0u;
            v221 = 0u;
            v219 = 0u;
            memset(destination, 0, sizeof(destination));
            v46 = figSoundBridge_AllowZeroSizeTerminatorAtom_value;
            if (figSoundBridge_AllowZeroSizeTerminatorAtom_value == -1)
            {
              v46 = FigGetCFPreferenceNumberWithDefault(CFSTR("zero_size_terminator_atom"), CFSTR("com.apple.coremedia"), 1);
              figSoundBridge_AllowZeroSizeTerminatorAtom_value = v46;
              v43 = (OpaqueCMBlockBuffer *)*((_QWORD *)&v201 + 1);
            }
            if (FigAtomStreamInitWithBBuf(v43, 0, v46 != 0, (uint64_t)destination))
            {
LABEL_160:
              v37 = 1;
              v26 = v45;
              goto LABEL_82;
            }
            while (1)
            {
              LODWORD(blockBufferOut) = 0;
              dataPointerOut[0] = 0;
              v211 = 0;
              if (FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)destination, &blockBufferOut, dataPointerOut))goto LABEL_160;
              if ((int)blockBufferOut <= 1684425824)
              {
                if ((int)blockBufferOut > 1684103986)
                {
                  if ((_DWORD)blockBufferOut == 1684103987)
                  {
                    if (!*((_QWORD *)&v197 + 1))
                    {
                      v50 = (CMBlockBufferRef *)&v197 + 1;
                      goto LABEL_151;
                    }
                  }
                  else if ((_DWORD)blockBufferOut == 1684366131 && !(_QWORD)v198)
                  {
                    v50 = (CMBlockBufferRef *)&v198;
                    goto LABEL_151;
                  }
                }
                else
                {
                  switch((_DWORD)blockBufferOut)
                  {
                    case 0x6164726D:
                      if (!(_QWORD)v200)
                      {
                        v50 = (CMBlockBufferRef *)&v200;
LABEL_151:
                        if (FigAtomStreamReadCurrentAtomAndCreateBBuf((uint64_t)destination, v50))
                          goto LABEL_160;
                      }
                      break;
                    case 0x616C6163:
                      if (!*((_QWORD *)&v198 + 1))
                      {
                        v50 = (CMBlockBufferRef *)&v198 + 1;
                        goto LABEL_151;
                      }
                      break;
                    case 0:
                      goto LABEL_160;
                    default:
                      break;
                  }
                }
              }
              else
              {
                if ((int)blockBufferOut > 1702061170)
                {
                  if ((_DWORD)blockBufferOut == 1702061171)
                  {
                    if (ReadESDSAtomAndData((uint64_t)destination, (CMBlockBufferRef *)&v196 + 1, (CMBlockBufferRef *)&v197))goto LABEL_160;
                    goto LABEL_159;
                  }
                  if ((_DWORD)blockBufferOut == 1935764850)
                  {
                    if (!*((_QWORD *)&v199 + 1)
                      && FigAtomStreamReadCurrentAtomDataAndCreateBBuf((uint64_t)destination, 0, 0, (CMBlockBufferRef *)&v199 + 1))
                    {
                      goto LABEL_160;
                    }
                    goto LABEL_159;
                  }
                  if ((_DWORD)blockBufferOut != 1718775137)
                    goto LABEL_159;
                  v212[0] = 0;
                  if (FigAtomStreamReadCurrentAtomDataAndCreateBBuf((uint64_t)destination, 0, 0, (CMBlockBufferRef *)v212))goto LABEL_160;
                  if (!v212[0])
                    goto LABEL_159;
                  v47 = CMBlockBufferGetDataLength((CMBlockBufferRef)v212[0]);
                  LODWORD(v215) = 0;
                  v48 = "'wave' atom has 'frma' atom that is too short to contain a format type";
                  if (v47 < 4)
                    goto LABEL_153;
                  v49 = 0;
                  if (HIDWORD(v192[0]) != 1633777252
                    && HIDWORD(v192[0]) != 1685220723
                    && HIDWORD(v192[0]) != 1701733217)
                  {
                    CMBlockBufferCopyDataBytes((CMBlockBufferRef)v212[0], 0, 4uLL, &v215);
                    LODWORD(v215) = bswap32(v215);
                    v48 = "'wave' atom has wrong 'frma' format type";
                    if ((_DWORD)v215 == HIDWORD(v192[0]))
                    {
                      v49 = 0;
                      goto LABEL_154;
                    }
LABEL_153:
                    figSoundBridge_ReportParsingFailureMessage(v208, (uint64_t)v48);
                    v49 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
                  }
LABEL_154:
                  if (v212[0])
                    CFRelease(v212[0]);
                  if (v49)
                    goto LABEL_160;
                  goto LABEL_159;
                }
                if ((_DWORD)blockBufferOut == 1684425825)
                {
                  if (!(_QWORD)v199)
                  {
                    v50 = (CMBlockBufferRef *)&v199;
                    goto LABEL_151;
                  }
                }
                else if ((_DWORD)blockBufferOut == 1701733473)
                {
                  if (!*((_QWORD *)&v202 + 1)
                    && FigAtomStreamReadCurrentAtomAndCreateBBuf((uint64_t)destination, (CMBlockBufferRef *)&v202 + 1)|| FigAtomStreamReadCurrentAtomData((uint64_t)destination, 0, 2, (uint64_t)&v211))
                  {
                    goto LABEL_160;
                  }
                  v211 = bswap32(v211) >> 16;
                  LOBYTE(v205) = (_BYTE)v211 != 0;
                }
              }
LABEL_159:
              if (FigAtomStreamAdvanceToNextAtom(destination))
                goto LABEL_160;
            }
          }
LABEL_81:
          v37 = 1;
LABEL_82:
          v30 = lengthAtOffsetOut;
          goto LABEL_83;
        }
        if (*((_QWORD *)&v200 + 1))
          goto LABEL_81;
        v39 = (CMBlockBufferRef *)&v200 + 1;
LABEL_80:
        ESDSAtomAndData = FigAtomStreamReadCurrentAtomAndCreateBBuf((uint64_t)v209, v39);
        if ((_DWORD)ESDSAtomAndData)
          goto LABEL_717;
        goto LABEL_81;
      }
      if ((int)lengthAtOffsetOut > 1684366130)
      {
        if ((int)lengthAtOffsetOut <= 1702061170)
        {
          if ((_DWORD)lengthAtOffsetOut == 1684366131)
          {
            if ((_QWORD)v198)
              goto LABEL_81;
            v39 = (CMBlockBufferRef *)&v198;
            goto LABEL_80;
          }
          if ((_DWORD)lengthAtOffsetOut == 1684425825)
          {
            if ((_QWORD)v199)
              goto LABEL_81;
            v39 = (CMBlockBufferRef *)&v199;
            goto LABEL_80;
          }
        }
        else
        {
          switch((_DWORD)lengthAtOffsetOut)
          {
            case 0x65736473:
              ESDSAtomAndData = ReadESDSAtomAndData((uint64_t)v209, (CMBlockBufferRef *)&v196 + 1, (CMBlockBufferRef *)&v197);
              if ((_DWORD)ESDSAtomAndData)
                goto LABEL_717;
              goto LABEL_81;
            case 0x73726174:
              if (HIDWORD(v192[1]) == 2)
              {
                LODWORD(destination[0]) = 0;
                if (!(_QWORD)v203)
                {
                  ESDSAtomAndData = FigAtomStreamReadCurrentAtomAndCreateBBuf((uint64_t)v209, (CMBlockBufferRef *)&v203);
                  if ((_DWORD)ESDSAtomAndData)
                    goto LABEL_717;
                }
                if (FigAtomStreamReadCurrentAtomData((uint64_t)v209, 4, 4, (uint64_t)destination))
                {
                  if ((_QWORD)v203)
                  {
                    CFRelease((CFTypeRef)v203);
                    *(_QWORD *)&v203 = 0;
                  }
                }
                else
                {
                  *((double *)&v205 + 1) = (double)bswap32(destination[0]);
                }
              }
              goto LABEL_81;
            case 0x70636D43:
              if ((_QWORD)v196)
                goto LABEL_81;
              v39 = (CMBlockBufferRef *)&v196;
              goto LABEL_80;
          }
        }
      }
      else if ((int)lengthAtOffsetOut <= 1667788395)
      {
        if ((_DWORD)lengthAtOffsetOut == 1633972845)
        {
          if ((_QWORD)v200)
            goto LABEL_81;
          v39 = (CMBlockBufferRef *)&v200;
          goto LABEL_80;
        }
        if ((_DWORD)lengthAtOffsetOut == 1634492771)
        {
          if (*((_QWORD *)&v198 + 1))
            goto LABEL_81;
          v39 = (CMBlockBufferRef *)&v198 + 1;
          goto LABEL_80;
        }
      }
      else
      {
        switch((_DWORD)lengthAtOffsetOut)
        {
          case 0x63686E6C:
            if ((_QWORD)v201)
              goto LABEL_81;
            v39 = (CMBlockBufferRef *)&v201;
            goto LABEL_80;
          case 0x64616333:
            if (*((_QWORD *)&v197 + 1))
              goto LABEL_81;
            v39 = (CMBlockBufferRef *)&v197 + 1;
            goto LABEL_80;
          case 0x64616D72:
            if (!*((_QWORD *)&v199 + 1))
            {
              ESDSAtomAndData = FigAtomStreamReadCurrentAtomDataAndCreateBBuf((uint64_t)v209, 0, 0, (CMBlockBufferRef *)&v199 + 1);
              if ((_DWORD)ESDSAtomAndData)
                goto LABEL_717;
            }
            goto LABEL_81;
        }
      }
      if (figSoundBridge_GetDecodeFormatIDForUnknownExtensionType(lengthAtOffsetOut, (uint64_t)v192, &v210))
      {
        v52 = v26;
        v55 = v210;
        LODWORD(v204) = v210;
        if (!*((_QWORD *)&v203 + 1)
          && (BBuf = FigAtomStreamReadCurrentAtomAndCreateBBuf((uint64_t)v209, (CMBlockBufferRef *)&v203 + 1),
              (_DWORD)BBuf)
          || (BBuf = figSoundBridge_TransformToCanonicalMagicCookieBBuf(v170, v55, (uint64_t)v192, (CMBlockBufferRef *)&v203 + 1), (_DWORD)BBuf))
        {
LABEL_760:
          Empty = BBuf;
          cf = 0;
          v26 = v52;
          goto LABEL_218;
        }
        v37 = 0;
        v26 = v52;
        goto LABEL_82;
      }
      goto LABEL_81;
    }
LABEL_55:
    v165 = (HIDWORD(v192[1]) > 3) | (9u >> (BYTE4(v192[1]) & 0xF));
    v174 = HIDWORD(v192[1]) != 3;
    goto LABEL_56;
  }
  if ((v192[0] & 1) != 0)
    goto LABEL_55;
  Empty = 0;
  v25 = 0;
  v26 = 0;
  cf = 0;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
LABEL_218:
  v56 = (int)v25;
  v164 = (char *)(v26 + 2);
  v166 = (char *)(v26 + 3);
  v57 = v25;
  v173 = v26;
  while (!(_DWORD)Empty || (_DWORD)Empty == -12890)
  {
    if (!v26)
    {
      Empty = 0;
      *((_QWORD *)&v204 + 1) = 0;
      a1 = v170;
      a5 = v167;
      goto LABEL_273;
    }
    v58 = (CFTypeRef *)malloc_type_calloc(v56, 8uLL, 0x6004044C4A2DFuLL);
    v177 = (const void **)malloc_type_calloc(v56, 8uLL, 0x6004044C4A2DFuLL);
    v59 = (const void **)malloc_type_calloc(v56, 8uLL, 0x6004044C4A2DFuLL);
    v60 = v59;
    v175 = v58;
    if (v58 && v177 && v59)
    {
      v61 = 0;
      if ((_DWORD)v56)
      {
        v62 = 0;
        v63 = v56;
        v65 = v164;
        v64 = (int *)v166;
        while (LODWORD(v26[3 * v62 + 2]))
        {
LABEL_243:
          ++v62;
          v64 += 6;
          v65 += 6;
          --v63;
          if (v62 == v56)
            goto LABEL_244;
        }
        v66 = (int)v26[3 * v62];
        LOBYTE(destination[0]) = 4;
        BYTE1(destination[0]) = HIBYTE(v66);
        BYTE2(destination[0]) = BYTE2(v66);
        BYTE3(destination[0]) = BYTE1(v66);
        BYTE4(destination[0]) = v66;
        v67 = CFStringCreateWithPascalString(allocator, (ConstStr255Param)destination, 0);
        v175[v61] = v67;
        if (!v67)
        {
          v68 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          if ((_DWORD)v68)
          {
            Empty = v68;
            v77 = 0;
LABEL_248:
            if ((int)v57 >= 1)
            {
              v78 = v175;
              v79 = v57;
              do
              {
                if (*v78)
                  CFRelease(*v78);
                ++v78;
                --v79;
              }
              while (v79);
            }
            free(v175);
            v26 = v173;
            goto LABEL_254;
          }
        }
        v69 = v64;
        v70 = v62;
        do
        {
          if (++v70 >= v56)
          {
            v26 = v173;
            v177[v61] = CFRetain(v173[3 * v62 + 1]);
LABEL_242:
            ++v61;
            goto LABEL_243;
          }
          v71 = *v69;
          v69 += 6;
        }
        while (v66 != v71);
        if (v62 >= v56)
        {
          v72 = 0;
        }
        else
        {
          v72 = 0;
          v73 = v63;
          v74 = v65;
          do
          {
            if (v66 == *(v74 - 4))
            {
              v60[v72++] = (const void *)*((_QWORD *)v74 - 1);
              *v74 = 1;
            }
            v74 += 6;
            --v73;
          }
          while (v73);
        }
        v75 = CFArrayCreate(allocator, v60, v72, MEMORY[0x1E0C9B378]);
        v177[v61] = v75;
        v26 = v173;
        if (v75)
          goto LABEL_242;
      }
      else
      {
LABEL_244:
        v76 = CFDictionaryCreate(allocator, v175, v177, v61, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (v76)
        {
          v77 = v76;
          Empty = 0;
          goto LABEL_247;
        }
      }
    }
    Empty = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    v77 = 0;
LABEL_247:
    if (v175)
      goto LABEL_248;
LABEL_254:
    if (v177)
    {
      if ((int)v56 >= 1)
      {
        v80 = v177;
        v81 = v57;
        do
        {
          if (*v80)
            CFRelease(*v80);
          ++v80;
          --v81;
        }
        while (v81);
      }
      free(v177);
      v26 = v173;
    }
    if (v60)
      free(v60);
    *((_QWORD *)&v204 + 1) = v77;
    if (!(_DWORD)Empty)
      break;
  }
  a1 = v170;
  a5 = v167;
  if (v26)
  {
    if ((int)v57 >= 1)
    {
      v82 = v26 + 1;
      do
      {
        if (*v82)
          CFRelease(*v82);
        v82 += 3;
        --v57;
      }
      while (v57);
    }
    free(v26);
  }
LABEL_273:
  theSourceBuffer = theBuffer;
  if (cf)
    CFRelease(cf);
  if ((_DWORD)Empty)
    goto LABEL_504;
LABEL_276:
  dataPointerOut[0] = 0;
  v83 = HIDWORD(v192[0]);
  if (SHIDWORD(v192[0]) <= 1718367025)
  {
    if (HIDWORD(v192[0]) != 1633777252 && HIDWORD(v192[0]) != 1685220723 && HIDWORD(v192[0]) != 1701733217)
      goto LABEL_328;
    *(_QWORD *)&destination[0] = 0;
    Empty = CMBlockBufferCreateEmpty(a1, 4u, 0, (CMBlockBufferRef *)destination);
    if ((_DWORD)Empty)
    {
LABEL_302:
      if (*(_QWORD *)&destination[0])
        CFRelease(*(CFTypeRef *)&destination[0]);
      goto LABEL_304;
    }
    if (*((_QWORD *)&v196 + 1))
      CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)&destination[0], *((CMBlockBufferRef *)&v196 + 1), 0, 0, 0);
    if (HIDWORD(v192[0]) == 1633777252)
    {
      v85 = (OpaqueCMBlockBuffer *)v200;
      if (!(_QWORD)v200)
        goto LABEL_299;
    }
    else
    {
      if (HIDWORD(v192[0]) != 1701733217 && HIDWORD(v192[0]) != 1685220723)
        goto LABEL_299;
      if (*((_QWORD *)&v197 + 1))
        CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)&destination[0], *((CMBlockBufferRef *)&v197 + 1), 0, 0, 0);
      if ((_QWORD)v198)
        CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)&destination[0], (CMBlockBufferRef)v198, 0, 0, 0);
      if ((_QWORD)v199)
        CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)&destination[0], (CMBlockBufferRef)v199, 0, 0, 0);
      if (*((_QWORD *)&v198 + 1))
        CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)&destination[0], *((CMBlockBufferRef *)&v198 + 1), 0, 0, 0);
      v85 = (OpaqueCMBlockBuffer *)*((_QWORD *)&v203 + 1);
      if (!*((_QWORD *)&v203 + 1))
        goto LABEL_299;
    }
    CMBlockBufferAppendBufferReference(*(CMBlockBufferRef *)&destination[0], v85, 0, 0, 0);
LABEL_299:
    v86 = *(char **)&destination[0];
    if (*(_QWORD *)&destination[0])
      v86 = (char *)CFRetain(*(CFTypeRef *)&destination[0]);
    dataPointerOut[0] = v86;
    goto LABEL_302;
  }
  if (SHIDWORD(v192[0]) <= 1768829491)
  {
    if (HIDWORD(v192[0]) != 1718367026)
    {
      v84 = 1718367796;
      goto LABEL_312;
    }
    goto LABEL_313;
  }
  if (HIDWORD(v192[0]) != 1768829492)
  {
    v84 = 1768829746;
LABEL_312:
    if (HIDWORD(v192[0]) != v84)
    {
LABEL_328:
      if ((v192[0] & 1) == 0)
      {
        if (HIDWORD(v192[0]) == 1832149349
          || HIDWORD(v192[0]) == 1836069985
          || figSoundBridge_isAACUsingESDSinMOV(HIDWORD(v192[0])))
        {
LABEL_332:
          v95 = (const void *)v197;
          if ((_QWORD)v197)
          {
LABEL_333:
            v87 = (char *)CFRetain(v95);
LABEL_665:
            Empty = 0;
            dataPointerOut[0] = v87;
            goto LABEL_305;
          }
LABEL_664:
          v87 = 0;
          goto LABEL_665;
        }
        v105 = (const void *)*((_QWORD *)&v203 + 1);
        if (!*((_QWORD *)&v203 + 1))
        {
          v105 = (const void *)*((_QWORD *)&v201 + 1);
          if (!*((_QWORD *)&v201 + 1))
            goto LABEL_434;
        }
LABEL_669:
        v87 = (char *)CFRetain(v105);
        Empty = 0;
        dataPointerOut[0] = v87;
        goto LABEL_305;
      }
      if (SHIDWORD(v192[0]) > 1718641516)
      {
        if (SHIDWORD(v192[0]) > 1935764849)
        {
          if (HIDWORD(v192[0]) == 1935764850 || HIDWORD(v192[0]) == 1935767394)
          {
            if (!*((_QWORD *)&v199 + 1))
            {
              v106 = v208;
              v107 = "Required 'damr' extension missing";
              goto LABEL_754;
            }
            MagicCookieBBufFromAMRBBuf = figSoundBridge_CreateMagicCookieBBufFromAMRBBuf(a1, HIDWORD(v192[0]), *((OpaqueCMBlockBuffer **)&v199 + 1), dataPointerOut);
            goto LABEL_474;
          }
        }
        else if (HIDWORD(v192[0]) == 1718641517 || HIDWORD(v192[0]) == 1768973165)
        {
          if (!(_QWORD)v196)
          {
            v106 = v208;
            v107 = "Required 'pcmC' extension missing";
            goto LABEL_754;
          }
LABEL_434:
          Empty = 0;
LABEL_304:
          v87 = (char *)dataPointerOut[0];
LABEL_305:
          if (!v87)
            goto LABEL_341;
          v88 = CMBlockBufferGetDataLength((CMBlockBufferRef)v87);
          if (!HIDWORD(v88))
          {
            v89 = v88;
            if (CMBlockBufferIsRangeContiguous((CMBlockBufferRef)v87, 0, v88))
            {
              v90 = (OpaqueCMBlockBuffer *)CFRetain(v87);
              *((_QWORD *)&v206 + 1) = v90;
              if (!v90)
              {
LABEL_341:
                if (dataPointerOut[0])
                  CFRelease(dataPointerOut[0]);
                if (!(_DWORD)Empty)
                {
                  v83 = HIDWORD(v192[0]);
                  goto LABEL_313;
                }
                goto LABEL_504;
              }
            }
            else
            {
              CMBlockBufferCreateContiguous(a1, (CMBlockBufferRef)v87, a1, 0, 0, 0, 0, (CMBlockBufferRef *)&v206 + 1);
              v90 = (OpaqueCMBlockBuffer *)*((_QWORD *)&v206 + 1);
              if (!*((_QWORD *)&v206 + 1))
                goto LABEL_341;
            }
            CMBlockBufferGetDataPointer(v90, 0, 0, 0, (char **)&v207);
            DWORD2(v207) = v89;
            goto LABEL_341;
          }
          v106 = v208;
          v107 = "Magic cookie size is greater than UINT32_MAX";
LABEL_754:
          figSoundBridge_ReportParsingFailureMessage(v106, (uint64_t)v107);
          Empty = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
          goto LABEL_341;
        }
      }
      else if (SHIDWORD(v192[0]) > 1700998450)
      {
        if (HIDWORD(v192[0]) == 1700998451)
        {
          v105 = (const void *)v198;
          if (!(_QWORD)v198)
          {
            v106 = v208;
            v107 = "Required 'dec3' extension missing";
            goto LABEL_754;
          }
          goto LABEL_669;
        }
        if (HIDWORD(v192[0]) == 1716281667)
        {
          v105 = (const void *)v199;
          if (!(_QWORD)v199)
          {
            v106 = v208;
            v107 = "Required 'dfLa' extension missing";
            goto LABEL_754;
          }
          goto LABEL_669;
        }
      }
      else
      {
        if (HIDWORD(v192[0]) == 1633889587)
        {
          v95 = (const void *)*((_QWORD *)&v197 + 1);
          if (*((_QWORD *)&v197 + 1))
            goto LABEL_333;
          goto LABEL_664;
        }
        if (HIDWORD(v192[0]) == 1634492771)
        {
          if (!*((_QWORD *)&v198 + 1))
          {
            v106 = v208;
            v107 = "Required 'alac' extension missing";
            goto LABEL_754;
          }
          MagicCookieBBufFromAMRBBuf = figSoundBridge_CreateMagicCookieBBufFromALACBBuf(a1, *((OpaqueCMBlockBuffer **)&v198 + 1), dataPointerOut);
LABEL_474:
          Empty = MagicCookieBBufFromAMRBBuf;
          goto LABEL_304;
        }
      }
      v105 = (const void *)*((_QWORD *)&v203 + 1);
      if (!*((_QWORD *)&v203 + 1))
        goto LABEL_332;
      goto LABEL_669;
    }
  }
LABEL_313:
  v213 = 0;
  memset(v212, 0, sizeof(v212));
  if (SLOWORD(v192[1]) > 1)
  {
    if (LOWORD(v192[1]) == 2)
    {
      v212[0] = (char *)bswap64(v194);
      v92 = bswap32(DWORD2(v194));
      LODWORD(v212[1]) = v83;
      HIDWORD(v212[3]) = v92;
      LODWORD(v213) = bswap32(v195);
      v93 = bswap32(DWORD1(v195));
      if (v83 == 1819304813)
      {
        if ((v93 & 8) != 0)
          v93 &= ~0x10u;
        if ((v93 & 1) != 0)
          v93 &= 0xFFFFFFBB;
        v93 &= ~0x40u;
      }
      HIDWORD(v212[1]) = v93;
      v94 = (char *)vrev32_s8(*(int8x8_t *)((char *)&v195 + 8));
      v212[2] = v94;
      if (v83 != 1819304813)
        goto LABEL_391;
      Empty = 0;
      LODWORD(v212[3]) = (_DWORD)v94;
      goto LABEL_503;
    }
    v96 = v208;
    v97 = "This sound description cannot be parsed";
    goto LABEL_461;
  }
  if (v83 > 1768829745)
  {
    if (v83 <= 1918990111)
    {
      if (v83 == 1768829746)
        goto LABEL_358;
      v91 = 1819304813;
    }
    else
    {
      if (v83 == 1918990112 || v83 == 1953984371)
        goto LABEL_358;
      v91 = 1936684916;
    }
LABEL_357:
    if (v83 == v91)
      goto LABEL_358;
    *(double *)v212 = (double)bswap32(DWORD2(v193)) * 0.0000152587891;
    v92 = (int)bswap32((unsigned __int16)v193) >> 16;
    LODWORD(v212[1]) = v83;
    HIDWORD(v212[3]) = v92;
    if (HIDWORD(v192[1]) == 3)
    {
      v93 = HIDWORD(v193);
      if (!HIDWORD(v193))
        goto LABEL_389;
      HIDWORD(v212[2]) = bswap32(HIDWORD(v193));
      if (SWORD2(v193) != -257)
      {
        v93 = 0;
        LODWORD(v212[2]) = bswap32(DWORD1(v194));
        goto LABEL_389;
      }
    }
    v93 = 0;
    goto LABEL_389;
  }
  if (v83 <= 1718367025)
  {
    if (!v83)
      goto LABEL_358;
    v91 = 1313820229;
    goto LABEL_357;
  }
  if (v83 != 1718367026 && v83 != 1718367796)
  {
    v91 = 1768829492;
    goto LABEL_357;
  }
LABEL_358:
  v212[1] = (char *)0x86C70636DLL;
  if (v83 <= 1718367025)
  {
    if (v83)
    {
      v99 = 1313820229;
LABEL_364:
      if (v83 != v99)
        goto LABEL_367;
    }
    if (WORD1(v193) != 2048)
    {
LABEL_367:
      v93 = 12;
      goto LABEL_368;
    }
    v93 = 8;
  }
  else
  {
    v93 = 9;
    if (v83 != 1718367026 && v83 != 1718367796)
    {
      v99 = 1918990112;
      goto LABEL_364;
    }
LABEL_368:
    HIDWORD(v212[1]) = v93;
  }
  if (v83 <= 1768829491)
  {
    if (v83 != 1718367026 && v83 != 1718367796)
      goto LABEL_378;
    goto LABEL_376;
  }
  if (v83 == 1768829492 || v83 == 1768829746)
  {
LABEL_376:
    if (!*((_QWORD *)&v202 + 1) || !(_BYTE)v205)
      goto LABEL_378;
    goto LABEL_379;
  }
  if (v83 == 1936684916)
  {
    v100 = (int)bswap32(WORD1(v193)) >> 16;
    goto LABEL_387;
  }
LABEL_378:
  v93 |= 2u;
  HIDWORD(v212[1]) = v93;
LABEL_379:
  v100 = (int)bswap32(WORD1(v193)) >> 16;
  LODWORD(v213) = v100;
  if (v83 > 1768829491)
  {
    if (v83 == 1768829492)
    {
      v100 = 24;
      goto LABEL_387;
    }
    if (v83 != 1768829746)
      goto LABEL_388;
LABEL_385:
    v100 = 32;
LABEL_387:
    LODWORD(v213) = v100;
    goto LABEL_388;
  }
  if (v83 == 1718367026)
    goto LABEL_385;
  if (v83 == 1718367796)
  {
    v100 = 64;
    goto LABEL_387;
  }
LABEL_388:
  *(double *)v212 = (double)bswap32(DWORD2(v193)) * 0.0000152587891;
  v92 = (int)bswap32((unsigned __int16)v193) >> 16;
  LODWORD(v212[2]) = (v100 >> 3) * v92;
  HIDWORD(v212[2]) = 1;
  v212[3] = (char *)__PAIR64__(v92, v212[2]);
  v83 = 1819304813;
LABEL_389:
  if ((_QWORD)v203)
    v212[0] = *((char **)&v205 + 1);
LABEL_391:
  size = 0;
  if (v83 > 1718378850)
  {
    if (v83 <= 1836069984)
    {
      if (v83 <= 1768829745)
      {
        if (v83 == 1718378851)
          goto LABEL_464;
        if (v83 != 1718641517)
        {
          v101 = 1768829492;
          goto LABEL_459;
        }
        HIDWORD(v212[1]) = v93 | 1;
        goto LABEL_496;
      }
      if (v83 <= 1819304812)
      {
        if (v83 == 1768829746)
          goto LABEL_460;
        if (v83 != 1768973165)
          goto LABEL_485;
LABEL_496:
        LODWORD(v212[1]) = 1819304813;
        if (!(_QWORD)v196)
          goto LABEL_502;
        *(_QWORD *)&destination[0] = 0;
        dataPointerOut[0] = 0;
        LODWORD(blockBufferOut) = 40;
        DataPointer = CMBlockBufferGetDataPointer((CMBlockBufferRef)v196, 0, (size_t *)destination, 0, (char **)dataPointerOut);
        if ((_DWORD)DataPointer)
          goto LABEL_463;
        Property = AudioToolbox_AudioFormatGetProperty(1885565796, LODWORD(destination[0]), (uint64_t)dataPointerOut[0], (uint64_t)&blockBufferOut, (uint64_t)v212);
        if (!(_DWORD)Property)
          goto LABEL_502;
LABEL_462:
        DataPointer = FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0);
        goto LABEL_463;
      }
      if (v83 == 1819304813)
        goto LABEL_502;
      if (v83 != 1832149349)
        goto LABEL_485;
LABEL_453:
      if ((_QWORD)v197)
      {
        DataPointer = figSoundBridge_GetMP4ASBDFromESDSDataBBuf((uint64_t)v192, (uint64_t)v212);
        goto LABEL_463;
      }
      Empty = 0;
      LODWORD(v212[1]) = 1633772320;
      goto LABEL_658;
    }
    if (v83 <= 1935767393)
    {
      if (v83 == 1836069985)
        goto LABEL_453;
      if (v83 == 1918990112)
        goto LABEL_460;
      if (v83 != 1935764850)
        goto LABEL_485;
    }
    else
    {
      if (v83 > 1953984370)
      {
        if (v83 == 1986295393)
        {
          if (LOWORD(v192[1]) == 1 && (v192[0] & 1) == 0)
          {
            Empty = 0;
            v212[2] = (char *)bswap32(DWORD1(v194));
            goto LABEL_503;
          }
          goto LABEL_502;
        }
        v101 = 1953984371;
LABEL_459:
        if (v83 != v101)
          goto LABEL_485;
        goto LABEL_460;
      }
      if (v83 != 1935767394)
      {
        v101 = 1936684916;
        goto LABEL_459;
      }
    }
    if (!*((_QWORD *)&v199 + 1))
    {
      v96 = v208;
      v97 = "Expected to get a magic cookie for AMR";
      goto LABEL_461;
    }
    LODWORD(destination[0]) = 40;
    HIDWORD(v212[3]) = 1;
    v212[0] = *((char **)&unk_18EDDD230 + (v83 == 1935764850));
    DataPointer = AudioToolbox_AudioFormatGetProperty(1718449257, DWORD2(v207), v207, (uint64_t)destination, (uint64_t)v212);
    goto LABEL_463;
  }
  if (v83 > 1634492770)
  {
    if (v83 > 1701733216)
    {
      if (v83 <= 1718367025)
      {
        if (v83 == 1701733217)
        {
LABEL_443:
          if ((_QWORD)v197)
          {
            DataPointer = figSoundBridge_GetMP4ASBDFromESDSDataBBuf((uint64_t)v192, (uint64_t)v212);
            if ((_DWORD)DataPointer)
              goto LABEL_463;
            if (v83 == 1633777252)
            {
              Empty = 0;
              v155 = 1633771875;
              goto LABEL_747;
            }
            if (v83 != 1701733217)
            {
              if (SLODWORD(v212[1]) <= 1633772399)
              {
                if (LODWORD(v212[1]) == 1633772320)
                {
                  Empty = 0;
                  v155 = 1885430115;
                  goto LABEL_747;
                }
                if (LODWORD(v212[1]) == 1633772392)
                {
                  Empty = 0;
                  v103 = 1885430115;
LABEL_688:
                  v155 = v103 + 517;
LABEL_747:
                  LODWORD(v212[1]) = v155;
                  goto LABEL_503;
                }
                goto LABEL_728;
              }
              if (LODWORD(v212[1]) != 1633772400)
              {
                if (LODWORD(v212[1]) == 1970495843)
                {
                  Empty = 0;
                  v155 = 1886745441;
                  goto LABEL_747;
                }
LABEL_728:
                v96 = v208;
                v97 = "Unrecognized audio codec type for 'drms'";
                goto LABEL_461;
              }
              Empty = 0;
              v160 = 1885430115;
LABEL_727:
              v155 = v160 + 525;
              goto LABEL_747;
            }
            if (SLODWORD(v212[1]) > 1633772399)
            {
              if (LODWORD(v212[1]) == 1633772400)
              {
                Empty = 0;
                v160 = 1902207331;
                goto LABEL_727;
              }
              if (LODWORD(v212[1]) == 1970495843)
              {
                Empty = 0;
                v155 = 1903522657;
                goto LABEL_747;
              }
            }
            else
            {
              if (LODWORD(v212[1]) == 1633772320)
              {
                Empty = 0;
                v155 = 1902207331;
                goto LABEL_747;
              }
              if (LODWORD(v212[1]) == 1633772392)
              {
                Empty = 0;
                v103 = 1902207331;
                goto LABEL_688;
              }
            }
            v96 = v208;
            v97 = "Unrecognized audio codec type for 'enca'";
LABEL_461:
            figSoundBridge_ReportParsingFailureMessage(v96, (uint64_t)v97);
            Property = 4294954582;
            goto LABEL_462;
          }
          if (*((_QWORD *)&v197 + 1))
          {
            DataPointer = figSoundBridge_GetASBDFromDAC3BBuf(*((OpaqueCMBlockBuffer **)&v197 + 1), (uint64_t)v212);
            if ((_DWORD)DataPointer)
              goto LABEL_463;
            if (v83 != 1633777252)
            {
              Empty = 0;
              if (v83 == 1701733217)
                v108 = 1902207331;
              else
                v108 = 1885430115;
              v155 = v108 + 464;
              goto LABEL_747;
            }
            v96 = v208;
            v97 = "Unrecognized audio codec type AC3 for 'aavd'";
            goto LABEL_461;
          }
          if ((_QWORD)v198)
          {
            DataPointer = figSoundBridge_GetASBDFromDEC3BBuf((OpaqueCMBlockBuffer *)v198, (uint64_t)v212);
            if ((_DWORD)DataPointer)
              goto LABEL_463;
            if (v83 != 1633777252)
            {
              Empty = 0;
              if (v83 == 1701733217)
                v155 = 1902469939;
              else
                v155 = 1885692723;
              goto LABEL_747;
            }
            v96 = v208;
            v97 = "Unrecognized audio codec type EnhancedAC3 for 'aavd'";
            goto LABEL_461;
          }
          if ((_QWORD)v199)
          {
            DataPointer = figSoundBridge_GetASBDFromAudioFormatWithCodecSpecificAtomBBuf(1718378851, (CMBlockBufferRef)v199, (uint64_t)v212);
            if ((_DWORD)DataPointer)
              goto LABEL_463;
            if (v83 == 1701733217)
            {
              Empty = 0;
              v155 = 1902537827;
              goto LABEL_747;
            }
            v96 = v208;
            v97 = "Unrecognized audio protection type for FLAC";
            goto LABEL_461;
          }
          if (*((_QWORD *)&v198 + 1))
          {
            DataPointer = figSoundBridge_GetASBDFromALACBBuf(*((OpaqueCMBlockBuffer **)&v198 + 1), (uint64_t)v212);
            if ((_DWORD)DataPointer)
              goto LABEL_463;
            if (v83 == 1701733217)
            {
              Empty = 0;
              v155 = 1902928227;
              goto LABEL_747;
            }
            v96 = v208;
            v97 = "Unrecognized audio protection type for Apple Lossless";
            goto LABEL_461;
          }
          if (*((_QWORD *)&v203 + 1))
          {
            DataPointer = figSoundBridge_GetASBDFromAudioFormatWithCodecSpecificAtomBBuf(v204, *((CMBlockBufferRef *)&v203 + 1), (uint64_t)v212);
            if ((_DWORD)DataPointer)
              goto LABEL_463;
            if (v83 == 1701733217
              && (LODWORD(v212[1]) == 1634754915 || LODWORD(v212[1]) == 1902211171 || LODWORD(v212[1]) == 1667330147))
            {
              Empty = 0;
              v155 = 1902211171;
              goto LABEL_747;
            }
            v96 = v208;
            v97 = "Unrecognized audio protection type";
            goto LABEL_461;
          }
          if (v83 == 1633777252)
          {
            Empty = 0;
            v163 = 1633771875;
          }
          else
          {
            if (v83 != 1685220723)
            {
              Empty = 0;
              goto LABEL_503;
            }
            Empty = 0;
            v163 = 1885430115;
          }
          LODWORD(v212[1]) = v163;
LABEL_658:
          v212[2] = (char *)0x40000000000;
          goto LABEL_503;
        }
        if (v83 != 1716281667)
          goto LABEL_485;
        LODWORD(v212[1]) = 1718378851;
LABEL_464:
        if ((_QWORD)v199)
        {
          DataPointer = figSoundBridge_GetASBDFromAudioFormatWithCodecSpecificAtomBBuf(1718378851, (CMBlockBufferRef)v199, (uint64_t)v212);
          goto LABEL_463;
        }
        goto LABEL_502;
      }
      if (v83 != 1718367026)
      {
        v101 = 1718367796;
        goto LABEL_459;
      }
LABEL_460:
      v96 = v208;
      v97 = "Detected an old, unsupported PCM OSType";
      goto LABEL_461;
    }
    if (v83 == 1634492771)
    {
      if (*((_QWORD *)&v198 + 1))
      {
        DataPointer = figSoundBridge_GetASBDFromALACBBuf(*((OpaqueCMBlockBuffer **)&v198 + 1), (uint64_t)v212);
        goto LABEL_463;
      }
      goto LABEL_502;
    }
    if (v83 == 1685220723)
      goto LABEL_443;
    if (v83 != 1700998451)
      goto LABEL_485;
    if (!(_QWORD)v198)
    {
      v96 = v208;
      v97 = "Expected to get a magic cookie for ec-3";
      goto LABEL_461;
    }
    DataPointer = figSoundBridge_GetASBDFromDEC3BBuf((OpaqueCMBlockBuffer *)v198, (uint64_t)v212);
LABEL_463:
    Empty = DataPointer;
    goto LABEL_503;
  }
  if (v83 <= 1296122677)
  {
    if (v83)
    {
      if (v83 == 778924083)
      {
        if ((HIDWORD(v192[1]) - 3) < 2)
          goto LABEL_502;
      }
      else if (v83 == 1296122675)
      {
        Empty = 0;
        LODWORD(v212[2]) = 2 * v92;
        HIDWORD(v212[2]) = 6;
        goto LABEL_503;
      }
      goto LABEL_485;
    }
    goto LABEL_460;
  }
  if (v83 <= 1633777251)
  {
    if (v83 != 1296122678)
    {
      v101 = 1313820229;
      goto LABEL_459;
    }
    Empty = 0;
    v212[2] = (char *)(v92 | 0x600000000);
    goto LABEL_503;
  }
  if (v83 == 1633777252)
    goto LABEL_443;
  if (v83 == 1633889587)
  {
    if (*((_QWORD *)&v197 + 1))
    {
      DataPointer = figSoundBridge_GetASBDFromDAC3BBuf(*((OpaqueCMBlockBuffer **)&v197 + 1), (uint64_t)v212);
      goto LABEL_463;
    }
LABEL_502:
    Empty = 0;
    goto LABEL_503;
  }
LABEL_485:
  if (!*((_QWORD *)&v203 + 1)
    || (LODWORD(destination[0]) = 0,
        figSoundBridge_GetDecodeFormatIDForCodingName(v83, (uint64_t)v192, destination)))
  {
LABEL_487:
    destination[0] = *(_OWORD *)v212;
    destination[1] = *(_OWORD *)&v212[2];
    *(_QWORD *)&v219 = v213;
    *(_QWORD *)&v226 = 32;
    dataPointerOut[0] = v212[0];
    dataPointerOut[1] = (CFTypeRef)0x96C70636DLL;
    LODWORD(v225) = 4 * HIDWORD(v212[3]);
    DWORD1(v225) = 1;
    DWORD2(v225) = 4 * HIDWORD(v212[3]);
    HIDWORD(v225) = HIDWORD(v212[3]);
    if (!AudioToolbox_AudioConverterNew((uint64_t)destination, (uint64_t)dataPointerOut, (uint64_t)&size)
      && (!(_QWORD)v207
       || !DWORD2(v207)
       || !AudioToolbox_AudioConverterSetProperty(size, 1684891491, DWORD2(v207), v207)))
    {
      LODWORD(blockBufferOut) = 40;
      if (!AudioToolbox_AudioConverterGetProperty(size, 1633904996, (uint64_t)&blockBufferOut, (uint64_t)destination))
      {
        *(_OWORD *)v212 = destination[0];
        *(_OWORD *)&v212[2] = destination[1];
        v213 = v219;
      }
    }
    if (size)
      AudioToolbox_AudioConverterDispose(size);
    goto LABEL_502;
  }
  v158 = destination[0];
  LODWORD(v212[1]) = destination[0];
  Empty = figSoundBridge_GetASBDFromAudioFormatWithCodecSpecificAtomBBuf(destination[0], *((CMBlockBufferRef *)&v203 + 1), (uint64_t)v212);
  if (!(_DWORD)Empty)
    goto LABEL_503;
  if (v158 > 1869641074)
  {
    if (v158 == 1869641075)
      goto LABEL_503;
    v159 = 1902211171;
  }
  else
  {
    if (v158 == 1634754915)
      goto LABEL_503;
    v159 = 1667330147;
  }
  if (v158 != v159)
  {
    figSoundBridge_ReportParsingFailureMessage(v208, (uint64_t)"AudioToolbox failed to parse the magic cookie; the resulting audio description may not be authoritative");
    goto LABEL_487;
  }
LABEL_503:
  if ((_DWORD)Empty)
  {
LABEL_504:
    v109 = 0;
    goto LABEL_505;
  }
  v113 = a5;
  theBuffera = theSourceBuffer;
  v171 = a1;
  v114 = v212[0];
  v186 = *(_OWORD *)((char *)&v212[1] + 4);
  v115 = (AudioFormatID)v212[1];
  v116 = HIDWORD(v212[3]);
  v117 = v213;
  if (!*((_QWORD *)&v200 + 1))
  {
    v119 = 0;
    goto LABEL_560;
  }
  v118 = CMBlockBufferGetDataLength(*((CMBlockBufferRef *)&v200 + 1));
  v119 = v118;
  if (!v118)
    goto LABEL_560;
  v120 = v118 - 12;
  if (v118 <= 0xC)
  {
    v161 = "Channel extension size is too short";
    v162 = v113;
    goto LABEL_738;
  }
  v109 = (AudioChannelLayout *)malloc_type_malloc(v118 - 12, 0xE0C9B033uLL);
  v121 = CMBlockBufferCopyDataBytes(*((CMBlockBufferRef *)&v200 + 1), 0xCuLL, v119 - 12, v109);
  if ((_DWORD)v121)
    goto LABEL_774;
  if (!v109)
  {
    v119 -= 12;
LABEL_560:
    v109 = 0;
    if (!(_QWORD)v201)
    {
      v120 = 0;
      goto LABEL_578;
    }
    v120 = 0;
    if (v115 != 1819304813)
      goto LABEL_578;
    dataPointerOut[0] = 0;
    v212[0] = 0;
    LODWORD(size) = 0;
    *(_QWORD *)&v220 = 0;
    v219 = 0u;
    memset(destination, 0, sizeof(destination));
    if (CMBlockBufferGetDataPointer((CMBlockBufferRef)v201, 0, (size_t *)dataPointerOut, 0, v212))
    {
      v109 = 0;
    }
    else
    {
      *(_QWORD *)&destination[0] = v114;
      *(_OWORD *)((char *)destination + 12) = v186;
      DWORD2(destination[0]) = 1819304813;
      HIDWORD(destination[1]) = v116;
      *(_QWORD *)&v219 = v117;
      *((char **)&v219 + 1) = v212[0];
      LODWORD(v220) = dataPointerOut[0];
      PropertyInfo = AudioToolbox_AudioFormatGetPropertyInfo(1684235116, 56, (uint64_t)destination, (uint64_t)&size);
      if ((_DWORD)PropertyInfo)
      {
        v109 = 0;
      }
      else
      {
        v109 = (AudioChannelLayout *)malloc_type_malloc(size, 0x19220E06uLL);
        if (v109)
        {
          PropertyInfo = AudioToolbox_AudioFormatGetProperty(1684235116, 56, (uint64_t)destination, (uint64_t)&size, (uint64_t)v109);
          if (!(_DWORD)PropertyInfo)
          {
            v119 = size;
LABEL_567:
            v120 = v119;
            goto LABEL_578;
          }
        }
        else
        {
          PropertyInfo = 4294954583;
        }
      }
      if (!FigSignalErrorAt(PropertyInfo, 0, 0, 0, 0, 0, 0))
      {
        v109 = 0;
        goto LABEL_567;
      }
    }
    free(v109);
    if (v116 >= 3)
    {
      figSoundBridge_ReportParsingFailureMessage(v113, (uint64_t)"Can't convert ISO channel layout for multichannel audio to an AudioChannelLayout");
      Empty = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      v109 = 0;
      v110 = 0;
      v111 = 0;
      goto LABEL_506;
    }
    v109 = 0;
    v120 = 0;
    goto LABEL_578;
  }
  if (v120 <= 4)
  {
    figSoundBridge_ReportParsingFailureMessage(v113, (uint64_t)"Channel extension size is too short");
    v121 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_774;
  }
  if (v120 < 0xC)
    goto LABEL_556;
  v123 = *(int8x8_t *)&v109->mChannelLayoutTag;
  mNumberChannelDescriptions = v109->mNumberChannelDescriptions;
  v125 = bswap32(mNumberChannelDescriptions);
  if (v125 <= ((int)v119 - 24) / 0x14u)
  {
    if (mNumberChannelDescriptions)
    {
      v126 = 0;
      mCoordinates = (AudioChannelLayout *)v109->mChannelDescriptions[0].mCoordinates;
      do
      {
        v128 = 0;
        *(int8x8_t *)&v109->mChannelDescriptions[v126].mChannelLabel = vrev32_s8(*(int8x8_t *)&v109->mChannelDescriptions[v126].mChannelLabel);
        do
        {
          *(AudioChannelLayoutTag *)((char *)&mCoordinates->mChannelLayoutTag + v128) = bswap32(*(AudioChannelLayoutTag *)((char *)&mCoordinates->mChannelLayoutTag + v128));
          v128 += 4;
        }
        while (v128 != 12);
        ++v126;
        mCoordinates = (AudioChannelLayout *)((char *)mCoordinates + 20);
      }
      while (v126 != v125);
    }
LABEL_577:
    *(int8x8_t *)&v109->mChannelLayoutTag = vrev32_s8(v123);
    v109->mNumberChannelDescriptions = v125;
    goto LABEL_578;
  }
  if (v123.i32[0])
  {
    LODWORD(v125) = 0;
    goto LABEL_577;
  }
LABEL_556:
  v121 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (!(_DWORD)v121)
  {
LABEL_578:
    *(_QWORD *)&v188[0] = v114;
    *(_OWORD *)((char *)v188 + 12) = v186;
    DWORD2(v188[0]) = v115;
    HIDWORD(v188[1]) = v116;
    *(_QWORD *)&v189 = v117;
    *((_QWORD *)&v189 + 1) = v207;
    LODWORD(v190) = DWORD2(v207);
    v129 = AudioToolbox_AudioFormatGetPropertyInfo(1718383476, 56, (uint64_t)v188, (uint64_t)&v191);
    if ((_DWORD)v129)
    {
      Empty = v129;
      allocatora = (CFAllocatorRef)v120;
      *(_QWORD *)&asbd.mSampleRate = v114;
      asbd.mFormatID = v115;
      *(_OWORD *)&asbd.mFormatFlags = v186;
      asbd.mChannelsPerFrame = v116;
      *(_QWORD *)&asbd.mBitsPerChannel = v117;
      v130 = v171;
      if ((_QWORD)v197)
      {
        *(_QWORD *)&destination[0] = 0;
        dataPointerOut[0] = 0;
        if (!CMBlockBufferGetDataPointer((CMBlockBufferRef)v197, 0, (size_t *)destination, 0, (char **)dataPointerOut))
        {
          if (HIDWORD(*(_QWORD *)&destination[0]))
          {
            FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
          }
          else
          {
            LODWORD(v212[0]) = 32;
            AudioToolbox_AudioFormatGetProperty(1702060908, *(uint64_t *)&destination[0], (uint64_t)dataPointerOut[0], (uint64_t)v212, (uint64_t)&layout);
          }
        }
      }
      v131 = v207;
      v132 = DWORD2(v207);
      if (!v109 && v115 == 1633889587 && (_QWORD)v207 && DWORD2(v207))
      {
        *(_QWORD *)&v219 = 0;
        memset(destination, 0, sizeof(destination));
        LODWORD(dataPointerOut[0]) = 0;
        if (!ParseAC3MP4Cookie((unsigned __int8 *)v207, DWORD2(v207), (uint64_t)destination, (int *)dataPointerOut)&& DWORD2(destination[0]) == 1633889587)
        {
          layout.mChannelLayoutTag = (AudioChannelLayoutTag)dataPointerOut[0];
        }
        v115 = 1633889587;
      }
      v110 = 0;
      if (!v109 && DWORD2(v188[0]) == 1700998451 && v131 && v132)
      {
        *(_QWORD *)&v219 = 0;
        memset(destination, 0, sizeof(destination));
        dataPointerOut[0] = 0;
        LODWORD(v212[0]) = 0;
        if (!ParseEnhancedAC3MP4Cookie(v131, v132, (uint64_t)destination, dataPointerOut, (unsigned int *)v212)&& v115 == DWORD2(destination[0]))
        {
          layout.mChannelLayoutTag = *(_DWORD *)dataPointerOut[0];
        }
        free((void *)dataPointerOut[0]);
        v110 = 0;
      }
      goto LABEL_611;
    }
    if (v191 > 0x2F)
    {
      v110 = malloc_type_calloc(1uLL, v191, 0x6D08AF81uLL);
      if (v110)
      {
        Empty = AudioToolbox_AudioFormatGetProperty(1718383476, 56, (uint64_t)v188, (uint64_t)&v191, (uint64_t)v110);
        allocatora = (CFAllocatorRef)v120;
        if ((_DWORD)Empty || v191 <= 0x2F)
        {
          *(_QWORD *)&asbd.mSampleRate = v114;
          asbd.mFormatID = v115;
          *(_OWORD *)&asbd.mFormatFlags = v186;
          asbd.mChannelsPerFrame = v116;
          *(_QWORD *)&asbd.mBitsPerChannel = v117;
        }
        else
        {
          v133 = (char *)&v110[12 * (v191 / 0x30) - 12];
          v134 = *(_OWORD *)v133;
          v135 = *((_OWORD *)v133 + 1);
          *(_QWORD *)&asbd.mBitsPerChannel = *((_QWORD *)v133 + 4);
          *(_OWORD *)&asbd.mSampleRate = v134;
          *(_OWORD *)&asbd.mBytesPerPacket = v135;
          layout.mChannelLayoutTag = *((_DWORD *)v133 + 10);
          if (!layout.mChannelLayoutTag)
          {
            v156 = *(_OWORD *)v133;
            v157 = *((_OWORD *)v133 + 1);
            *(_QWORD *)&v189 = *((_QWORD *)v133 + 4);
            v188[1] = v157;
            v188[0] = v156;
            v130 = v171;
            Empty = 0;
            if (!figSoundBridge_ChannelLayoutFromFormatInfo((uint64_t)v188, &v182, &v181))
              layout.mNumberChannelDescriptions = *((_DWORD *)v182 + 2);
LABEL_611:
            v212[0] = 0;
            v219 = 0u;
            v220 = 0u;
            memset(destination, 0, sizeof(destination));
            v226 = 0u;
            v227 = 0u;
            *(_OWORD *)dataPointerOut = 0u;
            v225 = 0u;
            blockBufferOut = 0;
            size = 0;
            v136 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v137 = CMBlockBufferGetDataLength(theBuffera);
            if (!CMBlockBufferCreateContiguous(v136, theBuffera, 0, 0, 0, v137, 0, &blockBufferOut))
            {
              v138 = blockBufferOut;
              v139 = CMBlockBufferGetDataLength(blockBufferOut);
              if (!FigCreateCFDataWithBlockBufferNoCopy(v136, v138, 0, v139, (CFDataRef *)&size))
              {
                if ((v192[0] & 1) != 0)
                {
                  if (BYTE8(v208))
                    v140 = kFigFormatDescriptionExtension_DeprecatedVerbatimISOSampleEntry;
                  else
                    v140 = (__CFString **)&kCMFormatDescriptionExtension_VerbatimISOSampleEntry;
                }
                else if (BYTE8(v208))
                {
                  v140 = kFigFormatDescriptionExtension_DeprecatedVerbatimSampleDescription;
                }
                else
                {
                  v140 = (__CFString **)&kCMFormatDescriptionExtension_VerbatimSampleDescription;
                }
                v141 = *v140;
                dataPointerOut[0] = (CFTypeRef)size;
                size = 0;
                *(_QWORD *)&destination[0] = v141;
                v142 = 1;
                v212[0] = (char *)1;
                if (*((_QWORD *)&v204 + 1))
                {
                  *((_QWORD *)&destination[0] + 1) = CFSTR("SampleDescriptionExtensionAtoms");
                  dataPointerOut[1] = CFRetain(*((CFTypeRef *)&v204 + 1));
                  v142 = 2;
                  v212[0] = (char *)2;
                }
                if (!(_QWORD)v202)
                {
LABEL_630:
                  v111 = CFDictionaryCreate(v130, (const void **)destination, dataPointerOut, v142, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
                  if (!v111)
                    FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
LABEL_632:
                  if (v212[0])
                  {
                    v145 = 0;
                    do
                    {
                      CFRelease(*((CFTypeRef *)destination + (_QWORD)v145));
                      CFRelease(dataPointerOut[(_QWORD)v145++]);
                    }
                    while (v145 < v212[0]);
                  }
                  if (blockBufferOut)
                    CFRelease(blockBufferOut);
                  v146 = (size_t)allocatora;
                  if (!v111)
                    goto LABEL_506;
                  v184 = 40;
                  AudioToolbox_AudioFormatGetProperty(1718449257, DWORD2(v207), v207, (uint64_t)&v184, (uint64_t)&asbd);
                  if (layout.mChannelLayoutTag == 0x10000)
                  {
                    mChannelBitmap = layout.mChannelBitmap;
                    if (!layout.mChannelBitmap)
                      goto LABEL_677;
                    mChannelLayoutTag_low = 0;
                    do
                    {
                      mChannelLayoutTag_low += mChannelBitmap & 1;
                      v149 = mChannelBitmap >= 2;
                      mChannelBitmap >>= 1;
                    }
                    while (v149);
                  }
                  else if (layout.mChannelLayoutTag)
                  {
                    mChannelLayoutTag_low = LOWORD(layout.mChannelLayoutTag);
                  }
                  else
                  {
                    mChannelLayoutTag_low = layout.mNumberChannelDescriptions;
                  }
                  if (mChannelLayoutTag_low)
                  {
                    if (!v109)
                      goto LABEL_679;
                    if (v109->mChannelLayoutTag == 0x10000)
                    {
                      v151 = v109->mChannelBitmap;
                      if (v151)
                      {
                        v150 = 0;
                        do
                        {
                          v150 += v151 & 1;
                          v149 = v151 >= 2;
                          v151 >>= 1;
                        }
                        while (v149);
                      }
                      else
                      {
                        v150 = 0;
                      }
                    }
                    else
                    {
                      v150 = v109->mChannelLayoutTag
                           ? (unsigned __int16)v109->mChannelLayoutTag
                           : v109->mNumberChannelDescriptions;
                    }
                    v152 = v191;
                    LODWORD(destination[0]) = 0;
                    if (!v110 || v191 <= 0x2F)
                      goto LABEL_679;
                    if (FigAudioFormatGetRichestDecodableFormatIndex((uint64_t)v110, v191, destination))
                      v153 = 0;
                    else
                      v153 = destination[0];
                    if (v110[12 * v153 + 7] == v150)
                      goto LABEL_677;
                    p_layout = v109;
                    if (v110[12 * (v152 / 0x30) - 5] != v150)
                    {
LABEL_679:
                      p_layout = (const AudioChannelLayout *)v182;
                      if (v182)
                      {
                        v146 = v181;
                      }
                      else
                      {
                        p_layout = &layout;
                        v146 = 12;
                      }
                    }
LABEL_682:
                    Empty = CMAudioFormatDescriptionCreate(v130, &asbd, v146, p_layout, DWORD2(v207), (const void *)v207, v111, &formatDescriptionOut);
                    if (!(_DWORD)Empty)
                    {
                      *v172 = formatDescriptionOut;
                      formatDescriptionOut = 0;
                    }
                    goto LABEL_506;
                  }
LABEL_677:
                  p_layout = v109;
                  goto LABEL_682;
                }
                lengthAtOffsetOut = 0;
                v215 = 0;
                if (!CMBlockBufferGetDataPointer((CMBlockBufferRef)v202, 0, &lengthAtOffsetOut, 0, &v215))
                {
                  lengthAtOffsetOut -= 8;
                  v215 += 8;
                  LODWORD(v206) = FigBridgeGetCommonEncryptionScheme((uint64_t)v215, lengthAtOffsetOut);
                  if ((_DWORD)v206)
                  {
                    *((_QWORD *)destination + v142) = CFSTR("CommonEncryptionProtected");
                    dataPointerOut[v142] = (CFTypeRef)*MEMORY[0x1E0C9AE50];
                    v143 = v142 + 1;
                    v212[0] = (char *)(v142 + 1);
                    OriginalFormatFromSinf = FigBridgeGetOriginalFormatFromSinf((uint64_t)v215, lengthAtOffsetOut);
                    if (OriginalFormatFromSinf)
                    {
                      *((_QWORD *)destination + v143) = CFSTR("CommonEncryptionOriginalFormat");
                      dataPointerOut[v143] = FigCFNumberCreateSInt32(v136, OriginalFormatFromSinf);
                      v212[0] = (char *)(v142 + 2);
                    }
                    v130 = v171;
                    if (FigBridgeExtractCommonEncryptionTrackEncryptionExtension(v171, (uint64_t)destination, (uint64_t)dataPointerOut, v212, (uint64_t)v215, lengthAtOffsetOut))
                    {
                      v111 = 0;
                      goto LABEL_632;
                    }
                    v142 = (CFIndex)v212[0];
                  }
                  goto LABEL_630;
                }
              }
            }
            v111 = 0;
            goto LABEL_632;
          }
          Empty = 0;
        }
        v130 = v171;
        goto LABEL_611;
      }
      FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
      v110 = 0;
    }
    v111 = 0;
    Empty = 0;
    goto LABEL_506;
  }
LABEL_774:
  Empty = v121;
LABEL_505:
  v110 = 0;
  v111 = 0;
LABEL_506:
  free(v109);
  free(v110);
  free(v182);
  if (*((_QWORD *)&v206 + 1))
    CFRelease(*((CFTypeRef *)&v206 + 1));
  *(_QWORD *)&v207 = 0;
  if ((_QWORD)v196)
    CFRelease((CFTypeRef)v196);
  if ((_QWORD)v197)
    CFRelease((CFTypeRef)v197);
  if (*((_QWORD *)&v196 + 1))
    CFRelease(*((CFTypeRef *)&v196 + 1));
  if (*((_QWORD *)&v197 + 1))
    CFRelease(*((CFTypeRef *)&v197 + 1));
  if ((_QWORD)v198)
    CFRelease((CFTypeRef)v198);
  if (*((_QWORD *)&v198 + 1))
    CFRelease(*((CFTypeRef *)&v198 + 1));
  if ((_QWORD)v199)
    CFRelease((CFTypeRef)v199);
  if (*((_QWORD *)&v199 + 1))
    CFRelease(*((CFTypeRef *)&v199 + 1));
  if (*((_QWORD *)&v200 + 1))
    CFRelease(*((CFTypeRef *)&v200 + 1));
  if ((_QWORD)v201)
    CFRelease((CFTypeRef)v201);
  if ((_QWORD)v203)
    CFRelease((CFTypeRef)v203);
  if (*((_QWORD *)&v201 + 1))
    CFRelease(*((CFTypeRef *)&v201 + 1));
  if ((_QWORD)v202)
    CFRelease((CFTypeRef)v202);
  if (*((_QWORD *)&v202 + 1))
    CFRelease(*((CFTypeRef *)&v202 + 1));
  if ((_QWORD)v200)
    CFRelease((CFTypeRef)v200);
  if (*((_QWORD *)&v203 + 1))
    CFRelease(*((CFTypeRef *)&v203 + 1));
  if (*((_QWORD *)&v204 + 1))
    CFRelease(*((CFTypeRef *)&v204 + 1));
  if (v111)
    CFRelease(v111);
  if ((Empty + 12896) < 7 || (_DWORD)Empty == -206)
    return 4294954582;
  return Empty;
}

void figSoundBridge_ReportParsingFailureMessage(uint64_t a1, uint64_t a2)
{
  const __CFAllocator *v4;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v6;
  __CFString *v7;
  __CFString *v8;

  if (a1)
  {
    v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v6 = Mutable;
      v7 = CFStringCreateMutable(v4, 0);
      if (v7)
      {
        v8 = v7;
        CFStringAppendFormat(v7, 0, CFSTR(" %s."), a2);
        FigCFDictionarySetInt64(v6, CFSTR("MessageType"), 2);
        CFDictionarySetValue(v6, CFSTR("DiagnosticInformation"), v8);
        FigCFDictionarySetInt32(v6, CFSTR("AnalysisType"), 1836019574);
        FigAssetAnalysisReporterAddMessage(a1, v6);
        CFRelease(v8);
      }
      CFRelease(v6);
    }
  }
}

uint64_t figSoundBridge_ChannelLayoutFromFormatInfo(uint64_t a1, _QWORD *a2, _DWORD *a3)
{
  uint64_t PropertyInfo;
  void *v7;
  uint64_t Property;
  uint64_t v9;
  size_t size;

  LODWORD(size) = 0;
  PropertyInfo = AudioToolbox_AudioFormatGetPropertyInfo(1668048489, 56, a1, (uint64_t)&size);
  if ((_DWORD)PropertyInfo)
    goto LABEL_9;
  if (size <= 0x1F)
  {
    PropertyInfo = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
LABEL_9:
    v9 = PropertyInfo;
    goto LABEL_6;
  }
  v7 = malloc_type_malloc(size, 0x8A7ADFBFuLL);
  if (!v7)
  {
    Property = 4294954583;
    goto LABEL_11;
  }
  Property = AudioToolbox_AudioFormatGetProperty(1668048489, 56, a1, (uint64_t)&size, (uint64_t)v7);
  if ((_DWORD)Property)
  {
LABEL_11:
    v9 = FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  v9 = 0;
  *a2 = v7;
  *a3 = size;
LABEL_6:
  v7 = 0;
LABEL_7:
  free(v7);
  return v9;
}

uint64_t ParseAC3MP4Cookie(unsigned __int8 *a1, unsigned int a2, uint64_t a3, int *a4)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  BOOL v11;
  int v12;
  int v13;

  v4 = 4294954582;
  if (a1 && a2 >= 0xB)
  {
    v5 = (unint64_t)a1[8] >> 6;
    if ((_DWORD)v5 == 3)
      return 4294954582;
    v6 = ParseEnhancedAC3MP4Cookie_theSampleRateTable[v5];
    v7 = a1[9];
    v8 = (v7 >> 3) & 7;
    v9 = ParseAC3MP4Cookie_theChannelTable[v8];
    v10 = v7 & 4;
    if (a4)
    {
      switch((int)v8)
      {
        case 1:
          v11 = v10 == 0;
          v12 = 9764866;
          v13 = 6553601;
          break;
        case 3:
          v12 = 9961476;
          v11 = v10 == 0;
          v13 = 9830403;
          break;
        case 4:
          v12 = 10027012;
          v11 = v10 == 0;
          v13 = 8585219;
          break;
        case 5:
          v11 = v10 == 0;
          v12 = 10092549;
          v13 = 9895940;
          break;
        case 6:
          v11 = v10 == 0;
          v12 = 9043973;
          v13 = 8650756;
          break;
        case 7:
          v11 = v10 == 0;
          v12 = 8060934;
          v13 = 7798789;
          break;
        default:
          v11 = v10 == 0;
          v12 = 8716291;
          v13 = 6619138;
          break;
      }
      if (v11)
        v12 = v13;
      *a4 = v12;
    }
    if (((a1[10] >> 5) & 0xFFFFFFE7 | (8 * (a1[9] & 3))) > 0x12)
    {
      return 4294954582;
    }
    else
    {
      v4 = 0;
      if (a3)
      {
        *(_QWORD *)a3 = v6;
        *(_QWORD *)(a3 + 8) = 1633889587;
        *(_QWORD *)(a3 + 16) = 0x60000000000;
        *(_DWORD *)(a3 + 24) = 0;
        *(_DWORD *)(a3 + 28) = v9 + (v10 >> 2);
        *(_QWORD *)(a3 + 32) = 0;
      }
    }
  }
  return v4;
}

uint64_t ParseEnhancedAC3MP4Cookie(uint64_t a1, unsigned int a2, uint64_t a3, _QWORD *a4, unsigned int *a5)
{
  uint64_t result;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned __int8 *v12;
  double v13;
  double v14;
  unint64_t v15;
  unsigned int v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  unsigned __int8 v21;
  unsigned __int8 v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  unsigned int v33;
  _DWORD *v34;
  int v37;
  int v38;
  uint64_t v39;
  __int128 __src;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  result = 4294954582;
  if (!a1 || a2 < 0xD)
    return result;
  v8 = 0;
  v9 = a1 + 8;
  v10 = a2 - 8;
  v11 = *(_BYTE *)(a1 + 9) & 7;
  v39 = 0;
  v12 = (unsigned __int8 *)(a1 + 10);
  v13 = 0.0;
  v14 = 0.0;
  do
  {
    if ((uint64_t)&v12[-v9 + 3] > v10)
      return 4294954582;
    v15 = (unint64_t)*v12 >> 6;
    v67 = 0;
    v65 = 0uLL;
    v66 = 0uLL;
    v63 = 0uLL;
    v64 = 0uLL;
    v61 = 0uLL;
    v62 = 0uLL;
    v59 = 0uLL;
    v60 = 0uLL;
    v57 = 0uLL;
    v58 = 0uLL;
    v55 = 0uLL;
    v56 = 0uLL;
    v53 = 0uLL;
    v54 = 0uLL;
    v51 = 0uLL;
    v52 = 0uLL;
    v49 = 0uLL;
    v50 = 0uLL;
    v47 = 0uLL;
    v48 = 0uLL;
    v45 = 0uLL;
    v46 = 0uLL;
    v43 = 0uLL;
    v44 = 0uLL;
    v41 = 0uLL;
    v42 = 0uLL;
    __src = 0uLL;
    if ((_DWORD)v15 == 3)
      return 4294954582;
    if (*(double *)&ParseEnhancedAC3MP4Cookie_theSampleRateTable[v15] > v14 || v8 == 0)
    {
      v13 = *(double *)&ParseEnhancedAC3MP4Cookie_theSampleRateTable[v15];
      v14 = v13;
    }
    v17 = v12[1];
    v18 = (v17 >> 1) & 7;
    switch(v18)
    {
      case 1:
        LODWORD(__src) = 3;
        v19 = 1;
        if ((v17 & 1) != 0)
          goto LABEL_25;
        break;
      case 3:
        v19 = 3;
        LODWORD(__src) = 1;
        DWORD1(v41) = 3;
        DWORD2(v42) = 2;
        if ((v17 & 1) != 0)
          goto LABEL_25;
        break;
      case 4:
        LODWORD(__src) = 1;
        DWORD1(v41) = 2;
        v19 = 3;
        DWORD2(v42) = 9;
        if ((v17 & 1) != 0)
          goto LABEL_25;
        break;
      case 5:
        LODWORD(__src) = 1;
        DWORD1(v41) = 3;
        v19 = 4;
        DWORD2(v42) = 2;
        HIDWORD(v43) = 9;
        if ((v17 & 1) != 0)
          goto LABEL_25;
        break;
      case 6:
        LODWORD(__src) = 1;
        DWORD1(v41) = 2;
        v19 = 4;
        DWORD2(v42) = 5;
        HIDWORD(v43) = 6;
        if ((v17 & 1) != 0)
          goto LABEL_25;
        break;
      case 7:
        LODWORD(__src) = 1;
        DWORD1(v41) = 3;
        v19 = 5;
        DWORD2(v42) = 2;
        HIDWORD(v43) = 5;
        LODWORD(v45) = 6;
        if ((v17 & 1) != 0)
          goto LABEL_25;
        break;
      default:
        v19 = 2;
        LODWORD(__src) = 1;
        DWORD1(v41) = 2;
        if ((v17 & 1) != 0)
        {
LABEL_25:
          v20 = 20 * v19++;
          *(_DWORD *)((char *)&__src + v20) = 4;
        }
        break;
    }
    v21 = v12[2];
    if ((v21 & 0x1E) == 0)
    {
      v12 += 3;
      continue;
    }
    if ((uint64_t)&v12[-v9 + 4] > v10)
      return 4294954582;
    v22 = v12[3];
    if ((v22 & 1) != 0)
    {
      v23 = v19 + 1;
      *((_DWORD *)&__src + 5 * v19) = 7;
      v19 += 2;
      *((_DWORD *)&__src + 5 * v23) = 8;
      if ((v22 & 2) == 0)
      {
LABEL_30:
        if ((v22 & 4) == 0)
          goto LABEL_37;
        goto LABEL_35;
      }
    }
    else if ((v12[3] & 2) == 0)
    {
      goto LABEL_30;
    }
    v24 = v19 + 1;
    *((_DWORD *)&__src + 5 * v19) = 33;
    v19 += 2;
    *((_DWORD *)&__src + 5 * v24) = 34;
    if ((v22 & 4) == 0)
      goto LABEL_37;
LABEL_35:
    if ((v18 - 6) <= 0xFFFFFFFD)
    {
      v25 = 20 * v19++;
      *(_DWORD *)((char *)&__src + v25) = 9;
    }
LABEL_37:
    if ((v22 & 8) != 0)
    {
      v28 = 20 * v19++;
      *(_DWORD *)((char *)&__src + v28) = 12;
      if ((v22 & 0x10) == 0)
      {
LABEL_39:
        if ((v22 & 0x20) == 0)
          goto LABEL_40;
        goto LABEL_49;
      }
    }
    else if ((v22 & 0x10) == 0)
    {
      goto LABEL_39;
    }
    v29 = v19 + 1;
    *((_DWORD *)&__src + 5 * v19) = 10;
    v19 += 2;
    *((_DWORD *)&__src + 5 * v29) = 11;
    if ((v22 & 0x20) == 0)
    {
LABEL_40:
      if ((v22 & 0x40) != 0)
        goto LABEL_50;
      goto LABEL_41;
    }
LABEL_49:
    v30 = v19 + 1;
    *((_DWORD *)&__src + 5 * v19) = 35;
    v19 += 2;
    *((_DWORD *)&__src + 5 * v30) = 36;
    if ((v22 & 0x40) != 0)
    {
LABEL_50:
      v31 = v19 + 1;
      *((_DWORD *)&__src + 5 * v19) = 13;
      v19 += 2;
      *((_DWORD *)&__src + 5 * v31) = 15;
      if ((v22 & 0x80) == 0)
        goto LABEL_42;
      goto LABEL_51;
    }
LABEL_41:
    if ((v22 & 0x80) == 0)
      goto LABEL_42;
LABEL_51:
    v32 = 20 * v19++;
    *(_DWORD *)((char *)&__src + v32) = 14;
LABEL_42:
    v12 += 4;
    if ((v21 & 1) != 0)
    {
      v26 = 20 * v19++;
      *(_DWORD *)((char *)&__src + v26) = 37;
    }
  }
  while (v8++ < v11);
  if (a4 && a5)
  {
    v37 = 4;
    v38 = 0;
    v33 = 20 * v19 + 12;
    v34 = malloc_type_calloc(1uLL, v33, 0xD3CA3F14uLL);
    *v34 = 0;
    v34[2] = v19;
    memcpy(v34 + 3, &__src, 20 * v19);
    if (!AudioToolbox_AudioFormatGetProperty(1668116596, v33, (uint64_t)v34, (uint64_t)&v37, (uint64_t)&v38))
    {
      free(v34);
      v33 = 32;
      v34 = malloc_type_calloc(1uLL, 0x20uLL, 0x99CAEB3DuLL);
      *v34 = v38;
      v34[2] = 0;
    }
    *a5 = v33;
    *a4 = v34;
  }
  result = 0;
  if (a3)
  {
    *(double *)a3 = v13;
    *(_QWORD *)(a3 + 8) = 1700998451;
    *(_QWORD *)(a3 + 16) = 0x60000000000;
    *(_DWORD *)(a3 + 24) = 0;
    *(_DWORD *)(a3 + 28) = v19;
    *(_QWORD *)(a3 + 32) = v39;
  }
  return result;
}

_DWORD *figSoundBridge_GetAudioChannelCountFromLayout(_DWORD *result)
{
  unsigned int v1;
  BOOL v2;

  if (result)
  {
    if (*result == 0x10000)
    {
      v1 = result[1];
      if (v1)
      {
        LODWORD(result) = 0;
        do
        {
          result = (_DWORD *)((v1 & 1) + result);
          v2 = v1 >= 2;
          v1 >>= 1;
        }
        while (v2);
      }
      else
      {
        return 0;
      }
    }
    else if (*result)
    {
      return (_DWORD *)(unsigned __int16)*result;
    }
    else
    {
      return (_DWORD *)result[2];
    }
  }
  return result;
}

OSStatus CMAudioFormatDescriptionCopyAsBigEndianSoundDescriptionBlockBuffer(CFAllocatorRef allocator, CMAudioFormatDescriptionRef audioFormatDescription, CMSoundDescriptionFlavor flavor, CMBlockBufferRef *blockBufferOut)
{
  CFTypeID TypeID;
  int v9;
  uint64_t v10;
  signed int MediaSubType;
  int v13;
  unsigned __int16 v14;
  CFStringRef *v15;
  const __CFData *Extension;
  const __CFData *v17;
  CFTypeID v18;
  size_t Length;
  const UInt8 *BytePtr;
  const UInt8 *v21;
  OSStatus DataPointer;
  uint64_t v23;
  const AudioFormatListItem *MostCompatibleFormatAndChannelLayout;
  uint64_t v25;
  const void *MagicCookie;
  OSStatus Contiguous;
  const AudioChannelLayout *ChannelLayout;
  size_t DataLength;
  int IsRangeContiguous;
  OpaqueCMBlockBuffer *v31;
  char *dataPointerOut;
  size_t totalLengthOut;
  size_t sizeOut;
  CMBlockBufferRef theBuffer;

  sizeOut = 0;
  theBuffer = 0;
  if (!audioFormatDescription)
  {
    v10 = 4294954584;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  TypeID = CMFormatDescriptionGetTypeID();
  if (TypeID != CFGetTypeID(audioFormatDescription)
    || CMFormatDescriptionGetMediaType(audioFormatDescription) != 1936684398
    || !blockBufferOut)
  {
    v10 = 4294954584;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
  if (flavor)
  {
    if (CFEqual(flavor, CFSTR("ISOFamily")))
    {
      v9 = 1;
      LODWORD(flavor) = 1;
      goto LABEL_18;
    }
    if (CFEqual(flavor, CFSTR("QuickTimeMovieV2")))
    {
      v9 = 0;
      LODWORD(flavor) = 4;
      goto LABEL_18;
    }
    if (CFEqual(flavor, CFSTR("3GPFamily")))
    {
      LODWORD(flavor) = 3;
      goto LABEL_17;
    }
    if (CFEqual(flavor, CFSTR("QuickTimeMovie")))
    {
      LODWORD(flavor) = 0;
      goto LABEL_17;
    }
    v10 = 4294954579;
    return FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
  }
LABEL_17:
  v9 = 1;
LABEL_18:
  totalLengthOut = 0;
  MediaSubType = CMFormatDescriptionGetMediaSubType(audioFormatDescription);
  if (MediaSubType <= 1902324530)
  {
    if (MediaSubType > 1700998450)
    {
      if (MediaSubType != 1700998451 && MediaSubType != 1885547315)
      {
        v13 = 1885692723;
LABEL_30:
        if (MediaSubType != v13)
          goto LABEL_37;
      }
    }
    else if (MediaSubType != 1667574579 && MediaSubType != 1667575091)
    {
      v13 = 1700997939;
      goto LABEL_30;
    }
LABEL_46:
    if (CMAudioFormatDescriptionGetStreamBasicDescription(audioFormatDescription)->mFramesPerPacket == 1536)
      goto LABEL_37;
LABEL_47:
    v23 = 4294954579;
LABEL_53:
    Contiguous = FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
    goto LABEL_54;
  }
  if (MediaSubType > 1935767393)
  {
    if (MediaSubType == 2053464883 || MediaSubType == 2053319475)
      goto LABEL_46;
    v14 = 30562;
  }
  else
  {
    if (MediaSubType == 1902324531 || MediaSubType == 1902469939)
      goto LABEL_46;
    v14 = 28018;
  }
  if (MediaSubType == (v14 | 0x73610000) && (flavor & 3) == 1)
    goto LABEL_47;
LABEL_37:
  v15 = (CFStringRef *)&kCMFormatDescriptionExtension_VerbatimISOSampleEntry;
  if ((flavor & 1) == 0)
    v15 = (CFStringRef *)&kCMFormatDescriptionExtension_VerbatimSampleDescription;
  Extension = (const __CFData *)CMFormatDescriptionGetExtension(audioFormatDescription, *v15);
  if (Extension)
  {
    v17 = Extension;
    v18 = CFDataGetTypeID();
    if (v18 == CFGetTypeID(v17))
    {
      Length = CFDataGetLength(v17);
      BytePtr = CFDataGetBytePtr(v17);
      v21 = BytePtr;
      dataPointerOut = 0;
      if (((v9 | flavor) & 1) != 0 || *((_WORD *)BytePtr + 8) == 512)
      {
        DataPointer = CMBlockBufferCreateWithMemoryBlock(allocator, 0, Length, allocator, 0, 0, Length, 1u, &theBuffer);
        if (!DataPointer)
        {
          DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
          if (!DataPointer)
          {
            memcpy(dataPointerOut, v21, Length);
            *blockBufferOut = theBuffer;
            theBuffer = 0;
          }
        }
        goto LABEL_55;
      }
    }
  }
  MostCompatibleFormatAndChannelLayout = FigAudioFormatDescriptionGetMostCompatibleFormatAndChannelLayout(audioFormatDescription, 0, 0);
  if (!MostCompatibleFormatAndChannelLayout)
  {
    v23 = 4294954586;
    goto LABEL_53;
  }
  v25 = (uint64_t)MostCompatibleFormatAndChannelLayout;
  MagicCookie = CMAudioFormatDescriptionGetMagicCookie(audioFormatDescription, &sizeOut);
  if ((flavor & 1) != 0)
  {
    DataPointer = figSoundBridge_CreateNativeISOAudioSampleEntryFromASBD(v25, allocator, &theBuffer);
    if (DataPointer)
      goto LABEL_55;
    goto LABEL_64;
  }
  DataPointer = figSoundBridge_CreateNativeMovieSoundDescriptionFromASBD(v25, allocator, (char)flavor, (CFTypeRef *)&theBuffer);
  if (DataPointer)
  {
LABEL_55:
    if (theBuffer)
      CFRelease(theBuffer);
    return DataPointer;
  }
  if ((FigAudioFormatDescriptionGetCreationChannelLayoutSignificance((uint64_t)audioFormatDescription) & 0xFFFFFFFE) == 2)
  {
    dataPointerOut = 0;
    ChannelLayout = CMAudioFormatDescriptionGetChannelLayout(audioFormatDescription, (size_t *)&dataPointerOut);
    if (ChannelLayout)
    {
      if (dataPointerOut)
      {
        if (!((unint64_t)dataPointerOut >> 32))
        {
          Contiguous = figSoundBridge_AddChannelLayoutExtensionToNativeSoundDescriptionBBuf(theBuffer, allocator, ChannelLayout, dataPointerOut);
          if (Contiguous)
          {
LABEL_54:
            DataPointer = Contiguous;
            goto LABEL_55;
          }
        }
      }
    }
  }
LABEL_64:
  DataPointer = figSoundBridge_AddCookieExtensionToNativeSoundDescriptionBBuf(theBuffer, *(_DWORD *)(v25 + 8), allocator, (uint64_t)MagicCookie, sizeOut, (char)flavor);
  if (DataPointer)
    goto LABEL_55;
  if ((flavor & 1) != 0)
  {
    DataPointer = figSoundBridge_AddSamplingRateBoxIfNecessaryToNativeISOAudioSampleEntry(theBuffer, allocator, v25);
    if (DataPointer)
      goto LABEL_55;
    DataPointer = figSoundBridge_AddISOChannelLayoutBoxToNativeISOAudioSampleEntryIfEligible(theBuffer, allocator, audioFormatDescription);
    if (DataPointer)
      goto LABEL_55;
  }
  DataPointer = figSoundBridge_AddMiscellaneousSampleDescriptionExtensionsToNativeSoundDescriptionBBuf(theBuffer, audioFormatDescription, allocator);
  if (DataPointer)
    goto LABEL_55;
  DataLength = CMBlockBufferGetDataLength(theBuffer);
  totalLengthOut = DataLength;
  IsRangeContiguous = CMBlockBufferIsRangeContiguous(theBuffer, 0, DataLength);
  v31 = theBuffer;
  if (!IsRangeContiguous)
  {
    dataPointerOut = 0;
    Contiguous = CMBlockBufferCreateContiguous(allocator, theBuffer, allocator, 0, 0, DataLength, 0, (CMBlockBufferRef *)&dataPointerOut);
    if (!Contiguous)
    {
      if (theBuffer)
        CFRelease(theBuffer);
      v31 = (OpaqueCMBlockBuffer *)dataPointerOut;
      theBuffer = (CMBlockBufferRef)dataPointerOut;
      goto LABEL_70;
    }
    goto LABEL_54;
  }
LABEL_70:
  dataPointerOut = 0;
  totalLengthOut = 0;
  DataPointer = CMBlockBufferGetDataPointer(v31, 0, 0, &totalLengthOut, &dataPointerOut);
  if (DataPointer)
    goto LABEL_55;
  DataPointer = figSoundBridge_FlipSoundDescriptionData((uint64_t)dataPointerOut, totalLengthOut, 1);
  if (DataPointer)
    goto LABEL_55;
  *blockBufferOut = theBuffer;
  return DataPointer;
}

uint64_t figSoundBridge_CreateNativeISOAudioSampleEntryFromASBD(uint64_t a1, const __CFAllocator *a2, CMBlockBufferRef *a3)
{
  uint64_t v6;
  double v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  uint64_t PropertyInfo;
  void *v13;
  void *v14;
  uint64_t Property;
  unsigned int v16;
  int v17;
  BOOL v18;
  __int16 v19;
  int v20;
  int v21;
  int v22;
  size_t v23;
  size_t v24;
  uint64_t DataPointer;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *dataPointerOut;
  CMBlockBufferRef theBuffer;
  int v32;
  uint64_t v33;
  int v34;
  _DWORD size[3];

  v6 = 0;
  v7 = *(double *)a1;
  v8 = (*(double *)a1 * 65536.0 + 0.5);
  dataPointerOut = 0;
  theBuffer = 0;
  v9 = *(_DWORD *)(a1 + 8);
  v10 = *(_DWORD *)(a1 + 12);
  v11 = *(_DWORD *)(a1 + 28);
  do
  {
    if (v9 == figSoundBridge_CreateNativeISOAudioSampleEntryFromASBD_isoDenylist[v6])
      goto LABEL_60;
    ++v6;
  }
  while (v6 != 3);
  if (v9 == 1819304813)
  {
    size[0] = 0;
    PropertyInfo = AudioToolbox_AudioFormatGetPropertyInfo(1935962211, 40, a1, (uint64_t)size);
    if (!(_DWORD)PropertyInfo)
    {
      v13 = CFAllocatorAllocate(a2, size[0], 0);
      if (v13)
      {
        v14 = v13;
        Property = AudioToolbox_AudioFormatGetProperty(1935962211, 40, a1, (uint64_t)size, (uint64_t)v13);
        if (!(_DWORD)Property)
        {
          v16 = size[0];
          goto LABEL_9;
        }
        v28 = FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0);
        if ((_DWORD)v28)
        {
          DataPointer = v28;
LABEL_47:
          CFAllocatorDeallocate(a2, v14);
          goto LABEL_61;
        }
LABEL_57:
        v14 = 0;
        v16 = 0;
LABEL_9:
        if ((v10 & 1) != 0)
          v17 = 1718641517;
        else
          v17 = 1768973165;
LABEL_12:
        v18 = v7 < 65536.0;
        v19 = v7 >= 65536.0;
        goto LABEL_34;
      }
      PropertyInfo = 4294954583;
    }
    DataPointer = FigSignalErrorAt(PropertyInfo, 0, 0, 0, 0, 0, 0);
    if ((_DWORD)DataPointer)
      goto LABEL_61;
    goto LABEL_57;
  }
  v20 = translateMP4AFormatID(*(_DWORD *)(a1 + 8));
  if (v9 == 1718378851)
  {
    v17 = 1716281667;
    goto LABEL_33;
  }
  v17 = v20;
  if (v20 > 1718641516)
  {
    if (v20 > 1836069984)
    {
      if (v20 == 1836069985 || v20 == 1935764850)
        goto LABEL_31;
      v21 = 1935767394;
    }
    else
    {
      if (v20 == 1718641517 || v20 == 1768973165)
        goto LABEL_31;
      v21 = 1832149349;
    }
  }
  else if (v20 > 1700998450)
  {
    if (v20 == 1700998451 || v20 == 1701733217)
      goto LABEL_31;
    v21 = 1716281667;
  }
  else
  {
    if (v20 == 1633889587 || v20 == 1634492771)
      goto LABEL_31;
    v21 = 1685220723;
  }
  if (v20 != v21)
  {
    v34 = 0;
    size[0] = v20;
    *(_QWORD *)&size[1] = 0x6D70346600000000;
    v33 = 0;
    v32 = 0;
    if (!AudioToolbox_AudioFormatGetPropertyInfo(1668180324, 12, (uint64_t)size, (uint64_t)&v32))
    {
      if (v32 == 12)
      {
        v27 = AudioToolbox_AudioFormatGetProperty(1668180324, 12, (uint64_t)size, (uint64_t)&v32, (uint64_t)&v33);
        if (!(_DWORD)v27)
        {
          v17 = v34;
          goto LABEL_31;
        }
      }
      else
      {
        v27 = 4294954584;
      }
      if (!FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0))
        goto LABEL_31;
    }
LABEL_60:
    DataPointer = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
    goto LABEL_61;
  }
LABEL_31:
  v14 = 0;
  v16 = 0;
  if (v17 == 1768973165 || v17 == 1718641517)
    goto LABEL_12;
LABEL_33:
  v18 = v7 < 65536.0;
  v16 = 0;
  v14 = 0;
  v19 = 0;
LABEL_34:
  if (v18)
    v22 = v8;
  else
    v22 = 0x10000;
  v23 = v16;
  v24 = v16 + 36;
  DataPointer = CMBlockBufferCreateWithMemoryBlock(a2, 0, v24, a2, 0, 0, v24, 1u, &theBuffer);
  if (!(_DWORD)DataPointer)
  {
    DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
    if (!(_DWORD)DataPointer)
    {
      v26 = dataPointerOut;
      *(_DWORD *)dataPointerOut = v24;
      *((_DWORD *)v26 + 1) = v17;
      *((_QWORD *)v26 + 1) = 0xFFFF000000000000;
      *((_WORD *)v26 + 8) = v19;
      *((_WORD *)v26 + 9) = 0;
      *((_DWORD *)v26 + 5) = 0;
      if (v17 != 1768973165 && v17 != 1718641517)
        LOWORD(v11) = 2;
      *((_WORD *)v26 + 12) = v11;
      *(_DWORD *)(v26 + 26) = 16;
      *((_WORD *)v26 + 15) = 0;
      *((_DWORD *)v26 + 8) = v22;
      if ((_DWORD)v23 && v14)
        memcpy(v26 + 36, v14, v23);
      DataPointer = 0;
      *a3 = theBuffer;
      theBuffer = 0;
    }
  }
  if (v14)
    goto LABEL_47;
LABEL_61:
  if (theBuffer)
    CFRelease(theBuffer);
  return DataPointer;
}

uint64_t figSoundBridge_CreateNativeMovieSoundDescriptionFromASBD(uint64_t a1, CFAllocatorRef structureAllocator, char a3, CFTypeRef *a4)
{
  double v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  uint64_t DataPointer;
  int v17;
  int v18;
  __int16 v19;
  size_t v20;
  char *v21;
  int v22;
  int v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  OpaqueCMBlockBuffer *v30;
  char *v31;
  unsigned int v32;
  int v33;
  int v34;
  __int16 v35;
  unsigned int v36;
  int v37;
  __int16 v38;
  int v39;
  char *v40;
  CMBlockBufferRef theBuffer;
  CFTypeRef cf;
  char *dataPointerOut;

  cf = 0;
  dataPointerOut = 0;
  if (!a4)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v6 = *(double *)a1;
  v7 = *(_DWORD *)(a1 + 8);
  v8 = *(_DWORD *)(a1 + 12);
  v9 = *(_DWORD *)(a1 + 16);
  v10 = *(_DWORD *)(a1 + 20);
  v11 = *(_DWORD *)(a1 + 24);
  v12 = *(_DWORD *)(a1 + 28);
  v13 = *(_DWORD *)(a1 + 32);
  *a4 = 0;
  if (v7 <= 1768829491)
  {
    if (v7 > 1718367025)
    {
      if (v7 == 1718367026)
        goto LABEL_16;
      v14 = 1718367796;
    }
    else
    {
      if (!v7)
        goto LABEL_16;
      v14 = 1313820229;
    }
  }
  else if (v7 <= 1918990111)
  {
    if (v7 == 1768829492)
      goto LABEL_16;
    v14 = 1768829746;
  }
  else
  {
    if (v7 == 1918990112 || v7 == 1953984371)
      goto LABEL_16;
    v14 = 1936684916;
  }
  if (v7 == v14 || !v12)
    goto LABEL_16;
  if (v7 == 1819304813)
  {
    if (v11 && v13 && v9 && v10 == 1)
    {
      if (!(v8 & 8 | v13 & 7) && v9 == (v13 >> 3) * v12)
        v8 |= 8u;
      goto LABEL_29;
    }
LABEL_16:
    DataPointer = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    goto LABEL_17;
  }
LABEL_29:
  if ((a3 & 5) == 4 || v6 >= 65536.0 || v12 > 2)
    goto LABEL_44;
  if (v7 != 1819304813)
  {
    if (v7 != 1718378851 && v7 != 1634492771 || (v8 & 6) == 0)
      goto LABEL_60;
    goto LABEL_44;
  }
  if (!v13 || (v13 & 7) != 0 || (v8 & 8) == 0 || v8 > 0xF)
    goto LABEL_44;
  if ((v8 & 1) == 0)
  {
    if ((v8 & 4) != 0)
    {
      HIDWORD(v24) = v13;
      LODWORD(v24) = v13 - 8;
      if ((v24 >> 3) < 4)
      {
LABEL_60:
        v18 = 0;
        v19 = 1;
        v20 = 52;
        goto LABEL_61;
      }
    }
    else if (v13 == 8)
    {
      goto LABEL_60;
    }
    goto LABEL_44;
  }
  v18 = 0;
  v19 = 1;
  v20 = 52;
  if (v13 == 32)
  {
LABEL_61:
    v17 = 1;
    goto LABEL_45;
  }
  v17 = 1;
  if (v13 != 64)
  {
LABEL_44:
    v17 = 0;
    v18 = 1;
    v19 = 2;
    v20 = 72;
  }
LABEL_45:
  v37 = v17;
  v38 = v19;
  v39 = v18;
  DataPointer = CMBlockBufferCreateWithMemoryBlock(structureAllocator, 0, v20, structureAllocator, 0, 0, v20, 1u, (CMBlockBufferRef *)&cf);
  if ((_DWORD)DataPointer)
    goto LABEL_17;
  DataPointer = CMBlockBufferGetDataPointer((CMBlockBufferRef)cf, 0, 0, 0, &dataPointerOut);
  if ((_DWORD)DataPointer)
    goto LABEL_17;
  bzero(dataPointerOut, v20);
  v21 = dataPointerOut;
  *(_DWORD *)dataPointerOut = v20;
  *((_WORD *)v21 + 8) = v38;
  *((_WORD *)v21 + 7) = -1;
  v22 = translateMP4AFormatID(v7);
  if (!v39)
  {
    if (!v37)
      goto LABEL_98;
    if (v22 != 1819304813)
    {
      *((_DWORD *)v21 + 1) = v22;
      goto LABEL_88;
    }
    if ((v8 & 1) == 0)
    {
      v23 = 1768829492;
      if (v13 != 24)
      {
        if (v13 != 32)
        {
          if ((v8 & 4) != 0)
          {
            if ((v8 & 2) != 0)
              v27 = 1953984371;
            else
              v27 = 1936684916;
          }
          else
          {
            v27 = 1918990112;
          }
          *((_DWORD *)v21 + 1) = v27;
          goto LABEL_88;
        }
        v23 = 1768829746;
      }
      goto LABEL_65;
    }
    v23 = 1718367026;
    if (v13 == 32)
    {
LABEL_65:
      *((_DWORD *)v21 + 1) = v23;
      goto LABEL_66;
    }
    if (v13 == 64)
    {
      v23 = 1718367796;
      goto LABEL_65;
    }
    v28 = *((_DWORD *)v21 + 1);
    if (v28 > 1768829491)
    {
      if (v28 == 1768829746)
        goto LABEL_66;
      v29 = 1768829492;
    }
    else
    {
      if (v28 == 1718367026)
        goto LABEL_66;
      v29 = 1718367796;
    }
    if (v28 != v29)
      goto LABEL_88;
LABEL_66:
    if ((v8 & 2) != 0)
      goto LABEL_88;
    v25 = v21;
    v40 = 0;
    theBuffer = 0;
    DataPointer = CMBlockBufferCreateWithMemoryBlock(structureAllocator, 0, 0x26uLL, structureAllocator, 0, 0, 0x26uLL, 1u, &theBuffer);
    if (!(_DWORD)DataPointer)
    {
      v26 = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &v40);
      if ((_DWORD)v26)
      {
        DataPointer = v26;
        if (theBuffer)
          CFRelease(theBuffer);
        goto LABEL_17;
      }
      v31 = v40;
      v30 = theBuffer;
      *(_OWORD *)v40 = xmmword_18EDDD240;
      v32 = bswap32(*((_DWORD *)v25 + 1));
      *(_QWORD *)(v31 + 30) = 0x8000000;
      v31 += 30;
      *(_DWORD *)(v31 - 14) = v32;
      *(_QWORD *)(v31 - 10) = 0x61646E650A000000;
      *((_WORD *)v31 - 1) = 256;
      v40 = v31;
      DataPointer = CMBlockBufferAppendBufferReference((CMBlockBufferRef)cf, v30, 0, 0x26uLL, 0);
      if (theBuffer)
        CFRelease(theBuffer);
      if ((_DWORD)DataPointer)
        goto LABEL_17;
      v21 = v25;
      *(_DWORD *)v25 += 38;
LABEL_88:
      *((_WORD *)v21 + 12) = v12;
      if ((unsigned __int16)v13 == 8)
        v33 = v13;
      else
        v33 = 16;
      *((_WORD *)v21 + 13) = v33;
      *((_DWORD *)v21 + 8) = (v6 * 65536.0 + 0.5);
      *((_DWORD *)v21 + 9) = v10;
      v34 = (int)((v33 + (((__int16)v33 >> 28) & 7)) << 16) >> 19;
      if (v9)
        v35 = -1;
      else
        v35 = -2;
      if (v9)
        v36 = v9;
      else
        v36 = 2;
      *((_WORD *)v21 + 14) = v35;
      *((_DWORD *)v21 + 11) = v36;
      *((_DWORD *)v21 + 12) = v34;
      *((_DWORD *)v21 + 10) = v36 / v12;
      goto LABEL_98;
    }
LABEL_17:
    if (cf)
      CFRelease(cf);
    return DataPointer;
  }
  *((_QWORD *)v21 + 3) = 0xFFFE00100003;
  *((_DWORD *)v21 + 1) = v22;
  *((_DWORD *)v21 + 8) = 0x10000;
  *((_DWORD *)v21 + 9) = v20;
  *((double *)v21 + 5) = v6;
  *((_DWORD *)v21 + 12) = v12;
  *((_DWORD *)v21 + 13) = 2130706432;
  *((_DWORD *)v21 + 14) = v13;
  *((_DWORD *)v21 + 15) = v8;
  *((_DWORD *)v21 + 16) = v9;
  *((_DWORD *)v21 + 17) = v10;
LABEL_98:
  DataPointer = 0;
  *a4 = cf;
  return DataPointer;
}

uint64_t figSoundBridge_AddChannelLayoutExtensionToNativeSoundDescriptionBBuf(OpaqueCMBlockBuffer *a1, const __CFAllocator *a2, const void *a3, unsigned int a4)
{
  uint64_t DataPointer;
  unsigned int v10;
  char *v11;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  char *v14;
  CFTypeRef cf;

  v14 = 0;
  cf = 0;
  if (!a1)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  lengthAtOffsetOut = 0;
  dataPointerOut = 0;
  DataPointer = CMBlockBufferGetDataPointer(a1, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
  if ((_DWORD)DataPointer)
    goto LABEL_3;
  if (lengthAtOffsetOut >= 4)
  {
    v10 = a4 + 12;
    DataPointer = CMBlockBufferCreateWithMemoryBlock(a2, 0, a4 + 12, a2, 0, 0, a4 + 12, 1u, (CMBlockBufferRef *)&cf);
    if (!(_DWORD)DataPointer)
    {
      DataPointer = CMBlockBufferGetDataPointer((CMBlockBufferRef)cf, 0, 0, 0, &v14);
      if (!(_DWORD)DataPointer)
      {
        *(_DWORD *)v14 = bswap32(v10);
        v11 = v14;
        v14 += 4;
        *((_DWORD *)v11 + 1) = 1851877475;
        v14 += 4;
        *(_DWORD *)v14 = 0;
        v14 += 4;
        memcpy(v14, a3, a4);
        DataPointer = figSoundBridge_EndianAudioChannelLayout_NtoB((int8x8_t *)v14, a4);
        if (!(_DWORD)DataPointer)
        {
          DataPointer = CMBlockBufferAppendBufferReference(a1, (CMBlockBufferRef)cf, 0, a4 + 12, 0);
          if (!(_DWORD)DataPointer)
            *(_DWORD *)dataPointerOut += v10;
        }
      }
    }
LABEL_3:
    if (cf)
      CFRelease(cf);
    return DataPointer;
  }
  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t figSoundBridge_AddCookieExtensionToNativeSoundDescriptionBBuf(CMBlockBufferRef theBuffer, int a2, const __CFAllocator *a3, uint64_t a4, unsigned int a5, char a6)
{
  _BOOL4 v6;
  uint64_t DataPointer;
  int v14;
  uint64_t v15;
  int v16;
  const __CFAllocator *v17;
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  size_t v23;
  char *v24;
  char *v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  unint64_t v30;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  char *v33;
  unsigned int __n[3];
  CFTypeRef cf;

  *(_QWORD *)&__n[1] = a4;
  cf = 0;
  __n[0] = a5;
  v6 = (a6 & 1) == 0;
  if (!theBuffer || !a4 && a5)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (!a5)
  {
    DataPointer = 0;
LABEL_11:
    if (cf)
      CFRelease(cf);
    return DataPointer;
  }
  dataPointerOut = 0;
  v33 = 0;
  lengthAtOffsetOut = 0;
  DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
  if ((_DWORD)DataPointer)
  {
LABEL_7:
    if (*(_QWORD *)&__n[1] && *(_QWORD *)&__n[1] != a4)
      CFAllocatorDeallocate(a3, *(void **)&__n[1]);
    goto LABEL_11;
  }
  if (lengthAtOffsetOut >= 4)
  {
    v14 = translateMP4AFormatID(a2);
    if (v14 == 1836069985 || v14 == 1832149349)
    {
      v15 = *(_QWORD *)&__n[1];
      v16 = __n[0];
      v17 = a3;
      v18 = a2;
      v19 = 0;
LABEL_21:
      v20 = figSoundBridge_ConvertMP4AESDSMagicCookieToSoundDescriptionExtension(v17, v18, v19, v15, v16, a6, (char **)&__n[1], __n);
      goto LABEL_22;
    }
    if (figSoundBridge_isProtectedMP4AFormatUsingESDS(a2))
    {
      v15 = *(_QWORD *)&__n[1];
      v16 = __n[0];
      v17 = a3;
      v18 = a2;
      v19 = 1;
      goto LABEL_21;
    }
    if (a2 > 1902537826)
    {
      if (a2 > 1935764849)
      {
        if (a2 == 1935764850 || a2 == 1935767394)
        {
          v20 = figSoundBridge_ConvertAMRMagicCookieToSoundDescriptionExtension(a3, a2, *(_DWORD **)&__n[1], __n[0], a6, &__n[1], __n);
LABEL_22:
          DataPointer = v20;
          v21 = v6;
          if ((_DWORD)v20)
            goto LABEL_7;
          goto LABEL_23;
        }
        v26 = 2053923171;
        goto LABEL_40;
      }
      if (a2 != 1902537827)
      {
        v26 = 1902928227;
LABEL_40:
        if (a2 != v26)
        {
LABEL_51:
          if (FigAudioCodecTypeIsAC3(a2))
            goto LABEL_52;
          if (a2 <= 1885692722)
          {
            if (a2 == 1667575091)
              goto LABEL_52;
            v28 = 1700998451;
          }
          else
          {
            if (a2 == 1885692723 || a2 == 1902469939)
              goto LABEL_52;
            v28 = 2053464883;
          }
          if (a2 != v28)
          {
            v29 = figSoundBridge_EncapsulatedMagicCookieFromCanonicalMagicCookie(a3, a2, a6, *(uint64_t *)&__n[1], __n[0], &__n[1], __n);
            if ((_DWORD)v29)
            {
              if ((a6 & 1) != 0)
              {
                v21 = 0;
                if (a2 != 1634754915 && a2 != 1667330147)
                {
                  DataPointer = v29;
                  if (a2 != 1902211171)
                    goto LABEL_7;
                }
              }
              else
              {
                v21 = 1;
              }
LABEL_23:
              v22 = __n[0] + 8;
              if (v21)
                v23 = __n[0] + 8;
              else
                v23 = __n[0];
              DataPointer = CMBlockBufferCreateWithMemoryBlock(a3, 0, v23, a3, 0, 0, v23, 1u, (CMBlockBufferRef *)&cf);
              if (!(_DWORD)DataPointer)
              {
                DataPointer = CMBlockBufferGetDataPointer((CMBlockBufferRef)cf, 0, 0, 0, &v33);
                if (!(_DWORD)DataPointer)
                {
                  if (v21)
                  {
                    *(_DWORD *)v33 = bswap32(v22);
                    v24 = v33;
                    v33 += 4;
                    *((_DWORD *)v24 + 1) = 1702257015;
                    v25 = v33 + 4;
                    v33 += 4;
                  }
                  else
                  {
                    v25 = v33;
                  }
                  memcpy(v25, *(const void **)&__n[1], __n[0]);
                  DataPointer = CMBlockBufferAppendBufferReference(theBuffer, (CMBlockBufferRef)cf, 0, v23, 0);
                  if (!(_DWORD)DataPointer)
                    *(_DWORD *)dataPointerOut += v23;
                }
              }
              goto LABEL_7;
            }
            v21 = 0;
            if (a2 == 1634754915 || a2 == 1667330147 || a2 == 1902211171)
              goto LABEL_23;
LABEL_54:
            v21 = v6;
            goto LABEL_23;
          }
LABEL_52:
          v30 = 0;
          figSoundBridge_AreAtomsWellFormed(*(uint64_t *)&__n[1], __n[0], v6, &v30);
          if (v30 < __n[0])
            __n[0] = v30;
          goto LABEL_54;
        }
        goto LABEL_46;
      }
LABEL_45:
      v20 = figSoundBridge_ConvertFLACMagicCookieToSoundDescriptionExtension(a3, *(unsigned int **)&__n[1], __n[0], (unsigned int **)&__n[1], __n);
      goto LABEL_22;
    }
    if (a2 > 1668047202)
    {
      if (a2 != 1668047203)
      {
        v27 = 1718378851;
LABEL_44:
        if (a2 != v27)
          goto LABEL_51;
        goto LABEL_45;
      }
    }
    else if (a2 != 1634492771)
    {
      v27 = 1667656803;
      goto LABEL_44;
    }
LABEL_46:
    v20 = figSoundBridge_ConvertALACMagicCookieToSoundDescriptionExtension(a3, *(_DWORD **)&__n[1], __n[0], a6, &__n[1], __n);
    goto LABEL_22;
  }
  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t figSoundBridge_AddSamplingRateBoxIfNecessaryToNativeISOAudioSampleEntry(OpaqueCMBlockBuffer *a1, const __CFAllocator *a2, uint64_t a3)
{
  uint64_t DataPointer;
  char *v8;
  char *v9;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  char *v12;
  CFTypeRef cf;

  v12 = 0;
  cf = 0;
  if (a1)
  {
    if (*(double *)a3 < 65536.0 || *(_DWORD *)(a3 + 8) != 1819304813)
      return 0;
    lengthAtOffsetOut = 0;
    dataPointerOut = 0;
    DataPointer = CMBlockBufferGetDataPointer(a1, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
    if ((_DWORD)DataPointer)
    {
LABEL_5:
      if (cf)
        CFRelease(cf);
      return DataPointer;
    }
    if (lengthAtOffsetOut >= 4)
    {
      DataPointer = CMBlockBufferCreateWithMemoryBlock(a2, 0, 0x10uLL, a2, 0, 0, 0x10uLL, 1u, (CMBlockBufferRef *)&cf);
      if (!(_DWORD)DataPointer)
      {
        DataPointer = CMBlockBufferGetDataPointer((CMBlockBufferRef)cf, 0, 0, 0, &v12);
        if (!(_DWORD)DataPointer)
        {
          *(_DWORD *)v12 = 0x10000000;
          v8 = v12;
          v12 += 4;
          *((_DWORD *)v8 + 1) = 1952543347;
          v12 += 4;
          *(_DWORD *)v12 = 0;
          v9 = v12;
          v12 += 4;
          *((_DWORD *)v9 + 1) = bswap32(*(double *)a3);
          DataPointer = CMBlockBufferAppendBufferReference(a1, (CMBlockBufferRef)cf, 0, 0x10uLL, 0);
          if (!(_DWORD)DataPointer)
            *(_DWORD *)dataPointerOut += 16;
        }
      }
      goto LABEL_5;
    }
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t figSoundBridge_AddISOChannelLayoutBoxToNativeISOAudioSampleEntryIfEligible(OpaqueCMBlockBuffer *a1, const __CFAllocator *a2, CMFormatDescriptionRef desc)
{
  CFPropertyListRef Extension;
  uint64_t appended;
  CFTypeID v8;
  const AudioStreamBasicDescription *StreamBasicDescription;
  uint64_t RichestDecodableFormatAndChannelLayout;
  int v11;
  CFTypeID v12;
  uint64_t v13;
  uint64_t DataPointer;
  _DWORD *v15;
  int CreationChannelLayoutSignificance;
  unint64_t v18;
  UInt32 mChannelsPerFrame;
  int v20;
  int v21;
  unsigned int v22;
  BOOL v23;
  BOOL v24;
  void *v27;
  void *v28;
  uint64_t Property;
  _OWORD v30[2];
  CFTypeRef cf;
  CFIndex size;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  _OWORD *v35;
  uint64_t v36;
  const AudioFormatListItem *v37;

  v36 = 0;
  v37 = 0;
  dataPointerOut = 0;
  v35 = 0;
  size = 0;
  lengthAtOffsetOut = 0;
  cf = 0;
  Extension = CMFormatDescriptionGetExtension(desc, CFSTR("SampleDescriptionExtensionAtoms"));
  appended = (uint64_t)Extension;
  if (Extension)
  {
    v8 = CFGetTypeID(Extension);
    if (v8 == CFDictionaryGetTypeID())
    {
      if (CFDictionaryGetValue((CFDictionaryRef)appended, CFSTR("chnl")))
        goto LABEL_52;
    }
  }
  StreamBasicDescription = CMAudioFormatDescriptionGetStreamBasicDescription(desc);
  if (StreamBasicDescription->mFormatID == 1819304813 && StreamBasicDescription->mChannelsPerFrame >= 2)
  {
    RichestDecodableFormatAndChannelLayout = CMAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout(desc, &v37, &v36, &v35);
    if ((_DWORD)RichestDecodableFormatAndChannelLayout)
      goto LABEL_64;
    v11 = 1;
  }
  else
  {
    if (!appended)
      goto LABEL_53;
    v12 = CFGetTypeID((CFTypeRef)appended);
    if (v12 != CFDictionaryGetTypeID())
      goto LABEL_52;
    v13 = 0;
    while (!CFDictionaryGetValue((CFDictionaryRef)appended, *(const void **)((char *)&off_1E28DD348 + v13)))
    {
      v13 += 8;
      if (v13 == 48)
        goto LABEL_52;
    }
    v11 = 0;
    if (CMAudioFormatDescriptionGetRichestDecodableFormatAndChannelLayout(desc, &v37, &v36, &v35))
      goto LABEL_52;
  }
  if (!a1)
    goto LABEL_62;
  DataPointer = CMBlockBufferGetDataPointer(a1, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
  if ((_DWORD)DataPointer)
  {
LABEL_65:
    appended = DataPointer;
    goto LABEL_53;
  }
  if (lengthAtOffsetOut <= 0x23)
  {
LABEL_62:
    RichestDecodableFormatAndChannelLayout = 4294954584;
    goto LABEL_64;
  }
  v15 = v35;
  if (v37->mASBD.mFormatID != 1819304813 || v35 == 0)
  {
    CreationChannelLayoutSignificance = FigAudioFormatDescriptionGetCreationChannelLayoutSignificance((uint64_t)desc);
    v15 = v35;
  }
  else
  {
    CreationChannelLayoutSignificance = 2;
  }
  memset(v30, 0, sizeof(v30));
  v18 = v36;
  if (v15 && v36)
    goto LABEL_31;
  mChannelsPerFrame = v37->mASBD.mChannelsPerFrame;
  if (mChannelsPerFrame == 1)
  {
    v20 = 6553601;
  }
  else
  {
    if (mChannelsPerFrame != 2)
      goto LABEL_31;
    v20 = 6619138;
  }
  LODWORD(v30[0]) = v20;
  v15 = v30;
  v35 = v30;
  v18 = 32;
  v36 = 32;
  CreationChannelLayoutSignificance = 2;
LABEL_31:
  if (!v15 || v18 < 4 || HIDWORD(v18))
    goto LABEL_51;
  if (*v15 == 0x10000)
  {
    v22 = v15[1];
    if (v22)
    {
      v21 = 0;
      do
      {
        v21 += v22 & 1;
        v23 = v22 >= 2;
        v22 >>= 1;
      }
      while (v23);
    }
    else
    {
      v21 = 0;
    }
  }
  else
  {
    v21 = *v15 ? (unsigned __int16)*v15 : v15[2];
  }
  v24 = v21 != v37->mASBD.mChannelsPerFrame || CreationChannelLayoutSignificance == 3;
  if (v24 || CreationChannelLayoutSignificance == 0)
  {
LABEL_51:
    if (!v11)
      goto LABEL_52;
    RichestDecodableFormatAndChannelLayout = 4294954586;
LABEL_64:
    DataPointer = FigSignalErrorAt(RichestDecodableFormatAndChannelLayout, 0, 0, 0, 0, 0, 0);
    goto LABEL_65;
  }
  RichestDecodableFormatAndChannelLayout = AudioToolbox_AudioFormatGetPropertyInfo(1668047726, v18, (uint64_t)v15, (uint64_t)&size + 4);
  if ((_DWORD)RichestDecodableFormatAndChannelLayout)
  {
    if ((_DWORD)RichestDecodableFormatAndChannelLayout != 1886547824)
      goto LABEL_64;
LABEL_52:
    appended = 0;
    goto LABEL_53;
  }
  v27 = CFAllocatorAllocate(a2, HIDWORD(size), 0);
  if (!v27)
  {
    RichestDecodableFormatAndChannelLayout = 4294954583;
    goto LABEL_64;
  }
  v28 = v27;
  LODWORD(size) = HIDWORD(size);
  Property = AudioToolbox_AudioFormatGetProperty(1668047726, v36, (uint64_t)v35, (uint64_t)&size, (uint64_t)v27);
  if ((_DWORD)Property
    || (Property = CMBlockBufferCreateWithMemoryBlock(a2, v28, HIDWORD(size), a2, 0, 0, size, 0, (CMBlockBufferRef *)&cf), (_DWORD)Property))
  {
    appended = FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0);
    CFAllocatorDeallocate(a2, v28);
  }
  else
  {
    appended = CMBlockBufferAppendBufferReference(a1, (CMBlockBufferRef)cf, 0, size, 0);
    if (!(_DWORD)appended)
      *(_DWORD *)dataPointerOut += size;
  }
LABEL_53:
  if (cf)
    CFRelease(cf);
  return appended;
}

uint64_t figSoundBridge_AddMiscellaneousSampleDescriptionExtensionsToNativeSoundDescriptionBBuf(OpaqueCMBlockBuffer *a1, const opaqueCMFormatDescription *a2, const __CFAllocator *a3)
{
  uint64_t DataPointer;
  size_t v7;
  char *v9;
  uint64_t v10;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  CFTypeRef cf;
  size_t v14;

  cf = 0;
  v14 = 0;
  DataPointer = figBridge_ConvertMiscellaneousSampleDescriptionExtensionsToAtoms(a2, &v14, 0);
  if (!(_DWORD)DataPointer)
  {
    v7 = v14;
    if (v14)
    {
      lengthAtOffsetOut = 0;
      dataPointerOut = 0;
      v9 = 0;
      DataPointer = CMBlockBufferGetDataPointer(a1, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
      if (!(_DWORD)DataPointer)
      {
        if (lengthAtOffsetOut < 4)
          return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        DataPointer = CMBlockBufferCreateWithMemoryBlock(a3, 0, v7, a3, 0, 0, v7, 1u, (CMBlockBufferRef *)&cf);
        if (!(_DWORD)DataPointer)
        {
          DataPointer = CMBlockBufferGetDataPointer((CMBlockBufferRef)cf, 0, 0, 0, &v9);
          if (!(_DWORD)DataPointer)
          {
            DataPointer = figBridge_ConvertMiscellaneousSampleDescriptionExtensionsToAtoms(a2, &v10, (uint64_t)v9);
            if (!(_DWORD)DataPointer)
            {
              DataPointer = CMBlockBufferAppendBufferReference(a1, (CMBlockBufferRef)cf, 0, v7, 0);
              if (!(_DWORD)DataPointer)
                *(_DWORD *)dataPointerOut += v7;
            }
          }
        }
      }
      if (cf)
        CFRelease(cf);
    }
  }
  return DataPointer;
}

OSStatus CMSwapHostEndianSoundDescriptionToBig(uint8_t *soundDescriptionData, size_t soundDescriptionSize)
{
  return figSoundBridge_FlipSoundDescriptionData((uint64_t)soundDescriptionData, soundDescriptionSize, 1);
}

Boolean CMDoesBigEndianSoundDescriptionRequireLegacyCBRSampleTableLayout(CMBlockBufferRef soundDescriptionBlockBuffer, CMSoundDescriptionFlavor flavor)
{
  int destination;

  destination = 0;
  if (CMBlockBufferCopyDataBytes(soundDescriptionBlockBuffer, 0x10uLL, 2uLL, (char *)&destination + 2))
    return 0;
  HIWORD(destination) = bswap32(HIWORD(destination)) >> 16;
  if (flavor)
  {
    if (!CFEqual(CFSTR("QuickTimeMovie"), flavor)
      && !CFEqual(CFSTR("QuickTimeMovieV2"), flavor)
      && (HIWORD(destination) != 1 || figSoundBridge_IsBlockBufferISOv1(soundDescriptionBlockBuffer, 1)))
    {
      return 0;
    }
  }
  if (CMBlockBufferCopyDataBytes(soundDescriptionBlockBuffer, 0x1CuLL, 2uLL, &destination))
    return 1;
  if (SHIWORD(destination) > 1)
    return 0;
  return (__int16)destination != -257;
}

OSStatus CMSwapBigEndianSoundDescriptionToHost(uint8_t *soundDescriptionData, size_t soundDescriptionSize)
{
  return figSoundBridge_FlipSoundDescriptionData((uint64_t)soundDescriptionData, soundDescriptionSize, 0);
}

uint64_t figSoundBridge_FlipSoundDescriptionData(uint64_t a1, unint64_t a2, int a3)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  int8x16_t v11;
  int8x8_t v12;
  unsigned int v13;
  int8x8_t v14;
  unsigned int v15;
  int8x8_t v16;
  unsigned int v17;
  unint64_t v18;
  int8x16_t v19;
  int8x8_t v20;

  if (!a1)
  {
    v9 = 4294954584;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  if (a2 <= 0x11)
    goto LABEL_16;
  v5 = *(unsigned __int16 *)(a1 + 16);
  v6 = bswap32(*(_DWORD *)a1);
  v7 = bswap32(v5) >> 16;
  if (a3)
  {
    v8 = *(_DWORD *)a1;
  }
  else
  {
    LOWORD(v5) = v7;
    v8 = v6;
  }
  if ((unsigned __int16)v5 >= 3u)
    goto LABEL_16;
  if ((unsigned __int16)v5 == 1)
    LOWORD(v5) = figSoundBridge_IsDataISOv1(a1, a2, a3 == 0) == 0;
  if ((int)v8 > a2
    || !(_WORD)v5 && v8 < 0x24
    || (unsigned __int16)v5 == 1 && v8 < 0x34
    || (unsigned __int16)v5 == 2 && v8 <= 0x47)
  {
LABEL_16:
    v9 = 4294954582;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  v11 = 0uLL;
  if ((unsigned __int16)v5 == 1)
    v11 = *(int8x16_t *)(a1 + 36);
  v12 = vrev32_s8(*(int8x8_t *)a1);
  v13 = bswap32(*(_DWORD *)(a1 + 8));
  v14 = vrev16_s8(*(int8x8_t *)(a1 + 12));
  v15 = bswap32(*(_DWORD *)(a1 + 20));
  v16 = vrev16_s8(*(int8x8_t *)(a1 + 24));
  v17 = bswap32(*(_DWORD *)(a1 + 32));
  if ((unsigned __int16)v5 == 1)
  {
    *(int8x8_t *)a1 = v12;
    *(_DWORD *)(a1 + 8) = v13;
    *(int8x8_t *)(a1 + 12) = v14;
    *(_DWORD *)(a1 + 20) = v15;
    *(int8x8_t *)(a1 + 24) = v16;
    *(_DWORD *)(a1 + 32) = v17;
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(v11);
  }
  else
  {
    *(int8x8_t *)a1 = v12;
    *(_DWORD *)(a1 + 8) = v13;
    *(int8x8_t *)(a1 + 12) = v14;
    *(_DWORD *)(a1 + 20) = v15;
    *(int8x8_t *)(a1 + 24) = v16;
    *(_DWORD *)(a1 + 32) = v17;
    if ((unsigned __int16)v5 == 2)
    {
      v18 = bswap64(*(_QWORD *)(a1 + 40));
      v19 = vrev32q_s8(*(int8x16_t *)(a1 + 48));
      v20 = vrev32_s8(*(int8x8_t *)(a1 + 64));
      *(_DWORD *)(a1 + 36) = bswap32(*(_DWORD *)(a1 + 36));
      *(_QWORD *)(a1 + 40) = v18;
      *(int8x16_t *)(a1 + 48) = v19;
      *(int8x8_t *)(a1 + 64) = v20;
    }
  }
  return 0;
}

uint64_t figSoundBridge_IsDataISOv1(uint64_t a1, unint64_t a2, int a3)
{
  _BOOL8 v3;
  signed int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  BOOL v14;
  _BOOL4 v15;
  _BOOL4 v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  int IsKnownAtomFoundInExtension;
  char v22;

  v3 = 0;
  if (a1 && a2 >= 0x24)
  {
    v6 = *(_DWORD *)a1;
    v7 = *(unsigned __int16 *)(a1 + 16);
    v8 = bswap32(*(_DWORD *)a1);
    v9 = bswap32(v7) >> 16;
    if (a3)
    {
      v6 = v8;
      LOWORD(v7) = v9;
    }
    v10 = v6;
    if (v6 < 0x24 || v6 > a2 || (unsigned __int16)v7 != 1)
      return 0;
    if (v6 == 36)
      return 1;
    v14 = 1;
    v15 = figSoundBridge_AreAtomsWellFormed(a1 + 36, v6 - 36, 1, 0);
    if (v10 >= 0x35)
    {
      v3 = 1;
      v16 = figSoundBridge_AreAtomsWellFormed(a1 + 52, v10 - 52, 1, 0);
      v14 = !v16;
      if (v15 && !v16)
        return v3;
      if (!v15 && v16)
        return 0;
    }
    v17 = *(_DWORD *)(a1 + 4);
    v18 = bswap32(v17);
    if (a3)
      v17 = v18;
    v3 = 1;
    if (v17 != 1716281667 && v17 != 1718641517 && v17 != 1768973165)
    {
      v19 = *(unsigned __int16 *)(a1 + 28);
      v20 = bswap32(v19) >> 16;
      if (a3)
        LOWORD(v19) = v20;
      if ((unsigned __int16)v19 > 0xFFFDu)
        return 0;
      if (!v15)
      {
        if (v14)
          return 0;
LABEL_36:
        figSoundBridge_IsKnownAtomFoundInExtension(a1 + 52, v10 - 52, 1);
        return 0;
      }
      IsKnownAtomFoundInExtension = figSoundBridge_IsKnownAtomFoundInExtension(a1 + 36, v10 - 36, 0);
      v3 = IsKnownAtomFoundInExtension != 0;
      if (IsKnownAtomFoundInExtension)
        v22 = 1;
      else
        v22 = v14;
      if ((v22 & 1) == 0)
        goto LABEL_36;
    }
  }
  return v3;
}

uint64_t figSoundBridge_IsBlockBufferISOv1(OpaqueCMBlockBuffer *a1, int a2)
{
  size_t DataLength;
  OpaqueCMBlockBuffer *v5;
  uint64_t IsDataISOv1;
  CMBlockBufferRef theBuffer;
  char *dataPointerOut;

  theBuffer = 0;
  dataPointerOut = 0;
  DataLength = CMBlockBufferGetDataLength(a1);
  if (CMBlockBufferIsRangeContiguous(a1, 0, 0))
  {
    v5 = a1;
  }
  else
  {
    if (CMBlockBufferCreateContiguous(0, a1, 0, 0, 0, 0, 0, &theBuffer))
      goto LABEL_10;
    v5 = theBuffer;
  }
  if (!CMBlockBufferGetDataPointer(v5, 0, 0, 0, &dataPointerOut))
  {
    IsDataISOv1 = figSoundBridge_IsDataISOv1((uint64_t)dataPointerOut, DataLength, a2);
    goto LABEL_7;
  }
LABEL_10:
  IsDataISOv1 = 0;
LABEL_7:
  if (theBuffer)
    CFRelease(theBuffer);
  return IsDataISOv1;
}

uint64_t FigAudioCodecTypeIsDecodable(int a1)
{
  uint64_t PropertyInfo;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  size_t size;

  LODWORD(size) = 0;
  PropertyInfo = AudioToolbox_AudioFormatGetPropertyInfo(1633904998, 0, 0, (uint64_t)&size);
  if ((_DWORD)PropertyInfo)
  {
    v3 = 0;
    goto LABEL_15;
  }
  if (size < 5)
  {
    v3 = 0;
    PropertyInfo = 0xFFFFFFFFLL;
    goto LABEL_15;
  }
  v3 = (char *)malloc_type_calloc(1uLL, size, 0x2EB930uLL);
  if (!v3)
  {
    PropertyInfo = 4294954585;
    goto LABEL_15;
  }
  PropertyInfo = AudioToolbox_AudioFormatGetProperty(1633904998, 0, 0, (uint64_t)&size, (uint64_t)v3);
  if ((_DWORD)PropertyInfo)
  {
LABEL_15:
    FigSignalErrorAt(PropertyInfo, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  if (size < 4)
  {
LABEL_9:
    v5 = 0;
    goto LABEL_11;
  }
  v4 = 0;
  while (*(_DWORD *)&v3[v4] != a1)
  {
    v4 += 4;
    if ((size & 0xFFFFFFFC) == v4)
      goto LABEL_9;
  }
  v5 = 1;
LABEL_11:
  free(v3);
  return v5;
}

uint64_t ReadESDSAtomAndData(uint64_t a1, CMBlockBufferRef *a2, CMBlockBufferRef *a3)
{
  uint64_t v5;
  size_t DataLength;
  size_t v7;
  const __CFAllocator *v8;
  _DWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  CMBlockBufferRef theBuffer;
  CMBlockBufferRef blockBufferOut;

  theBuffer = 0;
  blockBufferOut = 0;
  v5 = FigAtomStreamReadCurrentAtomDataAndCreateBBuf(a1, 4, 0, &theBuffer);
  if ((_DWORD)v5)
  {
    v12 = v5;
    v10 = 0;
  }
  else
  {
    DataLength = CMBlockBufferGetDataLength(theBuffer);
    v7 = DataLength + 8;
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE10];
    v9 = CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE10], DataLength + 8, 0);
    v10 = v9;
    if (v9)
    {
      *v9 = bswap32(v7);
      v9[1] = 1935962981;
      v11 = CMBlockBufferCopyDataBytes(theBuffer, 0, DataLength, v9 + 2);
      if ((_DWORD)v11)
      {
        v12 = v11;
      }
      else
      {
        v12 = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v10, v7, v8, 0, 0, v7, 0, &blockBufferOut);
        if (!(_DWORD)v12)
        {
          v10 = 0;
          *a2 = blockBufferOut;
          *a3 = theBuffer;
          theBuffer = 0;
          blockBufferOut = 0;
          goto LABEL_6;
        }
        if (blockBufferOut)
          CFRelease(blockBufferOut);
      }
    }
    else
    {
      v12 = 0;
    }
  }
  if (theBuffer)
    CFRelease(theBuffer);
LABEL_6:
  free(v10);
  return v12;
}

uint64_t figSoundBridge_GetDecodeFormatIDForUnknownExtensionType(int a1, uint64_t a2, _DWORD *a3)
{
  int v6;
  unsigned int v7;
  int v8;
  uint64_t Property;
  int v10;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;

  v6 = *(_DWORD *)(a2 + 4);
  if ((*(_BYTE *)a2 & 1) != 0 && (v7 = *(_DWORD *)(a2 + 12) - 1, v7 <= 2))
    v8 = dword_18EDDD2D4[v7];
  else
    v8 = 1299148630;
  v18 = v8;
  v19 = 4;
  v20 = v6;
  v16 = 0;
  v15 = 0;
  v17 = 0;
  if (!AudioToolbox_AudioFormatGetPropertyInfo(1701733230, 12, (uint64_t)&v18, (uint64_t)&v17))
  {
    if (v17 == 12)
    {
      Property = AudioToolbox_AudioFormatGetProperty(1701733230, 12, (uint64_t)&v18, (uint64_t)&v17, (uint64_t)&v15);
      if (!(_DWORD)Property)
      {
        v10 = v16;
        return v10 == a1 && !figSoundBridge_GetDecodeFormatIDForCodingName(v6, a2, a3);
      }
    }
    else
    {
      Property = 4294954584;
    }
    if (!FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0))
    {
      v10 = 0;
      return v10 == a1 && !figSoundBridge_GetDecodeFormatIDForCodingName(v6, a2, a3);
    }
  }
  if ((*(_BYTE *)a2 & 1) != 0 && (v12 = *(_DWORD *)(a2 + 12) - 1, v12 <= 2))
    v13 = dword_18EDDD2D4[v12];
  else
    v13 = 1299148630;
  v18 = v13;
  v19 = 4;
  v20 = a1;
  LODWORD(v15) = 0;
  v17 = 0;
  if (AudioToolbox_AudioFormatGetPropertyInfo(1768187246, 12, (uint64_t)&v18, (uint64_t)&v17))
    return 0;
  if (v17 == 4)
  {
    v14 = AudioToolbox_AudioFormatGetProperty(1768187246, 12, (uint64_t)&v18, (uint64_t)&v17, (uint64_t)&v15);
    if (!(_DWORD)v14)
    {
      *a3 = v15;
      return 1;
    }
  }
  else
  {
    v14 = 4294954584;
  }
  return !FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

uint64_t figSoundBridge_TransformToCanonicalMagicCookieBBuf(const __CFAllocator *a1, int a2, uint64_t a3, CMBlockBufferRef *a4)
{
  uint64_t DataPointer;
  unsigned int v9;
  int v10;
  void *v11;
  void *v12;
  uint64_t Property;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;
  CMBlockBufferRef blockBufferOut;
  unsigned int size;
  CFIndex size_4;
  char *v24;
  uint64_t v25;

  dataPointerOut = 0;
  blockBufferOut = 0;
  lengthAtOffsetOut = 0;
  DataPointer = CMBlockBufferGetDataPointer(*a4, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
  if ((_DWORD)DataPointer)
    return DataPointer;
  if ((*(_BYTE *)a3 & 1) != 0 && (v9 = *(_DWORD *)(a3 + 12) - 1, v9 <= 2))
    v10 = dword_18EDDD2D4[v9];
  else
    v10 = 1299148630;
  LODWORD(size_4) = a2;
  HIDWORD(size_4) = v10;
  v24 = dataPointerOut;
  v25 = lengthAtOffsetOut;
  size = 0;
  DataPointer = AudioToolbox_AudioFormatGetPropertyInfo(1835230563, 24, (uint64_t)&size_4, (uint64_t)&size);
  if ((_DWORD)DataPointer)
    return DataPointer;
  if (!size)
  {
    v18 = 4294954584;
LABEL_19:
    v16 = FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
LABEL_21:
    if ((_DWORD)v16)
      return v16;
    v12 = 0;
    v14 = 0;
    goto LABEL_11;
  }
  v11 = CFAllocatorAllocate(a1, size, 0);
  if (!v11)
  {
    v18 = 4294954583;
    goto LABEL_19;
  }
  v12 = v11;
  Property = AudioToolbox_AudioFormatGetProperty(1835230563, 24, (uint64_t)&size_4, (uint64_t)&size, (uint64_t)v11);
  if ((_DWORD)Property)
  {
    v16 = FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0);
    CFAllocatorDeallocate(a1, v12);
    goto LABEL_21;
  }
  v14 = size;
LABEL_11:
  v15 = CMBlockBufferCreateWithMemoryBlock(a1, v12, v14, a1, 0, 0, v14, 1u, &blockBufferOut);
  if ((_DWORD)v15)
  {
    v16 = v15;
    if (blockBufferOut)
      CFRelease(blockBufferOut);
    if (v12)
      CFAllocatorDeallocate(a1, v12);
  }
  else
  {
    if (*a4)
      CFRelease(*a4);
    v16 = 0;
    *a4 = blockBufferOut;
  }
  return v16;
}

uint64_t figSoundBridge_GetDecodeFormatIDForCodingName(int a1, uint64_t a2, _DWORD *a3)
{
  int v4;
  int v5;
  uint64_t result;
  int v7;
  int v8;
  _DWORD v9[3];

  if ((*(_BYTE *)a2 & 1) != 0 && (v4 = *(_DWORD *)(a2 + 12) - 1, v4 <= 2))
    v5 = dword_18EDDD2D4[v4];
  else
    v5 = 1299148630;
  v9[0] = v5;
  v9[1] = 4;
  v9[2] = a1;
  v7 = 0;
  v8 = 0;
  result = AudioToolbox_AudioFormatGetPropertyInfo(1768186734, 12, (uint64_t)v9, (uint64_t)&v7);
  if (!(_DWORD)result)
  {
    if (v7 == 4)
    {
      result = AudioToolbox_AudioFormatGetProperty(1768186734, 12, (uint64_t)v9, (uint64_t)&v7, (uint64_t)&v8);
      if (!(_DWORD)result)
      {
        *a3 = v8;
        return result;
      }
    }
    else
    {
      result = 4294954584;
    }
    return FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t figSoundBridge_CreateMagicCookieBBufFromALACBBuf(const __CFAllocator *a1, OpaqueCMBlockBuffer *a2, _QWORD *a3)
{
  uint64_t v5;
  size_t DataLength;
  void *v7;
  uint64_t v8;
  int v10;
  _OWORD v11[3];
  uint64_t v12;
  CMBlockBufferRef blockBufferOut;

  blockBufferOut = 0;
  v12 = 0;
  memset(v11, 0, sizeof(v11));
  v10 = 1667329121;
  v5 = CMBlockBufferCreateEmpty(a1, 4u, 0, &blockBufferOut);
  if ((_DWORD)v5 || (v5 = FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)v11), (_DWORD)v5))
  {
    v8 = v5;
  }
  else
  {
    FigAtomWriterBeginAtom((uint64_t)v11, 0x66726D61u, 0);
    FigAtomWriterAppendData((uint64_t)v11, (uint64_t)&v10, 4);
    FigAtomWriterEndAtom((uint64_t)v11);
    FigAtomWriterBeginAtom((uint64_t)v11, 0x616C6163u, 0);
    DataLength = CMBlockBufferGetDataLength(a2);
    FigAtomWriterAppendBlockBufferData((uint64_t)v11, a2, 8uLL, DataLength - 8);
    FigAtomWriterEndAtom((uint64_t)v11);
    FigAtomWriterBeginAtom((uint64_t)v11, 0, 0);
    FigAtomWriterEndAtom((uint64_t)v11);
    v7 = blockBufferOut;
    if (blockBufferOut)
      v7 = (void *)CFRetain(blockBufferOut);
    v8 = 0;
    *a3 = v7;
  }
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v8;
}

uint64_t figSoundBridge_CreateMagicCookieBBufFromAMRBBuf(const __CFAllocator *a1, unsigned int a2, OpaqueCMBlockBuffer *a3, _QWORD *a4)
{
  uint64_t v7;
  size_t DataLength;
  void *v9;
  uint64_t v10;
  __int16 v12;
  unsigned int v13;
  _OWORD v14[3];
  uint64_t v15;
  CMBlockBufferRef blockBufferOut;

  blockBufferOut = 0;
  v15 = 0;
  memset(v14, 0, sizeof(v14));
  v13 = 0;
  v12 = 0;
  v7 = CMBlockBufferCreateEmpty(a1, 4u, 0, &blockBufferOut);
  if ((_DWORD)v7 || (v7 = FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)v14), (_DWORD)v7))
  {
    v10 = v7;
  }
  else
  {
    FigAtomWriterBeginAtom((uint64_t)v14, 0x66726D61u, 0);
    v13 = bswap32(a2);
    FigAtomWriterAppendData((uint64_t)v14, (uint64_t)&v13, 4);
    FigAtomWriterEndAtom((uint64_t)v14);
    FigAtomWriterBeginAtom((uint64_t)v14, 0x656E6461u, 0);
    FigAtomWriterAppendData((uint64_t)v14, (uint64_t)&v12, 2);
    FigAtomWriterEndAtom((uint64_t)v14);
    FigAtomWriterBeginAtom((uint64_t)v14, 0x73616D72u, 0);
    DataLength = CMBlockBufferGetDataLength(a3);
    FigAtomWriterAppendBlockBufferData((uint64_t)v14, a3, 0, DataLength);
    FigAtomWriterEndAtom((uint64_t)v14);
    FigAtomWriterBeginAtom((uint64_t)v14, 0, 0);
    FigAtomWriterEndAtom((uint64_t)v14);
    v9 = blockBufferOut;
    if (blockBufferOut)
      v9 = (void *)CFRetain(blockBufferOut);
    v10 = 0;
    *a4 = v9;
  }
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v10;
}

BOOL figSoundBridge_isAACUsingESDSinMOV(unsigned int a1)
{
  int v1;

  if (a1 - 1633772389 > 0xE)
    goto LABEL_6;
  v1 = 1 << (a1 - 101);
  if ((v1 & 0x4888) != 0)
    return 1;
  if ((v1 & 7) != 0)
    return 0;
LABEL_6:
  if (a1 == 1633772320)
    return 1;
  return a1 >> 8 == 6381923;
}

uint64_t figSoundBridge_GetMP4ASBDFromESDSDataBBuf(uint64_t a1, uint64_t a2)
{
  uint64_t DataPointer;
  uint64_t Property;
  __int128 v6;
  const __CFAllocator *v7;
  char *v8;
  uint64_t v9;
  void *v10;
  const __CFAllocator *v11;
  CMBlockBufferRef v12;
  const void *v13;
  OpaqueCMBlockBuffer *v14;
  int v15;
  int v16;
  char *v17;
  uint64_t v18;
  __int128 v19;
  int v20;
  unsigned __int16 v22;
  unsigned __int8 v23;
  char *dataPointerOut;
  size_t lengthAtOffsetOut;
  int v26;
  CMBlockBufferRef blockBufferOut;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  CFIndex size;
  unsigned int v32[8];
  __int128 totalLengthOut;
  __int128 v34;
  uint64_t v35;
  char *v36;
  int v37;
  int v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  size = 0;
  v29 = 0u;
  v30 = 0u;
  v28 = 0u;
  blockBufferOut = 0;
  v26 = 0;
  dataPointerOut = 0;
  lengthAtOffsetOut = 0;
  DataPointer = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(a1 + 112), 0, &lengthAtOffsetOut, 0, &dataPointerOut);
  if ((_DWORD)DataPointer)
    goto LABEL_62;
  if (HIDWORD(lengthAtOffsetOut))
  {
    DataPointer = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_62;
  }
  *((_QWORD *)&v30 + 1) = dataPointerOut;
  LODWORD(size) = lengthAtOffsetOut;
  v26 = 56;
  if (AudioToolbox_AudioFormatGetProperty(1702061673, lengthAtOffsetOut, (uint64_t)dataPointerOut, (uint64_t)&v26, (uint64_t)&v28))
  {
    v26 = 40;
    Property = AudioToolbox_AudioFormatGetProperty(1702064996, lengthAtOffsetOut, (uint64_t)dataPointerOut, (uint64_t)&v26, a2);
    if ((_DWORD)Property)
      goto LABEL_48;
    goto LABEL_29;
  }
  v6 = v29;
  *(_OWORD *)a2 = v28;
  *(_OWORD *)(a2 + 16) = v6;
  *(_QWORD *)(a2 + 32) = v30;
  if ((_DWORD)size && *((_QWORD *)&v30 + 1))
  {
    if (lengthAtOffsetOut > size
      && *((_QWORD *)&v30 + 1) >= (unint64_t)dataPointerOut
      && (unint64_t)&dataPointerOut[lengthAtOffsetOut - *((_QWORD *)&v30 + 1)] >= size)
    {
      v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE10];
      v8 = (char *)CFAllocatorAllocate((CFAllocatorRef)*MEMORY[0x1E0C9AE10], size, 0);
      if (!v8)
      {
LABEL_35:
        Property = 0;
        goto LABEL_54;
      }
      v9 = CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 112), *((_QWORD *)&v30 + 1) - (_QWORD)dataPointerOut, size, v8);
      if ((_DWORD)v9)
        goto LABEL_60;
      v9 = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v8, size, v7, 0, 0, size, 0, &blockBufferOut);
      if ((_DWORD)v9)
        goto LABEL_60;
    }
    goto LABEL_20;
  }
  v10 = *(void **)(a1 + 104);
  if (v10)
    v10 = (void *)CFRetain(v10);
  blockBufferOut = (CMBlockBufferRef)v10;
  v11 = CFGetAllocator(v10);
  DataPointer = figSoundBridge_TransformToCanonicalMagicCookieBBuf(v11, SDWORD2(v28), a1, &blockBufferOut);
  if ((_DWORD)DataPointer)
  {
LABEL_62:
    Property = DataPointer;
    goto LABEL_53;
  }
  if (*(_DWORD *)(a2 + 8) == 1633772320)
    *(_BYTE *)(a1 + 296) = 1;
LABEL_20:
  v12 = blockBufferOut;
  if (blockBufferOut)
  {
    v13 = *(const void **)(a1 + 264);
    *(_QWORD *)(a1 + 264) = blockBufferOut;
    CFRetain(v12);
    if (v13)
      CFRelease(v13);
    if (blockBufferOut)
    {
      CFRelease(blockBufferOut);
      blockBufferOut = 0;
    }
    v14 = *(OpaqueCMBlockBuffer **)(a1 + 264);
    if (v14)
    {
      *(_QWORD *)&totalLengthOut = 0;
      CMBlockBufferGetDataPointer(v14, 0, 0, (size_t *)&totalLengthOut, (char **)(a1 + 272));
      *(_DWORD *)(a1 + 280) = totalLengthOut;
    }
    if (DWORD2(v28) == 1987015266)
    {
      Property = 1718449215;
      goto LABEL_48;
    }
  }
LABEL_29:
  if (*(_DWORD *)(a2 + 8) != 1633772320)
  {
    v8 = 0;
    goto LABEL_35;
  }
  Property = 0;
  v8 = 0;
  v15 = *(_DWORD *)(a2 + 12);
  if (v15 > 28)
  {
    if (v15 == 29)
    {
      v16 = 1633772400;
    }
    else
    {
      if (v15 != 30)
        goto LABEL_54;
      v16 = 1633772403;
    }
  }
  else if (v15 == 5)
  {
    v16 = 1633772392;
  }
  else
  {
    if (v15 != 23)
      goto LABEL_54;
    v16 = 1633772396;
  }
  v32[0] = 0;
  v34 = 0u;
  v35 = 0;
  totalLengthOut = 0u;
  v36 = dataPointerOut;
  v38 = 0;
  DWORD2(totalLengthOut) = v16;
  v37 = lengthAtOffsetOut;
  Property = AudioToolbox_AudioFormatGetPropertyInfo(1718383476, 56, (uint64_t)&totalLengthOut, (uint64_t)v32);
  if ((_DWORD)Property || !v32[0])
  {
LABEL_47:
    if ((_DWORD)Property)
    {
LABEL_48:
      v23 = 0;
      v22 = 0;
      FigMP4Bridge_GetESDSObjectTypeAndCopyDecoderSpecificInfo((unint64_t)dataPointerOut, lengthAtOffsetOut, (char *)&v23, &v22, 0);
      v20 = v23;
      if (v23)
      {
        if (v22)
        {
          snprintf((char *)v32, 0x20uLL, ", audio object type %u", v22);
          v20 = v23;
        }
        else
        {
          LOBYTE(v32[0]) = 0;
        }
        snprintf((char *)&totalLengthOut, 0x80uLL, "Found stream descriptor for unsupported MPEG-4 object type 0x%X%s", v20, (const char *)v32);
        figSoundBridge_ReportParsingFailureMessage(*(_QWORD *)(a1 + 288), (uint64_t)&totalLengthOut);
        FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      }
    }
LABEL_53:
    v8 = 0;
    goto LABEL_54;
  }
  v8 = (char *)malloc_type_malloc(v32[0], 0x413501D0uLL);
  if (v8)
  {
    Property = AudioToolbox_AudioFormatGetProperty(1718383476, 56, (uint64_t)&totalLengthOut, (uint64_t)v32, (uint64_t)v8);
    if (!(_DWORD)Property)
    {
      v17 = &v8[48 * (v32[0] / 0x30) - 48];
      v18 = *((_QWORD *)v17 + 4);
      v19 = *((_OWORD *)v17 + 1);
      *(_OWORD *)a2 = *(_OWORD *)v17;
      *(_OWORD *)(a2 + 16) = v19;
      *(_QWORD *)(a2 + 32) = v18;
    }
    free(v8);
    goto LABEL_47;
  }
  v9 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
LABEL_60:
  Property = v9;
LABEL_54:
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  if (v8)
    CFAllocatorDeallocate((CFAllocatorRef)*MEMORY[0x1E0C9AE10], v8);
  return Property;
}

uint64_t figSoundBridge_GetASBDFromDAC3BBuf(OpaqueCMBlockBuffer *a1, uint64_t a2)
{
  uint64_t result;
  size_t v4;
  char *dataPointerOut;

  v4 = 0;
  dataPointerOut = 0;
  result = CMBlockBufferGetDataPointer(a1, 0, &v4, 0, &dataPointerOut);
  if (!(_DWORD)result)
    return ParseAC3MP4Cookie((unsigned __int8 *)dataPointerOut, v4, a2, 0);
  return result;
}

uint64_t figSoundBridge_GetASBDFromDEC3BBuf(OpaqueCMBlockBuffer *a1, uint64_t a2)
{
  uint64_t result;
  size_t v4;
  char *dataPointerOut;

  v4 = 0;
  dataPointerOut = 0;
  result = CMBlockBufferGetDataPointer(a1, 0, &v4, 0, &dataPointerOut);
  if (!(_DWORD)result)
    return ParseEnhancedAC3MP4Cookie((uint64_t)dataPointerOut, v4, a2, 0, 0);
  return result;
}

uint64_t figSoundBridge_GetASBDFromAudioFormatWithCodecSpecificAtomBBuf(int a1, CMBlockBufferRef theBuffer, uint64_t a3)
{
  uint64_t result;
  int v6;
  char *dataPointerOut;
  size_t lengthAtOffsetOut;

  dataPointerOut = 0;
  lengthAtOffsetOut = 0;
  v6 = 40;
  result = CMBlockBufferGetDataPointer(theBuffer, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
  if (!(_DWORD)result)
  {
    *(_DWORD *)(a3 + 8) = a1;
    return AudioToolbox_AudioFormatGetProperty(1718449257, lengthAtOffsetOut, (uint64_t)dataPointerOut, (uint64_t)&v6, a3);
  }
  return result;
}

uint64_t figSoundBridge_GetASBDFromALACBBuf(OpaqueCMBlockBuffer *a1, uint64_t a2)
{
  uint64_t result;
  char *v4;
  unsigned __int8 v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  char *v9;
  size_t lengthAtOffsetOut;

  v9 = 0;
  lengthAtOffsetOut = 0;
  result = CMBlockBufferGetDataPointer(a1, 0, &lengthAtOffsetOut, 0, &v9);
  if (!(_DWORD)result)
  {
    if (lengthAtOffsetOut < 0x24)
    {
      return 4294954582;
    }
    else
    {
      v4 = v9;
      *(_DWORD *)(a2 + 8) = 1634492771;
      *(double *)a2 = (double)(int)bswap32(*((_DWORD *)v4 + 8));
      HIDWORD(v6) = v4[17];
      LODWORD(v6) = (HIDWORD(v6) << 24) - 0x10000000;
      v5 = v6 >> 26;
      if (v5 > 4u)
        v7 = 0;
      else
        v7 = dword_18EDDD2E0[(char)v5];
      result = 0;
      *(_DWORD *)(a2 + 12) = v7;
      *(_DWORD *)(a2 + 28) = v4[21];
      v8 = bswap32(*((_DWORD *)v4 + 3));
      *(_DWORD *)(a2 + 16) = 0;
      *(_QWORD *)(a2 + 20) = v8;
      *(_QWORD *)(a2 + 32) = 0;
    }
  }
  return result;
}

uint64_t translateMP4AFormatID(int a1)
{
  uint64_t result;
  int v3;
  unsigned __int16 v4;
  int v5;

  result = 1836069985;
  if (a1 <= 1752594530)
  {
    if (a1 <= 1667312946)
    {
      if ((a1 - 1633772389) <= 0xE && ((1 << (a1 - 101)) & 0x488F) != 0)
        return result;
      if (a1 == 1633771875)
        return 1633777252;
      v5 = 1633772320;
    }
    else
    {
      if (a1 <= 1667575090)
      {
        if (a1 <= 1667326823)
        {
          if (a1 == 1667312947)
            return 1701733217;
          v4 = 24931;
        }
        else
        {
          if (a1 == 1667326824 || a1 == 1667326832)
            return 1701733217;
          v4 = 28771;
        }
        v3 = v4 | 0x63610000;
        goto LABEL_50;
      }
      if (a1 > 1667656802)
      {
        if (a1 == 1667656803 || a1 == 1668047203)
          return 1701733217;
        v3 = 1668641633;
        goto LABEL_50;
      }
      if (a1 == 1667575091)
        return 1701733217;
      v5 = 1667591280;
    }
LABEL_46:
    if (a1 == v5)
      return result;
    goto LABEL_53;
  }
  if (a1 <= 1902211170)
  {
    if (a1 <= 1885692722)
    {
      if ((a1 - 1885430579) > 0x3D || ((1 << (a1 - 51)) & 0x2020000000000001) == 0)
      {
        if (a1 == 1752594531)
          return result;
        if (a1 != 1885430115)
          goto LABEL_53;
      }
      return 1685220723;
    }
    if (a1 <= 1902207794)
    {
      if (a1 != 1885692723 && a1 != 1886745441)
      {
        v3 = 1902207331;
        goto LABEL_50;
      }
      return 1685220723;
    }
    if ((a1 - 1902207795) <= 0x3D && ((1 << (a1 - 51)) & 0x2020000000000001) != 0)
      return 1701733217;
LABEL_53:
    if (a1 >> 8 == 6381923)
      return 1836069985;
    else
      return a1;
  }
  if (a1 <= 1903522656)
  {
    if (a1 > 1902537826)
    {
      if (a1 == 1902537827)
        return 1701733217;
      v3 = 1902928227;
    }
    else
    {
      if (a1 == 1902211171)
        return 1701733217;
      v3 = 1902469939;
    }
LABEL_50:
    if (a1 == v3)
      return 1701733217;
    goto LABEL_53;
  }
  if (a1 <= 1936487277)
  {
    if (a1 != 1903522657)
    {
      if (a1 == 1936487267)
        return 1832149349;
      goto LABEL_53;
    }
    return 1701733217;
  }
  if (a1 != 1936487278 && a1 != 1953986161)
  {
    v5 = 1970495843;
    goto LABEL_46;
  }
  return result;
}

uint64_t figSoundBridge_EndianAudioChannelLayout_NtoB(int8x8_t *a1, unsigned int a2)
{
  unint64_t v3;
  unsigned int AudioChannelCountFromLayout;
  uint64_t v5;
  int8x8_t v6;
  unsigned int v7;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;

  if (!a1 || a2 < 0xC)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v3 = a2;
  AudioChannelCountFromLayout = figSoundBridge_GetAudioChannelCountFromLayout(a1);
  v5 = a1[1].u32[0];
  if ((_DWORD)v5)
  {
    if (AudioChannelCountFromLayout != (_DWORD)v5 || 20 * (unint64_t)AudioChannelCountFromLayout + 12 > v3)
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  else if (!AudioChannelCountFromLayout)
  {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  v6 = *a1;
  if (20 * (unint64_t)v5 + 12 <= v3)
  {
    v7 = bswap32(v5);
    if ((_DWORD)v5)
    {
      v9 = 0;
      v10 = (_DWORD *)&a1[2] + 1;
      do
      {
        v11 = 0;
        *(int8x8_t *)((char *)a1 + 20 * v9 + 12) = vrev32_s8(*(int8x8_t *)((char *)a1 + 20 * v9 + 12));
        do
        {
          v10[v11] = bswap32(v10[v11]);
          ++v11;
        }
        while (v11 != 3);
        ++v9;
        v10 += 5;
      }
      while (v9 != v5);
    }
    goto LABEL_17;
  }
  if (!v6.i32[0])
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v7 = 0;
LABEL_17:
  *a1 = vrev32_s8(v6);
  a1[1].i32[0] = v7;
  return 0;
}

uint64_t figSoundBridge_ConvertMP4AESDSMagicCookieToSoundDescriptionExtension(const __CFAllocator *a1, int a2, int a3, uint64_t a4, int a5, char a6, char **a7, _DWORD *a8)
{
  size_t v11;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  unsigned int v22;
  char *v23;
  BOOL v24;
  const void *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  const __CFAllocator *allocator;

  LODWORD(v11) = a5;
  if (a3)
    v15 = 4;
  else
    v15 = 12;
  if (a3)
    v16 = translateMP4AFormatID(a2);
  else
    v16 = 1836069985;
  v17 = v15 + v11;
  if ((a6 & 1) != 0)
    v18 = v17;
  else
    v18 = v17 + 32;
  if (HIDWORD(v18))
  {
    v27 = 4294954586;
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  if (!a7 || !a8)
  {
    v27 = 4294954584;
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  allocator = a1;
  v19 = (char *)CFAllocatorAllocate(a1, v18, 0);
  if (!v19)
  {
    v27 = 4294954583;
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  v20 = v19;
  v21 = v19;
  if ((a6 & 1) == 0)
  {
    *(_QWORD *)v19 = 0x616D72660C000000;
    v22 = bswap32(v16);
    *((_DWORD *)v19 + 2) = v22;
    *((_DWORD *)v19 + 3) = 201326592;
    *((_DWORD *)v19 + 4) = v22;
    *((_DWORD *)v19 + 5) = 0;
    v21 = v19 + 24;
  }
  *(_DWORD *)v21 = bswap32(v17);
  *(_QWORD *)(v21 + 4) = 1935962981;
  v23 = v21 + 12;
  if (a3)
  {
    v24 = v11 >= 8;
    v11 = (v11 - 8);
    if (!v24)
    {
      v28 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
      CFAllocatorDeallocate(allocator, v20);
      return v28;
    }
    v25 = (const void *)(a4 + 8);
    v26 = v21 + 12;
  }
  else
  {
    v11 = v11;
    v26 = v21 + 12;
    v25 = (const void *)a4;
  }
  memcpy(v26, v25, v11);
  if ((a6 & 1) == 0)
    *(_QWORD *)&v23[v11] = 0x8000000;
  *a7 = v20;
  *a8 = v18;
  return 0;
}

uint64_t figSoundBridge_isProtectedMP4AFormatUsingESDS(int a1)
{
  uint64_t result;
  int v3;

  result = 1;
  if (a1 <= 1885430631)
  {
    if (a1 > 1667326831)
    {
      if (a1 != 1667326832 && a1 != 1668641633)
      {
        v3 = 1885430115;
LABEL_18:
        if (a1 != v3)
          return 0;
      }
    }
    else if (a1 != 1633771875 && a1 != 1667326307)
    {
      v3 = 1667326824;
      goto LABEL_18;
    }
  }
  else
  {
    if (a1 > 1902207330)
    {
      if (a1 > 1902207855)
      {
        if (a1 == 1902207856)
          return result;
        v3 = 1903522657;
      }
      else
      {
        if (a1 == 1902207331)
          return result;
        v3 = 1902207848;
      }
      goto LABEL_18;
    }
    if (a1 != 1885430632 && a1 != 1885430640)
    {
      v3 = 1886745441;
      goto LABEL_18;
    }
  }
  return result;
}

uint64_t figSoundBridge_ConvertALACMagicCookieToSoundDescriptionExtension(const __CFAllocator *a1, _DWORD *a2, unsigned int a3, char a4, _QWORD *a5, _DWORD *a6)
{
  char *v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  const void *v15;
  char *v16;
  __int128 v17;
  char *v19;
  __int128 v20;

  if (!a5 || !a6)
  {
    v12 = 4294954584;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  if (a3 > 0x2F)
  {
    if (a2[1] == 1634562662)
    {
      if (*a2 == 201326592 && a2[2] == 1667329121 && a2[4] == 1667329121)
      {
        v13 = bswap32(a2[3]);
        if (v13 + 12 <= (unint64_t)a3)
        {
          if ((a4 & 1) != 0)
            v11 = v13;
          else
            v11 = a3;
          v14 = (char *)CFAllocatorAllocate(a1, v11, 0);
          if (v14)
          {
            v10 = v14;
            if ((a4 & 1) != 0)
              v15 = a2 + 3;
            else
              v15 = a2;
            memcpy(v14, v15, v11);
            goto LABEL_30;
          }
LABEL_31:
          v12 = 4294954583;
          return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
        }
      }
    }
    else if (a2[7] == 1851877475 && a3 - 24 == bswap32(a2[6]))
    {
LABEL_23:
      if ((a4 & 1) != 0)
      {
        v19 = (char *)CFAllocatorAllocate(a1, 36, 0);
        if (v19)
        {
          v10 = v19;
          *(_QWORD *)v19 = 0x63616C6124000000;
          *((_DWORD *)v19 + 2) = 0;
          v20 = *(_OWORD *)a2;
          *(_QWORD *)(v19 + 28) = *((_QWORD *)a2 + 2);
          *(_OWORD *)(v19 + 12) = v20;
          LODWORD(v11) = 36;
          goto LABEL_30;
        }
      }
      else
      {
        v16 = (char *)CFAllocatorAllocate(a1, 56, 0);
        if (v16)
        {
          v10 = v16;
          *(_OWORD *)v16 = xmmword_18EDDD250;
          *((_QWORD *)v16 + 2) = 1667329121;
          v17 = *(_OWORD *)a2;
          *((_QWORD *)v16 + 5) = *((_QWORD *)a2 + 2);
          *(_OWORD *)(v16 + 24) = v17;
          *((_QWORD *)v16 + 6) = 0x8000000;
          LODWORD(v11) = 56;
          goto LABEL_30;
        }
      }
      goto LABEL_31;
    }
    goto LABEL_26;
  }
  if (a3 != 24)
  {
LABEL_26:
    v12 = 4294954580;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  if (a2)
    goto LABEL_23;
  v10 = 0;
  LODWORD(v11) = 0;
LABEL_30:
  *a5 = v10;
  *a6 = v11;
  return 0;
}

uint64_t figSoundBridge_ConvertFLACMagicCookieToSoundDescriptionExtension(const __CFAllocator *a1, unsigned int *a2, uint64_t a3, unsigned int **a4, unsigned int *a5)
{
  unsigned int v10;
  uint64_t v11;
  uint64_t PropertyInfo;
  void *v13;
  void *v14;
  uint64_t Property;
  unsigned int v17;

  if (a3 < 9 || a2[1] != 1632396900)
  {
    v17 = 0;
    PropertyInfo = AudioToolbox_AudioFormatGetPropertyInfo(1835230310, a3, (uint64_t)a2, (uint64_t)&v17);
    if (!(_DWORD)PropertyInfo)
    {
      v13 = CFAllocatorAllocate(a1, a3, 0);
      if (v13)
      {
        v14 = v13;
        Property = AudioToolbox_AudioFormatGetProperty(1835230310, a3, (uint64_t)a2, (uint64_t)&v17, (uint64_t)v13);
        if ((_DWORD)Property)
        {
          v11 = FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0);
          if ((_DWORD)v11)
            CFAllocatorDeallocate(a1, v14);
          return v11;
        }
        v11 = 0;
        *a4 = (unsigned int *)v14;
        v10 = v17;
        goto LABEL_9;
      }
      PropertyInfo = 4294954583;
    }
    return FigSignalErrorAt(PropertyInfo, 0, 0, 0, 0, 0, 0);
  }
  v10 = bswap32(*a2);
  if (v10 <= a3)
  {
    v11 = 0;
    *a4 = a2;
LABEL_9:
    *a5 = v10;
    return v11;
  }
  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t figSoundBridge_ConvertAMRMagicCookieToSoundDescriptionExtension(const __CFAllocator *a1, int a2, _DWORD *a3, int a4, char a5, _QWORD *a6, _DWORD *a7)
{
  unsigned int v11;
  size_t v12;
  _DWORD *v13;
  _DWORD *v14;
  const void *v15;
  uint64_t v16;

  if (!a6 || !a7)
  {
    v16 = 4294954584;
    return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
  }
  if (a4 != 47
    || *a3 != 201326592
    || a3[1] != 1634562662
    || bswap32(a3[2]) != a2
    || (v11 = bswap32(*(_DWORD *)((char *)a3 + 26)), v11 != 1684106610) && v11 != 1935764850
    || *(_DWORD *)((char *)a3 + 22) != 285212672)
  {
    v16 = 4294954580;
    return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
  }
  if ((a5 & 1) != 0)
    v12 = 17;
  else
    v12 = 47;
  v13 = CFAllocatorAllocate(a1, v12, 0);
  if (!v13)
  {
    v16 = 4294954583;
    return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
  }
  v14 = v13;
  if ((a5 & 1) != 0)
    v15 = (char *)a3 + 22;
  else
    v15 = a3;
  memcpy(v13, v15, v12);
  if ((a5 & 1) != 0)
    v14[1] = 1919770980;
  else
    *(_DWORD *)((char *)v14 + 26) = 1919770995;
  *a6 = v14;
  *a7 = v12;
  return 0;
}

uint64_t FigAudioCodecTypeIsAC3(int a1)
{
  uint64_t result;
  int v3;

  result = 1;
  if (a1 > 1885430578)
  {
    if (a1 != 1885430579 && a1 != 1902207795)
    {
      v3 = 2053202739;
LABEL_8:
      if (a1 != v3)
        return 0;
    }
  }
  else if (a1 != 1633889587 && a1 != 1667312947)
  {
    v3 = 1667326771;
    goto LABEL_8;
  }
  return result;
}

uint64_t figSoundBridge_EncapsulatedMagicCookieFromCanonicalMagicCookie(const __CFAllocator *a1, int a2, char a3, uint64_t a4, unsigned int a5, _QWORD *a6, unsigned int *a7)
{
  int v10;
  uint64_t PropertyInfo;
  void *v12;
  void *v13;
  uint64_t Property;
  uint64_t v15;
  uint64_t v17;
  unsigned int size;
  CFIndex size_4;
  uint64_t v20;
  uint64_t v21;

  if ((a3 & 1) != 0)
    v10 = 1836069990;
  else
    v10 = 1299148630;
  LODWORD(size_4) = a2;
  HIDWORD(size_4) = v10;
  v20 = a4;
  v21 = a5;
  size = 0;
  PropertyInfo = AudioToolbox_AudioFormatGetPropertyInfo(1701014883, 24, (uint64_t)&size_4, (uint64_t)&size);
  if ((_DWORD)PropertyInfo)
    return PropertyInfo;
  if (!size)
  {
    v17 = 4294954584;
    return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
  }
  v12 = CFAllocatorAllocate(a1, size, 0);
  if (!v12)
  {
    v17 = 4294954583;
    return FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
  }
  v13 = v12;
  Property = AudioToolbox_AudioFormatGetProperty(1701014883, 24, (uint64_t)&size_4, (uint64_t)&size, (uint64_t)v12);
  if ((_DWORD)Property)
  {
    v15 = FigSignalErrorAt(Property, 0, 0, 0, 0, 0, 0);
    CFAllocatorDeallocate(a1, v13);
  }
  else
  {
    v15 = 0;
    *a7 = size;
    *a6 = v13;
  }
  return v15;
}

BOOL figSoundBridge_AreAtomsWellFormed(uint64_t a1, uint64_t a2, int a3, _QWORD *a4)
{
  int CFPreferenceNumberWithDefault;
  int v9;
  uint64_t v10;
  int Atom;
  _BOOL8 result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  _OWORD v17[7];

  memset(v17, 0, sizeof(v17));
  CFPreferenceNumberWithDefault = figSoundBridge_AllowZeroSizeTerminatorAtom_value;
  if (figSoundBridge_AllowZeroSizeTerminatorAtom_value == -1)
  {
    CFPreferenceNumberWithDefault = FigGetCFPreferenceNumberWithDefault(CFSTR("zero_size_terminator_atom"), CFSTR("com.apple.coremedia"), 1);
    figSoundBridge_AllowZeroSizeTerminatorAtom_value = CFPreferenceNumberWithDefault;
  }
  v9 = FigAtomStreamInitWithMemoryBlock(a1, a2, 0, CFPreferenceNumberWithDefault != 0, (uint64_t)v17);
  v10 = 0;
  if (!v9)
  {
    while (1)
    {
      v16 = 0;
      v14 = 0;
      v15 = 0;
      if (FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v17, &v16, &v15)
        || FigAtomStreamGetCurrentAtomGlobalOffset(v17, 0, &v14))
      {
        break;
      }
      if (!v16)
      {
        v13 = v14;
        if (!a3)
          v13 = 0;
        v10 += v13;
        result = 1;
        if (!a4)
          return result;
        goto LABEL_13;
      }
      v10 += v14;
      Atom = FigAtomStreamAdvanceToNextAtom(v17);
      if (Atom)
      {
        result = Atom == -12890;
        if (a4)
          goto LABEL_13;
        return result;
      }
    }
  }
  result = 0;
  if (a4)
LABEL_13:
    *a4 = v10;
  return result;
}

uint64_t figBridge_ConvertMiscellaneousSampleDescriptionExtensionsToAtoms(const opaqueCMFormatDescription *a1, _QWORD *a2, uint64_t a3)
{
  CFPropertyListRef Extension;
  const void *v5;
  CFTypeID TypeID;
  size_t Count;
  size_t v8;
  const void **v9;
  const void **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  const void *v15;
  const void *Value;
  CFTypeID v17;
  unsigned int v18;
  unsigned int v19;
  CFTypeID v20;
  size_t Length;
  uint64_t v22;
  unsigned int v23;
  _DWORD *v24;
  const UInt8 *BytePtr;
  CFIndex v26;
  CFIndex v27;
  CFIndex v28;
  const __CFData *ValueAtIndex;
  CFTypeID v30;
  size_t v31;
  unsigned int v32;
  _DWORD *v33;
  const UInt8 *v34;
  void *v35;
  uint64_t v36;
  _QWORD *v38;
  unsigned int v39;
  size_t v41;
  const void **v42;

  *a2 = 0;
  Extension = CMFormatDescriptionGetExtension(a1, CFSTR("SampleDescriptionExtensionAtoms"));
  if (!Extension)
    return 0;
  v5 = Extension;
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v5))
    return 0;
  Count = CFDictionaryGetCount((CFDictionaryRef)v5);
  if (!Count)
    return 0;
  v8 = Count;
  v9 = (const void **)malloc_type_calloc(Count, 8uLL, 0x6004044C4A2DFuLL);
  v42 = v9;
  if (v9)
  {
    v10 = v9;
    v38 = a2;
    CFDictionaryGetKeysAndValues((CFDictionaryRef)v5, v9, 0);
    qsort(v10, v8, 8uLL, (int (__cdecl *)(const void *, const void *))SampleDescriptionExtensionComparator);
    v11 = 0;
    v12 = 0;
    v13 = a3;
    v41 = v8;
    do
    {
      v14 = (const __CFString *)v10[v12];
      v15 = v5;
      Value = CFDictionaryGetValue((CFDictionaryRef)v5, v14);
      v17 = CFStringGetTypeID();
      if (v17 == CFGetTypeID(v14))
      {
        v18 = figBridge_ConvertStringToAtomType(v14);
        if (v18)
        {
          v19 = v18;
          v20 = CFGetTypeID(Value);
          if (CFDataGetTypeID() == v20)
          {
            Length = CFDataGetLength((CFDataRef)Value);
            v22 = v13;
            v23 = Length + 8;
            if (v22)
            {
              v24 = (_DWORD *)(v22 + v11);
              *v24 = bswap32(v23);
              v24[1] = bswap32(v19);
              BytePtr = CFDataGetBytePtr((CFDataRef)Value);
              memcpy((void *)(v22 + v11 + 8), BytePtr, Length);
            }
            v11 += v23;
            v13 = v22;
            v10 = v42;
          }
          else if (CFArrayGetTypeID() == v20)
          {
            v26 = CFArrayGetCount((CFArrayRef)Value);
            if (v26)
            {
              v27 = v26;
              v28 = 0;
              v39 = bswap32(v19);
              do
              {
                ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex((CFArrayRef)Value, v28);
                v30 = CFDataGetTypeID();
                if (v30 == CFGetTypeID(ValueAtIndex))
                {
                  v31 = CFDataGetLength(ValueAtIndex);
                  v32 = v31 + 8;
                  if (v13)
                  {
                    v33 = (_DWORD *)(v13 + v11);
                    *v33 = bswap32(v32);
                    v33[1] = v39;
                    v34 = CFDataGetBytePtr(ValueAtIndex);
                    v35 = (void *)(v13 + v11 + 8);
                    v13 = a3;
                    memcpy(v35, v34, v31);
                  }
                  v11 += v32;
                  v10 = v42;
                }
                ++v28;
              }
              while (v27 != v28);
            }
          }
        }
      }
      ++v12;
      v5 = v15;
    }
    while (v12 != v41);
    v36 = 0;
    *v38 = v11;
  }
  else
  {
    v36 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  }
  free(v42);
  return v36;
}

uint64_t SampleDescriptionExtensionComparator(const __CFString **a1, const __CFString **a2)
{
  int v3;
  int v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  unsigned int v10;

  v3 = figBridge_ConvertStringToAtomType(*a1);
  v4 = v3;
  v5 = 0;
  while (SampleDescriptionExtensionISOAtomPriority_isoAtomOrdering[v5] != v3)
  {
    if (++v5 == 8)
    {
      LODWORD(v5) = 0;
      break;
    }
  }
  v6 = v5;
  v7 = figBridge_ConvertStringToAtomType(*a2);
  v8 = 0;
  while (SampleDescriptionExtensionISOAtomPriority_isoAtomOrdering[v8] != v7)
  {
    if (++v8 == 8)
    {
      if (v6)
        return 0xFFFFFFFFLL;
      else
        return (v4 - v7);
    }
  }
  if (v6 && (_DWORD)v8)
    return (v6 - v8);
  if ((_DWORD)v8)
    v10 = 1;
  else
    v10 = v4 - v7;
  if (v6)
    return 0xFFFFFFFFLL;
  else
    return v10;
}

uint64_t figBridge_ConvertStringToAtomType(const __CFString *a1)
{
  int PascalString;
  uint64_t result;
  unsigned __int8 buffer;
  unsigned int v4;

  PascalString = CFStringGetPascalString(a1, &buffer, 5, 0);
  result = 0;
  if (PascalString)
  {
    if (buffer == 4)
      return bswap32(v4);
  }
  return result;
}

uint64_t figSoundBridge_IsKnownAtomFoundInExtension(uint64_t a1, uint64_t a2, int a3)
{
  int CFPreferenceNumberWithDefault;
  uint64_t v9;
  int v10;
  _OWORD v11[7];

  memset(v11, 0, sizeof(v11));
  CFPreferenceNumberWithDefault = figSoundBridge_AllowZeroSizeTerminatorAtom_value;
  if (figSoundBridge_AllowZeroSizeTerminatorAtom_value == -1)
  {
    CFPreferenceNumberWithDefault = FigGetCFPreferenceNumberWithDefault(CFSTR("zero_size_terminator_atom"), CFSTR("com.apple.coremedia"), 1);
    figSoundBridge_AllowZeroSizeTerminatorAtom_value = CFPreferenceNumberWithDefault;
  }
  if (!FigAtomStreamInitWithMemoryBlock(a1, a2, 0, CFPreferenceNumberWithDefault != 0, (uint64_t)v11))
  {
    while (1)
    {
      v10 = 0;
      v9 = 0;
      if (FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v11, &v10, &v9))
        return 0;
      if (v10 <= 1969513847)
        break;
      if ((v10 - 1969514801) < 2)
        goto LABEL_19;
      if (v10 != 2002876005)
      {
        if (v10 != 1969513848)
          goto LABEL_20;
LABEL_19:
        if (!a3)
          return 1;
        goto LABEL_20;
      }
      if (a3 == 1)
        return 1;
LABEL_20:
      if (FigAtomStreamAdvanceToNextAtom(v11))
        return 0;
    }
    if (v10 <= 1936875891)
    {
      if (v10 != 1667788396 && v10 != 1684892024)
      {
        if (!v10)
          return 0;
        goto LABEL_20;
      }
    }
    else if ((v10 - 1969513265) >= 2 && v10 != 1936875892)
    {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  return 0;
}

OSStatus CMSwapBigEndianClosedCaptionDescriptionToHost(uint8_t *closedCaptionDescriptionData, size_t closedCaptionDescriptionSize)
{
  if (closedCaptionDescriptionSize <= 0xF)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  flipClosedCaptionDescriptionData((int8x8_t *)closedCaptionDescriptionData);
  return 0;
}

int8x8_t flipClosedCaptionDescriptionData(int8x8_t *a1)
{
  int8x8_t result;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;

  result = vrev32_s8(*a1);
  v2 = bswap32(a1[1].u32[0]);
  v3 = bswap32(a1[1].u16[2]) >> 16;
  v4 = bswap32(a1[1].u16[3]) >> 16;
  *a1 = result;
  a1[1].i32[0] = v2;
  a1[1].i16[2] = v3;
  a1[1].i16[3] = v4;
  return result;
}

OSStatus CMSwapHostEndianClosedCaptionDescriptionToBig(uint8_t *closedCaptionDescriptionData, size_t closedCaptionDescriptionSize)
{
  if (closedCaptionDescriptionSize <= 0xF)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  flipClosedCaptionDescriptionData((int8x8_t *)closedCaptionDescriptionData);
  return 0;
}

OSStatus CMClosedCaptionFormatDescriptionCreateFromBigEndianClosedCaptionDescriptionData(CFAllocatorRef allocator, const uint8_t *closedCaptionDescriptionData, size_t size, CMClosedCaptionDescriptionFlavor flavor, CMClosedCaptionFormatDescriptionRef *formatDescriptionOut)
{
  signed int v6;
  uint64_t v7;
  uint64_t v9;
  signed int v12;
  FourCharCode v13;
  unsigned __int16 v14;
  unint64_t v15;
  __CFDictionary *Mutable;
  const uint8_t *v17;
  const __CFAllocator *v18;
  unsigned int v19;
  signed int v20;
  uint64_t v21;
  unint64_t v22;
  BOOL v23;
  CFDataRef v24;
  CFDataRef v25;
  CFStringRef v26;
  CFStringRef v27;
  OSStatus v28;
  const __CFDictionary *v29;
  char v30;
  OSStatus v31;
  char v32;
  CFTypeRef *v33;
  FourCharCode mediaSubType;
  UInt8 bytes[4];
  void *keys[2];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  _OWORD values[8];
  _QWORD v45[4];

  v45[1] = *MEMORY[0x1E0C80C00];
  if (!closedCaptionDescriptionData || size <= 0xF || !formatDescriptionOut)
  {
    v9 = 4294954584;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  v6 = bswap32(*(_DWORD *)closedCaptionDescriptionData);
  v7 = v6;
  if (v6 < 0x10 || v6 > size)
  {
    v9 = 4294954582;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  v12 = *((_DWORD *)closedCaptionDescriptionData + 1);
  v13 = bswap32(v12);
  memset(values, 0, sizeof(values));
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  *(_OWORD *)keys = 0u;
  v37 = 0u;
  if (v12 <= 942684002)
  {
    if (v12 != 942683747)
    {
      v14 = 13936;
      goto LABEL_17;
    }
LABEL_18:
    mediaSubType = v13;
    v15 = v7 - 16;
    if ((unint64_t)(v7 - 16) < 9)
    {
LABEL_39:
      Mutable = 0;
LABEL_40:
      v29 = 0;
      v30 = 1;
    }
    else
    {
      Mutable = 0;
      v17 = closedCaptionDescriptionData + 16;
      v18 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      do
      {
        v19 = *((_DWORD *)v17 + 1);
        v20 = bswap32(*(_DWORD *)v17);
        *(_DWORD *)bytes = bswap32(v19);
        v21 = v20;
        v22 = v20 - 8;
        v23 = v15 - 8 >= v22;
        v15 -= v20;
        if (!v23)
          break;
        if (v19 != 1701147238)
        {
          v24 = CFDataCreate(v18, v17 + 8, v22);
          if (!v24)
            break;
          v25 = v24;
          *(_DWORD *)bytes = bswap32(*(unsigned int *)bytes);
          v26 = CFStringCreateWithBytes(v18, bytes, 4, 0, 0);
          if (!v26)
          {
            CFRelease(v25);
            break;
          }
          v27 = v26;
          if (!Mutable)
          {
            Mutable = CFDictionaryCreateMutable(v18, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            if (!Mutable)
            {
              CFRelease(v25);
              CFRelease(v27);
              goto LABEL_39;
            }
          }
          CFDictionaryAddValue(Mutable, v27, v25);
          CFRelease(v27);
          CFRelease(v25);
        }
        v17 += v21;
      }
      while (v15 > 8);
      if (!Mutable)
        goto LABEL_40;
      *(_QWORD *)&values[0] = CFRetain(Mutable);
      keys[0] = CFSTR("SampleDescriptionExtensionAtoms");
      v29 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (*(_QWORD *)&values[0])
        CFRelease(*(CFTypeRef *)&values[0]);
      v30 = 0;
      *(_QWORD *)&values[0] = 0;
      if (!v29)
      {
        v31 = -12713;
        v32 = 0;
        goto LABEL_42;
      }
    }
    v31 = 0;
    v32 = v30;
    v30 = 1;
LABEL_42:
    v33 = (CFTypeRef *)values;
    do
    {
      if (*v33)
        CFRelease(*v33);
      ++v33;
    }
    while (v33 < v45);
    if ((v32 & 1) == 0)
      CFRelease(Mutable);
    if ((v30 & 1) != 0)
    {
      v31 = CMFormatDescriptionCreate(allocator, 0x636C6370u, mediaSubType, v29, formatDescriptionOut);
      if (v29)
        CFRelease(v29);
    }
    return v31;
  }
  if (v12 == 1667462241)
    goto LABEL_18;
  v14 = 14179;
LABEL_17:
  if (v12 == (v14 | 0x38300000))
    goto LABEL_18;
  v28 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (!v28)
    return CMFormatDescriptionCreate(allocator, 0x636C6370u, v13, 0, formatDescriptionOut);
  return v28;
}

OSStatus CMClosedCaptionFormatDescriptionCreateFromBigEndianClosedCaptionDescriptionBlockBuffer(CFAllocatorRef allocator, CMBlockBufferRef closedCaptionDescriptionBlockBuffer, CMClosedCaptionDescriptionFlavor flavor, CMClosedCaptionFormatDescriptionRef *formatDescriptionOut)
{
  size_t DataLength;
  void *v8;
  CMClosedCaptionDescriptionFlavor v9;
  OSStatus Contiguous;
  CFTypeRef cf;
  char *dataPointerOut;

  cf = 0;
  if (!closedCaptionDescriptionBlockBuffer)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  dataPointerOut = 0;
  DataLength = CMBlockBufferGetDataLength(closedCaptionDescriptionBlockBuffer);
  if (CMBlockBufferIsRangeContiguous(closedCaptionDescriptionBlockBuffer, 0, 0))
  {
    v8 = (void *)CFRetain(closedCaptionDescriptionBlockBuffer);
    cf = v8;
  }
  else
  {
    Contiguous = CMBlockBufferCreateContiguous(allocator, closedCaptionDescriptionBlockBuffer, allocator, 0, 0, DataLength, 0, (CMBlockBufferRef *)&cf);
    if (Contiguous)
      goto LABEL_7;
    v8 = (void *)cf;
  }
  CMBlockBufferGetDataPointer((CMBlockBufferRef)v8, 0, 0, 0, &dataPointerOut);
  Contiguous = CMClosedCaptionFormatDescriptionCreateFromBigEndianClosedCaptionDescriptionData(allocator, (const uint8_t *)dataPointerOut, DataLength, v9, formatDescriptionOut);
LABEL_7:
  if (cf)
    CFRelease(cf);
  return Contiguous;
}

OSStatus CMClosedCaptionFormatDescriptionCopyAsBigEndianClosedCaptionDescriptionBlockBuffer(CFAllocatorRef allocator, CMClosedCaptionFormatDescriptionRef closedCaptionFormatDescription, CMClosedCaptionDescriptionFlavor flavor, CMBlockBufferRef *blockBufferOut)
{
  CFTypeID TypeID;
  const __CFDictionary *Extensions;
  const __CFDictionary *Value;
  const __CFDictionary *v10;
  size_t Count;
  int64_t v12;
  const void **v13;
  const void **v14;
  size_t v15;
  CFTypeRef *v16;
  int64_t v17;
  CFTypeID v18;
  CFTypeID v19;
  OSStatus DataPointer;
  OSStatus v21;
  const void **v22;
  size_t v24;
  OSStatus v25;
  FourCharCode MediaSubType;
  int8x8_t *v27;
  size_t DataLength;
  CFTypeRef *v29;
  CFTypeRef *v30;
  CFTypeID v31;
  CFTypeID v32;
  int Length;
  char *v34;
  const UInt8 *BytePtr;
  size_t v36;
  CFIndex v37;
  const void **v38;
  char *v39;
  CMBlockBufferRef v40;
  char *dataPointerOut;
  CMBlockBufferRef theBuffer;
  CFRange v43;

  v39 = 0;
  v40 = 0;
  if (!closedCaptionFormatDescription)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  TypeID = CMFormatDescriptionGetTypeID();
  if (TypeID != CFGetTypeID(closedCaptionFormatDescription)
    || CMFormatDescriptionGetMediaType(closedCaptionFormatDescription) != 1668047728
    || !blockBufferOut)
  {
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  Extensions = CMFormatDescriptionGetExtensions(closedCaptionFormatDescription);
  if (!Extensions)
  {
    v12 = 0;
    v24 = 16;
    goto LABEL_31;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("SampleDescriptionExtensionAtoms"));
  if (Value)
  {
    v10 = Value;
    dataPointerOut = 0;
    theBuffer = 0;
    Count = CFDictionaryGetCount(Value);
    v12 = Count;
    if (Count)
    {
      v13 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
      v14 = (const void **)malloc_type_calloc(v12, 8uLL, 0xC0040B8AA526DuLL);
      CFDictionaryGetKeysAndValues(v10, v13, v14);
      v38 = v13;
      v15 = 0;
      if (v12 >= 1)
      {
        v16 = v14;
        v17 = v12;
        do
        {
          if (*v16)
          {
            v18 = CFGetTypeID(*v16);
            if (v18 == CFDataGetTypeID())
            {
              if (*v13)
              {
                v19 = CFGetTypeID(*v13);
                if (v19 == CFStringGetTypeID())
                  v15 += CFDataGetLength((CFDataRef)*v16) + 8;
              }
            }
          }
          ++v13;
          ++v16;
          --v17;
        }
        while (v17);
      }
      DataPointer = CMBlockBufferCreateWithMemoryBlock(allocator, 0, v15, allocator, 0, 0, v15, 1u, &theBuffer);
      if (DataPointer || (DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut)) != 0)
      {
        v21 = DataPointer;
        v12 = 0;
        v22 = v38;
        if (!v38)
          goto LABEL_20;
      }
      else
      {
        v22 = v38;
        if (v12 >= 1)
        {
          v29 = v14;
          v30 = v38;
          do
          {
            if (*v29)
            {
              v31 = CFGetTypeID(*v29);
              if (v31 == CFDataGetTypeID())
              {
                if (*v30)
                {
                  v32 = CFGetTypeID(*v30);
                  if (v32 == CFStringGetTypeID())
                  {
                    Length = CFDataGetLength((CFDataRef)*v29);
                    *(_DWORD *)dataPointerOut = bswap32(Length + 8);
                    dataPointerOut += 4;
                    v43.location = 0;
                    v43.length = 4;
                    CFStringGetBytes((CFStringRef)*v30, v43, 0, 0, 0, (UInt8 *)dataPointerOut, 4, 0);
                    dataPointerOut += 4;
                    v34 = dataPointerOut;
                    BytePtr = CFDataGetBytePtr((CFDataRef)*v29);
                    v36 = CFDataGetLength((CFDataRef)*v29);
                    memcpy(v34, BytePtr, v36);
                    v37 = CFDataGetLength((CFDataRef)*v29);
                    dataPointerOut += v37;
                  }
                }
              }
            }
            ++v30;
            ++v29;
            --v12;
          }
          while (v12);
        }
        v21 = 0;
        v12 = (int64_t)theBuffer;
        theBuffer = 0;
        if (!v38)
        {
LABEL_20:
          if (v14)
            free(v14);
          if (theBuffer)
            CFRelease(theBuffer);
          if (v21)
          {
            if (v12)
            {
              CFRelease((CFTypeRef)v12);
              v12 = 0;
            }
            goto LABEL_34;
          }
          goto LABEL_30;
        }
      }
      free(v22);
      goto LABEL_20;
    }
  }
  else
  {
    v12 = 0;
  }
LABEL_30:
  v24 = CMBlockBufferGetDataLength((CMBlockBufferRef)v12) + 16;
LABEL_31:
  v25 = CMBlockBufferCreateWithMemoryBlock(allocator, 0, v24, allocator, 0, 0, v24, 1u, &v40);
  if (!v25)
  {
    v25 = CMBlockBufferGetDataPointer(v40, 0, 0, 0, &v39);
    if (!v25)
    {
      *(_DWORD *)v39 = v24;
      MediaSubType = CMFormatDescriptionGetMediaSubType(closedCaptionFormatDescription);
      v27 = (int8x8_t *)v39;
      *((_DWORD *)v39 + 1) = MediaSubType;
      v27[1] = (int8x8_t)0xFFFF000000000000;
      flipClosedCaptionDescriptionData(v27);
      if (!v12
        || (DataLength = CMBlockBufferGetDataLength((CMBlockBufferRef)v12),
            (v25 = CMBlockBufferCopyDataBytes((CMBlockBufferRef)v12, 0, DataLength, v39 + 16)) == 0))
      {
        v21 = 0;
        *blockBufferOut = v40;
        v40 = 0;
        if (!v12)
          return v21;
        goto LABEL_37;
      }
    }
  }
  v21 = v25;
LABEL_34:
  if (v40)
    CFRelease(v40);
  if (!v12)
    return v21;
LABEL_37:
  CFRelease((CFTypeRef)v12);
  return v21;
}

OSStatus CMSwapBigEndianTextDescriptionToHost(uint8_t *textDescriptionData, size_t textDescriptionSize)
{
  flipTextDescriptionData(bswap32(*((_DWORD *)textDescriptionData + 1)), (unsigned __int16 *)textDescriptionData);
  return 0;
}

int8x8_t flipTextDescriptionData(int a1, unsigned __int16 *__dst)
{
  int v4;
  size_t v5;
  unsigned int v6;
  int8x8_t result;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unsigned int v16;
  _OWORD __src[3];

  memset(__src, 0, 46);
  if (a1 > 2004251763)
  {
    if (a1 == 2021028980)
    {
LABEL_7:
      __src[0] = *(_OWORD *)__dst;
      *(int8x8_t *)&__src[0] = vrev32_s8(*(int8x8_t *)&__src[0]);
      DWORD2(__src[0]) = bswap32(DWORD2(__src[0]));
      WORD6(__src[0]) = bswap32(WORD6(__src[0])) >> 16;
      HIWORD(__src[0]) = bswap32(HIWORD(__src[0])) >> 16;
      v5 = 16;
      goto LABEL_9;
    }
    v4 = 2004251764;
  }
  else
  {
    if (a1 == 1937010800)
    {
      __src[0] = *(_OWORD *)__dst;
      *(int8x8_t *)&__src[0] = vrev32_s8(*(int8x8_t *)&__src[0]);
      DWORD2(__src[0]) = bswap32(DWORD2(__src[0]));
      WORD6(__src[0]) = bswap32(WORD6(__src[0])) >> 16;
      HIWORD(__src[0]) = bswap32(HIWORD(__src[0])) >> 16;
      result = *(int8x8_t *)&__src[0];
      *(_OWORD *)__dst = __src[0];
      return result;
    }
    v4 = 1937142900;
  }
  if (a1 == v4)
    goto LABEL_7;
  __src[0] = *(_OWORD *)__dst;
  v6 = *((_DWORD *)__dst + 4);
  *(int8x8_t *)&__src[0] = vrev32_s8(*(int8x8_t *)&__src[0]);
  DWORD2(__src[0]) = bswap32(DWORD2(__src[0]));
  WORD6(__src[0]) = bswap32(WORD6(__src[0])) >> 16;
  HIWORD(__src[0]) = bswap32(HIWORD(__src[0])) >> 16;
  LODWORD(__src[1]) = bswap32(v6);
  v5 = 20;
LABEL_9:
  memcpy(__dst, __src, v5);
  if (a1 == 1952807028)
  {
    *((_DWORD *)__dst + 5) = bswap32(*((_DWORD *)__dst + 5));
    v11 = bswap32(__dst[13]);
    v12 = bswap32(__dst[14]);
    __dst[12] = bswap32(__dst[12]) >> 16;
    __dst[13] = HIWORD(v11);
    __dst[14] = HIWORD(v12);
    v13 = *(_QWORD *)(__dst + 15);
    v14 = HIDWORD(v13);
    v15 = HIWORD(v13);
    LODWORD(v13) = bswap32(v13);
    *(_QWORD *)(__dst + 15) = ((unint64_t)(bswap32(v14) >> 16) << 32) | ((unint64_t)__rev16(v15) << 48) | ((unint64_t)(unsigned __int16)v13 << 16) | WORD1(v13);
    LODWORD(v14) = bswap32(__dst[21]);
    LODWORD(v15) = bswap32(__dst[22]);
    v16 = bswap32(__dst[23]);
    result = vrev16_s8(*(int8x8_t *)(__dst + 25));
    *(_DWORD *)(__dst + 19) = bswap32(*(_DWORD *)(__dst + 19));
    __dst[21] = WORD1(v14);
    __dst[22] = WORD1(v15);
    __dst[23] = HIWORD(v16);
    *(int8x8_t *)(__dst + 25) = result;
  }
  else if (a1 == 1954034535)
  {
    v8 = *(_QWORD *)(__dst + 13);
    v9 = HIDWORD(v8);
    v10 = HIWORD(v8);
    LODWORD(v8) = bswap32(v8);
    *(_QWORD *)(__dst + 13) = ((unint64_t)(bswap32(v9) >> 16) << 32) | ((unint64_t)__rev16(v10) << 48) | ((unint64_t)(unsigned __int16)v8 << 16) | WORD1(v8);
    LODWORD(v9) = bswap32(__dst[18]) >> 16;
    LODWORD(v10) = bswap32(__dst[19]);
    __dst[17] = bswap32(__dst[17]) >> 16;
    __dst[18] = v9;
    __dst[19] = WORD1(v10);
  }
  return result;
}

OSStatus CMSwapHostEndianTextDescriptionToBig(uint8_t *textDescriptionData, size_t textDescriptionSize)
{
  flipTextDescriptionData(*((_DWORD *)textDescriptionData + 1), (unsigned __int16 *)textDescriptionData);
  return 0;
}

OSStatus CMTextFormatDescriptionCreateFromBigEndianTextDescriptionData(CFAllocatorRef allocator, const uint8_t *textDescriptionData, size_t size, CMTextDescriptionFlavor flavor, CMMediaType mediaType, CMTextFormatDescriptionRef *formatDescriptionOut)
{
  CMFormatDescriptionRef *v6;
  uint64_t v10;
  OSStatus Dict;
  CFTypeRef v12;
  int v15;
  CFIndex v17;
  __int128 v18;
  const __CFAllocator *v19;
  CFNumberRef v20;
  CFNumberRef v21;
  CFNumberRef v22;
  CFNumberRef v23;
  OSStatus v24;
  CFNumberRef v25;
  CFNumberRef v26;
  CFNumberRef v27;
  CFNumberRef v28;
  CFNumberRef v29;
  CFNumberRef v30;
  CFNumberRef v31;
  CFNumberRef v32;
  CFNumberRef v33;
  CFNumberRef v34;
  CFNumberRef v35;
  CFNumberRef v36;
  CFNumberRef v37;
  CFNumberRef v38;
  CFNumberRef v39;
  CFNumberRef v40;
  CFIndex v41;
  __int128 v42;
  const __CFAllocator *v43;
  CFNumberRef v44;
  CFNumberRef v45;
  CFNumberRef v46;
  OSStatus v47;
  CFNumberRef v48;
  CFNumberRef v49;
  CFNumberRef v50;
  CFNumberRef v51;
  CFNumberRef v52;
  CFNumberRef v53;
  CFNumberRef v54;
  CFNumberRef v55;
  CFNumberRef v56;
  CFNumberRef v57;
  CFNumberRef v58;
  CFNumberRef v59;
  CFNumberRef v60;
  CFStringRef v61;
  CFNumberRef v62;
  CFNumberRef v63;
  CFTypeRef *v64;
  CFIndex v65;
  char *v66;
  CFTypeRef *v67;
  CFTypeRef *v68;
  CFTypeRef v69;
  CFTypeRef *v70;
  CFTypeRef *v71;
  CFTypeRef *v72;
  _QWORD *v73;
  CFTypeRef *v74;
  CFStringRef v75;
  CFStringRef v76;
  CFStringRef v77;
  const __CFAllocator *v78;
  int v79;
  CFIndex v80;
  CFTypeRef *v81;
  uint64_t v82;
  CFTypeRef *v83;
  CFStringRef v84;
  CFStringRef v85;
  CFStringRef v86;
  CFTypeRef *v87;
  CFTypeRef *v88;
  CFStringRef v89;
  CFTypeRef v91;
  CFTypeRef v92;
  CFTypeRef cf;
  CFTypeRef v94;
  CFTypeRef v95;
  CFTypeRef v96;
  unsigned int valuePtr;
  CFTypeRef v98;
  CFTypeRef v99[2];
  __int128 v100;
  _BYTE v101[27];
  CFTypeRef v102[2];
  _BYTE v103[32];
  const __CFString *v104;
  CFTypeRef v105[2];
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  CFTypeRef v113;
  const __CFString *v114;
  const __CFString *v115;
  const __CFString *v116;
  CFTypeRef v117;
  const __CFString *v118;
  const __CFString *v119;
  const __CFString *v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  _QWORD v141[2];

  v6 = formatDescriptionOut;
  v141[0] = *MEMORY[0x1E0C80C00];
  if (size <= 7)
    goto LABEL_2;
  v15 = bswap32(*((_DWORD *)textDescriptionData + 1));
  if (v15 <= 1952807027)
  {
    if (v15 == 1685220724)
      goto LABEL_26;
    if (v15 != 1937010800)
    {
      if (v15 != 1937142900)
      {
LABEL_17:
        v10 = 4294954579;
        goto LABEL_3;
      }
      goto LABEL_23;
    }
    v113 = 0;
    v139 = 0u;
    v140 = 0u;
    v137 = 0u;
    v138 = 0u;
    v135 = 0u;
    v136 = 0u;
    v133 = 0u;
    v134 = 0u;
    v131 = 0u;
    v132 = 0u;
    v129 = 0u;
    v130 = 0u;
    v127 = 0u;
    v128 = 0u;
    v125 = 0u;
    v126 = 0u;
    v123 = 0u;
    v124 = 0u;
    v121 = 0u;
    v122 = 0u;
    v98 = 0;
    LOBYTE(v96) = 0;
    LOBYTE(v95) = 0;
    LOBYTE(v94) = 0;
    LOBYTE(cf) = 0;
    if (size <= 0x10)
      goto LABEL_2;
    v105[0] = 0;
    v105[1] = 0;
    v99[0] = 0;
    v99[1] = 0;
    v102[0] = 0;
    v102[1] = 0;
    v117 = 0;
    v118 = 0;
    if (locateXMLSubtitleSampleFields((uint64_t)textDescriptionData, size, (char *)&v96, (uint64_t *)v105, (char *)&v95, (size_t *)v99, (char *)&v94, (size_t *)v102, (char *)&cf, &v117)|| !(_BYTE)v96|| (_BYTE)cf && (!(_BYTE)v95 || !(_BYTE)v94)|| (char *)v105[1] + 16 > (CFTypeRef)size|| (char *)v105[0] + (unint64_t)v105[1] > (CFTypeRef)size)
    {
      goto LABEL_161;
    }
    if ((_BYTE)v95)
    {
      v66 = (char *)v99[1] + (unint64_t)v105[1] + 16;
      if ((unint64_t)v66 > size
        || (char *)v99[0] + (unint64_t)v99[1] > (CFTypeRef)size
        || (_BYTE)v94
        && ((unint64_t)v102[1] + (unint64_t)v66 > size
         || (char *)v102[0] + (unint64_t)v102[1] > (CFTypeRef)size))
      {
        goto LABEL_161;
      }
    }
    else if ((_BYTE)v94)
    {
      goto LABEL_161;
    }
    if ((uint64_t)v105[1] > 1)
    {
      v78 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v75 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &textDescriptionData[(unint64_t)v105[0]], (CFIndex)v105[1] - 1, 0x8000100u, 1u);
      if (v75)
      {
        v76 = 0;
        if (!(_BYTE)v95
          || (uint64_t)v99[1] < 2
          || (v76 = CFStringCreateWithBytes(v78, &textDescriptionData[(unint64_t)v99[0]], (CFIndex)v99[1] - 1, 0x8000100u, 1u)) != 0)
        {
          v77 = 0;
          if ((_BYTE)v94
            && (uint64_t)v102[1] >= 2
            && (v77 = CFStringCreateWithBytes(v78, &textDescriptionData[(unint64_t)v102[0]], (CFIndex)v102[1] - 1, 0x8000100u, 1u)) == 0)
          {
            Dict = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
            v12 = 0;
          }
          else
          {
            v79 = ParseExtensionAtomsInDescription((uint64_t)textDescriptionData, size, 0, 0, 0, (__CFDictionary **)&v98);
            v80 = 0;
            if (!v79)
            {
              v89 = v75;
              v81 = (CFTypeRef *)&v131;
              if (v98)
              {
                v81 = (CFTypeRef *)&v131 + 1;
                *(_QWORD *)&v131 = CFRetain(v98);
                *(_QWORD *)&v121 = CFSTR("SampleDescriptionExtensionAtoms");
                v82 = 1;
              }
              else
              {
                v82 = 0;
              }
              *v81 = CFRetain(v89);
              v83 = v81 + 1;
              v80 = v82 + 1;
              *(_QWORD *)((unint64_t)&v121 | (8 * v82)) = CFSTR("XMLNamespaces");
              if (v76)
              {
                v83 = v81 + 2;
                v81[1] = CFRetain(v76);
                *((_QWORD *)&v121 + v80) = CFSTR("XMLSchemas");
                v80 = v82 | 2;
              }
              v75 = v89;
              if (v77)
              {
                *v83 = CFRetain(v77);
                *((_QWORD *)&v121 + v80++) = CFSTR("AuxiliaryMIMETypes");
              }
            }
            Dict = createDict(allocator, (const void **)&v121, (const void **)&v131, v80, (CFDictionaryRef *)&v113);
            v12 = v113;
          }
LABEL_181:
          v84 = v77;
          v85 = v76;
          if (Dict && v12)
          {
            v86 = v75;
            CFRelease(v12);
            v12 = 0;
          }
          else
          {
            v86 = v75;
          }
          v87 = (CFTypeRef *)&v131;
          do
          {
            if (*v87)
              CFRelease(*v87);
            ++v87;
          }
          while (v87 < v141);
          if (v86)
            CFRelease(v86);
          if (v85)
            CFRelease(v85);
          if (v84)
            CFRelease(v84);
          v69 = v98;
          v6 = formatDescriptionOut;
          if (v98)
            goto LABEL_196;
          goto LABEL_4;
        }
        Dict = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
        v12 = 0;
LABEL_163:
        v77 = 0;
        goto LABEL_181;
      }
      Dict = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
      v12 = 0;
LABEL_162:
      v76 = 0;
      goto LABEL_163;
    }
LABEL_161:
    Dict = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    v12 = 0;
    v75 = 0;
    goto LABEL_162;
  }
  if (v15 <= 2004251763)
  {
    if (v15 != 1952807028)
    {
      if (v15 != 1954034535)
        goto LABEL_17;
LABEL_26:
      v98 = 0;
      v95 = 0;
      v96 = 0;
      cf = 0;
      v94 = 0;
      v117 = CFSTR("Red");
      v118 = CFSTR("Green");
      v119 = CFSTR("Blue");
      v120 = CFSTR("Alpha");
      v113 = CFSTR("Top");
      v114 = CFSTR("Left");
      v115 = CFSTR("Bottom");
      v116 = CFSTR("Right");
      v99[0] = CFSTR("StartChar");
      v99[1] = CFSTR("EndChar");
      *(_QWORD *)&v100 = CFSTR("Font");
      *((_QWORD *)&v100 + 1) = CFSTR("FontFace");
      *(_QWORD *)v101 = CFSTR("FontSize");
      *(_QWORD *)&v101[8] = CFSTR("ForegroundColor");
      v111 = 0u;
      v112 = 0u;
      v109 = 0u;
      v110 = 0u;
      v107 = 0u;
      v108 = 0u;
      *(_OWORD *)v105 = 0u;
      v106 = 0u;
      v139 = 0u;
      v140 = 0u;
      v137 = 0u;
      v138 = 0u;
      v135 = 0u;
      v136 = 0u;
      v133 = 0u;
      v134 = 0u;
      v131 = 0u;
      v132 = 0u;
      v129 = 0u;
      v130 = 0u;
      v127 = 0u;
      v128 = 0u;
      v125 = 0u;
      v126 = 0u;
      v123 = 0u;
      v124 = 0u;
      v121 = 0u;
      v122 = 0u;
      v91 = 0;
      v92 = 0;
      if (size > 0x2D)
      {
        v18 = *((_OWORD *)textDescriptionData + 1);
        *(_OWORD *)v102 = *(_OWORD *)textDescriptionData;
        *(_OWORD *)v103 = v18;
        *(_OWORD *)&v103[14] = *(_OWORD *)(textDescriptionData + 30);
        v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v20 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt8Type, &v103[6]);
        if (!v20)
          goto LABEL_94;
        v105[0] = v20;
        v21 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[7]);
        if (!v21)
          goto LABEL_94;
        v105[1] = v21;
        v22 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[8]);
        if (!v22)
          goto LABEL_94;
        *(_QWORD *)&v106 = v22;
        v23 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[9]);
        if (!v23)
          goto LABEL_94;
        *((_QWORD *)&v106 + 1) = v23;
        v24 = createDict(allocator, &v117, v105, 4, (CFDictionaryRef *)&v96);
        if (!v24)
        {
          LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v103[10]) >> 16;
          v25 = CFNumberCreate(v19, kCFNumberSInt16Type, &valuePtr);
          if (!v25)
            goto LABEL_94;
          v105[0] = v25;
          LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v103[12]) >> 16;
          v26 = CFNumberCreate(v19, kCFNumberSInt16Type, &valuePtr);
          if (!v26)
            goto LABEL_94;
          v105[1] = v26;
          LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v103[14]) >> 16;
          v27 = CFNumberCreate(v19, kCFNumberSInt16Type, &valuePtr);
          if (!v27)
            goto LABEL_94;
          *(_QWORD *)&v106 = v27;
          LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v103[16]) >> 16;
          v28 = CFNumberCreate(v19, kCFNumberSInt16Type, &valuePtr);
          if (!v28)
            goto LABEL_94;
          *((_QWORD *)&v106 + 1) = v28;
          v24 = createDict(allocator, &v113, v105, 4, (CFDictionaryRef *)&v95);
          if (!v24)
          {
            v29 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[26]);
            if (!v29)
              goto LABEL_94;
            v105[0] = v29;
            v30 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[27]);
            if (!v30)
              goto LABEL_94;
            v105[1] = v30;
            v31 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[28]);
            if (!v31)
              goto LABEL_94;
            *(_QWORD *)&v106 = v31;
            v32 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[29]);
            if (!v32)
              goto LABEL_94;
            *((_QWORD *)&v106 + 1) = v32;
            v24 = createDict(allocator, &v117, v105, 4, (CFDictionaryRef *)&cf);
            if (!v24)
            {
              LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v103[18]) >> 16;
              v33 = CFNumberCreate(v19, kCFNumberSInt16Type, &valuePtr);
              if (!v33)
                goto LABEL_94;
              v105[0] = v33;
              LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v103[20]) >> 16;
              v34 = CFNumberCreate(v19, kCFNumberSInt16Type, &valuePtr);
              if (!v34)
                goto LABEL_94;
              v105[1] = v34;
              LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v103[22]) >> 16;
              v35 = CFNumberCreate(v19, kCFNumberSInt16Type, &valuePtr);
              if (!v35)
                goto LABEL_94;
              *(_QWORD *)&v106 = v35;
              v36 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[24]);
              if (!v36)
                goto LABEL_94;
              *((_QWORD *)&v106 + 1) = v36;
              v37 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[25]);
              if (!v37)
                goto LABEL_94;
              *(_QWORD *)&v107 = v37;
              *((_QWORD *)&v107 + 1) = CFRetain(cf);
              v24 = createDict(allocator, v99, v105, 6, (CFDictionaryRef *)&v94);
              if (!v24)
              {
                valuePtr = bswap32(*(unsigned int *)v103);
                v38 = CFNumberCreate(v19, kCFNumberSInt32Type, &valuePtr);
                if (v38)
                {
                  *(_QWORD *)&v131 = v38;
                  *(_QWORD *)&v121 = CFSTR("DisplayFlags");
                  v39 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[4]);
                  if (v39)
                  {
                    *((_QWORD *)&v131 + 1) = v39;
                    *((_QWORD *)&v121 + 1) = CFSTR("HorizontalJustification");
                    v40 = CFNumberCreate(v19, kCFNumberSInt8Type, &v103[5]);
                    if (v40)
                    {
                      *(_QWORD *)&v132 = v40;
                      *(_QWORD *)&v122 = CFSTR("VerticalJustification");
                      *((_QWORD *)&v132 + 1) = CFRetain(v96);
                      *((_QWORD *)&v122 + 1) = CFSTR("BackgroundColor");
                      *(_QWORD *)&v133 = CFRetain(v95);
                      *(_QWORD *)&v123 = CFSTR("DefaultTextBox");
                      *((_QWORD *)&v133 + 1) = CFRetain(v94);
                      *((_QWORD *)&v123 + 1) = CFSTR("DefaultStyle");
                      if (ParseExtensionAtomsInDescription((uint64_t)textDescriptionData, size, (__CFDictionary **)&v92, 0, 0, (__CFDictionary **)&v91))
                      {
                        v41 = 6;
                      }
                      else
                      {
                        if (v92)
                        {
                          v88 = (CFTypeRef *)&v134 + 1;
                          *(_QWORD *)&v134 = CFRetain(v92);
                          *(_QWORD *)&v124 = CFSTR("FontTable");
                          v41 = 7;
                        }
                        else
                        {
                          v88 = (CFTypeRef *)&v134;
                          v41 = 6;
                        }
                        if (v91)
                        {
                          *v88 = CFRetain(v91);
                          *((_QWORD *)&v121 + v41++) = CFSTR("SampleDescriptionExtensionAtoms");
                        }
                      }
                      Dict = createDict(allocator, (const void **)&v121, (const void **)&v131, v41, (CFDictionaryRef *)&v98);
                      v12 = v98;
                      if (Dict && v98)
                      {
                        CFRelease(v98);
                        goto LABEL_220;
                      }
LABEL_95:
                      v67 = v105;
                      do
                      {
                        if (*v67)
                          CFRelease(*v67);
                        ++v67;
                      }
                      while (v67 < &v113);
                      v68 = (CFTypeRef *)&v131;
                      do
                      {
                        if (*v68)
                          CFRelease(*v68);
                        ++v68;
                      }
                      while (v68 < v141);
                      if (v92)
                        CFRelease(v92);
                      if (v91)
                        CFRelease(v91);
                      if (v96)
                        CFRelease(v96);
                      if (v95)
                        CFRelease(v95);
                      if (v94)
                        CFRelease(v94);
                      v69 = cf;
                      if (!cf)
                        goto LABEL_4;
LABEL_196:
                      CFRelease(v69);
                      goto LABEL_4;
                    }
                  }
                }
LABEL_94:
                v12 = 0;
                Dict = -12713;
                goto LABEL_95;
              }
            }
          }
        }
        Dict = v24;
LABEL_220:
        v12 = 0;
        goto LABEL_95;
      }
LABEL_2:
      v10 = 4294954582;
LABEL_3:
      Dict = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
      v12 = 0;
      goto LABEL_4;
    }
    v98 = 0;
    v95 = 0;
    v96 = 0;
    cf = 0;
    v94 = 0;
    v113 = CFSTR("Red");
    v114 = CFSTR("Green");
    v115 = CFSTR("Blue");
    v117 = CFSTR("Top");
    v118 = CFSTR("Left");
    v119 = CFSTR("Bottom");
    v120 = CFSTR("Right");
    v102[0] = CFSTR("StartChar");
    v102[1] = CFSTR("Height");
    *(_QWORD *)v103 = CFSTR("Ascent");
    *(_QWORD *)&v103[8] = CFSTR("Font");
    *(_QWORD *)&v103[16] = CFSTR("FontFace");
    *(_QWORD *)&v103[24] = CFSTR("FontSize");
    v104 = CFSTR("ForegroundColor");
    v111 = 0u;
    v112 = 0u;
    v109 = 0u;
    v110 = 0u;
    v107 = 0u;
    v108 = 0u;
    *(_OWORD *)v105 = 0u;
    v106 = 0u;
    v139 = 0u;
    v140 = 0u;
    v137 = 0u;
    v138 = 0u;
    v135 = 0u;
    v136 = 0u;
    v133 = 0u;
    v134 = 0u;
    v131 = 0u;
    v132 = 0u;
    v129 = 0u;
    v130 = 0u;
    v127 = 0u;
    v128 = 0u;
    v125 = 0u;
    v126 = 0u;
    v123 = 0u;
    v124 = 0u;
    v121 = 0u;
    v122 = 0u;
    v91 = 0;
    v92 = 0;
    if (size <= 0x3A || (unint64_t)textDescriptionData[58] + 59 > size)
      goto LABEL_2;
    v42 = *((_OWORD *)textDescriptionData + 1);
    *(_OWORD *)v99 = *(_OWORD *)textDescriptionData;
    v100 = v42;
    *(_OWORD *)v101 = *((_OWORD *)textDescriptionData + 2);
    *(_OWORD *)&v101[11] = *(_OWORD *)(textDescriptionData + 43);
    LOWORD(valuePtr) = bswap32(WORD4(v42)) >> 16;
    v43 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v44 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt16Type, &valuePtr);
    if (v44)
    {
      v105[0] = v44;
      LOWORD(valuePtr) = bswap32(WORD5(v100)) >> 16;
      v45 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
      if (v45)
      {
        v105[1] = v45;
        LOWORD(valuePtr) = bswap32(WORD6(v100)) >> 16;
        v46 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
        if (v46)
        {
          *(_QWORD *)&v106 = v46;
          v47 = createDict(allocator, &v113, v105, 3, (CFDictionaryRef *)&v96);
          if (v47)
            goto LABEL_202;
          LOWORD(valuePtr) = bswap32(HIWORD(v100)) >> 16;
          v48 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
          if (v48)
          {
            v105[0] = v48;
            LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)v101) >> 16;
            v49 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
            if (v49)
            {
              v105[1] = v49;
              LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[2]) >> 16;
              v50 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
              if (v50)
              {
                *(_QWORD *)&v106 = v50;
                LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[4]) >> 16;
                v51 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                if (v51)
                {
                  *((_QWORD *)&v106 + 1) = v51;
                  v47 = createDict(allocator, &v117, v105, 4, (CFDictionaryRef *)&v95);
                  if (v47)
                    goto LABEL_202;
                  LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[20]) >> 16;
                  v52 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                  if (v52)
                  {
                    v105[0] = v52;
                    LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[22]) >> 16;
                    v53 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                    if (v53)
                    {
                      v105[1] = v53;
                      LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[24]) >> 16;
                      v54 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                      if (v54)
                      {
                        *(_QWORD *)&v106 = v54;
                        v47 = createDict(allocator, &v113, v105, 3, (CFDictionaryRef *)&cf);
                        if (v47)
                          goto LABEL_202;
                        valuePtr = bswap32(*(unsigned int *)&v101[6]);
                        v55 = CFNumberCreate(v43, kCFNumberSInt32Type, &valuePtr);
                        if (v55)
                        {
                          v105[0] = v55;
                          LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[10]) >> 16;
                          v56 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                          if (v56)
                          {
                            v105[1] = v56;
                            LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[12]) >> 16;
                            v57 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                            if (v57)
                            {
                              *(_QWORD *)&v106 = v57;
                              LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[14]) >> 16;
                              v58 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                              if (v58)
                              {
                                *((_QWORD *)&v106 + 1) = v58;
                                v59 = CFNumberCreate(v43, kCFNumberSInt8Type, &v101[16]);
                                if (v59)
                                {
                                  *(_QWORD *)&v107 = v59;
                                  LOWORD(valuePtr) = bswap32(*(unsigned __int16 *)&v101[18]) >> 16;
                                  v60 = CFNumberCreate(v43, kCFNumberSInt16Type, &valuePtr);
                                  if (v60)
                                  {
                                    *((_QWORD *)&v107 + 1) = v60;
                                    *(_QWORD *)&v108 = CFRetain(cf);
                                    v47 = createDict(allocator, v102, v105, 7, (CFDictionaryRef *)&v94);
                                    if (!v47)
                                    {
                                      v61 = CFStringCreateWithPascalString(allocator, textDescriptionData + 58, 0);
                                      valuePtr = bswap32(v100);
                                      v62 = CFNumberCreate(v43, kCFNumberSInt32Type, &valuePtr);
                                      if (v62)
                                      {
                                        *(_QWORD *)&v131 = v62;
                                        *(_QWORD *)&v121 = CFSTR("DisplayFlags");
                                        valuePtr = bswap32(DWORD1(v100));
                                        v63 = CFNumberCreate(v43, kCFNumberSInt32Type, &valuePtr);
                                        if (v63)
                                        {
                                          *((_QWORD *)&v131 + 1) = v63;
                                          *((_QWORD *)&v121 + 1) = CFSTR("TextJustification");
                                          *(_QWORD *)&v132 = CFRetain(v96);
                                          *(_QWORD *)&v122 = CFSTR("BackgroundColor");
                                          *((_QWORD *)&v132 + 1) = CFRetain(v95);
                                          *((_QWORD *)&v122 + 1) = CFSTR("DefaultTextBox");
                                          *(_QWORD *)&v133 = CFRetain(v94);
                                          *(_QWORD *)&v123 = CFSTR("DefaultStyle");
                                          if (v61)
                                          {
                                            v64 = (CFTypeRef *)&v134;
                                            *((_QWORD *)&v133 + 1) = CFRetain(v61);
                                            *((_QWORD *)&v123 + 1) = CFSTR("DefaultFontName");
                                            v65 = 6;
                                          }
                                          else
                                          {
                                            v64 = (CFTypeRef *)&v133 + 1;
                                            v65 = 5;
                                          }
                                          if (!ParseExtensionAtomsInDescription((uint64_t)textDescriptionData, size, (__CFDictionary **)&v92, 0, 0, (__CFDictionary **)&v91))
                                          {
                                            if (v92)
                                            {
                                              *v64++ = CFRetain(v92);
                                              *((_QWORD *)&v121 + v65++) = CFSTR("FontTable");
                                            }
                                            if (v91)
                                            {
                                              *v64 = CFRetain(v91);
                                              *((_QWORD *)&v121 + v65++) = CFSTR("SampleDescriptionExtensionAtoms");
                                            }
                                          }
                                          Dict = createDict(allocator, (const void **)&v121, (const void **)&v131, v65, (CFDictionaryRef *)&v98);
                                          v12 = v98;
                                          if (Dict && v98)
                                          {
                                            CFRelease(v98);
                                            v12 = 0;
                                          }
LABEL_119:
                                          v71 = v105;
                                          do
                                          {
                                            if (*v71)
                                              CFRelease(*v71);
                                            ++v71;
                                          }
                                          while (v71 < &v113);
                                          v72 = (CFTypeRef *)&v131;
                                          do
                                          {
                                            if (*v72)
                                              CFRelease(*v72);
                                            ++v72;
                                          }
                                          while (v72 < v141);
                                          if (v92)
                                            CFRelease(v92);
                                          if (v91)
                                            CFRelease(v91);
                                          if (v96)
                                            CFRelease(v96);
                                          if (v95)
                                            CFRelease(v95);
                                          if (v94)
                                            CFRelease(v94);
                                          if (cf)
                                            CFRelease(cf);
                                          if (v61)
                                          {
                                            v69 = v61;
                                            goto LABEL_196;
                                          }
                                          goto LABEL_4;
                                        }
                                      }
                                      v12 = 0;
LABEL_118:
                                      Dict = -12713;
                                      goto LABEL_119;
                                    }
LABEL_202:
                                    Dict = v47;
                                    v12 = 0;
                                    v61 = 0;
                                    goto LABEL_119;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v12 = 0;
    v61 = 0;
    goto LABEL_118;
  }
  if (v15 != 2004251764 && v15 != 2021028980)
    goto LABEL_17;
LABEL_23:
  v105[0] = 0;
  v139 = 0u;
  v140 = 0u;
  v137 = 0u;
  v138 = 0u;
  v135 = 0u;
  v136 = 0u;
  v133 = 0u;
  v134 = 0u;
  v131 = 0u;
  v132 = 0u;
  v129 = 0u;
  v130 = 0u;
  v127 = 0u;
  v128 = 0u;
  v125 = 0u;
  v126 = 0u;
  v123 = 0u;
  v124 = 0u;
  v121 = 0u;
  v122 = 0u;
  v99[0] = 0;
  v102[0] = 0;
  v117 = 0;
  v113 = 0;
  if (size <= 0xF)
    goto LABEL_2;
  if (ParseExtensionAtomsInDescription((uint64_t)textDescriptionData, size, (__CFDictionary **)v99, (__CFDictionary **)v102, (__CFDictionary **)&v117, (__CFDictionary **)&v113))
  {
    v17 = 0;
  }
  else
  {
    v70 = (CFTypeRef *)&v131;
    if (v113)
    {
      v70 = (CFTypeRef *)&v131 + 1;
      *(_QWORD *)&v131 = CFRetain(v113);
      *(_QWORD *)&v121 = CFSTR("SampleDescriptionExtensionAtoms");
      v17 = 1;
    }
    else
    {
      v17 = 0;
    }
    if (v102[0])
    {
      *v70++ = CFRetain(v102[0]);
      v73 = (_QWORD *)((unint64_t)&v121 | (8 * v17++));
      *v73 = CFSTR("rqdf");
    }
    if (v117)
    {
      *v70 = CFRetain(v117);
      *((_QWORD *)&v121 + v17++) = CFSTR("InlineResources");
    }
  }
  v74 = (CFTypeRef *)&v131;
  Dict = createDict(allocator, (const void **)&v121, (const void **)&v131, v17, (CFDictionaryRef *)v105);
  v12 = v105[0];
  if (Dict && v105[0])
  {
    CFRelease(v105[0]);
    v12 = 0;
  }
  do
  {
    if (*v74)
      CFRelease(*v74);
    ++v74;
  }
  while (v74 < v141);
  if (v99[0])
    CFRelease(v99[0]);
  if (v102[0])
    CFRelease(v102[0]);
  if (v117)
    CFRelease(v117);
  v69 = v113;
  if (v113)
    goto LABEL_196;
LABEL_4:
  if (!Dict)
    Dict = CMFormatDescriptionCreate(allocator, mediaType, bswap32(*((_DWORD *)textDescriptionData + 1)), (CFDictionaryRef)v12, v6);
  if (v12)
    CFRelease(v12);
  return Dict;
}

OSStatus CMTextFormatDescriptionCreateFromBigEndianTextDescriptionBlockBuffer(CFAllocatorRef allocator, CMBlockBufferRef textDescriptionBlockBuffer, CMTextDescriptionFlavor flavor, CMMediaType mediaType, CMTextFormatDescriptionRef *formatDescriptionOut)
{
  size_t DataLength;
  size_t v10;
  void *v11;
  OSStatus DataPointer;
  const __CFString *v13;
  OSStatus Contiguous;
  CFTypeRef cf;
  char *dataPointerOut;

  cf = 0;
  if (!textDescriptionBlockBuffer)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  dataPointerOut = 0;
  DataLength = CMBlockBufferGetDataLength(textDescriptionBlockBuffer);
  if (DataLength)
  {
    v10 = DataLength;
    if (CMBlockBufferIsRangeContiguous(textDescriptionBlockBuffer, 0, 0))
    {
      v11 = (void *)CFRetain(textDescriptionBlockBuffer);
      cf = v11;
    }
    else
    {
      Contiguous = CMBlockBufferCreateContiguous(allocator, textDescriptionBlockBuffer, allocator, 0, 0, v10, 0, (CMBlockBufferRef *)&cf);
      if (Contiguous)
        goto LABEL_10;
      v11 = (void *)cf;
    }
    DataPointer = CMBlockBufferGetDataPointer((CMBlockBufferRef)v11, 0, 0, 0, &dataPointerOut);
    if (!DataPointer)
      DataPointer = CMTextFormatDescriptionCreateFromBigEndianTextDescriptionData(allocator, (const uint8_t *)dataPointerOut, v10, v13, mediaType, formatDescriptionOut);
  }
  else
  {
    DataPointer = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  Contiguous = DataPointer;
LABEL_10:
  if (cf)
    CFRelease(cf);
  return Contiguous;
}

OSStatus CMTextFormatDescriptionCopyAsBigEndianTextDescriptionBlockBuffer(CFAllocatorRef allocator, CMTextFormatDescriptionRef textFormatDescription, CMTextDescriptionFlavor flavor, CMBlockBufferRef *blockBufferOut)
{
  signed int MediaSubType;
  const __CFDictionary *Extensions;
  const __CFDictionary *v9;
  int v10;
  int v11;
  size_t v12;
  size_t v13;
  size_t v14;
  int v15;
  int ValueIfPresent;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _BOOL8 v30;
  BOOL v31;
  uint64_t v32;
  size_t v33;
  OSStatus DictionaryNumberWithNtoBFlip;
  int v35;
  char *v36;
  void *v37;
  char *v38;
  OSStatus v39;
  char *v40;
  uint64_t v41;
  char *v42;
  size_t v43;
  char *v44;
  char *v45;
  char *v46;
  OSStatus v47;
  OpaqueCMBlockBuffer *v48;
  uint64_t v50;
  uint64_t v51;
  CMBlockBufferRef *v52;
  void *__src;
  CFStringRef v54;
  CFStringRef v55;
  CFStringRef theString;
  size_t v57;
  uint64_t context;
  uint64_t v59;
  char *v60;
  CFDictionaryRef v61;
  CFDictionaryRef v62;
  CFDictionaryRef theDict;
  void *value;
  void *v65;
  void *v66;
  void *v67;
  void *v68;
  CMBlockBufferRef v69;
  char *dataPointerOut;

  v69 = 0;
  dataPointerOut = 0;
  MediaSubType = CMFormatDescriptionGetMediaSubType(textFormatDescription);
  Extensions = CMFormatDescriptionGetExtensions(textFormatDescription);
  v9 = Extensions;
  v10 = 0;
  v67 = 0;
  v68 = 0;
  v66 = 0;
  value = 0;
  v65 = 0;
  v62 = 0;
  theDict = 0;
  v60 = 0;
  v61 = 0;
  context = 0;
  v59 = 0;
  v57 = 0;
  v52 = blockBufferOut;
  if (MediaSubType <= 2004251763)
  {
    if (MediaSubType != 1937010800)
    {
      v11 = 1937142900;
      goto LABEL_6;
    }
    v55 = 0;
    theString = 0;
    v54 = 0;
    if (!Extensions
      || (ValueIfPresent = CFDictionaryGetValueIfPresent(Extensions, CFSTR("XMLNamespaces"), (const void **)&theString),
          CFDictionaryGetValueIfPresent(v9, CFSTR("XMLSchemas"), (const void **)&v55),
          v17 = CFDictionaryGetValueIfPresent(v9, CFSTR("AuxiliaryMIMETypes"), (const void **)&v54),
          !ValueIfPresent))
    {
      v19 = 4294954581;
      goto LABEL_170;
    }
    v18 = v17;
    if (theString)
    {
      v19 = emitUTF8StringFromCFString(0, 0, theString, &v57);
      if ((_DWORD)v19)
        goto LABEL_170;
      v14 = v57;
    }
    else
    {
      v14 = 0;
    }
    if (v55)
    {
      v19 = emitUTF8StringFromCFString(0, 0, v55, &v57);
      if ((_DWORD)v19)
        goto LABEL_170;
      v13 = v57;
    }
    else
    {
      v13 = 0;
    }
    LODWORD(v50) = v18;
    if (!v54)
    {
      v12 = 0;
      goto LABEL_36;
    }
    v19 = emitUTF8StringFromCFString(0, 0, v54, &v57);
    if (!(_DWORD)v19)
    {
      v12 = v57;
LABEL_36:
      v51 = 0;
      HIDWORD(v50) = 0;
      v15 = 0;
      goto LABEL_37;
    }
LABEL_170:
    v47 = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
    goto LABEL_161;
  }
  if (MediaSubType == 2004251764)
    goto LABEL_8;
  v11 = 2021028980;
LABEL_6:
  if (MediaSubType != v11)
    v10 = 1;
LABEL_8:
  if (MediaSubType != 1937142900 && MediaSubType != 2004251764 && MediaSubType != 2021028980 && !Extensions)
  {
    v19 = 4294954584;
    goto LABEL_170;
  }
  if (!Extensions)
    v10 = 0;
  if (v10 == 1)
  {
    if (CFDictionaryGetValueIfPresent(Extensions, CFSTR("FontTable"), (const void **)&value) == 1)
    {
      context = 0;
      v59 = 0;
      v60 = 0;
      CFDictionaryApplyFunction((CFDictionaryRef)value, (CFDictionaryApplierFunction)FontTableEmittingApplierFunction, &context);
      v12 = 0;
      v13 = 0;
      v14 = 0;
      LODWORD(v50) = 0;
      HIDWORD(v50) = (unsigned __int16)context;
      v51 = v59 + 10;
    }
    else
    {
      v50 = 0;
      v51 = 0;
      v12 = 0;
      v13 = 0;
      v14 = 0;
    }
    v15 = 1;
  }
  else
  {
    HIDWORD(v50) = 0;
    if (!Extensions)
    {
      v20 = 0;
      __src = 0;
      v51 = 0;
      v12 = 0;
      v13 = 0;
      v14 = 0;
      v21 = 0;
      v22 = 0;
      v23 = 0;
      LODWORD(v50) = 0;
      goto LABEL_59;
    }
    v51 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    LODWORD(v50) = 0;
    v15 = 0;
  }
LABEL_37:
  if (CFDictionaryGetValueIfPresent(v9, CFSTR("SampleDescriptionExtensionAtoms"), (const void **)&theDict) == 1)
  {
    context = 0;
    v59 = 0;
    v60 = 0;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)MiscExtensionEmittingApplierFunction, &context);
    v21 = v59;
    if ((v15 & 1) == 0)
      goto LABEL_48;
  }
  else
  {
    v21 = 0;
    __src = 0;
    v20 = 0;
    if (!v15)
      goto LABEL_49;
  }
  if (CFDictionaryGetValueIfPresent(v9, CFSTR("DefaultFontName"), (const void **)&v68) != 1 || v68 == 0)
    goto LABEL_48;
  v25 = (char *)malloc_type_malloc(0x100uLL, 0x3B333B4uLL);
  if (!CFStringGetPascalString((CFStringRef)v68, (StringPtr)v25, 256, 0))
  {
    free(v25);
LABEL_48:
    __src = 0;
    v20 = 0;
    goto LABEL_49;
  }
  __src = v25;
  v20 = *v25;
LABEL_49:
  if (MediaSubType == 1937142900 || MediaSubType == 2021028980 || MediaSubType == 2004251764)
  {
    if (CFDictionaryGetValueIfPresent(v9, CFSTR("rqdf"), (const void **)&v62) == 1)
    {
      context = 0;
      v59 = 0;
      v60 = 0;
      CFDictionaryApplyFunction(v62, (CFDictionaryApplierFunction)RequiredFeaturesEmittingApplierFunction, &context);
      v22 = v59;
    }
    else
    {
      v22 = 0;
    }
    if (CFDictionaryGetValueIfPresent(v9, CFSTR("InlineResources"), (const void **)&v61) == 1)
    {
      context = 0;
      v59 = 0;
      v60 = 0;
      CFDictionaryApplyFunction(v61, (CFDictionaryApplierFunction)InlineResourcesEmittingApplierFunction, &context);
      v23 = v59;
      goto LABEL_59;
    }
  }
  else
  {
    v22 = 0;
  }
  v23 = 0;
LABEL_59:
  if (MediaSubType <= 1952807027)
  {
    if (MediaSubType == 1937010800)
    {
      v30 = (v21 | v12) != 0;
      if (v13)
        v30 = v13;
      if (v21)
        v31 = v12 == 0;
      else
        v31 = 0;
      if (v31)
        v32 = 1;
      else
        v32 = v12;
      v28 = v14 + v32 + v30 + 16;
      v27 = 16;
      v29 = v28;
      goto LABEL_78;
    }
    v26 = 1937142900;
  }
  else
  {
    if (MediaSubType == 1952807028)
    {
      v27 = 0;
      v29 = v20 + 59;
      v28 = v20 + 59 + v51;
      goto LABEL_78;
    }
    if (MediaSubType == 2021028980)
    {
LABEL_66:
      v27 = 0;
      v28 = v22 + v23 + 16;
      v29 = 16;
      goto LABEL_78;
    }
    v26 = 2004251764;
  }
  if (MediaSubType == v26)
    goto LABEL_66;
  v27 = 0;
  v28 = v51 + 46;
  v29 = 46;
LABEL_78:
  v33 = v28 + v21;
  DictionaryNumberWithNtoBFlip = CMBlockBufferCreateWithMemoryBlock(allocator, 0, v28 + v21, allocator, 0, 0, v28 + v21, 1u, &v69);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  CMBlockBufferGetDataPointer(v69, 0, 0, 0, &dataPointerOut);
  bzero(dataPointerOut, v33);
  if (MediaSubType <= 1952807027)
  {
    if (MediaSubType != 1937010800)
    {
      v35 = 1937142900;
LABEL_85:
      if (MediaSubType == v35)
        goto LABEL_86;
      v44 = dataPointerOut;
      *(_DWORD *)dataPointerOut = bswap32(v33);
      *((_DWORD *)v44 + 1) = bswap32(CMFormatDescriptionGetMediaSubType(textFormatDescription));
      *((_WORD *)v44 + 7) = -1;
      DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip(v9, CFSTR("DisplayFlags"), 3, (_DWORD *)v44 + 4);
      if (DictionaryNumberWithNtoBFlip)
        goto LABEL_167;
      DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip(v9, CFSTR("HorizontalJustification"), 1, (_DWORD *)v44 + 5);
      if (DictionaryNumberWithNtoBFlip)
        goto LABEL_167;
      DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip(v9, CFSTR("VerticalJustification"), 1, v44 + 21);
      if (DictionaryNumberWithNtoBFlip)
        goto LABEL_167;
      if (CFDictionaryGetValueIfPresent(v9, CFSTR("BackgroundColor"), (const void **)&v67) == 1)
      {
        DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Red"), 1, v44 + 22);
        if (DictionaryNumberWithNtoBFlip)
          goto LABEL_167;
        DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Green"), 1, v44 + 23);
        if (DictionaryNumberWithNtoBFlip)
          goto LABEL_167;
        DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Blue"), 1, (_DWORD *)v44 + 6);
        if (DictionaryNumberWithNtoBFlip)
          goto LABEL_167;
        DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Alpha"), 1, v44 + 25);
        if (DictionaryNumberWithNtoBFlip)
          goto LABEL_167;
        if (CFDictionaryGetValueIfPresent(v9, CFSTR("DefaultTextBox"), (const void **)&v67) == 1)
        {
          DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Top"), 2, v44 + 26);
          if (DictionaryNumberWithNtoBFlip)
            goto LABEL_167;
          DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Left"), 2, (_DWORD *)v44 + 7);
          if (DictionaryNumberWithNtoBFlip)
            goto LABEL_167;
          DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Right"), 2, (_DWORD *)v44 + 8);
          if (DictionaryNumberWithNtoBFlip)
            goto LABEL_167;
          DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Bottom"), 2, v44 + 30);
          if (DictionaryNumberWithNtoBFlip)
            goto LABEL_167;
          if (CFDictionaryGetValueIfPresent(v9, CFSTR("DefaultStyle"), (const void **)&v67) == 1)
          {
            DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("StartChar"), 2, v44 + 34);
            if (DictionaryNumberWithNtoBFlip)
              goto LABEL_167;
            DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("EndChar"), 2, (_DWORD *)v44 + 9);
            if (DictionaryNumberWithNtoBFlip)
              goto LABEL_167;
            DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Font"), 2, v44 + 38);
            if (DictionaryNumberWithNtoBFlip)
              goto LABEL_167;
            DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("FontFace"), 1, (_DWORD *)v44 + 10);
            if (DictionaryNumberWithNtoBFlip)
              goto LABEL_167;
            DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("FontSize"), 1, v44 + 41);
            if (DictionaryNumberWithNtoBFlip)
              goto LABEL_167;
            if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v67, CFSTR("ForegroundColor"), (const void **)&v65) == 1)
            {
              DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v65, CFSTR("Red"), 1, v44 + 42);
              if (!DictionaryNumberWithNtoBFlip)
              {
                DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v65, CFSTR("Green"), 1, v44 + 43);
                if (!DictionaryNumberWithNtoBFlip)
                {
                  v39 = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v65, CFSTR("Blue"), 1, (_DWORD *)v44 + 11);
                  v37 = __src;
                  if (!v39)
                  {
                    v39 = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v65, CFSTR("Alpha"), 1, v44 + 45);
                    if (!v39)
                      goto LABEL_150;
                  }
                  goto LABEL_172;
                }
              }
LABEL_167:
              v47 = DictionaryNumberWithNtoBFlip;
              blockBufferOut = v52;
              v37 = __src;
              goto LABEL_159;
            }
          }
        }
      }
      goto LABEL_165;
    }
    v40 = dataPointerOut;
    *(_DWORD *)dataPointerOut = bswap32(v33);
    *((_DWORD *)v40 + 1) = bswap32(CMFormatDescriptionGetMediaSubType(textFormatDescription));
    *((_WORD *)v40 + 7) = -1;
    if (CFDictionaryGetValueIfPresent(v9, CFSTR("XMLNamespaces"), (const void **)&v66) != 1)
    {
LABEL_165:
      v41 = 4294954581;
      goto LABEL_166;
    }
    v41 = emitUTF8StringFromCFString(v40 + 16, v33 - v27, (CFStringRef)v66, &v57);
    if (!(_DWORD)v41)
    {
      v42 = &v40[v57 + 16];
      v43 = v29 - v27 - v57;
      if (CFDictionaryGetValueIfPresent(v9, CFSTR("XMLSchemas"), (const void **)&v66))
      {
        v41 = emitUTF8StringFromCFString(v42, v43, (CFStringRef)v66, &v57);
        if ((_DWORD)v41)
          goto LABEL_166;
        v42 += v57;
        v43 -= v57;
      }
      else if (v21 || (_DWORD)v50)
      {
        *v42++ = 0;
        --v43;
      }
      if (!CFDictionaryGetValueIfPresent(v9, CFSTR("AuxiliaryMIMETypes"), (const void **)&v66))
      {
        if (v21)
        {
          *v42 = 0;
          --v43;
        }
        goto LABEL_149;
      }
      v41 = emitUTF8StringFromCFString(v42, v43, (CFStringRef)v66, &v57);
      if (!(_DWORD)v41)
      {
        v43 -= v57;
LABEL_149:
        v37 = __src;
        if (!v43)
          goto LABEL_150;
        v39 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
        goto LABEL_172;
      }
    }
LABEL_166:
    DictionaryNumberWithNtoBFlip = FigSignalErrorAt(v41, 0, 0, 0, 0, 0, 0);
    goto LABEL_167;
  }
  if (MediaSubType != 1952807028)
  {
    if (MediaSubType == 2021028980)
    {
LABEL_86:
      v36 = dataPointerOut;
      *(_DWORD *)dataPointerOut = bswap32(v33);
      *((_DWORD *)v36 + 1) = bswap32(CMFormatDescriptionGetMediaSubType(textFormatDescription));
      *((_WORD *)v36 + 7) = -1;
      v37 = __src;
LABEL_150:
      v60 = &dataPointerOut[v29];
      if (value)
      {
        *(_DWORD *)&dataPointerOut[v29] = bswap32(v51);
        v45 = v60;
        v60 += 4;
        *((_DWORD *)v45 + 1) = 1650553958;
        v46 = v60;
        v60 += 4;
        *((_WORD *)v46 + 2) = bswap32(HIDWORD(v50)) >> 16;
        v60 += 2;
        CFDictionaryApplyFunction((CFDictionaryRef)value, (CFDictionaryApplierFunction)FontTableEmittingApplierFunction, &context);
      }
      if (theDict)
        CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)MiscExtensionEmittingApplierFunction, &context);
      blockBufferOut = v52;
      if (v62)
        CFDictionaryApplyFunction(v62, (CFDictionaryApplierFunction)RequiredFeaturesEmittingApplierFunction, &context);
      if (v61)
        CFDictionaryApplyFunction(v61, (CFDictionaryApplierFunction)InlineResourcesEmittingApplierFunction, &context);
      v47 = 0;
      goto LABEL_159;
    }
    v35 = 2004251764;
    goto LABEL_85;
  }
  v38 = dataPointerOut;
  *(_DWORD *)dataPointerOut = bswap32(v33);
  *((_DWORD *)v38 + 1) = bswap32(CMFormatDescriptionGetMediaSubType(textFormatDescription));
  *((_WORD *)v38 + 7) = -1;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip(v9, CFSTR("DisplayFlags"), 3, (_DWORD *)v38 + 4);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip(v9, CFSTR("TextJustification"), 3, (_DWORD *)v38 + 5);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  if (CFDictionaryGetValueIfPresent(v9, CFSTR("BackgroundColor"), (const void **)&v67) != 1)
    goto LABEL_165;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Red"), 2, (_DWORD *)v38 + 6);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Green"), 2, v38 + 26);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Blue"), 2, (_DWORD *)v38 + 7);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  if (CFDictionaryGetValueIfPresent(v9, CFSTR("DefaultTextBox"), (const void **)&v67) != 1)
    goto LABEL_165;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Top"), 2, v38 + 30);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Left"), 2, (_DWORD *)v38 + 8);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Right"), 2, (_DWORD *)v38 + 9);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Bottom"), 2, v38 + 34);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  if (CFDictionaryGetValueIfPresent(v9, CFSTR("DefaultStyle"), (const void **)&v67) != 1)
    goto LABEL_165;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("StartChar"), 3, v38 + 38);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Height"), 2, v38 + 42);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Ascent"), 2, (_DWORD *)v38 + 11);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("Font"), 2, v38 + 46);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("FontFace"), 1, (_DWORD *)v38 + 12);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v67, CFSTR("FontSize"), 2, v38 + 50);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v67, CFSTR("ForegroundColor"), (const void **)&v65) != 1)
    goto LABEL_165;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v65, CFSTR("Red"), 2, (_DWORD *)v38 + 13);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  DictionaryNumberWithNtoBFlip = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v65, CFSTR("Green"), 2, v38 + 54);
  if (DictionaryNumberWithNtoBFlip)
    goto LABEL_167;
  v39 = FetchDictionaryNumberWithNtoBFlip((const __CFDictionary *)v65, CFSTR("Blue"), 2, (_DWORD *)v38 + 14);
  v37 = __src;
  if (!v39)
  {
    if (__src)
      memcpy(v38 + 58, __src, v20 + 1);
    goto LABEL_150;
  }
LABEL_172:
  v47 = v39;
  blockBufferOut = v52;
LABEL_159:
  if (v37)
    free(v37);
LABEL_161:
  v48 = v69;
  if (v47 && v69)
  {
    CFRelease(v69);
    v48 = 0;
  }
  *blockBufferOut = v48;
  return v47;
}

uint64_t emitUTF8StringFromCFString(void *a1, size_t a2, CFStringRef theString, size_t *a4)
{
  const __CFAllocator *v7;
  UInt8 *v8;
  UInt8 *v9;
  size_t v10;
  uint64_t result;
  uint64_t v12;
  size_t __n;

  __n = 0;
  if (!theString || (a1 != 0) != (a2 != 0))
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8 = FigCreateBytesFromCFString((const __CFAllocator *)*MEMORY[0x1E0C9AE00], theString, 0x8000100u, 1, &__n);
  if (!v8)
  {
    v12 = 4294954583;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v9 = v8;
  v10 = __n;
  if (!a1)
    goto LABEL_7;
  if (__n > a2)
  {
    v12 = 4294954582;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  memcpy(a1, v8, __n);
LABEL_7:
  CFAllocatorDeallocate(v7, v9);
  result = 0;
  if (a4)
    *a4 = v10;
  return result;
}

CFIndex FontTableEmittingApplierFunction(const __CFString *a1, CFStringRef theString, uint64_t a3)
{
  CFIndex Length;
  CFTypeID v7;
  CFTypeID v8;
  CFIndex result;
  CFIndex v10;
  uint64_t v11;
  UInt8 *v12;
  CFIndex maxBufLen;
  CFRange v14;
  CFRange v15;

  Length = CFStringGetLength(theString);
  v7 = CFGetTypeID(a1);
  if (v7 != CFStringGetTypeID())
    return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  v8 = CFGetTypeID(theString);
  if (v8 != CFStringGetTypeID())
    return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  maxBufLen = 0;
  v14.location = 0;
  v14.length = Length;
  result = CFStringGetBytes(theString, v14, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
  if (!maxBufLen)
    return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  v10 = maxBufLen + *(_QWORD *)(a3 + 8) + 3;
  ++*(_QWORD *)a3;
  *(_QWORD *)(a3 + 8) = v10;
  if (*(_QWORD *)(a3 + 16))
  {
    **(_WORD **)(a3 + 16) = bswap32(CFStringGetIntValue(a1)) >> 16;
    v11 = *(_QWORD *)(a3 + 16);
    *(_QWORD *)(a3 + 16) = v11 + 2;
    *(_BYTE *)(v11 + 2) = maxBufLen;
    v12 = (UInt8 *)(*(_QWORD *)(a3 + 16) + 1);
    *(_QWORD *)(a3 + 16) = v12;
    v15.location = 0;
    v15.length = Length;
    result = CFStringGetBytes(theString, v15, 0x8000100u, 0, 0, v12, maxBufLen, &maxBufLen);
    *(_QWORD *)(a3 + 16) += maxBufLen;
  }
  return result;
}

void MiscExtensionEmittingApplierFunction(const __CFString *a1, const __CFData *a2, _QWORD *a3)
{
  CFIndex Length;
  CFTypeID v7;
  CFTypeID v8;
  CFIndex v9;
  CFIndex v10;
  uint64_t v11;
  _DWORD *v12;
  UInt8 *v13;
  UInt8 buffer[4];
  CFIndex usedBufLen;
  CFRange v16;
  CFRange v17;

  Length = CFStringGetLength(a1);
  v7 = CFGetTypeID(a1);
  if (v7 == CFStringGetTypeID()
    && a2
    && (v8 = CFGetTypeID(a2), v8 == CFDataGetTypeID())
    && (v9 = CFDataGetLength(a2), v9 > 0))
  {
    v10 = v9;
    v11 = a3[1] + v9 + 8;
    ++*a3;
    a3[1] = v11;
    v12 = (_DWORD *)a3[2];
    if (v12)
    {
      usedBufLen = 0;
      *(_DWORD *)buffer = 0;
      *v12 = bswap32(v9 + 8);
      a3[2] += 4;
      v16.location = 0;
      v16.length = Length;
      CFStringGetBytes(a1, v16, 0, 0, 0, buffer, 4, &usedBufLen);
      if (usedBufLen == 4)
      {
        *(_DWORD *)a3[2] = *(_DWORD *)buffer;
        v13 = (UInt8 *)(a3[2] + 4);
        a3[2] = v13;
        v17.location = 0;
        v17.length = v10;
        CFDataGetBytes(a2, v17, v13);
        a3[2] += v10;
      }
      else
      {
        FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  else
  {
    FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t RequiredFeaturesEmittingApplierFunction(const void *a1, const void *a2, _QWORD *a3)
{
  CFTypeID v6;
  uint64_t result;
  CFTypeID v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFIndex v14;
  const __CFString *ValueAtIndex;
  CFTypeID v16;
  CFIndex Length;
  unsigned int v18;
  CFIndex v19;
  _DWORD *v20;
  _DWORD *v21;
  UInt8 *v22;
  unint64_t v23;
  CFIndex maxBufLen;
  CFRange v25;
  CFRange v26;

  v6 = CFGetTypeID(a1);
  if (v6 != CFStringGetTypeID())
    return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  result = CFEqual(a1, CFSTR("feat"));
  if ((_DWORD)result)
  {
    maxBufLen = 0;
    v8 = CFGetTypeID(a2);
    if (v8 != CFArrayGetTypeID())
      return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    result = CFArrayGetCount((CFArrayRef)a2);
    v9 = result;
    v11 = a3[1];
    v10 = (_DWORD *)a3[2];
    a3[1] = v11 + 8;
    if (v10)
    {
      *v10 = 0x8000000;
      v12 = a3[2];
      a3[2] = v12 + 4;
      *(_DWORD *)(v12 + 4) = 1717858674;
      v13 = a3[2] + 4;
      a3[2] = v13;
    }
    else
    {
      v13 = 0;
    }
    if (result >= 1)
    {
      v14 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a2, v14);
        v16 = CFGetTypeID(ValueAtIndex);
        if (v16 != CFStringGetTypeID())
          break;
        Length = CFStringGetLength(ValueAtIndex);
        v25.location = 0;
        v25.length = Length;
        result = CFStringGetBytes(ValueAtIndex, v25, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
        if (!maxBufLen)
          break;
        v18 = maxBufLen + 8;
        v19 = a3[1] + maxBufLen + 8;
        ++*a3;
        a3[1] = v19;
        v20 = (_DWORD *)a3[2];
        if (v20)
        {
          *v20 = bswap32(v18);
          v21 = (_DWORD *)(a3[2] + 4);
          a3[2] = v21;
          *v21 = 1952540006;
          v22 = (UInt8 *)(a3[2] + 4);
          a3[2] = v22;
          v26.location = 0;
          v26.length = Length;
          result = CFStringGetBytes(ValueAtIndex, v26, 0x8000100u, 0, 0, v22, maxBufLen, &maxBufLen);
          v13 = a3[2] + maxBufLen;
          a3[2] = v13;
        }
        else
        {
          v13 = 0;
        }
        if (v9 == ++v14)
          goto LABEL_15;
      }
      return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    }
LABEL_15:
    if (v13)
    {
      v23 = a3[1] - v11;
      if (!HIDWORD(v23))
      {
        *v10 = bswap32(v23);
        return result;
      }
      return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

void InlineResourcesEmittingApplierFunction(const void *a1, const __CFArray *a2, uint64_t a3)
{
  CFTypeID v6;
  const __CFString *v7;
  CFTypeID v8;
  size_t DataLength;
  void *v10;
  size_t v11;
  _OWORD v12[3];
  uint64_t v13;
  CMBlockBufferRef blockBufferOut;
  uint64_t v15;
  _OWORD *v16;

  v15 = 0;
  v16 = 0;
  blockBufferOut = 0;
  v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
  {
    if (*(_QWORD *)(a3 + 16))
      v7 = CFSTR("Skipping inline resources [atom writing pass]");
    else
      v7 = CFSTR("Skipping inline resources [data sizing pass]");
    CFShow(v7);
    if (CFEqual(a1, CFSTR("InlineResourcesArray")))
    {
      v13 = 0;
      memset(v12, 0, sizeof(v12));
      if (a2 && (v8 = CFGetTypeID(a2), v8 == CFArrayGetTypeID()))
      {
        if (!CMBlockBufferCreateEmpty((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 8u, 0, &blockBufferOut)
          && !FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)v12)
          && !FigAtomWriterBeginAtom((uint64_t)v12, 0x76747452u, 0))
        {
          v15 = a3;
          v16 = v12;
          FigCFArrayApplyFunction(a2, (void (__cdecl *)(const void *, void *))InlineResourcesPayloadWritingApplierFunc, &v15);
          if (!FigAtomWriterEndAtom((uint64_t)v12))
          {
            DataLength = CMBlockBufferGetDataLength(blockBufferOut);
            v10 = *(void **)(a3 + 16);
            *(_QWORD *)(a3 + 8) += DataLength;
            if (v10)
            {
              v11 = DataLength;
              if (!CMBlockBufferCopyDataBytes(blockBufferOut, 0, DataLength, v10))
                *(_QWORD *)(a3 + 16) += v11;
            }
          }
        }
      }
      else
      {
        FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
      }
      if (blockBufferOut)
        CFRelease(blockBufferOut);
    }
  }
  else
  {
    FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FetchDictionaryNumberWithNtoBFlip(const __CFDictionary *a1, const void *a2, uint64_t a3, _DWORD *a4)
{
  CFTypeID v6;
  uint64_t result;
  unsigned __int16 v8;
  unsigned int valuePtr;
  void *value;

  value = 0;
  valuePtr = 0;
  v8 = 0;
  if (CFDictionaryGetValueIfPresent(a1, a2, (const void **)&value) != 1)
    return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  v6 = CFGetTypeID(value);
  if (v6 != CFNumberGetTypeID())
    return FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  if (a3 == 3)
  {
    CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
    result = 0;
    *a4 = bswap32(valuePtr);
  }
  else if (a3 == 2)
  {
    CFNumberGetValue((CFNumberRef)value, kCFNumberSInt16Type, &v8);
    result = 0;
    *(_WORD *)a4 = bswap32(v8) >> 16;
  }
  else
  {
    if (a3 == 1)
      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt8Type, a4);
    return 0;
  }
  return result;
}

uint64_t createDict(const __CFAllocator *a1, const void **a2, const void **a3, CFIndex a4, CFDictionaryRef *a5)
{
  uint64_t v6;
  CFTypeRef *v7;
  CFDictionaryRef v8;

  v6 = a4;
  v7 = a3;
  v8 = CFDictionaryCreate(a1, a2, a3, a4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *a5 = v8;
  if (v6 >= 1)
  {
    do
    {
      if (*v7)
      {
        CFRelease(*v7);
        *v7 = 0;
      }
      ++v7;
      --v6;
    }
    while (v6);
    v8 = *a5;
  }
  if (v8)
    return 0;
  else
    return 4294954583;
}

uint64_t ParseExtensionAtomsInDescription(uint64_t a1, unint64_t a2, __CFDictionary **a3, __CFDictionary **a4, __CFDictionary **a5, __CFDictionary **a6)
{
  unsigned int v12;
  int v13;
  _BOOL4 v15;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  __CFDictionary *v22;
  __CFDictionary *v23;
  __CFDictionary *v24;
  CFDataRef v25;
  CFStringRef v26;
  __CFDictionary *v27;
  __CFDictionary *v28;
  const __CFAllocator *v29;
  uint64_t v30;
  unsigned int v31;
  signed int v32;
  uint64_t v33;
  unint64_t v34;
  int v35;
  unsigned int v36;
  unint64_t v37;
  CFIndex v38;
  __CFDictionary *Mutable;
  const UInt8 *v40;
  uint64_t v41;
  CFIndex v42;
  uint64_t v43;
  CFStringRef v44;
  CFStringRef v45;
  CFStringRef v46;
  CFStringRef v47;
  uint64_t v49;
  __CFArray *v50;
  unsigned int v51;
  int v52;
  OSStatus v53;
  OSStatus v54;
  const void *v55;
  __CFDictionary *v57;
  CFMutableArrayRef v58;
  CFMutableArrayRef v59;
  unsigned int v60;
  int CurrentAtomTypeAndDataLength;
  CFNumberRef v62;
  CFStringRef v63;
  const void *UInt32;
  int v65;
  int v66;
  CFDataRef v67;
  int v68;
  int v69;
  int BBuf;
  char *v71;
  const char *v72;
  char *v73;
  size_t v74;
  size_t v75;
  char *v76;
  const char *v77;
  size_t v78;
  size_t DataLength;
  int DataPointer;
  int v81;
  __CFArray *v82;
  uint64_t v83;
  const void *v84;
  __CFDictionary *v85;
  __CFArray *v86;
  __CFDictionary *v87;
  __CFDictionary *v88;
  __CFDictionary **v90;
  __CFDictionary **v91;
  __CFDictionary **v92;
  __CFDictionary **v93;
  __CFDictionary *v94;
  __CFDictionary *v95;
  __CFDictionary *v96;
  _BOOL4 v97;
  __CFDictionary *v98;
  int v99;
  __CFArray *v100;
  uint64_t v101;
  uint64_t v102;
  __CFArray *value;
  uint64_t v104;
  uint64_t v105;
  unint64_t v106;
  unint64_t length;
  UInt8 bytes[4];
  uint64_t v109;
  unsigned int v110;
  _OWORD v111[7];
  CMBlockBufferRef v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  uint64_t v120;
  int v121;
  char *v122;
  char *dataPointerOut;
  int v124;
  size_t lengthAtOffsetOut;
  CFStringRef v126;
  const void *v127;
  CFDataRef v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  size_t v132;
  const __CFString *v133;
  const __CFString *v134;
  const __CFString *v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  uint64_t v139;

  v139 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)bytes = 0;
  v12 = *(_DWORD *)(a1 + 4);
  v13 = bswap32(v12);
  v15 = v12 == 1953789560 || (v13 & 0xFBFFFFFF) == 1937142900;
  if (v13 <= 1952807027)
  {
    if (v13 != 1937010800)
    {
      if (v13 != 1937142900)
        goto LABEL_17;
      goto LABEL_14;
    }
    LOBYTE(dataPointerOut) = 0;
    LOBYTE(v122) = 0;
    LOBYTE(v120) = 0;
    LOBYTE(v112) = 0;
    v113 = 0uLL;
    v111[0] = 0uLL;
    v132 = 0;
    v133 = 0;
    lengthAtOffsetOut = 0;
    v126 = 0;
    if (a2 <= 0x10
      || locateXMLSubtitleSampleFields(a1, a2, (char *)&dataPointerOut, (uint64_t *)&v113, (char *)&v122, (size_t *)v111, (char *)&v120, &v132, (char *)&v112, &lengthAtOffsetOut)|| !(_BYTE)dataPointerOut|| (_BYTE)v112 && (!(_BYTE)v122 || !(_BYTE)v120))
    {
      goto LABEL_36;
    }
    v20 = *((_QWORD *)&v113 + 1) + 16;
    if (*((_QWORD *)&v113 + 1) + 16 > a2)
      goto LABEL_36;
    if ((_BYTE)v122)
    {
      v20 += *((_QWORD *)&v111[0] + 1);
      if (v20 > a2)
        goto LABEL_36;
      if ((_BYTE)v120)
      {
        v20 += (unint64_t)v133;
        if (v20 > a2)
          goto LABEL_36;
      }
    }
    else if ((_BYTE)v120)
    {
      goto LABEL_36;
    }
    v18 = a2 - v20;
    if (a2 >= v20)
    {
      v99 = 0;
      v17 = a1 + v20;
      goto LABEL_48;
    }
LABEL_36:
    v21 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    goto LABEL_37;
  }
  if (v13 == 1952807028)
  {
    if (a2 > 0x3A)
    {
      v19 = *(unsigned __int8 *)(a1 + 58) + 59;
      v18 = a2 - v19;
      if (a2 >= v19)
      {
        v17 = a1 + v19;
        goto LABEL_22;
      }
    }
    goto LABEL_36;
  }
  if (v13 != 2021028980 && v13 != 2004251764)
  {
LABEL_17:
    if (a2 > 0x2D)
    {
      v17 = a1 + 46;
      v18 = a2 - 46;
LABEL_22:
      v99 = 1;
      goto LABEL_48;
    }
    goto LABEL_36;
  }
LABEL_14:
  v99 = 0;
  v17 = a1 + 16;
  v18 = a2 - 16;
LABEL_48:
  if (v18 < 9)
  {
    v26 = 0;
    v25 = 0;
    v21 = 0;
    goto LABEL_225;
  }
  v97 = v15;
  v90 = a3;
  v91 = a4;
  v92 = a5;
  v93 = a6;
  v95 = 0;
  v96 = 0;
  v94 = 0;
  v98 = 0;
  v29 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v30 = v17;
  do
  {
    v31 = *(_DWORD *)(v30 + 4);
    v32 = bswap32(*(_DWORD *)v30);
    *(_DWORD *)bytes = bswap32(v31);
    if (v32 <= 7)
    {
      v21 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      v25 = 0;
      goto LABEL_247;
    }
    v33 = v32;
    v106 = v18 - 8;
    if (v32 - 9 >= v18 - 8)
      break;
    v34 = v32 - 8;
    v35 = v99;
    if (v31 != 1650553958)
      v35 = 0;
    length = v33 - 8;
    if (v35 == 1)
    {
      if (v34 > 1)
      {
        v36 = bswap32(*(unsigned __int16 *)(v30 + 8)) >> 16;
        v37 = v33 - 10;
        if (3 * (__int16)v36 <= (unint64_t)(v33 - 10))
        {
          v104 = v33;
          v38 = (__int16)v36;
          if ((__int16)v36 < 1)
          {
            v98 = 0;
LABEL_109:
            v33 = v104;
          }
          else
          {
            Mutable = 0;
            v101 = v30;
            v40 = (const UInt8 *)(v30 + 10);
            v41 = (__int16)v36;
            while (v37 >= 3)
            {
              v42 = v40[2];
              if (v40[2])
              {
                v43 = v42 + 3;
                if (v37 < v42 + 3)
                  break;
                v44 = CFStringCreateWithFormat(v29, 0, CFSTR("%d"), bswap32(*(unsigned __int16 *)v40) >> 16);
                if (!v44)
                  break;
                v45 = v44;
                v46 = CFStringCreateWithBytes(v29, v40 + 3, v42, 0x8000100u, 0);
                if (v46)
                {
                  v47 = v46;
                  if (!Mutable)
                    Mutable = CFDictionaryCreateMutable(v29, v38, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                  CFDictionaryAddValue(Mutable, v45, v47);
                  CFRelease(v47);
                }
                CFRelease(v45);
              }
              else
              {
                v43 = 3;
              }
              v40 += v43;
              v37 -= v43;
              if (!--v41)
              {
                v98 = Mutable;
                v30 = v101;
                goto LABEL_109;
              }
            }
            FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            v33 = v104;
            if (Mutable)
              CFRelease(Mutable);
            v30 = v101;
          }
          goto LABEL_122;
        }
      }
LABEL_107:
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_122;
    }
    if (v31 != 1717858674 || !v97)
    {
      if (v31 == 1383363702 && v97)
      {
        if (length <= 7)
          goto LABEL_107;
        memset(v111, 0, sizeof(v111));
        v110 = 0;
        v109 = 0;
        if (FigAtomStreamInitWithMemoryBlock(v30 + 8, length, 0, 0, (uint64_t)v111))
          goto LABEL_122;
        v59 = 0;
        v102 = v30;
        value = 0;
        v105 = v33;
        while (1)
        {
          if (FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v111, &v110, &v109))
            goto LABEL_207;
          v60 = v110;
          if (v110 == 1718773093)
            goto LABEL_172;
          if (v110 == 1920168547)
            break;
          v82 = value;
          if (!value)
          {
            v82 = CFArrayCreateMutable(v29, 0, MEMORY[0x1E0C9B378]);
            v60 = v110;
          }
          UInt32 = FigCFNumberCreateUInt32(v29, v60);
          value = v82;
          CFArrayAppendValue(v82, UInt32);
          if (UInt32)
            goto LABEL_171;
LABEL_172:
          if (FigAtomStreamAdvanceToNextAtom(v111))
          {
            if (!v59)
            {
              v95 = 0;
              goto LABEL_207;
            }
            v85 = CFDictionaryCreateMutable(v29, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            CFDictionaryAddValue(v85, CFSTR("InlineResourcesArray"), v59);
            v95 = v85;
            if (value)
            {
              CFDictionaryAddValue(v85, CFSTR("UnrecognizedAtoms"), value);
              v86 = value;
              goto LABEL_208;
            }
LABEL_210:
            v58 = v59;
            goto LABEL_121;
          }
        }
        if (!v59)
          v59 = CFArrayCreateMutable(v29, 0, MEMORY[0x1E0C9B378]);
        v121 = 0;
        v120 = 0;
        v119 = 0u;
        v118 = 0u;
        v117 = 0u;
        v116 = 0u;
        v115 = 0u;
        v114 = 0u;
        v113 = 0u;
        v112 = 0;
        CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v111, &v121, &v120);
        if (CurrentAtomTypeAndDataLength
          || (CurrentAtomTypeAndDataLength = FigAtomStreamInitWithParent((uint64_t)v111, 0, (uint64_t)&v113)) != 0)
        {
          v69 = CurrentAtomTypeAndDataLength;
          UInt32 = 0;
          goto LABEL_194;
        }
        v100 = v59;
        v62 = 0;
        v63 = 0;
        UInt32 = 0;
        v65 = 0;
        v66 = 0;
        v67 = 0;
        while (2)
        {
          while (2)
          {
            while (2)
            {
              v68 = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)&v113, &v121, &v120);
              if (v68)
                goto LABEL_184;
              if (v121 == 1684108385)
              {
                v132 = 0;
                lengthAtOffsetOut = 0;
                dataPointerOut = 0;
                if (v66)
                {
                  v66 = 1;
                  continue;
                }
                v68 = FigAtomStreamReadCurrentAtomDataAndCreateBBuf((uint64_t)&v113, 0, 0, &v112);
                if (v68)
                  goto LABEL_184;
                DataLength = CMBlockBufferGetDataLength(v112);
                DataPointer = CMBlockBufferGetDataPointer(v112, 0, &v132, &lengthAtOffsetOut, &dataPointerOut);
                if (DataPointer)
                  goto LABEL_200;
                v67 = CFDataCreate(v29, (const UInt8 *)dataPointerOut, DataLength);
                if (!v67)
                {
                  DataPointer = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
LABEL_200:
                  v69 = DataPointer;
                  if (!v62)
                    goto LABEL_187;
LABEL_186:
                  CFRelease(v62);
                  goto LABEL_187;
                }
                v66 = 1;
                goto LABEL_163;
              }
              break;
            }
            if (v121 == 1954115685)
            {
              if (v65)
              {
                v65 = 1;
                continue;
              }
              v124 = 0;
              v132 = 0;
              lengthAtOffsetOut = 0;
              v69 = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)&v113, &v124, &v132);
              v62 = 0;
              if (v69)
              {
                v63 = 0;
                UInt32 = 0;
                goto LABEL_161;
              }
              v63 = 0;
              UInt32 = 0;
              if (v132 < 0xA)
                goto LABEL_161;
              v122 = 0;
              dataPointerOut = 0;
              BBuf = FigAtomStreamReadCurrentAtomDataAndCreateBBuf((uint64_t)&v113, 0, 0, (CMBlockBufferRef *)&lengthAtOffsetOut);
              if (BBuf)
              {
                v69 = BBuf;
              }
              else
              {
                v69 = CMBlockBufferGetDataPointer((CMBlockBufferRef)lengthAtOffsetOut, 0, (size_t *)&dataPointerOut, 0, &v122);
                if (!v69)
                {
                  v71 = v122;
                  v62 = FigCFNumberCreateUInt32(v29, bswap32(*((_DWORD *)v122 + 1)));
                  v72 = v71 + 8;
                  v73 = dataPointerOut - 8;
                  v74 = strnlen(v72, (size_t)(dataPointerOut - 8));
                  v63 = 0;
                  if (v74 && (v75 = v74, v74 < (unint64_t)v73))
                  {
                    v63 = CFStringCreateWithBytes(v29, (const UInt8 *)v72, v74, 0, 1u);
                    v76 = &dataPointerOut[-v75 - 9];
                    if ((unint64_t)dataPointerOut <= v75 + 9)
                    {
                      UInt32 = 0;
LABEL_158:
                      v69 = 0;
                    }
                    else
                    {
                      v77 = &v72[v75 + 1];
                      v78 = strnlen(v77, (size_t)v76);
                      v69 = 0;
                      UInt32 = 0;
                      if (v78 && v78 < (unint64_t)v76)
                      {
                        UInt32 = CFStringCreateWithBytes(v29, (const UInt8 *)v77, v78, 0, 1u);
                        goto LABEL_158;
                      }
                    }
                  }
                  else
                  {
                    UInt32 = 0;
                  }
LABEL_159:
                  if (lengthAtOffsetOut)
                    CFRelease((CFTypeRef)lengthAtOffsetOut);
LABEL_161:
                  if (v69)
                    goto LABEL_185;
                  v65 = 1;
                  break;
                }
              }
              v62 = 0;
              v63 = 0;
              UInt32 = 0;
              goto LABEL_159;
            }
            break;
          }
LABEL_163:
          v81 = FigAtomStreamAdvanceToNextAtom(&v113);
          if (v81 == -12890)
          {
            v69 = 0;
LABEL_175:
            if (!v65 || !v66)
              goto LABEL_183;
            v137 = 0u;
            v138 = 0u;
            v136 = 0u;
            v130 = 0u;
            v131 = 0u;
            v129 = 0u;
            v132 = (size_t)CFSTR("resource_role");
            v133 = CFSTR("resource_mimetype");
            lengthAtOffsetOut = (size_t)v62;
            v126 = v63;
            v134 = CFSTR("resource_mimetype_URI");
            v135 = CFSTR("resource_payload");
            v127 = UInt32;
            v128 = v67;
            UInt32 = CFDictionaryCreate(v29, (const void **)&v132, (const void **)&lengthAtOffsetOut, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v83 = 0;
            v59 = v100;
            v30 = v102;
            do
            {
              v84 = *(const void **)((char *)&lengthAtOffsetOut + v83);
              if (v84)
                CFRelease(v84);
              v83 += 8;
            }
            while (v83 != 32);
            if (!UInt32)
            {
              v67 = 0;
              v63 = 0;
              v62 = 0;
LABEL_183:
              v68 = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
LABEL_184:
              v69 = v68;
LABEL_185:
              if (v62)
                goto LABEL_186;
LABEL_187:
              if (v63)
                CFRelease(v63);
              if (UInt32)
                CFRelease(UInt32);
              v30 = v102;
              if (v67)
                CFRelease(v67);
              UInt32 = 0;
              v59 = v100;
            }
LABEL_194:
            if (v112)
              CFRelease(v112);
            if (!v69)
            {
              CFArrayAppendValue(v59, UInt32);
              v33 = v105;
              if (!UInt32)
                goto LABEL_172;
LABEL_171:
              CFRelease(UInt32);
              goto LABEL_172;
            }
            if (UInt32)
              CFRelease(UInt32);
            v33 = v105;
LABEL_207:
            v86 = value;
            if (value)
LABEL_208:
              CFRelease(v86);
            if (!v59)
              goto LABEL_122;
            goto LABEL_210;
          }
          v69 = v81;
          if (v81)
            goto LABEL_175;
          continue;
        }
      }
      v25 = CFDataCreate(v29, (const UInt8 *)(v30 + 8), length);
      if (v25)
      {
        *(_DWORD *)bytes = bswap32(*(unsigned int *)bytes);
        v26 = CFStringCreateWithBytes(v29, bytes, 4, 0, 0);
        if (v26)
        {
          v57 = v96;
          if (v96 || (v57 = CFDictionaryCreateMutable(v29, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0])) != 0)
          {
            v96 = v57;
            CFDictionaryAddValue(v57, v26, v25);
            CFRelease(v26);
            goto LABEL_120;
          }
          v21 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
          v27 = 0;
          a5 = v92;
          a6 = v93;
          a3 = v90;
          a4 = v91;
          v23 = v94;
          v24 = v95;
          v22 = v98;
LABEL_37:
          if (!(_DWORD)v21)
            goto LABEL_229;
          v28 = v27;
          if (v22)
          {
            CFRelease(v22);
            v27 = v28;
          }
          if (v23)
          {
            CFRelease(v23);
            v27 = v28;
          }
          if (v24)
          {
            CFRelease(v24);
            v27 = v28;
          }
          if (!v27)
          {
            v22 = 0;
            v23 = 0;
            v24 = 0;
            if (a3)
              goto LABEL_230;
            goto LABEL_226;
          }
          CFRelease(v27);
LABEL_225:
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v27 = 0;
          if (a3)
            goto LABEL_230;
          goto LABEL_226;
        }
        v21 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
LABEL_248:
        a5 = v92;
        a6 = v93;
        a3 = v90;
        a4 = v91;
        v23 = v94;
        v24 = v95;
        v22 = v98;
        v27 = v96;
        goto LABEL_37;
      }
      v21 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
LABEL_247:
      v26 = 0;
      goto LABEL_248;
    }
    if (length <= 7)
      goto LABEL_107;
    v119 = 0u;
    v118 = 0u;
    v117 = 0u;
    v116 = 0u;
    v115 = 0u;
    v114 = 0u;
    v113 = 0u;
    LODWORD(v112) = 0;
    v122 = 0;
    if (FigAtomStreamInitWithMemoryBlock(v30 + 8, length, 0, 0, (uint64_t)&v113))
      goto LABEL_122;
    v49 = v33;
    v25 = 0;
    v50 = 0;
    while (!FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)&v113, &v112, &v122))
    {
      v51 = v112;
      if ((_DWORD)v112 != 1718773093)
      {
        if ((_DWORD)v112 == 1717920116)
        {
          if (!v25)
            v25 = CFArrayCreateMutable(v29, 0, MEMORY[0x1E0C9B378]);
          LODWORD(v120) = 0;
          *(_QWORD *)&v111[0] = 0;
          v132 = 0;
          v52 = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)&v113, &v120, v111);
          if (v52 || *(uint64_t *)&v111[0] < 1)
          {
            if (v52)
              break;
LABEL_116:
            FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            break;
          }
          lengthAtOffsetOut = 0;
          dataPointerOut = 0;
          v53 = FigAtomStreamReadCurrentAtomDataAndCreateBBuf((uint64_t)&v113, 0, 0, (CMBlockBufferRef *)&v132);
          if (v53)
          {
            v54 = v53;
LABEL_87:
            v55 = 0;
          }
          else
          {
            v54 = CMBlockBufferGetDataPointer((CMBlockBufferRef)v132, 0, &lengthAtOffsetOut, 0, &dataPointerOut);
            if (v54)
              goto LABEL_87;
            v55 = CFStringCreateWithBytes(v29, (const UInt8 *)dataPointerOut, lengthAtOffsetOut, 0, 1u);
          }
          if (v132)
            CFRelease((CFTypeRef)v132);
          if (v54)
          {
            if (v55)
              CFRelease(v55);
            break;
          }
          if (!v55)
            goto LABEL_116;
          CFArrayAppendValue(v25, v55);
        }
        else
        {
          if (!v50)
          {
            v50 = CFArrayCreateMutable(v29, 0, MEMORY[0x1E0C9B378]);
            v51 = v112;
          }
          v55 = FigCFNumberCreateUInt32(v29, v51);
          CFArrayAppendValue(v50, v55);
          if (!v55)
            goto LABEL_99;
        }
        CFRelease(v55);
      }
LABEL_99:
      if (FigAtomStreamAdvanceToNextAtom(&v113))
      {
        if (v25)
        {
          v87 = CFDictionaryCreateMutable(v29, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          CFDictionaryAddValue(v87, CFSTR("feat"), v25);
          v94 = v87;
          if (!v50)
          {
            v33 = v49;
            goto LABEL_120;
          }
          CFDictionaryAddValue(v87, CFSTR("UnrecognizedAtoms"), v50);
          goto LABEL_118;
        }
        v94 = 0;
        break;
      }
    }
    if (!v50)
      goto LABEL_119;
LABEL_118:
    CFRelease(v50);
LABEL_119:
    v33 = v49;
    if (!v25)
      goto LABEL_122;
LABEL_120:
    v58 = v25;
LABEL_121:
    CFRelease(v58);
LABEL_122:
    v18 = v106 - length;
    v30 += v33;
  }
  while (v106 - length > 8);
  v26 = 0;
  v25 = 0;
  v21 = 0;
  a5 = v92;
  a6 = v93;
  a3 = v90;
  a4 = v91;
  v23 = v94;
  v24 = v95;
  v22 = v98;
  v27 = v96;
LABEL_229:
  if (a3)
  {
LABEL_230:
    *a3 = v22;
    goto LABEL_231;
  }
LABEL_226:
  if (v22)
  {
    v88 = v27;
    CFRelease(v22);
    v27 = v88;
  }
LABEL_231:
  if (a4)
  {
    *a4 = v23;
    v23 = 0;
  }
  if (a5)
  {
    *a5 = v24;
    v24 = 0;
  }
  *a6 = v27;
  if (v23)
    CFRelease(v23);
  if (v24)
    CFRelease(v24);
  if (v26)
    CFRelease(v26);
  if (v25)
    CFRelease(v25);
  return v21;
}

uint64_t locateXMLSubtitleSampleFields(uint64_t a1, unint64_t a2, char *a3, uint64_t *a4, char *a5, size_t *a6, char *a7, size_t *a8, char *a9, _QWORD *a10)
{
  unint64_t v13;
  size_t v16;
  size_t v17;
  size_t v18;
  size_t v19;
  uint64_t result;
  char v21;
  char v22;
  size_t v23;
  size_t v24;
  size_t v25;
  char v26;
  size_t v27;
  unint64_t v28;
  char v29;
  uint64_t v30;

  v13 = a2 - 16;
  if (a2 <= 0x10 || (v16 = strnlen((const char *)(a1 + 16), a2 - 16), v17 = v16 + 1, v16 + 1 > v13))
  {
    result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    v29 = 0;
    v21 = 0;
    v22 = 0;
    v30 = 0;
    v17 = 0;
    v18 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = 0;
  }
  else
  {
    v18 = v16 + 17;
    v19 = a2 - (v16 + 17);
    if (a2 == v16 + 17)
    {
      result = 0;
LABEL_5:
      v21 = 0;
      v22 = 0;
      v18 = 0;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 1;
      v30 = 16;
      goto LABEL_14;
    }
    v23 = strnlen((const char *)(a1 + v18), v19) + 1;
    if (v23 > v19)
    {
      result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_5;
    }
    v24 = v23 + v18;
    if (a2 == v23 + v18)
    {
      result = 0;
LABEL_9:
      v22 = 0;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      v27 = 0;
      v28 = 0;
      v29 = 1;
      v30 = 16;
      v21 = 1;
      goto LABEL_14;
    }
    v25 = strnlen((const char *)(a1 + v24), a2 - (v23 + v18)) + 1;
    if (v25 > a2 - (v23 + v18))
    {
      result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_9;
    }
    v27 = v25 + v24;
    result = 0;
    v28 = a2 - (v25 + v24);
    if (a2 == v25 + v24)
    {
      v26 = 0;
      v27 = 0;
      v29 = 1;
      v30 = 16;
      v21 = 1;
      v22 = 1;
    }
    else
    {
      v29 = 1;
      v30 = 16;
      v21 = 1;
      v22 = 1;
      v26 = 1;
    }
  }
LABEL_14:
  if (a3)
    *a3 = v29;
  if (a5)
    *a5 = v21;
  if (a7)
    *a7 = v22;
  if (a9)
    *a9 = v26;
  if (a4)
  {
    *a4 = v30;
    a4[1] = v17;
  }
  if (a6)
  {
    *a6 = v18;
    a6[1] = v23;
  }
  if (a8)
  {
    *a8 = v24;
    a8[1] = v25;
  }
  if (a10)
  {
    *a10 = v27;
    a10[1] = v28;
  }
  return result;
}

void InlineResourcesPayloadWritingApplierFunc(const __CFDictionary *a1, uint64_t a2)
{
  uint64_t v4;
  UInt8 *v5;
  CFIndex Length;
  CFIndex v7;
  const UInt8 *BytePtr;
  CFIndex v9;
  CFIndex maxBufLen;
  _OWORD v11[3];
  uint64_t v12;
  _OWORD v13[3];
  uint64_t v14;
  unsigned int valuePtr;
  void *v16;
  void *v17;
  void *v18;
  void *value;
  CFRange v20;
  CFRange v21;
  CFRange v22;
  CFRange v23;

  v18 = 0;
  value = 0;
  v16 = 0;
  v17 = 0;
  valuePtr = 0;
  v4 = *(_QWORD *)(a2 + 8);
  v14 = 0;
  memset(v13, 0, sizeof(v13));
  v12 = 0;
  memset(v11, 0, sizeof(v11));
  if (CFDictionaryGetValueIfPresent(a1, CFSTR("resource_role"), (const void **)&value))
    CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
  CFDictionaryGetValueIfPresent(a1, CFSTR("resource_mimetype"), (const void **)&v18);
  CFDictionaryGetValueIfPresent(a1, CFSTR("resource_mimetype_URI"), (const void **)&v17);
  CFDictionaryGetValueIfPresent(a1, CFSTR("resource_payload"), (const void **)&v16);
  v5 = 0;
  if (!value || !v18 || !v16)
    goto LABEL_26;
  if (FigAtomWriterInitWithParent(v4, (uint64_t)v13))
    goto LABEL_28;
  if (FigAtomWriterBeginAtom((uint64_t)v13, 0x72737263u, 0))
    goto LABEL_28;
  if (FigAtomWriterInitWithParent((uint64_t)v13, (uint64_t)v11))
    goto LABEL_28;
  if (FigAtomWriterBeginAtom((uint64_t)v11, 0x74797065u, 0))
    goto LABEL_28;
  if (FigAtomWriterAppendVersionAndFlags((uint64_t)v11, 0, 0))
    goto LABEL_28;
  valuePtr = bswap32(valuePtr);
  if (FigAtomWriterAppendData((uint64_t)v11, (uint64_t)&valuePtr, 4))
    goto LABEL_28;
  if (v18)
  {
    Length = CFStringGetLength((CFStringRef)v18);
    maxBufLen = 0;
    v20.location = 0;
    v20.length = Length;
    CFStringGetBytes((CFStringRef)v18, v20, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
    if (!maxBufLen)
      goto LABEL_27;
    v5 = (UInt8 *)malloc_type_malloc(maxBufLen + 1, 0xCCD4FD58uLL);
    v21.location = 0;
    v21.length = Length;
    CFStringGetBytes((CFStringRef)v18, v21, 0x8000100u, 0, 0, v5, maxBufLen, &maxBufLen);
    v5[maxBufLen] = 0;
    if (FigAtomWriterAppendData((uint64_t)v11, (uint64_t)v5, maxBufLen + 1))
      goto LABEL_26;
    free(v5);
  }
  if (!v17)
  {
LABEL_20:
    if (!FigAtomWriterEndAtom((uint64_t)v11)
      && !FigAtomWriterBeginAtom((uint64_t)v11, 0x64617461u, 0))
    {
      BytePtr = CFDataGetBytePtr((CFDataRef)v16);
      v9 = CFDataGetLength((CFDataRef)v16);
      if (!FigAtomWriterAppendData((uint64_t)v11, (uint64_t)BytePtr, v9)
        && !FigAtomWriterEndAtom((uint64_t)v11)
        && !FigAtomWriterEndAtom((uint64_t)v13))
      {
        v5 = 0;
        ++**(_QWORD **)a2;
        goto LABEL_26;
      }
    }
LABEL_28:
    v5 = 0;
    goto LABEL_26;
  }
  v7 = CFStringGetLength((CFStringRef)v17);
  maxBufLen = 0;
  v22.location = 0;
  v22.length = v7;
  CFStringGetBytes((CFStringRef)v17, v22, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
  if (!maxBufLen)
  {
LABEL_27:
    FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    goto LABEL_28;
  }
  v5 = (UInt8 *)malloc_type_malloc(maxBufLen + 1, 0x1D7B6DF8uLL);
  v23.location = 0;
  v23.length = v7;
  CFStringGetBytes((CFStringRef)v17, v23, 0x8000100u, 0, 0, v5, maxBufLen, &maxBufLen);
  v5[maxBufLen] = 0;
  if (!FigAtomWriterAppendData((uint64_t)v11, (uint64_t)v5, maxBufLen + 1))
  {
    free(v5);
    goto LABEL_20;
  }
LABEL_26:
  free(v5);
}

uint64_t FigHALAudioObjectMapperCreate(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t v3;

  v2 = (uint64_t *)malloc_type_calloc(1uLL, 0x10uLL, 0x10200403A5D3213uLL);
  if (v2)
  {
    v3 = FigCFWeakReferenceTableCreate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], 3, v2);
    if (!(_DWORD)v3)
    {
      *((_DWORD *)v2 + 2) = 1;
      *a1 = v2;
      v2 = 0;
    }
  }
  else
  {
    v3 = FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
  }
  FigHALAudioObjectMapperDispose((const void **)v2);
  return v3;
}

void FigHALAudioObjectMapperDispose(const void **a1)
{
  const void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      CFRelease(v2);
    free(a1);
  }
}

id FigHALAudioObjectMapperCopyObjectForID(uint64_t *a1, unsigned int a2)
{
  return FigCFWeakReferenceTableCopyValue(*a1, (void *)a2);
}

uint64_t FigHALAudioObjectMapperAddPluginObjectMapping(uint64_t *a1, uint64_t a2)
{
  return FigCFWeakReferenceTableAddValueAssociatedWithKey(*a1, a2, 1);
}

uint64_t FigHALAudioObjectMapperAddMapping(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  unsigned int v6;
  uint64_t result;

  v6 = FigAtomicIncrement32((unsigned int *)(a1 + 8));
  result = FigCFWeakReferenceTableAddValueAssociatedWithKey(*(_QWORD *)a1, a2, v6);
  *a3 = v6;
  return result;
}

uint64_t FigHALAudioObjectMapperRemoveMapping(uint64_t *a1, unsigned int a2)
{
  return FigCFWeakReferenceTableRemoveValue(*a1, a2);
}

uint64_t FigVideoFormatDescriptionCreateFromBigEndianImageDescriptionDataWithReporter(const __CFAllocator *a1, __int128 *a2, unint64_t a3, CFStringEncoding a4, CFTypeRef cf1, CMVideoFormatDescriptionRef *a6, const void *a7)
{
  _BOOL4 v13;
  signed int v15;
  __int128 v16;
  __int128 v17;
  int v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  const char *v23;
  __int128 v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  unint64_t v31;
  size_t v32;
  int v33;
  CFStringRef v34;
  unsigned int v35;
  CFStringRef v36;
  size_t v37;
  size_t v38;
  _QWORD *v39;
  _QWORD *v40;
  uint64_t MPEG4VideoCodecTypeAndCopyDecoderSpecificInfo;
  CFTypeRef *v42;
  CFTypeRef v43;
  CFDataRef v44;
  uint64_t v45;
  CFTypeRef v46;
  uint64_t v47;
  CFTypeRef v48;
  const __CFAllocator *v49;
  CFNumberRef v50;
  uint64_t v51;
  CFTypeRef v52;
  CFNumberRef v53;
  uint64_t v54;
  CFTypeRef v55;
  CFNumberRef v56;
  uint64_t v57;
  CFTypeRef v58;
  CFNumberRef v59;
  uint64_t v60;
  CFIndex v61;
  CFTypeRef v62;
  CFStringRef v63;
  uint64_t v64;
  CFTypeRef v65;
  CFNumberRef v66;
  uint64_t v67;
  int32_t v68;
  int v69;
  int32_t v70;
  const void *v71;
  CMVideoFormatDescriptionRef v72;
  size_t v73;
  size_t v74;
  const void *v75;
  size_t v76;
  size_t v77;
  const void *v78;
  unsigned int ConciseProtectedCodecType;
  const void *Value;
  CMVideoCodecType v81;
  char v82;
  int v83;
  uint64_t v84;
  _BOOL4 v85;
  int32_t v86;
  unsigned int v87;
  unsigned int v88;
  int valuePtr;
  size_t v90;
  uint64_t v91;
  size_t count;
  CFTypeRef v93;
  CFTypeRef cf;
  __int16 v95;
  unsigned int v96;
  CMVideoFormatDescriptionRef formatDescriptionOut;
  _OWORD context[16];
  __int128 v99;
  __int128 v100;
  __int128 v101;
  _BYTE v102[38];
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
  formatDescriptionOut = 0;
  v96 = 0;
  v95 = 0;
  v93 = 0;
  cf = 0;
  v91 = 0;
  count = 0;
  v90 = 0;
  v88 = 0;
  valuePtr = 0;
  v87 = 0;
  if (!a2 || a3 <= 0x55 || !a6)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (cf1)
    v13 = CFEqual(cf1, CFSTR("ISOFamily")) == 0;
  else
    v13 = 1;
  v15 = bswap32(*(_DWORD *)a2);
  v99 = 0u;
  v100 = 0u;
  v101 = 0u;
  memset(v102, 0, sizeof(v102));
  if (v15 >= 0x56 && v15 <= a3)
  {
    *(_QWORD *)&v102[30] = *(_QWORD *)((char *)a2 + 78);
    v16 = a2[3];
    v101 = a2[2];
    *(_OWORD *)v102 = v16;
    *(_OWORD *)&v102[16] = a2[4];
    v17 = a2[1];
    v99 = *a2;
    v100 = v17;
    v18 = bswap32(DWORD1(v99));
    v96 = v18;
    v19 = WORD1(v101);
    v20 = bswap32(*(unsigned __int16 *)&v102[34]);
    v95 = HIWORD(v20);
    if (DWORD1(v99) == 544694642)
    {
      v96 = v20 >> 16;
      v95 = 0;
      v18 = v20 >> 16;
    }
    else if (v20 >> 16 < 0)
    {
      strcpy((char *)context, "Image description has negative depth");
      goto LABEL_79;
    }
    if ((_WORD)v101)
    {
      if (WORD1(v101))
      {
        if ((v18 & 0xFFFFFFFE) == 0x64766870 && (unsigned __int16)v101 == 5 && WORD1(v101) == 53250)
        {
          v22 = 960;
        }
        else
        {
          v22 = __rev16((unsigned __int16)v101);
          switch(v18)
          {
            case 1685481522:
            case 1685481525:
              goto LABEL_22;
            case 1685481523:
            case 1685481526:
              if ((unsigned __int16)v101 == 32775 && WORD1(v101) == 14340)
              {
                v22 = 1280;
              }
              else if (v18 == 1685481525)
              {
LABEL_22:
                if ((unsigned __int16)v101 == 32775 && WORD1(v101) == 14340)
                  v22 = 1440;
              }
              break;
            default:
              break;
          }
        }
        if (*(_WORD *)&v102[36])
        {
          v25 = 86;
          goto LABEL_34;
        }
        if (v15 <= 0x65)
        {
          strcpy((char *)context, "Image description is too small to have a color table");
          goto LABEL_79;
        }
        v33 = (int)bswap32(*((unsigned __int16 *)a2 + 46)) >> 16;
        if (v33 < 0)
        {
          strcpy((char *)context, "Image description has negative color table size");
          goto LABEL_79;
        }
        v25 = 8 * (unsigned __int16)v33 + 102;
        if (v25 <= v15)
        {
LABEL_34:
          v85 = v13;
          v86 = v22;
          v26 = (uint64_t)a2 + v25;
          v27 = v15 - v25;
          v28 = figBridge_WalkAndConvertImageDescriptionExtensions(a1, (uint64_t)a2 + v25, v27, (uint64_t)&count, 0, 0, &v90, 0, a7);
          if ((_DWORD)v28)
          {
            v21 = v28;
LABEL_80:
            v72 = 0;
            v39 = 0;
            v40 = 0;
LABEL_81:
            v36 = 0;
LABEL_82:
            FigFormatDescriptionRelease(v72);
            if (v93)
              CFRelease(v93);
            if (v36)
              CFRelease(v36);
            if (cf)
              CFRelease(cf);
            if (v39)
            {
              v73 = count;
              if (count)
              {
                v74 = 0;
                do
                {
                  v75 = (const void *)v39[v74];
                  if (v75)
                  {
                    CFRelease(v75);
                    v73 = count;
                  }
                  ++v74;
                }
                while (v74 < v73);
              }
              free(v39);
            }
            if (v40)
            {
              v76 = count;
              if (count)
              {
                v77 = 0;
                do
                {
                  v78 = (const void *)v40[v77];
                  if (v78)
                  {
                    CFRelease(v78);
                    v76 = count;
                  }
                  ++v77;
                }
                while (v77 < v76);
              }
              free(v40);
            }
            return v21;
          }
          v84 = v26;
          v29 = 0;
          v30 = __rev16(v19);
          v31 = v27;
          while (figBridge_ConvertMPEG2ProfileCodecTypesToProfileExtensions_mpeg2ConformingVideoCodecTypes[v29] != v96)
          {
            if (++v29 == 39)
            {
              v32 = count;
              goto LABEL_46;
            }
          }
          v32 = count + 1;
LABEL_46:
          count = v32 + 1;
          if (v102[2] - 1 > 0x1E)
          {
            v35 = bswap32(DWORD1(v99));
            v34 = CFStringCreateWithFormat(a1, 0, CFSTR("'%c%c%c%c'"), HIBYTE(v35), BYTE2(v35), BYTE1(v35), v35);
          }
          else
          {
            v34 = CFStringCreateWithPascalString(a1, &v102[2], a4);
          }
          v36 = v34;
          v37 = count;
          if (v34)
            v37 = count + 1;
          v38 = v37 + 4;
          count = v37 + 4;
          if (DWORD1(v100))
          {
            v38 = v37 + 5;
            count = v37 + 5;
          }
          if (v95)
            count = ++v38;
          if (v38)
          {
            v39 = malloc_type_calloc(v38, 8uLL, 0x6004044C4A2DFuLL);
            if (!v39)
            {
              v21 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              v72 = 0;
              v40 = 0;
              goto LABEL_82;
            }
            v40 = malloc_type_calloc(count, 8uLL, 0xC0040B8AA526DuLL);
            if (!v40)
            {
              MPEG4VideoCodecTypeAndCopyDecoderSpecificInfo = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              goto LABEL_106;
            }
            MPEG4VideoCodecTypeAndCopyDecoderSpecificInfo = figBridge_WalkAndConvertImageDescriptionExtensions(a1, v84, v31, (uint64_t)&v91, (uint64_t)v39, (uint64_t)v40, 0, v90, a7);
            if ((_DWORD)MPEG4VideoCodecTypeAndCopyDecoderSpecificInfo)
            {
LABEL_106:
              v21 = MPEG4VideoCodecTypeAndCopyDecoderSpecificInfo;
              goto LABEL_131;
            }
            figBridge_ConvertMPEG2ProfileCodecTypesToProfileExtensions((void *)v96, &v96, &v91, (uint64_t)v39, (uint64_t)v40);
            v42 = (CFTypeRef *)&kCMFormatDescriptionExtension_VerbatimSampleDescription;
            if (!v85)
              v42 = (CFTypeRef *)&kCMFormatDescriptionExtension_VerbatimISOSampleEntry;
            v43 = CFRetain(*v42);
            v39[v91] = v43;
            v44 = CFDataCreate(a1, (const UInt8 *)a2, a3);
            v45 = v91;
            v40[v91] = v44;
            v91 = v45 + 1;
            if (v36)
            {
              v46 = CFRetain(CFSTR("FormatName"));
              v47 = v91;
              v39[v91] = v46;
              v40[v47] = v36;
              v91 = v47 + 1;
            }
            HIWORD(valuePtr) = bswap32((unsigned __int16)v100) >> 16;
            v48 = CFRetain(CFSTR("Version"));
            v39[v91] = v48;
            v49 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v50 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt16Type, (char *)&valuePtr + 2);
            v51 = v91;
            v40[v91] = v50;
            v91 = v51 + 1;
            LOWORD(valuePtr) = bswap32(WORD1(v100)) >> 16;
            v52 = CFRetain(CFSTR("RevisionLevel"));
            v39[v91] = v52;
            v53 = CFNumberCreate(v49, kCFNumberSInt16Type, &valuePtr);
            v54 = v91;
            v40[v91] = v53;
            v91 = v54 + 1;
            v88 = bswap32(DWORD2(v100));
            v55 = CFRetain(CFSTR("TemporalQuality"));
            v39[v91] = v55;
            v56 = CFNumberCreate(v49, kCFNumberSInt32Type, &v88);
            v57 = v91;
            v40[v91] = v56;
            v91 = v57 + 1;
            v87 = bswap32(HIDWORD(v100));
            v58 = CFRetain(CFSTR("SpatialQuality"));
            v39[v91] = v58;
            v59 = CFNumberCreate(v49, kCFNumberSInt32Type, &v87);
            v60 = v91;
            v40[v91] = v59;
            v61 = v60 + 1;
            v91 = v60 + 1;
            if (DWORD1(v100))
            {
              v62 = CFRetain(CFSTR("Vendor"));
              v39[v91] = v62;
              v63 = CFStringCreateWithBytes(a1, (const UInt8 *)&v100 + 4, 4, 0, 0);
              v64 = v91;
              v40[v91] = v63;
              v61 = v64 + 1;
              v91 = v64 + 1;
            }
            if (v95)
            {
              v65 = CFRetain(CFSTR("Depth"));
              v39[v91] = v65;
              v66 = CFNumberCreate(v49, kCFNumberSInt16Type, &v95);
              v67 = v91;
              v40[v91] = v66;
              v61 = v67 + 1;
              v91 = v67 + 1;
            }
            if (count == v61)
            {
              cf = CFDictionaryCreate(a1, (const void **)v39, (const void **)v40, v61, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              if (cf)
              {
                v36 = 0;
LABEL_71:
                v68 = v30;
                v69 = v96;
                if (v96 != 1836070006)
                {
                  v70 = v86;
                  goto LABEL_109;
                }
                MPEG4VideoCodecTypeAndCopyDecoderSpecificInfo = (uint64_t)figBridge_GetMPEG4VideoCodecTypeAndCopyDecoderSpecificInfo((const __CFDictionary *)cf, (int *)&v96, (__CFDictionary **)&v93);
                if (!(_DWORD)MPEG4VideoCodecTypeAndCopyDecoderSpecificInfo)
                {
                  if ((uint64_t)FigCFDictionaryGetCount((CFDictionaryRef)v93) < 1)
                  {
                    v70 = v86;
                  }
                  else
                  {
                    context[0] = (unint64_t)cf;
                    *(_QWORD *)&context[1] = __PAIR64__(v30, v86);
                    CFDictionaryApplyFunction((CFDictionaryRef)v93, (CFDictionaryApplierFunction)figbridge_ConsumeMP4BridgeDecoderSpecificInfo, context);
                    v70 = context[1];
                    v68 = DWORD1(context[1]);
                    v71 = (const void *)*((_QWORD *)&context[0] + 1);
                    if (*((_QWORD *)&context[0] + 1))
                    {
                      if (cf)
                      {
                        CFRelease(cf);
                        v71 = (const void *)*((_QWORD *)&context[0] + 1);
                      }
                      cf = v71;
                    }
                  }
                  v69 = v96;
LABEL_109:
                  if (v69 == 1701733238)
                  {
                    ConciseProtectedCodecType = figBridge_GetConciseProtectedCodecType((const __CFDictionary *)cf);
                    if (ConciseProtectedCodecType)
                    {
                      v69 = ConciseProtectedCodecType;
                      v96 = ConciseProtectedCodecType;
                    }
                    else
                    {
                      v69 = v96;
                    }
                  }
                  if (FigVideoCodecTypeIsH264Flavor(v69)
                    || FigVideoCodecTypeIsHEVCFlavorOrDolbyVisionHEVCFlavor(v69))
                  {
                    goto LABEL_115;
                  }
                  if (v69 > 1902212656)
                  {
                    if (v69 != 1902403958)
                    {
                      v83 = 1902212657;
LABEL_138:
                      if (v69 != v83)
                        goto LABEL_118;
                    }
                  }
                  else if (v69 != 1635135537)
                  {
                    v83 = 1684108849;
                    goto LABEL_138;
                  }
LABEL_115:
                  FigBridge_MakeFallbackExtensionsFromVUI(a1, v69, (uint64_t)a7, (const __CFDictionary **)&cf);
                  if (FigVideoCodecTypeIsHEVCFlavorOrDolbyVisionHEVCFlavor(v96))
                  {
                    Value = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("AlternativeTransferCharacteristics"));
                    if (Value)
                      figBridge_OverrideTransferFunctionFromAlternativeTransferCharacteristics(a1, Value, (CFDictionaryRef *)&cf);
                  }
LABEL_118:
                  v81 = v96;
                  if (FigVideoCodecTypeIsProRes(v96))
                  {
                    figBridge_GetBitsPerComponentForProRes(a1, v81, (uint64_t *)&cf);
                    figBridge_GetAlphaChannelExtensionForProRes(a1, (uint64_t *)&cf);
                    v81 = v96;
                  }
                  if (v81 == 1932670515)
                  {
                    if (figBridge_Is3GP263ExtensionPresent((const __CFDictionary *)cf))
                    {
                      v81 = 1748121139;
                      goto LABEL_128;
                    }
                    v81 = v96;
                  }
                  v82 = v85;
                  if (v81 != 1835692135)
                    v82 = 1;
                  if ((v82 & 1) != 0)
                    goto LABEL_129;
                  v81 = 1785750887;
LABEL_128:
                  v96 = v81;
LABEL_129:
                  v21 = CMVideoFormatDescriptionCreate(a1, v81, v70, v68, (CFDictionaryRef)cf, &formatDescriptionOut);
                  v72 = formatDescriptionOut;
                  if ((_DWORD)v21)
                    goto LABEL_82;
                  *a6 = formatDescriptionOut;
                  formatDescriptionOut = 0;
LABEL_131:
                  v72 = 0;
                  goto LABEL_82;
                }
                goto LABEL_106;
              }
              v21 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
            }
            else
            {
              strcpy((char *)context, "Image description data could have changed");
              v21 = 4294954582;
              FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
              figSoundBridge_ReportParsingFailureMessage((uint64_t)a7, (uint64_t)context);
            }
            v72 = 0;
            goto LABEL_81;
          }
          v39 = 0;
          v40 = 0;
          goto LABEL_71;
        }
        v23 = "Image description color table size is too big";
      }
      else
      {
        v23 = "Image description has negative or zero height";
      }
      v24 = *((_OWORD *)v23 + 1);
      context[0] = *(_OWORD *)v23;
      context[1] = v24;
      *(_OWORD *)((char *)&context[1] + 14) = *(_OWORD *)(v23 + 30);
    }
    else
    {
      strcpy((char *)context, "Image description has negative or zero width");
    }
LABEL_79:
    v21 = 4294954582;
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    figSoundBridge_ReportParsingFailureMessage((uint64_t)a7, (uint64_t)context);
    goto LABEL_80;
  }
  strcpy((char *)context, "Image description size is incorrect");
  v21 = 4294954582;
  FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  figSoundBridge_ReportParsingFailureMessage((uint64_t)a7, (uint64_t)context);
  return v21;
}

const __CFDictionary *figBridge_GetMPEG4VideoCodecTypeAndCopyDecoderSpecificInfo(const __CFDictionary *result, int *a2, __CFDictionary **a3)
{
  const void *Value;
  const void *v6;
  CFTypeID TypeID;
  const __CFArray *v8;
  const __CFArray *ValueAtIndex;
  CFTypeID v10;
  CFTypeID v11;
  const UInt8 *BytePtr;
  CFIndex Length;
  int v14;
  unsigned __int8 v15;

  if (result)
  {
    v15 = 0;
    Value = CFDictionaryGetValue(result, CFSTR("SampleDescriptionExtensionAtoms"));
    if (!Value)
      return 0;
    v6 = Value;
    TypeID = CFDictionaryGetTypeID();
    if (TypeID != CFGetTypeID(v6))
      return 0;
    v8 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v6, CFSTR("esds"));
    if (!v8)
      return 0;
    ValueAtIndex = v8;
    v10 = CFArrayGetTypeID();
    if (v10 == CFGetTypeID(ValueAtIndex))
    {
      ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
      if (!ValueAtIndex)
        return 0;
    }
    v11 = CFDataGetTypeID();
    if (v11 != CFGetTypeID(ValueAtIndex))
      return 0;
    BytePtr = CFDataGetBytePtr(ValueAtIndex);
    Length = CFDataGetLength(ValueAtIndex);
    if (FigMP4Bridge_GetESDSObjectTypeAndCopyDecoderSpecificInfo((unint64_t)BytePtr, Length, (char *)&v15, 0, a3))return 0;
    v14 = 1836069238;
    if (v15 > 0x64u)
    {
      if (v15 != 101)
      {
        if (v15 == 106)
          goto LABEL_18;
        if (v15 == 108)
        {
          v14 = 1785750887;
          goto LABEL_18;
        }
        return (const __CFDictionary *)FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
      }
    }
    else if (v15 - 96 >= 2)
    {
      if (v15 == 32)
      {
        v14 = 1836070006;
LABEL_18:
        *a2 = v14;
        return 0;
      }
      return (const __CFDictionary *)FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
    }
    v14 = 1836069494;
    goto LABEL_18;
  }
  return result;
}

void figbridge_ConsumeMP4BridgeDecoderSpecificInfo(const void *a1, const __CFNumber *a2, uint64_t a3)
{
  int SInt32;
  int v7;
  __CFDictionary *MutableCopy;

  if (CFEqual(a1, CFSTR("VideoWidth")))
  {
    SInt32 = FigCFNumberGetSInt32(a2);
    if (SInt32 >= 1)
      *(_DWORD *)(a3 + 16) = SInt32;
  }
  else if (CFEqual(a1, CFSTR("VideoHeight")))
  {
    v7 = FigCFNumberGetSInt32(a2);
    if (v7 >= 1)
      *(_DWORD *)(a3 + 20) = v7;
  }
  else if (!CFDictionaryContainsKey(*(CFDictionaryRef *)a3, a1))
  {
    MutableCopy = *(__CFDictionary **)(a3 + 8);
    if (MutableCopy
      || (MutableCopy = FigCFDictionaryCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(CFDictionaryRef *)a3), (*(_QWORD *)(a3 + 8) = MutableCopy) != 0))
    {
      CFDictionaryAddValue(MutableCopy, a1, a2);
    }
  }
}

const __CFDictionary *figBridge_GetConciseProtectedCodecType(const __CFDictionary *result)
{
  const __CFDictionary *v1;
  CFTypeID v2;
  CFIndex v3;
  const void *ValueAtIndex;
  CFTypeID v5;
  const UInt8 *v6;
  CFIndex v7;
  CFTypeID v8;
  const UInt8 *BytePtr;
  CFIndex Length;

  if (!result)
    return result;
  result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("SampleDescriptionExtensionAtoms"));
  if (!result)
    return result;
  result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("sinf"));
  if (!result)
    return result;
  v1 = result;
  v2 = CFGetTypeID(result);
  if (v2 != CFArrayGetTypeID())
  {
    v8 = CFGetTypeID(v1);
    if (v8 == CFDataGetTypeID())
    {
      BytePtr = CFDataGetBytePtr(v1);
      Length = CFDataGetLength(v1);
      return (const __CFDictionary *)figBridge_GetConciseProtectedCodecTypeFromSinfData((uint64_t)BytePtr, Length);
    }
    return 0;
  }
  if (CFArrayGetCount(v1) < 1)
    return 0;
  v3 = 0;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v1, v3);
    v5 = CFGetTypeID(ValueAtIndex);
    if (v5 == CFDataGetTypeID())
    {
      v6 = CFDataGetBytePtr((CFDataRef)ValueAtIndex);
      v7 = CFDataGetLength((CFDataRef)ValueAtIndex);
      result = (const __CFDictionary *)figBridge_GetConciseProtectedCodecTypeFromSinfData((uint64_t)v6, v7);
      if ((_DWORD)result)
        break;
    }
    if (CFArrayGetCount(v1) <= ++v3)
      return 0;
  }
  return result;
}

uint64_t FigVideoCodecTypeIsH264Flavor(int a1)
{
  uint64_t result;
  int v3;

  result = 1;
  if (a1 > 1700886114)
  {
    if (a1 > 1902212708)
    {
      if (a1 == 1902212709)
        return result;
      v3 = 2053207651;
    }
    else
    {
      if (a1 == 1700886115)
        return result;
      v3 = 1902212707;
    }
  }
  else if (a1 > 1667331682)
  {
    if (a1 == 1667331683)
      return result;
    v3 = 1685220713;
  }
  else
  {
    if (a1 == 1635148593)
      return result;
    v3 = 1635148595;
  }
  if (a1 != v3)
    return 0;
  return result;
}

uint64_t FigVideoCodecTypeIsHEVCFlavorOrDolbyVisionHEVCFlavor(int a1)
{
  uint64_t result;
  int v3;

  result = 1;
  if (a1 > 1836415072)
  {
    if (a1 > 1902407031)
    {
      if (a1 > 1902671458)
      {
        if (a1 == 1902671459)
          return result;
        v3 = 1902998904;
      }
      else
      {
        if (a1 == 1902407032)
          return result;
        v3 = 1902667126;
      }
    }
    else if (a1 > 1902405680)
    {
      if (a1 == 1902405681)
        return result;
      v3 = 1902405733;
    }
    else
    {
      if (a1 == 1836415073)
        return result;
      v3 = 1869117027;
    }
  }
  else if (a1 > 1685481572)
  {
    if (a1 > 1751479856)
    {
      if (a1 == 1751479857)
        return result;
      v3 = 1752589105;
    }
    else
    {
      if (a1 == 1685481573)
        return result;
      v3 = 1718908520;
    }
  }
  else if (a1 > 1684895095)
  {
    if (a1 == 1684895096)
      return result;
    v3 = 1685481521;
  }
  else
  {
    if (a1 == 1667524657)
      return result;
    v3 = 1667790435;
  }
  if (a1 != v3)
    return 0;
  return result;
}

uint64_t FigBridge_MakeFallbackExtensionsFromVUI(const __CFAllocator *a1, int a2, uint64_t a3, const __CFDictionary **a4)
{
  const __CFDictionary *v4;
  const void *Value;
  const void *v10;
  CFTypeID TypeID;
  const __CFString *v12;
  int v13;
  int v14;
  int v15;
  const __CFArray *v16;
  const __CFArray *ValueAtIndex;
  CFTypeID v18;
  CFTypeID v19;
  int v20;
  int v21;
  int v22;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  int SPS_VUI_ChromaLocation;
  int v31;
  int v32;
  int v33;
  unsigned __int8 v34;
  const void *v35;
  const void *v36;
  _QWORD *v37;
  CFTypeRef v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  int v44;
  int SeqOBU_VUI_NCLC;
  CFStringRef StringForIntegerCodePoint;
  _QWORD *v47;
  CFTypeRef v48;
  uint64_t v49;
  CFStringRef v50;
  _QWORD *v51;
  CFTypeRef v52;
  uint64_t v53;
  uint64_t v54;
  CFStringRef v55;
  _QWORD *v56;
  CFTypeRef v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  int v62;
  int SPS_VUI_FullRangeVideo;
  CFTypeRef *v64;
  CFTypeRef v65;
  uint64_t v66;
  uint64_t v67;
  int IsHEVCFlavor;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  const void *v75;
  int v76;
  int v77;
  const void *v78;
  const void *v79;
  _BOOL4 v80;
  int v81;
  const void *v82;
  int v83;
  uint64_t v84;
  const void *v85;
  const UInt8 *v86;
  CFIndex v87;
  const CFStringRef *v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  int v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  CFDictionaryRef v101;
  int v102;
  int SPSIsInterlaced;
  CFNumberRef v104;
  CFTypeRef *v105;
  int yCbCrMatrixCodePoint;
  int colorPrimariesCodePoint[2];
  unint64_t v108;
  UInt8 *v109;
  CFDictionaryRef v110;
  _OWORD v111[10];
  _QWORD v112[20];
  char __str[264];
  uint64_t v114;

  v114 = *MEMORY[0x1E0C80C00];
  v4 = *a4;
  v110 = 0;
  memset(v112, 0, sizeof(v112));
  memset(v111, 0, sizeof(v111));
  if (!v4)
    return 0;
  Value = CFDictionaryGetValue(v4, CFSTR("SampleDescriptionExtensionAtoms"));
  if (!Value)
    return 0;
  v10 = Value;
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v10))
    return 0;
  v12 = CFSTR("avcC");
  if (a2 > 1752589104)
  {
    if (a2 > 1902405680)
    {
      if (a2 <= 1902667125)
      {
        if (a2 == 1902405681 || a2 == 1902405733)
          goto LABEL_48;
        v13 = 1902407032;
      }
      else
      {
        if (a2 <= 1902998903)
        {
          if (a2 != 1902667126)
          {
            v13 = 1902671459;
            goto LABEL_47;
          }
          goto LABEL_48;
        }
        if (a2 == 2053207651)
          goto LABEL_49;
        v13 = 1902998904;
      }
    }
    else
    {
      if (a2 > 1902212656)
      {
        if (a2 > 1902212708)
        {
          if (a2 == 1902212709)
            goto LABEL_49;
          v15 = 1902403958;
LABEL_41:
          if (a2 != v15)
            goto LABEL_72;
LABEL_42:
          v12 = CFSTR("av1C");
          goto LABEL_49;
        }
        if (a2 == 1902212657)
          goto LABEL_42;
        v14 = 1902212707;
        goto LABEL_26;
      }
      if (a2 == 1752589105 || a2 == 1836415073)
        goto LABEL_48;
      v13 = 1869117027;
    }
LABEL_47:
    if (a2 == v13)
      goto LABEL_48;
LABEL_72:
    snprintf(__str, 0x100uLL, "Image description - unsupported format '%c%c%c%c'", HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
    FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
    figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
    return 0;
  }
  if (a2 > 1684895095)
  {
    if (a2 > 1685481572)
    {
      if (a2 > 1718908519)
      {
        if (a2 != 1718908520)
        {
          v13 = 1751479857;
          goto LABEL_47;
        }
        goto LABEL_48;
      }
      if (a2 == 1685481573)
        goto LABEL_48;
      v14 = 1700886115;
LABEL_26:
      if (a2 == v14)
        goto LABEL_49;
      goto LABEL_72;
    }
    if (a2 == 1684895096)
      goto LABEL_48;
    if (a2 == 1685220713)
      goto LABEL_49;
    v13 = 1685481521;
    goto LABEL_47;
  }
  if (a2 <= 1667331682)
  {
    if (a2 == 1635135537)
      goto LABEL_42;
    if (a2 == 1635148593)
      goto LABEL_49;
    v14 = 1635148595;
    goto LABEL_26;
  }
  if (a2 <= 1667790434)
  {
    if (a2 == 1667331683)
      goto LABEL_49;
    v13 = 1667524657;
    goto LABEL_47;
  }
  if (a2 != 1667790435)
  {
    v15 = 1684108849;
    goto LABEL_41;
  }
LABEL_48:
  v12 = CFSTR("hvcC");
LABEL_49:
  v16 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v10, v12);
  if (!v16)
    return 0;
  ValueAtIndex = v16;
  v18 = CFArrayGetTypeID();
  if (v18 == CFGetTypeID(ValueAtIndex))
  {
    ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
    if (!ValueAtIndex)
      return 0;
  }
  v19 = CFDataGetTypeID();
  if (v19 != CFGetTypeID(ValueAtIndex))
    return 0;
  v108 = 0;
  v109 = 0;
  if (a2 > 1752589104)
  {
    if (a2 > 1902405680)
    {
      if (a2 <= 1902667125)
      {
        if (a2 != 1902405681 && a2 != 1902405733)
        {
          v20 = 1902407032;
          goto LABEL_94;
        }
      }
      else
      {
        if (a2 <= 1902998903)
        {
          if (a2 == 1902667126)
            goto LABEL_95;
          v20 = 1902671459;
          goto LABEL_94;
        }
        if (a2 != 1902998904)
        {
          v21 = 2053207651;
          goto LABEL_99;
        }
      }
    }
    else
    {
      if (a2 > 1902212656)
      {
        if (a2 > 1902212708)
        {
          if (a2 == 1902212709)
            goto LABEL_100;
          v22 = 1902403958;
          goto LABEL_89;
        }
        if (a2 == 1902212657)
          goto LABEL_90;
        v21 = 1902212707;
LABEL_99:
        if (a2 != v21)
          goto LABEL_102;
        goto LABEL_100;
      }
      if (a2 != 1752589105 && a2 != 1836415073)
      {
        v20 = 1869117027;
        goto LABEL_94;
      }
    }
LABEL_95:
    if (!FigHEVCBridge_GetHEVCParameterSetAtIndex(ValueAtIndex, 33, 0, (unint64_t)&v109, (unint64_t)&v108, 0, 0))goto LABEL_103;
    return 0;
  }
  if (a2 > 1684895095)
  {
    if (a2 <= 1685481572)
    {
      if (a2 == 1684895096)
        goto LABEL_95;
      if (a2 == 1685220713)
        goto LABEL_100;
      v20 = 1685481521;
    }
    else
    {
      if (a2 <= 1718908519)
      {
        if (a2 == 1685481573)
          goto LABEL_95;
        v21 = 1700886115;
        goto LABEL_99;
      }
      if (a2 == 1718908520)
        goto LABEL_95;
      v20 = 1751479857;
    }
LABEL_94:
    if (a2 == v20)
      goto LABEL_95;
LABEL_102:
    snprintf(__str, 0x100uLL, "Image description - unsupported format '%c%c%c%c'", HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
    FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
    figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
    goto LABEL_103;
  }
  if (a2 <= 1667331682)
  {
    if (a2 == 1635135537)
      goto LABEL_90;
    if (a2 == 1635148593)
      goto LABEL_100;
    v21 = 1635148595;
    goto LABEL_99;
  }
  if (a2 > 1667790434)
  {
    if (a2 == 1667790435)
      goto LABEL_95;
    v22 = 1684108849;
LABEL_89:
    if (a2 != v22)
      goto LABEL_102;
LABEL_90:
    if (!FigAV1Bridge_Getav1CStartAndLength(ValueAtIndex, (const UInt8 **)&v109, &v108))
      goto LABEL_103;
    return 0;
  }
  if (a2 != 1667331683)
  {
    v20 = 1667524657;
    goto LABEL_94;
  }
LABEL_100:
  BytePtr = CFDataGetBytePtr(ValueAtIndex);
  Length = CFDataGetLength(ValueAtIndex);
  if (FigH264Bridge_GetSPSFromAVCC((uint64_t)BytePtr, Length, 0, &v109, &v108))
    return 0;
LABEL_103:
  v25 = *MEMORY[0x1E0CA8CE8];
  if (CFDictionaryContainsKey(v4, (const void *)*MEMORY[0x1E0CA8CE8]))
  {
    v26 = 0;
    goto LABEL_186;
  }
  *(_QWORD *)colorPrimariesCodePoint = 0;
  if (a2 <= 1752589104)
  {
    if (a2 <= 1684895095)
    {
      if (a2 > 1667331682)
      {
        if (a2 <= 1667790434)
        {
          if (a2 != 1667331683)
          {
            v27 = 1667524657;
            goto LABEL_152;
          }
          goto LABEL_158;
        }
        if (a2 == 1667790435)
          goto LABEL_153;
        v29 = 1684108849;
        goto LABEL_140;
      }
      if (a2 == 1635135537)
        goto LABEL_141;
      if (a2 != 1635148593)
      {
        v28 = 1635148595;
        goto LABEL_157;
      }
LABEL_158:
      SPS_VUI_ChromaLocation = FigH264Bridge_GetSPS_VUI_ChromaLocation(v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint);
LABEL_159:
      if (!SPS_VUI_ChromaLocation)
        goto LABEL_161;
      goto LABEL_160;
    }
    if (a2 <= 1685481572)
    {
      if (a2 == 1684895096)
        goto LABEL_153;
      if (a2 == 1685220713)
        goto LABEL_158;
      v27 = 1685481521;
    }
    else
    {
      if (a2 <= 1718908519)
      {
        if (a2 == 1685481573)
          goto LABEL_153;
        v28 = 1700886115;
LABEL_157:
        if (a2 != v28)
          goto LABEL_512;
        goto LABEL_158;
      }
      if (a2 == 1718908520)
        goto LABEL_153;
      v27 = 1751479857;
    }
LABEL_152:
    if (a2 == v27)
      goto LABEL_153;
LABEL_512:
    snprintf(__str, 0x100uLL, "Image description - unsupported format '%c%c%c%c'", HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
    FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
    figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
    goto LABEL_161;
  }
  if (a2 > 1902405680)
  {
    if (a2 <= 1902667125)
    {
      if (a2 != 1902405681 && a2 != 1902405733)
      {
        v27 = 1902407032;
        goto LABEL_152;
      }
    }
    else
    {
      if (a2 <= 1902998903)
      {
        if (a2 == 1902667126)
          goto LABEL_153;
        v27 = 1902671459;
        goto LABEL_152;
      }
      if (a2 != 1902998904)
      {
        v28 = 2053207651;
        goto LABEL_157;
      }
    }
LABEL_153:
    if (!FigHEVCBridge_GetSPS_VUI_ChromaLocation((uint64_t)v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint))goto LABEL_161;
LABEL_160:
    *(_QWORD *)colorPrimariesCodePoint = 0;
    goto LABEL_161;
  }
  if (a2 <= 1902212656)
  {
    if (a2 != 1752589105 && a2 != 1836415073)
    {
      v27 = 1869117027;
      goto LABEL_152;
    }
    goto LABEL_153;
  }
  if (a2 <= 1902212708)
  {
    if (a2 == 1902212657)
      goto LABEL_141;
    v28 = 1902212707;
    goto LABEL_157;
  }
  if (a2 == 1902212709)
    goto LABEL_158;
  v29 = 1902403958;
LABEL_140:
  if (a2 != v29)
    goto LABEL_512;
LABEL_141:
  __str[0] = 0;
  LOBYTE(yCbCrMatrixCodePoint) = 0;
  SPS_VUI_ChromaLocation = FigAV1Bridge_GetChromaFormatAndBitDepthsFromAV1CodecConfigurationRecord((char *)v109, v108, (char *)&yCbCrMatrixCodePoint, __str, 0);
  if (SPS_VUI_ChromaLocation)
    goto LABEL_159;
  if (__str[0] == 2)
  {
    v32 = 3;
  }
  else if (__str[0])
  {
    v32 = 0;
  }
  else
  {
    if (yCbCrMatrixCodePoint == 100)
      v31 = 3;
    else
      v31 = 0;
    if ((_BYTE)yCbCrMatrixCodePoint)
      v32 = v31;
    else
      v32 = 1;
  }
  colorPrimariesCodePoint[0] = v32;
  colorPrimariesCodePoint[1] = v32;
LABEL_161:
  if (a2 > 1700886114)
  {
    if (a2 > 1902212708)
    {
      if (a2 == 1902212709)
        goto LABEL_173;
      v33 = 2053207651;
    }
    else
    {
      if (a2 == 1700886115)
        goto LABEL_173;
      v33 = 1902212707;
    }
  }
  else if (a2 > 1667331682)
  {
    if (a2 == 1667331683)
      goto LABEL_173;
    v33 = 1685220713;
  }
  else
  {
    if (a2 == 1635148593)
      goto LABEL_173;
    v33 = 1635148595;
  }
  if (a2 != v33)
  {
    v34 = colorPrimariesCodePoint[1];
    goto LABEL_176;
  }
LABEL_173:
  v34 = colorPrimariesCodePoint[1];
  if (colorPrimariesCodePoint[1] == 2 && colorPrimariesCodePoint[0] == 2)
  {
    v34 = 1;
    colorPrimariesCodePoint[0] = 1;
    colorPrimariesCodePoint[1] = 1;
  }
LABEL_176:
  v35 = (const void *)figConvertChromaLocationIndexToString(v34);
  if (v35)
  {
    *(_QWORD *)&v111[0] = CFRetain(v35);
    if (*(_QWORD *)&v111[0])
    {
      v112[0] = v25;
      v26 = 1;
    }
    else
    {
      v26 = 0;
    }
  }
  else
  {
    v26 = 0;
    *(_QWORD *)&v111[0] = 0;
  }
  v36 = (const void *)figConvertChromaLocationIndexToString(LOBYTE(colorPrimariesCodePoint[0]));
  v37 = v111;
  if (v36)
  {
    v38 = CFRetain(v36);
    *(_QWORD *)((unint64_t)v111 | (8 * v26)) = v38;
    if (!v38)
      goto LABEL_186;
    v39 = *MEMORY[0x1E0CA8CE0];
    v40 = v26 + 1;
    v37 = v112;
  }
  else
  {
    v39 = 0;
    v40 = v26;
  }
  v37[v26] = v39;
  v26 = v40;
LABEL_186:
  v41 = *MEMORY[0x1E0CA8D68];
  if (CFDictionaryContainsKey(v4, (const void *)*MEMORY[0x1E0CA8D68]))
    goto LABEL_249;
  *(_QWORD *)colorPrimariesCodePoint = 0;
  yCbCrMatrixCodePoint = 0;
  if (a2 > 1752589104)
  {
    if (a2 > 1902405680)
    {
      if (a2 <= 1902667125)
      {
        if (a2 == 1902405681 || a2 == 1902405733)
          goto LABEL_228;
        v42 = 1902407032;
      }
      else
      {
        if (a2 > 1902998903)
        {
          if (a2 == 1902998904)
            goto LABEL_228;
          v43 = 2053207651;
          goto LABEL_231;
        }
        if (a2 == 1902667126)
          goto LABEL_228;
        v42 = 1902671459;
      }
    }
    else
    {
      if (a2 > 1902212656)
      {
        if (a2 > 1902212708)
        {
          if (a2 == 1902212709)
            goto LABEL_232;
          v44 = 1902403958;
          goto LABEL_223;
        }
        if (a2 == 1902212657)
          goto LABEL_224;
        v43 = 1902212707;
        goto LABEL_231;
      }
      if (a2 == 1752589105 || a2 == 1836415073)
        goto LABEL_228;
      v42 = 1869117027;
    }
LABEL_227:
    if (a2 == v42)
      goto LABEL_228;
LABEL_513:
    snprintf(__str, 0x100uLL, "Image description - unsupported format '%c%c%c%c'", HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
    FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
    figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
    goto LABEL_234;
  }
  if (a2 > 1684895095)
  {
    if (a2 <= 1685481572)
    {
      if (a2 == 1684895096)
        goto LABEL_228;
      if (a2 == 1685220713)
        goto LABEL_232;
      v42 = 1685481521;
    }
    else
    {
      if (a2 <= 1718908519)
      {
        if (a2 == 1685481573)
          goto LABEL_228;
        v43 = 1700886115;
LABEL_231:
        if (a2 != v43)
          goto LABEL_513;
        goto LABEL_232;
      }
      if (a2 == 1718908520)
        goto LABEL_228;
      v42 = 1751479857;
    }
    goto LABEL_227;
  }
  if (a2 <= 1667331682)
  {
    if (a2 == 1635135537)
      goto LABEL_224;
    if (a2 == 1635148593)
      goto LABEL_232;
    v43 = 1635148595;
    goto LABEL_231;
  }
  if (a2 > 1667790434)
  {
    if (a2 != 1667790435)
    {
      v44 = 1684108849;
LABEL_223:
      if (a2 != v44)
        goto LABEL_513;
LABEL_224:
      SeqOBU_VUI_NCLC = FigAV1Bridge_GetSeqOBU_VUI_NCLC((char *)v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint, &yCbCrMatrixCodePoint);
      goto LABEL_233;
    }
LABEL_228:
    SeqOBU_VUI_NCLC = FigHEVCBridge_GetSPS_VUI_NCLC((uint64_t)v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint, &yCbCrMatrixCodePoint);
    goto LABEL_233;
  }
  if (a2 != 1667331683)
  {
    v42 = 1667524657;
    goto LABEL_227;
  }
LABEL_232:
  SeqOBU_VUI_NCLC = FigH264Bridge_GetSPS_VUI_NCLC(v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint, &yCbCrMatrixCodePoint);
LABEL_233:
  if (SeqOBU_VUI_NCLC)
    goto LABEL_249;
LABEL_234:
  StringForIntegerCodePoint = CVColorPrimariesGetStringForIntegerCodePoint(colorPrimariesCodePoint[1]);
  v47 = v111;
  if (StringForIntegerCodePoint)
  {
    v48 = CFRetain(StringForIntegerCodePoint);
    *((_QWORD *)v111 + v26) = v48;
    if (!v48)
      goto LABEL_239;
    v49 = v26 + 1;
    v47 = v112;
  }
  else
  {
    v41 = 0;
    v49 = v26;
  }
  v47[v26] = v41;
  v26 = v49;
LABEL_239:
  v50 = CVTransferFunctionGetStringForIntegerCodePoint(colorPrimariesCodePoint[0]);
  v51 = v111;
  if (v50)
  {
    v52 = CFRetain(v50);
    *((_QWORD *)v111 + v26) = v52;
    if (!v52)
      goto LABEL_244;
    v53 = *MEMORY[0x1E0CA8E98];
    v54 = v26 + 1;
    v51 = v112;
  }
  else
  {
    v53 = 0;
    v54 = v26;
  }
  v51[v26] = v53;
  v26 = v54;
LABEL_244:
  v55 = CVYCbCrMatrixGetStringForIntegerCodePoint(yCbCrMatrixCodePoint);
  v56 = v111;
  if (v55)
  {
    v57 = CFRetain(v55);
    *((_QWORD *)v111 + v26) = v57;
    if (!v57)
      goto LABEL_249;
    v58 = *MEMORY[0x1E0CA8EE8];
    v59 = v26 + 1;
    v56 = v112;
  }
  else
  {
    v58 = 0;
    v59 = v26;
  }
  v56[v26] = v58;
  v26 = v59;
LABEL_249:
  if (CFDictionaryContainsKey(v4, CFSTR("FullRangeVideo")))
    goto LABEL_301;
  LOBYTE(colorPrimariesCodePoint[1]) = 0;
  if (a2 > 1752589104)
  {
    if (a2 > 1902405680)
    {
      if (a2 <= 1902667125)
      {
        if (a2 == 1902405681 || a2 == 1902405733)
          goto LABEL_290;
        v60 = 1902407032;
      }
      else
      {
        if (a2 > 1902998903)
        {
          if (a2 == 1902998904)
            goto LABEL_290;
          v61 = 2053207651;
          goto LABEL_293;
        }
        if (a2 == 1902667126)
          goto LABEL_290;
        v60 = 1902671459;
      }
    }
    else
    {
      if (a2 > 1902212656)
      {
        if (a2 > 1902212708)
        {
          if (a2 == 1902212709)
            goto LABEL_294;
          v62 = 1902403958;
          goto LABEL_285;
        }
        if (a2 == 1902212657)
          goto LABEL_286;
        v61 = 1902212707;
        goto LABEL_293;
      }
      if (a2 == 1752589105 || a2 == 1836415073)
        goto LABEL_290;
      v60 = 1869117027;
    }
  }
  else
  {
    if (a2 <= 1684895095)
    {
      if (a2 > 1667331682)
      {
        if (a2 <= 1667790434)
        {
          if (a2 != 1667331683)
          {
            v60 = 1667524657;
            goto LABEL_289;
          }
LABEL_294:
          SPS_VUI_FullRangeVideo = FigH264Bridge_GetSPS_VUI_FullRangeVideo(v109, v108, &colorPrimariesCodePoint[1]);
LABEL_295:
          if (SPS_VUI_FullRangeVideo)
            goto LABEL_301;
          goto LABEL_296;
        }
        if (a2 != 1667790435)
        {
          v62 = 1684108849;
LABEL_285:
          if (a2 != v62)
            goto LABEL_514;
LABEL_286:
          SPS_VUI_FullRangeVideo = FigAV1Bridge_GetColorRangeFromAV1CodecConfigurationRecord((char *)v109, v108, (BOOL *)&colorPrimariesCodePoint[1]);
          goto LABEL_295;
        }
LABEL_290:
        SPS_VUI_FullRangeVideo = FigHEVCBridge_GetSPS_VUI_FullRangeVideo((uint64_t)v109, v108, &colorPrimariesCodePoint[1]);
        goto LABEL_295;
      }
      if (a2 == 1635135537)
        goto LABEL_286;
      if (a2 == 1635148593)
        goto LABEL_294;
      v61 = 1635148595;
LABEL_293:
      if (a2 != v61)
        goto LABEL_514;
      goto LABEL_294;
    }
    if (a2 <= 1685481572)
    {
      if (a2 == 1684895096)
        goto LABEL_290;
      if (a2 == 1685220713)
        goto LABEL_294;
      v60 = 1685481521;
    }
    else
    {
      if (a2 <= 1718908519)
      {
        if (a2 == 1685481573)
          goto LABEL_290;
        v61 = 1700886115;
        goto LABEL_293;
      }
      if (a2 == 1718908520)
        goto LABEL_290;
      v60 = 1751479857;
    }
  }
LABEL_289:
  if (a2 == v60)
    goto LABEL_290;
LABEL_514:
  snprintf(__str, 0x100uLL, "Image description - unsupported format '%c%c%c%c'", HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
  FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
  figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
LABEL_296:
  v64 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
  if (!LOBYTE(colorPrimariesCodePoint[1]))
    v64 = (CFTypeRef *)MEMORY[0x1E0C9AE40];
  v65 = *v64;
  if (*v64)
    v65 = CFRetain(v65);
  *((_QWORD *)v111 + v26) = v65;
  v112[v26++] = CFSTR("FullRangeVideo");
LABEL_301:
  v66 = *MEMORY[0x1E0CA8E68];
  if (CFDictionaryContainsKey(v4, (const void *)*MEMORY[0x1E0CA8E68]))
    goto LABEL_302;
  *(_QWORD *)colorPrimariesCodePoint = 0;
  if (a2 > 1752589104)
  {
    if (a2 > 1902405680)
    {
      if (a2 <= 1902667125)
      {
        if (a2 != 1902405681 && a2 != 1902405733)
        {
          v69 = 1902407032;
          goto LABEL_476;
        }
      }
      else
      {
        if (a2 <= 1902998903)
        {
          if (a2 == 1902667126)
            goto LABEL_477;
          v69 = 1902671459;
          goto LABEL_476;
        }
        if (a2 != 1902998904)
        {
          v72 = 2053207651;
          goto LABEL_481;
        }
      }
    }
    else
    {
      if (a2 > 1902212656)
      {
        if (a2 > 1902212708)
        {
          if (a2 == 1902212709)
            goto LABEL_482;
          v93 = 1902403958;
          goto LABEL_471;
        }
        if (a2 == 1902212657)
          goto LABEL_472;
        v72 = 1902212707;
LABEL_481:
        if (a2 == v72)
          goto LABEL_482;
        goto LABEL_515;
      }
      if (a2 != 1752589105 && a2 != 1836415073)
      {
        v69 = 1869117027;
        goto LABEL_476;
      }
    }
LABEL_477:
    if (FigHEVCBridge_GetSPS_VUI_AspectRatio((uint64_t)v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint))goto LABEL_302;
    goto LABEL_483;
  }
  if (a2 > 1684895095)
  {
    if (a2 <= 1685481572)
    {
      if (a2 == 1684895096)
        goto LABEL_477;
      if (a2 == 1685220713)
        goto LABEL_482;
      v69 = 1685481521;
    }
    else
    {
      if (a2 <= 1718908519)
      {
        if (a2 == 1685481573)
          goto LABEL_477;
        v72 = 1700886115;
        goto LABEL_481;
      }
      if (a2 == 1718908520)
        goto LABEL_477;
      v69 = 1751479857;
    }
LABEL_476:
    if (a2 == v69)
      goto LABEL_477;
    goto LABEL_515;
  }
  if (a2 <= 1667331682)
  {
    if (a2 == 1635135537)
      goto LABEL_472;
    if (a2 == 1635148593)
      goto LABEL_482;
    v72 = 1635148595;
    goto LABEL_481;
  }
  if (a2 <= 1667790434)
  {
    if (a2 != 1667331683)
    {
      v69 = 1667524657;
      goto LABEL_476;
    }
LABEL_482:
    if (FigH264Bridge_GetSPS_VUI_AspectRatio(v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint))goto LABEL_302;
    goto LABEL_483;
  }
  if (a2 == 1667790435)
    goto LABEL_477;
  v93 = 1684108849;
LABEL_471:
  if (a2 == v93)
  {
LABEL_472:
    if (FigAV1Bridge_GetSeqOBU_VUI_AspectRatio((char *)v109, v108, &colorPrimariesCodePoint[1], colorPrimariesCodePoint))goto LABEL_302;
    goto LABEL_483;
  }
LABEL_515:
  snprintf(__str, 0x100uLL, "Image description - unsupported format '%c%c%c%c'", HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
  FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
  figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
LABEL_483:
  v100 = colorPrimariesCodePoint[1];
  if (colorPrimariesCodePoint[1] && colorPrimariesCodePoint[0])
  {
    v112[v26] = v66;
    v101 = figBridge_CFDictionaryCreateWithNumbers(a1, v94, (void *)*MEMORY[0x1E0CA8E60], v95, v96, v97, v98, v99, v100);
    *((_QWORD *)v111 + v26) = v101;
    if (!v101)
      goto LABEL_506;
    ++v26;
  }
LABEL_302:
  v67 = *MEMORY[0x1E0CA8DC8];
  if (CFDictionaryContainsKey(v4, (const void *)*MEMORY[0x1E0CA8DC8]))
    goto LABEL_303;
  v70 = 0;
  LOBYTE(colorPrimariesCodePoint[1]) = 0;
  if (a2 > 1752589104)
  {
    if (a2 > 1902405680)
    {
      if (a2 <= 1902667125)
      {
        if (a2 == 1902405681 || a2 == 1902405733)
          goto LABEL_496;
        v71 = 1902407032;
      }
      else
      {
        if (a2 > 1902998903)
        {
          if (a2 == 1902998904)
            goto LABEL_496;
          v73 = 2053207651;
          goto LABEL_499;
        }
        if (a2 == 1902667126)
          goto LABEL_496;
        v71 = 1902671459;
      }
    }
    else
    {
      if (a2 > 1902212656)
      {
        if (a2 > 1902212708)
        {
          if (a2 == 1902212709)
            goto LABEL_500;
          v102 = 1902403958;
LABEL_491:
          if (a2 == v102)
            goto LABEL_502;
          goto LABEL_516;
        }
        if (a2 == 1902212657)
          goto LABEL_502;
        v73 = 1902212707;
        goto LABEL_499;
      }
      if (a2 == 1752589105 || a2 == 1836415073)
        goto LABEL_496;
      v71 = 1869117027;
    }
LABEL_495:
    if (a2 == v71)
      goto LABEL_496;
LABEL_516:
    snprintf(__str, 0x100uLL, "Image description - unsupported format '%c%c%c%c'", HIBYTE(a2), BYTE2(a2), BYTE1(a2), a2);
    FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
    figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
    goto LABEL_503;
  }
  if (a2 > 1684895095)
  {
    if (a2 <= 1685481572)
    {
      if (a2 == 1684895096)
        goto LABEL_496;
      if (a2 == 1685220713)
        goto LABEL_500;
      v71 = 1685481521;
    }
    else
    {
      if (a2 <= 1718908519)
      {
        if (a2 == 1685481573)
          goto LABEL_496;
        v73 = 1700886115;
LABEL_499:
        if (a2 != v73)
          goto LABEL_516;
        goto LABEL_500;
      }
      if (a2 == 1718908520)
        goto LABEL_496;
      v71 = 1751479857;
    }
    goto LABEL_495;
  }
  if (a2 <= 1667331682)
  {
    if (a2 == 1635135537)
      goto LABEL_502;
    if (a2 == 1635148593)
      goto LABEL_500;
    v73 = 1635148595;
    goto LABEL_499;
  }
  if (a2 <= 1667790434)
  {
    if (a2 != 1667331683)
    {
      v71 = 1667524657;
      goto LABEL_495;
    }
LABEL_500:
    SPSIsInterlaced = FigH264Bridge_GetSPSIsInterlaced(v109, v108, (BOOL *)&colorPrimariesCodePoint[1]);
    goto LABEL_501;
  }
  if (a2 != 1667790435)
  {
    v102 = 1684108849;
    goto LABEL_491;
  }
LABEL_496:
  SPSIsInterlaced = FigHEVCBridge_GetSPSIsInterlaced((uint64_t)v109, v108, (char *)&colorPrimariesCodePoint[1]);
LABEL_501:
  v70 = SPSIsInterlaced;
LABEL_502:
  if (v70)
    goto LABEL_303;
LABEL_503:
  if (LOBYTE(colorPrimariesCodePoint[1]))
    goto LABEL_303;
  *(_DWORD *)__str = 1;
  v112[v26] = v67;
  v104 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, __str);
  *((_QWORD *)v111 + v26) = v104;
  if (!v104)
  {
LABEL_506:
    v91 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    if (!v26)
      return v91;
    goto LABEL_507;
  }
  ++v26;
LABEL_303:
  if (CFDictionaryContainsKey(v4, CFSTR("MasteringDisplayColorVolume")))
    goto LABEL_358;
  *(_QWORD *)__str = 0;
  IsHEVCFlavor = FigVideoCodecTypeIsHEVCFlavor(a2);
  if (!IsHEVCFlavor)
  {
    if (a2 > 1902212656)
    {
      if (a2 == 1902403958)
        goto LABEL_350;
      v74 = 1902212657;
    }
    else
    {
      if (a2 == 1635135537)
        goto LABEL_350;
      v74 = 1684108849;
    }
    if (a2 != v74)
      goto LABEL_351;
LABEL_350:
    IsHEVCFlavor = FigAV1Bridge_CopyMDCVDataFromAV1ConfigurationRecordConfigOBU(ValueAtIndex, (CFDataRef *)__str);
    goto LABEL_351;
  }
  IsHEVCFlavor = FigHEVCBridge_CopyHEVCSEIPayloadData(ValueAtIndex, 137, (CFTypeRef *)__str);
LABEL_351:
  v75 = *(const void **)__str;
  if (!IsHEVCFlavor && *(_QWORD *)__str)
  {
    if (CFDataGetLength(*(CFDataRef *)__str) == 24)
    {
      v112[v26] = CFSTR("MasteringDisplayColorVolume");
      *((_QWORD *)v111 + v26++) = *(_QWORD *)__str;
      goto LABEL_358;
    }
    v75 = *(const void **)__str;
  }
  if (v75)
    CFRelease(v75);
LABEL_358:
  if (CFDictionaryContainsKey(v4, CFSTR("ContentLightLevelInfo")))
    goto LABEL_375;
  *(_QWORD *)__str = 0;
  v76 = FigVideoCodecTypeIsHEVCFlavor(a2);
  if (v76)
  {
    v76 = FigHEVCBridge_CopyHEVCSEIPayloadData(ValueAtIndex, 144, (CFTypeRef *)__str);
    goto LABEL_368;
  }
  if (a2 > 1902212656)
  {
    if (a2 != 1902403958)
    {
      v77 = 1902212657;
LABEL_366:
      if (a2 != v77)
        goto LABEL_368;
    }
  }
  else if (a2 != 1635135537)
  {
    v77 = 1684108849;
    goto LABEL_366;
  }
  v76 = FigAV1Bridge_CopyCLLIDataFromAV1ConfigurationRecordConfigOBU(ValueAtIndex, (CFDataRef *)__str);
LABEL_368:
  v78 = *(const void **)__str;
  if (!v76 && *(_QWORD *)__str)
  {
    if (CFDataGetLength(*(CFDataRef *)__str) == 4)
    {
      v112[v26] = CFSTR("ContentLightLevelInfo");
      *((_QWORD *)v111 + v26++) = *(_QWORD *)__str;
      goto LABEL_375;
    }
    v78 = *(const void **)__str;
  }
  if (v78)
    CFRelease(v78);
LABEL_375:
  if (!CFDictionaryContainsKey(v4, CFSTR("AmbientViewingEnvironment"))
    && FigVideoCodecTypeIsHEVCFlavor(a2))
  {
    *(_QWORD *)__str = 0;
    v81 = FigHEVCBridge_CopyHEVCSEIPayloadData(ValueAtIndex, 148, (CFTypeRef *)__str);
    v82 = *(const void **)__str;
    if (!v81 && *(_QWORD *)__str)
    {
      if (CFDataGetLength(*(CFDataRef *)__str) == 8)
      {
        v112[v26] = CFSTR("AmbientViewingEnvironment");
        *((_QWORD *)v111 + v26++) = *(_QWORD *)__str;
        goto LABEL_376;
      }
      v82 = *(const void **)__str;
    }
    if (v82)
      CFRelease(v82);
  }
LABEL_376:
  if (!CFDictionaryContainsKey(v4, CFSTR("ContentColorVolume")) && FigVideoCodecTypeIsHEVCFlavor(a2))
  {
    *(_QWORD *)__str = 0;
    v83 = FigHEVCBridge_CopyHEVCSEIPayloadData(ValueAtIndex, 149, (CFTypeRef *)__str);
    v84 = *(_QWORD *)__str;
    if (v83 || !*(_QWORD *)__str)
    {
      if (*(_QWORD *)__str)
        CFRelease(*(CFTypeRef *)__str);
    }
    else
    {
      v112[v26] = CFSTR("ContentColorVolume");
      *((_QWORD *)v111 + v26++) = v84;
    }
  }
  if (!CFDictionaryContainsKey(v4, CFSTR("AlternativeTransferCharacteristics")))
  {
    if (FigVideoCodecTypeIsHEVCFlavor(a2))
    {
      __str[0] = 0;
      if (!FigHEVCBridge_GetATCSEI(ValueAtIndex, (UInt8 *)__str))
      {
        v112[v26] = CFSTR("AlternativeTransferCharacteristics");
        v85 = CVTransferFunctionGetStringForIntegerCodePoint(__str[0]);
        if (v85)
          v85 = CFRetain(v85);
        *((_QWORD *)v111 + v26++) = v85;
      }
    }
  }
  if (!CFDictionaryContainsKey(v4, CFSTR("AlphaChannelMode")))
  {
    if (FigVideoCodecTypeIsHEVCFlavor(a2))
    {
      *(_QWORD *)__str = 0;
      if (!FigHEVCBridge_CopyHEVCSEIPayloadData(ValueAtIndex, 165, (CFTypeRef *)__str))
      {
        if (*(_QWORD *)__str)
        {
          LOBYTE(colorPrimariesCodePoint[1]) = 0;
          v86 = CFDataGetBytePtr(*(CFDataRef *)__str);
          v87 = CFDataGetLength(*(CFDataRef *)__str);
          if (!FigHEVCBridge_GetSEIAlphaChannelInfo((uint64_t)v86, v87, &colorPrimariesCodePoint[1]))
          {
            if (LOBYTE(colorPrimariesCodePoint[1]))
              v88 = &kCMFormatDescriptionAlphaChannelMode_PremultipliedAlpha;
            else
              v88 = &kCMFormatDescriptionAlphaChannelMode_StraightAlpha;
            *((CFStringRef *)v111 + v26) = *v88;
            v112[v26++] = CFSTR("AlphaChannelMode");
          }
          if (*(_QWORD *)__str)
            CFRelease(*(CFTypeRef *)__str);
        }
      }
    }
  }
  if (CFDictionaryContainsKey(v4, CFSTR("ContainsAlphaChannel")))
  {
    v79 = (const void *)*MEMORY[0x1E0C9AE50];
    v80 = v79 == CFDictionaryGetValue(v4, CFSTR("ContainsAlphaChannel"));
  }
  else if (FigVideoCodecTypeIsHEVCFlavor(a2) && figBridge_AlphaLayerIsPresent(v4))
  {
    *((_QWORD *)v111 + v26) = *MEMORY[0x1E0C9AE50];
    v112[v26++] = CFSTR("ContainsAlphaChannel");
    v80 = 1;
  }
  else
  {
    v80 = 0;
  }
  if (a2 <= 1836415072)
  {
    if (a2 > 1751479856)
    {
      if (a2 == 1751479857)
        goto LABEL_422;
      v89 = 1752589105;
    }
    else
    {
      if (a2 == 1667790435)
        goto LABEL_422;
      v89 = 1718908520;
    }
LABEL_421:
    if (a2 != v89)
      goto LABEL_434;
    goto LABEL_422;
  }
  if (a2 <= 1902667125)
  {
    if (a2 == 1836415073)
      goto LABEL_422;
    v89 = 1869117027;
    goto LABEL_421;
  }
  if (a2 != 1902667126 && a2 != 1902998904)
  {
    v89 = 1902671459;
    goto LABEL_421;
  }
LABEL_422:
  if (v80)
  {
    colorPrimariesCodePoint[1] = 0;
    if (!FigHEVCBridge_CheckVPSPrimaryAlphaLayerCompatibility(ValueAtIndex, &colorPrimariesCodePoint[1]))
    {
      if (colorPrimariesCodePoint[1] == 2)
      {
        strcpy(__str, "Image description - PrimaryAlphaLayerCompatibility. Apple decoders will not be able to decode this HEVC with Alpha stream. To fix this in the encoder, for the primary alpha layer, NumDirectRefLayers must be 0 and poc_lsb_not_present_flag must be 1");
        v90 = 4294954579;
        goto LABEL_433;
      }
      if (colorPrimariesCodePoint[1] == 1)
      {
        strcpy(__str, "Image description - PrimaryAlphaLayerCompatibility. Apple decoders can still decode this HEVC with Alpha stream, but the stream is not compliant with the standard (ISO/IEC 23008-2) and may have compatibility issues with other decoders");
        v90 = 4294954580;
LABEL_433:
        FigSignalErrorAt(v90, 0, 0, 0, 0, 0, 0);
        figSoundBridge_ReportParsingFailureMessage(a3, (uint64_t)__str);
      }
    }
  }
LABEL_434:
  if (!CFDictionaryContainsKey(v4, CFSTR("BitsPerComponent")))
  {
    __str[0] = 0;
    if (!figBridge_getSPS_VUI_ComponentBitDepth(a2, (char *)v109, v108, __str))
    {
      *((_QWORD *)v111 + v26) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt8Type, __str);
      v112[v26++] = CFSTR("BitsPerComponent");
    }
  }
  if (!v26)
    return 0;
  v91 = FigCFCreateExtendedDictionary(a1, v4, v112, v111, v26, &v110);
  if (!(_DWORD)v91 && v110)
  {
    *a4 = v110;
    CFRelease(v4);
  }
LABEL_507:
  v105 = (CFTypeRef *)v111;
  do
  {
    if (*v105)
      CFRelease(*v105);
    ++v105;
    --v26;
  }
  while (v26);
  return v91;
}

void figBridge_OverrideTransferFunctionFromAlternativeTransferCharacteristics(const __CFAllocator *a1, const void *a2, CFDictionaryRef *a3)
{
  const void *v6;
  const void *Value;
  __CFDictionary *MutableCopy;

  if (a3)
  {
    v6 = (const void *)*MEMORY[0x1E0CA8E98];
    Value = CFDictionaryGetValue(*a3, (const void *)*MEMORY[0x1E0CA8E98]);
    if (!Value || !FigCFEqual(Value, a2))
    {
      MutableCopy = FigCFDictionaryCreateMutableCopy(a1, *a3);
      CFDictionarySetValue(MutableCopy, v6, a2);
      if (*a3)
        CFRelease(*a3);
      *a3 = MutableCopy;
    }
  }
  else
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t FigVideoCodecTypeIsProRes(int a1)
{
  uint64_t result;
  unsigned __int16 v3;

  result = 1;
  if (a1 <= 1634743415)
  {
    if (a1 != 1634742376 && a1 != 1634742888)
    {
      v3 = 13416;
LABEL_9:
      if (a1 != (v3 | 0x61700000))
        return 0;
    }
  }
  else if (((a1 - 1634755432) > 0xB || ((1 << (a1 - 104)) & 0x8C1) == 0)
         && ((a1 - 1634759272) > 6 || ((1 << (a1 - 104)) & 0x51) == 0))
  {
    v3 = 13432;
    goto LABEL_9;
  }
  return result;
}

void figBridge_GetBitsPerComponentForProRes(const __CFAllocator *a1, int a2, uint64_t *a3)
{
  CFMutableDictionaryRef MutableCopy;
  __int16 v7;
  int v8;

  v8 = 0;
  if (!a3)
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    return;
  }
  FigCFDictionaryGetIntIfPresent(*a3, CFSTR("BitsPerComponent"), &v8);
  if (v8)
    return;
  MutableCopy = FigCFDictionaryCreateMutableCopy(a1, (CFDictionaryRef)*a3);
  v7 = 0;
  v8 = 12;
  FigCFDictionaryGetInt16IfPresent(*a3, CFSTR("Depth"), &v7);
  if (a2 <= 1634759271)
  {
    if (a2 != 1634743400 && a2 != 1634743416 || v7 != 32)
      goto LABEL_12;
    goto LABEL_11;
  }
  if (a2 == 1634759272 || a2 == 1634759278)
LABEL_11:
    v8 = 16;
LABEL_12:
  FigCFDictionarySetInt32(MutableCopy, CFSTR("BitsPerComponent"), v8);
  if (*a3)
    CFRelease((CFTypeRef)*a3);
  *a3 = (uint64_t)MutableCopy;
}

void figBridge_GetAlphaChannelExtensionForProRes(const __CFAllocator *a1, uint64_t *a2)
{
  int v4;
  int v5;
  int v7;
  __CFDictionary *MutableCopy;
  __CFDictionary *v9;
  __int16 v10;

  v10 = 0;
  if (a2 && *a2)
  {
    FigCFDictionaryGetInt16IfPresent(*a2, CFSTR("Depth"), &v10);
    if (v10 == 32)
    {
      v4 = CFDictionaryContainsKey((CFDictionaryRef)*a2, CFSTR("ContainsAlphaChannel"));
      v5 = CFDictionaryContainsKey((CFDictionaryRef)*a2, CFSTR("AlphaChannelMode"));
      if (!v4 || v5 == 0)
      {
        v7 = v5;
        MutableCopy = FigCFDictionaryCreateMutableCopy(a1, (CFDictionaryRef)*a2);
        if (MutableCopy)
        {
          v9 = MutableCopy;
          if (!v4)
            CFDictionarySetValue(MutableCopy, CFSTR("ContainsAlphaChannel"), (const void *)*MEMORY[0x1E0C9AE50]);
          if (!v7)
            CFDictionarySetValue(v9, CFSTR("AlphaChannelMode"), CFSTR("StraightAlpha"));
          if (*a2)
            CFRelease((CFTypeRef)*a2);
          *a2 = (uint64_t)v9;
        }
      }
    }
  }
  else
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
}

const __CFDictionary *figBridge_Is3GP263ExtensionPresent(const __CFDictionary *a1)
{
  const __CFDictionary *result;
  const __CFDictionary *v2;
  CFTypeID TypeID;
  const void *Value;
  const void *v5;
  CFTypeID v6;

  result = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("SampleDescriptionExtensionAtoms"));
  if (result)
  {
    v2 = result;
    TypeID = CFDictionaryGetTypeID();
    result = 0;
    if (TypeID == CFGetTypeID(v2))
    {
      Value = CFDictionaryGetValue(v2, CFSTR("d263"));
      if (Value)
      {
        v5 = Value;
        v6 = CFDataGetTypeID();
        if (v6 == CFGetTypeID(v5))
          return (const __CFDictionary *)1;
      }
    }
  }
  return result;
}

OSStatus CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionData(CFAllocatorRef allocator, const uint8_t *imageDescriptionData, size_t size, CFStringEncoding stringEncoding, CMImageDescriptionFlavor flavor, CMVideoFormatDescriptionRef *formatDescriptionOut)
{
  return FigVideoFormatDescriptionCreateFromBigEndianImageDescriptionDataWithReporter(allocator, (__int128 *)imageDescriptionData, size, stringEncoding, flavor, formatDescriptionOut, 0);
}

uint64_t FigBridge_GetPlaintextMediaSubTypeAndEncryptionSchemeFromProtectedCodecType(int a1, int *a2, int *a3)
{
  uint64_t v3;
  int *v4;
  uint64_t result;
  int v6;

  v3 = 0;
  while (1)
  {
    v4 = &lookUpConciseCodecType[v3];
    if (lookUpConciseCodecType[v3 + 2] == a1)
      break;
    v3 += 3;
    if (v3 == 63)
      return 4294954578;
  }
  if (!*v4)
    return 4294954578;
  v6 = v4[1];
  if (a2)
    *a2 = *v4;
  result = 0;
  if (a3)
    *a3 = v6;
  return result;
}

uint64_t figConvertChromaLocationIndexToString(int a1)
{
  uint64_t v1;

  switch(a1)
  {
    case 0:
      v1 = MEMORY[0x1E0CA8D10];
      return *(_QWORD *)v1;
    case 1:
      v1 = MEMORY[0x1E0CA8D00];
      return *(_QWORD *)v1;
    case 2:
      v1 = MEMORY[0x1E0CA8D20];
      return *(_QWORD *)v1;
    case 3:
      v1 = MEMORY[0x1E0CA8D18];
      return *(_QWORD *)v1;
    case 4:
      v1 = MEMORY[0x1E0CA8CF8];
      return *(_QWORD *)v1;
    case 5:
      v1 = MEMORY[0x1E0CA8CF0];
      return *(_QWORD *)v1;
    default:
      if (a1 == 255)
      {
        v1 = MEMORY[0x1E0CA8D08];
        return *(_QWORD *)v1;
      }
      else
      {
        FigSignalErrorAt(0, 0, 0, 0, 0, 0, 0);
        return 0;
      }
  }
}

CFDictionaryRef figBridge_CFDictionaryCreateWithNumbers(const __CFAllocator *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v10;
  int v11;
  const __CFAllocator *v12;
  void **v13;
  CFNumberRef v14;
  void **v15;
  CFDictionaryRef v16;
  unint64_t v17;
  int valuePtr;
  void **v20;
  void *values[2];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  void *keys[2];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  *(_OWORD *)keys = 0u;
  v23 = 0u;
  v24 = 0u;
  *(_OWORD *)values = 0u;
  v22 = 0u;
  v20 = (void **)&a9;
  if (a3)
  {
    v10 = a3;
    v11 = 0;
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    while (v11 < 10)
    {
      v13 = v20++;
      valuePtr = *(_DWORD *)v13;
      v14 = CFNumberCreate(v12, kCFNumberSInt32Type, &valuePtr);
      values[v11] = v14;
      if (v14)
        keys[v11++] = v10;
      v15 = v20++;
      v10 = *v15;
      if (!*v15)
        goto LABEL_10;
    }
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    v11 = 0;
  }
LABEL_10:
  v16 = CFDictionaryCreate(a1, (const void **)keys, (const void **)values, v11, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v11 >= 1)
  {
    v17 = v11 + 1;
    do
      CFRelease(values[(v17-- - 2)]);
    while (v17 > 1);
  }
  return v16;
}

uint64_t figBridge_AlphaLayerIsPresent(const __CFDictionary *a1)
{
  const void *Value;
  const void *v2;
  CFTypeID TypeID;
  const __CFArray *v4;
  const __CFArray *ValueAtIndex;
  CFTypeID v6;
  CFTypeID v7;
  int VPSAlphaChannelNuhLayerId;
  unsigned __int8 v9;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned __int8 v14;

  v14 = 0;
  v11 = 0;
  v12 = 0;
  Value = CFDictionaryGetValue(a1, CFSTR("SampleDescriptionExtensionAtoms"));
  if (!Value)
    return 0;
  v2 = Value;
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v2))
    return 0;
  v4 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v2, CFSTR("hvcC"));
  if (!v4)
    return 0;
  ValueAtIndex = v4;
  v6 = CFArrayGetTypeID();
  if (v6 == CFGetTypeID(ValueAtIndex))
  {
    ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
    if (!ValueAtIndex)
      return 0;
  }
  v7 = CFDataGetTypeID();
  if (v7 == CFGetTypeID(ValueAtIndex)
    && (v13 = 0,
        !FigHEVCBridge_GetHEVCParameterSetAtIndex(ValueAtIndex, 32, 0, (unint64_t)&v12, (unint64_t)&v11, 0, 0)))
  {
    VPSAlphaChannelNuhLayerId = FigHEVCBridge_GetVPSAlphaChannelNuhLayerId(v12, v11, &v14, &v13);
    v9 = v14;
    if (VPSAlphaChannelNuhLayerId)
      return 0;
  }
  else
  {
    return 0;
  }
  return v9;
}

uint64_t figBridge_getSPS_VUI_ComponentBitDepth(int a1, char *a2, unint64_t a3, _BYTE *a4)
{
  uint64_t result;
  int v7;
  unsigned __int16 v8;
  char v9;
  __int16 v10;

  v10 = 0;
  result = 4294954579;
  if (a1 > 1836415072)
  {
    if (a1 > 1902405732)
    {
      if (a1 > 1902667125)
      {
        if (a1 == 1902667126 || a1 == 1902998904)
          goto LABEL_31;
        v7 = 1902671459;
        goto LABEL_30;
      }
      if (a1 == 1902405733)
        goto LABEL_31;
      v8 = 28024;
    }
    else
    {
      if (a1 <= 1902212656)
      {
        if (a1 == 1836415073)
          goto LABEL_31;
        v7 = 1869117027;
LABEL_30:
        if (a1 != v7)
          return result;
        goto LABEL_31;
      }
      if (a1 == 1902212657 || a1 == 1902403958)
        goto LABEL_22;
      v8 = 26673;
    }
    v7 = v8 | 0x71640000;
    goto LABEL_30;
  }
  if (a1 > 1685481520)
  {
    if (a1 <= 1718908519)
    {
      if (a1 == 1685481521)
        goto LABEL_31;
      v7 = 1685481573;
    }
    else
    {
      if (a1 == 1718908520 || a1 == 1751479857)
        goto LABEL_31;
      v7 = 1752589105;
    }
    goto LABEL_30;
  }
  if (a1 <= 1667790434)
  {
    if (a1 == 1635135537)
      goto LABEL_22;
    v7 = 1667524657;
    goto LABEL_30;
  }
  if (a1 != 1667790435)
  {
    if (a1 != 1684108849)
    {
      v7 = 1684895096;
      goto LABEL_30;
    }
LABEL_22:
    result = FigAV1Bridge_GetChromaFormatAndBitDepthsFromAV1CodecConfigurationRecord(a2, a3, 0, 0, &v10);
    v9 = v10;
    goto LABEL_34;
  }
LABEL_31:
  result = FigHEVCBridge_GetSPSBitDepths((uint64_t)a2, a3, (_BYTE *)&v10 + 1, &v10);
  if ((_DWORD)result)
    return result;
  v9 = HIBYTE(v10);
  if (HIBYTE(v10) <= v10)
    v9 = v10;
LABEL_34:
  *a4 = v9;
  return result;
}

OSStatus CMVideoFormatDescriptionCopyTagCollectionArray(CMVideoFormatDescriptionRef formatDescription, CFArrayRef *tagCollectionsOut)
{
  signed int MediaSubType;
  signed int v5;
  OSStatus v6;
  int v7;
  const __CFDictionary *v8;
  unsigned __int16 v9;
  const __CFDictionary *Extensions;
  const void *StringValue;
  const __CFDictionary *Value;
  const __CFArray *v13;
  const __CFArray *ValueAtIndex;
  CFTypeID v15;
  CFTypeID v16;
  OSStatus HEVCParameterSetAtIndex;
  uint64_t v18;
  uint64_t v19;
  const UInt8 *BytePtr;
  CFIndex Length;
  __int16 v23;
  unsigned __int8 v24;
  unsigned __int8 v25;
  uint64_t v26;
  uint64_t v27;
  CFDataRef theData;

  v27 = 0;
  theData = 0;
  v26 = 0;
  v25 = -1;
  v24 = -1;
  MediaSubType = CMFormatDescriptionGetMediaSubType(formatDescription);
  v5 = MediaSubType;
  v6 = -12710;
  if (MediaSubType <= 1768972831)
  {
    if (MediaSubType > 1685481572)
    {
      if (MediaSubType > 1751479856)
      {
        if (MediaSubType == 1751479857)
          goto LABEL_29;
        v7 = 1752589105;
      }
      else
      {
        if (MediaSubType == 1685481573)
          goto LABEL_29;
        v7 = 1718908520;
      }
    }
    else
    {
      if (MediaSubType <= 1684895095)
      {
        if (MediaSubType != 1667524657)
        {
          v7 = 1667790435;
          goto LABEL_28;
        }
LABEL_29:
        Extensions = CMFormatDescriptionGetExtensions(formatDescription);
        if (!Extensions)
          goto LABEL_47;
        v8 = Extensions;
        if (v5 == 1768972832)
          goto LABEL_31;
        Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("SampleDescriptionExtensionAtoms"));
        if (Value)
        {
          v13 = (const __CFArray *)CFDictionaryGetValue(Value, CFSTR("hvcC"));
          if (v13)
          {
            ValueAtIndex = v13;
            v15 = CFGetTypeID(v13);
            if (v15 == CFArrayGetTypeID()
              && (ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0)) == 0
              || (v16 = CFGetTypeID(ValueAtIndex), v16 != CFDataGetTypeID()))
            {
LABEL_50:
              HEVCParameterSetAtIndex = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
LABEL_51:
              v6 = HEVCParameterSetAtIndex;
              goto LABEL_47;
            }
            HEVCParameterSetAtIndex = FigHEVCBridge_CopyHEVCSEIPayloadData(ValueAtIndex, 176, (CFTypeRef *)&theData);
            if (HEVCParameterSetAtIndex)
              goto LABEL_51;
            if (!theData)
              return -12710;
            HEVCParameterSetAtIndex = FigHEVCBridge_GetHEVCParameterSetAtIndex(ValueAtIndex, 32, 0, (unint64_t)&v27, (unint64_t)&v26, 0, 0);
            if (HEVCParameterSetAtIndex)
              goto LABEL_51;
            v19 = v26;
            v18 = v27;
            BytePtr = CFDataGetBytePtr(theData);
            Length = CFDataGetLength(theData);
            FigHEVCBridge_Get3DLayerIDs(v18, v19, (uint64_t)BytePtr, Length, (char *)&v25, (char *)&v24);
            if (HEVCParameterSetAtIndex)
              goto LABEL_51;
LABEL_44:
            if (v25 != 255 && v24 != 255)
            {
              v6 = 0;
              *tagCollectionsOut = figBridge_createFigTagCollectionArrayForLeftEyeVideoLayerIDsAndRightEyeVideoLayerIDs(&v25, &v24, 1);
              goto LABEL_47;
            }
            goto LABEL_50;
          }
        }
        goto LABEL_52;
      }
      if (MediaSubType == 1684895096)
        goto LABEL_29;
      v7 = 1685481521;
    }
LABEL_28:
    if (MediaSubType != v7)
      goto LABEL_47;
    goto LABEL_29;
  }
  if (MediaSubType > 1902407031)
  {
    if (MediaSubType > 1902671458)
    {
      if (MediaSubType == 1902998904)
        goto LABEL_29;
      v9 = 30307;
    }
    else
    {
      if (MediaSubType == 1902407032)
        goto LABEL_29;
      v9 = 25974;
    }
    v7 = v9 | 0x71680000;
    goto LABEL_28;
  }
  if (MediaSubType > 1902405680)
  {
    if (MediaSubType == 1902405681)
      goto LABEL_29;
    v7 = 1902405733;
    goto LABEL_28;
  }
  if (MediaSubType == 1836415073 || MediaSubType == 1869117027)
    goto LABEL_29;
  if (MediaSubType != 1768972832)
    goto LABEL_47;
  v8 = CMFormatDescriptionGetExtensions(formatDescription);
  if (v8)
  {
LABEL_31:
    v23 = 0;
    FigCFDictionaryGetBooleanIfPresent((uint64_t)v8, CFSTR("HasLeftStereoEyeView"), (Boolean *)&v23 + 1);
    FigCFDictionaryGetBooleanIfPresent((uint64_t)v8, CFSTR("HasRightStereoEyeView"), (Boolean *)&v23);
    StringValue = FigCFDictionaryGetStringValue(v8, CFSTR("ViewPackingKind"));
    if (HIBYTE(v23) && (_BYTE)v23 && !StringValue)
    {
      v25 = 0;
      v24 = 1;
    }
    goto LABEL_44;
  }
LABEL_52:
  v6 = -12710;
LABEL_47:
  if (theData)
    CFRelease(theData);
  return v6;
}

__CFArray *figBridge_createFigTagCollectionArrayForLeftEyeVideoLayerIDsAndRightEyeVideoLayerIDs(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  __CFArray *Mutable;
  unsigned __int8 *v4;
  uint64_t v5;
  unsigned __int8 *v6;
  const __CFAllocator *v7;
  unsigned int v8;
  unsigned int v9;
  CMTagCollectionRef newCollectionOut;
  _OWORD v12[2];
  CMTag tags;
  CMTag v14;
  uint64_t v15;

  Mutable = 0;
  v15 = *MEMORY[0x1E0C80C00];
  newCollectionOut = 0;
  if (a1)
  {
    v4 = a2;
    if (a2)
    {
      v5 = a3;
      if (a3 >= 1)
      {
        v6 = a1;
        v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
        if (Mutable)
        {
          while (1)
          {
            tags = kCMTagStereoLeftEye;
            v8 = *v6++;
            v14 = CMTagMakeWithSInt64Value(kCMTagCategory_VideoLayerID, v8);
            v12[0] = kCMTagStereoRightEye;
            v9 = *v4++;
            v12[1] = CMTagMakeWithSInt64Value(kCMTagCategory_VideoLayerID, v9);
            if (CMTagCollectionCreate(v7, &tags, 2, &newCollectionOut))
              break;
            CFArrayAppendValue(Mutable, newCollectionOut);
            if (newCollectionOut)
            {
              CFRelease(newCollectionOut);
              newCollectionOut = 0;
            }
            if (FigTagCollectionCreate((uint64_t)v7, (uint64_t)v12, 2, (uint64_t *)&newCollectionOut))
              break;
            CFArrayAppendValue(Mutable, newCollectionOut);
            if (newCollectionOut)
            {
              CFRelease(newCollectionOut);
              newCollectionOut = 0;
            }
            if (!--v5)
              return Mutable;
          }
          if (newCollectionOut)
            CFRelease(newCollectionOut);
        }
      }
    }
  }
  return Mutable;
}

uint64_t FigVideoFormatDescriptionCopyFigTagCollectionArrayWithExtraChannels(const opaqueCMFormatDescription *a1, __CFArray **a2)
{
  signed int MediaSubType;
  uint64_t v5;
  int v6;
  unsigned __int16 v7;
  const __CFDictionary *Extensions;
  const __CFDictionary *Value;
  const void *v10;
  const void *ValueAtIndex;
  CFTypeID v12;
  CFTypeID v13;
  uint64_t HEVCParameterSetAtIndex;
  uint64_t v15;
  uint64_t v16;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v25;
  uint64_t v26;
  CFDataRef theData;
  _OWORD v28[4];
  _OWORD v29[4];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v26 = 0;
  theData = 0;
  v25 = 0;
  memset(v29, 0, sizeof(v29));
  memset(v28, 0, sizeof(v28));
  MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  v5 = 4294954586;
  if (MediaSubType > 1836415072)
  {
    if (MediaSubType > 1902407031)
    {
      if (MediaSubType > 1902671458)
      {
        if (MediaSubType == 1902998904)
          goto LABEL_26;
        v7 = 30307;
      }
      else
      {
        if (MediaSubType == 1902407032)
          goto LABEL_26;
        v7 = 25974;
      }
      v6 = v7 | 0x71680000;
    }
    else if (MediaSubType > 1902405680)
    {
      if (MediaSubType == 1902405681)
        goto LABEL_26;
      v6 = 1902405733;
    }
    else
    {
      if (MediaSubType == 1836415073)
        goto LABEL_26;
      v6 = 1869117027;
    }
  }
  else if (MediaSubType > 1685481572)
  {
    if (MediaSubType > 1751479856)
    {
      if (MediaSubType == 1751479857)
        goto LABEL_26;
      v6 = 1752589105;
    }
    else
    {
      if (MediaSubType == 1685481573)
        goto LABEL_26;
      v6 = 1718908520;
    }
  }
  else if (MediaSubType > 1684895095)
  {
    if (MediaSubType == 1684895096)
      goto LABEL_26;
    v6 = 1685481521;
  }
  else
  {
    if (MediaSubType == 1667524657)
      goto LABEL_26;
    v6 = 1667790435;
  }
  if (MediaSubType != v6)
    goto LABEL_48;
LABEL_26:
  Extensions = CMFormatDescriptionGetExtensions(a1);
  if (Extensions)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("SampleDescriptionExtensionAtoms"));
    if (Value)
    {
      v10 = CFDictionaryGetValue(Value, CFSTR("hvcC"));
      if (v10)
      {
        ValueAtIndex = v10;
        v12 = CFGetTypeID(v10);
        if (v12 != CFArrayGetTypeID() || (ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0)) != 0)
        {
          v13 = CFGetTypeID(ValueAtIndex);
          if (v13 == CFDataGetTypeID())
          {
            HEVCParameterSetAtIndex = FigHEVCBridge_CopyHEVCSEIPayloadData(ValueAtIndex, 176, (CFTypeRef *)&theData);
            if ((_DWORD)HEVCParameterSetAtIndex)
              goto LABEL_52;
            if (!theData)
              return 4294954586;
            HEVCParameterSetAtIndex = FigHEVCBridge_GetHEVCParameterSetAtIndex(ValueAtIndex, 32, 0, (unint64_t)&v26, (unint64_t)&v25, 0, 0);
            if ((_DWORD)HEVCParameterSetAtIndex)
              goto LABEL_52;
            v16 = v25;
            v15 = v26;
            BytePtr = CFDataGetBytePtr(theData);
            Length = CFDataGetLength(theData);
            FigHEVCBridge_Get3DLayerIDSets(v15, v16, (uint64_t)BytePtr, Length, v29, v28);
            if ((_DWORD)HEVCParameterSetAtIndex)
              goto LABEL_52;
            v19 = 0;
            v20 = -1;
            v21 = -1;
            do
            {
              v22 = *((unsigned __int8 *)v29 + v19);
              v23 = *((unsigned __int8 *)v28 + v19);
              if (v22 == 255 && v23 == 255)
                break;
              if (v23 != 255)
                v20 = v19;
              if (v22 != 255)
                v21 = v19;
              ++v19;
            }
            while (v19 != 64);
            if ((v21 & 0x8000000000000000) == 0 && (v20 & 0x8000000000000000) == 0 && v21 == v20)
            {
              v5 = 0;
              *a2 = figBridge_createFigTagCollectionArrayForLeftEyeVideoLayerIDsAndRightEyeVideoLayerIDs((unsigned __int8 *)v29, (unsigned __int8 *)v28, v21 + 1);
              goto LABEL_48;
            }
          }
        }
        HEVCParameterSetAtIndex = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
LABEL_52:
        v5 = HEVCParameterSetAtIndex;
      }
    }
  }
LABEL_48:
  if (theData)
    CFRelease(theData);
  return v5;
}

uint64_t FigVideoFormatDescriptionDetermineCompatibilityWithCoreMediaRequirementsForHEVCWithAlpha(const opaqueCMFormatDescription *a1, _DWORD *a2)
{
  FourCharCode MediaSubType;
  const __CFDictionary *Extensions;
  const __CFDictionary *Value;
  const void *v7;
  const void *v8;
  CFTypeID v9;
  uint64_t result;
  int v11;

  v11 = 0;
  MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  if (MediaSubType != 1752589105 && MediaSubType != 1902671459 || !FigVideoFormatDescriptionContainsAlphaChannel(a1))
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  Extensions = CMFormatDescriptionGetExtensions(a1);
  if (!Extensions)
    return 4294954586;
  Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("SampleDescriptionExtensionAtoms"));
  if (!Value)
    return 4294954586;
  v7 = CFDictionaryGetValue(Value, CFSTR("hvcC"));
  if (!v7)
    return 4294954586;
  v8 = v7;
  v9 = CFGetTypeID(v7);
  if (v9 != CFDataGetTypeID())
    return 4294954586;
  result = FigHEVCBridge_CheckVPSPrimaryAlphaLayerCompatibility(v8, &v11);
  if (!(_DWORD)result)
  {
    if (v11 == 2 || v11 == 1)
    {
      result = 0;
      *a2 = v11;
    }
    else if (v11)
    {
      return 4294954578;
    }
    else
    {
      result = 0;
      *a2 = 0;
    }
  }
  return result;
}

OSStatus CMVideoFormatDescriptionCreateFromBigEndianImageDescriptionBlockBuffer(CFAllocatorRef allocator, CMBlockBufferRef imageDescriptionBlockBuffer, CFStringEncoding stringEncoding, CMImageDescriptionFlavor flavor, CMVideoFormatDescriptionRef *formatDescriptionOut)
{
  return FigVideoFormatDescriptionCreateFromBigEndianImageDescriptionBlockBufferWithReporter(allocator, imageDescriptionBlockBuffer, stringEncoding, flavor, formatDescriptionOut, 0);
}

uint64_t FigVideoFormatDescriptionCreateFromBigEndianImageDescriptionBlockBufferWithReporter(const __CFAllocator *a1, CMBlockBufferRef theBuffer, CFStringEncoding a3, const void *a4, CMVideoFormatDescriptionRef *a5, const void *a6)
{
  size_t DataLength;
  void *v13;
  uint64_t Contiguous;
  CFTypeRef cf;
  char *dataPointerOut;

  cf = 0;
  if (!theBuffer)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  dataPointerOut = 0;
  DataLength = CMBlockBufferGetDataLength(theBuffer);
  if (CMBlockBufferIsRangeContiguous(theBuffer, 0, 0))
  {
    v13 = (void *)CFRetain(theBuffer);
    cf = v13;
  }
  else
  {
    Contiguous = CMBlockBufferCreateContiguous(a1, theBuffer, a1, 0, 0, DataLength, 0, (CMBlockBufferRef *)&cf);
    if ((_DWORD)Contiguous)
      goto LABEL_7;
    v13 = (void *)cf;
  }
  CMBlockBufferGetDataPointer((CMBlockBufferRef)v13, 0, 0, 0, &dataPointerOut);
  Contiguous = FigVideoFormatDescriptionCreateFromBigEndianImageDescriptionDataWithReporter(a1, (__int128 *)dataPointerOut, DataLength, a3, a4, a5, a6);
LABEL_7:
  if (cf)
    CFRelease(cf);
  return Contiguous;
}

OSStatus CMVideoFormatDescriptionCopyAsBigEndianImageDescriptionBlockBuffer(CFAllocatorRef allocator, CMVideoFormatDescriptionRef videoFormatDescription, CFStringEncoding stringEncoding, CMImageDescriptionFlavor flavor, CMBlockBufferRef *blockBufferOut)
{
  CFTypeID TypeID;
  int v11;
  uint64_t v12;
  FourCharCode MediaSubType;
  int v15;
  int v16;
  unsigned __int16 v17;
  int v18;
  int v19;
  int v20;
  CFStringRef *v21;
  const __CFData *Extension;
  const __CFData *v23;
  CFTypeID v24;
  size_t Length;
  const UInt8 *BytePtr;
  OSStatus DataPointer;
  const __CFArray *v28;
  const __CFArray *v29;
  CFTypeID v30;
  unsigned int v31;
  CMVideoDimensions Dimensions;
  const __CFNumber *v33;
  const __CFNumber *v34;
  CFTypeID v35;
  unsigned int v36;
  OSStatus v37;
  char *v38;
  unsigned int v39;
  char *v40;
  const __CFString *v41;
  const __CFString *v42;
  CFTypeID v43;
  char *v44;
  unsigned int v45;
  const __CFNumber *v46;
  const __CFNumber *v47;
  CFTypeID v48;
  const __CFNumber *v49;
  const __CFNumber *v50;
  CFTypeID v51;
  const __CFNumber *v52;
  const __CFNumber *v53;
  CFTypeID v54;
  const __CFNumber *v55;
  const __CFNumber *v56;
  CFTypeID v57;
  const __CFString *v58;
  const __CFString *v59;
  CFTypeID v60;
  char *dataPointerOut;
  unsigned int v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  CMBlockBufferRef theBuffer;
  CFRange v67;

  v65 = 0;
  theBuffer = 0;
  v64 = 0;
  if (!videoFormatDescription)
  {
    v12 = 4294954584;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  TypeID = CMFormatDescriptionGetTypeID();
  if (TypeID != CFGetTypeID(videoFormatDescription)
    || CMFormatDescriptionGetMediaType(videoFormatDescription) != 1986618469
    || !blockBufferOut)
  {
    v12 = 4294954584;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  if (flavor)
  {
    if (CFEqual(flavor, CFSTR("ISOFamily")))
    {
      v11 = 0;
      LOBYTE(flavor) = 1;
    }
    else if (CFEqual(flavor, CFSTR("3GPFamily")))
    {
      v11 = 0;
      LOBYTE(flavor) = 3;
    }
    else if (CFEqual(flavor, CFSTR("FMP4InStreamParameterSets")))
    {
      v11 = 0;
      LOBYTE(flavor) = 5;
    }
    else if (CFEqual(flavor, CFSTR("ISOFamilyWithAppleExtensions")))
    {
      LOBYTE(flavor) = 9;
      v11 = 1;
    }
    else
    {
      if (!CFEqual(flavor, CFSTR("QuickTimeMovie")))
        goto LABEL_79;
      v11 = 0;
      LOBYTE(flavor) = 0;
    }
  }
  else
  {
    v11 = 0;
  }
  MediaSubType = CMFormatDescriptionGetMediaSubType(videoFormatDescription);
  if (MediaSubType == 1785750887)
    v15 = v11;
  else
    v15 = 1;
  if ((flavor & 1) == 0)
    v15 = 1;
  if (v15)
    v16 = MediaSubType;
  else
    v16 = 1835692135;
  v62 = v16;
  if (v16 > 1902403957)
  {
    if (v16 <= 1902407031)
    {
      if (v16 != 1902403958 && v16 != 1902405681)
      {
        v18 = 1902405733;
        goto LABEL_46;
      }
    }
    else if (v16 > 1902671458)
    {
      if (v16 != 1902998904)
      {
        v17 = 30307;
        goto LABEL_45;
      }
    }
    else if (v16 != 1902407032)
    {
      v17 = 25974;
LABEL_45:
      v18 = v17 | 0x71680000;
LABEL_46:
      if (v16 != v18)
        goto LABEL_48;
    }
LABEL_47:
    v16 = 1701733238;
    v62 = 1701733238;
    goto LABEL_48;
  }
  if (v16 <= 1902212656)
  {
    if (v16 != 1667331683 && v16 != 1667524657)
    {
      v18 = 1667790435;
      goto LABEL_46;
    }
    goto LABEL_47;
  }
  if ((v16 - 1902212657) <= 0x34 && ((1 << (v16 - 49)) & 0x14000000000001) != 0)
    goto LABEL_47;
LABEL_48:
  if ((flavor & 7) != 1)
    goto LABEL_67;
  if (v16 <= 1701733237)
  {
    if (v16 > 1684890160)
    {
      if (v16 == 1684890161 || v16 == 1685220713)
        goto LABEL_67;
      v19 = 1685481521;
    }
    else
    {
      if (v16 == 1635135537 || v16 == 1635148593)
        goto LABEL_67;
      v19 = 1684108849;
    }
  }
  else if (v16 <= 1785750886)
  {
    if (v16 == 1701733238 || v16 == 1748121139)
      goto LABEL_67;
    v19 = 1752589105;
  }
  else if (v16 > 1836070005)
  {
    if (v16 == 1836070006)
      goto LABEL_67;
    v19 = 1987063865;
  }
  else
  {
    if (v16 == 1785750887)
      goto LABEL_67;
    v19 = 1835692135;
  }
  if (v16 != v19)
    goto LABEL_79;
LABEL_67:
  if ((flavor & 2) != 0)
  {
    if (v16 <= 1748121138)
    {
      if (v16 != 1635148593)
      {
        v20 = 1701733238;
LABEL_74:
        if (v16 == v20)
          goto LABEL_75;
LABEL_79:
        v12 = 4294954579;
        return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
      }
    }
    else if (v16 != 1748121139 && v16 != 1752589105)
    {
      v20 = 1836070006;
      goto LABEL_74;
    }
  }
LABEL_75:
  if ((flavor & 4) != 0 && v16 != 1751479857 && v16 != 1685481573 && v16 != 1635148595)
    goto LABEL_79;
  v21 = (CFStringRef *)&kCMFormatDescriptionExtension_VerbatimSampleDescription;
  if ((flavor & 1) != 0)
    v21 = (CFStringRef *)&kCMFormatDescriptionExtension_VerbatimISOSampleEntry;
  Extension = (const __CFData *)CMFormatDescriptionGetExtension(videoFormatDescription, *v21);
  v63 = 0;
  if (Extension)
  {
    v23 = Extension;
    v24 = CFDataGetTypeID();
    if (v24 == CFGetTypeID(v23))
    {
      Length = CFDataGetLength(v23);
      BytePtr = CFDataGetBytePtr(v23);
      dataPointerOut = 0;
      DataPointer = CMBlockBufferCreateWithMemoryBlock(allocator, 0, Length, allocator, 0, 0, Length, 1u, &theBuffer);
      if (!DataPointer)
      {
        DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
        if (!DataPointer)
        {
          memcpy(dataPointerOut, BytePtr, Length);
          *blockBufferOut = theBuffer;
          theBuffer = 0;
        }
      }
      goto LABEL_100;
    }
  }
  v28 = (const __CFArray *)CMFormatDescriptionGetExtension(videoFormatDescription, CFSTR("RequiredButUnrecognizedFormatAtoms"));
  if (v28)
  {
    v29 = v28;
    v30 = CFGetTypeID(v28);
    if (v30 != CFArrayGetTypeID() || CFArrayGetCount(v29))
    {
      v37 = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
LABEL_99:
      DataPointer = v37;
LABEL_100:
      if (theBuffer)
        CFRelease(theBuffer);
      return DataPointer;
    }
  }
  figBridge_WalkAndConvertVideoFormatDescriptionExtensions(videoFormatDescription, (char)flavor, &v65, 0);
  v31 = v65 + 86;
  DataPointer = CMBlockBufferCreateWithMemoryBlock(allocator, 0, v65 + 86, allocator, 0, 0, v65 + 86, 1u, &theBuffer);
  if (DataPointer)
    goto LABEL_100;
  DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &v63);
  if (DataPointer)
    goto LABEL_100;
  Dimensions = CMVideoFormatDescriptionGetDimensions(videoFormatDescription);
  if ((flavor & 1) != 0)
  {
    v38 = v63;
    if ((flavor & 2) != 0 && v62 == 1748121139)
    {
      DataPointer = figBridge_ConvertH263SampleDescriptionExtensionToCodecType(videoFormatDescription, &v62);
      if (DataPointer)
        goto LABEL_100;
    }
    *(_DWORD *)v38 = bswap32(v31);
    *((_DWORD *)v38 + 1) = bswap32(v62);
    *((_QWORD *)v38 + 2) = 0;
    *((_QWORD *)v38 + 3) = 0;
    *((_QWORD *)v38 + 1) = 0xFFFF000000000000;
    *((_WORD *)v38 + 16) = bswap32(Dimensions.width) >> 16;
    *((_WORD *)v38 + 17) = bswap32(Dimensions.height) >> 16;
    *(_QWORD *)(v38 + 36) = 0x480000004800;
    *((_DWORD *)v38 + 11) = 0;
    *((_WORD *)v38 + 24) = 256;
    *(_DWORD *)(v38 + 82) = -59392;
    *(_OWORD *)(v38 + 50) = 0u;
    *(_OWORD *)(v38 + 66) = 0u;
  }
  else
  {
    v33 = (const __CFNumber *)CMFormatDescriptionGetExtension(videoFormatDescription, CFSTR("Depth"));
    if (v33)
    {
      v34 = v33;
      v35 = CFNumberGetTypeID();
      v36 = 24;
      if (v35 == CFGetTypeID(v34))
      {
        LOWORD(dataPointerOut) = 0;
        if (CFNumberGetValue(v34, kCFNumberSInt16Type, &dataPointerOut))
          v36 = (unsigned __int16)dataPointerOut;
        else
          v36 = 24;
      }
    }
    else
    {
      v36 = 24;
    }
    v39 = v62;
    if (v62 <= 0x28 && ((1 << v62) & 0x11701010116) != 0)
    {
      v62 = 1918990112;
      v36 = v39;
    }
    else if (v62 == 1836069494)
    {
      figBridge_ConvertMPEG2ProfileExtensionToCodecType(videoFormatDescription, &v62);
    }
    v40 = v63;
    *(_DWORD *)v63 = bswap32(v31);
    *((_DWORD *)v40 + 1) = bswap32(v62);
    *((_QWORD *)v40 + 1) = 0xFFFF000000000000;
    *((_QWORD *)v40 + 2) = 0;
    *((_QWORD *)v40 + 3) = 0x2000000020000;
    *((_WORD *)v40 + 16) = bswap32(Dimensions.width) >> 16;
    *((_WORD *)v40 + 17) = bswap32(Dimensions.height) >> 16;
    *(_QWORD *)(v40 + 36) = 0x480000004800;
    *((_DWORD *)v40 + 11) = 0;
    *((_WORD *)v40 + 24) = 256;
    *((_WORD *)v40 + 41) = bswap32(v36) >> 16;
    *((_WORD *)v40 + 42) = -1;
    *(_OWORD *)(v40 + 50) = 0u;
    *(_OWORD *)(v40 + 66) = 0u;
    v41 = (const __CFString *)CMFormatDescriptionGetExtension(videoFormatDescription, CFSTR("FormatName"));
    if (!v41
      || (v42 = v41, v43 = CFStringGetTypeID(), v43 != CFGetTypeID(v42))
      || !CFStringGetPascalString(v42, (StringPtr)v63 + 50, 32, stringEncoding))
    {
      v44 = v63;
      if (*((_DWORD *)v63 + 1) == 1752589105)
      {
        *(_DWORD *)(v63 + 50) = 1447380996;
        v44[54] = 67;
      }
      else
      {
        *((_WORD *)v63 + 25) = 9990;
        v45 = v62;
        v44[52] = HIBYTE(v62);
        v44[53] = BYTE2(v45);
        v44[54] = BYTE1(v45);
        v44[55] = v45;
        v44[56] = 39;
      }
    }
    v46 = (const __CFNumber *)CMFormatDescriptionGetExtension(videoFormatDescription, CFSTR("TemporalQuality"));
    if (v46)
    {
      v47 = v46;
      v48 = CFNumberGetTypeID();
      if (v48 == CFGetTypeID(v47))
      {
        LODWORD(dataPointerOut) = 0;
        CFNumberGetValue(v47, kCFNumberSInt32Type, &dataPointerOut);
        *((_DWORD *)v63 + 6) = bswap32(dataPointerOut);
      }
    }
    v49 = (const __CFNumber *)CMFormatDescriptionGetExtension(videoFormatDescription, CFSTR("SpatialQuality"));
    if (v49)
    {
      v50 = v49;
      v51 = CFNumberGetTypeID();
      if (v51 == CFGetTypeID(v50))
      {
        LODWORD(dataPointerOut) = 0;
        CFNumberGetValue(v50, kCFNumberSInt32Type, &dataPointerOut);
        *((_DWORD *)v63 + 7) = bswap32(dataPointerOut);
      }
    }
    v52 = (const __CFNumber *)CMFormatDescriptionGetExtension(videoFormatDescription, CFSTR("Version"));
    if (v52)
    {
      v53 = v52;
      v54 = CFNumberGetTypeID();
      if (v54 == CFGetTypeID(v53))
      {
        LOWORD(dataPointerOut) = 0;
        CFNumberGetValue(v53, kCFNumberSInt16Type, &dataPointerOut);
        *((_WORD *)v63 + 8) = bswap32((unsigned __int16)dataPointerOut) >> 16;
      }
    }
    v55 = (const __CFNumber *)CMFormatDescriptionGetExtension(videoFormatDescription, CFSTR("RevisionLevel"));
    if (v55)
    {
      v56 = v55;
      v57 = CFNumberGetTypeID();
      if (v57 == CFGetTypeID(v56))
      {
        LOWORD(dataPointerOut) = 0;
        CFNumberGetValue(v56, kCFNumberSInt16Type, &dataPointerOut);
        *((_WORD *)v63 + 9) = bswap32((unsigned __int16)dataPointerOut) >> 16;
      }
    }
    v58 = (const __CFString *)CMFormatDescriptionGetExtension(videoFormatDescription, CFSTR("Vendor"));
    if (v58)
    {
      v59 = v58;
      v60 = CFStringGetTypeID();
      if (v60 == CFGetTypeID(v59))
      {
        v67.location = 0;
        v67.length = 4;
        if (CFStringGetBytes(v59, v67, 0, 0, 0, (UInt8 *)v63 + 20, 4, 0) != 4)
          *((_DWORD *)v63 + 5) = 0;
      }
    }
  }
  if (v65)
  {
    dataPointerOut = 0;
    v37 = CMBlockBufferGetDataPointer(theBuffer, 0x56uLL, 0, 0, &dataPointerOut);
    if (!v37)
    {
      figBridge_WalkAndConvertVideoFormatDescriptionExtensions(videoFormatDescription, (char)flavor, &v64, (uint64_t)dataPointerOut);
      goto LABEL_136;
    }
    goto LABEL_99;
  }
LABEL_136:
  DataPointer = 0;
  *blockBufferOut = theBuffer;
  return DataPointer;
}

CFTypeID figBridge_WalkAndConvertVideoFormatDescriptionExtensions(const opaqueCMFormatDescription *a1, char a2, _QWORD *a3, uint64_t a4)
{
  const opaqueCMFormatDescription *v6;
  CFPropertyListRef Extension;
  const void *v8;
  CFTypeID TypeID;
  size_t Count;
  size_t v11;
  const void **v12;
  const void **v13;
  const void **v14;
  BOOL v15;
  size_t v16;
  uint64_t i;
  const __CFString *v18;
  const void *v19;
  CFTypeID v20;
  CFTypeID v22;
  size_t Length;
  size_t v24;
  uint64_t v25;
  const UInt8 *BytePtr;
  CFIndex v27;
  CFIndex v28;
  CFIndex v29;
  const __CFData *ValueAtIndex;
  CFTypeID v31;
  size_t v32;
  const void **v33;
  const void **v34;
  size_t v35;
  uint64_t v36;
  size_t v37;
  _QWORD *v38;
  const UInt8 *v39;
  void *v40;
  size_t v41;
  size_t v42;
  const __CFString *v43;
  const __CFString *v44;
  CFTypeID v45;
  const __CFString *v46;
  _QWORD *v47;
  const __CFString *v48;
  const __CFString *v49;
  CFTypeID v50;
  const __CFString *v51;
  const __CFString *v52;
  const __CFString *v53;
  CFTypeID v54;
  const __CFString *v55;
  CFPropertyListRef v56;
  signed int MediaSubType;
  unsigned int IntegerCodePointForString;
  unsigned int v59;
  unsigned int v60;
  int v61;
  const __CFDictionary *v62;
  const __CFDictionary *v63;
  CFTypeID v64;
  const __CFArray *Value;
  CFTypeID v66;
  const __CFData *v67;
  const __CFData *v68;
  CFTypeID v69;
  size_t v70;
  unsigned int v71;
  const UInt8 *v72;
  int v73;
  CFPropertyListRef v74;
  const void *v75;
  CFTypeID v76;
  unsigned int v77;
  size_t v78;
  size_t v79;
  const __CFNumber *v80;
  CFPropertyListRef v81;
  CFTypeID v82;
  CFTypeID v83;
  char v84;
  unsigned __int8 v85;
  char v86;
  size_t v87;
  size_t v88;
  size_t v89;
  CFPropertyListRef v90;
  const void *v91;
  CFTypeID v92;
  size_t v93;
  size_t v94;
  size_t v95;
  CFPropertyListRef v96;
  CFPropertyListRef v97;
  const void *v98;
  CFTypeID v99;
  CFTypeID v100;
  size_t v101;
  _QWORD *v102;
  size_t v103;
  const __CFDictionary *v104;
  const __CFDictionary *v105;
  CFTypeID v106;
  const __CFNumber *v107;
  const __CFNumber *v108;
  CFTypeID v109;
  CFTypeID v110;
  size_t v111;
  unint64_t v112;
  _QWORD *v113;
  size_t v114;
  size_t v115;
  const __CFDictionary *v116;
  const __CFDictionary *v117;
  CFTypeID v118;
  size_t v119;
  unsigned int v120;
  unsigned int v121;
  unsigned int v122;
  unsigned int v123;
  unsigned int v124;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127;
  unsigned int v128;
  unsigned int v129;
  unsigned int v130;
  size_t v131;
  size_t v132;
  size_t v133;
  _DWORD *v134;
  _DWORD *v135;
  size_t v136;
  _DWORD *v137;
  size_t v138;
  signed int v139;
  const __CFString *v140;
  const __CFString *v141;
  CFTypeID v142;
  size_t v143;
  int v144;
  char v145;
  CFPropertyListRef v146;
  int v147;
  size_t v148;
  uint64_t *v149;
  size_t v150;
  const __CFString *v151;
  const __CFString *v152;
  CFTypeID v153;
  CFIndex v154;
  _BYTE *v155;
  size_t v156;
  int v157;
  size_t v158;
  size_t v159;
  size_t v160;
  CFTypeID result;
  const void *v162;
  CFTypeID v163;
  size_t v164;
  size_t v165;
  size_t v166;
  const __CFString *v167;
  CFTypeID v168;
  CFIndex v169;
  uint64_t v170;
  double v171;
  _DWORD *v172;
  _QWORD *v173;
  const void *v174;
  CFIndex v175;
  uint64_t v176;
  uint64_t v177;
  CFPropertyListRef v178;
  const opaqueCMFormatDescription *v180;
  size_t v181;
  uint64_t v182;
  uint64_t v183;
  unsigned int v184;
  _BYTE valuePtr[12];
  unsigned __int8 buffer[8];
  CFRange v187;
  CFRange v188;
  CFRange v189;
  CFRange v190;

  v6 = a1;
  v181 = 0;
  Extension = CMFormatDescriptionGetExtension(a1, CFSTR("SampleDescriptionExtensionAtoms"));
  v180 = v6;
  if (!Extension)
    goto LABEL_35;
  v8 = Extension;
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v8))
    goto LABEL_35;
  Count = CFDictionaryGetCount((CFDictionaryRef)v8);
  if (!Count)
    goto LABEL_35;
  v11 = Count;
  v12 = (const void **)malloc_type_calloc(Count, 8uLL, 0x6004044C4A2DFuLL);
  v13 = (const void **)malloc_type_calloc(v11, 8uLL, 0x6004044C4A2DFuLL);
  v14 = v13;
  if (v12)
    v15 = v13 == 0;
  else
    v15 = 1;
  if (!v15)
  {
    v176 = a4;
    v173 = a3;
    CFDictionaryGetKeysAndValues((CFDictionaryRef)v8, v12, v13);
    v16 = 0;
    for (i = 0; i != v11; ++i)
    {
      v18 = (const __CFString *)v12[i];
      v19 = v14[i];
      v20 = CFStringGetTypeID();
      if (v20 == CFGetTypeID(v18) && CFStringGetPascalString(v18, buffer, 5, 0) && buffer[0] == 4)
      {
        v177 = bswap32(*(unsigned int *)&buffer[1]);
        if ((_DWORD)v177)
        {
          v22 = CFGetTypeID(v19);
          if (CFDataGetTypeID() == v22)
          {
            Length = CFDataGetLength((CFDataRef)v19);
            v24 = v16;
            v25 = (Length + 8);
            if (v176)
            {
              *(_QWORD *)(v176 + v24) = bswap64(v177 | (v25 << 32));
              BytePtr = CFDataGetBytePtr((CFDataRef)v19);
              memcpy((void *)(v176 + v24 + 8), BytePtr, Length);
            }
            v16 = v24 + v25;
          }
          else if (CFArrayGetTypeID() == v22)
          {
            v27 = CFArrayGetCount((CFArrayRef)v19);
            if (v27)
            {
              v28 = v27;
              v29 = 0;
              v174 = v19;
              v175 = v27;
              do
              {
                ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex((CFArrayRef)v19, v29);
                v31 = CFDataGetTypeID();
                if (v31 == CFGetTypeID(ValueAtIndex))
                {
                  v32 = v11;
                  v33 = v14;
                  v34 = v12;
                  v35 = CFDataGetLength(ValueAtIndex);
                  v36 = (v35 + 8);
                  if (v176)
                  {
                    v37 = v16;
                    v38 = (_QWORD *)(v176 + v16);
                    *v38 = bswap64(v177 | (v36 << 32));
                    v39 = CFDataGetBytePtr(ValueAtIndex);
                    v40 = v38 + 1;
                    v16 = v37;
                    v19 = v174;
                    memcpy(v40, v39, v35);
                  }
                  v16 += v36;
                  v12 = v34;
                  v14 = v33;
                  v11 = v32;
                  v28 = v175;
                }
                ++v29;
              }
              while (v28 != v29);
            }
          }
        }
      }
      v6 = v180;
    }
    v181 = v16;
    a3 = v173;
    a4 = v176;
    if (!v12)
      goto LABEL_33;
    goto LABEL_32;
  }
  FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  if (v12)
LABEL_32:
    free(v12);
LABEL_33:
  if (v14)
    free(v14);
LABEL_35:
  v41 = v181;
  if (a4)
    v42 = a4 + v181;
  else
    v42 = 0;
  if ((a2 & 2) == 0)
  {
    v43 = (const __CFString *)CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E0CA8D68]);
    if (v43)
    {
      v44 = v43;
      v45 = CFGetTypeID(v43);
      if (v45 == CFStringGetTypeID())
        v46 = v44;
      else
        v46 = 0;
    }
    else
    {
      v46 = 0;
    }
    v47 = a3;
    v48 = (const __CFString *)CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E0CA8E98]);
    if (v48)
    {
      v49 = v48;
      v50 = CFGetTypeID(v48);
      if (v50 == CFStringGetTypeID())
        v51 = v49;
      else
        v51 = 0;
    }
    else
    {
      v51 = 0;
    }
    v52 = (const __CFString *)CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E0CA8EE8]);
    if (v52)
    {
      v53 = v52;
      v54 = CFGetTypeID(v52);
      if (v54 == CFStringGetTypeID())
        v55 = v53;
      else
        v55 = 0;
    }
    else
    {
      v55 = 0;
    }
    v56 = CMFormatDescriptionGetExtension(v6, CFSTR("FullRangeVideo"));
    MediaSubType = CMFormatDescriptionGetMediaSubType(v6);
    IntegerCodePointForString = CVColorPrimariesGetIntegerCodePointForString(v46);
    v59 = CVTransferFunctionGetIntegerCodePointForString(v51);
    v60 = CVYCbCrMatrixGetIntegerCodePointForString(v55);
    if (MediaSubType <= 1836415072)
    {
      if (MediaSubType > 1751479856)
      {
        if (MediaSubType == 1751479857)
          goto LABEL_67;
        v61 = 1752589105;
      }
      else
      {
        if (MediaSubType == 1667790435)
          goto LABEL_67;
        v61 = 1718908520;
      }
    }
    else
    {
      if (MediaSubType > 1902667125)
      {
        if (MediaSubType != 1902667126 && MediaSubType != 1902998904)
        {
          v61 = 1902671459;
          goto LABEL_66;
        }
LABEL_67:
        if ((unsigned __int16)v59 == 18)
        {
          if ((a2 & 1) != 0)
          {
            v62 = (const __CFDictionary *)CMFormatDescriptionGetExtension(v6, CFSTR("SampleDescriptionExtensionAtoms"));
            if (v62)
            {
              v63 = v62;
              v178 = v56;
              v64 = CFGetTypeID(v62);
              v15 = v64 == CFDictionaryGetTypeID();
              v56 = v178;
              if (v15)
              {
                Value = (const __CFArray *)CFDictionaryGetValue(v63, CFSTR("hvcC"));
                if (Value)
                {
                  v66 = CFArrayGetTypeID();
                  if (v66 == CFGetTypeID(Value))
                    Value = (const __CFArray *)CFArrayGetValueAtIndex(Value, 0);
                  v56 = v178;
                }
                buffer[0] = 0;
                if (!FigHEVCBridge_GetATCSEI(Value, buffer))
                  goto LABEL_70;
              }
            }
          }
          else if (CMFormatDescriptionGetExtension(v6, CFSTR("AlternativeTransferCharacteristics")))
          {
LABEL_70:
            v59 = 14;
          }
        }
LABEL_79:
        if ((unsigned __int16)IntegerCodePointForString == 2
          && (unsigned __int16)v59 == 2
          && (unsigned __int16)v60 == 2)
        {
          v67 = (const __CFData *)CMFormatDescriptionGetExtension(v6, CFSTR("CVImageBufferICCProfile"));
          if (v67)
          {
            v68 = v67;
            v69 = CFDataGetTypeID();
            a3 = v47;
            if (v69 == CFGetTypeID(v68))
            {
              v70 = CFDataGetLength(v68);
              v71 = v70 + 12;
              if (v42)
              {
                *(_QWORD *)v42 = bswap32(v71) | 0x726C6F6300000000;
                *(_DWORD *)(v42 + 8) = 1718579824;
                v72 = CFDataGetBytePtr(v68);
                memcpy((void *)(v42 + 12), v72, v70);
              }
            }
            else
            {
              v71 = 0;
            }
            goto LABEL_94;
          }
          v71 = 0;
        }
        else
        {
          v71 = a2 & 1 | 0x12;
          if (v42)
          {
            *(_QWORD *)v42 = (v71 << 24) | 0x726C6F6300000000;
            v73 = (a2 & 1) != 0 ? 2020369262 : 1668047726;
            *(_DWORD *)(v42 + 8) = v73;
            *(_WORD *)(v42 + 12) = bswap32(IntegerCodePointForString) >> 16;
            *(_WORD *)(v42 + 14) = bswap32(v59) >> 16;
            *(_WORD *)(v42 + 16) = bswap32(v60) >> 16;
            if ((a2 & 1) != 0)
              *(_BYTE *)(v42 + 18) = (*MEMORY[0x1E0C9AE50] == (_QWORD)v56) << 7;
          }
        }
        a3 = v47;
LABEL_94:
        v181 = v71;
        if (v42)
          v42 += v71;
        else
          v42 = 0;
        v41 += v71;
        v6 = v180;
        goto LABEL_98;
      }
      if (MediaSubType == 1836415073)
        goto LABEL_67;
      v61 = 1869117027;
    }
LABEL_66:
    if (MediaSubType != v61)
      goto LABEL_79;
    goto LABEL_67;
  }
LABEL_98:
  *(_QWORD *)buffer = 0;
  v74 = CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E0CA8DF8]);
  if (v74
    && (v75 = v74, v76 = CFNumberGetTypeID(), v76 == CFGetTypeID(v75))
    && CFNumberGetValue((CFNumberRef)v75, kCFNumberDoubleType, buffer)
    && (v77 = vcvtd_n_s64_f64(*(double *)buffer, 0x10uLL)) != 0)
  {
    if (v42)
    {
      *(_QWORD *)v42 = 0x616D61670C000000;
      *(_DWORD *)(v42 + 8) = bswap32(v77);
    }
    v78 = 12;
  }
  else
  {
    v78 = 0;
  }
  v181 = v78;
  if (v42)
    v79 = v42 + v78;
  else
    v79 = 0;
  buffer[0] = 0;
  v80 = (const __CFNumber *)CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E0CA8DC8]);
  v81 = CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E0CA8DD0]);
  if (v80)
  {
    v82 = CFNumberGetTypeID();
    if (v82 == CFGetTypeID(v80))
      CFNumberGetValue(v80, kCFNumberSInt8Type, buffer);
  }
  if (v81 && (v83 = CFStringGetTypeID(), v83 == CFGetTypeID(v81)))
  {
    if (CFEqual(v81, (CFTypeRef)*MEMORY[0x1E0CA8DF0]))
    {
      v84 = 1;
    }
    else if (CFEqual(v81, (CFTypeRef)*MEMORY[0x1E0CA8DE8]))
    {
      v84 = 6;
    }
    else if (CFEqual(v81, (CFTypeRef)*MEMORY[0x1E0CA8DD8]))
    {
      v84 = 9;
    }
    else if (CFEqual(v81, (CFTypeRef)*MEMORY[0x1E0CA8DE0]))
    {
      v84 = 14;
    }
    else
    {
      v84 = 0;
    }
  }
  else
  {
    v84 = 0;
  }
  v85 = buffer[0];
  if (buffer[0])
  {
    v86 = a2;
    if (v79)
    {
      *(_QWORD *)v79 = 0x6C6569660A000000;
      *(_BYTE *)(v79 + 8) = v85;
      *(_BYTE *)(v79 + 9) = v84;
    }
    v87 = 10;
  }
  else
  {
    v87 = 0;
    v86 = a2;
  }
  v181 = v87;
  if (v79)
    v88 = v79 + v87;
  else
    v88 = 0;
  v89 = v78 + v41 + v87;
  *(_DWORD *)buffer = 0;
  v90 = CMFormatDescriptionGetExtension(v6, CFSTR("CVBytesPerRow"));
  if (v90
    && (v91 = v90, v92 = CFNumberGetTypeID(), v92 == CFGetTypeID(v91))
    && CFNumberGetValue((CFNumberRef)v91, kCFNumberSInt32Type, buffer))
  {
    if (v88)
    {
      *(_QWORD *)v88 = 0x62776F720C000000;
      *(_DWORD *)(v88 + 8) = bswap32(*(unsigned int *)buffer);
    }
    v93 = 12;
  }
  else
  {
    v93 = 0;
  }
  v181 = v93;
  if (v88)
    v94 = v88 + v93;
  else
    v94 = 0;
  v95 = v89 + v93;
  buffer[0] = 0;
  valuePtr[4] = 0;
  v96 = CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E0CA8CE8]);
  v97 = CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E0CA8CE0]);
  if (v96
    && (v98 = v97, v99 = CFStringGetTypeID(), v99 == CFGetTypeID(v96))
    && figBridge_ConvertChromaLocationStringToUInt8(v96, (char *)buffer))
  {
    if (!v98
      || (v100 = CFStringGetTypeID(), v100 != CFGetTypeID(v98))
      || !figBridge_ConvertChromaLocationStringToUInt8(v98, &valuePtr[4]))
    {
      valuePtr[4] = buffer[0];
    }
    if (v94)
    {
      *(_QWORD *)v94 = 0x6D7268630A000000;
      *(_BYTE *)(v94 + 8) = buffer[0];
      *(_BYTE *)(v94 + 9) = valuePtr[4];
    }
    v101 = 10;
  }
  else
  {
    v101 = 0;
  }
  v181 = v101;
  if (v94)
    v102 = (_QWORD *)(v94 + v101);
  else
    v102 = 0;
  v103 = v95 + v101;
  *(_DWORD *)buffer = 0;
  *(_DWORD *)&valuePtr[4] = 0;
  v104 = (const __CFDictionary *)CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E0CA8E68]);
  if (!v104)
    goto LABEL_161;
  v105 = v104;
  v106 = CFGetTypeID(v104);
  if (v106 != CFDictionaryGetTypeID())
    goto LABEL_161;
  v107 = (const __CFNumber *)CFDictionaryGetValue(v105, (const void *)*MEMORY[0x1E0CA8E60]);
  v108 = (const __CFNumber *)CFDictionaryGetValue(v105, (const void *)*MEMORY[0x1E0CA8E70]);
  if (v107)
  {
    v109 = CFNumberGetTypeID();
    if (v109 == CFGetTypeID(v107))
      CFNumberGetValue(v107, kCFNumberSInt32Type, buffer);
  }
  if (v108 && (v110 = CFNumberGetTypeID(), v110 == CFGetTypeID(v108)))
  {
    CFNumberGetValue(v108, kCFNumberSInt32Type, &valuePtr[4]);
    v111 = 0;
    if (*(int *)buffer >= 1 && *(int *)&valuePtr[4] >= 1)
    {
      if (v102)
      {
        v112 = bswap64(*(unsigned int *)&valuePtr[4] | ((unint64_t)*(unsigned int *)buffer << 32));
        *v102 = 0x7073617010000000;
        v102[1] = v112;
      }
      v111 = 2;
    }
  }
  else
  {
LABEL_161:
    v111 = 0;
  }
  v181 = v111 * 8;
  if (v102)
    v113 = &v102[v111];
  else
    v113 = 0;
  VEXUBridge_ConvertVideoExtendedUsageExtensionToAtom(v6, &v181, v113);
  if (v113)
    v114 = (size_t)v113 + v181;
  else
    v114 = 0;
  v115 = v103 + v111 * 8 + v181;
  *(_DWORD *)buffer = 0;
  *(_QWORD *)valuePtr = 0;
  v184 = 0;
  v182 = 0;
  v183 = 0;
  v116 = (const __CFDictionary *)CMFormatDescriptionGetExtension(v6, (CFStringRef)*MEMORY[0x1E0CA8D50]);
  if (v116 && (v117 = v116, v118 = CFGetTypeID(v116), v118 == CFDictionaryGetTypeID()))
  {
    figBridge_ReadRationalOrIntegerFromDictionary(v117, CFSTR("WidthAsRational"), (const void *)*MEMORY[0x1E0CA8D60], buffer, &valuePtr[4]);
    figBridge_ReadRationalOrIntegerFromDictionary(v117, CFSTR("HeightAsRational"), (const void *)*MEMORY[0x1E0CA8D40], valuePtr, &v184);
    figBridge_ReadRationalOrIntegerFromDictionary(v117, CFSTR("HorizontalOffsetAsRational"), (const void *)*MEMORY[0x1E0CA8D48], (char *)&v183 + 4, &v183);
    figBridge_ReadRationalOrIntegerFromDictionary(v117, CFSTR("VerticalOffsetAsRational"), (const void *)*MEMORY[0x1E0CA8D58], (char *)&v182 + 4, &v182);
    v119 = 0;
    v120 = *(_DWORD *)buffer;
    if (*(_DWORD *)buffer)
    {
      v121 = *(_DWORD *)valuePtr;
      if (*(_DWORD *)valuePtr)
      {
        v122 = *(_DWORD *)&valuePtr[4];
        if (*(_DWORD *)&valuePtr[4])
        {
          v123 = v184;
          if (v184)
          {
            v124 = v183;
            if ((_DWORD)v183)
            {
              v125 = v182;
              if ((_DWORD)v182)
              {
                if (v114)
                {
                  *(_QWORD *)v114 = 0x70616C6328000000;
                  v126 = bswap32(v120);
                  v127 = bswap32(v122);
                  v128 = bswap32(v123);
                  v129 = bswap32(HIDWORD(v183));
                  v130 = bswap32(HIDWORD(v182));
                  *(_DWORD *)(v114 + 8) = v126;
                  *(_DWORD *)(v114 + 12) = v127;
                  *(_DWORD *)(v114 + 16) = bswap32(v121);
                  *(_DWORD *)(v114 + 20) = v128;
                  *(_DWORD *)(v114 + 24) = v129;
                  *(_DWORD *)(v114 + 28) = bswap32(v124);
                  *(_DWORD *)(v114 + 32) = v130;
                  *(_DWORD *)(v114 + 36) = bswap32(v125);
                }
                v119 = 40;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    v119 = 0;
  }
  v181 = v119;
  if (v114)
    v131 = v114 + v119;
  else
    v131 = 0;
  v132 = v115 + v119;
  if ((v86 & 2) == 0)
  {
    figBridge_ConvertCFDataExtensionToAtom(v6, &v181, (_DWORD *)v131, CFSTR("MasteringDisplayColorVolume"), 0x6D646376u);
    v133 = v181;
    if (v131)
      v134 = (_DWORD *)(v131 + v181);
    else
      v134 = 0;
    figBridge_ConvertCFDataExtensionToAtom(v6, &v181, v134, CFSTR("ContentLightLevelInfo"), 0x636C6C69u);
    if (v134)
      v135 = (_DWORD *)((char *)v134 + v181);
    else
      v135 = 0;
    v136 = v133 + v181;
    figBridge_ConvertCFDataExtensionToAtom(v6, &v181, v135, CFSTR("AmbientViewingEnvironment"), 0x616D7665u);
    if (v135)
      v137 = (_DWORD *)((char *)v135 + v181);
    else
      v137 = 0;
    v138 = v136 + v181;
    figBridge_ConvertCFDataExtensionToAtom(v6, &v181, v137, CFSTR("ContentColorVolume"), 0x63636C76u);
    if (v137)
      v131 = (size_t)v137 + v181;
    else
      v131 = 0;
    v132 += v138 + v181;
  }
  if ((v86 & 1) == 0)
  {
    v139 = CMFormatDescriptionGetMediaSubType(v6);
    v140 = (const __CFString *)CMFormatDescriptionGetExtension(v6, CFSTR("AlternativeTransferCharacteristics"));
    if (!v140 || (v141 = v140, v142 = CFGetTypeID(v140), v142 != CFStringGetTypeID()))
    {
      v143 = 0;
      goto LABEL_222;
    }
    v143 = 0;
    if (v139 <= 1836415072)
    {
      if (v139 > 1751479856)
      {
        if (v139 != 1751479857)
        {
          v144 = 1752589105;
          goto LABEL_218;
        }
      }
      else if (v139 != 1667790435)
      {
        v144 = 1718908520;
        goto LABEL_218;
      }
    }
    else
    {
      if (v139 > 1902667125)
      {
        if (v139 == 1902667126 || v139 == 1902998904)
          goto LABEL_219;
        v144 = 1902671459;
LABEL_218:
        if (v139 == v144)
          goto LABEL_219;
LABEL_222:
        v181 = v143;
        if (v131)
          v131 += v143;
        else
          v131 = 0;
        v132 += v143;
        goto LABEL_226;
      }
      if (v139 != 1836415073)
      {
        v144 = 1869117027;
        goto LABEL_218;
      }
    }
LABEL_219:
    v145 = CVTransferFunctionGetIntegerCodePointForString(v141);
    if (v131)
    {
      *(_QWORD *)v131 = 0x6863746109000000;
      *(_BYTE *)(v131 + 8) = v145;
    }
    v143 = 9;
    goto LABEL_222;
  }
LABEL_226:
  v146 = CMFormatDescriptionGetExtension(v6, CFSTR("AlphaChannelMode"));
  if (FigCFEqual(v146, CFSTR("StraightAlpha")))
  {
    v147 = 0x10000;
    if (!v131)
    {
LABEL_229:
      v148 = 12;
      goto LABEL_230;
    }
LABEL_228:
    *(_QWORD *)v131 = 0x6F6D6C610C000000;
    *(_DWORD *)(v131 + 8) = v147;
    goto LABEL_229;
  }
  if (FigCFEqual(v146, CFSTR("PremultipliedAlpha")))
  {
    v147 = 33619968;
    if (!v131)
      goto LABEL_229;
    goto LABEL_228;
  }
  v148 = 0;
LABEL_230:
  v181 = v148;
  if (v131)
    v149 = (uint64_t *)(v131 + v148);
  else
    v149 = 0;
  v150 = v148 + v132;
  v151 = (const __CFString *)CMFormatDescriptionGetExtension(v6, CFSTR("AuxiliaryTypeInfo"));
  if (!v151 || (v152 = v151, v153 = CFStringGetTypeID(), v153 != CFGetTypeID(v152)))
  {
    v155 = 0;
LABEL_242:
    v156 = 0;
    goto LABEL_243;
  }
  v154 = CFStringGetLength(v152);
  *(_QWORD *)buffer = 0;
  v187.location = 0;
  v187.length = v154;
  v155 = 0;
  if (CFStringGetBytes(v152, v187, 0x8000100u, 0, 0, 0, 0, (CFIndex *)buffer) != v154)
  {
    v156 = 0;
    goto LABEL_243;
  }
  v156 = 0;
  if (*(uint64_t *)buffer >= 1)
  {
    v155 = malloc_type_malloc(*(_QWORD *)buffer + 1, 0x8A7507E9uLL);
    *(_QWORD *)&valuePtr[4] = 0;
    v188.location = 0;
    v188.length = v154;
    v156 = 0;
    if (CFStringGetBytes(v152, v188, 0x8000100u, 0, 0, v155, *(CFIndex *)buffer, (CFIndex *)&valuePtr[4]) == v154)
    {
      if (*(_QWORD *)buffer == *(_QWORD *)&valuePtr[4])
      {
        v155[*(_QWORD *)buffer] = 0;
        v157 = *(_DWORD *)buffer;
        v158 = ++*(_QWORD *)buffer;
        v156 = (v157 + 9);
        if (v149)
        {
          *v149 = bswap32(v156) | 0x6978756100000000;
          memcpy(v149 + 1, v155, v158);
        }
        goto LABEL_243;
      }
      goto LABEL_242;
    }
  }
LABEL_243:
  v181 = v156;
  free(v155);
  if (v149)
    v159 = (size_t)v149 + v181;
  else
    v159 = 0;
  v160 = v150 + v181;
  *(_DWORD *)buffer = 0;
  result = (CFTypeID)CMFormatDescriptionGetExtension(v6, CFSTR("HorizontalFieldOfView"));
  if (result
    && (v162 = (const void *)result, v163 = CFNumberGetTypeID(), result = CFGetTypeID(v162), v163 == result)
    && (result = CFNumberGetValue((CFNumberRef)v162, kCFNumberSInt32Type, buffer), (_DWORD)result))
  {
    if (v159)
    {
      *(_QWORD *)v159 = 0x766F66680C000000;
      *(_DWORD *)(v159 + 8) = bswap32(*(unsigned int *)buffer);
    }
    v164 = 12;
  }
  else
  {
    v164 = 0;
  }
  v181 = v164;
  if (v159)
    v165 = v159 + v164;
  else
    v165 = 0;
  v166 = v160 + v164;
  if ((v86 & 1) != 0)
  {
LABEL_271:
    if (!a3)
      return result;
    goto LABEL_272;
  }
  result = (CFTypeID)CMFormatDescriptionGetExtension(v6, CFSTR("LogTransferFunction"));
  if (!result)
    goto LABEL_263;
  v167 = (const __CFString *)result;
  v168 = CFGetTypeID((CFTypeRef)result);
  result = CFStringGetTypeID();
  if (v168 != result)
    goto LABEL_263;
  v169 = CFStringGetLength(v167);
  *(_QWORD *)buffer = 0;
  v189.location = 0;
  v189.length = v169;
  result = CFStringGetBytes(v167, v189, 0x600u, 0, 0, 0, 0, (CFIndex *)buffer);
  v170 = 0;
  if (result != v169)
    goto LABEL_264;
  v171 = *(double *)buffer;
  if ((unint64_t)(*(_QWORD *)buffer - 1) <= 0xFFFFFFF6)
  {
    v170 = (*(_DWORD *)buffer + 8);
    if (v165)
    {
      *(_QWORD *)&valuePtr[4] = 0;
      *(_QWORD *)v165 = bswap32(v170) | 0x73676F6C00000000;
      v190.location = 0;
      v190.length = v169;
      result = CFStringGetBytes(v167, v190, 0x600u, 0, 0, (UInt8 *)(v165 + 8), *(CFIndex *)&v171, (CFIndex *)&valuePtr[4]);
    }
  }
  else
  {
LABEL_263:
    v170 = 0;
  }
LABEL_264:
  if (v165)
    v172 = (_DWORD *)(v165 + v170);
  else
    v172 = 0;
  if (v170 + v166)
  {
    if (v172)
      *v172 = 0;
    v166 += v170 + 4;
    goto LABEL_271;
  }
  v166 = 0;
  if (a3)
LABEL_272:
    *a3 = v166;
  return result;
}

uint64_t figBridge_ConvertH263SampleDescriptionExtensionToCodecType(const opaqueCMFormatDescription *a1, _DWORD *a2)
{
  const __CFDictionary *Extensions;

  Extensions = CMFormatDescriptionGetExtensions(a1);
  if (!Extensions || !figBridge_Is3GP263ExtensionPresent(Extensions))
    return FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
  *a2 = 1932670515;
  return 0;
}

CFTypeID figBridge_ConvertMPEG2ProfileExtensionToCodecType(const opaqueCMFormatDescription *a1, void *a2)
{
  CFTypeID result;
  const void *v4;
  CFTypeID TypeID;

  result = (CFTypeID)CMFormatDescriptionGetExtension(a1, CFSTR("ConformsToMPEG2VideoProfile"));
  if (result)
  {
    v4 = (const void *)result;
    TypeID = CFNumberGetTypeID();
    result = CFGetTypeID(v4);
    if (TypeID == result)
      return CFNumberGetValue((CFNumberRef)v4, kCFNumberSInt32Type, a2);
  }
  return result;
}

OSStatus CMSwapBigEndianImageDescriptionToHost(uint8_t *imageDescriptionData, size_t imageDescriptionSize)
{
  return figBridge_FlipImageDescriptionData((uint64_t)imageDescriptionData, imageDescriptionSize, 0);
}

uint64_t figBridge_FlipImageDescriptionData(uint64_t a1, unint64_t a2, int a3)
{
  int v3;
  unsigned int v4;
  int v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  int8x8_t v11;
  int8x8_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  int8x8_t v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unint64_t *v23;
  unsigned int v24;
  int v25;
  uint64_t v27;
  __int128 v28;
  __int128 v29;

  if (!a1)
  {
    v27 = 4294954584;
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  v3 = *(_DWORD *)a1;
  v4 = bswap32(*(_DWORD *)a1);
  if (!a3)
    v3 = v4;
  if (v3 < 0x56 || v3 > a2)
  {
LABEL_23:
    v27 = 4294954582;
    return FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
  }
  v6 = *(unsigned __int16 *)(a1 + 84);
  if (!*(_WORD *)(a1 + 84))
  {
    if (v3 >= 0x66)
    {
      v8 = *(unsigned __int16 *)(a1 + 92);
      v9 = bswap32(v8) >> 16;
      if (!a3)
        LOWORD(v8) = v9;
      if ((v8 & 0x8000) == 0 && 8 * (unsigned __int16)v8 + 102 <= v3)
      {
        v7 = a1 + 86;
        goto LABEL_16;
      }
    }
    goto LABEL_23;
  }
  v7 = 0;
LABEL_16:
  v28 = *(_OWORD *)(a1 + 50);
  v29 = *(_OWORD *)(a1 + 66);
  v10 = bswap32(*(_DWORD *)(a1 + 8));
  v11 = vrev16_s8(*(int8x8_t *)(a1 + 12));
  v12 = vrev32_s8(*(int8x8_t *)(a1 + 20));
  v13 = bswap32(*(_DWORD *)(a1 + 28));
  v14 = bswap32(*(unsigned __int16 *)(a1 + 32)) >> 16;
  v15 = bswap32(*(unsigned __int16 *)(a1 + 34)) >> 16;
  v16 = vrev32_s8(*(int8x8_t *)(a1 + 36));
  v17 = bswap32(*(_DWORD *)(a1 + 44));
  v18 = bswap32(*(unsigned __int16 *)(a1 + 48)) >> 16;
  v19 = bswap32(*(unsigned __int16 *)(a1 + 82)) >> 16;
  v20 = bswap32(*(unsigned __int16 *)(a1 + 84)) >> 16;
  *(int8x8_t *)a1 = vrev32_s8(*(int8x8_t *)a1);
  *(_DWORD *)(a1 + 8) = v10;
  *(int8x8_t *)(a1 + 12) = v11;
  *(int8x8_t *)(a1 + 20) = v12;
  *(_DWORD *)(a1 + 28) = v13;
  *(_WORD *)(a1 + 32) = v14;
  *(_WORD *)(a1 + 34) = v15;
  *(int8x8_t *)(a1 + 36) = v16;
  *(_DWORD *)(a1 + 44) = v17;
  *(_WORD *)(a1 + 48) = v18;
  *(_OWORD *)(a1 + 66) = v29;
  *(_OWORD *)(a1 + 50) = v28;
  *(_WORD *)(a1 + 82) = v19;
  *(_WORD *)(a1 + 84) = v20;
  if (!v6)
  {
    v21 = *(unsigned __int16 *)(v7 + 6);
    v22 = bswap32(v21) >> 16;
    if (!a3)
      LOWORD(v21) = v22;
    v21 = (__int16)v21;
    *(_QWORD *)v7 = bswap32(*(_QWORD *)v7) | ((unint64_t)(bswap32(HIDWORD(*(_QWORD *)v7)) >> 16) << 32) | ((unint64_t)__rev16(HIWORD(*(_QWORD *)v7)) << 48);
    if ((__int16)v21 >= 1)
    {
      v23 = (unint64_t *)(a1 + 94);
      do
      {
        v24 = bswap32(*v23);
        *v23 = HIWORD(v24) | ((unint64_t)(unsigned __int16)v24 << 16) | ((unint64_t)(bswap32(HIDWORD(*v23)) >> 16) << 32) | ((unint64_t)__rev16(HIWORD(*v23)) << 48);
        ++v23;
        v25 = (__int16)v21--;
      }
      while (v25 > 1);
    }
  }
  return 0;
}

OSStatus CMSwapHostEndianImageDescriptionToBig(uint8_t *imageDescriptionData, size_t imageDescriptionSize)
{
  return figBridge_FlipImageDescriptionData((uint64_t)imageDescriptionData, imageDescriptionSize, 1);
}

uint64_t figBridge_WrapPayloadAsCFData(CFAllocatorRef allocator, uint64_t a2, uint64_t a3, _QWORD *a4, UInt8 *bytes, CFIndex length, CFTypeRef cf)
{
  CFDataRef v12;
  uint64_t result;

  if (a2)
    *(_QWORD *)(a2 + 8 * *a4) = CFRetain(cf);
  if (a3 && (v12 = CFDataCreate(allocator, bytes, length), (*(_QWORD *)(a3 + 8 * *a4) = v12) == 0))
    result = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  else
    result = 0;
  ++*a4;
  return result;
}

CFArrayRef figBridge_CFArrayCreateWithTwoIntegers(const __CFAllocator *a1, int a2, int a3)
{
  const __CFAllocator *v4;
  void *v5;
  CFNumberRef v6;
  BOOL v7;
  CFArrayRef v8;
  int v10;
  int valuePtr;
  void *values;
  CFTypeRef cf;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10 = a3;
  valuePtr = a2;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  values = v5;
  v6 = CFNumberCreate(v4, kCFNumberIntType, &v10);
  cf = v6;
  if (v5)
    v7 = v6 == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v8 = CFArrayCreate(a1, (const void **)&values, 2, MEMORY[0x1E0C9B378]);
    v5 = values;
    if (!values)
      goto LABEL_10;
    goto LABEL_9;
  }
  v8 = 0;
  if (v5)
LABEL_9:
    CFRelease(v5);
LABEL_10:
  if (cf)
    CFRelease(cf);
  return v8;
}

uint64_t figBridge_GetConciseProtectedCodecTypeFromSinfData(uint64_t a1, uint64_t a2)
{
  int OriginalFormatFromSinf;
  int CommonEncryptionScheme;
  uint64_t v6;

  OriginalFormatFromSinf = FigBridgeGetOriginalFormatFromSinf(a1, a2);
  CommonEncryptionScheme = FigBridgeGetCommonEncryptionScheme(a1, a2);
  v6 = 0;
  while (OriginalFormatFromSinf != lookUpConciseCodecType[v6]
       || CommonEncryptionScheme != lookUpConciseCodecType[v6 + 1])
  {
    v6 += 3;
    if (v6 == 63)
      return 0;
  }
  return lookUpConciseCodecType[v6 + 2];
}

unint64_t figBridge_ConvertCFDataExtensionToAtom(const opaqueCMFormatDescription *a1, _QWORD *a2, _DWORD *a3, CFStringRef extensionKey, unsigned int a5)
{
  unint64_t result;
  const __CFData *v9;
  CFTypeID TypeID;
  size_t v11;
  uint64_t v12;
  const UInt8 *BytePtr;

  result = (unint64_t)CMFormatDescriptionGetExtension(a1, extensionKey);
  if (result
    && (v9 = (const __CFData *)result, TypeID = CFDataGetTypeID(), result = CFGetTypeID(v9), TypeID == result)
    && (result = CFDataGetLength(v9), result <= 0xFFFFFFF7))
  {
    v11 = result;
    v12 = (result + 8);
    if (a3)
    {
      *a3 = bswap32(v12);
      a3[1] = bswap32(a5);
      BytePtr = CFDataGetBytePtr(v9);
      result = (unint64_t)memcpy(a3 + 2, BytePtr, v11);
    }
  }
  else
  {
    v12 = 0;
  }
  *a2 = v12;
  return result;
}

uint64_t figBridge_ConvertChromaLocationStringToUInt8(const void *a1, char *a2)
{
  char v4;
  uint64_t result;

  if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0CA8D10]))
  {
    v4 = 0;
  }
  else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0CA8D00]))
  {
    v4 = 1;
  }
  else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0CA8D20]))
  {
    v4 = 2;
  }
  else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0CA8D18]))
  {
    v4 = 3;
  }
  else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0CA8CF8]))
  {
    v4 = 4;
  }
  else if (CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0CA8CF0]))
  {
    v4 = 5;
  }
  else
  {
    result = CFEqual(a1, (CFTypeRef)*MEMORY[0x1E0CA8D08]);
    if (!(_DWORD)result)
      return result;
    v4 = -1;
  }
  *a2 = v4;
  return 1;
}

CFTypeID figBridge_ReadRationalOrIntegerFromDictionary(const __CFDictionary *a1, const void *a2, const void *a3, void *a4, _DWORD *a5)
{
  const void *Value;
  const void *v10;
  CFTypeID v11;
  const __CFNumber *ValueAtIndex;
  const __CFNumber *v13;
  const __CFNumber *v14;
  CFTypeID v15;
  CFTypeID v16;
  CFTypeID result;
  const void *v18;
  CFTypeID TypeID;

  Value = CFDictionaryGetValue(a1, a2);
  if (Value
    && (v10 = Value, v11 = CFArrayGetTypeID(), v11 == CFGetTypeID(v10))
    && CFArrayGetCount((CFArrayRef)v10) == 2
    && (ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)v10, 0),
        v13 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)v10, 1),
        ValueAtIndex)
    && (v14 = v13, v15 = CFNumberGetTypeID(), v15 == CFGetTypeID(ValueAtIndex))
    && v14
    && (v16 = CFNumberGetTypeID(), v16 == CFGetTypeID(v14)))
  {
    CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, a4);
    return CFNumberGetValue(v14, kCFNumberSInt32Type, a5);
  }
  else
  {
    result = (CFTypeID)CFDictionaryGetValue(a1, a3);
    if (result)
    {
      v18 = (const void *)result;
      TypeID = CFNumberGetTypeID();
      result = CFGetTypeID(v18);
      if (TypeID == result)
      {
        result = CFNumberGetValue((CFNumberRef)v18, kCFNumberSInt32Type, a4);
        *a5 = 1;
      }
    }
  }
  return result;
}

uint64_t FigMP4Bridge_GetESDSObjectTypeAndCopyDecoderSpecificInfo(unint64_t a1, unint64_t a2, char *a3, unsigned __int16 *a4, __CFDictionary **a5)
{
  uint64_t result;
  unint64_t v7;
  unint64_t v11;
  uint64_t v12;
  unsigned __int8 Bits;
  unint64_t v14;
  BOOL v15;
  int v16;
  char v18;
  char v19;
  unint64_t v20;
  uint64_t v21;
  char v22;
  unint64_t v23;
  unsigned __int8 v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  int v29;
  unint64_t v30;
  unint64_t v31;
  unsigned int v33;
  unsigned int v34;
  int v35;
  unint64_t v36;
  int v37;
  int v38;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v40;
  __int16 v41;
  __int16 v42;
  unsigned __int16 v43;
  unsigned __int8 v44;
  unsigned int v45;
  unint64_t v46;
  __int16 v47;
  __int16 v48;
  const __CFAllocator *v49;
  CFMutableDictionaryRef PixelAspectRatioDictionary;
  CFMutableDictionaryRef v51;
  int v52;
  int v53;
  CFMutableDictionaryRef v54;
  CFMutableDictionaryRef v55;
  uint64_t v56;
  int v57;
  int v58;
  uint64_t v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  int v63;
  int v64;
  CFMutableDictionaryRef v65;
  const __CFDictionary *v66;
  unsigned int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  int64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  __int128 v75;
  uint64_t v76;

  result = 4294954582;
  if (!a1)
    return result;
  v7 = a2;
  if (!a2)
    return result;
  v72 = a1;
  v73 = a2;
  v76 = 0;
  v74 = a1;
  v75 = a1 + a2;
  result = CopyNextWord((uint64_t)&v72);
  if ((_DWORD)result)
    return result;
  v11 = v74;
  v12 = v75;
  if (v74 >= (unint64_t)v75)
  {
    Bits = 0;
LABEL_17:
    v16 = Bits;
  }
  else
  {
    Bits = 0;
    while (1)
    {
      v14 = v12 - v11;
      v15 = HIDWORD(v75) || v14 > 4;
      v16 = Bits;
      if (!v15 || Bits == 3)
        break;
      Bits = GetBits((uint64_t)&v72, 8u);
      v11 = v74;
      v12 = v75;
      if (v74 >= (unint64_t)v75)
        goto LABEL_17;
    }
  }
  if (v16 != 3)
    goto LABEL_54;
  v71 = 0;
  if (!GetBERInteger((uint64_t)&v72, (unint64_t *)&v71)
    || v71 < 1
    || v74 >= (unint64_t)v75
    || (_QWORD)v75 - (v76 + v74) + ((unint64_t)HIDWORD(v75) >> 3) < v71
    || (unint64_t)v75 - v74 <= 4 && !HIDWORD(v75))
  {
    goto LABEL_54;
  }
  SkipBits((uint64_t)&v72, 0x10u);
  v18 = GetBits((uint64_t)&v72, 8u);
  v19 = v18;
  if (v18 < 0)
  {
    SkipBits((uint64_t)&v72, 0x10u);
    if ((v19 & 0x40) == 0)
    {
LABEL_27:
      if ((v19 & 0x20) == 0)
        goto LABEL_29;
      goto LABEL_28;
    }
  }
  else if ((v18 & 0x40) == 0)
  {
    goto LABEL_27;
  }
  v24 = GetBits((uint64_t)&v72, 8u);
  SkipBits((uint64_t)&v72, 8 * v24 + 8);
  if ((v19 & 0x20) != 0)
LABEL_28:
    SkipBits((uint64_t)&v72, 0x10u);
LABEL_29:
  if (v74 >= (unint64_t)v75 || (unint64_t)v75 - v74 <= 4 && !HIDWORD(v75))
    goto LABEL_54;
  if (GetBits((uint64_t)&v72, 8u) != 4)
    goto LABEL_54;
  v70 = 0;
  if (!GetBERInteger((uint64_t)&v72, &v70))
    goto LABEL_54;
  if (v74 >= (unint64_t)v75)
    goto LABEL_54;
  v20 = v75 - (v76 + v74) + ((unint64_t)HIDWORD(v75) >> 3);
  v21 = v70 - v20;
  if (v70 > v20 || (unint64_t)v75 - v74 <= 4 && !HIDWORD(v75))
    goto LABEL_54;
  v22 = GetBits((uint64_t)&v72, 8u);
  if ((GetBits((uint64_t)&v72, 8u) & 0x3F8) != 0x10)
    goto LABEL_54;
  SkipBits((uint64_t)&v72, 0x58u);
  if (v74 >= (unint64_t)v75)
  {
    v25 = 0;
    v23 = 0;
  }
  else
  {
    v23 = v75 - (v76 + v74) + ((unint64_t)HIDWORD(v75) >> 3);
    v69 = 0;
    if (((unint64_t)v75 - v74 > 4 || HIDWORD(v75)) && GetBits((uint64_t)&v72, 8u) == 5)
    {
      if (GetBERInteger((uint64_t)&v72, &v69))
      {
        v23 = v74 >= (unint64_t)v75 ? 0 : v75 - (v76 + v74) + ((unint64_t)HIDWORD(v75) >> 3);
        v25 = v69;
        if (v23 >= v69 && v21 + v23 >= v69)
          goto LABEL_53;
      }
LABEL_54:
      result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      if ((_DWORD)result)
        return result;
      v26 = 0;
      v22 = 32;
      goto LABEL_56;
    }
    v25 = 0;
  }
LABEL_53:
  v26 = v73 - v23;
  v7 = v25;
LABEL_56:
  if (a3)
    *a3 = v22;
  switch(v22)
  {
    case 'a':
    case 'b':
    case 'c':
    case 'd':
    case 'e':
      if (!v7)
        return 0;
      v27 = a1 + v26;
      v28 = v7;
      v29 = 1;
      return MP4Bridge_ParseMPEGVideoSequenceHeader(v27, v28, v29, a5);
    case 'f':
    case 'g':
    case 'h':
      v36 = a1 + v26;
      LODWORD(v71) = 0;
      LODWORD(v70) = 0;
      v72 = v36;
      v73 = v7;
      v76 = 0;
      v74 = v36;
      v75 = v36 + v7;
      result = CopyNextWord((uint64_t)&v72);
      if ((_DWORD)result)
        return result;
      if (GetBits((uint64_t)&v72, 0x20u) != 1094994246)
      {
        v46 = v36;
        return MP4Bridge_ParseMPEG4AudioSpecificConfig(v46, v7, a4, a5);
      }
      if (GetBits((uint64_t)&v72, 1u) == 1)
      {
        v37 = 9;
        do
        {
          SkipBits((uint64_t)&v72, 8u);
          --v37;
        }
        while (v37);
      }
      SkipBits((uint64_t)&v72, 1u);
      SkipBits((uint64_t)&v72, 1u);
      v38 = GetBits((uint64_t)&v72, 1u);
      SkipBits((uint64_t)&v72, 0x17u);
      if ((GetBits((uint64_t)&v72, 4u) + 1) != 1)
      {
        v59 = 4294954582;
        return FigSignalErrorAt(v59, 0, 0, 0, 0, 0, 0);
      }
      if (!v38)
        SkipBits((uint64_t)&v72, 0x14u);
      result = MP4Bridge_ParseProgramConfigElement((uint64_t)&v72, &v71, &v70);
      if (!a5 || (_DWORD)result)
        return result;
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (!Mutable)
        goto LABEL_191;
      v40 = Mutable;
      FigCFDictionarySetInt32(Mutable, CFSTR("AudioSampleRate"), v71);
      FigCFDictionarySetInt32(v40, CFSTR("AudioChannelCount"), v70);
      FigCFDictionarySetInt32(v40, CFSTR("AudioFramesPerPacket"), 1024);
      goto LABEL_149;
    case 'i':
    case 'k':
      if (!v7)
        return 0;
      if (v7 <= 5)
        goto LABEL_160;
      v72 = a1 + v26;
      v73 = v7;
      v74 = a1 + v26;
      v76 = 0;
      v75 = a1 + v26 + v7;
      if (CopyNextWord((uint64_t)&v72))
        return 0;
      SkipBits((uint64_t)&v72, 0xBu);
      v41 = GetBits((uint64_t)&v72, 2u);
      if (v41 == 1)
        goto LABEL_160;
      v42 = v41;
      v43 = 4 - GetBits((uint64_t)&v72, 2u);
      if (v43 >= 4u)
        goto LABEL_160;
      if (!a5)
        goto LABEL_157;
      SkipBits((uint64_t)&v72, 5u);
      v44 = GetBits((uint64_t)&v72, 2u);
      if (v44 == 3)
      {
LABEL_160:
        v56 = 4294954582;
      }
      else
      {
        if (v44 > 2u)
          v45 = 0;
        else
          v45 = dword_18EDDD680[(char)v44];
        if (v42)
        {
          if (v42 == 2)
            v45 >>= 1;
        }
        else
        {
          v45 >>= 2;
        }
        SkipBits((uint64_t)&v72, 2u);
        if (GetBits((uint64_t)&v72, 2u) == 3)
          v52 = 1;
        else
          v52 = 2;
        switch(v43)
        {
          case 3u:
            if (v45 <= 0x5DC0)
              v53 = 576;
            else
              v53 = 1152;
            break;
          case 2u:
            v53 = 1152;
            break;
          case 1u:
            v53 = 384;
            break;
          default:
            v53 = 0;
            break;
        }
        v54 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (v54)
        {
          v55 = v54;
          FigCFDictionarySetInt32(v54, CFSTR("AudioSampleRate"), v45);
          FigCFDictionarySetInt32(v55, CFSTR("AudioChannelCount"), v52);
          FigCFDictionarySetInt32(v55, CFSTR("AudioFramesPerPacket"), v53);
          *a5 = v55;
LABEL_157:
          if (a4)
            *a4 = v43;
          return 0;
        }
        v56 = 4294954510;
      }
      FigSignalErrorAt(v56, 0, 0, 0, 0, 0, 0);
      return 0;
    case 'j':
      if (!v7)
        return 0;
      v27 = a1 + v26;
      v28 = v7;
      v29 = 0;
      return MP4Bridge_ParseMPEGVideoSequenceHeader(v27, v28, v29, a5);
    case 'l':
      if (v7 < 7)
        return 0;
      v72 = a1 + v26;
      v73 = v7;
      v74 = a1 + v26;
      v76 = 0;
      v75 = a1 + v26 + v7;
      result = CopyNextWord((uint64_t)&v72);
      if ((_DWORD)result)
        return result;
      SkipBits((uint64_t)&v72, 0x10u);
      v47 = GetBits((uint64_t)&v72, 0x10u);
      v48 = GetBits((uint64_t)&v72, 0x10u);
      SkipBits((uint64_t)&v72, 8u);
      v49 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v40 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v40)
      {
        PixelAspectRatioDictionary = createPixelAspectRatioDictionary(v49, v47, v48);
        FigCFDictionarySetValue(v40, (const void *)*MEMORY[0x1E0CA8E68], PixelAspectRatioDictionary);
        if (PixelAspectRatioDictionary)
          CFRelease(PixelAspectRatioDictionary);
        if (!a5)
        {
          v51 = v40;
          goto LABEL_133;
        }
      }
      else if (!a5)
      {
        return 0;
      }
LABEL_149:
      result = 0;
      *a5 = v40;
      return result;
    default:
      if (v22 == 64)
      {
        v46 = a1 + v26;
        return MP4Bridge_ParseMPEG4AudioSpecificConfig(v46, v7, a4, a5);
      }
      if (v22 != 32)
        return 0;
      if (!v7)
      {
        result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
        if ((_DWORD)result)
          return result;
        return 4294954582;
      }
      v72 = a1 + v26;
      v73 = v7;
      v74 = a1 + v26;
      v76 = 0;
      v75 = a1 + v26 + v7;
      result = CopyNextWord((uint64_t)&v72);
      if ((_DWORD)result)
        return result;
      v30 = v74;
      v31 = v75;
      while (1)
      {
        if (v30 >= v31 || v31 - v30 <= 4 && !HIDWORD(v75))
          return 4294954582;
        while (PeekBits((uint64_t)&v72, 0x18u) != 1)
        {
          GetBits((uint64_t)&v72, 8u);
          if (v74 < (unint64_t)v75 && ((unint64_t)v75 - v74 > 4 || HIDWORD(v75) != 0))
            continue;
          return 4294954582;
        }
        GetBits((uint64_t)&v72, 0x18u);
        v33 = GetBits((uint64_t)&v72, 8u);
        if (v33 != 181)
          break;
        if (GetBits((uint64_t)&v72, 1u) == 1)
        {
          GetBits((uint64_t)&v72, 4u);
          GetBits((uint64_t)&v72, 3u);
        }
        v35 = GetBits((uint64_t)&v72, 4u);
        if ((v35 - 1) <= 1 && GetBits((uint64_t)&v72, 1u) == 1)
        {
          GetBits((uint64_t)&v72, 3u);
          GetBits((uint64_t)&v72, 1u);
          if (GetBits((uint64_t)&v72, 1u))
          {
            GetBits((uint64_t)&v72, 8u);
            GetBits((uint64_t)&v72, 8u);
            GetBits((uint64_t)&v72, 8u);
          }
        }
        GetBits((uint64_t)&v72, 1u);
        GetBits((uint64_t)&v72, BYTE12(v75) & 7);
        if (PeekBits((uint64_t)&v72, 0x20u) == 434)
        {
LABEL_90:
          result = EatUserData((uint64_t)&v72);
          if ((_DWORD)result)
            return result;
          goto LABEL_98;
        }
        if (v35 != 1)
          return 4294954579;
        GetBits((uint64_t)&v72, 0x18u);
        GetBits((uint64_t)&v72, 8u);
        if (PeekBits((uint64_t)&v72, 0x16u) == 32)
          return 4294954579;
LABEL_98:
        v30 = v74;
        v31 = v75;
        if (v74 >= (unint64_t)v75 || (unint64_t)v75 - v74 <= 4 && !HIDWORD(v75))
          return 4294954582;
      }
      if (v33 == 176)
      {
        v34 = 8;
LABEL_81:
        GetBits((uint64_t)&v72, v34);
        if (PeekBits((uint64_t)&v72, 0x20u) == 434)
          goto LABEL_90;
        goto LABEL_98;
      }
      if (v33 < 0x20)
        goto LABEL_98;
      if ((v33 & 0xFFFFFFF0) != 0x20)
      {
        if (v33 != 179)
          goto LABEL_98;
        GetBits((uint64_t)&v72, 0x14u);
        GetBits((uint64_t)&v72, 1u);
        v34 = BYTE12(v75) & 7;
        goto LABEL_81;
      }
      GetBits((uint64_t)&v72, 1u);
      if (GetBits((uint64_t)&v72, 8u) == 18)
        return 4294954579;
      v57 = 1;
      if (GetBits((uint64_t)&v72, 1u))
      {
        v57 = GetBits((uint64_t)&v72, 4u);
        GetBits((uint64_t)&v72, 3u);
      }
      if (GetBits((uint64_t)&v72, 4u) == 15)
      {
        GetBits((uint64_t)&v72, 8u);
        GetBits((uint64_t)&v72, 8u);
      }
      if (GetBits((uint64_t)&v72, 1u) == 1)
      {
        GetBits((uint64_t)&v72, 2u);
        GetBits((uint64_t)&v72, 1u);
        if (GetBits((uint64_t)&v72, 1u) == 1)
        {
          GetBits((uint64_t)&v72, 0x1Bu);
          GetBits((uint64_t)&v72, 0x1Bu);
          GetBits((uint64_t)&v72, 0x19u);
        }
      }
      v58 = GetBits((uint64_t)&v72, 2u);
      if (v58 == 3 && v57 != 1)
        return 4294954579;
      if (!GetBits((uint64_t)&v72, 1u))
        return 4294954582;
      v60 = GetBits((uint64_t)&v72, 0x10u);
      if (!GetBits((uint64_t)&v72, 1u))
        return 4294954582;
      v61 = 1;
      v62 = GetBits((uint64_t)&v72, 1u);
      if (v60 >= 2)
      {
        do
        {
          ++v61;
          v15 = v60 > 3;
          v60 >>= 1;
        }
        while (v15);
      }
      if (v62)
        GetBits((uint64_t)&v72, v61);
      if (v58 == 2)
        return 4294954579;
      if (v58)
      {
        v66 = 0;
LABEL_194:
        if (GetBits((uint64_t)&v72, 1u) || !GetBits((uint64_t)&v72, 1u))
          return 4294954579;
        v67 = v57 == 1 ? 1 : 2;
        if (GetBits((uint64_t)&v72, v67) || v57 != 1 && v58 && !GetBits((uint64_t)&v72, 1u))
          return 4294954579;
        v68 = GetBits((uint64_t)&v72, 1u);
        result = 4294954579;
        if (v58 == 3 || v68 == 1)
          return result;
        if (GetBits((uint64_t)&v72, 1u) == 1 || v57 != 1 && GetBits((uint64_t)&v72, 1u))
          return 4294954579;
        if (!GetBits((uint64_t)&v72, 1u))
          DefineVOPComplexityEstimationHeader((uint64_t)&v72);
        GetBits((uint64_t)&v72, 1u);
        if (GetBits((uint64_t)&v72, 1u))
          GetBits((uint64_t)&v72, 1u);
        if (v57 != 1 && (GetBits((uint64_t)&v72, 1u) || GetBits((uint64_t)&v72, 1u))
          || GetBits((uint64_t)&v72, 1u))
        {
          return 4294954579;
        }
        if (a5 && (uint64_t)FigCFDictionaryGetCount(v66) >= 1)
        {
          result = 0;
          *a5 = v66;
          return result;
        }
        if (v66)
        {
          v51 = v66;
LABEL_133:
          CFRelease(v51);
        }
        return 0;
      }
      if (!GetBits((uint64_t)&v72, 1u))
        return 4294954582;
      v63 = GetBits((uint64_t)&v72, 0xDu);
      if (!GetBits((uint64_t)&v72, 1u))
        return 4294954582;
      v64 = GetBits((uint64_t)&v72, 0xDu);
      if (!GetBits((uint64_t)&v72, 1u))
        return 4294954582;
      v65 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v65)
      {
        v66 = v65;
        FigCFDictionarySetInt32(v65, CFSTR("VideoWidth"), v63);
        FigCFDictionarySetInt32(v66, CFSTR("VideoHeight"), v64);
        goto LABEL_194;
      }
LABEL_191:
      v59 = 4294954510;
      return FigSignalErrorAt(v59, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t MP4Bridge_ParseMPEG4AudioSpecificConfig(unint64_t a1, unint64_t a2, _WORD *a3, CFMutableDictionaryRef *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  unsigned int Bits;
  unsigned int v10;
  int v11;
  unsigned int v12;
  int v13;
  _BOOL4 v14;
  unsigned int v15;
  BOOL v16;
  int v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v23;
  __int16 v24;
  int v25;
  char v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  _WORD *v32;
  _BOOL4 v33;
  _QWORD v34[2];
  unint64_t v35;
  __int128 v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;

  if (a2 <= 1)
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  v39 = v4;
  v40 = v5;
  v34[0] = a1;
  v34[1] = a2;
  v37 = 0;
  v35 = a1;
  v36 = a1 + a2;
  result = CopyNextWord((uint64_t)v34);
  if (!(_DWORD)result)
  {
    Bits = GetBits((uint64_t)v34, 5u);
    if (Bits == 31)
      Bits = GetBits((uint64_t)v34, 6u) + 32;
    v10 = GetBits((uint64_t)v34, 4u);
    if (v10 == 15)
    {
      v11 = GetBits((uint64_t)v34, 0x18u);
    }
    else
    {
      if (v10 >= 0xD)
      {
LABEL_117:
        v31 = 4294954582;
        return FigSignalErrorAt(v31, 0, 0, 0, 0, 0, 0);
      }
      v11 = sSamplingFrequencies[v10];
    }
    v12 = GetBits((uint64_t)v34, 4u);
    if (!v12)
    {
      v13 = 0;
      goto LABEL_14;
    }
    if (v12 < 0x10 && ((0x8701uLL >> v12) & 1) == 0)
    {
      v13 = MP4Bridge_ParseMPEG4AudioSpecificConfig_sChannelCounts[v12];
LABEL_14:
      v14 = Bits == 29;
      if (Bits == 29 || Bits == 5)
      {
        if (GetBits((uint64_t)v34, 4u) == 15)
          SkipBits((uint64_t)v34, 0x18u);
        v15 = GetBits((uint64_t)v34, 5u);
        if (v15 == 31)
          v15 = GetBits((uint64_t)v34, 6u) + 32;
        if (v15 == 22)
          SkipBits((uint64_t)v34, 4u);
        v16 = 1;
        if (!a4)
          goto LABEL_63;
      }
      else
      {
        v16 = 0;
        v14 = 0;
        v15 = Bits;
        if (!a4)
        {
LABEL_63:
          result = 0;
          if (a3)
            *a3 = v15;
          return result;
        }
      }
      result = 4294954514;
      v33 = v14;
      v32 = a3;
      v17 = 160;
      v18 = 8000;
      v19 = 1;
      switch(v15)
      {
        case 1u:
        case 2u:
        case 3u:
        case 4u:
        case 6u:
        case 7u:
        case 0x11u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
          v38 = 0;
          if ((unsigned __int16)v15 == 23)
            v17 = 512;
          else
            v17 = 1024;
          if (GetBits((uint64_t)v34, 1u) != 1)
            goto LABEL_37;
          if ((unsigned __int16)v15 == 23)
          {
            v17 = 480;
          }
          else if ((unsigned __int16)v15 == 3)
          {
            result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            if ((_DWORD)result)
              return result;
          }
          else
          {
            v17 = 960;
          }
LABEL_37:
          if (GetBits((uint64_t)v34, 1u) == 1)
            SkipBits((uint64_t)v34, 0xEu);
          v20 = GetBits((uint64_t)v34, 1u);
          if (v12)
            goto LABEL_42;
          if ((unsigned __int16)v15 - 5 < 0xFFFFFFFC)
          {
            result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            if ((_DWORD)result)
              return result;
            v17 = 0;
            if (!v13)
              goto LABEL_117;
LABEL_54:
            if ((v15 > 0x17 || ((1 << v15) & 0xA00080) == 0)
              && v35 < (unint64_t)v36
              && (BYTE12(v36) & 7 | (8 * ((_QWORD)v36 - (v37 + v35) + ((unint64_t)HIDWORD(v36) >> 3)))) >= 0xB
              && (unsigned __int16)GetBits((uint64_t)v34, 0xBu) == 695
              && Bits != 5
              && Bits != 29
              && v35 < (unint64_t)v36
              && (BYTE12(v36) & 7 | (8 * ((_QWORD)v36 - (v37 + v35) + ((unint64_t)HIDWORD(v36) >> 3)))) >= 5)
            {
              v24 = GetBits((uint64_t)v34, 5u);
              if (v24 == 31
                && v35 < (unint64_t)v36
                && (BYTE12(v36) & 6 | (8 * ((_QWORD)v36 - (v37 + v35) + ((unint64_t)HIDWORD(v36) >> 3)))) >= 6)
              {
                v24 = GetBits((uint64_t)v34, 6u) + 32;
              }
              if (v24 == 22 || v24 == 5)
              {
                v25 = GetBits((uint64_t)v34, 1u);
                v16 = v25 == 1;
                if (v25 == 1 && GetBits((uint64_t)v34, 4u) == 15)
                  SkipBits((uint64_t)v34, 0x18u);
                if (v24 == 22)
                {
                  if (v15 != 22)
                    goto LABEL_117;
                  SkipBits((uint64_t)v34, 4u);
                }
                else if (v24 == 5
                       && v35 < (unint64_t)v36
                       && (BYTE12(v36) & 4 | (8 * ((_QWORD)v36 - (v37 + v35) + ((unint64_t)HIDWORD(v36) >> 3)))) >= 0xC
                       && (unsigned __int16)GetBits((uint64_t)v34, 0xBu) == 1352)
                {
                  v33 = GetBits((uint64_t)v34, 1u) == 1;
                }
              }
            }
            goto LABEL_56;
          }
          result = MP4Bridge_ParseProgramConfigElement((uint64_t)v34, 0, &v38);
          if ((_DWORD)result)
            return result;
LABEL_42:
          if ((unsigned __int16)v15 == 20 || (unsigned __int16)v15 == 6)
            SkipBits((uint64_t)v34, 3u);
          if (v20 != 1)
            goto LABEL_51;
          if ((unsigned __int16)v15 > 0x17u)
            goto LABEL_50;
          if (((1 << v15) & 0x9A0000) != 0)
          {
            v21 = 3;
          }
          else
          {
            if ((unsigned __int16)v15 != 22)
              goto LABEL_50;
            SkipBits((uint64_t)v34, 5u);
            v21 = 11;
          }
          SkipBits((uint64_t)v34, v21);
LABEL_50:
          SkipBits((uint64_t)v34, 1u);
LABEL_51:
          if (!v12)
            v13 = v38;
          if (!v13)
            goto LABEL_117;
          goto LABEL_54;
        case 9u:
        case 0x19u:
          goto LABEL_57;
        case 0x20u:
        case 0x21u:
        case 0x22u:
          SkipBits((uint64_t)v34, 1u);
          v17 = 0;
          goto LABEL_56;
        case 0x27u:
          if (GetBits((uint64_t)v34, 1u) == 1)
            v17 = 480;
          else
            v17 = 512;
          SkipBits((uint64_t)v34, 3u);
          v26 = GetBits((uint64_t)v34, 1u);
          if (v26)
          {
            v16 = v26;
            GetBits((uint64_t)v34, 1u);
          }
          else
          {
            v16 = 0;
          }
LABEL_56:
          v19 = v13;
          v18 = v11;
          goto LABEL_57;
        case 0x2Au:
          v27 = GetBits((uint64_t)v34, 5u);
          if (v27 == 31)
          {
            v18 = GetBits((uint64_t)v34, 0x18u);
          }
          else
          {
            if (v27 > 0x1B || v27 - 13 < 2)
              goto LABEL_109;
            v18 = MP4Bridge_ParseUSACConfig_sUSACSamplingFrequencies[v27];
          }
          v28 = GetBits((uint64_t)v34, 3u);
          if (v28 > 4)
            goto LABEL_109;
          v17 = MP4Bridge_ParseUSACConfig_sUSACFramesPerPacket[v28];
          v29 = GetBits((uint64_t)v34, 5u);
          if (v29)
          {
            if (v29 > 0xF)
              goto LABEL_109;
            v19 = MP4Bridge_ParseUSACConfig_sUSACChannelCounts[v29];
          }
          else
          {
            v19 = GetBits((uint64_t)v34, 5u);
            if (v19 == 31)
            {
              v30 = GetBits((uint64_t)v34, 0x12u);
              v19 = GetBits((uint64_t)v34, 0x12u) + 31;
              if (v30 == 0x3FFFF)
                v19 += GetBits((uint64_t)v34, 0xDu);
            }
          }
          if (v19)
            goto LABEL_57;
LABEL_109:
          result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
          v17 = 0;
          v19 = v13;
          v18 = v11;
          if ((_DWORD)result)
            return result;
LABEL_57:
          Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          if (!Mutable)
          {
            v31 = 4294954510;
            return FigSignalErrorAt(v31, 0, 0, 0, 0, 0, 0);
          }
          v23 = Mutable;
          FigCFDictionarySetInt32(Mutable, CFSTR("AudioSampleRate"), v18);
          FigCFDictionarySetInt32(v23, CFSTR("AudioChannelCount"), v19);
          FigCFDictionarySetInt32(v23, CFSTR("AudioFramesPerPacket"), v17);
          if (v16)
            FigCFDictionarySetBoolean(v23, CFSTR("SBRIsPresent"), v16);
          a3 = v32;
          if (v33)
            FigCFDictionarySetBoolean(v23, CFSTR("PSIsPresent"), 1);
          *a4 = v23;
          goto LABEL_63;
        default:
          return result;
      }
    }
    goto LABEL_117;
  }
  return result;
}

uint64_t MP4Bridge_ParseMPEGVideoSequenceHeader(unint64_t a1, unint64_t a2, int a3, __CFDictionary **a4)
{
  uint64_t Word;
  int Bits;
  int v8;
  unsigned __int8 v9;
  int v10;
  const __CFAllocator *v11;
  __CFDictionary *Mutable;
  __CFDictionary *v13;
  int v14;
  int v15;
  __int16 v16;
  __int16 v17;
  int v18;
  const void *v19;
  const void **v20;
  int v22;
  const void *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  unsigned int v28;
  __int16 *v29;
  int v30;
  const void *v31;
  const void **v32;
  int v33;
  const void *v34;
  const void **v35;
  CFMutableDictionaryRef v36;
  int v37;
  uint64_t v38;
  char v39;
  uint64_t v40;
  int v41;
  int v42;
  CFMutableDictionaryRef PixelAspectRatioDictionary;
  uint64_t v44;
  _QWORD v45[2];
  unint64_t v46;
  __int128 v47;
  uint64_t v48;

  if (a3)
  {
    if (a2 > 0x15)
      goto LABEL_3;
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  if (a2 <= 0xB)
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_3:
  v45[0] = a1;
  v45[1] = a2;
  v48 = 0;
  v46 = a1;
  v47 = a1 + a2;
  Word = CopyNextWord((uint64_t)v45);
  if ((_DWORD)Word)
    return Word;
  if (GetBits((uint64_t)v45, 0x20u) != 435
    || (Bits = GetBits((uint64_t)v45, 0xCu),
        v8 = GetBits((uint64_t)v45, 0xCu),
        v9 = GetBits((uint64_t)v45, 4u),
        v10 = GetBits((uint64_t)v45, 4u),
        GetBits((uint64_t)v45, 0x12u),
        GetBits((uint64_t)v45, 1u) != 1))
  {
    v44 = 4294954582;
    return FigSignalErrorAt(v44, 0, 0, 0, 0, 0, 0);
  }
  SkipBits((uint64_t)v45, 0xAu);
  GetBits((uint64_t)v45, 1u);
  if (GetBits((uint64_t)v45, 1u))
    SkipBits((uint64_t)v45, 0x200u);
  if (GetBits((uint64_t)v45, 1u))
    SkipBits((uint64_t)v45, 0x200u);
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    v44 = 4294954510;
    return FigSignalErrorAt(v44, 0, 0, 0, 0, 0, 0);
  }
  v13 = Mutable;
  if (a3)
  {
    AdvanceToNextStartCode((uint64_t)v45);
    if (v46 >= (unint64_t)v47)
      goto LABEL_95;
    if ((_QWORD)v47 - (v48 + v46) + ((unint64_t)HIDWORD(v47) >> 3) < 0xA)
      goto LABEL_95;
    if (GetBits((uint64_t)v45, 0x20u) != 437)
      goto LABEL_95;
    if (GetBits((uint64_t)v45, 4u) != 1)
      goto LABEL_95;
    GetBits((uint64_t)v45, 8u);
    GetBits((uint64_t)v45, 1u);
    GetBits((uint64_t)v45, 2u);
    v14 = GetBits((uint64_t)v45, 2u);
    v15 = GetBits((uint64_t)v45, 2u);
    GetBits((uint64_t)v45, 0xCu);
    if (GetBits((uint64_t)v45, 1u) != 1)
      goto LABEL_95;
    Bits |= v14 << 12;
    v8 |= v15 << 12;
    SkipBits((uint64_t)v45, 8u);
    GetBits((uint64_t)v45, 1u);
    GetBits((uint64_t)v45, 2u);
    GetBits((uint64_t)v45, 5u);
    AdvanceToNextStartCode((uint64_t)v45);
    v16 = v8;
    v17 = Bits;
    if (v46 >= (unint64_t)v47
      || (v16 = v8, v17 = Bits, (_QWORD)v47 - (v48 + v46) + ((unint64_t)HIDWORD(v47) >> 3) < 9)
      || (v16 = v8, v17 = Bits, GetBits((uint64_t)v45, 0x20u) != 437)
      || (v16 = v8, v17 = Bits, GetBits((uint64_t)v45, 4u) != 2))
    {
LABEL_86:
      if (v17 != (__int16)Bits || Bits << 16 != 47185920 || (__int16)v8 != v16)
        goto LABEL_99;
      v37 = v8 << 16;
      if (v8 << 16 != 31457280)
      {
        if (v37 == 37748736)
        {
          if (v9 == 2)
          {
            v24 = 54;
            v25 = 59;
            goto LABEL_103;
          }
          if (v9 == 3)
          {
            v24 = 81;
            v25 = 118;
            goto LABEL_103;
          }
          goto LABEL_99;
        }
        if (v37 != 31850496)
          goto LABEL_99;
      }
      if (v9 == 2)
      {
        v24 = 11;
        v25 = 10;
        goto LABEL_103;
      }
      if (v9 == 3)
      {
        v24 = 33;
        v25 = 40;
        goto LABEL_103;
      }
LABEL_99:
      v39 = v9 - 2;
      if ((v9 - 2) > 2u)
      {
        v41 = 0;
        v42 = 0;
      }
      else
      {
        v40 = v39;
        v41 = dword_18EDDD68C[v39];
        v42 = dword_18EDDD698[v40];
      }
      v25 = v42 * v16;
      v24 = v41 * v17;
      goto LABEL_103;
    }
    GetBits((uint64_t)v45, 3u);
    if (!GetBits((uint64_t)v45, 1u))
      goto LABEL_74;
    v18 = GetBits((uint64_t)v45, 8u);
    if (v18 == 6)
    {
      v19 = (const void *)*MEMORY[0x1E0CA8D68];
      v20 = (const void **)MEMORY[0x1E0CA8DA0];
    }
    else
    {
      if (v18 != 1)
      {
        FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_60:
        v30 = GetBits((uint64_t)v45, 8u);
        if (v30 == 7)
        {
          v31 = (const void *)*MEMORY[0x1E0CA8E98];
          v32 = (const void **)MEMORY[0x1E0CA8EC0];
        }
        else
        {
          if (v30 != 1)
          {
            FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            goto LABEL_66;
          }
          v31 = (const void *)*MEMORY[0x1E0CA8E98];
          v32 = (const void **)MEMORY[0x1E0CA8EB0];
        }
        CFDictionarySetValue(v13, v31, *v32);
LABEL_66:
        v33 = GetBits((uint64_t)v45, 8u);
        switch(v33)
        {
          case 7:
            v34 = (const void *)*MEMORY[0x1E0CA8EE8];
            v35 = (const void **)MEMORY[0x1E0CA8F30];
            goto LABEL_72;
          case 6:
            v34 = (const void *)*MEMORY[0x1E0CA8EE8];
            v35 = (const void **)MEMORY[0x1E0CA8F10];
            goto LABEL_72;
          case 1:
            v34 = (const void *)*MEMORY[0x1E0CA8EE8];
            v35 = (const void **)MEMORY[0x1E0CA8F18];
LABEL_72:
            CFDictionarySetValue(v13, v34, *v35);
            goto LABEL_74;
        }
        FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_74:
        v16 = v8;
        v17 = Bits;
        if (v46 >= (unint64_t)v47
          || (v16 = v8, v17 = Bits, (_QWORD)v47 - (v48 + v46) + ((unint64_t)HIDWORD(v47) >> 3) < 4))
        {
LABEL_85:
          GetBits((uint64_t)v45, BYTE12(v47) & 7);
          AdvanceToNextStartCode((uint64_t)v45);
          goto LABEL_86;
        }
        v17 = Bits;
        if (GetBits((uint64_t)v45, 0xEu) < (__int16)Bits)
          v17 = GetBits((uint64_t)v45, 0xEu);
        if (GetBits((uint64_t)v45, 1u) == 1)
        {
          v16 = v8;
          if (GetBits((uint64_t)v45, 0xEu) < (__int16)v8)
            v16 = GetBits((uint64_t)v45, 0xEu);
          if (v17 < (__int16)Bits || v16 < (__int16)v8)
          {
            v36 = CFDictionaryCreateMutable(v11, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            FigCFDictionarySetInt32(v36, (const void *)*MEMORY[0x1E0CA8D60], v17);
            FigCFDictionarySetInt32(v36, (const void *)*MEMORY[0x1E0CA8D40], v16);
            FigCFDictionarySetInt32(v36, (const void *)*MEMORY[0x1E0CA8D48], 0);
            FigCFDictionarySetInt32(v36, (const void *)*MEMORY[0x1E0CA8D58], 0);
            FigCFDictionarySetValue(v13, (const void *)*MEMORY[0x1E0CA8D50], v36);
            if (v36)
              CFRelease(v36);
          }
          goto LABEL_85;
        }
LABEL_95:
        v38 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_109:
        CFRelease(v13);
        return v38;
      }
      v19 = (const void *)*MEMORY[0x1E0CA8D68];
      v20 = (const void **)MEMORY[0x1E0CA8D88];
    }
    CFDictionarySetValue(v13, v19, *v20);
    goto LABEL_60;
  }
  v22 = v10 << 16;
  if (v10 << 16 != 0x40000)
  {
    if (v22 == 196608)
    {
      v23 = (const void *)*MEMORY[0x1E0CA8D78];
      v26 = v8 << 16;
      v27 = Bits << 16;
      if (v8 << 16 == 18874368 && v27 == 23068672)
      {
        v24 = 54;
        v25 = 59;
        if (!v23)
          goto LABEL_103;
        goto LABEL_52;
      }
      if (v26 == 17825792 && v27 == 24117248)
      {
        v24 = 69;
        v25 = 68;
        if (!v23)
          goto LABEL_103;
      }
      else
      {
        if (v26 != 13631488 || v27 != 24117248)
        {
LABEL_41:
          v28 = v9 - 1;
          if (v28 > 0xD)
          {
            v25 = 0;
            v24 = 0;
            if (!v23)
              goto LABEL_103;
          }
          else
          {
            v29 = (__int16 *)((char *)&pixelAspectRatios + 4 * v28);
            v25 = *v29;
            v24 = v29[1];
            if (!v23)
              goto LABEL_103;
          }
          goto LABEL_52;
        }
        v24 = 69;
        v25 = 65;
        if (!v23)
          goto LABEL_103;
      }
LABEL_52:
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8D68], v23);
      CFDictionarySetValue(v13, (const void *)*MEMORY[0x1E0CA8E98], (const void *)*MEMORY[0x1E0CA8EB0]);
      CFDictionarySetValue(v13, (const void *)*MEMORY[0x1E0CA8EE8], (const void *)*MEMORY[0x1E0CA8F10]);
      goto LABEL_103;
    }
    if (v22 != 0x10000)
    {
      v23 = 0;
      goto LABEL_41;
    }
  }
  v23 = (const void *)*MEMORY[0x1E0CA8DA0];
  if ((unsigned __int16)v8 != 240)
    goto LABEL_41;
  if (Bits << 16 == 23068672)
  {
    v24 = 11;
    v25 = 10;
  }
  else
  {
    if (Bits << 16 != 25165824)
      goto LABEL_41;
    v24 = 6;
    v25 = 5;
    if (v9 != 1 && v9 != 14)
      goto LABEL_41;
  }
  if (v23)
    goto LABEL_52;
LABEL_103:
  FigCFDictionarySetInt16(v13, CFSTR("VideoWidth"), Bits);
  FigCFDictionarySetInt16(v13, CFSTR("VideoHeight"), v8);
  if (v25 >= 1 && v24 >= 1)
  {
    PixelAspectRatioDictionary = createPixelAspectRatioDictionary(v11, v25, v24);
    FigCFDictionarySetValue(v13, (const void *)*MEMORY[0x1E0CA8E68], PixelAspectRatioDictionary);
    if (PixelAspectRatioDictionary)
      CFRelease(PixelAspectRatioDictionary);
  }
  v38 = 0;
  if (!a4)
    goto LABEL_109;
  *a4 = v13;
  return v38;
}

uint64_t FigMP4BridgeCreateRFC6381CodecString(OpaqueCMBlockBuffer *a1, int a2, int a3, uint64_t a4, __CFString **a5)
{
  uint64_t CurrentAtomTypeAndDataLength;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  unsigned __int16 v14;
  int v15;
  const __CFString *CFStringForOSTypeValue;
  int v17;
  uint64_t v18;
  size_t v19;
  unint64_t v20;
  uint64_t v21;
  __CFDictionary **v22;
  CFStringRef v23;
  uint64_t v24;
  char v25;
  char v26;
  unsigned __int8 v27;
  unsigned __int16 v28;
  unsigned __int16 v29;
  int v30;
  char v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  uint64_t v34;
  uint64_t Word;
  unsigned __int8 Bits;
  uint64_t v37;
  unsigned int v38;
  int v40;
  int v41;
  unsigned __int8 v42;
  int v43;
  int i;
  unint64_t v45;
  __int16 v46;
  int v47;
  int j;
  unint64_t v49;
  unsigned int v50;
  __CFString *v51;
  CFStringRef v52;
  __CFString *MutableCopy;
  __CFString *v54;
  char *dataPointerOut;
  int64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  _OWORD v61[7];
  unint64_t v62;
  int v63;
  _BYTE v64[124];
  unsigned __int16 v65;
  unsigned __int8 v66;
  const __CFDictionary *v67;
  int v68;
  int v69;
  char *v70;
  __int128 v71;
  uint64_t v72;

  memset(v64, 0, 112);
  v63 = 0;
  v62 = 0;
  memset(v61, 0, sizeof(v61));
  v60 = 0;
  v58 = 0;
  v59 = 0;
  dataPointerOut = 0;
  v57 = 0;
  *a5 = 0;
  CurrentAtomTypeAndDataLength = FigAtomStreamInitWithBBuf(a1, 0, 1, (uint64_t)v64);
  if ((_DWORD)CurrentAtomTypeAndDataLength)
    return CurrentAtomTypeAndDataLength;
  CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v64, &v63, &v62);
  if ((_DWORD)CurrentAtomTypeAndDataLength)
    return CurrentAtomTypeAndDataLength;
  v10 = v63;
  if (v63 == 1633777252 || v63 == 1701733217 || v63 == 1685220723)
  {
    if (a3 > 1885692722)
    {
      if (a3 > 1903522656)
      {
        if (a3 > 2053202791)
        {
          if (a3 > 2053464882)
          {
            if (a3 == 2053464883)
              goto LABEL_81;
            v12 = 2054517601;
          }
          else
          {
            if (a3 == 2053202792)
              goto LABEL_60;
            v12 = 2053202800;
          }
          goto LABEL_59;
        }
        if (a3 <= 2053202274)
        {
          if (a3 == 1903522657)
            goto LABEL_60;
          v12 = 1970495843;
          goto LABEL_59;
        }
        if (a3 == 2053202275)
          goto LABEL_60;
        v11 = 2053202739;
      }
      else
      {
        if (a3 > 1902207847)
        {
          if (a3 <= 1902211170)
          {
            if (a3 == 1902207848)
              goto LABEL_60;
            v12 = 1902207856;
            goto LABEL_59;
          }
          if (a3 == 1902211171)
            goto LABEL_54;
          v13 = 1902469939;
LABEL_52:
          if (a3 == v13)
            goto LABEL_81;
          goto LABEL_61;
        }
        if (a3 <= 1902207330)
        {
          if (a3 == 1885692723)
            goto LABEL_81;
          v12 = 1886745441;
          goto LABEL_59;
        }
        if (a3 == 1902207331)
          goto LABEL_60;
        v11 = 1902207795;
      }
    }
    else
    {
      if (a3 <= 1667330146)
      {
        if (a3 <= 1667326306)
        {
          if (a3 <= 1634754914)
          {
            if (a3 != 1633771875)
            {
              v11 = 1633889587;
              goto LABEL_46;
            }
LABEL_60:
            v10 = 1836069985;
            goto LABEL_82;
          }
          if (a3 != 1634754915)
          {
            v14 = 11571;
LABEL_39:
            v11 = v14 | 0x63610000;
            goto LABEL_46;
          }
LABEL_54:
          v10 = 1634754915;
          goto LABEL_82;
        }
        if (a3 <= 1667326823)
        {
          if (a3 == 1667326307)
            goto LABEL_60;
          v14 = 25395;
          goto LABEL_39;
        }
        if (a3 == 1667326824)
          goto LABEL_60;
        v12 = 1667326832;
LABEL_59:
        if (a3 != v12)
        {
LABEL_61:
          if (a3 <= 1718378850)
          {
            if (a3 > 1667656802)
            {
              if (a3 == 1667656803)
                goto LABEL_77;
              if (a3 == 1668047203)
                goto LABEL_192;
              v15 = 1700997939;
            }
            else
            {
              if (a3 == 1633889588)
              {
                v10 = 1633889588;
                goto LABEL_82;
              }
              if (a3 == 1634492771)
                goto LABEL_192;
              v15 = 1667574579;
            }
            goto LABEL_80;
          }
          if (a3 > 1902537826)
          {
            if (a3 <= 2053319474)
            {
              if (a3 != 1902537827)
              {
                if (a3 != 1902928227)
                  goto LABEL_83;
LABEL_192:
                v10 = 1634492771;
                goto LABEL_82;
              }
LABEL_77:
              v10 = 1716281667;
              goto LABEL_82;
            }
            if (a3 == 2053923171)
              goto LABEL_192;
            v15 = 2053319475;
            goto LABEL_80;
          }
          if (a3 == 1718378851)
            goto LABEL_77;
          if (a3 != 1885547315)
          {
            v15 = 1902324531;
LABEL_80:
            if (a3 != v15)
              goto LABEL_83;
          }
LABEL_81:
          v10 = 1700998451;
          goto LABEL_82;
        }
        goto LABEL_60;
      }
      if (a3 <= 1885430114)
      {
        if (a3 > 1668641632)
        {
          if (a3 == 1668641633)
            goto LABEL_60;
          v13 = 1700998451;
        }
        else
        {
          if (a3 == 1667330147)
            goto LABEL_54;
          v13 = 1667575091;
        }
        goto LABEL_52;
      }
      if (a3 > 1885430631)
      {
        if (a3 == 1885430632)
          goto LABEL_60;
        v12 = 1885430640;
        goto LABEL_59;
      }
      if (a3 == 1885430115)
        goto LABEL_60;
      v11 = 1885430579;
    }
LABEL_46:
    if (a3 == v11)
    {
      v10 = 1633889587;
LABEL_82:
      v63 = v10;
      goto LABEL_83;
    }
    goto LABEL_61;
  }
LABEL_83:
  CFStringForOSTypeValue = FigGetCFStringForOSTypeValue(v10);
  if (v63 <= 1835560240)
  {
    if ((v63 - 1835557169) >= 2)
    {
      if (v63 != 1633889588)
        goto LABEL_180;
      v17 = 1684103988;
LABEL_92:
      if (a2 == 1936684398)
      {
        v18 = 28;
      }
      else
      {
        if (a2 != 1986618469)
          return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
        v18 = 78;
      }
      if (v62 <= v18 + 8)
        return 4294954580;
      CurrentAtomTypeAndDataLength = FigAtomStreamInitWithParent((uint64_t)v64, v18, (uint64_t)v61);
      if ((_DWORD)CurrentAtomTypeAndDataLength)
        return CurrentAtomTypeAndDataLength;
      while (v60 != v17)
      {
        CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v61, &v60, &v59);
        if ((_DWORD)CurrentAtomTypeAndDataLength)
          return CurrentAtomTypeAndDataLength;
      }
      CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomGlobalOffset(v61, &v58, &v57);
      if ((_DWORD)CurrentAtomTypeAndDataLength)
        return CurrentAtomTypeAndDataLength;
      if (v57 < v59)
        return 4294954580;
      v19 = v58 + v57;
      if (v19 > CMBlockBufferGetDataLength(a1))
        return 4294954580;
      CurrentAtomTypeAndDataLength = CMBlockBufferGetDataPointer(a1, 0, 0, 0, &dataPointerOut);
      if (!(_DWORD)CurrentAtomTypeAndDataLength)
      {
        v20 = v59;
        v21 = v57 - v59 + v58;
        if (v17 != 1684103988)
        {
          if (v17 != 1835557187)
          {
            v67 = 0;
            v66 = 0;
            v65 = 0;
            v22 = &v67;
            if (a3 != 1633772320 && a3 != 1633772392 && a3 != 1633772400)
              v22 = 0;
            if (FigMP4Bridge_GetESDSObjectTypeAndCopyDecoderSpecificInfo((unint64_t)&dataPointerOut[v21], v59, (char *)&v66, &v65, v22))
            {
              v23 = 0;
LABEL_196:
              v24 = 0;
LABEL_197:
              if (v67)
                CFRelease(v67);
              if (!(_DWORD)v24)
              {
LABEL_200:
                if (!v23)
                  goto LABEL_180;
LABEL_201:
                MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFStringForOSTypeValue);
                if (MutableCopy)
                {
                  v54 = MutableCopy;
                  CFStringAppendFormat(MutableCopy, 0, CFSTR(".%@"), v23);
                  v24 = 0;
                  *a5 = v54;
                }
                else
                {
                  v24 = 4294954583;
                }
LABEL_203:
                CFRelease(v23);
                return v24;
              }
LABEL_129:
              if (!v23)
                return v24;
              goto LABEL_203;
            }
            v37 = v65;
            if (v66 != 64)
            {
              if ((v66 & 0xFD) == 0x69 && v65)
                v52 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%X.%u"), v66, v65);
              else
                v52 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%X"), v66);
              goto LABEL_195;
            }
            if (v65 > 4u)
            {
              if (v65 != 5 && v65 != 29)
              {
LABEL_194:
                v52 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("40.%u"), v37);
LABEL_195:
                v23 = v52;
                goto LABEL_196;
              }
            }
            else if (v65)
            {
              if (v65 == 2)
              {
                if (FigCFDictionaryGetBooleanValue(v67, CFSTR("SBRIsPresent")))
                  v65 = 5;
                if (FigCFDictionaryGetBooleanValue(v67, CFSTR("PSIsPresent")))
                {
                  v37 = 29;
                  v65 = 29;
                }
                else
                {
                  v37 = v65;
                }
              }
              goto LABEL_194;
            }
            v24 = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
            v23 = 0;
            if ((_DWORD)v24)
              goto LABEL_197;
            goto LABEL_196;
          }
          if ((unint64_t)v59 > 4)
          {
            v69 = 0;
            v71 = 0u;
            v72 = 0;
            v67 = (const __CFDictionary *)&dataPointerOut[v21];
            v68 = v59;
            v70 = &dataPointerOut[v21];
            *(_QWORD *)&v71 = &dataPointerOut[v21 + v59];
            Word = CopyNextWord((uint64_t)&v67);
            if ((_DWORD)Word)
              goto LABEL_210;
            if (GetBits((uint64_t)&v67, 8u) == 1)
            {
              Bits = GetBits((uint64_t)&v67, 8u);
              SkipBits((uint64_t)&v67, 8u);
              if (v20 >= (unsigned __int16)GetBits((uint64_t)&v67, 0x10u) + 5)
              {
                v23 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%02X"), Bits);
                goto LABEL_200;
              }
            }
          }
          Word = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
LABEL_210:
          v24 = Word;
          v23 = 0;
          if (!(_DWORD)Word)
            goto LABEL_200;
          goto LABEL_129;
        }
        v69 = 0;
        v71 = 0u;
        v72 = 0;
        v67 = (const __CFDictionary *)&dataPointerOut[v21];
        v68 = v59;
        v70 = &dataPointerOut[v21];
        *(_QWORD *)&v71 = &dataPointerOut[v21 + v59];
        if (CopyNextWord((uint64_t)&v67))
          goto LABEL_180;
        v25 = GetBits((uint64_t)&v67, 3u);
        if ((v25 & 0xFE) != 0)
          goto LABEL_207;
        v26 = v25;
        v27 = GetBits((uint64_t)&v67, 7u);
        SkipBits((uint64_t)&v67, 5u);
        v28 = GetBits((uint64_t)&v67, 9u);
        v29 = v28;
        if (v26 == 1)
        {
          if ((v27 & 0xFE) != 0 && GetBits((uint64_t)&v67, 1u) == 1)
          {
            SkipBits((uint64_t)&v67, 0x10u);
            if (GetBits((uint64_t)&v67, 1u) == 1)
            {
              v38 = 0;
              do
                SkipBits((uint64_t)&v67, 8u);
              while (v38++ < 0xF);
            }
          }
          SkipBits((uint64_t)&v67, 2u);
          SkipBits((uint64_t)&v67, 0x20u);
          SkipBits((uint64_t)&v67, 0x20u);
          GetBits((uint64_t)&v67, BYTE12(v71) & 7);
          v40 = v29;
          if (v29)
          {
            v41 = 0;
            while (1)
            {
              v42 = GetBits((uint64_t)&v67, 8u);
              if (v42 >= 3u)
                goto LABEL_207;
              v33 = v42;
              v43 = GetBits((uint64_t)&v67, 8u);
              if (v43 == 255)
                v43 = GetBits((uint64_t)&v67, 0x10u) + 255;
              if (GetBits((uint64_t)&v67, 5u) != 6)
                goto LABEL_123;
              for (i = GetBits((uint64_t)&v67, 7u); i; --i)
                SkipBits((uint64_t)&v67, 0xFu);
              if (v33)
              {
                if (v33 == 1)
                {
                  if ((unint64_t)v70 >= (unint64_t)v71)
                    v45 = 0;
                  else
                    v45 = BYTE12(v71) & 7 | (8 * (v71 - (_QWORD)&v70[v72] + ((unint64_t)HIDWORD(v71) >> 3)));
                  if (GetBits((uint64_t)&v67, 1u) == 1)
                  {
                    SkipBits((uint64_t)&v67, 2u);
                    SkipBits((uint64_t)&v67, 0x20u);
                    SkipBits((uint64_t)&v67, 0x20u);
                  }
                  if (GetBits((uint64_t)&v67, 1u) == 1)
                  {
                    GetBits((uint64_t)&v67, BYTE12(v71) & 7);
                    v46 = GetBits((uint64_t)&v67, 0x10u);
                    if (v46)
                    {
                      LOWORD(v47) = v46;
                      do
                      {
                        SkipBits((uint64_t)&v67, 8u);
                        v47 = (unsigned __int16)v47 + 1;
                      }
                      while ((v47 & 0x10000) == 0);
                    }
                    for (j = GetBits((uint64_t)&v67, 5u); j; --j)
                      SkipBits((uint64_t)&v67, 0xBu);
                  }
                  GetBits((uint64_t)&v67, BYTE12(v71) & 7);
                  if ((unint64_t)v70 >= (unint64_t)v71)
                    v49 = 0;
                  else
                    v49 = BYTE12(v71) & 7 | (8 * (v71 - (_QWORD)&v70[v72] + ((unint64_t)HIDWORD(v71) >> 3)));
                  if (v45 - v49 <= (8 * v43 - 8))
                  {
                    SkipBits((uint64_t)&v67, 6u);
                    if (GetBits((uint64_t)&v67, 1u) == 1)
                      v50 = 9;
                    else
                      v50 = 1;
                    SkipBits((uint64_t)&v67, v50);
                  }
                }
              }
              else
              {
                GetBits((uint64_t)&v67, BYTE12(v71) & 7);
              }
              if (++v41 == v40)
                goto LABEL_178;
            }
          }
        }
        else if (!v26 && v28)
        {
          v30 = GetBits((uint64_t)&v67, 1u);
          v31 = GetBits((uint64_t)&v67, 5u);
          v32 = GetBits((uint64_t)&v67, 5u);
          if (v32 < 3u)
          {
            v33 = v32;
            if (v30 == 1 || v31 != 6)
            {
LABEL_123:
              v34 = GetBits((uint64_t)&v67, 3u);
              goto LABEL_179;
            }
          }
LABEL_207:
          FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
          goto LABEL_180;
        }
        v33 = 0;
LABEL_178:
        v34 = 0;
LABEL_179:
        v23 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%02X.%02X.%02X"), v27, v33, v34);
        if (!v23)
          goto LABEL_180;
        goto LABEL_201;
      }
      return CurrentAtomTypeAndDataLength;
    }
LABEL_89:
    v17 = 1835557187;
    goto LABEL_92;
  }
  if ((v63 - 1835560241) < 2)
    goto LABEL_89;
  v17 = 1702061171;
  if (v63 == 1836069985 || v63 == 1836070006)
    goto LABEL_92;
LABEL_180:
  if (CFStringForOSTypeValue)
    v51 = (__CFString *)CFRetain(CFStringForOSTypeValue);
  else
    v51 = 0;
  v24 = 0;
  *a5 = v51;
  return v24;
}

uint64_t GetBERInteger(uint64_t a1, unint64_t *a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char Bits;
  uint64_t v8;

  v3 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 24);
  if (v3 >= v4)
  {
    v6 = 0;
  }
  else
  {
    v6 = 0;
    Bits = 0x80;
    v8 = 5;
    while ((v4 - v3 > 4 || *(_DWORD *)(a1 + 36)) && Bits < 0)
    {
      if (!--v8)
      {
        FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
        return 0;
      }
      Bits = GetBits(a1, 8u);
      v6 = Bits & 0x7F | (v6 << 7);
      v3 = *(_QWORD *)(a1 + 16);
      v4 = *(_QWORD *)(a1 + 24);
      if (v3 >= v4)
        break;
    }
  }
  *a2 = v6;
  return 1;
}

uint64_t SkipBits(uint64_t result, unsigned int a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v5;
  unsigned int v6;

  v2 = *(_QWORD *)(result + 16);
  v3 = *(_QWORD *)(result + 24);
  if (v2 < v3)
  {
    v5 = result;
    do
    {
      if (v3 - v2 <= 4 && !*(_DWORD *)(v5 + 36))
        break;
      if (!a2)
        break;
      v6 = a2 >= 4 ? 4 : a2;
      result = GetBits(v5, v6);
      a2 -= v6;
      v2 = *(_QWORD *)(v5 + 16);
      v3 = *(_QWORD *)(v5 + 24);
    }
    while (v2 < v3);
  }
  return result;
}

uint64_t CopyNextWord(uint64_t a1)
{
  _BYTE *v2;
  _BYTE *v3;
  size_t v4;
  uint64_t result;
  unsigned int v7;

  v2 = *(_BYTE **)(a1 + 16);
  v3 = *(_BYTE **)(a1 + 24);
  v4 = v3 - v2;
  if (v3 <= v2 || v3 == v2)
  {
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    return 4294954584;
  }
  else
  {
    if (v4 > 3)
      v4 = 4;
    else
      *(_DWORD *)(a1 + 32) = 0;
    memcpy((void *)(a1 + 32), v2, v4);
    v7 = bswap32(*(_DWORD *)(a1 + 32));
    *(_DWORD *)(a1 + 32) = v7;
    *(_DWORD *)(a1 + 36) = 8 * v4;
    if (v4 <= 3)
      *(_DWORD *)(a1 + 32) = v7 >> (-8 * v4);
    result = 0;
    *(_QWORD *)(a1 + 40) = v4;
  }
  return result;
}

uint64_t EatUserData(uint64_t a1)
{
  uint64_t v2;

  v2 = 4294954582;
  if (GetBits(a1, 0x20u) == 434)
  {
    if (AdvanceToNextStartCode(a1) == 1)
      return 0;
    else
      return 4294954582;
  }
  return v2;
}

uint64_t AdvanceToNextStartCode(uint64_t a1)
{
  uint64_t i;
  uint64_t result;
  unint64_t v3;
  unint64_t v4;

  for (i = a1; ; a1 = i)
  {
    result = PeekBits(a1, 0x18u);
    if ((_DWORD)result == 1)
      break;
    v3 = *(_QWORD *)(i + 16);
    v4 = *(_QWORD *)(i + 24);
    if (v3 >= v4 || v4 - v3 <= 4 && !*(_DWORD *)(i + 36))
      break;
    GetBits(i, 8u);
  }
  return result;
}

uint64_t DefineVOPComplexityEstimationHeader(uint64_t a1)
{
  uint64_t result;
  int v3;

  result = GetBits(a1, 2u);
  if (result <= 1)
  {
    v3 = result;
    if (!GetBits(a1, 1u))
      GetBits(a1, 6u);
    if (!GetBits(a1, 1u))
      GetBits(a1, 4u);
    GetBits(a1, 1u);
    if (!GetBits(a1, 1u))
      GetBits(a1, 4u);
    if (!GetBits(a1, 1u))
      GetBits(a1, 6u);
    result = GetBits(a1, 1u);
    if (v3 == 1)
    {
      result = GetBits(a1, 1u);
      if (!(_DWORD)result)
        return GetBits(a1, 2u);
    }
  }
  return result;
}

CFMutableDictionaryRef createPixelAspectRatioDictionary(const __CFAllocator *a1, int a2, int a3)
{
  CFMutableDictionaryRef Mutable;

  Mutable = CFDictionaryCreateMutable(a1, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetInt32(Mutable, (const void *)*MEMORY[0x1E0CA8E60], a2);
  FigCFDictionarySetInt32(Mutable, (const void *)*MEMORY[0x1E0CA8E70], a3);
  return Mutable;
}

uint64_t MP4Bridge_ParseProgramConfigElement(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int Bits;
  unsigned __int8 v7;
  int v8;
  int v9;
  int v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  _DWORD *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int i;
  int v24;
  _DWORD *v25;

  SkipBits(a1, 4u);
  SkipBits(a1, 2u);
  Bits = GetBits(a1, 4u);
  if (Bits >= 0xD)
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  v25 = a2;
  v24 = sSamplingFrequencies[Bits];
  v7 = GetBits(a1, 4u);
  LOBYTE(v8) = GetBits(a1, 4u);
  LOBYTE(v9) = GetBits(a1, 4u);
  LOBYTE(v10) = GetBits(a1, 2u);
  v11 = GetBits(a1, 3u);
  v12 = GetBits(a1, 4u);
  if (GetBits(a1, 1u) == 1)
    SkipBits(a1, 4u);
  if (GetBits(a1, 1u) == 1)
    SkipBits(a1, 4u);
  if (GetBits(a1, 1u) == 1)
  {
    SkipBits(a1, 2u);
    SkipBits(a1, 1u);
  }
  v13 = a3;
  v14 = v7;
  if (v7)
  {
    v15 = 0;
    do
    {
      if (GetBits(a1, 1u) == 1)
        v16 = 2;
      else
        v16 = 1;
      v15 += v16;
      SkipBits(a1, 4u);
      --v14;
    }
    while (v14);
  }
  else
  {
    v15 = 0;
  }
  v8 = v8;
  if ((_BYTE)v8)
  {
    do
    {
      if (GetBits(a1, 1u) == 1)
        v17 = 2;
      else
        v17 = 1;
      v15 += v17;
      SkipBits(a1, 4u);
      --v8;
    }
    while (v8);
  }
  v9 = v9;
  if ((_BYTE)v9)
  {
    do
    {
      if (GetBits(a1, 1u) == 1)
        v18 = 2;
      else
        v18 = 1;
      v15 += v18;
      SkipBits(a1, 4u);
      --v9;
    }
    while (v9);
  }
  v19 = v10;
  if ((_BYTE)v10)
  {
    v10 = v10;
    do
    {
      SkipBits(a1, 4u);
      --v10;
    }
    while (v10);
    v15 += v19;
  }
  v20 = v11;
  if (v11)
  {
    do
    {
      SkipBits(a1, 4u);
      --v20;
    }
    while (v20);
  }
  v21 = v12;
  if (v12)
  {
    do
    {
      SkipBits(a1, 1u);
      SkipBits(a1, 4u);
      --v21;
    }
    while (v21);
  }
  GetBits(a1, *(_DWORD *)(a1 + 36) & 7);
  for (i = GetBits(a1, 8u); i; --i)
    SkipBits(a1, 8u);
  if (v25)
    *v25 = v24;
  if (v13)
    *v13 = v15;
  return 0;
}

uint64_t FigTransportConnectionXPCClientCreate(uint64_t a1, _QWORD *a2)
{
  CFTypeRef v3;

  if (ntcxpc_getConnectionShared_once != -1)
    dispatch_once(&ntcxpc_getConnectionShared_once, &__block_literal_global_24);
  if (ntcxpc_getConnectionShared_transportConnection)
  {
    v3 = CFRetain((CFTypeRef)ntcxpc_getConnectionShared_transportConnection);
    *a2 = v3;
    if (v3)
      return 0;
  }
  else
  {
    *a2 = 0;
  }
  return 4294955245;
}

void __ntcxpc_getConnectionShared_block_invoke()
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v1;
  uint64_t v2;
  unsigned int v3;
  char *v4;
  uint64_t v5;
  _QWORD *ClassID;
  _QWORD *DerivedStorage;
  os_log_type_t type;
  int v9[2];
  const char *v10;
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v9[0] = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v9, &type);
  v1 = v9[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v3 = v1;
  else
    v3 = v1 & 0xFFFFFFFE;
  if (v3)
  {
    v9[1] = 136315138;
    v10 = "ntcxpc_getConnectionShared_block_invoke";
    v4 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v1) = v9[0];
  }
  else
  {
    v4 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v4, v4 != &v11, v1, 0, v2);
  v5 = *MEMORY[0x1E0C9AE00];
  ClassID = (_QWORD *)NeroTransportConnectionGetClassID();
  if (!CMDerivedObjectCreate(v5, (uint64_t)&kFigTransportConnectionXPCVTable, ClassID, &ntcxpc_getConnectionShared_transportConnection))
  {
    DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(ntcxpc_getConnectionShared_transportConnection);
    if (ntcxpc_getClient_once != -1)
      dispatch_once(&ntcxpc_getClient_once, &__block_literal_global_7_0);
    *DerivedStorage = ntcxpc_getClient_client;
    ntcxpc_initTransportConnection(ntcxpc_getConnectionShared_transportConnection);
  }
}

void ntcxpc_initTransportConnection(uint64_t a1)
{
  uint64_t *DerivedStorage;
  int v2;
  xpc_object_t v3;
  xpc_object_t v4;
  xpc_object_t v5;

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  v4 = 0;
  v5 = 0;
  v2 = FigXPCCreateBasicMessage(0x696E6974u, 0, &v5);
  v3 = 0;
  if (!v2)
  {
    FigXPCRemoteClientSendSyncMessageCreatingReply(*DerivedStorage, (uint64_t)v5, &v4);
    v3 = v4;
  }
  FigXPCRelease(v3);
  FigXPCRelease(v5);
}

uint64_t ntcxpc_Invalidate()
{
  return 4294954514;
}

void ntcxpc_Finalize()
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v1;
  uint64_t v2;
  unsigned int v3;
  char *v4;
  char v5;
  os_log_type_t v6;
  int v7;

  v7 = 0;
  v6 = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v7, &v6);
  v1 = v7;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, v6))
    v3 = v1;
  else
    v3 = v1 & 0xFFFFFFFE;
  if (v3)
  {
    v4 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v1) = v7;
  }
  else
  {
    v4 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v4, v4 != &v5, v1, 0, v2);
  __break(1u);
}

__CFString *ntcxpc_CopyDebugDescription(uint64_t a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigTransportConnectionXPC %p>"), a1);
  return Mutable;
}

uint64_t ntcxpc_CopyProperty()
{
  return 4294954514;
}

uint64_t ntcxpc_SetProperty()
{
  return 0;
}

uint64_t ntcxpc_SetEventHandler(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  const void *v6;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!*(_BYTE *)(DerivedStorage + 16))
  {
    v5 = DerivedStorage;
    if (a3)
      a3 = _Block_copy(a3);
    v6 = *(const void **)(v5 + 8);
    if (v6)
      _Block_release(v6);
    *(_QWORD *)(v5 + 8) = a3;
  }
  return 0;
}

uint64_t ntcxpc_Start()
{
  return 0;
}

uint64_t ntcxpc_Stop()
{
  return 0;
}

uint64_t ntcxpc_EnqueuePackageWithPriority(uint64_t a1, unsigned int *a2, CMBlockBufferRef theBuffer, int a4)
{
  size_t DataLength;
  uint64_t DerivedStorage;
  uint64_t *v10;
  uint64_t v11;
  xpc_object_t v12;
  xpc_object_t xdict;

  xdict = 0;
  if (theBuffer)
    DataLength = CMBlockBufferGetDataLength(theBuffer);
  else
    DataLength = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)(DerivedStorage + 16))
  {
    v12 = 0;
    v11 = 0;
  }
  else if (DataLength >= *a2)
  {
    v12 = 0;
    v11 = 4294954516;
  }
  else
  {
    v10 = (uint64_t *)DerivedStorage;
    v11 = FigXPCCreateBasicMessage(0x656E7175u, 0, &xdict);
    v12 = xdict;
    if (!(_DWORD)v11)
    {
      xpc_dictionary_set_data(xdict, "enqueuePkgHeader", a2, *a2 - DataLength);
      v11 = FigXPCMessageSetBlockBuffer(xdict, "enqueuePackage", theBuffer);
      v12 = xdict;
      if (!(_DWORD)v11)
      {
        xpc_dictionary_set_int64(xdict, "enqueuePriority", a4);
        v11 = FigXPCRemoteClientSendSyncMessage(*v10, (uint64_t)xdict);
        v12 = xdict;
      }
    }
  }
  FigXPCRelease(v12);
  return v11;
}

uint64_t ntcxpc_FlushPendingPackagesWithPriority(uint64_t a1, int a2)
{
  uint64_t DerivedStorage;
  uint64_t *v4;
  uint64_t v5;
  xpc_object_t v6;
  xpc_object_t xdict;

  xdict = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)(DerivedStorage + 16))
  {
    v6 = 0;
    v5 = 0;
  }
  else
  {
    v4 = (uint64_t *)DerivedStorage;
    v5 = FigXPCCreateBasicMessage(0x666C7368u, 0, &xdict);
    v6 = xdict;
    if (!(_DWORD)v5)
    {
      xpc_dictionary_set_int64(xdict, "flushPendingPackage", a2);
      v5 = FigXPCRemoteClientSendSyncMessage(*v4, (uint64_t)xdict);
      v6 = xdict;
    }
  }
  FigXPCRelease(v6);
  return v5;
}

void __ntcxpc_getClient_block_invoke()
{
  __CFDictionary *Mutable;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v2;
  uint64_t v3;
  unsigned int v4;
  _BYTE *v5;
  int v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  _BYTE *v11;
  os_log_type_t type;
  int v13;
  int v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  _BYTE v18[128];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v13 = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v13, &type);
  v2 = v13;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v4 = v2;
  else
    v4 = v2 & 0xFFFFFFFE;
  if (v4)
  {
    v14 = 136315394;
    v15 = "ntcxpc_getClient_block_invoke";
    v16 = 2080;
    v17 = "com.apple.coremedia.nerotransportconnectionxpc";
    v5 = (_BYTE *)_os_log_send_and_compose_impl();
    LOBYTE(v2) = v13;
  }
  else
  {
    v5 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v5, v5 != v18, v2, 0, v3);
  CFDictionarySetValue(Mutable, CFSTR("xpcRemoteClientOption_DeathNoticeName"), CFSTR("FigTransportNTCXPCServerDied"));
  FigCFDictionarySetInt32(Mutable, CFSTR("xpcRemoteClientOption_QueuePriority"), 28);
  v6 = FigXPCRemoteClientCreate((uint64_t)"com.apple.coremedia.nerotransportconnectionxpc", (uint64_t)&kFigTransportConnectionXPC_FigTransportConnectionClass_block_invoke_clientCallbacks, Mutable, &ntcxpc_getClient_client);
  if (Mutable)
    CFRelease(Mutable);
  if (v6)
  {
    v13 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    v7 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, &v13, &type);
    v8 = v13;
    if (os_log_type_enabled(v7, type))
      v10 = v8;
    else
      v10 = v8 & 0xFFFFFFFE;
    if (v10)
    {
      v14 = 136315394;
      v15 = "ntcxpc_getClient_block_invoke";
      v16 = 1024;
      LODWORD(v17) = v6;
      v11 = (_BYTE *)_os_log_send_and_compose_impl();
      LOBYTE(v8) = v13;
    }
    else
    {
      v11 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v11, v11 != v18, v8, 0, v9);
  }
}

void ntcxpc_handleServerDeath()
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v1;
  uint64_t v2;
  unsigned int v3;
  char *v4;
  os_log_type_t type;
  int v6[2];
  const char *v7;
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v6[0] = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v6, &type);
  v1 = v6[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v3 = v1;
  else
    v3 = v1 & 0xFFFFFFFE;
  if (v3)
  {
    v6[1] = 136315138;
    v7 = "ntcxpc_handleServerDeath";
    v4 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v1) = v6[0];
  }
  else
  {
    v4 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v4, v4 != &v8, v1, 0, v2);
  if (ntcxpc_getConnectionShared_once != -1)
    dispatch_once(&ntcxpc_getConnectionShared_once, &__block_literal_global_24);
  ntcxpc_initTransportConnection(ntcxpc_getConnectionShared_transportConnection);
}

uint64_t ntcxpc_handleServerMessage(void *a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t DerivedStorage;
  uint64_t v5;
  int64_t int64;
  uint64_t v7;
  int v8;
  CFTypeRef cf;

  if (ntcxpc_getConnectionShared_once != -1)
    dispatch_once(&ntcxpc_getConnectionShared_once, &__block_literal_global_24);
  v2 = ntcxpc_getConnectionShared_transportConnection;
  v8 = 0;
  result = FigXPCMessageGetOpCode(a1, &v8);
  if (!(_DWORD)result)
  {
    if (v8 == 1701671783)
    {
      cf = 0;
      DerivedStorage = CMBaseObjectGetDerivedStorage(v2);
      if (!*(_BYTE *)(DerivedStorage + 16))
      {
        v5 = DerivedStorage;
        int64 = xpc_dictionary_get_int64(a1, (const char *)kNeroTransportConnectionEventHandler_Type);
        if (!FigXPCMessageCreateBlockBufferData((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a1, (char *)kNeroTransportConnectionEventHandler_BBuf, (CMBlockBufferRef *)&cf))
        {
          v7 = *(_QWORD *)(v5 + 8);
          if (v7)
            (*(void (**)(uint64_t, int64_t, CFTypeRef))(v7 + 16))(v7, int64, cf);
        }
        if (cf)
          CFRelease(cf);
      }
      return 0;
    }
    else
    {
      return 4294954516;
    }
  }
  return result;
}

void FigEnableCustomAllocatorsOnDaemonStartup()
{
  figCustomAllocatorsInit(1);
}

void figCustomAllocatorsInit(char a1)
{
  _QWORD block[4];
  char v2;

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __figCustomAllocatorsInit_block_invoke;
  block[3] = &__block_descriptor_tmp_27;
  v2 = a1;
  if (figCustomAllocatorsInit_onceToken != -1)
    dispatch_once(&figCustomAllocatorsInit_onceToken, block);
}

uint64_t FigGetAllocatorForMedia()
{
  figCustomAllocatorsInit(0);
  return qword_1ECDA8808;
}

uint64_t FigGetMallocZoneForMedia()
{
  figCustomAllocatorsInit(0);
  return qword_1ECDA8800;
}

uint64_t FigGetAllocatorForPermanentAllocations()
{
  figCustomAllocatorsInit(0);
  return qword_1ECDA8820;
}

uint64_t FigGetMallocZoneForPermanentAllocations()
{
  figCustomAllocatorsInit(0);
  return qword_1ECDA8818;
}

void *__figCustomAllocatorsInit_block_invoke(uint64_t a1)
{
  int v1;
  void *result;
  uint64_t v3;
  CFAllocatorContext context;

  v1 = *(unsigned __int8 *)(a1 + 32);
  figCustomAllocatorsInit_allocators = (uint64_t)"CMMediaAllocator";
  qword_1ECDA8810 = (uint64_t)"CMPermanentAllocator";
  if (v1)
  {
    qword_1ECDA8800 = (uint64_t)malloc_create_zone(0, 0);
    malloc_set_zone_name((malloc_zone_t *)qword_1ECDA8800, "CMMediaZone");
    context.version = 0;
    context.info = &figCustomAllocatorsInit_allocators;
    context.retain = 0;
    context.release = 0;
    context.copyDescription = (CFAllocatorCopyDescriptionCallBack)darwinMemory_copyDebugDescForCustomAllocator;
    context.allocate = (CFAllocatorAllocateCallBack)darwinMemory_allocForCustomAllocator;
    context.reallocate = (CFAllocatorReallocateCallBack)darwinMemory_reallocForCustomAllocator;
    context.deallocate = (CFAllocatorDeallocateCallBack)darwinMemory_deallocForCustomAllocator;
    context.preferredSize = 0;
    qword_1ECDA8808 = (uint64_t)CFAllocatorCreate(0, &context);
    qword_1ECDA8818 = (uint64_t)malloc_create_zone(0, 0);
    malloc_set_zone_name((malloc_zone_t *)qword_1ECDA8818, "CMPermanentZone");
    context.version = 0;
    context.info = &qword_1ECDA8810;
    context.retain = 0;
    context.release = 0;
    context.copyDescription = (CFAllocatorCopyDescriptionCallBack)darwinMemory_copyDebugDescForCustomAllocator;
    context.allocate = (CFAllocatorAllocateCallBack)darwinMemory_allocForCustomAllocator;
    context.reallocate = (CFAllocatorReallocateCallBack)darwinMemory_reallocForCustomAllocator;
    context.deallocate = (CFAllocatorDeallocateCallBack)darwinMemory_deallocForCustomAllocator;
    context.preferredSize = 0;
    result = CFAllocatorCreate(0, &context);
    qword_1ECDA8820 = (uint64_t)result;
  }
  else
  {
    qword_1ECDA8808 = *MEMORY[0x1E0C9AE00];
    v3 = qword_1ECDA8808;
    qword_1ECDA8800 = (uint64_t)malloc_default_zone();
    qword_1ECDA8820 = v3;
    result = malloc_default_zone();
    qword_1ECDA8818 = (uint64_t)result;
  }
  return result;
}

CFStringRef darwinMemory_copyDebugDescForCustomAllocator(uint64_t *a1)
{
  const __CFAllocator *v2;
  uint64_t v3;
  const char *zone_name;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v3 = *a1;
  zone_name = malloc_get_zone_name((malloc_zone_t *)a1[1]);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<%s with zone: %s(%p)>"), v3, zone_name, a1[1]);
}

void *darwinMemory_allocForCustomAllocator(size_t size, uint64_t a2, uint64_t a3)
{
  return malloc_type_zone_calloc(*(malloc_zone_t **)(a3 + 8), 1uLL, size, 0xF2F21DC9uLL);
}

void *darwinMemory_reallocForCustomAllocator(void *ptr, size_t size, uint64_t a3, uint64_t a4)
{
  return malloc_type_zone_realloc(*(malloc_zone_t **)(a4 + 8), ptr, size, 0x58E682ADuLL);
}

void darwinMemory_deallocForCustomAllocator(void *ptr, uint64_t a2)
{
  malloc_zone_free(*(malloc_zone_t **)(a2 + 8), ptr);
}

uint64_t FigMetricEventTimelineCreateRemote(uint64_t a1, int64_t a2, uint64_t *a3, uint64_t a4, CFTypeRef *a5)
{
  uint64_t v8;
  xpc_object_t v9;
  int64_t *v10;
  int64_t v11;
  int64_t v12;
  uint64_t v13;
  uint64_t uint64;
  const void *v15;
  uint64_t AllocatorForMedia;
  uint64_t v17;
  uint64_t v19;
  xpc_object_t v20;
  xpc_object_t xdict;

  v20 = 0;
  xdict = 0;
  if (!a5)
  {
    v8 = FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
LABEL_15:
    v17 = v8;
    v9 = 0;
    goto LABEL_13;
  }
  v8 = metremote_ensureClientEstablished();
  if ((_DWORD)v8)
    goto LABEL_15;
  v8 = FigXPCCreateBasicMessage(0x63726574u, 0, &xdict);
  if ((_DWORD)v8)
    goto LABEL_15;
  xpc_dictionary_set_int64(xdict, "MaxNoOfClasses", a2);
  v9 = xpc_array_create(0, 0);
  if (v9)
  {
    if (a2 >= 1)
    {
      v10 = a3;
      v11 = a2;
      do
      {
        v12 = *v10++;
        xpc_array_set_int64(v9, 0xFFFFFFFFFFFFFFFFLL, v12);
        --v11;
      }
      while (v11);
    }
    xpc_dictionary_set_value(xdict, "EventCountByClassXPCArray", v9);
    v13 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigMetricEventTimelineRemoteClient, (uint64_t)xdict, &v20);
    if ((_DWORD)v13)
      goto LABEL_12;
    uint64 = xpc_dictionary_get_uint64(v20, ".objectID");
    if (uint64)
    {
      v15 = (const void *)uint64;
      AllocatorForMedia = FigGetAllocatorForMedia();
      v13 = metremote_create(AllocatorForMedia, (uint64_t)v15, a2, a3, a5);
      if (!(_DWORD)v13)
        v13 = FigXPCRemoteClientAssociateObject(gFigMetricEventTimelineRemoteClient, (uint64_t)*a5, v15);
      goto LABEL_12;
    }
    v19 = 4294947844;
  }
  else
  {
    v19 = 4294947845;
  }
  v13 = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
LABEL_12:
  v17 = v13;
LABEL_13:
  FigXPCRelease(v9);
  FigXPCRelease(xdict);
  FigXPCRelease(v20);
  return v17;
}

uint64_t metremote_ensureClientEstablished()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __metremote_ensureClientEstablished_block_invoke;
  block[3] = &unk_1E28DD5C8;
  block[4] = &v3;
  if (metremote_ensureClientEstablished_sFigMetricEventTimelineRemoteClientSetupOnce != -1)
    dispatch_once(&metremote_ensureClientEstablished_sFigMetricEventTimelineRemoteClientSetupOnce, block);
  FigXPCRemoteClientKillServerOnTimeout(gFigMetricEventTimelineRemoteClient, *((unsigned int *)v4 + 6), "metremote_ensureClientEstablished", 0);
  v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t metremote_create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, CFTypeRef *a5)
{
  _QWORD *ClassID;
  uint64_t v11;
  CFTypeRef v12;
  _QWORD *DerivedStorage;
  CFTypeRef *v14;
  uint64_t AllocatorForMedia;
  CFTypeRef cf;

  cf = 0;
  if (!a5)
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  ClassID = (_QWORD *)FigMetricEventTimelineGetClassID();
  v11 = CMDerivedObjectCreate(a1, (uint64_t)&kMetricEventTimeline_VTable, ClassID, &cf);
  v12 = cf;
  if ((_DWORD)v11
    || (DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf),
        *DerivedStorage = a2,
        v14 = (CFTypeRef *)(DerivedStorage + 2),
        AllocatorForMedia = FigGetAllocatorForMedia(),
        v11 = FigMetricEventTimelineCreate(AllocatorForMedia, a3, a4, 0, 0, v14),
        v12 = cf,
        (_DWORD)v11))
  {
    if (v12)
      CFRelease(v12);
  }
  else
  {
    *a5 = cf;
  }
  return v11;
}

uint64_t FigMetricEventTimelineCreateRemoteWithObjectID(uint64_t a1, const void *a2, uint64_t a3, uint64_t *a4, _QWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  CFTypeRef v11;
  uint64_t AllocatorForMedia;
  uint64_t v13;
  CFTypeRef cf;

  cf = 0;
  if (!a5)
    return FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
  v9 = metremote_ensureClientEstablished();
  if ((_DWORD)v9)
    return v9;
  v10 = FigXPCRemoteClientRetainCopiedObject(gFigMetricEventTimelineRemoteClient, (uint64_t)a2, &cf);
  v11 = cf;
  if ((_DWORD)v10
    || !cf
    && ((AllocatorForMedia = FigGetAllocatorForMedia(),
         v10 = metremote_create(AllocatorForMedia, (uint64_t)a2, a3, a4, &cf),
         v11 = cf,
         (_DWORD)v10)
     || (v10 = FigXPCRemoteClientAssociateObject(gFigMetricEventTimelineRemoteClient, (uint64_t)cf, a2),
         v11 = cf,
         (_DWORD)v10)))
  {
    v13 = v10;
    if (v11)
      CFRelease(v11);
  }
  else
  {
    v13 = 0;
    *a5 = v11;
  }
  return v13;
}

uint64_t __metremote_ensureClientEstablished_block_invoke(uint64_t a1)
{
  uint64_t result;
  _OWORD v3[4];

  v3[0] = xmmword_1E28DD580;
  v3[1] = unk_1E28DD590;
  memset(&v3[2], 0, 32);
  result = FigXPCRemoteClientCreate((uint64_t)"com.apple.coremedia.mediaplaybackd.figmetriceventtimeline.xpc", (uint64_t)v3, 0, &gFigMetricEventTimelineRemoteClient);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t metremote_deadConnectionCallback(uint64_t a1)
{
  uint64_t result;

  result = CMBaseObjectGetDerivedStorage(a1);
  *(_BYTE *)(result + 8) = 1;
  return result;
}

uint64_t metremote_handleServerMessage(uint64_t a1, void *a2)
{
  uint64_t OpCode;
  uint64_t DerivedStorage;
  uint64_t v6;
  uint64_t v7;
  CFTypeRef v8;
  uint64_t (*v9)(uint64_t, uint64_t, CFTypeRef);
  uint64_t v10;
  int v12;
  CFTypeRef cf;

  v12 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v12);
  if ((_DWORD)OpCode)
    return OpCode;
  if (v12 != 1702260340)
    return 4294951138;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  cf = 0;
  v6 = FigMetricEventTimelineClientServerXPC_DeserializeAndCopyEvent(a2, &cf);
  if ((_DWORD)v6)
    goto LABEL_6;
  v7 = *(_QWORD *)(DerivedStorage + 16);
  v8 = cf;
  v9 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable(v7) + 16) + 40);
  if (v9)
  {
    v6 = v9(v7, a1, v8);
LABEL_6:
    v10 = v6;
    goto LABEL_9;
  }
  v10 = 4294954514;
LABEL_9:
  if (cf)
    CFRelease(cf);
  return v10;
}

uint64_t metremote_finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  void *v2;
  int v3;
  const void *v4;
  void *v6;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigXPCRemoteClientDisassociateObject(gFigMetricEventTimelineRemoteClient, *(const void **)DerivedStorage);
  v2 = 0;
  v6 = 0;
  if (!*(_BYTE *)(DerivedStorage + 8))
  {
    v3 = FigXPCCreateBasicMessage(0x64697370u, *(_QWORD *)DerivedStorage, &v6);
    v2 = v6;
    if (!v3)
    {
      FigXPCRemoteClientSendAsyncMessage(gFigMetricEventTimelineRemoteClient, v6);
      v2 = v6;
    }
  }
  FigXPCRelease(v2);
  v4 = *(const void **)(DerivedStorage + 16);
  if (v4)
    CFRelease(v4);
  return FigXPCRemoteClientKillServerOnTimeout(gFigMetricEventTimelineRemoteClient, 0, "metremote_finalize", 0);
}

CFStringRef metremote_copyDebugDesc(uint64_t a1)
{
  _QWORD *DerivedStorage;
  const __CFAllocator *AllocatorForMedia;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  return CFStringCreateWithFormat(AllocatorForMedia, 0, CFSTR("[FigMetricEventTimelineRemote %p %lld]"), a1, *DerivedStorage);
}

uint64_t metremote_registerSubscriber(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage;
  uint64_t *v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  void *v16;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v16 = 0;
  if (!a2)
  {
    v11 = FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
  v8 = (uint64_t *)DerivedStorage;
  if (*(_BYTE *)(DerivedStorage + 24))
  {
    v13 = 0;
    v14 = 0;
    goto LABEL_8;
  }
  *(_BYTE *)(DerivedStorage + 24) = 1;
  v9 = *(_QWORD *)(DerivedStorage + 16);
  v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v9) + 16) + 8);
  if (!v10)
  {
    v13 = 0;
    v14 = 4294954514;
    goto LABEL_8;
  }
  v11 = v10(v9, a2, a3, a4);
  if ((_DWORD)v11)
  {
LABEL_10:
    v14 = v11;
    v13 = 0;
    goto LABEL_8;
  }
  v12 = FigXPCCreateBasicMessage(0x72656773u, *v8, &v16);
  v13 = v16;
  if ((_DWORD)v12)
  {
    v14 = v12;
  }
  else
  {
    v14 = FigXPCRemoteClientSendSyncMessage(gFigMetricEventTimelineRemoteClient, (uint64_t)v16);
    v13 = v16;
  }
LABEL_8:
  FigXPCRelease(v13);
  return v14;
}

uint64_t metremote_subscribeByEventID(uint64_t a1, uint64_t a2, int64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t *v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t, uint64_t, int64_t);
  uint64_t v9;
  uint64_t v10;
  xpc_object_t v11;
  xpc_object_t xdict;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  xdict = 0;
  if (!a2)
  {
    v9 = FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  v6 = (uint64_t *)DerivedStorage;
  v7 = *(_QWORD *)(DerivedStorage + 16);
  v8 = *(uint64_t (**)(uint64_t, uint64_t, int64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v7) + 16) + 16);
  if (!v8)
  {
    v11 = 0;
    v10 = 4294954514;
    goto LABEL_7;
  }
  v9 = v8(v7, a2, a3);
  if ((_DWORD)v9)
  {
LABEL_9:
    v10 = v9;
    v11 = 0;
    goto LABEL_7;
  }
  v10 = FigXPCCreateBasicMessage(0x73657669u, *v6, &xdict);
  v11 = xdict;
  if (!(_DWORD)v10)
  {
    xpc_dictionary_set_int64(xdict, "EventID", a3);
    v10 = FigXPCRemoteClientSendSyncMessage(gFigMetricEventTimelineRemoteClient, (uint64_t)xdict);
    v11 = xdict;
  }
LABEL_7:
  FigXPCRelease(v11);
  return v10;
}

uint64_t metremote_subscribeByClassID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t *v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t);
  uint64_t v9;
  uint64_t v10;
  xpc_object_t v11;
  xpc_object_t xdict;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  xdict = 0;
  if (!a2)
  {
    v9 = FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  v6 = (uint64_t *)DerivedStorage;
  v7 = *(_QWORD *)(DerivedStorage + 16);
  v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v7) + 16) + 24);
  if (!v8)
  {
    v11 = 0;
    v10 = 4294954514;
    goto LABEL_7;
  }
  v9 = v8(v7, a2, a3);
  if ((_DWORD)v9)
  {
LABEL_9:
    v10 = v9;
    v11 = 0;
    goto LABEL_7;
  }
  v10 = FigXPCCreateBasicMessage(0x636C7369u, *v6, &xdict);
  v11 = xdict;
  if (!(_DWORD)v10)
  {
    xpc_dictionary_set_int64(xdict, "ClassID", (int)a3);
    v10 = FigXPCRemoteClientSendSyncMessage(gFigMetricEventTimelineRemoteClient, (uint64_t)xdict);
    v11 = xdict;
  }
LABEL_7:
  FigXPCRelease(v11);
  return v10;
}

uint64_t metremote_subscribeToAllEvents(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t *v4;
  uint64_t v5;
  uint64_t (*v6)(uint64_t, uint64_t);
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v12;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v12 = 0;
  if (!a2)
  {
    v7 = FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  v4 = (uint64_t *)DerivedStorage;
  v5 = *(_QWORD *)(DerivedStorage + 16);
  v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v5) + 16) + 32);
  if (!v6)
  {
    v9 = 0;
    v10 = 4294954514;
    goto LABEL_7;
  }
  v7 = v6(v5, a2);
  if ((_DWORD)v7)
  {
LABEL_9:
    v10 = v7;
    v9 = 0;
    goto LABEL_7;
  }
  v8 = FigXPCCreateBasicMessage(0x73746165u, *v4, &v12);
  v9 = v12;
  if ((_DWORD)v8)
  {
    v10 = v8;
  }
  else
  {
    v10 = FigXPCRemoteClientSendSyncMessage(gFigMetricEventTimelineRemoteClient, (uint64_t)v12);
    v9 = v12;
  }
LABEL_7:
  FigXPCRelease(v9);
  return v10;
}

uint64_t met_publishEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t *v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  void *v15;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v15 = 0;
  if (!a2 || !a3)
  {
    v10 = FigSignalErrorAt(4294947846, 0, 0, 0, 0, 0, 0);
    goto LABEL_11;
  }
  v7 = (uint64_t *)DerivedStorage;
  v8 = *(_QWORD *)(DerivedStorage + 16);
  v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v8) + 16) + 40);
  if (!v9)
  {
    v12 = 0;
    v13 = 4294954514;
    goto LABEL_9;
  }
  v10 = v9(v8, a2, a3);
  if ((_DWORD)v10)
  {
LABEL_11:
    v13 = v10;
    v12 = 0;
    goto LABEL_9;
  }
  v11 = FigXPCCreateBasicMessage(0x70756273u, *v7, &v15);
  v12 = v15;
  if ((_DWORD)v11 || (v11 = FigMetricEventTimelineClientServerXPC_SerializeEvent(v15, a1, a3), v12 = v15, (_DWORD)v11))
  {
    v13 = v11;
  }
  else
  {
    v13 = FigXPCRemoteClientSendSyncMessage(gFigMetricEventTimelineRemoteClient, (uint64_t)v15);
    v12 = v15;
  }
LABEL_9:
  FigXPCRelease(v12);
  return v13;
}

uint64_t FigVirtualCaptureCardServerStart()
{
  __CFDictionary *Mutable;
  uint64_t v1;
  _OWORD v3[3];

  v3[0] = xmmword_1E28DD6A8;
  v3[1] = *(_OWORD *)&off_1E28DD6B8;
  v3[2] = xmmword_1E28DD6C8;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, CFSTR("xpcServerOption_SiloObjectIDs"), (const void *)*MEMORY[0x1E0C9AE50]);
  v1 = FigXPCServerStart((uint64_t)"com.apple.coremedia.figvirtualcapturecard.xpc", (uint64_t)v3, (uint64_t)Mutable, &gFigVirtualCaptureCardServer);
  if (Mutable)
    CFRelease(Mutable);
  return v1;
}

uint64_t FigVirtualCaptureCardServerReplyingMessageHandler(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t OpCode;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t uint64;
  uint64_t v11;
  CFTypeID v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t);
  uint64_t v15;
  const char *string;
  const __CFString *v17;
  const __CFString *v18;
  CFURLRef v19;
  CFURLRef v20;
  uint64_t (*v21)(uint64_t, CFURLRef);
  const void *v22;
  int v24;
  uint64_t value;

  v24 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v24);
  if ((_DWORD)OpCode)
    return OpCode;
  if (v24 != 1668441400)
  {
    uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
    value = 0;
    v11 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &value, 0);
    if ((_DWORD)v11)
    {
      v9 = v11;
    }
    else
    {
      if (!value)
        return 4294954513;
      v12 = CFGetTypeID((CFTypeRef)value);
      if (v12 == FigVirtualCaptureCardGetTypeID())
      {
        v13 = value;
        v9 = 4294951138;
        if (v24 <= 1919251317)
        {
          if (v24 == 778268793)
          {
            v15 = FigXPCHandleStdCopyPropertyMessage(value, a2, a3);
LABEL_31:
            v9 = v15;
            if (!v13)
              return v9;
            goto LABEL_37;
          }
          if (v24 == 779314548)
          {
            v15 = FigXPCHandleStdSetPropertyMessage(value, a2);
            goto LABEL_31;
          }
        }
        else
        {
          switch(v24)
          {
            case 1919251318:
              string = xpc_dictionary_get_string(a2, "FileURL");
              v17 = CFStringCreateWithCString(0, string, 0x8000100u);
              if (!v17)
              {
                v9 = 4294954510;
                if (!v13)
                  return v9;
LABEL_37:
                v22 = (const void *)v13;
LABEL_38:
                CFRelease(v22);
                return v9;
              }
              v18 = v17;
              v19 = CFURLCreateWithString(0, v17, 0);
              if (v19)
              {
                v20 = v19;
                v21 = *(uint64_t (**)(uint64_t, CFURLRef))(*(_QWORD *)(CMBaseObjectGetVTable(v13) + 16) + 16);
                if (v21)
                  v9 = v21(v13, v20);
                else
                  v9 = 4294954514;
                CFRelease(v18);
              }
              else
              {
                v9 = 4294954510;
                v20 = (CFURLRef)v18;
              }
              CFRelease(v20);
              break;
            case 1935767141:
              v14 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(value) + 16) + 24);
              if (!v14)
              {
LABEL_19:
                v9 = 4294954514;
                if (!v13)
                  return v9;
                goto LABEL_37;
              }
              goto LABEL_29;
            case 1936224119:
              v14 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(value) + 16) + 8);
              if (!v14)
                goto LABEL_19;
LABEL_29:
              v15 = v14(v13);
              goto LABEL_31;
          }
        }
        if (!v13)
          return v9;
        goto LABEL_37;
      }
      v9 = 4294954516;
    }
    v22 = (const void *)value;
    if (!value)
      return v9;
    goto LABEL_38;
  }
  if (HandleFigVirtualCaptureCardCreationMessage_onceToken != -1)
    dispatch_once(&HandleFigVirtualCaptureCardCreationMessage_onceToken, &__block_literal_global_25);
  value = 0;
  FigSimpleMutexLock((pthread_mutex_t *)HandleFigVirtualCaptureCardCreationMessage_sFigVirtualCaptureCardCreationLock);
  v7 = (const void *)HandleFigVirtualCaptureCardCreationMessage_sFigVirtualCaptureCard;
  if (HandleFigVirtualCaptureCardCreationMessage_sFigVirtualCaptureCard)
    goto LABEL_8;
  v8 = FigVirtualCaptureCardCreate(*MEMORY[0x1E0C9AE00], 0, &HandleFigVirtualCaptureCardCreationMessage_sFigVirtualCaptureCard);
  if (!(_DWORD)v8)
  {
    v7 = (const void *)HandleFigVirtualCaptureCardCreationMessage_sFigVirtualCaptureCard;
LABEL_8:
    v9 = FigXPCServerAssociateObjectWithConnection(a1, v7, 0, 0, 0, &value);
    if (!(_DWORD)v9)
      xpc_dictionary_set_uint64(a3, ".objectID", value);
    goto LABEL_10;
  }
  v9 = v8;
LABEL_10:
  FigSimpleMutexUnlock((pthread_mutex_t *)HandleFigVirtualCaptureCardCreationMessage_sFigVirtualCaptureCardCreationLock);
  return v9;
}

uint64_t FigVirtualCaptureCardServerNoReplyMessageHandler(_xpc_connection_s *a1, void *a2)
{
  uint64_t OpCode;
  uint64_t uint64;
  uint64_t v6;
  CFTypeRef cf;
  int v9;

  v9 = 0;
  cf = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v9);
  if ((_DWORD)OpCode)
    goto LABEL_5;
  uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  OpCode = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, 0);
  if ((_DWORD)OpCode)
    goto LABEL_5;
  if (v9 == 1684632432)
  {
    OpCode = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
LABEL_5:
    v6 = OpCode;
    goto LABEL_7;
  }
  v6 = 4294951138;
LABEL_7:
  if (cf)
    CFRelease(cf);
  return v6;
}

uint64_t AudioToolbox_AudioConverterGetProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t result;

  v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))pAudioConverterGetProperty;
  if (pAudioConverterGetProperty)
    return v8(a1, a2, a3, a4);
  FigThreadRunOnce(&loadAudioToolboxPointers_sLoadAudioToolboxPointersOnce, (void (*)(void))loadAudioToolboxPointersOnce);
  result = gAudioToolboxBundleStatus ? 4294965266 : 0;
  v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))pAudioConverterGetProperty;
  if (pAudioConverterGetProperty)
    return v8(a1, a2, a3, a4);
  return result;
}

uint64_t AudioToolbox_AudioConverterSetProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t result;

  v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))pAudioConverterSetProperty;
  if (pAudioConverterSetProperty)
    return v8(a1, a2, a3, a4);
  FigThreadRunOnce(&loadAudioToolboxPointers_sLoadAudioToolboxPointersOnce, (void (*)(void))loadAudioToolboxPointersOnce);
  result = gAudioToolboxBundleStatus ? 4294965266 : 0;
  v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))pAudioConverterSetProperty;
  if (pAudioConverterSetProperty)
    return v8(a1, a2, a3, a4);
  return result;
}

uint64_t AudioToolbox_AudioConverterDispose(uint64_t a1)
{
  uint64_t (*v2)(uint64_t);
  uint64_t result;

  v2 = (uint64_t (*)(uint64_t))pAudioConverterDispose;
  if (pAudioConverterDispose)
    return v2(a1);
  FigThreadRunOnce(&loadAudioToolboxPointers_sLoadAudioToolboxPointersOnce, (void (*)(void))loadAudioToolboxPointersOnce);
  result = gAudioToolboxBundleStatus ? 4294965266 : 0;
  v2 = (uint64_t (*)(uint64_t))pAudioConverterDispose;
  if (pAudioConverterDispose)
    return v2(a1);
  return result;
}

uint64_t AudioToolbox_AudioConverterNew(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t);
  uint64_t result;

  v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))pAudioConverterNew;
  if (pAudioConverterNew)
    return v6(a1, a2, a3);
  FigThreadRunOnce(&loadAudioToolboxPointers_sLoadAudioToolboxPointersOnce, (void (*)(void))loadAudioToolboxPointersOnce);
  result = gAudioToolboxBundleStatus ? 4294965266 : 0;
  v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))pAudioConverterNew;
  if (pAudioConverterNew)
    return v6(a1, a2, a3);
  return result;
}

uint64_t FigHALAudioObjectGetClassID()
{
  if (FigHALAudioObjectGetClassID_sRegisterFigHALAudioDeviceOnce != -1)
    dispatch_once(&FigHALAudioObjectGetClassID_sRegisterFigHALAudioDeviceOnce, &__block_literal_global_26);
  return FigHALAudioObjectGetClassID_sFigHALAudioObjectClassID;
}

uint64_t CelestialIsAppleTV()
{
  uint64_t result;

  if (getDeviceClass_onceToken != -1)
    dispatch_once(&getDeviceClass_onceToken, &__block_literal_global_75);
  if (getDeviceClass_deviceClass != 4)
    return CelestialIsAppleTV_sIsAppleTV;
  result = 1;
  CelestialIsAppleTV_sIsAppleTV = 1;
  return result;
}

uint64_t CelestialIsiPad()
{
  uint64_t result;

  if (getDeviceClass_onceToken != -1)
    dispatch_once(&getDeviceClass_onceToken, &__block_literal_global_75);
  if (getDeviceClass_deviceClass != 3)
    return CelestialIsiPad_sIsiPad;
  result = 1;
  CelestialIsiPad_sIsiPad = 1;
  return result;
}

uint64_t CelestialIsiPhone()
{
  uint64_t result;

  if (getDeviceClass_onceToken != -1)
    dispatch_once(&getDeviceClass_onceToken, &__block_literal_global_75);
  if (getDeviceClass_deviceClass != 1)
    return CelestialIsiPhone_sIsiPhone;
  result = 1;
  CelestialIsiPhone_sIsiPhone = 1;
  return result;
}

void CelestialGetSupportedAVCProfileAndLevel(_BYTE *a1, _BYTE *a2)
{
  if (CelestialGetSupportedAVCProfileAndLevel_onceToken == -1)
  {
    if (!a1)
      goto LABEL_4;
    goto LABEL_3;
  }
  dispatch_once(&CelestialGetSupportedAVCProfileAndLevel_onceToken, &__block_literal_global_27);
  if (a1)
LABEL_3:
    *a1 = 100;
LABEL_4:
  if (a2)
    *a2 = CelestialGetSupportedAVCProfileAndLevel_sLevel;
}

uint64_t CelestialGetModelSpecificResolutionCap(double *a1, double *a2, __int128 *a3)
{
  uint64_t result;
  double v7;
  double v8;
  double v10;
  double v11;
  __int128 v12;

  v12 = xmmword_18EDDD6B0;
  v10 = 0.0;
  v11 = 0.0;
  CelestialGetMainScreenSize(&v11, &v10, 2048.0);
  result = 0;
  v8 = v10;
  v7 = v11;
  if (v11 > 0.0 && v10 > 0.0 && v10 > 7.0)
  {
    v12 = kResolutionCap3K;
    result = 1;
  }
  *a3 = v12;
  *a1 = v7;
  *a2 = v8;
  return result;
}

double CelestialGetMainScreenSize(double *a1, double *a2, double result)
{
  int v5;
  int v6;
  int v7;
  double v8;
  double v9;
  double v10;

  if (a1)
  {
    if (a2)
    {
      *a1 = 0.0;
      *a2 = 0.0;
      v5 = MGGetSInt32Answer();
      v6 = MGGetSInt32Answer();
      v7 = MGGetSInt32Answer();
      if (v5 >= 1 && v6 >= 1)
      {
        v8 = (double)v7;
        v9 = (double)v6;
        if ((double)v5 <= (double)v6)
          v10 = (double)v6;
        else
          v10 = (double)v5;
        if ((double)v5 <= (double)v6)
          v9 = (double)v5;
        *a1 = v10 / v8;
        result = v9 / v8;
        *a2 = result;
      }
    }
  }
  return result;
}

uint64_t CelestialIsAudioAccessory()
{
  if (CelestialIsAudioAccessory_onceToken != -1)
    dispatch_once(&CelestialIsAudioAccessory_onceToken, &__block_literal_global_3_0);
  return CelestialIsAudioAccessory_sIsAudioAccessory;
}

BOOL CelestialIs1GBAudioAccessory()
{
  if (CelestialIsAudioAccessory_onceToken != -1)
    dispatch_once(&CelestialIsAudioAccessory_onceToken, &__block_literal_global_3_0);
  if (CelestialIsAudioAccessory_sIsAudioAccessory != 1)
    return 0;
  FigThreadRunOnce(&sGetSystemMemorySizeOnce, (void (*)(void))celestialGetSystemMemorySizeOnce);
  return (unint64_t)sMemorySize < 0x40000001;
}

uint64_t CelestialGetSystemMemorySize()
{
  FigThreadRunOnce(&sGetSystemMemorySizeOnce, (void (*)(void))celestialGetSystemMemorySizeOnce);
  return sMemorySize;
}

uint64_t celestialGetSystemMemorySizeOnce()
{
  uint64_t result;
  size_t v1;
  int v2[2];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)v2 = 0x1800000006;
  v1 = 8;
  result = sysctl(v2, 2u, &sMemorySize, &v1, 0, 0);
  if ((result & 0x80000000) != 0)
    sMemorySize = 0;
  return result;
}

CFPropertyListRef CelestialCFCreatePropertyListForModelAndBundleIdentifier(CFStringRef bundleID, const __CFString *a2, const __CFString *cf)
{
  return FigCreateModelSpecificPropertyListForModelAndBundleIdentifier((const __CFAllocator *)*MEMORY[0x1E0C9AE00], bundleID, a2, cf);
}

CFPropertyListRef FigCreateModelSpecificPropertyListForModelAndBundleIdentifier(const __CFAllocator *a1, CFStringRef bundleID, const __CFString *a3, const __CFString *cf)
{
  const __CFString *v4;
  CFPropertyListRef PropertyListFromBundleIdentifier;
  CFPropertyListRef v9;

  v4 = cf;
  if (cf)
  {
    CFRetain(cf);
    if (!FigCFBundleIDResourceSubdirExists(bundleID, v4))
    {
      CFRelease(v4);
      v4 = CFSTR("Default");
    }
  }
  PropertyListFromBundleIdentifier = FigCreatePropertyListFromBundleIdentifier(a1, bundleID, a3, v4);
  v9 = PropertyListFromBundleIdentifier;
  if (v4 && !PropertyListFromBundleIdentifier)
  {
    v9 = FigCreatePropertyListFromBundleIdentifier(a1, bundleID, a3, 0);
LABEL_8:
    CFRelease(v4);
    return v9;
  }
  if (v4)
    goto LABEL_8;
  return v9;
}

CFPropertyListRef CelestialCFCreatePropertyListForModel(const __CFString *a1, const __CFString *cf)
{
  return FigCreateModelSpecificPropertyListForModelAndBundleIdentifier((const __CFAllocator *)*MEMORY[0x1E0C9AE00], CFSTR("com.apple.MediaToolbox"), a1, cf);
}

CFPropertyListRef FigCreateModelSpecificPropertyListForModel(const __CFAllocator *a1, const __CFString *a2, const __CFString *cf)
{
  return FigCreateModelSpecificPropertyListForModelAndBundleIdentifier(a1, CFSTR("com.apple.MediaToolbox"), a2, cf);
}

CFPropertyListRef FigCreateModelSpecificPropertyList(const __CFAllocator *a1, const __CFString *a2)
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1)
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_7_1);
  return FigCreateModelSpecificPropertyListForModelAndBundleIdentifier(a1, CFSTR("com.apple.MediaToolbox"), a2, (const __CFString *)CelestialGetModelSpecificName_sModelNameStr);
}

CFPropertyListRef CelestialCFCreatePropertyListFromBundleIdentifier(CFStringRef bundleID, const __CFString *a2)
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1)
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_7_1);
  return FigCreateModelSpecificPropertyListForModelAndBundleIdentifier((const __CFAllocator *)*MEMORY[0x1E0C9AE00], bundleID, a2, (const __CFString *)CelestialGetModelSpecificName_sModelNameStr);
}

CFPropertyListRef FigCreateModelSpecificPropertyListFromBundleIdentifier(const __CFAllocator *a1, CFStringRef bundleID, const __CFString *a3)
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1)
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_7_1);
  return FigCreateModelSpecificPropertyListForModelAndBundleIdentifier(a1, bundleID, a3, (const __CFString *)CelestialGetModelSpecificName_sModelNameStr);
}

uint64_t CelestialCustomizePlaybackImageQueueLevels(uint64_t a1, CMTime *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  int CFPreferenceNumberWithDefault;
  CMTimeEpoch epoch;
  __int128 v10;
  __int128 v11;
  CMTime v12;
  CMTime v13;

  result = CelestialIsAppleTV();
  if ((_DWORD)result)
  {
    memset(&v13, 0, sizeof(v13));
    v12 = *a2;
    CMTimeConvertScale(&v13, &v12, 60, kCMTimeRoundingMethod_RoundTowardPositiveInfinity);
    CFPreferenceNumberWithDefault = FigGetCFPreferenceNumberWithDefault(CFSTR("decode_depth"), CFSTR("com.apple.coremedia"), LODWORD(v13.value));
    CMTimeMake(&v12, CFPreferenceNumberWithDefault, 60);
    *(_OWORD *)&a2->value = *(_OWORD *)&v12.value;
    epoch = v12.epoch;
    a2->epoch = v12.epoch;
    v10 = *(_OWORD *)&a2->value;
    *(_QWORD *)(a3 + 16) = epoch;
    *(_OWORD *)a3 = v10;
    v11 = *(_OWORD *)&a2->value;
    *(_QWORD *)(a4 + 16) = a2->epoch;
    *(_OWORD *)a4 = v11;
    return 1;
  }
  return result;
}

double CelestialGetStreamingBackBufferDuration(double a1)
{
  FigThreadRunOnce(&sGetSystemMemorySizeOnce, (void (*)(void))celestialGetSystemMemorySizeOnce);
  if ((unint64_t)sMemorySize <= 0x20000000 && !CelestialIsAppleTV())
    return 1.0;
  return a1;
}

uint64_t CelestialShouldLimitConcurrent4K60HEVCDecoding()
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1)
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_7_1);
  return FigCFEqual((CFTypeRef)CelestialGetModelSpecificName_sModelNameStr, CFSTR("J105a"));
}

uint64_t CelestialShouldLimitHDRConcurrentPlayback(_DWORD *a1)
{
  uint64_t result;

  result = CelestialIsAppleTV();
  if ((_DWORD)result)
  {
    result = 1;
    if (a1)
      *a1 = 1;
  }
  return result;
}

uint64_t CelestialShouldLimitMVHEVCEncoding()
{
  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1)
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_7_1);
  return FigCFEqual((CFTypeRef)CelestialGetModelSpecificName_sModelNameStr, CFSTR("J105a"));
}

BOOL CelestialShouldLimitMVHEVCDecoding()
{
  const void *v0;

  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1)
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_7_1);
  v0 = (const void *)CelestialGetModelSpecificName_sModelNameStr;
  return FigCFEqual((CFTypeRef)CelestialGetModelSpecificName_sModelNameStr, CFSTR("J71b"))
      || FigCFEqual(v0, CFSTR("J72b"))
      || FigCFEqual(v0, CFSTR("J120"))
      || FigCFEqual(v0, CFSTR("J121"))
      || FigCFEqual(v0, CFSTR("J171"))
      || FigCFEqual(v0, CFSTR("J172"))
      || FigCFEqual(v0, CFSTR("J207"))
      || FigCFEqual(v0, CFSTR("J208")) != 0;
}

uint64_t CelestialShouldLimit4kConcurrentPlayback(_DWORD *a1)
{
  uint64_t result;

  result = CelestialIsAppleTV();
  if ((_DWORD)result)
  {
    result = 1;
    if (a1)
      *a1 = 1;
  }
  return result;
}

uint64_t CelestialShouldLimit4kStereoConcurrentPlayback()
{
  return 0;
}

uint64_t CelestialShouldLimitHDRFrameRateForPlayback(_QWORD *a1, double a2, double a3)
{
  int v6;
  uint64_t result;
  BOOL v8;

  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1)
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_7_1);
  v6 = FigCFEqual((CFTypeRef)CelestialGetModelSpecificName_sModelNameStr, CFSTR("J105a"));
  result = 0;
  if (v6)
    v8 = a3 <= 1920.0;
  else
    v8 = 1;
  if (!v8 && a2 > 1080.0)
  {
    if (a1)
      *a1 = 0x403E000000000000;
    return 1;
  }
  return result;
}

BOOL CelestialShouldSupportHDR10Plus()
{
  const void *v0;

  if (CelestialGetModelSpecificName_sModelNameCheckOnce != -1)
    dispatch_once(&CelestialGetModelSpecificName_sModelNameCheckOnce, &__block_literal_global_7_1);
  v0 = (const void *)CelestialGetModelSpecificName_sModelNameStr;
  return !FigCFEqual((CFTypeRef)CelestialGetModelSpecificName_sModelNameStr, CFSTR("J42d"))
      && !FigCFEqual(v0, CFSTR("J105a"))
      && !FigCFEqual(v0, CFSTR("J305"));
}

uint64_t CelestialShouldManageEDRDeadline()
{
  return MGGetBoolAnswer();
}

uint64_t CelestialShouldAllowHTPCIOSurfacesForHDRPlaybackToCA()
{
  if (CelestialShouldAllowHTPCIOSurfacesForHDRPlaybackToCA_once != -1)
    dispatch_once(&CelestialShouldAllowHTPCIOSurfacesForHDRPlaybackToCA_once, &__block_literal_global_54);
  return CelestialShouldAllowHTPCIOSurfacesForHDRPlaybackToCA_result;
}

uint64_t FigIsAirplaydEnabled()
{
  if (FigIsAirplaydEnabled_once != -1)
    dispatch_once(&FigIsAirplaydEnabled_once, &__block_literal_global_62);
  return FigIsAirplaydEnabled_result;
}

uint64_t __getDeviceClass_block_invoke()
{
  uint64_t result;

  result = MGGetSInt32Answer();
  getDeviceClass_deviceClass = result;
  return result;
}

uint64_t FigCustomURLHandlerRemoteClientCreateWithXPCEndpoint(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = FigXPCRemoteClientCreateWithXPCEndpoint((uint64_t)"customURLHandler", a1, (uint64_t)&FigCustomURLHandlerRemoteClientCreateWithXPCEndpoint_sFigCustomURLHandlerRemoteClientCallbacks, 0, a2);
  if ((_DWORD)result)
    return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  return result;
}

uint64_t figCustomURLHandlerRemote_DeadConnectionCallback(const void *a1)
{
  CFTypeID v2;
  uint64_t result;

  v2 = CFGetTypeID(a1);
  result = FigCustomURLHandlerGetTypeID();
  if (v2 == result)
  {
    result = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    *(_BYTE *)(result + 40) = 1;
  }
  return result;
}

uint64_t figCustomURLHandlerRemote_MessageHandler(uint64_t a1, void *a2)
{
  uint64_t OpCode;
  const __CFAllocator *v5;
  const UInt8 *v6;
  _QWORD *v7;
  CFDataRef v8;
  CFDataRef v9;
  uint64_t uint64;
  uint64_t (*v11)(uint64_t, uint64_t, void (*)(uint64_t, uint64_t, const __CFData *, int, const void *, const void *, const void *, NSObject *, uint64_t, CFTypeRef), CFDataRef);
  int v13;

  v13 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v13);
  if (!(_DWORD)OpCode && v13 == 1667777603)
  {
    if (dataCallbackMessageRec_getCFAllocator_sOnceToken != -1)
      dispatch_once_f(&dataCallbackMessageRec_getCFAllocator_sOnceToken, &dataCallbackMessageRec_getCFAllocator_sAllocator, (dispatch_function_t)dataCallbackMessageRec_initializeCFAllocatorOnce);
    v5 = (const __CFAllocator *)dataCallbackMessageRec_getCFAllocator_sAllocator;
    if (dataCallbackMessageRec_getCFAllocator_sAllocator
      || (OpCode = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0), !(_DWORD)OpCode))
    {
      v6 = (const UInt8 *)malloc_type_calloc(1uLL, 8uLL, 0x80040B8603338uLL);
      if (v6)
      {
        v7 = v6;
        v8 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6, 8, v5);
        if (v8)
        {
          v9 = v8;
          *v7 = FigXPCRetain(a2);
          uint64 = xpc_dictionary_get_uint64(a2, "CustomURLHandler_RequestID");
          v11 = *(uint64_t (**)(uint64_t, uint64_t, void (*)(uint64_t, uint64_t, const __CFData *, int, const void *, const void *, const void *, NSObject *, uint64_t, CFTypeRef), CFDataRef))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16) + 56);
          if (v11)
            OpCode = v11(a1, uint64, figCustomURLHandler_handleDataCallbackMessageWithRegisteredRequestInfo, v9);
          else
            OpCode = 4294954514;
          CFRelease(v9);
          return OpCode;
        }
        free(v7);
      }
      return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    }
  }
  return OpCode;
}

uint64_t FigCustomURLHandlerRemoteClientCopyExistingOrCreateIfNeccessaryWithXPCEndpoint(int a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  id v10;

  if (FigCustomURLHandlerRemoteClientCopyExistingOrCreateIfNeccessaryWithXPCEndpoint_sFigCustomURLRemoteXPCRemoteClientByPIDMutexRegisterOnce != -1)
    dispatch_once(&FigCustomURLHandlerRemoteClientCopyExistingOrCreateIfNeccessaryWithXPCEndpoint_sFigCustomURLRemoteXPCRemoteClientByPIDMutexRegisterOnce, &__block_literal_global_28);
  if (gFigCustomURLRemoteXPCRemoteClientByPIDTable)
  {
    FigSimpleMutexLock((pthread_mutex_t *)gFigCustomURLRemoteXPCRemoteClientByPIDMutex);
    v10 = FigCFWeakReferenceTableCopyValue(gFigCustomURLRemoteXPCRemoteClientByPIDTable, (void *)a1);
    if (v10)
    {
      v6 = 0;
LABEL_10:
      FigSimpleMutexUnlock((pthread_mutex_t *)gFigCustomURLRemoteXPCRemoteClientByPIDMutex);
      *a3 = v10;
      return v6;
    }
    if (a2)
    {
      if (!FigXPCRemoteClientCreateWithXPCEndpoint((uint64_t)"customURLHandler", a2, (uint64_t)&FigCustomURLHandlerRemoteClientCopyExistingOrCreateIfNeccessaryWithXPCEndpoint_sFigCustomURLHandlerRemoteClientCallbacks, 0, (uint64_t)&v10))
      {
        FigCFWeakReferenceTableRemoveValue(gFigCustomURLRemoteXPCRemoteClientByPIDTable, a1);
        v7 = FigCFWeakReferenceTableAddValueAssociatedWithKey(gFigCustomURLRemoteXPCRemoteClientByPIDTable, (uint64_t)v10, a1);
LABEL_9:
        v6 = v7;
        goto LABEL_10;
      }
      v9 = 4294954510;
    }
    else
    {
      v9 = 4294954516;
    }
    v7 = FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
    goto LABEL_9;
  }
  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCustomURLHandlerRemoteCreateWithID(const void *a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  const void *v8;
  _QWORD *ClassID;
  uint64_t ServerPID;
  uint64_t DerivedStorage;
  uint64_t v12;
  int v14;
  CFTypeRef cf;

  cf = 0;
  v14 = 0;
  if (!a2)
    return 4294954516;
  v8 = (const void *)*MEMORY[0x1E0C9AE00];
  ClassID = (_QWORD *)FigCustomURLHandlerGetClassID();
  ServerPID = CMDerivedObjectCreate((uint64_t)v8, (uint64_t)&kFigCustomURLHandlerRemote_VTable, ClassID, &cf);
  if ((_DWORD)ServerPID
    || (DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf),
        *(_QWORD *)(DerivedStorage + 24) = dispatch_queue_create("com.apple.coremedia.customurlhandler.remotehandler", 0), ServerPID = FigXPCRemoteClientGetServerPID((uint64_t)a2, &v14), (_DWORD)ServerPID))
  {
    v12 = ServerPID;
    if (cf)
      CFRelease(cf);
  }
  else
  {
    *(_DWORD *)(DerivedStorage + 8) = v14;
    *(_QWORD *)(DerivedStorage + 32) = a1;
    *(_QWORD *)DerivedStorage = CFRetain(a2);
    FigXPCRemoteClientAssociateObject((uint64_t)a2, (uint64_t)cf, a1);
    v12 = FigCustomURLHandlerCreate(v8, "FigCustomURLHandlerRemoteShim", (uint64_t)cf, *(NSObject **)(DerivedStorage + 24), &FigCustomURLHandlerRemoteCreateWithID_sFigCustomURLHandlerRemoteCallbacks, a3, (CFTypeRef *)(DerivedStorage + 16));
    *a4 = cf;
  }
  return v12;
}

void figCustomURLHandlerRemote_shimHandleRequestCallback(uint64_t a1, uint64_t a2, const __CFDictionary *a3, uint64_t a4, void (*a5)(uint64_t, _QWORD, uint64_t), uint64_t a6)
{
  uint64_t DerivedStorage;
  uint64_t v11;
  uint64_t v12;
  uint64_t NSSecureCodingTypesSerializable;
  __CFDictionary *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t IDForCryptorByAssociatingWithClientPID;
  uint64_t v18;
  CFTypeRef v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD v22[6];
  int v23[2];
  CFTypeRef cf;
  uint64_t v25;
  void *value;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  *(_QWORD *)v23 = 0;
  if (*(_BYTE *)(DerivedStorage + 40))
  {
    v19 = 0;
    v16 = 4294949923;
    goto LABEL_21;
  }
  v11 = DerivedStorage;
  v12 = FigXPCCreateBasicMessage(0x63684852u, *(_QWORD *)(DerivedStorage + 32), v23);
  if ((_DWORD)v12)
  {
    v16 = v12;
LABEL_34:
    v19 = 0;
    goto LABEL_21;
  }
  cf = 0;
  if (*(_BYTE *)(v11 + 40))
  {
    v16 = 4294949923;
    goto LABEL_34;
  }
  NSSecureCodingTypesSerializable = FigCustomURLRequestInfoCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3, &cf);
  if ((_DWORD)NSSecureCodingTypesSerializable)
    goto LABEL_25;
  v14 = (__CFDictionary *)cf;
  value = 0;
  v25 = 0;
  v15 = FigCustomURLRequestInfoCopyCryptor((const __CFDictionary *)cf, (const void **)&value);
  if ((_DWORD)v15 == -17360)
  {
    v16 = 0;
    goto LABEL_11;
  }
  v16 = v15;
  if (!(_DWORD)v15)
  {
    IDForCryptorByAssociatingWithClientPID = FigCPECryptorServerGetIDForCryptorByAssociatingWithClientPID(value, *(_DWORD *)(v11 + 8), &v25);
    if ((_DWORD)IDForCryptorByAssociatingWithClientPID
      || (IDForCryptorByAssociatingWithClientPID = FigCustomURLRequestInfoSetCryptorID(v14, v25),
          (_DWORD)IDForCryptorByAssociatingWithClientPID))
    {
      v16 = IDForCryptorByAssociatingWithClientPID;
    }
    else
    {
      v16 = FigCustomURLRequestInfoSetCryptor(v14, 0);
      if (!(_DWORD)v16)
        goto LABEL_11;
    }
    FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
  }
LABEL_11:
  if (value)
    CFRelease(value);
  if ((_DWORD)v16)
    goto LABEL_32;
  v18 = FigCustomURLRequestInfoSetNetworkHistory((__CFDictionary *)cf, 0);
  if ((_DWORD)v18)
  {
    v16 = v18;
    FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
LABEL_32:
    if (cf)
      CFRelease(cf);
    goto LABEL_34;
  }
  NSSecureCodingTypesSerializable = FigCustomURLRequestInfoMakeNSSecureCodingTypesSerializable((const __CFDictionary *)cf);
  if ((_DWORD)NSSecureCodingTypesSerializable)
  {
LABEL_25:
    v16 = NSSecureCodingTypesSerializable;
    goto LABEL_32;
  }
  v19 = cf;
  xpc_dictionary_set_uint64(*(xpc_object_t *)v23, "CustomURLHandler_RequestID", a4);
  FigXPCMessageSetCFDictionary(*(void **)v23, "CustomURLHandler_RequestInfo", v19);
  v20 = *(_QWORD *)v11;
  v22[0] = MEMORY[0x1E0C809B0];
  v22[1] = 0x40000000;
  v22[2] = __figCustomURLHandlerRemote_shimHandleRequestCallback_block_invoke;
  v22[3] = &__block_descriptor_tmp_5_2;
  v22[4] = a5;
  v22[5] = a6;
  v21 = FigXPCRemoteClientSendAsyncMessageWithNoTimeoutWithReplyHandler(v20, *(void **)v23, (uint64_t)v22);
  if (!(_DWORD)v21)
    goto LABEL_22;
  v16 = v21;
  if (v19)
  {
    value = 0;
    if (!*(_BYTE *)(v11 + 40) && !FigCustomURLRequestInfoGetCryptorID((uint64_t)v19, &value))
      FigCPECryptorServerDisassociateCryptorWithClientPID((uint64_t)value, *(_DWORD *)(v11 + 8));
  }
LABEL_21:
  a5(a6, 0, v16);
LABEL_22:
  FigXPCRelease(*(xpc_object_t *)v23);
  if (v19)
    CFRelease(v19);
}

void figCustomURLHandlerRemote_shimCancelRequestCallback(uint64_t a1, uint64_t a2, const __CFDictionary *a3, uint64_t a4)
{
  uint64_t DerivedStorage;
  uint64_t v7;
  uint64_t v8;
  xpc_object_t xdict;
  CFTypeRef cf;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  xdict = 0;
  cf = 0;
  if (!*(_BYTE *)(DerivedStorage + 40))
  {
    v7 = DerivedStorage;
    if (!FigCustomURLRequestInfoCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3, &cf))
    {
      v8 = FigCustomURLRequestInfoSetNetworkHistory((__CFDictionary *)cf, 0);
      if ((_DWORD)v8)
      {
        FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
      }
      else if (!FigCustomURLRequestInfoMakeNSSecureCodingTypesSerializable((const __CFDictionary *)cf)
             && !FigXPCCreateBasicMessage(0x63684352u, *(_QWORD *)(v7 + 32), &xdict))
      {
        xpc_dictionary_set_uint64(xdict, "CustomURLHandler_RequestID", a4);
        FigXPCMessageSetCFDictionary(xdict, "CustomURLHandler_RequestInfo", cf);
        FigXPCRemoteClientSendAsyncMessage(*(_QWORD *)v7, xdict);
      }
    }
  }
  if (cf)
    CFRelease(cf);
  FigXPCRelease(xdict);
}

void figCustomURLHandler_handleDataCallbackMessageWithRegisteredRequestInfo(uint64_t a1, uint64_t a2, const __CFData *a3, int a4, const void *a5, const void *a6, const void *a7, NSObject *a8, uint64_t a9, CFTypeRef a10)
{
  uint64_t DerivedStorage;
  void **BytePtr;
  void *v19;
  const __CFAllocator *v20;
  int uint64;
  char v22;
  uint64_t v23;
  CFTypeRef v24;
  unsigned int (*v25)(uint64_t, uint64_t, CFTypeRef);
  CFTypeRef v26;
  CFTypeRef v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t, CFTypeRef);
  int v30;
  uint64_t v31;
  CFTypeRef v32;
  void (*v33)(uint64_t, uint64_t, CFTypeRef, CFTypeRef);
  CFTypeRef cf;
  CFTypeRef v35;
  CFTypeRef v36;
  CFTypeRef v37;
  CFTypeRef v38;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v37 = 0;
  v38 = 0;
  v35 = 0;
  v36 = 0;
  cf = 0;
  BytePtr = (void **)CFDataGetBytePtr(a3);
  if (a4)
    goto LABEL_26;
  v19 = *BytePtr;
  v20 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (!FigXPCMessageCreateBlockBufferData((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *BytePtr, "CustomURLHandler_BlockBuffer", (CMBlockBufferRef *)&v36))
  {
    uint64 = xpc_dictionary_get_uint64(v19, "CustomURLHandler_CallbackFlags");
    if (!FigXPCMessageCopyCFError(v19, "CustomURLHandler_Error", (const __CFDictionary **)&v35))
    {
      v22 = uint64;
      if ((uint64 & 1) == 0 || !FigXPCMessageCopyCFDictionary(v19, "CustomURLHandler_FinalReport", &cf))
      {
        if (a6
          || !FigXPCMessageCopyCFDictionary(v19, "CustomURLHandler_ResponseInfo", &v38)
          && (!v38
           || !FigCustomURLResponseInfoCreateMutableCopy(v20, (CFDictionaryRef)v38, (CFMutableDictionaryRef *)&v37)&& !FigCustomURLResponseInfoDeserializeNSSecureCodingTypes((void *)v37)&& (v23 = *(_QWORD *)(DerivedStorage + 16), v24 = v37, (v25 = *(unsigned int (**)(uint64_t, uint64_t, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable(v23)+ 16)+ 8)) != 0)&& !v25(v23, a2, v24)))
        {
          v26 = v36;
          if (v36 || (uint64 & 0xFFFFFFFE) != 0 || (v27 = v35) != 0 && (v22 & 1) == 0)
          {
            v28 = *(_QWORD *)(DerivedStorage + 16);
            v29 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable(v28) + 16)
                                                                        + 16);
            if (v29)
            {
              v30 = v29(v28, a2, v26);
              if ((v22 & 1) != 0 && !v30)
              {
                v27 = v35;
                goto LABEL_22;
              }
            }
          }
          else if ((v22 & 1) != 0)
          {
LABEL_22:
            v31 = *(_QWORD *)(DerivedStorage + 16);
            v32 = cf;
            v33 = *(void (**)(uint64_t, uint64_t, CFTypeRef, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable(v31)
                                                                                            + 16)
                                                                                + 24);
            if (v33)
              v33(v31, a2, v27, v32);
          }
        }
      }
    }
  }
  if (cf)
    CFRelease(cf);
LABEL_26:
  if (v35)
    CFRelease(v35);
  if (v36)
    CFRelease(v36);
  if (v38)
    CFRelease(v38);
  if (v37)
    CFRelease(v37);
  if (a5)
    CFRelease(a5);
  if (a6)
    CFRelease(a6);
  if (a7)
    CFRelease(a7);
  if (a8)
    dispatch_release(a8);
  if (a10)
    CFRelease(a10);
}

uint64_t dataCallbackMessageRec_initializeCFAllocatorOnce(_QWORD *a1)
{
  uint64_t result;
  CFTypeRef v3;

  v3 = 0;
  result = FigCreateCFAllocatorFigMallocWithDeallocCallback((void (__cdecl *)(void *, void *))dataCallbackMessageRec_dealloc, &v3);
  if (!(_DWORD)result)
    *a1 = v3;
  return result;
}

void dataCallbackMessageRec_dealloc(xpc_object_t *a1)
{
  FigXPCRelease(*a1);
  free(a1);
}

uint64_t figCustomURLHandlerRemote_Invalidate(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v2;
  uint64_t (*v3)(uint64_t);

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v2 = *(_QWORD *)(DerivedStorage + 16);
  if (!v2)
    return 4294954516;
  v3 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(*(_QWORD *)(DerivedStorage + 16)) + 8)
                                         + 24);
  if (v3)
    return v3(v2);
  else
    return 4294954514;
}

void figCustomURLHandlerRemote_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v3;
  const void *v4;
  NSObject *v5;
  void *v6;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v3 = *(const void **)(DerivedStorage + 32);
  v6 = 0;
  figCustomURLHandlerRemote_Invalidate(a1);
  if (!*(_BYTE *)(DerivedStorage + 40))
  {
    if (!*(_QWORD *)DerivedStorage)
      goto LABEL_7;
    FigXPCRemoteClientDisassociateObject(*(_QWORD *)DerivedStorage, v3);
    if (!FigXPCCreateBasicMessage(0x63684469u, (uint64_t)v3, &v6))
      FigXPCRemoteClientSendAsyncMessage(*(_QWORD *)DerivedStorage, v6);
  }
  if (*(_QWORD *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(_QWORD *)DerivedStorage = 0;
  }
LABEL_7:
  v4 = *(const void **)(DerivedStorage + 16);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(DerivedStorage + 16) = 0;
  }
  v5 = *(NSObject **)(DerivedStorage + 24);
  if (v5)
  {
    dispatch_release(v5);
    *(_QWORD *)(DerivedStorage + 24) = 0;
  }
  FigXPCRelease(v6);
}

uint64_t figCustomURLHandlerRemote_HandleRequest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t (*v16)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  v15 = *(_QWORD *)(CMBaseObjectGetDerivedStorage(a1) + 16);
  v16 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v15) + 16) + 32);
  if (v16)
    return v16(v15, a2, a3, a4, a5, a6, a7, a8);
  else
    return 4294954514;
}

uint64_t figCustomURLHandlerRemote_CancelRequest(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t (*v4)(uint64_t, uint64_t);

  v3 = *(_QWORD *)(CMBaseObjectGetDerivedStorage(a1) + 16);
  v4 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v3) + 16) + 40);
  if (v4)
    return v4(v3, a2);
  else
    return 4294954514;
}

uint64_t figCustomURLHandlerRemote_RequestSetDormant(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t);

  v5 = *(_QWORD *)(CMBaseObjectGetDerivedStorage(a1) + 16);
  v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v5) + 16) + 48);
  if (v6)
    return v6(v5, a2, a3);
  else
    return 4294954514;
}

uint64_t figCustomURLHandlerRemote_lookupAndRetainRegisteredInfoForRequestID(const void *a1, uint64_t a2, uint64_t a3, const void *a4)
{
  uint64_t DerivedStorage;
  const __CFAllocator *v9;
  const UInt8 *v10;
  UInt8 *v11;
  CFDataRef v12;
  CFDataRef v13;
  CFTypeRef v14;
  CFTypeRef v15;
  uint64_t v16;
  uint64_t (*v17)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t, CFDataRef, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), CFDataRef);
  uint64_t v18;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (remoteHandlerLookupAndRetainRec_getCFAllocator_sOnceToken != -1)
    dispatch_once_f(&remoteHandlerLookupAndRetainRec_getCFAllocator_sOnceToken, &remoteHandlerLookupAndRetainRec_getCFAllocator_sAllocator, (dispatch_function_t)remoteHandlerLookupAndRetainRec_initializeCFAllocatorOnce);
  v9 = (const __CFAllocator *)remoteHandlerLookupAndRetainRec_getCFAllocator_sAllocator;
  if (!remoteHandlerLookupAndRetainRec_getCFAllocator_sAllocator)
  {
    v18 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    if ((_DWORD)v18)
      return v18;
  }
  v10 = (const UInt8 *)malloc_type_calloc(1uLL, 0x18uLL, 0xE0040C2B16B6AuLL);
  if (v10)
  {
    v11 = (UInt8 *)v10;
    v12 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v10, 24, v9);
    if (v12)
    {
      v13 = v12;
      if (a1)
        v14 = CFRetain(a1);
      else
        v14 = 0;
      *(_QWORD *)v11 = v14;
      *((_QWORD *)v11 + 1) = a3;
      if (a4)
        v15 = CFRetain(a4);
      else
        v15 = 0;
      *((_QWORD *)v11 + 2) = v15;
      v16 = *(_QWORD *)(DerivedStorage + 16);
      v17 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t, CFDataRef, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), CFDataRef))(*(_QWORD *)(CMBaseObjectGetVTable(v16) + 16) + 56);
      if (v17)
        v18 = v17(v16, a2, figCustomURLHandlerRemote_shimLookupAndRetainRegisteredInfoCallback, v13);
      else
        v18 = 4294954514;
      CFRelease(v13);
      return v18;
    }
    free(v11);
  }
  return FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
}

uint64_t figCustomURLHandlerRemote_shimLookupAndRetainRegisteredInfoCallback(int a1, uint64_t a2, CFDataRef theData, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  const UInt8 *BytePtr;

  BytePtr = CFDataGetBytePtr(theData);
  return (*((uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))BytePtr
          + 1))(*(_QWORD *)BytePtr, a2, *((_QWORD *)BytePtr + 2), a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t remoteHandlerLookupAndRetainRec_initializeCFAllocatorOnce(_QWORD *a1)
{
  uint64_t result;
  CFTypeRef v3;

  v3 = 0;
  result = FigCreateCFAllocatorFigMallocWithDeallocCallback((void (__cdecl *)(void *, void *))remoteHandlerLookupAndRetainRec_dealloc, &v3);
  if (!(_DWORD)result)
    *a1 = v3;
  return result;
}

void remoteHandlerLookupAndRetainRec_dealloc(const void **a1)
{
  const void *v2;
  const void *v3;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  v3 = a1[2];
  if (v3)
    CFRelease(v3);
  free(a1);
}

uint64_t __figCustomURLHandlerRemote_shimHandleRequestCallback_block_invoke(uint64_t a1, uint64_t a2, xpc_object_t xdict)
{
  _BOOL8 v5;

  if ((_DWORD)a2)
    v5 = 0;
  else
    v5 = xpc_dictionary_get_BOOL(xdict, "CustomURLHandler_CanHandleResult");
  return (*(uint64_t (**)(_QWORD, _BOOL8, uint64_t))(a1 + 32))(*(_QWORD *)(a1 + 40), v5, a2);
}

void *NeroValeriaListenerCreate(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  int started;
  int v5;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v7;
  uint64_t v8;
  unsigned int v9;
  char *v10;
  uint64_t CMBaseObject;
  uint64_t (*v12)(uint64_t, const __CFString *, const __CFString *);
  uint64_t v13;
  const void *LocalRootObject;
  os_log_type_t type;
  int v17;
  _QWORD v18[6];
  CFTypeRef cf;
  int v20;
  const char *v21;
  __int16 v22;
  int v23;
  char v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  cf = 0;
  if (!in_audio_mx_server_process() || !FigIsAirplaydEnabled())
    return 0;
  if (a1)
  {
    v2 = malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 0x40000000;
    v18[2] = __NeroValeriaListenerCreate_block_invoke;
    v18[3] = &unk_1E28DDAE8;
    v18[4] = a1;
    v18[5] = v2;
    *((_QWORD *)v2 + 1) = dispatch_queue_create("com.apple.coremedia.NeroValeriaListener", 0);
    v3 = *MEMORY[0x1E0C9AE00];
    started = FigTransportConnectionUSBCreate(*MEMORY[0x1E0C9AE00], &cf);
    if (started)
    {
LABEL_5:
      v5 = started;
      goto LABEL_6;
    }
    CMBaseObject = NeroTransportConnectionGetCMBaseObject(cf);
    v12 = *(uint64_t (**)(uint64_t, const __CFString *, const __CFString *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                                + 8)
                                                                                    + 56);
    if (v12)
    {
      started = v12(CMBaseObject, CFSTR("USBInterfaceName"), CFSTR("Valeria"));
      if (!started)
      {
        started = NeroTransportCreate(v3, cf, (uint64_t *)v2);
        if (!started)
        {
          v13 = *(_QWORD *)v2;
          LocalRootObject = (const void *)FigTransportGetLocalRootObject();
          started = NeroTransportRegisterObject(v13, LocalRootObject, *((NSObject **)v2 + 1), v18, 0);
          if (!started)
            started = NeroTransportStartAcceptingConnections(*(_QWORD *)v2);
        }
      }
      goto LABEL_5;
    }
    v5 = -12782;
  }
  else
  {
    v2 = 0;
    v5 = -12780;
  }
LABEL_6:
  if (cf)
    CFRelease(cf);
  if (v5)
  {
    v17 = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, &v17, &type);
    v7 = v17;
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v9 = v7;
    else
      v9 = v7 & 0xFFFFFFFE;
    if (v9)
    {
      v20 = 136315394;
      v21 = "NeroValeriaListenerCreate";
      v22 = 1024;
      v23 = v5;
      v10 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v7) = v17;
    }
    else
    {
      v10 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v10, v10 != &v24, v7, 0, v8);
    NeroValeriaListenerDestroy((CFTypeRef *)v2);
    return 0;
  }
  return v2;
}

void NeroValeriaListenerDestroy(CFTypeRef *a1)
{
  CFTypeRef v2;
  NSObject *v3;

  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      NeroTransportInvalidate((uint64_t)v2);
      if (*a1)
      {
        CFRelease(*a1);
        *a1 = 0;
      }
    }
    v3 = a1[1];
    if (v3)
      dispatch_release(v3);
    free(a1);
  }
}

void NeroValeriaListenerSetActiveStatus(uint64_t a1, char a2)
{
  NSObject *v2;
  _QWORD v3[5];
  char v4;

  if (a1)
  {
    v2 = *(NSObject **)(a1 + 8);
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 0x40000000;
    v3[2] = __NeroValeriaListenerSetActiveStatus_block_invoke;
    v3[3] = &__block_descriptor_tmp_3_2;
    v4 = a2;
    v3[4] = a1;
    dispatch_async(v2, v3);
  }
}

uint64_t FigTransportSessionGetClassID()
{
  if (FigTransportSessionGetClassID_sRegisterOnce != -1)
    dispatch_once_f(&FigTransportSessionGetClassID_sRegisterOnce, &FigTransportSessionGetClassID_sClassID, (dispatch_function_t)session_getClassID);
  return FigTransportSessionGetClassID_sClassID;
}

uint64_t session_getClassID(_QWORD *a1)
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&session_getClassID_sClassDesc, ClassID, 1, a1);
}

uint64_t FigTransportSessionGetTypeID()
{
  if (FigTransportSessionGetClassID_sRegisterOnce != -1)
    dispatch_once_f(&FigTransportSessionGetClassID_sRegisterOnce, &FigTransportSessionGetClassID_sClassID, (dispatch_function_t)session_getClassID);
  return CMBaseClassGetCFTypeID((_QWORD *)FigTransportSessionGetClassID_sClassID);
}

CFStringRef session_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigTransportSession %p]"), a1);
}

uint64_t FigEndpointStreamAirPlayGetClassID()
{
  if (FigEndpointStreamAirPlayGetClassID_sRegisterFigEndpointStreamAirPlayBaseTypeOnce != -1)
    dispatch_once_f(&FigEndpointStreamAirPlayGetClassID_sRegisterFigEndpointStreamAirPlayBaseTypeOnce, &FigEndpointStreamAirPlayGetClassID_sFigEndpointStreamAirPlayClassID, (dispatch_function_t)FigEndpointStreamAirPlayGetClassIDCallback);
  return FigEndpointStreamAirPlayGetClassID_sFigEndpointStreamAirPlayClassID;
}

uint64_t FigEndpointStreamAirPlayGetClassIDCallback(_QWORD *a1)
{
  _QWORD *ClassID;

  ClassID = (_QWORD *)FigEndpointStreamGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&FigEndpointStreamAirPlayGetClassIDCallback_sFigEndpointStreamAirPlayClassDesc, ClassID, 0, a1);
}

CFStringRef FigEndpointStreamAirPlayBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigEndpointStreamAirPlay %p]"), a1);
}

uint64_t FigAudioDeviceClockServerStart()
{
  const char *v1;
  _OWORD v2[3];

  v2[0] = xmmword_1E28DDBF8;
  memset(&v2[1], 0, 32);
  if (FigServer_IsMediaparserd())
    return FigSignalErrorAt(4294951145, 0, 0, 0, 0, 0, 0);
  if (FigServer_IsMediaplaybackd())
    v1 = "com.apple.coremedia.mediaplaybackd.audiodeviceclock.xpc";
  else
    v1 = "com.apple.coremedia.audiodeviceclock.xpc";
  return FigXPCServerStart((uint64_t)v1, (uint64_t)v2, 0, &gAudioDeviceClockServer);
}

uint64_t HandleAudioDeviceClockMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t OpCode;
  AudioDeviceID int64;
  uint64_t v8;
  const __CFAllocator *v9;
  uint64_t v10;
  uint64_t uint64;
  CFTypeID v12;
  uint64_t AnchorTime;
  CFTypeRef v14;
  CMClockRef HostTimeClock;
  double RelativeRate;
  uint64_t AudioDevice;
  int v19;
  CFTypeRef cf;
  CMTime value;
  CMTime clockOut;
  CMTime clockTimeOut;

  cf = 0;
  v19 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v19);
  if ((_DWORD)OpCode)
    goto LABEL_33;
  if (v19 == 1668441400)
  {
    clockTimeOut.value = 0;
    clockOut.value = 0;
    value.value = 0;
    int64 = xpc_dictionary_get_int64(a2, "DeviceID");
    v8 = FigXPCMessageCopyCFString(a2, "DeviceUID", &clockTimeOut);
    if ((_DWORD)v8)
    {
      AnchorTime = v8;
    }
    else
    {
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (int64)
        v10 = CMAudioDeviceClockCreateFromAudioDeviceID(v9, int64, (CMClockRef *)&clockOut);
      else
        v10 = CMAudioDeviceClockCreate(v9, (CFStringRef)clockTimeOut.value, (CMClockRef *)&clockOut);
      AnchorTime = v10;
      if (!(_DWORD)v10)
      {
        AnchorTime = FigXPCServerAssociateObjectWithConnection(a1, (const void *)clockOut.value, 0, 0, 0, (unint64_t *)&value);
        if (!(_DWORD)AnchorTime)
          xpc_dictionary_set_uint64(a3, ".objectID", value.value);
      }
    }
    if (clockTimeOut.value)
      CFRelease((CFTypeRef)clockTimeOut.value);
    if (clockOut.value)
      CFRelease((CFTypeRef)clockOut.value);
    goto LABEL_29;
  }
  uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  OpCode = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, 0);
  if ((_DWORD)OpCode)
    goto LABEL_33;
  if (!cf || (v12 = CFGetTypeID(cf), v12 != CMClockGetTypeID()))
  {
    OpCode = FigSignalErrorAt(4294954550, 0, 0, 0, 0, 0, 0);
    goto LABEL_33;
  }
  AnchorTime = 4294951138;
  if (v19 > 1734632821)
  {
    if (v19 != 1734632822)
    {
      if (v19 != 1735549300)
        goto LABEL_29;
      v14 = cf;
      HostTimeClock = CMClockGetHostTimeClock();
      RelativeRate = CMSyncGetRelativeRate(v14, HostTimeClock);
      xpc_dictionary_set_double(a3, "Rate", RelativeRate);
      goto LABEL_26;
    }
    clockTimeOut.value = 0;
    LODWORD(clockOut.value) = 0;
    LOBYTE(value.value) = 0;
    AudioDevice = CMAudioDeviceClockGetAudioDevice((CMClockRef)cf, (CFStringRef *)&clockTimeOut, (AudioDeviceID *)&clockOut, (Boolean *)&value);
    OpCode = FigXPCMessageSetCFString(a3, "DeviceUID", (CFTypeRef)clockTimeOut.value);
    if (!(_DWORD)OpCode)
    {
      xpc_dictionary_set_int64(a3, "DeviceID", LODWORD(clockOut.value));
      xpc_dictionary_set_BOOL(a3, "TrackDefaultDevice", LOBYTE(value.value) != 0);
      xpc_dictionary_set_int64(a3, "LoadStatus", (int)AudioDevice);
      AnchorTime = AudioDevice;
      goto LABEL_29;
    }
LABEL_33:
    AnchorTime = OpCode;
    goto LABEL_29;
  }
  if (v19 == 1685024621)
  {
    FigXPCServerDisassociateObjectWithConnection(a1, uint64);
LABEL_26:
    AnchorTime = 0;
    goto LABEL_29;
  }
  if (v19 == 1734438507)
  {
    memset(&clockTimeOut, 0, sizeof(clockTimeOut));
    memset(&clockOut, 0, sizeof(clockOut));
    AnchorTime = CMClockGetAnchorTime((CMClockRef)cf, &clockTimeOut, &clockOut);
    if (!(_DWORD)AnchorTime)
    {
      value = clockTimeOut;
      FigXPCMessageSetCMTime(a3, "ClockTime", &value);
      value = clockOut;
      FigXPCMessageSetCMTime(a3, "RefClockTime", &value);
      xpc_dictionary_set_int64(a3, "LoadStatus", 0);
    }
  }
LABEL_29:
  if (cf)
    CFRelease(cf);
  return AnchorTime;
}

uint64_t FigXPCAudioDeviceClockServerAssociateCopiedNeighborClock(xpc_connection_t connection, const void *a2, _QWORD *a3)
{
  return FigXPCServerAssociateCopiedObjectWithNeighborProcess(gAudioDeviceClockServer, connection, a2, 0, 0, 0, a3);
}

uint64_t FigXPCAudioDeviceClockServerAssociateNeighborClock(xpc_connection_t connection, const void *a2, _QWORD *a3)
{
  return FigXPCServerAssociateObjectWithNeighborProcess(gAudioDeviceClockServer, connection, a2, 0, 0, 0, a3);
}

uint64_t FigXPCAudioDeviceClockServerCopyClockForID(void *a1, _QWORD *a2)
{
  return FigXPCServerRetainNeighborObjectFromID((uint64_t *)gAudioDeviceClockServer, a1, a2);
}

uint64_t FigAudioDeviceClockServer_MakeWrapperForClock(const void *a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, _QWORD *a6)
{
  *a5 = 0;
  return FigXPCServerAssociateObjectWithNeighborProcessByPID(gAudioDeviceClockServer, a4, a1, 0, 0, 0, a6);
}

uint64_t FigAudioDeviceClockServer_MakeWrapperForClockWithManualCommandPortSendRightInsertion(const void *a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, _QWORD *a6)
{
  *a5 = 0;
  return FigXPCServerAssociateObjectWithNeighborProcessByPID(gAudioDeviceClockServer, a4, a1, 0, 0, 0, a6);
}

uint64_t FigAudioDeviceClockServer_LookupAndRetainSubClock(void *a1, _QWORD *a2)
{
  return FigXPCServerRetainNeighborObjectFromID((uint64_t *)gAudioDeviceClockServer, a1, a2);
}

uint64_t CMGetDMVersionLevelFromRPU()
{
  const __CFData *v0;
  size_t Length;
  const UInt8 *BytePtr;
  _BYTE v4[29609];
  unsigned __int8 v5;

  v0 = (const __CFData *)MEMORY[0x1E0C80A78]();
  bzero(v4, 0x73B0uLL);
  if (!v0)
    return 0;
  Length = CFDataGetLength(v0);
  BytePtr = CFDataGetBytePtr(v0);
  if (FigHEVCBridge_GetRPUMetadata(BytePtr, Length, (uint64_t)v4) || !v4[29130])
    return 0;
  if (v5 <= 2u)
    return v5 + 2;
  return 0;
}

BOOL FigTagHasSInt64Value(uint64_t a1)
{
  return (a1 & 0xBFFFFFFF00000000) == 0x200000000;
}

Boolean CMTagHasSInt64Value(CMTag tag)
{
  return (*(_QWORD *)&tag.category & 0xBFFFFFFF00000000) == 0x200000000;
}

CMTagDataType CMTagGetValueDataType(CMTag tag)
{
  return tag.dataType & 0xBFFFFFFF;
}

uint64_t FigTagGetSInt64Value(uint64_t a1, uint64_t a2)
{
  return a2;
}

int64_t CMTagGetSInt64Value(CMTag tag)
{
  return tag.value;
}

BOOL FigTagHasFloat64Value(uint64_t a1)
{
  return (a1 & 0xBFFFFFFF00000000) == 0x300000000;
}

Boolean CMTagHasFloat64Value(CMTag tag)
{
  return (*(_QWORD *)&tag.category & 0xBFFFFFFF00000000) == 0x300000000;
}

double FigTagGetFloat64Value(uint64_t a1, uint64_t a2)
{
  return *(double *)&a2;
}

Float64 CMTagGetFloat64Value(CMTag tag)
{
  return *(double *)&tag.value;
}

BOOL FigTagHasOSTypeValue(uint64_t a1)
{
  return (a1 & 0xBFFFFFFF00000000) == 0x500000000;
}

Boolean CMTagHasOSTypeValue(CMTag tag)
{
  return (*(_QWORD *)&tag.category & 0xBFFFFFFF00000000) == 0x500000000;
}

uint64_t FigTagGetOSTypeValue(uint64_t a1, uint64_t a2)
{
  return a2;
}

OSType CMTagGetOSTypeValue(CMTag tag)
{
  return tag.value;
}

BOOL FigTagHasFlagsValue(uint64_t a1)
{
  return (a1 & 0xBFFFFFFF00000000) == 0x700000000;
}

Boolean CMTagHasFlagsValue(CMTag tag)
{
  return (*(_QWORD *)&tag.category & 0xBFFFFFFF00000000) == 0x700000000;
}

uint64_t FigTagGetFlagsValue(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t CMTagGetFlagsValue(CMTag tag)
{
  return tag.value;
}

uint64_t FigTagMakeWithSInt64Value(unsigned int a1)
{
  return a1 | 0x200000000;
}

CMTag CMTagMakeWithSInt64Value(CMTagCategory category, int64_t value)
{
  uint64_t v2;
  CMTag result;

  v2 = category | 0x200000000;
  result.value = value;
  result.category = v2;
  result.dataType = HIDWORD(v2);
  return result;
}

uint64_t FigTagMakeWithFloat64Value(unsigned int a1)
{
  return a1 | 0x300000000;
}

CMTag CMTagMakeWithFloat64Value(CMTagCategory category, Float64 value)
{
  uint64_t v3;
  CMTag result;

  v3 = category | 0x300000000;
  *(Float64 *)&result.value = value;
  result.category = v3;
  result.dataType = HIDWORD(v3);
  return result;
}

uint64_t FigTagMakeWithOSTypeValue(unsigned int a1)
{
  return a1 | 0x500000000;
}

CMTag CMTagMakeWithOSTypeValue(CMTagCategory category, OSType value)
{
  uint64_t v2;
  uint64_t v3;
  CMTag result;

  v2 = value;
  v3 = category | 0x500000000;
  result.category = v3;
  result.dataType = HIDWORD(v3);
  LODWORD(result.value) = value;
  return result;
}

uint64_t FigTagMakeWithFlagsValue(unsigned int a1)
{
  return a1 | 0x700000000;
}

CMTag CMTagMakeWithFlagsValue(CMTagCategory category, uint64_t flagsForTag)
{
  uint64_t v2;
  CMTag result;

  v2 = category | 0x700000000;
  result.value = flagsForTag;
  result.category = v2;
  result.dataType = HIDWORD(v2);
  return result;
}

CFHashCode CMTagHash(CMTag tag)
{
  unint64_t v1;
  unint64_t v2;
  unsigned __int32 v4;
  CMTag v5;

  v5 = tag;
  v4 = tag.dataType & 0xBFFFFFFF;
  if ((tag.dataType & 0xBFFFFFFF) != 0)
    v1 = _CMTagCFHashBytes((uint64_t)&v5.value, 8);
  else
    v1 = 0x1000000;
  v2 = (_CMTagCFHashBytes((uint64_t)&v4, 4) + (v1 << 6) + (v1 >> 2) + 2654435769u) ^ v1;
  return (_CMTagCFHashBytes((uint64_t)&v5, 4) + (v2 << 6) + (v2 >> 2) + 2654435769u) ^ v2;
}

uint64_t _CMTagCFHashBytes(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned __int8 *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  BOOL v10;
  int v11;
  int v12;
  int v13;

  if ((int)a2 < 4)
  {
    v2 = 0;
    v9 = a2;
  }
  else
  {
    v2 = 0;
    v3 = (unsigned __int8 *)((a2 & 0xFFFFFFFF00000000) + a1 + 1);
    v4 = a2;
    do
    {
      v5 = *(v3 - 1) + 16 * v2;
      v6 = *v3 + 16 * (v5 ^ (16 * (v5 >> 28)));
      v7 = v3[1] + 16 * (v6 ^ (16 * (v6 >> 28)));
      v8 = v3[2] + 16 * (v7 ^ (16 * (v7 >> 28)));
      v2 = (v8 ^ ((v8 & 0xF0000000) >> 24)) & ~(v8 & 0xF0000000);
      v9 = v4 - 4;
      v3 += 4;
      v10 = v4 > 7;
      v4 -= 4;
    }
    while (v10);
  }
  switch(v9)
  {
    case 1u:
      goto LABEL_11;
    case 2u:
LABEL_10:
      v12 = *(unsigned __int8 *)(a2 + a1 - 2) + 16 * v2;
      v2 = (v12 ^ ((v12 & 0xF0000000) >> 24)) & ~(v12 & 0xF0000000);
LABEL_11:
      v13 = *(unsigned __int8 *)(a2 + a1 - 1) + 16 * v2;
      return (v13 ^ ((v13 & 0xF0000000) >> 24)) & ~(v13 & 0xF0000000);
    case 3u:
      v11 = *(unsigned __int8 *)(a2 + a1 - 3) + 16 * v2;
      v2 = (v11 ^ ((v11 & 0xF0000000) >> 24)) & ~(v11 & 0xF0000000);
      goto LABEL_10;
  }
  return v2;
}

BOOL FigTagEqualToTag(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _BOOL4 v5;

  v5 = ((a3 ^ a1) & 0xBFFFFFFF00000000) == 0 && a2 == a4;
  return (_DWORD)a1 == (_DWORD)a3 && v5;
}

Boolean CMTagEqualToTag(CMTag tag1, CMTag tag2)
{
  Boolean v3;

  v3 = ((*(_QWORD *)&tag2.category ^ *(_QWORD *)&tag1.category) & 0xBFFFFFFF00000000) == 0 && tag1.value == tag2.value;
  if (tag1.category == tag2.category)
    return v3;
  else
    return 0;
}

CFComparisonResult CMTagCompare(CMTag tag1, CMTag tag2)
{
  unsigned __int32 v3;
  CFComparisonResult v4;
  CFComparisonResult v5;

  if ((int)tag1.category < (int)tag2.category)
    return -1;
  if (tag1.category != tag2.category)
    return 1;
  v3 = tag1.dataType & 0xBFFFFFFF;
  if ((int)(tag1.dataType & 0xBFFFFFFF) < (int)(tag2.dataType & 0xBFFFFFFF))
    return -1;
  if (v3 != (tag2.dataType & 0xBFFFFFFF))
    return 1;
  v4 = (unint64_t)(tag1.value > tag2.value);
  if (tag1.value < tag2.value)
    v4 = kCFCompareLessThan;
  v5 = (unint64_t)(*(double *)&tag1.value > *(double *)&tag2.value);
  if (*(double *)&tag1.value < *(double *)&tag2.value)
    v5 = kCFCompareLessThan;
  if (v3 == 3)
    return v5;
  else
    return v4;
}

CFStringRef CMTagCopyDescription(CFAllocatorRef allocator, CMTag tag)
{
  CMTagValue value;
  unint64_t v3;
  __CFString *Mutable;
  __CFString *v5;
  unint64_t v6;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;

  value = tag.value;
  v3 = *(_QWORD *)&tag.category;
  Mutable = CFStringCreateMutable(allocator, 0);
  v5 = Mutable;
  if (Mutable)
  {
    v9 = bswap32(v3);
    CFStringAppendFormat(Mutable, 0, CFSTR("{"));
    CFStringAppendFormat(v5, 0, CFSTR("category:'%.4s'"), &v9);
    v6 = HIDWORD(v3);
    if (v6)
    {
      CFStringAppendFormat(v5, 0, CFSTR(" value:"));
      switch(v6 & 0xBFFFFFFF)
      {
        case 0uLL:
          CFStringAppendFormat(v5, 0, CFSTR("<invalid>"), v8);
          break;
        case 2uLL:
          CFStringAppendFormat(v5, 0, CFSTR("%lld <int64>"), value);
          break;
        case 3uLL:
          CFStringAppendFormat(v5, 0, CFSTR("%0.2f <Flt64>"), value);
          break;
        case 5uLL:
          v10 = bswap32(value);
          CFStringAppendFormat(v5, 0, CFSTR("'%.4s' <OSType>"), &v10);
          break;
        case 7uLL:
          CFStringAppendFormat(v5, 0, CFSTR("0x%llx <flags>"), value);
          break;
        default:
          CFStringAppendFormat(v5, 0, CFSTR("<raw:0x%0llu type:%d>"), value, v6 & 0xBFFFFFFF);
          break;
      }
      CFStringAppendFormat(v5, 0, CFSTR("}"));
    }
    else
    {
      CFStringAppendFormat(v5, 0, CFSTR("{INVALID}"));
    }
  }
  return v5;
}

CFDictionaryRef CMTagCopyAsDictionary(CMTag tag, CFAllocatorRef allocator)
{
  CMTagValue value;
  CMTagDataType dataType;
  const __CFAllocator *v5;
  const __CFDictionary *v6;
  uint64_t i;
  const void *v8;
  void *values;
  CFNumberRef SInt32;
  CFNumberRef SInt64;
  void *keys[2];
  const __CFString *v14;
  uint64_t v15;

  value = tag.value;
  dataType = tag.dataType;
  v15 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)keys = xmmword_1E28DDC58;
  v14 = CFSTR("value");
  SInt32 = 0;
  SInt64 = 0;
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  values = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E0C9AE00], tag.category);
  if (values
    && (SInt32 = FigCFNumberCreateSInt32(v5, dataType & 0xBFFFFFFF)) != 0
    && (SInt64 = FigCFNumberCreateSInt64(v5, value)) != 0)
  {
    v6 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)&values, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!v6)
      FigSignalErrorAt(4294951565, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    FigSignalErrorAt(4294951565, 0, 0, 0, 0, 0, 0);
    v6 = 0;
  }
  for (i = 0; i != 24; i += 8)
  {
    v8 = *(void **)((char *)&values + i);
    if (v8)
      CFRelease(v8);
  }
  return v6;
}

CMTag CMTagMakeFromDictionary(CFDictionaryRef dict)
{
  CFTypeID v2;
  CMTagValue v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  CMTagValue v7;
  uint64_t v8;
  CMTag result;

  if (dict)
  {
    v2 = CFGetTypeID(dict);
    if (v2 == CFDictionaryGetTypeID()
      && (v7 = 0,
          v8 = 0,
          FigCFDictionaryGetInt32IfPresent((uint64_t)dict, CFSTR("category"), (char *)&v8 + 4))
      && FigCFDictionaryGetInt32IfPresent((uint64_t)dict, CFSTR("flags"), &v8)
      && FigCFDictionaryGetInt64IfPresent((uint64_t)dict, CFSTR("value"), &v7))
    {
      v3 = v7;
      v4 = HIDWORD(v8);
      v5 = (unint64_t)v8 << 32;
    }
    else
    {
      v5 = 0;
      v3 = 0;
      v4 = 0;
    }
  }
  else
  {
    v5 = 0;
    v3 = 0;
    v4 = 0;
  }
  v6 = v4 | v5;
  result.value = v3;
  result.category = v6;
  result.dataType = HIDWORD(v6);
  return result;
}

void *FigTagCopyAsXPCDictionary(unint64_t a1, uint64_t a2)
{
  xpc_object_t empty;
  void *v5;

  empty = xpc_dictionary_create_empty();
  v5 = empty;
  if (empty)
  {
    xpc_dictionary_set_uint64(empty, "CMTagCategory", a1);
    xpc_dictionary_set_uint64(v5, "CMTagDataType", HIDWORD(a1) & 0xFFFFFFFFBFFFFFFFLL);
    xpc_dictionary_set_uint64(v5, "CMTagValue", a2);
  }
  else
  {
    FigSignalErrorAt(4294951565, 0, 0, 0, 0, 0, 0);
  }
  return v5;
}

uint64_t FigTagMakeFromXPCDictionary(void *a1)
{
  uint64_t uint64;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;

  if (a1)
  {
    uint64 = xpc_dictionary_get_uint64(a1, "CMTagCategory");
    v3 = xpc_dictionary_get_uint64(a1, "CMTagDataType");
    xpc_dictionary_get_uint64(a1, "CMTagValue");
    v4 = HIDWORD(uint64);
    if (HIDWORD(v3))
      v5 = 0;
    else
      v5 = v3 << 32;
    if (HIDWORD(v3))
      v6 = 0;
    else
      v6 = uint64;
    v7 = v4 == 0;
    if (v4)
      v8 = 0;
    else
      v8 = v5;
    if (v7)
      v9 = v6;
    else
      v9 = 0;
  }
  else
  {
    v8 = 0;
    v9 = 0;
  }
  return v9 | v8;
}

uint64_t FigNote_CopyRingBufferBacking()
{
  return 4294950613;
}

uint64_t FigNote_AllowInternalDefaultLogs()
{
  if (FigNote_AllowInternalDefaultLogs_onceToken != -1)
    dispatch_once_f(&FigNote_AllowInternalDefaultLogs_onceToken, 0, (dispatch_function_t)fig_note_initialize_allow_internal_default_logs);
  return gAllowInternalDefaultLogs;
}

uint64_t fig_note_initialize_allow_internal_default_logs()
{
  uint64_t result;

  result = FigDebugIsInternalBuild();
  gAllowInternalDefaultLogs = result;
  return result;
}

char *fig_get_timestamp(uint64_t a1, char *__str, size_t __size)
{
  if (a1 == 2)
  {
    fig_get_offsetTimeStamp(__str, __size);
  }
  else if (a1 == 1)
  {
    FigCFGetLocalTimeString(__str, __size);
  }
  else
  {
    snprintf(__str, __size, " ");
  }
  return __str;
}

char *fig_get_offsetTimeStamp(char *a1, size_t a2)
{
  int v4;
  __darwin_time_t v5;
  int v6;
  __darwin_suseconds_t tv_usec;
  BOOL v8;
  uint64_t v9;
  timeval v11;

  v11.tv_sec = 0;
  *(_QWORD *)&v11.tv_usec = 0;
  gettimeofday(&v11, 0);
  v4 = v11.tv_usec - dword_1ECDA88A0;
  if (v11.tv_usec - dword_1ECDA88A0 < 0)
  {
    if (v4 <= -1000000)
      v4 = -1000000;
    v6 = dword_1ECDA88A0 + v4;
    if (v6 == v11.tv_usec)
      tv_usec = v11.tv_usec;
    else
      tv_usec = v11.tv_usec + 1;
    v8 = v6 == v11.tv_usec;
    LODWORD(v9) = (v6 - tv_usec) / 0xF4240u;
    if (v8)
      v9 = v9;
    else
      v9 = (v9 + 1);
    v5 = v11.tv_sec + ~sStartTime - v9;
    v4 = v11.tv_usec + 1000000 * v9 + 1000000 - dword_1ECDA88A0;
  }
  else
  {
    v5 = v11.tv_sec - sStartTime;
  }
  snprintf(a1, a2, "%02d:%02d.%06d", v5 / 60, v5 % 60, v4);
  return a1;
}

uint64_t fig_log_emitter_get_os_log(uint64_t *a1, BOOL *a2, BOOL *a3)
{
  uint64_t result;
  BOOL v8;

  FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
  if (!a1 || (result = *a1) == 0)
    result = *fig_log_get_emitter("com.apple.coremedia", "");
  if (a2)
    *a2 = (gFigLogControl & 0xFFFFFFFE) == 8;
  if (a3)
  {
    v8 = gFigLogControl != 8 || byte_1EE13FDB1 != 0;
    *a3 = v8;
  }
  return result;
}

_QWORD *fig_log_get_emitter(const char *a1, const char *a2)
{
  const char *v4;
  CFStringRef v5;
  _QWORD *Value;
  const __CFAllocator *AllocatorForPermanentAllocations;
  CFStringRef Copy;
  malloc_zone_t *MallocZoneForPermanentAllocations;

  if (fig_log_get_emitter_onceToken != -1)
    dispatch_once(&fig_log_get_emitter_onceToken, &__block_literal_global_8);
  if (!a1)
    a1 = "com.apple.coremedia";
  if (a2)
    v4 = a2;
  else
    v4 = "";
  v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%s-%s"), a1, v4);
  os_unfair_lock_lock((os_unfair_lock_t)&fig_log_get_emitter_lock);
  Value = CFDictionaryGetValue((CFDictionaryRef)fig_log_get_emitter_emitterTable, v5);
  if (!Value)
  {
    AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
    Copy = CFStringCreateCopy(AllocatorForPermanentAllocations, v5);
    MallocZoneForPermanentAllocations = (malloc_zone_t *)FigGetMallocZoneForPermanentAllocations();
    Value = malloc_type_zone_calloc(MallocZoneForPermanentAllocations, 1uLL, 8uLL, 0x2004093837F09uLL);
    *Value = os_log_create(a1, v4);
    CFDictionarySetValue((CFMutableDictionaryRef)fig_log_get_emitter_emitterTable, Copy, Value);
    CFRelease(Copy);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&fig_log_get_emitter_lock);
  if (v5)
    CFRelease(v5);
  return Value;
}

uint64_t fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(uint64_t *a1, int a2, int *a3, _BYTE *a4)
{
  uint64_t os_log_and_send_and_compose_flags;

  os_log_and_send_and_compose_flags = fig_log_emitter_get_os_log_and_send_and_compose_flags(a1, a3);
  if (a4)
    *a4 = fig_log_get_os_log_type(a2);
  return os_log_and_send_and_compose_flags;
}

uint64_t fig_log_emitter_get_os_log_and_send_and_compose_flags(uint64_t *a1, int *a2)
{
  uint64_t result;
  int v4;
  __int16 v5;

  v5 = 0;
  result = fig_log_emitter_get_os_log(a1, (BOOL *)&v5 + 1, (BOOL *)&v5);
  if (a2)
  {
    v4 = 2 * ((_BYTE)v5 != 0);
    *a2 = v4;
    if (HIBYTE(v5))
      *a2 = v4 | 1;
  }
  return result;
}

uint64_t fig_log_get_os_log_type(int a1)
{
  if (a1)
  {
    if (a1 == 2)
      return 16;
    else
      return 0;
  }
  else
  {
    if (FigNote_AllowInternalDefaultLogs_onceToken != -1)
      dispatch_once_f(&FigNote_AllowInternalDefaultLogs_onceToken, 0, (dispatch_function_t)fig_note_initialize_allow_internal_default_logs);
    if (gAllowInternalDefaultLogs)
      return 16;
    else
      return 16 * FigServer_ShouldLogFigErrorsAsErrorsInThisProcess();
  }
}

void fig_log_call_emit_and_clean_up_after_send_and_compose(uint64_t *a1, unsigned __int16 a2, char a3, void *a4, uint64_t a5, char a6, uint64_t a7, uint64_t a8)
{
  int v8;

  if ((a6 & 2) != 0)
  {
    v8 = a5;
    fig_log_emit(a1, a2, a3 | 8, 0, a5, "%s", a7, a8, (uint64_t)a4);
    if (v8)
      free(a4);
  }
}

void fig_log_emit(uint64_t *a1, unsigned __int16 a2, char a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  BOOL v9;

  if (gFigLogControl)
    v9 = (a4 | (unint64_t)a6) == 0;
  else
    v9 = 1;
  if (!v9)
  {
    if (!a4)
      a3 |= 4u;
    fig_log_internal(a1, a2, a3, a4, a6, (CFIndex)&a9);
  }
}

void fig_log_internal(uint64_t *a1, unsigned __int16 a2, char a3, uint64_t a4, const char *a5, CFIndex a6)
{
  int v6;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  _BOOL4 v22;
  char *v23;
  char v24;
  __CFString *v25;
  char *v26;
  char *v27;
  size_t v28;
  char *v29;
  size_t v30;
  int64_t v31;
  int v32;
  size_t v33;
  int v34;
  const char *v35;
  char *v36;
  const char *v37;
  int v38;
  size_t v39;
  size_t v40;
  char *v41;
  size_t v42;
  int v43;
  const __CFString *v44;
  __CFString *Mutable;
  BOOL v46;
  const char **v47;
  char *CStringPtrMaybeUsingPreallocatedBuffer;
  int v49;
  size_t v50;
  CFIndex Length;
  NSObject *v52;
  NSObject *os_log;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  NSObject *v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  size_t v71;
  unsigned int v72;
  unint64_t v73;
  uint64_t v75;
  CFIndex v76;
  CMBlockBufferRef *v77;
  int v78;
  int v79;
  unsigned __int16 v80;
  CFIndex rangea;
  char *v83;
  const __CFString *theStringa;
  uint64_t *v86;
  uint64_t *v87;
  _BOOL4 v88;
  void *v89;
  size_t lengthAtOffsetOut;
  va_list arguments;
  unsigned int destination;
  CFIndex usedBufLen;
  char __src[511];
  char v95;
  CMBlockBufferRef blockBufferOut[4];
  int v97;
  __int16 v98;
  int v99;
  __int16 v100;
  int v101;
  __int16 v102;
  unsigned int v103;
  uint64_t v104;
  CFRange v105;
  CFRange v106;

  v104 = *MEMORY[0x1E0C80C00];
  v6 = gFigLogControl;
  v89 = 0;
  if (!gFigLogControl)
    goto LABEL_148;
  v12 = byte_1EE13FDB1;
  v13 = a2;
  FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
  fig_log_get_os_log_type(v13);
  fig_log_emitter_get_os_log(a1, 0, 0);
  v80 = a2;
  if (v12)
    goto LABEL_3;
  if (v6 == 7)
  {
    if (a4 || (a3 & 4) != 0)
    {
      if (!a4)
      {
        os_log_with_args();
        goto LABEL_148;
      }
      v25 = 0;
      v22 = 0;
      v23 = 0;
LABEL_79:
      os_log_pack_send();
      goto LABEL_87;
    }
  }
  else
  {
    if (v6 != 8)
    {
LABEL_3:
      if (a4)
      {
        if ((a3 & 3) != 0)
        {
          memset(blockBufferOut, 0, sizeof(blockBufferOut));
          fig_get_timestamp(a3 & 3, (char *)blockBufferOut, 0x20uLL);
          v21 = safe_snprintf_0(__src, v14, v15, v16, v17, v18, v19, v20, (char)blockBufferOut);
        }
        else
        {
          v21 = 0;
        }
        v26 = (char *)os_log_pack_compose();
        if (v26 == &__src[v21]
          || (v27 = v26, v28 = strlen(v26), (v29 = (char *)malloc_type_malloc(v21 + v28 + 1, 0x46F9E220uLL)) == 0))
        {
          v23 = __src;
        }
        else
        {
          v23 = v29;
          if (v21)
            memcpy(v29, __src, v21);
          v30 = strlen(v27);
          memcpy(&v23[v21], v27, v30 + 1);
          free(v27);
        }
        v25 = 0;
        v22 = v23 != __src;
        goto LABEL_65;
      }
      goto LABEL_21;
    }
    v22 = 0;
    v23 = 0;
    v24 = 1;
    v25 = 0;
    if (a4 || (a3 & 0xC) != 0)
    {
LABEL_70:
      if ((a3 & 8) != 0)
        goto LABEL_87;
      if (!a4)
      {
        if ((v24 & 1) != 0)
          os_log_with_args();
        else
LABEL_83:
          fig_os_log_with_args();
        goto LABEL_87;
      }
      goto LABEL_79;
    }
  }
LABEL_21:
  if (!a5)
    goto LABEL_148;
  usedBufLen = a6;
  memset(blockBufferOut, 0, sizeof(blockBufferOut));
  v78 = a3 & 3;
  if ((a3 & 3) != 0)
  {
    v77 = blockBufferOut;
    fig_get_timestamp(a3 & 3, (char *)blockBufferOut, 0x20uLL);
  }
  else
  {
    v77 = 0;
  }
  v79 = v12;
  v86 = a1;
  v31 = strlen(a5);
  if (v31 < 1)
  {
    v36 = __src;
    goto LABEL_49;
  }
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = &a5[v31];
  v36 = __src;
  v37 = a5;
  while (1)
  {
    v38 = *(unsigned __int8 *)v37;
    if (!v34)
    {
      if (v38 != 123 || v32 != 37)
      {
        ++v33;
        *v36 = v38;
        if (v33 == 511)
          break;
LABEL_42:
        v34 = 0;
        goto LABEL_43;
      }
LABEL_40:
      v34 = 1;
      goto LABEL_43;
    }
    if (v38 != 125)
      goto LABEL_40;
    if ((unint64_t)(v35 - v37) >= 4)
      v39 = 4;
    else
      v39 = v35 - v37;
    if (strncmp("}*.P", v37, v39))
      goto LABEL_42;
    v40 = v33 - 1;
    v41 = &__src[v33 - 1];
    v42 = 512 - v33 >= 8 ? 8 : 512 - v33;
    strncpy(v41, "(%zu) %p", v42);
    v33 = v42 + v40;
    if (v33 == 511)
      break;
    v34 = 0;
    v37 += 3;
LABEL_43:
    v43 = *(unsigned __int8 *)v37++;
    v32 = v43;
    v36 = &__src[v33];
    if (v37 >= v35)
      goto LABEL_49;
  }
  v36 = &v95;
LABEL_49:
  *v36 = 0;
  arguments = (va_list)usedBufLen;
  v44 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __src, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  Mutable = CFStringCreateMutable(0, 0);
  v25 = Mutable;
  if (v44)
    v46 = Mutable == 0;
  else
    v46 = 1;
  if (v46)
  {
    a1 = v86;
    v12 = v79;
    if (v44)
      goto LABEL_61;
  }
  else
  {
    a1 = v86;
    v12 = v79;
    if (v78)
      CFStringAppendFormat(Mutable, 0, CFSTR("[%s] "), v77);
    if (FigCFEqual(v44, CFSTR("%s")))
    {
      v47 = (const char **)arguments;
      arguments += 8;
      CFStringAppendCString(v25, *v47, 0x8000100u);
    }
    else
    {
      CFStringAppendFormatAndArguments(v25, 0, v44, arguments);
    }
LABEL_61:
    CFRelease(v44);
  }
  CStringPtrMaybeUsingPreallocatedBuffer = (char *)FigCFStringGetCStringPtrMaybeUsingPreallocatedBuffer((const char *)v25, __src, 1536, 0x8000100u);
  if (!CStringPtrMaybeUsingPreallocatedBuffer)
    CStringPtrMaybeUsingPreallocatedBuffer = FigCFStringGetCStringPtrAndBufferToFree(v25, 0x8000100u, (char **)&v89);
  v23 = CStringPtrMaybeUsingPreallocatedBuffer;
  v22 = 0;
LABEL_65:
  v24 = 0;
  switch(v6)
  {
    case 1:
      if ((v80 & 0xFFFD) != 0)
        v49 = 5;
      else
        v49 = 3;
      syslog(v49, "%s", v23);
      break;
    case 2:
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "%s\n", v23);
      break;
    case 3:
      puts(v23);
      break;
    case 4:
      goto LABEL_86;
    case 5:
      blockBufferOut[0] = 0;
      v50 = strlen(v23);
      if (!CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v50 + 2, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, v50 + 2, 1u, blockBufferOut))
      {
        CMBlockBufferReplaceDataBytes(v23, blockBufferOut[0], 0, v50);
        CMBlockBufferReplaceDataBytes("\n", blockBufferOut[0], v50, 2uLL);
        dispatch_async_f((dispatch_queue_t)sNoteBBufQueue, blockBufferOut[0], (dispatch_function_t)append_and_release_noteBBuf);
      }
      break;
    case 7:
      if (a4)
        goto LABEL_79;
      goto LABEL_83;
    case 8:
      goto LABEL_70;
    case 9:
      if ((a3 & 8) == 0)
      {
        if (a4)
          os_log_pack_send();
        else
          os_log_with_args();
      }
LABEL_86:
      fig_note_write_to_external_log_file(v23);
      break;
    default:
      break;
  }
LABEL_87:
  if (v12 && v25)
  {
    v88 = v22;
    Length = CFStringGetLength(v25);
    usedBufLen = 0;
    destination = 0;
    lengthAtOffsetOut = 0;
    arguments = 0;
    if (pthread_self() == (pthread_t)qword_1EE13FDA8)
    {
      os_log = fig_log_emitter_get_os_log(a1, 0, 0);
      if (os_log_type_enabled(os_log, OS_LOG_TYPE_ERROR))
        fig_log_internal_cold_1(os_log);
    }
    else
    {
      FigReadWriteLockLockForRead(sFigNoteRingBufferState);
      if (qword_1EE13FDB8)
      {
        v105.location = 0;
        v105.length = Length;
        CFStringGetBytes(v25, v105, 0x8000100u, 0, 0, 0, 0, &usedBufLen);
        usedBufLen += 4;
        if (usedBufLen <= (unint64_t)qword_1EE13FDC8)
        {
          rangea = Length;
          v83 = v23;
          theStringa = v25;
          v87 = a1;
          v54 = 0x7FFFFFFFFFFFFFFFLL;
          v55 = 0x1EE13F000uLL;
          v56 = 0x7FFFFFFFFFFFFFFFLL;
          while (1)
          {
LABEL_97:
            v57 = v56;
            v56 = *(_QWORD *)(v55 + 3520);
            v58 = (v57 >> 42) & 0x1FFFFF;
            v59 = (v56 >> 42) & 0x1FFFFF;
            v60 = v56;
            if ((_DWORD)v58 == (_DWORD)v59)
            {
              v61 = v55;
              v62 = (v57 >> 21) & 0x1FFFFF;
              v63 = v57 & 0x1FFFFF;
              if ((_DWORD)v62 == ((v56 >> 21) & 0x1FFFFF) && v63 == (v56 & 0x1FFFFF))
              {
                v65 = fig_log_emitter_get_os_log(v87, 0, 0);
                if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                {
                  LODWORD(blockBufferOut[0]) = 134219776;
                  *(CMBlockBufferRef *)((char *)blockBufferOut + 4) = (CMBlockBufferRef)qword_1EE13FDC8;
                  WORD2(blockBufferOut[1]) = 1024;
                  *(_DWORD *)((char *)&blockBufferOut[1] + 6) = v63;
                  WORD1(blockBufferOut[2]) = 1024;
                  HIDWORD(blockBufferOut[2]) = v62;
                  LOWORD(blockBufferOut[3]) = 1024;
                  *(_DWORD *)((char *)&blockBufferOut[3] + 2) = v58;
                  HIWORD(blockBufferOut[3]) = 1024;
                  v97 = v54 & 0x1FFFFF;
                  v98 = 1024;
                  v99 = (v54 >> 21) & 0x1FFFFF;
                  v100 = 1024;
                  v101 = (v54 >> 42) & 0x1FFFFF;
                  v102 = 1024;
                  v103 = destination;
                  _os_log_error_impl(&dword_18EC8D000, v65, OS_LOG_TYPE_ERROR, "Ring buffer (size %zu) contained unrecoverable garbage when going from (oldest:%d loop:%d latest:%d) to (oldest:%d loop:%d latest:%d). Last log size read from buffer was %u", (uint8_t *)blockBufferOut, 0x36u);
                }
                LODWORD(v59) = 0x1FFFFF;
                v60 = v54 & 0x8000000000000000 | 0x7FFFFC00001FFFFFLL;
              }
              else
              {
                v59 = (v57 >> 42) & 0x1FFFFF;
                v60 = v56;
              }
              v55 = v61;
            }
            v66 = v60 & 0xFFFFFFFFFFE00000;
            if ((_DWORD)v59 == 0x1FFFFF)
              v67 = 0;
            else
              v67 = v59;
            if ((_DWORD)v59 != 0x1FFFFF)
              v66 = v60;
            v68 = ((_DWORD)v67 + (_DWORD)usedBufLen) & 0x1FFFFF;
            v69 = v66 & 0x8000000000000000;
            v70 = v66 & 0x800003FFFFFFFFFFLL | ((((int)v67 + (int)usedBufLen) & 0x1FFFFFLL) << 42);
            if (qword_1EE13FDC8 < v68)
              v71 = 0;
            else
              v71 = v67;
            if (qword_1EE13FDC8 < v68)
              v70 = (v69 | (v67 << 21)) & 0x800003FFFFFFFFFFLL | ((usedBufLen & 0x1FFFFF) << 42);
            v54 = ((v70 >> 42) & 0x1FFFFF) <= ((v70 >> 21) & 0x1FFFFF)
                ? v70
                : v70 & 0xFFFFFC00001FFFFFLL | (((v70 >> 42) & 0x1FFFFF) << 21);
            if ((_DWORD)v59 == 0x1FFFFF)
              break;
            v72 = v54 & 0x1FFFFF;
            if (v71 > (v54 & 0x1FFFFF))
              break;
            while (1)
            {
              if (v72 >= ((v54 >> 42) & 0x1FFFFF))
                goto LABEL_122;
              CMBlockBufferCopyDataBytes((CMBlockBufferRef)qword_1EE13FDB8, v54 & 0x1FFFFF, 4uLL, &destination);
              if (destination < 4)
                break;
              if (qword_1EE13FDC8 < (unint64_t)destination
                || (v54 & 0x1FFFFF) > qword_1EE13FDC8 - (unint64_t)destination)
              {
                break;
              }
              v75 = (destination + (_DWORD)v54) & 0x1FFFFF;
              if (v75 >= ((v56 >> 21) & 0x1FFFFF))
                v54 = (v54 >> 21) & 0x3FFFFE00000 | v54 & 0xFFFFFC0000000000;
              else
                v54 = v54 & 0xFFFFFFFFFFE00000 | v75;
              v72 = v54 & 0x1FFFFF;
              if ((int)v71 > (int)(v54 & 0x1FFFFF))
                goto LABEL_122;
            }
          }
          do
          {
LABEL_122:
            v73 = __ldxr((unint64_t *)&qword_1EE13FDC0);
            if (v73 != v56)
            {
              __clrex();
              goto LABEL_97;
            }
          }
          while (__stxr(v54, (unint64_t *)&qword_1EE13FDC0));
          CMBlockBufferReplaceDataBytes(&usedBufLen, (CMBlockBufferRef)qword_1EE13FDB8, v71, 4uLL);
          CMBlockBufferGetDataPointer((CMBlockBufferRef)qword_1EE13FDB8, v71 + 4, &lengthAtOffsetOut, 0, &arguments);
          if (lengthAtOffsetOut >= usedBufLen)
            v76 = usedBufLen;
          else
            v76 = lengthAtOffsetOut;
          v25 = (__CFString *)theStringa;
          v106.location = 0;
          v106.length = rangea;
          CFStringGetBytes(theStringa, v106, 0x8000100u, 0, 0, (UInt8 *)arguments, v76, 0);
          v23 = v83;
        }
        else
        {
          v52 = fig_log_emitter_get_os_log(a1, 0, 0);
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
            fig_log_internal_cold_2(&usedBufLen, v52);
        }
      }
      FigReadWriteLockUnlockForRead(sFigNoteRingBufferState);
    }
    v22 = v88;
  }
  if (v22)
    free(v23);
  if (v25)
    CFRelease(v25);
LABEL_148:
  free(v89);
}

void fig_log(unsigned __int16 a1, char a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a5)
  {
    if (gFigLogControl)
      fig_log_internal(0, a1, a2 | 4, 0, a5, (CFIndex)&a9);
  }
}

void fig_log_with_return_address(uint64_t *a1, unsigned __int16 a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, const char *a7, uint64_t a8, uint64_t a9)
{
  if (a7)
  {
    if (gFigLogControl)
      fig_log_internal(a1, a2, a3 | 4, 0, a7, (CFIndex)&a9);
  }
}

void fig_log_CF1(unsigned __int16 a1, char a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a5)
  {
    if (gFigLogControl)
      fig_log_internal(0, a1, a2, 0, a5, (CFIndex)&a9);
  }
}

void fig_post_a_symptom_guts(uint64_t a1)
{
  NSObject *v2;

  if (fig_post_a_symptom_guts_onceToken != -1)
    dispatch_once(&fig_post_a_symptom_guts_onceToken, &__block_literal_global_29);
  v2 = fig_post_a_symptom_guts_sFigLogOSLogSymptom;
  if (os_log_type_enabled((os_log_t)fig_post_a_symptom_guts_sFigLogOSLogSymptom, OS_LOG_TYPE_ERROR))
    fig_post_a_symptom_guts_cold_1(a1, v2);
}

uint64_t __fig_post_a_symptom_guts_block_invoke()
{
  fig_post_a_symptom_guts_sFigLogOSLogSymptom = (uint64_t)os_log_create("com.apple.coremedia", "Symptoms");
  return FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
}

_QWORD *fig_log_handle()
{
  _QWORD *result;

  result = fig_log_get_emitter("com.apple.coremedia", "");
  if (result)
    return (_QWORD *)*result;
  return result;
}

CFMutableDictionaryRef __fig_log_get_emitter_block_invoke()
{
  CFMutableDictionaryRef result;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], 0);
  fig_log_get_emitter_emitterTable = (uint64_t)result;
  return result;
}

_QWORD *fig_log_get_excessive_emitter_for_subsystem(const char *a1)
{
  return fig_log_get_emitter(a1, "excessive");
}

void fig_note_initialize_category_with_default_work_cf(uint64_t a1, const __CFString *a2, const __CFString *a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, _QWORD *a8)
{
  uint64_t v15;
  const __CFString *v16;
  const __CFString *v17;
  int v18;
  CFTypeID v19;
  CFTypeID v20;
  CFTypeID v21;
  _QWORD v22[6];
  uint64_t v23;
  uint64_t v24;

  FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
  FigThreadRunOnce(&sFigNoteInit, (void (*)(void))fig_note_init_timestamps_once);
  v23 = 0;
  v24 = 0;
  v22[0] = a3;
  v22[1] = a2;
  v22[2] = a5;
  v22[3] = a4;
  v22[4] = a1;
  v22[5] = a6;
  if (initialize_fignote_variable_registry_sInitRegistryOnce != -1)
    dispatch_once_f(&initialize_fignote_variable_registry_sInitRegistryOnce, 0, (dispatch_function_t)initialize_fignote_variable_registry_once);
  dispatch_sync_f((dispatch_queue_t)gFigNoteVariableRegistry_0, v22, (dispatch_function_t)perform_fignote_variable_registration);
  v15 = v23;
  if ((_BYTE)v24 && v23)
  {
    v16 = (const __CFString *)CFPreferencesCopyAppValue(a2, a3);
    v17 = v16;
    v18 = gAllowAutomaticFigNotes;
    if (gAllowAutomaticFigNotes)
      v18 = *(_DWORD *)(v15 + 16);
    **(_DWORD **)(v15 + 8) = v18;
    if (v16)
    {
      v19 = CFGetTypeID(v16);
      if (v19 == CFStringGetTypeID())
      {
        LODWORD(v22[0]) = 0;
        if (!fig_note_get_value_for_string_preference(v17, (int *)v22))
          goto LABEL_16;
      }
      else
      {
        v20 = CFGetTypeID(v17);
        if (v20 != CFNumberGetTypeID())
        {
          v21 = CFGetTypeID(v17);
          if (v21 == CFBooleanGetTypeID())
            **(_DWORD **)(v15 + 8) = CFEqual(v17, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
          goto LABEL_16;
        }
        LODWORD(v22[0]) = 0;
        if (!CFNumberGetValue((CFNumberRef)v17, kCFNumberIntType, v22))
        {
LABEL_16:
          CFRelease(v17);
          goto LABEL_17;
        }
      }
      **(_DWORD **)(v15 + 8) = v22[0];
      goto LABEL_16;
    }
  }
LABEL_17:
  if (a8)
  {
    if (v15)
      *a8 = *(_QWORD *)v15;
  }
}

void fig_note_initialize_category_with_default_work(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, _QWORD *a8)
{
  const __CFAllocator *v14;
  const __CFString *v15;
  const __CFString *v16;
  uint64_t v17;

  v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v15 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, 0x8000100u);
  v16 = CFStringCreateWithCString(v14, a3, 0x8000100u);
  fig_note_initialize_category_with_default_work_cf(a1, v15, v16, a4, a5, a6, v17, a8);
  if (v15)
    CFRelease(v15);
  if (v16)
    CFRelease(v16);
}

void fig_note_initialize_with_default_work(uint64_t a1, const char *a2, const char *a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  fig_note_initialize_category_with_default_work(a1, a2, a3, (uint64_t)"", (uint64_t)"com.apple.coremedia", a4, a7, 0);
}

uint64_t FigNote_OneTimeInitializationForMediaServerd()
{
  CFIndex AppIntegerValue;
  uint64_t v1;
  Boolean keyExistsAndHasValidFormat;

  if (initialize_fignote_variable_registry_sInitRegistryOnce != -1)
    dispatch_once_f(&initialize_fignote_variable_registry_sInitRegistryOnce, 0, (dispatch_function_t)initialize_fignote_variable_registry_once);
  sRunningInMediaserverd = 1;
  keyExistsAndHasValidFormat = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("rpc_timeout"), CFSTR("com.apple.coremedia"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
    v1 = 1000000 * AppIntegerValue;
  else
    v1 = 9000000000;
  FigRPCServer_SetTimeoutNanoseconds(v1);
  FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
  return fig_note_read_control_preferences();
}

uint64_t fig_note_read_control_preferences()
{
  const __CFString *v0;
  const __CFString *v1;
  CFTypeID v2;
  CFTypeID v3;
  BOOL v4;
  unint64_t v5;
  int v6;
  CFTypeID v7;
  SInt32 IntValue;
  int v9;
  const __CFString *v10;
  const __CFString *v11;
  CFTypeID v12;
  char v13;
  CFTypeID v14;
  CFTypeID v16;
  int v17;
  int v18;
  int valuePtr;

  FigReentrantMutexLock((pthread_mutex_t *)gFigLogControlMutex);
  v0 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("fig_notes"), CFSTR("com.apple.coremedia"));
  if (v0)
  {
    v1 = v0;
    v2 = CFGetTypeID(v0);
    if (v2 == CFStringGetTypeID())
    {
      fig_note_close_external_log_file();
      if (CFStringCompare(v1, CFSTR("true"), 1uLL)
        && CFStringCompare(v1, CFSTR("yes"), 1uLL)
        && CFStringCompare(v1, CFSTR("on"), 1uLL)
        && CFStringCompare(v1, CFSTR("oslog"), 1uLL))
      {
        if (CFStringCompare(v1, CFSTR("syslog"), 1uLL) == kCFCompareEqualTo)
        {
          gFigLogControl = 1;
          goto LABEL_28;
        }
        if (CFStringCompare(v1, CFSTR("stderr"), 1uLL))
        {
          if (CFStringCompare(v1, CFSTR("stdout"), 1uLL))
          {
            if (CFStringCompare(v1, CFSTR("external"), 1uLL) == kCFCompareEqualTo
              || CFStringCompare(v1, CFSTR("external_no_echo_oslog"), 1uLL) == kCFCompareEqualTo
              || CFStringCompare(v1, CFSTR("public"), 1uLL) == kCFCompareEqualTo && sRunningInMediaserverd)
            {
              fig_note_configure_external_log_file(v1);
LABEL_28:
              CFRelease(v1);
              goto LABEL_29;
            }
            if (CFStringCompare(v1, CFSTR("bbuf"), 1uLL))
            {
              if (CFStringCompare(v1, CFSTR("ring"), 1uLL))
              {
                IntValue = CFStringGetIntValue(v1);
                goto LABEL_23;
              }
              v5 = 0x1EE13F000;
              v6 = 6;
            }
            else
            {
              if (!sNoteBBufQueue)
              {
                sNoteBBufQueue = (uint64_t)dispatch_queue_create("com.apple.coremedia.fignote", 0);
                CMBlockBufferCreateEmpty((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0x100u, 0, (CMBlockBufferRef *)&sNoteBBuf);
              }
              v5 = 0x1EE13F000;
              v6 = 5;
            }
          }
          else
          {
            v5 = 0x1EE13F000;
            v6 = 3;
          }
        }
        else
        {
          v5 = 0x1EE13F000;
          v6 = 2;
        }
      }
      else
      {
        v5 = 0x1EE13F000uLL;
        v6 = 8;
      }
      *(_DWORD *)(v5 + 3480) = v6;
      goto LABEL_28;
    }
    v3 = CFGetTypeID(v1);
    if (v3 == CFNumberGetTypeID())
    {
      valuePtr = 0;
      CFNumberGetValue((CFNumberRef)v1, kCFNumberIntType, &valuePtr);
      v4 = valuePtr == 0;
LABEL_24:
      v9 = !v4;
      gFigLogControl = 8 * v9;
      goto LABEL_28;
    }
    v7 = CFGetTypeID(v1);
    if (v7 != CFBooleanGetTypeID())
      goto LABEL_28;
    IntValue = CFEqual(v1, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
LABEL_23:
    v4 = IntValue == 0;
    goto LABEL_24;
  }
  fig_note_close_external_log_file();
  if (gFigLogControl != 8)
    gFigLogControl = 8;
LABEL_29:
  v10 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("automatic_fig_notes"), CFSTR("com.apple.coremedia"));
  gAllowAutomaticFigNotes = 1;
  if (v10)
  {
    v11 = v10;
    v12 = CFGetTypeID(v10);
    if (v12 == CFStringGetTypeID())
    {
      v18 = 0;
      if (!fig_note_get_value_for_string_preference(v11, &v18))
      {
LABEL_36:
        CFRelease(v11);
        return FigReentrantMutexUnlock((pthread_mutex_t *)gFigLogControlMutex);
      }
      v13 = v18;
    }
    else
    {
      v14 = CFGetTypeID(v11);
      if (v14 != CFNumberGetTypeID())
      {
        v16 = CFGetTypeID(v11);
        if (v16 == CFBooleanGetTypeID())
          gAllowAutomaticFigNotes = CFEqual(v11, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
        goto LABEL_36;
      }
      v17 = 0;
      CFNumberGetValue((CFNumberRef)v11, kCFNumberIntType, &v17);
      v13 = v17 != 0;
    }
    gAllowAutomaticFigNotes = v13;
    goto LABEL_36;
  }
  return FigReentrantMutexUnlock((pthread_mutex_t *)gFigLogControlMutex);
}

uint64_t FigNote_RefreshControlPreferences()
{
  FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
  return fig_note_read_control_preferences();
}

uint64_t FigNote_CopyAndClearNoteBBuf()
{
  return 0;
}

uint64_t FigNote_ChangeValue(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  BOOL v4;
  _QWORD v6[7];
  int v7;
  unsigned int v8;

  v3 = 4294950614;
  v8 = -16682;
  if (gFigNoteVariableRegistry_0)
    v4 = gFigNoteVariableRegistry_1 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __FigNote_ChangeValue_block_invoke;
    v6[3] = &__block_descriptor_tmp_11_1;
    v6[4] = a1;
    v6[5] = a2;
    v7 = a3;
    v6[6] = &v8;
    dispatch_sync((dispatch_queue_t)gFigNoteVariableRegistry_0, v6);
    return v8;
  }
  return v3;
}

uint64_t FigNote_GetValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  BOOL v4;
  _QWORD block[8];
  unsigned int v7;

  v3 = 4294950614;
  v7 = -16682;
  if (gFigNoteVariableRegistry_0)
    v4 = gFigNoteVariableRegistry_1 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __FigNote_GetValue_block_invoke;
    block[3] = &__block_descriptor_tmp_12_1;
    block[4] = a1;
    block[5] = a2;
    block[6] = a3;
    block[7] = &v7;
    dispatch_sync((dispatch_queue_t)gFigNoteVariableRegistry_0, block);
    return v7;
  }
  return v3;
}

uint64_t FigNote_ConfigureRingBuffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = fignote_initialize_ringlog();
  if ((_DWORD)v2)
    return v2;
  if (a1 && !*(_QWORD *)a1)
  {
    FigReadWriteLockLockForWrite(sFigNoteRingBufferState);
    qword_1EE13FDA8 = (uint64_t)pthread_self();
    v3 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v3)
    {
      if (v3 >= 0x200000)
      {
        v4 = FigSignalErrorAt(4294950616, 0, 0, 0, 0, 0, 0);
LABEL_11:
        qword_1EE13FDA8 = 0;
        FigReadWriteLockUnlockForWrite(sFigNoteRingBufferState);
        return v4;
      }
    }
    else
    {
      v3 = 0x100000;
    }
    qword_1EE13FDC8 = v3;
    if (byte_1EE13FDB1)
    {
      fig_note_dropRingBufferDataStructuresInternal();
      fig_note_makeRingBufferDataStructuresInternal();
    }
    v4 = 0;
    goto LABEL_11;
  }
  return FigSignalErrorAt(4294950616, 0, 0, 0, 0, 0, 0);
}

uint64_t fignote_initialize_ringlog()
{
  if (fignote_initialize_ringlog_initializeLogRingBuffer != -1)
    dispatch_once_f(&fignote_initialize_ringlog_initializeLogRingBuffer, 0, (dispatch_function_t)initialize_logRingBuffer);
  if (byte_1EE13FDB0)
    return 0;
  else
    return 4294950613;
}

void fig_note_dropRingBufferDataStructuresInternal()
{
  if (qword_1EE13FDB8)
  {
    CFRelease((CFTypeRef)qword_1EE13FDB8);
    qword_1EE13FDB8 = 0;
  }
  else
  {
    FigSignalErrorAt(4294950616, 0, 0, 0, 0, 0, 0);
  }
}

uint64_t fig_note_makeRingBufferDataStructuresInternal()
{
  uint64_t result;

  if (qword_1EE13FDB8)
    return FigSignalErrorAt(4294950616, 0, 0, 0, 0, 0, 0);
  result = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, qword_1EE13FDC8, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, qword_1EE13FDC8, 1u, (CMBlockBufferRef *)&qword_1EE13FDB8);
  if (!(_DWORD)result)
    atomic_store(0x7FFFFC00001FFFFFuLL, (unint64_t *)&qword_1EE13FDC0);
  return result;
}

uint64_t FigNote_EnableRingBuffer(int a1)
{
  uint64_t v2;

  v2 = fignote_initialize_ringlog();
  if (!(_DWORD)v2)
  {
    FigReadWriteLockLockForWrite(sFigNoteRingBufferState);
    qword_1EE13FDA8 = (uint64_t)pthread_self();
    if (!a1 || byte_1EE13FDB1)
    {
      if (!a1 && byte_1EE13FDB1)
        fig_note_dropRingBufferDataStructuresInternal();
    }
    else
    {
      fig_note_makeRingBufferDataStructuresInternal();
    }
    byte_1EE13FDB1 = a1;
    qword_1EE13FDA8 = 0;
    FigReadWriteLockUnlockForWrite(sFigNoteRingBufferState);
  }
  return v2;
}

uint64_t FigNote_CopyRingBufferLogArrayAndResetRing(__CFArray **a1, int a2)
{
  uint64_t result;
  unint64_t v5;
  CFTypeRef v6;
  void *v7;
  int v8;
  const __CFAllocator *v9;
  const __CFAllocator *v10;
  BOOL v11;
  BOOL v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  const __CFAllocator *AllocatorForMedia;
  CFStringRef v18;
  CFStringRef v19;
  __CFArray **v21;
  __CFArray *theArray;
  char *dataPointerOut;
  size_t lengthAtOffsetOut;
  int destination;
  CFAllocatorContext context;

  result = fignote_initialize_ringlog();
  if (!(_DWORD)result)
  {
    FigReadWriteLockLockForWrite(sFigNoteRingBufferState);
    qword_1EE13FDA8 = (uint64_t)pthread_self();
    v5 = atomic_load((unint64_t *)&qword_1EE13FDC0);
    if (qword_1EE13FDB8 && (v6 = CFRetain((CFTypeRef)qword_1EE13FDB8)) != 0)
    {
      v7 = (void *)v6;
      if (!a2 || (v5 & 0x1FFFFF) != 0x1FFFFF)
      {
        fig_note_dropRingBufferDataStructuresInternal();
        if (a2)
          fig_note_makeRingBufferDataStructuresInternal();
        else
          byte_1EE13FDB1 = 0;
      }
      qword_1EE13FDA8 = 0;
      FigReadWriteLockUnlockForWrite(sFigNoteRingBufferState);
      v8 = v5 & 0x1FFFFF;
      if ((v5 & 0x1FFFFF) != 0x1FFFFF)
      {
        v21 = a1;
        context.version = 0;
        memset(&context.retain, 0, 40);
        context.info = v7;
        context.deallocate = (CFAllocatorDeallocateCallBack)fig_log_ring_backing_deallocator;
        context.preferredSize = 0;
        v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v10 = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &context);
        v11 = v8 == 0;
        v12 = v8 != 0;
        theArray = CFArrayCreateMutable(v9, 0, MEMORY[0x1E0C9B378]);
        v13 = 0;
        v14 = (v5 >> 42) & 0x1FFFFF;
        v15 = (v5 >> 21) & 0x1FFFFF;
        do
        {
          destination = 0;
          dataPointerOut = 0;
          lengthAtOffsetOut = 0;
          CMBlockBufferCopyDataBytes((CMBlockBufferRef)v7, v8, 4uLL, &destination);
          v16 = destination;
          if (destination < 5)
            break;
          destination -= 4;
          CMBlockBufferGetDataPointer((CMBlockBufferRef)v7, v8 + 4, &lengthAtOffsetOut, 0, &dataPointerOut);
          if (lengthAtOffsetOut < destination)
            break;
          AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
          v18 = CFStringCreateWithBytesNoCopy(AllocatorForMedia, (const UInt8 *)dataPointerOut, destination, 0x8000100u, 0, v10);
          if (v18)
          {
            v19 = v18;
            CFRetain(v7);
            CFArrayAppendValue(theArray, v19);
            CFRelease(v19);
          }
          if (!v12 && v16 + v8 >= (int)v14)
            v13 = 1;
          if (v16 + v8 < (int)v15)
          {
            v8 += v16;
          }
          else
          {
            v11 = 1;
            v8 = 0;
          }
          v12 = !v11;
        }
        while (!v13 || !v11);
        *v21 = theArray;
        if (v10)
          CFRelease(v10);
      }
      CFRelease(v7);
      return 0;
    }
    else
    {
      qword_1EE13FDA8 = 0;
      FigReadWriteLockUnlockForWrite(sFigNoteRingBufferState);
      return 4294950613;
    }
  }
  return result;
}

void fig_log_ring_backing_deallocator(uint64_t a1, CFTypeRef cf)
{
  if (a1)
  {
    if (cf)
      CFRelease(cf);
  }
}

uint64_t FigNote_CopyKeys(uint64_t a1, _QWORD *a2)
{
  BOOL v2;
  __CFArray *v4;
  uint64_t v5;
  _QWORD v7[6];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  CFRange v12;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  if (gFigNoteVariableRegistry_0)
    v2 = gFigNoteVariableRegistry_1 == 0;
  else
    v2 = 1;
  if (v2)
    goto LABEL_7;
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 0x40000000;
  v7[2] = __FigNote_CopyKeys_block_invoke;
  v7[3] = &unk_1E28DDD50;
  v7[4] = &v8;
  v7[5] = a1;
  dispatch_sync((dispatch_queue_t)gFigNoteVariableRegistry_0, v7);
  v4 = (__CFArray *)v9[3];
  if (!v4)
  {
LABEL_7:
    v5 = 4294950614;
  }
  else
  {
    v12.length = CFArrayGetCount((CFArrayRef)v9[3]);
    v12.location = 0;
    CFArraySortValues(v4, v12, (CFComparatorFunction)MEMORY[0x1E0C98F10], 0);
    v5 = 0;
    *a2 = v9[3];
  }
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t fig_os_log_with_args()
{
  return os_log_with_args();
}

uint64_t fig_note_write_to_external_log_file(const char *a1)
{
  int v2;

  FigThreadRunOnce(&sFigLoggingInit, (void (*)(void))fig_note_init_logging_once);
  FigReentrantMutexLock((pthread_mutex_t *)gFigLogControlMutex);
  if (sExternalLogfile)
  {
    v2 = fprintf((FILE *)sExternalLogfile, "%s\n", a1);
    fflush((FILE *)sExternalLogfile);
    if (v2 >= 1 && sExternalLogfileSizeLimit != 0)
    {
      sExternalLogfileNumBytesWritten += v2;
      if (sExternalLogfileNumBytesWritten > sExternalLogfileSizeLimit)
      {
        fig_note_close_external_log_file();
        unlink(sExternalLogfilePath);
        fig_note_open_external_log_file();
      }
    }
  }
  return FigReentrantMutexUnlock((pthread_mutex_t *)gFigLogControlMutex);
}

void append_and_release_noteBBuf(CMBlockBufferRef targetBBuf)
{
  CMBlockBufferAppendBufferReference((CMBlockBufferRef)sNoteBBuf, targetBBuf, 0, 0, 0);
  CFRelease(targetBBuf);
}

uint64_t safe_snprintf_0(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t result;

  LODWORD(result) = vsnprintf(a1, 0x600uLL, "[%s] ", &a9);
  if (result >= 0x5FF)
    return 1535;
  else
    return result;
}

uint64_t fig_note_close_external_log_file()
{
  FigReentrantMutexLock((pthread_mutex_t *)gFigLogControlMutex);
  if (sExternalLogfile)
  {
    if (sFigNoteExternalLogDeleteWatchSource)
    {
      dispatch_source_cancel((dispatch_source_t)sFigNoteExternalLogDeleteWatchSource);
      dispatch_release((dispatch_object_t)sFigNoteExternalLogDeleteWatchSource);
      sFigNoteExternalLogDeleteWatchSource = 0;
    }
    else
    {
      fclose((FILE *)sExternalLogfile);
    }
    sExternalLogfile = 0;
  }
  return FigReentrantMutexUnlock((pthread_mutex_t *)gFigLogControlMutex);
}

uint64_t fig_note_open_external_log_file()
{
  tm *v0;
  FILE *v1;
  FILE *v2;
  char *v3;
  uint64_t v4;
  int v5;
  NSObject *global_queue;
  time_t v8;
  _OWORD handler[4];
  char v10[968];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  FigReentrantMutexLock((pthread_mutex_t *)gFigLogControlMutex);
  v8 = 0;
  time(&v8);
  if (sPublicLogFileInUse == 1)
  {
    qmemcpy(handler, "/private/var/mobile/Library/Logs/CrashReporter/mediaserverd_log_", sizeof(handler));
    v0 = localtime(&v8);
    strftime(v10, 0x3C0uLL, "%Y-%m-%d-%H%M%S.txt", v0);
    __strlcpy_chk();
  }
  sExternalLogfileNumBytesWritten = 0;
  v1 = fopen(sExternalLogfilePath, "ab");
  sExternalLogfile = (uint64_t)v1;
  if (v1)
  {
    setvbuf(v1, 0, 2, 0);
    v2 = (FILE *)sExternalLogfile;
    v3 = ctime(&v8);
    fprintf(v2, "\n\n\n=== New Log Starting At %.24s =============================================================\n", v3);
    gFigLogControl = 4;
    if ((sExternalEchoToOSLog & 1) != 0)
      fwrite("**** WARNING: Using external_no_echo_oslog causes standard Fig logging to be omitted from the log captured by sysdiagnose, which will mean that engineering is not able to analyze radars created while it's set\n\n", 0xD2uLL, 1uLL, (FILE *)sExternalLogfile);
    else
      gFigLogControl = 9;
    sExternalLogfileNumBytesWritten = MEMORY[0x193FFC01C](sExternalLogfile);
    v4 = sExternalLogfile;
    if (sExternalLogfile)
    {
      v5 = fileno((FILE *)sExternalLogfile);
      global_queue = dispatch_get_global_queue(0, 0);
      sFigNoteExternalLogDeleteWatchSource = (uint64_t)dispatch_source_create(MEMORY[0x1E0C80DE8], v5, 1uLL, global_queue);
      dispatch_source_set_event_handler((dispatch_source_t)sFigNoteExternalLogDeleteWatchSource, &__block_literal_global_26);
      *(_QWORD *)&handler[0] = MEMORY[0x1E0C809B0];
      *((_QWORD *)&handler[0] + 1) = 0x40000000;
      *(_QWORD *)&handler[1] = __fig_note_setup_log_delete_watch_block_invoke_2;
      *((_QWORD *)&handler[1] + 1) = &__block_descriptor_tmp_27;
      *(_QWORD *)&handler[2] = v4;
      dispatch_source_set_cancel_handler((dispatch_source_t)sFigNoteExternalLogDeleteWatchSource, handler);
      dispatch_resume((dispatch_object_t)sFigNoteExternalLogDeleteWatchSource);
    }
  }
  else
  {
    gFigLogControl = 8;
  }
  return FigReentrantMutexUnlock((pthread_mutex_t *)gFigLogControlMutex);
}

uint64_t __fig_note_setup_log_delete_watch_block_invoke()
{
  FigReentrantMutexLock((pthread_mutex_t *)gFigLogControlMutex);
  if (sExternalLogfile)
  {
    fig_note_close_external_log_file();
    fig_note_open_external_log_file();
  }
  return FigReentrantMutexUnlock((pthread_mutex_t *)gFigLogControlMutex);
}

uint64_t __fig_note_setup_log_delete_watch_block_invoke_2(uint64_t a1)
{
  return fclose(*(FILE **)(a1 + 32));
}

void perform_fignote_variable_registration(uint64_t a1)
{
  void *Mutable;
  CFIndex Count;
  CFIndex v4;
  CFIndex v5;
  _QWORD *ValueAtIndex;
  _QWORD *v7;
  const void *v8;
  void *value;

  value = 0;
  Mutable = (void *)CFDictionaryGetValue((CFDictionaryRef)gFigNoteVariableRegistry_1, *(const void **)a1);
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue((CFMutableDictionaryRef)gFigNoteVariableRegistry_1, *(const void **)a1, Mutable);
    CFRelease(Mutable);
  }
  if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)Mutable, *(const void **)(a1 + 8), (const void **)&value))
  {
    value = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
    CFDictionarySetValue((CFMutableDictionaryRef)Mutable, *(const void **)(a1 + 8), value);
    CFRelease(value);
  }
  Count = CFArrayGetCount((CFArrayRef)value);
  if (Count < 1)
  {
LABEL_9:
    v7 = malloc_type_calloc(1uLL, 0x18uLL, 0x10300409B68AA8EuLL);
    v8 = v7;
    if (v7)
    {
      v7[1] = *(_QWORD *)(a1 + 32);
      *((_DWORD *)v7 + 4) = *(_DWORD *)(a1 + 40);
      *v7 = fig_log_get_emitter(*(const char **)(a1 + 16), *(const char **)(a1 + 24));
      CFArrayAppendValue((CFMutableArrayRef)value, v8);
      *(_BYTE *)(a1 + 56) = 1;
    }
  }
  else
  {
    v4 = Count;
    v5 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)value, v5);
      if (ValueAtIndex[1] == *(_QWORD *)(a1 + 32))
        break;
      if (v4 == ++v5)
        goto LABEL_9;
    }
    v8 = ValueAtIndex;
  }
  *(_QWORD *)(a1 + 48) = v8;
}

BOOL fig_note_get_value_for_string_preference(const __CFString *a1, int *a2)
{
  _BOOL8 v4;
  int v5;
  SInt32 IntValue;

  v4 = 1;
  if (CFStringCompare(a1, CFSTR("true"), 1uLL))
  {
    v5 = 1;
    if (CFStringCompare(a1, CFSTR("yes"), 1uLL))
    {
      v5 = 1;
      if (CFStringCompare(a1, CFSTR("on"), 1uLL))
      {
        v4 = 1;
        if (CFStringCompare(a1, CFSTR("false"), 1uLL)
          && (v4 = 1, CFStringCompare(a1, CFSTR("no"), 1uLL))
          && (v4 = 1, CFStringCompare(a1, CFSTR("off"), 1uLL)))
        {
          if (CFEqual(a1, CFSTR("0")))
          {
            v5 = 0;
            v4 = 1;
          }
          else
          {
            IntValue = CFStringGetIntValue(a1);
            v4 = IntValue != 0;
            v5 = IntValue & ~(IntValue >> 31);
          }
        }
        else
        {
          v5 = 0;
        }
      }
      else
      {
        v4 = 1;
      }
    }
    else
    {
      v4 = 1;
    }
  }
  else
  {
    v5 = 1;
  }
  *a2 = v5;
  return v4;
}

void initialize_fignote_variable_registry_once()
{
  gFigNoteVariableRegistry_0 = (uint64_t)dispatch_queue_create("fignote_variable_registry_queue", 0);
  gFigNoteVariableRegistry_1 = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigInstallSysdiagnoseBlock((uint64_t)CFSTR("FigNoteVariableRegistry"), (uint64_t)&__block_literal_global_46);
}

void __initialize_fignote_variable_registry_once_block_invoke()
{
  NSObject *os_log_and_send_and_compose_flags;
  int v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  _QWORD *v5;
  int v6[2];
  const char *v7;
  _QWORD block[4];
  char v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v6[0] = 0;
  os_log_and_send_and_compose_flags = fig_log_emitter_get_os_log_and_send_and_compose_flags(0, v6);
  v1 = v6[0];
  if (os_log_type_enabled(os_log_and_send_and_compose_flags, OS_LOG_TYPE_DEFAULT))
    v4 = v1;
  else
    v4 = v1 & 0xFFFFFFFE;
  if (v4)
  {
    v6[1] = 136315138;
    v7 = "";
    v5 = (_QWORD *)_os_log_send_and_compose_impl();
    LOBYTE(v1) = v6[0];
  }
  else
  {
    v5 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 0, v5, v5 != block, v1, v2, v3);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __DumpVariableRegistry_block_invoke;
  block[3] = &__block_descriptor_tmp_47;
  v9 = 1;
  dispatch_sync((dispatch_queue_t)gFigNoteVariableRegistry_0, block);
}

void DumpNonDefaultRegisteredVariablesDictionaryApplierFunction(uint64_t a1, CFArrayRef theArray, uint64_t a3)
{
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  _DWORD **ValueAtIndex;
  _DWORD **v10;
  NSObject *os_log_and_send_and_compose_flags;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  int v17;
  char *v18;
  int v19[2];
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    v7 = Count;
    for (i = 0; i != v7; ++i)
    {
      ValueAtIndex = (_DWORD **)CFArrayGetValueAtIndex(theArray, i);
      if (*ValueAtIndex[1] != *((_DWORD *)ValueAtIndex + 4))
      {
        v10 = ValueAtIndex;
        v19[0] = 0;
        os_log_and_send_and_compose_flags = fig_log_emitter_get_os_log_and_send_and_compose_flags(0, v19);
        v12 = v19[0];
        if (os_log_type_enabled(os_log_and_send_and_compose_flags, OS_LOG_TYPE_DEFAULT))
          v15 = v12;
        else
          v15 = v12 & 0xFFFFFFFE;
        if (v15)
        {
          v16 = *v10[1];
          v17 = *((_DWORD *)v10 + 4);
          v19[1] = 136316162;
          v20 = "";
          v21 = 2112;
          v22 = a3;
          v23 = 2112;
          v24 = a1;
          v25 = 1024;
          v26 = v16;
          v27 = 1024;
          v28 = v17;
          v18 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v12) = v19[0];
        }
        else
        {
          v18 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 0, v18, v18 != &v29, v12, v13, v14);
      }
    }
  }
}

void DumpAllRegisteredVariablesDictionaryApplierFunction(uint64_t a1, CFArrayRef theArray, uint64_t a3)
{
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  _DWORD **ValueAtIndex;
  NSObject *os_log_and_send_and_compose_flags;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  int v16;
  char *v17;
  int v18[2];
  const char *v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    v7 = Count;
    for (i = 0; i != v7; ++i)
    {
      ValueAtIndex = (_DWORD **)CFArrayGetValueAtIndex(theArray, i);
      v18[0] = 0;
      os_log_and_send_and_compose_flags = fig_log_emitter_get_os_log_and_send_and_compose_flags(0, v18);
      v11 = v18[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags, OS_LOG_TYPE_DEFAULT))
        v14 = v11;
      else
        v14 = v11 & 0xFFFFFFFE;
      if (v14)
      {
        v15 = *ValueAtIndex[1];
        v16 = *((_DWORD *)ValueAtIndex + 4);
        v18[1] = 136316162;
        v19 = "";
        v20 = 2112;
        v21 = a3;
        v22 = 2112;
        v23 = a1;
        v24 = 1024;
        v25 = v15;
        v26 = 1024;
        v27 = v16;
        v17 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v11) = v18[0];
      }
      else
      {
        v17 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 0, v17, v17 != &v28, v11, v12, v13);
    }
  }
}

void DumpVariableAppIDDictionaryApplierFunction(void *context, CFDictionaryRef theDict, CFDictionaryApplierFunction applier)
{
  CFDictionaryApplyFunction(theDict, applier, context);
}

uint64_t fig_note_configure_external_log_file(const __CFString *a1)
{
  const __CFString *v2;
  const __CFString *v3;
  CFTypeID v4;
  const __CFString *v5;
  const __CFString *v6;
  CFTypeID v7;
  CFTypeID v8;

  sExternalEchoToOSLog = CFStringCompare(a1, CFSTR("external_no_echo_oslog"), 1uLL) == kCFCompareEqualTo;
  if (CFStringCompare(a1, CFSTR("public"), 1uLL))
  {
    sPublicLogFileInUse = 0;
    v2 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("fig_notes_log"), CFSTR("com.apple.coremedia"));
    if (v2)
    {
      v3 = v2;
      v4 = CFGetTypeID(v2);
      if (v4 == CFStringGetTypeID())
        CFStringGetCString(v3, sExternalLogfilePath, 1024, 0x8000100u);
      CFRelease(v3);
    }
  }
  else
  {
    sPublicLogFileInUse = 1;
  }
  v5 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("fig_notes_log_limit"), CFSTR("com.apple.coremedia"));
  if (v5)
  {
    v6 = v5;
    v7 = CFGetTypeID(v5);
    if (v7 == CFStringGetTypeID())
    {
      sExternalLogfileSizeLimit = CFStringGetIntValue(v6);
    }
    else
    {
      v8 = CFGetTypeID(v6);
      if (v8 == CFNumberGetTypeID())
        CFNumberGetValue((CFNumberRef)v6, kCFNumberSInt64Type, &sExternalLogfileSizeLimit);
    }
    if (sExternalLogfileSizeLimit && sExternalLogfileSizeLimit < 0x10000)
      sExternalLogfileSizeLimit = 0x10000;
    CFRelease(v6);
  }
  return fig_note_open_external_log_file();
}

uint64_t initialize_logRingBuffer()
{
  uint64_t result;

  result = FigDebugIsInternalBuild();
  if ((_DWORD)result)
  {
    byte_1EE13FDB0 = 1;
    result = (uint64_t)FigReadWriteLockCreate(1);
    sFigNoteRingBufferState = result;
  }
  else
  {
    byte_1EE13FDB0 = 0;
  }
  return result;
}

uint64_t FigTimeCodeFormatDescriptionRegister()
{
  return FigThreadRunOnce(&sFigTimeCodeFormatDescriptionRegisterOnce, (void (*)(void))FigTimeCodeFormatDescriptionRegisterOnce);
}

uint64_t FigTimeCodeFormatDescriptionRegisterOnce()
{
  int v1;
  uint64_t v2;
  BOOL (*v3)(uint64_t, const opaqueCMFormatDescription *, unint64_t, unint64_t);
  __CFString *(*v4)(const void *);
  uint64_t (*v5)();

  v1 = 0;
  v2 = 32;
  v4 = figTimeCodeFormatDescriptionCopyDebugDesc;
  v5 = figTimeCodeFormatDescriptionFinalize;
  v3 = figTimeCodeFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x746D6364u, (__int128 *)&v1);
}

OSStatus CMTimeCodeFormatDescriptionCreate(CFAllocatorRef allocator, CMTimeCodeFormatType timeCodeFormatType, CMTime *frameDuration, uint32_t frameQuanta, uint32_t flags, CFDictionaryRef extensions, CMTimeCodeFormatDescriptionRef *formatDescriptionOut)
{
  int v14;
  OSStatus v15;
  uint64_t DerivedStorage;
  CMTimeEpoch epoch;
  CFTypeRef cf;

  cf = 0;
  if (!formatDescriptionOut)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  if ((int)timeCodeFormatType > 1952658995)
  {
    if (timeCodeFormatType == 1952658996)
      goto LABEL_9;
    v14 = 1953325924;
  }
  else
  {
    if (timeCodeFormatType == 1668166450)
      goto LABEL_9;
    v14 = 1668167220;
  }
  if (timeCodeFormatType != v14)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
LABEL_9:
  if ((frameDuration->flags & 1) == 0 || !frameQuanta)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  FigThreadRunOnce(&sFigTimeCodeFormatDescriptionRegisterOnce, (void (*)(void))FigTimeCodeFormatDescriptionRegisterOnce);
  v15 = FigDerivedFormatDescriptionCreate(allocator, (void *)0x746D6364, timeCodeFormatType, extensions, (uint64_t *)&cf);
  if (v15)
  {
    if (cf)
      CFRelease(cf);
  }
  else
  {
    DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf);
    epoch = frameDuration->epoch;
    *(_OWORD *)DerivedStorage = *(_OWORD *)&frameDuration->value;
    *(_QWORD *)(DerivedStorage + 16) = epoch;
    *(_DWORD *)(DerivedStorage + 24) = frameQuanta;
    *(_DWORD *)(DerivedStorage + 28) = flags;
    *formatDescriptionOut = (CMTimeCodeFormatDescriptionRef)cf;
  }
  return v15;
}

CMTime *__cdecl CMTimeCodeFormatDescriptionGetFrameDuration(CMTime *__return_ptr retstr, CMTimeCodeFormatDescriptionRef timeCodeFormatDescription)
{
  CMTime *result;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  if (!timeCodeFormatDescription)
    return (CMTime *)FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  result = (CMTime *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)timeCodeFormatDescription);
  *(_OWORD *)&retstr->value = *(_OWORD *)&result->value;
  retstr->epoch = result->epoch;
  return result;
}

uint32_t CMTimeCodeFormatDescriptionGetFrameQuanta(CMTimeCodeFormatDescriptionRef timeCodeFormatDescription)
{
  if (timeCodeFormatDescription)
    return *(_DWORD *)(FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)timeCodeFormatDescription) + 24);
  FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint32_t CMTimeCodeFormatDescriptionGetTimeCodeFlags(CMTimeCodeFormatDescriptionRef desc)
{
  if (desc)
    return *(_DWORD *)(FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)desc) + 28);
  FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  return 0;
}

__CFString *figTimeCodeFormatDescriptionCopyDebugDesc(const void *a1)
{
  uint64_t DerivedStorage;
  const __CFAllocator *v3;
  __CFString *Mutable;
  const __CFAllocator *v5;
  __int128 v6;
  CFStringRef v7;
  CMTime time;

  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  v3 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v3, 0);
  v5 = CFGetAllocator(a1);
  v6 = *(_OWORD *)DerivedStorage;
  time.epoch = *(_QWORD *)(DerivedStorage + 16);
  *(_OWORD *)&time.value = v6;
  v7 = CMTimeCopyDescription(v5, &time);
  CFStringAppendFormat(Mutable, 0, CFSTR("\t\tframeDuration: %@"), v7);
  CFRelease(v7);
  CFStringAppendFormat(Mutable, 0, CFSTR("\t\tframes/sec: %d"), *(unsigned int *)(DerivedStorage + 24));
  CFStringAppendFormat(Mutable, 0, CFSTR("\t\ttcFlags: %d"), *(unsigned int *)(DerivedStorage + 28));
  return Mutable;
}

BOOL figTimeCodeFormatDescriptionEqual(uint64_t a1, const opaqueCMFormatDescription *a2, unint64_t a3, unint64_t a4)
{
  const opaqueCMFormatDescription *v7;
  uint64_t DerivedStorage;
  const __CFDictionary *Extensions;
  uint64_t v10;
  const __CFDictionary *v11;
  __int128 v12;
  __int128 v13;
  CMTime v15;
  CMTime time1;

  v7 = (const opaqueCMFormatDescription *)a1;
  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage(a1);
  Extensions = CMFormatDescriptionGetExtensions(v7);
  v10 = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a2);
  v11 = CMFormatDescriptionGetExtensions(a2);
  LODWORD(v7) = CMFormatDescriptionGetMediaSubType(v7);
  if ((_DWORD)v7 == CMFormatDescriptionGetMediaSubType(a2)
    && (v12 = *(_OWORD *)DerivedStorage,
        time1.epoch = *(_QWORD *)(DerivedStorage + 16),
        *(_OWORD *)&time1.value = v12,
        v13 = *(_OWORD *)v10,
        v15.epoch = *(_QWORD *)(v10 + 16),
        *(_OWORD *)&v15.value = v13,
        !CMTimeCompare(&time1, &v15))
    && *(_DWORD *)(DerivedStorage + 24) == *(_DWORD *)(v10 + 24)
    && *(_DWORD *)(DerivedStorage + 28) == *(_DWORD *)(v10 + 28))
  {
    return FigFormatDescriptionExtensionsDictionariesEqualIgnoringKeys(Extensions, v11, a3, a4) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t FigSandboxRegistrationAssociateWithURL(FigSandboxRegistrationObjCWrapper *a1, void *a2)
{
  FigSandboxRegistrationObjCWrapper *v2;
  id v4;
  uint64_t v5;

  v2 = a1;
  if (a1)
  {
    if (a2)
    {
      v4 = objc_alloc_init(MEMORY[0x1E0CB34A8]);
      v2 = -[FigSandboxRegistrationObjCWrapper initWithRegistration:]([FigSandboxRegistrationObjCWrapper alloc], "initWithRegistration:", v2);
      if (v2)
      {
        objc_setAssociatedObject(a2, &urlSBRegKey, v2, (void *)0x301);
        v5 = 0;
      }
      else
      {
        v5 = FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      v5 = FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
      v4 = 0;
      v2 = 0;
    }
  }
  else
  {
    v5 = FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
    v4 = 0;
  }

  objc_msgSend(v4, "drain");
  return v5;
}

uint64_t FigGetSandboxRegistrationAssociatedWithURL(void *a1, _QWORD *a2)
{
  void *v4;
  id AssociatedObject;

  if (!a1 || !a2)
    return FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
  v4 = (void *)MEMORY[0x193FFC34C]();
  AssociatedObject = objc_getAssociatedObject(a1, &urlSBRegKey);
  if (AssociatedObject)
    AssociatedObject = (id)objc_msgSend(AssociatedObject, "_sandboxRegistration");
  *a2 = AssociatedObject;
  objc_autoreleasePoolPop(v4);
  return 0;
}

uint64_t FigCreateBase32EncodedStringFromBytes(const __CFAllocator *a1, uint64_t a2, uint64_t a3, int a4, CFStringRef *a5)
{
  if (a2 && a3 && a5)
    return figNumericsCreateEncodedStringFromBytes(a1, 5uLL, "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", a2, a3, a4, a5);
  else
    return FigSignalErrorAt(4294949846, 0, 0, 0, 0, 0, 0);
}

uint64_t figNumericsCreateEncodedStringFromBytes(const __CFAllocator *a1, unint64_t a2, char *__s, uint64_t a4, uint64_t a5, int a6, CFStringRef *a7)
{
  CFIndex v14;
  const UInt8 *v15;
  UInt8 *v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  unsigned int v20;
  UInt8 *v21;
  int v22;
  unint64_t v23;
  UInt8 *v24;
  BOOL v25;
  CFStringRef v26;
  uint64_t v27;
  uint64_t v29;

  if (strlen(__s) >> a2)
  {
    if (a6)
      v14 = (a2 + 8 * a5 - 1) / a2 + 8;
    else
      v14 = (a2 + 8 * a5 - 1) / a2;
    v15 = (const UInt8 *)CFAllocatorAllocate(a1, v14, 0);
    v16 = (UInt8 *)v15;
    if (!v15)
    {
LABEL_24:
      v29 = 4294949845;
      goto LABEL_26;
    }
    if (a5)
    {
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      do
      {
        v20 = *(unsigned __int8 *)(a4 + v17) | (v20 << 8);
        if (v19 + 8 >= a2)
        {
          v21 = (UInt8 *)&v15[v18];
          v22 = 8 - a2 + v19;
          v19 += 8;
          do
          {
            *v21++ = __s[(unint64_t)v20 >> v22];
            v19 -= a2;
            v20 &= ~(-1 << v22);
            ++v18;
            v22 -= a2;
          }
          while (v19 >= a2);
        }
        else
        {
          v19 += 8;
        }
        ++v17;
      }
      while (v17 != a5);
      if (v19)
        v15[v18++] = __s[v20 << (a2 - v19)];
      if (!a6)
      {
LABEL_22:
        v26 = CFStringCreateWithBytesNoCopy(a1, v15, v18, 0x8000100u, 0, a1);
        v27 = 0;
        *a7 = v26;
        if (v26)
          return v27;
        goto LABEL_24;
      }
    }
    else
    {
      v18 = 0;
      if (!a6)
        goto LABEL_22;
    }
    if ((((_BYTE)v18 * (_BYTE)a2) & 7) != 0)
    {
      v23 = a2 + a2 * v18;
      v24 = (UInt8 *)&v15[v18];
      do
      {
        *v24++ = 61;
        ++v18;
        v25 = (v23 & 7) == 0;
        v23 += a2;
      }
      while (!v25);
    }
    goto LABEL_22;
  }
  v16 = 0;
  v29 = 4294949846;
LABEL_26:
  v27 = FigSignalErrorAt(v29, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)v27)
    CFAllocatorDeallocate(a1, v16);
  return v27;
}

uint64_t FigCreateBase64EncodedStringFromBytes(const __CFAllocator *a1, uint64_t a2, uint64_t a3, int a4, CFStringRef *a5)
{
  if (a2 && a3 && a5)
    return figNumericsCreateEncodedStringFromBytes(a1, 6uLL, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a2, a3, a4, a5);
  else
    return FigSignalErrorAt(4294949846, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCreateBase64EncodedStringFromCFData(const __CFAllocator *a1, CFDataRef theData, int a3, CFStringRef *a4)
{
  const UInt8 *BytePtr;
  CFIndex Length;

  if (!theData)
    return FigSignalErrorAt(4294949846, 0, 0, 0, 0, 0, 0);
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  return FigCreateBase64EncodedStringFromBytes(a1, (uint64_t)BytePtr, Length, a3, a4);
}

uint64_t FigCreateHexStringFromCFData(const __CFAllocator *a1, const __CFData *a2, int a3, CFStringRef *a4)
{
  CFMutableStringRef Mutable;
  __CFString *v9;
  const UInt8 *BytePtr;
  CFIndex Length;
  unint64_t v12;
  CFIndex v13;
  const UInt8 *v14;
  CFStringRef Copy;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;

  if (a4)
  {
    Mutable = CFStringCreateMutable(a1, 0);
    if (Mutable)
    {
      v9 = Mutable;
      if (a2)
      {
        BytePtr = CFDataGetBytePtr(a2);
        CFStringAppendFormat(v9, 0, CFSTR("0x"));
        Length = CFDataGetLength(a2);
        v12 = Length;
        if (a3)
        {
          if (Length >= 1)
          {
            v13 = 0;
            do
              CFStringAppendFormat(v9, 0, CFSTR("%02x"), BytePtr[v13++]);
            while (v13 < CFDataGetLength(a2));
          }
        }
        else if (Length >= 1)
        {
          v14 = BytePtr - 1;
          do
            CFStringAppendFormat(v9, 0, CFSTR("%02x"), v14[v12]);
          while (v12-- > 1);
        }
        Copy = CFStringCreateCopy(a1, v9);
        *a4 = Copy;
        if (Copy)
        {
          v17 = 0;
LABEL_14:
          CFRelease(v9);
          return v17;
        }
        v20 = 4294949845;
      }
      else
      {
        v20 = 4294949846;
      }
      v17 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
      goto LABEL_14;
    }
    v19 = 4294949845;
  }
  else
  {
    v19 = 4294949846;
  }
  return FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
}

OSStatus CMTimeCodeFormatDescriptionCreateFromBigEndianTimeCodeDescriptionData(CFAllocatorRef allocator, const uint8_t *timeCodeDescriptionData, size_t size, CMTimeCodeDescriptionFlavor flavor, CMTimeCodeFormatDescriptionRef *formatDescriptionOut)
{
  unsigned int v9;
  size_t v10;
  uint32_t v11;
  const uint8_t *v12;
  unsigned int v13;
  unsigned int v14;
  const uint8_t *v15;
  uint64_t v16;
  unsigned int v17;
  size_t v18;
  const void **v19;
  const void **v20;
  const void **v21;
  const __CFString *v22;
  unsigned int v23;
  OSStatus v24;
  OSStatus v25;
  CFDictionaryRef v26;
  CFNumberRef v27;
  const __CFDictionary *v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  CFNumberRef v34;
  CFDictionaryRef v35;
  const __CFString *v36;
  unint64_t v37;
  uint64_t v38;
  const void *v39;
  unint64_t v40;
  const void *v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  BOOL v45;
  int v46;
  CMTimeCodeFormatType v47;
  uint32_t v48;
  OSStatus v49;
  uint32_t v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  CMTimeCodeFormatDescriptionRef formatDescriptionOuta;
  CMTime v55;
  CFTypeRef cf;
  __int16 valuePtr;
  CMTime keys;
  void *values;
  CFNumberRef v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  memset(&v55, 0, sizeof(v55));
  formatDescriptionOuta = 0;
  if (!timeCodeDescriptionData)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (size < 0x22 || !formatDescriptionOut)
  {
    v25 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    v29 = 0;
LABEL_70:
    if (formatDescriptionOuta)
      CFRelease(formatDescriptionOuta);
    goto LABEL_72;
  }
  v9 = *((_DWORD *)timeCodeDescriptionData + 1);
  v51 = *((_DWORD *)timeCodeDescriptionData + 7);
  v52 = *((_DWORD *)timeCodeDescriptionData + 6);
  v10 = 34;
  v11 = timeCodeDescriptionData[32];
  v53 = *((_DWORD *)timeCodeDescriptionData + 5);
  do
  {
    if (v10 + 8 > size)
      goto LABEL_10;
    v12 = &timeCodeDescriptionData[v10];
    v13 = bswap32(*(_DWORD *)&timeCodeDescriptionData[v10]);
    v14 = v13 - 8;
    if (v13 < 8)
      goto LABEL_10;
    v10 += v13;
    if (v10 > size)
      goto LABEL_23;
  }
  while (*((_DWORD *)v12 + 1) != 1701667182);
  if (v14 >= 4)
  {
    v32 = *((unsigned __int16 *)v12 + 4);
    v15 = v12 + 8;
    v16 = bswap32(v32) >> 16;
    if (v16 + 4 > (unint64_t)v14)
    {
LABEL_23:
      v30 = 4294954582;
LABEL_24:
      v25 = FigSignalErrorAt(v30, 0, 0, 0, 0, 0, 0);
      v29 = 0;
      if (v25)
        goto LABEL_70;
      goto LABEL_58;
    }
    v17 = 2;
  }
  else
  {
LABEL_10:
    v15 = 0;
    LODWORD(v16) = 0;
    v17 = 1;
  }
  v18 = v17;
  v19 = (const void **)malloc_type_calloc(v17, 8uLL, 0x6004044C4A2DFuLL);
  if (!v19)
  {
    v30 = 4294954583;
    goto LABEL_24;
  }
  v20 = v19;
  v50 = v11;
  v21 = (const void **)malloc_type_calloc(v18, 8uLL, 0xC0040B8AA526DuLL);
  if (v21)
  {
    v22 = CFSTR("VerbatimSampleDescription");
    if (CFSTR("VerbatimSampleDescription"))
      v22 = (const __CFString *)CFRetain(CFSTR("VerbatimSampleDescription"));
    *v20 = v22;
    *v21 = CFDataCreate(allocator, timeCodeDescriptionData, size);
    if (v15)
    {
      v23 = bswap32(*((unsigned __int16 *)v15 + 1));
      valuePtr = HIWORD(v23);
      keys.value = 0;
      *(_QWORD *)&keys.timescale = 0;
      values = 0;
      v60 = 0;
      cf = 0;
      v24 = FigCFStringCreateWithBytesAndMovieLangCode(allocator, v15 + 4, v16, HIWORD(v23), 0, (CFStringRef *)&cf);
      if (v24)
      {
        v25 = v24;
        v26 = 0;
        v27 = 0;
      }
      else
      {
        keys.value = (CMTimeValue)CFSTR("TimeCode_SourceReferenceName_Value");
        values = (void *)cf;
        v34 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt16Type, &valuePtr);
        v27 = v34;
        if (v34
          && (*(_QWORD *)&keys.timescale = CFSTR("TimeCode_SourceReferenceName_LangCode"),
              v60 = v34,
              (v35 = CFDictionaryCreate(allocator, (const void **)&keys, (const void **)&values, 2, 0, MEMORY[0x1E0C9B3A0])) != 0))
        {
          v26 = v35;
          v25 = 0;
        }
        else
        {
          v25 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          v26 = 0;
        }
      }
      if (cf)
        CFRelease(cf);
      if (v27)
        CFRelease(v27);
      if (v25)
        goto LABEL_46;
      v36 = CFSTR("TimeCode_SourceReferenceName");
      if (CFSTR("TimeCode_SourceReferenceName"))
        v36 = (const __CFString *)CFRetain(CFSTR("TimeCode_SourceReferenceName"));
      v20[1] = v36;
      v21[1] = v26;
      v33 = 2;
    }
    else
    {
      v33 = 1;
    }
    if ((_DWORD)v18 == v33)
    {
      v29 = CFDictionaryCreate(allocator, v20, v21, v18, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v29)
        v25 = 0;
      else
        v25 = -12711;
      goto LABEL_47;
    }
    v31 = 4294954584;
  }
  else
  {
    v31 = 4294954583;
  }
  v25 = FigSignalErrorAt(v31, 0, 0, 0, 0, 0, 0);
LABEL_46:
  v29 = 0;
LABEL_47:
  v37 = 0;
  v38 = 8 * v18;
  do
  {
    v39 = v20[v37 / 8];
    if (v39)
      CFRelease(v39);
    v37 += 8;
  }
  while (v38 != v37);
  free(v20);
  if (v21)
  {
    v40 = 0;
    do
    {
      v41 = v21[v40 / 8];
      if (v41)
        CFRelease(v41);
      v40 += 8;
    }
    while (v38 != v40);
    free(v21);
  }
  v11 = v50;
  if (v25)
    goto LABEL_70;
LABEL_58:
  CMTimeMake(&v55, (int)bswap32(v51), bswap32(v52));
  v42 = bswap32(v9);
  v43 = bswap32(v53);
  v44 = 1952658996;
  if (v42 == 1952658996)
  {
    v46 = 1668167220;
    v45 = (v43 & 8) == 0;
  }
  else
  {
    v44 = 1953325924;
    if (v42 != 1953325924)
    {
      v49 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      if (v49)
      {
        v25 = v49;
        goto LABEL_70;
      }
      v48 = 0;
      v47 = 0;
      goto LABEL_66;
    }
    v45 = (v43 & 8) == 0;
    v46 = 1668166450;
  }
  if (v45)
    v47 = v44;
  else
    v47 = v46;
  v48 = v43 & 0xFFFFFFF7;
LABEL_66:
  keys = v55;
  v25 = CMTimeCodeFormatDescriptionCreate(allocator, v47, &keys, v11, v48, v29, &formatDescriptionOuta);
  if (v25)
    goto LABEL_70;
  *formatDescriptionOut = formatDescriptionOuta;
  formatDescriptionOuta = 0;
LABEL_72:
  if (v29)
    CFRelease(v29);
  return v25;
}

OSStatus CMTimeCodeFormatDescriptionCreateFromBigEndianTimeCodeDescriptionBlockBuffer(CFAllocatorRef allocator, CMBlockBufferRef timeCodeDescriptionBlockBuffer, CMTimeCodeDescriptionFlavor flavor, CMTimeCodeFormatDescriptionRef *formatDescriptionOut)
{
  size_t DataLength;
  OpaqueCMBlockBuffer *v8;
  OSStatus v10;
  CMTimeCodeDescriptionFlavor v11;
  CMBlockBufferRef theBuffer;
  char *dataPointerOut;

  theBuffer = 0;
  if (!timeCodeDescriptionBlockBuffer || !formatDescriptionOut)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  dataPointerOut = 0;
  DataLength = CMBlockBufferGetDataLength(timeCodeDescriptionBlockBuffer);
  if (CMBlockBufferIsRangeContiguous(timeCodeDescriptionBlockBuffer, 0, 0))
  {
    v8 = (OpaqueCMBlockBuffer *)CFRetain(timeCodeDescriptionBlockBuffer);
    theBuffer = v8;
LABEL_7:
    CMBlockBufferGetDataPointer(v8, 0, 0, 0, &dataPointerOut);
    v10 = CMTimeCodeFormatDescriptionCreateFromBigEndianTimeCodeDescriptionData(allocator, (const uint8_t *)dataPointerOut, DataLength, v11, formatDescriptionOut);
    v8 = theBuffer;
    goto LABEL_8;
  }
  v10 = CMBlockBufferCreateContiguous(allocator, timeCodeDescriptionBlockBuffer, allocator, 0, 0, DataLength, 0, &theBuffer);
  v8 = theBuffer;
  if (!v10)
    goto LABEL_7;
LABEL_8:
  if (v8)
    CFRelease(v8);
  return v10;
}

OSStatus CMTimeCodeFormatDescriptionCopyAsBigEndianTimeCodeDescriptionBlockBuffer(CFAllocatorRef allocator, CMTimeCodeFormatDescriptionRef timeCodeFormatDescription, CMTimeCodeDescriptionFlavor flavor, CMBlockBufferRef *blockBufferOut)
{
  CFTypeID TypeID;
  signed int MediaSubType;
  signed int v9;
  int v10;
  unsigned int value;
  CMTimeScale timescale;
  uint32_t FrameQuanta;
  char v14;
  uint32_t TimeCodeFlags;
  const __CFData *Extension;
  const __CFData *v17;
  CFTypeID v18;
  size_t Length;
  const UInt8 *BytePtr;
  OSStatus DataPointer;
  OSStatus v22;
  const __CFDictionary *v24;
  const __CFDictionary *v25;
  CFTypeID v26;
  unsigned int v27;
  char *v28;
  CMTimeValue v29;
  void *v30;
  size_t v31;
  CMTime v32;
  char *dataPointerOut;
  CMBlockBufferRef theBuffer;
  size_t v35;
  void *ptr;
  unsigned __int16 v37;

  v37 = 0;
  v35 = 0;
  ptr = 0;
  dataPointerOut = 0;
  theBuffer = 0;
  if (!timeCodeFormatDescription)
    goto LABEL_19;
  TypeID = CMFormatDescriptionGetTypeID();
  if (TypeID != CFGetTypeID(timeCodeFormatDescription)
    || CMFormatDescriptionGetMediaType(timeCodeFormatDescription) != 1953325924)
  {
    goto LABEL_19;
  }
  MediaSubType = CMFormatDescriptionGetMediaSubType(timeCodeFormatDescription);
  v9 = MediaSubType;
  if (MediaSubType > 1952658995)
  {
    if (MediaSubType == 1952658996)
      goto LABEL_11;
    v10 = 1953325924;
  }
  else
  {
    if (MediaSubType == 1668166450)
      goto LABEL_11;
    v10 = 1668167220;
  }
  if (MediaSubType != v10)
  {
LABEL_19:
    v22 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    goto LABEL_20;
  }
LABEL_11:
  if (!blockBufferOut)
    goto LABEL_19;
  CMTimeCodeFormatDescriptionGetFrameDuration(&v32, timeCodeFormatDescription);
  if ((v32.flags & 1) == 0)
    goto LABEL_19;
  value = v32.value;
  timescale = v32.timescale;
  FrameQuanta = CMTimeCodeFormatDescriptionGetFrameQuanta(timeCodeFormatDescription);
  if (!FrameQuanta)
    goto LABEL_19;
  v14 = FrameQuanta;
  TimeCodeFlags = CMTimeCodeFormatDescriptionGetTimeCodeFlags(timeCodeFormatDescription);
  Extension = (const __CFData *)CMFormatDescriptionGetExtension(timeCodeFormatDescription, CFSTR("VerbatimSampleDescription"));
  if (!Extension || (v17 = Extension, v18 = CFGetTypeID(Extension), v18 != CFDataGetTypeID()))
  {
    v24 = (const __CFDictionary *)CMFormatDescriptionGetExtension(timeCodeFormatDescription, CFSTR("TimeCode_SourceReferenceName"));
    if (v24
      && (v25 = v24, v26 = CFGetTypeID(v24), v26 == CFDictionaryGetTypeID())
      && !createaSourceReferenceNameStringFromDictionary(allocator, v25, &v37, (UInt8 **)&ptr, &v35))
    {
      v27 = v35 + 12;
    }
    else
    {
      v27 = 0;
    }
    DataPointer = CMBlockBufferCreateWithMemoryBlock(allocator, 0, v27 + 34, allocator, 0, 0, v27 + 34, 1u, &theBuffer);
    if (DataPointer)
      goto LABEL_21;
    DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
    if (DataPointer)
      goto LABEL_21;
    if (v9 > 1952658995)
    {
      if (v9 == 1953325924)
        goto LABEL_42;
      if (v9 == 1952658996)
      {
        v9 = 1952658996;
        goto LABEL_42;
      }
    }
    else
    {
      if (v9 == 1668166450)
      {
        TimeCodeFlags |= 8u;
        v9 = 1953325924;
        goto LABEL_42;
      }
      if (v9 == 1668167220)
      {
        v9 = 1952658996;
        TimeCodeFlags |= 8u;
LABEL_42:
        v28 = dataPointerOut;
        *(_DWORD *)dataPointerOut = bswap32(v27 + 34);
        *((_DWORD *)v28 + 1) = bswap32(v9);
        *((_QWORD *)v28 + 1) = 0xFFFF000000000000;
        *((_DWORD *)v28 + 4) = 0;
        *((_DWORD *)v28 + 5) = bswap32(TimeCodeFlags);
        *((_DWORD *)v28 + 6) = bswap32(timescale);
        *((_DWORD *)v28 + 7) = bswap32(value);
        v28[32] = v14;
        v28[33] = 0;
        if (!v27)
        {
LABEL_45:
          DataPointer = 0;
          goto LABEL_46;
        }
        v32.value = 0;
        v22 = CMBlockBufferGetDataPointer(theBuffer, 0x22uLL, 0, 0, (char **)&v32);
        if (!v22)
        {
          *(_DWORD *)v32.value = bswap32(v27);
          *(_DWORD *)(v32.value + 4) = 1701667182;
          v29 = v32.value;
          v31 = v35;
          v30 = ptr;
          *(_WORD *)(v32.value + 8) = bswap32(v35) >> 16;
          *(_WORD *)(v29 + 10) = bswap32(v37) >> 16;
          memmove((void *)(v29 + 12), v30, v31);
          goto LABEL_45;
        }
LABEL_20:
        DataPointer = v22;
        goto LABEL_21;
      }
    }
    v9 = 0;
    goto LABEL_42;
  }
  Length = CFDataGetLength(v17);
  BytePtr = CFDataGetBytePtr(v17);
  v32.value = 0;
  DataPointer = CMBlockBufferCreateWithMemoryBlock(allocator, 0, Length, allocator, 0, 0, Length, 1u, &theBuffer);
  if (!DataPointer)
  {
    DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, (char **)&v32);
    if (!DataPointer)
    {
      memcpy((void *)v32.value, BytePtr, Length);
LABEL_46:
      *blockBufferOut = theBuffer;
      theBuffer = 0;
    }
  }
LABEL_21:
  if (ptr)
    CFAllocatorDeallocate(allocator, ptr);
  if (theBuffer)
    CFRelease(theBuffer);
  return DataPointer;
}

uint64_t createaSourceReferenceNameStringFromDictionary(const __CFAllocator *a1, CFDictionaryRef theDict, unsigned __int16 *a3, UInt8 **a4, _QWORD *a5)
{
  const __CFString *Value;
  const __CFNumber *v11;
  BOOL v12;
  UInt8 *v13;
  uint64_t result;
  uint64_t v15;
  unsigned __int16 valuePtr;

  valuePtr = 0;
  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("TimeCode_SourceReferenceName_Value"));
  v11 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("TimeCode_SourceReferenceName_LangCode"));
  if (Value)
    v12 = v11 == 0;
  else
    v12 = 1;
  if (v12)
    return 4294954584;
  v15 = 0;
  CFNumberGetValue(v11, kCFNumberSInt16Type, &valuePtr);
  v13 = FigCreateBytesFromCFStringAndMovieLangCode(a1, Value, valuePtr, 0, &v15);
  result = 0;
  *a3 = valuePtr;
  *a4 = v13;
  *a5 = v15;
  return result;
}

OSStatus CMSwapBigEndianTimeCodeDescriptionToHost(uint8_t *timeCodeDescriptionData, size_t timeCodeDescriptionSize)
{
  figBridge_FlipTimeCodeDescriptionData((uint64_t)timeCodeDescriptionData, timeCodeDescriptionSize);
  return 0;
}

int8x8_t figBridge_FlipTimeCodeDescriptionData(uint64_t a1, unint64_t a2)
{
  int8x8_t result;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  int8x16_t v6;

  if (a1 && a2 > 0x21)
  {
    result = vrev32_s8(*(int8x8_t *)a1);
    v3 = bswap32(*(_DWORD *)(a1 + 8));
    v4 = bswap32(*(unsigned __int16 *)(a1 + 12)) >> 16;
    v5 = bswap32(*(unsigned __int16 *)(a1 + 14)) >> 16;
    v6 = vrev32q_s8(*(int8x16_t *)(a1 + 16));
    *(int8x8_t *)a1 = result;
    *(_DWORD *)(a1 + 8) = v3;
    *(_WORD *)(a1 + 12) = v4;
    *(_WORD *)(a1 + 14) = v5;
    *(int8x16_t *)(a1 + 16) = v6;
  }
  else
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

OSStatus CMSwapHostEndianTimeCodeDescriptionToBig(uint8_t *timeCodeDescriptionData, size_t timeCodeDescriptionSize)
{
  figBridge_FlipTimeCodeDescriptionData((uint64_t)timeCodeDescriptionData, timeCodeDescriptionSize);
  return 0;
}

size_t FigBlockBufferHexDumpWithEmitter(OpaqueCMBlockBuffer *a1, size_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unsigned int a6, uint64_t (*a7)(uint64_t a1, const char *a2), uint64_t a8)
{
  char v9;
  const char *v14;
  const char *v15;
  int v16;
  int v17;
  int v18;
  size_t result;
  unint64_t v20;
  uint64_t (*v21)(uint64_t, const char *);
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  int v26;
  size_t v27;
  size_t v28;
  size_t v29;
  uint64_t v30;
  size_t v31;
  size_t v32;
  BOOL v33;
  size_t v34;
  char *v35;
  size_t v36;
  const char *v38;
  int v39;
  int v40;
  int v41;
  char *v42;
  uint64_t v43;
  int v44;
  const char *v45;
  int v46;
  int v47;
  int v48;
  size_t v49;
  BOOL v50;
  const char *v51;
  int v52;
  int v53;
  int v54;
  int v55;
  char *v56;
  int v57;
  int v58;
  uint64_t v59;
  unsigned int v60;
  int v61;
  uint64_t v62;
  int v63;
  int v64;
  unint64_t v65;
  size_t v66;
  char *v67;
  size_t offset;
  int v69;
  int v70;
  uint64_t (*v71)(uint64_t, const char *);
  size_t v72;
  uint64_t v74;
  size_t lengthAtOffsetOut;
  char *returnedPointerOut;
  char __str[1024];
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  char temporaryBlock[128];
  uint64_t v88;

  v9 = a6;
  v88 = *MEMORY[0x1E0C80C00];
  v86 = 0u;
  v85 = 0u;
  v84 = 0u;
  v83 = 0u;
  v82 = 0u;
  v81 = 0u;
  v80 = 0u;
  v79 = 0u;
  v14 = "%#6zx: ";
  if ((a6 & 2) == 0)
    v14 = "%5zd: ";
  v15 = "/* %#6zx: */ ";
  if ((a6 & 2) == 0)
    v15 = "/* %5zd: */ ";
  if ((a6 & 0x10) != 0)
    v14 = v15;
  v67 = (char *)v14;
  if ((a6 & 0x10) != 0)
    v16 = 0;
  else
    v16 = a6 & 1;
  v70 = v16;
  if ((a6 & 0x10) != 0)
    v17 = 0;
  else
    v17 = (a6 >> 2) & 1;
  v69 = v17;
  if ((a6 & 0x10) != 0)
    v18 = 0;
  else
    v18 = (((a6 >> 2) & 1) == 0) & (a6 >> 3);
  result = CMBlockBufferGetDataLength(a1);
  offset = a2;
  v66 = result;
  v20 = result - a2;
  if (result > a2)
  {
    v21 = DefaultBBufHexDumpEmitter;
    returnedPointerOut = 0;
    if (a7)
      v21 = a7;
    v71 = v21;
    v22 = 128;
    if (a5 < 0x80)
      v22 = a5;
    if (a5)
      v23 = v22;
    else
      v23 = 16;
    if (v20 >= a3)
      v24 = a3;
    else
      v24 = result - a2;
    if (a3)
      v20 = v24;
    v25 = v23 * a4;
    if (v20 < v23 * a4)
      v25 = v20;
    if (a4 > 0)
      v20 = v25;
    v65 = v20;
    if (v20)
    {
      v74 = 0;
      v26 = 0;
      v27 = v20;
      v28 = a2;
      while (1)
      {
        if (v27 >= v23)
          v29 = v23;
        else
          v29 = v27;
        if (v69)
        {
          v86 = 0u;
          v85 = 0u;
          v84 = 0u;
          v83 = 0u;
          v82 = 0u;
          v81 = 0u;
          v80 = 0u;
          v79 = 0u;
          if (v29)
          {
            v30 = 0;
            v31 = v29;
            v32 = v28;
            do
            {
              lengthAtOffsetOut = 0;
              CMBlockBufferGetDataPointer(a1, v32, &lengthAtOffsetOut, 0, 0);
              v33 = v31 >= lengthAtOffsetOut;
              v31 -= lengthAtOffsetOut;
              if (!v33)
                break;
              v30 += lengthAtOffsetOut;
              v32 += lengthAtOffsetOut;
              *((_BYTE *)&v79 + v30 - 1) = 1;
            }
            while (v31);
          }
        }
        v34 = v27 - v29;
        CMBlockBufferAccessDataBytes(a1, v28, v29, temporaryBlock, &returnedPointerOut);
        if (v70 && v34)
        {
          if (!v29)
          {
LABEL_50:
            ++v26;
            v74 += v29;
            goto LABEL_124;
          }
          v35 = returnedPointerOut;
          v36 = v29;
          while (!*v35++)
          {
            if (!--v36)
              goto LABEL_50;
          }
        }
        v72 = v27 - v29;
        if (v26)
        {
          snprintf(__str, 0x400uLL, "    * %zd zeroes", v74);
          result = v71(a8, __str);
          if ((_DWORD)result)
            return result;
          v74 = 0;
        }
        v38 = fmtcheck(v67, "%zd");
        v39 = snprintf(__str, 0x400uLL, v38, v28 - offset);
        v40 = 1024 - v39;
        if (v39 >= 1024)
          v41 = 0;
        else
          v41 = v39;
        v42 = &__str[v41];
        if (v39 >= 1024)
          v40 = 0;
        if (v29)
        {
          v43 = 0;
          do
          {
            v44 = v40;
            if ((v9 & 0x10) != 0)
            {
              v46 = snprintf(v42, v40, "0x%02X, ", returnedPointerOut[v43++]);
            }
            else
            {
              if (!v18 || (v45 = "", (((_BYTE)v43 + 1) & 3) == 0))
              {
                v45 = " ";
                if (*((_BYTE *)&v79 + v43))
                  v45 = "|";
              }
              v46 = snprintf(v42, v40, "%02X%s", returnedPointerOut[v43++], v45);
            }
            v40 = v44 - v46;
            if (v44 <= v46)
              v47 = 0;
            else
              v47 = v46;
            v42 += v47;
            if (v44 <= v46)
              v40 = 0;
          }
          while (v43 != v29);
        }
        v48 = v40;
        v49 = v29;
        if (v23 > v27)
        {
          do
          {
            if ((v9 & 0x10) != 0)
            {
              v52 = snprintf(v42, v48, "      ");
              ++v49;
            }
            else
            {
              v50 = (++v49 & 3) == 0 || v18 == 0;
              v51 = "";
              if (v50)
                v51 = " ";
              v52 = snprintf(v42, v48, "  %s", v51);
            }
            if (v48 <= v52)
              v53 = 0;
            else
              v53 = v52;
            v42 += v53;
            if (v48 <= v52)
              v48 = 0;
            else
              v48 -= v52;
          }
          while (v49 != v23);
        }
        v54 = snprintf(v42, v48, "  ");
        if (v48 <= v54)
          v55 = 0;
        else
          v55 = v54;
        v56 = &v42[v55];
        if (v48 <= v54)
          v57 = 0;
        else
          v57 = v48 - v54;
        if ((v9 & 0x10) == 0)
        {
          if (v29)
            break;
          goto LABEL_120;
        }
        v58 = snprintf(v56, v57, "/* ");
        if (v57 <= v58)
        {
          v57 = 0;
        }
        else
        {
          v56 += v58;
          v57 -= v58;
        }
        if (v29)
          break;
LABEL_120:
        if ((v9 & 0x10) != 0)
          snprintf(v56, v57, " */");
        result = v71(a8, __str);
        v34 = v72;
        if ((_DWORD)result)
          return result;
        v26 = 0;
LABEL_124:
        v28 += v29;
        v27 = v34;
        if (!v34)
          goto LABEL_125;
      }
      v59 = 0;
      while (1)
      {
        v60 = returnedPointerOut[v59];
        if (returnedPointerOut[v59] < 0)
        {
          if (!__maskrune(returnedPointerOut[v59], 0x40000uLL))
          {
LABEL_112:
            v62 = 46;
            goto LABEL_113;
          }
          v61 = __maskrune(v60, 0x200uLL);
        }
        else
        {
          if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * returnedPointerOut[v59] + 60) & 0x40000) == 0)
            goto LABEL_112;
          v61 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * returnedPointerOut[v59] + 60) & 0x200;
        }
        if (v61)
          v62 = 46;
        else
          v62 = v60;
LABEL_113:
        v63 = snprintf(v56, v57, "%c", v62);
        if (v57 <= v63)
          v64 = 0;
        else
          v64 = v63;
        v56 += v64;
        if (v57 <= v63)
          v57 = 0;
        else
          v57 -= v63;
        if (v29 == ++v59)
          goto LABEL_120;
      }
    }
LABEL_125:
    if (v65 + offset < v66)
      v71(a8, "  ...");
    return v71(a8, 0);
  }
  return result;
}

uint64_t DefaultBBufHexDumpEmitter(uint64_t a1, const char *a2)
{
  if (a2)
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "%s\n", a2);
  return 0;
}

size_t FigBlockBufferHexDump(OpaqueCMBlockBuffer *a1, size_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unsigned int a6)
{
  return FigBlockBufferHexDumpWithEmitter(a1, a2, a3, a4, a5, a6, DefaultBBufHexDumpEmitter, 0);
}

size_t FigBlockBufferAppendHexDumpToCFString(OpaqueCMBlockBuffer *a1, size_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unsigned int a6, uint64_t a7)
{
  return FigBlockBufferHexDumpWithEmitter(a1, a2, a3, a4, a5, a6, (uint64_t (*)(uint64_t, const char *))cfStringBBufHexDumpEmitter, a7);
}

uint64_t cfStringBBufHexDumpEmitter(__CFString *a1, uint64_t a2)
{
  if (a2)
    CFStringAppendFormat(a1, 0, CFSTR("%s\n"), a2);
  return 0;
}

uint64_t FigBlockBufferCompare(OpaqueCMBlockBuffer *a1, OpaqueCMBlockBuffer *a2)
{
  size_t DataLength;
  size_t v5;
  size_t v6;
  size_t v7;
  uint64_t result;
  BOOL v9;
  char *v10;
  char *dataPointerOut;
  size_t v12;
  size_t lengthAtOffsetOut;

  DataLength = CMBlockBufferGetDataLength(a1);
  v5 = CMBlockBufferGetDataLength(a2);
  if (DataLength == v5)
  {
    v6 = 0;
    while (1)
    {
      v12 = 0;
      lengthAtOffsetOut = 0;
      v10 = 0;
      dataPointerOut = 0;
      CMBlockBufferGetDataPointer(a1, v6, &lengthAtOffsetOut, 0, &dataPointerOut);
      CMBlockBufferGetDataPointer(a2, v6, &v12, 0, &v10);
      v7 = lengthAtOffsetOut >= v12 ? v12 : lengthAtOffsetOut;
      if (!v7)
        break;
      result = memcmp(dataPointerOut, v10, v7);
      v6 += v7;
      if ((_DWORD)result)
        v9 = 1;
      else
        v9 = v6 >= DataLength;
      if (v9)
        return result;
    }
    if (lengthAtOffsetOut == v12)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  else if (DataLength > v5)
  {
    return 1;
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

uint64_t FigCreateCFDataWithBlockBufferNoCopy(const __CFAllocator *a1, CMBlockBufferRef theBuffer, size_t offset, unint64_t a4, CFDataRef *a5)
{
  uint64_t result;
  uint64_t v10;
  const __CFAllocator *v11;
  const __CFAllocator *v12;
  CFDataRef v13;
  size_t lengthAtOffsetOut;
  CFAllocatorContext context;
  char *dataPointerOut;

  if (a5)
  {
    dataPointerOut = 0;
    lengthAtOffsetOut = 0;
    result = CMBlockBufferGetDataPointer(theBuffer, offset, &lengthAtOffsetOut, 0, &dataPointerOut);
    if ((_DWORD)result)
    {
LABEL_13:
      v13 = 0;
      goto LABEL_9;
    }
    if (a4)
    {
      if (lengthAtOffsetOut < a4)
      {
        v10 = 4294954592;
LABEL_12:
        result = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
        goto LABEL_13;
      }
    }
    else
    {
      a4 = lengthAtOffsetOut;
    }
    context.version = 0;
    context.info = theBuffer;
    context.retain = (CFAllocatorRetainCallBack)MEMORY[0x1E0C98BD0];
    context.release = (CFAllocatorReleaseCallBack)MEMORY[0x1E0C98BC0];
    context.copyDescription = 0;
    context.allocate = (CFAllocatorAllocateCallBack)BBufUtilDummyAllocate;
    context.deallocate = (CFAllocatorDeallocateCallBack)BBufUtilDummyDeallocate;
    context.preferredSize = 0;
    context.reallocate = 0;
    v11 = CFAllocatorCreate(a1, &context);
    if (v11)
    {
      v12 = v11;
      v13 = CFDataCreateWithBytesNoCopy(a1, (const UInt8 *)dataPointerOut, a4, v11);
      CFRelease(v12);
      result = 0;
LABEL_9:
      *a5 = v13;
      return result;
    }
    v10 = 4294954596;
    goto LABEL_12;
  }
  return FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
}

uint64_t BBufUtilDummyAllocate()
{
  return 0;
}

uint64_t FigCreateBlockBufferWithCFDataNoCopy(const __CFAllocator *a1, CFDataRef theData, unint64_t a3, size_t a4, CMBlockBufferRef *a5)
{
  const UInt8 *BytePtr;
  unint64_t Length;
  uint64_t v12;
  uint64_t v13;
  CMBlockBufferCustomBlockSource customBlockSource;
  CMBlockBufferRef blockBufferOut;

  blockBufferOut = 0;
  if (!theData)
  {
    v13 = FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
    if (!a5)
      return v13;
    goto LABEL_12;
  }
  if (a5)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(theData);
    if (!BytePtr)
    {
      v12 = 4294954591;
      goto LABEL_19;
    }
    if (Length > a3)
    {
      if (a4)
      {
        if (Length < a4)
        {
          v12 = 4294954592;
          goto LABEL_19;
        }
        if (Length - a4 < a3)
          goto LABEL_8;
      }
      else
      {
        a4 = Length - a3;
      }
      customBlockSource.version = 0;
      customBlockSource.AllocateBlock = 0;
      customBlockSource.FreeBlock = (void (__cdecl *)(void *, void *, size_t))BBufUtilCFDataReleaser;
      customBlockSource.refCon = (void *)CFRetain(theData);
      v13 = CMBlockBufferCreateWithMemoryBlock(a1, (void *)&BytePtr[a3], a4, 0, &customBlockSource, 0, a4, 0, &blockBufferOut);
      if ((_DWORD)v13)
        CFRelease(theData);
      goto LABEL_12;
    }
LABEL_8:
    v12 = 4294954593;
LABEL_19:
    v13 = FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
LABEL_12:
    *a5 = blockBufferOut;
    return v13;
  }
  return FigSignalErrorAt(4294954591, 0, 0, 0, 0, 0, 0);
}

uint64_t FigCreateBlockBufferWithCFString(const __CFAllocator *a1, CFStringRef theString, CMBlockBufferRef *a3)
{
  const __CFString *v4;
  const char *CStringPtr;
  char *v7;
  void *v8;
  const __CFData *ExternalRepresentation;
  size_t Length;
  uint64_t v11;
  size_t v12;
  uint64_t v13;
  CMBlockBufferCustomBlockSource customBlockSource;
  CMBlockBufferRef blockBufferOut;

  v4 = theString;
  blockBufferOut = 0;
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  if (!CStringPtr)
  {
    ExternalRepresentation = CFStringCreateExternalRepresentation(a1, v4, 0x8000100u, 0x3Fu);
    if (!ExternalRepresentation)
    {
      v11 = 4294954510;
      if (!a3)
        return v11;
      goto LABEL_11;
    }
    v4 = (const __CFString *)ExternalRepresentation;
    Length = CFDataGetLength(ExternalRepresentation);
    v11 = FigCreateBlockBufferWithCFDataNoCopy(a1, (CFDataRef)v4, 0, Length, &blockBufferOut);
    goto LABEL_9;
  }
  v7 = (char *)CStringPtr;
  customBlockSource.version = 0;
  if (v4)
    v8 = (void *)CFRetain(v4);
  else
    v8 = 0;
  customBlockSource.AllocateBlock = 0;
  customBlockSource.FreeBlock = (void (__cdecl *)(void *, void *, size_t))BBufUtilCFStringReleaser;
  customBlockSource.refCon = v8;
  v12 = strlen(v7);
  v13 = CMBlockBufferCreateWithMemoryBlock(a1, v7, v12, 0, &customBlockSource, 0, v12, 0, &blockBufferOut);
  v11 = v13;
  if (v4 && (_DWORD)v13)
LABEL_9:
    CFRelease(v4);
  if (a3)
LABEL_11:
    *a3 = blockBufferOut;
  return v11;
}

uint64_t FigCreateBlockBufferCopyingMemoryBlock(CFAllocatorRef blockAllocator, const void *a2, size_t dataLength, CMBlockBufferRef *a4)
{
  uint64_t v7;
  uint64_t v8;
  CMBlockBufferRef destinationBuffer;

  destinationBuffer = 0;
  v7 = CMBlockBufferCreateWithMemoryBlock(blockAllocator, 0, dataLength, blockAllocator, 0, 0, dataLength, 1u, &destinationBuffer);
  if ((_DWORD)v7)
  {
    v8 = v7;
  }
  else
  {
    v8 = CMBlockBufferReplaceDataBytes(a2, destinationBuffer, 0, dataLength);
    if (!(_DWORD)v8)
    {
      *a4 = destinationBuffer;
      return v8;
    }
  }
  if (destinationBuffer)
    CFRelease(destinationBuffer);
  return v8;
}

uint64_t FigMakeIOVecArrayWithBlockBuffer(CMBlockBufferRef theBuffer, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v6;
  size_t v7;
  size_t *v8;
  uint64_t v9;
  uint64_t result;
  size_t v11;
  size_t totalLengthOut;

  v6 = 0;
  v7 = 0;
  totalLengthOut = 0;
  v8 = (size_t *)(a2 + 8);
  v9 = a3 & ~(a3 >> 31);
  while (v9 != v6)
  {
    result = CMBlockBufferGetDataPointer(theBuffer, v7, v8, &totalLengthOut, (char **)v8 - 1);
    if ((_DWORD)result)
      return result;
    v11 = *v8;
    v8 += 2;
    v7 += v11;
    ++v6;
    if (v7 >= totalLengthOut)
    {
      result = 0;
      *a4 = v6;
      return result;
    }
  }
  return 4294954588;
}

void CMMemoryPoolInvalidate(CMMemoryPoolRef pool)
{
  uint64_t v1;

  v1 = *((_QWORD *)pool + 2);
  if (v1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(v1 + 56));
    if (*(_BYTE *)(v1 + 16))
    {
      *(_BYTE *)(v1 + 16) = 0;
      poolBlockState_FreeBlocks(v1, 1);
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v1 + 56));
  }
}

void poolBlockState_FreeBlocks(uint64_t a1, int a2)
{
  int64_t UpTimeNanoseconds;
  CFIndex Count;
  unint64_t v6;
  uint64_t v7;
  const void **ValueAtIndex;
  const void **v9;
  int64_t v10;
  uint64_t v11;

  if (a2)
  {
    UpTimeNanoseconds = 0;
  }
  else
  {
    UpTimeNanoseconds = FigGetUpTimeNanoseconds();
    if (UpTimeNanoseconds < *(_QWORD *)(a1 + 48))
      return;
  }
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 72));
  if (Count < 1)
  {
    v7 = 0x7FFFFFFFFFFFFFFFLL;
    if (!a2)
      goto LABEL_21;
    return;
  }
  v6 = Count + 1;
  v7 = 0x7FFFFFFFFFFFFFFFLL;
  do
  {
    ValueAtIndex = (const void **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), v6 - 2);
    v9 = ValueAtIndex;
    if (*((_DWORD *)ValueAtIndex + 8))
    {
      v10 = (int64_t)ValueAtIndex[3];
LABEL_8:
      if (v7 >= v10)
        v7 = v10;
      if (a2)
        goto LABEL_17;
      goto LABEL_15;
    }
    if (a2 != 1)
    {
      v10 = (int64_t)ValueAtIndex[3];
      if (v10 >= UpTimeNanoseconds)
        goto LABEL_8;
    }
    poolBlockState_DeallocateVMMemory((uint64_t)ValueAtIndex);
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 72), v6 - 2);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 80), *v9);
    poolBlockState_postForgottenSerialNumber((const void *)a1, (uint64_t *)v9);
    free(v9);
    if (a2)
      goto LABEL_17;
LABEL_15:
    if ((((_BYTE)v6 - 2) & 0xF) == 0 && (uint64_t)(FigGetUpTimeNanoseconds() - UpTimeNanoseconds) >= 5000001)
      return;
LABEL_17:
    --v6;
  }
  while (v6 > 1);
  if (a2)
    return;
LABEL_21:
  v11 = UpTimeNanoseconds + 5000000;
  if (v7 > UpTimeNanoseconds + 5000000)
    v11 = v7;
  *(_QWORD *)(a1 + 48) = v11;
}

CFTypeID CMMemoryPoolGetTypeID(void)
{
  FigThreadRunOnce(&sRegisterFigMemoryPoolTypeOnce, (void (*)(void))RegisterFigMemoryPoolType);
  return sFigMemoryPoolID;
}

uint64_t RegisterFigMemoryPoolType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigMemoryPoolID = result;
  return result;
}

CMMemoryPoolRef CMMemoryPoolCreate(CFDictionaryRef options)
{
  uint64_t v1;
  const __CFAllocator *v2;
  const __CFNumber *Value;
  const __CFNumber *v5;
  CFTypeID TypeID;
  const void *v7;
  uint64_t Instance;
  uint64_t v9;
  double valuePtr;
  CFAllocatorContext context;

  v1 = 500000000;
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *(_OWORD *)&context.copyDescription = xmmword_1E28DDE88;
  *(_OWORD *)&context.reallocate = *(_OWORD *)off_1E28DDE98;
  context.preferredSize = 0;
  *(_OWORD *)&context.version = xmmword_1E28DDE68;
  *(_OWORD *)&context.retain = *(_OWORD *)algn_1E28DDE78;
  if (options)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(options, CFSTR("FigMemoryPool_AgeOutPeriod"));
    if (Value)
    {
      v5 = Value;
      TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(v5))
      {
        valuePtr = 0.0;
        CFNumberGetValue(v5, kCFNumberDoubleType, &valuePtr);
        if (valuePtr > 0.0)
          v1 = (uint64_t)(valuePtr * 1000.0 * 1000.0 * 1000.0);
      }
    }
    v7 = CFDictionaryGetValue(options, CFSTR("FigMemoryPool_LoggingName"));
  }
  else
  {
    v7 = 0;
  }
  FigThreadRunOnce(&sRegisterFigMemoryPoolTypeOnce, (void (*)(void))RegisterFigMemoryPoolType);
  Instance = _CFRuntimeCreateInstance();
  v9 = Instance;
  if (Instance)
  {
    if (!poolBlockState_Create(v2, Instance, v1, 1, 0x40000, v7, (_QWORD *)(Instance + 16)))
    {
      context.info = (void *)CFRetain(*(CFTypeRef *)(v9 + 16));
      *(_QWORD *)(v9 + 24) = CFAllocatorCreate(0, &context);
    }
  }
  else
  {
    FigSignalErrorAt(4294951806, 0, 0, 0, 0, 0, 0);
  }
  return (CMMemoryPoolRef)v9;
}

CFTypeRef poolingAllocator_CopyDescription()
{
  return CFRetain(CFSTR("FigMemoryPoolAllocator"));
}

vm_address_t poolingAllocator_Allocate(vm_address_t a1, uint64_t a2, uint64_t a3)
{
  return poolBlockState_AllocateInternal(a1, a3, 0, 0);
}

void *poolingAllocator_Reallocate(const void *a1, vm_address_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *Value;
  vm_address_t v8;
  void *Internal;
  void *v10;
  size_t v11;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a4 + 56));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 64), a1);
  if (Value)
  {
    v8 = Value[1];
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a4 + 56));
    Internal = (void *)poolBlockState_AllocateInternal(a2, a4, 0, 0);
    v10 = Internal;
    if (Internal)
    {
      if (v8 >= a2)
        v11 = a2;
      else
        v11 = v8;
      memcpy(Internal, a1, v11);
      poolingAllocator_Deallocate(a1, a4);
    }
  }
  else
  {
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a4 + 56));
    return 0;
  }
  return v10;
}

uint64_t poolingAllocator_Deallocate(const void *a1, uint64_t a2)
{
  const void **Value;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a2 + 56));
  Value = (const void **)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 64), a1);
  if (Value)
    poolBlockState_DecrementUseCountInternal(a2, Value);
  poolBlockState_FreeBlocks(a2, 0);
  return FigSimpleMutexUnlock(*(pthread_mutex_t **)(a2 + 56));
}

uint64_t poolBlockState_Create(const __CFAllocator *a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, const void *a6, _QWORD *a7)
{
  uint64_t Instance;
  _QWORD *v15;
  CFTypeRef v16;
  pthread_mutex_t *v17;
  CFMutableDictionaryRef v18;
  CFMutableArrayRef v19;
  CFMutableDictionaryRef v20;
  uint64_t v21;
  CFArrayCallBacks v23;
  CFDictionaryValueCallBacks valueCallBacks;

  memset(&valueCallBacks, 0, sizeof(valueCallBacks));
  memset(&v23, 0, sizeof(v23));
  if (poolBlockState_GetTypeID_sRegisterPoolBlockStateTypeOnce != -1)
    dispatch_once_f(&poolBlockState_GetTypeID_sRegisterPoolBlockStateTypeOnce, &poolBlockState_GetTypeID_sPoolBlockStateID, (dispatch_function_t)poolBlockState_RegisterType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return FigSignalErrorAt(4294951806, 0, 0, 0, 0, 0, 0);
  v15 = (_QWORD *)Instance;
  *(_BYTE *)(Instance + 16) = a4;
  *(_QWORD *)(Instance + 24) = a5;
  *(_QWORD *)(Instance + 32) = a3;
  if (a6)
    v16 = CFRetain(a6);
  else
    v16 = 0;
  v15[5] = v16;
  v17 = FigSimpleMutexCreate();
  v15[7] = v17;
  if (a2)
  {
    v15[12] = FigCFWeakReferenceHolderCreateWithReferencedObject(a2);
    v17 = (pthread_mutex_t *)v15[7];
  }
  if (!v17)
    goto LABEL_15;
  valueCallBacks.copyDescription = (CFDictionaryCopyDescriptionCallBack)poolBlockState_copyBlockInfoDescription;
  v18 = CFDictionaryCreateMutable(a1, 0, 0, &valueCallBacks);
  v15[8] = v18;
  if (!v18)
    goto LABEL_15;
  v23.copyDescription = (CFArrayCopyDescriptionCallBack)poolBlockState_copyBlockInfoDescription;
  v19 = CFArrayCreateMutable(a1, 0, &v23);
  v15[9] = v19;
  if (v19 && (v20 = CFDictionaryCreateMutable(a1, 0, 0, &valueCallBacks), (v15[10] = v20) != 0))
  {
    v21 = 0;
    v15[11] = *MEMORY[0x1E0C85AD8];
    *a7 = v15;
  }
  else
  {
LABEL_15:
    v21 = FigSignalErrorAt(4294951806, 0, 0, 0, 0, 0, 0);
    CFRelease(v15);
  }
  return v21;
}

CFAllocatorRef CMMemoryPoolGetAllocator(CMMemoryPoolRef pool)
{
  return (CFAllocatorRef)*((_QWORD *)pool + 3);
}

BOOL FigMemoryPoolIsPoolAllocator(const __CFAllocator *a1)
{
  _BOOL8 result;
  CFAllocatorContext v2;

  memset(&v2, 0, sizeof(v2));
  result = 0;
  if (a1)
  {
    CFAllocatorGetContext(a1, &v2);
    if ((vm_address_t (*)(vm_address_t, uint64_t, uint64_t))v2.allocate == poolingAllocator_Allocate)
      return 1;
  }
  return result;
}

const __CFAllocator *FigMemoryPoolAllocatorCopyMemoryPool(const __CFAllocator *result, id **a2)
{
  id *v3;
  id *v4;
  id *v5;
  CFAllocatorContext v6;

  if (result)
  {
    if (a2)
    {
      memset(&v6, 0, sizeof(v6));
      CFAllocatorGetContext(result, &v6);
      if ((vm_address_t (*)(vm_address_t, uint64_t, uint64_t))v6.allocate == poolingAllocator_Allocate)
      {
        v3 = (id *)*((_QWORD *)v6.info + 12);
        if (v3 && (v4 = FigCFWeakReferenceHolderCopyReferencedObject(v3)) != 0)
        {
          v5 = v4;
          result = 0;
          *a2 = v5;
        }
        else
        {
          return (const __CFAllocator *)FigSignalErrorAt(4294951801, 0, 0, 0, 0, 0, 0);
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return (const __CFAllocator *)FigSignalErrorAt(4294951805, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

void CMMemoryPoolFlush(CMMemoryPoolRef pool)
{
  uint64_t v1;

  v1 = *((_QWORD *)pool + 2);
  if (v1)
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(v1 + 56));
    if (*(_BYTE *)(v1 + 16))
      poolBlockState_FreeBlocks(v1, 1);
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(v1 + 56));
  }
}

uint64_t FigMemoryPoolCopyStats(uint64_t a1, CFMutableDictionaryRef *a2)
{
  uint64_t v3;
  int Count;
  CFMutableDictionaryRef Mutable;

  if (!a1 || !a2)
    return FigSignalErrorAt(4294951805, 0, 0, 0, 0, 0, 0);
  v3 = *(_QWORD *)(a1 + 16);
  FigSimpleMutexLock(*(pthread_mutex_t **)(v3 + 56));
  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(v3 + 64));
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(v3 + 56));
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetInt32(Mutable, CFSTR("FigMemoryPool_NumberOfBlocksInUse"), Count);
  *a2 = Mutable;
  return 0;
}

const void *FigMemoryPoolCreateBlockBufferWithOptions(uint64_t a1, vm_address_t a2, char a3, uint64_t a4, CMBlockBufferRef *a5)
{
  void *v9;
  void *v10;
  const __CFAllocator *v11;
  const void *v12;
  const void *v13;
  size_t v14;
  int v15;
  CFNumberRef v16;
  uint64_t v18;
  char *dataPointerOut;
  int v20;
  size_t blockLength;
  uint64_t valuePtr;
  CMBlockBufferRef theBuffer;

  valuePtr = 0;
  theBuffer = 0;
  blockLength = 0;
  if (!a1)
  {
    v18 = 4294951805;
LABEL_15:
    v13 = (const void *)FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
  v9 = (void *)poolBlockState_AllocateInternal(a2, *(_QWORD *)(a1 + 16), &valuePtr, &blockLength);
  if (!v9)
  {
    v18 = 4294951806;
    goto LABEL_15;
  }
  v10 = v9;
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v12 = (const void *)CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9, blockLength, *(CFAllocatorRef *)(a1 + 24), 0, 0, a2, 0, &theBuffer);
  if ((_DWORD)v12)
  {
    v13 = v12;
    CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 24), v10);
LABEL_10:
    if (theBuffer)
      CFRelease(theBuffer);
    return v13;
  }
  v13 = CFNumberCreate(v11, kCFNumberSInt64Type, &valuePtr);
  CMSetAttachment(theBuffer, CFSTR("MemoryPoolBlockSerialNumber"), v13, 0);
  CMSetAttachment(theBuffer, CFSTR("OwningPoolBlockState"), *(CFTypeRef *)(a1 + 16), 0);
  if ((a3 & 1) != 0)
  {
    v14 = (a2 + 0x3FFF) & 0xFFFFFFFFFFFFC000;
    v15 = v14 - a2;
    if (v14 > a2 && v14 <= blockLength)
    {
      dataPointerOut = 0;
      CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut);
      v20 = v15;
      bzero(&dataPointerOut[a2], v15);
      v16 = CFNumberCreate(v11, kCFNumberSInt32Type, &v20);
      CMSetAttachment(theBuffer, CFSTR("NumTrailingPaddingBytes"), v16, 0);
      CFRelease(v16);
    }
  }
  *a5 = theBuffer;
  theBuffer = 0;
  if (v13)
  {
    CFRelease(v13);
    v13 = 0;
    goto LABEL_10;
  }
  return v13;
}

vm_address_t poolBlockState_AllocateInternal(vm_address_t result, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  unsigned int v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  vm_size_t v11;
  vm_size_t v12;
  CFIndex Count;
  vm_size_t v14;
  vm_size_t v15;
  CFIndex v16;
  vm_address_t *ValueAtIndex;
  _QWORD *v18;
  vm_size_t v19;
  vm_address_t v21;
  __CFDictionary *v22;
  const void *v23;
  vm_address_t v24;
  const void *v25;
  vm_address_t address;

  address = 0;
  if (result)
  {
    v7 = result;
    FigSimpleMutexLock(*(pthread_mutex_t **)(a2 + 56));
    v8 = 0;
    while (1)
    {
      v9 = dword_18EDDD938[v8 + 1];
      if ((v9 & (v7 >> 4)) != 0)
        break;
      v8 += 2;
      if (v8 == 12)
        goto LABEL_7;
    }
    v10 = (v7 + dword_18EDDD938[v8] - 1) & v9;
    if (v10)
      goto LABEL_8;
LABEL_7:
    v10 = (v7 + 0x3FFF) & 0xFFFFC000;
LABEL_8:
    v11 = v10;
    v12 = *(_QWORD *)(a2 + 24);
    Count = CFArrayGetCount(*(CFArrayRef *)(a2 + 72));
    if (Count < 1)
    {
      v18 = 0;
LABEL_20:
      if (vm_allocate(*MEMORY[0x1E0C83DA0], &address, v11, 1577058305))
      {
        address = 0;
        if (!v18)
        {
LABEL_26:
          poolBlockState_FreeBlocks(a2, 0);
          FigSimpleMutexUnlock(*(pthread_mutex_t **)(a2 + 56));
          return address;
        }
        if (!a3)
        {
LABEL_24:
          if (a4)
            *a4 = v18[1];
          goto LABEL_26;
        }
LABEL_23:
        *a3 = *v18;
        goto LABEL_24;
      }
      v18 = malloc_type_calloc(1uLL, 0x28uLL, 0x10800407C5467E8uLL);
      v24 = address;
      v18[1] = v11;
      v18[2] = v24;
      v18[3] = 0;
      *((_DWORD *)v18 + 8) = 1;
      v25 = (const void *)poolBlockState_newMemoryBlockSerialNumber();
      *v18 = v25;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a2 + 80), v25, v18);
      v22 = *(__CFDictionary **)(a2 + 64);
      v23 = (const void *)address;
    }
    else
    {
      v14 = v11 >> 1;
      if (v11 >> 1 >= v12)
        v14 = v12;
      v15 = v14 + v11;
      v16 = Count + 1;
      while (1)
      {
        ValueAtIndex = (vm_address_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 72), v16 - 2);
        v18 = ValueAtIndex;
        v19 = ValueAtIndex[1];
        if (v19 >= v11 && v19 <= v15)
          break;
        if ((unint64_t)--v16 < 2)
          goto LABEL_20;
      }
      address = ValueAtIndex[2];
      v21 = address;
      ++*((_DWORD *)ValueAtIndex + 8);
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a2 + 72), v16 - 2);
      v22 = *(__CFDictionary **)(a2 + 64);
      v23 = (const void *)v21;
    }
    CFDictionarySetValue(v22, v23, v18);
    if (!a3)
      goto LABEL_24;
    goto LABEL_23;
  }
  return result;
}

const void *FigMemoryPoolCreateBlockBuffer(uint64_t a1, vm_address_t a2, CMBlockBufferRef *a3, uint64_t a4)
{
  return FigMemoryPoolCreateBlockBufferWithOptions(a1, a2, 0, a4, a3);
}

uint64_t FigMemoryPoolCreateContiguousBlockBuffer(uint64_t a1, CFAllocatorRef structureAllocator, CFAllocatorRef blockAllocator, CMBlockBufferCustomBlockSource *customBlockSource, CMBlockBufferRef theBuffer, size_t offsetToData, size_t dataLength, CMBlockBufferFlags flags, CMBlockBufferRef *a9)
{
  uint64_t DataPointer;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v22;
  size_t v23;
  char *dataPointerOut;
  uint64_t v25;
  CMBlockBufferRef blockBufferOut;

  v25 = 0;
  blockBufferOut = 0;
  dataPointerOut = 0;
  if (FigMemoryPoolCreateContiguousBlockBuffer_onceToken != -1)
    dispatch_once_f(&FigMemoryPoolCreateContiguousBlockBuffer_onceToken, &FigMemoryPoolCreateContiguousBlockBuffer_do_not_use_memory_pool, (dispatch_function_t)fmp_readContiguousBlockBufferDefaultOnce);
  if (FigMemoryPoolCreateContiguousBlockBuffer_do_not_use_memory_pool)
  {
    DataPointer = CMBlockBufferCreateContiguous(structureAllocator, theBuffer, blockAllocator, customBlockSource, offsetToData, dataLength, flags, &blockBufferOut);
    if ((_DWORD)DataPointer)
      goto LABEL_22;
LABEL_19:
    v20 = 0;
    *a9 = blockBufferOut;
    return v20;
  }
  v18 = CMBlockBufferGetDataLength(theBuffer);
  if (v18 <= offsetToData || v18 - offsetToData < dataLength)
  {
    DataPointer = FigSignalErrorAt(4294954593, 0, 0, 0, 0, 0, 0);
    goto LABEL_22;
  }
  if (!dataLength)
    dataLength = v18 - offsetToData;
  if ((flags & 2) != 0
    || (v22 = 0,
        v23 = 0,
        FigBlockBufferGetDataPointerAndOrigin((uint64_t)theBuffer, offsetToData, &v23, 0, 0, &v25, &v22))|| v23 < dataLength|| !FigIsMemoryPoolBlockBuffer(theBuffer))
  {
    DataPointer = (uint64_t)FigMemoryPoolCreateBlockBufferWithOptions(a1, dataLength, flags, v19, &blockBufferOut);
    if (!(_DWORD)DataPointer)
    {
      DataPointer = CMBlockBufferGetDataPointer(blockBufferOut, 0, 0, 0, &dataPointerOut);
      if (!(_DWORD)DataPointer)
      {
        DataPointer = CMBlockBufferCopyDataBytes(theBuffer, offsetToData, dataLength, dataPointerOut);
        if (!(_DWORD)DataPointer)
          goto LABEL_19;
      }
    }
  }
  else
  {
    DataPointer = CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theBuffer, offsetToData, dataLength, flags, &blockBufferOut);
    if (!(_DWORD)DataPointer)
      goto LABEL_19;
  }
LABEL_22:
  v20 = DataPointer;
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v20;
}

uint64_t fmp_readContiguousBlockBufferDefaultOnce(_BYTE *a1)
{
  uint64_t result;

  result = FigGetCFPreferenceBooleanWithDefault(CFSTR("do_not_use_memory_pool_for_creating_contiguous_block_buffers"), CFSTR("com.apple.coremedia"), 0);
  *a1 = result;
  return result;
}

uint64_t FigIsMemoryPoolBlockBuffer(OpaqueCMBlockBuffer *a1)
{
  size_t DataLength;
  uint64_t result;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  CMAttachmentBearerRef target;

  v6 = 0;
  target = 0;
  DataLength = CMBlockBufferGetDataLength(a1);
  if (!CMBlockBufferIsRangeContiguous(a1, 0, DataLength))
  {
    v4 = 0;
    v5 = 0;
    while (!FigBlockBufferGetDataPointerAndOrigin((uint64_t)a1, v4, &v5, 0, 0, &target, &v6))
    {
      result = (uint64_t)CMGetAttachment(target, CFSTR("OwningPoolBlockState"), 0);
      if (!result)
        return result;
      result = (uint64_t)CMGetAttachment(target, CFSTR("MemoryPoolBlockSerialNumber"), 0);
      if (!result)
        return result;
      v4 += v5;
      if (v4 >= DataLength)
        return 1;
    }
    return 0;
  }
  if (FigBlockBufferGetDataPointerAndOrigin((uint64_t)a1, 0, 0, 0, 0, &target, &v6))
    return 0;
  result = (uint64_t)CMGetAttachment(target, CFSTR("OwningPoolBlockState"), 0);
  if (result)
    return CMGetAttachment(target, CFSTR("MemoryPoolBlockSerialNumber"), 0) != 0;
  return result;
}

uint64_t FigMemoryPoolBlockBufferGetPaddedWriteInfo(OpaqueCMBlockBuffer *a1, char **a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t result;
  const __CFNumber *v9;
  uint64_t v10;
  int valuePtr;
  char *dataPointerOut;
  size_t totalLengthOut;
  size_t lengthAtOffsetOut;

  totalLengthOut = 0;
  lengthAtOffsetOut = 0;
  dataPointerOut = 0;
  valuePtr = 0;
  result = CMBlockBufferGetDataPointer(a1, 0, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut);
  if (!(_DWORD)result)
  {
    if (lengthAtOffsetOut == totalLengthOut)
    {
      if (FigIsMemoryPoolBlockBuffer(a1)
        && (v9 = (const __CFNumber *)CMGetAttachment(a1, CFSTR("NumTrailingPaddingBytes"), 0)) != 0)
      {
        CFNumberGetValue(v9, kCFNumberSInt32Type, &valuePtr);
        v10 = valuePtr;
      }
      else
      {
        v10 = 0;
      }
      result = 0;
      *a2 = dataPointerOut;
      *a3 = totalLengthOut + v10;
      *a4 = v10;
    }
    else
    {
      return FigSignalErrorAt(4294951805, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

BOOL FigMemoryOriginIsBlockBufferSendable(uint64_t a1, CMBlockBufferRef theBuffer)
{
  size_t DataLength;
  _BOOL8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  const __CFNumber *v10;
  const __CFNumber *v11;
  unint64_t v13;
  uint64_t valuePtr;
  unint64_t v15;
  CMAttachmentBearerRef target;

  v15 = 0;
  target = 0;
  valuePtr = 0;
  DataLength = CMBlockBufferGetDataLength(theBuffer);
  if (!CMBlockBufferIsRangeContiguous(theBuffer, 0, DataLength))
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v13 = 0;
    while (1)
    {
      if (FigBlockBufferGetDataPointerAndOrigin((uint64_t)theBuffer, v8, &v13, 0, 0, &target, &v15))
        return 0;
      if (!CMGetAttachment(target, CFSTR("OwningPoolBlockState"), 0)
        || !CMGetAttachment(target, CFSTR("MemoryPoolBlockSerialNumber"), 0))
      {
        break;
      }
      v10 = (const __CFNumber *)CMGetAttachment(target, CFSTR("ImportedBlockSerialNumber"), 0);
      if (v10)
      {
        CFNumberGetValue(v10, kCFNumberSInt64Type, &valuePtr);
        v7 = valuePtr & 0xFFFF800000000000;
        v6 = 1;
        if (v9 && v9 != v7)
        {
          LODWORD(v5) = 0;
          return v7 == (unint64_t)*(unsigned int *)(a1 + 56) << 47 && v5;
        }
        v9 = valuePtr & 0xFFFF800000000000;
      }
      v8 += v13;
      if (v8 >= DataLength)
      {
        v5 = 1;
        goto LABEL_19;
      }
    }
    v5 = 0;
LABEL_19:
    if (v6)
      return v7 == (unint64_t)*(unsigned int *)(a1 + 56) << 47 && v5;
    return v5;
  }
  if (FigBlockBufferGetDataPointerAndOrigin((uint64_t)theBuffer, 0, 0, 0, 0, &target, &v15))
    return 0;
  if (CMGetAttachment(target, CFSTR("OwningPoolBlockState"), 0))
    v5 = CMGetAttachment(target, CFSTR("MemoryPoolBlockSerialNumber"), 0) != 0;
  else
    v5 = 0;
  v11 = (const __CFNumber *)CMGetAttachment(target, CFSTR("ImportedBlockSerialNumber"), 0);
  if (v11)
  {
    CFNumberGetValue(v11, kCFNumberSInt64Type, &valuePtr);
    v7 = valuePtr & 0xFFFF800000000000;
    return v7 == (unint64_t)*(unsigned int *)(a1 + 56) << 47 && v5;
  }
  return v5;
}

uint64_t FigMemoryOriginSetBlockBufferInIPCMessageData(uint64_t a1, CMBlockBufferRef theBuffer, uint64_t a3, unint64_t a4, unint64_t *a5)
{
  size_t DataLength;
  unint64_t v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t DataPointerAndOrigin;
  int64_t v15;
  uint64_t v17;
  unint64_t v18;
  const void **v19;
  const void *v20;
  uint64_t v23;
  int64_t v24;
  CMAttachmentBearerRef v25;
  int64_t v26;

  v25 = 0;
  v26 = 0;
  if (!theBuffer)
    return 0;
  if (a1)
  {
    DataLength = CMBlockBufferGetDataLength(theBuffer);
    v10 = 0;
    v11 = 0;
    v23 = a3;
    v24 = 0;
    v12 = 52;
    while (1)
    {
      v13 = v12;
      DataPointerAndOrigin = FigBlockBufferGetDataPointerAndOrigin((uint64_t)theBuffer, v10, (unint64_t *)&v24, 0, 0, &v25, (unint64_t *)&v26);
      if ((_DWORD)DataPointerAndOrigin)
        break;
      v15 = v24;
      if (v13 <= a4)
      {
        DataPointerAndOrigin = memoryOrigin_storeSubBlockDescription(a1, v25, v26, v24, 0, (int64_t *)(a3 + 40 * v11 + 12));
        if ((_DWORD)DataPointerAndOrigin)
          break;
        ++v11;
      }
      else
      {
        a3 = 0;
      }
      v10 += v15;
      v12 = v13 + 40;
      if (v10 >= DataLength)
      {
        if (a5)
          *a5 = v13;
        if (a3)
        {
          *(_QWORD *)a3 = *(_QWORD *)(a1 + 40);
          *(_DWORD *)(a3 + 8) = v11;
        }
        if (v13 <= a4 || v23 == 0)
          v17 = 0;
        else
          v17 = 4294951775;
        if ((_DWORD)v17)
          goto LABEL_25;
        return v17;
      }
    }
  }
  else
  {
    DataPointerAndOrigin = FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
  }
  v17 = DataPointerAndOrigin;
  if ((_DWORD)DataPointerAndOrigin)
  {
LABEL_25:
    if (a3 && *(_DWORD *)(a3 + 8))
    {
      v18 = 0;
      v19 = (const void **)(a3 + 28);
      do
      {
        v20 = *v19;
        v19 += 5;
        memoryOrigin_unregisterUseOfBlock(a1, v20);
        ++v18;
      }
      while (v18 < *(unsigned int *)(a3 + 8));
    }
  }
  return v17;
}

uint64_t memoryOrigin_storeSubBlockDescription(uint64_t a1, CMAttachmentBearerRef target, int64_t a3, int64_t a4, unint64_t a5, int64_t *a6)
{
  CFTypeRef v12;
  const __CFNumber *v13;
  const void *v14;
  xpc_object_t *v15;
  xpc_object_t *v16;
  xpc_object_t v17;
  _DWORD *v18;
  _DWORD *v19;
  __CFNotificationCenter *DefaultLocalCenter;
  uint64_t v21;
  __CFArray **v22;
  __CFArray **v23;
  __CFArray *Mutable;
  CFMutableArrayRef v25;
  int64_t v26;
  const __CFNumber *v27;
  const __CFNumber *v28;
  const __CFNumber *v29;
  int64_t v30;
  const void *valuePtr;
  uint64_t v33;
  int64_t value;

  valuePtr = 0;
  v12 = CMGetAttachment(target, CFSTR("OwningPoolBlockState"), 0);
  v13 = (const __CFNumber *)CMGetAttachment(target, CFSTR("MemoryPoolBlockSerialNumber"), 0);
  if (!v12 || !v13 || !(a5 | (unint64_t)a6))
  {
    v21 = FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
    goto LABEL_37;
  }
  CFNumberGetValue(v13, kCFNumberSInt64Type, &valuePtr);
  v14 = valuePtr;
  v33 = 0;
  value = 0;
  poolBlockState_IncrementBlockUseCountAndAccessMemory((uint64_t)v12, valuePtr, &value, &v33);
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  v15 = (xpc_object_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), v14);
  if (!v15)
  {
    v17 = xpc_shmem_create((void *)value, v33);
    if (v17)
    {
      v18 = malloc_type_calloc(1uLL, 0x20uLL, 0x10A0040D63CFB62uLL);
      if (v18)
      {
        v19 = v18;
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), v14, v18);
        if (!*(_QWORD *)(a1 + 72))
          *(_QWORD *)(a1 + 72) = FigOSTransactionCreateWithProcessName("FigMemoryOrigin", *(const char **)(a1 + 48), *(unsigned int *)(a1 + 56), 0, *(_QWORD *)(a1 + 64));
        if (!MEMORY[0x193FFAA5C](*(_QWORD *)(a1 + 32), v12))
        {
          DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
          FigNotificationCenterAddWeakListener(DefaultLocalCenter, (void *)a1, (CFNotificationCallback)memoryOrigin_poolNotificationListener, 0, (unint64_t)v12, 2, 0);
        }
        CFBagAddValue(*(CFMutableBagRef *)(a1 + 32), v12);
        *(_QWORD *)v19 = CFRetain(v12);
        v19[6] = 1;
        *((_QWORD *)v19 + 2) = v14;
        *((_QWORD *)v19 + 1) = xpc_retain(v17);
        goto LABEL_6;
      }
    }
    v21 = FigSignalErrorAt(4294951775, 0, 0, 0, 0, 0, 0);
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    if (!(_DWORD)v21)
      goto LABEL_15;
    poolBlockState_DecrementBlockUseCount((uint64_t)v12, v14);
    FigXPCRelease(v17);
LABEL_37:
    v17 = 0;
    goto LABEL_34;
  }
  v16 = v15;
  v17 = xpc_retain(v15[1]);
  ++*((_DWORD *)v16 + 6);
LABEL_6:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
LABEL_15:
  if (!sFigMemoryOriginTransactionThreadKey)
    goto LABEL_24;
  v22 = (__CFArray **)FigThreadGetValue(sFigMemoryOriginTransactionThreadKey);
  if (!v22)
    goto LABEL_24;
  v23 = v22;
  if (!*(_BYTE *)v22)
    goto LABEL_24;
  Mutable = v22[1];
  if (!Mutable)
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 10, MEMORY[0x1E0C9B378]);
    v23[1] = Mutable;
    if (!Mutable)
      goto LABEL_38;
  }
  if (!v23[2])
  {
    v25 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 10, MEMORY[0x1E0C9B378]);
    v23[2] = v25;
    if (v25)
    {
      Mutable = v23[1];
      goto LABEL_23;
    }
LABEL_38:
    v21 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    FigXPCRelease(0);
    if ((_DWORD)v21)
      goto LABEL_34;
    goto LABEL_25;
  }
LABEL_23:
  CFArrayAppendValue(Mutable, (const void *)a1);
  FigCFArrayAppendInt64(v23[2], (uint64_t)v14);
LABEL_24:
  FigXPCRelease(0);
LABEL_25:
  if (a5)
  {
    xpc_dictionary_set_int64((xpc_object_t)a5, "OffsetInOrigin", a3);
    xpc_dictionary_set_int64((xpc_object_t)a5, "BlockBufferLength", a4);
    xpc_dictionary_set_int64((xpc_object_t)a5, "BlockSerialNumber", (int64_t)valuePtr);
    xpc_dictionary_set_value((xpc_object_t)a5, "OriginData", v17);
  }
  else
  {
    *a6 = a3;
    a6[1] = a4;
    v26 = (int64_t)valuePtr;
    a6[3] = 0;
    a6[4] = 0;
    a6[2] = v26;
  }
  v27 = (const __CFNumber *)CMGetAttachment(target, CFSTR("ImportedBlockSerialNumber"), 0);
  v28 = (const __CFNumber *)CMGetAttachment(target, CFSTR("RecipientObjectID"), 0);
  v21 = 0;
  if (v27)
  {
    v29 = v28;
    if (v28)
    {
      v33 = 0;
      value = 0;
      CFNumberGetValue(v27, kCFNumberSInt64Type, &value);
      CFNumberGetValue(v29, kCFNumberSInt64Type, &v33);
      v30 = value;
      if (a5)
      {
        xpc_dictionary_set_int64((xpc_object_t)a5, "RoundTripBlockSerialNumber", value);
        xpc_dictionary_set_uint64((xpc_object_t)a5, "RoundTripOriginObjectID", v33);
      }
      else
      {
        a6[3] = v33;
        a6[4] = v30;
      }
      v21 = 0;
    }
  }
LABEL_34:
  FigXPCRelease(v17);
  return v21;
}

uint64_t memoryOrigin_unregisterUseOfBlock(uint64_t a1, const void *a2)
{
  CFTypeRef *Value;
  const void *v5;

  if (!a2)
    return FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  Value = (CFTypeRef *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), a2);
  if (Value)
  {
    --*((_DWORD *)Value + 6);
    v5 = CFRetain(*Value);
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    poolBlockState_DecrementBlockUseCount((uint64_t)v5, a2);
    if (v5)
    {
      CFRelease(v5);
      return 0;
    }
  }
  else
  {
    v5 = (const void *)FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    if (!(_DWORD)v5)
      poolBlockState_DecrementBlockUseCount(0, a2);
  }
  return (uint64_t)v5;
}

uint64_t FigMemoryOriginSetBlockBufferInXPCMessage(uint64_t a1, void *a2, const char *a3, OpaqueCMBlockBuffer *a4)
{
  xpc_object_t v8;
  size_t DataLength;
  uint64_t v10;
  xpc_object_t v11;
  unint64_t v12;
  uint64_t DataPointerAndOrigin;
  xpc_object_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t count;
  size_t v18;
  size_t i;
  xpc_object_t value;
  const void *int64;
  int64_t v23;
  CMAttachmentBearerRef v24;
  int64_t v25;
  int64_t v26;

  v25 = 0;
  v26 = 0;
  v24 = 0;
  if (!a4)
  {
    v11 = 0;
    v14 = 0;
    v8 = 0;
    goto LABEL_18;
  }
  if (!a1 || !a2 || !a3)
  {
    v16 = FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
    v11 = 0;
    v14 = 0;
    v8 = 0;
    goto LABEL_19;
  }
  v8 = xpc_dictionary_create(0, 0, 0);
  if (!v8)
  {
    v10 = FigSignalErrorAt(4294951775, 0, 0, 0, 0, 0, 0);
    goto LABEL_32;
  }
  DataLength = CMBlockBufferGetDataLength(a4);
  if (!CMBlockBufferIsRangeContiguous(a4, 0, DataLength))
  {
    v23 = 0;
    v11 = xpc_array_create(0, 0);
    v12 = 0;
    do
    {
      DataPointerAndOrigin = FigBlockBufferGetDataPointerAndOrigin((uint64_t)a4, v12, (unint64_t *)&v23, 0, 0, &v24, (unint64_t *)&v25);
      if ((_DWORD)DataPointerAndOrigin)
      {
        v16 = DataPointerAndOrigin;
        goto LABEL_26;
      }
      v14 = xpc_dictionary_create(0, 0, 0);
      if (!v14)
      {
        v15 = FigSignalErrorAt(4294951775, 0, 0, 0, 0, 0, 0);
LABEL_28:
        v16 = v15;
        goto LABEL_19;
      }
      v15 = memoryOrigin_storeSubBlockDescription(a1, v24, v25, v23, (unint64_t)v14, 0);
      if ((_DWORD)v15)
        goto LABEL_28;
      xpc_array_set_value(v11, 0xFFFFFFFFFFFFFFFFLL, v14);
      xpc_release(v14);
      v12 += v23;
    }
    while (v12 < DataLength);
    xpc_dictionary_set_value(v8, "SubBlockArray", v11);
    if (v11)
      xpc_release(v11);
    goto LABEL_17;
  }
  v10 = FigBlockBufferGetDataPointerAndOrigin((uint64_t)a4, 0, 0, &v26, 0, &v24, (unint64_t *)&v25);
  if (!(_DWORD)v10)
  {
    v10 = memoryOrigin_storeSubBlockDescription(a1, v24, v25, v26, (unint64_t)v8, 0);
    if (!(_DWORD)v10)
    {
LABEL_17:
      xpc_dictionary_set_uint64(v8, ".objectID", *(_QWORD *)(a1 + 40));
      xpc_dictionary_set_value(a2, a3, v8);
      v11 = 0;
      v14 = 0;
LABEL_18:
      v16 = 0;
      goto LABEL_19;
    }
  }
LABEL_32:
  v16 = v10;
  v11 = 0;
LABEL_26:
  v14 = 0;
LABEL_19:
  FigXPCRelease(v8);
  FigXPCRelease(v14);
  if (v11)
  {
    count = xpc_array_get_count(v11);
    if (count)
    {
      v18 = count;
      for (i = 0; i != v18; ++i)
      {
        value = xpc_array_get_value(v11, i);
        int64 = (const void *)xpc_dictionary_get_int64(value, "BlockSerialNumber");
        memoryOrigin_unregisterUseOfBlock(a1, int64);
      }
    }
    FigXPCRelease(v11);
  }
  return v16;
}

uint64_t FigMemoryOriginUpdateRecipientStateFromXPCMessage(uint64_t a1, void *a2, const char *a3)
{
  uint64_t v4;
  CFTypeRef v5;
  uint64_t v6;
  CFTypeRef cf;

  cf = 0;
  if (a1 && a2)
  {
    v4 = FigXPCMessageCopyCFArray(a2, a3, &cf);
    v5 = cf;
    if ((_DWORD)v4)
    {
      v6 = v4;
      if (!cf)
        return v6;
    }
    else
    {
      v6 = memoryOrigin_unregisterUseOfMultipleBlocks(a1, (CFArrayRef)cf);
      v5 = cf;
      if (!cf)
        return v6;
    }
    CFRelease(v5);
    return v6;
  }
  return FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
}

uint64_t memoryOrigin_unregisterUseOfMultipleBlocks(uint64_t a1, CFArrayRef theArray)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  uint64_t v7;
  unsigned int v8;
  const void *v10;

  if (!theArray)
    return 0;
  Count = CFArrayGetCount(theArray);
  if (Count < 1)
    return 0;
  v5 = Count;
  v6 = 0;
  LODWORD(v7) = 0;
  do
  {
    v10 = 0;
    FigCFArrayGetInt64AtIndex(theArray, v6, &v10);
    v8 = memoryOrigin_unregisterUseOfBlock(a1, v10);
    if (v8)
      v7 = v8;
    else
      v7 = v7;
    ++v6;
  }
  while (v5 != v6);
  return v7;
}

uint64_t FigMemoryOriginUpdateRecipientStateFromIPCMessageData(uint64_t a1, unsigned int *a2, unint64_t a3)
{
  uint64_t v4;
  unint64_t v6;
  uint64_t v7;
  unsigned int v8;

  if (a1 && a2)
  {
    if (!a3)
      return 0;
    v4 = *a2;
    if (((8 * v4) | 4uLL) <= a3)
    {
      if ((_DWORD)v4)
      {
        v6 = 0;
        LODWORD(v7) = 0;
        do
        {
          v8 = memoryOrigin_unregisterUseOfBlock(a1, *(const void **)&a2[2 * v6 + 1]);
          if (v8)
            v7 = v8;
          else
            v7 = v7;
          ++v6;
        }
        while (v6 < *a2);
        return v7;
      }
      return 0;
    }
  }
  return FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
}

uint64_t FigMemoryOriginBeginEstablishingMemoryRecipientByFillingInXPCMessage1(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  xpc_object_t v4;
  xpc_object_t value;

  value = 0;
  if (EnsureMemoryOriginServerStarted_sMemoryOriginServerStartOnce != -1)
    dispatch_once(&EnsureMemoryOriginServerStarted_sMemoryOriginServerStartOnce, &__block_literal_global_62_0);
  v2 = EnsureMemoryOriginServerStarted_sMemoryOriginServerStartError;
  if (EnsureMemoryOriginServerStarted_sMemoryOriginServerStartError)
  {
    v4 = 0;
  }
  else
  {
    v3 = gMemoryOriginServerToken;
    v2 = FigXPCServerCopyXPCEndpoint(gMemoryOriginServer, &value);
    v4 = value;
    if (!(_DWORD)v2)
    {
      xpc_dictionary_set_value(a1, "MemoryOriginEndpoint", value);
      xpc_dictionary_set_uint64(a1, "MemoryOriginServerToken", v3);
      v4 = value;
    }
  }
  FigXPCRelease(v4);
  return v2;
}

uint64_t FigMemoryOriginCompleteEstablishingMemoryRecipientUsingXPCMessage2(void *a1, _QWORD *a2)
{
  void *uint64;

  uint64 = (void *)xpc_dictionary_get_uint64(a1, "OriginObjectID");
  return FigXPCServerRetainNeighborObjectFromID((uint64_t *)gMemoryOriginServer, uint64, a2);
}

uint64_t FigMemoryOriginGetObjectID(uint64_t a1, _QWORD *a2)
{
  if (!a1 || !a2)
    return FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
  *a2 = *(_QWORD *)(a1 + 40);
  return 0;
}

uint64_t FigMemoryOriginServerCopyMemoryOriginForObjectID(void *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;

  v5 = 0;
  if (a2)
  {
    *a2 = 0;
    if (a1)
    {
      if (gMemoryOriginServer)
      {
        result = FigXPCServerRetainNeighborObjectFromID((uint64_t *)gMemoryOriginServer, a1, &v5);
        *a2 = v5;
        return result;
      }
      v4 = 4294951774;
    }
    else
    {
      v4 = 4294951776;
    }
  }
  else
  {
    v4 = 4294951776;
  }
  return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
}

uint64_t FigMemoryRecipientCopyBlockBufferFromIPCMessageData(CFAllocatorRef structureAllocator, uint64_t a2, uint64_t a3, unint64_t a4, CMBlockBufferRef *a5)
{
  uint32_t v8;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int64_t *v13;
  uint64_t appended;
  CMBlockBufferRef v15;
  CMBlockBufferRef targetBBuf;
  CMBlockBufferRef blockBufferOut;

  targetBBuf = 0;
  blockBufferOut = 0;
  if (!a2 || !a3)
  {
    v11 = FigSignalErrorAt(4294951766, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  if (a5)
  {
    if (!a4)
      goto LABEL_21;
    if (a4 <= 0xB || (v8 = *(_DWORD *)(a3 + 8), 40 * (unint64_t)v8 + 12 > a4))
    {
      v10 = FigSignalErrorAt(4294951766, 0, 0, 0, 0, 0, 0);
      goto LABEL_9;
    }
    if (v8 == 1)
    {
      v10 = CreateSubBlockBuffer(structureAllocator, a2, 0, (int64_t *)(a3 + 12), &blockBufferOut);
LABEL_9:
      v11 = v10;
LABEL_22:
      *a5 = blockBufferOut;
      return v11;
    }
    v10 = CMBlockBufferCreateEmpty(structureAllocator, v8, 0, &blockBufferOut);
    if ((_DWORD)v10)
      goto LABEL_9;
    if (!*(_DWORD *)(a3 + 8))
    {
LABEL_21:
      v11 = 0;
      goto LABEL_22;
    }
    v12 = 0;
    v13 = (int64_t *)(a3 + 12);
    while (1)
    {
      appended = CreateSubBlockBuffer(structureAllocator, a2, 0, v13, &targetBBuf);
      v15 = targetBBuf;
      if ((_DWORD)appended)
        break;
      appended = CMBlockBufferAppendBufferReference(blockBufferOut, targetBBuf, 0, 0, 0);
      if ((_DWORD)appended)
        break;
      if (v15)
      {
        CFRelease(v15);
        targetBBuf = 0;
      }
      ++v12;
      v13 += 5;
      if (v12 >= *(unsigned int *)(a3 + 8))
      {
        v11 = 0;
        goto LABEL_19;
      }
    }
    v11 = appended;
    if (v15)
      CFRelease(v15);
LABEL_19:
    if (!a5)
      return v11;
    goto LABEL_22;
  }
  return FigSignalErrorAt(4294951766, 0, 0, 0, 0, 0, 0);
}

uint64_t CreateSubBlockBuffer(const __CFAllocator *a1, uint64_t a2, xpc_object_t xdict, int64_t *a4, OpaqueCMBlockBuffer **a5)
{
  xpc_object_t value;
  int64_t int64;
  const void *v10;
  void *uint64;
  uint64_t v12;
  CFIndex Count;
  CFIndex v14;
  CFIndex v15;
  _QWORD *ValueAtIndex;
  CFTypeRef v17;
  CFTypeRef *v18;
  CFTypeRef v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  CFTypeRef v23;
  xpc_object_t v24;
  int v25;
  size_t v26;
  uint64_t v27;
  xpc_object_t v28;
  uint64_t v29;
  size_t v30;
  size_t v31;
  uint64_t v32;
  xpc_object_t v33;
  void *v34;
  xpc_object_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  CFTypeRef v39;
  int v40;
  id *v41;
  OpaqueCMBlockBuffer *v42;
  uint64_t v43;
  uint64_t v44;
  xpc_object_t v45;
  const __CFAllocator *v46;
  CFNumberRef v47;
  CFNumberRef v48;
  CFNumberRef v49;
  const void *v50;
  uint64_t v51;
  BOOL v52;
  BOOL v53;
  uint64_t v54;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v56;
  uint64_t v57;
  unsigned int v58;
  xpc_object_t *v59;
  int64_t dataLength;
  int64_t v63;
  os_log_type_t type;
  int v65;
  CFTypeRef cf;
  const void *valuePtr;
  CMBlockBufferRef bufferReference;
  int64_t v69;
  _BYTE v70[12];
  __int16 v71;
  int v72;
  xpc_object_t xdicta[18];

  xdicta[16] = *(xpc_object_t *)MEMORY[0x1E0C80C00];
  if (xdict)
  {
    value = xpc_dictionary_get_value(xdict, "OriginData");
    int64 = xpc_dictionary_get_int64(xdict, "BlockSerialNumber");
    v63 = xpc_dictionary_get_int64(xdict, "OffsetInOrigin");
    dataLength = xpc_dictionary_get_int64(xdict, "BlockBufferLength");
    v10 = (const void *)xpc_dictionary_get_int64(xdict, "RoundTripBlockSerialNumber");
    uint64 = (void *)xpc_dictionary_get_uint64(xdict, "RoundTripOriginObjectID");
  }
  else
  {
    value = 0;
    int64 = a4[2];
    dataLength = a4[1];
    v63 = *a4;
    uint64 = (void *)a4[3];
    v10 = (const void *)a4[4];
  }
  bufferReference = 0;
  v69 = int64;
  v12 = *(_QWORD *)(a2 + 32);
  cf = 0;
  valuePtr = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)v12);
  Count = CFArrayGetCount(*(CFArrayRef *)(v12 + 8));
  if (Count < 1)
  {
LABEL_8:
    if (v10)
    {
      if (uint64)
      {
        FigMemoryOriginServerCopyMemoryOriginForObjectID(uint64, &cf);
        v17 = cf;
        if (cf)
        {
          FigReentrantMutexLock(*((pthread_mutex_t **)cf + 2));
          v18 = (CFTypeRef *)CFDictionaryGetValue(*((CFDictionaryRef *)v17 + 3), v10);
          if (v18)
          {
            v19 = CFRetain(*v18);
            FigReentrantMutexUnlock(*((pthread_mutex_t **)v17 + 2));
            if (v19)
            {
              xdicta[0] = 0;
              *(_QWORD *)v70 = 0;
              poolBlockState_IncrementBlockUseCountAndAccessMemory((uint64_t)v19, v10, xdicta, v70);
              receivedMemoryAllocator_tellOriginToDecrementUseCountOfBlock(v12, int64);
              v20 = CFAllocatorAllocate(a1, 64, 0);
              if (v20)
              {
                v21 = v20;
                *(_OWORD *)v20 = 0u;
                *((_OWORD *)v20 + 1) = 0u;
                *((_OWORD *)v20 + 2) = 0u;
                *((_OWORD *)v20 + 3) = 0u;
                *v20 = 0;
                v20[1] = v10;
                v22 = *(_QWORD *)v70;
                v20[2] = xdicta[0];
                v20[3] = v22;
                v20[6] = CFRetain(v19);
                *((_WORD *)v21 + 20) = 256;
                if (a1)
                  v23 = CFRetain(a1);
                else
                  v23 = 0;
                v26 = v63;
                v21[7] = v23;
                v21[4] = 0;
                CFArrayAppendValue(*(CFMutableArrayRef *)(v12 + 8), v21);
                v24 = 0;
                v25 = 0;
                valuePtr = (const void *)v21[1];
                goto LABEL_32;
              }
              v27 = FigSignalErrorAt(4294951765, 0, 0, 0, 0, 0, 0);
              v24 = 0;
              goto LABEL_65;
            }
          }
          else
          {
            FigReentrantMutexUnlock(*((pthread_mutex_t **)v17 + 2));
          }
        }
      }
    }
    if (value)
    {
      v24 = 0;
    }
    else
    {
      xdicta[0] = 0;
      *(_QWORD *)v70 = 0;
      FigXPCCreateBasicMessage(0x66746368u, *(_QWORD *)(*(_QWORD *)(a2 + 32) + 24), xdicta);
      xpc_dictionary_set_int64(xdicta[0], "BlockSerialNumber", int64);
      v27 = FigXPCRemoteClientSendSyncMessageCreatingReply(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16), (uint64_t)xdicta[0], (xpc_object_t *)v70);
      if ((_DWORD)v27)
      {
        v24 = 0;
      }
      else
      {
        v28 = xpc_dictionary_get_value(*(xpc_object_t *)v70, "OriginData");
        v24 = FigXPCRetain(v28);
      }
      FigXPCRelease(*(xpc_object_t *)v70);
      FigXPCRelease(xdicta[0]);
      if ((_DWORD)v27)
        goto LABEL_63;
      value = v24;
    }
    v29 = *(_QWORD *)(v12 + 32);
    xdicta[0] = 0;
    v30 = xpc_shmem_map(value, xdicta);
    if (v30 && xdicta[0])
    {
      v31 = v30;
      v32 = a2;
      v33 = v24;
      v34 = malloc_type_calloc(1uLL, 0x28uLL, 0x10800407C5467E8uLL);
      v35 = xdicta[0];
      *((_QWORD *)v34 + 1) = v31;
      *((_QWORD *)v34 + 2) = v35;
      *((_QWORD *)v34 + 3) = 0;
      *((_DWORD *)v34 + 8) = 1;
      *(_QWORD *)v34 = poolBlockState_newMemoryBlockSerialNumber();
      *((_BYTE *)v34 + 36) = 1;
      FigSimpleMutexLock(*(pthread_mutex_t **)(v29 + 56));
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v29 + 80), *(const void **)v34, v34);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v29 + 64), *((const void **)v34 + 2), v34);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(v29 + 56));
      v36 = *((_QWORD *)v34 + 1);
      valuePtr = *(const void **)v34;
      v37 = *((_QWORD *)v34 + 2);
LABEL_27:
      v38 = CFAllocatorAllocate(a1, 64, 0);
      if (v38)
      {
        v21 = v38;
        *(_OWORD *)v38 = 0u;
        *((_OWORD *)v38 + 1) = 0u;
        *((_OWORD *)v38 + 2) = 0u;
        *((_OWORD *)v38 + 3) = 0u;
        v38[2] = v37;
        v38[3] = v36;
        *v38 = v69;
        v38[1] = valuePtr;
        v38[6] = CFRetain(*(CFTypeRef *)(v12 + 32));
        *((_BYTE *)v21 + 40) = 0;
        v24 = v33;
        if (a1)
          v39 = CFRetain(a1);
        else
          v39 = 0;
        a2 = v32;
        v26 = v63;
        v21[7] = v39;
        v21[4] = 0;
        *((_BYTE *)v21 + 41) = 0;
        CFArrayAppendValue(*(CFMutableArrayRef *)(v12 + 8), v21);
        v19 = 0;
        v25 = 1;
        goto LABEL_32;
      }
      v27 = FigSignalErrorAt(4294951765, 0, 0, 0, 0, 0, 0);
      v19 = 0;
      v24 = v33;
      a2 = v32;
LABEL_65:
      v42 = 0;
      v25 = 0;
      v52 = (_DWORD)v27 == 0;
      goto LABEL_66;
    }
    v54 = FigSignalErrorAt(4294951764, 0, 0, 0, 0, 0, 0);
    if (!(_DWORD)v54)
    {
      v32 = a2;
      v33 = v24;
      v37 = 0;
      v36 = 0;
      goto LABEL_27;
    }
    v27 = v54;
LABEL_63:
    v19 = 0;
    goto LABEL_65;
  }
  v14 = Count;
  v15 = 0;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v12 + 8), v15);
    if (*ValueAtIndex == int64)
      break;
    if (v14 == ++v15)
      goto LABEL_8;
  }
  v21 = ValueAtIndex;
  v19 = 0;
  v24 = 0;
  v25 = 0;
  valuePtr = (const void *)ValueAtIndex[1];
  v26 = v63;
LABEL_32:
  v40 = *((unsigned __int8 *)v21 + 40);
  if (!*((_BYTE *)v21 + 40))
    *((_BYTE *)v21 + 40) = 1;
  v41 = (id *)v21[4];
  if (v41)
  {
    bufferReference = (CMBlockBufferRef)FigCFWeakReferenceHolderCopyReferencedObject(v41);
    if (bufferReference)
      goto LABEL_36;
LABEL_39:
    v43 = CMBlockBufferCreateWithMemoryBlock(a1, (void *)v21[2], v21[3], *(CFAllocatorRef *)(a2 + 24), 0, 0, v21[3], 0, &bufferReference);
    if ((_DWORD)v43)
      goto LABEL_60;
    v44 = a2;
    v45 = v24;
    v46 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v47 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
    CMSetAttachment(bufferReference, CFSTR("MemoryPoolBlockSerialNumber"), v47, 0);
    if (v47)
      CFRelease(v47);
    CMSetAttachment(bufferReference, CFSTR("OwningPoolBlockState"), (CFTypeRef)v21[6], 0);
    if (*v21)
    {
      v48 = CFNumberCreate(v46, kCFNumberSInt64Type, &v69);
      CMSetAttachment(bufferReference, CFSTR("ImportedBlockSerialNumber"), v48, 0);
      CFRelease(v48);
      v49 = CFNumberCreate(v46, kCFNumberSInt64Type, (const void *)(v44 + 16));
      CMSetAttachment(bufferReference, CFSTR("RecipientObjectID"), v49, 0);
      CFRelease(v49);
    }
    v50 = (const void *)v21[4];
    if (v50)
      CFRelease(v50);
    v21[4] = FigCFWeakReferenceHolderCreateWithReferencedObject((uint64_t)bufferReference);
    v24 = v45;
    a2 = v44;
    v26 = v63;
    if (v63)
      goto LABEL_37;
LABEL_47:
    v51 = v21[3];
    v42 = bufferReference;
    if (v51 == dataLength)
    {
LABEL_50:
      v27 = 0;
      bufferReference = 0;
      goto LABEL_51;
    }
    goto LABEL_48;
  }
  if (!bufferReference)
    goto LABEL_39;
LABEL_36:
  if (!v26)
    goto LABEL_47;
LABEL_37:
  v42 = bufferReference;
LABEL_48:
  xdicta[0] = 0;
  v43 = CMBlockBufferCreateWithBufferReference(a1, v42, v26, dataLength, 0, (CMBlockBufferRef *)xdicta);
  if (!(_DWORD)v43)
  {
    CFRelease(bufferReference);
    v42 = (OpaqueCMBlockBuffer *)xdicta[0];
    goto LABEL_50;
  }
LABEL_60:
  v27 = v43;
  v42 = 0;
LABEL_51:
  v52 = (_DWORD)v27 == 0;
  if (bufferReference)
    v53 = 1;
  else
    v53 = (_DWORD)v27 == 0;
  if (!v40 && v53)
  {
    FigSimpleMutexUnlock(*(pthread_mutex_t **)v12);
    if (!(_DWORD)v27)
      goto LABEL_75;
    goto LABEL_67;
  }
LABEL_66:
  receivedMemoryAllocator_tellOriginToDecrementUseCountOfBlock(*(_QWORD *)(a2 + 32), v69);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)v12);
  if (v52)
    goto LABEL_75;
LABEL_67:
  v65 = 0;
  type = OS_LOG_TYPE_DEFAULT;
  os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, &v65, &type);
  v56 = v65;
  if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
    v58 = v56;
  else
    v58 = v56 & 0xFFFFFFFE;
  if (v58)
  {
    *(_DWORD *)v70 = 136315394;
    *(_QWORD *)&v70[4] = "memoryRecipient_createRecipientBlockBuffer";
    v71 = 1024;
    v72 = v27;
    v59 = (xpc_object_t *)_os_log_send_and_compose_impl();
    LOBYTE(v56) = v65;
  }
  else
  {
    v59 = 0;
  }
  fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v59, v59 != xdicta, v56, 0, v57);
  if (v25)
    poolBlockState_DecrementBlockUseCount(*(_QWORD *)(v12 + 32), valuePtr);
LABEL_75:
  if (cf)
    CFRelease(cf);
  if (v19)
    CFRelease(v19);
  if (bufferReference)
    CFRelease(bufferReference);
  FigXPCRelease(v24);
  if ((_DWORD)v27)
  {
    if (v42)
      CFRelease(v42);
  }
  else
  {
    *a5 = v42;
  }
  return v27;
}

uint64_t FigMemoryRecipientCopyBlockBufferFromXPCMessage(const __CFAllocator *a1, uint64_t a2, xpc_object_t xdict, char *key, CMBlockBufferRef *a5)
{
  xpc_object_t value;
  void *v9;
  xpc_object_t v10;
  void *v11;
  size_t count;
  uint64_t v13;
  size_t v14;
  xpc_object_t v15;
  uint64_t appended;
  CMBlockBufferRef v17;
  uint64_t v18;
  CMBlockBufferRef targetBBuf;
  CMBlockBufferRef blockBufferOut;

  targetBBuf = 0;
  blockBufferOut = 0;
  if (!a2 || !xdict || !key)
  {
    v18 = FigSignalErrorAt(4294951766, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  if (a5)
  {
    value = xpc_dictionary_get_value(xdict, key);
    if (value)
    {
      v9 = value;
      v10 = xpc_dictionary_get_value(value, "SubBlockArray");
      if (v10)
      {
        v11 = v10;
        count = xpc_array_get_count(v10);
        v13 = CMBlockBufferCreateEmpty(a1, count, 0, &blockBufferOut);
        if (!(_DWORD)v13)
        {
          if (count)
          {
            v14 = 0;
            while (1)
            {
              v15 = xpc_array_get_value(v11, v14);
              appended = CreateSubBlockBuffer(a1, a2, v15, 0, &targetBBuf);
              v17 = targetBBuf;
              if ((_DWORD)appended)
                break;
              appended = CMBlockBufferAppendBufferReference(blockBufferOut, targetBBuf, 0, 0, 0);
              if ((_DWORD)appended)
                break;
              if (v17)
              {
                CFRelease(v17);
                targetBBuf = 0;
              }
              if (count == ++v14)
              {
                v18 = 0;
                goto LABEL_16;
              }
            }
            v18 = appended;
            if (v17)
              CFRelease(v17);
LABEL_16:
            if (!a5)
              return v18;
            goto LABEL_21;
          }
          goto LABEL_20;
        }
      }
      else
      {
        v13 = CreateSubBlockBuffer(a1, a2, v9, 0, &blockBufferOut);
      }
      v18 = v13;
LABEL_21:
      *a5 = blockBufferOut;
      return v18;
    }
LABEL_20:
    v18 = 0;
    goto LABEL_21;
  }
  return FigSignalErrorAt(4294951766, 0, 0, 0, 0, 0, 0);
}

uint64_t FigMemoryRecipientAppendRecipientStateUpdateToXPCMessage(uint64_t a1, void *a2, const char *a3)
{
  uint64_t v6;

  if (!a1 || !a2)
    return FigSignalErrorAt(4294951766, 0, 0, 0, 0, 0, 0);
  FigSimpleMutexLock(**(pthread_mutex_t ***)(a1 + 32));
  if (CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)(a1 + 32) + 56)) < 1)
  {
    v6 = 0;
  }
  else
  {
    dispatch_source_set_timer(*(dispatch_source_t *)(*(_QWORD *)(a1 + 32) + 48), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    v6 = FigXPCMessageSetCFArray(a2, a3, *(CFTypeRef *)(*(_QWORD *)(a1 + 32) + 56));
    if (!(_DWORD)v6)
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(*(_QWORD *)(a1 + 32) + 56));
  }
  FigSimpleMutexUnlock(**(pthread_mutex_t ***)(a1 + 32));
  return v6;
}

uint64_t FigMemoryRecipientAppendRecipientStateUpdateToIPCMessageData(uint64_t a1, _DWORD *a2, unint64_t a3, unint64_t *a4)
{
  unint64_t v7;
  uint64_t result;
  CFIndex Count;
  CFIndex v11;
  CFIndex v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  BOOL v18;
  uint64_t v19;

  if (!a1)
  {
    result = FigSignalErrorAt(4294951766, 0, 0, 0, 0, 0, 0);
    v7 = 0;
    if (!a4)
      return result;
    goto LABEL_15;
  }
  v7 = 0;
  result = 0;
  if (a2 && a3 >= 0xC)
  {
    v19 = 0;
    FigSimpleMutexLock(**(pthread_mutex_t ***)(a1 + 32));
    Count = CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)(a1 + 32) + 56));
    v11 = Count - 1;
    if (Count < 1)
    {
      v7 = 0;
    }
    else
    {
      v12 = Count;
      v13 = 0;
      v14 = a3 - 8;
      v15 = 12;
      do
      {
        v16 = v13;
        FigCFArrayGetInt64AtIndex(*(const void **)(*(_QWORD *)(a1 + 32) + 56), 0, &v19);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(*(_QWORD *)(a1 + 32) + 56), 0);
        *(_QWORD *)&a2[2 * v13++ + 1] = v19;
        v17 = v15 + 8;
        if (v11 == v16)
          break;
        v18 = v15 > v14;
        v15 += 8;
      }
      while (!v18);
      v7 = v17 - 8;
      if (v12 == v13)
        dispatch_source_set_timer(*(dispatch_source_t *)(*(_QWORD *)(a1 + 32) + 48), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
      *a2 = v13;
    }
    FigSimpleMutexUnlock(**(pthread_mutex_t ***)(a1 + 32));
    result = 0;
  }
  if (a4)
LABEL_15:
    *a4 = v7;
  return result;
}

uint64_t FigMemoryRecipientCreateWithXPCMessage1AndUpdateXPCMessage2(xpc_object_t xdict, void *a2, const char *a3, uint64_t **a4)
{
  xpc_object_t value;
  uint64_t v9;
  uint64_t uint64;
  void *v11;
  id v12;
  const void *v13;
  uint64_t *Instance;
  const void *version;
  const void *v16;
  id v17;
  const __CFAllocator *v18;
  __CFDictionary *Mutable;
  int v20;
  uint64_t v21;
  uint64_t v22;
  pid_t v23;
  const void *v24;
  _QWORD *v25;
  pthread_mutex_t *v26;
  CFMutableArrayRef v27;
  uint64_t v28;
  CFAllocatorRef v29;
  uint64_t v30;
  uint64_t ServerPID;
  char *CStringPtrAndBufferToFree;
  NSObject *v33;
  dispatch_source_t v34;
  CFMutableArrayRef v35;
  void *v36;
  void *v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t **v42;
  void *v43;
  xpc_object_t v44;
  xpc_object_t xdicta;
  _QWORD handler[5];
  unsigned int v47;
  CFTypeRef cf;
  char *label;
  void *v50;
  CFAllocatorContext context;
  char buffer[40];
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (FigMemoryRecipientCreateWithXPCMessage1AndUpdateXPCMessage2_sRecipientRemoteClients != -1)
    dispatch_once(&FigMemoryRecipientCreateWithXPCMessage1AndUpdateXPCMessage2_sRecipientRemoteClients, &__block_literal_global_30);
  value = xpc_dictionary_get_value(xdict, "MemoryOriginEndpoint");
  if (!value)
    return FigSignalErrorAt(4294951764, 0, 0, 0, 0, 0, 0);
  v9 = (uint64_t)value;
  if (MEMORY[0x193FFCDCC]() != MEMORY[0x1E0C81308])
    return FigSignalErrorAt(4294951764, 0, 0, 0, 0, 0, 0);
  uint64 = xpc_dictionary_get_uint64(xdict, "MemoryOriginServerToken");
  if (!uint64)
    return FigSignalErrorAt(4294951764, 0, 0, 0, 0, 0, 0);
  v11 = (void *)uint64;
  FigSimpleMutexLock((pthread_mutex_t *)qword_1EE141618);
  v12 = FigCFWeakReferenceTableCopyValue(qword_1EE141620, v11);
  v13 = v12;
  if (v12)
  {
    Instance = (uint64_t *)CFRetain(v12);
    version = 0;
    v16 = 0;
    goto LABEL_37;
  }
  v42 = a4;
  v43 = a2;
  v17 = FigCFWeakReferenceTableCopyValue(qword_1EE141628, v11);
  v16 = v17;
  if (v17)
  {
    version = CFRetain(v17);
    v18 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    goto LABEL_15;
  }
  context.version = 0;
  v18 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, CFSTR("xpcRemoteClientOption_DeathNoticeName"), CFSTR("MemoryRecipient_ServerDied"));
  CFDictionarySetValue(Mutable, CFSTR("xpcRemoteClientOption_DoNotMonitorConnection"), (const void *)*MEMORY[0x1E0C9AE50]);
  v20 = FigXPCRemoteClientCreateWithXPCEndpoint((uint64_t)"FigMemoryRecipient", v9, (uint64_t)&MemoryRecipientCreateRemoteClientWithXPCEndpoint_sMemoryRecipientRemoteClientCallbacks, (uint64_t)Mutable, (uint64_t)&context);
  if (Mutable)
    CFRelease(Mutable);
  if (v20)
  {
    v39 = FigSignalErrorAt(4294951764, 0, 0, 0, 0, 0, 0);
    version = 0;
    Instance = 0;
    if ((_DWORD)v39)
      goto LABEL_58;
  }
  else
  {
    version = (const void *)context.version;
  }
  v21 = FigCFWeakReferenceTableAddValueAssociatedWithKey(qword_1EE141628, (uint64_t)version, (uint64_t)v11);
  if ((_DWORD)v21)
  {
    v39 = v21;
    Instance = 0;
LABEL_58:
    FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EE141618);
    if (!version)
      goto LABEL_41;
    goto LABEL_40;
  }
LABEL_15:
  v44 = 0;
  xdicta = 0;
  if (memoryRecipient_GetTypeID_sRegisterMemoryRecipientTypeOnce != -1)
    dispatch_once(&memoryRecipient_GetTypeID_sRegisterMemoryRecipientTypeOnce, &__block_literal_global_73);
  Instance = (uint64_t *)_CFRuntimeCreateInstance();
  if (!Instance)
  {
    v39 = FigSignalErrorAt(4294951765, 0, 0, 0, 0, 0, 0);
    a4 = v42;
    goto LABEL_35;
  }
  v22 = FigXPCCreateBasicMessage(0x63726538u, 0, &xdicta);
  if ((_DWORD)v22
    || (xpc_dictionary_set_string(xdicta, ".DebugName", a3),
        memset(buffer, 0, 32),
        v23 = getpid(),
        proc_name(v23, buffer, 0x20u),
        xpc_dictionary_set_string(xdicta, ".ProcessName", buffer),
        v22 = FigXPCRemoteClientSendSyncMessageCreatingReply((uint64_t)version, (uint64_t)xdicta, &v44),
        (_DWORD)v22))
  {
    v39 = v22;
    a4 = v42;
    goto LABEL_54;
  }
  v24 = (const void *)xpc_dictionary_get_uint64(v44, ".objectID");
  Instance[2] = (uint64_t)v24;
  memset(&context, 0, sizeof(context));
  v25 = malloc_type_calloc(1uLL, 0x40uLL, 0x1020040D4733842uLL);
  if (v25)
  {
    v26 = FigSimpleMutexCreate();
    *v25 = v26;
    if (v26)
    {
      v27 = CFArrayCreateMutable(v18, 0, 0);
      v25[1] = v27;
      if (v27)
      {
        v28 = poolBlockState_Create(v18, 0, 0, 0, 0, CFSTR("ReceivedMemoryAllocatorPBS"), v25 + 4);
        if ((_DWORD)v28)
        {
          v39 = v28;
          receivedMemoryAllocator_ReleaseInfo((uint64_t)v25);
          a4 = v42;
          a2 = v43;
          goto LABEL_54;
        }
        v25[2] = CFRetain(version);
        v25[3] = v24;
        context.info = v25;
        context.release = (CFAllocatorReleaseCallBack)receivedMemoryAllocator_ReleaseInfo;
        context.deallocate = (CFAllocatorDeallocateCallBack)receivedMemoryAllocator_Deallocate;
        v29 = CFAllocatorCreate(0, &context);
        if (v29)
        {
          v30 = (uint64_t)v29;
          label = 0;
          v50 = 0;
          cf = 0;
          v47 = 0;
          ServerPID = FigXPCRemoteClientGetServerPID((uint64_t)version, &v47);
          if ((_DWORD)ServerPID)
            goto LABEL_47;
          FigServer_CopyProcessName(v47, (CFStringRef *)&cf);
          CStringPtrAndBufferToFree = FigCFStringGetCStringPtrAndBufferToFree((CFStringRef)cf, 0x8000100u, (char **)&v50);
          if (CStringPtrAndBufferToFree)
          {
            asprintf(&label, "com.apple.coremedia.memoryrecipient.use-count-batching.%s-%d", CStringPtrAndBufferToFree, v47);
            free(v50);
            if (cf)
              CFRelease(cf);
            v25[5] = dispatch_queue_create(label, 0);
            free(label);
            v33 = v25[5];
            if (v33)
            {
              v34 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v33);
              v25[6] = v34;
              if (v34)
              {
                v35 = CFArrayCreateMutable(v18, 0, MEMORY[0x1E0C9B378]);
                v25[7] = v35;
                if (v35)
                {
                  v36 = (void *)FigCFWeakReferenceHolderCreateWithReferencedObject(v30);
                  if (v36)
                  {
                    v37 = v36;
                    dispatch_set_context((dispatch_object_t)v25[6], v36);
                    dispatch_set_finalizer_f((dispatch_object_t)v25[6], (dispatch_function_t)receivedMemoryAllocator_finalizeUseCountUpdateTimer);
                    v38 = v25[6];
                    handler[0] = MEMORY[0x1E0C809B0];
                    handler[1] = 0x40000000;
                    handler[2] = __CreateReceivedMemoryAllocator_block_invoke;
                    handler[3] = &__block_descriptor_tmp_79;
                    handler[4] = v37;
                    dispatch_source_set_event_handler(v38, handler);
                    dispatch_source_set_timer((dispatch_source_t)v25[6], 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
                    dispatch_resume((dispatch_object_t)v25[6]);
                    Instance[3] = v30;
                    Instance[4] = (uint64_t)v25;
                    a4 = v42;
                    a2 = v43;
                    goto LABEL_34;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  ServerPID = FigSignalErrorAt(4294951765, 0, 0, 0, 0, 0, 0);
LABEL_47:
  v39 = ServerPID;
  a4 = v42;
  receivedMemoryAllocator_ReleaseInfo((uint64_t)v25);
  a2 = v43;
  if (!(_DWORD)v39)
  {
LABEL_34:
    v39 = FigXPCRemoteClientAssociateObject((uint64_t)version, (uint64_t)Instance, v24);
    if (!(_DWORD)v39)
      goto LABEL_35;
  }
LABEL_54:
  CFRelease(Instance);
  Instance = 0;
LABEL_35:
  FigXPCRelease(xdicta);
  FigXPCRelease(v44);
  if ((_DWORD)v39)
    goto LABEL_58;
  v40 = FigCFWeakReferenceTableAddValueAssociatedWithKey(qword_1EE141620, (uint64_t)Instance, (uint64_t)v11);
  if ((_DWORD)v40)
  {
    v39 = v40;
    goto LABEL_58;
  }
LABEL_37:
  xpc_dictionary_set_uint64(a2, "OriginObjectID", Instance[2]);
  *a4 = Instance;
  FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EE141618);
  if (v13)
    CFRelease(v13);
  Instance = 0;
  v39 = 0;
  if (!version)
    goto LABEL_41;
LABEL_40:
  CFRelease(version);
LABEL_41:
  if (v16)
    CFRelease(v16);
  if (Instance)
    CFRelease(Instance);
  return v39;
}

uint64_t FigMemoryOriginBeginTransactionMakingRegistrationsContingentOnIt()
{
  uint64_t result;
  _BYTE *Value;
  _BYTE *v2;

  if (FigMemoryOriginBeginTransactionMakingRegistrationsContingentOnIt_onceToken != -1)
    dispatch_once(&FigMemoryOriginBeginTransactionMakingRegistrationsContingentOnIt_onceToken, &__block_literal_global_22_0);
  result = sFigMemoryOriginTransactionThreadKey;
  if (sFigMemoryOriginTransactionThreadKey)
  {
    Value = FigThreadGetValue(sFigMemoryOriginTransactionThreadKey);
    if (Value)
    {
LABEL_5:
      result = 0;
      *Value = 1;
      return result;
    }
    v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x1020040984C81BBuLL);
    if (v2)
    {
      Value = v2;
      result = FigThreadSetValue(sFigMemoryOriginTransactionThreadKey, v2);
      if (!(_DWORD)result)
        goto LABEL_5;
    }
    else
    {
      return FigSignalErrorAt(4294951775, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

void transactionThreadDestructor(_QWORD *a1)
{
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v3;
  uint64_t v4;
  unsigned int v5;
  char *v6;
  const void *v7;
  const void *v8;
  os_log_type_t type;
  int v10[2];
  const char *v11;
  __int16 v12;
  _QWORD *v13;
  char v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_BYTE *)a1)
    {
      v10[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 0, v10, &type);
      v3 = v10[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v5 = v3;
      else
        v5 = v3 & 0xFFFFFFFE;
      if (v5)
      {
        v10[1] = 136315394;
        v11 = "transactionThreadDestructor";
        v12 = 2048;
        v13 = a1;
        v6 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v3) = v10[0];
      }
      else
      {
        v6 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose(0, 0, 1, v6, v6 != &v14, v3, 0, v4);
    }
    v7 = (const void *)a1[1];
    if (v7)
      CFRelease(v7);
    v8 = (const void *)a1[2];
    if (v8)
      CFRelease(v8);
    free(a1);
  }
}

uint64_t FigMemoryOriginCompleteTransaction(int a1)
{
  const __CFArray **Value;
  const __CFArray **v3;
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  const __CFArray *v7;
  CFIndex v8;
  uint64_t v9;
  CFIndex i;
  const void *ValueAtIndex;
  const __CFNumber *v12;
  const __CFNumber *SInt64;

  Value = (const __CFArray **)FigThreadGetValue(sFigMemoryOriginTransactionThreadKey);
  if (Value)
  {
    v3 = Value;
    if (*(_BYTE *)Value)
    {
      v4 = Value[1];
      if (v4)
      {
        Count = CFArrayGetCount(v4);
        if (Count >= 1)
        {
          v6 = Count;
          v7 = v3[2];
          if (v7)
          {
            v8 = CFArrayGetCount(v7);
            v9 = 0;
            if (a1 != 1 || v6 != v8)
              goto LABEL_11;
            for (i = 0; i != v6; ++i)
            {
              ValueAtIndex = CFArrayGetValueAtIndex(v3[1], i);
              v12 = (const __CFNumber *)CFArrayGetValueAtIndex(v3[2], i);
              SInt64 = FigCFNumberGetSInt64(v12);
              memoryOrigin_unregisterUseOfBlock((uint64_t)ValueAtIndex, SInt64);
            }
          }
        }
      }
      v9 = 0;
    }
    else
    {
      v9 = FigSignalErrorAt(4294951773, 0, 0, 0, 0, 0, 0);
    }
LABEL_11:
    FigCFArrayRemoveAllValues(v3[1]);
    FigCFArrayRemoveAllValues(v3[2]);
    *(_BYTE *)v3 = 0;
    return v9;
  }
  return FigSignalErrorAt(4294951773, 0, 0, 0, 0, 0, 0);
}

uint64_t poolBlockState_DeallocateVMMemory(uint64_t result)
{
  if (!*(_BYTE *)(result + 36))
    JUMPOUT(0x193FFCA84);
  if (*(_QWORD *)(result + 16))
    return munmap(*(void **)(result + 16), *(_QWORD *)(result + 8));
  return result;
}

void poolBlockState_postForgottenSerialNumber(const void *a1, uint64_t *a2)
{
  CFMutableDictionaryRef Mutable;
  __CFNotificationCenter *DefaultLocalCenter;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetInt64(Mutable, CFSTR("pool_BlockSerialNumber"), *a2);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("pool_ForgetBlock"), a1, Mutable);
  CFRelease(Mutable);
}

uint64_t figMemoryPoolInit(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  return result;
}

void figMemoryPoolFinalize(OpaqueCMMemoryPool *a1)
{
  const void *v2;
  const void *v3;

  CMMemoryPoolInvalidate(a1);
  v2 = (const void *)*((_QWORD *)a1 + 3);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)a1 + 3) = 0;
  }
  v3 = (const void *)*((_QWORD *)a1 + 2);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)a1 + 2) = 0;
  }
}

CFStringRef figMemoryPoolCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigMemoryPool %p]"), a1);
}

__CFString *figMemoryPoolCopyDebugDesc(_QWORD *a1)
{
  const void *v2;
  const __CFAllocator *v3;
  __CFString *Mutable;
  CFStringRef v5;
  CFIndex v6;

  v2 = (const void *)a1[2];
  v3 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v3, 0);
  v5 = CFCopyDescription(v2);
  v6 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("FigMemoryPool %p RC: %d poolingAllocator: %p %@"), a1, v6, a1[3], v5);
  if (v5)
    CFRelease(v5);
  return Mutable;
}

void poolBlockState_DecrementUseCountInternal(uint64_t a1, const void **a2)
{
  int v2;
  const void *v5;

  v2 = *((_DWORD *)a2 + 8) - 1;
  *((_DWORD *)a2 + 8) = v2;
  if (!v2)
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 64), a2[2]);
    if (*(_BYTE *)(a1 + 16))
    {
      a2[3] = (const void *)(*(_QWORD *)(a1 + 32) + FigGetUpTimeNanoseconds());
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 72), a2);
      v5 = a2[3];
      if (*(_QWORD *)(a1 + 48) > (uint64_t)v5)
        *(_QWORD *)(a1 + 48) = v5;
    }
    else
    {
      poolBlockState_DeallocateVMMemory((uint64_t)a2);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 80), *a2);
      poolBlockState_postForgottenSerialNumber((const void *)a1, (uint64_t *)a2);
      free(a2);
    }
  }
}

__CFString *poolBlockState_copyBlockInfoDescription(uint64_t a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("info %p ptr %p size %zd, expiryNanos %lld BlockSN %016llx useCount %d"), a1, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 24), *(_QWORD *)a1, *(unsigned int *)(a1 + 32));
  return Mutable;
}

uint64_t poolBlockState_RegisterType(uint64_t *a1)
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  *a1 = result;
  return result;
}

double poolBlockState_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 96) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

const __CFAllocator *poolBlockState_Finalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const __CFAllocator *result;

  v2 = (const void *)a1[8];
  if (v2)
  {
    CFRelease(v2);
    a1[8] = 0;
  }
  v3 = (const void *)a1[9];
  if (v3)
  {
    CFRelease(v3);
    a1[9] = 0;
  }
  v4 = (const void *)a1[10];
  if (v4)
  {
    CFRelease(v4);
    a1[10] = 0;
  }
  v5 = (const void *)a1[5];
  if (v5)
  {
    CFRelease(v5);
    a1[5] = 0;
  }
  v6 = (const void *)a1[12];
  if (v6)
  {
    CFRelease(v6);
    a1[12] = 0;
  }
  result = (const __CFAllocator *)a1[7];
  if (result)
  {
    result = FigSimpleMutexDestroy((uint64_t)result);
    a1[7] = 0;
  }
  return result;
}

__CFString *poolBlockState_CopyFormattingDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  CFIndex v4;
  const __CFString *v5;
  CFDictionaryRef Count;
  const __CFArray *v7;
  const __CFString *v8;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 56));
  v4 = CFGetRetainCount((CFTypeRef)a1);
  v5 = *(const __CFString **)(a1 + 40);
  Count = FigCFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 64));
  v7 = *(const __CFArray **)(a1 + 72);
  if (v7)
    v7 = (const __CFArray *)CFArrayGetCount(v7);
  v8 = &stru_1E28E82E0;
  if (v5)
    v8 = v5;
  CFStringAppendFormat(Mutable, 0, CFSTR("<PoolBlockState %p RC: %d \"%@\" blocksInUse: %ld blocksForReuse: %ld>"), a1, v4, v8, Count, v7);
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 56));
  return Mutable;
}

__CFString *poolBlockState_CopyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  CFIndex v4;
  const __CFString *v5;
  const char *v6;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 56));
  v4 = CFGetRetainCount((CFTypeRef)a1);
  v5 = &stru_1E28E82E0;
  if (*(_QWORD *)(a1 + 40))
    v5 = *(const __CFString **)(a1 + 40);
  if (*(_BYTE *)(a1 + 16))
    v6 = "recyclingEnabled";
  else
    v6 = "recyclingDisabled";
  CFStringAppendFormat(Mutable, 0, CFSTR("PoolBlockState %p RC: %d %@ %s blocksInUse: %p %@ blocksForReuse: %p %@"), a1, v4, v5, v6, *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 72));
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 56));
  return Mutable;
}

unint64_t poolBlockState_newMemoryBlockSerialNumber()
{
  if (poolBlockState_newMemoryBlockSerialNumber_sInitMemoryBlockSerialNumberOnce != -1)
    dispatch_once_f(&poolBlockState_newMemoryBlockSerialNumber_sInitMemoryBlockSerialNumberOnce, &poolBlockState_newMemoryBlockSerialNumber_sNextMemoryBlockSerialNumber, (dispatch_function_t)poolBlockState_InitBlockSerialNumber);
  return FigAtomicIncrement64(&poolBlockState_newMemoryBlockSerialNumber_sNextMemoryBlockSerialNumber);
}

uint64_t poolBlockState_InitBlockSerialNumber(_QWORD *a1)
{
  uint64_t result;

  result = getpid();
  *a1 = result << 47;
  return result;
}

uint64_t poolBlockState_IncrementBlockUseCountAndAccessMemory(uint64_t a1, const void *a2, _QWORD *a3, _QWORD *a4)
{
  _DWORD *Value;
  uint64_t v9;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 56));
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  ++Value[8];
  v9 = *((_QWORD *)Value + 1);
  *a3 = *((_QWORD *)Value + 2);
  *a4 = v9;
  return FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 56));
}

uint64_t memoryOrigin_poolNotificationListener(int a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  const void **Value;
  const void **v9;
  CFMutableDictionaryRef Mutable;
  void *v11;
  __CFNotificationCenter *DefaultLocalCenter;
  __CFNotificationCenter *v13;
  void *key;

  result = CFEqual(cf1, CFSTR("pool_ForgetBlock"));
  if ((_DWORD)result)
  {
    key = 0;
    FigCFDictionaryGetInt64IfPresent(a5, CFSTR("pool_BlockSerialNumber"), &key);
    FigReentrantMutexLock(*(pthread_mutex_t **)(a2 + 16));
    Value = (const void **)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 24), key);
    if (Value)
    {
      v9 = Value;
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      FigCFDictionarySetInt64(Mutable, CFSTR("BlockSerialNumber"), (uint64_t)key);
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a2 + 24), key);
      if (*(_QWORD *)(a2 + 72))
      {
        if (!CFDictionaryGetCount(*(CFDictionaryRef *)(a2 + 24)))
        {
          v11 = *(void **)(a2 + 72);
          if (v11)
          {
            os_release(v11);
            *(_QWORD *)(a2 + 72) = 0;
          }
        }
      }
      DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
      CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("ForgetBlock"), (const void *)a2, Mutable);
      if (Mutable)
        CFRelease(Mutable);
      CFBagRemoveValue(*(CFMutableBagRef *)(a2 + 32), *v9);
      if (!MEMORY[0x193FFAA5C](*(_QWORD *)(a2 + 32), *v9))
      {
        v13 = CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterRemoveWeakListener(v13, (const void *)a2, (uint64_t)memoryOrigin_poolNotificationListener, 0, *v9);
      }
      memoryOrigin_disposeOriginEntry(v9);
    }
    return FigReentrantMutexUnlock(*(pthread_mutex_t **)(a2 + 16));
  }
  return result;
}

uint64_t poolBlockState_DecrementBlockUseCount(uint64_t a1, const void *a2)
{
  const void **Value;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 56));
  Value = (const void **)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  poolBlockState_DecrementUseCountInternal(a1, Value);
  return FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 56));
}

void memoryOrigin_disposeOriginEntry(const void **a1)
{
  const void *v2;
  void *v3;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      CFRelease(v2);
    v3 = (void *)a1[1];
    if (v3)
    {
      a1[1] = 0;
      xpc_release(v3);
    }
    free(a1);
  }
}

uint64_t memoryOriginServer_handleRemoteMessageWithReply(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t OpCode;
  const char *string;
  const char *v8;
  const __CFAllocator *v9;
  uint64_t Instance;
  uint64_t v11;
  pthread_mutex_t *v12;
  CFMutableDictionaryRef Mutable;
  CFMutableBagRef v14;
  char *v15;
  uint64_t uint64;
  const void *int64;
  uint64_t v18;
  xpc_object_t *v19;
  uint64_t v20;
  const void *v21;
  char *v22;
  uint64_t v23;
  int v25;
  uint64_t value;

  v25 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v25);
  if ((_DWORD)OpCode)
    return OpCode;
  if (v25 != 1718903656)
  {
    if (v25 != 1668441400)
      return FigSignalErrorAt(4294951138, 0, 0, 0, 0, 0, 0);
    value = 0;
    string = xpc_dictionary_get_string(a2, ".DebugName");
    v8 = xpc_dictionary_get_string(a2, ".ProcessName");
    v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (memoryOrigin_GetTypeID_sRegisterMemoryOriginTypeOnce != -1)
      dispatch_once(&memoryOrigin_GetTypeID_sRegisterMemoryOriginTypeOnce, &__block_literal_global_67);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v11 = Instance;
      v12 = FigReentrantMutexCreate();
      *(_QWORD *)(v11 + 16) = v12;
      if (v12)
      {
        Mutable = CFDictionaryCreateMutable(v9, 0, 0, 0);
        *(_QWORD *)(v11 + 24) = Mutable;
        if (Mutable)
        {
          v14 = CFBagCreateMutable(v9, 0, MEMORY[0x1E0C9B388]);
          *(_QWORD *)(v11 + 32) = v14;
          if (v14)
          {
            if (string)
              v15 = strndup(string, 0x64uLL);
            else
              v15 = strdup("unnamed");
            *(_QWORD *)(v11 + 48) = v15;
            if (v8)
              v22 = strndup(v8, 0x64uLL);
            else
              v22 = strdup("unknown");
            *(_QWORD *)(v11 + 64) = v22;
            *(_DWORD *)(v11 + 56) = xpc_connection_get_pid(a1);
            v23 = FigXPCServerAssociateObjectWithConnection(a1, (const void *)v11, 0, 0, 0, &value);
            if ((_DWORD)v23)
            {
              v20 = v23;
              goto LABEL_26;
            }
LABEL_25:
            xpc_dictionary_set_uint64(a3, ".objectID", value);
            v20 = 0;
            *(_QWORD *)(v11 + 40) = value;
LABEL_26:
            v21 = (const void *)v11;
LABEL_27:
            CFRelease(v21);
            return v20;
          }
        }
      }
      v20 = FigSignalErrorAt(4294951775, 0, 0, 0, 0, 0, 0);
      CFRelease((CFTypeRef)v11);
    }
    else
    {
      v20 = FigSignalErrorAt(4294951775, 0, 0, 0, 0, 0, 0);
    }
    if ((_DWORD)v20)
      return v20;
    OpCode = FigXPCServerAssociateObjectWithConnection(a1, 0, 0, 0, 0, &value);
    v11 = 0;
    if (!(_DWORD)OpCode)
      goto LABEL_25;
    return OpCode;
  }
  value = 0;
  uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  int64 = (const void *)xpc_dictionary_get_int64(a2, "BlockSerialNumber");
  v18 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &value, 0);
  if ((_DWORD)v18)
  {
    v20 = v18;
  }
  else
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(value + 16));
    v19 = (xpc_object_t *)CFDictionaryGetValue(*(CFDictionaryRef *)(value + 24), int64);
    if (v19)
    {
      xpc_dictionary_set_value(a3, "OriginData", v19[1]);
      v20 = 0;
    }
    else
    {
      v20 = FigSignalErrorAt(4294951776, 0, 0, 0, 0, 0, 0);
    }
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(value + 16));
  }
  v21 = (const void *)value;
  if (value)
    goto LABEL_27;
  return v20;
}

uint64_t memoryOriginServer_handleRemoteMessageNoReply(_xpc_connection_s *a1, void *a2)
{
  uint64_t OpCode;
  uint64_t uint64;
  const void *int64;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeRef v10;
  int v12;
  CFTypeRef cf;
  CFTypeRef v14;

  v12 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v12);
  if ((_DWORD)OpCode)
    return OpCode;
  if (v12 != 1970482529)
  {
    if (v12 == 1970496813)
    {
      v14 = 0;
      uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
      int64 = (const void *)xpc_dictionary_get_int64(a2, "BlockSerialNumber");
      v7 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &v14, 0);
      if (!(_DWORD)v7)
        v7 = memoryOrigin_unregisterUseOfBlock((uint64_t)v14, int64);
      goto LABEL_6;
    }
    return FigSignalErrorAt(4294951138, 0, 0, 0, 0, 0, 0);
  }
  cf = 0;
  v14 = 0;
  v9 = xpc_dictionary_get_uint64(a2, ".objectID");
  v7 = FigXPCMessageCopyCFArray(a2, "BlockSerialNumberArray", &v14);
  if (!(_DWORD)v7)
  {
    v8 = FigXPCServerLookupAndRetainAssociatedObject(a1, v9, &cf, 0);
    v10 = cf;
    if (!(_DWORD)v8)
    {
      v8 = memoryOrigin_unregisterUseOfMultipleBlocks((uint64_t)cf, (CFArrayRef)v14);
      v10 = cf;
    }
    if (v10)
      CFRelease(v10);
    goto LABEL_12;
  }
LABEL_6:
  v8 = v7;
LABEL_12:
  if (v14)
    CFRelease(v14);
  return v8;
}

double memoryOrigin_Init(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

uint64_t memoryOrigin_Finalize(uint64_t a1)
{
  const __CFDictionary *v2;
  const void *v3;
  const void *v4;
  void *v5;

  v2 = *(const __CFDictionary **)(a1 + 24);
  if (v2)
  {
    CFDictionaryApplyFunction(v2, (CFDictionaryApplierFunction)memoryOrigin_disposeEachOriginEntry, 0);
    v3 = *(const void **)(a1 + 24);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 24) = 0;
    }
  }
  v4 = *(const void **)(a1 + 32);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 32) = 0;
  }
  free(*(void **)(a1 + 48));
  *(_QWORD *)(a1 + 48) = 0;
  free(*(void **)(a1 + 64));
  *(_QWORD *)(a1 + 64) = 0;
  v5 = *(void **)(a1 + 72);
  if (v5)
  {
    os_release(v5);
    *(_QWORD *)(a1 + 72) = 0;
  }
  return FigReentrantMutexDestroy(*(_QWORD *)(a1 + 16));
}

__CFString *memoryOrigin_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  CFMutableArrayRef v3;
  CFMutableArrayRef v4;
  uint64_t v5;
  CFIndex Count;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
  if (v3)
  {
    v4 = v3;
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
    v5 = *(_QWORD *)(a1 + 40);
    Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 24));
    CFStringAppendFormat(Mutable, 0, CFSTR("FigMemoryOrigin %p ObjectID %016llx %ld originBlocks"), a1, v5, Count);
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
    CFRelease(v4);
  }
  return Mutable;
}

void memoryOrigin_disposeEachOriginEntry(int a1, void *a2)
{
  int v3;

  if (*((int *)a2 + 6) >= 1)
  {
    v3 = 0;
    do
    {
      poolBlockState_DecrementBlockUseCount(*(_QWORD *)a2, *((const void **)a2 + 2));
      ++v3;
    }
    while (v3 < *((_DWORD *)a2 + 6));
  }
  memoryOrigin_disposeOriginEntry((const void **)a2);
}

void receivedMemoryAllocator_tellOriginToDecrementUseCountOfBlock(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  dispatch_time_t v4;

  if (!FigCFArrayAppendInt64(*(void **)(a1 + 56), a2) && CFArrayGetCount(*(CFArrayRef *)(a1 + 56)) == 1)
  {
    v3 = *(NSObject **)(a1 + 48);
    v4 = dispatch_time(0, 200000000);
    dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0);
  }
}

uint64_t memoryRecipient_NotificationFilter(uint64_t a1, CFTypeRef cf1, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  _BYTE *ValueAtIndex;
  uint64_t v12;

  if (CFEqual(cf1, CFSTR("ForgetBlock")))
  {
    v12 = 0;
    v6 = *(_QWORD *)(a1 + 32);
    FigCFDictionaryGetInt64IfPresent(a4, CFSTR("BlockSerialNumber"), &v12);
    FigSimpleMutexLock(*(pthread_mutex_t **)v6);
    Count = CFArrayGetCount(*(CFArrayRef *)(v6 + 8));
    if (Count >= 1)
    {
      v8 = Count;
      v9 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v6 + 8), v9);
        if (*(_QWORD *)ValueAtIndex == v12)
          break;
        if (v8 == ++v9)
          goto LABEL_9;
      }
      ValueAtIndex[41] = 1;
      if (!ValueAtIndex[40])
      {
        receivedMemoryAllocator_disposeReceivedMemoryEntry((uint64_t)ValueAtIndex);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v6 + 8), v9);
      }
    }
LABEL_9:
    FigSimpleMutexUnlock(*(pthread_mutex_t **)v6);
  }
  return 1;
}

void receivedMemoryAllocator_disposeReceivedMemoryEntry(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const __CFAllocator *v4;

  if (a1)
  {
    poolBlockState_DecrementBlockUseCount(*(_QWORD *)(a1 + 48), *(const void **)(a1 + 8));
    v2 = *(const void **)(a1 + 48);
    if (v2)
      CFRelease(v2);
    v3 = *(const void **)(a1 + 32);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 32) = 0;
    }
    v4 = *(const __CFAllocator **)(a1 + 56);
    CFAllocatorDeallocate(v4, (void *)a1);
    if (v4)
      CFRelease(v4);
  }
}

_QWORD *memoryRecipient_Init(_QWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

void memoryRecipient_Finalize(uint64_t a1)
{
  CFIndex Count;
  CFIndex v3;
  CFIndex v4;
  _BYTE *ValueAtIndex;
  const void *v6;

  if (*(_QWORD *)(a1 + 24))
  {
    FigSimpleMutexLock(**(pthread_mutex_t ***)(a1 + 32));
    Count = CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)(a1 + 32) + 8));
    if (Count >= 1)
    {
      v3 = Count;
      v4 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(_QWORD *)(a1 + 32) + 8), v4);
        ValueAtIndex[41] = 1;
        if (ValueAtIndex[40])
        {
          ++v4;
        }
        else
        {
          receivedMemoryAllocator_disposeReceivedMemoryEntry((uint64_t)ValueAtIndex);
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(*(_QWORD *)(a1 + 32) + 8), v4);
          --v3;
        }
      }
      while (v4 < v3);
    }
    FigSimpleMutexUnlock(**(pthread_mutex_t ***)(a1 + 32));
    v6 = *(const void **)(a1 + 24);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(a1 + 24) = 0;
    }
  }
}

__CFString *memoryRecipient_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  CFIndex Count;

  Mutable = CFStringCreateMutable(0, 0);
  FigSimpleMutexLock(**(pthread_mutex_t ***)(a1 + 32));
  Count = CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)(a1 + 32) + 8));
  CFStringAppendFormat(Mutable, 0, CFSTR("FigMemoryRecipient %p ObjectID %016llx receivedMemoryAllocator %p %ld memory blocks"), a1, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), Count);
  FigSimpleMutexUnlock(**(pthread_mutex_t ***)(a1 + 32));
  return Mutable;
}

void receivedMemoryAllocator_ReleaseInfo(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  const void *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v10;
  const void *v11;
  const void *v12;

  if (a1)
  {
    v2 = *(NSObject **)(a1 + 48);
    if (v2)
    {
      dispatch_source_cancel(v2);
      v3 = *(NSObject **)(a1 + 48);
      if (v3)
      {
        dispatch_release(v3);
        *(_QWORD *)(a1 + 48) = 0;
      }
    }
    v4 = *(NSObject **)(a1 + 40);
    if (v4)
    {
      dispatch_release(v4);
      *(_QWORD *)(a1 + 40) = 0;
    }
    receivedMemoryAllocator_sendPendingBatchOfBlockSNtoDecrementUseCount((pthread_mutex_t **)a1);
    v5 = *(const void **)(a1 + 56);
    if (v5)
      CFRelease(v5);
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 8));
    if (Count >= 1)
    {
      v7 = Count;
      for (i = 0; i != v7; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), i);
        receivedMemoryAllocator_disposeReceivedMemoryEntry((uint64_t)ValueAtIndex);
      }
    }
    v10 = *(const void **)(a1 + 32);
    if (v10)
    {
      CFRelease(v10);
      *(_QWORD *)(a1 + 32) = 0;
    }
    v11 = *(const void **)(a1 + 8);
    if (v11)
    {
      CFRelease(v11);
      *(_QWORD *)(a1 + 8) = 0;
    }
    v12 = *(const void **)(a1 + 16);
    if (v12)
    {
      CFRelease(v12);
      *(_QWORD *)(a1 + 16) = 0;
    }
    FigSimpleMutexDestroy(*(_QWORD *)a1);
    free((void *)a1);
  }
}

void receivedMemoryAllocator_Deallocate(id *a1, uint64_t a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  __CFArray *Mutable;
  const __CFAllocator *v8;
  const CFArrayCallBacks *v9;
  id **ValueAtIndex;
  uint64_t v11;
  id *v12;
  id *v13;

  FigSimpleMutexLock(*(pthread_mutex_t **)a2);
  Count = CFArrayGetCount(*(CFArrayRef *)(a2 + 8));
  if (Count >= 1)
  {
    v5 = Count;
    v6 = 0;
    Mutable = 0;
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v9 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    while (1)
    {
      ValueAtIndex = (id **)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 8), v6);
      if (ValueAtIndex[2] == a1)
      {
        v11 = (uint64_t)ValueAtIndex;
        v12 = FigCFWeakReferenceHolderCopyReferencedObject(ValueAtIndex[4]);
        if (!v12)
        {
          if (*(_BYTE *)(v11 + 40))
          {
            *(_BYTE *)(v11 + 40) = 0;
            if (*(_BYTE *)(v11 + 41))
            {
              receivedMemoryAllocator_disposeReceivedMemoryEntry(v11);
              CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a2 + 8), v6);
            }
            else
            {
              receivedMemoryAllocator_tellOriginToDecrementUseCountOfBlock(a2, *(_QWORD *)v11);
            }
          }
          goto LABEL_12;
        }
        v13 = v12;
        if (*(_QWORD *)v11)
        {
          FigSimpleMutexUnlock(*(pthread_mutex_t **)a2);
          CFRelease(v13);
          if (Mutable)
            goto LABEL_13;
          return;
        }
        if (!Mutable)
          Mutable = CFArrayCreateMutable(v8, 0, v9);
        CFArrayAppendValue(Mutable, v13);
        CFRelease(v13);
      }
      if (v5 == ++v6)
        goto LABEL_12;
    }
  }
  Mutable = 0;
LABEL_12:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)a2);
  if (Mutable)
LABEL_13:
    CFRelease(Mutable);
}

void receivedMemoryAllocator_finalizeUseCountUpdateTimer(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void receivedMemoryAllocator_sendPendingBatchOfBlockSNtoDecrementUseCount(pthread_mutex_t **a1)
{
  pthread_mutex_t **v1;
  xpc_object_t xdict;

  xdict = 0;
  if (a1)
  {
    v1 = a1;
    FigSimpleMutexLock(*a1);
    if (CFArrayGetCount((CFArrayRef)v1[7]) >= 1 && !FigXPCCreateBasicMessage(0x75732D61u, 0, &xdict))
    {
      FigXPCMessageSetCFObject(xdict, "BlockSerialNumberArray", v1[7]);
      CFArrayRemoveAllValues((CFMutableArrayRef)v1[7]);
      xpc_dictionary_set_uint64(xdict, ".objectID", (uint64_t)v1[3]);
      FigXPCRemoteClientSendAsyncMessage((uint64_t)v1[2], xdict);
    }
    FigSimpleMutexUnlock(*v1);
    a1 = (pthread_mutex_t **)xdict;
  }
  FigXPCRelease(a1);
}

uint64_t FigTransportStreamGetClassID()
{
  if (FigTransportStreamGetClassID_sRegisterOnce != -1)
    dispatch_once_f(&FigTransportStreamGetClassID_sRegisterOnce, &FigTransportStreamGetClassID_sClassID, (dispatch_function_t)stream_getClassID);
  return FigTransportStreamGetClassID_sClassID;
}

uint64_t stream_getClassID(_QWORD *a1)
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&stream_getClassID_sClassDesc, ClassID, 1, a1);
}

uint64_t FigTransportStreamGetTypeID()
{
  if (FigTransportStreamGetClassID_sRegisterOnce != -1)
    dispatch_once_f(&FigTransportStreamGetClassID_sRegisterOnce, &FigTransportStreamGetClassID_sClassID, (dispatch_function_t)stream_getClassID);
  return CMBaseClassGetCFTypeID((_QWORD *)FigTransportStreamGetClassID_sClassID);
}

uint64_t FigTransportStreamSendBatchSlow(uint64_t a1, uint64_t a2, CFArrayRef theArray)
{
  uint64_t result;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  const void *ValueAtIndex;
  const void *v11;
  CFTypeID v12;
  uint64_t (*v13)(uint64_t, uint64_t, const void *);

  result = 4294950686;
  if (a1 && theArray)
  {
    Count = CFArrayGetCount(theArray);
    if (Count < 1)
    {
      return 0;
    }
    else
    {
      v8 = Count;
      v9 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, v9);
        if (!ValueAtIndex)
          break;
        v11 = ValueAtIndex;
        v12 = CFGetTypeID(ValueAtIndex);
        if (v12 != CMBlockBufferGetTypeID())
          break;
        v13 = *(uint64_t (**)(uint64_t, uint64_t, const void *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16)
                                                                       + 48);
        if (!v13)
          return 4294954514;
        result = v13(a1, a2, v11);
        if ((_DWORD)result)
          return result;
        if (v8 == ++v9)
          return 0;
      }
      return 4294950686;
    }
  }
  return result;
}

CFStringRef stream_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigTransportStream %p]"), a1);
}

uint64_t FigEndpointPlaybackSessionStartServer()
{
  CFMutableDictionaryRef Mutable;
  uint64_t v1;
  _OWORD v3[3];

  v3[0] = xmmword_1E28DE2D8;
  memset(&v3[1], 0, 32);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetInt32(Mutable, CFSTR("xpcServerOption_SelfTerminationTimeout"), 30);
  v1 = FigXPCServerStart((uint64_t)"com.apple.coremedia.endpointplaybacksession.xpc", (uint64_t)v3, (uint64_t)Mutable, &gEndpointPlaybackSessionServer);
  if (Mutable)
    CFRelease(Mutable);
  return v1;
}

uint64_t HandleEndpointPlaybackSessionRemoteMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t OpCode;
  uint64_t uint64;
  uint64_t v8;
  CFTypeID v9;
  CFTypeRef v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *CompletionCallbackParametersFromMessageAndConnection_0;
  CFTypeRef v15;
  CFTypeRef v16;
  uint64_t (*v17)(CFTypeRef, CFTypeRef, CFTypeRef, void *, _QWORD *);
  void *v18;
  _QWORD *v19;
  uint64_t (*v20)(CFTypeRef, void *, _QWORD *);
  void *v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  void *v25;
  uint64_t (*v26)(CFTypeRef, void (*)(uint64_t, const void *, uint64_t), uint64_t, _QWORD);
  uint64_t v27;
  uint64_t (*v28)(CFTypeRef, _QWORD, _QWORD, _QWORD);
  uint64_t CMBaseObject;
  uint64_t v30;
  uint64_t (*v31)(uint64_t);
  uint64_t v32;
  CFTypeRef v33;
  CFTypeRef v34;
  uint64_t v35;
  uint64_t (*v36)(CFTypeRef, CFTypeRef, CFTypeRef, uint64_t);
  double v37;
  uint64_t v38;
  _QWORD *v39;
  CFTypeRef v40;
  uint64_t (*v41)(CFTypeRef, CFTypeRef, void (*)(int, uint64_t), _QWORD *, float);
  void (*v42)(int, uint64_t);
  float v43;
  uint64_t v44;
  _QWORD *v45;
  CFTypeRef v46;
  uint64_t (*v47)(CFTypeRef, CFTypeRef, void (*)(int, uint64_t), _QWORD *);
  uint64_t CMTime;
  _QWORD *v49;
  CFTypeRef v50;
  uint64_t (*v51)(CFTypeRef, CFTypeRef *, CFTypeRef, void (*)(const void *, int, uint64_t), _QWORD *);
  void (*v52)(const void *, int, uint64_t);
  void *v53;
  CFTypeRef v54;
  void (*v55)(int, uint64_t);
  void *v56;
  uint64_t v58;
  int v59;
  __int128 v60;
  uint64_t v61;
  CFTypeRef v62;
  CFTypeRef v63[2];
  uint64_t v64;
  CFTypeRef cf[2];
  uint64_t v66;

  v59 = 0;
  v58 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v59);
  if ((_DWORD)OpCode)
    return OpCode;
  uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  cf[0] = 0;
  v8 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, cf, &v58);
  if (!(_DWORD)v8)
  {
    if (cf[0])
    {
      v9 = CFGetTypeID(cf[0]);
      if (v9 == FigEndpointPlaybackSessionGetTypeID())
      {
        v10 = cf[0];
        goto LABEL_6;
      }
    }
    v8 = FigSignalErrorAt(4294950556, 0, 0, 0, 0, 0, 0);
  }
  v11 = v8;
  if (cf[0])
    CFRelease(cf[0]);
  if (!(_DWORD)v11)
  {
    v10 = 0;
LABEL_6:
    v11 = 4294950556;
    if (v59 <= 1886151032)
    {
      if (v59 > 1685024620)
      {
        if (v59 > 1735422065)
        {
          if (v59 == 1735422066)
          {
            cf[0] = 0;
            v63[0] = 0;
            v13 = FigXPCMessageCopyCFString(a2, "PropertyKey", cf);
            if (!(_DWORD)v13)
            {
              if (cf[0])
              {
                v13 = FigXPCMessageCopyCFDictionary(a2, "Params", v63);
                if (!(_DWORD)v13)
                {
                  CompletionCallbackParametersFromMessageAndConnection_0 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
                  v15 = cf[0];
                  v16 = v63[0];
                  v17 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef, void *, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16) + 88);
                  if (v17)
                  {
                    v18 = GetProxiedPropertyCompletionCallback;
                    goto LABEL_98;
                  }
                  goto LABEL_103;
                }
              }
              else
              {
                v13 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
              }
            }
LABEL_102:
            v11 = v13;
            goto LABEL_104;
          }
          if (v59 != 1768846956)
          {
            if (v59 != 1768976745)
              goto LABEL_124;
            v12 = v58;
            cf[0] = 0;
            v63[0] = 0;
            v13 = FigXPCMessageCopyCFDictionary(a2, "Item", cf);
            if ((_DWORD)v13)
              goto LABEL_102;
            v13 = FigXPCMessageCopyCFDictionary(a2, "AfterItem", v63);
            if ((_DWORD)v13)
              goto LABEL_102;
            v13 = checkRequestAgainstSandboxRules(a1, v12, a2, (CFDictionaryRef)cf[0]);
            if ((_DWORD)v13)
              goto LABEL_102;
            CompletionCallbackParametersFromMessageAndConnection_0 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
            v15 = cf[0];
            v16 = v63[0];
            v17 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef, void *, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16)
                                                                                              + 32);
            if (v17)
            {
              v18 = StandardCompletionCallback;
LABEL_98:
              if (CompletionCallbackParametersFromMessageAndConnection_0)
                v53 = v18;
              else
                v53 = 0;
              v13 = v17(v10, v15, v16, v53, CompletionCallbackParametersFromMessageAndConnection_0);
              goto LABEL_102;
            }
            goto LABEL_103;
          }
          CMBaseObject = FigEndpointPlaybackSessionGetCMBaseObject(v10);
          if (!CMBaseObject)
          {
            v11 = 4294954516;
            goto LABEL_124;
          }
          v30 = CMBaseObject;
          v31 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8) + 24);
          if (v31)
          {
            v22 = v31(v30);
            goto LABEL_85;
          }
LABEL_65:
          v11 = 4294954514;
          goto LABEL_124;
        }
        if (v59 == 1685024621)
        {
          v22 = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
          goto LABEL_85;
        }
        if (v59 != 1735421033)
          goto LABEL_124;
        v19 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
        v20 = *(uint64_t (**)(CFTypeRef, void *, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10)
                                                                                + 16)
                                                                    + 56);
        if (!v20)
          goto LABEL_65;
        v21 = GetPlaybackInfoCompletionCallback;
LABEL_39:
        if (v19)
          v23 = v21;
        else
          v23 = 0;
        v22 = v20(v10, v23, v19);
        goto LABEL_85;
      }
      if (v59 > 1635018856)
      {
        if (v59 != 1635018857)
        {
          if (v59 == 1667593832)
          {
            v27 = v58;
            v28 = *(uint64_t (**)(CFTypeRef, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10)
                                                                                          + 16)
                                                                              + 120);
            v11 = v28 ? v28(v10, 0, 0, 0) : 4294954514;
            *(_QWORD *)(v27 + 8) = 0;
            v56 = *(void **)(v27 + 16);
            if (v56)
            {
              *(_QWORD *)(v27 + 16) = 0;
              xpc_release(v56);
            }
          }
          goto LABEL_124;
        }
        cf[0] = 0;
        v63[0] = 0;
        v13 = FigXPCMessageCopyCFData(a2, "PicRequest", cf);
        if ((_DWORD)v13)
          goto LABEL_102;
        v13 = FigXPCMessageCopyCFString(a2, "ItemUUID", v63);
        if ((_DWORD)v13)
          goto LABEL_102;
        CompletionCallbackParametersFromMessageAndConnection_0 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
        v15 = cf[0];
        v16 = v63[0];
        v17 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef, void *, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16)
                                                                                          + 16);
        if (v17)
        {
          v18 = AuthorizeItemCompletionCallback;
          goto LABEL_98;
        }
        goto LABEL_103;
      }
      if (v59 == 778268793)
      {
        v22 = FigXPCHandleStdCopyPropertyMessage((uint64_t)v10, a2, a3);
      }
      else
      {
        if (v59 != 779314548)
          goto LABEL_124;
        v22 = FigXPCHandleStdSetPropertyMessage((uint64_t)v10, a2);
      }
LABEL_85:
      v11 = v22;
      goto LABEL_124;
    }
    if (v59 <= 1936028776)
    {
      if (v59 > 1919971688)
      {
        if (v59 != 1919971689)
        {
          if (v59 != 1936024673)
            goto LABEL_124;
          cf[0] = 0;
          v63[0] = 0;
          v13 = FigXPCMessageCopyCFDate(a2, "Date", (CFDateRef *)cf);
          if ((_DWORD)v13)
            goto LABEL_102;
          v13 = FigXPCMessageCopyCFDictionary(a2, "Options", v63);
          if ((_DWORD)v13)
            goto LABEL_102;
          CompletionCallbackParametersFromMessageAndConnection_0 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
          v15 = cf[0];
          v16 = v63[0];
          v17 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef, void *, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16)
                                                                                            + 72);
          if (v17)
          {
            v18 = SeekCompletionCallback;
            goto LABEL_98;
          }
          goto LABEL_103;
        }
        cf[0] = 0;
        v38 = FigXPCMessageCopyCFDictionary(a2, "Item", cf);
        if ((_DWORD)v38)
          goto LABEL_114;
        v45 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
        v46 = cf[0];
        v47 = *(uint64_t (**)(CFTypeRef, CFTypeRef, void (*)(int, uint64_t), _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16) + 40);
        if (!v47)
          goto LABEL_83;
      }
      else
      {
        if (v59 != 1886151033)
        {
          if (v59 != 1886545249)
            goto LABEL_124;
          cf[0] = 0;
          v63[0] = 0;
          v13 = FigXPCMessageCopyCFString(a2, "Type", cf);
          if ((_DWORD)v13)
            goto LABEL_102;
          v13 = FigXPCMessageCopyCFObject(a2, "Params", (__CFDictionary **)v63);
          if ((_DWORD)v13)
            goto LABEL_102;
          CompletionCallbackParametersFromMessageAndConnection_0 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
          v15 = cf[0];
          v16 = v63[0];
          v17 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef, void *, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16)
                                                                                            + 112);
          if (v17)
          {
            v18 = RemoteActionCompletionCallback;
            goto LABEL_98;
          }
LABEL_103:
          v11 = 4294954514;
LABEL_104:
          if (cf[0])
            CFRelease(cf[0]);
          v54 = v63[0];
          if (!v63[0])
            goto LABEL_124;
          goto LABEL_123;
        }
        v44 = v58;
        cf[0] = 0;
        v38 = FigXPCMessageCopyCFDictionary(a2, "Params", cf);
        if ((_DWORD)v38)
          goto LABEL_114;
        v38 = checkRequestAgainstSandboxRules(a1, v44, a2, (CFDictionaryRef)cf[0]);
        if ((_DWORD)v38)
          goto LABEL_114;
        v45 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
        v46 = cf[0];
        v47 = *(uint64_t (**)(CFTypeRef, CFTypeRef, void (*)(int, uint64_t), _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16) + 24);
        if (!v47)
          goto LABEL_83;
      }
      if (v45)
        v55 = StandardCompletionCallback;
      else
        v55 = 0;
      v38 = v47(v10, v46, v55, v45);
      goto LABEL_114;
    }
    if (v59 > 1936748657)
    {
      if (v59 != 1936748658)
      {
        if (v59 != 1936875892)
        {
          if (v59 != 1937010544)
            goto LABEL_124;
          v19 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
          v20 = *(uint64_t (**)(CFTypeRef, void *, _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10)
                                                                                  + 16)
                                                                      + 48);
          if (!v20)
            goto LABEL_65;
          v21 = StandardCompletionCallback;
          goto LABEL_39;
        }
        cf[0] = 0;
        v37 = xpc_dictionary_get_double(a2, "Rate");
        v38 = FigXPCMessageCopyCFDictionary(a2, "Params", cf);
        if ((_DWORD)v38)
          goto LABEL_114;
        v39 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
        v40 = cf[0];
        v41 = *(uint64_t (**)(CFTypeRef, CFTypeRef, void (*)(int, uint64_t), _QWORD *, float))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16) + 80);
        if (v41)
        {
          if (v39)
            v42 = StandardCompletionCallback;
          else
            v42 = 0;
          v43 = v37;
          v38 = v41(v10, v40, v42, v39, v43);
LABEL_114:
          v11 = v38;
LABEL_115:
          v54 = cf[0];
          if (!cf[0])
          {
LABEL_124:
            if (v10)
              CFRelease(v10);
            return v11;
          }
LABEL_123:
          CFRelease(v54);
          goto LABEL_124;
        }
LABEL_83:
        v11 = 4294954514;
        goto LABEL_115;
      }
      cf[0] = 0;
      v63[0] = 0;
      *(_QWORD *)&v60 = 0;
      v32 = FigXPCMessageCopyCFString(a2, "PropertyKey", cf);
      if (!(_DWORD)v32)
      {
        if (cf[0])
        {
          v32 = FigXPCMessageCopyCFDictionary(a2, "Params", v63);
          if (!(_DWORD)v32)
          {
            v32 = FigXPCMessageCopyCFObject(a2, "PropertyValue", (__CFDictionary **)&v60);
            if (!(_DWORD)v32)
            {
              v33 = cf[0];
              v34 = v63[0];
              v35 = v60;
              v36 = *(uint64_t (**)(CFTypeRef, CFTypeRef, CFTypeRef, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16)
                                                                                       + 96);
              if (!v36)
              {
                v11 = 4294954514;
LABEL_128:
                if (cf[0])
                  CFRelease(cf[0]);
                if (v63[0])
                  CFRelease(v63[0]);
                v54 = (CFTypeRef)v60;
                if (!(_QWORD)v60)
                  goto LABEL_124;
                goto LABEL_123;
              }
              v32 = v36(v10, v33, v34, v35);
            }
          }
        }
        else
        {
          v32 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
        }
      }
      v11 = v32;
      goto LABEL_128;
    }
    if (v59 != 1936028777)
    {
      if (v59 != 1936029288)
        goto LABEL_124;
      v24 = v58;
      *(_QWORD *)(v24 + 8) = xpc_dictionary_get_uint64(a2, ".objectID");
      v25 = *(void **)(v24 + 16);
      *(_QWORD *)(v24 + 16) = FigXPCRetain(a1);
      FigXPCRelease(v25);
      v26 = *(uint64_t (**)(CFTypeRef, void (*)(uint64_t, const void *, uint64_t), uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16) + 120);
      if (!v26)
        goto LABEL_65;
      v22 = v26(v10, HandleEventCallback, v24, 0);
      goto LABEL_85;
    }
    v63[0] = 0;
    v63[1] = 0;
    v64 = 0;
    v62 = 0;
    CMTime = FigXPCMessageGetCMTime(a2, "Time", (uint64_t)v63);
    if (!(_DWORD)CMTime)
    {
      CMTime = FigXPCMessageCopyCFDictionary(a2, "Options", &v62);
      if (!(_DWORD)CMTime)
      {
        v49 = CreateCompletionCallbackParametersFromMessageAndConnection_0(a2, a1);
        v50 = v62;
        v60 = *(_OWORD *)v63;
        v61 = v64;
        v51 = *(uint64_t (**)(CFTypeRef, CFTypeRef *, CFTypeRef, void (*)(const void *, int, uint64_t), _QWORD *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16) + 64);
        if (!v51)
        {
          v11 = 4294954514;
LABEL_122:
          v54 = v62;
          if (!v62)
            goto LABEL_124;
          goto LABEL_123;
        }
        if (v49)
          v52 = SeekCompletionCallback;
        else
          v52 = 0;
        *(_OWORD *)cf = v60;
        v66 = v61;
        CMTime = v51(v10, cf, v50, v52, v49);
      }
    }
    v11 = CMTime;
    goto LABEL_122;
  }
  return v11;
}

uint64_t FigXPCEndpointPlaybackSessionServerAssociateCopiedNeighborFigEndpointPlaybackSession(_xpc_connection_s *a1, const void *a2, _QWORD *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;

  v6 = malloc_type_calloc(1uLL, 0x20uLL, 0x10200404161829EuLL);
  v7 = v6;
  if (v6)
  {
    *v6 = a2;
    if (a2)
      CFRetain(a2);
    v7[3] = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  }
  else
  {
    v8 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    if ((_DWORD)v8)
      goto LABEL_6;
  }
  v8 = FigXPCServerAssociateCopiedObjectWithNeighborProcess(gEndpointPlaybackSessionServer, a1, a2, (uint64_t)v7, (uint64_t)DisposeSessionEventHandlerState, 0, a3);
  if ((_DWORD)v8)
LABEL_6:
    DisposeSessionEventHandlerState(v7);
  return v8;
}

void DisposeSessionEventHandlerState(void *a1)
{
  uint64_t v2;
  void (*v3)(uint64_t, _QWORD, _QWORD, _QWORD);
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex i;
  const void *v8;
  void *v9;
  uint64_t v10;

  if (a1)
  {
    v2 = *(_QWORD *)a1;
    if (*(_QWORD *)a1)
    {
      v3 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(*(_QWORD *)a1) + 16)
                                                                  + 120);
      if (v3)
        v3(v2, 0, 0, 0);
    }
    v4 = (const __CFArray *)*((_QWORD *)a1 + 3);
    if (v4)
    {
      Count = CFArrayGetCount(v4);
      if (Count >= 1)
      {
        v6 = Count;
        for (i = 0; i != v6; ++i)
        {
          v10 = 0;
          FigCFArrayGetInt64AtIndex(*((const void **)a1 + 3), i, &v10);
          sandbox_extension_release();
        }
      }
      v8 = (const void *)*((_QWORD *)a1 + 3);
      if (v8)
      {
        CFRelease(v8);
        *((_QWORD *)a1 + 3) = 0;
      }
    }
    v9 = (void *)*((_QWORD *)a1 + 2);
    if (v9)
    {
      *((_QWORD *)a1 + 2) = 0;
      xpc_release(v9);
    }
    if (*(_QWORD *)a1)
      CFRelease(*(CFTypeRef *)a1);
    free(a1);
  }
}

_QWORD *CreateCompletionCallbackParametersFromMessageAndConnection_0(void *a1, void *a2)
{
  uint64_t uint64;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;

  uint64 = xpc_dictionary_get_uint64(a1, "CompletionID");
  if (!uint64)
    return 0;
  v5 = uint64;
  v6 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
  v7 = v6;
  if (v6)
  {
    *v6 = v5;
    v6[1] = xpc_dictionary_get_uint64(a1, ".objectID");
    v7[2] = FigXPCRetain(a2);
  }
  else
  {
    FigSignalErrorAt(4294950555, 0, 0, 0, 0, 0, 0);
  }
  return v7;
}

void AuthorizeItemCompletionCallback(const void *a1, const void *a2, int a3, uint64_t a4)
{
  xpc_object_t xdict;

  xdict = 0;
  if (a4 && !FigXPCCreateBasicMessage(0x63616C62u, *(_QWORD *)(a4 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(_QWORD *)a4);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a3);
    FigXPCMessageSetCFData(xdict, "PicData", a1);
    FigXPCMessageSetCFString(xdict, "PlayerGUID", a2);
    xpc_connection_send_message(*(xpc_connection_t *)(a4 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a4);
  FigXPCRelease(xdict);
}

uint64_t checkRequestAgainstSandboxRules(_xpc_connection_s *a1, uint64_t a2, void *a3, CFDictionaryRef theDict)
{
  uint64_t v8;
  CFNumberRef SInt64;
  uint64_t result;
  _BYTE v11[1024];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (!CFDictionaryGetValue(theDict, CFSTR("path")))
  {
    xpc_connection_get_pid(a1);
    bzero(v11, 0x400uLL);
    if (!sandbox_container_path_for_pid())
    {
      result = (uint64_t)CFDictionaryGetValue(theDict, CFSTR("Content-Location"));
      if (!result)
        return result;
      if (!FigXPCConnectionHasEntitlement((uint64_t)a1, (uint64_t)"com.apple.security.network.client"))
        return FigSignalErrorAt(4294950550, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  if (!xpc_dictionary_get_string(a3, "SExtToken"))
    return FigSignalErrorAt(4294950552, 0, 0, 0, 0, 0, 0);
  v8 = sandbox_extension_consume();
  if (v8 != -1)
  {
    SInt64 = FigCFNumberCreateSInt64((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v8);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 24), SInt64);
    if (SInt64)
      CFRelease(SInt64);
    return 0;
  }
  return 4294950551;
}

void StandardCompletionCallback(int a1, uint64_t a2)
{
  xpc_object_t xdict;

  xdict = 0;
  if (a2 && !FigXPCCreateBasicMessage(0x63616C62u, *(_QWORD *)(a2 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(_QWORD *)a2);
    FigXPCMessageSetOSStatus(xdict, "CompletionStatus", a1);
    xpc_connection_send_message(*(xpc_connection_t *)(a2 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a2);
  FigXPCRelease(xdict);
}

void GetPlaybackInfoCompletionCallback(const void *a1, int a2, uint64_t a3)
{
  xpc_object_t xdict;

  xdict = 0;
  if (a3 && !FigXPCCreateBasicMessage(0x63616C62u, *(_QWORD *)(a3 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(_QWORD *)a3);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a2);
    FigXPCMessageSetCFDictionary(xdict, "PlaybackInfo", a1);
    xpc_connection_send_message(*(xpc_connection_t *)(a3 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a3);
  FigXPCRelease(xdict);
}

void SeekCompletionCallback(const void *a1, int a2, uint64_t a3)
{
  xpc_object_t xdict;

  xdict = 0;
  if (a3 && !FigXPCCreateBasicMessage(0x63616C62u, *(_QWORD *)(a3 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(_QWORD *)a3);
    FigXPCMessageSetOSStatus(xdict, "CompletionStatus", a2);
    FigXPCMessageSetCFDictionary(xdict, "SeekResponseInfo", a1);
    xpc_connection_send_message(*(xpc_connection_t *)(a3 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a3);
  FigXPCRelease(xdict);
}

void GetProxiedPropertyCompletionCallback(const void *a1, const void *a2, int a3, uint64_t a4)
{
  xpc_object_t xdict;

  xdict = 0;
  if (a4 && !FigXPCCreateBasicMessage(0x63616C62u, *(_QWORD *)(a4 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(_QWORD *)a4);
    xpc_dictionary_set_int64(xdict, "CompletionStatus", a3);
    FigXPCMessageSetCFString(xdict, "PropertyKey", a1);
    FigXPCMessageSetCFObject(xdict, "PropertyValue", a2);
    xpc_connection_send_message(*(xpc_connection_t *)(a4 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a4);
  FigXPCRelease(xdict);
}

void RemoteActionCompletionCallback(int a1, const void *a2, uint64_t a3)
{
  xpc_object_t xdict;

  xdict = 0;
  if (a3 && !FigXPCCreateBasicMessage(0x63616C62u, *(_QWORD *)(a3 + 8), &xdict))
  {
    xpc_dictionary_set_uint64(xdict, "CompletionID", *(_QWORD *)a3);
    FigXPCMessageSetOSStatus(xdict, "ResponseStatus", a1);
    FigXPCMessageSetCFObject(xdict, "ResponseParams", a2);
    xpc_connection_send_message(*(xpc_connection_t *)(a3 + 16), xdict);
  }
  DestroyCompletionCallbackParameters((xpc_object_t *)a3);
  FigXPCRelease(xdict);
}

void HandleEventCallback(uint64_t a1, const void *a2, uint64_t a3)
{
  int v5;
  xpc_object_t v6;
  xpc_object_t message;

  message = 0;
  if (a3)
  {
    v5 = FigXPCCreateBasicMessage(0x65686362u, *(_QWORD *)(a3 + 8), &message);
    v6 = message;
    if (!v5)
    {
      FigXPCMessageSetCFDictionary(message, "EventInfo", a2);
      xpc_connection_send_message(*(xpc_connection_t *)(a3 + 16), message);
      v6 = message;
    }
  }
  else
  {
    v6 = 0;
  }
  FigXPCRelease(v6);
}

uint64_t FigH264Bridge_GetNALUnitHeaderLengthFromAVCC(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  uint64_t result;

  if (a2 < 7)
    return 4294954582;
  result = 0;
  *a3 = (*(_BYTE *)(a1 + 4) & 3) + 1;
  return result;
}

uint64_t FigH264Bridge_GetPPSFromAVCC(uint64_t a1, unint64_t a2, int a3, _QWORD *a4, _QWORD *a5)
{
  int v5;
  unint64_t v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v16;

  if (a2 >= 7)
  {
    v5 = *(_BYTE *)(a1 + 5) & 0x1F;
    if ((*(_BYTE *)(a1 + 5) & 0x1F) != 0)
    {
      LODWORD(v6) = 6;
      while (1)
      {
        v7 = (v6 + 2);
        if (v7 > a2)
          break;
        v8 = *(unsigned __int16 *)(a1 + v6);
        v9 = __rev16(v8);
        v6 = v7 + (bswap32(v8) >> 16);
        if (v9 < 2 || v6 > a2)
          break;
        if (!--v5)
          goto LABEL_12;
      }
    }
    else
    {
      LODWORD(v6) = 6;
LABEL_12:
      v11 = (v6 + 1);
      if (v11 <= a2)
      {
        v12 = *(unsigned __int8 *)(a1 + v6);
        if (!v12)
          return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        while ((int)v11 + 2 <= a2)
        {
          v13 = *(unsigned __int8 *)(a1 + (int)v11 + 1) | (*(unsigned __int8 *)(a1 + v11) << 8);
          if (v13 < 2 || (int)v13 + (int)v11 + 2 > a2)
            break;
          if (!a3)
          {
            v16 = 0;
            *a4 = a1 + v11 + 2;
            *a5 = v13;
            return v16;
          }
          --a3;
          LODWORD(v11) = v13 + v11 + 2;
          if (!--v12)
            return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        }
      }
    }
  }
  return 4294954582;
}

uint64_t FigH264Bridge_GetSPSSequenceID(const UInt8 *a1, unint64_t a2, _DWORD *a3)
{
  uint64_t v3;
  int Length;
  const UInt8 *BytePtr;
  uint64_t v7;
  const __CFData *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  char v15;
  char *v16;
  int v17;
  int v18;
  char *v19;
  int v20;
  int v21;
  BOOL v22;
  int v23;
  char *v24;
  CFDataRef theData;
  __int128 v28;
  __int128 v29;

  v28 = 0u;
  v29 = 0u;
  theData = 0;
  v3 = 4294954584;
  if (!a1)
    return v3;
  Length = a2;
  if (a2 < 6)
    return v3;
  BytePtr = a1;
  if ((*a1 & 0x1F) != 7)
    return v3;
  v7 = RemoveEmulation3Byte(a1, a2, &theData);
  v8 = theData;
  if ((_DWORD)v7)
  {
LABEL_32:
    v3 = v7;
    if (!v8)
      return v3;
    goto LABEL_29;
  }
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(v8);
  }
  v9 = (unsigned int *)(BytePtr + 4);
  *(_QWORD *)&v28 = BytePtr + 4;
  DWORD2(v28) = Length - 4;
  *(_QWORD *)&v29 = BytePtr + 4;
  if ((Length - 4) < 4)
  {
    if (Length == 4)
    {
      v10 = 0;
    }
    else
    {
      DWORD2(v29) = 0;
      __memcpy_chk();
      v10 = DWORD2(v29);
    }
  }
  else
  {
    v10 = *v9;
  }
  v11 = bswap32(v10);
  DWORD2(v29) = v11;
  BYTE12(v29) = 0;
  if (!(v11 >> 19))
    goto LABEL_31;
  v12 = __clz(v11);
  v13 = v12 + 1;
  v14 = v11 << (v12 + 1) >> -(char)v12;
  if (!v12)
    v14 = 0;
  v15 = v13 + v12;
  v16 = (char *)v9 + ((v13 + v12) >> 3);
  v17 = (_DWORD)BytePtr + Length - (_DWORD)v16;
  if (v17 <= 3)
  {
    v18 = v15 & 7;
    if (v17 <= 0)
      v19 = v16;
    else
      v19 = v16 + 1;
    v20 = v17 - (v17 > 0);
    if (v20 > 0)
      ++v19;
    v21 = v20 - (v20 > 0);
    v22 = v21 <= 0;
    v23 = v21 & (v21 >> 31);
    v24 = v22 ? v19 : v19 + 1;
    if (v23 | v18 && v24 == v16)
    {
LABEL_31:
      v7 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_32;
    }
  }
  v3 = 0;
  *a3 = v14 + ~(-1 << v12);
  if (v8)
LABEL_29:
    CFRelease(v8);
  return v3;
}

uint64_t FigH264Bridge_GetSPSWidthAndHeight(const UInt8 *a1, unint64_t a2, _QWORD *a3, _QWORD *a4)
{
  unsigned int Length;
  const UInt8 *BytePtr;
  uint64_t v8;
  const __CFData *v9;
  unsigned int v10;
  uint64_t v11;
  CFDataRef theData;
  const UInt8 *v14;
  uint64_t v15;
  const UInt8 *v16;
  uint64_t v17;
  _OWORD v18[34];

  Length = a2;
  BytePtr = a1;
  memset(v18, 0, 512);
  v15 = 0;
  v16 = 0;
  v17 = 0;
  theData = 0;
  v8 = RemoveEmulation3Byte(a1, a2, &theData);
  if ((_DWORD)v8)
    return v8;
  v9 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(v9);
  }
  v14 = BytePtr;
  LODWORD(v15) = Length;
  v16 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v17) = 0;
      __memcpy_chk();
      v10 = v17;
    }
    else
    {
      v10 = 0;
    }
  }
  else
  {
    v10 = *(_DWORD *)BytePtr;
  }
  LODWORD(v17) = bswap32(v10);
  BYTE4(v17) = 0;
  v11 = PullParamSetSPS((uint64_t)&v14, (char *)v18);
  if (v9)
    CFRelease(v9);
  if (!(_DWORD)v11)
    FigH264Bridge_GetWidthAndHeightFromParsedSPS((uint64_t)v18, a3, a4);
  return v11;
}

uint64_t FigH264Bridge_GetWidthAndHeightFromParsedSPS(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *a2 = 16 * *(_DWORD *)(result + 324) + 16;
  v3 = 2 - *(int *)(result + 332);
  *a3 = 16 * ((int)v3 + (int)v3 * *(_DWORD *)(result + 328));
  if (*(_DWORD *)(result + 344))
  {
    v4 = *(char *)(result + 40);
    if (v4 > 3)
    {
      v5 = -2;
      v6 = -2;
    }
    else
    {
      v5 = qword_18EDDD9C8[v4];
      v6 = qword_18EDDD9E8[v4];
    }
    v7 = *(int *)(result + 360) + (uint64_t)*(int *)(result + 356);
    *a2 += v5 * (*(int *)(result + 352) + (uint64_t)*(int *)(result + 348));
    *a3 += v6 * v3 * v7;
  }
  return result;
}

uint64_t FigH264Bridge_GetSPSIsInterlaced(const UInt8 *a1, unint64_t a2, BOOL *a3)
{
  unsigned int Length;
  const UInt8 *BytePtr;
  uint64_t v6;
  const __CFData *v7;
  unsigned int v8;
  uint64_t v9;
  CFDataRef theData;
  const UInt8 *v12;
  uint64_t v13;
  const UInt8 *v14;
  uint64_t v15;
  _OWORD v16[20];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;

  Length = a2;
  BytePtr = a1;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  memset(v16, 0, sizeof(v16));
  v13 = 0;
  v14 = 0;
  v15 = 0;
  theData = 0;
  v6 = RemoveEmulation3Byte(a1, a2, &theData);
  if ((_DWORD)v6)
    return v6;
  v7 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(v7);
  }
  v12 = BytePtr;
  LODWORD(v13) = Length;
  v14 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v15) = 0;
      __memcpy_chk();
      v8 = v15;
    }
    else
    {
      v8 = 0;
    }
  }
  else
  {
    v8 = *(_DWORD *)BytePtr;
  }
  LODWORD(v15) = bswap32(v8);
  BYTE4(v15) = 0;
  v9 = PullParamSetSPS((uint64_t)&v12, (char *)v16);
  if (v7)
    CFRelease(v7);
  if (!(_DWORD)v9)
    *a3 = HIDWORD(v17) == 0;
  return v9;
}

uint64_t FigH264Bridge_GetSPSChromaFormatAndBitDepths(const UInt8 *a1, unint64_t a2, _BYTE *a3, _BYTE *a4, _BYTE *a5)
{
  unsigned int Length;
  const UInt8 *BytePtr;
  uint64_t v10;
  const __CFData *v11;
  unsigned int v12;
  uint64_t v13;
  CFDataRef theData;
  const UInt8 *v16;
  uint64_t v17;
  const UInt8 *v18;
  uint64_t v19;
  _OWORD v20[2];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;

  Length = a2;
  BytePtr = a1;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  memset(v20, 0, sizeof(v20));
  v17 = 0;
  v18 = 0;
  v19 = 0;
  theData = 0;
  v10 = RemoveEmulation3Byte(a1, a2, &theData);
  if ((_DWORD)v10)
    return v10;
  v11 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(v11);
  }
  v16 = BytePtr;
  LODWORD(v17) = Length;
  v18 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v19) = 0;
      __memcpy_chk();
      v12 = v19;
    }
    else
    {
      v12 = 0;
    }
  }
  else
  {
    v12 = *(_DWORD *)BytePtr;
  }
  LODWORD(v19) = bswap32(v12);
  BYTE4(v19) = 0;
  v13 = PullParamSetSPS((uint64_t)&v16, (char *)v20);
  if (v11)
    CFRelease(v11);
  if (!(_DWORD)v13)
  {
    if (a3)
      *a3 = BYTE8(v21);
    if (a4)
      *a4 = BYTE10(v21) + 8;
    v13 = 0;
    if (a5)
      *a5 = BYTE11(v21) + 8;
  }
  return v13;
}

uint64_t FigH264Bridge_GetSPS_VUI_Framerate(const UInt8 *a1, unint64_t a2, float *a3, BOOL *a4, _BYTE *a5, BOOL *a6, _DWORD *a7)
{
  unsigned int Length;
  const UInt8 *BytePtr;
  uint64_t v14;
  const __CFData *v15;
  unsigned int v16;
  uint64_t v17;
  float v18;
  CFDataRef theData;
  const UInt8 *v22;
  uint64_t v23;
  const UInt8 *v24;
  uint64_t v25;
  _OWORD v26[18];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  int v41;
  int v42;

  Length = a2;
  BytePtr = a1;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  memset(v26, 0, sizeof(v26));
  v23 = 0;
  v24 = 0;
  v25 = 0;
  theData = 0;
  v14 = RemoveEmulation3Byte(a1, a2, &theData);
  if ((_DWORD)v14)
    return v14;
  v15 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(v15);
  }
  v22 = BytePtr;
  LODWORD(v23) = Length;
  v24 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v25) = 0;
      __memcpy_chk();
      v16 = v25;
    }
    else
    {
      v16 = 0;
    }
  }
  else
  {
    v16 = *(_DWORD *)BytePtr;
  }
  LODWORD(v25) = bswap32(v16);
  BYTE4(v25) = 0;
  v17 = PullParamSetSPS((uint64_t)&v22, (char *)v26);
  if (v15)
    CFRelease(v15);
  if (!(_DWORD)v17)
  {
    if ((_DWORD)v36)
    {
      v18 = (float)SDWORD2(v36) / (float)SDWORD1(v36);
      if (DWORD1(v27) != 2 || HIDWORD(v29) != 0)
        v18 = v18 * 0.5;
      *a3 = v18;
      *a4 = HIDWORD(v36) != 0;
      *a5 = BYTE12(v37);
      *a6 = (_QWORD)v37 != 0;
      *a7 = 0;
      v17 = 0;
      if (*a6)
        *a7 = v41 + v42 + 2;
    }
    else
    {
      return 4294954584;
    }
  }
  return v17;
}

uint64_t FigH264Bridge_GetSPSAndPPSCountFromAVCC(const void *a1, _QWORD *a2, _QWORD *a3)
{
  CFTypeID v6;
  CFIndex Length;
  const UInt8 *BytePtr;
  char v9;
  char v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  int v16;

  if (a1)
  {
    v6 = CFGetTypeID(a1);
    if (v6 == CFDataGetTypeID())
    {
      Length = CFDataGetLength((CFDataRef)a1);
      BytePtr = CFDataGetBytePtr((CFDataRef)a1);
      if (Length > 5 && *BytePtr == 1)
      {
        v9 = 0;
        v10 = 1;
        v11 = 5;
        while (Length > v11)
        {
          v12 = v10;
          v13 = v11 + 1;
          v14 = BytePtr[v11];
          if ((v10 & 1) != 0)
            v15 = v14 & 0x1F;
          else
            v15 = v14;
          if ((_DWORD)v15)
          {
            v16 = v15;
            v11 = v13;
            while (Length > v11 + 1)
            {
              v11 += (BytePtr[v11 + 1] | ((unint64_t)BytePtr[v11] << 8)) + 2;
              if (Length < v11)
                break;
              if (!--v16)
                goto LABEL_17;
            }
            return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
          }
          v11 = v13;
LABEL_17:
          if (a2 == 0 || (v12 & 1) == 0)
          {
            if (a3 != 0 && (v9 & 1) != 0)
            {
              *a3 = v15;
              return 0;
            }
          }
          else
          {
            *a2 = v15;
          }
          v10 = 0;
          v9 = 1;
          if ((v12 & 1) == 0)
            return 0;
        }
      }
    }
  }
  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t FigH264Bridge_GetH264ParameterSetAtIndex(const void *a1, unint64_t a2, unint64_t a3, unint64_t *a4, unint64_t a5, _DWORD *a6)
{
  return FigH264Bridge_GetAndVisitH264ParameterSetAtIndex(a1, a2, a3, a4, a5, a6, 0, 0);
}

uint64_t FigH264Bridge_GetAndVisitH264ParameterSetAtIndex(CFTypeRef cf, unint64_t a2, unint64_t a3, unint64_t *a4, unint64_t a5, _DWORD *a6, unint64_t a7, uint64_t a8)
{
  CFTypeID v14;
  CFIndex Length;
  const UInt8 *BytePtr;
  const UInt8 *v17;
  int v18;
  int v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  CFIndex v24;
  int v25;
  unint64_t v26;
  CFIndex v27;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unint64_t v33;

  if (a3)
    *(_QWORD *)a3 = 0;
  if (a4)
    *a4 = 0;
  if (a5)
    *(_QWORD *)a5 = 0;
  if (a6)
    *a6 = 0;
  if (!cf)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v14 = CFGetTypeID(cf);
  if (v14 != CFDataGetTypeID())
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  Length = CFDataGetLength((CFDataRef)cf);
  BytePtr = CFDataGetBytePtr((CFDataRef)cf);
  if (Length < 6)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v17 = BytePtr;
  if (*BytePtr != 1)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v18 = BytePtr[1];
  if (!a6 || (*a6 = (BytePtr[4] & 3) + 1, a5) || a3 || a4 || a7)
  {
    v19 = 0;
    v20 = 0;
    LODWORD(v21) = 0;
    v22 = 5;
    v31 = v18 - 100;
    v30 = (1 << (v18 - 100)) & 0x100000400401;
    do
    {
      v33 = v20;
      if (v19 == 2)
      {
        if (v31 > 0x2C)
          break;
        if (!v30 || Length == v22)
          break;
        v22 += 3;
      }
      if (Length <= v22)
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      v24 = v22 + 1;
      LODWORD(v22) = v17[v22];
      if (v19)
        v22 = v22;
      else
        v22 &= 0x1Fu;
      if ((_DWORD)v22)
      {
        v21 = (int)v21;
        v32 = v22;
        v25 = v22;
        while (Length > v24 + 1)
        {
          v26 = v17[v24 + 1] | ((unint64_t)v17[v24] << 8);
          v27 = v24 + 2;
          v24 += v26 + 2;
          if (Length < v24)
            break;
          if (a2 == v21)
          {
            if (a3)
              *(_QWORD *)a3 = &v17[v27];
            if (a4)
              *a4 = v26;
            if (!(a5 | a7))
              return 0;
          }
          if (a7)
            ((void (*)(uint64_t, uint64_t, const UInt8 *))a7)(a8, v21, &v17[v27]);
          ++v21;
          if (!--v25)
          {
            v22 = v32;
            goto LABEL_44;
          }
        }
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      }
LABEL_44:
      v20 = v33 + v22;
      ++v19;
      v22 = v24;
    }
    while (v19 != 3);
    if (a5)
      *(_QWORD *)a5 = v20;
    if (!(a3 | (unint64_t)a4) || v20 > a2)
      return 0;
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigH264Bridge_VisitAllH264ParameterSets(const void *a1, unint64_t a2, _DWORD *a3, unint64_t a4, uint64_t a5)
{
  return FigH264Bridge_GetAndVisitH264ParameterSetAtIndex(a1, 0, 0, 0, a2, a3, a4, a5);
}

uint64_t FigH264Bridge_CreateAVCCFromH264ParameterSets(int a1, size_t count, uint64_t a3, uint64_t a4, unsigned int a5, _QWORD *a6, _QWORD *a7, __CFData **a8)
{
  char v11;
  uint64_t v12;
  _DWORD *v13;
  uint64_t v14;
  _DWORD *v15;
  CFIndex v16;
  size_t v17;
  unint64_t v18;
  char *v19;
  int v20;
  unsigned int v21;
  int v22;
  unint64_t v24;
  uint64_t v25;
  unsigned int v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  char v31;
  char *v32;
  int v33;
  int v34;
  char *v35;
  int v36;
  int v37;
  BOOL v38;
  int v39;
  char *v40;
  uint64_t v42;
  const __CFData *v43;
  unsigned int Length;
  _DWORD *v45;
  uint64_t v46;
  uint64_t v47;
  unsigned __int8 *v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  const __CFData *v52;
  uint64_t v53;
  unsigned int *v54;
  unsigned __int8 v55;
  int v56;
  int v57;
  unsigned int v58;
  int v59;
  int v60;
  unsigned int v61;
  unsigned __int8 *v62;
  int v63;
  unsigned int v64;
  int v65;
  int v66;
  unsigned int v67;
  unsigned int v68;
  int v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  unsigned int v73;
  unsigned int v74;
  uint64_t v75;
  int v76;
  unsigned __int8 *v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  unsigned int v83;
  uint64_t v84;
  int v85;
  int v86;
  unsigned int v87;
  int v88;
  int v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  uint64_t v93;
  int v94;
  unsigned __int8 *v95;
  int v96;
  int v97;
  int v98;
  int v99;
  unsigned int v100;
  unsigned int v101;
  unsigned int v102;
  unsigned int v103;
  unsigned __int8 *v104;
  int v105;
  int v106;
  unsigned __int8 *v107;
  int v108;
  int v109;
  int v110;
  unsigned __int8 *v111;
  int v112;
  int v113;
  int v114;
  const __CFData *v115;
  uint64_t v116;
  uint64_t v117;
  unint64_t v118;
  unint64_t v119;
  void *v120;
  unsigned int v121;
  __CFData *Mutable;
  __CFData *v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v129;
  _QWORD *v130;
  char v131;
  __CFData **v132;
  _QWORD *v133;
  void *__base;
  int v135;
  int v136;
  int v137;
  int v138;
  uint64_t v139;
  uint64_t v140;
  UInt8 v141;
  unint64_t v142;
  unint64_t v143;
  unint64_t v144;
  unint64_t v145;
  uint64_t v148;
  uint64_t v149;
  CFDataRef theData;
  __int128 v151;
  __int128 v152;
  UInt8 bytes[16];
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  uint64_t v185;

  v11 = a5;
  v12 = a4;
  v185 = *MEMORY[0x1E0C80C00];
  v151 = 0u;
  v152 = 0u;
  theData = 0;
  if (a6)
    *a6 = 0;
  if (a7)
    *a7 = 0;
  if (!a3 || !a4 || count <= 1 || a5 > 4 || ((1 << a5) & 0x16) == 0 || !a8)
  {
    v127 = 4294954584;
LABEL_195:
    v125 = FigSignalErrorAt(v127, 0, 0, 0, 0, 0, 0);
    v120 = 0;
    goto LABEL_199;
  }
  *a8 = 0;
  v13 = malloc_type_calloc(count, 0x10uLL, 0x1000040451B5BE8uLL);
  if (!v13)
  {
    v127 = 4294954583;
    goto LABEL_195;
  }
  v130 = a6;
  v132 = a8;
  v133 = a7;
  v131 = v11;
  v14 = 0;
  v142 = 0;
  v143 = 0;
  v144 = 0;
  v145 = 0;
  v139 = 0;
  v140 = 0;
  __base = v13;
  v15 = v13 + 2;
  v141 = -1;
  v16 = 7;
  v137 = -1;
  v138 = -1;
  v135 = 1;
  v136 = -1;
  v17 = count;
  do
  {
    v18 = *(_QWORD *)(v12 + 8 * v14);
    if (v18 >= 0x10000)
      goto LABEL_193;
    if (!v18)
      goto LABEL_193;
    v19 = *(char **)(a3 + 8 * v14);
    if (!v19)
      goto LABEL_193;
    v20 = *v19;
    if (v20 < 0 || (v20 & 0x60) == 0)
      goto LABEL_193;
    v21 = v20 & 0x1F;
    v22 = (1 << (v20 & 0x1F)) & 0x2180;
    if (v21 > 0xD || v22 == 0)
      goto LABEL_193;
    *((_QWORD *)v15 - 1) = v14;
    v15[1] = v21;
    *(_QWORD *)&v151 = v19;
    v24 = *(_QWORD *)(v12 + 8 * v14);
    DWORD2(v151) = v24;
    if (v21 == 7)
    {
      *(_QWORD *)&v152 = v19 + 4;
      if (v24 < 8uLL)
      {
        if (v24 >= 5uLL)
        {
          DWORD2(v152) = 0;
          __memcpy_chk();
          v17 = count;
        }
      }
      else
      {
        DWORD2(v152) = *((_DWORD *)v19 + 1);
      }
      v25 = 4;
    }
    else
    {
      *(_QWORD *)&v152 = v19 + 1;
      if (v24 < 5uLL)
      {
        if (v24 >= 2uLL)
        {
          DWORD2(v152) = 0;
          __memcpy_chk();
          v17 = count;
        }
      }
      else
      {
        DWORD2(v152) = *(_DWORD *)(v19 + 1);
      }
      v25 = 1;
    }
    v26 = bswap32(DWORD2(v152));
    DWORD2(v152) = v26;
    BYTE12(v152) = 0;
    if (!(v26 >> 19))
      goto LABEL_196;
    v27 = &v19[v25];
    v28 = __clz(v26);
    v29 = v28 + 1;
    v30 = v26 << (v28 + 1) >> -(char)v28;
    if (!v28)
      v30 = 0;
    *v15 = v30 + ~(-1 << v28);
    v31 = v29 + v28;
    v32 = &v27[(v29 + v28) >> 3];
    v33 = (_DWORD)v19 + v24 - (_DWORD)v32;
    if (v33 <= 3)
    {
      v34 = v31 & 7;
      if (v33 <= 0)
        v35 = v32;
      else
        v35 = v32 + 1;
      v36 = v33 - (v33 > 0);
      if (v36 > 0)
        ++v35;
      v37 = v36 - (v36 > 0);
      v38 = v37 <= 0;
      v39 = v37 & (v37 >> 31);
      v40 = v38 ? v35 : v35 + 1;
      if (v39 | v34 && v40 == v32)
        goto LABEL_196;
    }
    if (v21 == 13)
    {
      ++v145;
      goto LABEL_166;
    }
    if (v21 == 8)
    {
      ++v144;
      goto LABEL_166;
    }
    if (v21 != 7)
      goto LABEL_166;
    v148 = 0;
    v149 = 0;
    v183 = 0u;
    v184 = 0u;
    v181 = 0u;
    v182 = 0u;
    v179 = 0u;
    v180 = 0u;
    v177 = 0u;
    v178 = 0u;
    v175 = 0u;
    v176 = 0u;
    v173 = 0u;
    v174 = 0u;
    v171 = 0u;
    v172 = 0u;
    v169 = 0u;
    v170 = 0u;
    v167 = 0u;
    v168 = 0u;
    v165 = 0u;
    v166 = 0u;
    v163 = 0u;
    v164 = 0u;
    v161 = 0u;
    v162 = 0u;
    v159 = 0u;
    v160 = 0u;
    v158 = 0u;
    v156 = 0u;
    v157 = 0u;
    v154 = 0u;
    v155 = 0u;
    *(_OWORD *)bytes = 0u;
    v42 = RemoveEmulation3Byte((const UInt8 *)v19, v24, &theData);
    if ((_DWORD)v42)
      goto LABEL_198;
    v43 = theData;
    if (theData)
    {
      *(_QWORD *)&v151 = CFDataGetBytePtr(theData);
      Length = CFDataGetLength(v43);
      v45 = (_DWORD *)v151;
    }
    else
    {
      v45 = *(_DWORD **)(a3 + 8 * v14);
      *(_QWORD *)&v151 = v45;
      Length = *(_DWORD *)(v12 + 8 * v14);
    }
    DWORD2(v151) = Length;
    *(_QWORD *)&v152 = v45;
    if (Length < 4uLL)
    {
      if (Length)
      {
        DWORD2(v152) = 0;
        __memcpy_chk();
      }
    }
    else
    {
      DWORD2(v152) = *v45;
    }
    DWORD2(v152) = bswap32(DWORD2(v152));
    BYTE12(v152) = 0;
    if (PullParamSetSPS((uint64_t)&v151, (char *)bytes))
    {
      v46 = 0;
      v47 = 0;
      v148 = 0;
      v149 = 0;
    }
    else
    {
      FigH264Bridge_GetWidthAndHeightFromParsedSPS((uint64_t)bytes, &v149, &v148);
      v46 = v148;
      v47 = v149;
    }
    if (v139 && v139 != v47 || v140 && v140 != v46)
      v135 = 0;
    v48 = (unsigned __int8 *)v151;
    *(_QWORD *)&v152 = v151;
    v49 = DWORD2(v151);
    if (DWORD2(v151) < 4)
    {
      if (DWORD2(v151))
      {
        DWORD2(v152) = 0;
        v50 = v47;
        v51 = v12;
        v52 = v43;
        v53 = v46;
        __memcpy_chk();
        v46 = v53;
        v43 = v52;
        v12 = v51;
        v47 = v50;
      }
    }
    else
    {
      DWORD2(v152) = *(_DWORD *)v151;
    }
    DWORD2(v152) = bswap32(DWORD2(v152));
    BYTE12(v152) = 0;
    if (v49 - 1 < 4)
      goto LABEL_196;
    v54 = (unsigned int *)(v48 + 4);
    if ((v49 - 6) > 0xFFFFFFFB)
    {
      v55 = v48[2];
      v56 = v48[3];
      v58 = v48[4] << 24;
      goto LABEL_83;
    }
    v55 = v48[2];
    if ((v49 - 7) > 0xFFFFFFFB)
    {
      v56 = v48[3];
      v57 = (v48[4] << 16) | (v48[5] << 8);
      goto LABEL_81;
    }
    v56 = v48[3];
    if ((v49 & 0xFFFFFFFC) == 4)
    {
      v57 = (v48[4] << 16) | (v48[5] << 8) | v48[6];
LABEL_81:
      v58 = v57 << 8;
      goto LABEL_83;
    }
    v58 = bswap32(*v54);
LABEL_83:
    if (v58 < 0x80000)
      goto LABEL_196;
    v59 = (_DWORD)v48 + v49;
    v60 = v48[1];
    v61 = __clz(v58);
    v62 = (unsigned __int8 *)v54 + (v61 >> 2);
    v63 = (_DWORD)v48 + v49 - (_DWORD)v62;
    if (v63 < 4)
    {
      if (v63 < 1)
        goto LABEL_196;
      v65 = *v62;
      if (v63 == 1)
      {
        v64 = v65 << 24;
      }
      else
      {
        v66 = (v65 << 16) | (v62[1] << 8);
        if (v63 != 2)
          v66 |= v62[2];
        v64 = v66 << 8;
      }
    }
    else
    {
      v64 = bswap32(*(_DWORD *)v62);
    }
    if (v60 <= SHIDWORD(v143))
      v67 = HIDWORD(v143);
    else
      v67 = v48[1];
    v68 = v143;
    if (v56 > (int)v143)
      v68 = v56;
    v143 = __PAIR64__(v67, v68);
    if ((v60 - 100) <= 0x2C && ((1 << (v60 - 100)) & 0x100000400401) != 0)
    {
      v69 = (2 * (v61 & 3)) | 1;
      v70 = v64 << ((2 * (v61 & 3)) | 1);
      if (v70 < 0x80000)
        goto LABEL_196;
      v71 = __clz(v70);
      v72 = v70 << (v71 + 1) >> -(char)v71;
      if (v71)
        v73 = v72;
      else
        v73 = 0;
      v74 = v71 + v69 + v71 + 1;
      v75 = v74 >> 3;
      v76 = v74 & 7;
      v77 = &v62[v75];
      v78 = v59 - (_DWORD)v77;
      if (v59 - (int)v77 < 4)
      {
        if (v78 < 1)
        {
          v79 = v76 | v78;
          if (v79)
            goto LABEL_196;
        }
        else
        {
          v80 = *v77;
          if (v78 == 1)
          {
            v79 = v80 << 24;
          }
          else
          {
            v81 = (v80 << 16) | (v77[1] << 8);
            if (v78 != 2)
              v81 |= v77[2];
            v79 = v81 << 8;
          }
        }
      }
      else
      {
        v79 = bswap32(*(_DWORD *)v77);
      }
      v82 = v73 + ~(-1 << v71);
      if (v82 == 3)
      {
        v83 = v76 + 1;
        v84 = v83 >> 3;
        v76 = v83 & 7;
        v77 += v84;
        v85 = v59 - (_DWORD)v77;
        if (v59 - (int)v77 < 4)
        {
          if (v85 < 1)
          {
            v86 = v76 | v85;
            if (v86)
              goto LABEL_196;
          }
          else
          {
            v88 = *v77;
            if (v85 == 1)
            {
              v86 = v88 << 24;
            }
            else
            {
              v89 = (v88 << 16) | (v77[1] << 8);
              if (v85 != 2)
                v89 |= v77[2];
              v86 = v89 << 8;
            }
          }
        }
        else
        {
          v86 = bswap32(*(_DWORD *)v77);
        }
        v87 = v86 << v76;
      }
      else
      {
        v87 = v79 << v76;
      }
      if (v87 < 0x80000)
        goto LABEL_196;
      v90 = __clz(v87);
      v91 = v87 << (v90 + 1) >> -(char)v90;
      if (!v90)
        v91 = 0;
      v92 = v90 + v76 + v90 + 1;
      v93 = v92 >> 3;
      v94 = v92 & 7;
      v95 = &v77[v93];
      v96 = v59 - (_DWORD)v95;
      if (v59 - (int)v95 < 4)
      {
        if (v96 < 1)
        {
          v97 = v94 | v96;
          if (v97)
            goto LABEL_196;
        }
        else
        {
          v98 = *v95;
          if (v96 == 1)
          {
            v97 = v98 << 24;
          }
          else
          {
            v99 = (v98 << 16) | (v95[1] << 8);
            if (v96 != 2)
              v99 |= v95[2];
            v97 = v99 << 8;
          }
        }
      }
      else
      {
        v97 = bswap32(*(_DWORD *)v95);
      }
      v100 = v97 << v94;
      if ((v97 << v94) < 0x80000)
        goto LABEL_196;
      v101 = __clz(v100);
      v102 = v100 << (v101 + 1) >> -(char)v101;
      if (!v101)
        v102 = 0;
      v103 = v101 + v94 + v101 + 1;
      v104 = &v95[v103 >> 3];
      v105 = v59 - (_DWORD)v104;
      if (v105 <= 3)
      {
        v106 = v103 & 7;
        if (v105 <= 0)
          v107 = v104;
        else
          v107 = v104 + 1;
        v108 = v105 - (v105 > 0);
        if (v108 > 0)
          ++v107;
        v109 = v108 - (v108 > 0);
        v110 = v109 & (v109 >> 31);
        v111 = v109 <= 0 ? v107 : v107 + 1;
        if (v110 | v106 && v111 == v104)
        {
LABEL_196:
          v126 = 4294954582;
          goto LABEL_197;
        }
      }
      v112 = v138;
      if (v138 == -1)
      {
        v112 = v82;
      }
      else if (v138 != v82)
      {
        goto LABEL_193;
      }
      v138 = v112;
      v113 = v137;
      if (v137 == -1)
      {
        v113 = v91 + ~(-1 << v90);
        v114 = v136;
      }
      else
      {
        v114 = v136;
        if (v137 != v91 + ~(-1 << v90))
          goto LABEL_193;
      }
      v137 = v113;
      if (v114 == -1)
      {
        v136 = v102 + ~(-1 << v101);
        if (!v43)
          goto LABEL_165;
LABEL_164:
        v115 = v43;
        v116 = v47;
        v117 = v46;
        CFRelease(v115);
        v46 = v117;
        v47 = v116;
        theData = 0;
        goto LABEL_165;
      }
      if (v114 != v102 + ~(-1 << v101))
        goto LABEL_193;
    }
    if (v43)
      goto LABEL_164;
LABEL_165:
    ++v142;
    v141 &= v55;
    v139 = v47;
    v140 = v46;
    v17 = count;
LABEL_166:
    v16 += v18 + 2;
    ++v14;
    v15 += 4;
  }
  while (v17 != v14);
  v118 = v145;
  v119 = v142;
  if (v135)
  {
    if (v130)
      *v130 = v139;
    if (v133)
      *v133 = v140;
  }
  if (!v142)
  {
LABEL_193:
    v126 = 4294954584;
LABEL_197:
    v42 = FigSignalErrorAt(v126, 0, 0, 0, 0, 0, 0);
LABEL_198:
    v125 = v42;
    v120 = __base;
    goto LABEL_199;
  }
  v120 = __base;
  if (!v144)
    goto LABEL_203;
  v121 = HIDWORD(v143) - 100;
  if ((HIDWORD(v143) - 100) > 0x2C || ((1 << v121) & 0x100000400401) == 0)
  {
    v119 = v142 + v145;
    v118 = 0;
  }
  if (v119 >= 0x20 || v144 >= 0x100 || v118 >= 0x100)
  {
LABEL_203:
    v129 = 4294954584;
LABEL_204:
    v125 = FigSignalErrorAt(v129, 0, 0, 0, 0, 0, 0);
    goto LABEL_199;
  }
  qsort(__base, v17, 0x10uLL, (int (__cdecl *)(const void *, const void *))FigH264Bridge_sortParameterSets);
  if (v121 <= 0x2C && ((1 << v121) & 0x100000400401) != 0)
    v16 += 4;
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v16);
  if (!Mutable)
  {
    v129 = 4294954583;
    goto LABEL_204;
  }
  v123 = Mutable;
  bytes[0] = 1;
  bytes[1] = BYTE4(v143);
  bytes[2] = v141;
  bytes[3] = v143;
  bytes[4] = (v131 - 1) | 0xFC;
  bytes[5] = v119 | 0xE0;
  CFDataAppendBytes(Mutable, bytes, 6);
  if (v118)
    v124 = 0;
  else
    v124 = 13;
  FigH264Bridge_addSortedParameterSetsToData(v123, count, (uint64_t *)__base, a3, v12, 7, v124);
  bytes[0] = v144;
  CFDataAppendBytes(v123, bytes, 1);
  FigH264Bridge_addSortedParameterSetsToData(v123, count, (uint64_t *)__base, a3, v12, 8, 0);
  if (v121 <= 0x2C && ((1 << v121) & 0x100000400401) != 0)
  {
    bytes[0] = v138 | 0xFC;
    bytes[1] = v137 | 0xF8;
    bytes[2] = v136 | 0xF8;
    bytes[3] = v118;
    CFDataAppendBytes(v123, bytes, 4);
    FigH264Bridge_addSortedParameterSetsToData(v123, count, (uint64_t *)__base, a3, v12, 13, 0);
  }
  v125 = 0;
  *v132 = v123;
LABEL_199:
  if (theData)
    CFRelease(theData);
  free(v120);
  return v125;
}

uint64_t FigH264Bridge_sortParameterSets(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  _BOOL4 v8;

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a2 + 8);
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  if (v2 > v3)
    return 1;
  v5 = *(_DWORD *)(a1 + 12);
  v6 = *(_DWORD *)(a2 + 12);
  v7 = v5 >= v6;
  v8 = v5 > v6;
  if (v7)
    return v8;
  else
    return 0xFFFFFFFFLL;
}

void FigH264Bridge_addSortedParameterSetsToData(CFMutableDataRef theData, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  uint64_t v12;
  int v14;
  uint64_t v16;
  UInt8 bytes[2];

  if (a2)
  {
    v12 = a2;
    do
    {
      v14 = *((_DWORD *)a3 + 3);
      if (v14 == a6 || v14 == a7)
      {
        v16 = *a3;
        *(_WORD *)bytes = bswap32(*(unsigned __int16 *)(a5 + 8 * *a3)) >> 16;
        CFDataAppendBytes(theData, bytes, 2);
        CFDataAppendBytes(theData, *(const UInt8 **)(a4 + 8 * v16), *(_QWORD *)(a5 + 8 * v16));
      }
      a3 += 2;
      --v12;
    }
    while (v12);
  }
}

uint64_t FigH264Bridge_CreateAVCCFromSPSAndPPS(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, __CFData **a7)
{
  _QWORD v8[2];
  _QWORD v9[3];

  v9[2] = *MEMORY[0x1E0C80C00];
  v9[0] = a2;
  v9[1] = a4;
  v8[0] = a3;
  v8[1] = a5;
  return FigH264Bridge_CreateAVCCFromH264ParameterSets(a1, 2uLL, (uint64_t)v9, (uint64_t)v8, a6, 0, 0, a7);
}

uint64_t FigH264Bridge_GetSPS_VUI_FullRangeVideo(const UInt8 *a1, unint64_t a2, _BYTE *a3)
{
  unsigned int Length;
  const UInt8 *BytePtr;
  uint64_t v6;
  const __CFData *v7;
  unsigned int v8;
  uint64_t v9;
  CFDataRef theData;
  const UInt8 *v12;
  uint64_t v13;
  const UInt8 *v14;
  uint64_t v15;
  _OWORD v16[22];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;

  Length = a2;
  BytePtr = a1;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  memset(v16, 0, sizeof(v16));
  v13 = 0;
  v14 = 0;
  v15 = 0;
  theData = 0;
  v6 = RemoveEmulation3Byte(a1, a2, &theData);
  if ((_DWORD)v6)
    return v6;
  v7 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(v7);
  }
  v12 = BytePtr;
  LODWORD(v13) = Length;
  v14 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v15) = 0;
      __memcpy_chk();
      v8 = v15;
    }
    else
    {
      v8 = 0;
    }
  }
  else
  {
    v8 = *(_DWORD *)BytePtr;
  }
  LODWORD(v15) = bswap32(v8);
  BYTE4(v15) = 0;
  v9 = PullParamSetSPS((uint64_t)&v12, (char *)v16);
  if (v7)
    CFRelease(v7);
  if (!(_DWORD)v9)
  {
    if (HIDWORD(v17))
    {
      v9 = 0;
      *a3 = v20;
    }
    else
    {
      return 4294954584;
    }
  }
  return v9;
}

uint64_t FigH264Bridge_GetPPSSequenceID(const UInt8 *a1, unint64_t a2, _DWORD *a3, _DWORD *a4)
{
  const UInt8 *BytePtr;
  int Length;
  uint64_t v8;
  const __CFData *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  unsigned __int8 *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned __int8 *v27;
  int v28;
  int v29;
  unsigned __int8 *v30;
  int v31;
  int v32;
  BOOL v33;
  int v34;
  unsigned __int8 *v35;
  uint64_t v37;
  CFDataRef theData;
  __int128 v40;
  __int128 v41;

  v40 = 0u;
  v41 = 0u;
  theData = 0;
  if (!a1)
    return 4294954584;
  BytePtr = a1;
  if ((*a1 & 0x1F) != 8)
    return 4294954584;
  Length = a2;
  v8 = RemoveEmulation3Byte(a1, a2, &theData);
  v9 = theData;
  if ((_DWORD)v8)
    goto LABEL_44;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(v9);
  }
  v10 = (unsigned int *)(BytePtr + 1);
  *(_QWORD *)&v40 = BytePtr + 1;
  DWORD2(v40) = Length - 1;
  *(_QWORD *)&v41 = BytePtr + 1;
  if ((Length - 1) < 4)
  {
    if (Length == 1)
    {
      v11 = 0;
    }
    else
    {
      DWORD2(v41) = 0;
      __memcpy_chk();
      v11 = DWORD2(v41);
    }
  }
  else
  {
    v11 = *v10;
  }
  v12 = bswap32(v11);
  DWORD2(v41) = v12;
  BYTE12(v41) = 0;
  if (!(v12 >> 19))
    goto LABEL_43;
  v13 = (_DWORD)BytePtr + Length;
  v14 = __clz(v12);
  v15 = v12 << (v14 + 1) >> -(char)v14;
  if (!v14)
    v15 = 0;
  v16 = v14 + 1 + v14;
  v17 = v16 & 7;
  v18 = (unsigned __int8 *)v10 + (v16 >> 3);
  v19 = v13 - (_DWORD)v18;
  if (v13 - (int)v18 >= 4)
  {
    v20 = bswap32(*(_DWORD *)v18);
    goto LABEL_24;
  }
  if (v19 < 1)
  {
    v20 = v17 | v19;
    if (!v20)
      goto LABEL_24;
LABEL_43:
    v8 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_44:
    v37 = v8;
    if (!v9)
      return v37;
    goto LABEL_41;
  }
  v21 = *v18;
  if (v19 == 1)
  {
    v20 = v21 << 24;
  }
  else
  {
    v22 = (v21 << 16) | (v18[1] << 8);
    if (v19 != 2)
      v22 |= v18[2];
    v20 = v22 << 8;
  }
LABEL_24:
  v23 = v20 << v17;
  if (!((v20 << v17) >> 19))
    goto LABEL_43;
  v24 = __clz(v23);
  v25 = v23 << (v24 + 1) >> -(char)v24;
  if (!v24)
    v25 = 0;
  v26 = v24 + v17 + v24 + 1;
  v27 = &v18[v26 >> 3];
  v28 = v13 - (_DWORD)v27;
  if (v28 <= 3)
  {
    v29 = v26 & 7;
    if (v28 <= 0)
      v30 = v27;
    else
      v30 = v27 + 1;
    v31 = v28 - (v28 > 0);
    if (v31 > 0)
      ++v30;
    v32 = v31 - (v31 > 0);
    v33 = v32 <= 0;
    v34 = v32 & (v32 >> 31);
    v35 = v33 ? v30 : v30 + 1;
    if (v34 | v29 && v35 == v27)
      goto LABEL_43;
  }
  v37 = 0;
  *a3 = v25 + ~(-1 << v24);
  *a4 = v15 + ~(-1 << v14);
  if (v9)
LABEL_41:
    CFRelease(v9);
  return v37;
}

uint64_t FigH264Bridge_CopyStandaloneSPSData(const UInt8 *a1, unint64_t a2, CFDataRef *a3)
{
  unsigned int Length;
  const UInt8 *BytePtr;
  uint64_t v6;
  const __CFData *v7;
  unsigned int v8;
  uint64_t v9;
  __int128 v11;
  __int128 v12;
  CFDataRef theData;
  const UInt8 *v14;
  uint64_t v15;
  const UInt8 *v16;
  uint64_t v17;
  _OWORD v18[18];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;

  Length = a2;
  BytePtr = a1;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  memset(v18, 0, sizeof(v18));
  v15 = 0;
  v16 = 0;
  v17 = 0;
  theData = 0;
  v11 = 0u;
  v12 = 0u;
  v6 = RemoveEmulation3Byte(a1, a2, &theData);
  if ((_DWORD)v6)
    return v6;
  v7 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(v7);
  }
  v14 = BytePtr;
  LODWORD(v15) = Length;
  v16 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      LODWORD(v17) = 0;
      __memcpy_chk();
      v8 = v17;
    }
    else
    {
      v8 = 0;
    }
  }
  else
  {
    v8 = *(_DWORD *)BytePtr;
  }
  LODWORD(v17) = bswap32(v8);
  BYTE4(v17) = 0;
  v9 = PullParamSetSPS((uint64_t)&v14, (char *)v18);
  if (v7)
    CFRelease(v7);
  if (!(_DWORD)v9)
  {
    v11 = v19;
    LODWORD(v12) = DWORD2(v20);
    *(_QWORD *)((char *)&v12 + 4) = *(_QWORD *)((char *)&v21 + 4);
    HIDWORD(v12) = HIDWORD(v21);
    *a3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)&v11, 32);
  }
  return v9;
}

uint64_t FigH264Bridge_CopyStandalonePPSData(const UInt8 *BytePtr, unint64_t a2, CFDataRef *a3)
{
  uint64_t v6;
  const __CFData *v7;
  unsigned int v8;
  uint64_t v9;
  int32x2_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  __int128 v17;
  int v18;
  int v19;
  int v20;
  char v21;
  __CFData *v22;
  const UInt8 *v23;
  uint64_t v24;
  const UInt8 *v25;
  uint64_t v26;
  _OWORD v27[3];
  __int128 v28;
  _OWORD v29[2];

  v28 = 0u;
  memset(v29, 0, 24);
  memset(v27, 0, sizeof(v27));
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v22 = 0;
  bzero(&v11, 0x414uLL);
  v6 = RemoveEmulation3Byte(BytePtr, a2, &v22);
  if ((_DWORD)v6)
    return v6;
  v7 = v22;
  if (v22)
  {
    BytePtr = CFDataGetBytePtr(v22);
    LODWORD(a2) = CFDataGetLength(v7);
  }
  v23 = BytePtr;
  LODWORD(v24) = a2;
  v25 = BytePtr;
  if (a2 < 4)
  {
    if ((_DWORD)a2)
    {
      LODWORD(v26) = 0;
      __memcpy_chk();
      v8 = v26;
    }
    else
    {
      v8 = 0;
    }
  }
  else
  {
    v8 = *(_DWORD *)BytePtr;
  }
  LODWORD(v26) = bswap32(v8);
  BYTE4(v26) = 0;
  v9 = PullParamSetPPS((uint64_t *)&v23, (uint64_t)v27);
  if (v7)
    CFRelease(v7);
  if (!(_DWORD)v9)
  {
    v11 = vrev64_s32(*(int32x2_t *)&v27[0]);
    v12 = BYTE8(v27[0]);
    v13 = BYTE9(v27[0]);
    v14 = *(_QWORD *)((char *)v27 + 12);
    v15 = *((_QWORD *)&v28 + 1);
    v16 = LOBYTE(v29[0]);
    v17 = *(_OWORD *)((char *)v29 + 4);
    v18 = BYTE4(v29[1]);
    v19 = BYTE5(v29[1]);
    v20 = BYTE6(v29[1]);
    v21 = 1;
    *a3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)&v11, 1044);
  }
  return v9;
}

uint64_t PullParamSetPPS(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  unsigned __int8 *v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  uint64_t v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  unsigned int v61;
  char v62;
  unsigned int v63;
  uint64_t v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  unsigned int v70;
  uint64_t v71;
  unsigned __int8 *v72;
  int v73;
  unsigned int v74;
  int v75;
  unsigned int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  unsigned int v83;
  int v84;
  int v85;
  unsigned int v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  int v91;
  int v92;
  int v93;
  uint64_t v94;
  int v95;
  unsigned int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  unsigned int v102;
  int v103;
  int v104;
  int v105;
  unsigned int v106;
  int v107;
  int v108;
  int v109;
  double v110;
  unsigned int v111;
  unsigned int v112;
  unsigned int v113;
  int v114;
  unsigned __int8 *v115;
  int v116;
  int v117;
  int v118;
  unsigned int v119;
  int v120;
  int v121;
  int v122;
  uint64_t v123;
  int v124;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127;
  unsigned int v128;
  int v129;
  unsigned int v130;
  int v131;
  int v132;
  unsigned int v133;
  unsigned int v134;
  unsigned int v135;
  unsigned int v136;
  int v137;
  int v138;
  int v139;
  unsigned int v140;
  unsigned int v141;
  unsigned int v142;
  unsigned int v143;
  int v144;
  int v145;
  int v146;
  uint64_t v147;
  int v148;
  int v149;
  int v150;
  unsigned int v151;
  uint64_t v152;
  int v153;
  int v154;
  int v155;
  unsigned int v156;
  unsigned int v157;
  unsigned int v158;
  int v159;
  int v160;
  int v161;
  unsigned int v162;
  unsigned int v163;
  unsigned int v164;
  unsigned int v165;
  int v166;
  int v167;
  int v168;
  unsigned int v169;
  unsigned int v170;
  unsigned int v171;
  unsigned int v172;
  int v173;
  int v174;
  int v175;
  unsigned int v176;
  uint64_t v177;
  int v178;
  int v179;
  int v180;
  uint64_t v181;
  int v182;
  int v183;
  int v184;
  uint64_t v185;
  int v186;
  int v187;
  int v188;

  v4 = a1[2];
  v5 = *((_DWORD *)a1 + 6);
  v6 = *((unsigned __int8 *)a1 + 28);
  v7 = *((_DWORD *)a1 + 2);
  v8 = *a1;
  *(_QWORD *)(a2 + 80) = 0;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  v9 = v6 + 1;
  v10 = (v6 + 1) & 7;
  v11 = (unsigned __int8 *)(v4 + (v9 >> 3));
  v12 = v8 + v7;
  v13 = v8 + v7 - (_DWORD)v11;
  if (v13 < 4)
  {
    if (v13 < 1)
    {
      v16 = 0;
      if (v10 | v13)
      {
        LOBYTE(v21) = v10;
        goto LABEL_242;
      }
      v14 = 0;
    }
    else
    {
      v15 = *v11;
      if (v13 == 1)
      {
        v14 = v15 << 24;
      }
      else
      {
        v17 = (v15 << 16) | (v11[1] << 8);
        if (v13 != 2)
          v17 |= v11[2];
        v14 = v17 << 8;
      }
    }
  }
  else
  {
    v14 = bswap32(*(_DWORD *)v11);
  }
  v18 = (v10 + 2) & 7;
  v11 += (v10 + 2) >> 3;
  v19 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v19 < 1)
    {
      v16 = 0;
      if (v18 | v19)
      {
        LOBYTE(v21) = (v10 + 2) & 7;
        goto LABEL_242;
      }
    }
    else
    {
      v20 = *v11;
      if (v19 == 1)
      {
        v16 = v20 << 24;
      }
      else
      {
        v22 = (v20 << 16) | (v11[1] << 8);
        if (v19 != 2)
          v22 |= v11[2];
        v16 = v22 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  v21 = (v18 + 5) & 7;
  v11 += (v18 + 5) >> 3;
  v23 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v23 < 1)
    {
      v24 = 0;
      if (v21 | v23)
      {
        v16 = 0;
        goto LABEL_242;
      }
      if (v5 < 0)
        goto LABEL_385;
    }
    else
    {
      v25 = *v11;
      if (v23 == 1)
      {
        v24 = v25 << 24;
        if (v5 < 0)
          goto LABEL_385;
      }
      else
      {
        v32 = (v25 << 16) | (v11[1] << 8);
        if (v23 != 2)
          v32 |= v11[2];
        v24 = v32 << 8;
        if (v5 < 0)
          goto LABEL_385;
      }
    }
  }
  else
  {
    v24 = bswap32(*(_DWORD *)v11);
    if (v5 < 0)
      goto LABEL_385;
  }
  if (!(v14 << v10 >> 30) || v16 << v18 >> 27 != 8)
    goto LABEL_385;
  v16 = v24 << v21;
  if (v24 << v21 < 0x80000)
    goto LABEL_242;
  v26 = __clz(v16);
  v27 = v16 << (v26 + 1) >> -(char)v26;
  if (!v26)
    v27 = 0;
  v28 = v27 + ~(-1 << v26);
  *(_DWORD *)a2 = v28;
  v29 = v26 + v21 + v26 + 1;
  v21 = v29 & 7;
  v11 += v29 >> 3;
  v30 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v30 < 1)
    {
      v16 = 0;
      if (v21 | v30)
        goto LABEL_242;
    }
    else
    {
      v31 = *v11;
      if (v30 == 1)
      {
        v16 = v31 << 24;
      }
      else
      {
        v33 = (v31 << 16) | (v11[1] << 8);
        if (v30 != 2)
          v33 |= v11[2];
        v16 = v33 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  if (v28 >= 0x100)
    goto LABEL_385;
  v16 <<= v21;
  if (v16 < 0x80000)
    goto LABEL_242;
  v34 = __clz(v16);
  v35 = v16 << (v34 + 1) >> -(char)v34;
  if (!v34)
    v35 = 0;
  v36 = v35 + ~(-1 << v34);
  *(_DWORD *)(a2 + 4) = v36;
  v37 = v34 + v21 + v34 + 1;
  v21 = v37 & 7;
  v11 += v37 >> 3;
  v38 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v38 < 1)
    {
      v16 = 0;
      if (v21 | v38)
        goto LABEL_242;
    }
    else
    {
      v39 = *v11;
      if (v38 == 1)
      {
        v16 = v39 << 24;
      }
      else
      {
        v40 = (v39 << 16) | (v11[1] << 8);
        if (v38 != 2)
          v40 |= v11[2];
        v16 = v40 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  if (v36 >= 0x20)
  {
LABEL_385:
    v123 = 4294954582;
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    return v123;
  }
  *(_BYTE *)(a2 + 8) = ((v16 << v21) & 0x80000000) != 0;
  v41 = (v21 + 1) >> 3;
  v21 = (v21 + 1) & 7;
  v11 += v41;
  v42 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v42 < 1)
    {
      v16 = 0;
      if (v21 | v42)
        goto LABEL_242;
    }
    else
    {
      v43 = *v11;
      if (v42 == 1)
      {
        v16 = v43 << 24;
      }
      else
      {
        v44 = (v43 << 16) | (v11[1] << 8);
        if (v42 != 2)
          v44 |= v11[2];
        v16 = v44 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  *(_BYTE *)(a2 + 9) = ((v16 << v21) & 0x80000000) != 0;
  v45 = (v21 + 1) >> 3;
  v21 = (v21 + 1) & 7;
  v11 += v45;
  v46 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v46 < 1)
    {
      v16 = 0;
      if (v21 | v46)
        goto LABEL_242;
    }
    else
    {
      v47 = *v11;
      if (v46 == 1)
      {
        v16 = v47 << 24;
      }
      else
      {
        v48 = (v47 << 16) | (v11[1] << 8);
        if (v46 != 2)
          v48 |= v11[2];
        v16 = v48 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  v49 = v16 << v21;
  if (v16 << v21 >= 0x80000)
  {
    v50 = __clz(v49);
    v51 = v49 << (v50 + 1) >> -(char)v50;
    if (!v50)
      v51 = 0;
    v52 = v51 + ~(-1 << v50);
    *(_DWORD *)(a2 + 12) = v52;
    v53 = v50 + v21 + v50 + 1;
    v21 = v53 & 7;
    v11 += v53 >> 3;
    v54 = v12 - (_DWORD)v11;
    if (v12 - (int)v11 < 4)
    {
      if (v54 < 1)
      {
        v16 = 0;
        if (v21 | v54)
          goto LABEL_242;
      }
      else
      {
        v57 = *v11;
        if (v54 == 1)
        {
          v16 = v57 << 24;
        }
        else
        {
          v59 = (v57 << 16) | (v11[1] << 8);
          if (v54 != 2)
            v59 |= v11[2];
          v16 = v59 << 8;
        }
      }
    }
    else
    {
      v16 = bswap32(*(_DWORD *)v11);
    }
    v16 <<= v21;
    if (!v52)
      goto LABEL_261;
LABEL_157:
    if (v16 < 0x80000)
      goto LABEL_242;
    v87 = __clz(v16);
    v88 = v16 << (v87 + 1) >> -(char)v87;
    if (!v87)
      v88 = 0;
    v89 = v88 + ~(-1 << v87);
    *(_DWORD *)(a2 + 16) = v89;
    v90 = v87 + v21 + v87 + 1;
    v21 = v90 & 7;
    v11 += v90 >> 3;
    v91 = v12 - (_DWORD)v11;
    if (v12 - (int)v11 < 4)
    {
      if (v91 < 1)
      {
        v16 = 0;
        if (v21 | v91)
          goto LABEL_242;
      }
      else
      {
        v92 = *v11;
        if (v91 == 1)
        {
          v16 = v92 << 24;
        }
        else
        {
          v93 = (v92 << 16) | (v11[1] << 8);
          if (v91 != 2)
            v93 |= v11[2];
          v16 = v93 << 8;
        }
      }
    }
    else
    {
      v16 = bswap32(*(_DWORD *)v11);
    }
    v16 <<= v21;
    switch(v89)
    {
      case 0u:
        while (v16 >= 0x80000)
        {
          v96 = v21 + 2 * __clz(v16) + 1;
          v21 = v96 & 7;
          v11 += v96 >> 3;
          v97 = v12 - (_DWORD)v11;
          if (v12 - (int)v11 < 4)
          {
            if (v97 < 1)
            {
              v16 = 0;
              if (v21 | v97)
                goto LABEL_242;
            }
            else
            {
              v98 = *v11;
              if (v97 == 1)
              {
                v16 = v98 << 24;
              }
              else
              {
                v99 = (v98 << 16) | (v11[1] << 8);
                if (v97 != 2)
                  v99 |= v11[2];
                v16 = v99 << 8;
              }
            }
          }
          else
          {
            v16 = bswap32(*(_DWORD *)v11);
          }
          v16 <<= v21;
          if (++v89 > v52)
            goto LABEL_261;
        }
        goto LABEL_242;
      case 2u:
        v101 = 0;
        while (v16 >= 0x80000)
        {
          v102 = v21 + 2 * __clz(v16) + 1;
          v21 = v102 & 7;
          v11 += v102 >> 3;
          v103 = v12 - (_DWORD)v11;
          if (v12 - (int)v11 < 4)
          {
            if (v103 < 1)
            {
              v16 = 0;
              if (v21 | v103)
                goto LABEL_242;
            }
            else
            {
              v104 = *v11;
              if (v103 == 1)
              {
                v16 = v104 << 24;
              }
              else
              {
                v105 = (v104 << 16) | (v11[1] << 8);
                if (v103 != 2)
                  v105 |= v11[2];
                v16 = v105 << 8;
              }
            }
          }
          else
          {
            v16 = bswap32(*(_DWORD *)v11);
          }
          v16 <<= v21;
          if (v16 < 0x80000)
            break;
          v106 = v21 + 2 * __clz(v16) + 1;
          v21 = v106 & 7;
          v11 += v106 >> 3;
          v107 = v12 - (_DWORD)v11;
          if (v12 - (int)v11 < 4)
          {
            if (v107 < 1)
            {
              v16 = 0;
              if (v21 | v107)
                goto LABEL_242;
            }
            else
            {
              v108 = *v11;
              if (v107 == 1)
              {
                v16 = v108 << 24;
              }
              else
              {
                v109 = (v108 << 16) | (v11[1] << 8);
                if (v107 != 2)
                  v109 |= v11[2];
                v16 = v109 << 8;
              }
            }
          }
          else
          {
            v16 = bswap32(*(_DWORD *)v11);
          }
          v16 <<= v21;
          if (++v101 > v52)
            goto LABEL_261;
        }
        goto LABEL_242;
      case 3u:
      case 4u:
      case 5u:
        v94 = (v21 + 1) >> 3;
        v21 = (v21 + 1) & 7;
        v11 += v94;
        v95 = v12 - (_DWORD)v11;
        if (v12 - (int)v11 < 4)
        {
          if (v95 < 1)
          {
            v16 = 0;
            if (v21 | v95)
              goto LABEL_242;
          }
          else
          {
            v100 = *v11;
            if (v95 == 1)
            {
              v16 = v100 << 24;
            }
            else
            {
              v118 = (v100 << 16) | (v11[1] << 8);
              if (v95 != 2)
                v118 |= v11[2];
              v16 = v118 << 8;
            }
          }
        }
        else
        {
          v16 = bswap32(*(_DWORD *)v11);
        }
        v16 <<= v21;
        if (v16 < 0x80000)
          goto LABEL_242;
        v119 = v21 + 2 * __clz(v16) + 1;
        v21 = v119 & 7;
        v11 += v119 >> 3;
        v120 = v12 - (_DWORD)v11;
        if (v12 - (int)v11 < 4)
        {
          if (v120 < 1)
          {
            v16 = 0;
            if (v21 | v120)
              goto LABEL_242;
          }
          else
          {
            v121 = *v11;
            if (v120 == 1)
            {
              v16 = v121 << 24;
            }
            else
            {
              v122 = (v121 << 16) | (v11[1] << 8);
              if (v120 != 2)
                v122 |= v11[2];
              v16 = v122 << 8;
            }
          }
        }
        else
        {
          v16 = bswap32(*(_DWORD *)v11);
        }
        v16 <<= v21;
        goto LABEL_261;
      case 6u:
        v110 = log2((double)(v52 + 1));
        if (v16 < 0x80000)
          goto LABEL_242;
        v111 = __clz(v16);
        if (v111)
          v112 = v16 << (v111 + 1) >> -(char)v111;
        else
          v112 = 0;
        v113 = v111 + v21 + v111 + 1;
        v114 = v113 & 7;
        v115 = &v11[v113 >> 3];
        v116 = v12 - (_DWORD)v115;
        if (v12 - (int)v115 < 4)
        {
          if (v116 < 1)
          {
            v16 = 0;
            if (v114 | v116)
            {
LABEL_241:
              LOBYTE(v21) = v114;
              v11 = v115;
              goto LABEL_242;
            }
          }
          else
          {
            v117 = *v115;
            if (v116 == 1)
            {
              v16 = v117 << 24;
            }
            else
            {
              v124 = (v117 << 16) | (v115[1] << 8);
              if (v116 != 2)
                v124 |= v115[2];
              v16 = v124 << 8;
            }
          }
        }
        else
        {
          v16 = bswap32(*(_DWORD *)v115);
        }
        v125 = 0;
        v126 = vcvtpd_s64_f64(v110);
        v127 = v112 + ~(-1 << v111);
        v16 <<= v114;
        v11 = v115;
        v21 = v114;
        break;
      default:
        goto LABEL_261;
    }
    do
    {
      if (v126 - 26 < 0xFFFFFFE7)
        goto LABEL_241;
      v128 = v21 + v126;
      v21 = (v21 + v126) & 7;
      v11 += v128 >> 3;
      v129 = v12 - (_DWORD)v11;
      if (v12 - (int)v11 < 4)
      {
        if (v129 < 1)
        {
          v130 = 0;
          if (v21 | v129)
          {
            v16 = 0;
            goto LABEL_242;
          }
        }
        else
        {
          v131 = *v11;
          if (v129 == 1)
          {
            v130 = v131 << 24;
          }
          else
          {
            v132 = (v131 << 16) | (v11[1] << 8);
            if (v129 != 2)
              v132 |= v11[2];
            v130 = v132 << 8;
          }
        }
      }
      else
      {
        v130 = bswap32(*(_DWORD *)v11);
      }
      ++v125;
    }
    while (v125 <= v127);
    v16 = v130 << v21;
    goto LABEL_261;
  }
  v55 = (v21 + 1) >> 3;
  v21 = (v21 + 1) & 7;
  v11 += v55;
  v56 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v56 < 1)
    {
      v16 = 0;
      if (v21 | v56)
        goto LABEL_242;
    }
    else
    {
      v58 = *v11;
      if (v56 == 1)
      {
        v16 = v58 << 24;
      }
      else
      {
        v60 = (v58 << 16) | (v11[1] << 8);
        if (v56 != 2)
          v60 |= v11[2];
        v16 = v60 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  v61 = 0;
  v16 <<= v21;
  do
  {
    v62 = v21;
    v63 = v16;
    v64 = (v21 + 1) >> 3;
    v21 = (v21 + 1) & 7;
    v11 += v64;
    v65 = v12 - (_DWORD)v11;
    if (v12 - (int)v11 < 4)
    {
      if (v65 < 1)
      {
        v16 = 0;
        if (v21 | v65)
          goto LABEL_242;
      }
      else
      {
        v66 = *v11;
        if (v65 == 1)
        {
          v16 = v66 << 24;
        }
        else
        {
          v67 = (v66 << 16) | (v11[1] << 8);
          if (v65 != 2)
            v67 |= v11[2];
          v16 = v67 << 8;
        }
      }
    }
    else
    {
      v16 = bswap32(*(_DWORD *)v11);
    }
    v16 <<= v21;
    --v61;
  }
  while ((v63 & 0x80000000) == 0);
  if (v61 < 0xFFFFFFE1)
    goto LABEL_242;
  v68 = -v61;
  v69 = (v62 + 1) & 7;
  v70 = v69 - v61;
  if (-v61 <= 0x18)
  {
    v71 = v70 >> 3;
    v21 = v70 & 7;
    v72 = &v11[v71];
    v73 = v12 - ((_DWORD)v11 + v71);
    if (v73 >= 4)
    {
      v74 = bswap32(*(_DWORD *)v72);
      goto LABEL_140;
    }
    if (v73 >= 1)
    {
      v77 = *v72;
      if (v73 == 1)
      {
        v74 = v77 << 24;
      }
      else
      {
        v79 = (v77 << 16) | (v72[1] << 8);
        if (v73 != 2)
          v79 |= v72[2];
        v74 = v79 << 8;
      }
      goto LABEL_140;
    }
    v74 = 0;
    if (!(v21 | v73))
    {
LABEL_140:
      v80 = v16 >> v61;
      v16 = v74 << v21;
      goto LABEL_156;
    }
    v16 = 0;
LABEL_151:
    v11 = v72;
    goto LABEL_242;
  }
  v21 = v70 & 7;
  v11 += (~v61 + v69 - 15) >> 3;
  v75 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v75 < 1)
    {
      v76 = 0;
      if (v21 | v75)
      {
        v16 = 0;
        goto LABEL_242;
      }
    }
    else
    {
      v78 = *v11;
      if (v75 == 1)
      {
        v76 = v78 << 24;
      }
      else
      {
        v81 = (v78 << 16) | (v11[1] << 8);
        if (v75 != 2)
          v81 |= v11[2];
        v76 = v81 << 8;
      }
    }
  }
  else
  {
    v76 = bswap32(*(_DWORD *)v11);
  }
  v72 = v11 + 2;
  v82 = v12 - ((_DWORD)v11 + 2);
  if (v82 < 4)
  {
    if (v82 < 1)
    {
      v83 = 0;
      if (v21 | v82)
      {
        v16 = 0;
        goto LABEL_151;
      }
    }
    else
    {
      v84 = *v72;
      if (v82 == 1)
      {
        v83 = v84 << 24;
      }
      else
      {
        v85 = (v84 << 16) | (v11[3] << 8);
        if (v82 != 2)
          v85 |= v11[4];
        v83 = v85 << 8;
      }
    }
  }
  else
  {
    v83 = bswap32(*(_DWORD *)v72);
  }
  v86 = v16 >> (v61 + 48);
  v16 = v83 << v21;
  v80 = __PAIR64__(v86, v76 << v21) >> 16;
LABEL_156:
  v52 = v80 + ~(-1 << v68);
  *(_DWORD *)(a2 + 12) = v52;
  v11 = v72;
  if (v52)
    goto LABEL_157;
LABEL_261:
  if (v16 < 0x80000)
    goto LABEL_242;
  v133 = __clz(v16);
  v134 = v16 << (v133 + 1) >> -(char)v133;
  if (!v133)
    v134 = 0;
  v135 = v134 + ~(-1 << v133);
  *(_DWORD *)(a2 + 56) = v135;
  v136 = v133 + v21 + v133 + 1;
  v21 = v136 & 7;
  v11 += v136 >> 3;
  v137 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v137 < 1)
    {
      v16 = 0;
      if (v21 | v137)
        goto LABEL_242;
    }
    else
    {
      v138 = *v11;
      if (v137 == 1)
      {
        v16 = v138 << 24;
      }
      else
      {
        v139 = (v138 << 16) | (v11[1] << 8);
        if (v137 != 2)
          v139 |= v11[2];
        v16 = v139 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  if (v135 >= 0x20)
    goto LABEL_385;
  v16 <<= v21;
  if (v16 < 0x80000)
    goto LABEL_242;
  v140 = __clz(v16);
  v141 = v16 << (v140 + 1) >> -(char)v140;
  if (!v140)
    v141 = 0;
  v142 = v141 + ~(-1 << v140);
  *(_DWORD *)(a2 + 60) = v142;
  v143 = v140 + v21 + v140 + 1;
  v21 = v143 & 7;
  v11 += v143 >> 3;
  v144 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v144 < 1)
    {
      v16 = 0;
      if (v21 | v144)
        goto LABEL_242;
    }
    else
    {
      v145 = *v11;
      if (v144 == 1)
      {
        v16 = v145 << 24;
      }
      else
      {
        v146 = (v145 << 16) | (v11[1] << 8);
        if (v144 != 2)
          v146 |= v11[2];
        v16 = v146 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  if (v142 >= 0x20)
    goto LABEL_385;
  *(_BYTE *)(a2 + 64) = ((v16 << v21) & 0x80000000) != 0;
  v147 = (v21 + 1) >> 3;
  v21 = (v21 + 1) & 7;
  v11 += v147;
  v148 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v148 < 1)
    {
      v16 = 0;
      if (v21 | v148)
        goto LABEL_242;
    }
    else
    {
      v149 = *v11;
      if (v148 == 1)
      {
        v16 = v149 << 24;
      }
      else
      {
        v150 = (v149 << 16) | (v11[1] << 8);
        if (v148 != 2)
          v150 |= v11[2];
        v16 = v150 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  v151 = v16 << v21 >> 30;
  *(_DWORD *)(a2 + 68) = v151;
  v152 = (v21 + 2) >> 3;
  v21 = (v21 + 2) & 7;
  v11 += v152;
  v153 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v153 < 1)
    {
      v16 = 0;
      if (v21 | v153)
        goto LABEL_242;
    }
    else
    {
      v154 = *v11;
      if (v153 == 1)
      {
        v16 = v154 << 24;
      }
      else
      {
        v155 = (v154 << 16) | (v11[1] << 8);
        if (v153 != 2)
          v155 |= v11[2];
        v16 = v155 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  if (v151 == 3)
    goto LABEL_385;
  v16 <<= v21;
  if (v16 < 0x80000)
    goto LABEL_242;
  v156 = __clz(v16);
  v157 = v16 << (v156 + 1) >> -(char)v156;
  if (!v156)
    v157 = 0;
  v158 = v156 + v21 + v156 + 1;
  v21 = v158 & 7;
  v11 += v158 >> 3;
  v159 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v159 < 1)
    {
      v16 = 0;
      if (v21 | v159)
        goto LABEL_242;
    }
    else
    {
      v160 = *v11;
      if (v159 == 1)
      {
        v16 = v160 << 24;
      }
      else
      {
        v161 = (v160 << 16) | (v11[1] << 8);
        if (v159 != 2)
          v161 |= v11[2];
        v16 = v161 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  v162 = ((v157 + (1 << v156)) >> 1) - ((v157 + (1 << v156)) >> 1) * 2 * ((v157 + (1 << v156)) & 1);
  *(_DWORD *)(a2 + 72) = v162;
  if (v162 + 62 >= 0x58)
    goto LABEL_385;
  v16 <<= v21;
  if (v16 < 0x80000)
    goto LABEL_242;
  v163 = __clz(v16);
  v164 = v16 << (v163 + 1) >> -(char)v163;
  if (!v163)
    v164 = 0;
  v165 = v163 + v21 + v163 + 1;
  v21 = v165 & 7;
  v11 += v165 >> 3;
  v166 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v166 < 1)
    {
      v16 = 0;
      if (v21 | v166)
        goto LABEL_242;
    }
    else
    {
      v167 = *v11;
      if (v166 == 1)
      {
        v16 = v167 << 24;
      }
      else
      {
        v168 = (v167 << 16) | (v11[1] << 8);
        if (v166 != 2)
          v168 |= v11[2];
        v16 = v168 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  v169 = ((v164 + (1 << v163)) >> 1) - ((v164 + (1 << v163)) >> 1) * 2 * ((v164 + (1 << v163)) & 1);
  *(_DWORD *)(a2 + 76) = v169;
  if (v169 + 26 >= 0x34)
    goto LABEL_385;
  v16 <<= v21;
  if (v16 < 0x80000)
    goto LABEL_242;
  v170 = __clz(v16);
  v171 = v16 << (v170 + 1) >> -(char)v170;
  if (!v170)
    v171 = 0;
  v172 = v170 + v21 + v170 + 1;
  v21 = v172 & 7;
  v11 += v172 >> 3;
  v173 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v173 < 1)
    {
      v16 = 0;
      if (v21 | v173)
        goto LABEL_242;
    }
    else
    {
      v174 = *v11;
      if (v173 == 1)
      {
        v16 = v174 << 24;
      }
      else
      {
        v175 = (v174 << 16) | (v11[1] << 8);
        if (v173 != 2)
          v175 |= v11[2];
        v16 = v175 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  v176 = ((v171 + (1 << v170)) >> 1) - ((v171 + (1 << v170)) >> 1) * 2 * ((v171 + (1 << v170)) & 1);
  *(_DWORD *)(a2 + 80) = v176;
  if (v176 + 12 >= 0x19)
    goto LABEL_385;
  *(_BYTE *)(a2 + 84) = ((v16 << v21) & 0x80000000) != 0;
  v177 = (v21 + 1) >> 3;
  v21 = (v21 + 1) & 7;
  v11 += v177;
  v178 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v178 < 1)
    {
      v16 = 0;
      if (v21 | v178)
        goto LABEL_242;
    }
    else
    {
      v179 = *v11;
      if (v178 == 1)
      {
        v16 = v179 << 24;
      }
      else
      {
        v180 = (v179 << 16) | (v11[1] << 8);
        if (v178 != 2)
          v180 |= v11[2];
        v16 = v180 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  *(_BYTE *)(a2 + 85) = ((v16 << v21) & 0x80000000) != 0;
  v181 = (v21 + 1) >> 3;
  v21 = (v21 + 1) & 7;
  v11 += v181;
  v182 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 < 4)
  {
    if (v182 < 1)
    {
      v16 = 0;
      if (v21 | v182)
        goto LABEL_242;
    }
    else
    {
      v183 = *v11;
      if (v182 == 1)
      {
        v16 = v183 << 24;
      }
      else
      {
        v184 = (v183 << 16) | (v11[1] << 8);
        if (v182 != 2)
          v184 |= v11[2];
        v16 = v184 << 8;
      }
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v11);
  }
  *(_BYTE *)(a2 + 86) = ((v16 << v21) & 0x80000000) != 0;
  v185 = (v21 + 1) >> 3;
  v21 = (v21 + 1) & 7;
  v11 += v185;
  v186 = v12 - (_DWORD)v11;
  if (v12 - (int)v11 >= 4)
  {
    v16 = bswap32(*(_DWORD *)v11);
    goto LABEL_382;
  }
  if (v186 >= 1)
  {
    v187 = *v11;
    if (v186 == 1)
    {
      v16 = v187 << 24;
    }
    else
    {
      v188 = (v187 << 16) | (v11[1] << 8);
      if (v186 != 2)
        v188 |= v11[2];
      v16 = v188 << 8;
    }
    goto LABEL_382;
  }
  v16 = 0;
  if (!(v21 | v186))
  {
LABEL_382:
    v16 <<= v21;
LABEL_383:
    v123 = 0;
    a1[2] = (uint64_t)v11;
    *((_DWORD *)a1 + 6) = v16;
    *((_BYTE *)a1 + 28) = v21;
    return v123;
  }
LABEL_242:
  v123 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  if (!(_DWORD)v123)
    goto LABEL_383;
  return v123;
}

uint64_t FigH264Bridge_CopyDataWithEmulationPreventionBytesRemoved(const __CFData *a1, __CFData **a2)
{
  const UInt8 *BytePtr;
  CFIndex Length;

  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  return RemoveEmulation3Byte(BytePtr, Length, a2);
}

uint64_t FigH264Bridge_GetPPSSequenceIDFromSlice(const UInt8 *a1, unint64_t a2, int *a3, int *a4)
{
  uint64_t v4;
  int Length;
  const UInt8 *BytePtr;
  uint64_t v9;
  const __CFData *v10;
  _DWORD *v11;
  int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  unsigned __int8 *v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  int v31;
  unsigned __int8 *v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned __int8 *v42;
  int v43;
  int v44;
  unsigned __int8 *v45;
  int v46;
  int v47;
  BOOL v48;
  int v49;
  unsigned __int8 *v50;
  int v52;
  CFDataRef theData;
  __int128 v55;
  __int128 v56;

  v55 = 0u;
  v56 = 0u;
  theData = 0;
  v4 = 4294954584;
  if (!a1)
    return v4;
  Length = a2;
  if (a2 < 2)
    return v4;
  BytePtr = a1;
  if ((*a1 & 0x1B | 4) != 5)
    return v4;
  v9 = RemoveEmulation3Byte(a1, a2, &theData);
  v10 = theData;
  if ((_DWORD)v9)
    goto LABEL_65;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(v10);
  }
  v11 = BytePtr + 1;
  *(_QWORD *)&v55 = v11;
  v12 = Length - 1;
  DWORD2(v55) = Length - 1;
  *(_QWORD *)&v56 = v11;
  if ((Length - 1) < 4)
  {
    if (Length != 1)
    {
      DWORD2(v56) = 0;
      __memcpy_chk();
    }
  }
  else
  {
    DWORD2(v56) = *v11;
  }
  v13 = bswap32(DWORD2(v56));
  DWORD2(v56) = v13;
  BYTE12(v56) = 0;
  if (!(v13 >> 19))
    goto LABEL_64;
  v14 = (_DWORD)v11 + v12;
  v15 = __clz(v13);
  v16 = v15 + 1;
  v17 = v13 << (v15 + 1) >> -(char)v15;
  v18 = v15 ? v17 : 0;
  v19 = (v16 + v15) >> 3;
  v20 = (v16 + v15) & 7;
  v21 = (unsigned __int8 *)v11 + v19;
  v22 = v12 - v19;
  if (v22 < 4)
  {
    if (v22 < 1)
    {
      v23 = v20 | v22;
      if (v23)
        goto LABEL_64;
    }
    else
    {
      v24 = *v21;
      if (v22 == 1)
      {
        v23 = v24 << 24;
      }
      else
      {
        v25 = (v24 << 16) | (v21[1] << 8);
        if (v22 != 2)
          v25 |= v21[2];
        v23 = v25 << 8;
      }
    }
  }
  else
  {
    v23 = bswap32(*(_DWORD *)v21);
  }
  if ((v18 + ~(-1 << v15)) >> 22)
    goto LABEL_66;
  v26 = v23 << v20;
  if (!((v23 << v20) >> 19))
  {
LABEL_64:
    v9 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_65:
    v4 = v9;
    goto LABEL_61;
  }
  v27 = __clz(v26);
  v28 = v26 << (v27 + 1) >> -(char)v27;
  if (!v27)
    v28 = 0;
  v29 = v27 + v20 + v27 + 1;
  v30 = v29 >> 3;
  v31 = v29 & 7;
  v32 = &v21[v30];
  v33 = v14 - (_DWORD)v32;
  if (v14 - (int)v32 >= 4)
  {
    v34 = bswap32(*(_DWORD *)v32);
    goto LABEL_39;
  }
  if (v33 < 1)
  {
    v34 = v31 | v33;
    if (!v34)
      goto LABEL_39;
    goto LABEL_64;
  }
  v35 = *v32;
  if (v33 == 1)
  {
    v34 = v35 << 24;
  }
  else
  {
    v36 = (v35 << 16) | (v32[1] << 8);
    if (v33 != 2)
      v36 |= v32[2];
    v34 = v36 << 8;
  }
LABEL_39:
  v37 = v28 + ~(-1 << v27);
  if (v37 <= 9)
  {
    v38 = v34 << v31;
    if (a3)
      *a3 = v37;
    if (v38 >> 19)
    {
      v39 = __clz(v38);
      v40 = v38 << (v39 + 1) >> -(char)v39;
      if (!v39)
        v40 = 0;
      v41 = v39 + v31 + v39 + 1;
      v42 = &v32[v41 >> 3];
      v43 = v14 - (_DWORD)v42;
      if (v43 > 3)
        goto LABEL_58;
      v44 = v41 & 7;
      if (v43 <= 0)
        v45 = v42;
      else
        v45 = v42 + 1;
      v46 = v43 - (v43 > 0);
      if (v46 > 0)
        ++v45;
      v47 = v46 - (v46 > 0);
      v48 = v47 <= 0;
      v49 = v47 & (v47 >> 31);
      v50 = v48 ? v45 : v45 + 1;
      if (!(v49 | v44) || v50 != v42)
      {
LABEL_58:
        v52 = v40 + ~(-1 << v39);
        if (v52 <= 255)
        {
          v4 = 0;
          if (a4)
            *a4 = v52;
          goto LABEL_61;
        }
        goto LABEL_66;
      }
    }
    goto LABEL_64;
  }
LABEL_66:
  v4 = 4294954584;
LABEL_61:
  if (v10)
    CFRelease(v10);
  return v4;
}

uint64_t FigH264Bridge_GetInterlaceTypeFromSlice(const UInt8 *a1, unint64_t a2, _BYTE *a3, unint64_t a4, int *a5, unsigned int *a6, BOOL *a7)
{
  uint64_t v7;
  unsigned int Length;
  const UInt8 *BytePtr;
  uint64_t v15;
  const __CFData *v16;
  int v17;
  _DWORD *v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  unsigned __int8 *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t v38;
  int v39;
  unsigned __int8 *v40;
  int v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  uint64_t v50;
  int v51;
  unsigned __int8 *v52;
  int v53;
  unsigned int v54;
  int v55;
  int v56;
  unsigned int v57;
  uint64_t v58;
  int v59;
  unsigned __int8 *v60;
  int v61;
  int v62;
  int v63;
  int v64;
  unsigned __int8 *v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  unsigned __int8 *v71;
  int v72;
  unsigned __int8 *v73;
  int v74;
  int v75;
  BOOL v76;
  int v77;
  unsigned __int8 *v78;
  int v80;
  __int128 v82;
  CFDataRef theData;
  __int128 v84;
  __int128 v85;
  _OWORD v86[18];
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;

  v84 = 0u;
  v85 = 0u;
  theData = 0;
  v82 = 0u;
  v7 = 4294954584;
  if (!a1)
    return v7;
  Length = a2;
  if (a2 < 3)
    return v7;
  BytePtr = a1;
  if (a5)
    *a5 = 3;
  v99 = 0uLL;
  v100 = 0uLL;
  v97 = 0uLL;
  v98 = 0uLL;
  v95 = 0uLL;
  v96 = 0uLL;
  v93 = 0uLL;
  v94 = 0uLL;
  v91 = 0uLL;
  v92 = 0uLL;
  v89 = 0uLL;
  v90 = 0uLL;
  v87 = 0uLL;
  v88 = 0uLL;
  memset(v86, 0, sizeof(v86));
  v15 = RemoveEmulation3Byte(a1, a2, &theData);
  if ((_DWORD)v15)
    return v15;
  v16 = theData;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(v16);
  }
  *(_QWORD *)&v84 = BytePtr;
  DWORD2(v84) = Length;
  *(_QWORD *)&v85 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      DWORD2(v85) = 0;
      __memcpy_chk();
    }
  }
  else
  {
    DWORD2(v85) = *(_DWORD *)BytePtr;
  }
  DWORD2(v85) = bswap32(DWORD2(v85));
  BYTE12(v85) = 0;
  v7 = PullParamSetSPS((uint64_t)&v84, (char *)v86);
  if (v16)
    CFRelease(v16);
  if ((_DWORD)v7)
    return v7;
  v17 = v87;
  v7 = 4294954584;
  if ((int)v87 > 12 || !a3 || a4 < 3)
    return v7;
  if (a7)
    *a7 = (*a3 & 0x60) != 0;
  if ((*a3 & 0x1B | 4) != 5)
    return 4294954577;
  v18 = a3 + 1;
  v19 = a4 - 1;
  if (v19 < 4)
  {
    if (v19)
    {
      DWORD2(v82) = 0;
      __memcpy_chk();
    }
  }
  else
  {
    DWORD2(v82) = *v18;
  }
  v20 = bswap32(DWORD2(v82));
  if (!(v20 >> 19))
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  v21 = (_DWORD)v18 + v19;
  v22 = __clz(v20);
  v23 = v22 + 1;
  v24 = v20 << (v22 + 1) >> -(char)v22;
  if (v22)
    v25 = v24;
  else
    v25 = 0;
  v26 = (v23 + v22) >> 3;
  v27 = (v23 + v22) & 7;
  v28 = (unsigned __int8 *)v18 + v26;
  v29 = v19 - v26;
  if (v29 < 4)
  {
    if (v29 < 1)
    {
      v30 = v27 | v29;
      if (v30)
        return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      v31 = *v28;
      if (v29 == 1)
      {
        v30 = v31 << 24;
      }
      else
      {
        v32 = (v31 << 16) | (v28[1] << 8);
        if (v29 != 2)
          v32 |= v28[2];
        v30 = v32 << 8;
      }
    }
  }
  else
  {
    v30 = bswap32(*(_DWORD *)v28);
  }
  if ((v25 + ~(-1 << v22)) >> 22)
    return v7;
  v33 = v30 << v27;
  if (!((v30 << v27) >> 19))
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  v34 = __clz(v33);
  v35 = v33 << (v34 + 1) >> -(char)v34;
  if (v34)
    v36 = v35;
  else
    v36 = 0;
  v37 = v34 + v27 + v34 + 1;
  v38 = v37 >> 3;
  v39 = v37 & 7;
  v40 = &v28[v38];
  v41 = v21 - ((_DWORD)v28 + v38);
  if (v41 < 4)
  {
    if (v41 < 1)
    {
      v42 = v39 | v41;
      if (v42)
        return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      v43 = *v40;
      if (v41 == 1)
      {
        v42 = v43 << 24;
      }
      else
      {
        v44 = (v43 << 16) | (v40[1] << 8);
        if (v41 != 2)
          v44 |= v40[2];
        v42 = v44 << 8;
      }
    }
  }
  else
  {
    v42 = bswap32(*(_DWORD *)v40);
  }
  if (v36 + ~(-1 << v34) > 9)
    return v7;
  v45 = v42 << v39;
  if (!(v45 >> 19))
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  v46 = __clz(v45);
  v47 = v45 << (v46 + 1) >> -(char)v46;
  if (v46)
    v48 = v47;
  else
    v48 = 0;
  v49 = v46 + v39 + v46 + 1;
  v50 = v49 >> 3;
  v51 = v49 & 7;
  v52 = &v40[v50];
  v53 = v21 - ((_DWORD)v40 + v50);
  if (v53 < 4)
  {
    if (v53 < 1)
    {
      if (v51 | v53)
        return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      v54 = 0;
    }
    else
    {
      v55 = *v52;
      if (v53 == 1)
      {
        v54 = v55 << 24;
      }
      else
      {
        v56 = (v55 << 16) | (v52[1] << 8);
        if (v53 != 2)
          v56 |= v52[2];
        v54 = v56 << 8;
      }
    }
  }
  else
  {
    v54 = bswap32(*(_DWORD *)v52);
  }
  if (v48 + ~(-1 << v46) > 0xFF)
    return v7;
  if (v17 <= -4)
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  v57 = v51 + v17 + 4;
  v58 = v57 >> 3;
  v59 = v57 & 7;
  v60 = &v52[v58];
  v61 = v21 - (_DWORD)v60;
  if ((int)(v21 - (_DWORD)v60) >= 4)
  {
    v62 = bswap32(*(_DWORD *)v60);
    if (!a6)
      goto LABEL_82;
LABEL_81:
    *a6 = v54 << v51 >> (28 - v17);
    goto LABEL_82;
  }
  if (v61 < 1)
  {
    v62 = v59 | v61;
    if (v62)
      return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    if (a6)
      goto LABEL_81;
  }
  else
  {
    v63 = *v60;
    if (v61 == 1)
    {
      v62 = v63 << 24;
      if (a6)
        goto LABEL_81;
    }
    else
    {
      v69 = (v63 << 16) | (v60[1] << 8);
      if (v61 != 2)
        v69 |= v60[2];
      v62 = v69 << 8;
      if (a6)
        goto LABEL_81;
    }
  }
LABEL_82:
  if (HIDWORD(v89))
    goto LABEL_98;
  v64 = (v59 + 1) & 7;
  v65 = &v60[(v59 + 1) >> 3];
  v66 = v21 - (_DWORD)v65;
  if ((int)(v21 - (_DWORD)v65) >= 4)
  {
    v67 = bswap32(*(_DWORD *)v65);
    goto LABEL_97;
  }
  if (v66 < 1)
  {
    v67 = v64 | v66;
    if (!v67)
      goto LABEL_97;
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  v68 = *v65;
  if (v66 == 1)
  {
    v67 = v68 << 24;
  }
  else
  {
    v70 = (v68 << 16) | (v65[1] << 8);
    if (v66 != 2)
      v70 |= v65[2];
    v67 = v70 << 8;
  }
LABEL_97:
  if (((v62 << v59) & 0x80000000) == 0)
  {
LABEL_98:
    if (a5)
    {
      v7 = 0;
      *a5 = 0;
      return v7;
    }
    return 0;
  }
  v71 = &v65[(v64 + 1) >> 3];
  v72 = v21 - (_DWORD)v71;
  if (v72 <= 3)
  {
    if (v72 <= 0)
      v73 = &v65[(v64 + 1) >> 3];
    else
      v73 = v71 + 1;
    v74 = v72 - (v72 > 0);
    if (v74 > 0)
      ++v73;
    v75 = v74 - (v74 > 0);
    v76 = v75 <= 0;
    v77 = v75 & (v75 >> 31);
    v78 = v76 ? v73 : v73 + 1;
    if (v77 | ((_BYTE)v64 + 1) & 7 && v78 == v71)
      return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  if (!a5)
    return 0;
  v7 = 0;
  if (v67 << v64 >= 0)
    v80 = 1;
  else
    v80 = 2;
  *a5 = v80;
  return v7;
}

uint64_t FigH264Bridge_GetSliceInformationFromSampleBuffer(opaqueCMSampleBuffer *a1, int *a2, unsigned int *a3, BOOL *a4)
{
  const opaqueCMFormatDescription *FormatDescription;
  const __CFDictionary *Extensions;
  const __CFDictionary *Value;
  const __CFDictionary *v10;
  CFTypeID v11;
  const __CFArray *v12;
  const __CFArray *ValueAtIndex;
  CFTypeID v14;
  CFTypeID v15;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t result;
  const UInt8 *v19;
  uint64_t v20;
  size_t v21;
  CMBlockBufferRef DataBuffer;
  OpaqueCMBlockBuffer *v23;
  size_t v24;
  const UInt8 *v25;
  unint64_t v26;
  unsigned int v27;
  size_t v28;
  size_t v29;
  unsigned int v31;
  unint64_t v32;
  char *returnedPointerOut;
  const UInt8 *v34;
  _BYTE temporaryBlock[32];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v34 = 0;
  v32 = 0;
  FormatDescription = CMSampleBufferGetFormatDescription(a1);
  if (!FormatDescription)
    return 4294954584;
  Extensions = CMFormatDescriptionGetExtensions(FormatDescription);
  if (!Extensions)
    return 4294954584;
  Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("SampleDescriptionExtensionAtoms"));
  if (!Value)
    return 4294954584;
  v10 = Value;
  v11 = CFGetTypeID(Value);
  if (v11 != CFDictionaryGetTypeID())
    return 4294954584;
  v12 = (const __CFArray *)CFDictionaryGetValue(v10, CFSTR("avcC"));
  if (!v12)
    return 4294954584;
  ValueAtIndex = v12;
  v14 = CFGetTypeID(v12);
  if (v14 == CFArrayGetTypeID())
  {
    ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
    if (!ValueAtIndex)
      return 4294954584;
  }
  v15 = CFGetTypeID(ValueAtIndex);
  if (v15 != CFDataGetTypeID())
    return 4294954584;
  returnedPointerOut = 0;
  BytePtr = CFDataGetBytePtr(ValueAtIndex);
  Length = CFDataGetLength(ValueAtIndex);
  result = FigH264Bridge_GetSPSFromAVCC((uint64_t)BytePtr, Length, 0, &v34, &v32);
  if (!(_DWORD)result)
  {
    v19 = CFDataGetBytePtr(ValueAtIndex);
    if ((unint64_t)CFDataGetLength(ValueAtIndex) >= 7)
    {
      v20 = v19[4] & 3;
      v21 = v20 + 1;
      if (v20 < 2 || (_DWORD)v20 == 3)
      {
        DataBuffer = CMSampleBufferGetDataBuffer(a1);
        if (DataBuffer)
        {
          v23 = DataBuffer;
          v24 = 0;
          v25 = v34;
          v26 = v32;
          while (1)
          {
            v31 = 0;
            result = CMBlockBufferAccessDataBytes(v23, v24, v21, temporaryBlock, &returnedPointerOut);
            if ((_DWORD)result)
              return result;
            if (v21 == 2)
            {
              v27 = bswap32(*(unsigned __int16 *)returnedPointerOut) >> 16;
            }
            else
            {
              if (v21 != 4)
              {
                __memcpy_chk();
                v27 = 0;
                goto LABEL_22;
              }
              v27 = bswap32(*(_DWORD *)returnedPointerOut);
            }
            v31 = v27;
LABEL_22:
            if (v27 >= 0x20)
              v28 = 32;
            else
              v28 = v27;
            v29 = v24 + v21;
            result = CMBlockBufferAccessDataBytes(v23, v29, v28, temporaryBlock, &returnedPointerOut);
            if (!(_DWORD)result)
            {
              result = FigH264Bridge_GetInterlaceTypeFromSlice(v25, v26, returnedPointerOut, v28, a2, a3, a4);
              v24 = v29 + v31;
              if ((_DWORD)result == -12719)
                continue;
            }
            return result;
          }
        }
      }
      return 4294954584;
    }
    return 4294954582;
  }
  return result;
}

uint64_t FigH264Bridge_CreateHLSfMP4ParsingInfoFromAVCCData(const void *a1, _QWORD *a2)
{
  CFTypeID v4;
  uint64_t SPSAndPPSCountFromAVCC;
  char *v6;
  char *v7;
  uint64_t v8;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t SPSFromAVCC;
  const UInt8 *v12;
  unsigned int v13;
  const __CFData *v14;
  unsigned int v15;
  unint64_t v16;
  uint64_t v17;
  char *v18;
  int v19;
  uint64_t v20;
  const UInt8 *v21;
  CFIndex v22;
  const UInt8 *v23;
  unsigned int v24;
  const __CFData *v25;
  unsigned int v26;
  unint64_t v27;
  char *v28;
  __int128 v29;
  CFDataRef theData;
  __int128 v33;
  __int128 v34;
  _OWORD v35[2];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  const UInt8 *v70;
  const UInt8 *v71;

  v70 = 0;
  v71 = 0;
  v68 = 0;
  v69 = 0;
  v66 = 0;
  v67 = 0;
  if (a1)
  {
    v4 = CFGetTypeID(a1);
    if (v4 == CFDataGetTypeID())
    {
      if (a2)
      {
        SPSAndPPSCountFromAVCC = FigH264Bridge_GetSPSAndPPSCountFromAVCC(a1, &v67, &v66);
        if ((_DWORD)SPSAndPPSCountFromAVCC)
          return SPSAndPPSCountFromAVCC;
        if (v67 && v66)
        {
          v6 = (char *)malloc_type_malloc(0x3900uLL, 0x1000040677A246CuLL);
          v7 = v6;
          if (v6)
          {
            bzero(v6, 0x3900uLL);
            if (v67)
            {
              v8 = 0;
              while (1)
              {
                v64 = 0u;
                v65 = 0u;
                v62 = 0u;
                v63 = 0u;
                v60 = 0u;
                v61 = 0u;
                v58 = 0u;
                v59 = 0u;
                v56 = 0u;
                v57 = 0u;
                v54 = 0u;
                v55 = 0u;
                v52 = 0u;
                v53 = 0u;
                v50 = 0u;
                v51 = 0u;
                v48 = 0u;
                v49 = 0u;
                v46 = 0u;
                v47 = 0u;
                v44 = 0u;
                v45 = 0u;
                v42 = 0u;
                v43 = 0u;
                v40 = 0u;
                v41 = 0u;
                v38 = 0u;
                v39 = 0u;
                v36 = 0u;
                v37 = 0u;
                memset(v35, 0, sizeof(v35));
                v33 = 0u;
                v34 = 0u;
                theData = 0;
                BytePtr = CFDataGetBytePtr((CFDataRef)a1);
                Length = CFDataGetLength((CFDataRef)a1);
                SPSFromAVCC = FigH264Bridge_GetSPSFromAVCC((uint64_t)BytePtr, Length, v8, &v71, &v69);
                if ((_DWORD)SPSFromAVCC)
                  break;
                v12 = v71;
                v13 = v69;
                SPSFromAVCC = RemoveEmulation3Byte(v71, v69, &theData);
                if ((_DWORD)SPSFromAVCC)
                  break;
                v14 = theData;
                if (theData)
                {
                  *(_QWORD *)&v33 = CFDataGetBytePtr(theData);
                  v15 = CFDataGetLength(v14);
                  v16 = v15;
                  DWORD2(v33) = v15;
                  v12 = (const UInt8 *)v33;
                }
                else
                {
                  *(_QWORD *)&v33 = v12;
                  v16 = v13;
                  DWORD2(v33) = v13;
                }
                *(_QWORD *)&v34 = v12;
                if (v16 < 4)
                {
                  if (v16)
                  {
                    DWORD2(v34) = 0;
                    __memcpy_chk();
                  }
                }
                else
                {
                  DWORD2(v34) = *(_DWORD *)v12;
                }
                DWORD2(v34) = bswap32(DWORD2(v34));
                BYTE12(v34) = 0;
                v17 = PullParamSetSPS((uint64_t)&v33, (char *)v35);
                if (v14)
                  CFRelease(v14);
                if ((_DWORD)v17)
                  goto LABEL_44;
                if (SDWORD1(v36) >= 32)
                  goto LABEL_42;
                v18 = &v7[40 * SDWORD1(v36)];
                *v18 = 1;
                v19 = BYTE9(v36);
                *((_DWORD *)v18 + 1) = BYTE8(v36);
                *((_DWORD *)v18 + 2) = v19;
                *(_OWORD *)(v18 + 12) = v52;
                *(_QWORD *)(v18 + 28) = *(_QWORD *)((char *)&v54 + 4);
                *((_DWORD *)v18 + 9) = HIDWORD(v54);
                if (++v8 >= v67)
                  goto LABEL_24;
              }
            }
            else
            {
LABEL_24:
              if (!v66)
                goto LABEL_40;
              v20 = 0;
              while (1)
              {
                *(_QWORD *)&v39 = 0;
                v37 = 0u;
                v38 = 0u;
                v36 = 0u;
                v34 = 0u;
                memset(v35, 0, sizeof(v35));
                v33 = 0u;
                theData = 0;
                v21 = CFDataGetBytePtr((CFDataRef)a1);
                v22 = CFDataGetLength((CFDataRef)a1);
                SPSFromAVCC = FigH264Bridge_GetPPSFromAVCC((uint64_t)v21, v22, v20, &v70, &v68);
                if ((_DWORD)SPSFromAVCC)
                  break;
                v23 = v70;
                v24 = v68;
                SPSFromAVCC = RemoveEmulation3Byte(v70, v68, &theData);
                if ((_DWORD)SPSFromAVCC)
                  break;
                v25 = theData;
                if (theData)
                {
                  *(_QWORD *)&v33 = CFDataGetBytePtr(theData);
                  v26 = CFDataGetLength(v25);
                  v27 = v26;
                  DWORD2(v33) = v26;
                  v23 = (const UInt8 *)v33;
                }
                else
                {
                  *(_QWORD *)&v33 = v23;
                  v27 = v24;
                  DWORD2(v33) = v24;
                }
                *(_QWORD *)&v34 = v23;
                if (v27 < 4)
                {
                  if (v27)
                  {
                    DWORD2(v34) = 0;
                    __memcpy_chk();
                  }
                }
                else
                {
                  DWORD2(v34) = *(_DWORD *)v23;
                }
                DWORD2(v34) = bswap32(DWORD2(v34));
                BYTE12(v34) = 0;
                v17 = PullParamSetPPS((uint64_t *)&v33, (uint64_t)v35);
                if (v25)
                  CFRelease(v25);
                if ((_DWORD)v17)
                  goto LABEL_44;
                if (LODWORD(v35[0]) >= 0x100)
                  goto LABEL_42;
                v28 = &v7[52 * LODWORD(v35[0])];
                v28[1280] = 1;
                *((_DWORD *)v28 + 321) = DWORD1(v35[0]);
                *((_DWORD *)v28 + 322) = BYTE8(v35[0]);
                *((_DWORD *)v28 + 323) = BYTE9(v35[0]);
                *(_QWORD *)&v29 = *(_QWORD *)((char *)v35 + 12);
                *((_QWORD *)&v29 + 1) = __PAIR64__(DWORD2(v37), HIDWORD(v36));
                *((_OWORD *)v28 + 81) = v29;
                *((_DWORD *)v28 + 328) = HIDWORD(v37);
                *((_DWORD *)v28 + 329) = v38;
                *((_DWORD *)v28 + 330) = DWORD1(v38);
                *((_DWORD *)v28 + 331) = BYTE4(v39);
                *((_DWORD *)v28 + 332) = BYTE6(v39);
                if (++v20 >= v66)
                  goto LABEL_40;
              }
            }
          }
          else
          {
LABEL_42:
            SPSFromAVCC = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          }
          v17 = SPSFromAVCC;
LABEL_44:
          if ((_DWORD)v17)
            goto LABEL_45;
LABEL_40:
          v17 = 0;
          *a2 = v7;
          return v17;
        }
      }
    }
  }
  v17 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v7 = 0;
  if (!(_DWORD)v17)
    goto LABEL_40;
LABEL_45:
  if (v7)
    free(v7);
  return v17;
}

void FigH264Bridge_HLSfMP4ParsingInfoDestroy(void *a1)
{
  if (a1)
    free(a1);
}

uint64_t FigH264Bridge_MeasureSliceHeader(const UInt8 *a1, unint64_t a2, uint64_t a3, int a4, const UInt8 **a5)
{
  uint64_t v10;
  const __CFData *v11;
  const UInt8 *BytePtr;
  int Length;
  unsigned int v14;
  unsigned int v15;
  unsigned __int8 *v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned __int8 *v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int i;
  int v41;
  unsigned int v42;
  int v43;
  int v44;
  int v45;
  unsigned int v46;
  uint64_t v47;
  int v48;
  unsigned int v49;
  int v50;
  int v51;
  unsigned int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  unsigned int v57;
  int v58;
  int v59;
  int v60;
  unsigned int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  uint64_t v71;
  unsigned __int8 *v72;
  int v73;
  unsigned int v74;
  int v75;
  int v76;
  int v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  unsigned int v81;
  int v82;
  unsigned int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  _BYTE *v88;
  uint64_t v89;
  int v90;
  unsigned int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  unsigned int v96;
  int v97;
  unsigned int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  unsigned int v103;
  uint64_t v104;
  int v105;
  unsigned int v106;
  int v107;
  int v108;
  uint64_t v109;
  int v110;
  int v111;
  int v112;
  int v113;
  unsigned int v114;
  unsigned int v115;
  unsigned int v116;
  int v117;
  uint64_t v118;
  int v119;
  unsigned int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  int v127;
  unsigned int v128;
  int v129;
  int v130;
  unsigned int v131;
  int v132;
  int v133;
  int v134;
  unsigned int v135;
  int v136;
  unsigned int v137;
  int v138;
  unsigned __int8 *v139;
  int v140;
  unsigned int v141;
  int v142;
  int v143;
  int v144;
  int v145;
  unsigned int v146;
  int v147;
  int v148;
  int v149;
  unsigned int v150;
  int v151;
  int v152;
  int v153;
  int v154;
  unsigned int v155;
  int v156;
  int v157;
  unsigned int v158;
  unsigned int v159;
  int v160;
  int v161;
  int v162;
  int v163;
  unsigned int v164;
  unsigned int v165;
  unsigned int v166;
  int v167;
  uint64_t v168;
  int v169;
  unsigned int v170;
  int v171;
  int v172;
  int v173;
  int v174;
  int v175;
  int v176;
  int v177;
  unsigned int v178;
  int v179;
  unsigned int v180;
  int v181;
  int v182;
  int v183;
  unsigned int v184;
  int v185;
  unsigned int v186;
  int v187;
  int v188;
  unsigned int v189;
  int v190;
  int v191;
  int v192;
  int v193;
  unsigned int v194;
  int v195;
  int v196;
  int v197;
  unsigned int v198;
  int v199;
  int v200;
  int v201;
  unsigned int v202;
  int v203;
  unsigned int v204;
  unsigned int v205;
  uint64_t v206;
  int v207;
  unsigned int v208;
  int v209;
  int v210;
  int v211;
  unsigned int v212;
  unsigned int v213;
  int v214;
  int v215;
  unsigned int v216;
  int v217;
  int v218;
  int v219;
  unsigned int v220;
  uint64_t v221;
  unsigned __int8 *v222;
  int v223;
  int v224;
  int v225;
  int v226;
  int v227;
  unsigned int v228;
  uint64_t v229;
  int v230;
  int v231;
  unsigned int v232;
  int v233;
  uint64_t v234;
  int v235;
  unsigned int v236;
  int v237;
  int v238;
  int v239;
  int v240;
  unsigned int v241;
  unsigned int v242;
  int v243;
  unsigned int v244;
  int v245;
  int v246;
  int v247;
  unsigned int v248;
  uint64_t v249;
  int v250;
  int v251;
  int v252;
  int v253;
  int v254;
  unsigned int v255;
  uint64_t v256;
  int v257;
  int v258;
  unsigned int v259;
  unsigned int v260;
  unsigned int v261;
  int v262;
  int v263;
  int v264;
  int v265;
  uint64_t v266;
  int v267;
  int v268;
  int v269;
  int v270;
  int v271;
  uint64_t v272;
  int v273;
  unsigned int v274;
  int v275;
  BOOL v276;
  char v277;
  int v278;
  uint64_t v279;
  int v280;
  int v281;
  uint64_t v282;
  int v283;
  int v284;
  unsigned int v285;
  unsigned int v286;
  unsigned int v287;
  unsigned int v288;
  int v289;
  unsigned int v290;
  int v291;
  int v292;
  int v293;
  int v294;
  uint64_t v295;
  int v296;
  int v297;
  int v298;
  unsigned int v299;
  unsigned int v300;
  unsigned int v301;
  unsigned int v302;
  int v303;
  unsigned int v304;
  int v305;
  int v306;
  int v307;
  unsigned int v308;
  int v309;
  int v310;
  int v311;
  int v312;
  int v313;
  int v314;
  uint64_t v315;
  int v316;
  unsigned int v317;
  int v318;
  int v319;
  int v320;
  int v321;
  int v322;
  uint64_t v323;
  int v324;
  int v325;
  int v326;
  int v327;
  int v328;
  int v329;
  int v330;
  int v331;
  unsigned int v332;
  unsigned int v333;
  unsigned int v334;
  unsigned int v335;
  int v336;
  unsigned int v337;
  int v338;
  int v339;
  int v340;
  unsigned int v341;
  int v342;
  int v343;
  int v344;
  int v345;
  unsigned int v346;
  int v347;
  int v348;
  int v349;
  int v350;
  unsigned int v351;
  int v352;
  int v353;
  int v354;
  int v355;
  int v356;
  int v357;
  unsigned int v359;
  unsigned int v360;
  unsigned int v361;
  unsigned int v362;
  int v363;
  int v364;
  int v365;
  int v366;
  uint64_t v367;
  int v368;
  int v369;
  int v370;
  int v371;
  unsigned int v372;
  unsigned int v373;
  unsigned int v374;
  int v375;
  int v376;
  unsigned int v377;
  unsigned int v378;
  unsigned int v379;
  int v380;
  int v381;
  int v382;
  int v383;
  unsigned int v384;
  unsigned int v385;
  unsigned int v386;
  unsigned int v387;
  int v388;
  unsigned int v389;
  int v390;
  BOOL v391;
  char v392;
  int v393;
  unsigned int v394;
  unsigned int v395;
  unsigned int v396;
  int v397;
  int v398;
  int v399;
  uint64_t v400;
  int v401;
  int v402;
  unsigned int v403;
  unsigned int v404;
  unsigned int v405;
  unsigned int v406;
  int v407;
  unsigned int v408;
  int v409;
  int v410;
  int v411;
  int v412;
  unsigned int v413;
  unsigned int v414;
  unsigned int v415;
  int v416;
  int v417;
  int v418;
  int v419;
  unsigned int v420;
  unsigned int v421;
  unsigned int v422;
  int v423;
  int v424;
  int v425;
  int v426;
  const UInt8 *v427;
  const UInt8 **v428;
  int v429;
  unint64_t v430;
  unint64_t v431;
  unint64_t v432;
  unsigned int v434;
  unsigned int v435;
  unsigned int v436;
  unsigned int v437;
  int v438;
  unsigned int v439;
  int v440;
  int v441;
  int v442;
  unsigned int v443;
  int v444;
  int v445;
  int v446;
  int v447;
  int v448;
  int v449;
  int v450;
  const UInt8 *v451;
  const UInt8 **v452;
  CFDataRef theData;
  __int128 v454;
  __int128 v455;
  __int128 v456;
  __int128 v457;
  __int128 v458;
  __int128 v459;
  __int128 v460;
  __int128 v461;
  __int128 v462;
  __int128 v463;
  __int128 v464;
  __int128 v465;
  __int128 v466;
  __int128 v467;
  __int128 v468;
  __int128 v469;
  __int128 v470;
  uint64_t v471;

  v471 = 0;
  v469 = 0u;
  v470 = 0u;
  v467 = 0u;
  v468 = 0u;
  v465 = 0u;
  v466 = 0u;
  v463 = 0u;
  v464 = 0u;
  v462 = 0u;
  v460 = 0u;
  v461 = 0u;
  v458 = 0u;
  v459 = 0u;
  v456 = 0u;
  v457 = 0u;
  v454 = 0u;
  v455 = 0u;
  theData = 0;
  v10 = RemoveEmulation3Byte(a1, a2, &theData);
  if ((_DWORD)v10)
  {
    v400 = v10;
    goto LABEL_1068;
  }
  v11 = theData;
  BytePtr = a1;
  Length = a2;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(v11);
  }
  *(_QWORD *)&v454 = BytePtr;
  DWORD2(v454) = Length;
  *(_QWORD *)&v455 = BytePtr;
  if (Length < 4)
  {
    if (Length)
    {
      DWORD2(v455) = 0;
      __memcpy_chk();
      v14 = DWORD2(v455);
    }
    else
    {
      v14 = 0;
    }
  }
  else
  {
    v14 = *(_DWORD *)BytePtr;
  }
  v15 = bswap32(v14);
  DWORD2(v455) = v15;
  BYTE12(v455) = 0;
  v456 = 0u;
  v457 = 0u;
  v458 = 0u;
  v459 = 0u;
  v460 = 0u;
  v461 = 0u;
  v462 = 0u;
  v463 = 0u;
  v464 = 0u;
  v465 = 0u;
  v466 = 0u;
  v467 = 0u;
  v468 = 0u;
  v469 = 0u;
  v470 = 0u;
  v471 = 0;
  if (Length <= 3)
  {
    if (Length < 1)
    {
      v22 = 4294954582;
      if (!a4)
      {
        v451 = a1;
        v452 = a5;
        v23 = 0;
        LOBYTE(v24) = 1;
        goto LABEL_973;
      }
      goto LABEL_974;
    }
    LODWORD(v456) = (*BytePtr >> 5) & 3;
    v16 = (unsigned __int8 *)(BytePtr + 1);
    v17 = *BytePtr & 0x1F;
    DWORD1(v456) = v17;
    v451 = a1;
    v452 = a5;
    if (Length == 1)
    {
      v20 = 0;
      v18 = 0;
      v19 = 0;
      goto LABEL_22;
    }
    v25 = *v16;
    if (Length == 2)
    {
      v20 = 0;
      v19 = v25 << 24;
      v18 = 1;
      goto LABEL_22;
    }
    v21 = (v25 << 16) | (BytePtr[2] << 8);
    v18 = 2;
  }
  else
  {
    v451 = a1;
    v452 = a5;
    LODWORD(v456) = (*(_DWORD *)BytePtr >> 5) & 3;
    v16 = (unsigned __int8 *)(BytePtr + 1);
    v17 = *(_DWORD *)BytePtr & 0x1F;
    DWORD1(v456) = v17;
    v18 = Length - 1;
    if ((Length - 1) >= 4)
    {
      v19 = bswap32(*(_DWORD *)v16);
      v20 = 1;
      goto LABEL_22;
    }
    v21 = (BytePtr[1] << 16) | (BytePtr[2] << 8) | BytePtr[3];
    v18 = 3;
  }
  v20 = 0;
  v19 = v21 << 8;
LABEL_22:
  if (a4)
  {
    if ((v15 & 0x80000000) != 0)
      goto LABEL_952;
    LODWORD(v22) = -12714;
    if (v17 > 0x13 || ((1 << v17) & 0x80022) == 0)
      goto LABEL_974;
  }
  else if ((v15 & 0x80000000) != 0 || v17 > 0x13 || ((1 << v17) & 0x80022) == 0)
  {
    goto LABEL_853;
  }
  v26 = (_DWORD)BytePtr + Length;
  if (v19 >= 0x80000)
  {
    v27 = __clz(v19);
    v28 = v19 << (v27 + 1) >> -(char)v27;
    if (!v27)
      v28 = 0;
    DWORD2(v456) = v28 + ~(-1 << v27);
    v29 = v27 + 1 + v27;
    v24 = v29 & 7;
    v30 = &v16[v29 >> 3];
    v31 = v26 - (_DWORD)v30;
    if (v26 - (int)v30 >= 4)
    {
      v23 = bswap32(*(_DWORD *)v30);
      goto LABEL_95;
    }
    if (v31 >= 1)
    {
      v33 = *v30;
      if (v31 == 1)
      {
        v23 = v33 << 24;
      }
      else
      {
        v36 = (v33 << 16) | (v30[1] << 8);
        if (v31 != 2)
          v36 |= v30[2];
        v23 = v36 << 8;
      }
      goto LABEL_95;
    }
    v35 = v24 | v31;
    if (a4)
    {
      if (v35)
        goto LABEL_952;
      v23 = 0;
      goto LABEL_95;
    }
    v23 = 0;
    if (!v35)
    {
LABEL_95:
      v23 <<= v24;
      goto LABEL_121;
    }
    goto LABEL_1134;
  }
  if (v20)
  {
    v32 = bswap32(*(_DWORD *)v16);
  }
  else
  {
    if (!v18)
    {
      v22 = 4294954582;
      if (a4)
        goto LABEL_974;
      v23 = 0;
      LOBYTE(v24) = 1;
      goto LABEL_48;
    }
    v34 = *v16;
    if (v18 == 1)
    {
      v32 = v34 << 24;
    }
    else
    {
      v37 = (v34 << 16) | (BytePtr[2] << 8);
      if (v18 != 2)
        v37 |= BytePtr[3];
      v32 = v37 << 8;
    }
  }
  v38 = 0;
  v39 = 2 * v32;
  for (i = 1; ; i = (i + 1) & 7)
  {
    v24 = (i + 1) & 7;
    v16 += (i + 1) >> 3;
    v41 = v26 - (_DWORD)v16;
    if (v26 - (int)v16 >= 4)
    {
      v42 = bswap32(*(_DWORD *)v16);
      goto LABEL_68;
    }
    if (v41 >= 1)
      break;
    v44 = v24 | v41;
    if (a4)
    {
      if (v44)
        goto LABEL_952;
      v23 = 0;
      if (v39 < 0)
        goto LABEL_74;
    }
    else
    {
      v23 = 0;
      if (v44)
        goto LABEL_1130;
      if (v39 < 0)
        goto LABEL_78;
    }
LABEL_69:
    --v38;
    v39 = v44;
  }
  v43 = *v16;
  if (v41 == 1)
  {
    v42 = v43 << 24;
  }
  else
  {
    v45 = (v43 << 16) | (v16[1] << 8);
    if (v41 != 2)
      v45 |= v16[2];
    v42 = v45 << 8;
  }
LABEL_68:
  v44 = v42 << v24;
  if ((v39 & 0x80000000) == 0)
    goto LABEL_69;
  v23 = v44;
  if (!a4)
  {
LABEL_78:
    if (-v38 > 0x1E)
    {
LABEL_1130:
      v22 = 4294954582;
      goto LABEL_48;
    }
    if ((1 - v38) < 0x19)
      goto LABEL_76;
    goto LABEL_80;
  }
LABEL_74:
  if (-v38 > 0x1E)
    goto LABEL_952;
  if ((1 - v38) > 0x18)
  {
LABEL_80:
    v50 = (((_BYTE)i + 1) & 7) - v38;
    v24 = (v50 + 1) & 7;
    v16 += (v50 - 15) >> 3;
    v51 = v26 - (_DWORD)v16;
    if (v26 - (int)v16 >= 4)
    {
      v52 = bswap32(*(_DWORD *)v16);
LABEL_102:
      v57 = v52 << v24;
      goto LABEL_103;
    }
    if (v51 >= 1)
    {
      v54 = *v16;
      if (v51 == 1)
      {
        v52 = v54 << 24;
      }
      else
      {
        v59 = (v54 << 16) | (v16[1] << 8);
        if (v51 != 2)
          v59 |= v16[2];
        v52 = v59 << 8;
      }
      goto LABEL_102;
    }
    v56 = v24 | v51;
    if (a4)
    {
      if (v56)
        goto LABEL_952;
      v57 = 0;
LABEL_103:
      v30 = v16 + 2;
      v60 = v26 - ((_DWORD)v16 + 2);
      if (v60 < 4)
      {
        if (v60 < 1)
        {
          v63 = v24 | v60;
          if (a4)
          {
            if (v63)
              goto LABEL_952;
            v61 = 0;
          }
          else
          {
            v61 = 0;
            if (v63)
            {
LABEL_1139:
              v22 = 4294954582;
              v23 = 0;
              goto LABEL_1135;
            }
          }
        }
        else
        {
          v62 = *v30;
          if (v60 == 1)
          {
            v61 = v62 << 24;
          }
          else
          {
            v64 = (v62 << 16) | (v16[3] << 8);
            if (v60 != 2)
              v64 |= v16[4];
            v61 = v64 << 8;
          }
        }
      }
      else
      {
        v61 = bswap32(*(_DWORD *)v30);
      }
      v66 = v23 >> (v38 + 47);
      v23 = v61 << v24;
      v65 = __PAIR64__(v66, v57) >> 16;
      goto LABEL_120;
    }
    v57 = 0;
    if (!v56)
      goto LABEL_103;
    v22 = 4294954582;
    v23 = 0;
LABEL_48:
    BytePtr = v16;
    goto LABEL_973;
  }
LABEL_76:
  v46 = (((_BYTE)i + 1) & 7) - v38 + 1;
  v47 = v46 >> 3;
  v24 = v46 & 7;
  v30 = &v16[v47];
  v48 = v26 - ((_DWORD)v16 + v47);
  if (v48 >= 4)
  {
    v49 = bswap32(*(_DWORD *)v30);
    goto LABEL_115;
  }
  if (v48 >= 1)
  {
    v53 = *v30;
    if (v48 == 1)
    {
      v49 = v53 << 24;
    }
    else
    {
      v58 = (v53 << 16) | (v30[1] << 8);
      if (v48 != 2)
        v58 |= v30[2];
      v49 = v58 << 8;
    }
    goto LABEL_115;
  }
  v55 = v24 | v48;
  if (!a4)
  {
    v49 = 0;
    if (!v55)
      goto LABEL_115;
    goto LABEL_1139;
  }
  if (v55)
    goto LABEL_952;
  v49 = 0;
LABEL_115:
  v65 = v23 >> (v38 + 31);
  v23 = v49 << v24;
LABEL_120:
  DWORD2(v456) = v65 + ~(-1 << (1 - v38));
LABEL_121:
  if (!a4)
  {
    if (v23 >= 0x80000)
      goto LABEL_125;
LABEL_1134:
    v22 = 4294954582;
LABEL_1135:
    BytePtr = v30;
    goto LABEL_973;
  }
  if (v23 < 0x80000)
    goto LABEL_952;
LABEL_125:
  v67 = __clz(v23);
  v68 = v23 << (v67 + 1) >> -(char)v67;
  if (!v67)
    v68 = 0;
  v69 = v68 + ~(-1 << v67);
  LODWORD(v457) = v69;
  v70 = v67 + v24 + v67 + 1;
  v71 = v70 >> 3;
  v24 = v70 & 7;
  v72 = &v30[v71];
  v73 = v26 - ((_DWORD)v30 + v71);
  if (v73 >= 4)
  {
    v74 = bswap32(*(_DWORD *)v72);
    goto LABEL_138;
  }
  if (v73 < 1)
  {
    v76 = v24 | v73;
    if (a4)
    {
      if (v76)
        goto LABEL_952;
      v23 = 0;
      goto LABEL_139;
    }
    v23 = 0;
    if (v76)
      goto LABEL_658;
  }
  else
  {
    v75 = *v72;
    if (v73 == 1)
    {
      v74 = v75 << 24;
    }
    else
    {
      v77 = (v75 << 16) | (v72[1] << 8);
      if (v73 != 2)
        v77 |= v72[2];
      v74 = v77 << 8;
    }
LABEL_138:
    v23 = v74 << v24;
    if (a4)
    {
LABEL_139:
      if (v69 > 9)
        goto LABEL_952;
      if (v17 == 5)
      {
        LODWORD(v22) = -12714;
        if (((1 << v69) & 0x294) == 0)
          goto LABEL_974;
      }
      if (v23 < 0x80000)
        goto LABEL_952;
      goto LABEL_149;
    }
  }
  if (v69 > 9 || v17 == 5 && ((1 << v69) & 0x294) == 0)
    goto LABEL_853;
  if (v23 < 0x80000)
    goto LABEL_658;
LABEL_149:
  v78 = __clz(v23);
  v79 = v23 << (v78 + 1) >> -(char)v78;
  if (!v78)
    v79 = 0;
  v80 = v79 + ~(-1 << v78);
  DWORD1(v457) = v80;
  v81 = v78 + v24 + v78 + 1;
  v24 = v81 & 7;
  v72 += v81 >> 3;
  v82 = v26 - (_DWORD)v72;
  if (v26 - (int)v72 >= 4)
  {
    v83 = bswap32(*(_DWORD *)v72);
    goto LABEL_162;
  }
  if (v82 < 1)
  {
    v85 = v24 | v82;
    if (a4)
    {
      if (v85)
        goto LABEL_952;
      v23 = 0;
      goto LABEL_163;
    }
    v23 = 0;
    if (v85)
      goto LABEL_658;
LABEL_170:
    if (v80 > 0xFF)
      goto LABEL_1115;
    if (!*(_BYTE *)(a3 + 52 * v80 + 1280))
      goto LABEL_1115;
    v87 = *(_DWORD *)(a3 + 52 * v80 + 1284);
    if (v87 > 31)
      goto LABEL_1115;
    v88 = (_BYTE *)(a3 + 40 * v87);
    if (!*v88)
      goto LABEL_1115;
    if (*(_DWORD *)(a3 + 40 * v87 + 8))
      goto LABEL_175;
    goto LABEL_190;
  }
  v84 = *v72;
  if (v82 == 1)
  {
    v83 = v84 << 24;
  }
  else
  {
    v86 = (v84 << 16) | (v72[1] << 8);
    if (v82 != 2)
      v86 |= v72[2];
    v83 = v86 << 8;
  }
LABEL_162:
  v23 = v83 << v24;
  if (!a4)
    goto LABEL_170;
LABEL_163:
  if (v80 > 0xFF)
    goto LABEL_1007;
  if (!*(_BYTE *)(a3 + 52 * v80 + 1280))
    goto LABEL_1007;
  v87 = *(_DWORD *)(a3 + 52 * v80 + 1284);
  if (v87 > 31)
    goto LABEL_1007;
  v88 = (_BYTE *)(a3 + 40 * v87);
  if (!*v88)
    goto LABEL_1007;
  if (!*(_DWORD *)(a3 + 40 * v87 + 8))
  {
LABEL_187:
    v95 = *(_DWORD *)(a3 + 40 * v87 + 12);
    if ((v95 - 22) < 0xFFFFFFE7)
      goto LABEL_952;
    goto LABEL_191;
  }
LABEL_175:
  v89 = (v24 + 2) >> 3;
  v24 = (v24 + 2) & 7;
  v72 += v89;
  v90 = v26 - (_DWORD)v72;
  if (v26 - (int)v72 < 4)
  {
    if (v90 >= 1)
    {
      v92 = *v72;
      if (v90 == 1)
      {
        v91 = v92 << 24;
      }
      else
      {
        v94 = (v92 << 16) | (v72[1] << 8);
        if (v90 != 2)
          v94 |= v72[2];
        v91 = v94 << 8;
      }
      goto LABEL_186;
    }
    v93 = v24 | v90;
    if (a4)
    {
      if (v93)
        goto LABEL_952;
      v23 = 0;
      goto LABEL_187;
    }
    v23 = 0;
    if (v93)
      goto LABEL_658;
  }
  else
  {
    v91 = bswap32(*(_DWORD *)v72);
LABEL_186:
    v23 = v91 << v24;
    if (a4)
      goto LABEL_187;
  }
LABEL_190:
  v95 = *(_DWORD *)(a3 + 40 * v87 + 12);
  if ((v95 - 22) < 0xFFFFFFE7)
    goto LABEL_658;
LABEL_191:
  DWORD2(v457) = v23 >> (28 - v95);
  v96 = v95 + v24 + 4;
  v24 = v96 & 7;
  v72 += v96 >> 3;
  v97 = v26 - (_DWORD)v72;
  if (v26 - (int)v72 >= 4)
  {
    v98 = bswap32(*(_DWORD *)v72);
    goto LABEL_202;
  }
  if (v97 < 1)
  {
    v100 = v24 | v97;
    if (a4)
    {
      if (v100)
        goto LABEL_952;
    }
    else if (v100)
    {
      goto LABEL_1138;
    }
    v102 = 0;
    v23 = 0;
    WORD6(v457) = 0;
    if (!*(_DWORD *)(a3 + 40 * v87 + 36))
      goto LABEL_203;
    goto LABEL_234;
  }
  v99 = *v72;
  if (v97 == 1)
  {
    v98 = v99 << 24;
  }
  else
  {
    v101 = (v99 << 16) | (v72[1] << 8);
    if (v97 != 2)
      v101 |= v72[2];
    v98 = v101 << 8;
  }
LABEL_202:
  v100 = 0;
  v102 = v98 << v24;
  WORD6(v457) = 0;
  v23 = v98 << v24;
  if (*(_DWORD *)(a3 + 40 * v87 + 36))
    goto LABEL_234;
LABEL_203:
  v103 = v102 >> 31;
  BYTE12(v457) = v102 < 0;
  v104 = (v24 + 1) >> 3;
  v24 = (v24 + 1) & 7;
  v72 += v104;
  v105 = v26 - (_DWORD)v72;
  if (v26 - (int)v72 >= 4)
  {
    v106 = bswap32(*(_DWORD *)v72);
    goto LABEL_217;
  }
  if (v105 < 1)
  {
    v100 = v24 | v105;
    if (a4)
    {
      if (v100)
        goto LABEL_952;
LABEL_220:
      v23 = 0;
      if (v102 < 0)
        goto LABEL_221;
      goto LABEL_234;
    }
    if (!v100)
      goto LABEL_220;
LABEL_1138:
    v23 = 0;
    goto LABEL_658;
  }
  v107 = *v72;
  if (v105 == 1)
  {
    v106 = v107 << 24;
  }
  else
  {
    v108 = (v107 << 16) | (v72[1] << 8);
    if (v105 != 2)
      v108 |= v72[2];
    v106 = v108 << 8;
  }
LABEL_217:
  v23 = v106 << v24;
  if ((v102 & 0x80000000) == 0)
  {
    v100 = 0;
    goto LABEL_234;
  }
LABEL_221:
  BYTE13(v457) = (v23 & 0x80000000) != 0;
  v109 = (v24 + 1) >> 3;
  v24 = (v24 + 1) & 7;
  v72 += v109;
  v110 = v26 - (_DWORD)v72;
  if (v26 - (int)v72 < 4)
  {
    if (v110 < 1)
    {
      v112 = v24 | v110;
      if (a4)
      {
        if (v112)
          goto LABEL_952;
        v23 = 0;
      }
      else
      {
        v23 = 0;
        if (v112)
          goto LABEL_658;
      }
    }
    else
    {
      v111 = *v72;
      if (v110 == 1)
      {
        v23 = v111 << 24;
      }
      else
      {
        v113 = (v111 << 16) | (v72[1] << 8);
        if (v110 != 2)
          v113 |= v72[2];
        v23 = v113 << 8;
      }
    }
  }
  else
  {
    v23 = bswap32(*(_DWORD *)v72);
  }
  v23 <<= v24;
  v100 = v103;
LABEL_234:
  if (v17 != 5)
    goto LABEL_329;
  if (v23 >= 0x80000)
  {
    v114 = __clz(v23);
    v115 = v23 << (v114 + 1) >> -(char)v114;
    if (!v114)
      v115 = 0;
    LODWORD(v458) = v115 + ~(-1 << v114);
    v116 = v114 + v24 + v114 + 1;
    v24 = v116 & 7;
    v72 += v116 >> 3;
    v117 = v26 - (_DWORD)v72;
    if (v26 - (int)v72 < 4)
    {
      if (v117 < 1)
      {
        v123 = v24 | v117;
        if (a4)
        {
          if (v123)
            goto LABEL_952;
          v23 = 0;
        }
        else
        {
          v23 = 0;
          if (v123)
            goto LABEL_658;
        }
      }
      else
      {
        v121 = *v72;
        if (v117 == 1)
        {
          v23 = v121 << 24;
        }
        else
        {
          v125 = (v121 << 16) | (v72[1] << 8);
          if (v117 != 2)
            v125 |= v72[2];
          v23 = v125 << 8;
        }
      }
    }
    else
    {
      v23 = bswap32(*(_DWORD *)v72);
    }
    v23 <<= v24;
    goto LABEL_329;
  }
  v118 = (v24 + 1) >> 3;
  v24 = (v24 + 1) & 7;
  v72 += v118;
  v119 = v26 - (_DWORD)v72;
  if (v26 - (int)v72 >= 4)
  {
    v120 = bswap32(*(_DWORD *)v72);
    goto LABEL_260;
  }
  if (v119 < 1)
  {
    v124 = v24 | v119;
    if (a4)
    {
      if (v124)
        goto LABEL_952;
      v23 = 0;
    }
    else
    {
      v23 = 0;
      if (v124)
        goto LABEL_658;
    }
  }
  else
  {
    v122 = *v72;
    if (v119 == 1)
    {
      v120 = v122 << 24;
    }
    else
    {
      v126 = (v122 << 16) | (v72[1] << 8);
      if (v119 != 2)
        v126 |= v72[2];
      v120 = v126 << 8;
    }
LABEL_260:
    v23 = v120 << v24;
  }
  v127 = 0;
  v128 = v23;
  while (2)
  {
    v129 = (v24 + 1) & 7;
    v72 += (v24 + 1) >> 3;
    v130 = v26 - (_DWORD)v72;
    if (v26 - (int)v72 >= 4)
    {
      v131 = bswap32(*(_DWORD *)v72);
      goto LABEL_274;
    }
    if (v130 < 1)
    {
      v133 = v129 | v130;
      if (a4)
      {
        if (v133)
          goto LABEL_952;
        v23 = 0;
        if ((v128 & 0x80000000) != 0)
          goto LABEL_280;
      }
      else
      {
        if (v133)
        {
LABEL_1131:
          v23 = 0;
          goto LABEL_1132;
        }
        v23 = 0;
        if ((v128 & 0x80000000) != 0)
          goto LABEL_284;
      }
      goto LABEL_275;
    }
    v132 = *v72;
    if (v130 == 1)
    {
      v131 = v132 << 24;
    }
    else
    {
      v134 = (v132 << 16) | (v72[1] << 8);
      if (v130 != 2)
        v134 |= v72[2];
      v131 = v134 << 8;
    }
LABEL_274:
    v133 = v131 << v129;
    if ((v128 & 0x80000000) == 0)
    {
LABEL_275:
      --v127;
      v128 = v133;
      v24 = (v24 + 1) & 7;
      continue;
    }
    break;
  }
  v23 = v133;
  if (!a4)
  {
LABEL_284:
    if (-v127 > 0x1E)
      goto LABEL_1132;
    if ((1 - v127) < 0x19)
      goto LABEL_282;
LABEL_286:
    v138 = (((_BYTE)v24 + 1) & 7) - v127;
    v24 = (v138 + 1) & 7;
    v139 = &v72[(v138 - 15) >> 3];
    v140 = v26 - (_DWORD)v139;
    if (v26 - (int)v139 < 4)
    {
      if (v140 < 1)
      {
        v145 = v24 | v140;
        if (a4)
        {
          if (v145)
            goto LABEL_952;
          v146 = 0;
        }
        else
        {
          v146 = 0;
          if (v145)
            goto LABEL_438;
        }
LABEL_307:
        v72 = v139 + 2;
        v149 = v26 - ((_DWORD)v139 + 2);
        if (v149 < 4)
        {
          if (v149 < 1)
          {
            v152 = v24 | v149;
            if (a4)
            {
              if (v152)
                goto LABEL_952;
              v150 = 0;
            }
            else
            {
              v150 = 0;
              if (v152)
                goto LABEL_1140;
            }
          }
          else
          {
            v151 = *v72;
            if (v149 == 1)
            {
              v150 = v151 << 24;
            }
            else
            {
              v153 = (v151 << 16) | (v139[3] << 8);
              if (v149 != 2)
                v153 |= v139[4];
              v150 = v153 << 8;
            }
          }
        }
        else
        {
          v150 = bswap32(*(_DWORD *)v72);
        }
        v155 = v23 >> (v127 + 47);
        v23 = v150 << v24;
        v154 = __PAIR64__(v155, v146) >> 16;
        goto LABEL_328;
      }
      v143 = *v139;
      if (v140 == 1)
      {
        v141 = v143 << 24;
      }
      else
      {
        v148 = (v143 << 16) | (v139[1] << 8);
        if (v140 != 2)
          v148 |= v139[2];
        v141 = v148 << 8;
      }
    }
    else
    {
      v141 = bswap32(*(_DWORD *)v139);
    }
    v146 = v141 << v24;
    goto LABEL_307;
  }
LABEL_280:
  if (-v127 > 0x1E)
    goto LABEL_952;
  if ((1 - v127) > 0x18)
    goto LABEL_286;
LABEL_282:
  v135 = (((_BYTE)v24 + 1) & 7) - v127 + 1;
  v24 = v135 & 7;
  v72 += v135 >> 3;
  v136 = v26 - (_DWORD)v72;
  if (v26 - (int)v72 >= 4)
  {
    v137 = bswap32(*(_DWORD *)v72);
    goto LABEL_323;
  }
  if (v136 >= 1)
  {
    v142 = *v72;
    if (v136 == 1)
    {
      v137 = v142 << 24;
    }
    else
    {
      v147 = (v142 << 16) | (v72[1] << 8);
      if (v136 != 2)
        v147 |= v72[2];
      v137 = v147 << 8;
    }
    goto LABEL_323;
  }
  v144 = v24 | v136;
  if (!a4)
  {
    v137 = 0;
    if (!v144)
      goto LABEL_323;
LABEL_1140:
    v22 = 4294954582;
    v23 = 0;
    goto LABEL_659;
  }
  if (v144)
    goto LABEL_952;
  v137 = 0;
LABEL_323:
  v154 = v23 >> (v127 + 31);
  v23 = v137 << v24;
LABEL_328:
  LODWORD(v458) = v154 + ~(-1 << (1 - v127));
LABEL_329:
  DWORD2(v458) = 0;
  v156 = *(_DWORD *)(a3 + 40 * v87 + 16);
  if (v156)
    goto LABEL_443;
  v157 = *(_DWORD *)(a3 + 40 * v87 + 20);
  v158 = v157 - 22;
  if (a4)
  {
    if (v158 < 0xFFFFFFE7)
      goto LABEL_952;
  }
  else if (v158 < 0xFFFFFFE7)
  {
    goto LABEL_658;
  }
  DWORD1(v458) = v23 >> (28 - v157);
  v159 = v24 + v157 + 4;
  v24 = v159 & 7;
  v72 += v159 >> 3;
  v160 = v26 - (_DWORD)v72;
  if (v26 - (int)v72 < 4)
  {
    if (v160 < 1)
    {
      v162 = v24 | v160;
      if (a4)
      {
        if (v162)
          goto LABEL_952;
        v23 = 0;
      }
      else
      {
        v23 = 0;
        if (v162)
          goto LABEL_658;
      }
    }
    else
    {
      v161 = *v72;
      if (v160 == 1)
      {
        v23 = v161 << 24;
      }
      else
      {
        v163 = (v161 << 16) | (v72[1] << 8);
        if (v160 != 2)
          v163 |= v72[2];
        v23 = v163 << 8;
      }
    }
  }
  else
  {
    v23 = bswap32(*(_DWORD *)v72);
  }
  v23 <<= v24;
  if (!*(_DWORD *)(a3 + 52 * v80 + 1292) || v100)
    goto LABEL_569;
  if (v23 >= 0x80000)
  {
    v164 = __clz(v23);
    v165 = v23 << (v164 + 1) >> -(char)v164;
    if (!v164)
      v165 = 0;
    v166 = v164 + v24 + v164 + 1;
    v24 = v166 & 7;
    v72 += v166 >> 3;
    v167 = v26 - (_DWORD)v72;
    if (v26 - (int)v72 < 4)
    {
      if (v167 < 1)
      {
        v173 = v24 | v167;
        if (a4)
        {
          if (v173)
            goto LABEL_952;
          v23 = 0;
        }
        else
        {
          v23 = 0;
          if (v173)
            goto LABEL_658;
        }
      }
      else
      {
        v171 = *v72;
        if (v167 == 1)
        {
          v23 = v171 << 24;
        }
        else
        {
          v175 = (v171 << 16) | (v72[1] << 8);
          if (v167 != 2)
            v175 |= v72[2];
          v23 = v175 << 8;
        }
      }
    }
    else
    {
      v23 = bswap32(*(_DWORD *)v72);
    }
    v202 = v165 + ~(-1 << v164);
    v23 <<= v24;
    goto LABEL_442;
  }
  v168 = (v24 + 1) >> 3;
  v24 = (v24 + 1) & 7;
  v72 += v168;
  v169 = v26 - (_DWORD)v72;
  if (v26 - (int)v72 >= 4)
  {
    v170 = bswap32(*(_DWORD *)v72);
    goto LABEL_373;
  }
  if (v169 < 1)
  {
    v174 = v24 | v169;
    if (a4)
    {
      if (v174)
        goto LABEL_952;
      v23 = 0;
    }
    else
    {
      v23 = 0;
      if (v174)
        goto LABEL_658;
    }
  }
  else
  {
    v172 = *v72;
    if (v169 == 1)
    {
      v170 = v172 << 24;
    }
    else
    {
      v176 = (v172 << 16) | (v72[1] << 8);
      if (v169 != 2)
        v176 |= v72[2];
      v170 = v176 << 8;
    }
LABEL_373:
    v23 = v170 << v24;
  }
  v177 = 0;
  v178 = v23;
  while (2)
  {
    v129 = (v24 + 1) & 7;
    v72 += (v24 + 1) >> 3;
    v179 = v26 - (_DWORD)v72;
    if (v26 - (int)v72 >= 4)
    {
      v180 = bswap32(*(_DWORD *)v72);
      goto LABEL_387;
    }
    if (v179 < 1)
    {
      v182 = v129 | v179;
      if (a4)
      {
        if (v182)
          goto LABEL_952;
        v23 = 0;
        if ((v178 & 0x80000000) != 0)
          goto LABEL_393;
      }
      else
      {
        if (v182)
          goto LABEL_1131;
        v23 = 0;
        if ((v178 & 0x80000000) != 0)
          goto LABEL_397;
      }
      goto LABEL_388;
    }
    v181 = *v72;
    if (v179 == 1)
    {
      v180 = v181 << 24;
    }
    else
    {
      v183 = (v181 << 16) | (v72[1] << 8);
      if (v179 != 2)
        v183 |= v72[2];
      v180 = v183 << 8;
    }
LABEL_387:
    v182 = v180 << v129;
    if ((v178 & 0x80000000) == 0)
    {
LABEL_388:
      --v177;
      v178 = v182;
      v24 = (v24 + 1) & 7;
      continue;
    }
    break;
  }
  v23 = v182;
  if (!a4)
  {
LABEL_397:
    if (-v177 <= 0x1E)
    {
      if ((1 - v177) < 0x19)
        goto LABEL_395;
      goto LABEL_399;
    }
LABEL_1132:
    v22 = 4294954582;
    LOBYTE(v24) = v129;
    goto LABEL_659;
  }
LABEL_393:
  if (-v177 > 0x1E)
    goto LABEL_952;
  if ((1 - v177) > 0x18)
  {
LABEL_399:
    v187 = (((_BYTE)v24 + 1) & 7) - v177;
    v24 = (v187 + 1) & 7;
    v139 = &v72[(v187 - 15) >> 3];
    v188 = v26 - (_DWORD)v139;
    if (v26 - (int)v139 >= 4)
    {
      v189 = bswap32(*(_DWORD *)v139);
LABEL_419:
      v194 = v189 << v24;
      goto LABEL_420;
    }
    if (v188 >= 1)
    {
      v191 = *v139;
      if (v188 == 1)
      {
        v189 = v191 << 24;
      }
      else
      {
        v196 = (v191 << 16) | (v139[1] << 8);
        if (v188 != 2)
          v196 |= v139[2];
        v189 = v196 << 8;
      }
      goto LABEL_419;
    }
    v193 = v24 | v188;
    if (a4)
    {
      if (v193)
        goto LABEL_952;
      v194 = 0;
LABEL_420:
      v72 = v139 + 2;
      v197 = v26 - ((_DWORD)v139 + 2);
      if (v197 < 4)
      {
        if (v197 < 1)
        {
          v200 = v24 | v197;
          if (a4)
          {
            if (v200)
              goto LABEL_952;
            v198 = 0;
          }
          else
          {
            v198 = 0;
            if (v200)
              goto LABEL_1140;
          }
        }
        else
        {
          v199 = *v72;
          if (v197 == 1)
          {
            v198 = v199 << 24;
          }
          else
          {
            v201 = (v199 << 16) | (v139[3] << 8);
            if (v197 != 2)
              v201 |= v139[4];
            v198 = v201 << 8;
          }
        }
      }
      else
      {
        v198 = bswap32(*(_DWORD *)v72);
      }
      v204 = v23 >> (v177 + 47);
      v23 = v198 << v24;
      v203 = __PAIR64__(v204, v194) >> 16;
      goto LABEL_441;
    }
    v194 = 0;
    if (!v193)
      goto LABEL_420;
LABEL_438:
    v22 = 4294954582;
    v23 = 0;
    BytePtr = v139;
    goto LABEL_973;
  }
LABEL_395:
  v184 = (((_BYTE)v24 + 1) & 7) - v177 + 1;
  v24 = v184 & 7;
  v72 += v184 >> 3;
  v185 = v26 - (_DWORD)v72;
  if (v26 - (int)v72 >= 4)
  {
    v186 = bswap32(*(_DWORD *)v72);
    goto LABEL_436;
  }
  if (v185 >= 1)
  {
    v190 = *v72;
    if (v185 == 1)
    {
      v186 = v190 << 24;
    }
    else
    {
      v195 = (v190 << 16) | (v72[1] << 8);
      if (v185 != 2)
        v195 |= v72[2];
      v186 = v195 << 8;
    }
    goto LABEL_436;
  }
  v192 = v24 | v185;
  if (!a4)
  {
    v186 = 0;
    if (!v192)
      goto LABEL_436;
    goto LABEL_1140;
  }
  if (v192)
    goto LABEL_952;
  v186 = 0;
LABEL_436:
  v203 = v23 >> (v177 + 31);
  v23 = v186 << v24;
LABEL_441:
  v202 = v203 + ~(-1 << (1 - v177));
LABEL_442:
  DWORD2(v458) = ((v202 + 1) >> 1) - ((v202 + 1) >> 1) * 2 * ((v202 + 1) & 1);
LABEL_443:
  if (v156 != 1 || *(_DWORD *)(a3 + 40 * v87 + 24))
    goto LABEL_569;
  if (v23 >= 0x80000)
  {
    v205 = v24 + 2 * __clz(v23) + 1;
LABEL_486:
    v24 = v205 & 7;
    v72 += v205 >> 3;
    v224 = v26 - (_DWORD)v72;
    if (v26 - (int)v72 >= 4)
      goto LABEL_499;
    if (v224 >= 1)
    {
      v225 = *v72;
      if (v224 == 1)
      {
        v23 = v225 << 24;
      }
      else
      {
        v227 = (v225 << 16) | (v72[1] << 8);
        if (v224 != 2)
          v227 |= v72[2];
        v23 = v227 << 8;
      }
      goto LABEL_500;
    }
    v226 = v24 | v224;
    if (!a4)
      goto LABEL_513;
LABEL_491:
    if (v226)
      goto LABEL_952;
    v23 = 0;
    goto LABEL_500;
  }
  v206 = (v24 + 1) >> 3;
  v24 = (v24 + 1) & 7;
  v72 += v206;
  v207 = v26 - (_DWORD)v72;
  if (v26 - (int)v72 >= 4)
  {
    v208 = bswap32(*(_DWORD *)v72);
    goto LABEL_458;
  }
  if (v207 < 1)
  {
    v210 = v24 | v207;
    if (a4)
    {
      if (v210)
        goto LABEL_952;
      v23 = 0;
    }
    else
    {
      v23 = 0;
      if (v210)
        goto LABEL_658;
    }
  }
  else
  {
    v209 = *v72;
    if (v207 == 1)
    {
      v208 = v209 << 24;
    }
    else
    {
      v211 = (v209 << 16) | (v72[1] << 8);
      if (v207 != 2)
        v211 |= v72[2];
      v208 = v211 << 8;
    }
LABEL_458:
    v23 = v208 << v24;
  }
  v212 = 1;
  v213 = v23;
  while (2)
  {
    v214 = (v24 + 1) & 7;
    v72 += (v24 + 1) >> 3;
    v215 = v26 - (_DWORD)v72;
    if (v26 - (int)v72 >= 4)
    {
      v216 = bswap32(*(_DWORD *)v72);
      goto LABEL_472;
    }
    if (v215 < 1)
    {
      v218 = v214 | v215;
      if (a4)
      {
        if (v218)
          goto LABEL_952;
        if ((v213 & 0x80000000) != 0)
          goto LABEL_478;
        v218 = 0;
      }
      else
      {
        if (v218)
        {
LABEL_1136:
          v23 = 0;
          goto LABEL_1137;
        }
        v23 = 0;
        if ((v213 & 0x80000000) != 0)
          goto LABEL_483;
      }
      goto LABEL_473;
    }
    v217 = *v72;
    if (v215 == 1)
    {
      v216 = v217 << 24;
    }
    else
    {
      v219 = (v217 << 16) | (v72[1] << 8);
      if (v215 != 2)
        v219 |= v72[2];
      v216 = v219 << 8;
    }
LABEL_472:
    v218 = v216 << v214;
    if ((v213 & 0x80000000) == 0)
    {
LABEL_473:
      ++v212;
      v213 = v218;
      v24 = (v24 + 1) & 7;
      continue;
    }
    break;
  }
  v23 = v218;
  if (!a4)
  {
LABEL_483:
    if (v212 - 1 > 0x1E)
      goto LABEL_1137;
    if (v212 >= 0x19)
    {
      v228 = (((_BYTE)v24 + 1) & 7) + v212;
      v229 = (v228 - 16) >> 3;
      v24 = v228 & 7;
      v222 = &v72[v229];
      v230 = v26 - ((_DWORD)v72 + v229);
      if (v230 > 0 || !(v24 | v230))
        goto LABEL_498;
      goto LABEL_1141;
    }
LABEL_485:
    v205 = (((_BYTE)v24 + 1) & 7) + v212;
    goto LABEL_486;
  }
LABEL_478:
  if (v212 - 1 > 0x1E)
    goto LABEL_952;
  if (v212 <= 0x18)
    goto LABEL_485;
  v220 = (((_BYTE)v24 + 1) & 7) + v212;
  v221 = (v220 - 16) >> 3;
  v24 = v220 & 7;
  v222 = &v72[v221];
  v223 = v26 - ((_DWORD)v72 + v221);
  if (v223 <= 0 && v24 | v223)
  {
LABEL_952:
    LODWORD(v22) = -12714;
    goto LABEL_974;
  }
LABEL_498:
  v72 = v222 + 2;
  v231 = v26 - ((_DWORD)v222 + 2);
  if (v231 >= 4)
  {
LABEL_499:
    v23 = bswap32(*(_DWORD *)v72);
    goto LABEL_500;
  }
  if (v231 >= 1)
  {
    v233 = *v72;
    if (v231 == 1)
    {
      v23 = v233 << 24;
    }
    else
    {
      v238 = (v233 << 16) | (v222[3] << 8);
      if (v231 != 2)
        v238 |= v222[4];
      v23 = v238 << 8;
    }
    goto LABEL_500;
  }
  v226 = v24 | v231;
  if (a4)
    goto LABEL_491;
LABEL_513:
  v23 = 0;
  if (v226)
    goto LABEL_658;
LABEL_500:
  v23 <<= v24;
  if (*(_DWORD *)(a3 + 52 * v80 + 1292) != 1 || BYTE12(v457))
    goto LABEL_569;
  if (v23 >= 0x80000)
  {
    v232 = v24 + 2 * __clz(v23) + 1;
LABEL_554:
    v24 = v232 & 7;
    v72 += v232 >> 3;
    v251 = v26 - (_DWORD)v72;
    if (v26 - (int)v72 >= 4)
      goto LABEL_567;
    if (v251 >= 1)
    {
      v252 = *v72;
      if (v251 == 1)
      {
        v23 = v252 << 24;
      }
      else
      {
        v254 = (v252 << 16) | (v72[1] << 8);
        if (v251 != 2)
          v254 |= v72[2];
        v23 = v254 << 8;
      }
      goto LABEL_568;
    }
    v253 = v24 | v251;
    if (!a4)
      goto LABEL_1122;
LABEL_559:
    if (v253)
      goto LABEL_952;
    v23 = 0;
LABEL_568:
    v23 <<= v24;
LABEL_569:
    HIDWORD(v458) = 0;
    if (*(_DWORD *)(a3 + 52 * v80 + 1328))
    {
      if (a4)
      {
        if (v23 < 0x80000)
          goto LABEL_952;
      }
      else if (v23 < 0x80000)
      {
        goto LABEL_658;
      }
      v259 = __clz(v23);
      v260 = v23 << (v259 + 1) >> -(char)v259;
      if (!v259)
        v260 = 0;
      HIDWORD(v458) = v260 + ~(-1 << v259);
      v261 = v259 + v24 + v259 + 1;
      v24 = v261 & 7;
      v72 += v261 >> 3;
      v262 = v26 - (_DWORD)v72;
      if (v26 - (int)v72 < 4)
      {
        if (v262 < 1)
        {
          v264 = v24 | v262;
          if (a4)
          {
            if (v264)
              goto LABEL_952;
            v23 = 0;
          }
          else
          {
            v23 = 0;
            if (v264)
              goto LABEL_658;
          }
        }
        else
        {
          v263 = *v72;
          if (v262 == 1)
          {
            v23 = v263 << 24;
          }
          else
          {
            v265 = (v263 << 16) | (v72[1] << 8);
            if (v262 != 2)
              v265 |= v72[2];
            v23 = v265 << 8;
          }
        }
      }
      else
      {
        v23 = bswap32(*(_DWORD *)v72);
      }
      v23 <<= v24;
    }
    if (v69 == 6 || v69 == 1)
    {
      LOBYTE(v459) = (v23 & 0x80000000) != 0;
      v266 = (v24 + 1) >> 3;
      v24 = (v24 + 1) & 7;
      v72 += v266;
      v267 = v26 - (_DWORD)v72;
      if (v26 - (int)v72 < 4)
      {
        if (v267 < 1)
        {
          v270 = v24 | v267;
          if (a4)
          {
            if (v270)
              goto LABEL_952;
            v23 = 0;
          }
          else
          {
            v23 = 0;
            if (v270)
              goto LABEL_658;
          }
        }
        else
        {
          v269 = *v72;
          if (v267 == 1)
          {
            v23 = v269 << 24;
          }
          else
          {
            v271 = (v269 << 16) | (v72[1] << 8);
            if (v267 != 2)
              v271 |= v72[2];
            v23 = v271 << 8;
          }
        }
      }
      else
      {
        v23 = bswap32(*(_DWORD *)v72);
      }
      v268 = v23 << v24;
    }
    else
    {
      v268 = v23;
    }
    if (v69 > 8 || ((1 << v69) & 0x16B) == 0)
      goto LABEL_627;
    BYTE1(v459) = v268 < 0;
    v272 = (v24 + 1) >> 3;
    v24 = (v24 + 1) & 7;
    v72 += v272;
    v273 = v26 - (_DWORD)v72;
    if (v26 - (int)v72 >= 4)
    {
      v274 = bswap32(*(_DWORD *)v72);
      goto LABEL_624;
    }
    if (v273 < 1)
    {
      if (v24 | v273)
        v276 = 1;
      else
        v276 = v268 < 0;
      v277 = !v276;
      if (a4)
      {
        if ((v277 & 1) == 0)
          goto LABEL_952;
        v23 = 0;
      }
      else
      {
        v23 = 0;
        if ((v277 & 1) == 0)
          goto LABEL_658;
      }
      goto LABEL_625;
    }
    v275 = *v72;
    if (v273 == 1)
    {
      v274 = v275 << 24;
    }
    else
    {
      v278 = (v275 << 16) | (v72[1] << 8);
      if (v273 != 2)
        v278 |= v72[2];
      v274 = v278 << 8;
    }
LABEL_624:
    v23 = v274 << v24;
    if ((v268 & 0x80000000) == 0)
    {
LABEL_625:
      *(_QWORD *)((char *)&v459 + 4) = *(_QWORD *)(a3 + 52 * v80 + 1308);
      goto LABEL_626;
    }
    if (a4)
    {
      if (v23 < 0x80000)
        goto LABEL_952;
    }
    else if (v23 < 0x80000)
    {
      goto LABEL_658;
    }
    v285 = __clz(v23);
    v286 = v23 << (v285 + 1) >> -(char)v285;
    if (!v285)
      v286 = 0;
    v287 = v286 + ~(-1 << v285);
    DWORD1(v459) = v287;
    v288 = v285 + v24 + v285 + 1;
    v24 = v288 & 7;
    v72 += v288 >> 3;
    v289 = v26 - (_DWORD)v72;
    if (v26 - (int)v72 >= 4)
    {
      v290 = bswap32(*(_DWORD *)v72);
      goto LABEL_759;
    }
    if (v289 < 1)
    {
      v294 = v24 | v289;
      if (a4)
      {
        if (v294)
          goto LABEL_952;
        v23 = 0;
        goto LABEL_760;
      }
      v23 = 0;
      if (v294)
        goto LABEL_658;
    }
    else
    {
      v291 = *v72;
      if (v289 == 1)
      {
        v290 = v291 << 24;
      }
      else
      {
        v329 = (v291 << 16) | (v72[1] << 8);
        if (v289 != 2)
          v329 |= v72[2];
        v290 = v329 << 8;
      }
LABEL_759:
      v23 = v290 << v24;
      if (a4)
      {
LABEL_760:
        if (v287 > 0x1F)
          goto LABEL_1007;
LABEL_986:
        if (v69 != 6 && v69 != 1)
          goto LABEL_626;
        if (a4)
        {
          if (v23 < 0x80000)
            goto LABEL_952;
        }
        else if (v23 < 0x80000)
        {
          goto LABEL_658;
        }
        v403 = __clz(v23);
        v404 = v23 << (v403 + 1) >> -(char)v403;
        if (!v403)
          v404 = 0;
        v405 = v404 + ~(-1 << v403);
        DWORD2(v459) = v405;
        v406 = v403 + v24 + v403 + 1;
        v24 = v406 & 7;
        v72 += v406 >> 3;
        v407 = v26 - (_DWORD)v72;
        if (v26 - (int)v72 >= 4)
        {
          v408 = bswap32(*(_DWORD *)v72);
          goto LABEL_1005;
        }
        if (v407 < 1)
        {
          v410 = v24 | v407;
          if (a4)
          {
            if (v410)
              goto LABEL_952;
            v23 = 0;
            goto LABEL_1006;
          }
          v23 = 0;
          if (v410)
            goto LABEL_658;
        }
        else
        {
          v409 = *v72;
          if (v407 == 1)
          {
            v408 = v409 << 24;
          }
          else
          {
            v411 = (v409 << 16) | (v72[1] << 8);
            if (v407 != 2)
              v411 |= v72[2];
            v408 = v411 << 8;
          }
LABEL_1005:
          v23 = v408 << v24;
          if (a4)
          {
LABEL_1006:
            v268 = v23;
            if (v405 > 0x1F)
            {
LABEL_1007:
              LODWORD(v22) = -12719;
              goto LABEL_974;
            }
LABEL_627:
            if (((1 << v69) & 0x294) != 0)
            {
LABEL_628:
              if (v69 != 6 && v69 != 1)
                goto LABEL_666;
              BYTE13(v459) = v268 < 0;
              v279 = (v24 + 1) >> 3;
              v24 = (v24 + 1) & 7;
              v72 += v279;
              v280 = v26 - (_DWORD)v72;
              if (v26 - (int)v72 < 4)
              {
                if (v280 < 1)
                {
                  v284 = v24 | v280;
                  if (a4)
                  {
                    if (v284)
                      goto LABEL_952;
                    v23 = 0;
                  }
                  else
                  {
                    v23 = 0;
                    if (v284)
                      goto LABEL_658;
                  }
                }
                else
                {
                  v281 = *v72;
                  if (v280 == 1)
                  {
                    v23 = v281 << 24;
                  }
                  else
                  {
                    v292 = (v281 << 16) | (v72[1] << 8);
                    if (v280 != 2)
                      v292 |= v72[2];
                    v23 = v292 << 8;
                  }
                }
              }
              else
              {
                v23 = bswap32(*(_DWORD *)v72);
              }
              v23 <<= v24;
              if ((v268 & 0x80000000) == 0)
              {
LABEL_665:
                v268 = v23;
LABEL_666:
                v295 = a3 + 52 * v80;
                v450 = v87;
                if ((!*(_DWORD *)(v295 + 1316) || v69 > 8 || ((1 << v69) & 0x129) == 0)
                  && (*(_DWORD *)(a3 + 52 * v80 + 1320) != 1 || v69 != 6 && v69 != 1))
                {
                  v298 = (int)BytePtr;
                  goto LABEL_719;
                }
                *(_QWORD *)&v455 = v72;
                DWORD2(v455) = v268;
                v296 = (_DWORD)v72 - (_DWORD)BytePtr;
                BYTE12(v455) = v24;
                if (a4)
                {
                  if (Length < v296)
                    goto LABEL_952;
                  v297 = a4;
                  goto LABEL_717;
                }
                if (Length >= v296)
                {
                  v297 = 0;
LABEL_717:
                  v313 = PullSliceHeaderPredWeightTable((uint64_t *)&v454, &v456, (uint64_t)v88, v297);
                  if (v313)
                  {
                    LODWORD(v22) = v313;
                    goto LABEL_974;
                  }
                  v72 = (unsigned __int8 *)v455;
                  v268 = DWORD2(v455);
                  v24 = BYTE12(v455);
                  Length = DWORD2(v454);
                  v298 = v454;
LABEL_719:
                  v314 = v298 + Length;
                  if (!(_DWORD)v456)
                  {
                    v23 = v268;
                    BytePtr = v72;
                    goto LABEL_856;
                  }
                  v315 = (v24 + 1) >> 3;
                  v24 = (v24 + 1) & 7;
                  BytePtr = &v72[v315];
                  v316 = v314 - ((_DWORD)v72 + v315);
                  if (DWORD1(v456) == 5)
                  {
                    BYTE13(v468) = v268 < 0;
                    if (v316 >= 4)
                    {
                      v317 = bswap32(*(_DWORD *)BytePtr);
                      goto LABEL_741;
                    }
                    if (v316 < 1)
                    {
                      v320 = v24 | v316;
                      if (a4)
                      {
                        if (v320)
                          goto LABEL_952;
                        v23 = 0;
                        goto LABEL_742;
                      }
                      v23 = 0;
                      if (!v320)
                        goto LABEL_742;
                    }
                    else
                    {
                      v318 = *BytePtr;
                      if (v316 == 1)
                      {
                        v317 = v318 << 24;
                      }
                      else
                      {
                        v322 = (v318 << 16) | (BytePtr[1] << 8);
                        if (v316 != 2)
                          v322 |= BytePtr[2];
                        v317 = v322 << 8;
                      }
LABEL_741:
                      v23 = v317 << v24;
LABEL_742:
                      BYTE14(v468) = (v23 & 0x80000000) != 0;
                      v323 = (v24 + 1) >> 3;
                      v24 = (v24 + 1) & 7;
                      BytePtr += v323;
                      v324 = v314 - (_DWORD)BytePtr;
                      if (v314 - (int)BytePtr >= 4)
                      {
                        v23 = bswap32(*(_DWORD *)BytePtr);
                        goto LABEL_855;
                      }
                      if (v324 >= 1)
                      {
                        v325 = *BytePtr;
                        if (v324 == 1)
                        {
                          v23 = v325 << 24;
                        }
                        else
                        {
                          v328 = (v325 << 16) | (BytePtr[1] << 8);
                          if (v324 != 2)
                            v328 |= BytePtr[2];
                          v23 = v328 << 8;
                        }
                        goto LABEL_855;
                      }
                      v326 = v24 | v324;
                      if (a4)
                      {
                        if (v326)
                          goto LABEL_952;
                        v23 = 0;
LABEL_855:
                        v23 <<= v24;
LABEL_856:
                        v356 = *(_DWORD *)(a3 + 52 * v80 + 1288);
                        BYTE4(v471) = v356;
                        if (!*(_DWORD *)(v295 + 1316) || (LOBYTE(v357) = 1, (_DWORD)v457) && (_DWORD)v457 != 5)
                        {
                          v357 = *(_DWORD *)(a3 + 52 * v80 + 1320);
                          if (v357)
                            LOBYTE(v357) = (_DWORD)v457 == 1 || (_DWORD)v457 == 6;
                        }
                        BYTE5(v471) = v357;
                        if (!v356 || v457 <= 9 && ((1 << v457) & 0x294) != 0)
                        {
                          LOBYTE(v359) = 0;
                          goto LABEL_870;
                        }
                        if (a4)
                        {
                          if (v23 < 0x80000)
                            goto LABEL_952;
LABEL_904:
                          v372 = __clz(v23);
                          v373 = v23 << (v372 + 1) >> -(char)v372;
                          if (!v372)
                            v373 = 0;
                          v374 = v372 + v24 + v372 + 1;
                          v24 = v374 & 7;
                          BytePtr += v374 >> 3;
                          v375 = v298 + Length - (_DWORD)BytePtr;
                          if (v375 >= 4)
                          {
                            v23 = bswap32(*(_DWORD *)BytePtr);
                            goto LABEL_1117;
                          }
                          if (v375 >= 1)
                          {
                            v376 = *BytePtr;
                            if (v375 == 1)
                            {
                              v23 = v376 << 24;
                            }
                            else
                            {
                              v412 = (v376 << 16) | (BytePtr[1] << 8);
                              if (v375 != 2)
                                v412 |= BytePtr[2];
                              v23 = v412 << 8;
                            }
                            goto LABEL_1117;
                          }
                          v402 = v24 | v375;
                          if (a4)
                          {
                            if (v402)
                              goto LABEL_952;
                            v23 = 0;
                            goto LABEL_1117;
                          }
                          v23 = 0;
                          if (!v402)
                          {
LABEL_1117:
                            v359 = v373 + ~(-1 << v372);
                            v23 <<= v24;
LABEL_870:
                            BYTE4(v469) = v359;
                            if (a4)
                            {
                              if (v23 < 0x80000)
                                goto LABEL_952;
LABEL_874:
                              v360 = __clz(v23);
                              v361 = v23 << (v360 + 1) >> -(char)v360;
                              if (!v360)
                                v361 = 0;
                              v362 = v360 + v24 + v360 + 1;
                              v24 = v362 & 7;
                              BytePtr += v362 >> 3;
                              v363 = v314 - (_DWORD)BytePtr;
                              if (v314 - (int)BytePtr >= 4)
                              {
                                v23 = bswap32(*(_DWORD *)BytePtr);
                                goto LABEL_891;
                              }
                              if (v363 >= 1)
                              {
                                v364 = *BytePtr;
                                if (v363 == 1)
                                {
                                  v23 = v364 << 24;
                                }
                                else
                                {
                                  v366 = (v364 << 16) | (BytePtr[1] << 8);
                                  if (v363 != 2)
                                    v366 |= BytePtr[2];
                                  v23 = v366 << 8;
                                }
                                goto LABEL_891;
                              }
                              v365 = v24 | v363;
                              if (a4)
                              {
                                if (v365)
                                  goto LABEL_952;
                                v23 = 0;
                                goto LABEL_891;
                              }
                              v23 = 0;
                              if (!v365)
                              {
LABEL_891:
                                v23 <<= v24;
                                DWORD2(v469) = ((v361 + (1 << v360)) >> 1)
                                             - ((v361 + (1 << v360)) >> 1) * 2 * ((v361 + (1 << v360)) & 1);
                                switch((int)v457)
                                {
                                  case 3:
                                  case 8:
                                    BYTE12(v469) = (v23 & 0x80000000) != 0;
                                    v367 = (v24 + 1) >> 3;
                                    v24 = (v24 + 1) & 7;
                                    BytePtr += v367;
                                    v368 = v314 - (_DWORD)BytePtr;
                                    if (v314 - (int)BytePtr < 4)
                                    {
                                      if (v368 < 1)
                                      {
                                        v370 = v24 | v368;
                                        if (a4)
                                        {
                                          if (v370)
                                            goto LABEL_952;
                                          v23 = 0;
                                        }
                                        else
                                        {
                                          v23 = 0;
                                          if (v370)
                                            goto LABEL_972;
                                        }
                                      }
                                      else
                                      {
                                        v369 = *BytePtr;
                                        if (v368 == 1)
                                        {
                                          v23 = v369 << 24;
                                        }
                                        else
                                        {
                                          v371 = (v369 << 16) | (BytePtr[1] << 8);
                                          if (v368 != 2)
                                            v371 |= BytePtr[2];
                                          v23 = v371 << 8;
                                        }
                                      }
                                    }
                                    else
                                    {
                                      v23 = bswap32(*(_DWORD *)BytePtr);
                                    }
                                    v23 <<= v24;
                                    goto LABEL_913;
                                  case 4:
                                  case 9:
LABEL_913:
                                    if (a4)
                                    {
                                      if (v23 < 0x80000)
                                        goto LABEL_952;
                                    }
                                    else if (v23 < 0x80000)
                                    {
                                      goto LABEL_972;
                                    }
                                    v377 = __clz(v23);
                                    v378 = v23 << (v377 + 1) >> -(char)v377;
                                    if (!v377)
                                      v378 = 0;
                                    v379 = v377 + v24 + v377 + 1;
                                    v24 = v379 & 7;
                                    BytePtr += v379 >> 3;
                                    v380 = v314 - (_DWORD)BytePtr;
                                    if (v314 - (int)BytePtr < 4)
                                    {
                                      if (v380 < 1)
                                      {
                                        v382 = v24 | v380;
                                        if (a4)
                                        {
                                          if (v382)
                                            goto LABEL_952;
                                          v23 = 0;
                                        }
                                        else
                                        {
                                          v23 = 0;
                                          if (v382)
                                            goto LABEL_972;
                                        }
                                      }
                                      else
                                      {
                                        v381 = *BytePtr;
                                        if (v380 == 1)
                                        {
                                          v23 = v381 << 24;
                                        }
                                        else
                                        {
                                          v383 = (v381 << 16) | (BytePtr[1] << 8);
                                          if (v380 != 2)
                                            v383 |= BytePtr[2];
                                          v23 = v383 << 8;
                                        }
                                      }
                                    }
                                    else
                                    {
                                      v23 = bswap32(*(_DWORD *)BytePtr);
                                    }
                                    v23 <<= v24;
                                    LODWORD(v470) = ((v378 + (1 << v377)) >> 1)
                                                  - ((v378 + (1 << v377)) >> 1) * 2 * ((v378 + (1 << v377)) & 1);
LABEL_932:
                                    *((_QWORD *)&v470 + 1) = 0;
                                    DWORD1(v470) = 0;
                                    if (!*(_DWORD *)(a3 + 52 * v80 + 1324))
                                      goto LABEL_1031;
                                    if (a4)
                                    {
                                      if (v23 < 0x80000)
                                        goto LABEL_952;
                                    }
                                    else if (v23 < 0x80000)
                                    {
                                      goto LABEL_972;
                                    }
                                    v384 = __clz(v23);
                                    v385 = v23 << (v384 + 1) >> -(char)v384;
                                    if (!v384)
                                      v385 = 0;
                                    v386 = v385 + ~(-1 << v384);
                                    DWORD1(v470) = v386;
                                    v387 = v384 + v24 + v384 + 1;
                                    v24 = v387 & 7;
                                    BytePtr += v387 >> 3;
                                    v388 = v314 - (_DWORD)BytePtr;
                                    if (v314 - (int)BytePtr < 4)
                                    {
                                      if (v388 < 1)
                                      {
                                        if (v24 | v388)
                                          v391 = 0;
                                        else
                                          v391 = v386 == 1;
                                        v392 = v391;
                                        if (a4)
                                        {
                                          if ((v392 & 1) == 0)
                                            goto LABEL_952;
                                          v23 = 0;
                                        }
                                        else
                                        {
                                          v23 = 0;
                                          if ((v392 & 1) == 0)
                                            goto LABEL_972;
                                        }
                                        goto LABEL_1031;
                                      }
                                      v390 = *BytePtr;
                                      if (v388 == 1)
                                      {
                                        v389 = v390 << 24;
                                      }
                                      else
                                      {
                                        v393 = (v390 << 16) | (BytePtr[1] << 8);
                                        if (v388 != 2)
                                          v393 |= BytePtr[2];
                                        v389 = v393 << 8;
                                      }
                                    }
                                    else
                                    {
                                      v389 = bswap32(*(_DWORD *)BytePtr);
                                    }
                                    v23 = v389 << v24;
                                    if (v386 != 1)
                                    {
                                      if (a4)
                                      {
                                        if (v23 < 0x80000)
                                          goto LABEL_952;
                                      }
                                      else if (v23 < 0x80000)
                                      {
                                        goto LABEL_972;
                                      }
                                      v394 = __clz(v23);
                                      v395 = v23 << (v394 + 1) >> -(char)v394;
                                      if (!v394)
                                        v395 = 0;
                                      v396 = v394 + v24 + v394 + 1;
                                      v24 = v396 & 7;
                                      BytePtr += v396 >> 3;
                                      v397 = v314 - (_DWORD)BytePtr;
                                      if (v314 - (int)BytePtr < 4)
                                      {
                                        if (v397 < 1)
                                        {
                                          v399 = v24 | v397;
                                          if (a4)
                                          {
                                            if (v399)
                                              goto LABEL_952;
                                            v23 = 0;
                                          }
                                          else
                                          {
                                            v23 = 0;
                                            if (v399)
                                              goto LABEL_972;
                                          }
                                        }
                                        else
                                        {
                                          v398 = *BytePtr;
                                          if (v397 == 1)
                                          {
                                            v23 = v398 << 24;
                                          }
                                          else
                                          {
                                            v401 = (v398 << 16) | (BytePtr[1] << 8);
                                            if (v397 != 2)
                                              v401 |= BytePtr[2];
                                            v23 = v401 << 8;
                                          }
                                        }
                                      }
                                      else
                                      {
                                        v23 = bswap32(*(_DWORD *)BytePtr);
                                      }
                                      v23 <<= v24;
                                      DWORD2(v470) = ((v395 + (1 << v394)) >> 1)
                                                   - ((v395 + (1 << v394)) >> 1) * 2 * ((v395 + (1 << v394)) & 1);
                                      if (a4)
                                      {
                                        if (v23 < 0x80000)
                                          goto LABEL_952;
                                      }
                                      else if (v23 < 0x80000)
                                      {
                                        goto LABEL_972;
                                      }
                                      v413 = __clz(v23);
                                      v414 = v23 << (v413 + 1) >> -(char)v413;
                                      if (!v413)
                                        v414 = 0;
                                      v415 = v413 + v24 + v413 + 1;
                                      v24 = v415 & 7;
                                      BytePtr += v415 >> 3;
                                      v416 = v314 - (_DWORD)BytePtr;
                                      if (v314 - (int)BytePtr < 4)
                                      {
                                        if (v416 < 1)
                                        {
                                          v418 = v24 | v416;
                                          if (a4)
                                          {
                                            if (v418)
                                              goto LABEL_952;
                                            v23 = 0;
                                          }
                                          else
                                          {
                                            v23 = 0;
                                            if (v418)
                                              goto LABEL_972;
                                          }
                                        }
                                        else
                                        {
                                          v417 = *BytePtr;
                                          if (v416 == 1)
                                          {
                                            v23 = v417 << 24;
                                          }
                                          else
                                          {
                                            v419 = (v417 << 16) | (BytePtr[1] << 8);
                                            if (v416 != 2)
                                              v419 |= BytePtr[2];
                                            v23 = v419 << 8;
                                          }
                                        }
                                      }
                                      else
                                      {
                                        v23 = bswap32(*(_DWORD *)BytePtr);
                                      }
                                      v23 <<= v24;
                                      HIDWORD(v470) = ((v414 + (1 << v413)) >> 1)
                                                    - ((v414 + (1 << v413)) >> 1) * 2 * ((v414 + (1 << v413)) & 1);
                                    }
LABEL_1031:
                                    if (*(int *)(a3 + 52 * v80 + 1296) < 1
                                      || (*(_DWORD *)(a3 + 52 * v80 + 1300) - 3) > 2)
                                    {
                                      goto LABEL_1050;
                                    }
                                    v420 = vcvtpd_s64_f64(log2((double)((*(_DWORD *)(a3 + 40 * v450 + 28)
                                                                       + 1
                                                                       + (*(_DWORD *)(a3 + 40 * v450 + 28) + 1)
                                                                       * *(_DWORD *)(a3 + 40 * v450 + 32))
                                                                      / (*(_DWORD *)(a3 + 52 * v80 + 1304)
                                                                                     + 1)
                                                                      + 1)));
                                    v421 = v420 - 26;
                                    if (a4)
                                    {
                                      if (v421 < 0xFFFFFFE7)
                                        goto LABEL_952;
                                    }
                                    else if (v421 < 0xFFFFFFE7)
                                    {
                                      goto LABEL_972;
                                    }
                                    LODWORD(v471) = v23 >> -(char)v420;
                                    v422 = v24 + v420;
                                    v24 = v422 & 7;
                                    BytePtr += v422 >> 3;
                                    v423 = v314 - (_DWORD)BytePtr;
                                    if (v314 - (int)BytePtr < 4)
                                    {
                                      if (v423 < 1)
                                      {
                                        v425 = v24 | v423;
                                        if (a4)
                                        {
                                          if (v425)
                                            goto LABEL_952;
                                          v23 = 0;
                                        }
                                        else
                                        {
                                          v23 = 0;
                                          if (v425)
                                            goto LABEL_972;
                                        }
                                      }
                                      else
                                      {
                                        v424 = *BytePtr;
                                        if (v423 == 1)
                                        {
                                          v23 = v424 << 24;
                                        }
                                        else
                                        {
                                          v426 = (v424 << 16) | (BytePtr[1] << 8);
                                          if (v423 != 2)
                                            v426 |= BytePtr[2];
                                          v23 = v426 << 8;
                                        }
                                      }
                                    }
                                    else
                                    {
                                      v23 = bswap32(*(_DWORD *)BytePtr);
                                    }
                                    v23 <<= v24;
                                    break;
                                  default:
                                    goto LABEL_932;
                                }
                                goto LABEL_1050;
                              }
                            }
                            else if (v23 >= 0x80000)
                            {
                              goto LABEL_874;
                            }
                          }
                        }
                        else if (v23 >= 0x80000)
                        {
                          goto LABEL_904;
                        }
                      }
                      else
                      {
                        v23 = 0;
                        if (!v326)
                          goto LABEL_855;
                      }
                    }
LABEL_972:
                    v22 = 4294954582;
                    goto LABEL_973;
                  }
                  BYTE12(v468) = v268 < 0;
                  if (v316 < 4)
                  {
                    if (v316 < 1)
                    {
                      v321 = v24 | v316;
                      if (a4)
                      {
                        if (v321)
                          goto LABEL_952;
                        v23 = 0;
                      }
                      else
                      {
                        v23 = 0;
                        if (v321)
                          goto LABEL_972;
                      }
                    }
                    else
                    {
                      v319 = *BytePtr;
                      if (v316 == 1)
                      {
                        v23 = v319 << 24;
                      }
                      else
                      {
                        v327 = (v319 << 16) | (BytePtr[1] << 8);
                        if (v316 != 2)
                          v327 |= BytePtr[2];
                        v23 = v327 << 8;
                      }
                    }
                  }
                  else
                  {
                    v23 = bswap32(*(_DWORD *)BytePtr);
                  }
                  v23 <<= v24;
                  if ((v268 & 0x80000000) == 0)
                    goto LABEL_856;
                  while (2)
                  {
                    if (a4)
                    {
                      if (v23 < 0x80000)
                        goto LABEL_952;
                    }
                    else if (v23 < 0x80000)
                    {
                      goto LABEL_972;
                    }
                    v332 = __clz(v23);
                    v333 = v23 << (v332 + 1) >> -(char)v332;
                    if (!v332)
                      v333 = 0;
                    v334 = v333 + ~(-1 << v332);
                    v335 = v332 + v24 + v332 + 1;
                    v24 = v335 & 7;
                    BytePtr += v335 >> 3;
                    v336 = v314 - (_DWORD)BytePtr;
                    if (v314 - (int)BytePtr >= 4)
                    {
                      v337 = bswap32(*(_DWORD *)BytePtr);
                      goto LABEL_789;
                    }
                    if (v336 < 1)
                    {
                      v339 = v24 | v336;
                      if (a4)
                      {
                        if (v339)
                          goto LABEL_952;
                        v23 = 0;
                        goto LABEL_790;
                      }
                      v23 = 0;
                      if (v339)
                        goto LABEL_972;
                    }
                    else
                    {
                      v338 = *BytePtr;
                      if (v336 == 1)
                      {
                        v337 = v338 << 24;
                      }
                      else
                      {
                        v340 = (v338 << 16) | (BytePtr[1] << 8);
                        if (v336 != 2)
                          v340 |= BytePtr[2];
                        v337 = v340 << 8;
                      }
LABEL_789:
                      v23 = v337 << v24;
                      if (a4)
                      {
LABEL_790:
                        if (v334 > 6)
                          goto LABEL_952;
                        goto LABEL_794;
                      }
                    }
                    if (v334 > 6)
                      break;
LABEL_794:
                    if ((v334 | 2) == 3)
                    {
                      if (a4)
                      {
                        if (v23 < 0x80000)
                          goto LABEL_952;
                      }
                      else if (v23 < 0x80000)
                      {
                        goto LABEL_972;
                      }
                      v341 = v24 + 2 * __clz(v23) + 1;
                      v24 = v341 & 7;
                      BytePtr += v341 >> 3;
                      v342 = v314 - (_DWORD)BytePtr;
                      if (v314 - (int)BytePtr < 4)
                      {
                        if (v342 < 1)
                        {
                          v344 = v24 | v342;
                          if (a4)
                          {
                            if (v344)
                              goto LABEL_952;
                            v23 = 0;
                          }
                          else
                          {
                            v23 = 0;
                            if (v344)
                              goto LABEL_972;
                          }
                        }
                        else
                        {
                          v343 = *BytePtr;
                          if (v342 == 1)
                          {
                            v23 = v343 << 24;
                          }
                          else
                          {
                            v345 = (v343 << 16) | (BytePtr[1] << 8);
                            if (v342 != 2)
                              v345 |= BytePtr[2];
                            v23 = v345 << 8;
                          }
                        }
                      }
                      else
                      {
                        v23 = bswap32(*(_DWORD *)BytePtr);
                      }
                      v23 <<= v24;
                    }
                    switch(v334)
                    {
                      case 6u:
                      case 3u:
                        if (a4)
                        {
                          if (v23 < 0x80000)
                            goto LABEL_952;
                        }
                        else if (v23 < 0x80000)
                        {
                          goto LABEL_972;
                        }
                        v346 = v24 + 2 * __clz(v23) + 1;
                        v24 = v346 & 7;
                        BytePtr += v346 >> 3;
                        v347 = v314 - (_DWORD)BytePtr;
                        if (v314 - (int)BytePtr < 4)
                        {
                          if (v347 < 1)
                          {
                            v349 = v24 | v347;
                            if (a4)
                            {
                              if (v349)
                                goto LABEL_952;
                              v23 = 0;
                            }
                            else
                            {
                              v23 = 0;
                              if (v349)
                                goto LABEL_972;
                            }
                          }
                          else
                          {
                            v348 = *BytePtr;
                            if (v347 == 1)
                            {
                              v23 = v348 << 24;
                            }
                            else
                            {
                              v350 = (v348 << 16) | (BytePtr[1] << 8);
                              if (v347 != 2)
                                v350 |= BytePtr[2];
                              v23 = v350 << 8;
                            }
                          }
                        }
                        else
                        {
                          v23 = bswap32(*(_DWORD *)BytePtr);
                        }
                        v23 <<= v24;
                        break;
                      case 2u:
LABEL_834:
                        if (a4)
                        {
                          if (v23 < 0x80000)
                            goto LABEL_952;
                        }
                        else if (v23 < 0x80000)
                        {
                          goto LABEL_972;
                        }
                        v351 = v24 + 2 * __clz(v23) + 1;
                        v24 = v351 & 7;
                        BytePtr += v351 >> 3;
                        v352 = v314 - (_DWORD)BytePtr;
                        if (v314 - (int)BytePtr < 4)
                        {
                          if (v352 < 1)
                          {
                            v354 = v24 | v352;
                            if (a4)
                            {
                              if (v354)
                                goto LABEL_952;
                              v23 = 0;
                            }
                            else
                            {
                              v23 = 0;
                              if (v354)
                                goto LABEL_972;
                            }
                          }
                          else
                          {
                            v353 = *BytePtr;
                            if (v352 == 1)
                            {
                              v23 = v353 << 24;
                            }
                            else
                            {
                              v355 = (v353 << 16) | (BytePtr[1] << 8);
                              if (v352 != 2)
                                v355 |= BytePtr[2];
                              v23 = v355 << 8;
                            }
                          }
                        }
                        else
                        {
                          v23 = bswap32(*(_DWORD *)BytePtr);
                        }
                        v23 <<= v24;
                        break;
                      case 4u:
                        goto LABEL_834;
                    }
                    if (!v334)
                      goto LABEL_856;
                    continue;
                  }
                }
LABEL_853:
                LODWORD(v22) = -12714;
                FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
                goto LABEL_974;
              }
              while (2)
              {
                if (a4)
                {
                  if (v23 < 0x80000)
                    goto LABEL_952;
                }
                else if (v23 < 0x80000)
                {
                  goto LABEL_658;
                }
                v299 = __clz(v23);
                v300 = v23 << (v299 + 1) >> -(char)v299;
                if (!v299)
                  v300 = 0;
                v301 = v300 + ~(-1 << v299);
                v302 = v299 + v24 + v299 + 1;
                v24 = v302 & 7;
                v72 += v302 >> 3;
                v303 = v26 - (_DWORD)v72;
                if (v26 - (int)v72 >= 4)
                {
                  v304 = bswap32(*(_DWORD *)v72);
                  goto LABEL_693;
                }
                if (v303 < 1)
                {
                  v306 = v24 | v303;
                  if (a4)
                  {
                    if (v306)
                      goto LABEL_952;
                    v23 = 0;
                    goto LABEL_694;
                  }
                  v23 = 0;
                  if (v306)
                    goto LABEL_658;
                }
                else
                {
                  v305 = *v72;
                  if (v303 == 1)
                  {
                    v304 = v305 << 24;
                  }
                  else
                  {
                    v307 = (v305 << 16) | (v72[1] << 8);
                    if (v303 != 2)
                      v307 |= v72[2];
                    v304 = v307 << 8;
                  }
LABEL_693:
                  v23 = v304 << v24;
                  if (a4)
                  {
LABEL_694:
                    if (v301 > 3)
                      goto LABEL_1007;
                    if (v301 > 2)
                      goto LABEL_665;
                    if (v23 < 0x80000)
                      goto LABEL_952;
LABEL_702:
                    v308 = v24 + 2 * __clz(v23) + 1;
                    v24 = v308 & 7;
                    v72 += v308 >> 3;
                    v309 = v26 - (_DWORD)v72;
                    if (v26 - (int)v72 < 4)
                    {
                      if (v309 < 1)
                      {
                        v311 = v24 | v309;
                        if (a4)
                        {
                          if (v311)
                            goto LABEL_952;
                          v23 = 0;
                        }
                        else
                        {
                          v23 = 0;
                          if (v311)
                            goto LABEL_658;
                        }
                      }
                      else
                      {
                        v310 = *v72;
                        if (v309 == 1)
                        {
                          v23 = v310 << 24;
                        }
                        else
                        {
                          v312 = (v310 << 16) | (v72[1] << 8);
                          if (v309 != 2)
                            v312 |= v72[2];
                          v23 = v312 << 8;
                        }
                      }
                    }
                    else
                    {
                      v23 = bswap32(*(_DWORD *)v72);
                    }
                    v23 <<= v24;
                    continue;
                  }
                }
                break;
              }
              if (v301 > 3)
                goto LABEL_1115;
              if (v301 > 2)
                goto LABEL_665;
              if (v23 < 0x80000)
                goto LABEL_658;
              goto LABEL_702;
            }
            BYTE12(v459) = v268 < 0;
            v282 = (v24 + 1) >> 3;
            v24 = (v24 + 1) & 7;
            v72 += v282;
            v283 = v26 - (_DWORD)v72;
            if (v26 - (int)v72 < 4)
            {
              if (v283 < 1)
              {
                v330 = v24 | v283;
                if (a4)
                {
                  if (v330)
                    goto LABEL_952;
                  v23 = 0;
                }
                else
                {
                  v23 = 0;
                  if (v330)
                    goto LABEL_658;
                }
              }
              else
              {
                v293 = *v72;
                if (v283 == 1)
                {
                  v23 = v293 << 24;
                }
                else
                {
                  v331 = (v293 << 16) | (v72[1] << 8);
                  if (v283 != 2)
                    v331 |= v72[2];
                  v23 = v331 << 8;
                }
              }
            }
            else
            {
              v23 = bswap32(*(_DWORD *)v72);
            }
            v23 <<= v24;
            if ((v268 & 0x80000000) == 0)
            {
LABEL_1073:
              v268 = v23;
              goto LABEL_628;
            }
            while (2)
            {
              if (a4)
              {
                if (v23 < 0x80000)
                  goto LABEL_952;
              }
              else if (v23 < 0x80000)
              {
                goto LABEL_658;
              }
              v434 = __clz(v23);
              v435 = v23 << (v434 + 1) >> -(char)v434;
              if (!v434)
                v435 = 0;
              v436 = v435 + ~(-1 << v434);
              v437 = v434 + v24 + v434 + 1;
              v24 = v437 & 7;
              v72 += v437 >> 3;
              v438 = v26 - (_DWORD)v72;
              if (v26 - (int)v72 >= 4)
              {
                v439 = bswap32(*(_DWORD *)v72);
                goto LABEL_1091;
              }
              if (v438 < 1)
              {
                v441 = v24 | v438;
                if (a4)
                {
                  if (v441)
                    goto LABEL_952;
                  v23 = 0;
                  goto LABEL_1092;
                }
                v23 = 0;
                if (v441)
                  goto LABEL_658;
              }
              else
              {
                v440 = *v72;
                if (v438 == 1)
                {
                  v439 = v440 << 24;
                }
                else
                {
                  v442 = (v440 << 16) | (v72[1] << 8);
                  if (v438 != 2)
                    v442 |= v72[2];
                  v439 = v442 << 8;
                }
LABEL_1091:
                v23 = v439 << v24;
                if (a4)
                {
LABEL_1092:
                  if (v436 > 3)
                    goto LABEL_1007;
                  if (v436 > 2)
                    goto LABEL_1073;
                  if (v23 < 0x80000)
                    goto LABEL_952;
LABEL_1100:
                  v443 = v24 + 2 * __clz(v23) + 1;
                  v24 = v443 & 7;
                  v72 += v443 >> 3;
                  v444 = v26 - (_DWORD)v72;
                  if (v26 - (int)v72 < 4)
                  {
                    if (v444 < 1)
                    {
                      v446 = v24 | v444;
                      if (a4)
                      {
                        if (v446)
                          goto LABEL_952;
                        v23 = 0;
                      }
                      else
                      {
                        v23 = 0;
                        if (v446)
                          goto LABEL_658;
                      }
                    }
                    else
                    {
                      v445 = *v72;
                      if (v444 == 1)
                      {
                        v23 = v445 << 24;
                      }
                      else
                      {
                        v447 = (v445 << 16) | (v72[1] << 8);
                        if (v444 != 2)
                          v447 |= v72[2];
                        v23 = v447 << 8;
                      }
                    }
                  }
                  else
                  {
                    v23 = bswap32(*(_DWORD *)v72);
                  }
                  v23 <<= v24;
                  continue;
                }
              }
              break;
            }
            if (v436 > 3)
              goto LABEL_1115;
            if (v436 > 2)
              goto LABEL_1073;
            if (v23 < 0x80000)
              goto LABEL_658;
            goto LABEL_1100;
          }
        }
        if (v405 <= 0x1F)
        {
LABEL_626:
          v268 = v23;
          goto LABEL_627;
        }
LABEL_1115:
        v22 = 4294954577;
        goto LABEL_659;
      }
    }
    if (v287 <= 0x1F)
      goto LABEL_986;
    goto LABEL_1115;
  }
  v234 = (v24 + 1) >> 3;
  v24 = (v24 + 1) & 7;
  v72 += v234;
  v235 = v26 - (_DWORD)v72;
  if (v26 - (int)v72 >= 4)
  {
    v236 = bswap32(*(_DWORD *)v72);
    goto LABEL_526;
  }
  if (v235 < 1)
  {
    v239 = v24 | v235;
    if (a4)
    {
      if (v239)
        goto LABEL_952;
      v23 = 0;
    }
    else
    {
      v23 = 0;
      if (v239)
        goto LABEL_658;
    }
  }
  else
  {
    v237 = *v72;
    if (v235 == 1)
    {
      v236 = v237 << 24;
    }
    else
    {
      v240 = (v237 << 16) | (v72[1] << 8);
      if (v235 != 2)
        v240 |= v72[2];
      v236 = v240 << 8;
    }
LABEL_526:
    v23 = v236 << v24;
  }
  v241 = 1;
  v242 = v23;
  while (2)
  {
    v214 = (v24 + 1) & 7;
    v72 += (v24 + 1) >> 3;
    v243 = v26 - (_DWORD)v72;
    if (v26 - (int)v72 >= 4)
    {
      v244 = bswap32(*(_DWORD *)v72);
      goto LABEL_540;
    }
    if (v243 < 1)
    {
      v246 = v214 | v243;
      if (a4)
      {
        if (v246)
          goto LABEL_952;
        if ((v242 & 0x80000000) != 0)
          goto LABEL_546;
        v246 = 0;
      }
      else
      {
        if (v246)
          goto LABEL_1136;
        v23 = 0;
        if ((v242 & 0x80000000) != 0)
          goto LABEL_551;
      }
      goto LABEL_541;
    }
    v245 = *v72;
    if (v243 == 1)
    {
      v244 = v245 << 24;
    }
    else
    {
      v247 = (v245 << 16) | (v72[1] << 8);
      if (v243 != 2)
        v247 |= v72[2];
      v244 = v247 << 8;
    }
LABEL_540:
    v246 = v244 << v214;
    if ((v242 & 0x80000000) == 0)
    {
LABEL_541:
      ++v241;
      v242 = v246;
      v24 = (v24 + 1) & 7;
      continue;
    }
    break;
  }
  v23 = v246;
  if (!a4)
  {
LABEL_551:
    if (v241 - 1 <= 0x1E)
    {
      if (v241 < 0x19)
      {
LABEL_553:
        v232 = (((_BYTE)v24 + 1) & 7) + v241;
        goto LABEL_554;
      }
      v255 = (((_BYTE)v24 + 1) & 7) + v241;
      v256 = (v255 - 16) >> 3;
      v24 = v255 & 7;
      v222 = &v72[v256];
      v257 = v26 - ((_DWORD)v72 + v256);
      if (v257 > 0 || !(v24 | v257))
        goto LABEL_566;
LABEL_1141:
      v23 = 0;
      v22 = 4294954582;
      BytePtr = v222;
      goto LABEL_973;
    }
LABEL_1137:
    v22 = 4294954582;
    LOBYTE(v24) = v214;
    goto LABEL_659;
  }
LABEL_546:
  if (v241 - 1 > 0x1E)
    goto LABEL_952;
  if (v241 <= 0x18)
    goto LABEL_553;
  v248 = (((_BYTE)v24 + 1) & 7) + v241;
  v249 = (v248 - 16) >> 3;
  v24 = v248 & 7;
  v222 = &v72[v249];
  v250 = v26 - ((_DWORD)v72 + v249);
  if (v250 <= 0 && v24 | v250)
    goto LABEL_952;
LABEL_566:
  v72 = v222 + 2;
  v258 = v26 - ((_DWORD)v222 + 2);
  if (v258 >= 4)
  {
LABEL_567:
    v23 = bswap32(*(_DWORD *)v72);
    goto LABEL_568;
  }
  if (v258 >= 1)
  {
    v448 = *v72;
    if (v258 == 1)
    {
      v23 = v448 << 24;
    }
    else
    {
      v449 = (v448 << 16) | (v222[3] << 8);
      if (v258 != 2)
        v449 |= v222[4];
      v23 = v449 << 8;
    }
    goto LABEL_568;
  }
  v253 = v24 | v258;
  if (a4)
    goto LABEL_559;
LABEL_1122:
  v23 = 0;
  if (!v253)
    goto LABEL_568;
LABEL_658:
  v22 = 4294954582;
LABEL_659:
  BytePtr = v72;
LABEL_973:
  LODWORD(v22) = FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)v22)
  {
LABEL_974:
    if ((_QWORD)v455 - (_QWORD)v454 + 4 >= DWORD2(v454))
      v400 = 4294950906;
    else
      v400 = v22;
    goto LABEL_1068;
  }
LABEL_1050:
  *(_QWORD *)&v455 = BytePtr;
  DWORD2(v455) = v23;
  BYTE12(v455) = v24;
  v427 = &BytePtr[-v454];
  if ((_BYTE)v24)
    ++v427;
  if (theData)
  {
    v428 = v452;
    if (a2 >= 3 && v427)
    {
      v429 = 0;
      v430 = 0;
      v431 = 2;
      v432 = (unint64_t)v427;
      do
      {
        if (v451[v430] || *(_WORD *)&v451[v430 + 1] != 768)
        {
          v431 = v430;
        }
        else
        {
          if (v432 < v431)
            break;
          ++v432;
          v429 = 1;
        }
        if (v431 + 3 >= a2)
          break;
        v430 = v431 + 1;
        v431 += 3;
      }
      while (v430 < v432);
      if (v429)
        v427 = (const UInt8 *)v432;
    }
  }
  else
  {
    v428 = v452;
  }
  v400 = 0;
  *v428 = v427;
LABEL_1068:
  if (theData)
    CFRelease(theData);
  return v400;
}

uint64_t FigH264Bridge_LocateSliceHeaderForHLSfMP4EncryptableNAL(CMBlockBufferRef theBuffer, uint64_t a2, unint64_t a3, uint64_t a4, _QWORD *a5, uint64_t a6, _QWORD *a7, unint64_t a8, _QWORD *a9)
{
  uint64_t v9;
  unint64_t v12;
  size_t DataLength;
  size_t v18;
  OpaqueCMBlockBuffer *v19;
  uint64_t DataPointer;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  _BOOL8 v25;
  _BOOL4 v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  _BOOL8 v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  const UInt8 *v35;
  _BOOL4 v38;
  _QWORD *v39;
  _QWORD *v40;
  const UInt8 *v42;
  CMBlockBufferRef blockBufferOut;
  size_t totalLengthOut;
  char *dataPointerOut;

  totalLengthOut = 0;
  dataPointerOut = 0;
  blockBufferOut = 0;
  v9 = 4294954584;
  if (!theBuffer || !a4)
    return v9;
  v12 = (unint64_t)a7;
  if (a5)
    *a5 = 0;
  if (a7)
    *a7 = 0;
  if (a8)
    *(_QWORD *)a8 = 0;
  if (a9)
    *a9 = 0;
  DataLength = CMBlockBufferGetDataLength(theBuffer);
  if (!DataLength)
    goto LABEL_58;
  v18 = DataLength;
  if (CMBlockBufferIsRangeContiguous(theBuffer, 0, 0))
  {
    v19 = (OpaqueCMBlockBuffer *)CFRetain(theBuffer);
    blockBufferOut = v19;
  }
  else
  {
    DataPointer = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theBuffer, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, v18, 0, &blockBufferOut);
    if ((_DWORD)DataPointer)
    {
LABEL_59:
      v9 = DataPointer;
      goto LABEL_60;
    }
    v19 = blockBufferOut;
  }
  DataPointer = CMBlockBufferGetDataPointer(v19, 0, 0, &totalLengthOut, &dataPointerOut);
  if ((_DWORD)DataPointer)
    goto LABEL_59;
  if (!a3)
  {
    v21 = (unint64_t)a9;
    v22 = a6;
    if (!a2)
    {
      v40 = a5;
      a3 = totalLengthOut;
      goto LABEL_22;
    }
LABEL_58:
    DataPointer = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    goto LABEL_59;
  }
  v21 = (unint64_t)a9;
  v22 = a6;
  if (a3 + a2 > totalLengthOut)
    goto LABEL_58;
  v40 = a5;
  totalLengthOut = a3;
  dataPointerOut += a2;
LABEL_22:
  v23 = 0;
  v24 = 0;
  v39 = (_QWORD *)v12;
  v25 = (a8 | v21 | v12) != 0;
  v26 = (a8 | v21) != 0;
  v38 = v26;
  while (1)
  {
    if (a3 - 4 <= v24)
    {
      if (!v23)
        goto LABEL_58;
      if (v40)
        *v40 = v23;
      goto LABEL_56;
    }
    v27 = *(_DWORD *)&dataPointerOut[v24];
    if (!v27)
      goto LABEL_58;
    v28 = (v24 + 4);
    v29 = bswap32(v27);
    v24 = v29 + v28;
    if (a3 < (int)v29 + (int)v28)
      goto LABEL_58;
    if ((dataPointerOut[v28] & 0x1B) == 1)
      break;
LABEL_50:
    if (a3 < v24)
      goto LABEL_58;
  }
  if (v29 <= 1)
    goto LABEL_58;
  if (v23 != v22 || !v25)
  {
LABEL_49:
    ++v23;
    goto LABEL_50;
  }
  if (v12)
    *(_QWORD *)v12 = v28;
  if (v26)
  {
    v31 = v25;
    v42 = 0;
    v32 = 64;
    do
    {
      if (v32 >= v29)
        v33 = v29;
      else
        v33 = v32;
      v34 = FigH264Bridge_MeasureSliceHeader((const UInt8 *)&dataPointerOut[v28], v33, a4, 0, &v42);
      v9 = v34;
      if (v32 >= v29)
        break;
      v32 = v33 + 64;
    }
    while ((_DWORD)v34 == -16390);
    if ((_DWORD)v34)
      goto LABEL_60;
    v35 = v42;
    if (a8)
      *(_QWORD *)a8 = &v42[v28];
    v22 = a6;
    v25 = v31;
    v26 = v38;
    if (a9)
      *a9 = v29 - (_QWORD)v35;
    v12 = (unint64_t)v39;
  }
  if (v40)
  {
    a3 = totalLengthOut;
    goto LABEL_49;
  }
  if (__CFADD__(v23++, 1))
    goto LABEL_58;
LABEL_56:
  if (v23 <= v22)
    goto LABEL_58;
  v9 = 0;
LABEL_60:
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  return v9;
}

uint64_t scaling_list(uint64_t result, int a2, _DWORD *a3)
{
  unsigned __int8 *v3;
  unsigned int v4;
  int v5;
  uint64_t v7;
  int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  unsigned __int8 v22;

  v3 = *(unsigned __int8 **)(result + 16);
  v4 = *(_DWORD *)(result + 24);
  v5 = *(unsigned __int8 *)(result + 28);
  if (a2)
  {
    v7 = *(_QWORD *)result + *(unsigned int *)(result + 8);
    v8 = 8;
    v9 = 8;
    do
    {
      if (!v8)
        goto LABEL_23;
      if (*a3)
        return result;
      if (!(v4 >> 19))
      {
LABEL_27:
        result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
        *a3 = result;
        return result;
      }
      v10 = __clz(v4);
      v11 = v4 << (v10 + 1) >> -(char)v10;
      v12 = v10 ? v11 : 0;
      v13 = v10 + v5 + v10 + 1;
      v14 = v13 >> 3;
      v5 = v13 & 7;
      v3 += v14;
      v15 = v7 - (_DWORD)v3;
      if ((int)v7 - (int)v3 < 4)
      {
        if (v15 < 1)
        {
          v16 = v5 | v15;
          if (v16)
            goto LABEL_27;
        }
        else
        {
          v17 = *v3;
          if (v15 == 1)
          {
            v16 = v17 << 24;
          }
          else
          {
            v18 = (v17 << 16) | (v3[1] << 8);
            if (v15 != 2)
              v18 |= v3[2];
            v16 = v18 << 8;
          }
        }
      }
      else
      {
        v16 = bswap32(*(_DWORD *)v3);
      }
      v4 = v16 << v5;
      v19 = ((v12 + (1 << v10)) >> 1) - ((v12 + (1 << v10)) >> 1) * 2 * ((v12 + (1 << v10)) & 1) + v9 + 256;
      v20 = v19;
      v21 = -v19;
      v8 = v21 >= 0 ? -v21 : v20;
      v22 = v8;
      if (!v8)
      {
LABEL_23:
        v8 = 0;
        v22 = v9;
      }
      v9 = v22;
      --a2;
    }
    while (a2);
  }
  *(_QWORD *)(result + 16) = v3;
  *(_DWORD *)(result + 24) = v4;
  *(_BYTE *)(result + 28) = v5;
  return result;
}

uint64_t PullVUIParamSet(uint64_t *a1, unsigned int *a2)
{
  uint64_t v3;
  int v4;
  unint64_t v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  unsigned __int8 *v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int *v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  int v38;
  int v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned __int8 *v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  uint64_t v65;
  int v66;
  int v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  int v72;
  int v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  int v78;
  int v79;
  int v80;
  uint64_t v81;
  unsigned __int8 *v82;
  int v83;
  unsigned int v84;
  int v85;
  int v86;
  unsigned int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  unsigned int v92;
  int v93;
  int v94;
  int v95;
  unsigned int v96;
  int v97;
  int v98;
  int v99;
  unsigned int v100;
  int v101;
  int v102;
  uint64_t v103;
  int v104;
  int v105;
  int v106;
  uint64_t v107;
  int v108;
  int v109;
  int v110;
  unsigned int v111;
  unsigned int v112;
  unsigned int v113;
  int v114;
  int v115;
  unsigned int v116;
  int v117;
  int v118;
  int v119;
  uint64_t v120;
  int v121;
  int v122;
  int v123;
  uint64_t v124;
  int v125;
  int v126;
  int v127;
  unsigned int v128;
  int v129;
  unsigned int v130;
  unsigned int v131;
  uint64_t v132;
  int v133;
  int v134;
  int v135;
  unsigned int v136;
  char v137;
  unsigned int v138;
  uint64_t v139;
  int v140;
  int v141;
  int v142;
  unsigned int v143;
  int v144;
  int v145;
  int v146;
  int v147;
  int v148;
  unsigned int v149;
  uint64_t v150;
  int v151;
  uint64_t v154;
  int v155;
  int v156;
  int v157;
  unsigned int v158;
  char v159;
  unsigned int v160;
  uint64_t v161;
  int v162;
  int v163;
  int v164;
  unsigned int v165;
  int v166;
  int v167;
  uint64_t v168;
  int v169;
  int v170;
  int v171;
  uint64_t v172;
  int v173;
  int v174;
  int v175;
  uint64_t v176;
  int v177;
  int v178;
  int v179;
  uint64_t v180;
  int v181;
  int v182;
  int v183;
  uint64_t v184;
  int v185;
  int v186;
  int v187;
  uint64_t v188;
  int v189;
  int v190;
  int v191;
  unsigned int v192;
  unsigned int v193;
  int v194;
  int v195;
  unsigned int v196;
  int v197;
  int v198;
  int v199;
  uint64_t v200;
  int v201;
  int v202;
  int v203;
  uint64_t v204;
  int v205;
  int v206;
  int v207;
  unsigned int v208;
  int v209;
  unsigned int v210;
  unsigned int v211;
  uint64_t v212;
  int v213;
  int v214;
  int v215;
  unsigned int v216;
  char v217;
  unsigned int v218;
  uint64_t v219;
  int v220;
  int v221;
  int v222;
  unsigned int v223;
  int v224;
  int v225;
  int v226;
  int v227;
  int v228;
  unsigned int v229;
  uint64_t v230;
  int v231;
  uint64_t v234;
  int v235;
  int v236;
  int v237;
  unsigned int v238;
  char v239;
  unsigned int v240;
  uint64_t v241;
  int v242;
  int v243;
  int v244;
  unsigned int v245;
  int v246;
  int v247;
  uint64_t v248;
  int v249;
  int v250;
  int v251;
  uint64_t v252;
  int v253;
  int v254;
  int v255;
  uint64_t v256;
  int v257;
  int v258;
  int v259;
  uint64_t v260;
  int v261;
  int v262;
  int v263;
  uint64_t v264;
  int v265;
  int v266;
  int v267;
  uint64_t v268;
  int v269;
  int v270;
  int v271;
  uint64_t v272;
  int v273;
  int v274;
  int v275;
  unsigned int v276;
  uint64_t v277;
  int v278;
  int v279;
  int v280;
  uint64_t v281;
  int v282;
  int v283;
  int v284;
  unsigned int v285;
  unsigned int v286;
  unsigned int v287;
  int v288;
  int v289;
  int v290;
  unsigned int v291;
  unsigned int v292;
  unsigned int v293;
  int v294;
  int v295;
  int v296;
  unsigned int v297;
  unsigned int v298;
  unsigned int v299;
  int v300;
  int v301;
  int v302;
  unsigned int v303;
  unsigned int v304;
  unsigned int v305;
  int v306;
  int v307;
  int v308;
  unsigned int v309;
  unsigned int v310;
  unsigned int v311;
  int v312;
  int v313;
  int v314;
  unsigned int v315;
  unsigned int v316;
  unsigned int v317;
  int v318;
  int v319;
  int v320;
  uint64_t v321;

  v3 = *a1;
  v4 = *((_DWORD *)a1 + 2);
  v5 = *((unsigned __int8 *)a1 + 28);
  v6 = *((_DWORD *)a1 + 6);
  v7 = a1[2];
  *a2 = v6 >> 31;
  v8 = ++v5 & 7;
  v9 = (unsigned __int8 *)(v7 + (v5 >> 3));
  v10 = v3 + v4;
  v11 = v3 + v4 - (_DWORD)v9;
  if (v11 < 4)
  {
    if (v11 < 1)
    {
      v12 = 0;
      if (v8 | v11)
        goto LABEL_748;
    }
    else
    {
      v13 = *v9;
      if (v11 == 1)
      {
        v12 = v13 << 24;
      }
      else
      {
        v14 = (v13 << 16) | (v9[1] << 8);
        if (v11 != 2)
          v14 |= v9[2];
        v12 = v14 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  v15 = v12 << v8;
  if ((v6 & 0x80000000) != 0)
  {
    v17 = HIBYTE(v15);
    a2[1] = HIBYTE(v15);
    v16 = (unsigned int *)(v9 + 1);
    v18 = v10 - ((_DWORD)v9 + 1);
    if (v18 < 4)
    {
      if (v18 < 1)
      {
        v12 = 0;
        if (v8 | v18)
          goto LABEL_40;
      }
      else
      {
        v19 = *(unsigned __int8 *)v16;
        if (v18 == 1)
        {
          v12 = v19 << 24;
        }
        else
        {
          v20 = (v19 << 16) | (v9[2] << 8);
          if (v18 != 2)
            v20 |= v9[3];
          v12 = v20 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*v16);
    }
    v15 = v12 << v8;
    if (v17 != 255)
      goto LABEL_45;
    a2[2] = HIWORD(v15);
    v16 = (unsigned int *)(v9 + 3);
    v21 = v10 - ((_DWORD)v9 + 3);
    if (v21 < 4)
    {
      if (v21 < 1)
      {
        v12 = 0;
        if (v8 | v21)
          goto LABEL_40;
      }
      else
      {
        v22 = *(unsigned __int8 *)v16;
        if (v21 == 1)
        {
          v12 = v22 << 24;
        }
        else
        {
          v23 = (v22 << 16) | (v9[4] << 8);
          if (v21 != 2)
            v23 |= v9[5];
          v12 = v23 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*v16);
    }
    a2[3] = v12 << v8 >> 16;
    v16 = (unsigned int *)(v9 + 5);
    v24 = v10 - ((_DWORD)v9 + 5);
    if (v24 >= 4)
    {
      v12 = bswap32(*v16);
      goto LABEL_44;
    }
    if (v24 >= 1)
    {
      v25 = *(unsigned __int8 *)v16;
      if (v24 == 1)
      {
        v12 = v25 << 24;
      }
      else
      {
        v26 = (v25 << 16) | (v9[6] << 8);
        if (v24 != 2)
          v26 |= v9[7];
        v12 = v26 << 8;
      }
      goto LABEL_44;
    }
    v12 = 0;
    if (!(v8 | v24))
    {
LABEL_44:
      v15 = v12 << v8;
      goto LABEL_45;
    }
LABEL_40:
    v9 = (unsigned __int8 *)v16;
    goto LABEL_748;
  }
  v16 = (unsigned int *)v9;
LABEL_45:
  v27 = v7 - v3;
  if (v4 < v27)
    goto LABEL_746;
  a2[4] = v15 >> 31;
  v28 = (v8 + 1) >> 3;
  v8 = (v8 + 1) & 7;
  v9 = (unsigned __int8 *)v16 + v28;
  v29 = v10 - ((_DWORD)v16 + v28);
  if (v29 < 4)
  {
    if (v29 < 1)
    {
      v12 = 0;
      if (v8 | v29)
        goto LABEL_748;
    }
    else
    {
      v30 = *v9;
      if (v29 == 1)
      {
        v12 = v30 << 24;
      }
      else
      {
        v31 = (v30 << 16) | (v9[1] << 8);
        if (v29 != 2)
          v31 |= v9[2];
        v12 = v31 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  v32 = v12 << v8;
  if ((v15 & 0x80000000) != 0)
  {
    a2[5] = v32 >> 31;
    v33 = (v8 + 1) >> 3;
    v8 = (v8 + 1) & 7;
    v9 += v33;
    v34 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v34 < 1)
      {
        v12 = 0;
        if (v8 | v34)
          goto LABEL_748;
      }
      else
      {
        v35 = *v9;
        if (v34 == 1)
        {
          v12 = v35 << 24;
        }
        else
        {
          v36 = (v35 << 16) | (v9[1] << 8);
          if (v34 != 2)
            v36 |= v9[2];
          v12 = v36 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    v32 = v12 << v8;
  }
  a2[6] = v32 >> 31;
  v37 = (v8 + 1) >> 3;
  v8 = (v8 + 1) & 7;
  v9 += v37;
  v38 = v10 - (_DWORD)v9;
  if (v10 - (int)v9 < 4)
  {
    if (v38 < 1)
    {
      v12 = 0;
      if (v8 | v38)
        goto LABEL_748;
    }
    else
    {
      v39 = *v9;
      if (v38 == 1)
      {
        v12 = v39 << 24;
      }
      else
      {
        v40 = (v39 << 16) | (v9[1] << 8);
        if (v38 != 2)
          v40 |= v9[2];
        v12 = v40 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  v41 = v12 << v8;
  if ((v32 & 0x80000000) != 0)
  {
    a2[7] = v41 >> 29;
    v42 = (v8 + 3) >> 3;
    v8 = (v8 + 3) & 7;
    v9 += v42;
    v43 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v43 < 1)
      {
        v12 = 0;
        if (v8 | v43)
          goto LABEL_748;
      }
      else
      {
        v44 = *v9;
        if (v43 == 1)
        {
          v12 = v44 << 24;
        }
        else
        {
          v45 = (v44 << 16) | (v9[1] << 8);
          if (v43 != 2)
            v45 |= v9[2];
          v12 = v45 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    a2[8] = v12 << v8 >> 31;
    v46 = (v8 + 1) >> 3;
    v8 = (v8 + 1) & 7;
    v9 += v46;
    v47 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v47 < 1)
      {
        v12 = 0;
        if (v8 | v47)
          goto LABEL_748;
      }
      else
      {
        v48 = *v9;
        if (v47 == 1)
        {
          v12 = v48 << 24;
        }
        else
        {
          v49 = (v48 << 16) | (v9[1] << 8);
          if (v47 != 2)
            v49 |= v9[2];
          v12 = v49 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    v50 = v12 << v8;
    a2[9] = v12 << v8 >> 31;
    v51 = (v8 + 1) >> 3;
    v8 = (v8 + 1) & 7;
    v52 = &v9[v51];
    v53 = v10 - ((_DWORD)v9 + v51);
    if (v53 < 4)
    {
      if (v53 < 1)
      {
        v12 = 0;
        if (v8 | v53)
        {
LABEL_105:
          v9 = v52;
          goto LABEL_748;
        }
      }
      else
      {
        v54 = *v52;
        if (v53 == 1)
        {
          v12 = v54 << 24;
        }
        else
        {
          v55 = (v54 << 16) | (v52[1] << 8);
          if (v53 != 2)
            v55 |= v52[2];
          v12 = v55 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v52);
    }
    v41 = v12 << v8;
    if ((v50 & 0x80000000) != 0)
    {
      a2[10] = HIBYTE(v41);
      v9 = v52 + 1;
      v56 = v10 - ((_DWORD)v52 + 1);
      if (v56 < 4)
      {
        if (v56 < 1)
        {
          v12 = 0;
          if (v8 | v56)
            goto LABEL_748;
        }
        else
        {
          v57 = *v9;
          if (v56 == 1)
          {
            v12 = v57 << 24;
          }
          else
          {
            v58 = (v57 << 16) | (v52[2] << 8);
            if (v56 != 2)
              v58 |= v52[3];
            v12 = v58 << 8;
          }
        }
      }
      else
      {
        v12 = bswap32(*(_DWORD *)v9);
      }
      a2[11] = v12 << v8 >> 24;
      v9 = v52 + 2;
      v59 = v10 - ((_DWORD)v52 + 2);
      if (v59 < 4)
      {
        if (v59 < 1)
        {
          v12 = 0;
          if (v8 | v59)
            goto LABEL_748;
        }
        else
        {
          v60 = *v9;
          if (v59 == 1)
          {
            v12 = v60 << 24;
          }
          else
          {
            v61 = (v60 << 16) | (v52[3] << 8);
            if (v59 != 2)
              v61 |= v52[4];
            v12 = v61 << 8;
          }
        }
      }
      else
      {
        v12 = bswap32(*(_DWORD *)v9);
      }
      a2[12] = v12 << v8 >> 24;
      v9 = v52 + 3;
      v62 = v10 - ((_DWORD)v52 + 3);
      if (v62 < 4)
      {
        if (v62 < 1)
        {
          v12 = 0;
          if (v8 | v62)
            goto LABEL_748;
        }
        else
        {
          v63 = *v9;
          if (v62 == 1)
          {
            v12 = v63 << 24;
          }
          else
          {
            v64 = (v63 << 16) | (v52[4] << 8);
            if (v62 != 2)
              v64 |= v52[5];
            v12 = v64 << 8;
          }
        }
      }
      else
      {
        v12 = bswap32(*(_DWORD *)v9);
      }
      v41 = v12 << v8;
    }
    else
    {
      v9 = v52;
    }
  }
  a2[13] = v41 >> 31;
  v65 = (v8 + 1) >> 3;
  v8 = (v8 + 1) & 7;
  v9 += v65;
  v66 = v10 - (_DWORD)v9;
  if (v10 - (int)v9 < 4)
  {
    if (v66 < 1)
    {
      v12 = 0;
      if (v8 | v66)
        goto LABEL_748;
    }
    else
    {
      v67 = *v9;
      if (v66 == 1)
      {
        v12 = v67 << 24;
      }
      else
      {
        v68 = (v67 << 16) | (v9[1] << 8);
        if (v66 != 2)
          v68 |= v9[2];
        v12 = v68 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  v12 <<= v8;
  if ((v41 & 0x80000000) != 0)
  {
    if (v12 < 0x80000)
      goto LABEL_748;
    v69 = __clz(v12);
    v70 = v12 << (v69 + 1) >> -(char)v69;
    if (!v69)
      v70 = 0;
    a2[14] = v70 + ~(-1 << v69);
    v71 = v69 + v8 + v69 + 1;
    v8 = v71 & 7;
    v9 += v71 >> 3;
    v72 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v72 < 1)
      {
        v12 = 0;
        if (v8 | v72)
          goto LABEL_748;
      }
      else
      {
        v73 = *v9;
        if (v72 == 1)
        {
          v12 = v73 << 24;
        }
        else
        {
          v74 = (v73 << 16) | (v9[1] << 8);
          if (v72 != 2)
            v74 |= v9[2];
          v12 = v74 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v12 < 0x80000)
      goto LABEL_748;
    v75 = __clz(v12);
    v76 = v12 << (v75 + 1) >> -(char)v75;
    if (!v75)
      v76 = 0;
    a2[15] = v76 + ~(-1 << v75);
    v77 = v75 + v8 + v75 + 1;
    v8 = v77 & 7;
    v9 += v77 >> 3;
    v78 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v78 < 1)
      {
        v12 = 0;
        if (v8 | v78)
          goto LABEL_748;
      }
      else
      {
        v79 = *v9;
        if (v78 == 1)
        {
          v12 = v79 << 24;
        }
        else
        {
          v80 = (v79 << 16) | (v9[1] << 8);
          if (v78 != 2)
            v80 |= v9[2];
          v12 = v80 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    v4 = *((_DWORD *)a1 + 2);
    v27 = *((_DWORD *)a1 + 4) - *(_DWORD *)a1;
  }
  if (v4 < v27)
    goto LABEL_746;
  a2[16] = v12 >> 31;
  v81 = (v8 + 1) >> 3;
  v8 = (v8 + 1) & 7;
  v82 = &v9[v81];
  v83 = v10 - ((_DWORD)v9 + v81);
  if (v83 < 4)
  {
    if (v83 < 1)
    {
      v84 = 0;
      if (v8 | v83)
      {
        v12 = 0;
        goto LABEL_238;
      }
    }
    else
    {
      v85 = *v82;
      if (v83 == 1)
      {
        v84 = v85 << 24;
      }
      else
      {
        v86 = (v85 << 16) | (v82[1] << 8);
        if (v83 != 2)
          v86 |= v82[2];
        v84 = v86 << 8;
      }
    }
  }
  else
  {
    v84 = bswap32(*(_DWORD *)v82);
  }
  v87 = v84 << v8;
  if ((v12 & 0x80000000) == 0)
    goto LABEL_243;
  v9 = v82 + 2;
  v88 = v10 - ((_DWORD)v82 + 2);
  if (v88 < 4)
  {
    if (v88 < 1)
    {
      v12 = 0;
      if (v8 | v88)
        goto LABEL_748;
    }
    else
    {
      v89 = *v9;
      if (v88 == 1)
      {
        v12 = v89 << 24;
      }
      else
      {
        v90 = (v89 << 16) | (v82[3] << 8);
        if (v88 != 2)
          v90 |= v82[4];
        v12 = v90 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  v9 = v82 + 4;
  v91 = v10 - ((_DWORD)v82 + 4);
  if (v91 < 4)
  {
    if (v91 < 1)
    {
      v92 = 0;
      if (v8 | v91)
      {
        v12 = 0;
        goto LABEL_748;
      }
    }
    else
    {
      v93 = *v9;
      if (v91 == 1)
      {
        v92 = v93 << 24;
      }
      else
      {
        v94 = (v93 << 16) | (v82[5] << 8);
        if (v91 != 2)
          v94 |= v82[6];
        v92 = v94 << 8;
      }
    }
  }
  else
  {
    v92 = bswap32(*(_DWORD *)v9);
  }
  a2[17] = (v12 << v8 >> 16) | v87 & 0xFFFF0000;
  v9 = v82 + 6;
  v95 = v10 - ((_DWORD)v82 + 6);
  if (v95 < 4)
  {
    if (v95 < 1)
    {
      v96 = 0;
      if (v8 | v95)
      {
        v12 = 0;
        goto LABEL_748;
      }
    }
    else
    {
      v97 = *v9;
      if (v95 == 1)
      {
        v96 = v97 << 24;
      }
      else
      {
        v98 = (v97 << 16) | (v82[7] << 8);
        if (v95 != 2)
          v98 |= v82[8];
        v96 = v98 << 8;
      }
    }
  }
  else
  {
    v96 = bswap32(*(_DWORD *)v9);
  }
  v9 = v82 + 8;
  v99 = v10 - ((_DWORD)v82 + 8);
  if (v99 < 4)
  {
    if (v99 < 1)
    {
      v100 = 0;
      v12 = 0;
      if (v8 | v99)
        goto LABEL_748;
    }
    else
    {
      v101 = *v9;
      if (v99 == 1)
      {
        v100 = v101 << 24;
      }
      else
      {
        v102 = (v101 << 16) | (v82[9] << 8);
        if (v99 != 2)
          v102 |= v82[10];
        v100 = v102 << 8;
      }
    }
  }
  else
  {
    v100 = bswap32(*(_DWORD *)v9);
  }
  a2[18] = (v96 << v8 >> 16) | (v92 << v8) & 0xFFFF0000;
  a2[19] = v100 << v8 >> 31;
  v103 = (v8 + 1) >> 3;
  v8 = (v8 + 1) & 7;
  v82 = &v9[v103];
  v104 = v10 - ((_DWORD)v9 + v103);
  if (v104 >= 4)
  {
    v12 = bswap32(*(_DWORD *)v82);
    goto LABEL_242;
  }
  if (v104 >= 1)
  {
    v105 = *v82;
    if (v104 == 1)
    {
      v12 = v105 << 24;
    }
    else
    {
      v106 = (v105 << 16) | (v82[1] << 8);
      if (v104 != 2)
        v106 |= v82[2];
      v12 = v106 << 8;
    }
    goto LABEL_242;
  }
  v12 = 0;
  if (v8 | v104)
  {
LABEL_238:
    v9 = v82;
    goto LABEL_748;
  }
LABEL_242:
  v87 = v12 << v8;
LABEL_243:
  if (*((_DWORD *)a1 + 2) < *((_DWORD *)a1 + 4) - *(_DWORD *)a1)
    goto LABEL_746;
  a2[20] = v87 >> 31;
  v107 = (v8 + 1) >> 3;
  v8 = (v8 + 1) & 7;
  v9 = &v82[v107];
  v108 = v10 - ((_DWORD)v82 + v107);
  if (v108 < 4)
  {
    if (v108 < 1)
    {
      v12 = 0;
      if (v8 | v108)
        goto LABEL_748;
    }
    else
    {
      v109 = *v9;
      if (v108 == 1)
      {
        v12 = v109 << 24;
      }
      else
      {
        v110 = (v109 << 16) | (v9[1] << 8);
        if (v108 != 2)
          v110 |= v9[2];
        v12 = v110 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  v12 <<= v8;
  if ((v87 & 0x80000000) == 0)
  {
    v111 = v12;
    goto LABEL_432;
  }
  if (v12 < 0x80000)
    goto LABEL_748;
  v112 = __clz(v12);
  if (v112)
    v113 = v12 << (v112 + 1) >> -(char)v112;
  else
    v113 = 0;
  v114 = -1 << v112;
  v115 = v113 + ~(-1 << v112);
  a2[32] = v115;
  v116 = v112 + v8 + v112 + 1;
  v8 = v116 & 7;
  v9 += v116 >> 3;
  v117 = v10 - (_DWORD)v9;
  if (v10 - (int)v9 < 4)
  {
    if (v117 < 1)
    {
      v12 = 0;
      if (v8 | v117)
        goto LABEL_748;
    }
    else
    {
      v118 = *v9;
      if (v117 == 1)
      {
        v12 = v118 << 24;
      }
      else
      {
        v119 = (v118 << 16) | (v9[1] << 8);
        if (v117 != 2)
          v119 |= v9[2];
        v12 = v119 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  v12 <<= v8;
  if (v115 > 31)
    goto LABEL_748;
  a2[33] = v12 >> 28;
  v120 = (v8 + 4) >> 3;
  v8 = (v8 + 4) & 7;
  v9 += v120;
  v121 = v10 - (_DWORD)v9;
  if (v10 - (int)v9 < 4)
  {
    if (v121 < 1)
    {
      v12 = 0;
      if (v8 | v121)
        goto LABEL_748;
    }
    else
    {
      v122 = *v9;
      if (v121 == 1)
      {
        v12 = v122 << 24;
      }
      else
      {
        v123 = (v122 << 16) | (v9[1] << 8);
        if (v121 != 2)
          v123 |= v9[2];
        v12 = v123 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  a2[34] = v12 << v8 >> 28;
  v124 = (v8 + 4) >> 3;
  v8 = (v8 + 4) & 7;
  v9 += v124;
  v125 = v10 - (_DWORD)v9;
  if (v10 - (int)v9 < 4)
  {
    if (v125 < 1)
    {
      v12 = 0;
      if (v8 | v125)
        goto LABEL_748;
    }
    else
    {
      v126 = *v9;
      if (v125 == 1)
      {
        v12 = v126 << 24;
      }
      else
      {
        v127 = (v126 << 16) | (v9[1] << 8);
        if (v125 != 2)
          v127 |= v9[2];
        v12 = v127 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  v128 = v12 << v8;
  if ((v115 & 0x80000000) == 0)
  {
    v129 = 0;
    v130 = v113 - v114;
    while (v128 < 0x80000)
    {
      v132 = (v8 + 1) >> 3;
      v8 = (v8 + 1) & 7;
      v9 += v132;
      v133 = v10 - (_DWORD)v9;
      if (v10 - (int)v9 < 4)
      {
        if (v133 < 1)
        {
          v12 = 0;
          if (v8 | v133)
            goto LABEL_748;
        }
        else
        {
          v134 = *v9;
          if (v133 == 1)
          {
            v12 = v134 << 24;
          }
          else
          {
            v135 = (v134 << 16) | (v9[1] << 8);
            if (v133 != 2)
              v135 |= v9[2];
            v12 = v135 << 8;
          }
        }
      }
      else
      {
        v12 = bswap32(*(_DWORD *)v9);
      }
      v136 = 0;
      v12 <<= v8;
      do
      {
        v137 = v8;
        v138 = v12;
        v139 = (v8 + 1) >> 3;
        v8 = (v8 + 1) & 7;
        v9 += v139;
        v140 = v10 - (_DWORD)v9;
        if (v10 - (int)v9 < 4)
        {
          if (v140 < 1)
          {
            v12 = 0;
            if (v8 | v140)
              goto LABEL_748;
          }
          else
          {
            v141 = *v9;
            if (v140 == 1)
            {
              v12 = v141 << 24;
            }
            else
            {
              v142 = (v141 << 16) | (v9[1] << 8);
              if (v140 != 2)
                v142 |= v9[2];
              v12 = v142 << 8;
            }
          }
        }
        else
        {
          v12 = bswap32(*(_DWORD *)v9);
        }
        v12 <<= v8;
        ++v136;
      }
      while ((v138 & 0x80000000) == 0);
      if (v136 - 1 > 0x1E)
        goto LABEL_748;
      v143 = ((v137 + 1) & 7) + v136;
      if (v136 <= 0x18)
      {
        v8 = v143 & 7;
        v52 = &v9[v143 >> 3];
LABEL_320:
        v144 = v10 - (_DWORD)v52;
        if (v10 - (int)v52 >= 4)
          goto LABEL_329;
        if (v144 >= 1)
        {
          v145 = *v52;
          if (v144 == 1)
            goto LABEL_332;
          v146 = (v145 << 16) | (v52[1] << 8);
          if (v144 != 2)
          {
            v147 = v52[2];
            goto LABEL_337;
          }
          goto LABEL_338;
        }
        goto LABEL_333;
      }
      v8 = v143 & 7;
      v9 += (v143 - 16) >> 3;
      v148 = v10 - (_DWORD)v9;
      if (v10 - (int)v9 <= 3 && v148 <= 0 && v8 | v148)
        goto LABEL_747;
      v52 = v9 + 2;
      v144 = v10 - ((_DWORD)v9 + 2);
      if (v144 >= 4)
      {
LABEL_329:
        v12 = bswap32(*(_DWORD *)v52);
        goto LABEL_339;
      }
      if (v144 >= 1)
      {
        v145 = *v52;
        if (v144 == 1)
        {
LABEL_332:
          v12 = v145 << 24;
          goto LABEL_339;
        }
        v146 = (v145 << 16) | (v9[3] << 8);
        if (v144 != 2)
        {
          v147 = v9[4];
LABEL_337:
          v146 |= v147;
        }
LABEL_338:
        v12 = v146 << 8;
        goto LABEL_339;
      }
LABEL_333:
      v12 = 0;
      if (v8 | v144)
        goto LABEL_105;
LABEL_339:
      if (v12 << v8 < 0x80000)
      {
        v154 = (v8 + 1) >> 3;
        v8 = (v8 + 1) & 7;
        v9 = &v52[v154];
        v155 = v10 - ((_DWORD)v52 + v154);
        if (v155 < 4)
        {
          if (v155 < 1)
          {
            v12 = 0;
            if (v8 | v155)
              goto LABEL_748;
          }
          else
          {
            v156 = *v9;
            if (v155 == 1)
            {
              v12 = v156 << 24;
            }
            else
            {
              v157 = (v156 << 16) | (v9[1] << 8);
              if (v155 != 2)
                v157 |= v9[2];
              v12 = v157 << 8;
            }
          }
        }
        else
        {
          v12 = bswap32(*(_DWORD *)v9);
        }
        v158 = 0;
        v12 <<= v8;
        do
        {
          v159 = v8;
          v160 = v12;
          v161 = (v8 + 1) >> 3;
          v8 = (v8 + 1) & 7;
          v9 += v161;
          v162 = v10 - (_DWORD)v9;
          if (v10 - (int)v9 < 4)
          {
            if (v162 < 1)
            {
              v12 = 0;
              if (v8 | v162)
                goto LABEL_748;
            }
            else
            {
              v163 = *v9;
              if (v162 == 1)
              {
                v12 = v163 << 24;
              }
              else
              {
                v164 = (v163 << 16) | (v9[1] << 8);
                if (v162 != 2)
                  v164 |= v9[2];
                v12 = v164 << 8;
              }
            }
          }
          else
          {
            v12 = bswap32(*(_DWORD *)v9);
          }
          v12 <<= v8;
          ++v158;
        }
        while ((v160 & 0x80000000) == 0);
        if (v158 - 1 > 0x1E)
          goto LABEL_748;
        v165 = ((v159 + 1) & 7) + v158;
        if (v158 > 0x18)
        {
          v8 = v165 & 7;
          v9 += (v165 - 16) >> 3;
          v166 = v10 - (_DWORD)v9;
          if (v10 - (int)v9 <= 3 && v166 <= 0 && v8 | v166)
            goto LABEL_747;
          v9 += 2;
        }
        else
        {
          v8 = v165 & 7;
          v9 += v165 >> 3;
        }
        v167 = v10 - (_DWORD)v9;
        if (v10 - (int)v9 <= 3 && v167 <= 0 && v8 | v167)
          goto LABEL_747;
      }
      else
      {
        v149 = v8 + 2 * __clz(v12 << v8) + 1;
        v150 = v149 >> 3;
        v8 = v149 & 7;
        v9 = &v52[v150];
        v151 = v10 - ((_DWORD)v52 + v150);
        if (v151 <= 3 && v151 <= 0 && (v8 | v151) != 0)
        {
LABEL_747:
          v12 = 0;
          goto LABEL_748;
        }
      }
      v168 = (v8 + 1) >> 3;
      v8 = (v8 + 1) & 7;
      v9 += v168;
      v169 = v10 - (_DWORD)v9;
      if (v10 - (int)v9 < 4)
      {
        if (v169 < 1)
        {
          v12 = 0;
          if (v8 | v169)
            goto LABEL_748;
        }
        else
        {
          v170 = *v9;
          if (v169 == 1)
          {
            v12 = v170 << 24;
          }
          else
          {
            v171 = (v170 << 16) | (v9[1] << 8);
            if (v169 != 2)
              v171 |= v9[2];
            v12 = v171 << 8;
          }
        }
      }
      else
      {
        v12 = bswap32(*(_DWORD *)v9);
      }
      v128 = v12 << v8;
      if (++v129 == v130)
        goto LABEL_391;
    }
    v131 = v8 + 2 * __clz(v128) + 1;
    v8 = v131 & 7;
    v52 = &v9[v131 >> 3];
    goto LABEL_320;
  }
LABEL_391:
  a2[35] = v128 >> 27;
  v172 = (v8 + 5) >> 3;
  v8 = (v8 + 5) & 7;
  v9 += v172;
  v173 = v10 - (_DWORD)v9;
  if (v10 - (int)v9 < 4)
  {
    if (v173 < 1)
    {
      v12 = 0;
      if (v8 | v173)
        goto LABEL_748;
    }
    else
    {
      v174 = *v9;
      if (v173 == 1)
      {
        v12 = v174 << 24;
      }
      else
      {
        v175 = (v174 << 16) | (v9[1] << 8);
        if (v173 != 2)
          v175 |= v9[2];
        v12 = v175 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  a2[36] = v12 << v8 >> 27;
  v176 = (v8 + 5) >> 3;
  v8 = (v8 + 5) & 7;
  v9 += v176;
  v177 = v10 - (_DWORD)v9;
  if (v10 - (int)v9 < 4)
  {
    if (v177 < 1)
    {
      v12 = 0;
      if (v8 | v177)
        goto LABEL_748;
    }
    else
    {
      v178 = *v9;
      if (v177 == 1)
      {
        v12 = v178 << 24;
      }
      else
      {
        v179 = (v178 << 16) | (v9[1] << 8);
        if (v177 != 2)
          v179 |= v9[2];
        v12 = v179 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  a2[37] = v12 << v8 >> 27;
  v180 = (v8 + 5) >> 3;
  v8 = (v8 + 5) & 7;
  v9 += v180;
  v181 = v10 - (_DWORD)v9;
  if (v10 - (int)v9 < 4)
  {
    if (v181 < 1)
    {
      v12 = 0;
      if (v8 | v181)
        goto LABEL_748;
    }
    else
    {
      v182 = *v9;
      if (v181 == 1)
      {
        v12 = v182 << 24;
      }
      else
      {
        v183 = (v182 << 16) | (v9[1] << 8);
        if (v181 != 2)
          v183 |= v9[2];
        v12 = v183 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  a2[38] = v12 << v8 >> 27;
  v184 = (v8 + 5) >> 3;
  v8 = (v8 + 5) & 7;
  v9 += v184;
  v185 = v10 - (_DWORD)v9;
  if (v10 - (int)v9 < 4)
  {
    if (v185 < 1)
    {
      v12 = 0;
      if (v8 | v185)
        goto LABEL_748;
    }
    else
    {
      v186 = *v9;
      if (v185 == 1)
      {
        v12 = v186 << 24;
      }
      else
      {
        v187 = (v186 << 16) | (v9[1] << 8);
        if (v185 != 2)
          v187 |= v9[2];
        v12 = v187 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  v111 = v12 << v8;
LABEL_432:
  a2[21] = v111 >> 31;
  v188 = (v8 + 1) >> 3;
  v8 = (v8 + 1) & 7;
  v9 += v188;
  v189 = v10 - (_DWORD)v9;
  if (v10 - (int)v9 < 4)
  {
    if (v189 < 1)
    {
      v12 = 0;
      if (v8 | v189)
        goto LABEL_748;
    }
    else
    {
      v190 = *v9;
      if (v189 == 1)
      {
        v12 = v190 << 24;
      }
      else
      {
        v191 = (v190 << 16) | (v9[1] << 8);
        if (v189 != 2)
          v191 |= v9[2];
        v12 = v191 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  v12 <<= v8;
  if ((v111 & 0x80000000) != 0)
  {
    if (v12 < 0x80000)
      goto LABEL_748;
    v192 = __clz(v12);
    if (v192)
      v193 = v12 << (v192 + 1) >> -(char)v192;
    else
      v193 = 0;
    v194 = -1 << v192;
    v195 = v193 + ~(-1 << v192);
    a2[32] = v195;
    v196 = v192 + v8 + v192 + 1;
    v8 = v196 & 7;
    v9 += v196 >> 3;
    v197 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v197 < 1)
      {
        v12 = 0;
        if (v8 | v197)
          goto LABEL_748;
      }
      else
      {
        v198 = *v9;
        if (v197 == 1)
        {
          v12 = v198 << 24;
        }
        else
        {
          v199 = (v198 << 16) | (v9[1] << 8);
          if (v197 != 2)
            v199 |= v9[2];
          v12 = v199 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v195 > 31)
      goto LABEL_748;
    a2[33] = v12 >> 28;
    v200 = (v8 + 4) >> 3;
    v8 = (v8 + 4) & 7;
    v9 += v200;
    v201 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v201 < 1)
      {
        v12 = 0;
        if (v8 | v201)
          goto LABEL_748;
      }
      else
      {
        v202 = *v9;
        if (v201 == 1)
        {
          v12 = v202 << 24;
        }
        else
        {
          v203 = (v202 << 16) | (v9[1] << 8);
          if (v201 != 2)
            v203 |= v9[2];
          v12 = v203 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    a2[34] = v12 << v8 >> 28;
    v204 = (v8 + 4) >> 3;
    v8 = (v8 + 4) & 7;
    v9 += v204;
    v205 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v205 < 1)
      {
        v12 = 0;
        if (v8 | v205)
          goto LABEL_748;
      }
      else
      {
        v206 = *v9;
        if (v205 == 1)
        {
          v12 = v206 << 24;
        }
        else
        {
          v207 = (v206 << 16) | (v9[1] << 8);
          if (v205 != 2)
            v207 |= v9[2];
          v12 = v207 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    v208 = v12 << v8;
    if ((v195 & 0x80000000) == 0)
    {
      v209 = 0;
      v210 = v193 - v194;
      while (v208 < 0x80000)
      {
        v212 = (v8 + 1) >> 3;
        v8 = (v8 + 1) & 7;
        v9 += v212;
        v213 = v10 - (_DWORD)v9;
        if (v10 - (int)v9 < 4)
        {
          if (v213 < 1)
          {
            v12 = 0;
            if (v8 | v213)
              goto LABEL_748;
          }
          else
          {
            v214 = *v9;
            if (v213 == 1)
            {
              v12 = v214 << 24;
            }
            else
            {
              v215 = (v214 << 16) | (v9[1] << 8);
              if (v213 != 2)
                v215 |= v9[2];
              v12 = v215 << 8;
            }
          }
        }
        else
        {
          v12 = bswap32(*(_DWORD *)v9);
        }
        v216 = 0;
        v12 <<= v8;
        do
        {
          v217 = v8;
          v218 = v12;
          v219 = (v8 + 1) >> 3;
          v8 = (v8 + 1) & 7;
          v9 += v219;
          v220 = v10 - (_DWORD)v9;
          if (v10 - (int)v9 < 4)
          {
            if (v220 < 1)
            {
              v12 = 0;
              if (v8 | v220)
                goto LABEL_748;
            }
            else
            {
              v221 = *v9;
              if (v220 == 1)
              {
                v12 = v221 << 24;
              }
              else
              {
                v222 = (v221 << 16) | (v9[1] << 8);
                if (v220 != 2)
                  v222 |= v9[2];
                v12 = v222 << 8;
              }
            }
          }
          else
          {
            v12 = bswap32(*(_DWORD *)v9);
          }
          v12 <<= v8;
          ++v216;
        }
        while ((v218 & 0x80000000) == 0);
        if (v216 - 1 > 0x1E)
          goto LABEL_748;
        v223 = ((v217 + 1) & 7) + v216;
        if (v216 <= 0x18)
        {
          v8 = v223 & 7;
          v52 = &v9[v223 >> 3];
LABEL_507:
          v224 = v10 - (_DWORD)v52;
          if (v10 - (int)v52 >= 4)
            goto LABEL_516;
          if (v224 >= 1)
          {
            v225 = *v52;
            if (v224 == 1)
              goto LABEL_519;
            v226 = (v225 << 16) | (v52[1] << 8);
            if (v224 != 2)
            {
              v227 = v52[2];
              goto LABEL_524;
            }
            goto LABEL_525;
          }
          goto LABEL_520;
        }
        v8 = v223 & 7;
        v9 += (v223 - 16) >> 3;
        v228 = v10 - (_DWORD)v9;
        if (v10 - (int)v9 <= 3 && v228 <= 0 && v8 | v228)
          goto LABEL_747;
        v52 = v9 + 2;
        v224 = v10 - ((_DWORD)v9 + 2);
        if (v224 >= 4)
        {
LABEL_516:
          v12 = bswap32(*(_DWORD *)v52);
          goto LABEL_526;
        }
        if (v224 >= 1)
        {
          v225 = *v52;
          if (v224 == 1)
          {
LABEL_519:
            v12 = v225 << 24;
            goto LABEL_526;
          }
          v226 = (v225 << 16) | (v9[3] << 8);
          if (v224 != 2)
          {
            v227 = v9[4];
LABEL_524:
            v226 |= v227;
          }
LABEL_525:
          v12 = v226 << 8;
          goto LABEL_526;
        }
LABEL_520:
        v12 = 0;
        if (v8 | v224)
          goto LABEL_105;
LABEL_526:
        if (v12 << v8 < 0x80000)
        {
          v234 = (v8 + 1) >> 3;
          v8 = (v8 + 1) & 7;
          v9 = &v52[v234];
          v235 = v10 - ((_DWORD)v52 + v234);
          if (v235 < 4)
          {
            if (v235 < 1)
            {
              v12 = 0;
              if (v8 | v235)
                goto LABEL_748;
            }
            else
            {
              v236 = *v9;
              if (v235 == 1)
              {
                v12 = v236 << 24;
              }
              else
              {
                v237 = (v236 << 16) | (v9[1] << 8);
                if (v235 != 2)
                  v237 |= v9[2];
                v12 = v237 << 8;
              }
            }
          }
          else
          {
            v12 = bswap32(*(_DWORD *)v9);
          }
          v238 = 0;
          v12 <<= v8;
          do
          {
            v239 = v8;
            v240 = v12;
            v241 = (v8 + 1) >> 3;
            v8 = (v8 + 1) & 7;
            v9 += v241;
            v242 = v10 - (_DWORD)v9;
            if (v10 - (int)v9 < 4)
            {
              if (v242 < 1)
              {
                v12 = 0;
                if (v8 | v242)
                  goto LABEL_748;
              }
              else
              {
                v243 = *v9;
                if (v242 == 1)
                {
                  v12 = v243 << 24;
                }
                else
                {
                  v244 = (v243 << 16) | (v9[1] << 8);
                  if (v242 != 2)
                    v244 |= v9[2];
                  v12 = v244 << 8;
                }
              }
            }
            else
            {
              v12 = bswap32(*(_DWORD *)v9);
            }
            v12 <<= v8;
            ++v238;
          }
          while ((v240 & 0x80000000) == 0);
          if (v238 - 1 > 0x1E)
            goto LABEL_748;
          v245 = ((v239 + 1) & 7) + v238;
          if (v238 > 0x18)
          {
            v8 = v245 & 7;
            v9 += (v245 - 16) >> 3;
            v246 = v10 - (_DWORD)v9;
            if (v10 - (int)v9 <= 3 && v246 <= 0 && v8 | v246)
              goto LABEL_747;
            v9 += 2;
          }
          else
          {
            v8 = v245 & 7;
            v9 += v245 >> 3;
          }
          v247 = v10 - (_DWORD)v9;
          if (v10 - (int)v9 <= 3 && v247 <= 0 && v8 | v247)
            goto LABEL_747;
        }
        else
        {
          v229 = v8 + 2 * __clz(v12 << v8) + 1;
          v230 = v229 >> 3;
          v8 = v229 & 7;
          v9 = &v52[v230];
          v231 = v10 - ((_DWORD)v52 + v230);
          if (v231 <= 3 && v231 <= 0 && (v8 | v231) != 0)
            goto LABEL_747;
        }
        v248 = (v8 + 1) >> 3;
        v8 = (v8 + 1) & 7;
        v9 += v248;
        v249 = v10 - (_DWORD)v9;
        if (v10 - (int)v9 < 4)
        {
          if (v249 < 1)
          {
            v12 = 0;
            if (v8 | v249)
              goto LABEL_748;
          }
          else
          {
            v250 = *v9;
            if (v249 == 1)
            {
              v12 = v250 << 24;
            }
            else
            {
              v251 = (v250 << 16) | (v9[1] << 8);
              if (v249 != 2)
                v251 |= v9[2];
              v12 = v251 << 8;
            }
          }
        }
        else
        {
          v12 = bswap32(*(_DWORD *)v9);
        }
        if (*((_DWORD *)a1 + 2) < *((_DWORD *)a1 + 4) - *(_DWORD *)a1)
          goto LABEL_746;
        v208 = v12 << v8;
        if (++v209 == v210)
          goto LABEL_579;
      }
      v211 = v8 + 2 * __clz(v208) + 1;
      v8 = v211 & 7;
      v52 = &v9[v211 >> 3];
      goto LABEL_507;
    }
LABEL_579:
    a2[35] = v208 >> 27;
    v252 = (v8 + 5) >> 3;
    v8 = (v8 + 5) & 7;
    v9 += v252;
    v253 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v253 < 1)
      {
        v12 = 0;
        if (v8 | v253)
          goto LABEL_748;
      }
      else
      {
        v254 = *v9;
        if (v253 == 1)
        {
          v12 = v254 << 24;
        }
        else
        {
          v255 = (v254 << 16) | (v9[1] << 8);
          if (v253 != 2)
            v255 |= v9[2];
          v12 = v255 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    a2[36] = v12 << v8 >> 27;
    v256 = (v8 + 5) >> 3;
    v8 = (v8 + 5) & 7;
    v9 += v256;
    v257 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v257 < 1)
      {
        v12 = 0;
        if (v8 | v257)
          goto LABEL_748;
      }
      else
      {
        v258 = *v9;
        if (v257 == 1)
        {
          v12 = v258 << 24;
        }
        else
        {
          v259 = (v258 << 16) | (v9[1] << 8);
          if (v257 != 2)
            v259 |= v9[2];
          v12 = v259 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    a2[37] = v12 << v8 >> 27;
    v260 = (v8 + 5) >> 3;
    v8 = (v8 + 5) & 7;
    v9 += v260;
    v261 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v261 < 1)
      {
        v12 = 0;
        if (v8 | v261)
          goto LABEL_748;
      }
      else
      {
        v262 = *v9;
        if (v261 == 1)
        {
          v12 = v262 << 24;
        }
        else
        {
          v263 = (v262 << 16) | (v9[1] << 8);
          if (v261 != 2)
            v263 |= v9[2];
          v12 = v263 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    a2[38] = v12 << v8 >> 27;
    v264 = (v8 + 5) >> 3;
    v8 = (v8 + 5) & 7;
    v9 += v264;
    v265 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v265 < 1)
      {
        v12 = 0;
        if (v8 | v265)
          goto LABEL_748;
      }
      else
      {
        v266 = *v9;
        if (v265 == 1)
        {
          v12 = v266 << 24;
        }
        else
        {
          v267 = (v266 << 16) | (v9[1] << 8);
          if (v265 != 2)
            v267 |= v9[2];
          v12 = v267 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
  }
  if (*((_DWORD *)a1 + 2) < *((_DWORD *)a1 + 4) - *(_DWORD *)a1)
  {
LABEL_746:
    v321 = 4294954582;
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    return v321;
  }
  if (a2[20] || a2[21])
  {
    a2[22] = v12 >> 31;
    v268 = (v8 + 1) >> 3;
    v8 = (v8 + 1) & 7;
    v9 += v268;
    v269 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v269 < 1)
      {
        v12 = 0;
        if (v8 | v269)
          goto LABEL_748;
      }
      else
      {
        v270 = *v9;
        if (v269 == 1)
        {
          v12 = v270 << 24;
        }
        else
        {
          v271 = (v270 << 16) | (v9[1] << 8);
          if (v269 != 2)
            v271 |= v9[2];
          v12 = v271 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
  }
  a2[23] = v12 >> 31;
  v272 = (v8 + 1) >> 3;
  v8 = (v8 + 1) & 7;
  v9 += v272;
  v273 = v10 - (_DWORD)v9;
  if (v10 - (int)v9 < 4)
  {
    if (v273 < 1)
    {
      v12 = 0;
      if (v8 | v273)
        goto LABEL_748;
    }
    else
    {
      v274 = *v9;
      if (v273 == 1)
      {
        v12 = v274 << 24;
      }
      else
      {
        v275 = (v274 << 16) | (v9[1] << 8);
        if (v273 != 2)
          v275 |= v9[2];
        v12 = v275 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  v276 = v12 << v8;
  a2[24] = v12 << v8 >> 31;
  v277 = (v8 + 1) >> 3;
  v8 = (v8 + 1) & 7;
  v9 += v277;
  v278 = v10 - (_DWORD)v9;
  if (v10 - (int)v9 < 4)
  {
    if (v278 < 1)
    {
      v12 = 0;
      if (v8 | v278)
        goto LABEL_748;
    }
    else
    {
      v279 = *v9;
      if (v278 == 1)
      {
        v12 = v279 << 24;
      }
      else
      {
        v280 = (v279 << 16) | (v9[1] << 8);
        if (v278 != 2)
          v280 |= v9[2];
        v12 = v280 << 8;
      }
    }
  }
  else
  {
    v12 = bswap32(*(_DWORD *)v9);
  }
  v12 <<= v8;
  if ((v276 & 0x80000000) != 0)
  {
    a2[25] = v12 >> 31;
    v281 = (v8 + 1) >> 3;
    v8 = (v8 + 1) & 7;
    v9 += v281;
    v282 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v282 < 1)
      {
        v12 = 0;
        if (v8 | v282)
          goto LABEL_748;
      }
      else
      {
        v283 = *v9;
        if (v282 == 1)
        {
          v12 = v283 << 24;
        }
        else
        {
          v284 = (v283 << 16) | (v9[1] << 8);
          if (v282 != 2)
            v284 |= v9[2];
          v12 = v284 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v12 < 0x80000)
      goto LABEL_748;
    v285 = __clz(v12);
    v286 = v12 << (v285 + 1) >> -(char)v285;
    if (!v285)
      v286 = 0;
    a2[26] = v286 + ~(-1 << v285);
    v287 = v285 + v8 + v285 + 1;
    v8 = v287 & 7;
    v9 += v287 >> 3;
    v288 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v288 < 1)
      {
        v12 = 0;
        if (v8 | v288)
          goto LABEL_748;
      }
      else
      {
        v289 = *v9;
        if (v288 == 1)
        {
          v12 = v289 << 24;
        }
        else
        {
          v290 = (v289 << 16) | (v9[1] << 8);
          if (v288 != 2)
            v290 |= v9[2];
          v12 = v290 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v12 < 0x80000)
      goto LABEL_748;
    v291 = __clz(v12);
    v292 = v12 << (v291 + 1) >> -(char)v291;
    if (!v291)
      v292 = 0;
    a2[27] = v292 + ~(-1 << v291);
    v293 = v291 + v8 + v291 + 1;
    v8 = v293 & 7;
    v9 += v293 >> 3;
    v294 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v294 < 1)
      {
        v12 = 0;
        if (v8 | v294)
          goto LABEL_748;
      }
      else
      {
        v295 = *v9;
        if (v294 == 1)
        {
          v12 = v295 << 24;
        }
        else
        {
          v296 = (v295 << 16) | (v9[1] << 8);
          if (v294 != 2)
            v296 |= v9[2];
          v12 = v296 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v12 < 0x80000)
      goto LABEL_748;
    v297 = __clz(v12);
    v298 = v12 << (v297 + 1) >> -(char)v297;
    if (!v297)
      v298 = 0;
    a2[28] = v298 + ~(-1 << v297);
    v299 = v297 + v8 + v297 + 1;
    v8 = v299 & 7;
    v9 += v299 >> 3;
    v300 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v300 < 1)
      {
        v12 = 0;
        if (v8 | v300)
          goto LABEL_748;
      }
      else
      {
        v301 = *v9;
        if (v300 == 1)
        {
          v12 = v301 << 24;
        }
        else
        {
          v302 = (v301 << 16) | (v9[1] << 8);
          if (v300 != 2)
            v302 |= v9[2];
          v12 = v302 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v12 < 0x80000)
      goto LABEL_748;
    v303 = __clz(v12);
    v304 = v12 << (v303 + 1) >> -(char)v303;
    if (!v303)
      v304 = 0;
    a2[29] = v304 + ~(-1 << v303);
    v305 = v303 + v8 + v303 + 1;
    v8 = v305 & 7;
    v9 += v305 >> 3;
    v306 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v306 < 1)
      {
        v12 = 0;
        if (v8 | v306)
          goto LABEL_748;
      }
      else
      {
        v307 = *v9;
        if (v306 == 1)
        {
          v12 = v307 << 24;
        }
        else
        {
          v308 = (v307 << 16) | (v9[1] << 8);
          if (v306 != 2)
            v308 |= v9[2];
          v12 = v308 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v12 < 0x80000)
      goto LABEL_748;
    v309 = __clz(v12);
    v310 = v12 << (v309 + 1) >> -(char)v309;
    if (!v309)
      v310 = 0;
    a2[30] = v310 + ~(-1 << v309);
    v311 = v309 + v8 + v309 + 1;
    v8 = v311 & 7;
    v9 += v311 >> 3;
    v312 = v10 - (_DWORD)v9;
    if (v10 - (int)v9 < 4)
    {
      if (v312 < 1)
      {
        v12 = 0;
        if (v8 | v312)
          goto LABEL_748;
      }
      else
      {
        v313 = *v9;
        if (v312 == 1)
        {
          v12 = v313 << 24;
        }
        else
        {
          v314 = (v313 << 16) | (v9[1] << 8);
          if (v312 != 2)
            v314 |= v9[2];
          v12 = v314 << 8;
        }
      }
    }
    else
    {
      v12 = bswap32(*(_DWORD *)v9);
    }
    v12 <<= v8;
    if (v12 < 0x80000)
      goto LABEL_748;
    v315 = __clz(v12);
    v316 = v12 << (v315 + 1) >> -(char)v315;
    if (!v315)
      v316 = 0;
    a2[31] = v316 + ~(-1 << v315);
    v317 = v315 + v8 + v315 + 1;
    v8 = v317 & 7;
    v9 += v317 >> 3;
    v318 = v10 - (_DWORD)v9;
    if (v318 >= 4)
    {
      v12 = bswap32(*(_DWORD *)v9);
      goto LABEL_743;
    }
    if (v318 >= 1)
    {
      v319 = *v9;
      if (v318 == 1)
      {
        v12 = v319 << 24;
      }
      else
      {
        v320 = (v319 << 16) | (v9[1] << 8);
        if (v318 != 2)
          v320 |= v9[2];
        v12 = v320 << 8;
      }
      goto LABEL_743;
    }
    v12 = 0;
    if (!(v8 | v318))
    {
LABEL_743:
      v12 <<= v8;
      goto LABEL_744;
    }
LABEL_748:
    v321 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    if ((_DWORD)v321)
      return v321;
  }
LABEL_744:
  v321 = 0;
  a1[2] = (uint64_t)v9;
  *((_DWORD *)a1 + 6) = v12;
  *((_BYTE *)a1 + 28) = v8;
  return v321;
}

uint64_t PullSliceHeaderPredWeightTable(uint64_t *a1, _DWORD *a2, uint64_t a3, int a4)
{
  int v5;
  unsigned __int8 *v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  BOOL v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  char v27;
  unsigned int v28;
  int v29;
  uint64_t v30;
  int v31;
  unsigned int v32;
  int v33;
  BOOL v34;
  char v35;
  int v36;
  unsigned int v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  unsigned int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  int v52;
  char v53;
  char v54;
  unsigned int v55;
  int v56;
  unsigned int v57;
  int v58;
  int v59;
  unsigned int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  unsigned int v66;
  int v67;
  uint64_t v68;
  int v69;
  unsigned int v70;
  int v71;
  BOOL v72;
  char v73;
  int v74;
  unsigned int v75;
  int v76;
  unsigned int v77;
  int v78;
  int v79;
  unsigned int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  uint64_t v85;
  int v86;
  int v87;
  int v88;
  int v89;
  char v90;
  char v91;
  unsigned int v92;
  int v93;
  unsigned int v94;
  int v95;
  int v96;
  unsigned int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  uint64_t result;

  if (*(_DWORD *)(a3 + 8))
    v5 = 0;
  else
    v5 = *(_DWORD *)(a3 + 4);
  v6 = (unsigned __int8 *)a1[2];
  v7 = *((_DWORD *)a1 + 6);
  v8 = *((unsigned __int8 *)a1 + 28);
  v9 = *((_DWORD *)a1 + 2);
  v10 = *a1;
  if (a4)
  {
    if (v7 < 0x80000)
      goto LABEL_243;
  }
  else if (v7 < 0x80000)
  {
    goto LABEL_245;
  }
  v11 = __clz(v7);
  v12 = v7 << (v11 + 1) >> -(char)v11;
  if (!v11)
    v12 = 0;
  a2[17] = v12 + ~(-1 << v11);
  v13 = v11 + 1 + v11 + v8;
  v8 = v13 & 7;
  v6 += v13 >> 3;
  v14 = v10 + v9;
  v15 = v14 - (_DWORD)v6;
  if (v14 - (int)v6 < 4)
  {
    if (v15 < 1)
    {
      v18 = (v8 | v15 | v5) == 0;
      v7 = 0;
      if (a4)
      {
        if (!v18)
          goto LABEL_243;
      }
      else if (!v18)
      {
        goto LABEL_245;
      }
      goto LABEL_40;
    }
    v17 = *v6;
    if (v15 == 1)
    {
      v16 = v17 << 24;
    }
    else
    {
      v19 = (v17 << 16) | (v6[1] << 8);
      if (v15 != 2)
        v19 |= v6[2];
      v16 = v19 << 8;
    }
  }
  else
  {
    v16 = bswap32(*(_DWORD *)v6);
  }
  v7 = v16 << v8;
  if (v5)
  {
    if (a4)
    {
      if (v7 < 0x80000)
        goto LABEL_243;
    }
    else if (v7 < 0x80000)
    {
      goto LABEL_245;
    }
    v20 = __clz(v7);
    v21 = v7 << (v20 + 1) >> -(char)v20;
    if (!v20)
      v21 = 0;
    a2[18] = v21 + ~(-1 << v20);
    v22 = v20 + v8 + v20 + 1;
    v8 = v22 & 7;
    v6 += v22 >> 3;
    v23 = v14 - (_DWORD)v6;
    if (v14 - (int)v6 >= 4)
    {
      v7 = bswap32(*(_DWORD *)v6);
      goto LABEL_42;
    }
    if (v23 >= 1)
    {
      v24 = *v6;
      if (v23 == 1)
      {
        v7 = v24 << 24;
      }
      else
      {
        v26 = (v24 << 16) | (v6[1] << 8);
        if (v23 != 2)
          v26 |= v6[2];
        v7 = v26 << 8;
      }
      goto LABEL_42;
    }
    v25 = v8 | v23;
    v7 = 0;
    if (a4)
    {
      if (v25)
        goto LABEL_243;
      goto LABEL_42;
    }
    if (!v25)
    {
LABEL_42:
      v27 = 0;
      v7 <<= v8;
      goto LABEL_43;
    }
LABEL_245:
    result = 4294954582;
    goto LABEL_246;
  }
LABEL_40:
  v27 = 1;
LABEL_43:
  v28 = a2[13];
  if (v28 - 32 < 0xFFFFFFDF)
    goto LABEL_249;
  v29 = 0;
  while (1)
  {
    v30 = (v8 + 1) >> 3;
    v8 = (v8 + 1) & 7;
    v6 += v30;
    v31 = v14 - (_DWORD)v6;
    if (v14 - (int)v6 >= 4)
    {
      v32 = bswap32(*(_DWORD *)v6);
      goto LABEL_62;
    }
    if (v31 < 1)
    {
      if (v8 | v31)
        v34 = 1;
      else
        v34 = (v7 & 0x80000000) != 0;
      v35 = !v34;
      if (!a4)
      {
        if ((v35 & 1) == 0)
        {
LABEL_244:
          v7 = 0;
          goto LABEL_245;
        }
LABEL_85:
        v37 = 0;
        v7 = 0;
        if ((v27 & 1) == 0)
          goto LABEL_96;
        goto LABEL_139;
      }
      if ((v35 & 1) != 0)
        goto LABEL_85;
LABEL_242:
      v7 = 0;
LABEL_243:
      result = 4294954582;
      goto LABEL_247;
    }
    v33 = *v6;
    if (v31 == 1)
    {
      v32 = v33 << 24;
    }
    else
    {
      v36 = (v33 << 16) | (v6[1] << 8);
      if (v31 != 2)
        v36 |= v6[2];
      v32 = v36 << 8;
    }
LABEL_62:
    v37 = v32 << v8;
    if ((v7 & 0x80000000) == 0)
      goto LABEL_95;
    if (a4)
    {
      if (v37 < 0x80000)
      {
LABEL_250:
        result = 4294954582;
        v7 = v37;
        goto LABEL_247;
      }
    }
    else if (v37 < 0x80000)
    {
LABEL_251:
      result = 4294954582;
      v7 = v37;
      goto LABEL_246;
    }
    v38 = v8 + 2 * __clz(v37) + 1;
    v8 = v38 & 7;
    v6 += v38 >> 3;
    v39 = v14 - (_DWORD)v6;
    if (v14 - (int)v6 < 4)
      break;
    v40 = bswap32(*(_DWORD *)v6);
LABEL_75:
    v7 = v40 << v8;
    if (a4)
    {
      if (v7 < 0x80000)
        goto LABEL_243;
    }
    else if (v7 < 0x80000)
    {
      goto LABEL_245;
    }
    v43 = v8 + 2 * __clz(v7) + 1;
    v8 = v43 & 7;
    v6 += v43 >> 3;
    v44 = v14 - (_DWORD)v6;
    if (v14 - (int)v6 < 4)
    {
      if (v44 < 1)
      {
        v46 = v8 | v44;
        v7 = 0;
        if (a4)
        {
          if (v46)
            goto LABEL_243;
        }
        else if (v46)
        {
          goto LABEL_245;
        }
      }
      else
      {
        v45 = *v6;
        if (v44 == 1)
        {
          v7 = v45 << 24;
        }
        else
        {
          v47 = (v45 << 16) | (v6[1] << 8);
          if (v44 != 2)
            v47 |= v6[2];
          v7 = v47 << 8;
        }
      }
    }
    else
    {
      v7 = bswap32(*(_DWORD *)v6);
    }
    v37 = v7 << v8;
LABEL_95:
    v7 = v37;
    if ((v27 & 1) == 0)
    {
LABEL_96:
      v48 = (v8 + 1) >> 3;
      v8 = (v8 + 1) & 7;
      v6 += v48;
      v49 = v14 - (_DWORD)v6;
      if (v14 - (int)v6 < 4)
      {
        if (v49 < 1)
        {
          v51 = v8 | v49;
          v7 = 0;
          if (a4)
          {
            if (v51)
              goto LABEL_243;
          }
          else if (v51)
          {
            goto LABEL_245;
          }
        }
        else
        {
          v50 = *v6;
          if (v49 == 1)
          {
            v7 = v50 << 24;
          }
          else
          {
            v52 = (v50 << 16) | (v6[1] << 8);
            if (v49 != 2)
              v52 |= v6[2];
            v7 = v52 << 8;
          }
        }
      }
      else
      {
        v7 = bswap32(*(_DWORD *)v6);
      }
      v7 <<= v8;
      if ((v37 & 0x80000000) != 0)
      {
        v53 = 1;
        do
        {
          v54 = v53;
          if (a4)
          {
            if (v7 < 0x80000)
              goto LABEL_243;
          }
          else if (v7 < 0x80000)
          {
            goto LABEL_245;
          }
          v55 = v8 + 2 * __clz(v7) + 1;
          v8 = v55 & 7;
          v6 += v55 >> 3;
          v56 = v14 - (_DWORD)v6;
          if (v14 - (int)v6 < 4)
          {
            if (v56 < 1)
              goto LABEL_240;
            v58 = *v6;
            if (v56 == 1)
            {
              v57 = v58 << 24;
            }
            else
            {
              v59 = (v58 << 16) | (v6[1] << 8);
              if (v56 != 2)
                v59 |= v6[2];
              v57 = v59 << 8;
            }
          }
          else
          {
            v57 = bswap32(*(_DWORD *)v6);
          }
          v7 = v57 << v8;
          if (a4)
          {
            if (v7 < 0x80000)
              goto LABEL_243;
          }
          else if (v7 < 0x80000)
          {
            goto LABEL_245;
          }
          v60 = v8 + 2 * __clz(v7) + 1;
          v8 = v60 & 7;
          v6 += v60 >> 3;
          v61 = v14 - (_DWORD)v6;
          if (v14 - (int)v6 < 4)
          {
            if (v61 < 1)
            {
              v63 = v8 | v61;
              v7 = 0;
              if (a4)
              {
                if (v63)
                  goto LABEL_243;
              }
              else if (v63)
              {
                goto LABEL_245;
              }
            }
            else
            {
              v62 = *v6;
              if (v61 == 1)
              {
                v7 = v62 << 24;
              }
              else
              {
                v64 = (v62 << 16) | (v6[1] << 8);
                if (v61 != 2)
                  v64 |= v6[2];
                v7 = v64 << 8;
              }
            }
          }
          else
          {
            v7 = bswap32(*(_DWORD *)v6);
          }
          v53 = 0;
          v7 <<= v8;
        }
        while ((v54 & 1) != 0);
      }
    }
LABEL_139:
    if (++v29 > v28)
    {
      v65 = a2[4];
      if (v65 != 6 && v65 != 1)
      {
        result = 0;
        goto LABEL_247;
      }
      v66 = a2[14];
      if (v66 - 32 >= 0xFFFFFFDF)
      {
        v67 = 0;
        while (1)
        {
          v68 = (v8 + 1) >> 3;
          v8 = (v8 + 1) & 7;
          v6 += v68;
          v69 = v14 - (_DWORD)v6;
          if (v14 - (int)v6 < 4)
          {
            if (v69 < 1)
            {
              if (v8 | v69)
                v72 = 1;
              else
                v72 = (v7 & 0x80000000) != 0;
              v73 = !v72;
              if (a4)
              {
                if ((v73 & 1) == 0)
                  goto LABEL_242;
              }
              else if ((v73 & 1) == 0)
              {
                goto LABEL_244;
              }
              v37 = 0;
              v7 = 0;
              if ((v27 & 1) == 0)
                goto LABEL_195;
              goto LABEL_238;
            }
            v71 = *v6;
            if (v69 == 1)
            {
              v70 = v71 << 24;
            }
            else
            {
              v74 = (v71 << 16) | (v6[1] << 8);
              if (v69 != 2)
                v74 |= v6[2];
              v70 = v74 << 8;
            }
          }
          else
          {
            v70 = bswap32(*(_DWORD *)v6);
          }
          v37 = v70 << v8;
          if ((v7 & 0x80000000) != 0)
          {
            if (a4)
            {
              if (v37 < 0x80000)
                goto LABEL_250;
            }
            else if (v37 < 0x80000)
            {
              goto LABEL_251;
            }
            v75 = v8 + 2 * __clz(v37) + 1;
            v8 = v75 & 7;
            v6 += v75 >> 3;
            v76 = v14 - (_DWORD)v6;
            if (v14 - (int)v6 < 4)
            {
              if (v76 < 1)
                goto LABEL_240;
              v78 = *v6;
              if (v76 == 1)
              {
                v77 = v78 << 24;
              }
              else
              {
                v79 = (v78 << 16) | (v6[1] << 8);
                if (v76 != 2)
                  v79 |= v6[2];
                v77 = v79 << 8;
              }
            }
            else
            {
              v77 = bswap32(*(_DWORD *)v6);
            }
            v7 = v77 << v8;
            if (a4)
            {
              if (v7 < 0x80000)
                goto LABEL_243;
            }
            else if (v7 < 0x80000)
            {
              goto LABEL_245;
            }
            v80 = v8 + 2 * __clz(v7) + 1;
            v8 = v80 & 7;
            v6 += v80 >> 3;
            v81 = v14 - (_DWORD)v6;
            if (v14 - (int)v6 < 4)
            {
              if (v81 < 1)
              {
                v83 = v8 | v81;
                v7 = 0;
                if (a4)
                {
                  if (v83)
                    goto LABEL_243;
                }
                else if (v83)
                {
                  goto LABEL_245;
                }
              }
              else
              {
                v82 = *v6;
                if (v81 == 1)
                {
                  v7 = v82 << 24;
                }
                else
                {
                  v84 = (v82 << 16) | (v6[1] << 8);
                  if (v81 != 2)
                    v84 |= v6[2];
                  v7 = v84 << 8;
                }
              }
            }
            else
            {
              v7 = bswap32(*(_DWORD *)v6);
            }
            v37 = v7 << v8;
          }
          v7 = v37;
          if ((v27 & 1) == 0)
          {
LABEL_195:
            v85 = (v8 + 1) >> 3;
            v8 = (v8 + 1) & 7;
            v6 += v85;
            v86 = v14 - (_DWORD)v6;
            if (v14 - (int)v6 < 4)
            {
              if (v86 < 1)
              {
                v88 = v8 | v86;
                v7 = 0;
                if (a4)
                {
                  if (v88)
                    goto LABEL_243;
                }
                else if (v88)
                {
                  goto LABEL_245;
                }
              }
              else
              {
                v87 = *v6;
                if (v86 == 1)
                {
                  v7 = v87 << 24;
                }
                else
                {
                  v89 = (v87 << 16) | (v6[1] << 8);
                  if (v86 != 2)
                    v89 |= v6[2];
                  v7 = v89 << 8;
                }
              }
            }
            else
            {
              v7 = bswap32(*(_DWORD *)v6);
            }
            v7 <<= v8;
            if ((v37 & 0x80000000) != 0)
            {
              v90 = 1;
              do
              {
                v91 = v90;
                if (a4)
                {
                  if (v7 < 0x80000)
                    goto LABEL_243;
                }
                else if (v7 < 0x80000)
                {
                  goto LABEL_245;
                }
                v92 = v8 + 2 * __clz(v7) + 1;
                v8 = v92 & 7;
                v6 += v92 >> 3;
                v93 = v14 - (_DWORD)v6;
                if (v14 - (int)v6 < 4)
                {
                  if (v93 < 1)
                    goto LABEL_240;
                  v95 = *v6;
                  if (v93 == 1)
                  {
                    v94 = v95 << 24;
                  }
                  else
                  {
                    v96 = (v95 << 16) | (v6[1] << 8);
                    if (v93 != 2)
                      v96 |= v6[2];
                    v94 = v96 << 8;
                  }
                }
                else
                {
                  v94 = bswap32(*(_DWORD *)v6);
                }
                v7 = v94 << v8;
                if (a4)
                {
                  if (v7 < 0x80000)
                    goto LABEL_243;
                }
                else if (v7 < 0x80000)
                {
                  goto LABEL_245;
                }
                v97 = v8 + 2 * __clz(v7) + 1;
                v8 = v97 & 7;
                v6 += v97 >> 3;
                v98 = v14 - (_DWORD)v6;
                if (v14 - (int)v6 < 4)
                {
                  if (v98 < 1)
                  {
                    v100 = v8 | v98;
                    v7 = 0;
                    if (a4)
                    {
                      if (v100)
                        goto LABEL_243;
                    }
                    else if (v100)
                    {
                      goto LABEL_245;
                    }
                  }
                  else
                  {
                    v99 = *v6;
                    if (v98 == 1)
                    {
                      v7 = v99 << 24;
                    }
                    else
                    {
                      v101 = (v99 << 16) | (v6[1] << 8);
                      if (v98 != 2)
                        v101 |= v6[2];
                      v7 = v101 << 8;
                    }
                  }
                }
                else
                {
                  v7 = bswap32(*(_DWORD *)v6);
                }
                v90 = 0;
                v7 <<= v8;
              }
              while ((v91 & 1) != 0);
            }
          }
LABEL_238:
          result = 0;
          if (++v67 > v66)
            goto LABEL_247;
        }
      }
LABEL_249:
      result = 4294954577;
LABEL_246:
      result = FigSignalErrorAt(result, 0, 0, 0, 0, 0, 0);
      goto LABEL_247;
    }
  }
  if (v39 >= 1)
  {
    v41 = *v6;
    if (v39 == 1)
    {
      v40 = v41 << 24;
    }
    else
    {
      v42 = (v41 << 16) | (v6[1] << 8);
      if (v39 != 2)
        v42 |= v6[2];
      v40 = v42 << 8;
    }
    goto LABEL_75;
  }
LABEL_240:
  v7 = 0;
  result = 4294954582;
  if (!a4)
    goto LABEL_246;
LABEL_247:
  a1[2] = (uint64_t)v6;
  *((_DWORD *)a1 + 6) = v7;
  *((_BYTE *)a1 + 28) = v8;
  return result;
}

uint64_t FigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom(CFAllocatorRef alloc, int codecType, int32_t width, int32_t height, int a5, const UInt8 *a6, CFIndex a7, const __CFDictionary *a8, CMVideoFormatDescriptionRef *formatDescriptionOut)
{
  const __CFDictionary *v13;
  CFStringRef v16;
  CFDictionaryRef v17;
  uint64_t FallbackExtensionsFromVUI;
  uint64_t v20;
  uint64_t v21;
  int v23;
  CFTypeRef cf;
  unsigned __int8 pStr[5];
  void *values;
  void *keys[2];

  v13 = 0;
  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  values = 0;
  keys[0] = 0;
  cf = 0;
  if (!a5 || !a6)
  {
    v16 = 0;
    v17 = 0;
    goto LABEL_14;
  }
  v16 = 0;
  v17 = 0;
  if (!a7)
  {
LABEL_14:
    FallbackExtensionsFromVUI = CMVideoFormatDescriptionCreate(alloc, codecType, width, height, v13, formatDescriptionOut);
    goto LABEL_15;
  }
  pStr[0] = 4;
  pStr[1] = HIBYTE(a5);
  pStr[2] = BYTE2(a5);
  pStr[3] = BYTE1(a5);
  pStr[4] = a5;
  v16 = CFStringCreateWithPascalString(alloc, pStr, 0);
  if (v16 || (v21 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0), !(_DWORD)v21))
  {
    keys[0] = (void *)v16;
    values = CFDataCreate(alloc, a6, a7);
    if (!values)
    {
      v20 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
      goto LABEL_19;
    }
    v17 = CFDictionaryCreate(alloc, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
    if (!v17)
      goto LABEL_12;
    if (values)
    {
      CFRelease(values);
      values = 0;
    }
    keys[0] = CFSTR("SampleDescriptionExtensionAtoms");
    values = (void *)CFRetain(v17);
    if (a8)
    {
      FallbackExtensionsFromVUI = FigCFCreateExtendedDictionary(alloc, a8, keys, &values, 1, (CFDictionaryRef *)&cf);
      if ((_DWORD)FallbackExtensionsFromVUI)
      {
LABEL_15:
        v20 = FallbackExtensionsFromVUI;
        goto LABEL_20;
      }
      v13 = (const __CFDictionary *)cf;
      if (!cf)
      {
LABEL_12:
        FallbackExtensionsFromVUI = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
        goto LABEL_15;
      }
    }
    else
    {
      v13 = CFDictionaryCreate(alloc, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
      cf = v13;
      if (!v13)
        goto LABEL_12;
    }
    if (codecType > 1700886114)
    {
      if (codecType > 1902212708)
      {
        if (codecType == 1902212709)
          goto LABEL_42;
        v23 = 2053207651;
      }
      else
      {
        if (codecType == 1700886115)
          goto LABEL_42;
        v23 = 1902212707;
      }
    }
    else if (codecType > 1667331682)
    {
      if (codecType == 1667331683)
        goto LABEL_42;
      v23 = 1685220713;
    }
    else
    {
      if (codecType == 1635148593)
        goto LABEL_42;
      v23 = 1635148595;
    }
    if (codecType != v23 && !FigVideoCodecTypeIsHEVCFlavorOrDolbyVisionHEVCFlavor(codecType))
      goto LABEL_14;
LABEL_42:
    FallbackExtensionsFromVUI = FigBridge_MakeFallbackExtensionsFromVUI(alloc, codecType, 0, (const __CFDictionary **)&cf);
    if ((_DWORD)FallbackExtensionsFromVUI)
      goto LABEL_15;
    v13 = (const __CFDictionary *)cf;
    goto LABEL_14;
  }
  v20 = v21;
  v16 = 0;
LABEL_19:
  v17 = 0;
LABEL_20:
  if (values)
    CFRelease(values);
  if (v17)
    CFRelease(v17);
  if (cf)
    CFRelease(cf);
  if (v16)
    CFRelease(v16);
  return v20;
}

OSStatus CMVideoFormatDescriptionGetH264ParameterSetAtIndex(CMFormatDescriptionRef videoDesc, size_t parameterSetIndex, const uint8_t **parameterSetPointerOut, size_t *parameterSetSizeOut, size_t *parameterSetCountOut, int *NALUnitHeaderLengthOut)
{
  CFTypeID v12;
  const __CFDictionary *Extension;
  const __CFDictionary *v14;
  CFTypeID v15;
  const __CFArray *Value;
  const __CFArray *ValueAtIndex;
  CFTypeID v18;
  CFTypeID v19;

  if (!videoDesc)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v12 = CFGetTypeID(videoDesc);
  if (v12 != CMFormatDescriptionGetTypeID())
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(videoDesc, CFSTR("SampleDescriptionExtensionAtoms"));
  if (!Extension)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v14 = Extension;
  v15 = CFGetTypeID(Extension);
  if (v15 != CFDictionaryGetTypeID())
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  Value = (const __CFArray *)CFDictionaryGetValue(v14, CFSTR("avcC"));
  if (!Value)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  ValueAtIndex = Value;
  v18 = CFGetTypeID(Value);
  if (v18 == CFArrayGetTypeID())
  {
    if (CFArrayGetCount(ValueAtIndex) <= 0)
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
    if (!ValueAtIndex)
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
  v19 = CFGetTypeID(ValueAtIndex);
  if (v19 == CFDataGetTypeID())
    return FigH264Bridge_GetH264ParameterSetAtIndex(ValueAtIndex, parameterSetIndex, (unint64_t)parameterSetPointerOut, parameterSetSizeOut, (unint64_t)parameterSetCountOut, NALUnitHeaderLengthOut);
  else
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

OSStatus CMVideoFormatDescriptionCreateFromH264ParameterSets(CFAllocatorRef allocator, size_t parameterSetCount, const uint8_t *const *parameterSetPointers, const size_t *parameterSetSizes, int NALUnitHeaderLength, CMFormatDescriptionRef *formatDescriptionOut)
{
  OSStatus v8;
  int32_t v9;
  int32_t v10;
  BOOL v11;
  const UInt8 *BytePtr;
  CFIndex Length;
  OSStatus v14;
  CFDataRef theData;
  uint64_t v17;
  uint64_t v18;

  v17 = 0;
  v18 = 0;
  theData = 0;
  v8 = FigH264Bridge_CreateAVCCFromH264ParameterSets((int)allocator, parameterSetCount, (uint64_t)parameterSetPointers, (uint64_t)parameterSetSizes, NALUnitHeaderLength, &v18, &v17, &theData);
  if (!v8)
  {
    v10 = v17;
    v9 = v18;
    if (v18)
      v11 = v17 == 0;
    else
      v11 = 1;
    if (v11)
    {
      v8 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      BytePtr = CFDataGetBytePtr(theData);
      Length = CFDataGetLength(theData);
      v8 = FigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom(allocator, 1635148593, v9, v10, 1635148611, BytePtr, Length, 0, formatDescriptionOut);
    }
  }
  v14 = v8;
  if (theData)
    CFRelease(theData);
  return v14;
}

OSStatus CMVideoFormatDescriptionCreateFromHEVCParameterSets(CFAllocatorRef allocator, size_t parameterSetCount, const uint8_t *const *parameterSetPointers, const size_t *parameterSetSizes, int NALUnitHeaderLength, CFDictionaryRef extensions, CMFormatDescriptionRef *formatDescriptionOut)
{
  OSStatus v10;
  BOOL v11;
  const __CFDictionary *Value;
  const __CFAllocator *v13;
  CFIndex Count;
  __CFDictionary *MutableCopy;
  __CFDictionary *v16;
  int v17;
  int32_t v18;
  int32_t v19;
  const UInt8 *BytePtr;
  CFIndex Length;
  const __CFDictionary *v22;
  OSStatus v23;
  uint64_t v25;
  CFDataRef theData;
  uint64_t v27;
  uint64_t v28;

  v27 = 0;
  v28 = 0;
  theData = 0;
  v10 = FigHEVCBridge_CreateHVCCFromHEVCParameterSets((int)allocator, parameterSetCount, (uint64_t)parameterSetPointers, (uint64_t)parameterSetSizes, NALUnitHeaderLength, &v28, &v27, &theData);
  if (v10)
    goto LABEL_23;
  if (v28)
    v11 = v27 == 0;
  else
    v11 = 1;
  if (v11)
  {
    v25 = 4294954586;
LABEL_22:
    v10 = FigSignalErrorAt(v25, 0, 0, 0, 0, 0, 0);
LABEL_23:
    v23 = v10;
    goto LABEL_17;
  }
  if (extensions)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(extensions, CFSTR("SampleDescriptionExtensionAtoms"));
    if (Value)
    {
      if (CFDictionaryContainsKey(Value, CFSTR("dvcC")))
      {
        v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        Count = CFDictionaryGetCount(extensions);
        MutableCopy = CFDictionaryCreateMutableCopy(v13, Count, extensions);
        if (MutableCopy)
        {
          v16 = MutableCopy;
          CFDictionaryRemoveValue(MutableCopy, (const void *)*MEMORY[0x1E0CA8D68]);
          CFDictionaryRemoveValue(v16, (const void *)*MEMORY[0x1E0CA8E98]);
          CFDictionaryRemoveValue(v16, (const void *)*MEMORY[0x1E0CA8EE8]);
          v17 = 1685481521;
          goto LABEL_12;
        }
        v25 = 4294954585;
        goto LABEL_22;
      }
    }
  }
  v16 = 0;
  v17 = 1752589105;
LABEL_12:
  v19 = v27;
  v18 = v28;
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  if (v16)
    v22 = v16;
  else
    v22 = extensions;
  v23 = FigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom(allocator, v17, v18, v19, 1752589123, BytePtr, Length, v22, formatDescriptionOut);
  if (v16)
    CFRelease(v16);
LABEL_17:
  if (theData)
    CFRelease(theData);
  return v23;
}

OSStatus CMVideoFormatDescriptionGetHEVCParameterSetAtIndex(CMFormatDescriptionRef videoDesc, size_t parameterSetIndex, const uint8_t **parameterSetPointerOut, size_t *parameterSetSizeOut, size_t *parameterSetCountOut, int *NALUnitHeaderLengthOut)
{
  CFTypeID v12;
  const __CFDictionary *Extension;
  const __CFDictionary *v14;
  CFTypeID v15;
  const __CFArray *Value;
  const __CFArray *ValueAtIndex;
  CFTypeID v18;
  CFTypeID v19;

  if (!videoDesc)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v12 = CFGetTypeID(videoDesc);
  if (v12 != CMFormatDescriptionGetTypeID())
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension(videoDesc, CFSTR("SampleDescriptionExtensionAtoms"));
  if (!Extension)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v14 = Extension;
  v15 = CFGetTypeID(Extension);
  if (v15 != CFDictionaryGetTypeID())
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  Value = (const __CFArray *)CFDictionaryGetValue(v14, CFSTR("hvcC"));
  if (!Value)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  ValueAtIndex = Value;
  v18 = CFGetTypeID(Value);
  if (v18 == CFArrayGetTypeID())
  {
    if (CFArrayGetCount(ValueAtIndex) <= 0)
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
    if (!ValueAtIndex)
      return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
  v19 = CFGetTypeID(ValueAtIndex);
  if (v19 == CFDataGetTypeID())
    return FigHEVCBridge_GetHEVCParameterSetAtIndex(ValueAtIndex, 0, parameterSetIndex, (unint64_t)parameterSetPointerOut, (unint64_t)parameterSetSizeOut, (unint64_t)parameterSetCountOut, NALUnitHeaderLengthOut);
  else
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

uint64_t FigVideoFormatDescriptionVisitAllParameterSets(const void *a1, uint64_t a2)
{
  CFTypeID v4;
  const __CFDictionary *Extension;
  const __CFDictionary *v6;
  CFTypeID v7;
  const void *Value;
  const void *ValueAtIndex;
  CFTypeID v10;
  CFTypeID v11;
  uint64_t result;
  const void *v13;
  const void *v14;
  CFTypeID v15;
  CFTypeID v16;

  if (a1)
  {
    v4 = CFGetTypeID(a1);
    if (v4 == CMFormatDescriptionGetTypeID())
    {
      Extension = (const __CFDictionary *)CMFormatDescriptionGetExtension((CMFormatDescriptionRef)a1, CFSTR("SampleDescriptionExtensionAtoms"));
      if (Extension)
      {
        v6 = Extension;
        v7 = CFGetTypeID(Extension);
        if (v7 == CFDictionaryGetTypeID())
        {
          if (CFDictionaryContainsKey(v6, CFSTR("avcC")))
          {
            Value = CFDictionaryGetValue(v6, CFSTR("avcC"));
            if (Value)
            {
              ValueAtIndex = Value;
              v10 = CFGetTypeID(Value);
              if (v10 != CFArrayGetTypeID()
                || CFArrayGetCount((CFArrayRef)ValueAtIndex) > 0
                && (ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0)) != 0)
              {
                v11 = CFGetTypeID(ValueAtIndex);
                if (v11 == CFDataGetTypeID())
                  return FigH264Bridge_VisitAllH264ParameterSets(ValueAtIndex, 0, 0, (unint64_t)dispatchVideoFormatParameterSetVisitor, a2);
              }
            }
          }
          else
          {
            result = CFDictionaryContainsKey(v6, CFSTR("hvcC"));
            if (!(_DWORD)result)
              return result;
            v13 = CFDictionaryGetValue(v6, CFSTR("hvcC"));
            if (v13)
            {
              v14 = v13;
              v15 = CFGetTypeID(v13);
              if (v15 != CFArrayGetTypeID()
                || CFArrayGetCount((CFArrayRef)v14) > 0 && (v14 = CFArrayGetValueAtIndex((CFArrayRef)v14, 0)) != 0)
              {
                v16 = CFGetTypeID(v14);
                if (v16 == CFDataGetTypeID())
                  return FigHEVCBridge_VisitAllHEVCParameterSets(v14, 0, 0, 0, (uint64_t)dispatchVideoFormatParameterSetVisitor, a2);
              }
            }
          }
        }
      }
    }
  }
  return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
}

uint64_t dispatchVideoFormatParameterSetVisitor(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

uint64_t FigVideoFormatDescriptionCreateUpdatedHVCCWithAdditionalHEVCParameterSets(int a1, const void *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, _QWORD *a7, _QWORD *a8, __CFData **a9)
{
  return FigHEVCBridge_CreateUpdatedHVCCWithAdditionalHEVCParameterSets(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t FigVideoFormatDescriptionCreateUpdatedFromHEVCParameterSets(const __CFAllocator *a1, CMFormatDescriptionRef desc, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, CMVideoFormatDescriptionRef *a7)
{
  const __CFDictionary *Extensions;
  const __CFDictionary *Value;
  const void *v15;
  uint64_t v16;
  int32_t v17;
  int32_t v18;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v21;
  CFDataRef theData;
  uint64_t v24;
  uint64_t v25;

  v24 = 0;
  v25 = 0;
  theData = 0;
  if (!desc)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  Extensions = CMFormatDescriptionGetExtensions(desc);
  if (!Extensions)
    goto LABEL_14;
  Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("SampleDescriptionExtensionAtoms"));
  if (!Value)
    goto LABEL_14;
  v15 = CFDictionaryGetValue(Value, CFSTR("hvcC"));
  if (!v15)
    goto LABEL_14;
  v16 = FigHEVCBridge_CreateUpdatedHVCCWithAdditionalHEVCParameterSets((int)a1, v15, a3, a4, a5, a6, &v25, &v24, &theData);
  if (!(_DWORD)v16)
  {
    v17 = v25;
    if (v25)
    {
      v18 = v24;
      if (v24)
      {
        BytePtr = CFDataGetBytePtr(theData);
        Length = CFDataGetLength(theData);
        v16 = FigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom(a1, 1752589105, v17, v18, 1752589123, BytePtr, Length, 0, a7);
        goto LABEL_9;
      }
    }
LABEL_14:
    v16 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
LABEL_9:
  v21 = v16;
  if (theData)
    CFRelease(theData);
  return v21;
}

uint64_t FigVideoFormatDescriptionCreateFromSPSAndPPS(const __CFAllocator *a1, const UInt8 *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, CMVideoFormatDescriptionRef *a7)
{
  uint64_t SPSWidthAndHeight;
  int32_t v12;
  int32_t v13;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  CFDataRef theData;

  v19 = 0;
  theData = 0;
  v18 = 0;
  SPSWidthAndHeight = FigH264Bridge_CreateAVCCFromSPSAndPPS((int)a1, (uint64_t)a2, a3, a4, a5, a6, &theData);
  if (!(_DWORD)SPSWidthAndHeight)
  {
    SPSWidthAndHeight = FigH264Bridge_GetSPSWidthAndHeight(a2, a3, &v19, &v18);
    if (!(_DWORD)SPSWidthAndHeight)
    {
      v13 = v18;
      v12 = v19;
      BytePtr = CFDataGetBytePtr(theData);
      Length = CFDataGetLength(theData);
      SPSWidthAndHeight = FigVideoFormatDescriptionCreateWithSampleDescriptionExtensionAtom(a1, 1635148593, v12, v13, 1635148611, BytePtr, Length, 0, a7);
    }
  }
  v16 = SPSWidthAndHeight;
  if (theData)
    CFRelease(theData);
  return v16;
}

uint64_t FigHALAudioDeviceBrokerGetClassID()
{
  if (FigHALAudioDeviceBrokerGetClassID_sRegisterFigHALAudioDeviceBrokerClassOnce != -1)
    dispatch_once(&FigHALAudioDeviceBrokerGetClassID_sRegisterFigHALAudioDeviceBrokerClassOnce, &__block_literal_global_31);
  return FigHALAudioDeviceBrokerGetClassID_sFigHALAudioDeviceBrokerClassID;
}

uint64_t FigHALAudioDeviceBrokerGetTypeID()
{
  if (FigHALAudioDeviceBrokerGetClassID_sRegisterFigHALAudioDeviceBrokerClassOnce != -1)
    dispatch_once(&FigHALAudioDeviceBrokerGetClassID_sRegisterFigHALAudioDeviceBrokerClassOnce, &__block_literal_global_31);
  return CMBaseClassGetCFTypeID((_QWORD *)FigHALAudioDeviceBrokerGetClassID_sFigHALAudioDeviceBrokerClassID);
}

uint64_t FigHALAudioDeviceBrokerRegister(const void *a1, const void *a2)
{
  if (!a1 || !a2)
    return FigSignalErrorAt(4294949445, 0, 0, 0, 0, 0, 0);
  if (sFigHALAudioDeviceBrokerRegistryInitOnce != -1)
    dispatch_once_f(&sFigHALAudioDeviceBrokerRegistryInitOnce, 0, (dispatch_function_t)figHALAudioDeviceRegistryOneTimeInitialization);
  FigSimpleMutexLock((pthread_mutex_t *)sFigHALAudioDeviceBrokerRegistry_0);
  CFDictionarySetValue((CFMutableDictionaryRef)sFigHALAudioDeviceBrokerRegistry_1, a1, a2);
  FigSimpleMutexUnlock((pthread_mutex_t *)sFigHALAudioDeviceBrokerRegistry_0);
  return 0;
}

CFMutableDictionaryRef figHALAudioDeviceRegistryOneTimeInitialization()
{
  CFMutableDictionaryRef result;

  sFigHALAudioDeviceBrokerRegistry_0 = (uint64_t)FigSimpleMutexCreate();
  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  sFigHALAudioDeviceBrokerRegistry_1 = (uint64_t)result;
  return result;
}

uint64_t FigHALAudioDeviceBrokerUnregister(const void *a1)
{
  size_t Count;
  int64_t v3;
  const void **v4;
  const void **v5;
  const void **v6;
  const void **v7;

  if (!a1)
    return FigSignalErrorAt(4294949445, 0, 0, 0, 0, 0, 0);
  if (sFigHALAudioDeviceBrokerRegistryInitOnce != -1)
    dispatch_once_f(&sFigHALAudioDeviceBrokerRegistryInitOnce, 0, (dispatch_function_t)figHALAudioDeviceRegistryOneTimeInitialization);
  FigSimpleMutexLock((pthread_mutex_t *)sFigHALAudioDeviceBrokerRegistry_0);
  Count = CFDictionaryGetCount((CFDictionaryRef)sFigHALAudioDeviceBrokerRegistry_1);
  if (Count)
  {
    v3 = Count;
    v4 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    v5 = (const void **)malloc_type_calloc(v3, 8uLL, 0xC0040B8AA526DuLL);
    CFDictionaryGetKeysAndValues((CFDictionaryRef)sFigHALAudioDeviceBrokerRegistry_1, v4, v5);
    if (v3 >= 1)
    {
      v6 = v5;
      v7 = v4;
      while (*v6 != a1)
      {
        ++v7;
        ++v6;
        if (!--v3)
          goto LABEL_11;
      }
      CFDictionaryRemoveValue((CFMutableDictionaryRef)sFigHALAudioDeviceBrokerRegistry_1, *v7);
    }
LABEL_11:
    free(v4);
    free(v5);
  }
  FigSimpleMutexUnlock((pthread_mutex_t *)sFigHALAudioDeviceBrokerRegistry_0);
  return 0;
}

uint64_t FigHALAudioDeviceBrokerCopy(const void *a1, _QWORD *a2)
{
  const void *Value;

  if (!a1 || !a2)
    return FigSignalErrorAt(4294949445, 0, 0, 0, 0, 0, 0);
  if (sFigHALAudioDeviceBrokerRegistryInitOnce != -1)
    dispatch_once_f(&sFigHALAudioDeviceBrokerRegistryInitOnce, 0, (dispatch_function_t)figHALAudioDeviceRegistryOneTimeInitialization);
  FigSimpleMutexLock((pthread_mutex_t *)sFigHALAudioDeviceBrokerRegistry_0);
  Value = CFDictionaryGetValue((CFDictionaryRef)sFigHALAudioDeviceBrokerRegistry_1, a1);
  if (Value)
    Value = CFRetain(Value);
  *a2 = Value;
  FigSimpleMutexUnlock((pthread_mutex_t *)sFigHALAudioDeviceBrokerRegistry_0);
  return 0;
}

uint64_t FigEndpointStreamXPCRemoteGetObjectID(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)DerivedStorage)
  {
    v5 = 4294954511;
  }
  else
  {
    if (!*(_BYTE *)(DerivedStorage + 1))
    {
      *a2 = *(_QWORD *)(DerivedStorage + 8);
      return 0;
    }
    v5 = 4294950574;
  }
  return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointStreamXPCRemotePing()
{
  uint64_t v0;
  uint64_t v1;
  void *v2;
  uint64_t v3;
  void *v5;

  v5 = 0;
  v0 = figEndpointStreamRemoteXPC_EnsureClientEstablished();
  if ((_DWORD)v0)
  {
    v3 = v0;
    v2 = 0;
  }
  else
  {
    v1 = FigXPCCreateBasicMessage(0x2E706E67u, 0, &v5);
    v2 = v5;
    if ((_DWORD)v1)
    {
      v3 = v1;
    }
    else
    {
      v3 = FigXPCRemoteClientSendSyncMessage(gFigEndpointStreamRemoteClient, (uint64_t)v5);
      v2 = v5;
    }
  }
  FigXPCRelease(v2);
  return v3;
}

uint64_t figEndpointStreamRemoteXPC_EnsureClientEstablished()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __figEndpointStreamRemoteXPC_EnsureClientEstablished_block_invoke;
  block[3] = &unk_1E28DE3C8;
  block[4] = &v3;
  if (figEndpointStreamRemoteXPC_EnsureClientEstablished_sFigEndpointStreamRemoteClientSetupOnce != -1)
    dispatch_once(&figEndpointStreamRemoteXPC_EnsureClientEstablished_sFigEndpointStreamRemoteClientSetupOnce, block);
  v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t FigEndpointStreamXPCRemoteCreateWithObjectID(const void *a1, _QWORD *a2)
{
  uint64_t result;

  if (!a1 || !a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  result = figEndpointStreamRemoteXPC_EnsureClientEstablished();
  if (!(_DWORD)result)
    return remoteXPCEndpointStream_CreateInternal(a1, a2);
  return result;
}

uint64_t remoteXPCEndpointStream_CreateInternal(const void *a1, _QWORD *a2)
{
  const __CFAllocator *v4;
  _QWORD *ClassID;
  uint64_t result;
  _QWORD *DerivedStorage;
  CFMutableDictionaryRef v8;
  dispatch_queue_t v9;
  CFDictionaryValueCallBacks v10;
  uint64_t v11;

  v11 = 0;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  ClassID = (_QWORD *)FigEndpointStreamAirPlayGetClassID();
  result = CMDerivedObjectCreate((uint64_t)v4, (uint64_t)&kFigEndpointStreamRemoteXPC_EndpointVTable, ClassID, &v11);
  if (!(_DWORD)result)
  {
    DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(v11);
    DerivedStorage[1] = a1;
    DerivedStorage[4] = 1;
    v10.version = 0;
    v10.retain = (CFDictionaryRetainCallBack)remoteXPCEndpointStream_cloneCompletionCallback;
    v10.release = (CFDictionaryReleaseCallBack)remoteXPCEndpointStream_freeCompletionCallback;
    v10.copyDescription = 0;
    v10.equal = 0;
    v8 = CFDictionaryCreateMutable(v4, 0, 0, &v10);
    DerivedStorage[3] = v8;
    if (v8
      && (v9 = dispatch_queue_create("com.apple.coremedia.endpointstream.completioncallbacks", 0),
          (DerivedStorage[2] = v9) != 0))
    {
      FigXPCRemoteClientAssociateObject(gFigEndpointStreamRemoteClient, v11, a1);
      result = 0;
    }
    else
    {
      result = FigSignalErrorAt(4294950575, 0, 0, 0, 0, 0, 0);
    }
  }
  *a2 = v11;
  return result;
}

uint64_t FigEndpointStreamXPCRemoteRetainCopiedEndpointStream(const void *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  v6 = 0;
  if (!a1 || !a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  result = figEndpointStreamRemoteXPC_EnsureClientEstablished();
  if (!(_DWORD)result)
  {
    result = FigXPCRemoteClientRetainCopiedObject(gFigEndpointStreamRemoteClient, (uint64_t)a1, &v6);
    if (!(_DWORD)result)
    {
      v5 = v6;
      if (v6)
      {
        result = 0;
      }
      else
      {
        result = remoteXPCEndpointStream_CreateInternal(a1, &v6);
        v5 = v6;
      }
      *a2 = v5;
    }
  }
  return result;
}

void remoteXPCEndpointStreamClient_DeadConnectionCallback(uint64_t a1)
{
  *(_BYTE *)(CMBaseObjectGetDerivedStorage(a1) + 1) = 1;
  FigEndpointStreamRemoteXPC_runAllCallbacks(a1, -16722);
}

uint64_t remoteXPCEndpointStreamClient_HandleClientMessage(uint64_t a1, void *a2)
{
  uint64_t OpCode;
  uint64_t DerivedStorage;
  uint64_t uint64;
  int64_t int64;
  NSObject *v8;
  int v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  void (*v13)(uint64_t, int64_t, __int128 *, __int128 *, uint64_t, double);
  uint64_t v14;
  const void *v15;
  int v17;
  __int128 v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  _QWORD block[7];
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;

  v17 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v17);
  if ((_DWORD)OpCode)
    return OpCode;
  if (v17 != 1667329122)
    return 4294966630;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v27 = 0;
  v28 = &v27;
  v29 = 0x3800000000;
  v30 = 0u;
  v31 = 0u;
  uint64 = xpc_dictionary_get_uint64(a2, "CompletionID");
  int64 = xpc_dictionary_get_int64(a2, "CompletionStatus");
  v8 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __remoteXPCEndpointStreamClient_handleCompletionCallback_block_invoke;
  block[3] = &unk_1E28DE418;
  block[5] = DerivedStorage;
  block[6] = uint64;
  block[4] = &v27;
  dispatch_sync(v8, block);
  if (v28[3] == a1)
  {
    v9 = *((_DWORD *)v28 + 12);
    if (v9 == 2)
    {
      v24 = *(_OWORD *)&kCMTimeInvalid.value;
      v25 = 0;
      v22 = *(_OWORD *)&kCMTimeInvalid.value;
      v23 = 0;
      v11 = xpc_dictionary_get_double(a2, "Rate");
      FigXPCMessageGetCMTime(a2, "SampleTime", (uint64_t)&v24);
      FigXPCMessageGetCMTime(a2, "HostTime", (uint64_t)&v22);
      v12 = v28[4];
      v13 = (void (*)(uint64_t, int64_t, __int128 *, __int128 *, uint64_t, double))v28[5];
      v14 = v28[3];
      v20 = v24;
      v21 = v25;
      v18 = v22;
      v19 = v23;
      v13(v14, int64, &v20, &v18, v12, v11);
    }
    else if (v9 == 1)
    {
      ((void (*)(uint64_t, int64_t, uint64_t))v28[5])(a1, int64, v28[4]);
    }
    v10 = 0;
  }
  else
  {
    v10 = FigSignalErrorAt(4294950531, 0, 0, 0, 0, 0, 0);
  }
  v15 = (const void *)v28[3];
  if (v15)
    CFRelease(v15);
  _Block_object_dispose(&v27, 8);
  return v10;
}

void FigEndpointStreamRemoteXPC_runAllCallbacks(uint64_t a1, int a2)
{
  uint64_t DerivedStorage;
  NSObject *v4;
  const __CFDictionary *v5;
  const void *v6;
  _QWORD block[6];
  int context;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  context = a2;
  v4 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigEndpointStreamRemoteXPC_runAllCallbacks_block_invoke;
  block[3] = &unk_1E28DE3F0;
  block[4] = &v9;
  block[5] = DerivedStorage;
  dispatch_sync(v4, block);
  v5 = (const __CFDictionary *)v10[3];
  if (v5)
  {
    CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)FigEndpointStreamRemoteXPC_runOneCallback, &context);
    v6 = (const void *)v10[3];
    if (v6)
      CFRelease(v6);
  }
  _Block_object_dispose(&v9, 8);
}

uint64_t FigEndpointStreamRemoteXPC_runOneCallback(uint64_t a1, uint64_t *a2, unsigned int *a3)
{
  int v3;
  uint64_t result;
  uint64_t v5;
  uint64_t (*v6)(uint64_t, uint64_t, __int128 *, __int128 *, uint64_t, double);
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;

  v3 = *((_DWORD *)a2 + 6);
  if (v3 == 2)
  {
    v5 = a2[1];
    v6 = (uint64_t (*)(uint64_t, uint64_t, __int128 *, __int128 *, uint64_t, double))a2[2];
    v7 = *a3;
    v8 = *a2;
    v11 = *(_OWORD *)&kCMTimeInvalid.value;
    v12 = 0;
    v9 = *(_OWORD *)&kCMTimeInvalid.value;
    v10 = 0;
    return v6(v8, v7, &v11, &v9, v5, 0.0);
  }
  else if (v3 == 1)
  {
    return ((uint64_t (*)(_QWORD, _QWORD, uint64_t))a2[2])(*a2, *a3, a2[1]);
  }
  return result;
}

void __remoteXPCEndpointStreamClient_handleCompletionCallback_block_invoke(uint64_t a1)
{
  const __CFDictionary *v2;
  __int128 *Value;
  uint64_t v4;
  __int128 v5;
  const void *v6;

  v2 = *(const __CFDictionary **)(*(_QWORD *)(a1 + 40) + 24);
  if (v2)
  {
    Value = (__int128 *)CFDictionaryGetValue(v2, *(const void **)(a1 + 48));
    if (Value)
    {
      v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v5 = *Value;
      *(_OWORD *)(v4 + 40) = Value[1];
      *(_OWORD *)(v4 + 24) = v5;
      v6 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v6)
        CFRetain(v6);
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 40) + 24), *(const void **)(a1 + 48));
  }
}

CFTypeRef *remoteXPCEndpointStream_cloneCompletionCallback(const __CFAllocator *a1, _OWORD *a2)
{
  CFTypeRef *v3;
  __int128 v4;

  v3 = (CFTypeRef *)CFAllocatorAllocate(a1, 32, 0);
  v4 = a2[1];
  *(_OWORD *)v3 = *a2;
  *((_OWORD *)v3 + 1) = v4;
  if (*v3)
    CFRetain(*v3);
  return v3;
}

void remoteXPCEndpointStream_freeCompletionCallback(CFAllocatorRef allocator, CFTypeRef *ptr)
{
  if (*ptr)
    CFRelease(*ptr);
  CFAllocatorDeallocate(allocator, ptr);
}

uint64_t FigEndpointStreamRemoteXPC_Invalidate(uint64_t a1)
{
  _BYTE *DerivedStorage;

  DerivedStorage = (_BYTE *)CMBaseObjectGetDerivedStorage(a1);
  if (!*DerivedStorage)
  {
    *DerivedStorage = 1;
    FigEndpointStreamRemoteXPC_runAllCallbacks(a1, -12785);
    FigEndpointStreamRemoteXPC_teardown(a1);
  }
  return 0;
}

void FigEndpointStreamRemoteXPC_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *v3;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigEndpointStreamRemoteXPC_teardown(a1);
  v3 = *(NSObject **)(DerivedStorage + 16);
  if (v3)
    dispatch_release(v3);
}

uint64_t FigEndpointStreamRemoteXPC_CopyProperty(uint64_t a1, const void *a2, const __CFAllocator *a3, CFTypeRef *a4)
{
  uint64_t ObjectID;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  __CFArray *v13;
  xpc_object_t xdict;
  xpc_object_t v15;

  v12 = 0;
  ObjectID = FigEndpointStreamXPCRemoteGetObjectID(a1, &v12);
  if ((_DWORD)ObjectID)
    return ObjectID;
  if (CFEqual(a2, CFSTR("SupportedAudioFormatDescriptions")))
  {
    xdict = 0;
    v15 = 0;
    v13 = 0;
    v8 = FigXPCCreateBasicMessage(0x73756164u, v12, &v15);
    if (!(_DWORD)v8)
    {
      v8 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigEndpointStreamRemoteClient, (uint64_t)v15, &xdict);
      if (!(_DWORD)v8)
      {
        v9 = FigXPCMessageCopyFigEndpointStreamAudioFormatDescriptionArray(a3, xdict, "FormatDescriptionArray", &v13);
        goto LABEL_10;
      }
    }
    goto LABEL_15;
  }
  if (CFEqual(a2, CFSTR("RichestAudioFormatDescription")))
  {
    xdict = 0;
    v15 = 0;
    v13 = 0;
    v8 = FigXPCCreateBasicMessage(0x72616664u, v12, &v15);
    if (!(_DWORD)v8)
    {
      v8 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigEndpointStreamRemoteClient, (uint64_t)v15, &xdict);
      if (!(_DWORD)v8)
      {
        v9 = (uint64_t)FigXPCMessageCopyFigEndpointStreamAudioFormatDescription((uint64_t)a3, xdict, "RichestFormatDescription", (uint64_t *)&v13);
LABEL_10:
        v10 = v9;
        if (!(_DWORD)v9)
          *a4 = v13;
        goto LABEL_12;
      }
    }
LABEL_15:
    v10 = v8;
LABEL_12:
    FigXPCRelease(v15);
    FigXPCRelease(xdict);
    return v10;
  }
  return FigXPCSendStdCopyPropertyMessage(gFigEndpointStreamRemoteClient, v12, a2, a4);
}

uint64_t FigEndpointStreamRemoteXPC_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t result;
  uint64_t v6;

  v6 = 0;
  result = FigEndpointStreamXPCRemoteGetObjectID(a1, &v6);
  if (!(_DWORD)result)
    return FigXPCSendStdSetPropertyMessage(gFigEndpointStreamRemoteClient, v6, a2, a3);
  return result;
}

void FigEndpointStreamRemoteXPC_teardown(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v2;
  const void *v3;
  const void *v4;
  xpc_object_t v5;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v2 = DerivedStorage;
  v5 = 0;
  if (!*(_BYTE *)DerivedStorage)
  {
    v3 = *(const void **)(DerivedStorage + 8);
    FigXPCRemoteClientDisassociateObject(gFigEndpointStreamRemoteClient, v3);
    if (!*(_BYTE *)(v2 + 1) && !FigXPCCreateBasicMessage(0x646F6F6Du, (uint64_t)v3, &v5))
      FigXPCRemoteClientSendSyncMessage(gFigEndpointStreamRemoteClient, (uint64_t)v5);
  }
  v4 = *(const void **)(v2 + 24);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(v2 + 24) = 0;
  }
  FigXPCRelease(v5);
}

uint64_t FigEndpointStreamRemoteXPC_SuspendWithCompletionCallback(uint64_t a1, const void *a2, unint64_t a3, uint64_t a4)
{
  uint64_t ObjectID;
  uint64_t v9;
  void *v10;
  uint64_t v12;
  int v13[2];

  v12 = 0;
  *(_QWORD *)v13 = 0;
  ObjectID = FigEndpointStreamXPCRemoteGetObjectID(a1, &v12);
  if ((_DWORD)ObjectID)
  {
    v9 = ObjectID;
    v10 = 0;
  }
  else
  {
    v9 = FigXPCCreateBasicMessage(0x73737064u, v12, v13);
    v10 = *(void **)v13;
    if (!(_DWORD)v9)
    {
      FigXPCMessageSetCFDictionary(*(void **)v13, "Options", a2);
      v9 = FigEndpointStreamRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v13, a3, 0, a4);
      v10 = *(void **)v13;
    }
  }
  FigXPCRelease(v10);
  return v9;
}

uint64_t FigEndpointStreamRemoteXPC_ResumeWithCompletionCallback(uint64_t a1, const void *a2, unint64_t a3, uint64_t a4)
{
  uint64_t ObjectID;
  uint64_t v9;
  void *v10;
  uint64_t v12;
  int v13[2];

  v12 = 0;
  *(_QWORD *)v13 = 0;
  ObjectID = FigEndpointStreamXPCRemoteGetObjectID(a1, &v12);
  if ((_DWORD)ObjectID)
  {
    v9 = ObjectID;
    v10 = 0;
  }
  else
  {
    v9 = FigXPCCreateBasicMessage(0x7273756Du, v12, v13);
    v10 = *(void **)v13;
    if (!(_DWORD)v9)
    {
      FigXPCMessageSetCFDictionary(*(void **)v13, "Options", a2);
      v9 = FigEndpointStreamRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, *(void **)v13, a3, 0, a4);
      v10 = *(void **)v13;
    }
  }
  FigXPCRelease(v10);
  return v9;
}

uint64_t FigEndpointStreamRemoteXPC_Flush(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t ObjectID;
  uint64_t v6;
  xpc_object_t v7;
  uint64_t v9;
  xpc_object_t xdict;

  v9 = 0;
  xdict = 0;
  ObjectID = FigEndpointStreamXPCRemoteGetObjectID(a1, &v9);
  if ((_DWORD)ObjectID)
  {
    v6 = ObjectID;
    v7 = 0;
  }
  else
  {
    v6 = FigXPCCreateBasicMessage(0x666C7573u, v9, &xdict);
    v7 = xdict;
    if (!(_DWORD)v6)
    {
      FigXPCMessageSetCFDictionary(xdict, "Options", a3);
      xpc_dictionary_set_uint64(xdict, "FlushFlags", a2);
      v6 = FigXPCRemoteClientSendSyncMessage(gFigEndpointStreamRemoteClient, (uint64_t)xdict);
      v7 = xdict;
    }
  }
  FigXPCRelease(v7);
  return v6;
}

uint64_t FigEndpointStreamRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(uint64_t a1, void *a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  BOOL v17;
  NSObject *v18;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  _QWORD v24[7];
  _QWORD block[10];
  int v26;
  int v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v11 = DerivedStorage;
  v32 = 0;
  v33 = &v32;
  v34 = 0x2000000000;
  v35 = 0;
  v28 = 0;
  v29 = &v28;
  v30 = 0x2000000000;
  v31 = 0;
  v12 = MEMORY[0x1E0C809B0];
  if (a3 | a4)
  {
    v13 = *(NSObject **)(DerivedStorage + 16);
    if (a3)
      v14 = a3;
    else
      v14 = a4;
    block[0] = MEMORY[0x1E0C809B0];
    if (a3)
      v15 = 1;
    else
      v15 = 2;
    block[1] = 0x40000000;
    block[2] = __FigEndpointStreamRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback_block_invoke;
    block[3] = &unk_1E28DE518;
    block[4] = &v32;
    block[5] = a1;
    block[6] = v11;
    block[7] = a1;
    block[8] = a5;
    block[9] = v14;
    v26 = v15;
    v27 = 0;
    dispatch_sync(v13, block);
    xpc_dictionary_set_uint64(a2, "CompletionID", v33[3]);
  }
  v16 = FigXPCRemoteClientSendSyncMessage(gFigEndpointStreamRemoteClient, (uint64_t)a2);
  if ((_DWORD)v16)
    v17 = (a3 | a4) == 0;
  else
    v17 = 1;
  if (!v17)
  {
    v18 = *(NSObject **)(v11 + 16);
    v24[0] = v12;
    v24[1] = 0x40000000;
    v24[2] = __FigEndpointStreamRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback_block_invoke_2;
    v24[3] = &unk_1E28DE540;
    v24[4] = &v32;
    v24[5] = &v28;
    v24[6] = v11;
    dispatch_sync(v18, v24);
  }
  if (*((_BYTE *)v29 + 24))
  {
    if (a3)
    {
      ((void (*)(uint64_t, uint64_t, uint64_t))a3)(a1, v16, a5);
    }
    else
    {
      v22 = *(_OWORD *)&kCMTimeInvalid.value;
      v23 = 0;
      v20 = *(_OWORD *)&kCMTimeInvalid.value;
      v21 = 0;
      ((void (*)(uint64_t, uint64_t, __int128 *, __int128 *, uint64_t, double))a4)(a1, v16, &v22, &v20, a5, 0.0);
    }
  }
  FigXPCRemoteClientKillServerOnTimeout(gFigEndpointStreamRemoteClient, v16, "FigEndpointStreamRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback", 0);
  _Block_object_dispose(&v28, 8);
  _Block_object_dispose(&v32, 8);
  return v16;
}

uint64_t FigEndpointStreamRemoteXPC_SetRateAndAnchorTimeWithCompletionCallback(uint64_t a1, __int128 *a2, __int128 *a3, unint64_t a4, uint64_t a5, double a6)
{
  uint64_t ObjectID;
  uint64_t v13;
  xpc_object_t v14;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  xpc_object_t xdict;

  v18 = 0;
  xdict = 0;
  ObjectID = FigEndpointStreamXPCRemoteGetObjectID(a1, &v18);
  if ((_DWORD)ObjectID)
  {
    v13 = ObjectID;
    v14 = 0;
  }
  else
  {
    v13 = FigXPCCreateBasicMessage(0x73726174u, v18, &xdict);
    v14 = xdict;
    if (!(_DWORD)v13)
    {
      xpc_dictionary_set_double(xdict, "Rate", a6);
      v16 = *a2;
      v17 = *((_QWORD *)a2 + 2);
      FigXPCMessageSetCMTime(xdict, "SampleTime", &v16);
      v16 = *a3;
      v17 = *((_QWORD *)a3 + 2);
      FigXPCMessageSetCMTime(xdict, "HostTime", &v16);
      v13 = FigEndpointStreamRemoteXPC_sendMessageSynchronouslyExpectingCompletionCallback(a1, xdict, 0, a4, a5);
      v14 = xdict;
    }
  }
  FigXPCRelease(v14);
  return v13;
}

uint64_t FigEndpointStreamRemoteXPC_CopyTransportFormatDescriptionForSourceContentFormatDescription(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t ObjectID;
  uint64_t v6;
  xpc_object_t xdict;
  uint64_t v9;
  void *v10;

  v9 = 0;
  v10 = 0;
  xdict = 0;
  ObjectID = FigEndpointStreamXPCRemoteGetObjectID(a1, &v9);
  if (!(_DWORD)ObjectID)
  {
    ObjectID = FigXPCCreateBasicMessage(0x63746664u, v9, &v10);
    if (!(_DWORD)ObjectID)
    {
      ObjectID = FigXPCMessageSetFigEndpointStreamAudioFormatDescription(v10, "FormatDescription", a2);
      if (!(_DWORD)ObjectID)
      {
        ObjectID = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigEndpointStreamRemoteClient, (uint64_t)v10, &xdict);
        if (!(_DWORD)ObjectID)
          ObjectID = (uint64_t)FigXPCMessageCopyFigEndpointStreamAudioFormatDescription(*MEMORY[0x1E0C9AE00], xdict, "FormatDescription", a3);
      }
    }
  }
  v6 = ObjectID;
  FigXPCRelease(v10);
  FigXPCRelease(xdict);
  return v6;
}

uint64_t FigEndpointStreamRemoteXPC_IsPassthroughSupportedForFormatDescription(uint64_t a1, void *a2, BOOL *a3)
{
  uint64_t ObjectID;
  uint64_t v6;
  BOOL v7;
  xpc_object_t xdict;
  uint64_t v10;
  void *v11;

  v10 = 0;
  v11 = 0;
  xdict = 0;
  ObjectID = FigEndpointStreamXPCRemoteGetObjectID(a1, &v10);
  if ((_DWORD)ObjectID
    || (ObjectID = FigXPCCreateBasicMessage(0x70736664u, v10, &v11), (_DWORD)ObjectID)
    || (ObjectID = FigXPCMessageSetFigEndpointStreamAudioFormatDescription(v11, "FormatDescription", a2),
        (_DWORD)ObjectID))
  {
    v6 = ObjectID;
    goto LABEL_8;
  }
  v6 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigEndpointStreamRemoteClient, (uint64_t)v11, &xdict);
  if ((_DWORD)v6)
  {
LABEL_8:
    v7 = 0;
    goto LABEL_6;
  }
  v7 = xpc_dictionary_get_BOOL(xdict, "IsPassthroughSupported");
LABEL_6:
  *a3 = v7;
  FigXPCRelease(v11);
  FigXPCRelease(xdict);
  return v6;
}

uint64_t FigAtomStreamInitWithByteStreamWithSizeAndReporter(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  uint64_t EntireLengthOfByteStream;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  _QWORD v18[2];
  char __str[256];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  EntireLengthOfByteStream = GetEntireLengthOfByteStream(a1, &v17);
  if (!(_DWORD)EntireLengthOfByteStream)
  {
    v13 = v17;
    if (a2 < 0 || (v14 = v17 - a2, v17 <= a2))
    {
      v18[0] = 0;
      v18[1] = 0;
      snprintf(__str, 0x100uLL, "Offset %lld exceeds stream length %lld", a2, v17);
      v15 = 4294954403;
      FigSignalErrorAt(4294954403, 0, 0, 0, 0, 0, 0);
      AtomStreamReportErrorMessage(a5, (const char *)v18, -12893, (uint64_t)__str);
      return v15;
    }
    *(_OWORD *)a6 = 0u;
    *(_OWORD *)(a6 + 16) = 0u;
    *(_OWORD *)(a6 + 32) = 0u;
    *(_OWORD *)(a6 + 48) = 0u;
    *(_OWORD *)(a6 + 80) = 0u;
    *(_OWORD *)(a6 + 96) = 0u;
    *(_OWORD *)(a6 + 64) = 0u;
    *(_BYTE *)a6 = a4;
    *(_QWORD *)(a6 + 8) = a1;
    *(_QWORD *)(a6 + 16) = v13;
    *(_QWORD *)(a6 + 24) = ReadBytesFromByteStreamDataSource;
    *(_QWORD *)(a6 + 32) = ReadBBufFromByteStreamDataSource;
    *(_QWORD *)(a6 + 40) = a2;
    *(_QWORD *)(a6 + 48) = v14;
    *(_QWORD *)(a6 + 104) = a5;
    if (v14 > a3)
      *(_QWORD *)(a6 + 48) = a3;
    return CommonAtomStreamInitialization((unsigned __int8 *)a6);
  }
  return EntireLengthOfByteStream;
}

uint64_t GetEntireLengthOfByteStream(uint64_t a1, void *a2)
{
  uint64_t CMBaseObject;
  uint64_t (*v4)(uint64_t, const __CFString *, _QWORD, CFNumberRef *);
  uint64_t result;
  CFNumberRef number;

  number = 0;
  CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  v4 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, CFNumberRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                                + 8)
                                                                                    + 48);
  if (!v4)
    return 4294954514;
  result = v4(CMBaseObject, CFSTR("FBS_EntireLength"), 0, &number);
  if (!(_DWORD)result)
  {
    CFNumberGetValue(number, kCFNumberSInt64Type, a2);
    CFRelease(number);
    return 0;
  }
  return result;
}

void AtomStreamReportErrorMessage(uint64_t a1, const char *a2, int a3, uint64_t a4)
{
  const __CFAllocator *v8;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v10;
  __CFString *v11;
  __CFString *v12;
  const __CFString *v13;
  int v14;

  if (a1)
  {
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v10 = Mutable;
      v14 = 0;
      v11 = CFStringCreateMutable(v8, 0);
      if (v11)
      {
        v12 = v11;
        CFStringAppendFormat(v11, 0, CFSTR("%s"), a4);
        FigCFDictionarySetInt32(v10, CFSTR("FailureCode"), a3);
        if (*a2)
        {
          v13 = CFStringCreateWithCString(v8, a2, 0);
          if (FigCFStringGetOSTypeValue(v13, &v14))
            FigCFDictionarySetInt32(v10, CFSTR("AtomType"), v14);
          if (v13)
            CFRelease(v13);
        }
        CFDictionarySetValue(v10, CFSTR("DiagnosticInformation"), v12);
        FigCFDictionarySetInt32(v10, CFSTR("AnalysisType"), 1635020653);
        FigAssetAnalysisReporterAddMessage(a1, v10);
        CFRelease(v12);
      }
      CFRelease(v10);
    }
  }
}

uint64_t ReadBytesFromByteStreamDataSource(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  v9 = *a1;
  v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(*a1)
                                                                                          + 16)
                                                                              + 8);
  if (v10)
    return v10(v9, a2, a3, a4, a5);
  else
    return 4294954514;
}

uint64_t ReadBBufFromByteStreamDataSource(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  v9 = *a1;
  v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(*a1)
                                                                                          + 16)
                                                                              + 32);
  if (v10)
    return v10(v9, a2, a3, a4, a5);
  else
    return 4294954514;
}

uint64_t CommonAtomStreamInitialization(unsigned __int8 *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t AtomHeader;
  uint64_t v5;
  char v7[8];
  uint64_t v8;
  char __str[256];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)a1 + 5);
  v3 = *((_QWORD *)a1 + 6) + v2;
  AtomHeader = ReadAtomHeader(*((_QWORD *)a1 + 13), (uint64_t)(a1 + 8), v2, v3, *a1, 0, 0);
  if (!(_DWORD)AtomHeader)
  {
    v5 = *((_QWORD *)a1 + 9);
    if (v5 > 7)
    {
      if (v5 <= v3 - *((_QWORD *)a1 + 5))
      {
        AtomHeader = 0;
        *((_QWORD *)a1 + 7) = 0;
        *((_QWORD *)a1 + 10) = v5;
        return AtomHeader;
      }
      *(_QWORD *)v7 = 0;
      v8 = 0;
      AtomTypeToString(*((_DWORD *)a1 + 16), v7);
      snprintf(__str, 0x100uLL, "Atom total length (%lld) exceeds container's length. Atom '%s' at offset %lld.");
    }
    else
    {
      *(_QWORD *)v7 = 0;
      v8 = 0;
      AtomTypeToString(*((_DWORD *)a1 + 16), v7);
      snprintf(__str, 0x100uLL, "Atom total length (%lld) less than an atom header size. Atom '%s' at offset %lld.");
    }
    AtomHeader = 4294954402;
    AtomStreamReportErrorMessage(*((_QWORD *)a1 + 13), v7, -12894, (uint64_t)__str);
  }
  return AtomHeader;
}

uint64_t FigAtomStreamInitWithByteStreamAndReporter(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5)
{
  return FigAtomStreamInitWithByteStreamWithSizeAndReporter(a1, a2, 0x7FFFFFFFFFFFFFFFLL, a3, a4, a5);
}

uint64_t FigAtomStreamInitWithByteStreamWithSize(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  return FigAtomStreamInitWithByteStreamWithSizeAndReporter(a1, a2, a3, a4, 0, a5);
}

uint64_t FigAtomStreamInitWithByteStream(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  return FigAtomStreamInitWithByteStreamWithSizeAndReporter(a1, a2, 0x7FFFFFFFFFFFFFFFLL, a3, 0, a4);
}

uint64_t FigAtomStreamInitWithParent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t AtomHeader;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v16[8];
  uint64_t v17;
  char __str[256];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)a3 = 0;
  v5 = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(a3 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a3 + 8) = v5;
  v6 = *(_QWORD *)(a1 + 56) + *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a3 + 40) = v6;
  v7 = *(_QWORD *)(a1 + 80);
  *(_QWORD *)(a3 + 48) = v7;
  v8 = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a3 + 104) = v8;
  if (v7 < a2)
  {
    *(_QWORD *)v16 = 0;
    v17 = 0;
    snprintf(__str, 0x100uLL, "Offset %zd outside of parent container length %lld (Effective global offset %lld)", a2, v7, v6 + a2);
    AtomHeader = 4294954403;
    FigSignalErrorAt(4294954403, 0, 0, 0, 0, 0, 0);
    v10 = *(_QWORD *)(a3 + 104);
    v11 = -12893;
LABEL_7:
    AtomStreamReportErrorMessage(v10, v16, v11, (uint64_t)__str);
    return AtomHeader;
  }
  v12 = v7 + v6;
  v13 = (uint64_t *)(a3 + 72);
  AtomHeader = ReadAtomHeader(v8, a3 + 8, v6 + a2, v7 + v6, 0, 0, 1);
  if (!(_DWORD)AtomHeader)
  {
    v14 = *v13;
    if (*v13 >= 8 && v14 <= v12 - (*(_QWORD *)(a3 + 40) + a2))
    {
      AtomHeader = 0;
      *(_QWORD *)(a3 + 56) = a2;
      *(_QWORD *)(a3 + 80) = v14;
      return AtomHeader;
    }
    *(_QWORD *)v16 = 0;
    v17 = 0;
    AtomTypeToString(*(_DWORD *)(a3 + 64), v16);
    snprintf(__str, 0x100uLL, "Atom '%s' has an invalid length %lld, offset %lld, limit %lld", v16, *(_QWORD *)(a3 + 72), *(_QWORD *)(a3 + 40) + a2, v12);
    AtomHeader = 4294954402;
    FigSignalErrorAt(4294954402, 0, 0, 0, 0, 0, 0);
    v10 = *(_QWORD *)(a3 + 104);
    v11 = -12894;
    goto LABEL_7;
  }
  return AtomHeader;
}

uint64_t ReadAtomHeader(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v7;
  uint64_t v11;
  size_t v13;
  uint64_t v14;
  int v15[2];
  char v16[8];
  uint64_t v17;
  char __str[256];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (a3 + 8 > a4)
    return 4294954403;
  v14 = 0;
  *(_QWORD *)v15 = 0;
  v13 = 0;
  v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, 8);
  if ((_DWORD)v11)
    return v11;
  *(_QWORD *)v16 = 0;
  v17 = 0;
  snprintf(__str, 0x100uLL, "Fewer bytes read than expected reading atom header at offset %lld (read %zd wanted %zd)", a3, v13, 8uLL);
  if (a7)
    FigSignalErrorAt(4294954404, 0, 0, 0, 0, 0, 0);
  v7 = 4294954404;
  AtomStreamReportErrorMessage(a1, v16, -12892, (uint64_t)__str);
  return v7;
}

char *AtomTypeToString(unsigned int a1, char *__str)
{
  int v4;

  if ((a1 & 0x80000000) != 0)
    v4 = __maskrune(HIBYTE(a1), 0x40000uLL);
  else
    v4 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * HIBYTE(a1) + 60) & 0x40000;
  if (!v4)
    goto LABEL_15;
  if (BYTE2(a1) > 0x7Fu)
  {
    if (!__maskrune(BYTE2(a1), 0x40000uLL))
      goto LABEL_15;
  }
  else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * BYTE2(a1) + 60) & 0x40000) == 0)
  {
    goto LABEL_15;
  }
  if (BYTE1(a1) <= 0x7Fu)
  {
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * BYTE1(a1) + 60) & 0x40000) == 0)
      goto LABEL_15;
LABEL_13:
    if (a1 > 0x7Fu)
    {
      if (!__maskrune(a1, 0x40000uLL))
        goto LABEL_15;
    }
    else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * a1 + 60) & 0x40000) == 0)
    {
      goto LABEL_15;
    }
    snprintf(__str, 0x10uLL, "%c%c%c%c");
    return __str;
  }
  if (__maskrune(BYTE1(a1), 0x40000uLL))
    goto LABEL_13;
LABEL_15:
  snprintf(__str, 0x10uLL, "0x%02x%02x%02x%02x");
  return __str;
}

uint64_t FigAtomStreamGetCurrentAtomTypeAndDataLength(uint64_t a1, _DWORD *a2, _QWORD *a3)
{
  if (a2)
    *a2 = *(_DWORD *)(a1 + 64);
  if (a3)
    *a3 = *(_QWORD *)(a1 + 80);
  return 0;
}

uint64_t FigAtomStreamGetCurrentAtomUUIDType(uint64_t a1, _OWORD *a2)
{
  uint64_t result;

  if (*(_DWORD *)(a1 + 64) != 1970628964)
    return 4294954401;
  result = 0;
  *a2 = *(_OWORD *)(a1 + 88);
  return result;
}

uint64_t FigAtomStreamGetCurrentAtomVersionAndFlags(uint64_t a1, _BYTE *a2, unsigned int *a3)
{
  uint64_t result;
  unsigned int v6;
  unsigned int v7;

  v7 = 0;
  result = FigAtomStreamReadCurrentAtomData(a1, 0, 4, (uint64_t)&v7);
  if (!(_DWORD)result)
  {
    v6 = bswap32(v7);
    if (a2)
      *a2 = HIBYTE(v6);
    if (a3)
      *a3 = v6 & 0xFFFFFF;
  }
  return result;
}

uint64_t FigAtomStreamReadCurrentAtomData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v14;
  char v15[8];
  uint64_t v16;
  char __str[256];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  v7 = *(_QWORD *)(a1 + 80);
  if (v7 > a2 && a3 + a2 <= v7)
  {
    v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(a1 + 24))(a1 + 8, a3, *(_QWORD *)(a1 + 40) + a2 + *(_QWORD *)(a1 + 56), a4, &v14);
    if ((_DWORD)v9)
      return v9;
    v12 = v14;
    if (v14 == a3)
      return 0;
    *(_QWORD *)v15 = 0;
    v16 = 0;
    AtomTypeToString(*(_DWORD *)(a1 + 64), v15);
    snprintf(__str, 0x100uLL, "Fewer bytes read than expected (got %zd wanted %zd) %lld bytes into '%s' atom length %lld @ %lld", v12, a3, a2, v15, *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 56) + *(_QWORD *)(a1 + 40));
    v9 = 4294954404;
    FigSignalErrorAt(4294954404, 0, 0, 0, 0, 0, 0);
    v10 = *(_QWORD *)(a1 + 104);
    v11 = -12892;
  }
  else
  {
    *(_QWORD *)v15 = 0;
    v16 = 0;
    AtomTypeToString(*(_DWORD *)(a1 + 64), v15);
    snprintf(__str, 0x100uLL, "Attempt to read %zd bytes at %lld out of range of '%s' atom's data size %lld", a3, a2, v15, *(_QWORD *)(a1 + 80));
    v9 = 4294954405;
    FigSignalErrorAt(4294954405, 0, 0, 0, 0, 0, 0);
    v10 = *(_QWORD *)(a1 + 104);
    v11 = -12891;
  }
  AtomStreamReportErrorMessage(v10, v15, v11, (uint64_t)__str);
  return v9;
}

uint64_t FigAtomStreamGetCurrentAtomGlobalOffset(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  if (a2)
    *a2 = a1[7] + a1[5] - a1[9] + a1[10];
  if (a3)
    *a3 = a1[9];
  return 0;
}

uint64_t FigAtomStreamGetCurrentAtomOffsetInParent(_QWORD *a1, _QWORD *a2)
{
  *a2 = a1[10] - a1[9] + a1[7];
  return 0;
}

uint64_t FigAtomStreamGetCurrentAtomDataGlobalOffset(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  char v7[8];
  uint64_t v8;
  char __str[256];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 80) <= a2)
  {
    *(_QWORD *)v7 = 0;
    v8 = 0;
    AtomTypeToString(*(_DWORD *)(a1 + 64), v7);
    snprintf(__str, 0x100uLL, "Offset %lld beyond end of '%s' atom's dataLength %lld", a2, v7, *(_QWORD *)(a1 + 80));
    v5 = 4294954405;
    FigSignalErrorAt(4294954405, 0, 0, 0, 0, 0, 0);
    AtomStreamReportErrorMessage(*(_QWORD *)(a1 + 104), v7, -12891, (uint64_t)__str);
  }
  else
  {
    v5 = 0;
    *a3 = *(_QWORD *)(a1 + 40) + a2 + *(_QWORD *)(a1 + 56);
  }
  return v5;
}

uint64_t FigAtomStreamGetCurrentAtomHeaderSize(uint64_t a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 72) - *(_QWORD *)(a1 + 80);
  return 0;
}

uint64_t FigAtomStreamReadCurrentAtomDataAndCreateBBuf(uint64_t a1, uint64_t a2, size_t a3, CMBlockBufferRef *a4)
{
  size_t v4;
  uint64_t v7;
  uint64_t Contiguous;
  uint64_t v10;
  int v11;
  uint64_t v14;
  CMBlockBufferRef sourceBuffer;
  uint64_t v16;
  char v17[8];
  uint64_t v18;
  char __str[8];
  uint64_t v20;

  v4 = a3;
  v20 = *MEMORY[0x1E0C80C00];
  v16 = 0;
  v7 = *(_QWORD *)(a1 + 80);
  if (v7 <= a2 || (uint64_t)(a3 + a2) > v7)
  {
    *(_QWORD *)v17 = 0;
    v18 = 0;
    AtomTypeToString(*(_DWORD *)(a1 + 64), v17);
    snprintf(__str, 0x100uLL, "Attempt to read %zd bytes at %lld out of range of '%s' atom's data size %lld", v4, a2, v17, *(_QWORD *)(a1 + 80));
    Contiguous = 4294954405;
    FigSignalErrorAt(4294954405, 0, 0, 0, 0, 0, 0);
    v10 = *(_QWORD *)(a1 + 104);
    v11 = -12891;
LABEL_6:
    AtomStreamReportErrorMessage(v10, v17, v11, (uint64_t)__str);
    return Contiguous;
  }
  sourceBuffer = 0;
  if (!a3)
    v4 = v7 - a2;
  Contiguous = (*(uint64_t (**)(uint64_t, size_t, uint64_t, CMBlockBufferRef *, uint64_t *))(a1 + 32))(a1 + 8, v4, *(_QWORD *)(a1 + 40) + a2 + *(_QWORD *)(a1 + 56), &sourceBuffer, &v16);
  if (!(_DWORD)Contiguous)
  {
    v14 = v16;
    if (v16 != v4)
    {
      if (sourceBuffer)
      {
        CFRelease(sourceBuffer);
        v14 = v16;
      }
      *(_QWORD *)v17 = 0;
      v18 = 0;
      AtomTypeToString(*(_DWORD *)(a1 + 64), v17);
      snprintf(__str, 0x100uLL, "Fewer bytes read than expected (got %zd wanted %zd) %lld bytes into '%s' atom length %lld @ %lld", v14, v4, a2, v17, *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 56) + *(_QWORD *)(a1 + 40));
      Contiguous = 4294954404;
      FigSignalErrorAt(4294954404, 0, 0, 0, 0, 0, 0);
      v10 = *(_QWORD *)(a1 + 104);
      v11 = -12892;
      goto LABEL_6;
    }
    if (CMBlockBufferIsRangeContiguous(sourceBuffer, 0, v4))
    {
      Contiguous = 0;
      *a4 = sourceBuffer;
    }
    else
    {
      *(_QWORD *)__str = 0;
      Contiguous = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E0C9AE00], sourceBuffer, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, v4, 0, (CMBlockBufferRef *)__str);
      *a4 = *(CMBlockBufferRef *)__str;
      if (sourceBuffer)
        CFRelease(sourceBuffer);
    }
  }
  return Contiguous;
}

uint64_t FigAtomStreamReadCurrentAtomAndCreateBBuf(uint64_t a1, CMBlockBufferRef *a2)
{
  size_t v4;
  size_t v5;
  uint64_t Contiguous;
  uint64_t v7;
  CMBlockBufferRef sourceBuffer;
  uint64_t v10;
  char v11[8];
  uint64_t v12;
  char __str[8];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  sourceBuffer = 0;
  v10 = 0;
  v4 = *(_QWORD *)(a1 + 72);
  v5 = *(_QWORD *)(a1 + 80) - v4 + *(_QWORD *)(a1 + 40) + *(_QWORD *)(a1 + 56);
  Contiguous = (*(uint64_t (**)(uint64_t, size_t, size_t, CMBlockBufferRef *, uint64_t *))(a1 + 32))(a1 + 8, v4, v5, &sourceBuffer, &v10);
  if (!(_DWORD)Contiguous)
  {
    v7 = v10;
    if (v10 == v4)
    {
      if (CMBlockBufferIsRangeContiguous(sourceBuffer, 0, v4))
      {
        Contiguous = 0;
        *a2 = sourceBuffer;
      }
      else
      {
        *(_QWORD *)__str = 0;
        Contiguous = CMBlockBufferCreateContiguous((CFAllocatorRef)*MEMORY[0x1E0C9AE00], sourceBuffer, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, v4, 0, (CMBlockBufferRef *)__str);
        *a2 = *(CMBlockBufferRef *)__str;
        if (sourceBuffer)
          CFRelease(sourceBuffer);
      }
    }
    else
    {
      if (sourceBuffer)
      {
        CFRelease(sourceBuffer);
        v7 = v10;
      }
      *(_QWORD *)v11 = 0;
      v12 = 0;
      AtomTypeToString(*(_DWORD *)(a1 + 64), v11);
      snprintf(__str, 0x100uLL, "Fewer bytes read than expected (got %zd wanted %zd) for '%s' atom @ %lld", v7, v4, v11, v5);
      Contiguous = 4294954404;
      FigSignalErrorAt(4294954404, 0, 0, 0, 0, 0, 0);
      AtomStreamReportErrorMessage(*(_QWORD *)(a1 + 104), v11, -12892, (uint64_t)__str);
    }
  }
  return Contiguous;
}

uint64_t FigAtomStreamAdvanceToNextAtom(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t AtomHeader;
  uint64_t v5;
  uint64_t v6;
  char v8[8];
  uint64_t v9;
  char __str[256];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v1 = a1[6];
  v2 = a1[10] + a1[7];
  if (v2 == v1)
    return 4294954406;
  v5 = a1[5];
  v6 = v5 + v1;
  AtomHeader = ReadAtomHeader(a1[13], (uint64_t)(a1 + 1), v5 + v2, v5 + v1, *(unsigned __int8 *)a1, 0, 1);
  if (!(_DWORD)AtomHeader)
  {
    *(_QWORD *)v8 = 0;
    v9 = 0;
    AtomTypeToString(0, v8);
    snprintf(__str, 0x100uLL, "Atom '%s' has an invalid length %lld, offset %lld, limit %lld", v8, 0, a1[5] + v2, v6);
    AtomHeader = 4294954402;
    FigSignalErrorAt(4294954402, 0, 0, 0, 0, 0, 0);
    AtomStreamReportErrorMessage(a1[13], v8, -12894, (uint64_t)__str);
  }
  return AtomHeader;
}

uint64_t FigAtomStreamAdvanceToNextAtomWithType(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t AtomHeader;
  char v9[8];
  uint64_t v10;
  char __str[256];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v1 = a1[6];
  v2 = a1[10] + a1[7];
  if (v2 == v1)
    return 4294954406;
  v5 = a1[5];
  v6 = v1 + v5;
  AtomHeader = ReadAtomHeader(a1[13], (uint64_t)(a1 + 1), v5 + v2, v1 + v5, *(unsigned __int8 *)a1, 0, 1);
  if ((_DWORD)AtomHeader)
    return AtomHeader;
  *(_QWORD *)v9 = 0;
  v10 = 0;
  AtomTypeToString(0, v9);
  snprintf(__str, 0x100uLL, "Atom '%s' has an invalid length %lld, offset %lld, limit %lld", v9, 0, a1[5] + v2, v6);
  v3 = 4294954402;
  FigSignalErrorAt(4294954402, 0, 0, 0, 0, 0, 0);
  AtomStreamReportErrorMessage(a1[13], v9, -12894, (uint64_t)__str);
  return v3;
}

uint64_t FigAtomStreamPositionAtFirstAtomWithType(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 64) == a2)
    return 0;
  else
    return FigAtomStreamAdvanceToNextAtomWithType((_QWORD *)a1);
}

__n128 FigAtomStreamAdvanceViaAtomPath(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  __n128 result;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __n128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;

  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v9 = 0u;
  if (!FigAtomStreamInitWithParent(a1, 0, (uint64_t)&v9)
    && ((_DWORD)v13 == *a3 || !FigAtomStreamAdvanceToNextAtomWithType(&v9))
    && (a2 < 2 || !FigAtomStreamAdvanceViaAtomPath(&v9, a2 - 1, a3 + 1)))
  {
    v7 = v14;
    *(_OWORD *)(a1 + 64) = v13;
    *(_OWORD *)(a1 + 80) = v7;
    *(_OWORD *)(a1 + 96) = v15;
    v8 = v10;
    *(_OWORD *)a1 = v9;
    *(_OWORD *)(a1 + 16) = v8;
    result = v12;
    *(_OWORD *)(a1 + 32) = v11;
    *(__n128 *)(a1 + 48) = result;
  }
  return result;
}

__n128 FigAtomStreamPositionViaAtomPath(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int AtomWithType;
  __n128 result;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __n128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  if (*(_DWORD *)(a1 + 64) == *a3)
    AtomWithType = 0;
  else
    AtomWithType = FigAtomStreamAdvanceToNextAtomWithType((_QWORD *)a1);
  if (a2 >= 2 && !AtomWithType)
  {
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v11 = 0u;
    v12 = 0u;
    v10 = 0u;
    if (!FigAtomStreamInitWithParent(a1, 0, (uint64_t)&v10)
      && !FigAtomStreamPositionViaAtomPath(&v10, a2 - 1, a3 + 1))
    {
      v8 = v15;
      *(_OWORD *)(a1 + 64) = v14;
      *(_OWORD *)(a1 + 80) = v8;
      *(_OWORD *)(a1 + 96) = v16;
      v9 = v11;
      *(_OWORD *)a1 = v10;
      *(_OWORD *)(a1 + 16) = v9;
      result = v13;
      *(_OWORD *)(a1 + 32) = v12;
      *(__n128 *)(a1 + 48) = result;
    }
  }
  return result;
}

uint64_t FigAtomStreamInitWithBBufAndReporter(OpaqueCMBlockBuffer *a1, unint64_t a2, char a3, uint64_t a4, uint64_t a5)
{
  size_t DataLength;
  _QWORD v12[2];
  char __str[256];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  DataLength = CMBlockBufferGetDataLength(a1);
  if ((a2 & 0x8000000000000000) != 0 || DataLength <= a2)
  {
    v12[0] = 0;
    v12[1] = 0;
    snprintf(__str, 0x100uLL, "Offset %zd exceeds block buffer length %zd", a2, DataLength);
    FigSignalErrorAt(4294954403, 0, 0, 0, 0, 0, 0);
    AtomStreamReportErrorMessage(a4, (const char *)v12, -12893, (uint64_t)__str);
    return 4294954403;
  }
  else
  {
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_OWORD *)(a5 + 48) = 0u;
    *(_OWORD *)(a5 + 80) = 0u;
    *(_OWORD *)(a5 + 96) = 0u;
    *(_OWORD *)(a5 + 64) = 0u;
    *(_BYTE *)a5 = a3;
    *(_QWORD *)(a5 + 8) = a1;
    *(_QWORD *)(a5 + 16) = DataLength;
    *(_QWORD *)(a5 + 24) = ReadBytesFromBlockBufferDataSource;
    *(_QWORD *)(a5 + 32) = ReadBBufFromBlockBufferDataSource;
    *(_QWORD *)(a5 + 40) = a2;
    *(_QWORD *)(a5 + 48) = DataLength - a2;
    *(_QWORD *)(a5 + 104) = a4;
    return CommonAtomStreamInitialization((unsigned __int8 *)a5);
  }
}

uint64_t ReadBytesFromBlockBufferDataSource(CMBlockBufferRef *a1, size_t dataLength, size_t offsetToData, void *a4, size_t *a5)
{
  uint64_t result;
  size_t v8;

  result = CMBlockBufferCopyDataBytes(*a1, offsetToData, dataLength, a4);
  if ((_DWORD)result)
    v8 = 0;
  else
    v8 = dataLength;
  *a5 = v8;
  return result;
}

uint64_t ReadBBufFromBlockBufferDataSource(CMBlockBufferRef *a1, size_t dataLength, size_t a3, CMBlockBufferRef *blockBufferOut, size_t *a5)
{
  uint64_t result;
  size_t v8;

  result = CMBlockBufferCreateWithBufferReference((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *a1, a3, dataLength, 0, blockBufferOut);
  if ((_DWORD)result)
    v8 = 0;
  else
    v8 = dataLength;
  *a5 = v8;
  return result;
}

uint64_t FigAtomStreamInitWithBBuf(OpaqueCMBlockBuffer *a1, unint64_t a2, char a3, uint64_t a4)
{
  return FigAtomStreamInitWithBBufAndReporter(a1, a2, a3, 0, a4);
}

uint64_t FigAtomStreamInitWithMemoryBlockAndReporter(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  if (!a2)
    return FigSignalErrorAt(4294954399, 0, 0, 0, 0, 0, 0);
  *(_OWORD *)a6 = 0u;
  *(_OWORD *)(a6 + 16) = 0u;
  *(_OWORD *)(a6 + 32) = 0u;
  *(_OWORD *)(a6 + 48) = 0u;
  *(_OWORD *)(a6 + 80) = 0u;
  *(_OWORD *)(a6 + 96) = 0u;
  *(_OWORD *)(a6 + 64) = 0u;
  *(_BYTE *)a6 = a4;
  *(_QWORD *)(a6 + 8) = a1;
  *(_QWORD *)(a6 + 16) = a2;
  *(_QWORD *)(a6 + 24) = ReadBytesFromMemoryBlockDataSource;
  *(_QWORD *)(a6 + 32) = ReadBBufFromMemoryBlockDataSource;
  *(_QWORD *)(a6 + 40) = a3;
  *(_QWORD *)(a6 + 48) = a2;
  *(_QWORD *)(a6 + 104) = a5;
  return CommonAtomStreamInitialization((unsigned __int8 *)a6);
}

uint64_t ReadBytesFromMemoryBlockDataSource(_QWORD *a1, int64_t a2, uint64_t a3, void *__dst, int64_t *a5)
{
  uint64_t v5;
  BOOL v6;
  int64_t v7;

  v5 = a1[1];
  v6 = v5 <= a3;
  v7 = v5 - a3;
  if (v6)
    return 4294954404;
  if (v7 >= a2)
    v7 = a2;
  *a5 = v7;
  if (v7)
    memcpy(__dst, (const void *)(*a1 + a3), v7);
  return 0;
}

uint64_t ReadBBufFromMemoryBlockDataSource(_QWORD *a1, int64_t a2, uint64_t a3, CMBlockBufferRef *a4, size_t *a5)
{
  uint64_t v5;
  BOOL v6;
  int64_t v7;
  size_t v9;
  uint64_t result;
  CMBlockBufferRef destinationBuffer;

  v5 = a1[1];
  v6 = v5 <= a3;
  v7 = v5 - a3;
  if (v6)
    return 4294954404;
  if (v7 >= a2)
    v9 = a2;
  else
    v9 = v7;
  *a5 = v9;
  if (v9)
  {
    destinationBuffer = 0;
    result = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v9, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, v9, 1u, &destinationBuffer);
    if (!(_DWORD)result)
    {
      CMBlockBufferReplaceDataBytes((const void *)(*a1 + a3), destinationBuffer, 0, v9);
      result = 0;
      *a4 = destinationBuffer;
    }
  }
  else
  {
    result = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t FigAtomStreamInitWithMemoryBlock(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  return FigAtomStreamInitWithMemoryBlockAndReporter(a1, a2, a3, a4, 0, a5);
}

uint64_t FigAtomUtilityGetAtomTypeAndLengthInByteStream(uint64_t a1, uint64_t a2, _DWORD *a3, _QWORD *a4, _QWORD *a5)
{
  return FigAtomUtilityGetAtomTypeAndLengthInByteStreamWithSize(a1, a2, 0x7FFFFFFFFFFFFFFFLL, a3, a4, a5);
}

uint64_t FigAtomUtilityGetAtomTypeAndLengthInByteStreamWithSize(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t EntireLengthOfByteStream;
  uint64_t v13;
  unsigned int AtomHeader;
  uint64_t v15;
  uint64_t v17;
  char __str[8];
  uint64_t v19;
  uint64_t (*v20)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v21)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  EntireLengthOfByteStream = GetEntireLengthOfByteStream(a1, &v17);
  if ((_DWORD)EntireLengthOfByteStream)
    return EntireLengthOfByteStream;
  if (a2 < 0 || v17 <= a2)
  {
    snprintf(__str, 0x100uLL, "Offset %lld exceeds stream length %lld.", a2, v17);
    v15 = 4294954403;
    FigSignalErrorAt(4294954403, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    *(_QWORD *)__str = a1;
    v19 = v17;
    if (v17 - a2 >= a3)
      v13 = a3;
    else
      v13 = v17 - a2;
    v20 = ReadBytesFromByteStreamDataSource;
    v21 = ReadBBufFromByteStreamDataSource;
    AtomHeader = ReadAtomHeader(0, (uint64_t)__str, a2, v13 + a2, 0, 1, 0);
    if (a4)
      *a4 = 0;
    if (a5)
      *a5 = 0;
    if (a6)
      *a6 = 0;
    if (AtomHeader + 12893 >= 2)
      return AtomHeader;
    else
      return 4294954400;
  }
  return v15;
}

uint64_t FigAtomUtilityGetAtomTypeAndLengthInBBuf(OpaqueCMBlockBuffer *a1, unint64_t a2, _DWORD *a3, _QWORD *a4, _QWORD *a5)
{
  size_t DataLength;
  unsigned int AtomHeader;
  uint64_t v12;
  char __str[8];
  size_t v15;
  uint64_t (*v16)(CMBlockBufferRef *, size_t, size_t, void *, size_t *);
  uint64_t (*v17)(CMBlockBufferRef *, size_t, size_t, CMBlockBufferRef *, size_t *);
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  DataLength = CMBlockBufferGetDataLength(a1);
  if ((a2 & 0x8000000000000000) != 0 || DataLength <= a2)
  {
    snprintf(__str, 0x100uLL, "Offset %zd exceeds block buffer length %zd", a2, DataLength);
    v12 = 4294954403;
    FigSignalErrorAt(4294954403, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    *(_QWORD *)__str = a1;
    v15 = DataLength;
    v16 = ReadBytesFromBlockBufferDataSource;
    v17 = ReadBBufFromBlockBufferDataSource;
    AtomHeader = ReadAtomHeader(0, (uint64_t)__str, a2, DataLength, 0, 1, 1);
    if (a3)
      *a3 = 0;
    if (a4)
      *a4 = 0;
    if (a5)
      *a5 = 0;
    if (AtomHeader + 12893 >= 2)
      return AtomHeader;
    else
      return 4294954400;
  }
  return v12;
}

uint64_t FigPriorityQueueGetTypeID()
{
  FigThreadRunOnce(&FigPriorityQueueGetTypeID_sRegisterFigPriorityQueueOnce, (void (*)(void))registerFigPriorityQueue);
  return sFigPriorityQueueID;
}

uint64_t registerFigPriorityQueue()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigPriorityQueueID = result;
  return result;
}

uint64_t FigPriorityQueueCreate(const __CFAllocator *a1, CFIndex a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  uint64_t Instance;
  _QWORD *v13;
  __int128 v14;
  __int128 v15;
  __CFArray *Mutable;
  uint64_t result;

  if (!a4 || !a6)
    return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
  FigThreadRunOnce(&FigPriorityQueueGetTypeID_sRegisterFigPriorityQueueOnce, (void (*)(void))registerFigPriorityQueue);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v13 = (_QWORD *)Instance;
    if (a3)
    {
      v14 = *(_OWORD *)(a3 + 8);
      v15 = *(_OWORD *)(a3 + 24);
    }
    else
    {
      v14 = 0uLL;
      v15 = 0uLL;
    }
    *(_OWORD *)(Instance + 16) = v14;
    *(_OWORD *)(Instance + 32) = v15;
    *(_QWORD *)(Instance + 48) = a4;
    *(_QWORD *)(Instance + 56) = a5;
    Mutable = CFArrayCreateMutable(a1, a2, MEMORY[0x1E0C9B378]);
    v13[8] = Mutable;
    if (Mutable)
    {
      CFArrayAppendValue(Mutable, (const void *)*MEMORY[0x1E0C9B0D0]);
      result = 0;
      *a6 = v13;
      return result;
    }
    CFRelease(v13);
  }
  return 4294954305;
}

uint64_t FigPriorityQueueCheckHeap(uint64_t a1)
{
  CFIndex Count;
  CFIndex v3;
  uint64_t v4;
  unint64_t i;
  _QWORD *ValueAtIndex;
  unsigned int v7;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  if (Count < 2)
    return 0;
  v3 = Count;
  if (*((_QWORD *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), 1) + 3) == 1)
    v4 = 0;
  else
    v4 = 0xFFFFFFFFLL;
  if (v3 != 2)
  {
    for (i = 2; i != v3; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), i);
      if (comparePriorityAtIndices(a1, i, i >> 1) == -1)
        v7 = -1;
      else
        v7 = v4;
      if (i == ValueAtIndex[3])
        v4 = v7;
      else
        v4 = 0xFFFFFFFFLL;
    }
  }
  return v4;
}

uint64_t comparePriorityAtIndices(uint64_t result, CFIndex a2, CFIndex a3)
{
  uint64_t v3;
  uint64_t v6;

  if (result)
  {
    v3 = result;
    if (!*(_QWORD *)(result + 48))
      return 0;
    if (!a2)
      return -1;
    if (!a3 || CFArrayGetCount(*(CFArrayRef *)(result + 64)) <= a2)
      return 1;
    if (CFArrayGetCount(*(CFArrayRef *)(v3 + 64)) <= a3)
      return -1;
    result = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 64), a2);
    if (result)
    {
      v6 = result;
      result = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)(v3 + 64), a3);
      if (result)
        return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(v3 + 48))(*(_QWORD *)(v6 + 16), *(_QWORD *)(result + 16), *(_QWORD *)(v3 + 56));
    }
  }
  return result;
}

uint64_t FigPriorityQueueInsertItemAndCreateUpdateToken(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  CFAllocatorRef v6;
  uint64_t Instance;
  _QWORD *v8;
  uint64_t (*v9)(CFAllocatorRef, uint64_t);
  CFIndex Count;
  uint64_t v12;

  if (!a1)
  {
    v12 = 4294954306;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v6 = CFGetAllocator((CFTypeRef)a1);
  FigThreadRunOnce(&FigPriorityQueueNodeGetTypeID_sRegisterFigPriorityQueueNodeOnce, (void (*)(void))registerFigPriorityQueueNode);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v12 = 4294954305;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v8 = (_QWORD *)Instance;
  *(_QWORD *)(Instance + 32) = a1;
  v9 = *(uint64_t (**)(CFAllocatorRef, uint64_t))(a1 + 16);
  if (v9)
    a2 = v9(v6, a2);
  v8[2] = a2;
  v8[5] = *(_QWORD *)(a1 + 24);
  v8[6] = v6;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 64), v8);
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  v8[3] = Count - 1;
  siftUp(a1, Count - 1);
  if (a3)
    *a3 = v8;
  else
    CFRelease(v8);
  return 0;
}

void siftUp(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  BOOL v4;

  if (a2 >= 2)
  {
    v2 = a2;
    do
    {
      if (comparePriorityAtIndices(a1, v2, v2 >> 1) != -1)
        break;
      swapIndices(*(const __CFArray **)(a1 + 64), v2, v2 >> 1);
      v4 = v2 > 3;
      v2 >>= 1;
    }
    while (v4);
  }
}

uint64_t FigPriorityQueueInsertItem(uint64_t a1, uint64_t a2)
{
  return FigPriorityQueueInsertItemAndCreateUpdateToken(a1, a2, 0);
}

uint64_t FigPriorityQueueGetItem(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;

  if (a1)
  {
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 64)) < 2)
    {
      v4 = 0;
      if (!a2)
        return 0;
    }
    else
    {
      v4 = *((_QWORD *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), 1) + 2);
      if (!a2)
        return 0;
    }
    *a2 = v4;
    return 0;
  }
  return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
}

uint64_t FigPriorityQueueRemoveItem(uint64_t a1)
{
  _QWORD *ValueAtIndex;
  _QWORD *v3;
  void (*v4)(CFAllocatorRef, _QWORD);
  CFAllocatorRef v5;
  const __CFArray *v6;
  CFIndex Count;
  const __CFArray *v8;
  CFIndex v9;

  if (a1)
  {
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 64)) == 1)
      return 0;
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 64), 1);
    if (ValueAtIndex)
    {
      v3 = ValueAtIndex;
      v4 = *(void (**)(CFAllocatorRef, _QWORD))(a1 + 24);
      if (v4)
      {
        v5 = CFGetAllocator((CFTypeRef)a1);
        v4(v5, v3[2]);
      }
      v3[2] = 0;
      v3[3] = 0;
      v3[4] = 0;
      v6 = *(const __CFArray **)(a1 + 64);
      Count = CFArrayGetCount(v6);
      swapIndices(v6, 1, Count - 1);
      v8 = *(const __CFArray **)(a1 + 64);
      v9 = CFArrayGetCount(v8);
      CFArrayRemoveValueAtIndex(v8, v9 - 1);
      siftDown(a1, 1);
      return 0;
    }
  }
  return FigSignalErrorAt(4294954306, 0, 0, 0, 0, 0, 0);
}

void swapIndices(const __CFArray *a1, CFIndex a2, CFIndex a3)
{
  _QWORD *ValueAtIndex;
  _QWORD *v7;

  ValueAtIndex = CFArrayGetValueAtIndex(a1, a2);
  v7 = CFArrayGetValueAtIndex(a1, a3);
  ValueAtIndex[3] = a3;
  v7[3] = a2;
  CFArrayExchangeValuesAtIndices(a1, a2, a3);
}

void siftDown(uint64_t a1, CFIndex a2)
{
  CFIndex Count;
  CFIndex v5;
  uint64_t v6;
  CFIndex v7;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 64));
  v5 = 2 * a2;
  if (2 * a2 < Count)
  {
    v6 = Count;
    do
    {
      v7 = v5 | 1;
      if (comparePriorityAtIndices(a1, v5, v5 | 1) != 1)
        v7 = v5;
      if (comparePriorityAtIndices(a1, v7, a2) != -1)
        break;
      swapIndices(*(const __CFArray **)(a1 + 64), a2, v7);
      v5 = 2 * v7;
      a2 = v7;
    }
    while (2 * v7 < v6);
  }
}

uint64_t FigPriorityQueueCopyAndRemoveItem(_QWORD *a1, _QWORD *a2)
{
  uint64_t result;
  void (*v5)(CFAllocatorRef, _QWORD);
  CFAllocatorRef v6;

  result = FigPriorityQueueGetItem((uint64_t)a1, a2);
  if (!(_DWORD)result)
  {
    v5 = (void (*)(CFAllocatorRef, _QWORD))a1[2];
    if (v5)
    {
      v6 = CFGetAllocator(a1);
      v5(v6, *a2);
    }
    return FigPriorityQueueRemoveItem((uint64_t)a1);
  }
  return result;
}

CFIndex FigPriorityQueueGetCount(uint64_t a1)
{
  return CFArrayGetCount(*(CFArrayRef *)(a1 + 64)) - 1;
}

uint64_t FigPriorityQueueTokenUpdatePriority(_QWORD *a1)
{
  CFTypeID v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!a1)
    return 4294954306;
  v2 = CFGetTypeID(a1);
  FigThreadRunOnce(&FigPriorityQueueNodeGetTypeID_sRegisterFigPriorityQueueNodeOnce, (void (*)(void))registerFigPriorityQueueNode);
  if (v2 != sFigPriorityQueueNodeID)
    return 4294954306;
  v3 = a1[4];
  if (!v3 || !*(_QWORD *)(v3 + 48))
    return 4294954306;
  v4 = a1[3];
  if (v4 >= 0)
    v5 = v4;
  else
    v5 = v4 + 1;
  if (comparePriorityAtIndices(v3, v4, v5 >> 1) == -1)
    siftUp(v3, v4);
  else
    siftDown(v3, v4);
  return 0;
}

double figPriorityQueueInit(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 64) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void figPriorityQueueFinalize(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 64);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 64) = 0;
  }
}

__CFString *figPriorityQueueCopyFormattingDesc(const void *a1, const __CFDictionary *a2)
{
  const __CFAllocator *v4;
  __CFString *Mutable;
  CFAllocatorRef v6;

  if (!a1)
    return 0;
  v4 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v4, 0);
  if (Mutable)
  {
    v6 = CFGetAllocator(a1);
    CFStringAppendFormat(Mutable, a2, CFSTR("<FigPriorityQueue %p [%p]>{}"), a1, v6);
  }
  return Mutable;
}

__CFString *figPriorityQueueCopyDebugDesc(const void *a1)
{
  return figPriorityQueueCopyFormattingDesc(a1, 0);
}

uint64_t registerFigPriorityQueueNode()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigPriorityQueueNodeID = result;
  return result;
}

double figPriorityQueueNodeInit(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

_QWORD *figPriorityQueueNodeFinalize(_QWORD *result)
{
  _QWORD *v1;
  uint64_t (*v2)(_QWORD);

  v1 = result;
  if (result[2])
  {
    v2 = (uint64_t (*)(_QWORD))result[5];
    if (v2)
      result = (_QWORD *)v2(result[6]);
  }
  v1[2] = 0;
  v1[4] = 0;
  return result;
}

__CFString *figPriorityQueueNodeCopyFormattingDesc(_QWORD *a1, const __CFDictionary *a2)
{
  const __CFAllocator *v4;
  __CFString *Mutable;
  CFAllocatorRef v6;
  uint64_t (*v7)(_QWORD);
  const __CFString *v8;
  const __CFString *v9;

  v4 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v4, 0);
  v6 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, a2, CFSTR("<FigPriorityQueueNode %p [%p]>{\n"), a1, v6);
  v7 = *(uint64_t (**)(_QWORD))(a1[4] + 32);
  if (v7 && (v8 = (const __CFString *)v7(a1[2])) != 0)
  {
    v9 = v8;
    CFStringAppend(Mutable, v8);
    CFStringAppendFormat(Mutable, a2, CFSTR("\n}\n"));
    CFRelease(v9);
  }
  else
  {
    CFStringAppendFormat(Mutable, a2, CFSTR("\n}\n"));
  }
  return Mutable;
}

__CFString *figPriorityQueueNodeCopyDebugDesc(_QWORD *a1)
{
  return figPriorityQueueNodeCopyFormattingDesc(a1, 0);
}

uint64_t FigCaptionRubyReserveGetTypeID()
{
  FigThreadRunOnce(&sRegisterFigCaptionRubyReserveTypeOnce, (void (*)(void))RegisterFigCaptionRubyReserveType);
  return sFigCaptionRubyReserveID;
}

uint64_t RegisterFigCaptionRubyReserveType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigCaptionRubyReserveID = result;
  return result;
}

uint64_t FigCaptionRubyReserveGetRubyPosition(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t FigCaptionRubyReserveGetLength(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t FigCaptionRubyReserveCreate(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t Instance;
  _QWORD *v10;
  CFTypeRef v11;

  if (!a5)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  FigThreadRunOnce(&sRegisterFigCaptionRubyReserveTypeOnce, (void (*)(void))RegisterFigCaptionRubyReserveType);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v10 = (_QWORD *)Instance;
    if (a2)
      v11 = CFRetain(a2);
    else
      v11 = 0;
    v10[2] = v11;
    v10[3] = a3;
    v10[4] = a4;
    *a5 = v10;
  }
  else
  {
    FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigCaptionRubyReserveCreateNone(uint64_t a1, _QWORD *a2)
{
  return FigCaptionRubyReserveCreate(a1, 0, 0, 0, a2);
}

double fcrr_Init(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void fcrr_Finalize(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 16);
  if (v1)
    CFRelease(v1);
}

BOOL fcrr_Equal(_BOOL8 result, uint64_t a2)
{
  uint64_t v3;
  CFTypeID v4;
  CFTypeID v5;

  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID((CFTypeRef)result);
    FigThreadRunOnce(&sRegisterFigCaptionRubyReserveTypeOnce, (void (*)(void))RegisterFigCaptionRubyReserveType);
    result = 0;
    if (a2)
    {
      if (v4 == sFigCaptionRubyReserveID)
      {
        v5 = CFGetTypeID((CFTypeRef)a2);
        FigThreadRunOnce(&sRegisterFigCaptionRubyReserveTypeOnce, (void (*)(void))RegisterFigCaptionRubyReserveType);
        if (v5 == sFigCaptionRubyReserveID)
        {
          result = FigGeometryDimensionEqualToDimension(*(_QWORD *)(v3 + 24), *(_QWORD *)(v3 + 32), *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32));
          if (result)
            return FigCFEqual(*(CFTypeRef *)(v3 + 16), *(CFTypeRef *)(a2 + 16)) != 0;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

CFHashCode fcrr_Hash(_QWORD *a1)
{
  CFTypeID v2;
  const void *v3;

  if (a1
    && (v2 = CFGetTypeID(a1),
        FigThreadRunOnce(&sRegisterFigCaptionRubyReserveTypeOnce, (void (*)(void))RegisterFigCaptionRubyReserveType),
        v2 == sFigCaptionRubyReserveID)
    && (v3 = (const void *)a1[2]) != 0)
  {
    return CFHash(v3);
  }
  else
  {
    return 0;
  }
}

CFStringRef fcrr_CopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionRubyReserve %p]"), a1);
}

CFStringRef fcrr_CopyDebugDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCaptionRubyReserve %p]"), a1);
}

uint64_t FigXPCEndpointMessengerServerAssociateNeighborFigEndpointMessenger(xpc_connection_t connection, const void *a2, _QWORD *a3)
{
  return FigXPCServerAssociateObjectWithNeighborProcess(gEndpointMessengerServer, connection, a2, 0, 0, 0, a3);
}

uint64_t FigEndpointMessengerStartServer()
{
  _OWORD v1[3];

  v1[0] = xmmword_1E28DE698;
  memset(&v1[1], 0, 32);
  return FigXPCServerStart((uint64_t)"com.apple.coremedia.endpointmessenger.xpc", (uint64_t)v1, 0, &gEndpointMessengerServer);
}

uint64_t HandleEndpointMessengerRemoteMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t OpCode;
  const void *uint64;
  uint64_t v8;
  CFTypeID v9;
  CFTypeRef v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFTypeRef v15;
  uint64_t (*v16)(CFTypeRef, uint64_t, CFTypeRef);
  CFTypeRef v17;
  uint64_t (*v18)(CFTypeRef, CFTypeRef, _QWORD, CFTypeRef *);
  uint64_t v19;
  CFTypeRef v20;
  uint64_t (*v21)(CFTypeRef, CFTypeRef *);
  int v23;
  CFTypeRef v24;
  CFTypeRef cf[6];

  v23 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v23);
  if ((_DWORD)OpCode)
    return OpCode;
  uint64 = (const void *)xpc_dictionary_get_uint64(a2, ".objectID");
  cf[0] = 0;
  v8 = FigXPCServerLookupAndRetainAssociatedObject(a1, (uint64_t)uint64, cf, 0);
  if (!(_DWORD)v8)
  {
    if (cf[0])
    {
      v9 = CFGetTypeID(cf[0]);
      if (v9 == FigEndpointMessengerGetTypeID())
      {
        v10 = cf[0];
        goto LABEL_6;
      }
    }
    v8 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  }
  v11 = v8;
  if (cf[0])
    CFRelease(cf[0]);
  if ((_DWORD)v11)
    return v11;
  v10 = 0;
LABEL_6:
  v11 = 4294966630;
  if (v23 > 1936221291)
  {
    if (v23 == 1936221292)
    {
      cf[0] = (CFTypeRef)MEMORY[0x1E0C809B0];
      cf[1] = (CFTypeRef)0x40000000;
      cf[2] = __HandleSetHandlerMessage_block_invoke;
      cf[3] = &__block_descriptor_tmp_38;
      cf[4] = uint64;
      cf[5] = a1;
      v21 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10) + 16)
                                                             + 8);
      if (v21)
      {
        v12 = v21(v10, cf);
LABEL_24:
        v11 = v12;
        if (!v10)
          return v11;
        goto LABEL_30;
      }
      v11 = 4294954514;
      if (!v10)
        return v11;
LABEL_30:
      CFRelease(v10);
      return v11;
    }
    if (v23 != 1936552807)
      goto LABEL_29;
    cf[0] = 0;
    v13 = xpc_dictionary_get_uint64(a2, "MessageType");
    v14 = FigXPCMessageCopyCFObject(a2, "Payload", (__CFDictionary **)cf);
    if (!(_DWORD)v14)
    {
      v15 = cf[0];
      v16 = *(uint64_t (**)(CFTypeRef, uint64_t, CFTypeRef))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10)
                                                                                 + 16)
                                                                     + 16);
      if (!v16)
        goto LABEL_26;
      v14 = v16(v10, v13, v15);
    }
LABEL_15:
    v11 = v14;
    goto LABEL_27;
  }
  if (v23 == 778268793)
  {
    v24 = 0;
    cf[0] = 0;
    v14 = FigXPCMessageCopyCFString(a2, ".PropertyName", cf);
    if (!(_DWORD)v14)
    {
      v17 = cf[0];
      if (cf[0])
      {
        v18 = *(uint64_t (**)(CFTypeRef, CFTypeRef, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v10)
                                                                                              + 8)
                                                                                  + 48);
        if (v18)
        {
          v19 = v18(v10, v17, *MEMORY[0x1E0C9AE00], &v24);
          v20 = v24;
          if (!(_DWORD)v19)
          {
            v11 = FigXPCMessageSetCFObject(a3, ".Value", v24);
            v20 = v24;
            if (!v24)
              goto LABEL_27;
            goto LABEL_21;
          }
          v11 = v19;
          if (v24)
LABEL_21:
            CFRelease(v20);
LABEL_27:
          if (cf[0])
            CFRelease(cf[0]);
          goto LABEL_29;
        }
LABEL_26:
        v11 = 4294954514;
        goto LABEL_27;
      }
      v14 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
    }
    goto LABEL_15;
  }
  if (v23 == 779314548)
  {
    v12 = FigXPCHandleStdSetPropertyMessage((uint64_t)v10, a2);
    goto LABEL_24;
  }
LABEL_29:
  if (v10)
    goto LABEL_30;
  return v11;
}

uint64_t FigCustomURLLoaderServerCopyLoaderForID(void *a1, _QWORD *a2)
{
  uint64_t result;

  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (!a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  result = FigXPCServerRetainNeighborObjectFromID((uint64_t *)gFigCustomURLLoaderServer, a1, a2);
  if (!*a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  return result;
}

uint64_t FigCustomURLLoaderServerAssociateNeighbor(_xpc_connection_s *a1, const void *a2, _QWORD *a3)
{
  uint64_t *v6;
  uint64_t v7;
  CFTypeRef *v8;
  uint64_t v10;

  v10 = 0;
  v6 = (uint64_t *)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
  v6[1] = FigOSTransactionCreate("FigCustomURLLoader", 0, 0, 0);
  FigCFWeakReferenceTableCreate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], 1, v6);
  v7 = FigXPCServerAssociateObjectWithNeighborProcess(gFigCustomURLLoaderServer, a1, a2, (uint64_t)v6, (uint64_t)figCustomURLLoaderServer_disposeServerCompanion, 0, &v10);
  if ((_DWORD)v7)
    v8 = (CFTypeRef *)v6;
  else
    v8 = 0;
  if (!(_DWORD)v7)
  {
    *a3 = v10;
    if (!v8)
      return v7;
    goto LABEL_6;
  }
  if (v8)
LABEL_6:
    figCustomURLLoaderServer_disposeServerCompanion(v8);
  return v7;
}

void figCustomURLLoaderServer_disposeServerCompanion(CFTypeRef *a1)
{
  void *v2;

  v2 = (void *)a1[1];
  if (v2)
  {
    os_release(v2);
    a1[1] = 0;
  }
  if (*a1)
    CFRelease(*a1);
  free(a1);
}

uint64_t FigCustomURLLoaderServerStart()
{
  uint64_t v0;
  _BOOL4 IsMediaplaybackd;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v4;
  const char *v5;
  uint64_t v6;
  _OWORD v7[3];

  v7[0] = xmmword_1E28DE730;
  v7[1] = *(_OWORD *)&off_1E28DE740;
  v7[2] = xmmword_1E28DE750;
  if (FigServer_IsMediaparserd())
  {
    v0 = 4294951145;
    return FigSignalErrorAt(v0, 0, 0, 0, 0, 0, 0);
  }
  IsMediaplaybackd = FigServer_IsMediaplaybackd();
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    v0 = 4294954510;
    return FigSignalErrorAt(v0, 0, 0, 0, 0, 0, 0);
  }
  v4 = Mutable;
  if (IsMediaplaybackd)
    v5 = "com.apple.coremedia.mediaplaybackd.customurlloader.xpc";
  else
    v5 = "com.apple.coremedia.customurlloader.xpc";
  v6 = FigXPCServerStart((uint64_t)v5, (uint64_t)v7, (uint64_t)v4, &gFigCustomURLLoaderServer);
  CFRelease(v4);
  return v6;
}

uint64_t figCustomURLLoaderServer_handleMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t OpCode;
  CFTypeRef ConnectionRefcon;
  xpc_object_t value;
  uint64_t v9;
  uint64_t v10;
  uint64_t uint64;
  uint64_t v12;
  CFTypeID v13;
  CFTypeRef v14;
  uint64_t *v15;
  const void *v16;
  int64_t int64;
  uint64_t v18;
  uint64_t v19;
  uint64_t (*v20)(CFTypeRef, uint64_t, int64_t);
  uint64_t v21;
  CFTypeRef v22;
  uint64_t *v23;
  void *v24;
  void *v25;
  uint64_t v26;
  id v27;
  id v28;
  uint64_t (*v29)(CFTypeRef, id, id, uint64_t);
  uint64_t *v31;
  CFTypeRef cf;
  int v33;
  CFTypeRef v34;
  uint64_t v35;

  v33 = 0;
  v31 = 0;
  cf = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v33);
  if ((_DWORD)OpCode)
    goto LABEL_51;
  ConnectionRefcon = (CFTypeRef)FigXPCServerGetConnectionRefcon(a1);
  if (ConnectionRefcon)
  {
LABEL_7:
    CFRetain(ConnectionRefcon);
    goto LABEL_8;
  }
  xpc_connection_get_pid(a1);
  v35 = 0;
  value = xpc_dictionary_get_value(a2, "CustomURLLoader_Endpoint");
  if (value)
  {
    v9 = (uint64_t)value;
    if (MEMORY[0x193FFCDCC]() == MEMORY[0x1E0C81308])
    {
      v10 = FigCustomURLHandlerRemoteClientCreateWithXPCEndpoint(v9, (uint64_t)&v35);
      if (!(_DWORD)v10)
      {
        ConnectionRefcon = (CFTypeRef)v35;
        FigXPCServerSetConnectionRefcon(a1, v35, (uint64_t)figCustomURLLoaderServer_connectionRefconDestructor);
        if (!ConnectionRefcon)
          goto LABEL_8;
        goto LABEL_7;
      }
      goto LABEL_50;
    }
  }
  v10 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)v10)
  {
LABEL_50:
    OpCode = FigSignalErrorAt(v10, 0, 0, 0, 0, 0, 0);
LABEL_51:
    v21 = OpCode;
    goto LABEL_44;
  }
  FigXPCServerSetConnectionRefcon(a1, 0, (uint64_t)figCustomURLLoaderServer_connectionRefconDestructor);
  ConnectionRefcon = 0;
LABEL_8:
  uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  v12 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, &v31);
  if ((_DWORD)v12)
  {
LABEL_26:
    v21 = v12;
    goto LABEL_42;
  }
  if (!cf || (v13 = CFGetTypeID(cf), v13 != FigCustomURLLoaderGetCFTypeID()))
  {
    v12 = FigSignalErrorAt(4294949916, 0, 0, 0, 0, 0, 0);
    goto LABEL_26;
  }
  v14 = cf;
  if (v33 == 779314548)
  {
    v12 = FigXPCHandleStdSetPropertyMessage((uint64_t)cf, a2);
    goto LABEL_26;
  }
  if (v33 != 1668043858)
  {
    if (v33 != 1668039497)
    {
      v21 = 0;
      goto LABEL_42;
    }
    v15 = v31;
    v34 = 0;
    v35 = 0;
    v16 = (const void *)xpc_dictionary_get_uint64(a2, "CustomURLLoader_HandlerID");
    int64 = xpc_dictionary_get_int64(a2, "CustomURLLoader_Priority");
    v18 = FigXPCMessageCopyCFDictionary(a2, "CustomURLLoader_CreateOptions", &v34);
    if (!(_DWORD)v18)
    {
      v18 = FigCustomURLHandlerRemoteCreateWithID(v16, ConnectionRefcon, (uint64_t)v34, (CFTypeRef *)&v35);
      if (!(_DWORD)v18)
      {
        v19 = v35;
        v20 = *(uint64_t (**)(CFTypeRef, uint64_t, int64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v14)
                                                                                + 16)
                                                                    + 8);
        if (!v20)
        {
          v21 = 4294954514;
          if (!a3)
          {
LABEL_21:
            if (v34)
              CFRelease(v34);
            v22 = (CFTypeRef)v35;
            if (!v35)
              goto LABEL_42;
            goto LABEL_41;
          }
LABEL_20:
          xpc_dictionary_set_int64(a3, ".ErrorReturn", (int)v21);
          goto LABEL_21;
        }
        v18 = v20(v14, v19, int64);
        if (!(_DWORD)v18)
          v18 = FigCFWeakReferenceTableAddValueAssociatedWithKey(*v15, v35, (uint64_t)v16);
      }
    }
    v21 = v18;
    if (!a3)
      goto LABEL_21;
    goto LABEL_20;
  }
  v23 = v31;
  v24 = (void *)xpc_dictionary_get_uint64(a2, "CustomURLLoader_FromHandlerID");
  v25 = (void *)xpc_dictionary_get_uint64(a2, "CustomURLLoader_ToHandlerID");
  v26 = xpc_dictionary_get_uint64(a2, "CustomURLLoader_RequestID");
  v27 = FigCFWeakReferenceTableCopyValue(*v23, v24);
  if (!v27)
  {
    v28 = 0;
LABEL_53:
    v21 = 0;
    if (!a3)
      goto LABEL_37;
    goto LABEL_36;
  }
  v28 = FigCFWeakReferenceTableCopyValue(*v23, v25);
  if (!v28)
    goto LABEL_53;
  v29 = *(uint64_t (**)(CFTypeRef, id, id, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v14) + 16)
                                                              + 48);
  if (v29)
  {
    v21 = v29(v14, v27, v28, v26);
    if (!a3)
      goto LABEL_37;
    goto LABEL_36;
  }
  v21 = 4294954514;
  if (a3)
LABEL_36:
    xpc_dictionary_set_int64(a3, ".ErrorReturn", (int)v21);
LABEL_37:
  if (v27)
    CFRelease(v27);
  if (!v28)
    goto LABEL_42;
  v22 = v28;
LABEL_41:
  CFRelease(v22);
LABEL_42:
  if (ConnectionRefcon)
    CFRelease(ConnectionRefcon);
LABEL_44:
  if (cf)
    CFRelease(cf);
  return v21;
}

uint64_t figCustomURLLoaderServer_handleMessageNoReply(_xpc_connection_s *a1, void *a2)
{
  uint64_t OpCode;
  uint64_t uint64;
  CFTypeID v6;
  uint64_t v7;
  uint64_t v9;
  CFTypeRef cf;
  int v11;

  v11 = 0;
  v9 = 0;
  cf = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v11);
  if ((_DWORD)OpCode)
    goto LABEL_7;
  uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  OpCode = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, &v9);
  if ((_DWORD)OpCode)
    goto LABEL_7;
  if (!cf || (v6 = CFGetTypeID(cf), v6 != FigCustomURLLoaderGetCFTypeID()))
  {
    OpCode = FigSignalErrorAt(4294949916, 0, 0, 0, 0, 0, 0);
    goto LABEL_7;
  }
  if (v11 == 1668039785)
  {
    OpCode = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
LABEL_7:
    v7 = OpCode;
    goto LABEL_9;
  }
  v7 = 0;
LABEL_9:
  if (cf)
    CFRelease(cf);
  return v7;
}

uint64_t FigAtomWriterInitWithBlockBuffer(OpaqueCMBlockBuffer *a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_QWORD *)a2 = a1;
  *(_QWORD *)(a2 + 24) = CMBlockBufferGetDataLength(a1);
  return 0;
}

uint64_t FigAtomWriterInitWithByteStream(uint64_t a1, uint64_t a2)
{
  uint64_t CMBaseObject;
  uint64_t (*v4)(uint64_t, const __CFString *, _QWORD, CFNumberRef *);
  uint64_t v5;
  uint64_t v6;
  CFNumberRef number;

  *(_QWORD *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_QWORD *)(a2 + 8) = a1;
  number = 0;
  CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  v4 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, CFNumberRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                                + 8)
                                                                                    + 48);
  if (v4)
  {
    v5 = v4(CMBaseObject, CFSTR("FBS_EntireLength"), *MEMORY[0x1E0C9AE00], &number);
    if (!(_DWORD)v5)
    {
      if (CFNumberGetValue(number, kCFNumberSInt64Type, (void *)(a2 + 24)))
      {
        v6 = 0;
        goto LABEL_8;
      }
      v5 = FigSignalErrorAt(0xFFFFFFFFLL, 0, 0, 0, 0, 0, 0);
    }
    v6 = v5;
  }
  else
  {
    v6 = 4294954514;
  }
LABEL_8:
  if (number)
    CFRelease(number);
  return v6;
}

uint64_t FigAtomWriterInitWithParent(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_QWORD *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  v2 = *(_QWORD *)(a1 + 40) + *(_QWORD *)(a1 + 24);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_QWORD *)(a2 + 16) = a1;
  *(_QWORD *)(a2 + 24) = v2;
  return 0;
}

uint64_t FigAtomWriterBeginAtom(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t WritableForBlockBuffer;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  _DWORD v11[2];

  if (*(_BYTE *)(a1 + 49))
  {
    v8 = FigSignalErrorAt(4294954725, 0, 0, 0, 0, 0, 0);
    if (!(_DWORD)v8)
      return v8;
LABEL_14:
    FigAtomWriterReleaseByteStreamIfNecessary((_QWORD *)a1);
    return v8;
  }
  if (!*(_QWORD *)(a1 + 16))
  {
    if (*(_QWORD *)a1)
    {
      WritableForBlockBuffer = CMByteStreamCreateWritableForBlockBuffer((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(void **)a1, 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, (CFTypeRef *)(a1 + 8));
      if ((_DWORD)WritableForBlockBuffer)
        goto LABEL_12;
    }
  }
  v11[0] = (a3 != 0) << 24;
  v11[1] = bswap32(a2);
  WritableForBlockBuffer = CMByteStreamAppend(*(_QWORD *)(a1 + 8), 8, (uint64_t)v11, 0);
  if ((_DWORD)WritableForBlockBuffer)
    goto LABEL_12;
  *(_QWORD *)(a1 + 40) = 8;
  if (!a3)
  {
    v7 = 8;
    goto LABEL_10;
  }
  v10 = 0;
  WritableForBlockBuffer = CMByteStreamAppend(*(_QWORD *)(a1 + 8), 8, (uint64_t)&v10, 0);
  if ((_DWORD)WritableForBlockBuffer)
  {
LABEL_12:
    v8 = WritableForBlockBuffer;
    goto LABEL_14;
  }
  v7 = *(_QWORD *)(a1 + 40) + 8;
  *(_QWORD *)(a1 + 40) = v7;
LABEL_10:
  v8 = 0;
  *(_QWORD *)(a1 + 32) = v7;
  *(_BYTE *)(a1 + 48) = a3;
  *(_BYTE *)(a1 + 49) = 1;
  return v8;
}

void FigAtomWriterReleaseByteStreamIfNecessary(_QWORD *a1)
{
  const void *v2;

  if (!a1[2] && *a1)
  {
    v2 = (const void *)a1[1];
    if (v2)
    {
      CFRelease(v2);
      a1[1] = 0;
    }
  }
}

uint64_t FigAtomWriterBeginUUIDAtom(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v5 = FigAtomWriterBeginAtom(a1, 0x75756964u, a3);
  if ((_DWORD)v5)
    return v5;
  v6 = CMByteStreamAppend(*(_QWORD *)(a1 + 8), 16, a2, 0);
  if ((_DWORD)v6)
  {
    FigAtomWriterReleaseByteStreamIfNecessary((_QWORD *)a1);
    *(_BYTE *)(a1 + 49) = 0;
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 40) + 16;
    *(_QWORD *)(a1 + 32) = v7;
    *(_QWORD *)(a1 + 40) = v7;
  }
  return v6;
}

uint64_t FigAtomWriterAppendVersionAndFlags(uint64_t a1, unsigned __int8 a2, int a3)
{
  uint64_t result;
  uint64_t v5;
  unsigned int v6;

  if (!*(_BYTE *)(a1 + 49))
    return FigSignalErrorAt(4294954726, 0, 0, 0, 0, 0, 0);
  v6 = bswap32(a3 & 0xFFFFFF | (a2 << 24));
  result = CMByteStreamAppend(*(_QWORD *)(a1 + 8), 4, (uint64_t)&v6, 0);
  if (!(_DWORD)result)
  {
    v5 = *(_QWORD *)(a1 + 40) + 4;
    *(_QWORD *)(a1 + 32) = v5;
    *(_QWORD *)(a1 + 40) = v5;
  }
  return result;
}

uint64_t FigAtomWriterAppendData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (!*(_BYTE *)(a1 + 49))
    return FigSignalErrorAt(4294954726, 0, 0, 0, 0, 0, 0);
  if (!a3)
    return 0;
  result = CMByteStreamAppend(*(_QWORD *)(a1 + 8), a3, a2, 0);
  if (!(_DWORD)result)
    *(_QWORD *)(a1 + 40) += a3;
  return result;
}

uint64_t FigAtomWriterAppendBlockBufferData(uint64_t a1, OpaqueCMBlockBuffer *a2, size_t a3, size_t dataLength)
{
  OpaqueCMBlockBuffer *v6;
  uint64_t result;

  if (!*(_BYTE *)(a1 + 49))
    return FigSignalErrorAt(4294954726, 0, 0, 0, 0, 0, 0);
  if (!dataLength)
    return 0;
  v6 = *(OpaqueCMBlockBuffer **)a1;
  if (v6)
  {
    result = CMBlockBufferAppendBufferReference(v6, a2, a3, dataLength, 0);
    if ((_DWORD)result)
      return result;
  }
  else
  {
    result = CMByteStreamAppendBlockBuffer(*(_QWORD *)(a1 + 8));
    if ((_DWORD)result)
      return result;
  }
  result = 0;
  *(_QWORD *)(a1 + 40) += dataLength;
  return result;
}

uint64_t FigAtomWriterEndAtom(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, uint64_t, uint64_t, unint64_t *, _QWORD);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, uint64_t, uint64_t, unsigned int *, _QWORD);
  unsigned int v13;
  unint64_t v14;

  v14 = 0;
  if (!*(_BYTE *)(a1 + 49))
  {
    v8 = 0;
    goto LABEL_16;
  }
  v2 = *(_QWORD *)(a1 + 40);
  v14 = v2;
  if (!*(_BYTE *)(a1 + 48))
  {
    if (v2 >= 0x100000000)
    {
      v6 = FigSignalErrorAt(4294954724, 0, 0, 0, 0, 0, 0);
      goto LABEL_11;
    }
    v13 = bswap32(v2);
    v9 = *(_QWORD *)(a1 + 8);
    v10 = *(_QWORD *)(a1 + 24);
    v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned int *, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(v9)
                                                                                                  + 16)
                                                                                      + 16);
    if (v11)
    {
      v8 = v11(v9, 4, v10, &v13, 0);
      if ((_DWORD)v8)
        goto LABEL_16;
      goto LABEL_5;
    }
LABEL_15:
    v8 = 4294954514;
    goto LABEL_16;
  }
  v14 = bswap64(v2);
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 24);
  v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t *, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(v3) + 16)
                                                                                       + 16);
  if (!v5)
    goto LABEL_15;
  v6 = v5(v3, 8, v4 + 8, &v14, 0);
  if ((_DWORD)v6)
  {
LABEL_11:
    v8 = v6;
    goto LABEL_16;
  }
LABEL_5:
  v7 = *(_QWORD *)(a1 + 16);
  if (v7)
    *(_QWORD *)(v7 + 40) += *(_QWORD *)(a1 + 40);
  v8 = 0;
  *(_QWORD *)(a1 + 24) += *(_QWORD *)(a1 + 40);
LABEL_16:
  FigAtomWriterReleaseByteStreamIfNecessary((_QWORD *)a1);
  *(_BYTE *)(a1 + 49) = 0;
  return v8;
}

uint64_t FigAtomWriterGetAtomGlobalDataOffset(uint64_t a1, _QWORD *a2)
{
  if (!*(_BYTE *)(a1 + 49))
    return FigSignalErrorAt(4294954726, 0, 0, 0, 0, 0, 0);
  *a2 = *(_QWORD *)(a1 + 32) + *(_QWORD *)(a1 + 24);
  return 0;
}

uint64_t FigAtomWriterGetAtomSize(uint64_t a1, _QWORD *a2)
{
  if (!*(_BYTE *)(a1 + 49))
    return FigSignalErrorAt(4294954726, 0, 0, 0, 0, 0, 0);
  *a2 = *(_QWORD *)(a1 + 40);
  return 0;
}

uint64_t FigAtomWriterGetAtomDataSize(uint64_t a1, _QWORD *a2)
{
  if (!*(_BYTE *)(a1 + 49))
    return FigSignalErrorAt(4294954726, 0, 0, 0, 0, 0, 0);
  *a2 = *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32);
  return 0;
}

uint64_t FigByteStreamProviderGetClassID()
{
  FigThreadRunOnce(&FigByteStreamProviderGetClassID_sRegisterFigByteStreamProviderBaseTypeOnce, (void (*)(void))RegisterFigByteStreamProviderBaseType);
  return sFigByteStreamProviderClassID;
}

uint64_t RegisterFigByteStreamProviderBaseType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigByteStreamProviderClassDesc, ClassID, 1, &sFigByteStreamProviderClassID);
}

uint64_t FigByteStreamProviderGetTypeID()
{
  FigThreadRunOnce(&FigByteStreamProviderGetClassID_sRegisterFigByteStreamProviderBaseTypeOnce, (void (*)(void))RegisterFigByteStreamProviderBaseType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigByteStreamProviderClassID);
}

uint64_t FigGetBaseByteStreamProvider()
{
  FigThreadRunOnce(&FigGetBaseByteStreamProvider_sCreateBaseByteStreamProviderOnce, (void (*)(void))createBaseByteStreamProvider);
  return sFigBaseByteStreamProvider;
}

CFTypeRef createBaseByteStreamProvider()
{
  uint64_t v0;
  CFTypeRef result;
  uint64_t DerivedStorage;

  v0 = *MEMORY[0x1E0C9AE00];
  FigThreadRunOnce(&FigByteStreamProviderGetClassID_sRegisterFigByteStreamProviderBaseTypeOnce, (void (*)(void))RegisterFigByteStreamProviderBaseType);
  result = (CFTypeRef)CMDerivedObjectCreate(v0, (uint64_t)&kBaseByteStreamProvider_VTable, (_QWORD *)sFigByteStreamProviderClassID, &sFigBaseByteStreamProvider);
  if (!(_DWORD)result)
  {
    DerivedStorage = CMBaseObjectGetDerivedStorage(sFigBaseByteStreamProvider);
    result = (CFTypeRef)FigGetDefaultManagedFilePool();
    *(_QWORD *)(DerivedStorage + 8) = result;
    if (result)
      return CFRetain(result);
  }
  return result;
}

uint64_t FigByteStreamProviderCreateForBaseURLWithSecurityOptions(int a1, CFTypeRef cf, const void *a3, int a4, CFTypeRef *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t DerivedStorage;
  const void *v13;

  if (!cf || !a3 || !a5)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (a4)
  {
    v13 = 0;
    v9 = *MEMORY[0x1E0C9AE00];
    FigThreadRunOnce(&FigByteStreamProviderGetClassID_sRegisterFigByteStreamProviderBaseTypeOnce, (void (*)(void))RegisterFigByteStreamProviderBaseType);
    v10 = CMDerivedObjectCreate(v9, (uint64_t)&kSecurityPolicyByteStreamProvider_VTable, (_QWORD *)sFigByteStreamProviderClassID, &v13);
    if (!(_DWORD)v10)
    {
      DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)v13);
      *(_QWORD *)DerivedStorage = CFRetain(a3);
      *(_DWORD *)(DerivedStorage + 8) = a4;
      *(_QWORD *)(DerivedStorage + 16) = CFRetain(cf);
      *a5 = v13;
    }
  }
  else
  {
    v10 = 0;
    *a5 = CFRetain(cf);
  }
  return v10;
}

CFStringRef FigByteStreamProviderCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigByteStreamProvider %p]"), a1);
}

CFTypeRef baseByteStreamProvider_CopyDebugDescription()
{
  return CFRetain(CFSTR("[Base ByteStreamProvider]"));
}

uint64_t baseByteStreamProvider_CreateByteStreamForURL(uint64_t a1, CFURLRef relativeURL, unsigned int a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  CFURLRef v10;
  CFURLRef v11;
  uint64_t DerivedStorage;
  const void *v13;
  uint64_t ByteStreamForFile;
  uint64_t v15;

  if (!relativeURL)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  if (!a6)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  v10 = CFURLCopyAbsoluteURL(relativeURL);
  if (!v10)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  v11 = v10;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if ((a3 & 0xFFFFFFBF) != 0 || (v13 = *(const void **)(DerivedStorage + 8)) == 0)
    ByteStreamForFile = CMByteStreamCreateForFileURL(a5, v11, a3, a6);
  else
    ByteStreamForFile = FigManagedFilePoolCreateByteStreamForFile(v13, v11, a3, a5, a6);
  v15 = ByteStreamForFile;
  CFRelease(v11);
  return v15;
}

uint64_t baseByteStreamProvider_CreateScheduledIOForURL(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  uint64_t (*v10)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, CFTypeRef *);
  uint64_t v11;
  CFTypeRef v12;
  uint64_t v13;
  CFTypeRef cf;

  cf = 0;
  v10 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(a1) + 16)
                                                                                          + 8);
  if (!v10)
    return 4294954514;
  v11 = v10(a1, a2, 0, a3, a4, &cf);
  v12 = cf;
  if ((_DWORD)v11)
  {
    v13 = v11;
    if (!cf)
      return v13;
    goto LABEL_4;
  }
  v13 = FigScheduledIOCreateForReadingByteStream(a4, cf, a5);
  v12 = cf;
  if (cf)
LABEL_4:
    CFRelease(v12);
  return v13;
}

void securityPolicyByteStreamProvider_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v2;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_QWORD *)DerivedStorage)
  {
    CFRelease(*(CFTypeRef *)DerivedStorage);
    *(_QWORD *)DerivedStorage = 0;
  }
  v2 = *(const void **)(DerivedStorage + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(DerivedStorage + 16) = 0;
  }
}

CFTypeRef securityPolicyByteStreamProvider_CopyDebugDescription()
{
  return CFRetain(CFSTR("[Security Policy ByteStreamProvider]"));
}

uint64_t securityPolicyByteStreamProvider_CreateByteStreamForURL(uint64_t a1, const __CFURL *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t DerivedStorage;
  uint64_t v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t, const __CFURL *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v16;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!a2)
  {
    v16 = 4294954516;
    return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
  }
  v12 = DerivedStorage;
  if (!FigIsReferenceAllowedBySecurityPolicy(*(const __CFURL **)DerivedStorage, a2, *(_DWORD *)(DerivedStorage + 8)))
  {
    v16 = 4294954846;
    return FigSignalErrorAt(v16, 0, 0, 0, 0, 0, 0);
  }
  v13 = *(_QWORD *)(v12 + 16);
  v14 = *(uint64_t (**)(uint64_t, const __CFURL *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v13) + 16)
                                                                                               + 8);
  if (v14)
    return v14(v13, a2, a3, a4, a5, a6);
  else
    return 4294954514;
}

uint64_t securityPolicyByteStreamProvider_CreateScheduledIOForURL(uint64_t a1, const __CFURL *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, const __CFURL *, uint64_t, uint64_t, uint64_t);
  uint64_t v14;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!a2)
  {
    v14 = 4294954516;
    return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  }
  v10 = DerivedStorage;
  if (!FigIsReferenceAllowedBySecurityPolicy(*(const __CFURL **)DerivedStorage, a2, *(_DWORD *)(DerivedStorage + 8)))
  {
    v14 = 4294954846;
    return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  }
  v11 = *(_QWORD *)(v10 + 16);
  v12 = *(uint64_t (**)(uint64_t, const __CFURL *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v11)
                                                                                                  + 16)
                                                                                      + 16);
  if (v12)
    return v12(v11, a2, a3, a4, a5);
  else
    return 4294954514;
}

_QWORD *FigLogRingBufferCreate(NSObject *a1, size_t a2, uint64_t a3, char a4)
{
  _QWORD *v4;
  uint64_t v5;
  const __CFAllocator *v9;
  _QWORD *v10;
  uint64_t v11;
  int v12;
  void *v13;
  void *v14;
  uint32_t v15;
  int v16;
  __darwin_time_t tv_sec;
  BOOL v18;
  void *v21;
  stat v22;
  char v23[1024];
  uint64_t v24;

  v4 = 0;
  v24 = *MEMORY[0x1E0C80C00];
  v21 = 0;
  if (a3 <= 1)
    v5 = 1;
  else
    v5 = a3;
  if (!a1 || !a2)
    return v4;
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (!qword_1EE1416E0)
  {
    kCustomDictRingBufferCallbacks = (uint64_t)frb_FigRingBufferOutOfBounds;
    qword_1EE1416D8 = (uint64_t)flr_CustomDictGetSize;
    qword_1EE1416E0 = 0x1E10790C8;
  }
  v10 = FigRingBufferCreate(v9, 0, v5 * a2, (uint64_t (**)())&kCustomDictRingBufferCallbacks);
  if (!v10)
    return 0;
  v11 = (uint64_t)v10;
  v12 = FigGzipCreate(&v21);
  v13 = 0;
  v14 = v21;
  if (v12 || !v21)
    goto LABEL_33;
  v13 = malloc_type_calloc(1uLL, a2, 0x89B6F939uLL);
  if (!v13)
  {
    v14 = v21;
    goto LABEL_33;
  }
  v4 = malloc_type_calloc(1uLL, 0x48uLL, 0x10A0040F5008690uLL);
  v14 = v21;
  if (!v4)
  {
LABEL_33:
    if (v14)
      FigGzipDispose(v14);
    if (v13)
      free(v13);
    FigRingBufferRelease(v11);
    return 0;
  }
  v4[4] = v11;
  v4[5] = v14;
  *v4 = v13;
  v4[1] = 0;
  v4[2] = a2;
  *((_BYTE *)v4 + 64) = a4;
  memset(&v22, 0, sizeof(v22));
  v15 = arc4random_uniform(0xAu);
  v16 = 0;
  tv_sec = 0;
  while (1)
  {
    if (!flr_FigLogRingBufferMakeLogFileName("/private/var/mobile/Library/Logs/CrashReporter/mediaserverd_autolog_", 1, v16, v23))
    {
      if ((stat(v23, &v22) & 0x80000000) == 0)
      {
        if (tv_sec)
          v18 = tv_sec <= v22.st_mtimespec.tv_sec;
        else
          v18 = 0;
        if (!v18)
        {
          tv_sec = v22.st_mtimespec.tv_sec;
          v15 = v16;
        }
        goto LABEL_27;
      }
      if (*__error() == 2 || *__error() == 20)
        break;
    }
LABEL_27:
    if (++v16 == 10)
      goto LABEL_30;
  }
  v15 = v16;
LABEL_30:
  *((_DWORD *)v4 + 14) = v15;
  v4[3] = a1;
  dispatch_retain(a1);
  return v4;
}

uint64_t FigLogRingBufferAppend(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;

  if (!a2)
    return 4294950824;
  if (!a1)
    return 4294950825;
  v4 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  if (!v4)
    return 4294950826;
  *v4 = a1;
  v4[1] = a2;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 24), v4, (dispatch_function_t)flr_FigLogRingBufferAppendAsync);
  return 0;
}

void flr_FigLogRingBufferAppendAsync(void *a1)
{
  OpaqueCMBlockBuffer *v2;
  uint64_t v3;
  BOOL v4;
  size_t DataLength;
  size_t v6;
  size_t v7;
  uint64_t v8;
  size_t v9;
  __int128 v10;

  v10 = 0uLL;
  if (a1)
  {
    v3 = *(_QWORD *)a1;
    v2 = (OpaqueCMBlockBuffer *)*((_QWORD *)a1 + 1);
    if (v2)
      v4 = v3 == 0;
    else
      v4 = 1;
    if (v4)
    {
      if (!v2)
        goto LABEL_16;
    }
    else
    {
      DataLength = CMBlockBufferGetDataLength(*((CMBlockBufferRef *)a1 + 1));
      v6 = DataLength;
      v7 = *(_QWORD *)(v3 + 16);
      if (v7 <= DataLength)
      {
        syslog(3, "<<<< FigLogRingBuffer >>>> LogRingBuffer Error: log msg bigger than ring buffer size(%ld).", DataLength);
      }
      else
      {
        v8 = *(_QWORD *)(v3 + 8);
        if (!v8)
        {
          *(CFAbsoluteTime *)(v3 + 48) = CFAbsoluteTimeGetCurrent();
          v8 = *(_QWORD *)(v3 + 8);
          v7 = *(_QWORD *)(v3 + 16);
        }
        v9 = v8 + v6;
        if (v8 + v6 >= v7)
        {
          v10 = *(_OWORD *)v3;
          flr_FigLogRingBufferCommitBuffer(v3, (uint64_t)&v10, 0, *(double *)(v3 + 48));
        }
        if (*(_QWORD *)v3 && !CMBlockBufferCopyDataBytes(v2, 0, v6, (void *)(*(_QWORD *)v3 + *(_QWORD *)(v3 + 8))))
        {
          *(_QWORD *)(v3 + 8) += v6;
          if (v9 >= v7)
            *(CFAbsoluteTime *)(v3 + 48) = CFAbsoluteTimeGetCurrent();
        }
      }
    }
    CFRelease(v2);
LABEL_16:
    free(a1);
  }
}

uint64_t FigLogRingBufferGetEntries(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;

  if (!a1)
    return 4294950825;
  if (!a2)
    return 0;
  v4 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  if (v4)
  {
    *v4 = a1;
    v4[1] = a2;
    dispatch_sync_f(*(dispatch_queue_t *)(a1 + 24), v4, (dispatch_function_t)flr_FigLogRingBufferGetEntries);
    return 0;
  }
  return 4294950826;
}

void flr_FigLogRingBufferGetEntries(uint64_t *a1)
{
  uint64_t v2;
  __CFArray *v3;
  BOOL v4;

  if (a1)
  {
    v2 = *a1;
    v3 = (__CFArray *)a1[1];
    if (v2)
      v4 = v3 == 0;
    else
      v4 = 1;
    if (!v4)
      flr_FigLogRingBufferGetEntriesInternal(v2, v3);
    free(a1);
  }
}

uint64_t FigLogRingBufferWriteLogsAsync(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  if (!a1 || !*(_QWORD *)(a1 + 24))
  {
    v3 = 4294950821;
LABEL_8:
    syslog(3, "<<<< FigLogRingBuffer >>>> failed to write ring buffer to logs err %d", v3);
    return v3;
  }
  v2 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  if (!v2)
  {
    v3 = 4294950826;
    goto LABEL_8;
  }
  *v2 = a1;
  v2[1] = 0;
  dispatch_async_f(*(dispatch_queue_t *)(a1 + 24), v2, (dispatch_function_t)flr_FigLogRingBufferWriteLogsDispatch);
  return 0;
}

void flr_FigLogRingBufferWriteLogsDispatch(uint64_t *a1)
{
  uint64_t v2;
  CFURLRef *v3;
  int LogFileName;
  const __CFAllocator *v5;
  __CFArray *Mutable;
  __CFArray *v7;
  FILE *v8;
  int *v9;
  int v10;
  FILE *v11;
  int v12;
  int v13;
  BOOL v14;
  int v15;
  int v16;
  int appended;
  int v18;
  int v19;
  const __CFString *v20;
  const __CFString *v21;
  char __filename[1024];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
    goto LABEL_23;
  v2 = *a1;
  if (!*a1)
  {
    v10 = -16471;
    goto LABEL_22;
  }
  v3 = (CFURLRef *)a1[1];
  LogFileName = flr_FigLogRingBufferMakeLogFileName("/tmp/mediaserverd_cached_log_", 0, 0, __filename);
  if (LogFileName)
  {
    v10 = LogFileName;
    goto LABEL_22;
  }
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    v10 = -16470;
    goto LABEL_22;
  }
  v7 = Mutable;
  flr_FigLogRingBufferGetEntriesInternal(v2, Mutable);
  if (CFArrayGetCount(v7) <= 0)
  {
    CFRelease(v7);
    goto LABEL_23;
  }
  v8 = fopen(__filename, "wb+");
  if (!v8)
  {
    v9 = __error();
    syslog(3, "<<<< FigLogRingBuffer >>>> Error in opening file %s errno %d", __filename, *v9);
    CFRelease(v7);
    v10 = -16477;
LABEL_22:
    syslog(3, "<<<< FigLogRingBuffer >>>> failed to copy ring buffer logs error %d", v10);
    goto LABEL_23;
  }
  v11 = v8;
  v13 = *(_DWORD *)(v2 + 56);
  v12 = *(_DWORD *)(v2 + 60);
  v14 = __OFSUB__(v13, v12);
  v15 = v13 - v12;
  if (v15 < 0 != v14)
    v16 = v15 + 10;
  else
    v16 = v15;
  appended = flr_FigLogRingBufferAppendRotatingLogFiles(v16, v12, v11);
  if (appended)
  {
    v10 = appended;
    goto LABEL_21;
  }
  v18 = flr_FigLogRingBufferWriteBuffersToFile(v7, v11);
  if (v18)
  {
LABEL_15:
    v10 = v18;
    if (!v3)
      goto LABEL_21;
    goto LABEL_18;
  }
  v19 = *(_DWORD *)(v2 + 60);
  if (v19 <= 9)
  {
    v18 = flr_FigLogRingBufferAppendRotatingLogFiles(*(_DWORD *)(v2 + 56), 10 - v19, v11);
    goto LABEL_15;
  }
  v10 = 0;
  if (!v3)
    goto LABEL_21;
LABEL_18:
  v20 = CFStringCreateWithCString(v5, __filename, 0);
  if (v20)
  {
    v21 = v20;
    *v3 = CFURLCreateWithFileSystemPath(v5, v20, kCFURLPOSIXPathStyle, 0);
    CFRelease(v21);
    if (!*v3)
      v10 = -16470;
  }
  else
  {
    v10 = -16470;
  }
LABEL_21:
  fclose(v11);
  CFRelease(v7);
  if (v10)
    goto LABEL_22;
LABEL_23:
  free(a1);
}

uint64_t FigLogRingBufferWriteAndCopyURLContainingLogs(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;

  if (!a1 || !*(_QWORD *)(a1 + 24))
  {
    v5 = 4294950821;
LABEL_8:
    syslog(3, "<<<< FigLogRingBuffer >>>> failed to write ring buffer to logs err %d", v5);
    return v5;
  }
  v4 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  if (!v4)
  {
    v5 = 4294950826;
    goto LABEL_8;
  }
  *v4 = a1;
  v4[1] = a2;
  dispatch_sync_f(*(dispatch_queue_t *)(a1 + 24), v4, (dispatch_function_t)flr_FigLogRingBufferWriteLogsDispatch);
  return 0;
}

void FigLogRingBufferRelease(dispatch_queue_t *context)
{
  if (context)
  {
    dispatch_sync_f(context[3], context, (dispatch_function_t)flr_FigLogRingBufferRelease);
    dispatch_release(context[3]);
    free(context);
  }
}

void flr_FigLogRingBufferRelease(uint64_t a1)
{
  void *v2;
  void *v3;

  if (a1)
  {
    v2 = *(void **)a1;
    if (v2)
      free(v2);
    v3 = *(void **)(a1 + 40);
    if (v3)
      FigGzipDispose(v3);
    FigRingBufferRelease(*(_QWORD *)(a1 + 32));
  }
}

CFIndex FigLogRingBufferGetCount(uint64_t a1)
{
  const __CFArray **v1;

  if (a1 && (v1 = *(const __CFArray ***)(a1 + 32)) != 0)
    return FigRingBufferGetCount(v1);
  else
    return 0;
}

uint64_t FigLogRingBufferGetBufferSize(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 8);
  return result;
}

uint64_t FigLogRingBufferGetCompressedLogSize(uint64_t a1)
{
  uint64_t v1;

  if (a1 && (v1 = *(_QWORD *)(a1 + 32)) != 0)
    return FigRingBufferGetSize(v1);
  else
    return 0;
}

uint64_t FigLogRingBufferSetWriteRotatingLogFiles(uint64_t a1, char a2)
{
  uint64_t result;

  if (!a1)
    return 4294950825;
  result = 0;
  *(_BYTE *)(a1 + 64) = a2;
  return result;
}

CFIndex flr_CustomDictGetSize(const __CFDictionary *a1)
{
  const __CFData *Value;

  if (a1 && (Value = (const __CFData *)CFDictionaryGetValue(a1, CFSTR("buffer"))) != 0)
    return CFDataGetLength(Value);
  else
    return 0;
}

uint64_t flr_FigLogRingBufferMakeLogFileName(const char *a1, int a2, int a3, char *a4)
{
  size_t v8;
  uint64_t v9;
  tm *v10;
  time_t v12;

  v8 = strlen(a1);
  strlcpy(a4, a1, 0x400uLL);
  if (a2)
  {
    if (1024 - v8 < 4)
    {
      return 4294950818;
    }
    else if (snprintf(&a4[v8], 1024 - v8, "%d.log.gz", a3))
    {
      return 0;
    }
    else
    {
      return 4294950818;
    }
  }
  else
  {
    v12 = 0;
    time(&v12);
    v9 = 4294950818;
    if (1024 - v8 >= 0x19)
    {
      v10 = localtime(&v12);
      if (strftime(&a4[v8], 1024 - v8, "%Y-%m-%d-%H%M%S.log.gz", v10))
        return 0;
      else
        return 4294950818;
    }
  }
  return v9;
}

void flr_FigLogRingBufferCommitBuffer(uint64_t a1, uint64_t a2, __CFArray *a3, double a4)
{
  const __CFAllocator *v8;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v10;
  CFDataRef v11;
  CFDataRef v12;
  double Current;
  __CFArray *v14;
  int v15;
  FILE *v16;
  int *v17;
  FILE *v18;
  const __CFDictionary *ValueAtIndex;
  const __CFNumber *Value;
  CFDateRef v21;
  CFDateRef v22;
  const __CFLocale *v23;
  const __CFLocale *v24;
  __CFDateFormatter *v25;
  __CFDateFormatter *v26;
  const __CFString *StringWithDate;
  const char *CStringPtr;
  pid_t v29;
  const char *v30;
  unsigned int v31;
  uint64_t v32;
  int v33;
  int *v34;
  int v35;
  int v36;
  void *v37;
  __CFArray *v38;
  int v39;
  int v40;
  _QWORD v41[2];
  void *v42;
  size_t v43;
  char __filename[1024];
  UInt8 *bytes;
  CFIndex length;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v10 = Mutable;
  if (a2 && a1 && Mutable)
  {
    if (!*(_QWORD *)(a2 + 8) || !*(_QWORD *)a2)
      goto LABEL_66;
    length = 0;
    bytes = 0;
    if (flr_FigLogRingBufferGzipBufferIntoNewBuffer(a1, a2, &bytes))
    {
      v12 = 0;
    }
    else
    {
      v11 = CFDataCreate(v8, bytes, length);
      v12 = v11;
      if (v11)
      {
        CFRetain(v11);
        CFRelease(v12);
      }
    }
    if (bytes)
      free(bytes);
    if (*(_QWORD *)a2)
    {
      free(*(void **)a2);
      *(_QWORD *)a2 = 0;
    }
    FigGzipReset(*(_QWORD *)(a1 + 40));
    if (!v12)
    {
LABEL_66:
      v38 = v10;
LABEL_62:
      CFRelease(v38);
      return;
    }
    Current = CFAbsoluteTimeGetCurrent();
    FigCFDictionarySetDouble(v10, CFSTR("start"), a4);
    FigCFDictionarySetDouble(v10, CFSTR("end"), Current);
    CFDictionarySetValue(v10, CFSTR("buffer"), v12);
    if (*(_BYTE *)(a1 + 64))
    {
      v14 = CFArrayCreateMutable(v8, 0, MEMORY[0x1E0C9B378]);
      if (!v14)
        goto LABEL_60;
    }
    else
    {
      v14 = 0;
    }
    if (FigRingBufferAppendValueAndEvictBuffer(*(_QWORD *)(a1 + 32), v10, v14))
      goto LABEL_60;
    if (!v14 || CFArrayGetCount(v14) < 1)
      goto LABEL_56;
    if (flr_FigLogRingBufferMakeLogFileName("/private/var/mobile/Library/Logs/CrashReporter/mediaserverd_autolog_", 1, *(_DWORD *)(a1 + 56), __filename))
    {
LABEL_60:
      CFRelease(v10);
      CFRelease(v12);
      if (!v14)
        return;
      v38 = v14;
      goto LABEL_62;
    }
    v15 = *(_DWORD *)(a1 + 60);
    *(_DWORD *)(a1 + 56) = (*(_DWORD *)(a1 + 56) + 1) % 10;
    if (v15 <= 9)
      *(_DWORD *)(a1 + 60) = v15 + 1;
    if (CFArrayGetCount(v14) < 1)
      goto LABEL_56;
    v16 = fopen(__filename, "wb+");
    if (!v16)
    {
      v17 = __error();
      syslog(3, "<<<< FigLogRingBuffer >>>> Error in opening file %s, errno %d", __filename, *v17);
      syslog(3, "<<<< FigLogRingBuffer >>>> failed to write ring log buffer to file %s error %d", __filename, -16477);
LABEL_56:
      if (a3)
        CFArrayAppendValue(a3, v10);
      v37 = malloc_type_calloc(1uLL, *(_QWORD *)(a1 + 16), 0xE9362F0FuLL);
      *(_QWORD *)a1 = v37;
      if (v37)
      {
        *(_QWORD *)(a1 + 8) = 0;
        *(_QWORD *)(a1 + 48) = 0;
      }
      goto LABEL_60;
    }
    v18 = v16;
    bytes = 0;
    if (CFArrayGetCount(v14) < 1)
    {
      v39 = -16475;
    }
    else
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v14, 0);
      if (ValueAtIndex)
      {
        Value = (const __CFNumber *)CFDictionaryGetValue(ValueAtIndex, CFSTR("start"));
        if (Value)
        {
          CFNumberGetValue(Value, kCFNumberDoubleType, &bytes);
          v21 = CFDateCreate(v8, *(CFAbsoluteTime *)&bytes);
          if (v21)
          {
            v22 = v21;
            v23 = CFLocaleCopyCurrent();
            if (!v23)
            {
              CFRelease(v22);
              StringWithDate = 0;
              syslog(3, "<<<< FigLogRingBuffer >>>> failed to get the buffer start time %d", -16470);
              goto LABEL_37;
            }
            v24 = v23;
            v25 = CFDateFormatterCreate(v8, v23, kCFDateFormatterFullStyle, kCFDateFormatterFullStyle);
            v26 = v25;
            if (v25)
            {
              CFDateFormatterSetFormat(v25, CFSTR("yyyy-MM-dd HH:mm:ss.SS"));
              StringWithDate = CFDateFormatterCreateStringWithDate(v8, v26, v22);
              CFRelease(v26);
              if (StringWithDate)
              {
                v40 = 0;
                LOBYTE(v26) = 1;
                goto LABEL_35;
              }
              LOBYTE(v26) = 0;
            }
            else
            {
              StringWithDate = 0;
            }
            v40 = -16470;
LABEL_35:
            CFRelease(v22);
            CFRelease(v24);
            if ((v26 & 1) == 0)
              syslog(3, "<<<< FigLogRingBuffer >>>> failed to get the buffer start time %d", v40);
LABEL_37:
            v41[0] = &bytes;
            if (StringWithDate)
              CStringPtr = CFStringGetCStringPtr(StringWithDate, 0x8000100u);
            else
              CStringPtr = 0;
            v29 = getpid();
            v30 = "TimeNotAvailable";
            if (CStringPtr)
              v30 = CStringPtr;
            v31 = snprintf((char *)&bytes, 0x480uLL, "==== mediaserverd Rotating AutoLogFile %s PID %d start time: %s ====\n", __filename, v29, v30);
            if (v31)
            {
              if (v31 >= 0x480)
                v32 = 1152;
              else
                v32 = v31;
              v41[1] = v32;
              v42 = 0;
              v43 = 0;
              v33 = flr_FigLogRingBufferGzipBufferIntoNewBuffer(a1, (uint64_t)v41, (Bytef **)&v42);
              if (v33)
              {
                v35 = v33;
              }
              else
              {
                if (fwrite(v42, v43, 1uLL, v18) == 1)
                {
                  free(v42);
LABEL_52:
                  v36 = flr_FigLogRingBufferWriteBuffersToFile(v14, v18);
                  if (v36)
                    syslog(3, "<<<< FigLogRingBuffer >>>> failed to write ring log buffer to file %s error %d", __filename, v36);
                  fclose(v18);
                  if (StringWithDate)
                    CFRelease(StringWithDate);
                  goto LABEL_56;
                }
                v34 = __error();
                syslog(3, "<<<< FigLogRingBuffer >>>> Failed to write the auto log file header, errno %d", *v34);
                v35 = -16477;
              }
              free(v42);
            }
            else
            {
              v35 = -16478;
            }
            syslog(3, "<<<< FigLogRingBuffer >>>> failed to write the auto log file header for %s (%d)", __filename, v35);
            goto LABEL_52;
          }
          v39 = -16470;
        }
        else
        {
          v39 = -16471;
        }
      }
      else
      {
        v39 = -16474;
      }
    }
    StringWithDate = 0;
    syslog(3, "<<<< FigLogRingBuffer >>>> failed to get the buffer start time %d", v39);
    goto LABEL_37;
  }
  if (Mutable)
    CFRelease(Mutable);
}

uint64_t flr_FigLogRingBufferGzipBufferIntoNewBuffer(uint64_t a1, uint64_t a2, Bytef **a3)
{
  uint64_t v3;
  size_t v6;
  Bytef *v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v12;
  Bytef *v13;
  BOOL v14;
  uint64_t v15;

  v15 = 0;
  v14 = 0;
  v3 = 4294950821;
  v13 = 0;
  if (a1 && a2 && a3)
  {
    v6 = *(_QWORD *)(a2 + 8);
    if (v6)
    {
      v12 = 0;
      v8 = (Bytef *)malloc_type_calloc(1uLL, v6, 0x524446E4uLL);
      if (v8)
      {
        v9 = *(_QWORD *)(a2 + 8);
        *a3 = v8;
        a3[1] = 0;
        v10 = FigGzipCompressMemory(*(z_streamp *)(a1 + 40), *(Bytef **)a2, *(_QWORD *)(a2 + 8), &v15, &v14, v8, v9, &v13, &v12, 1);
        v3 = v10;
        if ((_DWORD)v10)
          syslog(3, "<<<< FigLogRingBuffer >>>> error in compressing ring log buffer %d", v10);
        else
          a3[1] = v13;
      }
      else
      {
        v3 = 4294950826;
      }
      FigGzipReset(*(_QWORD *)(a1 + 40));
    }
    else
    {
      return 4294950821;
    }
  }
  return v3;
}

uint64_t flr_FigLogRingBufferWriteBuffersToFile(const __CFArray *a1, FILE *a2)
{
  CFIndex v4;
  const __CFDictionary *ValueAtIndex;
  const __CFData *Value;
  const __CFData *v7;
  const UInt8 *BytePtr;
  size_t Length;
  int *v11;

  if (!a1)
    return 4294950822;
  if (a2)
  {
    if (CFArrayGetCount(a1) < 1)
      return 0;
    v4 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1, v4);
      if (ValueAtIndex)
      {
        Value = (const __CFData *)CFDictionaryGetValue(ValueAtIndex, CFSTR("buffer"));
        if (Value)
        {
          v7 = Value;
          BytePtr = CFDataGetBytePtr(Value);
          Length = CFDataGetLength(v7);
          if (fwrite(BytePtr, Length, 1uLL, a2) != 1)
            break;
        }
      }
      if (++v4 >= CFArrayGetCount(a1))
        return 0;
    }
    v11 = __error();
    syslog(3, "<<<< FigLogRingBuffer >>>> Failed to flush the fig log ring buffer logs, errno %d", *v11);
  }
  return 4294950819;
}

void flr_FigLogRingBufferGetEntriesInternal(uint64_t a1, __CFArray *a2)
{
  __int128 v4;

  FigRingBufferGetEntries(*(_QWORD *)(a1 + 32), a2);
  if (*(_QWORD *)(a1 + 8))
  {
    v4 = *(_OWORD *)a1;
    flr_FigLogRingBufferCommitBuffer(a1, (uint64_t)&v4, a2, *(double *)(a1 + 48));
  }
}

uint64_t flr_FigLogRingBufferAppendRotatingLogFiles(int a1, int a2, FILE *a3)
{
  int v3;
  int v4;
  uint64_t LogFileName;
  FILE *v7;
  FILE *v8;
  void *v9;
  size_t v10;
  uint64_t v11;
  char v12;
  BOOL v13;
  char __filename[1024];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1 >= 0)
    v3 = a1;
  else
    v3 = a1 + 10;
  if (!a3)
  {
    syslog(3, "<<<< FigLogRingBuffer >>>> null target file cannot copy");
    return 4294950819;
  }
  if (v3 < 0)
  {
    syslog(3, "<<<< FigLogRingBuffer >>>> cannot determine the ring log file counter to use %d");
    return 4294950819;
  }
  v4 = a2;
  if (a2 < 1)
    return 0;
  while (1)
  {
    LogFileName = flr_FigLogRingBufferMakeLogFileName("/private/var/mobile/Library/Logs/CrashReporter/mediaserverd_autolog_", 1, v3, __filename);
    if ((_DWORD)LogFileName)
    {
      v11 = LogFileName;
      syslog(3, "<<<< FigLogRingBuffer >>>> failed (%d) to make the ring log file name for %d");
      return v11;
    }
    v7 = fopen(__filename, "rb");
    if (v7)
    {
      v8 = v7;
      v9 = malloc_type_calloc(1uLL, 0x4000uLL, 0x8DE28586uLL);
      if (v9)
      {
        while (1)
        {
          if (feof(v8))
          {
            v11 = 0;
            v12 = 1;
            goto LABEL_15;
          }
          v10 = fread(v9, 1uLL, 0x4000uLL, v8);
          if (!v10)
            break;
          if (fwrite(v9, 1uLL, v10, a3) != v10)
          {
            syslog(3, "<<<< FigLogRingBuffer >>>> failed to write all the data %ld (read %ld)");
            goto LABEL_20;
          }
        }
        syslog(3, "<<<< FigLogRingBuffer >>>> failed to read bytes from source log file");
LABEL_20:
        v12 = 0;
        v11 = 4294950819;
      }
      else
      {
        v12 = 0;
        v11 = 4294950826;
      }
LABEL_15:
      free(v9);
      fclose(v8);
      if ((v12 & 1) == 0)
        break;
    }
    v3 = (v3 + 1) % 10;
    v13 = __OFSUB__(v4--, 1);
    if ((v4 < 0) ^ v13 | (v4 == 0))
      return 0;
  }
  syslog(3, "<<<< FigLogRingBuffer >>>> failed to append the ring log file %s");
  return v11;
}

uint64_t CMTagCollectionAssistantGetTypeID()
{
  if (CMTagCollectionAssistantGetTypeID_sRegisterTagCollectionAssistantTypeOnce != -1)
    dispatch_once_f(&CMTagCollectionAssistantGetTypeID_sRegisterTagCollectionAssistantTypeOnce, 0, (dispatch_function_t)tagCollectionAssistant_registerTagCollectionAssistantType);
  return sTagCollectionAssistantTypeID;
}

uint64_t tagCollectionAssistant_registerTagCollectionAssistantType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sTagCollectionAssistantTypeID = result;
  return result;
}

uint64_t CMTagCollectionAssistantCreateWithPreset(uint64_t a1, unsigned int a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t Instance;
  uint64_t v7;

  result = 4294951345;
  if (a2 <= 1 && a3)
  {
    if (CMTagCollectionAssistantGetTypeID_sRegisterTagCollectionAssistantTypeOnce != -1)
      dispatch_once_f(&CMTagCollectionAssistantGetTypeID_sRegisterTagCollectionAssistantTypeOnce, 0, (dispatch_function_t)tagCollectionAssistant_registerTagCollectionAssistantType);
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v7 = Instance;
      result = 0;
      *(_DWORD *)(v7 + 16) = a2;
      *(_OWORD *)(v7 + 24) = xmmword_18EDDDA80;
      *a3 = v7;
    }
    else
    {
      return 4294951346;
    }
  }
  return result;
}

uint64_t CMTagCollectionAssistantCopyTagCollection(uint64_t a1, CFAllocatorRef allocator, CMTagCollectionRef *a3)
{
  unsigned int v3;
  uint64_t v5;
  uint64_t v6;
  int32x2_t v7;
  int64x2_t v8;
  OSStatus v9;
  CMTagCollectionRef v10;
  uint64_t result;
  CMTagCollectionRef newCollectionOut;
  CMTag tags;
  int8x16_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return 4294951345;
  v3 = *(_DWORD *)(a1 + 16);
  if (v3 > 1)
    return 4294951345;
  newCollectionOut = 0;
  v5 = *(_QWORD *)(a1 + 24);
  v6 = *(_QWORD *)(a1 + 32);
  v7 = vdup_n_s32(v3 == 1);
  v8.i64[0] = v7.u32[0];
  v8.i64[1] = v7.u32[1];
  tags = kCMTagMediaTypeVideo;
  v14 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v8, 0x3FuLL)), (int8x16_t)kCMTagStereoLeftAndRightEye, (int8x16_t)kCMTagStereoNone);
  v15 = 0x57061636BLL;
  v16 = v5;
  v17 = 0x570726F6ALL;
  v18 = v6;
  v9 = CMTagCollectionCreate(allocator, &tags, 4, &newCollectionOut);
  v10 = newCollectionOut;
  if (v9)
  {
    if (newCollectionOut)
    {
      CFRelease(newCollectionOut);
      v10 = 0;
    }
  }
  result = 0;
  *a3 = v10;
  return result;
}

uint64_t CMTagCollectionAssistantGetPreset(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t CMTagCollectionAssistantSetPreset(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2;
  return result;
}

uint64_t CMTagCollectionAssistantGetPackingType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t CMTagCollectionAssistantSetPackingType(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 24) = a2;
  return result;
}

uint64_t CMTagCollectionAssistantGetProjectionType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t CMTagCollectionAssistantSetProjectionType(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = a2;
  return result;
}

_QWORD *tagCollectionAssistant_init(_QWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  return result;
}

BOOL tagCollectionAssistant_equal(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16)
      && *(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24)
      && *(_QWORD *)(a1 + 32) == *(_QWORD *)(a2 + 32);
}

CFStringRef tagCollectionAssistant_copyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  CFIndex v3;

  v2 = CFGetAllocator((CFTypeRef)a1);
  v3 = CFGetRetainCount((CFTypeRef)a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CMTagCollectionAssistant %p retainCount: %ld> preset: %u, packingType: %llu, projectionType: %llu"), a1, v3, *(unsigned int *)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32));
}

OSStatus CMSwapBigEndianMetadataDescriptionToHost(uint8_t *metadataDescriptionData, size_t metadataDescriptionSize)
{
  flipClosedCaptionDescriptionData((int8x8_t *)metadataDescriptionData);
  return 0;
}

OSStatus CMSwapHostEndianMetadataDescriptionToBig(uint8_t *metadataDescriptionData, size_t metadataDescriptionSize)
{
  flipClosedCaptionDescriptionData((int8x8_t *)metadataDescriptionData);
  return 0;
}

uint64_t FigMetadataUnboxMEBXKeyTableBox(const __CFAllocator *a1, uint64_t a2, CFMutableDictionaryRef *a3)
{
  uint64_t v5;
  CFMutableDictionaryRef Mutable;
  uint64_t CurrentAtomVersionAndFlags;
  const __CFString *v8;
  const __CFString *v9;
  uint64_t CurrentAtomTypeAndDataLength;
  BOOL v11;
  unsigned int v12;
  uint64_t v13;
  CFStringRef v14;
  __CFDictionary *v15;
  __CFArray *v16;
  uint64_t v17;
  CFNumberRef *v18;
  CFDataRef *p_value;
  const __CFString *v20;
  __CFArray *v21;
  CFTypeRef v22;
  __CFData *v23;
  __CFData *v24;
  uint64_t v25;
  UInt8 *MutableBytePtr;
  uint64_t v27;
  __CFArray *v28;
  uint64_t v29;
  CFTypeRef v30;
  CFDictionaryRef v31;
  uint64_t v32;
  char *v33;
  uint64_t CurrentAtomData;
  CFStringRef v35;
  uint64_t v36;
  uint64_t v37;
  __CFDictionary *v39;
  const void *v40;
  uint64_t v41;
  uint64_t Atom;
  const void *v43;
  __CFDictionary *v44;
  __CFDictionary *v45;
  CFStringRef v46;
  const void *v47;
  CFMutableDictionaryRef *v49;
  const __CFAllocator *allocator;
  const __CFString *v51;
  const __CFString *v52;
  const void *v53;
  const void *v54;
  CFTypeRef v55;
  uint64_t v56;
  unsigned int v57;
  _OWORD v58[7];
  __int128 v59;
  __int128 value;
  _OWORD v61[7];
  uint64_t v62;
  int v63;
  unsigned int valuePtr;
  CFTypeRef v65;
  CFTypeRef cf;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  uint64_t v74;
  int v75;
  void *values[2];
  void *keys[4];

  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  memset(v58, 0, sizeof(v58));
  v57 = 0;
  v56 = 0;
  v5 = FigAtomStreamInitWithParent(a2, 0, (uint64_t)v58);
  if ((_DWORD)v5 == -12893)
  {
    Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CurrentAtomVersionAndFlags = 0;
    goto LABEL_3;
  }
  CurrentAtomVersionAndFlags = v5;
  if (!(_DWORD)v5)
  {
    v49 = a3;
    Mutable = 0;
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v8 = CFSTR("MetadataKeyDataTypeNameSpace");
    v9 = CFSTR("MetadataKeyDataType");
    v53 = (const void *)*MEMORY[0x1E0C9AE40];
    v54 = (const void *)*MEMORY[0x1E0C9AE50];
    while (1)
    {
      CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v58, &v57, &v56);
      if ((_DWORD)CurrentAtomTypeAndDataLength)
      {
        CurrentAtomVersionAndFlags = CurrentAtomTypeAndDataLength;
LABEL_174:
        if (Mutable)
          CFRelease(Mutable);
        return CurrentAtomVersionAndFlags;
      }
      if (v57)
        v11 = v57 == 1970628964;
      else
        v11 = 1;
      if (v11)
        goto LABEL_12;
      v52 = v9;
      valuePtr = v57;
      v63 = 0;
      v62 = 0;
      memset(v61, 0, sizeof(v61));
      value = 0uLL;
      v59 = 0uLL;
      v13 = FigAtomStreamInitWithParent((uint64_t)v58, 0, (uint64_t)v61);
      v51 = v8;
      if ((_DWORD)v13)
      {
        CurrentAtomVersionAndFlags = v13;
        v44 = Mutable;
        v14 = 0;
        v15 = 0;
        v55 = 0;
LABEL_160:
        v16 = 0;
        goto LABEL_131;
      }
      v14 = 0;
      v15 = 0;
      v55 = 0;
      v16 = 0;
      while (1)
      {
        v17 = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v61, &v63, &v62);
        if ((_DWORD)v17)
        {
LABEL_125:
          CurrentAtomVersionAndFlags = v17;
          goto LABEL_126;
        }
        if (v63 <= 1819239264)
        {
          if (v63 == 1668575347)
          {
            if (!v16)
            {
              v75 = 0;
              v74 = 0;
              v72 = 0u;
              v73 = 0u;
              v70 = 0u;
              v71 = 0u;
              v68 = 0u;
              v69 = 0u;
              v67 = 0u;
              v65 = 0;
              cf = 0;
              v27 = FigAtomStreamInitWithParent((uint64_t)v61, 0, (uint64_t)&v67);
              if ((_DWORD)v27)
              {
                CurrentAtomVersionAndFlags = v27;
                v44 = Mutable;
                goto LABEL_160;
              }
              v28 = 0;
              do
              {
                v29 = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)&v67, &v75, &v74);
                if ((_DWORD)v29)
                {
                  CurrentAtomVersionAndFlags = v29;
                  goto LABEL_90;
                }
                if (v75 == 1685354864)
                {
                  CurrentAtomVersionAndFlags = copyKeyOrDataTypeAtom(a1, (uint64_t)&v67, (CFNumberRef *)&cf, (CFDataRef *)&v65);
                  v30 = cf;
                  if ((_DWORD)CurrentAtomVersionAndFlags)
                  {
                    if (cf)
                      CFRelease(cf);
                    goto LABEL_90;
                  }
                  if (cf && v65)
                  {
                    keys[0] = (void *)v8;
                    keys[1] = (void *)v52;
                    values[0] = (void *)cf;
                    values[1] = (void *)v65;
                    v31 = CFDictionaryCreate(a1, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                    if (!v28)
                      v28 = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
                    CFArrayAppendValue(v28, v31);
                    CFRelease(v31);
                    v30 = cf;
                  }
                  if (v30)
                  {
                    CFRelease(v30);
                    cf = 0;
                  }
                  if (v65)
                  {
                    CFRelease(v65);
                    v65 = 0;
                  }
                }
                v32 = FigAtomStreamAdvanceToNextAtom(&v67);
              }
              while (!(_DWORD)v32);
              CurrentAtomVersionAndFlags = v32;
              if ((_DWORD)v32 == -12890)
              {
                CurrentAtomVersionAndFlags = 0;
                v16 = v28;
                v28 = 0;
                goto LABEL_91;
              }
LABEL_90:
              v16 = 0;
LABEL_91:
              if (v65)
                CFRelease(v65);
              if (v28)
                CFRelease(v28);
              if ((_DWORD)CurrentAtomVersionAndFlags)
                goto LABEL_126;
            }
          }
          else if (v63 == 1685354864)
          {
            if (v59 == 0)
            {
              v18 = (CFNumberRef *)&v59 + 1;
              p_value = (CFDataRef *)&v59;
LABEL_55:
              v17 = copyKeyOrDataTypeAtom(a1, (uint64_t)v61, v18, p_value);
              if ((_DWORD)v17)
                goto LABEL_125;
              goto LABEL_99;
            }
          }
          else if (v63 == 1801812324 && value == 0)
          {
            v18 = (CFNumberRef *)&value + 1;
            p_value = (CFDataRef *)&value;
            goto LABEL_55;
          }
          goto LABEL_99;
        }
        if (v63 == 1819239265)
        {
          if (!v14)
          {
            *(_QWORD *)&v67 = 0;
            CurrentAtomVersionAndFlags = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v61, 0, &v67);
            v33 = 0;
            if ((_DWORD)CurrentAtomVersionAndFlags || !(_QWORD)v67)
              goto LABEL_98;
            v33 = (char *)malloc_type_malloc(v67, 0xA8D583B0uLL);
            if (!v33)
              goto LABEL_97;
            CurrentAtomData = FigAtomStreamReadCurrentAtomData((uint64_t)v61, 0, v67, (uint64_t)v33);
            if ((_DWORD)CurrentAtomData)
            {
              CurrentAtomVersionAndFlags = CurrentAtomData;
              v44 = Mutable;
              free(v33);
              v14 = 0;
              goto LABEL_131;
            }
            if (v33[(_QWORD)v67 - 1] || (v35 = CFStringCreateWithCString(a1, v33, 0x600u)) == 0)
            {
LABEL_97:
              CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
LABEL_98:
              free(v33);
              v14 = 0;
              if ((_DWORD)CurrentAtomVersionAndFlags)
              {
                v44 = Mutable;
                Mutable = 0;
                v46 = 0;
                v45 = 0;
                goto LABEL_133;
              }
              goto LABEL_99;
            }
            v14 = v35;
            free(v33);
          }
          goto LABEL_99;
        }
        if (v63 != 1935962212)
        {
          if (v63 == 1936028789 && !v55)
          {
            v20 = v14;
            v21 = v16;
            *(_QWORD *)&v67 = 0;
            CurrentAtomVersionAndFlags = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v61, 0, &v67);
            v22 = 0;
            if (!(_DWORD)CurrentAtomVersionAndFlags && (_QWORD)v67)
            {
              v23 = CFDataCreateMutable(allocator, v67);
              if (v23)
              {
                v24 = v23;
                CFDataSetLength(v23, v67);
                v25 = v67;
                MutableBytePtr = CFDataGetMutableBytePtr(v24);
                CurrentAtomVersionAndFlags = FigAtomStreamReadCurrentAtomData((uint64_t)v61, 0, v25, (uint64_t)MutableBytePtr);
                if ((_DWORD)CurrentAtomVersionAndFlags)
                  v22 = 0;
                else
                  v22 = CFRetain(v24);
                CFRelease(v24);
              }
              else
              {
                CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                v22 = 0;
              }
            }
            v55 = v22;
            if ((_DWORD)CurrentAtomVersionAndFlags)
            {
              v44 = Mutable;
              Mutable = 0;
              v46 = 0;
              v45 = 0;
              v16 = v21;
              v14 = v20;
              goto LABEL_133;
            }
            v16 = v21;
            v14 = v20;
          }
          goto LABEL_99;
        }
        if (!v15)
          break;
LABEL_99:
        Atom = FigAtomStreamAdvanceToNextAtom(v61);
        if ((_DWORD)Atom)
        {
          CurrentAtomVersionAndFlags = Atom;
          if ((_DWORD)Atom == -12890)
          {
            if (!Mutable)
            {
              Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              if (!Mutable)
              {
                CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                v44 = 0;
                goto LABEL_132;
              }
            }
            v43 = (const void *)*((_QWORD *)&value + 1);
            if (!*((_QWORD *)&value + 1))
            {
              v44 = Mutable;
              CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
              goto LABEL_131;
            }
            v44 = Mutable;
            v45 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            if (v45)
            {
              Mutable = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
              if (Mutable)
              {
                v46 = CFStringCreateWithFormat(a1, 0, CFSTR("%d"), valuePtr);
                if (v46)
                {
                  CFDictionaryAddValue(v45, CFSTR("MetadataKeyNamespace"), v43);
                  if ((_QWORD)value)
                    CFDictionaryAddValue(v45, CFSTR("MetadataKeyValue"), (const void *)value);
                  CFDictionaryAddValue(v45, CFSTR("MetadataKeyLocalID"), Mutable);
                  if (*((_QWORD *)&v59 + 1))
                  {
                    v47 = (const void *)v59;
                    if ((_QWORD)v59)
                    {
                      CFDictionaryAddValue(v45, v51, *((const void **)&v59 + 1));
                      CFDictionaryAddValue(v45, v52, v47);
                    }
                  }
                  if (v14)
                    CFDictionaryAddValue(v45, CFSTR("MetadataKeyLanguageTag"), v14);
                  if (v15)
                    CFDictionaryAddValue(v45, CFSTR("MetadataKeyStructuralDependency"), v15);
                  if (v55)
                    CFDictionaryAddValue(v45, CFSTR("MetadataKeySetupData"), v55);
                  if (v16)
                    CFDictionaryAddValue(v45, CFSTR("MetadataKeyConformingDataTypes"), v16);
                  CFDictionaryAddValue(v44, v46, v45);
                  CurrentAtomVersionAndFlags = 0;
                }
                else
                {
                  CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                }
                goto LABEL_133;
              }
              CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
            }
            else
            {
              CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              Mutable = 0;
            }
            v46 = 0;
            goto LABEL_133;
          }
LABEL_126:
          v44 = Mutable;
          goto LABEL_131;
        }
      }
      LODWORD(v74) = 0;
      keys[0] = 0;
      v72 = 0u;
      v73 = 0u;
      v70 = 0u;
      v71 = 0u;
      v68 = 0u;
      v69 = 0u;
      v67 = 0u;
      v36 = FigAtomStreamInitWithParent((uint64_t)v61, 0, (uint64_t)&v67);
      if ((_DWORD)v36)
      {
        CurrentAtomVersionAndFlags = v36;
        goto LABEL_130;
      }
      v15 = 0;
      while (2)
      {
        v37 = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)&v67, &v74, keys);
        if ((_DWORD)v37)
        {
          CurrentAtomVersionAndFlags = v37;
          goto LABEL_128;
        }
        if ((_DWORD)v74 == 1935962217 && v15 == 0)
        {
          LOBYTE(cf) = 0;
          LODWORD(values[0]) = 0;
          CurrentAtomVersionAndFlags = FigAtomStreamGetCurrentAtomVersionAndFlags((uint64_t)&v67, &cf, (unsigned int *)values);
          if (!(_DWORD)CurrentAtomVersionAndFlags && !(_BYTE)cf)
          {
            v39 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            if (v39)
            {
              v15 = v39;
              if (((uint64_t)values[0] & 1) != 0)
                v40 = v54;
              else
                v40 = v53;
              CFDictionaryAddValue(v39, CFSTR("StructuralDependencyIsInvalidFlag"), v40);
              goto LABEL_84;
            }
            CurrentAtomVersionAndFlags = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          }
          if ((_DWORD)CurrentAtomVersionAndFlags)
            goto LABEL_130;
          v15 = 0;
        }
LABEL_84:
        v41 = FigAtomStreamAdvanceToNextAtom(&v67);
        if (!(_DWORD)v41)
          continue;
        break;
      }
      CurrentAtomVersionAndFlags = v41;
      if ((_DWORD)v41 == -12890)
        goto LABEL_99;
LABEL_128:
      if (v15)
        CFRelease(v15);
LABEL_130:
      v44 = Mutable;
      v15 = 0;
LABEL_131:
      Mutable = 0;
LABEL_132:
      v46 = 0;
      v45 = 0;
LABEL_133:
      if (*((_QWORD *)&value + 1))
        CFRelease(*((CFTypeRef *)&value + 1));
      if (Mutable)
        CFRelease(Mutable);
      if (v46)
        CFRelease(v46);
      Mutable = v44;
      if ((_QWORD)value)
        CFRelease((CFTypeRef)value);
      v8 = v51;
      if (v45)
        CFRelease(v45);
      if (*((_QWORD *)&v59 + 1))
        CFRelease(*((CFTypeRef *)&v59 + 1));
      if ((_QWORD)v59)
        CFRelease((CFTypeRef)v59);
      if (v14)
        CFRelease(v14);
      if (v15)
        CFRelease(v15);
      if (v55)
        CFRelease(v55);
      if (v16)
        CFRelease(v16);
      v9 = v52;
      if ((_DWORD)CurrentAtomVersionAndFlags)
        goto LABEL_174;
LABEL_12:
      v12 = FigAtomStreamAdvanceToNextAtom(v58);
      if (v12)
      {
        if (v12 == -12890)
          CurrentAtomVersionAndFlags = 0;
        else
          CurrentAtomVersionAndFlags = v12;
        a3 = v49;
LABEL_3:
        *a3 = Mutable;
        return CurrentAtomVersionAndFlags;
      }
    }
  }
  return CurrentAtomVersionAndFlags;
}

uint64_t FigMetadataUnboxMEBXPrimaryLocalIDsBox(const __CFAllocator *a1, uint64_t a2, __CFArray **a3)
{
  uint64_t CurrentAtomTypeAndDataLength;
  __CFArray *Mutable;
  uint64_t v8;
  const __CFAllocator *v9;
  const CFArrayCallBacks *v10;
  uint64_t CurrentAtomData;
  CFNumberRef v12;
  uint64_t v13;
  unsigned int valuePtr;
  uint64_t v16;

  v16 = 0;
  valuePtr = 0;
  CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength(a2, 0, &v16);
  if ((_DWORD)CurrentAtomTypeAndDataLength)
    return CurrentAtomTypeAndDataLength;
  if ((v16 & 3) != 0)
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  else if (v16 < 1)
  {
    Mutable = 0;
LABEL_11:
    v13 = 0;
    *a3 = Mutable;
  }
  else
  {
    Mutable = 0;
    v8 = 0;
    v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v10 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    while (1)
    {
      CurrentAtomData = FigAtomStreamReadCurrentAtomData(a2, v8, 4, (uint64_t)&valuePtr);
      if ((_DWORD)CurrentAtomData)
        break;
      valuePtr = bswap32(valuePtr);
      v12 = CFNumberCreate(v9, kCFNumberSInt32Type, &valuePtr);
      if (!Mutable)
        Mutable = CFArrayCreateMutable(a1, (unint64_t)v16 >> 2, v10);
      CFArrayAppendValue(Mutable, v12);
      CFRelease(v12);
      v8 += 4;
      if (v8 >= v16)
        goto LABEL_11;
    }
    v13 = CurrentAtomData;
    if (Mutable)
      CFRelease(Mutable);
  }
  return v13;
}

uint64_t FigMetadataUnboxMEBXLocalIDDependencyListBoxes(const __CFAllocator *a1, uint64_t a2, __CFDictionary **a3)
{
  uint64_t v5;
  __CFDictionary *v6;
  const __CFAllocator *v7;
  const CFArrayCallBacks *v8;
  const CFDictionaryKeyCallBacks *v9;
  const CFDictionaryValueCallBacks *v10;
  uint64_t CurrentAtomTypeAndDataLength;
  int v12;
  __CFArray *Mutable;
  uint64_t v14;
  uint64_t CurrentAtomData;
  CFNumberRef v16;
  CFStringRef v17;
  uint64_t Atom;
  uint64_t v19;
  __CFDictionary **v21;
  uint64_t valuePtr;
  uint64_t v23;
  _OWORD v24[7];

  memset(v24, 0, sizeof(v24));
  valuePtr = 0;
  v23 = 0;
  v5 = FigAtomStreamInitWithParent(a2, 0, (uint64_t)v24);
  if ((_DWORD)v5)
    return v5;
  v21 = a3;
  v6 = 0;
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  do
  {
    CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v24, (_DWORD *)&valuePtr + 1, &v23);
    if ((_DWORD)CurrentAtomTypeAndDataLength)
    {
      v19 = CurrentAtomTypeAndDataLength;
      goto LABEL_21;
    }
    if ((v23 & 3) != 0 || (v12 = HIDWORD(valuePtr), HIDWORD(valuePtr) = bswap32(HIDWORD(valuePtr)), !v12))
    {
      FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      v19 = 0;
      goto LABEL_21;
    }
    if (v23 >= 1)
    {
      Mutable = 0;
      v14 = 0;
      while (1)
      {
        CurrentAtomData = FigAtomStreamReadCurrentAtomData((uint64_t)v24, v14, 4, (uint64_t)&valuePtr);
        if ((_DWORD)CurrentAtomData)
          break;
        LODWORD(valuePtr) = bswap32(valuePtr);
        v16 = CFNumberCreate(v7, kCFNumberSInt32Type, &valuePtr);
        if (!Mutable)
          Mutable = CFArrayCreateMutable(a1, (unint64_t)v23 >> 2, v8);
        CFArrayAppendValue(Mutable, v16);
        CFRelease(v16);
        v14 += 4;
        if (v14 >= v23)
        {
          if (Mutable)
          {
            if (!v6)
              v6 = CFDictionaryCreateMutable(a1, 0, v9, v10);
            v17 = CFStringCreateWithFormat(a1, 0, CFSTR("%d"), HIDWORD(valuePtr));
            CFDictionarySetValue(v6, v17, Mutable);
            CFRelease(Mutable);
            CFRelease(v17);
          }
          goto LABEL_16;
        }
      }
      v19 = CurrentAtomData;
      if (Mutable)
        CFRelease(Mutable);
      goto LABEL_21;
    }
LABEL_16:
    Atom = FigAtomStreamAdvanceToNextAtom(v24);
  }
  while (!(_DWORD)Atom);
  v19 = Atom;
  if ((_DWORD)Atom == -12890)
  {
    v19 = 0;
    *v21 = v6;
    return v19;
  }
LABEL_21:
  if (v6)
    CFRelease(v6);
  return v19;
}

OSStatus CMMetadataFormatDescriptionCreateFromBigEndianMetadataDescriptionData(CFAllocatorRef allocator, const uint8_t *metadataDescriptionData, size_t size, CMMetadataDescriptionFlavor flavor, CMMetadataFormatDescriptionRef *formatDescriptionOut)
{
  OSStatus v7;
  const __CFString *v8;
  CMBlockBufferRef v9;
  OSStatus v10;
  CMBlockBufferRef metadataDescriptionBlockBuffer;

  metadataDescriptionBlockBuffer = 0;
  if (!metadataDescriptionData || !formatDescriptionOut)
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v7 = CMBlockBufferCreateWithMemoryBlock(allocator, (void *)metadataDescriptionData, size, (CFAllocatorRef)*MEMORY[0x1E0C9AE20], 0, 0, size, 1u, &metadataDescriptionBlockBuffer);
  v9 = metadataDescriptionBlockBuffer;
  if (v7)
  {
    v10 = v7;
    if (!metadataDescriptionBlockBuffer)
      return v10;
    goto LABEL_5;
  }
  v10 = CMMetadataFormatDescriptionCreateFromBigEndianMetadataDescriptionBlockBuffer(allocator, metadataDescriptionBlockBuffer, v8, formatDescriptionOut);
  v9 = metadataDescriptionBlockBuffer;
  if (metadataDescriptionBlockBuffer)
LABEL_5:
    CFRelease(v9);
  return v10;
}

OSStatus CMMetadataFormatDescriptionCreateFromBigEndianMetadataDescriptionBlockBuffer(CFAllocatorRef allocator, CMBlockBufferRef metadataDescriptionBlockBuffer, CMMetadataDescriptionFlavor flavor, CMMetadataFormatDescriptionRef *formatDescriptionOut)
{
  OSStatus v7;
  unsigned int v8;
  OSStatus v9;
  const __CFDictionary *v10;
  OSStatus v11;
  OSStatus CurrentAtomTypeAndDataLength;
  OSStatus Atom;
  CFDictionaryRef v14;
  BOOL v15;
  CFIndex v16;
  CFDictionaryRef v17;
  unsigned int destination;
  CFTypeRef v20;
  CFTypeRef cf;
  CFDictionaryRef theDict;
  uint64_t v23;
  int v24;
  _OWORD v25[7];
  void *values[3];
  void *keys[4];

  keys[3] = *(void **)MEMORY[0x1E0C80C00];
  if (!metadataDescriptionBlockBuffer || !formatDescriptionOut)
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  destination = 0;
  v7 = CMBlockBufferCopyDataBytes(metadataDescriptionBlockBuffer, 4uLL, 4uLL, &destination);
  if (v7)
    return v7;
  v8 = destination;
  destination = bswap32(destination);
  cf = 0;
  theDict = 0;
  v20 = 0;
  if (CMBlockBufferGetDataLength(metadataDescriptionBlockBuffer) > 0xF)
  {
    memset(v25, 0, sizeof(v25));
    v24 = 0;
    v23 = 0;
    if (v8 == 2019714413)
    {
      v11 = FigAtomStreamInitWithBBuf(metadataDescriptionBlockBuffer, 0x10uLL, 0, (uint64_t)v25);
      if (!v11)
      {
        do
        {
          CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)v25, &v24, &v23);
          if (CurrentAtomTypeAndDataLength)
          {
LABEL_36:
            v9 = CurrentAtomTypeAndDataLength;
            goto LABEL_37;
          }
          if (v24 == 1818846320)
          {
            if (!cf)
            {
              CurrentAtomTypeAndDataLength = FigMetadataUnboxMEBXPrimaryLocalIDsBox(allocator, (uint64_t)v25, (__CFArray **)&cf);
              if (CurrentAtomTypeAndDataLength)
                goto LABEL_36;
            }
          }
          else if (v24 == 1818846316)
          {
            if (!v20)
            {
              CurrentAtomTypeAndDataLength = FigMetadataUnboxMEBXLocalIDDependencyListBoxes(allocator, (uint64_t)v25, (__CFDictionary **)&v20);
              if (CurrentAtomTypeAndDataLength)
                goto LABEL_36;
            }
          }
          else if (v24 == 1801812339 && !theDict)
          {
            CurrentAtomTypeAndDataLength = FigMetadataUnboxMEBXKeyTableBox(allocator, (uint64_t)v25, &theDict);
            if (CurrentAtomTypeAndDataLength)
              goto LABEL_36;
          }
          Atom = FigAtomStreamAdvanceToNextAtom(v25);
        }
        while (!Atom);
        v9 = Atom;
        if (Atom == -12890)
        {
          v14 = theDict;
          if (!theDict)
          {
            v10 = 0;
            v9 = 0;
            goto LABEL_39;
          }
          if (CFDictionaryGetCount(theDict) < 1)
          {
            v17 = 0;
          }
          else
          {
            keys[1] = CFSTR("MetadataPrimaryLocalIDs");
            keys[2] = CFSTR("MetadataLocalIDDependencyLists");
            values[0] = v14;
            values[1] = (void *)cf;
            values[2] = (void *)v20;
            keys[0] = CFSTR("MetadataKeyTable");
            if (v20)
              v15 = cf == 0;
            else
              v15 = 1;
            if (v15)
              v16 = 1;
            else
              v16 = 3;
            v17 = CFDictionaryCreate(allocator, (const void **)keys, (const void **)values, v16, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          }
          v9 = 0;
          goto LABEL_38;
        }
LABEL_37:
        v17 = 0;
        v10 = 0;
        v14 = theDict;
        if (!theDict)
          goto LABEL_39;
LABEL_38:
        CFRelease(v14);
        v10 = v17;
        goto LABEL_39;
      }
    }
    else
    {
      v11 = FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
    }
    v9 = v11;
    v10 = 0;
LABEL_39:
    if (cf)
      CFRelease(cf);
    if (v20)
      CFRelease(v20);
    goto LABEL_43;
  }
  v9 = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  v10 = 0;
LABEL_43:
  if (!v9)
    v9 = FigMetadataFormatDescriptionCreateWithExtensions(allocator, destination, v10, formatDescriptionOut);
  if (v10)
    CFRelease(v10);
  return v9;
}

uint64_t FigMetadataAppendMEBXKeyTableBox(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t result;
  _OWORD v4[3];
  uint64_t v5;
  _OWORD v6[3];
  uint64_t v7;

  v7 = 0;
  memset(v6, 0, sizeof(v6));
  v5 = 0;
  memset(v4, 0, sizeof(v4));
  result = FigAtomWriterInitWithParent(a1, (uint64_t)v6);
  if (!(_DWORD)result)
  {
    result = FigAtomWriterBeginAtom((uint64_t)v6, 0x6B657973u, 0);
    if (!(_DWORD)result)
    {
      result = FigAtomWriterInitWithParent((uint64_t)v6, (uint64_t)v4);
      if (!(_DWORD)result)
      {
        CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)KeyEmitterApplierFunction, v4);
        return FigAtomWriterEndAtom((uint64_t)v6);
      }
    }
  }
  return result;
}

void KeyEmitterApplierFunction(uint64_t a1, const __CFDictionary *a2, uint64_t a3)
{
  unsigned int LocalIDUInt32;
  const void *Value;
  CFTypeID v7;
  const __CFString *v8;
  const __CFString *v9;
  CFTypeID TypeID;
  CFIndex v11;
  CFIndex v12;
  CFIndex v13;
  UInt8 *v14;
  CFTypeID v15;
  int v16;
  const UInt8 *v17;
  CFIndex v18;
  int v19;
  uint64_t v20;
  int v21;
  const __CFString *v22;
  const __CFString *v23;
  uint64_t Length;
  CFIndex v25;
  UInt8 *v26;
  UInt8 *v27;
  int appended;
  int v29;
  const __CFDictionary *v30;
  const __CFDictionary *v31;
  const void *v32;
  int v33;
  const __CFData *v34;
  const __CFData *v35;
  CFIndex v36;
  uint64_t v37;
  const UInt8 *BytePtr;
  const __CFArray *v39;
  const __CFArray *v40;
  CFIndex Count;
  uint64_t v42;
  CFIndex v43;
  const __CFDictionary *ValueAtIndex;
  uint64_t v45;
  CFIndex usedBufLen;
  _OWORD valuePtr[3];
  uint64_t v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  CFRange v53;
  CFRange v54;

  LocalIDUInt32 = FigMetadataKeyGetLocalIDUInt32(a2);
  if (!LocalIDUInt32)
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    return;
  }
  if (!FigAtomWriterBeginAtom(a3, LocalIDUInt32, 0))
  {
    Value = CFDictionaryGetValue(a2, CFSTR("MetadataKeyNamespace"));
    v7 = CFGetTypeID(Value);
    if (v7 != CFNumberGetTypeID())
    {
      if (FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0))
        return;
LABEL_23:
      if (KeyEmitter_EmitDatatypeDeclarationBox(a3, a2))
        return;
      usedBufLen = 0;
      *(_QWORD *)&valuePtr[0] = 0;
      v22 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("MetadataKeyLanguageTag"));
      if (!v22)
        goto LABEL_34;
      v23 = v22;
      Length = CFStringGetLength(v22);
      if (Length < 1)
        goto LABEL_34;
      v25 = Length;
      v52 = 0;
      v50 = 0u;
      v51 = 0u;
      v49 = 0u;
      v53.location = 0;
      v53.length = Length;
      CFStringGetBytes(v23, v53, 0x600u, 0, 0, 0, 0, (CFIndex *)valuePtr);
      if (*(uint64_t *)&valuePtr[0] <= 0)
      {
        v45 = 4294954580;
      }
      else
      {
        v26 = (UInt8 *)malloc_type_malloc(*(_QWORD *)&valuePtr[0] + 1, 0xD94E18CCuLL);
        if (v26)
        {
          v27 = v26;
          v54.location = 0;
          v54.length = v25;
          CFStringGetBytes(v23, v54, 0x600u, 0, 0, v26, *(CFIndex *)&valuePtr[0], &usedBufLen);
          if (*(_QWORD *)&valuePtr[0] == usedBufLen)
          {
            v27[*(_QWORD *)&valuePtr[0]] = 0;
            appended = FigAtomWriterInitWithParent(a3, (uint64_t)&v49);
            if (!appended)
            {
              appended = FigAtomWriterBeginAtom((uint64_t)&v49, 0x6C6F6361u, 0);
              if (!appended)
              {
                appended = FigAtomWriterAppendData((uint64_t)&v49, (uint64_t)v27, *(_QWORD *)&valuePtr[0] + 1);
                if (!appended)
                  appended = FigAtomWriterEndAtom((uint64_t)&v49);
              }
            }
          }
          else
          {
            appended = FigSignalErrorAt(4294954580, 0, 0, 0, 0, 0, 0);
          }
          v29 = appended;
          free(v27);
          if (v29)
            return;
LABEL_34:
          v30 = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("MetadataKeyStructuralDependency"));
          if (v30)
          {
            v31 = v30;
            if (CFDictionaryContainsKey(v30, CFSTR("StructuralDependencyIsInvalidFlag")))
            {
              v48 = 0;
              memset(valuePtr, 0, sizeof(valuePtr));
              if (FigAtomWriterInitWithParent(a3, (uint64_t)valuePtr))
                return;
              if (FigAtomWriterBeginAtom((uint64_t)valuePtr, 0x73647064u, 0))
                return;
              v52 = 0;
              v50 = 0u;
              v51 = 0u;
              v49 = 0u;
              if (FigAtomWriterInitWithParent((uint64_t)valuePtr, (uint64_t)&v49))
                return;
              v32 = CFDictionaryGetValue(v31, CFSTR("StructuralDependencyIsInvalidFlag"));
              v33 = FigCFEqual(v32, (CFTypeRef)*MEMORY[0x1E0C9AE50]);
              if (FigAtomWriterBeginAtom((uint64_t)&v49, 0x73647069u, 0)
                || FigAtomWriterAppendVersionAndFlags((uint64_t)&v49, 0, v33 != 0)
                || FigAtomWriterEndAtom((uint64_t)&v49)
                || FigAtomWriterEndAtom((uint64_t)valuePtr))
              {
                return;
              }
            }
          }
          v34 = (const __CFData *)CFDictionaryGetValue(a2, CFSTR("MetadataKeySetupData"));
          if (v34)
          {
            v35 = v34;
            v36 = CFDataGetLength(v34);
            if (v36)
            {
              v37 = v36;
              v52 = 0;
              v50 = 0u;
              v51 = 0u;
              v49 = 0u;
              if (FigAtomWriterInitWithParent(a3, (uint64_t)&v49))
                return;
              if (FigAtomWriterBeginAtom((uint64_t)&v49, 0x73657475u, 0))
                return;
              BytePtr = CFDataGetBytePtr(v35);
              if (FigAtomWriterAppendData((uint64_t)&v49, (uint64_t)BytePtr, v37)
                || FigAtomWriterEndAtom((uint64_t)&v49))
              {
                return;
              }
            }
          }
          v39 = (const __CFArray *)CFDictionaryGetValue(a2, CFSTR("MetadataKeyConformingDataTypes"));
          if (v39)
          {
            v40 = v39;
            Count = CFArrayGetCount(v39);
            if (Count)
            {
              v42 = Count;
              v52 = 0;
              v50 = 0u;
              v51 = 0u;
              v49 = 0u;
              if (FigAtomWriterInitWithParent(a3, (uint64_t)&v49)
                || FigAtomWriterBeginAtom((uint64_t)&v49, 0x63747073u, 0))
              {
                return;
              }
              if (v42 >= 1)
              {
                v43 = 0;
                do
                {
                  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v40, v43);
                  if (KeyEmitter_EmitDatatypeDeclarationBox((uint64_t)&v49, ValueAtIndex))
                    return;
                }
                while (v42 != ++v43);
              }
              if (FigAtomWriterEndAtom((uint64_t)&v49))
                return;
            }
          }
          FigAtomWriterEndAtom(a3);
          return;
        }
        v45 = 4294954583;
      }
      if (FigSignalErrorAt(v45, 0, 0, 0, 0, 0, 0))
        return;
      goto LABEL_34;
    }
    v52 = 0;
    v50 = 0u;
    v51 = 0u;
    v49 = 0u;
    LODWORD(valuePtr[0]) = 0;
    CFNumberGetValue((CFNumberRef)Value, kCFNumberSInt32Type, valuePtr);
    LODWORD(valuePtr[0]) = bswap32(valuePtr[0]);
    v8 = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("MetadataKeyValue"));
    v9 = v8;
    if (v8)
    {
      CFRetain(v8);
      TypeID = CFStringGetTypeID();
      if (TypeID == CFGetTypeID(v9))
      {
        v11 = CFStringGetLength(v9);
        if (v11 >= 1)
        {
          v12 = v11;
          v13 = v11 + 1;
          v14 = (UInt8 *)malloc_type_calloc(1uLL, v11 + 1, 0xF4139D1uLL);
          if (CFStringGetCString(v9, (char *)v14, v13, 0x600u))
          {
            CFRelease(v9);
            v9 = (const __CFString *)CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v14, v12);
          }
          free(v14);
        }
      }
      v15 = CFGetTypeID(v9);
      if (v15 == CFDataGetTypeID())
      {
        if (CFDataGetLength((CFDataRef)v9))
          goto LABEL_12;
        v20 = 4294954581;
      }
      else
      {
        v20 = 4294954584;
      }
      v16 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
      goto LABEL_20;
    }
LABEL_12:
    v16 = FigAtomWriterInitWithParent(a3, (uint64_t)&v49);
    if (!v16)
    {
      v16 = FigAtomWriterBeginAtom((uint64_t)&v49, 0x6B657964u, 0);
      if (!v16)
      {
        v16 = FigAtomWriterAppendData((uint64_t)&v49, (uint64_t)valuePtr, 4);
        if (!v16)
        {
          if (v9)
          {
            v17 = CFDataGetBytePtr((CFDataRef)v9);
            v18 = CFDataGetLength((CFDataRef)v9);
            v19 = FigAtomWriterAppendData((uint64_t)&v49, (uint64_t)v17, v18);
            if (v19)
            {
              v21 = v19;
LABEL_21:
              CFRelease(v9);
LABEL_22:
              if (v21)
                return;
              goto LABEL_23;
            }
          }
          v16 = FigAtomWriterEndAtom((uint64_t)&v49);
        }
      }
    }
LABEL_20:
    v21 = v16;
    if (!v9)
      goto LABEL_22;
    goto LABEL_21;
  }
}

uint64_t FigMetadataAppendMEBXPrimaryLocalIDsBox(uint64_t a1, const __CFArray *a2)
{
  uint64_t result;
  _OWORD v4[3];
  uint64_t v5;
  CFRange v6;

  v5 = 0;
  memset(v4, 0, sizeof(v4));
  result = FigAtomWriterInitWithParent(a1, (uint64_t)v4);
  if (!(_DWORD)result)
  {
    result = FigAtomWriterBeginAtom((uint64_t)v4, 0x6C696470u, 0);
    if (!(_DWORD)result)
    {
      v6.length = CFArrayGetCount(a2);
      v6.location = 0;
      CFArrayApplyFunction(a2, v6, (CFArrayApplierFunction)LocalIDEmitterApplierFunction, v4);
      return FigAtomWriterEndAtom((uint64_t)v4);
    }
  }
  return result;
}

uint64_t LocalIDEmitterApplierFunction(const __CFNumber *a1, uint64_t a2)
{
  uint64_t result;
  signed int valuePtr;

  valuePtr = 0;
  result = CFNumberGetValue(a1, kCFNumberSInt32Type, &valuePtr);
  if (valuePtr >= 1)
  {
    valuePtr = bswap32(valuePtr);
    return FigAtomWriterAppendData(a2, (uint64_t)&valuePtr, 4);
  }
  return result;
}

uint64_t FigMetadataAppendMEBXLocalIDDependencyListBoxes(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t result;
  _OWORD v4[3];
  uint64_t v5;

  v5 = 0;
  memset(v4, 0, sizeof(v4));
  result = FigAtomWriterInitWithParent(a1, (uint64_t)v4);
  if (!(_DWORD)result)
  {
    result = FigAtomWriterBeginAtom((uint64_t)v4, 0x6C69646Cu, 0);
    if (!(_DWORD)result)
    {
      CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)DependencyListsEmitterApplierFunction, v4);
      return FigAtomWriterEndAtom((uint64_t)v4);
    }
  }
  return result;
}

uint64_t DependencyListsEmitterApplierFunction(const __CFString *a1, const void *a2, uint64_t a3)
{
  CFTypeID TypeID;
  CFTypeID v7;
  uint64_t result;
  unsigned int v9;
  _OWORD v10[3];
  uint64_t v11;
  CFRange v12;

  TypeID = CFStringGetTypeID();
  if (TypeID != CFGetTypeID(a1))
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v7 = CFArrayGetTypeID();
  if (v7 != CFGetTypeID(a2))
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  result = CFStringGetIntValue(a1);
  if ((_DWORD)result)
  {
    v9 = bswap32(result);
    v11 = 0;
    memset(v10, 0, sizeof(v10));
    FigAtomWriterInitWithParent(a3, (uint64_t)v10);
    FigAtomWriterBeginAtom((uint64_t)v10, v9, 0);
    v12.length = CFArrayGetCount((CFArrayRef)a2);
    v12.location = 0;
    CFArrayApplyFunction((CFArrayRef)a2, v12, (CFArrayApplierFunction)LocalIDEmitterApplierFunction, v10);
    return FigAtomWriterEndAtom((uint64_t)v10);
  }
  return result;
}

OSStatus CMMetadataFormatDescriptionCopyAsBigEndianMetadataDescriptionBlockBuffer(CFAllocatorRef allocator, CMMetadataFormatDescriptionRef metadataFormatDescription, CMMetadataDescriptionFlavor flavor, CMBlockBufferRef *blockBufferOut)
{
  const __CFDictionary *Extensions;
  const __CFDictionary *v8;
  const __CFDictionary *Value;
  const __CFDictionary *v10;
  const __CFArray *v11;
  const __CFDictionary *v12;
  OSStatus appended;
  OSStatus v14;
  OSStatus v15;
  unint64_t v17;
  CMBlockBufferRef blockBufferOuta;
  _OWORD v19[3];
  uint64_t v20;

  v20 = 0;
  memset(v19, 0, sizeof(v19));
  v17 = 0xFFFF000000000000;
  blockBufferOuta = 0;
  if (metadataFormatDescription)
  {
    if (blockBufferOut)
    {
      Extensions = CMFormatDescriptionGetExtensions(metadataFormatDescription);
      if (Extensions)
      {
        v8 = Extensions;
        Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("MetadataKeyTable"));
        if (Value)
        {
          v10 = Value;
          CFRetain(Value);
        }
        else
        {
          v10 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        }
        v11 = (const __CFArray *)CFDictionaryGetValue(v8, CFSTR("MetadataPrimaryLocalIDs"));
        v12 = (const __CFDictionary *)CFDictionaryGetValue(v8, CFSTR("MetadataLocalIDDependencyLists"));
        if (CMFormatDescriptionGetMediaSubType(metadataFormatDescription) != 1835360888)
        {
          v15 = FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
          goto LABEL_24;
        }
        appended = CMBlockBufferCreateEmpty(allocator, 8u, 0, &blockBufferOuta);
        if (appended)
          goto LABEL_18;
        appended = FigAtomWriterInitWithBlockBuffer(blockBufferOuta, (uint64_t)v19);
        if (appended)
          goto LABEL_18;
        appended = FigAtomWriterBeginAtom((uint64_t)v19, 0x6D656278u, 0);
        if (appended)
          goto LABEL_18;
        FigAtomWriterAppendData((uint64_t)v19, (uint64_t)&v17, 8);
        appended = FigMetadataAppendMEBXKeyTableBox((uint64_t)v19, v10);
        if (appended)
          goto LABEL_18;
        if (!v11)
          goto LABEL_21;
        if (CFArrayGetCount(v11) >= 1 && v12 && CFDictionaryGetCount(v12) >= 1)
        {
          appended = FigMetadataAppendMEBXPrimaryLocalIDsBox((uint64_t)v19, v11);
          if (appended || (appended = FigMetadataAppendMEBXLocalIDDependencyListBoxes((uint64_t)v19, v12)) != 0)
          {
LABEL_18:
            v14 = appended;
            goto LABEL_25;
          }
          goto LABEL_23;
        }
        if (CFArrayGetCount(v11) <= 0)
        {
LABEL_21:
          if (v12)
            CFDictionaryGetCount(v12);
        }
LABEL_23:
        v15 = FigAtomWriterEndAtom((uint64_t)v19);
LABEL_24:
        v14 = v15;
        if (v15)
          goto LABEL_25;
LABEL_31:
        *blockBufferOut = blockBufferOuta;
        blockBufferOuta = 0;
        if (!v10)
          return v14;
        goto LABEL_28;
      }
    }
  }
  v14 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v10 = 0;
  if (!v14)
    goto LABEL_31;
LABEL_25:
  if (blockBufferOuta)
    CFRelease(blockBufferOuta);
  if (v10)
LABEL_28:
    CFRelease(v10);
  return v14;
}

uint64_t copyKeyOrDataTypeAtom(const __CFAllocator *a1, uint64_t a2, CFNumberRef *a3, CFDataRef *a4)
{
  uint64_t CurrentAtomTypeAndDataLength;
  uint64_t CurrentAtomData;
  CFNumberRef v10;
  CFDataRef v11;
  unint64_t v13;
  char *dataPointerOut;
  size_t totalLengthOut;
  CMBlockBufferRef theBuffer;
  unsigned int valuePtr;
  char v18;

  v18 = 0;
  valuePtr = 0;
  totalLengthOut = 0;
  theBuffer = 0;
  v13 = 0;
  dataPointerOut = 0;
  CurrentAtomTypeAndDataLength = FigAtomStreamGetCurrentAtomTypeAndDataLength(a2, 0, &v13);
  if (!(_DWORD)CurrentAtomTypeAndDataLength && v13 >= 4)
  {
    CurrentAtomData = FigAtomStreamReadCurrentAtomData(a2, 0, 4, (uint64_t)&valuePtr);
    if (!(_DWORD)CurrentAtomData)
    {
      valuePtr = bswap32(valuePtr);
      v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
      *a3 = v10;
      if (v10)
      {
        if (v13 < 5)
        {
LABEL_9:
          CurrentAtomTypeAndDataLength = 0;
          goto LABEL_10;
        }
        CurrentAtomData = FigAtomStreamReadCurrentAtomDataAndCreateBBuf(a2, 4, 0, &theBuffer);
        if ((_DWORD)CurrentAtomData)
          goto LABEL_14;
        CurrentAtomData = CMBlockBufferGetDataPointer(theBuffer, 0, 0, &totalLengthOut, &dataPointerOut);
        if ((_DWORD)CurrentAtomData)
          goto LABEL_14;
        v11 = CFDataCreate(a1, (const UInt8 *)dataPointerOut, totalLengthOut);
        *a4 = v11;
        if (v11)
          goto LABEL_9;
      }
      CurrentAtomData = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    }
LABEL_14:
    CurrentAtomTypeAndDataLength = CurrentAtomData;
  }
LABEL_10:
  if (theBuffer)
    CFRelease(theBuffer);
  return CurrentAtomTypeAndDataLength;
}

uint64_t KeyEmitter_EmitDatatypeDeclarationBox(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFNumber *Value;
  const __CFString *v5;
  const __CFString *v6;
  CFTypeID TypeID;
  CFIndex Length;
  CFIndex v9;
  CFIndex v10;
  UInt8 *v11;
  CFTypeID v12;
  uint64_t v13;
  CFTypeID v14;
  uint64_t appended;
  const UInt8 *BytePtr;
  CFIndex v17;
  uint64_t v18;
  UInt8 bytes[4];
  unsigned int valuePtr;
  _OWORD v22[3];
  uint64_t v23;

  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("MetadataKeyDataTypeNameSpace"));
  valuePtr = 0;
  if (Value)
  {
    v23 = 0;
    memset(v22, 0, sizeof(v22));
    CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
    valuePtr = bswap32(valuePtr);
    v5 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("MetadataKeyDataType"));
    if (v5)
    {
      v6 = v5;
      CFRetain(v5);
      TypeID = CFStringGetTypeID();
      if (TypeID == CFGetTypeID(v6))
      {
        Length = CFStringGetLength(v6);
        if (Length >= 1)
        {
          v9 = Length;
          v10 = Length + 1;
          v11 = (UInt8 *)malloc_type_calloc(1uLL, Length + 1, 0x93AD09ACuLL);
          if (CFStringGetCString(v6, (char *)v11, v10, 0x600u))
          {
            CFRelease(v6);
            v6 = (const __CFString *)CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v11, v9);
          }
          free(v11);
          if (!v6)
            return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        }
        goto LABEL_13;
      }
      v12 = CFNumberGetTypeID();
      if (v12 == CFGetTypeID(v6))
      {
        *(_DWORD *)bytes = 0;
        CFNumberGetValue((CFNumberRef)v6, kCFNumberSInt32Type, bytes);
        CFRelease(v6);
        *(_DWORD *)bytes = bswap32(*(unsigned int *)bytes);
        v6 = (const __CFString *)CFDataCreate(0, bytes, 4);
        if (!v6)
          return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        v14 = CFDataGetTypeID();
        if (v14 != CFGetTypeID(v6))
        {
          v18 = 4294954584;
          goto LABEL_20;
        }
      }
LABEL_13:
      if (CFDataGetLength((CFDataRef)v6))
      {
        appended = FigAtomWriterInitWithParent(a1, (uint64_t)v22);
        if (!(_DWORD)appended)
        {
          appended = FigAtomWriterBeginAtom((uint64_t)v22, 0x64747970u, 0);
          if (!(_DWORD)appended)
          {
            appended = FigAtomWriterAppendData((uint64_t)v22, (uint64_t)&valuePtr, 4);
            if (!(_DWORD)appended)
            {
              BytePtr = CFDataGetBytePtr((CFDataRef)v6);
              v17 = CFDataGetLength((CFDataRef)v6);
              appended = FigAtomWriterAppendData((uint64_t)v22, (uint64_t)BytePtr, v17);
              if (!(_DWORD)appended)
                appended = FigAtomWriterEndAtom((uint64_t)v22);
            }
          }
        }
        goto LABEL_21;
      }
      v18 = 4294954581;
LABEL_20:
      appended = FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
LABEL_21:
      v13 = appended;
      CFRelease(v6);
      return v13;
    }
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

void FigSandboxServerXPC_RemoveAssertionForPID(int a1, uint64_t a2)
{
  _QWORD v2[5];
  int v3;

  if (gFigSandboxServerXPC_0)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __FigSandboxServerXPC_RemoveAssertionForPID_block_invoke;
    v2[3] = &__block_descriptor_tmp_39;
    v3 = a1;
    v2[4] = a2;
    dispatch_sync((dispatch_queue_t)gFigSandboxServerXPC_0, v2);
  }
}

void fsbsxpc_removeAssertionForPIDOnQueue(int a1)
{
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  CFNumberRef SInt32;
  void *value;

  v2 = (const void *)a1;
  v3 = MEMORY[0x193FFAA5C](gFigSandboxServerXPC_2, a1);
  if (v3 >= 1)
  {
    v4 = v3;
    CFBagRemoveValue((CFMutableBagRef)gFigSandboxServerXPC_2, v2);
    if (v4 == 1)
    {
      SInt32 = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a1);
      value = 0;
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)gFigSandboxServerXPC_1, SInt32, (const void **)&value))
      {
        CFArrayGetCount((CFArrayRef)value);
        CFDictionaryRemoveValue((CFMutableDictionaryRef)gFigSandboxServerXPC_1, SInt32);
      }
      if (SInt32)
        CFRelease(SInt32);
    }
  }
}

void FigSandboxServerXPC_AddAssertionForPID(int a1, uint64_t a2)
{
  _QWORD v2[5];
  int v3;

  if (gFigSandboxServerXPC_0)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __FigSandboxServerXPC_AddAssertionForPID_block_invoke;
    v2[3] = &__block_descriptor_tmp_3_4;
    v3 = a1;
    v2[4] = a2;
    dispatch_sync((dispatch_queue_t)gFigSandboxServerXPC_0, v2);
  }
}

uint64_t FigSandboxRegistrationServerStart()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __FigSandboxRegistrationServerStart_block_invoke;
  block[3] = &unk_1E28DE9F0;
  block[4] = &v3;
  if (FigSandboxRegistrationServerStart_static_init != -1)
    dispatch_once(&FigSandboxRegistrationServerStart_static_init, block);
  v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t HandleSandboxRegistrationMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t OpCode;
  int ClientPIDFromAuditToken;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  CFNumberRef SInt32;
  uint64_t uint64;
  CFTypeID v13;
  const __CFNumber *v14;
  int v15;
  int v17;
  int *v18;
  CFTypeRef v19;
  __int128 block;
  __int128 v21;
  CFNumberRef v22;
  const void *v23;
  int v24;
  CFTypeRef cf;
  uint64_t value;
  const void *v27;
  const __CFData *v28;
  __int128 v29;
  __int128 v30;

  v18 = 0;
  v19 = 0;
  v17 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v17);
  if ((_DWORD)OpCode)
    goto LABEL_28;
  if (v17 == 1668441400)
  {
    v30 = 0u;
    v29 = 0u;
    v27 = 0;
    v28 = 0;
    cf = 0;
    value = 0;
    xpc_connection_get_audit_token();
    block = v29;
    v21 = v30;
    ClientPIDFromAuditToken = FigServer_GetClientPIDFromAuditToken(&block);
    v8 = FigXPCMessageCopyCFData(a2, "ExtensionTokenData", &v28);
    if ((_DWORD)v8
      || (FigXPCMessageCopyCFString(a2, "ExtensionPath", &cf),
          v8 = FigSandboxRegistrationCreate(v28, ClientPIDFromAuditToken, cf, &v27),
          (_DWORD)v8)
      || (v9 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL)) == 0
      && (v8 = FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0), (_DWORD)v8))
    {
      v10 = v8;
      v9 = 0;
    }
    else
    {
      v10 = FigXPCServerAssociateObjectWithConnection(a1, v27, (uint64_t)v9, (uint64_t)DisposeServedSandboxRegistrationState, 0, &value);
      if (!(_DWORD)v10)
      {
        xpc_dictionary_set_uint64(a3, ".objectID", value);
        SInt32 = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E0C9AE00], ClientPIDFromAuditToken);
        *(_QWORD *)&block = MEMORY[0x1E0C809B0];
        *((_QWORD *)&block + 1) = 0x40000000;
        *(_QWORD *)&v21 = __HandleSandboxRegistrationCreationMessage_block_invoke;
        *((_QWORD *)&v21 + 1) = &__block_descriptor_tmp_20_0;
        v22 = SInt32;
        v23 = v27;
        v24 = ClientPIDFromAuditToken;
        dispatch_sync((dispatch_queue_t)gFigSandboxServerXPC_0, &block);
        *(_DWORD *)v9 = ClientPIDFromAuditToken;
        v9[1] = CFRetain(v27);
        v9 = 0;
LABEL_8:
        DisposeServedSandboxRegistrationState(v9);
        if (v27)
          CFRelease(v27);
        if (cf)
          CFRelease(cf);
        if (v28)
          CFRelease(v28);
        if (SInt32)
          CFRelease(SInt32);
        goto LABEL_24;
      }
    }
    SInt32 = 0;
    goto LABEL_8;
  }
  uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  OpCode = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &v19, &v18);
  if ((_DWORD)OpCode)
  {
LABEL_28:
    v10 = OpCode;
    goto LABEL_24;
  }
  if (!v19 || (v13 = CFGetTypeID(v19), v13 != FigSandboxRegistrationGetTypeID()))
  {
    OpCode = FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
    goto LABEL_28;
  }
  if (v17 == 1685024621)
  {
    v14 = (const __CFNumber *)v19;
    if (v19)
    {
      v15 = *v18;
      CFRetain(v19);
      *(_QWORD *)&block = MEMORY[0x1E0C809B0];
      *((_QWORD *)&block + 1) = 0x40000000;
      *(_QWORD *)&v21 = __HandleDestroySandboxRegistrationMessage_block_invoke;
      *((_QWORD *)&v21 + 1) = &__block_descriptor_tmp_22_0;
      LODWORD(v23) = v15;
      v22 = v14;
      dispatch_async((dispatch_queue_t)gFigSandboxServerXPC_0, &block);
    }
    FigXPCServerDisassociateObjectWithConnection(a1, uint64);
    v10 = 0;
  }
  else
  {
    v10 = 4294951138;
  }
LABEL_24:
  if (v19)
    CFRelease(v19);
  return v10;
}

void figSandboxRegistrationServerCompactDictionaryDescription(const __CFNumber *a1, const __CFSet *a2, __CFString *a3)
{
  const __CFNumber *SInt32;
  __CFString *v6;

  SInt32 = FigCFNumberGetSInt32(a1);
  CFStringAppendFormat(a3, 0, CFSTR("pid : %d = {"), SInt32);
  v6 = FigCFCopyCompactDescription(a2);
  CFStringAppendFormat(a3, 0, CFSTR("%@} "), v6);
  if (v6)
    CFRelease(v6);
}

void figSandboxRegistrationServerPublicDictionaryDescription(const __CFNumber *a1, const __CFArray *a2, __CFString *a3)
{
  const __CFNumber *SInt32;
  CFIndex Count;

  SInt32 = FigCFNumberGetSInt32(a1);
  CFStringAppendFormat(a3, 0, CFSTR("pid : %d = {"), SInt32);
  Count = CFArrayGetCount(a2);
  CFStringAppendFormat(a3, 0, CFSTR("%d} "), Count);
}

uint64_t FigSandboxRegistrationServerKillDueToError(int a1)
{
  return FigXPCServerSelfTerminateDueToError(gFigSandboxRegistrationServerXPC, a1);
}

uint64_t FigSandboxRegistrationServerCopyRegistrationForID(void *a1, _QWORD *a2)
{
  if (gFigSandboxRegistrationServerXPC)
    return FigXPCServerRetainNeighborObjectFromID((uint64_t *)gFigSandboxRegistrationServerXPC, a1, a2);
  else
    return FigSignalErrorAt(4294949792, 0, 0, 0, 0, 0, 0);
}

uint64_t FigXPCMessageSetSandboxRegistration(void *a1, const char *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t value;

  value = 0;
  if (!a3 || !a1 || !a2)
    return FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
  result = FigSandboxRegistrationRemoteGetObjectID(a3, &value);
  if (!(_DWORD)result)
  {
    xpc_dictionary_set_uint64(a1, a2, value);
    return 0;
  }
  return result;
}

uint64_t FigXPCMessageCopySandboxRegistration(void *a1, const char *a2, _QWORD *a3)
{
  void *uint64;

  if (!a3 || !a1 || !a2)
    return FigSignalErrorAt(4294949796, 0, 0, 0, 0, 0, 0);
  uint64 = (void *)xpc_dictionary_get_uint64(a1, a2);
  if (uint64)
    return FigSandboxRegistrationServerCopyRegistrationForID(uint64, a3);
  else
    return 4294949794;
}

void FigSandboxRegistrationServerDumpMappings(uint64_t a1)
{
  CFMutableStringRef Mutable;
  CFMutableStringRef v3;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v5;
  uint64_t v6;
  unsigned int v7;
  char *v8;
  os_log_type_t type;
  int v10[2];
  const char *v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  CFMutableStringRef v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (Mutable)
  {
    v3 = Mutable;
    if (CFDictionaryGetCount((CFDictionaryRef)gFigSandboxServerXPC_1) >= 1)
    {
      CFDictionaryApplyFunction((CFDictionaryRef)gFigSandboxServerXPC_1, (CFDictionaryApplierFunction)figSandboxRegistrationServerPublicDictionaryDescription, v3);
      v10[0] = 0;
      type = OS_LOG_TYPE_DEFAULT;
      os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, v10, &type);
      v5 = v10[0];
      if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
        v7 = v5;
      else
        v7 = v5 & 0xFFFFFFFE;
      if (v7)
      {
        v10[1] = 136315650;
        v11 = "FigSandboxRegistrationServerDumpMappings";
        v12 = 2048;
        v13 = a1;
        v14 = 2114;
        v15 = v3;
        v8 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v5) = v10[0];
      }
      else
      {
        v8 = 0;
      }
      fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v8, v8 != &v16, v5, 0, v6);
    }
    CFRelease(v3);
  }
}

void DisposeServedSandboxRegistrationState(_QWORD *a1)
{
  const void *v2;
  CFTypeRef v3;
  int v4;
  const void *v5;
  _QWORD v6[5];
  int v7;

  if (a1)
  {
    v2 = (const void *)a1[1];
    if (v2)
    {
      v3 = CFRetain(v2);
      v4 = *(_DWORD *)a1;
      v6[0] = MEMORY[0x1E0C809B0];
      v6[1] = 0x40000000;
      v6[2] = __DisposeServedSandboxRegistrationState_block_invoke;
      v6[3] = &__block_descriptor_tmp_21_2;
      v7 = v4;
      v6[4] = v3;
      dispatch_async((dispatch_queue_t)gFigSandboxServerXPC_0, v6);
      v5 = (const void *)a1[1];
      if (v5)
        CFRelease(v5);
    }
    free(a1);
  }
}

uint64_t FigMetadataFormatDescriptionRegister()
{
  return FigThreadRunOnce(&sFigMetadataFormatDescriptionRegisterOnce, (void (*)(void))FigMetadataFormatDescriptionRegisterOnce);
}

uint64_t FigMetadataFormatDescriptionRegisterOnce()
{
  int v1;
  uint64_t v2;
  uint64_t (*v3)(const opaqueCMFormatDescription *, const opaqueCMFormatDescription *, unint64_t, unint64_t);
  __CFString *(*v4)(const void *);
  void (*v5)(uint64_t);

  v1 = 0;
  v2 = 48;
  v4 = figMetadataFormatDescriptionCopyDebugDesc;
  v5 = figMetadataFormatDescriptionFinalize;
  v3 = figMetadataFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x6D657461u, (__int128 *)&v1);
}

uint64_t FigMetadataFormatDescriptionCreateWithKeysAndDependencies(const __CFAllocator *a1, int a2, CFArrayRef theArray, const __CFString *a4, void *a5, uint64_t *a6)
{
  uint64_t *v7;
  CFMutableArrayRef v12;
  CFDictionaryRef v13;
  __CFArray *v14;
  __CFDictionary *v15;
  CFStringRef DynamicBaseDataType;
  CFTypeRef v17;
  CFStringRef v18;
  CFIndex v19;
  const __CFArray *v20;
  const void *ValueAtIndex;
  CFTypeID v22;
  const __CFNumber *Value;
  const __CFNumber *LocalIDUInt32;
  unsigned int KeyNamespaceUInt32;
  __CFDictionary *Mutable;
  __CFDictionary *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  CFTypeID TypeID;
  CFTypeID v33;
  const void *v34;
  const __CFString *v35;
  const __CFArray *v36;
  const __CFArray *v37;
  CFIndex Count;
  CFIndex v39;
  CFIndex v40;
  const void *v41;
  const void *v42;
  CFTypeID v43;
  unsigned int DatatypeNamespaceUInt32;
  const void *v45;
  const void *v46;
  CFTypeID v47;
  const void *v48;
  __CFDictionary *v49;
  const void *v50;
  const void *v51;
  CFTypeID v52;
  CFStringRef v53;
  __CFDictionary *v54;
  int v55;
  int v56;
  CFMutableDictionaryRef v57;
  const void *v58;
  CFIndex v59;
  CFDictionaryRef v60;
  CFDictionaryRef v61;
  __CFDictionary *v62;
  __CFDictionary *v63;
  CFIndex v64;
  uint64_t v65;
  _QWORD *DerivedStorage;
  const __CFString *v68;
  void *v69;
  const __CFAllocator *allocator;
  uint64_t *v71;
  __CFDictionary *v72;
  const __CFAllocator *alloc;
  __CFDictionary *v74;
  __CFArray *v75;
  CFArrayRef theArraya;
  __CFDictionary *v77;
  int v78;
  __CFDictionary *v79;
  const __CFDictionary *v80;
  CFDictionaryRef theDict;
  uint64_t capacity;
  CFTypeRef cf;
  uint64_t valuePtr;
  void *values;
  CFStringRef v86;
  const void *v87;
  void *keys[2];
  const __CFString *v89;
  uint64_t v90;
  CFRange v91;

  v90 = *MEMORY[0x1E0C80C00];
  cf = 0;
  valuePtr = 0;
  if (!a6 || !theArray || (v7 = a6, !CFArrayGetCount(theArray)) || (theArraya = theArray, a2 != 1835360888))
  {
    v65 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    v12 = 0;
    v79 = 0;
    v80 = 0;
    v74 = 0;
    v75 = 0;
    v63 = 0;
    v77 = 0;
    theDict = 0;
    v13 = 0;
    v15 = 0;
    DynamicBaseDataType = 0;
    v18 = 0;
    goto LABEL_118;
  }
  FigThreadRunOnce(&sFigMetadataFormatDescriptionRegisterOnce, (void (*)(void))FigMetadataFormatDescriptionRegisterOnce);
  FigThreadRunOnce(&sFigMetadataFormatDescriptionCreateCanonicalToWellKnownTypeAssociationsOnce, FigMetadataFormatDescriptionCreateCanonicalToWellKnownTypeAssociationsOnce);
  capacity = CFArrayGetCount(theArray);
  if (capacity < 1)
  {
    v12 = 0;
    v79 = 0;
    v80 = 0;
    v74 = 0;
    v75 = 0;
    v63 = 0;
    v77 = 0;
    theDict = 0;
    DynamicBaseDataType = 0;
    v17 = 0;
    v18 = 0;
    goto LABEL_108;
  }
  v68 = a4;
  v69 = a5;
  v71 = v7;
  v72 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v77 = 0;
  v79 = 0;
  theDict = 0;
  DynamicBaseDataType = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v20 = theArraya;
  alloc = a1;
  while (1)
  {
    if (v18)
      CFRelease(v18);
    if (v17)
      CFRelease(v17);
    if (cf)
    {
      CFRelease(cf);
      cf = 0;
    }
    if (DynamicBaseDataType)
      CFRelease(DynamicBaseDataType);
    if (v12)
      CFRelease(v12);
    ValueAtIndex = CFArrayGetValueAtIndex(v20, v19);
    if (ValueAtIndex)
      v17 = CFRetain(ValueAtIndex);
    else
      v17 = 0;
    v22 = CFGetTypeID(v17);
    if (v22 != CFDictionaryGetTypeID())
    {
      v80 = v13;
      v74 = v15;
      v75 = v14;
      v65 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
      v18 = 0;
      goto LABEL_146;
    }
    Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v17, CFSTR("MetadataKeyLocalID"));
    if (Value)
    {
      if (CFNumberGetValue(Value, kCFNumberSInt32Type, (char *)&valuePtr + 4))
      {
        LocalIDUInt32 = FigMetadataKeyGetLocalIDUInt32((const __CFDictionary *)v17);
        HIDWORD(valuePtr) = (_DWORD)LocalIDUInt32;
        if ((_DWORD)LocalIDUInt32)
          break;
      }
    }
    v18 = 0;
LABEL_48:
    DynamicBaseDataType = 0;
    v12 = 0;
LABEL_49:
    if (++v19 == capacity)
    {
      v80 = v13;
      if (theDict)
      {
        v63 = v72;
        if (CFDictionaryGetCount(theDict) >= 1)
        {
          *(_OWORD *)keys = xmmword_1E28DEB28;
          v89 = 0;
          v86 = 0;
          v87 = 0;
          values = theDict;
          if (v68)
          {
            keys[1] = CFSTR("MetadataPrimaryLocalIDs");
            v86 = v68;
            v64 = 2;
          }
          else
          {
            v64 = 1;
          }
          if (v69)
          {
            keys[v64] = CFSTR("MetadataLocalIDDependencyLists");
            *(&values + v64++) = v69;
          }
          v13 = CFDictionaryCreate(a1, (const void **)keys, (const void **)&values, v64, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          if (v13)
          {
            v65 = FigDerivedFormatDescriptionCreate(a1, (void *)0x6D657461, 1835360888, v13, v71);
            if ((_DWORD)v65)
            {
              v74 = v15;
              v75 = v14;
            }
            else
            {
              DerivedStorage = (_QWORD *)FigDerivedFormatDescriptionGetDerivedStorage(*v71);
              *DerivedStorage = v80;
              DerivedStorage[1] = v79;
              DerivedStorage[2] = v77;
              DerivedStorage[3] = v72;
              DerivedStorage[4] = v15;
              DerivedStorage[5] = v14;
              v79 = 0;
              v80 = 0;
              v77 = 0;
              v63 = 0;
              v74 = 0;
              v75 = 0;
            }
          }
          else
          {
            v74 = v15;
            v75 = v14;
            v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
          }
          v15 = 0;
          goto LABEL_116;
        }
        v74 = v15;
        v75 = v14;
        v7 = v71;
      }
      else
      {
        v74 = v15;
        v75 = v14;
        theDict = 0;
        v7 = v71;
        v63 = v72;
      }
LABEL_108:
      v65 = FigDerivedFormatDescriptionCreate(a1, (void *)0x6D657461, 1835360888, 0, v7);
      v15 = 0;
      v13 = 0;
      goto LABEL_116;
    }
  }
  v18 = CFStringCreateWithFormat(a1, 0, CFSTR("%d"), LocalIDUInt32);
  if (!v18)
    goto LABEL_48;
  KeyNamespaceUInt32 = FigMetadataKeyGetKeyNamespaceUInt32((const __CFDictionary *)v17);
  if (KeyNamespaceUInt32 != 1634627438 && !CFDictionaryGetValue((CFDictionaryRef)v17, CFSTR("MetadataKeyValue")))
    goto LABEL_48;
  Mutable = theDict;
  if (!theDict)
  {
    Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!Mutable)
    {
      v80 = v13;
      v74 = v15;
      v75 = v14;
      v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
      DynamicBaseDataType = 0;
      v15 = 0;
      v13 = 0;
      theDict = 0;
      goto LABEL_147;
    }
  }
  theDict = Mutable;
  CFDictionaryAddValue(Mutable, v18, v17);
  v27 = v79;
  if (!v79)
  {
    v27 = CFDictionaryCreateMutable(a1, capacity, 0, MEMORY[0x1E0C9B3A0]);
    if (!v27)
    {
      v80 = v13;
      v74 = v15;
      v75 = v14;
      v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
      DynamicBaseDataType = 0;
      v15 = 0;
      v13 = 0;
      v79 = 0;
      goto LABEL_147;
    }
  }
  v79 = v27;
  CFDictionaryAddValue(v27, (const void *)HIDWORD(valuePtr), v17);
  v28 = CFDictionaryGetValue((CFDictionaryRef)v17, CFSTR("MetadataKeyValue"));
  if (FigMetadataCreateIdentifierForKeyAndOSTypeKeySpace(a1, v28, KeyNamespaceUInt32, (CFStringRef *)&cf))
  {
    v80 = v13;
LABEL_150:
    v74 = v15;
    v75 = v14;
    v65 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
LABEL_146:
    DynamicBaseDataType = 0;
    v15 = 0;
    v13 = 0;
LABEL_147:
    v12 = 0;
    goto LABEL_148;
  }
  if (!v13)
  {
    v13 = CFArrayCreateMutable(a1, capacity, MEMORY[0x1E0C9B378]);
    if (!v13)
    {
      v74 = v15;
      v75 = v14;
      v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
      DynamicBaseDataType = 0;
      v15 = 0;
      v80 = 0;
      goto LABEL_147;
    }
  }
  v91.length = CFArrayGetCount(v13);
  v91.location = 0;
  if (!CFArrayContainsValue(v13, v91, cf))
    CFArrayAppendValue(v13, cf);
  v29 = CFDictionaryGetValue((CFDictionaryRef)v17, CFSTR("MetadataKeyDataType"));
  v30 = CFDictionaryGetValue((CFDictionaryRef)v17, CFSTR("MetadataKeyDataTypeNameSpace"));
  v78 = -1;
  v80 = v13;
  if (!v29 || (v31 = v30) == 0)
  {
LABEL_53:
    v35 = (const __CFString *)CFRetain(CFSTR("com.apple.metadata.datatype.raw-data"));
    goto LABEL_54;
  }
  TypeID = CFDataGetTypeID();
  if (TypeID != CFGetTypeID(v29))
    goto LABEL_150;
  v33 = CFNumberGetTypeID();
  if (v33 != CFGetTypeID(v31))
    goto LABEL_150;
  CFNumberGetValue((CFNumberRef)v31, kCFNumberSInt32Type, &valuePtr);
  if ((_DWORD)valuePtr == 1)
  {
    DynamicBaseDataType = CFStringCreateFromExternalRepresentation(a1, (CFDataRef)v29, 0x600u);
    v78 = -1;
    v13 = v80;
    if (!DynamicBaseDataType)
      goto LABEL_53;
    goto LABEL_55;
  }
  v13 = v80;
  if ((_DWORD)valuePtr || CFDataGetLength((CFDataRef)v29) != 4)
  {
    v78 = -1;
    goto LABEL_53;
  }
  v78 = bswap32(*(_DWORD *)CFDataGetBytePtr((CFDataRef)v29));
  v34 = CFDictionaryGetValue((CFDictionaryRef)sWellKnownTypeToCanonicalMap, (const void *)v78);
  if (v34)
  {
    v35 = (const __CFString *)CFRetain(v34);
    if (v35)
    {
LABEL_54:
      DynamicBaseDataType = v35;
      goto LABEL_55;
    }
  }
  DynamicBaseDataType = FigMetadataCreateDynamicBaseDataType(a1, v78);
  if (!DynamicBaseDataType)
    goto LABEL_53;
LABEL_55:
  v36 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v17, CFSTR("MetadataKeyConformingDataTypes"));
  if (!v36)
  {
    v12 = 0;
LABEL_83:
    a1 = alloc;
    v20 = theArraya;
LABEL_84:
    v55 = v78;
    if (v78 == -1)
    {
      if (!v14)
      {
        v14 = CFArrayCreateMutable(a1, capacity, 0);
        if (!v14)
        {
          v74 = v15;
          v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
          v15 = 0;
          v13 = 0;
          v75 = 0;
          goto LABEL_148;
        }
      }
      CFArrayAppendValue(v14, (const void *)HIDWORD(valuePtr));
      v55 = 0;
      if (v15)
        goto LABEL_91;
    }
    else if (v15)
    {
      goto LABEL_91;
    }
    v56 = v55;
    v57 = CFDictionaryCreateMutable(a1, capacity, 0, 0);
    v55 = v56;
    v15 = v57;
    if (!v57)
    {
      v75 = v14;
      v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
      v13 = 0;
      v74 = 0;
      goto LABEL_148;
    }
LABEL_91:
    CFDictionaryAddValue(v15, (const void *)HIDWORD(valuePtr), (const void *)v55);
    v58 = CFDictionaryGetValue((CFDictionaryRef)v17, CFSTR("MetadataKeyLanguageTag"));
    if (cf)
    {
      *(_OWORD *)keys = xmmword_1E28DEB10;
      v89 = CFSTR("MetadataExtendedLanguageTag");
      values = (void *)cf;
      v86 = DynamicBaseDataType;
      v87 = v58;
      if (v58)
        v59 = 3;
      else
        v59 = 2;
      v60 = CFDictionaryCreate(a1, (const void **)keys, (const void **)&values, v59, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (!v60)
      {
        v74 = v15;
        v75 = v14;
LABEL_158:
        v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
        v15 = 0;
LABEL_159:
        v13 = 0;
LABEL_148:
        v63 = v72;
        goto LABEL_116;
      }
      v61 = v60;
      v62 = v77;
      if (!v77)
      {
        v62 = CFDictionaryCreateMutable(a1, capacity, 0, MEMORY[0x1E0C9B3A0]);
        if (!v62)
        {
          v74 = v15;
          v75 = v14;
          v77 = 0;
          goto LABEL_158;
        }
      }
      v77 = v62;
      CFDictionaryAddValue(v62, (const void *)HIDWORD(valuePtr), v61);
      CFRelease(v61);
      v20 = theArraya;
    }
    goto LABEL_49;
  }
  v37 = v36;
  Count = CFArrayGetCount(v36);
  if (Count < 1)
  {
    v12 = 0;
    v13 = v80;
    goto LABEL_83;
  }
  v39 = Count;
  v74 = v15;
  v75 = v14;
  v12 = 0;
  v40 = 0;
  while (2)
  {
    v41 = CFArrayGetValueAtIndex(v37, v40);
    if (!v41)
      goto LABEL_76;
    v42 = v41;
    v43 = CFDictionaryGetTypeID();
    if (v43 != CFGetTypeID(v42))
      goto LABEL_76;
    DatatypeNamespaceUInt32 = FigMetadataKeyGetDatatypeNamespaceUInt32((const __CFDictionary *)v42);
    LODWORD(valuePtr) = DatatypeNamespaceUInt32;
    if (DatatypeNamespaceUInt32 == 1)
    {
      v50 = CFDictionaryGetValue((CFDictionaryRef)v42, CFSTR("MetadataKeyDataType"));
      if (!v50)
        goto LABEL_76;
      v51 = v50;
      v52 = CFDataGetTypeID();
      if (v52 != CFGetTypeID(v51))
        goto LABEL_76;
      v53 = CFStringCreateFromExternalRepresentation(alloc, (CFDataRef)v51, 0x600u);
      goto LABEL_72;
    }
    if (DatatypeNamespaceUInt32)
      goto LABEL_76;
    v45 = CFDictionaryGetValue((CFDictionaryRef)v42, CFSTR("MetadataKeyDataType"));
    if (!v45)
      goto LABEL_76;
    v46 = v45;
    v47 = CFDataGetTypeID();
    if (v47 != CFGetTypeID(v46) || CFDataGetLength((CFDataRef)v46) != 4)
      goto LABEL_76;
    v78 = bswap32(*(_DWORD *)CFDataGetBytePtr((CFDataRef)v46));
    v48 = CFDictionaryGetValue((CFDictionaryRef)sWellKnownTypeToCanonicalMap, (const void *)v78);
    if (!v48 || (v49 = (__CFDictionary *)CFRetain(v48)) == 0)
    {
      v53 = FigMetadataCreateDynamicBaseDataType(alloc, v78);
LABEL_72:
      v15 = (__CFDictionary *)v53;
      if (v53)
        goto LABEL_73;
      goto LABEL_76;
    }
    v15 = v49;
LABEL_73:
    if (!v12)
    {
      v12 = CFArrayCreateMutable(allocator, v39, MEMORY[0x1E0C9B378]);
      if (!v12)
      {
        v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
        goto LABEL_159;
      }
    }
    CFArrayAppendValue(v12, v15);
    CFRelease(v15);
LABEL_76:
    if (v39 != ++v40)
      continue;
    break;
  }
  v20 = theArraya;
  if (!v12)
  {
    v15 = v74;
    v14 = v75;
    v13 = v80;
    a1 = alloc;
    goto LABEL_84;
  }
  v15 = v74;
  v14 = v75;
  v54 = v72;
  v13 = v80;
  a1 = alloc;
  if (v72 || (v54 = CFDictionaryCreateMutable(alloc, capacity, 0, MEMORY[0x1E0C9B3A0])) != 0)
  {
    v72 = v54;
    CFDictionaryAddValue(v54, (const void *)HIDWORD(valuePtr), v12);
    goto LABEL_84;
  }
  v65 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
  v15 = 0;
  v13 = 0;
  v63 = 0;
LABEL_116:
  if (v17)
    CFRelease(v17);
LABEL_118:
  if (cf)
    CFRelease(cf);
  if (DynamicBaseDataType)
    CFRelease(DynamicBaseDataType);
  if (v15)
    CFRelease(v15);
  if (v18)
    CFRelease(v18);
  if (theDict)
    CFRelease(theDict);
  if (v13)
    CFRelease(v13);
  if (v80)
    CFRelease(v80);
  if (v79)
    CFRelease(v79);
  if (v77)
    CFRelease(v77);
  if (v63)
    CFRelease(v63);
  if (v74)
    CFRelease(v74);
  if (v75)
    CFRelease(v75);
  if (v12)
    CFRelease(v12);
  return v65;
}

OSStatus CMMetadataFormatDescriptionCreateWithKeys(CFAllocatorRef allocator, CMMetadataFormatType metadataType, CFArrayRef keys, CMMetadataFormatDescriptionRef *formatDescriptionOut)
{
  if (metadataType != 1835360888 && keys == 0)
    return CMFormatDescriptionCreate(allocator, 0x6D657461u, metadataType, 0, formatDescriptionOut);
  else
    return FigMetadataFormatDescriptionCreateWithKeysAndDependencies(allocator, metadataType, keys, 0, 0, (uint64_t *)formatDescriptionOut);
}

uint64_t FigMetadataFormatDescriptionCreateWithExtensions(const __CFAllocator *a1, FourCharCode a2, const __CFDictionary *cf, CMFormatDescriptionRef *a4)
{
  CFTypeID v8;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  CFTypeID v11;
  CFIndex Count;
  CFMutableArrayRef Mutable;
  const __CFArray *v14;
  const __CFString *Value;
  void *v16;
  uint64_t v17;
  uint64_t v19;

  if (a4)
  {
    *a4 = 0;
    if (!a2)
      goto LABEL_11;
    if (a2 != 1835360888 || !cf)
    {
      FigThreadRunOnce(&sFigMetadataFormatDescriptionRegisterOnce, (void (*)(void))FigMetadataFormatDescriptionRegisterOnce);
      return CMFormatDescriptionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0x6D657461u, a2, cf, a4);
    }
    v8 = CFGetTypeID(cf);
    if (v8 == CFDictionaryGetTypeID()
      && (v9 = (const __CFDictionary *)CFDictionaryGetValue(cf, CFSTR("MetadataKeyTable"))) != 0
      && (v10 = v9, v11 = CFGetTypeID(v9), v11 == CFDictionaryGetTypeID()))
    {
      Count = CFDictionaryGetCount(v10);
      Mutable = CFArrayCreateMutable(a1, Count, MEMORY[0x1E0C9B378]);
      if (Mutable)
      {
        v14 = Mutable;
        CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)appendValuesToArray_dictionaryCallback, Mutable);
        Value = (const __CFString *)CFDictionaryGetValue(cf, CFSTR("MetadataPrimaryLocalIDs"));
        v16 = (void *)CFDictionaryGetValue(cf, CFSTR("MetadataLocalIDDependencyLists"));
        v17 = FigMetadataFormatDescriptionCreateWithKeysAndDependencies(a1, 1835360888, v14, Value, v16, (uint64_t *)a4);
        CFRelease(v14);
        return v17;
      }
      v19 = 4294954585;
    }
    else
    {
LABEL_11:
      v19 = 4294954586;
    }
  }
  else
  {
    v19 = 4294954586;
  }
  return FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
}

void appendValuesToArray_dictionaryCallback(int a1, const void *a2, CFMutableArrayRef theArray)
{
  CFArrayAppendValue(theArray, a2);
}

OSStatus CMMetadataFormatDescriptionCreateWithMetadataSpecifications(CFAllocatorRef allocator, CMMetadataFormatType metadataType, CFArrayRef metadataSpecifications, CMMetadataFormatDescriptionRef *formatDescriptionOut)
{
  CFIndex Count;
  const __CFArray *Mutable;
  const __CFArray *v10;
  OSStatus v11;
  uint64_t v13;

  if (metadataSpecifications)
  {
    if (CFArrayGetCount(metadataSpecifications))
    {
      Count = CFArrayGetCount(metadataSpecifications);
      Mutable = CFArrayCreateMutable(allocator, Count, MEMORY[0x1E0C9B378]);
      if (Mutable)
      {
        v10 = Mutable;
        v11 = metadataFormatDescriptionCreateWithMetadataSpecifications(allocator, metadataType, 1u, metadataSpecifications, Mutable, 0, 0, (uint64_t *)formatDescriptionOut);
        CFRelease(v10);
        return v11;
      }
      v13 = 4294954585;
    }
    else
    {
      v13 = 4294954586;
    }
  }
  else
  {
    v13 = 4294954586;
  }
  return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
}

uint64_t metadataFormatDescriptionCreateWithMetadataSpecifications(const __CFAllocator *a1, int a2, unsigned int a3, const __CFArray *a4, CFArrayRef theArray, const __CFArray *a6, const void *a7, uint64_t *a8)
{
  CFIndex Count;
  uint64_t v16;
  const void *v17;
  const __CFAllocator *v18;
  CFNumberRef v19;
  CFNumberRef v20;
  CFIndex v21;
  CFNumberRef v22;
  CFIndex v23;
  uint64_t v24;
  CFIndex v25;
  __CFString *MutableCopy;
  CFIndex v27;
  CFMutableDictionaryRef Mutable;
  void *v29;
  const __CFArray *v30;
  uint64_t *v31;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const void *Value;
  uint64_t v35;
  CFNumberRef v37;
  _QWORD valuePtr[6];
  CFTypeRef cf;
  __int128 context;
  __int128 v42;
  __int128 v43;
  CFIndex capacity;
  int v45;
  CFRange v46;
  CFRange v47;

  Count = CFArrayGetCount(theArray);
  v45 = 1;
  if (!a8 || a2 != 1835360888)
    return FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  v16 = Count;
  v17 = a7;
  capacity = 0;
  v42 = 0u;
  v43 = 0u;
  context = 0u;
  LODWORD(valuePtr[0]) = 0;
  v18 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v19 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, valuePtr);
  v20 = CFNumberCreate(v18, kCFNumberSInt32Type, &v45);
  v21 = CFArrayGetCount(a4);
  LODWORD(context) = 0;
  *((_QWORD *)&context + 1) = a1;
  *(_QWORD *)&v42 = a3 | 0x6D65627800000000;
  v37 = v19;
  *((_QWORD *)&v42 + 1) = v19;
  v22 = v20;
  v23 = v21;
  *(_QWORD *)&v43 = v22;
  *((_QWORD *)&v43 + 1) = theArray;
  LODWORD(capacity) = 0;
  v46.location = 0;
  v46.length = v21;
  CFArrayApplyFunction(a4, v46, (CFArrayApplierFunction)metadataFormatDescriptionCreateWithMetadataSpecifications1_arrayCallback, &context);
  v24 = context;
  if ((_DWORD)context)
  {
    v29 = 0;
    MutableCopy = 0;
    goto LABEL_22;
  }
  if (!(_DWORD)capacity)
  {
    v29 = 0;
    if (a6)
    {
      v30 = a6;
      MutableCopy = 0;
      v31 = a8;
      if (v17)
      {
        MutableCopy = (__CFString *)CFRetain(v30);
        v29 = (void *)CFRetain(v17);
      }
      goto LABEL_20;
    }
    MutableCopy = 0;
LABEL_19:
    v31 = a8;
LABEL_20:
    v35 = FigMetadataFormatDescriptionCreateWithKeysAndDependencies(a1, 1835360888, theArray, MutableCopy, v29, v31);
LABEL_21:
    v24 = v35;
    goto LABEL_22;
  }
  cf = 0;
  valuePtr[0] = 0;
  if (a6 && v17)
  {
    v25 = CFArrayGetCount(a6);
    MutableCopy = (__CFString *)CFArrayCreateMutableCopy(a1, v25 + v23, a6);
    v27 = CFDictionaryGetCount((CFDictionaryRef)v17);
    Mutable = CFDictionaryCreateMutableCopy(a1, v27 + capacity, (CFDictionaryRef)v17);
  }
  else
  {
    MutableCopy = (__CFString *)CFArrayCreateMutable(a1, v23 + v16, MEMORY[0x1E0C9B378]);
    if (v16 >= 1)
    {
      for (i = 0; i != v16; ++i)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
        Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("MetadataKeyLocalID"));
        if (Value)
          CFArrayAppendValue((CFMutableArrayRef)MutableCopy, Value);
      }
    }
    Mutable = CFDictionaryCreateMutable(a1, capacity, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  v29 = Mutable;
  v35 = FigMetadataFormatDescriptionCreateWithKeysAndDependencies(a1, 1835360888, theArray, 0, 0, (uint64_t *)&cf);
  if ((_DWORD)v35)
    goto LABEL_21;
  LODWORD(valuePtr[0]) = 0;
  valuePtr[1] = a1;
  valuePtr[2] = cf;
  valuePtr[3] = MutableCopy;
  valuePtr[4] = v29;
  valuePtr[5] = 0;
  v47.location = 0;
  v47.length = v23;
  CFArrayApplyFunction(a4, v47, (CFArrayApplierFunction)metadataFormatDescriptionCreateWithMetadataSpecifications2_arrayCallback, valuePtr);
  CFRelease(cf);
  v24 = LODWORD(valuePtr[0]);
  if (!LODWORD(valuePtr[0]))
    goto LABEL_19;
LABEL_22:
  if (v37)
    CFRelease(v37);
  if (v22)
    CFRelease(v22);
  if (MutableCopy)
    CFRelease(MutableCopy);
  if (v29)
    CFRelease(v29);
  return v24;
}

const __CFDictionary *FigMetadataFormatDescriptionGetLocalIDForMetadataIdentifyingFactors(const opaqueCMFormatDescription *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage;
  uint64_t v9;
  const __CFDictionary *result;
  _QWORD v11[3];
  uint64_t v12;

  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  if (a1
    && (v9 = DerivedStorage, CMFormatDescriptionGetMediaType(a1) == 1835365473)
    && CMFormatDescriptionGetMediaSubType(a1) == 1835360888
    && a2
    && a3)
  {
    v12 = 0;
    result = *(const __CFDictionary **)(v9 + 16);
    if (result)
    {
      v11[0] = a2;
      v11[1] = a3;
      v11[2] = a4;
      HIDWORD(v12) = 0;
      LOBYTE(v12) = 0;
      CFDictionaryApplyFunction(result, (CFDictionaryApplierFunction)figMetadataFormatDescriptionGetLocalIDForMetadataIdentifyingFactors_dictionaryCallback, v11);
      return (const __CFDictionary *)HIDWORD(v12);
    }
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

uint64_t figMetadataFormatDescriptionGetLocalIDForMetadataIdentifyingFactors_dictionaryCallback(uint64_t result, CFDictionaryRef theDict, uint64_t a3)
{
  int v5;
  const void *Value;
  const void *v7;
  const void *v8;

  if (!*(_DWORD *)(a3 + 28))
  {
    v5 = result;
    Value = CFDictionaryGetValue(theDict, CFSTR("MetadataIdentifier"));
    result = FigCFEqual(Value, *(CFTypeRef *)a3);
    if ((_DWORD)result)
    {
      if (*(_BYTE *)(a3 + 24)
        || (v7 = CFDictionaryGetValue(theDict, CFSTR("MetadataDataType")),
            result = FigCFEqual(v7, *(CFTypeRef *)(a3 + 8)),
            (_DWORD)result)
        && (v8 = CFDictionaryGetValue(theDict, CFSTR("MetadataExtendedLanguageTag")),
            result = FigCFEqual(v8, *(CFTypeRef *)(a3 + 16)),
            (_DWORD)result))
      {
        *(_DWORD *)(a3 + 28) = v5;
      }
    }
  }
  return result;
}

const __CFDictionary *FigMetadataFormatDescriptionGetFirstLocalIDForIdentifier(const opaqueCMFormatDescription *a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  const __CFDictionary *result;
  _QWORD v7[3];
  uint64_t v8;

  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  if (a1
    && (v5 = DerivedStorage, CMFormatDescriptionGetMediaType(a1) == 1835365473)
    && CMFormatDescriptionGetMediaSubType(a1) == 1835360888
    && a2)
  {
    v8 = 0;
    result = *(const __CFDictionary **)(v5 + 16);
    if (result)
    {
      HIDWORD(v8) = 0;
      v7[1] = 0;
      v7[2] = 0;
      v7[0] = a2;
      LOBYTE(v8) = 1;
      CFDictionaryApplyFunction(result, (CFDictionaryApplierFunction)figMetadataFormatDescriptionGetLocalIDForMetadataIdentifyingFactors_dictionaryCallback, v7);
      return (const __CFDictionary *)HIDWORD(v8);
    }
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

const void *FigMetadataFormatDescriptionGetIdentifierForLocalID(const opaqueCMFormatDescription *a1, unsigned int a2)
{
  return getIdentifyingFactorForLocalID(a1, a2, CFSTR("MetadataIdentifier"));
}

const void *getIdentifyingFactorForLocalID(const opaqueCMFormatDescription *a1, unsigned int a2, const void *a3)
{
  uint64_t DerivedStorage;
  uint64_t v7;
  const __CFDictionary *v8;
  const __CFDictionary *Value;

  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  if (a1
    && (v7 = DerivedStorage, CMFormatDescriptionGetMediaType(a1) == 1835365473)
    && CMFormatDescriptionGetMediaSubType(a1) == 1835360888
    && a2)
  {
    v8 = *(const __CFDictionary **)(v7 + 16);
    if (v8)
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue(v8, (const void *)a2);
      if (Value)
        return CFDictionaryGetValue(Value, a3);
    }
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

const void *FigMetadataFormatDescriptionGetDataTypeForLocalID(const opaqueCMFormatDescription *a1, unsigned int a2)
{
  return getIdentifyingFactorForLocalID(a1, a2, CFSTR("MetadataDataType"));
}

const void *FigMetadataFormatDescriptionGetLanguageTagForLocalID(const opaqueCMFormatDescription *a1, unsigned int a2)
{
  return getIdentifyingFactorForLocalID(a1, a2, CFSTR("MetadataExtendedLanguageTag"));
}

const void *FigMetadataFormatDescriptionGetConformingDataTypesForLocalID(const opaqueCMFormatDescription *a1, unsigned int a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  const __CFDictionary *v6;

  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  if (a1
    && (v5 = DerivedStorage, CMFormatDescriptionGetMediaType(a1) == 1835365473)
    && CMFormatDescriptionGetMediaSubType(a1) == 1835360888
    && a2)
  {
    v6 = *(const __CFDictionary **)(v5 + 24);
    if (v6)
      return CFDictionaryGetValue(v6, (const void *)a2);
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

const __CFDictionary *FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(const opaqueCMFormatDescription *a1, unsigned int a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  const __CFDictionary *result;

  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  if (a1
    && (v5 = DerivedStorage, CMFormatDescriptionGetMediaType(a1) == 1835365473)
    && CMFormatDescriptionGetMediaSubType(a1) == 1835360888
    && a2)
  {
    result = *(const __CFDictionary **)(v5 + 32);
    if (result)
    {
      result = (const __CFDictionary *)CFDictionaryGetCountOfKey(result, (const void *)a2);
      if (result)
        return (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 32), (const void *)a2);
    }
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

const void *FigMetadataFormatDescriptionGetSetupDataForLocalID(const opaqueCMFormatDescription *a1, unsigned int a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;
  const __CFDictionary *v6;
  const __CFDictionary *Value;

  DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  if (a1
    && (v5 = DerivedStorage, CMFormatDescriptionGetMediaType(a1) == 1835365473)
    && CMFormatDescriptionGetMediaSubType(a1) == 1835360888
    && a2)
  {
    v6 = *(const __CFDictionary **)(v5 + 8);
    if (v6)
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue(v6, (const void *)a2);
      if (Value)
        return CFDictionaryGetValue(Value, CFSTR("MetadataKeySetupData"));
    }
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigMetadataFormatDescriptionQuickTimeWellKnownTypeIsRecognized(const opaqueCMFormatDescription *a1, unsigned int a2)
{
  unsigned int QuickTimeWellKnownTypeForLocalID;
  signed int v5;
  uint64_t DerivedStorage;
  uint64_t v8;
  const __CFArray *v9;
  CFRange v10;

  QuickTimeWellKnownTypeForLocalID = FigMetadataFormatDescriptionGetQuickTimeWellKnownTypeForLocalID(a1, a2);
  if (QuickTimeWellKnownTypeForLocalID)
  {
    v5 = QuickTimeWellKnownTypeForLocalID;
    FigThreadRunOnce(&sFigMetadataFormatDescriptionCreateCanonicalToWellKnownTypeAssociationsOnce, FigMetadataFormatDescriptionCreateCanonicalToWellKnownTypeAssociationsOnce);
    return CFDictionaryContainsKey((CFDictionaryRef)sWellKnownTypeToCanonicalMap, (const void *)v5);
  }
  else
  {
    DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
    if (a1
      && (v8 = DerivedStorage, CMFormatDescriptionGetMediaType(a1) == 1835365473)
      && CMFormatDescriptionGetMediaSubType(a1) == 1835360888
      && a2)
    {
      v9 = *(const __CFArray **)(v8 + 40);
      if (v9)
      {
        v10.length = CFArrayGetCount(*(CFArrayRef *)(v8 + 40));
        v10.location = 0;
        return CFArrayContainsValue(v9, v10, (const void *)a2) == 0;
      }
      else
      {
        return 1;
      }
    }
    else
    {
      FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
      return 0;
    }
  }
}

OSStatus CMMetadataFormatDescriptionCreateWithMetadataFormatDescriptionAndMetadataSpecifications(CFAllocatorRef allocator, CMMetadataFormatDescriptionRef sourceDescription, CFArrayRef metadataSpecifications, CMMetadataFormatDescriptionRef *formatDescriptionOut)
{
  const __CFDictionary *Extensions;
  const __CFDictionary *v9;
  const __CFDictionary *Value;
  const __CFArray *v11;
  const void *v12;
  const void *v13;
  CFIndex Count;
  CFMutableArrayRef Mutable;
  const __CFArray *v16;
  CFIndex v17;
  CFIndex v18;
  CFMutableArrayRef v19;
  const __CFArray *v20;
  OSStatus v21;
  const __CFArray *v22;
  uint64_t v23;
  CFMutableArrayRef v25;
  uint64_t v26;
  _QWORD context[2];
  CFRange v28;

  if (!metadataSpecifications)
  {
    v23 = 4294954586;
    return FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
  }
  if (!sourceDescription
    || CMFormatDescriptionGetMediaSubType(sourceDescription) != 1835360888
    || (Extensions = CMFormatDescriptionGetExtensions(sourceDescription)) == 0
    || (v9 = Extensions,
        Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("MetadataKeyTable")),
        v11 = (const __CFArray *)CFDictionaryGetValue(v9, CFSTR("MetadataPrimaryLocalIDs")),
        v12 = CFDictionaryGetValue(v9, CFSTR("MetadataLocalIDDependencyLists")),
        !Value))
  {
    v23 = 4294954586;
    return FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
  }
  v13 = v12;
  Count = CFArrayGetCount(metadataSpecifications);
  Mutable = CFArrayCreateMutable(allocator, Count, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    v23 = 4294954585;
    return FigSignalErrorAt(v23, 0, 0, 0, 0, 0, 0);
  }
  v16 = Mutable;
  v26 = 0;
  context[0] = sourceDescription;
  context[1] = Mutable;
  v28.length = CFArrayGetCount(metadataSpecifications);
  v28.location = 0;
  CFArrayApplyFunction(metadataSpecifications, v28, (CFArrayApplierFunction)figMetadataFormatDescriptionCreateWithMetadataFormatDescriptionAndMetadataSpecifications_arrayCallback, context);
  if (!CFArrayGetCount(v16))
  {
    v21 = 0;
    *formatDescriptionOut = (CMMetadataFormatDescriptionRef)CFRetain(sourceDescription);
LABEL_13:
    v22 = v16;
    goto LABEL_14;
  }
  v17 = CFArrayGetCount(metadataSpecifications);
  v18 = CFDictionaryGetCount(Value);
  v19 = CFArrayCreateMutable(allocator, v18 + v17, MEMORY[0x1E0C9B378]);
  if (!v19)
  {
    v21 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
    goto LABEL_13;
  }
  v20 = v19;
  v25 = v19;
  LODWORD(v26) = 0;
  CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)figMetadataFormatDescriptionCreateWithMetadataFormatDescriptionAndMetadataSpecifications_dictionaryCallback, &v25);
  v21 = metadataFormatDescriptionCreateWithMetadataSpecifications(allocator, 1835360888, (int)v26 + 1, v16, v20, v11, v13, (uint64_t *)formatDescriptionOut);
  CFRelease(v16);
  v22 = v20;
LABEL_14:
  CFRelease(v22);
  return v21;
}

void figMetadataFormatDescriptionCreateWithMetadataFormatDescriptionAndMetadataSpecifications_arrayCallback(const __CFDictionary *a1, const opaqueCMFormatDescription **a2)
{
  const opaqueCMFormatDescription *v4;
  const void *Value;
  const void *v6;
  const void *v7;

  v4 = *a2;
  Value = CFDictionaryGetValue(a1, CFSTR("MetadataIdentifier"));
  v6 = CFDictionaryGetValue(a1, CFSTR("MetadataDataType"));
  v7 = CFDictionaryGetValue(a1, CFSTR("MetadataExtendedLanguageTag"));
  if (!FigMetadataFormatDescriptionGetLocalIDForMetadataIdentifyingFactors(v4, (uint64_t)Value, (uint64_t)v6, (uint64_t)v7))CFArrayAppendValue(a2[1], a1);
}

void figMetadataFormatDescriptionCreateWithMetadataFormatDescriptionAndMetadataSpecifications_dictionaryCallback(const __CFString *a1, const void *a2, uint64_t a3)
{
  CFTypeID TypeID;
  SInt32 IntValue;
  CFTypeID v8;
  int valuePtr;

  valuePtr = -1;
  TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    IntValue = CFStringGetIntValue(a1);
LABEL_5:
    valuePtr = IntValue;
    goto LABEL_7;
  }
  v8 = CFNumberGetTypeID();
  if (v8 == CFGetTypeID(a1))
  {
    IntValue = CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr);
    goto LABEL_5;
  }
  IntValue = -1;
LABEL_7:
  if (*(_DWORD *)(a3 + 8) < IntValue)
    *(_DWORD *)(a3 + 8) = IntValue;
  if (a2)
    CFArrayAppendValue(*(CFMutableArrayRef *)a3, a2);
}

OSStatus CMMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions(CFAllocatorRef allocator, CMMetadataFormatDescriptionRef sourceDescription, CMMetadataFormatDescriptionRef otherSourceDescription, CMMetadataFormatDescriptionRef *formatDescriptionOut)
{
  FourCharCode MediaSubType;
  FourCharCode v9;
  OSStatus v10;
  const __CFDictionary *Extensions;
  const __CFDictionary *v13;
  const __CFDictionary *Value;
  const __CFArray *v15;
  const __CFDictionary *v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  const __CFArray *v19;
  CFIndex Count;
  CFIndex v21;
  CFMutableArrayRef Mutable;
  const __CFArray *v23;
  CFMutableDictionaryRef v24;
  CFMutableDictionaryRef v25;
  CFIndex v26;
  CFIndex v27;
  CFIndex v28;
  const __CFArray *MutableCopy;
  CFIndex v30;
  CFMutableDictionaryRef v31;
  void *v32;
  uint64_t v33;
  CFIndex v34;
  CFIndex v35;
  CFMutableDictionaryRef v36;
  CFIndex v37;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v40;
  const __CFDictionary *v41;
  const __CFDictionary *theDict;
  CFMutableDictionaryRef v43;
  _QWORD v44[4];
  const __CFArray *v45;
  CFMutableDictionaryRef v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  CFMutableArrayRef context;
  uint64_t v52;
  CFRange v53;

  if (sourceDescription)
  {
    MediaSubType = CMFormatDescriptionGetMediaSubType(sourceDescription);
    if (!otherSourceDescription)
      goto LABEL_24;
    v9 = MediaSubType;
    if (MediaSubType != CMFormatDescriptionGetMediaSubType(otherSourceDescription))
      goto LABEL_24;
    if (v9 == 1768126752 || v9 == 1768174368 || CMFormatDescriptionEqual(sourceDescription, otherSourceDescription))
    {
      v10 = 0;
      *formatDescriptionOut = (CMMetadataFormatDescriptionRef)CFRetain(sourceDescription);
      return v10;
    }
    if (v9 != 1835360888)
      goto LABEL_24;
    Extensions = CMFormatDescriptionGetExtensions(sourceDescription);
    if (!Extensions)
      goto LABEL_24;
    v13 = Extensions;
    Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("MetadataKeyTable"));
    v15 = (const __CFArray *)CFDictionaryGetValue(v13, CFSTR("MetadataPrimaryLocalIDs"));
    v41 = (const __CFDictionary *)CFDictionaryGetValue(v13, CFSTR("MetadataLocalIDDependencyLists"));
    if (!Value)
      goto LABEL_24;
    v16 = CMFormatDescriptionGetExtensions(otherSourceDescription);
    if (v16
      && (v17 = v16,
          v18 = (const __CFDictionary *)CFDictionaryGetValue(v16, CFSTR("MetadataKeyTable")),
          v19 = (const __CFArray *)CFDictionaryGetValue(v17, CFSTR("MetadataPrimaryLocalIDs")),
          theDict = (const __CFDictionary *)CFDictionaryGetValue(v17, CFSTR("MetadataLocalIDDependencyLists")),
          v18))
    {
      Count = CFDictionaryGetCount(v18);
      v21 = CFDictionaryGetCount(Value);
      Mutable = CFArrayCreateMutable(allocator, v21 + Count, MEMORY[0x1E0C9B378]);
      if (Mutable)
      {
        v23 = Mutable;
        v47 = 0u;
        v48 = 0u;
        v49 = 0u;
        v50 = 0;
        v45 = 0;
        v46 = 0;
        context = Mutable;
        v52 = 0;
        CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback1, &context);
        v43 = CFDictionaryCreateMutable(allocator, Count, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (!v43
          || (v24 = CFDictionaryCreateMutable(allocator, Count, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0])) == 0)
        {
          v10 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
          v25 = 0;
          v32 = v23;
          v36 = v43;
LABEL_43:
          CFRelease(v32);
LABEL_44:
          if (v36)
            CFRelease(v36);
          if (v25)
            CFRelease(v25);
          return v10;
        }
        v25 = v24;
        *(_QWORD *)&v47 = allocator;
        *((_QWORD *)&v47 + 1) = v23;
        *(_QWORD *)&v48 = sourceDescription;
        *((_QWORD *)&v48 + 1) = otherSourceDescription;
        LODWORD(v50) = v52 + 1;
        *(_QWORD *)&v49 = v43;
        *((_QWORD *)&v49 + 1) = v24;
        CFDictionaryApplyFunction(v18, (CFDictionaryApplierFunction)figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback2, &v47);
        if (v19 && theDict)
        {
          v26 = CFArrayGetCount(v19);
          v27 = CFDictionaryGetCount(theDict);
          if (!v15 || !v41)
          {
            v37 = CFDictionaryGetCount(Value);
            MutableCopy = CFArrayCreateMutable(allocator, v37 + v26, MEMORY[0x1E0C9B378]);
            v32 = CFDictionaryCreateMutable(allocator, v27, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v45 = MutableCopy;
            v46 = 0;
            CFDictionaryApplyFunction(Value, (CFDictionaryApplierFunction)figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback3, &v45);
            goto LABEL_32;
          }
          v28 = CFArrayGetCount(v15);
          MutableCopy = CFArrayCreateMutableCopy(allocator, v28 + v26, v15);
          if (MutableCopy)
          {
            v30 = CFDictionaryGetCount(v41);
            v31 = CFDictionaryCreateMutableCopy(allocator, v30 + v27, v41);
            if (v31)
            {
              v32 = v31;
LABEL_32:
              if (v26 >= 1)
              {
                for (i = 0; i != v26; ++i)
                {
                  ValueAtIndex = CFArrayGetValueAtIndex(v19, i);
                  v40 = CFDictionaryGetValue(v25, ValueAtIndex);
                  if (v40)
                    ValueAtIndex = v40;
                  v53.length = CFArrayGetCount(MutableCopy);
                  v53.location = 0;
                  if (!CFArrayContainsValue(MutableCopy, v53, ValueAtIndex))
                    CFArrayAppendValue(MutableCopy, ValueAtIndex);
                }
              }
              v44[0] = allocator;
              v44[1] = v32;
              v36 = v43;
              v44[2] = v43;
              v44[3] = v25;
              CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback4, v44);
              v10 = FigMetadataFormatDescriptionCreateWithKeysAndDependencies(allocator, 1835360888, v23, (const __CFString *)MutableCopy, v32, (uint64_t *)formatDescriptionOut);
LABEL_40:
              CFRelease(v23);
              if (MutableCopy)
                CFRelease(MutableCopy);
              if (!v32)
                goto LABEL_44;
              goto LABEL_43;
            }
          }
          v10 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
          v32 = 0;
        }
        else
        {
          MutableCopy = 0;
          v32 = 0;
          if (v15 && v41)
          {
            v34 = CFArrayGetCount(v15);
            v35 = CFDictionaryGetCount(v18);
            MutableCopy = CFArrayCreateMutableCopy(allocator, v35 + v34, v15);
            v32 = (void *)CFRetain(v41);
            v45 = MutableCopy;
            v46 = v25;
            CFDictionaryApplyFunction(v18, (CFDictionaryApplierFunction)figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback3, &v45);
          }
          v10 = FigMetadataFormatDescriptionCreateWithKeysAndDependencies(allocator, 1835360888, v23, (const __CFString *)MutableCopy, v32, (uint64_t *)formatDescriptionOut);
        }
        v36 = v43;
        goto LABEL_40;
      }
      v33 = 4294954585;
    }
    else
    {
LABEL_24:
      v33 = 4294954586;
    }
  }
  else
  {
    v33 = 4294954586;
  }
  return FigSignalErrorAt(v33, 0, 0, 0, 0, 0, 0);
}

void figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback1(const __CFString *a1, const void *a2, uint64_t a3)
{
  CFTypeID TypeID;
  SInt32 IntValue;
  CFTypeID v8;
  int valuePtr;

  valuePtr = -1;
  TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    IntValue = CFStringGetIntValue(a1);
LABEL_5:
    valuePtr = IntValue;
    goto LABEL_7;
  }
  v8 = CFNumberGetTypeID();
  if (v8 == CFGetTypeID(a1))
  {
    IntValue = CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr);
    goto LABEL_5;
  }
  IntValue = -1;
LABEL_7:
  if (*(_DWORD *)(a3 + 8) < IntValue)
    *(_DWORD *)(a3 + 8) = IntValue;
  if (a2)
    CFArrayAppendValue(*(CFMutableArrayRef *)a3, a2);
}

void figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback2(const __CFString *a1, const __CFDictionary *a2, uint64_t a3)
{
  CFTypeID TypeID;
  SInt32 IntValue;
  CFTypeID v8;
  unsigned int v9;
  const opaqueCMFormatDescription *v10;
  const void *IdentifyingFactorForLocalID;
  const void *v12;
  const void *v13;
  const __CFDictionary *LocalIDForMetadataIdentifyingFactors;
  int v15;
  const __CFDictionary *v16;
  __CFDictionary *MutableCopy;
  CFStringRef v18;
  CFNumberRef v19;
  __CFDictionary *v20;
  const void *Value;
  const __CFAllocator *v22;
  CFIndex Count;
  uint64_t v24;

  HIDWORD(v24) = -1;
  TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    IntValue = CFStringGetIntValue(a1);
LABEL_5:
    v9 = IntValue;
    HIDWORD(v24) = IntValue;
    goto LABEL_7;
  }
  v8 = CFNumberGetTypeID();
  if (v8 == CFGetTypeID(a1))
  {
    IntValue = CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, (char *)&v24 + 4);
    goto LABEL_5;
  }
  v9 = -1;
LABEL_7:
  v10 = *(const opaqueCMFormatDescription **)(a3 + 16);
  IdentifyingFactorForLocalID = getIdentifyingFactorForLocalID(*(const opaqueCMFormatDescription **)(a3 + 24), v9, CFSTR("MetadataIdentifier"));
  v12 = getIdentifyingFactorForLocalID(*(const opaqueCMFormatDescription **)(a3 + 24), HIDWORD(v24), CFSTR("MetadataDataType"));
  v13 = getIdentifyingFactorForLocalID(*(const opaqueCMFormatDescription **)(a3 + 24), HIDWORD(v24), CFSTR("MetadataExtendedLanguageTag"));
  LocalIDForMetadataIdentifyingFactors = FigMetadataFormatDescriptionGetLocalIDForMetadataIdentifyingFactors(v10, (uint64_t)IdentifyingFactorForLocalID, (uint64_t)v12, (uint64_t)v13);
  v15 = (int)LocalIDForMetadataIdentifyingFactors;
  if ((_DWORD)LocalIDForMetadataIdentifyingFactors)
  {
    LODWORD(v24) = (_DWORD)LocalIDForMetadataIdentifyingFactors;
    v16 = LocalIDForMetadataIdentifyingFactors;
    if ((_DWORD)LocalIDForMetadataIdentifyingFactors == HIDWORD(v24))
      return;
LABEL_13:
    v18 = CFStringCreateWithFormat(*(CFAllocatorRef *)a3, 0, CFSTR("%d"), v16, v24);
    v19 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &v24);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 32), a1, v18);
    v20 = *(__CFDictionary **)(a3 + 40);
    Value = CFDictionaryGetValue(a2, CFSTR("MetadataKeyLocalID"));
    CFDictionarySetValue(v20, Value, v19);
    MutableCopy = 0;
    if (!v15)
    {
      v22 = *(const __CFAllocator **)a3;
      Count = CFDictionaryGetCount(a2);
      MutableCopy = CFDictionaryCreateMutableCopy(v22, Count, a2);
      CFDictionarySetValue(MutableCopy, CFSTR("MetadataKeyLocalID"), v19);
    }
    CFRelease(v18);
    CFRelease(v19);
    if (MutableCopy)
      goto LABEL_16;
    return;
  }
  v16 = (const __CFDictionary *)*(unsigned int *)(a3 + 48);
  *(_DWORD *)(a3 + 48) = (_DWORD)v16 + 1;
  LODWORD(v24) = (_DWORD)v16;
  if ((_DWORD)v16 != HIDWORD(v24))
    goto LABEL_13;
  MutableCopy = (__CFDictionary *)CFRetain(a2);
  if (MutableCopy)
  {
LABEL_16:
    CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 8), MutableCopy);
    CFRelease(MutableCopy);
  }
}

void figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback3(int a1, CFDictionaryRef theDict, const __CFArray **a3)
{
  const void *Value;
  const __CFDictionary *v5;
  const __CFArray *v6;
  CFRange v7;

  Value = CFDictionaryGetValue(theDict, CFSTR("MetadataKeyLocalID"));
  v5 = a3[1];
  if (v5)
    v5 = (const __CFDictionary *)CFDictionaryGetValue(v5, Value);
  if (v5)
    Value = v5;
  v6 = *a3;
  v7.length = CFArrayGetCount(*a3);
  v7.location = 0;
  if (!CFArrayContainsValue(v6, v7, Value))
    CFArrayAppendValue(*a3, Value);
}

void figMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions_dictionaryCallback4(const void *a1, CFArrayRef theArray, CFAllocatorRef *a3)
{
  uint64_t Count;
  const __CFArray *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  const void *Value;
  const void *v11;
  __CFArray *v12;
  const void *v13;
  const __CFArray *v14;
  const __CFArray *v15;
  CFIndex v16;
  CFIndex v17;
  __CFArray *MutableCopy;
  CFIndex j;
  const void *v20;
  CFRange v21;

  Count = CFArrayGetCount(theArray);
  Mutable = CFArrayCreateMutable(*a3, Count, MEMORY[0x1E0C9B378]);
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
      Value = CFDictionaryGetValue(a3[3], ValueAtIndex);
      if (Value)
      {
        v11 = Value;
        v12 = Mutable;
      }
      else
      {
        v12 = Mutable;
        v11 = ValueAtIndex;
      }
      CFArrayAppendValue(v12, v11);
    }
  }
  v13 = CFDictionaryGetValue(a3[2], a1);
  if (v13)
    a1 = v13;
  v14 = (const __CFArray *)CFDictionaryGetValue(a3[1], a1);
  if (v14)
  {
    v15 = v14;
    v16 = CFArrayGetCount(v14);
    v17 = CFArrayGetCount(Mutable);
    MutableCopy = CFArrayCreateMutableCopy(*a3, v17 + v16, v15);
    if (v17 >= 1)
    {
      for (j = 0; j != v17; ++j)
      {
        v20 = CFArrayGetValueAtIndex(Mutable, j);
        v21.location = 0;
        v21.length = v16;
        if (!CFArrayContainsValue(v15, v21, v20))
          CFArrayAppendValue(MutableCopy, v20);
      }
    }
    CFDictionarySetValue(a3[1], a1, MutableCopy);
    CFRelease(MutableCopy);
  }
  else
  {
    CFDictionarySetValue(a3[1], a1, Mutable);
  }
  CFRelease(Mutable);
}

CFDictionaryRef CMMetadataFormatDescriptionGetKeyWithLocalID(CMMetadataFormatDescriptionRef desc, OSType localKeyID)
{
  uint64_t DerivedStorage;
  const __CFDictionary *v5;

  if (desc
    && CMFormatDescriptionGetMediaType(desc) == 1835365473
    && CMFormatDescriptionGetMediaSubType(desc) == 1835360888)
  {
    DerivedStorage = FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)desc);
    if (DerivedStorage)
    {
      v5 = *(const __CFDictionary **)(DerivedStorage + 8);
      if (v5)
        return (CFDictionaryRef)CFDictionaryGetValue(v5, (const void *)localKeyID);
    }
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

CFArrayRef CMMetadataFormatDescriptionGetIdentifiers(CMMetadataFormatDescriptionRef desc)
{
  CFArrayRef result;

  if (desc
    && CMFormatDescriptionGetMediaType(desc) == 1835365473
    && CMFormatDescriptionGetMediaSubType(desc) == 1835360888)
  {
    result = (CFArrayRef)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)desc);
    if (result)
      return *(CFArrayRef *)result;
  }
  else
  {
    FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return result;
}

void figMetadataFormatDescriptionFinalize(uint64_t a1)
{
  const void **DerivedStorage;
  const void **v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  DerivedStorage = (const void **)FigDerivedFormatDescriptionGetDerivedStorage(a1);
  if (DerivedStorage)
  {
    v2 = DerivedStorage;
    v3 = *DerivedStorage;
    if (v3)
      CFRelease(v3);
    v4 = v2[1];
    if (v4)
      CFRelease(v4);
    v5 = v2[2];
    if (v5)
      CFRelease(v5);
    v6 = v2[3];
    if (v6)
      CFRelease(v6);
    v7 = v2[4];
    if (v7)
      CFRelease(v7);
    v8 = v2[5];
    if (v8)
      CFRelease(v8);
  }
}

__CFString *figMetadataFormatDescriptionCopyDebugDesc(const void *a1)
{
  _QWORD *DerivedStorage;
  const __CFAllocator *v3;
  __CFString *Mutable;
  __CFString *v5;

  DerivedStorage = (_QWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  v3 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v3, 0);
  v5 = Mutable;
  if (*DerivedStorage)
    CFStringAppendFormat(Mutable, 0, CFSTR("\t\tidentifierToDataTypes %p"), *DerivedStorage);
  if (DerivedStorage[1])
    CFStringAppendFormat(v5, 0, CFSTR("\t\tlocalKeyIDToKeyEntryMapping %p"), DerivedStorage[1]);
  if (DerivedStorage[2])
    CFStringAppendFormat(v5, 0, CFSTR("\t\tlocalKeyIDToMetadataSpecificationMapping %p"), DerivedStorage[2]);
  if (DerivedStorage[3])
    CFStringAppendFormat(v5, 0, CFSTR("\t\tlocalKeyIDToConformingDataTypes %p"), DerivedStorage[3]);
  if (DerivedStorage[4])
    CFStringAppendFormat(v5, 0, CFSTR("\t\tlocalKeyIDToQuickTimeWellKnownTypeMapping %p"), DerivedStorage[4]);
  if (DerivedStorage[5])
    CFStringAppendFormat(v5, 0, CFSTR("\t\tlocalKeyIDsThatDoNotHaveAWellKnownType %p"), DerivedStorage[5]);
  return v5;
}

uint64_t figMetadataFormatDescriptionEqual(const opaqueCMFormatDescription *a1, const opaqueCMFormatDescription *a2, unint64_t a3, unint64_t a4)
{
  CFTypeRef *DerivedStorage;
  const __CFDictionary *Extensions;
  CFTypeRef *v10;
  const __CFDictionary *v11;
  uint64_t result;

  DerivedStorage = (CFTypeRef *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  Extensions = CMFormatDescriptionGetExtensions(a1);
  v10 = (CFTypeRef *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a2);
  v11 = CMFormatDescriptionGetExtensions(a2);
  result = FigCFEqual(*DerivedStorage, *v10);
  if ((_DWORD)result)
  {
    result = FigCFEqual(DerivedStorage[1], v10[1]);
    if ((_DWORD)result)
    {
      result = FigCFEqual(DerivedStorage[2], v10[2]);
      if ((_DWORD)result)
      {
        result = FigCFEqual(DerivedStorage[3], v10[3]);
        if ((_DWORD)result)
        {
          result = FigCFEqual(DerivedStorage[4], v10[4]);
          if ((_DWORD)result)
          {
            result = FigCFEqual(DerivedStorage[5], v10[5]);
            if ((_DWORD)result)
              return FigFormatDescriptionExtensionsDictionariesEqualIgnoringKeys(Extensions, v11, a3, a4) != 0;
          }
        }
      }
    }
  }
  return result;
}

void FigMetadataFormatDescriptionCreateCanonicalToWellKnownTypeAssociationsOnce()
{
  const __CFAllocator *v0;
  const CFDictionaryValueCallBacks *v1;
  uint64_t v2;
  CFDataRef v3;
  UInt8 bytes[4];
  const __CFString *v5;
  int v6;
  const __CFString *v7;
  int v8;
  const __CFString *v9;
  int v10;
  const __CFString *v11;
  int v12;
  const __CFString *v13;
  int v14;
  const __CFString *v15;
  int v16;
  const __CFString *v17;
  int v18;
  const __CFString *v19;
  int v20;
  const __CFString *v21;
  int v22;
  const __CFString *v23;
  int v24;
  const __CFString *v25;
  int v26;
  const __CFString *v27;
  int v28;
  const __CFString *v29;
  int v30;
  const __CFString *v31;
  int v32;
  const __CFString *v33;
  int v34;
  const __CFString *v35;
  int v36;
  const __CFString *v37;
  int v38;
  const __CFString *v39;
  int v40;
  const __CFString *v41;
  int v42;
  const __CFString *v43;
  int v44;
  const __CFString *v45;
  int v46;
  const __CFString *v47;
  int v48;
  const __CFString *v49;
  int v50;
  const __CFString *v51;
  int v52;
  const __CFString *v53;
  int v54;
  const __CFString *v55;
  int v56;
  const __CFString *v57;
  int v58;
  const __CFString *v59;
  int v60;
  const __CFString *v61;
  int v62;
  const __CFString *v63;
  int v64;
  const __CFString *v65;
  int v66;
  const __CFString *v67;
  int v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  v5 = CFSTR("com.apple.metadata.datatype.raw-data");
  v6 = 0;
  v7 = CFSTR("com.apple.metadata.datatype.UTF-8");
  v8 = 1;
  v9 = CFSTR("com.apple.metadata.datatype.UTF-16");
  v10 = 2;
  v11 = CFSTR("com.apple.metadata.datatype.UTF-8-sort");
  v12 = 4;
  v13 = CFSTR("com.apple.metadata.datatype.UTF-16-sort");
  v14 = 5;
  v15 = CFSTR("com.apple.metadata.datatype.GIF");
  v16 = 12;
  v17 = CFSTR("com.apple.metadata.datatype.JPEG");
  v18 = 13;
  v19 = CFSTR("com.apple.metadata.datatype.PNG");
  v21 = CFSTR("com.apple.metadata.datatype.UPC");
  v20 = 14;
  v22 = 25;
  v23 = CFSTR("com.apple.metadata.datatype.BMP");
  v25 = CFSTR("com.apple.metadata.datatype.QuickTime-metadata-box");
  v24 = 27;
  v26 = 28;
  v27 = CFSTR("com.apple.metadata.datatype.float32");
  v29 = CFSTR("com.apple.metadata.datatype.float64");
  v28 = 23;
  v30 = 24;
  v31 = CFSTR("com.apple.metadata.datatype.pixel-density");
  v33 = CFSTR("com.apple.metadata.datatype.int8");
  v32 = 30;
  v34 = 65;
  v35 = CFSTR("com.apple.metadata.datatype.int16");
  v37 = CFSTR("com.apple.metadata.datatype.int32");
  v36 = 66;
  v38 = 67;
  v39 = CFSTR("com.apple.metadata.datatype.int64");
  v40 = 74;
  v41 = CFSTR("com.apple.metadata.datatype.uint8");
  v42 = 75;
  v43 = CFSTR("com.apple.metadata.datatype.uint16");
  v44 = 76;
  v45 = CFSTR("com.apple.metadata.datatype.uint32");
  v46 = 77;
  v47 = CFSTR("com.apple.metadata.datatype.uint64");
  v48 = 78;
  v49 = CFSTR("com.apple.metadata.datatype.array-collection");
  v50 = 68;
  v51 = CFSTR("com.apple.metadata.datatype.record-collection");
  v52 = 69;
  v53 = CFSTR("com.apple.metadata.datatype.point-float32");
  v54 = 70;
  v55 = CFSTR("com.apple.metadata.datatype.dimensions-float32");
  v56 = 71;
  v57 = CFSTR("com.apple.metadata.datatype.rectangle-float32");
  v58 = 72;
  v59 = CFSTR("com.apple.metadata.affine-transform-float64");
  v60 = 79;
  v61 = CFSTR("com.apple.metadata.datatype.polygon-float32");
  v62 = 80;
  v63 = CFSTR("com.apple.metadata.datatype.polyline-float32");
  v64 = 81;
  v65 = CFSTR("com.apple.metadata.datatype.JSON");
  v66 = 82;
  v67 = CFSTR("com.apple.metadata.perspective-transform-float64");
  v68 = 83;
  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v1 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  sCanonicalToWellKnownTypeMap = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 32, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v2 = 0;
  sWellKnownTypeToCanonicalMap = (uint64_t)CFDictionaryCreateMutable(v0, 32, 0, v1);
  do
  {
    *(_DWORD *)bytes = bswap32(*(_DWORD *)((char *)&v5 + v2 + 8));
    v3 = CFDataCreate(v0, bytes, 4);
    CFDictionarySetValue((CFMutableDictionaryRef)sCanonicalToWellKnownTypeMap, *(const __CFString **)((char *)&v5 + v2), v3);
    CFDictionarySetValue((CFMutableDictionaryRef)sWellKnownTypeToCanonicalMap, (const void *)*(int *)((char *)&v5 + v2 + 8), *(const __CFString **)((char *)&v5 + v2));
    CFRelease(v3);
    v2 += 16;
  }
  while (v2 != 512);
}

void metadataFormatDescriptionCreateWithMetadataSpecifications1_arrayCallback(const void *a1, uint64_t a2)
{
  CFTypeID TypeID;
  const __CFAllocator *v5;
  int v6;
  int v7;
  const __CFArray *v8;
  CFIndex Count;
  const __CFString *Value;
  const __CFString *v11;
  CFTypeID v12;
  const __CFString *v13;
  const __CFString *v14;
  CFTypeID v15;
  const void *v16;
  CFTypeID v17;
  const void *v18;
  CFTypeID v19;
  const void *v20;
  CFTypeID v21;
  const __CFArray *v22;
  const __CFArray *v23;
  CFTypeID v24;
  CFIndex v25;
  const __CFArray *ConformingDataTypes;
  const __CFString *v27;
  CFStringRef BaseDataTypeForConformingDataType;
  const __CFString *v29;
  CFStringRef v30;
  const __CFData *v31;
  CFDataRef Copy;
  CFIndex v33;
  const __CFString *ValueAtIndex;
  CFStringRef v35;
  uint64_t v36;
  unsigned int QTWellKnownTypeFromDynamicBaseDataType;
  CFDataRef v38;
  OSStatus v39;
  int v40;
  int KeySpaceAsOSTypeFromIdentifier;
  const __CFAllocator *v42;
  CFNumberRef v43;
  CFNumberRef v44;
  uint64_t v45;
  CFIndex i;
  const __CFDictionary *v47;
  const void *v48;
  CFDataRef v49;
  const void *v50;
  const void *v51;
  const void *v52;
  const void *v53;
  const void *v54;
  const void *v55;
  uint64_t v56;
  uint64_t v57;
  CFIndex v58;
  const void *v59;
  const CFDictionaryKeyCallBacks *v60;
  const CFDictionaryValueCallBacks *v61;
  const __CFString *v62;
  void *v63;
  const __CFAllocator *v64;
  const __CFString *v65;
  CFDictionaryRef v66;
  CFDictionaryRef v67;
  void *v68;
  void *v69;
  void *v70;
  CFIndex v71;
  const void *v72;
  CFNumberRef v73;
  CFNumberRef v74;
  __CFArray *v75;
  CFDictionaryRef v76;
  const __CFArray *v77;
  const __CFArray *v78;
  CFTypeID v79;
  uint64_t v80;
  __int128 v81;
  int v82;
  CFIndex v83;
  CFNumberRef v84;
  const void *v85;
  void *v86;
  CFTypeRef v87;
  CFTypeRef v88;
  CFTypeRef ExternalRepresentation;
  CFTypeRef v90;
  const void *v91;
  const __CFData *cf;
  const void *v93;
  const __CFString *dataType;
  __CFArray *dataTypea;
  CFNumberRef cf1;
  const __CFArray *theArray;
  CFDataRef keyOut;
  int valuePtr;
  int v100;
  void *values[2];
  void *keys[2];
  void *v103[4];
  __int128 v104;
  __int128 v105;
  uint64_t v106;
  UInt8 bytes[16];
  __int128 v108;
  __int128 v109;
  __int128 v110;
  uint64_t v111;
  uint64_t v112;
  CFRange v113;

  v112 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a2)
    return;
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(a1))
    goto LABEL_115;
  v5 = *(const __CFAllocator **)(a2 + 8);
  v6 = *(_DWORD *)(a2 + 16);
  v7 = *(_DWORD *)(a2 + 20);
  v93 = *(const void **)(a2 + 24);
  v8 = *(const __CFArray **)(a2 + 40);
  v91 = *(const void **)(a2 + 32);
  valuePtr = 0;
  v100 = v6;
  theArray = v8;
  keyOut = 0;
  Count = CFArrayGetCount(v8);
  Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("MetadataIdentifier"));
  if (!Value)
    goto LABEL_30;
  v11 = Value;
  v12 = CFStringGetTypeID();
  if (v12 != CFGetTypeID(v11))
    goto LABEL_30;
  v13 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("MetadataDataType"));
  if (!v13)
    goto LABEL_30;
  v14 = v13;
  v15 = CFStringGetTypeID();
  if (v15 != CFGetTypeID(v14))
    goto LABEL_30;
  v16 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("MetadataExtendedLanguageTag"));
  if (v16)
  {
    v17 = CFStringGetTypeID();
    if (v17 != CFGetTypeID(v16))
      goto LABEL_30;
  }
  dataType = v14;
  v18 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("StructuralDependency"));
  if (v18)
  {
    v19 = CFDictionaryGetTypeID();
    if (v19 != CFGetTypeID(v18))
      goto LABEL_30;
  }
  v20 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("MetadataKeySetupData"));
  if (v20)
  {
    v21 = CFDataGetTypeID();
    if (v21 != CFGetTypeID(v20))
      goto LABEL_30;
  }
  v87 = v20;
  v22 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("MetadataConformingDataTypes"));
  v88 = v16;
  v86 = (void *)v18;
  if (v22)
  {
    v23 = v22;
    v24 = CFArrayGetTypeID();
    if (v24 == CFGetTypeID(v23))
    {
      v25 = CFArrayGetCount(v23);
      if (v25)
        ConformingDataTypes = v23;
      else
        ConformingDataTypes = 0;
      v27 = dataType;
      BaseDataTypeForConformingDataType = CMMetadataDataTypeRegistryGetBaseDataTypeForConformingDataType(dataType);
      if (BaseDataTypeForConformingDataType)
      {
        v29 = BaseDataTypeForConformingDataType;
        goto LABEL_23;
      }
      if (v25 >= 1)
      {
        v33 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ConformingDataTypes, v33);
          v35 = CMMetadataDataTypeRegistryGetBaseDataTypeForConformingDataType(ValueAtIndex);
          if (v35)
            break;
          if (v25 == ++v33)
            goto LABEL_30;
        }
        v29 = v35;
        v27 = dataType;
        if (v7 != 1835360888)
          goto LABEL_72;
        goto LABEL_24;
      }
    }
LABEL_30:
    v36 = 4294954586;
LABEL_73:
    v40 = FigSignalErrorAt(v36, 0, 0, 0, 0, 0, 0);
    v72 = 0;
    v75 = 0;
    v59 = 0;
    v38 = 0;
    goto LABEL_74;
  }
  v30 = CMMetadataDataTypeRegistryGetBaseDataTypeForConformingDataType(dataType);
  if (!v30)
    goto LABEL_30;
  v29 = v30;
  ConformingDataTypes = 0;
  v27 = dataType;
LABEL_23:
  if (v7 != 1835360888)
    goto LABEL_72;
LABEL_24:
  FigThreadRunOnce(&sFigMetadataFormatDescriptionCreateCanonicalToWellKnownTypeAssociationsOnce, FigMetadataFormatDescriptionCreateCanonicalToWellKnownTypeAssociationsOnce);
  v31 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)sCanonicalToWellKnownTypeMap, v29);
  if (v31)
  {
    Copy = CFDataCreateCopy(v5, v31);
  }
  else
  {
    QTWellKnownTypeFromDynamicBaseDataType = FigMetadataGetQTWellKnownTypeFromDynamicBaseDataType(v29);
    if (!QTWellKnownTypeFromDynamicBaseDataType)
      goto LABEL_72;
    *(_DWORD *)bytes = bswap32(QTWellKnownTypeFromDynamicBaseDataType);
    Copy = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, 4);
  }
  v38 = Copy;
  if (!Copy)
  {
LABEL_72:
    v36 = 4294954585;
    goto LABEL_73;
  }
  if (!CMMetadataDataTypeRegistryDataTypeIsBaseDataType(v27))
  {
    ExternalRepresentation = CFStringCreateExternalRepresentation(v5, v27, 0x600u, 0);
    v90 = v91;
    if (ExternalRepresentation)
      goto LABEL_37;
    v40 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
    v72 = 0;
    v75 = 0;
    v59 = 0;
LABEL_74:
    v76 = 0;
    goto LABEL_98;
  }
  ExternalRepresentation = CFRetain(v38);
  v90 = v93;
LABEL_37:
  v39 = CMMetadataCreateKeyFromIdentifierAsCFData(v5, v11, &keyOut);
  if (v39)
  {
    v40 = v39;
    if (v39 != -16308)
      goto LABEL_97;
  }
  KeySpaceAsOSTypeFromIdentifier = FigMetadataGetKeySpaceAsOSTypeFromIdentifier(v11);
  valuePtr = KeySpaceAsOSTypeFromIdentifier;
  if (!KeySpaceAsOSTypeFromIdentifier || KeySpaceAsOSTypeFromIdentifier != 1634627438 && !keyOut)
  {
    v40 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
LABEL_97:
    v75 = 0;
    v59 = 0;
    v76 = 0;
    v72 = ExternalRepresentation;
    goto LABEL_98;
  }
  v42 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v43 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  v44 = CFNumberCreate(v42, kCFNumberSInt32Type, &v100);
  v109 = xmmword_1E28DEB60;
  v110 = unk_1E28DEB70;
  v111 = 0;
  *(_OWORD *)bytes = xmmword_1E28DEB40;
  v108 = *(_OWORD *)&off_1E28DEB50;
  v84 = v44;
  v85 = a1;
  v103[0] = v44;
  v103[1] = v43;
  cf1 = v43;
  v103[2] = (void *)v90;
  v103[3] = (void *)ExternalRepresentation;
  v104 = 0u;
  v105 = 0u;
  v106 = 0;
  cf = v38;
  if (keyOut)
  {
    *(_QWORD *)&v109 = CFSTR("MetadataKeyValue");
    *(_QWORD *)&v104 = keyOut;
    v45 = 5;
  }
  else
  {
    v45 = 4;
  }
  v83 = v45;
  if (Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      v47 = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
      v48 = CFDictionaryGetValue(v47, CFSTR("MetadataKeyNamespace"));
      if (FigCFEqual(v43, v48))
      {
        v49 = keyOut;
        v50 = CFDictionaryGetValue(v47, CFSTR("MetadataKeyValue"));
        if (FigCFEqual(v49, v50))
        {
          v51 = CFDictionaryGetValue(v47, CFSTR("MetadataKeyDataTypeNameSpace"));
          if (FigCFEqual(v90, v51))
          {
            v52 = CFDictionaryGetValue(v47, CFSTR("MetadataKeyDataType"));
            if (FigCFEqual(ExternalRepresentation, v52))
            {
              v53 = CFDictionaryGetValue(v47, CFSTR("MetadataKeyLanguageTag"));
              if (FigCFEqual(v88, v53))
              {
                v54 = CFDictionaryGetValue(v47, CFSTR("MetadataKeySetupData"));
                if (FigCFEqual(v87, v54))
                {
                  if (!ConformingDataTypes
                    || (v55 = CFDictionaryGetValue(v47, CFSTR("MetadataKeyConformingDataTypes")),
                        FigCFEqual(ConformingDataTypes, v55)))
                  {
                    dataTypea = 0;
                    v59 = 0;
                    v76 = 0;
                    v40 = 0;
LABEL_92:
                    v74 = v84;
                    a1 = v85;
                    v38 = cf;
                    v72 = ExternalRepresentation;
                    v73 = cf1;
                    goto LABEL_86;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (!ConformingDataTypes && (ConformingDataTypes = CMMetadataDataTypeRegistryGetConformingDataTypes(dataType)) == 0
    || (v56 = CFArrayGetCount(ConformingDataTypes), v56 < 1))
  {
    v59 = 0;
    dataTypea = 0;
    a1 = v85;
    v70 = v86;
    v68 = (void *)v88;
    v72 = ExternalRepresentation;
    v69 = (void *)v87;
    v73 = v43;
    v71 = v83;
    v74 = v84;
    goto LABEL_78;
  }
  v57 = v56;
  dataTypea = CFArrayCreateMutable(v5, v56, MEMORY[0x1E0C9B378]);
  v58 = 0;
  v59 = 0;
  v60 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v61 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  do
  {
    if (v59)
      CFRelease(v59);
    v62 = (const __CFString *)CFArrayGetValueAtIndex(ConformingDataTypes, v58);
    if (CMMetadataDataTypeRegistryDataTypeIsBaseDataType(v62))
    {
      if (CFStringCompare(v29, v62, 0))
      {
        v40 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
        v59 = 0;
        goto LABEL_95;
      }
      v59 = CFRetain(cf);
      v63 = (void *)v93;
      v64 = v5;
    }
    else
    {
      v65 = (const __CFString *)CFArrayGetValueAtIndex(ConformingDataTypes, v58);
      v64 = v5;
      v59 = CFStringCreateExternalRepresentation(v5, v65, 0x600u, 0);
      v63 = (void *)v91;
      if (!v59)
        goto LABEL_93;
    }
    *(_OWORD *)keys = xmmword_1E28DEB88;
    values[0] = v63;
    values[1] = (void *)v59;
    v5 = v64;
    v66 = CFDictionaryCreate(v64, (const void **)keys, (const void **)values, 2, v60, v61);
    if (!v66)
    {
LABEL_93:
      v40 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
LABEL_95:
      v76 = 0;
      goto LABEL_92;
    }
    v67 = v66;
    CFArrayAppendValue(dataTypea, v66);
    CFRelease(v67);
    ++v58;
  }
  while (v57 != v58);
  v69 = (void *)v87;
  v68 = (void *)v88;
  v70 = v86;
  v71 = v83;
  if (dataTypea)
  {
    *(_QWORD *)&bytes[8 * v83] = CFSTR("MetadataKeyConformingDataTypes");
    v103[v83] = dataTypea;
    v71 = v83 + 1;
  }
  else
  {
    dataTypea = 0;
  }
  v72 = ExternalRepresentation;
  v74 = v84;
  a1 = v85;
  v38 = cf;
  v73 = cf1;
LABEL_78:
  if (v68)
  {
    *(_QWORD *)&bytes[8 * v71] = CFSTR("MetadataKeyLanguageTag");
    v103[v71++] = v68;
  }
  if (v70)
  {
    *(_QWORD *)&bytes[8 * v71] = CFSTR("MetadataKeyStructuralDependency");
    v103[v71++] = v70;
  }
  if (v69)
  {
    *(_QWORD *)&bytes[8 * v71] = CFSTR("MetadataKeySetupData");
    v103[v71++] = v69;
  }
  v76 = CFDictionaryCreate(v5, (const void **)bytes, (const void **)v103, v71, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v76)
  {
    CFArrayAppendValue(theArray, v76);
    v40 = 0;
  }
  else
  {
    v40 = FigSignalErrorAt(4294954585, 0, 0, 0, 0, 0, 0);
  }
LABEL_86:
  if (v74)
    CFRelease(v74);
  if (v73)
    CFRelease(v73);
  v75 = dataTypea;
LABEL_98:
  if (keyOut)
    CFRelease(keyOut);
  if (v72)
    CFRelease(v72);
  if (v75)
    CFRelease(v75);
  if (v59)
    CFRelease(v59);
  if (v38)
    CFRelease(v38);
  if (v76)
    CFRelease(v76);
  if (!v40)
  {
    ++*(_DWORD *)(a2 + 16);
    v77 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("MetadataDependentSpecifications"));
    if (!v77)
      return;
    v78 = v77;
    v79 = CFArrayGetTypeID();
    if (v79 == CFGetTypeID(v78))
    {
      v80 = CFArrayGetCount(v78);
      if (v80 >= 1)
      {
        v113.length = v80;
        v81 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)bytes = *(_OWORD *)a2;
        v108 = v81;
        v109 = *(_OWORD *)(a2 + 32);
        *(_QWORD *)&v110 = *(_QWORD *)(a2 + 48);
        v113.location = 0;
        CFArrayApplyFunction(v78, v113, (CFArrayApplierFunction)metadataFormatDescriptionCreateWithMetadataSpecifications1_arrayCallback, bytes);
        v82 = v110;
        *(_DWORD *)(a2 + 16) = v108;
        *(_DWORD *)(a2 + 48) = v82 + 1;
      }
      return;
    }
LABEL_115:
    v40 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    if (!v40)
      return;
  }
  if (!*(_DWORD *)a2)
    *(_DWORD *)a2 = v40;
}

void metadataFormatDescriptionCreateWithMetadataSpecifications2_arrayCallback(const __CFDictionary *a1, __int128 *a2)
{
  const opaqueCMFormatDescription *v4;
  const void *Value;
  const void *v6;
  const void *v7;
  const __CFDictionary *LocalIDForMetadataIdentifyingFactors;
  const __CFDictionary *v9;
  const __CFDictionary *KeyWithLocalID;
  const void *v11;
  const void *v12;
  CFStringRef v13;
  CFStringRef v14;
  const __CFArray *v15;
  const __CFArray *v16;
  const __CFArray *v17;
  __int128 v18;
  const __CFArray *v19;
  const __CFArray *v20;
  const __CFArray *v21;
  __int128 v22;
  CFIndex Count;
  const __CFArray *v24;
  const __CFArray *v25;
  CFIndex v26;
  CFIndex v27;
  __CFArray *MutableCopy;
  CFIndex i;
  const void *ValueAtIndex;
  int v31;
  __int128 context;
  __int128 v33;
  CFArrayRef theArray[2];
  CFRange v35;
  CFRange v36;
  CFRange v37;
  CFRange v38;
  CFRange v39;

  if (!*(_DWORD *)a2)
  {
    v4 = (const opaqueCMFormatDescription *)*((_QWORD *)a2 + 2);
    Value = CFDictionaryGetValue(a1, CFSTR("MetadataIdentifier"));
    v6 = CFDictionaryGetValue(a1, CFSTR("MetadataDataType"));
    v7 = CFDictionaryGetValue(a1, CFSTR("MetadataExtendedLanguageTag"));
    LocalIDForMetadataIdentifyingFactors = FigMetadataFormatDescriptionGetLocalIDForMetadataIdentifyingFactors(v4, (uint64_t)Value, (uint64_t)v6, (uint64_t)v7);
    if ((_DWORD)LocalIDForMetadataIdentifyingFactors)
    {
      v9 = LocalIDForMetadataIdentifyingFactors;
      KeyWithLocalID = CMMetadataFormatDescriptionGetKeyWithLocalID(*((CMMetadataFormatDescriptionRef *)a2 + 2), (OSType)LocalIDForMetadataIdentifyingFactors);
      if (KeyWithLocalID)
      {
        v11 = CFDictionaryGetValue(KeyWithLocalID, CFSTR("MetadataKeyLocalID"));
        if (v11)
        {
          v12 = v11;
          v13 = CFStringCreateWithFormat(*((CFAllocatorRef *)a2 + 1), 0, CFSTR("%d"), v9);
          if (v13)
          {
            v14 = v13;
            v15 = (const __CFArray *)*((_QWORD *)a2 + 5);
            if (v15)
            {
              v35.length = CFArrayGetCount(*((CFArrayRef *)a2 + 5));
              v35.location = 0;
              if (!CFArrayContainsValue(v15, v35, v12))
                CFArrayAppendValue(*((CFMutableArrayRef *)a2 + 5), v12);
              v16 = (const __CFArray *)CFDictionaryGetValue(a1, CFSTR("MetadataDependentSpecifications"));
              if (!v16)
                goto LABEL_25;
              v17 = v16;
              v18 = a2[1];
              context = *a2;
              v33 = v18;
              *(_OWORD *)theArray = a2[2];
              v36.length = CFArrayGetCount(v16);
              v36.location = 0;
              CFArrayApplyFunction(v17, v36, (CFArrayApplierFunction)metadataFormatDescriptionCreateWithMetadataSpecifications2_arrayCallback, &context);
            }
            else
            {
              v19 = (const __CFArray *)*((_QWORD *)a2 + 3);
              v37.length = CFArrayGetCount(v19);
              v37.location = 0;
              if (!CFArrayContainsValue(v19, v37, v12))
                CFArrayAppendValue(*((CFMutableArrayRef *)a2 + 3), v12);
              v20 = (const __CFArray *)CFDictionaryGetValue(a1, CFSTR("MetadataDependentSpecifications"));
              if (!v20)
                goto LABEL_25;
              v21 = v20;
              v22 = a2[1];
              context = *a2;
              v33 = v22;
              theArray[0] = *((CFArrayRef *)a2 + 4);
              Count = CFArrayGetCount(v20);
              theArray[1] = CFArrayCreateMutable(*((CFAllocatorRef *)a2 + 1), Count, MEMORY[0x1E0C9B378]);
              v38.location = 0;
              v38.length = Count;
              CFArrayApplyFunction(v21, v38, (CFArrayApplierFunction)metadataFormatDescriptionCreateWithMetadataSpecifications2_arrayCallback, &context);
              if (!(_DWORD)context)
              {
                v24 = (const __CFArray *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 4), v14);
                if (v24)
                {
                  v25 = v24;
                  v26 = CFArrayGetCount(v24);
                  v27 = CFArrayGetCount(theArray[1]);
                  MutableCopy = CFArrayCreateMutableCopy(*((CFAllocatorRef *)a2 + 1), v27 + v26, v25);
                  if (v27 >= 1)
                  {
                    for (i = 0; i != v27; ++i)
                    {
                      ValueAtIndex = CFArrayGetValueAtIndex(theArray[1], i);
                      v39.location = 0;
                      v39.length = v26;
                      if (!CFArrayContainsValue(v25, v39, ValueAtIndex))
                        CFArrayAppendValue(MutableCopy, ValueAtIndex);
                    }
                  }
                  CFDictionarySetValue(*((CFMutableDictionaryRef *)a2 + 4), v14, MutableCopy);
                  CFRelease(MutableCopy);
                }
                else
                {
                  CFDictionarySetValue(*((CFMutableDictionaryRef *)a2 + 4), v14, theArray[1]);
                }
              }
              CFRelease(theArray[1]);
              if (*(_DWORD *)a2)
                goto LABEL_25;
            }
            *(_DWORD *)a2 = context;
LABEL_25:
            CFRelease(v14);
            return;
          }
        }
      }
    }
    v31 = FigSignalErrorAt(4294954586, 0, 0, 0, 0, 0, 0);
    if (v31 && !*(_DWORD *)a2)
      *(_DWORD *)a2 = v31;
  }
}

CMTimeRange *__cdecl CMTimeRangeMake(CMTimeRange *__return_ptr retstr, CMTimeRange *start, CMTime *duration)
{
  _BYTE v3[32];

  if (duration->epoch)
  {
    *(_OWORD *)&retstr->start.epoch = 0u;
    *(_OWORD *)&retstr->duration.timescale = 0u;
    *(_OWORD *)&retstr->start.value = 0u;
  }
  else
  {
    *(_QWORD *)v3 = start->start.epoch;
    *(CMTime *)&v3[8] = *duration;
    *(_OWORD *)&retstr->start.value = *(_OWORD *)&start->start.value;
    *(_OWORD *)&retstr->start.epoch = *(_OWORD *)v3;
    *(_OWORD *)&retstr->duration.timescale = *(_OWORD *)&v3[16];
  }
  return start;
}

CMTimeMapping *__cdecl CMTimeMappingMake(CMTimeMapping *__return_ptr retstr, CMTimeMapping *source, CMTimeRange *target)
{
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  if (source->source.duration.epoch || target->duration.epoch)
  {
    *(_OWORD *)&retstr->target.start.epoch = 0u;
    *(_OWORD *)&retstr->target.duration.timescale = 0u;
    *(_OWORD *)&retstr->source.duration.timescale = 0u;
    *(_OWORD *)&retstr->target.start.value = 0u;
    *(_OWORD *)&retstr->source.start.value = 0u;
    *(_OWORD *)&retstr->source.start.epoch = 0u;
  }
  else
  {
    v4 = *(_OWORD *)&source->source.start.epoch;
    v3 = *(_OWORD *)&source->source.duration.timescale;
    v6 = *(_OWORD *)&target->start.epoch;
    v5 = *(_OWORD *)&target->duration.timescale;
    v7 = *(_OWORD *)&target->start.value;
    *(_OWORD *)&retstr->source.start.value = *(_OWORD *)&source->source.start.value;
    *(_OWORD *)&retstr->source.start.epoch = v4;
    *(_OWORD *)&retstr->source.duration.timescale = v3;
    *(_OWORD *)&retstr->target.start.value = v7;
    *(_OWORD *)&retstr->target.start.epoch = v6;
    *(_OWORD *)&retstr->target.duration.timescale = v5;
  }
  return source;
}

CMTimeMapping *__cdecl CMTimeMappingMakeEmpty(CMTimeMapping *__return_ptr retstr, CMTimeMapping *target)
{
  __int128 v2;
  uint64_t v3;

  if (target->source.duration.epoch)
  {
    *(_OWORD *)&retstr->target.start.epoch = 0u;
    *(_OWORD *)&retstr->target.duration.timescale = 0u;
    *(_OWORD *)&retstr->source.duration.timescale = 0u;
    *(_OWORD *)&retstr->target.start.value = 0u;
    *(_OWORD *)&retstr->source.start.value = 0u;
    *(_OWORD *)&retstr->source.start.epoch = 0u;
  }
  else
  {
    v2 = *(_OWORD *)&target->source.start.epoch;
    *(_OWORD *)&retstr->target.start.value = *(_OWORD *)&target->source.start.value;
    *(_OWORD *)&retstr->target.start.epoch = v2;
    v3 = *(_QWORD *)&target->source.duration.timescale;
    *(_OWORD *)&retstr->source.start.value = 0u;
    *(_OWORD *)&retstr->source.start.epoch = 0u;
    *(_OWORD *)&retstr->source.duration.timescale = 0u;
    *(_QWORD *)&retstr->target.duration.timescale = v3;
    retstr->target.duration.epoch = 0;
  }
  return target;
}

CMTimeRange *__cdecl CMTimeRangeGetUnion(CMTimeRange *__return_ptr retstr, CMTimeRange *range, CMTimeRange *otherRange)
{
  CMTimeRange *v5;
  __int128 v6;
  CMTimeEpoch epoch;
  __int128 v8;
  CMTimeEpoch v9;
  __int128 v10;
  __int128 v11;
  CMTime v12;
  CMTime v13;
  CMTime v14;
  CMTime v15;
  CMTime v16;
  CMTime rhs;
  CMTime time2;
  __int128 time1;
  CMTime time1_16;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  memset(&v16, 0, sizeof(v16));
  memset(&v14, 0, sizeof(v14));
  if (range->start.epoch != otherRange->start.epoch)
    goto LABEL_9;
  v5 = range;
  time1 = *(_OWORD *)&range->start.value;
  time1_16.value = range->start.epoch;
  time2 = otherRange->start;
  CMTimeMinimum(&v16, (CMTime *)&time1, &time2);
  v6 = *(_OWORD *)&v5->start.epoch;
  time1 = *(_OWORD *)&v5->start.value;
  *(_OWORD *)&time1_16.value = v6;
  epoch = v5->duration.epoch;
  time1_16.epoch = *(_QWORD *)&v5->duration.timescale;
  if (epoch)
  {
    memset(&v13, 0, sizeof(v13));
  }
  else
  {
    time2 = v5->start;
    *(_OWORD *)&rhs.value = *(_OWORD *)&time1_16.timescale;
    rhs.epoch = 0;
    CMTimeAdd(&v13, &time2, &rhs);
  }
  v15 = v13;
  v8 = *(_OWORD *)&otherRange->start.epoch;
  time1 = *(_OWORD *)&otherRange->start.value;
  *(_OWORD *)&time1_16.value = v8;
  v9 = otherRange->duration.epoch;
  time1_16.epoch = *(_QWORD *)&otherRange->duration.timescale;
  if (v9)
  {
    memset(&v13, 0, sizeof(v13));
  }
  else
  {
    time2 = otherRange->start;
    *(_OWORD *)&rhs.value = *(_OWORD *)&time1_16.timescale;
    rhs.epoch = 0;
    CMTimeAdd(&v13, &time2, &rhs);
  }
  time2 = v13;
  time1 = *(_OWORD *)&v15.value;
  time1_16.value = v15.epoch;
  rhs = v13;
  CMTimeMaximum(&v14, (CMTime *)&time1, &rhs);
  time1 = *(_OWORD *)&v14.value;
  time1_16.value = v14.epoch;
  rhs = v16;
  range = (CMTimeRange *)CMTimeSubtract(&v12, (CMTime *)&time1, &rhs);
  if (!v12.epoch)
  {
    *(_QWORD *)&time1_16.timescale = v12.value;
    time1_16.value = v16.epoch;
    v10 = *(_OWORD *)&time1_16.value;
    v11 = *(unint64_t *)&v12.timescale;
    *(_OWORD *)&retstr->start.value = *(_OWORD *)&v16.value;
    *(_OWORD *)&retstr->start.epoch = v10;
    *(_OWORD *)&retstr->duration.timescale = v11;
  }
  else
  {
LABEL_9:
    *(_OWORD *)&retstr->start.epoch = 0u;
    *(_OWORD *)&retstr->duration.timescale = 0u;
    *(_OWORD *)&retstr->start.value = 0u;
  }
  return range;
}

CMTime *__cdecl CMTimeRangeGetEnd(CMTime *__return_ptr retstr, CMTime *range)
{
  CMTime v2;
  CMTime lhs;

  if (range[1].epoch)
  {
    *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
    retstr->epoch = 0;
  }
  else
  {
    lhs = *range;
    v2 = range[1];
    return CMTimeAdd(retstr, &lhs, &v2);
  }
  return range;
}

CMTimeRange *__cdecl CMTimeRangeGetIntersection(CMTimeRange *__return_ptr retstr, CMTimeRange *range, CMTimeRange *otherRange)
{
  CMTimeRange *v5;
  __int128 v6;
  CMTimeEpoch epoch;
  __int128 v8;
  CMTimeEpoch v9;
  __int128 v10;
  __int128 v11;
  CMTime v12;
  CMTime v13;
  CMTime v14;
  _BYTE v15[56];
  CMTime v16;
  CMTime rhs;
  CMTime time2;
  __int128 time1;
  CMTime time1_16;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  memset(&v16, 0, sizeof(v16));
  memset(&v15[32], 0, 24);
  memset(v15, 0, 24);
  memset(&v14, 0, sizeof(v14));
  if (range->start.epoch != otherRange->start.epoch)
    goto LABEL_11;
  v5 = range;
  time1 = *(_OWORD *)&range->start.value;
  time1_16.value = range->start.epoch;
  time2 = otherRange->start;
  CMTimeMaximum(&v16, (CMTime *)&time1, &time2);
  v6 = *(_OWORD *)&v5->start.epoch;
  time1 = *(_OWORD *)&v5->start.value;
  *(_OWORD *)&time1_16.value = v6;
  epoch = v5->duration.epoch;
  time1_16.epoch = *(_QWORD *)&v5->duration.timescale;
  if (epoch)
  {
    memset(&v13, 0, sizeof(v13));
  }
  else
  {
    time2 = v5->start;
    *(_OWORD *)&rhs.value = *(_OWORD *)&time1_16.timescale;
    rhs.epoch = 0;
    CMTimeAdd(&v13, &time2, &rhs);
  }
  *(CMTime *)&v15[32] = v13;
  v8 = *(_OWORD *)&otherRange->start.epoch;
  time1 = *(_OWORD *)&otherRange->start.value;
  *(_OWORD *)&time1_16.value = v8;
  v9 = otherRange->duration.epoch;
  time1_16.epoch = *(_QWORD *)&otherRange->duration.timescale;
  if (v9)
  {
    memset(&v13, 0, sizeof(v13));
  }
  else
  {
    time2 = otherRange->start;
    *(_OWORD *)&rhs.value = *(_OWORD *)&time1_16.timescale;
    rhs.epoch = 0;
    CMTimeAdd(&v13, &time2, &rhs);
  }
  *(CMTime *)v15 = v13;
  time1 = *(_OWORD *)&v15[32];
  time1_16.value = *(_QWORD *)&v15[48];
  time2 = v13;
  CMTimeMinimum(&v14, (CMTime *)&time1, &time2);
  time1 = *(_OWORD *)&v16.value;
  time1_16.value = v16.epoch;
  time2 = v14;
  range = (CMTimeRange *)CMTimeCompare((CMTime *)&time1, &time2);
  if ((range & 0x80000000) == 0)
  {
    *retstr = kCMTimeRangeZero;
    return range;
  }
  time1 = *(_OWORD *)&v14.value;
  time1_16.value = v14.epoch;
  time2 = v16;
  range = (CMTimeRange *)CMTimeSubtract(&v12, (CMTime *)&time1, &time2);
  if (!v12.epoch)
  {
    *(_QWORD *)&time1_16.timescale = v12.value;
    time1_16.value = v16.epoch;
    v10 = *(_OWORD *)&time1_16.value;
    v11 = *(unint64_t *)&v12.timescale;
    *(_OWORD *)&retstr->start.value = *(_OWORD *)&v16.value;
    *(_OWORD *)&retstr->start.epoch = v10;
    *(_OWORD *)&retstr->duration.timescale = v11;
  }
  else
  {
LABEL_11:
    *(_OWORD *)&retstr->start.epoch = 0u;
    *(_OWORD *)&retstr->duration.timescale = 0u;
    *(_OWORD *)&retstr->start.value = 0u;
  }
  return range;
}

Boolean CMTimeRangeEqual(CMTimeRange *range1, CMTimeRange *range2)
{
  CMTime start;
  CMTime time1;

  if (range1->start.epoch != range2->start.epoch)
    return 0;
  time1 = range1->start;
  start = range2->start;
  if (CMTimeCompare(&time1, &start))
    return 0;
  time1 = range1->duration;
  start = range2->duration;
  return CMTimeCompare(&time1, &start) == 0;
}

Boolean CMTimeRangeContainsTime(CMTimeRange *range, CMTime *time)
{
  int v4;
  __int128 v5;
  CMTimeEpoch epoch;
  CMTime v8;
  CMTime rhs;
  CMTime time2;
  __int128 time1;
  CMTime time1_16;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  time1 = *(_OWORD *)&range->start.value;
  time1_16.value = range->start.epoch;
  time2 = *time;
  if (CMTimeCompare((CMTime *)&time1, &time2) <= 0)
  {
    v5 = *(_OWORD *)&range->start.epoch;
    time1 = *(_OWORD *)&range->start.value;
    *(_OWORD *)&time1_16.value = v5;
    epoch = range->duration.epoch;
    time1_16.epoch = *(_QWORD *)&range->duration.timescale;
    if (epoch)
    {
      memset(&v8, 0, sizeof(v8));
    }
    else
    {
      time2 = range->start;
      *(_OWORD *)&rhs.value = *(_OWORD *)&time1_16.timescale;
      rhs.epoch = 0;
      CMTimeAdd(&v8, &time2, &rhs);
    }
    time1 = *(_OWORD *)&time->value;
    time1_16.value = time->epoch;
    return CMTimeCompare((CMTime *)&time1, &v8) >> 31;
  }
  else
  {
    LOBYTE(v4) = 0;
  }
  return v4;
}

Boolean CMTimeRangeContainsTimeRange(CMTimeRange *range, CMTimeRange *otherRange)
{
  __int128 v4;
  int v5;
  __int128 v6;
  CMTimeEpoch epoch;
  __int128 v8;
  __int128 v9;
  CMTimeEpoch v10;
  __int128 v11;
  CMTimeEpoch v12;
  CMTime v14;
  CMTime time1;
  CMTime v16;
  CMTime rhs;
  CMTime time;
  CMTimeRange rangea;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (range->start.epoch != otherRange->start.epoch)
  {
LABEL_15:
    LOBYTE(v5) = 0;
    return v5;
  }
  v4 = *(_OWORD *)&range->start.epoch;
  *(_OWORD *)&rangea.start.value = *(_OWORD *)&range->start.value;
  *(_OWORD *)&rangea.start.epoch = v4;
  *(_OWORD *)&rangea.duration.timescale = *(_OWORD *)&range->duration.timescale;
  time = otherRange->start;
  v5 = CMTimeRangeContainsTime(&rangea, &time);
  if (v5)
  {
    v6 = *(_OWORD *)&otherRange->start.epoch;
    *(_OWORD *)&rangea.start.value = *(_OWORD *)&otherRange->start.value;
    *(_OWORD *)&rangea.start.epoch = v6;
    epoch = otherRange->duration.epoch;
    *(_QWORD *)&rangea.duration.timescale = *(_QWORD *)&otherRange->duration.timescale;
    if (epoch)
    {
      memset(&v16, 0, sizeof(v16));
    }
    else
    {
      time = otherRange->start;
      *(_OWORD *)&rhs.value = *(_OWORD *)&rangea.duration.value;
      rhs.epoch = 0;
      CMTimeAdd(&v16, &time, &rhs);
    }
    v8 = *(_OWORD *)&range->start.epoch;
    *(_OWORD *)&rangea.start.value = *(_OWORD *)&range->start.value;
    *(_OWORD *)&rangea.start.epoch = v8;
    *(_OWORD *)&rangea.duration.timescale = *(_OWORD *)&range->duration.timescale;
    if (!CMTimeRangeContainsTime(&rangea, &v16))
    {
      v9 = *(_OWORD *)&range->start.epoch;
      *(_OWORD *)&rangea.start.value = *(_OWORD *)&range->start.value;
      *(_OWORD *)&rangea.start.epoch = v9;
      v10 = range->duration.epoch;
      *(_QWORD *)&rangea.duration.timescale = *(_QWORD *)&range->duration.timescale;
      if (v10)
      {
        memset(&time1, 0, sizeof(time1));
      }
      else
      {
        time = range->start;
        *(_OWORD *)&rhs.value = *(_OWORD *)&rangea.duration.value;
        rhs.epoch = 0;
        CMTimeAdd(&time1, &time, &rhs);
      }
      v11 = *(_OWORD *)&otherRange->start.epoch;
      *(_OWORD *)&rangea.start.value = *(_OWORD *)&otherRange->start.value;
      *(_OWORD *)&rangea.start.epoch = v11;
      v12 = otherRange->duration.epoch;
      *(_QWORD *)&rangea.duration.timescale = *(_QWORD *)&otherRange->duration.timescale;
      if (v12)
      {
        memset(&v14, 0, sizeof(v14));
      }
      else
      {
        time = otherRange->start;
        *(_OWORD *)&rhs.value = *(_OWORD *)&rangea.duration.value;
        rhs.epoch = 0;
        CMTimeAdd(&v14, &time, &rhs);
      }
      if (CMTimeCompare(&time1, &v14))
        goto LABEL_15;
    }
    LOBYTE(v5) = 1;
  }
  return v5;
}

CMTime *__cdecl CMTimeMapDurationFromRangeToRange(CMTime *__return_ptr retstr, CMTime *dur, CMTimeRange *fromRange, CMTimeRange *toRange)
{
  CMTime *result;
  CMTime *p_duration;
  CMTime *v10;
  CMTime *v11;
  double Seconds;
  Float64 v13;
  CMTime duration;
  CMTime time1;

  time1 = fromRange->duration;
  duration = toRange->duration;
  result = (CMTime *)CMTimeCompare(&time1, &duration);
  if ((dur->flags & 0x1D) == 1 && dur->epoch
    || (fromRange->start.flags & 0x1D) != 1
    || (toRange->start.flags & 0x1D) != 1)
  {
    goto LABEL_17;
  }
  p_duration = &fromRange->duration;
  v10 = &toRange->duration;
  if (((~fromRange->duration.flags & 0x11) == 0 || (fromRange->duration.flags & 5) == 5)
    && ((~toRange->duration.flags & 0x11) == 0 || (toRange->duration.flags & 5) == 5))
  {
    if (!(_DWORD)result)
    {
LABEL_21:
      v11 = dur;
      goto LABEL_18;
    }
LABEL_20:
    *(_OWORD *)&time1.value = *(_OWORD *)&v10->value;
    time1.epoch = toRange->duration.epoch;
    Seconds = CMTimeGetSeconds(&time1);
    *(_OWORD *)&time1.value = *(_OWORD *)&p_duration->value;
    time1.epoch = fromRange->duration.epoch;
    v13 = CMTimeGetSeconds(&time1);
    duration = *dur;
    result = CMTimeMultiplyByFloat64(&time1, &duration, Seconds / v13);
    *dur = time1;
    goto LABEL_21;
  }
  if ((fromRange->duration.flags & 0x1D) != 1
    || p_duration->value < 1
    || fromRange->duration.epoch
    || (toRange->duration.flags & 0x1D) != 1)
  {
LABEL_17:
    v11 = (CMTime *)&kCMTimeInvalid;
    goto LABEL_18;
  }
  v11 = (CMTime *)&kCMTimeInvalid;
  if (v10->value >= 1 && !toRange->duration.epoch)
  {
    v11 = dur;
    if ((_DWORD)result)
      goto LABEL_20;
  }
LABEL_18:
  *(_OWORD *)&retstr->value = *(_OWORD *)&v11->value;
  retstr->epoch = v11->epoch;
  return result;
}

CMTime *__cdecl CMTimeMapTimeFromRangeToRange(CMTime *__return_ptr retstr, CMTime *t, CMTimeRange *fromRange, CMTimeRange *toRange)
{
  int32_t v8;
  CMTime *result;
  int v10;
  CMTime *p_duration;
  CMTime *v12;
  double Seconds;
  Float64 v14;
  CMTime start;
  CMTime time2;
  CMTime time1;

  time1 = fromRange->start;
  time2 = toRange->start;
  v8 = CMTimeCompare(&time1, &time2);
  time1 = fromRange->duration;
  time2 = toRange->duration;
  result = (CMTime *)CMTimeCompare(&time1, &time2);
  if ((fromRange->start.flags & 0x1D) != 1 || (toRange->start.flags & 0x1D) != 1)
    goto LABEL_19;
  if ((v10 = (int)result,
        p_duration = &fromRange->duration,
        v12 = &toRange->duration,
        (~fromRange->duration.flags & 0x11) != 0)
    && (fromRange->duration.flags & 5) != 5
    || (~toRange->duration.flags & 0x11) != 0 && (toRange->duration.flags & 5) != 5)
  {
    if ((fromRange->duration.flags & 0x1D) != 1
      || p_duration->value < 1
      || fromRange->duration.epoch
      || (toRange->duration.flags & 0x1D) != 1
      || v12->value < 1
      || toRange->duration.epoch)
    {
      goto LABEL_19;
    }
  }
  if ((t->flags & 0x1D) != 1)
    goto LABEL_20;
  if (t->epoch != fromRange->start.epoch)
  {
LABEL_19:
    t = (CMTime *)&kCMTimeInvalid;
    goto LABEL_20;
  }
  if (v8 | result)
  {
    time2 = *t;
    start = fromRange->start;
    CMTimeSubtract(&time1, &time2, &start);
    *t = time1;
    if (v10)
    {
      *(_OWORD *)&time1.value = *(_OWORD *)&v12->value;
      time1.epoch = toRange->duration.epoch;
      Seconds = CMTimeGetSeconds(&time1);
      *(_OWORD *)&time1.value = *(_OWORD *)&p_duration->value;
      time1.epoch = fromRange->duration.epoch;
      v14 = CMTimeGetSeconds(&time1);
      time2 = *t;
      CMTimeMultiplyByFloat64(&time1, &time2, Seconds / v14);
      *t = time1;
    }
    time2 = *t;
    start = toRange->start;
    result = CMTimeAdd(&time1, &time2, &start);
    *t = time1;
  }
LABEL_20:
  *(_OWORD *)&retstr->value = *(_OWORD *)&t->value;
  retstr->epoch = t->epoch;
  return result;
}

CMTime *__cdecl CMTimeClampToRange(CMTime *__return_ptr retstr, CMTime *time, CMTimeRange *range)
{
  CMTime *v5;
  BOOL v6;
  CMTimeEpoch epoch;
  __int128 v9;
  CMTimeEpoch v10;
  __int128 v11;
  CMTimeEpoch v12;
  CMTime v13;
  CMTime rhs;
  CMTime time2;
  __int128 time1;
  CMTime time1_16;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if ((range->start.flags & 0x1D) != 1
    || ((v5 = time, (~range->duration.flags & 5) != 0) ? (v6 = (range->duration.flags & 0x11) == 17) : (v6 = 1),
        !v6 && ((range->duration.flags & 0x1D) != 1 || range->duration.value < 1 || range->duration.epoch)))
  {
LABEL_24:
    *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
    epoch = 0;
    goto LABEL_25;
  }
  if ((~time->flags & 0x11) != 0 && (time->flags & 1) != 0)
  {
    time1 = *(_OWORD *)&time->value;
    time1_16.value = time->epoch;
    time2 = range->start;
    time = (CMTime *)CMTimeCompare((CMTime *)&time1, &time2);
    if ((int)time <= 0)
    {
      *(_OWORD *)&retstr->value = *(_OWORD *)&range->start.value;
      epoch = range->start.epoch;
      goto LABEL_25;
    }
    v9 = *(_OWORD *)&range->start.epoch;
    time1 = *(_OWORD *)&range->start.value;
    *(_OWORD *)&time1_16.value = v9;
    v10 = range->duration.epoch;
    time1_16.epoch = *(_QWORD *)&range->duration.timescale;
    if (v10)
    {
      memset(&v13, 0, sizeof(v13));
    }
    else
    {
      time2 = range->start;
      *(_OWORD *)&rhs.value = *(_OWORD *)&time1_16.timescale;
      rhs.epoch = 0;
      CMTimeAdd(&v13, &time2, &rhs);
    }
    time1 = *(_OWORD *)&v5->value;
    time1_16.value = v5->epoch;
    time = (CMTime *)CMTimeCompare((CMTime *)&time1, &v13);
    if ((time & 0x80000000) == 0)
    {
      v11 = *(_OWORD *)&range->start.epoch;
      time1 = *(_OWORD *)&range->start.value;
      *(_OWORD *)&time1_16.value = v11;
      v12 = range->duration.epoch;
      time1_16.epoch = *(_QWORD *)&range->duration.timescale;
      if (!v12)
      {
        time2 = range->start;
        *(_OWORD *)&rhs.value = *(_OWORD *)&time1_16.timescale;
        rhs.epoch = 0;
        return CMTimeAdd(retstr, &time2, &rhs);
      }
      goto LABEL_24;
    }
  }
  *(_OWORD *)&retstr->value = *(_OWORD *)&v5->value;
  epoch = v5->epoch;
LABEL_25:
  retstr->epoch = epoch;
  return time;
}

CMTime *__cdecl CMTimeFoldIntoRange(CMTime *__return_ptr retstr, CMTime *time, CMTimeRange *foldRange)
{
  CMTime duration;
  CMTime rhs;
  CMTime lhs;
  CMTime v9;
  CMTime v10;

  *(_OWORD *)&retstr->value = *(_OWORD *)&kCMTimeInvalid.value;
  retstr->epoch = 0;
  memset(&v10, 0, sizeof(v10));
  memset(&v9, 0, sizeof(v9));
  lhs = *time;
  rhs = foldRange->start;
  CMTimeSubtract(&v10, &lhs, &rhs);
  lhs = v10;
  *(_OWORD *)&rhs.value = *(_OWORD *)&kCMTimeZero.value;
  rhs.epoch = 0;
  if (CMTimeCompare(&lhs, &rhs) < 0)
  {
    rhs = v10;
    duration = foldRange->duration;
    CMTimeRemainder((__int128 *)&rhs.value, (__int128 *)&duration.value, &lhs);
    v10 = lhs;
    rhs = lhs;
    duration = foldRange->duration;
    CMTimeAdd(&lhs, &rhs, &duration);
    v10 = lhs;
  }
  lhs = v10;
  rhs = foldRange->duration;
  CMTimeRemainder((__int128 *)&lhs.value, (__int128 *)&rhs.value, &v9);
  lhs = v9;
  rhs = foldRange->start;
  return CMTimeAdd(retstr, &lhs, &rhs);
}

CFDictionaryRef CMTimeRangeCopyAsDictionary(CMTimeRange *range, CFAllocatorRef allocator)
{
  CFDictionaryRef v4;
  CFDictionaryRef v5;
  CFDictionaryRef v6;
  CFDictionaryRef v7;
  const __CFDictionary *v8;
  const void *v10[2];
  CMTime time;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  time = range->start;
  v4 = CMTimeCopyAsDictionary(&time, 0);
  time = range->duration;
  v5 = CMTimeCopyAsDictionary(&time, 0);
  v6 = v5;
  if (v4 && v5)
  {
    *(_OWORD *)&time.value = xmmword_1E28DEBB8;
    v10[0] = v4;
    v10[1] = v5;
    v7 = CFDictionaryCreate(allocator, (const void **)&time, v10, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  else
  {
    v7 = 0;
    v8 = 0;
    if (!v4)
      goto LABEL_6;
  }
  CFRelease(v4);
  v8 = v7;
LABEL_6:
  if (v6)
    CFRelease(v6);
  return v8;
}

CMTimeRange *__cdecl CMTimeRangeMakeFromDictionary(CMTimeRange *__return_ptr retstr, CMTimeRange *dictionaryRepresentation)
{
  CMTimeRange *v3;
  CMTimeRange *TypeID;
  const __CFDictionary *Value;
  CMTimeRange *v6;
  __int128 v7;
  CMTime v8;
  CMTime v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BYTE v14[24];
  uint64_t v15;

  if (dictionaryRepresentation
    && (v3 = dictionaryRepresentation,
        TypeID = (CMTimeRange *)CFDictionaryGetTypeID(),
        dictionaryRepresentation = (CMTimeRange *)CFGetTypeID(v3),
        TypeID == dictionaryRepresentation)
    && (Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v3, CFSTR("start")),
        dictionaryRepresentation = (CMTimeRange *)CFDictionaryGetValue((CFDictionaryRef)v3, CFSTR("duration")),
        Value)
    && (v6 = dictionaryRepresentation) != 0)
  {
    CMTimeMakeFromDictionary(&v9, Value);
    dictionaryRepresentation = (CMTimeRange *)CMTimeMakeFromDictionary(&v8, (CFDictionaryRef)v6);
    if (v8.epoch)
    {
      v11 = 0u;
      v12 = 0u;
      v10 = 0u;
    }
    else
    {
      *(_QWORD *)v14 = v9.epoch;
      v13 = *(_OWORD *)&v9.value;
      *(_OWORD *)&v14[8] = *(_OWORD *)&v8.value;
      v15 = 0;
      v10 = *(_OWORD *)&v9.value;
      v11 = *(_OWORD *)v14;
      v12 = *(unint64_t *)&v8.timescale;
    }
    v7 = v11;
    *(_OWORD *)&retstr->start.value = v10;
    *(_OWORD *)&retstr->start.epoch = v7;
    *(_OWORD *)&retstr->duration.timescale = v12;
  }
  else
  {
    *(_OWORD *)&retstr->start.epoch = 0u;
    *(_OWORD *)&retstr->duration.timescale = 0u;
    *(_OWORD *)&retstr->start.value = 0u;
  }
  return dictionaryRepresentation;
}

CFDictionaryRef CMTimeMappingCopyAsDictionary(CMTimeMapping *mapping, CFAllocatorRef allocator)
{
  __int128 v4;
  CFDictionaryRef v5;
  __int128 v6;
  CFDictionaryRef v7;
  CFDictionaryRef v8;
  CFDictionaryRef v9;
  const __CFDictionary *v10;
  const void *v12[2];
  CMTimeRange range;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *(_OWORD *)&mapping->source.start.epoch;
  *(_OWORD *)&range.start.value = *(_OWORD *)&mapping->source.start.value;
  *(_OWORD *)&range.start.epoch = v4;
  *(_OWORD *)&range.duration.timescale = *(_OWORD *)&mapping->source.duration.timescale;
  v5 = CMTimeRangeCopyAsDictionary(&range, 0);
  v6 = *(_OWORD *)&mapping->target.start.epoch;
  *(_OWORD *)&range.start.value = *(_OWORD *)&mapping->target.start.value;
  *(_OWORD *)&range.start.epoch = v6;
  *(_OWORD *)&range.duration.timescale = *(_OWORD *)&mapping->target.duration.timescale;
  v7 = CMTimeRangeCopyAsDictionary(&range, 0);
  v8 = v7;
  if (v5 && v7)
  {
    *(_OWORD *)&range.start.value = xmmword_1E28DEBC8;
    v12[0] = v5;
    v12[1] = v7;
    v9 = CFDictionaryCreate(allocator, (const void **)&range, v12, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  else
  {
    v9 = 0;
    v10 = 0;
    if (!v5)
      goto LABEL_6;
  }
  CFRelease(v5);
  v10 = v9;
LABEL_6:
  if (v8)
    CFRelease(v8);
  return v10;
}

CMTimeMapping *__cdecl CMTimeMappingMakeFromDictionary(CMTimeMapping *__return_ptr retstr, CMTimeMapping *dictionaryRepresentation)
{
  CMTimeMapping *v3;
  CMTimeMapping *TypeID;
  const __CFDictionary *Value;
  CMTimeMapping *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  CMTimeRange v10;
  CMTimeRange v11;
  CMTimeRange v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  CMTimeRange v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;

  if (dictionaryRepresentation
    && (v3 = dictionaryRepresentation,
        TypeID = (CMTimeMapping *)CFDictionaryGetTypeID(),
        dictionaryRepresentation = (CMTimeMapping *)CFGetTypeID(v3),
        TypeID == dictionaryRepresentation)
    && (Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v3, CFSTR("source")),
        dictionaryRepresentation = (CMTimeMapping *)CFDictionaryGetValue((CFDictionaryRef)v3, CFSTR("target")),
        Value)
    && (v6 = dictionaryRepresentation) != 0)
  {
    CMTimeRangeMakeFromDictionary(&v11, Value);
    dictionaryRepresentation = (CMTimeMapping *)CMTimeRangeMakeFromDictionary(&v10, (CFDictionaryRef)v6);
    if (v11.duration.epoch || v10.duration.epoch)
    {
      v14 = 0u;
      v15 = 0u;
      v13 = 0u;
      memset(&v12, 0, sizeof(v12));
    }
    else
    {
      v16 = v11;
      v17 = *(_OWORD *)&v10.start.value;
      v18 = *(_OWORD *)&v10.start.epoch;
      v19 = *(unint64_t *)&v10.duration.timescale;
      v12 = v11;
      v13 = *(_OWORD *)&v10.start.value;
      v14 = *(_OWORD *)&v10.start.epoch;
      v15 = *(unint64_t *)&v10.duration.timescale;
    }
    v7 = v13;
    *(_OWORD *)&retstr->source.duration.timescale = *(_OWORD *)&v12.duration.timescale;
    *(_OWORD *)&retstr->target.start.value = v7;
    v8 = v15;
    *(_OWORD *)&retstr->target.start.epoch = v14;
    *(_OWORD *)&retstr->target.duration.timescale = v8;
    v9 = *(_OWORD *)&v12.start.epoch;
    *(_OWORD *)&retstr->source.start.value = *(_OWORD *)&v12.start.value;
    *(_OWORD *)&retstr->source.start.epoch = v9;
  }
  else
  {
    *(_OWORD *)&retstr->target.start.epoch = 0u;
    *(_OWORD *)&retstr->target.duration.timescale = 0u;
    *(_OWORD *)&retstr->source.duration.timescale = 0u;
    *(_OWORD *)&retstr->target.start.value = 0u;
    *(_OWORD *)&retstr->source.start.value = 0u;
    *(_OWORD *)&retstr->source.start.epoch = 0u;
  }
  return dictionaryRepresentation;
}

CFStringRef CMTimeRangeCopyDescription(CFAllocatorRef allocator, CMTimeRange *range)
{
  CFMutableStringRef Mutable;
  const __CFString *v5;
  CFStringRef v6;
  const __CFString *v7;
  CMTime start;

  Mutable = CFStringCreateMutable(allocator, 0);
  if (!Mutable)
    return Mutable;
  start = range->start;
  v5 = CMTimeCopyDescription(allocator, &start);
  start = range->duration;
  v6 = CMTimeCopyDescription(allocator, &start);
  v7 = v6;
  if (v5 && v6)
  {
    CFStringAppend(Mutable, CFSTR("{"));
    CFStringAppend(Mutable, v5);
    CFStringAppend(Mutable, CFSTR(", "));
    CFStringAppend(Mutable, v7);
    CFStringAppend(Mutable, CFSTR("}"));
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("{ERROR CONSTRUCTING DESCRIPTION}"));
    if (!v5)
      goto LABEL_7;
  }
  CFRelease(v5);
LABEL_7:
  if (v7)
    CFRelease(v7);
  return Mutable;
}

void CMTimeRangeShow(CMTimeRange *range)
{
  const __CFAllocator *v1;
  __int128 v2;
  const __CFString *v3;
  const __CFString *v4;
  CMTimeRange rangea;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v2 = *(_OWORD *)&range->start.epoch;
  *(_OWORD *)&rangea.start.value = *(_OWORD *)&range->start.value;
  *(_OWORD *)&rangea.start.epoch = v2;
  *(_OWORD *)&rangea.duration.timescale = *(_OWORD *)&range->duration.timescale;
  v3 = CMTimeRangeCopyDescription(v1, &rangea);
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  v6 = 0u;
  memset(&rangea, 0, sizeof(rangea));
  if (v3)
  {
    v4 = v3;
    if (CFStringGetCString(v3, (char *)&rangea, 512, 0))
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "%s\n", (const char *)&rangea);
    CFRelease(v4);
  }
}

CFStringRef CMTimeMappingCopyDescription(CFAllocatorRef allocator, CMTimeMapping *mapping)
{
  CFMutableStringRef Mutable;
  __int128 v5;
  const __CFString *v6;
  __int128 v7;
  CFStringRef v8;
  const __CFString *v9;
  CMTimeRange v11;

  Mutable = CFStringCreateMutable(allocator, 0);
  if (!Mutable)
    return Mutable;
  v5 = *(_OWORD *)&mapping->source.start.epoch;
  *(_OWORD *)&v11.start.value = *(_OWORD *)&mapping->source.start.value;
  *(_OWORD *)&v11.start.epoch = v5;
  *(_OWORD *)&v11.duration.timescale = *(_OWORD *)&mapping->source.duration.timescale;
  v6 = CMTimeRangeCopyDescription(allocator, &v11);
  v7 = *(_OWORD *)&mapping->target.start.epoch;
  *(_OWORD *)&v11.start.value = *(_OWORD *)&mapping->target.start.value;
  *(_OWORD *)&v11.start.epoch = v7;
  *(_OWORD *)&v11.duration.timescale = *(_OWORD *)&mapping->target.duration.timescale;
  v8 = CMTimeRangeCopyDescription(allocator, &v11);
  v9 = v8;
  if (v6 && v8)
  {
    CFStringAppend(Mutable, CFSTR("{"));
    CFStringAppend(Mutable, v6);
    CFStringAppend(Mutable, CFSTR(", "));
    CFStringAppend(Mutable, v9);
    CFStringAppend(Mutable, CFSTR("}"));
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("{ERROR CONSTRUCTING DESCRIPTION}"));
    if (!v6)
      goto LABEL_7;
  }
  CFRelease(v6);
LABEL_7:
  if (v9)
    CFRelease(v9);
  return Mutable;
}

void CMTimeMappingShow(CMTimeMapping *mapping)
{
  const __CFAllocator *v1;
  __int128 v2;
  __int128 v3;
  __int128 v4;
  const __CFString *v5;
  const __CFString *v6;
  CMTimeMapping mappinga;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v2 = *(_OWORD *)&mapping->target.start.value;
  *(_OWORD *)&mappinga.source.duration.timescale = *(_OWORD *)&mapping->source.duration.timescale;
  *(_OWORD *)&mappinga.target.start.value = v2;
  v3 = *(_OWORD *)&mapping->target.duration.timescale;
  *(_OWORD *)&mappinga.target.start.epoch = *(_OWORD *)&mapping->target.start.epoch;
  *(_OWORD *)&mappinga.target.duration.timescale = v3;
  v4 = *(_OWORD *)&mapping->source.start.epoch;
  *(_OWORD *)&mappinga.source.start.value = *(_OWORD *)&mapping->source.start.value;
  *(_OWORD *)&mappinga.source.start.epoch = v4;
  v5 = CMTimeMappingCopyDescription(v1, &mappinga);
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  memset(&mappinga, 0, sizeof(mappinga));
  if (v5)
  {
    v6 = v5;
    if (CFStringGetCString(v5, (char *)&mappinga, 512, 0))
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "%s\n", (const char *)&mappinga);
    CFRelease(v6);
  }
}

CMTimeRange *__cdecl CMTimeRangeFromTimeToTime(CMTimeRange *__return_ptr retstr, CMTime *start, CMTime *end)
{
  CMTimeRange *result;
  uint64_t v7;
  __int128 v8;
  CMTime v9;
  CMTime time2;
  _BYTE time1[32];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  *(CMTime *)time1 = *start;
  time2 = *end;
  result = (CMTimeRange *)CMTimeCompare((CMTime *)time1, &time2);
  if ((int)result >= 1
    || (time2 = *end,
        v9 = *start,
        result = (CMTimeRange *)CMTimeSubtract((CMTime *)time1, &time2, &v9),
        *(_OWORD *)&time2.value = *(_OWORD *)time1,
        *(_QWORD *)&time1[16]))
  {
    *(_OWORD *)&retstr->start.epoch = 0u;
    *(_OWORD *)&retstr->duration.timescale = 0u;
    *(_OWORD *)&retstr->start.value = 0u;
  }
  else
  {
    *(_QWORD *)&time1[16] = start->epoch;
    *(_OWORD *)time1 = *(_OWORD *)&start->value;
    *(_QWORD *)&time1[24] = time2.value;
    v7 = *(_QWORD *)&time2.timescale;
    v8 = *(_OWORD *)&time1[16];
    *(_OWORD *)&retstr->start.value = *(_OWORD *)time1;
    *(_OWORD *)&retstr->start.epoch = v8;
    *(_QWORD *)&retstr->duration.timescale = v7;
    retstr->duration.epoch = 0;
  }
  return result;
}

CMTime *CMSpeedRampMapTimeFromTargetToSource@<X0>(CMTime *result@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, CMTime *a4@<X8>)
{
  CMTime *v4;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CMTimeFlags flags;
  CMTimeEpoch epoch;
  uint64_t v14;
  CMTimeValue v15;
  CMTimeFlags v16;
  CMTimeEpoch v17;
  __int128 v19;
  uint64_t v20;
  CMTimeFlags v21;
  CMTimeEpoch v22;
  CMTime *v23;
  CMTimeRange *p_time1;
  CMTime *v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  _OWORD *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  unint64_t v34;
  CMTimeRange time;
  CMTime v38;
  CMTime v39;
  CMTime v40;
  CMTime v41;
  CMTime v42;
  CMTime time2;
  CMTime rhs;
  CMTime lhs;
  CMTimeRange time1;
  CMTimeValue v47;
  CMTimeScale v48;
  CMTimeValue value;
  CMTimeScale timescale;
  uint64_t v51;

  v4 = result;
  v51 = *MEMORY[0x1E0C80C00];
  if ((result->flags & 0x1D) == 1)
  {
    v34 = a3 - 1;
    if (((a3 - 1) & 0x8000000000000000) != 0)
    {
LABEL_22:
      *(_OWORD *)&time1.start.value = *(_OWORD *)&v4->value;
      time1.start.epoch = v4->epoch;
      *(_OWORD *)&time.start.value = *(_OWORD *)(a2 + 48);
      time.start.epoch = *(_QWORD *)(a2 + 64);
      CMTimeSubtract(&v42, &time1.start, &time.start);
      *(_OWORD *)&time1.start.value = *(_OWORD *)a2;
      time1.start.epoch = *(_QWORD *)(a2 + 16);
      v23 = &v42;
      p_time1 = &time1;
      v25 = a4;
    }
    else
    {
      v6 = 0;
      v7 = a3 - 1;
      v8 = a3 - 1;
      while (1)
      {
        v9 = v8 + (v8 < 0);
        if (v6 >= a3)
          break;
        v10 = v9 >> 1;
        v11 = a2 + 96 * (v9 >> 1);
        value = v4->value;
        flags = v4->flags;
        timescale = v4->timescale;
        epoch = v4->epoch;
        v15 = *(_QWORD *)(v11 + 48);
        v14 = v11 + 48;
        v47 = v15;
        v16 = *(_DWORD *)(v14 + 12);
        v48 = *(_DWORD *)(v14 + 8);
        v17 = *(_QWORD *)(v14 + 16);
        if ((flags & 0x1F) == 3 || (v16 & 0x1F) == 3)
        {
          memset(&time1, 0, 24);
          lhs.value = v4->value;
          lhs.timescale = v4->timescale;
          lhs.flags = flags;
          lhs.epoch = epoch;
          rhs.value = *(_QWORD *)v14;
          rhs.timescale = *(_DWORD *)(v14 + 8);
          rhs.flags = v16;
          rhs.epoch = v17;
          CMTimeSubtract(&time.start, &lhs, &rhs);
          CMTimeAbsoluteValue(&time1.start, &time.start);
          CMTimeMake(&time2, 1, 1000000000);
          lhs = time1.start;
          if (CMTimeCompare(&lhs, &time2) <= 0)
            goto LABEL_12;
        }
        time1.start.value = value;
        time1.start.timescale = timescale;
        time1.start.flags = flags;
        time1.start.epoch = epoch;
        lhs.value = v47;
        lhs.timescale = v48;
        lhs.flags = v16;
        lhs.epoch = v17;
        if (CMTimeCompare(&time1.start, &lhs) < 0)
        {
          v7 = v10 - 1;
        }
        else
        {
LABEL_12:
          v19 = *(_OWORD *)(v14 + 16);
          *(_OWORD *)&time1.start.value = *(_OWORD *)v14;
          *(_OWORD *)&time1.start.epoch = v19;
          v20 = *(_QWORD *)(v14 + 40);
          *(_QWORD *)&time1.duration.timescale = *(_QWORD *)(v14 + 32);
          if (v20)
          {
            memset(&v38, 0, sizeof(v38));
          }
          else
          {
            *(_OWORD *)&time.start.value = *(_OWORD *)v14;
            time.start.epoch = *(_QWORD *)(v14 + 16);
            *(_OWORD *)&lhs.value = *(_OWORD *)&time1.duration.value;
            lhs.epoch = 0;
            CMTimeAdd(&v38, &time.start, &lhs);
          }
          value = v4->value;
          v21 = v4->flags;
          timescale = v4->timescale;
          v22 = v4->epoch;
          if ((v21 & 0x1F) != 3 && (v38.flags & 0x1F) != 3)
            goto LABEL_35;
          memset(&time1, 0, 24);
          lhs.value = v4->value;
          lhs.timescale = v4->timescale;
          lhs.flags = v21;
          lhs.epoch = v22;
          rhs = v38;
          CMTimeSubtract(&time.start, &lhs, &rhs);
          CMTimeAbsoluteValue(&time1.start, &time.start);
          CMTimeMake(&time2, 1, 1000000000);
          lhs = time1.start;
          if (CMTimeCompare(&lhs, &time2) > 0)
          {
LABEL_35:
            time1.start.value = value;
            time1.start.timescale = timescale;
            time1.start.flags = v21;
            time1.start.epoch = v22;
            lhs = v38;
            if (CMTimeCompare(&time1.start, &lhs) < 0)
            {
              lhs = *v4;
              v29 = (_OWORD *)(a2 + 96 * v10);
              v30 = *(_OWORD *)(v14 + 16);
              *(_OWORD *)&time1.start.value = *(_OWORD *)v14;
              *(_OWORD *)&time1.start.epoch = v30;
              *(_OWORD *)&time1.duration.timescale = *(_OWORD *)(v14 + 32);
              v31 = v29[1];
              *(_OWORD *)&time.start.value = *v29;
              *(_OWORD *)&time.start.epoch = v31;
              *(_OWORD *)&time.duration.timescale = v29[2];
              return CMTimeMapTimeFromRangeToRange(a4, &lhs, &time1, &time);
            }
          }
          v6 = v10 + 1;
        }
        v8 = v7 + v6;
        if (v7 < 0)
          goto LABEL_22;
      }
      v26 = a2 + 96 * v34;
      v27 = *(_OWORD *)(v26 + 64);
      *(_OWORD *)&time1.start.value = *(_OWORD *)(v26 + 48);
      *(_OWORD *)&time1.start.epoch = v27;
      v28 = *(_QWORD *)(v26 + 88);
      *(_QWORD *)&time1.duration.timescale = *(_QWORD *)(v26 + 80);
      if (v28)
      {
        memset(&v40, 0, sizeof(v40));
      }
      else
      {
        *(_OWORD *)&time.start.value = *(_OWORD *)(v26 + 48);
        time.start.epoch = *(_QWORD *)(v26 + 64);
        *(_OWORD *)&lhs.value = *(_OWORD *)&time1.duration.value;
        lhs.epoch = 0;
        CMTimeAdd(&v40, &time.start, &lhs);
      }
      *(_OWORD *)&time1.start.value = *(_OWORD *)&v4->value;
      time1.start.epoch = v4->epoch;
      CMTimeSubtract(&v41, &time1.start, &v40);
      v32 = *(_OWORD *)(v26 + 16);
      *(_OWORD *)&time1.start.value = *(_OWORD *)v26;
      *(_OWORD *)&time1.start.epoch = v32;
      v33 = *(_QWORD *)(v26 + 40);
      *(_QWORD *)&time1.duration.timescale = *(_QWORD *)(v26 + 32);
      if (v33)
      {
        memset(&v39, 0, sizeof(v39));
      }
      else
      {
        *(_OWORD *)&time.start.value = *(_OWORD *)v26;
        time.start.epoch = *(_QWORD *)(v26 + 16);
        *(_OWORD *)&lhs.value = *(_OWORD *)&time1.duration.value;
        lhs.epoch = 0;
        CMTimeAdd(&v39, &time.start, &lhs);
      }
      v23 = &v41;
      p_time1 = (CMTimeRange *)&v39;
      v25 = a4;
    }
    return CMTimeAdd(v25, v23, &p_time1->start);
  }
  else
  {
    *(_OWORD *)&a4->value = *(_OWORD *)&result->value;
    a4->epoch = result->epoch;
  }
  return result;
}

CMTime *CMSpeedRampMapTimeFromSourceToTarget@<X0>(CMTime *result@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, CMTime *a4@<X8>)
{
  CMTime *v4;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CMTimeFlags flags;
  CMTimeEpoch epoch;
  CMTimeFlags v14;
  CMTimeEpoch v15;
  __int128 v17;
  uint64_t v18;
  CMTimeFlags v19;
  CMTimeEpoch v20;
  CMTime *v21;
  CMTimeRange *p_time1;
  CMTime *v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  _OWORD *v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  unint64_t v34;
  CMTimeRange time;
  CMTime v37;
  CMTime v38;
  CMTime v39;
  CMTime v40;
  CMTime v41;
  CMTime time2;
  CMTime rhs;
  CMTime lhs;
  CMTimeRange time1;
  CMTimeValue v46;
  CMTimeScale v47;
  CMTimeValue value;
  CMTimeScale timescale;
  uint64_t v50;

  v4 = result;
  v50 = *MEMORY[0x1E0C80C00];
  if ((result->flags & 0x1D) == 1)
  {
    v34 = a3 - 1;
    if (((a3 - 1) & 0x8000000000000000) != 0)
    {
LABEL_22:
      *(_OWORD *)&time1.start.value = *(_OWORD *)&v4->value;
      time1.start.epoch = v4->epoch;
      *(_OWORD *)&time.start.value = *(_OWORD *)a2;
      time.start.epoch = *(_QWORD *)(a2 + 16);
      CMTimeSubtract(&v41, &time1.start, &time.start);
      *(_OWORD *)&time1.start.value = *(_OWORD *)(a2 + 48);
      time1.start.epoch = *(_QWORD *)(a2 + 64);
      v21 = &v41;
      p_time1 = &time1;
      v23 = a4;
    }
    else
    {
      v6 = 0;
      v7 = a3 - 1;
      v8 = a3 - 1;
      while (1)
      {
        v9 = v8 + (v8 < 0);
        if (v6 >= a3)
          break;
        v10 = v9 >> 1;
        v11 = a2 + 96 * (v9 >> 1);
        value = v4->value;
        flags = v4->flags;
        timescale = v4->timescale;
        epoch = v4->epoch;
        v46 = *(_QWORD *)v11;
        v14 = *(_DWORD *)(v11 + 12);
        v47 = *(_DWORD *)(v11 + 8);
        v15 = *(_QWORD *)(v11 + 16);
        if ((flags & 0x1F) == 3 || (v14 & 0x1F) == 3)
        {
          memset(&time1, 0, 24);
          lhs.value = v4->value;
          lhs.timescale = v4->timescale;
          lhs.flags = flags;
          lhs.epoch = epoch;
          rhs.value = *(_QWORD *)v11;
          rhs.timescale = *(_DWORD *)(v11 + 8);
          rhs.flags = v14;
          rhs.epoch = v15;
          CMTimeSubtract(&time.start, &lhs, &rhs);
          CMTimeAbsoluteValue(&time1.start, &time.start);
          CMTimeMake(&time2, 1, 1000000000);
          lhs = time1.start;
          if (CMTimeCompare(&lhs, &time2) <= 0)
            goto LABEL_12;
        }
        time1.start.value = value;
        time1.start.timescale = timescale;
        time1.start.flags = flags;
        time1.start.epoch = epoch;
        lhs.value = v46;
        lhs.timescale = v47;
        lhs.flags = v14;
        lhs.epoch = v15;
        if (CMTimeCompare(&time1.start, &lhs) < 0)
        {
          v7 = v10 - 1;
        }
        else
        {
LABEL_12:
          v17 = *(_OWORD *)(v11 + 16);
          *(_OWORD *)&time1.start.value = *(_OWORD *)v11;
          *(_OWORD *)&time1.start.epoch = v17;
          v18 = *(_QWORD *)(v11 + 40);
          *(_QWORD *)&time1.duration.timescale = *(_QWORD *)(v11 + 32);
          if (v18)
          {
            memset(&v37, 0, sizeof(v37));
          }
          else
          {
            *(_OWORD *)&time.start.value = *(_OWORD *)v11;
            time.start.epoch = *(_QWORD *)(v11 + 16);
            *(_OWORD *)&lhs.value = *(_OWORD *)&time1.duration.value;
            lhs.epoch = 0;
            CMTimeAdd(&v37, &time.start, &lhs);
          }
          value = v4->value;
          v19 = v4->flags;
          timescale = v4->timescale;
          v20 = v4->epoch;
          if ((v19 & 0x1F) != 3 && (v37.flags & 0x1F) != 3)
            goto LABEL_35;
          memset(&time1, 0, 24);
          lhs.value = v4->value;
          lhs.timescale = v4->timescale;
          lhs.flags = v19;
          lhs.epoch = v20;
          rhs = v37;
          CMTimeSubtract(&time.start, &lhs, &rhs);
          CMTimeAbsoluteValue(&time1.start, &time.start);
          CMTimeMake(&time2, 1, 1000000000);
          lhs = time1.start;
          if (CMTimeCompare(&lhs, &time2) > 0)
          {
LABEL_35:
            time1.start.value = value;
            time1.start.timescale = timescale;
            time1.start.flags = v19;
            time1.start.epoch = v20;
            lhs = v37;
            if (CMTimeCompare(&time1.start, &lhs) < 0)
            {
              lhs = *v4;
              v27 = (_OWORD *)(a2 + 96 * v10);
              v28 = *(_OWORD *)(v11 + 16);
              *(_OWORD *)&time1.start.value = *(_OWORD *)v11;
              *(_OWORD *)&time1.start.epoch = v28;
              *(_OWORD *)&time1.duration.timescale = *(_OWORD *)(v11 + 32);
              v29 = v27[4];
              *(_OWORD *)&time.start.value = v27[3];
              *(_OWORD *)&time.start.epoch = v29;
              *(_OWORD *)&time.duration.timescale = v27[5];
              return CMTimeMapTimeFromRangeToRange(a4, &lhs, &time1, &time);
            }
          }
          v6 = v10 + 1;
        }
        v8 = v7 + v6;
        if (v7 < 0)
          goto LABEL_22;
      }
      v24 = a2 + 96 * v34;
      v25 = *(_OWORD *)(v24 + 16);
      *(_OWORD *)&time1.start.value = *(_OWORD *)v24;
      *(_OWORD *)&time1.start.epoch = v25;
      v26 = *(_QWORD *)(v24 + 40);
      *(_QWORD *)&time1.duration.timescale = *(_QWORD *)(v24 + 32);
      if (v26)
      {
        memset(&v39, 0, sizeof(v39));
      }
      else
      {
        *(_OWORD *)&time.start.value = *(_OWORD *)v24;
        time.start.epoch = *(_QWORD *)(v24 + 16);
        *(_OWORD *)&lhs.value = *(_OWORD *)&time1.duration.value;
        lhs.epoch = 0;
        CMTimeAdd(&v39, &time.start, &lhs);
      }
      *(_OWORD *)&time1.start.value = *(_OWORD *)&v4->value;
      time1.start.epoch = v4->epoch;
      CMTimeSubtract(&v40, &time1.start, &v39);
      v30 = a2 + 96 * v34;
      v31 = *(_OWORD *)(v30 + 64);
      *(_OWORD *)&time1.start.value = *(_OWORD *)(v30 + 48);
      *(_OWORD *)&time1.start.epoch = v31;
      v32 = *(_QWORD *)(v30 + 88);
      *(_QWORD *)&time1.duration.timescale = *(_QWORD *)(v30 + 80);
      if (v32)
      {
        memset(&v38, 0, sizeof(v38));
      }
      else
      {
        *(_OWORD *)&time.start.value = *(_OWORD *)(v30 + 48);
        time.start.epoch = *(_QWORD *)(v30 + 64);
        *(_OWORD *)&lhs.value = *(_OWORD *)&time1.duration.value;
        lhs.epoch = 0;
        CMTimeAdd(&v38, &time.start, &lhs);
      }
      v21 = &v40;
      p_time1 = (CMTimeRange *)&v38;
      v23 = a4;
    }
    return CMTimeAdd(v23, v21, &p_time1->start);
  }
  else
  {
    *(_OWORD *)&a4->value = *(_OWORD *)&result->value;
    a4->epoch = result->epoch;
  }
  return result;
}

uint64_t FigEndpointMessengerXPCRemotePing()
{
  uint64_t v0;
  uint64_t v1;
  void *v2;
  uint64_t v3;
  void *v5;

  v5 = 0;
  v0 = figEndpointMessengerRemoteXPC_EnsureClientEstablished();
  if ((_DWORD)v0)
  {
    v3 = v0;
    v2 = 0;
  }
  else
  {
    v1 = FigXPCCreateBasicMessage(0x2E706E67u, 0, &v5);
    v2 = v5;
    if ((_DWORD)v1)
    {
      v3 = v1;
    }
    else
    {
      v3 = FigXPCRemoteClientSendSyncMessage(gFigEndpointMessengerRemoteClient, (uint64_t)v5);
      v2 = v5;
    }
  }
  FigXPCRelease(v2);
  return v3;
}

uint64_t figEndpointMessengerRemoteXPC_EnsureClientEstablished()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __figEndpointMessengerRemoteXPC_EnsureClientEstablished_block_invoke;
  block[3] = &unk_1E28DEC20;
  block[4] = &v3;
  if (figEndpointMessengerRemoteXPC_EnsureClientEstablished_gFigEndpointMessengerClientSetupOnce != -1)
    dispatch_once(&figEndpointMessengerRemoteXPC_EnsureClientEstablished_gFigEndpointMessengerClientSetupOnce, block);
  v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t FigEndpointMessengerXPCRemoteCreateWithObjectID(const void *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *ClassID;
  uint64_t v7;
  uint64_t v9;

  if (!a1 || !a2)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  v4 = figEndpointMessengerRemoteXPC_EnsureClientEstablished();
  if ((_DWORD)v4)
    return v4;
  v9 = 0;
  v5 = *MEMORY[0x1E0C9AE00];
  ClassID = (_QWORD *)FigEndpointMessengerGetClassID();
  v7 = CMDerivedObjectCreate(v5, (uint64_t)&kEndpointMessengerRemoteXPC_MessengerVTable, ClassID, &v9);
  if (!(_DWORD)v7)
  {
    *(_QWORD *)(CMBaseObjectGetDerivedStorage(v9) + 8) = a1;
    FigXPCRemoteClientAssociateObject(gFigEndpointMessengerRemoteClient, v9, a1);
  }
  *a2 = v9;
  return v7;
}

uint64_t remoteXPCEndpointMessenger_DeadConnectionCallback(uint64_t a1)
{
  uint64_t result;

  result = CMBaseObjectGetDerivedStorage(a1);
  *(_BYTE *)(result + 1) = 1;
  return result;
}

uint64_t remoteXPCEndpointMessenger_handleClientMessage(uint64_t a1, void *a2)
{
  uint64_t result;
  uint64_t DerivedStorage;
  uint64_t v6;
  int v7;
  CFTypeRef cf;

  v7 = 0;
  result = FigXPCMessageGetOpCode(a2, &v7);
  if (!(_DWORD)result)
  {
    if (v7 == 1869968493)
    {
      cf = 0;
      DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
      if (*(_QWORD *)(DerivedStorage + 16))
      {
        v6 = DerivedStorage;
        xpc_dictionary_get_uint64(a2, "MessageType");
        FigXPCMessageCopyCFObject(a2, "Payload", (__CFDictionary **)&cf);
        (*(void (**)(void))(*(_QWORD *)(v6 + 16) + 16))();
        if (cf)
          CFRelease(cf);
      }
      return 0;
    }
    else
    {
      return 4294966630;
    }
  }
  return result;
}

void FigEndpointMessengerRemoteXPC_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v2;
  const void *v3;
  uint64_t v4;
  xpc_object_t v5;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v2 = DerivedStorage;
  v5 = 0;
  if (!*(_BYTE *)DerivedStorage)
  {
    v3 = *(const void **)(DerivedStorage + 8);
    if (!FigXPCRemoteClientDisassociateObject(gFigEndpointMessengerRemoteClient, v3)
      && !*(_BYTE *)(v2 + 1)
      && !FigXPCCreateBasicMessage(0x646F6F6Du, (uint64_t)v3, &v5))
    {
      v4 = FigXPCRemoteClientSendSyncMessage(gFigEndpointMessengerRemoteClient, (uint64_t)v5);
      FigXPCRemoteClientKillServerOnTimeout(gFigEndpointMessengerRemoteClient, v4, "FigEndpointMessengerRemoteXPC_teardown", 0);
    }
  }
  _Block_release(*(const void **)(v2 + 16));
  FigXPCRelease(v5);
}

uint64_t FigEndpointMessengerRemoteXPC_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t ObjectID;
  uint64_t v7;
  CFTypeRef v8;
  CFTypeRef v9;
  CFTypeRef cf;
  uint64_t v12;

  cf = 0;
  v12 = 0;
  ObjectID = remoteXPCEndpointMessenger_GetObjectID(a1, &v12);
  if ((_DWORD)ObjectID)
  {
    v7 = ObjectID;
    if (!a4)
      goto LABEL_11;
    v8 = 0;
LABEL_7:
    v9 = 0;
    goto LABEL_8;
  }
  v7 = FigXPCSendStdCopyPropertyMessage(gFigEndpointMessengerRemoteClient, v12, a2, &cf);
  v8 = cf;
  if (!a4)
    goto LABEL_9;
  if (!cf)
    goto LABEL_7;
  v9 = CFRetain(cf);
  v8 = cf;
LABEL_8:
  *a4 = v9;
LABEL_9:
  if (v8)
    CFRelease(v8);
LABEL_11:
  FigXPCRemoteClientKillServerOnTimeout(gFigEndpointMessengerRemoteClient, v7, "FigEndpointMessengerRemoteXPC_CopyProperty", a2);
  return v7;
}

uint64_t FigEndpointMessengerRemoteXPC_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t ObjectID;
  uint64_t v6;
  uint64_t v8;

  v8 = 0;
  ObjectID = remoteXPCEndpointMessenger_GetObjectID(a1, &v8);
  if (!(_DWORD)ObjectID)
    ObjectID = FigXPCSendStdSetPropertyMessage(gFigEndpointMessengerRemoteClient, v8, a2, a3);
  v6 = ObjectID;
  FigXPCRemoteClientKillServerOnTimeout(gFigEndpointMessengerRemoteClient, ObjectID, "FigEndpointMessengerRemoteXPC_SetProperty", a2);
  return v6;
}

uint64_t remoteXPCEndpointMessenger_GetObjectID(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)DerivedStorage)
  {
    v5 = 4294954511;
  }
  else
  {
    if (!*(_BYTE *)(DerivedStorage + 1))
    {
      *a2 = *(_QWORD *)(DerivedStorage + 8);
      return 0;
    }
    v5 = 4294966630;
  }
  return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointMessengerRemoteXPC_SetMessageHandler(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage;
  uint64_t ObjectID;
  uint64_t v6;
  uint64_t v8;
  xpc_object_t v9;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v8 = 0;
  v9 = 0;
  ObjectID = remoteXPCEndpointMessenger_GetObjectID(a1, &v8);
  if ((_DWORD)ObjectID || (ObjectID = FigXPCCreateBasicMessage(0x7368646Cu, v8, &v9), (_DWORD)ObjectID))
  {
    v6 = ObjectID;
  }
  else
  {
    v6 = FigXPCRemoteClientSendSyncMessage(gFigEndpointMessengerRemoteClient, (uint64_t)v9);
    if (!(_DWORD)v6)
      *(_QWORD *)(DerivedStorage + 16) = _Block_copy(a2);
  }
  FigXPCRelease(v9);
  return v6;
}

uint64_t FigEndpointMessengerRemoteXPC_SendMessage(uint64_t a1, unsigned int a2, const void *a3)
{
  uint64_t ObjectID;
  uint64_t v6;
  uint64_t v8;
  xpc_object_t xdict;

  v8 = 0;
  xdict = 0;
  ObjectID = remoteXPCEndpointMessenger_GetObjectID(a1, &v8);
  if (!(_DWORD)ObjectID)
  {
    ObjectID = FigXPCCreateBasicMessage(0x736D7367u, v8, &xdict);
    if (!(_DWORD)ObjectID)
    {
      xpc_dictionary_set_uint64(xdict, "MessageType", a2);
      if (!a2)
      {
        v6 = 4294966630;
        goto LABEL_9;
      }
      if (!a3 || (ObjectID = FigXPCMessageSetCFObject(xdict, "Payload", a3), !(_DWORD)ObjectID))
        ObjectID = FigXPCRemoteClientSendSyncMessage(gFigEndpointMessengerRemoteClient, (uint64_t)xdict);
    }
  }
  v6 = ObjectID;
LABEL_9:
  FigXPCRelease(xdict);
  return v6;
}

uint64_t FigRetainProxyGetTypeID()
{
  FigThreadRunOnce(&sRegisterFigRetainProxyTypeOnce, (void (*)(void))RegisterFigRetainProxyType);
  return sFigRetainProxyID;
}

uint64_t RegisterFigRetainProxyType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigRetainProxyID = result;
  return result;
}

uint64_t FigRetainProxyIsInvalidated(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 48);
}

uint64_t FigRetainProxyInvalidate(uint64_t a1)
{
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  *(_BYTE *)(a1 + 48) = 1;
  return FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
}

CFTypeRef FigRetainProxyRetain(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

void FigRetainProxyRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t FigRetainProxyLockMutex(uint64_t a1)
{
  uint64_t v2;

  v2 = FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
  figRetainProxyIncrementLockCount(a1);
  return v2;
}

void figRetainProxyIncrementLockCount(uint64_t a1)
{
  uint64_t v1;
  id *v3;

  v1 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = v1 + 1;
  if (!v1)
  {
    v3 = FigCFWeakReferenceHolderCopyReferencedObject(*(id **)(a1 + 32));
    if (v3 == *(id **)(a1 + 24))
    {
      *(_BYTE *)(a1 + 49) = 1;
    }
    else
    {
      if (v3)
        CFRelease(v3);
      *(_BYTE *)(a1 + 48) = 1;
    }
  }
}

BOOL FigRetainProxyTryLockMutex(uint64_t a1)
{
  _BOOL8 v2;

  v2 = FigReentrantMutexTryLock(*(pthread_mutex_t **)(a1 + 16));
  if (v2)
    figRetainProxyIncrementLockCount(a1);
  return v2;
}

uint64_t FigRetainProxyGetLockCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t FigRetainProxyConditionVariableWaitRelative(uint64_t a1, pthread_cond_t *a2, unint64_t a3)
{
  uint64_t v6;
  const void *v7;
  uint64_t v8;

  v6 = *(_QWORD *)(a1 + 40) - 1;
  *(_QWORD *)(a1 + 40) = v6;
  if (!v6 && *(_BYTE *)(a1 + 49) == 1)
  {
    *(_BYTE *)(a1 + 49) = 0;
    v7 = *(const void **)(a1 + 24);
    if (v7)
      CFRelease(v7);
  }
  v8 = FigConditionVariableWaitRelative(a2, *(pthread_mutex_t **)(a1 + 16), a3);
  figRetainProxyIncrementLockCount(a1);
  return v8;
}

uint64_t FigRetainProxyUnlockMutex(uint64_t a1)
{
  uint64_t v1;
  const void *v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1 + 40) - 1;
  *(_QWORD *)(a1 + 40) = v1;
  if (v1 || *(_BYTE *)(a1 + 49) != 1)
    return FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  *(_BYTE *)(a1 + 49) = 0;
  v2 = *(const void **)(a1 + 24);
  v3 = FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
  if (v2)
    CFRelease(v2);
  return v3;
}

uint64_t FigRetainProxyUnlockAll(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  if (*(_BYTE *)(a1 + 49))
  {
    *(_BYTE *)(a1 + 49) = 0;
    v3 = *(const void **)(a1 + 24);
    if (v3)
      CFRelease(v3);
  }
  if (v2 >= 1)
  {
    v4 = v2;
    do
    {
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 16));
      --v4;
    }
    while (v4);
  }
  return v2;
}

void FigRetainProxyRelock(uint64_t a1, uint64_t a2)
{
  do
  {
    FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 16));
    figRetainProxyIncrementLockCount(a1);
  }
  while (*(_QWORD *)(a1 + 40) < a2);
}

uint64_t FigRetainProxyGetOwner(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

CFTypeRef FigRetainProxyRetainOwner(uint64_t a1)
{
  CFTypeRef result;

  result = *(CFTypeRef *)(a1 + 24);
  if (result)
    return CFRetain(result);
  return result;
}

void FigRetainProxyReleaseOwner(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 24);
  if (v1)
    CFRelease(v1);
}

uint64_t FigRetainProxyCreate(const __CFAllocator *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t Instance;
  _QWORD *v7;
  pthread_mutex_t *v8;
  CFTypeRef v9;
  uint64_t v11;
  uint64_t v12;

  if (!a2 || !a3)
  {
    v12 = 4294954516;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  FigThreadRunOnce(&sRegisterFigRetainProxyTypeOnce, (void (*)(void))RegisterFigRetainProxyType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v12 = 4294954510;
    return FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
  }
  v7 = (_QWORD *)Instance;
  v8 = FigReentrantMutexCreateWithFlags(a1);
  v7[2] = v8;
  if (v8 && (v7[3] = a2, v9 = FigCFWeakReferenceHolderCreateWithReferencedObject(a2), (v7[4] = v9) != 0))
  {
    v7[5] = 0;
    *a3 = v7;
    return 0;
  }
  else
  {
    v11 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    CFRelease(v7);
    return v11;
  }
}

double FigRetainProxyInit(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

__n128 FigRetainProxyFinalize(__n128 *a1)
{
  const void *v2;
  unint64_t v3;
  __n128 *v4;
  unint64_t v5;
  __n128 result;

  v2 = (const void *)a1[2].n128_u64[0];
  if (v2)
    CFRelease(v2);
  v5 = a1[1].n128_u64[0];
  v4 = a1 + 1;
  v3 = v5;
  if (v5)
    FigReentrantMutexDestroy(v3);
  v4[2].n128_u64[0] = -1;
  result.n128_u64[0] = -1;
  result.n128_u64[1] = -1;
  *v4 = result;
  v4[1] = result;
  return result;
}

CFStringRef FigRetainProxyCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigRetainProxy %p]"), a1);
}

CFStringRef FigRetainProxyCopyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  uint64_t v3;
  const char *v4;
  CFIndex v5;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v3 = *(_QWORD *)(a1 + 24);
  if (*(_BYTE *)(a1 + 49))
    v4 = " retained";
  else
    v4 = "";
  v5 = CFGetRetainCount((CFTypeRef)a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("[FigRetainProxy %p owner %p%s retain count %d lock count %d"), a1, v3, v4, v5, *(_QWORD *)(a1 + 40));
}

uint64_t FigIsReferenceAllowedBySecurityPolicy(const __CFURL *a1, const __CFURL *a2, char a3)
{
  int URLZone;
  int v7;
  const __CFString *v8;
  CFURLRef v9;
  const __CFString *v10;
  uint64_t v11;
  const __CFString *v12;
  const __CFString *v13;
  CFStringRef v14;

  URLZone = GetURLZone(a1);
  v7 = GetURLZone(a2);
  if ((a3 & 2) != 0 && URLZone == 2 && v7 == 1 || (a3 & 4) != 0 && URLZone == 1 && v7 == 2)
    return 0;
  if ((a3 & 0x10) == 0 || URLZone != 1 || v7 != 1)
  {
    v11 = 1;
    if ((a3 & 8) == 0 || URLZone != 2 || v7 != 2)
      return v11;
    v12 = CFURLCopyScheme(a1);
    v13 = CFURLCopyScheme(a2);
    v8 = CFURLCopyHostName(a1);
    v14 = CFURLCopyHostName(a2);
    v10 = v14;
    if (v12 && v8 && v13 && v14)
    {
      if (CFStringCompare(v12, v13, 1uLL))
        v11 = 0;
      else
        v11 = CFStringCompare(v8, v10, 1uLL) == kCFCompareEqualTo;
    }
    else if (!v12)
    {
LABEL_29:
      if (v13)
        CFRelease(v13);
LABEL_31:
      if (!v8)
        goto LABEL_33;
      goto LABEL_32;
    }
    CFRelease(v12);
    goto LABEL_29;
  }
  v8 = (const __CFString *)CFURLCopyAbsoluteURL(a1);
  v9 = CFURLCopyAbsoluteURL(a2);
  v10 = (const __CFString *)v9;
  if (!v8 || !v9)
  {
    v11 = 1;
    goto LABEL_31;
  }
  v11 = CFEqual(v8, v9);
LABEL_32:
  CFRelease(v8);
LABEL_33:
  if (v10)
    CFRelease(v10);
  return v11;
}

uint64_t GetURLZone(const __CFURL *a1)
{
  const __CFString *v1;
  const __CFString *v2;
  uint64_t v3;

  if (!a1)
    return 0;
  v1 = CFURLCopyScheme(a1);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = 1;
  if (CFStringCompare(v1, CFSTR("file"), 1uLL))
  {
    if (CFStringCompare(v2, CFSTR("res"), 1uLL))
      v3 = 2;
    else
      v3 = 1;
  }
  CFRelease(v2);
  return v3;
}

uint64_t FigCustomURLLoaderRemoteCreateWithObjectID(const void *a1, CFTypeRef *a2)
{
  uint64_t v4;
  const void *v5;
  _QWORD *ClassID;
  uint64_t v7;
  CFTypeRef v8;
  _QWORD *DerivedStorage;
  uint64_t v10;
  CFTypeRef cf;

  cf = 0;
  if (figCustomURLLoaderRemote_EnsureClientEstablished_gFigCustomURLLoaderRemoteOnce != -1)
    dispatch_once(&figCustomURLLoaderRemote_EnsureClientEstablished_gFigCustomURLLoaderRemoteOnce, &__block_literal_global_33);
  v4 = figCustomURLLoaderRemote_EnsureClientEstablished_err;
  if (!figCustomURLLoaderRemote_EnsureClientEstablished_err)
  {
    v5 = (const void *)*MEMORY[0x1E0C9AE00];
    ClassID = (_QWORD *)FigCustomURLLoaderGetClassID();
    v7 = CMDerivedObjectCreate((uint64_t)v5, (uint64_t)&kFigCustomURLLoaderRemote_VTable, ClassID, &cf);
    v8 = cf;
    if (!(_DWORD)v7)
    {
      DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
      *DerivedStorage = a1;
      v10 = FigCustomURLLoaderCreate(v5, 0, DerivedStorage + 3);
      if ((_DWORD)v10)
      {
        v4 = v10;
        v8 = cf;
LABEL_12:
        if (v8)
          CFRelease(v8);
        return v4;
      }
      v7 = FigCFWeakReferenceTableCreate((const __CFAllocator *)v5, 1, DerivedStorage + 2);
      v8 = cf;
      if (!(_DWORD)v7)
      {
        v4 = FigXPCRemoteClientAssociateObject(gFigCustomURLLoaderRemoteClient, (uint64_t)cf, a1);
        v8 = cf;
        if (!(_DWORD)v4)
        {
          *a2 = cf;
          return v4;
        }
        goto LABEL_12;
      }
    }
    v4 = v7;
    goto LABEL_12;
  }
  return v4;
}

uint64_t figCustomURLLoaderRemote_GetObjectID(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  uint64_t v5;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)(DerivedStorage + 8))
  {
    v5 = 4294949911;
  }
  else
  {
    if (!*(_BYTE *)(DerivedStorage + 9))
    {
      *a2 = *(_QWORD *)DerivedStorage;
      return 0;
    }
    v5 = 4294949910;
  }
  return FigSignalErrorAt(v5, 0, 0, 0, 0, 0, 0);
}

uint64_t figCustomURLLoaderRemote_DeadConnectionCallback(const void *a1)
{
  CFTypeID v2;
  uint64_t result;

  v2 = CFGetTypeID(a1);
  result = FigCustomURLLoaderGetCFTypeID();
  if (v2 == result)
  {
    result = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    *(_BYTE *)(result + 8) = 1;
  }
  return result;
}

void figCustomURLLoaderRemote_serverStatePurged(const void *a1, uint64_t a2)
{
  CFTypeID v4;
  CFMutableDictionaryRef Mutable;
  __CFNotificationCenter *DefaultLocalCenter;

  v4 = CFGetTypeID(a1);
  if (v4 == FigCustomURLLoaderGetCFTypeID())
  {
    *(_BYTE *)(CMBaseObjectGetDerivedStorage((uint64_t)a1) + 9) = 1;
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    FigCFDictionarySetInt64(Mutable, CFSTR("PurgeIdentifier"), a2);
    DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
    CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("CustomURLLoader_ServerStatePurged"), a1, Mutable);
    if (Mutable)
      CFRelease(Mutable);
  }
}

void figCustomURLLoaderRemote_Finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  void *v2;
  const void *v3;
  const void *v4;
  int v5;
  uint64_t v6;
  void *v7;

  v7 = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  FigXPCRemoteClientDisassociateObject(gFigCustomURLLoaderRemoteClient, *(const void **)DerivedStorage);
  v2 = *(void **)DerivedStorage;
  if (*(_QWORD *)DerivedStorage)
  {
    if (*(_BYTE *)(DerivedStorage + 8) || *(_BYTE *)(DerivedStorage + 9))
    {
      v2 = 0;
    }
    else
    {
      v5 = FigXPCCreateBasicMessage(0x636C4469u, (uint64_t)v2, &v7);
      v2 = v7;
      if (!v5)
      {
        v6 = FigXPCRemoteClientSendAsyncMessage(gFigCustomURLLoaderRemoteClient, v7);
        FigXPCRemoteClientKillServerOnTimeout(gFigCustomURLLoaderRemoteClient, v6, "figCustomURLLoaderRemote_Finalize", 0);
        v2 = v7;
      }
    }
  }
  FigXPCRelease(v2);
  v3 = *(const void **)(DerivedStorage + 16);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(DerivedStorage + 16) = 0;
  }
  v4 = *(const void **)(DerivedStorage + 24);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(DerivedStorage + 24) = 0;
  }
}

uint64_t figCustomURLLoaderRemote_SetProperty(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t *DerivedStorage;

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  return FigXPCSendStdSetPropertyMessage(gFigCustomURLLoaderRemoteClient, *DerivedStorage, a2, a3);
}

uint64_t figCustomURLLoaderRemote_CreateAndInstallHandler(uint64_t a1, int64_t a2, const char *a3, uint64_t a4, NSObject *a5, __int128 *a6, const void *a7, CFTypeRef *a8)
{
  uint64_t v16;
  uint64_t v17;
  CFTypeRef v18;
  uint64_t DerivedStorage;
  uint64_t ObjectID;
  uint64_t v21;
  uint64_t (*v22)(uint64_t, CFTypeRef, int64_t);
  xpc_object_t v23;
  CFTypeRef cf;
  uint64_t v26;
  uint64_t value;
  xpc_object_t v28;
  xpc_object_t xdict;
  int v30;

  cf = 0;
  if (figCustomURLLoaderRemote_EnsureClientEstablished_gFigCustomURLLoaderRemoteOnce != -1)
    dispatch_once(&figCustomURLLoaderRemote_EnsureClientEstablished_gFigCustomURLLoaderRemoteOnce, &__block_literal_global_33);
  v16 = figCustomURLLoaderRemote_EnsureClientEstablished_err;
  if (!figCustomURLLoaderRemote_EnsureClientEstablished_err)
  {
    v17 = FigCustomURLHandlerCreate((const void *)*MEMORY[0x1E0C9AE00], a3, a4, a5, a6, (uint64_t)a7, &cf);
    v18 = cf;
    if ((_DWORD)v17)
    {
      v16 = v17;
LABEL_22:
      if (v18)
        CFRelease(v18);
      return v16;
    }
    v30 = 0;
    v28 = 0;
    xdict = 0;
    v26 = 0;
    value = 0;
    DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
    ObjectID = figCustomURLLoaderRemote_GetObjectID(a1, &v26);
    if (!(_DWORD)ObjectID)
    {
      ObjectID = FigCustomURLHandlerServerEnsure();
      if (!(_DWORD)ObjectID)
      {
        ObjectID = FigXPCRemoteClientGetServerPID(gFigCustomURLLoaderRemoteClient, &v30);
        if (!(_DWORD)ObjectID)
        {
          ObjectID = FigCustomURLHandlerServerAssociateObjectByPID(v30, v18, &value);
          if (!(_DWORD)ObjectID)
          {
            ObjectID = FigCFWeakReferenceTableAddValueAssociatedWithKey(*(_QWORD *)(DerivedStorage + 16), (uint64_t)v18, value);
            if (!(_DWORD)ObjectID)
            {
              v21 = *(_QWORD *)(DerivedStorage + 24);
              v22 = *(uint64_t (**)(uint64_t, CFTypeRef, int64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v21) + 16)
                                                                          + 8);
              if (!v22)
              {
                v23 = 0;
                v16 = 4294954514;
                goto LABEL_17;
              }
              ObjectID = v22(v21, v18, a2);
              if (!(_DWORD)ObjectID)
              {
                ObjectID = FigXPCCreateBasicMessage(0x636C4349u, v26, &xdict);
                if (!(_DWORD)ObjectID)
                {
                  ObjectID = figCustomURLLoaderRemote_addHandshakeParameters(xdict);
                  if (!(_DWORD)ObjectID)
                  {
                    xpc_dictionary_set_uint64(xdict, "CustomURLLoader_HandlerID", value);
                    xpc_dictionary_set_int64(xdict, "CustomURLLoader_Priority", a2);
                    ObjectID = FigXPCMessageSetCFDictionary(xdict, "CustomURLLoader_CreateOptions", a7);
                    if (!(_DWORD)ObjectID)
                    {
                      v16 = FigXPCRemoteClientSendSyncMessageCreatingReply(gFigCustomURLLoaderRemoteClient, (uint64_t)xdict, &v28);
                      v23 = v28;
                      goto LABEL_17;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v16 = ObjectID;
    v23 = 0;
LABEL_17:
    FigXPCRelease(v23);
    FigXPCRelease(xdict);
    v18 = cf;
    if (!(_DWORD)v16)
    {
      *a8 = cf;
      return v16;
    }
    goto LABEL_22;
  }
  return v16;
}

uint64_t figCustomURLLoaderRemote_GetURL(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t DerivedStorage;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!DerivedStorage)
    return FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
  v12 = *(_QWORD *)(DerivedStorage + 24);
  if (!v12)
    return FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
  v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(*(_QWORD *)(DerivedStorage + 24)) + 16)
                                                                                       + 24);
  if (v13)
    return v13(v12, a2, a3, a4, a5, a6);
  else
    return 4294954514;
}

uint64_t figCustomURLLoaderRemote_CancelRequest(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, uint64_t);

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (!DerivedStorage)
    return FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
  v4 = *(_QWORD *)(DerivedStorage + 24);
  if (!v4)
    return FigSignalErrorAt(4294954514, 0, 0, 0, 0, 0, 0);
  v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(*(_QWORD *)(DerivedStorage + 24))
                                                              + 16)
                                                  + 32);
  if (v5)
    return v5(v4, a2);
  else
    return 4294954514;
}

uint64_t figCustomURLLoaderRemote_TransferHandlingOfRequest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage;
  uint64_t ObjectID;
  uint64_t v10;
  uint64_t Key;
  uint64_t v12;
  xpc_object_t v13;
  uint64_t v15;
  xpc_object_t xdict;

  v15 = 0;
  xdict = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  ObjectID = figCustomURLLoaderRemote_GetObjectID(a1, &v15);
  if ((_DWORD)ObjectID)
  {
    v10 = ObjectID;
LABEL_10:
    v13 = 0;
    goto LABEL_8;
  }
  if (figCustomURLLoaderRemote_EnsureClientEstablished_gFigCustomURLLoaderRemoteOnce != -1)
    dispatch_once(&figCustomURLLoaderRemote_EnsureClientEstablished_gFigCustomURLLoaderRemoteOnce, &__block_literal_global_33);
  v10 = figCustomURLLoaderRemote_EnsureClientEstablished_err;
  if (figCustomURLLoaderRemote_EnsureClientEstablished_err)
    goto LABEL_10;
  Key = FigCFWeakReferenceTableGetKey(*(_QWORD *)(DerivedStorage + 16), a2);
  v12 = FigCFWeakReferenceTableGetKey(*(_QWORD *)(DerivedStorage + 16), a3);
  v10 = FigXPCCreateBasicMessage(0x636C5452u, v15, &xdict);
  v13 = xdict;
  if (!(_DWORD)v10)
  {
    v10 = figCustomURLLoaderRemote_addHandshakeParameters(xdict);
    v13 = xdict;
    if (!(_DWORD)v10)
    {
      xpc_dictionary_set_uint64(xdict, "CustomURLLoader_FromHandlerID", Key);
      xpc_dictionary_set_uint64(xdict, "CustomURLLoader_ToHandlerID", v12);
      xpc_dictionary_set_uint64(xdict, "CustomURLLoader_RequestID", a4);
      v10 = FigXPCRemoteClientSendSyncMessage(gFigCustomURLLoaderRemoteClient, (uint64_t)xdict);
      v13 = xdict;
    }
  }
LABEL_8:
  FigXPCRelease(v13);
  return v10;
}

uint64_t figCustomURLLoaderRemote_addHandshakeParameters(void *a1)
{
  uint64_t v2;
  xpc_object_t value;

  value = 0;
  v2 = FigCustomURLHandlerServerCopyXPCEndpoint(&value);
  if (!(_DWORD)v2)
    xpc_dictionary_set_value(a1, "CustomURLLoader_Endpoint", value);
  FigXPCRelease(value);
  return v2;
}

uint64_t FigManagedFilePoolGetTypeID()
{
  FigThreadRunOnce(&sRegisterFigManagedFilePoolTypeOnce, (void (*)(void))RegisterFigManagedFilePoolType);
  return sFigManagedFilePoolID;
}

uint64_t RegisterFigManagedFilePoolType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigManagedFilePoolID = result;
  return result;
}

uint64_t FigManagedFilePoolCreate(int64_t a1, CFAllocatorRef Default, _QWORD *a3)
{
  uint64_t Instance;
  _QWORD *v7;
  pthread_mutex_t *v8;
  char *v9;
  int64_t v10;
  char *v11;
  uint64_t v12;

  if (a1 <= 0)
  {
    v12 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    v7 = 0;
LABEL_14:
    if (!a3)
      return v12;
LABEL_15:
    *a3 = v7;
    return v12;
  }
  if (a3)
  {
    FigThreadRunOnce(&sRegisterFigManagedFilePoolTypeOnce, (void (*)(void))RegisterFigManagedFilePoolType);
    Instance = _CFRuntimeCreateInstance();
    v7 = (_QWORD *)Instance;
    if (!Instance)
    {
      v12 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      goto LABEL_15;
    }
    if (Default)
    {
      *(_QWORD *)(Instance + 16) = Default;
    }
    else
    {
      Default = CFAllocatorGetDefault();
      v7[2] = Default;
      if (!Default)
        goto LABEL_8;
    }
    CFRetain(Default);
LABEL_8:
    v8 = FigReentrantMutexCreate();
    v7[3] = v8;
    if (!v8 || (v9 = (char *)malloc_type_calloc(a1, 0x10uLL, 0x20040A4A59CD2uLL)) == 0)
    {
      v12 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
      if ((_DWORD)v12)
      {
        CFRelease(v7);
        v7 = 0;
      }
      goto LABEL_15;
    }
    if ((unint64_t)a1 >= 2)
    {
      v10 = a1 - 1;
      v11 = v9 + 16;
      do
      {
        *((_QWORD *)v11 - 2) = v11;
        v11 += 16;
        --v10;
      }
      while (v10);
    }
    v12 = 0;
    v7[6] = a1;
    v7[7] = v9;
    goto LABEL_14;
  }
  return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
}

uint64_t FigGetDefaultManagedFilePool()
{
  FigThreadRunOnce(&FigGetDefaultManagedFilePool_sCreateDefaultManagedFilePoolOnce, (void (*)(void))createDefaultManagedFilePool);
  return sFigDefaultManagedFilePool;
}

uint64_t createDefaultManagedFilePool()
{
  return FigManagedFilePoolCreate(100, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], &sFigDefaultManagedFilePool);
}

uint64_t FigManagedFilePoolCreateByteStreamForFile(const void *a1, const __CFURL *a2, int a3, uint64_t a4, CFTypeRef *a5)
{
  _QWORD *ClassID;
  uint64_t v11;
  CFTypeRef v12;
  uint64_t DerivedStorage;
  CFTypeRef cf;

  cf = 0;
  if (!a1 || !a2 || !a5 || (a3 & 0xFFFFFFBF) != 0)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  ClassID = (_QWORD *)CMByteStreamGetClassID();
  v11 = CMDerivedObjectCreate(a4, (uint64_t)&kManagedFileByteStreamVTable, ClassID, &cf);
  v12 = cf;
  if ((_DWORD)v11
    || (DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf),
        *(_QWORD *)DerivedStorage = CFRetain(a1),
        *(_BYTE *)(DerivedStorage + 16) = 0,
        *(_QWORD *)(DerivedStorage + 24) = 0,
        *(_QWORD *)(DerivedStorage + 32) = 0,
        v11 = FindAndRetainManagedFile(DerivedStorage, a2, 0, a3),
        v12 = cf,
        (_DWORD)v11))
  {
    if (v12)
      CFRelease(v12);
  }
  else
  {
    *a5 = cf;
  }
  return v11;
}

uint64_t FindAndRetainManagedFile(uint64_t a1, const __CFURL *a2, unsigned int *a3, int a4)
{
  int v8;
  uint64_t v9;
  int DarwinFileDesc;
  uint64_t FileInfo;
  uint64_t v12;
  _DWORD *v13;
  __int128 v14;
  uint64_t v15;
  unsigned __int8 *v16;
  uint64_t v17;
  unsigned int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  int v22;
  unsigned int v24;
  unsigned __int8 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  stat v29;

  v28 = 0;
  v26 = 0u;
  v27 = 0u;
  v8 = *(unsigned __int8 *)(a1 + 16);
  v9 = *(_QWORD *)a1;
  v25 = 0;
  if (!v8)
  {
    FileInfo = FigFileGetFileInfo(a2, (uint64_t)&v26);
    if (!(_DWORD)FileInfo)
      goto LABEL_6;
LABEL_34:
    v20 = FileInfo;
    goto LABEL_36;
  }
  DarwinFileDesc = FigFileGetDarwinFileDesc(a3);
  if (DarwinFileDesc == -1)
  {
    FileInfo = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_34;
  }
  memset(&v29, 0, sizeof(v29));
  if (!fstat(DarwinFileDesc, &v29))
  {
    LODWORD(v28) = v29.st_mtimespec.tv_nsec;
    *(_QWORD *)&v26 = v29.st_size;
    *((_QWORD *)&v26 + 1) = v29.st_dev;
    *(_QWORD *)&v27 = v29.st_ino;
    *((_QWORD *)&v27 + 1) = v29.st_mtimespec.tv_sec;
    goto LABEL_6;
  }
  v20 = FigSignalErrorAt(4294954422, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)v20)
  {
LABEL_36:
    *(_QWORD *)(a1 + 8) = 0;
    goto LABEL_25;
  }
LABEL_6:
  FigReentrantMutexLock(*(pthread_mutex_t **)(v9 + 24));
  v12 = *(_QWORD *)(v9 + 32);
  if (v12)
  {
    while (!CFEqual(a2, *(CFTypeRef *)(v12 + 24))
         || *(_DWORD *)(v12 + 16) != a4
         || !FigFileInfoEqual((uint64_t)&v26, v12 + 32)
         || *(unsigned __int8 *)(v12 + 72) != v8)
    {
      v12 = *(_QWORD *)(v12 + 8);
      if (!v12)
        goto LABEL_12;
    }
    FigAtomicIncrement32((unsigned int *)(v12 + 88));
    goto LABEL_23;
  }
LABEL_12:
  v13 = malloc_type_calloc(1uLL, 0x68uLL, 0x106004065D502D3uLL);
  if (!v13)
  {
    v24 = FigSignalErrorAt(4294954510, 0, 0, 0, 0, 0, 0);
    if (v24)
      v20 = v24;
    else
      v20 = 0;
    v12 = 0;
    goto LABEL_24;
  }
  v12 = (uint64_t)v13;
  v13[22] = 1;
  *((_QWORD *)v13 + 3) = CFRetain(a2);
  *(_DWORD *)(v12 + 16) = a4;
  v14 = v27;
  *(_OWORD *)(v12 + 32) = v26;
  *(_OWORD *)(v12 + 48) = v14;
  *(_QWORD *)(v12 + 64) = v28;
  *(_BYTE *)(v12 + 72) = v8;
  v15 = *(_QWORD *)a1;
  FigReentrantMutexLock(*(pthread_mutex_t **)(*(_QWORD *)a1 + 24));
  if (*(_BYTE *)(a1 + 16))
  {
    if (!a3)
    {
      v19 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      goto LABEL_18;
    }
    v16 = &v25;
    v17 = a1;
    v18 = a3;
  }
  else
  {
    v17 = a1;
    v18 = 0;
    v16 = 0;
  }
  v19 = AccessManagedFileHelper(v17, v18, v16, v12);
LABEL_18:
  v20 = v19;
  if (!(_DWORD)v19)
  {
    FigAtomicDecrement32((unsigned int *)(v12 + 92));
    v21 = *(uint64_t **)(v15 + 32);
    if (v21)
    {
      *v21 = v12;
      *(_QWORD *)(v12 + 8) = *(_QWORD *)(v15 + 32);
    }
    else
    {
      *(_QWORD *)(v15 + 40) = v12;
    }
    *(_QWORD *)(v15 + 32) = v12;
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(v15 + 24));
LABEL_23:
    v20 = 0;
    goto LABEL_24;
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(v15 + 24));
  DisposeManagedFile((_QWORD *)v12);
  v12 = 0;
LABEL_24:
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(v9 + 24));
  v22 = v25;
  *(_QWORD *)(a1 + 8) = v12;
  if (!v22)
LABEL_25:
    FigFileForkClose((int *)a3);
  return v20;
}

uint64_t FigManagedFilePoolCreateByteStreamForOpenFileAssumingOwnership(const void *a1, const __CFURL *a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, CFTypeRef *a7)
{
  unsigned int *v7;
  _QWORD *ClassID;
  uint64_t v15;
  uint64_t DerivedStorage;
  uint64_t v17;
  CFTypeRef cf;

  v7 = a3;
  cf = 0;
  if (!a1 || !a2 || !a3 || !a4 || !a5 || !a7)
  {
    v15 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  ClassID = (_QWORD *)CMByteStreamGetClassID();
  v15 = CMDerivedObjectCreate(a6, (uint64_t)&kManagedFileByteStreamVTable, ClassID, &cf);
  if ((_DWORD)v15)
  {
LABEL_14:
    v17 = v15;
    goto LABEL_10;
  }
  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)cf);
  *(_QWORD *)DerivedStorage = CFRetain(a1);
  *(_BYTE *)(DerivedStorage + 16) = 1;
  *(_QWORD *)(DerivedStorage + 24) = a4;
  *(_QWORD *)(DerivedStorage + 32) = FigCFWeakReferenceHolderCreateWithReferencedObject(a5);
  v17 = FindAndRetainManagedFile(DerivedStorage, a2, v7, 0);
  v7 = 0;
  if (!(_DWORD)v17)
  {
    *a7 = cf;
    cf = 0;
  }
LABEL_10:
  FigFileForkClose((int *)v7);
  if (cf)
    CFRelease(cf);
  return v17;
}

double ManagedFilePoolInit(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void ManagedFilePoolFinalize(uint64_t a1)
{
  uint64_t v2;
  const void *v3;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    FigReentrantMutexDestroy(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  free(*(void **)(a1 + 56));
  *(_QWORD *)(a1 + 56) = 0;
  v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

CFStringRef ManagedFilePoolCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigManagedFilePool %p]"), a1);
}

__CFString *ManagedFilePoolCopyDebugDesc(_QWORD *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  uint64_t v4;
  CFIndex v5;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = a1[6];
  v5 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("FigManagedFilePool %p of %d descriptors retainCount: %d"), a1, v4, v5);
  return Mutable;
}

BOOL ManagedFileByteStreamEqual(uint64_t a1, uint64_t a2)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  return *(_QWORD *)(DerivedStorage + 8) == *(_QWORD *)(CMBaseObjectGetDerivedStorage(a2) + 8);
}

void ManagedFileByteStreamFinalize(uint64_t a1)
{
  uint64_t *DerivedStorage;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  const void *v7;

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  v2 = DerivedStorage;
  v3 = DerivedStorage[1];
  if (v3)
  {
    v4 = *DerivedStorage;
    FigReentrantMutexLock(*(pthread_mutex_t **)(*DerivedStorage + 24));
    if (!FigAtomicDecrement32((unsigned int *)(v3 + 88)))
    {
      CloseManagedFile(v4, v3);
      v5 = *(_QWORD *)v3;
      v6 = *(_QWORD **)(v3 + 8);
      if (*(_QWORD *)v3)
      {
        *(_QWORD *)(v5 + 8) = v6;
        v6 = *(_QWORD **)(v3 + 8);
      }
      else
      {
        *(_QWORD *)(v4 + 32) = v6;
        v5 = *(_QWORD *)v3;
      }
      if (!v6)
        v6 = (_QWORD *)(v4 + 40);
      *v6 = v5;
      *(_QWORD *)v3 = 0;
      *(_QWORD *)(v3 + 8) = 0;
      DisposeManagedFile((_QWORD *)v3);
    }
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(v4 + 24));
    v2[1] = 0;
  }
  v7 = (const void *)v2[4];
  if (v7)
  {
    CFRelease(v7);
    v2[4] = 0;
  }
  v2[3] = 0;
  if (*v2)
  {
    CFRelease((CFTypeRef)*v2);
    *v2 = 0;
  }
}

__CFString *ManagedFileByteStreamCopyDebugDescription(uint64_t a1)
{
  _QWORD *DerivedStorage;
  __CFString *Mutable;
  CFStringRef v3;
  CFStringRef v4;
  const __CFString *v5;
  const char *v6;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v3 = CFCopyDescription(*(CFTypeRef *)(DerivedStorage[1] + 24));
  v4 = v3;
  v5 = CFSTR("UNKNOWN PATH");
  if (v3)
    v5 = v3;
  if (*(_QWORD *)(DerivedStorage[1] + 80))
    v6 = "open";
  else
    v6 = "closed";
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigManagedFileByteStream %p>{%@} Owning pool %p Currently %s"), DerivedStorage, v5, *DerivedStorage, v6);
  if (v4)
    CFRelease(v4);
  return Mutable;
}

uint64_t ManagedFileByteStreamCopyProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t DerivedStorage;
  uint64_t v8;
  uint64_t CMBaseObject;
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v11;

  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v8 = AccessManagedFileHelper(DerivedStorage, 0, 0, *(_QWORD *)(DerivedStorage + 8));
  if ((_DWORD)v8)
    return v8;
  CMBaseObject = CMByteStreamGetCMBaseObject(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DerivedStorage + 8) + 80) + 8));
  v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                 + 8)
                                                                     + 48);
  if (v10)
    v11 = v10(CMBaseObject, a2, a3, a4);
  else
    v11 = 4294954514;
  FigAtomicDecrement32((unsigned int *)(*(_QWORD *)(DerivedStorage + 8) + 92));
  return v11;
}

uint64_t ManagedFileByteStreamSetProperty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t v6;
  uint64_t CMBaseObject;
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t);
  uint64_t v9;

  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v6 = AccessManagedFileHelper(DerivedStorage, 0, 0, *(_QWORD *)(DerivedStorage + 8));
  if ((_DWORD)v6)
    return v6;
  CMBaseObject = CMByteStreamGetCMBaseObject(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DerivedStorage + 8) + 80) + 8));
  v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8) + 56);
  if (v8)
    v9 = v8(CMBaseObject, a2, a3);
  else
    v9 = 4294954514;
  FigAtomicDecrement32((unsigned int *)(*(_QWORD *)(DerivedStorage + 8) + 92));
  return v9;
}

void CloseManagedFile(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  const void *v4;

  v2 = *(_QWORD **)(a2 + 80);
  if (v2)
  {
    *(_QWORD *)(a2 + 80) = 0;
    v4 = (const void *)v2[1];
    if (v4)
    {
      CFRelease(v4);
      v2[1] = 0;
    }
    *v2 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 56) = v2;
  }
}

void DisposeManagedFile(_QWORD *a1)
{
  const void *v2;

  if (a1)
  {
    v2 = (const void *)a1[3];
    if (v2)
      CFRelease(v2);
    free(a1);
  }
}

uint64_t AccessManagedFileHelper(uint64_t a1, unsigned int *a2, _BYTE *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  id *v12;
  uint64_t (*v13)(id *, unsigned int **);
  int *v14;
  id *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  id *v21;
  uint64_t v22;
  CFTypeRef cf;
  unsigned int *v24;

  v8 = *(_QWORD *)a1;
  FigReentrantMutexLock(*(pthread_mutex_t **)(*(_QWORD *)a1 + 24));
  FigAtomicIncrement32((unsigned int *)(a4 + 92));
  *(_QWORD *)(a4 + 96) = FigGetUpTimeNanoseconds();
  if (*(_QWORD *)(a4 + 80))
    goto LABEL_2;
  v11 = *(_QWORD *)(v8 + 56);
  if (v11)
  {
LABEL_5:
    *(_QWORD *)(v8 + 56) = *(_QWORD *)v11;
    *(_QWORD *)v11 = 0;
  }
  else
  {
    v16 = 0x7FFFFFFFFFFFFFFFLL;
    while (1)
    {
      v17 = *(_QWORD *)(v8 + 32);
      if (!v17)
      {
        FigUSleep(0x64u);
LABEL_38:
        v9 = FigSignalErrorAt(4294954856, 0, 0, 0, 0, 0, 0);
        FigReentrantMutexUnlock(*(pthread_mutex_t **)(v8 + 24));
        if (!(_DWORD)v9)
          return v9;
        goto LABEL_39;
      }
      v18 = 0;
      v19 = 0;
      do
      {
        if (*(_DWORD *)(v17 + 92))
        {
          ++v18;
        }
        else if (*(_QWORD *)(v17 + 80) && *(_QWORD *)(v17 + 96) < v16)
        {
          v16 = *(_QWORD *)(v17 + 96);
          v19 = v17;
        }
        v17 = *(_QWORD *)(v17 + 8);
      }
      while (v17);
      if (v19)
        break;
      FigUSleep(0x64u);
      if (v18 <= 1)
        goto LABEL_38;
    }
    CloseManagedFile(v8, v19);
    v11 = *(_QWORD *)(v8 + 56);
    if (v11)
      goto LABEL_5;
  }
  if (*(_BYTE *)(a1 + 16))
  {
    v13 = *(uint64_t (**)(id *, unsigned int **))(a1 + 24);
    v12 = *(id **)(a1 + 32);
    cf = 0;
    v24 = 0;
    if (a2)
    {
      v9 = FigByteStreamCreateFromReadOnlyOpenFileAssumingOwnership(a2, *MEMORY[0x1E0C9AE00], &cf);
      v14 = 0;
      if (!(_DWORD)v9)
      {
        v15 = 0;
LABEL_28:
        v14 = 0;
        v9 = 0;
        *(_QWORD *)(v11 + 8) = cf;
        cf = 0;
        *(_QWORD *)(a4 + 80) = v11;
        goto LABEL_29;
      }
      v15 = 0;
    }
    else if (v13)
    {
      v21 = FigCFWeakReferenceHolderCopyReferencedObject(v12);
      v15 = v21;
      if (v21)
      {
        v9 = v13(v21, &v24);
        v14 = (int *)v24;
        if ((_DWORD)v9)
          goto LABEL_29;
        v22 = FigByteStreamCreateFromReadOnlyOpenFileAssumingOwnership(v24, *MEMORY[0x1E0C9AE00], &cf);
        v24 = 0;
        if (!(_DWORD)v22)
          goto LABEL_28;
      }
      else
      {
        v22 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      }
      v9 = v22;
      v14 = 0;
    }
    else
    {
      v9 = FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
      v14 = 0;
      v15 = 0;
    }
LABEL_29:
    FigFileForkClose(v14);
    if (cf)
      CFRelease(cf);
    if (v15)
      CFRelease(v15);
    if (a3)
      *a3 = 1;
    if (!(_DWORD)v9)
      goto LABEL_2;
    goto LABEL_36;
  }
  v20 = CMByteStreamCreateForFileURL(*MEMORY[0x1E0C9AE00], *(const void **)(a4 + 24), *(_DWORD *)(a4 + 16), (CFTypeRef *)(v11 + 8));
  if (!(_DWORD)v20)
  {
    *(_QWORD *)(a4 + 80) = v11;
LABEL_2:
    FigReentrantMutexUnlock(*(pthread_mutex_t **)(v8 + 24));
    return 0;
  }
  v9 = v20;
LABEL_36:
  *(_QWORD *)v11 = *(_QWORD *)(v8 + 56);
  *(_QWORD *)(v8 + 56) = v11;
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(v8 + 24));
LABEL_39:
  FigAtomicDecrement32((unsigned int *)(a4 + 92));
  return v9;
}

uint64_t ManagedFileByteStreamRead(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v13;

  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v10 = AccessManagedFileHelper(DerivedStorage, 0, 0, *(_QWORD *)(DerivedStorage + 8));
  if ((_DWORD)v10)
    return v10;
  v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DerivedStorage + 8) + 80) + 8);
  v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v11)
                                                                                          + 16)
                                                                              + 8);
  if (v12)
    v13 = v12(v11, a2, a3, a4, a5);
  else
    v13 = 4294954514;
  FigAtomicDecrement32((unsigned int *)(*(_QWORD *)(DerivedStorage + 8) + 92));
  return v13;
}

uint64_t ManagedFileByteStreamGetAvailableLengthAtOffset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DerivedStorage;
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t);
  uint64_t v9;

  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v6 = AccessManagedFileHelper(DerivedStorage, 0, 0, *(_QWORD *)(DerivedStorage + 8));
  if ((_DWORD)v6)
    return v6;
  v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DerivedStorage + 8) + 80) + 8);
  v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v7) + 16) + 24);
  if (v8)
    v9 = v8(v7, a2, a3);
  else
    v9 = 4294954514;
  FigAtomicDecrement32((unsigned int *)(*(_QWORD *)(DerivedStorage + 8) + 92));
  return v9;
}

uint64_t ManagedFileByteStreamReadAndCreateBlockBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DerivedStorage;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v13;

  if (!a1)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v10 = AccessManagedFileHelper(DerivedStorage, 0, 0, *(_QWORD *)(DerivedStorage + 8));
  if ((_DWORD)v10)
    return v10;
  v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(DerivedStorage + 8) + 80) + 8);
  v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v11)
                                                                                          + 16)
                                                                              + 32);
  if (v12)
    v13 = v12(v11, a2, a3, a4, a5);
  else
    v13 = 4294954514;
  FigAtomicDecrement32((unsigned int *)(*(_QWORD *)(DerivedStorage + 8) + 92));
  return v13;
}

uint64_t FigByteStreamCreateWithCFData(const void *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  return _createWithCFData(a1, 0, a2, a3, a4);
}

uint64_t _createWithCFData(const void *a1, int a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  _QWORD *ClassID;
  uint64_t v10;
  _QWORD *DerivedStorage;
  CFTypeRef cf;

  cf = 0;
  if (a3 || !a1)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  ClassID = (_QWORD *)CMByteStreamGetClassID();
  v10 = CMDerivedObjectCreate(a4, (uint64_t)&kFigDataByteStreamVTable, ClassID, &cf);
  if ((_DWORD)v10)
  {
    if (cf)
      CFRelease(cf);
  }
  else
  {
    DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
    *DerivedStorage = CFRetain(a1);
    if (a2)
      DerivedStorage[1] = CFRetain(a1);
    v10 = 0;
    *a5 = cf;
  }
  return v10;
}

uint64_t FigByteStreamCreateWritableWithCFMutableData(const void *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  return _createWithCFData(a1, 1, a2, a3, a4);
}

BOOL FigDataByteStreamEqual(uint64_t a1, uint64_t a2)
{
  _QWORD *DerivedStorage;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  return *DerivedStorage == *(_QWORD *)CMBaseObjectGetDerivedStorage(a2);
}

void FigDataByteStreamFinalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_QWORD *)DerivedStorage)
    CFRelease(*(CFTypeRef *)DerivedStorage);
  v2 = *(const void **)(DerivedStorage + 8);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(DerivedStorage + 16);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(DerivedStorage + 24);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(DerivedStorage + 32);
  if (v5)
    CFRelease(v5);
}

uint64_t FigDataByteStreamCopyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t DerivedStorage;
  const __CFAllocator *v7;
  CFIndex Length;
  void *SInt64;
  void *v10;
  uint64_t result;
  const void *v12;
  const void **v13;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (CFEqual(a2, CFSTR("FBS_EntireLength")) || CFEqual(a2, CFSTR("FBS_AvailableLength")))
  {
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Length = CFDataGetLength(*(CFDataRef *)DerivedStorage);
    SInt64 = FigCFNumberCreateSInt64(v7, Length);
LABEL_4:
    v10 = SInt64;
LABEL_5:
    result = 0;
    *a4 = v10;
    return result;
  }
  if (CFEqual(a2, CFSTR("FBS_EntireLengthAvailableOnDemand")))
  {
    v12 = (const void *)*MEMORY[0x1E0C9AE50];
LABEL_8:
    SInt64 = (void *)CFRetain(v12);
    goto LABEL_4;
  }
  if (CFEqual(a2, CFSTR("FBS_URL")))
  {
    v12 = *(const void **)(DerivedStorage + 16);
    if (v12)
      goto LABEL_8;
    return 4294954512;
  }
  if (CFEqual(a2, CFSTR("FBS_FileType")))
  {
    v12 = *(const void **)(DerivedStorage + 32);
    if (v12)
      goto LABEL_8;
    return 4294954512;
  }
  if (CFEqual(a2, CFSTR("FBS_MIMEType")))
  {
    v12 = *(const void **)(DerivedStorage + 24);
    if (v12)
      goto LABEL_8;
    return 4294954512;
  }
  if (CFEqual(a2, CFSTR("FBS_ReadSupported")))
  {
    v13 = (const void **)MEMORY[0x1E0C9AE50];
    goto LABEL_23;
  }
  if (CFEqual(a2, CFSTR("FBS_WriteSupported")))
  {
    v13 = (const void **)MEMORY[0x1E0C9AE50];
    if (!*(_QWORD *)(DerivedStorage + 8))
      v13 = (const void **)MEMORY[0x1E0C9AE40];
LABEL_23:
    v12 = *v13;
    if (!*v13)
    {
      v10 = 0;
      goto LABEL_5;
    }
    goto LABEL_8;
  }
  return FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
}

uint64_t FigDataByteStreamSetProperty(const void *a1, const void *a2, const __CFString *a3)
{
  _QWORD *DerivedStorage;
  CFTypeID v7;
  const void *v8;
  CFTypeID v9;
  CFTypeID v10;
  const void *v11;
  const __CFAllocator *v12;
  uint64_t v14;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  if (CFEqual(a2, CFSTR("FBS_URL")))
  {
    if (a3)
    {
      v7 = CFGetTypeID(a3);
      if (v7 == CFURLGetTypeID())
      {
        v8 = (const void *)DerivedStorage[2];
        DerivedStorage[2] = a3;
        goto LABEL_9;
      }
      goto LABEL_25;
    }
    v8 = (const void *)DerivedStorage[2];
    DerivedStorage[2] = 0;
    if (!v8)
      return 0;
LABEL_21:
    CFRelease(v8);
    return 0;
  }
  if (CFEqual(a2, CFSTR("FBS_FileType")))
  {
    if (a3)
    {
      v9 = CFGetTypeID(a3);
      if (v9 == CFNumberGetTypeID())
      {
        v8 = (const void *)DerivedStorage[4];
        DerivedStorage[4] = a3;
LABEL_9:
        CFRetain(a3);
        if (!v8)
          return 0;
        goto LABEL_21;
      }
      goto LABEL_25;
    }
    v8 = (const void *)DerivedStorage[4];
    DerivedStorage[4] = 0;
    if (!v8)
      return 0;
    goto LABEL_21;
  }
  if (CFEqual(a2, CFSTR("FBS_MIMEType")))
  {
    if (!a3 || (v10 = CFGetTypeID(a3), v10 == CFStringGetTypeID()))
    {
      v11 = (const void *)DerivedStorage[3];
      if (v11)
      {
        CFRelease(v11);
        DerivedStorage[3] = 0;
      }
      if (a3)
      {
        v12 = CFGetAllocator(a1);
        DerivedStorage[3] = CFStringCreateCopy(v12, a3);
      }
      return 0;
    }
LABEL_25:
    v14 = 4294954424;
    return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
  }
  v14 = 4294954512;
  return FigSignalErrorAt(v14, 0, 0, 0, 0, 0, 0);
}

uint64_t FigDataByteStreamRead(uint64_t a1, int64_t a2, CFIndex a3, void *a4, int64_t *a5)
{
  uint64_t CMBaseObject;
  CFDataRef *DerivedStorage;
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t result;

  CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  DerivedStorage = (CFDataRef *)CMBaseObjectGetDerivedStorage(CMBaseObject);
  Length = CFDataGetLength(*DerivedStorage);
  if (a2)
  {
    if (a3 < 0)
    {
      result = FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
      a2 = 0;
      if (!a5)
        return result;
      goto LABEL_10;
    }
    if (Length <= a3)
      return 4294954423;
    if ((a2 & (unint64_t)~(a2 >> 63)) >= Length - a3)
      a2 = Length - a3;
    else
      a2 &= ~(a2 >> 63);
    if (a2)
    {
      BytePtr = CFDataGetBytePtr(*DerivedStorage);
      memcpy(a4, &BytePtr[a3], a2);
    }
  }
  result = 0;
  if (!a5)
    return result;
LABEL_10:
  if (!(_DWORD)result)
    *a5 = a2;
  return result;
}

uint64_t FigDataByteStreamWrite(uint64_t a1, size_t a2, CFIndex a3, const UInt8 *a4, size_t *a5)
{
  uint64_t CMBaseObject;
  uint64_t DerivedStorage;
  const __CFData *v11;
  CFIndex Length;
  unint64_t v13;
  __CFData *v14;
  const UInt8 *BytePtr;
  uint64_t result;
  uint64_t v17;
  CFRange v18;

  CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(CMBaseObject);
  v11 = *(const __CFData **)(DerivedStorage + 8);
  if (!v11)
  {
    v17 = 4294954419;
LABEL_16:
    result = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
    if (!a5)
      return result;
    goto LABEL_11;
  }
  if (!a4 || a3 < 0)
  {
    v17 = 4294954424;
    goto LABEL_16;
  }
  if (a2)
  {
    Length = CFDataGetLength(v11);
    if (Length == a3)
    {
      CFDataAppendBytes(*(CFMutableDataRef *)(DerivedStorage + 8), a4, a2);
    }
    else
    {
      v13 = Length;
      v14 = *(__CFData **)(DerivedStorage + 8);
      if (a3 + a2 <= v13)
      {
        v18.location = a3;
        v18.length = a2;
        CFDataReplaceBytes(v14, v18, a4, a2);
      }
      else
      {
        CFDataSetLength(v14, a3 + a2);
        BytePtr = CFDataGetBytePtr(*(CFDataRef *)(DerivedStorage + 8));
        memcpy((void *)&BytePtr[a3], a4, a2);
      }
    }
  }
  result = 0;
  if (a5)
  {
LABEL_11:
    if (!(_DWORD)result)
      *a5 = a2;
  }
  return result;
}

uint64_t FigDataByteStreamGetAvailableLengthAtOffset(uint64_t a1, uint64_t a2, CFIndex *a3)
{
  uint64_t CMBaseObject;
  CFDataRef *DerivedStorage;
  CFIndex Length;

  CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  DerivedStorage = (CFDataRef *)CMBaseObjectGetDerivedStorage(CMBaseObject);
  if (!a3)
    return FigSignalErrorAt(4294954424, 0, 0, 0, 0, 0, 0);
  Length = CFDataGetLength(*DerivedStorage);
  *a3 = (Length - a2) & ~((Length - a2) >> 63);
  return 0;
}

uint64_t FigDataByteStreamReadAndCreateBlockBuffer(const void *a1, size_t a2, unint64_t a3, CFTypeRef *a4, _QWORD *a5)
{
  uint64_t CMBaseObject;
  uint64_t DerivedStorage;
  uint64_t v12;
  const __CFAllocator *v13;
  uint64_t BlockBufferWithCFDataNoCopy;
  uint64_t v15;
  size_t DataLength;
  CFTypeRef cf;

  CMBaseObject = CMByteStreamGetCMBaseObject(a1);
  DerivedStorage = CMBaseObjectGetDerivedStorage(CMBaseObject);
  DataLength = 0;
  cf = 0;
  v12 = *(_QWORD *)(DerivedStorage + 8);
  v13 = CFGetAllocator(a1);
  if (v12)
  {
    BlockBufferWithCFDataNoCopy = CMCreateContiguousBlockBufferFromStream((uint64_t)a1, v13, a2, a3, (CMBlockBufferRef *)&cf, &DataLength);
    if (!(_DWORD)BlockBufferWithCFDataNoCopy)
    {
      if (!a4)
        goto LABEL_5;
      goto LABEL_4;
    }
LABEL_13:
    v15 = BlockBufferWithCFDataNoCopy;
    goto LABEL_7;
  }
  BlockBufferWithCFDataNoCopy = FigCreateBlockBufferWithCFDataNoCopy(v13, *(CFDataRef *)DerivedStorage, a3, a2, (CMBlockBufferRef *)&cf);
  if ((_DWORD)BlockBufferWithCFDataNoCopy)
    goto LABEL_13;
  DataLength = CMBlockBufferGetDataLength((CMBlockBufferRef)cf);
  if (a4)
  {
LABEL_4:
    *a4 = cf;
    cf = 0;
  }
LABEL_5:
  v15 = 0;
  if (a5)
    *a5 = DataLength;
LABEL_7:
  if (cf)
    CFRelease(cf);
  return v15;
}

uint64_t FigCPECryptorGetClassID()
{
  FigThreadRunOnce(&FigCPECryptorGetClassID_sRegisterFigCPECryptorTypeOnce, (void (*)(void))RegisterFigCPECryptorType);
  return sFigCPECryptorClassID;
}

uint64_t RegisterFigCPECryptorType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigCPECryptorClassDesc, ClassID, 1, &sFigCPECryptorClassID);
}

uint64_t FigCPECryptorGetTypeID()
{
  FigThreadRunOnce(&FigCPECryptorGetClassID_sRegisterFigCPECryptorTypeOnce, (void (*)(void))RegisterFigCPECryptorType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigCPECryptorClassID);
}

uint64_t FigCPECopyCryptorForSerializationToken(void *a1, _QWORD *a2)
{
  if (FigCPECryptorServerExistsInProcess())
    return FigCPECryptorServerCopyCryptorForID(a1, a2);
  else
    return FigCPECryptorRemoteRetainCopiedCryptor(*MEMORY[0x1E0C9AE00], a1, a2);
}

CFStringRef FigCPECryptorCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigCPECryptor %p]"), a1);
}

uint64_t FigTransportServiceGetClassID()
{
  if (FigTransportServiceGetClassID_sRegisterOnce != -1)
    dispatch_once_f(&FigTransportServiceGetClassID_sRegisterOnce, &FigTransportServiceGetClassID_sClassID, (dispatch_function_t)service_getClassID);
  return FigTransportServiceGetClassID_sClassID;
}

uint64_t service_getClassID(_QWORD *a1)
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&service_getClassID_sClassDesc, ClassID, 1, a1);
}

uint64_t FigTransportServiceGetTypeID()
{
  if (FigTransportServiceGetClassID_sRegisterOnce != -1)
    dispatch_once_f(&FigTransportServiceGetClassID_sRegisterOnce, &FigTransportServiceGetClassID_sClassID, (dispatch_function_t)service_getClassID);
  return CMBaseClassGetCFTypeID((_QWORD *)FigTransportServiceGetClassID_sClassID);
}

CFStringRef service_copyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigTransportService %p]"), a1);
}

uint64_t FigSandboxRegistrationGetTypeID()
{
  if (sRegisterFigSandboxRegistrationTypeOnce != -1)
    dispatch_once_f(&sRegisterFigSandboxRegistrationTypeOnce, 0, (dispatch_function_t)RegisterFigSandboxRegistrationType);
  return sFigSandboxRegistrationID;
}

uint64_t RegisterFigSandboxRegistrationType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigSandboxRegistrationID = result;
  return result;
}

uint64_t FigSandboxRegistrationCreate(const __CFData *a1, int a2, const void *a3, _QWORD *a4)
{
  uint64_t Instance;
  _QWORD *v9;
  CFTypeRef v10;
  uint64_t v11;
  uint64_t v12;

  if (sRegisterFigSandboxRegistrationTypeOnce != -1)
    dispatch_once_f(&sRegisterFigSandboxRegistrationTypeOnce, 0, (dispatch_function_t)RegisterFigSandboxRegistrationType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
  v9 = (_QWORD *)Instance;
  *(_DWORD *)(Instance + 24) = a2;
  CFDataGetBytePtr(a1);
  if (a3)
    v10 = CFRetain(a3);
  else
    v10 = 0;
  v9[2] = v10;
  v11 = sandbox_extension_consume();
  v9[4] = v11;
  if (v11 == -1)
  {
    FigSandboxRegistrationServerDumpMappings((uint64_t)v9);
    if (*__error() == 12)
    {
      v12 = FigSignalErrorAt(4294949793, 0, 0, 0, 0, 0, 0);
      FigSandboxRegistrationServerKillDueToError(-17503);
    }
    else
    {
      v12 = FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v9);
  }
  else
  {
    if (figSandboxRegistrationRecordForDiagnosticLogging_onceToken != -1)
      dispatch_once(&figSandboxRegistrationRecordForDiagnosticLogging_onceToken, &__block_literal_global_34);
    FigSimpleMutexLock((pthread_mutex_t *)figSandboxRegistrationRecordForDiagnosticLogging_mutex);
    FigCFWeakReferenceTableAddValueAssociatedWithKey(figSandboxRegistrationRecordForDiagnosticLogging_sandboxRegistrations, (uint64_t)v9, (uint64_t)v9);
    FigSimpleMutexUnlock((pthread_mutex_t *)figSandboxRegistrationRecordForDiagnosticLogging_mutex);
    v12 = 0;
    *a4 = v9;
  }
  return v12;
}

uint64_t FigSandboxRegistrationCreateWithURLOnSelfGrantingReadWriteAccess(const __CFURL *a1, int a2, _QWORD *a3)
{
  uint64_t Instance;
  _QWORD *v7;
  const __CFString *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  char buffer[1024];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (sRegisterFigSandboxRegistrationTypeOnce != -1)
    dispatch_once_f(&sRegisterFigSandboxRegistrationTypeOnce, 0, (dispatch_function_t)RegisterFigSandboxRegistrationType);
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    v7 = (_QWORD *)Instance;
    *(_DWORD *)(Instance + 24) = a2;
    v8 = CFURLCopyFileSystemPath(a1, kCFURLPOSIXPathStyle);
    CFStringGetCString(v8, buffer, 1024, 0x8000100u);
    if (buffer[0])
    {
      v9 = sandbox_extension_issue_file_to_self();
      if (v9)
      {
        v10 = (void *)v9;
        v11 = sandbox_extension_consume();
        v7[4] = v11;
        if (v11 != -1)
        {
          *a3 = v7;
          free(v10);
          v12 = 0;
          if (!v8)
            return v12;
LABEL_8:
          CFRelease(v8);
          return v12;
        }
        v12 = FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
        free(v10);
      }
      else
      {
        FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
        v12 = 0;
      }
    }
    else
    {
      v12 = FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v7);
    if (!v8)
      return v12;
    goto LABEL_8;
  }
  return FigSignalErrorAt(4294949795, 0, 0, 0, 0, 0, 0);
}

_QWORD *figSandboxRegistrationInit(_QWORD *result)
{
  result[2] = 0;
  result[3] = 0;
  result[4] = -1;
  return result;
}

void figSandboxRegistrationFinalize(uint64_t a1)
{
  const void *v2;

  if (*(_QWORD *)(a1 + 32) != -1)
    sandbox_extension_release();
  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

__CFString *figSandboxRegistrationCopyFormattingDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  uint64_t v4;
  uint64_t v5;
  const __CFString *v6;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(unsigned int *)(a1 + 24);
  if (FigIsItOKToLogURLs())
    v6 = *(const __CFString **)(a1 + 16);
  else
    v6 = CFSTR("<REDACTED>");
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigSandboxRegistration %p> hold <extensionHandle %lld> for client PID %d - %@"), a1, v4, v5, v6);
  return Mutable;
}

__CFString *figSandboxRegistrationCopyDebugDesc(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  uint64_t v4;
  const __CFString *v5;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = *(unsigned int *)(a1 + 24);
  if (FigIsItOKToLogURLs())
    v5 = *(const __CFString **)(a1 + 16);
  else
    v5 = CFSTR("<REDACTED>");
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigSandboxRegistration %p> for client PID %d - %@"), a1, v4, v5);
  return Mutable;
}

void __figSandboxRegistrationRecordForDiagnosticLogging_block_invoke()
{
  figSandboxRegistrationRecordForDiagnosticLogging_mutex = (uint64_t)FigSimpleMutexCreate();
  FigCFWeakReferenceTableCreate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], 1, &figSandboxRegistrationRecordForDiagnosticLogging_sandboxRegistrations);
  FigInstallSysdiagnoseBlock((uint64_t)CFSTR("Sandbox Registrations"), (uint64_t)&__block_literal_global_10);
}

uint64_t __figSandboxRegistrationRecordForDiagnosticLogging_block_invoke_2()
{
  int *v0;
  uint64_t v1;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v3;
  const __CFArray *v4;
  const __CFArray *v5;
  CFIndex v6;
  const void *ValueAtIndex;
  const __CFArray *Value;
  const __CFArray *v9;
  CFIndex Count;
  const __CFNumber *SInt32;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v13;
  uint64_t v14;
  unsigned int v15;
  const char *v16;
  char *v17;
  CFIndex i;
  const __CFArray *v19;
  os_log_type_t type;
  int v22;
  CFTypeRef cf;
  int v24;
  const char *v25;
  __int16 v26;
  const void *v27;
  __int16 v28;
  CFTypeRef v29;
  __int16 v30;
  CFIndex v31;
  __int16 v32;
  const char *v33;
  char v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v0 = &ensureGlobalDeserializeRegister_err;
  FigSimpleMutexLock((pthread_mutex_t *)figSandboxRegistrationRecordForDiagnosticLogging_mutex);
  v1 = figSandboxRegistrationRecordForDiagnosticLogging_sandboxRegistrations;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v3 = Mutable;
    FigCFWeakReferenceTableApplyFunction(v1, (void (*)(_QWORD, CFTypeRef, uint64_t))figSandboxRegistrationDumpAllApply, (uint64_t)Mutable);
    v4 = FigCFDictionaryCopyArrayOfKeys(v3);
    if (v4)
    {
      v5 = v4;
      if (CFArrayGetCount(v4) <= 0)
      {
        CFRelease(v3);
      }
      else
      {
        v6 = 0;
        do
        {
          ValueAtIndex = FigCFArrayGetValueAtIndex(v5, v6);
          Value = (const __CFArray *)CFDictionaryGetValue(v3, ValueAtIndex);
          v9 = Value;
          if (Value)
            Count = CFArrayGetCount(Value);
          else
            Count = 0;
          cf = 0;
          SInt32 = FigCFNumberGetSInt32((const __CFNumber *)ValueAtIndex);
          FigServer_CopyProcessName((uint64_t)SInt32, (CFStringRef *)&cf);
          v22 = 0;
          type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type(0, 1, &v22, &type);
          v13 = v22;
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
            v15 = v13;
          else
            v15 = v13 & 0xFFFFFFFE;
          if (v15)
          {
            v16 = "s";
            if (Count == 1)
              v16 = "";
            v24 = 136316162;
            v25 = "figSandboxRegistrationDumpAll";
            v26 = 2114;
            v27 = ValueAtIndex;
            v28 = 2114;
            v29 = cf;
            v30 = 2048;
            v31 = Count;
            v32 = 2082;
            v33 = v16;
            v17 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v13) = v22;
          }
          else
          {
            v17 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose(0, 1u, 1, v17, v17 != &v34, v13, 0, v14);
          if (FigIsItOKToLogURLs() && Count >= 1)
          {
            for (i = 0; i != Count; ++i)
              CFArrayGetValueAtIndex(v9, i);
          }
          if (cf)
            CFRelease(cf);
          ++v6;
        }
        while (v6 < CFArrayGetCount(v5));
        CFRelease(v3);
        v0 = &ensureGlobalDeserializeRegister_err;
      }
      v19 = v5;
    }
    else
    {
      FigSignalErrorAt(4294949790, 0, 0, 0, 0, 0, 0);
      v19 = v3;
    }
    CFRelease(v19);
  }
  else
  {
    FigSignalErrorAt(4294949790, 0, 0, 0, 0, 0, 0);
  }
  return FigSimpleMutexUnlock(*((pthread_mutex_t **)v0 + 237));
}

void figSandboxRegistrationDumpAllApply(uint64_t a1, int *a2, const __CFDictionary *a3)
{
  const __CFAllocator *v5;
  CFNumberRef SInt32;
  CFNumberRef v7;
  void *Value;
  CFMutableArrayRef Mutable;

  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  SInt32 = FigCFNumberCreateSInt32((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2[6]);
  if (SInt32)
  {
    v7 = SInt32;
    Value = (void *)FigCFDictionaryGetValue(a3, SInt32);
    if (!Value)
    {
      Mutable = CFArrayCreateMutable(v5, 0, MEMORY[0x1E0C9B378]);
      if (!Mutable)
      {
        FigSignalErrorAt(4294949790, 0, 0, 0, 0, 0, 0);
        goto LABEL_6;
      }
      Value = Mutable;
      FigCFDictionarySetValue(a3, v7, Mutable);
      CFRelease(Value);
    }
    CFArrayAppendValue((CFMutableArrayRef)Value, a2);
LABEL_6:
    CFRelease(v7);
    return;
  }
  FigSignalErrorAt(4294949790, 0, 0, 0, 0, 0, 0);
}

uint64_t FigEndpointManagerStartServer(const void *a1)
{
  CFMutableDictionaryRef Mutable;
  uint64_t started;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  FigCFDictionarySetValue(Mutable, CFSTR("AirPlay"), a1);
  started = FigEndpointManagerStartServerEx(Mutable);
  if (Mutable)
    CFRelease(Mutable);
  return started;
}

uint64_t FigEndpointManagerStartServerEx(const __CFDictionary *a1)
{
  const __CFAllocator *v2;
  const __CFArray *v3;
  const CFDictionaryKeyCallBacks *v4;
  const CFDictionaryValueCallBacks *v5;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v7;
  uint64_t v8;
  _QWORD v10[5];
  _OWORD v11[3];

  v11[0] = xmmword_1E28DF518;
  memset(&v11[1], 0, 32);
  if (!a1 || !CFDictionaryGetCount(a1))
    return 4294950586;
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  gEndpointManagers = (uint64_t)CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1);
  v3 = FigCFDictionaryCopyArrayOfKeys((const void *)gEndpointManagers);
  v4 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v5 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = __FigEndpointManagerStartServerEx_block_invoke;
  v10[3] = &__block_descriptor_tmp_43;
  v10[4] = Mutable;
  FigCFArrayApplyBlock(v3, v10);
  gEndpointManagerData = (uint64_t)Mutable;
  v7 = CFDictionaryCreateMutable(v2, 0, v4, v5);
  FigCFDictionarySetInt32(v7, CFSTR("xpcServerOption_SelfTerminationTimeout"), 30);
  v8 = FigXPCServerStart((uint64_t)"com.apple.coremedia.endpointmanager.xpc", (uint64_t)v11, (uint64_t)v7, &gEndpointManagerServer);
  if (v7)
    CFRelease(v7);
  if (v3)
    CFRelease(v3);
  return v8;
}

uint64_t HandleEndpointManagerRemoteMessage(_xpc_connection_s *a1, void *a2, void *a3)
{
  uint64_t OpCode;
  uint64_t EndpointManager;
  CFTypeRef v8;
  uint64_t uint64;
  uint64_t v10;
  CFTypeID v11;
  CFTypeRef v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t CMBaseObject;
  uint64_t (*v16)(uint64_t, const __CFString *, _QWORD, CFTypeRef *);
  uint64_t v17;
  uint64_t v18;
  CFTypeRef v19;
  xpc_object_t v20;
  uint64_t (*v21)(CFTypeRef, CFTypeRef, xpc_object_t);
  uint64_t v22;
  CFTypeRef v23;
  uint64_t (*v24)(CFTypeRef, CFTypeRef, _QWORD, xpc_object_t *);
  uint64_t v25;
  xpc_object_t v26;
  xpc_object_t v27;
  uint64_t v28;
  uint64_t (*v29)(CFTypeRef, uint64_t, CFTypeRef *);
  uint64_t v30;
  uint64_t (*v31)(CFTypeRef, CFTypeRef *);
  CFTypeRef v32;
  CFTypeRef v33;
  uint64_t *v35;
  int v36;
  xpc_object_t v37;
  xpc_object_t value;
  CFTypeRef cf;

  v36 = 0;
  v35 = 0;
  OpCode = FigXPCMessageGetOpCode(a2, &v36);
  if ((_DWORD)OpCode)
    return OpCode;
  if (v36 == 1734701165)
  {
    cf = 0;
    OpCode = FigXPCMessageCopyCFString(a2, "EndpointManagerType", &cf);
    if ((_DWORD)OpCode)
      return OpCode;
    EndpointManager = HandleGetEndpointManager(a1, cf, a3);
    v8 = cf;
    if (!cf)
      return EndpointManager;
LABEL_62:
    CFRelease(v8);
    return EndpointManager;
  }
  if (v36 == 1734436205)
    return HandleGetEndpointManager(a1, CFSTR("AirPlay"), a3);
  uint64 = xpc_dictionary_get_uint64(a2, ".objectID");
  cf = 0;
  v10 = FigXPCServerLookupAndRetainAssociatedObject(a1, uint64, &cf, &v35);
  if (!(_DWORD)v10)
  {
    if (cf)
    {
      v11 = CFGetTypeID(cf);
      if (v11 == FigEndpointManagerGetTypeID())
      {
        v12 = cf;
        goto LABEL_13;
      }
    }
    v10 = FigSignalErrorAt(4294950586, 0, 0, 0, 0, 0, 0);
  }
  EndpointManager = v10;
  if (cf)
    CFRelease(cf);
  if (!(_DWORD)EndpointManager)
  {
    v12 = 0;
LABEL_13:
    EndpointManager = 4294950586;
    if (v36 > 1668441440)
    {
      if (v36 <= 1701995363)
      {
        if (v36 != 1668441441)
        {
          if (v36 == 1685024621)
          {
            v13 = FigXPCServerDisassociateObjectWithConnection(a1, uint64);
LABEL_50:
            EndpointManager = v13;
            goto LABEL_60;
          }
          goto LABEL_60;
        }
        cf = 0;
        v28 = xpc_dictionary_get_uint64(a2, "EndpointAggregateType");
        v29 = *(uint64_t (**)(CFTypeRef, uint64_t, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v12)
                                                                                     + 16)
                                                                         + 24);
        if (v29)
        {
          v30 = v29(v12, v28, &cf);
LABEL_46:
          v32 = cf;
          if ((_DWORD)v30)
          {
            EndpointManager = v30;
            if (!cf)
              goto LABEL_60;
          }
          else
          {
            EndpointManager = FigEndpointXPCServerWriteNeighborEndpointToReply(a1, (void *)cf, a3, 0);
            v32 = cf;
            if (!cf)
              goto LABEL_60;
          }
          v33 = v32;
LABEL_59:
          CFRelease(v33);
          goto LABEL_60;
        }
        goto LABEL_51;
      }
      if (v36 == 1701995364)
      {
        cf = 0;
        v31 = *(uint64_t (**)(CFTypeRef, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v12) + 16)
                                                               + 32);
        if (v31)
        {
          v30 = v31(v12, &cf);
          goto LABEL_46;
        }
LABEL_51:
        EndpointManager = 4294954514;
        goto LABEL_60;
      }
      if (v36 != 1935961376)
        goto LABEL_60;
      value = 0;
      cf = 0;
      v18 = FigXPCMessageCopyCFString(a2, "DiscoveryMode", &cf);
      if (!(_DWORD)v18)
      {
        v18 = FigXPCMessageCopyCFDictionary(a2, "DiscoveryOptions", &value);
        if (!(_DWORD)v18)
        {
          v20 = value;
          v19 = cf;
          v21 = *(uint64_t (**)(CFTypeRef, CFTypeRef, xpc_object_t))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v12)
                                                                                         + 16)
                                                                             + 8);
          if (!v21)
          {
            EndpointManager = 4294954514;
LABEL_56:
            v27 = value;
            if (!value)
              goto LABEL_58;
            goto LABEL_57;
          }
          v18 = v21(v12, v19, v20);
        }
      }
      EndpointManager = v18;
      goto LABEL_56;
    }
    if (v36 != 778268793)
    {
      if (v36 == 779314548)
      {
        v13 = FigXPCHandleStdSetPropertyMessage((uint64_t)v12, a2);
        goto LABEL_50;
      }
      if (v36 != 1635148140)
      {
LABEL_60:
        if (!v12)
          return EndpointManager;
        v8 = v12;
        goto LABEL_62;
      }
      v14 = *v35;
      value = 0;
      cf = 0;
      v37 = 0;
      CMBaseObject = FigEndpointManagerGetCMBaseObject(v12);
      v16 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, CFTypeRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject) + 8)
                                                                                       + 48);
      if (v16)
      {
        v17 = v16(CMBaseObject, CFSTR("AvailableEndpoints"), *MEMORY[0x1E0C9AE00], &cf);
        if ((_DWORD)v17
          || (v17 = FigEndpointRPCCacheComputeCacheDeltas(v14, a1, (CFArrayRef)cf, &value, &v37), (_DWORD)v17))
        {
          EndpointManager = v17;
        }
        else
        {
          if (value)
            xpc_dictionary_set_value(a3, "AddedEndpoints", value);
          if (v37)
            xpc_dictionary_set_value(a3, "SubtractedEndpoints", v37);
          EndpointManager = 0;
        }
      }
      else
      {
        EndpointManager = 4294954514;
      }
      FigXPCRelease(value);
      FigXPCRelease(v37);
      goto LABEL_58;
    }
    value = 0;
    cf = 0;
    v22 = FigXPCMessageCopyCFString(a2, ".PropertyName", &cf);
    if (!(_DWORD)v22)
    {
      v23 = cf;
      if (cf)
      {
        v24 = *(uint64_t (**)(CFTypeRef, CFTypeRef, _QWORD, xpc_object_t *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)v12)
                                                                                                 + 8)
                                                                                     + 48);
        if (!v24)
        {
          EndpointManager = 4294954514;
          goto LABEL_58;
        }
        v25 = v24(v12, v23, *MEMORY[0x1E0C9AE00], &value);
        v26 = value;
        if (!(_DWORD)v25)
        {
          EndpointManager = FigXPCMessageSetCFObject(a3, ".Value", value);
          v26 = value;
          if (!value)
            goto LABEL_58;
          goto LABEL_41;
        }
        EndpointManager = v25;
        if (value)
        {
LABEL_41:
          v27 = v26;
LABEL_57:
          CFRelease(v27);
        }
LABEL_58:
        v33 = cf;
        if (!cf)
          goto LABEL_60;
        goto LABEL_59;
      }
      v22 = FigSignalErrorAt(4294954512, 0, 0, 0, 0, 0, 0);
    }
    EndpointManager = v22;
    goto LABEL_58;
  }
  return EndpointManager;
}

uint64_t HandleGetEndpointManager(_xpc_connection_s *a1, const void *a2, void *a3)
{
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  _QWORD **v10;
  _QWORD **v11;
  uint64_t pid;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v17;
  CFTypeRef cf;
  uint64_t value;

  cf = 0;
  value = 0;
  if (!a2)
    return 4294950586;
  v6 = CFDictionaryGetValue((CFDictionaryRef)gEndpointManagers, a2);
  if (v6 && (v7 = v6, (v8 = CFDictionaryGetValue((CFDictionaryRef)gEndpointManagerData, a2)) != 0))
  {
    v9 = v8;
    v10 = (_QWORD **)malloc_type_calloc(1uLL, 0x18uLL, 0x102004093CA8EA1uLL);
    if (v10)
    {
      v11 = v10;
      pid = xpc_connection_get_pid(a1);
      v13 = pid;
      FigServer_CopyProcessName(pid, (CFStringRef *)&cf);
      v14 = FigEndpointRPCCacheCreate(v11, 1);
      if ((_DWORD)v14)
      {
        v15 = v14;
      }
      else
      {
        v11[2] = CFRetain(v9);
        *((_DWORD *)v11 + 2) = v13;
        v15 = FigXPCServerAssociateObjectWithConnection(a1, v7, (uint64_t)v11, (uint64_t)FigEndpointManagerXPCClientInfoDispose, 0, &value);
        if (!(_DWORD)v15)
        {
          xpc_dictionary_set_uint64(a3, ".objectID", value);
          goto LABEL_9;
        }
      }
      FigEndpointRPCCacheDispose(*v11);
      v17 = v11[2];
      if (v17)
        CFRelease(v17);
      free(v11);
      goto LABEL_9;
    }
    v15 = 4294950585;
  }
  else
  {
    v15 = 4294950583;
  }
LABEL_9:
  if (cf)
    CFRelease(cf);
  return v15;
}

void FigEndpointManagerXPCClientInfoDispose(_QWORD *a1)
{
  const void *v2;

  FigEndpointRPCCacheDispose((_QWORD *)*a1);
  v2 = (const void *)a1[2];
  if (v2)
    CFRelease(v2);
  free(a1);
}

uint64_t FigEndpointSubEndpointSupportProtocolGetProtocolID()
{
  FigThreadRunOnce(&FigEndpointSubEndpointSupportProtocolGetProtocolID_sRegisterFigEndpointSubEndpointSupportProtocolTypeOnce, (void (*)(void))RegisterFigEndpointSubEndpointSupportProtocolType);
  return sFigEndpointSubEndpointSupportProtocolID;
}

uint64_t RegisterFigEndpointSubEndpointSupportProtocolType()
{
  return FigBaseProtocolRegisterProtocol((__int128 *)&sFigEndpointSubEndpointSupportProtocolDesc, 0, &sFigEndpointSubEndpointSupportProtocolID);
}

uint64_t FigVP9Bridge_ParseVPCC(const __CFData *a1, _BYTE *a2)
{
  const UInt8 *BytePtr;
  uint64_t v6;

  if (!a1 || !a2)
  {
    v6 = 4294954584;
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  if (*a2)
  {
    v6 = 4294954579;
    return FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
  }
  if (CFDataGetLength(a1) > 11 && (BytePtr = CFDataGetBytePtr(a1), *BytePtr == 1))
  {
    a2[1] = BytePtr[4];
    a2[2] = BytePtr[5];
    a2[3] = BytePtr[6] >> 4;
    a2[4] = (BytePtr[6] >> 1) & 7;
    a2[5] = BytePtr[6] & 1;
    a2[6] = BytePtr[7];
    a2[7] = BytePtr[8];
    a2[8] = BytePtr[9];
  }
  else
  {
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t endpointCentricPlugin_CreateEndpointCentricPluginObjectInternal(const __CFAllocator *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  _QWORD *ClassID;
  uint64_t v13;
  _QWORD *DerivedStorage;
  dispatch_queue_t v15;
  dispatch_queue_t v16;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v18;
  uint64_t v19;
  CFTypeRef cf;

  cf = 0;
  ClassID = (_QWORD *)FigHALAudioPluginGetClassID();
  v13 = CMDerivedObjectCreate((uint64_t)a1, (uint64_t)&kFigHALAudioPluginVTable_0, ClassID, &cf);
  if ((_DWORD)v13)
    goto LABEL_10;
  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)cf);
  DerivedStorage[1] = a2;
  DerivedStorage[6] = a4;
  DerivedStorage[7] = a5;
  DerivedStorage[4] = a3;
  v15 = dispatch_queue_create("FigHALEndpointCentricPlugin.InternalQueue", 0);
  DerivedStorage[2] = v15;
  if (!v15
    || (v16 = dispatch_queue_create("FigHALEndpointCentricPlugin.HostQueue", 0), (DerivedStorage[3] = v16) == 0)
    || (Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]),
        (DerivedStorage[9] = Mutable) == 0)
    || (v18 = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]),
        (DerivedStorage[10] = v18) == 0))
  {
    v13 = FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
LABEL_10:
    v19 = v13;
    goto LABEL_11;
  }
  v19 = FigHALAudioObjectMapperAddPluginObjectMapping(a2, (uint64_t)cf);
  if (!(_DWORD)v19)
  {
    *a6 = cf;
    return v19;
  }
LABEL_11:
  if (cf)
    CFRelease(cf);
  return v19;
}

uint64_t FigHALAudioCreateEndpointCentricPluginObject(const __CFAllocator *a1, uint64_t *a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  return endpointCentricPlugin_CreateEndpointCentricPluginObjectInternal(a1, a2, a3, a4, 0, a5);
}

void endpointCentricPlugin_Finalize(uint64_t a1)
{
  _QWORD *DerivedStorage;
  const void *v2;
  const void *v3;
  const void *v4;
  NSObject *v5;
  NSObject *v6;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage(a1);
  v2 = (const void *)DerivedStorage[9];
  if (v2)
  {
    CFRelease(v2);
    DerivedStorage[9] = 0;
  }
  v3 = (const void *)DerivedStorage[10];
  if (v3)
  {
    CFRelease(v3);
    DerivedStorage[10] = 0;
  }
  v4 = (const void *)DerivedStorage[5];
  if (v4)
  {
    CFRelease(v4);
    DerivedStorage[5] = 0;
  }
  v5 = DerivedStorage[2];
  if (v5)
  {
    dispatch_release(v5);
    DerivedStorage[2] = 0;
  }
  v6 = DerivedStorage[3];
  if (v6)
  {
    dispatch_release(v6);
    DerivedStorage[3] = 0;
  }
}

CFStringRef endpointCentricPlugin_CopyDebugDescription(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *v3;
  CFStringRef v4;
  const void *v5;
  const void *v6;
  _QWORD block[8];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v3 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __endpointCentricPlugin_CopyDebugDescription_block_invoke;
  block[3] = &unk_1E28DF658;
  block[6] = a1;
  block[7] = DerivedStorage;
  block[4] = &v13;
  block[5] = &v9;
  dispatch_sync(v3, block);
  v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("FigHALEndpointCentricPlugin:\nEndponts/Streams:\n%@\nStreams/Devices:\n%@"), v14[3], v10[3]);
  v5 = (const void *)v14[3];
  if (v5)
    CFRelease(v5);
  v6 = (const void *)v10[3];
  if (v6)
    CFRelease(v6);
  _Block_object_dispose(&v9, 8);
  _Block_object_dispose(&v13, 8);
  return v4;
}

uint64_t endpointCentricPlugin_GetObjectID()
{
  return 1;
}

uint64_t endpointCentricPlugin_HasProperty(uint64_t a1, int *a2)
{
  int v2;
  uint64_t result;
  BOOL v4;
  int v5;

  v2 = *a2;
  result = 1;
  if (*a2 <= 1819107690)
  {
    v4 = v2 == 1668047219;
    v5 = 1684370979;
  }
  else
  {
    v4 = v2 == 1819107691 || v2 == 1870098020;
    v5 = 1969841252;
  }
  if (!v4 && v2 != v5)
    return 0;
  return result;
}

uint64_t endpointCentricPlugin_IsPropertySettable()
{
  return 0;
}

uint64_t endpointCentricPlugin_GetPropertyDataSize(uint64_t a1, int *a2)
{
  uint64_t DerivedStorage;
  uint64_t v4;
  int v5;
  NSObject *v6;
  _QWORD v8[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v4 = 0;
  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v5 = *a2;
  if (*a2 > 1819107690)
  {
    if (v5 == 1819107691)
    {
      v4 = 8;
      goto LABEL_11;
    }
    if (v5 != 1870098020)
    {
      if (v5 != 1969841252)
        goto LABEL_12;
      goto LABEL_9;
    }
LABEL_8:
    v6 = *(NSObject **)(DerivedStorage + 16);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = __endpointCentricPlugin_GetPropertyDataSize_block_invoke;
    v8[3] = &unk_1E28DF680;
    v8[4] = &v9;
    v8[5] = DerivedStorage;
    dispatch_sync(v6, v8);
    v4 = *((unsigned int *)v10 + 6);
    goto LABEL_12;
  }
  if (v5 == 1668047219)
  {
LABEL_9:
    v4 = 4;
LABEL_11:
    v12 = v4;
    goto LABEL_12;
  }
  if (v5 == 1684370979)
    goto LABEL_8;
LABEL_12:
  _Block_object_dispose(&v9, 8);
  return v4;
}

uint64_t endpointCentricPlugin_GetPropertyData(uint64_t a1, int *a2, int a3, uint64_t a4, unsigned int a5, _DWORD *a6, _DWORD *a7)
{
  uint64_t DerivedStorage;
  int v14;
  NSObject *v15;
  NSObject *v16;
  int v17;
  uint64_t v18;
  int v20;
  _QWORD block[9];
  unsigned int v22;
  _QWORD v23[8];
  unsigned int v24;
  _QWORD v25[4];
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;

  v26 = 0;
  v27 = &v26;
  v28 = 0x2000000000;
  v29 = 0;
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v14 = *a2;
  if (*a2 <= 1819107690)
  {
    if (v14 != 1668047219)
    {
      if (v14 != 1684370979)
        goto LABEL_16;
LABEL_11:
      v25[0] = 0;
      v25[1] = v25;
      v25[2] = 0x2000000000;
      v25[3] = 0;
      v16 = *(NSObject **)(DerivedStorage + 16);
      v23[0] = MEMORY[0x1E0C809B0];
      v23[1] = 0x40000000;
      v23[2] = __endpointCentricPlugin_GetPropertyData_block_invoke;
      v23[3] = &unk_1E28DF6A8;
      v23[4] = v25;
      v23[5] = DerivedStorage;
      v24 = a5;
      v23[6] = a7;
      v23[7] = a6;
      dispatch_sync(v16, v23);
      _Block_object_dispose(v25, 8);
      goto LABEL_19;
    }
    *a6 = 4;
    if (a5 >= 4)
    {
      v17 = 0;
      *a7 = 1634757735;
      goto LABEL_18;
    }
LABEL_17:
    v17 = 561211770;
    goto LABEL_18;
  }
  if (v14 == 1819107691)
  {
    *a6 = 8;
    if (a5 >= 8)
    {
      v17 = 0;
      *(_QWORD *)a7 = CFSTR("Apple Inc.");
LABEL_18:
      *((_DWORD *)v27 + 6) = v17;
      goto LABEL_19;
    }
    goto LABEL_17;
  }
  if (v14 == 1870098020)
    goto LABEL_11;
  if (v14 != 1969841252)
  {
LABEL_16:
    *((_DWORD *)v27 + 6) = 2003332927;
    goto LABEL_19;
  }
  if (a5 > 3 && a3 == 8 && a4)
  {
    v15 = *(NSObject **)(DerivedStorage + 16);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __endpointCentricPlugin_GetPropertyData_block_invoke_2;
    block[3] = &unk_1E28DF6D0;
    block[4] = &v26;
    block[5] = DerivedStorage;
    v22 = a5;
    block[6] = a4;
    block[7] = a6;
    block[8] = a7;
    dispatch_sync(v15, block);
  }
  else
  {
    v20 = FigSignalErrorAt(561211770, 0, 0, 0, 0, 0, 0);
    *((_DWORD *)v27 + 6) = v20;
  }
LABEL_19:
  v18 = *((unsigned int *)v27 + 6);
  _Block_object_dispose(&v26, 8);
  return v18;
}

uint64_t endpointCentricPlugin_SetPropertyData()
{
  return 2003332927;
}

uint64_t endpointCentricPlugin_Initialize(const void *a1, uint64_t a2)
{
  _QWORD *DerivedStorage;
  void (*v5)(_QWORD, _QWORD, uint64_t, uint64_t *);
  NSObject *v6;
  uint64_t v7;
  _QWORD block[8];
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;

  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v10 = 0;
  *DerivedStorage = a2;
  v5 = (void (*)(_QWORD, _QWORD, uint64_t, uint64_t *))DerivedStorage[7];
  if (v5)
    v5(*MEMORY[0x1E0C9AE00], DerivedStorage[1], a2, &v10);
  CFRetain(a1);
  v6 = DerivedStorage[2];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __endpointCentricPlugin_Initialize_block_invoke;
  block[3] = &unk_1E28DF6F8;
  block[4] = &v11;
  block[5] = v10;
  block[6] = DerivedStorage;
  block[7] = a1;
  dispatch_async(v6, block);
  v7 = *((unsigned int *)v12 + 6);
  _Block_object_dispose(&v11, 8);
  return v7;
}

void endpointCentricPlugin_ActivatedEndpointsChangedNotificationCallback(uint64_t a1, const void *a2)
{
  uint64_t DerivedStorage;
  NSObject *v4;
  _QWORD block[5];

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a2);
  CFRetain(a2);
  v4 = *(NSObject **)(DerivedStorage + 16);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __endpointCentricPlugin_ActivatedEndpointsChangedNotificationCallback_block_invoke;
  block[3] = &__block_descriptor_tmp_10_3;
  block[4] = a2;
  dispatch_async(v4, block);
}

void endpointCentricPlugin_PeruseActivatedEndpoints(uint64_t a1)
{
  uint64_t DerivedStorage;
  NSObject *v3;
  _QWORD v4[4];
  __int128 v5;
  uint64_t v6;
  __CFArray *v7;
  __int128 v8;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v8 = (unint64_t)a1;
  v7 = 0;
  if (!FigEndpointManagerCopyActivatedEndpoints(*(_QWORD *)(DerivedStorage + 40), (const __CFAllocator *)*MEMORY[0x1E0C9AE00], &v7))
  {
    FigCFArrayApplyFunction(v7, (void (__cdecl *)(const void *, void *))endpointCentricPlugin_UpdateEndpointApplier, &v8);
    if (BYTE9(v8))
    {
      v3 = *(NSObject **)(DerivedStorage + 24);
      v4[0] = MEMORY[0x1E0C809B0];
      v4[1] = 0x40000000;
      v4[2] = __endpointCentricPlugin_PeruseActivatedEndpoints_block_invoke;
      v4[3] = &__block_descriptor_tmp_11_2;
      v5 = v8;
      v6 = DerivedStorage;
      dispatch_async(v3, v4);
    }
  }
  if (v7)
    CFRelease(v7);
}

uint64_t endpointCentricPlugin_UpdateEndpointApplier(void *a1, uint64_t a2)
{
  uint64_t result;

  result = endpointCentricPlugin_UpdateEndpoint(*(const void **)a2, a1, *(unsigned __int8 *)(a2 + 8));
  *(_BYTE *)(a2 + 9) += result;
  return result;
}

uint64_t endpointCentricPlugin_UpdateEndpoint(const void *a1, void *a2, int a3)
{
  uint64_t DerivedStorage;
  CFAllocatorRef *v7;
  uint64_t v8;
  void *v10;
  const __CFSet *v11;
  const __CFAllocator *v12;
  CFMutableSetRef Mutable;
  __CFSet *MutableCopy;
  __CFSet *v15;
  CFIndex Count;
  CFIndex v17;
  CFIndex i;
  const void *ValueAtIndex;
  __CFNotificationCenter *DefaultLocalCenter;
  __CFNotificationCenter *v21;
  __CFNotificationCenter *v22;
  __CFNotificationCenter *v23;
  __CFNotificationCenter *v24;
  __CFNotificationCenter *v25;
  __CFNotificationCenter *v26;
  __CFNotificationCenter *v27;
  _QWORD context[2];
  void *value;
  uint64_t v31;
  CFArrayRef theArray;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  v31 = 0;
  theArray = 0;
  context[0] = DerivedStorage;
  context[1] = a2;
  v7 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (!a3)
  {
    v8 = FigEndpointCopyStreamsForTypeAndSubType((uint64_t)a2, *MEMORY[0x1E0C9AE00], (uint64_t)CFSTR("Audio"), 0, &theArray);
    if ((_DWORD)v8 != -16723 && (_DWORD)v8 != 0)
      FigSignalErrorAt(v8, 0, 0, 0, 0, 0, 0);
  }
  v10 = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(DerivedStorage + 80), a2);
  value = v10;
  if (v10)
  {
    v11 = (const __CFSet *)v10;
    CFRetain(v10);
    v12 = *v7;
  }
  else
  {
    v12 = *v7;
    Mutable = CFSetCreateMutable(*v7, 0, MEMORY[0x1E0C9B3B0]);
    value = Mutable;
    if (!Mutable)
    {
      FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
      v15 = 0;
      MutableCopy = 0;
      goto LABEL_24;
    }
    v11 = Mutable;
  }
  MutableCopy = CFSetCreateMutableCopy(v12, 0, v11);
  if (MutableCopy)
  {
    v15 = CFSetCreateMutable(v12, 0, MEMORY[0x1E0C9B3B0]);
    if (v15)
    {
      if (theArray)
      {
        Count = CFArrayGetCount(theArray);
        if (Count >= 1)
        {
          v17 = Count;
          for (i = 0; i != v17; ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
            if (CFSetContainsValue(v11, ValueAtIndex))
              CFSetRemoveValue(MutableCopy, ValueAtIndex);
            else
              CFSetAddValue(v15, ValueAtIndex);
          }
        }
      }
      CFSetApplyFunction(v15, (CFSetApplierFunction)endpointCentricPlugin_AddStreamApplier, context);
      CFSetApplyFunction(MutableCopy, (CFSetApplierFunction)endpointCentricPlugin_RemoveStreamApplier, context);
      if (a3)
      {
        DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterRemoveListener(DefaultLocalCenter, a1, (int)endpointCentricPlugin_EndpointNotificationCallback, CFSTR("Endpoint_EndpointActivated"), a2);
        v21 = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterRemoveListener(v21, a1, (int)endpointCentricPlugin_EndpointNotificationCallback, CFSTR("Endpoint_EndpointDeactivated"), a2);
        v22 = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterRemoveListener(v22, a1, (int)endpointCentricPlugin_EndpointNotificationCallback, CFSTR("Endpoint_StreamsChanged"), a2);
        v23 = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterRemoveListener(v23, a1, (int)endpointCentricPlugin_EndpointNotificationCallback, CFSTR("Endpoint_Dissociated"), a2);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(DerivedStorage + 80), a2);
      }
      else if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(DerivedStorage + 80), a2))
      {
        v24 = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterAddListener(v24, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))endpointCentricPlugin_EndpointNotificationCallback, CFSTR("Endpoint_EndpointActivated"), (unint64_t)a2);
        v25 = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterAddListener(v25, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))endpointCentricPlugin_EndpointNotificationCallback, CFSTR("Endpoint_EndpointDeactivated"), (unint64_t)a2);
        v26 = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterAddListener(v26, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))endpointCentricPlugin_EndpointNotificationCallback, CFSTR("Endpoint_StreamsChanged"), (unint64_t)a2);
        v27 = CMNotificationCenterGetDefaultLocalCenter();
        CMNotificationCenterAddListener(v27, a1, (void (__cdecl *)(CFNotificationCenterRef, void *, CFNotificationName, const void *, CFDictionaryRef))endpointCentricPlugin_EndpointNotificationCallback, CFSTR("Endpoint_Dissociated"), (unint64_t)a2);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(DerivedStorage + 80), a2, value);
      }
    }
    else
    {
      FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    FigSignalErrorAt(4294950406, 0, 0, 0, 0, 0, 0);
    v15 = 0;
  }
LABEL_24:
  if (theArray)
    CFRelease(theArray);
  if (v15)
    CFRelease(v15);
  if (MutableCopy)
    CFRelease(MutableCopy);
  if (value)
    CFRelease(value);
  return v31;
}

void endpointCentricPlugin_AddStreamApplier(const void *a1, uint64_t a2)
{
  int v4;
  void *v5;
  BOOL v6;
  void *value;

  value = 0;
  v4 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, const void *, _QWORD, void **))(*(_QWORD *)a2 + 48))(*MEMORY[0x1E0C9AE00], *(_QWORD *)(*(_QWORD *)a2 + 8), **(_QWORD **)a2, *(_QWORD *)(a2 + 8), a1, 0, &value);
  v5 = value;
  if (v4)
    v6 = 1;
  else
    v6 = value == 0;
  if (!v6)
  {
    CFSetAddValue(*(CFMutableSetRef *)(a2 + 16), a1);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(*(_QWORD *)a2 + 72), a1, value);
    ++*(_QWORD *)(a2 + 24);
    v5 = value;
  }
  if (v5)
    CFRelease(v5);
}

void endpointCentricPlugin_RemoveStreamApplier(void *value, uint64_t a2)
{
  CFSetRemoveValue(*(CFMutableSetRef *)(a2 + 16), value);
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(*(_QWORD *)a2 + 72), value))
  {
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(_QWORD *)a2 + 72), value);
    ++*(_QWORD *)(a2 + 24);
  }
}

void endpointCentricPlugin_EndpointNotificationCallback(uint64_t a1, const void *a2, uint64_t a3, const void *a4)
{
  uint64_t DerivedStorage;
  NSObject *v8;
  _QWORD v9[8];

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a2);
  CFRetain(a2);
  CFRetain(a4);
  v8 = *(NSObject **)(DerivedStorage + 16);
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __endpointCentricPlugin_EndpointNotificationCallback_block_invoke;
  v9[3] = &__block_descriptor_tmp_13_2;
  v9[4] = a3;
  v9[5] = a2;
  v9[6] = a4;
  v9[7] = DerivedStorage;
  dispatch_async(v8, v9);
}

BOOL FigTagCollectionIsEmpty(const OpaqueCMTagCollection *a1)
{
  return CMTagCollectionGetCount(a1) == 0;
}

Boolean CMTagCollectionIsEmpty(CMTagCollectionRef tagCollection)
{
  return CMTagCollectionGetCount(tagCollection) == 0;
}

CMItemCount CMTagCollectionGetCount(CMTagCollectionRef tagCollection)
{
  CFTypeID v2;

  if (tagCollection)
  {
    v2 = CFGetTypeID(tagCollection);
    if (sRegisterCMTagCollectionTypeOnce != -1)
      dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
    if (v2 == sCMTagCollectionID)
      return *((_QWORD *)tagCollection + 4);
  }
  FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t FigTagCollectionGetTypeID()
{
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  return sCMTagCollectionID;
}

CFTypeID CMTagCollectionGetTypeID(void)
{
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  return sCMTagCollectionID;
}

uint64_t RegisterCMTagCollectionType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sCMTagCollectionID = result;
  return result;
}

uint64_t FigTagCollectionCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return _CMTagCollectionCreateCommon(0, a1, a2, a3, 0, 0, a4);
}

OSStatus CMTagCollectionCreate(CFAllocatorRef allocator, const CMTag *tags, CMItemCount tagCount, CMTagCollectionRef *newCollectionOut)
{
  return _CMTagCollectionCreateCommon(0, (uint64_t)allocator, (uint64_t)tags, tagCount, 0, 0, (uint64_t *)newCollectionOut);
}

uint64_t _CMTagCollectionCreateCommon(char a1, uint64_t a2, uint64_t a3, uint64_t a4, int64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v10;
  _QWORD *Instance;
  uint64_t v14;
  uint64_t v15;
  int64_t v17;
  uint64_t v18;
  _BOOL4 v19;

  if (!a7)
  {
    v15 = 4294951556;
    return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
  v10 = a4;
  if ((a1 & 1) == 0 || (a1 & 2) != 0)
  {
    if ((a1 & 3) != 0)
    {
      if (((a1 & 1) == 0 || (a1 & 2) == 0) && (a1 & 3) != 2 || !a6)
        goto LABEL_34;
    }
    else
    {
      v19 = a4 < 0;
      if (!a3)
        v19 = a4 != 0;
      if (v19)
        goto LABEL_34;
    }
  }
  else if (a3 || a4 || a5 < 0)
  {
LABEL_34:
    v15 = 4294951556;
    return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
  *a7 = 0;
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  if (!Instance)
  {
    v15 = 4294951555;
    return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
  v14 = (uint64_t)Instance;
  Instance[3] = 0;
  Instance[4] = 0;
  Instance[2] = 0x274616773;
  Instance[5] = 0;
  Instance[6] = 16;
  Instance[7] = Instance + 8;
  if ((a1 & 2) != 0)
  {
    _CMTagCollectionEnsureTagArraySpace((uint64_t)Instance, *(_QWORD *)(a6 + 48), 0);
    *(_QWORD *)(v14 + 32) = *(_QWORD *)(a6 + 32);
    memcpy(*(void **)(v14 + 56), *(const void **)(a6 + 56), 16 * *(_QWORD *)(a6 + 32));
  }
  else
  {
    if ((a1 & 1) != 0)
      v17 = a5;
    else
      v17 = v10;
    _CMTagCollectionEnsureTagArraySpace((uint64_t)Instance, v17, 0);
    if (a3 && v10 >= 1 && (a1 & 1) == 0)
    {
      v18 = a3 + 8;
      do
      {
        _CMTagCollectionAddTagAvoidingDuplicates(v14, *(CMTag *)(v18 - 8));
        v18 += 16;
        --v10;
      }
      while (v10);
    }
  }
  if ((a1 & 1) != 0)
    *(_DWORD *)(v14 + 20) |= 1u;
  *a7 = v14;
  return 0;
}

uint64_t FigTagCollectionCreateMutable(uint64_t a1, int64_t a2, uint64_t *a3)
{
  return _CMTagCollectionCreateCommon(1, a1, 0, 0, a2, 0, a3);
}

OSStatus CMTagCollectionCreateMutable(CFAllocatorRef allocator, CFIndex capacity, CMMutableTagCollectionRef *newMutableCollectionOut)
{
  return _CMTagCollectionCreateCommon(1, (uint64_t)allocator, 0, 0, capacity, 0, (uint64_t *)newMutableCollectionOut);
}

uint64_t FigTagCollectionCreateCopy(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return _CMTagCollectionCreateCommon(2, a2, 0, 0, 0, a1, a3);
}

OSStatus CMTagCollectionCreateCopy(CMTagCollectionRef tagCollection, CFAllocatorRef allocator, CMTagCollectionRef *newCollectionCopyOut)
{
  return _CMTagCollectionCreateCommon(2, (uint64_t)allocator, 0, 0, 0, (uint64_t)tagCollection, (uint64_t *)newCollectionCopyOut);
}

uint64_t FigTagCollectionCreateMutableCopy(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return _CMTagCollectionCreateCommon(3, a2, 0, 0, 0, a1, a3);
}

OSStatus CMTagCollectionCreateMutableCopy(CMTagCollectionRef tagCollection, CFAllocatorRef allocator, CMMutableTagCollectionRef *newMutableCollectionCopyOut)
{
  return _CMTagCollectionCreateCommon(3, (uint64_t)allocator, 0, 0, 0, (uint64_t)tagCollection, (uint64_t *)newMutableCollectionCopyOut);
}

CFStringRef CMTagCollectionCopyDescription(CFAllocatorRef allocator, CMTagCollectionRef tagCollection)
{
  CFMutableStringRef Mutable;
  CFTypeID v5;
  uint64_t v6;
  uint64_t v7;
  CFStringRef v8;

  Mutable = CFStringCreateMutable(allocator, 0);
  if (Mutable)
  {
    if (!tagCollection)
      goto LABEL_19;
    v5 = CFGetTypeID(tagCollection);
    if (sRegisterCMTagCollectionTypeOnce != -1)
      dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
    if (v5 == sCMTagCollectionID)
    {
      if ((*((_DWORD *)tagCollection + 5) & 1) != 0)
        CFStringAppendFormat(Mutable, 0, CFSTR("CMMutableTagCollection"));
      else
        CFStringAppendFormat(Mutable, 0, CFSTR("CMTagCollection"));
      if ((*((_BYTE *)tagCollection + 20) & 0x10) != 0)
      {
        CFStringAppendFormat(Mutable, 0, CFSTR("{inline}"));
        if ((*((_BYTE *)tagCollection + 20) & 0x10) != 0)
          CFStringAppendFormat(Mutable, 0, CFSTR("{%d tags}"), *((_QWORD *)tagCollection + 4));
      }
      CFStringAppendFormat(Mutable, 0, CFSTR("{\n"));
      if (*((uint64_t *)tagCollection + 4) >= 1)
      {
        v6 = 0;
        v7 = 0;
        do
        {
          v8 = CMTagCopyDescription(allocator, *(CMTag *)(*((_QWORD *)tagCollection + 7) + v6));
          CFStringAppendFormat(Mutable, 0, CFSTR("%@\n"), v8);
          if (v8)
            CFRelease(v8);
          ++v7;
          v6 += 16;
        }
        while (v7 < *((_QWORD *)tagCollection + 4));
      }
      CFStringAppendFormat(Mutable, 0, CFSTR("}"));
    }
    else
    {
LABEL_19:
      FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    }
  }
  return Mutable;
}

void CMTagCollectionApply(CMTagCollectionRef tagCollection, CMTagCollectionApplierFunction applier, void *context)
{
  CFTypeID v6;
  uint64_t v8;
  uint64_t v9;

  if (!tagCollection)
    goto LABEL_12;
  v6 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v6 != sCMTagCollectionID || applier == 0)
  {
LABEL_12:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
  else if (*((uint64_t *)tagCollection + 4) >= 1)
  {
    v8 = 0;
    v9 = 0;
    do
    {
      ((void (*)(_QWORD, _QWORD, void *))applier)(*(_QWORD *)(*((_QWORD *)tagCollection + 7) + v8), *(_QWORD *)(*((_QWORD *)tagCollection + 7) + v8 + 8), context);
      ++v9;
      v8 += 16;
    }
    while (v9 < *((_QWORD *)tagCollection + 4));
  }
}

CMTag CMTagCollectionApplyUntil(CMTagCollectionRef tagCollection, CMTagCollectionTagFilterFunction applier, void *context)
{
  CMTagValue v3;
  uint64_t v4;
  CFTypeID v8;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  CMTagValue v14;
  uint64_t v15;
  CMTagValue v16;
  CMTag result;

  v4 = 0;
  v3 = 0;
  if (!tagCollection)
    goto LABEL_15;
  v8 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v8 != sCMTagCollectionID || applier == 0)
  {
LABEL_15:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
  else if (*((uint64_t *)tagCollection + 4) >= 1)
  {
    v10 = 0;
    v11 = 0;
    while (1)
    {
      v12 = (_QWORD *)(*((_QWORD *)tagCollection + 7) + v10);
      v13 = *v12;
      v14 = v12[1];
      if (((unsigned int (*)(_QWORD, CMTagValue, void *))applier)(*v12, v14, context))
        break;
      ++v11;
      v10 += 16;
      if (v11 >= *((_QWORD *)tagCollection + 4))
        goto LABEL_14;
    }
    v3 = v14;
    v4 = v13;
  }
LABEL_14:
  v15 = v4;
  v16 = v3;
  result.value = v16;
  result.category = v15;
  result.dataType = HIDWORD(v15);
  return result;
}

Boolean CMTagCollectionContainsTag(CMTagCollectionRef tagCollection, CMTag tag)
{
  CMTagValue value;
  uint64_t v3;
  CFTypeID v5;
  _QWORD context[2];
  uint64_t v8;

  if (!tagCollection)
    goto LABEL_6;
  value = tag.value;
  v3 = *(_QWORD *)&tag.category;
  v5 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v5 == sCMTagCollectionID)
  {
    context[1] = value;
    v8 = 0;
    context[0] = v3;
    CMTagCollectionApplyUntil(tagCollection, (CMTagCollectionTagFilterFunction)_CMTagCollectionContainsTagApplier, context);
    return v8;
  }
  else
  {
LABEL_6:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

uint64_t _CMTagCollectionContainsTagApplier(CMTag a1, uint64_t a2)
{
  uint64_t result;

  if (!CMTagEqualToTag(a1, *(CMTag *)a2))
    return *(unsigned __int8 *)(a2 + 16);
  result = 1;
  *(_BYTE *)(a2 + 16) = 1;
  return result;
}

Boolean CMTagCollectionContainsTagsOfCollection(CMTagCollectionRef tagCollection, CMTagCollectionRef containedTagCollection)
{
  CFTypeID v4;
  CMTagCollectionRef v6;
  uint64_t v7;

  if (!tagCollection)
    goto LABEL_7;
  v4 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v4 == sCMTagCollectionID)
  {
    v6 = tagCollection;
    v7 = 0;
    CMTagCollectionApply(containedTagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionContainsTagsApplier, &v6);
    if (!HIDWORD(v7))
      return (_BYTE)v7 == 0;
  }
  else
  {
LABEL_7:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t _CMTagCollectionContainsTagsApplier(CMTag tag, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 12) && !*(_BYTE *)(a2 + 8))
  {
    *(_QWORD *)&tag.category = CMTagCollectionContainsTag(*(CMTagCollectionRef *)a2, tag);
    *(_BYTE *)(a2 + 8) = tag.category == kCMTagCategory_Undefined;
    if (!*(_DWORD *)(a2 + 12))
      *(_DWORD *)(a2 + 12) = 0;
  }
  return *(_QWORD *)&tag.category;
}

Boolean CMTagCollectionContainsSpecifiedTags(CMTagCollectionRef tagCollection, const CMTag *containedTags, CMItemCount containedTagCount)
{
  CFTypeID v6;
  BOOL v7;
  CMTagValue *p_value;

  if (!tagCollection)
    goto LABEL_14;
  v6 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v6 == sCMTagCollectionID && containedTags && (containedTagCount & 0x8000000000000000) == 0)
  {
    if (containedTagCount)
    {
      v7 = 0;
      p_value = &containedTags->value;
      do
      {
        if (!v7)
          v7 = CMTagCollectionContainsTag(tagCollection, *(CMTag *)(p_value - 1)) == 0;
        p_value += 2;
        --containedTagCount;
      }
      while (containedTagCount);
      return !v7;
    }
    else
    {
      return 1;
    }
  }
  else
  {
LABEL_14:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

Boolean CMTagCollectionContainsCategory(CMTagCollectionRef tagCollection, CMTagCategory category)
{
  CFTypeID v4;
  CMTagCategory context;

  if (!tagCollection)
    goto LABEL_6;
  v4 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v4 == sCMTagCollectionID)
  {
    context = category;
    return CMTagCollectionApplyUntil(tagCollection, (CMTagCollectionTagFilterFunction)_CMTagCollectionContainsTagCategoryApplier, &context).category == category;
  }
  else
  {
LABEL_6:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

BOOL _CMTagCollectionContainsTagCategoryApplier(int a1, uint64_t a2, _DWORD *a3)
{
  return *a3 == a1;
}

CMItemCount CMTagCollectionGetCountOfCategory(CMTagCollectionRef tagCollection, CMTagCategory category)
{
  CFTypeID v4;
  uint64_t v6;
  uint64_t v7;

  if (!tagCollection)
    goto LABEL_6;
  v4 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v4 == sCMTagCollectionID)
  {
    v7 = 0;
    v6 = category;
    CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionCountOfCategoryApplier, &v6);
    return v7;
  }
  else
  {
LABEL_6:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

uint64_t _CMTagCollectionCountOfCategoryApplier(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)a3 == (_DWORD)result)
    ++*(_QWORD *)(a3 + 8);
  return result;
}

CMItemCount CMTagCollectionCountTagsWithFilterFunction(CMTagCollectionRef tagCollection, CMTagCollectionTagFilterFunction filterApplier, void *context)
{
  CFTypeID v6;
  _QWORD v8[2];
  __int128 v9;
  __int128 v10;

  if (!tagCollection)
    goto LABEL_9;
  v6 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v6 == sCMTagCollectionID && filterApplier)
  {
    v9 = 0u;
    v8[0] = filterApplier;
    v8[1] = context;
    v10 = 0uLL;
    CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionCountTagsFilterFunctionApplier, v8);
    if (HIDWORD(v10))
      return 0;
    else
      return v9;
  }
  else
  {
LABEL_9:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    return 0;
  }
}

uint64_t _CMTagCollectionCountTagsFilterFunctionApplier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))a3)(a1, a2, *(_QWORD *)(a3 + 8));
  if ((_DWORD)result)
    ++*(_QWORD *)(a3 + 16);
  return result;
}

OSStatus CMTagCollectionGetTagsWithFilterFunction(CMTagCollectionRef tagCollection, CMTag *tagBuffer, CMItemCount tagBufferCount, CMItemCount *numberOfTagsCopied, CMTagCollectionTagFilterFunction filter, void *context)
{
  CFTypeID v12;
  BOOL v13;
  CMItemCount v15;
  OSStatus result;
  CMTag *v17;
  _QWORD v18[2];
  CMItemCount v19;
  CMItemCount v20;
  CMTag *v21;
  uint64_t v22;

  if (!tagCollection)
    goto LABEL_19;
  v12 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  v13 = v12 != sCMTagCollectionID || tagBuffer == 0;
  if (v13 || filter == 0)
  {
LABEL_19:
    result = FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    v15 = 0;
    if (!numberOfTagsCopied)
      return result;
    goto LABEL_17;
  }
  v18[0] = filter;
  v18[1] = context;
  v21 = tagBuffer;
  v22 = 0;
  v19 = 0;
  v20 = tagBufferCount;
  CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionGetTagsFilterFunctionApplier, v18);
  v15 = v19;
  result = HIDWORD(v22);
  if (!HIDWORD(v22))
  {
    if (v19 < tagBufferCount)
    {
      v17 = &tagBuffer[v19];
      do
      {
        *v17++ = kCMTagInvalid;
        --tagBufferCount;
      }
      while (v15 != tagBufferCount);
    }
    result = 0;
  }
  if (numberOfTagsCopied)
LABEL_17:
    *numberOfTagsCopied = v15;
  return result;
}

uint64_t _CMTagCollectionGetTagsFilterFunctionApplier(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;

  if (!*(_DWORD *)(a3 + 44) && !*(_BYTE *)(a3 + 40))
  {
    v5 = result;
    result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))a3)(result, a2, *(_QWORD *)(a3 + 8));
    if ((_DWORD)result)
    {
      v6 = *(_QWORD *)(a3 + 16);
      if (v6 == *(_QWORD *)(a3 + 24))
      {
        *(_BYTE *)(a3 + 40) = 1;
        *(_DWORD *)(a3 + 44) = -15748;
      }
      else
      {
        v7 = (uint64_t *)(*(_QWORD *)(a3 + 32) + 16 * v6);
        *v7 = v5;
        v7[1] = a2;
        ++*(_QWORD *)(a3 + 16);
      }
    }
  }
  return result;
}

uint64_t FigTagCollectionGetTags(const OpaqueCMTagCollection *a1, CMTag *a2, CMItemCount a3, CMItemCount *a4)
{
  return CMTagCollectionGetTagsWithFilterFunction(a1, a2, a3, a4, (CMTagCollectionTagFilterFunction)_CMTagCollectionAllTagsFilter, 0);
}

OSStatus CMTagCollectionGetTags(CMTagCollectionRef tagCollection, CMTag *tagBuffer, CMItemCount tagBufferCount, CMItemCount *numberOfTagsCopied)
{
  return CMTagCollectionGetTagsWithFilterFunction(tagCollection, tagBuffer, tagBufferCount, numberOfTagsCopied, (CMTagCollectionTagFilterFunction)_CMTagCollectionAllTagsFilter, 0);
}

uint64_t _CMTagCollectionAllTagsFilter()
{
  return 1;
}

uint64_t FigTagCollectionGetTagsWithCategory(const OpaqueCMTagCollection *a1, int a2, CMTag *tagBuffer, CMItemCount tagBufferCount, CMItemCount *numberOfTagsCopied)
{
  int context;

  context = a2;
  return CMTagCollectionGetTagsWithFilterFunction(a1, tagBuffer, tagBufferCount, numberOfTagsCopied, (CMTagCollectionTagFilterFunction)_CMTagCollectionAllTagsOfCategoryFilter, &context);
}

OSStatus CMTagCollectionGetTagsWithCategory(CMTagCollectionRef tagCollection, CMTagCategory category, CMTag *tagBuffer, CMItemCount tagBufferCount, CMItemCount *numberOfTagsCopied)
{
  CMTagCategory context;

  context = category;
  return CMTagCollectionGetTagsWithFilterFunction(tagCollection, tagBuffer, tagBufferCount, numberOfTagsCopied, (CMTagCollectionTagFilterFunction)_CMTagCollectionAllTagsOfCategoryFilter, &context);
}

BOOL _CMTagCollectionAllTagsOfCategoryFilter(int a1, uint64_t a2, _DWORD *a3)
{
  return *a3 == a1;
}

OSStatus CMTagCollectionCreateIntersection(CMTagCollectionRef tagCollection1, CMTagCollectionRef tagCollection2, CMTagCollectionRef *tagCollectionOut)
{
  CFTypeID v6;
  CFTypeID v8;
  CFAllocatorRef v9;
  OSStatus Common;
  OSStatus v11;
  _QWORD context[3];
  uint64_t v14;
  CFTypeRef cf;

  cf = 0;
  if (!tagCollection1)
    goto LABEL_20;
  v6 = CFGetTypeID(tagCollection1);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v6 != sCMTagCollectionID || tagCollection2 == 0)
    goto LABEL_20;
  v8 = CFGetTypeID(tagCollection2);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v8 == sCMTagCollectionID && tagCollectionOut)
  {
    v9 = CFGetAllocator(tagCollection1);
    if (tagCollection1 == tagCollection2)
    {
      Common = _CMTagCollectionCreateCommon(3, (uint64_t)v9, 0, 0, 0, (uint64_t)tagCollection1, (uint64_t *)&cf);
      if (!Common)
        goto LABEL_18;
    }
    else
    {
      Common = _CMTagCollectionCreateCommon(1, (uint64_t)v9, 0, 0, 0, 0, (uint64_t *)&cf);
      if (!Common)
      {
        context[0] = tagCollection1;
        context[1] = tagCollection2;
        context[2] = cf;
        v14 = 0;
        CMTagCollectionApply(tagCollection1, (CMTagCollectionApplierFunction)_CMTagCollectionIntersectApplier, context);
        v11 = v14;
        if ((_DWORD)v14)
          goto LABEL_15;
LABEL_18:
        v11 = 0;
        *tagCollectionOut = (CMTagCollectionRef)cf;
        return v11;
      }
    }
  }
  else
  {
LABEL_20:
    Common = FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
  v11 = Common;
LABEL_15:
  if (cf)
    CFRelease(cf);
  return v11;
}

uint64_t _CMTagCollectionIntersectApplier(CMTag tag, uint64_t a2)
{
  CMTagValue value;
  uint64_t v4;
  const OpaqueCMTagCollection *v5;
  CMTag v7;
  CMTag v8;

  if (!*(_DWORD *)(a2 + 24))
  {
    value = tag.value;
    v4 = *(_QWORD *)&tag.category;
    v5 = *(const OpaqueCMTagCollection **)(a2 + 8);
    *(_QWORD *)&v7.category = v4;
    v7.value = value;
    *(_QWORD *)&tag.category = CMTagCollectionContainsTag(v5, v7);
    if (tag.category)
    {
      *(_QWORD *)&v8.category = v4;
      v8.value = value;
      *(_QWORD *)&tag.category = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)(a2 + 16), v8);
    }
    if (!*(_DWORD *)(a2 + 24))
      *(_DWORD *)(a2 + 24) = tag.category;
  }
  return *(_QWORD *)&tag.category;
}

OSStatus CMTagCollectionCreateUnion(CMTagCollectionRef tagCollection1, CMTagCollectionRef tagCollection2, CMTagCollectionRef *tagCollectionOut)
{
  CFTypeID v6;
  CFTypeID v7;
  CFAllocatorRef v8;
  OSStatus Common;
  OSStatus v10;
  _QWORD context[3];
  uint64_t v13;
  CFTypeRef cf;

  cf = 0;
  if (!tagCollection1)
    goto LABEL_18;
  v6 = CFGetTypeID(tagCollection1);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v6 != sCMTagCollectionID || !tagCollection2)
    goto LABEL_18;
  v7 = CFGetTypeID(tagCollection2);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v7 != sCMTagCollectionID || !tagCollectionOut)
  {
LABEL_18:
    Common = FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  v8 = CFGetAllocator(tagCollection1);
  if (tagCollection1 == tagCollection2)
  {
    Common = _CMTagCollectionCreateCommon(3, (uint64_t)v8, 0, 0, 0, (uint64_t)tagCollection1, (uint64_t *)&cf);
    if (!Common)
    {
LABEL_16:
      v10 = 0;
      *tagCollectionOut = (CMTagCollectionRef)cf;
      return v10;
    }
LABEL_19:
    v10 = Common;
    goto LABEL_20;
  }
  Common = _CMTagCollectionCreateCommon(1, (uint64_t)v8, 0, 0, 0, 0, (uint64_t *)&cf);
  if (Common)
    goto LABEL_19;
  context[0] = tagCollection1;
  context[1] = tagCollection2;
  context[2] = cf;
  v13 = 0;
  CMTagCollectionApply(tagCollection1, (CMTagCollectionApplierFunction)_CMTagCollectionUnionApplier, context);
  v10 = v13;
  if (!(_DWORD)v13)
  {
    LODWORD(v13) = 0;
    CMTagCollectionApply(tagCollection2, (CMTagCollectionApplierFunction)_CMTagCollectionUnionApplier, context);
    v10 = v13;
    if (!(_DWORD)v13)
      goto LABEL_16;
  }
LABEL_20:
  if (cf)
    CFRelease(cf);
  return v10;
}

uint64_t _CMTagCollectionUnionApplier(CMTag tagToAdd, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 24))
  {
    *(_QWORD *)&tagToAdd.category = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)(a2 + 16), tagToAdd);
    if (!*(_DWORD *)(a2 + 24))
      *(_DWORD *)(a2 + 24) = tagToAdd.category;
  }
  return *(_QWORD *)&tagToAdd.category;
}

OSStatus CMTagCollectionCreateDifference(CMTagCollectionRef tagCollectionMinuend, CMTagCollectionRef tagCollectionSubtrahend, CMTagCollectionRef *tagCollectionOut)
{
  CFTypeID v6;
  CFTypeID v8;
  CFAllocatorRef v9;
  OSStatus Common;
  OSStatus v11;
  _QWORD context[3];
  uint64_t v14;
  CFTypeRef cf;

  cf = 0;
  if (!tagCollectionMinuend)
    goto LABEL_17;
  v6 = CFGetTypeID(tagCollectionMinuend);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v6 != sCMTagCollectionID || tagCollectionSubtrahend == 0)
    goto LABEL_17;
  v8 = CFGetTypeID(tagCollectionSubtrahend);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v8 == sCMTagCollectionID && tagCollectionOut)
  {
    v9 = CFGetAllocator(tagCollectionMinuend);
    Common = _CMTagCollectionCreateCommon(1, (uint64_t)v9, 0, 0, 0, 0, (uint64_t *)&cf);
    v11 = Common;
    if (tagCollectionMinuend != tagCollectionSubtrahend)
    {
      if (Common)
        goto LABEL_18;
      context[0] = tagCollectionMinuend;
      context[1] = tagCollectionSubtrahend;
      context[2] = cf;
      v14 = 0;
      CMTagCollectionApply(tagCollectionMinuend, (CMTagCollectionApplierFunction)_CMTagCollectionSubtractApplier, context);
      v11 = v14;
    }
    if (!v11)
    {
      v11 = 0;
      *tagCollectionOut = (CMTagCollectionRef)cf;
      return v11;
    }
  }
  else
  {
LABEL_17:
    v11 = FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  }
LABEL_18:
  if (cf)
    CFRelease(cf);
  return v11;
}

uint64_t _CMTagCollectionSubtractApplier(CMTag tag, uint64_t a2)
{
  CMTagValue value;
  uint64_t v4;
  const OpaqueCMTagCollection *v5;
  CMTag v7;
  CMTag v8;

  if (!*(_DWORD *)(a2 + 24))
  {
    value = tag.value;
    v4 = *(_QWORD *)&tag.category;
    v5 = *(const OpaqueCMTagCollection **)(a2 + 8);
    *(_QWORD *)&v7.category = v4;
    v7.value = value;
    if (CMTagCollectionContainsTag(v5, v7))
    {
      *(_QWORD *)&tag.category = 0;
    }
    else
    {
      *(_QWORD *)&v8.category = v4;
      v8.value = value;
      *(_QWORD *)&tag.category = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)(a2 + 16), v8);
    }
    if (!*(_DWORD *)(a2 + 24))
      *(_DWORD *)(a2 + 24) = tag.category;
  }
  return *(_QWORD *)&tag.category;
}

OSStatus CMTagCollectionCreateExclusiveOr(CMTagCollectionRef tagCollection1, CMTagCollectionRef tagCollection2, CMTagCollectionRef *tagCollectionOut)
{
  CFTypeID v6;
  CFTypeID v7;
  CFAllocatorRef v8;
  OSStatus Common;
  OSStatus v10;
  CMTagCollectionRef context;
  CMTagCollectionRef v13;
  CFTypeRef v14;
  uint64_t v15;
  CFTypeRef cf;

  cf = 0;
  if (!tagCollection1)
    goto LABEL_17;
  v6 = CFGetTypeID(tagCollection1);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v6 != sCMTagCollectionID || !tagCollection2)
    goto LABEL_17;
  v7 = CFGetTypeID(tagCollection2);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v7 != sCMTagCollectionID || !tagCollectionOut)
  {
LABEL_17:
    v10 = FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    goto LABEL_18;
  }
  v8 = CFGetAllocator(tagCollection1);
  Common = _CMTagCollectionCreateCommon(1, (uint64_t)v8, 0, 0, 0, 0, (uint64_t *)&cf);
  v10 = Common;
  if (tagCollection1 != tagCollection2)
  {
    if (Common)
      goto LABEL_18;
    v14 = cf;
    v15 = 0;
    context = tagCollection1;
    v13 = tagCollection2;
    CMTagCollectionApply(tagCollection1, (CMTagCollectionApplierFunction)_CMTagCollectionExcludeApplier, &context);
    v10 = v15;
    if ((_DWORD)v15)
      goto LABEL_18;
    context = tagCollection2;
    v13 = tagCollection1;
    LODWORD(v15) = 0;
    CMTagCollectionApply(tagCollection2, (CMTagCollectionApplierFunction)_CMTagCollectionExcludeApplier, &context);
    v10 = v15;
  }
  if (!v10)
  {
    v10 = 0;
    *tagCollectionOut = (CMTagCollectionRef)cf;
    return v10;
  }
LABEL_18:
  if (cf)
    CFRelease(cf);
  return v10;
}

uint64_t _CMTagCollectionExcludeApplier(CMTag tag, uint64_t a2)
{
  CMTagValue value;
  uint64_t v4;
  const OpaqueCMTagCollection *v5;
  CMTag v7;
  CMTag v8;

  if (!*(_DWORD *)(a2 + 24))
  {
    value = tag.value;
    v4 = *(_QWORD *)&tag.category;
    v5 = *(const OpaqueCMTagCollection **)(a2 + 8);
    *(_QWORD *)&v7.category = v4;
    v7.value = value;
    if (CMTagCollectionContainsTag(v5, v7))
    {
      *(_QWORD *)&tag.category = 0;
    }
    else
    {
      *(_QWORD *)&v8.category = v4;
      v8.value = value;
      *(_QWORD *)&tag.category = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)(a2 + 16), v8);
    }
    if (!*(_DWORD *)(a2 + 24))
      *(_DWORD *)(a2 + 24) = tag.category;
  }
  return *(_QWORD *)&tag.category;
}

OSStatus CMTagCollectionAddTag(CMMutableTagCollectionRef tagCollection, CMTag tagToAdd)
{
  CMTagValue value;
  uint64_t v3;
  CFTypeID v5;
  CMTag v7;

  if (!tagCollection)
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  value = tagToAdd.value;
  v3 = *(_QWORD *)&tagToAdd.category;
  v5 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v5 != sCMTagCollectionID || (*((_BYTE *)tagCollection + 20) & 1) == 0)
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  _CMTagCollectionEnsureTagArraySpace((uint64_t)tagCollection, *((_QWORD *)tagCollection + 4) + 1, 0);
  *(_QWORD *)&v7.category = v3;
  v7.value = value;
  _CMTagCollectionAddTagAvoidingDuplicates((uint64_t)tagCollection, v7);
  return 0;
}

void _CMTagCollectionEnsureTagArraySpace(uint64_t a1, int64_t count, int a3)
{
  unsigned int v5;
  void *v6;
  __int128 *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;

  v5 = *(unsigned __int8 *)(a1 + 20);
  if (*(_QWORD *)(a1 + 48) >= count)
  {
    if (count <= 15 && a3 && ((v5 >> 1) & 1) == 0)
    {
      v7 = *(__int128 **)(a1 + 56);
      v8 = v7[3];
      v10 = *v7;
      v9 = v7[1];
      *(_OWORD *)(a1 + 96) = v7[2];
      *(_OWORD *)(a1 + 112) = v8;
      *(_OWORD *)(a1 + 64) = v10;
      *(_OWORD *)(a1 + 80) = v9;
      v11 = v7[7];
      v13 = v7[4];
      v12 = v7[5];
      *(_OWORD *)(a1 + 160) = v7[6];
      *(_OWORD *)(a1 + 176) = v11;
      *(_OWORD *)(a1 + 128) = v13;
      *(_OWORD *)(a1 + 144) = v12;
      v14 = v7[11];
      v16 = v7[8];
      v15 = v7[9];
      *(_OWORD *)(a1 + 224) = v7[10];
      *(_OWORD *)(a1 + 240) = v14;
      *(_OWORD *)(a1 + 192) = v16;
      *(_OWORD *)(a1 + 208) = v15;
      v17 = v7[15];
      v19 = v7[12];
      v18 = v7[13];
      *(_OWORD *)(a1 + 288) = v7[14];
      *(_OWORD *)(a1 + 304) = v17;
      *(_OWORD *)(a1 + 256) = v19;
      *(_OWORD *)(a1 + 272) = v18;
      free(v7);
      *(_QWORD *)(a1 + 48) = 0;
      *(_QWORD *)(a1 + 56) = a1 + 64;
      *(_DWORD *)(a1 + 20) |= 2u;
    }
  }
  else if ((v5 & 2) != 0)
  {
    v20 = malloc_type_calloc(count, 0x10uLL, 0x1000040451B5BE8uLL);
    *(_QWORD *)(a1 + 56) = v20;
    *(_DWORD *)(a1 + 20) &= ~2u;
    v21 = *(_OWORD *)(a1 + 256);
    v22 = *(_OWORD *)(a1 + 272);
    v23 = *(_OWORD *)(a1 + 304);
    v20[14] = *(_OWORD *)(a1 + 288);
    v20[15] = v23;
    v20[12] = v21;
    v20[13] = v22;
    v24 = *(_OWORD *)(a1 + 192);
    v25 = *(_OWORD *)(a1 + 208);
    v26 = *(_OWORD *)(a1 + 240);
    v20[10] = *(_OWORD *)(a1 + 224);
    v20[11] = v26;
    v20[8] = v24;
    v20[9] = v25;
    v27 = *(_OWORD *)(a1 + 128);
    v28 = *(_OWORD *)(a1 + 144);
    v29 = *(_OWORD *)(a1 + 176);
    v20[6] = *(_OWORD *)(a1 + 160);
    v20[7] = v29;
    v20[4] = v27;
    v20[5] = v28;
    v30 = *(_OWORD *)(a1 + 64);
    v31 = *(_OWORD *)(a1 + 80);
    v32 = *(_OWORD *)(a1 + 112);
    v20[2] = *(_OWORD *)(a1 + 96);
    v20[3] = v32;
    *v20 = v30;
    v20[1] = v31;
    *(_QWORD *)(a1 + 48) = count;
  }
  else
  {
    v6 = malloc_type_realloc(*(void **)(a1 + 56), 16 * count, 0x1000040451B5BE8uLL);
    *(_QWORD *)(a1 + 48) = count;
    *(_QWORD *)(a1 + 56) = v6;
  }
  if (*(_QWORD *)(a1 + 32) > count)
    *(_QWORD *)(a1 + 32) = count;
}

uint64_t _CMTagCollectionAddTagAvoidingDuplicates(uint64_t a1, CMTag a2)
{
  CMTagValue value;
  uint64_t v3;
  uint64_t result;
  uint64_t v6;
  _QWORD *v7;
  char v8;
  uint64_t v9;

  value = a2.value;
  v3 = *(_QWORD *)&a2.category;
  v9 = -1;
  v8 = 0;
  result = _CMTagCollectionFindTag(a1, a2, &v9, &v8);
  if (!(_DWORD)result)
  {
    v6 = v9;
    if (!v8)
      result = (uint64_t)memmove((void *)(*(_QWORD *)(a1 + 56) + 16 * v9 + 16), (const void *)(*(_QWORD *)(a1 + 56) + 16 * v9), 16 * (*(_QWORD *)(a1 + 32) - v9));
    v7 = (_QWORD *)(*(_QWORD *)(a1 + 56) + 16 * v6);
    *v7 = v3;
    v7[1] = value;
    ++*(_QWORD *)(a1 + 32);
  }
  return result;
}

OSStatus CMTagCollectionRemoveTag(CMMutableTagCollectionRef tagCollection, CMTag tagToRemove)
{
  CMTagValue value;
  uint64_t v3;
  CFTypeID v5;
  uint64_t v6;
  OSStatus result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CMTag *v11;
  char v12;
  uint64_t v13;
  CMTag v14;

  if (!tagCollection)
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  value = tagToRemove.value;
  v3 = *(_QWORD *)&tagToRemove.category;
  v5 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v5 != sCMTagCollectionID || (*((_BYTE *)tagCollection + 20) & 1) == 0)
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  v6 = *((_QWORD *)tagCollection + 4);
  if (v6 < 0)
    return 0;
  if (!v6)
    return -15746;
  v13 = -1;
  v12 = 0;
  *(_QWORD *)&v14.category = v3;
  v14.value = value;
  if (!_CMTagCollectionFindTag((uint64_t)tagCollection, v14, &v13, &v12))
    return -15746;
  if (v12)
    return 0;
  v8 = v13;
  v9 = *((_QWORD *)tagCollection + 4) - (v13 + 1);
  v10 = *((_QWORD *)tagCollection + 7);
  v11 = (CMTag *)(v10 + 16 * v13);
  if (v9 >= 1)
  {
    memmove((void *)(v10 + 16 * v13), (const void *)(v10 + 16 * (v13 + 1)), 16 * v9);
    v11 = (CMTag *)(*((_QWORD *)tagCollection + 7) + 16 * (v9 + v8));
  }
  result = 0;
  *v11 = kCMTagInvalid;
  --*((_QWORD *)tagCollection + 4);
  return result;
}

OSStatus CMTagCollectionRemoveAllTags(CMMutableTagCollectionRef tagCollection)
{
  CFTypeID v2;

  if (!tagCollection)
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  v2 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v2 != sCMTagCollectionID || (*((_BYTE *)tagCollection + 20) & 1) == 0)
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  _CMTagCollectionEnsureTagArraySpace((uint64_t)tagCollection, 0, 1);
  return 0;
}

OSStatus CMTagCollectionRemoveAllTagsOfCategory(CMMutableTagCollectionRef tagCollection, CMTagCategory category)
{
  CFTypeID v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  _DWORD *v9;

  if (!tagCollection)
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  v4 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v4 != sCMTagCollectionID || (*((_BYTE *)tagCollection + 20) & 1) == 0)
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  v5 = *((_QWORD *)tagCollection + 4);
  if (v5)
  {
    if (v5 >= 1)
    {
      v6 = 0;
      v7 = 16 * v5 - 16;
      do
      {
        v8 = v7 - 16 * v6;
        v9 = (_DWORD *)(*((_QWORD *)tagCollection + 7) + 16 * v6);
        while (*v9 != category)
        {
          ++v6;
          v8 -= 16;
          v9 += 4;
          if (v6 >= v5)
            goto LABEL_16;
        }
        if (~v6 + v5 >= 1)
          memmove(v9, v9 + 4, v8);
        --v5;
        v7 -= 16;
      }
      while (v6 < v5);
    }
LABEL_16:
    *((_QWORD *)tagCollection + 4) = v5;
  }
  return 0;
}

uint64_t FigTagCollectionAddTagsFromCollection(uint64_t a1, CMTagCollectionRef tagCollection)
{
  uint64_t v3;
  uint64_t v4;

  v3 = a1;
  v4 = 0;
  CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionAddTagsFromCollectionApplier, &v3);
  return v4;
}

OSStatus CMTagCollectionAddTagsFromCollection(CMMutableTagCollectionRef tagCollection, CMTagCollectionRef collectionWithTagsToAdd)
{
  CMMutableTagCollectionRef v3;
  uint64_t v4;

  v3 = tagCollection;
  v4 = 0;
  CMTagCollectionApply(collectionWithTagsToAdd, (CMTagCollectionApplierFunction)_CMTagCollectionAddTagsFromCollectionApplier, &v3);
  return v4;
}

uint64_t _CMTagCollectionAddTagsFromCollectionApplier(CMTag tagToAdd, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 8))
  {
    *(_QWORD *)&tagToAdd.category = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)a2, tagToAdd);
    if (!*(_DWORD *)(a2 + 8))
      *(_DWORD *)(a2 + 8) = tagToAdd.category;
  }
  return *(_QWORD *)&tagToAdd.category;
}

uint64_t FigTagCollectionAddTagsFromCollectionWithFilterFunction(uint64_t a1, CMTagCollectionRef tagCollection, uint64_t a3, uint64_t a4)
{
  _QWORD v5[4];

  v5[0] = 0;
  v5[1] = a1;
  v5[2] = a3;
  v5[3] = a4;
  if (!a3)
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionAddTagsFromCollectionWithFilterFunctionApplier, v5);
  return LODWORD(v5[0]);
}

uint64_t _CMTagCollectionAddTagsFromCollectionWithFilterFunctionApplier(uint64_t result, CMTagValue a2, uint64_t a3)
{
  uint64_t v5;
  CMTag v6;

  if (!*(_DWORD *)a3)
  {
    v5 = result;
    result = (*(uint64_t (**)(uint64_t, CMTagValue, _QWORD))(a3 + 16))(result, a2, *(_QWORD *)(a3 + 24));
    if ((_DWORD)result)
    {
      *(_QWORD *)&v6.category = v5;
      v6.value = a2;
      result = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)(a3 + 8), v6);
      *(_DWORD *)a3 = result;
    }
  }
  return result;
}

OSStatus CMTagCollectionAddTagsFromArray(CMMutableTagCollectionRef tagCollection, CMTag *tags, CMItemCount tagCount)
{
  CFTypeID v6;
  CMTagValue *i;
  OSStatus result;

  if (!tagCollection)
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  v6 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v6 != sCMTagCollectionID || (*((_BYTE *)tagCollection + 20) & 1) == 0 || !tags)
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  if (tagCount < 1)
    return 0;
  for (i = &tags->value; ; i += 2)
  {
    result = CMTagCollectionAddTag(tagCollection, *(CMTag *)(i - 1));
    if (result)
      break;
    if (!--tagCount)
      return 0;
  }
  return result;
}

OSStatus CMTagCollectionCopyTagsOfCategories(CFAllocatorRef allocator, CMTagCollectionRef tagCollection, const CMTagCategory *categories, CMItemCount categoriesCount, CMTagCollectionRef *collectionWithTagsOfCategories)
{
  CFTypeID v10;
  OSStatus Common;
  CFTypeRef v12;
  _QWORD context[3];
  uint64_t v15;
  CFTypeRef cf;

  cf = 0;
  if (!tagCollection)
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  v10 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v10 != sCMTagCollectionID || !categories || categoriesCount <= 0 || !collectionWithTagsOfCategories)
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  Common = _CMTagCollectionCreateCommon(1, (uint64_t)allocator, 0, 0, 0, 0, (uint64_t *)&cf);
  v12 = cf;
  if (Common
    || (context[2] = cf,
        v15 = 0,
        context[0] = categories,
        context[1] = categoriesCount,
        CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionAddTagsOfCategoriesFromCollectionApplier, context), Common = v15, v12 = cf, (_DWORD)v15))
  {
    if (v12)
      CFRelease(v12);
  }
  else
  {
    *collectionWithTagsOfCategories = (CMTagCollectionRef)cf;
  }
  return Common;
}

uint64_t _CMTagCollectionAddTagsOfCategoriesFromCollectionApplier(CMTag tagToAdd, uint64_t a2)
{
  uint64_t v3;
  CMTagValue value;
  uint64_t v5;
  uint64_t i;
  CMTag v8;

  if (!*(_DWORD *)(a2 + 24))
  {
    v3 = *(_QWORD *)(a2 + 8);
    if (v3 < 1)
    {
      *(_QWORD *)&tagToAdd.category = 0;
LABEL_12:
      *(_DWORD *)(a2 + 24) = tagToAdd.category;
      return *(_QWORD *)&tagToAdd.category;
    }
    value = tagToAdd.value;
    v5 = *(_QWORD *)&tagToAdd.category;
    for (i = 0; i < v3; ++i)
    {
      if (*(_DWORD *)(*(_QWORD *)a2 + 4 * i) == (_DWORD)v5)
      {
        *(_QWORD *)&v8.category = v5;
        v8.value = value;
        *(_QWORD *)&tagToAdd.category = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)(a2 + 16), v8);
        if (tagToAdd.category)
          goto LABEL_9;
        v3 = *(_QWORD *)(a2 + 8);
      }
    }
    *(_QWORD *)&tagToAdd.category = 0;
LABEL_9:
    if (!*(_DWORD *)(a2 + 24))
      goto LABEL_12;
  }
  return *(_QWORD *)&tagToAdd.category;
}

CFDictionaryRef CMTagCollectionCopyAsDictionary(CMTagCollectionRef tagCollection, CFAllocatorRef allocator)
{
  CFTypeID v4;
  const __CFDictionary *Mutable;
  CFMutableArrayRef v6;
  CFMutableArrayRef v7;
  _QWORD context[2];
  uint64_t v10;

  if (!tagCollection)
    goto LABEL_10;
  v4 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v4 != sCMTagCollectionID)
  {
LABEL_10:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  Mutable = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
  {
    FigSignalErrorAt(4294951555, 0, 0, 0, 0, 0, 0);
    return Mutable;
  }
  v6 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
  if (!v6)
  {
    FigSignalErrorAt(4294951555, 0, 0, 0, 0, 0, 0);
LABEL_14:
    CFRelease(Mutable);
    return 0;
  }
  v7 = v6;
  context[1] = allocator;
  v10 = 0;
  context[0] = v6;
  CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionCopyAsDictionaryApplier, context);
  if ((_DWORD)v10)
  {
    CFRelease(v7);
    goto LABEL_14;
  }
  CFDictionaryAddValue(Mutable, CFSTR("tags"), v7);
  CFRelease(v7);
  return Mutable;
}

uint64_t _CMTagCollectionCopyAsDictionaryApplier(CMTag a1, uint64_t a2)
{
  CFDictionaryRef v3;
  CFDictionaryRef v4;

  if (!*(_DWORD *)(a2 + 16))
  {
    v3 = CMTagCopyAsDictionary(a1, *(CFAllocatorRef *)(a2 + 8));
    if (v3)
    {
      v4 = v3;
      CFArrayAppendValue(*(CFMutableArrayRef *)a2, v3);
      CFRelease(v4);
      *(_QWORD *)&a1.category = 0;
    }
    else
    {
      *(_QWORD *)&a1.category = FigSignalErrorAt(4294951555, 0, 0, 0, 0, 0, 0);
    }
    if (!*(_DWORD *)(a2 + 16))
      *(_DWORD *)(a2 + 16) = a1.category;
  }
  return *(_QWORD *)&a1.category;
}

OSStatus CMTagCollectionCreateFromDictionary(CFDictionaryRef dict, CFAllocatorRef allocator, CMTagCollectionRef *newCollectionOut)
{
  CFTypeID v6;
  OSStatus Common;
  const __CFArray *Value;
  uint64_t v9;
  OSStatus v10;
  CFTypeRef v12;
  uint64_t v13;
  CFTypeRef cf;

  cf = 0;
  if (dict && (v6 = CFGetTypeID(dict), v6 == CFDictionaryGetTypeID()) && newCollectionOut)
  {
    Common = _CMTagCollectionCreateCommon(1, (uint64_t)allocator, 0, 0, 0, 0, (uint64_t *)&cf);
    if (Common)
      goto LABEL_12;
    Value = (const __CFArray *)CFDictionaryGetValue(dict, CFSTR("tags"));
    if (Value)
    {
      v12 = cf;
      v13 = 0;
      FigCFArrayApplyFunction(Value, (void (__cdecl *)(const void *, void *))_CMTagCollectionMakeFromDictionaryApplier, &v12);
      v9 = v13;
      if (!(_DWORD)v13)
      {
        v10 = 0;
        *newCollectionOut = (CMTagCollectionRef)cf;
        return v10;
      }
    }
    else
    {
      v9 = 4294951552;
    }
  }
  else
  {
    v9 = 4294951556;
  }
  Common = FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
LABEL_12:
  v10 = Common;
  if (cf)
    CFRelease(cf);
  return v10;
}

uint64_t _CMTagCollectionMakeFromDictionaryApplier(uint64_t cf, uint64_t a2)
{
  const __CFDictionary *v3;
  CFTypeID v4;
  CMTag v5;
  uint64_t v6;

  if (!*(_DWORD *)(a2 + 8))
  {
    v3 = (const __CFDictionary *)cf;
    if (cf && (v4 = CFGetTypeID((CFTypeRef)cf), v4 == CFDictionaryGetTypeID()))
    {
      v5 = CMTagMakeFromDictionary(v3);
      if (HIDWORD(*(_QWORD *)&v5.category))
      {
        cf = CMTagCollectionAddTag(*(CMMutableTagCollectionRef *)a2, v5);
        goto LABEL_6;
      }
      v6 = 4294951553;
    }
    else
    {
      v6 = 4294951556;
    }
    cf = FigSignalErrorAt(v6, 0, 0, 0, 0, 0, 0);
LABEL_6:
    if (!*(_DWORD *)(a2 + 8))
      *(_DWORD *)(a2 + 8) = cf;
  }
  return cf;
}

xpc_object_t FigTagCollectionCopyAsXPCDictionary(const void *a1)
{
  CFTypeID v2;
  xpc_object_t empty;
  xpc_object_t v4;
  void *v5;
  void *v6;
  _QWORD context[2];
  uint64_t v9;

  if (!a1)
    goto LABEL_11;
  v2 = CFGetTypeID(a1);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v2 != sCMTagCollectionID)
  {
LABEL_11:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    v5 = 0;
    v6 = 0;
LABEL_15:
    empty = 0;
    goto LABEL_10;
  }
  empty = xpc_dictionary_create_empty();
  if (!empty)
  {
    FigSignalErrorAt(4294951555, 0, 0, 0, 0, 0, 0);
    v5 = 0;
    goto LABEL_9;
  }
  v4 = xpc_array_create_empty();
  v5 = v4;
  if (!v4)
  {
    FigSignalErrorAt(4294951555, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  context[1] = 0;
  v9 = 0;
  context[0] = v4;
  CMTagCollectionApply((CMTagCollectionRef)a1, (CMTagCollectionApplierFunction)_CMTagCollectionCopyAsXPCDictionaryApplier, context);
  if ((_DWORD)v9)
  {
LABEL_14:
    v6 = empty;
    goto LABEL_15;
  }
  xpc_dictionary_set_value(empty, (const char *)kCMTagCollection_TagsArrayKey, v5);
LABEL_9:
  v6 = 0;
LABEL_10:
  FigXPCRelease(v5);
  FigXPCRelease(v6);
  return empty;
}

unint64_t _CMTagCollectionCopyAsXPCDictionaryApplier(unint64_t result, uint64_t a2, uint64_t a3)
{
  void *v4;
  void *v5;

  if (!*(_DWORD *)(a3 + 8))
  {
    v4 = FigTagCopyAsXPCDictionary(result, a2);
    if (v4)
    {
      v5 = v4;
      xpc_array_append_value(*(xpc_object_t *)a3, v4);
      xpc_release(v5);
      result = 0;
    }
    else
    {
      result = FigSignalErrorAt(4294951555, 0, 0, 0, 0, 0, 0);
    }
    if (!*(_DWORD *)(a3 + 8))
      *(_DWORD *)(a3 + 8) = result;
  }
  return result;
}

uint64_t FigTagCollectionCreateFromXPCDictionary(void *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t Common;
  xpc_object_t value;
  void *v7;
  OpaqueCMTagCollection *v8;
  size_t v9;
  xpc_object_t v10;
  uint64_t v11;
  CMTagValue v12;
  uint64_t v13;
  uint64_t v15;
  CFTypeRef cf;
  CMTag v17;

  cf = 0;
  if (!a1)
    return FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
  if (!a3)
  {
    v15 = 4294951556;
LABEL_16:
    Common = FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
LABEL_17:
    v13 = Common;
    if (cf)
      CFRelease(cf);
    return v13;
  }
  Common = _CMTagCollectionCreateCommon(1, a2, 0, 0, 0, 0, (uint64_t *)&cf);
  if ((_DWORD)Common)
    goto LABEL_17;
  value = xpc_dictionary_get_value(a1, (const char *)kCMTagCollection_TagsArrayKey);
  if (!value)
  {
    v15 = 4294951552;
    goto LABEL_16;
  }
  v7 = value;
  v8 = (OpaqueCMTagCollection *)cf;
  if (xpc_array_get_count(value))
  {
    v9 = 0;
    while (1)
    {
      v10 = xpc_array_get_value(v7, v9);
      v11 = FigTagMakeFromXPCDictionary(v10);
      if (!HIDWORD(v11))
        break;
      v17.value = v12;
      *(_QWORD *)&v17.category = v11;
      Common = CMTagCollectionAddTag(v8, v17);
      if ((_DWORD)Common)
        goto LABEL_17;
      if (++v9 >= xpc_array_get_count(v7))
        goto LABEL_10;
    }
    Common = FigSignalErrorAt(4294951554, 0, 0, 0, 0, 0, 0);
    if ((_DWORD)Common)
      goto LABEL_17;
  }
LABEL_10:
  v13 = 0;
  *a3 = cf;
  return v13;
}

CFDataRef CMTagCollectionCopyAsData(CMTagCollectionRef tagCollection, CFAllocatorRef allocator)
{
  CFTypeID v4;
  const __CFData *v5;
  void *v6;
  size_t DataLength;
  _OWORD *context;
  uint64_t v10;
  unsigned int v11;
  int v12;
  _OWORD v13[3];
  uint64_t v14;
  _OWORD v15[3];
  uint64_t v16;
  CMBlockBufferRef blockBufferOut;

  blockBufferOut = 0;
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  v14 = 0;
  memset(v13, 0, sizeof(v13));
  v12 = 0;
  if (!tagCollection)
    goto LABEL_17;
  v4 = CFGetTypeID(tagCollection);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v4 != sCMTagCollectionID)
  {
LABEL_17:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
LABEL_18:
    v5 = 0;
    v6 = 0;
    goto LABEL_14;
  }
  if (CMBlockBufferCreateEmpty(allocator, 4u, 0, &blockBufferOut))
    goto LABEL_18;
  if (FigAtomWriterInitWithBlockBuffer(blockBufferOut, (uint64_t)v15))
    goto LABEL_18;
  FigAtomWriterBeginAtom((uint64_t)v15, 0x7467636Fu, 0);
  if (FigAtomWriterInitWithParent((uint64_t)v15, (uint64_t)v13))
    goto LABEL_18;
  FigAtomWriterBeginAtom((uint64_t)v13, 0x7467696Eu, 0);
  FigAtomWriterAppendVersionAndFlags((uint64_t)v13, 0, 0);
  v12 = 543646068;
  FigAtomWriterAppendData((uint64_t)v13, (uint64_t)&v12, 4);
  v12 = 1819045731;
  FigAtomWriterAppendData((uint64_t)v13, (uint64_t)&v12, 4);
  FigAtomWriterEndAtom((uint64_t)v13);
  FigAtomWriterBeginAtom((uint64_t)v13, 0x74676C69u, 0);
  FigAtomWriterAppendVersionAndFlags((uint64_t)v13, 0, 0);
  v11 = bswap32(*((_DWORD *)tagCollection + 8));
  FigAtomWriterAppendData((uint64_t)v13, (uint64_t)&v11, 4);
  if (*((uint64_t *)tagCollection + 4) >= 1)
  {
    context = v13;
    v10 = 0;
    CMTagCollectionApply(tagCollection, (CMTagCollectionApplierFunction)_CMTagCollectionCopyAsDataApplier, &context);
    v5 = 0;
    v6 = 0;
    if ((_DWORD)v10)
      goto LABEL_14;
  }
  FigAtomWriterEndAtom((uint64_t)v13);
  FigAtomWriterEndAtom((uint64_t)v15);
  DataLength = CMBlockBufferGetDataLength(blockBufferOut);
  v6 = malloc_type_malloc(DataLength, 0xF217AC60uLL);
  if (!v6)
  {
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    goto LABEL_20;
  }
  if (CMBlockBufferCopyDataBytes(blockBufferOut, 0, DataLength, v6))
  {
LABEL_20:
    v5 = 0;
    goto LABEL_14;
  }
  v5 = CFDataCreate(allocator, (const UInt8 *)v6, DataLength);
  if (!v5)
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
LABEL_14:
  if (blockBufferOut)
    CFRelease(blockBufferOut);
  free(v6);
  return v5;
}

uint64_t _CMTagCollectionCopyAsDataApplier(uint64_t result, unint64_t a2, uint64_t a3)
{
  unsigned int v4;
  unsigned int v5;
  unint64_t v6;

  if (!*(_DWORD *)(a3 + 8))
  {
    v4 = bswap32(result);
    v5 = bswap32(HIDWORD(result));
    v6 = bswap64(a2);
    result = FigAtomWriterAppendData(*(_QWORD *)a3, (uint64_t)&v4, 4);
    if (!(_DWORD)result)
    {
      result = FigAtomWriterAppendData(*(_QWORD *)a3, (uint64_t)&v5, 4);
      if (!(_DWORD)result)
        result = FigAtomWriterAppendData(*(_QWORD *)a3, (uint64_t)&v6, 8);
    }
    if (!*(_DWORD *)(a3 + 8))
      *(_DWORD *)(a3 + 8) = result;
  }
  return result;
}

OSStatus CMTagCollectionCreateFromData(CFDataRef data, CFAllocatorRef allocator, CMTagCollectionRef *newCollectionOut)
{
  CFTypeID v6;
  OSStatus Common;
  size_t Length;
  OSStatus v9;
  CFTypeRef cf;
  _OWORD v12[7];
  const OpaqueCMTagCollection *v13;

  v13 = 0;
  memset(v12, 0, sizeof(v12));
  cf = 0;
  if (!data)
    goto LABEL_15;
  v6 = CFGetTypeID(data);
  if (v6 != CFDataGetTypeID() || !newCollectionOut)
    goto LABEL_15;
  Common = _CMTagCollectionCreateCommon(1, (uint64_t)allocator, 0, 0, 0, 0, (uint64_t *)&v13);
  if (Common)
  {
LABEL_16:
    v9 = Common;
    goto LABEL_10;
  }
  Length = CFDataGetLength(data);
  if (Length <= 7)
  {
LABEL_15:
    Common = FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  Common = FigCreateBlockBufferWithCFDataNoCopy(allocator, data, 0, Length, (CMBlockBufferRef *)&cf);
  if (Common)
    goto LABEL_16;
  Common = FigAtomStreamInitWithBBuf((OpaqueCMBlockBuffer *)cf, 0, 0, (uint64_t)v12);
  if (Common)
    goto LABEL_16;
  v9 = ParseTagCollectionDataChildAtoms(v12, (uint64_t)"ocgt", 1, (uint64_t)v13);
  if (!v9)
  {
    *newCollectionOut = v13;
    v13 = 0;
  }
LABEL_10:
  if (cf)
    CFRelease(cf);
  if (v13)
    CFRelease(v13);
  return v9;
}

uint64_t ProcessTagCollectionContainerAtom(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _OWORD v5[7];
  int v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v6, 0);
  if (!(_DWORD)result)
  {
    result = FigAtomStreamInitWithParent(a1, 0, (uint64_t)v5);
    if (!(_DWORD)result)
      return ParseTagCollectionDataChildAtoms(v5, (uint64_t)"nigt", 2, a2);
  }
  return result;
}

uint64_t ParseTagCollectionDataChildAtoms(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _DWORD *v7;
  uint64_t result;
  _DWORD *v9;
  uint64_t v10;
  int v11;

  v11 = 0;
  v7 = (_DWORD *)(a2 + 8);
  while (1)
  {
    result = FigAtomStreamGetCurrentAtomTypeAndDataLength((uint64_t)a1, &v11, 0);
    if ((_DWORD)result)
      return result;
    if (a3 >= 1)
    {
      v9 = v7;
      v10 = a3;
      while (v11 != *(v9 - 2))
      {
        v9 += 4;
        if (!--v10)
          goto LABEL_9;
      }
      result = (*(uint64_t (**)(_QWORD *, uint64_t))v9)(a1, a4);
      if ((_DWORD)result)
        return result;
    }
LABEL_9:
    LODWORD(result) = FigAtomStreamAdvanceToNextAtom(a1);
    if ((_DWORD)result)
    {
      if ((_DWORD)result == -12890)
        return 0;
      else
        return result;
    }
  }
}

double CMTagCollectionInit(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[18] = 0u;
  a1[19] = 0u;
  a1[16] = 0u;
  a1[17] = 0u;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

void CMTagCollectionFinalize(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 20) & 2) == 0)
    free(*(void **)(a1 + 56));
}

BOOL CMTagCollectionEqual(const void **cf, const void **a2)
{
  _BOOL8 result;
  CFTypeID v5;
  CFTypeID v6;
  const void *v7;

  if (cf == a2)
    return 1;
  result = 0;
  if (cf && a2)
  {
    v5 = CFGetTypeID(cf);
    if (sRegisterCMTagCollectionTypeOnce != -1)
      dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
    if (v5 != sCMTagCollectionID)
      goto LABEL_13;
    v6 = CFGetTypeID(a2);
    if (sRegisterCMTagCollectionTypeOnce != -1)
      dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
    if (v6 == sCMTagCollectionID)
    {
      v7 = cf[4];
      if (v7 == a2[4])
        return memcmp(cf[7], a2[7], 16 * (_QWORD)v7) == 0;
    }
    else
    {
LABEL_13:
      FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    }
    return 0;
  }
  return result;
}

unint64_t CMTagCollectionHash(_QWORD *a1)
{
  CFTypeID v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    goto LABEL_9;
  v2 = CFGetTypeID(a1);
  if (sRegisterCMTagCollectionTypeOnce != -1)
    dispatch_once_f(&sRegisterCMTagCollectionTypeOnce, 0, (dispatch_function_t)RegisterCMTagCollectionType);
  if (v2 == sCMTagCollectionID)
  {
    v3 = _CMTagCFHashBytes((uint64_t)(a1 + 2), 4);
    v4 = (_CMTagCFHashBytes((uint64_t)a1 + 20, 4) + (v3 << 6) + (v3 >> 2) + 2654435769u) ^ v3;
    v5 = (_CMTagCFHashBytes((uint64_t)(a1 + 3), 8) + (v4 << 6) + (v4 >> 2) + 2654435769u) ^ v4;
    if ((uint64_t)a1[4] >= 1)
    {
      v6 = 0;
      v7 = 0;
      do
      {
        v5 ^= (v5 << 6) + 2654435769u + (v5 >> 2) + CMTagHash(*(CMTag *)(a1[7] + v6));
        ++v7;
        v6 += 16;
      }
      while (v7 < a1[4]);
    }
  }
  else
  {
LABEL_9:
    FigSignalErrorAt(4294951556, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  return v5;
}

CFStringRef CMTagCollectionCopyFormattingDesc(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CMTagCollectionCopyDescription(v2, (CMTagCollectionRef)a1);
}

CFStringRef CMTagCollectionCopyDebugDesc(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CMTagCollectionCopyDescription(v2, (CMTagCollectionRef)a1);
}

uint64_t _CMTagCollectionFindTag(uint64_t a1, CMTag tag1, uint64_t *a3, char *a4)
{
  uint64_t v6;
  CMTagValue value;
  uint64_t v8;
  uint64_t v10;
  CFComparisonResult v11;
  uint64_t result;
  char v13;
  CMTag v14;

  v6 = *(_QWORD *)(a1 + 32);
  if (v6 < 1)
  {
    result = 0;
    v13 = 1;
  }
  else
  {
    value = tag1.value;
    v8 = *(_QWORD *)&tag1.category;
    v10 = 0;
    v6 = 0;
    while (1)
    {
      *(_QWORD *)&v14.category = v8;
      v14.value = value;
      v11 = CMTagCompare(v14, *(CMTag *)(*(_QWORD *)(a1 + 56) + v10));
      if (v11 == kCFCompareLessThan)
      {
        result = 0;
        v13 = 0;
        goto LABEL_10;
      }
      if (v11 == kCFCompareEqualTo)
        break;
      ++v6;
      v10 += 16;
      if (v6 >= *(_QWORD *)(a1 + 32))
      {
        result = 0;
        v13 = 1;
        v6 = *(_QWORD *)(a1 + 32);
        goto LABEL_10;
      }
    }
    v13 = 0;
    result = 1;
  }
LABEL_10:
  *a3 = v6;
  *a4 = v13;
  return result;
}

uint64_t ProcessTagCollectionInfoAtom(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  _QWORD v4[2];
  unsigned int v5;
  char v6;
  unint64_t v7;
  int v8;

  v8 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  LODWORD(v4[1]) = 0;
  v4[0] = 0;
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v8, &v7);
  if (!(_DWORD)result)
  {
    result = FigAtomStreamGetCurrentAtomVersionAndFlags(a1, &v6, &v5);
    if (!(_DWORD)result)
    {
      if (v6)
      {
        v3 = 4294951549;
      }
      else if (v7 < 0xC)
      {
        v3 = 4294951551;
      }
      else
      {
        result = FigAtomStreamReadCurrentAtomData(a1, 0, 12, (uint64_t)v4);
        if ((_DWORD)result)
          return result;
        v3 = 4294951551;
        if (*(_QWORD *)((char *)v4 + 4) == 0x6C6C6F6320676174)
          return 0;
      }
      return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
    }
  }
  return result;
}

uint64_t ProcessTagCollectionListAtom(uint64_t a1, OpaqueCMTagCollection *a2)
{
  uint64_t result;
  uint64_t v5;
  unsigned int i;
  uint64_t v7;
  int8x8_t v8;
  CMTagValue value;
  _QWORD v10[3];
  char v11;
  unint64_t v12;
  int v13;
  CMTag v14;

  v13 = 0;
  v12 = 0;
  v11 = 0;
  memset(v10, 0, sizeof(v10));
  result = FigAtomStreamGetCurrentAtomTypeAndDataLength(a1, &v13, &v12);
  if ((_DWORD)result)
    return result;
  result = FigAtomStreamGetCurrentAtomVersionAndFlags(a1, &v11, 0);
  if ((_DWORD)result)
    return result;
  if (v11)
  {
    v7 = 4294951549;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  if (v12 <= 7)
    goto LABEL_14;
  result = FigAtomStreamReadCurrentAtomData(a1, 0, 8, (uint64_t)v10);
  if ((_DWORD)result)
    return result;
  v5 = bswap32(HIDWORD(v10[0]));
  if (v12 != ((16 * v5) | 8))
  {
LABEL_14:
    v7 = 4294951551;
    return FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  }
  if (!HIDWORD(v10[0]))
    return 0;
  for (i = 8; ; i += 16)
  {
    v8 = 0;
    value = 0;
    result = FigAtomStreamReadCurrentAtomData(a1, i, 16, (uint64_t)&v8);
    if ((_DWORD)result)
      break;
    v8 = vrev32_s8(v8);
    *(int8x8_t *)&v14.category = v8;
    v14.value = bswap64(value);
    value = v14.value;
    result = CMTagCollectionAddTag(a2, v14);
    if ((_DWORD)result)
      break;
    if (!--v5)
      return 0;
  }
  return result;
}

uint64_t FigApplicationStateMonitorGetClassID()
{
  if (sRegisterFigApplicationStateMonitorClassIDOnce != -1)
    dispatch_once_f(&sRegisterFigApplicationStateMonitorClassIDOnce, 0, (dispatch_function_t)RegisterFigApplicationStateMonitorType);
  return sFigApplicationStateMonitorClassID;
}

uint64_t RegisterFigApplicationStateMonitorType()
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&sFigApplicationStateMonitorClassDesc, ClassID, 1, &sFigApplicationStateMonitorClassID);
}

uint64_t FigApplicationStateMonitorGetTypeID()
{
  if (sRegisterFigApplicationStateMonitorClassIDOnce != -1)
    dispatch_once_f(&sRegisterFigApplicationStateMonitorClassIDOnce, 0, (dispatch_function_t)RegisterFigApplicationStateMonitorType);
  return CMBaseClassGetCFTypeID((_QWORD *)sFigApplicationStateMonitorClassID);
}

uint64_t FigApplicationStateMonitorCopyProcessNameIfAvailable(uint64_t a1, CFStringRef *a2)
{
  uint64_t result;
  void *v5;
  void *v6;
  const __CFAllocator *AllocatorForMedia;
  CFStringRef Copy;
  CFStringRef v9;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v11;
  uint64_t v12;
  unsigned int v13;
  char *v14;
  uint64_t v15;
  os_log_type_t type;
  int v17[2];
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  CFStringRef v22;
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce != -1)
    dispatch_once(&fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce, &__block_literal_global_35);
  result = fasm_ensureInternalState_sFigApplicationStateMonitorInitResult;
  if (!fasm_ensureInternalState_sFigApplicationStateMonitorInitResult)
  {
    if ((int)a1 > 0 && a2)
    {
      v5 = (void *)objc_msgSend(MEMORY[0x1E0D87D60], "handleForIdentifier:error:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a1), 0);
      if (v5)
      {
        v6 = v5;
        result = objc_msgSend(v5, "name");
        if (!result)
          return result;
        AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
        Copy = CFStringCreateCopy(AllocatorForMedia, (CFStringRef)objc_msgSend(v6, "name"));
        if (Copy)
        {
          v9 = Copy;
          if (dword_1EE141F68 >= 2)
          {
            v17[0] = 0;
            type = OS_LOG_TYPE_DEFAULT;
            os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F60, 1, v17, &type);
            v11 = v17[0];
            if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
              v13 = v11;
            else
              v13 = v11 & 0xFFFFFFFE;
            if (v13)
            {
              v17[1] = 136315650;
              v18 = "FigApplicationStateMonitorCopyProcessNameIfAvailable";
              v19 = 1024;
              v20 = a1;
              v21 = 2112;
              v22 = v9;
              v14 = (char *)_os_log_send_and_compose_impl();
              LOBYTE(v11) = v17[0];
            }
            else
            {
              v14 = 0;
            }
            fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F60, 1u, 1, v14, v14 != &v23, v11, 0, v12);
          }
          result = 0;
          *a2 = v9;
          return result;
        }
      }
      v15 = 4294947865;
    }
    else
    {
      v15 = 4294947866;
    }
    return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
  return result;
}

uint64_t FigApplicationStateMonitorGetHostPIDIfAvailable(uint64_t a1, int *a2)
{
  uint64_t v4;
  const void *v5;
  int v6;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v8;
  uint64_t v9;
  unsigned int v10;
  char *v11;
  os_log_type_t type;
  int v14;
  uint64_t v15;
  int v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  char v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce != -1)
    dispatch_once(&fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce, &__block_literal_global_35);
  v4 = fasm_ensureInternalState_sFigApplicationStateMonitorInitResult;
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInitResult)
    return v4;
  if ((int)a1 > 0 && a2)
  {
    FigSimpleMutexLock((pthread_mutex_t *)gApplicationMonitorsMutex);
    v4 = fasm_ensureApplicationStateMonitor(a1, (void **)&v15);
    v5 = (const void *)v15;
    if ((_DWORD)v4 || !v15)
    {
      if (!v15)
        goto LABEL_21;
    }
    else
    {
      v4 = 0;
      v6 = *(_DWORD *)(CMBaseObjectGetDerivedStorage(v15) + 24);
      *a2 = v6;
      if (v6 != (_DWORD)a1 && v6 >= 1 && dword_1EE141F68)
      {
        v14 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F60, 1, &v14, &type);
        v8 = v14;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
          v10 = v8;
        else
          v10 = v8 & 0xFFFFFFFE;
        if (v10)
        {
          v16 = 136315650;
          v17 = "FigApplicationStateMonitorGetHostPIDIfAvailable";
          v18 = 1024;
          v19 = a1;
          v20 = 1024;
          v21 = v6;
          v11 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v8) = v14;
        }
        else
        {
          v11 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F60, 1u, 1, v11, v11 != &v22, v8, 0, v9);
        v4 = 0;
      }
    }
    CFRelease(v5);
LABEL_21:
    FigSimpleMutexUnlock((pthread_mutex_t *)gApplicationMonitorsMutex);
    return v4;
  }
  return FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
}

uint64_t fasm_ensureApplicationStateMonitor(uint64_t a1, void **a2)
{
  unsigned int v4;
  const __CFAllocator *AllocatorForMedia;
  CFNumberRef UInt32;
  CFNumberRef v7;
  const void *v8;
  void *v9;
  void *v10;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v12;
  uint64_t v13;
  unsigned int v14;
  NSObject *v15;
  unsigned int v16;
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t DerivedStorage;
  void *v21;
  void *v22;
  int v23;
  uint64_t *v24;
  _BOOL8 v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  void *v30;
  void *v31;
  NSObject *v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  NSObject *v37;
  int v38;
  uint64_t v39;
  unsigned int v40;
  _BYTE *v41;
  os_log_type_t type;
  int v43;
  _QWORD v44[6];
  CFArrayCallBacks callBacks;
  void *value;
  int v47;
  const char *v48;
  __int16 v49;
  void *v50;
  _BYTE v51[128];
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&callBacks.version = xmmword_1E28DF8A0;
  *(_OWORD *)&callBacks.release = *(_OWORD *)&off_1E28DF8B0;
  callBacks.equal = 0;
  v4 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigApplicationStateMonitorTrace[1], CFSTR("figapplicationstatemonitor_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v4, 0, gFigApplicationStateMonitorTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&dword_1EE141F68, CFSTR("figapplicationstatemonitor_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &qword_1EE141F60);
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  UInt32 = FigCFNumberCreateUInt32(AllocatorForMedia, a1);
  if (!UInt32)
    return FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
  v7 = UInt32;
  v8 = CFDictionaryGetValue((CFDictionaryRef)gApplicationMonitors, UInt32);
  if (v8)
  {
    v9 = (void *)CFRetain(v8);
    value = v9;
    if (v9)
    {
      if (dword_1EE141F68)
      {
        v10 = v9;
        v43 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F60, 1, &v43, &type);
        v12 = v43;
        if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
          v14 = v12;
        else
          v14 = v12 & 0xFFFFFFFE;
        if (v14)
        {
          v47 = 136315394;
          v48 = "fasm_ensureApplicationStateMonitor";
          v49 = 2112;
          v50 = v10;
LABEL_18:
          v17 = (_BYTE *)_os_log_send_and_compose_impl();
          LOBYTE(v12) = v43;
LABEL_26:
          v24 = (uint64_t *)qword_1EE141F60;
          v25 = v17 != v51;
          v26 = v12;
LABEL_39:
          fig_log_call_emit_and_clean_up_after_send_and_compose(v24, 1u, 1, v17, v25, v26, 0, v13);
          goto LABEL_40;
        }
        goto LABEL_25;
      }
      goto LABEL_40;
    }
  }
  else
  {
    value = 0;
  }
  if (CFSetContainsValue((CFSetRef)gExcludedPIDs, v7))
  {
    if (dword_1EE141F68)
    {
      v43 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v15 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F60, 1, &v43, &type);
      v12 = v43;
      if (os_log_type_enabled(v15, type))
        v16 = v12;
      else
        v16 = v12 & 0xFFFFFFFE;
      if (v16)
      {
        v47 = 136315394;
        v48 = "fasm_ensureApplicationStateMonitor";
        v49 = 1024;
        LODWORD(v50) = a1;
        goto LABEL_18;
      }
LABEL_25:
      v17 = 0;
      goto LABEL_26;
    }
  }
  else
  {
    v18 = FigGetAllocatorForMedia();
    if (sRegisterFigApplicationStateMonitorClassIDOnce != -1)
      dispatch_once_f(&sRegisterFigApplicationStateMonitorClassIDOnce, 0, (dispatch_function_t)RegisterFigApplicationStateMonitorType);
    v19 = CMDerivedObjectCreate(v18, (uint64_t)&kFigApplicationStateMonitor_VTable, (_QWORD *)sFigApplicationStateMonitorClassID, &value);
    if ((_DWORD)v19)
    {
      v35 = v19;
      goto LABEL_41;
    }
    DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)value);
    *(_DWORD *)DerivedStorage = a1;
    *(_QWORD *)(DerivedStorage + 16) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &callBacks);
    v21 = (void *)objc_msgSend(MEMORY[0x1E0D87D60], "handleForIdentifier:error:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a1), 0);
    if (!v21)
      goto LABEL_45;
    v22 = (void *)objc_msgSend(v21, "hostProcess");
    v23 = v22 ? objc_msgSend(v22, "pid") : 0;
    v27 = objc_msgSend(MEMORY[0x1E0D87DA8], "predicateMatchingIdentifier:", objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", a1));
    if (!v27)
      goto LABEL_45;
    v28 = v27;
    v29 = (void *)objc_msgSend(MEMORY[0x1E0D87DC8], "descriptor");
    if (!v29)
      goto LABEL_45;
    v30 = v29;
    objc_msgSend(v29, "setEndowmentNamespaces:", &unk_1E28FD8B8);
    v44[0] = MEMORY[0x1E0C809B0];
    v44[1] = 3221225472;
    v44[2] = __fasm_ensureApplicationStateMonitor_block_invoke;
    v44[3] = &unk_1E28DF928;
    v44[4] = v30;
    v44[5] = v28;
    v31 = (void *)objc_msgSend(MEMORY[0x1E0D87D98], "monitorWithConfiguration:", v44);
    if (!v31)
    {
LABEL_45:
      v35 = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
      CFSetAddValue((CFMutableSetRef)gExcludedPIDs, v7);
      if (dword_1EE141F68 >= 2)
      {
        v43 = 0;
        type = OS_LOG_TYPE_DEFAULT;
        v37 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F60, 1, &v43, &type);
        v38 = v43;
        if (os_log_type_enabled(v37, type))
          v40 = v38;
        else
          v40 = v38 & 0xFFFFFFFE;
        if (v40)
        {
          v47 = 136315394;
          v48 = "fasm_ensureApplicationStateMonitor";
          v49 = 1024;
          LODWORD(v50) = a1;
          v41 = (_BYTE *)_os_log_send_and_compose_impl();
          LOBYTE(v38) = v43;
        }
        else
        {
          v41 = 0;
        }
        fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F60, 1u, 1, v41, v41 != v51, v38, 0, v39);
      }
      goto LABEL_41;
    }
    *(_QWORD *)(DerivedStorage + 8) = v31;
    *(_DWORD *)(DerivedStorage + 24) = v23;
    CFDictionarySetValue((CFMutableDictionaryRef)gApplicationMonitors, v7, value);
    if (dword_1EE141F68)
    {
      v43 = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v32 = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F60, 1, &v43, &type);
      v33 = v43;
      if (os_log_type_enabled(v32, type))
        v34 = v33;
      else
        v34 = v33 & 0xFFFFFFFE;
      if (v34)
      {
        v47 = 136315394;
        v48 = "fasm_ensureApplicationStateMonitor";
        v49 = 2112;
        v50 = value;
        v17 = (_BYTE *)_os_log_send_and_compose_impl();
        LOBYTE(v33) = v43;
      }
      else
      {
        v17 = 0;
      }
      v24 = (uint64_t *)qword_1EE141F60;
      v25 = v17 != v51;
      v26 = v33;
      goto LABEL_39;
    }
  }
LABEL_40:
  v35 = 0;
  *a2 = value;
  value = 0;
LABEL_41:
  CFRelease(v7);
  if (value)
    CFRelease(value);
  return v35;
}

uint64_t FigApplicationStateMonitorAddPIDToIgnore(signed int a1)
{
  uint64_t v2;
  const __CFAllocator *AllocatorForMedia;
  CFNumberRef UInt32;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v6;
  uint64_t v7;
  unsigned int v8;
  char *v9;
  os_log_type_t type;
  int v12[2];
  const char *v13;
  __int16 v14;
  signed int v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce != -1)
    dispatch_once(&fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce, &__block_literal_global_35);
  v2 = fasm_ensureInternalState_sFigApplicationStateMonitorInitResult;
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInitResult)
    goto LABEL_19;
  if (a1 <= 0)
  {
    v2 = FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
LABEL_19:
    UInt32 = 0;
    goto LABEL_7;
  }
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  UInt32 = FigCFNumberCreateUInt32(AllocatorForMedia, a1);
  if (UInt32)
  {
    FigSimpleMutexLock((pthread_mutex_t *)gApplicationMonitorsMutex);
    CFSetAddValue((CFMutableSetRef)gExcludedPIDs, UInt32);
    FigSimpleMutexUnlock((pthread_mutex_t *)gApplicationMonitorsMutex);
    v2 = 0;
  }
  else
  {
    v2 = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
  }
LABEL_7:
  if (dword_1EE141F68 >= 2)
  {
    v12[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F60, 1, v12, &type);
    v6 = v12[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v8 = v6;
    else
      v8 = v6 & 0xFFFFFFFE;
    if (v8)
    {
      v12[1] = 136315394;
      v13 = "FigApplicationStateMonitorAddPIDToIgnore";
      v14 = 1024;
      v15 = a1;
      v9 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v6) = v12[0];
    }
    else
    {
      v9 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F60, 1u, 1, v9, v9 != &v16, v6, 0, v7);
  }
  if (UInt32)
    CFRelease(UInt32);
  return v2;
}

uint64_t FigApplicationStateMonitorRemovePIDToIgnore(signed int a1)
{
  uint64_t v2;
  const __CFAllocator *AllocatorForMedia;
  CFNumberRef UInt32;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v6;
  uint64_t v7;
  unsigned int v8;
  char *v9;
  os_log_type_t type;
  int v12[2];
  const char *v13;
  __int16 v14;
  signed int v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce != -1)
    dispatch_once(&fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce, &__block_literal_global_35);
  v2 = fasm_ensureInternalState_sFigApplicationStateMonitorInitResult;
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInitResult)
    goto LABEL_19;
  if (a1 <= 0)
  {
    v2 = FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
LABEL_19:
    UInt32 = 0;
    goto LABEL_7;
  }
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  UInt32 = FigCFNumberCreateUInt32(AllocatorForMedia, a1);
  if (UInt32)
  {
    FigSimpleMutexLock((pthread_mutex_t *)gApplicationMonitorsMutex);
    CFSetRemoveValue((CFMutableSetRef)gExcludedPIDs, UInt32);
    FigSimpleMutexUnlock((pthread_mutex_t *)gApplicationMonitorsMutex);
    v2 = 0;
  }
  else
  {
    v2 = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
  }
LABEL_7:
  if (dword_1EE141F68 >= 2)
  {
    v12[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F60, 1, v12, &type);
    v6 = v12[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v8 = v6;
    else
      v8 = v6 & 0xFFFFFFFE;
    if (v8)
    {
      v12[1] = 136315394;
      v13 = "FigApplicationStateMonitorRemovePIDToIgnore";
      v14 = 1024;
      v15 = a1;
      v9 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v6) = v12[0];
    }
    else
    {
      v9 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F60, 1u, 1, v9, v9 != &v16, v6, 0, v7);
  }
  if (UInt32)
    CFRelease(UInt32);
  return v2;
}

uint64_t FigApplicationStateMonitorAddCallbackClient(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  uint64_t DerivedStorage;
  CFTypeRef v10;
  CFTypeRef v11;
  _QWORD *v12;
  _QWORD *v13;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v15;
  uint64_t v16;
  unsigned int v17;
  char *v18;
  os_log_type_t type;
  int v21;
  uint64_t v22;
  int v23;
  const char *v24;
  __int16 v25;
  _QWORD *v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  int v30;
  char v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v22 = 0;
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce != -1)
    dispatch_once(&fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce, &__block_literal_global_35);
  v6 = fasm_ensureInternalState_sFigApplicationStateMonitorInitResult;
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInitResult)
    return v6;
  if ((int)a1 > 0 && a2 && a3)
  {
    FigSimpleMutexLock((pthread_mutex_t *)gApplicationMonitorsMutex);
    v7 = fasm_ensureApplicationStateMonitor(a1, (void **)&v22);
    v8 = (const void *)v22;
    if ((_DWORD)v7)
    {
      v6 = v7;
      if (!v22)
        goto LABEL_21;
    }
    else
    {
      if (!v22)
      {
        v6 = FigSignalErrorAt(4294947857, 0, 0, 0, 0, 0, 0);
        goto LABEL_21;
      }
      DerivedStorage = CMBaseObjectGetDerivedStorage(v22);
      v10 = FigCFWeakReferenceHolderCreateWithReferencedObject(a2);
      if (v10 && (v11 = v10, (v12 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL)) != 0))
      {
        v13 = v12;
        *v12 = v11;
        v12[1] = a3;
        CFArrayAppendValue(*(CFMutableArrayRef *)(DerivedStorage + 16), v12);
        if (dword_1EE141F68)
        {
          v21 = 0;
          type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F60, 1, &v21, &type);
          v15 = v21;
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
            v17 = v15;
          else
            v17 = v15 & 0xFFFFFFFE;
          if (v17)
          {
            v23 = 136315906;
            v24 = "FigApplicationStateMonitorAddCallbackClient";
            v25 = 2048;
            v26 = v13;
            v27 = 2112;
            v28 = a2;
            v29 = 1024;
            v30 = a1;
            v18 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v15) = v21;
          }
          else
          {
            v18 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F60, 1u, 1, v18, v18 != &v31, v15, 0, v16);
        }
        v6 = 0;
      }
      else
      {
        v6 = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
      }
    }
    CFRelease(v8);
LABEL_21:
    FigSimpleMutexUnlock((pthread_mutex_t *)gApplicationMonitorsMutex);
    return v6;
  }
  return FigSignalErrorAt(4294947866, 0, 0, 0, 0, 0, 0);
}

uint64_t FigApplicationStateMonitorRemoveCallbackClient(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  uint64_t DerivedStorage;
  CFIndex Count;
  unint64_t v9;
  id **ValueAtIndex;
  id *v11;
  uint64_t v13;
  uint64_t v14;

  v14 = 0;
  FigSimpleMutexLock((pthread_mutex_t *)gApplicationMonitorsMutex);
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce != -1)
    dispatch_once(&fasm_ensureInternalState_sFigApplicationStateMonitorInternalInitOnce, &__block_literal_global_35);
  v4 = fasm_ensureInternalState_sFigApplicationStateMonitorInitResult;
  if (fasm_ensureInternalState_sFigApplicationStateMonitorInitResult)
    return v4;
  if ((int)a1 > 0 && a2)
  {
    v5 = fasm_ensureApplicationStateMonitor(a1, (void **)&v14);
    v6 = (const void *)v14;
    if ((_DWORD)v5)
    {
      v4 = v5;
      if (!v14)
        return v4;
      goto LABEL_18;
    }
    if (v14)
    {
      DerivedStorage = CMBaseObjectGetDerivedStorage(v14);
      Count = CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 16));
      if (Count < 1)
      {
        v4 = 0;
      }
      else
      {
        v9 = Count + 1;
        do
        {
          ValueAtIndex = (id **)FigCFArrayGetValueAtIndex(*(const __CFArray **)(DerivedStorage + 16), v9 - 2);
          v11 = FigCFWeakReferenceHolderCopyReferencedObject(*ValueAtIndex);
          if (FigCFEqual(v11, a2))
            fasm_callbackClientFreeAndClearContext((const void **)ValueAtIndex);
          if (v11)
            CFRelease(v11);
          --v9;
        }
        while (v9 > 1);
        v4 = 0;
        if (!v6)
          return v4;
      }
LABEL_18:
      CFRelease(v6);
      return v4;
    }
    v13 = 4294947857;
  }
  else
  {
    v13 = 4294947866;
  }
  return FigSignalErrorAt(v13, 0, 0, 0, 0, 0, 0);
}

void fasm_callbackClientFreeAndClearContext(const void **a1)
{
  const void *v2;

  a1[1] = 0;
  v2 = *a1;
  if (v2)
    CFRelease(v2);
  free(a1);
}

CFStringRef FigApplicationStateMonitorCopyFormattingDesc(uint64_t a1)
{
  unsigned int *DerivedStorage;

  DerivedStorage = (unsigned int *)CMBaseObjectGetDerivedStorage(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigApplicationStateMonitor %p pid %d]"), a1, *DerivedStorage);
}

void __fasm_ensureInternalState_block_invoke()
{
  const __CFAllocator *AllocatorForPermanentAllocations;
  const __CFAllocator *v1;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v3;
  uint64_t v4;
  unsigned int v5;
  char *v6;
  os_log_type_t type;
  int v8[2];
  const char *v9;
  __int16 v10;
  int v11;
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  AllocatorForPermanentAllocations = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations();
  gApplicationMonitors = (uint64_t)CFDictionaryCreateMutable(AllocatorForPermanentAllocations, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!gApplicationMonitors
    || (gApplicationMonitorsMutex = (uint64_t)FigSimpleMutexCreate()) == 0
    || (v1 = (const __CFAllocator *)FigGetAllocatorForPermanentAllocations(),
        (gExcludedPIDs = (uint64_t)CFSetCreateMutable(v1, 0, MEMORY[0x1E0C9B3B0])) == 0))
  {
    fasm_ensureInternalState_sFigApplicationStateMonitorInitResult = FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
  }
  if (dword_1EE141F68)
  {
    v8[0] = 0;
    type = OS_LOG_TYPE_DEFAULT;
    os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F60, 1, v8, &type);
    v3 = v8[0];
    if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
      v5 = v3;
    else
      v5 = v3 & 0xFFFFFFFE;
    if (v5)
    {
      v8[1] = 136315394;
      v9 = "fasm_ensureInternalState_block_invoke";
      v10 = 1024;
      v11 = fasm_ensureInternalState_sFigApplicationStateMonitorInitResult;
      v6 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v3) = v8[0];
    }
    else
    {
      v6 = 0;
    }
    fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F60, 1u, 1, v6, v6 != &v12, v3, 0, v4);
  }
}

void fasm_callbackClientContextCFArrayReleaseCallback(int a1, const void **a2)
{
  fasm_callbackClientFreeAndClearContext(a2);
}

uint64_t __fasm_ensureApplicationStateMonitor_block_invoke(uint64_t a1, void *a2)
{
  _QWORD v5[2];

  v5[1] = *MEMORY[0x1E0C80C00];
  objc_msgSend(a2, "setStateDescriptor:", *(_QWORD *)(a1 + 32));
  v5[0] = *(_QWORD *)(a1 + 40);
  objc_msgSend(a2, "setPredicates:", objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v5, 1));
  return objc_msgSend(a2, "setUpdateHandler:", &__block_literal_global_27);
}

void __fasm_ensureApplicationStateMonitor_block_invoke_2(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  const __CFAllocator *AllocatorForMedia;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v15;
  const __CFAllocator *v16;
  CFNumberRef UInt32;
  CFNumberRef v18;
  const void *Value;
  const void *v20;
  uint64_t DerivedStorage;
  int v22;
  CFIndex v23;
  id **ValueAtIndex;
  id *v25;
  BOOL v26;
  id *v27;
  NSObject *os_log_and_send_and_compose_flags_and_os_log_type;
  int v29;
  uint64_t v30;
  unsigned int v31;
  char *v32;
  const __CFArray *v33;
  const __CFArray *v34;
  CFIndex v35;
  const void *v36;
  const void *v37;
  uint64_t v38;
  CFIndex Count;
  unint64_t v40;
  id **v41;
  id *v42;
  pthread_mutex_t *v43;
  unsigned int v44;
  unsigned int v45;
  os_log_type_t type;
  int v47[2];
  const char *v48;
  __int16 v49;
  const void *v50;
  __int16 v51;
  unsigned int v52;
  __int16 v53;
  unsigned int v54;
  char v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v6 = objc_msgSend(a3, "isDaemon");
  v7 = objc_msgSend((id)objc_msgSend((id)objc_msgSend(a4, "state"), "endowmentNamespaces"), "containsObject:", CFSTR("com.apple.frontboard.visibility"));
  v8 = objc_msgSend(a3, "pid");
  v9 = objc_msgSend((id)objc_msgSend(a4, "previousState"), "taskState");
  if (((v9 - 1) & 0xFC) != 0)
    v10 = 0;
  else
    v10 = (v9 - 1) + 1;
  switch(objc_msgSend((id)objc_msgSend(a4, "state"), "taskState"))
  {
    case 1u:
      v11 = 1;
      v12 = 1;
      break;
    case 2u:
      v11 = 0;
      v12 = 2;
      break;
    case 3u:
      v11 = 0;
      v12 = 3;
      break;
    case 4u:
      v11 = 0;
      v12 = 4;
      break;
    default:
      v11 = 0;
      v12 = 0;
      break;
  }
  AllocatorForMedia = (const __CFAllocator *)FigGetAllocatorForMedia();
  Mutable = CFDictionaryCreateMutable(AllocatorForMedia, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v15 = Mutable;
    FigCFDictionarySetUInt32(Mutable, CFSTR("FigApplicationStateMonitorCallbackDictionary_pid"), v8);
    FigCFDictionarySetUInt32(v15, CFSTR("FigApplicationStateMonitorCallbackDictionary_currentSchedulerStatus"), v12);
    FigCFDictionarySetUInt32(v15, CFSTR("FigApplicationStateMonitorCallbackDictionary_previousSchedulerStatus"), v10);
    FigCFDictionarySetBoolean(v15, CFSTR("FigApplicationStateMonitorCallbackDictionary_isDaemon"), v6);
    FigCFDictionarySetBoolean(v15, CFSTR("FigApplicationStateMonitorCallbackDictionary_isVisible"), v7);
    v16 = (const __CFAllocator *)FigGetAllocatorForMedia();
    UInt32 = FigCFNumberCreateUInt32(v16, v8);
    if (UInt32)
    {
      v18 = UInt32;
      v45 = v12;
      FigSimpleMutexLock((pthread_mutex_t *)gApplicationMonitorsMutex);
      Value = CFDictionaryGetValue((CFDictionaryRef)gApplicationMonitors, v18);
      if (Value)
      {
        v20 = Value;
        v44 = v10;
        DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)Value);
        if (CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 16)) < 1)
        {
          v22 = 0;
        }
        else
        {
          v22 = 0;
          v23 = 0;
          do
          {
            ValueAtIndex = (id **)FigCFArrayGetValueAtIndex(*(const __CFArray **)(DerivedStorage + 16), v23);
            v25 = FigCFWeakReferenceHolderCopyReferencedObject(*ValueAtIndex);
            if (v25)
              v26 = 0;
            else
              v26 = v22 == 0;
            if (v26)
            {
              v22 = 1;
            }
            else
            {
              v27 = v25;
              ((void (*)(void))ValueAtIndex[1])();
              if (v27)
                CFRelease(v27);
            }
            ++v23;
          }
          while (v23 < CFArrayGetCount(*(CFArrayRef *)(DerivedStorage + 16)));
        }
        if (dword_1EE141F68)
        {
          v47[0] = 0;
          type = OS_LOG_TYPE_DEFAULT;
          os_log_and_send_and_compose_flags_and_os_log_type = fig_log_emitter_get_os_log_and_send_and_compose_flags_and_os_log_type((uint64_t *)qword_1EE141F60, 1, v47, &type);
          v29 = v47[0];
          if (os_log_type_enabled(os_log_and_send_and_compose_flags_and_os_log_type, type))
            v31 = v29;
          else
            v31 = v29 & 0xFFFFFFFE;
          if (v31)
          {
            v47[1] = 136315906;
            v48 = "fasm_updateHandler";
            v49 = 2112;
            v50 = v20;
            v51 = 1024;
            v52 = v45;
            v53 = 1024;
            v54 = v44;
            v32 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v29) = v47[0];
          }
          else
          {
            v32 = 0;
          }
          fig_log_call_emit_and_clean_up_after_send_and_compose((uint64_t *)qword_1EE141F60, 1u, 1, v32, v32 != &v55, v29, 0, v30);
        }
        if (v11)
          CFDictionaryRemoveValue((CFMutableDictionaryRef)gApplicationMonitors, v18);
        if (v22)
        {
          v33 = FigCFDictionaryCopyArrayOfKeys((const void *)gApplicationMonitors);
          if (v33)
          {
            v34 = v33;
            if (CFArrayGetCount(v33) >= 1)
            {
              v35 = 0;
              do
              {
                v36 = CFArrayGetValueAtIndex(v34, v35);
                v37 = CFDictionaryGetValue((CFDictionaryRef)gApplicationMonitors, v36);
                v38 = CMBaseObjectGetDerivedStorage((uint64_t)v37);
                Count = CFArrayGetCount(*(CFArrayRef *)(v38 + 16));
                if (Count >= 1)
                {
                  v40 = Count + 1;
                  do
                  {
                    v41 = (id **)CFArrayGetValueAtIndex(*(CFArrayRef *)(v38 + 16), v40 - 2);
                    v42 = FigCFWeakReferenceHolderCopyReferencedObject(*v41);
                    if (v42)
                    {
                      CFRelease(v42);
                    }
                    else
                    {
                      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v38 + 16), v40 - 2);
                      fasm_callbackClientFreeAndClearContext((const void **)v41);
                    }
                    --v40;
                  }
                  while (v40 > 1);
                }
                ++v35;
              }
              while (v35 < CFArrayGetCount(v34));
            }
            CFRelease(v34);
          }
          else
          {
            FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
          }
        }
        v43 = (pthread_mutex_t *)gApplicationMonitorsMutex;
      }
      else
      {
        FigSignalErrorAt(4294947858, 0, 0, 0, 0, 0, 0);
        v43 = (pthread_mutex_t *)gApplicationMonitorsMutex;
      }
      FigSimpleMutexUnlock(v43);
      CFRelease(v18);
    }
    else
    {
      FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
    }
    CFRelease(v15);
  }
  else
  {
    FigSignalErrorAt(4294947865, 0, 0, 0, 0, 0, 0);
  }
}

void fasm_finalize(uint64_t a1)
{
  uint64_t DerivedStorage;
  const void *v2;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  *(_DWORD *)DerivedStorage = 0;
  objc_msgSend(*(id *)(DerivedStorage + 8), "invalidate");

  v2 = *(const void **)(DerivedStorage + 16);
  if (v2)
    CFRelease(v2);
}

CFStringRef fasm_copyDebugDescription(uint64_t a1)
{
  unsigned int *DerivedStorage;
  uint64_t v3;
  const __CFAllocator *v4;
  uint64_t v5;

  DerivedStorage = (unsigned int *)CMBaseObjectGetDerivedStorage(a1);
  v3 = DerivedStorage[6];
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v5 = *DerivedStorage;
  if ((int)v3 < 1)
    return CFStringCreateWithFormat(v4, 0, CFSTR("[FigApplicationStateMonitor %p pid %d]"), a1, v5);
  else
    return CFStringCreateWithFormat(v4, 0, CFSTR("[FigApplicationStateMonitor %p pid %d hostPID %d]"), a1, v5, v3);
}

uint64_t FigScheduledIOFRSCreateForByteStream(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  uint64_t SchedulerCopyForByteStream;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *DerivedStorage;
  unint64_t v11;
  CFTypeRef cf;
  CFTypeRef v13;

  cf = 0;
  v13 = 0;
  v11 = 0;
  if (!a2 || !a3)
  {
    SchedulerCopyForByteStream = FigSignalErrorAt(4294948015, 0, 0, 0, 0, 0, 0);
LABEL_13:
    v8 = SchedulerCopyForByteStream;
    goto LABEL_7;
  }
  SchedulerCopyForByteStream = FigReadSchedulerCopyForByteStream((uint64_t)a2, (uint64_t *)&cf);
  if ((_DWORD)SchedulerCopyForByteStream)
    goto LABEL_13;
  SchedulerCopyForByteStream = FigReadSchedulerGetNewClientID((uint64_t)cf, &v11);
  if ((_DWORD)SchedulerCopyForByteStream)
    goto LABEL_13;
  v7 = (_QWORD *)FigScheduledIOGetClassID();
  v8 = CMDerivedObjectCreate(a1, (uint64_t)&kFigScheduledIOFRSVTable, v7, &v13);
  if (!(_DWORD)v8)
  {
    DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)v13);
    *DerivedStorage = FigSimpleMutexCreate();
    DerivedStorage[3] = v11;
    DerivedStorage[1] = CFRetain(a2);
    DerivedStorage[2] = CFRetain(cf);
    *a3 = v13;
    v13 = 0;
  }
LABEL_7:
  if (cf)
    CFRelease(cf);
  if (v13)
    CFRelease(v13);
  return v8;
}

const __CFAllocator *figSchedIOFRS_Finalize(uint64_t a1)
{
  uint64_t *DerivedStorage;
  dispatch_queue_t *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  DerivedStorage = (uint64_t *)CMBaseObjectGetDerivedStorage(a1);
  v2 = (dispatch_queue_t *)DerivedStorage[2];
  if (v2)
  {
    FigReadSchedulerCancelAllClientRequests(v2, DerivedStorage[3], 0);
    v3 = (const void *)DerivedStorage[4];
    if (v3)
    {
      CFRelease(v3);
      DerivedStorage[4] = 0;
    }
    v4 = (const void *)DerivedStorage[2];
    if (v4)
    {
      CFRelease(v4);
      DerivedStorage[2] = 0;
    }
  }
  v5 = (const void *)DerivedStorage[1];
  if (v5)
  {
    CFRelease(v5);
    DerivedStorage[1] = 0;
  }
  return FigSimpleMutexDestroy(*DerivedStorage);
}

__CFString *figSchedIOFRS_CopyDebugDescription(const void *a1)
{
  _QWORD *DerivedStorage;
  __CFString *Mutable;
  CFIndex v4;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  Mutable = CFStringCreateMutable(0, 0);
  v4 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("FigSchedIOFRS %p(%d): BS=%@ clientID=%lld RS: %@"), a1, v4, DerivedStorage[1], DerivedStorage[3], DerivedStorage[2]);
  if (DerivedStorage[4])
    CFStringAppendFormat(Mutable, 0, CFSTR(" PrerollBatch: %@"), DerivedStorage[4]);
  return Mutable;
}

uint64_t figSchedIOFRS_CopyProperty(uint64_t a1, const void *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t DerivedStorage;
  uint64_t CMBaseObject;
  uint64_t (*v9)(uint64_t, const __CFString *, uint64_t, _QWORD);
  uint64_t result;
  uint64_t (*v11)(uint64_t, const __CFString *, uint64_t, _QWORD);

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v11 = 0;
  if (CFEqual(a2, CFSTR("ScheduledIO_ReadStats")))
  {
    CMBaseObject = CMByteStreamGetCMBaseObject(*(_QWORD *)(DerivedStorage + 8));
    v9 = *(uint64_t (**)(uint64_t, const __CFString *, uint64_t, _QWORD))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                            + 8)
                                                                                + 48);
    if (v9)
    {
      result = v9(CMBaseObject, CFSTR("FBS_ReadStats"), a3, &v11);
      v9 = v11;
    }
    else
    {
      result = 4294954514;
    }
  }
  else
  {
    v9 = 0;
    result = 4294954512;
  }
  *a4 = v9;
  return result;
}

uint64_t figSchedIOFRS_GetEOF(uint64_t a1, _QWORD *a2)
{
  uint64_t DerivedStorage;
  uint64_t CMBaseObject;
  uint64_t (*v5)(uint64_t, const __CFString *, _QWORD, CFNumberRef *);
  uint64_t v6;
  CFNumberRef v7;
  CFNumberRef number;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  number = 0;
  *a2 = 0;
  CMBaseObject = CMByteStreamGetCMBaseObject(*(_QWORD *)(DerivedStorage + 8));
  v5 = *(uint64_t (**)(uint64_t, const __CFString *, _QWORD, CFNumberRef *))(*(_QWORD *)(CMBaseObjectGetVTable(CMBaseObject)
                                                                                                + 8)
                                                                                    + 48);
  if (!v5)
    return 4294954514;
  v6 = v5(CMBaseObject, CFSTR("FBS_EntireLength"), *MEMORY[0x1E0C9AE00], &number);
  v7 = number;
  if (!(_DWORD)v6)
  {
    CFNumberGetValue(number, kCFNumberSInt64Type, a2);
    v7 = number;
  }
  if (v7)
    CFRelease(v7);
  return v6;
}

uint64_t figSchedIOFRS_RequestRead(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, _QWORD *a10)
{
  uint64_t DerivedStorage;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  dispatch_queue_t *v22;
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  uint64_t Batch;
  void *v28;
  uint64_t v29;
  uint64_t v30;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v30 = 0;
  if ((a9 & 0xC) != 0 && a9 < 0)
  {
    Batch = FigSignalErrorAt(4294948015, 0, 0, 0, 0, 0, 0);
    v28 = 0;
    goto LABEL_18;
  }
  v19 = DerivedStorage;
  v29 = a2;
  v20 = malloc_type_calloc(1uLL, 0x18uLL, 0x80040D6874129uLL);
  v28 = v20;
  if (!v20)
  {
    v25 = FigSignalErrorAt(4294948016, 0, 0, 0, 0, 0, 0);
    goto LABEL_20;
  }
  *v20 = a5;
  v20[1] = a6;
  v20[2] = a7;
  if ((a9 & 0xC) == 0)
  {
    v22 = *(dispatch_queue_t **)(v19 + 16);
    v23 = *(_QWORD *)(v19 + 24);
    v24 = *(const void **)(v19 + 8);
    if ((a9 & 0x80) == 0)
    {
      v25 = FigReadSchedulerRequestReadWithDeadline(v22, v23, v24, v29, a3, a4, 0, a8, (uint64_t)figSchedIOFRS_Callback, (uint64_t)v28, 0, &v30);
      if ((_DWORD)v25)
        goto LABEL_20;
LABEL_17:
      Batch = 0;
      v28 = 0;
      *a10 = v30;
      goto LABEL_18;
    }
    v25 = FigReadSchedulerRequestBackgroundRead(v22, v23, v24, v29, a3, a4, 0, (uint64_t)figSchedIOFRS_Callback, (uint64_t)v28, 0, &v30);
    if (!(_DWORD)v25)
      goto LABEL_17;
LABEL_20:
    Batch = v25;
    goto LABEL_18;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)v19);
  v21 = *(_QWORD *)(v19 + 32);
  if (v21
    || (Batch = FigReadSchedulerCreateBatch(*(void **)(v19 + 16), (_QWORD *)(v19 + 32)),
        (v21 = *(_QWORD *)(v19 + 32)) != 0))
  {
    Batch = FigReadSchedulerBatchAddReadWithDeadline(v21, *(_QWORD *)(v19 + 24), *(const void **)(v19 + 8), v29, a3, a4, 0, a8, (uint64_t)figSchedIOFRS_Callback, (uint64_t)v28, 0, &v30);
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)v19);
  if (!(_DWORD)Batch)
    goto LABEL_17;
LABEL_18:
  free(v28);
  return Batch;
}

uint64_t figSchedIOFRS_Finish(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t DerivedStorage;
  uint64_t v6;
  int v7;
  uint64_t v9;
  dispatch_queue_t *v10;
  uint64_t v11;
  int v12;
  uint64_t SchedulerCancelAllClientRequests;
  uint64_t v14;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v6 = DerivedStorage;
  if (a3 == 5)
  {
    v7 = 0;
    return figSchedIOFRS_FinishPreroll(DerivedStorage, v7);
  }
  if (a3 == 4)
  {
    v7 = 1;
    return figSchedIOFRS_FinishPreroll(DerivedStorage, v7);
  }
  if (a2)
  {
    switch(a3)
    {
      case 2:
        return FigReadSchedulerCancelRequest(*(dispatch_queue_t **)(DerivedStorage + 16), a2);
      case 1:
        v9 = 4294954514;
        return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
      case 0:
        return FigReadSchedulerExpediteRequest(*(dispatch_queue_t **)(DerivedStorage + 16), a2, 1);
    }
LABEL_15:
    v9 = 4294948015;
    return FigSignalErrorAt(v9, 0, 0, 0, 0, 0, 0);
  }
  switch(a3)
  {
    case 2:
      v10 = *(dispatch_queue_t **)(DerivedStorage + 16);
      v11 = *(_QWORD *)(v6 + 24);
      v12 = 0;
      break;
    case 1:
      v10 = *(dispatch_queue_t **)(DerivedStorage + 16);
      v11 = *(_QWORD *)(v6 + 24);
      v12 = 1;
      break;
    case 0:
      return FigReadSchedulerExpediteAllClientRequests(*(dispatch_queue_t **)(DerivedStorage + 16), *(_QWORD *)(DerivedStorage + 24), 1);
    default:
      goto LABEL_15;
  }
  SchedulerCancelAllClientRequests = FigReadSchedulerCancelAllClientRequests(v10, v11, v12);
  v14 = *(_QWORD *)(v6 + 32);
  if (v14)
    FigReadSchedulerBatchCancel(v14);
  return SchedulerCancelAllClientRequests;
}

uint64_t figSchedIOFRS_ExpediteAllClientRequests(uint64_t a1)
{
  uint64_t DerivedStorage;

  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  return FigReadSchedulerExpediteAllClientRequests(*(dispatch_queue_t **)(DerivedStorage + 16), *(_QWORD *)(DerivedStorage + 24), 0);
}

uint64_t figSchedIOFRS_GetAvailableLengthAtOffset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t);

  v5 = *(_QWORD *)(CMBaseObjectGetDerivedStorage(a1) + 8);
  v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(CMBaseObjectGetVTable(v5) + 16) + 24);
  if (v6)
    return v6(v5, a2, a3);
  else
    return 4294954514;
}

uint64_t figSchedIOFRS_CreateBatch(const void *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t DerivedStorage;
  _QWORD *ClassID;
  uint64_t Batch;
  CFTypeRef v9;
  uint64_t v10;
  unint64_t *v11;
  __CFNotificationCenter *DefaultLocalCenter;
  CFTypeRef cf;

  cf = 0;
  if (a3 && a1)
  {
    DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
    ClassID = (_QWORD *)FigScheduledIOBatchGetClassID();
    Batch = CMDerivedObjectCreate(a2, (uint64_t)&kFigScheduledIOBatchFRSVTable, ClassID, &cf);
    v9 = cf;
    if (!(_DWORD)Batch)
    {
      v10 = CMBaseObjectGetDerivedStorage((uint64_t)cf);
      *(_QWORD *)v10 = a1;
      CFRetain(a1);
      *(_BYTE *)(v10 + 16) = 0;
      v11 = (unint64_t *)(v10 + 8);
      Batch = FigReadSchedulerCreateBatch(*(void **)(DerivedStorage + 16), (_QWORD *)(v10 + 8));
      if (!(_DWORD)Batch)
      {
        DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
        FigNotificationCenterAddWeakListener(DefaultLocalCenter, (void *)cf, (CFNotificationCallback)figSchedIOBatchFRS_completionCallback, CFSTR("readSchedulerNotification_BatchCompleted"), *v11, 0, 0);
        *a3 = cf;
        return Batch;
      }
      v9 = cf;
    }
    if (v9)
      CFRelease(v9);
    return Batch;
  }
  return FigSignalErrorAt(4294948015, 0, 0, 0, 0, 0, 0);
}

void figSchedIOFRS_Callback(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  uint64_t v8;

  if (a6 == -17785)
    v8 = 4294948013;
  else
    v8 = a6;
  ((void (*)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t))*a2)(a2[1], a2[2], a4, a5, v8);
  free(a2);
}

uint64_t figSchedIOFRS_FinishPreroll(uint64_t a1, int a2)
{
  const void *v4;
  uint64_t SchedulerBatchExpedite;
  uint64_t SchedulerBatchAwaitCompletion;
  _QWORD v8[2];
  uint64_t v9;

  v9 = 0;
  FigSimpleMutexLock(*(pthread_mutex_t **)a1);
  v4 = *(const void **)(a1 + 32);
  *(_QWORD *)(a1 + 32) = 0;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)a1);
  if (!v4)
    return 0;
  SchedulerBatchExpedite = FigReadSchedulerBatchExpedite((uint64_t)v4);
  SchedulerBatchAwaitCompletion = SchedulerBatchExpedite;
  if (a2)
  {
    if (!(_DWORD)SchedulerBatchExpedite)
    {
      v8[0] = v4;
      v8[1] = 0;
      FigThreadRegisterAbortAction((uint64_t (*)())figSchedIOFRSWaitForCompletionAbort, (_opaque_pthread_t *)v8, &v9);
      SchedulerBatchAwaitCompletion = FigReadSchedulerBatchAwaitCompletion((uint64_t)v4);
      if (v9)
        FigThreadUnregisterAbortAction(v9);
    }
  }
  CFRelease(v4);
  return SchedulerBatchAwaitCompletion;
}

uint64_t figSchedIOFRSWaitForCompletionAbort(uint64_t a1)
{
  uint64_t result;

  result = FigReadSchedulerBatchCancel(*(_QWORD *)a1);
  *(_DWORD *)(a1 + 8) = -19283;
  return result;
}

uint64_t figSchedIOBatchFRS_completionCallback(uint64_t a1, const void *a2)
{
  __CFNotificationCenter *DefaultLocalCenter;

  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  return CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("scheduledIOBatchNotification_BatchCompleted"), a2, 0);
}

void figSchedIOBatchFRS_Finalize(const void *a1)
{
  uint64_t DerivedStorage;
  __CFNotificationCenter *DefaultLocalCenter;
  uint64_t v4;
  const void *v5;

  DerivedStorage = CMBaseObjectGetDerivedStorage((uint64_t)a1);
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  FigNotificationCenterRemoveWeakListener(DefaultLocalCenter, a1, (uint64_t)figSchedIOBatchFRS_completionCallback, CFSTR("readSchedulerNotification_BatchCompleted"), *(const void **)(DerivedStorage + 8));
  if (!*(_BYTE *)(DerivedStorage + 16))
  {
    v4 = *(_QWORD *)(DerivedStorage + 8);
    if (!v4)
      goto LABEL_6;
    FigReadSchedulerBatchCancel(v4);
  }
  v5 = *(const void **)(DerivedStorage + 8);
  if (v5)
    CFRelease(v5);
LABEL_6:
  if (*(_QWORD *)DerivedStorage)
    CFRelease(*(CFTypeRef *)DerivedStorage);
}

__CFString *figSchedIOBatchFRS_CopyDebugDescription(const void *a1)
{
  _QWORD *DerivedStorage;
  __CFString *Mutable;
  CFIndex v4;

  DerivedStorage = (_QWORD *)CMBaseObjectGetDerivedStorage((uint64_t)a1);
  Mutable = CFStringCreateMutable(0, 0);
  v4 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("FigSchedIOBatchFRS %p(%d): scheduledIO=%@, schedulerBatch=%@"), a1, v4, *DerivedStorage, DerivedStorage[1]);
  return Mutable;
}

uint64_t figSchedIOBatchFRS_AddRead(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, _QWORD *a10)
{
  uint64_t DerivedStorage;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  uint64_t v29;

  v29 = 0;
  if (!a1)
  {
    v28 = 4294948015;
LABEL_12:
    v26 = FigSignalErrorAt(v28, 0, 0, 0, 0, 0, 0);
    v21 = 0;
    goto LABEL_9;
  }
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  v18 = CMBaseObjectGetDerivedStorage(*(_QWORD *)DerivedStorage);
  if (*(_BYTE *)(DerivedStorage + 16))
  {
    v28 = 4294948014;
    goto LABEL_12;
  }
  v19 = v18;
  v20 = malloc_type_calloc(1uLL, 0x18uLL, 0x80040D6874129uLL);
  v21 = v20;
  if (!v20)
  {
    v25 = FigSignalErrorAt(4294948016, 0, 0, 0, 0, 0, 0);
    goto LABEL_14;
  }
  *v20 = a5;
  v20[1] = a6;
  v20[2] = a7;
  v22 = *(_QWORD *)(DerivedStorage + 8);
  v23 = *(_QWORD *)(v19 + 24);
  v24 = *(const void **)(v19 + 8);
  if ((a9 & 0x80) == 0)
  {
    v25 = FigReadSchedulerBatchAddReadWithDeadline(v22, v23, v24, a2, a3, a4, 0, a8, (uint64_t)figSchedIOFRS_Callback, (uint64_t)v21, 0, &v29);
    if ((_DWORD)v25)
      goto LABEL_14;
    goto LABEL_8;
  }
  v25 = FigReadSchedulerBatchAddBackgroundRead(v22, v23, v24, a2, a3, a4, 0, (uint64_t)figSchedIOFRS_Callback, (uint64_t)v21, 0, &v29);
  if ((_DWORD)v25)
  {
LABEL_14:
    v26 = v25;
    goto LABEL_9;
  }
LABEL_8:
  v26 = 0;
  v21 = 0;
  *a10 = v29;
LABEL_9:
  free(v21);
  return v26;
}

uint64_t figSchedIOBatchFRS_Commit(uint64_t a1)
{
  uint64_t DerivedStorage;
  uint64_t v2;
  uint64_t result;
  uint64_t v4;

  if (!a1)
  {
    v4 = 4294948015;
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  if (*(_BYTE *)(DerivedStorage + 16))
  {
    v4 = 4294948014;
    return FigSignalErrorAt(v4, 0, 0, 0, 0, 0, 0);
  }
  v2 = DerivedStorage;
  result = FigReadSchedulerBatchCommit(*(_QWORD *)(DerivedStorage + 8));
  if (!(_DWORD)result)
    *(_BYTE *)(v2 + 16) = 1;
  return result;
}

uint64_t figSchedIOBatchFRS_Cancel(uint64_t a1)
{
  uint64_t DerivedStorage;

  if (!a1)
    return FigSignalErrorAt(4294948015, 0, 0, 0, 0, 0, 0);
  DerivedStorage = CMBaseObjectGetDerivedStorage(a1);
  return FigReadSchedulerBatchCancel(*(_QWORD *)(DerivedStorage + 8));
}

uint64_t FigHEVCBridge_GetSPS_VUI_AspectRatio(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  int v9;
  _QWORD v10[3];
  __int128 v11;
  _OWORD v12[7];
  uint64_t v13;
  _OWORD v14[6];
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  memset(v14, 0, sizeof(v14));
  v13 = 0;
  memset(v12, 0, sizeof(v12));
  v11 = 0u;
  v9 = 0;
  v8 = 0;
  result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v14, a1, a2, 1);
  if (!(_DWORD)result)
  {
    LOBYTE(v12[0]) = 1;
    *(_QWORD *)((char *)v12 + 12) = 0;
    *(_QWORD *)((char *)v12 + 4) = 0xF80000000000;
    v10[0] = &v8;
    v10[1] = hevcbridgeGetSPS_VUI_AspectRatioCallbackFlag;
    v10[2] = hevcbridgeGetSPS_VUI_AspectRatioCallbackUnsigned;
    result = hevcbridgeParseNALUnit(v14, v10);
    if (!(_DWORD)result)
    {
      result = 4294954584;
      if ((_BYTE)v9)
      {
        if (BYTE1(v9))
        {
          result = 0;
          v7 = HIDWORD(v8);
          *a3 = v8;
          *a4 = v7;
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeSetupBitStreamFromPointerAndLength(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_BYTE *)(a1 + 41) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = a2 + a3;
  *(_BYTE *)(a1 + 40) = a4;
  *(_QWORD *)(a1 + 48) = a2;
  *(_QWORD *)(a1 + 56) = a2;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  return hevcbridgeAdvanceInBitstream(a1, 0);
}

uint64_t hevcbridgeGetSPS_VUI_AspectRatioCallbackFlag(uint64_t a1, int a2, int a3)
{
  if (a2 == 109)
  {
    *(_BYTE *)(a1 + 9) = a3;
    return a3 != 1;
  }
  if (a2 == 108)
  {
    *(_BYTE *)(a1 + 8) = a3;
    return a3 != 1;
  }
  return 4294954584;
}

uint64_t hevcbridgeGetSPS_VUI_AspectRatioCallbackUnsigned(unsigned int *a1, int a2, unsigned int a3)
{
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned int v5;

  v3 = 4294954584;
  if (a2 > 110)
  {
    if (a2 != 111)
    {
      if (a2 == 112)
      {
        a1[1] = a3;
        return 1;
      }
      return v3;
    }
    *a1 = a3;
    return 0;
  }
  if (!a2)
  {
    if (a3 != 33)
      return v3;
    return 0;
  }
  if (a2 == 110)
  {
    if (a3 - 1 <= 0xF)
    {
      v4 = (unsigned __int8 *)&kHEVCSampleAspectRatioIndicators + 2 * a3;
      v5 = *v4;
      LODWORD(v4) = v4[1];
      *a1 = v5;
      a1[1] = v4;
      return 1;
    }
    if (a3 != 255)
    {
      *(_QWORD *)a1 = 0x100000001;
      return 1;
    }
    return 0;
  }
  return v3;
}

uint64_t hevcbridgeParseNALUnit(_QWORD *a1, _QWORD *a2)
{
  unsigned int v4;
  char v5;
  char v6;
  char v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;

  v10 = 0;
  v11 = 0;
  v4 = hevcbridgeUPullLong((uint64_t)a1, 1, (_DWORD *)&v11 + 1);
  if (!v4)
  {
    if (HIDWORD(v11))
    {
      v8 = 4294954582;
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      return v8;
    }
    v5 = *((_BYTE *)a2 + 40);
    v4 = hevcbridgeUPullLong((uint64_t)a1, 6, &v11);
    if ((v5 & 1) != 0 && !v4)
      v4 = ((uint64_t (*)(_QWORD, _QWORD, _QWORD, uint64_t))a2[2])(*a2, 0, v11, 0xFFFFFFFFLL);
    if (!v4)
    {
      v6 = *((_BYTE *)a2 + 40);
      v4 = hevcbridgeUPullLong((uint64_t)a1, 6, (_DWORD *)&v10 + 1);
      if ((v6 & 2) != 0 && !v4)
        v4 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 1, HIDWORD(v10), 0xFFFFFFFFLL);
      if (!v4)
      {
        v7 = *((_BYTE *)a2 + 40);
        v4 = hevcbridgeUPullLong((uint64_t)a1, 3, &v10);
        if ((v7 & 4) != 0 && !v4)
          v4 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 2, v10, 0xFFFFFFFFLL);
        if (!v4)
        {
          v8 = 0;
          switch((int)v11)
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
              v4 = hevcbridgeParseSliceSegmentLayer((uint64_t)a1, a2, v11, HIDWORD(v10), v10);
              break;
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
            case 35:
            case 36:
            case 37:
            case 38:
              return v8;
            case 32:
              v4 = hevcbridgeParseVideoParameterSet((uint64_t)a1, a2);
              break;
            case 33:
              v4 = hevcbridgeParseSequenceParameterSet((uint64_t)a1, a2, SHIDWORD(v10));
              break;
            case 34:
              v4 = hevcbridgeParsePictureParameterSet(a1, a2);
              break;
            case 39:
            case 40:
              v4 = hevcbridgeParseSEIRBSP(a1, a2, v11);
              break;
            default:
              if ((_DWORD)v11 != 62)
                return v8;
              v4 = hevcbridgeParseDolbyRPUDataRBSP((uint64_t)a1, a2, 0);
              break;
          }
        }
      }
    }
  }
  if (v4 == 1)
    return 0;
  else
    return v4;
}

uint64_t FigHEVCBridge_GetSPS_VUI_ChromaLocation(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result;
  int v7;
  uint64_t v8;
  int v9;
  _QWORD v10[3];
  __int128 v11;
  _OWORD v12[7];
  uint64_t v13;
  _OWORD v14[6];
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  memset(v14, 0, sizeof(v14));
  v13 = 0;
  memset(v12, 0, sizeof(v12));
  v11 = 0u;
  v9 = 0;
  v8 = 0;
  result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v14, a1, a2, 1);
  if (!(_DWORD)result)
  {
    LOBYTE(v12[0]) = 1;
    *(_QWORD *)((char *)v12 + 12) = 0;
    *(_QWORD *)((char *)v12 + 4) = 0xE00080000000000;
    v10[0] = &v8;
    v10[1] = hevcbridgeGetSPS_VUI_ChromaLocationCallbackFlag;
    v10[2] = hevcbridgeGetSPS_VUI_ChromaLocationCallbackUnsigned;
    result = hevcbridgeParseNALUnit(v14, v10);
    if (!(_DWORD)result)
    {
      result = 4294954584;
      if ((_BYTE)v9)
      {
        if (BYTE1(v9))
        {
          result = 0;
          v7 = HIDWORD(v8);
          *a3 = v8;
          *a4 = v7;
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeGetSPS_VUI_ChromaLocationCallbackFlag(uint64_t a1, int a2, int a3)
{
  if (a2 == 122)
  {
    *(_BYTE *)(a1 + 9) = a3;
    return a3 != 1;
  }
  if (a2 == 108)
  {
    *(_BYTE *)(a1 + 8) = a3;
    return a3 != 1;
  }
  return 4294954584;
}

uint64_t hevcbridgeGetSPS_VUI_ChromaLocationCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  if (a2 == 124)
  {
    a1[1] = a3;
    return 1;
  }
  else
  {
    if (a2 == 123)
    {
      *a1 = a3;
    }
    else if (a2 || a3 != 33)
    {
      return 4294954584;
    }
    return 0;
  }
}

uint64_t FigHEVCBridge_GetSPS_VUI_NCLC(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t result;
  int v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[3];
  __int128 v13;
  _OWORD v14[7];
  uint64_t v15;
  _OWORD v16[6];
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  memset(v16, 0, sizeof(v16));
  v15 = 0;
  memset(v14, 0, sizeof(v14));
  v13 = 0u;
  v10 = 0;
  v11 = 0;
  result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v16, a1, a2, 1);
  if (!(_DWORD)result)
  {
    LOBYTE(v14[0]) = 1;
    *(_QWORD *)((char *)v14 + 12) = 0;
    *(_QWORD *)((char *)v14 + 4) = 0x1E0080000000000;
    v12[0] = &v10;
    v12[1] = hevcbridgeGetSPS_VUI_NCLCCallbackFlag;
    v12[2] = hevcbridgeGetSPS_VUI_NCLCCallbackUnsigned;
    result = hevcbridgeParseNALUnit(v16, v12);
    if (!(_DWORD)result)
    {
      result = 4294954584;
      if (BYTE4(v11))
      {
        if (BYTE5(v11))
        {
          result = 0;
          v9 = HIDWORD(v10);
          *a3 = v10;
          *a4 = v9;
          *a5 = v11;
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeGetSPS_VUI_NCLCCallbackFlag(uint64_t a1, int a2, int a3)
{
  if (a2 == 118)
  {
    *(_BYTE *)(a1 + 13) = a3;
    return a3 != 1;
  }
  if (a2 == 108)
  {
    *(_BYTE *)(a1 + 12) = a3;
    return a3 != 1;
  }
  return 4294954584;
}

uint64_t hevcbridgeGetSPS_VUI_NCLCCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  uint64_t result;

  result = 4294954584;
  if (a2 > 119)
  {
    if (a2 == 120)
    {
      ++a1;
LABEL_11:
      *a1 = a3;
      return 0;
    }
    if (a2 == 121)
    {
      a1[2] = a3;
      return 1;
    }
  }
  else
  {
    if (a2)
    {
      if (a2 != 119)
        return result;
      goto LABEL_11;
    }
    if (a3 == 33)
      return 0;
  }
  return result;
}

uint64_t FigHEVCBridge_GetSPS_VUI_FullRangeVideo(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result;
  char v5;
  _QWORD v6[3];
  __int128 v7;
  _OWORD v8[7];
  uint64_t v9;
  _QWORD v10[14];

  v10[13] = *MEMORY[0x1E0C80C00];
  memset(v10, 0, 104);
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  v7 = 0u;
  v5 = 0;
  result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v10, a1, a2, 1);
  if (!(_DWORD)result)
  {
    LOBYTE(v8[0]) = 1;
    *(_QWORD *)((char *)v8 + 12) = 0;
    *(_QWORD *)((char *)v8 + 4) = 0x10000000000000;
    v6[0] = &v5;
    v6[1] = hevcbridgeGetSPS_VUI_FullRangeVideoCallbackFlag;
    v6[2] = hevcbridgeGetSPS_VUI_FullRangeVideoCallbackUnsigned;
    result = hevcbridgeParseNALUnit(v10, v6);
    if (!(_DWORD)result)
      *a3 = v5;
  }
  return result;
}

uint64_t hevcbridgeGetSPS_VUI_FullRangeVideoCallbackFlag(_BYTE *a1, int a2, char a3)
{
  if (a2 != 117)
    return 4294954584;
  *a1 = a3;
  return 1;
}

uint64_t hevcbridgeGetSPS_VUI_FullRangeVideoCallbackUnsigned(uint64_t a1, int a2, int a3)
{
  if (a3 == 33 && a2 == 0)
    return 0;
  else
    return 4294954584;
}

uint64_t FigHEVCBridge_GetNALUnitHeader(uint64_t a1, uint64_t a2, _DWORD *a3, const char **a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t result;
  const char *v11;
  uint64_t v12;
  int v13;
  uint64_t *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  _OWORD v25[6];
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v26 = 0;
  memset(v25, 0, sizeof(v25));
  v24 = 0;
  v23 = 0u;
  v22 = 0u;
  v21 = 0u;
  v20 = 0u;
  v19 = 0u;
  v18 = 0u;
  v17 = 0u;
  v16 = 0u;
  v15 = 0u;
  v13 = 0;
  v12 = 0;
  result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v25, a1, a2, 1);
  if (!(_DWORD)result)
  {
    LOBYTE(v17) = 7;
    v14 = &v12;
    *((_QWORD *)&v15 + 1) = hevcbridgeGetNALUnitHeaderCallbackUnsigned;
    result = hevcbridgeParseNALUnit(v25, &v14);
    if (!(_DWORD)result)
    {
      if (a3)
        *a3 = v12;
      if (a4)
      {
        if (v12 > 0x3F)
          v11 = "?";
        else
          v11 = nalUnitTypeString[v12];
        *a4 = v11;
      }
      if (a5)
        *a5 = HIDWORD(v12);
      result = 0;
      if (a6)
        *a6 = v13 - 1;
    }
  }
  return result;
}

uint64_t hevcbridgeGetNALUnitHeaderCallbackUnsigned(_DWORD *a1, uint64_t a2, int a3)
{
  if ((_DWORD)a2)
  {
    if ((_DWORD)a2 == 2)
    {
      a1 += 2;
      a2 = 1;
    }
    else
    {
      if ((_DWORD)a2 != 1)
        return 4294954584;
      a2 = 0;
      ++a1;
    }
  }
  *a1 = a3;
  return a2;
}

uint64_t FigHEVCBridge_GetVPSAlphaChannelNuhLayerId(uint64_t a1, uint64_t a2, _BYTE *a3, _DWORD *a4)
{
  uint64_t result;
  uint64_t v7;
  _QWORD v8[3];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  _QWORD v18[14];

  v18[13] = *MEMORY[0x1E0C80C00];
  memset(v18, 0, 104);
  v17 = 0;
  v16 = 0u;
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v12 = 0u;
  v11 = 0u;
  v10 = 0u;
  v9 = 0u;
  v7 = 0;
  result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v18, a1, a2, 1);
  if (!(_DWORD)result)
  {
    LOBYTE(v10) = 1;
    *(_QWORD *)((char *)&v10 + 4) = 50397184;
    v8[0] = &v7;
    v8[1] = hevcbridgeGetVPSAlphaChannelNuhLayerIdCallbackFlag;
    v8[2] = hevcbridgeGetVPSAlphaChannelNuhLayerIdCallbackUnsigned;
    result = hevcbridgeParseNALUnit(v18, v8);
    if (!(_DWORD)result)
    {
      if (a3)
        *a3 = BYTE4(v7);
      result = 0;
      if (a4)
        *a4 = v7;
    }
  }
  return result;
}

uint64_t hevcbridgeGetVPSAlphaChannelNuhLayerIdCallbackFlag(uint64_t a1, int a2, int a3)
{
  if (a2 == 19)
    return a3 == 0;
  else
    return 4294954584;
}

uint64_t hevcbridgeGetVPSAlphaChannelNuhLayerIdCallbackUnsigned(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t result;

  if (a2 == 28)
    return 1;
  if (a2 == 27)
  {
    if (a3 == 1)
    {
      *(_DWORD *)a1 = a3 >> 8;
      result = 1;
      *(_BYTE *)(a1 + 4) = 1;
      return result;
    }
  }
  else if (a2 || a3 != 32)
  {
    return 4294954584;
  }
  return 0;
}

uint64_t FigHEVCBridge_GetSEIAlphaChannelInfo(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t result;
  char v5;
  _QWORD v6[3];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  _BYTE v16[96];
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  memset(v16, 0, sizeof(v16));
  v15 = 0;
  v14 = 0u;
  v13 = 0u;
  v12 = 0u;
  v11 = 0u;
  v10 = 0u;
  v9 = 0u;
  v8 = 0u;
  v7 = 0u;
  v5 = 0;
  result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v16, a1, a2, 1);
  if (!(_DWORD)result)
  {
    BYTE12(v9) = 31;
    v6[0] = &v5;
    v6[1] = hevcbridgeGetSEIAlphaChannelInfoCallbackFlag;
    v6[2] = hevcbridgeGetSEIAlphaChannelInfoCallbackUnsigned;
    result = hevcbridgeParseSEIAlphaChannelInfo((uint64_t)v16, (uint64_t)v6);
    if (result <= 1)
    {
      result = 0;
      *a3 = v5;
    }
  }
  return result;
}

uint64_t hevcbridgeGetSEIAlphaChannelInfoCallbackFlag(uint64_t a1, int a2, int a3)
{
  uint64_t result;

  result = 4294954584;
  if (a2 == 354)
  {
    if (a3)
      return 4294954584;
    else
      return 1;
  }
  else if (a2 == 353)
  {
    if (!a3)
      return 0;
  }
  else if (a2 == 348 && a3 != 1)
  {
    return 0;
  }
  return result;
}

uint64_t hevcbridgeGetSEIAlphaChannelInfoCallbackUnsigned(_BYTE *a1, int a2, int a3)
{
  BOOL v3;
  uint64_t result;

  switch(a2)
  {
    case 349:
      if (a3 == 1)
      {
        result = 0;
        *a1 = 1;
      }
      else
      {
        if (a3)
          goto LABEL_6;
        result = 0;
        *a1 = 0;
      }
      break;
    case 350:
    case 351:
      v3 = a3 == 0;
      goto LABEL_8;
    case 352:
      v3 = a3 == 255;
LABEL_8:
      if (v3)
        result = 0;
      else
        result = 4294954584;
      break;
    default:
LABEL_6:
      result = 4294954584;
      break;
  }
  return result;
}

uint64_t hevcbridgeParseSEIAlphaChannelInfo(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  BOOL v5;
  char v6;
  int v7;
  unsigned int v8;
  __int16 v9;

  v9 = 0;
  result = hevcbridgeUPullFlagAlways(a1, a2, *(_BYTE *)(a2 + 68) & 1, 348, (_BYTE *)&v9 + 1);
  if ((_DWORD)result)
    v5 = 0;
  else
    v5 = HIBYTE(v9) == 0;
  if (v5)
  {
    v8 = 0;
    result = hevcbridgeUPullIfRequested(a1, a2, (*(unsigned __int8 *)(a2 + 68) >> 1) & 1, 349, 3);
    if (!(_DWORD)result)
    {
      v6 = *(_BYTE *)(a2 + 68);
      result = hevcbridgeUPullLong(a1, 3, &v8);
      if ((v6 & 4) != 0 && !(_DWORD)result)
        result = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t))(a2 + 16))(*(_QWORD *)a2, 350, v8, 0xFFFFFFFFLL);
      if (!(_DWORD)result)
      {
        v7 = v8 + 9;
        result = hevcbridgeUPullIfRequested(a1, a2, (*(unsigned __int8 *)(a2 + 68) >> 3) & 1, 351, v8 + 9);
        if (!(_DWORD)result)
        {
          result = hevcbridgeUPullIfRequested(a1, a2, (*(unsigned __int8 *)(a2 + 68) >> 4) & 1, 352, v7);
          if (!(_DWORD)result)
          {
            result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(unsigned __int8 *)(a2 + 68) >> 5) & 1, 353);
            if (!(_DWORD)result)
            {
              result = hevcbridgeUPullFlagAlways(a1, a2, (*(unsigned __int8 *)(a2 + 68) >> 6) & 1, 354, &v9);
              if (!(_DWORD)result)
              {
                if (!(_BYTE)v9)
                  return 0;
                result = hevcbridgeUPullFlagIfRequested(a1, a2, *(unsigned __int8 *)(a2 + 68) >> 7, 355);
                if (!(_DWORD)result)
                  return 0;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t FigHEVCBridge_GetAmbientViewingEnvironment(uint64_t a1, uint64_t a2, _DWORD *a3, _WORD *a4, _WORD *a5)
{
  uint64_t result;
  __int16 v9;
  __int16 v10;
  uint64_t v11;
  uint64_t *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  _QWORD v23[14];

  v23[13] = *MEMORY[0x1E0C80C00];
  memset(v23, 0, 104);
  v22 = 0;
  v21 = 0u;
  v20 = 0u;
  v19 = 0u;
  v18 = 0u;
  v17 = 0u;
  v16 = 0u;
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v11 = 0;
  result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v23, a1, a2, 1);
  if (!(_DWORD)result)
  {
    LOBYTE(v15) = 1;
    LOBYTE(v17) = 7;
    v12 = &v11;
    *((_QWORD *)&v13 + 1) = hevcbridgeGetSEIAmbientViewingEnvironmentCallbackUnsigned;
    result = hevcbridgeParseNALUnit(v23, &v12);
    if (result <= 1)
    {
      result = 4294954584;
      if ((_DWORD)v11)
      {
        v9 = WORD2(v11);
        if (WORD2(v11))
        {
          v10 = HIWORD(v11);
          if (HIWORD(v11))
          {
            if (a3)
              *a3 = v11;
            if (a4)
              *a4 = v9;
            result = 0;
            if (a5)
              *a5 = v10;
          }
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeGetSEIAmbientViewingEnvironmentCallbackUnsigned(uint64_t a1, int a2, int a3)
{
  uint64_t result;

  result = 4294954584;
  if (a2 > 356)
  {
    if (a2 == 357)
    {
      *(_WORD *)(a1 + 4) = a3;
LABEL_11:
      if (a3)
        return 0;
      else
        return 4294954584;
    }
    if (a2 == 358)
    {
      *(_WORD *)(a1 + 6) = a3;
      return 1;
    }
  }
  else
  {
    if (a2)
    {
      if (a2 != 356)
        return result;
      *(_DWORD *)a1 = a3;
      goto LABEL_11;
    }
    if (a3 == 39)
      return 0;
  }
  return result;
}

uint64_t FigHEVCBridge_GetSPSProfileTierLevel(uint64_t a1, uint64_t a2, _BYTE *a3, _BYTE *a4, _BYTE *a5)
{
  uint64_t result;
  char v9;
  uint64_t v10;
  int v11;
  _QWORD v12[3];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  _OWORD v22[6];
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v23 = 0;
  memset(v22, 0, sizeof(v22));
  v21 = 0;
  v20 = 0u;
  v19 = 0u;
  v18 = 0u;
  v17 = 0u;
  v16 = 0u;
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v11 = 0;
  v10 = 0;
  result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v22, a1, a2, 1);
  if (!(_DWORD)result)
  {
    LOBYTE(v14) = 1;
    DWORD1(v15) = 1048583;
    v12[0] = &v10;
    v12[1] = hevcbridgeGetSPSProfileTierLevelCallbackFlag;
    v12[2] = hevcbridgeGetSPSProfileTierLevelCallbackUnsigned;
    result = hevcbridgeParseNALUnit(v22, v12);
    if (!(_DWORD)result)
    {
      v9 = BYTE4(v10);
      *a3 = v10;
      *a4 = v11;
      *a5 = v9;
    }
  }
  return result;
}

uint64_t hevcbridgeGetSPSProfileTierLevelCallbackFlag(uint64_t a1, int a2, char a3)
{
  uint64_t result;

  if (a2 != 309)
    return 4294954584;
  result = 0;
  *(_BYTE *)(a1 + 8) = a3;
  return result;
}

uint64_t hevcbridgeGetSPSProfileTierLevelCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  uint64_t result;

  result = 4294954584;
  if (a2 <= 309)
  {
    if (a2)
    {
      if (a2 != 308 || a3)
        return result;
    }
    else if (a3 != 33)
    {
      return result;
    }
    return 0;
  }
  if (a2 == 310)
  {
    *a1 = a3;
    return 0;
  }
  if (a2 == 328)
  {
    a1[1] = a3;
    return 1;
  }
  return result;
}

uint64_t FigHEVCBridge_GetSPSChromaFormatAndBitDepths(uint64_t a1, uint64_t a2, _BYTE *a3, _BYTE *a4, _BYTE *a5)
{
  uint64_t result;
  char v9;
  char v10;
  uint64_t v11;
  unsigned int v12;
  _QWORD v13[3];
  __int128 v14;
  _OWORD v15[7];
  uint64_t v16;
  _OWORD v17[6];
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  memset(v17, 0, sizeof(v17));
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  v14 = 0u;
  v12 = 0;
  v11 = 0;
  result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v17, a1, a2, 1);
  if (!(_DWORD)result)
  {
    LOBYTE(v15[0]) = 1;
    *(_QWORD *)((char *)v15 + 12) = 0;
    *(_QWORD *)((char *)v15 + 4) = 196768;
    v13[0] = &v11;
    v13[1] = hevcbridgeGetSPSChromaFormatAndBitDepthsCallbackFlag;
    v13[2] = hevcbridgeGetSPSChromaFormatAndBitDepthsCallbackUnsigned;
    result = hevcbridgeParseNALUnit(v17, v13);
    if (!(_DWORD)result)
    {
      if (v11 >= 4)
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      v9 = BYTE4(v11);
      if (HIDWORD(v11) >= 9)
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      v10 = v12;
      if (v12 >= 9)
      {
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        if (a3)
          *a3 = v11;
        if (a4)
          *a4 = v9 + 8;
        result = 0;
        if (a5)
          *a5 = v10 + 8;
      }
    }
  }
  return result;
}

uint64_t hevcbridgeGetSPSChromaFormatAndBitDepthsCallbackFlag(uint64_t a1, int a2)
{
  if (a2 == 70)
    return 4294954579;
  else
    return 4294954584;
}

uint64_t hevcbridgeGetSPSChromaFormatAndBitDepthsCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  uint64_t result;

  result = 4294954584;
  if (a2 > 80)
  {
    if (a2 == 81)
    {
      ++a1;
LABEL_11:
      *a1 = a3;
      return 0;
    }
    if (a2 == 82)
    {
      a1[2] = a3;
      return 1;
    }
  }
  else
  {
    if (a2)
    {
      if (a2 != 72)
        return result;
      goto LABEL_11;
    }
    if (a3 == 33)
      return 0;
  }
  return result;
}

uint64_t FigHEVCBridge_GetSPSIsScalingListPresent(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t result;
  BOOL v5;
  char v6;
  __int16 v7;
  _QWORD v8[3];
  __int128 v9;
  _OWORD v10[7];
  uint64_t v11;
  _QWORD v12[14];

  v12[13] = *MEMORY[0x1E0C80C00];
  v11 = 0;
  memset(v10, 0, sizeof(v10));
  v9 = 0u;
  v7 = 0;
  if (!a3)
    return 4294954584;
  memset(v12, 0, 104);
  *a3 = 0;
  result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v12, a1, a2, 1);
  if (!(_DWORD)result)
  {
    LOBYTE(v10[0]) = 1;
    *(_QWORD *)((char *)v10 + 12) = 0;
    *(_QWORD *)((char *)v10 + 4) = 603979776;
    v8[0] = &v7;
    v8[1] = hevcbridgeGetSPSScalingListEnabledAndScalingListPresentCallback;
    v8[2] = hevcbridgeGetSPSScalingListEnabledAndScalingListPresentCallbackUnsigned;
    result = hevcbridgeParseNALUnit(v12, v8);
    if (!(_DWORD)result)
    {
      if (HIBYTE(v7))
        v5 = v7 == 0;
      else
        v5 = 1;
      v6 = !v5;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t hevcbridgeGetSPSScalingListEnabledAndScalingListPresentCallbackUnsigned(uint64_t a1, int a2, int a3)
{
  if (a3 == 33 && a2 == 0)
    return 0;
  else
    return 4294954584;
}

uint64_t hevcbridgeGetSPSScalingListEnabledAndScalingListPresentCallback(_BYTE *a1, int a2, int a3)
{
  if (a2 == 94)
  {
    a1[1] = a3;
    return 1;
  }
  else if (a2 == 91)
  {
    *a1 = a3;
    return a3 == 0;
  }
  else
  {
    return 4294954584;
  }
}

uint64_t FigHEVCBridge_GetSPSBitDepths(uint64_t a1, uint64_t a2, _BYTE *a3, _BYTE *a4)
{
  return FigHEVCBridge_GetSPSChromaFormatAndBitDepths(a1, a2, 0, a3, a4);
}

uint64_t FigHEVCBridge_GetSPSIsInterlaced(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t result;
  BOOL v5;
  char v6;
  __int16 v7;
  _QWORD v8[3];
  __int128 v9;
  _OWORD v10[7];
  uint64_t v11;
  _QWORD v12[14];

  v12[13] = *MEMORY[0x1E0C80C00];
  memset(v12, 0, 104);
  v11 = 0;
  memset(v10, 0, sizeof(v10));
  v9 = 0u;
  v7 = 0;
  result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v12, a1, a2, 1);
  if (!(_DWORD)result)
  {
    LOBYTE(v10[0]) = 1;
    *(_QWORD *)((char *)v10 + 12) = 0;
    *(_QWORD *)((char *)v10 + 4) = 0x2000080000000000;
    v8[0] = &v7;
    v8[1] = hevcbridgeGetSPSIsInterlacedCallbackFlag;
    v8[2] = hevcbridgeGetSPSIsInterlacedCallbackUnsigned;
    result = hevcbridgeParseNALUnit(v12, v8);
    if (!(_DWORD)result)
    {
      if ((_BYTE)v7)
        v5 = HIBYTE(v7) == 0;
      else
        v5 = 1;
      v6 = !v5;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t hevcbridgeGetSPSIsInterlacedCallbackFlag(_BYTE *a1, int a2, int a3)
{
  if (a2 == 126)
  {
    a1[1] = a3;
    return 1;
  }
  else if (a2 == 108)
  {
    *a1 = a3;
    return a3 == 0;
  }
  else
  {
    return 4294954584;
  }
}

uint64_t hevcbridgeGetSPSIsInterlacedCallbackUnsigned(uint64_t a1, int a2, int a3)
{
  if (a3 == 33 && a2 == 0)
    return 0;
  else
    return 4294954584;
}

double FigHEVCBridge_Get3DLayerIDSets(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5, _OWORD *a6)
{
  double result;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _OWORD v16[9];
  _OWORD *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  _OWORD v28[6];
  uint64_t v29;
  _OWORD v30[6];
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v31 = 0;
  memset(v30, 0, sizeof(v30));
  v29 = 0;
  memset(v28, 0, sizeof(v28));
  v27 = 0;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  v23 = 0u;
  v22 = 0u;
  v21 = 0u;
  v20 = 0u;
  v19 = 0u;
  v18 = 0u;
  memset(v16, 0, 140);
  if (!hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v30, a3, a4, 0))
  {
    LOBYTE(v20) = 1;
    WORD2(v22) = 48;
    v17 = v16;
    *((_QWORD *)&v18 + 1) = hevcbridgeGet3DLayerIDsSEICallbackUnsigned;
    *(_QWORD *)((char *)v16 + 4) = -1;
    if (hevcbridgeParseSEI3DReferenceDisplaysInformation((uint64_t)v30, &v17) <= 1
      && !hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v28, a1, a2, 1))
    {
      v20 = 0u;
      v27 = 0;
      v26 = 0u;
      v25 = 0u;
      v24 = 0u;
      v23 = 0u;
      v22 = 0u;
      v21 = 0u;
      v19 = 0u;
      LOBYTE(v20) = 1;
      *(_QWORD *)((char *)&v20 + 4) = 4160815104;
      v17 = v16;
      *(_QWORD *)&v18 = hevcbridgeGet3DLayerIDsVPSCallbackFlag;
      *((_QWORD *)&v18 + 1) = hevcbridgeGet3DLayerIDsVPSCallbackUnsigned;
      *(_QWORD *)&v11 = -1;
      *((_QWORD *)&v11 + 1) = -1;
      *(_OWORD *)((char *)v16 + 12) = v11;
      *(_OWORD *)((char *)&v16[1] + 12) = v11;
      *(_OWORD *)((char *)&v16[2] + 12) = v11;
      *(_OWORD *)((char *)&v16[3] + 12) = v11;
      *(_OWORD *)((char *)&v16[4] + 12) = v11;
      *(_OWORD *)((char *)&v16[5] + 12) = v11;
      *(_OWORD *)((char *)&v16[6] + 12) = v11;
      *(_OWORD *)((char *)&v16[7] + 12) = v11;
      if (!hevcbridgeParseNALUnit(v28, &v17))
      {
        v12 = *(_OWORD *)(((unint64_t)v16 | 0xC) + 0x10);
        *a5 = *(_OWORD *)((unint64_t)v16 | 0xC);
        a5[1] = v12;
        v13 = *(_OWORD *)(((unint64_t)v16 | 0xC) + 0x30);
        a5[2] = *(_OWORD *)(((unint64_t)v16 | 0xC) + 0x20);
        a5[3] = v13;
        v14 = *(_OWORD *)((char *)&v16[5] + 12);
        *a6 = *(_OWORD *)((char *)&v16[4] + 12);
        a6[1] = v14;
        result = *(double *)((char *)&v16[6] + 12);
        v15 = *(_OWORD *)((char *)&v16[7] + 12);
        a6[2] = *(_OWORD *)((char *)&v16[6] + 12);
        a6[3] = v15;
      }
    }
  }
  return result;
}

uint64_t hevcbridgeGet3DLayerIDsSEICallbackUnsigned(uint64_t a1, int a2, int a3)
{
  if (a2 == 364)
  {
    *(_DWORD *)(a1 + 8) = a3;
    return 1;
  }
  else
  {
    if (a2 == 363)
    {
      *(_DWORD *)(a1 + 4) = a3;
    }
    else if (a2 || a3 != 39)
    {
      return 4294954584;
    }
    return 0;
  }
}

uint64_t hevcbridgeParseSEI3DReferenceDisplaysInformation(uint64_t a1, _QWORD *a2)
{
  __int16 v4;
  uint64_t result;
  unsigned int v6;
  int v7;
  __int16 v8;
  int v9;
  __int16 v10;
  int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  __int16 v15;
  int v16;
  int v17;
  int v18;
  char v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  unsigned __int8 v23;

  v23 = 0;
  v22 = 0;
  v21 = 0;
  v4 = *((_WORD *)a2 + 38);
  result = hevcbridgeUEPullLong(a1, &v22);
  if ((v4 & 1) != 0 && !(_DWORD)result)
    result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 359, v22, 0xFFFFFFFFLL);
  if (!(_DWORD)result)
  {
    v6 = v22;
    if (v22 >= 0x20)
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 76) >> 1) & 1, 360, &v23);
    if ((_DWORD)result)
      return result;
    v7 = v23;
    if (v23)
    {
      v8 = *((_WORD *)a2 + 38);
      result = hevcbridgeUEPullLong(a1, (unsigned int *)&v21);
      if ((v8 & 4) != 0 && !(_DWORD)result)
        result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 361, v21, 0xFFFFFFFFLL);
      if ((_DWORD)result)
        return result;
      v9 = v21;
      if (v21 >= 0x20)
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    }
    else
    {
      v9 = 0;
    }
    v10 = *((_WORD *)a2 + 38);
    result = hevcbridgeUEPullLong(a1, (unsigned int *)&v21 + 1);
    if ((v10 & 8) != 0 && !(_DWORD)result)
      result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 362, HIDWORD(v21), 0xFFFFFFFFLL);
    if (!(_DWORD)result)
    {
      v11 = 0;
      v12 = HIDWORD(v21);
      v13 = v6 - 30;
      v14 = v6 - 31;
      while (1)
      {
        v20 = 0;
        v19 = 0;
        result = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 76) >> 4) & 1, 363);
        if ((_DWORD)result)
          break;
        result = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 76) >> 5) & 1, 364);
        if ((_DWORD)result)
          break;
        v15 = *((_WORD *)a2 + 38);
        result = hevcbridgeUPullLong(a1, 6, &v20);
        if ((v15 & 0x40) != 0 && !(_DWORD)result)
          result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 365, v20, 0xFFFFFFFFLL);
        if ((_DWORD)result)
          break;
        if (v20 >= 0x3F)
          return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        if (v20)
          v16 = v14 + v20;
        else
          v16 = v13;
        result = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, *((unsigned __int8 *)a2 + 76) >> 7, 366, v16);
        if ((_DWORD)result)
          return result;
        if (v7)
        {
          v18 = 0;
          result = hevcbridgeUPullAlways(a1, (uint64_t)a2, *((_BYTE *)a2 + 77) & 1, 367, &v18, 6);
          if ((_DWORD)result)
            return result;
          v17 = v18 ? v18 - 31 : 0;
          result = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, (*((unsigned __int16 *)a2 + 38) >> 9) & 1, 368, v9 + v17);
          if ((_DWORD)result)
            return result;
        }
        result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((unsigned __int16 *)a2 + 38) >> 10) & 1, 369, &v19);
        if ((_DWORD)result)
          return result;
        if (v19)
        {
          result = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, (*((unsigned __int16 *)a2 + 38) >> 11) & 1, 370, 10);
          if ((_DWORD)result)
            return result;
        }
        if (++v11 > v12)
          return hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((unsigned __int16 *)a2 + 38) >> 12) & 1, 371);
      }
    }
  }
  return result;
}

uint64_t hevcbridgeGet3DLayerIDsVPSCallbackFlag(uint64_t a1, int a2, int a3)
{
  unsigned int v3;

  if (a2 == 19)
    v3 = a3 == 0;
  else
    v3 = -12712;
  if (a2 == 31)
    v3 = 1;
  if (a2 == 34)
    return 1;
  else
    return v3;
}

uint64_t hevcbridgeGet3DLayerIDsVPSCallbackUnsigned(uint64_t a1, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;

  if ((a2 - 32) < 2)
    return 1;
  if (a2 == 30)
  {
    if ((unsigned __int16)a3 == *(_DWORD *)(a1 + 4))
    {
      v4 = 0;
      while (*(unsigned __int8 *)(a1 + 12 + v4) != 255)
      {
        if (++v4 == 64)
          return 4294954584;
      }
      v6 = (_BYTE *)(a1 + v4 + 12);
    }
    else
    {
      if ((unsigned __int16)a3 != *(_DWORD *)(a1 + 8))
        return 0;
      v5 = 0;
      while (*(unsigned __int8 *)(a1 + 76 + v5) != 255)
      {
        ++v5;
        v3 = 4294954584;
        if (v5 == 64)
          return v3;
      }
      v6 = (_BYTE *)(a1 + v5 + 76);
    }
    *v6 = BYTE2(a3);
    return 0;
  }
  if (!a2 && a3 == 32)
    return 0;
  return 4294954584;
}

void FigHEVCBridge_Get3DLayerIDs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, char *a6)
{
  char v8;
  int v9;
  BOOL v10;
  BOOL v11;
  char v12;
  _OWORD v13[4];
  _OWORD v14[4];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  memset(v14, 0, sizeof(v14));
  memset(v13, 0, sizeof(v13));
  FigHEVCBridge_Get3DLayerIDSets(a1, a2, a3, a4, v14, v13);
  v8 = v14[0];
  if (v9)
    v10 = 1;
  else
    v10 = LOBYTE(v14[0]) == 255;
  v11 = v10 || LOBYTE(v13[0]) == 255;
  if (v11)
    v8 = -1;
  if (v11)
    v12 = -1;
  else
    v12 = v13[0];
  *a5 = v8;
  *a6 = v12;
}

_BYTE *FigHEVCBridge_AllocThreeDimensionalReferenceDisplaysInfo(unsigned int a1)
{
  char v1;
  _BYTE *result;

  if (a1 > 0x20)
    return 0;
  v1 = a1;
  result = malloc_type_calloc(1uLL, 40 * a1 + 8, 0x35C1F732uLL);
  if (result)
    result[3] = v1 - 1;
  return result;
}

uint64_t FigHEVCBridge_CreateThreeDimensionalReferenceDisplaysInfoSEI(unsigned __int8 *a1, CFDataRef *a2)
{
  uint64_t result;
  unsigned __int8 *v5;
  unint64_t v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  int BufferWithStartCodeEmulationBytes;
  CFDataRef v16;
  CFDataRef v17;
  _BYTE v18[389];
  uint64_t v19[2];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  _OWORD v26[16];
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v27 = 0;
  memset(v26, 0, sizeof(v26));
  v25 = 0;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v20 = 0u;
  memset(v18, 0, sizeof(v18));
  if (!a2)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v19[0] = (uint64_t)v26;
  v19[1] = 260;
  *(_QWORD *)&v22 = v26;
  BYTE9(v21) = 0;
  result = hevcbridgeUPush(v19, 1, 0);
  if (!(_DWORD)result)
  {
    result = hevcbridgeUPush(v19, 6, 39);
    if (!(_DWORD)result)
    {
      result = hevcbridgeUPush(v19, 6, 0);
      if (!(_DWORD)result)
      {
        result = hevcbridgeUPush(v19, 3, 1);
        if (!(_DWORD)result)
        {
          result = hevcbridgeUPush(v19, 8, 176);
          if (!(_DWORD)result)
          {
            result = hevcbridgeUPush(v19, 8, 0);
            if (!(_DWORD)result)
            {
              result = hevcbridgeUEPush((uint64_t)v19, *a1);
              if (!(_DWORD)result)
              {
                result = hevcbridgeUPush(v19, 1, a1[1]);
                if (!(_DWORD)result)
                {
                  if (!a1[1] || (result = hevcbridgeUEPush((uint64_t)v19, a1[2]), !(_DWORD)result))
                  {
                    result = hevcbridgeUEPush((uint64_t)v19, a1[3]);
                    if (!(_DWORD)result)
                    {
                      v5 = a1 + 24;
                      v6 = -1;
                      while (1)
                      {
                        result = hevcbridgeUEPush((uint64_t)v19, *((unsigned __int16 *)v5 - 8));
                        if ((_DWORD)result)
                          return result;
                        result = hevcbridgeUEPush((uint64_t)v19, *((unsigned __int16 *)v5 - 7));
                        if ((_DWORD)result)
                          return result;
                        result = hevcbridgeUPush(v19, 6, *(v5 - 12));
                        if ((_DWORD)result)
                          return result;
                        if (*(v5 - 12))
                        {
                          v7 = *a1 + *(v5 - 12);
                          v8 = v7 - 31;
                          if (v7 < 0x1F)
                            goto LABEL_19;
                        }
                        else
                        {
                          v9 = *a1;
                          v8 = v9 - 30;
                          if (v9 < 0x1E)
                          {
LABEL_19:
                            v8 = 0;
LABEL_24:
                            v10 = *((_DWORD *)v5 - 2);
                            goto LABEL_25;
                          }
                        }
                        if (v8 < 33)
                          goto LABEL_24;
                        result = hevcbridgeUPushLong(v19, v8 - 32, *((_DWORD *)v5 - 1));
                        if ((_DWORD)result)
                          return result;
                        v10 = *((_DWORD *)v5 - 2);
                        v8 = 32;
LABEL_25:
                        result = hevcbridgeUPushLong(v19, v8, v10);
                        if ((_DWORD)result)
                          return result;
                        if (a1[1])
                        {
                          result = hevcbridgeUPush(v19, 6, *v5);
                          if ((_DWORD)result)
                            return result;
                          if (*v5)
                          {
                            v11 = a1[2] + *v5;
                            v12 = v11 - 31;
                            if (v11 < 0x1F)
                              goto LABEL_30;
LABEL_32:
                            if (v12 >= 33)
                            {
                              result = hevcbridgeUPushLong(v19, v12 - 32, *((_DWORD *)v5 + 3));
                              if ((_DWORD)result)
                                return result;
                              v14 = *((_DWORD *)v5 + 2);
                              v12 = 32;
LABEL_36:
                              result = hevcbridgeUPushLong(v19, v12, v14);
                              if ((_DWORD)result)
                                return result;
                              goto LABEL_37;
                            }
                          }
                          else
                          {
                            v13 = a1[2];
                            v12 = v13 - 30;
                            if (v13 >= 0x1E)
                              goto LABEL_32;
LABEL_30:
                            v12 = 0;
                          }
                          v14 = *((_DWORD *)v5 + 2);
                          goto LABEL_36;
                        }
LABEL_37:
                        result = hevcbridgeUPush(v19, 1, v5[16]);
                        if ((_DWORD)result)
                          return result;
                        if (v5[16])
                        {
                          result = hevcbridgeUPush(v19, 10, *((unsigned __int16 *)v5 + 9));
                          if ((_DWORD)result)
                            return result;
                        }
                        ++v6;
                        v5 += 40;
                        if (v6 >= a1[3])
                        {
                          result = hevcbridgeUPush(v19, 1, a1[4]);
                          if ((_DWORD)result)
                            return result;
                          if (HIDWORD(v23))
                          {
                            result = hevcbridgeUPush(v19, 1, 1);
                            if ((_DWORD)result)
                              return result;
                            while (HIDWORD(v23))
                              hevcbridgeUPush(v19, 1, 0);
                          }
                          BYTE3(v26[0]) = v22 - LOBYTE(v19[0]) - 4;
                          result = hevcbridgeUPush(v19, 1, 1);
                          if (!(_DWORD)result)
                          {
                            BufferWithStartCodeEmulationBytes = generateBufferWithStartCodeEmulationBytes(v22 - v19[0] + 1, v26, (uint64_t)v18);
                            v16 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v18, BufferWithStartCodeEmulationBytes);
                            if (v16)
                            {
                              v17 = v16;
                              result = 0;
                              *a2 = v17;
                            }
                            else
                            {
                              return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                            }
                          }
                          return result;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeUPushLong(uint64_t *a1, int a2, unsigned int a3)
{
  unsigned __int16 v3;
  uint64_t *v4;
  uint64_t result;

  v3 = a3;
  v4 = a1;
  if (a2 >= 26)
  {
    result = hevcbridgeUPush(a1, a2 - 16, HIWORD(a3));
    if ((_DWORD)result)
      return result;
    a3 = v3;
    a1 = v4;
    a2 = 16;
  }
  return hevcbridgeUPush(a1, a2, a3);
}

uint64_t hevcbridgeUEPush(uint64_t a1, int a2)
{
  int v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  uint64_t result;

  if (*(_BYTE *)(a1 + 41))
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  v3 = a2 + 1;
  if ((a2 + 1) < 2)
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    v5 = a2 + 1;
    do
    {
      v6 = v4++;
      if (v6 > 0xE)
        break;
      v7 = v5 > 3;
      v5 >>= 1;
    }
    while (v7);
  }
  result = hevcbridgeUPush((uint64_t *)a1, v4 + 1, 1);
  if (v4)
  {
    if (!(_DWORD)result)
      return hevcbridgeUPush((uint64_t *)a1, v4, (v3 - (1 << v4)) & ((1 << v4) - 1));
  }
  return result;
}

uint64_t hevcbridgeUPush(uint64_t *a1, int a2, int a3)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  size_t v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int __src;

  if (*((_BYTE *)a1 + 41) || a2 <= 0 || a2 >= 0x1A)
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  v4 = *((_DWORD *)a1 + 19) + a2;
  v5 = (a3 << -(char)(*((_BYTE *)a1 + 76) + a2)) | *((_DWORD *)a1 + 20);
  *((_DWORD *)a1 + 20) = v5;
  __src = bswap32(v5);
  v6 = a1[1] + *a1;
  v7 = (unsigned int *)a1[6];
  v8 = v6 - (_DWORD)v7;
  v9 = (v6 - (_DWORD)v7);
  if (v9 < 4)
  {
    memcpy(v7, &__src, v9);
    if (v8 >= (v4 + 7) >> 3)
      goto LABEL_7;
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  *v7 = __src;
LABEL_7:
  v10 = *((_DWORD *)a1 + 20) << (v4 & 0xF8);
  v11 = a1[6] + (v4 >> 3);
  a1[6] = v11;
  *((_DWORD *)a1 + 19) = v4 & 7;
  *((_DWORD *)a1 + 20) = v10;
  v12 = *a1;
  v13 = a1[1];
  if (v13 + *a1 <= v11)
  {
    *((_BYTE *)a1 + 41) = 1;
    a1[6] = v12 + v13;
  }
  return 0;
}

uint64_t generateBufferWithStartCodeEmulationBytes(uint64_t result, _BYTE *a2, uint64_t a3)
{
  uint64_t v3;
  int v4;

  if (result)
  {
    v3 = result;
    v4 = 0;
    LODWORD(result) = 0;
    do
    {
      if (v4 == 2)
      {
        if (*a2 > 3u)
        {
          v4 = 2;
        }
        else
        {
          v4 = 0;
          *(_BYTE *)(a3 + (int)result) = 3;
          LODWORD(result) = result + 1;
        }
      }
      *(_BYTE *)(a3 + (int)result) = *a2;
      if (*a2++)
        v4 = 0;
      else
        ++v4;
      result = (result + 1);
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t FigHEVCBridge_CreateUpdatedHVCCWithAdditionalHEVCParameterSets(int a1, const void *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, _QWORD *a7, _QWORD *a8, __CFData **a9)
{
  uint64_t v12;
  __CFArray *v14;
  uint64_t HEVCParameterSetAtIndex;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  char v19;
  char v20;
  char v21;
  CFDataRef v22;
  char v23;
  CFIndex v24;
  size_t v25;
  unint64_t v26;
  BOOL v27;
  unint64_t v28;
  uint64_t ArrayOfSEINALUnitsFromJumboSEINALUnit;
  char *v30;
  unint64_t v31;
  const UInt8 *v32;
  char *v33;
  size_t v34;
  unint64_t v35;
  CFIndex Count;
  CFIndex v37;
  _QWORD *v38;
  __CFArray *v39;
  __int16 v40;
  unint64_t v41;
  _QWORD *v42;
  char *v43;
  char v44;
  unsigned int v45;
  int v46;
  int v47;
  unsigned int v48;
  unint64_t v49;
  int v50;
  int v51;
  char v52;
  char v53;
  unsigned int v54;
  int v55;
  int v56;
  CFIndex v57;
  uint64_t v58;
  const void *ValueAtIndex;
  CFIndex Length;
  char *v61;
  uint64_t v62;
  _DWORD *v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  _DWORD *v70;
  uint64_t v71;
  unsigned int *v72;
  uint64_t v73;
  int v74;
  _QWORD *v75;
  uint64_t v76;
  uint64_t v77;
  __CFData *Mutable;
  __CFData *v79;
  uint64_t i;
  char *v81;
  uint64_t v82;
  _QWORD *v83;
  char *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  const UInt8 *v88;
  CFIndex v89;
  uint64_t v91;
  _QWORD *v92;
  unint64_t v93;
  int v94;
  unsigned int v95;
  unsigned int v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  const __CFAllocator *v104;
  const __CFAllocator *allocator;
  const __CFData *v106;
  unint64_t v109;
  unint64_t v110;
  __CFArray *v111;
  unint64_t v112;
  const UInt8 *BytePtr;
  unint64_t v114;
  UInt8 v115[4];
  int v116;
  unint64_t v117;
  CFTypeRef cf;
  UInt8 v119[32];
  __int128 v120;
  _OWORD v121[7];
  uint64_t v122;
  _OWORD v123[8];
  uint64_t v124;
  uint64_t v125;
  _BYTE v126[32];
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  _BYTE bytes[24];
  __int128 v133;
  _DWORD v134[8];
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  uint64_t v140;
  UInt8 v141[16];
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  uint64_t v147;
  uint64_t v148;

  v12 = a5;
  v148 = *MEMORY[0x1E0C80C00];
  v117 = 0;
  cf = 0;
  v116 = 0;
  v130 = 0u;
  v131 = 0u;
  v128 = 0u;
  v129 = 0u;
  *(_OWORD *)&v126[16] = 0u;
  v127 = 0u;
  *(_OWORD *)v126 = 0u;
  memset(v123, 0, sizeof(v123));
  v122 = 0;
  memset(v121, 0, sizeof(v121));
  v124 = 0x100000000;
  v125 = 2;
  *(_QWORD *)&v126[12] = 0x400000003;
  *(_DWORD *)v115 = 0;
  v114 = 0;
  if (a7)
    *a7 = 0;
  if (a8)
    *a8 = 0;
  if (!a4 || !a5 || a6 > 4 || ((1 << a6) & 0x16) == 0)
    goto LABEL_103;
  v14 = (__CFArray *)a9;
  if (!a9)
  {
    v77 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    goto LABEL_122;
  }
  *a9 = 0;
  if (a2)
  {
    HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(a2, 1, 0, 0, 0, 0, (unint64_t)&v117, &v116, 0, 0);
    if ((_DWORD)HEVCParameterSetAtIndex)
    {
LABEL_105:
      v77 = HEVCParameterSetAtIndex;
      v14 = 0;
      goto LABEL_122;
    }
    if (v116 != a6)
      goto LABEL_103;
  }
  if (a3 > 0x4FFFB || v117 > 0x4FFFB)
  {
LABEL_103:
    v76 = 4294954584;
LABEL_104:
    HEVCParameterSetAtIndex = FigSignalErrorAt(v76, 0, 0, 0, 0, 0, 0);
    goto LABEL_105;
  }
  v16 = malloc_type_calloc(v117 + a3, 0x20uLL, 0x10500408B07DF01uLL);
  if (!v16)
  {
    v76 = 4294954583;
    goto LABEL_104;
  }
  v17 = v16;
  v18 = v117;
  if (!(v117 + a3))
  {
    qsort(v16, 0, 0x20uLL, (int (__cdecl *)(const void *, const void *))FigHEVCBridge_sortParameterSetsByTypeThenIDThenBase);
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v97 = 0;
    LOWORD(v96) = 0;
    v100 = 0;
    v101 = 0;
    v14 = 0;
    v22 = 0;
    v23 = 0;
    v24 = 23;
LABEL_107:
    Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v24);
    if (Mutable)
    {
      v79 = Mutable;
      v106 = v22;
      v111 = v14;
      bytes[0] = 1;
      bytes[1] = (32 * (v101 & 1)) | (BYTE4(v101) << 6) | BYTE4(v100) & 0x1F;
      CFDataAppendBytes(Mutable, bytes, 2);
      *(_DWORD *)v115 = bswap32(*(unsigned int *)v115);
      CFDataAppendBytes(v79, v115, 4);
      v114 = bswap64(v114);
      CFDataAppendBytes(v79, (const UInt8 *)&v114 + 2, 6);
      bytes[0] = v100;
      bytes[1] = BYTE1(v96) | 0xF0;
      bytes[2] = v96;
      bytes[3] = -4;
      bytes[4] = BYTE4(v97) | 0xFC;
      bytes[5] = v97 | 0xF8;
      bytes[6] = v21 | 0xF8;
      *(_WORD *)&bytes[7] = 0;
      bytes[9] = (a6 + 3) & 3 | (8 * (v20 & 7)) | (4 * (v19 & 1));
      bytes[10] = v23;
      CFDataAppendBytes(v79, bytes, 11);
      for (i = 0; i != 5; ++i)
      {
        v81 = (char *)v121 + 24 * i;
        v82 = *((unsigned __int16 *)v81 + 6);
        if (*((_WORD *)v81 + 6))
        {
          v83 = v17;
          v84 = (char *)v121 + 24 * i;
          *(_WORD *)v141 = 0;
          *(_WORD *)v119 = 0;
          bytes[0] = v84[16] & 0x3F | 0x80;
          CFDataAppendBytes(v79, bytes, 1);
          *(_WORD *)v119 = bswap32(v82 - *((unsigned __int16 *)v84 + 7)) >> 16;
          CFDataAppendBytes(v79, v119, 2);
          v85 = 0;
          v86 = *(_QWORD *)v84;
          v87 = v86 + 8;
          do
          {
            if (!v85
              || *(_DWORD *)(v87 - 8) != *(_DWORD *)(v86 + 32 * (v85 - 1))
              || *(_DWORD *)(v87 - 4) != *(_DWORD *)(v86 + 32 * (v85 - 1) + 4))
            {
              v88 = *(const UInt8 **)v87;
              v89 = *(_QWORD *)(v87 + 8);
              *(_WORD *)v141 = bswap32(v89) >> 16;
              CFDataAppendBytes(v79, v141, 2);
              CFDataAppendBytes(v79, v88, v89);
            }
            ++v85;
            v87 += 32;
          }
          while (v82 != v85);
          v17 = v83;
        }
      }
      v77 = 0;
      *a9 = v79;
      v14 = v111;
LABEL_119:
      v22 = v106;
      goto LABEL_120;
    }
LABEL_134:
    v91 = 4294954583;
LABEL_129:
    ArrayOfSEINALUnitsFromJumboSEINALUnit = FigSignalErrorAt(v91, 0, 0, 0, 0, 0, 0);
LABEL_130:
    v77 = ArrayOfSEINALUnitsFromJumboSEINALUnit;
    goto LABEL_120;
  }
  v109 = a3;
  v92 = a7;
  v97 = 0;
  v98 = 0;
  v95 = 0;
  v96 = 0;
  v100 = 0;
  v101 = 0;
  v25 = 0;
  v99 = 0;
  v103 = 0;
  v93 = 0;
  v26 = 0;
  v14 = 0;
  v22 = 0;
  v104 = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v94 = -1;
  v102 = v12;
  while (2)
  {
    v112 = 0;
    BytePtr = 0;
    v27 = v26 >= v18;
    v28 = v26 - v18;
    if (v27)
    {
      v32 = *(const UInt8 **)(a4 + 8 * v28);
      v31 = *(_QWORD *)(v12 + 8 * v28);
      v112 = v31;
      BytePtr = v32;
      v33 = (char *)&v17[4 * v25];
      v33[24] = 0;
      *((_QWORD *)v33 + 1) = v32;
    }
    else
    {
      ArrayOfSEINALUnitsFromJumboSEINALUnit = hevcbridge_getHEVCParameterSetAtIndex(a2, 1, 0, v26, (unint64_t)&BytePtr, (unint64_t)&v112, 0, 0, 0, 0);
      if ((_DWORD)ArrayOfSEINALUnitsFromJumboSEINALUnit)
        goto LABEL_130;
      v30 = (char *)&v17[4 * v25];
      v30[24] = 1;
      *((_QWORD *)v30 + 1) = BytePtr;
      v31 = v112;
    }
    v17[4 * v25 + 2] = v31;
    if (v112 >= 0x10000)
    {
LABEL_128:
      v91 = 4294954584;
      goto LABEL_129;
    }
    if (!v112)
    {
      v91 = 4294954584;
      goto LABEL_129;
    }
    if (!BytePtr)
    {
      v91 = 4294954584;
      goto LABEL_129;
    }
    v110 = v26;
    v34 = v25;
    v35 = ((unint64_t)*BytePtr >> 1) & 0x3F;
    switch((int)v35)
    {
      case ' ':
        v147 = 0;
        v145 = 0u;
        v146 = 0u;
        v143 = 0u;
        v144 = 0u;
        *(_OWORD *)v141 = 0u;
        v142 = 0u;
        v140 = 0;
        v138 = 0u;
        v139 = 0u;
        v136 = 0u;
        v137 = 0u;
        v135 = 0u;
        v133 = 0u;
        memset(v134, 0, sizeof(v134));
        LODWORD(v120) = 0;
        memset(v119, 0, sizeof(v119));
        ArrayOfSEINALUnitsFromJumboSEINALUnit = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v141, (uint64_t)BytePtr, v112, 1);
        if ((_DWORD)ArrayOfSEINALUnitsFromJumboSEINALUnit)
          goto LABEL_130;
        LOBYTE(v134[0]) = 1;
        *(_QWORD *)&v134[1] = 49;
        v134[5] = 1048639;
        *(_QWORD *)bytes = v119;
        *(_QWORD *)&bytes[8] = hevcbridgeParseVPSForHVCCCallbackFlag;
        *(_QWORD *)&bytes[16] = hevcbridgeParseVPSForHVCCCallbackUnsigned;
        ArrayOfSEINALUnitsFromJumboSEINALUnit = hevcbridgeParseNALUnit(v141, bytes);
        if ((_DWORD)ArrayOfSEINALUnitsFromJumboSEINALUnit)
          goto LABEL_130;
        v44 = BYTE1(v120);
        v46 = *(_DWORD *)&v119[8];
        v45 = *(_DWORD *)&v119[12];
        v47 = *(_DWORD *)&v119[16];
        v48 = *(_DWORD *)&v119[28];
        v49 = *(unsigned int *)&v119[24] | ((unint64_t)*(unsigned int *)&v119[20] << 32);
        v50 = *(_DWORD *)v119;
        v51 = *(_DWORD *)&v119[4] + 1;
        v52 = v120;
        if (!*((_WORD *)v121 + 12 * (int)v124 + 6)
          || *((_WORD *)v121 + 12 * (int)v124 + 6) == 1 && *((_DWORD *)v121 + 6 * (int)v124 + 2) == *(_DWORD *)v119)
        {
          v53 = 0;
          *((_BYTE *)&v121[1] + 24 * (int)v124) = 32;
          LOBYTE(v101) = v44;
          HIDWORD(v101) = v46;
          *(_DWORD *)v115 = v47;
          v114 = v49;
          v100 = __PAIR64__(v45, v48);
          LOBYTE(v98) = v52;
          HIDWORD(v98) = v51;
        }
        else
        {
          if (HIDWORD(v101) != *(_DWORD *)&v119[8]
            || BYTE1(v120) != v101
            || __PAIR64__(*(unsigned int *)v115, HIDWORD(v100)) != *(_QWORD *)&v119[12]
            || v114 != v49
            || (_DWORD)v100 != *(_DWORD *)&v119[28]
            || HIDWORD(v98) != v51
            || v120 != v98)
          {
            goto LABEL_128;
          }
LABEL_71:
          v53 = 0;
        }
        goto LABEL_87;
      case '!':
        v147 = 0;
        v145 = 0u;
        v146 = 0u;
        v143 = 0u;
        v144 = 0u;
        *(_OWORD *)v141 = 0u;
        v142 = 0u;
        v140 = 0;
        v138 = 0u;
        v139 = 0u;
        v136 = 0u;
        v137 = 0u;
        v135 = 0u;
        v133 = 0u;
        memset(v134, 0, sizeof(v134));
        v120 = 0u;
        memset(v119, 0, sizeof(v119));
        ArrayOfSEINALUnitsFromJumboSEINALUnit = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v141, (uint64_t)BytePtr, v112, 1);
        if ((_DWORD)ArrayOfSEINALUnitsFromJumboSEINALUnit)
          goto LABEL_130;
        LOBYTE(v134[0]) = 3;
        *(_QWORD *)&v134[1] = 0x8000003F690;
        *(_QWORD *)&v134[3] = 17408;
        *(_QWORD *)bytes = v119;
        *(_QWORD *)&bytes[8] = hevcbridgeParseSPSForHVCCCallbackFlag;
        *(_QWORD *)&bytes[16] = hevcbridgeParseSPSForHVCCCallbackUnsigned;
        ArrayOfSEINALUnitsFromJumboSEINALUnit = hevcbridgeParseNALUnit(v141, bytes);
        if ((_DWORD)ArrayOfSEINALUnitsFromJumboSEINALUnit)
          goto LABEL_130;
        v50 = *(_DWORD *)&v119[4];
        if (*(_DWORD *)v119)
          goto LABEL_71;
        v54 = *(_DWORD *)&v119[8];
        if (*(_DWORD *)&v119[8] == 2)
        {
          v56 = -1;
          v55 = -2;
        }
        else if (*(_DWORD *)&v119[8] == 1)
        {
          v55 = -2;
          v56 = -2;
        }
        else
        {
          v55 = -1;
          v56 = -1;
        }
        v65 = *(_DWORD *)&v119[12];
        v64 = *(_DWORD *)&v119[16];
        v66 = *(_DWORD *)&v119[20];
        v67 = (*(_DWORD *)&v119[24] + (DWORD1(v120) + v120) * v55);
        v68 = (*(_DWORD *)&v119[28] + (HIDWORD(v120) + DWORD2(v120)) * v56);
        if (!v99 || v99 == 1 && v94 == *(_DWORD *)&v119[4])
        {
          *((_BYTE *)&v121[1] + 24 * SHIDWORD(v124)) = 33;
          if (v92)
            *v92 = v67;
          v93 = __PAIR64__(v67, v68);
          if (a8)
            *a8 = v68;
          v96 = v66;
          v97 = __PAIR64__(v54, v65);
          v95 = v64;
        }
        else if (v97 != __PAIR64__(*(unsigned int *)&v119[8], *(unsigned int *)&v119[12])
               || __PAIR64__(v96, v95) != *(_QWORD *)&v119[16]
               || v93 != __PAIR64__(v67, v68))
        {
          goto LABEL_128;
        }
        v53 = 0;
        ++v99;
        v94 = v50;
        goto LABEL_87;
      case '"':
        v147 = 0;
        v145 = 0u;
        v146 = 0u;
        v143 = 0u;
        v144 = 0u;
        *(_OWORD *)v141 = 0u;
        v142 = 0u;
        v140 = 0;
        v138 = 0u;
        v139 = 0u;
        v136 = 0u;
        v137 = 0u;
        v135 = 0u;
        v133 = 0u;
        memset(v134, 0, sizeof(v134));
        *(_OWORD *)&bytes[8] = 0u;
        *(_DWORD *)v119 = 0;
        ArrayOfSEINALUnitsFromJumboSEINALUnit = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v141, (uint64_t)BytePtr, v112, 1);
        if ((_DWORD)ArrayOfSEINALUnitsFromJumboSEINALUnit)
          goto LABEL_130;
        LOBYTE(v134[0]) = 1;
        *(_QWORD *)&v134[3] = 0;
        *(_QWORD *)&v134[1] = 1;
        *(_QWORD *)bytes = v119;
        *(_QWORD *)&bytes[16] = hevcbridgeParsePPSForHVCCCallbackUnsigned;
        ArrayOfSEINALUnitsFromJumboSEINALUnit = hevcbridgeParseNALUnit(v141, bytes);
        if ((_DWORD)ArrayOfSEINALUnitsFromJumboSEINALUnit)
          goto LABEL_130;
        v53 = 0;
        v50 = *(_DWORD *)v119;
        goto LABEL_87;
      case '\'':
      case '(':
        if (v22)
          CFRelease(v22);
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
        v22 = CFDataCreateWithBytesNoCopy(allocator, BytePtr, v112, v104);
        ArrayOfSEINALUnitsFromJumboSEINALUnit = FigHEVCBridge_CreateArrayOfSEINALUnitsFromJumboSEINALUnit(v22, (__CFArray **)&cf);
        if ((_DWORD)ArrayOfSEINALUnitsFromJumboSEINALUnit)
          goto LABEL_130;
        if (!v14)
        {
          v14 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
          if (!v14)
            goto LABEL_134;
        }
        Count = CFArrayGetCount((CFArrayRef)cf);
        v37 = Count;
        if (Count < 2)
        {
          if (Count == 1)
          {
            v106 = v22;
LABEL_55:
            v57 = 0;
            v58 = 4 * v34;
            while (1)
            {
              ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, v57);
              CFArrayAppendValue(v14, ValueAtIndex);
              if (v57)
                LOBYTE(v17[v58 + 3]) = v17[v58 - 1];
              BytePtr = CFDataGetBytePtr((CFDataRef)ValueAtIndex);
              Length = CFDataGetLength((CFDataRef)ValueAtIndex);
              v112 = Length;
              v61 = (char *)&v17[v58];
              *((_QWORD *)v61 + 1) = BytePtr;
              *((_QWORD *)v61 + 2) = Length;
              v147 = 0;
              v145 = 0u;
              v146 = 0u;
              v143 = 0u;
              v144 = 0u;
              *(_OWORD *)v141 = 0u;
              v142 = 0u;
              v140 = 0;
              v138 = 0u;
              v139 = 0u;
              v136 = 0u;
              v137 = 0u;
              v135 = 0u;
              v133 = 0u;
              memset(v134, 0, sizeof(v134));
              *(_OWORD *)&bytes[8] = 0u;
              *(_DWORD *)v119 = 0;
              v62 = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v141, (uint64_t)BytePtr, v112, 1);
              if ((_DWORD)v62)
                break;
              LOBYTE(v134[0]) = 1;
              LOBYTE(v134[1]) = 4;
              *(_QWORD *)bytes = v119;
              *(_QWORD *)&bytes[16] = hevcbridgeParseSEIForHVCCCallbackUnsigned;
              v62 = hevcbridgeParseNALUnit(v141, bytes);
              if ((_DWORD)v62)
                break;
              v50 = *(_DWORD *)v119;
              v63 = &v17[v58];
              *v63 = v35;
              v63[1] = v50;
              ++v57;
              v58 += 4;
              if (v37 == v57)
              {
                v34 += v57;
                v53 = 1;
                v22 = v106;
                goto LABEL_63;
              }
            }
            v77 = v62;
            goto LABEL_119;
          }
          v50 = 0;
          v53 = 1;
LABEL_63:
          v12 = v102;
LABEL_87:
          v69 = (char *)v121 + 24 * *((int *)v123 + v35);
          v69[16] = v35;
          ++*((_WORD *)v69 + 6);
          *((_DWORD *)v69 + 2) = v50;
          if ((v53 & 1) != 0)
          {
            v25 = v34;
          }
          else
          {
            v70 = &v17[4 * v34];
            *v70 = v35;
            v70[1] = v50;
            v25 = v34 + 1;
          }
          v26 = v110 + 1;
          v18 = v117;
          if (v110 + 1 >= v117 + v109)
          {
            qsort(v17, v25, 0x20uLL, (int (__cdecl *)(const void *, const void *))FigHEVCBridge_sortParameterSetsByTypeThenIDThenBase);
            v23 = 0;
            if (!v25)
            {
              v24 = 23;
              v19 = v98;
              v20 = BYTE4(v98);
              v21 = v95;
              goto LABEL_107;
            }
            v71 = 0;
            v24 = 23;
            v72 = (unsigned int *)v17;
            v19 = v98;
            v20 = BYTE4(v98);
            v21 = v95;
            while (2)
            {
              v73 = *v72;
              v74 = *((_DWORD *)v123 + v73);
              v75 = (_QWORD *)v121 + 3 * v74;
              if (*v75)
              {
                if (!v71)
                  goto LABEL_100;
              }
              else
              {
                *v75 = v72;
                v24 += 3;
                ++v23;
                if (!v71)
                  goto LABEL_100;
              }
              if ((_DWORD)v73 == *(v72 - 8) && v72[1] == *(v72 - 7))
                ++*((_WORD *)v121 + 12 * v74 + 7);
              else
LABEL_100:
                v24 += *((_QWORD *)v72 + 2) + 2;
              ++v71;
              v72 += 8;
              if (v25 == v71)
                goto LABEL_107;
              continue;
            }
          }
          continue;
        }
        v38 = v17;
        v39 = v14;
        v40 = Count - 1;
        v41 = Count - 1 + v103;
        if (v41 >= 0x10000)
        {
          v77 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
          v14 = v39;
          v17 = v38;
        }
        else
        {
          v103 += Count - 1;
          v42 = malloc_type_realloc(v38, 32 * (v41 + v109 + v117), 0x10500408B07DF01uLL);
          if (v42)
          {
            v106 = v22;
            v43 = (char *)v121 + 24 * *((int *)v123 + v35);
            *((_WORD *)v43 + 6) += v40;
            v14 = v39;
            v17 = v42;
            goto LABEL_55;
          }
          free(v38);
          v77 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
          v14 = v39;
          v17 = 0;
        }
LABEL_120:
        free(v17);
        if (v22)
          CFRelease(v22);
LABEL_122:
        if (cf)
          CFRelease(cf);
        if (v14)
          CFRelease(v14);
        return v77;
      default:
        goto LABEL_128;
    }
  }
}

uint64_t FigHEVCBridge_GetHEVCParameterSetAtIndex(const void *a1, int a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, _DWORD *a7)
{
  return hevcbridge_getHEVCParameterSetAtIndex(a1, 1, a2, a3, a4, a5, a6, a7, 0, 0);
}

uint64_t FigHEVCBridge_CreateArrayOfSEINALUnitsFromJumboSEINALUnit(const __CFData *a1, __CFArray **a2)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v6;
  uint64_t Count;
  CFIndex v8;
  const __CFData *ValueAtIndex;
  CFIndex v10;
  __CFData *v11;
  __CFData *v12;
  CFIndex v13;
  UInt8 *MutableBytePtr;
  UInt8 *v15;
  const UInt8 *v16;
  CFIndex v17;
  uint64_t v18;
  int v19;
  UInt8 *v21;
  UInt8 *v22;
  uint64_t v23;
  uint64_t v24;
  __CFArray **v26;
  uint64_t v27;
  const __CFAllocator *allocator;
  __CFArray *Mutable;
  CFArrayRef theArray;
  UInt8 bytes;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  _OWORD v42[6];
  uint64_t v43;
  uint64_t v44;
  CFRange v45;

  v44 = *MEMORY[0x1E0C80C00];
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  theArray = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!theArray)
    return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  v43 = 0;
  memset(v42, 0, sizeof(v42));
  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  v6 = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v42, (uint64_t)BytePtr, Length, 1);
  if (!(_DWORD)v6)
  {
    BYTE8(v34) |= 1u;
    BYTE12(v34) |= 1u;
    *(_QWORD *)&v32 = &theArray;
    *(_QWORD *)&v33 = hevcbridgeParseSEIForSplitterCallbackUnsigned;
    *(_QWORD *)&v34 = hevcbridgeParseSEIForSplitterCallbackCFData;
    v6 = hevcbridgeParseNALUnit(v42, &v32);
    if (!(_DWORD)v6)
    {
      Count = CFArrayGetCount(theArray);
      Mutable = CFArrayCreateMutable(allocator, Count, MEMORY[0x1E0C9B378]);
      if (Mutable)
      {
        v26 = a2;
        if (Count == 1)
        {
          CFArrayAppendValue(Mutable, a1);
LABEL_35:
          v23 = 0;
          *v26 = Mutable;
          goto LABEL_36;
        }
        if (Count < 1)
          goto LABEL_35;
        v8 = 0;
        v27 = Count;
        while (1)
        {
          ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(theArray, v8);
          bytes = 0x80;
          if (CFDataGetLength(a1) <= 1)
            break;
          v10 = CFDataGetLength(ValueAtIndex);
          v11 = CFDataCreateMutable(allocator, 0);
          if (!v11)
          {
            v24 = 4294954583;
            goto LABEL_32;
          }
          v12 = v11;
          v13 = v10 + 2;
          CFDataSetLength(v11, v10 + 2);
          MutableBytePtr = CFDataGetMutableBytePtr(v12);
          if (!MutableBytePtr)
          {
LABEL_29:
            v23 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
            CFRelease(v12);
            Count = v27;
LABEL_33:
            if ((_DWORD)v23)
            {
              CFRelease(Mutable);
              goto LABEL_36;
            }
            CFArrayAppendValue(Mutable, 0);
            goto LABEL_27;
          }
          v15 = MutableBytePtr;
          v16 = CFDataGetBytePtr(ValueAtIndex);
          v45.location = 0;
          v45.length = 2;
          CFDataGetBytes(a1, v45, v15);
          if (v10 >= 1)
          {
            v17 = 0;
            v18 = 2;
            do
            {
              v19 = v16[v17];
              if (v17 + 2 < v10 && v19 == 0)
              {
                if (!v16[v17 + 1] && v16[v17 + 2] <= 3u)
                {
                  CFDataSetLength(v12, ++v13);
                  v21 = CFDataGetMutableBytePtr(v12);
                  if (!v21)
                    goto LABEL_29;
                  v15 = v21;
                  v22 = &v21[v18];
                  *v22 = v16[v17];
                  v18 += 2;
                  v22[1] = v16[v17 + 1];
                  v21[v18] = 3;
                  ++v17;
                  goto LABEL_25;
                }
                LOBYTE(v19) = 0;
              }
              v15[v18] = v19;
LABEL_25:
              ++v18;
              ++v17;
            }
            while (v17 < v10);
          }
          CFDataAppendBytes(v12, &bytes, 1);
          CFArrayAppendValue(Mutable, v12);
          CFRelease(v12);
          Count = v27;
LABEL_27:
          if (++v8 == Count)
            goto LABEL_35;
        }
        v24 = 4294954584;
LABEL_32:
        v23 = FigSignalErrorAt(v24, 0, 0, 0, 0, 0, 0);
        goto LABEL_33;
      }
      v6 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    }
  }
  v23 = v6;
LABEL_36:
  if (theArray)
    CFRelease(theArray);
  return v23;
}

uint64_t FigHEVCBridge_sortParameterSetsByTypeThenIDThenBase(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  unsigned int v4;

  if (*(_DWORD *)a1 < *(_DWORD *)a2)
    return 0xFFFFFFFFLL;
  if (*(_DWORD *)a1 > *(_DWORD *)a2)
    return 1;
  v3 = *(_DWORD *)(a1 + 4);
  v4 = *(_DWORD *)(a2 + 4);
  if (v3 < v4)
    return 0xFFFFFFFFLL;
  if (v3 > v4)
    return 1;
  if (!*(_BYTE *)(a1 + 24))
  {
    if (!*(_BYTE *)(a2 + 24))
      return 0;
    return 0xFFFFFFFFLL;
  }
  return !*(_BYTE *)(a2 + 24);
}

uint64_t hevcbridge_getHEVCParameterSetAtIndex(CFTypeRef cf, int a2, int a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, _DWORD *a8, uint64_t a9, uint64_t a10)
{
  CFTypeID v16;
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t v19;
  const UInt8 *v20;
  uint64_t v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const UInt8 *v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v36;
  uint64_t v39;
  int v40;
  unint64_t v41;

  if (a5)
    *(_QWORD *)a5 = 0;
  if (a6)
    *(_QWORD *)a6 = 0;
  if (a7)
    *(_QWORD *)a7 = 0;
  if (a8)
    *a8 = 0;
  if (!cf)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v16 = CFGetTypeID(cf);
  if (v16 != CFDataGetTypeID())
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  Length = CFDataGetLength((CFDataRef)cf);
  BytePtr = CFDataGetBytePtr((CFDataRef)cf);
  v19 = 22;
  if (!a2)
    v19 = 5;
  if (Length <= v19)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v20 = BytePtr;
  if (*BytePtr != 1)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (!a8)
    goto LABEL_55;
  v21 = 21;
  if (!a2)
    v21 = 4;
  *a8 = (BytePtr[v21] & 3) + 1;
  if (a7 || a5 || a6 || a9)
  {
LABEL_55:
    v36 = BytePtr[v19];
    if (BytePtr[v19])
    {
      v22 = 0;
      v23 = 0;
      v24 = 0;
      v25 = v19 + 1;
      while (1)
      {
        v40 = v22;
        v41 = v23;
        v26 = v25 + 3;
        if (Length < v25 + 3)
          return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        v27 = &v20[v25];
        v28 = __rev16(*(unsigned __int16 *)(v27 + 1));
        if (a3)
          v29 = (*v27 & 0x3F) == a3;
        else
          v29 = 1;
        v30 = v29;
        if (v29)
          v31 = v28;
        else
          v31 = 0;
        v39 = v31;
        if ((_DWORD)v28)
        {
          while (1)
          {
            v32 = v26 + 2;
            if (Length < v26 + 2)
              break;
            v33 = __rev16(*(unsigned __int16 *)&v20[v26]);
            v26 = v33 + v32;
            if (Length < v33 + v32)
              break;
            if (a4 == v24)
              v34 = v30;
            else
              v34 = 0;
            if (v34 == 1)
            {
              if (a5)
                *(_QWORD *)a5 = &v20[v32];
              if (a6)
                *(_QWORD *)a6 = v33;
              if (!(a7 | a9))
                return 0;
            }
            if (a9)
              ((void (*)(uint64_t, uint64_t, const UInt8 *))a9)(a10, v24, &v20[v32]);
            v24 += v30;
            LODWORD(v28) = v28 - 1;
            if (!(_DWORD)v28)
              goto LABEL_49;
          }
          return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        }
LABEL_49:
        v23 = v39 + v41;
        v22 = v40 + 1;
        v25 = v26;
        if (v40 + 1 == v36)
          goto LABEL_52;
      }
    }
    v23 = 0;
LABEL_52:
    if (a7)
      *(_QWORD *)a7 = v23;
    if (a5 | a6 && v23 <= a4)
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  return 0;
}

uint64_t FigHEVCBridge_VisitAllHEVCParameterSets(const void *a1, int a2, unint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  return hevcbridge_getHEVCParameterSetAtIndex(a1, 1, a2, 0, 0, 0, a3, a4, a5, a6);
}

uint64_t FigHEVCBridge_GetHEVCParameterSetFromLHVCAtIndex(const void *a1, int a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, _DWORD *a7)
{
  return hevcbridge_getHEVCParameterSetAtIndex(a1, 0, a2, a3, a4, a5, a6, a7, 0, 0);
}

uint64_t FigHEVCBridge_CopyHEVCSEIPayloadData(CFTypeRef cf, __int16 a2, CFTypeRef *a3)
{
  int v6;
  uint64_t HEVCParameterSetAtIndex;
  unint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  __int128 *v15;
  CFTypeRef cfa;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _OWORD v27[6];
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  v15 = 0;
  cfa = 0;
  v6 = 39;
  while (1)
  {
    v13 = 0;
    HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(cf, 1, v6, 0, 0, 0, (unint64_t)&v13, 0, 0, 0);
    if ((_DWORD)HEVCParameterSetAtIndex)
      break;
    if (v13)
    {
      v8 = 0;
      do
      {
        v11 = 0;
        v12 = 0;
        HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(cf, 1, v6, v8, (unint64_t)&v12, (unint64_t)&v11, 0, 0, 0, 0);
        if ((_DWORD)HEVCParameterSetAtIndex)
          goto LABEL_16;
        v28 = 0;
        memset(v27, 0, sizeof(v27));
        v25 = 0u;
        v26 = 0u;
        v23 = 0u;
        v24 = 0u;
        v21 = 0u;
        v22 = 0u;
        v19 = 0u;
        v20 = 0u;
        v17 = 0u;
        v18 = 0u;
        LOWORD(v14) = a2;
        v15 = &v17;
        cfa = 0;
        HEVCParameterSetAtIndex = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v27, v12, v11, 1);
        if ((_DWORD)HEVCParameterSetAtIndex)
          goto LABEL_16;
        BYTE8(v19) |= 1u;
        BYTE12(v19) = BYTE12(v19) & 0xCB | 4;
        *(_QWORD *)&v17 = &v14;
        *(_QWORD *)&v18 = hevcbridgeParseSEITypeCallbackUnsigned;
        HEVCParameterSetAtIndex = hevcbridgeParseNALUnit(v27, &v17);
        if ((_DWORD)HEVCParameterSetAtIndex)
          goto LABEL_16;
        if (cfa)
        {
          v9 = 0;
          *a3 = cfa;
          cfa = 0;
          goto LABEL_13;
        }
      }
      while (++v8 < v13);
    }
    if (++v6 == 41)
    {
      v9 = 0;
      *a3 = 0;
      goto LABEL_13;
    }
  }
LABEL_16:
  v9 = HEVCParameterSetAtIndex;
LABEL_13:
  if (cfa)
    CFRelease(cfa);
  return v9;
}

uint64_t hevcbridgeParseSEITypeCallbackUnsigned(unsigned __int16 *a1, int a2, int a3)
{
  uint64_t (*v4)(uint64_t, int, CFTypeRef);

  if (a2 == 344)
  {
    v4 = hevcbridgeParseSEIPayloadData;
    if (*a1 != a3)
      v4 = 0;
    *(_BYTE *)(*((_QWORD *)a1 + 1) + 44) = *(_BYTE *)(*((_QWORD *)a1 + 1) + 44) & 0xDF | (32 * (*a1 == a3));
    *(_QWORD *)(*((_QWORD *)a1 + 1) + 32) = v4;
  }
  else if (a2 || (a3 - 41) < 0xFFFFFFFE)
  {
    return 4294954584;
  }
  return 0;
}

uint64_t FigHEVCBridge_GetATCSEI(const void *a1, UInt8 *a2)
{
  uint64_t v3;
  const __CFData *v4;
  CFTypeID v5;
  uint64_t v6;
  CFTypeRef cf;
  CFRange v9;

  cf = 0;
  if (a2)
  {
    v3 = FigHEVCBridge_CopyHEVCSEIPayloadData(a1, 147, &cf);
    v4 = (const __CFData *)cf;
    if ((_DWORD)v3)
    {
      v6 = v3;
      if (!cf)
        return v6;
    }
    else
    {
      if (!cf)
        return 4294954578;
      v5 = CFGetTypeID(cf);
      if (v5 == CFDataGetTypeID() && CFDataGetLength(v4) == 1)
      {
        v9.location = 0;
        v9.length = 1;
        CFDataGetBytes(v4, v9, a2);
        v6 = 0;
      }
      else
      {
        v6 = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
      }
    }
    CFRelease(v4);
    return v6;
  }
  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t hevcbridgeParseSEIForSplitterCallbackUnsigned(uint64_t a1, int a2, int a3)
{
  unsigned int v3;

  if ((a3 - 41) >= 0xFFFFFFFE)
    v3 = 0;
  else
    v3 = -12712;
  if (a2)
    return 4294954584;
  else
    return v3;
}

uint64_t hevcbridgeParseSEIForSplitterCallbackCFData(CFMutableArrayRef *a1, int a2, void *value)
{
  if (a2 != 342)
    return 4294954584;
  CFArrayAppendValue(*a1, value);
  return 0;
}

uint64_t FigHEVCBridge_GetNALUnitHeaderLengthFromHVCC(const __CFData *a1, _QWORD *a2)
{
  const UInt8 *BytePtr;
  uint64_t v5;

  BytePtr = CFDataGetBytePtr(a1);
  if ((unint64_t)CFDataGetLength(a1) < 0x16)
    return 4294954582;
  v5 = BytePtr[21] & 3;
  *a2 = v5 + 1;
  if (v5 < 2 || (_DWORD)v5 == 3)
    return 0;
  else
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t FigHEVCBridge_CreateHVCCFromHEVCParameterSets(int a1, unint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, _QWORD *a6, _QWORD *a7, __CFData **a8)
{
  return FigHEVCBridge_CreateUpdatedHVCCWithAdditionalHEVCParameterSets(a1, 0, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t FigHEVCBridge_CreateSelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord(const void *a1, int a2, const __CFArray *a3, const __CFArray *a4, __CFData **a5)
{
  CFTypeID v10;
  CFIndex Count;
  const __CFData *MutableCopy;
  __CFData *v13;
  CFIndex Length;
  UInt8 *MutableBytePtr;
  UInt8 *v16;
  uint64_t v17;
  uint64_t v18;
  int v20;
  uint64_t v21;
  CFIndex v22;
  unsigned int v23;
  uint64_t v24;
  CFIndex v25;
  uint64_t v26;
  UInt8 *v27;
  unsigned int v28;
  uint64_t v29;
  int v30;
  int v31;
  CFIndex FirstIndexOfInt32;
  __int16 v34;
  UInt8 *v35;
  __CFData *v36;
  CFRange v37;
  CFIndex v38;
  uint64_t v39;
  uint64_t v40;
  __CFData **v41;
  int v42;
  CFIndex v43;
  unsigned int v44;
  CFIndex range;
  CFIndex range_8;
  int v47;
  int v48;
  const __CFArray *theArray;
  unsigned int v50;
  int v51;
  const __CFArray *v52;
  UInt8 newBytes[2];
  char v54;
  int v55;
  CFRange v56;
  CFRange v57;

  if (!a1
    || (v10 = CFGetTypeID(a1), v10 != CFDataGetTypeID())
    || !a3
    || CFArrayGetCount(a3) <= 0
    || a4 && (Count = CFArrayGetCount(a4), Count != CFArrayGetCount(a3)))
  {
    v18 = 4294954584;
    return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
  }
  MutableCopy = CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, (CFDataRef)a1);
  if (!MutableCopy)
  {
    v18 = 4294954583;
    return FigSignalErrorAt(v18, 0, 0, 0, 0, 0, 0);
  }
  v13 = MutableCopy;
  v52 = a3;
  Length = CFDataGetLength(MutableCopy);
  MutableBytePtr = CFDataGetMutableBytePtr(v13);
  v16 = MutableBytePtr;
  theArray = a4;
  v41 = a5;
  if (a2)
  {
    if (Length > 5 && *MutableBytePtr == 1)
    {
      v17 = 5;
      goto LABEL_17;
    }
LABEL_47:
    v40 = 4294954581;
LABEL_45:
    v39 = FigSignalErrorAt(v40, 0, 0, 0, 0, 0, 0);
    CFRelease(v13);
    return v39;
  }
  if (Length <= 22 || *MutableBytePtr != 1)
    goto LABEL_47;
  v17 = 22;
LABEL_17:
  v43 = v17;
  v47 = MutableBytePtr[v17];
  if (MutableBytePtr[v17])
  {
    v48 = 0;
    v20 = 0;
    v21 = v17 + 1;
    while (1)
    {
      v22 = v21 + 3;
      if (Length < v21 + 3)
        break;
      v42 = v20;
      range_8 = v21 + 1;
      v23 = __rev16(*(unsigned __int16 *)&v16[v21 + 1]);
      if (v23)
      {
        v50 = v23;
        v51 = 0;
        range = v21;
        v24 = v16[v21] & 0x3F;
        v44 = v24 - 33;
        while (1)
        {
          v25 = v22 + 2;
          if (Length < v22 + 2)
            goto LABEL_44;
          v26 = __rev16(*(unsigned __int16 *)&v16[v22]);
          if (Length < v25 + v26
            || v26 <= 1
            || (char)v16[v25] < 0
            || ((v16[v25] >> 1) & 0x3F) != (_DWORD)v24)
          {
            goto LABEL_44;
          }
          v27 = v16;
          v28 = v16[v22 + 3] | (v16[v25] << 8);
          v55 = 0;
          v29 = v24;
          v30 = FigCFArrayContainsInt32(v52, (v28 >> 3) & 0x3F);
          v24 = v29;
          if ((_DWORD)v29 != 32 && !v30)
          {
            v56.length = v26 + 2;
            v56.location = v22;
            CFDataDeleteBytes(v13, v56);
            v31 = v51 + 1;
            if (v50 == (unsigned __int16)++v51)
            {
              v57.location = range;
              v57.length = 3;
              CFDataDeleteBytes(v13, v57);
              v54 = v47 - ++v48;
              v35 = (UInt8 *)&v54;
              v36 = v13;
              v37.location = v43;
              v37.length = 1;
              v38 = 1;
            }
            else
            {
              *(_WORD *)newBytes = bswap32(v50 - v31) >> 16;
              v35 = newBytes;
              v36 = v13;
              v37.location = range_8;
              v37.length = 2;
              v38 = 2;
            }
            CFDataReplaceBytes(v36, v37, v35, v38);
            v16 = CFDataGetMutableBytePtr(v13);
            Length = CFDataGetLength(v13);
            v24 = v29;
            goto LABEL_41;
          }
          if (!theArray)
            break;
          if (CFArrayGetCount(theArray) < 1
            || v44 > 1
            || (FirstIndexOfInt32 = FigCFArrayGetFirstIndexOfInt32(v52, (v28 >> 3) & 0x3F), FirstIndexOfInt32 == -1))
          {
            v22 = v25 + v26;
            v24 = v29;
LABEL_40:
            v16 = v27;
            goto LABEL_41;
          }
          FigCFArrayGetInt32AtIndex(theArray, FirstIndexOfInt32, &v55);
          v34 = (8 * (v55 & 0x1FFF)) | v28 & 0xFE07;
          v16 = v27;
          v27[v25] = HIBYTE(v34);
          v27[v22 + 3] = v34;
          v22 = v25 + v26;
          v24 = v29;
LABEL_41:
          if (!--v23)
            goto LABEL_42;
        }
        v22 = v25 + v26;
        goto LABEL_40;
      }
LABEL_42:
      v20 = v42 + 1;
      v21 = v22;
      if (v42 + 1 == v47)
        goto LABEL_43;
    }
LABEL_44:
    v40 = 4294954582;
    goto LABEL_45;
  }
LABEL_43:
  v39 = 0;
  *v41 = v13;
  return v39;
}

uint64_t FigHEVCBridge_CreateSelectedLayerHVCCFromMuxedAlphaHVCC(const void *a1, int a2, __CFData **a3)
{
  const __CFAllocator *v6;
  CFMutableArrayRef Mutable;
  const __CFArray *v8;
  CFMutableArrayRef v9;
  const __CFArray *v10;
  uint64_t SelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord;
  const __CFArray *v12;

  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v8 = Mutable;
    FigCFArrayAppendInt32(Mutable, a2);
    if (a2)
    {
      v9 = CFArrayCreateMutable(v6, 0, MEMORY[0x1E0C9B378]);
      if (!v9)
      {
        SelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
        v12 = v8;
        goto LABEL_8;
      }
      v10 = v9;
      FigCFArrayAppendInt32(v9, 0);
    }
    else
    {
      v10 = 0;
    }
    SelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord = FigHEVCBridge_CreateSelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord(a1, 0, v8, v10, a3);
    CFRelease(v8);
    if (!v10)
      return SelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord;
    v12 = v10;
LABEL_8:
    CFRelease(v12);
    return SelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord;
  }
  return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
}

uint64_t FigHEVCBridge_CreateSelectedLayerFormatDescriptionFromMuxedAlphaFormatDescription(const opaqueCMFormatDescription *a1, int a2, CMVideoFormatDescriptionRef *a3)
{
  FourCharCode MediaSubType;
  CMVideoCodecType v7;
  CMVideoDimensions Dimensions;
  const __CFDictionary *Extensions;
  const __CFDictionary *v10;
  const __CFDictionary *Value;
  const __CFDictionary *v12;
  const void *v13;
  const void *v14;
  CFTypeID v15;
  const __CFAllocator *v16;
  CFMutableDictionaryRef MutableCopy;
  CFMutableDictionaryRef v18;
  CFMutableDictionaryRef v19;
  __CFDictionary *v20;
  CFDataRef v21;
  const __CFData *v22;
  uint64_t HEVCParameterSetAtIndex;
  const void *v24;
  const void *v25;
  uint64_t v26;
  CFMutableDataRef v27;
  uint64_t updated;
  CFDataRef v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  CFDataRef theData;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const UInt8 *v43;
  const UInt8 *v44[2];

  v44[1] = *(const UInt8 **)MEMORY[0x1E0C80C00];
  theData = 0;
  if (!a1)
  {
    v32 = 4294954584;
    return FigSignalErrorAt(v32, 0, 0, 0, 0, 0, 0);
  }
  MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  if (MediaSubType == 1836415073)
    v7 = 1752589105;
  else
    v7 = MediaSubType;
  Dimensions = CMVideoFormatDescriptionGetDimensions(a1);
  Extensions = CMFormatDescriptionGetExtensions(a1);
  if (!Extensions
    || (v10 = Extensions,
        (Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("SampleDescriptionExtensionAtoms"))) == 0)
    || (v12 = Value, (v13 = CFDictionaryGetValue(Value, CFSTR("hvcC"))) == 0)
    || (v14 = v13, v15 = CFGetTypeID(v13), v15 != CFDataGetTypeID()))
  {
    v32 = 4294954581;
    return FigSignalErrorAt(v32, 0, 0, 0, 0, 0, 0);
  }
  v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v10);
  if (!MutableCopy)
  {
    v32 = 4294954583;
    return FigSignalErrorAt(v32, 0, 0, 0, 0, 0, 0);
  }
  v18 = MutableCopy;
  v19 = CFDictionaryCreateMutableCopy(v16, 0, v12);
  if (!v19)
  {
    v33 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    CFRelease(v18);
    return v33;
  }
  v20 = v19;
  FigHEVCBridge_CreateSelectedLayerHVCCFromMuxedAlphaHVCC(v14, a2, &theData);
  v21 = theData;
  if (theData)
  {
    v22 = 0;
LABEL_28:
    CFDictionarySetValue(v20, CFSTR("hvcC"), v21);
    CFDictionarySetValue(v18, CFSTR("SampleDescriptionExtensionAtoms"), v20);
    CFDictionaryRemoveValue(v18, CFSTR("VerbatimSampleDescription"));
    CFDictionaryRemoveValue(v18, CFSTR("VerbatimISOSampleEntry"));
    CFDictionaryRemoveValue(v18, CFSTR("ContainsAlphaChannel"));
    CFDictionarySetValue(v18, CFSTR("IgnoreVPSExtension"), (const void *)*MEMORY[0x1E0C9AE50]);
    updated = CMVideoFormatDescriptionCreate(v16, v7, Dimensions.width, Dimensions.height, v18, a3);
    goto LABEL_29;
  }
  v42 = 0;
  v43 = 0;
  v44[0] = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v34 = 0;
  HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(v14, 1, 32, 0, (unint64_t)&v42, (unint64_t)&v39, (unint64_t)&v36, (_DWORD *)&v34 + 1, 0, 0);
  if ((_DWORD)HEVCParameterSetAtIndex)
    goto LABEL_44;
  if (v36 != 1)
  {
    v26 = 4294954584;
    goto LABEL_43;
  }
  v24 = CFDictionaryGetValue(v12, CFSTR("lhvC"));
  if (!v24)
  {
LABEL_41:
    v26 = 4294954583;
LABEL_43:
    HEVCParameterSetAtIndex = FigSignalErrorAt(v26, 0, 0, 0, 0, 0, 0);
    goto LABEL_44;
  }
  v25 = v24;
  HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetWithNuhLayerID(v24, 33, (unsigned __int16)a2, &v43, &v40, &v37, &v34);
  if ((_DWORD)HEVCParameterSetAtIndex)
    goto LABEL_44;
  v26 = 4294954584;
  if (HIDWORD(v34) != (_DWORD)v34 || v37 != 1)
    goto LABEL_43;
  HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetWithNuhLayerID(v25, 34, (unsigned __int16)a2, v44, &v41, &v38, &v34);
  if ((_DWORD)HEVCParameterSetAtIndex)
    goto LABEL_44;
  v26 = 4294954584;
  if (HIDWORD(v34) != (_DWORD)v34 || v38 != 1)
    goto LABEL_43;
  HEVCParameterSetAtIndex = FigHEVCBridge_CreateUpdatedHVCCWithAdditionalHEVCParameterSets(-12712, 0, 3uLL, (uint64_t)&v42, (uint64_t)&v39, HIDWORD(v34), 0, 0, &theData);
  if ((_DWORD)HEVCParameterSetAtIndex)
  {
LABEL_44:
    v30 = HEVCParameterSetAtIndex;
    v22 = 0;
    goto LABEL_30;
  }
  v27 = CFDataCreateMutableCopy(v16, 0, theData);
  if (!v27)
    goto LABEL_41;
  v22 = v27;
  updated = hevcbridge_updateConfigRecordNuhLayerID(v27, 0, 0);
  if (!(_DWORD)updated)
  {
    v29 = theData;
    theData = v22;
    CFRetain(v22);
    if (v29)
      CFRelease(v29);
    v21 = theData;
    goto LABEL_28;
  }
LABEL_29:
  v30 = updated;
LABEL_30:
  CFRelease(v18);
  CFRelease(v20);
  if (theData)
    CFRelease(theData);
  if (v22)
    CFRelease(v22);
  return v30;
}

uint64_t hevcbridge_getHEVCParameterSetWithNuhLayerID(CFTypeRef cf, int a2, int a3, const UInt8 **a4, _QWORD *a5, _QWORD *a6, _DWORD *a7)
{
  CFTypeID v14;
  CFIndex Length;
  const UInt8 *BytePtr;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const UInt8 *v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  const UInt8 *v27;

  if (a4)
    *a4 = 0;
  if (a5)
    *a5 = 0;
  if (a6)
    *a6 = 0;
  if (a7)
    *a7 = 0;
  if (cf)
  {
    v14 = CFGetTypeID(cf);
    if (v14 == CFDataGetTypeID())
    {
      Length = CFDataGetLength((CFDataRef)cf);
      BytePtr = CFDataGetBytePtr((CFDataRef)cf);
      if (Length > 5 && *BytePtr == 1)
      {
        if (!a7 || (*a7 = (BytePtr[4] & 3) + 1, a4) || a5 || a6)
        {
          v17 = BytePtr[5];
          if (BytePtr[5])
          {
            v18 = 0;
            v19 = 0;
            v20 = 6;
            while (1)
            {
              v21 = v20 + 3;
              if (Length < v20 + 3)
                return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
              v22 = &BytePtr[v20];
              v23 = __rev16(*(unsigned __int16 *)(v22 + 1));
              if (v23)
              {
                v24 = *v22 & 0x3F;
                while (1)
                {
                  v25 = v21 + 2;
                  if (Length < v21 + 2)
                    break;
                  v26 = __rev16(*(unsigned __int16 *)&BytePtr[v21]);
                  v20 = v26 + v25;
                  if (Length < v26 + v25)
                    break;
                  if (v24 == a2)
                  {
                    v27 = &BytePtr[v25];
                    if ((((BytePtr[v21 + 3] | (*v27 << 8)) >> 3) & 0x3F) == a3)
                    {
                      if (a4)
                        *a4 = v27;
                      if (a5)
                        *a5 = v26;
                      if (!a6)
                        return 0;
                      ++v19;
                    }
                  }
                  v21 = v20;
                  if (!--v23)
                    goto LABEL_35;
                }
                return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
              }
              v20 = v21;
LABEL_35:
              if (++v18 == v17)
              {
                if (!a6)
                  return 0;
                goto LABEL_37;
              }
            }
          }
          v19 = 0;
          if (a6)
LABEL_37:
            *a6 = v19;
        }
        return 0;
      }
    }
  }
  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t hevcbridge_updateConfigRecordNuhLayerID(void *a1, int a2, __int16 a3)
{
  CFTypeID v6;
  CFIndex Length;
  UInt8 *MutableBytePtr;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v22;

  if (!a1 || (v6 = CFGetTypeID(a1), v6 != CFDataGetTypeID()))
  {
    v22 = 4294954584;
    return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
  }
  Length = CFDataGetLength((CFDataRef)a1);
  MutableBytePtr = CFDataGetMutableBytePtr((CFMutableDataRef)a1);
  if (!a2)
  {
    if (Length >= 23 && *MutableBytePtr == 1)
    {
      v9 = 22;
      goto LABEL_10;
    }
LABEL_31:
    v22 = 4294954581;
    return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
  }
  if (Length < 6 || *MutableBytePtr != 1)
    goto LABEL_31;
  v9 = 5;
LABEL_10:
  v10 = MutableBytePtr[v9];
  if (!MutableBytePtr[v9])
    return 0;
  v11 = 0;
  v12 = v9 + 1;
  while (1)
  {
    v13 = v12 + 3;
    if (Length < v12 + 3)
      break;
    v14 = __rev16(*(unsigned __int16 *)&MutableBytePtr[v12 + 1]);
    if (v14)
    {
      v15 = MutableBytePtr[v12] & 0x3F;
      while (1)
      {
        v16 = v13 + 2;
        if (Length < v13 + 2)
          goto LABEL_28;
        v17 = __rev16(*(unsigned __int16 *)&MutableBytePtr[v13]);
        v12 = v16 + v17;
        v18 = Length >= v16 + v17 && v17 >= 2;
        if (!v18 || (char)MutableBytePtr[v16] < 0 || ((MutableBytePtr[v16] >> 1) & 0x3F) != v15)
          goto LABEL_28;
        v19 = v13 + 3;
        v20 = MutableBytePtr[v19] & 7 | (MutableBytePtr[v16] << 8) & 0xFE07 | (8 * (a3 & 0x1FFF));
        MutableBytePtr[v16] = HIBYTE(v20);
        MutableBytePtr[v19] = v20;
        v13 = v12;
        if (!--v14)
          goto LABEL_26;
      }
    }
    v12 += 3;
LABEL_26:
    if (++v11 == v10)
      return 0;
  }
LABEL_28:
  v22 = 4294954582;
  return FigSignalErrorAt(v22, 0, 0, 0, 0, 0, 0);
}

uint64_t FigHEVCBridge_CreateFormatDescriptionWithSelectedLayersFromMultiviewMuxedAlphaFormatDescription(const opaqueCMFormatDescription *a1, CFArrayRef theArray, const __CFArray *a3, CMVideoFormatDescriptionRef *a4)
{
  CFIndex Count;
  FourCharCode MediaSubType;
  CMVideoDimensions Dimensions;
  const __CFDictionary *Extensions;
  const __CFDictionary *v12;
  const __CFDictionary *Value;
  const __CFDictionary *v14;
  const void *v15;
  const void *v16;
  CFTypeID v17;
  const void *v18;
  const void *v19;
  CFTypeID v20;
  const __CFAllocator *v21;
  CFMutableDictionaryRef MutableCopy;
  CFMutableDictionaryRef v23;
  CFMutableDictionaryRef v24;
  __CFDictionary *v25;
  const __CFData *v26;
  uint64_t HEVCParameterSetAtIndex;
  CFMutableDataRef v28;
  uint64_t updated;
  CFDataRef v30;
  CFTypeRef v31;
  CFTypeID v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  CMVideoFormatDescriptionRef *formatDescriptionOut;
  CMVideoCodecType codecType;
  int v39;
  unsigned int v40;
  int v41;
  CFTypeRef cf;
  CFDataRef theData;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const UInt8 *v51;
  const UInt8 *v52[2];

  v52[1] = *(const UInt8 **)MEMORY[0x1E0C80C00];
  cf = 0;
  theData = 0;
  v41 = 0;
  if (!a1
    || !theArray
    || CFArrayGetCount(theArray) <= 0
    || a3 && (Count = CFArrayGetCount(a3), Count != CFArrayGetCount(theArray)))
  {
    v34 = 4294954584;
LABEL_36:
    v33 = FigSignalErrorAt(v34, 0, 0, 0, 0, 0, 0);
LABEL_37:
    v26 = 0;
    goto LABEL_38;
  }
  MediaSubType = CMFormatDescriptionGetMediaSubType(a1);
  Dimensions = CMVideoFormatDescriptionGetDimensions(a1);
  Extensions = CMFormatDescriptionGetExtensions(a1);
  if (!Extensions)
    goto LABEL_43;
  v12 = Extensions;
  Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("SampleDescriptionExtensionAtoms"));
  if (!Value)
    goto LABEL_43;
  v14 = Value;
  v15 = CFDictionaryGetValue(Value, CFSTR("hvcC"));
  if (!v15
    || (v16 = v15, v17 = CFGetTypeID(v15), v17 != CFDataGetTypeID())
    || (codecType = MediaSubType, (v18 = CFDictionaryGetValue(v14, CFSTR("lhvC"))) == 0)
    || (v19 = v18, v20 = CFGetTypeID(v18), v20 != CFDataGetTypeID()))
  {
LABEL_43:
    v34 = 4294954581;
    goto LABEL_36;
  }
  formatDescriptionOut = a4;
  v21 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v12);
  if (!MutableCopy)
  {
    v34 = 4294954583;
    goto LABEL_36;
  }
  v23 = MutableCopy;
  v24 = CFDictionaryCreateMutableCopy(v21, 0, v14);
  if (!v24)
  {
    v33 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    CFRelease(v23);
    goto LABEL_37;
  }
  v25 = v24;
  FigCFArrayGetInt16AtIndex(theArray, 0, (char *)&v41 + 2);
  FigCFArrayGetInt16AtIndex(a3, 0, &v41);
  FigHEVCBridge_CreateSelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord(v16, 0, theArray, a3, &theData);
  v26 = 0;
  if (theData)
    goto LABEL_28;
  v50 = 0;
  v51 = 0;
  v52[0] = 0;
  v47 = 0;
  v48 = 0;
  v49 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v39 = 0;
  v40 = 0;
  HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(v16, 1, 32, 0, (unint64_t)&v50, (unint64_t)&v47, (unint64_t)&v44, &v40, 0, 0);
  if (!(_DWORD)HEVCParameterSetAtIndex)
  {
    if (v44 != 1)
      goto LABEL_45;
    HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetWithNuhLayerID(v19, 33, HIWORD(v41), &v51, &v48, &v45, &v39);
    if ((_DWORD)HEVCParameterSetAtIndex)
      goto LABEL_47;
    if (v45 != 1 || v40 != v39)
      goto LABEL_45;
    HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetWithNuhLayerID(v19, 34, HIWORD(v41), v52, &v49, &v46, &v39);
    if ((_DWORD)HEVCParameterSetAtIndex)
      goto LABEL_47;
    if (v46 != 1 || v40 != v39)
    {
LABEL_45:
      v36 = 4294954584;
LABEL_46:
      HEVCParameterSetAtIndex = FigSignalErrorAt(v36, 0, 0, 0, 0, 0, 0);
      goto LABEL_47;
    }
    HEVCParameterSetAtIndex = FigHEVCBridge_CreateUpdatedHVCCWithAdditionalHEVCParameterSets(0, 0, 3uLL, (uint64_t)&v50, (uint64_t)&v47, v40, 0, 0, &theData);
    if (!(_DWORD)HEVCParameterSetAtIndex)
    {
      v28 = CFDataCreateMutableCopy(v21, 0, theData);
      if (v28)
      {
        v26 = v28;
        updated = hevcbridge_updateConfigRecordNuhLayerID(v28, 0, v41);
        if ((_DWORD)updated)
        {
LABEL_32:
          v33 = updated;
          goto LABEL_33;
        }
        v30 = theData;
        theData = v26;
        CFRetain(v26);
        if (v30)
          CFRelease(v30);
LABEL_28:
        updated = FigHEVCBridge_CreateSelectedLayersHVCCOrLHVCFromMuxedAlphaConfigRecord(v19, 1, theArray, a3, (__CFData **)&cf);
        if (!(_DWORD)updated)
        {
          v31 = cf;
          if (cf && (v32 = CFGetTypeID(cf), v32 == CFDataGetTypeID()))
          {
            CFDictionarySetValue(v25, CFSTR("hvcC"), theData);
            CFDictionarySetValue(v25, CFSTR("lhvC"), v31);
            CFDictionarySetValue(v23, CFSTR("SampleDescriptionExtensionAtoms"), v25);
            CFDictionaryRemoveValue(v23, CFSTR("VerbatimSampleDescription"));
            CFDictionaryRemoveValue(v23, CFSTR("VerbatimISOSampleEntry"));
            CFDictionaryRemoveValue(v23, CFSTR("ContainsAlphaChannel"));
            updated = CMVideoFormatDescriptionCreate(v21, codecType, Dimensions.width, Dimensions.height, v23, formatDescriptionOut);
          }
          else
          {
            updated = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
          }
        }
        goto LABEL_32;
      }
      v36 = 4294954583;
      goto LABEL_46;
    }
  }
LABEL_47:
  v33 = HEVCParameterSetAtIndex;
  v26 = 0;
LABEL_33:
  CFRelease(v23);
  CFRelease(v25);
  if (theData)
    CFRelease(theData);
LABEL_38:
  if (cf)
    CFRelease(cf);
  if (v26)
    CFRelease(v26);
  return v33;
}

uint64_t FigHEVCBridge_ParseMuxedAlphaFrameAndWriteSelectedLayerNALUnitsToBuffer(OpaqueCMBlockBuffer *a1, unsigned int a2, _QWORD *a3, uint64_t a4, size_t a5)
{
  const __CFAllocator *v10;
  const __CFArray *v11;
  const __CFArray *v12;
  uint64_t v13;
  uint64_t v14;
  void *values;

  v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  values = FigCFNumberCreateUInt32((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2);
  if (!values)
    return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  v11 = CFArrayCreate(v10, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
  if (!v11)
    goto LABEL_19;
  if (!a2)
  {
    v12 = 0;
    goto LABEL_10;
  }
  if (values)
  {
    CFRelease(values);
    values = 0;
  }
  values = FigCFNumberCreateUInt32(v10, 0);
  if (!values)
  {
LABEL_19:
    v14 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    v12 = 0;
    goto LABEL_12;
  }
  v12 = CFArrayCreate(v10, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
  if (v12)
  {
LABEL_10:
    v13 = FigHEVCBridge_ParseMuxedAlphaFrameAndWriteSelectedLayerIDsNALUnitsToBuffer(a1, v11, v12, a3, a4, a5);
    goto LABEL_11;
  }
  v13 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
LABEL_11:
  v14 = v13;
LABEL_12:
  if (values)
    CFRelease(values);
  if (v11)
    CFRelease(v11);
  if (v12)
    CFRelease(v12);
  return v14;
}

uint64_t FigHEVCBridge_ParseMuxedAlphaFrameAndWriteSelectedLayerIDsNALUnitsToBuffer(OpaqueCMBlockBuffer *a1, CFArrayRef theArray, const __CFArray *a3, _QWORD *a4, uint64_t a5, size_t a6)
{
  CFIndex Count;
  size_t DataLength;
  size_t v13;
  size_t v14;
  uint64_t result;
  uint64_t v16;
  int v18;
  unsigned int v19;
  int v20;
  size_t v21;
  size_t v22;
  CFIndex FirstIndexOfInt32;
  unsigned int v24;
  uint64_t v25;
  _QWORD *v26;
  const __CFArray *v28;
  int v29;
  unsigned __int16 v30;
  unsigned int destination;

  if (!a1)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (!theArray)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (CFArrayGetCount(theArray) <= 0)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (a3)
  {
    Count = CFArrayGetCount(a3);
    if (Count != CFArrayGetCount(theArray))
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  v26 = a4;
  DataLength = CMBlockBufferGetDataLength(a1);
  if (DataLength)
  {
    v28 = a3;
    v13 = 0;
    v14 = 0;
    while (v14 + 6 <= DataLength)
    {
      destination = 0;
      v30 = 0;
      result = CMBlockBufferCopyDataBytes(a1, v14, 4uLL, &destination);
      if ((_DWORD)result)
        return result;
      v16 = bswap32(destination);
      if (v16 < 2 || v14 + 4 + v16 > DataLength)
        break;
      result = CMBlockBufferCopyDataBytes(a1, v14 + 4, 2uLL, &v30);
      if ((_DWORD)result)
        return result;
      v18 = bswap32(v30);
      v19 = v18 >> 16;
      if (v18 >> 16 < 0)
        break;
      v20 = (v18 >> 19) & 0x3F;
      v21 = (v16 + 4);
      if (FigCFArrayContainsInt32(theArray, v20))
      {
        v22 = v13 + v21;
        if (a5)
        {
          if (v22 > a6)
            return FigSignalErrorAt(4294954577, 0, 0, 0, 0, 0, 0);
          result = CMBlockBufferCopyDataBytes(a1, v14, v21, (void *)(a5 + v13));
          if ((_DWORD)result)
            return result;
          v29 = 0;
          if (!v28 || (FirstIndexOfInt32 = FigCFArrayGetFirstIndexOfInt32(theArray, v20), FirstIndexOfInt32 == -1))
          {
            LOBYTE(v24) = BYTE1(v19);
          }
          else
          {
            FigCFArrayGetInt32AtIndex(v28, FirstIndexOfInt32, &v29);
            v19 = (8 * (unsigned __int16)v29) | v19 & 0xFE07;
            v24 = v19 >> 8;
          }
          v25 = v13 + a5;
          *(_BYTE *)(v25 + 4) = v24;
          *(_BYTE *)(v25 + 5) = v19;
        }
      }
      else
      {
        v22 = v13;
      }
      v14 += v21;
      v13 = v22;
      if (v14 >= DataLength)
        goto LABEL_30;
    }
    return FigSignalErrorAt(4294954577, 0, 0, 0, 0, 0, 0);
  }
  v14 = 0;
  v22 = 0;
LABEL_30:
  if (v14 != DataLength)
    return FigSignalErrorAt(4294954577, 0, 0, 0, 0, 0, 0);
  if (!v26)
    return 0;
  result = 0;
  *v26 = v22;
  return result;
}

uint64_t FigHEVCBridge_CreateAlphaInfoSEI(int a1, int a2, int a3, CFDataRef *a4)
{
  CFDataRef v8;
  CFDataRef v9;
  uint64_t result;
  uint64_t v11[2];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  UInt8 bytes[8];
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v19 = 0;
  *(_QWORD *)bytes = 0;
  v17 = 0;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v12 = 0u;
  if (!a4)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v11[0] = (uint64_t)bytes;
  v11[1] = 9;
  *(_QWORD *)&v14 = bytes;
  hevcbridgeUPush(v11, 1, 0);
  hevcbridgeUPush(v11, 6, 39);
  hevcbridgeUPush(v11, 6, 0);
  hevcbridgeUPush(v11, 3, 1);
  hevcbridgeUPush(v11, 8, 165);
  hevcbridgeUPush(v11, 8, 4);
  hevcbridgeUPush(v11, 1, 0);
  hevcbridgeUPush(v11, 3, a1 != 0);
  hevcbridgeUPush(v11, 3, 0);
  hevcbridgeUPush(v11, 9, a2);
  hevcbridgeUPush(v11, 9, a3);
  hevcbridgeUPush(v11, 1, 0);
  hevcbridgeUPush(v11, 1, 0);
  if (HIDWORD(v15))
    hevcbridgeUPush(v11, 1, 1);
  v19 = 0x80;
  v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, 9);
  if (!v8)
    return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  v9 = v8;
  result = 0;
  *a4 = v9;
  return result;
}

uint64_t FigHEVCBridge_CreateMuxedAlphaHVCCOrLHVC(const void *a1, const void *a2, int a3, const __CFData *a4, int a5, __CFData **a6)
{
  CFTypeID v10;
  CFTypeID v11;
  uint64_t v12;
  const __CFData *MutableCopy;
  __CFData *v14;
  CFIndex Length;
  UInt8 *MutableBytePtr;
  BOOL v17;
  UInt8 *v18;
  int v19;
  uint64_t v20;
  CFIndex v21;
  int v22;
  CFIndex v23;
  unsigned int v24;
  int v25;
  int v26;
  BOOL v27;
  char v28;
  unsigned int v29;
  CFIndex v30;
  uint64_t v31;
  int v32;
  const __CFData *v33;
  unsigned int v34;
  unsigned __int16 v35;
  CFIndex v36;
  const UInt8 *BytePtr;
  unsigned int v38;
  unsigned __int16 v39;
  const UInt8 *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v44;
  CFIndex v45;
  int v47;
  uint64_t v48;
  int v49;
  int v50;
  char v52;
  CFRange range;
  CFDataRef theData;
  CFTypeRef cf;
  CFRange v56;
  CFRange v57;
  CFRange v58;
  CFRange v59;
  CFRange v60;
  CFRange v61;
  CFRange v62;
  CFRange v63;

  theData = 0;
  cf = 0;
  if (!a1)
    goto LABEL_65;
  v10 = CFGetTypeID(a1);
  if (v10 != CFDataGetTypeID())
    goto LABEL_65;
  if (!a2)
  {
LABEL_8:
    MutableCopy = CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, (CFDataRef)a1);
    if (MutableCopy)
    {
      v14 = MutableCopy;
      Length = CFDataGetLength(MutableCopy);
      MutableBytePtr = CFDataGetMutableBytePtr(v14);
      if (MutableBytePtr)
        v17 = Length <= 0;
      else
        v17 = 1;
      if (v17)
      {
        v42 = 4294954584;
        goto LABEL_59;
      }
      v18 = MutableBytePtr;
      v19 = *MutableBytePtr;
      if (a3)
      {
        if ((unint64_t)Length > 5 && v19 == 1)
        {
          v20 = 5;
          goto LABEL_20;
        }
      }
      else if ((unint64_t)Length > 0x16 && v19 == 1)
      {
        v20 = 22;
LABEL_20:
        v21 = v20 + 1;
        v45 = v20;
        v47 = MutableBytePtr[v20];
        if (MutableBytePtr[v20])
        {
          v48 = 0;
          v50 = 0;
          v22 = 0;
          v23 = v20 + 1;
          while (1)
          {
            v21 = v23 + 3;
            if (Length < v23 + 3)
              goto LABEL_58;
            v49 = v22;
            range.location = v23 + 1;
            v24 = __rev16(*(unsigned __int16 *)&v18[v23 + 1]);
            if (v24)
              break;
LABEL_49:
            v22 = v49 + 1;
            v23 = v21;
            if (v49 + 1 == v47)
              goto LABEL_52;
          }
          v25 = 0;
          v26 = v18[v23] & 0x3F;
          if (a4)
            v27 = v26 == 39;
          else
            v27 = 0;
          v28 = v27;
          v52 = v28;
          v29 = v24;
          while (1)
          {
            v30 = v21 + 2;
            if (Length < v21 + 2)
              goto LABEL_58;
            v31 = __rev16(*(unsigned __int16 *)&v18[v21]);
            v21 = v30 + v31;
            if (Length < v30 + v31)
              goto LABEL_58;
            if (v31 <= 1)
              goto LABEL_58;
            v32 = (char)v18[v30];
            if (v32 < 0 || v26 != v32 >> 1)
              goto LABEL_58;
            if (v29 == 1)
            {
              if ((v26 - 33) >= 2)
              {
                if ((v52 & 1) != 0)
                {
                  v50 = 1;
                  v33 = a4;
LABEL_47:
                  v34 = CFDataGetLength(v33);
                  v35 = v34;
                  HIWORD(range.length) = bswap32(v34) >> 16;
                  v56.location = v21;
                  v56.length = 0;
                  CFDataReplaceBytes(v14, v56, (const UInt8 *)&range.length + 6, 2);
                  v36 = v21 + 2;
                  BytePtr = CFDataGetBytePtr(v33);
                  v57.location = v36;
                  v57.length = 0;
                  CFDataReplaceBytes(v14, v57, BytePtr, v35);
                  v21 = v36 + v35;
                  WORD2(range.length) = bswap32(++v25 + v24) >> 16;
                  v58.location = range.location;
                  v58.length = 2;
                  CFDataReplaceBytes(v14, v58, (const UInt8 *)&range.length + 4, 2);
                  v18 = CFDataGetMutableBytePtr(v14);
                  Length = CFDataGetLength(v14);
                }
              }
              else
              {
                if (v26 == 33)
                {
                  HIDWORD(v48) = 1;
                  v33 = (const __CFData *)cf;
                  if (!cf)
                    goto LABEL_48;
                  goto LABEL_47;
                }
                if (v26 == 34)
                {
                  LODWORD(v48) = 1;
                  v33 = theData;
                  if (!theData)
                    goto LABEL_48;
                  goto LABEL_47;
                }
                v50 = 1;
                v33 = a4;
                if (a4)
                  goto LABEL_47;
              }
            }
LABEL_48:
            if (!--v29)
              goto LABEL_49;
          }
        }
        v50 = 0;
        v48 = 0;
LABEL_52:
        BYTE3(range.length) = v47;
        if (a4 && !v50)
        {
          BYTE3(range.length) = v47 + 1;
          v59.location = v45;
          v59.length = 1;
          CFDataReplaceBytes(v14, v59, (const UInt8 *)&range.length + 3, 1);
          BYTE2(range.length) = 39;
          v60.location = v21;
          v60.length = 0;
          CFDataReplaceBytes(v14, v60, (const UInt8 *)&range.length + 2, 1);
          v61.location = v21 + 1;
          HIWORD(range.length) = 256;
          v61.length = 0;
          CFDataReplaceBytes(v14, v61, (const UInt8 *)&range.length + 6, 2);
          v38 = CFDataGetLength(a4);
          v39 = v38;
          WORD2(range.length) = bswap32(v38) >> 16;
          v62.location = v21 + 3;
          v62.length = 0;
          CFDataReplaceBytes(v14, v62, (const UInt8 *)&range.length + 4, 2);
          v40 = CFDataGetBytePtr(a4);
          v63.location = v21 + 5;
          v63.length = 0;
          CFDataReplaceBytes(v14, v63, v40, v39);
        }
        if (HIDWORD(v48) && (_DWORD)v48)
        {
          v41 = 0;
          *a6 = v14;
          goto LABEL_60;
        }
      }
LABEL_58:
      v42 = 4294954581;
LABEL_59:
      v41 = FigSignalErrorAt(v42, 0, 0, 0, 0, 0, 0);
      CFRelease(v14);
      goto LABEL_60;
    }
    v44 = 4294954583;
    goto LABEL_70;
  }
  v11 = CFGetTypeID(a2);
  if (v11 != CFDataGetTypeID())
  {
LABEL_65:
    v44 = 4294954584;
    goto LABEL_70;
  }
  v12 = hevcbridge_copyModifedAlphaSPSAndPPSFromHVCCOrLHVC(a2, a3, a5, (__CFData **)&cf, &theData);
  if (!(_DWORD)v12)
  {
    if (!cf)
    {
      v41 = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
      goto LABEL_62;
    }
    if (theData)
      goto LABEL_8;
    v44 = 4294954581;
LABEL_70:
    v12 = FigSignalErrorAt(v44, 0, 0, 0, 0, 0, 0);
  }
  v41 = v12;
LABEL_60:
  if (cf)
    CFRelease(cf);
LABEL_62:
  if (theData)
    CFRelease(theData);
  return v41;
}

uint64_t hevcbridge_copyModifedAlphaSPSAndPPSFromHVCCOrLHVC(const void *a1, int a2, int a3, __CFData **a4, __CFData **a5)
{
  CFTypeID v10;
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  __CFData *v17;
  __CFData *v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v27;
  uint64_t v28;
  uint64_t v30;
  __CFData **v31;
  __CFData **v32;
  int v33;
  int v34;

  if (!a1
    || (v10 = CFGetTypeID(a1), v10 != CFDataGetTypeID())
    || (v32 = a5, Length = CFDataGetLength((CFDataRef)a1), (BytePtr = CFDataGetBytePtr((CFDataRef)a1)) == 0)
    || Length <= 0)
  {
    v30 = 4294954584;
    return FigSignalErrorAt(v30, 0, 0, 0, 0, 0, 0);
  }
  v13 = (uint64_t)BytePtr;
  v14 = *BytePtr;
  if (!a2)
  {
    if ((unint64_t)Length > 0x16 && v14 == 1)
    {
      v15 = 22;
      goto LABEL_12;
    }
    goto LABEL_49;
  }
  if ((unint64_t)Length <= 5 || v14 != 1)
  {
LABEL_49:
    v30 = 4294954581;
    return FigSignalErrorAt(v30, 0, 0, 0, 0, 0, 0);
  }
  v15 = 5;
LABEL_12:
  v31 = a4;
  v33 = BytePtr[v15];
  if (BytePtr[v15])
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = v15 + 1;
    while (1)
    {
      v20 = v19 + 3;
      if (Length < v19 + 3)
        break;
      v34 = v16;
      v21 = __rev16(*(unsigned __int16 *)(v19 + v13 + 1));
      if (v21)
      {
        v22 = *(_BYTE *)(v13 + v19) & 0x3F;
        v23 = v21;
        while (1)
        {
          v24 = v20 + 2;
          if (Length < v20 + 2)
            goto LABEL_40;
          v25 = __rev16(*(unsigned __int16 *)(v13 + v20));
          v19 = v24 + v25;
          if (Length < v24 + v25 || v25 < 2)
            goto LABEL_40;
          v27 = *(unsigned __int8 *)(v20 + v13 + 3) | (*(unsigned __int8 *)(v13 + v24) << 8);
          if ((v27 & 0x8000) != 0 || ((v27 >> 9) & 0x3F) != v22 || !a2 && (v27 & 0x1F8) != 0)
            goto LABEL_40;
          if (v22 == 34)
          {
            if (v21 != 1 || v17)
              goto LABEL_40;
            v17 = hevcbridge_copyPatchedParameterSet(v13, v24, v25, v27, a3);
          }
          else if (v22 == 33)
          {
            if (v21 != 1)
              goto LABEL_40;
            if (v18)
            {
              v28 = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
              goto LABEL_41;
            }
            v18 = hevcbridge_copyPatchedParameterSet(v13, v24, v25, v27, a3);
          }
          v20 = v19;
          if (!--v23)
            goto LABEL_38;
        }
      }
      v19 += 3;
LABEL_38:
      v16 = v34 + 1;
      if (v34 + 1 == v33)
        goto LABEL_45;
    }
LABEL_40:
    v28 = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    if (v18)
LABEL_41:
      CFRelease(v18);
    if (v17)
      CFRelease(v17);
  }
  else
  {
    v18 = 0;
    v17 = 0;
LABEL_45:
    v28 = 0;
    *v32 = v17;
    *v31 = v18;
  }
  return v28;
}

uint64_t FigHEVCBridge_CreateMuxedAlphaHVCC(const void *a1, const void *a2, const __CFData *a3, __CFData **a4)
{
  return FigHEVCBridge_CreateMuxedAlphaHVCCOrLHVC(a1, a2, 0, a3, 1, a4);
}

uint64_t FigHEVCBridge_CreateMuxedAlphaFormatDescription(const opaqueCMFormatDescription *a1, const opaqueCMFormatDescription *a2, const __CFData *a3, CMVideoFormatDescriptionRef *a4)
{
  CMVideoDimensions Dimensions;
  const UInt8 *v9;
  CFIndex Length;
  uint64_t SEIAlphaChannelInfo;
  const __CFDictionary *Extensions;
  const __CFDictionary *v13;
  const __CFDictionary *v14;
  const __CFDictionary *v15;
  const void *v16;
  const void *v17;
  CFTypeID v18;
  const __CFDictionary *v19;
  const __CFDictionary *v20;
  const void *v21;
  const void *v22;
  CFTypeID v23;
  _BOOL4 v24;
  CFTypeRef v25;
  CFTypeID v26;
  const __CFAllocator *v27;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v29;
  __CFDictionary *v30;
  __CFDictionary *v31;
  const void **v32;
  uint64_t LHVCFromHEVCParameterSets;
  __CFDictionary *v34;
  CFTypeID v35;
  const __CFData *v36;
  const __CFData *v37;
  uint64_t v39;
  BOOL v40;
  CFDataRef v41;
  CFDataRef theData;
  void *value;
  CFTypeRef cf;
  CMVideoFormatDescriptionRef formatDescriptionOut;
  char v46;
  _QWORD v47[2];
  _QWORD v48[3];

  v48[2] = *MEMORY[0x1E0C80C00];
  v46 = 0;
  cf = 0;
  formatDescriptionOut = 0;
  theData = 0;
  value = 0;
  v41 = 0;
  v40 = 0;
  Dimensions = CMVideoFormatDescriptionGetDimensions(a1);
  if (CFDataGetLength(a3) <= 4)
    goto LABEL_40;
  v9 = CFDataGetBytePtr(a3) + 4;
  Length = CFDataGetLength(a3);
  SEIAlphaChannelInfo = FigHEVCBridge_GetSEIAlphaChannelInfo((uint64_t)v9, Length - 4, &v46);
  if ((_DWORD)SEIAlphaChannelInfo)
    goto LABEL_42;
  Extensions = CMFormatDescriptionGetExtensions(a1);
  if (!Extensions)
    goto LABEL_40;
  v13 = Extensions;
  v14 = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("SampleDescriptionExtensionAtoms"));
  if (!v14)
    goto LABEL_40;
  v15 = v14;
  v16 = CFDictionaryGetValue(v14, CFSTR("hvcC"));
  if (!v16)
    goto LABEL_40;
  v17 = v16;
  v18 = CFGetTypeID(v16);
  if (v18 != CFDataGetTypeID())
    goto LABEL_40;
  v19 = CMFormatDescriptionGetExtensions(a2);
  if (!v19)
    goto LABEL_40;
  v20 = (const __CFDictionary *)CFDictionaryGetValue(v19, CFSTR("SampleDescriptionExtensionAtoms"));
  if (!v20)
    goto LABEL_40;
  v21 = CFDictionaryGetValue(v20, CFSTR("hvcC"));
  if (!v21)
    goto LABEL_40;
  v22 = v21;
  v23 = CFGetTypeID(v21);
  if (v23 != CFDataGetTypeID())
    goto LABEL_40;
  SEIAlphaChannelInfo = hevcbridgeIsHVCC8Bit420(v17, &v40);
  if ((_DWORD)SEIAlphaChannelInfo)
    goto LABEL_42;
  v24 = v40;
  if (v40)
  {
    SEIAlphaChannelInfo = FigHEVCBridge_CreateMuxedAlphaHVCCOrLHVC(v17, v22, 0, a3, 1, (__CFData **)&cf);
    if (!(_DWORD)SEIAlphaChannelInfo)
    {
      v25 = cf;
      if (cf)
      {
        v26 = CFGetTypeID(cf);
        if (v26 == CFDataGetTypeID())
          goto LABEL_16;
      }
LABEL_40:
      v39 = 4294954581;
LABEL_41:
      SEIAlphaChannelInfo = FigSignalErrorAt(v39, 0, 0, 0, 0, 0, 0);
      goto LABEL_42;
    }
    goto LABEL_42;
  }
  SEIAlphaChannelInfo = FigHEVCBridge_CreateMuxedAlphaHVCCOrLHVC(v17, 0, 0, a3, 0, (__CFData **)&cf);
  if ((_DWORD)SEIAlphaChannelInfo)
    goto LABEL_42;
  v25 = cf;
  if (!cf)
    goto LABEL_40;
  v35 = CFGetTypeID(cf);
  if (v35 != CFDataGetTypeID())
    goto LABEL_40;
  SEIAlphaChannelInfo = hevcbridge_copyModifedAlphaSPSAndPPSFromHVCCOrLHVC(v22, 0, 1, &theData, &v41);
  if ((_DWORD)SEIAlphaChannelInfo)
  {
LABEL_42:
    LHVCFromHEVCParameterSets = SEIAlphaChannelInfo;
    goto LABEL_31;
  }
  v36 = theData;
  v48[0] = CFDataGetBytePtr(theData);
  v37 = v41;
  v48[1] = CFDataGetBytePtr(v41);
  v47[0] = CFDataGetLength(v36);
  v47[1] = CFDataGetLength(v37);
  LHVCFromHEVCParameterSets = hevcbridgeCreateLHVCFromHEVCParameterSets(0, (uint64_t)v48, (uint64_t)v47, (__CFData **)&value);
  if ((_DWORD)LHVCFromHEVCParameterSets)
    goto LABEL_31;
LABEL_16:
  v27 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v13);
  if (!MutableCopy)
  {
    v39 = 4294954583;
    goto LABEL_41;
  }
  v29 = MutableCopy;
  v30 = CFDictionaryCreateMutableCopy(v27, 0, v15);
  if (v30)
  {
    v31 = v30;
    CFDictionarySetValue(v30, CFSTR("hvcC"), v25);
    if (!v24)
      CFDictionarySetValue(v31, CFSTR("lhvC"), value);
    CFDictionarySetValue(v29, CFSTR("SampleDescriptionExtensionAtoms"), v31);
    CFDictionarySetValue(v29, CFSTR("ContainsAlphaChannel"), (const void *)*MEMORY[0x1E0C9AE50]);
    v32 = (const void **)&kCMFormatDescriptionAlphaChannelMode_PremultipliedAlpha;
    if (!v46)
      v32 = (const void **)&kCMFormatDescriptionAlphaChannelMode_StraightAlpha;
    CFDictionarySetValue(v29, CFSTR("AlphaChannelMode"), *v32);
    CFDictionaryRemoveValue(v29, CFSTR("VerbatimSampleDescription"));
    CFDictionaryRemoveValue(v29, CFSTR("VerbatimISOSampleEntry"));
    LHVCFromHEVCParameterSets = CMVideoFormatDescriptionCreate(v27, 0x68766331u, Dimensions.width, Dimensions.height, v29, &formatDescriptionOut);
    if ((_DWORD)LHVCFromHEVCParameterSets)
    {
      if (formatDescriptionOut)
        CFRelease(formatDescriptionOut);
    }
    else
    {
      *a4 = formatDescriptionOut;
      formatDescriptionOut = 0;
    }
    CFRelease(v29);
    v34 = v31;
  }
  else
  {
    LHVCFromHEVCParameterSets = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    v34 = v29;
  }
  CFRelease(v34);
LABEL_31:
  if (cf)
    CFRelease(cf);
  if (value)
    CFRelease(value);
  if (theData)
    CFRelease(theData);
  if (v41)
    CFRelease(v41);
  return LHVCFromHEVCParameterSets;
}

uint64_t hevcbridgeIsHVCC8Bit420(const void *a1, BOOL *a2)
{
  CFTypeID v4;
  uint64_t result;
  BOOL v7;
  char v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = 0;
  v9 = 0;
  v8 = 0;
  if (!a1)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v4 = CFGetTypeID(a1);
  if (v4 != CFDataGetTypeID())
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v10 = 0;
  result = hevcbridge_getHEVCParameterSetAtIndex(a1, 1, 33, 0, (unint64_t)&v10, (unint64_t)&v11, 0, 0, 0, 0);
  if (!(_DWORD)result)
  {
    result = FigHEVCBridge_GetSPSChromaFormatAndBitDepths(v10, v11, &v8, (_BYTE *)&v9 + 1, &v9);
    if (!(_DWORD)result)
    {
      v7 = v8 == 1 && HIBYTE(v9) == 8;
      *a2 = v7;
    }
  }
  return result;
}

uint64_t hevcbridgeCreateLHVCFromHEVCParameterSets(CFDataRef theData, uint64_t a2, uint64_t a3, __CFData **a4)
{
  const __CFAllocator *v7;
  const __CFData *MutableCopy;
  __CFData *v9;
  CFIndex Length;
  CFIndex v11;
  UInt8 *MutableBytePtr;
  UInt8 *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  CFIndex v17;
  CFIndex v18;
  int v19;
  int v20;
  int v21;
  CFIndex v22;
  uint64_t v23;
  CFIndex v24;
  int v25;
  uint64_t v26;
  char v27;
  char v28;
  int v29;
  uint64_t v30;
  CFIndex v31;
  __CFData *Mutable;
  uint64_t v33;
  char v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  __CFData **v39;
  int v40;
  int v41;
  int v42;
  CFRange range;
  UInt8 newBytes[2];
  UInt8 v46[2];
  UInt8 v47[3];
  UInt8 v48;
  UInt8 bytes[4];
  __int16 v50;
  CFRange v51;
  CFRange v52;
  CFRange v53;

  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (theData)
  {
    MutableCopy = CFDataCreateMutableCopy(v7, 0, theData);
    if (MutableCopy)
    {
      v9 = MutableCopy;
      Length = CFDataGetLength(MutableCopy);
      if (Length <= 5)
        goto LABEL_30;
      v11 = Length;
      MutableBytePtr = CFDataGetMutableBytePtr(v9);
      if (!MutableBytePtr)
      {
        v37 = 4294954584;
        goto LABEL_31;
      }
      v13 = MutableBytePtr;
      if (*MutableBytePtr != 1)
      {
LABEL_30:
        v37 = 4294954581;
LABEL_31:
        v36 = FigSignalErrorAt(v37, 0, 0, 0, 0, 0, 0);
        CFRelease(v9);
        return v36;
      }
      v40 = MutableBytePtr[5];
      if (MutableBytePtr[5])
      {
        v39 = a4;
        v14 = 0;
        v15 = 6;
        v16 = a3;
        v17 = v11;
        while (1)
        {
          v18 = v15 + 3;
          if (v17 < v15 + 3)
            goto LABEL_30;
          v41 = v14;
          range.location = v15 + 1;
          LODWORD(range.length) = __rev16(*(unsigned __int16 *)&v13[v15 + 1]);
          if (LODWORD(range.length))
          {
            v19 = 0;
            v20 = 0;
            v21 = v13[v15] & 0x3F;
            do
            {
              v22 = v18 + 2;
              if (v17 < v18 + 2)
                goto LABEL_30;
              v23 = __rev16(*(unsigned __int16 *)&v13[v18]);
              v24 = v22 + v23;
              if (v17 < v22 + v23)
                goto LABEL_30;
              if (v23 <= 1)
                goto LABEL_30;
              v25 = (char)v13[v22];
              if (v25 < 0 || v21 != v25 >> 1)
                goto LABEL_30;
              v42 = v19 + 1;
              if (v19 + 1 == LODWORD(range.length))
              {
                v26 = 0;
                v27 = 1;
                v18 = v24;
                do
                {
                  v28 = v27;
                  v29 = (**(unsigned __int8 **)(a2 + 8 * v26) >> 1) & 0x3F;
                  v30 = *(_QWORD *)(v16 + 8 * v26);
                  *(_WORD *)newBytes = bswap32(v30) >> 16;
                  if (v21 == v29)
                  {
                    v31 = (unsigned __int16)v30;
                    v51.location = v24;
                    v51.length = 0;
                    CFDataReplaceBytes(v9, v51, newBytes, 2);
                    v52.location = v24 + 2;
                    v52.length = 0;
                    CFDataReplaceBytes(v9, v52, *(const UInt8 **)(a2 + 8 * v26), v31);
                    v18 += v31 + 2;
                    HIWORD(range.length) = bswap32(++v20 + LODWORD(range.length)) >> 16;
                    v53.location = range.location;
                    v53.length = 2;
                    CFDataReplaceBytes(v9, v53, (const UInt8 *)&range.length + 6, 2);
                    v13 = CFDataGetMutableBytePtr(v9);
                    v17 = CFDataGetLength(v9);
                    v16 = a3;
                  }
                  v27 = 0;
                  v26 = 1;
                }
                while ((v28 & 1) != 0);
              }
              else
              {
                v18 = v24;
              }
              v19 = v42;
            }
            while (v42 != LODWORD(range.length));
          }
          v14 = v41 + 1;
          v15 = v18;
          if (v41 + 1 == v40)
          {
            a4 = v39;
            break;
          }
        }
      }
LABEL_29:
      v36 = 0;
      *a4 = v9;
      return v36;
    }
  }
  else
  {
    Mutable = CFDataCreateMutable(v7, 0);
    if (Mutable)
    {
      v9 = Mutable;
      *(_DWORD *)bytes = -67047423;
      v50 = 707;
      CFDataAppendBytes(Mutable, bytes, 6);
      v33 = 0;
      v34 = 1;
      do
      {
        v35 = v34;
        v48 = 0;
        v48 = (**(_BYTE **)(a2 + 8 * v33) >> 1) & 0x3F | 0x80;
        *(_WORD *)v47 = 256;
        *(_WORD *)v46 = bswap32(*(unsigned __int16 *)(a3 + 8 * v33)) >> 16;
        CFDataAppendBytes(v9, &v48, 1);
        CFDataAppendBytes(v9, v47, 2);
        CFDataAppendBytes(v9, v46, 2);
        CFDataAppendBytes(v9, *(const UInt8 **)(a2 + 8 * v33), *(_QWORD *)(a3 + 8 * v33));
        v34 = 0;
        v33 = 1;
      }
      while ((v35 & 1) != 0);
      goto LABEL_29;
    }
  }
  return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
}

uint64_t FigHEVCBridge_CreateMultiviewMuxedAlphaFormatDescription(const opaqueCMFormatDescription *a1, const opaqueCMFormatDescription *a2, const __CFData *a3, int a4, CFArrayRef theArray, const __CFArray *a6, CMVideoFormatDescriptionRef *a7)
{
  CMVideoDimensions Dimensions;
  const UInt8 *v14;
  CFIndex Length;
  uint64_t SEIAlphaChannelInfo;
  const __CFDictionary *Extensions;
  const __CFDictionary *v18;
  const __CFDictionary *Value;
  const __CFDictionary *v20;
  const void *v21;
  const void *v22;
  CFTypeID v23;
  const __CFData *v24;
  const __CFData *v25;
  CFTypeID v26;
  const __CFAllocator *v27;
  const __CFDictionary *v28;
  const __CFDictionary *v29;
  const __CFDictionary *v30;
  const void *v31;
  const void *v32;
  CFTypeID v33;
  const void *v34;
  const void *v35;
  CFTypeID v36;
  uint64_t IsHVCC8Bit420;
  _BOOL4 v38;
  const void *v39;
  uint64_t MuxedAlphaHVCCOrLHVC;
  void *v41;
  CFTypeID v42;
  uint64_t updated;
  const __CFData *v44;
  CFTypeID v45;
  CFTypeRef v46;
  CMVideoFormatDescriptionRef *v47;
  uint64_t v48;
  uint64_t v49;
  const __CFData *v50;
  const __CFData *v51;
  CFMutableDictionaryRef v52;
  __CFDictionary *v53;
  __CFDictionary *v54;
  __CFDictionary *v55;
  const void **v56;
  __CFDictionary *v57;
  CFMutableDataRef v58;
  uint64_t v60;
  CMVideoFormatDescriptionRef *v61;
  CMVideoDimensions v62;
  const __CFDictionary *theDict;
  CFMutableDataRef MutableCopy;
  __int16 v65;
  BOOL v66;
  CFTypeRef v67;
  CFDataRef v68;
  CFDataRef theData;
  int v70;
  CFTypeRef v71;
  CFTypeRef cf;
  CMVideoFormatDescriptionRef formatDescriptionOut;
  char v74;
  _QWORD v75[2];
  _QWORD v76[4];

  v76[2] = *MEMORY[0x1E0C80C00];
  v74 = 0;
  cf = 0;
  formatDescriptionOut = 0;
  v71 = 0;
  v70 = 0;
  v68 = 0;
  theData = 0;
  v67 = 0;
  v66 = 0;
  if (!theArray || CFArrayGetCount(theArray) != 2 || !a6 || CFArrayGetCount(a6) != 2)
  {
    v48 = 4294954584;
LABEL_34:
    SEIAlphaChannelInfo = FigSignalErrorAt(v48, 0, 0, 0, 0, 0, 0);
    goto LABEL_35;
  }
  Dimensions = CMVideoFormatDescriptionGetDimensions(a1);
  if (CFDataGetLength(a3) <= 4)
    goto LABEL_61;
  v14 = CFDataGetBytePtr(a3) + 4;
  Length = CFDataGetLength(a3);
  SEIAlphaChannelInfo = FigHEVCBridge_GetSEIAlphaChannelInfo((uint64_t)v14, Length - 4, &v74);
  if ((_DWORD)SEIAlphaChannelInfo)
  {
LABEL_35:
    v49 = SEIAlphaChannelInfo;
    goto LABEL_52;
  }
  Extensions = CMFormatDescriptionGetExtensions(a1);
  if (!Extensions)
    goto LABEL_61;
  v18 = Extensions;
  Value = (const __CFDictionary *)CFDictionaryGetValue(Extensions, CFSTR("SampleDescriptionExtensionAtoms"));
  if (!Value)
    goto LABEL_61;
  v20 = Value;
  v21 = CFDictionaryGetValue(Value, CFSTR("hvcC"));
  if (!v21
    || (v22 = v21, v23 = CFGetTypeID(v21), v23 != CFDataGetTypeID())
    || (v24 = (const __CFData *)CFDictionaryGetValue(v20, CFSTR("lhvC"))) == 0
    || (v25 = v24, theDict = v18, v26 = CFGetTypeID(v24), v26 != CFDataGetTypeID()))
  {
LABEL_61:
    v48 = 4294954581;
    goto LABEL_34;
  }
  v62 = Dimensions;
  v27 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  MutableCopy = CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v25);
  if (!MutableCopy)
  {
    v48 = 4294954583;
    goto LABEL_34;
  }
  v28 = CMFormatDescriptionGetExtensions(a2);
  if (!v28)
    goto LABEL_62;
  v29 = (const __CFDictionary *)CFDictionaryGetValue(v28, CFSTR("SampleDescriptionExtensionAtoms"));
  if (!v29
    || (v30 = v29, (v31 = CFDictionaryGetValue(v29, CFSTR("hvcC"))) == 0)
    || (v32 = v31, v33 = CFGetTypeID(v31), v33 != CFDataGetTypeID())
    || (v34 = CFDictionaryGetValue(v30, CFSTR("lhvC"))) == 0
    || (v35 = v34, v36 = CFGetTypeID(v34), v36 != CFDataGetTypeID()))
  {
LABEL_62:
    IsHVCC8Bit420 = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
    goto LABEL_63;
  }
  FigCFArrayGetInt16AtIndex(a6, 0, (char *)&v70 + 2);
  IsHVCC8Bit420 = hevcbridgeIsHVCC8Bit420(v22, &v66);
  if ((_DWORD)IsHVCC8Bit420)
  {
LABEL_63:
    v49 = IsHVCC8Bit420;
    v58 = MutableCopy;
    goto LABEL_51;
  }
  v61 = a7;
  v38 = v66;
  if (v66)
    v39 = v32;
  else
    v39 = 0;
  MuxedAlphaHVCCOrLHVC = FigHEVCBridge_CreateMuxedAlphaHVCCOrLHVC(v22, v39, 0, a3, HIWORD(v70), (__CFData **)&cf);
  v41 = (void *)cf;
  if (!(_DWORD)MuxedAlphaHVCCOrLHVC)
  {
    if (cf)
    {
      v42 = CFGetTypeID(cf);
      if (v42 == CFDataGetTypeID())
      {
        v65 = 0;
        FigCFArrayGetInt16AtIndex(theArray, 1, &v65);
        updated = hevcbridge_updateConfigRecordNuhLayerID(MutableCopy, 1, v65);
        if ((_DWORD)updated)
          goto LABEL_71;
        FigCFArrayGetInt16AtIndex(a6, 1, &v70);
        updated = FigHEVCBridge_CreateMuxedAlphaHVCCOrLHVC(MutableCopy, v35, 1, 0, (unsigned __int16)v70, (__CFData **)&v71);
        if ((_DWORD)updated)
          goto LABEL_71;
        v44 = (const __CFData *)v71;
        if (v71 && (v45 = CFGetTypeID(v71), v45 == CFDataGetTypeID()))
        {
          if (v38)
          {
            v46 = v44;
            v47 = v61;
          }
          else
          {
            updated = hevcbridge_copyModifedAlphaSPSAndPPSFromHVCCOrLHVC(v32, 0, HIWORD(v70), &theData, &v68);
            if ((_DWORD)updated)
              goto LABEL_71;
            v50 = theData;
            v76[0] = CFDataGetBytePtr(theData);
            v51 = v68;
            v76[1] = CFDataGetBytePtr(v68);
            v75[0] = CFDataGetLength(v50);
            v75[1] = CFDataGetLength(v51);
            updated = hevcbridgeCreateLHVCFromHEVCParameterSets(v44, (uint64_t)v76, (uint64_t)v75, (__CFData **)&v67);
            if ((_DWORD)updated)
              goto LABEL_71;
            v46 = v67;
            v71 = v67;
            v47 = v61;
            if (v67)
              CFRetain(v67);
            CFRelease(v44);
          }
          v52 = CFDictionaryCreateMutableCopy(v27, 0, theDict);
          if (v52)
          {
            v53 = v52;
            v54 = CFDictionaryCreateMutableCopy(v27, 0, v20);
            if (v54)
            {
              v55 = v54;
              CFDictionarySetValue(v54, CFSTR("hvcC"), v41);
              CFDictionarySetValue(v55, CFSTR("lhvC"), v46);
              CFDictionarySetValue(v53, CFSTR("SampleDescriptionExtensionAtoms"), v55);
              CFDictionarySetValue(v53, CFSTR("ContainsAlphaChannel"), (const void *)*MEMORY[0x1E0C9AE50]);
              v56 = (const void **)&kCMFormatDescriptionAlphaChannelMode_PremultipliedAlpha;
              if (!v74)
                v56 = (const void **)&kCMFormatDescriptionAlphaChannelMode_StraightAlpha;
              CFDictionarySetValue(v53, CFSTR("AlphaChannelMode"), *v56);
              CFDictionaryRemoveValue(v53, CFSTR("VerbatimSampleDescription"));
              CFDictionaryRemoveValue(v53, CFSTR("VerbatimISOSampleEntry"));
              v49 = CMVideoFormatDescriptionCreate(v27, 0x68766331u, v62.width, v62.height, v53, &formatDescriptionOut);
              if (!(_DWORD)v49)
              {
                *v47 = formatDescriptionOut;
                formatDescriptionOut = 0;
              }
              CFRelease(v53);
              v57 = v55;
            }
            else
            {
              v49 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
              v57 = v53;
            }
            CFRelease(v57);
            goto LABEL_49;
          }
          v60 = 4294954583;
        }
        else
        {
          v60 = 4294954581;
        }
        updated = FigSignalErrorAt(v60, 0, 0, 0, 0, 0, 0);
LABEL_71:
        v49 = updated;
LABEL_49:
        CFRelease(MutableCopy);
LABEL_50:
        v58 = (CFMutableDataRef)v41;
LABEL_51:
        CFRelease(v58);
        goto LABEL_52;
      }
    }
    MuxedAlphaHVCCOrLHVC = FigSignalErrorAt(4294954581, 0, 0, 0, 0, 0, 0);
  }
  v49 = MuxedAlphaHVCCOrLHVC;
  CFRelease(MutableCopy);
  if (v41)
    goto LABEL_50;
LABEL_52:
  if (v71)
    CFRelease(v71);
  if (theData)
    CFRelease(theData);
  if (v68)
    CFRelease(v68);
  if (v67)
    CFRelease(v67);
  return v49;
}

uint64_t FigHEVCBridge_CreateMuxedAlphaDataBuffer(OpaqueCMBlockBuffer *a1, OpaqueCMBlockBuffer *a2, CMBlockBufferRef *a3)
{
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v7;
  uint64_t appended;
  uint64_t v9;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
  v7 = Mutable;
  appended = FigCFArrayAppendInt32(Mutable, 1);
  if (!(_DWORD)appended)
    appended = FigHEVCBridge_CreateMultiviewMuxedAlphaDataBuffer(a1, a2, 0, v7, a3);
  v9 = appended;
  CFRelease(v7);
  return v9;
}

uint64_t FigHEVCBridge_CreateMultiviewMuxedAlphaDataBuffer(OpaqueCMBlockBuffer *a1, OpaqueCMBlockBuffer *a2, const void *a3, const void *a4, CMBlockBufferRef *a5)
{
  size_t DataLength;
  size_t v11;
  unint64_t v12;
  uint64_t DataPointer;
  uint64_t updated;
  char *dataPointerOut;
  CMBlockBufferRef theBuffer;

  DataLength = CMBlockBufferGetDataLength(a1);
  v11 = CMBlockBufferGetDataLength(a2);
  dataPointerOut = 0;
  theBuffer = 0;
  if (a4 && (v12 = v11, (unint64_t)(CFArrayGetCount((CFArrayRef)a4) - 3) > 0xFFFFFFFFFFFFFFFDLL))
  {
    DataPointer = CMBlockBufferCreateWithMemoryBlock((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v12 + DataLength, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, v12 + DataLength, 1u, &theBuffer);
    if ((_DWORD)DataPointer
      || (DataPointer = CMBlockBufferGetDataPointer(theBuffer, 0, 0, 0, &dataPointerOut), (_DWORD)DataPointer)
      || (DataPointer = CMBlockBufferCopyDataBytes(a1, 0, DataLength, dataPointerOut), (_DWORD)DataPointer)
      || a3
      && (DataPointer = hevcbridge_updateNuhLayerIDs((uint64_t)dataPointerOut, DataLength, a3), (_DWORD)DataPointer)
      || (DataPointer = CMBlockBufferCopyDataBytes(a2, 0, v12, &dataPointerOut[DataLength]), (_DWORD)DataPointer))
    {
      updated = DataPointer;
    }
    else
    {
      updated = hevcbridge_updateNuhLayerIDs((uint64_t)&dataPointerOut[DataLength], v12, a4);
      if (!(_DWORD)updated)
      {
        *a5 = theBuffer;
        return updated;
      }
    }
  }
  else
  {
    FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    updated = 0;
  }
  if (theBuffer)
    CFRelease(theBuffer);
  return updated;
}

uint64_t hevcbridge_updateNuhLayerIDs(uint64_t a1, unint64_t a2, const void *a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v10;
  unsigned int v11;
  int v13;

  if (!a3)
    return 0;
  if (a2)
  {
    v6 = 0;
    while (v6 + 6 <= a2)
    {
      v7 = a1 + v6;
      v8 = bswap32(*(_DWORD *)(a1 + v6));
      v13 = 0;
      if (v8 < 2 || v6 + v8 + 4 > a2)
        break;
      v10 = (int)bswap32(*(unsigned __int16 *)(v7 + 4)) >> 16;
      if (v10 < 0)
        break;
      v11 = v10 & 0xFFFFFE07;
      FigCFArrayGetInt32AtIndex(a3, (v10 & 0x1F8) != 0, &v13);
      *(_WORD *)(v7 + 4) = bswap32(v11 | (8 * (unsigned __int16)v13)) >> 16;
      v6 += (v8 + 4);
      if (v6 >= a2)
        goto LABEL_13;
    }
    return FigSignalErrorAt(4294954577, 0, 0, 0, 0, 0, 0);
  }
  v6 = 0;
LABEL_13:
  if (v6 != a2)
    return FigSignalErrorAt(4294954577, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t FigHEVCBridge_CreateAmbientViewingEnvironmentSEINAL(unsigned int a1, int a2, int a3, CFDataRef *a4)
{
  uint64_t result;
  int BufferWithStartCodeEmulationBytes;
  CFDataRef v10;
  CFDataRef v11;
  UInt8 bytes[8];
  _QWORD v13[2];
  uint64_t v14[2];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  _QWORD v21[3];

  v21[2] = *MEMORY[0x1E0C80C00];
  memset(v21, 0, 13);
  v20 = 0;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v15 = 0u;
  *(_QWORD *)bytes = 0;
  v13[0] = 0;
  *(_QWORD *)((char *)v13 + 5) = 0;
  if (!a4)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v14[0] = (uint64_t)v21;
  v14[1] = 13;
  *(_QWORD *)&v17 = v21;
  BYTE9(v16) = 0;
  result = hevcbridgeUPush(v14, 1, 0);
  if (!(_DWORD)result)
  {
    result = hevcbridgeUPush(v14, 6, 39);
    if (!(_DWORD)result)
    {
      result = hevcbridgeUPush(v14, 6, 0);
      if (!(_DWORD)result)
      {
        result = hevcbridgeUPush(v14, 3, 1);
        if (!(_DWORD)result)
        {
          result = hevcbridgeUPush(v14, 8, 148);
          if (!(_DWORD)result)
          {
            result = hevcbridgeUPush(v14, 8, 8);
            if (!(_DWORD)result)
            {
              result = hevcbridgeUPushLong(v14, 32, a1);
              if (!(_DWORD)result)
              {
                result = hevcbridgeUPush(v14, 16, a2);
                if (!(_DWORD)result)
                {
                  result = hevcbridgeUPush(v14, 16, a3);
                  if (!(_DWORD)result)
                  {
                    BYTE4(v21[1]) = 0x80;
                    BufferWithStartCodeEmulationBytes = generateBufferWithStartCodeEmulationBytes(13, v21, (uint64_t)bytes);
                    v10 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, BufferWithStartCodeEmulationBytes);
                    if (v10)
                    {
                      v11 = v10;
                      result = 0;
                      *a4 = v11;
                    }
                    else
                    {
                      return FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void FigHEVCBridge_HLSfMP4ParsingInfoDestroy(void **a1)
{
  unint64_t v2;

  if (a1)
  {
    if (*a1)
    {
      v2 = 0;
      do
        free(a1[++v2]);
      while (v2 < (unint64_t)*a1);
    }
    free(a1);
  }
}

uint64_t FigHEVCBridge_CreateHLSfMP4ParsingInfoFromHVCCAndLHVCData(const void *a1, const void *a2, char a3, void ***a4)
{
  CFTypeID v8;
  CFTypeID v9;
  uint64_t HEVCParameterSetAtIndex;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void **v19;
  void **v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  const void *v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _OWORD v41[9];
  __int128 v42;
  _QWORD v43[14];

  v43[13] = *MEMORY[0x1E0C80C00];
  v39 = 0;
  v40 = 0;
  v37 = 0;
  v38 = 0;
  v36 = 0;
  if (!a1)
    goto LABEL_45;
  v8 = CFGetTypeID(a1);
  if (v8 != CFDataGetTypeID())
    goto LABEL_45;
  if (a2)
  {
    v9 = CFGetTypeID(a2);
    if (v9 != CFDataGetTypeID())
      goto LABEL_45;
  }
  if (!a4)
    goto LABEL_45;
  HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(a1, 1, 32, 0, 0, 0, (unint64_t)&v40, 0, 0, 0);
  if ((_DWORD)HEVCParameterSetAtIndex)
    goto LABEL_46;
  HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(a1, 1, 33, 0, 0, 0, (unint64_t)&v39, 0, 0, 0);
  if ((_DWORD)HEVCParameterSetAtIndex)
    goto LABEL_46;
  HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(a1, 1, 34, 0, 0, 0, (unint64_t)&v38, 0, 0, 0);
  if ((_DWORD)HEVCParameterSetAtIndex)
    goto LABEL_46;
  v11 = v40;
  if (!v40 || (v12 = v39) == 0 || (v13 = v38) == 0)
  {
LABEL_45:
    v17 = 4294954584;
    goto LABEL_19;
  }
  if (!a2)
  {
    v15 = 0;
    v14 = 0;
LABEL_17:
    v16 = v12 + v14 + v11 + v13 + v15;
    if (v16 < 0x1FFFFFFFFFFFFFFFLL)
    {
      v20 = (void **)malloc_type_calloc(1uLL, 8 * v16 + 8, 0x66E5F360uLL);
      if (v20)
      {
        v19 = v20;
        v21 = v40;
        v22 = v39 + v40;
        v23 = v39 + v40 + v38;
        v24 = v23 + v37;
        if (v23 + v37 + v36)
        {
          v25 = 0;
          while (1)
          {
            memset(v43, 0, 104);
            v42 = 0u;
            memset(v41, 0, sizeof(v41));
            v34 = 0;
            v35 = 0;
            v26 = v25 - v21;
            if (v25 < v21)
            {
              v27 = hevcbridge_getHEVCParameterSetAtIndex(a1, 1, 32, v25, (unint64_t)&v35, (unint64_t)&v34, 0, 0, 0, 0);
              goto LABEL_36;
            }
            v28 = v25 - v22;
            if (v25 >= v22)
            {
              v26 = v25 - v23;
              if (v25 < v23)
              {
                v29 = a1;
                v30 = 1;
LABEL_34:
                v31 = 34;
                v26 = v28;
                goto LABEL_35;
              }
              v28 = v25 - v24;
              if (v25 >= v24)
              {
                v29 = a2;
                v30 = 0;
                goto LABEL_34;
              }
              v29 = a2;
              v30 = 0;
            }
            else
            {
              v29 = a1;
              v30 = 1;
            }
            v31 = 33;
LABEL_35:
            v27 = hevcbridge_getHEVCParameterSetAtIndex(v29, v30, v31, v26, (unint64_t)&v35, (unint64_t)&v34, 0, 0, 0, 0);
LABEL_36:
            v18 = v27;
            if ((_DWORD)v27)
              goto LABEL_20;
            v32 = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v43, v35, v34, 1);
            if ((_DWORD)v32
              || (*(_QWORD *)&v42 = &v19[(_QWORD)*v19 + 1],
                  BYTE8(v42) = a3,
                  v32 = hevcbridgeParseNALUnit(v43, v41),
                  (_DWORD)v32))
            {
              v18 = v32;
              goto LABEL_20;
            }
            if (v19[(_QWORD)*v19 + 1])
              *v19 = (char *)*v19 + 1;
            ++v25;
            v21 = v40;
            v22 = v39 + v40;
            v23 = v39 + v40 + v38;
            v24 = v23 + v37;
            if (v25 >= v23 + v37 + v36)
              goto LABEL_42;
          }
        }
        goto LABEL_42;
      }
    }
    v17 = 4294954583;
LABEL_19:
    v18 = FigSignalErrorAt(v17, 0, 0, 0, 0, 0, 0);
    v19 = 0;
    if ((_DWORD)v18)
      goto LABEL_20;
LABEL_42:
    v18 = 0;
    *a4 = v19;
    return v18;
  }
  HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(a2, 0, 33, 0, 0, 0, (unint64_t)&v37, 0, 0, 0);
  if (!(_DWORD)HEVCParameterSetAtIndex)
  {
    HEVCParameterSetAtIndex = hevcbridge_getHEVCParameterSetAtIndex(a2, 0, 34, 0, 0, 0, (unint64_t)&v36, 0, 0, 0);
    if (!(_DWORD)HEVCParameterSetAtIndex)
    {
      v12 = v39;
      v11 = v40;
      v14 = v37;
      v13 = v38;
      v15 = v36;
      goto LABEL_17;
    }
  }
LABEL_46:
  v18 = HEVCParameterSetAtIndex;
  v19 = 0;
LABEL_20:
  FigHEVCBridge_HLSfMP4ParsingInfoDestroy(v19);
  return v18;
}

uint64_t FigHEVCBridge_CreateHLSfMP4ParsingInfoFromHVCCData(const void *a1, void ***a2)
{
  return FigHEVCBridge_CreateHLSfMP4ParsingInfoFromHVCCAndLHVCData(a1, 0, 1, a2);
}

uint64_t FigHEVCBridge_MeasureSliceHeader(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5)
{
  uint64_t result;
  _OWORD v8[3];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v12 = 0;
  v10 = 0u;
  v11 = 0u;
  v9 = 0u;
  memset(v8, 0, sizeof(v8));
  result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v8, a1, a2, 1);
  if (!(_DWORD)result)
  {
    *(_QWORD *)&v21 = *a3;
    *((_QWORD *)&v21 + 1) = a3 + 1;
    BYTE8(v15) = 1;
    *(_QWORD *)&v14 = hevcbridgeMeasureSliceHeaderCallbackUnsigned;
    result = hevcbridgeParseNALUnit(v8, &v13);
    if (!(_DWORD)result)
    {
      if (HIDWORD(v10))
      {
        return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        result = 0;
        *a5 = v9 - *(_QWORD *)&v8[0];
      }
    }
  }
  return result;
}

uint64_t hevcbridgeMeasureSliceHeaderCallbackUnsigned(uint64_t a1, int a2, unsigned int a3)
{
  unsigned int v3;

  if (a3 <= 0x1F)
    v3 = 0;
  else
    v3 = -12712;
  if (a2)
    return 4294954584;
  else
    return v3;
}

uint64_t FigHEVCBridge_LocateSliceHeaderForHLSfMP4EncryptableNAL(CMBlockBufferRef theBuffer, uint64_t a2, size_t a3, _QWORD *a4, _QWORD *a5, uint64_t a6, unint64_t a7, _QWORD *a8, uint64_t a9)
{
  uint64_t result;
  _QWORD *v14;
  size_t DataLength;
  size_t v18;
  unint64_t v19;
  size_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  size_t v25;
  uint64_t v26;
  unsigned int v27;
  _BOOL4 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  _BOOL4 v36;
  _BOOL4 v37;
  unsigned int destination;
  unsigned int v40;
  _QWORD v41[2];
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  destination = 0;
  result = 4294954584;
  if (!theBuffer || !a4)
    return result;
  v14 = a5;
  if (a5)
    *a5 = 0;
  if (a7)
    *(_QWORD *)a7 = 0;
  if (a8)
    *a8 = 0;
  if (a9)
    *(_QWORD *)a9 = 0;
  DataLength = CMBlockBufferGetDataLength(theBuffer);
  if (!DataLength)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  if (a3)
  {
    if (a3 + a2 <= DataLength)
      goto LABEL_18;
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  if (a2)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  a3 = DataLength;
LABEL_18:
  v40 = 0;
  v18 = a3 - 4;
  if (a3 != 4)
  {
    v19 = (unint64_t)a8;
    v20 = 0;
    v21 = a4;
    v22 = 0;
    v32 = (_QWORD *)v19;
    v23 = v19 | a9;
    v36 = v23 != 0;
    v37 = (v23 | a7) != 0;
    v34 = v21;
    v33 = v21 + 1;
    v35 = v14;
    do
    {
      result = CMBlockBufferCopyDataBytes(theBuffer, v20 + a2, 4uLL, &destination);
      if ((_DWORD)result)
        return result;
      v24 = bswap32(destination);
      destination = v24;
      if (v24 <= 1)
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      v25 = v20 + 4;
      if (v25 + v24 > a3)
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      v26 = v25 + a2;
      result = CMBlockBufferCopyDataBytes(theBuffer, v25 + a2, 1uLL, &v40);
      if ((_DWORD)result)
        return result;
      v27 = (v40 >> 1) & 0x3F;
      v40 = v27;
      if (v27 < 0xA || v27 - 19 < 2 || v27 <= 0x15 && ((1 << v27) & 0x270000) != 0)
      {
        v28 = v37;
        if (v22 != a6)
          v28 = 0;
        if (v28)
        {
          v29 = a6;
          if (a7)
            *(_QWORD *)a7 = v25;
          if (v36)
          {
            v30 = destination;
            v56 = 0u;
            v57 = 0u;
            v54 = 0u;
            v55 = 0u;
            v52 = 0u;
            v53 = 0u;
            v50 = 0u;
            v51 = 0u;
            v49 = 0u;
            v48 = 0u;
            v41[0] = 0;
            v47 = 0;
            v45 = 0u;
            v46 = 0u;
            v43 = 0u;
            v44 = 0u;
            v41[1] = v26 + destination;
            v42 = (unint64_t)theBuffer;
            result = CMBlockBufferGetDataPointer(theBuffer, v25 + a2, 0, 0, (char **)&v44);
            if ((_DWORD)result)
              return result;
            v41[0] = v44 - v26;
            *((_QWORD *)&v42 + 1) = v44;
            WORD4(v43) = 1;
            *((_QWORD *)&v44 + 1) = v44;
            *((_QWORD *)&v46 + 1) = 0;
            LODWORD(v47) = 0;
            v45 = 0uLL;
            result = hevcbridgeAdvanceInBitstream((uint64_t)v41, 0);
            if ((_DWORD)result)
              return result;
            *(_QWORD *)&v56 = *v34;
            *((_QWORD *)&v56 + 1) = v33;
            BYTE8(v50) = 1;
            *(_QWORD *)&v49 = hevcbridgeMeasureSliceHeaderCallbackUnsigned;
            result = hevcbridgeParseNALUnit(v41, &v48);
            if ((_DWORD)result)
              return result;
            if (HIDWORD(v45))
            {
              result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
              v31 = 0;
              if ((_DWORD)result)
                return result;
            }
            else
            {
              v31 = v44 - (v41[0] + v26);
            }
            if (v32)
              *v32 = v31 + v25;
            if (a9)
              *(_QWORD *)a9 = v30 - v31;
          }
          a6 = v29;
          v14 = v35;
          v18 = a3 - 4;
          if (!v35)
          {
            if (a6 == -1)
              return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
            return 0;
          }
        }
        ++v22;
      }
      v20 = v25 + destination;
    }
    while (v20 < v18);
    if (v22)
    {
      if (v14)
        *v14 = v22;
      if (v22 > a6)
        return 0;
    }
  }
  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t FigHEVCBridge_CheckVPSPrimaryAlphaLayerCompatibility(const void *a1, int *a2)
{
  CFTypeID v4;
  uint64_t HLSfMP4ParsingInfoFromHVCCAndLHVCData;
  uint64_t v6;
  uint64_t v7;
  const __CFData *v8;
  uint64_t v9;
  uint64_t v10;
  const UInt8 *BytePtr;
  CFIndex Length;
  _BOOL4 v14;
  uint64_t v15;
  int v16;
  int v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  void *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  CFDataRef theData;
  uint64_t v30;
  _OWORD v31[4];
  unsigned __int8 v32[72];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v26 = 0;
  v27 = 0;
  v25 = 0;
  v24 = 0;
  *a2 = 0;
  if (!a1 || (v4 = CFGetTypeID(a1), v4 != CFDataGetTypeID()))
  {
    HLSfMP4ParsingInfoFromHVCCAndLHVCData = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    goto LABEL_38;
  }
  HLSfMP4ParsingInfoFromHVCCAndLHVCData = FigHEVCBridge_CreateHLSfMP4ParsingInfoFromHVCCAndLHVCData(a1, 0, 0, (void ***)&v24);
  if ((_DWORD)HLSfMP4ParsingInfoFromHVCCAndLHVCData)
    goto LABEL_38;
  theData = 0;
  v30 = 0;
  v28 = 0;
  HLSfMP4ParsingInfoFromHVCCAndLHVCData = hevcbridge_getHEVCParameterSetAtIndex(a1, 1, 32, 0, (unint64_t)&v28, (unint64_t)&v30, 0, 0, 0, 0);
  if ((_DWORD)HLSfMP4ParsingInfoFromHVCCAndLHVCData)
    goto LABEL_38;
  v6 = FigHEVCBridge_CopyHEVCSEIPayloadData(a1, 176, (CFTypeRef *)&theData);
  v7 = v6;
  if (!(_DWORD)v6)
  {
    v8 = theData;
    if (theData)
    {
      v9 = v28;
      v10 = v30;
      BytePtr = CFDataGetBytePtr(theData);
      Length = CFDataGetLength(v8);
      memset(v32, 0, 64);
      memset(v31, 0, sizeof(v31));
      FigHEVCBridge_Get3DLayerIDSets(v9, v10, (uint64_t)BytePtr, Length, v32, v31);
      if (!(_DWORD)HLSfMP4ParsingInfoFromHVCCAndLHVCData)
      {
        v14 = v32[0] != 255 && LOBYTE(v31[0]) != 255;
        goto LABEL_16;
      }
LABEL_38:
      v7 = HLSfMP4ParsingInfoFromHVCCAndLHVCData;
      goto LABEL_36;
    }
  }
  if ((_DWORD)v6)
    goto LABEL_36;
  v14 = 0;
LABEL_16:
  HLSfMP4ParsingInfoFromHVCCAndLHVCData = hevcbridge_getHEVCParameterSetAtIndex(a1, 1, 32, 0, (unint64_t)&v26, (unint64_t)&v27, 0, 0, 0, 0);
  if ((_DWORD)HLSfMP4ParsingInfoFromHVCCAndLHVCData)
    goto LABEL_38;
  HLSfMP4ParsingInfoFromHVCCAndLHVCData = FigHEVCBridge_GetVPSAlphaChannelNuhLayerId(v26, v27, 0, &v25);
  if ((_DWORD)HLSfMP4ParsingInfoFromHVCCAndLHVCData)
    goto LABEL_38;
  if (*(_QWORD *)v24)
  {
    v15 = 0;
    v16 = 0;
    if (v14)
      v17 = 2;
    else
      v17 = 1;
    do
    {
      v18 = (_DWORD *)*((_QWORD *)v24 + v15 + 1);
      if (*v18 == 32)
      {
        v19 = 0;
        while (1)
        {
          v20 = *((unsigned __int8 *)v18 + v19 + 335);
          if (v25 == (_DWORD)v20)
          {
            v21 = (char *)v18 + v20;
            if (v21[76] || v21[140] == 0)
              break;
          }
          if (++v19 == 63)
            goto LABEL_32;
        }
        v16 = v17;
      }
LABEL_32:
      ++v15;
    }
    while (v15 != *(_QWORD *)v24);
  }
  else
  {
    v16 = 0;
  }
  v7 = 0;
  *a2 = v16;
LABEL_36:
  FigHEVCBridge_HLSfMP4ParsingInfoDestroy((void **)v24);
  return v7;
}

uint64_t FigHEVCBridge_CopyParsingInformation(uint64_t a1, uint64_t a2, _QWORD *a3, __CFString **a4)
{
  __CFString *Mutable;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  _OWORD v13[6];
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  _OWORD v17[8];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  memset(v17, 0, sizeof(v17));
  v15 = 0u;
  v16 = 0u;
  v14 = 0;
  memset(v13, 0, sizeof(v13));
  v9 = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v13, a1, a2, 1);
  if ((_DWORD)v9)
    goto LABEL_8;
  *(_QWORD *)&v10 = -1;
  *((_QWORD *)&v10 + 1) = -1;
  *(_OWORD *)((char *)&v17[6] + 8) = v10;
  *(_OWORD *)((char *)&v17[5] + 8) = v10;
  *(_OWORD *)((char *)&v17[4] + 8) = v10;
  *(_OWORD *)((char *)&v17[3] + 8) = v10;
  *(_OWORD *)((char *)&v17[2] + 8) = v10;
  *(_OWORD *)((char *)&v17[1] + 8) = v10;
  *(_OWORD *)((char *)v17 + 8) = v10;
  *(_QWORD *)&v15 = Mutable;
  *((_QWORD *)&v15 + 1) = hevcbridgeCopyParsingInformationCallbackFlag;
  *(_QWORD *)&v16 = hevcbridgeCopyParsingInformationCallbackUnsigned;
  *((_QWORD *)&v16 + 1) = hevcbridgeCopyParsingInformationCallbackSigned;
  *((_QWORD *)&v17[7] + 1) = -1;
  *(_QWORD *)&v17[0] = hevcbridgeCopyParsingInformationCallbackCFData;
  if (a3)
  {
    *(_QWORD *)&v17[6] = *a3;
    *((_QWORD *)&v17[6] + 1) = a3 + 1;
  }
  *(_QWORD *)&v17[7] = 0;
  v11 = hevcbridgeParseNALUnit(v13, &v15);
  if ((_DWORD)v11)
    CFStringAppendFormat(Mutable, 0, CFSTR("Error found: %d\n"), v11);
  if (!a4)
  {
LABEL_8:
    if (Mutable)
      CFRelease(Mutable);
  }
  else
  {
    *a4 = Mutable;
  }
  return v9;
}

uint64_t hevcbridgeCopyParsingInformationCallbackFlag(__CFString *a1, int a2, int a3, uint64_t a4)
{
  const char *v4;
  const char *v5;

  if (a2 < 0)
    v4 = "unknown field";
  else
    v4 = NALFieldsStrings[a2];
  v5 = "SET";
  if (!a3)
    v5 = "not set";
  if ((a4 & 0x80000000) != 0)
    CFStringAppendFormat(a1, 0, CFSTR("%s: %s\n"), v4, v5);
  else
    CFStringAppendFormat(a1, 0, CFSTR("%s[%d]: %s\n"), v4, a4, v5);
  return 0;
}

uint64_t hevcbridgeCopyParsingInformationCallbackUnsigned(__CFString *a1, int a2, uint64_t a3)
{
  const char *v3;
  char **v4;
  const char *v5;
  uint64_t v7;
  uint64_t v8;

  if (a2 < 0)
    v3 = "unknown field";
  else
    v3 = NALFieldsStrings[a2];
  if (a2 > 115)
  {
    if (a2 > 327)
    {
      if (a2 == 328)
      {
        CFStringAppendFormat(a1, 0, CFSTR("%s: %u (%f)\n"), v3, a3, (float)((float)a3 / 30.0));
        return 0;
      }
      if (a2 != 344)
        goto LABEL_33;
      v5 = "?";
      if ((int)a3 > 143)
      {
        switch((int)a3)
        {
          case 144:
            v5 = "content_light_level_info";
            break;
          case 145:
          case 146:
            goto LABEL_29;
          case 147:
            v5 = "alternative_transfer_characteristics";
            break;
          case 148:
            v5 = "ambient_viewing_environment";
            break;
          case 149:
            v5 = "content_color_volume";
            break;
          default:
            if ((_DWORD)a3 == 165)
            {
              v5 = "alpha_channel_info";
            }
            else if ((_DWORD)a3 == 176)
            {
              v5 = "three_dimensional_reference_displays_info";
            }
            break;
        }
      }
      else
      {
        switch((int)a3)
        {
          case 0:
            v5 = "buffering_period";
            break;
          case 1:
            v5 = "pic_timing";
            break;
          case 2:
          case 3:
            goto LABEL_29;
          case 4:
            v5 = "user_data_registered_itut35";
            break;
          case 5:
            v5 = "user_data_unregistered";
            break;
          default:
            switch((int)a3)
            {
              case 128:
                v5 = "structure_of_pictures_info";
                break;
              case 129:
                v5 = "active_parameter_sets";
                break;
              case 132:
                v5 = "decoded_picture_hash";
                break;
              case 137:
                v5 = "mastering_display_colour_volume";
                break;
              default:
                goto LABEL_29;
            }
            break;
        }
      }
      goto LABEL_29;
    }
    if (a2 == 116)
    {
      if (a3 <= 5)
      {
        v4 = off_1E28E0FA8;
        goto LABEL_27;
      }
    }
    else
    {
      if (a2 != 269)
        goto LABEL_33;
      if (a3 <= 2)
      {
        v4 = off_1E28E0FD8;
LABEL_27:
        v5 = v4[(int)a3];
        goto LABEL_29;
      }
    }
LABEL_28:
    v5 = "?";
    goto LABEL_29;
  }
  if (a2 > 29)
  {
    if (a2 == 30)
    {
      v7 = (unsigned __int16)a3;
      v8 = WORD1(a3);
      goto LABEL_31;
    }
    if (a2 != 72)
    {
LABEL_33:
      CFStringAppendFormat(a1, 0, CFSTR("%s: %u\n"), v3, a3);
      return 0;
    }
    if (a3 <= 3)
    {
      v4 = off_1E28E0F88;
      goto LABEL_27;
    }
    goto LABEL_28;
  }
  if (a2)
  {
    if (a2 == 27)
    {
      v7 = a3;
      v8 = a3 >> 8;
LABEL_31:
      CFStringAppendFormat(a1, 0, CFSTR("%s: %u and %u\n"), v3, v7, v8);
      return 0;
    }
    goto LABEL_33;
  }
  v5 = nalUnitTypeString[a3];
LABEL_29:
  CFStringAppendFormat(a1, 0, CFSTR("%s: %s (%u)\n"), v3, v5, a3);
  return 0;
}

uint64_t hevcbridgeCopyParsingInformationCallbackSigned(__CFString *a1, int a2, uint64_t a3)
{
  const char *v3;

  if (a2 < 0)
    v3 = "unknown field";
  else
    v3 = NALFieldsStrings[a2];
  CFStringAppendFormat(a1, 0, CFSTR("%s: %d\n"), v3, a3);
  return 0;
}

uint64_t hevcbridgeCopyParsingInformationCallbackCFData(__CFString *a1, int a2, CFDataRef theData)
{
  CFIndex Length;
  const UInt8 *BytePtr;
  const char *v8;
  unint64_t v9;
  BOOL v10;
  CFIndex v11;
  unsigned int v12;

  Length = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  if (a2 < 0)
    v8 = "unknown field";
  else
    v8 = NALFieldsStrings[a2];
  CFStringAppendFormat(a1, 0, CFSTR("%s: "), v8);
  CFStringAppendFormat(a1, 0, CFSTR("{length = %lu, bytes = 0x"), Length);
  if (Length < 25)
  {
    if (Length >= 1)
    {
      do
      {
        v12 = *BytePtr++;
        CFStringAppendFormat(a1, 0, CFSTR("%02x"), v12);
        --Length;
      }
      while (Length);
    }
  }
  else
  {
    v9 = 0;
    do
    {
      CFStringAppendFormat(a1, 0, CFSTR("%02x%02x%02x%02x"), BytePtr[v9], BytePtr[v9 + 1], BytePtr[v9 + 2], BytePtr[v9 + 3]);
      v10 = v9 >= 0xC;
      v9 += 4;
    }
    while (!v10);
    CFStringAppend(a1, CFSTR(" ... "));
    v11 = Length - 8;
    do
    {
      CFStringAppendFormat(a1, 0, CFSTR("%02x%02x%02x%02x"), BytePtr[v11], BytePtr[v11 + 1], BytePtr[v11 + 2], BytePtr[v11 + 3]);
      v11 += 4;
    }
    while (v11 < Length);
  }
  CFStringAppend(a1, CFSTR("}\n"));
  return 0;
}

uint64_t FigHEVCBridge_GetRPUMetadataFromRPU(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  __int128 v5;
  _QWORD v6[5];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  _OWORD v15[6];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  result = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v15, a1, a2, 0);
  if (!(_DWORD)result)
  {
    v14 = -1;
    *(_QWORD *)&v5 = -1;
    *((_QWORD *)&v5 + 1) = -1;
    v13 = v5;
    v12 = v5;
    v11 = v5;
    v10 = v5;
    v9 = v5;
    v8 = v5;
    v6[0] = a3;
    v6[1] = hevcbridgeGetRPUMetadataCallbackFlag;
    v7 = v5;
    v6[2] = hevcbridgeGetRPUMetadataCallbackUnsigned;
    v6[3] = hevcbridgeGetRPUMetadataCallbackSigned;
    v6[4] = hevcbridgeGetRPUMetadataCallbackCFData;
    return hevcbridgeParseDolbyRPUDataRBSP((uint64_t)v15, v6, a3);
  }
  return result;
}

uint64_t hevcbridgeGetRPUMetadataCallbackFlag()
{
  return 0;
}

uint64_t hevcbridgeGetRPUMetadataCallbackUnsigned(uint64_t a1, int a2, int a3)
{
  if (a3 != 62 && a2 == 0)
    return 4294954584;
  else
    return 0;
}

uint64_t hevcbridgeGetRPUMetadataCallbackSigned()
{
  return 0;
}

uint64_t hevcbridgeGetRPUMetadataCallbackCFData()
{
  return 0;
}

uint64_t hevcbridgeParseDolbyRPUDataRBSP(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  char v13;
  char v14;
  unsigned int v15;
  unsigned int v16;
  char v17;
  int v18;
  char v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t i;
  int v36;
  uint64_t j;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  _WORD *v42;
  char v43;
  char v44;
  int v45;
  char v46;
  int v47;
  char v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  char v54;
  int v55;
  uint64_t v56;
  int v57;
  int v58;
  int v59;
  int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  char v64;
  uint64_t v65;
  unsigned int v66;
  unsigned __int8 v67;
  unsigned __int8 v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unsigned __int8 v72;
  __int16 v73;
  unsigned int v74;
  unsigned __int8 v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  v77 = 0;
  v78 = 0;
  v76 = 0;
  v75 = 0;
  v74 = 0;
  v73 = 0;
  v72 = 0;
  v70 = 0;
  v71 = 0;
  v80 = 0;
  v79 = 0;
  v69 = 0;
  result = hevcbridgeUPullLong(a1, 8, (_DWORD *)&v78 + 1);
  if ((_DWORD)result)
    return result;
  if (HIDWORD(v78) != 25)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v7 = *(_QWORD *)((char *)a2 + 44);
  result = hevcbridgeUPullLong(a1, 6, &v78);
  if ((v7 & 1) != 0 && !(_DWORD)result)
    result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 412, v78, 0xFFFFFFFFLL);
  if ((_DWORD)result)
    return result;
  if ((_DWORD)v78 != 2)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v8 = *(_QWORD *)((char *)a2 + 44);
  result = hevcbridgeUPullLong(a1, 11, (_DWORD *)&v77 + 1);
  if ((v8 & 2) != 0 && !(_DWORD)result)
    result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 413, HIDWORD(v77), 0xFFFFFFFFLL);
  if ((_DWORD)result)
    return result;
  if (a3)
  {
    *(_BYTE *)(a3 + 6) = 2;
    *(_WORD *)(a3 + 8) = WORD2(v77);
  }
  v68 = 0;
  v9 = *(_QWORD *)((char *)a2 + 44);
  result = hevcbridgeUPullLong(a1, 4, (_DWORD *)&v69 + 1);
  if ((v9 & 4) != 0 && !(_DWORD)result)
    result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 414, HIDWORD(v69), 0xFFFFFFFFLL);
  if ((_DWORD)result)
    return result;
  result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 3) & 1, 415, &v69, 4);
  if ((_DWORD)result)
    return result;
  v67 = 0;
  result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 4) & 1, 416, &v67);
  if ((_DWORD)result)
    return result;
  v10 = v67;
  if (a3)
  {
    *(_BYTE *)(a3 + 10) = BYTE4(v69);
    *(_BYTE *)(a3 + 11) = v69;
    *(_BYTE *)(a3 + 12) = v10;
  }
  v66 = 0;
  v65 = 0;
  v64 = 0;
  if (!v10)
  {
    v22 = 0;
    v56 = 0;
    v12 = 0;
    v21 = 0;
    v20 = 0;
    v16 = 0;
    v18 = 0;
    goto LABEL_36;
  }
  LOBYTE(v61) = 0;
  result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 6) & 1, 418, &v61);
  if ((_DWORD)result)
    return result;
  v11 = v61;
  result = hevcbridgeUPullAlways(a1, (uint64_t)a2, *((unsigned __int8 *)a2 + 44) >> 7, 419, &v77, 2);
  if ((_DWORD)result)
    return result;
  v12 = v77;
  if ((_DWORD)v77)
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
  }
  else
  {
    result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 8) & 1, 420, &v76);
    if ((_DWORD)result)
      return result;
    v15 = v76;
    if (v11)
    {
      v63 = 0;
      v25 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 9) & 1, 421, &v63);
      if ((_DWORD)v25)
        return v25;
      v14 = v63;
    }
    else
    {
      v14 = 0;
    }
    v13 = v15;
  }
  result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 10) & 1, 422, &v65, 2);
  if ((_DWORD)result)
    return result;
  result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 11) & 1, 423, &v64);
  if ((_DWORD)result)
    return result;
  v54 = v13;
  LODWORD(v56) = v15;
  v46 = v65;
  v48 = v64;
  if ((v77 & 0x70000000000) != 0)
  {
    v43 = 0;
    v44 = 0;
    v16 = 0;
    HIDWORD(v56) = 0;
    v17 = 0;
    v50 = 0;
    v52 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
LABEL_32:
    if (a3)
    {
      *(_BYTE *)(a3 + 13) = 0;
      *(_BYTE *)(a3 + 14) = v11;
      *(_BYTE *)(a3 + 15) = v12;
      *(_BYTE *)(a3 + 16) = v54;
      *(_BYTE *)(a3 + 17) = v44;
      *(_BYTE *)(a3 + 18) = v14;
      *(_BYTE *)(a3 + 19) = v46;
      *(_BYTE *)(a3 + 20) = v48;
      *(_BYTE *)(a3 + 21) = v16;
      *(_BYTE *)(a3 + 22) = BYTE4(v56);
      *(_BYTE *)(a3 + 23) = v17;
      *(_BYTE *)(a3 + 24) = v20;
      *(_BYTE *)(a3 + 25) = v52;
      *(_BYTE *)(a3 + 26) = v18;
      *(_BYTE *)(a3 + 27) = v43;
      *(_BYTE *)(a3 + 28) = v50;
      *(_BYTE *)(a3 + 29) = v19;
    }
    v21 = v50;
    v22 = v52;
LABEL_36:
    result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 22) & 1, 434, &v73);
    if ((_DWORD)result)
      return result;
    v23 = v73;
    if ((_BYTE)v73 || !v18)
    {
      result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 23) & 1, 435, &v72);
      if ((_DWORD)result)
        return result;
      if (a3)
      {
        *(_BYTE *)(a3 + 30) = v23;
        v24 = v72;
        *(_BYTE *)(a3 + 31) = v72;
      }
      else
      {
        v24 = v72;
      }
      v55 = v23;
      if (v24)
      {
        v63 = 0;
        v25 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, HIBYTE(*((_DWORD *)a2 + 11)) & 1, 436, &v63);
        if (a3 && !(_DWORD)v25)
        {
          *(_BYTE *)(a3 + 32) = v63;
LABEL_175:
          if (!v55 || (v25 = hevcbridgeParseVdrDmDataPayload(a1, a2, v18, a3), !(_DWORD)v25))
          {
            v58 = 0;
            while (*(_DWORD *)(a1 + 76))
            {
              result = hevcbridgeUPullLong(a1, 1, &v58);
              if ((_DWORD)result)
                return result;
              if (v58)
              {
                FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
                return 4294954582;
              }
            }
            return hevcbridgeUPullLong(a1, 32, &v57);
          }
          return v25;
        }
LABEL_172:
        if (!(_DWORD)v25)
          goto LABEL_175;
        return v25;
      }
      v51 = v21;
      v53 = v22;
      v62 = 0;
      v63 = 0;
      result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 25) & 1, 437, &v63);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 26) & 1, 438, &v62);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 27) & 1, 439, (unsigned int *)&v71 + 1);
      if ((_DWORD)result)
        return result;
      if (a3)
      {
        *(_BYTE *)(a3 + 33) = v63;
        *(_BYTE *)(a3 + 34) = v62;
        v47 = HIDWORD(v71);
        *(_BYTE *)(a3 + 35) = BYTE4(v71);
      }
      else
      {
        v47 = HIDWORD(v71);
      }
      v45 = WORD2(v77) & 0x700;
      if ((v77 & 0x70000000000) == 0 && v47)
      {
        result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 28) & 1, 440, &v71, 4);
        if ((_DWORD)result)
          return result;
        v27 = v71;
        if (a3)
          *(_BYTE *)(a3 + 36) = v71;
        if (v27 == 14)
        {
          v60 = 0;
          v61 = 0;
          if (v47 == 2)
          {
            v25 = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 29) & 1, 441, &v61, 2);
            if ((_DWORD)v25)
              return v25;
            if (a3)
              *(_BYTE *)(a3 + 37) = v61;
          }
          result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 30) & 1, 442, &v60, 2);
          if (!a3 || (_DWORD)result)
          {
            if ((_DWORD)result)
              return result;
          }
          else
          {
            *(_BYTE *)(a3 + 38) = v60;
          }
        }
      }
      v28 = 0;
      v29 = v16 + 8;
      v49 = 46;
      do
      {
        v61 = 0;
        result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 35) & 1, 447, &v61);
        if ((_DWORD)result)
          return result;
        v30 = v61;
        if (v61 >= 0x10)
          return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        if (a3)
          *(_BYTE *)(a3 + v28 + 43) = v61;
        *((_DWORD *)&v79 + v28) = v30;
        v31 = v30 + 2;
        v32 = v49;
        do
        {
          v60 = 0;
          v25 = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 36) & 1, 448, &v60, v29);
          if (!a3 || (_DWORD)v25)
          {
            if ((_DWORD)v25)
              return v25;
          }
          else
          {
            *(_WORD *)(a3 + v32) = v60;
          }
          v32 += 2;
          --v31;
        }
        while (v31);
        v49 += 32;
        ++v28;
      }
      while (v28 != 3);
      if (!v45 && v20)
      {
        v60 = 0;
        v61 = 0;
        v33 = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 37) & 1, 449, &v61, 3);
        if ((_DWORD)v33)
          return v33;
        v34 = v61;
        if (a3)
          *(_BYTE *)(a3 + 238) = v61;
        if (v34)
        {
          for (i = 0; i != 3; ++i)
          {
            v59 = 0;
            result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 38) & 1, 450, &v59, 3);
            if (!a3 || (_DWORD)result)
            {
              if ((_DWORD)result)
                return result;
            }
            else
            {
              *(_BYTE *)(a3 + 239 + i) = v34;
            }
          }
        }
        v33 = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 39) & 1, 451, &v60, 3);
        if ((_DWORD)v33)
          return v33;
        v36 = v60;
        if (a3)
          *(_BYTE *)(a3 + 242) = v60;
        if (v36)
        {
          for (j = 0; j != 3; ++j)
          {
            v59 = 0;
            result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 40) & 1, 452, &v59, 3);
            if (!a3 || (_DWORD)result)
            {
              if ((_DWORD)result)
                return result;
            }
            else
            {
              *(_BYTE *)(a3 + 243 + j) = v59;
            }
          }
        }
      }
      if (v45 | v51)
      {
LABEL_127:
        result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 45) & 1, 457, (unsigned int *)&v70 + 1);
        if ((_DWORD)result)
          return result;
        result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 46) & 1, 458, (unsigned int *)&v70);
        if ((_DWORD)result)
          return result;
        v38 = v70;
        v39 = HIDWORD(v70);
        if (a3)
        {
          *(_BYTE *)(a3 + 313) = BYTE4(v70);
          *(_BYTE *)(a3 + 314) = v38;
        }
        if (v39 + v38)
        {
          v61 = 0;
          result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 47) & 1, 459, &v61);
          if (!a3 || (_DWORD)result)
          {
            if ((_DWORD)result)
              return result;
          }
          else
          {
            *(_BYTE *)(a3 + 315) = v61;
          }
        }
        v25 = hevcbridgeParseVDRRPUDataPayload(a1, a2, v39, v38, v12, v56, SWORD2(v77), v47, v53, v51, (uint64_t)&v79, a3);
        goto LABEL_172;
      }
      v60 = 0;
      v61 = 0;
      result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 41) & 1, 453, &v60, 3);
      if ((_DWORD)result)
        return result;
      if (a3)
      {
        *(_BYTE *)(a3 + 246) = v60;
        if (v47 != 2)
        {
          *(_BYTE *)(a3 + 247) = 0;
LABEL_153:
          v41 = 2;
LABEL_154:
          v42 = (_WORD *)(a3 + 248);
          do
          {
            v59 = 0;
            result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 43) & 1, 455, &v59, HIDWORD(v56) + 8);
            if (!a3 || (_DWORD)result)
            {
              if ((_DWORD)result)
                return result;
            }
            else
            {
              *v42 = v59;
            }
            ++v42;
            --v41;
          }
          while (v41);
          if (v47)
          {
            v59 = 0;
            result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 44) & 1, 456, &v59, 3);
            if (!a3 || (_DWORD)result)
            {
              if ((_DWORD)result)
                return result;
            }
            else
            {
              *(_BYTE *)(a3 + 312) = v59;
            }
          }
          goto LABEL_127;
        }
      }
      else if (v47 != 2)
      {
        goto LABEL_153;
      }
      result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 42) & 1, 454, &v61);
      if ((_DWORD)result)
        return result;
      v40 = v61;
      if (v61 >= 0x10)
        return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
      if (a3)
        *(_BYTE *)(a3 + 247) = v61;
      v41 = v40 + 2;
      goto LABEL_154;
    }
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  LOBYTE(v60) = 0;
  result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 12) & 1, 424, &v66);
  if ((_DWORD)result)
    return result;
  v16 = v66;
  if (v66 > 8)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 13) & 1, 425, (unsigned int *)&v65 + 1);
  if ((_DWORD)result)
    return result;
  HIDWORD(v56) = HIDWORD(v65);
  if (HIDWORD(v65) >> 8 < 0xE3)
  {
    v26 = HIDWORD(v65);
  }
  else
  {
    if ((v65 & 0xFF000000000000) != 0 || BYTE5(v65) - 229 < 0xFFFFFFFE)
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    v26 = BYTE4(v65);
  }
  if (v26 > 8)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v63 = 0;
  result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 14) & 1, 426, &v63);
  if ((_DWORD)result)
    return result;
  if (v63 >= 9)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v17 = v63;
  result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 15) & 1, 427, &v68);
  if ((_DWORD)result)
    return result;
  v20 = v68;
  if (v68)
  {
    v62 = 0;
    result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, HIWORD(*((_DWORD *)a2 + 11)) & 1, 428, &v75);
    if ((_DWORD)result)
      return result;
    v44 = 0;
    v52 = v75;
    if (!v12 && v75)
    {
      result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 17) & 1, 429, &v62);
      if ((_DWORD)result)
        return result;
      v44 = v62;
    }
  }
  else
  {
    v44 = 0;
    v52 = 0;
  }
  result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 18) & 1, 430, &v74, 3);
  if (!(_DWORD)result)
  {
    v18 = v74;
    if (v74 >= 8)
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 19) & 1, 431, &v60);
    if ((_DWORD)result)
      return result;
    result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 20) & 1, 432, (_BYTE *)&v73 + 1);
    if ((_DWORD)result)
      return result;
    v43 = v60;
    v19 = HIBYTE(v73);
    v50 = HIBYTE(v73);
    if (HIBYTE(v73))
    {
      v19 = 0;
    }
    else
    {
      v62 = 0;
      if (!v12 && v11)
      {
        result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 21) & 1, 433, &v62);
        if ((_DWORD)result)
          return result;
        v19 = v62;
      }
    }
    goto LABEL_32;
  }
  return result;
}

uint64_t FigHEVCBridge_GetRPUMetadata(const void *a1, size_t a2, uint64_t a3)
{
  uint64_t v6;
  _WORD *v7;
  void *v8;
  uint64_t v9;
  __int128 v10;
  unsigned int v11;
  uint64_t v12;
  int v14;
  uint64_t v15;
  _QWORD v16[5];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  _BYTE v25[96];
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v26 = 0;
  memset(v25, 0, sizeof(v25));
  v6 = a2 + 2;
  v7 = malloc_type_malloc(a2 + 2, 0x25C37DBFuLL);
  v8 = v7;
  if (!v7)
  {
    v9 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    goto LABEL_16;
  }
  *v7 = 380;
  memcpy(v7 + 1, a1, a2);
  v9 = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)v25, (uint64_t)v8, v6, 1);
  if ((_DWORD)v9)
  {
LABEL_16:
    v12 = v9;
    goto LABEL_14;
  }
  v24 = -1;
  *(_QWORD *)&v10 = -1;
  *((_QWORD *)&v10 + 1) = -1;
  v23 = v10;
  v22 = v10;
  v21 = v10;
  v20 = v10;
  v19 = v10;
  v18 = v10;
  v17 = v10;
  v16[0] = a3;
  v16[1] = hevcbridgeGetRPUMetadataCallbackFlag;
  v16[2] = hevcbridgeGetRPUMetadataCallbackUnsigned;
  v16[3] = hevcbridgeGetRPUMetadataCallbackSigned;
  v16[4] = hevcbridgeGetRPUMetadataCallbackCFData;
  v15 = 0;
  v11 = hevcbridgeUPullLong((uint64_t)v25, 1, (_DWORD *)&v15 + 1);
  if (!v11)
  {
    if (HIDWORD(v15))
    {
      v12 = 4294954582;
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_14;
    }
    v11 = hevcbridgeUPullLong((uint64_t)v25, 6, &v15);
    if (!v11)
    {
      if ((_DWORD)v15 == 62)
      {
        v11 = hevcbridgeUPullLong((uint64_t)v25, 6, &v14);
        if (!v11)
        {
          v11 = hevcbridgeUPullIfRequested((uint64_t)v25, (uint64_t)v16, 1, 2, 3);
          if (!v11)
            v11 = hevcbridgeParseDolbyRPUDataRBSP((uint64_t)v25, v16, a3);
        }
      }
      else
      {
        v11 = -12712;
      }
    }
  }
  if (v11 == 1)
    v12 = 0;
  else
    v12 = v11;
LABEL_14:
  free(v8);
  return v12;
}

uint64_t FigHEVCBridge_CreateDolbyRPUNAL(int *a1, CFDataRef *a2)
{
  int v2;
  char *v5;
  UInt8 *v6;
  UInt8 *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  unsigned __int16 *v29;
  unint64_t v30;
  unsigned __int8 *v31;
  uint64_t v32;
  char *v33;
  char *v34;
  unsigned int v35;
  char v36;
  CFIndex BufferWithStartCodeEmulationBytes;
  const __CFAllocator *v38;
  const __CFAllocator *GlobalCFAllocatorFigMalloc;
  CFDataRef v40;
  CFDataRef *v42;
  uint64_t v43[2];
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v49 = 0;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v44 = 0u;
  if (!a2)
  {
    v12 = FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
    v5 = 0;
    v7 = 0;
    goto LABEL_650;
  }
  v5 = (char *)malloc_type_calloc(1uLL, 0x1F4uLL, 0x53CC301uLL);
  v6 = (UInt8 *)malloc_type_calloc(1uLL, 0x1F4uLL, 0xD190390CuLL);
  v7 = v6;
  if (!v5 || !v6)
  {
    v8 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
    goto LABEL_601;
  }
  v43[0] = (uint64_t)v5;
  v43[1] = 500;
  *(_QWORD *)&v46 = v5;
  BYTE9(v45) = 0;
  if (!hevcbridgeUPush(v43, 8, 25)
    && !hevcbridgeUPush(v43, 6, 2)
    && !hevcbridgeUPush(v43, 11, 18))
  {
    if (v2 == 1)
    {
      if (hevcbridgeUPush(v43, 4, 0))
        goto LABEL_75;
    }
    else if (hevcbridgeUPush(v43, 4, 1))
    {
      goto LABEL_203;
    }
    if (!hevcbridgeUPush(v43, 4, 0)
      && !hevcbridgeUPush(v43, 1, 1)
      && !hevcbridgeUPush(v43, 1, 0)
      && !hevcbridgeUPush(v43, 2, 0)
      && !hevcbridgeUEPush((uint64_t)v43, 23)
      && !hevcbridgeUPush(v43, 2, 1))
    {
      if (v2 == 1)
      {
        if (hevcbridgeUPush(v43, 1, 1))
        {
LABEL_75:
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 384);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 6408);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 384);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 1153);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 7184);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 1184);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 1924);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 7952);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 1952);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 2688);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 8704);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 2752);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 3456);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 9536);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 3520);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 4288);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 10304);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 4224);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 4992);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 11008);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 4928);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 5760);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 11776);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 5760);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 96);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 7912);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 96);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 288);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 8104);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 288);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 480);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 8288);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 480);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 672);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 8448);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 672);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 96);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 7912);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 96);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 288);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 8104);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 288);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 480);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 8288);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 480);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 672);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 1);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 23, 8448);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeSEPush((uint64_t)v43, 0);
          if ((_DWORD)v8)
            goto LABEL_601;
          v9 = 672;
          goto LABEL_451;
        }
      }
      else if (hevcbridgeUPush(v43, 1, 0))
      {
        goto LABEL_203;
      }
      if (!hevcbridgeUEPush((uint64_t)v43, 2)
        && !hevcbridgeUEPush((uint64_t)v43, 2)
        && !hevcbridgeUEPush((uint64_t)v43, 4)
        && !hevcbridgeUPush(v43, 1, 0)
        && !hevcbridgeUPush(v43, 3, 0)
        && !hevcbridgeUPush(v43, 1, 0)
        && !hevcbridgeUPush(v43, 1, 1)
        && !hevcbridgeUPush(v43, 1, 1)
        && !hevcbridgeUPush(v43, 1, 0)
        && !hevcbridgeUEPush((uint64_t)v43, 0)
        && !hevcbridgeUEPush((uint64_t)v43, 0)
        && !hevcbridgeUEPush((uint64_t)v43, 0)
        && !hevcbridgeUEPush((uint64_t)v43, 7))
      {
        if (v2 == 1)
        {
          if (hevcbridgeUPush(v43, 10, 0)
            || hevcbridgeUPush(v43, 10, 128)
            || hevcbridgeUPush(v43, 10, 128)
            || hevcbridgeUPush(v43, 10, 128)
            || hevcbridgeUPush(v43, 10, 128)
            || hevcbridgeUPush(v43, 10, 128)
            || hevcbridgeUPush(v43, 10, 128)
            || hevcbridgeUPush(v43, 10, 128)
            || hevcbridgeUPush(v43, 10, 127)
            || hevcbridgeUEPush((uint64_t)v43, 3)
            || hevcbridgeUPush(v43, 10, 0)
            || hevcbridgeUPush(v43, 10, 256)
            || hevcbridgeUPush(v43, 10, 256)
            || hevcbridgeUPush(v43, 10, 256)
            || hevcbridgeUPush(v43, 10, 255)
            || hevcbridgeUEPush((uint64_t)v43, 3)
            || hevcbridgeUPush(v43, 10, 0)
            || hevcbridgeUPush(v43, 10, 256)
            || hevcbridgeUPush(v43, 10, 256)
            || hevcbridgeUPush(v43, 10, 256)
            || hevcbridgeUPush(v43, 10, 255))
          {
            goto LABEL_75;
          }
        }
        else if (hevcbridgeUPush(v43, 10, 63)
               || hevcbridgeUPush(v43, 10, 69)
               || hevcbridgeUPush(v43, 10, 230)
               || hevcbridgeUPush(v43, 10, 256)
               || hevcbridgeUPush(v43, 10, 256)
               || hevcbridgeUPush(v43, 10, 37)
               || hevcbridgeUPush(v43, 10, 16)
               || hevcbridgeUPush(v43, 10, 8)
               || hevcbridgeUPush(v43, 10, 7)
               || hevcbridgeUEPush((uint64_t)v43, 0)
               || hevcbridgeUPush(v43, 10, 0)
               || hevcbridgeUPush(v43, 10, 1023)
               || hevcbridgeUEPush((uint64_t)v43, 0)
               || hevcbridgeUPush(v43, 10, 0)
               || hevcbridgeUPush(v43, 10, 1023))
        {
          goto LABEL_203;
        }
        if (!hevcbridgeUEPush((uint64_t)v43, 0))
          hevcbridgeUEPush((uint64_t)v43, 0);
      }
    }
  }
  if (v2 == 1)
    goto LABEL_75;
LABEL_203:
  v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, -1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 7978928);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 8332855);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, -3);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 4889184);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, -1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 8269552);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 5186604);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, -2);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 3909327);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 1317527);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 5338528);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, -1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 7440486);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 2119979);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 2065496);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 2288524);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 7982780);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, -2);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 5409990);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 1585336);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 6);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 3460436);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, -14);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 3197328);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 8);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 615464);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 13);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 3921968);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, -30);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 6820672);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 16);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 5546752);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 28);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 1947392);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, -62);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 1244640);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeSEPush((uint64_t)v43, 34);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 23, 6094272);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v10 = *((unsigned __int8 *)a1 + 4);
  v11 = hevcbridgeUPush(v43, 2, 2);
  v12 = v11;
  if (v10)
  {
    if ((_DWORD)v11)
      goto LABEL_650;
    v8 = hevcbridgeSEPush((uint64_t)v43, 1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 1150183);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 87355);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 6228986);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -5);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 642500);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 1023296);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 5);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 6569512);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 9);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 5128216);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -12);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 4317296);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 8299905);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 5819931);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 3);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 2324124);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 7273546);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -5);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 1562484);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -12);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 3679480);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 18);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 6357360);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 8172981);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 3261951);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 5970055);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 927142);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 3525840);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 7);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 5110348);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -19);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 6236848);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUEPush((uint64_t)v43, 1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 2, 2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 6266112);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 4);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 193104);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 5369128);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 5);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 2553116);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 8009648);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -8);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 2772020);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 3122453);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 2961581);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -4);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 6769788);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 2565605);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -6);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 7864496);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 4777288);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 12);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 649616);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 7036536);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -4);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 1666406);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 406265);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 2901521);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 2680224);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 146340);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -8);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 1008052);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 4366810);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 4);
    if ((_DWORD)v8)
      goto LABEL_601;
    v9 = 5080852;
  }
  else
  {
    if ((_DWORD)v11)
      goto LABEL_650;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 4188155);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 705568);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 3);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 6778652);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 739652);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -4);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 6451088);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 4957009);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 5762128);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 5980826);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 6359965);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -4);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 3533214);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 7481723);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 3);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 1107168);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 7291404);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 8100137);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -10);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 5798904);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 6900831);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 4107935);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 762460);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 4106660);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 2620573);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 545445);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 12);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 2973664);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUEPush((uint64_t)v43, 1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 2, 2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 6389327);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 3);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 4438378);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 3214133);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 5);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 4263144);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 8212876);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -7);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 5336260);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 1628407);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 5426045);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -3);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 3531622);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 3136655);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -7);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 7907964);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 2444756);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 9);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 1229184);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 7962716);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -5);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 6901800);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 5917361);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 2863974);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 8253338);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -2);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 2372924);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, -5);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 712920);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 23, 1229046);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeSEPush((uint64_t)v43, 6);
    if ((_DWORD)v8)
      goto LABEL_601;
    v9 = 3243492;
  }
LABEL_451:
  v8 = hevcbridgeUPush(v43, 23, v9);
  if ((_DWORD)v8)
    goto LABEL_601;
  v13 = *a1;
  v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUEPush((uint64_t)v43, 1);
  if ((_DWORD)v8)
    goto LABEL_601;
  if (v13 == 1)
  {
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 0x2000);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 799);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 1681);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 0x2000);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, -933);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 1091);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 0x2000);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 267);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, -5545);
    if ((_DWORD)v8)
      goto LABEL_601;
    v14 = 0;
  }
  else
  {
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 9574);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 13802);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 9574);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, -1540);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, -5348);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 9574);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 17610);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v14 = 0x1000000;
  }
  v8 = hevcbridgeUPushLong(v43, 32, v14);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPushLong(v43, 32, 0x8000000u);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPushLong(v43, 32, 0x8000000u);
  if ((_DWORD)v8)
    goto LABEL_601;
  if (v13 == 1)
  {
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 17081);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, -349);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, -349);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, -349);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 17081);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, -349);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, -349);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, -349);
    if ((_DWORD)v8)
      goto LABEL_601;
    v15 = 17081;
  }
  else
  {
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 7222);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 8771);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 390);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 2654);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 12430);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 1300);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 0);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeIPush((uint64_t)v43, 16, 422);
    if ((_DWORD)v8)
      goto LABEL_601;
    v15 = 15962;
  }
  v8 = hevcbridgeIPush((uint64_t)v43, 16, v15);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 16, 0xFFFF);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 16, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 16, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPushLong(v43, 32, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 5, 12);
  if ((_DWORD)v8)
    goto LABEL_601;
  v16 = v13 == 1 ? 2 : 0;
  v8 = hevcbridgeUPush(v43, 2, v16);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 2, 0);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 2, 1);
  if ((_DWORD)v8)
    goto LABEL_601;
  v17 = *((_BYTE *)a1 + 4) ? 62 : 0;
  v8 = hevcbridgeUPush(v43, 12, v17);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 12, 3079);
  if ((_DWORD)v8)
    goto LABEL_601;
  v8 = hevcbridgeUPush(v43, 10, 42);
  if ((_DWORD)v8)
    goto LABEL_601;
  v18 = *((_BYTE *)a1 + 29120) != 0;
  if (*((_BYTE *)a1 + 29121))
    v18 += a1[7285];
  if (*((_BYTE *)a1 + 29123))
    ++v18;
  if (*((_BYTE *)a1 + 29124))
    ++v18;
  if (*((_BYTE *)a1 + 29125))
    ++v18;
  v19 = *((_BYTE *)a1 + 29131) ? v18 + 1 : v18;
  v8 = hevcbridgeUEPush((uint64_t)v43, v19);
  if ((_DWORD)v8)
    goto LABEL_601;
  hevcBridgeAlignToByte((uint64_t)v43);
  if (*((_BYTE *)a1 + 29120))
  {
    v8 = hevcbridgeUEPush((uint64_t)v43, 5);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 8, 1);
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14566));
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14567));
    if ((_DWORD)v8)
      goto LABEL_601;
    v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14568));
    if ((_DWORD)v8)
      goto LABEL_601;
    v20 = 5;
    while (--v20)
    {
      v8 = hevcbridgeUPush(v43, 1, 0);
      if ((_DWORD)v8)
        goto LABEL_601;
    }
  }
  v42 = a2;
  if (!*((_BYTE *)a1 + 29121) || !a1[7285])
  {
LABEL_555:
    if (*((_BYTE *)a1 + 29123))
    {
      v8 = hevcbridgeUEPush((uint64_t)v43, 3);
      if ((_DWORD)v8)
        goto LABEL_601;
      v8 = hevcbridgeUPush(v43, 8, 4);
      if ((_DWORD)v8)
        goto LABEL_601;
      v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14631));
      if ((_DWORD)v8)
        goto LABEL_601;
      v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14632));
      if ((_DWORD)v8)
        goto LABEL_601;
    }
    if (*((_BYTE *)a1 + 29124))
    {
      v8 = hevcbridgeUEPush((uint64_t)v43, 7);
      if ((_DWORD)v8)
        goto LABEL_601;
      v8 = hevcbridgeUPush(v43, 8, 5);
      if ((_DWORD)v8)
        goto LABEL_601;
      v8 = hevcbridgeUPush(v43, 13, *((unsigned __int16 *)a1 + 14633));
      if ((_DWORD)v8)
        goto LABEL_601;
      v8 = hevcbridgeUPush(v43, 13, *((unsigned __int16 *)a1 + 14634));
      if ((_DWORD)v8)
        goto LABEL_601;
      v8 = hevcbridgeUPush(v43, 13, *((unsigned __int16 *)a1 + 14635));
      if ((_DWORD)v8)
        goto LABEL_601;
      v8 = hevcbridgeUPush(v43, 13, *((unsigned __int16 *)a1 + 14636));
      if ((_DWORD)v8)
        goto LABEL_601;
      v24 = 5;
      while (--v24)
      {
        v8 = hevcbridgeUPush(v43, 1, 0);
        if ((_DWORD)v8)
          goto LABEL_601;
      }
    }
    if (!*((_BYTE *)a1 + 29125)
      || (v8 = hevcbridgeUEPush((uint64_t)v43, 8), !(_DWORD)v8)
      && (v8 = hevcbridgeUPush(v43, 8, 6), !(_DWORD)v8)
      && (v8 = hevcbridgeUPush(v43, 16, 0), !(_DWORD)v8)
      && (v8 = hevcbridgeUPush(v43, 16, 0), !(_DWORD)v8)
      && (v8 = hevcbridgeUPush(v43, 16, 0), !(_DWORD)v8)
      && (v8 = hevcbridgeUPush(v43, 16, 0), !(_DWORD)v8))
    {
      if (!*((_BYTE *)a1 + 4))
        goto LABEL_641;
      v25 = *((_BYTE *)a1 + 29122) != 0;
      if (*((_BYTE *)a1 + 29126))
        v25 += a1[7321];
      if (*((_BYTE *)a1 + 29127))
        ++v25;
      if (*((_BYTE *)a1 + 29128))
        v25 += a1[7372];
      if (*((_BYTE *)a1 + 29129))
        ++v25;
      v26 = *((_BYTE *)a1 + 29130) ? v25 + 1 : v25;
      if (!v26)
        goto LABEL_641;
      v8 = hevcbridgeUEPush((uint64_t)v43, v26);
      if (!(_DWORD)v8)
      {
        hevcBridgeAlignToByte((uint64_t)v43);
        if (*((_BYTE *)a1 + 29122))
        {
          v8 = hevcbridgeUEPush((uint64_t)v43, 5);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 8, 3);
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14628));
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14629));
          if ((_DWORD)v8)
            goto LABEL_601;
          v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 14630));
          if ((_DWORD)v8)
            goto LABEL_601;
          v27 = 5;
          while (--v27)
          {
            v8 = hevcbridgeUPush(v43, 1, 0);
            if ((_DWORD)v8)
              goto LABEL_601;
          }
        }
        if (*((_BYTE *)a1 + 29126) && a1[7321])
        {
          v28 = 0;
          v29 = (unsigned __int16 *)(a1 + 7326);
          do
          {
            v8 = hevcbridgeUEPush((uint64_t)v43, *((_DWORD *)v29 - 4));
            if ((_DWORD)v8)
              goto LABEL_601;
            v8 = hevcbridgeUPush(v43, 8, 8);
            if ((_DWORD)v8)
              goto LABEL_601;
            v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)v29 - 12));
            if ((_DWORD)v8)
              goto LABEL_601;
            v8 = hevcbridgeUPush(v43, 12, *(v29 - 5));
            if ((_DWORD)v8)
              goto LABEL_601;
            v8 = hevcbridgeUPush(v43, 12, *(v29 - 4));
            if ((_DWORD)v8)
              goto LABEL_601;
            v8 = hevcbridgeUPush(v43, 12, *(v29 - 3));
            if ((_DWORD)v8)
              goto LABEL_601;
            v8 = hevcbridgeUPush(v43, 12, *(v29 - 2));
            if ((_DWORD)v8)
              goto LABEL_601;
            v8 = hevcbridgeUPush(v43, 12, *(v29 - 1));
            if ((_DWORD)v8)
              goto LABEL_601;
            v8 = hevcbridgeUPush(v43, 12, *v29);
            if ((_DWORD)v8)
              goto LABEL_601;
            v29 += 18;
          }
          while (++v28 < (unint64_t)a1[7321]);
        }
        if (!*((_BYTE *)a1 + 29127)
          || (v8 = hevcbridgeUEPush((uint64_t)v43, 1), !(_DWORD)v8)
          && (v8 = hevcbridgeUPush(v43, 8, 9), !(_DWORD)v8)
          && (v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)a1 + 29468)), !(_DWORD)v8))
        {
          if (*((_BYTE *)a1 + 29128) && a1[7372])
          {
            v30 = 0;
            v31 = (unsigned __int8 *)a1 + 29502;
            do
            {
              v8 = hevcbridgeUEPush((uint64_t)v43, *(_DWORD *)(v31 - 10));
              if ((_DWORD)v8)
                goto LABEL_601;
              v8 = hevcbridgeUPush(v43, 8, 10);
              if ((_DWORD)v8)
                goto LABEL_601;
              v8 = hevcbridgeUPush(v43, 8, *(v31 - 6));
              if ((_DWORD)v8)
                goto LABEL_601;
              v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)v31 - 2));
              if ((_DWORD)v8)
                goto LABEL_601;
              v8 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)v31 - 1));
              if ((_DWORD)v8)
                goto LABEL_601;
              v8 = hevcbridgeUPush(v43, 8, *v31);
              if ((_DWORD)v8)
                goto LABEL_601;
              ++v30;
              v31 += 28;
            }
            while (v30 < a1[7372]);
          }
          if (!*((_BYTE *)a1 + 29129)
            || (v8 = hevcbridgeUEPush((uint64_t)v43, 4), !(_DWORD)v8)
            && (v8 = hevcbridgeUPush(v43, 8, 11), !(_DWORD)v8)
            && (v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)a1 + 29604)), !(_DWORD)v8)
            && (v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)a1 + 29605)), !(_DWORD)v8)
            && (v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)a1 + 29606)), !(_DWORD)v8)
            && (v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)a1 + 29607)), !(_DWORD)v8))
          {
            if (!*((_BYTE *)a1 + 29130)
              || (v8 = hevcbridgeUEPush((uint64_t)v43, 2), !(_DWORD)v8)
              && (v8 = hevcbridgeUPush(v43, 8, 254), !(_DWORD)v8)
              && (v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)a1 + 29608)), !(_DWORD)v8)
              && (v8 = hevcbridgeUPush(v43, 8, *((unsigned __int8 *)a1 + 29609)), !(_DWORD)v8))
            {
LABEL_641:
              hevcBridgeAlignToByte((uint64_t)v43);
              v32 = v46 - v43[0];
              v33 = &v5[v46 - v43[0]];
              if ((uint64_t)v46 - v43[0] - 1 < 1)
              {
                v35 = -1;
              }
              else
              {
                v34 = v5 + 1;
                v35 = -1;
                do
                {
                  v36 = *v34++;
                  v35 = CRC32Lut[(v36 ^ HIBYTE(v35))] ^ (v35 << 8);
                }
                while (v34 < v33);
              }
              *(_DWORD *)v33 = bswap32(v35);
              v5[v32 + 4] = 0x80;
              BufferWithStartCodeEmulationBytes = (int)generateBufferWithStartCodeEmulationBytes(v32 + 5, v5, (uint64_t)v7);
              v38 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
              GlobalCFAllocatorFigMalloc = (const __CFAllocator *)FigGetGlobalCFAllocatorFigMalloc();
              v40 = CFDataCreateWithBytesNoCopy(v38, v7, BufferWithStartCodeEmulationBytes, GlobalCFAllocatorFigMalloc);
              if (v40)
              {
                v7 = 0;
                v12 = 0;
                *v42 = v40;
              }
              else
              {
                v12 = 0;
              }
              goto LABEL_650;
            }
          }
        }
      }
    }
LABEL_601:
    v12 = v8;
    goto LABEL_650;
  }
  v21 = 0;
  while (1)
  {
    v22 = hevcbridgeUEPush((uint64_t)v43, 11);
    if ((_DWORD)v22)
      break;
    v22 = hevcbridgeUPush(v43, 8, 2);
    if ((_DWORD)v22)
      break;
    v22 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 7 * v21 + 14572));
    if ((_DWORD)v22)
      break;
    v22 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 7 * v21 + 14573));
    if ((_DWORD)v22)
      break;
    v22 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 7 * v21 + 14574));
    if ((_DWORD)v22)
      break;
    v22 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 7 * v21 + 14575));
    if ((_DWORD)v22)
      break;
    v22 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 7 * v21 + 14576));
    if ((_DWORD)v22)
      break;
    v22 = hevcbridgeUPush(v43, 12, *((unsigned __int16 *)a1 + 7 * v21 + 14577));
    if ((_DWORD)v22)
      break;
    v22 = hevcbridgeIPush((uint64_t)v43, 13, *((__int16 *)a1 + 7 * v21 + 14578));
    if ((_DWORD)v22)
      break;
    v23 = 4;
    while (--v23)
    {
      v22 = hevcbridgeUPush(v43, 1, 0);
      if ((_DWORD)v22)
        goto LABEL_649;
    }
    if (++v21 >= (unint64_t)a1[7285])
      goto LABEL_555;
  }
LABEL_649:
  v12 = v22;
LABEL_650:
  free(v5);
  free(v7);
  return v12;
}

uint64_t FigHEVCBridge_WritePaddingNALU(unsigned int a1, unsigned int a2, _WORD *a3)
{
  size_t v5;
  unsigned int v6;
  _WORD *v7;

  if (a3)
  {
    if (a2 <= 4 && ((1 << a2) & 0x16) != 0)
    {
      v5 = a1 - (a2 + 2);
      if (a1 > a2 + 2)
      {
        v6 = a1 - a2;
        if (a2 == 2)
        {
          if (a1 < 0x10000)
          {
            *a3 = bswap32(v6) >> 16;
            goto LABEL_14;
          }
        }
        else if (a2 == 1)
        {
          if (a1 < 0x100)
          {
            *(_BYTE *)a3 = v6;
LABEL_14:
            v7 = (_WORD *)((char *)a3 + a2);
            *v7 = 332;
            memset(v7 + 1, 255, v5);
            *((_BYTE *)a3 + a1 - 1) = 0x80;
            return 0;
          }
        }
        else if (a1 <= 0x10000 || a2 != 4)
        {
          *(_DWORD *)a3 = bswap32(v6);
          goto LABEL_14;
        }
      }
    }
  }
  return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
}

uint64_t hevcbridgeAdvanceInBitstream(uint64_t a1, int a2)
{
  int v3;
  int v4;
  size_t v5;
  char v6;
  _BYTE *v7;
  uint64_t v8;
  uint8x8_t v10;
  unsigned int v11;
  unsigned int *v12;
  uint64_t result;
  uint64_t v14;
  unsigned int v15;
  BOOL v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v21;
  unsigned int *v22;
  int v23;

  v3 = *(_DWORD *)(a1 + 76) + a2;
  v4 = v3 >> 3;
  *(_DWORD *)(a1 + 76) = v3 & 7;
  if (!*(_BYTE *)(a1 + 40))
  {
    v12 = (unsigned int *)(*(_QWORD *)(a1 + 48) + v4);
    *(_QWORD *)(a1 + 48) = v12;
    if ((unint64_t)(v12 + 1) <= *(_QWORD *)(a1 + 24))
      goto LABEL_24;
    if (*(_QWORD *)(a1 + 16))
    {
      result = hevcbridgeAdvanceAcrossBBufDiscontiguity(a1, 0);
      if ((_DWORD)result)
        return result;
      v12 = *(unsigned int **)(a1 + 48);
    }
    v14 = *(_QWORD *)(a1 + 8) + *(_QWORD *)a1 - (_QWORD)v12;
    if (v14 > 3)
    {
LABEL_24:
      v11 = *v12;
      goto LABEL_25;
    }
    v15 = 0;
    v21 = 3;
    v22 = v12;
    do
    {
      if (v14 >= 1)
      {
        v23 = *(unsigned __int8 *)v22;
        v22 = (unsigned int *)((char *)v22 + 1);
        v15 |= v23;
        --v14;
      }
      v15 <<= 8;
      --v21;
    }
    while (v21);
    *(_DWORD *)(a1 + 80) = v15;
    if (v22 != v12)
      goto LABEL_26;
    *(_BYTE *)(a1 + 41) = 1;
    if (!v14 && !*(_DWORD *)(a1 + 76))
      goto LABEL_26;
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  v5 = (*(_DWORD *)(a1 + 72) - v4);
  *(_DWORD *)(a1 + 72) = v5;
  if (!a2 || v3 >= 8)
  {
    if (v4 >= 8)
      v6 = 8;
    else
      v6 = v3 >> 3;
    *(_DWORD *)(a1 + 96) >>= v6;
    if ((int)v5 >= 1)
    {
      memmove((void *)(a1 + 64), (const void *)(a1 + 64 + v4), v5);
      LODWORD(v5) = *(_DWORD *)(a1 + 72);
    }
    v7 = *(_BYTE **)(a1 + 56);
    v8 = *(_QWORD *)(a1 + 8) + *(_QWORD *)a1 - (_QWORD)v7;
    if ((int)v5 <= 3 && v8 >= 1)
    {
      do
      {
        if ((unint64_t)(v7 + 3) > *(_QWORD *)(a1 + 24) && *(_QWORD *)(a1 + 16))
        {
          result = hevcbridgeAdvanceAcrossBBufDiscontiguity(a1, 1);
          if ((_DWORD)result)
            return result;
          v7 = *(_BYTE **)(a1 + 56);
        }
        if (*v7)
          v16 = 0;
        else
          v16 = (unint64_t)v8 >= 3;
        if (v16 && !v7[1] && v7[2] == 3)
        {
          v17 = *(unsigned int *)(a1 + 72);
          if ((v17 & 0x80000000) == 0)
          {
            *(_BYTE *)(a1 + v17 + 64) = 0;
            LODWORD(v17) = *(_DWORD *)(a1 + 72);
          }
          *(_DWORD *)(a1 + 72) = v17 + 1;
          if ((int)v17 <= -2)
          {
            LODWORD(v5) = v17 + 2;
            *(_DWORD *)(a1 + 72) = v17 + 2;
            v7 += 3;
            *(_QWORD *)(a1 + 56) = v7;
          }
          else
          {
            *(_BYTE *)(a1 + (v17 + 1) + 64) = 0;
            v18 = *(_DWORD *)(a1 + 72);
            LODWORD(v5) = v18 + 1;
            *(_DWORD *)(a1 + 72) = v18 + 1;
            v7 += 3;
            *(_QWORD *)(a1 + 56) = v7;
            if (v18 >= 1)
              *(_DWORD *)(a1 + 96) |= 1 << v18;
          }
          v8 -= 3;
          ++*(_QWORD *)(a1 + 88);
        }
        else
        {
          v19 = *(unsigned int *)(a1 + 72);
          if ((v19 & 0x80000000) == 0)
          {
            *(_BYTE *)(a1 + v19 + 64) = *v7;
            LODWORD(v19) = *(_DWORD *)(a1 + 72);
          }
          LODWORD(v5) = v19 + 1;
          *(_DWORD *)(a1 + 72) = v19 + 1;
          *(_QWORD *)(a1 + 56) = ++v7;
          --v8;
        }
      }
      while ((int)v5 <= 3 && v8 > 0);
    }
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)*(unsigned int *)(a1 + 96));
    v10.i16[0] = vaddlv_u8(v10);
    *(_QWORD *)(a1 + 48) = &v7[-(int)v5 - v10.u32[0]];
  }
  if ((int)v5 <= 0)
  {
    *(_BYTE *)(a1 + 41) = 1;
    if ((_DWORD)v5 || *(_DWORD *)(a1 + 76))
      return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  }
  v11 = *(_DWORD *)(a1 + 64);
LABEL_25:
  v15 = bswap32(v11);
LABEL_26:
  result = 0;
  *(_DWORD *)(a1 + 80) = v15 << *(_DWORD *)(a1 + 76);
  return result;
}

uint64_t hevcbridgeAdvanceAcrossBBufDiscontiguity(uint64_t a1, int a2)
{
  uint64_t v3;
  char *v4;
  size_t v5;
  uint64_t result;
  char *v7;
  char *v8;
  size_t v9;
  size_t totalLengthOut;
  size_t lengthAtOffsetOut;
  char *dataPointerOut;

  if (a2)
    v3 = 56;
  else
    v3 = 48;
  v4 = *(char **)(a1 + v3);
  lengthAtOffsetOut = 0;
  dataPointerOut = v4;
  v5 = (size_t)&v4[-*(_QWORD *)a1];
  totalLengthOut = 0;
  result = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(a1 + 16), v5, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut);
  if (!(_DWORD)result)
  {
    if (lengthAtOffsetOut > 7 || lengthAtOffsetOut == totalLengthOut)
    {
      v7 = dataPointerOut;
      v8 = &dataPointerOut[lengthAtOffsetOut];
LABEL_13:
      result = 0;
      *(_QWORD *)(a1 + 24) = v8;
      *(_QWORD *)a1 = &v7[-v5];
      *(_QWORD *)(a1 + v3) = v7;
      return result;
    }
    if (totalLengthOut >= 8)
      v9 = 8;
    else
      v9 = totalLengthOut;
    v7 = (char *)(a1 + 32);
    result = CMBlockBufferCopyDataBytes(*(CMBlockBufferRef *)(a1 + 16), v5, v9, (void *)(a1 + 32));
    if (!(_DWORD)result)
    {
      v8 = &v7[v9];
      goto LABEL_13;
    }
  }
  return result;
}

uint64_t hevcbridgeUPullLong(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t result;
  int v6;
  int v7;
  int v8;
  int v9;

  v9 = 0;
  if (*(_BYTE *)(a1 + 41) || a2 <= 0 || a2 >= 0x21)
  {
    result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_10;
  }
  if (a2 > 0x18)
  {
    v7 = 0;
    v8 = 0;
    result = hevcbridgeUPull(a1, a2 - 16, &v8);
    if (!(_DWORD)result)
    {
      result = hevcbridgeUPull(a1, 16, &v7);
      v6 = v7 + (v8 << 16);
      goto LABEL_8;
    }
LABEL_10:
    v6 = 0;
    goto LABEL_8;
  }
  result = hevcbridgeUPull(a1, a2, &v9);
  v6 = v9;
LABEL_8:
  *a3 = v6;
  return result;
}

uint64_t hevcbridgeUPullAlways(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5, int a6)
{
  uint64_t result;

  result = hevcbridgeUPullLong(a1, a6, a5);
  if (a3)
  {
    if (!(_DWORD)result)
      return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t))(a2 + 16))(*(_QWORD *)a2, a4, *a5, 0xFFFFFFFFLL);
  }
  return result;
}

uint64_t hevcbridgeParseVideoParameterSet(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void **v10;
  BOOL v11;
  _DWORD *v13;
  unsigned int v14;
  void *v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned __int8 v25;
  int v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  unsigned __int8 v32;
  _BYTE *v33;
  uint64_t v34;
  _BYTE *v35;
  int v36;
  unsigned int v37;
  char v38;
  __int16 v39;
  unsigned int v40;
  unsigned int v41;
  char v42;
  uint64_t v43;
  __int16 v44;
  unsigned int v45;

  v45 = 0;
  v44 = 0;
  v43 = 0;
  v42 = 0;
  v40 = 0;
  v41 = 0;
  v39 = 0;
  v4 = *(_QWORD *)((char *)a2 + 44);
  v5 = hevcbridgeUPullLong(a1, 4, &v45);
  v6 = v5;
  if ((v4 & 1) != 0 && !(_DWORD)v5)
    v6 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 3, v45, 0xFFFFFFFFLL);
  if (!(_DWORD)v6)
  {
    v7 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 1) & 1, 4, (_BYTE *)&v44 + 1);
    if ((_DWORD)v7)
      goto LABEL_7;
    v7 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 2) & 1, 5, &v44);
    if ((_DWORD)v7)
      goto LABEL_7;
    v17 = *(_QWORD *)((char *)a2 + 44);
    v18 = hevcbridgeUPullLong(a1, 6, (_DWORD *)&v43 + 1);
    v6 = v18;
    if ((v17 & 8) != 0 && !(_DWORD)v18)
      v6 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 6, HIDWORD(v43), 0xFFFFFFFFLL);
    if (!(_DWORD)v6)
    {
      v7 = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 4) & 1, 7, &v43, 3);
      if ((_DWORD)v7
        || (v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 5) & 1, 8),
            (_DWORD)v7)
        || (v7 = hevcbridgeUSkip(a1, 16), (_DWORD)v7))
      {
LABEL_7:
        v6 = v7;
        goto LABEL_8;
      }
      v19 = v43;
      v20 = hevcbridgeParseProfileTierLevel(a1, a2, 1, v43);
      v6 = v20;
      if ((_DWORD)v20 == 1)
      {
        v8 = 0;
        v9 = 0;
        v10 = (void **)a2[18];
        if (!v10)
          goto LABEL_22;
        goto LABEL_18;
      }
      if (!(_DWORD)v20)
      {
        v7 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 6) & 1, 9, &v42);
        if ((_DWORD)v7)
          goto LABEL_7;
        v21 = v42 ? 0 : v19;
        do
        {
          v7 = hevcbridgeUESkip(a1);
          if ((_DWORD)v7)
            goto LABEL_7;
          v7 = hevcbridgeUESkip(a1);
          if ((_DWORD)v7)
            goto LABEL_7;
          v7 = hevcbridgeUESkip(a1);
          if ((_DWORD)v7)
            goto LABEL_7;
          ++v21;
        }
        while (v21 <= v19);
        v7 = hevcbridgeUPullAlways(a1, (uint64_t)a2, *((unsigned __int8 *)a2 + 44) >> 7, 10, &v41, 6);
        if ((_DWORD)v7)
          goto LABEL_7;
        v7 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 8) & 1, 11, &v40);
        if ((_DWORD)v7)
          goto LABEL_7;
        v34 = v40;
        if (v40 < 0x400)
        {
          if (v40)
          {
            v22 = v41;
            v23 = v41 + 1;
            v35 = malloc_type_calloc(v40 + 1, v41 + 1, 0x100004077774924uLL);
            v24 = 1;
            v33 = malloc_type_calloc(v34 + 1, 1uLL, 0x100004077774924uLL);
LABEL_47:
            v25 = 0;
            v26 = 0;
            while (1)
            {
              LOBYTE(v37) = 0;
              v27 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 9) & 1, 12, &v37);
              if ((_DWORD)v27)
                break;
              if ((_BYTE)v37)
              {
                v28 = v26;
                v35[v23 * v24 + v25++] = v26;
                v29 = v22;
              }
              else
              {
                v29 = v22;
                v28 = v26;
              }
              v26 = v28 + 1;
              if (v28 + 1 > v29)
              {
                v33[v24++] = v25;
                if (v24 <= v34)
                  goto LABEL_47;
                goto LABEL_56;
              }
            }
          }
          else
          {
            v33 = 0;
            v35 = 0;
LABEL_56:
            v27 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 10) & 1, 13, (_BYTE *)&v39 + 1);
            if (!(_DWORD)v27)
            {
              if (!HIBYTE(v39))
                goto LABEL_75;
              v38 = 0;
              v37 = 0;
              v6 = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 11) & 1, 14, 32);
              if ((_DWORD)v6)
                goto LABEL_58;
              v6 = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 12) & 1, 15, 32);
              if ((_DWORD)v6)
                goto LABEL_58;
              v6 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 13) & 1, 16, &v38);
              if ((_DWORD)v6)
                goto LABEL_58;
              if (v38)
              {
                v6 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 14) & 1, 17);
                if ((_DWORD)v6)
                  goto LABEL_58;
              }
              v6 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 15) & 1, 18, &v37);
              if ((_DWORD)v6)
                goto LABEL_58;
              v30 = v37;
              if (v37)
              {
                v31 = 0;
                while (1)
                {
                  v27 = hevcbridgeUESkip(a1);
                  if ((_DWORD)v27)
                    break;
                  if (v31)
                  {
                    v36 = 0;
                    v27 = hevcbridgeUPull(a1, 1, &v36);
                    if ((_DWORD)v27)
                      break;
                    v32 = v36;
                  }
                  else
                  {
                    v32 = 1;
                  }
                  v6 = hevcbridgeParseHRDParameters(a1, (uint64_t)a2, v32, v19);
                  if ((_DWORD)v6)
                    goto LABEL_58;
                  if (v30 == ++v31)
                    goto LABEL_75;
                }
              }
              else
              {
LABEL_75:
                v6 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, HIWORD(*((_DWORD *)a2 + 11)) & 1, 19, &v39);
                if ((_DWORD)v6 || !(_BYTE)v39)
                  goto LABEL_58;
                v37 = 0;
                while (*(_DWORD *)(a1 + 76))
                {
                  v27 = hevcbridgeUPullLong(a1, 1, &v37);
                  if ((_DWORD)v27)
                    goto LABEL_57;
                  if (v37 != 1)
                  {
                    v6 = 4294954582;
                    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
                    goto LABEL_58;
                  }
                }
                v6 = hevcbridgeParseVPSExtension(a1, (uint64_t)a2, HIBYTE(v44), v44, HIDWORD(v43), v19, v34, v41, v35, v33);
                if ((_DWORD)v6)
                  goto LABEL_58;
                v27 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 17) & 1, 20, &v36);
              }
            }
          }
LABEL_57:
          v6 = v27;
LABEL_58:
          v8 = v35;
          v9 = v33;
          goto LABEL_9;
        }
        v6 = 4294954582;
        FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      }
    }
  }
LABEL_8:
  v8 = 0;
  v9 = 0;
LABEL_9:
  v10 = (void **)a2[18];
  if (v10)
    v11 = (_DWORD)v6 == 0;
  else
    v11 = 1;
  if (!v11 && (_DWORD)v6 != 1)
  {
    v15 = *v10;
    if (*v10)
    {
      *v10 = 0;
      free(v15);
    }
    goto LABEL_22;
  }
  if (!v10)
    goto LABEL_22;
LABEL_18:
  v13 = *v10;
  if (v13)
  {
    v14 = v45;
    *v13 = 32;
    v13[1] = v14;
  }
LABEL_22:
  free(v8);
  free(v9);
  return v6;
}

uint64_t hevcbridgeParseSequenceParameterSet(uint64_t a1, _QWORD *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void **v10;
  void *v11;
  _QWORD *v12;
  uint64_t v13;
  _DWORD *v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  char v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  int v35;
  char v36;
  unsigned int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  unsigned int v43;
  int v44;
  _BYTE *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  unsigned int v50;
  int v51;
  __int16 v52;
  __int16 v53;
  __int16 v54;
  __int16 v55;
  unsigned int count;
  char count_5;
  __int16 count_6;
  unsigned int v59;
  unsigned int v60;
  char v61;
  unsigned int v62;
  char v63;
  uint64_t v64;
  char v65;
  unsigned int v66;
  int v67;
  char v68;
  uint64_t v69;
  unsigned int v70;
  unsigned int v71;

  v71 = 0;
  v70 = 0;
  v69 = 0;
  v68 = 0;
  v66 = 0;
  v67 = 0;
  v65 = 0;
  v64 = 0;
  v63 = 0;
  v62 = 0;
  v61 = 0;
  v59 = 0;
  v60 = 0;
  count_6 = 0;
  count_5 = 0;
  count = 0;
  v55 = 0;
  v54 = 0;
  v53 = 0;
  v52 = 0;
  v51 = 0;
  v6 = *(_QWORD *)((char *)a2 + 44);
  v7 = hevcbridgeUPullLong(a1, 4, &v71);
  v8 = v7;
  if ((v6 & 1) != 0 && !(_DWORD)v7)
    v8 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 65, v71, 0xFFFFFFFFLL);
  if ((_DWORD)v8)
    goto LABEL_5;
  v12 = (_QWORD *)a2[17];
  if (v12 && (v13 = a2[16]) != 0)
  {
    while (1)
    {
      v14 = (_DWORD *)*v12;
      if (*(_DWORD *)*v12 == 32 && v14[1] == v71)
        break;
      ++v12;
      if (!--v13)
        goto LABEL_15;
    }
    v15 = *((unsigned __int8 *)v14 + 4494);
  }
  else
  {
LABEL_15:
    v15 = 0;
  }
  v16 = *(_QWORD *)((char *)a2 + 44);
  if (a3)
  {
    v17 = hevcbridgeUPullLong(a1, 3, (_DWORD *)&v69 + 1);
    v8 = v17;
    if ((v16 & 4) != 0 && !(_DWORD)v17)
      v8 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 67, HIDWORD(v69), 0xFFFFFFFFLL);
    if ((_DWORD)v8)
      goto LABEL_5;
    v18 = HIDWORD(v69);
    if (HIDWORD(v69) == 7)
      v18 = v15;
    v70 = v18;
    if (HIDWORD(v69) == 7)
    {
      v19 = 1;
      goto LABEL_35;
    }
  }
  else
  {
    v21 = hevcbridgeUPullLong(a1, 3, &v70);
    v8 = v21;
    if ((v16 & 2) != 0 && !(_DWORD)v21)
      v8 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 66, v70, 0xFFFFFFFFLL);
    if ((_DWORD)v8)
      goto LABEL_5;
  }
  v22 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 3) & 1, 68);
  if ((_DWORD)v22)
    goto LABEL_75;
  v15 = v70;
  v22 = hevcbridgeParseProfileTierLevel(a1, a2, 1, v70);
  if ((_DWORD)v22)
    goto LABEL_75;
  v19 = 0;
LABEL_35:
  v23 = *(_QWORD *)((char *)a2 + 44);
  v24 = hevcbridgeUEPullLong(a1, (unsigned int *)&v69);
  v8 = v24;
  if ((v23 & 0x10) != 0 && !(_DWORD)v24)
    v8 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 69, v69, 0xFFFFFFFFLL);
  if ((_DWORD)v8)
    goto LABEL_5;
  v25 = *((unsigned __int8 *)a2 + 44);
  if (v19)
  {
    v22 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (v25 >> 5) & 1, 70, &v68);
    if ((_DWORD)v22)
      goto LABEL_75;
    v26 = v68;
    if (v68)
    {
      v22 = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 6) & 1, 71, &v67, 8);
      if ((_DWORD)v22)
        goto LABEL_75;
    }
    v27 = 0;
  }
  else
  {
    v22 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (v25 >> 7) & 1, 72, &v66);
    if ((_DWORD)v22)
      goto LABEL_75;
    v27 = v66;
    if (v66 == 3)
    {
      v22 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 8) & 1, 73, &v65);
      if ((_DWORD)v22)
        goto LABEL_75;
    }
    v22 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 9) & 1, 74, (unsigned int *)&v64 + 1);
    if ((_DWORD)v22)
      goto LABEL_75;
    v22 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 10) & 1, 75, (unsigned int *)&v64);
    if ((_DWORD)v22)
      goto LABEL_75;
    v22 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 11) & 1, 76, &v63);
    if ((_DWORD)v22)
      goto LABEL_75;
    if (v63)
    {
      v22 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 12) & 1, 77);
      if ((_DWORD)v22)
        goto LABEL_75;
      v22 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 13) & 1, 78);
      if ((_DWORD)v22)
        goto LABEL_75;
      v22 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 14) & 1, 79);
      if ((_DWORD)v22)
        goto LABEL_75;
      v22 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 15) & 1, 80);
      if ((_DWORD)v22)
        goto LABEL_75;
    }
    v22 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, HIWORD(*((_DWORD *)a2 + 11)) & 1, 81);
    if ((_DWORD)v22)
      goto LABEL_75;
    v22 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 17) & 1, 82);
    if ((_DWORD)v22)
      goto LABEL_75;
    v26 = 0;
  }
  v22 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 18) & 1, 83, &v62);
  if ((_DWORD)v22)
    goto LABEL_75;
  v28 = v62;
  if (v62 >= 0xD)
  {
LABEL_105:
    v8 = 4294954582;
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_5;
  }
  if ((v19 & 1) == 0)
  {
    v22 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 19) & 1, 84, &v61);
    if (!(_DWORD)v22)
    {
      if (v61)
        v30 = 0;
      else
        v30 = v15;
      while (1)
      {
        v22 = hevcbridgeUESkip(a1);
        if ((_DWORD)v22)
          break;
        v22 = hevcbridgeUESkip(a1);
        if ((_DWORD)v22)
          break;
        v22 = hevcbridgeUESkip(a1);
        if ((_DWORD)v22)
          break;
        if (++v30 > v15)
          goto LABEL_47;
      }
    }
    goto LABEL_75;
  }
LABEL_47:
  v22 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 20) & 1, 85, &v60);
  if ((_DWORD)v22
    || (v22 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 21) & 1, 86, &v59), (_DWORD)v22)
    || (v22 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 22) & 1, 87), (_DWORD)v22)
    || (v22 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 23) & 1, 88), (_DWORD)v22)
    || (v22 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, HIBYTE(*((_DWORD *)a2 + 11)) & 1, 89), (_DWORD)v22)
    || (v22 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 25) & 1, 90), (_DWORD)v22)
    || (v22 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 26) & 1, 91, (_BYTE *)&count_6 + 1),
        (_DWORD)v22))
  {
LABEL_75:
    v8 = v22;
    goto LABEL_5;
  }
  if (!HIBYTE(count_6))
    goto LABEL_88;
  LOBYTE(v50) = 0;
  LOBYTE(v49) = 0;
  if (v19)
  {
    v8 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 27) & 1, 92, &v50);
    if ((_DWORD)v8)
    {
LABEL_5:
      v9 = 0;
      goto LABEL_6;
    }
    if ((_BYTE)v50)
    {
      v29 = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 28) & 1, 93, 6);
      goto LABEL_87;
    }
  }
  v8 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 29) & 1, 94, &v49);
  if ((_DWORD)v8)
    goto LABEL_5;
  if ((_BYTE)v49)
  {
    v29 = hevcbridgeParseScalingListData(a1);
LABEL_87:
    v8 = v29;
    if ((_DWORD)v29)
      goto LABEL_5;
  }
LABEL_88:
  v22 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 30) & 1, 95);
  if ((_DWORD)v22)
    goto LABEL_75;
  v22 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, *((_DWORD *)a2 + 11) >> 31, 96, &count_6);
  if ((_DWORD)v22)
    goto LABEL_75;
  v22 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, a2[6] & 1, 97, &count_5);
  if ((_DWORD)v22)
    goto LABEL_75;
  if (count_5)
  {
    v22 = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 33) & 1, 98, 4);
    if ((_DWORD)v22)
      goto LABEL_75;
    v22 = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 34) & 1, 99, 4);
    if ((_DWORD)v22)
      goto LABEL_75;
    v22 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 35) & 1, 100);
    if ((_DWORD)v22)
      goto LABEL_75;
    v22 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 36) & 1, 101);
    if ((_DWORD)v22)
      goto LABEL_75;
    v22 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 37) & 1, 102);
    if ((_DWORD)v22)
      goto LABEL_75;
  }
  v22 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 38) & 1, 103, &count);
  if ((_DWORD)v22)
    goto LABEL_75;
  v31 = count;
  if (count >= 0x41)
    goto LABEL_105;
  if (a2[18])
  {
    *(_QWORD *)a2[18] = malloc_type_calloc(1uLL, 164 * count + 96, 0xABF93FA2uLL);
    v32 = *(_QWORD *)a2[18];
    if (!v32)
    {
      v9 = 0;
      v8 = 4294954583;
      goto LABEL_6;
    }
    v33 = v69;
    *(_DWORD *)v32 = 33;
    *(_DWORD *)(v32 + 4) = v33;
    *(_DWORD *)(v32 + 8) = v71;
    v48 = v32 + 8;
    *(_BYTE *)(v32 + 53) = v19;
    v34 = v60;
    *(_DWORD *)(v32 + 12) = a3;
    *(_DWORD *)(v32 + 16) = v34;
    v35 = HIDWORD(v64);
    *(_DWORD *)(v32 + 20) = v59;
    *(_DWORD *)(v32 + 24) = v35;
    *(_DWORD *)(v32 + 28) = v64;
    *(_DWORD *)(v32 + 32) = v28;
    v36 = v65;
    if (v65)
      v37 = 0;
    else
      v37 = v27;
    v38 = v67;
    *(_DWORD *)(v32 + 44) = v37;
    *(_DWORD *)(v32 + 48) = v38;
    *(_BYTE *)(v32 + 52) = v26;
    *(_BYTE *)(v32 + 54) = v36;
    *(_BYTE *)(v32 + 88) = count_6;
    *(_BYTE *)(v32 + 89) = *((_BYTE *)a2 + 152);
    v9 = (void *)(v32 + 96);
    *(_DWORD *)(v32 + 92) = v31;
  }
  else
  {
    v9 = malloc_type_calloc(count, 0xA4uLL, 0x1000040B98E1C1EuLL);
    v48 = 0;
  }
  if ((_DWORD)v31)
  {
    v39 = 0;
    v40 = (uint64_t)v9;
    do
    {
      v41 = hevcbridgeParseSTRefPicSet(a1, v39, v31, (uint64_t)v9, v40);
      if ((_DWORD)v41)
        goto LABEL_112;
      ++v39;
      v40 += 164;
    }
    while (v31 != v39);
  }
  v41 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 39) & 1, 104, (_BYTE *)&v55 + 1);
  if ((_DWORD)v41)
  {
LABEL_112:
    v8 = v41;
    goto LABEL_6;
  }
  v42 = HIBYTE(v55);
  if (v48)
    *(_BYTE *)(v48 + 47) = HIBYTE(v55);
  if (v42)
  {
    v50 = 0;
    v8 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, *(_DWORD *)((_BYTE *)a2 + 49) & 1, 105, &v50);
    if ((_DWORD)v8)
      goto LABEL_6;
    v43 = v50;
    if (v50 > 0x20)
    {
      v8 = 4294954582;
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_6;
    }
    if (v50)
    {
      v44 = v28 + 4;
      v45 = (_BYTE *)(v48 + 48);
      v46 = v50;
      do
      {
        v41 = hevcbridgeUSkip(a1, v44);
        if ((_DWORD)v41)
          goto LABEL_112;
        v49 = 0;
        v47 = hevcbridgeUPull(a1, 1, &v49);
        v8 = v47;
        if (!v48 || (_DWORD)v47)
        {
          if ((_DWORD)v47)
            goto LABEL_6;
        }
        else
        {
          *v45 = v49;
        }
        ++v45;
      }
      while (--v46);
    }
    if (v48)
      *(_DWORD *)(v48 + 28) = v43;
  }
  v41 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 41) & 1, 106, &v55);
  if ((_DWORD)v41)
    goto LABEL_112;
  if (v48)
    *(_DWORD *)(v48 + 32) = v55;
  v41 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 42) & 1, 107);
  if ((_DWORD)v41)
    goto LABEL_112;
  v41 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 43) & 1, 108, (_BYTE *)&v54 + 1);
  if ((_DWORD)v41)
    goto LABEL_112;
  if (HIBYTE(v54))
  {
    v41 = hevcbridgeParseVUIParameters(a1, (uint64_t)a2, v15);
    if ((_DWORD)v41)
      goto LABEL_112;
  }
  v41 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 13) >> 19) & 1, 148, &v54);
  if ((_DWORD)v41)
    goto LABEL_112;
  if ((_BYTE)v54)
  {
    v41 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 13) >> 20) & 1, 149, (_BYTE *)&v53 + 1);
    if ((_DWORD)v41)
      goto LABEL_112;
    v41 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 13) >> 21) & 1, 150, &v53);
    if ((_DWORD)v41)
      goto LABEL_112;
    v41 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 13) >> 22) & 1, 151, (_BYTE *)&v52 + 1);
    if ((_DWORD)v41)
      goto LABEL_112;
    v41 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 13) >> 23) & 1, 152, &v52);
    if ((_DWORD)v41)
      goto LABEL_112;
    v41 = hevcbridgeUPullAlways(a1, (uint64_t)a2, *(_DWORD *)((_BYTE *)a2 + 55) & 1, 153, &v51, 4);
    if ((_DWORD)v41)
      goto LABEL_112;
    if (HIBYTE(v53))
    {
      v41 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 13) >> 25) & 1, 154);
      if ((_DWORD)v41)
        goto LABEL_112;
      v41 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 13) >> 26) & 1, 155);
      if ((_DWORD)v41)
        goto LABEL_112;
      v41 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 13) >> 27) & 1, 156);
      if ((_DWORD)v41)
        goto LABEL_112;
      v41 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 13) >> 28) & 1, 157);
      if ((_DWORD)v41)
        goto LABEL_112;
      v41 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 13) >> 29) & 1, 158);
      if ((_DWORD)v41)
        goto LABEL_112;
      v41 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 13) >> 30) & 1, 159);
      if ((_DWORD)v41)
        goto LABEL_112;
      v41 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, *((_DWORD *)a2 + 13) >> 31, 160);
      if ((_DWORD)v41)
        goto LABEL_112;
      v41 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, a2[7] & 1, 161);
      if ((_DWORD)v41)
        goto LABEL_112;
      v41 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 52) >> 33) & 1, 162);
      if ((_DWORD)v41)
        goto LABEL_112;
    }
  }
  v8 = 0;
LABEL_6:
  v10 = (void **)a2[18];
  if (!v10)
  {
    v11 = v9;
    goto LABEL_26;
  }
  if (v8 >= 2)
  {
    v11 = *v10;
    if (*v10)
    {
      *v10 = 0;
LABEL_26:
      free(v11);
    }
  }
  return v8;
}

uint64_t hevcbridgeParsePictureParameterSet(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  char v14;
  char v15;
  uint64_t v16;
  char v17;
  int v18;
  uint64_t v19;
  void **v20;
  void *v21;
  unsigned int v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  char v27;
  unsigned int v28;
  unsigned int v29;
  char v30;
  int v31;
  char v32;
  __int16 v33;
  __int16 v34;
  __int16 v35;
  __int16 v36;
  __int16 v37;
  __int16 v38;
  __int16 v39;
  __int16 v40;
  __int16 v41;
  uint64_t v42;
  unsigned int v43;
  char v44;
  __int16 v45;
  uint64_t v46;

  v46 = 0;
  v45 = 0;
  v44 = 0;
  v43 = 0;
  v42 = 0;
  v41 = 0;
  v40 = 0;
  v39 = 0;
  v38 = 0;
  v37 = 0;
  v36 = 0;
  v35 = 0;
  v34 = 0;
  v33 = 0;
  v32 = 0;
  v31 = 0;
  v30 = 0;
  v4 = *(_QWORD *)((char *)a2 + 44);
  v5 = hevcbridgeUEPullLong((uint64_t)a1, (unsigned int *)&v46 + 1);
  v6 = v5;
  if ((v4 & 1) != 0 && !(_DWORD)v5)
    v6 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 163, HIDWORD(v46), 0xFFFFFFFFLL);
  if ((_DWORD)v6)
    goto LABEL_81;
  if (a2[18])
  {
    *(_QWORD *)a2[18] = malloc_type_calloc(1uLL, 0x11A0uLL, 0x1000040A601553DuLL);
    v7 = *(_DWORD **)a2[18];
    if (!v7)
    {
      v6 = 4294954583;
      goto LABEL_81;
    }
    v8 = HIDWORD(v46);
    *v7 = 34;
    v7[1] = v8;
    v9 = v7 + 2;
  }
  else
  {
    v9 = 0;
  }
  v10 = *(_QWORD *)((char *)a2 + 44);
  v11 = hevcbridgeUEPullLong((uint64_t)a1, (unsigned int *)&v46);
  v6 = v11;
  if ((v10 & 2) != 0 && !(_DWORD)v11)
    v6 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 164, v46, 0xFFFFFFFFLL);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 2) & 1, 165, (_BYTE *)&v45 + 1);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 3) & 1, 166, &v45);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 4) & 1, 167, &v42, 3);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUPullFlagIfRequested((uint64_t)a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 5) & 1, 168);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 6) & 1, 169, &v44);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUEPullAlways((uint64_t)a1, (uint64_t)a2, *((unsigned __int8 *)a2 + 44) >> 7, 170, &v43);
  if ((_DWORD)v6)
    goto LABEL_81;
  v12 = v43;
  if (v43 >= 0xF)
    goto LABEL_100;
  v6 = hevcbridgeUEPullAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 8) & 1, 171, (unsigned int *)&v42 + 1);
  if ((_DWORD)v6)
    goto LABEL_81;
  v13 = HIDWORD(v42);
  if (HIDWORD(v42) >= 0xF)
    goto LABEL_100;
  v6 = hevcbridgeSEPullIfRequested((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 9) & 1, 172);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUPullFlagIfRequested((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 10) & 1, 173);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 11) & 1, 174, (_BYTE *)&v41 + 1);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 12) & 1, 175, &v41);
  if ((_DWORD)v6)
    goto LABEL_81;
  if ((_BYTE)v41)
  {
    v6 = hevcbridgeUEPullIfRequested((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 13) & 1, 176);
    if ((_DWORD)v6)
      goto LABEL_81;
  }
  v6 = hevcbridgeSEPullIfRequested((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 14) & 1, 177);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeSEPullIfRequested((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 15) & 1, 178);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, HIWORD(*((_DWORD *)a2 + 11)) & 1, 179, (_BYTE *)&v40 + 1);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 17) & 1, 180, &v40);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 18) & 1, 181, (_BYTE *)&v39 + 1);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUPullFlagIfRequested((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 19) & 1, 182);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 20) & 1, 183, &v39);
  if ((_DWORD)v6)
    goto LABEL_81;
  v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 21) & 1, 184, (_BYTE *)&v38 + 1);
  if ((_DWORD)v6)
    goto LABEL_81;
  v14 = v39;
  if (!(_BYTE)v39)
    goto LABEL_113;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  v6 = hevcbridgeUEPullAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 22) & 1, 185, &v29);
  if (!(_DWORD)v6)
  {
    v6 = hevcbridgeUEPullAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 23) & 1, 186, &v28);
    if (!(_DWORD)v6)
    {
      v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, HIBYTE(*((_DWORD *)a2 + 11)) & 1, 187, &v27);
      if (!(_DWORD)v6)
      {
        if (!v27)
        {
          v23 = v29;
          if (v29)
          {
            do
            {
              v19 = hevcbridgeUESkip((uint64_t)a1);
              if ((_DWORD)v19)
                goto LABEL_93;
            }
            while (--v23);
          }
          v24 = v28;
          if (v28)
          {
            do
            {
              v19 = hevcbridgeUESkip((uint64_t)a1);
              if ((_DWORD)v19)
                goto LABEL_93;
            }
            while (--v24);
          }
        }
        v6 = hevcbridgeUPullFlagIfRequested((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 25) & 1, 188);
        if (!(_DWORD)v6)
        {
LABEL_113:
          v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 26) & 1, 189, &v38);
          if (!(_DWORD)v6)
          {
            v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 27) & 1, 190, (_BYTE *)&v37 + 1);
            if (!(_DWORD)v6)
            {
              if (HIBYTE(v37))
              {
                v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 28) & 1, 191, &v37);
                if ((_DWORD)v6)
                  goto LABEL_81;
                v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 29) & 1, 192, (_BYTE *)&v36 + 1);
                if ((_DWORD)v6)
                  goto LABEL_81;
                v15 = HIBYTE(v36);
                if (HIBYTE(v36))
                  goto LABEL_51;
                v6 = hevcbridgeSEPullIfRequested((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 30) & 1, 193);
                if ((_DWORD)v6)
                  goto LABEL_81;
                v6 = hevcbridgeSEPullIfRequested((uint64_t)a1, (uint64_t)a2, *((_DWORD *)a2 + 11) >> 31, 194);
                if ((_DWORD)v6)
                  goto LABEL_81;
              }
              v15 = 0;
LABEL_51:
              v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, a2[6] & 1, 195, &v36);
              if ((_DWORD)v6)
                goto LABEL_81;
              if ((_BYTE)v36)
              {
                v16 = hevcbridgeParseScalingListData((uint64_t)a1);
                v6 = v16;
                if ((_DWORD)v16 == 1)
                  return v6;
                if ((_DWORD)v16)
                  goto LABEL_81;
              }
              v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 33) & 1, 196, (_BYTE *)&v35 + 1);
              if ((_DWORD)v6)
                goto LABEL_81;
              v6 = hevcbridgeUEPullIfRequested((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 34) & 1, 197);
              if ((_DWORD)v6)
                goto LABEL_81;
              v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 35) & 1, 198, &v35);
              if ((_DWORD)v6)
                goto LABEL_81;
              v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 36) & 1, 199, (_BYTE *)&v34 + 1);
              if ((_DWORD)v6)
                goto LABEL_81;
              if (!HIBYTE(v34))
                goto LABEL_94;
              v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 37) & 1, 200, &v34);
              if ((_DWORD)v6)
                goto LABEL_81;
              v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 38) & 1, 201, (_BYTE *)&v33 + 1);
              if ((_DWORD)v6)
                goto LABEL_81;
              v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 39) & 1, 202, &v33);
              if ((_DWORD)v6)
                goto LABEL_81;
              v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, *(_DWORD *)((_BYTE *)a2 + 49) & 1, 203, &v32);
              if ((_DWORD)v6)
                goto LABEL_81;
              v6 = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 41) & 1, 204, &v31, 4);
              if ((_DWORD)v6)
                goto LABEL_81;
              if ((_BYTE)v34)
              {
                if (HIBYTE(v41))
                {
                  v6 = hevcbridgeUEPullIfRequested((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 42) & 1, 205);
                  if ((_DWORD)v6)
                    goto LABEL_81;
                }
                v6 = hevcbridgeUPullFlagIfRequested((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 43) & 1, 206);
                if ((_DWORD)v6)
                  goto LABEL_81;
                v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 44) & 1, 207, &v30);
                if ((_DWORD)v6)
                  goto LABEL_81;
                v17 = v30;
                if (v30)
                {
                  v29 = 0;
                  v6 = hevcbridgeUEPullIfRequested((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 45) & 1, 208);
                  if (!(_DWORD)v6)
                  {
                    v6 = hevcbridgeUEPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 46) & 1, 209, &v29);
                    if (!(_DWORD)v6)
                    {
                      v18 = 0;
                      v26 = v29;
                      while (1)
                      {
                        v19 = hevcbridgeSESkip((uint64_t)a1);
                        if ((_DWORD)v19)
                          break;
                        v19 = hevcbridgeSESkip((uint64_t)a1);
                        if ((_DWORD)v19)
                          break;
                        if (++v18 > v26)
                          goto LABEL_77;
                      }
LABEL_93:
                      v6 = v19;
                      goto LABEL_81;
                    }
                  }
                  goto LABEL_81;
                }
LABEL_77:
                v6 = hevcbridgeUEPullIfRequested((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 47) & 1, 210);
                if ((_DWORD)v6)
                  goto LABEL_81;
                v6 = hevcbridgeUEPullIfRequested((uint64_t)a1, (uint64_t)a2, *(_DWORD *)((_BYTE *)a2 + 50) & 1, 211);
                if ((_DWORD)v6)
                  goto LABEL_81;
              }
              else
              {
LABEL_94:
                v17 = 0;
              }
              if (v9)
              {
                v25 = v42;
                *v9 = v46;
                v9[1] = v25;
                v9[2] = v12;
                v9[3] = v13;
                *((_BYTE *)v9 + 16) = HIBYTE(v45);
                *((_BYTE *)v9 + 17) = v45;
                *((_BYTE *)v9 + 18) = HIBYTE(v35);
                *((_BYTE *)v9 + 19) = v44;
                *((_BYTE *)v9 + 20) = v40;
                *((_BYTE *)v9 + 21) = HIBYTE(v39);
                *((_BYTE *)v9 + 22) = HIBYTE(v40);
                *((_BYTE *)v9 + 23) = v17;
                *((_BYTE *)v9 + 24) = v37;
                *((_BYTE *)v9 + 25) = v15;
                *((_BYTE *)v9 + 26) = v38;
                *((_BYTE *)v9 + 27) = v14;
                *((_BYTE *)v9 + 28) = HIBYTE(v38);
                *((_BYTE *)v9 + 29) = v35;
              }
              if (HIBYTE(v33))
              {
                v6 = hevcbridgeParsePictureParameterSetMultilayerExtension((uint64_t)a1, (uint64_t)a2);
                if ((_DWORD)v6)
                  goto LABEL_81;
              }
              if (!(_BYTE)v33)
              {
                if (v32)
                {
                  v6 = hevcbridgeParsePictureParameterSetSCCExtension((uint64_t)a1, (uint64_t)a2);
                  if ((_DWORD)v6 || !v31)
                    goto LABEL_81;
                }
                else if (!v31)
                {
                  return 0;
                }
                do
                  v6 = hevcbridgeUPullFlagAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 52) >> 35) & 1, 262, &v29);
                while (!(_DWORD)v6
                     && (unint64_t)(a1[6] + 1) < a1[1] + *a1
                     && hevcbridgeMoreRBSPData((uint64_t)a1));
                goto LABEL_81;
              }
LABEL_100:
              v6 = 4294954582;
              FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            }
          }
        }
      }
    }
  }
LABEL_81:
  if (v6 >= 2)
  {
    v20 = (void **)a2[18];
    if (v20)
    {
      v21 = *v20;
      if (*v20)
      {
        *v20 = 0;
        free(v21);
      }
    }
  }
  return v6;
}

uint64_t hevcbridgeParseSEIRBSP(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  const __CFAllocator *v6;
  __CFData *Mutable;
  uint64_t v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  CFIndex v13;
  char v14;
  uint64_t v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  UInt8 *v19;
  UInt8 *v20;
  uint64_t v21;
  UInt8 *v22;
  __CFData *v23;
  __CFData *v24;
  __CFData *v25;
  UInt8 *MutableBytePtr;
  uint64_t v27;
  const __CFData *v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  const UInt8 *BytePtr;
  CFIndex Length;
  unsigned int v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  char v41;
  uint64_t v42;
  char v43;
  uint64_t v44;
  const __CFData *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  uint64_t v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  int v69;
  int v70;
  int v71;
  const __CFAllocator *v72;
  unsigned int v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  __int16 v82;
  __int16 v83;
  unsigned int v84;
  UInt8 bytes[16];
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  uint64_t v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  v74 = 0;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  do
  {
    v75 = 0;
    v76 = 0;
    if ((*((_BYTE *)a2 + 44) & 1) != 0)
    {
      Mutable = CFDataCreateMutable(v6, 0);
      if (!Mutable)
      {
        v11 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
        goto LABEL_195;
      }
    }
    else
    {
      Mutable = 0;
    }
    LODWORD(v8) = 0;
    do
    {
      v9 = *((_BYTE *)a2 + 44);
      v10 = hevcbridgeUPullLong((uint64_t)a1, 8, &v76);
      v11 = v10;
      if ((v9 & 2) != 0 && !(_DWORD)v10)
        v11 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 343, v76, 0xFFFFFFFFLL);
      if ((_DWORD)v11)
        goto LABEL_193;
      v12 = v76;
      if (Mutable)
      {
        bytes[0] = v76;
        CFDataAppendBytes(Mutable, bytes, 1);
      }
      v8 = v12 + v8;
    }
    while (v12 == 255);
    if ((*((_BYTE *)a2 + 44) & 4) != 0)
    {
      v11 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t, uint64_t))a2[2])(*a2, 344, v8, 0xFFFFFFFFLL);
      if ((_DWORD)v11)
      {
LABEL_193:
        if (!Mutable)
          goto LABEL_195;
        goto LABEL_194;
      }
    }
    LODWORD(v13) = 0;
    do
    {
      v14 = *((_BYTE *)a2 + 44);
      v15 = hevcbridgeUPullLong((uint64_t)a1, 8, &v75);
      v11 = v15;
      if ((v14 & 8) != 0 && !(_DWORD)v15)
        v11 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 345, v75, 0xFFFFFFFFLL);
      if ((_DWORD)v11)
        goto LABEL_193;
      v16 = v75;
      if (Mutable)
      {
        bytes[0] = v75;
        CFDataAppendBytes(Mutable, bytes, 1);
      }
      v13 = v16 + v13;
    }
    while (v16 == 255);
    if (v13 < 0x100000)
    {
      if (!Mutable)
      {
        v20 = 0;
LABEL_29:
        if ((*((_BYTE *)a2 + 44) & 0x10) != 0)
        {
          v11 = ((uint64_t (*)(_QWORD, uint64_t, CFIndex, uint64_t))a2[2])(*a2, 346, v13, 0xFFFFFFFFLL);
          if ((_DWORD)v11)
            goto LABEL_193;
        }
        if ((_DWORD)a3 != 39
          || ((v69 = 1, (v8 - 148) > 0x1C) || ((1 << (v8 + 108)) & 0x10020001) == 0) && (_DWORD)v8 != 4)
        {
          if ((*((_BYTE *)a2 + 44) & 0x20) == 0)
          {
            if (!v20)
            {
              v11 = hevcbridgeUSkip((uint64_t)a1, 8 * (int)v13);
              if ((_DWORD)v11)
                goto LABEL_193;
              v28 = 0;
              v69 = 0;
LABEL_51:
              v29 = *((_BYTE *)a2 + 44);
              if ((v29 & 0x20) != 0)
              {
                v30 = ((uint64_t (*)(_QWORD, uint64_t, const __CFData *))a2[4])(*a2, 347, v28);
                if ((_DWORD)v30)
                {
                  v11 = v30;
                  goto LABEL_191;
                }
                v29 = *((_BYTE *)a2 + 44);
              }
              if ((v29 & 1) != 0)
              {
                v31 = ((uint64_t (*)(_QWORD, uint64_t, __CFData *))a2[4])(*a2, 342, Mutable);
                v11 = v31;
                if ((_DWORD)v31 == 1)
                  goto LABEL_191;
                v32 = v69;
                if ((_DWORD)v31)
                  v32 = 0;
                if ((v32 & 1) == 0)
                  goto LABEL_191;
              }
              else if (!v69)
              {
                goto LABEL_190;
              }
              v91 = 0;
              v89 = 0u;
              v90 = 0u;
              v87 = 0u;
              v88 = 0u;
              *(_OWORD *)bytes = 0u;
              v86 = 0u;
              BytePtr = CFDataGetBytePtr(v28);
              Length = CFDataGetLength(v28);
              v35 = hevcbridgeSetupBitStreamFromPointerAndLength((uint64_t)bytes, (uint64_t)BytePtr, Length, 0);
              if (v35)
                v11 = v35;
              else
                v11 = 4294954584;
              if (v35 || (_DWORD)a3 != 39)
                goto LABEL_191;
              v11 = 4294954584;
              if ((int)v8 > 164)
              {
                if ((_DWORD)v8 == 176)
                {
                  v36 = hevcbridgeParseSEI3DReferenceDisplaysInformation((uint64_t)bytes, a2);
                }
                else
                {
                  if ((_DWORD)v8 != 165)
                    goto LABEL_191;
                  v36 = hevcbridgeParseSEIAlphaChannelInfo((uint64_t)bytes, (uint64_t)a2);
                }
                goto LABEL_85;
              }
              if ((_DWORD)v8 != 4)
              {
                if ((_DWORD)v8 != 148)
                  goto LABEL_191;
                v36 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, a2[9] & 1, 356, 32);
                if (!(_DWORD)v36)
                {
                  v36 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((unsigned __int8 *)a2 + 72) >> 1) & 1, 357, 16);
                  if (!(_DWORD)v36)
                    v36 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((unsigned __int8 *)a2 + 72) >> 2) & 1, 358, 16);
                }
LABEL_85:
                v11 = v36;
                v39 = 1;
LABEL_86:
                if ((_DWORD)v11 == 1)
                  goto LABEL_191;
                if ((_DWORD)v11)
                  goto LABEL_189;
                if (BYTE9(v87))
                {
LABEL_190:
                  v11 = 0;
                  goto LABEL_191;
                }
                v84 = 0;
                v11 = hevcbridgeUPullLong((uint64_t)bytes, 8 - HIDWORD(v89), &v84);
                if ((_DWORD)v11)
                {
LABEL_189:
                  if ((_DWORD)v11)
                    goto LABEL_191;
                  goto LABEL_190;
                }
                if (BYTE9(v87))
                  v40 = v84;
                else
                  v40 = *(unsigned __int8 *)(*(_QWORD *)bytes + *(_QWORD *)&bytes[8] - 1);
                if (v40)
                  v65 = 0;
                else
                  v65 = v39;
                if (v65 != 1)
                {
                  v11 = 0;
                  goto LABEL_189;
                }
                v11 = 4294954582;
                FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_191:
                if (!v28)
                  goto LABEL_193;
                goto LABEL_192;
              }
              v78 = 0;
              v77 = 0;
              v37 = *((_BYTE *)a2 + 80);
              v38 = hevcbridgeUPullLong((uint64_t)bytes, 8, (_DWORD *)&v78 + 1);
              v11 = v38;
              if ((v37 & 1) != 0 && !(_DWORD)v38)
                v11 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 372, HIDWORD(v78), 0xFFFFFFFFLL);
              if ((_DWORD)v11)
              {
LABEL_83:
                v39 = 0;
                goto LABEL_86;
              }
              if (HIDWORD(v78) != 181)
              {
                if (HIDWORD(v78) == 255)
                {
                  v11 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((unsigned __int8 *)a2 + 80) >> 1) & 1, 373, 8);
                  goto LABEL_83;
                }
LABEL_182:
                v11 = 0;
                goto LABEL_83;
              }
              v41 = *((_BYTE *)a2 + 80);
              v42 = hevcbridgeUPullLong((uint64_t)bytes, 16, &v78);
              v11 = v42;
              if ((v41 & 4) != 0 && !(_DWORD)v42)
                v11 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 374, v78, 0xFFFFFFFFLL);
              if ((_DWORD)v11)
                goto LABEL_83;
              if ((_DWORD)v78 != 60)
                goto LABEL_182;
              v43 = *((_BYTE *)a2 + 80);
              v44 = hevcbridgeUPullLong((uint64_t)bytes, 16, &v77);
              v11 = v44;
              if ((v43 & 8) != 0 && !(_DWORD)v44)
                v11 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 375, v77, 0xFFFFFFFFLL);
              if ((_DWORD)v11)
                goto LABEL_83;
              v45 = v28;
              if (v77 == 1)
              {
                v84 = 0;
                v83 = 0;
                v82 = 0;
                v80 = 0;
                v81 = 0;
                v46 = *(_QWORD *)((char *)a2 + 84);
                v47 = hevcbridgeUPullLong((uint64_t)bytes, 8, (_DWORD *)&v80 + 1);
                v11 = v47;
                if ((v46 & 1) != 0 && !(_DWORD)v47)
                  v11 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 376, HIDWORD(v80), 0xFFFFFFFFLL);
                if ((_DWORD)v11)
                  goto LABEL_209;
                if (HIDWORD(v80) != 4)
                  goto LABEL_212;
                v48 = *(_QWORD *)((char *)a2 + 84);
                v49 = hevcbridgeUPullLong((uint64_t)bytes, 8, &v80);
                v11 = v49;
                if ((v48 & 2) != 0 && !(_DWORD)v49)
                  v11 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 377, v80, 0xFFFFFFFFLL);
                if ((_DWORD)v11)
                  goto LABEL_209;
                if ((_DWORD)v80 != 1)
                {
LABEL_212:
                  v11 = 1;
                  goto LABEL_209;
                }
                v50 = *(_QWORD *)((char *)a2 + 84);
                v51 = hevcbridgeUPullLong((uint64_t)bytes, 2, &v84);
                v11 = v51;
                if ((v50 & 4) != 0 && !(_DWORD)v51)
                  v11 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 378, v84, 0xFFFFFFFFLL);
                if ((_DWORD)v11)
                  goto LABEL_209;
                v73 = v84;
                if (v84 >= 2)
                {
                  v52 = v84 - 1;
                  do
                  {
                    v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((unsigned __int8 *)a2 + 84) >> 3) & 1, 379, 16);
                    if ((_DWORD)v53)
                      goto LABEL_208;
                    v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((unsigned __int8 *)a2 + 84) >> 4) & 1, 380, 16);
                    if ((_DWORD)v53)
                      goto LABEL_208;
                    v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((unsigned __int8 *)a2 + 84) >> 5) & 1, 381, 16);
                    if ((_DWORD)v53)
                      goto LABEL_208;
                    v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((unsigned __int8 *)a2 + 84) >> 6) & 1, 382, 16);
                    if ((_DWORD)v53)
                      goto LABEL_208;
                    v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, *((unsigned __int8 *)a2 + 84) >> 7, 383, 16);
                    if ((_DWORD)v53)
                      goto LABEL_208;
                    v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 8) & 1, 384, 16);
                    if ((_DWORD)v53)
                      goto LABEL_208;
                    v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 9) & 1, 385, 8);
                    if ((_DWORD)v53)
                      goto LABEL_208;
                    v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 10) & 1, 386, 16);
                    if ((_DWORD)v53)
                      goto LABEL_208;
                    v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 11) & 1, 387, 16);
                    if ((_DWORD)v53)
                      goto LABEL_208;
                    v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 12) & 1, 388, 16);
                    if ((_DWORD)v53)
                      goto LABEL_208;
                    v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 13) & 1, 389, 1);
                    if ((_DWORD)v53)
                      goto LABEL_208;
                  }
                  while (--v52);
                }
                v11 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 14) & 1, 390, 27);
                if ((_DWORD)v11)
                  goto LABEL_209;
                v11 = hevcbridgeUPullFlagAlways((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 15) & 1, 391, (_BYTE *)&v83 + 1);
                if ((_DWORD)v11)
                  goto LABEL_209;
                if (HIBYTE(v83))
                {
                  v11 = hevcbridgeUPullAlways((uint64_t)bytes, (uint64_t)a2, HIWORD(*((_DWORD *)a2 + 21)) & 1, 392, (_DWORD *)&v81 + 1, 5);
                  if ((_DWORD)v11)
                    goto LABEL_209;
                  v11 = hevcbridgeUPullAlways((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 17) & 1, 393, &v81, 5);
                  if ((_DWORD)v11)
                    goto LABEL_209;
                  v70 = HIDWORD(v81);
                  if (HIDWORD(v81))
                  {
                    v54 = 0;
                    v55 = v81;
                    while (1)
                    {
                      v56 = v55;
                      if (v55)
                        break;
LABEL_143:
                      if (++v54 == v70)
                        goto LABEL_144;
                    }
                    while (1)
                    {
                      v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 18) & 1, 394, 4);
                      if ((_DWORD)v53)
                        goto LABEL_208;
                      if (!--v56)
                        goto LABEL_143;
                    }
                  }
                }
LABEL_144:
                if (v73)
                {
                  v57 = 0;
LABEL_146:
                  HIDWORD(v79) = 0;
                  v58 = 3;
                  while (1)
                  {
                    v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 19) & 1, 395, 17);
                    if ((_DWORD)v53)
                      goto LABEL_208;
                    if (!--v58)
                    {
                      v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 20) & 1, 396, 17);
                      if ((_DWORD)v53)
                        goto LABEL_208;
                      v53 = hevcbridgeUPullAlways((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 21) & 1, 397, (_DWORD *)&v79 + 1, 4);
                      if ((_DWORD)v53)
                        goto LABEL_208;
                      v59 = HIDWORD(v79);
                      if (HIDWORD(v79))
                      {
                        do
                        {
                          v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 22) & 1, 398, 7);
                          if ((_DWORD)v53)
                            goto LABEL_208;
                          v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 23) & 1, 399, 17);
                          if ((_DWORD)v53)
                            goto LABEL_208;
                        }
                        while (--v59);
                      }
                      v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, HIBYTE(*((_DWORD *)a2 + 21)) & 1, 400, 10);
                      if ((_DWORD)v53)
                        goto LABEL_208;
                      if (++v57 != v73)
                        goto LABEL_146;
                      break;
                    }
                  }
                }
                v11 = hevcbridgeUPullFlagAlways((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 25) & 1, 401, &v83);
                if ((_DWORD)v11)
                {
LABEL_209:
                  v28 = v45;
                  goto LABEL_83;
                }
                if ((_BYTE)v83)
                {
                  v79 = 0;
                  v11 = hevcbridgeUPullAlways((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 26) & 1, 402, (_DWORD *)&v79 + 1, 5);
                  if ((_DWORD)v11)
                    goto LABEL_209;
                  v11 = hevcbridgeUPullAlways((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 27) & 1, 403, &v79, 5);
                  if ((_DWORD)v11)
                    goto LABEL_209;
                  v71 = HIDWORD(v79);
                  if (HIDWORD(v79))
                  {
                    v60 = 0;
                    v61 = v79;
                    while (1)
                    {
                      v62 = v61;
                      if (v61)
                        break;
LABEL_166:
                      if (++v60 == v71)
                        goto LABEL_167;
                    }
                    while (1)
                    {
                      v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 28) & 1, 404, 4);
                      if ((_DWORD)v53)
                        goto LABEL_208;
                      if (!--v62)
                        goto LABEL_166;
                    }
                  }
                }
LABEL_167:
                if (v73)
                {
                  v63 = 0;
                  while (1)
                  {
                    v53 = hevcbridgeUPullFlagAlways((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 29) & 1, 405, (_BYTE *)&v82 + 1);
                    if ((_DWORD)v53)
                      break;
                    if (HIBYTE(v82))
                    {
                      HIDWORD(v79) = 0;
                      v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*((_DWORD *)a2 + 21) >> 30) & 1, 406, 12);
                      if ((_DWORD)v53)
                        break;
                      v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, *((_DWORD *)a2 + 21) >> 31, 407, 12);
                      if ((_DWORD)v53)
                        break;
                      v53 = hevcbridgeUPullAlways((uint64_t)bytes, (uint64_t)a2, a2[11] & 1, 408, (_DWORD *)&v79 + 1, 4);
                      if ((_DWORD)v53)
                        break;
                      v64 = HIDWORD(v79);
                      if (HIDWORD(v79))
                      {
                        do
                        {
                          v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 84) >> 33) & 1, 409, 10);
                          if ((_DWORD)v53)
                            goto LABEL_208;
                        }
                        while (--v64);
                      }
                    }
                    v53 = hevcbridgeUPullFlagAlways((uint64_t)bytes, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 84) >> 34) & 1, 410, &v82);
                    if ((_DWORD)v53)
                      break;
                    if ((_BYTE)v82)
                    {
                      v53 = hevcbridgeUPullIfRequested((uint64_t)bytes, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 84) >> 35) & 1, 411, 6);
                      if ((_DWORD)v53)
                        break;
                    }
                    v11 = 0;
                    if (++v63 == v73)
                      goto LABEL_209;
                  }
LABEL_208:
                  v11 = v53;
                  goto LABEL_209;
                }
              }
              v11 = 0;
              goto LABEL_209;
            }
            v72 = v6;
            v21 = a3;
            v22 = 0;
            v23 = 0;
            v69 = 0;
            if ((_DWORD)v13)
              goto LABEL_44;
LABEL_50:
            a3 = v21;
            v6 = v72;
            v28 = v23;
            goto LABEL_51;
          }
          v69 = 0;
        }
        v24 = CFDataCreateMutable(v6, v13);
        if (v24)
        {
          v25 = v24;
          v72 = v6;
          v21 = a3;
          CFDataSetLength(v24, v13);
          v23 = v25;
          MutableBytePtr = CFDataGetMutableBytePtr(v25);
          if (!MutableBytePtr)
          {
            v11 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
            v6 = v72;
            v28 = v23;
LABEL_192:
            CFRelease(v28);
            goto LABEL_193;
          }
          v22 = MutableBytePtr;
          if ((_DWORD)v13)
          {
LABEL_44:
            while (1)
            {
              *(_DWORD *)bytes = 0;
              v27 = hevcbridgeUPullLong((uint64_t)a1, 8, bytes);
              if ((_DWORD)v27)
                break;
              if (v22)
                *v22++ = bytes[0];
              if (v20)
                *v20++ = bytes[0];
              if (!--v13)
                goto LABEL_50;
            }
            v11 = v27;
            a3 = v21;
            v6 = v72;
            v28 = v23;
            goto LABEL_191;
          }
          goto LABEL_50;
        }
        v67 = 4294954583;
        goto LABEL_205;
      }
      v17 = CFDataGetLength(Mutable);
      if (v17 >> 20)
      {
        v66 = 4294954584;
      }
      else
      {
        v18 = v17;
        CFDataSetLength(Mutable, v17 + v13);
        v19 = CFDataGetMutableBytePtr(Mutable);
        if (v19)
        {
          v20 = &v19[v18];
          goto LABEL_29;
        }
        v66 = 4294954583;
      }
      v11 = FigSignalErrorAt(v66, 0, 0, 0, 0, 0, 0);
LABEL_194:
      CFRelease(Mutable);
      goto LABEL_195;
    }
    v67 = 4294954584;
LABEL_205:
    v11 = FigSignalErrorAt(v67, 0, 0, 0, 0, 0, 0);
    if (Mutable)
      goto LABEL_194;
LABEL_195:
    if ((_DWORD)v11)
      return v11;
  }
  while ((unint64_t)(a1[6] + 1) < a1[1] + *a1 && hevcbridgeMoreRBSPData((uint64_t)a1));
  v11 = hevcbridgeUPullLong((uint64_t)a1, 8, &v74);
  if (!(_DWORD)v11)
  {
    if (v74 == 128)
    {
      return 0;
    }
    else
    {
      v11 = 4294954582;
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    }
  }
  return v11;
}

uint64_t hevcbridgeParseSliceSegmentLayer(uint64_t a1, _QWORD *a2, int a3, unsigned int a4, int a5)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _DWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  _DWORD *v18;
  _DWORD *v19;
  _QWORD *v20;
  _DWORD *v21;
  unsigned int *v22;
  unsigned __int8 *v23;
  unsigned int v24;
  unsigned int *v25;
  _DWORD *v26;
  _DWORD *v27;
  unsigned __int8 *v28;
  int *v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  double v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  double v41;
  unsigned int *v42;
  int v43;
  unsigned int *v44;
  int v45;
  int v46;
  unsigned __int8 *v47;
  _QWORD *v48;
  uint64_t v49;
  _DWORD *v50;
  unsigned int *v51;
  int v52;
  unint64_t i;
  unsigned int v54;
  double v55;
  uint64_t v56;
  char *v57;
  int v58;
  char *v59;
  uint64_t v60;
  unsigned int v61;
  unsigned __int8 *v62;
  BOOL v63;
  int v64;
  uint64_t v65;
  unsigned __int8 *v66;
  uint64_t v68;
  unsigned __int8 *v69;
  uint64_t v71;
  unsigned __int8 *v72;
  unsigned int v74;
  BOOL v75;
  int v76;
  unsigned int v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  char v81;
  char v82;
  int v83;
  double v84;
  int v85;
  int v86;
  int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  char v91;
  char v92;
  unsigned int v93;
  unsigned int v94;
  uint64_t v95;
  unsigned int v96;
  unsigned int *v97;
  int v98;
  int v99;
  int v100;
  int v101;
  uint64_t v102;
  int v103;
  char v104;
  int v105;
  unint64_t v106;
  int v107;
  unsigned int v108;
  unsigned int v109;
  char v110;
  int v111;
  __int16 v112;
  __int16 v113;
  __int16 v114;
  uint64_t v115;
  uint64_t v116;
  unsigned int v117;
  char v118;
  unsigned int v119;
  char v120;
  unsigned __int8 v121[16];
  _QWORD v122[2];
  _QWORD v123[2];
  _QWORD v124[2];
  _QWORD v125[2];
  unsigned int v126[42];
  uint64_t v127;

  v127 = *MEMORY[0x1E0C80C00];
  v120 = 0;
  v119 = 0;
  v118 = 0;
  v117 = 0;
  v116 = 0;
  result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, *((_DWORD *)a2 + 11) & 1, 263, &v120);
  if ((_DWORD)result)
    return result;
  if ((a3 & 0xFFFFFFF8) == 0x10)
  {
    result = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 1) & 1, 264);
    if ((_DWORD)result)
      return result;
  }
  v11 = *(_QWORD *)((char *)a2 + 44);
  result = hevcbridgeUEPullLong(a1, &v119);
  if ((v11 & 4) != 0 && !(_DWORD)result)
    result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 265, v119, 0xFFFFFFFFLL);
  if ((_DWORD)result)
    return result;
  v12 = a2[16];
  if (!v12)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v13 = (_QWORD *)a2[17];
  v14 = a2[16];
  while (1)
  {
    v15 = (_DWORD *)*v13;
    if (*(_DWORD *)*v13 == 34 && v15[1] == v119)
      break;
    ++v13;
    if (!--v14)
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  v16 = (_QWORD *)a2[17];
  v17 = a2[16];
  while (1)
  {
    v18 = (_DWORD *)*v16;
    if (*(_DWORD *)*v16 == 33 && v18[1] == v15[2])
      break;
    ++v16;
    if (!--v17)
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  v19 = v18 + 2;
  v20 = (_QWORD *)a2[17];
  while (1)
  {
    v21 = (_DWORD *)*v20;
    if (*(_DWORD *)*v20 == 32 && v21[1] == *v19)
      break;
    ++v20;
    if (!--v12)
    {
      v22 = 0;
      goto LABEL_26;
    }
  }
  v22 = v21 + 2;
LABEL_26:
  if (*((_BYTE *)v18 + 53))
  {
    if (!v22)
      return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  }
  else if (!a4 || !v22)
  {
    v102 = 0;
    v101 = 0;
    v99 = 0;
    v26 = v18 + 6;
    v27 = v18 + 7;
    v28 = (unsigned __int8 *)v18 + 54;
    v29 = v18 + 11;
    goto LABEL_36;
  }
  v23 = (unsigned __int8 *)v22 + a4;
  if (*((_BYTE *)v18 + 52))
    v24 = v18[12];
  else
    v24 = v23[4];
  if (v24 > *v22)
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v25 = &v22[4 * v24];
  v26 = v25 + 1122;
  v27 = v25 + 1123;
  v28 = (unsigned __int8 *)(v25 + 1125);
  v29 = (int *)(v25 + 1124);
  v101 = *((unsigned __int8 *)v22 + 196);
  v99 = *((unsigned __int8 *)v22 + 197);
  LODWORD(v102) = v23[68];
  HIDWORD(v102) = v23[132];
LABEL_36:
  v100 = *v29;
  v105 = *v28;
  if (v120)
    goto LABEL_37;
  v32 = ~(-1 << (*((_BYTE *)v18 + 16) + *((_BYTE *)v18 + 20) + 3));
  v33 = log2((double)(((*v26 + v32) >> (*((_BYTE *)v18 + 16) + *((_BYTE *)v18 + 20) + 3))
                    * ((*v27 + v32) >> (*((_BYTE *)v18 + 16) + *((_BYTE *)v18 + 20) + 3))));
  if (*((_BYTE *)v15 + 24))
  {
    result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 3) & 1, 266, &v118);
    if ((_DWORD)result)
      return result;
  }
  result = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 4) & 1, 267, vcvtpd_s64_f64(v33));
  if ((_DWORD)result)
    return result;
  if (!v118)
  {
LABEL_37:
    memset(v126, 0, 164);
    v115 = 0;
    v125[1] = 0;
    v125[0] = 0;
    v114 = 0;
    v113 = 0;
    v112 = 0;
    v111 = 0;
    if (v15[3])
    {
      result = hevcbridgeUSkip(a1, 1);
      if ((_DWORD)result)
        return result;
      v30 = v15[3];
      if (v30 >= 2)
      {
        result = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 5) & 1, 268);
        if (!(_DWORD)result)
        {
          v30 = v15[3];
          v31 = 2;
          goto LABEL_72;
        }
        return result;
      }
      v31 = 1;
LABEL_72:
      while (v31 < v30)
      {
        result = hevcbridgeUSkip(a1, 1);
        if ((_DWORD)result)
          return result;
        ++v31;
        v30 = v15[3];
      }
    }
    result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 44) >> 6) & 1, 269, &v117);
    if ((_DWORD)result)
      return result;
    if (*((_BYTE *)v15 + 25))
    {
      result = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, *((unsigned __int8 *)a2 + 44) >> 7, 270);
      if ((_DWORD)result)
        return result;
    }
    if (v105 == 1)
    {
      result = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 8) & 1, 271, 2);
      if ((_DWORD)result)
        return result;
    }
    if (!a4 || HIDWORD(v102))
    {
      if ((a3 - 21) > 0xFFFFFFFD)
        goto LABEL_91;
    }
    else if ((a3 - 21) >= 0xFFFFFFFE && *((_BYTE *)v18 + 89))
    {
      goto LABEL_91;
    }
    result = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 9) & 1, 272, v18[8] + 4);
    if ((_DWORD)result)
      return result;
    if ((a3 - 21) <= 0xFFFFFFFD)
    {
      v121[0] = 0;
      LODWORD(v124[0]) = 0;
      v38 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 10) & 1, 273, v121);
      if ((_DWORD)v38)
        return v38;
      v39 = v121[0];
      v40 = v18[23];
      if (v121[0])
      {
        if (v40 >= 2)
        {
          v41 = log2((double)v40);
          result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 11) & 1, 274, v124, vcvtpd_s64_f64(v41));
          if ((_DWORD)result)
            return result;
        }
        if (v39 == 1)
        {
          if (LODWORD(v124[0]) >= v18[23])
            goto LABEL_282;
          v51 = &v19[41 * LODWORD(v124[0]) + 22];
        }
        else
        {
          v51 = v126;
        }
        v97 = v51;
      }
      else
      {
        v97 = v126;
        v38 = hevcbridgeParseSTRefPicSet(a1, v40, v40, (uint64_t)(v18 + 24), (uint64_t)v126);
        if ((_DWORD)v38)
          return v38;
      }
      if (*((_BYTE *)v18 + 55))
      {
        if (v18[9])
        {
          v38 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 12) & 1, 275, (unsigned int *)&v115 + 1);
          if ((_DWORD)v38)
            return v38;
        }
        v38 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 13) & 1, 276, (unsigned int *)&v115);
        if ((_DWORD)v38)
          return v38;
        v106 = HIDWORD(v115);
        if (HIDWORD(v115) >= 0x11)
          goto LABEL_282;
        v98 = v115;
        if (v115 >= 0x11)
          goto LABEL_282;
        v95 = (v115 + HIDWORD(v115));
        if (v95 > 0x10)
          goto LABEL_282;
        if ((_DWORD)v95)
        {
          for (i = 0; i != v95; ++i)
          {
            LODWORD(v123[0]) = 0;
            if (i >= v106)
            {
              v56 = hevcbridgeUSkip(a1, v18[8] + 4);
              if ((_DWORD)v56)
                return v56;
              LODWORD(v122[0]) = 0;
              v56 = hevcbridgeUPull(a1, 1, v122);
              if ((_DWORD)v56)
                return v56;
              v104 = v122[0];
            }
            else
            {
              v54 = v18[9];
              if (v54 >= 2)
              {
                v55 = log2((double)v54);
                v56 = hevcbridgeUPullLong(a1, vcvtpd_s64_f64(v55), v123);
                if ((_DWORD)v56)
                  return v56;
              }
              v104 = 0;
            }
            LODWORD(v122[0]) = 0;
            v56 = hevcbridgeUPull(a1, 1, v122);
            if ((_DWORD)v56)
              return v56;
            if (LOBYTE(v122[0]))
            {
              v56 = hevcbridgeUESkip(a1);
              if ((_DWORD)v56)
                return v56;
            }
            if (i < v106)
              v104 = *((_BYTE *)v19 + LODWORD(v123[0]) + 48);
            *((_BYTE *)v125 + i) = v104;
          }
        }
      }
      else
      {
        v98 = 0;
        LODWORD(v106) = 0;
      }
      if (v18[10])
      {
        v38 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 14) & 1, 277, (_BYTE *)&v114 + 1);
        if ((_DWORD)v38)
          return v38;
      }
      v103 = 1;
      v42 = v97;
      goto LABEL_92;
    }
LABEL_91:
    v98 = 0;
    LODWORD(v106) = 0;
    v103 = 0;
    v42 = 0;
LABEL_92:
    v43 = 0;
    if (!a4 || v101 || !(_DWORD)v102)
      goto LABEL_103;
    result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 15) & 1, 278, &v112);
    if ((_DWORD)result)
      return result;
    v44 = v42;
    v43 = v112;
    if (!(_BYTE)v112)
      goto LABEL_102;
    if (v102 < 2)
    {
LABEL_103:
      v46 = v43;
      if (*((_BYTE *)v18 + 88))
      {
        result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 18) & 1, 281, (_BYTE *)&v113 + 1);
        if ((_DWORD)result)
          return result;
        if (v100)
        {
          result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 19) & 1, 282, &v113);
          if ((_DWORD)result)
            return result;
        }
      }
      v96 = v117;
      if (v117 > 1)
        goto LABEL_245;
      v47 = (unsigned __int8 *)v42;
      v110 = 0;
      v93 = v15[5];
      v94 = v15[4];
      v108 = v93;
      v109 = v94;
      v38 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 20) & 1, 283, &v110);
      if ((_DWORD)v38)
        return v38;
      if (v110)
      {
        v38 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 21) & 1, 284, &v109);
        if ((_DWORD)v38)
          return v38;
        v94 = v109;
        if (v109 >= 0xF)
          goto LABEL_282;
        if (!v96)
        {
          v38 = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 22) & 1, 285, &v108);
          if ((_DWORD)v38)
            return v38;
          v93 = v108;
          if (v108 >= 0xF)
          {
LABEL_282:
            v38 = 4294954582;
            FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
            return v38;
          }
        }
      }
      v48 = (_QWORD *)a2[17];
      if (!v48 || v22)
      {
        if (v22)
        {
LABEL_167:
          v57 = (char *)v22 + a4;
          v58 = v57[68];
          if (!v57[68])
            goto LABEL_184;
          v52 = 0;
          v59 = (char *)v22 + a4;
          v60 = v59[198];
          v61 = a5 - 1;
          v62 = (unsigned __int8 *)(v59 + 326);
          do
          {
            if (v61 <= *((unsigned __int8 *)v22 + v60 + 262)
              && (a5 == 1 || v61 < *((unsigned __int8 *)&v22[16 * v60 + 97] + *v62 + 2)))
            {
              ++v52;
            }
            --v58;
          }
          while (v58);
LABEL_174:
          if (a4)
            v63 = v52 == 0;
          else
            v63 = 1;
          if (v63)
          {
            v52 = 0;
            goto LABEL_185;
          }
          if (v101)
          {
LABEL_185:
            v64 = v103;
            if (v103)
            {
              if (!v47)
                goto LABEL_282;
              v65 = v47[160];
              if (v47[160])
              {
                v64 = 0;
                v66 = v47 + 128;
                do
                {
                  if (*v66++)
                    ++v64;
                  --v65;
                }
                while (v65);
              }
              else
              {
                v64 = 0;
              }
              v68 = v47[161];
              if (v47[161])
              {
                v69 = v47 + 144;
                do
                {
                  if (*v69++)
                    ++v64;
                  --v68;
                }
                while (v68);
              }
              v71 = (v98 + v106);
              if (v98 + (_DWORD)v106)
              {
                v72 = (unsigned __int8 *)v125;
                do
                {
                  if (*v72++)
                    ++v64;
                  --v71;
                }
                while (v71);
              }
            }
            if (*((_BYTE *)v15 + 38))
              ++v64;
            v74 = v64 + v52;
            if (*((_BYTE *)v15 + 26))
              v75 = v74 >= 2;
            else
              v75 = 0;
            if (!v75)
            {
LABEL_210:
              if (!v96)
              {
                v38 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 25) & 1, 288);
                if ((_DWORD)v38)
                  return v38;
              }
              if (*((_BYTE *)v15 + 27))
              {
                v38 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 26) & 1, 289);
                if ((_DWORD)v38)
                  return v38;
              }
              if (!HIBYTE(v114))
                goto LABEL_304;
              v76 = 1;
              LOBYTE(v124[0]) = 1;
              if (!v96)
              {
                v38 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 27) & 1, 290, v124);
                if ((_DWORD)v38)
                  return v38;
                v76 = LOBYTE(v124[0]);
                if (!LOBYTE(v124[0]))
                  goto LABEL_217;
              }
              if (!v94)
              {
LABEL_217:
                if (v76 || !v93)
                  goto LABEL_304;
              }
              v38 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 28) & 1, 291);
              if (!(_DWORD)v38)
              {
LABEL_304:
                if (v96 == 1 && *((_BYTE *)v15 + 28) || !v96 && *((_BYTE *)v15 + 29))
                {
                  memset(v124, 0, 15);
                  memset(v123, 0, 15);
                  v38 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 29) & 1, 292);
                  if ((_DWORD)v38)
                    return v38;
                  if (v100)
                  {
                    v38 = hevcbridgeSEPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 30) & 1, 293);
                    if ((_DWORD)v38)
                      return v38;
                  }
                  v77 = 0;
                  while (1)
                  {
                    LODWORD(v122[0]) = 0;
                    v56 = hevcbridgeUPull(a1, 1, v122);
                    *((_BYTE *)v124 + v77) = v122[0];
                    if ((_DWORD)v56)
                      return v56;
                    if (++v77 > v94)
                    {
                      if (v100)
                      {
                        v78 = 0;
                        while (1)
                        {
                          LODWORD(v122[0]) = 0;
                          v56 = hevcbridgeUPull(a1, 1, v122);
                          *((_BYTE *)v123 + v78) = v122[0];
                          if ((_DWORD)v56)
                            break;
                          if (++v78 > v94)
                            goto LABEL_233;
                        }
                      }
                      else
                      {
LABEL_233:
                        v79 = 0;
                        while (1)
                        {
                          if (*((_BYTE *)v124 + v79))
                          {
                            v56 = hevcbridgeSESkip(a1);
                            if ((_DWORD)v56)
                              break;
                            v56 = hevcbridgeSESkip(a1);
                            if ((_DWORD)v56)
                              break;
                          }
                          v80 = v79;
                          if (*((_BYTE *)v123 + v79))
                          {
                            v81 = 1;
                            do
                            {
                              v82 = v81;
                              v56 = hevcbridgeSESkip(a1);
                              if ((_DWORD)v56)
                                return v56;
                              v56 = hevcbridgeSESkip(a1);
                              if ((_DWORD)v56)
                                return v56;
                              v81 = 0;
                            }
                            while ((v82 & 1) != 0);
                          }
                          v79 = v80 + 1;
                          if (v80 + 1 > v94)
                          {
                            if (v96)
                              goto LABEL_244;
                            v88 = 0;
                            memset(v122, 0, 15);
                            memset(v121, 0, 15);
                            while (1)
                            {
                              v107 = 0;
                              v56 = hevcbridgeUPull(a1, 1, &v107);
                              *((_BYTE *)v122 + v88) = v107;
                              if ((_DWORD)v56)
                                return v56;
                              if (++v88 > v93)
                              {
                                if (v100)
                                {
                                  v89 = 0;
                                  while (1)
                                  {
                                    v107 = 0;
                                    v56 = hevcbridgeUPull(a1, 1, &v107);
                                    v121[v89] = v107;
                                    if ((_DWORD)v56)
                                      break;
                                    if (++v89 > v93)
                                      goto LABEL_290;
                                  }
                                }
                                else
                                {
LABEL_290:
                                  v90 = 0;
                                  while (1)
                                  {
                                    if (*((_BYTE *)v122 + v90))
                                    {
                                      v56 = hevcbridgeSESkip(a1);
                                      if ((_DWORD)v56)
                                        break;
                                      v56 = hevcbridgeSESkip(a1);
                                      if ((_DWORD)v56)
                                        break;
                                    }
                                    if (v121[v90])
                                    {
                                      v91 = 1;
                                      do
                                      {
                                        v92 = v91;
                                        v56 = hevcbridgeSESkip(a1);
                                        if ((_DWORD)v56)
                                          return v56;
                                        v56 = hevcbridgeSESkip(a1);
                                        if ((_DWORD)v56)
                                          return v56;
                                        v91 = 0;
                                      }
                                      while ((v92 & 1) != 0);
                                    }
                                    if (++v90 > v93)
                                      goto LABEL_244;
                                  }
                                }
                                return v56;
                              }
                            }
                          }
                        }
                      }
                      return v56;
                    }
                  }
                }
LABEL_244:
                v38 = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, *((_DWORD *)a2 + 11) >> 31, 294);
                if ((_DWORD)v38)
                  return v38;
LABEL_245:
                result = hevcbridgeSEPullIfRequested(a1, (uint64_t)a2, a2[6] & 1, 295);
                if ((_DWORD)result)
                  return result;
                if (*((_BYTE *)v15 + 30))
                {
                  result = hevcbridgeSEPullIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 33) & 1, 296);
                  if ((_DWORD)result)
                    return result;
                  result = hevcbridgeSEPullIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 34) & 1, 297);
                  if ((_DWORD)result)
                    return result;
                }
                if (*((_BYTE *)v15 + 31))
                {
                  result = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 35) & 1, 298);
                  if ((_DWORD)result)
                    return result;
                }
                if (!*((_BYTE *)v15 + 32))
                  goto LABEL_271;
                result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 36) & 1, 299, &v114);
                if ((_DWORD)result)
                  return result;
                if ((_BYTE)v114)
                {
                  result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 37) & 1, 300, (_BYTE *)&v112 + 1);
                  if ((_DWORD)result)
                    return result;
                  v83 = HIBYTE(v112);
                  if (!HIBYTE(v112))
                  {
                    result = hevcbridgeSEPullIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 38) & 1, 301);
                    if ((_DWORD)result)
                      return result;
                    result = hevcbridgeSEPullIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 39) & 1, 302);
                    if ((_DWORD)result)
                      return result;
                    v83 = 0;
                  }
                }
                else
                {
LABEL_271:
                  v83 = *((unsigned __int8 *)v15 + 33);
                }
                if (*((_BYTE *)v15 + 34) && (v113 || !v83))
                {
                  result = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 40) & 1, 303);
                  if ((_DWORD)result)
                    return result;
                }
                goto LABEL_46;
              }
              return v38;
            }
            LOBYTE(v124[0]) = 0;
            v84 = log2((double)v74);
            v38 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 11) >> 23) & 1, 286, v124);
            if ((_DWORD)v38)
              return v38;
            v85 = vcvtpd_s64_f64(v84);
            if (LOBYTE(v124[0]))
            {
              v86 = 0;
              while (1)
              {
                v56 = hevcbridgeUSkip(a1, v85);
                if ((_DWORD)v56)
                  break;
                if (++v86 > v94)
                  goto LABEL_264;
              }
            }
            else
            {
LABEL_264:
              if (v96)
                goto LABEL_210;
              LOBYTE(v123[0]) = 0;
              v38 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, HIBYTE(*((_DWORD *)a2 + 11)) & 1, 287, v123);
              if ((_DWORD)v38)
                return v38;
              if (!LOBYTE(v123[0]))
                goto LABEL_210;
              v87 = 0;
              while (1)
              {
                v56 = hevcbridgeUSkip(a1, v85);
                if ((_DWORD)v56)
                  break;
                if (++v87 > v93)
                  goto LABEL_210;
              }
            }
            return v56;
          }
          if (v46)
          {
            v52 = 1;
            if (!v99 && (_DWORD)v102 != 1)
              v52 = v111 + 1;
            goto LABEL_185;
          }
LABEL_184:
          v52 = 0;
          goto LABEL_185;
        }
      }
      else
      {
        v49 = a2[16];
        if (v49)
        {
          while (1)
          {
            v50 = (_DWORD *)*v48;
            if (*(_DWORD *)*v48 == 32 && v50[1] == *v19)
              break;
            ++v48;
            if (!--v49)
              goto LABEL_133;
          }
          v22 = v50 + 2;
          goto LABEL_167;
        }
      }
LABEL_133:
      v52 = 1;
      goto LABEL_174;
    }
    v45 = vcvtpd_s64_f64(log2((double)v102));
    if (!v99)
    {
      if (v45 < 0 || (int)v102 <= v45)
        return FigSignalErrorAt(1, 0, 0, 0, 0, 0, 0);
      result = hevcbridgeUPullAlways(a1, (uint64_t)a2, HIWORD(*((_DWORD *)a2 + 11)) & 1, 279, &v111, v45);
      if ((_DWORD)result)
        return result;
    }
    if ((v45 & 0x80000000) == 0 && v45 < (int)v102)
    {
      v43 = 1;
LABEL_102:
      v42 = v44;
      goto LABEL_103;
    }
    return FigSignalErrorAt(1, 0, 0, 0, 0, 0, 0);
  }
  if (!*((_BYTE *)v15 + 35) && !*((_BYTE *)v15 + 36))
    goto LABEL_57;
LABEL_46:
  v126[0] = 0;
  v34 = *(_QWORD *)((char *)a2 + 44);
  result = hevcbridgeUEPullLong(a1, v126);
  if ((v34 & 0x20000000000) != 0 && !(_DWORD)result)
    result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 304, v126[0], 0xFFFFFFFFLL);
  if ((_DWORD)result)
    return result;
  v35 = v126[0];
  if (v126[0])
  {
    LODWORD(v125[0]) = 0;
    result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 42) & 1, 305, (unsigned int *)v125);
    if (!(_DWORD)result)
    {
      v36 = LODWORD(v125[0]) + 1;
      while (1)
      {
        result = hevcbridgeUSkip(a1, v36);
        if ((_DWORD)result)
          break;
        if (!--v35)
          goto LABEL_57;
      }
    }
  }
  else
  {
    if (!*((_BYTE *)v15 + 37))
      goto LABEL_62;
LABEL_57:
    v126[0] = 0;
    result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 43) & 1, 306, v126);
    if ((_DWORD)result)
      return result;
    v37 = v126[0];
    if (v126[0])
    {
      while (1)
      {
        result = hevcbridgeUSkip(a1, 8);
        if ((_DWORD)result)
          break;
        if (!--v37)
          goto LABEL_62;
      }
    }
    else
    {
LABEL_62:
      result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 44) & 1, 307, (_DWORD *)&v116 + 1, 1);
      if (!(_DWORD)result)
      {
        if (HIDWORD(v116) == 1)
        {
          while (*(_DWORD *)(a1 + 76))
          {
            result = hevcbridgeUPullLong(a1, 1, &v116);
            if ((_DWORD)result)
              return result;
            if ((_DWORD)v116)
              goto LABEL_67;
          }
          return 0;
        }
        else
        {
LABEL_67:
          FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
          return 4294954582;
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeUPull(uint64_t a1, int a2, _DWORD *a3)
{
  int v4;
  uint64_t result;

  if (*(_BYTE *)(a1 + 41) || a2 <= 0 || a2 >= 0x1A)
  {
    result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    v4 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 80) >> -(char)a2;
    result = hevcbridgeAdvanceInBitstream(a1, a2);
  }
  *a3 = v4;
  return result;
}

uint64_t hevcbridgeUPullFlagAlways(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  unsigned __int8 v10;
  int v11;

  v11 = 0;
  result = hevcbridgeUPull(a1, 1, &v11);
  if (!(_DWORD)result)
  {
    v10 = v11;
    *a5 = v11;
    if (a3)
      return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t))(a2 + 8))(*(_QWORD *)a2, a4, v10, 0xFFFFFFFFLL);
    else
      return 0;
  }
  return result;
}

uint64_t hevcbridgeUPullFlagIfRequested(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result;
  int v7;

  if (!a3)
    return hevcbridgeUSkip(a1, 1);
  v7 = 0;
  result = hevcbridgeUPull(a1, 1, &v7);
  if (!(_DWORD)result)
    return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t))(a2 + 8))(*(_QWORD *)a2, a4, v7, 0xFFFFFFFFLL);
  return result;
}

uint64_t hevcbridgeUSkip(uint64_t a1, int a2)
{
  if (*(_BYTE *)(a1 + 41) || a2 < 0)
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  else
    return hevcbridgeAdvanceInBitstream(a1, a2);
}

uint64_t hevcbridgeParseProfileTierLevel(uint64_t a1, _QWORD *a2, int a3, unsigned int a4)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned __int8 *v21;
  _BYTE *i;
  const float *v25;
  float32x4_t v26;
  int8x16_t v27;
  int16x4_t v28;
  uint16x4_t v29;
  uint64_t v30;
  int v31;
  BOOL v32;
  BOOL v33;
  int8x16_t v34;
  unsigned int v35;
  int8x16_t v36;
  int8x16_t v37;
  int v38;
  _DWORD v39[2];
  _DWORD v40[2];
  unsigned int v41;
  unsigned int v42;

  v42 = 0;
  v41 = 0;
  *(_DWORD *)((char *)v40 + 3) = 0;
  v40[0] = 0;
  *(_DWORD *)((char *)v39 + 3) = 0;
  v39[0] = 0;
  if (a4 >= 7)
  {
    v7 = 4294954582;
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    return v7;
  }
  if (a3)
  {
    v7 = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, *((_DWORD *)a2 + 15) & 1, 308, 2);
    if ((_DWORD)v7)
      return v7;
    v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 60) >> 1) & 1, 309);
    if ((_DWORD)v7)
      return v7;
    v8 = *((_DWORD *)a2 + 15);
    v9 = hevcbridgeUPullLong(a1, 5, &v42);
    v7 = v9;
    if ((v8 & 4) != 0 && !(_DWORD)v9)
      v7 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 310, v42, 0xFFFFFFFFLL);
    if ((_DWORD)v7)
      return v7;
    v10 = *((_DWORD *)a2 + 15);
    v11 = hevcbridgeUPullLong(a1, 32, &v41);
    v7 = v11;
    if ((v10 & 8) != 0 && !(_DWORD)v11)
      v7 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 311, v41, 0xFFFFFFFFLL);
    if ((_DWORD)v7)
      return v7;
    v12 = *((_DWORD *)a2 + 15);
    if ((v12 & 0x30) != 0)
    {
      v7 = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, (v12 >> 4) & 1, 312, 16);
      if ((_DWORD)v7)
        return v7;
      v13 = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 60) >> 5) & 1, 313, 32);
    }
    else
    {
      v25 = (const float *)&v41;
      v26 = vld1q_dup_f32(v25);
      v36 = (int8x16_t)v26;
      v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (v12 >> 6) & 1, 314);
      if ((_DWORD)v7)
        return v7;
      v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, *((unsigned __int8 *)a2 + 60) >> 7, 315);
      if ((_DWORD)v7)
        return v7;
      v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 15) >> 8) & 1, 316);
      if ((_DWORD)v7)
        return v7;
      v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 15) >> 9) & 1, 317);
      if ((_DWORD)v7)
        return v7;
      v27.i64[0] = 0x101010101010101;
      v27.i64[1] = 0x101010101010101;
      v34 = vbicq_s8(v27, vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v36, (int8x16_t)xmmword_18EDDE040)), (int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v36, (int8x16_t)xmmword_18EDDE050))), (int8x16_t)vuzp1q_s16((int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v36, (int8x16_t)xmmword_18EDDE060)), (int16x8_t)vceqzq_s32((int32x4_t)vandq_s8(v36, (int8x16_t)xmmword_18EDDE070)))));
      v28.i16[0] = v34.u8[4];
      v28.i16[1] = v34.u8[5];
      v28.i16[2] = v34.u8[6];
      v28.i16[3] = v34.u8[7];
      v29 = (uint16x4_t)vtst_s16(v28, v28);
      v37.i32[0] = v29.i32[0];
      v35 = v42;
      if ((vmaxv_u16(v29) & 1) != 0 || v42 - 4 <= 3)
      {
        v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 15) >> 10) & 1, 318);
        if ((_DWORD)v7)
          return v7;
        v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 15) >> 11) & 1, 319);
        if ((_DWORD)v7)
          return v7;
        v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 15) >> 12) & 1, 320);
        if ((_DWORD)v7)
          return v7;
        v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 15) >> 13) & 1, 321);
        if ((_DWORD)v7)
          return v7;
        v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 15) >> 14) & 1, 322);
        if ((_DWORD)v7)
          return v7;
        v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 15) >> 15) & 1, 323);
        if ((_DWORD)v7)
          return v7;
        v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, HIWORD(*((_DWORD *)a2 + 15)) & 1, 324);
        if ((_DWORD)v7)
          return v7;
        v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 15) >> 17) & 1, 325);
        if ((_DWORD)v7)
          return v7;
        v7 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 15) >> 18) & 1, 326);
        if ((_DWORD)v7)
          return v7;
        v30 = a1;
        v31 = 34;
      }
      else
      {
        v30 = a1;
        v31 = 43;
      }
      v7 = hevcbridgeUSkip(v30, v31);
      if ((_DWORD)v7)
        return v7;
      if (v35 - 1 < 5
        || (!v34.i8[1] ? (v32 = v34.u8[2] == 0) : (v32 = 0),
            v32 ? (v33 = v34.u8[3] == 0) : (v33 = 0),
            !v33 || (v37.i8[0] & 1) != 0 || (v37.i8[2] & 1) != 0))
      {
        v13 = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 15) >> 19) & 1, 327);
      }
      else
      {
        v13 = hevcbridgeUSkip(a1, 1);
      }
    }
    v7 = v13;
    if ((_DWORD)v13)
      return v7;
  }
  v7 = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 15) >> 20) & 1, 328, 8);
  if (!(_DWORD)v7)
  {
    if (a4)
    {
      v14 = a4;
      v15 = v40;
      v16 = v39;
      v17 = a4;
      while (1)
      {
        v38 = 0;
        v18 = hevcbridgeUPull(a1, 1, &v38);
        *v15 = v38;
        if ((_DWORD)v18)
          break;
        v38 = 0;
        v18 = hevcbridgeUPull(a1, 1, &v38);
        *v16 = v38;
        if ((_DWORD)v18)
          break;
        ++v15;
        ++v16;
        if (!--v17)
        {
          v19 = a4 - 8;
          while (1)
          {
            v18 = hevcbridgeUSkip(a1, 2);
            if ((_DWORD)v18)
              break;
            if (__CFADD__(v19++, 1))
            {
              v21 = (unsigned __int8 *)v40;
              for (i = v39; ; ++i)
              {
                if (*v21++)
                {
                  v18 = hevcbridgeUSkip(a1, 88);
                  if ((_DWORD)v18)
                    break;
                }
                if (*i)
                {
                  v18 = hevcbridgeUSkip(a1, 8);
                  if ((_DWORD)v18)
                    break;
                }
                v7 = 0;
                if (!--v14)
                  return v7;
              }
              return v18;
            }
          }
          return v18;
        }
      }
      return v18;
    }
    else
    {
      return 0;
    }
  }
  return v7;
}

uint64_t hevcbridgeUESkip(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t result;
  int v6;

  if (*(_BYTE *)(a1 + 41))
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  v1 = a1;
  v2 = *(_DWORD *)(a1 + 80);
  if (v2 >= 0x80)
  {
    v3 = (2 * __clz(v2)) | 1;
    return hevcbridgeAdvanceInBitstream(a1, v3);
  }
  v6 = 0;
  hevcbridgeUPull(a1, 1, &v6);
  if (v6)
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  v4 = 0;
  while (1)
  {
    result = hevcbridgeUPull(v1, 1, &v6);
    if ((_DWORD)result)
      break;
    ++v4;
    if (v6)
    {
      if (v4 >= 0x20)
        return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      a1 = v1;
      v3 = v4;
      return hevcbridgeAdvanceInBitstream(a1, v3);
    }
  }
  return result;
}

uint64_t hevcbridgeUEPullAlways(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned int *a5)
{
  uint64_t result;

  result = hevcbridgeUEPullLong(a1, a5);
  if (a3)
  {
    if (!(_DWORD)result)
      return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t))(a2 + 16))(*(_QWORD *)a2, a4, *a5, 0xFFFFFFFFLL);
  }
  return result;
}

uint64_t hevcbridgeUPullIfRequested(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result;
  unsigned int v8;

  if (!a3)
    return hevcbridgeUSkip(a1, a5);
  v8 = 0;
  result = hevcbridgeUPullLong(a1, a5, &v8);
  if (!(_DWORD)result)
    return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t))(a2 + 16))(*(_QWORD *)a2, a4, v8, 0xFFFFFFFFLL);
  return result;
}

uint64_t hevcbridgeUEPullIfRequested(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result;
  unsigned int v7;

  if (!a3)
    return hevcbridgeUESkip(a1);
  v7 = 0;
  result = hevcbridgeUEPullLong(a1, &v7);
  if (!(_DWORD)result)
    return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t))(a2 + 16))(*(_QWORD *)a2, a4, v7, 0xFFFFFFFFLL);
  return result;
}

uint64_t hevcbridgeParseHRDParameters(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t result;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned __int8 v17;
  __int16 v18;

  v18 = 0;
  v17 = 0;
  if (!a3)
    goto LABEL_20;
  result = hevcbridgeUPullFlagAlways(a1, a2, *(_WORD *)(a2 + 64) & 1, 329, (_BYTE *)&v18 + 1);
  if ((_DWORD)result)
    return result;
  result = hevcbridgeUPullFlagAlways(a1, a2, (*(unsigned __int8 *)(a2 + 64) >> 1) & 1, 330, &v18);
  if ((_DWORD)result)
    return result;
  v8 = HIBYTE(v18);
  v9 = v18;
  if (!(HIBYTE(v18) | v18))
  {
LABEL_20:
    v9 = 0;
    v10 = 0;
    v8 = 0;
LABEL_21:
    v11 = 0;
    while (1)
    {
      v15 = 0;
      v16 = 0;
      result = hevcbridgeUPull(a1, 1, &v15);
      if ((_DWORD)result)
        return result;
      if ((_BYTE)v15)
        goto LABEL_26;
      v15 = 0;
      result = hevcbridgeUPull(a1, 1, &v15);
      if ((_DWORD)result)
        return result;
      if ((_BYTE)v15)
      {
LABEL_26:
        result = hevcbridgeUESkip(a1);
        if ((_DWORD)result)
          return result;
      }
      else
      {
        v15 = 0;
        result = hevcbridgeUPull(a1, 1, &v15);
        if ((_DWORD)result)
          return result;
        if ((_BYTE)v15)
        {
          v12 = 0;
          if (v8)
            goto LABEL_29;
          goto LABEL_41;
        }
      }
      result = hevcbridgeUEPullLong(a1, &v16);
      if ((_DWORD)result)
        return result;
      v12 = v16;
      if (v8)
      {
LABEL_29:
        v13 = 0;
        do
        {
          result = hevcbridgeUESkip(a1);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeUESkip(a1);
          if ((_DWORD)result)
            return result;
          if (v10)
          {
            result = hevcbridgeUESkip(a1);
            if ((_DWORD)result)
              return result;
            result = hevcbridgeUESkip(a1);
            if ((_DWORD)result)
              return result;
          }
          result = hevcbridgeUSkip(a1, 1);
          if ((_DWORD)result)
            return result;
        }
        while (++v13 <= v12);
      }
LABEL_41:
      if (v9)
      {
        v14 = 0;
        do
        {
          result = hevcbridgeUESkip(a1);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeUESkip(a1);
          if ((_DWORD)result)
            return result;
          if (v10)
          {
            result = hevcbridgeUESkip(a1);
            if ((_DWORD)result)
              return result;
            result = hevcbridgeUESkip(a1);
            if ((_DWORD)result)
              return result;
          }
          result = hevcbridgeUSkip(a1, 1);
          if ((_DWORD)result)
            return result;
        }
        while (++v14 <= v12);
      }
      result = 0;
      if (++v11 > a4)
        return result;
    }
  }
  result = hevcbridgeUPullFlagAlways(a1, a2, (*(unsigned __int8 *)(a2 + 64) >> 2) & 1, 331, &v17);
  if (!(_DWORD)result)
  {
    v10 = v17;
    if (!v17
      || (result = hevcbridgeUPullIfRequested(a1, a2, (*(unsigned __int8 *)(a2 + 64) >> 3) & 1, 332, 8),
          !(_DWORD)result)
      && (result = hevcbridgeUPullIfRequested(a1, a2, (*(unsigned __int8 *)(a2 + 64) >> 4) & 1, 333, 5),
          !(_DWORD)result)
      && (result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(unsigned __int8 *)(a2 + 64) >> 5) & 1, 334),
          !(_DWORD)result)
      && (result = hevcbridgeUPullIfRequested(a1, a2, (*(unsigned __int8 *)(a2 + 64) >> 6) & 1, 335, 5),
          !(_DWORD)result))
    {
      result = hevcbridgeUPullIfRequested(a1, a2, *(unsigned __int8 *)(a2 + 64) >> 7, 336, 4);
      if (!(_DWORD)result)
      {
        result = hevcbridgeUPullIfRequested(a1, a2, *(_BYTE *)(a2 + 65) & 1, 337, 4);
        if (!(_DWORD)result)
        {
          if (!v10
            || (result = hevcbridgeUPullIfRequested(a1, a2, (*(unsigned __int16 *)(a2 + 64) >> 9) & 1, 338, 4),
                !(_DWORD)result))
          {
            result = hevcbridgeUPullIfRequested(a1, a2, (*(unsigned __int16 *)(a2 + 64) >> 10) & 1, 339, 5);
            if (!(_DWORD)result)
            {
              result = hevcbridgeUPullIfRequested(a1, a2, (*(unsigned __int16 *)(a2 + 64) >> 11) & 1, 340, 5);
              if (!(_DWORD)result)
              {
                result = hevcbridgeUPullIfRequested(a1, a2, (*(unsigned __int16 *)(a2 + 64) >> 12) & 1, 341, 5);
                if (!(_DWORD)result)
                  goto LABEL_21;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeParseVPSExtension(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _BYTE *a9, _BYTE *a10)
{
  uint64_t v10;
  _QWORD *v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  _QWORD *v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void **v35;
  void *v36;
  uint64_t v38;
  uint64_t v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  _DWORD *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  char *v47;
  uint64_t v48;
  unsigned __int8 *v49;
  int v50;
  uint64_t v51;
  unsigned int v52;
  __int128 v53;
  uint64_t v54;
  char *v55;
  unsigned __int8 v56;
  int v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int v61;
  unsigned __int8 v62;
  char v63;
  __int128 *v64;
  char *v65;
  uint64_t v66;
  char v67;
  unsigned int v68;
  int *v69;
  __int128 *v70;
  uint64_t i;
  _QWORD *v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  unsigned int v77;
  char v78;
  int v79;
  _BOOL4 v80;
  char *v81;
  char *v82;
  int v83;
  uint64_t v84;
  int v85;
  char *v86;
  int v87;
  unint64_t v88;
  _QWORD *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int *v93;
  int v94;
  int v95;
  size_t v96;
  char *v97;
  uint64_t v98;
  char *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  size_t v106;
  _BYTE *v107;
  uint64_t v108;
  _BYTE *v109;
  uint64_t v110;
  uint64_t v111;
  size_t v112;
  size_t v113;
  size_t v114;
  unsigned __int8 v115;
  unsigned __int8 v116;
  unsigned __int8 v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  unsigned __int8 *v121;
  _BYTE *v122;
  _BYTE *v123;
  _BYTE *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  unsigned __int8 v128;
  unsigned __int8 v129;
  unsigned __int8 v130;
  uint64_t v131;
  uint64_t v132;
  unsigned __int8 v133;
  uint64_t v134;
  int v135;
  _BYTE *v136;
  unsigned __int8 *v137;
  uint64_t v138;
  unsigned __int8 v139;
  uint64_t v140;
  uint64_t v141;
  unint64_t v142;
  unsigned __int8 v143;
  unint64_t v144;
  unsigned __int8 v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  unsigned __int8 *v149;
  _BYTE *v150;
  void *v151;
  _BYTE *v152;
  unsigned __int8 *v153;
  _BYTE *v154;
  _BYTE *v155;
  void *v156;
  _BYTE *v157;
  int v158;
  unsigned int v159;
  uint64_t v160;
  uint64_t v161;
  _BYTE *v162;
  uint64_t v163;
  size_t v164;
  uint64_t v165;
  _BYTE *v166;
  _BYTE *v167;
  size_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  unsigned int v172;
  uint64_t v173;
  char *v174;
  _BYTE *v175;
  uint64_t v176;
  char v177;
  unsigned int v178;
  int v179;
  int v180;
  uint64_t v181;
  uint64_t v182;
  unsigned __int8 *v183;
  double v184;
  uint64_t v185;
  uint64_t v186;
  unsigned __int8 v187;
  uint64_t v188;
  unsigned int v189;
  int v190;
  int v191;
  unsigned int v192;
  uint64_t v193;
  uint64_t v194;
  unint64_t v195;
  uint64_t v196;
  unsigned __int8 v197;
  unsigned __int8 v198;
  unsigned int v199;
  BOOL v200;
  unint64_t v201;
  uint64_t v202;
  uint64_t v203;
  char v204;
  uint64_t v205;
  int v206;
  uint64_t v207;
  unint64_t v208;
  unint64_t v209;
  unsigned int v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  _BYTE *v215;
  unint64_t v216;
  _BYTE *v217;
  uint64_t v218;
  _BYTE *v219;
  char *v220;
  uint64_t v221;
  int v222;
  int v223;
  char *v224;
  uint64_t v225;
  uint64_t v226;
  uint64x2_t v227;
  uint32x2_t v228;
  int32x2_t v229;
  int64x2_t v230;
  _BYTE *v231;
  int64x2_t v232;
  int32x2_t v233;
  uint32x2_t v234;
  uint64_t k;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  int v239;
  int v240;
  int v241;
  int v242;
  int v243;
  uint64_t v244;
  unsigned int v245;
  void *__dst;
  unsigned int v247;
  size_t v248;
  uint64_t v249;
  _BYTE *v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  int v254;
  uint64_t v255;
  unsigned int j;
  void *v257;
  unsigned int v258;
  _BYTE *v259;
  void *v260;
  char *v261;
  _BYTE *v262;
  int v263;
  _BYTE *v264;
  char *v265;
  unint64_t v266;
  unsigned __int8 *v267;
  unsigned int v268;
  _BYTE *v269;
  _BYTE *__src;
  unsigned int v271;
  uint64_t v272;
  size_t count;
  uint64_t v274;
  int v275;
  int v276;
  unsigned __int8 *v277;
  unsigned __int8 v278;
  unsigned __int8 v279;
  _BYTE *v280;
  int v281;
  int v282;
  _BYTE *v283;
  char *v284;
  _BYTE *v285;
  int v286;
  unsigned int v287;
  char v288;
  __int16 v289;
  uint64_t v290;
  uint64_t v291;
  __int16 v292;
  unsigned int v293;
  int v294;
  __int16 v295;
  _OWORD v296[4];
  _OWORD v297[4];
  char v298;
  _BYTE v299[4095];
  _BYTE v300[64];
  __int128 v301;
  __int128 v302;
  __int128 v303;
  __int128 v304;
  __int128 v305;
  __int128 v306;
  __int128 v307;
  __int128 v308;
  __int128 v309;
  __int128 v310;
  __int128 v311;
  __int128 v312;
  __int128 v313;
  __int128 v314;
  __int128 v315;
  uint64_t v316;
  _BYTE v317[64];
  _OWORD v318[16];
  _QWORD v319[2];
  char v320;
  _DWORD v321[18];
  _QWORD v322[5];

  v10 = MEMORY[0x1E0C80A78]();
  v18 = v11;
  v322[2] = *MEMORY[0x1E0C80C00];
  v295 = 0;
  v322[0] = 0;
  v322[1] = 0;
  memset(v321, 0, 64);
  if (v14 >= 0x3E)
    v19 = 62;
  else
    v19 = v14;
  v319[0] = 0;
  v319[1] = 0;
  v320 = 0;
  v294 = 0;
  memset(v318, 0, sizeof(v318));
  v293 = 0;
  v292 = 0;
  v290 = 0;
  v291 = 0;
  memset(v317, 0, sizeof(v317));
  v289 = 0;
  v288 = 0;
  if (v12 != 1 || v13 != 1)
    goto LABEL_171;
  v20 = v16;
  v21 = v15;
  v22 = v14;
  v23 = v10;
  v275 = v17;
  if (v14)
  {
    v24 = hevcbridgeParseProfileTierLevel(v10, v11, 0, v15);
    if ((_DWORD)v24)
      goto LABEL_9;
  }
  v24 = hevcbridgeUPullFlagAlways(v23, (uint64_t)v18, (*((_DWORD *)v18 + 11) >> 18) & 1, 21, (_BYTE *)&v295 + 1);
  if ((_DWORD)v24)
    goto LABEL_9;
  v271 = v20;
  v268 = v21;
  v38 = 0;
  v39 = v19;
  LODWORD(v19) = 0;
  v269 = a10;
  __src = a9;
  v272 = v39;
  count = (v39 + 2);
  do
  {
    LOBYTE(v301) = 0;
    v24 = hevcbridgeUPullFlagAlways(v23, (uint64_t)v18, (*((_DWORD *)v18 + 11) >> 19) & 1, 22, &v301);
    if ((_DWORD)v24)
      goto LABEL_9;
    v40 = v301;
    *((_BYTE *)v322 + v38) = v301;
    v19 = (v19 + v40);
    ++v38;
  }
  while (v38 != 16);
  v286 = HIBYTE(v295);
  v41 = v19 - HIBYTE(v295);
  if (v19 > HIBYTE(v295))
  {
    if (v41 <= 1)
      v42 = 1;
    else
      v42 = v41;
    v43 = v321;
    while (1)
    {
      LODWORD(v301) = 0;
      v44 = *(_QWORD *)((char *)v18 + 44);
      v45 = hevcbridgeUPullLong(v23, 3, &v301);
      v25 = v45;
      if ((v44 & 0x100000) != 0 && !(_DWORD)v45)
        v25 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))v18[2])(*v18, 23, v301, 0xFFFFFFFFLL);
      if ((_DWORD)v25)
        break;
      *v43++ = v301 + 1;
      if (!--v42)
        goto LABEL_30;
    }
LABEL_10:
    v26 = 0;
LABEL_11:
    v280 = 0;
    v283 = 0;
    v277 = 0;
    v285 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    goto LABEL_12;
  }
LABEL_30:
  if (v286 && (_DWORD)v19)
  {
    if (v19 < 2)
    {
      v51 = 1;
    }
    else
    {
      v46 = 0;
      v47 = (char *)v319 + 1;
      v48 = v19 - 1;
      v49 = (unsigned __int8 *)v321;
      do
      {
        v50 = *v49;
        v49 += 4;
        v46 += v50;
        *v47++ = v46;
        --v48;
      }
      while (v48);
      v51 = v19;
    }
    v52 = *((unsigned __int8 *)v319 + (v19 - 1));
    v321[(v19 - 1)] = 6 - v52;
    *((_BYTE *)v319 + v51) = 6;
    if (v52 >= 6)
    {
LABEL_171:
      v25 = 4294954582;
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_10;
    }
  }
  v24 = hevcbridgeUPullFlagAlways(v23, (uint64_t)v18, (*((_DWORD *)v18 + 11) >> 21) & 1, 24, &v295);
  if ((_DWORD)v24)
  {
LABEL_9:
    v25 = v24;
    goto LABEL_10;
  }
  v258 = v22;
  *(_QWORD *)&v53 = -1;
  *((_QWORD *)&v53 + 1) = -1;
  v318[15] = v53;
  *(_OWORD *)((char *)&v318[14] + 4) = v53;
  *(_OWORD *)((char *)&v318[13] + 4) = v53;
  *(_OWORD *)((char *)&v318[12] + 4) = v53;
  *(_OWORD *)((char *)&v318[11] + 4) = v53;
  *(_OWORD *)((char *)&v318[10] + 4) = v53;
  *(_OWORD *)((char *)&v318[9] + 4) = v53;
  *(_OWORD *)((char *)&v318[8] + 4) = v53;
  *(_OWORD *)((char *)&v318[7] + 4) = v53;
  *(_OWORD *)((char *)&v318[6] + 4) = v53;
  *(_OWORD *)((char *)&v318[5] + 4) = v53;
  *(_OWORD *)((char *)&v318[4] + 4) = v53;
  *(_OWORD *)((char *)&v318[3] + 4) = v53;
  *(_OWORD *)((char *)&v318[2] + 4) = v53;
  *(_OWORD *)((char *)&v318[1] + 4) = v53;
  *(_OWORD *)((char *)v318 + 4) = v53;
  LODWORD(v318[0]) = 0;
  if ((_DWORD)v272)
  {
    v54 = 1;
    v26 = (char *)malloc_type_calloc(count, 1uLL, 0x100004077774924uLL);
    v55 = 0;
    v56 = 0;
    v263 = v295;
    v261 = v26 + 1;
    v57 = 1;
    v265 = v26;
    do
    {
      v284 = v55;
      v287 = 0;
      v301 = 0uLL;
      if (v263)
      {
        v58 = v26;
        v59 = *(_QWORD *)((char *)v18 + 44);
        v60 = hevcbridgeUPullLong(v23, 6, &v287);
        v25 = v60;
        if ((v59 & 0x400000) != 0 && !(_DWORD)v60)
          v25 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))v18[2])(*v18, 25, v287, 0xFFFFFFFFLL);
        v26 = v58;
        if ((_DWORD)v25)
          goto LABEL_11;
        v61 = v287;
      }
      else
      {
        v287 = v54;
        v61 = v54;
      }
      v281 = v57;
      v26[v54] = v61;
      v266 = v54;
      v317[v61] = v54;
      v62 = v56;
      if (v61 > v56)
        v62 = v61;
      v278 = v62;
      if (v286)
      {
        if ((_DWORD)v19)
        {
          v63 = 0;
          v64 = &v301;
          v65 = (char *)v319 + 1;
          v66 = v19;
          do
          {
            v67 = *v65++;
            v68 = (v61 & ~(-1 << v67)) >> v63;
            v63 = v67;
            *(_BYTE *)v64 = v68;
            v64 = (__int128 *)((char *)v64 + 1);
            --v66;
          }
          while (v66);
        }
      }
      else if ((_DWORD)v19)
      {
        v69 = v321;
        v70 = &v301;
        for (i = v19; i; --i)
        {
          LODWORD(v297[0]) = 0;
          v72 = v18;
          v73 = *(_QWORD *)((char *)v18 + 44);
          v74 = *v69++;
          v75 = hevcbridgeUPullLong(v23, v74, v297);
          v25 = v75;
          if ((v73 & 0x800000) != 0)
          {
            v18 = v72;
            if (!(_DWORD)v75)
              v25 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))v72[2])(*v72, 26, LODWORD(v297[0]), 0xFFFFFFFFLL);
            if ((_DWORD)v25)
            {
LABEL_78:
              v26 = v265;
              goto LABEL_11;
            }
          }
          else
          {
            v18 = v72;
            if ((_DWORD)v75)
              goto LABEL_78;
          }
          *(_BYTE *)v70 = v297[0];
          v70 = (__int128 *)((char *)v70 + 1);
        }
      }
      v76 = 0;
      v77 = 0;
      v297[0] = 0uLL;
      v26 = v265;
      do
      {
        if (*((_BYTE *)v322 + v76))
        {
          v78 = *((_BYTE *)&v301 + v77++);
          *((_BYTE *)v297 + v76) = v78;
        }
        ++v76;
      }
      while (v76 != 16);
      v79 = BYTE1(v297[0]);
      *((_DWORD *)v318 + v61) = BYTE1(v297[0]);
      if (*((_DWORD *)v318 + *v265) == v79)
      {
        v80 = 0;
      }
      else
      {
        v81 = 0;
        do
        {
          v82 = v81;
          if (v284 == v81)
            break;
          v83 = *((_DWORD *)v318 + (v81++)[(_QWORD)v261]);
        }
        while (v83 != v79);
        v80 = (unint64_t)(v82 + 1) >= v266;
      }
      v56 = v278;
      if ((*((_BYTE *)v18 + 47) & 1) != 0)
      {
        v25 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, _QWORD))v18[2])(*v18, 27, BYTE3(v297[0]) | (v61 << 8), (v266 - 1));
        v26 = v265;
        if ((_DWORD)v25)
          goto LABEL_11;
      }
      v57 = v281 + v80;
      v54 = v266 + 1;
      v55 = v284 + 1;
    }
    while (v266 + 1 != (_DWORD)v272 + 1);
  }
  else
  {
    v265 = 0;
    v56 = 0;
    v57 = 1;
  }
  v84 = hevcbridgeUPullAlways(v23, (uint64_t)v18, (*((_DWORD *)v18 + 11) >> 25) & 1, 28, &v294, 4);
  if ((_DWORD)v84)
    goto LABEL_81;
  v279 = v56;
  v85 = v294;
  v86 = v265;
  if (v294 && v57)
  {
    v87 = 0;
    v88 = ((unint64_t)v56 << 16) + 0x10000;
    v282 = v57;
    while (1)
    {
      LODWORD(v301) = 0;
      v89 = v18;
      v90 = *(_QWORD *)((char *)v18 + 44);
      v91 = hevcbridgeUPullLong(v23, v85, &v301);
      v25 = v91;
      if ((v90 & 0x4000000) != 0)
      {
        v18 = v89;
        if (!(_DWORD)v91)
          v25 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))v89[2])(*v89, 29, v301, 0xFFFFFFFFLL);
      }
      else
      {
        v18 = v89;
      }
      if ((_DWORD)v25)
        goto LABEL_82;
      if ((*((_BYTE *)v18 + 47) & 8) != 0)
        break;
LABEL_97:
      ++v87;
      v86 = v265;
      if (v87 == v282)
        goto LABEL_98;
    }
    v92 = 0;
    v93 = (int *)v318;
    v94 = v301;
    while (1)
    {
      v95 = *v93++;
      if (v95 == v87)
      {
        v84 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))v18[2])(*v18, 30, v94 | v92, 0xFFFFFFFFLL);
        if ((_DWORD)v84)
          break;
      }
      v92 += 0x10000;
      if (v88 == v92)
        goto LABEL_97;
    }
LABEL_81:
    v25 = v84;
LABEL_82:
    v280 = 0;
    v283 = 0;
LABEL_83:
    v277 = 0;
    v285 = 0;
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v26 = v265;
    goto LABEL_12;
  }
LABEL_98:
  v265 = v86;
  v274 = v23;
  if (!(_DWORD)v272)
  {
    v149 = 0;
    v259 = 0;
    v150 = 0;
    v151 = 0;
    v152 = 0;
    v257 = 0;
    v285 = 0;
    v153 = 0;
    v154 = 0;
    v155 = 0;
LABEL_163:
    v277 = v153;
    v280 = v154;
    v283 = v155;
    v260 = v151;
    v262 = v150;
    v267 = v149;
    v264 = v152;
    v156 = 0;
    v157 = 0;
    v158 = 0;
    v159 = v271 + 1;
    goto LABEL_164;
  }
  v96 = v279 + 1;
  v97 = (char *)malloc_type_calloc(count, count, 0x100004077774924uLL);
  v280 = malloc_type_calloc(count, count, 0x100004077774924uLL);
  v283 = v97;
  v98 = (v272 + 1);
  v99 = &v97[count];
  v100 = 1;
  do
  {
    v101 = 0;
    do
    {
      LOBYTE(v301) = 0;
      v102 = hevcbridgeUPullFlagAlways(v274, (uint64_t)v18, (*((_DWORD *)v18 + 11) >> 28) & 1, 31, &v301);
      if ((_DWORD)v102)
      {
        v25 = v102;
        goto LABEL_83;
      }
      v99[v101++] = v301;
    }
    while (v100 != v101);
    ++v100;
    v99 += count;
  }
  while (v100 != v98);
  v251 = (uint64_t)v18;
  v103 = &v283[count];
  v104 = 1;
  do
  {
    v105 = 0;
    v106 = v104 * count;
    v107 = v280;
    do
    {
      v108 = 0;
      v280[v106 + v105] = v283[v106 + v105];
      v109 = v107;
      do
      {
        if (v103[v108] && *v109)
          v280[v106 + v105] = 1;
        ++v108;
        v109 += count;
      }
      while (v104 != v108);
      ++v105;
      ++v107;
    }
    while (v105 != v272);
    ++v104;
    v103 += count;
  }
  while (v104 != v98);
  v110 = 0;
  v111 = 0;
  LOBYTE(v112) = 0;
  LOBYTE(v113) = 0;
  LOBYTE(v114) = 0;
  do
  {
    v115 = 0;
    v116 = 0;
    v117 = 0;
    v118 = (v272 + 1);
    v119 = v111;
    v120 = v110;
    do
    {
      if (v283[v120])
        ++v117;
      if (v280[v120])
        ++v116;
      if (v280[v119])
        ++v115;
      ++v120;
      v119 += count;
      --v118;
    }
    while (v118);
    if (v114 <= v117)
      v114 = v117;
    else
      v114 = v114;
    if (v113 <= v116)
      v113 = v116;
    else
      v113 = v113;
    if (v112 <= v115)
      v112 = v115;
    else
      v112 = v112;
    ++v111;
    v110 += count;
  }
  while (v111 != v98);
  v121 = (unsigned __int8 *)malloc_type_calloc(v96, v114, 0x100004077774924uLL);
  v285 = malloc_type_calloc(v96, v113, 0x100004077774924uLL);
  v122 = malloc_type_calloc(v96, v112, 0x100004077774924uLL);
  v264 = malloc_type_calloc(v96, 1uLL, 0x100004077774924uLL);
  v123 = malloc_type_calloc(v96, 1uLL, 0x100004077774924uLL);
  v124 = malloc_type_calloc(v96, 1uLL, 0x100004077774924uLL);
  v125 = 0;
  v126 = 0;
  do
  {
    v127 = 0;
    v128 = 0;
    v129 = 0;
    v130 = 0;
    v131 = v265[v126];
    v132 = v126;
    do
    {
      v133 = v265[v127];
      if (v283[v125 + v127])
        v121[v131 * v114 + v130++] = v133;
      if (v280[v125 + v127])
        v285[v131 * v113 + v129++] = v133;
      if (v280[v132])
        v122[v131 * v112 + v128++] = v133;
      ++v127;
      v132 += count;
    }
    while (v98 != v127);
    v264[v131] = v130;
    v123[v131] = v129;
    v124[v131] = v128;
    ++v126;
    v125 += count;
  }
  while (v126 != v98);
  v260 = v123;
  v262 = v124;
  v277 = v121;
  v134 = 0;
  v135 = 0;
  v303 = 0u;
  v304 = 0u;
  v301 = 0u;
  v302 = 0u;
  do
  {
    if (!v264[v265[v134]])
      ++v135;
    ++v134;
  }
  while (v98 != v134);
  v136 = malloc_type_calloc(v135, (v112 + 1), 0x100004077774924uLL);
  v244 = v135;
  v137 = (unsigned __int8 *)malloc_type_calloc(v135, 1uLL, 0x100004077774924uLL);
  v138 = 0;
  v139 = 0;
  do
  {
    v140 = v265[v138];
    if (!v264[v140])
    {
      v141 = v139;
      v142 = v139 * (unint64_t)(v112 + 1);
      v136[v142] = v140;
      v143 = v262[v140];
      if (v143)
      {
        v144 = 0;
        v145 = 1;
        do
        {
          v146 = v122[v140 * (unint64_t)v112 + v144];
          if (!*((_BYTE *)&v301 + v146))
          {
            v136[v142 + v145++] = v146;
            *((_BYTE *)&v301 + v146) = 1;
            v143 = v262[v140];
          }
          ++v144;
        }
        while (v144 < v143);
      }
      else
      {
        v145 = 1;
      }
      ++v139;
      v137[v141] = v145;
    }
    ++v138;
  }
  while (v138 != v98);
  v267 = v137;
  v259 = v136;
  v257 = v122;
  if (v135 < 2u)
  {
    v18 = (_QWORD *)v251;
    v154 = v280;
    v155 = v283;
    v153 = v277;
    v150 = v262;
    v152 = v264;
    v151 = v260;
    v149 = v137;
    goto LABEL_163;
  }
  v147 = (v112 + 1);
  v148 = hevcbridgeUEPullAlways(v274, v251, (*(_DWORD *)(v251 + 44) >> 29) & 1, 32, &v293);
  if ((_DWORD)v148)
  {
    v25 = v148;
LABEL_160:
    v33 = 0;
    v34 = 0;
    v18 = (_QWORD *)v251;
    v28 = v264;
    v26 = v265;
    v27 = v257;
    goto LABEL_184;
  }
  v255 = v293;
  if (v293 >= 0x400)
  {
    v25 = 4294954582;
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    goto LABEL_160;
  }
  v172 = v271 + 1;
  v248 = v293 + v271 + 1;
  if (!v293)
  {
    v156 = 0;
    v157 = 0;
    v158 = 0;
    v18 = (_QWORD *)v251;
    v159 = v293 + v271 + 1;
    goto LABEL_164;
  }
  v250 = malloc_type_calloc(v248, 1uLL, 0x100004077774924uLL);
  v243 = v275 + 1;
  __dst = malloc_type_calloc(v248, (v275 + 1), 0x100004077774924uLL);
  if (a9)
    memcpy(__dst, a9, v243 * v172);
  *v250 = 1;
  if (v271)
  {
    if (v172 <= 2)
      v173 = 2;
    else
      v173 = v172;
    v174 = a10 + 1;
    v175 = v250 + 1;
    v176 = v173 - 1;
    do
    {
      v177 = *v174++;
      *v175++ = v177;
      --v176;
    }
    while (v176);
  }
  else
  {
    v172 = 1;
  }
  v181 = 0;
  do
  {
    v316 = 0;
    v314 = 0u;
    v315 = 0u;
    v312 = 0u;
    v313 = 0u;
    v310 = 0u;
    v311 = 0u;
    v308 = 0u;
    v309 = 0u;
    v306 = 0u;
    v307 = 0u;
    v304 = 0u;
    v305 = 0u;
    v302 = 0u;
    v303 = 0u;
    v182 = 1;
    v301 = 0u;
    v18 = (_QWORD *)v251;
    v183 = v267;
    do
    {
      v184 = log2((double)(v183[v182] + 1));
      LODWORD(v297[0]) = 0;
      v185 = *(_QWORD *)((char *)v18 + 44);
      v186 = hevcbridgeUPullLong(v274, vcvtpd_s64_f64(v184), v297);
      v25 = v186;
      if ((v185 & 0x40000000) != 0)
      {
        v18 = (_QWORD *)v251;
        if (!(_DWORD)v186)
          v25 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t))(v251 + 16))(*(_QWORD *)v251, 33, LODWORD(v297[0]), 0xFFFFFFFFLL);
      }
      else
      {
        v18 = (_QWORD *)v251;
      }
      if ((_DWORD)v25)
        goto LABEL_189;
      v183 = v267;
      if (LODWORD(v297[0]) > v267[v182])
      {
        v25 = 4294954582;
        FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
        goto LABEL_189;
      }
      *((_DWORD *)&v301 + v182++) = v297[0];
    }
    while (v244 != v182);
    v187 = 0;
    v188 = 1;
    do
    {
      v189 = *((_DWORD *)&v301 + v188);
      if (v189)
      {
        v190 = 0;
        do
          *((_BYTE *)__dst + (v172 + v181) * v243 + v187++) = v259[v188 * v147 + v190++];
        while (v189 > v190);
      }
      ++v188;
    }
    while (v188 != v244);
    v250[v172 + v181++] = v187;
  }
  while (v181 != v255);
  v156 = __dst;
  v159 = v248;
  v157 = v250;
  v18 = (_QWORD *)v251;
  v269 = v250;
  __src = __dst;
  v158 = v255;
LABEL_164:
  v160 = hevcbridgeUPullFlagAlways(v274, (uint64_t)v18, *((_DWORD *)v18 + 11) >> 31, 34, (_BYTE *)&v292 + 1);
  if ((_DWORD)v160)
  {
LABEL_170:
    v25 = v160;
    v27 = v257;
    v33 = v157;
    v30 = v262;
    v28 = v264;
    v34 = v156;
    v31 = v259;
    v29 = v260;
    v26 = v265;
    v32 = v267;
    goto LABEL_12;
  }
  v254 = v158;
  memset(v300, 0, sizeof(v300));
  if (HIBYTE(v292))
  {
    v161 = (v272 + 1);
    v162 = v300;
    do
    {
      LODWORD(v301) = 0;
      v160 = hevcbridgeUPullAlways(v274, (uint64_t)v18, v18[6] & 1, 35, &v301, 3);
      if ((_DWORD)v160)
        goto LABEL_170;
      *v162++ = v301;
    }
    while (--v161);
  }
  v160 = hevcbridgeUPullFlagAlways(v274, (uint64_t)v18, (*(_QWORD *)((char *)v18 + 44) >> 33) & 1, 36, &v292);
  if ((_DWORD)v160)
    goto LABEL_170;
  v247 = v159;
  bzero(&v298, 0x1000uLL);
  if (!(_BYTE)v292 || !(_DWORD)v272)
  {
LABEL_181:
    __dst = v156;
    v250 = v157;
    v170 = hevcbridgeUPullFlagAlways(v274, (uint64_t)v18, (*(_QWORD *)((char *)v18 + 44) >> 35) & 1, 38, &v289);
    if ((_DWORD)v170)
    {
      v25 = v170;
LABEL_189:
      v28 = v264;
      v26 = v265;
      v27 = v257;
      v29 = v260;
      v30 = v262;
      v31 = v259;
      v32 = v267;
      v33 = v250;
      v34 = __dst;
      goto LABEL_12;
    }
    v253 = (uint64_t)v18;
    v171 = hevcbridgeUEPullAlways(v274, (uint64_t)v18, (*(_QWORD *)((char *)v18 + 44) >> 36) & 1, 39, (unsigned int *)&v291 + 1);
    if ((_DWORD)v171)
      goto LABEL_187;
    v178 = HIDWORD(v291);
    if (HIDWORD(v291) >= 2)
    {
      v180 = 2;
      do
      {
        LOBYTE(v301) = 0;
        v171 = hevcbridgeUPullFlagAlways(v274, v253, (*(_QWORD *)(v253 + 44) >> 37) & 1, 40, &v301);
        if ((_DWORD)v171)
          goto LABEL_187;
        v25 = hevcbridgeParseProfileTierLevel(v274, (_QWORD *)v253, v301, v268);
        if ((_DWORD)v25)
          goto LABEL_188;
      }
      while (++v180 <= v178);
    }
    if (v247 < 2)
    {
      v179 = 0;
      v245 = 0;
    }
    else
    {
      v171 = hevcbridgeUEPullAlways(v274, v253, (*(_QWORD *)(v253 + 44) >> 38) & 1, 41, (unsigned int *)&v291);
      if ((_DWORD)v171)
        goto LABEL_187;
      v179 = v291;
      if (v291 >= 0x400)
        goto LABEL_342;
      v171 = hevcbridgeUPullAlways(v274, v253, (*(_QWORD *)(v253 + 44) >> 39) & 1, 42, (_DWORD *)&v290 + 1, 2);
      if ((_DWORD)v171)
      {
LABEL_187:
        v25 = v171;
LABEL_188:
        v18 = (_QWORD *)v253;
        goto LABEL_189;
      }
      v245 = HIDWORD(v290);
    }
    if (v245 >= 2)
      v191 = 2;
    else
      v191 = v245;
    v242 = v191;
    if (*(_BYTE *)(v253 + 152))
    {
LABEL_235:
      v25 = 1;
      goto LABEL_188;
    }
    v241 = v179 + v247;
    if (v179 + v247 >= 2)
    {
      v239 = vcvtpd_s64_f64(log2((double)(v254 + v271)));
      v240 = v275 + 1;
      v276 = vcvtpd_s64_f64(log2((double)(v178 + 1)));
      for (j = 1; j != v241; ++j)
      {
        v192 = 0;
        v287 = 0;
        v303 = 0u;
        v304 = 0u;
        v301 = 0u;
        v302 = 0u;
        if (v247 >= 3 && j >= v247)
        {
          v171 = hevcbridgeUPullAlways(v274, v253, (*(_QWORD *)(v253 + 44) >> 40) & 1, 43, &v287, v239);
          if ((_DWORD)v171)
            goto LABEL_187;
          v192 = v287;
          if (v287 > v247 - 2)
            goto LABEL_342;
        }
        if (j >= v247)
          v193 = v192 + 1;
        else
          v193 = j;
        v194 = v193;
        v195 = v269[v193];
        if (j > v271 || v245 == 2)
        {
          if (v269[v193])
          {
            v201 = 0;
            while (1)
            {
              LOBYTE(v297[0]) = 0;
              v171 = hevcbridgeUPullFlagAlways(v274, v253, (*(_QWORD *)(v253 + 44) >> 41) & 1, 44, v297);
              if ((_DWORD)v171)
                goto LABEL_187;
              *((_BYTE *)&v301 + v201++) = v297[0];
              v195 = v269[v194];
              if (v201 >= v195)
                goto LABEL_266;
            }
          }
        }
        else
        {
          if (v242)
          {
            if (v269[v193])
            {
              v196 = 0;
              v197 = 0;
              v198 = 0;
              do
              {
                v199 = __src[(v194 * v240 + v196)];
                v200 = v199 >= v198;
                if (v199 > v198)
                  v198 = __src[(v194 * v240 + v196)];
                if (v200)
                  v197 = v196;
                ++v196;
              }
              while (v195 != v196);
            }
            else
            {
              v197 = 0;
            }
            *((_BYTE *)&v301 + v197) = 1;
LABEL_266:
            if (!(_DWORD)v195)
              continue;
          }
          else
          {
            if (!v269[v193])
              continue;
            memset(&v301, 1, v269[v193]);
          }
          v202 = 0;
          v203 = 0;
          v204 = 0;
          do
          {
            if (*((_BYTE *)&v301 + v202))
            {
              ++v204;
              v203 = __src[v202];
            }
            ++v202;
          }
          while (v195 != v202);
          v205 = 0;
          v206 = v194 * v240;
          memset(v297, 0, sizeof(v297));
          do
          {
            if (*((_BYTE *)&v301 + v205))
            {
              *((_BYTE *)v297 + v205) = 1;
              if (v205)
              {
                v207 = 0;
                v208 = v317[__src[(v206 + v205)]]
                     * (unint64_t)count;
                do
                {
                  if (v280[v208 + v317[__src[(v206 + v207)]]])
                    *((_BYTE *)v297 + v207) = 1;
                  ++v207;
                }
                while (v205 != v207);
              }
            }
            ++v205;
          }
          while (v205 != v195);
          v209 = 0;
          do
          {
            if (v178 && *((_BYTE *)v297 + v209))
            {
              v171 = hevcbridgeUPullIfRequested(v274, v253, (*(_QWORD *)(v253 + 44) >> 42) & 1, 45, v276);
              if ((_DWORD)v171)
                goto LABEL_187;
              LODWORD(v195) = v269[v194];
            }
            ++v209;
          }
          while (v209 < v195);
          if (v204 == 1)
          {
            if (v264[v203])
            {
              v171 = hevcbridgeUPullFlagIfRequested(v274, v253, (*(_QWORD *)(v253 + 44) >> 43) & 1, 46);
              if ((_DWORD)v171)
                goto LABEL_187;
            }
          }
        }
      }
    }
    v171 = hevcbridgeUEPullAlways(v274, v253, (*(_QWORD *)(v253 + 44) >> 44) & 1, 47, (unsigned int *)&v290);
    if (!(_DWORD)v171)
    {
      v210 = v290;
      if (v290 < 0x100)
      {
        if (*(_QWORD *)(v253 + 144))
        {
          **(_QWORD **)(v253 + 144) = malloc_type_calloc(1uLL, 16 * v290 + 4512, 0x4DAA09A2uLL);
          v211 = **(_QWORD **)(v253 + 144);
          if (!v211)
          {
            v25 = 4294954583;
            goto LABEL_188;
          }
          v212 = 0;
          *(_DWORD *)(v211 + 8) = v210;
          v213 = v211 + 8;
          *(_BYTE *)(v211 + 204) = v289;
          do
          {
            v214 = v265[v212];
            v215 = (_BYTE *)(v211 + v214);
            v215[76] = v264[v214];
            v215[334] = v317[v214];
            if (v264[v214])
            {
              v216 = 0;
              v217 = v215 + 206;
              do
              {
                v218 = v317[v277[v214 + v216]];
                *v217 = v218;
                *(_BYTE *)(v211 + v218 + 270) = v300[v218];
                ++v216;
              }
              while (v216 < v264[v214]);
            }
            ++v212;
          }
          while (v212 != (_DWORD)v272 + 1);
          if ((_DWORD)v272)
          {
            v219 = v299;
            v220 = (char *)(v211 + 399);
            v221 = v272;
            do
            {
              memcpy(v220, v219, --v221 + 1);
              v219 += 65;
              v220 += 65;
            }
            while (v221);
          }
          *(_BYTE *)(v211 + 4494) = v268;
        }
        else
        {
          v213 = 0;
        }
        v222 = 0;
        while (1)
        {
          v171 = hevcbridgeParseRepFormat(v274, (_QWORD *)v253, v222, v213);
          if ((_DWORD)v171)
            goto LABEL_187;
          if (++v222 > v210)
          {
            if (v210)
            {
              v171 = hevcbridgeUPullFlagAlways(v274, v253, (*(_QWORD *)(v253 + 44) >> 45) & 1, 48, (_BYTE *)&v289 + 1);
              if ((_DWORD)v171)
                goto LABEL_187;
            }
            memset(v296, 0, sizeof(v296));
            if (HIBYTE(v289))
            {
              if ((_DWORD)v272)
              {
                v223 = vcvtpd_s64_f64(log2((double)(v210 + 1)));
                v224 = (char *)v296 + 1;
                if (v258 >= 0x3EuLL)
                  v225 = 62;
                else
                  v225 = v258;
                do
                {
                  LODWORD(v301) = 0;
                  v171 = hevcbridgeUPullAlways(v274, v253, (*(_QWORD *)(v253 + 44) >> 46) & 1, 49, &v301, v223);
                  if ((_DWORD)v171)
                    goto LABEL_187;
                  *v224++ = v301;
                }
                while (--v225);
              }
            }
            else
            {
              v226 = (v272 + 2) & 0xFE;
              v227 = (uint64x2_t)vdupq_n_s64((unint64_t)(v272 + 1) - 1);
              v228 = (uint32x2_t)vdup_n_s32(v210);
              v229 = (int32x2_t)0x100000000;
              v230 = (int64x2_t)xmmword_18EDDE080;
              v231 = (char *)v296 + 1;
              v232 = vdupq_n_s64(2uLL);
              do
              {
                v233 = vmovn_s64((int64x2_t)vcgeq_u64(v227, (uint64x2_t)v230));
                v234 = vmin_u32((uint32x2_t)v229, v228);
                if ((v233.i8[0] & 1) != 0)
                  *(v231 - 1) = v234.i8[0];
                if ((v233.i8[4] & 1) != 0)
                  *v231 = v234.i8[4];
                v230 = vaddq_s64(v230, v232);
                v229 = vadd_s32(v229, (int32x2_t)0x200000002);
                v231 += 2;
                v226 -= 2;
              }
              while (v226);
            }
            if (v213)
            {
              for (k = 0; k != 64; ++k)
                *(_BYTE *)(v213 + 4 + k) = *((_BYTE *)v296 + v317[k]);
            }
            v171 = hevcbridgeUPullFlagAlways(v274, v253, (*(_QWORD *)(v253 + 44) >> 47) & 1, 50, &v288);
            if ((_DWORD)v171)
              goto LABEL_187;
            if (v213)
              *(_BYTE *)(v213 + 197) = v288;
            v171 = hevcbridgeUPullFlagIfRequested(v274, v253, *(_WORD *)(v253 + 50) & 1, 51);
            if ((_DWORD)v171)
              goto LABEL_187;
            if (!(_DWORD)v272)
              goto LABEL_235;
            v236 = 0;
            if (v258 >= 0x3EuLL)
              v237 = 62;
            else
              v237 = v258;
            do
            {
              if (!v264[v265[v236 + 1]])
              {
                LOBYTE(v301) = 0;
                v238 = hevcbridgeUPullFlagAlways(v274, v253, (*(_QWORD *)(v253 + 44) >> 49) & 1, 52, &v301);
                v25 = v238;
                if (!v213 || (_DWORD)v238)
                {
                  if ((_DWORD)v238)
                    goto LABEL_188;
                }
                else
                {
                  *(_BYTE *)(v213 + v317[v236 + 1] + 132) = v301;
                }
              }
              ++v236;
              v25 = 1;
            }
            while (v237 != v236);
            goto LABEL_188;
          }
        }
      }
LABEL_342:
      v25 = 4294954582;
      FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      goto LABEL_188;
    }
    goto LABEL_187;
  }
  v163 = 0;
  v165 = v272;
  v164 = count;
  v166 = v299;
  while (2)
  {
    v249 = v165;
    v252 = v163 + 1;
    v167 = v166;
    v168 = v164;
LABEL_176:
    if (!v283[v164])
    {
LABEL_179:
      v164 += count;
      ++v166;
      if (!--v165)
      {
        v164 = v168 + v272 + 3;
        v166 = v167 + 65;
        v163 = v252;
        v165 = v249 - 1;
        if (v252 == v272)
          goto LABEL_181;
        continue;
      }
      goto LABEL_176;
    }
    break;
  }
  LODWORD(v301) = 0;
  v169 = hevcbridgeUPullAlways(v274, (uint64_t)v18, (*(_QWORD *)((char *)v18 + 44) >> 34) & 1, 37, &v301, 3);
  if (!(_DWORD)v169)
  {
    *v166 = v301;
    goto LABEL_179;
  }
  v25 = v169;
  v27 = v257;
  v33 = v157;
  v28 = v264;
  v26 = v265;
  v34 = v156;
LABEL_184:
  v29 = v260;
  v30 = v262;
  v31 = v259;
  v32 = v267;
LABEL_12:
  free(v26);
  free(v283);
  free(v280);
  free(v277);
  free(v285);
  free(v27);
  free(v28);
  free(v29);
  free(v30);
  free(v31);
  free(v32);
  free(v33);
  free(v34);
  if (v25 >= 2)
  {
    v35 = (void **)v18[18];
    if (v35)
    {
      v36 = *v35;
      if (*v35)
      {
        *v35 = 0;
        free(v36);
      }
    }
  }
  return v25;
}

uint64_t hevcbridgeUEPullLong(uint64_t a1, unsigned int *a2)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t result;
  unsigned int v9;
  int v10;
  int v11;

  v11 = 0;
  if (*(_BYTE *)(a1 + 41))
    goto LABEL_13;
  v4 = *(_DWORD *)(a1 + 80);
  if (v4 < 0x80000)
  {
    v10 = 0;
    hevcbridgeUPull(a1, 1, &v10);
    if (!v10)
    {
      v9 = 0;
      while (1)
      {
        result = hevcbridgeUPull(a1, 1, &v10);
        if ((_DWORD)result)
          goto LABEL_14;
        ++v9;
        if (v10)
        {
          if (v9 >= 0x20)
            break;
          result = hevcbridgeUPullLong(a1, v9, &v11);
          v7 = v11 + ~(-1 << v9);
          goto LABEL_12;
        }
      }
    }
LABEL_13:
    result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
LABEL_14:
    v7 = 0;
    goto LABEL_12;
  }
  v5 = __clz(v4);
  v6 = v4 << (v5 + 1) >> -(char)v5;
  if (!v5)
    v6 = 0;
  *(_DWORD *)(a1 + 80) = v6;
  v7 = v6 + ~(-1 << v5);
  result = hevcbridgeAdvanceInBitstream(a1, v5 + 1 + v5);
LABEL_12:
  *a2 = v7;
  return result;
}

uint64_t hevcbridgeParseRepFormat(uint64_t a1, _QWORD *a2, int a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  char v14;
  unsigned int v15;
  char v16;
  uint64_t v17;

  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v8 = *(_QWORD *)((char *)a2 + 44);
  result = hevcbridgeUPullLong(a1, 16, (_DWORD *)&v17 + 1);
  if ((v8 & 0x4000000000000) != 0 && !(_DWORD)result)
    result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 53, HIDWORD(v17), 0xFFFFFFFFLL);
  if (!(_DWORD)result)
  {
    v10 = *(_QWORD *)((char *)a2 + 44);
    result = hevcbridgeUPullLong(a1, 16, &v17);
    if ((v10 & 0x8000000000000) != 0 && !(_DWORD)result)
      result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 54, v17, 0xFFFFFFFFLL);
    if (!(_DWORD)result)
    {
      result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 52) & 1, 55, &v16);
      if (!(_DWORD)result)
      {
        if (v16)
        {
          v11 = *(_QWORD *)((char *)a2 + 44);
          result = hevcbridgeUPullLong(a1, 2, &v15);
          if ((v11 & 0x20000000000000) != 0 && !(_DWORD)result)
            result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 56, v15, 0xFFFFFFFFLL);
          if ((_DWORD)result)
            return result;
          v12 = v15;
          if (v15 == 3)
          {
            result = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 54) & 1, 57);
            if ((_DWORD)result)
              return result;
          }
          result = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) >> 55) & 1, 58, 4);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeUPullIfRequested(a1, (uint64_t)a2, *((_BYTE *)a2 + 51) & 1, 59, 4);
          if ((_DWORD)result)
            return result;
        }
        else
        {
          v12 = 0;
        }
        result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) & 0x200000000000000) != 0, 60, &v14);
        if ((_DWORD)result)
          return result;
        if (v14)
        {
          result = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) & 0x400000000000000) != 0, 61);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) & 0x800000000000000) != 0, 62);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) & 0x1000000000000000) != 0, 63);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeUEPullIfRequested(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 44) & 0x2000000000000000) != 0, 64);
          if (!a4 || (_DWORD)result)
            return result;
        }
        else if (!a4)
        {
          return 0;
        }
        result = 0;
        v13 = a4 + 16 * a3;
        *(_DWORD *)(v13 + 4488) = HIDWORD(v17);
        *(_DWORD *)(v13 + 4492) = v17;
        *(_DWORD *)(v13 + 4496) = v12;
        *(_BYTE *)(v13 + 4500) = 0;
      }
    }
  }
  return result;
}

uint64_t hevcbridgeParseScalingListData(uint64_t a1)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  int v6;
  uint64_t result;
  int v8;
  int v9;

  v2 = 0;
LABEL_2:
  v3 = 0;
  v4 = 16 << (2 * v2);
  if (v4 >= 0x40)
    v4 = 64;
  if (v2 == 3)
    v5 = 3;
  else
    v5 = 1;
  if (v4 <= 1)
    v6 = 1;
  else
    v6 = v4;
  while (1)
  {
    v9 = 0;
    result = hevcbridgeUPull(a1, 1, &v9);
    if ((_DWORD)result)
      return result;
    if ((_BYTE)v9)
    {
      v8 = v6;
      if (v2 < 2 || (result = hevcbridgeSESkip(a1), v8 = v6, !(_DWORD)result))
      {
        while (1)
        {
          result = hevcbridgeSESkip(a1);
          if ((_DWORD)result)
            break;
          if (!--v8)
            goto LABEL_18;
        }
      }
      return result;
    }
    result = hevcbridgeUESkip(a1);
    if ((_DWORD)result)
      return result;
LABEL_18:
    v3 += v5;
    if (v3 >= 6)
    {
      if (++v2 != 4)
        goto LABEL_2;
      return 0;
    }
  }
}

uint64_t hevcbridgeParseSTRefPicSet(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  _BYTE *v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  _BYTE *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  unsigned int v39;
  unint64_t v40;
  int v41;
  unsigned int v42;
  uint64_t v43;
  int v44;
  unint64_t v45;
  unsigned int v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v52;
  unsigned int v53;
  _BYTE *v54;
  unsigned __int8 *v55;
  int v56;
  unsigned int v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD v60[2];
  _QWORD v61[3];

  v61[2] = *MEMORY[0x1E0C80C00];
  v59 = 0;
  if (!a2)
    goto LABEL_24;
  LODWORD(v61[0]) = 0;
  v10 = hevcbridgeUPull(a1, 1, v61);
  if ((_DWORD)v10)
    return v10;
  if (LOBYTE(v61[0]))
  {
    v11 = 0;
    v58 = 0;
    v57 = 0;
    v61[0] = 0;
    v61[1] = 0;
    v60[0] = 0;
    v60[1] = 0;
    if (a2 == a3)
    {
      v10 = hevcbridgeUEPullLong(a1, (unsigned int *)&v58 + 1);
      if ((_DWORD)v10)
        return v10;
      v11 = HIDWORD(v58);
      if (HIDWORD(v58) > a2 - 1)
        goto LABEL_79;
    }
    v10 = hevcbridgeUPullLong(a1, 1, &v58);
    if (!(_DWORD)v10)
    {
      v10 = hevcbridgeUEPullLong(a1, &v57);
      if (!(_DWORD)v10)
      {
        if (v57 < 0x8000)
        {
          v12 = ~v11 + a2;
          v13 = a4 + 164 * v12;
          v14 = *(unsigned __int8 *)(v13 + 160);
          v55 = (unsigned __int8 *)(v13 + 160);
          v16 = (_BYTE *)(v13 + 161);
          v15 = *(unsigned __int8 *)(v13 + 161);
          v54 = v16;
          if ((v15 + v14) <= 0xF)
          {
            v17 = v57 + 1 - 2 * v58 * (v57 + 1);
            v52 = v15 + v14;
            v53 = v12;
            v18 = a4 + 164 * v12;
            v19 = (v15 + v14 + 1);
            v20 = v60;
            v21 = v61;
            while (1)
            {
              v56 = 0;
              v22 = hevcbridgeUPull(a1, 1, &v56);
              v23 = v56;
              *v21 = v56;
              if ((_DWORD)v22)
                return v22;
              if (v23)
              {
                *v20 = 1;
              }
              else
              {
                v56 = 0;
                v22 = hevcbridgeUPull(a1, 1, &v56);
                *v20 = v56;
                if ((_DWORD)v22)
                  return v22;
              }
              ++v20;
              ++v21;
              if (!--v19)
              {
                v24 = *v54;
                if (*v54)
                {
                  v25 = 0;
                  v27 = v52;
                  v26 = v53;
                  v28 = v55;
                  do
                  {
                    v29 = *(_DWORD *)(a4 + 164 * v53 + 60 + 4 * v24) + v17;
                    if (v29 < 0)
                    {
                      v30 = v24 + *v55 - 1;
                      if (*((_BYTE *)v60 + v30))
                      {
                        *(_DWORD *)(a5 + 4 * v25) = v29;
                        *(_BYTE *)(a5 + v25++ + 128) = *((_BYTE *)v61 + v30);
                      }
                    }
                    --v24;
                  }
                  while ((unint64_t)(v24 + 1) > 1);
                }
                else
                {
                  v25 = 0;
                  v28 = v55;
                  v27 = v52;
                  v26 = v53;
                }
                if (v17 < 0 && *((_BYTE *)v60 + v27))
                {
                  *(_DWORD *)(a5 + 4 * v25) = v17;
                  *(_BYTE *)(a5 + v25++ + 128) = *((_BYTE *)v61 + v27);
                }
                v39 = *v28;
                if (!*v28)
                  goto LABEL_66;
                v40 = 0;
                do
                {
                  v41 = *(_DWORD *)(v18 + 4 * v40) + v17;
                  if (v41 < 0 && *((_BYTE *)v60 + v40))
                  {
                    *(_DWORD *)(a5 + 4 * v25) = v41;
                    *(_BYTE *)(a5 + v25++ + 128) = *((_BYTE *)v61 + v40);
                    v39 = *v28;
                  }
                  ++v40;
                }
                while (v40 < v39);
                if (v39)
                {
                  v42 = 0;
                  v43 = v39 - 1;
                  do
                  {
                    v44 = *(_DWORD *)(v18 + 4 * v43) + v17;
                    if (v44 >= 1 && *((_BYTE *)v60 + v43))
                    {
                      *(_DWORD *)(a5 + 4 * v42 + 64) = v44;
                      *(_BYTE *)(a5 + v42++ + 144) = *((_BYTE *)v61 + v43);
                    }
                    v45 = v43-- + 1;
                  }
                  while (v45 > 1);
                }
                else
                {
LABEL_66:
                  v42 = 0;
                }
                if (v17 >= 1 && *((_BYTE *)v60 + v27))
                {
                  *(_DWORD *)(a5 + 4 * v42 + 64) = v17;
                  *(_BYTE *)(a5 + v42++ + 144) = *((_BYTE *)v61 + v27);
                }
                v46 = *v54;
                if (*v54)
                {
                  v47 = 0;
                  v48 = a4 + 164 * v26 + 64;
                  do
                  {
                    v49 = *(_DWORD *)(v48 + 4 * v47) + v17;
                    if (v49 >= 1)
                    {
                      v50 = *v28;
                      if (*((_BYTE *)v60 + v50 + v47))
                      {
                        *(_DWORD *)(a5 + 4 * v42 + 64) = v49;
                        *(_BYTE *)(a5 + v42++ + 144) = *((_BYTE *)v61 + v50 + v47);
                        v46 = *v54;
                      }
                    }
                    ++v47;
                  }
                  while (v47 < v46);
                }
                if (v42 + v25 < 0x10)
                {
                  v10 = 0;
                  *(_BYTE *)(a5 + 160) = v25;
                  *(_BYTE *)(a5 + 161) = v42;
                  return v10;
                }
                goto LABEL_79;
              }
            }
          }
        }
        goto LABEL_79;
      }
    }
  }
  else
  {
LABEL_24:
    v10 = hevcbridgeUEPullLong(a1, (unsigned int *)&v59 + 1);
    if (!(_DWORD)v10)
    {
      v10 = hevcbridgeUEPullLong(a1, (unsigned int *)&v59);
      if (!(_DWORD)v10)
      {
        v31 = HIDWORD(v59);
        if (HIDWORD(v59) < 0x10)
        {
          v32 = v59;
          if (v59 < 0x10 && (v59 + HIDWORD(v59)) < 0x10)
          {
            *(_BYTE *)(a5 + 160) = BYTE4(v59);
            *(_BYTE *)(a5 + 161) = v32;
            if ((_DWORD)v31)
            {
              v33 = 0;
              while (1)
              {
                LODWORD(v61[0]) = 0;
                v22 = hevcbridgeUEPullLong(a1, (unsigned int *)v61);
                if ((_DWORD)v22)
                  break;
                LODWORD(v60[0]) = 0;
                v22 = hevcbridgeUPull(a1, 1, v60);
                if ((_DWORD)v22)
                  break;
                v34 = v61[0];
                if (LODWORD(v61[0]) >= 0x8000)
                  goto LABEL_79;
                *(_BYTE *)(a5 + v33 + 128) = v60[0];
                if (v33)
                  v35 = *(_DWORD *)(a5 + 4 * v33 - 4) + ~v34;
                else
                  v35 = ~v34;
                *(_DWORD *)(a5 + 4 * v33++) = v35;
                if (v31 == v33)
                  goto LABEL_38;
              }
            }
            else
            {
LABEL_38:
              if (!(_DWORD)v32)
                return 0;
              v36 = 0;
              v37 = a5 + 144;
              while (1)
              {
                LODWORD(v61[0]) = 0;
                v22 = hevcbridgeUEPullLong(a1, (unsigned int *)v61);
                if ((_DWORD)v22)
                  break;
                LODWORD(v60[0]) = 0;
                v22 = hevcbridgeUPull(a1, 1, v60);
                if ((_DWORD)v22)
                  break;
                v38 = v61[0];
                if (LODWORD(v61[0]) >= 0x8000)
                  goto LABEL_79;
                *(_BYTE *)(v37 + v36) = v60[0];
                if (v36)
                  v38 += *(_DWORD *)(v37 + 4 * v36 - 84);
                v10 = 0;
                *(_DWORD *)(v37 + 4 * v36++ - 80) = v38 + 1;
                if (v32 == v36)
                  return v10;
              }
            }
            return v22;
          }
        }
LABEL_79:
        v10 = 4294954582;
        FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  return v10;
}

uint64_t hevcbridgeParseVUIParameters(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;
  uint64_t v7;
  char v8;
  char v9;
  char v10;
  unsigned int v11;
  char v12;
  __int16 v13;
  __int16 v14;
  __int16 v15;

  v15 = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  result = hevcbridgeUPullFlagAlways(a1, a2, (*(_QWORD *)(a2 + 44) >> 44) & 1, 109, (_BYTE *)&v15 + 1);
  if (!(_DWORD)result)
  {
    if (!HIBYTE(v15))
      goto LABEL_11;
    v11 = 0;
    v7 = *(_QWORD *)(a2 + 44);
    result = hevcbridgeUPullLong(a1, 8, &v11);
    if ((v7 & 0x200000000000) != 0 && !(_DWORD)result)
      result = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t))(a2 + 16))(*(_QWORD *)a2, 110, v11, 0xFFFFFFFFLL);
    if (!(_DWORD)result)
    {
      if (v11 != 255
        || (result = hevcbridgeUPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) >> 46) & 1, 111, 16), !(_DWORD)result)
        && (result = hevcbridgeUPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) >> 47) & 1, 112, 16), !(_DWORD)result))
      {
LABEL_11:
        result = hevcbridgeUPullFlagAlways(a1, a2, *(_DWORD *)(a2 + 50) & 1, 113, &v15);
        if (!(_DWORD)result)
        {
          if (!(_BYTE)v15
            || (result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) >> 49) & 1, 114), !(_DWORD)result))
          {
            result = hevcbridgeUPullFlagAlways(a1, a2, (*(_QWORD *)(a2 + 44) >> 50) & 1, 115, (_BYTE *)&v14 + 1);
            if (!(_DWORD)result)
            {
              if (!HIBYTE(v14)
                || (v10 = 0,
                    result = hevcbridgeUPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) >> 51) & 1, 116, 3),
                    !(_DWORD)result)
                && (result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) >> 52) & 1, 117),
                    !(_DWORD)result)
                && (result = hevcbridgeUPullFlagAlways(a1, a2, (*(_QWORD *)(a2 + 44) >> 53) & 1, 118, &v10),
                    !(_DWORD)result)
                && (!v10
                 || (result = hevcbridgeUPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) >> 54) & 1, 119, 8),
                     !(_DWORD)result)
                 && (result = hevcbridgeUPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) >> 55) & 1, 120, 8),
                     !(_DWORD)result)
                 && (result = hevcbridgeUPullIfRequested(a1, a2, *(_DWORD *)(a2 + 51) & 1, 121, 8), !(_DWORD)result)))
              {
                result = hevcbridgeUPullFlagAlways(a1, a2, (*(_QWORD *)(a2 + 44) & 0x200000000000000) != 0, 122, &v14);
                if (!(_DWORD)result)
                {
                  if (!(_BYTE)v14
                    || (result = hevcbridgeUEPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) & 0x400000000000000) != 0, 123), !(_DWORD)result)&& (result = hevcbridgeUEPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) & 0x800000000000000) != 0, 124), !(_DWORD)result))
                  {
                    result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) & 0x1000000000000000) != 0, 125);
                    if (!(_DWORD)result)
                    {
                      result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) & 0x2000000000000000) != 0, 126);
                      if (!(_DWORD)result)
                      {
                        result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) & 0x4000000000000000) != 0, 127);
                        if (!(_DWORD)result)
                        {
                          result = hevcbridgeUPullFlagAlways(a1, a2, *(_QWORD *)(a2 + 44) >> 63, 128, (_BYTE *)&v13 + 1);
                          if (!(_DWORD)result)
                          {
                            if (!HIBYTE(v13)
                              || (result = hevcbridgeUEPullIfRequested(a1, a2, *(_DWORD *)(a2 + 52) & 1, 129),
                                  !(_DWORD)result)
                              && (result = hevcbridgeUEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 1) & 1, 130),
                                  !(_DWORD)result)
                              && (result = hevcbridgeUEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 2) & 1, 131),
                                  !(_DWORD)result)
                              && (result = hevcbridgeUEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 3) & 1, 132),
                                  !(_DWORD)result))
                            {
                              result = hevcbridgeUPullFlagAlways(a1, a2, (*(_DWORD *)(a2 + 52) >> 4) & 1, 133, &v13);
                              if (!(_DWORD)result)
                              {
                                if (!(_BYTE)v13)
                                  goto LABEL_46;
                                v9 = 0;
                                v8 = 0;
                                result = hevcbridgeUPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 5) & 1, 134, 32);
                                if (!(_DWORD)result)
                                {
                                  result = hevcbridgeUPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 6) & 1, 135, 32);
                                  if (!(_DWORD)result)
                                  {
                                    result = hevcbridgeUPullFlagAlways(a1, a2, (*(_DWORD *)(a2 + 52) >> 7) & 1, 136, &v9);
                                    if (!(_DWORD)result)
                                    {
                                      if (!v9
                                        || (result = hevcbridgeUEPullIfRequested(a1, a2, *(_DWORD *)(a2 + 53) & 1, 137), !(_DWORD)result))
                                      {
                                        result = hevcbridgeUPullFlagAlways(a1, a2, (*(_DWORD *)(a2 + 52) >> 9) & 1, 138, &v8);
                                        if (!(_DWORD)result)
                                        {
                                          if (!v8
                                            || (result = hevcbridgeParseHRDParameters(a1, a2, 1, a3), !(_DWORD)result))
                                          {
LABEL_46:
                                            result = hevcbridgeUPullFlagAlways(a1, a2, (*(_DWORD *)(a2 + 52) >> 10) & 1, 139, &v12);
                                            if (!(_DWORD)result)
                                            {
                                              if (v12)
                                              {
                                                result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 11) & 1, 140);
                                                if (!(_DWORD)result)
                                                {
                                                  result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 12) & 1, 141);
                                                  if (!(_DWORD)result)
                                                  {
                                                    result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 13) & 1, 142);
                                                    if (!(_DWORD)result)
                                                    {
                                                      result = hevcbridgeUEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 14) & 1, 143);
                                                      if (!(_DWORD)result)
                                                      {
                                                        result = hevcbridgeUEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 15) & 1, 144);
                                                        if (!(_DWORD)result)
                                                        {
                                                          result = hevcbridgeUEPullIfRequested(a1, a2, *(_DWORD *)(a2 + 54) & 1, 145);
                                                          if (!(_DWORD)result)
                                                          {
                                                            result = hevcbridgeUEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 17) & 1, 146);
                                                            if (!(_DWORD)result)
                                                              return hevcbridgeUEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 18) & 1, 147);
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeSESkip(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 41))
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  else
    return hevcbridgeUESkip(a1);
}

uint64_t hevcbridgeSEPullIfRequested(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t result;
  unsigned int v7;

  if (!a3)
    return hevcbridgeSESkip(a1);
  v7 = 0;
  result = hevcbridgeSEPullLong(a1, &v7);
  if (!(_DWORD)result)
    return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t))(a2 + 24))(*(_QWORD *)a2, a4, v7, 0xFFFFFFFFLL);
  return result;
}

uint64_t hevcbridgeParsePictureParameterSetMultilayerExtension(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  __int16 v17;
  __int16 v18;
  unsigned int v19;
  char v20;

  v20 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v14 = 0;
  v15 = 0;
  v13 = 0;
  result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) >> 49) & 1, 212);
  if ((_DWORD)result)
    return result;
  result = hevcbridgeUPullFlagAlways(a1, a2, (*(_QWORD *)(a2 + 44) >> 50) & 1, 213, &v20);
  if ((_DWORD)result)
    return result;
  if (v20)
  {
    result = hevcbridgeUPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) >> 51) & 1, 214, 6);
    if ((_DWORD)result)
      return result;
  }
  v5 = *(_QWORD *)(a2 + 44);
  result = hevcbridgeUEPullLong(a1, &v19);
  if ((v5 & 0x10000000000000) != 0 && !(_DWORD)result)
    result = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t))(a2 + 16))(*(_QWORD *)a2, 215, v19, 0xFFFFFFFFLL);
  if ((_DWORD)result)
    return result;
  v6 = v19;
  if (v19 > 0x400)
    goto LABEL_51;
  if (!v19)
  {
LABEL_32:
    result = hevcbridgeUPullFlagAlways(a1, a2, (*(_DWORD *)(a2 + 52) >> 5) & 1, 232, &v17);
    if ((_DWORD)result)
      return result;
    if (!(_BYTE)v17)
      return result;
    result = hevcbridgeUEPullAlways(a1, a2, (*(_DWORD *)(a2 + 52) >> 6) & 1, 233, &v16);
    if ((_DWORD)result)
      return result;
    v7 = v16;
    if (v16 <= 0x3D)
    {
      if (v16)
      {
        while (1)
        {
          result = hevcbridgeUPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 7) & 1, 234, 6);
          if ((_DWORD)result)
            break;
          if (!--v7)
            goto LABEL_39;
        }
      }
      else
      {
LABEL_39:
        result = hevcbridgeUPullAlways(a1, a2, *(_DWORD *)(a2 + 53) & 1, 235, (_DWORD *)&v15 + 1, 2);
        if (!(_DWORD)result)
        {
          result = hevcbridgeUPullAlways(a1, a2, (*(_DWORD *)(a2 + 52) >> 9) & 1, 236, &v15, 2);
          if (!(_DWORD)result)
          {
            result = hevcbridgeUEPullAlways(a1, a2, (*(_DWORD *)(a2 + 52) >> 10) & 1, 237, (unsigned int *)&v14 + 1);
            if (!(_DWORD)result)
            {
              result = hevcbridgeUEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 11) & 1, 238);
              if (!(_DWORD)result)
              {
                result = hevcbridgeUEPullAlways(a1, a2, (*(_DWORD *)(a2 + 52) >> 12) & 1, 239, (unsigned int *)&v14);
                if (!(_DWORD)result)
                {
                  result = hevcbridgeUEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 13) & 1, 240);
                  if (!(_DWORD)result)
                  {
                    result = hevcbridgeUPullAlways(a1, a2, (*(_DWORD *)(a2 + 52) >> 14) & 1, 241, (_DWORD *)&v13 + 1, 2);
                    if (!(_DWORD)result)
                    {
                      result = hevcbridgeUPullAlways(a1, a2, (*(_DWORD *)(a2 + 52) >> 15) & 1, 242, &v13, 2);
                      if (!(_DWORD)result)
                      {
                        v9 = v14;
                        v8 = HIDWORD(v14);
                        v11 = v13;
                        v10 = HIDWORD(v13);
                        v12 = HIDWORD(v15);
                        if (HIDWORD(v15) != 1
                          || (result = hevcbridgeSEPullIfRequested(a1, a2, *(_DWORD *)(a2 + 54) & 1, 243),
                              !(_DWORD)result)
                          && (result = hevcbridgeSEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 17) & 1, 244),
                              !(_DWORD)result))
                        {
                          hevcBridgeParseColourMappingOctants(a1, (_QWORD *)a2, v12, v15, (v8 - (v9 + v10) + ~v11 + 10), 0, 0, 0, 0, 1 << v12);
                          return 0;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
LABEL_51:
    FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    return 4294954582;
  }
  while (1)
  {
    result = hevcbridgeUPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) >> 53) & 1, 216, 6);
    if ((_DWORD)result)
      return result;
    result = hevcbridgeUPullFlagAlways(a1, a2, (*(_QWORD *)(a2 + 44) >> 54) & 1, 217, (_BYTE *)&v18 + 1);
    if ((_DWORD)result)
      return result;
    if (HIBYTE(v18))
    {
      result = hevcbridgeSEPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) >> 55) & 1, 218);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSEPullIfRequested(a1, a2, *(_DWORD *)(a2 + 51) & 1, 219);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSEPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) & 0x200000000000000) != 0, 220);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSEPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) & 0x400000000000000) != 0, 221);
      if ((_DWORD)result)
        return result;
    }
    result = hevcbridgeUPullFlagAlways(a1, a2, (*(_QWORD *)(a2 + 44) & 0x800000000000000) != 0, 222, &v18);
    if ((_DWORD)result)
      return result;
    if ((_BYTE)v18)
    {
      result = hevcbridgeSEPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) & 0x1000000000000000) != 0, 223);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSEPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) & 0x2000000000000000) != 0, 224);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSEPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 44) & 0x4000000000000000) != 0, 225);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSEPullIfRequested(a1, a2, *(_QWORD *)(a2 + 44) >> 63, 226);
      if ((_DWORD)result)
        return result;
    }
    result = hevcbridgeUPullFlagAlways(a1, a2, *(_DWORD *)(a2 + 52) & 1, 227, (_BYTE *)&v17 + 1);
    if ((_DWORD)result)
      return result;
    if (HIBYTE(v17))
    {
      result = hevcbridgeUEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 1) & 1, 228);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 2) & 1, 229);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 3) & 1, 230);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 4) & 1, 231);
      if ((_DWORD)result)
        return result;
    }
    if (!--v6)
      goto LABEL_32;
  }
}

uint64_t hevcbridgeParsePictureParameterSetSCCExtension(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  char v17;
  unsigned int v18;
  char v19;
  __int16 v20;

  v20 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v4 = *(uint64_t **)(a2 + 144);
  if (v4)
  {
    v5 = *v4;
    if (!v5)
      return 4294954583;
    v6 = v5 + 8;
  }
  else
  {
    v6 = 0;
  }
  result = hevcbridgeUPullFlagAlways(a1, a2, (*(_DWORD *)(a2 + 52) >> 23) & 1, 250, (_BYTE *)&v20 + 1);
  if (!(_DWORD)result)
  {
    result = hevcbridgeUPullFlagAlways(a1, a2, *(_DWORD *)(a2 + 55) & 1, 251, &v20);
    if (!(_DWORD)result)
    {
      if (!(_BYTE)v20
        || (result = hevcbridgeUPullFlagIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 25) & 1, 252), !(_DWORD)result)
        && (result = hevcbridgeSEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 26) & 1, 253), !(_DWORD)result)
        && (result = hevcbridgeSEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 27) & 1, 254), !(_DWORD)result)
        && (result = hevcbridgeSEPullIfRequested(a1, a2, (*(_DWORD *)(a2 + 52) >> 28) & 1, 255), !(_DWORD)result))
      {
        result = hevcbridgeUPullFlagAlways(a1, a2, (*(_DWORD *)(a2 + 52) >> 29) & 1, 256, &v19);
        if (!(_DWORD)result)
        {
          if (!v19)
            goto LABEL_28;
          v15 = 0;
          v16 = 0;
          result = hevcbridgeUEPullAlways(a1, a2, (*(_DWORD *)(a2 + 52) >> 30) & 1, 257, &v18);
          if ((_DWORD)result)
            return result;
          v8 = v18;
          if (v18)
          {
            result = hevcbridgeUPullFlagAlways(a1, a2, *(_DWORD *)(a2 + 52) >> 31, 258, &v17);
            if (!(_DWORD)result)
            {
              result = hevcbridgeUEPullAlways(a1, a2, *(_DWORD *)(a2 + 56) & 1, 259, &v16);
              if (!(_DWORD)result)
              {
                if (v17)
                {
                  v9 = 1;
                  v10 = 8;
                }
                else
                {
                  result = hevcbridgeUEPullAlways(a1, a2, (*(_QWORD *)(a2 + 52) >> 33) & 1, 260, &v15);
                  if ((_DWORD)result)
                    return result;
                  v10 = v15 + 8;
                  v9 = 3;
                }
                v11 = 0;
                v12 = v16 + 8;
LABEL_21:
                v13 = v8;
                while (1)
                {
                  v14 = v11 ? v10 : v12;
                  result = hevcbridgeUPullIfRequested(a1, a2, (*(_QWORD *)(a2 + 52) >> 34) & 1, 261, v14);
                  if ((_DWORD)result)
                    break;
                  if (!--v13)
                  {
                    if (++v11 != v9)
                      goto LABEL_21;
                    goto LABEL_28;
                  }
                }
              }
            }
          }
          else
          {
LABEL_28:
            result = 0;
            if (v6)
              *(_BYTE *)(v6 + 30) = HIBYTE(v20);
          }
        }
      }
    }
  }
  return result;
}

BOOL hevcbridgeMoreRBSPData(uint64_t a1)
{
  __int128 v1;
  __int128 v2;
  __int128 v3;
  int v5;
  int v6;
  int v7;
  int v8;
  _OWORD v9[2];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v1 = *(_OWORD *)(a1 + 80);
  v12 = *(_OWORD *)(a1 + 64);
  v13 = v1;
  v14 = *(_QWORD *)(a1 + 96);
  v2 = *(_OWORD *)(a1 + 48);
  v10 = *(_OWORD *)(a1 + 32);
  v11 = v2;
  v3 = *(_OWORD *)(a1 + 16);
  v9[0] = *(_OWORD *)a1;
  v9[1] = v3;
  if (!BYTE9(v10) && !hevcbridgeUPull((uint64_t)v9, 1, &v8))
  {
    while (!BYTE9(v10))
    {
      v7 = 0;
      v5 = hevcbridgeUPull((uint64_t)v9, 8 - HIDWORD(v12), &v7);
      v6 = v7 != 0;
      if (v5)
        v6 = 4;
      if (v6)
        return v6 != 4;
    }
  }
  return 0;
}

uint64_t hevcbridgeSEPullLong(uint64_t a1, unsigned int *a2)
{
  uint64_t result;
  unsigned int v4;
  unsigned int v5;

  v5 = 0;
  if (*(_BYTE *)(a1 + 41))
  {
    result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    v4 = 0;
  }
  else
  {
    result = hevcbridgeUEPullLong(a1, &v5);
    v4 = ((v5 + 1) >> 1) - ((v5 + 1) >> 1) * 2 * ((v5 + 1) & 1);
  }
  *a2 = v4;
  return result;
}

uint64_t hevcBridgeParseColourMappingOctants(uint64_t a1, _QWORD *a2, uint64_t a3, unsigned int a4, uint64_t a5, unsigned int a6, int a7, int a8, int a9, unsigned int a10)
{
  uint64_t result;
  int v18;
  uint64_t v19;
  char v20;
  int v21;
  uint64_t v22;
  char v23;
  int v24;
  uint64_t v25;
  char v26;
  char v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  int v35;
  char v36;
  int v37;
  char v38;
  unsigned int v40;
  unsigned int v41;
  char v42;
  char v43;

  v43 = 0;
  if (a6 >= a3)
    goto LABEL_13;
  result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 13) >> 18) & 1, 245, &v43);
  if ((_DWORD)result)
    return result;
  if (v43)
  {
    v18 = 0;
    v19 = a6 + 1;
    v20 = 1;
    v37 = a8;
    v35 = a7;
LABEL_6:
    v21 = 0;
    v36 = v20;
    v22 = a7 + (((v18 << a4) * a10) >> 1);
    v23 = 1;
LABEL_7:
    v24 = 0;
    v38 = v23;
    v25 = a8 + ((v21 * a10) >> 1);
    v26 = 1;
    while (1)
    {
      v27 = v26;
      LODWORD(v34) = a9 + ((v24 * a10) >> 1);
      HIDWORD(v34) = a10 >> 1;
      result = hevcBridgeParseColourMappingOctants(a1, a2, a3, a4, a5, v19, v22, v25, v34);
      if ((_DWORD)result)
        break;
      v26 = 0;
      v24 = 1;
      if ((v27 & 1) == 0)
      {
        v23 = 0;
        v21 = 1;
        a8 = v37;
        if ((v38 & 1) != 0)
          goto LABEL_7;
        v20 = 0;
        result = 0;
        v18 = 1;
        a7 = v35;
        if ((v36 & 1) != 0)
          goto LABEL_6;
        return result;
      }
    }
  }
  else
  {
LABEL_13:
    v28 = 0;
LABEL_14:
    v29 = 0;
    while (1)
    {
      v42 = 0;
      result = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 13) >> 19) & 1, 246, &v42);
      if ((_DWORD)result)
        break;
      if (v42)
      {
        v30 = 3;
        do
        {
          v40 = 0;
          v41 = 0;
          v31 = *(_QWORD *)((char *)a2 + 52);
          result = hevcbridgeUEPullLong(a1, &v41);
          if ((v31 & 0x100000) != 0 && !(_DWORD)result)
            result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 247, v41, 0xFFFFFFFFLL);
          if ((_DWORD)result)
            return result;
          if ((_DWORD)a5)
          {
            v32 = *(_QWORD *)((char *)a2 + 52);
            result = hevcbridgeUPullLong(a1, a5, &v40);
            if ((v32 & 0x200000) != 0 && !(_DWORD)result)
              result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 248, v40, 0xFFFFFFFFLL);
            if ((_DWORD)result)
              return result;
            v33 = v40;
          }
          else
          {
            v33 = 0;
          }
          if (v41 | v33)
          {
            result = hevcbridgeUPullFlagIfRequested(a1, (uint64_t)a2, (*((_DWORD *)a2 + 13) >> 22) & 1, 249);
            if ((_DWORD)result)
              return result;
          }
        }
        while (--v30);
      }
      if (++v29 == 4)
      {
        result = 0;
        if (!(++v28 >> a4))
          goto LABEL_14;
        return result;
      }
    }
  }
  return result;
}

uint64_t hevcbridgeParseVPSForHVCCCallbackFlag(uint64_t a1, int a2, char a3)
{
  uint64_t result;

  if (a2 == 309)
  {
    result = 0;
    *(_BYTE *)(a1 + 33) = a3;
  }
  else if (a2 == 8)
  {
    result = 0;
    *(_BYTE *)(a1 + 32) = a3;
  }
  else
  {
    return 4294954584;
  }
  return result;
}

uint64_t hevcbridgeParseVPSForHVCCCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  uint64_t v3;

  v3 = 4294954584;
  if (a2 <= 307)
  {
    if (a2)
    {
      if (a2 != 3)
      {
        if (a2 != 7)
          return v3;
        ++a1;
      }
LABEL_14:
      *a1 = a3;
    }
    else if (a3 != 32)
    {
      return v3;
    }
    return 0;
  }
  switch(a2)
  {
    case 308:
      a1 += 2;
      goto LABEL_14;
    case 309:
      return v3;
    case 310:
      a1 += 3;
      goto LABEL_14;
    case 311:
      a1 += 4;
      goto LABEL_14;
    case 312:
      a1 += 5;
      goto LABEL_14;
    case 313:
      a1 += 6;
      goto LABEL_14;
    default:
      if (a2 == 328)
      {
        a1[7] = a3;
        v3 = 1;
      }
      break;
  }
  return v3;
}

uint64_t hevcbridgeParseSPSForHVCCCallbackFlag(uint64_t a1, int a2, int a3)
{
  if (a2 == 139 || a2 == 108)
    return a3 == 0;
  else
    return 4294954584;
}

uint64_t hevcbridgeParseSPSForHVCCCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  uint64_t v3;

  v3 = 4294954584;
  if (a2 <= 68)
  {
    if (a2)
    {
      if (a2 != 1)
        return v3;
LABEL_20:
      *a1 = a3;
    }
    else if (a3 != 33)
    {
      return v3;
    }
    return 0;
  }
  else
  {
    switch(a2)
    {
      case 'E':
        a1[1] = a3;
        if (!*a1)
          return 0;
        goto LABEL_10;
      case 'F':
      case 'G':
      case 'I':
      case 'L':
        return v3;
      case 'H':
        a1 += 2;
        goto LABEL_20;
      case 'J':
        a1 += 6;
        goto LABEL_20;
      case 'K':
        a1 += 7;
        goto LABEL_20;
      case 'M':
        a1 += 8;
        goto LABEL_20;
      case 'N':
        a1 += 9;
        goto LABEL_20;
      case 'O':
        a1 += 10;
        goto LABEL_20;
      case 'P':
        a1 += 11;
        goto LABEL_20;
      case 'Q':
        a1 += 3;
        goto LABEL_20;
      case 'R':
        a1 += 4;
        goto LABEL_20;
      default:
        if (a2 != 143)
          return v3;
        a1[5] = a3;
LABEL_10:
        v3 = 1;
        break;
    }
  }
  return v3;
}

uint64_t hevcbridgeParsePPSForHVCCCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  unsigned int v3;

  if (a2 == 163)
  {
    *a1 = a3;
    return 1;
  }
  else
  {
    if (a3 == 34)
      v3 = 0;
    else
      v3 = -12712;
    if (a2)
      return 4294954584;
    else
      return v3;
  }
}

uint64_t hevcbridgeParseSEIForHVCCCallbackUnsigned(_DWORD *a1, int a2, int a3)
{
  unsigned int v3;

  if (a2 == 344)
  {
    *a1 = a3;
    return 1;
  }
  else
  {
    if ((a3 - 41) >= 0xFFFFFFFE)
      v3 = 0;
    else
      v3 = -12712;
    if (a2)
      return 4294954584;
    else
      return v3;
  }
}

uint64_t hevcbridgeParseSEIPayloadData(uint64_t a1, int a2, CFTypeRef cf)
{
  const void *v3;

  if (a2 != 347)
    return 4294954584;
  v3 = *(const void **)(a1 + 16);
  *(_QWORD *)(a1 + 16) = cf;
  if (cf)
    CFRetain(cf);
  if (v3)
    CFRelease(v3);
  return 1;
}

__CFData *hevcbridge_copyPatchedParameterSet(uint64_t a1, uint64_t a2, unsigned int a3, int a4, int a5)
{
  __CFData *Mutable;
  UInt8 newBytes[2];
  CFRange v13;

  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFDataAppendBytes(Mutable, (const UInt8 *)(a1 + a2), a3);
  *(_WORD *)newBytes = bswap32(a4 & 0xFFFFFE07 | (8 * a5)) >> 16;
  v13.location = 0;
  v13.length = 2;
  CFDataReplaceBytes(Mutable, v13, newBytes, 2);
  return Mutable;
}

uint64_t hevcbridgeParseVDRRPUDataPayload(uint64_t a1, _QWORD *a2, unsigned int a3, unsigned int a4, int a5, int a6, __int16 a7, int a8, int a9, int a10, uint64_t a11, uint64_t a12)
{
  char *v18;
  char *v19;
  int v20;
  _BOOL4 v21;
  _BOOL4 v22;
  uint64_t v23;
  uint64_t v24;
  _DWORD *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  char *v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  unsigned int v37;
  char *v38;
  char v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  _DWORD *v48;
  __int16 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  _BYTE *v55;
  int v56;
  __int16 v57;
  uint64_t v58;
  int v59;
  int v60;
  __int16 v61;
  uint64_t v62;
  uint64_t v63;
  __int16 v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t i;
  int v69;
  __int16 v70;
  uint64_t v71;
  unint64_t v72;
  int v73;
  __int16 v74;
  uint64_t v75;
  __int16 v76;
  uint64_t v77;
  __int16 v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v84;
  int v85;
  int v87;
  _BOOL4 v88;
  _BOOL4 v89;
  uint64_t v90;
  _DWORD *v91;
  uint64_t v92;
  char *v93;
  int v94;
  uint64_t v95;
  unsigned int v96;
  char *v97;
  char *v98;
  uint64_t v99;
  unsigned int v100;
  uint64_t v101;
  _DWORD *v102;
  int v103;
  uint64_t v104;
  unsigned __int8 v105;
  uint64_t v106;
  _QWORD v107[2];

  v18 = (char *)malloc_type_calloc(1uLL, 0x90uLL, 0x1000040265AC83CuLL);
  v19 = v18;
  if (!v18)
  {
    v80 = FigSignalErrorAt(4294954583, 0, 0, 0, 0, 0, 0);
LABEL_196:
    v31 = v80;
    goto LABEL_197;
  }
  v84 = 0;
  v96 = 0;
  if (a5)
    v20 = 32;
  else
    v20 = a6;
  v103 = v20;
  v95 = a12 + 408;
  v85 = a8;
  if (a8)
    v21 = (a7 & 0x700) == 0;
  else
    v21 = 0;
  if (a9)
    v22 = (a7 & 0x700) == 0;
  else
    v22 = 0;
  v88 = v22;
  v89 = v21;
  v87 = a7 & 0x700 | a10;
  v93 = v18;
LABEL_12:
  v94 = 0;
LABEL_13:
  v23 = 0;
  v24 = 0;
  v105 = 0;
  v100 = v96++;
  v25 = (_DWORD *)(a12 + 420);
  v26 = a12;
  while (2)
  {
    if (*(_DWORD *)(a11 + 4 * v24) > 0xFu)
    {
LABEL_192:
      v81 = 4294954584;
LABEL_189:
      v34 = FigSignalErrorAt(v81, 0, 0, 0, 0, 0, 0);
LABEL_190:
      v31 = v34;
      if (!(_DWORD)v34)
        goto LABEL_178;
      goto LABEL_197;
    }
    v27 = 0;
    v91 = v25;
    v102 = v25;
    v90 = v26;
    v101 = v26;
    v99 = v24;
LABEL_16:
    v28 = v23;
    v104 = 0;
    v29 = *((_BYTE *)a2 + 100);
    v30 = hevcbridgeUEPullLong(a1, (unsigned int *)&v104 + 1);
    v31 = v30;
    if ((v29 & 1) != 0 && !(_DWORD)v30)
      v31 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 496, HIDWORD(v104), 0xFFFFFFFFLL);
    if ((_DWORD)v31)
      goto LABEL_177;
    v32 = HIDWORD(v104);
    if (HIDWORD(v104) >= 0x10)
      goto LABEL_192;
    if (a12)
      *(_BYTE *)(a12 + 316 - v24 + 16 * v24 + v27) = BYTE4(v104);
    switch(v32)
    {
      case 0:
        v33 = &v19[16 * v24 + v27];
        if (*v33)
        {
          v34 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 100) >> 1) & 1, 497, &v105);
          if ((_DWORD)v34)
            goto LABEL_190;
          v28 = v105;
          if (a12)
            *(_BYTE *)(a12 - v24 + 16 * v24 + v27 + 361) = v105;
          if (!(_DWORD)v28)
            goto LABEL_56;
          if (*v33 < 2u)
          {
LABEL_51:
            v37 = v19[16 * v24 + 48 + v27];
          }
          else
          {
            v35 = *((_BYTE *)a2 + 100);
            v36 = hevcbridgeUEPullLong(a1, (unsigned int *)&v104);
            v31 = v36;
            if ((v35 & 4) != 0 && !(_DWORD)v36)
              v31 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 498, v104, 0xFFFFFFFFLL);
            if ((_DWORD)v31)
              goto LABEL_177;
            v37 = v100 - v104 + 1;
            if (a12)
              *(_BYTE *)(a12 - v24 + 16 * v24 + v27 + 24984) = v104;
          }
LABEL_52:
          v31 = 0;
          if ((v37 & 0x80000000) != 0)
            goto LABEL_177;
          v23 = v28;
          if (v37 >= v100)
            goto LABEL_177;
LABEL_142:
          ++v27;
          v101 += 180;
          v102 += 13;
          if (v27 >= (*(_DWORD *)(a11 + 4 * v24) + 1))
          {
            ++v24;
            v26 = v90 + 2700;
            v25 = v91 + 195;
            if (v24 == 3)
              goto LABEL_178;
            continue;
          }
          goto LABEL_16;
        }
        v105 = 0;
LABEL_56:
        v97 = &v19[16 * v24 + v27];
        v42 = *(unsigned int *)(a11 + 4 * v24);
        LODWORD(v107[1]) = 0;
        BYTE4(v106) = 0;
        v43 = *((_WORD *)a2 + 52);
        v44 = hevcbridgeUEPullLong(a1, (unsigned int *)&v107[1]);
        v31 = v44;
        if ((v43 & 1) != 0 && !(_DWORD)v44)
          v31 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 499, LODWORD(v107[1]), 0xFFFFFFFFLL);
        if ((_DWORD)v31)
          goto LABEL_177;
        v45 = v107[1];
        if (a12)
          *(_BYTE *)(v95 + 780 * v24 + 52 * v27) = v107[1];
        if (!v45)
        {
          v34 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 104) >> 1) & 1, 500, (_BYTE *)&v106 + 4);
          if (!(_DWORD)v34)
          {
            v60 = BYTE4(v106);
            if (a12)
              *(_BYTE *)(v95 + 780 * v24 + 52 * v27 + 1) = BYTE4(v106);
            if (v60)
            {
              v107[0] = 0;
              if (!a5)
              {
                v74 = *((_WORD *)a2 + 52);
                v75 = hevcbridgeUEPullLong(a1, (unsigned int *)v107);
                v31 = v75;
                if ((v74 & 4) != 0)
                {
                  v53 = &v19[16 * v24 + v27];
                  if (!(_DWORD)v75)
                    v31 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 501, LODWORD(v107[0]), 0xFFFFFFFFLL);
                  if ((_DWORD)v31)
                    goto LABEL_85;
                }
                else
                {
                  v53 = &v19[16 * v24 + v27];
                  if ((_DWORD)v75)
                    goto LABEL_85;
                }
                if (a12)
                  *(_DWORD *)(v95 + 780 * v24 + 52 * v27 + 4) = v107[0];
              }
              v61 = *((_WORD *)a2 + 52);
              v62 = hevcbridgeUPullLong(a1, v103, (_DWORD *)v107 + 1);
              v31 = v62;
              if ((v61 & 8) != 0)
              {
                v53 = &v19[16 * v24 + v27];
                if (!(_DWORD)v62)
                  v31 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 502, HIDWORD(v107[0]), 0xFFFFFFFFLL);
                if ((_DWORD)v31)
                  goto LABEL_85;
              }
              else
              {
                v53 = &v19[16 * v24 + v27];
                if ((_DWORD)v62)
                  goto LABEL_85;
              }
              if (a12)
                *(_DWORD *)(v95 + 780 * v24 + 52 * v27 + 8) = HIDWORD(v107[0]);
              if (v27 != v42)
              {
                v31 = 0;
                goto LABEL_85;
              }
              if (!a5)
              {
                v78 = *((_WORD *)a2 + 52);
                v79 = hevcbridgeUEPullLong(a1, (unsigned int *)v107);
                v31 = v79;
                if ((v78 & 4) != 0)
                {
                  v53 = &v19[16 * v24 + v27];
                  if (!(_DWORD)v79)
                    v31 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 501, LODWORD(v107[0]), 0xFFFFFFFFLL);
                  if ((_DWORD)v31)
                    goto LABEL_85;
                }
                else
                {
                  v53 = &v19[16 * v24 + v27];
                  if ((_DWORD)v79)
                    goto LABEL_85;
                }
                if (a12)
                  *(_DWORD *)(v95 + 780 * v24 + 52 * v27 + 4) = v107[0];
              }
              v76 = *((_WORD *)a2 + 52);
              v77 = hevcbridgeUPullLong(a1, v103, (_DWORD *)v107 + 1);
              v31 = v77;
              if ((v76 & 8) != 0 && !(_DWORD)v77)
                v31 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 502, HIDWORD(v107[0]), 0xFFFFFFFFLL);
              v53 = &v19[16 * v24 + v27];
              if (a12 && !(_DWORD)v31)
                *(_DWORD *)(v95 + 780 * v24 + 52 * v27 + 8) = HIDWORD(v107[0]);
              goto LABEL_85;
            }
            goto LABEL_63;
          }
          goto LABEL_190;
        }
LABEL_63:
        v46 = 0;
        v107[0] = 0;
        v47 = (v45 + 2);
        v48 = v102;
        while (1)
        {
          v49 = *((_WORD *)a2 + 52);
          if (a5)
          {
            v50 = hevcbridgeUPullLong(a1, 32, v107);
            v31 = v50;
            if ((v49 & 0x20) != 0 && !(_DWORD)v50)
              v31 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 504, LODWORD(v107[0]), 0xFFFFFFFFLL);
            if ((_DWORD)v31)
              goto LABEL_84;
            if (!a12)
              goto LABEL_82;
            goto LABEL_81;
          }
          if ((v49 & 0x10) != 0)
            break;
LABEL_75:
          v52 = hevcbridgeUPullLong(a1, a6, v107);
          v31 = v52;
          if ((v49 & 0x20) != 0 && !(_DWORD)v52)
            v31 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 504, LODWORD(v107[0]), 0xFFFFFFFFLL);
          if ((_DWORD)v31)
            goto LABEL_84;
          if (!a12)
            goto LABEL_82;
          *v48 = v46;
LABEL_81:
          v48[5] = v107[0];
LABEL_82:
          ++v48;
          if (!--v47)
          {
            v31 = 0;
            goto LABEL_84;
          }
        }
        v51 = hevcbridgeSEPullLong(a1, (unsigned int *)v107 + 1);
        if (!(_DWORD)v51)
        {
          v46 = HIDWORD(v107[0]);
          v51 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[3])(*a2, 503, HIDWORD(v107[0]), 0xFFFFFFFFLL);
          if (!(_DWORD)v51)
          {
            v49 = *((_WORD *)a2 + 52);
            goto LABEL_75;
          }
        }
        v31 = v51;
LABEL_84:
        v19 = v93;
        v53 = v97;
        v24 = v99;
LABEL_85:
        if (!(_DWORD)v31)
        {
          v54 = &v19[16 * v24 + v27];
          v56 = v54[48];
          v55 = v54 + 48;
          if (!v56)
LABEL_140:
            *v55 = v100;
          goto LABEL_141;
        }
LABEL_177:
        if (!(_DWORD)v31)
        {
LABEL_178:
          if (v89)
          {
            v80 = FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
            if ((_DWORD)v80)
              goto LABEL_196;
          }
          if (v88)
          {
            v80 = FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
            if ((_DWORD)v80)
              goto LABEL_196;
          }
          if (!v87)
          {
            v80 = FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
            if ((_DWORD)v80)
              goto LABEL_196;
            if (v85)
            {
              v80 = FigSignalErrorAt(4294954579, 0, 0, 0, 0, 0, 0);
              if ((_DWORD)v80)
                goto LABEL_196;
            }
          }
          if (++v94 > a3)
          {
            if (++v84 > a4)
            {
              v31 = 0;
              goto LABEL_197;
            }
            goto LABEL_12;
          }
          goto LABEL_13;
        }
LABEL_197:
        free(v19);
        return v31;
      case 1:
        v38 = &v19[16 * v24 + v27];
        if (!*v38)
        {
          v105 = 0;
LABEL_89:
          v98 = &v19[16 * v24 + v27];
          memset(v107, 0, 12);
          v57 = *((_WORD *)a2 + 52);
          v58 = hevcbridgeUPullLong(a1, 2, &v107[1]);
          v31 = v58;
          if ((v57 & 0x40) != 0 && !(_DWORD)v58)
            v31 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 505, LODWORD(v107[1]), 0xFFFFFFFFLL);
          if ((_DWORD)v31)
            goto LABEL_176;
          if (a12)
            *(_BYTE *)(v95 + 2700 * v99 + 180 * v27) = v107[1];
          if (!a5)
          {
            if ((a2[13] & 0x80) != 0)
            {
              v63 = hevcbridgeSEPullLong(a1, (unsigned int *)v107 + 1);
              if ((_DWORD)v63
                || (v59 = HIDWORD(v107[0]),
                    v63 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[3])(*a2, 506, HIDWORD(v107[0]), 0xFFFFFFFFLL), (_DWORD)v63))
              {
LABEL_175:
                v31 = v63;
LABEL_176:
                v19 = v93;
                goto LABEL_177;
              }
            }
            else
            {
              v59 = 0;
            }
            if (a12)
              *(_DWORD *)(v95 + 2700 * v99 + 180 * v27 + 4) = v59;
          }
          v64 = *((_WORD *)a2 + 52);
          v65 = hevcbridgeUPullLong(a1, v103, v107);
          v31 = v65;
          if ((v64 & 0x100) != 0 && !(_DWORD)v65)
            v31 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 507, LODWORD(v107[0]), 0xFFFFFFFFLL);
          if ((_DWORD)v31)
            goto LABEL_176;
          if (a12)
            *(_DWORD *)(v95 + 2700 * v99 + 180 * v27 + 8) = v107[0];
          if (LODWORD(v107[1]) != -1)
          {
            v92 = (LODWORD(v107[1]) + 2);
            v66 = v101;
            v67 = 1;
            do
            {
              for (i = 0; i != 28; i += 4)
              {
                v106 = 0;
                if (!a5)
                {
                  if ((a2[13] & 0x200) != 0)
                  {
                    v63 = hevcbridgeSEPullLong(a1, (unsigned int *)&v106 + 1);
                    if ((_DWORD)v63)
                      goto LABEL_175;
                    v69 = HIDWORD(v106);
                    v63 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[3])(*a2, 508, HIDWORD(v106), 0xFFFFFFFFLL);
                    if ((_DWORD)v63)
                      goto LABEL_175;
                  }
                  else
                  {
                    v69 = 0;
                  }
                  if (a12)
                    *(_DWORD *)(v66 + i + 448) = v69;
                }
                v70 = *((_WORD *)a2 + 52);
                v71 = hevcbridgeUPullLong(a1, v103, &v106);
                v31 = v71;
                if ((v70 & 0x400) != 0 && !(_DWORD)v71)
                  v31 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 509, v106, 0xFFFFFFFFLL);
                if (!a12 || (_DWORD)v31)
                {
                  if ((_DWORD)v31)
                    goto LABEL_176;
                }
                else
                {
                  *(_DWORD *)(v66 + i + 532) = v106;
                }
              }
              ++v67;
              v66 += 28;
            }
            while (v67 != v92);
          }
          v19 = v93;
          v24 = v99;
          v72 = (unint64_t)&v93[16 * v99 + v27];
          v73 = *(unsigned __int8 *)(v72 + 48);
          v55 = (_BYTE *)(v72 + 48);
          if (!v73)
          {
            v53 = v98;
            goto LABEL_140;
          }
          v53 = v98;
LABEL_141:
          v23 = 0;
          ++*v53;
          goto LABEL_142;
        }
        v34 = hevcbridgeUPullFlagAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 100) >> 1) & 1, 497, &v105);
        if ((_DWORD)v34)
          goto LABEL_190;
        v28 = v105;
        if (a12)
          *(_BYTE *)(a12 - v24 + 16 * v24 + v27 + 361) = v105;
        if (!(_DWORD)v28)
          goto LABEL_89;
        if (*v38 < 2u)
          goto LABEL_51;
        v39 = *((_BYTE *)a2 + 100);
        v40 = hevcbridgeUEPullLong(a1, (unsigned int *)&v104);
        v31 = v40;
        if ((v39 & 4) != 0 && !(_DWORD)v40)
          v31 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 498, v104, 0xFFFFFFFFLL);
        if ((_DWORD)v31)
          goto LABEL_177;
        v41 = v104;
        if (a12)
          *(_BYTE *)(a12 - v24 + 16 * v24 + v27 + 24984) = v104;
        v37 = v96 - v41;
        goto LABEL_52;
      case 2:
      case 3:
        v81 = 4294954579;
        goto LABEL_189;
      default:
        v37 = 0;
        v23 = 0;
        if (!(_DWORD)v28)
          goto LABEL_142;
        goto LABEL_52;
    }
  }
}

uint64_t hevcbridgeParseVdrDmDataPayload(uint64_t a1, _QWORD *a2, int a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  char v16;
  int v17;
  unsigned int v18;
  int v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  unsigned int v41;
  uint64_t v42;

  v42 = 0;
  v8 = *(_QWORD *)((char *)a2 + 92);
  result = hevcbridgeUEPullLong(a1, (unsigned int *)&v42);
  if ((v8 & 1) != 0 && !(_DWORD)result)
    result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 460, v42, 0xFFFFFFFFLL);
  if (!(_DWORD)result)
  {
    v41 = 0;
    v10 = *(_QWORD *)((char *)a2 + 92);
    result = hevcbridgeUEPullLong(a1, &v41);
    if ((v10 & 2) != 0 && !(_DWORD)result)
      result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 461, v41, 0xFFFFFFFFLL);
    if (!(_DWORD)result)
    {
      v40 = 0;
      v11 = *(_QWORD *)((char *)a2 + 92);
      result = hevcbridgeUEPullLong(a1, &v40);
      if ((v11 & 4) != 0 && !(_DWORD)result)
        result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 462, v40, 0xFFFFFFFFLL);
      if (!(_DWORD)result)
      {
        if (!a3)
        {
          v38 = 0;
          v39 = 0;
          v36 = 0;
          v37 = 0;
          v35 = 0;
          v34 = 0;
          v32 = 0;
          v33 = 0;
          v30 = 0;
          v31 = 0;
          v28 = 0;
          v29 = 0;
          v27 = 0;
          v14 = (*((unsigned __int8 *)a2 + 92) >> 3) & 1;
          v26 = 0;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, v14, 463, (int *)&v39 + 1, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 92) >> 4) & 1, 464, (int *)&v39, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 92) >> 5) & 1, 465, (int *)&v38 + 1, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 92) >> 6) & 1, 466, (int *)&v38, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, *((unsigned __int8 *)a2 + 92) >> 7, 467, (int *)&v37 + 1, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 8) & 1, 468, (int *)&v37, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 9) & 1, 469, (int *)&v36 + 1, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 10) & 1, 470, (int *)&v36, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 11) & 1, 471, &v35, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 12) & 1, 472, &v34, 32);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 13) & 1, 473, (_DWORD *)&v33 + 1, 32);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 14) & 1, 474, &v33, 32);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 15) & 1, 475, (int *)&v32 + 1, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, HIWORD(*((_DWORD *)a2 + 23)) & 1, 476, (int *)&v32, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 17) & 1, 477, (int *)&v31 + 1, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 18) & 1, 478, (int *)&v31, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 19) & 1, 479, (int *)&v30 + 1, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 20) & 1, 480, (int *)&v30, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 21) & 1, 481, (int *)&v29 + 1, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 22) & 1, 482, (int *)&v29, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeSPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 23) & 1, 483, (int *)&v28 + 1, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeUPullAlways(a1, (uint64_t)a2, HIBYTE(*((_DWORD *)a2 + 23)) & 1, 484, &v28, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 25) & 1, 485, (_DWORD *)&v27 + 1, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 26) & 1, 486, &v27, 16);
          if ((_DWORD)result)
            return result;
          result = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 27) & 1, 487, &v26, 32);
          if ((_DWORD)result)
            return result;
          v25 = 0;
          v23 = 0;
          v24 = 0;
          v22 = 0;
          v15 = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 28) & 1, 488, &v25, 5);
          if ((_DWORD)v15)
            return v15;
          v16 = v25;
          v15 = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 29) & 1, 489, (_DWORD *)&v24 + 1, 2);
          if ((_DWORD)v15)
            return v15;
          v15 = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*((_DWORD *)a2 + 23) >> 30) & 1, 490, &v24, 2);
          if ((_DWORD)v15)
            return v15;
          v15 = hevcbridgeUPullAlways(a1, (uint64_t)a2, *((_DWORD *)a2 + 23) >> 31, 491, (_DWORD *)&v23 + 1, 2);
          if ((_DWORD)v15)
            return v15;
          v15 = hevcbridgeUPullAlways(a1, (uint64_t)a2, a2[12] & 1, 492, &v23, 12);
          if ((_DWORD)v15)
            return v15;
          v15 = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 92) >> 33) & 1, 493, (_DWORD *)&v22 + 1, 12);
          if ((_DWORD)v15)
            return v15;
          v15 = hevcbridgeUPullAlways(a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 92) >> 34) & 1, 494, &v22, 10);
          if ((_DWORD)v15)
            return v15;
          if (a4)
          {
            *(_WORD *)(a4 + 29048) = WORD2(v39);
            *(_WORD *)(a4 + 29050) = v39;
            *(_WORD *)(a4 + 29052) = WORD2(v38);
            *(_WORD *)(a4 + 29054) = v38;
            *(_WORD *)(a4 + 29056) = WORD2(v37);
            *(_WORD *)(a4 + 29058) = v37;
            *(_WORD *)(a4 + 29060) = WORD2(v36);
            *(_WORD *)(a4 + 29062) = v36;
            *(_WORD *)(a4 + 29064) = v35;
            v19 = HIDWORD(v33);
            *(_DWORD *)(a4 + 29068) = v34;
            *(_DWORD *)(a4 + 29072) = v19;
            *(_DWORD *)(a4 + 29076) = v33;
            *(_WORD *)(a4 + 29080) = WORD2(v32);
            *(_WORD *)(a4 + 29082) = v32;
            *(_WORD *)(a4 + 29084) = WORD2(v31);
            *(_WORD *)(a4 + 29086) = v31;
            *(_WORD *)(a4 + 29088) = WORD2(v30);
            *(_WORD *)(a4 + 29090) = v30;
            *(_WORD *)(a4 + 29092) = WORD2(v29);
            *(_WORD *)(a4 + 29094) = v29;
            *(_WORD *)(a4 + 29096) = WORD2(v28);
            *(_WORD *)(a4 + 29098) = v28;
            *(_WORD *)(a4 + 29100) = WORD2(v27);
            *(_WORD *)(a4 + 29102) = v27;
            *(_DWORD *)(a4 + 29104) = v26;
            *(_BYTE *)(a4 + 29108) = v16;
            *(_BYTE *)(a4 + 29109) = BYTE4(v24);
            *(_BYTE *)(a4 + 29110) = v24;
            *(_BYTE *)(a4 + 29111) = BYTE4(v23);
            *(_WORD *)(a4 + 29112) = v23;
            *(_WORD *)(a4 + 29114) = WORD2(v22);
            *(_WORD *)(a4 + 29116) = v22;
          }
        }
        v12 = *(_QWORD *)((char *)a2 + 92);
        result = hevcbridgeUEPullLong(a1, (unsigned int *)&v42 + 1);
        if ((v12 & 0x800000000) != 0 && !(_DWORD)result)
          result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 495, HIDWORD(v42), 0xFFFFFFFFLL);
        if (!(_DWORD)result)
        {
          v13 = HIDWORD(v42);
          if (HIDWORD(v42) < 0xFF)
          {
            if (a4)
            {
              *(_BYTE *)(a4 + 29118) = BYTE4(v42);
              *(_BYTE *)(a4 + 29044) = v42;
              *(_BYTE *)(a4 + 29045) = v41;
              *(_BYTE *)(a4 + 29046) = v40;
            }
            v21 = 0;
            if (v13)
            {
              while (*(_DWORD *)(a1 + 76))
              {
                result = hevcbridgeUPullLong(a1, 1, &v21);
                if ((_DWORD)result)
                  return result;
                if (v21)
                {
LABEL_26:
                  FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
                  return 4294954582;
                }
              }
              v17 = v13;
              do
              {
                result = hevcbridgeParseVdrDmDataPayloadExMetadatatBlocks((_QWORD *)a1, a2, 1, a4);
                if ((_DWORD)result)
                  return result;
              }
              while (--v17);
            }
            result = 0;
            v20 = 0;
            if (*(_QWORD *)(a1 + 8) + *(_QWORD *)a1 - *(_QWORD *)(a1 + 56) < 6uLL)
              return result;
            result = hevcbridgeUEPullAlways(a1, (uint64_t)a2, *((_BYTE *)a2 + 124) & 1, 591, &v20);
            if ((_DWORD)result)
              return result;
            v18 = v20;
            if (v20 < 0xFF)
            {
              if (!v20)
                return 0;
              while (*(_DWORD *)(a1 + 76))
              {
                result = hevcbridgeUPullLong(a1, 1, &v21);
                if ((_DWORD)result)
                  return result;
                if (v21)
                  goto LABEL_26;
              }
              if (v18 + v13 <= 0xFF)
              {
                do
                {
                  result = hevcbridgeParseVdrDmDataPayloadExMetadatatBlocks((_QWORD *)a1, a2, 2, a4);
                  if ((_DWORD)result)
                    break;
                  --v18;
                }
                while (v18);
                return result;
              }
            }
          }
          return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
        }
      }
    }
  }
  return result;
}

uint64_t hevcbridgeSPullAlways(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int *a5, int a6)
{
  char v10;
  int v11;
  unsigned int v12;
  uint64_t result;
  int v14;

  if (*(_BYTE *)(a1 + 41))
  {
    result = FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
    v14 = 0;
  }
  else
  {
    v10 = a6;
    v11 = *(_DWORD *)(a1 + 80);
    v12 = v11 >> -(char)a6;
    result = hevcbridgeAdvanceInBitstream(a1, a6);
    if (v11 >= 0)
      v14 = v12 & 0x7FFFFFF;
    else
      v14 = v12 | (-1 << v10);
  }
  *a5 = v14;
  if (a3)
  {
    if (!(_DWORD)result)
      return (*(uint64_t (**)(_QWORD, uint64_t))(a2 + 24))(*(_QWORD *)a2, a4);
  }
  return result;
}

uint64_t hevcbridgeParseVdrDmDataPayloadExMetadatatBlocks(_QWORD *a1, _QWORD *a2, int a3, uint64_t a4)
{
  char v7;
  uint64_t result;
  char v9;
  char v10;
  char v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  _WORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int16 v43;
  __int16 v44;
  int v45;
  _WORD *v46;
  _BYTE *v47;
  _BYTE *v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;

  if (a3 == 1)
  {
    v55 = 0;
    v7 = *((_BYTE *)a2 + 120);
    result = hevcbridgeUEPullLong((uint64_t)a1, (unsigned int *)&v55 + 1);
    if ((v7 & 1) != 0 && !(_DWORD)result)
      result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 512, HIDWORD(v55), 0xFFFFFFFFLL);
    if ((_DWORD)result)
      return result;
    v9 = *((_BYTE *)a2 + 120);
    result = hevcbridgeUPullLong((uint64_t)a1, 8, &v55);
    if ((v9 & 2) != 0 && !(_DWORD)result)
      result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 513, v55, 0xFFFFFFFFLL);
  }
  else
  {
    v55 = 0;
    v10 = *((_BYTE *)a2 + 124);
    result = hevcbridgeUEPullLong((uint64_t)a1, (unsigned int *)&v55 + 1);
    if ((v10 & 2) != 0 && !(_DWORD)result)
      result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 592, HIDWORD(v55), 0xFFFFFFFFLL);
    if ((_DWORD)result)
      return result;
    v11 = *((_BYTE *)a2 + 124);
    result = hevcbridgeUPullLong((uint64_t)a1, 8, &v55);
    if ((v11 & 4) != 0 && !(_DWORD)result)
      result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 593, v55, 0xFFFFFFFFLL);
  }
  if ((_DWORD)result)
    return result;
  v12 = HIDWORD(v55);
  if (HIDWORD(v55) >= 0x101 || v55 >= 0x100 || a1[1] + *a1 - a1[7] < (unint64_t)HIDWORD(v55))
    return FigSignalErrorAt(4294954584, 0, 0, 0, 0, 0, 0);
  v13 = 0;
  switch((int)v55)
  {
    case 1:
      v55 = 0;
      HIDWORD(v54) = 0;
      v14 = *(_QWORD *)((char *)a2 + 108);
      result = hevcbridgeUPullLong((uint64_t)a1, 12, (_DWORD *)&v55 + 1);
      if ((v14 & 1) != 0 && !(_DWORD)result)
        result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 514, HIDWORD(v55), 0xFFFFFFFFLL);
      if (!(_DWORD)result)
      {
        v15 = *(_QWORD *)((char *)a2 + 108);
        result = hevcbridgeUPullLong((uint64_t)a1, 12, &v55);
        if ((v15 & 2) != 0 && !(_DWORD)result)
          result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 515, v55, 0xFFFFFFFFLL);
        if (!(_DWORD)result)
        {
          v16 = *(_QWORD *)((char *)a2 + 108);
          result = hevcbridgeUPullLong((uint64_t)a1, 12, (_DWORD *)&v54 + 1);
          if ((v16 & 4) != 0 && !(_DWORD)result)
            result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 516, HIDWORD(v54), 0xFFFFFFFFLL);
          if (!(_DWORD)result)
          {
            if (a4)
            {
              *(_BYTE *)(a4 + 29120) = 1;
              *(_WORD *)(a4 + 29132) = WORD2(v55);
              *(_WORD *)(a4 + 29134) = v55;
              *(_WORD *)(a4 + 29136) = WORD2(v54);
            }
            goto LABEL_115;
          }
        }
      }
      return result;
    case 2:
      v54 = 0;
      v55 = 0;
      v53 = 0;
      HIDWORD(v52) = 0;
      if (a4)
        ++*(_DWORD *)(a4 + 29140);
      v26 = *(_QWORD *)((char *)a2 + 108);
      result = hevcbridgeUPullLong((uint64_t)a1, 12, (_DWORD *)&v55 + 1);
      if ((v26 & 8) != 0 && !(_DWORD)result)
        result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 517, HIDWORD(v55), 0xFFFFFFFFLL);
      if (!(_DWORD)result)
      {
        v27 = *(_QWORD *)((char *)a2 + 108);
        result = hevcbridgeUPullLong((uint64_t)a1, 12, &v55);
        if ((v27 & 0x10) != 0 && !(_DWORD)result)
          result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 518, v55, 0xFFFFFFFFLL);
        if (!(_DWORD)result)
        {
          v28 = *(_QWORD *)((char *)a2 + 108);
          result = hevcbridgeUPullLong((uint64_t)a1, 12, (_DWORD *)&v54 + 1);
          if ((v28 & 0x20) != 0 && !(_DWORD)result)
            result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 519, HIDWORD(v54), 0xFFFFFFFFLL);
          if (!(_DWORD)result)
          {
            result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((unsigned __int8 *)a2 + 108) >> 6) & 1, 520, &v54, 12);
            if (!(_DWORD)result)
            {
              result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, *((unsigned __int8 *)a2 + 108) >> 7, 521, (_DWORD *)&v53 + 1, 12);
              if (!(_DWORD)result)
              {
                result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 27) >> 8) & 1, 522, &v53, 12);
                if (!(_DWORD)result)
                {
                  result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 27) >> 9) & 1, 523, (int *)&v52 + 1, 13);
                  if (!(_DWORD)result)
                  {
                    if (a4)
                    {
                      v29 = *(_DWORD *)(a4 + 29140);
                      *(_BYTE *)(a4 + 29121) = 1;
                      v30 = (_WORD *)(a4 + 14 * (int)(v29 - 1) + 29144);
                      *v30 = WORD2(v55);
                      v30[1] = v55;
                      v30[2] = WORD2(v54);
                      v30[3] = v54;
                      v30[4] = WORD2(v53);
                      v30[5] = v53;
                      v30[6] = WORD2(v52);
                      if (v29 >= 8)
                        v29 = 8;
                      *(_DWORD *)(a4 + 29140) = v29;
                    }
                    v13 = 85;
                    goto LABEL_194;
                  }
                }
              }
            }
          }
        }
      }
      return result;
    case 3:
      v55 = 0;
      HIDWORD(v54) = 0;
      v31 = *(_QWORD *)((char *)a2 + 108);
      result = hevcbridgeUPullLong((uint64_t)a1, 12, (_DWORD *)&v55 + 1);
      if ((v31 & 0x400) != 0 && !(_DWORD)result)
        result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 524, HIDWORD(v55), 0xFFFFFFFFLL);
      if (!(_DWORD)result)
      {
        v32 = *(_QWORD *)((char *)a2 + 108);
        result = hevcbridgeUPullLong((uint64_t)a1, 12, &v55);
        if ((v32 & 0x800) != 0 && !(_DWORD)result)
          result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 525, v55, 0xFFFFFFFFLL);
        if (!(_DWORD)result)
        {
          v33 = *(_QWORD *)((char *)a2 + 108);
          result = hevcbridgeUPullLong((uint64_t)a1, 12, (_DWORD *)&v54 + 1);
          if ((v33 & 0x1000) != 0 && !(_DWORD)result)
            result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 526, HIDWORD(v54), 0xFFFFFFFFLL);
          if (!(_DWORD)result)
          {
            if (a4)
            {
              *(_BYTE *)(a4 + 29122) = 1;
              *(_WORD *)(a4 + 29256) = WORD2(v55);
              *(_WORD *)(a4 + 29258) = v55;
              *(_WORD *)(a4 + 29260) = WORD2(v54);
            }
LABEL_115:
            v13 = 36;
            goto LABEL_194;
          }
        }
      }
      return result;
    case 4:
      v55 = 0;
      v24 = *(_QWORD *)((char *)a2 + 108);
      result = hevcbridgeUPullLong((uint64_t)a1, 12, (_DWORD *)&v55 + 1);
      if ((v24 & 0x2000) != 0 && !(_DWORD)result)
        result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 527, HIDWORD(v55), 0xFFFFFFFFLL);
      if (!(_DWORD)result)
      {
        v25 = *(_QWORD *)((char *)a2 + 108);
        result = hevcbridgeUPullLong((uint64_t)a1, 12, &v55);
        if ((v25 & 0x4000) != 0 && !(_DWORD)result)
          result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 528, v55, 0xFFFFFFFFLL);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            *(_BYTE *)(a4 + 29123) = 1;
            *(_WORD *)(a4 + 29262) = WORD2(v55);
            *(_WORD *)(a4 + 29264) = v55;
          }
          v13 = 24;
          goto LABEL_194;
        }
      }
      return result;
    case 5:
      v54 = 0;
      v55 = 0;
      v34 = *(_QWORD *)((char *)a2 + 108);
      result = hevcbridgeUPullLong((uint64_t)a1, 13, (_DWORD *)&v55 + 1);
      if ((v34 & 0x8000) != 0 && !(_DWORD)result)
        result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 529, HIDWORD(v55), 0xFFFFFFFFLL);
      if (!(_DWORD)result)
      {
        v35 = *(_QWORD *)((char *)a2 + 108);
        result = hevcbridgeUPullLong((uint64_t)a1, 13, &v55);
        if ((v35 & 0x10000) != 0 && !(_DWORD)result)
          result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 530, v55, 0xFFFFFFFFLL);
        if (!(_DWORD)result)
        {
          v36 = *(_QWORD *)((char *)a2 + 108);
          result = hevcbridgeUPullLong((uint64_t)a1, 13, (_DWORD *)&v54 + 1);
          if ((v36 & 0x20000) != 0 && !(_DWORD)result)
            result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 531, HIDWORD(v54), 0xFFFFFFFFLL);
          if (!(_DWORD)result)
          {
            result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 27) >> 18) & 1, 532, &v54, 13);
            if (!(_DWORD)result)
            {
              if (a4)
              {
                *(_BYTE *)(a4 + 29124) = 1;
                *(_WORD *)(a4 + 29266) = WORD2(v55);
                *(_WORD *)(a4 + 29268) = v55;
                *(_WORD *)(a4 + 29270) = WORD2(v54);
                *(_WORD *)(a4 + 29272) = v54;
              }
              v13 = 52;
              goto LABEL_194;
            }
          }
        }
      }
      return result;
    case 6:
      v54 = 0;
      v55 = 0;
      v41 = *(_QWORD *)((char *)a2 + 108);
      result = hevcbridgeUPullLong((uint64_t)a1, 16, (_DWORD *)&v55 + 1);
      if ((v41 & 0x80000) != 0 && !(_DWORD)result)
        result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 533, HIDWORD(v55), 0xFFFFFFFFLL);
      if (!(_DWORD)result)
      {
        v42 = *(_QWORD *)((char *)a2 + 108);
        result = hevcbridgeUPullLong((uint64_t)a1, 16, &v55);
        if ((v42 & 0x100000) != 0 && !(_DWORD)result)
          result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 534, v55, 0xFFFFFFFFLL);
        if (!(_DWORD)result)
        {
          result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 27) >> 21) & 1, 535, (_DWORD *)&v54 + 1, 16);
          if (!(_DWORD)result)
          {
            result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 27) >> 22) & 1, 536, &v54, 16);
            if (!(_DWORD)result)
            {
              if (a4)
              {
                *(_BYTE *)(a4 + 29125) = 1;
                *(_WORD *)(a4 + 29274) = WORD2(v55);
                *(_WORD *)(a4 + 29276) = v55;
                *(_WORD *)(a4 + 29278) = WORD2(v54);
                *(_WORD *)(a4 + 29280) = v54;
              }
              v13 = 64;
              goto LABEL_194;
            }
          }
        }
      }
      return result;
    case 7:
      goto LABEL_194;
    case 8:
      v54 = 0;
      v55 = 0;
      v53 = 0;
      HIDWORD(v52) = 0;
      v37 = *(_QWORD *)((char *)a2 + 108);
      result = hevcbridgeUPullLong((uint64_t)a1, 8, (_DWORD *)&v55 + 1);
      if ((v37 & 0x800000) != 0 && !(_DWORD)result)
        result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 537, HIDWORD(v55), 0xFFFFFFFFLL);
      if ((_DWORD)result)
        return result;
      v38 = *(_QWORD *)((char *)a2 + 108);
      result = hevcbridgeUPullLong((uint64_t)a1, 12, &v55);
      if ((v38 & 0x1000000) != 0 && !(_DWORD)result)
        result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 538, v55, 0xFFFFFFFFLL);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 27) >> 25) & 1, 539, (_DWORD *)&v54 + 1, 12);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 27) >> 26) & 1, 540, &v54, 12);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 27) >> 27) & 1, 541, (_DWORD *)&v53 + 1, 12);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 27) >> 28) & 1, 542, &v53, 12);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 27) >> 29) & 1, 543, (_DWORD *)&v52 + 1, 12);
      if ((_DWORD)result)
        return result;
      if (a4)
      {
        *(_BYTE *)(a4 + 29126) = 1;
        v39 = *(_DWORD *)(a4 + 29284);
        v40 = a4 + 36 * v39 + 29288;
        *(_BYTE *)(v40 + 4) = BYTE4(v55);
        *(_WORD *)(v40 + 6) = v55;
        *(_WORD *)(v40 + 8) = WORD2(v54);
        *(_WORD *)(v40 + 10) = v54;
        *(_WORD *)(v40 + 12) = WORD2(v53);
        *(_WORD *)(v40 + 14) = v53;
        *(_WORD *)(v40 + 16) = WORD2(v52);
        *(_DWORD *)v40 = v12;
        if (v39 <= 4)
          *(_DWORD *)(a4 + 29284) = v39 + 1;
      }
      else
      {
        v39 = 0;
      }
      if (v12 < 0xB)
      {
        v13 = 80;
        goto LABEL_194;
      }
      LODWORD(v52) = 0;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((_DWORD *)a2 + 27) >> 30) & 1, 544, &v52, 12);
      if ((_DWORD)result)
        return result;
      if (a4)
        *(_WORD *)(a4 + 36 * v39 + 29306) = v52;
      if (v12 < 0xD)
      {
        v13 = 92;
        goto LABEL_194;
      }
      LODWORD(v52) = 0;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, *((_DWORD *)a2 + 27) >> 31, 545, &v52, 12);
      if ((_DWORD)result)
        return result;
      if (a4)
        *(_WORD *)(a4 + 36 * v39 + 29308) = v52;
      if (v12 < 0xE)
      {
        v13 = 104;
        goto LABEL_194;
      }
      LODWORD(v52) = 0;
      v50 = 0;
      v51 = 0;
      v49 = 0;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, a2[14] & 1, 546, &v52, 8);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 33) & 1, 547, (_DWORD *)&v51 + 1, 8);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 34) & 1, 548, &v51, 8);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 35) & 1, 549, (_DWORD *)&v50 + 1, 8);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 36) & 1, 550, &v50, 8);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 37) & 1, 551, &v49, 8);
      if ((_DWORD)result)
        return result;
      if (a4)
      {
        v47 = (_BYTE *)(a4 + 36 * v39 + 29288);
        v47[22] = v52;
        v47[23] = BYTE4(v51);
        v47[24] = v51;
        v47[25] = BYTE4(v50);
        v47[26] = v50;
        v47[27] = v49;
      }
      if (v12 < 0x14)
      {
        v13 = 152;
        goto LABEL_194;
      }
      LODWORD(v52) = 0;
      v50 = 0;
      v51 = 0;
      v49 = 0;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 38) & 1, 552, &v52, 8);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 39) & 1, 553, (_DWORD *)&v51 + 1, 8);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, *(_DWORD *)((_BYTE *)a2 + 113) & 1, 554, &v51, 8);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 41) & 1, 555, (_DWORD *)&v50 + 1, 8);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 42) & 1, 556, &v50, 8);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 43) & 1, 557, &v49, 8);
      if ((_DWORD)result)
        return result;
      if (a4)
      {
        v48 = (_BYTE *)(a4 + 36 * v39 + 29288);
        v48[28] = v52;
        v48[29] = BYTE4(v51);
        v48[30] = v51;
        v48[31] = BYTE4(v50);
        v48[32] = v50;
        v48[33] = v49;
      }
      v13 = 200;
      goto LABEL_194;
    case 9:
      HIDWORD(v55) = 0;
      v18 = *(_QWORD *)((char *)a2 + 108);
      result = hevcbridgeUPullLong((uint64_t)a1, 8, (_DWORD *)&v55 + 1);
      if ((v18 & 0x100000000000) != 0 && !(_DWORD)result)
        result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 558, HIDWORD(v55), 0xFFFFFFFFLL);
      if ((_DWORD)result)
        return result;
      if (a4)
      {
        *(_BYTE *)(a4 + 29127) = 1;
        v19 = HIDWORD(v55);
        *(_BYTE *)(a4 + 29468) = BYTE4(v55);
      }
      else
      {
        v19 = HIDWORD(v55);
      }
      if (v19 < 0x13)
      {
        v13 = 8;
        goto LABEL_194;
      }
      LODWORD(v55) = 0;
      v53 = 0;
      v54 = 0;
      v52 = 0;
      HIDWORD(v51) = 0;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 45) & 1, 559, (int *)&v55, 16);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 46) & 1, 560, (int *)&v54 + 1, 16);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 47) & 1, 561, (int *)&v54, 16);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, *(_DWORD *)((_BYTE *)a2 + 114) & 1, 562, (int *)&v53 + 1, 16);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 49) & 1, 563, (int *)&v53, 16);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 50) & 1, 564, (int *)&v52 + 1, 16);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 51) & 1, 565, (int *)&v52, 16);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 52) & 1, 566, (int *)&v51 + 1, 16);
      if ((_DWORD)result)
        return result;
      if (a4)
      {
        *(_WORD *)(a4 + 29470) = v55;
        *(_WORD *)(a4 + 29472) = WORD2(v54);
        *(_WORD *)(a4 + 29474) = v54;
        *(_WORD *)(a4 + 29476) = WORD2(v53);
        *(_WORD *)(a4 + 29478) = v53;
        *(_WORD *)(a4 + 29480) = WORD2(v52);
        *(_WORD *)(a4 + 29482) = v52;
        *(_WORD *)(a4 + 29484) = WORD2(v51);
      }
      v13 = 136;
      goto LABEL_194;
    case 10:
      v54 = 0;
      v55 = 0;
      v20 = *(_QWORD *)((char *)a2 + 108);
      result = hevcbridgeUPullLong((uint64_t)a1, 8, (_DWORD *)&v55 + 1);
      if ((v20 & 0x20000000000000) != 0 && !(_DWORD)result)
        result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 567, HIDWORD(v55), 0xFFFFFFFFLL);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 54) & 1, 568, &v55, 12);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) >> 55) & 1, 569, (_DWORD *)&v54 + 1, 12);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, *((_BYTE *)a2 + 115) & 1, 570, &v54, 8);
      if ((_DWORD)result)
        return result;
      if (a4)
      {
        *(_BYTE *)(a4 + 29128) = 1;
        v21 = *(_DWORD *)(a4 + 29488);
        if (v21 <= 3)
          *(_DWORD *)(a4 + 29488) = v21 + 1;
        v22 = a4 + 28 * v21 + 29492;
        *(_BYTE *)(v22 + 4) = BYTE4(v55);
        *(_WORD *)(v22 + 6) = v55;
        *(_WORD *)(v22 + 8) = WORD2(v54);
        v23 = v54;
        *(_BYTE *)(v22 + 10) = v54;
      }
      else
      {
        v21 = 0;
        v23 = v54;
      }
      if (v23 < 0x13)
      {
        v13 = 40;
        goto LABEL_194;
      }
      v52 = 0;
      v53 = 0;
      v50 = 0;
      v51 = 0;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) & 0x200000000000000) != 0, 571, (int *)&v53 + 1, 16);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) & 0x400000000000000) != 0, 572, (int *)&v53, 16);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) & 0x800000000000000) != 0, 573, (int *)&v52 + 1, 16);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) & 0x1000000000000000) != 0, 574, (int *)&v52, 16);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) & 0x2000000000000000) != 0, 575, (int *)&v51 + 1, 16);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, (*(_QWORD *)((char *)a2 + 108) & 0x4000000000000000) != 0, 576, (int *)&v51, 16);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, *(_QWORD *)((char *)a2 + 108) >> 63, 577, (int *)&v50 + 1, 16);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeSPullAlways((uint64_t)a1, (uint64_t)a2, *((_WORD *)a2 + 58) & 1, 578, (int *)&v50, 16);
      if ((_DWORD)result)
        return result;
      if (a4)
      {
        v46 = (_WORD *)(a4 + 28 * v21 + 29492);
        v46[6] = WORD2(v53);
        v46[7] = v53;
        v46[8] = WORD2(v52);
        v46[9] = v52;
        v46[10] = WORD2(v51);
        v46[11] = v51;
        v46[12] = WORD2(v50);
        v46[13] = v50;
      }
      v13 = 168;
      goto LABEL_194;
    case 11:
      v54 = 0;
      v55 = 0;
      v43 = *((_WORD *)a2 + 58);
      result = hevcbridgeUPullLong((uint64_t)a1, 8, (_DWORD *)&v55 + 1);
      if ((v43 & 2) != 0 && !(_DWORD)result)
        result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 579, HIDWORD(v55), 0xFFFFFFFFLL);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((unsigned __int16 *)a2 + 58) >> 2) & 1, 580, &v55, 8);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((unsigned __int16 *)a2 + 58) >> 3) & 1, 581, (_DWORD *)&v54 + 1, 8);
      if ((_DWORD)result)
        return result;
      result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((unsigned __int16 *)a2 + 58) >> 4) & 1, 582, &v54, 8);
      if ((_DWORD)result)
        return result;
      if (a4)
      {
        *(_BYTE *)(a4 + 29129) = 1;
        *(_BYTE *)(a4 + 29604) = BYTE4(v55);
        *(_BYTE *)(a4 + 29605) = v55;
        *(_BYTE *)(a4 + 29606) = BYTE4(v54);
        *(_BYTE *)(a4 + 29607) = v54;
      }
      v13 = 32;
      goto LABEL_194;
    default:
      if ((_DWORD)v55 == 254)
      {
        v55 = 0;
        v44 = *((_WORD *)a2 + 58);
        result = hevcbridgeUPullLong((uint64_t)a1, 8, (_DWORD *)&v55 + 1);
        if ((v44 & 0x20) != 0 && !(_DWORD)result)
          result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 583, HIDWORD(v55), 0xFFFFFFFFLL);
        if (!(_DWORD)result)
        {
          result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((unsigned __int16 *)a2 + 58) >> 6) & 1, 584, &v55, 8);
          if (!(_DWORD)result)
          {
            if (a4)
            {
              *(_BYTE *)(a4 + 29130) = 1;
              *(_BYTE *)(a4 + 29608) = BYTE4(v55);
              v45 = v55;
              *(_BYTE *)(a4 + 29609) = v55;
              if (v45 == 2)
                *(_BYTE *)(a4 + 4) = 1;
            }
            v13 = 16;
            goto LABEL_194;
          }
        }
      }
      else
      {
        if ((_DWORD)v55 != 255)
        {
LABEL_194:
          if (8 * v12 <= v13)
            return 0;
          else
            return hevcbridgeUSkip((uint64_t)a1, 8 * v12 - v13);
        }
        v54 = 0;
        v55 = 0;
        v53 = 0;
        v17 = *((_WORD *)a2 + 58);
        result = hevcbridgeUPullLong((uint64_t)a1, 8, (_DWORD *)&v55 + 1);
        if ((v17 & 0x80) != 0 && !(_DWORD)result)
          result = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, uint64_t))a2[2])(*a2, 585, HIDWORD(v55), 0xFFFFFFFFLL);
        if (!(_DWORD)result)
        {
          result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, *((_BYTE *)a2 + 117) & 1, 586, &v55, 8);
          if (!(_DWORD)result)
          {
            result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((unsigned __int16 *)a2 + 58) >> 9) & 1, 587, (_DWORD *)&v54 + 1, 8);
            if (!(_DWORD)result)
            {
              result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((unsigned __int16 *)a2 + 58) >> 10) & 1, 588, &v54, 8);
              if (!(_DWORD)result)
              {
                result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((unsigned __int16 *)a2 + 58) >> 11) & 1, 589, (_DWORD *)&v53 + 1, 8);
                if (!(_DWORD)result)
                {
                  result = hevcbridgeUPullAlways((uint64_t)a1, (uint64_t)a2, (*((unsigned __int16 *)a2 + 58) >> 12) & 1, 590, &v53, 8);
                  if (!(_DWORD)result)
                  {
                    if (a4)
                    {
                      *(_BYTE *)(a4 + 29131) = 1;
                      *(_BYTE *)(a4 + 29610) = BYTE4(v55);
                      *(_BYTE *)(a4 + 29611) = v55;
                      *(_BYTE *)(a4 + 29612) = BYTE4(v54);
                      *(_BYTE *)(a4 + 29613) = v54;
                      *(_BYTE *)(a4 + 29614) = BYTE4(v53);
                      *(_BYTE *)(a4 + 29615) = v53;
                    }
                    v13 = 48;
                    goto LABEL_194;
                  }
                }
              }
            }
          }
        }
      }
      break;
  }
  return result;
}

uint64_t hevcbridgeSEPush(uint64_t a1, int a2)
{
  _BOOL4 v3;
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  uint64_t result;

  if (*(_BYTE *)(a1 + 41))
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  v3 = a2 < 1;
  if (a2 >= 0)
    v4 = a2;
  else
    v4 = -a2;
  v5 = 0;
  if (a2)
  {
    v6 = v4;
    do
    {
      v7 = v5++;
      if (v7 > 0x1D)
        break;
      v8 = v6 > 1;
      v6 >>= 1;
    }
    while (v8);
  }
  result = hevcbridgeUPush((uint64_t *)a1, v5 + 1, 1);
  if (v5)
  {
    if (!(_DWORD)result)
      return hevcbridgeUPush((uint64_t *)a1, v5, (((2 * v4) | v3) - (1 << v5)) & ((1 << v5) - 1));
  }
  return result;
}

uint64_t hevcbridgeIPush(uint64_t a1, char a2, int a3)
{
  if (*(_BYTE *)(a1 + 41) || 1 << (a2 - 1) <= a3 || -1 << (a2 - 1) > a3)
    return FigSignalErrorAt(4294954582, 0, 0, 0, 0, 0, 0);
  else
    return hevcbridgeUPush((uint64_t *)a1, a2, a3 & ~(-1 << a2));
}

uint64_t hevcBridgeAlignToByte(uint64_t result)
{
  uint64_t v1;

  if (*(_DWORD *)(result + 76))
  {
    v1 = result;
    do
      result = hevcbridgeUPush((uint64_t *)v1, 1, 0);
    while (!(_DWORD)result && *(_DWORD *)(v1 + 76));
  }
  return result;
}

CC_MD5_CTX *FigDigestMD5Create()
{
  CC_MD5_CTX *v0;
  CC_MD5_CTX *v1;

  v0 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x100004034A301B9uLL);
  v1 = v0;
  if (v0)
    CC_MD5_Init(v0);
  return v1;
}

uint64_t FigDigestMD5GetDigest(CC_MD5_CTX *c, unsigned __int8 *md)
{
  return CC_MD5_Final(md, c);
}

CC_SHA1_CTX *FigDigestSHA1Create()
{
  CC_SHA1_CTX *v0;
  CC_SHA1_CTX *v1;

  v0 = (CC_SHA1_CTX *)malloc_type_malloc(0x60uLL, 0x1000040565EDBD2uLL);
  v1 = v0;
  if (v0)
    CC_SHA1_Init(v0);
  return v1;
}

uint64_t FigDigestSHA1GetDigest(CC_SHA1_CTX *c, unsigned __int8 *md)
{
  return CC_SHA1_Final(md, c);
}

uint64_t FigOSEventLinkRemoteCreateFromXPCObject(int a1, void *a2, const void *a3, const void *a4, uint64_t *a5)
{
  const void *v6;
  xpc_object_t value;
  uint64_t Instance;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFTypeRef cf;

  v21 = 0;
  cf = 0;
  if (!a2)
  {
    v19 = 4294947875;
    goto LABEL_26;
  }
  if (!a3)
    goto LABEL_21;
  v6 = a4;
  if (!a4)
  {
    v17 = FigSignalErrorAt(4294947875, 0, 0, 0, 0, 0, 0);
    goto LABEL_15;
  }
  if (MEMORY[0x193FFCDCC](a2) != MEMORY[0x1E0C812F8])
  {
LABEL_21:
    v19 = 4294947875;
LABEL_26:
    v17 = FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
    LODWORD(v6) = 0;
    goto LABEL_15;
  }
  value = xpc_dictionary_get_value(a2, "RemoteEventLinkCreationInfo");
  if (figOSEventLinkRemote_GetTypeID_sRegisterFigOSEventLinkRemoteTypeOnce != -1)
    dispatch_once(&figOSEventLinkRemote_GetTypeID_sRegisterFigOSEventLinkRemoteTypeOnce, &__block_literal_global_36);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v19 = 4294947876;
    goto LABEL_26;
  }
  v12 = Instance;
  v13 = FigXPCMessageCopyBlockBufferUsingMemoryRecipient((const __CFAllocator *)*MEMORY[0x1E0C9AE00], value, "BlockBuffer", (uint64_t)v6, (CMBlockBufferRef *)&cf);
  if ((_DWORD)v13
    || (v13 = figOSEventLinkMemoryObjects_createInternal(a1, a3, v6, (CMBlockBufferRef)cf, &v21), (_DWORD)v13))
  {
    v17 = v13;
    v15 = 0;
    LODWORD(v6) = 0;
    goto LABEL_31;
  }
  *(_QWORD *)(v12 + 16) = v21;
  LODWORD(v6) = xpc_dictionary_copy_mach_send();
  if (!(_DWORD)v6)
  {
    v20 = 4294947871;
LABEL_29:
    v17 = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
    v15 = 0;
    goto LABEL_31;
  }
  xpc_dictionary_get_string(value, "EventLinkIdentifier");
  v14 = os_eventlink_create_with_port();
  if (!v14)
  {
    v20 = 4294947873;
    goto LABEL_29;
  }
  v15 = (void *)v14;
  v16 = os_eventlink_activate();
  if ((_DWORD)v16)
  {
    v17 = v16;
  }
  else
  {
    v17 = os_eventlink_associate();
    if (!(_DWORD)v17)
    {
      *(_QWORD *)(v12 + 24) = v15;
      *(_QWORD *)(v12 + 32) = 0;
      *(_DWORD *)(v12 + 40) = 5;
      *a5 = v12;
LABEL_15:
      FigMachPortReleaseSendRight_((mach_port_name_t)v6, 0, 0, 0, 0);
      v15 = 0;
      goto LABEL_16;
    }
  }
LABEL_31:
  FigMachPortReleaseSendRight_((mach_port_name_t)v6, 0, 0, 0, 0);
  CFRelease((CFTypeRef)v12);
LABEL_16:
  if (cf)
    CFRelease(cf);
  if (v15)
    os_release(v15);
  return v17;
}

uint64_t figOSEventLinkMemoryObjects_createInternal(int a1, const void *a2, const void *a3, CMBlockBufferRef theBuffer, uint64_t *a5)
{
  size_t DataLength;
  size_t v10;
  uint64_t Instance;
  uint64_t v12;
  CFTypeRef v13;
  CFTypeRef v14;
  uint64_t v15;
  size_t v16;
  uint64_t v17;
  uint64_t v19;

  if (theBuffer)
  {
    DataLength = CMBlockBufferGetDataLength(theBuffer);
    if (DataLength % *MEMORY[0x1E0C85AD8])
    {
      v19 = 4294947875;
    }
    else
    {
      v10 = DataLength;
      if (figOSEventLinkMemoryObjects_GetTypeID_sRegisterFigOSEventLinkMemoryObjectsTypeOnce != -1)
        dispatch_once(&figOSEventLinkMemoryObjects_GetTypeID_sRegisterFigOSEventLinkMemoryObjectsTypeOnce, &__block_literal_global_10_0);
      Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        v12 = Instance;
        if (a2)
          v13 = CFRetain(a2);
        else
          v13 = 0;
        *(_QWORD *)(v12 + 16) = v13;
        if (a3)
          v14 = CFRetain(a3);
        else
          v14 = 0;
        *(_QWORD *)(v12 + 24) = v14;
        v15 = CMBlockBufferCreateWithBufferReference(0, theBuffer, 0, 0x20uLL, 0, (CMBlockBufferRef *)(v12 + 32));
        if ((_DWORD)v15
          || (v16 = (v10 - 32) >> 1,
              v15 = CMBlockBufferCreateWithBufferReference(0, theBuffer, 0x20uLL, v16, 0, (CMBlockBufferRef *)(v12 + 40)), (_DWORD)v15))
        {
          v17 = v15;
        }
        else
        {
          v17 = CMBlockBufferCreateWithBufferReference(0, theBuffer, v16 + 32, v16, 0, (CMBlockBufferRef *)(v12 + 48));
          if (!(_DWORD)v17)
          {
            *a5 = v12;
            return v17;
          }
        }
        CFRelease((CFTypeRef)v12);
        return v17;
      }
      v19 = 4294947876;
    }
  }
  else
  {
    v19 = 4294947875;
  }
  return FigSignalErrorAt(v19, 0, 0, 0, 0, 0, 0);
}

uint64_t FigOSEventLinkRemoteFillMessageBufferThenSendItAndHandleReply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DataPointer;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v12;
  unsigned __int8 v13;
  char *dataPointerOut;

  dataPointerOut = 0;
  v13 = 0;
  FigMemoryOriginBeginTransactionMakingRegistrationsContingentOnIt();
  if (*(_BYTE *)(a1 + 44))
  {
    v12 = 4294947867;
    goto LABEL_19;
  }
  DataPointer = CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(*(_QWORD *)(a1 + 16) + 32), 0, 0, 0, &dataPointerOut);
  if ((_DWORD)DataPointer)
    goto LABEL_20;
  DataPointer = (*(uint64_t (**)(uint64_t, _QWORD))(a2 + 16))(a2, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40));
  if ((_DWORD)DataPointer)
    goto LABEL_20;
  if (!FigAtomicCompareAndSwap32(0, 1u, (unsigned int *)dataPointerOut + 3))
    goto LABEL_17;
  *(_DWORD *)dataPointerOut = 1;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  *(_QWORD *)(dataPointerOut + 4) = *(_QWORD *)(a1 + 36);
  *(_QWORD *)(a1 + 36) = 0x500000000;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
  v7 = os_eventlink_signal_and_wait();
  if (v7 == 89)
    v8 = 4294947868;
  else
    v8 = v7;
  if ((_DWORD)v8)
    goto LABEL_21;
  v9 = figOSEventLinkResolveMessageStatus((unsigned int *)dataPointerOut + 3, &v13);
  v10 = v13;
  if ((_DWORD)v9)
  {
    v8 = v9;
    goto LABEL_16;
  }
  if (!v13)
  {
LABEL_17:
    v12 = 4294947872;
LABEL_19:
    DataPointer = FigSignalErrorAt(v12, 0, 0, 0, 0, 0, 0);
LABEL_20:
    v8 = DataPointer;
LABEL_21:
    v10 = 0;
    goto LABEL_16;
  }
  if (FigAtomicCompareAndSwap32(1, 2u, (unsigned int *)dataPointerOut + 5))
  {
    v8 = (*(uint64_t (**)(uint64_t, _QWORD))(a3 + 16))(a3, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48));
    if (!(_DWORD)v8)
      v8 = *((unsigned int *)dataPointerOut + 4);
    *((_DWORD *)dataPointerOut + 3) = 0;
  }
  else
  {
    v8 = FigSignalErrorAt(4294947872, 0, 0, 0, 0, 0, 0);
  }
  v10 = 1;
LABEL_16:
  FigMemoryOriginCompleteTransaction(v10 == 0);
  return v8;
}

uint64_t figOSEventLinkResolveMessageStatus(unsigned int *a1, _BYTE *a2)
{
  int v4;
  char v5;
  uint64_t result;

  while (1)
  {
    v4 = FigAtomicCompareAndSwap32(2, 2u, a1);
    v5 = v4;
    if (v4)
    {
LABEL_4:
      result = 0;
      goto LABEL_6;
    }
    if (*a1 - 1 >= 2)
      break;
    if (FigAtomicCompareAndSwap32(1, 3u, a1))
      goto LABEL_4;
  }
  result = FigSignalErrorAt(4294947872, 0, 0, 0, 0, 0, 0);
LABEL_6:
  *a2 = v5;
  return result;
}

uint64_t FigOSEventLinkRemoteInvalidate(uint64_t a1)
{
  if (!a1)
    return FigSignalErrorAt(4294947875, 0, 0, 0, 0, 0, 0);
  if (!*(_BYTE *)(a1 + 44))
  {
    *(_BYTE *)(a1 + 44) = 1;
    os_eventlink_cancel();
  }
  return 0;
}

uint64_t FigOSEventLinkRemoteSetMessageHandlingThreadMachThreadPriority(os_unfair_lock_s *a1, uint32_t a2)
{
  os_unfair_lock_s *v4;

  if (!a1 || a2 - 98 <= 0xFFFFFF9E)
    return FigSignalErrorAt(4294947875, 0, 0, 0, 0, 0, 0);
  v4 = a1 + 8;
  os_unfair_lock_lock(a1 + 8);
  a1[9]._os_unfair_lock_opaque = a2;
  a1[10]._os_unfair_lock_opaque = 5;
  os_unfair_lock_unlock(v4);
  return 0;
}

uint64_t FigOSEventLinkRemoteSetMessageHandlingThreadFigThreadPriority(os_unfair_lock_s *a1, unsigned int a2)
{
  os_unfair_lock_s *v4;

  if (!a1 || a2 == 5 || a2 >= 0x31)
    return FigSignalErrorAt(4294947875, 0, 0, 0, 0, 0, 0);
  v4 = a1 + 8;
  os_unfair_lock_lock(a1 + 8);
  a1[9]._os_unfair_lock_opaque = 0;
  a1[10]._os_unfair_lock_opaque = a2;
  os_unfair_lock_unlock(v4);
  return 0;
}

uint64_t FigOSEventLinkServerCreate(int a1, unsigned int a2, int a3, const __CFString *a4, uint64_t a5, const void *a6, const void *a7, const void *a8, _QWORD *a9)
{
  CFStringRef v11;
  uint64_t Instance;
  uint64_t v17;
  _QWORD *v18;
  uint64_t BlockBuffer;
  CFTypeRef v20;
  uint64_t v21;
  uint64_t v22;
  const __CFAllocator *v23;
  __CFDictionary *Mutable;
  uint64_t v25;
  uint64_t v27;
  uint64_t v28;
  CFTypeRef cf;
  pthread_t v30;

  cf = 0;
  v30 = 0;
  v28 = 0;
  if (!a7)
  {
    v27 = 4294947875;
    goto LABEL_28;
  }
  if (!a8 || !a6)
    goto LABEL_24;
  v11 = a4;
  if (!a4)
  {
    v25 = FigSignalErrorAt(4294947875, 0, 0, 0, 0, 0, 0);
    goto LABEL_19;
  }
  if (a2 == 5 && !a3)
  {
LABEL_24:
    v27 = 4294947875;
LABEL_28:
    v25 = FigSignalErrorAt(v27, 0, 0, 0, 0, 0, 0);
    v11 = 0;
    goto LABEL_19;
  }
  if (figOSEventLinkServer_GetTypeID_sRegisterFigOSEventLinkServerTypeOnce != -1)
    dispatch_once(&figOSEventLinkServer_GetTypeID_sRegisterFigOSEventLinkServerTypeOnce, &__block_literal_global_15_0);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v27 = 4294947876;
    goto LABEL_28;
  }
  v18 = (_QWORD *)Instance;
  BlockBuffer = (uint64_t)FigMemoryPoolCreateBlockBuffer((uint64_t)a6, *MEMORY[0x1E0C85AD8], (CMBlockBufferRef *)&cf, v17);
  if (!(_DWORD)BlockBuffer)
  {
    BlockBuffer = figOSEventLinkMemoryObjects_createInternal(a1, a7, a8, (CMBlockBufferRef)cf, &v28);
    if (!(_DWORD)BlockBuffer)
    {
      v18[3] = v28;
      v28 = 0;
      v20 = CFRetain(a6);
      v18[4] = cf;
      v18[5] = v20;
      cf = 0;
      v18[10] = CFRetain(v11);
      CFStringGetCStringPtr(v11, 0x8000100u);
      v21 = os_eventlink_create();
      if (v21)
      {
        v22 = v21;
        BlockBuffer = os_eventlink_activate();
        if (!(_DWORD)BlockBuffer)
        {
          v18[6] = v22;
          v23 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          v11 = CFStringCreateWithFormat(v23, 0, CFSTR("%@.%p"), v11, v22);
          CFDictionarySetValue(Mutable, CFSTR("com.apple.fig.ThreadCreateKey_Identifier"), v11);
          if (a3)
            FigCFDictionarySetInt32(Mutable, CFSTR("com.apple.fig.ThreadCreateKey_MachThreadPriority"), a3);
          v25 = FigThreadCreate((uint64_t)FigOSEventLinkServerMain, (uint64_t)v18, a2, 0, Mutable, &v30);
          if (!(_DWORD)v25)
          {
            CFRetain(v18);
            *a9 = v18;
            if (!Mutable)
              goto LABEL_19;
            goto LABEL_18;
          }
          goto LABEL_31;
        }
      }
      else
      {
        BlockBuffer = FigSignalErrorAt(4294947873, 0, 0, 0, 0, 0, 0);
      }
    }
  }
  v25 = BlockBuffer;
  Mutable = 0;
  v11 = 0;
LABEL_31:
  CFRelease(v18);
  if (Mutable)
LABEL_18:
    CFRelease(Mutable);
LABEL_19:
  if (cf)
    CFRelease(cf);
  if (v11)
    CFRelease(v11);
  return v25;
}

uint64_t FigOSEventLinkServerMain(_QWORD *a1)
{
  int v2;
  const __CFAllocator *v3;
  char *v4;
  int v5;
  int v6;
  const __CFNumber *UInt32;
  const void **v8;
  const void *v9;
  _opaque_pthread_t *Current;
  char *v11;
  char *v12;
  int v13;
  int v14;
  char *v15;
  int v16;
  int v17;
  char *v19;
  unsigned __int8 v20;

  v19 = 0;
  if (!os_eventlink_associate()
    && !os_eventlink_wait()
    && !CMBlockBufferGetDataPointer(*(CMBlockBufferRef *)(a1[3] + 32), 0, 0, 0, &v19))
  {
    v2 = 0;
    v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    while (1)
    {
      if (v2)
        goto LABEL_37;
      if (!a1[8])
      {
        FigSignalErrorAt(4294947871, 0, 0, 0, 0, 0, 0);
        goto LABEL_37;
      }
      v4 = v19;
      if (*(_DWORD *)v19 == 1)
        break;
      if (*(_DWORD *)v19)
      {
        v14 = 0;
LABEL_28:
        v2 = 0;
        if (v14)
          goto LABEL_37;
      }
      else
      {
        *((_DWORD *)v19 + 4) = 0;
        v5 = os_eventlink_signal();
        v2 = 1;
        if (v5)
          goto LABEL_37;
      }
    }
    if (FigAtomicCompareAndSwap32(1, 2u, (unsigned int *)v19 + 3))
    {
      v6 = *((_DWORD *)v4 + 1);
      if (v6 > 0)
        goto LABEL_13;
      if (*((_DWORD *)v4 + 2) != 5)
      {
        if (!v6)
        {
          UInt32 = FigCFNumberCreateUInt32(v3, *((_DWORD *)v4 + 2));
          v8 = (const void **)&kFigThreadPropertyKey_Priority;
          goto LABEL_14;
        }
LABEL_13:
        UInt32 = FigCFNumberCreateSInt32(v3, v6);
        v8 = (const void **)&kFigThreadPropertyKey_MachThreadPriority;
LABEL_14:
        v9 = *v8;
        Current = FigThreadGetCurrent();
        FigThreadSetProperty(Current, v9, UInt32);
        if (UInt32)
          CFRelease(UInt32);
        *(_QWORD *)(v4 + 4) = 0x500000000;
      }
    }
    else
    {
      FigSignalErrorAt(4294947872, 0, 0, 0, 0, 0, 0);
    }
    v11 = v19;
    FigMemoryOriginBeginTransactionMakingRegistrationsContingentOnIt();
    if (!FigAtomicCompareAndSwap32(0, 1u, (unsigned int *)v11 + 5))
      FigSignalErrorAt(4294947872, 0, 0, 0, 0, 0, 0);
    v12 = v19;
    if (*((_DWORD *)v19 + 3) == 2)
      v13 = ((uint64_t (*)(_QWORD *, _QWORD, _QWORD, _QWORD))a1[8])(a1, 0, *(_QWORD *)(a1[3] + 40), *(_QWORD *)(a1[3] + 48));
    else
      v13 = FigSignalErrorAt(4294947870, 0, 0, 0, 0, 0, 0);
    v14 = v13;
    *((_DWORD *)v12 + 4) = v13;
    if (!v13)
      v14 = os_eventlink_signal_and_wait();
    v20 = 0;
    v15 = v19 + 20;
    v16 = figOSEventLinkResolveMessageStatus((unsigned int *)v19 + 5, &v20);
    v17 = v20;
    if (!v16)
    {
      if (v20)
        *(_DWORD *)v15 = 0;
      else
        FigSignalErrorAt(4294947872, 0, 0, 0, 0, 0, 0);
    }
    FigMemoryOriginCompleteTransaction(v17 == 0);
    goto LABEL_28;
  }
LABEL_37:
  os_eventlink_cancel();
  CFRelease(a1);
  return 0;
}

uint64_t FigOSEventLinkServerCopyRemoteCreationInfoXPCObject(uint64_t a1, _QWORD *a2)
{
  xpc_object_t v4;
  uint64_t v5;
  const char *CStringPtr;
  uint64_t remote_port;

  v4 = xpc_dictionary_create(0, 0, 0);
  v5 = FigMemoryOriginSetBlockBufferInXPCMessage(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 16), v4, "BlockBuffer", *(OpaqueCMBlockBuffer **)(a1 + 32));
  if ((_DWORD)v5)
  {
    remote_port = v5;
  }
  else
  {
    CStringPtr = CFStringGetCStringPtr(*(CFStringRef *)(a1 + 80), 0x8000100u);
    xpc_dictionary_set_string(v4, "EventLinkIdentifier", CStringPtr);
    remote_port = os_eventlink_extract_remote_port();
    if (!(_DWORD)remote_port)
    {
      xpc_dictionary_set_mach_send();
      *a2 = v4;
      v4 = 0;
    }
  }
  FigMachPortReleaseSendRight_(0, 0, 0, 0, 0);
  FigXPCRelease(v4);
  return remote_port;
}

uint64_t FigOSEventLinkServerSetCallbacks(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  const void *v5;

  if (!a1)
    return FigSignalErrorAt(4294947875, 0, 0, 0, 0, 0, 0);
  *(_OWORD *)(a1 + 56) = *a3;
  v5 = *(const void **)(a1 + 72);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 72) = 0;
  }
  if (a2)
    *(_QWORD *)(a1 + 72) = FigCFWeakReferenceHolderCreateWithReferencedObject(a2);
  return 0;
}

uint64_t FigOSEventLinkServerSetAssociatedFigXPCServerXPCConnection(uint64_t a1, void *a2)
{
  uint64_t v3;

  if (a1)
  {
    if (a2)
    {
      if (!*(_QWORD *)(a1 + 16))
      {
        *(_QWORD *)(a1 + 16) = FigXPCRetain(a2);
        return 0;
      }
      v3 = 4294947872;
    }
    else
    {
      v3 = 4294947875;
    }
  }
  else
  {
    v3 = 4294947875;
  }
  return FigSignalErrorAt(v3, 0, 0, 0, 0, 0, 0);
}

uint64_t FigOSEventLinkServerGetAssociatedFigXPCServerXPCConnection(uint64_t a1)
{
  if (a1)
    return *(_QWORD *)(a1 + 16);
  FigSignalErrorAt(4294947875, 0, 0, 0, 0, 0, 0);
  return 0;
}

double figOSEventLinkRemote_Init(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void figOSEventLinkRemote_Finalize(uint64_t a1)
{
  uint64_t v2;
  OpaqueCMBlockBuffer *v3;
  const void *v4;
  void *v5;
  char *dataPointerOut;

  dataPointerOut = 0;
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 && (v3 = *(OpaqueCMBlockBuffer **)(v2 + 32)) != 0 && *(_QWORD *)(a1 + 24))
  {
    if (!CMBlockBufferGetDataPointer(v3, 0, 0, 0, &dataPointerOut))
    {
      *(_DWORD *)dataPointerOut = 0;
      os_eventlink_signal_and_wait();
    }
  }
  else
  {
    FigSignalErrorAt(4294947872, 0, 0, 0, 0, 0, 0);
  }
  v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 16) = 0;
  }
  if (*(_QWORD *)(a1 + 24))
  {
    os_eventlink_cancel();
    v5 = *(void **)(a1 + 24);
    if (v5)
    {
      os_release(v5);
      *(_QWORD *)(a1 + 24) = 0;
    }
  }
}

__CFString *figOSEventLinkRemote_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  OpaqueCMBlockBuffer *v3;
  size_t DataLength;
  OpaqueCMBlockBuffer *v5;
  size_t v6;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = *(OpaqueCMBlockBuffer **)(*(_QWORD *)(a1 + 16) + 40);
  DataLength = CMBlockBufferGetDataLength(v3);
  v5 = *(OpaqueCMBlockBuffer **)(*(_QWORD *)(a1 + 16) + 48);
  v6 = CMBlockBufferGetDataLength(v5);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigOSEventLinkRemote %p sharedMessageBBuf %p (size %zu) sharedReplyBBuf %p (size %zu)>"), a1, v3, DataLength, v5, v6);
  return Mutable;
}

double figOSEventLinkMemoryObjects_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void figOSEventLinkMemoryObjects_Finalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  v3 = (const void *)a1[3];
  if (v3)
  {
    CFRelease(v3);
    a1[3] = 0;
  }
  v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
    a1[4] = 0;
  }
  v5 = (const void *)a1[5];
  if (v5)
  {
    CFRelease(v5);
    a1[5] = 0;
  }
  v6 = (const void *)a1[6];
  if (v6)
  {
    CFRelease(v6);
    a1[6] = 0;
  }
}

__CFString *figOSEventLinkMemoryObjects_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  OpaqueCMBlockBuffer *v3;
  size_t DataLength;
  OpaqueCMBlockBuffer *v5;
  size_t v6;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = *(OpaqueCMBlockBuffer **)(a1 + 40);
  DataLength = CMBlockBufferGetDataLength(v3);
  v5 = *(OpaqueCMBlockBuffer **)(a1 + 48);
  v6 = CMBlockBufferGetDataLength(v5);
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigOSEventLinkMemoryObjects %p sharedMessageBBuf %p (size %zu) sharedReplyBBuf %p (size %zu)>"), a1, v3, DataLength, v5, v6);
  return Mutable;
}

double figOSEventLinkServer_Init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 80) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void figOSEventLinkServer_Finalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  void *v5;
  void *v6;
  const void *v7;
  const void *v8;

  v2 = (const void *)a1[5];
  if (v2)
  {
    CFRelease(v2);
    a1[5] = 0;
  }
  v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  v4 = (const void *)a1[3];
  if (v4)
  {
    CFRelease(v4);
    a1[3] = 0;
  }
  v5 = (void *)a1[6];
  if (v5)
  {
    os_release(v5);
    a1[6] = 0;
  }
  v6 = (void *)a1[2];
  if (v6)
  {
    os_release(v6);
    a1[2] = 0;
  }
  v7 = (const void *)a1[9];
  if (v7)
  {
    CFRelease(v7);
    a1[9] = 0;
  }
  v8 = (const void *)a1[10];
  if (v8)
  {
    CFRelease(v8);
    a1[10] = 0;
  }
}

__CFString *figOSEventLinkServer_CopyDebugDesc(uint64_t a1)
{
  __CFString *Mutable;
  OpaqueCMBlockBuffer *v3;
  size_t DataLength;
  uint64_t v5;
  uint64_t v6;
  size_t v7;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = *(OpaqueCMBlockBuffer **)(*(_QWORD *)(a1 + 24) + 40);
  DataLength = CMBlockBufferGetDataLength(v3);
  v5 = *(_QWORD *)(a1 + 24);
  v6 = *(_QWORD *)(v5 + 48);
  v7 = CMBlockBufferGetDataLength(*(CMBlockBufferRef *)(v5 + 40));
  CFStringAppendFormat(Mutable, 0, CFSTR("<FigOSEventLinkServer %p sharedMessageBBuf %p (size %zu) sharedReplyBBuf %p (size %zu)>"), a1, v3, DataLength, v6, v7);
  return Mutable;
}

uint64_t FigPreferAudioSessionOverCMSession()
{
  if (FigPreferAudioSessionOverCMSession_onceToken != -1)
    dispatch_once(&FigPreferAudioSessionOverCMSession_onceToken, &__block_literal_global_37);
  return 1;
}

uint64_t FigCaptionGroupFormatDescriptionRegister()
{
  return FigThreadRunOnce(&sFigCaptionGroupFormatDescriptionRegisterOnce, (void (*)(void))FigCaptionGroupFormatDescriptionRegisterOnce);
}

uint64_t FigCaptionGroupFormatDescriptionRegisterOnce()
{
  int v1;
  uint64_t v2;
  BOOL (*v3)(uint64_t, uint64_t);
  __CFString *(*v4)(const void *);
  uint64_t (*v5)();

  v1 = 0;
  v2 = 4;
  v4 = figCaptionGroupFormatDescriptionCopyDebugDesc;
  v5 = figCaptionGroupFormatDescriptionFinalize;
  v3 = figCaptionGroupFormatDescriptionEqual;
  return FigDerivedFormatDescriptionRegister(0x63706772u, (__int128 *)&v1);
}

uint64_t FigCaptionGroupFormatDescriptionCreate(const __CFAllocator *a1, int a2, CFTypeRef *a3)
{
  uint64_t v6;
  CFTypeRef cf;

  cf = 0;
  if (!a3)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  FigThreadRunOnce(&sFigCaptionGroupFormatDescriptionRegisterOnce, (void (*)(void))FigCaptionGroupFormatDescriptionRegisterOnce);
  v6 = FigDerivedFormatDescriptionCreate(a1, (void *)0x63706772, a2, 0, (uint64_t *)&cf);
  if ((_DWORD)v6)
  {
    if (cf)
      CFRelease(cf);
  }
  else
  {
    *(_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)cf) = a2;
    *a3 = cf;
  }
  return v6;
}

__CFString *figCaptionGroupFormatDescriptionCopyDebugDesc(const void *a1)
{
  _DWORD *DerivedStorage;
  const __CFAllocator *v3;
  __CFString *Mutable;

  DerivedStorage = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage((uint64_t)a1);
  v3 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v3, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("\t\tsubType: '%c%c%c%c'"), HIBYTE(*DerivedStorage), BYTE2(*DerivedStorage), BYTE1(*DerivedStorage), *DerivedStorage);
  return Mutable;
}

BOOL figCaptionGroupFormatDescriptionEqual(uint64_t a1, uint64_t a2)
{
  _DWORD *DerivedStorage;

  DerivedStorage = (_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage(a1);
  return *DerivedStorage == *(_DWORD *)FigDerivedFormatDescriptionGetDerivedStorage(a2);
}

uint64_t FigTaggedBufferGroupGetTypeID()
{
  if (CMTaggedBufferGroupGetTypeID_sRegisterTaggedBufferGroupTypeOnce != -1)
    dispatch_once(&CMTaggedBufferGroupGetTypeID_sRegisterTaggedBufferGroupTypeOnce, &__block_literal_global_38);
  return CMTaggedBufferGroupGetTypeID_sTaggedBufferGroupTypeID;
}

CFTypeID CMTaggedBufferGroupGetTypeID(void)
{
  if (CMTaggedBufferGroupGetTypeID_sRegisterTaggedBufferGroupTypeOnce != -1)
    dispatch_once(&CMTaggedBufferGroupGetTypeID_sRegisterTaggedBufferGroupTypeOnce, &__block_literal_global_38);
  return CMTaggedBufferGroupGetTypeID_sTaggedBufferGroupTypeID;
}

uint64_t taggedBufferGroup_init(uint64_t result)
{
  *(_QWORD *)(result + 16) = 0;
  return result;
}

void taggedBufferGroup_finalize(uint64_t a1)
{
  uint64_t v2;
  CFTypeRef *v3;
  const void *v4;

  if (*(uint64_t *)(a1 + 16) >= 1)
  {
    v2 = 0;
    v3 = (CFTypeRef *)(a1 + 32);
    do
    {
      v4 = *(v3 - 1);
      if (v4)
      {
        CFRelease(v4);
        *(v3 - 1) = 0;
      }
      if (*v3)
      {
        CFRelease(*v3);
        *v3 = 0;
      }
      ++v2;
      v3 += 2;
    }
    while (v2 < *(_QWORD *)(a1 + 16));
  }
}

uint64_t taggedBufferGroup_equal(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  CFTypeRef *v5;
  CFTypeRef *i;
  uint64_t result;

  if (!a2)
    return 0;
  v3 = *(_QWORD *)(a1 + 16);
  if (v3 != *(_QWORD *)(a2 + 16))
    return 0;
  if (v3 < 1)
    return 1;
  v4 = 0;
  v5 = (CFTypeRef *)(a1 + 32);
  for (i = (CFTypeRef *)(a2 + 32); ; i += 2)
  {
    result = CFEqual(*(v5 - 1), *(i - 1));
    if (!(_DWORD)result)
      break;
    result = CFEqual(*v5, *i);
    if (!(_DWORD)result)
      break;
    ++v4;
    v5 += 2;
    if (v4 >= *(_QWORD *)(a1 + 16))
      return 1;
  }
  return result;
}

CFHashCode taggedBufferGroup_hash(uint64_t a1)
{
  CFHashCode v2;
  uint64_t v3;
  const void **v4;
  CFHashCode v5;
  const void *v6;

  if (*(uint64_t *)(a1 + 16) < 1)
    return 0;
  v2 = 0;
  v3 = 0;
  v4 = (const void **)(a1 + 32);
  do
  {
    v5 = ((v2 << 6) + 2654435769u + (v2 >> 2) + CFHash(*(v4 - 1))) ^ v2;
    v6 = *v4;
    v4 += 2;
    v2 = (CFHash(v6) + 2654435769u + (v5 << 6) + (v5 >> 2)) ^ v5;
    ++v3;
  }
  while (v3 < *(_QWORD *)(a1 + 16));
  return v2;
}

uint64_t taggedBufferGroup_createCommon(int a1, const __CFArray *a2, CFArrayRef theArray, uint64_t *a4)
{
  CFIndex Count;
  uint64_t Instance;
  uint64_t v9;
  CFIndex v10;
  CFTypeRef *v11;
  const void *ValueAtIndex;
  const void *v13;
  uint64_t v15;

  if (!a2)
  {
    v15 = 4294951516;
    return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
  if (!theArray || (Count = CFArrayGetCount(theArray), Count != CFArrayGetCount(a2)) || !a4)
  {
    v15 = 4294951516;
    return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
  if (CMTaggedBufferGroupGetTypeID_sRegisterTaggedBufferGroupTypeOnce != -1)
    dispatch_once(&CMTaggedBufferGroupGetTypeID_sRegisterTaggedBufferGroupTypeOnce, &__block_literal_global_38);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v15 = 4294951515;
    return FigSignalErrorAt(v15, 0, 0, 0, 0, 0, 0);
  }
  v9 = Instance;
  *(_QWORD *)(Instance + 16) = Count;
  if (Count >= 1)
  {
    v10 = 0;
    v11 = (CFTypeRef *)(Instance + 32);
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v10);
      *(v11 - 1) = CFRetain(ValueAtIndex);
      v13 = CFArrayGetValueAtIndex(a2, v10);
      *v11 = CFRetain(v13);
      v11 += 2;
      ++v10;
    }
    while (v10 < *(_QWORD *)(v9 + 16));
  }
  *a4 = v9;
  return 0;
}

OSStatus CMTaggedBufferGroupCreateCombined(CFAllocatorRef allocator, CFArrayRef taggedBufferGroups, CMTaggedBufferGroupRef *groupOut)
{
  CFIndex Count;
  CFIndex v7;
  CFMutableArrayRef Mutable;
  __CFArray *v9;
  CFMutableArrayRef v10;
  __CFArray *v11;
  CFIndex i;
  char *ValueAtIndex;
  char *v14;
  uint64_t v15;
  const void **v16;
  const void *v17;
  OSStatus Common;
  __CFArray *v19;
  uint64_t v20;
  CFTypeRef cf;

  cf = 0;
  if (!taggedBufferGroups || (Count = CFArrayGetCount(taggedBufferGroups), Count <= 0) || !groupOut)
  {
    v20 = 4294951516;
LABEL_16:
    Common = FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
    goto LABEL_17;
  }
  v7 = Count;
  Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    v20 = 4294951515;
    goto LABEL_16;
  }
  v9 = Mutable;
  v10 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
  if (v10)
  {
    v11 = v10;
    for (i = 0; i != v7; ++i)
    {
      ValueAtIndex = (char *)CFArrayGetValueAtIndex(taggedBufferGroups, i);
      if (*((uint64_t *)ValueAtIndex + 2) >= 1)
      {
        v14 = ValueAtIndex;
        v15 = 0;
        v16 = (const void **)(ValueAtIndex + 32);
        do
        {
          CFArrayAppendValue(v11, *(v16 - 1));
          v17 = *v16;
          v16 += 2;
          CFArrayAppendValue(v9, v17);
          ++v15;
        }
        while (v15 < *((_QWORD *)v14 + 2));
      }
    }
    Common = taggedBufferGroup_createCommon((int)allocator, v9, v11, (uint64_t *)&cf);
    if (!Common)
    {
      *groupOut = (CMTaggedBufferGroupRef)cf;
      cf = 0;
    }
    CFRelease(v9);
    v19 = v11;
  }
  else
  {
    Common = FigSignalErrorAt(4294951515, 0, 0, 0, 0, 0, 0);
    v19 = v9;
  }
  CFRelease(v19);
LABEL_17:
  if (cf)
    CFRelease(cf);
  return Common;
}

CMItemCount CMTaggedBufferGroupGetCount(CMTaggedBufferGroupRef group)
{
  if (group)
    return *((_QWORD *)group + 2);
  FigSignalErrorAt(4294951516, 0, 0, 0, 0, 0, 0);
  return 0;
}

CMTagCollectionRef CMTaggedBufferGroupGetTagCollectionAtIndex(CMTaggedBufferGroupRef group, CFIndex index)
{
  if (group && (index & 0x8000000000000000) == 0 && *((_QWORD *)group + 2) > index)
    return (CMTagCollectionRef)*((_QWORD *)group + 2 * index + 4);
  FigSignalErrorAt(4294951516, 0, 0, 0, 0, 0, 0);
  return 0;
}

uint64_t FigTaggedBufferGroupGetCVPixelBufferAtIndex(uint64_t a1, uint64_t a2)
{
  CFTypeID TypeID;

  TypeID = CVPixelBufferGetTypeID();
  return taggedBufferGroup_getBufferAtIndexWithTypeCheck(a1, a2, TypeID);
}

CVPixelBufferRef CMTaggedBufferGroupGetCVPixelBufferAtIndex(CMTaggedBufferGroupRef group, CFIndex index)
{
  CFTypeID TypeID;

  TypeID = CVPixelBufferGetTypeID();
  return (CVPixelBufferRef)taggedBufferGroup_getBufferAtIndexWithTypeCheck((uint64_t)group, index, TypeID);
}

uint64_t taggedBufferGroup_getBufferAtIndexWithTypeCheck(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;

  if (!a1 || a2 < 0 || *(_QWORD *)(a1 + 16) <= a2)
  {
    FigSignalErrorAt(4294951516, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  v3 = a1 + 16 * a2;
  v4 = *(_QWORD *)(v3 + 24);
  if (!v4)
    return 0;
  if (CFGetTypeID(*(CFTypeRef *)(v3 + 24)) == a3)
    return v4;
  else
    return 0;
}

CVPixelBufferRef CMTaggedBufferGroupGetCVPixelBufferForTag(CMTaggedBufferGroupRef group, CMTag tag, CFIndex *indexOut)
{
  CVPixelBufferRef CVPixelBufferForTagCollection;
  __CVBuffer *v6;
  CMTagCollectionRef tagCollection;
  CFIndex indexOuta;
  CMTag tags;

  tags = tag;
  tagCollection = 0;
  indexOuta = -1;
  if (CMTagCollectionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &tags, 1, &tagCollection))
  {
    v6 = 0;
  }
  else
  {
    CVPixelBufferForTagCollection = CMTaggedBufferGroupGetCVPixelBufferForTagCollection(group, tagCollection, &indexOuta);
    v6 = CVPixelBufferForTagCollection;
    if (indexOut && CVPixelBufferForTagCollection)
      *indexOut = indexOuta;
  }
  if (tagCollection)
    CFRelease(tagCollection);
  return v6;
}

CVPixelBufferRef CMTaggedBufferGroupGetCVPixelBufferForTagCollection(CMTaggedBufferGroupRef group, CMTagCollectionRef tagCollection, CFIndex *indexOut)
{
  uint64_t CountAndLastIndexForMatchedTagCollection;
  uint64_t v6;
  CFTypeID TypeID;
  CVPixelBufferRef result;
  CFIndex v10;

  v10 = -1;
  CountAndLastIndexForMatchedTagCollection = taggedBufferGroup_getCountAndLastIndexForMatchedTagCollection((uint64_t)group, tagCollection, &v10);
  v6 = v10;
  if (CountAndLastIndexForMatchedTagCollection != 1 || v10 == -1)
    return 0;
  TypeID = CVPixelBufferGetTypeID();
  result = (CVPixelBufferRef)taggedBufferGroup_getBufferAtIndexWithTypeCheck((uint64_t)group, v6, TypeID);
  if (indexOut)
  {
    if (result)
      *indexOut = v10;
  }
  return result;
}

uint64_t taggedBufferGroup_getCountAndLastIndexForMatchedTagCollection(uint64_t a1, CMTagCollectionRef containedTagCollection, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  const OpaqueCMTagCollection **v8;
  uint64_t v9;
  const OpaqueCMTagCollection *v10;

  if (!a1 || !containedTagCollection)
  {
    FigSignalErrorAt(4294951516, 0, 0, 0, 0, 0, 0);
    return 0;
  }
  if (*(uint64_t *)(a1 + 16) < 1)
  {
    v6 = 0;
    v9 = -1;
    if (!a3)
      return v6;
LABEL_11:
    *a3 = v9;
    return v6;
  }
  v6 = 0;
  v7 = 0;
  v8 = (const OpaqueCMTagCollection **)(a1 + 32);
  v9 = -1;
  do
  {
    v10 = *v8;
    v8 += 2;
    if (CMTagCollectionContainsTagsOfCollection(v10, containedTagCollection))
    {
      v9 = v7;
      ++v6;
    }
    ++v7;
  }
  while (v7 < *(_QWORD *)(a1 + 16));
  if (a3)
    goto LABEL_11;
  return v6;
}

uint64_t FigTaggedBufferGroupGetCMSampleBufferAtIndex(uint64_t a1, uint64_t a2)
{
  CFTypeID TypeID;

  TypeID = CMSampleBufferGetTypeID();
  return taggedBufferGroup_getBufferAtIndexWithTypeCheck(a1, a2, TypeID);
}

CMSampleBufferRef CMTaggedBufferGroupGetCMSampleBufferAtIndex(CMTaggedBufferGroupRef group, CFIndex index)
{
  CFTypeID TypeID;

  TypeID = CMSampleBufferGetTypeID();
  return (CMSampleBufferRef)taggedBufferGroup_getBufferAtIndexWithTypeCheck((uint64_t)group, index, TypeID);
}

CMSampleBufferRef CMTaggedBufferGroupGetCMSampleBufferForTag(CMTaggedBufferGroupRef group, CMTag tag, CFIndex *indexOut)
{
  CMSampleBufferRef CMSampleBufferForTagCollection;
  opaqueCMSampleBuffer *v6;
  CMTagCollectionRef tagCollection;
  CFIndex indexOuta;
  CMTag tags;

  tags = tag;
  tagCollection = 0;
  indexOuta = -1;
  if (CMTagCollectionCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &tags, 1, &tagCollection))
  {
    v6 = 0;
  }
  else
  {
    CMSampleBufferForTagCollection = CMTaggedBufferGroupGetCMSampleBufferForTagCollection(group, tagCollection, &indexOuta);
    v6 = CMSampleBufferForTagCollection;
    if (indexOut && CMSampleBufferForTagCollection)
      *indexOut = indexOuta;
  }
  if (tagCollection)
    CFRelease(tagCollection);
  return v6;
}

CMSampleBufferRef CMTaggedBufferGroupGetCMSampleBufferForTagCollection(CMTaggedBufferGroupRef group, CMTagCollectionRef tagCollection, CFIndex *indexOut)
{
  uint64_t CountAndLastIndexForMatchedTagCollection;
  uint64_t v6;
  CFTypeID TypeID;
  CMSampleBufferRef result;
  CFIndex v10;

  v10 = -1;
  CountAndLastIndexForMatchedTagCollection = taggedBufferGroup_getCountAndLastIndexForMatchedTagCollection((uint64_t)group, tagCollection, &v10);
  v6 = v10;
  if (CountAndLastIndexForMatchedTagCollection != 1 || v10 == -1)
    return 0;
  TypeID = CMSampleBufferGetTypeID();
  result = (CMSampleBufferRef)taggedBufferGroup_getBufferAtIndexWithTypeCheck((uint64_t)group, v6, TypeID);
  if (indexOut)
  {
    if (result)
      *indexOut = v10;
  }
  return result;
}

uint64_t FigTaggedBufferGroupGetNumberOfMatchesForTagCollection(uint64_t a1, const OpaqueCMTagCollection *a2)
{
  return taggedBufferGroup_getCountAndLastIndexForMatchedTagCollection(a1, a2, 0);
}

CMItemCount CMTaggedBufferGroupGetNumberOfMatchesForTagCollection(CMTaggedBufferGroupRef group, CMTagCollectionRef tagCollection)
{
  return taggedBufferGroup_getCountAndLastIndexForMatchedTagCollection((uint64_t)group, tagCollection, 0);
}

__CFString *taggedBufferGroup_copyDesc(const void **a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  const __CFAllocator *v4;
  CFMutableArrayRef v5;
  __CFArray *v6;
  uint64_t v7;
  const void **v8;
  const void *v9;
  __CFString *v10;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  if (Mutable)
  {
    v4 = CFGetAllocator(a1);
    v5 = CFArrayCreateMutable(v4, 0, MEMORY[0x1E0C9B378]);
    if (v5)
    {
      v6 = v5;
      if ((uint64_t)a1[2] >= 1)
      {
        v7 = 0;
        v8 = a1 + 4;
        do
        {
          CFArrayAppendValue(v6, *(v8 - 1));
          v9 = *v8;
          v8 += 2;
          CFArrayAppendValue(v6, v9);
          ++v7;
        }
        while (v7 < (uint64_t)a1[2]);
      }
      v10 = FigCFCopyCompactDescription(v6);
      CFStringAppendFormat(Mutable, 0, CFSTR("<CMTaggedBufferGroup %p>: TaggedBuffers %@"), a1, v10);
      if (v10)
        CFRelease(v10);
      CFRelease(v6);
    }
    else
    {
      CFStringAppendFormat(Mutable, 0, CFSTR("<CMTaggedBufferGroup %p>: TaggedBuffers %@"), a1, 0);
    }
  }
  else
  {
    FigSignalErrorAt(4294951515, 0, 0, 0, 0, 0, 0);
  }
  return Mutable;
}

uint64_t FigRegistryItemGetTypeID()
{
  FigThreadRunOnce(&FigRegistryItemGetTypeID_registerOnce, (void (*)(void))registerFigRegistryItem);
  return sFigRegistryItemID;
}

uint64_t registerFigRegistryItem()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigRegistryItemID = result;
  return result;
}

uint64_t FigRegistryItemCreateCopy2(_QWORD *a1, CFDictionaryRef theDict, _QWORD *a3)
{
  uint64_t result;
  const void *Value;
  const void *v8;
  const void *v9;
  const void *v10;
  const __CFNumber *v11;
  const __CFNumber *SInt64;
  const void *v13;
  const void *v14;
  const __CFAllocator *v15;
  uint64_t Instance;
  _QWORD *v17;
  CFMutableDictionaryRef MutableCopy;
  uint64_t v19;
  const void *v20;
  const void *v21;
  CFTypeRef v22;
  uint64_t v23;

  *a3 = 0;
  result = 4294954602;
  if (a1 && theDict)
  {
    Value = CFDictionaryGetValue(theDict, CFSTR("CMClassID"));
    if (Value
      && (v8 = Value, (v9 = CFDictionaryGetValue(theDict, CFSTR("CMClassImplementationName"))) != 0)
      && (v10 = v9,
          (v11 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("CMClassImplementationVersion"))) != 0)
      && (SInt64 = FigCFNumberGetSInt64(v11), CFDictionaryGetValue(theDict, CFSTR("CMClassImplementationID")))
      && (v13 = CFDictionaryGetValue(theDict, CFSTR("CMMatchingInfo"))) != 0)
    {
      v14 = v13;
      v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      FigThreadRunOnce(&FigRegistryItemGetTypeID_registerOnce, (void (*)(void))registerFigRegistryItem);
      Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        v17 = (_QWORD *)Instance;
        MutableCopy = FigCFDictionaryCreateMutableCopy(v15, theDict);
        v17[2] = MutableCopy;
        if (MutableCopy)
        {
          v17[3] = a1[3];
          v19 = a1[3];
          if (v19)
          {
            FigAtomicIncrement32((unsigned int *)(v19 + 16));
            v20 = *(const void **)(a1[3] + 8);
            if (v20)
              CFRetain(v20);
          }
          v17[4] = CFRetain(v8);
          v17[5] = CFRetain(v10);
          v17[7] = CFRetain(v14);
          v17[8] = SInt64;
          v21 = (const void *)a1[6];
          if (v21)
            v22 = CFRetain(v21);
          else
            v22 = 0;
          result = 0;
          v17[6] = v22;
          v17[9] = a1[9];
          *a3 = v17;
        }
        else
        {
          v23 = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
          CFRelease(v17);
          return v23;
        }
      }
      else
      {
        return 4294954603;
      }
    }
    else
    {
      return 4294954602;
    }
  }
  return result;
}

uint64_t FigRegistryItemCreateCopy(uint64_t a1, uint64_t a2, const void *a3, _QWORD *a4)
{
  uint64_t Copy2;
  const __CFAllocator *v9;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v11;
  const __CFString *Value;
  __CFString *v13;

  Copy2 = 4294954602;
  if (!a3 || !a1 || !a4)
    return Copy2;
  *a4 = 0;
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  MutableCopy = FigCFDictionaryCreateMutableCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(CFDictionaryRef *)(a1 + 16));
  if (MutableCopy)
  {
    v11 = MutableCopy;
    Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("CMClassImplementationID"));
    if (a2)
    {
      v13 = CFStringCreateMutableCopy(v9, 0, Value);
      CFStringAppendFormat(v13, 0, CFSTR(".%@"), a2);
      CFDictionarySetValue(v11, CFSTR("CMClassImplementationID"), v13);
    }
    else
    {
      v13 = 0;
    }
    CFDictionarySetValue(v11, CFSTR("CMMatchingInfo"), a3);
    Copy2 = FigRegistryItemCreateCopy2((_QWORD *)a1, v11, a4);
    if (v13)
      CFRelease(v13);
    CFRelease(v11);
    return Copy2;
  }
  return FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
}

uint64_t FigRegistryItemCopyDescription(uint64_t a1, _QWORD *a2)
{
  const void *v4;
  uint64_t v5;

  v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRetain(v4);
    v5 = *(_QWORD *)(a1 + 16);
  }
  else
  {
    v5 = 0;
  }
  *a2 = v5;
  return 0;
}

uint64_t FigRegistryItemCopyMatchingInfo(uint64_t a1, _QWORD *a2)
{
  const void *v4;
  uint64_t v5;

  v4 = *(const void **)(a1 + 56);
  if (v4)
  {
    CFRetain(v4);
    v5 = *(_QWORD *)(a1 + 56);
  }
  else
  {
    v5 = 0;
  }
  *a2 = v5;
  return 0;
}

uint64_t FigRegistryItemCopyBundle(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 24);
  if (v3)
  {
    CFRetain(*(CFTypeRef *)(v3 + 8));
    v4 = *(_QWORD *)(v3 + 8);
  }
  else
  {
    v4 = 0;
  }
  *a2 = v4;
  return 0;
}

uint64_t FigRegistryItemGetFactory(uint64_t a1, int a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  result = 0;
  v6 = *(_QWORD *)(a1 + 72);
  if (a2 && !v6)
  {
    v7 = *(_QWORD *)(a1 + 24);
    FigSimpleMutexLock(*(pthread_mutex_t **)v7);
    if (!*(_QWORD *)(a1 + 72))
      *(_QWORD *)(a1 + 72) = CFBundleGetFunctionPointerForName(*(CFBundleRef *)(v7 + 8), *(CFStringRef *)(a1 + 48));
    FigSimpleMutexUnlock(*(pthread_mutex_t **)v7);
    v6 = *(_QWORD *)(a1 + 72);
    if (v6)
    {
      result = 0;
    }
    else
    {
      result = FigSignalErrorAt(4294954604, 0, 0, 0, 0, 0, 0);
      v6 = *(_QWORD *)(a1 + 72);
    }
  }
  *a3 = v6;
  return result;
}

uint64_t FigRegistryItemGetVersion(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t FigRegistryGetTypeID()
{
  FigThreadRunOnce(&FigRegistryGetTypeID_registerOnce, (void (*)(void))registerFigRegistry);
  return sFigRegistryID;
}

uint64_t registerFigRegistry()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigRegistryID = result;
  return result;
}

uint64_t FigRegistryCreate(const __CFAllocator *a1, const __CFString *a2, _QWORD *a3)
{
  _QWORD *Instance;
  const CFSetCallBacks *v7;
  CFMutableDictionaryRef Mutable;
  BOOL v9;
  CFStringRef Copy;
  uint64_t v12;

  FigThreadRunOnce(&FigRegistryGetTypeID_registerOnce, (void (*)(void))registerFigRegistry);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    v7 = (const CFSetCallBacks *)MEMORY[0x1E0C9B3B0];
    Instance[3] = CFSetCreateMutable(a1, 0, MEMORY[0x1E0C9B3B0]);
    Instance[4] = CFArrayCreateMutable(a1, 0, 0);
    Instance[5] = CFSetCreateMutable(a1, 0, v7);
    Instance[6] = FigReentrantMutexCreate();
    Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    Instance[7] = Mutable;
    if (Instance[3] && Instance[4] && Instance[5] && (Instance[6] ? (v9 = Mutable == 0) : (v9 = 1), !v9))
    {
      Copy = CFStringCreateCopy(a1, a2);
      v12 = 0;
      Instance[2] = Copy;
    }
    else
    {
      v12 = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
      if ((_DWORD)v12)
      {
        CFRelease(Instance);
        Instance = 0;
      }
    }
  }
  else
  {
    v12 = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
  }
  *a3 = Instance;
  return v12;
}

uint64_t FigRegistryAddSearchPathWithOptions(uint64_t a1, const void *a2, int a3)
{
  uint64_t v6;
  void *value;

  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 48));
  if (CFSetContainsValue(*(CFSetRef *)(a1 + 24), a2))
  {
    v6 = 0;
  }
  else
  {
    value = 0;
    v6 = registryCacheAddPath(a2, 0, a3, (pthread_mutex_t ***)&value);
    if (!(_DWORD)v6)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), value);
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 24), a2);
    }
  }
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 48));
  return v6;
}

uint64_t registryCacheAddPath(const void *a1, int a2, int a3, pthread_mutex_t ***a4)
{
  pthread_mutex_t **Value;
  int v9;
  const __CFArray *BundlesFromDirectory;
  const __CFArray *v11;
  uint64_t result;
  pthread_mutex_t **v13;
  CFMutableDictionaryRef Mutable;
  pthread_mutex_t *v15;
  CFRange v16;

  FigThreadRunOnce(&stru_1EE140288, (void (*)(void))registryCacheInitOnce);
  if (qword_1EE140280)
  {
    FigSimpleMutexLock((pthread_mutex_t *)qword_1EE140280);
    Value = (pthread_mutex_t **)CFDictionaryGetValue((CFDictionaryRef)sRegistryCache, a1);
    if (Value)
    {
LABEL_3:
      FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EE140280);
      FigSimpleMutexLock(Value[1]);
      v9 = *((_DWORD *)Value + 5);
      if (a2 || !v9)
      {
        if (v9)
          CFDictionaryApplyFunction((CFDictionaryRef)*Value, (CFDictionaryApplierFunction)registryCacheClearClass, 0);
        BundlesFromDirectory = CFBundleCreateBundlesFromDirectory((CFAllocatorRef)qword_1EE140278, (CFURLRef)a1, CFSTR("bundle"));
        if (BundlesFromDirectory)
        {
          v11 = BundlesFromDirectory;
          v16.length = CFArrayGetCount(BundlesFromDirectory);
          v16.location = 0;
          CFArrayApplyFunction(v11, v16, (CFArrayApplierFunction)registryCacheProcessBundle, Value);
          CFRelease(v11);
LABEL_9:
          ++*((_DWORD *)Value + 5);
          goto LABEL_17;
        }
        if (!FigSignalErrorAt(4294954605, 0, 0, 0, 0, 0, 0))
          goto LABEL_9;
      }
LABEL_17:
      FigSimpleMutexUnlock(Value[1]);
      result = 0;
      if (!a4)
        return result;
      goto LABEL_18;
    }
    v13 = (pthread_mutex_t **)malloc_type_calloc(1uLL, 0x18uLL, 0x102004062D53EE8uLL);
    if (v13)
    {
      Value = v13;
      *((_DWORD *)v13 + 4) = a3;
      *((_DWORD *)v13 + 5) = 0;
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)qword_1EE140278, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      *Value = (pthread_mutex_t *)Mutable;
      if (Mutable)
      {
        v15 = FigSimpleMutexCreate();
        Value[1] = v15;
        if (v15)
        {
          CFDictionaryAddValue((CFMutableDictionaryRef)sRegistryCache, a1, Value);
          goto LABEL_3;
        }
      }
      FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
      if (*Value)
        CFRelease(*Value);
      free(Value);
    }
    else
    {
      FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
    }
    FigSimpleMutexUnlock((pthread_mutex_t *)qword_1EE140280);
    Value = 0;
    result = 4294954603;
    if (!a4)
      return result;
  }
  else
  {
    result = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
    Value = 0;
    if (!a4)
      return result;
  }
LABEL_18:
  *a4 = Value;
  return result;
}

uint64_t FigRegistryAddSearchPath(uint64_t a1, const void *a2)
{
  return FigRegistryAddSearchPathWithOptions(a1, a2, 0);
}

uint64_t FigRegistryAddItem(uint64_t a1, CFDictionaryRef theDict, uint64_t a3)
{
  const void *Value;
  const __CFAllocator *v7;
  uint64_t v8;
  CFTypeRef v9;
  CFTypeRef cf;

  cf = 0;
  Value = CFDictionaryGetValue(theDict, CFSTR("CMClassID"));
  if (Value && CFEqual(Value, *(CFTypeRef *)(a1 + 16)))
  {
    v7 = CFGetAllocator((CFTypeRef)a1);
    v8 = figRegistryItemCreate(v7, 0, a3, theDict, &cf);
    if ((_DWORD)v8)
    {
      v9 = cf;
      if (!cf)
        return v8;
    }
    else
    {
      FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 48));
      v9 = cf;
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), cf);
      FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 48));
      if (!v9)
        return v8;
    }
    CFRelease(v9);
    return v8;
  }
  return FigSignalErrorAt(4294954606, 0, 0, 0, 0, 0, 0);
}

uint64_t figRegistryItemCreate(const __CFAllocator *a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict, _QWORD *a5)
{
  uint64_t v7;
  const __CFDictionary *v8;
  __CFDictionary *v11;
  __CFBundle *v12;
  CFURLRef v13;
  CFMutableDictionaryRef MutableCopy;
  uint64_t v15;
  CFStringRef v16;
  CFStringRef v17;
  const void *Value;
  const void *v19;
  const void *v20;
  const void *v21;
  _QWORD *v22;
  CFTypeID v23;
  BOOL v24;
  CFTypeID v25;
  CFTypeID v26;
  CFTypeID v27;
  CFTypeID v28;
  CFTypeID v29;
  uint64_t v30;
  _QWORD *Instance;
  uint64_t result;
  const void *v33;
  CFTypeRef v34;
  CFTypeRef v35;
  uint64_t v36;
  CFTypeRef v37;
  CFTypeRef cf;
  uint64_t valuePtr;

  v7 = 4294954606;
  if (a2 | a3)
  {
    v8 = theDict;
    if (theDict)
    {
      valuePtr = 0;
      if (CFDictionaryGetValue(theDict, CFSTR("CMClassImplementationID")))
      {
        v11 = 0;
        goto LABEL_12;
      }
      if (a2)
      {
        v12 = *(__CFBundle **)(a2 + 8);
        if (v12)
        {
          v13 = CFBundleCopyBundleURL(v12);
          if (v13)
            CFRelease(v13);
        }
      }
      MutableCopy = FigCFDictionaryCreateMutableCopy(a1, v8);
      if (MutableCopy)
      {
        v11 = MutableCopy;
        v15 = FigAtomicIncrement32((unsigned int *)&figRegistryItemCreate_sNextMadeUpNumber);
        v16 = CFStringCreateWithFormat(a1, 0, CFSTR("anon-%d"), v15);
        if (!v16)
        {
          v30 = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
          *a5 = 0;
          goto LABEL_31;
        }
        v17 = v16;
        CFDictionarySetValue(v11, CFSTR("CMClassImplementationID"), v16);
        CFRelease(v17);
        v8 = v11;
LABEL_12:
        Value = CFDictionaryGetValue(v8, CFSTR("CMClassID"));
        v19 = CFDictionaryGetValue(v8, CFSTR("CMClassImplementationName"));
        v37 = CFDictionaryGetValue(v8, CFSTR("CMFactoryFunction"));
        v20 = CFDictionaryGetValue(v8, CFSTR("CMClassImplementationVersion"));
        v21 = CFDictionaryGetValue(v8, CFSTR("CMClassImplementationID"));
        cf = CFDictionaryGetValue(v8, CFSTR("CMMatchingInfo"));
        if (!Value)
          goto LABEL_29;
        if (!v19)
          goto LABEL_29;
        if (!v20)
          goto LABEL_29;
        if (!cf)
          goto LABEL_29;
        if (!v21)
          goto LABEL_29;
        v22 = a5;
        v23 = CFGetTypeID(Value);
        v24 = v23 == CFStringGetTypeID();
        a5 = v22;
        if (!v24)
          goto LABEL_29;
        v25 = CFGetTypeID(v19);
        v24 = v25 == CFStringGetTypeID();
        a5 = v22;
        if (!v24)
          goto LABEL_29;
        v26 = CFGetTypeID(v20);
        v24 = v26 == CFNumberGetTypeID();
        a5 = v22;
        if (!v24)
          goto LABEL_29;
        v27 = CFGetTypeID(cf);
        v24 = v27 == CFDictionaryGetTypeID();
        a5 = v22;
        if (!v24)
          goto LABEL_29;
        v28 = CFGetTypeID(v21);
        if (v28 != CFStringGetTypeID() || !CFNumberGetValue((CFNumberRef)v20, kCFNumberSInt64Type, &valuePtr))
          goto LABEL_29;
        if (v37)
        {
          v29 = CFGetTypeID(v37);
          if (v29 != CFStringGetTypeID())
          {
LABEL_29:
            v30 = FigSignalErrorAt(4294954606, 0, 0, 0, 0, 0, 0);
            Instance = 0;
            goto LABEL_30;
          }
        }
        else if (!a3)
        {
          goto LABEL_29;
        }
        FigThreadRunOnce(&FigRegistryItemGetTypeID_registerOnce, (void (*)(void))registerFigRegistryItem);
        Instance = (_QWORD *)_CFRuntimeCreateInstance();
        if (Instance)
        {
          Instance[2] = CFRetain(v8);
          Instance[3] = a2;
          if (a2)
          {
            FigAtomicIncrement32((unsigned int *)(a2 + 16));
            v33 = *(const void **)(a2 + 8);
            if (v33)
              CFRetain(v33);
          }
          Instance[4] = CFRetain(Value);
          Instance[5] = CFRetain(v19);
          v34 = v37;
          if (v37)
            v34 = CFRetain(v37);
          Instance[6] = v34;
          v35 = CFRetain(cf);
          v30 = 0;
          v36 = valuePtr;
          Instance[7] = v35;
          Instance[8] = v36;
          Instance[9] = a3;
        }
        else
        {
          v30 = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
        }
LABEL_30:
        *a5 = Instance;
        if (!v11)
          return v30;
LABEL_31:
        CFRelease(v11);
        return v30;
      }
      v7 = 4294954603;
    }
  }
  result = FigSignalErrorAt(v7, 0, 0, 0, 0, 0, 0);
  *a5 = 0;
  return result;
}

uint64_t FigRegistryRemoveItem(uint64_t a1, const void *a2)
{
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 48));
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 40), a2);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 48));
  return 0;
}

uint64_t FigRegistryRescan(uint64_t a1)
{
  FigReentrantMutexLock(*(pthread_mutex_t **)(a1 + 48));
  CFSetApplyFunction(*(CFSetRef *)(a1 + 24), (CFSetApplierFunction)figRegistryRescanDirectory, (void *)a1);
  FigReentrantMutexUnlock(*(pthread_mutex_t **)(a1 + 48));
  return 0;
}

uint64_t figRegistryRescanDirectory(const void *a1)
{
  return registryCacheAddPath(a1, 1, 0, 0);
}

uint64_t FigRegistrySetIORegistryEntryArray()
{
  return 0;
}

uint64_t FigRegistryCopyItemList(const void *a1, CFMutableArrayRef *a2, _DWORD *a3)
{
  return FigRegistryCopyFilteredItemList(a1, 0, 0, a2, a3);
}

uint64_t FigRegistryCopyFilteredItemList(CFTypeRef cf, uint64_t a2, uint64_t a3, CFMutableArrayRef *a4, _DWORD *a5)
{
  const __CFAllocator *v8;
  CFMutableArrayRef Mutable;
  uint64_t v10;
  int Count;
  CFIndex v12;
  CFIndex v13;
  CFIndex i;
  pthread_mutex_t **ValueAtIndex;
  int v16;
  const __CFSet *Value;
  _QWORD context[3];

  context[0] = cf;
  context[1] = a2;
  context[2] = a3;
  if (a4)
  {
    v8 = CFGetAllocator(cf);
    Mutable = CFArrayCreateMutable(v8, 0, MEMORY[0x1E0C9B378]);
    if (!Mutable)
    {
      v10 = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
      Count = 0;
      goto LABEL_15;
    }
  }
  else
  {
    Mutable = 0;
  }
  FigReentrantMutexLock(*((pthread_mutex_t **)cf + 6));
  Count = CFSetGetCount(*((CFSetRef *)cf + 5));
  if (a4)
    CFDictionaryRemoveAllValues(*((CFMutableDictionaryRef *)cf + 7));
  v12 = CFArrayGetCount(*((CFArrayRef *)cf + 4));
  if (v12 >= 1)
  {
    v13 = v12;
    for (i = 0; i != v13; ++i)
    {
      ValueAtIndex = (pthread_mutex_t **)CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 4), i);
      FigSimpleMutexLock(ValueAtIndex[1]);
      v16 = *((_DWORD *)ValueAtIndex + 5);
      if (a4)
      {
        Value = (const __CFSet *)CFDictionaryGetValue((CFDictionaryRef)*ValueAtIndex, *((const void **)cf + 2));
        if (Value)
          CFSetApplyFunction(Value, (CFSetApplierFunction)figRegistryAddResultItem, context);
      }
      Count += v16;
      FigSimpleMutexUnlock(ValueAtIndex[1]);
    }
  }
  if (a4)
  {
    CFSetApplyFunction(*((CFSetRef *)cf + 5), (CFSetApplierFunction)figRegistryAddResultItem, context);
    CFDictionaryApplyFunction(*((CFDictionaryRef *)cf + 7), (CFDictionaryApplierFunction)figRegistryAddItemsToResult, Mutable);
    FigReentrantMutexUnlock(*((pthread_mutex_t **)cf + 6));
    v10 = 0;
LABEL_15:
    *a4 = Mutable;
    Mutable = 0;
    if (!a5)
      goto LABEL_17;
    goto LABEL_16;
  }
  FigReentrantMutexUnlock(*((pthread_mutex_t **)cf + 6));
  v10 = 0;
  if (a5)
LABEL_16:
    *a5 = Count;
LABEL_17:
  if (Mutable)
    CFRelease(Mutable);
  return v10;
}

void figRegistryAddResultItem(uint64_t a1, uint64_t a2)
{
  unsigned int (*v3)(_QWORD, uint64_t);
  CFDictionaryRef *v4;
  const void *Value;
  const __CFArray *v6;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  _QWORD *ValueAtIndex;
  uint64_t v11;
  uint64_t v12;
  const __CFAllocator *v13;
  __CFArray *Mutable;

  v4 = *(CFDictionaryRef **)a2;
  v3 = *(unsigned int (**)(_QWORD, uint64_t))(a2 + 8);
  if (!v3 || v3(*(_QWORD *)(a2 + 16), a1))
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("CMClassImplementationID"));
    v6 = (const __CFArray *)CFDictionaryGetValue(v4[7], Value);
    if (v6)
    {
      v7 = v6;
      Count = CFArrayGetCount(v6);
      if (Count < 1)
      {
        v9 = 0;
      }
      else
      {
        v9 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v7, v9);
          v11 = *(_QWORD *)(a1 + 64);
          v12 = ValueAtIndex[8];
          if (v11 > v12)
            break;
          if (v11 == v12)
            goto LABEL_13;
          if (Count == ++v9)
            goto LABEL_14;
        }
        CFArrayInsertValueAtIndex(v7, v9, (const void *)a1);
      }
LABEL_13:
      if (v9 == Count)
LABEL_14:
        CFArrayAppendValue(v7, (const void *)a1);
    }
    else
    {
      v13 = CFGetAllocator(v4);
      Mutable = CFArrayCreateMutable(v13, 0, MEMORY[0x1E0C9B378]);
      CFArrayAppendValue(Mutable, (const void *)a1);
      CFDictionarySetValue(v4[7], Value, Mutable);
      CFRelease(Mutable);
    }
  }
}

void figRegistryAddItemsToResult(int a1, const __CFArray *a2, CFMutableArrayRef theArray)
{
  CFRange v4;

  v4.location = 0;
  v4.length = 1;
  CFArrayAppendArray(theArray, a2, v4);
}

double figRegistryItemInit(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

double figRegistryItemFinalize(_QWORD *a1)
{
  const void *v2;
  _OWORD *v3;
  uint64_t v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  double result;

  v3 = a1 + 2;
  v2 = (const void *)a1[2];
  if (v2)
    CFRelease(v2);
  v4 = a1[3];
  if (v4)
  {
    if (!CFBundleIsExecutableLoaded(*(CFBundleRef *)(v4 + 8)) || CFGetRetainCount(*(CFTypeRef *)(v4 + 8)) >= 2)
      CFRelease(*(CFTypeRef *)(v4 + 8));
    if (!FigAtomicDecrement32((unsigned int *)(v4 + 16)))
    {
      FigSimpleMutexDestroy(*(_QWORD *)v4);
      free((void *)v4);
    }
  }
  v5 = (const void *)a1[4];
  if (v5)
    CFRelease(v5);
  v6 = (const void *)a1[5];
  if (v6)
    CFRelease(v6);
  v7 = (const void *)a1[6];
  if (v7)
    CFRelease(v7);
  v8 = (const void *)a1[7];
  if (v8)
    CFRelease(v8);
  result = 0.0;
  v3[2] = 0u;
  v3[3] = 0u;
  *v3 = 0u;
  v3[1] = 0u;
  return result;
}

uint64_t figRegistryItemEqual(uint64_t a1, uint64_t a2)
{
  const void *Value;
  const void *v5;
  uint64_t result;

  if (*(_QWORD *)(a1 + 64) != *(_QWORD *)(a2 + 64))
    return 0;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("CMClassImplementationID"));
  v5 = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 16), CFSTR("CMClassImplementationID"));
  result = CFEqual(Value, v5);
  if ((_DWORD)result)
    return CFEqual(*(CFTypeRef *)(a1 + 32), *(CFTypeRef *)(a2 + 32)) != 0;
  return result;
}

CFHashCode figRegistryItemHash(uint64_t a1)
{
  CFHashCode v2;
  CFHashCode v3;
  uint64_t v4;
  double v5;
  long double v6;
  double v7;
  double v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  v2 = CFHash(*(CFTypeRef *)(a1 + 32));
  v3 = CFHash(*(CFTypeRef *)(a1 + 40));
  v4 = *(_QWORD *)(a1 + 64);
  v5 = -(double)v4;
  if (v4 >= 0)
    v5 = (double)v4;
  v6 = floor(v5 + 0.5);
  v7 = (v5 - v6) * 1.84467441e19;
  v8 = fmod(v6, 1.84467441e19);
  v9 = 2654435761u * (unint64_t)v8;
  v10 = v9 + (unint64_t)v7;
  if (v7 <= 0.0)
    v10 = 2654435761u * (unint64_t)v8;
  v11 = v9 - (unint64_t)fabs(v7);
  if (v7 >= 0.0)
    v11 = v10;
  return v3 ^ v2 ^ v11;
}

CFStringRef figRegistryItemCopyDebugDesc(CFTypeRef cf)
{
  uint64_t v2;
  __CFBundle *v3;
  const __CFURL *v4;
  const __CFAllocator *v5;
  const __CFString *v6;
  CFStringRef v7;
  char v8;
  uint64_t v9;
  const void *Value;
  const __CFString *v11;
  CFStringRef v12;

  v2 = *((_QWORD *)cf + 3);
  if (v2 && (v3 = *(__CFBundle **)(v2 + 8)) != 0)
  {
    v4 = CFBundleCopyBundleURL(*(CFBundleRef *)(v2 + 8));
    v5 = CFGetAllocator(cf);
    if (CFBundleIsExecutableLoaded(v3))
      v6 = CFSTR(" (loaded)");
    else
      v6 = &stru_1E28E82E0;
    if (v4)
    {
      v7 = CFURLGetString(v4);
      v8 = 0;
    }
    else
    {
      v7 = CFSTR("none");
      v8 = 1;
    }
  }
  else
  {
    v5 = CFGetAllocator(cf);
    v3 = 0;
    v4 = 0;
    v7 = CFSTR("none");
    v8 = 1;
    v6 = &stru_1E28E82E0;
  }
  v9 = *((_QWORD *)cf + 4);
  Value = CFDictionaryGetValue(*((CFDictionaryRef *)cf + 2), CFSTR("CMClassImplementationID"));
  v11 = (const __CFString *)*((_QWORD *)cf + 6);
  if (!v11)
    v11 = &stru_1E28E82E0;
  v12 = CFStringCreateWithFormat(v5, 0, CFSTR("<FigRegistryItem %p> {\n\tBundle: %p%@\n\tBundle URL: %@\n\tClass ID: %@\n\tClass Implementation ID: %@\n\tObject name: %@\n\tVersion: %lld\n\tFactory function name: %@\n\tFactory function: %p\n}"), cf, v3, v6, v7, v9, Value, *((_QWORD *)cf + 5), *((_QWORD *)cf + 8), v11, *((_QWORD *)cf + 9));
  if ((v8 & 1) == 0)
    CFRelease(v4);
  return v12;
}

double figRegistryInit(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

double figRegistryFinalize(_QWORD *a1)
{
  const void *v2;
  _OWORD *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  uint64_t v8;
  double result;

  v3 = a1 + 2;
  v2 = (const void *)a1[2];
  if (v2)
    CFRelease(v2);
  v4 = (const void *)a1[3];
  if (v4)
    CFRelease(v4);
  v5 = (const void *)a1[4];
  if (v5)
    CFRelease(v5);
  v6 = (const void *)a1[5];
  if (v6)
    CFRelease(v6);
  v7 = (const void *)a1[7];
  if (v7)
    CFRelease(v7);
  v8 = a1[6];
  if (v8)
    FigReentrantMutexDestroy(v8);
  result = 0.0;
  v3[1] = 0u;
  v3[2] = 0u;
  *v3 = 0u;
  return result;
}

CFStringRef figRegistryCopyDebugDesc(_QWORD *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<FigRegistry %p> {\n\tClass ID: %@\n}"), a1, a1[2]);
}

uint64_t registryCacheInitOnce()
{
  uint64_t v0;

  sRegistryCache = (uint64_t)CFDictionaryCreateMutable((CFAllocatorRef)qword_1EE140278, 0, MEMORY[0x1E0C9B390], 0);
  if (sRegistryCache)
  {
    qword_1EE140280 = (uint64_t)FigSimpleMutexCreate();
    if (qword_1EE140280)
      return 0;
  }
  v0 = FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
  if ((_DWORD)v0 && sRegistryCache)
  {
    CFRelease((CFTypeRef)sRegistryCache);
    sRegistryCache = 0;
  }
  return v0;
}

void registryCacheClearClass(int a1, CFMutableSetRef theSet)
{
  CFSetRemoveAllValues(theSet);
}

void registryCacheProcessBundle(__CFBundle *a1, uint64_t a2)
{
  unsigned int v4;
  const __CFArray *ValueForInfoDictionaryKey;
  const __CFArray *v6;
  CFTypeID v7;
  CFIndex Count;
  char *v9;
  CFIndex v10;
  void *ValueAtIndex;
  CFTypeID v12;
  const void *Value;
  const void *v14;
  CFTypeID v15;
  const __CFAllocator *v16;
  const __CFAllocator *v17;
  CFMutableDictionaryRef MutableCopy;
  CFMutableDictionaryRef v19;
  const void *v20;
  const __CFArray *v21;
  const __CFArray *v22;
  CFTypeID v23;
  int v24;
  const void **v25;
  void *v26;
  CFMutableSetRef Mutable;
  unsigned int *v28;
  CFDictionaryRef *v29;
  const void *v30;
  uint64_t *v31;
  CFTypeRef cf;

  v4 = *(unsigned __int8 *)(a2 + 16);
  ValueForInfoDictionaryKey = (const __CFArray *)CFBundleGetValueForInfoDictionaryKey(a1, CFSTR("CMClassImplementations"));
  if (ValueForInfoDictionaryKey)
  {
    v6 = ValueForInfoDictionaryKey;
    v7 = CFGetTypeID(ValueForInfoDictionaryKey);
    if (v7 == CFArrayGetTypeID())
    {
      v29 = (CFDictionaryRef *)a2;
      Count = CFArrayGetCount(v6);
      v9 = (char *)malloc_type_calloc(1uLL, 0x18uLL, 0x10200404B2C534EuLL);
      *((_QWORD *)v9 + 1) = a1;
      v9[20] = v4 & 1;
      *((_DWORD *)v9 + 4) = 1;
      v28 = (unsigned int *)(v9 + 16);
      v31 = (uint64_t *)v9;
      *(_QWORD *)v9 = FigSimpleMutexCreate();
      if (Count >= 1)
      {
        v10 = 0;
        v30 = (const void *)*MEMORY[0x1E0C9AE50];
        while (1)
        {
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(v6, v10);
          v12 = CFGetTypeID(ValueAtIndex);
          if (v12 == CFDictionaryGetTypeID())
            break;
LABEL_33:
          if (Count == ++v10)
            goto LABEL_39;
        }
        if ((((v4 >> 1) | (v4 >> 2) | (v4 >> 3)) & 1) == 0
          || (Value = CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, CFSTR("CMMatchingInfo"))) == 0
          || (v14 = Value, v15 = CFGetTypeID(Value), v15 != CFDictionaryGetTypeID()))
        {
          v20 = 0;
          goto LABEL_17;
        }
        v16 = CFGetAllocator(ValueAtIndex);
        ValueAtIndex = FigCFDictionaryCreateMutableCopy(v16, (CFDictionaryRef)ValueAtIndex);
        v17 = CFGetAllocator(v14);
        MutableCopy = FigCFDictionaryCreateMutableCopy(v17, (CFDictionaryRef)v14);
        v19 = MutableCopy;
        if ((v4 & 2) != 0)
        {
          FigCFDictionarySetValue(MutableCopy, CFSTR("IsProWorkflowPlugin"), v30);
          if ((v4 & 4) == 0)
          {
LABEL_11:
            if ((v4 & 8) == 0)
            {
LABEL_13:
              FigCFDictionarySetValue(ValueAtIndex, CFSTR("CMMatchingInfo"), v19);
              if (v19)
                CFRelease(v19);
              v20 = ValueAtIndex;
LABEL_17:
              cf = 0;
              v21 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, CFSTR("CMExecutableArchitectures"));
              if (!v21
                || (v22 = v21, v23 = CFGetTypeID(v21), v23 != CFArrayGetTypeID())
                || !FigCFArrayContainsValue(v22, CFSTR("arm64"))
                && (!CFEqual(CFSTR("arm64e"), CFSTR("arm64"))
                 || !FigCFArrayContainsValue(v22, CFSTR("arm64"))))
              {
LABEL_31:
                if (v20)
                  CFRelease(v20);
                goto LABEL_33;
              }
              v24 = figRegistryItemCreate((const __CFAllocator *)qword_1EE140278, (uint64_t)v31, 0, (CFDictionaryRef)ValueAtIndex, &cf);
              v25 = (const void **)cf;
              if (v24)
              {
                if (!cf)
                  goto LABEL_31;
              }
              else
              {
                v26 = (void *)CFDictionaryGetValue(*v29, *((const void **)cf + 4));
                if (!v26)
                {
                  Mutable = CFSetCreateMutable((CFAllocatorRef)qword_1EE140278, 0, MEMORY[0x1E0C9B3B0]);
                  if (!Mutable)
                  {
                    FigSignalErrorAt(4294954603, 0, 0, 0, 0, 0, 0);
                    goto LABEL_30;
                  }
                  v26 = Mutable;
                  CFDictionaryAddValue(*v29, v25[4], Mutable);
                  CFRelease(v26);
                }
                CFSetAddValue((CFMutableSetRef)v26, v25);
              }
LABEL_30:
              CFRelease(v25);
              goto LABEL_31;
            }
LABEL_12:
            FigCFDictionarySetValue(v19, CFSTR("IsPreferredInternalPlugin"), v30);
            goto LABEL_13;
          }
        }
        else if ((v4 & 4) == 0)
        {
          goto LABEL_11;
        }
        FigCFDictionarySetValue(v19, CFSTR("IsAppExclusivePlugin"), v30);
        if ((v4 & 8) == 0)
          goto LABEL_13;
        goto LABEL_12;
      }
LABEL_39:
      if (!FigAtomicDecrement32(v28))
      {
        FigSimpleMutexDestroy(*v31);
        free(v31);
      }
    }
  }
  CFRelease(a1);
}

uint64_t FigEndpointGetClassID()
{
  if (FigEndpointGetClassID_sRegisterFigEndpointBaseTypeOnce != -1)
    dispatch_once_f(&FigEndpointGetClassID_sRegisterFigEndpointBaseTypeOnce, &FigEndpointGetClassID_sFigEndpointClassID, (dispatch_function_t)FigEndpointGetClassIDCallback);
  return FigEndpointGetClassID_sFigEndpointClassID;
}

uint64_t FigEndpointGetClassIDCallback(_QWORD *a1)
{
  _QWORD *ClassID;

  ClassID = CMBaseGetClassID();
  return FigBaseClassRegisterClass((uint64_t)&FigEndpointGetClassIDCallback_sFigEndpointClassDesc, ClassID, 1, a1);
}

uint64_t FigEndpointGetTypeID()
{
  if (FigEndpointGetClassID_sRegisterFigEndpointBaseTypeOnce != -1)
    dispatch_once_f(&FigEndpointGetClassID_sRegisterFigEndpointBaseTypeOnce, &FigEndpointGetClassID_sFigEndpointClassID, (dispatch_function_t)FigEndpointGetClassIDCallback);
  return CMBaseClassGetCFTypeID((_QWORD *)FigEndpointGetClassID_sFigEndpointClassID);
}

CFStringRef FigEndpointBaseCopyFormattingDesc(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("[FigEndpoint %p]"), a1);
}

uint64_t FigHALAudioConduitDeviceGetTypeID()
{
  FigThreadRunOnce(&FigHALAudioConduitDeviceGetTypeID_sRegisterFigHALAudioConduitDeviceOnce, (void (*)(void))registerFigHALAudioConduitDevice);
  return sFigHALAudioConduitDeviceID;
}

uint64_t registerFigHALAudioConduitDevice()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigHALAudioConduitDeviceID = result;
  return result;
}

uint64_t FigHALAudioConduitDeviceCreate(uint64_t a1, const void *a2, const __CFDictionary *a3, uint64_t *a4)
{
  unsigned int v7;
  uint64_t Instance;
  uint64_t v9;
  pthread_mutex_t *v10;
  pthread_mutex_t *v11;
  const void *v12;
  const void *StringValue;
  const void *v14;
  const void *v15;
  CFTypeRef v16;
  uint64_t result;

  v7 = FigNote_AllowInternalDefaultLogs() != 0;
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigHALAudioConduitDeviceTrace[1], CFSTR("fhacd_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", v7, 0, gFigHALAudioConduitDeviceTrace);
  fig_note_initialize_category_with_default_work_cf((uint64_t)&gFigHALAudioConduitDeviceTrace[3], CFSTR("fhacd_trace"), CFSTR("com.apple.coremedia"), (uint64_t)"", (uint64_t)"com.apple.coremedia", 1u, 0, &gFigHALAudioConduitDeviceTrace[2]);
  if (!a2 || !a4)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  FigThreadRunOnce(&FigHALAudioConduitDeviceGetTypeID_sRegisterFigHALAudioConduitDeviceOnce, (void (*)(void))registerFigHALAudioConduitDevice);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return 4294954510;
  v9 = Instance;
  v10 = FigSimpleMutexCreate();
  *(_QWORD *)(v9 + 168) = v10;
  if (!v10 || (v11 = FigSimpleMutexCreate(), (*(_QWORD *)(v9 + 80) = v11) == 0))
  {
    CFRelease((CFTypeRef)v9);
    return 4294954510;
  }
  *(_WORD *)(v9 + 128) = 0;
  v12 = (const void *)*MEMORY[0x1E0C9AE50];
  *(_BYTE *)(v9 + 130) = v12 == FigCFDictionaryGetBooleanValue(a3, CFSTR("ForTest"));
  *(_QWORD *)(v9 + 136) = CFRetain(a2);
  StringValue = FigCFDictionaryGetStringValue(a3, CFSTR("DeviceName"));
  if (StringValue)
    StringValue = CFRetain(StringValue);
  *(_QWORD *)(v9 + 144) = StringValue;
  v14 = FigCFDictionaryGetStringValue(a3, CFSTR("DeviceUID"));
  if (v14)
    v14 = CFRetain(v14);
  *(_QWORD *)(v9 + 160) = v14;
  v15 = FigCFDictionaryGetStringValue(a3, CFSTR("ModelUID"));
  if (v15)
    v16 = CFRetain(v15);
  else
    v16 = 0;
  result = 0;
  *(_QWORD *)(v9 + 152) = v16;
  *a4 = v9;
  return result;
}

uint64_t FigHALAudioConduitDeviceSetClientReceiveAudioIODelegate(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 168));
  if (*(_BYTE *)(a1 + 129))
  {
    v7 = 4294954514;
  }
  else
  {
    FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 80));
    if (a2)
    {
      v4 = *a2;
      v5 = a2[1];
      v6 = a2[2];
      *(_OWORD *)(a1 + 60) = *(__int128 *)((char *)a2 + 44);
      *(_OWORD *)(a1 + 32) = v5;
      *(_OWORD *)(a1 + 48) = v6;
    }
    else
    {
      v4 = 0uLL;
      *(_OWORD *)(a1 + 60) = 0u;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)(a1 + 48) = 0u;
    }
    *(_OWORD *)(a1 + 16) = v4;
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 80));
    v7 = 0;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
  return v7;
}

uint64_t FigHALAudioConduitDeviceSetClientControlIODelegate(uint64_t a1, __int128 *a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 168));
  if (*(_BYTE *)(a1 + 129))
  {
    v4 = 4294954514;
  }
  else
  {
    v4 = 0;
    if (a2)
    {
      v5 = *a2;
      v6 = a2[1];
      *(_QWORD *)(a1 + 120) = *((_QWORD *)a2 + 4);
      *(_OWORD *)(a1 + 104) = v6;
    }
    else
    {
      *(_QWORD *)(a1 + 120) = 0;
      v5 = 0uLL;
      *(_OWORD *)(a1 + 104) = 0u;
    }
    *(_OWORD *)(a1 + 88) = v5;
  }
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
  return v4;
}

uint64_t FigHALAudioConduitDeviceResume(uint64_t a1)
{
  __CFDictionary *Mutable;
  CFTypeRef v3;
  uint64_t (*v4)(CFTypeRef, _QWORD, _QWORD, _QWORD, __CFDictionary *);
  uint64_t v5;
  CFTypeRef cf;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 168));
  if (*(_BYTE *)(a1 + 128))
  {
    v5 = 4294954514;
    goto LABEL_13;
  }
  cf = 0;
  if (*(_BYTE *)(a1 + 130))
    goto LABEL_12;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, CFSTR("ConduitDeviceOption_Conduit"), (const void *)a1);
  FigHALAudioDeviceBrokerCopy(*(const void **)(a1 + 136), &cf);
  v3 = cf;
  if (cf)
  {
    v4 = *(uint64_t (**)(CFTypeRef, _QWORD, _QWORD, _QWORD, __CFDictionary *))(*(_QWORD *)(CMBaseObjectGetVTable((uint64_t)cf) + 16)
                                                                                       + 8);
    if (v4)
    {
      v5 = v4(v3, 0, 0, 0, Mutable);
      if (!Mutable)
        goto LABEL_9;
    }
    else
    {
      v5 = 4294954514;
      if (!Mutable)
        goto LABEL_9;
    }
LABEL_8:
    CFRelease(Mutable);
    goto LABEL_9;
  }
  v5 = 4294949690;
  if (Mutable)
    goto LABEL_8;
LABEL_9:
  if (cf)
    CFRelease(cf);
  if (!(_DWORD)v5)
  {
LABEL_12:
    v5 = 0;
    *(_BYTE *)(a1 + 128) = 1;
  }
LABEL_13:
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
  return v5;
}

uint64_t FigHALAudioConduitDeviceSuspendAndInvalidate(uint64_t a1)
{
  __CFNotificationCenter *DefaultLocalCenter;
  uint64_t v3;

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 168));
  if (*(_BYTE *)(a1 + 129))
  {
    v3 = 0;
LABEL_7:
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
    return v3;
  }
  *(_BYTE *)(a1 + 129) = 1;
  if (*(_BYTE *)(a1 + 128) != 1)
  {
    v3 = 4294954514;
    goto LABEL_7;
  }
  *(_BYTE *)(a1 + 128) = 0;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
  DefaultLocalCenter = CMNotificationCenterGetDefaultLocalCenter();
  CMNotificationCenterPostNotification(DefaultLocalCenter, CFSTR("Suspended"), (const void *)a1, 0);
  return 0;
}

uint64_t FigHALAudioConduitDeviceHALSendAudio(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void (*v10)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t);

  if (FigSimpleMutexTryLock(*(pthread_mutex_t **)(a1 + 168)))
  {
    if (*(_BYTE *)(a1 + 128) && !*(_BYTE *)(a1 + 129) && FigSimpleMutexTryLock(*(pthread_mutex_t **)(a1 + 80)))
    {
      v10 = *(void (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 60);
      if (v10)
        v10(*(_QWORD *)(a1 + 68), a2, a3, a4, a5);
      FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 80));
    }
    FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
  }
  return 0;
}

uint64_t FigHALAudioConduitDeviceCopyProperty(uint64_t a1, CFTypeRef cf1, const __CFAllocator *a3, _QWORD *a4)
{
  CFNumberRef SInt32;
  CFTypeRef v9;
  uint64_t result;
  const void *v11;

  if (!cf1 || !a4)
    return FigSignalErrorAt(4294954516, 0, 0, 0, 0, 0, 0);
  if (!CFEqual(cf1, CFSTR("HALSendAudioFormat")))
  {
    if (CFEqual(cf1, CFSTR("HALSendDesiredNumberPackets")))
    {
      FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 80));
      SInt32 = FigCFNumberCreateSInt32(a3, *(_DWORD *)(a1 + 56));
      goto LABEL_7;
    }
    if (CFEqual(cf1, CFSTR("DeviceName")))
    {
      v11 = *(const void **)(a1 + 144);
      if (v11)
        goto LABEL_11;
    }
    else if (CFEqual(cf1, CFSTR("DeviceUID")))
    {
      v11 = *(const void **)(a1 + 160);
      if (v11)
        goto LABEL_11;
    }
    else
    {
      if (!CFEqual(cf1, CFSTR("ModelUID")))
        return 4294954512;
      v11 = *(const void **)(a1 + 152);
      if (v11)
      {
LABEL_11:
        v9 = CFRetain(v11);
        goto LABEL_8;
      }
    }
    v9 = 0;
    goto LABEL_8;
  }
  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 80));
  SInt32 = CFDataCreate(a3, (const UInt8 *)(a1 + 16), 40);
LABEL_7:
  v9 = SInt32;
  FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 80));
  if (v9)
  {
LABEL_8:
    result = 0;
    *a4 = v9;
    return result;
  }
  return 4294954510;
}

uint64_t FigHALAudioConduitDeviceHALStartIO(uint64_t a1, uint64_t a2)
{
  figHALAudioConduitDeviceCallControlIODelegate(a1, 1, a2);
  return 0;
}

uint64_t figHALAudioConduitDeviceCallControlIODelegate(uint64_t a1, int a2, uint64_t a3)
{
  void (*v6)(_QWORD, uint64_t);

  FigSimpleMutexLock(*(pthread_mutex_t **)(a1 + 168));
  if (*(_BYTE *)(a1 + 128) && !*(_BYTE *)(a1 + 129))
  {
    switch(a2)
    {
      case 1:
        v6 = *(void (**)(_QWORD, uint64_t))(a1 + 88);
        if (v6)
          goto LABEL_11;
        break;
      case 2:
        v6 = *(void (**)(_QWORD, uint64_t))(a1 + 96);
        if (v6)
          goto LABEL_11;
        break;
      case 3:
        v6 = *(void (**)(_QWORD, uint64_t))(a1 + 104);
        if (v6)
          goto LABEL_11;
        break;
      case 4:
        v6 = *(void (**)(_QWORD, uint64_t))(a1 + 112);
        if (v6)
LABEL_11:
          v6(*(_QWORD *)(a1 + 120), a3);
        break;
      default:
        return FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
    }
  }
  return FigSimpleMutexUnlock(*(pthread_mutex_t **)(a1 + 168));
}

uint64_t FigHALAudioConduitDeviceHALStopIO(uint64_t a1, uint64_t a2)
{
  figHALAudioConduitDeviceCallControlIODelegate(a1, 2, a2);
  return 0;
}

uint64_t FigHALAudioConduitDeviceHALStartStream(uint64_t a1, uint64_t a2)
{
  figHALAudioConduitDeviceCallControlIODelegate(a1, 3, a2);
  return 0;
}

uint64_t FigHALAudioConduitDeviceHALStopStream(uint64_t a1, uint64_t a2)
{
  figHALAudioConduitDeviceCallControlIODelegate(a1, 4, a2);
  return 0;
}

double FigHALAudioConduitDeviceInit(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[9] = 0u;
  a1[10] = 0u;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void FigHALAudioConduitDeviceFinalize(uint64_t *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  FigSimpleMutexDestroy(a1[10]);
  FigSimpleMutexDestroy(a1[21]);
  v2 = (const void *)a1[17];
  if (v2)
    CFRelease(v2);
  v3 = (const void *)a1[20];
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[18];
  if (v4)
    CFRelease(v4);
  v5 = (const void *)a1[19];
  if (v5)
    CFRelease(v5);
}

__CFString *FigHALAudioConduitDeviceCopyDebugDesc(const void *a1)
{
  const __CFAllocator *v1;
  __CFString *Mutable;

  v1 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v1, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("FigHALAudioConduitDevice"));
  return Mutable;
}

uint64_t FigGeometryMappingGetTypeID()
{
  if (sRegisterFigGeometryMappingTypeOnce != -1)
    dispatch_once_f(&sRegisterFigGeometryMappingTypeOnce, 0, (dispatch_function_t)RegisterFigGeometryMappingType);
  return sFigGeometryMappingID;
}

uint64_t RegisterFigGeometryMappingType()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  sFigGeometryMappingID = result;
  return result;
}

uint64_t FigGeometryMappingGetSourceUnits(uint64_t a1, _OWORD *a2)
{
  __int128 v2;

  if (!a1)
    return FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  if (a2)
  {
    v2 = *(_OWORD *)(a1 + 72);
    *a2 = *(_OWORD *)(a1 + 56);
    a2[1] = v2;
  }
  return 0;
}

uint64_t FigGeometryMappingGetDestinationUnits(uint64_t a1, _OWORD *a2)
{
  __int128 v2;

  if (!a1)
    return FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  if (a2)
  {
    v2 = *(_OWORD *)(a1 + 104);
    *a2 = *(_OWORD *)(a1 + 88);
    a2[1] = v2;
  }
  return 0;
}

uint64_t FigGeometryMappingCreate(uint64_t a1, const void *a2, int a3, const void *a4, int a5, uint64_t *a6)
{
  uint64_t Instance;
  uint64_t v12;
  int v13;
  double v14;
  double v15;
  double v16;
  double v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v22;
  int v23;
  uint64_t v24;
  double v25;
  double v26;
  CGFloat v27;
  double v28;
  CGFloat v29;
  double v30;
  CGFloat v31;
  double v32;
  double v33;
  double v34;
  CGFloat v35;
  double v36;
  CGFloat v37;
  double MinX;
  double v39;
  CGFloat v40;
  CGFloat v41;
  double MinY;
  double MaxY;
  double v44;
  CGFloat v45;
  uint64_t v46;
  double MaxX;
  CGFloat v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  CGFloat v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  _OWORD v64[22];
  _OWORD __src[22];
  uint64_t v66;
  int v67;
  __int128 v68;
  __int128 v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;
  uint64_t v76;
  CGRect v77;
  CGRect v78;
  CGRect v79;
  CGRect v80;
  CGRect v81;
  CGRect v82;
  CGRect v83;
  CGRect v84;

  v76 = *MEMORY[0x1E0C80C00];
  v73 = 0u;
  v74 = 0u;
  v75 = 0;
  v71 = 0;
  v72 = 0;
  v68 = 0u;
  v69 = 0u;
  v70 = 0;
  v66 = 0;
  v67 = 0;
  if (!a2 || !a4 || (a3 - 3) <= 0xFFFFFFFD || (a5 - 3) <= 0xFFFFFFFD || !a6)
  {
    v20 = 4294949966;
    return FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
  }
  *a6 = 0;
  if (sRegisterFigGeometryMappingTypeOnce != -1)
    dispatch_once_f(&sRegisterFigGeometryMappingTypeOnce, 0, (dispatch_function_t)RegisterFigGeometryMappingType);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    v20 = 4294949965;
    return FigSignalErrorAt(v20, 0, 0, 0, 0, 0, 0);
  }
  v12 = Instance;
  memset(__src, 0, sizeof(__src));
  *(_QWORD *)(Instance + 16) = 0x16D617070;
  *(_QWORD *)(Instance + 128) = CFRetain(a2);
  *(_QWORD *)(v12 + 136) = CFRetain(a4);
  *(_BYTE *)(v12 + 120) = 0;
  *(_OWORD *)(v12 + 24) = kFigGeometryAffineTransform1DIdentity;
  *(_OWORD *)(v12 + 40) = kFigGeometryAffineTransform1DIdentity;
  *(_OWORD *)(v12 + 56) = kFigGeometrySizeZero;
  *(_OWORD *)(v12 + 72) = unk_18EDDC9A8;
  *(_OWORD *)(v12 + 88) = kFigGeometrySizeZero;
  *(_OWORD *)(v12 + 104) = unk_18EDDC9A8;
  if (_figUpdateCoordinateSpaceGeometryCache((uint64_t)a2, (uint64_t)__src))
  {
    memset(v64, 0, sizeof(v64));
    if (_figUpdateCoordinateSpaceGeometryCache((uint64_t)a4, (uint64_t)v64))
    {
      memcpy((void *)(v12 + 144), __src, 0x160uLL);
      memcpy((void *)(v12 + 496), v64, 0x160uLL);
      *(_DWORD *)(v12 + 848) = a3;
      *(_DWORD *)(v12 + 852) = a5;
      if (a3 == 2)
      {
        if (a5 == 2)
        {
          v73 = __src[0];
          v74 = __src[1];
          v75 = *(_QWORD *)&__src[2];
          v71 = *(_QWORD *)((char *)&__src[2] + 12);
          v13 = DWORD2(__src[2]);
          v72 = DWORD1(__src[3]);
          v22 = *((_QWORD *)&__src[3] + 1);
          v70 = *(_QWORD *)&v64[2];
          v68 = v64[0];
          v69 = v64[1];
          v23 = DWORD2(v64[2]);
          v67 = DWORD1(v64[3]);
          v66 = *(_QWORD *)((char *)&v64[2] + 12);
          v24 = *((_QWORD *)&v64[3] + 1);
          goto LABEL_25;
        }
        if (a5 == 1)
        {
          v53 = __src[16];
          v54 = __src[17];
          v55 = __src[18];
          v56 = __src[19];
          _figApplyNormalizedCGRectToFigGeometryRect(&v53, (uint64_t)&v57, *(double *)&v64[20], *((double *)&v64[20] + 1), *(double *)&v64[21], *((double *)&v64[21] + 1));
          v73 = v57;
          v74 = v58;
          v75 = v59;
          v13 = v60;
          v71 = v61;
          v72 = v62;
          v22 = v63;
          v68 = v64[12];
          v69 = v64[13];
          v70 = *(_QWORD *)&v64[14];
          v23 = DWORD2(v64[14]);
          v67 = DWORD1(v64[15]);
          v66 = *(_QWORD *)((char *)&v64[14] + 12);
          v24 = *((_QWORD *)&v64[15] + 1);
LABEL_25:
          v50 = v22;
          v51 = v24;
          v57 = v73;
          v58 = v74;
          v59 = v75;
          v60 = v13;
          v61 = v71;
          v62 = v72;
          v63 = v22;
          v25 = FigGeometryRectGetCGRect((uint64_t)&v57);
          v27 = v26;
          v48 = v26;
          v29 = v28;
          v31 = v30;
          v57 = v68;
          v58 = v69;
          v59 = v70;
          v60 = v23;
          v61 = v66;
          v62 = v67;
          v63 = v51;
          v32 = FigGeometryRectGetCGRect((uint64_t)&v57);
          v52 = v33;
          v35 = v34;
          v37 = v36;
          v77.origin.x = v25;
          v77.origin.y = v27;
          v77.size.width = v29;
          v77.size.height = v31;
          MinX = CGRectGetMinX(v77);
          v78.origin.x = v25;
          v78.origin.y = v27;
          v78.size.width = v29;
          v78.size.height = v31;
          MaxX = CGRectGetMaxX(v78);
          v79.origin.x = v32;
          v79.origin.y = v52;
          v79.size.width = v35;
          v79.size.height = v37;
          v39 = CGRectGetMinX(v79);
          v80.origin.x = v32;
          v80.origin.y = v52;
          v80.size.width = v35;
          v80.size.height = v37;
          v40 = (CGRectGetMaxX(v80) - v39) / (MaxX - MinX);
          *(CGFloat *)(v12 + 24) = v40;
          *(double *)(v12 + 32) = v39 - MinX * v40;
          v41 = v25;
          v81.origin.x = v25;
          v81.origin.y = v48;
          v81.size.width = v29;
          v81.size.height = v31;
          MinY = CGRectGetMinY(v81);
          v82.origin.x = v41;
          v82.origin.y = v48;
          v82.size.width = v29;
          v82.size.height = v31;
          MaxY = CGRectGetMaxY(v82);
          v83.origin.x = v32;
          v83.origin.y = v52;
          v83.size.width = v35;
          v83.size.height = v37;
          v44 = CGRectGetMinY(v83);
          v84.origin.x = v32;
          v84.origin.y = v52;
          v84.size.width = v35;
          v84.size.height = v37;
          v45 = (CGRectGetMaxY(v84) - v44) / (MaxY - MinY);
          *(CGFloat *)(v12 + 40) = v45;
          *(double *)(v12 + 48) = v44 - MinY * v45;
          *(_DWORD *)(v12 + 64) = v13;
          *(_DWORD *)(v12 + 80) = v50;
          *(_DWORD *)(v12 + 96) = v23;
          *(_DWORD *)(v12 + 112) = v51;
          *a6 = v12;
          return 0;
        }
      }
      else if (a3 == 1)
      {
        if (a5 == 2)
        {
          v73 = __src[12];
          v74 = __src[13];
          v75 = *(_QWORD *)&__src[14];
          v71 = *(_QWORD *)((char *)&__src[14] + 12);
          v13 = DWORD2(__src[14]);
          v72 = DWORD1(__src[15]);
          v49 = *((_QWORD *)&__src[15] + 1);
          v15 = *((double *)&__src[20] + 1);
          v14 = *(double *)&__src[20];
          v17 = *((double *)&__src[21] + 1);
          v16 = *(double *)&__src[21];
          v53 = v64[0];
          v54 = v64[1];
          v18 = v64[2];
          v19 = v64[3];
          goto LABEL_23;
        }
        if (a5 == 1)
        {
          v73 = __src[12];
          v74 = __src[13];
          v75 = *(_QWORD *)&__src[14];
          v71 = *(_QWORD *)((char *)&__src[14] + 12);
          v13 = DWORD2(__src[14]);
          v72 = DWORD1(__src[15]);
          v49 = *((_QWORD *)&__src[15] + 1);
          v15 = *((double *)&__src[20] + 1);
          v14 = *(double *)&__src[20];
          v17 = *((double *)&__src[21] + 1);
          v16 = *(double *)&__src[21];
          v53 = v64[16];
          v54 = v64[17];
          v18 = v64[18];
          v19 = v64[19];
LABEL_23:
          v55 = v18;
          v56 = v19;
          _figApplyNormalizedCGRectToFigGeometryRect(&v53, (uint64_t)&v57, v14, v15, v16, v17);
          v22 = v49;
          v68 = v57;
          v69 = v58;
          v70 = v59;
          v23 = v60;
          v66 = v61;
          v67 = v62;
          v24 = v63;
          goto LABEL_25;
        }
      }
      v23 = 0;
      v13 = 0;
      v22 = 0;
      v24 = 0;
      goto LABEL_25;
    }
  }
  v46 = FigSignalErrorAt(4294949966, 0, 0, 0, 0, 0, 0);
  CFRelease((CFTypeRef)v12);
  return v46;
}

uint64_t _figUpdateCoordinateSpaceGeometryCache(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t result;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  int v8;
  uint64_t *v9;
  int v10;
  int v11;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  double v20;
  int v21;
  int v22;
  double v23;
  int v24;
  double v25;
  int v26;
  int v27;
  double v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  double x;
  double y;
  double width;
  double height;
  double MaxY;
  BOOL v39;
  double v40;
  double v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  uint64_t v50;
  int v51;
  double v52;
  double v53;
  CGFloat v54;
  CGFloat v55;
  double v56;
  double v57;
  double v58;
  double v59;
  double v60;
  double v61;
  CGFloat v62;
  CGFloat v63;
  CGFloat v64;
  double MinX;
  CGFloat v66;
  double v67;
  CGFloat v68;
  double v69;
  double v70;
  CGFloat v71;
  double v72;
  CGFloat v73;
  double v74;
  double v75;
  double v76;
  CGFloat v77;
  double v78;
  CGFloat v79;
  CGFloat v80;
  double v81;
  CGFloat v82;
  CGFloat v83;
  double v84;
  double v85;
  double v86;
  CGFloat v87;
  CGFloat v88;
  double v89;
  double v90;
  double v91;
  double v92;
  CGFloat v93;
  double v94;
  double v95;
  double v96;
  double v97;
  CGFloat v98;
  CGFloat v99;
  double v100;
  double v101;
  double v102;
  CGFloat v103;
  double v104;
  double v105;
  double v106;
  CGFloat v107;
  CGFloat v108;
  double v109;
  double v110;
  double v111;
  double v112;
  CGFloat v113;
  double MinY;
  __int128 v115;
  __int128 v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  double v124;
  double v125;
  double v126;
  double v127;
  double v128;
  double v129;
  double v130;
  double v131;
  double v132;
  double v133;
  double v134;
  double v135;
  double v136;
  double v137;
  double v138;
  double v139;
  double v140;
  double v141;
  double v142;
  double v143;
  double v144;
  double v145;
  double v146;
  int v147;
  int v148;
  int v149;
  int v150;
  int v151;
  int v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  CGFloat v159;
  double v160;
  CGFloat v161;
  double v162;
  double rect;
  double rectd;
  double recte;
  CGFloat recta;
  double rectf;
  double rectb;
  double rectg;
  double recth;
  double rectc;
  double recti;
  double rectj;
  CGFloat v174;
  CGFloat v175;
  CGFloat v176;
  CGFloat v177;
  double v178;
  uint64_t v179;
  int v180;
  double MaxX;
  int v182;
  int v183;
  int v184;
  int v185;
  uint64_t v186;
  int v187;
  int v188;
  int v189;
  int v190;
  int v191;
  uint64_t v192;
  uint64_t v193;
  int v194;
  uint64_t v195;
  int v196;
  int v197;
  uint64_t v198;
  int v199;
  int v200;
  uint64_t v201;
  int v202;
  int v203;
  int v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  _BYTE v213[64];
  uint64_t v214;
  int v215;
  uint64_t v216;
  int v217;
  uint64_t v218;
  int v219;
  uint64_t v220;
  int v221;
  uint64_t v222;
  int v223;
  uint64_t v224;
  int v225;
  uint64_t v226;
  int v227;
  uint64_t v228;
  int v229;
  uint64_t v230;
  int v231;
  uint64_t v232;
  int v233;
  uint64_t v234;
  int v235;
  uint64_t v236;
  int v237;
  uint64_t v238;
  int v239;
  uint64_t v240;
  int v241;
  uint64_t v242;
  int v243;
  uint64_t v244;
  int v245;
  uint64_t v246;
  int v247;
  uint64_t v248;
  int v249;
  uint64_t v250;
  CGRect v251;
  CGRect v252;
  CGRect v253;
  CGRect v254;
  CGRect v255;
  CGRect v256;
  CGRect v257;
  CGRect v258;
  CGRect v259;
  CGRect v260;
  CGRect v261;
  CGRect v262;
  CGRect v263;
  CGRect v264;
  CGRect v265;
  CGRect v266;
  CGRect v267;
  CGRect v268;
  CGRect v269;
  CGRect v270;
  CGRect v271;
  CGRect v272;
  CGRect v273;
  CGRect v274;
  CGRect v275;
  CGRect v276;
  CGRect v277;
  CGRect v278;
  CGRect v279;
  CGRect v280;
  CGRect v281;
  CGRect v282;
  CGRect v283;
  CGRect v284;
  CGRect v285;
  CGRect v286;
  CGRect v287;
  CGRect v288;
  CGRect v289;
  CGRect v290;
  CGRect v291;
  CGRect v292;
  CGRect v293;
  CGRect v294;
  CGRect v295;
  CGRect v296;
  CGRect v297;

  v250 = *MEMORY[0x1E0C80C00];
  v248 = 0;
  v249 = 0;
  v246 = 0;
  v247 = 0;
  v244 = 0;
  v245 = 0;
  v242 = 0;
  v243 = 0;
  v240 = 0;
  v241 = 0;
  v238 = 0;
  v239 = 0;
  v209 = 0u;
  v210 = 0u;
  v211 = 0u;
  v212 = 0u;
  v207 = 0u;
  v208 = 0u;
  v205 = 0u;
  v206 = 0u;
  v2 = *(_DWORD *)(a1 + 16);
  v224 = 0;
  v225 = 0;
  v222 = 0;
  v223 = 0;
  v220 = 0;
  v221 = 0;
  if ((v2 & 1) == 0)
    return 0;
  result = 0;
  v5 = (uint64_t *)(a1 + 68);
  v6 = *(_QWORD *)(a1 + 68);
  v7 = (uint64_t *)(a1 + 36);
  v248 = *(_QWORD *)(a1 + 36);
  v8 = *(_DWORD *)(a1 + 48);
  v249 = *(_DWORD *)(a1 + 44);
  v9 = (uint64_t *)(a1 + 52);
  v246 = *(_QWORD *)(a1 + 52);
  v10 = *(_DWORD *)(a1 + 64);
  v247 = *(_DWORD *)(a1 + 60);
  v192 = *(_QWORD *)(a1 + 24);
  v244 = v6;
  v245 = *(_DWORD *)(a1 + 76);
  v11 = *(_DWORD *)(a1 + 32);
  if (v11 != v10 || v8 != *(_DWORD *)(a1 + 80))
    return result;
  v13 = *(_DWORD *)(a1 + 84);
  v236 = *v7;
  v237 = *(_DWORD *)(a1 + 44);
  v234 = *v9;
  v235 = *(_DWORD *)(a1 + 60);
  v232 = *v5;
  v233 = *(_DWORD *)(a1 + 76);
  v188 = v8;
  v189 = v11;
  if ((v2 & 2) == 0)
  {
    v14 = v8;
    v15 = v192;
    v16 = v11;
    v17 = v11;
    v18 = v8;
    v19 = v13;
    goto LABEL_37;
  }
  v20 = *(double *)(a1 + 88);
  v21 = *(_DWORD *)(a1 + 96);
  v22 = v13;
  v190 = *(_DWORD *)(a1 + 100);
  v23 = *(double *)(a1 + 104);
  v24 = *(_DWORD *)(a1 + 112);
  v185 = *(_DWORD *)(a1 + 116);
  v25 = *(double *)(a1 + 120);
  v27 = *(_DWORD *)(a1 + 128);
  v26 = *(_DWORD *)(a1 + 132);
  v28 = *(double *)(a1 + 136);
  v29 = *(_DWORD *)(a1 + 144);
  v183 = *(_DWORD *)(a1 + 148);
  *(_QWORD *)v213 = v192;
  *(_QWORD *)&v213[12] = *v7;
  v30 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)&v213[8] = v11;
  *(_DWORD *)&v213[20] = v30;
  *(_QWORD *)&v213[28] = *v9;
  v31 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)&v213[24] = v8;
  *(_DWORD *)&v213[36] = v31;
  *(_QWORD *)&v213[44] = *v5;
  v32 = *(_DWORD *)(a1 + 76);
  *(_DWORD *)&v213[40] = v11;
  *(_DWORD *)&v213[52] = v32;
  *(_DWORD *)&v213[56] = v8;
  v33 = v22;
  *(_DWORD *)&v213[60] = v22;
  v251.origin.x = FigGeometryRectGetCGRect((uint64_t)v213);
  x = v251.origin.x;
  y = v251.origin.y;
  width = v251.size.width;
  height = v251.size.height;
  MaxX = CGRectGetMaxX(v251);
  v252.origin.x = x;
  v252.origin.y = y;
  v252.size.width = width;
  v252.size.height = height;
  MaxY = CGRectGetMaxY(v252);
  if (v21 != v189 && v21 != 622862368)
    return 0;
  if (v27 != v188 && v27 != 622862368 || v24 != v189 && v24 != 622862368)
    return 0;
  result = 0;
  v39 = v29 == 622862368 || v29 == v188;
  if (!v39 || (v190 & 0x1D) != 1 || (v26 & 0x1D) != 1 || (v185 & 0x1D) != 1 || (v183 & 0x1D) != 1)
    return result;
  v13 = v33;
  if (v21 == 622862368 && v189 != 622862368)
    v20 = v20 * width / 100.0;
  v40 = v25;
  if (v27 == 622862368)
  {
    v40 = v25;
    if (v188 != 622862368)
      v40 = v25 * height / 100.0;
  }
  if (v24 == 622862368 && v189 != 622862368)
    v23 = v23 * width / 100.0;
  if (v29 == v188)
    v41 = v25;
  else
    v41 = v28;
  if (v29 == 622862368 && v188 != 622862368)
    v41 = v28 * height / 100.0;
  v193 = v192;
  v194 = v189;
  v195 = v236;
  v196 = v237;
  v197 = v188;
  v198 = v234;
  v199 = v235;
  v200 = v189;
  v201 = v232;
  v202 = v233;
  v203 = v188;
  v204 = v33;
  FigGeometryRectMakeFromCGRectAndReferenceUnits(&v193, (uint64_t)v213, x + v20, y + v40, MaxX - v23 - (x + v20), MaxY - v41 - (y + v40));
  v8 = v188;
  v11 = v189;
  v15 = *(_QWORD *)v213;
  v236 = *(_QWORD *)&v213[12];
  v16 = *(_DWORD *)&v213[8];
  v237 = *(_DWORD *)&v213[20];
  v234 = *(_QWORD *)&v213[28];
  v14 = *(_DWORD *)&v213[24];
  v235 = *(_DWORD *)&v213[36];
  v232 = *(_QWORD *)&v213[44];
  v17 = *(_DWORD *)&v213[40];
  v233 = *(_DWORD *)&v213[52];
  v5 = &v232;
  v9 = &v234;
  v7 = &v236;
  v18 = *(_DWORD *)&v213[56];
  v19 = *(_DWORD *)&v213[60];
LABEL_37:
  v230 = *v7;
  v231 = *((_DWORD *)v7 + 2);
  v228 = *v9;
  v229 = *((_DWORD *)v9 + 2);
  v227 = *((_DWORD *)v5 + 2);
  v226 = *v5;
  v242 = v230;
  v243 = v231;
  v241 = v229;
  v42 = v15;
  v240 = v228;
  v43 = v16;
  v44 = v14;
  v238 = v226;
  v45 = v17;
  v46 = v17;
  v47 = v18;
  v48 = v19;
  v239 = v227;
  v186 = v15;
  v191 = v18;
  v187 = v13;
  if ((v2 & 8) != 0)
  {
    v49 = v19;
    v50 = *(_QWORD *)(a1 + 280);
    if ((v2 & 0x10) != 0)
      v51 = *(_DWORD *)(a1 + 288);
    else
      v51 = 0;
    v218 = v236;
    v219 = v237;
    v216 = v234;
    v217 = v235;
    v214 = v232;
    v215 = v233;
    v195 = v236;
    v193 = v15;
    v194 = v16;
    v198 = v234;
    v196 = v237;
    v197 = v14;
    v199 = v235;
    v200 = v46;
    v201 = v232;
    v202 = v233;
    v203 = v18;
    v204 = v49;
    *(_QWORD *)v213 = v15;
    *(_QWORD *)&v213[12] = v236;
    *(_DWORD *)&v213[8] = v16;
    *(_DWORD *)&v213[20] = v237;
    *(_QWORD *)&v213[28] = v234;
    *(_DWORD *)&v213[24] = v14;
    *(_DWORD *)&v213[36] = v235;
    *(_QWORD *)&v213[44] = v232;
    *(_DWORD *)&v213[40] = v46;
    *(_DWORD *)&v213[52] = v233;
    *(_DWORD *)&v213[56] = v18;
    *(_DWORD *)&v213[60] = v49;
    v253.origin.x = FigGeometryRectGetCGRect((uint64_t)v213);
    v52 = v253.origin.x;
    v53 = v253.origin.y;
    v54 = v253.size.width;
    v55 = v253.size.height;
    v254 = CGRectOffset(v253, -v253.origin.x, -v253.origin.y);
    v56 = v254.origin.x;
    v57 = v254.origin.y;
    v58 = v254.size.height;
    v59 = (double)(int)v50;
    v60 = (double)SHIDWORD(v50);
    v61 = v254.size.height * (double)(int)v50 / (double)SHIDWORD(v50);
    if (v61 > v254.size.width)
    {
      v62 = v254.size.width * v60;
      v58 = v62 / v59;
      v61 = v62 / v59 * v59 / v60;
    }
    if (v51 > 1918989157)
    {
      v19 = v49;
      if (v51 <= 1920166265)
      {
        recta = v55;
        if (v51 == 1918989158 || v51 == 1918989168)
        {
          v273.origin.x = v56;
          v92 = v56;
          v273.origin.y = v57;
          v273.size.width = v61;
          v273.size.height = v58;
          v93 = v57;
          v162 = v57;
          v160 = CGRectGetWidth(v273);
          v274.origin.x = v92;
          v274.origin.y = v93;
          v274.size.width = v61;
          v274.size.height = v58;
          v94 = CGRectGetHeight(v274);
          v275.origin.x = v52;
          v275.origin.y = v53;
          v275.size.width = v54;
          v275.size.height = recta;
          v95 = CGRectGetWidth(v275);
          v276.origin.x = v52;
          v276.origin.y = v53;
          v276.size.width = v54;
          v276.size.height = recta;
          v96 = CGRectGetHeight(v276) / v94;
          if (v95 / v160 >= v96)
            v97 = v96;
          else
            v97 = v95 / v160;
          if (v95 / v160 > v96)
            v96 = v95 / v160;
          if (v51 != 1918989158)
            v96 = v97;
          v159 = v94 * v96;
          v98 = v160 * v96;
          v99 = v52 + v92;
          v277.origin.x = v52;
          v277.origin.y = v53;
          v277.size.width = v54;
          v277.size.height = recta;
          v100 = CGRectGetMaxX(v277);
          v278.origin.x = v99;
          v278.origin.y = v53 + v162;
          v278.size.width = v98;
          v278.size.height = v159;
          v178 = v100 - CGRectGetMaxX(v278);
          v279.origin.x = v52;
          v279.origin.y = v53;
          v279.size.width = v54;
          v279.size.height = recta;
          v101 = CGRectGetMaxY(v279);
          v280.origin.x = v99;
          v280.origin.y = v53 + v162;
          v280.size.width = v98;
          v280.size.height = v159;
          v102 = v101 - CGRectGetMaxY(v280);
          v15 = v186;
          v81 = v178 * 0.5;
          v76 = v102 * 0.5;
          v77 = v99;
          v78 = v53 + v162;
          v79 = v98;
          v80 = v159;
        }
        else
        {
          if (v51 != 1919510376)
            goto LABEL_87;
          v261.origin.x = v52;
          v261.origin.y = v53;
          v261.size.width = v54;
          v261.size.height = v55;
          v176 = v56;
          v71 = v57;
          v72 = CGRectGetMaxX(v261);
          v262.origin.x = v56;
          v262.origin.y = v71;
          v73 = v71;
          v262.size.width = v61;
          v262.size.height = v58;
          v74 = v72 - CGRectGetMaxX(v262);
          v263.origin.x = v52;
          v263.origin.y = v53;
          v263.size.width = v54;
          v263.size.height = recta;
          v75 = CGRectGetMaxY(v263);
          v264.origin.x = v176;
          v264.origin.y = v73;
          v264.size.width = v61;
          v264.size.height = v58;
          v76 = (v75 - CGRectGetMaxY(v264)) * 0.5;
          v77 = v176;
          v78 = v73;
          v79 = v61;
          v80 = v58;
          v81 = v74;
          v15 = v186;
        }
        v281 = CGRectOffset(*(CGRect *)&v77, v81, v76);
        v56 = v281.origin.x;
        v57 = v281.origin.y;
        v61 = v281.size.width;
        v58 = v281.size.height;
        goto LABEL_87;
      }
      if (v51 > 1953460255)
      {
        v177 = v56;
        if (v51 == 1953460256)
        {
          v293.origin.x = v52;
          v293.origin.y = v53;
          v293.size.width = v54;
          v293.size.height = v55;
          v113 = v57;
          recti = CGRectGetMaxX(v293);
          v294.origin.x = v177;
          v294.origin.y = v113;
          v294.size.width = v61;
          v294.size.height = v58;
          rectj = recti - CGRectGetMaxX(v294);
          v295.origin.x = v52;
          v295.origin.y = v53;
          v295.size.width = v54;
          v295.size.height = v55;
          MinY = CGRectGetMinY(v295);
          v296.origin.x = v177;
          v296.origin.y = v113;
          v296.size.width = v61;
          v296.size.height = v58;
          v86 = MinY - CGRectGetMinY(v296);
          v91 = rectj * 0.5;
          v87 = v177;
          v88 = v113;
          v89 = v61;
          v90 = v58;
          goto LABEL_86;
        }
        if (v51 == 1953655143)
        {
          v269.origin.x = v52;
          v269.origin.y = v53;
          v269.size.width = v54;
          v269.size.height = v55;
          v63 = v57;
          rect = CGRectGetMaxX(v269);
          v64 = v177;
          v270.origin.x = v177;
          v270.origin.y = v63;
          v270.size.width = v61;
          v270.size.height = v58;
          MinX = CGRectGetMaxX(v270);
          goto LABEL_65;
        }
      }
      else if (v51 == 1920166266)
      {
        v58 = v55;
        v61 = v54;
        v57 = v53;
        v56 = v52;
      }
      else if (v51 == 1953260902)
      {
        v255.origin.x = v52;
        v255.origin.y = v53;
        v255.size.width = v54;
        v255.size.height = v55;
        v174 = v56;
        v63 = v57;
        rect = CGRectGetMinX(v255);
        v64 = v174;
        v256.origin.x = v174;
        v256.origin.y = v63;
        v256.size.width = v61;
        v256.size.height = v58;
        MinX = CGRectGetMinX(v256);
LABEL_65:
        rectg = rect - MinX;
        v271.origin.x = v52;
        v271.origin.y = v53;
        v271.size.width = v54;
        v271.size.height = v55;
        v85 = CGRectGetMinY(v271);
        v272.origin.x = v64;
        v272.origin.y = v63;
        v272.size.width = v61;
        v272.size.height = v58;
        v86 = v85 - CGRectGetMinY(v272);
        v87 = v64;
        v88 = v63;
        v89 = v61;
        v90 = v58;
        v91 = rectg;
        v15 = v186;
LABEL_86:
        v297 = CGRectOffset(*(CGRect *)&v87, v91, v86);
        v56 = v297.origin.x;
        v57 = v297.origin.y;
        v61 = v297.size.width;
        v58 = v297.size.height;
      }
LABEL_87:
      *(_QWORD *)v213 = v15;
      *(_QWORD *)&v213[12] = v218;
      *(_DWORD *)&v213[8] = v16;
      *(_DWORD *)&v213[20] = v219;
      *(_QWORD *)&v213[28] = v216;
      *(_DWORD *)&v213[24] = v14;
      *(_DWORD *)&v213[36] = v217;
      *(_QWORD *)&v213[44] = v214;
      *(_DWORD *)&v213[40] = v46;
      *(_DWORD *)&v213[52] = v215;
      *(_DWORD *)&v213[56] = v18;
      *(_DWORD *)&v213[60] = v19;
      FigGeometryRectMakeFromCGRectAndReferenceUnits(v213, (uint64_t)&v193, v56, v57, v61, v58);
      v42 = v193;
      v224 = v195;
      v225 = v196;
      v43 = v194;
      v44 = v197;
      v222 = v198;
      v223 = v199;
      v221 = v202;
      v220 = v201;
      v45 = v200;
      v47 = v203;
      v48 = v204;
      v237 = v196;
      v236 = v195;
      v235 = v199;
      v234 = v198;
      v233 = v202;
      v232 = v201;
      v8 = v188;
      v11 = v189;
      goto LABEL_88;
    }
    v19 = v49;
    v175 = v56;
    if (v51 > 1651665254)
    {
      if (v51 == 1651665255)
      {
        v288.origin.x = v52;
        v288.origin.y = v53;
        v288.size.width = v54;
        v288.size.height = v55;
        v82 = v57;
        rectc = CGRectGetMaxX(v288);
        v83 = v175;
        v289.origin.x = v175;
        v289.origin.y = v82;
        v289.size.width = v61;
        v289.size.height = v58;
        v111 = CGRectGetMaxX(v289);
LABEL_81:
        rectb = rectc - v111;
        v290.origin.x = v52;
        v290.origin.y = v53;
        v290.size.width = v54;
        v290.size.height = v55;
        v112 = CGRectGetMaxY(v290);
        v291.origin.x = v83;
        v291.origin.y = v82;
        v291.size.width = v61;
        v291.size.height = v58;
        v69 = v112 - CGRectGetMaxY(v291);
LABEL_82:
        v107 = v83;
        v108 = v82;
        v109 = v61;
        v110 = v58;
        v70 = rectb;
        v15 = v186;
        goto LABEL_83;
      }
      if (v51 != 1667591796)
      {
        if (v51 != 1818584692)
          goto LABEL_87;
        v265.origin.x = v52;
        v265.origin.y = v53;
        v265.size.width = v54;
        v265.size.height = v55;
        v82 = v57;
        rectf = CGRectGetMinX(v265);
        v83 = v175;
        v266.origin.x = v175;
        v266.origin.y = v82;
        v266.size.width = v61;
        v266.size.height = v58;
        rectb = rectf - CGRectGetMinX(v266);
        v267.origin.x = v52;
        v267.origin.y = v53;
        v267.size.width = v54;
        v267.size.height = v55;
        v84 = CGRectGetMaxY(v267);
        v268.origin.x = v175;
        v268.origin.y = v82;
        v268.size.width = v61;
        v268.size.height = v58;
        v69 = (v84 - CGRectGetMaxY(v268)) * 0.5;
        goto LABEL_82;
      }
    }
    else if (v51)
    {
      if (v51 != 1651271014)
      {
        if (v51 != 1651471476)
          goto LABEL_87;
        v257.origin.x = v52;
        v257.origin.y = v53;
        v257.size.width = v54;
        v257.size.height = v55;
        v66 = v57;
        rectd = CGRectGetMaxX(v257);
        v258.origin.x = v175;
        v258.origin.y = v66;
        v258.size.width = v61;
        v258.size.height = v58;
        recte = rectd - CGRectGetMaxX(v258);
        v259.origin.x = v52;
        v259.origin.y = v53;
        v259.size.width = v54;
        v259.size.height = v55;
        v67 = CGRectGetMaxY(v259);
        v68 = v175;
        v260.origin.x = v175;
        v260.origin.y = v66;
        v260.size.width = v61;
        v260.size.height = v58;
        v69 = v67 - CGRectGetMaxY(v260);
        v70 = recte * 0.5;
        goto LABEL_77;
      }
      v286.origin.x = v52;
      v286.origin.y = v53;
      v286.size.width = v54;
      v286.size.height = v55;
      v82 = v57;
      rectc = CGRectGetMinX(v286);
      v83 = v175;
      v287.origin.x = v175;
      v287.origin.y = v82;
      v287.size.width = v61;
      v287.size.height = v58;
      v111 = CGRectGetMinX(v287);
      goto LABEL_81;
    }
    v282.origin.x = v52;
    v282.origin.y = v53;
    v282.size.width = v54;
    v282.size.height = v55;
    v161 = v54;
    v103 = v57;
    v104 = CGRectGetMaxX(v282);
    v283.origin.x = v56;
    v283.origin.y = v103;
    v66 = v103;
    v283.size.width = v61;
    v283.size.height = v58;
    recth = v104 - CGRectGetMaxX(v283);
    v284.origin.x = v52;
    v284.origin.y = v53;
    v284.size.width = v161;
    v284.size.height = v55;
    v105 = CGRectGetMaxY(v284);
    v68 = v175;
    v285.origin.x = v175;
    v285.origin.y = v66;
    v285.size.width = v61;
    v285.size.height = v58;
    v106 = v105 - CGRectGetMaxY(v285);
    v15 = v186;
    v70 = recth * 0.5;
    v69 = v106 * 0.5;
LABEL_77:
    v107 = v68;
    v108 = v66;
    v109 = v61;
    v110 = v58;
LABEL_83:
    v292 = CGRectOffset(*(CGRect *)&v107, v70, v69);
    v56 = v292.origin.x;
    v57 = v292.origin.y;
    v61 = v292.size.width;
    v58 = v292.size.height;
    goto LABEL_87;
  }
LABEL_88:
  v179 = v42;
  v180 = v16;
  v182 = v46;
  v184 = v14;
  v115 = *(_OWORD *)(a1 + 232);
  v209 = *(_OWORD *)(a1 + 216);
  v210 = v115;
  v116 = *(_OWORD *)(a1 + 264);
  v211 = *(_OWORD *)(a1 + 248);
  v212 = v116;
  *(_QWORD *)v213 = v192;
  *(_QWORD *)&v213[12] = v248;
  *(_DWORD *)&v213[8] = v11;
  *(_DWORD *)&v213[20] = v249;
  *(_QWORD *)&v213[28] = v246;
  *(_DWORD *)&v213[24] = v8;
  *(_DWORD *)&v213[36] = v247;
  *(_QWORD *)&v213[44] = v244;
  *(_DWORD *)&v213[40] = v11;
  *(_DWORD *)&v213[52] = v245;
  *(_DWORD *)&v213[56] = v8;
  *(_DWORD *)&v213[60] = v13;
  v117 = v45;
  v118 = v8;
  v119 = v11;
  v120 = v44;
  v121 = v43;
  v122 = v47;
  v123 = v48;
  v124 = FigGeometryRectGetCGRect((uint64_t)v213);
  v126 = v125;
  v128 = v127;
  v130 = v129;
  *(_QWORD *)v213 = v42;
  *(_QWORD *)&v213[12] = v236;
  *(_DWORD *)&v213[8] = v121;
  *(_DWORD *)&v213[20] = v237;
  *(_QWORD *)&v213[28] = v234;
  *(_DWORD *)&v213[24] = v120;
  *(_DWORD *)&v213[36] = v235;
  *(_QWORD *)&v213[44] = v232;
  *(_DWORD *)&v213[40] = v117;
  *(_DWORD *)&v213[52] = v233;
  *(_DWORD *)&v213[56] = v122;
  *(_DWORD *)&v213[60] = v123;
  v131 = FigGeometryRectGetCGRect((uint64_t)v213);
  v133 = v132;
  v135 = v134;
  v137 = v136;
  *(_OWORD *)v213 = v209;
  *(_OWORD *)&v213[16] = v210;
  *(_OWORD *)&v213[32] = v211;
  *(_OWORD *)&v213[48] = v212;
  FigGeometryRectGetCGRect((uint64_t)v213);
  v139 = v138 / v135;
  v141 = v140 / v137;
  v142 = v133 - v126;
  v143 = -((v131 - v124) * v139);
  v144 = 0.0;
  if (v131 - v124 == 0.0)
    v143 = 0.0;
  if (v142 != 0.0)
    v144 = -(v142 * v141);
  v145 = (v131 - v124) / v128;
  v146 = v142 / v130;
  *(_OWORD *)v213 = v209;
  *(_OWORD *)&v213[16] = v210;
  *(_OWORD *)&v213[32] = v211;
  *(_OWORD *)&v213[48] = v212;
  FigGeometryRectMakeFromCGRectAndReferenceUnits(v213, (uint64_t)&v205, v143, v144, v128 * v139, v130 * v141);
  *(_QWORD *)a2 = v192;
  *(_DWORD *)(a2 + 8) = v119;
  *(_QWORD *)(a2 + 12) = v248;
  *(_DWORD *)(a2 + 20) = v249;
  *(_DWORD *)(a2 + 24) = v118;
  *(_QWORD *)(a2 + 28) = v246;
  *(_DWORD *)(a2 + 36) = v247;
  *(_DWORD *)(a2 + 40) = v119;
  *(_QWORD *)(a2 + 44) = v244;
  *(_DWORD *)(a2 + 52) = v245;
  *(_DWORD *)(a2 + 56) = v118;
  *(_DWORD *)(a2 + 60) = v187;
  *(_QWORD *)(a2 + 64) = v186;
  *(_DWORD *)(a2 + 72) = v180;
  v147 = v243;
  *(_QWORD *)(a2 + 76) = v242;
  *(_DWORD *)(a2 + 84) = v147;
  *(_DWORD *)(a2 + 88) = v184;
  v148 = v241;
  *(_QWORD *)(a2 + 92) = v240;
  *(_DWORD *)(a2 + 100) = v148;
  *(_DWORD *)(a2 + 104) = v182;
  v149 = v239;
  *(_QWORD *)(a2 + 108) = v238;
  *(_DWORD *)(a2 + 116) = v149;
  *(_DWORD *)(a2 + 120) = v191;
  *(_DWORD *)(a2 + 124) = v19;
  *(_QWORD *)(a2 + 128) = v179;
  *(_DWORD *)(a2 + 136) = v121;
  v150 = v237;
  *(_QWORD *)(a2 + 140) = v236;
  *(_DWORD *)(a2 + 148) = v150;
  *(_DWORD *)(a2 + 152) = v120;
  v151 = v235;
  *(_QWORD *)(a2 + 156) = v234;
  *(_DWORD *)(a2 + 164) = v151;
  *(_DWORD *)(a2 + 168) = v117;
  v152 = v233;
  *(_QWORD *)(a2 + 172) = v232;
  *(_DWORD *)(a2 + 180) = v152;
  *(_DWORD *)(a2 + 184) = v122;
  *(_DWORD *)(a2 + 188) = v123;
  v153 = v209;
  v154 = v210;
  v155 = v212;
  *(_OWORD *)(a2 + 224) = v211;
  *(_OWORD *)(a2 + 240) = v155;
  *(_OWORD *)(a2 + 192) = v153;
  *(_OWORD *)(a2 + 208) = v154;
  v156 = v205;
  v157 = v206;
  v158 = v208;
  *(_OWORD *)(a2 + 288) = v207;
  *(_OWORD *)(a2 + 304) = v158;
  *(_OWORD *)(a2 + 256) = v156;
  *(_OWORD *)(a2 + 272) = v157;
  *(double *)(a2 + 320) = v145;
  *(double *)(a2 + 328) = v146;
  result = 1;
  *(double *)(a2 + 336) = v135 / v128;
  *(double *)(a2 + 344) = v137 / v130;
  return result;
}

